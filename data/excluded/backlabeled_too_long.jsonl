{"instruction": "Represents a base class that is common to most RhinoCommon curve types.", "code": "class Curve(GeometryBase,IDisposable,ISerializable):\n \"\"\"\n Represents a base class that is common to most RhinoCommon curve types.\n\n    A curve represents an entity that can be all visited by providing\n\n    a single parameter,usually called t.\n \"\"\"\n def ChangeClosedCurveSeam(self,t):\n  \"\"\"\n  ChangeClosedCurveSeam(self: Curve,t: float) -> bool\n\n  \n\n   If this curve is closed,then modify it so that the start/end point is at curve parameter t.\n\n  \n\n   t: Curve parameter of new start/end point. The returned curves domain will start at t.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def ChangeDimension(self,desiredDimension):\n  \"\"\"\n  ChangeDimension(self: Curve,desiredDimension: int) -> bool\n\n  \n\n   Changes the dimension of a curve.\n\n  \n\n   desiredDimension: The desired dimension.\n\n   Returns: true if the curve's dimension was already desiredDimension\n\n     or if the curve's \n\n    dimension was successfully changed to desiredDimension;\n\n     otherwise false.\n  \"\"\"\n  pass\n def ClosedCurveOrientation(self,*__args):\n  \"\"\"\n  ClosedCurveOrientation(self: Curve,xform: Transform) -> CurveOrientation\n\n  \n\n   Determines the orientation (counterclockwise or clockwise) of a closed planar curve.\n\n       \n\n     Only works with simple (no self intersections) closed planar curves.\n\n  \n\n  \n\n   xform: Transformation to map the curve to the xy plane. If the curve is parallel\n\n     to the xy \n\n    plane,you may pass Identity matrix.\n\n  \n\n   Returns: The orientation of this curve in the world xy-plane.\n\n  ClosedCurveOrientation(self: Curve,plane: Plane) -> CurveOrientation\n\n  \n\n   Determines the orientation (counterclockwise or clockwise) of a closed planar curve in a given \n\n    plane.\n\n     Only works with simple (no self intersections) closed planar curves.\n\n  \n\n  \n\n   plane: The plane in which to solve the orientation.\n\n   Returns: The orientation of this curve in the given plane.\n\n  ClosedCurveOrientation(self: Curve,upDirection: Vector3d) -> CurveOrientation\n\n  \n\n   Determines the orientation (counterclockwise or clockwise) of a closed planar curve in a given \n\n    plane.\n\n     Only works with simple (no self intersections) closed planar curves.\n\n  \n\n  \n\n   upDirection: A vector that is considered \"up\".\n\n   Returns: The orientation of this curve with respect to a defined up direction.\n  \"\"\"\n  pass\n def ClosestPoint(self,testPoint,t,maximumDistance=None):\n  \"\"\"\n  ClosestPoint(self: Curve,testPoint: Point3d,maximumDistance: float) -> (bool,float)\n\n  \n\n   Finds the parameter of the point on a curve that is closest to testPoint.\n\n     If the \n\n    maximumDistance parameter is > 0,then only points whose distance\n\n     to the given \n\n    point is <= maximumDistance will be returned.  Using a \n\n     positive value of \n\n    maximumDistance can substantially speed up the search.\n\n  \n\n  \n\n   testPoint: Point to project.\n\n   maximumDistance: The maximum allowed distance.\n\n     Past this distance,the search is given up and false \n\n    is returned.Use 0 to turn off this parameter.\n\n  \n\n   Returns: true on success,false on failure.\n\n  ClosestPoint(self: Curve,testPoint: Point3d) -> (bool,float)\n\n  \n\n   Finds parameter of the point on a curve that is closest to testPoint.\n\n     If the \n\n    maximumDistance parameter is > 0,then only points whose distance\n\n     to the given \n\n    point is <= maximumDistance will be returned.  Using a \n\n     positive value of \n\n    maximumDistance can substantially speed up the search.\n\n  \n\n  \n\n   testPoint: Point to search from.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def ClosestPoints(self,*__args):\n  \"\"\"\n  ClosestPoints(self: Curve,otherCurve: Curve) -> (bool,Point3d,Point3d)\n\n  \n\n   Gets closest points between this and another curves.\n\n  \n\n   otherCurve: The other curve.\n\n   Returns: true on success; false on error.\n\n  ClosestPoints(self: Curve,geometry: IEnumerable[GeometryBase]) -> (bool,Point3d,Point3d,int)\n\n  ClosestPoints(self: Curve,geometry: IEnumerable[GeometryBase],maximumDistance: float) -> (bool,Point3d,Point3d,int)\n  \"\"\"\n  pass\n def ConstructConstObject(self,*args):\n  \"\"\"\n  ConstructConstObject(self: CommonObject,parentObject: object,subobject_index: int)\n\n   Assigns a parent object and a subobject index to this.\n\n  \n\n   parentObject: The parent object.\n\n   subobject_index: The subobject index.\n  \"\"\"\n  pass\n def Contains(self,testPoint,plane=None,tolerance=None):\n  \"\"\"\n  Contains(self: Curve,testPoint: Point3d,plane: Plane,tolerance: float) -> PointContainment\n\n  \n\n   Computes the relationship between a point and a closed curve region. \n\n     This curve \n\n    must be closed or the return value will be Unset.\n\n  \n\n  \n\n   testPoint: Point to test.\n\n   plane: Plane in in which to compare point and region.\n\n   tolerance: Tolerance to use during comparison.\n\n   Returns: Relationship between point and curve region.\n\n  Contains(self: Curve,testPoint: Point3d,plane: Plane) -> PointContainment\n\n  \n\n   Computes the relationship between a point and a closed curve region. \n\n     This curve \n\n    must be closed or the return value will be Unset.\n\n  \n\n  \n\n   testPoint: Point to test.\n\n   plane: Plane in in which to compare point and region.\n\n   Returns: Relationship between point and curve region.\n\n  Contains(self: Curve,testPoint: Point3d) -> PointContainment\n\n  \n\n   Computes the relationship between a point and a closed curve region. \n\n     This curve \n\n    must be closed or the return value will be Unset.\n\n     Both curve and point are \n\n    projected to the World XY plane.\n\n  \n\n  \n\n   testPoint: Point to test.\n\n   Returns: Relationship between point and curve region.\n  \"\"\"\n  pass\n @staticmethod\n def CreateBlendCurve(*__args):\n  \"\"\"\n  CreateBlendCurve(curve0: Curve,t0: float,reverse0: bool,continuity0: BlendContinuity,curve1: Curve,t1: float,reverse1: bool,continuity1: BlendContinuity) -> Curve\n\n  \n\n   Makes a curve blend between 2 curves at the parameters specified\n\n     with the \n\n    directions and continuities specified\n\n  \n\n  \n\n   curve0: First curve to blend from\n\n   t0: Parameter on first curve for blend endpoint\n\n   reverse0: If false,the blend will go in the natural direction of the curve.\n\n     If true,the \n\n    blend will go in the opposite direction to the curve\n\n  \n\n   continuity0: continuity for the blend at the start\n\n   curve1: Second curve to blend from\n\n   t1: Parameter on second curve for blend endpoint\n\n   reverse1: If false,the blend will go in the natural direction of the curve.\n\n     If true,the \n\n    blend will go in the opposite direction to the curve\n\n  \n\n   continuity1: continuity for the blend at the end\n\n   Returns: the blend curve on success. null on failure\n\n  CreateBlendCurve(curveA: Curve,curveB: Curve,continuity: BlendContinuity,bulgeA: float,bulgeB: float) -> Curve\n\n  \n\n   Create a Blend curve between two existing curves.\n\n  \n\n   curveA: Curve to blend from (blending will occur at curve end point).\n\n   curveB: Curve to blend to (blending will occur at curve start point).\n\n   continuity: Continuity of blend.\n\n   bulgeA: Bulge factor at curveA end of blend. Values near 1.0 work best.\n\n   bulgeB: Bulge factor at curveB end of blend. Values near 1.0 work best.\n\n   Returns: A curve representing the blend between A and B or null on failure.\n\n  CreateBlendCurve(curveA: Curve,curveB: Curve,continuity: BlendContinuity) -> Curve\n\n  \n\n   Create a Blend curve between two existing curves.\n\n  \n\n   curveA: Curve to blend from (blending will occur at curve end point).\n\n   curveB: Curve to blend to (blending will occur at curve start point).\n\n   continuity: Continuity of blend.\n\n   Returns: A curve representing the blend between A and B or null on failure.\n  \"\"\"\n  pass\n @staticmethod\n def CreateBooleanDifference(curveA,*__args):\n  \"\"\"\n  CreateBooleanDifference(curveA: Curve,subtractors: IEnumerable[Curve]) -> Array[Curve]\n\n  CreateBooleanDifference(curveA: Curve,curveB: Curve) -> Array[Curve]\n\n  \n\n   Calculates the boolean difference between two closed,planar curves. \n\n     Note,curves \n\n    must be co-planar.\n\n  \n\n  \n\n   curveA: The first closed,planar curve.\n\n   curveB: The second closed,planar curve.\n\n   Returns: Result curves on success,empty array if no difference could be calculated.\n  \"\"\"\n  pass\n @staticmethod\n def CreateBooleanIntersection(curveA,curveB):\n  \"\"\"\n  CreateBooleanIntersection(curveA: Curve,curveB: Curve) -> Array[Curve]\n\n  \n\n   Calculates the boolean intersection of two closed,planar curves. \n\n     Note,curves \n\n    must be co-planar.\n\n  \n\n  \n\n   curveA: The first closed,planar curve.\n\n   curveB: The second closed,planar curve.\n\n   Returns: Result curves on success,empty array if no intersection could be calculated.\n  \"\"\"\n  pass\n @staticmethod\n def CreateBooleanUnion(curves):\n  \"\"\" CreateBooleanUnion(curves: IEnumerable[Curve]) -> Array[Curve] \"\"\"\n  pass\n @staticmethod\n def CreateControlPointCurve(points,degree=None):\n  \"\"\"\n  CreateControlPointCurve(points: IEnumerable[Point3d]) -> Curve\n\n  CreateControlPointCurve(points: IEnumerable[Point3d],degree: int) -> Curve\n  \"\"\"\n  pass\n @staticmethod\n def CreateFillet(curve0,curve1,radius,t0Base,t1Base):\n  \"\"\"\n  CreateFillet(curve0: Curve,curve1: Curve,radius: float,t0Base: float,t1Base: float) -> Arc\n\n  \n\n   Computes the fillet arc for a curve filleting operation.\n\n  \n\n   curve0: First curve to fillet.\n\n   curve1: Second curve to fillet.\n\n   radius: Fillet radius.\n\n   t0Base: Parameter on curve0 where the fillet ought to start (approximately).\n\n   t1Base: Parameter on curve1 where the fillet ought to end (approximately).\n\n   Returns: The fillet arc on success,or Arc.Unset on failure.\n  \"\"\"\n  pass\n @staticmethod\n def CreateFilletCurves(curve0,point0,curve1,point1,radius,join,trim,arcExtension,tolerance,angleTolerance):\n  \"\"\"\n  CreateFilletCurves(curve0: Curve,point0: Point3d,curve1: Curve,point1: Point3d,radius: float,join: bool,trim: bool,arcExtension: bool,tolerance: float,angleTolerance: float) -> Array[Curve]\n\n  \n\n   Creates a tangent arc between two curves and trims or extends the curves to the arc.\n\n  \n\n   curve0: The first curve to fillet.\n\n   point0: A point on the first curve that is near the end where the fillet will\n\n     be created.\n\n   curve1: The second curve to fillet.\n\n   point1: A point on the second curve that is near the end where the fillet will\n\n     be created.\n\n   radius: The radius of the fillet.\n\n   join: Join the output curves.\n\n   trim: Trim copies of the input curves to the output fillet curve.\n\n   arcExtension: Applies when arcs are filleted but need to be extended to meet the\n\n     fillet curve or \n\n    chamfer line. If true,then the arc is extended\n\n     maintaining its validity. If false,\n\n    then the arc is extended with a\n\n     line segment,which is joined to the arc converting \n\n    it to a polycurve.\n\n  \n\n   tolerance: The tolerance,generally the document's absolute tolerance.\n\n   Returns: The results of the fillet operation. The number of output curves depends\n\n     on the \n\n    input curves and the values of the parameters that were used\n\n     during the fillet \n\n    operation. In most cases,the output array will contain\n\n     either one or three curves,\n\n    although two curves can be returned if the\n\n     radius is zero and join=false.\n\n      \n\n      For example,if both join and trim=true,then the output curve\n\n     will be a \n\n    polycurve containing the fillet curve joined with trimmed copies\n\n     of the input \n\n    curves. If join=false and trim=true,then three curves,\n\n     the fillet curve and \n\n    trimmed copies of the input curves,will be returned.\n\n     If both join and trim=\n\n    false,then just the fillet curve is returned.\n  \"\"\"\n  pass\n @staticmethod\n def CreateInterpolatedCurve(points,degree,knots=None,startTangent=None,endTangent=None):\n  \"\"\"\n  CreateInterpolatedCurve(points: IEnumerable[Point3d],degree: int,knots: CurveKnotStyle,startTangent: Vector3d,endTangent: Vector3d) -> Curve\n\n  CreateInterpolatedCurve(points: IEnumerable[Point3d],degree: int,knots: CurveKnotStyle) -> Curve\n\n  CreateInterpolatedCurve(points: IEnumerable[Point3d],degree: int) -> Curve\n  \"\"\"\n  pass\n @staticmethod\n def CreateMeanCurve(curveA,curveB,angleToleranceRadians=None):\n  \"\"\"\n  CreateMeanCurve(curveA: Curve,curveB: Curve) -> Curve\n\n  \n\n   Constructs a mean,or average,curve from two curves.\n\n  \n\n   curveA: A first curve.\n\n   curveB: A second curve.\n\n   Returns: The average curve,or null on error.\n\n  CreateMeanCurve(curveA: Curve,curveB: Curve,angleToleranceRadians: float) -> Curve\n\n  \n\n   Constructs a mean,or average,curve from two curves.\n\n  \n\n   curveA: A first curve.\n\n   curveB: A second curve.\n\n   angleToleranceRadians: The angle tolerance,in radians,used to match kinks between curves.\n\n     If you are \n\n    unsure how to set this parameter,then either use the\n\n     document's angle tolerance \n\n    RhinoDoc.AngleToleranceRadians,\n\n     or the default value (RhinoMath.UnsetValue)\n\n  \n\n   Returns: The average curve,or null on error.\n  \"\"\"\n  pass\n @staticmethod\n def CreateTweenCurves(curve0,curve1,numCurves):\n  \"\"\"\n  CreateTweenCurves(curve0: Curve,curve1: Curve,numCurves: int) -> Array[Curve]\n\n  \n\n   Creates curves between two open or closed input curves. Uses the control points of the curves \n\n    for finding tween curves.\n\n     That means the first control point of first curve is \n\n    matched to first control point of the second curve and so on.\n\n     There is no matching \n\n    of curves direction. Caller must match input curves direction before calling the function.\n\n  \n\n  \n\n   curve0: The first,or starting,curve.\n\n   curve1: The second,or ending,curve.\n\n   numCurves: Number of tween curves to create.\n\n   Returns: An array of joint curves. This array can be empty.\n  \"\"\"\n  pass\n @staticmethod\n def CreateTweenCurvesWithMatching(curve0,curve1,numCurves):\n  \"\"\"\n  CreateTweenCurvesWithMatching(curve0: Curve,curve1: Curve,numCurves: int) -> Array[Curve]\n\n  \n\n   Creates curves between two open or closed input curves. Make the structure of input curves \n\n    compatible if needed.\n\n     Refits the input curves to have the same structure. The \n\n    resulting curves are usually more complex than input unless\n\n     input curves are \n\n    compatible and no refit is needed. There is no matching of curves direction.\n\n     Caller \n\n    must match input curves direction before calling the function.\n\n  \n\n  \n\n   curve0: The first,or starting,curve.\n\n   curve1: The second,or ending,curve.\n\n   numCurves: Number of tween curves to create.\n\n   Returns: An array of joint curves. This array can be empty.\n  \"\"\"\n  pass\n @staticmethod\n def CreateTweenCurvesWithSampling(curve0,curve1,numCurves,numSamples):\n  \"\"\"\n  CreateTweenCurvesWithSampling(curve0: Curve,curve1: Curve,numCurves: int,numSamples: int) -> Array[Curve]\n\n  \n\n   Creates curves between two open or closed input curves. Use sample points method to make curves \n\n    compatible.\n\n     This is how the algorithm workd: Divides the two curves into an equal \n\n    number of points,finds the midpoint between the \n\n     corresponding points on the \n\n    curves and interpolates the tween curve through those points. There is no matching of curves\n\n     \n\n       direction. Caller must match input curves direction before calling the function.\n\n  \n\n  \n\n   curve0: The first,or starting,curve.\n\n   curve1: The second,or ending,curve.\n\n   numCurves: Number of tween curves to create.\n\n   numSamples: Number of sample points along input curves.\n\n   Returns: >An array of joint curves. This array can be empty.\n  \"\"\"\n  pass\n def CurvatureAt(self,t):\n  \"\"\"\n  CurvatureAt(self: Curve,t: float) -> Vector3d\n\n  \n\n   Evaluate the curvature vector at a curve parameter.\n\n  \n\n   t: Evaluation parameter.\n\n   Returns: Curvature vector of the curve at the parameter t.\n  \"\"\"\n  pass\n def DerivativeAt(self,t,derivativeCount,side=None):\n  \"\"\"\n  DerivativeAt(self: Curve,t: float,derivativeCount: int,side: CurveEvaluationSide) -> Array[Vector3d]\n\n  \n\n   Evaluate the derivatives at the specified curve parameter.\n\n  \n\n   t: Curve parameter to evaluate.\n\n   derivativeCount: Number of derivatives to evaluate,must be at least 0.\n\n   side: Side of parameter to evaluate. If the parameter is at a kink,\n\n     it makes a big \n\n    difference whether the evaluation is from below or above.\n\n  \n\n   Returns: An array of vectors that represents all the derivatives starting at zero.\n\n  DerivativeAt(self: Curve,t: float,derivativeCount: int) -> Array[Vector3d]\n\n  \n\n   Evaluate the derivatives at the specified curve parameter.\n\n  \n\n   t: Curve parameter to evaluate.\n\n   derivativeCount: Number of derivatives to evaluate,must be at least 0.\n\n   Returns: An array of vectors that represents all the derivatives starting at zero.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\"\n  Dispose(self: Curve,disposing: bool)\n\n   For derived class implementers.\n\n     This method is called with argument true when class \n\n    user calls Dispose(),while with argument false when\n\n     the Garbage Collector invokes \n\n    the finalizer,or Finalize() method.You must reclaim all used unmanaged resources in both cases,\n\n    and can use this chance to call Dispose on disposable fields if the argument is true.Also,you \n\n    must call the base virtual method within your overriding method.\n\n  \n\n  \n\n   disposing: true if the call comes from the Dispose() method; false if it comes from the Garbage Collector \n\n    finalizer.\n  \"\"\"\n  pass\n def DivideAsContour(self,contourStart,contourEnd,interval):\n  \"\"\"\n  DivideAsContour(self: Curve,contourStart: Point3d,contourEnd: Point3d,interval: float) -> Array[Point3d]\n\n  \n\n   Divides this curve at fixed steps along a defined contour line.\n\n  \n\n   contourStart: The start of the contouring line.\n\n   contourEnd: The end of the contouring line.\n\n   interval: A distance to measure on the contouring axis.\n\n   Returns: An array of points; or null on error.\n  \"\"\"\n  pass\n def DivideByCount(self,segmentCount,includeEnds,points=None):\n  \"\"\"\n  DivideByCount(self: Curve,segmentCount: int,includeEnds: bool) -> (Array[float],Array[Point3d])\n\n  \n\n   Divide the curve into a number of equal-length segments.\n\n  \n\n   segmentCount: Segment count. Note that the number of division points may differ from the segment count.\n\n   includeEnds: If true,then the points at the start and end of the curve are included.\n\n   Returns: Array containing division curve parameters on success,null on failure.\n\n  DivideByCount(self: Curve,segmentCount: int,includeEnds: bool) -> Array[float]\n\n  \n\n   Divide the curve into a number of equal-length segments.\n\n  \n\n   segmentCount: Segment count. Note that the number of division points may differ from the segment count.\n\n   includeEnds: If true,then the points at the start and end of the curve are included.\n\n   Returns: List of curve parameters at the division points on success,null on failure.\n  \"\"\"\n  pass\n def DivideByLength(self,segmentLength,includeStart,points=None):\n  \"\"\"\n  DivideByLength(self: Curve,segmentLength: float,includeStart: bool) -> (Array[float],Array[Point3d])\n\n  \n\n   Divide the curve into specific length segments.\n\n  \n\n   segmentLength: The length of each and every segment (except potentially the last one).\n\n   includeStart: If true,then the point at the start of the curve is included.\n\n   Returns: Array containing division curve parameters if successful,null on failure.\n\n  DivideByLength(self: Curve,segmentLength: float,includeStart: bool) -> Array[float]\n\n  \n\n   Divide the curve into specific length segments.\n\n  \n\n   segmentLength: The length of each and every segment (except potentially the last one).\n\n   includeStart: If true,then the points at the start of the curve is included.\n\n   Returns: Array containing division curve parameters if successful,null on failure.\n  \"\"\"\n  pass\n def DivideEquidistant(self,distance):\n  \"\"\"\n  DivideEquidistant(self: Curve,distance: float) -> Array[Point3d]\n\n  \n\n   Calculates 3d points on a curve where the linear distance between the points is equal.\n\n  \n\n   distance: The distance betwen division points.\n\n   Returns: An array of equidistant points,or null on error.\n  \"\"\"\n  pass\n @staticmethod\n def DoDirectionsMatch(curveA,curveB):\n  \"\"\"\n  DoDirectionsMatch(curveA: Curve,curveB: Curve) -> bool\n\n  \n\n   Determines whether two curves travel more or less in the same direction.\n\n  \n\n   curveA: First curve to test.\n\n   curveB: Second curve to test.\n\n   Returns: true if both curves more or less point in the same direction,\n\n     false if they point \n\n    in the opposite directions.\n  \"\"\"\n  pass\n def Duplicate(self):\n  \"\"\"\n  Duplicate(self: Curve) -> GeometryBase\n\n  \n\n   Constructs an exact duplicate of this Curve.\n  \"\"\"\n  pass\n def DuplicateCurve(self):\n  \"\"\"\n  DuplicateCurve(self: Curve) -> Curve\n\n  \n\n   Constructs an exact duplicate of this curve.\n\n   Returns: An exact copy of this curve.\n  \"\"\"\n  pass\n def DuplicateSegments(self):\n  \"\"\"\n  DuplicateSegments(self: Curve) -> Array[Curve]\n\n  \n\n   Polylines will be exploded into line segments. ExplodeCurves will\n\n     return the curves \n\n    in topological order.\n\n  \n\n   Returns: An array of all the segments that make up this curve.\n  \"\"\"\n  pass\n def Extend(self,*__args):\n  \"\"\"\n  Extend(self: Curve,side: CurveEnd,style: CurveExtensionStyle,geometry: IEnumerable[GeometryBase]) -> Curve\n\n  Extend(self: Curve,side: CurveEnd,style: CurveExtensionStyle,endPoint: Point3d) -> Curve\n\n  \n\n   Extends a curve to a point.\n\n  \n\n   side: The end of the curve to extend.\n\n   style: The style or type of extension to use.\n\n   endPoint: A new end point.\n\n   Returns: New extended curve result on success,null on failure.\n\n  Extend(self: Curve,side: CurveEnd,length: float,style: CurveExtensionStyle) -> Curve\n\n  \n\n   Extends a curve by a specific length.\n\n  \n\n   side: Curve end to extend.\n\n   length: Length to add to the curve end.\n\n   style: Extension style.\n\n   Returns: A curve with extended ends or null on failure.\n\n  Extend(self: Curve,t0: float,t1: float) -> Curve\n\n  \n\n   Where possible,analytically extends curve to include the given domain. \n\n     This will \n\n    not work on closed curves. The original curve will be identical to the \n\n     restriction \n\n    of the resulting curve to the original curve domain.\n\n  \n\n  \n\n   t0: Start of extension domain,if the start is not inside the \n\n     Domain of this curve,an \n\n    attempt will be made to extend the curve.\n\n  \n\n   t1: End of extension domain,if the end is not inside the \n\n     Domain of this curve,an \n\n    attempt will be made to extend the curve.\n\n  \n\n   Returns: Extended curve on success,null on failure.\n\n  Extend(self: Curve,domain: Interval) -> Curve\n\n  \n\n   Where possible,analytically extends curve to include the given domain. \n\n     This will \n\n    not work on closed curves. The original curve will be identical to the \n\n     restriction \n\n    of the resulting curve to the original curve domain.\n\n  \n\n  \n\n   domain: Extension domain.\n\n   Returns: Extended curve on success,null on failure.\n  \"\"\"\n  pass\n def ExtendByArc(self,side,geometry):\n  \"\"\" ExtendByArc(self: Curve,side: CurveEnd,geometry: IEnumerable[GeometryBase]) -> Curve \"\"\"\n  pass\n def ExtendByLine(self,side,geometry):\n  \"\"\" ExtendByLine(self: Curve,side: CurveEnd,geometry: IEnumerable[GeometryBase]) -> Curve \"\"\"\n  pass\n def ExtendOnSurface(self,side,*__args):\n  \"\"\"\n  ExtendOnSurface(self: Curve,side: CurveEnd,face: BrepFace) -> Curve\n\n  \n\n   Extends a curve on a surface.\n\n  \n\n   side: The end of the curve to extend.\n\n   face: BrepFace that contains the curve.\n\n   Returns: New extended curve result on success,null on failure.\n\n  ExtendOnSurface(self: Curve,side: CurveEnd,surface: Surface) -> Curve\n\n  \n\n   Extends a curve on a surface.\n\n  \n\n   side: The end of the curve to extend.\n\n   surface: Surface that contains the curve.\n\n   Returns: New extended curve result on success,null on failure.\n  \"\"\"\n  pass\n def Fair(self,distanceTolerance,angleTolerance,clampStart,clampEnd,iterations):\n  \"\"\"\n  Fair(self: Curve,distanceTolerance: float,angleTolerance: float,clampStart: int,clampEnd: int,iterations: int) -> Curve\n\n  \n\n   Fairs a curve object. Fair works best on degree 3 (cubic) curves. Attempts to \n\n     \n\n    remove large curvature variations while limiting the geometry changes to be no \n\n     \n\n    more than the specified tolerance.\n\n  \n\n  \n\n   distanceTolerance: Maximum allowed distance the faired curve is allowed to deviate from the input.\n\n   angleTolerance: (in radians) kinks with angles <= angleTolerance are smoothed out 0.05 is a good default.\n\n   clampStart: The number of (control vertices-1) to preserve at start. \n\n     0=preserve start point1 \n\n   =preserve start point and 1st derivative2=preserve start point,1st and 2nd derivative\n\n  \n\n   clampEnd: Same as clampStart.\n\n   iterations: The number of iteratoins to use in adjusting the curve.\n\n   Returns: Returns new faired Curve on success,null on failure.\n  \"\"\"\n  pass\n def Fit(self,degree,fitTolerance,angleTolerance):\n  \"\"\"\n  Fit(self: Curve,degree: int,fitTolerance: float,angleTolerance: float) -> Curve\n\n  \n\n   Fits a new curve through an existing curve.\n\n  \n\n   degree: The degree of the returned Curve. Must be bigger than 1.\n\n   fitTolerance: The fitting tolerance. If fitTolerance is RhinoMath.UnsetValue or <=0.0,\n\n     the \n\n    document absolute tolerance is used.\n\n  \n\n   angleTolerance: The kink smoothing tolerance in radians.\n\n     If angleTolerance is 0.0,all kinks are \n\n    smoothedIf angleTolerance is >0.0,kinks smaller than angleTolerance are smoothedIf \n\n    angleTolerance is RhinoMath.UnsetValue or <0.0,the document angle tolerance is used for the \n\n    kink smoothing\n\n  \n\n   Returns: Returns a new fitted Curve if successful,null on failure.\n  \"\"\"\n  pass\n def FrameAt(self,t,plane):\n  \"\"\"\n  FrameAt(self: Curve,t: float) -> (bool,Plane)\n\n  \n\n   Returns a 3d frame at a parameter.\n\n  \n\n   t: Evaluation parameter.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def GetCurveParameterFromNurbsFormParameter(self,nurbsParameter,curveParameter):\n  \"\"\"\n  GetCurveParameterFromNurbsFormParameter(self: Curve,nurbsParameter: float) -> (bool,float)\n\n  \n\n   Convert a NURBS curve parameter to a curve parameter.\n\n  \n\n   nurbsParameter: Nurbs form parameter.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n @staticmethod\n def GetDistancesBetweenCurves(curveA,curveB,tolerance,maxDistance,maxDistanceParameterA,maxDistanceParameterB,minDistance,minDistanceParameterA,minDistanceParameterB):\n  \"\"\"\n  GetDistancesBetweenCurves(curveA: Curve,curveB: Curve,tolerance: float) -> (bool,float,float,float,float,float,float)\n\n  \n\n   Computes the distances between two arbitrary curves that overlap.\n\n  \n\n   curveA: A curve.\n\n   curveB: Another curve.\n\n   tolerance: A tolerance value.\n\n   Returns: true if the operation succeeded; otherwise false.\n  \"\"\"\n  pass\n @staticmethod\n def GetFilletPoints(curve0,curve1,radius,t0Base,t1Base,t0,t1,filletPlane):\n  \"\"\"\n  GetFilletPoints(curve0: Curve,curve1: Curve,radius: float,t0Base: float,t1Base: float) -> (bool,float,float,Plane)\n\n  \n\n   Finds points at which to cut a pair of curves so that a fillet of given radius can be inserted.\n\n  \n\n   curve0: First curve to fillet.\n\n   curve1: Second curve to fillet.\n\n   radius: Fillet radius.\n\n   t0Base: Parameter value for base point on curve0.\n\n   t1Base: Parameter value for base point on curve1.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def GetLength(self,*__args):\n  \"\"\"\n  GetLength(self: Curve,subdomain: Interval) -> float\n\n  \n\n   Get the length of a sub-section of the curve with a fractional tolerance of 1e-8.\n\n  \n\n   subdomain: The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).\n\n   Returns: The length of the sub-curve on success,or zero on failure.\n\n  GetLength(self: Curve,fractionalTolerance: float,subdomain: Interval) -> float\n\n  \n\n   Get the length of a sub-section of the curve.\n\n  \n\n   fractionalTolerance: Desired fractional precision. \n\n     fabs((\"exact\" length from start to t) - \n\n    arc_length)/arc_length <= fractionalTolerance.\n\n  \n\n   subdomain: The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).\n\n   Returns: The length of the sub-curve on success,or zero on failure.\n\n  GetLength(self: Curve) -> float\n\n  \n\n   Gets the length of the curve with a fractional tolerance of 1.0e-8.\n\n   Returns: The length of the curve on success,or zero on failure.\n\n  GetLength(self: Curve,fractionalTolerance: float) -> float\n\n  \n\n   Get the length of the curve.\n\n  \n\n   fractionalTolerance: Desired fractional precision. \n\n     fabs((\"exact\" length from start to t) - \n\n    arc_length)/arc_length <= fractionalTolerance.\n\n  \n\n   Returns: The length of the curve on success,or zero on failure.\n  \"\"\"\n  pass\n def GetNextDiscontinuity(self,continuityType,t0,t1,t):\n  \"\"\"\n  GetNextDiscontinuity(self: Curve,continuityType: Continuity,t0: float,t1: float) -> (bool,float)\n\n  \n\n   Searches for a derivative,tangent,or curvature discontinuity.\n\n  \n\n   continuityType: Type of continuity to search for.\n\n   t0: Search begins at t0. If there is a discontinuity at t0,it will be ignored. This makes it\n\n     \n\n       possible to repeatedly call GetNextDiscontinuity() and step through the discontinuities.\n\n  \n\n   t1: (t0 != t1)  If there is a discontinuity at t1 it will be ignored unless continuityType is\n\n     \n\n       a locus discontinuity type and t1 is at the start or end of the curve.\n\n  \n\n   Returns: Parametric continuity tests c=(C0_continuous,...,G2_continuous):\n\n      true if a \n\n    parametric discontinuity was found strictly between t0 and t1. Note well that\n\n      all \n\n    curves are parametrically continuous at the ends of their domains.\n\n     \n\n     \n\n    Locus continuity tests c=(C0_locus_continuous,...,G2_locus_continuous):\n\n      true if \n\n    a locus discontinuity was found strictly between t0 and t1 or at t1 is the at the end\n\n      \n\n    of a curve. Note well that all open curves (IsClosed()=false) are locus discontinuous at the\n\n  \n\n        ends of their domains.  All closed curves (IsClosed()=true) are at least \n\n    C0_locus_continuous at \n\n      the ends of their domains.\n  \"\"\"\n  pass\n def GetNurbsFormParameterFromCurveParameter(self,curveParameter,nurbsParameter):\n  \"\"\"\n  GetNurbsFormParameterFromCurveParameter(self: Curve,curveParameter: float) -> (bool,float)\n\n  \n\n   Convert a curve parameter to a NURBS curve parameter.\n\n  \n\n   curveParameter: Curve parameter.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def GetPerpendicularFrames(self,parameters):\n  \"\"\" GetPerpendicularFrames(self: Curve,parameters: IEnumerable[float]) -> Array[Plane] \"\"\"\n  pass\n def HasNurbsForm(self):\n  \"\"\"\n  HasNurbsForm(self: Curve) -> int\n\n  \n\n   Does a NURBS curve representation of this curve exist?\n\n   Returns: 0   unable to create NURBS representation with desired accuracy.\n\n     1   success - \n\n    NURBS parameterization matches the curve's to the desired accuracy\n\n     2   success - \n\n    NURBS point locus matches the curve's and the domain of the NURBS\n\n          \n\n    curve is correct. However,This curve's parameterization and the\n\n          \n\n    NURBS curve parameterization may not match. This situation happens\n\n          \n\n    when getting NURBS representations of curves that have a\n\n          \n\n    transendental parameterization like circles.\n  \"\"\"\n  pass\n def IsArc(self,tolerance=None):\n  \"\"\"\n  IsArc(self: Curve,tolerance: float) -> bool\n\n  \n\n   Test a curve to see if it can be represented by an arc or circle within the given tolerance.\n\n  \n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if the curve can be represented by an arc or a circle within tolerance.\n\n  IsArc(self: Curve) -> bool\n\n  \n\n   Test a curve to see if it can be represented by an arc or circle within RhinoMath.ZeroTolerance.\n\n   Returns: true if the curve can be represented by an arc or a circle within tolerance.\n  \"\"\"\n  pass\n def IsCircle(self,tolerance=None):\n  \"\"\"\n  IsCircle(self: Curve,tolerance: float) -> bool\n\n  \n\n   Test a curve to see if it can be represented by a circle within the given tolerance.\n\n  \n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if the curve can be represented by a circle to within tolerance.\n\n  IsCircle(self: Curve) -> bool\n\n  \n\n   Test a curve to see if it can be represented by a circle within RhinoMath.ZeroTolerance.\n\n   Returns: true if the Curve can be represented by a circle within tolerance.\n  \"\"\"\n  pass\n def IsClosable(self,tolerance,minimumAbsoluteSize=None,minimumRelativeSize=None):\n  \"\"\"\n  IsClosable(self: Curve,tolerance: float) -> bool\n\n  \n\n   Decide if it makes sense to close off this curve by moving the endpoint \n\n     to the \n\n    start based on start-end gap size and length of curve as \n\n     approximated by chord \n\n    defined by 6 points.\n\n  \n\n  \n\n   tolerance: Maximum allowable distance between start and end. \n\n     If start - end gap is greater \n\n    than tolerance,this function will return false.\n\n  \n\n   Returns: true if start and end points are close enough based on above conditions.\n\n  IsClosable(self: Curve,tolerance: float,minimumAbsoluteSize: float,minimumRelativeSize: float) -> bool\n\n  \n\n   Decide if it makes sense to close off this curve by moving the endpoint\n\n     to the \n\n    start based on start-end gap size and length of curve as\n\n     approximated by chord \n\n    defined by 6 points.\n\n  \n\n  \n\n   tolerance: Maximum allowable distance between start and end. \n\n     If start - end gap is greater \n\n    than tolerance,this function will return false.\n\n  \n\n   minimumAbsoluteSize: If greater than 0.0 and none of the interior sampled points are at\n\n     least \n\n    minimumAbsoluteSize from start,this function will return false.\n\n  \n\n   minimumRelativeSize: If greater than 1.0 and chord length is less than \n\n     minimumRelativeSize*gap,this \n\n    function will return false.\n\n  \n\n   Returns: true if start and end points are close enough based on above conditions.\n  \"\"\"\n  pass\n def IsContinuous(self,continuityType,t):\n  \"\"\"\n  IsContinuous(self: Curve,continuityType: Continuity,t: float) -> bool\n\n  \n\n   Test continuity at a curve parameter value.\n\n  \n\n   continuityType: Type of continuity to test for.\n\n   t: Parameter to test.\n\n   Returns: true if the curve has at least the c type continuity at the parameter t.\n  \"\"\"\n  pass\n def IsEllipse(self,tolerance=None):\n  \"\"\"\n  IsEllipse(self: Curve,tolerance: float) -> bool\n\n  \n\n   Test a curve to see if it can be represented by an ellipse within a given tolerance.\n\n  \n\n   tolerance: Tolerance to use for checking.\n\n   Returns: true if the Curve can be represented by an ellipse within tolerance.\n\n  IsEllipse(self: Curve) -> bool\n\n  \n\n   Test a curve to see if it can be represented by an ellipse within RhinoMath.ZeroTolerance.\n\n   Returns: true if the Curve can be represented by an ellipse within tolerance.\n  \"\"\"\n  pass\n def IsInPlane(self,testPlane,tolerance=None):\n  \"\"\"\n  IsInPlane(self: Curve,testPlane: Plane,tolerance: float) -> bool\n\n  \n\n   Test a curve to see if it lies in a specific plane.\n\n  \n\n   testPlane: Plane to test for.\n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if the maximum distance from the curve to the testPlane is <= tolerance.\n\n  IsInPlane(self: Curve,testPlane: Plane) -> bool\n\n  \n\n   Test a curve to see if it lies in a specific plane.\n\n  \n\n   testPlane: Plane to test for.\n\n   Returns: true if the maximum distance from the curve to the testPlane is <= RhinoMath.ZeroTolerance.\n  \"\"\"\n  pass\n def IsLinear(self,tolerance=None):\n  \"\"\"\n  IsLinear(self: Curve,tolerance: float) -> bool\n\n  \n\n   Test a curve to see if it is linear to within the custom tolerance.\n\n  \n\n   tolerance: Tolerance to use when checking linearity.\n\n   Returns: true if the ends of the curve are farther than tolerance apart\n\n     and the maximum \n\n    distance from any point on the curve to\n\n     the line segment connecting the curve ends \n\n    is <= tolerance.\n\n  \n\n  IsLinear(self: Curve) -> bool\n\n  \n\n   Test a curve to see if it is linear to within RhinoMath.ZeroTolerance units (1e-12).\n\n   Returns: true if the curve is linear.\n  \"\"\"\n  pass\n def IsPlanar(self,tolerance=None):\n  \"\"\"\n  IsPlanar(self: Curve,tolerance: float) -> bool\n\n  \n\n   Test a curve for planarity.\n\n  \n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if there is a plane such that the maximum distance from the curve to the plane is <= \n\n    tolerance.\n\n  \n\n  IsPlanar(self: Curve) -> bool\n\n  \n\n   Test a curve for planarity.\n\n   Returns: true if the curve is planar (flat) to within RhinoMath.ZeroTolerance units (1e-12).\n  \"\"\"\n  pass\n def IsPolyline(self):\n  \"\"\"\n  IsPolyline(self: Curve) -> bool\n\n  \n\n   Several types of Curve can have the form of a polyline\n\n     including a degree 1 \n\n    NurbsCurve,a PolylineCurve,\n\n     and a PolyCurve all of whose segments are some form of\n\n\n    \n     polyline. IsPolyline tests a curve to see if it can be\n\n     represented as \n\n    a polyline.\n\n  \n\n   Returns: true if this curve can be represented as a polyline; otherwise,false.\n  \"\"\"\n  pass\n def IsShort(self,tolerance,subdomain=None):\n  \"\"\"\n  IsShort(self: Curve,tolerance: float,subdomain: Interval) -> bool\n\n  \n\n   Used to quickly find short curves.\n\n  \n\n   tolerance: Length threshold value for \"shortness\".\n\n   subdomain: The test is performed on the interval that is the intersection of subdomain with Domain()\n\n   Returns: true if the length of the curve is <= tolerance.\n\n  IsShort(self: Curve,tolerance: float) -> bool\n\n  \n\n   Used to quickly find short curves.\n\n  \n\n   tolerance: Length threshold value for \"shortness\".\n\n   Returns: true if the length of the curve is <= tolerance.\n  \"\"\"\n  pass\n @staticmethod\n def JoinCurves(inputCurves,joinTolerance=None,preserveDirection=None):\n  \"\"\"\n  JoinCurves(inputCurves: IEnumerable[Curve],joinTolerance: float,preserveDirection: bool) -> Array[Curve]\n\n  JoinCurves(inputCurves: IEnumerable[Curve],joinTolerance: float) -> Array[Curve]\n\n  JoinCurves(inputCurves: IEnumerable[Curve]) -> Array[Curve]\n  \"\"\"\n  pass\n def LengthParameter(self,segmentLength,t,*__args):\n  \"\"\"\n  LengthParameter(self: Curve,segmentLength: float,subdomain: Interval) -> (bool,float)\n\n  \n\n   Gets the parameter along the curve which coincides with a given length along the curve. \n\n      \n\n      A fractional tolerance of 1e-8 is used in this version of the function.\n\n  \n\n  \n\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the subdomain.\n\n   subdomain: The calculation is performed on the specified sub-domain of the curve rather than the whole \n\n    curve.\n\n  \n\n   Returns: true on success,false on failure.\n\n  LengthParameter(self: Curve,segmentLength: float,fractionalTolerance: float,subdomain: Interval) -> (bool,float)\n\n  \n\n   Gets the parameter along the curve which coincides with a given length along the curve.\n\n  \n\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the subdomain.\n\n   fractionalTolerance: Desired fractional precision. \n\n     fabs((\"exact\" length from start to t) - \n\n    arc_length)/arc_length <= fractionalTolerance.\n\n  \n\n   subdomain: The calculation is performed on the specified sub-domain of the curve rather than the whole \n\n    curve.\n\n  \n\n   Returns: true on success,false on failure.\n\n  LengthParameter(self: Curve,segmentLength: float) -> (bool,float)\n\n  \n\n   Gets the parameter along the curve which coincides with a given length along the curve. \n\n      \n\n      A fractional tolerance of 1e-8 is used in this version of the function.\n\n  \n\n  \n\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the curve.\n\n   Returns: true on success,false on failure.\n\n  LengthParameter(self: Curve,segmentLength: float,fractionalTolerance: float) -> (bool,float)\n\n  \n\n   Gets the parameter along the curve which coincides with a given length along the curve.\n\n  \n\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the curve.\n\n   fractionalTolerance: Desired fractional precision.\n\n     fabs((\"exact\" length from start to t) - \n\n    arc_length)/arc_length <= fractionalTolerance.\n\n  \n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def MakeClosed(self,tolerance):\n  \"\"\"\n  MakeClosed(self: Curve,tolerance: float) -> bool\n\n  \n\n   If IsClosed,just return true. Otherwise,decide if curve can be closed as \n\n     \n\n    follows: Linear curves polylinear curves with 2 segments,Nurbs with 3 or less \n\n     \n\n    control points cannot be made closed. Also,if tolerance > 0 and the gap between \n\n     \n\n    start and end is larger than tolerance,curve cannot be made closed. \n\n     Adjust the \n\n    curve's endpoint to match its start point.\n\n  \n\n  \n\n   tolerance: If nonzero,and the gap is more than tolerance,curve cannot be made closed.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n @staticmethod\n def MakeEndsMeet(curveA,adjustStartCurveA,curveB,adjustStartCurveB):\n  \"\"\"\n  MakeEndsMeet(curveA: Curve,adjustStartCurveA: bool,curveB: Curve,adjustStartCurveB: bool) -> bool\n\n  \n\n   Makes adjustments to the ends of one or both input curves so that they meet at a point.\n\n  \n\n   curveA: 1st curve to adjust.\n\n   adjustStartCurveA: Which end of the 1st curve to adjust: true is start,false is end.\n\n   curveB: 2nd curve to adjust.\n\n   adjustStartCurveB: which end of the 2nd curve to adjust true==start,false==end.\n\n   Returns: true on success.\n  \"\"\"\n  pass\n def NonConstOperation(self,*args):\n  \"\"\"\n  NonConstOperation(self: Curve)\n\n   For derived classes implementers.\n\n     Defines the necessary implementation to free the \n\n    instance from being const.\n  \"\"\"\n  pass\n def NormalizedLengthParameter(self,s,t,*__args):\n  \"\"\"\n  NormalizedLengthParameter(self: Curve,s: float,subdomain: Interval) -> (bool,float)\n\n  \n\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \n\n    the curve. \n\n     A fractional tolerance of 1e-8 is used in this version of the function.\n\n  \n\n  \n\n   s: Normalized arc length parameter. \n\n     E.g.,0=start of curve,1/2=midpoint of \n\n    curve,1=end of curve.\n\n  \n\n   subdomain: The calculation is performed on the specified sub-domain of the curve.\n\n   Returns: true on success,false on failure.\n\n  NormalizedLengthParameter(self: Curve,s: float,fractionalTolerance: float,subdomain: Interval) -> (bool,float)\n\n  \n\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \n\n    the curve.\n\n  \n\n  \n\n   s: Normalized arc length parameter. \n\n     E.g.,0=start of curve,1/2=midpoint of \n\n    curve,1=end of curve.\n\n  \n\n   fractionalTolerance: Desired fractional precision. \n\n     fabs((\"exact\" length from start to t) - \n\n    arc_length)/arc_length <= fractionalTolerance.\n\n  \n\n   subdomain: The calculation is performed on the specified sub-domain of the curve.\n\n   Returns: true on success,false on failure.\n\n  NormalizedLengthParameter(self: Curve,s: float) -> (bool,float)\n\n  \n\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \n\n    the curve. \n\n     A fractional tolerance of 1e-8 is used in this version of the function.\n\n  \n\n  \n\n   s: Normalized arc length parameter. \n\n     E.g.,0=start of curve,1/2=midpoint of \n\n    curve,1=end of curve.\n\n  \n\n   Returns: true on success,false on failure.\n\n  NormalizedLengthParameter(self: Curve,s: float,fractionalTolerance: float) -> (bool,float)\n\n  \n\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \n\n    the curve.\n\n  \n\n  \n\n   s: Normalized arc length parameter. \n\n     E.g.,0=start of curve,1/2=midpoint of \n\n    curve,1=end of curve.\n\n  \n\n   fractionalTolerance: Desired fractional precision. \n\n     fabs((\"exact\" length from start to t) - \n\n    arc_length)/arc_length <= fractionalTolerance.\n\n  \n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def NormalizedLengthParameters(self,s,absoluteTolerance,*__args):\n  \"\"\"\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float,subdomain: Interval) -> Array[float]\n\n  \n\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \n\n    the curve. \n\n     A fractional tolerance of 1e-8 is used in this version of the function.\n\n  \n\n  \n\n   s: Array of normalized arc length parameters. \n\n     E.g.,0=start of curve,1/2=\n\n    midpoint of curve,1=end of curve.\n\n  \n\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \n\n     \n\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n\n  \n\n   subdomain: The calculation is performed on the specified sub-domain of the curve. \n\n     A 0.0 s \n\n    value corresponds to subdomain->Min() and a 1.0 s value corresponds to subdomain->Max().\n\n  \n\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \n\n    t[i] is s[i]*curve_length. \n\n     Null on failure.\n\n  \n\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float,fractionalTolerance: float,subdomain: Interval) -> Array[float]\n\n  \n\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \n\n    the curve.\n\n  \n\n  \n\n   s: Array of normalized arc length parameters. \n\n     E.g.,0=start of curve,1/2=\n\n    midpoint of curve,1=end of curve.\n\n  \n\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \n\n     \n\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n\n  \n\n   fractionalTolerance: Desired fractional precision for each segment. \n\n     fabs(\"true\" length - actual \n\n    length)/(actual length) <= fractionalTolerance.\n\n  \n\n   subdomain: The calculation is performed on the specified sub-domain of the curve. \n\n     A 0.0 s \n\n    value corresponds to subdomain->Min() and a 1.0 s value corresponds to subdomain->Max().\n\n  \n\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \n\n    t[i] is s[i]*curve_length. \n\n     Null on failure.\n\n  \n\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float) -> Array[float]\n\n  \n\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \n\n    the curve. \n\n     A fractional tolerance of 1e-8 is used in this version of the function.\n\n  \n\n  \n\n   s: Array of normalized arc length parameters. \n\n     E.g.,0=start of curve,1/2=\n\n    midpoint of curve,1=end of curve.\n\n  \n\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \n\n     \n\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n\n  \n\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \n\n    t[i] is s[i]*curve_length. \n\n     Null on failure.\n\n  \n\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float,fractionalTolerance: float) -> Array[float]\n\n  \n\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \n\n    the curve.\n\n  \n\n  \n\n   s: Array of normalized arc length parameters. \n\n     E.g.,0=start of curve,1/2=\n\n    midpoint of curve,1=end of curve.\n\n  \n\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \n\n     \n\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n\n  \n\n   fractionalTolerance: Desired fractional precision for each segment. \n\n     fabs(\"true\" length - actual \n\n    length)/(actual length) <= fractionalTolerance.\n\n  \n\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \n\n    t[i] is s[i]*curve_length. \n\n     Null on failure.\n  \"\"\"\n  pass\n def Offset(self,*__args):\n  \"\"\"\n  Offset(self: Curve,directionPoint: Point3d,normal: Vector3d,distance: float,tolerance: float,cornerStyle: CurveOffsetCornerStyle) -> Array[Curve]\n\n  \n\n   Offsets this curve. If you have a nice offset,then there will be one entry in \n\n     the \n\n    array. If the original curve had kinks or the offset curve had self \n\n     intersections,\n\n    you will get multiple segments in the offset_curves[] array.\n\n  \n\n  \n\n   directionPoint: A point that indicates the direction of the offset.\n\n   normal: The normal to the offset plane.\n\n   distance: The positive or negative distance to offset.\n\n   tolerance: The offset or fitting tolerance.\n\n   cornerStyle: Corner style for offset kinks.\n\n   Returns: Offset curves on success,null on failure.\n\n  Offset(self: Curve,plane: Plane,distance: float,tolerance: float,cornerStyle: CurveOffsetCornerStyle) -> Array[Curve]\n\n  \n\n   Offsets this curve. If you have a nice offset,then there will be one entry in \n\n     the \n\n    array. If the original curve had kinks or the offset curve had self \n\n     intersections,\n\n    you will get multiple segments in the offset_curves[] array.\n\n  \n\n  \n\n   plane: Offset solution plane.\n\n   distance: The positive or negative distance to offset.\n\n   tolerance: The offset or fitting tolerance.\n\n   cornerStyle: Corner style for offset kinks.\n\n   Returns: Offset curves on success,null on failure.\n  \"\"\"\n  pass\n def OffsetNormalToSurface(self,surface,height):\n  \"\"\"\n  OffsetNormalToSurface(self: Curve,surface: Surface,height: float) -> Curve\n\n  \n\n   Finds a curve by offsetting an existing curve normal to a surface.\n\n     The caller is \n\n    responsible for ensuring that the curve lies on the input surface.\n\n  \n\n  \n\n   surface: Surface from which normals are calculated.\n\n   height: offset distance (distance from surface to result curve)\n\n   Returns: Offset curve at distance height from the surface.  The offset curve is\n\n     interpolated \n\n    through a small number of points so if the surface is irregular\n\n     or complicated,the \n\n    result will not be a very accurate offset.\n  \"\"\"\n  pass\n def OffsetOnSurface(self,*__args):\n  \"\"\"\n  OffsetOnSurface(self: Curve,surface: Surface,distance: float,fittingTolerance: float) -> Array[Curve]\n\n  \n\n   Offset a curve on a surface. This curve must lie on the surface.\n\n  \n\n   surface: A surface on which to offset.\n\n   distance: A distance to offset (+)left,(-)right.\n\n   fittingTolerance: A fitting tolerance.\n\n   Returns: Offset curves on success,or null on failure.\n\n  OffsetOnSurface(self: Curve,surface: Surface,throughPoint: Point2d,fittingTolerance: float) -> Array[Curve]\n\n  \n\n   Offset a curve on a surface. This curve must lie on the surface.\n\n     This overload \n\n    allows to specify a surface point at which the offset will pass.\n\n  \n\n  \n\n   surface: A surface on which to offset.\n\n   throughPoint: 2d point on the brep face to offset through.\n\n   fittingTolerance: A fitting tolerance.\n\n   Returns: Offset curves on success,or null on failure.\n\n  OffsetOnSurface(self: Curve,surface: Surface,curveParameters: Array[float],offsetDistances: Array[float],fittingTolerance: float) -> Array[Curve]\n\n  \n\n   Offset this curve on a surface. This curve must lie on the surface.\n\n     This overload \n\n    allows to specify different offsets for different curve parameters.\n\n  \n\n  \n\n   surface: A surface on which to offset.\n\n   curveParameters: Curve parameters corresponding to the offset distances.\n\n   offsetDistances: Distances to offset (+)left,(-)right.\n\n   fittingTolerance: A fitting tolerance.\n\n   Returns: Offset curves on success,or null on failure.\n\n  OffsetOnSurface(self: Curve,face: BrepFace,distance: float,fittingTolerance: float) -> Array[Curve]\n\n  \n\n   Offset this curve on a brep face surface. This curve must lie on the surface.\n\n  \n\n   face: The brep face on which to offset.\n\n   distance: A distance to offset (+)left,(-)right.\n\n   fittingTolerance: A fitting tolerance.\n\n   Returns: Offset curves on success,or null on failure.\n\n  OffsetOnSurface(self: Curve,face: BrepFace,throughPoint: Point2d,fittingTolerance: float) -> Array[Curve]\n\n  \n\n   Offset a curve on a brep face surface. This curve must lie on the surface.\n\n     This \n\n    overload allows to specify a surface point at which the offset will pass.\n\n  \n\n  \n\n   face: The brep face on which to offset.\n\n   throughPoint: 2d point on the brep face to offset through.\n\n   fittingTolerance: A fitting tolerance.\n\n   Returns: Offset curves on success,or null on failure.\n\n  OffsetOnSurface(self: Curve,face: BrepFace,curveParameters: Array[float],offsetDistances: Array[float],fittingTolerance: float) -> Array[Curve]\n\n  \n\n   Offset a curve on a brep face surface. This curve must lie on the surface.\n\n     This \n\n    overload allows to specify different offsets for different curve parameters.\n\n  \n\n  \n\n   face: The brep face on which to offset.\n\n   curveParameters: Curve parameters corresponding to the offset distances.\n\n   offsetDistances: distances to offset (+)left,(-)right.\n\n   fittingTolerance: A fitting tolerance.\n\n   Returns: Offset curves on success,or null on failure.\n  \"\"\"\n  pass\n def OnSwitchToNonConst(self,*args):\n  \"\"\"\n  OnSwitchToNonConst(self: GeometryBase)\n\n   Is called when a non-const operation occurs.\n  \"\"\"\n  pass\n def PerpendicularFrameAt(self,t,plane):\n  \"\"\"\n  PerpendicularFrameAt(self: Curve,t: float) -> (bool,Plane)\n\n  \n\n   Return a 3d frame at a parameter. This is slightly different than FrameAt in\n\n     that \n\n    the frame is computed in a way so there is minimal rotation from one\n\n     frame to the \n\n    next.\n\n  \n\n  \n\n   t: Evaluation parameter.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n @staticmethod\n def PlanarClosedCurveRelationship(curveA,curveB,testPlane,tolerance):\n  \"\"\"\n  PlanarClosedCurveRelationship(curveA: Curve,curveB: Curve,testPlane: Plane,tolerance: float) -> RegionContainment\n\n  \n\n   Determines whether two coplanar simple closed curves are disjoint or intersect;\n\n     \n\n    otherwise,if the regions have a containment relationship,discovers\n\n     which curve \n\n    encloses the other.\n\n  \n\n  \n\n   curveA: A first curve.\n\n   curveB: A second curve.\n\n   testPlane: A plane.\n\n   tolerance: A tolerance value.\n\n   Returns: A value indicating the relationship between the first and the second curve.\n  \"\"\"\n  pass\n @staticmethod\n def PlanarCurveCollision(curveA,curveB,testPlane,tolerance):\n  \"\"\"\n  PlanarCurveCollision(curveA: Curve,curveB: Curve,testPlane: Plane,tolerance: float) -> bool\n\n  \n\n   Determines if two coplanar curves collide (intersect).\n\n  \n\n   curveA: A curve.\n\n   curveB: Another curve.\n\n   testPlane: A valid plane containing the curves.\n\n   tolerance: A tolerance value for intersection.\n\n   Returns: true if the curves intersect,otherwise false\n  \"\"\"\n  pass\n def PointAt(self,t):\n  \"\"\"\n  PointAt(self: Curve,t: float) -> Point3d\n\n  \n\n   Evaluates point at a curve parameter.\n\n  \n\n   t: Evaluation parameter.\n\n   Returns: Point (location of curve at the parameter t).\n  \"\"\"\n  pass\n def PointAtLength(self,length):\n  \"\"\"\n  PointAtLength(self: Curve,length: float) -> Point3d\n\n  \n\n   Gets a point at a certain length along the curve. The length must be \n\n     non-negative \n\n    and less than or equal to the length of the curve. \n\n     Lengths will not be wrapped \n\n    when the curve is closed or periodic.\n\n  \n\n  \n\n   length: Length along the curve between the start point and the returned point.\n\n   Returns: Point on the curve at the specified length from the start point or Poin3d.Unset on failure.\n  \"\"\"\n  pass\n def PointAtNormalizedLength(self,length):\n  \"\"\"\n  PointAtNormalizedLength(self: Curve,length: float) -> Point3d\n\n  \n\n   Gets a point at a certain normalized length along the curve. The length must be \n\n     \n\n    between or including 0.0 and 1.0,where 0.0 equals the start of the curve and \n\n     1.0 \n\n    equals the end of the curve.\n\n  \n\n  \n\n   length: Normalized length along the curve between the start point and the returned point.\n\n   Returns: Point on the curve at the specified normalized length from the start point or Poin3d.Unset on \n\n    failure.\n  \"\"\"\n  pass\n @staticmethod\n def ProjectToBrep(*__args):\n  \"\"\"\n  ProjectToBrep(curves: IEnumerable[Curve],breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> Array[Curve]\n\n  ProjectToBrep(curves: IEnumerable[Curve],breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> (Array[Curve],Array[int],Array[int])\n\n  ProjectToBrep(curve: Curve,breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> (Array[Curve],Array[int])\n\n  ProjectToBrep(curve: Curve,brep: Brep,direction: Vector3d,tolerance: float) -> Array[Curve]\n\n  \n\n   Projects a Curve onto a Brep along a given direction.\n\n  \n\n   curve: Curve to project.\n\n   brep: Brep to project onto.\n\n   direction: Direction of projection.\n\n   tolerance: Tolerance to use for projection.\n\n   Returns: An array of projected curves or empty array if the projection set is empty.\n\n  ProjectToBrep(curve: Curve,breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> Array[Curve]\n  \"\"\"\n  pass\n @staticmethod\n def ProjectToMesh(*__args):\n  \"\"\"\n  ProjectToMesh(curves: IEnumerable[Curve],meshes: IEnumerable[Mesh],direction: Vector3d,tolerance: float) -> Array[Curve]\n\n  ProjectToMesh(curve: Curve,meshes: IEnumerable[Mesh],direction: Vector3d,tolerance: float) -> Array[Curve]\n\n  ProjectToMesh(curve: Curve,mesh: Mesh,direction: Vector3d,tolerance: float) -> Array[Curve]\n\n  \n\n   Projects a curve to a mesh using a direction and tolerance.\n\n  \n\n   curve: A curve.\n\n   mesh: A mesh.\n\n   direction: A direction vector.\n\n   tolerance: A tolerance value.\n\n   Returns: A curve array.\n  \"\"\"\n  pass\n @staticmethod\n def ProjectToPlane(curve,plane):\n  \"\"\"\n  ProjectToPlane(curve: Curve,plane: Plane) -> Curve\n\n  \n\n   Constructs a curve by projecting an existing curve to a plane.\n\n  \n\n   curve: A curve.\n\n   plane: A plane.\n\n   Returns: The projected curve on success; null on failure.\n  \"\"\"\n  pass\n def PullToBrepFace(self,*__args):\n  \"\"\"\n  PullToBrepFace(curve: Curve,face: BrepFace,tolerance: float) -> Array[Curve]\n\n  \n\n   Pull a curve to a BrepFace using closest point projection.\n\n  \n\n   curve: Curve to pull.\n\n   face: Brepface that pulls.\n\n   tolerance: Tolerance to use for pulling.\n\n   Returns: An array of pulled curves,or an empty array on failure.\n\n  PullToBrepFace(self: Curve,face: BrepFace,tolerance: float) -> Array[Curve]\n\n  \n\n   Pulls this curve to a brep face and returns the result of that operation.\n\n  \n\n   face: A brep face.\n\n   tolerance: A tolerance value.\n\n   Returns: An array containing the resulting curves after pulling. This array could be empty.\n  \"\"\"\n  pass\n def PullToMesh(self,mesh,tolerance):\n  \"\"\"\n  PullToMesh(self: Curve,mesh: Mesh,tolerance: float) -> PolylineCurve\n\n  \n\n   Makes a polyline approximation of the curve and gets the closest point on the mesh for each \n\n    point on the curve. \n\n     Then it \"connects the points\" so that you have a polyline on \n\n    the mesh.\n\n  \n\n  \n\n   mesh: Mesh to project onto.\n\n   tolerance: Input tolerance (RhinoDoc.ModelAbsoluteTolerance is a good default)\n\n   Returns: A polyline curve on success,null on failure.\n  \"\"\"\n  pass\n def Rebuild(self,pointCount,degree,preserveTangents):\n  \"\"\"\n  Rebuild(self: Curve,pointCount: int,degree: int,preserveTangents: bool) -> NurbsCurve\n\n  \n\n   Rebuild a curve with a specific point count.\n\n  \n\n   pointCount: Number of control points in the rebuild curve.\n\n   degree: Degree of curve. Valid values are between and including 1 and 11.\n\n   preserveTangents: If true,the end tangents of the input curve will be preserved.\n\n   Returns: A Nurbs curve on success or null on failure.\n  \"\"\"\n  pass\n def RemoveShortSegments(self,tolerance):\n  \"\"\"\n  RemoveShortSegments(self: Curve,tolerance: float) -> bool\n\n  \n\n   Looks for segments that are shorter than tolerance that can be removed. \n\n     Does not \n\n    change the domain,but it will change the relative parameterization.\n\n  \n\n  \n\n   tolerance: Tolerance which defines \"short\" segments.\n\n   Returns: true if removable short segments were found. \n\n     false if no removable short segments \n\n    were found.\n  \"\"\"\n  pass\n def Reverse(self):\n  \"\"\"\n  Reverse(self: Curve) -> bool\n\n  \n\n   Reverses the direction of the curve.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def SetEndPoint(self,point):\n  \"\"\"\n  SetEndPoint(self: Curve,point: Point3d) -> bool\n\n  \n\n   Forces the curve to end at a specified point. \n\n     Not all curve types support this \n\n    operation.\n\n  \n\n  \n\n   point: New end point of curve.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def SetStartPoint(self,point):\n  \"\"\"\n  SetStartPoint(self: Curve,point: Point3d) -> bool\n\n  \n\n   Forces the curve to start at a specified point. \n\n     Not all curve types support this \n\n    operation.\n\n  \n\n  \n\n   point: New start point of curve.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def Simplify(self,options,distanceTolerance,angleToleranceRadians):\n  \"\"\"\n  Simplify(self: Curve,options: CurveSimplifyOptions,distanceTolerance: float,angleToleranceRadians: float) -> Curve\n\n  \n\n   Returns a geometrically equivalent PolyCurve.\n\n     The PolyCurve has the following \n\n    properties\n\n     1. All the PolyCurve segments are LineCurve,PolylineCurve,ArcCurve,or \n\n    NurbsCurve.\n\n     \n\n     2. The Nurbs Curves segments do not have fully multiple \n\n    interior knots.\n\n     \n\n     3. Rational Nurbs curves do not have constant \n\n    weights.\n\n     \n\n     4. Any segment for which IsLinear() or IsArc() is true is a \n\n    Line,\n\n        Polyline segment,or an Arc.\n\n     \n\n     5. Adjacent \n\n    Colinear or Cocircular segments are combined.\n\n     \n\n     6. Segments that meet \n\n    with G1-continuity have there ends tuned up so\n\n        that they meet with G1-continuity \n\n    to within machine precision.\n\n  \n\n  \n\n   options: Simplification options.\n\n   distanceTolerance: A distance tolerance for the simplification.\n\n   angleToleranceRadians: An angle tolerance for the simplification.\n\n   Returns: New simplified curve on success,null on failure.\n  \"\"\"\n  pass\n def SimplifyEnd(self,end,options,distanceTolerance,angleToleranceRadians):\n  \"\"\"\n  SimplifyEnd(self: Curve,end: CurveEnd,options: CurveSimplifyOptions,distanceTolerance: float,angleToleranceRadians: float) -> Curve\n\n  \n\n   Same as SimplifyCurve,but simplifies only the last two segments at \"side\" end.\n\n  \n\n   end: If CurveEnd.Start the function simplifies the last two start \n\n     side segments,\n\n    otherwise if CurveEnd.End the last two end side segments are simplified.\n\n  \n\n   options: Simplification options.\n\n   distanceTolerance: A distance tolerance for the simplification.\n\n   angleToleranceRadians: An angle tolerance for the simplification.\n\n   Returns: New simplified curve on success,null on failure.\n  \"\"\"\n  pass\n def SpanDomain(self,spanIndex):\n  \"\"\"\n  SpanDomain(self: Curve,spanIndex: int) -> Interval\n\n  \n\n   Get the domain of the curve span with the given index. \n\n     Use the SpanCount property \n\n    to test how many spans there are.\n\n  \n\n  \n\n   spanIndex: Index of span.\n\n   Returns: Interval of the span with the given index.\n  \"\"\"\n  pass\n def Split(self,*__args):\n  \"\"\"\n  Split(self: Curve,cutter: Brep,tolerance: float) -> Array[Curve]\n\n  \n\n   Splits a curve into pieces using a polysurface.\n\n  \n\n   cutter: A cutting surface or polysurface.\n\n   tolerance: A tolerance for computing intersections.\n\n   Returns: An array of curves. This array can be empty.\n\n  Split(self: Curve,cutter: Surface,tolerance: float) -> Array[Curve]\n\n  \n\n   Splits a curve into pieces using a surface.\n\n  \n\n   cutter: A cutting surface or polysurface.\n\n   tolerance: A tolerance for computing intersections.\n\n   Returns: An array of curves. This array can be empty.\n\n  Split(self: Curve,t: float) -> Array[Curve]\n\n  \n\n   Splits (divides) the curve at the specified parameter. \n\n     The parameter must be in \n\n    the interior of the curve's domain.\n\n  \n\n  \n\n   t: Parameter to split the curve at in the interval returned by Domain().\n\n   Returns: Two curves on success,null on failure.\n\n  Split(self: Curve,t: IEnumerable[float]) -> Array[Curve]\n  \"\"\"\n  pass\n def TangentAt(self,t):\n  \"\"\"\n  TangentAt(self: Curve,t: float) -> Vector3d\n\n  \n\n   Evaluates the unit tangent vector at a curve parameter.\n\n  \n\n   t: Evaluation parameter.\n\n   Returns: Unit tangent vector of the curve at the parameter t.\n  \"\"\"\n  pass\n def ToNurbsCurve(self,subdomain=None):\n  \"\"\"\n  ToNurbsCurve(self: Curve) -> NurbsCurve\n\n  \n\n   Constructs a NURBS curve representation of this curve.\n\n   Returns: NURBS representation of the curve on success,null on failure.\n\n  ToNurbsCurve(self: Curve,subdomain: Interval) -> NurbsCurve\n\n  \n\n   Constructs a NURBS curve representation of this curve.\n\n  \n\n   subdomain: The NURBS representation for this portion of the curve is returned.\n\n   Returns: NURBS representation of the curve on success,null on failure.\n  \"\"\"\n  pass\n def ToPolyline(self,mainSegmentCount,subSegmentCount,maxAngleRadians,maxChordLengthRatio,maxAspectRatio,tolerance,minEdgeLength,maxEdgeLength,keepStartPoint,curveDomain=None):\n  \"\"\"\n  ToPolyline(self: Curve,mainSegmentCount: int,subSegmentCount: int,maxAngleRadians: float,maxChordLengthRatio: float,maxAspectRatio: float,tolerance: float,minEdgeLength: float,maxEdgeLength: float,keepStartPoint: bool,curveDomain: Interval) -> PolylineCurve\n\n  \n\n   Gets a polyline approximation of a curve.\n\n  \n\n   mainSegmentCount: If mainSegmentCount <= 0,then both subSegmentCount and mainSegmentCount are ignored. \n\n     \n\n    If mainSegmentCount > 0,then subSegmentCount must be >= 1. In this \n\n     case the \n\n    nurb will be broken into mainSegmentCount equally spaced \n\n     chords. If needed,each \n\n    of these chords can be split into as many \n\n     subSegmentCount sub-parts if the \n\n    subdivision is necessary for the \n\n     mesh to meet the other meshing constraints. In \n\n    particular,if \n\n     subSegmentCount=0,then the curve is broken into mainSegmentCount \n\n    \n\n     pieces and no further testing is performed.\n\n  \n\n   subSegmentCount: An amount of subsegments.\n\n   maxAngleRadians: ( 0 to pi ) Maximum angle (in radians) between unit tangents at \n\n     adjacent vertices.\n\n   maxChordLengthRatio: Maximum permitted value of \n\n     (distance chord midpoint to curve) / (length of chord).\n\n   maxAspectRatio: If maxAspectRatio < 1.0,the parameter is ignored. \n\n     If 1 <= maxAspectRatio < \n\n    sqrt(2),it is treated as if maxAspectRatio=sqrt(2). \n\n     This parameter controls the \n\n    maximum permitted value of \n\n     (length of longest chord) / (length of shortest chord).\n\n  \n\n   tolerance: If tolerance=0,the parameter is ignored. \n\n     This parameter controls the maximum \n\n    permitted value of the \n\n     distance from the curve to the polyline.\n\n  \n\n   minEdgeLength: The minimum permitted edge length.\n\n   maxEdgeLength: If maxEdgeLength=0,the parameter \n\n     is ignored. This parameter controls the \n\n    maximum permitted edge length.\n\n  \n\n   keepStartPoint: If true the starting point of the curve \n\n     is added to the polyline. If false the \n\n    starting point of the curve is \n\n     not added to the polyline.\n\n  \n\n   curveDomain: This subdomain of the NURBS curve is approximated.\n\n   Returns: PolylineCurve on success,null on error.\n\n  ToPolyline(self: Curve,mainSegmentCount: int,subSegmentCount: int,maxAngleRadians: float,maxChordLengthRatio: float,maxAspectRatio: float,tolerance: float,minEdgeLength: float,maxEdgeLength: float,keepStartPoint: bool) -> PolylineCurve\n\n  \n\n   Gets a polyline approximation of a curve.\n\n  \n\n   mainSegmentCount: If mainSegmentCount <= 0,then both subSegmentCount and mainSegmentCount are ignored. \n\n     \n\n    If mainSegmentCount > 0,then subSegmentCount must be >= 1. In this \n\n     case the \n\n    nurb will be broken into mainSegmentCount equally spaced \n\n     chords. If needed,each \n\n    of these chords can be split into as many \n\n     subSegmentCount sub-parts if the \n\n    subdivision is necessary for the \n\n     mesh to meet the other meshing constraints. In \n\n    particular,if \n\n     subSegmentCount=0,then the curve is broken into mainSegmentCount \n\n    \n\n     pieces and no further testing is performed.\n\n  \n\n   subSegmentCount: An amount of subsegments.\n\n   maxAngleRadians: ( 0 to pi ) Maximum angle (in radians) between unit tangents at \n\n     adjacent vertices.\n\n   maxChordLengthRatio: Maximum permitted value of \n\n     (distance chord midpoint to curve) / (length of chord).\n\n   maxAspectRatio: If maxAspectRatio < 1.0,the parameter is ignored. \n\n     If 1 <= maxAspectRatio < \n\n    sqrt(2),it is treated as if maxAspectRatio=sqrt(2). \n\n     This parameter controls the \n\n    maximum permitted value of \n\n     (length of longest chord) / (length of shortest chord).\n\n  \n\n   tolerance: If tolerance=0,the parameter is ignored. \n\n     This parameter controls the maximum \n\n    permitted value of the \n\n     distance from the curve to the polyline.\n\n  \n\n   minEdgeLength: The minimum permitted edge length.\n\n   maxEdgeLength: If maxEdgeLength=0,the parameter \n\n     is ignored. This parameter controls the \n\n    maximum permitted edge length.\n\n  \n\n   keepStartPoint: If true the starting point of the curve \n\n     is added to the polyline. If false the \n\n    starting point of the curve is \n\n     not added to the polyline.\n\n  \n\n   Returns: PolylineCurve on success,null on error.\n  \"\"\"\n  pass\n def Trim(self,*__args):\n  \"\"\"\n  Trim(self: Curve,side: CurveEnd,length: float) -> Curve\n\n  \n\n   Shortens a curve by a given length\n\n   Returns: Trimmed curve if successful,null on failure.\n\n  Trim(self: Curve,domain: Interval) -> Curve\n\n  \n\n   Removes portions of the curve outside the specified interval.\n\n  \n\n   domain: Trimming interval. Portions of the curve before curve(domain[0])\n\n     and after \n\n    curve(domain[1]) are removed.\n\n  \n\n   Returns: Trimmed curve if successful,null on failure.\n\n  Trim(self: Curve,t0: float,t1: float) -> Curve\n\n  \n\n   Removes portions of the curve outside the specified interval.\n\n  \n\n   t0: Start of the trimming interval. Portions of the curve before curve(t0) are removed.\n\n   t1: End of the trimming interval. Portions of the curve after curve(t1) are removed.\n\n   Returns: Trimmed portion of this curve is successfull,null on failure.\n  \"\"\"\n  pass\n def TryGetArc(self,*__args):\n  \"\"\"\n  TryGetArc(self: Curve,plane: Plane) -> (bool,Arc)\n\n  \n\n   Try to convert this curve into an Arc using RhinoMath.ZeroTolerance.\n\n  \n\n   plane: Plane in which the comparison is performed.\n\n   Returns: true if the curve could be converted into an arc within the given plane.\n\n  TryGetArc(self: Curve,plane: Plane,tolerance: float) -> (bool,Arc)\n\n  \n\n   Try to convert this curve into an Arc using a custom tolerance.\n\n  \n\n   plane: Plane in which the comparison is performed.\n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if the curve could be converted into an arc within the given plane.\n\n  TryGetArc(self: Curve) -> (bool,Arc)\n\n  \n\n   Try to convert this curve into an Arc using RhinoMath.ZeroTolerance.\n\n   Returns: true if the curve could be converted into an arc.\n\n  TryGetArc(self: Curve,tolerance: float) -> (bool,Arc)\n\n  \n\n   Try to convert this curve into an Arc using a custom tolerance.\n\n  \n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if the curve could be converted into an arc.\n  \"\"\"\n  pass\n def TryGetCircle(self,circle,tolerance=None):\n  \"\"\"\n  TryGetCircle(self: Curve,tolerance: float) -> (bool,Circle)\n\n  \n\n   Try to convert this curve into a Circle using a custom tolerance.\n\n  \n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if the curve could be converted into a Circle within tolerance.\n\n  TryGetCircle(self: Curve) -> (bool,Circle)\n\n  \n\n   Try to convert this curve into a circle using RhinoMath.ZeroTolerance.\n\n   Returns: true if the curve could be converted into a Circle.\n  \"\"\"\n  pass\n def TryGetEllipse(self,*__args):\n  \"\"\"\n  TryGetEllipse(self: Curve,plane: Plane) -> (bool,Ellipse)\n\n  \n\n   Try to convert this curve into an Ellipse within RhinoMath.ZeroTolerance.\n\n  \n\n   plane: Plane in which the comparison is performed.\n\n   Returns: true if the curve could be converted into an Ellipse within the given plane.\n\n  TryGetEllipse(self: Curve,plane: Plane,tolerance: float) -> (bool,Ellipse)\n\n  \n\n   Try to convert this curve into an Ellipse using a custom tolerance.\n\n  \n\n   plane: Plane in which the comparison is performed.\n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if the curve could be converted into an Ellipse within the given plane.\n\n  TryGetEllipse(self: Curve) -> (bool,Ellipse)\n\n  \n\n   Try to convert this curve into an Ellipse within RhinoMath.ZeroTolerance.\n\n   Returns: true if the curve could be converted into an Ellipse.\n\n  TryGetEllipse(self: Curve,tolerance: float) -> (bool,Ellipse)\n\n  \n\n   Try to convert this curve into an Ellipse using a custom tolerance.\n\n  \n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if the curve could be converted into an Ellipse.\n  \"\"\"\n  pass\n def TryGetPlane(self,plane,tolerance=None):\n  \"\"\"\n  TryGetPlane(self: Curve,tolerance: float) -> (bool,Plane)\n\n  \n\n   Test a curve for planarity and return the plane.\n\n  \n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if there is a plane such that the maximum distance from the curve to the plane is <= \n\n    tolerance.\n\n  \n\n  TryGetPlane(self: Curve) -> (bool,Plane)\n\n  \n\n   Test a curve for planarity and return the plane.\n\n   Returns: true if there is a plane such that the maximum distance from the curve to the plane is <= \n\n    RhinoMath.ZeroTolerance.\n  \"\"\"\n  pass\n def TryGetPolyline(self,polyline,parameters=None):\n  \"\"\"\n  TryGetPolyline(self: Curve) -> (bool,Polyline,Array[float])\n\n  \n\n   Several types of Curve can have the form of a polyline \n\n     including a degree 1 \n\n    NurbsCurve,a PolylineCurve,\n\n     and a PolyCurve all of whose segments are some form \n\n    of \n\n     polyline. IsPolyline tests a curve to see if it can be \n\n     \n\n    represented as a polyline.\n\n  \n\n   Returns: true if this curve can be represented as a polyline; otherwise,false.\n\n  TryGetPolyline(self: Curve) -> (bool,Polyline)\n\n  \n\n   Several types of Curve can have the form of a polyline \n\n     including a degree 1 \n\n    NurbsCurve,a PolylineCurve,\n\n     and a PolyCurve all of whose segments are some form \n\n    of \n\n     polyline. IsPolyline tests a curve to see if it can be \n\n     \n\n    represented as a polyline.\n\n  \n\n   Returns: true if this curve can be represented as a polyline; otherwise,false.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n @staticmethod\n def __new__(self,*args): #cannot find CLR constructor\n  \"\"\"\n  __new__(cls: type)\n\n  __new__(cls: type,info: SerializationInfo,context: StreamingContext)\n  \"\"\"\n  pass\n def __reduce_ex__(self,*args):\n  pass\n Degree=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the maximum algebraic degree of any span\n\n   or a good estimate if curve spans are not algebraic.\n\n\n\nGet: Degree(self: Curve) -> int\n\n\n\n\"\"\"\n\n Dimension=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the dimension of the object.\n\n   The dimension is typically three. For parameter space trimming\n\n   curves the dimension is two. In rare cases the dimension can\n\n   be one or greater than three.\n\n\n\nGet: Dimension(self: Curve) -> int\n\n\n\n\"\"\"\n\n Domain=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets or sets the domain of the curve.\n\n\n\nGet: Domain(self: Curve) -> Interval\n\n\n\nSet: Domain(self: Curve)=value\n\n\"\"\"\n\n IsClosed=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets a value indicating whether or not this curve is a closed curve.\n\n\n\nGet: IsClosed(self: Curve) -> bool\n\n\n\n\"\"\"\n\n IsPeriodic=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets a value indicating whether or not this curve is considered to be Periodic.\n\n\n\nGet: IsPeriodic(self: Curve) -> bool\n\n\n\n\"\"\"\n\n PointAtEnd=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Evaluates point at the end of the curve.\n\n\n\nGet: PointAtEnd(self: Curve) -> Point3d\n\n\n\n\"\"\"\n\n PointAtStart=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Evaluates point at the start of the curve.\n\n\n\nGet: PointAtStart(self: Curve) -> Point3d\n\n\n\n\"\"\"\n\n SpanCount=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the number of non-empty smooth (c-infinity) spans in the curve.\n\n\n\nGet: SpanCount(self: Curve) -> int\n\n\n\n\"\"\"\n\n TangentAtEnd=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Evaluate unit tangent vector at the end of the curve.\n\n\n\nGet: TangentAtEnd(self: Curve) -> Vector3d\n\n\n\n\"\"\"\n\n TangentAtStart=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Evaluates the unit tangent vector at the start of the curve.\n\n\n\nGet: TangentAtStart(self: Curve) -> Vector3d\n\n\n\n\"\"\"\n\n\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "classes", "point", "brep", "line", "dimension", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "0000onoff_Projekt-HS24_c351e034a6.json", "repo": "0000onoff/Projekt-HS24"}
{"instruction": "Represents a base class that is common to most RhinoCommon curve types.", "code": "class Curve(GeometryBase,IDisposable,ISerializable):\n \"\"\"\n Represents a base class that is common to most RhinoCommon curve types.\n\n    A curve represents an entity that can be all visited by providing\n\n    a single parameter,usually called t.\n \"\"\"\n def ChangeClosedCurveSeam(self,t):\n  \"\"\"\n  ChangeClosedCurveSeam(self: Curve,t: float) -> bool\n\n  \n\n   If this curve is closed,then modify it so that the start/end point is at curve parameter t.\n\n  \n\n   t: Curve parameter of new start/end point. The returned curves domain will start at t.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def ChangeDimension(self,desiredDimension):\n  \"\"\"\n  ChangeDimension(self: Curve,desiredDimension: int) -> bool\n\n  \n\n   Changes the dimension of a curve.\n\n  \n\n   desiredDimension: The desired dimension.\n\n   Returns: true if the curve's dimension was already desiredDimension\n\n     or if the curve's \n\n    dimension was successfully changed to desiredDimension;\n\n     otherwise false.\n  \"\"\"\n  pass\n def ClosedCurveOrientation(self,*__args):\n  \"\"\"\n  ClosedCurveOrientation(self: Curve,xform: Transform) -> CurveOrientation\n\n  \n\n   Determines the orientation (counterclockwise or clockwise) of a closed planar curve.\n\n       \n\n     Only works with simple (no self intersections) closed planar curves.\n\n  \n\n  \n\n   xform: Transformation to map the curve to the xy plane. If the curve is parallel\n\n     to the xy \n\n    plane,you may pass Identity matrix.\n\n  \n\n   Returns: The orientation of this curve in the world xy-plane.\n\n  ClosedCurveOrientation(self: Curve,plane: Plane) -> CurveOrientation\n\n  \n\n   Determines the orientation (counterclockwise or clockwise) of a closed planar curve in a given \n\n    plane.\n\n     Only works with simple (no self intersections) closed planar curves.\n\n  \n\n  \n\n   plane: The plane in which to solve the orientation.\n\n   Returns: The orientation of this curve in the given plane.\n\n  ClosedCurveOrientation(self: Curve,upDirection: Vector3d) -> CurveOrientation\n\n  \n\n   Determines the orientation (counterclockwise or clockwise) of a closed planar curve in a given \n\n    plane.\n\n     Only works with simple (no self intersections) closed planar curves.\n\n  \n\n  \n\n   upDirection: A vector that is considered \"up\".\n\n   Returns: The orientation of this curve with respect to a defined up direction.\n  \"\"\"\n  pass\n def ClosestPoint(self,testPoint,t,maximumDistance=None):\n  \"\"\"\n  ClosestPoint(self: Curve,testPoint: Point3d,maximumDistance: float) -> (bool,float)\n\n  \n\n   Finds the parameter of the point on a curve that is closest to testPoint.\n\n     If the \n\n    maximumDistance parameter is > 0,then only points whose distance\n\n     to the given \n\n    point is <= maximumDistance will be returned.  Using a \n\n     positive value of \n\n    maximumDistance can substantially speed up the search.\n\n  \n\n  \n\n   testPoint: Point to project.\n\n   maximumDistance: The maximum allowed distance.\n\n     Past this distance,the search is given up and false \n\n    is returned.Use 0 to turn off this parameter.\n\n  \n\n   Returns: true on success,false on failure.\n\n  ClosestPoint(self: Curve,testPoint: Point3d) -> (bool,float)\n\n  \n\n   Finds parameter of the point on a curve that is closest to testPoint.\n\n     If the \n\n    maximumDistance parameter is > 0,then only points whose distance\n\n     to the given \n\n    point is <= maximumDistance will be returned.  Using a \n\n     positive value of \n\n    maximumDistance can substantially speed up the search.\n\n  \n\n  \n\n   testPoint: Point to search from.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def ClosestPoints(self,*__args):\n  \"\"\"\n  ClosestPoints(self: Curve,otherCurve: Curve) -> (bool,Point3d,Point3d)\n\n  \n\n   Gets closest points between this and another curves.\n\n  \n\n   otherCurve: The other curve.\n\n   Returns: true on success; false on error.\n\n  ClosestPoints(self: Curve,geometry: IEnumerable[GeometryBase]) -> (bool,Point3d,Point3d,int)\n\n  ClosestPoints(self: Curve,geometry: IEnumerable[GeometryBase],maximumDistance: float) -> (bool,Point3d,Point3d,int)\n  \"\"\"\n  pass\n def ConstructConstObject(self,*args):\n  \"\"\"\n  ConstructConstObject(self: CommonObject,parentObject: object,subobject_index: int)\n\n   Assigns a parent object and a subobject index to this.\n\n  \n\n   parentObject: The parent object.\n\n   subobject_index: The subobject index.\n  \"\"\"\n  pass\n def Contains(self,testPoint,plane=None,tolerance=None):\n  \"\"\"\n  Contains(self: Curve,testPoint: Point3d,plane: Plane,tolerance: float) -> PointContainment\n\n  \n\n   Computes the relationship between a point and a closed curve region. \n\n     This curve \n\n    must be closed or the return value will be Unset.\n\n  \n\n  \n\n   testPoint: Point to test.\n\n   plane: Plane in in which to compare point and region.\n\n   tolerance: Tolerance to use during comparison.\n\n   Returns: Relationship between point and curve region.\n\n  Contains(self: Curve,testPoint: Point3d,plane: Plane) -> PointContainment\n\n  \n\n   Computes the relationship between a point and a closed curve region. \n\n     This curve \n\n    must be closed or the return value will be Unset.\n\n  \n\n  \n\n   testPoint: Point to test.\n\n   plane: Plane in in which to compare point and region.\n\n   Returns: Relationship between point and curve region.\n\n  Contains(self: Curve,testPoint: Point3d) -> PointContainment\n\n  \n\n   Computes the relationship between a point and a closed curve region. \n\n     This curve \n\n    must be closed or the return value will be Unset.\n\n     Both curve and point are \n\n    projected to the World XY plane.\n\n  \n\n  \n\n   testPoint: Point to test.\n\n   Returns: Relationship between point and curve region.\n  \"\"\"\n  pass\n @staticmethod\n def CreateBlendCurve(*__args):\n  \"\"\"\n  CreateBlendCurve(curve0: Curve,t0: float,reverse0: bool,continuity0: BlendContinuity,curve1: Curve,t1: float,reverse1: bool,continuity1: BlendContinuity) -> Curve\n\n  \n\n   Makes a curve blend between 2 curves at the parameters specified\n\n     with the \n\n    directions and continuities specified\n\n  \n\n  \n\n   curve0: First curve to blend from\n\n   t0: Parameter on first curve for blend endpoint\n\n   reverse0: If false,the blend will go in the natural direction of the curve.\n\n     If true,the \n\n    blend will go in the opposite direction to the curve\n\n  \n\n   continuity0: continuity for the blend at the start\n\n   curve1: Second curve to blend from\n\n   t1: Parameter on second curve for blend endpoint\n\n   reverse1: If false,the blend will go in the natural direction of the curve.\n\n     If true,the \n\n    blend will go in the opposite direction to the curve\n\n  \n\n   continuity1: continuity for the blend at the end\n\n   Returns: the blend curve on success. null on failure\n\n  CreateBlendCurve(curveA: Curve,curveB: Curve,continuity: BlendContinuity,bulgeA: float,bulgeB: float) -> Curve\n\n  \n\n   Create a Blend curve between two existing curves.\n\n  \n\n   curveA: Curve to blend from (blending will occur at curve end point).\n\n   curveB: Curve to blend to (blending will occur at curve start point).\n\n   continuity: Continuity of blend.\n\n   bulgeA: Bulge factor at curveA end of blend. Values near 1.0 work best.\n\n   bulgeB: Bulge factor at curveB end of blend. Values near 1.0 work best.\n\n   Returns: A curve representing the blend between A and B or null on failure.\n\n  CreateBlendCurve(curveA: Curve,curveB: Curve,continuity: BlendContinuity) -> Curve\n\n  \n\n   Create a Blend curve between two existing curves.\n\n  \n\n   curveA: Curve to blend from (blending will occur at curve end point).\n\n   curveB: Curve to blend to (blending will occur at curve start point).\n\n   continuity: Continuity of blend.\n\n   Returns: A curve representing the blend between A and B or null on failure.\n  \"\"\"\n  pass\n @staticmethod\n def CreateBooleanDifference(curveA,*__args):\n  \"\"\"\n  CreateBooleanDifference(curveA: Curve,subtractors: IEnumerable[Curve]) -> Array[Curve]\n\n  CreateBooleanDifference(curveA: Curve,curveB: Curve) -> Array[Curve]\n\n  \n\n   Calculates the boolean difference between two closed,planar curves. \n\n     Note,curves \n\n    must be co-planar.\n\n  \n\n  \n\n   curveA: The first closed,planar curve.\n\n   curveB: The second closed,planar curve.\n\n   Returns: Result curves on success,empty array if no difference could be calculated.\n  \"\"\"\n  pass\n @staticmethod\n def CreateBooleanIntersection(curveA,curveB):\n  \"\"\"\n  CreateBooleanIntersection(curveA: Curve,curveB: Curve) -> Array[Curve]\n\n  \n\n   Calculates the boolean intersection of two closed,planar curves. \n\n     Note,curves \n\n    must be co-planar.\n\n  \n\n  \n\n   curveA: The first closed,planar curve.\n\n   curveB: The second closed,planar curve.\n\n   Returns: Result curves on success,empty array if no intersection could be calculated.\n  \"\"\"\n  pass\n @staticmethod\n def CreateBooleanUnion(curves):\n  \"\"\" CreateBooleanUnion(curves: IEnumerable[Curve]) -> Array[Curve] \"\"\"\n  pass\n @staticmethod\n def CreateControlPointCurve(points,degree=None):\n  \"\"\"\n  CreateControlPointCurve(points: IEnumerable[Point3d]) -> Curve\n\n  CreateControlPointCurve(points: IEnumerable[Point3d],degree: int) -> Curve\n  \"\"\"\n  pass\n @staticmethod\n def CreateFillet(curve0,curve1,radius,t0Base,t1Base):\n  \"\"\"\n  CreateFillet(curve0: Curve,curve1: Curve,radius: float,t0Base: float,t1Base: float) -> Arc\n\n  \n\n   Computes the fillet arc for a curve filleting operation.\n\n  \n\n   curve0: First curve to fillet.\n\n   curve1: Second curve to fillet.\n\n   radius: Fillet radius.\n\n   t0Base: Parameter on curve0 where the fillet ought to start (approximately).\n\n   t1Base: Parameter on curve1 where the fillet ought to end (approximately).\n\n   Returns: The fillet arc on success,or Arc.Unset on failure.\n  \"\"\"\n  pass\n @staticmethod\n def CreateFilletCurves(curve0,point0,curve1,point1,radius,join,trim,arcExtension,tolerance,angleTolerance):\n  \"\"\"\n  CreateFilletCurves(curve0: Curve,point0: Point3d,curve1: Curve,point1: Point3d,radius: float,join: bool,trim: bool,arcExtension: bool,tolerance: float,angleTolerance: float) -> Array[Curve]\n\n  \n\n   Creates a tangent arc between two curves and trims or extends the curves to the arc.\n\n  \n\n   curve0: The first curve to fillet.\n\n   point0: A point on the first curve that is near the end where the fillet will\n\n     be created.\n\n   curve1: The second curve to fillet.\n\n   point1: A point on the second curve that is near the end where the fillet will\n\n     be created.\n\n   radius: The radius of the fillet.\n\n   join: Join the output curves.\n\n   trim: Trim copies of the input curves to the output fillet curve.\n\n   arcExtension: Applies when arcs are filleted but need to be extended to meet the\n\n     fillet curve or \n\n    chamfer line. If true,then the arc is extended\n\n     maintaining its validity. If false,\n\n    then the arc is extended with a\n\n     line segment,which is joined to the arc converting \n\n    it to a polycurve.\n\n  \n\n   tolerance: The tolerance,generally the document's absolute tolerance.\n\n   Returns: The results of the fillet operation. The number of output curves depends\n\n     on the \n\n    input curves and the values of the parameters that were used\n\n     during the fillet \n\n    operation. In most cases,the output array will contain\n\n     either one or three curves,\n\n    although two curves can be returned if the\n\n     radius is zero and join=false.\n\n      \n\n      For example,if both join and trim=true,then the output curve\n\n     will be a \n\n    polycurve containing the fillet curve joined with trimmed copies\n\n     of the input \n\n    curves. If join=false and trim=true,then three curves,\n\n     the fillet curve and \n\n    trimmed copies of the input curves,will be returned.\n\n     If both join and trim=\n\n    false,then just the fillet curve is returned.\n  \"\"\"\n  pass\n @staticmethod\n def CreateInterpolatedCurve(points,degree,knots=None,startTangent=None,endTangent=None):\n  \"\"\"\n  CreateInterpolatedCurve(points: IEnumerable[Point3d],degree: int,knots: CurveKnotStyle,startTangent: Vector3d,endTangent: Vector3d) -> Curve\n\n  CreateInterpolatedCurve(points: IEnumerable[Point3d],degree: int,knots: CurveKnotStyle) -> Curve\n\n  CreateInterpolatedCurve(points: IEnumerable[Point3d],degree: int) -> Curve\n  \"\"\"\n  pass\n @staticmethod\n def CreateMeanCurve(curveA,curveB,angleToleranceRadians=None):\n  \"\"\"\n  CreateMeanCurve(curveA: Curve,curveB: Curve) -> Curve\n\n  \n\n   Constructs a mean,or average,curve from two curves.\n\n  \n\n   curveA: A first curve.\n\n   curveB: A second curve.\n\n   Returns: The average curve,or null on error.\n\n  CreateMeanCurve(curveA: Curve,curveB: Curve,angleToleranceRadians: float) -> Curve\n\n  \n\n   Constructs a mean,or average,curve from two curves.\n\n  \n\n   curveA: A first curve.\n\n   curveB: A second curve.\n\n   angleToleranceRadians: The angle tolerance,in radians,used to match kinks between curves.\n\n     If you are \n\n    unsure how to set this parameter,then either use the\n\n     document's angle tolerance \n\n    RhinoDoc.AngleToleranceRadians,\n\n     or the default value (RhinoMath.UnsetValue)\n\n  \n\n   Returns: The average curve,or null on error.\n  \"\"\"\n  pass\n @staticmethod\n def CreateTweenCurves(curve0,curve1,numCurves):\n  \"\"\"\n  CreateTweenCurves(curve0: Curve,curve1: Curve,numCurves: int) -> Array[Curve]\n\n  \n\n   Creates curves between two open or closed input curves. Uses the control points of the curves \n\n    for finding tween curves.\n\n     That means the first control point of first curve is \n\n    matched to first control point of the second curve and so on.\n\n     There is no matching \n\n    of curves direction. Caller must match input curves direction before calling the function.\n\n  \n\n  \n\n   curve0: The first,or starting,curve.\n\n   curve1: The second,or ending,curve.\n\n   numCurves: Number of tween curves to create.\n\n   Returns: An array of joint curves. This array can be empty.\n  \"\"\"\n  pass\n @staticmethod\n def CreateTweenCurvesWithMatching(curve0,curve1,numCurves):\n  \"\"\"\n  CreateTweenCurvesWithMatching(curve0: Curve,curve1: Curve,numCurves: int) -> Array[Curve]\n\n  \n\n   Creates curves between two open or closed input curves. Make the structure of input curves \n\n    compatible if needed.\n\n     Refits the input curves to have the same structure. The \n\n    resulting curves are usually more complex than input unless\n\n     input curves are \n\n    compatible and no refit is needed. There is no matching of curves direction.\n\n     Caller \n\n    must match input curves direction before calling the function.\n\n  \n\n  \n\n   curve0: The first,or starting,curve.\n\n   curve1: The second,or ending,curve.\n\n   numCurves: Number of tween curves to create.\n\n   Returns: An array of joint curves. This array can be empty.\n  \"\"\"\n  pass\n @staticmethod\n def CreateTweenCurvesWithSampling(curve0,curve1,numCurves,numSamples):\n  \"\"\"\n  CreateTweenCurvesWithSampling(curve0: Curve,curve1: Curve,numCurves: int,numSamples: int) -> Array[Curve]\n\n  \n\n   Creates curves between two open or closed input curves. Use sample points method to make curves \n\n    compatible.\n\n     This is how the algorithm workd: Divides the two curves into an equal \n\n    number of points,finds the midpoint between the \n\n     corresponding points on the \n\n    curves and interpolates the tween curve through those points. There is no matching of curves\n\n     \n\n       direction. Caller must match input curves direction before calling the function.\n\n  \n\n  \n\n   curve0: The first,or starting,curve.\n\n   curve1: The second,or ending,curve.\n\n   numCurves: Number of tween curves to create.\n\n   numSamples: Number of sample points along input curves.\n\n   Returns: >An array of joint curves. This array can be empty.\n  \"\"\"\n  pass\n def CurvatureAt(self,t):\n  \"\"\"\n  CurvatureAt(self: Curve,t: float) -> Vector3d\n\n  \n\n   Evaluate the curvature vector at a curve parameter.\n\n  \n\n   t: Evaluation parameter.\n\n   Returns: Curvature vector of the curve at the parameter t.\n  \"\"\"\n  pass\n def DerivativeAt(self,t,derivativeCount,side=None):\n  \"\"\"\n  DerivativeAt(self: Curve,t: float,derivativeCount: int,side: CurveEvaluationSide) -> Array[Vector3d]\n\n  \n\n   Evaluate the derivatives at the specified curve parameter.\n\n  \n\n   t: Curve parameter to evaluate.\n\n   derivativeCount: Number of derivatives to evaluate,must be at least 0.\n\n   side: Side of parameter to evaluate. If the parameter is at a kink,\n\n     it makes a big \n\n    difference whether the evaluation is from below or above.\n\n  \n\n   Returns: An array of vectors that represents all the derivatives starting at zero.\n\n  DerivativeAt(self: Curve,t: float,derivativeCount: int) -> Array[Vector3d]\n\n  \n\n   Evaluate the derivatives at the specified curve parameter.\n\n  \n\n   t: Curve parameter to evaluate.\n\n   derivativeCount: Number of derivatives to evaluate,must be at least 0.\n\n   Returns: An array of vectors that represents all the derivatives starting at zero.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\"\n  Dispose(self: Curve,disposing: bool)\n\n   For derived class implementers.\n\n     This method is called with argument true when class \n\n    user calls Dispose(),while with argument false when\n\n     the Garbage Collector invokes \n\n    the finalizer,or Finalize() method.You must reclaim all used unmanaged resources in both cases,\n\n    and can use this chance to call Dispose on disposable fields if the argument is true.Also,you \n\n    must call the base virtual method within your overriding method.\n\n  \n\n  \n\n   disposing: true if the call comes from the Dispose() method; false if it comes from the Garbage Collector \n\n    finalizer.\n  \"\"\"\n  pass\n def DivideAsContour(self,contourStart,contourEnd,interval):\n  \"\"\"\n  DivideAsContour(self: Curve,contourStart: Point3d,contourEnd: Point3d,interval: float) -> Array[Point3d]\n\n  \n\n   Divides this curve at fixed steps along a defined contour line.\n\n  \n\n   contourStart: The start of the contouring line.\n\n   contourEnd: The end of the contouring line.\n\n   interval: A distance to measure on the contouring axis.\n\n   Returns: An array of points; or null on error.\n  \"\"\"\n  pass\n def DivideByCount(self,segmentCount,includeEnds,points=None):\n  \"\"\"\n  DivideByCount(self: Curve,segmentCount: int,includeEnds: bool) -> (Array[float],Array[Point3d])\n\n  \n\n   Divide the curve into a number of equal-length segments.\n\n  \n\n   segmentCount: Segment count. Note that the number of division points may differ from the segment count.\n\n   includeEnds: If true,then the points at the start and end of the curve are included.\n\n   Returns: Array containing division curve parameters on success,null on failure.\n\n  DivideByCount(self: Curve,segmentCount: int,includeEnds: bool) -> Array[float]\n\n  \n\n   Divide the curve into a number of equal-length segments.\n\n  \n\n   segmentCount: Segment count. Note that the number of division points may differ from the segment count.\n\n   includeEnds: If true,then the points at the start and end of the curve are included.\n\n   Returns: List of curve parameters at the division points on success,null on failure.\n  \"\"\"\n  pass\n def DivideByLength(self,segmentLength,includeStart,points=None):\n  \"\"\"\n  DivideByLength(self: Curve,segmentLength: float,includeStart: bool) -> (Array[float],Array[Point3d])\n\n  \n\n   Divide the curve into specific length segments.\n\n  \n\n   segmentLength: The length of each and every segment (except potentially the last one).\n\n   includeStart: If true,then the point at the start of the curve is included.\n\n   Returns: Array containing division curve parameters if successful,null on failure.\n\n  DivideByLength(self: Curve,segmentLength: float,includeStart: bool) -> Array[float]\n\n  \n\n   Divide the curve into specific length segments.\n\n  \n\n   segmentLength: The length of each and every segment (except potentially the last one).\n\n   includeStart: If true,then the points at the start of the curve is included.\n\n   Returns: Array containing division curve parameters if successful,null on failure.\n  \"\"\"\n  pass\n def DivideEquidistant(self,distance):\n  \"\"\"\n  DivideEquidistant(self: Curve,distance: float) -> Array[Point3d]\n\n  \n\n   Calculates 3d points on a curve where the linear distance between the points is equal.\n\n  \n\n   distance: The distance betwen division points.\n\n   Returns: An array of equidistant points,or null on error.\n  \"\"\"\n  pass\n @staticmethod\n def DoDirectionsMatch(curveA,curveB):\n  \"\"\"\n  DoDirectionsMatch(curveA: Curve,curveB: Curve) -> bool\n\n  \n\n   Determines whether two curves travel more or less in the same direction.\n\n  \n\n   curveA: First curve to test.\n\n   curveB: Second curve to test.\n\n   Returns: true if both curves more or less point in the same direction,\n\n     false if they point \n\n    in the opposite directions.\n  \"\"\"\n  pass\n def Duplicate(self):\n  \"\"\"\n  Duplicate(self: Curve) -> GeometryBase\n\n  \n\n   Constructs an exact duplicate of this Curve.\n  \"\"\"\n  pass\n def DuplicateCurve(self):\n  \"\"\"\n  DuplicateCurve(self: Curve) -> Curve\n\n  \n\n   Constructs an exact duplicate of this curve.\n\n   Returns: An exact copy of this curve.\n  \"\"\"\n  pass\n def DuplicateSegments(self):\n  \"\"\"\n  DuplicateSegments(self: Curve) -> Array[Curve]\n\n  \n\n   Polylines will be exploded into line segments. ExplodeCurves will\n\n     return the curves \n\n    in topological order.\n\n  \n\n   Returns: An array of all the segments that make up this curve.\n  \"\"\"\n  pass\n def Extend(self,*__args):\n  \"\"\"\n  Extend(self: Curve,side: CurveEnd,style: CurveExtensionStyle,geometry: IEnumerable[GeometryBase]) -> Curve\n\n  Extend(self: Curve,side: CurveEnd,style: CurveExtensionStyle,endPoint: Point3d) -> Curve\n\n  \n\n   Extends a curve to a point.\n\n  \n\n   side: The end of the curve to extend.\n\n   style: The style or type of extension to use.\n\n   endPoint: A new end point.\n\n   Returns: New extended curve result on success,null on failure.\n\n  Extend(self: Curve,side: CurveEnd,length: float,style: CurveExtensionStyle) -> Curve\n\n  \n\n   Extends a curve by a specific length.\n\n  \n\n   side: Curve end to extend.\n\n   length: Length to add to the curve end.\n\n   style: Extension style.\n\n   Returns: A curve with extended ends or null on failure.\n\n  Extend(self: Curve,t0: float,t1: float) -> Curve\n\n  \n\n   Where possible,analytically extends curve to include the given domain. \n\n     This will \n\n    not work on closed curves. The original curve will be identical to the \n\n     restriction \n\n    of the resulting curve to the original curve domain.\n\n  \n\n  \n\n   t0: Start of extension domain,if the start is not inside the \n\n     Domain of this curve,an \n\n    attempt will be made to extend the curve.\n\n  \n\n   t1: End of extension domain,if the end is not inside the \n\n     Domain of this curve,an \n\n    attempt will be made to extend the curve.\n\n  \n\n   Returns: Extended curve on success,null on failure.\n\n  Extend(self: Curve,domain: Interval) -> Curve\n\n  \n\n   Where possible,analytically extends curve to include the given domain. \n\n     This will \n\n    not work on closed curves. The original curve will be identical to the \n\n     restriction \n\n    of the resulting curve to the original curve domain.\n\n  \n\n  \n\n   domain: Extension domain.\n\n   Returns: Extended curve on success,null on failure.\n  \"\"\"\n  pass\n def ExtendByArc(self,side,geometry):\n  \"\"\" ExtendByArc(self: Curve,side: CurveEnd,geometry: IEnumerable[GeometryBase]) -> Curve \"\"\"\n  pass\n def ExtendByLine(self,side,geometry):\n  \"\"\" ExtendByLine(self: Curve,side: CurveEnd,geometry: IEnumerable[GeometryBase]) -> Curve \"\"\"\n  pass\n def ExtendOnSurface(self,side,*__args):\n  \"\"\"\n  ExtendOnSurface(self: Curve,side: CurveEnd,face: BrepFace) -> Curve\n\n  \n\n   Extends a curve on a surface.\n\n  \n\n   side: The end of the curve to extend.\n\n   face: BrepFace that contains the curve.\n\n   Returns: New extended curve result on success,null on failure.\n\n  ExtendOnSurface(self: Curve,side: CurveEnd,surface: Surface) -> Curve\n\n  \n\n   Extends a curve on a surface.\n\n  \n\n   side: The end of the curve to extend.\n\n   surface: Surface that contains the curve.\n\n   Returns: New extended curve result on success,null on failure.\n  \"\"\"\n  pass\n def Fair(self,distanceTolerance,angleTolerance,clampStart,clampEnd,iterations):\n  \"\"\"\n  Fair(self: Curve,distanceTolerance: float,angleTolerance: float,clampStart: int,clampEnd: int,iterations: int) -> Curve\n\n  \n\n   Fairs a curve object. Fair works best on degree 3 (cubic) curves. Attempts to \n\n     \n\n    remove large curvature variations while limiting the geometry changes to be no \n\n     \n\n    more than the specified tolerance.\n\n  \n\n  \n\n   distanceTolerance: Maximum allowed distance the faired curve is allowed to deviate from the input.\n\n   angleTolerance: (in radians) kinks with angles <= angleTolerance are smoothed out 0.05 is a good default.\n\n   clampStart: The number of (control vertices-1) to preserve at start. \n\n     0=preserve start point1 \n\n   =preserve start point and 1st derivative2=preserve start point,1st and 2nd derivative\n\n  \n\n   clampEnd: Same as clampStart.\n\n   iterations: The number of iteratoins to use in adjusting the curve.\n\n   Returns: Returns new faired Curve on success,null on failure.\n  \"\"\"\n  pass\n def Fit(self,degree,fitTolerance,angleTolerance):\n  \"\"\"\n  Fit(self: Curve,degree: int,fitTolerance: float,angleTolerance: float) -> Curve\n\n  \n\n   Fits a new curve through an existing curve.\n\n  \n\n   degree: The degree of the returned Curve. Must be bigger than 1.\n\n   fitTolerance: The fitting tolerance. If fitTolerance is RhinoMath.UnsetValue or <=0.0,\n\n     the \n\n    document absolute tolerance is used.\n\n  \n\n   angleTolerance: The kink smoothing tolerance in radians.\n\n     If angleTolerance is 0.0,all kinks are \n\n    smoothedIf angleTolerance is >0.0,kinks smaller than angleTolerance are smoothedIf \n\n    angleTolerance is RhinoMath.UnsetValue or <0.0,the document angle tolerance is used for the \n\n    kink smoothing\n\n  \n\n   Returns: Returns a new fitted Curve if successful,null on failure.\n  \"\"\"\n  pass\n def FrameAt(self,t,plane):\n  \"\"\"\n  FrameAt(self: Curve,t: float) -> (bool,Plane)\n\n  \n\n   Returns a 3d frame at a parameter.\n\n  \n\n   t: Evaluation parameter.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def GetCurveParameterFromNurbsFormParameter(self,nurbsParameter,curveParameter):\n  \"\"\"\n  GetCurveParameterFromNurbsFormParameter(self: Curve,nurbsParameter: float) -> (bool,float)\n\n  \n\n   Convert a NURBS curve parameter to a curve parameter.\n\n  \n\n   nurbsParameter: Nurbs form parameter.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n @staticmethod\n def GetDistancesBetweenCurves(curveA,curveB,tolerance,maxDistance,maxDistanceParameterA,maxDistanceParameterB,minDistance,minDistanceParameterA,minDistanceParameterB):\n  \"\"\"\n  GetDistancesBetweenCurves(curveA: Curve,curveB: Curve,tolerance: float) -> (bool,float,float,float,float,float,float)\n\n  \n\n   Computes the distances between two arbitrary curves that overlap.\n\n  \n\n   curveA: A curve.\n\n   curveB: Another curve.\n\n   tolerance: A tolerance value.\n\n   Returns: true if the operation succeeded; otherwise false.\n  \"\"\"\n  pass\n @staticmethod\n def GetFilletPoints(curve0,curve1,radius,t0Base,t1Base,t0,t1,filletPlane):\n  \"\"\"\n  GetFilletPoints(curve0: Curve,curve1: Curve,radius: float,t0Base: float,t1Base: float) -> (bool,float,float,Plane)\n\n  \n\n   Finds points at which to cut a pair of curves so that a fillet of given radius can be inserted.\n\n  \n\n   curve0: First curve to fillet.\n\n   curve1: Second curve to fillet.\n\n   radius: Fillet radius.\n\n   t0Base: Parameter value for base point on curve0.\n\n   t1Base: Parameter value for base point on curve1.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def GetLength(self,*__args):\n  \"\"\"\n  GetLength(self: Curve,subdomain: Interval) -> float\n\n  \n\n   Get the length of a sub-section of the curve with a fractional tolerance of 1e-8.\n\n  \n\n   subdomain: The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).\n\n   Returns: The length of the sub-curve on success,or zero on failure.\n\n  GetLength(self: Curve,fractionalTolerance: float,subdomain: Interval) -> float\n\n  \n\n   Get the length of a sub-section of the curve.\n\n  \n\n   fractionalTolerance: Desired fractional precision. \n\n     fabs((\"exact\" length from start to t) - \n\n    arc_length)/arc_length <= fractionalTolerance.\n\n  \n\n   subdomain: The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).\n\n   Returns: The length of the sub-curve on success,or zero on failure.\n\n  GetLength(self: Curve) -> float\n\n  \n\n   Gets the length of the curve with a fractional tolerance of 1.0e-8.\n\n   Returns: The length of the curve on success,or zero on failure.\n\n  GetLength(self: Curve,fractionalTolerance: float) -> float\n\n  \n\n   Get the length of the curve.\n\n  \n\n   fractionalTolerance: Desired fractional precision. \n\n     fabs((\"exact\" length from start to t) - \n\n    arc_length)/arc_length <= fractionalTolerance.\n\n  \n\n   Returns: The length of the curve on success,or zero on failure.\n  \"\"\"\n  pass\n def GetNextDiscontinuity(self,continuityType,t0,t1,t):\n  \"\"\"\n  GetNextDiscontinuity(self: Curve,continuityType: Continuity,t0: float,t1: float) -> (bool,float)\n\n  \n\n   Searches for a derivative,tangent,or curvature discontinuity.\n\n  \n\n   continuityType: Type of continuity to search for.\n\n   t0: Search begins at t0. If there is a discontinuity at t0,it will be ignored. This makes it\n\n     \n\n       possible to repeatedly call GetNextDiscontinuity() and step through the discontinuities.\n\n  \n\n   t1: (t0 != t1)  If there is a discontinuity at t1 it will be ignored unless continuityType is\n\n     \n\n       a locus discontinuity type and t1 is at the start or end of the curve.\n\n  \n\n   Returns: Parametric continuity tests c=(C0_continuous,...,G2_continuous):\n\n      true if a \n\n    parametric discontinuity was found strictly between t0 and t1. Note well that\n\n      all \n\n    curves are parametrically continuous at the ends of their domains.\n\n     \n\n     \n\n    Locus continuity tests c=(C0_locus_continuous,...,G2_locus_continuous):\n\n      true if \n\n    a locus discontinuity was found strictly between t0 and t1 or at t1 is the at the end\n\n      \n\n    of a curve. Note well that all open curves (IsClosed()=false) are locus discontinuous at the\n\n  \n\n        ends of their domains.  All closed curves (IsClosed()=true) are at least \n\n    C0_locus_continuous at \n\n      the ends of their domains.\n  \"\"\"\n  pass\n def GetNurbsFormParameterFromCurveParameter(self,curveParameter,nurbsParameter):\n  \"\"\"\n  GetNurbsFormParameterFromCurveParameter(self: Curve,curveParameter: float) -> (bool,float)\n\n  \n\n   Convert a curve parameter to a NURBS curve parameter.\n\n  \n\n   curveParameter: Curve parameter.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def GetPerpendicularFrames(self,parameters):\n  \"\"\" GetPerpendicularFrames(self: Curve,parameters: IEnumerable[float]) -> Array[Plane] \"\"\"\n  pass\n def HasNurbsForm(self):\n  \"\"\"\n  HasNurbsForm(self: Curve) -> int\n\n  \n\n   Does a NURBS curve representation of this curve exist?\n\n   Returns: 0   unable to create NURBS representation with desired accuracy.\n\n     1   success - \n\n    NURBS parameterization matches the curve's to the desired accuracy\n\n     2   success - \n\n    NURBS point locus matches the curve's and the domain of the NURBS\n\n          \n\n    curve is correct. However,This curve's parameterization and the\n\n          \n\n    NURBS curve parameterization may not match. This situation happens\n\n          \n\n    when getting NURBS representations of curves that have a\n\n          \n\n    transendental parameterization like circles.\n  \"\"\"\n  pass\n def IsArc(self,tolerance=None):\n  \"\"\"\n  IsArc(self: Curve,tolerance: float) -> bool\n\n  \n\n   Test a curve to see if it can be represented by an arc or circle within the given tolerance.\n\n  \n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if the curve can be represented by an arc or a circle within tolerance.\n\n  IsArc(self: Curve) -> bool\n\n  \n\n   Test a curve to see if it can be represented by an arc or circle within RhinoMath.ZeroTolerance.\n\n   Returns: true if the curve can be represented by an arc or a circle within tolerance.\n  \"\"\"\n  pass\n def IsCircle(self,tolerance=None):\n  \"\"\"\n  IsCircle(self: Curve,tolerance: float) -> bool\n\n  \n\n   Test a curve to see if it can be represented by a circle within the given tolerance.\n\n  \n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if the curve can be represented by a circle to within tolerance.\n\n  IsCircle(self: Curve) -> bool\n\n  \n\n   Test a curve to see if it can be represented by a circle within RhinoMath.ZeroTolerance.\n\n   Returns: true if the Curve can be represented by a circle within tolerance.\n  \"\"\"\n  pass\n def IsClosable(self,tolerance,minimumAbsoluteSize=None,minimumRelativeSize=None):\n  \"\"\"\n  IsClosable(self: Curve,tolerance: float) -> bool\n\n  \n\n   Decide if it makes sense to close off this curve by moving the endpoint \n\n     to the \n\n    start based on start-end gap size and length of curve as \n\n     approximated by chord \n\n    defined by 6 points.\n\n  \n\n  \n\n   tolerance: Maximum allowable distance between start and end. \n\n     If start - end gap is greater \n\n    than tolerance,this function will return false.\n\n  \n\n   Returns: true if start and end points are close enough based on above conditions.\n\n  IsClosable(self: Curve,tolerance: float,minimumAbsoluteSize: float,minimumRelativeSize: float) -> bool\n\n  \n\n   Decide if it makes sense to close off this curve by moving the endpoint\n\n     to the \n\n    start based on start-end gap size and length of curve as\n\n     approximated by chord \n\n    defined by 6 points.\n\n  \n\n  \n\n   tolerance: Maximum allowable distance between start and end. \n\n     If start - end gap is greater \n\n    than tolerance,this function will return false.\n\n  \n\n   minimumAbsoluteSize: If greater than 0.0 and none of the interior sampled points are at\n\n     least \n\n    minimumAbsoluteSize from start,this function will return false.\n\n  \n\n   minimumRelativeSize: If greater than 1.0 and chord length is less than \n\n     minimumRelativeSize*gap,this \n\n    function will return false.\n\n  \n\n   Returns: true if start and end points are close enough based on above conditions.\n  \"\"\"\n  pass\n def IsContinuous(self,continuityType,t):\n  \"\"\"\n  IsContinuous(self: Curve,continuityType: Continuity,t: float) -> bool\n\n  \n\n   Test continuity at a curve parameter value.\n\n  \n\n   continuityType: Type of continuity to test for.\n\n   t: Parameter to test.\n\n   Returns: true if the curve has at least the c type continuity at the parameter t.\n  \"\"\"\n  pass\n def IsEllipse(self,tolerance=None):\n  \"\"\"\n  IsEllipse(self: Curve,tolerance: float) -> bool\n\n  \n\n   Test a curve to see if it can be represented by an ellipse within a given tolerance.\n\n  \n\n   tolerance: Tolerance to use for checking.\n\n   Returns: true if the Curve can be represented by an ellipse within tolerance.\n\n  IsEllipse(self: Curve) -> bool\n\n  \n\n   Test a curve to see if it can be represented by an ellipse within RhinoMath.ZeroTolerance.\n\n   Returns: true if the Curve can be represented by an ellipse within tolerance.\n  \"\"\"\n  pass\n def IsInPlane(self,testPlane,tolerance=None):\n  \"\"\"\n  IsInPlane(self: Curve,testPlane: Plane,tolerance: float) -> bool\n\n  \n\n   Test a curve to see if it lies in a specific plane.\n\n  \n\n   testPlane: Plane to test for.\n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if the maximum distance from the curve to the testPlane is <= tolerance.\n\n  IsInPlane(self: Curve,testPlane: Plane) -> bool\n\n  \n\n   Test a curve to see if it lies in a specific plane.\n\n  \n\n   testPlane: Plane to test for.\n\n   Returns: true if the maximum distance from the curve to the testPlane is <= RhinoMath.ZeroTolerance.\n  \"\"\"\n  pass\n def IsLinear(self,tolerance=None):\n  \"\"\"\n  IsLinear(self: Curve,tolerance: float) -> bool\n\n  \n\n   Test a curve to see if it is linear to within the custom tolerance.\n\n  \n\n   tolerance: Tolerance to use when checking linearity.\n\n   Returns: true if the ends of the curve are farther than tolerance apart\n\n     and the maximum \n\n    distance from any point on the curve to\n\n     the line segment connecting the curve ends \n\n    is <= tolerance.\n\n  \n\n  IsLinear(self: Curve) -> bool\n\n  \n\n   Test a curve to see if it is linear to within RhinoMath.ZeroTolerance units (1e-12).\n\n   Returns: true if the curve is linear.\n  \"\"\"\n  pass\n def IsPlanar(self,tolerance=None):\n  \"\"\"\n  IsPlanar(self: Curve,tolerance: float) -> bool\n\n  \n\n   Test a curve for planarity.\n\n  \n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if there is a plane such that the maximum distance from the curve to the plane is <= \n\n    tolerance.\n\n  \n\n  IsPlanar(self: Curve) -> bool\n\n  \n\n   Test a curve for planarity.\n\n   Returns: true if the curve is planar (flat) to within RhinoMath.ZeroTolerance units (1e-12).\n  \"\"\"\n  pass\n def IsPolyline(self):\n  \"\"\"\n  IsPolyline(self: Curve) -> bool\n\n  \n\n   Several types of Curve can have the form of a polyline\n\n     including a degree 1 \n\n    NurbsCurve,a PolylineCurve,\n\n     and a PolyCurve all of whose segments are some form of\n\n\n    \n     polyline. IsPolyline tests a curve to see if it can be\n\n     represented as \n\n    a polyline.\n\n  \n\n   Returns: true if this curve can be represented as a polyline; otherwise,false.\n  \"\"\"\n  pass\n def IsShort(self,tolerance,subdomain=None):\n  \"\"\"\n  IsShort(self: Curve,tolerance: float,subdomain: Interval) -> bool\n\n  \n\n   Used to quickly find short curves.\n\n  \n\n   tolerance: Length threshold value for \"shortness\".\n\n   subdomain: The test is performed on the interval that is the intersection of subdomain with Domain()\n\n   Returns: true if the length of the curve is <= tolerance.\n\n  IsShort(self: Curve,tolerance: float) -> bool\n\n  \n\n   Used to quickly find short curves.\n\n  \n\n   tolerance: Length threshold value for \"shortness\".\n\n   Returns: true if the length of the curve is <= tolerance.\n  \"\"\"\n  pass\n @staticmethod\n def JoinCurves(inputCurves,joinTolerance=None,preserveDirection=None):\n  \"\"\"\n  JoinCurves(inputCurves: IEnumerable[Curve],joinTolerance: float,preserveDirection: bool) -> Array[Curve]\n\n  JoinCurves(inputCurves: IEnumerable[Curve],joinTolerance: float) -> Array[Curve]\n\n  JoinCurves(inputCurves: IEnumerable[Curve]) -> Array[Curve]\n  \"\"\"\n  pass\n def LengthParameter(self,segmentLength,t,*__args):\n  \"\"\"\n  LengthParameter(self: Curve,segmentLength: float,subdomain: Interval) -> (bool,float)\n\n  \n\n   Gets the parameter along the curve which coincides with a given length along the curve. \n\n      \n\n      A fractional tolerance of 1e-8 is used in this version of the function.\n\n  \n\n  \n\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the subdomain.\n\n   subdomain: The calculation is performed on the specified sub-domain of the curve rather than the whole \n\n    curve.\n\n  \n\n   Returns: true on success,false on failure.\n\n  LengthParameter(self: Curve,segmentLength: float,fractionalTolerance: float,subdomain: Interval) -> (bool,float)\n\n  \n\n   Gets the parameter along the curve which coincides with a given length along the curve.\n\n  \n\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the subdomain.\n\n   fractionalTolerance: Desired fractional precision. \n\n     fabs((\"exact\" length from start to t) - \n\n    arc_length)/arc_length <= fractionalTolerance.\n\n  \n\n   subdomain: The calculation is performed on the specified sub-domain of the curve rather than the whole \n\n    curve.\n\n  \n\n   Returns: true on success,false on failure.\n\n  LengthParameter(self: Curve,segmentLength: float) -> (bool,float)\n\n  \n\n   Gets the parameter along the curve which coincides with a given length along the curve. \n\n      \n\n      A fractional tolerance of 1e-8 is used in this version of the function.\n\n  \n\n  \n\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the curve.\n\n   Returns: true on success,false on failure.\n\n  LengthParameter(self: Curve,segmentLength: float,fractionalTolerance: float) -> (bool,float)\n\n  \n\n   Gets the parameter along the curve which coincides with a given length along the curve.\n\n  \n\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the curve.\n\n   fractionalTolerance: Desired fractional precision.\n\n     fabs((\"exact\" length from start to t) - \n\n    arc_length)/arc_length <= fractionalTolerance.\n\n  \n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def MakeClosed(self,tolerance):\n  \"\"\"\n  MakeClosed(self: Curve,tolerance: float) -> bool\n\n  \n\n   If IsClosed,just return true. Otherwise,decide if curve can be closed as \n\n     \n\n    follows: Linear curves polylinear curves with 2 segments,Nurbs with 3 or less \n\n     \n\n    control points cannot be made closed. Also,if tolerance > 0 and the gap between \n\n     \n\n    start and end is larger than tolerance,curve cannot be made closed. \n\n     Adjust the \n\n    curve's endpoint to match its start point.\n\n  \n\n  \n\n   tolerance: If nonzero,and the gap is more than tolerance,curve cannot be made closed.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n @staticmethod\n def MakeEndsMeet(curveA,adjustStartCurveA,curveB,adjustStartCurveB):\n  \"\"\"\n  MakeEndsMeet(curveA: Curve,adjustStartCurveA: bool,curveB: Curve,adjustStartCurveB: bool) -> bool\n\n  \n\n   Makes adjustments to the ends of one or both input curves so that they meet at a point.\n\n  \n\n   curveA: 1st curve to adjust.\n\n   adjustStartCurveA: Which end of the 1st curve to adjust: true is start,false is end.\n\n   curveB: 2nd curve to adjust.\n\n   adjustStartCurveB: which end of the 2nd curve to adjust true==start,false==end.\n\n   Returns: true on success.\n  \"\"\"\n  pass\n def NonConstOperation(self,*args):\n  \"\"\"\n  NonConstOperation(self: Curve)\n\n   For derived classes implementers.\n\n     Defines the necessary implementation to free the \n\n    instance from being const.\n  \"\"\"\n  pass\n def NormalizedLengthParameter(self,s,t,*__args):\n  \"\"\"\n  NormalizedLengthParameter(self: Curve,s: float,subdomain: Interval) -> (bool,float)\n\n  \n\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \n\n    the curve. \n\n     A fractional tolerance of 1e-8 is used in this version of the function.\n\n  \n\n  \n\n   s: Normalized arc length parameter. \n\n     E.g.,0=start of curve,1/2=midpoint of \n\n    curve,1=end of curve.\n\n  \n\n   subdomain: The calculation is performed on the specified sub-domain of the curve.\n\n   Returns: true on success,false on failure.\n\n  NormalizedLengthParameter(self: Curve,s: float,fractionalTolerance: float,subdomain: Interval) -> (bool,float)\n\n  \n\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \n\n    the curve.\n\n  \n\n  \n\n   s: Normalized arc length parameter. \n\n     E.g.,0=start of curve,1/2=midpoint of \n\n    curve,1=end of curve.\n\n  \n\n   fractionalTolerance: Desired fractional precision. \n\n     fabs((\"exact\" length from start to t) - \n\n    arc_length)/arc_length <= fractionalTolerance.\n\n  \n\n   subdomain: The calculation is performed on the specified sub-domain of the curve.\n\n   Returns: true on success,false on failure.\n\n  NormalizedLengthParameter(self: Curve,s: float) -> (bool,float)\n\n  \n\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \n\n    the curve. \n\n     A fractional tolerance of 1e-8 is used in this version of the function.\n\n  \n\n  \n\n   s: Normalized arc length parameter. \n\n     E.g.,0=start of curve,1/2=midpoint of \n\n    curve,1=end of curve.\n\n  \n\n   Returns: true on success,false on failure.\n\n  NormalizedLengthParameter(self: Curve,s: float,fractionalTolerance: float) -> (bool,float)\n\n  \n\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \n\n    the curve.\n\n  \n\n  \n\n   s: Normalized arc length parameter. \n\n     E.g.,0=start of curve,1/2=midpoint of \n\n    curve,1=end of curve.\n\n  \n\n   fractionalTolerance: Desired fractional precision. \n\n     fabs((\"exact\" length from start to t) - \n\n    arc_length)/arc_length <= fractionalTolerance.\n\n  \n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def NormalizedLengthParameters(self,s,absoluteTolerance,*__args):\n  \"\"\"\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float,subdomain: Interval) -> Array[float]\n\n  \n\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \n\n    the curve. \n\n     A fractional tolerance of 1e-8 is used in this version of the function.\n\n  \n\n  \n\n   s: Array of normalized arc length parameters. \n\n     E.g.,0=start of curve,1/2=\n\n    midpoint of curve,1=end of curve.\n\n  \n\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \n\n     \n\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n\n  \n\n   subdomain: The calculation is performed on the specified sub-domain of the curve. \n\n     A 0.0 s \n\n    value corresponds to subdomain->Min() and a 1.0 s value corresponds to subdomain->Max().\n\n  \n\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \n\n    t[i] is s[i]*curve_length. \n\n     Null on failure.\n\n  \n\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float,fractionalTolerance: float,subdomain: Interval) -> Array[float]\n\n  \n\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \n\n    the curve.\n\n  \n\n  \n\n   s: Array of normalized arc length parameters. \n\n     E.g.,0=start of curve,1/2=\n\n    midpoint of curve,1=end of curve.\n\n  \n\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \n\n     \n\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n\n  \n\n   fractionalTolerance: Desired fractional precision for each segment. \n\n     fabs(\"true\" length - actual \n\n    length)/(actual length) <= fractionalTolerance.\n\n  \n\n   subdomain: The calculation is performed on the specified sub-domain of the curve. \n\n     A 0.0 s \n\n    value corresponds to subdomain->Min() and a 1.0 s value corresponds to subdomain->Max().\n\n  \n\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \n\n    t[i] is s[i]*curve_length. \n\n     Null on failure.\n\n  \n\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float) -> Array[float]\n\n  \n\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \n\n    the curve. \n\n     A fractional tolerance of 1e-8 is used in this version of the function.\n\n  \n\n  \n\n   s: Array of normalized arc length parameters. \n\n     E.g.,0=start of curve,1/2=\n\n    midpoint of curve,1=end of curve.\n\n  \n\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \n\n     \n\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n\n  \n\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \n\n    t[i] is s[i]*curve_length. \n\n     Null on failure.\n\n  \n\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float,fractionalTolerance: float) -> Array[float]\n\n  \n\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \n\n    the curve.\n\n  \n\n  \n\n   s: Array of normalized arc length parameters. \n\n     E.g.,0=start of curve,1/2=\n\n    midpoint of curve,1=end of curve.\n\n  \n\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \n\n     \n\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n\n  \n\n   fractionalTolerance: Desired fractional precision for each segment. \n\n     fabs(\"true\" length - actual \n\n    length)/(actual length) <= fractionalTolerance.\n\n  \n\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \n\n    t[i] is s[i]*curve_length. \n\n     Null on failure.\n  \"\"\"\n  pass\n def Offset(self,*__args):\n  \"\"\"\n  Offset(self: Curve,directionPoint: Point3d,normal: Vector3d,distance: float,tolerance: float,cornerStyle: CurveOffsetCornerStyle) -> Array[Curve]\n\n  \n\n   Offsets this curve. If you have a nice offset,then there will be one entry in \n\n     the \n\n    array. If the original curve had kinks or the offset curve had self \n\n     intersections,\n\n    you will get multiple segments in the offset_curves[] array.\n\n  \n\n  \n\n   directionPoint: A point that indicates the direction of the offset.\n\n   normal: The normal to the offset plane.\n\n   distance: The positive or negative distance to offset.\n\n   tolerance: The offset or fitting tolerance.\n\n   cornerStyle: Corner style for offset kinks.\n\n   Returns: Offset curves on success,null on failure.\n\n  Offset(self: Curve,plane: Plane,distance: float,tolerance: float,cornerStyle: CurveOffsetCornerStyle) -> Array[Curve]\n\n  \n\n   Offsets this curve. If you have a nice offset,then there will be one entry in \n\n     the \n\n    array. If the original curve had kinks or the offset curve had self \n\n     intersections,\n\n    you will get multiple segments in the offset_curves[] array.\n\n  \n\n  \n\n   plane: Offset solution plane.\n\n   distance: The positive or negative distance to offset.\n\n   tolerance: The offset or fitting tolerance.\n\n   cornerStyle: Corner style for offset kinks.\n\n   Returns: Offset curves on success,null on failure.\n  \"\"\"\n  pass\n def OffsetNormalToSurface(self,surface,height):\n  \"\"\"\n  OffsetNormalToSurface(self: Curve,surface: Surface,height: float) -> Curve\n\n  \n\n   Finds a curve by offsetting an existing curve normal to a surface.\n\n     The caller is \n\n    responsible for ensuring that the curve lies on the input surface.\n\n  \n\n  \n\n   surface: Surface from which normals are calculated.\n\n   height: offset distance (distance from surface to result curve)\n\n   Returns: Offset curve at distance height from the surface.  The offset curve is\n\n     interpolated \n\n    through a small number of points so if the surface is irregular\n\n     or complicated,the \n\n    result will not be a very accurate offset.\n  \"\"\"\n  pass\n def OffsetOnSurface(self,*__args):\n  \"\"\"\n  OffsetOnSurface(self: Curve,surface: Surface,distance: float,fittingTolerance: float) -> Array[Curve]\n\n  \n\n   Offset a curve on a surface. This curve must lie on the surface.\n\n  \n\n   surface: A surface on which to offset.\n\n   distance: A distance to offset (+)left,(-)right.\n\n   fittingTolerance: A fitting tolerance.\n\n   Returns: Offset curves on success,or null on failure.\n\n  OffsetOnSurface(self: Curve,surface: Surface,throughPoint: Point2d,fittingTolerance: float) -> Array[Curve]\n\n  \n\n   Offset a curve on a surface. This curve must lie on the surface.\n\n     This overload \n\n    allows to specify a surface point at which the offset will pass.\n\n  \n\n  \n\n   surface: A surface on which to offset.\n\n   throughPoint: 2d point on the brep face to offset through.\n\n   fittingTolerance: A fitting tolerance.\n\n   Returns: Offset curves on success,or null on failure.\n\n  OffsetOnSurface(self: Curve,surface: Surface,curveParameters: Array[float],offsetDistances: Array[float],fittingTolerance: float) -> Array[Curve]\n\n  \n\n   Offset this curve on a surface. This curve must lie on the surface.\n\n     This overload \n\n    allows to specify different offsets for different curve parameters.\n\n  \n\n  \n\n   surface: A surface on which to offset.\n\n   curveParameters: Curve parameters corresponding to the offset distances.\n\n   offsetDistances: Distances to offset (+)left,(-)right.\n\n   fittingTolerance: A fitting tolerance.\n\n   Returns: Offset curves on success,or null on failure.\n\n  OffsetOnSurface(self: Curve,face: BrepFace,distance: float,fittingTolerance: float) -> Array[Curve]\n\n  \n\n   Offset this curve on a brep face surface. This curve must lie on the surface.\n\n  \n\n   face: The brep face on which to offset.\n\n   distance: A distance to offset (+)left,(-)right.\n\n   fittingTolerance: A fitting tolerance.\n\n   Returns: Offset curves on success,or null on failure.\n\n  OffsetOnSurface(self: Curve,face: BrepFace,throughPoint: Point2d,fittingTolerance: float) -> Array[Curve]\n\n  \n\n   Offset a curve on a brep face surface. This curve must lie on the surface.\n\n     This \n\n    overload allows to specify a surface point at which the offset will pass.\n\n  \n\n  \n\n   face: The brep face on which to offset.\n\n   throughPoint: 2d point on the brep face to offset through.\n\n   fittingTolerance: A fitting tolerance.\n\n   Returns: Offset curves on success,or null on failure.\n\n  OffsetOnSurface(self: Curve,face: BrepFace,curveParameters: Array[float],offsetDistances: Array[float],fittingTolerance: float) -> Array[Curve]\n\n  \n\n   Offset a curve on a brep face surface. This curve must lie on the surface.\n\n     This \n\n    overload allows to specify different offsets for different curve parameters.\n\n  \n\n  \n\n   face: The brep face on which to offset.\n\n   curveParameters: Curve parameters corresponding to the offset distances.\n\n   offsetDistances: distances to offset (+)left,(-)right.\n\n   fittingTolerance: A fitting tolerance.\n\n   Returns: Offset curves on success,or null on failure.\n  \"\"\"\n  pass\n def OnSwitchToNonConst(self,*args):\n  \"\"\"\n  OnSwitchToNonConst(self: GeometryBase)\n\n   Is called when a non-const operation occurs.\n  \"\"\"\n  pass\n def PerpendicularFrameAt(self,t,plane):\n  \"\"\"\n  PerpendicularFrameAt(self: Curve,t: float) -> (bool,Plane)\n\n  \n\n   Return a 3d frame at a parameter. This is slightly different than FrameAt in\n\n     that \n\n    the frame is computed in a way so there is minimal rotation from one\n\n     frame to the \n\n    next.\n\n  \n\n  \n\n   t: Evaluation parameter.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n @staticmethod\n def PlanarClosedCurveRelationship(curveA,curveB,testPlane,tolerance):\n  \"\"\"\n  PlanarClosedCurveRelationship(curveA: Curve,curveB: Curve,testPlane: Plane,tolerance: float) -> RegionContainment\n\n  \n\n   Determines whether two coplanar simple closed curves are disjoint or intersect;\n\n     \n\n    otherwise,if the regions have a containment relationship,discovers\n\n     which curve \n\n    encloses the other.\n\n  \n\n  \n\n   curveA: A first curve.\n\n   curveB: A second curve.\n\n   testPlane: A plane.\n\n   tolerance: A tolerance value.\n\n   Returns: A value indicating the relationship between the first and the second curve.\n  \"\"\"\n  pass\n @staticmethod\n def PlanarCurveCollision(curveA,curveB,testPlane,tolerance):\n  \"\"\"\n  PlanarCurveCollision(curveA: Curve,curveB: Curve,testPlane: Plane,tolerance: float) -> bool\n\n  \n\n   Determines if two coplanar curves collide (intersect).\n\n  \n\n   curveA: A curve.\n\n   curveB: Another curve.\n\n   testPlane: A valid plane containing the curves.\n\n   tolerance: A tolerance value for intersection.\n\n   Returns: true if the curves intersect,otherwise false\n  \"\"\"\n  pass\n def PointAt(self,t):\n  \"\"\"\n  PointAt(self: Curve,t: float) -> Point3d\n\n  \n\n   Evaluates point at a curve parameter.\n\n  \n\n   t: Evaluation parameter.\n\n   Returns: Point (location of curve at the parameter t).\n  \"\"\"\n  pass\n def PointAtLength(self,length):\n  \"\"\"\n  PointAtLength(self: Curve,length: float) -> Point3d\n\n  \n\n   Gets a point at a certain length along the curve. The length must be \n\n     non-negative \n\n    and less than or equal to the length of the curve. \n\n     Lengths will not be wrapped \n\n    when the curve is closed or periodic.\n\n  \n\n  \n\n   length: Length along the curve between the start point and the returned point.\n\n   Returns: Point on the curve at the specified length from the start point or Poin3d.Unset on failure.\n  \"\"\"\n  pass\n def PointAtNormalizedLength(self,length):\n  \"\"\"\n  PointAtNormalizedLength(self: Curve,length: float) -> Point3d\n\n  \n\n   Gets a point at a certain normalized length along the curve. The length must be \n\n     \n\n    between or including 0.0 and 1.0,where 0.0 equals the start of the curve and \n\n     1.0 \n\n    equals the end of the curve.\n\n  \n\n  \n\n   length: Normalized length along the curve between the start point and the returned point.\n\n   Returns: Point on the curve at the specified normalized length from the start point or Poin3d.Unset on \n\n    failure.\n  \"\"\"\n  pass\n @staticmethod\n def ProjectToBrep(*__args):\n  \"\"\"\n  ProjectToBrep(curves: IEnumerable[Curve],breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> Array[Curve]\n\n  ProjectToBrep(curves: IEnumerable[Curve],breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> (Array[Curve],Array[int],Array[int])\n\n  ProjectToBrep(curve: Curve,breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> (Array[Curve],Array[int])\n\n  ProjectToBrep(curve: Curve,brep: Brep,direction: Vector3d,tolerance: float) -> Array[Curve]\n\n  \n\n   Projects a Curve onto a Brep along a given direction.\n\n  \n\n   curve: Curve to project.\n\n   brep: Brep to project onto.\n\n   direction: Direction of projection.\n\n   tolerance: Tolerance to use for projection.\n\n   Returns: An array of projected curves or empty array if the projection set is empty.\n\n  ProjectToBrep(curve: Curve,breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> Array[Curve]\n  \"\"\"\n  pass\n @staticmethod\n def ProjectToMesh(*__args):\n  \"\"\"\n  ProjectToMesh(curves: IEnumerable[Curve],meshes: IEnumerable[Mesh],direction: Vector3d,tolerance: float) -> Array[Curve]\n\n  ProjectToMesh(curve: Curve,meshes: IEnumerable[Mesh],direction: Vector3d,tolerance: float) -> Array[Curve]\n\n  ProjectToMesh(curve: Curve,mesh: Mesh,direction: Vector3d,tolerance: float) -> Array[Curve]\n\n  \n\n   Projects a curve to a mesh using a direction and tolerance.\n\n  \n\n   curve: A curve.\n\n   mesh: A mesh.\n\n   direction: A direction vector.\n\n   tolerance: A tolerance value.\n\n   Returns: A curve array.\n  \"\"\"\n  pass\n @staticmethod\n def ProjectToPlane(curve,plane):\n  \"\"\"\n  ProjectToPlane(curve: Curve,plane: Plane) -> Curve\n\n  \n\n   Constructs a curve by projecting an existing curve to a plane.\n\n  \n\n   curve: A curve.\n\n   plane: A plane.\n\n   Returns: The projected curve on success; null on failure.\n  \"\"\"\n  pass\n def PullToBrepFace(self,*__args):\n  \"\"\"\n  PullToBrepFace(curve: Curve,face: BrepFace,tolerance: float) -> Array[Curve]\n\n  \n\n   Pull a curve to a BrepFace using closest point projection.\n\n  \n\n   curve: Curve to pull.\n\n   face: Brepface that pulls.\n\n   tolerance: Tolerance to use for pulling.\n\n   Returns: An array of pulled curves,or an empty array on failure.\n\n  PullToBrepFace(self: Curve,face: BrepFace,tolerance: float) -> Array[Curve]\n\n  \n\n   Pulls this curve to a brep face and returns the result of that operation.\n\n  \n\n   face: A brep face.\n\n   tolerance: A tolerance value.\n\n   Returns: An array containing the resulting curves after pulling. This array could be empty.\n  \"\"\"\n  pass\n def PullToMesh(self,mesh,tolerance):\n  \"\"\"\n  PullToMesh(self: Curve,mesh: Mesh,tolerance: float) -> PolylineCurve\n\n  \n\n   Makes a polyline approximation of the curve and gets the closest point on the mesh for each \n\n    point on the curve. \n\n     Then it \"connects the points\" so that you have a polyline on \n\n    the mesh.\n\n  \n\n  \n\n   mesh: Mesh to project onto.\n\n   tolerance: Input tolerance (RhinoDoc.ModelAbsoluteTolerance is a good default)\n\n   Returns: A polyline curve on success,null on failure.\n  \"\"\"\n  pass\n def Rebuild(self,pointCount,degree,preserveTangents):\n  \"\"\"\n  Rebuild(self: Curve,pointCount: int,degree: int,preserveTangents: bool) -> NurbsCurve\n\n  \n\n   Rebuild a curve with a specific point count.\n\n  \n\n   pointCount: Number of control points in the rebuild curve.\n\n   degree: Degree of curve. Valid values are between and including 1 and 11.\n\n   preserveTangents: If true,the end tangents of the input curve will be preserved.\n\n   Returns: A Nurbs curve on success or null on failure.\n  \"\"\"\n  pass\n def RemoveShortSegments(self,tolerance):\n  \"\"\"\n  RemoveShortSegments(self: Curve,tolerance: float) -> bool\n\n  \n\n   Looks for segments that are shorter than tolerance that can be removed. \n\n     Does not \n\n    change the domain,but it will change the relative parameterization.\n\n  \n\n  \n\n   tolerance: Tolerance which defines \"short\" segments.\n\n   Returns: true if removable short segments were found. \n\n     false if no removable short segments \n\n    were found.\n  \"\"\"\n  pass\n def Reverse(self):\n  \"\"\"\n  Reverse(self: Curve) -> bool\n\n  \n\n   Reverses the direction of the curve.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def SetEndPoint(self,point):\n  \"\"\"\n  SetEndPoint(self: Curve,point: Point3d) -> bool\n\n  \n\n   Forces the curve to end at a specified point. \n\n     Not all curve types support this \n\n    operation.\n\n  \n\n  \n\n   point: New end point of curve.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def SetStartPoint(self,point):\n  \"\"\"\n  SetStartPoint(self: Curve,point: Point3d) -> bool\n\n  \n\n   Forces the curve to start at a specified point. \n\n     Not all curve types support this \n\n    operation.\n\n  \n\n  \n\n   point: New start point of curve.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def Simplify(self,options,distanceTolerance,angleToleranceRadians):\n  \"\"\"\n  Simplify(self: Curve,options: CurveSimplifyOptions,distanceTolerance: float,angleToleranceRadians: float) -> Curve\n\n  \n\n   Returns a geometrically equivalent PolyCurve.\n\n     The PolyCurve has the following \n\n    properties\n\n     1. All the PolyCurve segments are LineCurve,PolylineCurve,ArcCurve,or \n\n    NurbsCurve.\n\n     \n\n     2. The Nurbs Curves segments do not have fully multiple \n\n    interior knots.\n\n     \n\n     3. Rational Nurbs curves do not have constant \n\n    weights.\n\n     \n\n     4. Any segment for which IsLinear() or IsArc() is true is a \n\n    Line,\n\n        Polyline segment,or an Arc.\n\n     \n\n     5. Adjacent \n\n    Colinear or Cocircular segments are combined.\n\n     \n\n     6. Segments that meet \n\n    with G1-continuity have there ends tuned up so\n\n        that they meet with G1-continuity \n\n    to within machine precision.\n\n  \n\n  \n\n   options: Simplification options.\n\n   distanceTolerance: A distance tolerance for the simplification.\n\n   angleToleranceRadians: An angle tolerance for the simplification.\n\n   Returns: New simplified curve on success,null on failure.\n  \"\"\"\n  pass\n def SimplifyEnd(self,end,options,distanceTolerance,angleToleranceRadians):\n  \"\"\"\n  SimplifyEnd(self: Curve,end: CurveEnd,options: CurveSimplifyOptions,distanceTolerance: float,angleToleranceRadians: float) -> Curve\n\n  \n\n   Same as SimplifyCurve,but simplifies only the last two segments at \"side\" end.\n\n  \n\n   end: If CurveEnd.Start the function simplifies the last two start \n\n     side segments,\n\n    otherwise if CurveEnd.End the last two end side segments are simplified.\n\n  \n\n   options: Simplification options.\n\n   distanceTolerance: A distance tolerance for the simplification.\n\n   angleToleranceRadians: An angle tolerance for the simplification.\n\n   Returns: New simplified curve on success,null on failure.\n  \"\"\"\n  pass\n def SpanDomain(self,spanIndex):\n  \"\"\"\n  SpanDomain(self: Curve,spanIndex: int) -> Interval\n\n  \n\n   Get the domain of the curve span with the given index. \n\n     Use the SpanCount property \n\n    to test how many spans there are.\n\n  \n\n  \n\n   spanIndex: Index of span.\n\n   Returns: Interval of the span with the given index.\n  \"\"\"\n  pass\n def Split(self,*__args):\n  \"\"\"\n  Split(self: Curve,cutter: Brep,tolerance: float) -> Array[Curve]\n\n  \n\n   Splits a curve into pieces using a polysurface.\n\n  \n\n   cutter: A cutting surface or polysurface.\n\n   tolerance: A tolerance for computing intersections.\n\n   Returns: An array of curves. This array can be empty.\n\n  Split(self: Curve,cutter: Surface,tolerance: float) -> Array[Curve]\n\n  \n\n   Splits a curve into pieces using a surface.\n\n  \n\n   cutter: A cutting surface or polysurface.\n\n   tolerance: A tolerance for computing intersections.\n\n   Returns: An array of curves. This array can be empty.\n\n  Split(self: Curve,t: float) -> Array[Curve]\n\n  \n\n   Splits (divides) the curve at the specified parameter. \n\n     The parameter must be in \n\n    the interior of the curve's domain.\n\n  \n\n  \n\n   t: Parameter to split the curve at in the interval returned by Domain().\n\n   Returns: Two curves on success,null on failure.\n\n  Split(self: Curve,t: IEnumerable[float]) -> Array[Curve]\n  \"\"\"\n  pass\n def TangentAt(self,t):\n  \"\"\"\n  TangentAt(self: Curve,t: float) -> Vector3d\n\n  \n\n   Evaluates the unit tangent vector at a curve parameter.\n\n  \n\n   t: Evaluation parameter.\n\n   Returns: Unit tangent vector of the curve at the parameter t.\n  \"\"\"\n  pass\n def ToNurbsCurve(self,subdomain=None):\n  \"\"\"\n  ToNurbsCurve(self: Curve) -> NurbsCurve\n\n  \n\n   Constructs a NURBS curve representation of this curve.\n\n   Returns: NURBS representation of the curve on success,null on failure.\n\n  ToNurbsCurve(self: Curve,subdomain: Interval) -> NurbsCurve\n\n  \n\n   Constructs a NURBS curve representation of this curve.\n\n  \n\n   subdomain: The NURBS representation for this portion of the curve is returned.\n\n   Returns: NURBS representation of the curve on success,null on failure.\n  \"\"\"\n  pass\n def ToPolyline(self,mainSegmentCount,subSegmentCount,maxAngleRadians,maxChordLengthRatio,maxAspectRatio,tolerance,minEdgeLength,maxEdgeLength,keepStartPoint,curveDomain=None):\n  \"\"\"\n  ToPolyline(self: Curve,mainSegmentCount: int,subSegmentCount: int,maxAngleRadians: float,maxChordLengthRatio: float,maxAspectRatio: float,tolerance: float,minEdgeLength: float,maxEdgeLength: float,keepStartPoint: bool,curveDomain: Interval) -> PolylineCurve\n\n  \n\n   Gets a polyline approximation of a curve.\n\n  \n\n   mainSegmentCount: If mainSegmentCount <= 0,then both subSegmentCount and mainSegmentCount are ignored. \n\n     \n\n    If mainSegmentCount > 0,then subSegmentCount must be >= 1. In this \n\n     case the \n\n    nurb will be broken into mainSegmentCount equally spaced \n\n     chords. If needed,each \n\n    of these chords can be split into as many \n\n     subSegmentCount sub-parts if the \n\n    subdivision is necessary for the \n\n     mesh to meet the other meshing constraints. In \n\n    particular,if \n\n     subSegmentCount=0,then the curve is broken into mainSegmentCount \n\n    \n\n     pieces and no further testing is performed.\n\n  \n\n   subSegmentCount: An amount of subsegments.\n\n   maxAngleRadians: ( 0 to pi ) Maximum angle (in radians) between unit tangents at \n\n     adjacent vertices.\n\n   maxChordLengthRatio: Maximum permitted value of \n\n     (distance chord midpoint to curve) / (length of chord).\n\n   maxAspectRatio: If maxAspectRatio < 1.0,the parameter is ignored. \n\n     If 1 <= maxAspectRatio < \n\n    sqrt(2),it is treated as if maxAspectRatio=sqrt(2). \n\n     This parameter controls the \n\n    maximum permitted value of \n\n     (length of longest chord) / (length of shortest chord).\n\n  \n\n   tolerance: If tolerance=0,the parameter is ignored. \n\n     This parameter controls the maximum \n\n    permitted value of the \n\n     distance from the curve to the polyline.\n\n  \n\n   minEdgeLength: The minimum permitted edge length.\n\n   maxEdgeLength: If maxEdgeLength=0,the parameter \n\n     is ignored. This parameter controls the \n\n    maximum permitted edge length.\n\n  \n\n   keepStartPoint: If true the starting point of the curve \n\n     is added to the polyline. If false the \n\n    starting point of the curve is \n\n     not added to the polyline.\n\n  \n\n   curveDomain: This subdomain of the NURBS curve is approximated.\n\n   Returns: PolylineCurve on success,null on error.\n\n  ToPolyline(self: Curve,mainSegmentCount: int,subSegmentCount: int,maxAngleRadians: float,maxChordLengthRatio: float,maxAspectRatio: float,tolerance: float,minEdgeLength: float,maxEdgeLength: float,keepStartPoint: bool) -> PolylineCurve\n\n  \n\n   Gets a polyline approximation of a curve.\n\n  \n\n   mainSegmentCount: If mainSegmentCount <= 0,then both subSegmentCount and mainSegmentCount are ignored. \n\n     \n\n    If mainSegmentCount > 0,then subSegmentCount must be >= 1. In this \n\n     case the \n\n    nurb will be broken into mainSegmentCount equally spaced \n\n     chords. If needed,each \n\n    of these chords can be split into as many \n\n     subSegmentCount sub-parts if the \n\n    subdivision is necessary for the \n\n     mesh to meet the other meshing constraints. In \n\n    particular,if \n\n     subSegmentCount=0,then the curve is broken into mainSegmentCount \n\n    \n\n     pieces and no further testing is performed.\n\n  \n\n   subSegmentCount: An amount of subsegments.\n\n   maxAngleRadians: ( 0 to pi ) Maximum angle (in radians) between unit tangents at \n\n     adjacent vertices.\n\n   maxChordLengthRatio: Maximum permitted value of \n\n     (distance chord midpoint to curve) / (length of chord).\n\n   maxAspectRatio: If maxAspectRatio < 1.0,the parameter is ignored. \n\n     If 1 <= maxAspectRatio < \n\n    sqrt(2),it is treated as if maxAspectRatio=sqrt(2). \n\n     This parameter controls the \n\n    maximum permitted value of \n\n     (length of longest chord) / (length of shortest chord).\n\n  \n\n   tolerance: If tolerance=0,the parameter is ignored. \n\n     This parameter controls the maximum \n\n    permitted value of the \n\n     distance from the curve to the polyline.\n\n  \n\n   minEdgeLength: The minimum permitted edge length.\n\n   maxEdgeLength: If maxEdgeLength=0,the parameter \n\n     is ignored. This parameter controls the \n\n    maximum permitted edge length.\n\n  \n\n   keepStartPoint: If true the starting point of the curve \n\n     is added to the polyline. If false the \n\n    starting point of the curve is \n\n     not added to the polyline.\n\n  \n\n   Returns: PolylineCurve on success,null on error.\n  \"\"\"\n  pass\n def Trim(self,*__args):\n  \"\"\"\n  Trim(self: Curve,side: CurveEnd,length: float) -> Curve\n\n  \n\n   Shortens a curve by a given length\n\n   Returns: Trimmed curve if successful,null on failure.\n\n  Trim(self: Curve,domain: Interval) -> Curve\n\n  \n\n   Removes portions of the curve outside the specified interval.\n\n  \n\n   domain: Trimming interval. Portions of the curve before curve(domain[0])\n\n     and after \n\n    curve(domain[1]) are removed.\n\n  \n\n   Returns: Trimmed curve if successful,null on failure.\n\n  Trim(self: Curve,t0: float,t1: float) -> Curve\n\n  \n\n   Removes portions of the curve outside the specified interval.\n\n  \n\n   t0: Start of the trimming interval. Portions of the curve before curve(t0) are removed.\n\n   t1: End of the trimming interval. Portions of the curve after curve(t1) are removed.\n\n   Returns: Trimmed portion of this curve is successfull,null on failure.\n  \"\"\"\n  pass\n def TryGetArc(self,*__args):\n  \"\"\"\n  TryGetArc(self: Curve,plane: Plane) -> (bool,Arc)\n\n  \n\n   Try to convert this curve into an Arc using RhinoMath.ZeroTolerance.\n\n  \n\n   plane: Plane in which the comparison is performed.\n\n   Returns: true if the curve could be converted into an arc within the given plane.\n\n  TryGetArc(self: Curve,plane: Plane,tolerance: float) -> (bool,Arc)\n\n  \n\n   Try to convert this curve into an Arc using a custom tolerance.\n\n  \n\n   plane: Plane in which the comparison is performed.\n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if the curve could be converted into an arc within the given plane.\n\n  TryGetArc(self: Curve) -> (bool,Arc)\n\n  \n\n   Try to convert this curve into an Arc using RhinoMath.ZeroTolerance.\n\n   Returns: true if the curve could be converted into an arc.\n\n  TryGetArc(self: Curve,tolerance: float) -> (bool,Arc)\n\n  \n\n   Try to convert this curve into an Arc using a custom tolerance.\n\n  \n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if the curve could be converted into an arc.\n  \"\"\"\n  pass\n def TryGetCircle(self,circle,tolerance=None):\n  \"\"\"\n  TryGetCircle(self: Curve,tolerance: float) -> (bool,Circle)\n\n  \n\n   Try to convert this curve into a Circle using a custom tolerance.\n\n  \n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if the curve could be converted into a Circle within tolerance.\n\n  TryGetCircle(self: Curve) -> (bool,Circle)\n\n  \n\n   Try to convert this curve into a circle using RhinoMath.ZeroTolerance.\n\n   Returns: true if the curve could be converted into a Circle.\n  \"\"\"\n  pass\n def TryGetEllipse(self,*__args):\n  \"\"\"\n  TryGetEllipse(self: Curve,plane: Plane) -> (bool,Ellipse)\n\n  \n\n   Try to convert this curve into an Ellipse within RhinoMath.ZeroTolerance.\n\n  \n\n   plane: Plane in which the comparison is performed.\n\n   Returns: true if the curve could be converted into an Ellipse within the given plane.\n\n  TryGetEllipse(self: Curve,plane: Plane,tolerance: float) -> (bool,Ellipse)\n\n  \n\n   Try to convert this curve into an Ellipse using a custom tolerance.\n\n  \n\n   plane: Plane in which the comparison is performed.\n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if the curve could be converted into an Ellipse within the given plane.\n\n  TryGetEllipse(self: Curve) -> (bool,Ellipse)\n\n  \n\n   Try to convert this curve into an Ellipse within RhinoMath.ZeroTolerance.\n\n   Returns: true if the curve could be converted into an Ellipse.\n\n  TryGetEllipse(self: Curve,tolerance: float) -> (bool,Ellipse)\n\n  \n\n   Try to convert this curve into an Ellipse using a custom tolerance.\n\n  \n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if the curve could be converted into an Ellipse.\n  \"\"\"\n  pass\n def TryGetPlane(self,plane,tolerance=None):\n  \"\"\"\n  TryGetPlane(self: Curve,tolerance: float) -> (bool,Plane)\n\n  \n\n   Test a curve for planarity and return the plane.\n\n  \n\n   tolerance: Tolerance to use when checking.\n\n   Returns: true if there is a plane such that the maximum distance from the curve to the plane is <= \n\n    tolerance.\n\n  \n\n  TryGetPlane(self: Curve) -> (bool,Plane)\n\n  \n\n   Test a curve for planarity and return the plane.\n\n   Returns: true if there is a plane such that the maximum distance from the curve to the plane is <= \n\n    RhinoMath.ZeroTolerance.\n  \"\"\"\n  pass\n def TryGetPolyline(self,polyline,parameters=None):\n  \"\"\"\n  TryGetPolyline(self: Curve) -> (bool,Polyline,Array[float])\n\n  \n\n   Several types of Curve can have the form of a polyline \n\n     including a degree 1 \n\n    NurbsCurve,a PolylineCurve,\n\n     and a PolyCurve all of whose segments are some form \n\n    of \n\n     polyline. IsPolyline tests a curve to see if it can be \n\n     \n\n    represented as a polyline.\n\n  \n\n   Returns: true if this curve can be represented as a polyline; otherwise,false.\n\n  TryGetPolyline(self: Curve) -> (bool,Polyline)\n\n  \n\n   Several types of Curve can have the form of a polyline \n\n     including a degree 1 \n\n    NurbsCurve,a PolylineCurve,\n\n     and a PolyCurve all of whose segments are some form \n\n    of \n\n     polyline. IsPolyline tests a curve to see if it can be \n\n     \n\n    represented as a polyline.\n\n  \n\n   Returns: true if this curve can be represented as a polyline; otherwise,false.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n @staticmethod\n def __new__(self,*args): #cannot find CLR constructor\n  \"\"\"\n  __new__(cls: type)\n\n  __new__(cls: type,info: SerializationInfo,context: StreamingContext)\n  \"\"\"\n  pass\n def __reduce_ex__(self,*args):\n  pass\n Degree=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the maximum algebraic degree of any span\n\n   or a good estimate if curve spans are not algebraic.\n\n\n\nGet: Degree(self: Curve) -> int\n\n\n\n\"\"\"\n\n Dimension=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the dimension of the object.\n\n   The dimension is typically three. For parameter space trimming\n\n   curves the dimension is two. In rare cases the dimension can\n\n   be one or greater than three.\n\n\n\nGet: Dimension(self: Curve) -> int\n\n\n\n\"\"\"\n\n Domain=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets or sets the domain of the curve.\n\n\n\nGet: Domain(self: Curve) -> Interval\n\n\n\nSet: Domain(self: Curve)=value\n\n\"\"\"\n\n IsClosed=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets a value indicating whether or not this curve is a closed curve.\n\n\n\nGet: IsClosed(self: Curve) -> bool\n\n\n\n\"\"\"\n\n IsPeriodic=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets a value indicating whether or not this curve is considered to be Periodic.\n\n\n\nGet: IsPeriodic(self: Curve) -> bool\n\n\n\n\"\"\"\n\n PointAtEnd=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Evaluates point at the end of the curve.\n\n\n\nGet: PointAtEnd(self: Curve) -> Point3d\n\n\n\n\"\"\"\n\n PointAtStart=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Evaluates point at the start of the curve.\n\n\n\nGet: PointAtStart(self: Curve) -> Point3d\n\n\n\n\"\"\"\n\n SpanCount=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the number of non-empty smooth (c-infinity) spans in the curve.\n\n\n\nGet: SpanCount(self: Curve) -> int\n\n\n\n\"\"\"\n\n TangentAtEnd=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Evaluate unit tangent vector at the end of the curve.\n\n\n\nGet: TangentAtEnd(self: Curve) -> Vector3d\n\n\n\n\"\"\"\n\n TangentAtStart=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Evaluates the unit tangent vector at the start of the curve.\n\n\n\nGet: TangentAtStart(self: Curve) -> Vector3d\n\n\n\n\"\"\"\n\n\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "classes", "point", "brep", "line", "dimension", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "0000onoff_Projekt-HS24_eb1803e251.json", "repo": "0000onoff/Projekt-HS24"}
{"instruction": "Returns the type of conic section based on the curve's shape.", "code": "from . import Util\ntry:\n    from itertools import izip as zip # python 2\nexcept ImportError:\n    pass # python 3\n\n\ndef GetConicSectionType(thisCurve, multiple=False):\n    \"\"\"\n    Returns the type of conic section based on the curve's shape.\n    \"\"\"\n    url = \"rhino/geometry/curve/getconicsectiontype-curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve]\n    if multiple: args = [[item] for item in thisCurve]\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CreateInterpolatedCurve(points, degree, multiple=False):\n    \"\"\"\n    Interpolates a sequence of points. Used by InterpCurve Command\n    This routine works best when degree=3.\n\n    Args:\n        degree (int): The degree of the curve >=1.  Degree must be odd.\n        points (IEnumerable<Point3d>): Points to interpolate (Count must be >= 2)\n\n    Returns:\n        Curve: interpolated curve on success. None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createinterpolatedcurve-point3darray_int\"\n    if multiple: url += \"?multiple=true\"\n    args = [points, degree]\n    if multiple: args = list(zip(points, degree))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateInterpolatedCurve1(points, degree, knots, multiple=False):\n    \"\"\"\n    Interpolates a sequence of points. Used by InterpCurve Command\n    This routine works best when degree=3.\n\n    Args:\n        degree (int): The degree of the curve >=1.  Degree must be odd.\n        points (IEnumerable<Point3d>): Points to interpolate. For periodic curves if the final point is a\n            duplicate of the initial point it is  ignored. (Count must be >=2)\n        knots (CurveKnotStyle): Knot-style to use  and specifies if the curve should be periodic.\n\n    Returns:\n        Curve: interpolated curve on success. None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createinterpolatedcurve-point3darray_int_curveknotstyle\"\n    if multiple: url += \"?multiple=true\"\n    args = [points, degree, knots]\n    if multiple: args = list(zip(points, degree, knots))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateInterpolatedCurve2(points, degree, knots, startTangent, endTangent, multiple=False):\n    \"\"\"\n    Interpolates a sequence of points. Used by InterpCurve Command\n    This routine works best when degree=3.\n\n    Args:\n        degree (int): The degree of the curve >=1.  Degree must be odd.\n        points (IEnumerable<Point3d>): Points to interpolate. For periodic curves if the final point is a\n            duplicate of the initial point it is  ignored. (Count must be >=2)\n        knots (CurveKnotStyle): Knot-style to use  and specifies if the curve should be periodic.\n        startTangent (Vector3d): A starting tangent.\n        endTangent (Vector3d): An ending tangent.\n\n    Returns:\n        Curve: interpolated curve on success. None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createinterpolatedcurve-point3darray_int_curveknotstyle_vector3d_vector3d\"\n    if multiple: url += \"?multiple=true\"\n    args = [points, degree, knots, startTangent, endTangent]\n    if multiple: args = list(zip(points, degree, knots, startTangent, endTangent))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateSoftEditCurve(curve, t, delta, length, fixEnds, multiple=False):\n    \"\"\"\n    Creates a soft edited curve from an existing curve using a smooth field of influence.\n\n    Args:\n        curve (Curve): The curve to soft edit.\n        t (double): A parameter on the curve to move from. This location on the curve is moved, and the move\n            is smoothly tapered off with increasing distance along the curve from this parameter.\n        delta (Vector3d): The direction and magnitude, or maximum distance, of the move.\n        length (double): The distance along the curve from the editing point over which the strength\n            of the editing falls off smoothly.\n\n    Returns:\n        Curve: The soft edited curve if successful. None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createsofteditcurve-curve_double_vector3d_double_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, t, delta, length, fixEnds]\n    if multiple: args = list(zip(curve, t, delta, length, fixEnds))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateFilletCornersCurve(curve, radius, tolerance, angleTolerance, multiple=False):\n    \"\"\"\n    Rounds the corners of a kinked curve with arcs of a single, specified radius.\n\n    Args:\n        curve (Curve): The curve to fillet.\n        radius (double): The fillet radius.\n        tolerance (double): The tolerance. When in doubt, use the document's model space absolute tolerance.\n        angleTolerance (double): The angle tolerance in radians. When in doubt, use the document's model space angle tolerance.\n\n    Returns:\n        Curve: The filleted curve if successful. None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createfilletcornerscurve-curve_double_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, radius, tolerance, angleTolerance]\n    if multiple: args = list(zip(curve, radius, tolerance, angleTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateArcBlend(startPt, startDir, endPt, endDir, controlPointLengthRatio, multiple=False):\n    \"\"\"\n    Creates a polycurve consisting of two tangent arc segments that connect two points and two directions.\n\n    Args:\n        startPt (Point3d): Start of the arc blend curve.\n        startDir (Vector3d): Start direction of the arc blend curve.\n        endPt (Point3d): End of the arc blend curve.\n        endDir (Vector3d): End direction of the arc blend curve.\n        controlPointLengthRatio (double): The ratio of the control polygon lengths of the two arcs. Note, a value of 1.0\n            means the control polygon lengths for both arcs will be the same.\n\n    Returns:\n        Curve: The arc blend curve, or None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/createarcblend-point3d_vector3d_point3d_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [startPt, startDir, endPt, endDir, controlPointLengthRatio]\n    if multiple: args = list(zip(startPt, startDir, endPt, endDir, controlPointLengthRatio))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateMeanCurve(curveA, curveB, angleToleranceRadians, multiple=False):\n    \"\"\"\n    Constructs a mean, or average, curve from two curves.\n\n    Args:\n        curveA (Curve): A first curve.\n        curveB (Curve): A second curve.\n        angleToleranceRadians (double): The angle tolerance, in radians, used to match kinks between curves.\n            If you are unsure how to set this parameter, then either use the\n            document's angle tolerance RhinoDoc.AngleToleranceRadians,\n            or the default value (RhinoMath.UnsetValue)\n\n    Returns:\n        Curve: The average curve, or None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/createmeancurve-curve_curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, angleToleranceRadians]\n    if multiple: args = list(zip(curveA, curveB, angleToleranceRadians))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateMeanCurve1(curveA, curveB, multiple=False):\n    \"\"\"\n    Constructs a mean, or average, curve from two curves.\n\n    Args:\n        curveA (Curve): A first curve.\n        curveB (Curve): A second curve.\n\n    Returns:\n        Curve: The average curve, or None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/createmeancurve-curve_curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB]\n    if multiple: args = list(zip(curveA, curveB))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBlendCurve(curveA, curveB, continuity, multiple=False):\n    \"\"\"\n    Create a Blend curve between two existing curves.\n\n    Args:\n        curveA (Curve): Curve to blend from (blending will occur at curve end point).\n        curveB (Curve): Curve to blend to (blending will occur at curve start point).\n        continuity (BlendContinuity): Continuity of blend.\n\n    Returns:\n        Curve: A curve representing the blend between A and B or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createblendcurve-curve_curve_blendcontinuity\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, continuity]\n    if multiple: args = list(zip(curveA, curveB, continuity))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBlendCurve1(curveA, curveB, continuity, bulgeA, bulgeB, multiple=False):\n    \"\"\"\n    Create a Blend curve between two existing curves.\n\n    Args:\n        curveA (Curve): Curve to blend from (blending will occur at curve end point).\n        curveB (Curve): Curve to blend to (blending will occur at curve start point).\n        continuity (BlendContinuity): Continuity of blend.\n        bulgeA (double): Bulge factor at curveA end of blend. Values near 1.0 work best.\n        bulgeB (double): Bulge factor at curveB end of blend. Values near 1.0 work best.\n\n    Returns:\n        Curve: A curve representing the blend between A and B or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createblendcurve-curve_curve_blendcontinuity_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, continuity, bulgeA, bulgeB]\n    if multiple: args = list(zip(curveA, curveB, continuity, bulgeA, bulgeB))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBlendCurve2(curve0, t0, reverse0, continuity0, curve1, t1, reverse1, continuity1, multiple=False):\n    \"\"\"\n    Makes a curve blend between 2 curves at the parameters specified\n    with the directions and continuities specified\n\n    Args:\n        curve0 (Curve): First curve to blend from\n        t0 (double): Parameter on first curve for blend endpoint\n        reverse0 (bool): If false, the blend will go in the natural direction of the curve.\n            If true, the blend will go in the opposite direction to the curve\n        continuity0 (BlendContinuity): Continuity for the blend at the start\n        curve1 (Curve): Second curve to blend from\n        t1 (double): Parameter on second curve for blend endpoint\n        reverse1 (bool): If false, the blend will go in the natural direction of the curve.\n            If true, the blend will go in the opposite direction to the curve\n        continuity1 (BlendContinuity): Continuity for the blend at the end\n\n    Returns:\n        Curve: The blend curve on success. None on failure\n    \"\"\"\n    url = \"rhino/geometry/curve/createblendcurve-curve_double_bool_blendcontinuity_curve_double_bool_blendcontinuity\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, t0, reverse0, continuity0, curve1, t1, reverse1, continuity1]\n    if multiple: args = list(zip(curve0, t0, reverse0, continuity0, curve1, t1, reverse1, continuity1))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateTweenCurves(curve0, curve1, numCurves, multiple=False):\n    \"\"\"\n    Creates curves between two open or closed input curves. Uses the control points of the curves for finding tween curves.\n    That means the first control point of first curve is matched to first control point of the second curve and so on.\n    There is no matching of curves direction. Caller must match input curves direction before calling the function.\n\n    Args:\n        curve0 (Curve): The first, or starting, curve.\n        curve1 (Curve): The second, or ending, curve.\n        numCurves (int): Number of tween curves to create.\n\n    Returns:\n        Curve[]: An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtweencurves-curve_curve_int\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, numCurves]\n    if multiple: args = list(zip(curve0, curve1, numCurves))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateTweenCurves1(curve0, curve1, numCurves, tolerance, multiple=False):\n    \"\"\"\n    Creates curves between two open or closed input curves. Uses the control points of the curves for finding tween curves.\n    That means the first control point of first curve is matched to first control point of the second curve and so on.\n    There is no matching of curves direction. Caller must match input curves direction before calling the function.\n\n    Args:\n        curve0 (Curve): The first, or starting, curve.\n        curve1 (Curve): The second, or ending, curve.\n        numCurves (int): Number of tween curves to create.\n\n    Returns:\n        Curve[]: An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtweencurves-curve_curve_int_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, numCurves, tolerance]\n    if multiple: args = list(zip(curve0, curve1, numCurves, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateTweenCurvesWithMatching(curve0, curve1, numCurves, multiple=False):\n    \"\"\"\n    Creates curves between two open or closed input curves. Make the structure of input curves compatible if needed.\n    Refits the input curves to have the same structure. The resulting curves are usually more complex than input unless\n    input curves are compatible and no refit is needed. There is no matching of curves direction.\n    Caller must match input curves direction before calling the function.\n\n    Args:\n        curve0 (Curve): The first, or starting, curve.\n        curve1 (Curve): The second, or ending, curve.\n        numCurves (int): Number of tween curves to create.\n\n    Returns:\n        Curve[]: An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtweencurveswithmatching-curve_curve_int\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, numCurves]\n    if multiple: args = list(zip(curve0, curve1, numCurves))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateTweenCurvesWithMatching1(curve0, curve1, numCurves, tolerance, multiple=False):\n    \"\"\"\n    Creates curves between two open or closed input curves. Make the structure of input curves compatible if needed.\n    Refits the input curves to have the same structure. The resulting curves are usually more complex than input unless\n    input curves are compatible and no refit is needed. There is no matching of curves direction.\n    Caller must match input curves direction before calling the function.\n\n    Args:\n        curve0 (Curve): The first, or starting, curve.\n        curve1 (Curve): The second, or ending, curve.\n        numCurves (int): Number of tween curves to create.\n\n    Returns:\n        Curve[]: An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtweencurveswithmatching-curve_curve_int_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, numCurves, tolerance]\n    if multiple: args = list(zip(curve0, curve1, numCurves, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateTweenCurvesWithSampling(curve0, curve1, numCurves, numSamples, multiple=False):\n    \"\"\"\n    Creates curves between two open or closed input curves. Use sample points method to make curves compatible.\n    This is how the algorithm works: Divides the two curves into an equal number of points, finds the midpoint between the\n    corresponding points on the curves and interpolates the tween curve through those points. There is no matching of curves\n    direction. Caller must match input curves direction before calling the function.\n\n    Args:\n        curve0 (Curve): The first, or starting, curve.\n        curve1 (Curve): The second, or ending, curve.\n        numCurves (int): Number of tween curves to create.\n        numSamples (int): Number of sample points along input curves.\n\n    Returns:\n        Curve[]: >An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtweencurveswithsampling-curve_curve_int_int\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, numCurves, numSamples]\n    if multiple: args = list(zip(curve0, curve1, numCurves, numSamples))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateTweenCurvesWithSampling1(curve0, curve1, numCurves, numSamples, tolerance, multiple=False):\n    \"\"\"\n    Creates curves between two open or closed input curves. Use sample points method to make curves compatible.\n    This is how the algorithm works: Divides the two curves into an equal number of points, finds the midpoint between the\n    corresponding points on the curves and interpolates the tween curve through those points. There is no matching of curves\n    direction. Caller must match input curves direction before calling the function.\n\n    Args:\n        curve0 (Curve): The first, or starting, curve.\n        curve1 (Curve): The second, or ending, curve.\n        numCurves (int): Number of tween curves to create.\n        numSamples (int): Number of sample points along input curves.\n\n    Returns:\n        Curve[]: >An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtweencurveswithsampling-curve_curve_int_int_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, numCurves, numSamples, tolerance]\n    if multiple: args = list(zip(curve0, curve1, numCurves, numSamples, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef JoinCurves(inputCurves, multiple=False):\n    \"\"\"\n    Joins a collection of curve segments together.\n\n    Args:\n        inputCurves (IEnumerable<Curve>): Curve segments to join.\n\n    Returns:\n        Curve[]: An array of curves which contains.\n    \"\"\"\n    url = \"rhino/geometry/curve/joincurves-curvearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [inputCurves]\n    if multiple: args = [[item] for item in inputCurves]\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef JoinCurves1(inputCurves, joinTolerance, multiple=False):\n    \"\"\"\n    Joins a collection of curve segments together.\n\n    Args:\n        inputCurves (IEnumerable<Curve>): An array, a list or any enumerable set of curve segments to join.\n        joinTolerance (double): Joining tolerance,\n            i.e. the distance between segment end-points that is allowed.\n\n    Returns:\n        Curve[]: An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/joincurves-curvearray_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [inputCurves, joinTolerance]\n    if multiple: args = list(zip(inputCurves, joinTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef JoinCurves2(inputCurves, joinTolerance, preserveDirection, multiple=False):\n    \"\"\"\n    Joins a collection of curve segments together.\n\n    Args:\n        inputCurves (IEnumerable<Curve>): An array, a list or any enumerable set of curve segments to join.\n        joinTolerance (double): Joining tolerance,\n            i.e. the distance between segment end-points that is allowed.\n        preserveDirection (bool): If true, curve endpoints will be compared to curve start points.If false, all start and endpoints will be compared and copies of input curves may be reversed in output.\n\n    Returns:\n        Curve[]: An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/joincurves-curvearray_double_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [inputCurves, joinTolerance, preserveDirection]\n    if multiple: args = list(zip(inputCurves, joinTolerance, preserveDirection))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef MakeEndsMeet(curveA, adjustStartCurveA, curveB, adjustStartCurveB, multiple=False):\n    \"\"\"\n    Makes adjustments to the ends of one or both input curves so that they meet at a point.\n\n    Args:\n        curveA (Curve): 1st curve to adjust.\n        adjustStartCurveA (bool): Which end of the 1st curve to adjust: True is start, False is end.\n        curveB (Curve): 2nd curve to adjust.\n        adjustStartCurveB (bool): which end of the 2nd curve to adjust true==start, false==end.\n\n    Returns:\n        bool: True on success.\n    \"\"\"\n    url = \"rhino/geometry/curve/makeendsmeet-curve_bool_curve_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, adjustStartCurveA, curveB, adjustStartCurveB]\n    if multiple: args = list(zip(curveA, adjustStartCurveA, curveB, adjustStartCurveB))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CreateFillet(curve0, curve1, radius, t0Base, t1Base, multiple=False):\n    \"\"\"\n    Computes the fillet arc for a curve filleting operation.\n\n    Args:\n        curve0 (Curve): First curve to fillet.\n        curve1 (Curve): Second curve to fillet.\n        radius (double): Fillet radius.\n        t0Base (double): Parameter on curve0 where the fillet ought to start (approximately).\n        t1Base (double): Parameter on curve1 where the fillet ought to end (approximately).\n\n    Returns:\n        Arc: The fillet arc on success, or Arc.Unset on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createfillet-curve_curve_double_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, radius, t0Base, t1Base]\n    if multiple: args = list(zip(curve0, curve1, radius, t0Base, t1Base))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CreateFilletCurves(curve0, point0, curve1, point1, radius, join, trim, arcExtension, tolerance, angleTolerance, multiple=False):\n    \"\"\"\n    Creates a tangent arc between two curves and trims or extends the curves to the arc.\n\n    Args:\n        curve0 (Curve): The first curve to fillet.\n        point0 (Point3d): A point on the first curve that is near the end where the fillet will\n            be created.\n        curve1 (Curve): The second curve to fillet.\n        point1 (Point3d): A point on the second curve that is near the end where the fillet will\n            be created.\n        radius (double): The radius of the fillet.\n        join (bool): Join the output curves.\n        trim (bool): Trim copies of the input curves to the output fillet curve.\n        arcExtension (bool): Applies when arcs are filleted but need to be extended to meet the\n            fillet curve or chamfer line. If true, then the arc is extended\n            maintaining its validity. If false, then the arc is extended with a\n            line segment, which is joined to the arc converting it to a polycurve.\n        tolerance (double): The tolerance, generally the document's absolute tolerance.\n\n    Returns:\n        Curve[]: The results of the fillet operation. The number of output curves depends\n        on the input curves and the values of the parameters that were used\n        during the fillet operation. In most cases, the output array will contain\n        either one or three curves, although two curves can be returned if the\n        radius is zero and join = false.\n        For example, if both join and trim = true, then the output curve\n        will be a polycurve containing the fillet curve joined with trimmed copies\n        of the input curves. If join = False and trim = true, then three curves,\n        the fillet curve and trimmed copies of the input curves, will be returned.\n        If both join and trim = false, then just the fillet curve is returned.\n    \"\"\"\n    url = \"rhino/geometry/curve/createfilletcurves-curve_point3d_curve_point3d_double_bool_bool_bool_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, point0, curve1, point1, radius, join, trim, arcExtension, tolerance, angleTolerance]\n    if multiple: args = list(zip(curve0, point0, curve1, point1, radius, join, trim, arcExtension, tolerance, angleTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanUnion(curves, multiple=False):\n    \"\"\"\n    Calculates the boolean union of two or more closed, planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curves (IEnumerable<Curve>): The co-planar curves to union.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no union could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleanunion-curvearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves]\n    if multiple: args = [[item] for item in curves]\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanUnion1(curves, tolerance, multiple=False):\n    \"\"\"\n    Calculates the boolean union of two or more closed, planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curves (IEnumerable<Curve>): The co-planar curves to union.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no union could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleanunion-curvearray_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves, tolerance]\n    if multiple: args = list(zip(curves, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanIntersection(curveA, curveB, multiple=False):\n    \"\"\"\n    Calculates the boolean intersection of two closed, planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curveA (Curve): The first closed, planar curve.\n        curveB (Curve): The second closed, planar curve.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no intersection could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleanintersection-curve_curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB]\n    if multiple: args = list(zip(curveA, curveB))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanIntersection1(curveA, curveB, tolerance, multiple=False):\n    \"\"\"\n    Calculates the boolean intersection of two closed, planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curveA (Curve): The first closed, planar curve.\n        curveB (Curve): The second closed, planar curve.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no intersection could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleanintersection-curve_curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, tolerance]\n    if multiple: args = list(zip(curveA, curveB, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanDifference(curveA, curveB, multiple=False):\n    \"\"\"\n    Calculates the boolean difference between two closed, planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curveA (Curve): The first closed, planar curve.\n        curveB (Curve): The second closed, planar curve.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no difference could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleandifference-curve_curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB]\n    if multiple: args = list(zip(curveA, curveB))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanDifference1(curveA, curveB, tolerance, multiple=False):\n    \"\"\"\n    Calculates the boolean difference between two closed, planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curveA (Curve): The first closed, planar curve.\n        curveB (Curve): The second closed, planar curve.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no difference could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleandifference-curve_curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, tolerance]\n    if multiple: args = list(zip(curveA, curveB, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanDifference2(curveA, subtractors, multiple=False):\n    \"\"\"\n    Calculates the boolean difference between a closed planar curve, and a list of closed planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curveA (Curve): The first closed, planar curve.\n        subtractors (IEnumerable<Curve>): curves to subtract from the first closed curve.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no difference could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleandifference-curve_curvearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, subtractors]\n    if multiple: args = list(zip(curveA, subtractors))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanDifference3(curveA, subtractors, tolerance, multiple=False):\n    \"\"\"\n    Calculates the boolean difference between a closed planar curve, and a list of closed planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curveA (Curve): The first closed, planar curve.\n        subtractors (IEnumerable<Curve>): curves to subtract from the first closed curve.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no difference could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleandifference-curve_curvearray_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, subtractors, tolerance]\n    if multiple: args = list(zip(curveA, subtractors, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanRegions(curves, plane, points, combineRegions, tolerance, multiple=False):\n    \"\"\"\n    Curve Boolean method, which trims and splits curves based on their overlapping regions.\n\n    Args:\n        curves (IEnumerable<Curve>): The input curves.\n        plane (Plane): Regions will be found in the projection of the curves to this plane.\n        points (IEnumerable<Point3d>): These points will be projected to plane. All regions that contain at least one of these points will be found.\n        combineRegions (bool): If true, then adjacent regions will be combined.\n        tolerance (double): Function tolerance. When in doubt, use the document's model absolute tolerance.\n\n    Returns:\n        CurveBooleanRegions: The curve Boolean regions if successful, None of no successful.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleanregions-curvearray_plane_point3darray_bool_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves, plane, points, combineRegions, tolerance]\n    if multiple: args = list(zip(curves, plane, points, combineRegions, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CreateBooleanRegions1(curves, plane, combineRegions, tolerance, multiple=False):\n    \"\"\"\n    Calculates curve Boolean regions, which trims and splits curves based on their overlapping regions.\n\n    Args:\n        curves (IEnumerable<Curve>): The input curves.\n        plane (Plane): Regions will be found in the projection of the curves to this plane.\n        combineRegions (bool): If true, then adjacent regions will be combined.\n        tolerance (double): Function tolerance. When in doubt, use the document's model absolute tolerance.\n\n    Returns:\n        CurveBooleanRegions: The curve Boolean regions if successful, None of no successful.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleanregions-curvearray_plane_bool_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves, plane, combineRegions, tolerance]\n    if multiple: args = list(zip(curves, plane, combineRegions, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CreateTextOutlines(text, font, textHeight, textStyle, closeLoops, plane, smallCapsScale, tolerance, multiple=False):\n    \"\"\"\n    Creates outline curves created from a text string. The functionality is similar to what you find in Rhino's TextObject command or TextEntity.Explode() in RhinoCommon.\n\n    Args:\n        text (string): The text from which to create outline curves.\n        font (string): The text font.\n        textHeight (double): The text height.\n        textStyle (int): The font style. The font style can be any number of the following: 0 - Normal, 1 - Bold, 2 - Italic\n        closeLoops (bool): Set this value to True when dealing with normal fonts and when you expect closed loops. You may want to set this to False when specifying a single-stroke font where you don't want closed loops.\n        plane (Plane): The plane on which the outline curves will lie.\n        smallCapsScale (double): Displays lower-case letters as small caps. Set the relative text size to a percentage of the normal text.\n        tolerance (double): The tolerance for the operation.\n\n    Returns:\n        Curve[]: An array containing one or more curves if successful.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtextoutlines-string_string_double_int_bool_plane_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [text, font, textHeight, textStyle, closeLoops, plane, smallCapsScale, tolerance]\n    if multiple: args = list(zip(text, font, textHeight, textStyle, closeLoops, plane, smallCapsScale, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateCurve2View(curveA, curveB, vectorA, vectorB, tolerance, angleTolerance, multiple=False):\n    \"\"\"\n    Creates a third curve from two curves that are planar in different construction planes.\n    The new curve looks the same as each of the original curves when viewed in each plane.\n\n    Args:\n        curveA (Curve): The first curve.\n        curveB (Curve): The second curve.\n        vectorA (Vector3d): A vector defining the normal direction of the plane which the first curve is drawn upon.\n        vectorB (Vector3d): A vector defining the normal direction of the plane which the second curve is drawn upon.\n        tolerance (double): The tolerance for the operation.\n        angleTolerance (double): The angle tolerance for the operation.\n\n    Returns:\n        Curve[]: An array containing one or more curves if successful.\n    \"\"\"\n    url = \"rhino/geometry/curve/createcurve2view-curve_curve_vector3d_vector3d_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, vectorA, vectorB, tolerance, angleTolerance]\n    if multiple: args = list(zip(curveA, curveB, vectorA, vectorB, tolerance, angleTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef DoDirectionsMatch(curveA, curveB, multiple=False):\n    \"\"\"\n    Determines whether two curves travel more or less in the same direction.\n\n    Args:\n        curveA (Curve): First curve to test.\n        curveB (Curve): Second curve to test.\n\n    Returns:\n        bool: True if both curves more or less point in the same direction,\n        False if they point in the opposite directions.\n    \"\"\"\n    url = \"rhino/geometry/curve/dodirectionsmatch-curve_curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB]\n    if multiple: args = list(zip(curveA, curveB))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ProjectToMesh(curve, mesh, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a curve to a mesh using a direction and tolerance.\n\n    Args:\n        curve (Curve): A curve.\n        mesh (Mesh): A mesh.\n        direction (Vector3d): A direction vector.\n        tolerance (double): A tolerance value.\n\n    Returns:\n        Curve[]: A curve array.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttomesh-curve_mesh_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, mesh, direction, tolerance]\n    if multiple: args = list(zip(curve, mesh, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ProjectToMesh1(curve, meshes, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a curve to a set of meshes using a direction and tolerance.\n\n    Args:\n        curve (Curve): A curve.\n        meshes (IEnumerable<Mesh>): A list, an array or any enumerable of meshes.\n        direction (Vector3d): A direction vector.\n        tolerance (double): A tolerance value.\n\n    Returns:\n        Curve[]: A curve array.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttomesh-curve_mesharray_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, meshes, direction, tolerance]\n    if multiple: args = list(zip(curve, meshes, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ProjectToMesh2(curves, meshes, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a curve to a set of meshes using a direction and tolerance.\n\n    Args:\n        curves (IEnumerable<Curve>): A list, an array or any enumerable of curves.\n        meshes (IEnumerable<Mesh>): A list, an array or any enumerable of meshes.\n        direction (Vector3d): A direction vector.\n        tolerance (double): A tolerance value.\n\n    Returns:\n        Curve[]: A curve array.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttomesh-curvearray_mesharray_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves, meshes, direction, tolerance]\n    if multiple: args = list(zip(curves, meshes, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ProjectToBrep(curve, brep, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a Curve onto a Brep along a given direction.\n\n    Args:\n        curve (Curve): Curve to project.\n        brep (Brep): Brep to project onto.\n        direction (Vector3d): Direction of projection.\n        tolerance (double): Tolerance to use for projection.\n\n    Returns:\n        Curve[]: An array of projected curves or empty array if the projection set is empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttobrep-curve_brep_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, brep, direction, tolerance]\n    if multiple: args = list(zip(curve, brep, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ProjectToBrep1(curve, breps, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a Curve onto a collection of Breps along a given direction.\n\n    Args:\n        curve (Curve): Curve to project.\n        breps (IEnumerable<Brep>): Breps to project onto.\n        direction (Vector3d): Direction of projection.\n        tolerance (double): Tolerance to use for projection.\n\n    Returns:\n        Curve[]: An array of projected curves or empty array if the projection set is empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttobrep-curve_breparray_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, breps, direction, tolerance]\n    if multiple: args = list(zip(curve, breps, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ProjectToBrep2(curve, breps, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a Curve onto a collection of Breps along a given direction.\n\n    Args:\n        curve (Curve): Curve to project.\n        breps (IEnumerable<Brep>): Breps to project onto.\n        direction (Vector3d): Direction of projection.\n        tolerance (double): Tolerance to use for projection.\n\n    Returns:\n        Curve[]: An array of projected curves or None if the projection set is empty.\n        brepIndices (int[]): (out) Integers that identify for each resulting curve which Brep it was projected onto.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttobrep-curve_breparray_vector3d_double_intarray\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, breps, direction, tolerance]\n    if multiple: args = list(zip(curve, breps, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ProjectToBrep3(curves, breps, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a collection of Curves onto a collection of Breps along a given direction.\n\n    Args:\n        curves (IEnumerable<Curve>): Curves to project.\n        breps (IEnumerable<Brep>): Breps to project onto.\n        direction (Vector3d): Direction of projection.\n        tolerance (double): Tolerance to use for projection.\n\n    Returns:\n        Curve[]: An array of projected curves or empty array if the projection set is empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttobrep-curvearray_breparray_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves, breps, direction, tolerance]\n    if multiple: args = list(zip(curves, breps, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ProjectToBrep4(curves, breps, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a collection of Curves onto a collection of Breps along a given direction.\n\n    Args:\n        curves (IEnumerable<Curve>): Curves to project.\n        breps (IEnumerable<Brep>): Breps to project onto.\n        direction (Vector3d): Direction of projection.\n        tolerance (double): Tolerance to use for projection.\n\n    Returns:\n        Curve[]: An array of projected curves. Array is empty if the projection set is empty.\n        curveIndices (int[]): Index of which curve in the input list was the source for a curve in the return array.\n        brepIndices (int[]): Index of which brep was used to generate a curve in the return array.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttobrep-curvearray_breparray_vector3d_double_intarray_intarray\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves, breps, direction, tolerance]\n    if multiple: args = list(zip(curves, breps, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ProjectToPlane(curve, plane, multiple=False):\n    \"\"\"\n    Constructs a curve by projecting an existing curve to a plane.\n\n    Args:\n        curve (Curve): A curve.\n        plane (Plane): A plane.\n\n    Returns:\n        Curve: The projected curve on success; None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttoplane-curve_plane\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, plane]\n    if multiple: args = list(zip(curve, plane))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef PullToBrepFace(curve, face, tolerance, multiple=False):\n    \"\"\"\n    Pull a curve to a BrepFace using closest point projection.\n\n    Args:\n        curve (Curve): Curve to pull.\n        face (BrepFace): Brep face that pulls.\n        tolerance (double): Tolerance to use for pulling.\n\n    Returns:\n        Curve[]: An array of pulled curves, or an empty array on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/pulltobrepface-curve_brepface_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, face, tolerance]\n    if multiple: args = list(zip(curve, face, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef PlanarClosedCurveRelationship(curveA, curveB, testPlane, tolerance, multiple=False):\n    \"\"\"\n    Determines whether two coplanar simple closed curves are disjoint or intersect;\n    otherwise, if the regions have a containment relationship, discovers\n    which curve encloses the other.\n\n    Args:\n        curveA (Curve): A first curve.\n        curveB (Curve): A second curve.\n        testPlane (Plane): A plane.\n        tolerance (double): A tolerance value.\n\n    Returns:\n        RegionContainment: A value indicating the relationship between the first and the second curve.\n    \"\"\"\n    url = \"rhino/geometry/curve/planarclosedcurverelationship-curve_curve_plane_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, testPlane, tolerance]\n    if multiple: args = list(zip(curveA, curveB, testPlane, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef PlanarCurveCollision(curveA, curveB, testPlane, tolerance, multiple=False):\n    \"\"\"\n    Determines if two coplanar curves collide (intersect).\n\n    Args:\n        curveA (Curve): A curve.\n        curveB (Curve): Another curve.\n        testPlane (Plane): A valid plane containing the curves.\n        tolerance (double): A tolerance value for intersection.\n\n    Returns:\n        bool: True if the curves intersect, otherwise false\n    \"\"\"\n    url = \"rhino/geometry/curve/planarcurvecollision-curve_curve_plane_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, testPlane, tolerance]\n    if multiple: args = list(zip(curveA, curveB, testPlane, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DuplicateSegments(thisCurve, multiple=False):\n    \"\"\"\n    Polylines will be exploded into line segments. ExplodeCurves will\n    return the curves in topological order.\n\n    Returns:\n        Curve[]: An array of all the segments that make up this curve.\n    \"\"\"\n    url = \"rhino/geometry/curve/duplicatesegments-curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve]\n    if multiple: args = [[item] for item in thisCurve]\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Smooth(thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem, multiple=False):\n    \"\"\"\n    Smooths a curve by averaging the positions of control points in a specified region.\n\n    Args:\n        smoothFactor (double): The smoothing factor, which controls how much control points move towards the average of the neighboring control points.\n        bXSmooth (bool): When True control points move in X axis direction.\n        bYSmooth (bool): When True control points move in Y axis direction.\n        bZSmooth (bool): When True control points move in Z axis direction.\n        bFixBoundaries (bool): When True the curve ends don't move.\n        coordinateSystem (SmoothingCoordinateSystem): The coordinates to determine the direction of the smoothing.\n\n    Returns:\n        Curve: The smoothed curve if successful, None otherwise.\n    \"\"\"\n    url = \"rhino/geometry/curve/smooth-curve_double_bool_bool_bool_bool_smoothingcoordinatesystem\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem]\n    if multiple: args = list(zip(thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Smooth1(thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem, plane, multiple=False):\n    \"\"\"\n    Smooths a curve by averaging the positions of control points in a specified region.\n\n    Args:\n        smoothFactor (double): The smoothing factor, which controls how much control points move towards the average of the neighboring control points.\n        bXSmooth (bool): When True control points move in X axis direction.\n        bYSmooth (bool): When True control points move in Y axis direction.\n        bZSmooth (bool): When True control points move in Z axis direction.\n        bFixBoundaries (bool): When True the curve ends don't move.\n        coordinateSystem (SmoothingCoordinateSystem): The coordinates to determine the direction of the smoothing.\n        plane (Plane): If SmoothingCoordinateSystem.CPlane specified, then the construction plane.\n\n    Returns:\n        Curve: The smoothed curve if successful, None otherwise.\n    \"\"\"\n    url = \"rhino/geometry/curve/smooth-curve_double_bool_bool_bool_bool_smoothingcoordinatesystem_plane\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem, plane]\n    if multiple: args = list(zip(thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem, plane))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef GetLocalPerpPoint(thisCurve, testPoint, seedParmameter, multiple=False):\n    \"\"\"\n    Search for a location on the curve, near seedParmameter, that is perpendicular to a test point.\n\n    Args:\n        testPoint (Point3d): The test point.\n        seedParmameter (double): A \"seed\" parameter on the curve.\n\n    Returns:\n        bool: True if a solution is found, False otherwise.\n        curveParameter (double): The parameter value at the perpendicular point\n    \"\"\"\n    url = \"rhino/geometry/curve/getlocalperppoint-curve_point3d_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, seedParmameter]\n    if multiple: args = list(zip(thisCurve, testPoint, seedParmameter))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLocalPerpPoint1(thisCurve, testPoint, seedParmameter, subDomain, multiple=False):\n    \"\"\"\n    Search for a location on the curve, near seedParmameter, that is perpendicular to a test point.\n\n    Args:\n        testPoint (Point3d): The test point.\n        seedParmameter (double): A \"seed\" parameter on the curve.\n        subDomain (Interval): The sub-domain of the curve to search.\n\n    Returns:\n        bool: True if a solution is found, False otherwise.\n        curveParameter (double): The parameter value at the perpendicular point\n    \"\"\"\n    url = \"rhino/geometry/curve/getlocalperppoint-curve_point3d_double_interval_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, seedParmameter, subDomain]\n    if multiple: args = list(zip(thisCurve, testPoint, seedParmameter, subDomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLocalTangentPoint(thisCurve, testPoint, seedParmameter, multiple=False):\n    \"\"\"\n    Search for a location on the curve, near seedParmameter, that is tangent to a test point.\n\n    Args:\n        testPoint (Point3d): The test point.\n        seedParmameter (double): A \"seed\" parameter on the curve.\n\n    Returns:\n        bool: True if a solution is found, False otherwise.\n        curveParameter (double): The parameter value at the tangent point\n    \"\"\"\n    url = \"rhino/geometry/curve/getlocaltangentpoint-curve_point3d_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, seedParmameter]\n    if multiple: args = list(zip(thisCurve, testPoint, seedParmameter))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLocalTangentPoint1(thisCurve, testPoint, seedParmameter, subDomain, multiple=False):\n    \"\"\"\n    Search for a location on the curve, near seedParmameter, that is tangent to a test point.\n\n    Args:\n        testPoint (Point3d): The test point.\n        seedParmameter (double): A \"seed\" parameter on the curve.\n        subDomain (Interval): The sub-domain of the curve to search.\n\n    Returns:\n        bool: True if a solution is found, False otherwise.\n        curveParameter (double): The parameter value at the tangent point\n    \"\"\"\n    url = \"rhino/geometry/curve/getlocaltangentpoint-curve_point3d_double_interval_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, seedParmameter, subDomain]\n    if multiple: args = list(zip(thisCurve, testPoint, seedParmameter, subDomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef InflectionPoints(thisCurve, multiple=False):\n    \"\"\"\n    Returns a curve's inflection points. An inflection point is a location on\n    a curve at which the sign of the curvature (i.e., the concavity) changes.\n    The curvature at these locations is always 0.\n\n    Returns:\n        Point3d[]: An array of points if successful, None if not successful or on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/inflectionpoints-curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve]\n    if multiple: args = [[item] for item in thisCurve]\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToPoint3d(response)\n    return response\n\n\ndef MaxCurvaturePoints(thisCurve, multiple=False):\n    \"\"\"\n    Returns a curve's maximum curvature points. The maximum curvature points identify\n    where the curvature starts to decrease in both directions from the points.\n\n    Returns:\n        Point3d[]: An array of points if successful, None if not successful or on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/maxcurvaturepoints-curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve]\n    if multiple: args = [[item] for item in thisCurve]\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToPoint3d(response)\n    return response\n\n\ndef MakeClosed(thisCurve, tolerance, multiple=False):\n    \"\"\"\n    If IsClosed, just return true. Otherwise, decide if curve can be closed as\n    follows: Linear curves polylinear curves with 2 segments, NURBS with 3 or less\n    control points cannot be made closed. Also, if tolerance > 0 and the gap between\n    start and end is larger than tolerance, curve cannot be made closed.\n    Adjust the curve's endpoint to match its start point.\n\n    Args:\n        tolerance (double): If nonzero, and the gap is more than tolerance, curve cannot be made closed.\n\n    Returns:\n        bool: True on success, False on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/makeclosed-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance]\n    if multiple: args = list(zip(thisCurve, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef LcoalClosestPoint(thisCurve, testPoint, seed, multiple=False):\n    \"\"\"\n    Find parameter of the point on a curve that is locally closest to\n    the testPoint.  The search for a local close point starts at\n    a seed parameter.\n\n    Args:\n        testPoint (Point3d): A point to test against.\n        seed (double): The seed parameter.\n\n    Returns:\n        bool: True if the search is successful, False if the search fails.\n        t (double): >Parameter of the curve that is closest to testPoint.\n    \"\"\"\n    url = \"rhino/geometry/curve/lcoalclosestpoint-curve_point3d_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, seed]\n    if multiple: args = list(zip(thisCurve, testPoint, seed))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef LocalClosestPoint(thisCurve, testPoint, seed, multiple=False):\n    \"\"\"\n    Find parameter of the point on a curve that is locally closest to\n    the testPoint.  The search for a local close point starts at\n    a seed parameter.\n\n    Args:\n        testPoint (Point3d): A point to test against.\n        seed (double): The seed parameter.\n\n    Returns:\n        bool: True if the search is successful, False if the search fails.\n        t (double): >Parameter of the curve that is closest to testPoint.\n    \"\"\"\n    url = \"rhino/geometry/curve/localclosestpoint-curve_point3d_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, seed]\n    if multiple: args = list(zip(thisCurve, testPoint, seed))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ClosestPoint(thisCurve, testPoint, multiple=False):\n    \"\"\"\n    Finds parameter of the point on a curve that is closest to testPoint.\n    If the maximumDistance parameter is > 0, then only points whose distance\n    to the given point is <= maximumDistance will be returned.  Using a\n    positive value of maximumDistance can substantially speed up the search.\n\n    Args:\n        testPoint (Point3d): Point to search from.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter of local closest point.\n    \"\"\"\n    url = \"rhino/geometry/curve/closestpoint-curve_point3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint]\n    if multiple: args = list(zip(thisCurve, testPoint))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ClosestPoint1(thisCurve, testPoint, maximumDistance, multiple=False):\n    \"\"\"\n    Finds the parameter of the point on a curve that is closest to testPoint.\n    If the maximumDistance parameter is > 0, then only points whose distance\n    to the given point is <= maximumDistance will be returned.  Using a\n    positive value of maximumDistance can substantially speed up the search.\n\n    Args:\n        testPoint (Point3d): Point to project.\n        maximumDistance (double): The maximum allowed distance.\n            Past this distance, the search is given up and False is returned.Use 0 to turn off this parameter.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): parameter of local closest point returned here.\n    \"\"\"\n    url = \"rhino/geometry/curve/closestpoint-curve_point3d_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, maximumDistance]\n    if multiple: args = list(zip(thisCurve, testPoint, maximumDistance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ClosestPoints(thisCurve, otherCurve, multiple=False):\n    \"\"\"\n    Gets closest points between this and another curves.\n\n    Args:\n        otherCurve (Curve): The other curve.\n\n    Returns:\n        bool: True on success; False on error.\n        pointOnThisCurve (Point3d): The point on this curve. This out parameter is assigned during this call.\n        pointOnOtherCurve (Point3d): The point on other curve. This out parameter is assigned during this call.\n    \"\"\"\n    url = \"rhino/geometry/curve/closestpoints-curve_curve_point3d_point3d\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, otherCurve]\n    if multiple: args = list(zip(thisCurve, otherCurve))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef Contains(thisCurve, testPoint, multiple=False):\n    \"\"\"\n    Computes the relationship between a point and a closed curve region.\n    This curve must be closed or the return value will be Unset.\n    Both curve and point are projected to the World XY plane.\n\n    Args:\n        testPoint (Point3d): Point to test.\n\n    Returns:\n        PointContainment: Relationship between point and curve region.\n    \"\"\"\n    url = \"rhino/geometry/curve/contains-curve_point3d\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint]\n    if multiple: args = list(zip(thisCurve, testPoint))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef Contains1(thisCurve, testPoint, plane, multiple=False):\n    \"\"\"\n    Computes the relationship between a point and a closed curve region.\n    This curve must be closed or the return value will be Unset.\n\n    Args:\n        testPoint (Point3d): Point to test.\n        plane (Plane): Plane in which to compare point and region.\n\n    Returns:\n        PointContainment: Relationship between point and curve region.\n    \"\"\"\n    url = \"rhino/geometry/curve/contains-curve_point3d_plane\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, plane]\n    if multiple: args = list(zip(thisCurve, testPoint, plane))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef Contains2(thisCurve, testPoint, plane, tolerance, multiple=False):\n    \"\"\"\n    Computes the relationship between a point and a closed curve region.\n    This curve must be closed or the return value will be Unset.\n\n    Args:\n        testPoint (Point3d): Point to test.\n        plane (Plane): Plane in which to compare point and region.\n        tolerance (double): Tolerance to use during comparison.\n\n    Returns:\n        PointContainment: Relationship between point and curve region.\n    \"\"\"\n    url = \"rhino/geometry/curve/contains-curve_point3d_plane_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, plane, tolerance]\n    if multiple: args = list(zip(thisCurve, testPoint, plane, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ExtremeParameters(thisCurve, direction, multiple=False):\n    \"\"\"\n    Returns the parameter values of all local extrema.\n    Parameter values are in increasing order so consecutive extrema\n    define an interval on which each component of the curve is monotone.\n    Note, non-periodic curves always return the end points.\n\n    Args:\n        direction (Vector3d): The direction in which to perform the calculation.\n\n    Returns:\n        double[]: The parameter values of all local extrema.\n    \"\"\"\n    url = \"rhino/geometry/curve/extremeparameters-curve_vector3d\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, direction]\n    if multiple: args = list(zip(thisCurve, direction))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CreatePeriodicCurve(curve, multiple=False):\n    \"\"\"\n    Removes kinks from a curve. Periodic curves deform smoothly without kinks.\n\n    Args:\n        curve (Curve): The curve to make periodic. Curve must have degree >= 2.\n\n    Returns:\n        Curve: The resulting curve if successful, None otherwise.\n    \"\"\"\n    url = \"rhino/geometry/curve/createperiodiccurve-curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve]\n    if multiple: args = [[item] for item in curve]\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreatePeriodicCurve1(curve, smooth, multiple=False):\n    \"\"\"\n    Removes kinks from a curve. Periodic curves deform smoothly without kinks.\n\n    Args:\n        curve (Curve): The curve to make periodic. Curve must have degree >= 2.\n        smooth (bool): If true, smooths any kinks in the curve and moves control points to make a smooth curve.\n            If false, control point locations are not changed or changed minimally (only one point may move) and only the knot vector is altered.\n\n    Returns:\n        Curve: The resulting curve if successful, None otherwise.\n    \"\"\"\n    url = \"rhino/geometry/curve/createperiodiccurve-curve_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, smooth]\n    if multiple: args = list(zip(curve, smooth))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef PointAtLength(thisCurve, length, multiple=False):\n    \"\"\"\n    Gets a point at a certain length along the curve. The length must be\n    non-negative and less than or equal to the length of the curve.\n    Lengths will not be wrapped when the curve is closed or periodic.\n\n    Args:\n        length (double): Length along the curve between the start point and the returned point.\n\n    Returns:\n        Point3d: Point on the curve at the specified length from the start point or Poin3d.Unset on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/pointatlength-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, length]\n    if multiple: args = list(zip(thisCurve, length))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToPoint3d(response)\n    return response\n\n\ndef PointAtNormalizedLength(thisCurve, length, multiple=False):\n    \"\"\"\n    Gets a point at a certain normalized length along the curve. The length must be\n    between or including 0.0 and 1.0, where 0.0 equals the start of the curve and\n    1.0 equals the end of the curve.\n\n    Args:\n        length (double): Normalized length along the curve between the start point and the returned point.\n\n    Returns:\n        Point3d: Point on the curve at the specified normalized length from the start point or Poin3d.Unset on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/pointatnormalizedlength-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, length]\n    if multiple: args = list(zip(thisCurve, length))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToPoint3d(response)\n    return response\n\n\ndef PerpendicularFrameAt(thisCurve, t, multiple=False):\n    \"\"\"\n    Return a 3d frame at a parameter. This is slightly different than FrameAt in\n    that the frame is computed in a way so there is minimal rotation from one\n    frame to the next.\n\n    Args:\n        t (double): Evaluation parameter.\n\n    Returns:\n        bool: True on success, False on failure.\n        plane (Plane): The frame is returned here.\n    \"\"\"\n    url = \"rhino/geometry/curve/perpendicularframeat-curve_double_plane\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, t]\n    if multiple: args = list(zip(thisCurve, t))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetPerpendicularFrames(thisCurve, parameters, multiple=False):\n    \"\"\"\n    Gets a collection of perpendicular frames along the curve. Perpendicular frames\n    are also known as 'Zero-twisting frames' and they minimize rotation from one frame to the next.\n\n    Args:\n        parameters (IEnumerable<double>): A collection of strictly increasing curve parameters to place perpendicular frames on.\n\n    Returns:\n        Plane[]: An array of perpendicular frames on success or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/getperpendicularframes-curve_doublearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, parameters]\n    if multiple: args = list(zip(thisCurve, parameters))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLength(thisCurve, multiple=False):\n    \"\"\"\n    Gets the length of the curve with a fractional tolerance of 1.0e-8.\n\n    Returns:\n        double: The length of the curve on success, or zero on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/getlength-curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve]\n    if multiple: args = [[item] for item in thisCurve]\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLength1(thisCurve, fractionalTolerance, multiple=False):\n    \"\"\"\n    Get the length of the curve.\n\n    Args:\n        fractionalTolerance (double): Desired fractional precision.\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\n\n    Returns:\n        double: The length of the curve on success, or zero on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/getlength-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, fractionalTolerance]\n    if multiple: args = list(zip(thisCurve, fractionalTolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLength2(thisCurve, subdomain, multiple=False):\n    \"\"\"\n    Get the length of a sub-section of the curve with a fractional tolerance of 1e-8.\n\n    Args:\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).\n\n    Returns:\n        double: The length of the sub-curve on success, or zero on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/getlength-curve_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, subdomain]\n    if multiple: args = list(zip(thisCurve, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLength3(thisCurve, fractionalTolerance, subdomain, multiple=False):\n    \"\"\"\n    Get the length of a sub-section of the curve.\n\n    Args:\n        fractionalTolerance (double): Desired fractional precision.\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).\n\n    Returns:\n        double: The length of the sub-curve on success, or zero on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/getlength-curve_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, fractionalTolerance, subdomain]\n    if multiple: args = list(zip(thisCurve, fractionalTolerance, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef IsShort(thisCurve, tolerance, multiple=False):\n    \"\"\"\n    Used to quickly find short curves.\n\n    Args:\n        tolerance (double): Length threshold value for \"shortness\".\n\n    Returns:\n        bool: True if the length of the curve is <= tolerance.\n    \"\"\"\n    url = \"rhino/geometry/curve/isshort-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance]\n    if multiple: args = list(zip(thisCurve, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef IsShort1(thisCurve, tolerance, subdomain, multiple=False):\n    \"\"\"\n    Used to quickly find short curves.\n\n    Args:\n        tolerance (double): Length threshold value for \"shortness\".\n        subdomain (Interval): The test is performed on the interval that is the intersection of sub-domain with Domain()\n\n    Returns:\n        bool: True if the length of the curve is <= tolerance.\n    \"\"\"\n    url = \"rhino/geometry/curve/isshort-curve_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance, subdomain]\n    if multiple: args = list(zip(thisCurve, tolerance, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef RemoveShortSegments(thisCurve, tolerance, multiple=False):\n    \"\"\"\n    Looks for segments that are shorter than tolerance that can be removed.\n    Does not change the domain, but it will change the relative parameterization.\n\n    Args:\n        tolerance (double): Tolerance which defines \"short\" segments.\n\n    Returns:\n        bool: True if removable short segments were found.\n        False if no removable short segments were found.\n    \"\"\"\n    url = \"rhino/geometry/curve/removeshortsegments-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance]\n    if multiple: args = list(zip(thisCurve, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef LengthParameter(thisCurve, segmentLength, multiple=False):\n    \"\"\"\n    Gets the parameter along the curve which coincides with a given length along the curve.\n    A fractional tolerance of 1e-8 is used in this version of the function.\n\n    Args:\n        segmentLength (double): Length of segment to measure. Must be less than or equal to the length of the curve.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from the curve start point to t equals length.\n    \"\"\"\n    url = \"rhino/geometry/curve/lengthparameter-curve_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength]\n    if multiple: args = list(zip(thisCurve, segmentLength))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef LengthParameter1(thisCurve, segmentLength, fractionalTolerance, multiple=False):\n    \"\"\"\n    Gets the parameter along the curve which coincides with a given length along the curve.\n\n    Args:\n        segmentLength (double): Length of segment to measure. Must be less than or equal to the length of the curve.\n        fractionalTolerance (double): Desired fractional precision.\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from the curve start point to t equals s.\n    \"\"\"\n    url = \"rhino/geometry/curve/lengthparameter-curve_double_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, fractionalTolerance]\n    if multiple: args = list(zip(thisCurve, segmentLength, fractionalTolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef LengthParameter2(thisCurve, segmentLength, subdomain, multiple=False):\n    \"\"\"\n    Gets the parameter along the curve which coincides with a given length along the curve.\n    A fractional tolerance of 1e-8 is used in this version of the function.\n\n    Args:\n        segmentLength (double): Length of segment to measure. Must be less than or equal to the length of the sub-domain.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve rather than the whole curve.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from the start of the sub-domain to t is s.\n    \"\"\"\n    url = \"rhino/geometry/curve/lengthparameter-curve_double_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, subdomain]\n    if multiple: args = list(zip(thisCurve, segmentLength, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef LengthParameter3(thisCurve, segmentLength, fractionalTolerance, subdomain, multiple=False):\n    \"\"\"\n    Gets the parameter along the curve which coincides with a given length along the curve.\n\n    Args:\n        segmentLength (double): Length of segment to measure. Must be less than or equal to the length of the sub-domain.\n        fractionalTolerance (double): Desired fractional precision.\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve rather than the whole curve.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from the start of the sub-domain to t is s.\n    \"\"\"\n    url = \"rhino/geometry/curve/lengthparameter-curve_double_double_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, fractionalTolerance, subdomain]\n    if multiple: args = list(zip(thisCurve, segmentLength, fractionalTolerance, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameter(thisCurve, s, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n    A fractional tolerance of 1e-8 is used in this version of the function.\n\n    Args:\n        s (double): Normalized arc length parameter.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from its start to t is arc_length.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameter-curve_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s]\n    if multiple: args = list(zip(thisCurve, s))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameter1(thisCurve, s, fractionalTolerance, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n\n    Args:\n        s (double): Normalized arc length parameter.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        fractionalTolerance (double): Desired fractional precision.\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from its start to t is arc_length.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameter-curve_double_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, fractionalTolerance]\n    if multiple: args = list(zip(thisCurve, s, fractionalTolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameter2(thisCurve, s, subdomain, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n    A fractional tolerance of 1e-8 is used in this version of the function.\n\n    Args:\n        s (double): Normalized arc length parameter.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from its start to t is arc_length.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameter-curve_double_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, subdomain]\n    if multiple: args = list(zip(thisCurve, s, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameter3(thisCurve, s, fractionalTolerance, subdomain, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n\n    Args:\n        s (double): Normalized arc length parameter.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        fractionalTolerance (double): Desired fractional precision.\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from its start to t is arc_length.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameter-curve_double_double_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, fractionalTolerance, subdomain]\n    if multiple: args = list(zip(thisCurve, s, fractionalTolerance, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameters(thisCurve, s, absoluteTolerance, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n    A fractional tolerance of 1e-8 is used in this version of the function.\n\n    Args:\n        s (double[]): Array of normalized arc length parameters.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        absoluteTolerance (double): If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length\n            and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n\n    Returns:\n        double[]: If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length.\n        Null on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameters-curve_doublearray_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, absoluteTolerance]\n    if multiple: args = list(zip(thisCurve, s, absoluteTolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameters1(thisCurve, s, absoluteTolerance, fractionalTolerance, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n\n    Args:\n        s (double[]): Array of normalized arc length parameters.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        absoluteTolerance (double): If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length\n            and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n        fractionalTolerance (double): Desired fractional precision for each segment.\n            fabs(\"true\" length - actual length)/(actual length) <= fractionalTolerance.\n\n    Returns:\n        double[]: If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length.\n        Null on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameters-curve_doublearray_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, absoluteTolerance, fractionalTolerance]\n    if multiple: args = list(zip(thisCurve, s, absoluteTolerance, fractionalTolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameters2(thisCurve, s, absoluteTolerance, subdomain, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n    A fractional tolerance of 1e-8 is used in this version of the function.\n\n    Args:\n        s (double[]): Array of normalized arc length parameters.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        absoluteTolerance (double): If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length\n            and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve.\n            A 0.0 s value corresponds to sub-domain->Min() and a 1.0 s value corresponds to sub-domain->Max().\n\n    Returns:\n        double[]: If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length.\n        Null on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameters-curve_doublearray_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, absoluteTolerance, subdomain]\n    if multiple: args = list(zip(thisCurve, s, absoluteTolerance, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameters3(thisCurve, s, absoluteTolerance, fractionalTolerance, subdomain, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n\n    Args:\n        s (double[]): Array of normalized arc length parameters.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        absoluteTolerance (double): If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length\n            and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n        fractionalTolerance (double): Desired fractional precision for each segment.\n            fabs(\"true\" length - actual length)/(actual length) <= fractionalTolerance.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve.\n            A 0.0 s value corresponds to sub-domain->Min() and a 1.0 s value corresponds to sub-domain->Max().\n\n    Returns:\n        double[]: If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length.\n        Null on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameters-curve_doublearray_double_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, absoluteTolerance, fractionalTolerance, subdomain]\n    if multiple: args = list(zip(thisCurve, s, absoluteTolerance, fractionalTolerance, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideByCount(thisCurve, segmentCount, includeEnds, multiple=False):\n    \"\"\"\n    Divide the curve into a number of equal-length segments.\n\n    Args:\n        segmentCount (int): Segment count. Note that the number of division points may differ from the segment count.\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\n\n    Returns:\n        double[]: List of curve parameters at the division points on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/dividebycount-curve_int_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentCount, includeEnds]\n    if multiple: args = list(zip(thisCurve, segmentCount, includeEnds))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideByCount1(thisCurve, segmentCount, includeEnds, multiple=False):\n    \"\"\"\n    Divide the curve into a number of equal-length segments.\n\n    Args:\n        segmentCount (int): Segment count. Note that the number of division points may differ from the segment count.\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\n\n    Returns:\n        double[]: Array containing division curve parameters on success, None on failure.\n        points (Point3d[]): A list of division points. If the function returns successfully, this point-array will be filled in.\n    \"\"\"\n    url = \"rhino/geometry/curve/dividebycount-curve_int_bool_point3darray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentCount, includeEnds]\n    if multiple: args = list(zip(thisCurve, segmentCount, includeEnds))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideByLength(thisCurve, segmentLength, includeEnds, multiple=False):\n    \"\"\"\n    Divide the curve into specific length segments.\n\n    Args:\n        segmentLength (double): The length of each and every segment (except potentially the last one).\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\n\n    Returns:\n        double[]: Array containing division curve parameters if successful, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/dividebylength-curve_double_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, includeEnds]\n    if multiple: args = list(zip(thisCurve, segmentLength, includeEnds))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideByLength1(thisCurve, segmentLength, includeEnds, reverse, multiple=False):\n    \"\"\"\n    Divide the curve into specific length segments.\n\n    Args:\n        segmentLength (double): The length of each and every segment (except potentially the last one).\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\n        reverse (bool): If true, then the divisions start from the end of the curve.\n\n    Returns:\n        double[]: Array containing division curve parameters if successful, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/dividebylength-curve_double_bool_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, includeEnds, reverse]\n    if multiple: args = list(zip(thisCurve, segmentLength, includeEnds, reverse))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideByLength2(thisCurve, segmentLength, includeEnds, multiple=False):\n    \"\"\"\n    Divide the curve into specific length segments.\n\n    Args:\n        segmentLength (double): The length of each and every segment (except potentially the last one).\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\n\n    Returns:\n        double[]: Array containing division curve parameters if successful, None on failure.\n        points (Point3d[]): If function is successful, points at each parameter value are returned in points.\n    \"\"\"\n    url = \"rhino/geometry/curve/dividebylength-curve_double_bool_point3darray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, includeEnds]\n    if multiple: args = list(zip(thisCurve, segmentLength, includeEnds))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideByLength3(thisCurve, segmentLength, includeEnds, reverse, multiple=False):\n    \"\"\"\n    Divide the curve into specific length segments.\n\n    Args:\n        segmentLength (double): The length of each and every segment (except potentially the last one).\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\n        reverse (bool): If true, then the divisions start from the end of the curve.\n\n    Returns:\n        double[]: Array containing division curve parameters if successful, None on failure.\n        points (Point3d[]): If function is successful, points at each parameter value are returned in points.\n    \"\"\"\n    url = \"rhino/geometry/curve/dividebylength-curve_double_bool_bool_point3darray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, includeEnds, reverse]\n    if multiple: args = list(zip(thisCurve, segmentLength, includeEnds, reverse))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideEquidistant(thisCurve, distance, multiple=False):\n    \"\"\"\n    Calculates 3d points on a curve where the linear distance between the points is equal.\n\n    Args:\n        distance (double): The distance between division points.\n\n    Returns:\n        Point3d[]: An array of equidistant points, or None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/divideequidistant-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, distance]\n    if multiple: args = list(zip(thisCurve, distance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToPoint3d(response)\n    return response\n\n\ndef DivideAsContour(thisCurve, contourStart, contourEnd, interval, multiple=False):\n    \"\"\"\n    Divides this curve at fixed steps along a defined contour line.\n\n    Args:\n        contourStart (Point3d): The start of the contouring line.\n        contourEnd (Point3d): The end of the contouring line.\n        interval (double): A distance to measure on the contouring axis.\n\n    Returns:\n        Point3d[]: An array of points; or None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/divideascontour-curve_point3d_point3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, contourStart, contourEnd, interval]\n    if multiple: args = list(zip(thisCurve, contourStart, contourEnd, interval))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToPoint3d(response)\n    return response\n\n\ndef Trim(thisCurve, side, length, multiple=False):\n    \"\"\"\n    Shortens a curve by a given length\n\n    Returns:\n        Curve: Trimmed curve if successful, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/trim-curve_curveend_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, length]\n    if multiple: args = list(zip(thisCurve, side, length))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Split(thisCurve, cutter, tolerance, multiple=False):\n    \"\"\"\n    Splits a curve into pieces using a polysurface.\n\n    Args:\n        cutter (Brep): A cutting surface or polysurface.\n        tolerance (double): A tolerance for computing intersections.\n\n    Returns:\n        Curve[]: An array of curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/split-curve_brep_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, cutter, tolerance]\n    if multiple: args = list(zip(thisCurve, cutter, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Split1(thisCurve, cutter, tolerance, angleToleranceRadians, multiple=False):\n    \"\"\"\n    Splits a curve into pieces using a polysurface.\n\n    Args:\n        cutter (Brep): A cutting surface or polysurface.\n        tolerance (double): A tolerance for computing intersections.\n\n    Returns:\n        Curve[]: An array of curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/split-curve_brep_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, cutter, tolerance, angleToleranceRadians]\n    if multiple: args = list(zip(thisCurve, cutter, tolerance, angleToleranceRadians))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Split2(thisCurve, cutter, tolerance, multiple=False):\n    \"\"\"\n    Splits a curve into pieces using a surface.\n\n    Args:\n        cutter (Surface): A cutting surface or polysurface.\n        tolerance (double): A tolerance for computing intersections.\n\n    Returns:\n        Curve[]: An array of curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/split-curve_surface_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, cutter, tolerance]\n    if multiple: args = list(zip(thisCurve, cutter, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Split3(thisCurve, cutter, tolerance, angleToleranceRadians, multiple=False):\n    \"\"\"\n    Splits a curve into pieces using a surface.\n\n    Args:\n        cutter (Surface): A cutting surface or polysurface.\n        tolerance (double): A tolerance for computing intersections.\n\n    Returns:\n        Curve[]: An array of curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/split-curve_surface_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, cutter, tolerance, angleToleranceRadians]\n    if multiple: args = list(zip(thisCurve, cutter, tolerance, angleToleranceRadians))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Extend(thisCurve, t0, t1, multiple=False):\n    \"\"\"\n    Where possible, analytically extends curve to include the given domain.\n    This will not work on closed curves. The original curve will be identical to the\n    restriction of the resulting curve to the original curve domain.\n\n    Args:\n        t0 (double): Start of extension domain, if the start is not inside the\n            Domain of this curve, an attempt will be made to extend the curve.\n        t1 (double): End of extension domain, if the end is not inside the\n            Domain of this curve, an attempt will be made to extend the curve.\n\n    Returns:\n        Curve: Extended curve on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extend-curve_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, t0, t1]\n    if multiple: args = list(zip(thisCurve, t0, t1))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Extend1(thisCurve, domain, multiple=False):\n    \"\"\"\n    Where possible, analytically extends curve to include the given domain.\n    This will not work on closed curves. The original curve will be identical to the\n    restriction of the resulting curve to the original curve domain.\n\n    Args:\n        domain (Interval): Extension domain.\n\n    Returns:\n        Curve: Extended curve on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extend-curve_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, domain]\n    if multiple: args = list(zip(thisCurve, domain))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Extend2(thisCurve, side, length, style, multiple=False):\n    \"\"\"\n    Extends a curve by a specific length.\n\n    Args:\n        side (CurveEnd): Curve end to extend.\n        length (double): Length to add to the curve end.\n        style (CurveExtensionStyle): Extension style.\n\n    Returns:\n        Curve: A curve with extended ends or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extend-curve_curveend_double_curveextensionstyle\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, length, style]\n    if multiple: args = list(zip(thisCurve, side, length, style))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Extend3(thisCurve, side, style, geometry, multiple=False):\n    \"\"\"\n    Extends a curve until it intersects a collection of objects.\n\n    Args:\n        side (CurveEnd): The end of the curve to extend.\n        style (CurveExtensionStyle): The style or type of extension to use.\n        geometry (System.Collections.Generic.IEnumerable<GeometryBase>): A collection of objects. Allowable object types are Curve, Surface, Brep.\n\n    Returns:\n        Curve: New extended curve result on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extend-curve_curveend_curveextensionstyle_geometrybasearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, style, geometry]\n    if multiple: args = list(zip(thisCurve, side, style, geometry))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Extend4(thisCurve, side, style, endPoint, multiple=False):\n    \"\"\"\n    Extends a curve to a point.\n\n    Args:\n        side (CurveEnd): The end of the curve to extend.\n        style (CurveExtensionStyle): The style or type of extension to use.\n        endPoint (Point3d): A new end point.\n\n    Returns:\n        Curve: New extended curve result on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extend-curve_curveend_curveextensionstyle_point3d\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, style, endPoint]\n    if multiple: args = list(zip(thisCurve, side, style, endPoint))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ExtendOnSurface(thisCurve, side, surface, multiple=False):\n    \"\"\"\n    Extends a curve on a surface.\n\n    Args:\n        side (CurveEnd): The end of the curve to extend.\n        surface (Surface): Surface that contains the curve.\n\n    Returns:\n        Curve: New extended curve result on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extendonsurface-curve_curveend_surface\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, surface]\n    if multiple: args = list(zip(thisCurve, side, surface))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ExtendOnSurface1(thisCurve, side, face, multiple=False):\n    \"\"\"\n    Extends a curve on a surface.\n\n    Args:\n        side (CurveEnd): The end of the curve to extend.\n        face (BrepFace): BrepFace that contains the curve.\n\n    Returns:\n        Curve: New extended curve result on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extendonsurface-curve_curveend_brepface\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, face]\n    if multiple: args = list(zip(thisCurve, side, face))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ExtendByLine(thisCurve, side, geometry, multiple=False):\n    \"\"\"\n    Extends a curve by a line until it intersects a collection of objects.\n\n    Args:\n        side (CurveEnd): The end of the curve to extend.\n        geometry (System.Collections.Generic.IEnumerable<GeometryBase>): A collection of objects. Allowable object types are Curve, Surface, Brep.\n\n    Returns:\n        Curve: New extended curve result on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extendbyline-curve_curveend_geometrybasearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, geometry]\n    if multiple: args = list(zip(thisCurve, side, geometry))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ExtendByArc(thisCurve, side, geometry, multiple=False):\n    \"\"\"\n    Extends a curve by an Arc until it intersects a collection of objects.\n\n    Args:\n        side (CurveEnd): The end of the curve to extend.\n        geometry (System.Collections.Generic.IEnumerable<GeometryBase>): A collection of objects. Allowable object types are Curve, Surface, Brep.\n\n    Returns:\n        Curve: New extended curve result on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extendbyarc-curve_curveend_geometrybasearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, geometry]\n    if multiple: args = list(zip(thisCurve, side, geometry))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Simplify(thisCurve, options, distanceTolerance, angleToleranceRadians, multiple=False):\n    \"\"\"\n    Returns a geometrically equivalent PolyCurve.\n    The PolyCurve has the following properties\n    1. All the PolyCurve segments are LineCurve, PolylineCurve, ArcCurve, or NurbsCurve.\n    \n    2. The NURBS Curves segments do not have fully multiple interior knots.\n    \n    3. Rational NURBS curves do not have constant weights.\n    \n    4. Any segment for which IsLinear() or IsArc() is True is a Line,\n    Polyline segment, or an Arc.\n    \n    5. Adjacent co-linear or co-circular segments are combined.\n    \n    6. Segments that meet with G1-continuity have there ends tuned up so\n    that they meet with G1-continuity to within machine precision.\n\n    Args:\n        options (CurveSimplifyOptions): Simplification options.\n        distanceTolerance (double): A distance tolerance for the simplification.\n        angleToleranceRadians (double): An angle tolerance for the simplification.\n\n    Returns:\n        Curve: New simplified curve on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/simplify-curve_curvesimplifyoptions_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, options, distanceTolerance, angleToleranceRadians]\n    if multiple: args = list(zip(thisCurve, options, distanceTolerance, angleToleranceRadians))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef SimplifyEnd(thisCurve, end, options, distanceTolerance, angleToleranceRadians, multiple=False):\n    \"\"\"\n    Same as SimplifyCurve, but simplifies only the last two segments at \"side\" end.\n\n    Args:\n        end (CurveEnd): If CurveEnd.Start the function simplifies the last two start\n            side segments, otherwise if CurveEnd.End the last two end side segments are simplified.\n        options (CurveSimplifyOptions): Simplification options.\n        distanceTolerance (double): A distance tolerance for the simplification.\n        angleToleranceRadians (double): An angle tolerance for the simplification.\n\n    Returns:\n        Curve: New simplified curve on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/simplifyend-curve_curveend_curvesimplifyoptions_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, end, options, distanceTolerance, angleToleranceRadians]\n    if multiple: args = list(zip(thisCurve, end, options, distanceTolerance, angleToleranceRadians))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Fair(thisCurve, distanceTolerance, angleTolerance, clampStart, clampEnd, iterations, multiple=False):\n    \"\"\"\n    Fairs a curve object. Fair works best on degree 3 (cubic) curves. Attempts to\n    remove large curvature variations while limiting the geometry changes to be no\n    more than the specified tolerance.\n\n    Args:\n        distanceTolerance (double): Maximum allowed distance the faired curve is allowed to deviate from the input.\n        angleTolerance (double): (in radians) kinks with angles <= angleTolerance are smoothed out 0.05 is a good default.\n        clampStart (int): The number of (control vertices-1) to preserve at start.\n            0 = preserve start point1 = preserve start point and 1st derivative2 = preserve start point, 1st and 2nd derivative\n        clampEnd (int): Same as clampStart.\n        iterations (int): The number of iterations to use in adjusting the curve.\n\n    Returns:\n        Curve: Returns new faired Curve on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/fair-curve_double_double_int_int_int\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, distanceTolerance, angleTolerance, clampStart, clampEnd, iterations]\n    if multiple: args = list(zip(thisCurve, distanceTolerance, angleTolerance, clampStart, clampEnd, iterations))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Fit(thisCurve, degree, fitTolerance, angleTolerance, multiple=False):\n    \"\"\"\n    Fits a new curve through an existing curve.\n\n    Args:\n        degree (int): The degree of the returned Curve. Must be bigger than 1.\n        fitTolerance (double): The fitting tolerance. If fitTolerance is RhinoMath.UnsetValue or <=0.0,\n            the document absolute tolerance is used.\n        angleTolerance (double): The kink smoothing tolerance in radians.\n            If angleTolerance is 0.0, all kinks are smoothedIf angleTolerance is >0.0, kinks smaller than angleTolerance are smoothedIf angleTolerance is RhinoMath.UnsetValue or <0.0, the document angle tolerance is used for the kink smoothing\n\n    Returns:\n        Curve: Returns a new fitted Curve if successful, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/fit-curve_int_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, degree, fitTolerance, angleTolerance]\n    if multiple: args = list(zip(thisCurve, degree, fitTolerance, angleTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Rebuild(thisCurve, pointCount, degree, preserveTangents, multiple=False):\n    \"\"\"\n    Rebuild a curve with a specific point count.\n\n    Args:\n        pointCount (int): Number of control points in the rebuild curve.\n        degree (int): Degree of curve. Valid values are between and including 1 and 11.\n        preserveTangents (bool): If true, the end tangents of the input curve will be preserved.\n\n    Returns:\n        NurbsCurve: A NURBS curve on success or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/rebuild-curve_int_int_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, pointCount, degree, preserveTangents]\n    if multiple: args = list(zip(thisCurve, pointCount, degree, preserveTangents))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ToPolyline(thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint, multiple=False):\n    \"\"\"\n    Gets a polyline approximation of a curve.\n\n    Args:\n        mainSegmentCount (int): If mainSegmentCount <= 0, then both subSegmentCount and mainSegmentCount are ignored.\n            If mainSegmentCount > 0, then subSegmentCount must be >= 1. In this\n            case the NURBS will be broken into mainSegmentCount equally spaced\n            chords. If needed, each of these chords can be split into as many\n            subSegmentCount sub-parts if the subdivision is necessary for the\n            mesh to meet the other meshing constraints. In particular, if\n            subSegmentCount = 0, then the curve is broken into mainSegmentCount\n            pieces and no further testing is performed.\n        subSegmentCount (int): An amount of subsegments.\n        maxAngleRadians (double): ( 0 to pi ) Maximum angle (in radians) between unit tangents at\n            adjacent vertices.\n        maxChordLengthRatio (double): Maximum permitted value of\n            (distance chord midpoint to curve) / (length of chord).\n        maxAspectRatio (double): If maxAspectRatio < 1.0, the parameter is ignored.\n            If 1 <= maxAspectRatio < sqrt(2), it is treated as if maxAspectRatio = sqrt(2).\n            This parameter controls the maximum permitted value of\n            (length of longest chord) / (length of shortest chord).\n        tolerance (double): If tolerance = 0, the parameter is ignored.\n            This parameter controls the maximum permitted value of the\n            distance from the curve to the polyline.\n        minEdgeLength (double): The minimum permitted edge length.\n        maxEdgeLength (double): If maxEdgeLength = 0, the parameter\n            is ignored. This parameter controls the maximum permitted edge length.\n        keepStartPoint (bool): If True the starting point of the curve\n            is added to the polyline. If False the starting point of the curve is\n            not added to the polyline.\n\n    Returns:\n        PolylineCurve: PolylineCurve on success, None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/topolyline-curve_int_int_double_double_double_double_double_double_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint]\n    if multiple: args = list(zip(thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ToPolyline1(thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint, curveDomain, multiple=False):\n    \"\"\"\n    Gets a polyline approximation of a curve.\n\n    Args:\n        mainSegmentCount (int): If mainSegmentCount <= 0, then both subSegmentCount and mainSegmentCount are ignored.\n            If mainSegmentCount > 0, then subSegmentCount must be >= 1. In this\n            case the NURBS will be broken into mainSegmentCount equally spaced\n            chords. If needed, each of these chords can be split into as many\n            subSegmentCount sub-parts if the subdivision is necessary for the\n            mesh to meet the other meshing constraints. In particular, if\n            subSegmentCount = 0, then the curve is broken into mainSegmentCount\n            pieces and no further testing is performed.\n        subSegmentCount (int): An amount of subsegments.\n        maxAngleRadians (double): ( 0 to pi ) Maximum angle (in radians) between unit tangents at\n            adjacent vertices.\n        maxChordLengthRatio (double): Maximum permitted value of\n            (distance chord midpoint to curve) / (length of chord).\n        maxAspectRatio (double): If maxAspectRatio < 1.0, the parameter is ignored.\n            If 1 <= maxAspectRatio < sqrt(2), it is treated as if maxAspectRatio = sqrt(2).\n            This parameter controls the maximum permitted value of\n            (length of longest chord) / (length of shortest chord).\n        tolerance (double): If tolerance = 0, the parameter is ignored.\n            This parameter controls the maximum permitted value of the\n            distance from the curve to the polyline.\n        minEdgeLength (double): The minimum permitted edge length.\n        maxEdgeLength (double): If maxEdgeLength = 0, the parameter\n            is ignored. This parameter controls the maximum permitted edge length.\n        keepStartPoint (bool): If True the starting point of the curve\n            is added to the polyline. If False the starting point of the curve is\n            not added to the polyline.\n        curveDomain (Interval): This sub-domain of the NURBS curve is approximated.\n\n    Returns:\n        PolylineCurve: PolylineCurve on success, None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/topolyline-curve_int_int_double_double_double_double_double_double_bool_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint, curveDomain]\n    if multiple: args = list(zip(thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint, curveDomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ToPolyline2(thisCurve, tolerance, angleTolerance, minimumLength, maximumLength, multiple=False):\n    \"\"\"\n    Gets a polyline approximation of a curve.\n\n    Args:\n        tolerance (double): The tolerance. This is the maximum deviation from line midpoints to the curve. When in doubt, use the document's model space absolute tolerance.\n        angleTolerance (double): The angle tolerance in radians. This is the maximum deviation of the line directions. When in doubt, use the document's model space angle tolerance.\n        minimumLength (double): The minimum segment length.\n        maximumLength (double): The maximum segment length.\n\n    Returns:\n        PolylineCurve: PolyCurve on success, None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/topolyline-curve_double_double_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance, angleTolerance, minimumLength, maximumLength]\n    if multiple: args = list(zip(thisCurve, tolerance, angleTolerance, minimumLength, maximumLength))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ToArcsAndLines(thisCurve, tolerance, angleTolerance, minimumLength, maximumLength, multiple=False):\n    \"\"\"\n    Converts a curve into polycurve consisting of arc segments. Sections of the input curves that are nearly straight are converted to straight-line segments.\n\n    Args:\n        tolerance (double): The tolerance. This is the maximum deviation from arc midpoints to the curve. When in doubt, use the document's model space absolute tolerance.\n        angleTolerance (double): The angle tolerance in radians. This is the maximum deviation of the arc end directions from the curve direction. When in doubt, use the document's model space angle tolerance.\n        minimumLength (double): The minimum segment length.\n        maximumLength (double): The maximum segment length.\n\n    Returns:\n        PolyCurve: PolyCurve on success, None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/toarcsandlines-curve_double_double_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance, angleTolerance, minimumLength, maximumLength]\n    if multiple: args = list(zip(thisCurve, tolerance, angleTolerance, minimumLength, maximumLength))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef PullToMesh(thisCurve, mesh, tolerance, multiple=False):\n    \"\"\"\n    Makes a polyline approximation of the curve and gets the closest point on the mesh for each point on the curve.\n    Then it \"connects the points\" so that you have a polyline on the mesh.\n\n    Args:\n        mesh (Mesh): Mesh to project onto.\n        tolerance (double): Input tolerance (RhinoDoc.ModelAbsoluteTolerance is a good default)\n\n    Returns:\n        PolylineCurve: A polyline curve on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/pulltomesh-curve_mesh_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, mesh, tolerance]\n    if multiple: args = list(zip(thisCurve, mesh, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef Offset(thisCurve, plane, distance, tolerance, cornerStyle, multiple=False):\n    \"\"\"\n    Offsets this curve. If you have a nice offset, then there will be one entry in\n    the array. If the original curve had kinks or the offset curve had self\n    intersections, you will get multiple segments in the output array.\n\n    Args:\n        plane (Plane): Offset solution plane.\n        distance (double): The positive or negative distance to offset.\n        tolerance (double): The offset or fitting tolerance.\n        cornerStyle (CurveOffsetCornerStyle): Corner style for offset kinks.\n\n    Returns:\n        Curve[]: Offset curves on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offset-curve_plane_double_double_curveoffsetcornerstyle\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, plane, distance, tolerance, cornerStyle]\n    if multiple: args = list(zip(thisCurve, plane, distance, tolerance, cornerStyle))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Offset1(thisCurve, directionPoint, normal, distance, tolerance, cornerStyle, multiple=False):\n    \"\"\"\n    Offsets this curve. If you have a nice offset, then there will be one entry in\n    the array. If the original curve had kinks or the offset curve had self\n    intersections, you will get multiple segments in the output array.\n\n    Args:\n        directionPoint (Point3d): A point that indicates the direction of the offset.\n        normal (Vector3d): The normal to the offset plane.\n        distance (double): The positive or negative distance to offset.\n        tolerance (double): The offset or fitting tolerance.\n        cornerStyle (CurveOffsetCornerStyle): Corner style for offset kinks.\n\n    Returns:\n        Curve[]: Offset curves on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offset-curve_point3d_vector3d_double_double_curveoffsetcornerstyle\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, directionPoint, normal, distance, tolerance, cornerStyle]\n    if multiple: args = list(zip(thisCurve, directionPoint, normal, distance, tolerance, cornerStyle))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Offset2(thisCurve, directionPoint, normal, distance, tolerance, angleTolerance, loose, cornerStyle, endStyle, multiple=False):\n    \"\"\"\n    Offsets this curve. If you have a nice offset, then there will be one entry in\n    the array. If the original curve had kinks or the offset curve had self\n    intersections, you will get multiple segments in the output array.\n\n    Args:\n        directionPoint (Point3d): A point that indicates the direction of the offset.\n        normal (Vector3d): The normal to the offset plane.\n        distance (double): The positive or negative distance to offset.\n        tolerance (double): The offset or fitting tolerance.\n        angleTolerance (double): The angle tolerance, in radians, used to decide whether to split at kinks.\n        loose (bool): If false, offset within tolerance. If true, offset by moving edit points.\n        cornerStyle (CurveOffsetCornerStyle): Corner style for offset kinks.\n        endStyle (CurveOffsetEndStyle): End style for non-loose, non-closed curve offsets.\n\n    Returns:\n        Curve[]: Offset curves on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offset-curve_point3d_vector3d_double_double_double_bool_curveoffsetcornerstyle_curveoffsetendstyle\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, directionPoint, normal, distance, tolerance, angleTolerance, loose, cornerStyle, endStyle]\n    if multiple: args = list(zip(thisCurve, directionPoint, normal, distance, tolerance, angleTolerance, loose, cornerStyle, endStyle))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef RibbonOffset(thisCurve, distance, blendRadius, directionPoint, normal, tolerance, multiple=False):\n    \"\"\"\n    Offsets a closed curve in the following way: pProject the curve to a plane with given normal.\n    Then, loose Offset the projection by distance + blend_radius and trim off self-intersection.\n    THen, Offset the remaining curve back in the opposite direction by blend_radius, filling gaps with blends.\n    Finally, use the elevations of the input curve to get the correct elevations of the result.\n\n    Args:\n        distance (double): The positive distance to offset the curve.\n        blendRadius (double): Positive, typically the same as distance. When the offset results in a self-intersection\n            that gets trimmed off at a kink, the kink will be blended out using this radius.\n        directionPoint (Point3d): A point that indicates the direction of the offset. If the offset is inward,\n            the point's projection to the plane should be well within the curve.\n            It will be used to decide which part of the offset to keep if there are self-intersections.\n        normal (Vector3d): A vector that indicates the normal of the plane in which the offset will occur.\n        tolerance (double): Used to determine self-intersections, not offset error.\n\n    Returns:\n        Curve: The offset curve if successful.\n    \"\"\"\n    url = \"rhino/geometry/curve/ribbonoffset-curve_double_double_point3d_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, distance, blendRadius, directionPoint, normal, tolerance]\n    if multiple: args = list(zip(thisCurve, distance, blendRadius, directionPoint, normal, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetOnSurface(thisCurve, face, distance, fittingTolerance, multiple=False):\n    \"\"\"\n    Offset this curve on a brep face surface. This curve must lie on the surface.\n\n    Args:\n        face (BrepFace): The brep face on which to offset.\n        distance (double): A distance to offset (+)left, (-)right.\n        fittingTolerance (double): A fitting tolerance.\n\n    Returns:\n        Curve[]: Offset curves on success, or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetonsurface-curve_brepface_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, face, distance, fittingTolerance]\n    if multiple: args = list(zip(thisCurve, face, distance, fittingTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetOnSurface1(thisCurve, face, throughPoint, fittingTolerance, multiple=False):\n    \"\"\"\n    Offset a curve on a brep face surface. This curve must lie on the surface.\n    This overload allows to specify a surface point at which the offset will pass.\n\n    Args:\n        face (BrepFace): The brep face on which to offset.\n        throughPoint (Point2d): 2d point on the brep face to offset through.\n        fittingTolerance (double): A fitting tolerance.\n\n    Returns:\n        Curve[]: Offset curves on success, or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetonsurface-curve_brepface_point2d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, face, throughPoint, fittingTolerance]\n    if multiple: args = list(zip(thisCurve, face, throughPoint, fittingTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetOnSurface2(thisCurve, face, curveParameters, offsetDistances, fittingTolerance, multiple=False):\n    \"\"\"\n    Offset a curve on a brep face surface. This curve must lie on the surface.\n    This overload allows to specify different offsets for different curve parameters.\n\n    Args:\n        face (BrepFace): The brep face on which to offset.\n        curveParameters (double[]): Curve parameters corresponding to the offset distances.\n        offsetDistances (double[]): distances to offset (+)left, (-)right.\n        fittingTolerance (double): A fitting tolerance.\n\n    Returns:\n        Curve[]: Offset curves on success, or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetonsurface-curve_brepface_doublearray_doublearray_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, face, curveParameters, offsetDistances, fittingTolerance]\n    if multiple: args = list(zip(thisCurve, face, curveParameters, offsetDistances, fittingTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetOnSurface3(thisCurve, surface, distance, fittingTolerance, multiple=False):\n    \"\"\"\n    Offset a curve on a surface. This curve must lie on the surface.\n\n    Args:\n        surface (Surface): A surface on which to offset.\n        distance (double): A distance to offset (+)left, (-)right.\n        fittingTolerance (double): A fitting tolerance.\n\n    Returns:\n        Curve[]: Offset curves on success, or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetonsurface-curve_surface_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, surface, distance, fittingTolerance]\n    if multiple: args = list(zip(thisCurve, surface, distance, fittingTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetOnSurface4(thisCurve, surface, throughPoint, fittingTolerance, multiple=False):\n    \"\"\"\n    Offset a curve on a surface. This curve must lie on the surface.\n    This overload allows to specify a surface point at which the offset will pass.\n\n    Args:\n        surface (Surface): A surface on which to offset.\n        throughPoint (Point2d): 2d point on the brep face to offset through.\n        fittingTolerance (double): A fitting tolerance.\n\n    Returns:\n        Curve[]: Offset curves on success, or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetonsurface-curve_surface_point2d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, surface, throughPoint, fittingTolerance]\n    if multiple: args = list(zip(thisCurve, surface, throughPoint, fittingTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetOnSurface5(thisCurve, surface, curveParameters, offsetDistances, fittingTolerance, multiple=False):\n    \"\"\"\n    Offset this curve on a surface. This curve must lie on the surface.\n    This overload allows to specify different offsets for different curve parameters.\n\n    Args:\n        surface (Surface): A surface on which to offset.\n        curveParameters (double[]): Curve parameters corresponding to the offset distances.\n        offsetDistances (double[]): Distances to offset (+)left, (-)right.\n        fittingTolerance (double): A fitting tolerance.\n\n    Returns:\n        Curve[]: Offset curves on success, or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetonsurface-curve_surface_doublearray_doublearray_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, surface, curveParameters, offsetDistances, fittingTolerance]\n    if multiple: args = list(zip(thisCurve, surface, curveParameters, offsetDistances, fittingTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef PullToBrepFace1(thisCurve, face, tolerance, multiple=False):\n    \"\"\"\n    Pulls this curve to a brep face and returns the result of that operation.\n\n    Args:\n        face (BrepFace): A brep face.\n        tolerance (double): A tolerance value.\n\n    Returns:\n        Curve[]: An array containing the resulting curves after pulling. This array could be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/pulltobrepface-curve_brepface_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, face, tolerance]\n    if multiple: args = list(zip(thisCurve, face, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetNormalToSurface(thisCurve, surface, height, multiple=False):\n    \"\"\"\n    Finds a curve by offsetting an existing curve normal to a surface.\n    The caller is responsible for ensuring that the curve lies on the input surface.\n\n    Args:\n        surface (Surface): Surface from which normals are calculated.\n        height (double): offset distance (distance from surface to result curve)\n\n    Returns:\n        Curve: Offset curve at distance height from the surface.  The offset curve is\n        interpolated through a small number of points so if the surface is irregular\n        or complicated, the result will not be a very accurate offset.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetnormaltosurface-curve_surface_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, surface, height]\n    if multiple: args = list(zip(thisCurve, surface, height))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "point", "brep", "line", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "42-hirosuzu_TBDA_b8749dccd2.json", "repo": "42-hirosuzu/TBDA"}
{"instruction": "Evaluate a python script on the compute server. The script can reference an", "code": "import rhino3dm\nimport json\nimport requests\n\n__version__ = '0.12.2'\n\nurl = 'https://compute.rhino3d.com/'\nauthToken = ''\napiKey = ''\nstopat = 0\n\n\ndef ComputeFetch(endpoint, arglist):\n    class __Rhino3dmEncoder(json.JSONEncoder):\n        def default(self, o):\n            if hasattr(o, \"Encode\"):\n                return o.Encode()\n            return json.JSONEncoder.default(self, o)\n    global authToken\n    global apiKey\n    global url\n    global stopat\n    posturl = url + endpoint\n    if(stopat>0):\n        if(posturl.find('?')>0): posturl += '&stopat='\n        else: posturl += '?stopat='\n        posturl += str(stopat)\n    postdata = json.dumps(arglist, cls=__Rhino3dmEncoder)\n    headers = { 'User-Agent': 'compute.rhino3d.py/' + __version__ }\n    if authToken:\n        headers['Authorization'] = 'Bearer ' + authToken\n    if apiKey:\n        headers['RhinoComputeKey'] = apiKey\n    r = requests.post(posturl, data=postdata, headers=headers)\n    return r.json()\n\n\ndef PythonEvaluate(script, inputs, output_names):\n    \"\"\"\n    Evaluate a python script on the compute server. The script can reference an\n    `input` parameter which is passed as a dictionary. The script also has\n    access to an 'output' parameter which is returned from the server.\n\n    Args:\n        script (str): the python script to evaluate\n        inputs (dict): dictionary of data passed to the server for use by the\n                       script as an input variable\n        output_names (list): list of strings defining which variables in the\n                       script to return\n    Returns:\n        dict: The script has access to an output dict variable that it can\n              fill with values. This information is returned from the server\n              to the client.\n    \"\"\"\n    encodedInput = rhino3dm.ArchivableDictionary.EncodeDict(inputs)\n    url = 'rhino/python/evaluate'\n    args = [script, json.dumps(encodedInput), output_names]\n    response = ComputeFetch(url, args)\n    output = rhino3dm.ArchivableDictionary.DecodeDict(json.loads(response))\n    return output\n\n\ndef DecodeToCommonObject(item):\n    if item is None:\n        return None\n    if isinstance(item, list):\n        return [DecodeToCommonObject(x) for x in item]\n    return rhino3dm.CommonObject.Decode(item)\n\n\ndef DecodeToPoint3d(item):\n    if item is None:\n        return None\n    if isinstance(item, list):\n        return [DecodeToPoint3d(x) for x in item]\n    return rhino3dm.Point3d(item['X'], item['Y'], item['Z'])\n\n\ndef DecodeToVector3d(item):\n    if item is None:\n        return None\n    if isinstance(item, list):\n        return [DecodeToVector3d(x) for x in item]\n    return rhino3dm.Vector3d(item['X'], item['Y'], item['Z'])\n\n\ndef DecodeToLine(item):\n    if item is None:\n        return None\n    if isinstance(item, list):\n        return [DecodeToLine(x) for x in item]\n    start = DecodeToPoint3d(item['From'])\n    end = DecodeToPoint3d(item['To'])\n    return rhino3dm.Line(start,end)\n\n\ndef DecodeToBoundingBox(item):\n    if item is None:\n        return None\n    if isinstance(item, list):\n        return [DecodeToBoundingBox(x) for x in item]\n    return rhino3dm.BoundingBox(item['Min']['X'], item['Min']['Y'], item['Min']['Z'], item['Max']['X'], item['Max']['Y'], item['Max']['Z'])\n\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["line", "classes", "functions", "point"], "original_file": "42-hirosuzu_TBDA_e44a0833fd.json", "repo": "42-hirosuzu/TBDA"}
{"instruction": "Implement the function 'is_pt_inside' for Rhino scripting", "code": "# -*- coding:utf-8 -*-\ntry:\n    from typing import List, Tuple, Dict, Any, Optional\nexcept ImportError:\n    pass\n\nimport math\n\nimport scriptcontext as sc\nimport Rhino  # type: ignore\nimport Rhino.Geometry as geo  # type: ignore\nimport ghpythonlib.components as ghcomp\n\nimport time\n\nBIGNUM = 1000000\nOP_TOL = 0.0001\n\n\ndef is_pt_inside(region, pt, plane=geo.Plane.WorldXY, tol=OP_TOL):\n    # type: (geo.Curve, geo.Point3d, geo.Plane, float) -> int\n    # clipper  10 \n    containment = region.Contains(pt, plane, tol)\n\n    return containment == geo.PointContainment.Inside\n\n\nclass Road:\n\n    def __init__(self, centerline):\n        # type: (geo.Curve) -> None\n        self.center_crv = centerline\n        self.mid_pt = centerline.PointAtNormalizedLength(0.5)\n        self.st_pt = centerline.PointAtStart\n        self.en_pt = centerline.PointAtEnd\n\n        self.length = round(centerline.GetLength(), 2)\n\n        self.st_pt_on_topo = None  # type: geo.Point3d\n        self.st_pt_on_topo = None  # type: geo.Point3d\n        self.height = None  # type: float\n        self.road_region = None  # type: geo.Curve\n\n    def set_height(self, topo):\n        # type: (geo.Mesh) -> bool\n\n        def get_projected_pt_on_mesh(pt, mesh):\n            # type: (geo.Point3d, geo.Mesh) -> geo.Point3d | None\n            # Z   \n            ray = geo.Ray3d(pt, geo.Vector3d(0, 0, -1))  # Z  \n            t = geo.Intersect.Intersection.MeshRay(mesh, ray)\n\n            if t >= 0:\n                #  t   \n                return ray.PointAt(t)\n\n            ray = geo.Ray3d(pt, geo.Vector3d(0, 0, 1))  # Z  \n            t = geo.Intersect.Intersection.MeshRay(mesh, ray)\n\n            if t >= 0:\n                #  t   \n                return ray.PointAt(t)\n\n            return None  #    None \n\n        self.st_pt_on_topo = get_projected_pt_on_mesh(self.st_pt, topo)\n        self.en_pt_on_topo = get_projected_pt_on_mesh(self.en_pt, topo)\n\n        #         \n        if not (self.st_pt_on_topo and self.en_pt_on_topo):\n            return False\n\n        self.height = abs(self.st_pt_on_topo.Z - self.en_pt_on_topo.Z)\n        return True\n\n    @property\n    def slope_percentage(self):\n        # type: () -> float\n        if self.height is None:\n            raise Exception(\"NO HEIGHT\")\n\n        return self.height / self.length\n\n    def is_steep(self, steep_percentage):\n        # type: (float) -> bool\n\n        return self.slope_percentage > steep_percentage\n\n\nstime = time.time()\n\n# input :  topo(geo.Mesh), road_centerlines(List[geo.Curve]), road_regions(List[geo.Curve]), steep_percentage(float)\n\nroads = [Road(centerline) for centerline in road_centerlines]\n\nsteep_roads = []\nfor road in roads:\n\n    # road height \n    is_height_available = road.set_height(topo)\n    if not is_height_available:\n        continue\n\n    #   \n    if not road.is_steep(steep_percentage):\n        continue\n\n    # road  region \n    matched_region = None\n    for region in road_regions:\n        if is_pt_inside(region, road.mid_pt):\n            matched_region = region\n            road.road_region = matched_region\n            road_regions = [\n                region for region in road_regions if region is not matched_region\n            ]\n            break\n\n    steep_roads.append(road.road_region)\n\noutput = (\n    \"Total Roads = \"\n    + str(len(roads))\n    + \"\\n\"\n    + \"Steep Roads = \"\n    + str(len(steep_roads))\n    + \"\\n\"\n    + str(round(len(steep_roads) / len(roads) * 100, 2))\n    + \"% of road is steep\"\n    + \"\\n\"\n)\n\netime = time.time()\n\nprint(\"TIME\", etime - stime)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "line", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "969flash_EDDM_slope_analysis_5bc02cefb3.json", "repo": "969flash/EDDM_slope_analysis"}
{"instruction": "Implement the function 'convert_io_to_list' for Rhino scripting", "code": "# -*- coding:utf-8 -*-\ntry:\n    from typing import List, Tuple, Dict, Any, Optional, Union\nexcept ImportError:\n    pass\nimport functools\n\nimport Rhino\nimport Rhino.Geometry as geo  # ignore\nimport ghpythonlib.components as ghcomp  # ignore\n\nBIGNUM = 10000000\n\nTOL = 0.001\nDIST_TOL = 0.01\nAREA_TOL = 0.1\nOP_TOL = 0.00001\nCLIPPER_TOL = 0.0000000001\n\n\ndef convert_io_to_list(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        new_args = []\n        for arg in args:\n            if isinstance(arg, geo.Curve):\n                arg = [arg]\n            new_args.append(arg)\n\n        result = func(*new_args, **kwargs)\n        if isinstance(result, geo.Curve):\n            result = [result]\n\n        if hasattr(result, \"__dict__\"):\n            for key, values in result.__dict__.items():\n                if isinstance(values, geo.Curve):\n                    setattr(result, key, [values])\n        return result\n\n    return wrapper\n\n\nclass Offset:\n    class _PolylineOffsetResult:\n        def __init__(self):\n            self.contour: Optional[List[geo.Curve]] = None\n            self.holes: Optional[List[geo.Curve]] = None\n\n    @convert_io_to_list\n    def polyline_offset(\n        self,\n        crvs: List[geo.Curve],\n        dists: List[float],\n        miter: int = BIGNUM,\n        closed_fillet: int = 2,\n        open_fillet: int = 2,\n        tol: float = Rhino.RhinoMath.ZeroTolerance,\n    ) -> _PolylineOffsetResult:\n        \"\"\"\n        Args:\n            crv (_type_): _description_\n            dists (_type_): _description_\n            miter : miter\n            closed_fillet : 0 = round, 1 = square, 2 = miter\n            open_fillet : 0 = round, 1 = square, 2 = butt\n\n        Returns:\n            _type_: _PolylineOffsetResult\n        \"\"\"\n        if not crvs:\n            raise ValueError(\"No Curves to offset\")\n\n        plane = geo.Plane(geo.Point3d(0, 0, crvs[0].PointAtEnd.Z), geo.Vector3d.ZAxis)\n        result = ghcomp.ClipperComponents.PolylineOffset(\n            crvs,\n            dists,\n            plane,\n            tol,\n            closed_fillet,\n            open_fillet,\n            miter,\n        )\n\n        polyline_offset_result = Offset._PolylineOffsetResult()\n        for name in (\"contour\", \"holes\"):\n            setattr(polyline_offset_result, name, result[name])\n        return polyline_offset_result\n\n\ndef get_overlap_crv(crv_a: geo.Curve, crv_b: geo.Curve) -> List[geo.Curve]:\n    \"\"\"    .\n    Args:\n        crv_a : crv_b    \n        crv_b : crv_a   \n\n    Returns:\n        crv_a  crv_b   \n    \"\"\"\n    #       .\n    if not geo.Curve.PlanarCurveCollision(crv_a, crv_b, geo.Plane.WorldXY, TOL):\n        return []\n\n    # crv_a crv_b  + crv_a  crv_a .\n    pts_to_split = (\n        ghcomp.Explode(crv_a, True).vertices + ghcomp.CurveXCurve(crv_a, crv_b).points\n    )\n    if not pts_to_split:\n        return []\n\n    parameters = [ghcomp.CurveClosestPoint(pt, crv_a).parameter for pt in pts_to_split]\n\n    segments = ghcomp.Shatter(crv_a, parameters)\n\n    overlaped_segments = [\n        seg\n        for seg in segments\n        if geo.Curve.PlanarCurveCollision(seg, crv_b, geo.Plane.WorldXY, TOL)\n    ]\n\n    if not overlaped_segments:\n        return []\n\n    return geo.Curve.JoinCurves(overlaped_segments)\n\n\ndef get_overlap_length(crv_a: geo.Curve, crv_b: geo.Curve) -> float:\n    \"\"\"    .\n    Args:\n        crv_a : crv_b    \n        crv_b : crv_a   \n\n    Returns:\n        crv_a  crv_b   \n    \"\"\"\n    overlap_crvs = get_overlap_crv(crv_a, crv_b)\n    if not overlap_crvs:\n        return 0.0\n\n    length = 0.0\n    for crv in overlap_crvs:\n        length += crv.GetLength()\n    return length\n\n\ndef is_intersection_with_other_crvs(crv: geo.Curve, crvs: List[geo.Curve]) -> bool:\n    return any(\n        geo.Curve.PlanarCurveCollision(crv, other_crv, geo.Plane.WorldXY, OP_TOL)\n        for other_crv in crvs\n    )\n\n\ndef has_region_intersection(\n    region: geo.Curve, other_region: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"      .\n    Args:\n        region:  \n        other_regions:    \n        tol: tolerance\n\n    Returns:\n        bool:  \n    \"\"\"\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        region, other_region, geo.Plane.WorldXY, tol\n    )\n    #    .   .\n    if relationship == geo.RegionContainment.Disjoint:\n        return False\n    return True\n\n\ndef offset_regions_inward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n\n    Returns:\n        offset  \n    \"\"\"\n\n    if not dist:\n        return regions\n    return Offset().polyline_offset(regions, dist, miter).holes\n\n\ndef offset_regions_outward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n    returns:\n        offset  \n    \"\"\"\n    if isinstance(regions, geo.Curve):\n        regions = [regions]\n\n    return [offset_region_outward(region, dist, miter) for region in regions]\n\n\ndef offset_region_outward(\n    region: geo.Curve, dist: float, miter: float = BIGNUM\n) -> geo.Curve:\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n\n    Returns:\n        offset  \n    \"\"\"\n\n    if not dist:\n        return region\n    if not isinstance(region, geo.Curve):\n        raise ValueError(\"region must be curve\")\n    return Offset().polyline_offset(region, dist, miter).contour[0]\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "line", "curve", "functions", "RhinoCommon"], "original_file": "969flash_FindSimilarLot_04d2c95184.json", "repo": "969flash/FindSimilarLot"}
{"instruction": " Curve   , offset     ", "code": "# -*- coding:utf-8 -*-\ntry:\n    from typing import List, Tuple, Dict, Optional\nexcept ImportError:\n    pass\n\nimport functools\nimport Rhino.Geometry as geo  # ignore\nimport ghpythonlib.components as ghcomp  # ignore\nfrom tqdm import tqdm\n\nimport utils\n\n#  \nimport importlib\n\nimportlib.reload(utils)\n\nBIGNUM = 100000\n\n\nclass Lot:\n    def __init__(self, crv: geo.Curve, record: List[str]):\n        self.crv = crv\n        self.record = record\n        result = geo.AreaMassProperties.Compute(crv)\n        self.area = result.Area\n        self.centroid = result.Centroid\n\n    def __repr__(self):\n        return f\"Lot(area={self.area})\"\n\n    def __lt__(self, other):\n        return self.area < other.area\n\n    def __eq__(self, other):\n        return self.area == other.area\n\n\ndef is_similar(base: Lot, other: Lot, tol: float = 0.2):\n    \"\"\"\n     Curve   , offset     \n    \"\"\"\n\n    # 1.    (other base  )\n    move_vector = geo.Vector3d(base.centroid - other.centroid)\n    aligned_other = other.crv.DuplicateCurve()\n    aligned_other.Translate(move_vector)\n\n    # 2. base offset \n    offset_result = utils.Offset().polyline_offset(base.crv, tol, BIGNUM)\n    if not offset_result.holes or not offset_result.contour:\n        return False\n\n    offset_bases = [offset_result.holes[0], offset_result.contour[0]]\n\n    # 3.  offset   other  \n    intersects = any(\n        geo.Curve.PlanarCurveCollision(\n            offset_base, aligned_other, geo.Plane.WorldXY, 0.01\n        )\n        for offset_base in offset_bases\n    )\n\n    return not intersects  #    \n\n\ndef find_all_groups(lots: List[Lot]) -> List[List[Lot]]:\n    visited = set()\n    groups = []\n\n    for i, base in tqdm(enumerate(lots), total=len(lots), desc=\"  \"):\n        if i in visited:\n            continue\n\n        group = [base]\n        visited.add(i)\n\n        for j, other in enumerate(lots):\n            if j == i or j in visited:\n                continue\n            try:\n                if utils.is_similar(base, other):\n                    print(f\"[find_all_groups] {i} {j}   \")\n                    group.append(other)\n                    visited.add(j)\n            except Exception as e:\n                print(f\"[find_all_groups ] {i}-{j}   : {e}\")\n\n        groups.append(group)\n\n    return groups\n\n\ndef cluster_lots_by_area(\n    lots: List[Lot], bin_size: int\n) -> Dict[Tuple[int, int], List[Lot]]:\n\n    clusters = {}\n    for idx, lot in enumerate(lots):\n        bin_idx = int(lot.area // bin_size)\n        start = bin_idx * bin_size\n        end = start + bin_size\n        key = (start, end)\n        clusters.setdefault(key, []).append(lots[idx])\n\n    return clusters\n\n\n# ---   ---\n# lot_crvs: Rhino.Geometry.Curve     \nlots = [Lot(curve, record) for curve, record in zip(lot_crvs, records)]\n\nclusters = cluster_lots_by_area(lots, bin_size=5)\n\n#  10  \ntop_clusters = sorted(clusters.items(), key=lambda x: len(x[1]), reverse=True)[:10]\nfor i, (key, lot_list) in enumerate(top_clusters, 1):\n    print(f\"{i}.  {key}: {len(lot_list)} \")\n\n#      \ntarget_cluster = top_clusters[0][1]\nresult = find_all_groups(target_cluster)\n\n#     \nlargest_group = max(result, key=lambda g: len(g))\nprint(f\"\\n   : {len(largest_group)} \")\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "line", "curve", "functions", "RhinoCommon"], "original_file": "969flash_FindSimilarLot_5bc02cefb3.json", "repo": "969flash/FindSimilarLot"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "# r: pyshp\n\nimport shapefile\nimport os\nfrom typing import List, Tuple, Any, Optional, Union\nimport ghpythonlib.components as ghcomp\nimport Rhino.Geometry as geo\nimport math\n\nTOL = 0.001  #   \nRAW_TOL = 0.1  #    \n\n\nclass Parcel:\n    \"\"\"  \"\"\"\n\n    def __init__(\n        self,\n        region: geo.Curve,\n        pnu: str,\n        jimok: str,\n        record: List[Any],\n        hole_regions: List[geo.Curve],\n    ):\n        self.region = region  #   \n        self.hole_regions = (\n            hole_regions if hole_regions is not None else []\n        )  #  \n        self.pnu = pnu\n        self.jimok = jimok\n        self.record = record\n        self._area = None\n\n    @property\n    def area(self) -> float:\n        \"\"\"  \"\"\"\n        if self._area is None:\n            outer_area = get_area(self.region)\n            hole_area = get_area(self.hole_regions) if self.hole_regions else 0.0\n            self._area = outer_area - hole_area\n        return self._area\n\n    def preprocess_curve(self) -> bool:\n        \"\"\"  (invalid ,  , )\"\"\"\n        if not self.region or not self.region.IsValid:\n            return False\n\n        #  \n        intersection_events = geo.Intersect.Intersection.CurveSelf(self.region, TOL)\n        if intersection_events:\n            simplified = self.region.Simplify(\n                geo.CurveSimplifyOptions.All, RAW_TOL, 1.0\n            )\n            if simplified:\n                self.region = simplified\n            else:\n                return False\n\n        #  \n        simplified = self.region.Simplify(geo.CurveSimplifyOptions.All, RAW_TOL, 1.0)\n        if simplified:\n            self.region = simplified\n\n        #   \n        valid_holes = []\n        for hole in self.hole_regions:\n            if hole and hole.IsValid:\n                simplified_hole = hole.Simplify(\n                    geo.CurveSimplifyOptions.All, RAW_TOL, 1.0\n                )\n                if simplified_hole:\n                    valid_holes.append(simplified_hole)\n                else:\n                    valid_holes.append(hole)\n        self.hole_regions = valid_holes\n\n        return True\n\n\nclass Road(Parcel):\n    \"\"\" \"\"\"\n\n    pass\n\n\nclass Lot(Parcel):\n    \"\"\" \"\"\"\n\n    def __init__(\n        self,\n        curve_crv: geo.Curve,\n        pnu: str,\n        jimok: str,\n        record: List[Any],\n        hole_regions: List[geo.Curve] = None,\n    ):\n        super().__init__(curve_crv, pnu, jimok, record, hole_regions)\n        self.is_flag_lot = False  #   \n        self.has_road_access = False  #   \n\n\ndef read_shp_file(file_path: str) -> Tuple[List[Any], List[Any], List[str]]:\n    \"\"\"shapefile  shapes records \"\"\"\n    try:\n        sf = shapefile.Reader(file_path, encoding=\"utf-8\")\n    except:\n        try:\n            sf = shapefile.Reader(file_path, encoding=\"cp949\")\n        except:\n            sf = shapefile.Reader(file_path)\n\n    shapes = sf.shapes()\n    records = sf.records()\n    fields = [field[0] for field in sf.fields[1:]]\n    return shapes, records, fields\n\n\ndef get_curve_from_points(\n    points: List[Tuple[float, float]], start_idx: int, end_idx: int\n) -> Optional[geo.PolylineCurve]:\n    \"\"\"     \"\"\"\n    #  3  \n    if end_idx - start_idx < 3:\n        return None\n\n    #     ( ) None \n    first_pt = points[start_idx]\n    last_pt = points[end_idx - 1]\n    if first_pt[0] != last_pt[0] or first_pt[1] != last_pt[1]:\n        return None\n\n    curve_points = [\n        geo.Point3d(points[i][0], points[i][1], 0) for i in range(start_idx, end_idx)\n    ]\n\n    curve_crv = geo.PolylineCurve(curve_points)\n    return curve_crv if curve_crv and curve_crv.IsValid else None\n\n\ndef get_part_indices(shape: Any) -> List[Tuple[int, int]]:\n    \"\"\"shape      \"\"\"\n    if not hasattr(shape, \"parts\") or len(shape.parts) <= 1:\n        return [(0, len(shape.points))]\n\n    parts = list(shape.parts) + [len(shape.points)]\n    return [(parts[i], parts[i + 1]) for i in range(len(shape.parts))]\n\n\ndef get_intersection_points(\n    curve_a: geo.Curve, curve_b: geo.Curve, tol: float = TOL\n) -> List[geo.Point3d]:\n    \"\"\"    .\"\"\"\n    intersections = geo.Intersect.Intersection.CurveCurve(curve_a, curve_b, tol, tol)\n    if not intersections:\n        return []\n    return [event.PointA for event in intersections]\n\n\ndef get_vertices(curve: geo.Curve) -> List[geo.Point3d]:\n    \"\"\"  (Vertex) .\"\"\"\n    if not curve:\n        return []\n    vertices = [curve.PointAt(curve.SpanDomain(i)[0]) for i in range(curve.SpanCount)]\n    if not curve.IsClosed:\n        vertices.append(curve.PointAtEnd)\n    return vertices\n\n\ndef is_pt_on_crv(pt: geo.Point3d, crv: geo.Curve, tol=TOL):\n    \"\"\"pt crv   \"\"\"\n    rc, param = crv.ClosestPoint(pt, tol)\n    if not rc:\n        return False\n\n    closest_pt = crv.PointAt(param)\n    if closest_pt.DistanceTo(pt) <= tol:\n        return True\n\n    return False\n\n\ndef is_seg_on_crv(seg: geo.Curve, crv: geo.Curve, tol=TOL):\n    \"\"\"seg crv   \"\"\"\n    # seg    crv   .\n    for pt in (seg.PointAtStart, seg.PointAtEnd):\n        if not is_pt_on_crv(pt, crv, tol):\n            return False\n\n    pt_mid = seg.PointAtNormalizedLength(0.5)\n    if not is_pt_on_crv(pt_mid, crv, tol):\n        return False\n\n    return True\n\n\ndef get_overlapped_curves(\n    curve_a: geo.Curve, curve_b: geo.Curve, tol: float = TOL\n) -> List[geo.Curve]:\n    \"\"\"     .\"\"\"\n    intersection_points = get_intersection_points(curve_a, curve_b)\n    if not intersection_points:\n        return []\n\n    params = [curve_a.SpanDomain(i)[0] for i in range(curve_a.SpanCount)]\n    params += [curve_a.ClosestPoint(pt, tol)[1] for pt in intersection_points]\n    shatter_result = ghcomp.Shatter(curve_a, params)\n\n    if not shatter_result:\n        return []\n\n    overlapped_segments = [seg for seg in shatter_result if is_seg_on_crv(seg, curve_b)]\n    if not overlapped_segments:\n        return []\n\n    return geo.Curve.JoinCurves(overlapped_segments)\n\n\ndef get_overlapped_length(curve_a: geo.Curve, curve_b: geo.Curve) -> float:\n    \"\"\"     .\"\"\"\n    overlapped_curves = get_overlapped_curves(curve_a, curve_b)\n    if not overlapped_curves:\n        return 0.0\n    return sum(crv.GetLength() for crv in overlapped_curves)\n\n\ndef get_curves_from_shape(\n    shape: Any,\n) -> Tuple[Optional[geo.PolylineCurve], List[geo.PolylineCurve]]:\n    \"\"\"shape      \"\"\"\n    boundary_region = None\n    hole_regions = []\n\n    part_indices = get_part_indices(shape)\n\n    for i, (start_idx, end_idx) in enumerate(part_indices):\n        curve_crv = get_curve_from_points(shape.points, start_idx, end_idx)\n        if curve_crv:\n            if i == 0:\n                boundary_region = curve_crv\n            else:\n                hole_regions.append(curve_crv)\n\n    #      \n    if boundary_region is None and len(part_indices) == 1:\n        points = [geo.Point3d(pt[0], pt[1], 0) for pt in shape.points]\n        if len(points) >= 3:\n            if points[0].DistanceTo(points[-1]) > TOL:\n                points.append(points[0])\n            curve_crv = geo.PolylineCurve(points)\n            if curve_crv and curve_crv.IsValid:\n                boundary_region = curve_crv\n\n    return boundary_region, hole_regions\n\n\ndef get_field_value(\n    record: List[Any], fields: List[str], field_name: str, default: str = \"Unknown\"\n) -> str:\n    \"\"\"    \"\"\"\n    try:\n        index = fields.index(field_name)\n        return record[index]\n    except (ValueError, IndexError):\n        return default\n\n\ndef create_parcel_from_shape(\n    shape: Any, record: List[Any], fields: List[str]\n) -> Optional[Parcel]:\n    \"\"\"shape Parcel  \"\"\"\n    boundary_region, hole_regions = get_curves_from_shape(shape)\n\n    if not boundary_region or not boundary_region.IsValid:\n        return None\n\n    pnu = get_field_value(record, fields, \"A1\")  #  PNU\n    jimok = get_field_value(record, fields, \"A11\")  #  JIMOK\n\n    if jimok == \"\":\n        parcel = Road(boundary_region, pnu, jimok, record, hole_regions)\n    else:\n        parcel = Lot(boundary_region, pnu, jimok, record, hole_regions)\n\n    return parcel if parcel.preprocess_curve() else None\n\n\ndef has_intersection(\n    curve_a: geo.Curve,\n    curve_b: geo.Curve,\n    plane: geo.Plane = geo.Plane.WorldXY,\n    tol: float = TOL,\n) -> bool:\n    \"\"\"    .\"\"\"\n    return geo.Curve.PlanarCurveCollision(curve_a, curve_b, plane, tol)\n\n\ndef get_parcels_from_shapes(\n    shapes: List[Any], records: List[Any], fields: List[str]\n) -> List[Parcel]:\n    \"\"\" shape Parcel  \"\"\"\n    parcels = []\n\n    for shape, record in zip(shapes, records):\n        parcel = create_parcel_from_shape(shape, record, fields)\n        if parcel:\n            parcels.append(parcel)\n\n    return parcels\n\n\ndef classify_parcels(parcels: List[Parcel]) -> Tuple[List[Lot], List[Road]]:\n    \"\"\"Parcel  Lot Road \"\"\"\n    lots = []\n    roads = []\n\n    for parcel in parcels:\n        if isinstance(parcel, Road):\n            roads.append(parcel)\n        else:\n            lots.append(parcel)\n\n    return lots, roads\n\n\ndef get_area(regions: Union[List[geo.Curve], geo.Curve]) -> float:\n    \"\"\"   .\"\"\"\n    if not isinstance(regions, list):\n        regions = [regions]\n\n    area = sum([geo.AreaMassProperties.Compute(r).Area for r in regions])\n    return round(area, 6)\n\n\ndef get_straight_skeleton(region_curve):\n    \"\"\"\n         \n    \"\"\"\n    # 1.    \n    if not region_curve.IsClosed:\n        return None\n\n    polyline = None\n    if isinstance(region_curve, geo.PolylineCurve):\n        polyline = region_curve.ToPolyline()\n    else:\n        #    \n        polyline_curve = region_curve.ToPolyline(0, 0, 0.1, 0.1, 0.1, 0, 0, 0, True)\n        polyline = polyline_curve.ToPolyline()\n\n    points = list(polyline)\n    if points[0].DistanceTo(points[-1]) < 0.001:\n        points.pop()  #   \n\n    n = len(points)\n    skeleton_lines = []\n\n    # 2.   (Bisector)  \n    bisectors = []\n    for i in range(n):\n        p_prev = points[(i - 1 + n) % n]\n        p_curr = points[i]\n        p_next = points[(i + 1) % n]\n\n        v1 = p_prev - p_curr\n        v2 = p_next - p_curr\n        v1.Unitize()\n        v2.Unitize()\n\n        #      \n        bisect_vec = v1 + v2\n\n        #    \n        if bisect_vec.Length < 1e-6:\n            bisect_vec = geo.Vector3d(-v1.Y, v1.X, 0)\n        else:\n            bisect_vec.Unitize()\n\n        #    (Cross Product )\n        cross = geo.Vector3d.CrossProduct(v1, v2)\n        if cross.Z > 0:  # /      \n            bisect_vec *= -1\n\n        bisectors.append(bisect_vec)\n\n    # 3.      (Event Simulation)\n    #          \n    new_points = []\n    for i in range(n):\n        line1 = geo.Line(points[i], points[i] + bisectors[i] * 1000)\n        next_idx = (i + 1) % n\n        line2 = geo.Line(\n            points[next_idx], points[next_idx] + bisectors[next_idx] * 1000\n        )\n\n        rc, a, b = geo.Intersect.Intersection.LineLine(line1, line2)\n        if rc:\n            intersect_pt = line1.PointAt(a)\n            #       \n            skeleton_lines.append(geo.LineCurve(points[i], intersect_pt))\n            skeleton_lines.append(geo.LineCurve(points[next_idx], intersect_pt))\n            new_points.append(intersect_pt)\n\n    # 4.     \n    for i in range(len(new_points)):\n        p1 = new_points[i]\n        p2 = new_points[(i + 1) % len(new_points)]\n        if p1.DistanceTo(p2) > 0.001:\n            skeleton_lines.append(geo.LineCurve(p1, p2))\n\n    return geo.Curve.JoinCurves(skeleton_lines)\n\n\n#  \n# skeleton = get_straight_skeleton(input_region)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "line", "curve", "functions", "RhinoCommon"], "original_file": "969flash_HeightLimitCalculation_e4e95f0c86.json", "repo": "969flash/HeightLimitCalculation"}
{"instruction": "    .", "code": "# -*- coding:utf-8 -*-\ntry:\n    from typing import List, Tuple, Dict, Any, Optional, Union\nexcept ImportError:\n    pass\nimport functools\n\nimport Rhino\nimport Rhino.Geometry as geo  # ignore\nimport ghpythonlib.components as ghcomp  # ignore\n\nBIGNUM = 10000000\n\nTOL = 0.001\nDIST_TOL = 0.01\nAREA_TOL = 0.1\nOP_TOL = 0.00001\nCLIPPER_TOL = 0.0000000001\n\n\ndef get_overlap_crv(crv_a: geo.Curve, crv_b: geo.Curve) -> List[geo.Curve]:\n    \"\"\"    .\n    Args:\n        crv_a : crv_b    \n        crv_b : crv_a   \n\n    Returns:\n        crv_a  crv_b   \n    \"\"\"\n    #       .\n    if not geo.Curve.PlanarCurveCollision(crv_a, crv_b, geo.Plane.WorldXY, TOL):\n        return []\n\n    # crv_a crv_b  + crv_a  crv_a .\n    pts_to_split = (\n        ghcomp.Explode(crv_a, True).vertices + ghcomp.CurveXCurve(crv_a, crv_b).points\n    )\n    if not pts_to_split:\n        return []\n\n    parameters = [ghcomp.CurveClosestPoint(pt, crv_a).parameter for pt in pts_to_split]\n\n    segments = ghcomp.Shatter(crv_a, parameters)\n\n    overlaped_segments = [\n        seg\n        for seg in segments\n        if geo.Curve.PlanarCurveCollision(seg, crv_b, geo.Plane.WorldXY, TOL)\n    ]\n\n    if not overlaped_segments:\n        return []\n\n    return geo.Curve.JoinCurves(overlaped_segments)\n\n\ndef get_overlap_length(crv_a: geo.Curve, crv_b: geo.Curve) -> float:\n    \"\"\"    .\n    Args:\n        crv_a : crv_b    \n        crv_b : crv_a   \n\n    Returns:\n        crv_a  crv_b   \n    \"\"\"\n    overlap_crvs = get_overlap_crv(crv_a, crv_b)\n    if not overlap_crvs:\n        return 0.0\n\n    length = 0.0\n    for crv in overlap_crvs:\n        length += crv.GetLength()\n    return length\n\n\ndef is_intersection_with_other_crvs(crv: geo.Curve, crvs: List[geo.Curve]) -> bool:\n    return any(\n        geo.Curve.PlanarCurveCollision(crv, other_crv, geo.Plane.WorldXY, OP_TOL)\n        for other_crv in crvs\n    )\n\n\ndef has_region_intersection(\n    region: geo.Curve, other_region: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"      .\n    Args:\n        region:  \n        other_regions:    \n        tol: tolerance\n\n    Returns:\n        bool:  \n    \"\"\"\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        region, other_region, geo.Plane.WorldXY, tol\n    )\n    #    .   .\n    if relationship == geo.RegionContainment.Disjoint:\n        return False\n    return True\n\n\ndef offset_regions_inward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n\n    Returns:\n        offset  \n    \"\"\"\n\n    if not dist:\n        return regions\n    return Offset().polyline_offset(regions, dist, miter).holes\n\n\ndef offset_regions_outward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n    returns:\n        offset  \n    \"\"\"\n    if isinstance(regions, geo.Curve):\n        regions = [regions]\n\n    return [offset_region_outward(region, dist, miter) for region in regions]\n\n\ndef offset_region_outward(\n    region: geo.Curve, dist: float, miter: float = BIGNUM\n) -> geo.Curve:\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n\n    Returns:\n        offset  \n    \"\"\"\n\n    if not dist:\n        return region\n    if not isinstance(region, geo.Curve):\n        raise ValueError(\"region must be curve\")\n    return Offset().polyline_offset(region, dist, miter).contour[0]\n\n\ndef convert_io_to_list(func):\n    \"\"\"    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        new_args = []\n        for arg in args:\n            if isinstance(arg, geo.Curve):\n                arg = [arg]\n            new_args.append(arg)\n\n        result = func(*new_args, **kwargs)\n        if isinstance(result, geo.Curve):\n            result = [result]\n\n        if hasattr(result, \"__dict__\"):\n            for key, values in result.__dict__.items():\n                if isinstance(values, geo.Curve):\n                    setattr(result, key, [values])\n        return result\n\n    return wrapper\n\n\nclass Offset:\n    class _PolylineOffsetResult:\n        def __init__(self):\n            self.contour: Optional[List[geo.Curve]] = None\n            self.holes: Optional[List[geo.Curve]] = None\n\n    @convert_io_to_list\n    def polyline_offset(\n        self,\n        crvs: List[geo.Curve],\n        dists: List[float],\n        miter: int = BIGNUM,\n        closed_fillet: int = 2,\n        open_fillet: int = 2,\n        tol: float = Rhino.RhinoMath.ZeroTolerance,\n    ) -> _PolylineOffsetResult:\n        \"\"\"\n        Args:\n            crv (_type_): _description_\n            dists (_type_): _description_\n            miter : miter\n            closed_fillet : 0 = round, 1 = square, 2 = miter\n            open_fillet : 0 = round, 1 = square, 2 = butt\n\n        Returns:\n            _type_: _PolylineOffsetResult\n        \"\"\"\n        if not crvs:\n            raise ValueError(\"No Curves to offset\")\n\n        plane = geo.Plane(geo.Point3d(0, 0, crvs[0].PointAtEnd.Z), geo.Vector3d.ZAxis)\n        result = ghcomp.ClipperComponents.PolylineOffset(\n            crvs,\n            dists,\n            plane,\n            tol,\n            closed_fillet,\n            open_fillet,\n            miter,\n        )\n\n        polyline_offset_result = Offset._PolylineOffsetResult()\n        for name in (\"contour\", \"holes\"):\n            setattr(polyline_offset_result, name, result[name])\n        return polyline_offset_result\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "line", "curve", "functions", "RhinoCommon"], "original_file": "969flash_LausLecture_5248d258b6.json", "repo": "969flash/LausLecture"}
{"instruction": "    ", "code": "from typing import List, Tuple, Any, Optional, Union\nimport Rhino.Geometry as geo\nimport Rhino\nimport functools\n\nimport ghpythonlib.components as ghcomp\n\nTOL = 0.01  #   \nDIST_TOL = 0.01\nAREA_TOL = 0.1\nOP_TOL = 0.00001\nCLIPPER_TOL = 0.0000000001\nBIGNUM = 100000\nROUNDING_PRECISION = 6  #   \n\n\ndef get_dist_between_pts(\n    pt_a: geo.Point3d, pt_b: geo.Point3d, rounding_precision=ROUNDING_PRECISION\n):\n    \"\"\"\n        \n    :param pt_a: Rhino.Geometry.Point3d \n    :param pt_b: Rhino.Geometry.Point3d \n    :param rounding_precision:    \n    :return:  (float)\n    \"\"\"\n    return round(pt_a.DistanceTo(pt_b), rounding_precision)\n\n\ndef has_intersection(\n    crv_a: geo.Curve, crv_b: geo.Curve, plane=geo.Plane.WorldXY, tol=TOL\n):\n    \"\"\"\n        \n    :param curve_a: Rhino.Geometry.Curve \n    :param curve_b: Rhino.Geometry.Curve \n    :return:   (bool)\n    \"\"\"\n    return geo.Curve.PlanarCurveCollision(crv_a, crv_b, plane, tol)\n\n\n##    \ndef get_intersection_from_crvs(crv_a: geo.Curve, crv_b: geo.Curve, tol=TOL):\n    \"\"\"\n        \n    :param curve_a: Rhino.Geometry.Curve \n    :param curve_b: Rhino.Geometry.Curve \n    :param tol:  \n    :return:   (list of Point3d)\n    \"\"\"\n    intersections = geo.Intersect.Intersection.CurveCurve(crv_a, crv_b, tol, tol)\n\n    #      \n    if not intersections:\n        return []\n\n    return [pt.PointA for pt in intersections if pt.IsPointAValid]\n\n\n##    \ndef get_dist_between_crvs(\n    crv_a: geo.Curve, crv_b: geo.Curve, rounding_precision=ROUNDING_PRECISION\n):\n    \"\"\"\n         \n    :param curve_a: Rhino.Geometry.Curve \n    :param curve_b: Rhino.Geometry.Curve \n    :param rounding_precision:    \n    :return:   (float)\n    \"\"\"\n    _, a, b = crv_a.ClosestPoints(crv_b)\n    dist = a.DistanceTo(b)\n    return round(dist, rounding_precision)\n\n\ndef explode_curve(crv: geo.Curve) -> List[geo.Curve]:\n    \"\"\"\n        .\n    :param curve: Rhino.Geometry.Curve \n    :return:    (list of Curve)\n    \"\"\"\n    if not crv:\n        return []\n\n    # span 1    .\n    if crv.SpanCount == 1:\n        return [crv]\n\n    segments = []\n    for i in range(crv.SpanCount):\n        param_start, param_end = crv.SpanDomain(i)\n        pt_seg_start = crv.PointAt(param_start)\n        pt_seg_end = crv.PointAt(param_end)\n        segments.append(geo.LineCurve(pt_seg_start, pt_seg_end))\n\n    return segments\n\n\ndef has_region_intersection(\n    region: geo.Curve, other_region: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"      .\n    Args:\n        region:  \n        other_regions:    \n        tol: tolerance\n\n    Returns:\n        bool:  \n    \"\"\"\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        region, other_region, geo.Plane.WorldXY, tol\n    )\n    #    .   .\n    if relationship == geo.RegionContainment.Disjoint:\n        return False\n    return True\n\n\ndef get_dist_between_pt_and_crv(\n    pt: geo.Point3d, crv: geo.Curve, rounding_precision=ROUNDING_PRECISION\n) -> float:\n    \"\"\"\n         \n    :param pt: Rhino.Geometry.Point3d \n    :param crv: Rhino.Geometry.Curve \n    :param rounding_precision:    \n    :return:  (float)\n    \"\"\"\n    dist = pt.DistanceTo(crv.PointAt(crv.ClosestPoint(pt)[1]))\n    dist = round(dist, rounding_precision)\n    return dist\n\n\ndef is_region_inside_region(\n    region: geo.Curve, other_region: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"       .\n    Args:\n        region:  \n        other_region:   \n        tol: tolerance\n    Returns:\n        bool:  \n    \"\"\"\n\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        region, other_region, geo.Plane.WorldXY, tol\n    )\n    # region other_region   \n    if relationship == geo.RegionContainment.AInsideB:\n        return True\n    return False\n\n\ndef offset_regions_inward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n\n    Returns:\n        offset  \n    \"\"\"\n\n    if not dist:\n        return regions\n    return Offset().polyline_offset(regions, dist, miter).holes\n\n\ndef offset_regions_outward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n    returns:\n        offset  \n    \"\"\"\n    if isinstance(regions, geo.Curve):\n        regions = [regions]\n\n    return [offset_region_outward(region, dist, miter) for region in regions]\n\n\ndef offset_region_outward(\n    region: geo.Curve, dist: float, miter: float = BIGNUM\n) -> geo.Curve:\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n\n    Returns:\n        offset  \n    \"\"\"\n\n    if not dist:\n        return region\n    if not isinstance(region, geo.Curve):\n        raise ValueError(\"region must be curve\")\n    return Offset().polyline_offset(region, dist, miter).contour[0]\n\n\ndef get_outside_perp_vec_from_pt(pt: geo.Point3d, region: geo.Curve) -> geo.Vector3d:\n    _, param = region.ClosestPoint(pt)\n    vec_perp_outer = region.PerpendicularFrameAt(param)[1].XAxis\n\n    if region.ClosedCurveOrientation() != geo.CurveOrientation.Clockwise:\n        vec_perp_outer = -vec_perp_outer\n\n    return vec_perp_outer\n\n\ndef get_pt_by_length(\n    crv: geo.Curve, length: float, include_start: bool = False\n) -> List[geo.Point3d]:\n    \"\"\"     .\"\"\"\n    params = crv.DivideByLength(length, include_start)\n\n    # crv length  \n    if not params:\n        return []\n\n    return [crv.PointAt(param) for param in params]\n\n\ndef move_curve(crv: geo.Curve, vec: geo.Vector3d):\n    \"\"\"   .\"\"\"\n    moved_crv = crv.Duplicate()\n    moved_crv.Translate(vec)\n    return moved_crv\n\n\ndef get_bounding_box_crv(curve: geo.Curve, plane: geo.Plane) -> geo.PolylineCurve:\n    \"\"\"    .\"\"\"\n    bbox = curve.GetBoundingBox(plane)\n\n    corners = list(bbox.GetCorners())[:4]  # type: List[geo.Point3d]\n    for corner in corners:\n        corner.Transform(geo.Transform.ChangeBasis(plane, geo.Plane.WorldXY))\n\n    return geo.PolylineCurve(corners + [corners[0]])\n\n\ndef convert_io_to_list(func):\n    \"\"\"    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        new_args = []\n        for arg in args:\n            if isinstance(arg, geo.Curve):\n                arg = [arg]\n            new_args.append(arg)\n\n        result = func(*new_args, **kwargs)\n        if isinstance(result, geo.Curve):\n            result = [result]\n\n        if hasattr(result, \"__dict__\"):\n            for key, values in result.__dict__.items():\n                if isinstance(values, geo.Curve):\n                    setattr(result, key, [values])\n        return result\n\n    return wrapper\n\n\nclass Offset:\n    class _PolylineOffsetResult:\n        def __init__(self):\n            self.contour: Optional[List[geo.Curve]] = None\n            self.holes: Optional[List[geo.Curve]] = None\n\n    @convert_io_to_list\n    def polyline_offset(\n        self,\n        crvs: List[geo.Curve],\n        dists: List[float],\n        miter: int = BIGNUM,\n        closed_fillet: int = 2,\n        open_fillet: int = 2,\n        tol: float = Rhino.RhinoMath.ZeroTolerance,\n    ) -> _PolylineOffsetResult:\n        \"\"\"\n        Args:\n            crv (_type_): _description_\n            dists (_type_): _description_\n            miter : miter\n            closed_fillet : 0 = round, 1 = square, 2 = miter\n            open_fillet : 0 = round, 1 = square, 2 = butt\n\n        Returns:\n            _type_: _PolylineOffsetResult\n        \"\"\"\n        if not crvs:\n            raise ValueError(\"No Curves to offset\")\n\n        plane = geo.Plane(geo.Point3d(0, 0, crvs[0].PointAtEnd.Z), geo.Vector3d.ZAxis)\n        result = ghcomp.ClipperComponents.PolylineOffset(\n            crvs,\n            dists,\n            plane,\n            tol,\n            closed_fillet,\n            open_fillet,\n            miter,\n        )\n\n        polyline_offset_result = Offset._PolylineOffsetResult()\n        for name in (\"contour\", \"holes\"):\n            setattr(polyline_offset_result, name, result[name])\n        return polyline_offset_result\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "line", "curve", "functions", "RhinoCommon"], "original_file": "969flash_LausLecture_9374d89733.json", "repo": "969flash/LausLecture"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "# r: pyshp\n\nimport Rhino.Geometry as geo\nimport shapefile\nimport os\nfrom typing import List, Tuple, Any, Optional\nimport ghpythonlib.components as ghcomp\n\n\nclass Parcel:\n    \"\"\"  \"\"\"\n\n    def __init__(\n        self,\n        curve_crv: geo.Curve,\n        pnu: str,\n        jimok: str,\n        record: List[Any],\n        hole_regions: List[geo.Curve],\n    ):\n        self.region = curve_crv  #   \n        self.hole_regions = (\n            hole_regions if hole_regions is not None else []\n        )  #  \n        self.pnu = pnu\n        self.jimok = jimok\n        self.record = record\n\n    def preprocess_curve(self) -> bool:\n        \"\"\"  (invalid ,  , )\"\"\"\n        if not self.region or not self.region.IsValid:\n            return False\n\n        #  \n        intersection_events = geo.Intersect.Intersection.CurveSelf(self.region, 0.001)\n        if intersection_events:\n            simplified = self.region.Simplify(geo.CurveSimplifyOptions.All, 0.1, 1.0)\n            if simplified:\n                self.region = simplified\n            else:\n                return False\n\n        #  \n        simplified = self.region.Simplify(geo.CurveSimplifyOptions.All, 0.1, 1.0)\n        if simplified:\n            self.region = simplified\n\n        #   \n        valid_holes = []\n        for hole in self.hole_regions:\n            if hole and hole.IsValid:\n                simplified_hole = hole.Simplify(geo.CurveSimplifyOptions.All, 0.1, 1.0)\n                if simplified_hole:\n                    valid_holes.append(simplified_hole)\n                else:\n                    valid_holes.append(hole)\n        self.hole_regions = valid_holes\n\n        return True\n\n\nclass Road(Parcel):\n    \"\"\" \"\"\"\n\n    pass\n\n\nclass Lot(Parcel):\n    \"\"\" \"\"\"\n\n    def __init__(\n        self,\n        curve_crv: geo.Curve,\n        pnu: str,\n        jimok: str,\n        record: List[Any],\n        hole_regions: List[geo.Curve] = None,\n    ):\n        super().__init__(curve_crv, pnu, jimok, record, hole_regions)\n        self.is_flag_lot = False  #   \n        self.has_road_access = False  #   \n\n\ndef read_shp_file(file_path: str) -> Tuple[List[Any], List[Any], List[str]]:\n    \"\"\"shapefile  shapes records \"\"\"\n    try:\n        sf = shapefile.Reader(file_path, encoding=\"utf-8\")\n    except:\n        try:\n            sf = shapefile.Reader(file_path, encoding=\"cp949\")\n        except:\n            sf = shapefile.Reader(file_path)\n\n    shapes = sf.shapes()\n    records = sf.records()\n    fields = [field[0] for field in sf.fields[1:]]\n    return shapes, records, fields\n\n\ndef get_curve_from_points(\n    points: List[Tuple[float, float]], start_idx: int, end_idx: int\n) -> Optional[geo.PolylineCurve]:\n    \"\"\"     \"\"\"\n    #  3  \n    if end_idx - start_idx < 3:\n        return None\n\n    #     ( ) None \n    first_pt = points[start_idx]\n    last_pt = points[end_idx - 1]\n    if first_pt[0] != last_pt[0] or first_pt[1] != last_pt[1]:\n        return None\n\n    curve_points = [\n        geo.Point3d(points[i][0], points[i][1], 0) for i in range(start_idx, end_idx)\n    ]\n\n    curve_crv = geo.PolylineCurve(curve_points)\n    return curve_crv if curve_crv and curve_crv.IsValid else None\n\n\ndef get_part_indices(shape: Any) -> List[Tuple[int, int]]:\n    \"\"\"shape      \"\"\"\n    if not hasattr(shape, \"parts\") or len(shape.parts) <= 1:\n        return [(0, len(shape.points))]\n\n    parts = list(shape.parts) + [len(shape.points)]\n    return [(parts[i], parts[i + 1]) for i in range(len(shape.parts))]\n\n\ndef get_curves_from_shape(\n    shape: Any,\n) -> Tuple[Optional[geo.PolylineCurve], List[geo.PolylineCurve]]:\n    \"\"\"shape      \"\"\"\n    boundary_region = None\n    hole_regions = []\n\n    part_indices = get_part_indices(shape)\n\n    for i, (start_idx, end_idx) in enumerate(part_indices):\n        curve_crv = get_curve_from_points(shape.points, start_idx, end_idx)\n        if curve_crv:\n            if i == 0:\n                boundary_region = curve_crv\n            else:\n                hole_regions.append(curve_crv)\n\n    #      \n    if boundary_region is None and len(part_indices) == 1:\n        points = [geo.Point3d(pt[0], pt[1], 0) for pt in shape.points]\n        if len(points) >= 3:\n            if points[0].DistanceTo(points[-1]) > 0.001:\n                points.append(points[0])\n            curve_crv = geo.PolylineCurve(points)\n            if curve_crv and curve_crv.IsValid:\n                boundary_region = curve_crv\n\n    return boundary_region, hole_regions\n\n\ndef get_field_value(\n    record: List[Any], fields: List[str], field_name: str, default: str = \"Unknown\"\n) -> str:\n    \"\"\"    \"\"\"\n    try:\n        index = fields.index(field_name)\n        return record[index]\n    except (ValueError, IndexError):\n        return default\n\n\ndef create_parcel_from_shape(\n    shape: Any, record: List[Any], fields: List[str]\n) -> Optional[Parcel]:\n    \"\"\"shape Parcel  \"\"\"\n    boundary_region, hole_regions = get_curves_from_shape(shape)\n\n    if not boundary_region or not boundary_region.IsValid:\n        return None\n\n    pnu = get_field_value(record, fields, \"A1\")  #  PNU\n    jimok = get_field_value(record, fields, \"A11\")  #  JIMOK\n\n    if jimok == \"\":\n        parcel = Road(boundary_region, pnu, jimok, record, hole_regions)\n    else:\n        parcel = Lot(boundary_region, pnu, jimok, record, hole_regions)\n\n    return parcel if parcel.preprocess_curve() else None\n\n\ndef get_parcels_from_shapes(\n    shapes: List[Any], records: List[Any], fields: List[str]\n) -> List[Parcel]:\n    \"\"\" shape Parcel  \"\"\"\n    parcels = []\n\n    for shape, record in zip(shapes, records):\n        parcel = create_parcel_from_shape(shape, record, fields)\n        if parcel:\n            parcels.append(parcel)\n\n    return parcels\n\n\ndef classify_parcels(parcels: List[Parcel]) -> Tuple[List[Lot], List[Road]]:\n    \"\"\"Parcel  Lot Road \"\"\"\n    lots = []\n    roads = []\n\n    for parcel in parcels:\n        if isinstance(parcel, Road):\n            roads.append(parcel)\n        else:\n            lots.append(parcel)\n\n    return lots, roads\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "line", "curve", "functions", "RhinoCommon"], "original_file": "969flash_LausLecture_d9ab009170.json", "repo": "969flash/LausLecture"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "# r: pyshp\n\nimport Rhino.Geometry as geo\nimport shapefile\nimport os\nimport zipfile\nfrom typing import List, Tuple, Any, Optional\nimport ghpythonlib.components as ghcomp\n\n\nclass Parcel:\n    \"\"\"  \"\"\"\n\n    def __init__(\n        self,\n        curve_crv: geo.Curve,\n        pnu: str,\n        jimok: str,\n        record: List[Any],\n        hole_regions: List[geo.Curve],\n    ):\n        self.region = curve_crv  #   \n        self.hole_regions = (\n            hole_regions if hole_regions is not None else []\n        )  #  \n        self.pnu = pnu\n        self.jimok = jimok\n        self.record = record\n\n    def preprocess_curve(self) -> bool:\n        \"\"\"  (invalid ,  , )\"\"\"\n        if not self.region or not self.region.IsValid:\n            return False\n\n        #  \n        intersection_events = geo.Intersect.Intersection.CurveSelf(self.region, 0.001)\n        if intersection_events:\n            simplified = self.region.Simplify(geo.CurveSimplifyOptions.All, 0.1, 1.0)\n            if simplified:\n                self.region = simplified\n            else:\n                return False\n\n        #  \n        simplified = self.region.Simplify(geo.CurveSimplifyOptions.All, 0.1, 1.0)\n        if simplified:\n            self.region = simplified\n\n        #   \n        valid_holes = []\n        for hole in self.hole_regions:\n            if hole and hole.IsValid:\n                simplified_hole = hole.Simplify(geo.CurveSimplifyOptions.All, 0.1, 1.0)\n                if simplified_hole:\n                    valid_holes.append(simplified_hole)\n                else:\n                    valid_holes.append(hole)\n        self.hole_regions = valid_holes\n\n        return True\n\n\nclass Road(Parcel):\n    \"\"\" \"\"\"\n\n    pass\n\n\nclass Lot(Parcel):\n    \"\"\" \"\"\"\n\n    def __init__(\n        self,\n        curve_crv: geo.Curve,\n        pnu: str,\n        jimok: str,\n        record: List[Any],\n        hole_regions: List[geo.Curve] = None,\n    ):\n        super().__init__(curve_crv, pnu, jimok, record, hole_regions)\n        self.is_flag_lot = False  #   \n        self.has_road_access = False  #   \n\n\ndef read_shp_file(file_path: str) -> Tuple[List[Any], List[Any], List[str]]:\n    \"\"\"shapefile  shapes records \"\"\"\n    try:\n        sf = shapefile.Reader(file_path, encoding=\"utf-8\")\n    except:\n        try:\n            sf = shapefile.Reader(file_path, encoding=\"cp949\")\n        except:\n            sf = shapefile.Reader(file_path)\n\n    shapes = sf.shapes()\n    records = sf.records()\n    fields = [field[0] for field in sf.fields[1:]]\n    return shapes, records, fields\n\n\ndef get_curve_from_points(\n    points: List[Tuple[float, float]], start_idx: int, end_idx: int\n) -> Optional[geo.PolylineCurve]:\n    \"\"\"     \"\"\"\n    #  3  \n    if end_idx - start_idx < 3:\n        return None\n\n    #     ( ) None \n    first_pt = points[start_idx]\n    last_pt = points[end_idx - 1]\n    if first_pt[0] != last_pt[0] or first_pt[1] != last_pt[1]:\n        return None\n\n    curve_points = [\n        geo.Point3d(points[i][0], points[i][1], 0) for i in range(start_idx, end_idx)\n    ]\n\n    curve_crv = geo.PolylineCurve(curve_points)\n    return curve_crv if curve_crv and curve_crv.IsValid else None\n\n\ndef get_part_indices(shape: Any) -> List[Tuple[int, int]]:\n    \"\"\"shape      \"\"\"\n    if not hasattr(shape, \"parts\") or len(shape.parts) <= 1:\n        return [(0, len(shape.points))]\n\n    parts = list(shape.parts) + [len(shape.points)]\n    return [(parts[i], parts[i + 1]) for i in range(len(shape.parts))]\n\n\ndef get_curves_from_shape(\n    shape: Any,\n) -> Tuple[Optional[geo.PolylineCurve], List[geo.PolylineCurve]]:\n    \"\"\"shape      \"\"\"\n    boundary_region = None\n    hole_regions = []\n\n    part_indices = get_part_indices(shape)\n\n    for i, (start_idx, end_idx) in enumerate(part_indices):\n        curve_crv = get_curve_from_points(shape.points, start_idx, end_idx)\n        if curve_crv:\n            if i == 0:\n                boundary_region = curve_crv\n            else:\n                hole_regions.append(curve_crv)\n\n    #      \n    if boundary_region is None and len(part_indices) == 1:\n        points = [geo.Point3d(pt[0], pt[1], 0) for pt in shape.points]\n        if len(points) >= 3:\n            if points[0].DistanceTo(points[-1]) > 0.001:\n                points.append(points[0])\n            curve_crv = geo.PolylineCurve(points)\n            if curve_crv and curve_crv.IsValid:\n                boundary_region = curve_crv\n\n    return boundary_region, hole_regions\n\n\ndef get_field_value(\n    record: List[Any], fields: List[str], field_name: str, default: str = \"Unknown\"\n) -> str:\n    \"\"\"    \"\"\"\n    try:\n        index = fields.index(field_name)\n        return record[index]\n    except (ValueError, IndexError):\n        return default\n\n\ndef create_parcel_from_shape(\n    shape: Any, record: List[Any], fields: List[str]\n) -> Optional[Parcel]:\n    \"\"\"shape Parcel  \"\"\"\n    boundary_region, hole_regions = get_curves_from_shape(shape)\n\n    if not boundary_region or not boundary_region.IsValid:\n        return None\n\n    pnu = get_field_value(record, fields, \"A1\")  #  PNU\n    jimok = get_field_value(record, fields, \"A11\")  #  JIMOK\n\n    if jimok == \"\":\n        parcel = Road(boundary_region, pnu, jimok, record, hole_regions)\n    else:\n        parcel = Lot(boundary_region, pnu, jimok, record, hole_regions)\n\n    return parcel if parcel.preprocess_curve() else None\n\n\ndef get_parcels_from_shapes(\n    shapes: List[Any], records: List[Any], fields: List[str]\n) -> List[Parcel]:\n    \"\"\" shape Parcel  \"\"\"\n    parcels = []\n\n    for shape, record in zip(shapes, records):\n        parcel = create_parcel_from_shape(shape, record, fields)\n        if parcel:\n            parcels.append(parcel)\n\n    return parcels\n\n\ndef classify_parcels(parcels: List[Parcel]) -> Tuple[List[Lot], List[Road]]:\n    \"\"\"Parcel  Lot Road \"\"\"\n    lots = []\n    roads = []\n\n    for parcel in parcels:\n        if isinstance(parcel, Road):\n            roads.append(parcel)\n        else:\n            lots.append(parcel)\n\n    return lots, roads\n\n\n# ================ GeometryUtils  ================\n\n\ndef get_point_from_shape(pts: List) -> geo.Point3d:\n    \"\"\"     Point3d \"\"\"\n    pts = list(pts)\n    if len(pts) == 2:\n        pts.append(0)\n    return geo.Point3d(*pts)\n\n\ndef get_vertices(curve: geo.Curve) -> List[geo.Point3d]:\n    \"\"\"  \"\"\"\n    vertices = [curve.PointAt(curve.SpanDomain(i)[0]) for i in range(curve.SpanCount)]\n    if not curve.IsClosed:\n        vertices.append(curve.PointAtEnd)\n    return vertices\n\n\ndef get_projected_pt_on_mesh(pt: geo.Point3d, mesh: geo.Mesh) -> Optional[geo.Point3d]:\n    \"\"\"  \"\"\"\n    for direction in [geo.Vector3d(0, 0, -1), geo.Vector3d(0, 0, 1)]:\n        ray = geo.Ray3d(pt, direction)\n        t = geo.Intersect.Intersection.MeshRay(mesh, ray)\n        if t >= 0:\n            return ray.PointAt(t)\n    return None\n\n\n# ================ Shape type mapping ================\n\nSHAPE_TYPES = {\n    \"point\": [\n        1,  # POINT\n        8,  # MULTIPOINT\n        11,  # POINTS\n        18,  # MULTIPOINTZ\n        21,  # POINTM\n        28,  # MULTIPOINTM\n    ],\n    \"polyline\": [\n        3,  # POLYLINE\n        5,  # POLYGON\n        13,  # POLYLINES\n        15,  # POLYGONZ\n        23,  # POLYLINEM\n        25,  # POLYGONM\n        31,  # MULTIPATCH\n    ],\n}\n\n\ndef find_shape_type(shape_type_id: int) -> Optional[str]:\n    \"\"\"Shape type ID type  \"\"\"\n    for key, values in SHAPE_TYPES.items():\n        if shape_type_id in values:\n            return key\n    return None\n\n\n# ================ Shapefile   ================\n\n\ndef parse_geometry(shape: Any, shape_type: str) -> List[Any]:\n    \"\"\"shape  geometry \"\"\"\n    if shape_type == \"point\":\n        return [get_point_from_shape(pt) for pt in shape.points]\n    elif shape_type == \"polyline\":\n        parts = [\n            shape.points[\n                shape.parts[i] : (\n                    shape.parts[i + 1] if i + 1 < len(shape.parts) else None\n                )\n            ]\n            for i in range(len(shape.parts))\n        ]\n        return [\n            geo.PolylineCurve([get_point_from_shape(pt) for pt in part])\n            for part in parts\n        ]\n    return []\n\n\ndef read_shapefile_from_reader(sf: shapefile.Reader, encoding: str = \"utf-8\") -> Tuple:\n    \"\"\"shapefile.Reader   \"\"\"\n    result_geom = []\n    result_fields = []\n    result_field_names = []\n    result_records = []\n\n    shape_type = find_shape_type(sf.shapeType)\n\n    # Extract field names\n    for field in sf.fields:\n        if field[0] != \"DeletionFlag\":\n            _field = field[0]\n            if isinstance(_field, bytes):\n                _field = _field.decode(encoding, errors=\"replace\")\n            result_field_names.append(_field)\n            result_fields.append(field)\n\n    # Extract geometry and records\n    for shape, record in zip(sf.shapes(), sf.records()):\n        geom = parse_geometry(shape, shape_type)\n        result_geom.append(geom)\n        _record = []\n        for rec in record:\n            if isinstance(rec, bytes):\n                _record.append(rec.decode(encoding, errors=\"replace\"))\n            else:\n                _record.append(rec)\n        result_records.append(_record)\n\n    return (\n        shape_type,\n        result_geom,\n        result_fields,\n        result_field_names,\n        result_records,\n    )\n\n\n# ================ Contour   ================\n\n\ndef create_contour_curves(\n    contour_geometry_records: List[Tuple],\n) -> List[geo.PolylineCurve]:\n    \"\"\"contour geometry record 3D  \"\"\"\n    contour_crvs = []\n    for contour_geom, contour_record in contour_geometry_records:\n        contour_crvs.append(\n            geo.PolylineCurve(\n                [\n                    geo.Point3d(\n                        contour_geom[0].Point(pt_count).X,\n                        contour_geom[0].Point(pt_count).Y,\n                        contour_record[1],\n                    )\n                    for pt_count in range(contour_geom[0].SpanCount)\n                ]\n            )\n        )\n    return contour_crvs\n\n\ndef create_points_for_mesh(\n    contour_curves: List[geo.Curve], resolution: float\n) -> List[geo.Point3d]:\n    \"\"\"contour     \"\"\"\n    points = []\n    for curve in contour_curves:\n        params = curve.DivideByLength(resolution, True)\n        if params:\n            points.extend([curve.PointAt(param) for param in params])\n\n    return points\n\n\n# ================ Building   ================\n\n\ndef create_building_breps(\n    building_geometry_records: List[Tuple], mesh_terrain: geo.Mesh\n) -> List[geo.Brep]:\n    \"\"\" geometry record Brep \"\"\"\n    breps = []\n    for geom, record in building_geometry_records:\n        base_curve = geom[0]\n        height = record[5] * 3.5\n        vertices = get_vertices(base_curve)\n\n        projected_pts = [get_projected_pt_on_mesh(pt, mesh_terrain) for pt in vertices]\n        projected_pts = list(filter(None, projected_pts))\n\n        if projected_pts:\n            min_z = min(pt.Z for pt in projected_pts)\n            base_curve.Translate(geo.Vector3d(0, 0, min_z - vertices[0].Z))\n            breps.append(geo.Extrusion.Create(base_curve, -height, True))\n    return breps\n\n\n# ================ ZIP/Shapefile   ================\n\n\ndef read_shapefiles_from_zip(\n    zip_paths: List[str], file_prefixes: List[str]\n) -> List[shapefile.Reader]:\n    \"\"\"ZIP  shapefile \"\"\"\n    readers = []\n    zip_files = [zipfile.ZipFile(zip_path, \"r\") for zip_path in zip_paths]\n\n    for zip_file in zip_files:\n        for prefix in file_prefixes:\n            try:\n                #  UTF-8 \n                try:\n                    readers.append(\n                        shapefile.Reader(\n                            shp=zip_file.open(f\"{prefix}.shp\"),\n                            shx=zip_file.open(f\"{prefix}.shx\"),\n                            dbf=zip_file.open(f\"{prefix}.dbf\"),\n                            prj=zip_file.open(f\"{prefix}.prj\"),\n                            encoding=\"utf-8\",\n                        )\n                    )\n                except UnicodeDecodeError:\n                    # UTF-8  CP949 \n                    readers.append(\n                        shapefile.Reader(\n                            shp=zip_file.open(f\"{prefix}.shp\"),\n                            shx=zip_file.open(f\"{prefix}.shx\"),\n                            dbf=zip_file.open(f\"{prefix}.dbf\"),\n                            prj=zip_file.open(f\"{prefix}.prj\"),\n                            encoding=\"cp949\",\n                        )\n                    )\n            except KeyError:\n                continue\n\n    # Close zip files\n    for zip_file in zip_files:\n        zip_file.close()\n\n    return readers\n\n\n# ================ ShpData  ================\n\n\nclass ShpData:\n    \"\"\"Shapefile   \"\"\"\n\n    def __init__(\n        self,\n        shape_type: str,\n        geometry: List,\n        fields: List,\n        field_names: List[str],\n        records: List,\n    ):\n        self.shape_type = shape_type\n        self.geometry = geometry\n        self.fields = fields\n        self.field_names = field_names\n        self.records = records\n\n\ndef extract_data_from_shapefiles(shapefiles: List[shapefile.Reader]) -> ShpData:\n    \"\"\" shapefile   ShpData \"\"\"\n    all_geometry = []\n    all_fields = []\n    all_field_names = []\n    all_records = []\n    shape_type = None\n\n    for sf in shapefiles:\n        result = read_shapefile_from_reader(sf)\n        if shape_type is None:\n            shape_type = result[0]\n        all_geometry.extend(result[1])\n        all_fields.extend(result[2])\n        all_field_names.extend(result[3])\n        all_records.extend(result[4])\n\n    return ShpData(shape_type, all_geometry, all_fields, all_field_names, all_records)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "brep", "line", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "969flash_LausLecture_eed91b8b42.json", "repo": "969flash/LausLecture"}
{"instruction": "    .", "code": "# -*- coding:utf-8 -*-\ntry:\n    from typing import List, Tuple, Dict, Any, Optional, Union\nexcept ImportError:\n    pass\nimport functools\n\nimport Rhino\nimport Rhino.Geometry as geo  # ignore\nimport ghpythonlib.components as ghcomp  # ignore\n\nBIGNUM = 10000000\n\nTOL = 0.001\nDIST_TOL = 0.01\nAREA_TOL = 0.1\nOP_TOL = 0.00001\nCLIPPER_TOL = 0.0000000001\n\n\ndef get_overlap_crv(crv_a: geo.Curve, crv_b: geo.Curve) -> List[geo.Curve]:\n    \"\"\"    .\n    Args:\n        crv_a : crv_b    \n        crv_b : crv_a   \n\n    Returns:\n        crv_a  crv_b   \n    \"\"\"\n    #       .\n    if not geo.Curve.PlanarCurveCollision(crv_a, crv_b, geo.Plane.WorldXY, TOL):\n        return []\n\n    # crv_a crv_b  + crv_a  crv_a .\n    pts_to_split = (\n        ghcomp.Explode(crv_a, True).vertices + ghcomp.CurveXCurve(crv_a, crv_b).points\n    )\n    if not pts_to_split:\n        return []\n\n    parameters = [ghcomp.CurveClosestPoint(pt, crv_a).parameter for pt in pts_to_split]\n\n    segments = ghcomp.Shatter(crv_a, parameters)\n\n    overlaped_segments = [\n        seg\n        for seg in segments\n        if geo.Curve.PlanarCurveCollision(seg, crv_b, geo.Plane.WorldXY, TOL)\n    ]\n\n    if not overlaped_segments:\n        return []\n\n    return geo.Curve.JoinCurves(overlaped_segments)\n\n\ndef get_overlap_length(crv_a: geo.Curve, crv_b: geo.Curve) -> float:\n    \"\"\"    .\n    Args:\n        crv_a : crv_b    \n        crv_b : crv_a   \n\n    Returns:\n        crv_a  crv_b   \n    \"\"\"\n    overlap_crvs = get_overlap_crv(crv_a, crv_b)\n    if not overlap_crvs:\n        return 0.0\n\n    length = 0.0\n    for crv in overlap_crvs:\n        length += crv.GetLength()\n    return length\n\n\ndef is_intersection_with_other_crvs(crv: geo.Curve, crvs: List[geo.Curve]) -> bool:\n    return any(\n        geo.Curve.PlanarCurveCollision(crv, other_crv, geo.Plane.WorldXY, OP_TOL)\n        for other_crv in crvs\n    )\n\n\ndef has_region_intersection(\n    region: geo.Curve, other_region: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"      .\n    Args:\n        region:  \n        other_regions:    \n        tol: tolerance\n\n    Returns:\n        bool:  \n    \"\"\"\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        region, other_region, geo.Plane.WorldXY, tol\n    )\n    #    .   .\n    if relationship == geo.RegionContainment.Disjoint:\n        return False\n    return True\n\n\ndef offset_regions_inward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n\n    Returns:\n        offset  \n    \"\"\"\n\n    if not dist:\n        return regions\n    return Offset().polyline_offset(regions, dist, miter).holes\n\n\ndef offset_regions_outward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n    returns:\n        offset  \n    \"\"\"\n    if isinstance(regions, geo.Curve):\n        regions = [regions]\n\n    return [offset_region_outward(region, dist, miter) for region in regions]\n\n\ndef offset_region_outward(\n    region: geo.Curve, dist: float, miter: float = BIGNUM\n) -> geo.Curve:\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n\n    Returns:\n        offset  \n    \"\"\"\n\n    if not dist:\n        return region\n    if not isinstance(region, geo.Curve):\n        raise ValueError(\"region must be curve\")\n    return Offset().polyline_offset(region, dist, miter).contour[0]\n\n\ndef convert_io_to_list(func):\n    \"\"\"    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        new_args = []\n        for arg in args:\n            if isinstance(arg, geo.Curve):\n                arg = [arg]\n            new_args.append(arg)\n\n        result = func(*new_args, **kwargs)\n        if isinstance(result, geo.Curve):\n            result = [result]\n\n        if hasattr(result, \"__dict__\"):\n            for key, values in result.__dict__.items():\n                if isinstance(values, geo.Curve):\n                    setattr(result, key, [values])\n        return result\n\n    return wrapper\n\n\nclass Offset:\n    class _PolylineOffsetResult:\n        def __init__(self):\n            self.contour: Optional[List[geo.Curve]] = None\n            self.holes: Optional[List[geo.Curve]] = None\n\n    @convert_io_to_list\n    def polyline_offset(\n        self,\n        crvs: List[geo.Curve],\n        dists: List[float],\n        miter: int = BIGNUM,\n        closed_fillet: int = 2,\n        open_fillet: int = 2,\n        tol: float = Rhino.RhinoMath.ZeroTolerance,\n    ) -> _PolylineOffsetResult:\n        \"\"\"\n        Args:\n            crv (_type_): _description_\n            dists (_type_): _description_\n            miter : miter\n            closed_fillet : 0 = round, 1 = square, 2 = miter\n            open_fillet : 0 = round, 1 = square, 2 = butt\n\n        Returns:\n            _type_: _PolylineOffsetResult\n        \"\"\"\n        if not crvs:\n            raise ValueError(\"No Curves to offset\")\n\n        plane = geo.Plane(geo.Point3d(0, 0, crvs[0].PointAtEnd.Z), geo.Vector3d.ZAxis)\n        result = ghcomp.ClipperComponents.PolylineOffset(\n            crvs,\n            dists,\n            plane,\n            tol,\n            closed_fillet,\n            open_fillet,\n            miter,\n        )\n\n        polyline_offset_result = Offset._PolylineOffsetResult()\n        for name in (\"contour\", \"holes\"):\n            setattr(polyline_offset_result, name, result[name])\n        return polyline_offset_result\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "line", "curve", "functions", "RhinoCommon"], "original_file": "969flash_OpenspaceAutomation_04d2c95184.json", "repo": "969flash/OpenspaceAutomation"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "# -*- coding:utf-8 -*-\ntry:\n    from typing import List, Tuple, Dict, Any, Optional\nexcept ImportError:\n    pass\n\nimport Rhino.Geometry as geo  # type: ignore\nimport scriptcontext as sc  # type: ignore\nimport Rhino  # type: ignore\nimport ghpythonlib.components as ghcomp  # type: ignore\nimport utils\n\n#  \nimport importlib\n\nimportlib.reload(utils)\n\n\nclass Lot:\n    def __init__(self, region: geo.Curve, district_use: str) -> None:\n        self.region = region\n        self.district_use = district_use\n        self.area = geo.AreaMassProperties.Compute(region).Area\n\n\nclass Road:\n    def __init__(self, curve: geo.Curve) -> None:\n        self.curve = curve\n\n\nclass Building:\n    def __init__(self, regions: List[geo.Curve], floor_count: int, use: str) -> None:\n        self.regions = regions\n        self.floor_area = sum(\n            geo.AreaMassProperties.Compute(region).Area for region in regions\n        )\n        self.floor_count = floor_count\n        self.total_area = self.floor_area * floor_count\n        self.use = use\n\n\nclass OpenspaceRequirement:\n    \"\"\"  \"\"\"\n\n    MIN_AREA = 90.0  # type: float\n    MIN_DEPTH = 9.0  # type: float\n    AREA_RATIO = 0.1  # type: float\n    #    41  \n    ROAD_ADJUST_RATIO = 0.25  # type: float\n\n    def __init__(self, lot: Lot, building: Building) -> None:\n        self.area = 0  # type: float\n        self._get_target_information(lot, building)\n\n    def _get_target_information(self, lot: Lot, building: Building) -> None:\n        #   \n        # 1.   \n        if lot.district_use not in (\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n        ):\n            return\n        # 2.   \n        if building.use not in (\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n        ):\n            return\n\n        # 3.   \n        if building.total_area < 5000:\n            return\n\n        #   =  10%( 90m2)\n        self.area = max(lot.area * self.AREA_RATIO, self.MIN_AREA)\n\n\nclass OepnspaceGenerator:\n    def __init__(\n        self,\n        lot: Lot,\n        roads: List[Road],\n        building: Building,\n        parking_region: geo.Curve,\n        requirement: OpenspaceRequirement,\n    ) -> None:\n        self.lot = lot\n        self.roads = roads\n        self.building = building\n        self.parking_region = parking_region\n        self.requirement = requirement\n\n    def get_openspace(self) -> List[geo.Curve]:\n        #   \n        # 1.   \n        candidates = self.get_candidate_regions()\n\n        # 2.   \n        filtered_candidates = self.filter_candidate_regions(candidates)\n\n        # 3.   \n        sorted_candidates = self.sort_candidate_regions(filtered_candidates)\n\n        # 4.   ()\n        openspace_regions = self.adjust_candidate_regions(sorted_candidates)\n\n        return openspace_regions\n\n    def get_candidate_regions(self) -> List[geo.Curve]:\n        \"\"\"     \"\"\"\n        #      \n        #  in and out   \n        inward_regions = utils.offset_regions_inward(\n            [self.lot.region, self.parking_region] + self.building.regions,\n            self.requirement.MIN_DEPTH / 2,\n        )\n\n        #      geo.Curve.PlanarCurveCollision \n        filtered_inward_regions = []\n        for region in inward_regions:\n            if any(\n                utils.has_region_intersection(region, other_region)\n                for other_region in self.building.regions\n            ):\n                continue\n            filtered_inward_regions.append(region)\n\n        candidate_regions = utils.offset_regions_outward(\n            filtered_inward_regions, self.requirement.MIN_DEPTH / 2\n        )\n\n        return candidate_regions\n\n    def filter_candidate_regions(self, candidates: List[geo.Curve]) -> List[geo.Curve]:\n        \"\"\"  \"\"\"\n\n        def is_road_adjacent(candidate: geo.Curve) -> bool:\n            #      \n            for road in self.roads:\n                candidate_overlap_length = utils.get_overlap_length(\n                    candidate, road.curve\n                )\n                lot_overlap_length = utils.get_overlap_length(\n                    self.lot.region, road.curve\n                )\n                if (\n                    candidate_overlap_length\n                    > lot_overlap_length * self.requirement.ROAD_ADJUST_RATIO\n                ):\n                    return True\n\n            return False\n\n        #  4 1     \n        filtered_candidates = filter(lambda x: is_road_adjacent(x), candidates)\n\n        #    \n        filtered_candidates = filter(\n            lambda x: geo.AreaMassProperties.Compute(x).Area\n            >= self.requirement.MIN_AREA,\n            filtered_candidates,\n        )\n\n        return list(filtered_candidates)\n\n    def sort_candidate_regions(self, candidates: List[geo.Curve]) -> List[geo.Curve]:\n        #    \n        sorted_candidates = sorted(\n            candidates,\n            key=lambda x: geo.AreaMassProperties.Compute(x).Area,\n            reverse=True,\n        )\n        return sorted_candidates\n\n    def adjust_candidate_regions(self, candidates: List[geo.Curve]) -> List[geo.Curve]:\n        #    \n        def reduce_region(region: geo.Curve, target_area: float) -> geo.Curve:\n            #      \n            region = region.Duplicate()\n            area = geo.AreaMassProperties.Compute(region).Area\n            if area <= target_area:\n                return region\n            scale_factor = (target_area / area) ** 0.5\n            center_of_scale = utils.get_overlap_crv(region, self.lot.region)[0].PointAt(\n                0.5\n            )\n            return ghcomp.Scale(region, center_of_scale, scale_factor).geometry\n\n        adjusted_candidates = []\n        total_area = 0.0\n        #       \n        for candidate in candidates:\n            area = geo.AreaMassProperties.Compute(candidate).Area\n            if total_area + area > self.requirement.area:\n                candidate = reduce_region(candidate, self.requirement.area - total_area)\n                area = geo.AreaMassProperties.Compute(candidate).Area\n\n            adjusted_candidates.append(candidate)\n            total_area += area\n\n            if total_area >= self.requirement.area:\n                break\n\n        return adjusted_candidates\n\n\n#######    #######\n# , , ,   .\nlot = Lot(lot_region, \"\")  # type: geo.Curve\nroads = [Road(region) for region in road_regions]  # type: List[Road]\nbuilding = Building(building_regions, 5, \"\")  # Placeholder for building\nrequirement = OpenspaceRequirement(lot, building)  # Placeholder for requirement\nopenspace_generator = OepnspaceGenerator(\n    lot, roads, building, parking_region, requirement\n)  # type: OepnspaceGenerator\n##############################\n\n\nopenspace_regions = openspace_generator.get_openspace()\n\nopenspace_area = sum(\n    geo.AreaMassProperties.Compute(region).Area for region in openspace_regions\n)\nprint(f\"Total Openspace Area: {openspace_area} m2\")\nprint(f\"Lot Area: {lot.area} m2\")\nprint(f\"Building Area: {building.total_area} m2\")\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "curve", "functions", "RhinoCommon"], "original_file": "969flash_OpenspaceAutomation_5bc02cefb3.json", "repo": "969flash/OpenspaceAutomation"}
{"instruction": "    ", "code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Any, Optional, Union\nimport math\nimport functools\nimport Rhino\nimport Rhino.Geometry as geo\nimport ghpythonlib.components as ghcomp\n\nfrom constants import TOL, ROUNDING_PRECISION, BIGNUM, OP_TOL, CLIPPER_TOL\n\n# Type Hinting\nCurveLike = Union[geo.Curve, List[geo.Curve]]\n\n\ndef convert_io_to_list(func):\n    \"\"\"    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        new_args = []\n        for arg in args:\n            if isinstance(arg, geo.Curve):\n                arg = [arg]\n            new_args.append(arg)\n\n        result = func(*new_args, **kwargs)\n        if isinstance(result, geo.Curve):\n            result = [result]\n        if hasattr(result, \"__dict__\"):\n            for key, values in result.__dict__.items():\n                if isinstance(values, geo.Curve):\n                    setattr(result, key, [values])\n        return result\n\n    return wrapper\n\n\n# ==============================================================================\n# 1.    (Core Geometry Utilities)\n# ==============================================================================\n\n\ndef get_distance_between_points(point_a: geo.Point3d, point_b: geo.Point3d) -> float:\n    \"\"\"    .\"\"\"\n    return round(point_a.DistanceTo(point_b), ROUNDING_PRECISION)\n\n\ndef get_distance_between_point_and_curve(point: geo.Point3d, curve: geo.Curve) -> float:\n    \"\"\"     .\"\"\"\n    _, param = curve.ClosestPoint(point)\n    dist = point.DistanceTo(curve.PointAt(param))\n    return round(dist, ROUNDING_PRECISION)\n\n\ndef get_distance_between_curves(curve_a: geo.Curve, curve_b: geo.Curve) -> float:\n    \"\"\"     .\"\"\"\n    _, pt_a, pt_b = curve_a.ClosestPoints(curve_b)\n    dist = pt_a.DistanceTo(pt_b)\n    return round(dist, ROUNDING_PRECISION)\n\n\ndef get_vector_from_pts(pt_a: geo.Point3d, pt_b: geo.Point3d) -> geo.Vector3d:\n    \"\"\"    .\"\"\"\n    return geo.Vector3d(pt_b.X - pt_a.X, pt_b.Y - pt_a.Y, pt_b.Z - pt_a.Z)\n\n\ndef get_vertices(curve: geo.Curve) -> List[geo.Point3d]:\n    \"\"\"  (Vertex) .\"\"\"\n    if not curve:\n        return []\n    vertices = [curve.PointAt(curve.SpanDomain(i)[0]) for i in range(curve.SpanCount)]\n    if not curve.IsClosed:\n        vertices.append(curve.PointAtEnd)\n    return vertices\n\n\ndef move_curve(curve: geo.Curve, vector: geo.Vector3d) -> geo.Curve:\n    \"\"\"     .\"\"\"\n    moved_curve = curve.Duplicate()\n    moved_curve.Translate(vector)\n    return moved_curve\n\n\ndef explode_curve(curve: geo.Curve) -> List[geo.Curve]:\n    \"\"\"     .\"\"\"\n    if not curve:\n        return []\n    if isinstance(curve, geo.PolyCurve):\n        return list(curve.DuplicateSegments())\n\n    segments = []\n    if curve.SpanCount > 0:\n        for i in range(curve.SpanCount):\n            sub_curve = curve.Trim(curve.SpanDomain(i))\n            if sub_curve:\n                segments.append(sub_curve)\n    elif curve.IsLinear():\n        segments.append(curve.Duplicate())\n\n    return segments\n\n\ndef get_pts_by_length(\n    crv: geo.Curve, length: float, include_start: bool = False\n) -> List[geo.Point3d]:\n    \"\"\"     .\"\"\"\n    params = crv.DivideByLength(length, include_start)\n    if not params:\n        return []\n    return [crv.PointAt(param) for param in params]\n\n\ndef get_area(regions: Union[List[geo.Curve], geo.Curve]) -> float:\n    \"\"\"   .\"\"\"\n    if not isinstance(regions, list):\n        regions = [regions]\n\n    area = sum([geo.AreaMassProperties.Compute(r).Area for r in regions])\n    return round(area, ROUNDING_PRECISION)\n\n\n# ==============================================================================\n# 2.    (Advanced Geometry Operations)\n# ==============================================================================\n\n\ndef has_intersection(\n    curve_a: geo.Curve,\n    curve_b: geo.Curve,\n    plane: geo.Plane = geo.Plane.WorldXY,\n    tol: float = TOL,\n) -> bool:\n    \"\"\"    .\"\"\"\n    return geo.Curve.PlanarCurveCollision(curve_a, curve_b, plane, tol)\n\n\ndef get_intersection_points(\n    curve_a: geo.Curve, curve_b: geo.Curve, tol: float = TOL\n) -> List[geo.Point3d]:\n    \"\"\"    .\"\"\"\n    intersections = geo.Intersect.Intersection.CurveCurve(curve_a, curve_b, tol, tol)\n    if not intersections:\n        return []\n    return [event.PointA for event in intersections if event.IsPointAValid]\n\n\ndef has_region_intersection(\n    region_a: geo.Curve, region_b: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"    ( ) .\"\"\"\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        region_a, region_b, geo.Plane.WorldXY, tol\n    )\n    return relationship != geo.RegionContainment.Disjoint\n\n\ndef is_region_inside(\n    inner_region: geo.Curve, outer_region: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"     .\"\"\"\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        inner_region, outer_region, geo.Plane.WorldXY, tol\n    )\n\n    return relationship == geo.RegionContainment.AInsideB\n\n\ndef get_overlapped_curves(curve_a: geo.Curve, curve_b: geo.Curve) -> List[geo.Curve]:\n    \"\"\"     .\"\"\"\n    if not has_intersection(curve_a, curve_b) or not ghcomp:\n        return []\n\n    intersection_points = get_intersection_points(curve_a, curve_b)\n    explode_result = ghcomp.Explode(curve_a, True)\n    explode_points = (\n        explode_result.vertices + intersection_points\n        if explode_result\n        else intersection_points\n    )\n\n    if not explode_points:\n        return []\n\n    params = [ghcomp.CurveClosestPoint(pt, curve_a).parameter for pt in explode_points]\n    shatter_result = ghcomp.Shatter(curve_a, params)\n\n    if not shatter_result:\n        return []\n\n    overlapped_segments = [\n        seg for seg in shatter_result if has_intersection(seg, curve_b)\n    ]\n    if not overlapped_segments:\n        return []\n\n    return geo.Curve.JoinCurves(overlapped_segments)\n\n\ndef get_overlapped_length(curve_a: geo.Curve, curve_b: geo.Curve) -> float:\n    \"\"\"     .\"\"\"\n    overlapped_curves = get_overlapped_curves(curve_a, curve_b)\n    if not overlapped_curves:\n        return 0.0\n    return sum(crv.GetLength() for crv in overlapped_curves)\n\n\nclass Offset:\n    class _OffsetResult:\n        def __init__(self):\n            self.contour: Optional[List[geo.Curve]] = None\n            self.holes: Optional[List[geo.Curve]] = None\n\n    @convert_io_to_list\n    def polyline_offset(\n        self,\n        crvs: List[geo.Curve],\n        dists: List[float],\n        miter: int = BIGNUM,\n        closed_fillet: int = 2,\n        open_fillet: int = 2,\n        tol: float = Rhino.RhinoMath.ZeroTolerance,\n    ) -> _OffsetResult:\n        \"\"\"\n        Args:\n            crv (_type_): _description_\n            dists (_type_): _description_\n            miter : miter\n            closed_fillet : 0 = round, 1 = square, 2 = miter\n            open_fillet : 0 = round, 1 = square, 2 = butt\n\n        Returns:\n            _type_: _OffsetResult\n        \"\"\"\n        if not crvs:\n            raise ValueError(\"No Curves to offset\")\n\n        plane = geo.Plane(geo.Point3d(0, 0, crvs[0].PointAtEnd.Z), geo.Vector3d.ZAxis)\n        result = ghcomp.ClipperComponents.PolylineOffset(\n            crvs,\n            dists,\n            plane,\n            tol,\n            closed_fillet,\n            open_fillet,\n            miter,\n        )\n\n        polyline_offset_result = Offset._OffsetResult()\n        for name in (\"contour\", \"holes\"):\n            setattr(polyline_offset_result, name, result[name])\n        return polyline_offset_result\n\n\ndef offset_regions_inward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n\n    Returns:\n        offset  \n    \"\"\"\n\n    if not dist:\n        return regions\n    result = Offset().polyline_offset(regions, dist, miter).holes\n\n    if not result:\n        return []\n\n    if isinstance(regions, geo.Curve):\n        regions = [regions]\n\n    if len(result) < 2:\n        return result\n\n    filtered = [\n        crv for crv in result if any(is_region_inside(crv, reg) for reg in regions)\n    ]\n    return filtered\n\n\ndef offset_regions_outward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n    returns:\n        offset  \n    \"\"\"\n    if isinstance(regions, geo.Curve):\n        regions = [regions]\n\n    return [offset_region_outward(region, dist, miter) for region in regions]\n\n\ndef simplify_regions_with_offset(\n    regions: List[geo.Curve], dist: float, miter: int = BIGNUM\n) -> Union[List[geo.Curve], geo.Curve]:\n    \"\"\"   offset  .\n     dist     .\n    Args:\n        region:   \n        dist:  offset \n\n    Returns:\n          \n    \"\"\"\n    if not regions:\n        return []\n\n    if dist <= 0.0:\n        return regions\n\n    inner = offset_regions_inward(regions, dist * 0.5, miter)\n    if not inner:\n        return []\n\n    outer = offset_regions_outward(inner, dist * 0.5, miter)\n\n    return outer\n\n\n# ==============================================================================\n# 2.1     Simplify ( )\n# ==============================================================================\n\n\ndef simplify_crv_by_reducing_segments(\n    crv: geo.Curve,\n    tol: float = TOL,\n    angle_tol: Optional[float] = None,\n) -> geo.Curve:\n    \"\"\"MergeColinearSegments + ReduceSegments  .\n\n    - colinear()   , / tol    .\n    -   /    .\n    - /    .\n    \"\"\"\n    if crv is None:\n        return crv\n\n    if angle_tol is None:\n        #  constants.ANGLE_TOL ,   1()\n        try:\n            from constants import ANGLE_TOL as _ANGLE_TOL  # type: ignore\n\n            angle_tol = float(_ANGLE_TOL)\n        except Exception:\n            angle_tol = math.radians(1.0)\n\n    # vertices  polyline \n    pts = get_vertices(crv)\n    if not pts:\n        return crv\n    if crv.IsClosed:\n        pts.append(pts[0])\n\n    pl = geo.Polyline(pts)\n\n    # colinear    \n    try:\n        pl.MergeColinearSegments(angle_tol, True)\n    except Exception:\n        pass\n    try:\n        pl.ReduceSegments(tol)\n    except Exception:\n        pass\n\n    #    (  ReduceSegments   )\n    try:\n        if pl.IsClosed and pl.Count > 3:\n            pt_items = list(pl.Item)\n            pt_first = pt_items[0]\n            pt1 = pt_items[1]\n            pt2 = pt_items[pl.Count - 2]\n            if geo.Line(pt1, pt2).DistanceTo(pt_first, True) <= tol:\n                pl.RemoveAt(0)\n                pl.RemoveAt(pl.Count - 1)\n                pl.Add(pl.First)\n    except Exception:\n        pass\n\n    polycrv = pl.ToPolylineCurve()\n    if not getattr(polycrv, \"IsValid\", False):\n        #  /   \n        return crv\n    return polycrv\n\n\ndef simplify_crvs_by_reducing_segments(\n    crvs: List[geo.Curve], tol: float = TOL, angle_tol: Optional[float] = None\n) -> List[geo.Curve]:\n    \"\"\"       \"\"\"\n    if not crvs:\n        return []\n    out: List[geo.Curve] = []\n    for r in crvs:\n        try:\n            out.append(simplify_crv_by_reducing_segments(r, tol, angle_tol))\n        except Exception:\n            out.append(r)\n    return out\n\n\ndef offset_region_outward(\n    region: geo.Curve, dist: float, miter: float = BIGNUM\n) -> geo.Curve:\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n\n    Returns:\n        offset  \n    \"\"\"\n\n    if not dist:\n        return region\n    if not isinstance(region, geo.Curve):\n        raise ValueError(\"region must be curve\")\n    return Offset().polyline_offset(region, dist, miter).contour[0]\n\n\nclass RegionBool:\n    @convert_io_to_list\n    def _polyline_boolean(\n        self, crvs0, crvs1, boolean_type=None, plane=None, tol=CLIPPER_TOL\n    ):\n        # type: (List[geo.Curve], List[geo.Curve], int, geo.Plane, float) -> List[geo.Curve]\n        if not crvs0 or not crvs1:\n            raise ValueError(\"Check input values\")\n        result = ghcomp.ClipperComponents.PolylineBoolean(\n            crvs0, crvs1, boolean_type, plane, tol\n        )\n\n        #  IronPython.Runtime.List ( list )       list \n        if not result:\n            return []\n\n        # IronPython.Runtime.List, System.Collections.Generic.List, tuple      \n        if isinstance(result, geo.Curve):\n            #   \n            result = [result]\n        else:\n            try:\n                # IEnumerable / IronPython.Runtime.List / tuple / System.Collections.Generic.List  list()  \n                result = [crv for crv in list(result) if crv]\n            except TypeError:\n                #      \n                result = [result]\n\n        return result\n\n    def polyline_boolean_intersection(self, crvs0, crvs1, plane=None, tol=CLIPPER_TOL):\n        # type: (Union[geo.Curve, List[geo.Curve]], Union[geo.Curve, List[geo.Curve]], geo.Plane, float) -> List[geo.Curve]\n        return self._polyline_boolean(crvs0, crvs1, 0, plane, tol)\n\n    def polyline_boolean_union(self, crvs0, crvs1, plane=None, tol=CLIPPER_TOL):\n        # type: (Union[geo.Curve, List[geo.Curve]], Union[geo.Curve, List[geo.Curve]], geo.Plane, float) -> List[geo.Curve]\n        return self._polyline_boolean(crvs0, crvs1, 1, plane, tol)\n\n    def polyline_boolean_difference(self, crvs0, crvs1, plane=None, tol=CLIPPER_TOL):\n        # type: (Union[geo.Curve, List[geo.Curve]], Union[geo.Curve, List[geo.Curve]], geo.Plane, float) -> List[geo.Curve]\n        return self._polyline_boolean(crvs0, crvs1, 2, plane, tol)\n\n\ndef get_intersection_regions(\n    regions_a: List[geo.Curve], regions_b: List[geo.Curve]\n) -> List[geo.Curve]:\n    \"\"\"     .\n    Args:\n        regions_a:     \n        regions_b:     \n    Returns:\n          \n    \"\"\"\n    if not regions_a or not regions_b:\n        return []\n    intersection_result = RegionBool().polyline_boolean_intersection(\n        regions_a, regions_b\n    )\n    return intersection_result\n\n\ndef get_union_regions(regions: List[geo.Curve] = None) -> List[geo.Curve]:\n    \"\"\"    .\n    Args:\n        regions:    \n    Returns:\n          \n    \"\"\"\n    if not regions:\n        return []\n\n    if len(regions) == 1:\n        return regions\n\n    union_result = list(geo.Curve.CreateBooleanUnion(regions, TOL))\n    if union_result:\n        return union_result\n\n    union_result = regions[0]\n    for region in regions[1:]:\n        union_result = RegionBool().polyline_boolean_union(union_result, region)\n\n    if not isinstance(union_result, list):\n        union_result = [union_result]\n\n    return union_result\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "line", "curve", "functions", "RhinoCommon"], "original_file": "969flash_RoadDetailBuilder_04d2c95184.json", "repo": "969flash/RoadDetailBuilder"}
{"instruction": "A class to manage Shapefile operations.", "code": "# -*- coding:utf-8 -*-\nfrom typing import List, Tuple, Optional\nimport zipfile\nimport shapefile\nimport Rhino.Geometry as geo\nimport ghpythonlib.components as ghcomp  # ignore\n\n#########################\n# bsh960flash@snu.ac.kr #\n#########################\n\n\n# Contour Divide Resolution(Higher value means more points in terrain mesh)\nRESOLUTION = 4\n\n# Shape type mapping\n# This dictionary categorizes shape types based on their IDs as defined in the shapefile specification.\n# The categories are 'point' and 'polyline', and the IDs represent different geometry types.\nshape_types = {\n    \"point\": [\n        1,  # POINT\n        8,  # MULTIPOINT\n        11,  # POINTZ\n        18,  # MULTIPOINTZ\n        21,  # POINTM\n        28,  # MULTIPOINTM\n    ],\n    \"polyline\": [\n        3,  # POLYLINE\n        5,  # POLYGON\n        13,  # POLYLINEZ\n        15,  # POLYGONZ\n        23,  # POLYLINEM\n        25,  # POLYGONM\n        31,  # MULTIPATCH\n    ],\n}\n\n\nclass ShapefileHandler:\n    \"\"\"\n    A class to manage Shapefile operations.\n    \"\"\"\n\n    def __init__(self, zip_paths: List[str]):\n        self.zip_files = [zipfile.ZipFile(zip_path, \"r\") for zip_path in zip_paths]\n\n    def read_shapefile(self, file_prefixes: List[str]) -> List[shapefile.Reader]:\n        \"\"\"\n        Attempts to read shapefiles from the zip archives using a list of prefixes.\n        \"\"\"\n        readers = []\n        for zip_file in self.zip_files:\n            for prefix in file_prefixes:\n                try:\n                    readers.append(\n                        shapefile.Reader(\n                            shp=zip_file.open(f\"{prefix}.shp\"),\n                            shx=zip_file.open(f\"{prefix}.shx\"),\n                            dbf=zip_file.open(f\"{prefix}.dbf\"),\n                            prj=zip_file.open(f\"{prefix}.prj\"),\n                            encoding=\"cp949\",\n                        )\n                    )\n                except KeyError:\n                    continue\n        return readers\n\n    def extract_data(self, shapefiles: List[shapefile.Reader]) -> \"ShpData\":\n        \"\"\"\n        Extracts data from a list of shapefiles.\n        \"\"\"\n        all_geometry = []\n        all_fields = []\n        all_field_names = []\n        all_records = []\n        shape_type = None\n\n        for sf in shapefiles:\n            result = ShapefileParser.read_shapefile(sf)\n            if shape_type is None:\n                shape_type = result[0]\n            all_geometry.extend(result[1])\n            all_fields.extend(result[2])\n            all_field_names.extend(result[3])\n            all_records.extend(result[4])\n\n        return ShpData(\n            shape_type, all_geometry, all_fields, all_field_names, all_records\n        )\n\n\nclass ShpData:\n    \"\"\"\n    A class to store Shapefile data.\n    \"\"\"\n\n    def __init__(self, shape_type, geometry, fields, field_names, records):\n        self.shape_type = shape_type\n        self.geometry = geometry\n        self.fields = fields\n        self.field_names = field_names\n        self.records = records\n\n\nclass ShapefileParser:\n    \"\"\"\n    A class to handle parsing operations for shapefiles.\n    \"\"\"\n\n    @staticmethod\n    def find_type(shape_type):\n        for key, values in shape_types.items():\n            if shape_type in values:\n                return key\n        return None\n\n    @staticmethod\n    def read_shapefile(sf: shapefile.Reader, encoding=\"utf-8\") -> Tuple:\n        result_geom = []\n        result_fields = []\n        result_field_names = []\n        result_records = []\n\n        shape_type = ShapefileParser.find_type(sf.shapeType)\n\n        # Extract field names\n        for field in sf.fields:\n            if field[0] != \"DeletionFlag\":\n                _field = field[0]\n                if isinstance(_field, bytes):\n                    _field = _field.decode(encoding, errors=\"replace\")\n                result_field_names.append(_field)\n                result_fields.append(field)\n\n        # Extract geometry and records\n        for shape, record in zip(sf.shapes(), sf.records()):\n            geom = ShapefileParser.parse_geometry(shape, shape_type)\n            result_geom.append(geom)\n            _record = []\n            for rec in record:\n                if isinstance(rec, bytes):\n                    _record.append(rec.decode(encoding, errors=\"replace\"))\n                else:\n                    _record.append(rec)\n            result_records.append(_record)\n\n        return (\n            shape_type,\n            result_geom,\n            result_fields,\n            result_field_names,\n            result_records,\n        )\n\n    @staticmethod\n    def parse_geometry(shape, shape_type):\n        if shape_type == \"point\":\n            return [GeometryUtils.list2point(pt) for pt in shape.points]\n        elif shape_type == \"polyline\":\n            parts = [\n                shape.points[\n                    shape.parts[i] : (\n                        shape.parts[i + 1] if i + 1 < len(shape.parts) else None\n                    )\n                ]\n                for i in range(len(shape.parts))\n            ]\n            return [\n                geo.PolylineCurve([GeometryUtils.list2point(pt) for pt in part])\n                for part in parts\n            ]\n        return []\n\n\nclass GeometryUtils:\n    \"\"\"\n    A utility class for geometry-related operations.\n    \"\"\"\n\n    @staticmethod\n    def list2point(pts):\n        pts = list(pts)\n        if len(pts) == 2:\n            pts.append(0)\n        return geo.Point3d(*pts)\n\n    @staticmethod\n    def get_vertices(curve):\n        vertices = [\n            curve.PointAt(curve.SpanDomain(i)[0]) for i in range(curve.SpanCount)\n        ]\n        if not curve.IsClosed:\n            vertices.append(curve.PointAtEnd)\n        return vertices\n\n    @staticmethod\n    def get_projected_pt_on_mesh(pt, mesh):\n        for direction in [geo.Vector3d(0, 0, -1), geo.Vector3d(0, 0, 1)]:\n            ray = geo.Ray3d(pt, direction)\n            t = geo.Intersect.Intersection.MeshRay(mesh, ray)\n            if t >= 0:\n                return ray.PointAt(t)\n        return None\n\n\nclass ContourProcessor:\n    \"\"\"\n    A class to handle contour operations.\n    \"\"\"\n\n    @staticmethod\n    def create_contour_curves(contour_geometry_records):\n        contour_crvs = []\n        for contour_geom, contour_record in contour_geometry_records:\n            contour_crvs.append(\n                geo.PolylineCurve(\n                    [\n                        geo.Point3d(\n                            contour_geom[0].Point(pt_count).X,\n                            contour_geom[0].Point(pt_count).Y,\n                            contour_record[1],\n                        )\n                        for pt_count in range(contour_geom[0].SpanCount)\n                    ]\n                )\n            )\n        return contour_crvs\n\n    @staticmethod\n    def create_points_for_mesh(contour_curves, resolution):\n        points = []\n        for curve in contour_curves:\n            params = curve.DivideByLength(resolution, True)\n            if params:\n                points.extend([curve.PointAt(param) for param in params])\n        return points\n\n\nclass BuildingProcessor:\n    \"\"\"\n    A class to process building geometries.\n    \"\"\"\n\n    @staticmethod\n    def create_building_breps(building_geometry_records, mesh_terrain):\n        breps = []\n        for geom, record in building_geometry_records:\n            base_curve = geom[0]\n            height = record[5] * 3.5\n            vertices = GeometryUtils.get_vertices(base_curve)\n\n            projected_pts = [\n                GeometryUtils.get_projected_pt_on_mesh(pt, mesh_terrain)\n                for pt in vertices\n            ]\n            projected_pts = list(filter(None, projected_pts))\n\n            if projected_pts:\n                min_z = min(pt.Z for pt in projected_pts)\n                base_curve.Translate(geo.Vector3d(0, 0, min_z - vertices[0].Z))\n                building = geo.Extrusion.Create(base_curve, -height, True)\n                breps.append(building)\n\n        return breps\n\n\n# paths -> parameter of the component in grasshopper that is the path to the zip files\n\n# Main workflow\nhandler = ShapefileHandler(paths)\ncontour_shapes = handler.read_shapefile([\"N1L_F0010000\", \"N3L_F0010000\"])\nbuilding_shapes = handler.read_shapefile([\"N1A_B0010000\", \"N3A_B0010000\"])\nroad_region_shapes = handler.read_shapefile([\"N3A_A0010000\"])\nroad_centerline_shapes = handler.read_shapefile([\"N3L_A0020000\"])\nriver_shapes = handler.read_shapefile([\"N3A_E0010001\"])\nwater_shapes = handler.read_shapefile([\"N3A_G0020000\"])\n\n# Extract data\ncontour_data = handler.extract_data(contour_shapes)\nbuilding_data = handler.extract_data(building_shapes)\nroad_region_data = handler.extract_data(road_region_shapes)\nroad_centerline_data = handler.extract_data(road_centerline_shapes)\nriver_data = handler.extract_data(river_shapes)\nwater_shapes_data = handler.extract_data(water_shapes)\n\n\n# Process contour\ncontour_geometry_records = list(zip(contour_data.geometry, contour_data.records))\ncontour_curves = ContourProcessor.create_contour_curves(contour_geometry_records)\n\n# Process terrain\nmesh_points = ContourProcessor.create_points_for_mesh(contour_curves, RESOLUTION)\nterrain_mesh = ghcomp.DelaunayMesh(mesh_points)\n\n# Process buildings\nbuilding_geometry_records = list(zip(building_data.geometry, building_data.records))\nbuilding_breps = BuildingProcessor.create_building_breps(\n    building_geometry_records, terrain_mesh\n)\n\n# Process road\nroad_region_curves = [data[0] for data in road_region_data.geometry]\nroad_centerline_curves = [data[0] for data in road_centerline_data.geometry]\n\n# process river\nriver_curves = [data[0] for data in river_data.geometry]\n# process water\nwater_curves = [data[0] for data in water_shapes_data.geometry]\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "brep", "line", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "969flash_SHPtoContext_5bc02cefb3.json", "repo": "969flash/SHPtoContext"}
{"instruction": "Public: Quantize a point to TOL-sized grid for stable equality/hash.", "code": "try:\n    from typing import List, Tuple\nexcept ImportError:\n    pass\nimport Rhino.Geometry as geo\nimport ghpythonlib.components as ghcomp\nimport utils\nimport importlib\nimport networkx as nx\nimport scriptcontext as sc\n\nimportlib.reload(utils)\nTOL = 5\nNODE_TOL = 0.5\n\n\nclass Edge:\n    def __init__(self, curve: geo.Curve, width: float):\n        self.curve = curve  # type: geo.Curve\n        self.width = width  # type: float\n\n    def is_at(self, node: \"Node\") -> bool:\n        return node == self.curve.PointAtStart or node == self.curve.PointAtEnd\n\n\nclass Node:\n    def __init__(self, point: geo.Point3d):\n        self.point = point\n        self.edges = []  # type: List[Edge]\n\n    def add_edges(self, edges: List[Edge]) -> None:\n        self.edges.extend(edges)\n\n    @staticmethod\n    def point_to_key(p: geo.Point3d):\n        \"\"\"Public: Quantize a point to TOL-sized grid for stable equality/hash.\"\"\"\n        q = TOL\n        return (\n            int(round(p.X / q)),\n            int(round(p.Y / q)),\n            int(round(p.Z / q)),\n        )\n\n    def __eq__(self, other):\n        # Allow positional tolerance of NODE_TOL\n        if isinstance(other, Node):\n            return self.point.DistanceTo(other.point) <= NODE_TOL\n        if isinstance(other, geo.Point3d):\n            return self.point.DistanceTo(other) <= NODE_TOL\n        return NotImplemented\n\n    def __hash__(self):\n        # Hash derived from the same quantized key used in __eq__\n        return hash(Node.point_to_key(self.point))\n\n\nclass Road:\n    def __init__(self, region: geo.Curve, edge: Edge):\n        self.region = region\n        self.edge = edge\n\n\nclass Junction:\n    def __init__(self, region, node: Node):\n        self.region = region\n        self.node = node\n        self.connected_roads = []  # type: List[Road]\n\n\nclass RoadNetwork:\n    def __init__(\n        self,\n        roads: List[Road],\n        junctions: List[Junction],\n        nodes: List[Node],\n        edges: List[Edge],\n    ):\n        self.nodes = nodes\n        self.edges = edges\n        self.roads = roads\n        self.junctions = junctions\n\n        self.graph = self._get_graph()\n\n    def _get_graph(self):\n        G = nx.Graph()\n\n        # TOL    : Node.point_to_key / Node.point_key \n        key = Node.point_to_key\n        nodes_by_key = {key(n.point): n for n in self.nodes}\n\n        #   + \n        for n in self.nodes:\n            G.add_node(n, point=n.point, degree=len(n.edges))\n\n        #  :   +  fallback\n        for e in self.edges:\n            n1 = nodes_by_key.get(key(e.curve.PointAtStart))\n            n2 = nodes_by_key.get(key(e.curve.PointAtEnd))\n            if not n1:\n                n1 = next((n for n in self.nodes if n == e.curve.PointAtStart), None)\n            if not n2:\n                n2 = next((n for n in self.nodes if n == e.curve.PointAtEnd), None)\n            if not n1 or not n2:\n                continue\n            G.add_edge(\n                n1,\n                n2,\n                object=e,\n                width=getattr(e, \"width\", None),\n                length=e.curve.GetLength() if e.curve else None,\n                curve=e.curve,\n            )\n        return G\n\n\nclass BlockInfo:\n    \"\"\"Configuration holder for initializing Block objects.\n\n    Attributes:\n        block_ids: List of target block ids this config applies to.\n        gfa: Floor area ratio ().\n        bcr: Building coverage ratio ().\n        landuses: List of landuse labels.\n        pedestrian_width: Width of pedestrian zone (m).\n    \"\"\"\n\n    def __init__(\n        self,\n        block_ids,  # type: List[int]\n        gfa=None,  # type: float\n        bcr=None,  # type: float\n        landuses=None,  # type: List[str]\n        pedestrian_width=None,  # type: float\n    ):\n        self.block_ids = block_ids\n        self.gfa = gfa\n        self.bcr = bcr\n        self.landuses = landuses\n        self.pedestrian_width = pedestrian_width\n\n\nclass Block:\n    def __init__(self, region: geo.Curve, block_id: int = None):\n        self.block_id = block_id\n        self.region = region\n        self.buildable_region = region  # type: geo.Curve\n        self.roads = []  # type: List[Road]\n        self.junctions = []  # type: List[Junction]\n\n        # landuse/building defaults\n        self.landuses = []  # type: List[str]\n        self.gfa = 0.0  # \n        self.bcr = 0.0  # \n        self.pedestrian_width = 0.0\n\n        # placeholders for downstream\n        self.pedestrian = []  # type: List[geo.Surface]\n        self.buildings = []  # type: List[Building]\n\n    def initialize(self, block_info: BlockInfo):\n        \"\"\"block_info   .\"\"\"\n        # gfa and bcr\n        self.gfa = block_info.gfa\n        self.bcr = block_info.bcr\n\n        # landuses\n        self.landuses = block_info.landuses\n\n        # pedestrian width\n        self.pedestrian_width = block_info.pedestrian_width\n\n        self.buildable_region = utils.offset_regions_inward(\n            self.region, self.pedestrian_width\n        )[0]\n\n        self.pedestrian = ghcomp.BoundarySurfaces([self.buildable_region, self.region])\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "classes", "point", "curve", "functions", "block", "RhinoCommon"], "original_file": "969flash_UrbanFrame_a20ddddd7a.json", "repo": "969flash/UrbanFrame"}
{"instruction": "Return the shape score for a block.", "code": "from __future__ import annotations\n\nimport math\nfrom typing import List\nimport Rhino.Geometry as geo\nimport ghpythonlib.components as ghcomp  # type: ignore\nfrom units import Block\nimport utils\nimport os\n\nfrom constants import (\n    SHAPE_BLOCK_INFLUENCE,\n    SHAPE_CONVEXITY_WEIGHT,\n    SHAPE_CIRCULARITY_WEIGHT,\n    SHAPE_SQUARENESS_WEIGHT,\n)\n\n\ndef compute(block: Block) -> float:\n    \"\"\"Return the shape score for a block.\n\n    1)   RSI  \n    2)   RSI  'ugly multiplier' \n    3)      .\n    \"\"\"\n    if not block.lots:\n        return 0.0\n\n    lot_scores = [get_rsi(lot.region) for lot in block.lots]\n    if not lot_scores:\n        return 0.0\n\n    lot_avg_rsi = sum(lot_scores) / len(lot_scores)\n\n    block_rsi = get_rsi(block.region)\n    block_multiplier = _compute_block_multiplier(block_rsi)\n\n    final_score = lot_avg_rsi * block_multiplier\n\n    return final_score\n\n\ndef get_rsi(region: geo.Curve | None) -> float:\n    \"\"\"Return the RSI value (0~1) for a single region.\"\"\"\n    convexity = get_convexity_index(region)\n    circularity = get_circularity_index(region)\n    squareness = get_squareness_index(region)\n\n    rsi = (\n        (convexity * SHAPE_CONVEXITY_WEIGHT)\n        + (circularity * SHAPE_CIRCULARITY_WEIGHT)\n        + (squareness * SHAPE_SQUARENESS_WEIGHT)\n    )\n\n    return rsi\n\n\ndef get_convexity_index(region: geo.Curve) -> float:\n    \"\"\"\n     (CI) : A / A_ch\n\n    - A:   \n    - A_ch:   (Convex Hull) \n    -  (0, 1] . 1   .\n    - , ,        \n    \"\"\"\n    if region is None:\n        raise ValueError(\"Region curve is required to compute convexity.\")\n    if not getattr(region, \"IsClosed\", False):\n        raise ValueError(\"Region curve must be closed to compute convexity.\")\n\n    try:\n        area = float(utils.get_area(region))\n    except Exception:\n        return 0.0\n    if area <= 0.0:\n        return 0.0\n\n    vertices = utils.get_vertices(region)\n    hull_crv = ghcomp.ConvexHull(vertices).hull\n\n    if not hull_crv:\n        return 0.0\n    try:\n        hull_area = float(utils.get_area(hull_crv))\n    except Exception:\n        return 0.0\n    if hull_area <= 0.0:\n        return 0.0\n    return area / hull_area\n\n\ndef get_circularity_index(region: geo.Curve) -> float:\n    \"\"\"\n     (Isoperimetric Quotient) : (4    A) / P\n\n    - A:  \n    - P:  \n    -  : 1.0\n    - : ~0.785\n    -   : 0  \n    -     \n    \"\"\"\n    if region is None:\n        raise ValueError(\"Region curve is required to compute circularity.\")\n    if not getattr(region, \"IsClosed\", False):\n        raise ValueError(\"Region curve must be closed to compute circularity.\")\n\n    try:\n        area = utils.get_area(region)\n        perim = utils.get_length(region)\n    except Exception:\n        return 0.0\n\n    # Isoperimetric Quotient \n    circularity = (4.0 * math.pi * area) / (perim * perim)\n\n    #  1.0   ,       \n    return circularity\n\n\ndef get_squareness_index(region: geo.Curve) -> float:\n    \"\"\"    .\"\"\"\n    bbox = utils.get_min_bbox(region)\n\n    corners = list(bbox.GetCorners())[:4]\n    dist_1 = corners[0].DistanceTo(corners[1])\n    dist_2 = corners[1].DistanceTo(corners[2])\n\n    aspect_ratio = min(dist_1, dist_2) / max(dist_1, dist_2)\n\n    vertex_count = len(utils.get_vertices(region))\n    vertex_penalty = 1.0\n    if vertex_count == 3:\n        vertex_penalty = 0.5\n    elif vertex_count == 4:\n        vertex_penalty = 1.0\n    elif vertex_count == 5:\n        vertex_penalty = 0.9\n    elif vertex_count == 6:\n        vertex_penalty = 0.8\n    elif vertex_count > 6:\n        vertex_penalty = 0.7\n\n    return aspect_ratio * vertex_penalty\n\n\ndef _compute_block_multiplier(block_rsi: float) -> float:\n    \"\"\"Return the block-level adjustment multiplier.\"\"\"\n    if block_rsi <= 0.0:\n        return 1.0 - SHAPE_BLOCK_INFLUENCE\n    return (block_rsi * SHAPE_BLOCK_INFLUENCE) + (1.0 - SHAPE_BLOCK_INFLUENCE)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["block", "curve", "functions", "RhinoCommon"], "original_file": "969flash_parcel_layout_evaluation_analysis_a07edef006.json", "repo": "969flash/parcel_layout_evaluation_analysis"}
{"instruction": "   ( )", "code": "import Rhino.Geometry as geo\nfrom typing import List, Any, Optional, Tuple\nfrom constants import TOL\nimport importlib\nimport scriptcontext as sc\nimport utils\nimport constants\nfrom constants import RAW_TOL\n\nimportlib.reload(utils)\nimportlib.reload(constants)\n\n\nclass Parcel:\n    \"\"\"   ( )\n\n      utils    .\n    \"\"\"\n\n    def __init__(\n        self,\n        curve_crv: geo.Curve,\n        pnu: str,\n        jimok: str,\n        record: List[Any],\n        hole_regions: Optional[List[geo.Curve]] = None,\n    ):\n        self.region: geo.Curve = curve_crv  #   \n        self.hole_regions: List[geo.Curve] = hole_regions or []  #  \n        self.pnu = pnu\n        self.jimok = jimok\n        self.record = record\n\n    def preprocess_curve(self) -> bool:\n        \"\"\"  (invalid ,  , )\n\n         utils.preprocess_curve_util        .\n        \"\"\"\n        if not self.region or not getattr(self.region, \"IsValid\", False):\n            return False\n\n        #     \n        try:\n            import utils  # type: ignore\n        except Exception:\n            return False\n\n        result = self._preprocess_curve_util(self.region, self.hole_regions)\n        if result is None:\n            return False\n\n        region, holes = result\n        self.region = region\n        self.hole_regions = holes\n        return True\n\n    def _preprocess_curve_util(\n        self, region: geo.Curve, hole_regions: Optional[List[geo.Curve]]\n    ) -> Optional[Tuple[geo.Curve, List[geo.Curve]]]:\n        \"\"\"\n               .\n        (hole)   .\n        \"\"\"\n\n        if region is None or not getattr(region, \"IsValid\", False):\n            return None\n\n        #    \n        try:\n            if geo.Intersect.Intersection.CurveSelf(region, TOL):\n                simplified = region.Simplify(geo.CurveSimplifyOptions.All, 0.1, 1.0)\n                region = simplified or region\n        except Exception:\n            pass  #    \n\n        #  \n        try:\n            simplified = region.Simplify(geo.CurveSimplifyOptions.All, 0.1, 1.0)\n            region = simplified or region\n        except Exception:\n            pass\n\n        #   \n        valid_holes: List[geo.Curve] = []\n        for hole in hole_regions or []:\n            try:\n                if hole and hole.IsValid:\n                    simplified_hole = hole.Simplify(\n                        geo.CurveSimplifyOptions.All, 0.1, 1.0\n                    )\n                    valid_holes.append(simplified_hole or hole)\n            except Exception:\n                continue\n\n        return region, valid_holes\n\n\nclass Road(Parcel):\n    \"\"\" \"\"\"\n\n    pass\n\n\nclass Lot(Parcel):\n    \"\"\" \"\"\"\n\n    def __init__(\n        self,\n        curve_crv: geo.Curve,\n        pnu: str,\n        jimok: str,\n        record: List[Any],\n        hole_regions: Optional[List[geo.Curve]] = None,\n        road_adj: Optional[int] = None,\n        max_height: Optional[float] = None,\n        min_height: Optional[float] = None,\n    ):\n        super().__init__(curve_crv, pnu, jimok, record, hole_regions)\n        self.is_flag_lot: bool = False  #   \n        self.has_road_access: bool = False  #   \n        self.road_adj = road_adj  #   \n        self.max_height = max_height  #   \n        self.min_height = min_height  #   \n\n\nclass Block:\n    def __init__(self, lots: List[Lot], id: int):\n        self.id = id\n        self.lots = lots\n        self.region: geo.Curve = None  #  \n        #     \n        self.is_donut = False\n        self._set_block_region()\n        self.layout_score: LayoutScore = None  #   \n        self.max_height = self.get_max_height()\n        self.min_height = self.get_min_height()\n\n    def get_max_height(self) -> Optional[float]:\n        \"\"\"     .\"\"\"\n        heights = [lot.max_height for lot in self.lots if lot.max_height is not None]\n        return max(heights) if heights else None\n\n    def get_min_height(self) -> Optional[float]:\n        \"\"\"     .\"\"\"\n        heights = [lot.min_height for lot in self.lots if lot.min_height is not None]\n        return min(heights) if heights else None\n\n    def _set_block_region(self) -> None:\n        \"\"\" Lot  .\"\"\"\n        #  Lot     .\n        lot_regions = [lot.region for lot in self.lots if lot.region]\n        offset_regions = utils.offset_regions_outward(lot_regions, RAW_TOL)\n        block_regions = utils.get_union_regions(offset_regions)\n        if len(block_regions) != 1:\n            block_region = self._get_out_region(block_regions)\n            self.is_donut = True\n\n        else:\n            block_region = block_regions[0]\n\n        block_region = utils.offset_regions_inward(block_region, RAW_TOL)\n\n        if len(block_region) != 1:\n            raise ValueError(\"      .\")\n\n        try:\n            block_region = utils.simplify_crv_by_reducing_segments(block_region[0], TOL)\n        except Exception:\n            print(\"   \")\n            block_region = block_region[0]\n\n        self.region = block_region\n\n    def _get_out_region(self, regions: List[geo.Curve]) -> geo.Curve:\n        \"\"\"    .\"\"\"\n        if len(regions) == 1:\n            return regions[0]\n\n        out_region = None\n\n        for candidate in regions:\n            contains_all = True\n            for other in regions:\n                if other is candidate:\n                    continue\n                if not utils.is_region_inside(other, candidate):\n                    contains_all = False\n                    break\n            if contains_all:\n                out_region = candidate\n                break\n\n        if out_region is None:\n            raise ValueError(\"        .\")\n\n        return out_region\n\n\nclass LayoutScore:\n    def __init__(\n        self,\n        region_score: float = 0.0,\n        shape_score: float = 0.0,\n        road_score: float = 0.0,\n        topo_score: float = 0.0,\n    ):\n        self.region_score = region_score\n        self.shape_score = shape_score\n        self.road_score = road_score\n        self.topo_score = topo_score\n\n    def __repr__(self):\n        #   \n        return f\"LayoutScore(region_score={self.region_score}, shape_score={self.shape_score}, road_score={self.road_score}, topo_score={self.topo_score})\"\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "curve", "functions", "block", "RhinoCommon"], "original_file": "969flash_parcel_layout_evaluation_analysis_b191c080f4.json", "repo": "969flash/parcel_layout_evaluation_analysis"}
{"instruction": "    ", "code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Any, Optional, Union\nimport math\nimport functools\nimport Rhino\nimport Rhino.Geometry as geo\nimport ghpythonlib.components as ghcomp\n\nfrom constants import TOL, ROUNDING_PRECISION, BIGNUM, OP_TOL, CLIPPER_TOL\n\n# Type Hinting\nCurveLike = Union[geo.Curve, List[geo.Curve]]\n\n\ndef convert_io_to_list(func):\n    \"\"\"    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        new_args = []\n        for arg in args:\n            if isinstance(arg, geo.Curve):\n                arg = [arg]\n            new_args.append(arg)\n\n        result = func(*new_args, **kwargs)\n        if isinstance(result, geo.Curve):\n            result = [result]\n        if hasattr(result, \"__dict__\"):\n            for key, values in result.__dict__.items():\n                if isinstance(values, geo.Curve):\n                    setattr(result, key, [values])\n        return result\n\n    return wrapper\n\n\n# ==============================================================================\n# 1.    (Core Geometry Utilities)\n# ==============================================================================\n\n\ndef get_distance_between_points(point_a: geo.Point3d, point_b: geo.Point3d) -> float:\n    \"\"\"    .\"\"\"\n    return round(point_a.DistanceTo(point_b), ROUNDING_PRECISION)\n\n\ndef get_distance_between_point_and_curve(point: geo.Point3d, curve: geo.Curve) -> float:\n    \"\"\"     .\"\"\"\n    _, param = curve.ClosestPoint(point)\n    dist = point.DistanceTo(curve.PointAt(param))\n    return round(dist, ROUNDING_PRECISION)\n\n\ndef get_distance_between_curves(curve_a: geo.Curve, curve_b: geo.Curve) -> float:\n    \"\"\"     .\"\"\"\n    _, pt_a, pt_b = curve_a.ClosestPoints(curve_b)\n    dist = pt_a.DistanceTo(pt_b)\n    return round(dist, ROUNDING_PRECISION)\n\n\ndef get_vector_from_pts(pt_a: geo.Point3d, pt_b: geo.Point3d) -> geo.Vector3d:\n    \"\"\"    .\"\"\"\n    return geo.Vector3d(pt_b.X - pt_a.X, pt_b.Y - pt_a.Y, pt_b.Z - pt_a.Z)\n\n\ndef get_vertices(curve: geo.Curve) -> List[geo.Point3d]:\n    \"\"\"  (Vertex) .\"\"\"\n    if not curve:\n        return []\n    vertices = [curve.PointAt(curve.SpanDomain(i)[0]) for i in range(curve.SpanCount)]\n    if not curve.IsClosed:\n        vertices.append(curve.PointAtEnd)\n    return vertices\n\n\ndef move_curve(curve: geo.Curve, vector: geo.Vector3d) -> geo.Curve:\n    \"\"\"     .\"\"\"\n    moved_curve = curve.Duplicate()\n    moved_curve.Translate(vector)\n    return moved_curve\n\n\ndef explode_curve(curve: geo.Curve) -> List[geo.Curve]:\n    \"\"\"     .\"\"\"\n    if not curve:\n        return []\n    if isinstance(curve, geo.PolyCurve):\n        return list(curve.DuplicateSegments())\n\n    segments = []\n    if curve.SpanCount > 0:\n        for i in range(curve.SpanCount):\n            sub_curve = curve.Trim(curve.SpanDomain(i))\n            if sub_curve:\n                segments.append(sub_curve)\n    elif curve.IsLinear():\n        segments.append(curve.Duplicate())\n\n    return segments\n\n\ndef get_pts_by_length(\n    crv: geo.Curve, length: float, include_start: bool = False\n) -> List[geo.Point3d]:\n    \"\"\"     .\"\"\"\n    params = crv.DivideByLength(length, include_start)\n    if not params:\n        return []\n    return [crv.PointAt(param) for param in params]\n\n\ndef get_area(regions: Union[List[geo.Curve], geo.Curve]) -> float:\n    \"\"\"   .\"\"\"\n    if not isinstance(regions, list):\n        regions = [regions]\n\n    area = sum([geo.AreaMassProperties.Compute(r).Area for r in regions])\n    return round(area, ROUNDING_PRECISION)\n\n\ndef get_length(curve: geo.Curve) -> float:\n    \"\"\"  .\"\"\"\n    if not curve:\n        return 0.0\n    length = curve.GetLength()\n    return round(length, ROUNDING_PRECISION)\n\n\n# ==============================================================================\n# 2.    (Advanced Geometry Operations)\n# ==============================================================================\n\n\ndef has_intersection(\n    curve_a: geo.Curve,\n    curve_b: geo.Curve,\n    plane: geo.Plane = geo.Plane.WorldXY,\n    tol: float = TOL,\n) -> bool:\n    \"\"\"    .\"\"\"\n    return geo.Curve.PlanarCurveCollision(curve_a, curve_b, plane, tol)\n\n\ndef get_intersection_points(\n    curve_a: geo.Curve, curve_b: geo.Curve, tol: float = TOL\n) -> List[geo.Point3d]:\n    \"\"\"    .\"\"\"\n    intersections = geo.Intersect.Intersection.CurveCurve(curve_a, curve_b, tol, tol)\n    if not intersections:\n        return []\n    return [event.PointA for event in intersections if event.IsPointAValid]\n\n\ndef has_region_intersection(\n    region_a: geo.Curve, region_b: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"    ( ) .\"\"\"\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        region_a, region_b, geo.Plane.WorldXY, tol\n    )\n    return relationship != geo.RegionContainment.Disjoint\n\n\ndef is_region_inside(\n    inner_region: geo.Curve, outer_region: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"     .\"\"\"\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        inner_region, outer_region, geo.Plane.WorldXY, tol\n    )\n\n    return relationship == geo.RegionContainment.AInsideB\n\n\ndef get_overlapped_curves(curve_a: geo.Curve, curve_b: geo.Curve) -> List[geo.Curve]:\n    \"\"\"     .\"\"\"\n    if not has_intersection(curve_a, curve_b) or not ghcomp:\n        return []\n\n    intersection_points = get_intersection_points(curve_a, curve_b)\n    explode_result = ghcomp.Explode(curve_a, True)\n    explode_points = (\n        explode_result.vertices + intersection_points\n        if explode_result\n        else intersection_points\n    )\n\n    if not explode_points:\n        return []\n\n    params = [ghcomp.CurveClosestPoint(pt, curve_a).parameter for pt in explode_points]\n    shatter_result = ghcomp.Shatter(curve_a, params)\n\n    if not shatter_result:\n        return []\n\n    overlapped_segments = [\n        seg for seg in shatter_result if has_intersection(seg, curve_b)\n    ]\n    if not overlapped_segments:\n        return []\n\n    return geo.Curve.JoinCurves(overlapped_segments)\n\n\ndef get_overlapped_length(curve_a: geo.Curve, curve_b: geo.Curve) -> float:\n    \"\"\"     .\"\"\"\n    overlapped_curves = get_overlapped_curves(curve_a, curve_b)\n    if not overlapped_curves:\n        return 0.0\n    return sum(crv.GetLength() for crv in overlapped_curves)\n\n\ndef get_min_bbox(region: geo.Curve) -> geo.BoundingBox:\n    \"\"\"       .\"\"\"\n\n    # 1.  \n    pts = get_vertices(region)\n    hull_pts = ghcomp.ConvexHull(pts, geo.Plane.WorldXY).indices\n    if not hull_pts:\n        raise ValueError(\"   \")\n\n    # 2.     \n    bbox_list = []\n    for i in range(len(hull_pts)):\n        pt_a = pts[hull_pts[i]]\n        pt_b = pts[hull_pts[(i + 1) % len(hull_pts)]]\n        # get_plane form pt_a to pt_b\n        line = geo.Line(pt_a, pt_b)\n        dir_vector = line.Direction\n        normal_vector = geo.Vector3d.CrossProduct(dir_vector, geo.Vector3d.ZAxis)\n        plane = geo.Plane(pt_a, dir_vector, normal_vector)\n        bbox = region.GetBoundingBox(plane)\n        bbox_list.append(bbox)\n\n    # 3.    \n    min_bbox = min(bbox_list, key=lambda b: b.Area)\n\n    return min_bbox\n\n\nclass Offset:\n    class _OffsetResult:\n        def __init__(self):\n            self.contour: Optional[List[geo.Curve]] = None\n            self.holes: Optional[List[geo.Curve]] = None\n\n    @convert_io_to_list\n    def polyline_offset(\n        self,\n        crvs: List[geo.Curve],\n        dists: List[float],\n        miter: int = BIGNUM,\n        closed_fillet: int = 2,\n        open_fillet: int = 2,\n        tol: float = Rhino.RhinoMath.ZeroTolerance,\n    ) -> _OffsetResult:\n        \"\"\"\n        Args:\n            crv (_type_): _description_\n            dists (_type_): _description_\n            miter : miter\n            closed_fillet : 0 = round, 1 = square, 2 = miter\n            open_fillet : 0 = round, 1 = square, 2 = butt\n\n        Returns:\n            _type_: _OffsetResult\n        \"\"\"\n        if not crvs:\n            raise ValueError(\"No Curves to offset\")\n\n        plane = geo.Plane(geo.Point3d(0, 0, crvs[0].PointAtEnd.Z), geo.Vector3d.ZAxis)\n        result = ghcomp.ClipperComponents.PolylineOffset(\n            crvs,\n            dists,\n            plane,\n            tol,\n            closed_fillet,\n            open_fillet,\n            miter,\n        )\n\n        polyline_offset_result = Offset._OffsetResult()\n        for name in (\"contour\", \"holes\"):\n            setattr(polyline_offset_result, name, result[name])\n        return polyline_offset_result\n\n\ndef offset_regions_inward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n\n    Returns:\n        offset  \n    \"\"\"\n\n    if not dist:\n        return regions\n    result = Offset().polyline_offset(regions, dist, miter).holes\n\n    if not result:\n        return []\n\n    if isinstance(regions, geo.Curve):\n        regions = [regions]\n\n    if len(result) < 2:\n        return result\n\n    filtered = [\n        crv for crv in result if any(is_region_inside(crv, reg) for reg in regions)\n    ]\n    return filtered\n\n\ndef offset_regions_outward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n    returns:\n        offset  \n    \"\"\"\n    if isinstance(regions, geo.Curve):\n        regions = [regions]\n\n    return [offset_region_outward(region, dist, miter) for region in regions]\n\n\ndef simplify_regions_with_offset(\n    regions: List[geo.Curve], dist: float, miter: int = BIGNUM\n) -> Union[List[geo.Curve], geo.Curve]:\n    \"\"\"   offset  .\n     dist     .\n    Args:\n        region:   \n        dist:  offset \n\n    Returns:\n          \n    \"\"\"\n    if not regions:\n        return []\n\n    if dist <= 0.0:\n        return regions\n\n    inner = offset_regions_inward(regions, dist * 0.5, miter)\n    if not inner:\n        return []\n\n    outer = offset_regions_outward(inner, dist * 0.5, miter)\n\n    # NOTE:\n    # in -> out  /    (regions) \n    #      .\n    #  (  ) score > 1     \n    #     .\n    clamped = get_intersection_regions(outer, regions)\n    return clamped\n\n\n# ==============================================================================\n# 2.1     Simplify ( )\n# ==============================================================================\n\n\ndef simplify_crv_by_reducing_segments(\n    crv: geo.Curve,\n    tol: float = TOL,\n    angle_tol: Optional[float] = None,\n) -> geo.Curve:\n    \"\"\"MergeColinearSegments + ReduceSegments  .\n\n    - colinear()   , / tol    .\n    -   /    .\n    - /    .\n    \"\"\"\n    if crv is None:\n        return crv\n\n    if angle_tol is None:\n        #  constants.ANGLE_TOL ,   1()\n        try:\n            from constants import ANGLE_TOL as _ANGLE_TOL  # type: ignore\n\n            angle_tol = float(_ANGLE_TOL)\n        except Exception:\n            angle_tol = math.radians(1.0)\n\n    # vertices  polyline \n    pts = get_vertices(crv)\n    if not pts:\n        return crv\n    if crv.IsClosed:\n        pts.append(pts[0])\n\n    pl = geo.Polyline(pts)\n\n    # colinear    \n    try:\n        pl.MergeColinearSegments(angle_tol, True)\n    except Exception:\n        pass\n    try:\n        pl.ReduceSegments(tol)\n    except Exception:\n        pass\n\n    #    (  ReduceSegments   )\n    try:\n        if pl.IsClosed and pl.Count > 3:\n            pt_items = list(pl.Item)\n            pt_first = pt_items[0]\n            pt1 = pt_items[1]\n            pt2 = pt_items[pl.Count - 2]\n            if geo.Line(pt1, pt2).DistanceTo(pt_first, True) <= tol:\n                pl.RemoveAt(0)\n                pl.RemoveAt(pl.Count - 1)\n                pl.Add(pl.First)\n    except Exception:\n        pass\n\n    polycrv = pl.ToPolylineCurve()\n    if not getattr(polycrv, \"IsValid\", False):\n        #  /   \n        return crv\n    return polycrv\n\n\ndef simplify_crvs_by_reducing_segments(\n    crvs: List[geo.Curve], tol: float = TOL, angle_tol: Optional[float] = None\n) -> List[geo.Curve]:\n    \"\"\"       \"\"\"\n    if not crvs:\n        return []\n    out: List[geo.Curve] = []\n    for r in crvs:\n        try:\n            out.append(simplify_crv_by_reducing_segments(r, tol, angle_tol))\n        except Exception:\n            out.append(r)\n    return out\n\n\ndef offset_region_outward(\n    region: geo.Curve, dist: float, miter: float = BIGNUM\n) -> geo.Curve:\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n\n    Returns:\n        offset  \n    \"\"\"\n\n    if not dist:\n        return region\n    if not isinstance(region, geo.Curve):\n        raise ValueError(\"region must be curve\")\n    return Offset().polyline_offset(region, dist, miter).contour[0]\n\n\nclass RegionBool:\n    @convert_io_to_list\n    def _polyline_boolean(\n        self, crvs0, crvs1, boolean_type=None, plane=None, tol=CLIPPER_TOL\n    ):\n        # type: (List[geo.Curve], List[geo.Curve], int, geo.Plane, float) -> List[geo.Curve]\n        if not crvs0 or not crvs1:\n            raise ValueError(\"Check input values\")\n        result = ghcomp.ClipperComponents.PolylineBoolean(\n            crvs0, crvs1, boolean_type, plane, tol\n        )\n\n        #  IronPython.Runtime.List ( list )       list \n        if not result:\n            return []\n\n        # IronPython.Runtime.List, System.Collections.Generic.List, tuple      \n        if isinstance(result, geo.Curve):\n            #   \n            result = [result]\n        else:\n            try:\n                # IEnumerable / IronPython.Runtime.List / tuple / System.Collections.Generic.List  list()  \n                result = [crv for crv in list(result) if crv]\n            except TypeError:\n                #      \n                result = [result]\n\n        return result\n\n    def polyline_boolean_intersection(self, crvs0, crvs1, plane=None, tol=CLIPPER_TOL):\n        # type: (Union[geo.Curve, List[geo.Curve]], Union[geo.Curve, List[geo.Curve]], geo.Plane, float) -> List[geo.Curve]\n        return self._polyline_boolean(crvs0, crvs1, 0, plane, tol)\n\n    def polyline_boolean_union(self, crvs0, crvs1, plane=None, tol=CLIPPER_TOL):\n        # type: (Union[geo.Curve, List[geo.Curve]], Union[geo.Curve, List[geo.Curve]], geo.Plane, float) -> List[geo.Curve]\n        return self._polyline_boolean(crvs0, crvs1, 1, plane, tol)\n\n    def polyline_boolean_difference(self, crvs0, crvs1, plane=None, tol=CLIPPER_TOL):\n        # type: (Union[geo.Curve, List[geo.Curve]], Union[geo.Curve, List[geo.Curve]], geo.Plane, float) -> List[geo.Curve]\n        return self._polyline_boolean(crvs0, crvs1, 2, plane, tol)\n\n\ndef get_intersection_regions(\n    regions_a: List[geo.Curve], regions_b: List[geo.Curve]\n) -> List[geo.Curve]:\n    \"\"\"     .\n    Args:\n        regions_a:     \n        regions_b:     \n    Returns:\n          \n    \"\"\"\n    if not regions_a or not regions_b:\n        return []\n    intersection_result = RegionBool().polyline_boolean_intersection(\n        regions_a, regions_b\n    )\n    return intersection_result\n\n\ndef get_union_regions(regions: List[geo.Curve] = None) -> List[geo.Curve]:\n    \"\"\"    .\n    Args:\n        regions:    \n    Returns:\n          \n    \"\"\"\n    if not regions:\n        return []\n\n    if len(regions) == 1:\n        return regions\n\n    union_result = list(geo.Curve.CreateBooleanUnion(regions, TOL))\n    if union_result:\n        return union_result\n\n    union_result = regions[0]\n    for region in regions[1:]:\n        union_result = RegionBool().polyline_boolean_union(union_result, region)\n\n    if not isinstance(union_result, list):\n        union_result = [union_result]\n\n    return union_result\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "line", "curve", "functions", "RhinoCommon"], "original_file": "969flash_parcel_layout_evaluation_analysis_d2fb3862ff.json", "repo": "969flash/parcel_layout_evaluation_analysis"}
{"instruction": "crv  lenth  .", "code": "# -*- coding:utf-8 -*-\ntry:\n    from typing import List, Tuple, Dict, Any, Optional, Union\nexcept ImportError:\n    pass\nimport collections\nfrom operator import attrgetter\nimport functools\n\nimport Rhino\nimport Rhino.Geometry as geo  # ignore\nimport ghpythonlib.components as ghcomp  # ignore\n\nBIGNUM = 10000000\n\nTOL = 0.001\nDIST_TOL = 0.01\nAREA_TOL = 0.1\nOP_TOL = 0.00001\nCLIPPER_TOL = 0.0000000001\n\n\ndef trim_crv_from_length(crv, length, reverse=False):\n    # type: (geo.Curve, float, bool) -> geo.Curve\n    \"\"\"crv  lenth  .\"\"\"\n    is_len_possible, param = crv.LengthParameter(length)\n    if not is_len_possible:\n        return crv\n\n    ## for Rhino 8, REMOVE FOR RHINO7 !!!##\n    param = float(param)\n    ########################################\n\n    if reverse:\n        return crv.Trim(param, crv.Domain.Max)\n    return crv.Trim(0.0, param)\n\n\ndef trim_crv_from_length(crv, length, reverse=False):\n    # type: (geo.Curve, float, bool) -> geo.Curve\n    \"\"\"crv  lenth  .\"\"\"\n    is_len_possible, param = crv.LengthParameter(length)\n    if not is_len_possible:\n        return crv\n\n    ## for Rhino 8, REMOVE FOR RHINO7 !!!##\n    param = float(param)\n    ########################################\n\n    if reverse:\n        return crv.Trim(param, crv.Domain.Max)\n    return crv.Trim(0.0, param)\n\n\ndef get_length(crvs, ndigits=3):\n    # type: (List[geo.Curve], int) -> float\n    if not isinstance(crvs, list):\n        return round(crvs.GetLength(), ndigits)\n    length = 0\n    for crv in crvs:\n        length += round(crv.GetLength(), ndigits)\n    return length\n\n\ndef get_dist_from_crv_crv(crv_a, crv_b):\n    # type: (geo.Curve, geo.Curve) -> float\n    \"\"\"    .\n\n    Args:\n        crv_a : crv_b   \n        crv_b : crv_a   \n\n    Returns:\n           \n    \"\"\"\n    _, a, b = crv_a.ClosestPoints(crv_b)\n    dist = a.DistanceTo(b)\n    dist = round(dist, 6)\n    return dist\n\n\ndef is_intersection_with_other_crvs(crv, crvs):\n    # type: (geo.Curve, List[geo.Curve]) -> bool\n    return any(\n        geo.Curve.PlanarCurveCollision(crv, other_crv, geo.Plane.WorldXY, OP_TOL)\n        for other_crv in crvs\n    )\n\n\ndef offset_regions_inward(regions, dist, miter=BIGNUM):\n    # type: (geo.Curve | List[geo.Curve], float, int) -> List[geo.Curve]\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n\n    Returns:\n        offset  \n    \"\"\"\n\n    if not dist:\n        return regions\n    return Offset().polyline_offset(regions, dist, miter).holes\n\n\ndef offset_region_outward(region, dist, miter=BIGNUM):\n    # type: (geo.Curve, float, float) -> geo.Curve\n    \"\"\"   offset .\n         .\n    Args:\n        region: offset  \n        dist: offset \n\n    Returns:\n        offset  \n    \"\"\"\n\n    if not dist:\n        return region\n    if not isinstance(region, geo.Curve):\n        raise ValueError(\"region must be curve\")\n    return Offset().polyline_offset(region, dist, miter).contour[0]\n\n\ndef convert_io_to_list(func):\n    \"\"\"    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        new_args = []\n        for arg in args:\n            if isinstance(arg, geo.Curve):\n                arg = [arg]\n            new_args.append(arg)\n\n        result = func(*new_args, **kwargs)\n        if isinstance(result, geo.Curve):\n            result = [result]\n        if hasattr(result, \"__dict__\"):\n            for key, values in result.__dict__.items():\n                if isinstance(values, geo.Curve):\n                    setattr(result, key, [values])\n        return result\n\n    return wrapper\n\n\nclass Offset:\n    class _PolylineOffsetResult:\n        def __init__(self):\n            self.contour = None  # type: Optional[List[geo.Curve]]\n            self.holes = None  # type: Optional[List[geo.Curve]]\n\n    @convert_io_to_list\n    def polyline_offset(\n        self,\n        crvs,\n        dists,\n        miter=BIGNUM,\n        closed_fillet=2,\n        open_fillet=2,\n        tol=Rhino.RhinoMath.ZeroTolerance,\n    ):\n        # type: (List[geo.Curve], List[float], int, int, int, float) -> _PolylineOffsetResult\n        \"\"\"\n        Args:\n            crv (_type_): _description_\n            dists (_type_): _description_\n            miter : miter\n            closed_fillet : 0 = round, 1 = square, 2 = miter\n            open_fillet : 0 = round, 1 = square, 2 = butt\n\n        Returns:\n            _type_: _PolylineOffsetResult\n        \"\"\"\n        if tol == Rhino.RhinoMath.ZeroTolerance and open_fillet == 0:\n            raise ValueError(\"open_fillet must be 1 or 2\")\n\n        if not crvs:\n            raise ValueError(\"crvs must be more than 1\")\n\n        plane = geo.Plane(geo.Point3d(0, 0, crvs[0].PointAtEnd.Z), geo.Vector3d.ZAxis)\n        result = ghcomp.ClipperComponents.PolylineOffset(\n            crvs,\n            dists,\n            plane,\n            tol,\n            closed_fillet,\n            open_fillet,\n            miter,\n        )\n\n        polyline_offset_result = Offset._PolylineOffsetResult()\n        for name in (\"contour\", \"holes\"):\n            setattr(polyline_offset_result, name, result[name])\n        return polyline_offset_result\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "line", "curve", "functions", "RhinoCommon"], "original_file": "969flash_urban__auto_mass_70f87f8fb9.json", "repo": "969flash/urban__auto_mass"}
{"instruction": "Implement the function 'runml' for Rhino scripting", "code": "from typing import ItemsView, Literal\nfrom flask import Flask\nimport ghhops_server as hs\nfrom ghhops_server.params import HopsNumber\nimport rhino3dm\nimport numpy as np\nimport os\nimport sys\n#import tensorflow as tf\nimport pickle\nimport joblib\nimport machinelearning as ml\n\nos.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n\napp = Flask(__name__)\nhops = hs.Hops(app)\n\n@hops.component(\n    \"/runML11\",\n    name=\"runML11\",\n    description=\"Run Machine Learning prediction\",\n    icon=\"examples/pointat.png\",\n    inputs=[\n        hs.HopsNumber(\"Construction Time\", \"Time\", \"Construction Time\"),\n        hs.HopsNumber(\"Construction Cost\", \"Cost\", \"Construction Cost\"),\n        hs.HopsNumber(\"Rotation angle from North\", \"Rotation\", \"Rotation Angle\"),\n    ],\n    outputs=[\n        hs.HopsNumber(\"Length X\", \"X\", \"Length X\"),\n        hs.HopsNumber(\"Length Y\", \"Y\", \"Length Y\"),\n        hs.HopsNumber(\"Wall Panels number\", \"Wall N\", \"Wall Panels number\"),\n        hs.HopsNumber(\"Window Panels number\", \"Window N\", \"Window Panels number\"),\n        hs.HopsNumber(\"Spatial Daylight Autonomy\", \"sDA\", \"Spatial Daylight Autonomy\"),\n        hs.HopsNumber(\"Total Electricity consumption\", \"Electricity\", \"Total Electricity Consumption\"),\n        hs.HopsNumber(\"Light Electricity consumption\", \"Light\", \"Light Electricity Consumption\"),\n        hs.HopsNumber(\"Cooling Electricity consumption\", \"Cooling\", \"Cooling Electricity Consumption\"),\n        hs.HopsNumber(\"Heating Electricity consumption\", \"Heating\", \"Heating Electricity Consumption\"),\n        hs.HopsNumber(\"TerraceCost\", \"TerraceCost\", \"TerraceCost\"),\n        hs.HopsNumber(\"WindowCost\", \"WindowCost\", \"WindowCost\"),\n        hs.HopsNumber(\"FacadeCost\", \"FacadeCost\", \"FacadeCost\"),\n        hs.HopsNumber(\"InteriorCost\", \"InteriorCost\", \"InteriorCost\"),\n        hs.HopsNumber(\"Colormesh\", \"Colormesh\", \"Colormesh\",hs.HopsParamAccess.LIST)\n\n      ]\n)\n\ndef runml(a,b,c):\n    \n\n    return ml.runml(a,b,c)\n\n  \n\nif __name__ == \"__main__\":\n   app.run(debug=True)\n\n\n\n   \n#######################################\n#BONUS HINT\n\n#if you had a scaler in your training you should have had this\n##Normalize data using standard scaling\n#scalerY = StandardScaler().fit(outputArr)\n#y_scaled = scalerY.transform(outputArr)\n#print(\"y_scaled\", np.amin(y_scaled), np.amax(y_scaled))\n\n##Save scaler model for later use\n#joblib.dump(scalerY, 'scalerY.pkl')\n\n#SO YOU NEED TO\n#Load scaler for inverse transformation\n#scalerY = joblib.load(\"scalerY.pkl\")\n#And apply it to either input or output\n\n#########################################", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["mesh", "functions", "point"], "original_file": "AIA-Studio-IaaC-G06_PFHG_b84ffec2f6.json", "repo": "AIA-Studio-IaaC-G06/PFHG"}
{"instruction": "**********************************************************************************", "code": "import rhinoscriptsyntax as rs\nimport Rhino.Geometry as rg\nimport scriptcontext as sc\n\n__author__ = 'Arash Adel'\n__email__ = '<aaadel@umich.edu>'\n__copyright__ = 'Copyright 2020, Arash Adel'\n\n\"\"\"\n**********************************************************************************\nBrick Class\n**********************************************************************************\n\"\"\"\n\n\nclass Brick(object):\n\n    def __init__(self, frame, dim, is_half_brick=False):\n        \"\"\"\n        A Brick with the following main attributes:\n        frame: rg.Plane\n        dim:  (length, width, height)\n        col, shape, material\n        \"\"\"\n        self.frame = frame\n        self.dim = dim\n        if not is_half_brick:\n            self.length = self.dim[0]\n        else:\n            self.length = self.dim[0]/2.0\n        self.width = self.dim[1]\n        self.height = self.dim[2]\n\n        # Half Dimensions\n        self.half_length = self.length / 2.0\n        self.half_width = self.width / 2.0\n        self.half_height = self.height / 2.0\n\n        # Corner point of the brick\n        self.points = []\n        # Brick Brep\n        self.shape = self.add_brick()\n\n    def __str__(self):\n        \"\"\"\n        Returns a message of the attributes of the brick.\n        \"\"\"\n        message = \"A brick with the following attributes: \"\n        cor_attr = \"Coordinate = {}\".format(tuple(self.frame.Origin))\n        dim_attr = \"dimensions = {}\".format(self.dim)\n        return message + cor_attr + \" and \" + dim_attr\n\n    def add_brick(self):\n        \"\"\"\n        Adds a Rhino box based on the center, orientation,\n        and the dimennsions of the brick.\n                pt_3------------------------pt_0\n                    |          ^y          |\n                    |          |           |\n                    |          cp--->x     |\n                    |                      |\n                    |                      |\n                pt_2------------------------pt_1\n        \"\"\"\n        # Center Point\n        cp = self.frame.Origin\n\n        # Translation Vectors\n        t_vec_x = rg.Vector3d.Multiply(self.frame.XAxis, self.half_length)\n        t_vec_y = rg.Vector3d.Multiply(self.frame.YAxis, self.half_width)\n        t_vec_z = rg.Vector3d.Multiply(self.frame.ZAxis, self.half_height)\n\n        # Translation vectors on the plane of the brick\n        t_vec_0 = rg.Vector3d.Add(t_vec_x, t_vec_y)\n        t_vec_1 = rg.Vector3d.Add(t_vec_x, -t_vec_y)\n        t_vec_2 = rg.Vector3d.Add(-t_vec_x, -t_vec_y)\n        t_vec_3 = rg.Vector3d.Add(-t_vec_x, t_vec_y)\n\n        # Corner points\n        # Negative z\n        pt_0 = rg.Point3d.Add(cp, rg.Vector3d.Add(t_vec_0, - t_vec_z))\n        pt_1 = rg.Point3d.Add(cp, rg.Vector3d.Add(t_vec_1, - t_vec_z))\n        pt_2 = rg.Point3d.Add(cp, rg.Vector3d.Add(t_vec_2, - t_vec_z))\n        pt_3 = rg.Point3d.Add(cp, rg.Vector3d.Add(t_vec_3, - t_vec_z))\n\n        # Positive z\n        pt_4 = rg.Point3d.Add(cp, rg.Vector3d.Add(t_vec_0, t_vec_z))\n        pt_5 = rg.Point3d.Add(cp, rg.Vector3d.Add(t_vec_1, t_vec_z))\n        pt_6 = rg.Point3d.Add(cp, rg.Vector3d.Add(t_vec_2, t_vec_z))\n        pt_7 = rg.Point3d.Add(cp, rg.Vector3d.Add(t_vec_3, t_vec_z))\n\n        # List of corner points\n        bott_points = [pt_0, pt_1, pt_2, pt_3]\n        top_points = [pt_4, pt_5, pt_6, pt_7]\n        self.points = bott_points + top_points\n\n        brick_brep = rg.Brep.CreateFromBox(self.points)\n        return brick_brep\n\n    def draw_brick(self):\n        \"\"\"\n        Adds the brep of the brick to the Rhino enviroment.\n        \"\"\"\n        self.shape_id = sc.doc.Objects.AddBrep(self.shape)\n\n    def set_col(self, new_col):\n        \"\"\"Setter for the new color.\n        \"\"\"\n        self.col = new_col\n        rs.ObjectColor(self.shape_id, self.col)\n\n    def set_material(self, material=None):\n        \"\"\"\n        Setter for the new material.\n        \"\"\"\n        if material is None:\n            self.material = self.col\n        else:\n            self.material = material\n        mat_index = rs.AddMaterialToObject(self.shape_id)\n        rs.MaterialColor(mat_index, self.material)\n\n    def check_collision(self, other):\n        \"\"\"Checks the collision with another brick\n        \"\"\"\n        bb_intersect = rg.Intersect.Intersection.BrepBrep(\n            self.shape, other.shape, 0.001)\n        return bb_intersect\n\n    def rotate_brick(self, rot_val):\n        \"\"\"Rotates the brick around its zaxis by the rot_val\n\n        Args:\n            rot_val (float): value in radians\n        \"\"\"\n        self.frame.Rotate(rot_val, self.frame.ZAxis, self.frame.Origin)\n        self.shape = self.add_brick()\n\n    def get_center_point(self):\n        \"\"\"Getter for the center point of the brick\n        \"\"\"\n        return self.frame.Origin\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "classes", "point", "brep", "dimension", "functions", "RhinoCommon"], "original_file": "AdelResearchGroup_robotic_fabrication_w23_57eb4f92ce.json", "repo": "AdelResearchGroup/robotic_fabrication_w23"}
{"instruction": "Construct an egi from a set of vectors.", "code": "from __future__ import absolute_import\nfrom __future__ import print_function\nfrom __future__ import division\n\nimport compas\n\nfrom compas.datastructures import Network\n\nfrom compas.geometry import add_vectors\nfrom compas.geometry import distance_point_point as distance\nfrom compas.geometry import dot_vectors\nfrom compas.geometry import cross_vectors\nfrom compas.geometry import normalize_vector\nfrom compas.geometry import subtract_vectors\n\nfrom compas.datastructures.network.duality import network_node_find_first_neighbor\n\nfrom compas.utilities import geometric_key\n\nfrom compas_3gs.diagrams import EGI\nfrom compas_3gs.diagrams import Cell\n\ntry:\n    from Rhino.Geometry import Arc\n    from Rhino.Geometry import Point3d\n    from Rhino.Geometry import ArcCurve\n    from Rhino.Geometry import Vector3d\n    from Rhino.Geometry import Circle\n    from Rhino.Geometry import Plane\n\n    from Rhino.Geometry.Intersect.Intersection import CurveCurve as CCX\n\nexcept ImportError:\n    compas.raise_if_ironpython()\n\n\n__all__ = ['egi_from_vectors',\n           'cell_from_egi']\n\n\ndef egi_from_vectors(vectordict, origin, tol=0.001):\n    \"\"\"Construct an egi from a set of vectors.\n\n    Parameters\n    ----------\n    vectordict : dict\n        A dectionary of key-vector pairs.\n    origin : list\n        The coordinates of the centroid.\n    tol : float, optional\n        Tolerance for evaluating antipodal.\n\n    Returns\n    -------\n    egi : mesh\n        A mesh object representing the egi.\n\n    Raises\n    ------\n    Exception\n        If there are less than four vectors.\n\n    Notes\n    -----\n    This algorithm is dependent on Rhinoceros objects; the adjacency arcs are implemented using Rhino.Geometry.Arc,\n    and the cross-adjacencies (arc-arc intersections) are computed using Rhino.Geometry.Intersect.Intersection.CurveCurve.\n\n    Warning\n    -------\n    - This algorithm does not address scenarios where multiple parallel (collinear) vectors are present.\n\n    References\n    ----------\n    - Horn, B.K.P. (1984). *Extended Gaussian images*.\n    - Moni, S. (1990, June). *A closed-form solution for the reconstruction\n    of a convex polyhedron from its extended gaussian image.*\n    - Lee, J., T. Van Mele, and P. Block (2018). *Disjointed force polyhedra.*\n\n    \"\"\"\n    if len(vectordict) < 4:\n        raise Exception('Four or more vectors are needed for the construction of egi.')\n\n    egi = Network()\n\n    # --------------------------------------------------------------------------\n    #   1. add vertices from vectors\n    # --------------------------------------------------------------------------\n    vertex_geokeys = {}\n\n    for vkey in vectordict:\n        normal = normalize_vector(vectordict[vkey])\n        vertex_xyz = add_vectors(normal, origin)\n        vertex_geokeys[geometric_key(normal)] = vkey\n        egi.add_vertex(x=vertex_xyz[0],\n                       y=vertex_xyz[1],\n                       z=vertex_xyz[2],\n                       key=vkey,\n                       attr_dict={'type': 'face',\n                                  'normal': normal,\n                                  'nbrs': []})\n\n    # --------------------------------------------------------------------------\n    #   2.  Identify main adjacencies\n    # --------------------------------------------------------------------------\n    vkey_pairs = set()\n\n    for vkey in egi.vertex:\n        v_crs_dict = {}\n\n        for nbr_vkey in egi.vertex:\n\n            if nbr_vkey is not vkey:\n\n                n1 = egi.vertex[vkey]['normal']\n                n2 = egi.vertex[nbr_vkey]['normal']\n\n                # This checks if the normals are opposite ----------------------\n                dot = dot_vectors(n1, n2)\n\n                if dot > 1 - tol:\n                    raise Exception(\"Coincident vectors detected.\")\n\n                elif dot > -1 + tol:\n\n                    this_crs = cross_vectors(n1, n2)\n                    unit_crs = normalize_vector(this_crs)\n\n                    crs_gkey = geometric_key(unit_crs)\n\n                    # Check to see if any other normals are coplanar\n                    if crs_gkey not in v_crs_dict:\n                        v_crs_dict[crs_gkey] = nbr_vkey\n\n                    # If multiple arcs are coplanar, choose the closer one\n                    elif crs_gkey in v_crs_dict:\n                        this_dist = distance(egi.vertex_coordinates(vkey),\n                                             egi.vertex_coordinates(nbr_vkey))\n                        test_dist = distance(egi.vertex_coordinates(vkey),\n                                             egi.vertex_coordinates(v_crs_dict[crs_gkey]))\n                        if this_dist < test_dist:\n                            del v_crs_dict[crs_gkey]\n                            v_crs_dict[crs_gkey] = nbr_vkey\n\n        # Add to overall connectivity dict -------------------------------------\n        for crs_gkey in v_crs_dict:\n            nbr_vkey = v_crs_dict[crs_gkey]\n            pair = frozenset([vkey, nbr_vkey])\n            vkey_pairs.add(pair)\n\n    # --------------------------------------------------------------------------\n    #   3.  Main adjacency arcs\n    # --------------------------------------------------------------------------\n    arcs = {}\n\n    for pair in vkey_pairs:\n        u, v = list(pair)\n        arc = _draw_arc(egi.vertex[u]['normal'],\n                        egi.vertex[v]['normal'],\n                        origin)\n\n        if len(arcs) == 0:\n            arc_key = 0\n        else:\n            arc_key = max(int(x) for x in arcs.keys()) + 1\n        arcs[arc_key] = {'arc': arc,\n                         'vkeys': [u, v],\n                         'end_vkeys': [u, v],\n                         'int_vkeys': {}, }\n\n    # --------------------------------------------------------------------------\n    #   3.  arc intersections --> cross adjacencies\n    # --------------------------------------------------------------------------\n    arc_pairs_seen = set()\n    for arckey_1 in arcs:\n        for arckey_2 in arcs:\n            if arckey_1 != arckey_2:\n                arc_pair = frozenset([arckey_1, arckey_2])\n                if arc_pair not in arc_pairs_seen:\n                    arc_1 = arcs[arckey_1]['arc']\n                    arc_2 = arcs[arckey_2]['arc']\n                    intersection = _curve_curve_intx(arc_1, arc_2)\n                    if intersection:\n                        new_vkey = max(int(vkey) for vkey in egi.vertex.keys()) + 1\n                        new_normal = subtract_vectors(intersection, origin)\n                        new_normal = normalize_vector(new_normal)\n                        new_vertex_geokey = geometric_key(new_normal, precision='3f')\n\n                        # if intersection is not an endpoint -------------------\n                        if new_vertex_geokey not in vertex_geokeys.keys():\n                            vertex_geokeys[new_vertex_geokey] = new_vkey\n                            egi.add_vertex(x=intersection[0],\n                                           y=intersection[1],\n                                           z=intersection[2],\n                                           key=new_vkey,\n                                           attr_dict={'type': 'zero',\n                                                      'normal': new_normal,\n                                                      'magnitude': 0,\n                                                      'nbrs': []})\n                            arcs[arckey_1]['vkeys'].append(new_vkey)\n                            arcs[arckey_2]['vkeys'].append(new_vkey)\n                            arcs[arckey_1]['int_vkeys'][new_vkey] = arckey_2\n                            arcs[arckey_2]['int_vkeys'][new_vkey] = arckey_1\n\n                        # if intersection already exists -----------------------\n                        elif new_vertex_geokey in vertex_geokeys.keys():\n                            vkey = vertex_geokeys[new_vertex_geokey]\n                            if vkey not in arcs[arckey_1]['vkeys']:\n                                arcs[arckey_1]['vkeys'].append(vkey)\n                                arcs[arckey_1]['int_vkeys'][vkey] = arckey_2\n                            if vkey not in arcs[arckey_2]['vkeys']:\n                                arcs[arckey_2]['vkeys'].append(vkey)\n                                arcs[arckey_2]['int_vkeys'][vkey] = arckey_1\n                        arc_pairs_seen.add(arc_pair)\n\n    # --------------------------------------------------------------------------\n    #   5.  Reorder vertices along each arc and add edges to EGI network\n    # --------------------------------------------------------------------------\n    for arckey in arcs:\n        vkeys = arcs[arckey]['vkeys']\n        if len(vkeys) > 2:\n            pt_list = [egi.vertex_coordinates(key) for key in vkeys]\n            arcs[arckey]['vkeys'] = _reorder_pts_on_arc(pt_list,\n                                                        arcs[arckey]['vkeys'],\n                                                        arcs[arckey]['arc'])[1]\n        #     edge_type = 'cross'\n        # else:\n        #     edge_type = 'main'\n        for i in range(len(arcs[arckey]['vkeys']) - 1):\n            vkey_1 = arcs[arckey]['vkeys'][i]\n            vkey_2 = arcs[arckey]['vkeys'][i + 1]\n            egi.vertex[vkey_1]['nbrs'] += [vkey_2]\n            egi.vertex[vkey_2]['nbrs'] += [vkey_1]\n            egi.add_edge(vkey_1, vkey_2)\n\n    # --------------------------------------------------------------------------\n    #   6.  For each vertex, sort nbrs in ccw order\n    # --------------------------------------------------------------------------\n    _egi_sort_v_nbrs(egi)\n\n    # --------------------------------------------------------------------------\n    #   7.  Add EGI Network faces\n    # --------------------------------------------------------------------------\n    egi_mesh = EGI()\n    for vkey in egi.vertex:\n        egi_mesh.vertex[vkey] = egi.vertex[vkey]\n\n    egi_mesh.attributes['name'] = 'egi'\n    egi_mesh.attributes['origin'] = list(origin)\n\n    _egi_find_faces(egi, egi_mesh)\n\n    return egi_mesh\n\n\n# ******************************************************************************\n# ******************************************************************************\n# ******************************************************************************\n#\n#   from egi to unit polyhedron\n#\n# ******************************************************************************\n# ******************************************************************************\n# ******************************************************************************\n\ndef cell_from_egi(egi):\n    \"\"\"Construct a cell from an egi.\n\n    Parameters\n    ----------\n    egi\n        A mesh object representing the egi.\n\n    Returns\n    -------\n    cell\n        A mesh object representing the unit polyhedron.\n\n    \"\"\"\n    cell = Cell()\n    cell.name = 'cell'\n\n    for fkey in egi.face:\n        x, y, z = egi.face_center(fkey)\n        cell.add_vertex(key=fkey, x=x, y=y, z=z)\n\n    for vkey in egi.vertex:\n        cell_face = egi.vertex_faces(vkey, ordered=True)\n        cell.add_face(cell_face[::-1], fkey=vkey)\n\n        cell.facedata[vkey]['type'] = egi.vertex[vkey]['type']\n\n    return cell\n\n\n# ******************************************************************************\n# ******************************************************************************\n# ******************************************************************************\n#\n#   helpers\n#\n# ******************************************************************************\n# ******************************************************************************\n# ******************************************************************************\n\n\ndef _draw_arc(normal_1, normal_2, origin):\n    mid_pt = normalize_vector(add_vectors(normal_1, normal_2))\n    arc = Arc(Point3d(*[sum(axis) for axis in zip(normal_1, origin)]),\n              Point3d(*[sum(axis) for axis in zip(mid_pt, origin)]),\n              Point3d(*[sum(axis) for axis in zip(normal_2, origin)]))\n    arc_as_curve = ArcCurve(arc)\n    return arc_as_curve\n\n\ndef _reorder_pts_on_arc(pt_list, pt_key_list, arc_curve):\n    # all points should be on the arc...\n    dist_list = []\n    sp = arc_curve.PointAtStart\n    for pt in pt_list:\n        dist_list.append(distance(sp, pt))\n    ordered_pt_list = [x for (y, x) in sorted(zip(dist_list, pt_list))]\n    ordered_pt_key_list = [x for (y, x) in sorted(zip(dist_list, pt_key_list))]\n    return ordered_pt_list, ordered_pt_key_list\n\n\ndef _curve_curve_intx(curve_1, curve_2):\n    intersection_tolerance = 0.01\n    overlap_tolerance = 0.0\n    intersection = CCX(curve_1,\n                       curve_2,\n                       intersection_tolerance,\n                       overlap_tolerance)\n    if not intersection:\n        return None\n    for instance in intersection:\n        return instance.PointA\n\n\ndef _egi_sort_v_nbrs(egi):\n    \"\"\" By default, the sorting should be ccw, since the circle is typically drawn\n    ccw around the local plane's z-axis...\n    \"\"\"\n    xyz = dict((key, [attr[_] for _ in 'xyz']) for key, attr in egi.vertices(True))\n    for vkey in egi.vertex:\n        nbrs = egi.vertex[vkey]['nbrs']\n        plane = Plane(Point3d(*xyz[vkey]),\n                      Vector3d(*[axis for axis in egi.vertex[vkey]['normal']]))\n        circle = Circle(plane, 1)\n        p_list = []\n        for nbr_vkey in nbrs:\n            boolean, parameter = ArcCurve(circle).ClosestPoint(Point3d(*xyz[nbr_vkey]))\n            p_list.append(parameter)\n        sorted_nbrs = [key for (param, key) in sorted(zip(p_list, nbrs))]\n        egi.vertex[vkey]['sorted_nbrs'] = sorted_nbrs\n\n\ndef _egi_find_edge_face(u, v, egi):\n    \"\"\" same as duality.algorithms.find_edge_faces... using 'sorted_nbrs' instead\n    \"\"\"\n    cycle = [u]\n    while True:\n        cycle.append(v)\n        nbrs = egi.vertex[v]['sorted_nbrs']\n        nbr = nbrs[nbrs.index(u) - 1]\n        u, v = v, nbr\n        if v == cycle[0]:\n            cycle.append(v)\n            break\n    return cycle\n\n\ndef _egi_find_faces(egi, egi_mesh):\n    \"\"\" Modified, and simplified version of duality.algorithms.find_network_faces...\n    since there are no leaves or open faces in a egi network.\n    \"\"\"\n    egi_mesh.halfedge = {key: {} for key in egi.vertices()}\n    for u, v in egi.edges():\n        egi_mesh.halfedge[u][v] = None\n        egi_mesh.halfedge[v][u] = None\n    u = sorted(egi.vertices(True), key=lambda x: (x[1]['y'], x[1]['x']))[0][0]\n    v = network_node_find_first_neighbor(egi, u)\n\n    egi_mesh.add_face(_egi_find_edge_face(u, v, egi))\n\n    for u, v in egi.edges():\n\n        if egi_mesh.halfedge[u][v] is None:\n\n            egi_mesh.add_face(_egi_find_edge_face(u, v, egi))\n        if egi_mesh.halfedge[v][u] is None:\n            egi_mesh.add_face(_egi_find_edge_face(v, u, egi))\n\n    return egi_mesh\n\n\n# ******************************************************************************\n# ******************************************************************************\n# ******************************************************************************\n#\n#   main\n#\n# ******************************************************************************\n# ******************************************************************************\n# ******************************************************************************\n\n\nif __name__ == '__main__':\n    pass\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "line", "curve", "functions", "block", "mesh", "RhinoCommon"], "original_file": "BlockResearchGroup_compas_3gs_4132b4170b.json", "repo": "BlockResearchGroup/compas_3gs"}
{"instruction": "Check if a point is on any of the surfaces of a Brep.", "code": "import rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\nimport Rhino.Geometry as rg\r\nimport Rhino.DocObjects as rd\r\nimport math\r\nimport os\r\nimport System\r\nimport System.Collections.Generic\r\nimport Rhino\r\n\r\ndef SampleViewCaptureToFile(name):\r\n    view = sc.doc.Views.ActiveView;\r\n    if view:\r\n        view_capture = Rhino.Display.ViewCapture()\r\n        view_capture.Width = view.ActiveViewport.Size.Width\r\n        view_capture.Height = view.ActiveViewport.Size.Height\r\n        view_capture.ScaleScreenItems = False\r\n        view_capture.DrawAxes = False\r\n        view_capture.DrawGrid = False\r\n        view_capture.DrawGridAxes = False\r\n        view_capture.TransparentBackground = True\r\n        bitmap = view_capture.CaptureToBitmap(view)\r\n        if bitmap:\r\n            bitmap.Save(name, System.Drawing.Imaging.ImageFormat.Png);\r\n\r\n\r\n\r\ndef voxelize_brep(brep, voxel_size, points_guid):\r\n    bbox = rs.BoundingBox(brep)\r\n    if bbox is None:  # Check if bounding box exists\r\n        return None\r\n\r\n    min_pt, max_pt = bbox[0], bbox[6]\r\n    x_span = max_pt.X - min_pt.X\r\n    y_span = max_pt.Y - min_pt.Y\r\n    z_span = max_pt.Z - min_pt.Z\r\n\r\n    x_voxels = int(x_span / voxel_size) + 1\r\n    y_voxels = int(y_span / voxel_size) + 1\r\n    z_voxels = int(z_span / voxel_size) + 1\r\n\r\n    voxels = []\r\n    color = []\r\n    voxel_guids = []\r\n    renderCount = 1\r\n\r\n    for i in range(x_voxels):\r\n        for j in range(y_voxels):\r\n            for k in range(z_voxels):\r\n                x = min_pt.X + i * voxel_size\r\n                y = min_pt.Y + j * voxel_size\r\n                z = min_pt.Z + k * voxel_size\r\n                voxel = rg.Box(rg.Plane.WorldXY, rg.Interval(x, x + voxel_size), rg.Interval(y, y + voxel_size), rg.Interval(z, z + voxel_size))\r\n                voxel_guid = sc.doc.Objects.AddBrep(voxel.ToBrep())\r\n                voxel_guids.append(voxel_guid)\r\n                intersect = rg.Intersect.Intersection.BrepBrep(brep, voxel.ToBrep(), sc.doc.ModelAbsoluteTolerance)\r\n                voxel_brep = voxel.ToBrep()\r\n                \r\n                #calculate the closest point in the to the voxel\r\n                voxel_centroid = rg.AreaMassProperties.Compute(voxel_brep).Centroid\r\n                #closest_point = brep.ClosestPoint(rs.coercebrep(brep_guid))\r\n                coordinates = []\r\n                \r\n                for point in points_guid:\r\n                    coordinates.append(rs.PointCoordinates(point))\r\n                #use that info to extract the info of the point to get the color\r\n                closest_point, point_index = find_closest_point(voxel_centroid, coordinates)\r\n                point_property = get_point_property(points_guid[point_index])\r\n\r\n                voxelCorners = voxel.GetCorners()\r\n                \r\n                #TEST INSIDE BREP ONLY IF THE 8 CORNER POINTS ARE INSIDE THE BREP ******new****\r\n                cornerCount = 0\r\n                for corner in voxelCorners:\r\n                    isPointonSrf = is_point_on_brep(corner, brep)\r\n                    if rg.Brep.IsPointInside(brep, corner, sc.doc.ModelAbsoluteTolerance, True) or isPointonSrf is True:\r\n                        cornerCount+=1\r\n                if cornerCount == 8:\r\n                    rs.ObjectColor(voxel_guid, point_property)\r\n                    voxels.append(voxel)\r\n                    color.append([point_property.R, point_property.G, point_property.B])\r\n                else:\r\n                    print(\"The point is not inside the Brep.\")\r\n                    rs.DeleteObject(voxel_guid)\r\n                \r\n                cornerCount = 0\r\n                '''\r\n                if len(intersect[1]) > 0:\r\n                    rs.ObjectColor(voxel_guid, point_property)\r\n                    voxels.append(voxel)\r\n                    color.append([point_property.R, point_property.G, point_property.B])\r\n\r\n                    location = \"C:/Users/Chris/Desktop/Temp/Voxel/\"\r\n                    name = location + \"Voxel\" + \"000\" + str(renderCount) + \".png\"\r\n                    SampleViewCaptureToFile(name)\r\n                    renderCount = renderCount + 1\r\n                else: \r\n                    #test inside or outside ****old*****\r\n                    if rg.Brep.IsPointInside(brep, voxel_centroid, sc.doc.ModelAbsoluteTolerance, True):\r\n                        print(\"The point is inside the Brep.\")\r\n                        rs.ObjectColor(voxel_guid, point_property)\r\n                        voxels.append(voxel)\r\n                        color.append([point_property.R, point_property.G, point_property.B])\r\n                    else:\r\n                        print(\"The point is not inside the Brep.\")\r\n                        rs.DeleteObject(voxel_guid)\r\n                        '''\r\n\r\n\r\n    return voxels, color, voxel_guids\r\n\r\ndef get_point_property(point):\r\n    \r\n    #If ColorSource is ON::color_from_object, then value of m_color is used.\r\n    color = rs.ObjectColor(point)\r\n    return color\r\n    \r\ndef find_closest_point(target_point, point_set):\r\n    closest_point = None\r\n    closest_point_index = None\r\n    min_distance = float('inf')\r\n\r\n    for i in range(len(point_set)):\r\n        distance = target_point.DistanceTo(point_set[i])\r\n        if distance < min_distance:\r\n            min_distance = distance\r\n            closest_point = point_set[i]\r\n            closest_point_index = i\r\n    \r\n    return closest_point, closest_point_index\r\n    \r\n\r\n\r\ndef toolpath_to_voxel(voxels, color, highdensity, hd_centroid, meddensity, md_centroid, lowdensity, ld_centroid):\r\n    \r\n    for voxel in range(len(voxels)):\r\n      #voxel_guid = sc.doc.Objects.AddBrep(voxels[voxel].ToBrep())\r\n      color[voxel]\r\n      voxel_brep = voxels[voxel].ToBrep()\r\n      print(color[voxel])\r\n      if color[voxel][0] == 255 and color[voxel][1] == 0:\r\n          print(\"meow\")\r\n          voxel_centroid = rg.AreaMassProperties.Compute(voxel_brep).Centroid\r\n          start_point = rs.coerce3dpoint(hd_centroid)\r\n          end_point = rs.coerce3dpoint(voxel_centroid)\r\n          \r\n          vector = rg.Vector3d(end_point - start_point)\r\n          rs.CopyObject(highdensity, vector)\r\n      elif color[voxel][0] == 255 and color[voxel][1] == 255:\r\n          print(\"moo\")\r\n          voxel_centroid = rg.AreaMassProperties.Compute(voxel_brep).Centroid\r\n          start_point = rs.coerce3dpoint(md_centroid)\r\n          end_point = rs.coerce3dpoint(voxel_centroid)\r\n          \r\n          vector = rg.Vector3d(end_point - start_point)\r\n          \r\n          rs.CopyObject(meddensity, vector)\r\n      elif color[voxel][0] == 0 and color[voxel][1] == 255:\r\n          print(\"woof\")\r\n          voxel_centroid = rg.AreaMassProperties.Compute(voxel_brep).Centroid\r\n          start_point = rs.coerce3dpoint(ld_centroid)\r\n          end_point = rs.coerce3dpoint(voxel_centroid)\r\n          \r\n          vector = rg.Vector3d(end_point - start_point)\r\n          \r\n          rs.CopyObject(lowdensity, vector)\r\n\r\n\r\n\r\ndef split_breps_with_breps(breps_to_split, splitting_breps, brep):\r\n    split_breps = []\r\n    splitting_breps = splitting_breps.Surfaces\r\n    for brep_to_split in breps_to_split:\r\n        for splitting_brep in splitting_breps:\r\n            splitting_brep = Rhino.Geometry.Brep.CreateFromSurface(splitting_brep)\r\n            print(brep_to_split)\r\n            if str(brep_to_split) == \"Rhino.Geometry.Box\":\r\n                brep_to_split = rg.Brep.CreateFromBox(brep_to_split)\r\n            intersection_curves = rg.Intersect.Intersection.BrepBrep(brep_to_split, splitting_brep, 0.001)\r\n            if intersection_curves:\r\n                #brep_pieces = (rs.SplitBrep(brep_to_split, splitting_brep))\r\n                brep_pieces = (brep_to_split.CreateBooleanSplit(brep_to_split, splitting_brep, .001))\r\n                    # Check if any pieces were created\r\n                if brep_pieces:\r\n                    #rs.DeleteObject(brep_to_split)\r\n                    for piece in brep_pieces:\r\n                        #test inside or outside\r\n                        piece_centroid = rs.SurfaceVolumeCentroid(rs.coercebrep(piece))\r\n                        if brep.IsPointInside(piece_centroid[0], .001, True):\r\n                            print(\"The point is inside the Brep.\")\r\n                            split_breps.append(rs.coercebrep(piece))\r\n                        else:\r\n                            print(\"The point is not inside the Brep.\")\r\n                            \r\n                        print(\"Brep split successful.\")\r\n                else:\r\n                    print(\"No pieces were created.\")\r\n\r\n    return split_breps, brep_to_split\r\n\r\ndef is_point_on_brep(point, brep):\r\n    \"\"\"\r\n    Check if a point is on any of the surfaces of a Brep.\r\n    \"\"\"\r\n    # Get all the surfaces of the BrepSurfacesfaces\r\n    surfaces = brep.Surfaces\r\n    closesetPoint = brep.ClosestPoint(point)\r\n    distance = point.DistanceTo(closesetPoint)\r\n    if distance < 2:\r\n        return True\r\n    # If the point is not on any surface of the Brep\r\n    return False\r\n\r\n\r\n\r\n\r\n#points_guid = [rs.coerce3dpoint(points_guid) for point_guid in point_guids]\r\nbrep_guid = rs.GetObject(\"Select a Brep\", rs.filter.surface | rs.filter.polysurface)\r\npoints_guid = rs.GetObjects(\"Select points\", rs.filter.point)\r\nvoxel_size = rs.GetReal(\"Enter voxel size\", 2.0)\r\n\r\nrs.HideObject(brep_guid)\r\nrs.HideObject(points_guid)\r\n\r\nvoxels, colors, voxel_guid = voxelize_brep(rs.coercebrep(brep_guid), voxel_size, points_guid)\r\n#toolpath geometry \r\n\r\n\r\n\r\n#rs.HideObjects(voxel_guid)\r\n\r\n#split_voxels, voxels = split_breps_with_breps(voxels, rs.coercebrep(brep_guid), rs.coercebrep(brep_guid))\r\n\r\nhighdensity = rs.GetObjects(\"Pick High Density Toolpath\")\r\nhd_centroid = rs.GetObject(\"Pick High Density centroid\")\r\n\r\nmeddensity = rs.GetObjects(\"Pick Medium Density Toolpath\")\r\nmd_centroid = rs.GetObject(\"Pick Medium Density centroid\")\r\n\r\nlowdensity = rs.GetObjects(\"Pick Low Density Toolpath\")\r\nld_centroid = rs.GetObject(\"Pick Low Density centroid\")\r\n\r\ntoolpath = toolpath_to_voxel(voxels, colors, highdensity, hd_centroid, meddensity, md_centroid, lowdensity, ld_centroid)\r\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "brep", "curve", "functions", "RhinoCommon"], "original_file": "ChristopherVoltl_Functionally-Graded-Spatial-Printing_9a8c5a6b9d.json", "repo": "ChristopherVoltl/Functionally-Graded-Spatial-Printing"}
{"instruction": "Grasshopper components to access ArchiCAD via JSON API.", "code": "#!/usr/bin/env python27\n# -*- coding: utf-8 -*-\n\n__all__ = [\"Plugin\", \"RhinoWrapper\", \"Factory\"]\n\n# - - - - - - - - BUILT-IN IMPORTS\nimport System, traceback\nimport base64\n\n# - - - - - - - - LOCAL IMPORTS\nfrom tapir_py import parts, utility\n\n# - - - - - - - - RH/GH IMPORTS\nimport Rhino, Grasshopper, GhPython\n\n# - - - - - - - - GLOBAL VARIABLES\nPlugin = utility.RuntimeObject( { \"is_active\" : False, \"Archicad\" : None }, \"TapirPlugin\")\n\n# - - - - - - - - DECORATORS\ndef connect(function):\n    def wrapper(*args, **kwargs):\n        if Plugin.is_active:\n            return function(*args, **kwargs)\n        else:\n            args[0].AddRuntimeMessage(Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, \"Plugin Disconnected!\")\n    return wrapper\n\ndef debug(function):    \n    def wrapper(*args, **kwargs):\n        try:\n            return function(*args, **kwargs)\n        except Exception as ex:\n            System.Windows.Forms.MessageBox.Show(traceback.format_exc(), str(ex))\n            args[0].AddRuntimeMessage(Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, str(ex))\n        return wrapper\n\n# - - - - - - - - CLASS LIBRARY\nclass AssemblyInfo(GhPython.Assemblies.PythonAssemblyInfo):\n    \n    def get_AssemblyName(self):\n        return \"tAPIr\"\n    \n    def get_AssemblyDescription(self):\n        return \"\"\"Grasshopper components to access ArchiCAD via JSON API.\"\"\"\n\n    def get_AssemblyVersion(self):\n        return \"1.0.9\"\n\n    def get_AuthorName(self):\n        return \"EnzymeAPD\"\n    \n    def get_Id(self):\n        return System.Guid(\"54b11162-627b-455b-b9c0-963e76b36dc7\")\n\nclass RhinoWrapper(object):\n\n    @staticmethod\n    def BoundingBox(boundingBoxes):\n\n        success = True\n        message = \"\"\n        rhino_boxes = []\n        for bBox in list(boundingBoxes):\n\n            if isinstance(bBox, parts.BoundingBox):\n                X = Rhino.Geometry.Interval(*bBox.x)\n                Y = Rhino.Geometry.Interval(*bBox.y)\n                Z = Rhino.Geometry.Interval(*bBox.z)\n            \n                box = Rhino.Geometry.Box(Rhino.Geometry.Plane.WorldXY, X, Y, Z)\n                rhino_boxes.append(box)\n            else:\n                success = False\n                message = \"Some inputs were skipped.\"\n\n        return success, message, rhino_boxes\n\nclass Factory(object):\n\n    @staticmethod\n    def create_button(component, param_index, name, x_offset=27, y_offset=11):\n        source_input = component.Params.Input[param_index]\n        component_width_delta = component.Attributes.Bounds.Width * 0.5\n\n        # Create new Button component\n        source_pivot = component.Attributes.Pivot\n        new_button = Grasshopper.Kernel.Special.GH_ButtonObject()\n\n        # Add component to current Grasshopper Document\n        doc = component.OnPingDocument()\n        doc.AddObject(new_button, False, doc.ObjectCount + 1)\n\n        new_button.Name = name\n        new_button.NickName = name\n        new_button.Attributes.Pivot = System.Drawing.PointF(source_pivot.X - component_width_delta - x_offset, source_pivot.Y - y_offset)\n\n        # Connect Value List to component\n        source_input.AddSource(new_button)\n        new_button.ExpireSolution(True)\n\n        return new_button\n\n    @staticmethod\n    def create_value_list(component, param_index, name, items, x_offset=27, y_offset=11):\n        source_input = component.Params.Input[param_index]\n        component_width_delta = component.Attributes.Bounds.Width * 0.5\n\n        # Create new Value List component\n        source_pivot = component.Attributes.Pivot\n        new_value_list = Grasshopper.Kernel.Special.GH_ValueList()\n        \n        # Add component to current Grasshopper Document\n        doc = component.OnPingDocument()\n        doc.AddObject(new_value_list, False, doc.ObjectCount + 1)\n\n        new_value_list.Name = name\n        new_value_list.NickName = name\n        new_value_list.Attributes.Pivot = System.Drawing.PointF(source_pivot.X - component_width_delta - x_offset, source_pivot.Y - y_offset)\n        new_value_list.ListItems.Clear()\n\n        # Populate list\n        Factory.update_value_list(new_value_list, items)\n\n        # Connect Value List to component\n        source_input.AddSource(new_value_list)\n        new_value_list.ExpireSolution(True)\n\n        return new_value_list\n\n    @staticmethod\n    def update_value_list(component, items):\n        if isinstance(component, Grasshopper.Kernel.Special.GH_ValueList):\n            component.ListItems.Clear()\n            for item in items:\n                list_item = Grasshopper.Kernel.Special.GH_ValueListItem(str(item), '\"{}\"'.format(item))\n                component.ListItems.Add(list_item)\n            return True\n        else:\n            return False\n\n# ----- UTILLITIES\ndef ico2base64(ico_file):\n    \"\"\"\n    Converts icon image to base64 string \n    to be used by get_internal_Icon_24x24 method\n    \"\"\"\n    with open(ico_file, \"rb\") as image_file:\n        encoded_string = base64.b64encode(image_file.read())\n        image_file.close()\n    return encoded_string\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "classes", "functions", "RhinoCommon"], "original_file": "ENZYME-APD_tapir-archicad-automation_0ee47dd552.json", "repo": "ENZYME-APD/tapir-archicad-automation"}
{"instruction": "Extracts code from a GhPython Script component, and provides option to export to .py file.", "code": "#!/usr/bin/env ipy\n# -*- coding: utf-8 -*-\n\n__all__ = [\"ExportCode_Component\",\n           \"StealIcon_Component\",\n           \"ClassificationItem_Component\"]\n\n# - - - - - - - - BUILT-IN IMPORTS\nimport System\nimport os, traceback\n\n# - - - - - - - - LOCAL IMPORTS\nimport tapir, tapir_py\n\n# - - - - - - - - RH/GH IMPORTS\nfrom  ghpythonlib.componentbase import dotnetcompiledcomponent as component\nfrom ghpythonlib.treehelpers import list_to_tree\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\nimport Rhino, Grasshopper, GhPython\n        \n# - - - - - - - - COMPONENT\nclass ExportCode_Component(component):\n    \n    def __new__(cls):\n        instance = Grasshopper.Kernel.GH_Component.__new__(cls, \"ExportCode\", \"ExportCode\", \"\"\"Extracts code from a GhPython Script component, and provides option to export to .py file.\"\"\", \"tAPIr\", \"00 WIP\")\n        return instance\n    \n    def get_ComponentGuid(self):\n        return System.Guid(\"d2a22074-0167-4365-a93b-924680662805\")\n    \n    def SetUpParam(self, p, name, nickname, description):\n        p.Name = name\n        p.NickName = nickname\n        p.Description = description\n        p.Optional = True\n\n    def RegisterInputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"GhPython\", \"G\", \"GhPython Script component.\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        self.Params.Input.Add(p)\n        \n    def RegisterOutputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"Code\", \"C\", \"Code as multiline text.\")\n        self.Params.Output.Add(p)\n        \n    def SolveInstance(self, DA):\n        p0 = self.marshal.GetInput(DA, 0)\n        result = self.RunScript(p0)\n\n        if result is not None:\n            self.marshal.SetOutput(result, DA, 0, True)\n        \n    def get_Internal_Icon_24x24(self):\n        o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAKCSURBVHgB3ZWxbxJxFMff73pWht6FmJCQXmKOBY4cFRzExEUC1c3YzUUL/4HdLMWhThonh1ZXIc5yHY09pGMPE2oq5UiHdmh1IRFhtffz/a45ShSOa3Cxn4Tc7/fu3ff9fu+9PAD+d8ioF9Fo7LEFkOMAZArgR8cO7g/BIqut1u4GTIKizN1OZ+7S7W2Dvi9rlNHtdunHTZ0mb976IcsJv1ctboQ9lEzewEAKGEbNNgiCAPOZNNrCfp/vVwI8MjW4kWXZHwxefQBgpQRRTFz2TYMkzYIoiCCKgu2jaRtwdPS9EwgEg4HAlU673f7pFoB3FnhamRC+fn/hXv/6hvHZfkqzkh3IYf5OaknAoLpeYelMmebuFowjEo2Vi8USHcdiNmfXhvEW/SORWNlNlxtYpDKYYzeOj7/ZPyddrCaEo6716KeItaIkSf0Xa+uvoVR6B71er29jhV589NAuPuPUn8ieArA+RzE/EymiMMuvvvnBFh1Ft9tjB+u4BeAGbrBjGIa9rlR0yC8/cRVn6JUKNhxUwcsNgJLV5y9eVptmy87zIGxf1rS/PmYta1nWM/AS4LTVpkLra2+yGC2HJvnMjZ6dGlPX3GtphMAObrf29/fYE+uiHphmIwReUKKxT04rOuRXCva4WM4XKIplh3xDh2kNHRXU4rSVwlMwarW+LZ1OQ9M0oYY2Qqar4JGR01RRrmUJZy3NzAgJ1vesY7DLqtQir4ZNU3YDs/mVwHlhk5ONkXETdFSKJiISUevhsBofDKCqahzHTt3x4WACeB7/kDjQnCBM/ATrx3OXco7P+XP2B7boCWhYeRnlDqc4fqHRqH+BfwkLokTnDlT1ehwuHL8BoJMgDHftTCsAAAAASUVORK5CYII=\"\n        return System.Drawing.Bitmap(System.IO.MemoryStream(System.Convert.FromBase64String(o)))\n\n    def __init__(self):\n        self.code = \"\"\n    \n    def RunScript(self, component):\n        self.code = \"\"\n        if self.Params.Input.Count == 0 or self.Params.Input[0].Sources.Count == 0:\n            self.AddRuntimeMessage(RML.Warning, \"Connect a GhPython Script component.\")\n            \n        else:\n            input_sources = self.Params.Input[0].Sources\n            target_component = None\n            \n            if input_sources[0].Attributes.IsTopLevel:\n                target_component = input_sources[0]\n            else:\n                target_component = input_sources[0].Attributes.GetTopLevel.DocObject\n            \n            if isinstance(target_component, GhPython.Component.ZuiPythonComponent):\n                self.code = target_component.Code\n            else:\n                self.AddRuntimeMessage(RML.Error, \"Input is not a GhPython Script component.\")\n        \n        return self.code\n    \n    def OnExportClick(self, sender, args):\n        file_dialog = Rhino.UI.SaveFileDialog()\n        file_dialog.Title = \"Export Python FIle\"\n        file_dialog.Filter = \"Python files (*.py)|*.py\";\n        file_dialog.ShowDialog()\n\n        if file_dialog.FileName != \"\":\n            with open(file_dialog.FileName, 'wt') as file:\n                file.write(self.code)\n            Rhino.RhinoApp.WriteLine(\"File Exported Successfully!\\n{}\".format(file_dialog.FileName))\n    \n    def AppendAdditionalMenuItems(self, items):\n        component.AppendAdditionalMenuItems(self , items)\n        if self.code == \"\":\n            return\n        try:\n            export_menu_item = items.Items.Add('Export Python FIle', None, self.OnExportClick)\n        except Exception as ex:\n            System.Windows.Forms.MessageBox.Show(traceback.format_exc(), ex)\n\nclass StealIcon_Component(component):\n    def __new__(cls):\n        instance = Grasshopper.Kernel.GH_Component.__new__(cls, \"StealIcon\", \"StealIcon\", \"\"\"Extracts 24x24 icon from input component.\"\"\", \"tAPIr\", \"00 WIP\")\n        return instance\n    \n    def get_ComponentGuid(self):\n        return System.Guid(\"503f8223-189d-4a84-8e32-6ebf10afeab6\")\n    \n    def SetUpParam(self, p, name, nickname, description):\n        p.Name = name\n        p.NickName = nickname\n        p.Description = description\n        p.Optional = True\n    \n    def RegisterInputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_String()\n        self.SetUpParam(p, \"file\", \"source\", \"Script variable Python\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        self.Params.Input.Add(p)\n        \n    def RegisterOutputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"stream\", \"stream\", \"Script output stream.\")\n        self.Params.Output.Add(p)\n        \n    def SolveInstance(self, DA):\n        p0 = self.marshal.GetInput(DA, 0)\n        result = self.RunScript(p0)\n\n        if result is not None:\n            self.marshal.SetOutput(result, DA, 0, True)\n        \n    def get_Internal_Icon_24x24(self):\n        o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAIOSURBVHgB3VW/T9tAFH4X+cxCoswNg2mp1DBlqenY4mQm6V6ZuQW1WyEg8R/wQyHMiRgQDBB2AqwwZYIx+Q9AZMJn5fHOcHF+YZwwwSed/PTO/r6753ffAbx1sKBJRIwLIWxk7DtjLEUJ42mqhgANhljRdb0Mo8B13TlHiBsaGDTuHafuOI49FDl9uPEScZ+QEGuhyOWLw5J3jI1ePtZTFruFWJJxs9n0ctFoFIZBhLGspmnHAwUc162rH/ljNgPTyS+wuPiHRGKQSHyAkLjlmjZJTXHbJbC+vmWPR8dL1eopXF1ft3egIHcynUyCZc1CJmORYOJ5CcR/1F1bXQLGp6kjQJaFkPiZy3q7GyRELVwZ4zwn40g722JGEKHcgVy9wuFRxStjoVDse5fOR0rFvgCDVAA/fJsxYXVluS9f2C7C/6V8j4K/WL9EHz8jvALz9i/I5/0F6Jx73JEO2QaMANVdpfIuXFxcqnRNBR0latVgCJjmV9gpFuDs9AQWFn57uZNq1XtKn2rTqoBK9JcemxCwUtM0YYaI0+k0xGLdB/DurunnEOeVCfoChhGHCK9TGM9RC6YtC5J00CQmJgJ6vgfkwI0xXZ8cOGkYU3N7+wf4Ci/CF51VjOCkaoiwjipGcFQxwEkDIZ1Vml8I8ht5OT3Hw8II0Y+THmVQ+z2edsbkdVmj/DnnvKyc833iAbpECjpFWScMAAAAAElFTkSuQmCC\"\n        return System.Drawing.Bitmap(System.IO.MemoryStream(System.Convert.FromBase64String(o)))\n\n    def set_icon(self, bitmap):\n        self.SetIconOverride(bitmap)\n        memory_stream = System.IO.MemoryStream()\n        bitmap.Save(memory_stream, System.Drawing.Imaging.ImageFormat.Png)\n        stream = System.Convert.ToBase64String(memory_stream.ToArray())\n        return stream\n    \n    def RunScript(self, source):\n        \n        sources = self.Params.Input[0].Sources\n        \n        if source and os.path.isfile(source):\n            bitmap = System.Drawing.Bitmap(source)\n            return self.set_icon(bitmap)\n        \n        elif sources:\n            source = sources[0].Attributes.GetTopLevel.DocObject\n            bitmap = source.Icon_24x24\n            return self.set_icon(bitmap)\n        \n        else:\n            bitmap = None\n            self.set_icon(self.get_Internal_Icon_24x24())\n            self.AddRuntimeMessage(RML.Warning, \"No Input\")\n            return \n\nclass ClassificationItem_Component(component):\n    def __new__(cls):\n        instance = Grasshopper.Kernel.GH_Component.__new__(cls, \"ClassificationItem\", \"ClassificationItem\", \"\"\"ClassificationItem\"\"\", \"tAPIr\", \"00 WIP\")\n        return instance\n    \n    def get_ComponentGuid(self):\n        return System.Guid(\"608cd6d6-01be-4ef2-87cb-8760dcf4c859\")\n    \n    def SetUpParam(self, p, name, nickname, description):\n        p.Name = name\n        p.NickName = nickname\n        p.Description = description\n        p.Optional = True\n    \n    def RegisterInputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"classification\", \"classification\", \"Script variable Python\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.tree\n        self.Params.Input.Add(p)\n        \n    def RegisterOutputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"children\", \"children\", \"Script output children.\")\n        self.Params.Output.Add(p)\n        \n    def SolveInstance(self, DA):\n        p0 = self.marshal.GetInput(DA, 0)\n        result = self.RunScript(p0)\n\n        if result is not None:\n            self.marshal.SetOutput(result, DA, 0, True)\n        \n    def get_Internal_Icon_24x24(self):\n        o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAALEgAACxIB0t1+/AAAAZ1JREFUSEvdlT1PwlAUhvkJ/IQrgpsxcSVE/wGbEh0YDOpG1Dijzlp01Tj7sTCJ7OrcRHZbdqEzt02u5zSn3NIe+uHIm7xJc3rPc+5XTwvLLaVUUUrZnrpuT3qeJV1XkU0/JmWThuaX53l1ADkhKOuplFbuQpDYjYLSDCvqUHqycCAHyOguYXjBtjSDwePJxHcoOZNxawkXV/ggq7Vt1To8Vt/DobLsUQyUYAcvByG1DOOuef/wqHYb+2p9Y1OJUmXOGMN3OMaybQ6sDTePsFpitdyLQpN8ena+sBBeYcJqiZWKyYEC4woOWkex+I1xGy8CV5ewWtHEqPE8cMbcuxNYTbQIYbW4xDy+uLxKK7BmcYlprta2Zs8fn19BAZOwWnkPeaexp/rvAx94bXT9WIdWwR9yqdIOA6LGmeJeP7+8qt9x/AOci3G9SQhRBJCDMAS99Qfqx7J9h0FpxuZHyLiEKNefYIZcYmandVb3H500MORm66g4kAMkGSdG6dnkd9b5v9giO4kdNE1YCGbXA5szKBTGGDY1tnMukQqFP73q7HDtm/LxAAAAAElFTkSuQmCC\"\n        return System.Drawing.Bitmap(System.IO.MemoryStream(System.Convert.FromBase64String(o)))\n\n    \n    def RunScript(self, classification):    \n        items = []\n        tree = classification\n        archicad = tapir.Plugin.Archicad\n        \n        for branch_index in range(tree.BranchCount):\n            branch = tree.Branch(branch_index)\n            branch_item = []\n            for leaf in branch:\n                \n                if isinstance(leaf, tapir_py.core.Command):\n                    objects = leaf.GetAllClassificationSystems()\n                    branch_item.append(objects)\n                \n                elif isinstance(leaf, tapir_py.parts.ClassificationSystem):\n                    objects = archicad.GetAllClassificationsInSystem(leaf)\n                    branch_item.append(objects)\n            \n                elif isinstance(leaf, tapir_py.parts.ClassificationItem):\n                    objects = leaf.children\n                    branch_item.append(objects)\n            \n            items.append(branch_item)\n        \n        items = list_to_tree(items)\n        children = items\n        \n        # return outputs if you have them; here I try it for you:\n        return children\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["line", "classes", "functions"], "original_file": "ENZYME-APD_tapir-archicad-automation_1d5ba494bb.json", "repo": "ENZYME-APD/tapir-archicad-automation"}
{"instruction": "Retrieves Element information from connected ArchiCAD project.", "code": "#!/usr/bin/env ipy\n# -*- coding: utf-8 -*-\n\n__all__ = [\"GetElements_Component\",\n           \"GetAllClassificationSystems_Component_OBSOLETE\",\n           \"GetClassificationSystems_Component\",\n           \"GetElementsByClassification_Component\",\n           \"GetBoundingBox_Component\",\n           \"HighlightElements_Component\"]\n\n# - - - - - - - - BUILT-IN IMPORTS\nimport System\nimport traceback\n\n# - - - - - - - - LOCAL IMPORTS\nimport tapir\n\n# - - - - - - - - RH/GH IMPORTS\nfrom ghpythonlib.componentbase import dotnetcompiledcomponent as component\nfrom ghpythonlib.treehelpers import list_to_tree\nimport Grasshopper\n\n# - - - - - - - - COMPONENTS\nclass GetElements_Component(component):\n    \n    def __new__(cls):\n        instance = Grasshopper.Kernel.GH_Component.__new__(cls, \"GetElements\", \"GetElements\", \"\"\"Retrieves Element information from connected ArchiCAD project.\"\"\", \"tAPIr\", \"02 Get\")\n        return instance\n    \n    def get_ComponentGuid(self):\n        return System.Guid(\"4a16caba-b37f-4f7f-80c1-cd23cb4a0841\")\n    \n    def SetUpParam(self, p, name, nickname, description):\n        p.Name = name\n        p.NickName = nickname\n        p.Description = description\n        p.Optional = True\n    \n    def RegisterInputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_Boolean()\n        self.SetUpParam(p, \"Update\", \"U\", \"Updates output Elements list.\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        p.SetPersistentData(Grasshopper.Kernel.Types.GH_Boolean(True))\n        self.Params.Input.Add(p)\n        \n    def RegisterOutputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"Elements\", \"E\", \"List of Elements from ArchiCAD project.\")\n        self.Params.Output.Add(p)\n        \n    def SolveInstance(self, DA):\n        p0 = self.marshal.GetInput(DA, 0)\n        result = self.RunScript(p0)\n\n        if result is not None:\n            self.marshal.SetOutput(result, DA, 0, True)\n        \n    def get_Internal_Icon_24x24(self):\n        o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAH8SURBVHgB3VUxT8JAFH7XdmCQhsG4sJyLtCmGuqhxVuOk3RXlH7iqizpo3IxRZ0Hc1c1EF38BGq3gRIdCojFR28RgYjzvGokVrgTphN/S3nvv3nv9Xu87gG4Hqr8oSnKVrtYCIwmslUq36/UlxjgWifQsAkIZ6sRAiEXTZWs1aceyrl6a9itqkjiOQ3h4fXUI8/uTJxJaYXNzi9h2xYu5uyuSpeUVklCTBYz1GLdAK/gLsK9lyXjYoEU9Nr4hQEcgmYX5NNezMD9HmSKZcAUQwoqicF3xeJwF4HAFAFmVSpXrKZbuPX+4AoRkDw/zXJdnp/76WvI7XdeFaDTatInZ/YhEpJ18/shwXFdnnDO6KtUq5HJ5OD45vXqnv2o9tuNzoOt6rFb7+DkHjBbaeeA56FqIPKOqDm739vaNPj09XkJIoEYDHRgGJJVlWX55fHjrD8sn5zcVVw1jGtLpWSpmdIhtgmnTwICWahnEumeaY9u2J3DDI2PPXOHiQNO0lKJo5cYiAq97dtxlOfqnrzBN81oUwRAEOPEXQf7uGfcX52ffegLgOC5MTE41zYJ1yvQouByySsWb/l8muumAJ8G7e/u/5LcVPJrUwbKmDaUakv9wz7ts2plFUHJPixCSZthtMj4xFbSfzkKYoc9cUMDnJ8qKgmSYZuEa/hW+AG0WQhBYhGOoAAAAAElFTkSuQmCC\"\n        return System.Drawing.Bitmap(System.IO.MemoryStream(System.Convert.FromBase64String(o)))\n\n    def __init__(self):\n        self.state = 0\n    \n    def set_state(self, state):\n        self.state = state\n        self.update_icon()\n        self.update_message()\n\n    def update_message(self):\n        if self.state == 0:\n            self.Message = \"Get Selected\"\n        elif self.state == 1:\n            self.Message = \"Get All\"\n        elif self.state == 2:\n            self.Message = \"Get By Classification\"\n        else:\n            self.Message = \"\"\n\n    def update_icon(self):\n        if self.state == 0:\n            o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAGYSURBVHgB3VRNTsJAFH5vOglNFMKCuB42UFIM3UnceQI5AjfAG4AnMNyAI3AD48ZEN0CkoTu6NiwIXVgT7DgVRqAMBcsKv1Xfz7zve/PmFeDUgfLDMMpNYbV2ZnJoOc7wXpqMsayunzcAsS6CDDh3RbmO79O26/an2wSlMn99eYZ0Or1Vezbz4Kp6Dc5oiLJ4KnX2iAStbR3Q//ygN5KErAdVxUNkMpv+ULmq+FKxpevzhrQJJAKvx4ZxFU9GgMj2JLDjCADdQ+PJCDjvHBrfIPA8T5kf9es6bYth9pW1hT98qtJOvAeWZWV9f77ag/BahPLoHpw+NJWzVLp8yOUuqpPJ+xMcCYw6DMNggHQshjUVK58/9j4Vz1RrLpmz6yu/D8Wi2SsUzEoswUJ9+CoW4Ah3jFlZOACUQp0Q6EZJiEq9xF+6sG17oGlQi5Lgpno6jh5UzcIwzHH8/whdZ/SWD7/oLvWKLn6XzHHsvCrXNM3KV0C6GqG1tfO71cd1EVfctnsD6f+ZASK9hRgsughic4IAO9Hi/wPfJCWfBKxXgIgAAAAASUVORK5CYII=\"\n        elif self.state == 1:\n            o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAH8SURBVHgB3VUxT8JAFH7XdmCQhsG4sJyLtCmGuqhxVuOk3RXlH7iqizpo3IxRZ0Hc1c1EF38BGq3gRIdCojFR28RgYjzvGokVrgTphN/S3nvv3nv9Xu87gG4Hqr8oSnKVrtYCIwmslUq36/UlxjgWifQsAkIZ6sRAiEXTZWs1aceyrl6a9itqkjiOQ3h4fXUI8/uTJxJaYXNzi9h2xYu5uyuSpeUVklCTBYz1GLdAK/gLsK9lyXjYoEU9Nr4hQEcgmYX5NNezMD9HmSKZcAUQwoqicF3xeJwF4HAFAFmVSpXrKZbuPX+4AoRkDw/zXJdnp/76WvI7XdeFaDTatInZ/YhEpJ18/shwXFdnnDO6KtUq5HJ5OD45vXqnv2o9tuNzoOt6rFb7+DkHjBbaeeA56FqIPKOqDm739vaNPj09XkJIoEYDHRgGJJVlWX55fHjrD8sn5zcVVw1jGtLpWSpmdIhtgmnTwICWahnEumeaY9u2J3DDI2PPXOHiQNO0lKJo5cYiAq97dtxlOfqnrzBN81oUwRAEOPEXQf7uGfcX52ffegLgOC5MTE41zYJ1yvQouByySsWb/l8muumAJ8G7e/u/5LcVPJrUwbKmDaUakv9wz7ts2plFUHJPixCSZthtMj4xFbSfzkKYoc9cUMDnJ8qKgmSYZuEa/hW+AG0WQhBYhGOoAAAAAElFTkSuQmCC\"\n        elif self.state == 2:\n            o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAALEgAACxIB0t1+/AAAAa5JREFUSEvdVDtOw0AQzRFyBFfxrtYmpgCJGkQNos6HGpDbIAoqEF2OwOcAMT1BqZMmR0iTPlIusMzb7Dp2GCdxqMKTnuL1jt/Mm9ls5X9CiOBRymAG4tm+zsHzvCr2hAwnQgZaCDXB2vOiqg3hQYGti8srPZ/P9XQ61Xj2/SC22wYQ9301NsIr9GUwLkxCFceoZDgcmQTAV//bVqdaNsw45MRTcq7xEtVCEOKnZ+f67f1D95JPjYTYcx+ahJxwSjUxolmg32jJcDTSN7d3+un5xYgiIZL1egnszxDLi+ZpRLNAAtMO2jw6PtGd+wdDiONdn/aWCexgCxn+duBaBAeNZjsNbjSvjXi+RTvMABDioEUBA3KTSBkmFDhw6+xJiqKoSu/KnyJACOHREF9xDC273AdIsnDi2kW/tN74P1h8GLaztFt7BOp/t3BQf4WZwWJYs4393AUYcHoqSrjAgajVVN0uebjqHcu4UErVcYWsTZKr3rGEi7VJVqt35FxAhItdkr0qmOodt3RhHJC4Uod5B0XVO24zi0JxgO6VmBPOke4pG84CdxMrvueoVH4AzCJavwTgX24AAAAASUVORK5CYII=\"\n        else:\n            o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAIOSURBVHgB3VW/T9tAFH4X+cxCoswNg2mp1DBlqenY4mQm6V6ZuQW1WyEg8R/wQyHMiRgQDBB2AqwwZYIx+Q9AZMJn5fHOcHF+YZwwwSed/PTO/r6753ffAbx1sKBJRIwLIWxk7DtjLEUJ42mqhgANhljRdb0Mo8B13TlHiBsaGDTuHafuOI49FDl9uPEScZ+QEGuhyOWLw5J3jI1ePtZTFruFWJJxs9n0ctFoFIZBhLGspmnHAwUc162rH/ljNgPTyS+wuPiHRGKQSHyAkLjlmjZJTXHbJbC+vmWPR8dL1eopXF1ft3egIHcynUyCZc1CJmORYOJ5CcR/1F1bXQLGp6kjQJaFkPiZy3q7GyRELVwZ4zwn40g722JGEKHcgVy9wuFRxStjoVDse5fOR0rFvgCDVAA/fJsxYXVluS9f2C7C/6V8j4K/WL9EHz8jvALz9i/I5/0F6Jx73JEO2QaMANVdpfIuXFxcqnRNBR0latVgCJjmV9gpFuDs9AQWFn57uZNq1XtKn2rTqoBK9JcemxCwUtM0YYaI0+k0xGLdB/DurunnEOeVCfoChhGHCK9TGM9RC6YtC5J00CQmJgJ6vgfkwI0xXZ8cOGkYU3N7+wf4Ci/CF51VjOCkaoiwjipGcFQxwEkDIZ1Vml8I8ht5OT3Hw8II0Y+THmVQ+z2edsbkdVmj/DnnvKyc833iAbpECjpFWScMAAAAAElFTkSuQmCC\"\n        self.SetIconOverride(System.Drawing.Bitmap(System.IO.MemoryStream(System.Convert.FromBase64String(o))))\n\n    @tapir.connect\n    def RunScript(self, refresh):\n        if self.state == 0:\n            return tapir.Plugin.Archicad.GetSelectedElements()\n        elif self.state == 1:\n            return tapir.Plugin.Archicad.GetAllElements()\n        elif self.state == 2:\n            return tapir.Plugin.Archicad\n\n    def on_get_selected_click(self, sender, args):\n        try:\n            # TODO: Add Update Input Parameter here.\n            self.set_state(0)\n            self.ExpireSolution(True)\n        except Exception as ex:\n            System.Windows.Forms.MessageBox.Show(traceback.format_exc(), ex)\n\n    def on_get_all_click(self, sender, args):\n        try:\n            # TODO: Remove Update input Parameter here.\n            self.set_state(1)\n            self.ExpireSolution(True)\n        except Exception as ex:\n            System.Windows.Forms.MessageBox.Show(traceback.format_exc(), ex)\n\n    def on_get_by_classification_system(self, sender, args):\n        try:\n            self.set_state(2)\n            self.ExpireSilution(True)\n        except Exception as ex:\n            System.Windows.Forms.MessageBox.Show(traceback.format_exc(), ex)\n\n    def AppendAdditionalMenuItems(self , items):\n        component.AppendAdditionalMenuItems(self , items)\n        try:\n            item_a = items.Items.Add('Get Selected', None, self.on_get_selected_click)\n            item_b = items.Items.Add('Get All', None, self.on_get_all_click)\n            item_c = items.Items.Add('Get By Classification System', None, self.on_get_by_classification_system)\n            item_c.Enabled  = False\n            \n            if self.state == 0:\n                item_a.Checked = True\n                item_b.Checked = False\n            \n            elif self.state == 1:\n                item_a.Checked = False\n                item_b.Checked = True\n            \n            else:\n                item_a.Checked = False\n                item_b.Checked = False\n            \n        except Exception as ex:\n            System.Windows.Forms.MessageBox.Show(traceback.format_exc(), ex)\n\nclass GetAllClassificationSystems_Component_OBSOLETE(component):\n\n    def __new__(cls):\n        instance = Grasshopper.Kernel.GH_Component.__new__(cls, \"GetAllClassificationSystems\", \"GetAllClassificationSystems\", \"Component description goes here.\", \"tAPIr\", \"02 Get\")\n        return instance\n    \n    def get_ComponentGuid(self):\n        return System.Guid(\"25fb8ccf-7ced-41e2-b2d9-5e4acfd69e06\")\n\n    def SetUpParam(self, p, name, nickname, description):\n        p.Name = name\n        p.NickName = nickname\n        p.Description = description\n        p.Optional = True\n\n    def RegisterInputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_Boolean()\n        self.SetUpParam(p, \"Update\", \"U\", \"Updates output Classification Systems list.\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        self.Params.Input.Add(p)\n\n    def RegisterOutputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"ClassificationSystems\", \"CS\", \"ClassificationSystems come out here\")\n        self.Params.Output.Add(p)\n    \n    def SolveInstance(self, DA):\n        p0 = self.marshal.GetInput(DA, 0)\n        result = self.RunScript(p0)\n\n        if result is not None:\n            self.marshal.SetOutput(result, DA, 0, True)\n\n    def get_Internal_Icon_24x24(self):\n        o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJ4SURBVHgB1VXPaxNREJ7dLGQLbughPdh6aCvt7mYTU8EInoQmeM0WQb2o8Sa2mHizrdA/oS0qeJPUu4lHoUGv3QilmGaTXlIhPZlisvGQgtnxvU1/bEIa1xoRP1jeezPvzcz7Zt4swP8OppdSlv1xBCYBgKOAuIvIrBSLuVXoB2Q5sKzO3MSNDQ0p8nkd6VqWlWX4U0xM+KamwzfQMAy0o1YzMHT1GkpS4LpTW2yngB7mOHYpEpkGQRDadB6PAKoaJWxhYnJSCYIDuOwLSovgOffq9p1bkhqNwtCQF5Jrb+Di+Di43W5rj9frBX7ALVX29x/yPD9YqXx938vBcZJF0R+XfeLKWvJ1W+TzC4vgETwgeFqyudlH1mgYdbgfewB6vphwlHhJUkq6rh/z/fzFS1xfz2C5XEZJ9uPdezEr0Ue6t6m0VQCSrJTACaiRI5T39nB27rFlhMKuo8bDkZMCoLpedrmTKbOradnRFi3PoF6vW1TNkKTa6cpkPlhyTdNgeOSCdQ6cQBQvxWmd20vz6fwC+RatKOncrqcjXdPc9bLb9pJpFQ2PnE+Ew60SzWY/kUizrY0MUw2FrgySz7pdKvUOjNp38rI/P3HsgMLn802ZJnvIC/Ol0XCl+YEf3wp6jiEBqCT4IMOwVURzq1DIfYR+4FeJ7IVTm50k+ZcIL7HWijS7w2SiiV0bnigqm4gQ29nZ3rLLudMcNBrcKs83kp3ygwO+2m0/x0Gs2YQ0aSFqp5O+QVGUIH2w9j7FwRlAjRD6RjvlTRMs0lkXkyazsTM7KBS2x7rJ6Q2aJpt2sZwK/YZFjxwoKcplR238t0F+r5t/zfg/xU9Qkkw5GVlaDwAAAABJRU5ErkJggg==\"\n        return System.Drawing.Bitmap(System.IO.MemoryStream(System.Convert.FromBase64String(o)))\n\n    def get_Exposure(self):\n        return Grasshopper.Kernel.GH_Exposure.hidden\n    \n    @tapir.connect\n    def RunScript(self, refresh):\n        return tapir.Plugin.Archicad.GetAllClassificationSystems()\n\nclass GetClassificationSystems_Component(component):\n\n    def __new__(cls):\n        instance = Grasshopper.Kernel.GH_Component.__new__(cls, \"GetClassificationSystems\", \"GetClassificationSystems\", \"\"\"Gets ClassificationSystems from current ArchiCAD project.\"\"\", \"tAPIr\", \"02 Get\")\n        return instance\n    \n    def get_ComponentGuid(self):\n        return System.Guid(\"9c083b2b-c5d1-4f68-b2e2-e247d7261747\")\n    \n    def SetUpParam(self, p, name, nickname, description):\n        p.Name = name\n        p.NickName = nickname\n        p.Description = description\n        p.Optional = True\n    \n    def RegisterInputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_String()\n        self.SetUpParam(p, \"classificationSystems\", \"classificationSystems\", \"Script variable Python\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        self.Params.Input.Add(p)\n        \n    def RegisterOutputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"classificationSystems\", \"classificationSystems\", \"Script output classificationSystems.\")\n        self.Params.Output.Add(p)\n        \n    def SolveInstance(self, DA):\n        p0 = self.marshal.GetInput(DA, 0)\n        result = self.RunScript(p0)\n\n        if result is not None:\n            self.marshal.SetOutput(result, DA, 0, True)\n        \n    def get_Internal_Icon_24x24(self):\n        o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAALEgAACxIB0t1+/AAAAbNJREFUSEvdlbFSwjAYx3kEH4EFkjQN4KB3TnriOeM5izjryQo6OFnZGNRdfQDxAeoD4MJG2VjK7NEXiPmHFCkq12I57/zd5drmS//J98+XNvO/YcyuUyaGlNmSUj4kxK6b0O9hTLQrB4ey232ToN/3JJ4Z420zZHlyOau0W96XQRBo8ZDxOJAbm1sqG7FthiYHLytrOs5Ny8hGuXZaUlnVyed50bwSH9iCFUIcloCHx6dIJuhHHBkmsgsbCI/nbWk0L6SjVn17d69bCOzC+NgbjyrxvMmqAcRc91X6vi9RRUfV2jQrxJ47L7oAKONDI7EYiIT4o5E8PTvXImA2BvHy3mcBIGYkFoN6x4rQ4C/2otG8nIoA2IV+xF3XlX1voGIiXgaEFL7sAQQxCSbA/Wwc10R7AFBFSB9VAiuqxydaHI1Z4h3P6EccmRAikh86y7JKlNpXkyZq2WxpLfRZLaCCfsYKdXXd0S+kQThBqugM9IfOfOzM/U+eE8J7iU63tobS7HxDvxkSgXNexFla6hMSl9QmgUhYXd+3mGcjKToDJc75evo2rVQcqH9Ib2Xif0gm8wGOuY8PG8oa8gAAAABJRU5ErkJggg==\"\n        return System.Drawing.Bitmap(System.IO.MemoryStream(System.Convert.FromBase64String(o)))\n\n    def __init__(self):\n        self.classification_systems = []\n        self.value_list = None\n    \n    def ensure_value_list(self):\n        if self.Params.Input[0].Sources.Count == 0:\n            archicad = tapir.Plugin.Archicad\n            if archicad:\n                self.classification_systems = archicad.GetAllClassificationSystems()\n                items = [classification_system.name for classification_system in self.classification_systems]\n                tapir.Factory.create_value_list(self, 0, \"ClassificationSystem\", items, 250)\n                self.ExpireSolution(True)\n\n    def RunScript(self, classificationSystems):\n        self.ensure_value_list()\n        for classification_system in self.classification_systems:\n            if classification_system.name == classificationSystems:\n                return classification_system\n\nclass GetElementsByClassification_Component(component):\n    \n    def __new__(cls):\n        instance = Grasshopper.Kernel.GH_Component.__new__(cls, \"GetElementsByClassification\", \"GetElementsByClassification\", \"\"\"Gets Element by Classification Systems\"\"\", \"tAPIr\", \"02 Get\")\n        return instance\n    \n    def get_ComponentGuid(self):\n        return System.Guid(\"58b0588c-fb46-4dc6-9ef0-32c6ea3cb90d\")\n    \n    def SetUpParam(self, p, name, nickname, description):\n        p.Name = name\n        p.NickName = nickname\n        p.Description = description\n        p.Optional = True\n    \n    def RegisterInputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_String()\n        self.SetUpParam(p, \"classificationSystems\", \"classificationSystems\", \"Script variable Python\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        self.Params.Input.Add(p)\n        \n    def RegisterOutputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"Names\", \"Names\", \"Script output Names.\")\n        self.Params.Output.Add(p)\n        \n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"Elements\", \"Elements\", \"Script output Elements.\")\n        self.Params.Output.Add(p)\n        \n    def SolveInstance(self, DA):\n        p0 = self.marshal.GetInput(DA, 0)\n        result = self.RunScript(p0)\n\n        if result is not None:\n                self.marshal.SetOutput(result[0], DA, 0, True)\n                self.marshal.SetOutput(result[1], DA, 1, True)\n        \n    def get_Internal_Icon_24x24(self):\n        o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAKtSURBVHgB3VU/bBJRGP/e3TUlsTQXczUNMhxLOUKVGztWJjfRaOpggbg5oZPaGtENYxpLbB0NHbthjDLWbkpNWmxJj6GBpQYrTS5h8Ejond/jTz2441J10f7CheN7v/d9v+/PewD87yB2RkmaTBICd+m7YcCiouw87eeIosi7XCMJICSOLBGJFXSX0TQuXalsqV0ea3UejEkBafH9u7eumZkbrvzGxrRhsOrh4cEns/Ph4TNrhCE38Sfflkp4lDvNDumX3SOeVVWtapYAgcBkAr8eLCw858fGBBCE9pPL5SRBOKfWat8LlDc+7r3fcW5XknGO07Va7WC9JwAtixTwp5JPHvOyHIKr166D0RJGIBqd5ZVSKULpdKMgjGVaigeBGCKKSdNX5tiGNV96mYbRUTc8nJuHcDgM2ewbcLvdMDf/CKKzt8Do9AXJIjji1zpjNu8qJYjFbkM+/xnq9TpmJUEq9Qz2979i4FGzgwo4B6hYAtBpWV5+BSsrr9Gxv6WePh7PeaCZLeEaQU6HnHH0b1rvGVNJuhgDosfRqNIlwzDoZNCPquvwoVTaadVVlmW+0WiuYY9ki2+ArcYP7lJ3VHumqFb7VhCEs9h9MoXOJTS5cMdHTRu6t7f3Zb3Lq1armtfrWW02da3TD75VFsywoXF3zOfActCoOk07iphtirKdgX8VrJ0xELjwAg/WVPew/A0sJcLRFIFwZWyWis3ymev5J2CsJjbZiYyXWTMBJ4TfH9ycmAiGHAO01dPbsQ16ckVR5uEE4DiIMwxk+4Mwduq7+J0sisVigWUh0h+E9Krnyv0b7XqBV3rZ+T4iFWV320ffuEHqbbI4/tNRlKLPjhsMBkNHOpNlGS5i2j9YvVMWTs6Lxc1C197qASHcFXBAOwvdkaPrJNPv/HTgJ1uWDACYoLhMAAAAAElFTkSuQmCC\"\n        return System.Drawing.Bitmap(System.IO.MemoryStream(System.Convert.FromBase64String(o)))\n\n    def __init__(self):\n        self.classification_systems = []\n    \n    def ensure_value_list(self):\n        if self.Params.Input[0].Sources.Count == 0:\n            archicad = tapir.Plugin.Archicad\n            if archicad:\n                self.classification_systems = archicad.GetAllClassificationSystems()\n                items = [classification_system.name for classification_system in self.classification_systems]\n                tapir.Factory.create_value_list(self, 0, \"ClassificationSystem\", items, 250)\n                self.ExpireSolution(True)\n    \n    def RunScript(self, classificationSystems):\n        try:\n            self.ensure_value_list()\n            for classification_system in self.classification_systems:\n                if classification_system.name == classificationSystems:\n                    #ClassificationSystemGuid = classification_system.guid\n                    ClassificationsInSystem = tapir.Plugin.Archicad.GetAllClassificationsInSystem(classification_system)\n                    names, elements = [], []\n                    for classification_item in ClassificationsInSystem:\n                        names.append([classification_item.id])\n                        elements.append(tapir.Plugin.Archicad.GetElementsByClassification(classification_item.guid))\n                    return list_to_tree(names), list_to_tree(elements)\n        except Exception as ex:\n            System.Windows.Forms.MessageBox.Show(traceback.format_exc(), str(ex))\n\nclass GetBoundingBox_Component(component):\n    \n    def __new__(cls):\n        instance = Grasshopper.Kernel.GH_Component.__new__(cls, \"GetBoundingBox\", \"BBox\", \"\"\"Retrieves BoundingBox for the provided elements.\"\"\", \"tAPIr\", \"02 Get\")\n        return instance\n    \n    def get_ComponentGuid(self):\n        return System.Guid(\"0197343d-00a0-4956-a67f-418b3ca88d6b\")\n    \n    def SetUpParam(self, p, name, nickname, description):\n        p.Name = name\n        p.NickName = nickname\n        p.Description = description\n        p.Optional = True\n    \n    def RegisterInputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"Elements\", \"E\", \"Elements as List.\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.list\n        self.Params.Input.Add(p)\n        \n    def RegisterOutputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"bBox\", \"B\", \"BoundingBoxes as List.\")\n        self.Params.Output.Add(p)\n        \n    def SolveInstance(self, DA):\n        p0 = self.marshal.GetInput(DA, 0)\n        result = self.RunScript(p0)\n\n        if result is not None:\n            self.marshal.SetOutput(result, DA, 0, True)\n        \n    def get_Internal_Icon_24x24(self):\n        o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJcSURBVHgBzZVNTBNBFMff1F5LPHCxNXG9zcaSeHCb6MVKi3iC9uiB7uJNuglXqRrqwY8rKdWDH7CLZ6CeNGJSj8DBFEl2ORBi0jYxIaFpTfRgHedtS6ltaXdVCL9kksnMm///7ex7GYCTBKUXdnA4OUPsBFE6cBWAJXl00FpgkCWkqhiG8QX+BUqpwDOekwKXmabpbJ/FxSU2GLrOcE8UxXPgFEEQTlPqn5YCV/ZSqTQrl8uslXw+z3CPin6GsbaNRNE/ycfenamEJdILjMHY+v+R4fDr4AE8m7GYwlZX15hT0AjP1r7ooBBcDQdSmxJCwOfzgVMKxaJ1tlnrTwPG5uPx2xAZHYGYPA5TiXtQKBR7C/MYjFXVSQgNXgPUQK12gzrRaAR07RX4vF4IDw3DbPppR6NKpWLtYTIY+2HlHcRiY21xrk5Z4RWp6gSsvH/LxQsgK+OwtJxp7Gv6AoTCw9YeJoOxHo+nkxS4oQto9PjRQ0sIryHBByJJl2A2NQOBgAS9cIMN0EjX5qysEZzbxZbBPtHoKDjFBUfMcRowZbmpUv6WmgZT2g1492G9y8otWw3Wytr6+sHZpk5u/GTT+HzemjCXHB66kYxERgQ1PsEryNtVGAWx4TKZN6VfVZbc2tqcad4/1Xpgd/drrr/fmzFNo6QvvA7iGpZpX5/HyhLB+sdOfv7iJdxN3C/lchtPfnx339ze3vjYqtf1RaP0ogBQnfadPaPE+ddgwyHYten0M6iUv80T4k4axqdDXzabTyY3Ij+xu4L1pSx/Nh+Y5mYW/idUHNjBASeJ36MgYcqj2cC/AAAAAElFTkSuQmCC\"\n        return System.Drawing.Bitmap(System.IO.MemoryStream(System.Convert.FromBase64String(o)))\n\n    @tapir.connect\n    def RunScript(self, Elements):\n        bBox = []\n        if Elements:\n            bBox = tapir.Plugin.Archicad.Get3DBoundingBoxes(Elements)\n            success, message, bBox = tapir.RhinoWrapper.BoundingBox(bBox)\n            \n            if not success:\n                self.AddRuntimeMessage(Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n        return bBox\n\nclass HighlightElements_Component(component):\n    def __new__(cls):\n        instance = Grasshopper.Kernel.GH_Component.__new__(cls, \"HighlightElements\", \"Highlight\", \"\"\"Highlights elements on Archicad window.\"\"\", \"tAPIr\", \"02 Get\")\n        return instance\n    \n    def get_ComponentGuid(self):\n        return System.Guid(\"95091882-2129-4f1c-acdf-da7a325cc2bf\")\n    \n    def SetUpParam(self, p, name, nickname, description):\n        p.Name = name\n        p.NickName = nickname\n        p.Description = description\n        p.Optional = True\n    \n    def RegisterInputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"Elements\", \"E\", \"Elements to highlight\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.list\n        self.Params.Input.Add(p)\n    \n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"sColor\", \"sC\", \"Color for selected elements.\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        p.Optional = True\n        self.Params.Input.Add(p)\n\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"uColor\", \"uC\", \"Color for unselected Elements.\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        p.Optional = True\n        self.Params.Input.Add(p)\n\n    def RegisterOutputParams(self, pManager):\n        pass\n\n    def SolveInstance(self, DA):\n        p0 = self.marshal.GetInput(DA, 0)\n        p1 = self.marshal.GetInput(DA, 1)\n        p2 = self.marshal.GetInput(DA, 2)\n        result = self.RunScript(p0, p1, p2)\n\n        if result is not None:\n            self.marshal.SetOutput(result, DA, 0, True)\n        \n    def get_Internal_Icon_24x24(self):\n        o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAIBSURBVHgBxVXPLztBFH8zre9tm2+jxNGJ3WyFgzZxUiTOji7ackf8BXohjqTcyx+gjSsSjtoD4kfrpAeVUBLZ5UCy+8xsrSq1O62IT7K78+PN570389l5AL8MTyPGqqr2+v3tHff35RvRNV5oAIZBxii1mseiaxpy4PFgBuAf/BiKEkx3dam9ovZ867q7g+l6c3UzoBQTJtA4a87ZY7LcMwiAkUqP7BUKJ/v2nGnSuNfrTdTjIuCCCrGZCoVDnYoigyRJkM3mIJfNFVko8Y+OGgYnD4UH8OAgi5+xvbOLfK4SQNMO1MsdRvQduGNuA82ARzYRnUQ3TETjjllQu8GVIMvB+ap6MBIO9wsEIoN9+F85Pjiw0dJS1bmu6+AGn08CJw6HyGq3KLW+gVdXJdQ0DTfTmffxaIxvUTACzUBWei5tBS0sLuHwyKilnGRy7V1J3AaahS3TfD5vESZX16yH4/w8/yZT5+ip0yT/iZ4eH8eisama8yiVrmF6ZhZ0TR8qFE73nDhcr+ty+fZC8vn72gKt8vPLizXGnWXSWylGvuK2noIACOKRVpNBib2xKLRWxIjru3JN8wyq37OzQ9e6IFQPDAP6GGkCETKcnBDC+kYKBAqPUAYcb2oZJIQ+IJrHbodrQ6gmswstxj7LLIMiU+h/lsF4INABd3c3f5/Br+MVbi1GePxGuTMAAAAASUVORK5CYII=\"\n        return System.Drawing.Bitmap(System.IO.MemoryStream(System.Convert.FromBase64String(o)))\n    \n    @tapir.connect\n    def RunScript(self, elements, fg_color=None, bg_color=None):\n        archicad = tapir.Plugin.Archicad\n        if archicad:\n\n            if fg_color:\n                fg_color = [int(val) for val in [fg_color.R, fg_color.G, fg_color.B, fg_color.A]]\n            else:\n                fg_color = [0, 150, 0, 100]\n            if bg_color:\n                bg_color = [int(val) for val in [bg_color.R, bg_color.G, bg_color.B, bg_color.A]]\n            else:\n                bg_color = [150, 0, 0, 100]\n\n            archicad.HighlightElements(elements, fg_color, bg_color)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["classes", "functions"], "original_file": "ENZYME-APD_tapir-archicad-automation_2c20af96e5.json", "repo": "ENZYME-APD/tapir-archicad-automation"}
{"instruction": "Establishes connection between current Grasshopper document, and any open ArchiCAD project.", "code": "#!/usr/bin/env ipy\n# -*- coding: utf-8 -*-\n\n__all__ = ['Connect_Component']\n\n# - - - - - - - - BUILT-IN IMPORTS\nimport System\nimport traceback\n\n# - - - - - - - - LOCAL IMPORTS\nimport tapir\nfrom tapir_py import core\n\n# - - - - - - - - RH/GH IMPORTS\nfrom ghpythonlib.componentbase import dotnetcompiledcomponent as component\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\nimport Rhino, Grasshopper, GhPython\n\n# - - - - - - - - COMPONENT\nclass Connect_Component(component):\n\n    def __new__(cls):\n        instance = Grasshopper.Kernel.GH_Component.__new__(cls, \"Connect\", \"Connect\", \"\"\"Establishes connection between current Grasshopper document, and any open ArchiCAD project.\"\"\", \"tAPIr\", \"01 Setup\")\n        return instance\n    \n    def get_ComponentGuid(self):\n        return System.Guid(\"bb340f32-83f5-4140-9956-960003773db4\")\n    \n    def SetUpParam(self, p, name, nickname, description):\n        p.Name = name\n        p.NickName = nickname\n        p.Description = description\n        p.Optional = True\n    \n    def RegisterInputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_Boolean()\n        self.SetUpParam(p, \"Refresh\", \"R\", \"Refreshes the link to the ArchiCAD project.\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        self.Params.Input.Add(p)\n    \n    def RegisterOutputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"Link\", \"A\", \"ArchiCAD Command Object, that can execute commands.\")\n        self.Params.Output.Add(p)\n        \n    def SolveInstance(self, DA):\n        p0 = self.marshal.GetInput(DA, 0)\n        result = self.RunScript(p0)\n\n        if result is not None:\n            self.marshal.SetOutput(result, DA, 0, True)\n        \n    def get_Internal_Icon_24x24(self):\n        o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAFDSURBVHgB7ZSxTsJQFIb/cwuJE2Egzt24TSHUN+ARfAR8A0dkIT6Awuimj8DqJKObkIiQLmLSSSFKu7DQY6+mTWrEmN4uRL/pz/lv/pObc3KAXYeggZTSBAqXRHAYKIMxJNq0ptPpk3aDz3DjBkTmVy/csOO6k7HSApkxut+Ff4QK6icaGSEiZ7uJpmk6Za0GDCr/5l32HwCDH7zRfD5602tAGG7zhCi2Ym0gA7ZtN0KmKwIdgWlNgsxoJuvIujVE8XAyuRsjKypcWvVH2z5oIG/+w3czPHXspKx1o/0+VpqZByDRNERBb+1iLKvea7c77Ps+e57H7ZMOV6v1HvLCsmqvKjhmtfK5GtWgSepUlEqlRAdBgDxITkWlsr/3slg0LSnVncHZeQ+zB/diuXy+hgapIas5RJWW0hxyfza7P8Wf5x2l5XcOZmQWkAAAAABJRU5ErkJggg==\"\n        return System.Drawing.Bitmap(System.IO.MemoryStream(System.Convert.FromBase64String(o)))\n\n    def __init__(self):\n        self.is_valid = False\n        self.archicad = None\n\n    def RunScript(self, refresh):\n        self.ensure_button()\n\n        if refresh:\n            self.archicad = core.Command.create()\n            self.is_valid = self.archicad.IsAlive()\n        \n        tapir.Plugin.is_active = self.is_valid\n\n        if self.is_valid:\n            tapir.Plugin.Archicad = self.archicad\n            self.Message = \"Port: {}\".format(self.archicad.link.port)\n            return self.archicad\n        \n        else:\n            tapir.Plugin.Archicad = None\n            self.Message = \"\"\n            self.AddRuntimeMessage(RML.Warning, \"Connection Failed: Unable to connect to ArchiCAD.\")\n            return None\n    \n    def ensure_button(self):\n        if self.Params.Input[0].Sources.Count == 0:\n            tapir.Factory.create_button(self, 0, \"Update\", 150)\n            self.ExpireSolution(True)\n\n    def on_disconnect_click(self, sender, args):\n        try:\n            self.__init__()\n            self.ExpireSolution(True)\n        except Exception as ex:\n            System.Windows.Forms.MessageBox.Show(traceback.format_exc(), ex)\n\n    def AppendAdditionalMenuItems(self , items):\n        component.AppendAdditionalMenuItems(self , items)\n        try:\n            disconnect_menu_item = items.Items.Add('Disconnect', None, self.on_disconnect_click)\n        except Exception as ex:\n            System.Windows.Forms.MessageBox.Show(traceback.format_exc(), ex)\n\n# TODO: ProjectInfo / ProductInfo / ", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["classes", "functions"], "original_file": "ENZYME-APD_tapir-archicad-automation_4826fd2391.json", "repo": "ENZYME-APD/tapir-archicad-automation"}
{"instruction": "# Archicad API 3.0 for grasshopper nodes and ARCHICAD 25 Python pallete", "code": "import json\nimport csv\nimport os\nimport urllib2 as rq\nfrom collections import OrderedDict\nimport  xml.etree.ElementTree as e\n# import requests\ntry: \n\timport scriptcontext as sc\nexcept:\n\tpass\n\t# print ('No sticky')\n\n# \"\"\"\n# Archicad API 3.0 for grasshopper nodes and ARCHICAD 25 Python pallete\n\n# \"\"\"\ndef readFromFile(csvFile):\n\t'''\n\tReads list of elements from file previouslly saved\n\t'''\n\t#path validation\n\tisFile = os.path.isfile(csvFile)\n\tif isFile:\n\t\twith open(csvFile,'r') as file:\n\t\t\treader = csv.reader(file)\n\t\t\t_list =[row[0] for row in reader]\n\t\t\tprint _list\n\t\tfile.close()\n\t\treturn _list\n\treturn []\ndef bakeToFile(_list,csvFile):\n\t'''\n\tSaves list to a textfile in one column\n\tINPUT:\n\t\t_list:\t\tlist - list of elements \n\t\tcsv_file: \tstr  - path to a location where file will be saved\n\t'''\n\twith open(csvFile,'w') as f:\n\t\twrite = csv.writer(f)\n\t\tfor row in _list:\n\t\t\twrite.writerow([row])\n\treturn '{} elements saved to file: {}'.format(len(_list),csvFile)\n\tf.close()\ndef composeAddonCommand(commandName,commandParams={},namespace='AdditionalJSONCommands'):\n\n\t# '''\n\t# Composes json command for Custom Addon: AdditionalJsonCommands\n\t# if commands requires parameters provide it in form of dictionary\n\t# Parametername:value\n\t# '''\n\tjson_command = {}\n\tjson_command['command'] = 'API.ExecuteAddOnCommand'\n    \n\n\taddOnCommandId  ={}\n\taddOnCommandId['commandNamespace'] = namespace\n\taddOnCommandId['commandName'] = commandName\n\n\n\taddOnCommandParameters = {}    \n\tif len(commandParams) > 0:\n\t\t_parameters={}\n\t\tfor command,value in commandParams.items():\n\t\t\t_parameters[command] = value\n\t\taddOnCommandParameters = _parameters\n\t\tjson_command['parameters'] = {'addOnCommandId':addOnCommandId,'addOnCommandParameters':addOnCommandParameters}\n\telse:\n\t\tjson_command['parameters'] = {'addOnCommandId':addOnCommandId}\n\treturn json_command\n\ndef extract_xml_from_bimx(bimxFile):\n\twith open(bimxFile,'r') as file:\n\t# with open(bimxFile,'r',encoding='utf-8') as file:\n\t\tdata = file.readlines()\n\tfile.close()\n\n\n\tfor i,j in enumerate(data):\n\t\t# print (i,j)\n\t\tif \"<Metadata\" in j:\n\t\t\ta = i \n\t\tif \"</Metadata\" in j:\n\t\t\tb = i+1\n\n\tblock = (a,b)\n\txml = []\n\tfor i in xrange(block[0],block[1]):\n\t\txml.append(data[i])\n\t\txmlString = ''.join(xml)\n\treturn xmlString\n\ndef parseXML(xmlString):\n\t# parser = e.XMLParser(strip_cdata = False)\n\t# xmlParsed = e.parse(xmlString,parser)\n\txmlParsed = e.fromstring(xmlString)\n\troot = xmlParsed\n\treturn root\n\ndef addItem(array,item):\n    array.append(item)\n    \ndef openFolder(array,folder):\n    for f in folder:\n        if f.tag=='Item':addItem(array,f)\n        if f.tag=='Folder':openFolder(array,f)\n\ndef getLayouts(itemsAndFolders):\n    _layoutName = []\n    _layoutID   = []\n    _items= []\n    for j,i in enumerate(itemsAndFolders[0]):\n        if i.attrib.has_key('type') == False:\n            if i.tag=='Item':addItem(_items,i)\n            if i.tag=='Folder':openFolder(_items,i)\n    for item in _items:\n        \n        _layoutName.append(item.attrib['title'])\n        _layoutID.append(item.attrib['id'])\n    sc.sticky['layoutNames'] = _layoutName\n    sc.sticky['layoutID'] = _layoutID\n    return _layoutName,_layoutID\n\ndef get_layouts():\n\t\"\"\"get bimx llayouts from sticky global\"\"\"\n\ttry:\n\t\t_layoutName = sc.sticky['layoutNames']\n\t\t_layoutID = sc.sticky['layoutID']\n\t\t\n\t\treturn dict(zip(_layoutName,_layoutID))\n\texcept:\n\t\treturn False\ndef set_global_toggle(on_off):\n\t\"\"\"\n\tglobal turnoff/on variable\n\tINPUT:\n\t\ton_off: list of integers\n\t\"\"\"\n\ttry:\n\t\tif isinstance(on_off,bool):\n\t\t\tsc.sticky['toggle'] = on_off\n\t\telse: \n\t\t\tsc.sticky['toggle'] = False\n\texcept:\n\t\tprint 'Run outside GH'\n\n\ndef get_global_toggle():\n\t\"\"\"Gets global toggle\"\"\"\n\ttry:\n\t\t_toggle = sc.sticky['toggle']\n\t\treturn _toggle\n\texcept:\n\t\treturn False\n\ndef set_active_port(ports):\n\t''' \n\t'''\n\tif isinstance(ports,int):\n\t\tports=[ports]\n\ttry:\n\t\tsc.sticky['activeports'] = ports\n\texcept:\n\t\tprint 'Run outside GH'\ndef get_active_port():\n\ttry:\n\t\treturn sc.sticky['activeports']\n\texcept:\n\t\treturn [19723]\n\ndef set_ports(ports):\n\t\"\"\"\n\tSaves ports to GH Sticky Global variable accessible to any node in a scheme\n\tINPUT:\n\t\tports: list of integers\n\t\"\"\"\n\ttry:\n\t\tsc.sticky['ports'] = ports\n\t\tprint('ports set')\n\texcept:\n\t\tprint 'Run outside GH'\n\ndef get_port():\n\t\"\"\"Gets list of ports saved in  GH sticky global variable or false if run outside GH \"\"\"\n\ttry:\n\t\t_ports = sc.sticky['ports']\n\t\tif isinstance(sc.sticky['ports'],int):\n\t\t\t_ports = [sc.sticky['ports']]\n\t\treturn _ports\n\texcept:\n\t\treturn False\n\n\n\ndef connect(json_definition,port):\n\t\"\"\"\n\tConnects to ARCHICAD API\n\t\"\"\"\n\ttry:\n\t\trequest = rq.Request ('http://127.0.0.1:{}'.format(port))\n\t\tresponse = rq.urlopen (request, json.dumps (json_definition).encode (\"UTF-8\"))\n\t\tResult = json.loads (response.read ())\n\t\treturn Result\n\texcept :\n\t\treturn False\n\ndef check_port(port):\n\t\"\"\"\n\tChecks if port is Alive\n\t\"\"\"\n\tcommand = {\n\t\"command\": \"API.IsAlive\"\n\t}\n\ttry:\n\t\tresp_to_json  = connect(command,port)\n\t\tisSuccess = resp_to_json['succeeded']\n\t# print ('Status:{0}'.format(isSuccess))s\n\t# if isSuccess == False:\n\texcept:\n\t\t# print ('Port not opened')\n\t\tisSuccess = False\n\t\t# print ('Error {0} - {1}'.format(resp_to_json['error']['code'],resp_to_json['error']['message']))\n\treturn isSuccess\n\ndef open_ports():\n\t\"\"\"\n\tScans scopes of ports and return list of open ports (open ARCHICAD copies)\n\t\"\"\"\n\tscope = (19723,19726)\n\t# scope = (19723,19743)\n\tports = [i for i in range(scope[0],scope[1]+1)if check_port(i)]\n\tset_ports(ports)\n\treturn ports\n\n\t\n\n\ndef pack(name,dictionary):\n\t\"\"\"\n\tPacking dictionary to json and dumps it to string\n\tINPUT:\n\t\tname: key name\n\t\tdictionary: data set to be send\n\t\"\"\"\n\tjson_def = {name:dictionary}\n\treturn json.dumps(json_def)\ndef packlist(_list):\n\t\"\"\"\n\tPacking list to json and dumps it to string\n\tINPUT:\n\t\tname: key name\n\t\tdictionary: data set to be send\n\t\"\"\"\n\tjson_def = _list\n\treturn json.dumps(json_def)\n\ndef unpack(json_def):\n\t\"\"\"\n\tUnpacking dumped json string into dictionary\n\tINPUT:\n\t\tjson_def: string to be parsed into dictionary\n\t\"\"\"\n\treturn json.loads(json_def)\n\n\n\n# # wrapping_index\ndef get_wrapped_value(current_index,lista):\n\t'''\n\twraps current_value to fit a lenght of a list\n\t'''\n\twrapped_index = 0\n\tif len(lista):\n\t\tmultiplication = int(current_index/len(lista)) \n\t\twrapped_index = current_index - (multiplication*len(lista))\n\treturn int(wrapped_index)\n\n\n\ndef show_menu(header_name,lista,current_index):\n\t'''\n\t\tdraws menu \n\t'''\n\theader = '''\n---------------\n{}\n---------------\n\t'''.format(header_name)\n\n\n\n\trows=[]\n\trows.append(header)\t\n\tfor i,j in enumerate(lista):\n\t\t\n\t\tif i == current_index:\n\t\t\tarrow = '<--pick ({})'.format(j)\n\t\telse:\n\t\t\tarrow = ''\n\t\trows.append('{} | {}     {}'.format(i,j,arrow))\n\n\tshow_content = '\\n'.join(rows)\n\t# print show_content\n\treturn show_content\n\ndef show_menu_two_inputs(header_name,lista,current_index,current_index2):\n\t'''\n\t\tdraws menu \n\t'''\n\theader = '''\n---------------\n{}\n---------------\n\t'''.format(header_name)\n\n\n\n\trows=[]\n\trows.append(header)\t\n\tfor i,j in enumerate(lista):\n\t\t\n\t\tif i == current_index:\n\t\t\tarrow = '<--IdField ({})'.format(j)\n\t\telse:\n\t\t\tarrow = ''\n\t\tif i == current_index2:\n\t\t\tarrow2 = '<--ValueField ({})'.format(j)\n\t\telse:\n\t\t\tarrow2 = ''\n\t\trows.append('{} | {}     {}     {}'.format(i,j,arrow,arrow2))\n\n\tshow_content = '\\n'.join(rows)\n\t# print show_content\n\treturn show_content\n\n\ndef getBuiltInPropertiesOfType(builtInPropertyNames,port,propType = 'General'):\n\t\"\"\"\n\tGets BuiltIn properties of Type\n\tinput:\n\t\tpropType: property type\n\t\tport: active port\n\t\"\"\"\n\tpropsOfType =[]\n\tfor prop in builtInPropertyNames:\n\t\tif propType in prop:\n\t\t\tpropsOfType.append(prop)\n\treturn propsOfType\n\ndef getBuiltInPropertyTypes(port):\n\t\"\"\"\n\tGets BuiltIn property Types for grouping\n\tinput:\n\t\tport: active port\n\t\"\"\"\n\n\tBuiltInPropertyTypes=[]\n\tjson_definition = {\n\t\"command\": \"API.GetAllPropertyNames\"\n\t}\n\n\tresult =  connect(json_definition,port)\n\n\tfor _property in result['result']['properties']:\n\t\tif 'BuiltIn' in _property['type']:\n\t\t\tstring= _property['nonLocalizedName']\n\t\t\tBuiltInPropertyTypes.append(string.split('_')[0])\n\t\tBuiltInPropertyTypes = list(set(BuiltInPropertyTypes))\n\treturn BuiltInPropertyTypes\n\ndef getBuiltInPropertyNames(port):\n\t'''\n\tGets list of 'BuiltIn' property names\n\tinput: \n\t\tport: active port \n\t'''\n\tBuiltInPropertyNames =[]\n\tjson_definition = {\n    \"command\": \"API.GetAllPropertyNames\"\n\t}\n\n\tresult =  connect(json_definition,port)\n\tfor _property in result['result']['properties']:\n\t\tif 'BuiltIn' in _property['type']:\n\t\t\tstring= _property['nonLocalizedName']\n\t\t\tBuiltInPropertyNames.append(string)\n\treturn BuiltInPropertyNames\n\ndef getUserDefinedPropertyId(group,propertyName,port):\n\t'''\n\tinput: \n\t\tproperty name,\n\t\tport\n\toutput:\n\t\tguid <str> of property\n\t'''\n\tcommand = {\n\t    \"command\": \"API.GetPropertyIds\",\n\t    \"parameters\": {\n\t        \"properties\": [\n\t            {\n\t                \"type\": \"UserDefined\",\n\t                \"localizedName\": [group,propertyName]\n\t        \t}\n\t        ]\n\t            \n\t    }\n\t}\n\n\tid = connect(command,port)\n\n\treturn id['result']['properties'][0]['propertyId']['guid']\n\n\ndef getBuiltInPropertyId(propertyName,port):\n\t'''\n\tinput: \n\t\tproperty name,\n\t\tport\n\toutput:\n\t\tguid <str> of property\n\t'''\n\tcommand = {\n\t    \"command\": \"API.GetPropertyIds\",\n\t    \"parameters\": {\n\t        \"properties\": [\n\t            {\n\t                \"type\": \"BuiltIn\",\n\t                \"nonLocalizedName\": propertyName\n\t        \t}\n\t        ]\n\t            \n\t    }\n\t}\n\n\tid = connect(command,port)\n\n\treturn id['result']['properties'][0]['propertyId']['guid']\n\n\ndef getUserDefinedPropertyGroups(port):\n\t\"\"\"\n\tGet all avaliable user defined property groups\n\tINPUT:\n\t\tport\n\tOutput (2 variables):\n\t\tgroups: list of groups names\n\t\tproperties: dictionary {group:list of properties names} \n\n\t\"\"\"\n\tjson_definition = {\n    \"command\": \"API.GetAllPropertyNames\"\n\t}\n\n\tresult =  connect(json_definition,port)\n\tuserDefGroups =[]\n\tuserDefProps =[]\n\tfor i in result['result']['properties']:\n\t\tif i['type'] == 'UserDefined':\n\t\t\tuserDefGroups.append(i['localizedName'][0])\n\t\t\tuserDefProps.append(i['localizedName'])\n\n\tuserDefGroups = list(set(userDefGroups))\n\n\tgroup_props={}\n\tfor group in userDefGroups:\n\t\t_props=[]\n\t\tfor prop in userDefProps:\n\t\t\tif prop[0] == group:\n\t\t\t\t_props.append(prop[1])\n\t\tgroup_props[group] = _props\n\n\t# return userDefProps\n\t# return userDefGroups\n\treturn userDefGroups,group_props\n\ndef getUserDefinedPropertiesOfGroup(port,group):\n\t\"\"\"\n\tGet all avaliable user defined properties in group\n\tINPUT:\n\t\tport int port avaliable\n\t\tgroup: string name\n\tOutput: list of properties in provided group\n\t\"\"\"\n\tprint \"props in group: {}\".format(group)\n\n\ndef getPropertyValue(elements,propertyId,port):\n\t'''\n\tgets property value\n\t'''\n\t_elements = elements#[0]\n\t_propertyId = propertyId#[0]\n\n\t_el = []\n\t_prop = []\n\tfor i in _elements:\n\n\t\t_el.append(\n\t\t\t{\n     \t\t \"elementId\": \n     \t\t \t{\n             \t\"guid\": i\n                }\n\t\t\t}\n\t\t\t)\n\n\tfor i in _propertyId:\n\n\t\t_prop.append(\n\t\t\t{\n     \t\t \"propertyId\": \n     \t\t \t{\n             \t\"guid\": i\n                }\n\t\t\t}\n\t\t\t)\n\n\tjson_definition = {\n        \"command\": \"API.GetPropertyValuesOfElements\",\n        \"parameters\": {\n            \"elements\":_el,\n            \"properties\": _prop\n        }\n\t}\n\n\tresult = connect(json_definition,port)\n\tval=[]\n\t\n\tif result['succeeded']:\n\t\tfor i in result['result']['propertyValuesForElements']:\n\t\t\t# print i['propertyValues'][0]['propertyValue']\n\t\t\t__val = i['propertyValues'][0]['propertyValue']\n\t\t\tval.append(__val)\n\t\treturn val\n\telse:\n\t\tprint result['error']['message']\n\t\treturn False\n\t\n\t# return result['result']\ndef getElementsTypes():\n\ttypes = [\n\t\"Wall\",\n\t\"Column\",\n\t\"Beam\",\n\t\"Window\",\n\t\"Door\",\n\t\"Object\",\n\t\"Lamp\",\n\t\"Slab\",\n\t\"Roof\",\n\t\"Mesh\",\n\t\"Zone\",\n\t\"CurtainWall\",\n\t\"Shell\",\n\t\"Skylight\",\n\t\"Morph\",\n\t\"Stair\",\n\t\"Railing\",\n\t\"Opening\"\n\t]\n\treturn types\n\ndef getAllElements(port):\n\t'''\n\t'''\n\tcommand = {\n\t\t\"command\": \"API.GetAllElements\"\n\t\t}\n\n\tresult = connect(command,port)\n\tif result['succeeded']:\n\t\telements=[]\n\t\tfor el in result['result']['elements']:\n\t\t\t# pass\n\t\t\telements.append(el['elementId']['guid'])\n\t\treturn json.dumps({'elements':elements})\n\telse:\n\t\treturn False\n\ndef getElementsByType(elementType,port):\n\tcommand = {\n\t\t\"command\": \"API.GetElementsByType\",\n\t\t\t\"parameters\": {\"elementType\": elementType\n\t\t\t}\n\t\t}\n\tresult = connect(command,port)\n\telements=[]\n\tfor e in result['result']['elements']:\n\t\telements.append(e['elementId']['guid'])\n\t_elements = json.dumps({'type':elementType,'elements':elements})\n\t# _elements = json.dumps({'elements':elements})\n\treturn _elements\n\n\ndef getClassificationSystems(port):\n\t\"\"\"\n\t\"\"\"\n\tjsn = {\n\t\"command\": \"API.GetAllClassificationSystems\"\n\t}\n\tresult = connect(jsn,port)\n\tsystems = [name for name in result['result']['classificationSystems']]\n\tnames = [name['name'] for name in systems]\n\tguids = [guid['classificationSystemId']['guid'] for guid in systems]\n\treturn dict(zip(names,guids))\n\ndef convert_types(value,type_name):\n\t# print value,type_name\n\tif type_name=='number':return float(value)\n\tif type_name=='string':return str(value)\n\tif type_name=='integer':\n\n\t\treturn int(value)\n\tif type_name=='boolean':return bool(value)\n\tif type_name=='area':return float(value)\n\tif type_name=='volume':return float(value)\n\tif type_name=='angle':return float(value)\n\tif type_name=='length':return float(value)\n\ndef prop_type(value,other_types=''):\n\tif other_types=='':\n\t\tif isinstance(value, str):\n\t\t\tif value == 'True'\t or value == 'False':\n\t\t\t\treturn'boolean'\n\t\t\telse:\n\t\t\t\treturn'string'.lower()\n\t\tif isinstance(value, int):return'integer'\n\t\tif isinstance(value, float):return'number'\n\t\tif isinstance(value, dict):return'singleEnum'\n\t\tif isinstance(value, list):return'multiEnum'\n\tif other_types=='area':return'area'\n\tif other_types=='volume':return'volume'\n\tif other_types=='length':return'length'\n\tif other_types=='angle':return'angle'\n\tif other_types=='boolean':return'boolean'\n\ndef setPropertyValue(e,p,v,port):\n\n\n\tjson_def = {}\n\tjson_def['command'] =  \"API.SetPropertyValuesOfElements\"\n\tjson_def['parameters'] =  {}\n\n \titem = {}\n\n \t\n \t\n \titems_list =[]\n\n \tk=0\n\n \tfor i in e:\n\t\t\n \t\t# items_list.append({'elementId':{'guid':i},'propertyId':{'guid':p},'propertyValue':v})\n \t\titems_list.append({'elementId':{'guid':i},'propertyId':{'guid':p},'propertyValue':{'type':v[k]['type'],'status':v[k]['status'],'value':v[k]['value']}})\n \t\tk=k+1\n\n\tjson_def['parameters']['elementPropertyValues'] =  items_list\n\tresult = connect(json_def,port)\n\t# print json_def\n\t# print result['succeeded']\t\t\n\n\treturn 'Set new Parameter value to {0} elements:{1} '.format(len(e),str(result['succeeded']))\n\t# # return result\n\t# # return json.dumps(json_def,indent=4,sort_keys=True)\n\n\n\n#-------- CLASSIFICATION SYSTEM\n\ndef getAllClassificationSystems(port):\n\tjson_def = {}\n\tjson_def['command'] =  \"API.GetAllClassificationSystems\"\n\tresult = connect(json_def,port)\n\ttry:\n\t\tresponse = result['succeeded']\n\texcept:\n\t\tresponse = result\n\tif response:\n\t\t_system_details = result['result']['classificationSystems']\n\t\t_systems = []\n\t\tfor i in _system_details:\n\t\t\t_system  = {}\t\n\t\t\t_system['name']\t\t\t= i['name']\n\t\t\t_system['source']\t\t= i['source']  \n\t\t\t_system['version']\t\t= i['version']  \n\t\t\t_system['date']\t\t\t= i['date']  \n\t\t\t_system['description']\t= i['description']  \n\t\t\t_system['guid']\t\t\t= i['classificationSystemId']['guid']  \n\t\t\t_systems.append(_system)\n\t\treturn _systems\n\telse:\n\t\treturn False\n\ndef GetAllClassificationsInSystem(port,_classSystemID):\n\tjson_def = {}\n\tjson_def['command'] =  \"API.GetAllClassificationsInSystem\"\n\tjson_def['parameters'] =  {\n\t\t\"classificationSystemId\": {\n            \"guid\": _classSystemID\n\t\t}\n\t}\n\tresult = connect(json_def,port)\n\n\ttry:\n\t\tresponse = result['succeeded']\n\texcept:\n\t\tresponse = result\n\t\treturn['message']['error']\n\tif response:\n\t\treturn result['result']['classificationItems']\n\n\n# def SetClassificationsOfElements():\ndef SetClassificationsOfElements(port,_elements,_systemID,_classificationID):\n\tjson_def = {}\n\tjson_def['command'] =  \"API.SetClassificationsOfElements\"\n\t_elementClassifications = []\n\tfor _el in _elements:\n\t\t_element_set = OrderedDict()\n\t\t_element_set[\"elementId\"]={\"guid\":_el}\n\t\t_element_set[\"classificationId\"]={\n\t\t\t\"classificationItemId\":\t\t{\"guid\":_classificationID},\n\t\t\t\"classificationSystemId\":\t{\"guid\":_systemID}\n\t\t}\n\t\t# _element_set[\"classificationSystemId\"]={\"guid\":_systemID}\n\t\t\n\t\t_elementClassifications.append(_element_set)\n\n\tjson_def['parameters'] = {\"elementClassifications\":_elementClassifications}\n\n\t# result = connect(json_def,port)\n\t\n\treturn json_def\n\ndef GetElementsByClassification(port,_classificationID):\n\tjson_def = {\n    \"command\": \"API.GetElementsByClassification\",\n    \"parameters\": {\n        \"classificationItemId\": {\n            \"guid\": _classificationID\n\t        }\n\t    }\n\t}\n\tresult = connect(json_def,port)\n\tif result['succeeded']:\n\t\telements=[]\n\t\tfor el in result['result']['elements']:\n\t\t\t# pass\n\t\t\telements.append(el['elementId']['guid'])\n\t\treturn json.dumps(elements)\n\telse:\n\t\treturn False\ndef attributes_names():\n\tatt = [\n\t'BuildingMaterial',\n\t'Composite',\n\t'Fill',\n\t'Layer',\n\t'LayerCombination',\n\t'Line',\n\t'PenTable',\n\t'Profile',\n\t'Surface',\n\t'ZoneCategory'\n\t]\n\treturn att\ndef GetAttributes(att_type,guid):\n\n\tcommands = {\n\t'BuildingMaterial':\"API.GetBuildingMaterialAttributes\",\n\t'Composite':\"API.GetCompositeAttributes\",\n\t'Fill':\"API.GetFillAttributes\",\n\t'Layer':\"API.GetLayerAttributes\",\n\t'LayerCombination':\"API.GetLayerCombinationAttributes\",\n\t'Line':\"API.GetLineAttributes\",\n\t'PenTable':\"API.GetPenTableAttributes\",\n\t'Profile':\"API.GetProfileAttributes\",\n\t'Surface':\"API.GetSurfaceAttributes\",\n\t'ZoneCategory':\"API.GetZoneCategoryAttributes\"\n\t}\n\n\n\t_guids=[]\n\tif isinstance(guid,str) or isinstance(guid,unicode):\n\t\tguid = [guid]\n\n\n\tfor g in guid:\n\t\t_guids.append({\"attributeId\": {\"guid\": g}})\n\n\tatt_def= {\n    \"command\": commands[att_type],\n    \"parameters\": {\"attributeIds\": _guids}\n    # \"parameters\": {\"attributeIds\": [{\"attributeId\": {\"guid\": guid}}]}\n    }\n\treturn att_def\n\ndef GetAttributesByType(att_type,port):\n\n\n\tjson_def = {\n    \"command\": \"API.GetAttributesByType\",\n    \"parameters\": {\n        \"attributeType\": att_type\n    \t}\n\t}\n\tresult = connect(json_def,port)\n# \tresult = connect(json_def,port)\n\tids =[id['attributeId']['guid'] for id in result['result']['attributeIds']]\n\treturn ids\n\t# print ids\n# \tjs = GetAttributes(att_type,ids[0])\n# \tatt = connect(js,19723) \n\t\n\t# return att['result']['attributes'][0]\n\ndef getAttributeDetails(attr,port):\n\t_surface_guid = api.GetAttributesByType(attr,port)\n\tf = api.GetAttributes(attr,_surface_guid)\n\tresult = api.connect(f,port)\n\treturn result['result']\n\n\nif __name__ == '__main__':\n\n\t# print r\n\n\tfor attr in attributes_names():\n\t# attr = 'Fill'\n\t\tattrByType = GetAttributesByType(attr, 19723)\n\t\tc = GetAttributes(attr,attrByType[0])\n\t\tr=connect(c,19723)\n\t\tprint '-'*10 + attr\n\t\tprint r\n# \tj = {\n#     \"command\": \"API.GetAttributesByType\",\n#     \"parameters\": {\n#         \"attributeType\": \"Layer\"\n#     }\n# }\n# \tlayers=[]\n# \tr= connect(j,19723)\n# \tfor i in r['result']['attributeIds']:\n# \t\tlayers.append(i['attributeId']['guid'])\n# \ti = 0 \n# \tfor i in range(len(layers)):\n# \t\tf= {\n# \t    \"command\": \"API.GetLayerAttributes\",\n# \t    \"parameters\": {\n# \t        \"attributeIds\": [\n# \t            {\n# \t                \"attributeId\": {\n# \t                    \"guid\": layers[i]\n# \t                }\n# \t            }\n# \t        ]\n# \t    }\n# \t}\n# \t\trr =connect(f,19723)\n# \t\tprint rr['result']['attributes'][0]['layerAttribute']['name']\n \t# print prop\n# # class Wrap():\n# # \t\"\"\"\n# # \tWrap type and guid to an object to send it wherever\n# # \t\"\"\"\n# # \tdef __init__(self,typ,guid,value=None):\n# # \t\tself.Type = typ\n# # \t\tself.Guid = guid\n# # \t\tself.Value = value\n\n\n\t\n\n\n\n\n# # def get_element_type_guid(element):\n# # \t# if isinstance(element, str) ==False:\n# # \telement_dict = {element.Type:element.Guid}\n# # \treturn element_dict\n\n\n\n\n\n\n\n\n\n\n\n# # def userDefined_properties(Result):\n# # \tuserdefined_properies ={}\n# # \tgroups=[]\n# # \tproperties=[]\n# # \tfor i in Result['result']['properties']:\n# # \t\tif 'UserDefined' in i['type']:\n# # \t\t\tgroups.append(i['localizedName'][0])\n# # \t\t\tproperties.append(i['localizedName'][1])\n# # \t\t\t# print i['localizedName'][0],'  |  ',i['localizedName'][1]\n# # \tgroups = set(groups)\n# # \tgroups = list(groups)\n\n\n\n\n# # def builtIn_properties(Result):\n# # \tbuiltin_properties =[]\n# # \tfor i in Result['result']['properties']:\n# # \t\tif 'BuiltIn' in i['type']:\n# # \t\t\tbuiltin_properties.append(i['nonLocalizedName'])\n\n\n# # \ttyp = []\n# # \tfor j in builtin_properties:\n# # \t\ttyp.append(j.split('_')[0])\n# # \ttyp = list(set(typ))\n# # \ttyp.sort()\n\n# # \tbuiltin_types = {}\n# # \tfor _typ in typ:\n# # \t\tprops_of_type =[]\n# # \t\tfor prop in builtin_properties:\n# # \t\t\tif prop.split('_')[0] == _typ:\n# # \t\t\t\tprops_of_type.append(prop)\n# # \t\tbuiltin_types[_typ] = props_of_type\n\n# # \treturn builtin_types\n\n\n\n\n# # def inputNormalizer(elementInput):\n# # \t'''\n# # \tnormalise two kind of element inputs:\n# # \t1. AC_Type passed by contener node\n# # \t2. archicad_api Wrap class\n# # \t'''\n# # \tt = str(elementInput[0].Type)\n# # \tprint 't: ',t \n# # \tsplited = t.split('_')\n# # \tif len(splited) > 1:\n# # \t\tname = splited[1]\n# # \t\t_elements = [str(el.Guid).upper() for el in elementInput]\n# # \t\t# print 'contaner',_elements\n# # \t\treturn Wrap(name,_elements)\n# # \telse:\n# # \t\tname = splited[0]\n# # \t\t# _elements = [el.Guid for el in elementInput]\n# # \t\t_elements = elementInput[0].Guid\n# # \t\t# print 'wrap',_elements\n# # \t\treturn Wrap(name,_elements)\n\n\n\n\n\n# # def AddInputParam(name,desc='Description'):\n# #     param = kernel.Parameters.Param_String()\n# #     param.NickName = name\n# #     param.Name = name\n# #     param.Description = desc\n# #     param.Access = kernel.GH_ParamAccess.list\n# #     index = self.Params.Input.Count\n# #     self.Params.RegisterInputParam(param,index)\n# #     self.Params.OnParametersChanged()\n\n\n\n# # def AddOutputParam(name,desc='Description'):\n# #     param = kernel.Parameters.Param_String()\n# #     param.NickName = name\n# #     param.Name = name\n# #     param.Description = desc\n# #     param.Access = kernel.GH_ParamAccess.list\n# #     index = self.Params.Output.Count\n  \n# #     self.Params.RegisterOutputParam(param,index)\n# #     self.Params.OnParametersChanged()\n\n\n\t\n# \t\t", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["surface", "classes", "layer", "line", "functions", "block", "mesh"], "original_file": "ENZYME-APD_tapir-archicad-automation_4ba29684f0.json", "repo": "ENZYME-APD/tapir-archicad-automation"}
{"instruction": "Implement the function 'process_event' for Rhino scripting", "code": "import redis\nimport time\nfrom django.utils import simplejson\nfrom django.http import HttpResponse\nfrom processor.models import RhinoScript, ComponentForm, Component\nfrom django.core.files import File\nfrom django.conf import settings\nfrom django.views.decorators.csrf import csrf_exempt\nimport logging\nimport hashlib\nimport glob\nlogger = logging.getLogger(__name__)\nfrom processor.scripting import *\nfrom processor.sound import *\nimport random\nimport time\nfrom pyga.requests import Tracker, Session, Visitor, Event\nimport celery\nimport mosquitto\n\nglobal mqtt\n\ndef process_event():\n\t# First work through the behaviours\n\tfiles = glob.glob(settings.ROOT_PATH+'/behaviours/*.py')\n\tfiles.sort()\n\tfor filename in files:\n\t\texecfile(filename)\n\ndef handle_event(event, params):\n\tif event.startswith('interaction.'):\n\t\tcelery.execute.send_task(\"tasks.ga\", [event])\n\tat_time = time.time()\n\tif event == 'environment.bluetooth.found' or event == 'environment.bluetooth.lost':\n\t\tif 'address' in params:\n\t\t\tparams['address'] = hashlib.sha1(params['address']+','+'rh1n0t3xt').hexdigest()\n\t\n\tmemory_obj = {'event':event, 'params':params, 'created':at_time}\n\tmemory_json = simplejson.dumps(memory_obj)\n\n\t# First update the various stats in redis.\n\tr = redis.StrictRedis(host='localhost', port=6379, db=0)\n\tp = r.pipeline()\n\tp.multi()\n\t\n\t# pushes a memory object to the memory list, then trims it down to 10 items.\n\tp.lpush('short_term', memory_json)\n\tp.ltrim('short_term', 0, 99)\n\n\t# Incrs the count of this item in long-term memory.\n\tp.hincrby('long_term', event, 1)\n\t# Store when the event last happened\n\tp.execute()\n\t\n\t#mqtt_connect()\n\tprocess_event()\n\t#mqtt_disconnect()\n\t\n@csrf_exempt\ndef add_event(request):\n\tif request.method == 'GET':\n\t\treturn HttpResponse(\"Please post to me!\")\n\telif request.method == 'POST':\n\t\tdata = simplejson.loads(request.body)\n\t\tif not 'event' in data or not 'params' in data:\n\t\t\treturn HttpResponse(\"Invalid parameters (need event and params)\")\n\t\thandle_event(data['event'], data['params'])\n\t\treturn HttpResponse(simplejson.dumps({'result':'success'}), mimetype='application/json')\n\n@csrf_exempt\ndef get_state(request):\n\tr = redis.StrictRedis(host='localhost', port=6379, db=0)\n\tmemory = r.lrange('short_term', 0, -1)\n\tshort_term = []\n\tfor memory_json in memory:\n\t\tmemory_obj = simplejson.loads(memory_json)\n\t\tshort_term.append(memory_obj)\n\n\tlogs = r.lrange('log', 0, -1)\n\tmessages = []\n\tfor log in logs:\n\t\tmessages.append(log)\n\n\tmood_keys = r.lrange('moods', 0, -1)\n\tmoods = []\n\tfor mood_key in mood_keys:\n\t\tmoods.append(mood_key)\n\n\tlong_term = {}\n\tlast_trigger = {}\n\tfor key in r.hkeys('long_term'):\n\t\tlong_term[key] = r.hget('long_term', key)\n\n\tfor key in r.hkeys('last_trigger'):\n\t\tlast_trigger[key] = r.hget('last_trigger', key)\n\n\t# Get stats\n\tstats = {}\n\tfor key in r.hkeys('stats'):\n\t\tstats[key] = r.hget('stats', key)\n\treturn HttpResponse(simplejson.dumps({'result':'success', 'messages':messages, 'short_term':short_term, 'long_term':long_term, 'moods':moods,  'last_trigger':last_trigger, 'stats':stats}), mimetype='application/json')\n\n@csrf_exempt\ndef register_component(request):\n\tdata = simplejson.loads(request.body)\n\tif not 'url' in data:\n\t\treturn HttpResponse(simplejson.dumps({'result':'failure', 'reason':'missing_url'}), mimetype='application/json')\n\n\tif not 'name' in data:\n\t\treturn HttpResponse(simplejson.dumps({'result':'failure', 'reason':'missing_name'}), mimetype='application/json')\n\n\n\t# TODO: Check that it validates before deleting old components\n\tComponent.objects.filter(name=data['name']).delete()\n\tform = ComponentForm({'url':data['url'], 'name':data['name']})\n\tif form.is_valid():\n\t\tnew_component = form.save()\n\t\treturn HttpResponse(simplejson.dumps({'result':'success'}))\n\telse:\n\t\treturn HttpResponse(simplejson.dumps({'result':'failure', 'reason':'invalid_data'}), mimetype='application/json')\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["line", "functions"], "original_file": "EricaTheRhino_brain_django_62a2490f23.json", "repo": "EricaTheRhino/brain_django"}
{"instruction": "Implement a function to create graph", "code": "from flask import Flask\nimport ghhops_server as hs\nimport rhino3dm as rg\nimport geometry as geo\nimport networkx as nx\n\napp = Flask(__name__)\nhops = hs.Hops(app)\n\n\n\n@hops.component(\n    \"/createGraph\",\n    name = \"Create Graph\",\n    inputs=[\n        hs.HopsInteger(\"Count X\", \"X\", \"Number of node in X\", hs.HopsParamAccess.ITEM, default= 1),\n        hs.HopsInteger(\"Count Y\", \"Y\", \"Number of node in Y\", hs.HopsParamAccess.ITEM, default= 1),\n        hs.HopsInteger(\"Layout\", \"L\", \"Layout to order Nodes\", hs.HopsParamAccess.ITEM, default= 0),\n\n\n    ],\n    outputs=[\n       hs.HopsPoint(\"Nodes\",\"N\",\"List of Nodes \", hs.HopsParamAccess.LIST),\n       hs.HopsCurve(\"Edges\",\"E\",\"List of Edges \", hs.HopsParamAccess.LIST)\n\n    ]\n)\ndef createGraph(X, Y, layout):\n\n    G = geo.createGridGraph(X, Y)\n    GW = geo.addRandomWeights(G)\n\n    nodes = geo.getNodes(GW, layout)\n    edges = geo.getEdges(GW, layout) \n\n    return nodes, edges\n\n@hops.component(\n    \"/convertToNetworkX\",\n    name = \" Convert Graph to NetworkX\",\n    inputs=[\n        hs.HopsPoint(\"Nodes\", \"N\", \"List of Nodes\",hs.HopsParamAccess.LIST),\n        hs.HopsCurve(\"Edges\", \"E\", \"List of Edges\", hs.HopsParamAccess.LIST),\n        hs.HopsInteger(\"Layout\", \"L\", \"Layout to order Nodes\", hs.HopsParamAccess.ITEM, default= 0)\n    ],\n    outputs=[\n        hs.HopsPoint(\"Nodes\",\"N\",\"List of Nodes \", hs.HopsParamAccess.LIST),\n        hs.HopsCurve(\"Edges\",\"E\",\"List of Edges \", hs.HopsParamAccess.LIST)\n    ]\n)\n\ndef convertToNetworkX(nodes, edges, layout):\n\n    G = nx.Graph()\n\n    nd =[]\n\n    #adding nodes\n    for node in nodes:\n        G.add_node(node)\n        nd.append((node.X, node.Y, node.Z))\n\n    #adding edges\n    for edge in edges:\n       pstart= nd.index((edge.PointAtStart.X, edge.PointAtStart.Y, edge.PointAtStart.Z))\n       pend = nd.index((edge.PointAtEnd.X, edge.PointAtEnd.Y, edge.PointAtEnd.Z)) \n       G.add_edge(pstart, pend)\n    \n    #applying random weights and getting nodes and edges as outputs\n    GW = geo.addRandomWeights(G)\n    \n    nodes = geo.getNodes(GW, layout)\n    edges = geo.getEdges(GW, layout)\n\n    return nodes, edges\n\nif __name__== \"__main__\":\n    app.run(debug=True)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["curve", "functions", "point"], "original_file": "Eridaa_1_RhinoGH--Python-hops-examples_09136aa282.json", "repo": "Eridaa/1.RhinoGH--Python-hops-examples"}
{"instruction": "Implement a function to create random points", "code": "from flask import Flask\nimport ghhops_server as hs\n\n#notice, we import another file as a library\nimport geometry as geo\n\n#we also import random library to generate some randomness \nimport random as r\n\n#finally we bring rhino3dm to create rhino geometry in python\nimport rhino3dm as rg\n\napp = Flask(__name__)\nhops = hs.Hops(app)\n\n\n@hops.component(\n    \"/createRandomPoints\",\n    name = \"Create Random Points\",\n    inputs=[\n        hs.HopsInteger(\"Count\", \"C\", \"Number of Random Points\", hs.HopsParamAccess.ITEM, default= 1),\n        hs.HopsNumber(\"X range of randomness\", \"X\", \"Maximum randomness in X directon\", hs.HopsParamAccess.ITEM),\n        hs.HopsNumber(\"Y range of randomness\", \"Y\", \"Maximum randomness in Y directon\", hs.HopsParamAccess.ITEM)\n\n    ],\n    outputs=[\n       hs.HopsPoint(\"Random Points\",\"RP\",\"List of generated random points \", hs.HopsParamAccess.LIST)\n    ]\n)\ndef createRandomPoints(count,rX, rY):\n\n    randomPts = []\n    for i in range(count):\n\n        #in each itereation generate some random points\n        random_x = r.uniform(-rX, rX)\n        random_y = r.uniform(-rY, rY)\n\n        #create a point with rhino3dm\n        random_pt = rg.Point3d(random_x, random_y, 0)\n        \n        #add point to the list\n        randomPts.append(random_pt)\n\n    return randomPts\n\n\n\n@hops.component(\n    \"/moreRandomPoints\",\n    name = \"More Random Points\",\n    inputs=[\n        hs.HopsInteger(\"Count\", \"C\", \"Number of Random Points\", hs.HopsParamAccess.ITEM, default= 1),\n        hs.HopsNumber(\"X range of randomness\", \"X\", \"Maximum randomness in X directon\", hs.HopsParamAccess.ITEM),\n        hs.HopsNumber(\"Y range of randomness\", \"Y\", \"Maximum randomness in Y directon\", hs.HopsParamAccess.ITEM)\n\n    ],\n    outputs=[\n       hs.HopsPoint(\"Random Points\",\"RP\",\"List of generated random points \", hs.HopsParamAccess.LIST)\n    ]\n)\ndef moreRandomPoints(count,rX, rY):\n\n    randomPts = geo.createRandomPoints(count, rX, rY)\n    return randomPts\n\n\n\n\n\nif __name__== \"__main__\":\n    app.run(debug=True)", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["functions", "point"], "original_file": "Eridaa_1_RhinoGH--Python-hops-examples_64a92a1507.json", "repo": "Eridaa/1.RhinoGH--Python-hops-examples"}
{"instruction": "Returns the type of conic section based on the curve's shape.", "code": "from . import Util\r\n\r\n\r\ndef GetConicSectionType(thisCurve, multiple=False):\r\n    \"\"\"\r\n    Returns the type of conic section based on the curve's shape.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/getconicsectiontype-curve\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve]\r\n    if multiple: args = [[item] for item in thisCurve]\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef CreateInterpolatedCurve(points, degree, multiple=False):\r\n    \"\"\"\r\n    Interpolates a sequence of points. Used by InterpCurve Command\r\n    This routine works best when degree=3.\r\n\r\n    Args:\r\n        degree (int): The degree of the curve >=1.  Degree must be odd.\r\n        points (IEnumerable<Point3d>): Points to interpolate (Count must be >= 2)\r\n\r\n    Returns:\r\n        Curve: interpolated curve on success. None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createinterpolatedcurve-point3darray_int\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [points, degree]\r\n    if multiple: args = zip(points, degree)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateInterpolatedCurve1(points, degree, knots, multiple=False):\r\n    \"\"\"\r\n    Interpolates a sequence of points. Used by InterpCurve Command\r\n    This routine works best when degree=3.\r\n\r\n    Args:\r\n        degree (int): The degree of the curve >=1.  Degree must be odd.\r\n        points (IEnumerable<Point3d>): Points to interpolate. For periodic curves if the final point is a\r\n            duplicate of the initial point it is  ignored. (Count must be >=2)\r\n        knots (CurveKnotStyle): Knot-style to use  and specifies if the curve should be periodic.\r\n\r\n    Returns:\r\n        Curve: interpolated curve on success. None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createinterpolatedcurve-point3darray_int_curveknotstyle\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [points, degree, knots]\r\n    if multiple: args = zip(points, degree, knots)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateInterpolatedCurve2(points, degree, knots, startTangent, endTangent, multiple=False):\r\n    \"\"\"\r\n    Interpolates a sequence of points. Used by InterpCurve Command\r\n    This routine works best when degree=3.\r\n\r\n    Args:\r\n        degree (int): The degree of the curve >=1.  Degree must be odd.\r\n        points (IEnumerable<Point3d>): Points to interpolate. For periodic curves if the final point is a\r\n            duplicate of the initial point it is  ignored. (Count must be >=2)\r\n        knots (CurveKnotStyle): Knot-style to use  and specifies if the curve should be periodic.\r\n        startTangent (Vector3d): A starting tangent.\r\n        endTangent (Vector3d): An ending tangent.\r\n\r\n    Returns:\r\n        Curve: interpolated curve on success. None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createinterpolatedcurve-point3darray_int_curveknotstyle_vector3d_vector3d\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [points, degree, knots, startTangent, endTangent]\r\n    if multiple: args = zip(points, degree, knots, startTangent, endTangent)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateSoftEditCurve(curve, t, delta, length, fixEnds, multiple=False):\r\n    \"\"\"\r\n    Creates a soft edited curve from an existing curve using a smooth field of influence.\r\n\r\n    Args:\r\n        curve (Curve): The curve to soft edit.\r\n        t (double): A parameter on the curve to move from. This location on the curve is moved, and the move\r\n            is smoothly tapered off with increasing distance along the curve from this parameter.\r\n        delta (Vector3d): The direction and magnitude, or maximum distance, of the move.\r\n        length (double): The distance along the curve from the editing point over which the strength\r\n            of the editing falls off smoothly.\r\n\r\n    Returns:\r\n        Curve: The soft edited curve if successful. None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createsofteditcurve-curve_double_vector3d_double_bool\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve, t, delta, length, fixEnds]\r\n    if multiple: args = zip(curve, t, delta, length, fixEnds)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateFilletCornersCurve(curve, radius, tolerance, angleTolerance, multiple=False):\r\n    \"\"\"\r\n    Rounds the corners of a kinked curve with arcs of a single, specified radius.\r\n\r\n    Args:\r\n        curve (Curve): The curve to fillet.\r\n        radius (double): The fillet radius.\r\n        tolerance (double): The tolerance. When in doubt, use the document's model space absolute tolerance.\r\n        angleTolerance (double): The angle tolerance in radians. When in doubt, use the document's model space angle tolerance.\r\n\r\n    Returns:\r\n        Curve: The filleted curve if successful. None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createfilletcornerscurve-curve_double_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve, radius, tolerance, angleTolerance]\r\n    if multiple: args = zip(curve, radius, tolerance, angleTolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateArcBlend(startPt, startDir, endPt, endDir, controlPointLengthRatio, multiple=False):\r\n    \"\"\"\r\n    Creates a polycurve consisting of two tangent arc segments that connect two points and two directions.\r\n\r\n    Args:\r\n        startPt (Point3d): Start of the arc blend curve.\r\n        startDir (Vector3d): Start direction of the arc blend curve.\r\n        endPt (Point3d): End of the arc blend curve.\r\n        endDir (Vector3d): End direction of the arc blend curve.\r\n        controlPointLengthRatio (double): The ratio of the control polygon lengths of the two arcs. Note, a value of 1.0\r\n            means the control polygon lengths for both arcs will be the same.\r\n\r\n    Returns:\r\n        Curve: The arc blend curve, or None on error.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createarcblend-point3d_vector3d_point3d_vector3d_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [startPt, startDir, endPt, endDir, controlPointLengthRatio]\r\n    if multiple: args = zip(startPt, startDir, endPt, endDir, controlPointLengthRatio)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateMeanCurve(curveA, curveB, angleToleranceRadians, multiple=False):\r\n    \"\"\"\r\n    Constructs a mean, or average, curve from two curves.\r\n\r\n    Args:\r\n        curveA (Curve): A first curve.\r\n        curveB (Curve): A second curve.\r\n        angleToleranceRadians (double): The angle tolerance, in radians, used to match kinks between curves.\r\n            If you are unsure how to set this parameter, then either use the\r\n            document's angle tolerance RhinoDoc.AngleToleranceRadians,\r\n            or the default value (RhinoMath.UnsetValue)\r\n\r\n    Returns:\r\n        Curve: The average curve, or None on error.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createmeancurve-curve_curve_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curveA, curveB, angleToleranceRadians]\r\n    if multiple: args = zip(curveA, curveB, angleToleranceRadians)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateMeanCurve1(curveA, curveB, multiple=False):\r\n    \"\"\"\r\n    Constructs a mean, or average, curve from two curves.\r\n\r\n    Args:\r\n        curveA (Curve): A first curve.\r\n        curveB (Curve): A second curve.\r\n\r\n    Returns:\r\n        Curve: The average curve, or None on error.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createmeancurve-curve_curve\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curveA, curveB]\r\n    if multiple: args = zip(curveA, curveB)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateBlendCurve(curveA, curveB, continuity, multiple=False):\r\n    \"\"\"\r\n    Create a Blend curve between two existing curves.\r\n\r\n    Args:\r\n        curveA (Curve): Curve to blend from (blending will occur at curve end point).\r\n        curveB (Curve): Curve to blend to (blending will occur at curve start point).\r\n        continuity (BlendContinuity): Continuity of blend.\r\n\r\n    Returns:\r\n        Curve: A curve representing the blend between A and B or None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createblendcurve-curve_curve_blendcontinuity\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curveA, curveB, continuity]\r\n    if multiple: args = zip(curveA, curveB, continuity)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateBlendCurve1(curveA, curveB, continuity, bulgeA, bulgeB, multiple=False):\r\n    \"\"\"\r\n    Create a Blend curve between two existing curves.\r\n\r\n    Args:\r\n        curveA (Curve): Curve to blend from (blending will occur at curve end point).\r\n        curveB (Curve): Curve to blend to (blending will occur at curve start point).\r\n        continuity (BlendContinuity): Continuity of blend.\r\n        bulgeA (double): Bulge factor at curveA end of blend. Values near 1.0 work best.\r\n        bulgeB (double): Bulge factor at curveB end of blend. Values near 1.0 work best.\r\n\r\n    Returns:\r\n        Curve: A curve representing the blend between A and B or None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createblendcurve-curve_curve_blendcontinuity_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curveA, curveB, continuity, bulgeA, bulgeB]\r\n    if multiple: args = zip(curveA, curveB, continuity, bulgeA, bulgeB)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateBlendCurve2(curve0, t0, reverse0, continuity0, curve1, t1, reverse1, continuity1, multiple=False):\r\n    \"\"\"\r\n    Makes a curve blend between 2 curves at the parameters specified\r\n    with the directions and continuities specified\r\n\r\n    Args:\r\n        curve0 (Curve): First curve to blend from\r\n        t0 (double): Parameter on first curve for blend endpoint\r\n        reverse0 (bool): If false, the blend will go in the natural direction of the curve.\r\n            If true, the blend will go in the opposite direction to the curve\r\n        continuity0 (BlendContinuity): Continuity for the blend at the start\r\n        curve1 (Curve): Second curve to blend from\r\n        t1 (double): Parameter on second curve for blend endpoint\r\n        reverse1 (bool): If false, the blend will go in the natural direction of the curve.\r\n            If true, the blend will go in the opposite direction to the curve\r\n        continuity1 (BlendContinuity): Continuity for the blend at the end\r\n\r\n    Returns:\r\n        Curve: The blend curve on success. None on failure\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createblendcurve-curve_double_bool_blendcontinuity_curve_double_bool_blendcontinuity\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve0, t0, reverse0, continuity0, curve1, t1, reverse1, continuity1]\r\n    if multiple: args = zip(curve0, t0, reverse0, continuity0, curve1, t1, reverse1, continuity1)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateTweenCurves(curve0, curve1, numCurves, multiple=False):\r\n    \"\"\"\r\n    Creates curves between two open or closed input curves. Uses the control points of the curves for finding tween curves.\r\n    That means the first control point of first curve is matched to first control point of the second curve and so on.\r\n    There is no matching of curves direction. Caller must match input curves direction before calling the function.\r\n\r\n    Args:\r\n        curve0 (Curve): The first, or starting, curve.\r\n        curve1 (Curve): The second, or ending, curve.\r\n        numCurves (int): Number of tween curves to create.\r\n\r\n    Returns:\r\n        Curve[]: An array of joint curves. This array can be empty.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createtweencurves-curve_curve_int\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve0, curve1, numCurves]\r\n    if multiple: args = zip(curve0, curve1, numCurves)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateTweenCurves1(curve0, curve1, numCurves, tolerance, multiple=False):\r\n    \"\"\"\r\n    Creates curves between two open or closed input curves. Uses the control points of the curves for finding tween curves.\r\n    That means the first control point of first curve is matched to first control point of the second curve and so on.\r\n    There is no matching of curves direction. Caller must match input curves direction before calling the function.\r\n\r\n    Args:\r\n        curve0 (Curve): The first, or starting, curve.\r\n        curve1 (Curve): The second, or ending, curve.\r\n        numCurves (int): Number of tween curves to create.\r\n\r\n    Returns:\r\n        Curve[]: An array of joint curves. This array can be empty.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createtweencurves-curve_curve_int_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve0, curve1, numCurves, tolerance]\r\n    if multiple: args = zip(curve0, curve1, numCurves, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateTweenCurvesWithMatching(curve0, curve1, numCurves, multiple=False):\r\n    \"\"\"\r\n    Creates curves between two open or closed input curves. Make the structure of input curves compatible if needed.\r\n    Refits the input curves to have the same structure. The resulting curves are usually more complex than input unless\r\n    input curves are compatible and no refit is needed. There is no matching of curves direction.\r\n    Caller must match input curves direction before calling the function.\r\n\r\n    Args:\r\n        curve0 (Curve): The first, or starting, curve.\r\n        curve1 (Curve): The second, or ending, curve.\r\n        numCurves (int): Number of tween curves to create.\r\n\r\n    Returns:\r\n        Curve[]: An array of joint curves. This array can be empty.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createtweencurveswithmatching-curve_curve_int\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve0, curve1, numCurves]\r\n    if multiple: args = zip(curve0, curve1, numCurves)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateTweenCurvesWithMatching1(curve0, curve1, numCurves, tolerance, multiple=False):\r\n    \"\"\"\r\n    Creates curves between two open or closed input curves. Make the structure of input curves compatible if needed.\r\n    Refits the input curves to have the same structure. The resulting curves are usually more complex than input unless\r\n    input curves are compatible and no refit is needed. There is no matching of curves direction.\r\n    Caller must match input curves direction before calling the function.\r\n\r\n    Args:\r\n        curve0 (Curve): The first, or starting, curve.\r\n        curve1 (Curve): The second, or ending, curve.\r\n        numCurves (int): Number of tween curves to create.\r\n\r\n    Returns:\r\n        Curve[]: An array of joint curves. This array can be empty.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createtweencurveswithmatching-curve_curve_int_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve0, curve1, numCurves, tolerance]\r\n    if multiple: args = zip(curve0, curve1, numCurves, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateTweenCurvesWithSampling(curve0, curve1, numCurves, numSamples, multiple=False):\r\n    \"\"\"\r\n    Creates curves between two open or closed input curves. Use sample points method to make curves compatible.\r\n    This is how the algorithm works: Divides the two curves into an equal number of points, finds the midpoint between the\r\n    corresponding points on the curves and interpolates the tween curve through those points. There is no matching of curves\r\n    direction. Caller must match input curves direction before calling the function.\r\n\r\n    Args:\r\n        curve0 (Curve): The first, or starting, curve.\r\n        curve1 (Curve): The second, or ending, curve.\r\n        numCurves (int): Number of tween curves to create.\r\n        numSamples (int): Number of sample points along input curves.\r\n\r\n    Returns:\r\n        Curve[]: >An array of joint curves. This array can be empty.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createtweencurveswithsampling-curve_curve_int_int\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve0, curve1, numCurves, numSamples]\r\n    if multiple: args = zip(curve0, curve1, numCurves, numSamples)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateTweenCurvesWithSampling1(curve0, curve1, numCurves, numSamples, tolerance, multiple=False):\r\n    \"\"\"\r\n    Creates curves between two open or closed input curves. Use sample points method to make curves compatible.\r\n    This is how the algorithm works: Divides the two curves into an equal number of points, finds the midpoint between the\r\n    corresponding points on the curves and interpolates the tween curve through those points. There is no matching of curves\r\n    direction. Caller must match input curves direction before calling the function.\r\n\r\n    Args:\r\n        curve0 (Curve): The first, or starting, curve.\r\n        curve1 (Curve): The second, or ending, curve.\r\n        numCurves (int): Number of tween curves to create.\r\n        numSamples (int): Number of sample points along input curves.\r\n\r\n    Returns:\r\n        Curve[]: >An array of joint curves. This array can be empty.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createtweencurveswithsampling-curve_curve_int_int_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve0, curve1, numCurves, numSamples, tolerance]\r\n    if multiple: args = zip(curve0, curve1, numCurves, numSamples, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef JoinCurves(inputCurves, multiple=False):\r\n    \"\"\"\r\n    Joins a collection of curve segments together.\r\n\r\n    Args:\r\n        inputCurves (IEnumerable<Curve>): Curve segments to join.\r\n\r\n    Returns:\r\n        Curve[]: An array of curves which contains.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/joincurves-curvearray\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [inputCurves]\r\n    if multiple: args = [[item] for item in inputCurves]\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef JoinCurves1(inputCurves, joinTolerance, multiple=False):\r\n    \"\"\"\r\n    Joins a collection of curve segments together.\r\n\r\n    Args:\r\n        inputCurves (IEnumerable<Curve>): An array, a list or any enumerable set of curve segments to join.\r\n        joinTolerance (double): Joining tolerance,\r\n            i.e. the distance between segment end-points that is allowed.\r\n\r\n    Returns:\r\n        Curve[]: An array of joint curves. This array can be empty.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/joincurves-curvearray_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [inputCurves, joinTolerance]\r\n    if multiple: args = zip(inputCurves, joinTolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef JoinCurves2(inputCurves, joinTolerance, preserveDirection, multiple=False):\r\n    \"\"\"\r\n    Joins a collection of curve segments together.\r\n\r\n    Args:\r\n        inputCurves (IEnumerable<Curve>): An array, a list or any enumerable set of curve segments to join.\r\n        joinTolerance (double): Joining tolerance,\r\n            i.e. the distance between segment end-points that is allowed.\r\n        preserveDirection (bool): If true, curve endpoints will be compared to curve start points.If false, all start and endpoints will be compared and copies of input curves may be reversed in output.\r\n\r\n    Returns:\r\n        Curve[]: An array of joint curves. This array can be empty.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/joincurves-curvearray_double_bool\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [inputCurves, joinTolerance, preserveDirection]\r\n    if multiple: args = zip(inputCurves, joinTolerance, preserveDirection)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef MakeEndsMeet(curveA, adjustStartCurveA, curveB, adjustStartCurveB, multiple=False):\r\n    \"\"\"\r\n    Makes adjustments to the ends of one or both input curves so that they meet at a point.\r\n\r\n    Args:\r\n        curveA (Curve): 1st curve to adjust.\r\n        adjustStartCurveA (bool): Which end of the 1st curve to adjust: True is start, False is end.\r\n        curveB (Curve): 2nd curve to adjust.\r\n        adjustStartCurveB (bool): which end of the 2nd curve to adjust true==start, false==end.\r\n\r\n    Returns:\r\n        bool: True on success.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/makeendsmeet-curve_bool_curve_bool\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curveA, adjustStartCurveA, curveB, adjustStartCurveB]\r\n    if multiple: args = zip(curveA, adjustStartCurveA, curveB, adjustStartCurveB)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef CreateFillet(curve0, curve1, radius, t0Base, t1Base, multiple=False):\r\n    \"\"\"\r\n    Computes the fillet arc for a curve filleting operation.\r\n\r\n    Args:\r\n        curve0 (Curve): First curve to fillet.\r\n        curve1 (Curve): Second curve to fillet.\r\n        radius (double): Fillet radius.\r\n        t0Base (double): Parameter on curve0 where the fillet ought to start (approximately).\r\n        t1Base (double): Parameter on curve1 where the fillet ought to end (approximately).\r\n\r\n    Returns:\r\n        Arc: The fillet arc on success, or Arc.Unset on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createfillet-curve_curve_double_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve0, curve1, radius, t0Base, t1Base]\r\n    if multiple: args = zip(curve0, curve1, radius, t0Base, t1Base)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef CreateFilletCurves(curve0, point0, curve1, point1, radius, join, trim, arcExtension, tolerance, angleTolerance, multiple=False):\r\n    \"\"\"\r\n    Creates a tangent arc between two curves and trims or extends the curves to the arc.\r\n\r\n    Args:\r\n        curve0 (Curve): The first curve to fillet.\r\n        point0 (Point3d): A point on the first curve that is near the end where the fillet will\r\n            be created.\r\n        curve1 (Curve): The second curve to fillet.\r\n        point1 (Point3d): A point on the second curve that is near the end where the fillet will\r\n            be created.\r\n        radius (double): The radius of the fillet.\r\n        join (bool): Join the output curves.\r\n        trim (bool): Trim copies of the input curves to the output fillet curve.\r\n        arcExtension (bool): Applies when arcs are filleted but need to be extended to meet the\r\n            fillet curve or chamfer line. If true, then the arc is extended\r\n            maintaining its validity. If false, then the arc is extended with a\r\n            line segment, which is joined to the arc converting it to a polycurve.\r\n        tolerance (double): The tolerance, generally the document's absolute tolerance.\r\n\r\n    Returns:\r\n        Curve[]: The results of the fillet operation. The number of output curves depends\r\n        on the input curves and the values of the parameters that were used\r\n        during the fillet operation. In most cases, the output array will contain\r\n        either one or three curves, although two curves can be returned if the\r\n        radius is zero and join = false.\r\n        For example, if both join and trim = true, then the output curve\r\n        will be a polycurve containing the fillet curve joined with trimmed copies\r\n        of the input curves. If join = False and trim = true, then three curves,\r\n        the fillet curve and trimmed copies of the input curves, will be returned.\r\n        If both join and trim = false, then just the fillet curve is returned.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createfilletcurves-curve_point3d_curve_point3d_double_bool_bool_bool_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve0, point0, curve1, point1, radius, join, trim, arcExtension, tolerance, angleTolerance]\r\n    if multiple: args = zip(curve0, point0, curve1, point1, radius, join, trim, arcExtension, tolerance, angleTolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateBooleanUnion(curves, multiple=False):\r\n    \"\"\"\r\n    Calculates the boolean union of two or more closed, planar curves.\r\n    Note, curves must be co-planar.\r\n\r\n    Args:\r\n        curves (IEnumerable<Curve>): The co-planar curves to union.\r\n\r\n    Returns:\r\n        Curve[]: Result curves on success, empty array if no union could be calculated.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createbooleanunion-curvearray\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curves]\r\n    if multiple: args = [[item] for item in curves]\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateBooleanUnion1(curves, tolerance, multiple=False):\r\n    \"\"\"\r\n    Calculates the boolean union of two or more closed, planar curves.\r\n    Note, curves must be co-planar.\r\n\r\n    Args:\r\n        curves (IEnumerable<Curve>): The co-planar curves to union.\r\n\r\n    Returns:\r\n        Curve[]: Result curves on success, empty array if no union could be calculated.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createbooleanunion-curvearray_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curves, tolerance]\r\n    if multiple: args = zip(curves, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateBooleanIntersection(curveA, curveB, multiple=False):\r\n    \"\"\"\r\n    Calculates the boolean intersection of two closed, planar curves.\r\n    Note, curves must be co-planar.\r\n\r\n    Args:\r\n        curveA (Curve): The first closed, planar curve.\r\n        curveB (Curve): The second closed, planar curve.\r\n\r\n    Returns:\r\n        Curve[]: Result curves on success, empty array if no intersection could be calculated.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createbooleanintersection-curve_curve\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curveA, curveB]\r\n    if multiple: args = zip(curveA, curveB)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateBooleanIntersection1(curveA, curveB, tolerance, multiple=False):\r\n    \"\"\"\r\n    Calculates the boolean intersection of two closed, planar curves.\r\n    Note, curves must be co-planar.\r\n\r\n    Args:\r\n        curveA (Curve): The first closed, planar curve.\r\n        curveB (Curve): The second closed, planar curve.\r\n\r\n    Returns:\r\n        Curve[]: Result curves on success, empty array if no intersection could be calculated.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createbooleanintersection-curve_curve_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curveA, curveB, tolerance]\r\n    if multiple: args = zip(curveA, curveB, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateBooleanDifference(curveA, curveB, multiple=False):\r\n    \"\"\"\r\n    Calculates the boolean difference between two closed, planar curves.\r\n    Note, curves must be co-planar.\r\n\r\n    Args:\r\n        curveA (Curve): The first closed, planar curve.\r\n        curveB (Curve): The second closed, planar curve.\r\n\r\n    Returns:\r\n        Curve[]: Result curves on success, empty array if no difference could be calculated.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createbooleandifference-curve_curve\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curveA, curveB]\r\n    if multiple: args = zip(curveA, curveB)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateBooleanDifference1(curveA, curveB, tolerance, multiple=False):\r\n    \"\"\"\r\n    Calculates the boolean difference between two closed, planar curves.\r\n    Note, curves must be co-planar.\r\n\r\n    Args:\r\n        curveA (Curve): The first closed, planar curve.\r\n        curveB (Curve): The second closed, planar curve.\r\n\r\n    Returns:\r\n        Curve[]: Result curves on success, empty array if no difference could be calculated.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createbooleandifference-curve_curve_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curveA, curveB, tolerance]\r\n    if multiple: args = zip(curveA, curveB, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateBooleanDifference2(curveA, subtractors, multiple=False):\r\n    \"\"\"\r\n    Calculates the boolean difference between a closed planar curve, and a list of closed planar curves.\r\n    Note, curves must be co-planar.\r\n\r\n    Args:\r\n        curveA (Curve): The first closed, planar curve.\r\n        subtractors (IEnumerable<Curve>): curves to subtract from the first closed curve.\r\n\r\n    Returns:\r\n        Curve[]: Result curves on success, empty array if no difference could be calculated.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createbooleandifference-curve_curvearray\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curveA, subtractors]\r\n    if multiple: args = zip(curveA, subtractors)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateBooleanDifference3(curveA, subtractors, tolerance, multiple=False):\r\n    \"\"\"\r\n    Calculates the boolean difference between a closed planar curve, and a list of closed planar curves.\r\n    Note, curves must be co-planar.\r\n\r\n    Args:\r\n        curveA (Curve): The first closed, planar curve.\r\n        subtractors (IEnumerable<Curve>): curves to subtract from the first closed curve.\r\n\r\n    Returns:\r\n        Curve[]: Result curves on success, empty array if no difference could be calculated.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createbooleandifference-curve_curvearray_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curveA, subtractors, tolerance]\r\n    if multiple: args = zip(curveA, subtractors, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateBooleanRegions(curves, plane, points, combineRegions, tolerance, multiple=False):\r\n    \"\"\"\r\n    Curve Boolean method, which trims and splits curves based on their overlapping regions.\r\n\r\n    Args:\r\n        curves (IEnumerable<Curve>): The input curves.\r\n        plane (Plane): Regions will be found in the projection of the curves to this plane.\r\n        points (IEnumerable<Point3d>): These points will be projected to plane. All regions that contain at least one of these points will be found.\r\n        combineRegions (bool): If true, then adjacent regions will be combined.\r\n        tolerance (double): Function tolerance. When in doubt, use the document's model absolute tolerance.\r\n\r\n    Returns:\r\n        CurveBooleanRegions: The curve Boolean regions if successful, None of no successful.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createbooleanregions-curvearray_plane_point3darray_bool_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curves, plane, points, combineRegions, tolerance]\r\n    if multiple: args = zip(curves, plane, points, combineRegions, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef CreateBooleanRegions1(curves, plane, combineRegions, tolerance, multiple=False):\r\n    \"\"\"\r\n    Calculates curve Boolean regions, which trims and splits curves based on their overlapping regions.\r\n\r\n    Args:\r\n        curves (IEnumerable<Curve>): The input curves.\r\n        plane (Plane): Regions will be found in the projection of the curves to this plane.\r\n        combineRegions (bool): If true, then adjacent regions will be combined.\r\n        tolerance (double): Function tolerance. When in doubt, use the document's model absolute tolerance.\r\n\r\n    Returns:\r\n        CurveBooleanRegions: The curve Boolean regions if successful, None of no successful.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createbooleanregions-curvearray_plane_bool_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curves, plane, combineRegions, tolerance]\r\n    if multiple: args = zip(curves, plane, combineRegions, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef CreateTextOutlines(text, font, textHeight, textStyle, closeLoops, plane, smallCapsScale, tolerance, multiple=False):\r\n    \"\"\"\r\n    Creates outline curves created from a text string. The functionality is similar to what you find in Rhino's TextObject command or TextEntity.Explode() in RhinoCommon.\r\n\r\n    Args:\r\n        text (string): The text from which to create outline curves.\r\n        font (string): The text font.\r\n        textHeight (double): The text height.\r\n        textStyle (int): The font style. The font style can be any number of the following: 0 - Normal, 1 - Bold, 2 - Italic\r\n        closeLoops (bool): Set this value to True when dealing with normal fonts and when you expect closed loops. You may want to set this to False when specifying a single-stroke font where you don't want closed loops.\r\n        plane (Plane): The plane on which the outline curves will lie.\r\n        smallCapsScale (double): Displays lower-case letters as small caps. Set the relative text size to a percentage of the normal text.\r\n        tolerance (double): The tolerance for the operation.\r\n\r\n    Returns:\r\n        Curve[]: An array containing one or more curves if successful.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createtextoutlines-string_string_double_int_bool_plane_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [text, font, textHeight, textStyle, closeLoops, plane, smallCapsScale, tolerance]\r\n    if multiple: args = zip(text, font, textHeight, textStyle, closeLoops, plane, smallCapsScale, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreateCurve2View(curveA, curveB, vectorA, vectorB, tolerance, angleTolerance, multiple=False):\r\n    \"\"\"\r\n    Creates a third curve from two curves that are planar in different construction planes.\r\n    The new curve looks the same as each of the original curves when viewed in each plane.\r\n\r\n    Args:\r\n        curveA (Curve): The first curve.\r\n        curveB (Curve): The second curve.\r\n        vectorA (Vector3d): A vector defining the normal direction of the plane which the first curve is drawn upon.\r\n        vectorB (Vector3d): A vector defining the normal direction of the plane which the second curve is drawn upon.\r\n        tolerance (double): The tolerance for the operation.\r\n        angleTolerance (double): The angle tolerance for the operation.\r\n\r\n    Returns:\r\n        Curve[]: An array containing one or more curves if successful.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createcurve2view-curve_curve_vector3d_vector3d_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curveA, curveB, vectorA, vectorB, tolerance, angleTolerance]\r\n    if multiple: args = zip(curveA, curveB, vectorA, vectorB, tolerance, angleTolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef DoDirectionsMatch(curveA, curveB, multiple=False):\r\n    \"\"\"\r\n    Determines whether two curves travel more or less in the same direction.\r\n\r\n    Args:\r\n        curveA (Curve): First curve to test.\r\n        curveB (Curve): Second curve to test.\r\n\r\n    Returns:\r\n        bool: True if both curves more or less point in the same direction,\r\n        False if they point in the opposite directions.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/dodirectionsmatch-curve_curve\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curveA, curveB]\r\n    if multiple: args = zip(curveA, curveB)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef ProjectToMesh(curve, mesh, direction, tolerance, multiple=False):\r\n    \"\"\"\r\n    Projects a curve to a mesh using a direction and tolerance.\r\n\r\n    Args:\r\n        curve (Curve): A curve.\r\n        mesh (Mesh): A mesh.\r\n        direction (Vector3d): A direction vector.\r\n        tolerance (double): A tolerance value.\r\n\r\n    Returns:\r\n        Curve[]: A curve array.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/projecttomesh-curve_mesh_vector3d_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve, mesh, direction, tolerance]\r\n    if multiple: args = zip(curve, mesh, direction, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef ProjectToMesh1(curve, meshes, direction, tolerance, multiple=False):\r\n    \"\"\"\r\n    Projects a curve to a set of meshes using a direction and tolerance.\r\n\r\n    Args:\r\n        curve (Curve): A curve.\r\n        meshes (IEnumerable<Mesh>): A list, an array or any enumerable of meshes.\r\n        direction (Vector3d): A direction vector.\r\n        tolerance (double): A tolerance value.\r\n\r\n    Returns:\r\n        Curve[]: A curve array.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/projecttomesh-curve_mesharray_vector3d_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve, meshes, direction, tolerance]\r\n    if multiple: args = zip(curve, meshes, direction, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef ProjectToMesh2(curves, meshes, direction, tolerance, multiple=False):\r\n    \"\"\"\r\n    Projects a curve to a set of meshes using a direction and tolerance.\r\n\r\n    Args:\r\n        curves (IEnumerable<Curve>): A list, an array or any enumerable of curves.\r\n        meshes (IEnumerable<Mesh>): A list, an array or any enumerable of meshes.\r\n        direction (Vector3d): A direction vector.\r\n        tolerance (double): A tolerance value.\r\n\r\n    Returns:\r\n        Curve[]: A curve array.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/projecttomesh-curvearray_mesharray_vector3d_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curves, meshes, direction, tolerance]\r\n    if multiple: args = zip(curves, meshes, direction, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef ProjectToBrep(curve, brep, direction, tolerance, multiple=False):\r\n    \"\"\"\r\n    Projects a Curve onto a Brep along a given direction.\r\n\r\n    Args:\r\n        curve (Curve): Curve to project.\r\n        brep (Brep): Brep to project onto.\r\n        direction (Vector3d): Direction of projection.\r\n        tolerance (double): Tolerance to use for projection.\r\n\r\n    Returns:\r\n        Curve[]: An array of projected curves or empty array if the projection set is empty.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/projecttobrep-curve_brep_vector3d_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve, brep, direction, tolerance]\r\n    if multiple: args = zip(curve, brep, direction, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef ProjectToBrep1(curve, breps, direction, tolerance, multiple=False):\r\n    \"\"\"\r\n    Projects a Curve onto a collection of Breps along a given direction.\r\n\r\n    Args:\r\n        curve (Curve): Curve to project.\r\n        breps (IEnumerable<Brep>): Breps to project onto.\r\n        direction (Vector3d): Direction of projection.\r\n        tolerance (double): Tolerance to use for projection.\r\n\r\n    Returns:\r\n        Curve[]: An array of projected curves or empty array if the projection set is empty.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/projecttobrep-curve_breparray_vector3d_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve, breps, direction, tolerance]\r\n    if multiple: args = zip(curve, breps, direction, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef ProjectToBrep2(curve, breps, direction, tolerance, multiple=False):\r\n    \"\"\"\r\n    Projects a Curve onto a collection of Breps along a given direction.\r\n\r\n    Args:\r\n        curve (Curve): Curve to project.\r\n        breps (IEnumerable<Brep>): Breps to project onto.\r\n        direction (Vector3d): Direction of projection.\r\n        tolerance (double): Tolerance to use for projection.\r\n\r\n    Returns:\r\n        Curve[]: An array of projected curves or None if the projection set is empty.\r\n        brepIndices (int[]): (out) Integers that identify for each resulting curve which Brep it was projected onto.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/projecttobrep-curve_breparray_vector3d_double_intarray\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve, breps, direction, tolerance]\r\n    if multiple: args = zip(curve, breps, direction, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef ProjectToBrep3(curves, breps, direction, tolerance, multiple=False):\r\n    \"\"\"\r\n    Projects a collection of Curves onto a collection of Breps along a given direction.\r\n\r\n    Args:\r\n        curves (IEnumerable<Curve>): Curves to project.\r\n        breps (IEnumerable<Brep>): Breps to project onto.\r\n        direction (Vector3d): Direction of projection.\r\n        tolerance (double): Tolerance to use for projection.\r\n\r\n    Returns:\r\n        Curve[]: An array of projected curves or empty array if the projection set is empty.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/projecttobrep-curvearray_breparray_vector3d_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curves, breps, direction, tolerance]\r\n    if multiple: args = zip(curves, breps, direction, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef ProjectToBrep4(curves, breps, direction, tolerance, multiple=False):\r\n    \"\"\"\r\n    Projects a collection of Curves onto a collection of Breps along a given direction.\r\n\r\n    Args:\r\n        curves (IEnumerable<Curve>): Curves to project.\r\n        breps (IEnumerable<Brep>): Breps to project onto.\r\n        direction (Vector3d): Direction of projection.\r\n        tolerance (double): Tolerance to use for projection.\r\n\r\n    Returns:\r\n        Curve[]: An array of projected curves. Array is empty if the projection set is empty.\r\n        curveIndices (int[]): Index of which curve in the input list was the source for a curve in the return array.\r\n        brepIndices (int[]): Index of which brep was used to generate a curve in the return array.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/projecttobrep-curvearray_breparray_vector3d_double_intarray_intarray\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curves, breps, direction, tolerance]\r\n    if multiple: args = zip(curves, breps, direction, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef ProjectToPlane(curve, plane, multiple=False):\r\n    \"\"\"\r\n    Constructs a curve by projecting an existing curve to a plane.\r\n\r\n    Args:\r\n        curve (Curve): A curve.\r\n        plane (Plane): A plane.\r\n\r\n    Returns:\r\n        Curve: The projected curve on success; None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/projecttoplane-curve_plane\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve, plane]\r\n    if multiple: args = zip(curve, plane)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef PullToBrepFace(curve, face, tolerance, multiple=False):\r\n    \"\"\"\r\n    Pull a curve to a BrepFace using closest point projection.\r\n\r\n    Args:\r\n        curve (Curve): Curve to pull.\r\n        face (BrepFace): Brep face that pulls.\r\n        tolerance (double): Tolerance to use for pulling.\r\n\r\n    Returns:\r\n        Curve[]: An array of pulled curves, or an empty array on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/pulltobrepface-curve_brepface_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve, face, tolerance]\r\n    if multiple: args = zip(curve, face, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef PlanarClosedCurveRelationship(curveA, curveB, testPlane, tolerance, multiple=False):\r\n    \"\"\"\r\n    Determines whether two coplanar simple closed curves are disjoint or intersect;\r\n    otherwise, if the regions have a containment relationship, discovers\r\n    which curve encloses the other.\r\n\r\n    Args:\r\n        curveA (Curve): A first curve.\r\n        curveB (Curve): A second curve.\r\n        testPlane (Plane): A plane.\r\n        tolerance (double): A tolerance value.\r\n\r\n    Returns:\r\n        RegionContainment: A value indicating the relationship between the first and the second curve.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/planarclosedcurverelationship-curve_curve_plane_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curveA, curveB, testPlane, tolerance]\r\n    if multiple: args = zip(curveA, curveB, testPlane, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef PlanarCurveCollision(curveA, curveB, testPlane, tolerance, multiple=False):\r\n    \"\"\"\r\n    Determines if two coplanar curves collide (intersect).\r\n\r\n    Args:\r\n        curveA (Curve): A curve.\r\n        curveB (Curve): Another curve.\r\n        testPlane (Plane): A valid plane containing the curves.\r\n        tolerance (double): A tolerance value for intersection.\r\n\r\n    Returns:\r\n        bool: True if the curves intersect, otherwise false\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/planarcurvecollision-curve_curve_plane_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curveA, curveB, testPlane, tolerance]\r\n    if multiple: args = zip(curveA, curveB, testPlane, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef DuplicateSegments(thisCurve, multiple=False):\r\n    \"\"\"\r\n    Polylines will be exploded into line segments. ExplodeCurves will\r\n    return the curves in topological order.\r\n\r\n    Returns:\r\n        Curve[]: An array of all the segments that make up this curve.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/duplicatesegments-curve\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve]\r\n    if multiple: args = [[item] for item in thisCurve]\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef Smooth(thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem, multiple=False):\r\n    \"\"\"\r\n    Smooths a curve by averaging the positions of control points in a specified region.\r\n\r\n    Args:\r\n        smoothFactor (double): The smoothing factor, which controls how much control points move towards the average of the neighboring control points.\r\n        bXSmooth (bool): When True control points move in X axis direction.\r\n        bYSmooth (bool): When True control points move in Y axis direction.\r\n        bZSmooth (bool): When True control points move in Z axis direction.\r\n        bFixBoundaries (bool): When True the curve ends don't move.\r\n        coordinateSystem (SmoothingCoordinateSystem): The coordinates to determine the direction of the smoothing.\r\n\r\n    Returns:\r\n        Curve: The smoothed curve if successful, None otherwise.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/smooth-curve_double_bool_bool_bool_bool_smoothingcoordinatesystem\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem]\r\n    if multiple: args = zip(thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef Smooth1(thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem, plane, multiple=False):\r\n    \"\"\"\r\n    Smooths a curve by averaging the positions of control points in a specified region.\r\n\r\n    Args:\r\n        smoothFactor (double): The smoothing factor, which controls how much control points move towards the average of the neighboring control points.\r\n        bXSmooth (bool): When True control points move in X axis direction.\r\n        bYSmooth (bool): When True control points move in Y axis direction.\r\n        bZSmooth (bool): When True control points move in Z axis direction.\r\n        bFixBoundaries (bool): When True the curve ends don't move.\r\n        coordinateSystem (SmoothingCoordinateSystem): The coordinates to determine the direction of the smoothing.\r\n        plane (Plane): If SmoothingCoordinateSystem.CPlane specified, then the construction plane.\r\n\r\n    Returns:\r\n        Curve: The smoothed curve if successful, None otherwise.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/smooth-curve_double_bool_bool_bool_bool_smoothingcoordinatesystem_plane\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem, plane]\r\n    if multiple: args = zip(thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem, plane)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef GetLocalPerpPoint(thisCurve, testPoint, seedParmameter, multiple=False):\r\n    \"\"\"\r\n    Search for a location on the curve, near seedParmameter, that is perpendicular to a test point.\r\n\r\n    Args:\r\n        testPoint (Point3d): The test point.\r\n        seedParmameter (double): A \"seed\" parameter on the curve.\r\n\r\n    Returns:\r\n        bool: True if a solution is found, False otherwise.\r\n        curveParameter (double): The parameter value at the perpendicular point\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/getlocalperppoint-curve_point3d_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, testPoint, seedParmameter]\r\n    if multiple: args = zip(thisCurve, testPoint, seedParmameter)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef GetLocalPerpPoint1(thisCurve, testPoint, seedParmameter, subDomain, multiple=False):\r\n    \"\"\"\r\n    Search for a location on the curve, near seedParmameter, that is perpendicular to a test point.\r\n\r\n    Args:\r\n        testPoint (Point3d): The test point.\r\n        seedParmameter (double): A \"seed\" parameter on the curve.\r\n        subDomain (Interval): The sub-domain of the curve to search.\r\n\r\n    Returns:\r\n        bool: True if a solution is found, False otherwise.\r\n        curveParameter (double): The parameter value at the perpendicular point\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/getlocalperppoint-curve_point3d_double_interval_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, testPoint, seedParmameter, subDomain]\r\n    if multiple: args = zip(thisCurve, testPoint, seedParmameter, subDomain)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef GetLocalTangentPoint(thisCurve, testPoint, seedParmameter, multiple=False):\r\n    \"\"\"\r\n    Search for a location on the curve, near seedParmameter, that is tangent to a test point.\r\n\r\n    Args:\r\n        testPoint (Point3d): The test point.\r\n        seedParmameter (double): A \"seed\" parameter on the curve.\r\n\r\n    Returns:\r\n        bool: True if a solution is found, False otherwise.\r\n        curveParameter (double): The parameter value at the tangent point\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/getlocaltangentpoint-curve_point3d_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, testPoint, seedParmameter]\r\n    if multiple: args = zip(thisCurve, testPoint, seedParmameter)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef GetLocalTangentPoint1(thisCurve, testPoint, seedParmameter, subDomain, multiple=False):\r\n    \"\"\"\r\n    Search for a location on the curve, near seedParmameter, that is tangent to a test point.\r\n\r\n    Args:\r\n        testPoint (Point3d): The test point.\r\n        seedParmameter (double): A \"seed\" parameter on the curve.\r\n        subDomain (Interval): The sub-domain of the curve to search.\r\n\r\n    Returns:\r\n        bool: True if a solution is found, False otherwise.\r\n        curveParameter (double): The parameter value at the tangent point\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/getlocaltangentpoint-curve_point3d_double_interval_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, testPoint, seedParmameter, subDomain]\r\n    if multiple: args = zip(thisCurve, testPoint, seedParmameter, subDomain)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef InflectionPoints(thisCurve, multiple=False):\r\n    \"\"\"\r\n    Returns a curve's inflection points. An inflection point is a location on\r\n    a curve at which the sign of the curvature (i.e., the concavity) changes.\r\n    The curvature at these locations is always 0.\r\n\r\n    Returns:\r\n        Point3d[]: An array of points if successful, None if not successful or on error.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/inflectionpoints-curve\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve]\r\n    if multiple: args = [[item] for item in thisCurve]\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToPoint3d(response)\r\n    return response\r\n\r\n\r\ndef MaxCurvaturePoints(thisCurve, multiple=False):\r\n    \"\"\"\r\n    Returns a curve's maximum curvature points. The maximum curvature points identify\r\n    where the curvature starts to decrease in both directions from the points.\r\n\r\n    Returns:\r\n        Point3d[]: An array of points if successful, None if not successful or on error.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/maxcurvaturepoints-curve\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve]\r\n    if multiple: args = [[item] for item in thisCurve]\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToPoint3d(response)\r\n    return response\r\n\r\n\r\ndef MakeClosed(thisCurve, tolerance, multiple=False):\r\n    \"\"\"\r\n    If IsClosed, just return true. Otherwise, decide if curve can be closed as\r\n    follows: Linear curves polylinear curves with 2 segments, NURBS with 3 or less\r\n    control points cannot be made closed. Also, if tolerance > 0 and the gap between\r\n    start and end is larger than tolerance, curve cannot be made closed.\r\n    Adjust the curve's endpoint to match its start point.\r\n\r\n    Args:\r\n        tolerance (double): If nonzero, and the gap is more than tolerance, curve cannot be made closed.\r\n\r\n    Returns:\r\n        bool: True on success, False on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/makeclosed-curve_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, tolerance]\r\n    if multiple: args = zip(thisCurve, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef LcoalClosestPoint(thisCurve, testPoint, seed, multiple=False):\r\n    \"\"\"\r\n    Find parameter of the point on a curve that is locally closest to\r\n    the testPoint.  The search for a local close point starts at\r\n    a seed parameter.\r\n\r\n    Args:\r\n        testPoint (Point3d): A point to test against.\r\n        seed (double): The seed parameter.\r\n\r\n    Returns:\r\n        bool: True if the search is successful, False if the search fails.\r\n        t (double): >Parameter of the curve that is closest to testPoint.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/lcoalclosestpoint-curve_point3d_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, testPoint, seed]\r\n    if multiple: args = zip(thisCurve, testPoint, seed)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef LocalClosestPoint(thisCurve, testPoint, seed, multiple=False):\r\n    \"\"\"\r\n    Find parameter of the point on a curve that is locally closest to\r\n    the testPoint.  The search for a local close point starts at\r\n    a seed parameter.\r\n\r\n    Args:\r\n        testPoint (Point3d): A point to test against.\r\n        seed (double): The seed parameter.\r\n\r\n    Returns:\r\n        bool: True if the search is successful, False if the search fails.\r\n        t (double): >Parameter of the curve that is closest to testPoint.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/localclosestpoint-curve_point3d_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, testPoint, seed]\r\n    if multiple: args = zip(thisCurve, testPoint, seed)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef ClosestPoint(thisCurve, testPoint, multiple=False):\r\n    \"\"\"\r\n    Finds parameter of the point on a curve that is closest to testPoint.\r\n    If the maximumDistance parameter is > 0, then only points whose distance\r\n    to the given point is <= maximumDistance will be returned.  Using a\r\n    positive value of maximumDistance can substantially speed up the search.\r\n\r\n    Args:\r\n        testPoint (Point3d): Point to search from.\r\n\r\n    Returns:\r\n        bool: True on success, False on failure.\r\n        t (double): Parameter of local closest point.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/closestpoint-curve_point3d_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, testPoint]\r\n    if multiple: args = zip(thisCurve, testPoint)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef ClosestPoint1(thisCurve, testPoint, maximumDistance, multiple=False):\r\n    \"\"\"\r\n    Finds the parameter of the point on a curve that is closest to testPoint.\r\n    If the maximumDistance parameter is > 0, then only points whose distance\r\n    to the given point is <= maximumDistance will be returned.  Using a\r\n    positive value of maximumDistance can substantially speed up the search.\r\n\r\n    Args:\r\n        testPoint (Point3d): Point to project.\r\n        maximumDistance (double): The maximum allowed distance.\r\n            Past this distance, the search is given up and False is returned.Use 0 to turn off this parameter.\r\n\r\n    Returns:\r\n        bool: True on success, False on failure.\r\n        t (double): parameter of local closest point returned here.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/closestpoint-curve_point3d_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, testPoint, maximumDistance]\r\n    if multiple: args = zip(thisCurve, testPoint, maximumDistance)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef ClosestPoints(thisCurve, otherCurve, multiple=False):\r\n    \"\"\"\r\n    Gets closest points between this and another curves.\r\n\r\n    Args:\r\n        otherCurve (Curve): The other curve.\r\n\r\n    Returns:\r\n        bool: True on success; False on error.\r\n        pointOnThisCurve (Point3d): The point on this curve. This out parameter is assigned during this call.\r\n        pointOnOtherCurve (Point3d): The point on other curve. This out parameter is assigned during this call.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/closestpoints-curve_curve_point3d_point3d\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, otherCurve]\r\n    if multiple: args = zip(thisCurve, otherCurve)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef Contains(thisCurve, testPoint, multiple=False):\r\n    \"\"\"\r\n    Computes the relationship between a point and a closed curve region.\r\n    This curve must be closed or the return value will be Unset.\r\n    Both curve and point are projected to the World XY plane.\r\n\r\n    Args:\r\n        testPoint (Point3d): Point to test.\r\n\r\n    Returns:\r\n        PointContainment: Relationship between point and curve region.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/contains-curve_point3d\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, testPoint]\r\n    if multiple: args = zip(thisCurve, testPoint)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef Contains1(thisCurve, testPoint, plane, multiple=False):\r\n    \"\"\"\r\n    Computes the relationship between a point and a closed curve region.\r\n    This curve must be closed or the return value will be Unset.\r\n\r\n    Args:\r\n        testPoint (Point3d): Point to test.\r\n        plane (Plane): Plane in which to compare point and region.\r\n\r\n    Returns:\r\n        PointContainment: Relationship between point and curve region.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/contains-curve_point3d_plane\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, testPoint, plane]\r\n    if multiple: args = zip(thisCurve, testPoint, plane)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef Contains2(thisCurve, testPoint, plane, tolerance, multiple=False):\r\n    \"\"\"\r\n    Computes the relationship between a point and a closed curve region.\r\n    This curve must be closed or the return value will be Unset.\r\n\r\n    Args:\r\n        testPoint (Point3d): Point to test.\r\n        plane (Plane): Plane in which to compare point and region.\r\n        tolerance (double): Tolerance to use during comparison.\r\n\r\n    Returns:\r\n        PointContainment: Relationship between point and curve region.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/contains-curve_point3d_plane_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, testPoint, plane, tolerance]\r\n    if multiple: args = zip(thisCurve, testPoint, plane, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef ExtremeParameters(thisCurve, direction, multiple=False):\r\n    \"\"\"\r\n    Returns the parameter values of all local extrema.\r\n    Parameter values are in increasing order so consecutive extrema\r\n    define an interval on which each component of the curve is monotone.\r\n    Note, non-periodic curves always return the end points.\r\n\r\n    Args:\r\n        direction (Vector3d): The direction in which to perform the calculation.\r\n\r\n    Returns:\r\n        double[]: The parameter values of all local extrema.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/extremeparameters-curve_vector3d\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, direction]\r\n    if multiple: args = zip(thisCurve, direction)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef CreatePeriodicCurve(curve, multiple=False):\r\n    \"\"\"\r\n    Removes kinks from a curve. Periodic curves deform smoothly without kinks.\r\n\r\n    Args:\r\n        curve (Curve): The curve to make periodic. Curve must have degree >= 2.\r\n\r\n    Returns:\r\n        Curve: The resulting curve if successful, None otherwise.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createperiodiccurve-curve\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve]\r\n    if multiple: args = [[item] for item in curve]\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef CreatePeriodicCurve1(curve, smooth, multiple=False):\r\n    \"\"\"\r\n    Removes kinks from a curve. Periodic curves deform smoothly without kinks.\r\n\r\n    Args:\r\n        curve (Curve): The curve to make periodic. Curve must have degree >= 2.\r\n        smooth (bool): If true, smooths any kinks in the curve and moves control points to make a smooth curve.\r\n            If false, control point locations are not changed or changed minimally (only one point may move) and only the knot vector is altered.\r\n\r\n    Returns:\r\n        Curve: The resulting curve if successful, None otherwise.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/createperiodiccurve-curve_bool\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [curve, smooth]\r\n    if multiple: args = zip(curve, smooth)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef PointAtLength(thisCurve, length, multiple=False):\r\n    \"\"\"\r\n    Gets a point at a certain length along the curve. The length must be\r\n    non-negative and less than or equal to the length of the curve.\r\n    Lengths will not be wrapped when the curve is closed or periodic.\r\n\r\n    Args:\r\n        length (double): Length along the curve between the start point and the returned point.\r\n\r\n    Returns:\r\n        Point3d: Point on the curve at the specified length from the start point or Poin3d.Unset on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/pointatlength-curve_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, length]\r\n    if multiple: args = zip(thisCurve, length)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToPoint3d(response)\r\n    return response\r\n\r\n\r\ndef PointAtNormalizedLength(thisCurve, length, multiple=False):\r\n    \"\"\"\r\n    Gets a point at a certain normalized length along the curve. The length must be\r\n    between or including 0.0 and 1.0, where 0.0 equals the start of the curve and\r\n    1.0 equals the end of the curve.\r\n\r\n    Args:\r\n        length (double): Normalized length along the curve between the start point and the returned point.\r\n\r\n    Returns:\r\n        Point3d: Point on the curve at the specified normalized length from the start point or Poin3d.Unset on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/pointatnormalizedlength-curve_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, length]\r\n    if multiple: args = zip(thisCurve, length)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToPoint3d(response)\r\n    return response\r\n\r\n\r\ndef PerpendicularFrameAt(thisCurve, t, multiple=False):\r\n    \"\"\"\r\n    Return a 3d frame at a parameter. This is slightly different than FrameAt in\r\n    that the frame is computed in a way so there is minimal rotation from one\r\n    frame to the next.\r\n\r\n    Args:\r\n        t (double): Evaluation parameter.\r\n\r\n    Returns:\r\n        bool: True on success, False on failure.\r\n        plane (Plane): The frame is returned here.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/perpendicularframeat-curve_double_plane\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, t]\r\n    if multiple: args = zip(thisCurve, t)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef GetPerpendicularFrames(thisCurve, parameters, multiple=False):\r\n    \"\"\"\r\n    Gets a collection of perpendicular frames along the curve. Perpendicular frames\r\n    are also known as 'Zero-twisting frames' and they minimize rotation from one frame to the next.\r\n\r\n    Args:\r\n        parameters (IEnumerable<double>): A collection of strictly increasing curve parameters to place perpendicular frames on.\r\n\r\n    Returns:\r\n        Plane[]: An array of perpendicular frames on success or None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/getperpendicularframes-curve_doublearray\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, parameters]\r\n    if multiple: args = zip(thisCurve, parameters)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef GetLength(thisCurve, multiple=False):\r\n    \"\"\"\r\n    Gets the length of the curve with a fractional tolerance of 1.0e-8.\r\n\r\n    Returns:\r\n        double: The length of the curve on success, or zero on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/getlength-curve\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve]\r\n    if multiple: args = [[item] for item in thisCurve]\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef GetLength1(thisCurve, fractionalTolerance, multiple=False):\r\n    \"\"\"\r\n    Get the length of the curve.\r\n\r\n    Args:\r\n        fractionalTolerance (double): Desired fractional precision.\r\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\r\n\r\n    Returns:\r\n        double: The length of the curve on success, or zero on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/getlength-curve_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, fractionalTolerance]\r\n    if multiple: args = zip(thisCurve, fractionalTolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef GetLength2(thisCurve, subdomain, multiple=False):\r\n    \"\"\"\r\n    Get the length of a sub-section of the curve with a fractional tolerance of 1e-8.\r\n\r\n    Args:\r\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).\r\n\r\n    Returns:\r\n        double: The length of the sub-curve on success, or zero on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/getlength-curve_interval\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, subdomain]\r\n    if multiple: args = zip(thisCurve, subdomain)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef GetLength3(thisCurve, fractionalTolerance, subdomain, multiple=False):\r\n    \"\"\"\r\n    Get the length of a sub-section of the curve.\r\n\r\n    Args:\r\n        fractionalTolerance (double): Desired fractional precision.\r\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\r\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).\r\n\r\n    Returns:\r\n        double: The length of the sub-curve on success, or zero on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/getlength-curve_double_interval\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, fractionalTolerance, subdomain]\r\n    if multiple: args = zip(thisCurve, fractionalTolerance, subdomain)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef IsShort(thisCurve, tolerance, multiple=False):\r\n    \"\"\"\r\n    Used to quickly find short curves.\r\n\r\n    Args:\r\n        tolerance (double): Length threshold value for \"shortness\".\r\n\r\n    Returns:\r\n        bool: True if the length of the curve is <= tolerance.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/isshort-curve_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, tolerance]\r\n    if multiple: args = zip(thisCurve, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef IsShort1(thisCurve, tolerance, subdomain, multiple=False):\r\n    \"\"\"\r\n    Used to quickly find short curves.\r\n\r\n    Args:\r\n        tolerance (double): Length threshold value for \"shortness\".\r\n        subdomain (Interval): The test is performed on the interval that is the intersection of sub-domain with Domain()\r\n\r\n    Returns:\r\n        bool: True if the length of the curve is <= tolerance.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/isshort-curve_double_interval\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, tolerance, subdomain]\r\n    if multiple: args = zip(thisCurve, tolerance, subdomain)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef RemoveShortSegments(thisCurve, tolerance, multiple=False):\r\n    \"\"\"\r\n    Looks for segments that are shorter than tolerance that can be removed.\r\n    Does not change the domain, but it will change the relative parameterization.\r\n\r\n    Args:\r\n        tolerance (double): Tolerance which defines \"short\" segments.\r\n\r\n    Returns:\r\n        bool: True if removable short segments were found.\r\n        False if no removable short segments were found.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/removeshortsegments-curve_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, tolerance]\r\n    if multiple: args = zip(thisCurve, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef LengthParameter(thisCurve, segmentLength, multiple=False):\r\n    \"\"\"\r\n    Gets the parameter along the curve which coincides with a given length along the curve.\r\n    A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n    Args:\r\n        segmentLength (double): Length of segment to measure. Must be less than or equal to the length of the curve.\r\n\r\n    Returns:\r\n        bool: True on success, False on failure.\r\n        t (double): Parameter such that the length of the curve from the curve start point to t equals length.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/lengthparameter-curve_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, segmentLength]\r\n    if multiple: args = zip(thisCurve, segmentLength)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef LengthParameter1(thisCurve, segmentLength, fractionalTolerance, multiple=False):\r\n    \"\"\"\r\n    Gets the parameter along the curve which coincides with a given length along the curve.\r\n\r\n    Args:\r\n        segmentLength (double): Length of segment to measure. Must be less than or equal to the length of the curve.\r\n        fractionalTolerance (double): Desired fractional precision.\r\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\r\n\r\n    Returns:\r\n        bool: True on success, False on failure.\r\n        t (double): Parameter such that the length of the curve from the curve start point to t equals s.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/lengthparameter-curve_double_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, segmentLength, fractionalTolerance]\r\n    if multiple: args = zip(thisCurve, segmentLength, fractionalTolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef LengthParameter2(thisCurve, segmentLength, subdomain, multiple=False):\r\n    \"\"\"\r\n    Gets the parameter along the curve which coincides with a given length along the curve.\r\n    A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n    Args:\r\n        segmentLength (double): Length of segment to measure. Must be less than or equal to the length of the sub-domain.\r\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve rather than the whole curve.\r\n\r\n    Returns:\r\n        bool: True on success, False on failure.\r\n        t (double): Parameter such that the length of the curve from the start of the sub-domain to t is s.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/lengthparameter-curve_double_double_interval\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, segmentLength, subdomain]\r\n    if multiple: args = zip(thisCurve, segmentLength, subdomain)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef LengthParameter3(thisCurve, segmentLength, fractionalTolerance, subdomain, multiple=False):\r\n    \"\"\"\r\n    Gets the parameter along the curve which coincides with a given length along the curve.\r\n\r\n    Args:\r\n        segmentLength (double): Length of segment to measure. Must be less than or equal to the length of the sub-domain.\r\n        fractionalTolerance (double): Desired fractional precision.\r\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\r\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve rather than the whole curve.\r\n\r\n    Returns:\r\n        bool: True on success, False on failure.\r\n        t (double): Parameter such that the length of the curve from the start of the sub-domain to t is s.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/lengthparameter-curve_double_double_double_interval\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, segmentLength, fractionalTolerance, subdomain]\r\n    if multiple: args = zip(thisCurve, segmentLength, fractionalTolerance, subdomain)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef NormalizedLengthParameter(thisCurve, s, multiple=False):\r\n    \"\"\"\r\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\r\n    A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n    Args:\r\n        s (double): Normalized arc length parameter.\r\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\r\n\r\n    Returns:\r\n        bool: True on success, False on failure.\r\n        t (double): Parameter such that the length of the curve from its start to t is arc_length.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/normalizedlengthparameter-curve_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, s]\r\n    if multiple: args = zip(thisCurve, s)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef NormalizedLengthParameter1(thisCurve, s, fractionalTolerance, multiple=False):\r\n    \"\"\"\r\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\r\n\r\n    Args:\r\n        s (double): Normalized arc length parameter.\r\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\r\n        fractionalTolerance (double): Desired fractional precision.\r\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\r\n\r\n    Returns:\r\n        bool: True on success, False on failure.\r\n        t (double): Parameter such that the length of the curve from its start to t is arc_length.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/normalizedlengthparameter-curve_double_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, s, fractionalTolerance]\r\n    if multiple: args = zip(thisCurve, s, fractionalTolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef NormalizedLengthParameter2(thisCurve, s, subdomain, multiple=False):\r\n    \"\"\"\r\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\r\n    A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n    Args:\r\n        s (double): Normalized arc length parameter.\r\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\r\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve.\r\n\r\n    Returns:\r\n        bool: True on success, False on failure.\r\n        t (double): Parameter such that the length of the curve from its start to t is arc_length.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/normalizedlengthparameter-curve_double_double_interval\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, s, subdomain]\r\n    if multiple: args = zip(thisCurve, s, subdomain)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef NormalizedLengthParameter3(thisCurve, s, fractionalTolerance, subdomain, multiple=False):\r\n    \"\"\"\r\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\r\n\r\n    Args:\r\n        s (double): Normalized arc length parameter.\r\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\r\n        fractionalTolerance (double): Desired fractional precision.\r\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\r\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve.\r\n\r\n    Returns:\r\n        bool: True on success, False on failure.\r\n        t (double): Parameter such that the length of the curve from its start to t is arc_length.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/normalizedlengthparameter-curve_double_double_double_interval\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, s, fractionalTolerance, subdomain]\r\n    if multiple: args = zip(thisCurve, s, fractionalTolerance, subdomain)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef NormalizedLengthParameters(thisCurve, s, absoluteTolerance, multiple=False):\r\n    \"\"\"\r\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\r\n    A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n    Args:\r\n        s (double[]): Array of normalized arc length parameters.\r\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\r\n        absoluteTolerance (double): If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length\r\n            and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\r\n\r\n    Returns:\r\n        double[]: If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length.\r\n        Null on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/normalizedlengthparameters-curve_doublearray_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, s, absoluteTolerance]\r\n    if multiple: args = zip(thisCurve, s, absoluteTolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef NormalizedLengthParameters1(thisCurve, s, absoluteTolerance, fractionalTolerance, multiple=False):\r\n    \"\"\"\r\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\r\n\r\n    Args:\r\n        s (double[]): Array of normalized arc length parameters.\r\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\r\n        absoluteTolerance (double): If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length\r\n            and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\r\n        fractionalTolerance (double): Desired fractional precision for each segment.\r\n            fabs(\"true\" length - actual length)/(actual length) <= fractionalTolerance.\r\n\r\n    Returns:\r\n        double[]: If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length.\r\n        Null on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/normalizedlengthparameters-curve_doublearray_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, s, absoluteTolerance, fractionalTolerance]\r\n    if multiple: args = zip(thisCurve, s, absoluteTolerance, fractionalTolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef NormalizedLengthParameters2(thisCurve, s, absoluteTolerance, subdomain, multiple=False):\r\n    \"\"\"\r\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\r\n    A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n    Args:\r\n        s (double[]): Array of normalized arc length parameters.\r\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\r\n        absoluteTolerance (double): If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length\r\n            and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\r\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve.\r\n            A 0.0 s value corresponds to sub-domain->Min() and a 1.0 s value corresponds to sub-domain->Max().\r\n\r\n    Returns:\r\n        double[]: If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length.\r\n        Null on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/normalizedlengthparameters-curve_doublearray_double_interval\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, s, absoluteTolerance, subdomain]\r\n    if multiple: args = zip(thisCurve, s, absoluteTolerance, subdomain)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef NormalizedLengthParameters3(thisCurve, s, absoluteTolerance, fractionalTolerance, subdomain, multiple=False):\r\n    \"\"\"\r\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\r\n\r\n    Args:\r\n        s (double[]): Array of normalized arc length parameters.\r\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\r\n        absoluteTolerance (double): If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length\r\n            and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\r\n        fractionalTolerance (double): Desired fractional precision for each segment.\r\n            fabs(\"true\" length - actual length)/(actual length) <= fractionalTolerance.\r\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve.\r\n            A 0.0 s value corresponds to sub-domain->Min() and a 1.0 s value corresponds to sub-domain->Max().\r\n\r\n    Returns:\r\n        double[]: If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length.\r\n        Null on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/normalizedlengthparameters-curve_doublearray_double_double_interval\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, s, absoluteTolerance, fractionalTolerance, subdomain]\r\n    if multiple: args = zip(thisCurve, s, absoluteTolerance, fractionalTolerance, subdomain)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef DivideByCount(thisCurve, segmentCount, includeEnds, multiple=False):\r\n    \"\"\"\r\n    Divide the curve into a number of equal-length segments.\r\n\r\n    Args:\r\n        segmentCount (int): Segment count. Note that the number of division points may differ from the segment count.\r\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\r\n\r\n    Returns:\r\n        double[]: List of curve parameters at the division points on success, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/dividebycount-curve_int_bool\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, segmentCount, includeEnds]\r\n    if multiple: args = zip(thisCurve, segmentCount, includeEnds)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef DivideByCount1(thisCurve, segmentCount, includeEnds, multiple=False):\r\n    \"\"\"\r\n    Divide the curve into a number of equal-length segments.\r\n\r\n    Args:\r\n        segmentCount (int): Segment count. Note that the number of division points may differ from the segment count.\r\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\r\n\r\n    Returns:\r\n        double[]: Array containing division curve parameters on success, None on failure.\r\n        points (Point3d[]): A list of division points. If the function returns successfully, this point-array will be filled in.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/dividebycount-curve_int_bool_point3darray\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, segmentCount, includeEnds]\r\n    if multiple: args = zip(thisCurve, segmentCount, includeEnds)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef DivideByLength(thisCurve, segmentLength, includeEnds, multiple=False):\r\n    \"\"\"\r\n    Divide the curve into specific length segments.\r\n\r\n    Args:\r\n        segmentLength (double): The length of each and every segment (except potentially the last one).\r\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\r\n\r\n    Returns:\r\n        double[]: Array containing division curve parameters if successful, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/dividebylength-curve_double_bool\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, segmentLength, includeEnds]\r\n    if multiple: args = zip(thisCurve, segmentLength, includeEnds)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef DivideByLength1(thisCurve, segmentLength, includeEnds, reverse, multiple=False):\r\n    \"\"\"\r\n    Divide the curve into specific length segments.\r\n\r\n    Args:\r\n        segmentLength (double): The length of each and every segment (except potentially the last one).\r\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\r\n        reverse (bool): If true, then the divisions start from the end of the curve.\r\n\r\n    Returns:\r\n        double[]: Array containing division curve parameters if successful, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/dividebylength-curve_double_bool_bool\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, segmentLength, includeEnds, reverse]\r\n    if multiple: args = zip(thisCurve, segmentLength, includeEnds, reverse)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef DivideByLength2(thisCurve, segmentLength, includeEnds, multiple=False):\r\n    \"\"\"\r\n    Divide the curve into specific length segments.\r\n\r\n    Args:\r\n        segmentLength (double): The length of each and every segment (except potentially the last one).\r\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\r\n\r\n    Returns:\r\n        double[]: Array containing division curve parameters if successful, None on failure.\r\n        points (Point3d[]): If function is successful, points at each parameter value are returned in points.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/dividebylength-curve_double_bool_point3darray\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, segmentLength, includeEnds]\r\n    if multiple: args = zip(thisCurve, segmentLength, includeEnds)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef DivideByLength3(thisCurve, segmentLength, includeEnds, reverse, multiple=False):\r\n    \"\"\"\r\n    Divide the curve into specific length segments.\r\n\r\n    Args:\r\n        segmentLength (double): The length of each and every segment (except potentially the last one).\r\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\r\n        reverse (bool): If true, then the divisions start from the end of the curve.\r\n\r\n    Returns:\r\n        double[]: Array containing division curve parameters if successful, None on failure.\r\n        points (Point3d[]): If function is successful, points at each parameter value are returned in points.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/dividebylength-curve_double_bool_bool_point3darray\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, segmentLength, includeEnds, reverse]\r\n    if multiple: args = zip(thisCurve, segmentLength, includeEnds, reverse)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef DivideEquidistant(thisCurve, distance, multiple=False):\r\n    \"\"\"\r\n    Calculates 3d points on a curve where the linear distance between the points is equal.\r\n\r\n    Args:\r\n        distance (double): The distance between division points.\r\n\r\n    Returns:\r\n        Point3d[]: An array of equidistant points, or None on error.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/divideequidistant-curve_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, distance]\r\n    if multiple: args = zip(thisCurve, distance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToPoint3d(response)\r\n    return response\r\n\r\n\r\ndef DivideAsContour(thisCurve, contourStart, contourEnd, interval, multiple=False):\r\n    \"\"\"\r\n    Divides this curve at fixed steps along a defined contour line.\r\n\r\n    Args:\r\n        contourStart (Point3d): The start of the contouring line.\r\n        contourEnd (Point3d): The end of the contouring line.\r\n        interval (double): A distance to measure on the contouring axis.\r\n\r\n    Returns:\r\n        Point3d[]: An array of points; or None on error.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/divideascontour-curve_point3d_point3d_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, contourStart, contourEnd, interval]\r\n    if multiple: args = zip(thisCurve, contourStart, contourEnd, interval)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToPoint3d(response)\r\n    return response\r\n\r\n\r\ndef Trim(thisCurve, side, length, multiple=False):\r\n    \"\"\"\r\n    Shortens a curve by a given length\r\n\r\n    Returns:\r\n        Curve: Trimmed curve if successful, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/trim-curve_curveend_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, side, length]\r\n    if multiple: args = zip(thisCurve, side, length)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef Split(thisCurve, cutter, tolerance, multiple=False):\r\n    \"\"\"\r\n    Splits a curve into pieces using a polysurface.\r\n\r\n    Args:\r\n        cutter (Brep): A cutting surface or polysurface.\r\n        tolerance (double): A tolerance for computing intersections.\r\n\r\n    Returns:\r\n        Curve[]: An array of curves. This array can be empty.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/split-curve_brep_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, cutter, tolerance]\r\n    if multiple: args = zip(thisCurve, cutter, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef Split1(thisCurve, cutter, tolerance, angleToleranceRadians, multiple=False):\r\n    \"\"\"\r\n    Splits a curve into pieces using a polysurface.\r\n\r\n    Args:\r\n        cutter (Brep): A cutting surface or polysurface.\r\n        tolerance (double): A tolerance for computing intersections.\r\n\r\n    Returns:\r\n        Curve[]: An array of curves. This array can be empty.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/split-curve_brep_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, cutter, tolerance, angleToleranceRadians]\r\n    if multiple: args = zip(thisCurve, cutter, tolerance, angleToleranceRadians)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef Split2(thisCurve, cutter, tolerance, multiple=False):\r\n    \"\"\"\r\n    Splits a curve into pieces using a surface.\r\n\r\n    Args:\r\n        cutter (Surface): A cutting surface or polysurface.\r\n        tolerance (double): A tolerance for computing intersections.\r\n\r\n    Returns:\r\n        Curve[]: An array of curves. This array can be empty.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/split-curve_surface_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, cutter, tolerance]\r\n    if multiple: args = zip(thisCurve, cutter, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef Split3(thisCurve, cutter, tolerance, angleToleranceRadians, multiple=False):\r\n    \"\"\"\r\n    Splits a curve into pieces using a surface.\r\n\r\n    Args:\r\n        cutter (Surface): A cutting surface or polysurface.\r\n        tolerance (double): A tolerance for computing intersections.\r\n\r\n    Returns:\r\n        Curve[]: An array of curves. This array can be empty.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/split-curve_surface_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, cutter, tolerance, angleToleranceRadians]\r\n    if multiple: args = zip(thisCurve, cutter, tolerance, angleToleranceRadians)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef Extend(thisCurve, t0, t1, multiple=False):\r\n    \"\"\"\r\n    Where possible, analytically extends curve to include the given domain.\r\n    This will not work on closed curves. The original curve will be identical to the\r\n    restriction of the resulting curve to the original curve domain.\r\n\r\n    Args:\r\n        t0 (double): Start of extension domain, if the start is not inside the\r\n            Domain of this curve, an attempt will be made to extend the curve.\r\n        t1 (double): End of extension domain, if the end is not inside the\r\n            Domain of this curve, an attempt will be made to extend the curve.\r\n\r\n    Returns:\r\n        Curve: Extended curve on success, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/extend-curve_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, t0, t1]\r\n    if multiple: args = zip(thisCurve, t0, t1)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef Extend1(thisCurve, domain, multiple=False):\r\n    \"\"\"\r\n    Where possible, analytically extends curve to include the given domain.\r\n    This will not work on closed curves. The original curve will be identical to the\r\n    restriction of the resulting curve to the original curve domain.\r\n\r\n    Args:\r\n        domain (Interval): Extension domain.\r\n\r\n    Returns:\r\n        Curve: Extended curve on success, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/extend-curve_interval\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, domain]\r\n    if multiple: args = zip(thisCurve, domain)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef Extend2(thisCurve, side, length, style, multiple=False):\r\n    \"\"\"\r\n    Extends a curve by a specific length.\r\n\r\n    Args:\r\n        side (CurveEnd): Curve end to extend.\r\n        length (double): Length to add to the curve end.\r\n        style (CurveExtensionStyle): Extension style.\r\n\r\n    Returns:\r\n        Curve: A curve with extended ends or None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/extend-curve_curveend_double_curveextensionstyle\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, side, length, style]\r\n    if multiple: args = zip(thisCurve, side, length, style)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef Extend3(thisCurve, side, style, geometry, multiple=False):\r\n    \"\"\"\r\n    Extends a curve until it intersects a collection of objects.\r\n\r\n    Args:\r\n        side (CurveEnd): The end of the curve to extend.\r\n        style (CurveExtensionStyle): The style or type of extension to use.\r\n        geometry (System.Collections.Generic.IEnumerable<GeometryBase>): A collection of objects. Allowable object types are Curve, Surface, Brep.\r\n\r\n    Returns:\r\n        Curve: New extended curve result on success, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/extend-curve_curveend_curveextensionstyle_geometrybasearray\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, side, style, geometry]\r\n    if multiple: args = zip(thisCurve, side, style, geometry)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef Extend4(thisCurve, side, style, endPoint, multiple=False):\r\n    \"\"\"\r\n    Extends a curve to a point.\r\n\r\n    Args:\r\n        side (CurveEnd): The end of the curve to extend.\r\n        style (CurveExtensionStyle): The style or type of extension to use.\r\n        endPoint (Point3d): A new end point.\r\n\r\n    Returns:\r\n        Curve: New extended curve result on success, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/extend-curve_curveend_curveextensionstyle_point3d\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, side, style, endPoint]\r\n    if multiple: args = zip(thisCurve, side, style, endPoint)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef ExtendOnSurface(thisCurve, side, surface, multiple=False):\r\n    \"\"\"\r\n    Extends a curve on a surface.\r\n\r\n    Args:\r\n        side (CurveEnd): The end of the curve to extend.\r\n        surface (Surface): Surface that contains the curve.\r\n\r\n    Returns:\r\n        Curve: New extended curve result on success, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/extendonsurface-curve_curveend_surface\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, side, surface]\r\n    if multiple: args = zip(thisCurve, side, surface)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef ExtendOnSurface1(thisCurve, side, face, multiple=False):\r\n    \"\"\"\r\n    Extends a curve on a surface.\r\n\r\n    Args:\r\n        side (CurveEnd): The end of the curve to extend.\r\n        face (BrepFace): BrepFace that contains the curve.\r\n\r\n    Returns:\r\n        Curve: New extended curve result on success, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/extendonsurface-curve_curveend_brepface\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, side, face]\r\n    if multiple: args = zip(thisCurve, side, face)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef ExtendByLine(thisCurve, side, geometry, multiple=False):\r\n    \"\"\"\r\n    Extends a curve by a line until it intersects a collection of objects.\r\n\r\n    Args:\r\n        side (CurveEnd): The end of the curve to extend.\r\n        geometry (System.Collections.Generic.IEnumerable<GeometryBase>): A collection of objects. Allowable object types are Curve, Surface, Brep.\r\n\r\n    Returns:\r\n        Curve: New extended curve result on success, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/extendbyline-curve_curveend_geometrybasearray\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, side, geometry]\r\n    if multiple: args = zip(thisCurve, side, geometry)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef ExtendByArc(thisCurve, side, geometry, multiple=False):\r\n    \"\"\"\r\n    Extends a curve by an Arc until it intersects a collection of objects.\r\n\r\n    Args:\r\n        side (CurveEnd): The end of the curve to extend.\r\n        geometry (System.Collections.Generic.IEnumerable<GeometryBase>): A collection of objects. Allowable object types are Curve, Surface, Brep.\r\n\r\n    Returns:\r\n        Curve: New extended curve result on success, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/extendbyarc-curve_curveend_geometrybasearray\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, side, geometry]\r\n    if multiple: args = zip(thisCurve, side, geometry)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef Simplify(thisCurve, options, distanceTolerance, angleToleranceRadians, multiple=False):\r\n    \"\"\"\r\n    Returns a geometrically equivalent PolyCurve.\r\n    The PolyCurve has the following properties\r\n    1. All the PolyCurve segments are LineCurve, PolylineCurve, ArcCurve, or NurbsCurve.\r\n    \r\n    2. The NURBS Curves segments do not have fully multiple interior knots.\r\n    \r\n    3. Rational NURBS curves do not have constant weights.\r\n    \r\n    4. Any segment for which IsLinear() or IsArc() is True is a Line,\r\n    Polyline segment, or an Arc.\r\n    \r\n    5. Adjacent co-linear or co-circular segments are combined.\r\n    \r\n    6. Segments that meet with G1-continuity have there ends tuned up so\r\n    that they meet with G1-continuity to within machine precision.\r\n\r\n    Args:\r\n        options (CurveSimplifyOptions): Simplification options.\r\n        distanceTolerance (double): A distance tolerance for the simplification.\r\n        angleToleranceRadians (double): An angle tolerance for the simplification.\r\n\r\n    Returns:\r\n        Curve: New simplified curve on success, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/simplify-curve_curvesimplifyoptions_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, options, distanceTolerance, angleToleranceRadians]\r\n    if multiple: args = zip(thisCurve, options, distanceTolerance, angleToleranceRadians)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef SimplifyEnd(thisCurve, end, options, distanceTolerance, angleToleranceRadians, multiple=False):\r\n    \"\"\"\r\n    Same as SimplifyCurve, but simplifies only the last two segments at \"side\" end.\r\n\r\n    Args:\r\n        end (CurveEnd): If CurveEnd.Start the function simplifies the last two start\r\n            side segments, otherwise if CurveEnd.End the last two end side segments are simplified.\r\n        options (CurveSimplifyOptions): Simplification options.\r\n        distanceTolerance (double): A distance tolerance for the simplification.\r\n        angleToleranceRadians (double): An angle tolerance for the simplification.\r\n\r\n    Returns:\r\n        Curve: New simplified curve on success, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/simplifyend-curve_curveend_curvesimplifyoptions_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, end, options, distanceTolerance, angleToleranceRadians]\r\n    if multiple: args = zip(thisCurve, end, options, distanceTolerance, angleToleranceRadians)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef Fair(thisCurve, distanceTolerance, angleTolerance, clampStart, clampEnd, iterations, multiple=False):\r\n    \"\"\"\r\n    Fairs a curve object. Fair works best on degree 3 (cubic) curves. Attempts to\r\n    remove large curvature variations while limiting the geometry changes to be no\r\n    more than the specified tolerance.\r\n\r\n    Args:\r\n        distanceTolerance (double): Maximum allowed distance the faired curve is allowed to deviate from the input.\r\n        angleTolerance (double): (in radians) kinks with angles <= angleTolerance are smoothed out 0.05 is a good default.\r\n        clampStart (int): The number of (control vertices-1) to preserve at start.\r\n            0 = preserve start point1 = preserve start point and 1st derivative2 = preserve start point, 1st and 2nd derivative\r\n        clampEnd (int): Same as clampStart.\r\n        iterations (int): The number of iterations to use in adjusting the curve.\r\n\r\n    Returns:\r\n        Curve: Returns new faired Curve on success, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/fair-curve_double_double_int_int_int\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, distanceTolerance, angleTolerance, clampStart, clampEnd, iterations]\r\n    if multiple: args = zip(thisCurve, distanceTolerance, angleTolerance, clampStart, clampEnd, iterations)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef Fit(thisCurve, degree, fitTolerance, angleTolerance, multiple=False):\r\n    \"\"\"\r\n    Fits a new curve through an existing curve.\r\n\r\n    Args:\r\n        degree (int): The degree of the returned Curve. Must be bigger than 1.\r\n        fitTolerance (double): The fitting tolerance. If fitTolerance is RhinoMath.UnsetValue or <=0.0,\r\n            the document absolute tolerance is used.\r\n        angleTolerance (double): The kink smoothing tolerance in radians.\r\n            If angleTolerance is 0.0, all kinks are smoothedIf angleTolerance is >0.0, kinks smaller than angleTolerance are smoothedIf angleTolerance is RhinoMath.UnsetValue or <0.0, the document angle tolerance is used for the kink smoothing\r\n\r\n    Returns:\r\n        Curve: Returns a new fitted Curve if successful, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/fit-curve_int_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, degree, fitTolerance, angleTolerance]\r\n    if multiple: args = zip(thisCurve, degree, fitTolerance, angleTolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef Rebuild(thisCurve, pointCount, degree, preserveTangents, multiple=False):\r\n    \"\"\"\r\n    Rebuild a curve with a specific point count.\r\n\r\n    Args:\r\n        pointCount (int): Number of control points in the rebuild curve.\r\n        degree (int): Degree of curve. Valid values are between and including 1 and 11.\r\n        preserveTangents (bool): If true, the end tangents of the input curve will be preserved.\r\n\r\n    Returns:\r\n        NurbsCurve: A NURBS curve on success or None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/rebuild-curve_int_int_bool\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, pointCount, degree, preserveTangents]\r\n    if multiple: args = zip(thisCurve, pointCount, degree, preserveTangents)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef ToPolyline(thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint, multiple=False):\r\n    \"\"\"\r\n    Gets a polyline approximation of a curve.\r\n\r\n    Args:\r\n        mainSegmentCount (int): If mainSegmentCount <= 0, then both subSegmentCount and mainSegmentCount are ignored.\r\n            If mainSegmentCount > 0, then subSegmentCount must be >= 1. In this\r\n            case the NURBS will be broken into mainSegmentCount equally spaced\r\n            chords. If needed, each of these chords can be split into as many\r\n            subSegmentCount sub-parts if the subdivision is necessary for the\r\n            mesh to meet the other meshing constraints. In particular, if\r\n            subSegmentCount = 0, then the curve is broken into mainSegmentCount\r\n            pieces and no further testing is performed.\r\n        subSegmentCount (int): An amount of subsegments.\r\n        maxAngleRadians (double): ( 0 to pi ) Maximum angle (in radians) between unit tangents at\r\n            adjacent vertices.\r\n        maxChordLengthRatio (double): Maximum permitted value of\r\n            (distance chord midpoint to curve) / (length of chord).\r\n        maxAspectRatio (double): If maxAspectRatio < 1.0, the parameter is ignored.\r\n            If 1 <= maxAspectRatio < sqrt(2), it is treated as if maxAspectRatio = sqrt(2).\r\n            This parameter controls the maximum permitted value of\r\n            (length of longest chord) / (length of shortest chord).\r\n        tolerance (double): If tolerance = 0, the parameter is ignored.\r\n            This parameter controls the maximum permitted value of the\r\n            distance from the curve to the polyline.\r\n        minEdgeLength (double): The minimum permitted edge length.\r\n        maxEdgeLength (double): If maxEdgeLength = 0, the parameter\r\n            is ignored. This parameter controls the maximum permitted edge length.\r\n        keepStartPoint (bool): If True the starting point of the curve\r\n            is added to the polyline. If False the starting point of the curve is\r\n            not added to the polyline.\r\n\r\n    Returns:\r\n        PolylineCurve: PolylineCurve on success, None on error.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/topolyline-curve_int_int_double_double_double_double_double_double_bool\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint]\r\n    if multiple: args = zip(thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef ToPolyline1(thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint, curveDomain, multiple=False):\r\n    \"\"\"\r\n    Gets a polyline approximation of a curve.\r\n\r\n    Args:\r\n        mainSegmentCount (int): If mainSegmentCount <= 0, then both subSegmentCount and mainSegmentCount are ignored.\r\n            If mainSegmentCount > 0, then subSegmentCount must be >= 1. In this\r\n            case the NURBS will be broken into mainSegmentCount equally spaced\r\n            chords. If needed, each of these chords can be split into as many\r\n            subSegmentCount sub-parts if the subdivision is necessary for the\r\n            mesh to meet the other meshing constraints. In particular, if\r\n            subSegmentCount = 0, then the curve is broken into mainSegmentCount\r\n            pieces and no further testing is performed.\r\n        subSegmentCount (int): An amount of subsegments.\r\n        maxAngleRadians (double): ( 0 to pi ) Maximum angle (in radians) between unit tangents at\r\n            adjacent vertices.\r\n        maxChordLengthRatio (double): Maximum permitted value of\r\n            (distance chord midpoint to curve) / (length of chord).\r\n        maxAspectRatio (double): If maxAspectRatio < 1.0, the parameter is ignored.\r\n            If 1 <= maxAspectRatio < sqrt(2), it is treated as if maxAspectRatio = sqrt(2).\r\n            This parameter controls the maximum permitted value of\r\n            (length of longest chord) / (length of shortest chord).\r\n        tolerance (double): If tolerance = 0, the parameter is ignored.\r\n            This parameter controls the maximum permitted value of the\r\n            distance from the curve to the polyline.\r\n        minEdgeLength (double): The minimum permitted edge length.\r\n        maxEdgeLength (double): If maxEdgeLength = 0, the parameter\r\n            is ignored. This parameter controls the maximum permitted edge length.\r\n        keepStartPoint (bool): If True the starting point of the curve\r\n            is added to the polyline. If False the starting point of the curve is\r\n            not added to the polyline.\r\n        curveDomain (Interval): This sub-domain of the NURBS curve is approximated.\r\n\r\n    Returns:\r\n        PolylineCurve: PolylineCurve on success, None on error.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/topolyline-curve_int_int_double_double_double_double_double_double_bool_interval\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint, curveDomain]\r\n    if multiple: args = zip(thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint, curveDomain)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef ToPolyline2(thisCurve, tolerance, angleTolerance, minimumLength, maximumLength, multiple=False):\r\n    \"\"\"\r\n    Gets a polyline approximation of a curve.\r\n\r\n    Args:\r\n        tolerance (double): The tolerance. This is the maximum deviation from line midpoints to the curve. When in doubt, use the document's model space absolute tolerance.\r\n        angleTolerance (double): The angle tolerance in radians. This is the maximum deviation of the line directions. When in doubt, use the document's model space angle tolerance.\r\n        minimumLength (double): The minimum segment length.\r\n        maximumLength (double): The maximum segment length.\r\n\r\n    Returns:\r\n        PolylineCurve: PolyCurve on success, None on error.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/topolyline-curve_double_double_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, tolerance, angleTolerance, minimumLength, maximumLength]\r\n    if multiple: args = zip(thisCurve, tolerance, angleTolerance, minimumLength, maximumLength)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef ToArcsAndLines(thisCurve, tolerance, angleTolerance, minimumLength, maximumLength, multiple=False):\r\n    \"\"\"\r\n    Converts a curve into polycurve consisting of arc segments. Sections of the input curves that are nearly straight are converted to straight-line segments.\r\n\r\n    Args:\r\n        tolerance (double): The tolerance. This is the maximum deviation from arc midpoints to the curve. When in doubt, use the document's model space absolute tolerance.\r\n        angleTolerance (double): The angle tolerance in radians. This is the maximum deviation of the arc end directions from the curve direction. When in doubt, use the document's model space angle tolerance.\r\n        minimumLength (double): The minimum segment length.\r\n        maximumLength (double): The maximum segment length.\r\n\r\n    Returns:\r\n        PolyCurve: PolyCurve on success, None on error.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/toarcsandlines-curve_double_double_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, tolerance, angleTolerance, minimumLength, maximumLength]\r\n    if multiple: args = zip(thisCurve, tolerance, angleTolerance, minimumLength, maximumLength)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef PullToMesh(thisCurve, mesh, tolerance, multiple=False):\r\n    \"\"\"\r\n    Makes a polyline approximation of the curve and gets the closest point on the mesh for each point on the curve.\r\n    Then it \"connects the points\" so that you have a polyline on the mesh.\r\n\r\n    Args:\r\n        mesh (Mesh): Mesh to project onto.\r\n        tolerance (double): Input tolerance (RhinoDoc.ModelAbsoluteTolerance is a good default)\r\n\r\n    Returns:\r\n        PolylineCurve: A polyline curve on success, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/pulltomesh-curve_mesh_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, mesh, tolerance]\r\n    if multiple: args = zip(thisCurve, mesh, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    return response\r\n\r\n\r\ndef Offset(thisCurve, plane, distance, tolerance, cornerStyle, multiple=False):\r\n    \"\"\"\r\n    Offsets this curve. If you have a nice offset, then there will be one entry in\r\n    the array. If the original curve had kinks or the offset curve had self\r\n    intersections, you will get multiple segments in the output array.\r\n\r\n    Args:\r\n        plane (Plane): Offset solution plane.\r\n        distance (double): The positive or negative distance to offset.\r\n        tolerance (double): The offset or fitting tolerance.\r\n        cornerStyle (CurveOffsetCornerStyle): Corner style for offset kinks.\r\n\r\n    Returns:\r\n        Curve[]: Offset curves on success, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/offset-curve_plane_double_double_curveoffsetcornerstyle\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, plane, distance, tolerance, cornerStyle]\r\n    if multiple: args = zip(thisCurve, plane, distance, tolerance, cornerStyle)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef Offset1(thisCurve, directionPoint, normal, distance, tolerance, cornerStyle, multiple=False):\r\n    \"\"\"\r\n    Offsets this curve. If you have a nice offset, then there will be one entry in\r\n    the array. If the original curve had kinks or the offset curve had self\r\n    intersections, you will get multiple segments in the output array.\r\n\r\n    Args:\r\n        directionPoint (Point3d): A point that indicates the direction of the offset.\r\n        normal (Vector3d): The normal to the offset plane.\r\n        distance (double): The positive or negative distance to offset.\r\n        tolerance (double): The offset or fitting tolerance.\r\n        cornerStyle (CurveOffsetCornerStyle): Corner style for offset kinks.\r\n\r\n    Returns:\r\n        Curve[]: Offset curves on success, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/offset-curve_point3d_vector3d_double_double_curveoffsetcornerstyle\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, directionPoint, normal, distance, tolerance, cornerStyle]\r\n    if multiple: args = zip(thisCurve, directionPoint, normal, distance, tolerance, cornerStyle)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef Offset2(thisCurve, directionPoint, normal, distance, tolerance, angleTolerance, loose, cornerStyle, endStyle, multiple=False):\r\n    \"\"\"\r\n    Offsets this curve. If you have a nice offset, then there will be one entry in\r\n    the array. If the original curve had kinks or the offset curve had self\r\n    intersections, you will get multiple segments in the output array.\r\n\r\n    Args:\r\n        directionPoint (Point3d): A point that indicates the direction of the offset.\r\n        normal (Vector3d): The normal to the offset plane.\r\n        distance (double): The positive or negative distance to offset.\r\n        tolerance (double): The offset or fitting tolerance.\r\n        angleTolerance (double): The angle tolerance, in radians, used to decide whether to split at kinks.\r\n        loose (bool): If false, offset within tolerance. If true, offset by moving edit points.\r\n        cornerStyle (CurveOffsetCornerStyle): Corner style for offset kinks.\r\n        endStyle (CurveOffsetEndStyle): End style for non-loose, non-closed curve offsets.\r\n\r\n    Returns:\r\n        Curve[]: Offset curves on success, None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/offset-curve_point3d_vector3d_double_double_double_bool_curveoffsetcornerstyle_curveoffsetendstyle\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, directionPoint, normal, distance, tolerance, angleTolerance, loose, cornerStyle, endStyle]\r\n    if multiple: args = zip(thisCurve, directionPoint, normal, distance, tolerance, angleTolerance, loose, cornerStyle, endStyle)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef RibbonOffset(thisCurve, distance, blendRadius, directionPoint, normal, tolerance, multiple=False):\r\n    \"\"\"\r\n    Offsets a closed curve in the following way: pProject the curve to a plane with given normal.\r\n    Then, loose Offset the projection by distance + blend_radius and trim off self-intersection.\r\n    THen, Offset the remaining curve back in the opposite direction by blend_radius, filling gaps with blends.\r\n    Finally, use the elevations of the input curve to get the correct elevations of the result.\r\n\r\n    Args:\r\n        distance (double): The positive distance to offset the curve.\r\n        blendRadius (double): Positive, typically the same as distance. When the offset results in a self-intersection\r\n            that gets trimmed off at a kink, the kink will be blended out using this radius.\r\n        directionPoint (Point3d): A point that indicates the direction of the offset. If the offset is inward,\r\n            the point's projection to the plane should be well within the curve.\r\n            It will be used to decide which part of the offset to keep if there are self-intersections.\r\n        normal (Vector3d): A vector that indicates the normal of the plane in which the offset will occur.\r\n        tolerance (double): Used to determine self-intersections, not offset error.\r\n\r\n    Returns:\r\n        Curve: The offset curve if successful.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/ribbonoffset-curve_double_double_point3d_vector3d_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, distance, blendRadius, directionPoint, normal, tolerance]\r\n    if multiple: args = zip(thisCurve, distance, blendRadius, directionPoint, normal, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef OffsetOnSurface(thisCurve, face, distance, fittingTolerance, multiple=False):\r\n    \"\"\"\r\n    Offset this curve on a brep face surface. This curve must lie on the surface.\r\n\r\n    Args:\r\n        face (BrepFace): The brep face on which to offset.\r\n        distance (double): A distance to offset (+)left, (-)right.\r\n        fittingTolerance (double): A fitting tolerance.\r\n\r\n    Returns:\r\n        Curve[]: Offset curves on success, or None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/offsetonsurface-curve_brepface_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, face, distance, fittingTolerance]\r\n    if multiple: args = zip(thisCurve, face, distance, fittingTolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef OffsetOnSurface1(thisCurve, face, throughPoint, fittingTolerance, multiple=False):\r\n    \"\"\"\r\n    Offset a curve on a brep face surface. This curve must lie on the surface.\r\n    This overload allows to specify a surface point at which the offset will pass.\r\n\r\n    Args:\r\n        face (BrepFace): The brep face on which to offset.\r\n        throughPoint (Point2d): 2d point on the brep face to offset through.\r\n        fittingTolerance (double): A fitting tolerance.\r\n\r\n    Returns:\r\n        Curve[]: Offset curves on success, or None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/offsetonsurface-curve_brepface_point2d_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, face, throughPoint, fittingTolerance]\r\n    if multiple: args = zip(thisCurve, face, throughPoint, fittingTolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef OffsetOnSurface2(thisCurve, face, curveParameters, offsetDistances, fittingTolerance, multiple=False):\r\n    \"\"\"\r\n    Offset a curve on a brep face surface. This curve must lie on the surface.\r\n    This overload allows to specify different offsets for different curve parameters.\r\n\r\n    Args:\r\n        face (BrepFace): The brep face on which to offset.\r\n        curveParameters (double[]): Curve parameters corresponding to the offset distances.\r\n        offsetDistances (double[]): distances to offset (+)left, (-)right.\r\n        fittingTolerance (double): A fitting tolerance.\r\n\r\n    Returns:\r\n        Curve[]: Offset curves on success, or None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/offsetonsurface-curve_brepface_doublearray_doublearray_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, face, curveParameters, offsetDistances, fittingTolerance]\r\n    if multiple: args = zip(thisCurve, face, curveParameters, offsetDistances, fittingTolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef OffsetOnSurface3(thisCurve, surface, distance, fittingTolerance, multiple=False):\r\n    \"\"\"\r\n    Offset a curve on a surface. This curve must lie on the surface.\r\n\r\n    Args:\r\n        surface (Surface): A surface on which to offset.\r\n        distance (double): A distance to offset (+)left, (-)right.\r\n        fittingTolerance (double): A fitting tolerance.\r\n\r\n    Returns:\r\n        Curve[]: Offset curves on success, or None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/offsetonsurface-curve_surface_double_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, surface, distance, fittingTolerance]\r\n    if multiple: args = zip(thisCurve, surface, distance, fittingTolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef OffsetOnSurface4(thisCurve, surface, throughPoint, fittingTolerance, multiple=False):\r\n    \"\"\"\r\n    Offset a curve on a surface. This curve must lie on the surface.\r\n    This overload allows to specify a surface point at which the offset will pass.\r\n\r\n    Args:\r\n        surface (Surface): A surface on which to offset.\r\n        throughPoint (Point2d): 2d point on the brep face to offset through.\r\n        fittingTolerance (double): A fitting tolerance.\r\n\r\n    Returns:\r\n        Curve[]: Offset curves on success, or None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/offsetonsurface-curve_surface_point2d_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, surface, throughPoint, fittingTolerance]\r\n    if multiple: args = zip(thisCurve, surface, throughPoint, fittingTolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef OffsetOnSurface5(thisCurve, surface, curveParameters, offsetDistances, fittingTolerance, multiple=False):\r\n    \"\"\"\r\n    Offset this curve on a surface. This curve must lie on the surface.\r\n    This overload allows to specify different offsets for different curve parameters.\r\n\r\n    Args:\r\n        surface (Surface): A surface on which to offset.\r\n        curveParameters (double[]): Curve parameters corresponding to the offset distances.\r\n        offsetDistances (double[]): Distances to offset (+)left, (-)right.\r\n        fittingTolerance (double): A fitting tolerance.\r\n\r\n    Returns:\r\n        Curve[]: Offset curves on success, or None on failure.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/offsetonsurface-curve_surface_doublearray_doublearray_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, surface, curveParameters, offsetDistances, fittingTolerance]\r\n    if multiple: args = zip(thisCurve, surface, curveParameters, offsetDistances, fittingTolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef PullToBrepFace1(thisCurve, face, tolerance, multiple=False):\r\n    \"\"\"\r\n    Pulls this curve to a brep face and returns the result of that operation.\r\n\r\n    Args:\r\n        face (BrepFace): A brep face.\r\n        tolerance (double): A tolerance value.\r\n\r\n    Returns:\r\n        Curve[]: An array containing the resulting curves after pulling. This array could be empty.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/pulltobrepface-curve_brepface_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, face, tolerance]\r\n    if multiple: args = zip(thisCurve, face, tolerance)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n\r\ndef OffsetNormalToSurface(thisCurve, surface, height, multiple=False):\r\n    \"\"\"\r\n    Finds a curve by offsetting an existing curve normal to a surface.\r\n    The caller is responsible for ensuring that the curve lies on the input surface.\r\n\r\n    Args:\r\n        surface (Surface): Surface from which normals are calculated.\r\n        height (double): offset distance (distance from surface to result curve)\r\n\r\n    Returns:\r\n        Curve: Offset curve at distance height from the surface.  The offset curve is\r\n        interpolated through a small number of points so if the surface is irregular\r\n        or complicated, the result will not be a very accurate offset.\r\n    \"\"\"\r\n    url = \"rhino/geometry/curve/offsetnormaltosurface-curve_surface_double\"\r\n    if multiple: url += \"?multiple=true\"\r\n    args = [thisCurve, surface, height]\r\n    if multiple: args = zip(thisCurve, surface, height)\r\n    response = Util.ComputeFetch(url, args)\r\n    response = Util.DecodeToCommonObject(response)\r\n    return response\r\n\r\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "point", "brep", "line", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "Exponent-Labs_exponent-compute-rhino3d_a821886856.json", "repo": "Exponent-Labs/exponent-compute-rhino3d"}
{"instruction": "Evaluate a python script on the compute server. The script can reference an", "code": "import rhino3dm\r\nimport json\r\nimport requests\r\n\r\n__version__ = '0.12.1'\r\n\r\nurl = 'https://compute.rhino3d.com/'\r\nauthToken = ''\r\napiKey = ''\r\nstopat = 0\r\n\r\n\r\ndef ComputeFetch(endpoint, arglist):\r\n    class __Rhino3dmEncoder(json.JSONEncoder):\r\n        def default(self, o):\r\n            if hasattr(o, \"Encode\"):\r\n                return o.Encode()\r\n            return json.JSONEncoder.default(self, o)\r\n    global authToken\r\n    global apiKey\r\n    global url\r\n    global stopat\r\n    posturl = url + endpoint\r\n    if(stopat>0):\r\n        if(posturl.find('?')>0): posturl += '&stopat='\r\n        else: posturl += '?stopat='\r\n        posturl += str(stopat)\r\n    postdata = json.dumps(arglist, cls=__Rhino3dmEncoder)\r\n    headers = { 'User-Agent': 'compute.rhino3d.py/' + __version__ }\r\n    if authToken:\r\n        headers['Authorization'] = 'Bearer ' + authToken\r\n    if apiKey:\r\n        headers['RhinoComputeKey'] = apiKey\r\n    r = requests.post(posturl, data=postdata, headers=headers)\r\n    return r.json()\r\n\r\n\r\ndef PythonEvaluate(script, inputs, output_names):\r\n    \"\"\"\r\n    Evaluate a python script on the compute server. The script can reference an\r\n    `input` parameter which is passed as a dictionary. The script also has\r\n    access to an 'output' parameter which is returned from the server.\r\n\r\n    Args:\r\n        script (str): the python script to evaluate\r\n        inputs (dict): dictionary of data passed to the server for use by the\r\n                       script as an input variable\r\n        output_names (list): list of strings defining which variables in the\r\n                       script to return\r\n    Returns:\r\n        dict: The script has access to an output dict variable that it can\r\n              fill with values. This information is returned from the server\r\n              to the client.\r\n    \"\"\"\r\n    encodedInput = rhino3dm.ArchivableDictionary.EncodeDict(inputs)\r\n    url = 'rhino/python/evaluate'\r\n    args = [script, json.dumps(encodedInput), output_names]\r\n    response = ComputeFetch(url, args)\r\n    output = rhino3dm.ArchivableDictionary.DecodeDict(json.loads(response))\r\n    return output\r\n\r\n\r\ndef DecodeToCommonObject(item):\r\n    if item is None:\r\n        return None\r\n    if isinstance(item, list):\r\n        return [DecodeToCommonObject(x) for x in item]\r\n    return rhino3dm.CommonObject.Decode(item)\r\n\r\n\r\ndef DecodeToPoint3d(item):\r\n    if item is None:\r\n        return None\r\n    if isinstance(item, list):\r\n        return [DecodeToPoint3d(x) for x in item]\r\n    return rhino3dm.Point3d(item['X'], item['Y'], item['Z'])\r\n\r\n\r\ndef DecodeToVector3d(item):\r\n    if item is None:\r\n        return None\r\n    if isinstance(item, list):\r\n        return [DecodeToVector3d(x) for x in item]\r\n    return rhino3dm.Vector3d(item['X'], item['Y'], item['Z'])\r\n\r\n\r\ndef DecodeToLine(item):\r\n    if item is None:\r\n        return None\r\n    if isinstance(item, list):\r\n        return [DecodeToLine(x) for x in item]\r\n    start = DecodeToPoint3d(item['From'])\r\n    end = DecodeToPoint3d(item['To'])\r\n    return rhino3dm.Line(start,end)\r\n\r\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["line", "classes", "functions", "point"], "original_file": "Exponent-Labs_exponent-compute-rhino3d_df9bdad08a.json", "repo": "Exponent-Labs/exponent-compute-rhino3d"}
{"instruction": "workshop_instuctions_param =rebar.get_Parameter(BuiltInParameter.REBAR_WORKSHOP_INSTRUCTIONS)", "code": "# -*- coding: utf-8 -*-\nimport clr\nclr.AddReference(\"RhinoInside.Revit\")\nclr.AddReference('System.Core')\nclr.AddReference('RevitAPI') \nclr.AddReference('RevitAPIUI')\nimport System\nimport ghpythonlib.treehelpers as th\nimport Autodesk\nfrom System.Collections.Generic import List, IList\nfrom .rebarShape import RebarShapeCurve\nfrom .data_processor import find_row_by_name\nfrom utils.utils import update_params_from_dict_list, dictionary_from_csv\nfrom utils.revit_utils import get_active_doc, get_active_ui_doc\nfrom utils.rhinoinside_utils import convert_rhino_to_revit_geometry, convert_rhino_to_revit_length, convert_revit_to_rhino_length\nfrom Autodesk.Revit.DB import FilteredElementCollector, BuiltInCategory,Transaction, TransactionGroup,BuiltInParameter, IFailuresPreprocessor, FailureProcessingResult, BuiltInFailures, ElementId,Element,ElementType,Curve\nfrom Autodesk.Revit.DB.Structure import RebarStyle, RebarFreeFormValidationResult,Rebar, RebarBarType, RebarShape, RebarHookType,RebarReinforcementData, RebarCoupler,RebarCouplerError,RebarHookOrientation,RebarConstraintsManager\n\nimport math\n\nclass MyPreProcessor(IFailuresPreprocessor):\n    def PreprocessFailures(self, failuresAccessor):\n        transactionName = failuresAccessor.GetTransactionName()\n        failMessages = failuresAccessor.GetFailureMessages()\n        \n        if failMessages.Count == 0:\n            return FailureProcessingResult.Continue\n\n        for currentMessage in failMessages:\n            failID = currentMessage.GetFailureDefinitionId()\n            if failID == BuiltInFailures.OverlapFailures.DuplicateRebar:\n                failuresAccessor.DeleteWarning(currentMessage)\n        \n        return FailureProcessingResult.Continue\n\ndef get_hook_orientation(hook_orientation):\n    if hook_orientation == 'left' or hook_orientation == 'Left':\n        return RebarHookOrientation.Left\n    elif hook_orientation == 'right' or hook_orientation == 'Right':\n        return RebarHookOrientation.Right\n    else:\n        return None\n    \ndef get_hook_orientation_from_shapename(shapename):\n    data = find_row_by_name(shapename)\n    start_hook_orientation =get_hook_orientation(data[0]['HookOrientation0']) \n    end_hook_orientation =  get_hook_orientation(data[0]['HookOrientation1']) \n\n    return [start_hook_orientation, end_hook_orientation]\n    \ndef get_rebar_type_by_diameter(rh_diameter):\n    doc = get_active_doc()\n    rebar_types = FilteredElementCollector(doc).OfClass(RebarBarType).ToElements()\n    for rebar_type in rebar_types:\n        rv_diameter = convert_rhino_to_revit_length(rh_diameter)\n        if abs(rebar_type.BarModelDiameter - rv_diameter) < 0.00001:\n            return rebar_type\n    return None\n\ndef get_rebar_shape_by_name(name):\n    doc = get_active_doc()\n    rebar_shapes = [rebarShape for rebarShape in FilteredElementCollector(doc).OfClass(RebarShape).ToElements() if rebarShape.get_Parameter(BuiltInParameter.ALL_MODEL_TYPE_NAME).AsString() == name]\n    if len(rebar_shapes) > 0:\n        return rebar_shapes[0]\n    return None\n\ndef get_rebar_style_by_name(name):\n    rebar_shape = get_rebar_shape_by_name(name)\n    if rebar_shape != None:\n        print(rebar_shape.RebarStyle)\n        return rebar_shape.RebarStyle\n\ndef get_hook_type_by_angle(angle, style):\n    doc = get_active_doc()\n    rebar_hook_type = [rebarHook for rebarHook in FilteredElementCollector(doc).OfClass(RebarHookType).ToElements() if abs(rebarHook.HookAngle -angle) < 0.01 ]\n    if len(rebar_hook_type) > 0:\n        for hook in rebar_hook_type:\n            if hook.Style == style:\n                return hook\n    return None\n\ndef get_hook_type_from_shapename(shapename):\n    data = find_row_by_name(shapename)\n    style = get_rebar_style_by_name(shapename)\n    start_hook_type =get_hook_type_by_angle(float(data[0]['Hook At Start'] )* math.pi/180, style) \n    end_hook_type =  get_hook_type_by_angle(float(data[0]['Hook At End']) * math.pi/180, style) \n\n    return [start_hook_type, end_hook_type,style]\n\ndef get_default_coupler_type(doc, rebar, coupler_family_name):\n    \n    rebar_diameter = Element.Name.GetValue(doc.GetElement(rebar.GetTypeId())).replace('D',\"\")\n    coupler_types = [coupler_type for coupler_type in FilteredElementCollector(doc).OfClass(ElementType).OfCategory(BuiltInCategory.OST_Coupler).ToElements() if (coupler_family_name + rebar_diameter) in Element.Name.GetValue(coupler_type) ] \n    if len(coupler_types) > 0:\n        return coupler_types[0]\n        \n    return None\n\ndef create_rebar_from_shape(host, diameter, shape,origin, xVec, yVec):\n    doc = get_active_doc()\n    rv_shape = get_rebar_shape_by_name(shape)\n    rv_origin = convert_rhino_to_revit_geometry(origin)\n    rv_xVec = convert_rhino_to_revit_geometry(xVec)\n    rv_yVec = convert_rhino_to_revit_geometry(yVec)\n    rv_type = get_rebar_type_by_diameter(diameter)\n\n    rebar = Rebar.CreateFromRebarShape(doc, rv_shape, rv_type, host, rv_origin, rv_xVec, rv_yVec)\n    return rebar\n\ndef scaleToBox_rebar(rebar, origin, xVec, yVec):\n    doc = get_active_doc()\n    rv_origin = convert_rhino_to_revit_geometry(origin)\n    rv_xVec = convert_rhino_to_revit_geometry(xVec)\n    rv_yVec = convert_rhino_to_revit_geometry(yVec)\n    rebar_diameter = rebar.get_Parameter(BuiltInParameter.REBAR_BAR_DIAMETER).AsDouble()\n    accessor = rebar.GetShapeDrivenAccessor()\n    if rebar.GetHookRotationAngle(1)>0:\n        accessor.ScaleToBox(rv_origin - rebar_diameter*rv_xVec.Normalize()*0.5, rv_xVec +  rebar_diameter*rv_xVec.Normalize(), rv_yVec)\n    else:\n        accessor.ScaleToBox(rv_origin - rebar_diameter*rv_xVec.Normalize()*0.5, rv_xVec +  rebar_diameter*rv_xVec.Normalize()*0.5, rv_yVec)\n    return rebar\n\n\n\n\n\ndef get_rebars_in_doc(doc):\n    return FilteredElementCollector(doc).OfClass(Rebar).ToElements()\n\ndef get_rebar_in_host(doc,host):\n    return FilteredElementCollector(doc,host.Id).OfClass(Rebar).ToElements()\n\ndef get_rebar_by_mark(doc,mark):\n    return FilteredElementCollector(doc).OfClass(Rebar).WhereElementIsNotElementType().Where(lambda r:r.get_Parameter(BuiltInParameter.ALL_MODEL_MARK).AsString() == mark).ToElements()\n\ndef get_rebar_in_host_by_mark(doc,host,mark):\n    return FilteredElementCollector(doc,host.Id).OfClass(Rebar).WhereElementIsNotElementType().Where(lambda r:r.get_Parameter(BuiltInParameter.ALL_MODEL_MARK).AsString() == mark).ToElements()\n\n\n\ndef create_rebarShapeParams_from_csv(csv_path):\n    dict_list = dictionary_from_csv(csv_path)\n    params_template = {'a': None, 'b': None, 'c': None, 'd': None, 'e': None, 'f': None, 'g': None, 'h': None, 'x': None, 'y': None, 'j': None}\n    updated_params_list = update_params_from_dict_list(dict_list, params_template)\n    return updated_params_list\n\ndef create_rebarShapePrarams_from_dict(dict):\n    params_template = {'a': None, 'b': None, 'c': None, 'd': None, 'e': None, 'f': None, 'g': None, 'h': None, 'x': None, 'y': None, 'j': None}\n    updated_params = params_template.copy()\n    for key in updated_params:\n        if key in dict:\n            updated_params[key] = None if dict[key] == \"\" else float(dict[key])\n    return updated_params\n\ndef create_rebarShapeCurve_from_csv(csv_path, planes=None):\n    params_list = create_rebarShapeParams_from_csv(csv_path)\n    dict_list = dictionary_from_csv(csv_path)\n    if planes == None:\n        planes = [None for i in range(len(dict_list))]\n    rebarShape_list = []\n    for i, dict in enumerate(dict_list):\n        name = dict['shape']\n        data= find_row_by_name(name)\n        rgName = data[0]['RhinoBaseLineType']\n        rebarShape_list.append(RebarShapeCurve(rgName,name, planes[i],**params_list[i]).curve)\n    return rebarShape_list\n\ndef create_rebarShapeCurve_from_params(name,params, plane=None):\n    return RebarShapeCurve(name, plane,**params)\n\ndef create_rebarShape_rhinoCurve_from_dict(dict, plane=None):\n    shapeName = dict['shape']\n    if len(shapeName) == 1:\n        shapeName = \"0\" + shapeName\n\n    data= find_row_by_name(shapeName)\n    rgName = data[0]['RhinoBaseLineType']\n    params = create_rebarShapePrarams_from_dict(dict)\n    return RebarShapeCurve(rgName,shapeName, plane,**params)\n\ndef create_rebarShape_rhinoCurves_from_dict_list(dict_list, plane_list=None):\n    curves_list = []\n    for i, dict in enumerate(dict_list):\n        curves_list.append(create_rebarShape_rhinoCurve_from_dict(dict, plane_list[i]).curve)\n    return th.list_to_tree(curves_list)\n\ndef create_rebar_coupler_data(doc, rebar, start, end, coupler_family_name):\n    coupler_type = get_default_coupler_type(doc, rebar,coupler_family_name)\n    if coupler_type != None:\n        defaulttypeId = coupler_type.Id\n        #print(defaulttypeId)\n        if defaulttypeId != ElementId.InvalidElementId:\n            rebarData_start =None\n            rebarData_end =None\n            if start:\n                rebarData_start = RebarReinforcementData.Create(rebar.Id, 0)\n                #print(rebarData_start)\n            if end:\n                rebarData_end = RebarReinforcementData.Create(rebar.Id, 1)\n                #print(rebarData_end)\n            error = clr.Reference[RebarCouplerError]()\n\n            return defaulttypeId, rebarData_start, rebarData_end, error\n    return None\n\n\ndef create_rebar_coupler_at_index(doc,rebar, start, end,coupler_family_name):\n    doc = get_active_doc()\n    t = Transaction(doc, 'create coupler')\n    t.Start()\n    data = create_rebar_coupler_data(doc,rebar, start, end, coupler_family_name)\n    if data == None:\n        return rebar\n    type_Id, rebarData_start, rebarData_end, error = data\n    #print(\"type_Id\" , type_Id)\n    #print(\"rebarData_start\" , rebarData_start)\n    #print(\"rebarData_end\" , rebarData_end)\n    if type_Id == None:\n        return rebar\n    if rebarData_start == None and rebarData_end == None:\n        return rebar\n    if rebarData_start != None:\n        RebarCoupler.Create(doc, type_Id, rebarData_start, None, error)\n    if rebarData_end != None:\n        RebarCoupler.Create(doc, type_Id, rebarData_end, None, error)\n    t.Commit()\n    return rebar\n\ndef create_rebar_coupler_from_dict(doc, rebar, dict,coupler_family_name):\n    start = False\n    end = False\n    if 'coupler_start' in dict:\n        if dict['coupler_start'] == 1 or dict['coupler_start'] == \"1\":\n            start = True\n            \n            \n    if 'coupler_end' in dict:\n        if dict['coupler_end'] == 1 or dict['coupler_end'] == \"1\":\n            end = True\n    if end is False and start is False:\n        return rebar\n    return create_rebar_coupler_at_index(doc,rebar, start, end,coupler_family_name)\n    \ndef create_rebars_from_curves(curves, norms, types, shapes, pitches, a, b, c, d, e, f, g, comments, bar_numbers):\n    rebars = []\n    doc = get_active_doc()\n    with Transaction(doc,'create_bars') as t:\n        \n        t.Start()\n        failureOptions = t.GetFailureHandlingOptions()\n        handler = MyPreProcessor()\n        t.SetFailureHandlingOptions(failureOptions)\n\n        for i, curve in enumerate(curves):\n            rebar = Rebar.CreateFromCurvesAndShape(doc, shapes[i], types[i], None, None, None, norms[i], curve, RebarHookOrientation.Right, RebarHookOrientation.Right)\n            # Rebar...\n            rebars.append(rebar.Id)\n\n        t.Commit()\n    return rebars\n\ndef create_rebar_from_dict_CAS(doc,dict,  plane, host):\n    doc = get_active_doc()\n    t = Transaction(doc, 'create_bars')\n    t.Start()\n    shape = create_rebarShape_rhinoCurve_from_dict(dict, plane)\n    curves = shape.curve\n    norm = shape.plane.Normal\n    rv_norm = convert_rhino_to_revit_geometry(norm)\n    rv_curves = [convert_rhino_to_revit_geometry(curve) for curve in curves]\n    rv_shape = get_rebar_shape_by_name(shape.rv_name)\n    rv_type = get_rebar_type_by_diameter(float(dict['diameter']))\n    rv_startHookOrientation = get_hook_orientation_from_shapename(shape.rv_name)[0]\n    rv_endHookOrientation = get_hook_orientation_from_shapename(shape.rv_name)[1]\n    rv_startHookType = get_hook_type_from_shapename(shape.rv_name)[0]\n    rv_endHookType = get_hook_type_from_shapename(shape.rv_name)[1]\n    rebar = Rebar.CreateFromCurvesAndShape(doc, rv_shape, rv_type, rv_startHookType, rv_endHookType, host, rv_norm, rv_curves, rv_startHookOrientation, rv_endHookOrientation)\n    t.Commit()\n    return rebar\n\ndef create_rebar_from_curve_CAS(curves, plane, host, diameter, shapeName):\n    doc = get_active_doc()\n    rv_curves = [convert_rhino_to_revit_geometry(curve) for curve in curves]\n    rv_norm = convert_rhino_to_revit_geometry(plane.Normal)\n    rv_shape = get_rebar_shape_by_name(shapeName)\n    rv_type = get_rebar_type_by_diameter(diameter)\n    rebar = Rebar.CreateFromCurvesAndShape(doc, rv_shape, rv_type, None, None, host, rv_norm, rv_curves, RebarHookOrientation.Right, RebarHookOrientation.Right)\n    return rebar\n\ndef create_rebar_from_dict_RS(dict,  plane, host):\n    doc = get_active_doc()\n    shape = create_rebarShape_rhinoCurve_from_dict(dict, plane)\n    rv_shape = get_rebar_shape_by_name(shape.rv_name)\n    rv_type = get_rebar_type_by_diameter(dict['diameter'])\n    rv_origin = convert_rhino_to_revit_geometry(shape.plane.Origin)\n    rv_xVec = convert_rhino_to_revit_geometry(shape.plane.XAxis)\n    rv_yVec = convert_rhino_to_revit_geometry(shape.plane.YAxis)\n    rebar = Rebar.CreateFromRebarShape(doc, rv_shape, rv_type, host, rv_origin, rv_xVec, rv_yVec)\n    return rebar\n\ndef create_rebar_from_C(curves, plane, host):\n    doc = get_active_doc()\n    rv_curves = [convert_rhino_to_revit_geometry(curve) for curve in curves]\n    rv_norm = convert_rhino_to_revit_geometry(plane.Normal)\n    rv_rebarStyle = None\n    rv_rebarBarStyle = None\n    rv_startHookType = None\n    rv_endHookType =None\n    rv_starthookOrientation =None\n    rv_endhookOrientation =None\n    useExistingShapeIfPossible = True\n    createNewShape = True\n    \n    rebar = Rebar.CreateFromCurves(doc, rv_rebarStyle, rv_rebarBarStyle, rv_startHookType, rv_endHookType, host, rv_norm, rv_curves,rv_starthookOrientation,rv_endhookOrientation,useExistingShapeIfPossible,createNewShape)\n    return rebar\n\ndef set_layoutAsNumberWithSpacing(rebar, number, spacing):\n    rv_spacing = convert_rhino_to_revit_length(spacing)\n    if rebar == None:\n        return rebar\n    accessor = rebar.GetShapeDrivenAccessor()\n    accessor.SetLayoutAsNumberWithSpacing(number, rv_spacing, True, True, True)\n    return rebar\n\ndef set_rebar_spacing_from_dict(rebar, dict):\n    doc = get_active_doc()\n    t = Transaction(doc, 'edit constraints')\n    t.Start()\n    if rebar == None:\n        return rebar\n    number = 1\n    spacing = 0\n    if 'spacing' not in dict or 'number' not in dict:\n        return rebar\n    else:\n        if dict['spacing'] == None or dict['spacing'] == \"\" or dict['spacing'] == 0:\n            return rebar\n        else:\n            spacing = float(dict['spacing'])\n        if dict['number'] == None or dict['number'] == \"\" or dict['number'] == 0 or dict['number'] == 1:\n            return rebar\n        else:\n            number = int(dict['number'])\n    bar_counts = int(dict['number']) \n    if bar_counts > 1 and spacing > 0:\n        rebar = set_layoutAsNumberWithSpacing(rebar, bar_counts, float(dict['spacing']))\n    t.Commit()\n    return rebar\n\ndef set_comment(rebar, comment):\n    doc = get_active_doc()\n    t = Transaction(doc, 'set comment')\n    t.Start()\n    if rebar == None:\n        return rebar\n    comment_param = rebar.get_Parameter(BuiltInParameter.ALL_MODEL_INSTANCE_COMMENTS)\n    comment_param.Set(comment)\n    t.Commit()\n    return rebar\n\ndef set_comment_from_dict(rebar, dict):\n    if rebar == None:\n        return rebar\n    if 'name' not in dict or dict['name'] == None:\n        return rebar\n    rebar = set_comment(rebar, dict['name'])\n    return rebar\n\n\n\n\ndef create_rebars_from_dict_CAS(dict_list, plane_list, host,coupler_family_name=\"CPLD\"):\n    doc = get_active_doc()\n    rebars = []\n\n    transaction_group = TransactionGroup(doc, \"Grouped Transactions\")\n    transaction_group.Start()\n    try:\n        for i, dict in enumerate(dict_list):\n            rebar = create_rebar_from_dict_CAS(doc, dict,  plane_list[i], host)\n            rebar = set_rebar_spacing_from_dict(rebar, dict)\n            rebar = create_rebar_coupler_from_dict(doc, rebar, dict,coupler_family_name)\n            rebar = set_comment_from_dict(rebar, dict)\n            if rebar != None:\n                rebars.append(rebar)\n        transaction_group.Assimilate()\n\n    except Exception as e:\n        # TransactionGroup\n        print(\"Error:\", e)\n        transaction_group.RollBack()\n    \n\n    return rebars\n\ndef create_rebar_from_dict_FreeForm(doc,dict,  plane, host):\n    t = Transaction(doc, 'create_bars')\n    t.Start()\n    shape = create_rebarShape_rhinoCurve_from_dict(dict, plane)\n    curves = shape.curve\n    norm = shape.plane.Normal\n    rv_curves_list = List[IList[Curve]]()\n    space = float(dict['spacing'])\n    number = int(dict['number'])\n    if number <= 1:\n        curve_group = List[Curve]([convert_rhino_to_revit_geometry(curve) for curve in curves])\n        rv_curves_list.Add(curve_group)\n    else:\n        for i in range(number):\n            offset_curves = []\n            for curve in curves:\n                distance = space * i\n                offset_vector = norm * distance\n                nurbs_curve = curve.ToNurbsCurve()\n                transformed_nurbs_curve = nurbs_curve.Duplicate()\n                transformed_nurbs_curve.Translate(offset_vector)\n                offset_curves.append(transformed_nurbs_curve)\n            rv_curves = List[Curve]([convert_rhino_to_revit_geometry(curve) for curve in offset_curves])\n            rv_curves_list.Add(rv_curves)\n    \n  \n    rv_type = get_rebar_type_by_diameter(float(dict['diameter']))\n    rv_startHookOrientation = get_hook_orientation_from_shapename(shape.rv_name)[0]\n    rv_endHookOrientation = get_hook_orientation_from_shapename(shape.rv_name)[1]\n    rv_startHookType = get_hook_type_from_shapename(shape.rv_name)[0]\n    rv_endHookType = get_hook_type_from_shapename(shape.rv_name)[1]\n    style = get_hook_type_from_shapename(shape.rv_name)[2]\n    error = clr.Reference[RebarFreeFormValidationResult]()\n    rebar = Rebar.CreateFreeForm(doc, rv_type,host,rv_curves_list, error)\n    if error.Value == RebarFreeFormValidationResult.Success:\n        '''\n        \n        workshop_instuctions_param =rebar.get_Parameter(BuiltInParameter.REBAR_WORKSHOP_INSTRUCTIONS)\n        if partition_param and partition is not None:\n            # Number Suffix\n            partition_param.Set(partition)\n            print(f\"Updated Rebar Number Suffix for Rebar ID: {rebar.Id}\")\n        if workshop_instuctions_param :\n            workshop_instuctions_param.Set(0)\n        #rebar.set_hook_orientation(0, rv_startHookOrientation)\n        #rebar.set_hook_orientation(1, rv_endHookOrientation)\n        #rebar.set_hook_type(0, rv_startHookType)\n        #rebar.set_hook_type(1, rv_endHookType)\n        '''\n        workshop_instuctions_param =rebar.get_Parameter(BuiltInParameter.REBAR_WORKSHOP_INSTRUCTIONS)\n        if workshop_instuctions_param :\n            workshop_instuctions_param.Set(0)\n        \n        if rebar != None:\n            \n            #rebar.get_Parameter(BuiltInParameter.REBAR_ELEM_HOOK_STYLE).Set(int(RebarStyle.StirrupTie))\n            rebar.get_Parameter(BuiltInParameter.REBAR_ELEM_HOOK_STYLE).Set(int(style))\n\n  \n            try:\n                rebar.SetHookOrientation(0, rv_startHookOrientation)\n                rebar.SetHookOrientation(1, rv_endHookOrientation)\n                \n                if(rebar.CanUseHookType(rv_startHookType.Id)):\n                    rebar.SetHookTypeId(0, rv_startHookType.Id)\n                    print(\"Set Hook Type\" , rv_startHookType.Id)\n                if(rebar.CanUseHookType(rv_endHookType.Id)):\n                    rebar.SetHookTypeId(1, rv_endHookType.Id)\n                \n\n                t.Commit()\n                return rebar\n            except Exception as e:\n                print(\"Error:\", e)\n                t.RollBack()\n                return None\n    else:\n        print(\"Failed to create rebar:\", error.Value)\n        t.RollBack()\n        return None\n    return None\n\n    \n\n\ndef create_rebars_from_dict_FreeForm(dict_list, plane_list, host,coupler_family_name=\"CPLD\"):\n    doc = get_active_doc()\n    transaction_group = TransactionGroup(doc, \"Grouped Transactions\")\n    transaction_group.Start()\n    rebars = []\n    try:\n        for i, dict in enumerate(dict_list):\n            rebar = create_rebar_from_dict_FreeForm(doc, dict,  plane_list[i], host)\n            rebar = create_rebar_coupler_from_dict(doc, rebar, dict,coupler_family_name)\n            rebar = set_comment_from_dict(rebar, dict)\n            if rebar != None:\n                rebars.append(rebar)\n        transaction_group.Assimilate()\n        print(\"Success\")\n\n    except Exception as e:\n        # TransactionGroup\n        print(\"Error:\", e)\n        transaction_group.RollBack()\n   \n    pass\n\n\n    \n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["curve", "line", "classes", "functions"], "original_file": "GEL-Dev_RebarRIRToolkit_cd955100fb.json", "repo": "GEL-Dev/RebarRIRToolkit"}
{"instruction": "This is the object to Construct room", "code": "import numpy as np\nimport rhino3dm as rhino3dm\nfrom Graphic.BaseGeometry import BaseGeometry\nfrom Acoustic.Material import Material\n\n\nclass Plane:\n    \"\"\"\n    This is the object to Construct room\n    \"\"\"\n\n    def __init__(self, rhino_plane: rhino3dm.Brep, material: Material):\n        \"\"\"\n        Init plane\n        :param rhino_plane: A rhino Brep object\n        :param material: The material object of this plane\n        \"\"\"\n        self.rhino_plane = rhino_plane\n        self.material = material\n        self.material_name = material.name\n        self.diffuse_abs_coe = material.diffuse_abs\n        self.normal_abs_coe = material.normal_abs\n        self.ref_coe = material.ref_0\n        self.sca_coe = material.scatter\n        self.array_plane = []\n\n        # Change the rhino data to Ndarray with shape (n,3)\n        for idx in range(len(rhino_plane.Geometry.Edges)):\n            # TODO BUG is Here: The point is not in the order\n            # No closed polygon\n            pt_1 = rhino_plane.Geometry.Edges[idx].PointAtStart\n            tmp_pt1 = np.array([pt_1.X, pt_1.Y, pt_1.Z])\n            pt_2 = rhino_plane.Geometry.Edges[idx].PointAtEnd\n            tmp_pt2 = np.array([pt_2.X, pt_2.Y, pt_2.Z])\n            tmp_pt = np.array([tmp_pt1, tmp_pt2])\n            # Get the start point and end point, append it into array_plane\n            self.array_plane.append(tmp_pt)\n        # print(f\"Array Plane: {self.array_plane}\")\n        # Switch the right order of the first item\n        # if (self.array_plane[0][0,:] == self.array_plane[1][0,:]).all():\n        #     self.array_plane[0] = np.array([self.array_plane[0][1,:],self.array_plane[0][0,:]])\n        # elif (self.array_plane[0][0,:] == self.array_plane[1][1,:]).all():\n        #     self.array_plane[0] = np.array([self.array_plane[0][1, :], self.array_plane[0][0, :]])\n        tmp_plane = [self.array_plane[0]]\n        rest_plane = self.array_plane[1:]\n        while len(rest_plane) != 0:\n            compare_pt = tmp_plane[-1][1, :]\n            for idx in range(len(rest_plane)):\n                if np.allclose(compare_pt, rest_plane[idx][0, :]):\n                    tmp_plane.append(rest_plane[idx])\n                    del rest_plane[idx]\n                    break\n                elif np.allclose(compare_pt, rest_plane[idx][1, :]):\n                    tmp_plane.append(np.array([rest_plane[idx][1, :], rest_plane[idx][0, :]]))\n                    del rest_plane[idx]\n                    break\n        self.array_plane = tmp_plane\n        # print(f\"Array Plane: {self.array_plane}\")\n\n        # polygon is the list contain the unique point\n        polygon = []\n        for i in range(len(self.array_plane)):\n            polygon.append(self.array_plane[i][0,:])\n\n        # Struct the polygon\n        polygon = np.array(polygon)\n        self.polygon = polygon\n\n        self.array_plane = np.array(self.array_plane)\n        self.planar_state = BaseGeometry.is_planar(self.polygon)\n        self.normal_direc, self.cen_pt, self.intercept_d = BaseGeometry.normal_direction(self.polygon)\n        self.area = BaseGeometry.area(polygon, self.cen_pt)\n\n    def __str__(self):\n        return f\"The plane is {self.polygon}. The material is {self.material_name}\"\n\n\nif __name__ == \"__main__\":\n    from FileIO.ReadRhino import Read3dm\n    path = \"/Users/liguanda/Desktop/MasterReasearch/MasterFinal/code/Simu/Test_File/Test_Theater.3dm\"\n    rhino_file = Read3dm(path)\n    plane_dict, _, _ = rhino_file.convert_file()\n    plane_list = []\n    for key in plane_dict.keys():\n        for rh_plane in plane_dict[key]:\n            tmp_plane = Plane(rh_plane,np.asarray([0.1,0.1,0.1,0.1,0.1]),np.asarray([0.1,0.1,0.1,0.1,0.1]),key)\n            plane_list.append(tmp_plane)\n            print(f\"Array: {tmp_plane.polygon}, is planar: {tmp_plane.planar_state}, \"\n                  f\"normal direction is: {tmp_plane.normal_direc}\")\n    print(f\"Total {len(plane_list)} planes\")", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["brep", "classes", "functions", "point"], "original_file": "Guanda0120_Geometry_Acoustic_Simu_b6c64656e9.json", "repo": "Guanda0120/Geometry_Acoustic_Simu"}
{"instruction": "Implement a function to generate meta", "code": "import Rhino.Geometry as rg\nimport Rhino\nimport json\nimport time\n\nimport numpy as np\nfrom parameters.params import PICKLE_PROTOCOL\nimport datetime\n\n# Generate a meta data dict based on keys and values\ndef generate_meta(keys, values):\n    meta = {}\n    \n    for key, value in zip(keys, values):\n        if key.lower() == 'time':\n            meta[key] = str(datetime.datetime.now())\n        else:\n            meta[key] = value\n    \n    return meta\n\n# Save a mesh to a json file in base64 format\n# The json data is a base64 encoded string of the byte array representing the geometry.\ndef save_mesh_to_json(meshes, mesh_types, name, folder, meta_data=None, logger=False):\n    start = time.time()\n    path = folder + \"/\" + name + \".json\"\n    \n    options = Rhino.FileIO.SerializationOptions()\n    data = {}\n    \n    for i, mesh in enumerate(meshes):\n        if isinstance(mesh, list):\n            temp_mesh = rg.Mesh()\n            \n            for m in mesh:\n                temp_mesh.Append(m)\n            \n            data[mesh_types[i]] = temp_mesh.ToJSON(options)\n        else:\n            data[mesh_types[i]] = mesh.ToJSON(options)\n    \n    data['meta'] = meta_data\n\n    with open(path, \"w\") as file:\n        json.dump(data, file)\n    \n    if logger:\n        logger.info(f\"Mesh {name} saved in {round(time.time() - start)}s\")\n    \ndef save_outlines_to_json(outlines, name, folder, logger=False):\n    start = time.time()\n    path = folder + \"/\" + name + \".json\"\n    \n    options = Rhino.FileIO.SerializationOptions()\n    data = {}\n    \n    for i, outline in enumerate(outlines):\n        for j, polyline in enumerate(outline):\n            curve = polyline.ToNurbsCurve()\n            curve_name = f\"curve_{str(i)}_{str(j)}\"\n            data[curve_name] = curve.ToJSON(options)\n\n    with open(path, \"w\") as file:\n        json.dump(data, file)\n    \n    if logger:\n        logger.info(f\"Polyines {name} saved in {round(time.time() - start)}s\")\n\ndef save_array(array, name, folder, logger=False):\n    start = time.perf_counter()\n    path = folder + '\\\\' + name + '.npy'\n    \n    np.save(path, array)\n    \n    if logger:\n        logger.info(f\"Array saved in {round(time.perf_counter() - start)}s\")\n\ndef save_array_as_list(array, name, folder, logger=False):\n    start = time.time()\n    list_data = array.tolist()\n    \n    path = folder + \"/\" + name + \".json\"\n    \n    data = json.dumps(list_data)\n\n    with open(path, 'w') as file:\n        json.dump(data, file)\n    \n    if logger:\n        logger.info(f\"Array_list {name} saved in {round(time.time() - start)}s\")\n    \n    # with open('./data/list_data.pkl', 'wb') as file:\n    #     pickle.dump(list_data, file, protocol=PICKLE_PROTOCOL)\n\n# Save an HB model to a file as json file\ndef save_hbjson(model, name, folder, logger=False):\n    start = time.time()\n    model.to_hbjson(name=name, folder=folder)\n    \n    if logger:\n        logger.info(f\"HB_model {name} saved in {round(time.time() - start)}s\")", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["line", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "JobdeVogel_Solar-Irradiation-Prediction_90d87dd6fb.json", "repo": "JobdeVogel/Solar-Irradiation-Prediction"}
{"instruction": "Implement the function 'modifier' for Rhino scripting", "code": "import Rhino.Geometry as rg\n\nimport uuid\n\nfrom honeybee.face import Face\nfrom honeybee.facetype import face_types\nfrom honeybee.boundarycondition import boundary_conditions\nfrom honeybee.typing import clean_string, clean_and_id_string, clean_and_id_rad_string, clean_rad_string\n\n# Ladybug-Rhino dependencies\nfrom ladybug_rhino.togeometry import to_mesh3d, to_face3d\n# from ladybug_rhino.grasshopper import longest_list\nfrom ladybug_rhino.config import units_system, tolerance, angle_tolerance\n\n# Honeybee Core dependencies\nfrom honeybee.model import Model\n\n# Honeybee-Radiance dependencies\nfrom honeybee_radiance.lib.modifiers import modifier_by_identifier\nfrom honeybee_radiance.modifier.material import Plastic\nfrom honeybee_radiance.sensorgrid import SensorGrid\n\n\nimport time\n\nfrom parameters.params import REFLECTANCE, SPECULAR, ROUGHNESS, MODIFIER_NAME\n\ndef modifier(reflectance=REFLECTANCE, specular=SPECULAR, roughness=ROUGHNESS, name=MODIFIER_NAME):\n    # Set the default modifier properties\n    specular = 0.0 if specular is None else specular\n    roughness = 0.0 if roughness is None else roughness\n    name = clean_and_id_rad_string('OpaqueMaterial') if name is None else \\\n        clean_rad_string(name)\n\n    # Create the modifier\n    modifier = Plastic.from_single_reflectance(name, reflectance, specular, roughness)\n    modifier.display_name = name\n    \n    return modifier\n\ndef generate_HB_faces(mesh, modifier, name=\"faces\", boundary_condition=\"outdoors\"):\n    faces = []\n    for j, geo in enumerate(mesh):\n\n        # Assign Name\n        # display_name = '{}_{}'.format(longest_list(name, j), j + 1)\n        display_name = 'temp'\n        name = clean_and_id_string(display_name)\n        \n        # Type is not used in this context\n        typ = None\n        \n        # Assign boundary condition\n        bc = boundary_conditions.by_name(boundary_condition)\n        \n        # Generate LB faces\n        \n        lb_faces = to_face3d(geo)   # OPTIMIZE SPEED\n        for i, lb_face in enumerate(lb_faces):\n            face_name = '{}_{}'.format(name, i)\n            hb_face = Face(face_name, lb_face, typ, bc)\n            hb_face.display_name = display_name\n\n            # Assign radiance modifier\n            hb_face.properties.radiance.modifier = modifier\n            \n            # Append faces to collection\n            faces.append(hb_face)\n\n    return faces\n\ndef HB_model(faces, grid, name=\"model_\" + str(time.time())):\n    # Set a default name and get the Rhino Model units\n    name = clean_string(name)\n    units = units_system()\n\n    # Generate model with only name and faces\n    model = Model(name, [], faces, [], [], [],\n                  units=units, tolerance=tolerance, angle_tolerance=angle_tolerance)\n    model.display_name = name\n    \n    if isinstance(grid, list):\n        model.properties.radiance.add_sensor_grids(grid)\n    else:\n        model.properties.radiance.add_sensor_grids([grid])\n    \n    return model\n\n#model.to_hbjson(name='xjdsd', folder='C://Users//Job de Vogel//Desktop')\n\ndef grid(points, normals, name=\"custom_SensorGrid\"):\n    # Set the default name and process the points to tuples\n    name = name\n    pts = [(pt.X, pt.Y, pt.Z) if pt is not None else None for pt in points]\n\n    # create the sensor grid object\n    id  = clean_rad_string(name) if '/' not in name else clean_rad_string(name.split('/')[0])\n    if len(normals) == 0:\n        grid = SensorGrid.from_planar_positions(id, pts, (0, 0, 1))\n    else:\n        vecs = [(vec.X, vec.Y, vec.Z) if vec is not None else None for vec in normals]\n        grid = SensorGrid.from_position_and_direction(id, pts, vecs)\n\n    # set the display name\n    grid.display_name = name\n    if '/' in name:\n        grid.group_identifier = \\\n            '/'.join(clean_rad_string(key) for key in name.split('/')[1:])\n    \n    return grid\n\ndef generate(ground_mesh, roof_mesh, wall_mesh, sensors, normals):\n    mod = modifier()\n    faces = []\n\n    faces.extend(generate_HB_faces(ground_mesh, mod))\n    faces.extend(generate_HB_faces(roof_mesh, mod))\n    faces.extend(generate_HB_faces(wall_mesh, mod))\n\n    sensor_grid = grid(sensors, normals)\n    \n    name = str(uuid.uuid4())\n    \n    model = HB_model(faces, sensor_grid, name=name)\n    \n    return model", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "mesh", "functions", "RhinoCommon"], "original_file": "JobdeVogel_Solar-Irradiation-Prediction_fa71001ba0.json", "repo": "JobdeVogel/Solar-Irradiation-Prediction"}
{"instruction": "Converts an Open3D mesh into a Rhino3dm mesh.", "code": "import pyarrow.parquet as pq\nimport os\nimport pandas as pd\nimport numpy as np\nimport open3d as o3d\nimport ghhops_server as hs\nimport rhino3dm\nfrom flask import Flask\nimport open3d as o3d\nimport cv2\nimport outline\n\n\n\n\ndef o3d_to_rhino3dm(o3d_mesh):\n    \"\"\"\n    Converts an Open3D mesh into a Rhino3dm mesh.\n\n    Parameters:\n        o3d_mesh (o3d.geometry.TriangleMesh): The Open3D mesh to convert.\n\n    Returns:\n        rhino3dm.Mesh: The converted Rhino3dm mesh.\n    \"\"\"\n\n    \n    # Create a new Rhino3dm mesh\n    rhino_mesh = rhino3dm.Mesh()\n\n    # Add vertices to the Rhino mesh\n    for vertex in o3d_mesh.vertices:\n        rhino_mesh.Vertices.Add(vertex[0], vertex[1], vertex[2])\n        \n\n    for colour in o3d_mesh.vertex_colors:\n        rhino_mesh.VertexColors.Add(int(colour[0]*255),int(colour[1]*255), int(colour[2]*255))\n    # Add faces to the Rhino mesh\n    for triangle in o3d_mesh.triangles:\n        rhino_mesh.Faces.AddFace(triangle[0], triangle[1], triangle[2])\n\n    return rhino_mesh\n\ndef aabb_to_mesh(aabb):\n    \"\"\"\n    Converts an Open3D AxisAlignedBoundingBox into a TriangleMesh.\n\n    Parameters:\n        aabb (o3d.geometry.AxisAlignedBoundingBox): The bounding box to convert.\n\n    Returns:\n        o3d.geometry.TriangleMesh: The mesh representation of the AABB.\n    \"\"\"\n    # Get the eight corners of the AABB\n    corners = np.asarray(aabb.get_box_points())\n    \n    # Define the 12 triangles (faces) of the box using the corners\n    faces = [\n        [0, 1, 2], [0, 2, 3],  # bottom face\n        [4, 5, 6], [4, 6, 7],  # top face\n        [0, 1, 5], [0, 5, 4],  # front face\n        [2, 3, 7], [2, 7, 6],  # back face\n        [1, 2, 6], [1, 6, 5],  # right face\n        [0, 3, 7], [0, 7, 4]   # left face\n    ]\n    \n    # Create a TriangleMesh from the corners and faces\n    mesh = o3d.geometry.TriangleMesh()\n    mesh.vertices = o3d.utility.Vector3dVector(corners)\n    mesh.triangles = o3d.utility.Vector3iVector(faces)\n    \n    # Optionally, compute normals for better visualization\n    mesh.compute_vertex_normals()\n    \n    return mesh\n\n\ndef create_bounding_box(point_cloud):\n    \"\"\"\n    Create a simplified bounding box around the point cloud.\n\n    Parameters:\n        point_cloud (o3d.geometry.PointCloud): The point cloud to wrap.\n\n    Returns:\n        o3d.geometry.TriangleMesh: The bounding box mesh.\n    \"\"\"\n    # Get the axis-aligned bounding box (AABB)\n    aabb = point_cloud.get_axis_aligned_bounding_box()\n    \n    bounding_box_mesh = aabb_to_mesh(aabb)\n    # Create a mesh from the bounding bo\n    # bounding_box_mesh = o3d.geometry.TriangleMesh.create_from_axis_aligned_bounding_box(aabb)\n    \n    # Optionally, we can apply a scaling factor to make the box larger\n    scale_factor = 1.05  # Scale to make the box slightly larger\n    bounding_box_mesh.scale(scale_factor, center=aabb.get_center())\n    \n    return bounding_box_mesh\n\n\ndef dfToPC(df):\n    # Convert DataFrame to NumPy array\n    points = df[['x', 'y', 'z']].to_numpy()\n    # Create an Open3D point cloud object\n    pcd = o3d.geometry.PointCloud()\n\n    # Extract XYZ coordinates\n    points = df[['x', 'y', 'z']].values\n    pcd.points = o3d.utility.Vector3dVector(points)\n\n    # Normalize RGB values to the range [0, 1]\n    colors = df[['r', 'g', 'b']].values / 255.0\n    pcd.colors = o3d.utility.Vector3dVector(colors)\n    return pcd\n\n\ndef dfToBB(df):\n    return create_bounding_box(dfToPC(df))\n\ndef wallsMesh(pline, height):\n    pts = pline\n    meshList = []\n    holder = []\n    for i, pt in enumerate(pline):\n        mesh = rhino3dm.Mesh()\n        ptA = pt\n        if i == len(pline) - 1:\n            ptB1 = pline[0]\n        else:\n            ptB1 = pline[i+1]\n        ptB = rhino3dm.Point3d(pt.X, pt.Y, height[1])\n        ptA1 = rhino3dm.Point3d(ptB1.X, ptB1.Y, height[1])\n        \n        mesh.Vertices.Add(ptA.X, ptA.Y, ptA.Z)\n        mesh.Vertices.Add(ptB.X, ptB.Y, ptB.Z)\n        mesh.Vertices.Add(ptA1.X, ptA1.Y, ptA1.Z)\n        mesh.Vertices.Add(ptB1.X, ptB1.Y, ptB1.Z)\n        \n        mesh.Faces.AddFace(0,1,2,3)\n        # Optionally: Compute the normals\n        mesh.Normals.ComputeNormals()\n        meshList.append(mesh)\n    meshHolder = rhino3dm.Mesh()\n    for mesh in meshList:\n        meshHolder.Append(mesh)\n    return meshHolder\n\n\n\n\ndef windowMesh(line, zBounds):\n    mesh = rhino3dm.Mesh()\n    ptA = rhino3dm.Point3d(line[0][0], line[0][1], zBounds[0])\n    ptB1 = rhino3dm.Point3d(line[1][0], line[1][1], zBounds[0])\n    ptB = rhino3dm.Point3d(line[0][0], line[0][1], zBounds[1])\n    ptA1 = rhino3dm.Point3d(line[1][0], line[1][1], zBounds[1])\n    \n    mesh.Vertices.Add(ptA.X, ptA.Y, ptA.Z)\n    mesh.Vertices.Add(ptB.X, ptB.Y, ptB.Z)\n    mesh.Vertices.Add(ptA1.X, ptA1.Y, ptA1.Z)\n    mesh.Vertices.Add(ptB1.X, ptB1.Y, ptB1.Z)\n    \n    mesh.Faces.AddFace(0,1,2,3)\n    # Optionally: Compute the normals\n    mesh.Normals.ComputeNormals()\n    \n\n    return mesh\n\n\ndef dfToMesh(df):\n    \n    # Create an open3d PointCloud object\n    pcd = o3d.geometry.PointCloud()\n    points = df[['x', 'y', 'z']].values\n    pcd.points = o3d.utility.Vector3dVector(points)\n\n    \n\n    # Normalize RGB values to [0, 1] range and assign them to the point cloud\n    colors = df[['r', 'g', 'b']].values / 255.0\n    pcd.colors = o3d.utility.Vector3dVector(colors)\n\n    o3d.io.write_point_cloud(\"colored_pts.ply\", pcd)\n\n\n \n    # Estimate normals for Poisson reconstruction\n    pcd.estimate_normals(search_param=o3d.geometry.KDTreeSearchParamHybrid(radius=0.1, max_nn=30))\n\n    # with o3d.utility.VerbosityContextManager(\n    #         o3d.utility.VerbosityLevel.Debug) as cm:\n    mesh, densities = o3d.geometry.TriangleMesh.create_from_point_cloud_poisson(\n        pcd, depth=9)\n\n    # Define a threshold to remove low-density vertices\n    vertices = np.asarray(mesh.vertices)\n    density_threshold = np.percentile(densities, 5)  # Remove the bottom 5% of densities\n    vertices_to_remove = densities < density_threshold\n\n    # Filter vertices based on the density threshold\n    mesh.remove_vertices_by_mask(vertices_to_remove)\n    # # Create a mesh using Poisson reconstruction\n    # mesh, densities = o3d.geometry.TriangleMesh.create_from_point_cloud_poisson(pcd, depth=9)\n\n    # # Map the colors from the point cloud to the mesh vertices\n    # mesh.vertex_colors = pcd.colors\n\n    # Save the mesh to a .ply file, preserving vertex colors\n    return mesh\n\n\ndef getPlanarMesh(pLine):\n    rhino3dm.NurbsSurface.Create()\n\n\ndef getPolyline(ptList, bottomBound):\n    pts = []\n    if(len(ptList) > 3):\n        ptList = np.append(ptList, [ptList[0]], axis=0)\n        \n    for pt in ptList:\n        pts.append(rhino3dm.Point3d(pt[0],pt[1],bottomBound))\n    return rhino3dm.Polyline(pts)\n\ndef dfToRhinoMesh(df):\n    return o3d_to_rhino3dm(dfToMesh(df))\n\ndef dfToRhinoBBMesh(df):\n    return o3d_to_rhino3dm(dfToBB(df))\n# def add_numbers(a: str, b: float) -> rhino3dm.Mesh:\n\n\ndef runAll():\n    from os import listdir\n    from os.path import isfile, join\n    onlyfiles = [f for f in listdir(\"C:/Users/mskepasts/Documents/GitHub/3d-scan-with-spatial-analysis/data/\") if isfile(join(\"C:/Users/mskepasts/Documents/GitHub/3d-scan-with-spatial-analysis/data/\", f))]\n\n    for file in onlyfiles:\n        fileName = os.path.basename(file).split('/')[-1]\n        run(fileName)\n\n\ndef getHeight(walldf):\n    return walldf['Z'].max() - walldf['Z'].min()\n\n\ndef run(name):\n    try:\n        a = dir_path = \"C:/Users/mskepasts/Documents/GitHub/3d-scan-with-spatial-analysis/\" + \"/data/\" + name\n        table = pq.read_table(a)\n\n    except:\n        exit(\"File does not exist...\")\n\n\n    model = rhino3dm.File3dm()\n    final_fp,room_height,final_endpoint_lst,z_bound = outline.main(a)\n    pLine = getPolyline(final_fp, room_height[0])\n    for i, points in enumerate(final_endpoint_lst):\n        model.Objects.AddMesh(windowMesh(points, z_bound[i]))\n        model.Objects.AddPolyline(getPolyline(points, z_bound[i][0]))\n    \n    \n    model.Objects.AddMesh(wallsMesh(pLine, room_height))\n    # Convert to a pandas DataFrame if needed\n    df = table.to_pandas()\n    dfWalls = df[df['cat'] == 2]\n    dfFloor = df[df['cat'] == 1]\n    dfCeiling = df[df['cat'] == 0]\n    dfWindow =df[df['cat'] == 10]\n\n    if(len(dfWindow) == 0):\n        fileName = os.path.basename(a).split('/')[-1]\n        print(str(fileName) + \" has no windows!!\")\n        return\n        \n    print(\"Number of points in the walls: \" + str(len(dfWalls)))\n    print(\"Number of points in the floor: \" + str(len(dfFloor)))\n    print(\"Number of points in the ceiling: \" + str(len(dfCeiling)))\n\n\n\n    df_sampleWalls = dfWalls.sample(n=40000, random_state=1)\n    df_sampleFloor = dfFloor\n    df_sampleCeiling = dfCeiling\n    # df_sampleWalls = dfWalls.sample(n=40000, random_state=1)\n    df_sampleFloor = dfFloor.sample(n=40000, random_state=1)\n    df_sampleCeiling = dfCeiling.sample(n=40000, random_state=1)\n\n\n    df_sampleWindow = df[df['cat'] == 10]\n\n    walls = dfToRhinoMesh(df_sampleWalls)\n    floor = dfToRhinoMesh(df_sampleFloor)\n    ceiling = dfToRhinoMesh(df_sampleCeiling)\n    window = dfToRhinoMesh(df_sampleWindow)\n    # Create a 3dm file\n    # o3d.io.write_triangle_mesh(\"colored_mesh.ply\", dfToMesh(df_sampleWalls))\n\n\n   \n    model.Objects.AddMesh(walls)\n    model.Objects.AddMesh(floor)\n    model.Objects.AddMesh(ceiling)\n    model.Objects.AddMesh(window)\n    model.Objects.AddPolyline(pLine)\n\n    fileName = os.path.basename(a).split('/')[-1]\n    num = fileName[fileName.index(\"_\")+1 : fileName.index(\".\")]\n\n    # Write the model to a file\n    model.Write(\"C:/Users/mskepasts/Documents/GitHub/3d-scan-with-spatial-analysis/models/\" + \"setup_\" + str(num)+ \".3dm\", 6) \n\n    print(\"Rhino Model: \" + \"setup_\" + str(num)+ \" saved!\")\n    print(\"\\n\")\n\n# Defining main function\ndef main():\n    \n    num = input(\"What file number?: \")\n    \n    if num.capitalize() == \"All\":\n        print(\"yes\")\n        runAll()\n    else:\n        run(\"setup_\" + num + \".parquet\")\n\n\n# Using the special variable \n# __name__\nif __name__==\"__main__\":\n    main()\n\n\n\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["surface", "point", "line", "functions", "mesh"], "original_file": "Kyungho0511_3d-scan-with-spatial-analysis_9eafc0eb2a.json", "repo": "Kyungho0511/3d-scan-with-spatial-analysis"}
{"instruction": "Implement a function to build frames", "code": "import ghhops_server as hs\nfrom flask import Flask\nimport rhino3dm as rh\nimport joblib\n\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import curve_fit\nfrom scipy.spatial.transform import Rotation\nimport json\nimport numpy as np\nimport pandas as pd\nimport math\nimport copy\nimport os\nimport re\n\n\nloaded_model = joblib.load('gradient_boosting_model.joblib')\nfiles = os.listdir(\"PredictionModels\\\\\")\nmodel_dict = {}\nfor file in files:\n    name = re.split(r'\\.',file)[0]\n    model = joblib.load('PredictionModels\\\\{}'.format(file))\n    model_dict[name] = model\n\napp = Flask(__name__)\nhops: hs.HopsFlask = hs.Hops(app)\n\n\n\ndef build_frames(data):\n    frames = []\n    for i in range(len(data[\"X\"])):\n        frame = [data[\"X\"][i],data[\"Y\"][i],data[\"Z\"][i],data[\"A\"][i],data[\"B\"][i],data[\"C\"][i]]\n        frames.append(frame)\n    return frames\n\ndef distance(f1,f2):\n    dist = math.sqrt((f2[0]-f1[0])**2 + (f2[1]-f1[1])**2 +(f2[2]-f1[2])**2)\n    return dist \n\ndef angle_difference(frame1, frame2):\n    # Extract Euler angles from each frame\n    euler_angles1 = [float(x) for x in frame1[3:]]\n    euler_angles2 = [float(x) for x in frame2[3:]]\n\n    # Create rotation matrices from Euler angles\n    rotation_matrix1 = Rotation.from_euler('xyz', euler_angles1, degrees=True).as_matrix()\n    rotation_matrix2 = Rotation.from_euler('xyz', euler_angles2, degrees=True).as_matrix()\n\n    # Calculate the rotation matrix that transforms frame1 to frame2\n    relative_rotation_matrix = rotation_matrix2 @ rotation_matrix1.T\n\n    # Convert the rotation matrix to axis-angle representation\n    axis_angle = Rotation.from_matrix(relative_rotation_matrix).as_rotvec()\n\n    # Calculate the angle difference\n    angle_difference = np.linalg.norm(axis_angle)\n\n    return angle_difference\n\ndef calculateTaskDistance(frames,frames2,currentPos):\n    \n    dist = 0\n    angle = 0\n    #this is glue task \n    if frames != None and frames2 != None and frames!=[] and frames2!=[]:\n        #frames = re.split(';',frames)\n        #frames2 = re.split(';',frames2)\n                \n        dist += distance(frames[0],currentPos)\n        angle += abs(angle_difference(currentPos,frames[0]))\n        \n        if len(frames)==1:\n            #print (\"angle---\",angle)\n            return dist,angle,frames2[-1]\n        \n        for i in range(1,len(frames)):\n            dist += distance(frames[i-1],frames2[i-1])\n            dist += distance(frames2[i-1],frames[i])\n            \n            angle += abs(angle_difference(frames[i-1],frames2[i-1]))\n            angle += abs(angle_difference(frames2[i-1],frames[i]))\n            \n            \n            \n        dist += distance(frames[-1],frames2[-1])\n        angle += abs(angle_difference(frames[-1],frames2[-1]))\n        finalPos=frames2[-1]\n        #print (\"angle---\",angle)\n        return dist,angle,finalPos\n        \n    #this is a regular task\n    elif frames != None and frames!=[]:\n        \n        #frames = re.split(';',frames)\n        \n        dist += distance(frames[0],currentPos)\n        angle += abs(angle_difference(frames[0],currentPos))\n        \n        if len(frames)==1: \n            #print (\"angle---\",angle)\n            return dist,angle,frames[0]\n            \n        for i in range(1,len(frames)):\n            dist += distance(frames[i-1],frames[i])\n            angle += abs(angle_difference(frames[i-1],frames[i]))\n    \n        #print (\"angle---\",angle)\n        return dist,angle,frames[-1]\n    \n    #print (\"angle---\",angle)\n    return dist,angle,currentPos\n\n\n\n\n\n\n\n# Define the Objective functions\n# Objective Functions from https://machinelearningmastery.com/curve-fitting-with-python/\ndef objective(x, a, b):\n    return a * x + b\n\ndef objective2(x, a, b, c):\n    return a * x + b * x**2 + c\n\ndef objective3(x, a, b, c, d, e, f):\n    return (a * x) + (b * x**2) + (c * x**3) + (d * x**4) + (e * x**5) + f\n\ndef fit_to_objective(xdata,ydata,obj_fun = 0):\n\n    if obj_fun==0:\n        parameters, _ = curve_fit(objective, xdata, ydata)\n        a,b = parameters\n        x_line = np.arange(min(xdata), max(xdata), 1)\n        y_line = objective(x_line, a, b)\n    elif obj_fun==1:\n        parameters, _ = curve_fit(objective2, xdata, ydata)\n        a,b,c = parameters\n        x_line = np.arange(min(xdata), max(xdata), 1)\n        y_line = objective2(x_line, a, b, c)\n    elif obj_fun==2:\n        parameters, _ = curve_fit(objective3, xdata, ydata)\n        a, b, c, d, e, f = parameters\n        x_line = np.arange(min(xdata), max(xdata), 1)\n        y_line = objective3(x_line, a, b, c,d,e,f)\n    else:\n        x_line,y_line = [],[]\n    return x_line,y_line\n\n@app.route(\"/index\")\ndef index():\n    return (\"This is my Flask app\")\n\n@hops.component(\n    \"/sum\",\n    name=\"Sum\",\n    description=\"sum of numbers\",\n    inputs=[\n        hs.HopsNumber(\"A\", \"A\", \"First Number\"),\n        hs.HopsNumber(\"B\", \"B\", \"Second Number\")\n    ],\n    outputs=[\n        hs.HopsNumber(\"Sum\", \"Sum\", \"Sum of the numbers\")\n    ]\n)\ndef sum (a:float, b:float):\n    return a+b\n\n@hops.component(\n    \"/plotFit\",\n    name = \"Plt\",\n    description = \"This component plot the point and save the png files\",\n    inputs = [hs.HopsBoolean(\"Plot\",\"Plot\",\"True to Plot\",access=hs.HopsParamAccess.ITEM),\n              hs.HopsPoint(\"Points\",\"Points\",\"Points to plot\",access=hs.HopsParamAccess.LIST),\n              hs.HopsCurve(\"Curve\",\"Curve\",\"Fit curve to plot\",access=hs.HopsParamAccess.ITEM),\n              hs.HopsString(\"File Name\",\"File Name\",\"File Name\",access=hs.HopsParamAccess.ITEM)\n    ],\n    outputs=[hs.HopsBoolean(\"Success\",\"Success\",\"True if plotted False if error\",access=hs.HopsParamAccess.ITEM)\n    ]\n)\ndef plotFit(save,pts,crv,file_name):\n    X = [pt.X for pt in pts]\n    Y = [pt.Y for pt in pts]\n\n    crv.Domain = rh.Interval(0.00,1.00)\n    cX = []\n    cY = []\n    for i in range(len(pts)):\n        pt = crv.PointAt(i/len(pts))\n        cX.append(pt.X)\n        cY.append(pt.Y)\n    if save:\n        fig,ax = plt.subplots()\n        ax.plot(X, Y, 'o', label='data')\n        ax.plot(cX, cY, '-', label='fit')\n        ax.legend()\n        name = \"{}.png\".format(file_name)\n        fig.savefig(name)\n        return True\n    \n    return False\n\n@hops.component(\n    \"/fitCurve\",\n    name = \"fit\",\n    description = \"This component fit a curve to a set of points\",\n    inputs = [hs.HopsPoint(\"Points\",\"Points\",\"Points to plot\",access=hs.HopsParamAccess.LIST),\n              hs.HopsNumber(\"Objective\",\"Obj\",\"Objective Type\",access=hs.HopsParamAccess.ITEM)\n    ],\n    outputs=[hs.HopsBoolean(\"Success\",\"Success\",\"True if fitted curve\",access=hs.HopsParamAccess.ITEM),\n            hs.HopsCurve(\"fitCurve\",\"CRV\",\"Fitted curve\",access=hs.HopsParamAccess.ITEM)\n    ]\n)\ndef fitCurve(pts,obj):\n    X = [pt.X for pt in pts]\n    Y = [pt.Y for pt in pts]\n    Z = [pt.Z for pt in pts]\n\n    xdata = np.asarray(X)\n    ydata = np.asarray(Y)\n\n    x_line,y_line = fit_to_objective(xdata,ydata,obj_fun=obj)\n\n    newPoints = []\n    if len(x_line)>0:\n        for i in range(len(x_line)):\n            pt = rh.Point3d(x_line[i],y_line[i],0)\n            newPoints.append(pt)\n        crv = rh.Curve.CreateControlPointCurve(newPoints,1)\n        print (\"I'm here now\")\n        return True,crv\n    print (\"lol\")\n    crv = rh.Curve.CreateControlPointCurve(pts,1)\n    print (crv)\n    return False,crv\n\n@hops.component(\n    \"/savePoints\",\n    name = \"savePoints\",\n    description = \"This component save a list of points as json file\",\n    inputs = [hs.HopsPoint(\"Points\",\"Points\",\"Points to plot\",access=hs.HopsParamAccess.LIST)\n    ],\n    outputs=[hs.HopsBoolean(\"Success\",\"Success\",\"True if plotted False if error\",access=hs.HopsParamAccess.ITEM)\n    ]\n)\ndef savePoints(pts):\n    X = [pt.X for pt in pts]\n    Y = [pt.Y for pt in pts]\n    Z = [pt.Z for pt in pts]\n    \n    points_dict = {'X':X,'Y':Y,'Z':Z}\n    \n    file_path = 'points.json'\n\n\n    with open(file_path, 'w') as json_file:\n        json.dump(points_dict, json_file, indent=4)\n\n    print(f\"JSON file saved at: {file_path}\")\n        \n    return True\n\n@hops.component(\n    \"/predictPoint\",\n    name = \"predictPoint\",\n    description = \"This component predict a z value of a point on a surface\",\n    inputs = [hs.HopsPoint(\"Point\",\"Point\",\"Points to test\",access=hs.HopsParamAccess.ITEM)\n    ],\n    outputs=[hs.HopsPoint(\"Point\",\"Point\",\"Point with predicted Z value\",access=hs.HopsParamAccess.ITEM)\n    ]\n)\ndef predictPoint(pt):\n    X = pt.X \n    Y = pt.Y\n    new_data = np.array([[X,Y]])\n    prediction = loaded_model.predict(new_data)\n    new_pt = rh.Point3d(X,Y,prediction)\n    return new_pt\n\n\n@hops.component(\n    \"/tester\",\n    name = \"Tester\",\n    description = \"None\",\n    inputs = [hs.HopsString(\"data\",\"data\",\"data\",access=hs.HopsParamAccess.LIST),\n              hs.HopsString(\"model_name\",\"model\",\"model\",access=hs.HopsParamAccess.ITEM)],\n    outputs = [hs.HopsNumber(\"data\",\"data\",\"data\",access=hs.HopsParamAccess.LIST)]\n)\ndef tester(data,model_name):\n\n    new_data = []\n    \n    HOME = [2316.51,0.08,2961.99,-89.81,-44.85,-90.26]\n    current_pos = copy.deepcopy(HOME)\n    for d in data:\n        data_dict = json.loads(d)\n        \n        name = data_dict[\"type\"]\n        if \"clos\" in name.lower() : name=\"Closing\"\n        if \"init\" in name.lower():name = \"Initiate Tool\"\n        if \"place\" in name.lower(): name = \"Place\"\n        \n        new_dict = {\"names\":name}\n        actor_data = data_dict[\"actors_data\"][data_dict[\"main_actor\"]]\n        \n        new_dict[\"tools\"] = actor_data[\"toolname\"]\n        new_dict[\"operationCount\"] = actor_data[\"actioncount\"]\n        \n        \n        if actor_data[\"movementbasetype\"] == \"axis\":\n            frames = build_frames(actor_data[\"secondaryactionvalues\"])\n            dist,angle,current_pos = calculateTaskDistance(frames,None,current_pos)\n        else:\n            if actor_data[\"actionid\"]==1:\n                dist,angle,current_pos = calculateTaskDistance([HOME],None,current_pos)\n            elif actor_data[\"mainactionvalues\"]==None:\n                dist,angle,current_pos = 0,0,current_pos  \n            elif actor_data[\"secondaryactionvalues\"] != None:\n                frames,frames2 = build_frames(actor_data[\"mainactionvalues\"]),build_frames(actor_data[\"secondaryactionvalues\"])\n                dist,angle,current_pos = calculateTaskDistance(frames,frames2,current_pos)\n            else:\n                frames = build_frames(actor_data[\"mainactionvalues\"])\n                dist,angle,current_pos = calculateTaskDistance(frames,None,current_pos)\n        \n        dist = dist/10000\n        new_dict[\"subOperationDistance\"] = dist/actor_data[\"actioncount\"]\n        new_dict[\"totalDistance\"] = dist\n        new_dict[\"movementAngle\"] = angle\n        \n        new_data.append(new_dict)\n    \n        \n    data_dict = {key: []  for key, value in new_data[0].items()}\n    \n    for d in new_data:\n        dict = d\n        for key,value in dict.items():\n            data_dict[key].append(value)\n    \n    tool_map = {'Nail Gripper':1, 'Vaccuum Gripper':2, 'GlueGun':3}\n    task_map = {'Closing':1,'Gluing':2,'Initiate Tool':3,'Move':4,'Nail':5,'Pick':6,'Place':7,\n                'Spilling':8,'Storing':9,'Take Tool':10,'Travel':11}\n    \n    df = pd.DataFrame(data_dict)\n    df = df.map(lambda s: tool_map.get(s) if s in tool_map else s)\n    df = df.map(lambda s: task_map.get(s) if s in task_map else s)\n    \n    predictions = model_dict[model_name].predict(df)\n    results = [float(p) for p in predictions]\n    #print (results)\n    return (results)\n    \n    \n    return new_data\n\n@hops.component(\n    \"/predict_tester\",\n    name = \"PredictTester\",\n    description = \"None\",\n    inputs = [hs.HopsString(\"data\",\"data\",\"data\",access=hs.HopsParamAccess.LIST),\n              hs.HopsString(\"model_name\",\"model\",\"model\",access=hs.HopsParamAccess.ITEM)],\n    outputs = [hs.HopsNumber(\"data\",\"data\",\"data\",access=hs.HopsParamAccess.LIST)]\n)\ndef predict_tester(data,model_name):\n\n    tool_map = {'Nail Gripper':1, 'Vaccuum Gripper':2, 'GlueGun':3}\n    task_map = {'Closing':1,'Gluing':2,'Initiate Tool':3,'Move':4,'Nail':5,'Pick':6,'Place':7,\n                'Spilling':8,'Storing':9,'Take Tool':10,'Travel':11}\n    \n    dict = json.loads(data[0])\n    data_dict = {key: []  for key, value in dict.items()}\n    \n    for d in data:\n        dict = json.loads(d)\n        for key,value in dict.items():\n            data_dict[key].append(value)\n    \n    df = pd.DataFrame(data_dict)\n    df = df.map(lambda s: tool_map.get(s) if s in tool_map else s)\n    df = df.map(lambda s: task_map.get(s) if s in task_map else s)\n    \n    predictions = model_dict[model_name].predict(df)\n    results = [float(p) for p in predictions]\n    #print (results)\n    return (results)\n    \n    \n        \n\n\nif __name__ == \"__main__\":\n\n    app.run(debug=True)\n\n\n\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["surface", "point", "line", "curve", "functions"], "original_file": "LiorSkoury-git_ITECH_HopsExample_3f41e54689.json", "repo": "LiorSkoury-git/ITECH_HopsExample"}
{"instruction": "Returns the distance from a 3D point to a plane", "code": "\r\ndef DistanceToPlane(plane, point):\r\n    \"\"\"Returns the distance from a 3D point to a plane\r\n    Parameters:\r\n      plane (plane): the plane\r\n      point (point): List of 3 numbers or Point3d\r\n    Returns:\r\n      number: The distance if successful, otherwise None\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n      point = rs.GetPoint(\"Point to test\")\r\n      if point:\r\n      plane = rs.ViewCPlane()\r\n      if plane:\r\n      distance = rs.DistanceToPlane(plane, point)\r\n      if distance is not None:\r\n      print(\"Distance to plane: \", distance)\r\n    See Also:\r\n      Distance\r\n      PlaneClosestPoint\r\n    \"\"\"\r\n\r\n\r\n\r\ndef EvaluatePlane(plane, parameter):\r\n    \"\"\"Evaluates a plane at a U,V parameter\r\n    Parameters:\r\n      plane (plane): the plane to evaluate\r\n      parameter ([number, number]): list of two numbers defining the U,V parameter to evaluate\r\n    Returns:\r\n      point: Point3d on success\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n      view = rs.CurrentView()\r\n      plane = rs.ViewCPlane(view)\r\n      point = rs.EvaluatePlane(plane, (5,5))\r\n      rs.AddPoint( point )\r\n    See Also:\r\n      PlaneClosestPoint\r\n    \"\"\"\r\n\r\n\r\n\r\ndef IntersectPlanes(plane1, plane2, plane3):\r\n    \"\"\"Calculates the intersection of three planes\r\n    Parameters:\r\n      plane1 (plane): the 1st plane to intersect\r\n      plane2 (plane): the 2nd plane to intersect\r\n      plane3 (plane): the 3rd plane to intersect\r\n    Returns:\r\n      point: the intersection point between the 3 planes on success\r\n      None: on error\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n      plane1 = rs.WorldXYPlane()\r\n      plane2 = rs.WorldYZPlane()\r\n      plane3 = rs.WorldZXPlane()\r\n      point = rs.IntersectPlanes(plane1, plane2, plane3)\r\n      if point: rs.AddPoint(point)\r\n    See Also:\r\n      LineLineIntersection\r\n      LinePlaneIntersection\r\n      PlanePlaneIntersection\r\n    \"\"\"\r\n\r\n\r\n\r\ndef MovePlane(plane, origin):\r\n    \"\"\"Moves the origin of a plane\r\n    Parameters:\r\n      plane (plane): Plane or ConstructionPlane\r\n      origin (point): Point3d or list of three numbers\r\n    Returns:\r\n      plane: moved plane\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n      origin = rs.GetPoint(\"CPlane origin\")\r\n      if origin:\r\n      plane = rs.ViewCPlane()\r\n      plane = rs.MovePlane(plane,origin)\r\n      rs.ViewCplane(plane)\r\n    See Also:\r\n      PlaneFromFrame\r\n      PlaneFromNormal\r\n      RotatePlane\r\n    \"\"\"\r\n\r\n\r\n\r\ndef PlaneClosestPoint(plane, point, return_point=True):\r\n    \"\"\"Returns the point on a plane that is closest to a test point.\r\n    Parameters:\r\n      plane (plane): The plane\r\n      point (point): The 3-D point to test.\r\n      return_point (bool, optional): If omitted or True, then the point on the plane\r\n         that is closest to the test point is returned. If False, then the\r\n         parameter of the point on the plane that is closest to the test\r\n         point is returned.\r\n    Returns:\r\n      point: If return_point is omitted or True, then the 3-D point\r\n      point: If return_point is False, then an array containing the U,V parameters\r\n      of the point\r\n      None: if not successful, or on error.\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n      point = rs.GetPoint(\"Point to test\")\r\n      if point:\r\n      plane = rs.ViewCPlane()\r\n      if plane:\r\n      print(rs.PlaneClosestPoint(plane, point))\r\n    See Also:\r\n      DistanceToPlane\r\n      EvaluatePlane\r\n    \"\"\"\r\n\r\n\r\n\r\ndef PlaneCurveIntersection(plane, curve, tolerance=None):\r\n    \"\"\"Intersect an infinite plane and a curve object\r\n    Parameters:\r\n      plane (plane): The plane to intersect.\r\n      curve (guid): The identifier of the curve object\r\n      torerance (number, optional): The intersection tolerance. If omitted, the document's absolute tolerance is used.\r\n    Returns:\r\n      A list of intersection information tuple if successful.  The list will contain one or more of the following tuple:\r\n\r\n        Element Type        Description\r\n\r\n        [0]       Number      The intersection event type, either Point (1) or Overlap (2).\r\n\r\n        [1]       Point3d     If the event type is Point (1), then the intersection point on the curve.\r\n                            If the event type is Overlap (2), then intersection start point on the curve.\r\n\r\n        [2]       Point3d     If the event type is Point (1), then the intersection point on the curve.\r\n                            If the event type is Overlap (2), then intersection end point on the curve.\r\n\r\n        [3]       Point3d     If the event type is Point (1), then the intersection point on the plane.\r\n                            If the event type is Overlap (2), then intersection start point on the plane.\r\n\r\n        [4]       Point3d     If the event type is Point (1), then the intersection point on the plane.\r\n\r\n                            If the event type is Overlap (2), then intersection end point on the plane.\r\n\r\n        [5]       Number      If the event type is Point (1), then the curve parameter.\r\n                            If the event type is Overlap (2), then the start value of the curve parameter range.\r\n\r\n        [6]       Number      If the event type is Point (1), then the curve parameter.\r\n                            If the event type is Overlap (2),  then the end value of the curve parameter range.\r\n\r\n        [7]       Number      If the event type is Point (1), then the U plane parameter.\r\n                            If the event type is Overlap (2), then the U plane parameter for curve at (n, 5).\r\n\r\n        [8]       Number      If the event type is Point (1), then the V plane parameter.\r\n                            If the event type is Overlap (2), then the V plane parameter for curve at (n, 5).\r\n\r\n        [9]       Number      If the event type is Point (1), then the U plane parameter.\r\n                            If the event type is Overlap (2), then the U plane parameter for curve at (n, 6).\r\n\r\n        [10]      Number      If the event type is Point (1), then the V plane parameter.\r\n                            If the event type is Overlap (2), then the V plane parameter for curve at (n, 6).\r\n\r\n      None: on error\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n\r\n      curve = rs.GetObject(\"Select curve\", rs.filter.curve)\r\n      if curve:\r\n      plane = rs.WorldXYPlane()\r\n      intersections = rs.PlaneCurveIntersection(plane, curve)\r\n      if intersections:\r\n      for intersection in intersections:\r\n      rs.AddPoint(intersection[1])\r\n    See Also:\r\n      IntersectPlanes\r\n      PlanePlaneIntersection\r\n      PlaneSphereIntersection\r\n    \"\"\"\r\n\r\n\r\n\r\ndef PlaneEquation(plane):\r\n    \"\"\"Returns the equation of a plane as a tuple of four numbers. The standard\r\n    equation of a plane with a non-zero vector is Ax+By+Cz+D=0\r\n    Parameters:\r\n      plane (plane): the plane to deconstruct\r\n    Returns:\r\n      tuple(number, number, number, number): containing four numbers that represent the coefficients of the equation  (A, B, C, D) if successful\r\n      None: if not successful\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n      plane = rs.ViewCPlane()\r\n      equation = rs.PlaneEquation(plane)\r\n      print(\"A =\", equation[0])\r\n      print(\"B =\", equation[1])\r\n      print(\"C =\", equation[2])\r\n      print(\"D =\", equation[3])\r\n    See Also:\r\n      PlaneFromFrame\r\n      PlaneFromNormal\r\n      PlaneFromPoints\r\n    \"\"\"\r\n\r\n\r\n\r\ndef PlaneFitFromPoints(points):\r\n    \"\"\"Returns a plane that was fit through an array of 3D points.\r\n    Parameters:\r\n    points (point): An array of 3D points.\r\n    Returns:\r\n      plane: The plane if successful\r\n      None: if not successful\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n      points = rs.GetPoints()\r\n      if points:\r\n      plane = rs.PlaneFitFromPoints(points)\r\n      if plane:\r\n      magX = plane.XAxis.Length\r\n      magY = plane.YAxis.Length\r\n      rs.AddPlaneSurface( plane, magX, magY )\r\n    See Also:\r\n      PlaneFromFrame\r\n      PlaneFromNormal\r\n      PlaneFromPoints\r\n    \"\"\"\r\n\r\n\r\n\r\ndef PlaneFromFrame(origin, x_axis, y_axis):\r\n    \"\"\"Construct a plane from a point, and two vectors in the plane.\r\n    Parameters:\r\n      origin (point): A 3D point identifying the origin of the plane.\r\n      x_axis (vector): A non-zero 3D vector in the plane that determines the X axis\r\n               direction.\r\n      y_axis (vector): A non-zero 3D vector not parallel to x_axis that is used\r\n               to determine the Y axis direction. Note, y_axis does not\r\n               have to be perpendicular to x_axis.\r\n    Returns:\r\n      plane: The plane if successful.\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n      origin = rs.GetPoint(\"CPlane origin\")\r\n      if origin:\r\n      xaxis = (1,0,0)\r\n      yaxis = (0,0,1)\r\n      plane = rs.PlaneFromFrame( origin, xaxis, yaxis )\r\n      rs.ViewCPlane(None, plane)\r\n    See Also:\r\n      MovePlane\r\n      PlaneFromNormal\r\n      PlaneFromPoints\r\n      RotatePlane\r\n    \"\"\"\r\n\r\n\r\ndef PlaneFromNormal(origin, normal, xaxis=None):\r\n    \"\"\"Creates a plane from an origin point and a normal direction vector.\r\n    Parameters:\r\n      origin (point): A 3D point identifying the origin of the plane.\r\n      normal (vector): A 3D vector identifying the normal direction of the plane.\r\n      xaxis (vector, optional): optional vector defining the plane's x-axis\r\n    Returns:\r\n      plane: The plane if successful.\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n      origin = rs.GetPoint(\"CPlane origin\")\r\n      if origin:\r\n      direction = rs.GetPoint(\"CPlane direction\")\r\n      if direction:\r\n      normal = direction - origin\r\n      normal = rs.VectorUnitize(normal)\r\n      rs.ViewCPlane( None, rs.PlaneFromNormal(origin, normal) )\r\n    See Also:\r\n      MovePlane\r\n      PlaneFromFrame\r\n      PlaneFromPoints\r\n      RotatePlane\r\n    \"\"\"\r\n\r\n\r\ndef PlaneFromPoints(origin, x, y):\r\n    \"\"\"Creates a plane from three non-colinear points\r\n    Parameters:\r\n      origin (point): origin point of the plane\r\n      x, y (point): points on the plane's x and y axes\r\n    Returns:\r\n      plane: The plane if successful, otherwise None\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n      corners = rs.GetRectangle()\r\n      if corners:\r\n      rs.ViewCPlane( rs.PlaneFromPoints(corners[0], corners[1], corners[3]))\r\n    See Also:\r\n      PlaneFromFrame\r\n      PlaneFromNormal\r\n    \"\"\"\r\n\r\n\r\n\r\ndef PlanePlaneIntersection(plane1, plane2):\r\n    \"\"\"Calculates the intersection of two planes\r\n    Parameters:\r\n      plane1 (plane): the 1st plane to intersect\r\n      plane2 (plane): the 2nd plane to intersect\r\n    Returns:\r\n      line:  a line with two 3d points identifying the starting/ending points of the intersection\r\n      None: on error\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n      plane1 = rs.WorldXYPlane()\r\n      plane2 = rs.WorldYZPlane()\r\n      line = rs.PlanePlaneIntersection(plane1, plane2)\r\n      if line: rs.AddLine(line[0], line[1])\r\n    See Also:\r\n      IntersectPlanes\r\n      LineLineIntersection\r\n      LinePlaneIntersection\r\n    \"\"\"\r\n\r\n\r\n\r\ndef PlaneSphereIntersection(plane, sphere_plane, sphere_radius):\r\n    \"\"\"Calculates the intersection of a plane and a sphere\r\n    Parameters:\r\n      plane (plane): the plane to intersect\r\n      sphere_plane (plane): equatorial plane of the sphere. origin of the plane is\r\n        the center of the sphere\r\n      sphere_radius (number): radius of the sphere\r\n    Returns:\r\n      list(number, point|plane, number): of intersection results\r\n          Element    Type      Description\r\n          [0]       number     The type of intersection, where 0 = point and 1 = circle.\r\n          [1]   point or plane If a point intersection, the a Point3d identifying the 3-D intersection location.\r\n                               If a circle intersection, then the circle's plane. The origin of the plane will be the center point of the circle\r\n          [2]       number     If a circle intersection, then the radius of the circle.\r\n      None: on error\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n      plane = rs.WorldXYPlane()\r\n      radius = 10\r\n      results = rs.PlaneSphereIntersection(plane, plane, radius)\r\n      if results:\r\n      if results[0]==0:\r\n      rs.AddPoint(results[1])\r\n      else:\r\n      rs.AddCircle(results[1], results[2])\r\n    See Also:\r\n      IntersectPlanes\r\n      LinePlaneIntersection\r\n      PlanePlaneIntersection\r\n    \"\"\"\r\n\r\n\r\n\r\ndef PlaneTransform(plane, xform):\r\n    \"\"\"Transforms a plane\r\n    Parameters:\r\n      plane (plane): Plane to transform\r\n      xform (transform): Transformation to apply\r\n    Returns:\r\n      plane:the resulting plane if successful\r\n      None: if not successful\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n      plane = rs.ViewCPlane()\r\n      xform = rs.XformRotation(45.0, plane.Zaxis, plane.Origin)\r\n      plane = rs.PlaneTransform(plane, xform)\r\n      rs.ViewCPlane(None, plane)\r\n    See Also:\r\n      PlaneFromFrame\r\n      PlaneFromNormal\r\n      PlaneFromPoints\r\n    \"\"\"\r\n\r\n\r\n\r\ndef RotatePlane(plane, angle_degrees, axis):\r\n    \"\"\"Rotates a plane\r\n    Parameters:\r\n      plane (plane): Plane to rotate\r\n      angle_degrees (number): rotation angle in degrees\r\n      axis (vector): Axis of rotation or list of three numbers\r\n    Returns:\r\n      plane: rotated plane on success\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n      plane = rs.ViewCPlane()\r\n      rotated = rs.RotatePlane(plane, 45.0, plane.XAxis)\r\n      rs.ViewCPlane( None, rotated )\r\n    See Also:\r\n      MovePlane\r\n      PlaneFromFrame\r\n      PlaneFromNormal\r\n    \"\"\"\r\n\r\n\r\n\r\ndef WorldXYPlane():\r\n    \"\"\"Returns Rhino's world XY plane\r\n    Returns:\r\n      plane: Rhino's world XY plane\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n      view = rs.CurrentView()\r\n      rs.ViewCPlane( view, rs.WorldXYPlane() )\r\n    See Also:\r\n      WorldYZPlane\r\n      WorldZXPlane\r\n    \"\"\"\r\n\r\n\r\n\r\ndef WorldYZPlane():\r\n    \"\"\"Returns Rhino's world YZ plane\r\n    Returns:\r\n      plane: Rhino's world YZ plane\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n      view = rs.CurrentView()\r\n      rs.ViewCPlane( view, rs.WorldYZPlane() )\r\n    See Also:\r\n      WorldXYPlane\r\n      WorldZXPlane\r\n    \"\"\"\r\n\r\n\r\n\r\ndef WorldZXPlane():\r\n    \"\"\"Returns Rhino's world ZX plane\r\n    Returns:\r\n      plane: Rhino's world ZX plane\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n      view = rs.CurrentView()\r\n      rs.ViewCPlane( view, rs.WorldZXPlane() )\r\n    See Also:\r\n      WorldXYPlane\r\n      WorldYZPlane\r\n    \"\"\"\r\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "line", "curve", "functions"], "original_file": "MahmoudAbdelRahman_GH_CPython_10db0ba2a8.json", "repo": "MahmoudAbdelRahman/GH_CPython"}
{"instruction": "Finds the point on an infinite line that is closest to a test point", "code": "import Rhino\n\nimport scriptcontext\n\nimport rhinocompat as compat\nfrom rhinoscript import utility as rhutil\n\n\ndef LineClosestPoint(line, testpoint):\n    \"\"\"Finds the point on an infinite line that is closest to a test point\n    Parameters:\n      line ([point, point]): List of 6 numbers or 2 Point3d.  Two 3-D points identifying the starting and ending points of the line.\n      testpoint (point): List of 3 numbers or Point3d.  The test point.\n    Returns:\n      point: the point on the line that is closest to the test point if successful, otherwise None\n    Example:\n      import rhinoscriptsyntax as rs\n      line = (0,0,0), (5,5,0)\n      point = (15, 10, 0)\n      result = rs.LineClosestPoint( line, point)\n      if result: rs.AddPoint(result)\n    See Also:\n      LineIsFartherThan\n      LineMaxDistanceTo\n      LineMinDistanceTo\n      LinePlane\n      LineTransform\n    \"\"\"\n    line = rhutil.coerceline(line, True)\n    testpoint = rhutil.coerce3dpoint(testpoint, True)\n    return line.ClosestPoint(testpoint, False)\n\n\ndef LineCylinderIntersection(line, cylinder_plane, cylinder_height, cylinder_radius):\n    \"\"\"Calculates the intersection of a line and a cylinder\n    Parameters:\n      line (guid|line): the line to intersect\n      cylinder_plane (plane): base plane of the cylinder\n      cylinder_height (number): height of the cylinder\n      cylinder_radius (number): radius of the cylinder\n    Returns:\n      list(point, ...): list of intersection points (0, 1, or 2 points)\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.WorldXYPlane()\n      line = (-10,0,0), (10,0,10)\n      points = rs.LineCylinderIntersection(line, plane, cylinder_height=10, cylinder_radius=5)\n      if points:\n          for point in points: rs.AddPoint(point)\n    See Also:\n      LineLineIntersection\n      LinePlaneIntersection\n      LineSphereIntersection\n    \"\"\"\n    line = rhutil.coerceline(line, True)\n    cylinder_plane = rhutil.coerceplane(cylinder_plane, True)\n    circle = Rhino.Geometry.Circle( cylinder_plane, cylinder_radius )\n    if not circle.IsValid: raise ValueError(\"unable to create valid circle with given plane and radius\")\n    cyl = Rhino.Geometry.Cylinder( circle, cylinder_height )\n    if not cyl.IsValid: raise ValueError(\"unable to create valid cylinder with given circle and height\")\n    rc, pt1, pt2 = Rhino.Geometry.Intersect.Intersection.LineCylinder(line, cyl)\n    if rc==compat.ENUM_NONE(Rhino.Geometry.Intersect.LineCylinderIntersection):\n        return []\n    if rc==Rhino.Geometry.Intersect.LineCylinderIntersection.Single:\n        return [pt1]\n    return [pt1, pt2]\n\n\ndef LineIsFartherThan(line, distance, point_or_line):\n    \"\"\"Determines if the shortest distance from a line to a point or another\n    line is greater than a specified distance\n    Parameters:\n      line (line | [point, point]): List of 6 numbers, 2 Point3d, or Line.\n      distance (number): the distance\n      point_or_line (point|line) the test point or the test line\n    Returns:\n      bool: True if the shortest distance from the line to the other project is\n            greater than distance, False otherwise\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      line = (0,0,0), (10,10,0)\n      testPoint = (10,5,0)\n      print(rs.LineIsFartherThan(line, 3, testPoint))\n    See Also:\n      LineClosestPoint\n      LineMaxDistanceTo\n      LineMinDistanceTo\n      LinePlane\n      LineTransform\n    \"\"\"\n    line = rhutil.coerceline(line, True)\n    test = rhutil.coerceline(point_or_line)\n    if not test: test = rhutil.coerce3dpoint(point_or_line, True)\n    minDist = line.MinimumDistanceTo(test)\n    return minDist>distance\n\n\ndef LineLineIntersection(lineA, lineB):\n    \"\"\"Calculates the intersection of two non-parallel lines. Note, the two\n    lines do not have to intersect for an intersection to be found. (see help)\n    Parameters:\n      lineA, lineB (line): lines to intersect\n    Returns:\n      tuple(point, point): containing a point on the first line and a point on the second line if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      lineA = (1,1,0), (5,0,0)\n      lineB = (1,3,0), (5,5,0)\n      point = rs.LineLineIntersection(lineA, lineB)\n      if point:\n          rs.AddPoint(point[0])\n          rs.AddPoint(point[1])\n    See Also:\n      IntersectPlanes\n      LinePlaneIntersection\n      PlanePlaneIntersection\n    \"\"\"\n    lineA = rhutil.coerceline(lineA, True)\n    lineB = rhutil.coerceline(lineB, True)\n    rc, a, b = Rhino.Geometry.Intersect.Intersection.LineLine(lineA, lineB)\n    if not rc: return None\n    return lineA.PointAt(a), lineB.PointAt(b)\n\n\ndef LineMaxDistanceTo(line, point_or_line):\n    \"\"\"Finds the longest distance between a line as a finite chord, and a point\n    or another line\n    Parameters:\n      line (line | [point, point]): List of 6 numbers, two Point3d, or Line.\n      point_or_line (point|line): the test point or test line.\n    Returns:\n      number: A distance (D) such that if Q is any point on the line and P is any point on the other object, then D >= Rhino.Distance(Q, P).\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      line = (0,0,0), (10,10,0)\n      print(rs.LineMaxDistanceTo( line, (10,5,0) ))\n    See Also:\n      LineClosestPoint\n      LineIsFartherThan\n      LineMinDistanceTo\n      LinePlane\n      LineTransform\n    \"\"\"\n    line = rhutil.coerceline(line, True)\n    test = rhutil.coerceline(point_or_line)\n    if test is None: test = rhutil.coerce3dpoint(point_or_line, True)\n    return line.MaximumDistanceTo(test)\n\n\ndef LineMinDistanceTo(line, point_or_line):\n    \"\"\"Finds the shortest distance between a line as a finite chord, and a point\n    or another line\n    Parameters:\n      line (line | [point, point]): List of 6 numbers, two Point3d, or Line.\n      point_or_line (point|line): the test point or test line.\n    Returns:\n      number: A distance (D) such that if Q is any point on the line and P is any point on the other object, then D <= Rhino.Distance(Q, P).\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      line = (0,0,0), (10,10,0)\n      print(rs.LineMinDistanceTo(line, (10,5,0)))\n    See Also:\n      LineClosestPoint\n      LineIsFartherThan\n      LineMaxDistanceTo\n      LinePlane\n      LineTransform\n    \"\"\"\n    line = rhutil.coerceline(line, True)\n    test = rhutil.coerceline(point_or_line)\n    if test is None: test = rhutil.coerce3dpoint(point_or_line, True)\n    return line.MinimumDistanceTo(test)\n\n\ndef LinePlane(line):\n    \"\"\"Returns a plane that contains the line. The origin of the plane is at the start of\n    the line. If possible, a plane parallel to the world XY, YZ, or ZX plane is returned\n    Parameters:\n      line (line | [point, point]):  List of 6 numbers, two Point3d, or Line.\n    Returns:\n      plane: the plane if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      lineFrom = (0,0,0)\n      lineTo = (10,10,0)\n      distance = rs.Distance(lineFrom, lineTo)\n      plane = rs.LinePlane([lineFrom, lineTo])\n      rs.AddPlaneSurface( plane, distance, distance )\n    See Also:\n      LineClosestPoint\n      LineIsFartherThan\n      LineMaxDistanceTo\n      LineMinDistanceTo\n      LineTransform\n    \"\"\"\n    line = rhutil.coerceline(line, True)\n    rc, plane = line.TryGetPlane()\n    if not rc: return scriptcontext.errorhandler()\n    return plane\n\n\ndef LinePlaneIntersection(line, plane):\n    \"\"\"Calculates the intersection of a line and a plane.\n    Parameters:\n      line ([point, point]): Two 3D points identifying the starting and ending points of the line to intersect.\n      plane (plane): The plane to intersect.\n    Returns:\n      point: The 3D point of intersection is successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.WorldXYPlane()\n      line = (2, 11, 13), (20, 4, -10)\n      point = rs.LinePlaneIntersection(line, plane)\n      if( point!=None ): rs.AddPoint(point)\n    See Also:\n      LineLineIntersection\n      PlanePlaneIntersection\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    line_points = rhutil.coerce3dpointlist(line, True)\n    line = Rhino.Geometry.Line(line_points[0], line_points[1])\n    rc, t = Rhino.Geometry.Intersect.Intersection.LinePlane(line, plane) \n    if  not rc: return scriptcontext.errorhandler()\n    return line.PointAt(t)\n\n\ndef LineSphereIntersection(line, sphere_center, sphere_radius):\n    \"\"\"Calculates the intersection of a line and a sphere\n    Parameters:\n      line (line | [point, point]): the line\n      sphere_center (point): the center point of the sphere\n      sphere_radius (number): the radius of the sphere\n    Returns:\n      list(point, ...): list of intersection points if successful, otherwise None\n    Example:\n      import rhinoscriptsyntax as rs\n      radius = 10\n      line = (-10,0,0), (10,0,10)\n      points = rs.LineSphereIntersection(line, (0,0,0), radius)\n      if points:\n          for point in points: rs.AddPoint(point)\n    See Also:\n      LineCylinderIntersection\n      LineLineIntersection\n      LinePlaneIntersection\n    \"\"\"\n    line = rhutil.coerceline(line, True)\n    sphere_center = rhutil.coerce3dpoint(sphere_center, True)\n    sphere = Rhino.Geometry.Sphere(sphere_center, sphere_radius)\n    rc, pt1, pt2 = Rhino.Geometry.Intersect.Intersection.LineSphere(line, sphere)\n    if rc==compat.ENUM_NONE(Rhino.Geometry.Intersect.LineSphereIntersection): return []\n    if rc==Rhino.Geometry.Intersect.LineSphereIntersection.Single: return [pt1]\n    return [pt1, pt2]\n\n\ndef LineTransform(line, xform):\n    \"\"\"Transforms a line\n    Parameters:\n      line (guid): the line to transform\n      xform (transform): the transformation to apply\n    Returns:\n      guid: transformed line\n    Example:\n      import rhinoscriptsyntax as rs\n      line = (0,0,0), (10,10,0)\n      rs.AddLine( line[0], line[1] )\n      plane = rs.WorldXYPlane()\n      xform = rs.XformRotation(30, plane.Zaxis, plane.Origin)\n      line = rs.LineTransform(line, xform)\n      rs.AddLine( line.From, line.To )\n    See Also:\n      LineClosestPoint\n      LineIsFartherThan\n      LineMaxDistanceTo\n      LineMinDistanceTo\n      LinePlane\n    \"\"\"\n    line = rhutil.coerceline(line, True)\n    xform = rhutil.coercexform(xform, True)\n    success = line.Transform(xform)\n    if not success: raise Exception(\"unable to transform line\")\n    return line\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "line", "functions", "RhinoCommon"], "original_file": "McMuff86_rhinomcp_04108076ce.json", "repo": "McMuff86/rhinomcp"}
{"instruction": "Adds a new block definition to the document", "code": "import math\n\nimport System\n\nimport Rhino\n\nimport scriptcontext\n\nfrom rhinoscript import utility as rhutil\n\n\ndef __InstanceObjectFromId(id, raise_if_missing):\n    rhobj = rhutil.coercerhinoobject(id, True, raise_if_missing)\n    if isinstance(rhobj, Rhino.DocObjects.InstanceObject): return rhobj\n    if raise_if_missing: raise ValueError(\"unable to find InstanceObject\")\n\n\ndef AddBlock(object_ids, base_point, name=None, delete_input=False):\n    \"\"\"Adds a new block definition to the document\n    Parameters:\n      object_ids ([guid, ....]) objects that will be included in the block\n      base_point (point): 3D base point for the block definition\n      name (str, optional): name of the block definition. If omitted a name will be\n        automatically generated\n      delete_input (bool): if True, the object_ids will be deleted\n    Returns:\n      str: name of new block definition on success\n    Example:\n      import rhinoscriptsyntax as rs\n      objs = rs.GetObjects(\"Select objects to define block\")\n      if objs:\n          point = rs.GetPoint(\"Block base point\")\n          if point:\n              block = rs.AddBlock(objs, point, None, True)\n              rs.InsertBlock(block, point)\n    See Also:\n      InsertBlock\n    \"\"\"\n    base_point = rhutil.coerce3dpoint(base_point, True)\n    if not name:\n        name = scriptcontext.doc.InstanceDefinitions.GetUnusedInstanceDefinitionName()\n    found = scriptcontext.doc.InstanceDefinitions.Find(name)\n    objects = []\n    for id in object_ids:\n        obj = rhutil.coercerhinoobject(id, True)\n        if obj.IsReference: return\n        ot = obj.ObjectType\n        if ot==Rhino.DocObjects.ObjectType.Light: return\n        if ot==Rhino.DocObjects.ObjectType.Grip: return\n        if ot==Rhino.DocObjects.ObjectType.Phantom: return\n        if ot==Rhino.DocObjects.ObjectType.InstanceReference and found:\n            uses, nesting = obj.UsesDefinition(found.Index)\n            if uses: return\n        objects.append(obj)\n    if objects:\n        geometry = [obj.Geometry for obj in objects]\n        attrs = [obj.Attributes for obj in objects]\n        rc = 0\n        if found:\n          rc = scriptcontext.doc.InstanceDefinitions.ModifyGeometry(found.Index, geometry, attrs)\n        else:\n          rc = scriptcontext.doc.InstanceDefinitions.Add(name, \"\", base_point, geometry, attrs)\n        if rc>=0:\n            if delete_input:\n                for obj in objects: scriptcontext.doc.Objects.Delete(obj, True)\n            scriptcontext.doc.Views.Redraw()\n    return name\n\n\ndef BlockContainerCount(block_name):\n    \"\"\"Returns number of block definitions that contain a specified\n    block definition\n    Parameters:\n      block_name (str): the name of an existing block definition\n    Returns:\n      number: the number of block definitions that contain a specified block definition\n    Example:\n      import rhinoscriptscriptsyntax as rs\n      block = rs.GetString(\"Block name to query\")\n      if rs.IsBlock(block):\n          count = rs.BlockContainerCount(block)\n          print(\"This block is nested in {} block(s).\".format(count))\n    See Also:\n      BlockContainers\n      IsBlock\n    \"\"\"\n    return len(BlockContainers(block_name))\n\n\ndef BlockContainers(block_name):\n    \"\"\"Returns names of the block definitions that contain a specified block\n    definition.\n    Parameters:\n      block_name (str): the name of an existing block definition\n    Returns:\n      list(str, ...): A list of block definition names\n    Example:\n      import rhinoscriptsyntax as rs\n      blockname = rs.GetString(\"Block name to query\")\n      if rs.IsBlock(blockname):\n          blocks = rs.BlockContainers(blockname)\n          for block in blocks: print(block)\n    See Also:\n      BlockContainerCount\n      IsBlock\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    containers = idef.GetContainers()\n    rc = []\n    for item in containers:\n        if not item.IsDeleted: rc.append(item.Name)\n    return rc\n\n\ndef BlockCount():\n    \"\"\"Returns the number of block definitions in the document\n    Returns:\n      number: the number of block definitions in the document\n    Example:\n      import rhinoscriptsyntax as rs\n      count = rs.BlockCount()\n      print(\"There are {} blocks\".format(count)\n    See Also:\n      BlockNames\n      IsBlock\n    \"\"\"\n    return scriptcontext.doc.InstanceDefinitions.ActiveCount\n\n\ndef BlockDescription(block_name, description=None):\n    \"\"\"Returns or sets the description of a block definition\n    Parameters:\n      block_name (str): the name of an existing block definition\n      description (str, optional): The new description.\n    Returns:\n      str: if description is not specified, the current description\n      str: if description is specified, the previous description\n    Example:\n      import rhinoscriptsyntax as rs\n      blockname = rs.GetString(\"Block name to list description\")\n      if rs.IsBlock(blockname):\n          desc = rs.BlockDescription(blockname)\n          if desc is None: print(\"No description\")\n          else: print(desc)\n    See Also:\n      IsBlock\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    rc = idef.Description\n    if description: scriptcontext.doc.InstanceDefinitions.Modify( idef, idef.Name, description, True )\n    return rc\n\n\ndef BlockInstanceCount(block_name,where_to_look=0):\n    \"\"\"Counts number of instances of the block in the document.\n    Nested instances are not included in the count.\n    Parameters:\n      block_name (str): the name of an existing block definition\n      where_to_look (number, optional):\n        0 = get top level references in active document.\n        1 = get top level and nested references in active document.\n        2 = check for references from other instance definitions\n    Returns:\n      number: the number of instances of the block in the document\n    Example:\n      import rhinoscriptsyntax as rs\n      blockname = rs.GetString(\"Block to count\")\n      if rs.IsBlock(blockname):\n          count = rs.BlockInstanceCount(blockname)\n          print(\"{} block(s) found.\".format(count))\n    See Also:\n      BlockInstanceInsertPoint\n      BlockInstances\n      BlockInstanceXform\n      IsBlockInstance\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    refs = idef.GetReferences(where_to_look)\n    return len(refs)\n\n\ndef BlockInstanceInsertPoint(object_id):\n    \"\"\"Returns the insertion point of a block instance.\n    Parameters:\n      object_id (guid): The identifier of an existing block insertion object\n    Returns:\n      point: The insertion 3D point if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      strObject = rs.GetObject(\"Select block\")\n      if rs.IsBlockInstance(strObject):\n          rs.AddPoint( rs.BlockInstanceInsertPoint(strObject) )\n    See Also:\n      BlockInstanceCount\n      BlockInstances\n      BlockInstanceXform\n      IsBlockInstance\n    \"\"\"\n    instance = __InstanceObjectFromId(object_id, True)\n    xf = instance.InstanceXform\n    pt = Rhino.Geometry.Point3d.Origin\n    pt.Transform(xf)\n    return pt\n\n\ndef BlockInstanceName(object_id):\n    \"\"\"Returns the block name of a block instance\n    Parameters:\n      object_id (guid): The identifier of an existing block insertion object\n    Returns:\n      str: the block name of a block instance\n    Example:\n      import rhinoscriptsyntax as rs\n      strObject = rs.GetObject(\"Select block\")\n      if rs.IsBlockInstance(strObject):\n          print(rs.BlockInstanceName(strObject))\n    See Also:\n      BlockInstanceCount\n      BlockInstances\n      BlockInstanceXform\n      IsBlockInstance\n    \"\"\"\n    instance = __InstanceObjectFromId(object_id, True)\n    idef = instance.InstanceDefinition\n    return idef.Name\n\n\ndef BlockInstances(block_name,where_to_look=0):\n    \"\"\"Returns the identifiers of the inserted instances of a block.\n    Parameters:\n      block_name (str): the name of an existing block definition\n      where_to_look (number, optional):\n        0 = get top level references in active document.\n        1 = get top level and nested references in active document.\n        2 = check for references from other instance definitions\n    Returns:\n      list(guid, ...): Ids identifying the instances of a block in the model.\n    Example:\n      import rhinoscriptsyntax as rs\n      strBlock = rs.GetString(\"Block to select\")\n      if rs.IsBlock(strBlock):\n          arrObjects = rs.BlockInstances(strBlock)\n          if arrobjects:\n              rs.SelectObjects(arrObjects)\n    See Also:\n      BlockInstanceCount\n      BlockInstanceInsertPoint\n      BlockInstanceXform\n      IsBlockInstance\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    instances = idef.GetReferences(where_to_look)\n    return [item.Id for item in instances]\n\n\ndef BlockInstanceXform(object_id):\n    \"\"\"Returns the location of a block instance relative to the world coordinate\n    system origin (0,0,0). The position is returned as a 4x4 transformation\n    matrix\n    Parameters:\n      object_id (guid): The identifier of an existing block insertion object\n    Returns:\n      transform: the location, as a transform matrix, of a block instance relative to the world coordinate\n    system origin\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select block to query\")\n      if rs.IsBlockInstance(obj):\n          arrMatrix = rs.BlockInstanceXform(obj)\n          if arrMatrix is not None:\n              pointId = rs.AddPoint([0,0,0])\n              rs.TransformObject( pointId, arrMatrix)\n    See Also:\n      BlockInstanceCount\n      BlockInstanceInsertPoint\n      BlockInstances\n      IsBlockInstance\n    \"\"\"\n    instance = __InstanceObjectFromId(object_id, True)\n    return instance.InstanceXform\n\n\ndef BlockNames( sort=False ):\n    \"\"\"Returns the names of all block definitions in the document\n    Parameters:\n      sort (bool): True to return a sorted list\n    Returns:\n      list(str, ...): the names of all block definitions in the document\n    Example:\n      import rhinoscriptsyntax as rs\n      names = rs.BlockNames(True)\n      if names:\n          for name in names: print(name)\n    See Also:\n      BlockCount\n      IsBlock\n    \"\"\"\n    ideflist = scriptcontext.doc.InstanceDefinitions.GetList(True)\n    rc = [item.Name for item in ideflist]\n    if(sort): rc.sort()\n    return rc\n\n\ndef BlockObjectCount(block_name):\n    \"\"\"Returns number of objects that make up a block definition\n    Parameters:\n      block_name (str): name of an existing block definition\n    Returns:\n      number: the number of objects that make up a block definition\n    Example:\n      import rhinoscriptsyntax as rs\n      count = rs.BlockObjectCount()\n      print(\"There are {} blocks\".format(count))\n    See Also:\n      BlockNames\n      BlockObjects\n      IsBlock\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    return idef.ObjectCount\n\n\ndef BlockObjects(block_name):\n    \"\"\"Returns identifiers of the objects that make up a block definition\n    Parameters:\n      block_name (str): name of an existing block definition\n    Returns:\n      list(guid, ...): list of identifiers on success\n    Example:\n      import rhinoscriptsyntax as rs\n      strBlock = rs.GetString(\"Block name to list identifiers\")\n      if rs.IsBlock(strBlock):\n          objects = rs.BlockObjects(strBlock)\n          if objects:\n              for item in objects: print(item)\n    See Also:\n      BlockNames\n      BlockObjectCount\n      IsBlock\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    rhobjs = idef.GetObjects()\n    return [obj.Id for obj in rhobjs]\n\n\ndef BlockPath(block_name):\n    \"\"\"Returns path to the source of a linked or embedded block definition.\n    A linked or embedded block definition is a block definition that was\n    inserted from an external file.\n    Parameters:\n      block_name (str): name of an existing block definition\n    Returns:\n      str: path to the linked block on success\n    Example:\n      import rhinoscriptsyntax as rs\n      strBlock = rs.GetString(\"Block name to list path\")\n      if rs.IsBlockEmbedded(strBlock):\n          print(rs.BlockPath(strBlock))\n    See Also:\n      IsBlock\n      IsBlockEmbedded\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    return idef.SourceArchive\n\n\ndef BlockStatus(block_name):\n    \"\"\"Returns the status of a linked block\n    Parameters:\n        block_name (str): Name of an existing block\n    Returns:\n      number: the status of a linked block\n        Value Description\n        -3    Not a linked block definition.\n        -2    The linked block definition's file could not be opened or could not be read.\n        -1    The linked block definition's file could not be found.\n         0    The linked block definition is up-to-date.\n         1    The linked block definition's file is newer than definition.\n         2    The linked block definition's file is older than definition.\n         3    The linked block definition's file is different than definition.\n    Example:\n      import rhinoscriptsyntax as rs\n      block = rs.GetString(\"Block name to list description\")\n      if rs.IsBlock(block):\n          status = rs.BlockStatus(block)\n          print(\"block status for {} is {}\".format(block, status))\n    See Also:\n      IsBlock\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: return -3\n    return int(idef.ArchiveFileStatus)\n\n\ndef DeleteBlock(block_name):\n    \"\"\"Deletes a block definition and all of it's inserted instances.\n    Parameters:\n      block_name (str): name of an existing block definition\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      strBlock = rs.GetString(\"Block name to delete\")\n      if rs.IsBlock(strBlock):\n          rs.DeleteBlock(strBlock)\n    See Also:\n      BlockNames\n      ExplodeBlockInstance\n      IsBlock\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    rc = scriptcontext.doc.InstanceDefinitions.Delete(idef.Index, True, False)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ExplodeBlockInstance(object_id, explode_nested_instances=False):\n    \"\"\"Explodes a block instance into it's geometric components. The\n    exploded objects are added to the document\n    Parameters:\n      object_id (guid): The identifier of an existing block insertion object\n      explode_nested_instances (bool, optional): By default nested blocks are not exploded.\n    Returns:\n      list(guid, ...): identifiers for the newly exploded objects on success\n    Example:\n      import rhinoscriptsyntax as rs\n      strObject = rs.GetObject(\"Select block instance to explode\")\n      if rs.IsBlockInstance(strObject):\n          rs.ExplodeBlockInstance(strObject)\n    See Also:\n      DeleteBlock\n      IsBlockInstance\n    \"\"\"\n    instance = __InstanceObjectFromId(object_id, True)\n    guids = scriptcontext.doc.Objects.AddExplodedInstancePieces(instance, explodeNestedInstances=explode_nested_instances, deleteInstance=True)\n    if guids:\n      scriptcontext.doc.Views.Redraw()\n    return guids\n\n\ndef InsertBlock( block_name, insertion_point, scale=(1,1,1), angle_degrees=0, rotation_normal=(0,0,1) ):\n    \"\"\"Inserts a block whose definition already exists in the document\n    Parameters:\n      block_name (str): name of an existing block definition\n      insertion_point (point): insertion point for the block\n      scale ({number, number, number]): x,y,z scale factors\n      angle_degrees (number, optional): rotation angle in degrees\n      rotation_normal (vector, optional): the axis of rotation.\n    Returns:\n      guid: id for the block that was added to the doc\n    Example:\n    See Also:\n    \"\"\"\n    insertion_point = rhutil.coerce3dpoint(insertion_point, True)\n    rotation_normal = rhutil.coerce3dvector(rotation_normal, True)\n    angle_radians = math.radians(angle_degrees)\n    trans = Rhino.Geometry.Transform\n    move = trans.Translation(insertion_point[0],insertion_point[1],insertion_point[2])\n    scale = trans.Scale(Rhino.Geometry.Plane.WorldXY, scale[0], scale[1], scale[2])\n    rotate = trans.Rotation(angle_radians, rotation_normal, Rhino.Geometry.Point3d.Origin)\n    xform = move * scale * rotate\n    return InsertBlock2( block_name, xform )\n\n\ndef InsertBlock2(block_name, xform):\n    \"\"\"Inserts a block whose definition already exists in the document\n    Parameters:\n      block_name (str): name of an existing block definition\n      xform (transform): 4x4 transformation matrix to apply\n    Returns:\n      guid: id for the block that was added to the doc on success\n    Example:\n    See Also:\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    xform = rhutil.coercexform(xform, True)\n    id = scriptcontext.doc.Objects.AddInstanceObject(idef.Index, xform )\n    if id!=System.Guid.Empty:\n        scriptcontext.doc.Views.Redraw()\n        return id\n\n\ndef IsBlock(block_name):\n    \"\"\"Verifies the existence of a block definition in the document.\n    Parameters:\n      block_name (str): name of an existing block definition\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      strBlock = rs.GetString(\"Block name\")\n      if rs.IsBlock(strBlock):\n          print(\"The block definition exists.\")\n      else:\n          print(\"The block definition does not exist.\")\n    See Also:\n      IsBlockEmbedded\n      IsBlockInstance\n      IsBlockInUse\n      IsBlockReference\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    return (idef is not None)\n\n\ndef IsBlockEmbedded(block_name):\n    \"\"\"Verifies a block definition is embedded, or linked, from an external file.\n    Parameters:\n      block_name (str): name of an existing block definition\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      strBlock = rs.GetString(\"Block name\")\n      if rs.IsBlock(strBlock):\n          if rs.IsBlockEmbedded(strBlock):\n              print(\"The block definition is embedded.\")\n          else:\n              print(\"The block definition is not embedded.\")\n      else:\n          print(\"The block definition does not exist.\")\n    See Also:\n      IsBlock\n      IsBlockInstance\n      IsBlockInUse\n      IsBlockReference\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    ut = Rhino.DocObjects.InstanceDefinitionUpdateType\n    return (idef.UpdateType==ut.Embedded or idef.UpdateType==ut.Static or idef.UpdateType==ut.LinkedAndEmbedded)\n\n\ndef IsBlockInstance(object_id):\n    \"\"\"Verifies an object is a block instance\n    Parameters:\n      object_id (guid): The identifier of an existing block insertion object\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select block instance\")\n      if rs.IsBlockInstance(obj):\n          print(\"The object is a block instance.\")\n      else:\n          print(\"The object is not a block instance.\")\n    See Also:\n      IsBlock\n      IsBlockEmbedded\n      IsBlockInUse\n      IsBlockReference\n    \"\"\"\n    return  __InstanceObjectFromId(object_id, False) is not None\n\n\ndef IsBlockInUse(block_name, where_to_look=0):\n    \"\"\"Verifies that a block definition is being used by an inserted instance\n    Parameters:\n      block_name (str): name of an existing block definition\n      where_to_look (number, optional): One of the following values\n           0 = Check for top level references in active document\n           1 = Check for top level and nested references in active document\n           2 = Check for references in other instance definitions\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      strBlock = rs.GetString(\"Block name\")\n      if rs.IsBlock(strBlock):\n          if rs.IsBlockInUse(strBlock):\n              print(\"The block definition is in use.\")\n          else:\n              print(\"The block definition is not in use.\")\n      else:\n          print(\"The block definition does not exist.\")\n    See Also:\n      IsBlock\n      IsBlockInstance\n      IsBlockEmbedded\n      IsBlockReference\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    return idef.InUse(where_to_look)\n\n\ndef IsBlockReference(block_name):\n    \"\"\"Verifies that a block definition is from a reference file.\n    Parameters:\n      block_name (str): name of an existing block definition\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      strBlock = rs.GetString(\"Block name\")\n      if rs.IsBlock(strBlock):\n          if rs.IsBlockReference(strBlock):\n              print(\"The block definition is a reference definition.\")\n          else:\n              print(\"The block definition is not a reference definition.\")\n      else:\n          print(\"The block definition does not exist.\")\n    See Also:\n      IsBlock\n      IsBlockEmbedded\n      IsBlockInUse\n      IsBlockInstance\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    return idef.IsReference\n\n\ndef RenameBlock( block_name, new_name ):\n    \"\"\"Renames an existing block definition\n    Parameters:\n      block_name (str): name of an existing block definition\n      new_name (str): name to change to\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      strOldBlock = rs.GetString(\"Old block name\")\n      if strOldBlock:\n          strNewBlock = rs.GetString(\"New block name\")\n          if strNewBlock:\n              rs.RenameBlock (strOldBlock, strNewBlock)\n    See Also:\n      BlockNames\n      IsBlock\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    description = idef.Description\n    rc = scriptcontext.doc.InstanceDefinitions.Modify(idef, new_name, description, False)\n    return rc\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "point", "functions", "block", "RhinoCommon"], "original_file": "McMuff86_rhinomcp_1e169170ac.json", "repo": "McMuff86/rhinomcp"}
{"instruction": "Enables or disables an object's grips. For curves and surfaces, these are", "code": "import Rhino\n\nimport scriptcontext\n\nimport rhinocompat as compat\nfrom rhinoscript import utility as rhutil\n\n\ndef __neighborgrip(i, object_id, index, direction, enable):\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    grips = rhobj.GetGrips()\n    if not grips or len(grips)<=index: return scriptcontext.errorhandler()\n    grip = grips[index]\n    next_grip=None\n    if direction==0:\n        next_grip = grip.NeighborGrip(i,0,0,False)\n    else:\n        next_grip = grip.NeighborGrip(0,i,0,False)\n    if next_grip and enable:\n        next_grip.Select(True)\n        scriptcontext.doc.Views.Redraw()\n    return next_grip\n\n\ndef EnableObjectGrips(object_id, enable=True):\n    \"\"\"Enables or disables an object's grips. For curves and surfaces, these are\n    also called control points.\n    Parameters:\n      object_id (guid): identifier of the object\n      enable (bool, optional): if True, the specified object's grips will be turned on.\n        Otherwise, they will be turned off\n    Returns:\n      bool: True on success, False on failure\n    Example:\n      import rhinoscriptsyntax as  rs\n      objects = rs.GetObjects(\"Select  objects\")\n      if objects: [rs.EnableObjectGrips(obj)  for obj in objs]\n    See Also:\n      ObjectGripCount\n      ObjectGripsOn\n      ObjectGripsSelected\n      SelectObjectGrips\n      UnselectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if enable!=rhobj.GripsOn:\n        rhobj.GripsOn = enable\n        scriptcontext.doc.Views.Redraw()\n\n\ndef GetObjectGrip(message=None, preselect=False, select=False):\n    \"\"\"Prompts the user to pick a single object grip\n    Parameters:\n      message (str, optional): prompt for picking\n      preselect (bool, optional): allow for selection of pre-selected object grip.\n      select (bool, optional): select the picked object grip.\n    Returns:\n      tuple(guid, number, point): defining a grip record.\n         [0] = identifier of the object that owns the grip\n         [1] = index value of the grip\n         [2] = location of the grip\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if curve:\n          rs.EnableObjectGrips( curve )\n          grip = rs.GetObjectGrip(\"Select a curve grip\")\n          if grip: print(grip[2])\n    See Also:\n      GetObjectGrips\n    \"\"\"\n    if not preselect:\n        scriptcontext.doc.Objects.UnselectAll()\n        scriptcontext.doc.Views.Redraw()\n    rc, grip = Rhino.Input.RhinoGet.GetGrip(message)\n    if rc!=Rhino.Commands.Result.Success: return scriptcontext.errorhandler()\n    if select:\n        grip.Select(True, True)\n        scriptcontext.doc.Views.Redraw()\n    return grip.OwnerId, grip.Index, grip.CurrentLocation\n\n\ndef GetObjectGrips(message=None, preselect=False, select=False):\n    \"\"\"Prompts user to pick one or more object grips from one or more objects.\n    Parameters:\n      message (str, optional): prompt for picking\n      preselect (bool, optional): allow for selection of pre-selected object grips\n      select (bool, optional) select the picked object grips\n    Returns:\n      list((guid, number, point), ...): containing one or more grip records. Each grip record is a tuple\n        [n][0] = identifier of the object that owns the grip\n        [n][1] = index value of the grip\n        [n][2] = location of the grip\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curves = rs.GetObjects(\"Select curves\", rs.filter.curves)\n      if curves:\n          for curve in curves: rs.EnableObjectGrips(curve)\n          grips = rs.GetObjectGrips(\"Select curve grips\")\n          if grips: for grip in grips: print(grip[0])\n    See Also:\n      GetObjectGrip\n    \"\"\"\n    if not preselect:\n        scriptcontext.doc.Objects.UnselectAll()\n        scriptcontext.doc.Views.Redraw()\n    getrc, grips = Rhino.Input.RhinoGet.GetGrips(message)\n    if getrc!=Rhino.Commands.Result.Success or not grips:\n        return scriptcontext.errorhandler()\n    rc = []\n    for grip in grips:\n        id = grip.OwnerId\n        index = grip.Index\n        location = grip.CurrentLocation\n        rc.append((id, index, location))\n        if select: grip.Select(True, True)\n    if select: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef NextObjectGrip(object_id, index, direction=0, enable=True):\n    \"\"\"Returns the next grip index from a specified grip index of an object\n    Parameters:\n      object_id (guid): identifier of the object\n      index (number): zero based grip index from which to get the next grip index\n      direction ([number, number], optional): direction to get the next grip index (0=U, 1=V)\n      enable (bool, optional): if True, the next grip index found will be selected\n    Returns:\n      number: index of the next grip on success\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      object_id = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if object_id:\n          rs.EnableObjectGrips( object_id )\n          count = rs.ObjectGripCount( object_id )\n          for i in range(0,count,2):\n              rs.NextObjectGrip(object_id, i, 0, True)\n    See Also:\n      EnableObjectGrips\n      PrevObjectGrip\n    \"\"\"\n    return __neighborgrip(1, object_id, index, direction, enable)\n\n\ndef ObjectGripCount(object_id):\n    \"\"\"Returns number of grips owned by an object\n    Parameters:\n      object_id (guid): identifier of the object\n    Returns:\n      number: number of grips if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select object\")\n      if rs.ObjectGripsOn(obj):\n          print(\"Grip count ={}\".format(rs.ObjectGripCount(obj)))\n    See Also:\n      EnableObjectGrips\n      ObjectGripsOn\n      ObjectGripsSelected\n      SelectObjectGrips\n      UnselectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    grips = rhobj.GetGrips()\n    if not grips: return scriptcontext.errorhandler()\n    return grips.Length\n\n\ndef ObjectGripLocation(object_id, index, point=None):\n    \"\"\"Returns or modifies the location of an object's grip\n    Parameters:\n      object_id (guid) identifier of the object\n      index (number): index of the grip to either query or modify\n      point (point, optional): 3D point defining new location of the grip\n    Returns:\n      point: if point is not specified, the current location of the grip referenced by index\n      point: if point is specified, the previous location of the grip referenced by index\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if obj:\n          rs.EnableObjectGrips(obj)\n          point = rs.ObjectGripLocation(obj, 0)\n          point[0] = point[0] + 1.0\n          point[1] = point[1] + 1.0\n          point[2] = point[2] + 1.0\n          rs.ObjectGripLocation(obj, 0, point)\n          rs.EnableObjectGrips(obj, False)\n    See Also:\n      EnableObjectGrips\n      ObjectGripLocations\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return scriptcontext.errorhandler()\n    grips = rhobj.GetGrips()\n    if not grips or index<0 or index>=grips.Length:\n        return scriptcontext.errorhandler()\n    grip = grips[index]\n    rc = grip.CurrentLocation\n    if point:\n        grip.CurrentLocation = rhutil.coerce3dpoint(point, True)\n        scriptcontext.doc.Objects.GripUpdate(rhobj, True)\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ObjectGripLocations(object_id, points=None):\n    \"\"\"Returns or modifies the location of all grips owned by an object. The\n    locations of the grips are returned in a list of Point3d with each position\n    in the list corresponding to that grip's index. To modify the locations of\n    the grips, you must provide a list of points that contain the same number\n    of points at grips\n    Parameters:\n      object_id (guid): identifier of the object\n      points ([point, ...], optional) list of 3D points identifying the new grip locations\n    Returns:\n      list(point, ...): if points is not specified, the current location of all grips\n      list(point, ...): if points is specified, the previous location of all grips\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if obj:\n          rs.EnableObjectGrips( obj )\n          points = rs.ObjectGripLocations(obj)\n          for point in points:  print(point)\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      ObjectGripLocation\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return scriptcontext.errorhandler()\n    grips = rhobj.GetGrips()\n    if grips is None: return scriptcontext.errorhandler()\n    rc = [grip.CurrentLocation for grip in grips]\n    if points and len(points)==len(grips):\n        points = rhutil.coerce3dpointlist(points, True)\n        for i, grip in enumerate(grips):\n            point = points[i]\n            grip.CurrentLocation = point\n        scriptcontext.doc.Objects.GripUpdate(rhobj, True)\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ObjectGripsOn(object_id):\n    \"\"\"Verifies that an object's grips are turned on\n    Parameters:\n      object_id (guid): identifier of the object\n    Returns:\n      bool: True or False indicating Grips state\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select object\")\n      if rs.ObjectGripsOn(obj):\n          print(\"Grip count = {}\".format(rs.ObjectGripCount(obj)))\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      ObjectGripsSelected\n      SelectObjectGrips\n      UnselectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    return rhobj.GripsOn\n\n\ndef ObjectGripsSelected(object_id):\n    \"\"\"Verifies that an object's grips are turned on and at least one grip\n    is selected\n    Parameters:\n      object_id (guid): identifier of the object\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select object\")\n      if rs.ObjectGripsSelected(obj):\n          rs.UnselectObjectGrips( obj )\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      ObjectGripsOn\n      SelectObjectGrips\n      UnselectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return False\n    grips = rhobj.GetGrips()\n    if grips is None: return False\n    for grip in grips:\n        if grip.IsSelected(False): return True\n    return False\n\n\ndef PrevObjectGrip(object_id, index, direction=0, enable=True):\n    \"\"\"Returns the previous grip index from a specified grip index of an object\n    Parameters:\n      object_id (guid): identifier of the object\n      index (number): zero based grip index from which to get the previous grip index\n      direction ([number, number], optional): direction to get the next grip index (0=U, 1=V)\n      enable (bool, optional): if True, the next grip index found will be selected\n    Returns:\n      number: index of the next grip on success\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      object_id = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if object_id:\n          rs.EnableObjectGrips(object_id)\n          count = rs.ObjectGripCount(object_id)\n          for i in range(count-1, 0, -2):\n              rs.PrevObjectGrip(object_id, i, 0, True)\n    See Also:\n      EnableObjectGrips\n      NextObjectGrip\n    \"\"\"\n    return __neighborgrip(-1, object_id, index, direction, enable)\n\n\ndef SelectedObjectGrips(object_id):\n    \"\"\"Returns a list of grip indices indentifying an object's selected grips\n    Parameters:\n      object_id (guid): identifier of the object\n    Returns:\n      list(number): list of indices on success\n      None: on failure or if no grips are selected\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if obj:\n          rs.EnableObjectGrips( obj )\n          count = rs.ObjectGripCount( obj )\n          for i in range(0,count,2):\n              rs.SelectObjectGrip( obj, i )\n          grips = rs.SelectedObjectGrips(obj)\n          if grips: print(len(grips{}).format(\"grips selected\"))\n    See Also:\n      EnableObjectGrips\n      SelectObjectGrip\n      SelectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return None\n    grips = rhobj.GetGrips()\n    rc = []\n    if grips:\n        for i in compat.RANGE(grips.Length):\n            if grips[i].IsSelected(False): rc.append(i)\n    return rc\n\n\ndef SelectObjectGrip(object_id, index):\n    \"\"\"Selects a single grip owned by an object. If the object's grips are\n    not turned on, the grips will not be selected\n    Parameters:\n      object_id (guid) identifier of the object\n      index (number): index of the grip to select\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if obj:\n          rs.EnableObjectGrips( obj )\n          count = rs.ObjectGripCount( obj )\n          for i in range(0,count,2): rs.SelectObjectGrip(obj,i)\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      SelectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return False\n    grips = rhobj.GetGrips()\n    if grips is None: return False\n    if index<0 or index>=grips.Length: return False\n    grip = grips[index]\n    if grip.Select(True,True)>0:\n        scriptcontext.doc.Views.Redraw()\n        return True\n    return False\n\n\ndef SelectObjectGrips(object_id):\n    \"\"\"Selects an object's grips. If the object's grips are not turned on,\n    they will not be selected\n    Parameters:\n      object_id (guid): identifier of the object\n    Returns:\n      number: Number of grips selected on success\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select object\")\n      if rs.ObjectGripsSelected(obj)==False:\n          rs.SelectObjectGrips( obj )\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      SelectObjectGrip\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return scriptcontext.errorhandler()\n    grips = rhobj.GetGrips()\n    if grips is None: return scriptcontext.errorhandler()\n    count = 0\n    for grip in grips:\n        if grip.Select(True,True)>0: count+=1\n    if count>0:\n        scriptcontext.doc.Views.Redraw()\n        return count\n    return scriptcontext.errorhandler()\n\n\ndef UnselectObjectGrip(object_id, index):\n    \"\"\"Unselects a single grip owned by an object. If the object's grips are\n    not turned on, the grips will not be unselected\n    Parameters:\n      object_id (guid): identifier of the object\n      index (number): index of the grip to unselect\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if obj:\n          rs.EnableObjectGrips( obj )\n          count = rs.ObjectGripCount(obj)\n          for i in range(0,count,2):\n              rs.UnselectObjectGrip( obj, i )\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      UnselectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return False\n    grips = rhobj.GetGrips()\n    if grips is None: return False\n    if index<0 or index>=grips.Length: return False\n    grip = grips[index]\n    if grip.Select(False)==0:\n        scriptcontext.doc.Views.Redraw()\n        return True\n    return False\n\n\ndef UnselectObjectGrips(object_id):\n    \"\"\"Unselects an object's grips. Note, the grips will not be turned off.\n    Parameters:\n      object_id (guid): identifier of the object\n    Returns:\n      number: Number of grips unselected on success\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select object\")\n      if rs.ObjectGripsSelected(obj): rs.UnselectObjectGrips(obj)\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      UnselectObjectGrip\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return scriptcontext.errorhandler()\n    grips = rhobj.GetGrips()\n    if grips is None: return scriptcontext.errorhandler()\n    count = 0\n    for grip in grips:\n        if grip.Select(False)==0: count += 1\n    if count>0:\n        scriptcontext.doc.Views.Redraw()\n        return count\n    return scriptcontext.errorhandler()\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "curve", "functions"], "original_file": "McMuff86_rhinomcp_20737059db.json", "repo": "McMuff86/rhinomcp"}
{"instruction": "Adds a new directional light object to the document", "code": "import math\n\nimport Rhino.Geometry\n\nimport scriptcontext\n\nimport rhinocompat as compat\nfrom rhinoscript import utility as rhutil\n\n\ndef __coercelight(id, raise_if_missing=False):\n    light = rhutil.coercegeometry(id)\n    if isinstance(light, Rhino.Geometry.Light): return light\n    if raise_if_missing: raise ValueError(\"unable to retrieve light from %s\"%id)\n\n\ndef AddDirectionalLight(start_point, end_point):\n    \"\"\"Adds a new directional light object to the document\n    Parameters:\n      start_point(point): starting point of the light\n      end_point (point): ending point and direction of the light\n    Returns:\n      (guid): identifier of the new object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      end = rs.GetPoint(\"End of light vector direction\")\n      if end:\n          start = rs.GetPoint(\"Start of light vector direction\", end)\n          if start: rs.AddDirectionalLight( start, end )\n    See Also:\n      IsDirectionalLight\n    \"\"\"\n    start = rhutil.coerce3dpoint(start_point, True)\n    end = rhutil.coerce3dpoint(end_point, True)\n    light = Rhino.Geometry.Light()\n    light.LightStyle = Rhino.Geometry.LightStyle.WorldDirectional\n    light.Location = start\n    light.Direction = end-start\n    index = scriptcontext.doc.Lights.Add(light)\n    if index<0: raise Exception(\"unable to add light to LightTable\")\n    rc = scriptcontext.doc.Lights[index].Id\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddLinearLight(start_point, end_point, width=None):\n    \"\"\"Adds a new linear light object to the document\n    Parameters:\n      start_point (point): starting point of the light\n      end_point (point): ending point and direction of the light\n      width (number): width of the light\n    Returns:\n      guid: identifier of the new object if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      start = rs.GetPoint(\"Light origin\")\n      if start:\n          end = rs.GetPoint(\"Light length and direction\", start)\n          if end: rs.AddLinearLight(start, end)\n    See Also:\n      IsLinearLight\n    \"\"\"\n    start = rhutil.coerce3dpoint(start_point, True)\n    end = rhutil.coerce3dpoint(end_point, True)\n    if width is None:\n        radius=0.5\n        units = scriptcontext.doc.ModelUnitSystem\n        if units!=compat.ENUM_NONE(Rhino.UnitSystem):\n            scale = Rhino.RhinoMath.UnitScale(Rhino.UnitSystem.Inches, units)\n            radius *= scale\n        width = radius\n    light = Rhino.Geometry.Light()\n    light.LightStyle = Rhino.Geometry.LightStyle.WorldLinear\n    light.Location = start\n    v = end-start\n    light.Direction = v\n    light.Length = light.Direction\n    light.Width = -light.Width\n    plane = Rhino.Geometry.Plane(light.Location, light.Direction)\n    xaxis = plane.XAxis\n    xaxis.Unitize()\n    plane.XAxis = xaxis\n    light.Width = xaxis * min(width, v.Length/20)\n    #light.Location = start - light.Direction\n    index = scriptcontext.doc.Lights.Add(light)\n    if index<0: raise Exception(\"unable to add light to LightTable\")\n    rc = scriptcontext.doc.Lights[index].Id\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddPointLight(point):\n    \"\"\"Adds a new point light object to the document\n    Parameters:\n      point (point): the 3d location of the point\n    Returns:\n      guid: identifier of the new object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      point = rs.GetPoint(\"Point light location\")\n      if point: rs.AddPointLight(point)\n    See Also:\n      IsPointLight\n    \"\"\"\n    point = rhutil.coerce3dpoint(point, True)\n    light = Rhino.Geometry.Light()\n    light.LightStyle = Rhino.Geometry.LightStyle.WorldPoint\n    light.Location = point\n    index = scriptcontext.doc.Lights.Add(light)\n    if index<0: raise Exception(\"unable to add light to LightTable\")\n    rc = scriptcontext.doc.Lights[index].Id\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddRectangularLight(origin, width_point, height_point):\n    \"\"\"Adds a new rectangular light object to the document\n    Parameters:\n      origin (point): 3d origin point of the light\n      width_point (point): 3d width and direction point of the light\n      height_point (point): 3d height and direction point of the light\n    Returns:\n      guid: identifier of the new object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      rect = rs.GetRectangle(2)\n      if rect: rs.AddRectangularLight( rect[0], rect[1], rect[3] )\n    See Also:\n      IsRectangularLight\n    \"\"\"\n    origin = rhutil.coerce3dpoint(origin, True)\n    ptx = rhutil.coerce3dpoint(width_point, True)\n    pty = rhutil.coerce3dpoint(height_point, True)\n    length = pty-origin\n    width = ptx-origin\n    normal = Rhino.Geometry.Vector3d.CrossProduct(width, length)\n    normal.Unitize()\n    light = Rhino.Geometry.Light()\n    light.LightStyle = Rhino.Geometry.LightStyle.WorldRectangular\n    light.Location = origin\n    light.Width = width\n    light.Length = length\n    light.Direction = normal\n    index = scriptcontext.doc.Lights.Add(light)\n    if index<0: raise Exception(\"unable to add light to LightTable\")\n    rc = scriptcontext.doc.Lights[index].Id\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSpotLight(origin, radius, apex_point):\n    \"\"\"Adds a new spot light object to the document\n    Parameters:\n      origin (point): 3d origin point of the light\n      radius (number):  radius of the cone\n      apex_point (point): 3d apex point of the light\n    Returns:\n      guid: identifier of the new object\n    Example:\n      import rhinoscriptsyntax as rs\n      radius = 5.0\n      origin = rs.GetPoint(\"Base of cone\")\n      if origin:\n          apex = rs.GetPoint(\"End of cone\", origin)\n          if apex: rs.AddSpotLight(origin, radius, apex)\n    See Also:\n      IsSpotLight\n      SpotLightHardness\n      SpotLightShadowIntensity\n    \"\"\"\n    origin = rhutil.coerce3dpoint(origin, True)\n    apex_point = rhutil.coerce3dpoint(apex_point, True)\n    if radius<0: radius=1.0\n    light = Rhino.Geometry.Light()\n    light.LightStyle = Rhino.Geometry.LightStyle.WorldSpot\n    light.Location = apex_point\n    light.Direction = origin-apex_point\n    light.SpotAngleRadians = math.atan(radius / (light.Direction.Length))\n    light.HotSpot = 0.50\n    index = scriptcontext.doc.Lights.Add(light)\n    if index<0: raise Exception(\"unable to add light to LightTable\")\n    rc = scriptcontext.doc.Lights[index].Id\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef EnableLight(object_id, enable=None):\n    \"\"\"Enables or disables a light object\n    Parameters:\n      object_id (guid): the light object's identifier\n      enable (bool, optional): the light's enabled status\n    Returns:\n      bool: if enable is not specified, the current enabled status\n      bool: if enable is specified, the previous enabled status\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select light\", rs.filter.light)\n      if id: rs.EnableLight( id, False )\n    See Also:\n      IsLight\n      IsLightEnabled\n      LightColor\n      LightCount\n      LightName\n      LightObjects\n    \"\"\"\n    light = __coercelight(object_id, True)\n    rc = light.IsEnabled\n    if enable is not None and enable!=rc:\n        light.IsEnabled = enable\n        id = rhutil.coerceguid(object_id)\n        if not scriptcontext.doc.Lights.Modify(id, light):\n            return scriptcontext.errorhandler()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef IsDirectionalLight(object_id):\n    \"\"\"Verifies a light object is a directional light\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsDirectionalLight(id):\n          print(\"The object is a directional light.\")\n      else:\n          print(\"The object is not a directional light.\")\n    See Also:\n      AddDirectionalLight\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsDirectionalLight\n\n\ndef IsLight(object_id):\n    \"\"\"Verifies an object is a light object\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\")\n      if rs.IsLight(id):\n          print(\"The object is a light.\")\n      else:\n          print(\"The object is not a light.\")\n    See Also:\n      EnableLight\n      IsLightEnabled\n      LightColor\n      LightCount\n      LightName\n      LightObjects\n    \"\"\"\n    light = __coercelight(object_id, False)\n    return light is not None\n\n\ndef IsLightEnabled(object_id):\n    \"\"\"Verifies a light object is enabled\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsLightEnabled(id):\n          print(\"The light is enabled (on).\")\n      else:\n          print(\"The light is disabled (off).\")\n    See Also:\n      EnableLight\n      IsLight\n      LightColor\n      LightCount\n      LightName\n      LightObjects\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsEnabled\n\n\ndef IsLightReference(object_id):\n    \"\"\"Verifies a light object is referenced from another file\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsLightReference(id):\n          print(\"The light is a reference object.\")\n      else:\n          print(\"The light is not a reference object.\")\n    See Also:\n      IsObjectReference\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsReference\n\n\ndef IsLinearLight(object_id):\n    \"\"\"Verifies a light object is a linear light\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsLinearLight(id):\n          print(\"The object is a linear light.\")\n      else:\n          print(\"The object is not a linear light.\")\n    See Also:\n      AddLinearLight\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsLinearLight\n\n\ndef IsPointLight(object_id):\n    \"\"\"Verifies a light object is a point light\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsPointLight(id):\n          print(\"The object is a point light.\")\n      else:\n          print(\"The object is not a point light.\")\n    See Also:\n      AddPointLight\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsPointLight\n\n\ndef IsRectangularLight(object_id):\n    \"\"\"Verifies a light object is a rectangular light\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsRectangularLight(id):\n          print(\"The object is a rectangular light.\")\n      else:\n          print(\"The object is not a rectangular light.\")\n    See Also:\n      AddRectangularLight\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsRectangularLight\n\n\ndef IsSpotLight(object_id):\n    \"\"\"Verifies a light object is a spot light\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsSpotLight(id):\n          print(\"The object is a spot light.\")\n      else:\n          print(\"The object is not a spot light.\")\n    See Also:\n      AddSpotLight\n      SpotLightHardness\n      SpotLightShadowIntensity\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsSpotLight\n\n\ndef LightColor(object_id, color=None):\n    \"\"\"Returns or changes the color of a light\n    Parameters:\n      object_id (guid): the light object's identifier\n      color (color, optional): the light's new color\n    Returns:\n      color: if color is not specified, the current color\n      color: if color is specified, the previous color\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id: rs.LightColor( id, (0,255,255) )\n    See Also:\n      EnableLight\n      IsLight\n      IsLightEnabled\n      LightCount\n      LightName\n      LightObjects\n    \"\"\"\n    light = __coercelight(object_id, True)\n    rc = light.Diffuse\n    if color:\n        color = rhutil.coercecolor(color, True)\n        if color!=rc:\n            light.Diffuse = color\n            id = rhutil.coerceguid(object_id, True)\n            if not scriptcontext.doc.Lights.Modify(id, light):\n                return scriptcontext.errorhandler()\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef LightCount():\n    \"\"\"Returns the number of light objects in the document\n    Returns:\n      number: the number of light objects in the document\n    Example:\n      import rhinoscriptsyntax as rs\n      print(\"There are {} lights\".format(rs.LightCount()))\n    See Also:\n      EnableLight\n      IsLight\n      IsLightEnabled\n      LightColor\n      LightName\n      LightObjects\n    \"\"\"\n    return scriptcontext.doc.Lights.Count\n\n\ndef LightDirection(object_id, direction=None):\n    \"\"\"Returns or changes the direction of a light object\n    Parameters:\n      object_id (guid): the light object's identifier\n      direction (vector, optional): the light's new direction\n    Returns:\n      vector: if direction is not specified, the current direction\n      vector: if direction is specified, the previous direction\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id: print( rs.LightDirection(id) )\n    See Also:\n      IsLight\n      LightLocation\n    \"\"\"\n    light = __coercelight(object_id, True)\n    rc = light.Direction\n    if direction:\n        direction = rhutil.coerce3dvector(direction, True)\n        if direction!=rc:\n            light.Direction = direction\n            id = rhutil.coerceguid(object_id, True)\n            if not scriptcontext.doc.Lights.Modify(id, light):\n                return scriptcontext.errorhandler()\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef LightLocation(object_id, location=None):\n    \"\"\"Returns or changes the location of a light object\n    Parameters:\n      object_id (guid): the light object's identifier\n      location (point, optional): the light's new location\n    Returns:\n      point: if location is not specified, the current location\n      point: if location is specified, the previous location\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id: rs.AddPoint( rs.LightLocation(id) )\n    See Also:\n      IsLight\n      LightDirection\n    \"\"\"\n    light = __coercelight(object_id, True)\n    rc = light.Location\n    if location:\n        location = rhutil.coerce3dpoint(location, True)\n        if location!=rc:\n            light.Location = location\n            id = rhutil.coerceguid(object_id, True)\n            if not scriptcontext.doc.Lights.Modify(id, light):\n                return scriptcontext.errorhandler()\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef LightName(object_id, name=None):\n    \"\"\"Returns or changes the name of a light object\n    Parameters:\n      object_id (guid): the light object's identifier\n      name (str, optional): the light's new name\n    Returns:\n      str: if name is not specified, the current name\n      str: if name is specified, the previous name\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id:\n          name = rs.GetString(\"New light name\")\n          if name: rs.LightName(id, name)\n    See Also:\n      EnableLight\n      IsLight\n      IsLightEnabled\n      LightColor\n      LightCount\n      LightObjects\n    \"\"\"\n    light = __coercelight(object_id, True)\n    rc = light.Name\n    if name and name!=rc:\n        light.Name = name\n        id = rhutil.coerceguid(object_id, True)\n        if not scriptcontext.doc.Lights.Modify(id, light):\n            return scriptcontext.errorhandler()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef LightObjects():\n    \"\"\"Returns list of identifiers of light objects in the document\n    Returns:\n      list(guid, ...): the list of identifiers of light objects in the document\n    Example:\n      import rhinoscriptsyntax as rs\n      lights = rs.LightObjects()\n      if lights:\n          rs.AddLayer( \"Lights\" )\n          for light in lights: rs.ObjectLayer( light, \"Lights\" )\n    See Also:\n      EnableLight\n      IsLight\n      IsLightEnabled\n      LightColor\n      LightCount\n      LightName\n    \"\"\"\n    count = scriptcontext.doc.Lights.Count\n    rc = []\n    for i in range(count):\n        rhlight = scriptcontext.doc.Lights[i]\n        if not rhlight.IsDeleted: rc.append(rhlight.Id)\n    return rc\n\n\ndef RectangularLightPlane(object_id):\n    \"\"\"Returns the plane of a rectangular light object\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      plane: the plane if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a rectangular light\", rs.filter.light)\n      if id:\n          rc = rs.RectangularLightPlane(id)\n          if rc:\n              plane, extents = rc\n              rs.AddPlaneSurface( plane, extents[0], extents[1] )\n    See Also:\n      IsRectangularLight\n    \"\"\"\n    light = __coercelight(object_id, True)\n    if light.LightStyle!=Rhino.Geometry.LightStyle.WorldRectangular:\n        return scriptcontext.errorhandler()\n    location = light.Location\n    length = light.Length\n    width = light.Width\n    direction = light.Direction\n    plane = Rhino.Geometry.Plane(location, length, width)\n    return plane, (length.Length, width.Length)\n\n\ndef SpotLightHardness(object_id, hardness=None):\n    \"\"\"Returns or changes the hardness of a spot light. Spotlight hardness\n    controls the fully illuminated region.\n    Parameters:\n      object_id (guid): the light object's identifier\n      hardness (number, optional): the light's new hardness\n    Returns:\n      number: if hardness is not specified, the current hardness\n      number: if hardness is specified, the previous hardness\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id: rs.SpotLightHardness(id, 0.75)\n    See Also:\n      AddSpotLight\n      IsSpotLight\n      SpotLightRadius\n      SpotLightShadowIntensity\n    \"\"\"\n    light = __coercelight(object_id, True)\n    if light.LightStyle!=Rhino.Geometry.LightStyle.WorldSpot:\n        return scriptcontext.errorhandler()\n    rc = light.HotSpot\n    if hardness and hardness!=rc:\n        light.HotSpot = hardness\n        id = rhutil.coerceguid(object_id, True)\n        if not scriptcontext.doc.Lights.Modify(id, light):\n            return scriptcontext.errorhandler()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef SpotLightRadius(object_id, radius=None):\n    \"\"\"Returns or changes the radius of a spot light.\n    Parameters:\n      object_id (guid): the light object's identifier\n      radius (number, optional): the light's new radius\n    Returns:\n      number: if radius is not specified, the current radius\n      number: if radius is specified, the previous radius\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id: rs.SpotLightRadius(id, 5.0)\n    See Also:\n      AddSpotLight\n      IsSpotLight\n      SpotLightHardness\n      SpotLightShadowIntensity\n    \"\"\"\n    light = __coercelight(object_id, True)\n    if light.LightStyle!=Rhino.Geometry.LightStyle.WorldSpot:\n        return scriptcontext.errorhandler()\n    radians = light.SpotAngleRadians\n    rc = light.Direction.Length * math.tan(radians)\n    if radius and radius!=rc:\n        radians = math.atan(radius/light.Direction.Length)\n        light.SpotAngleRadians = radians\n        id = rhutil.coerceguid(object_id, True)\n        if not scriptcontext.doc.Lights.Modify(id, light):\n            return scriptcontext.errorhandler()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef SpotLightShadowIntensity(object_id, intensity=None):\n    \"\"\"Returns or changes the shadow intensity of a spot light.\n    Parameters:\n      object_id (guid): the light object's identifier\n      intensity (number, optional): the light's new intensity\n    Returns:\n      number: if intensity is not specified, the current intensity\n      number: if intensity is specified, the previous intensity\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id: rs.SpotLightShadowIntensity(id, 0.75)\n    See Also:\n      AddSpotLight\n      IsSpotLight\n      SpotLightHardness\n      SpotLightRadius\n    \"\"\"\n    light = __coercelight(object_id, True)\n    if light.LightStyle!=Rhino.Geometry.LightStyle.WorldSpot:\n        return scriptcontext.errorhandler()\n    rc = light.SpotLightShadowIntensity\n    if intensity and intensity!=rc:\n        light.SpotLightShadowIntensity = intensity\n        id = rhutil.coerceguid(object_id, True)\n        if not scriptcontext.doc.Lights.Modify(id, light):\n            return scriptcontext.errorhandler()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "layer", "line", "functions", "RhinoCommon"], "original_file": "McMuff86_rhinomcp_7dd5385255.json", "repo": "McMuff86/rhinomcp"}
{"instruction": "Adds an arc curve to the document", "code": "import math\n\nimport System\n\nimport Rhino\n\nimport scriptcontext\n\nimport rhinocompat as compat\nfrom rhinoscript import utility as rhutil\n\n\ndef AddArc(plane, radius, angle_degrees):\n    \"\"\"Adds an arc curve to the document\n    Parameters:\n      plane (str): plane on which the arc will lie. The origin of the plane will be\n        the center point of the arc. x-axis of the plane defines the 0 angle\n        direction.\n      radius(number): radius of the arc\n      angle_degrees (number): interval of arc in degrees\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as  rs\n      plane = rs.WorldXYPlane()\n      plane = rs.RotatePlane(plane,  45.0, [0,0,1])\n      rs.AddArc( plane, 5.0, 45.0  )\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcCenterPoint\n      ArcMidPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    radians = math.radians(angle_degrees)\n    arc = Rhino.Geometry.Arc(plane, radius, radians)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add arc to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddArc3Pt(start, end, point_on_arc):\n    \"\"\"Adds a 3-point arc curve to the document\n    Parameters:\n      start, end (point|guid): endpoints of the arc\n      point_on_arc (point|guid): a point on the arc\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      start = rs.GetPoint(\"Start of arc\")\n      if start is not None:\n          end = rs.GetPoint(\"End of arc\")\n          if end is not None:\n              pton = rs.GetPoint(\"Point on arc\")\n              if pton is not None:\n                  rs.AddArc3Pt(start, end, pton)\n    See Also:\n      AddArc\n      ArcAngle\n      ArcCenterPoint\n      ArcMidPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    start = rhutil.coerce3dpoint(start, True)\n    end = rhutil.coerce3dpoint(end, True)\n    pton = rhutil.coerce3dpoint(point_on_arc, True)\n    arc = Rhino.Geometry.Arc(start, pton, end)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add arc to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddArcPtTanPt(start, direction, end):\n    \"\"\"Adds an arc curve, created from a start point, a start direction, and an\n    end point, to the document\n    Parameters:\n      start (point): the starting point of the arc\n      direction (vector): the arc direction at start\n      end (point): the ending point of the arc\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      pick = rs.GetCurveObject(\"Select curve to extend\")\n      point = rs.GetPoint(\"End of extension\")\n      domain = rs.CurveDomain(pick[0])\n      if abs(pick[4]-domain[0]) < abs(pick[4]-domain[1]):\n          origin = rs.CurveStartPoint(pick[0])\n          tangent = rs.VectorReverse(rs.CurveTangent(pick[0], domain[0]))\n      else:\n          origin = rs.CurveEndPoint(pick[0])\n          tangent = rs.CurveTangent(pick[0], domain[1])\n      rs.AddArcPtTanPt(origin, tangent, point)\n    See Also:\n      AddArc\n      AddArc3Pt\n      IsArc\n    \"\"\"\n    start = rhutil.coerce3dpoint(start, True)\n    direction = rhutil.coerce3dvector(direction, True)\n    end = rhutil.coerce3dpoint(end, True)\n    arc = Rhino.Geometry.Arc(start, direction, end)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add arc to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddBlendCurve(curves, parameters, reverses, continuities):\n    \"\"\"Makes a curve blend between two curves\n    Parameters:\n      curves ([guid|curve, guid|curve]): list of two curves\n      parameters ([number, number]): list of two curve parameters defining the blend end points\n      reverses ([bool, bool]): list of two boolean values specifying to use the natural or opposite direction of the curve\n      continuities ([number, number]): list of two numbers specifying continuity at end points\n                                            0 = position\n                                            1 = tangency\n                                            2 = curvature\n    Returns:\n      guid: identifier of new curve on success\n    Example:\n        import rhinoscriptsyntax as rs\n        curve0 = rs.AddLine((0,0,0), (0,9,0))\n        curve1 = rs.AddLine((1,10,0), (10,10,0))\n        curves = curve0, curve1\n        domain_crv0 = rs.CurveDomain(curve0)\n        domain_crv1 = rs.CurveDomain(curve1)\n        params = domain_crv0[1], domain_crv1[0]\n        revs = False, True\n        cont = 2,2\n        rs.AddBlendCurve( curves, params, revs, cont )\n    See Also:\n      AddFilletCurve\n    \"\"\"\n    crv0 = rhutil.coercecurve(curves[0], -1, True)\n    crv1 = rhutil.coercecurve(curves[1], -1, True)\n    c0 = System.Enum.ToObject(Rhino.Geometry.BlendContinuity, continuities[0])\n    c1 = System.Enum.ToObject(Rhino.Geometry.BlendContinuity, continuities[1])\n    curve = Rhino.Geometry.Curve.CreateBlendCurve(crv0, parameters[0], reverses[0], c0, crv1, parameters[1], reverses[1], c1)\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCircle(plane_or_center, radius):\n    \"\"\"Adds a circle curve to the document\n    Parameters:\n      plane_or_center (point|plane): plane on which the circle will lie. If a point is\n        passed, this will be the center of the circle on the active\n        construction plane\n      radius (number): the radius of the circle\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.WorldXYPlane()\n      rs.AddCircle( plane, 5.0 )\n    See Also:\n      AddCircle3Pt\n      CircleCenterPoint\n      CircleCircumference\n      CircleRadius\n      IsCircle\n    \"\"\"\n    rc = None\n    plane = rhutil.coerceplane(plane_or_center, False)\n    if plane:\n        circle = Rhino.Geometry.Circle(plane, radius)\n        rc = scriptcontext.doc.Objects.AddCircle(circle)\n    else:\n        center = rhutil.coerce3dpoint(plane_or_center, True)\n        view = scriptcontext.doc.Views.ActiveView\n        plane = view.ActiveViewport.ConstructionPlane()\n        plane.Origin = center\n        circle = Rhino.Geometry.Circle(plane, radius)\n        rc = scriptcontext.doc.Objects.AddCircle(circle)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add circle to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCircle3Pt(first, second, third):\n    \"\"\"Adds a 3-point circle curve to the document\n    Parameters:\n      first, second, third (point|guid): points on the circle\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      point1 = rs.GetPoint(\"First point on circle\")\n      if point1:\n          point2 = rs.GetPoint(\"Second point on circle\")\n          if point2:\n              point3 = rs.GetPoint(\"Third point on circle\")\n              if point3:\n                  rs.AddCircle3Pt(point1, point2, point3)\n    See Also:\n      AddCircle\n      CircleCenterPoint\n      CircleCircumference\n      CircleRadius\n      IsCircle\n    \"\"\"\n    start = rhutil.coerce3dpoint(first, True)\n    end = rhutil.coerce3dpoint(second, True)\n    third = rhutil.coerce3dpoint(third, True)\n    circle = Rhino.Geometry.Circle(start, end, third)\n    rc = scriptcontext.doc.Objects.AddCircle(circle)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add circle to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCurve(points, degree=3):\n    \"\"\"Adds a control points curve object to the document\n    Parameters:\n      points ([point|guid, ...]) a list of points\n      degree (number): degree of the curve\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      points = rs.GetPoints(True, message1=\"Pick curve point\")\n      if points: rs.AddCurve(points)\n    See Also:\n      AddInterpCurve\n      IsCurve\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    curve = Rhino.Geometry.Curve.CreateControlPointCurve(points, degree)\n    if not curve: raise Exception(\"unable to create control point curve from given points\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddEllipse(plane, radiusX, radiusY):\n    \"\"\"Adds an elliptical curve to the document\n    Parameters:\n      plane (plane) the plane on which the ellipse will lie. The origin of\n              the plane will be the center of the ellipse\n      radiusX, radiusY (number): radius in the X and Y axis directions\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.WorldXYPlane()\n      rs.AddEllipse( plane, 5.0, 10.0 )\n    See Also:\n      AddEllipse3Pt\n      IsEllipse\n      EllipseCenterPoint\n      EllipseQuadPoints\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    ellipse = Rhino.Geometry.Ellipse(plane, radiusX, radiusY)\n    rc = scriptcontext.doc.Objects.AddEllipse(ellipse)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddEllipse3Pt(center, second, third):\n    \"\"\"Adds a 3-point elliptical curve to the document\n    Parameters:\n      center (point|guid): center point of the ellipse\n      second (point|guid): end point of the x axis\n      third  (point|guid): end point of the y axis\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      center = (0,0,0)\n      second = (5,0,0)\n      third = (0,10,0)\n      rs.AddEllipse3Pt( center, second, third )\n    See Also:\n      AddEllipse\n      IsEllipse\n      EllipseCenterPoint\n      EllipseQuadPoints\n    \"\"\"\n    center = rhutil.coerce3dpoint(center, True)\n    second = rhutil.coerce3dpoint(second, True)\n    third = rhutil.coerce3dpoint(third, True)\n    ellipse = Rhino.Geometry.Ellipse(center, second, third)\n    rc = scriptcontext.doc.Objects.AddEllipse(ellipse)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddFilletCurve(curve0id, curve1id, radius=1.0, base_point0=None, base_point1=None):\n    \"\"\"Adds a fillet curve between two curve objects\n    Parameters:\n      curve0id (guid): identifier of the first curve object\n      curve1id (guid): identifier of the second curve object\n      radius (number, optional): fillet radius\n      base_point0 (point|guid, optional): base point of the first curve. If omitted,\n                          starting point of the curve is used\n      base_point1 (point|guid, optional): base point of the second curve. If omitted,\n                          starting point of the curve is used\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      curve0 = rs.AddLine([0,0,0], [5,1,0])\n      curve1 = rs.AddLine([0,0,0], [1,5,0])\n      rs.AddFilletCurve( curve0, curve1 )\n    See Also:\n      CurveFilletPoints\n    \"\"\"\n    if base_point0: base_point0 = rhutil.coerce3dpoint(base_point0, True)\n    else: base_point0 = Rhino.Geometry.Point3d.Unset\n    if base_point1: base_point1 = rhutil.coerce3dpoint(base_point1, True)\n    else: base_point1 = Rhino.Geometry.Point3d.Unset\n    curve0 = rhutil.coercecurve(curve0id, -1, True)\n    curve1 = rhutil.coercecurve(curve1id, -1, True)\n    crv0_t = 0.0\n    if base_point0==Rhino.Geometry.Point3d.Unset:\n        crv0_t = curve0.Domain.Min\n    else:\n        rc, t = curve0.ClosestPoint(base_point0, 0.0)\n        if not rc: raise Exception(\"ClosestPoint failed\")\n        crv0_t = t\n    crv1_t = 0.0\n    if base_point1==Rhino.Geometry.Point3d.Unset:\n        crv1_t = curve1.Domain.Min\n    else:\n        rc, t = curve1.ClosestPoint(base_point1, 0.0)\n        if not rc: raise Exception(\"ClosestPoint failed\")\n        crv1_t = t\n    arc = Rhino.Geometry.Curve.CreateFillet(curve0, curve1, radius, crv0_t, crv1_t)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddInterpCrvOnSrf(surface_id, points):\n    \"\"\"Adds an interpolated curve object that lies on a specified\n    surface.  Note, this function will not create periodic curves,\n    but it will create closed curves.\n    Parameters:\n      surface_id (guid): identifier of the surface to create the curve on\n      points ([point|guid, point|guid, ...])list of 3D points that lie on the specified surface.\n               The list must contain at least 2 points\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      surface_id = rs.GetObject(\"Select surface to draw curve on\", rs.filter.surface)\n      if surface_id:\n          point1 = rs.GetPointOnSurface( surface_id, \"First point on surface\")\n          if point1:\n              point2 = rs.GetPointOnSurface( surface_id, \"Second point on surface\")\n              if point2:\n                  rs.AddInterpCrvOnSrf( surface_id, [point1, point2])\n    See Also:\n      AddCurve\n      AddInterpCurve\n      AddInterpCrvOnSrfUV\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    points = rhutil.coerce3dpointlist(points, True)\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    curve = surface.InterpolatedCurveOnSurface(points, tolerance)\n    if not curve: raise Exception(\"unable to create InterpolatedCurveOnSurface\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddInterpCrvOnSrfUV(surface_id, points):\n    \"\"\"Adds an interpolated curve object based on surface parameters,\n    that lies on a specified surface. Note, this function will not\n    create periodic curves, but it will create closed curves.\n    Parameters:\n      surface_id (guid): identifier of the surface to create the curve on\n      points ([[number, number}, [number,number], ...]): a list of 2D surface parameters. The list must contain\n                                                         at least 2 sets of parameters\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      surface_id = rs.GetObject(\"Select surface to draw curve on\", rs.filter.surface)\n      if surface_id:\n          domainU = rs.SurfaceDomain( surface_id, 0)\n          u0 = domainU[0]/2\n          u1 = domainU[1]/2\n          domainV = rs.SurfaceDomain( surface_id, 1)\n          v0 = domainV[0]/2\n          v1 = domainV[1]/2\n          rs.AddInterpCrvOnSrfUV( surface_id, [[u0,v0],[u1,v1]])\n    See Also:\n      AddCurve\n      AddInterpCurve\n      AddInterpCrvOnSrf\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    points = rhutil.coerce2dpointlist(points)\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    curve = surface.InterpolatedCurveOnSurfaceUV(points, tolerance)\n    if not curve: raise Exception(\"unable to create InterpolatedCurveOnSurfaceUV\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddInterpCurve(points, degree=3, knotstyle=0, start_tangent=None, end_tangent=None):\n    \"\"\"Adds an interpolated curve object to the document. Options exist to make\n    a periodic curve or to specify the tangent at the endpoints. The resulting\n    curve is a non-rational NURBS curve of the specified degree.\n    Parameters:\n      points (point|guid, point|guid, ...]): a list containing 3D points to interpolate. For periodic curves,\n          if the final point is a duplicate of the initial point, it is\n          ignored. The number of control points must be >= (degree+1).\n      degree (number, optional): The degree of the curve (must be >=1).\n          Periodic curves must have a degree >= 2. For knotstyle = 1 or 2,\n          the degree must be 3. For knotstyle = 4 or 5, the degree must be odd\n      knotstyle(opt):\n          0 Uniform knots.  Parameter spacing between consecutive knots is 1.0.\n          1 Chord length spacing.  Requires degree = 3 with arrCV1 and arrCVn1 specified.\n          2 Sqrt (chord length).  Requires degree = 3 with arrCV1 and arrCVn1 specified.\n          3 Periodic with uniform spacing.\n          4 Periodic with chord length spacing.  Requires an odd degree value.\n          5 Periodic with sqrt (chord length) spacing.  Requires an odd degree value.\n      start_tangent (vector, optional): a vector that specifies a tangency condition at the\n          beginning of the curve. If the curve is periodic, this argument must be omitted.\n      end_tangent (vector, optional): 3d vector that specifies a tangency condition at the\n          end of the curve. If the curve is periodic, this argument must be omitted.\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      points = (0,0,0), (1,1,0), (2,0,0), (3,1,0), (4,0,0), (5,1,0)\n      rs.AddInterpCurve(points)\n    See Also:\n      AddCurve\n      CurvePointCount\n      IsCurve\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    if not start_tangent: start_tangent = Rhino.Geometry.Vector3d.Unset\n    start_tangent = rhutil.coerce3dvector(start_tangent, True)\n    if not end_tangent: end_tangent = Rhino.Geometry.Vector3d.Unset\n    end_tangent = rhutil.coerce3dvector(end_tangent, True)\n    knotstyle = System.Enum.ToObject(Rhino.Geometry.CurveKnotStyle, knotstyle)\n    curve = Rhino.Geometry.Curve.CreateInterpolatedCurve(points, degree, knotstyle, start_tangent, end_tangent)\n    if not curve: raise Exception(\"unable to CreateInterpolatedCurve\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddLine(start, end):\n    \"\"\"Adds a line curve to the current model.\n    Parameters:\n      start, end (point|guid) end points of the line\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      start = rs.GetPoint(\"Start of line\")\n      if start:\n          end = rs.GetPoint(\"End of line\")\n          if end: rs.AddLine(start, end)\n    See Also:\n      CurveEndPoint\n      CurveStartPoint\n      IsLine\n    \"\"\"\n    start = rhutil.coerce3dpoint(start, True)\n    end = rhutil.coerce3dpoint(end, True)\n    rc = scriptcontext.doc.Objects.AddLine(start, end)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add line to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddNurbsCurve(points, knots, degree, weights=None):\n    \"\"\"Adds a NURBS curve object to the document\n    Parameters:\n      points ([guid|point, guid|point, ...]): a list containing 3D control points\n      knots ([number, number, ...]): Knot values for the curve. The number of elements in knots must\n          equal the number of elements in points plus degree minus 1\n      degree (number): degree of the curve. must be greater than of equal to 1\n      weights([number, number, ...], optional) weight values for the curve. Number of elements should\n          equal the number of elements in points. Values must be greater than 0\n    Returns:\n      guid: the identifier of the new object if successful, otherwise None\n    Example:\n      import rhinoscriptsyntax as rs\n      curve_id = rs.GetObject(\"Pick a curve\", rs.filter.curve)\n      if curve_id:\n          points = rs.CurvePoints(curve_id)\n          knots = rs.CurveKnots(curve_id)\n          degree = rs.CurveDegree(curve_id)\n          newcurve = rs.AddNurbsCurve( points, knots, degree)\n          if newcurve: rs.SelectObject(newcurve)\n    See Also:\n      CurveDegree\n      CurveKnots\n      CurvePoints\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    cvcount = len(points)\n    knotcount = cvcount + degree - 1\n    if len(knots)!=knotcount:\n        raise Exception(\"Number of elements in knots must equal the number of elements in points plus degree minus 1\")\n    if weights and len(weights)!=cvcount:\n        raise Exception(\"Number of elements in weights should equal the number of elements in points\")\n    rational = (weights!=None)\n    \n    nc = Rhino.Geometry.NurbsCurve(3,rational,degree+1,cvcount)\n    if rational: \n        for i in compat.RANGE(cvcount):\n            nc.Points.SetPoint(i, points[i], weights[i])\n    else:\n        for i in compat.RANGE(cvcount):\n            nc.Points.SetPoint(i, points[i])\n    for i in compat.RANGE(knotcount): nc.Knots[i] = knots[i]\n    rc = scriptcontext.doc.Objects.AddCurve(nc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddPolyline(points, replace_id=None):\n    \"\"\"Adds a polyline curve to the current model\n    Parameters:\n      points ([guid|point, guid|point, ...]): list of 3D points. Duplicate, consecutive points will be\n               removed. The list must contain at least two points. If the\n               list contains less than four points, then the first point and\n               last point must be different.\n      replace_id (guid, optional): If set to the id of an existing object, the object\n               will be replaced by this polyline\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      points = rs.GetPoints(True)\n      if points: rs.AddPolyline(points)\n    See Also:\n      IsPolyline\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    if replace_id: replace_id = rhutil.coerceguid(replace_id, True)\n    rc = System.Guid.Empty\n    pl = Rhino.Geometry.Polyline(points)\n    pl.DeleteShortSegments(scriptcontext.doc.ModelAbsoluteTolerance)\n    if replace_id:\n        if scriptcontext.doc.Objects.Replace(replace_id, pl):\n            rc = replace_id\n    else:\n        rc = scriptcontext.doc.Objects.AddPolyline(pl)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add polyline to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddRectangle(plane, width, height):\n    \"\"\"Add a rectangular curve to the document\n    Parameters:\n      plane (plane) plane on which the rectangle will lie\n      width, height (number): width and height of rectangle as measured along the plane's\n        x and y axes\n    Returns:\n      guid: id of new rectangle\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.WorldXYPlane()\n      plane = rs.RotatePlane(plane, 45.0, [0,0,1])\n      rs.AddRectangle( plane, 5.0, 15.0 )\n    See Also:\n      \n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    rect = Rhino.Geometry.Rectangle3d(plane, width, height)\n    poly = rect.ToPolyline()\n    rc = scriptcontext.doc.Objects.AddPolyline(poly)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add polyline to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSpiral(point0, point1, pitch, turns, radius0, radius1=None):\n    \"\"\"Adds a spiral or helical curve to the document\n    Parameters:\n      point0 (point|guid): helix axis start point or center of spiral\n      point1 (point|guid): helix axis end point or point normal on spiral plane\n      pitch (number): distance between turns. If 0, then a spiral. If > 0 then the\n              distance between helix \"threads\"\n      turns (number): number of turns\n      radius0 (number): starting radius of spiral\n      radius1 (number, optional): ending radius of spiral. If omitted, the starting radius is used for the complete spiral.\n    Returns:\n      guid: id of new curve on success\n    Example:\n      import rhinoscriptsyntax as rs\n      point0 = (0,0,0)\n      point1 = (0,0,10)\n      pitch = 1\n      turns = 10\n      radius0 = 5.0\n      radius1 = 8.0\n      rs.AddSpiral(point0, point1, pitch, turns, radius0, radius1)\n    See Also:\n      \n    \"\"\"\n    if radius1 is None: radius1 = radius0\n    point0 = rhutil.coerce3dpoint(point0, True)\n    point1 = rhutil.coerce3dpoint(point1, True)\n    dir = point1 - point0\n    plane = Rhino.Geometry.Plane(point0, dir)\n    point2 = point0 + plane.XAxis\n    curve = Rhino.Geometry.NurbsCurve.CreateSpiral(point0, dir, point2, pitch, turns, radius0, radius1)\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSubCrv(curve_id, param0, param1):\n    \"\"\"Add a curve object based on a portion, or interval of an existing curve\n    object. Similar in operation to Rhino's SubCrv command\n    Parameters:\n      curve_id (guid): identifier of a closed planar curve object\n      param0, param1 (number): first and second parameters on the source curve\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      getresult = rs.GetCurveObject()\n      if getresult:\n          curve_id = getresult[0]\n          point0 = rs.GetPointOnCurve( curve_id )\n          if point0:\n              point1 = rs.GetPointOnCurve( curve_id )\n              if point1:\n                  t0 = rs.CurveClosestPoint( curve_id, point0)\n                  t1 = rs.CurveClosestPoint( curve_id, point1)\n                  rs.AddSubCrv( curve_id, t0, t1 )\n    See Also:\n      CurveClosestPoint\n      GetCurveObject\n      GetPointOnCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    trimcurve = curve.Trim(param0, param1)\n    if not trimcurve: raise Exception(\"unable to trim curve\")\n    rc = scriptcontext.doc.Objects.AddCurve(trimcurve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ArcAngle(curve_id, segment_index=-1):\n    \"\"\"Returns the angle of an arc curve object.\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): identifies the curve segment if\n      curve_id (guid): identifies a polycurve\n    Returns:\n      number: The angle in degrees if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select arc\")\n      if rs.IsArc(id):\n          angle = rs.ArcAngle(id)\n          print(\"Arc angle: {}\".format(angle))\n    See Also:\n      AddArc3Pt\n      ArcCenterPoint\n      ArcMidPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.AngleDegrees\n\n\ndef ArcCenterPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the center point of an arc curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: The 3D center point of the arc if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select arc\")\n      if rs.IsArc(id):\n      point = rs.ArcCenterPoint(id)\n      rs.AddPoint(point)\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcMidPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.Center\n\n\ndef ArcMidPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the mid point of an arc curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: The 3D mid point of the arc if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select arc\")\n      if rs.IsArc(id):\n          point = rs.ArcMidPoint(id)\n          rs.AddPoint(point)\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcCenterPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.MidPoint\n\n\ndef ArcRadius(curve_id, segment_index=-1):\n    \"\"\"Returns the radius of an arc curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The radius of the arc if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select arc\")\n      if rs.IsArc(id):\n          radius = rs.ArcRadius(id)\n          print(\"Arc radius: {}\".format(radius))\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcCenterPoint\n      ArcMidPoint\n      IsArc\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.Radius\n\n\ndef CircleCenterPoint(curve_id, segment_index=-1, return_plane=False):\n    \"\"\"Returns the center point of a circle curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n      return_plane (bool, optional): if True, the circle's plane is returned. If omitted the plane is not returned.\n    Returns:\n      point: The 3D center point of the circle if successful.\n      plane: The plane of the circle if return_plane is True\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select circle\")\n      if rs.IsCircle(id):\n          point = rs.CircleCenterPoint(id)\n          rs.AddPoint( point )\n    See Also:\n      AddCircle\n      AddCircle3Pt\n      CircleCircumference\n      CircleRadius\n      IsCircle\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, circle = curve.TryGetCircle(Rhino.RhinoMath.ZeroTolerance)\n    if not rc: raise Exception(\"curve is not circle\")\n    if return_plane: return circle.Plane\n    return circle.Center\n\n\ndef CircleCircumference(curve_id, segment_index=-1):\n    \"\"\"Returns the circumference of a circle curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The circumference of the circle if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select circle\")\n      if rs.IsCircle(id):\n          circumference = rs.CircleCircumference(id)\n          print(\"Circle circumference: {}\".format(circumference))\n    See Also:\n      AddCircle\n      AddCircle3Pt\n      CircleCenterPoint\n      CircleRadius\n      IsCircle\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, circle = curve.TryGetCircle( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not circle\")\n    return circle.Circumference\n\n\ndef CircleRadius(curve_id, segment_index=-1):\n    \"\"\"Returns the radius of a circle curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The radius of the circle if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select circle\")\n      if rs.IsCircle(id):\n          radius = rs.CircleRadius(id)\n          print(\"Circle radius: {}\".format(radius))\n    See Also:\n      AddCircle\n      AddCircle3Pt\n      CircleCenterPoint\n      CircleCircumference\n      IsCircle\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, circle = curve.TryGetCircle( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not circle\")\n    return circle.Radius\n\n\ndef CloseCurve(curve_id, tolerance=-1.0):\n    \"\"\"Closes an open curve object by making adjustments to the end points so\n    they meet at a point\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      tolerance (number, optional): maximum allowable distance between start and end\n                                    point. If omitted, the current absolute tolerance is used\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if not rs.IsCurveClosed(obj) and rs.IsCurveClosable(obj):\n          rs.CloseCurve( obj )\n    See Also:\n      IsCurveClosable\n      IsCurveClosed\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if curve.IsClosed: return curve_id\n    if tolerance<0.0: tolerance = Rhino.RhinoMath.ZeroTolerance\n    if not curve.MakeClosed(tolerance): return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ClosedCurveOrientation(curve_id, direction=(0,0,1)):\n    \"\"\"Determine the orientation (counter-clockwise or clockwise) of a closed,\n    planar curve\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      direction (vector, optional): 3d vector that identifies up, or Z axs, direction of\n                                    the plane to test against\n    Returns:\n      number: 1 if the curve's orientation is counter-clockwise\n             -1 if the curve's orientation is clockwise\n              0 if unable to compute the curve's orientation\n    Example:\n    See Also:\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1 ,True)\n    direction = rhutil.coerce3dvector(direction, True)\n    if not curve.IsClosed: return 0\n    orientation = curve.ClosedCurveOrientation(direction)\n    return int(orientation)\n\n\ndef ConvertCurveToPolyline(curve_id, angle_tolerance=5.0, tolerance=0.01, delete_input=False, min_edge_length=0, max_edge_length=0):\n    \"\"\"Convert curve to a polyline curve\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      angle_tolerance (number, optional): The maximum angle between curve tangents at line endpoints.\n                                          If omitted, the angle tolerance is set to 5.0.\n      tolerance(number, optional): The distance tolerance at segment midpoints. If omitted, the tolerance is set to 0.01.\n      delete_input(bool, optional): Delete the curve object specified by curve_id. If omitted, curve_id will not be deleted.\n      min_edge_length (number, optional): Minimum segment length\n      max_edge_length (number, optonal): Maximum segment length\n    Returns:\n      guid: The new curve if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          polyline = rs.ConvertCurveToPolyline(obj)\n          if polyline: rs.SelectObject(polyline)\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if angle_tolerance<=0: angle_tolerance = 5.0\n    angle_tolerance = Rhino.RhinoMath.ToRadians(angle_tolerance)\n    if tolerance<=0.0: tolerance = 0.01;\n    polyline_curve = curve.ToPolyline( 0, 0, angle_tolerance, 0.0, 0.0, tolerance, min_edge_length, max_edge_length, True)\n    if not polyline_curve: return scriptcontext.errorhandler()\n    id = System.Guid.Empty\n    if delete_input:\n        if scriptcontext.doc.Objects.Replace( curve_id, polyline_curve): id = curve_id\n    else:\n        id = scriptcontext.doc.Objects.AddCurve( polyline_curve )\n    if System.Guid.Empty==id: return scriptcontext.errorhandler()\n    return id\n\n  \ndef CurveArcLengthPoint(curve_id, length, from_start=True):\n    \"\"\"Returns the point on the curve that is a specified arc length\n    from the start of the curve.\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      length (number): The arc length from the start of the curve to evaluate.\n      from_start (bool, optional): If not specified or True, then the arc length point is\n          calculated from the start of the curve. If False, the arc length\n          point is calculated from the end of the curve.\n    Returns:\n      point: on curve if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          length = rs.CurveLength(obj)\n          point = rs.CurveArcLengthPoint(obj, length/3.0)\n          rs.AddPoint( point )\n    See Also:\n      CurveEndPoint\n      CurveMidPoint\n      CurveStartPoint\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    curve_length = curve.GetLength()\n    if curve_length>=length:\n        s = 0.0\n        if length==0.0: s = 0.0\n        elif length==curve_length: s = 1.0\n        else: s = length / curve_length\n        dupe = curve.Duplicate()\n        if dupe:\n            if from_start==False: dupe.Reverse()\n            rc, t = dupe.NormalizedLengthParameter(s)\n            if rc: return dupe.PointAt(t)\n            dupe.Dispose()\n\n\ndef CurveArea(curve_id):\n    \"\"\"Returns area of closed planar curves. The results are based on the\n    current drawing units.\n    Parameters:\n      curve_id (guid): The identifier of a closed, planar curve object.\n    Returns:\n      list[number, number]: List of area information. The list will contain the following information:\n        Element  Description\n        [0]      The area. If more than one curve was specified, the\n                   value will be the cumulative area.\n        [1]      The absolute (+/-) error bound for the area.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if id:\n          props = rs.CurveArea(id)\n          if props:\n              print(\"The curve area is: {}\".format(props[0]))\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    mp = Rhino.Geometry.AreaMassProperties.Compute(curve, tol)\n    if mp == None: return None\n    return mp.Area, mp.AreaError\n\n\ndef CurveAreaCentroid(curve_id):\n    \"\"\"Returns area centroid of closed, planar curves. The results are based\n    on the current drawing units.\n    Parameters:\n      curve_id (guid)The identifier of a closed, planar curve object.\n    Returns:\n      tuple(point, vector): of area centroid information containing the following information:\n        Element  Description\n        [0]        The 3d centroid point. If more than one curve was specified,\n                 the value will be the cumulative area.\n        [1]        A 3d vector with the absolute (+/-) error bound for the area\n                 centroid.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if id:\n          props = rs.CurveAreaCentroid(id)\n          if props:\n              print(\"The curve area centroid is: {}\".format(props[0]))\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    mp = Rhino.Geometry.AreaMassProperties.Compute(curve, tol)\n    if mp == None: return None\n    return mp.Centroid, mp.CentroidError\n\n\ndef CurveArrows(curve_id, arrow_style=None):\n    \"\"\"Enables or disables a curve object's annotation arrows\n    Parameters:\n      curve_id (guid): identifier of a curve\n      arrow_style (number, optional): the style of annotation arrow to be displayed. If omitted the current type is returned.\n        0 = no arrows\n        1 = display arrow at start of curve\n        2 = display arrow at end of curve\n        3 = display arrow at both start and end of curve\n      Returns:\n        number: if arrow_style is not specified, the current annotation arrow style\n        number: if arrow_style is specified, the previous arrow style\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.CurveArrows(obj)!=3: rs.CurveArrows(obj, 3)\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rhobj = rhutil.coercerhinoobject(curve_id, True, True)\n    attr = rhobj.Attributes\n    rc = attr.ObjectDecoration\n    none_obj_decor = compat.ENUM_NONE(Rhino.DocObjects.ObjectDecoration)\n    if arrow_style is not None:\n        if arrow_style==0:\n            attr.ObjectDecoration = none_obj_decor\n        elif arrow_style==1:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.StartArrowhead\n        elif arrow_style==2:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.EndArrowhead\n        elif arrow_style==3:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.BothArrowhead\n        id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.ModifyAttributes(id, attr, True)\n        scriptcontext.doc.Views.Redraw()\n    if rc==none_obj_decor: return 0\n    if rc==Rhino.DocObjects.ObjectDecoration.StartArrowhead: return 1\n    if rc==Rhino.DocObjects.ObjectDecoration.EndArrowhead: return 2\n    if rc==Rhino.DocObjects.ObjectDecoration.BothArrowhead: return 3\n\n\ndef CurveBooleanDifference(curve_id_0, curve_id_1, tolerance=None):\n    \"\"\"Calculates the difference between two closed, planar curves and\n    adds the results to the document. Note, curves must be coplanar.\n    Parameters:\n      curve_id_0 (guid): identifier of the first curve object.\n      curve_id_1 (guid): identifier of the second curve object.\n      tolerance (float, optional): a positive tolerance value, or None for the doc default.\n    Returns:\n      list(guid, ...): The identifiers of the new objects if successful, None on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curveA = rs.GetObject(\"Select first curve\", rs.filter.curve)\n      curveB = rs.GetObject(\"Select second curve\", rs.filter.curve)\n      arrResult = rs.CurveBooleanDifference(curveA, curveB)\n      if arrResult:\n          rs.DeleteObject( curveA )\n          rs.DeleteObject( curveB )\n    See Also:\n      CurveBooleanIntersection\n      CurveBooleanUnion\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    out_curves = Rhino.Geometry.Curve.CreateBooleanDifference(curve0, curve1, tolerance)\n    curves = []\n    if out_curves:\n        for curve in out_curves:\n            if curve and curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n                curve.Dispose()\n                if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n                curves.append(rc)\n    scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef CurveBooleanIntersection(curve_id_0, curve_id_1, tolerance=None):\n    \"\"\"Calculates the intersection of two closed, planar curves and adds\n    the results to the document. Note, curves must be coplanar.\n    Parameters:\n      curve_id_0 (guid): identifier of the first curve object.\n      curve_id_1 (guid): identifier of the second curve object.\n      tolerance (float, optional): a positive tolerance value, or None for the doc default.\n    Returns:\n      list(guid, ...): The identifiers of the new objects.\n    Example:\n      import rhinoscriptsyntax as rs\n      curveA = rs.GetObject(\"Select first curve\", rs.filter.curve)\n      curveB = rs.GetObject(\"Select second curve\", rs.filter.curve)\n      result = rs.CurveBooleanIntersection(curveA, curveB)\n      if result:\n          rs.DeleteObject( curveA )\n          rs.DeleteObject( curveB )\n    See Also:\n      CurveBooleanDifference\n      CurveBooleanUnion\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    out_curves = Rhino.Geometry.Curve.CreateBooleanIntersection(curve0, curve1, tolerance)\n    curves = []\n    if out_curves:\n        for curve in out_curves:\n            if curve and curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n                curve.Dispose()\n                if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n                curves.append(rc)\n    scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef CurveBooleanUnion(curve_id, tolerance=None):\n    \"\"\"Calculate the union of two or more closed, planar curves and\n    add the results to the document. Note, curves must be coplanar.\n    Parameters:\n      curve_id ([guid, guid, ...])list of two or more close planar curves identifiers\n      tolerance (float, optional): a positive tolerance value, or None for the doc default.\n    Returns:\n      list(guid, ...): The identifiers of the new objects.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve_ids = rs.GetObjects(\"Select curves to union\", rs.filter.curve)\n      if curve_ids and len(curve_ids)>1:\n          result = rs.CurveBooleanUnion(curve_ids)\n          if result: rs.DeleteObjects(curve_ids)\n    See Also:\n      CurveBooleanDifference\n      CurveBooleanIntersection\n    \"\"\"\n    in_curves = [rhutil.coercecurve(id,-1,True) for id in curve_id]\n    if len(in_curves)<2: raise ValueException(\"curve_id must have at least 2 curves\")\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    out_curves = Rhino.Geometry.Curve.CreateBooleanUnion(in_curves, tolerance)\n    curves = []\n    if out_curves:\n        for curve in out_curves:\n            if curve and curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n                curve.Dispose()\n                if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n                curves.append(rc)\n        scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef CurveBrepIntersect(curve_id, brep_id, tolerance=None):\n    \"\"\"Intersects a curve object with a brep object. Note, unlike the\n    CurveSurfaceIntersection function, this function works on trimmed surfaces.\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      brep_id (guid): identifier of a brep object\n      tolerance (number, optional): distance tolerance at segment midpoints.\n                        If omitted, the current absolute tolerance is used.\n    Returns:\n      list(guid, ...): identifiers for the newly created intersection objects if successful.\n      None: on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if curve:\n          brep = rs.GetObject(\"Select a brep\", rs.filter.surface + rs.filter.polysurface)\n          if brep: rs.CurveBrepIntersect( curve, brep )\n    See Also:\n      CurveSurfaceIntersection\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    brep = rhutil.coercebrep(brep_id, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, out_curves, out_points = Rhino.Geometry.Intersect.Intersection.CurveBrep(curve, brep, tolerance)\n    if not rc: return scriptcontext.errorhandler()\n    \n    curves = []\n    points = []\n    for curve in out_curves:\n        if curve and curve.IsValid:\n            rc = scriptcontext.doc.Objects.AddCurve(curve)\n            curve.Dispose()\n            if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n            curves.append(rc)\n    for point in out_points:\n        if point and point.IsValid:\n            rc = scriptcontext.doc.Objects.AddPoint(point)\n            points.append(rc)\n    if not curves and not points: return None\n    scriptcontext.doc.Views.Redraw()\n    return curves, points\n\n\ndef CurveClosestObject(curve_id, object_ids):\n    \"\"\"Returns the 3D point locations on two objects where they are closest to\n    each other. Note, this function provides similar functionality to that of\n    Rhino's ClosestPt command.\n    Parameters:\n      curve_id (guid):identifier of the curve object to test\n      object_ids ([guid, ...]) list of identifiers of point cloud, curve, surface, or\n        polysurface to test against\n    Returns:\n      tuple[guid, point, point]: containing the results of the closest point calculation.\n      The elements are as follows:\n        [0]    The identifier of the closest object.\n        [1]    The 3-D point that is closest to the closest object.\n        [2]    The 3-D point that is closest to the test curve.\n    Example:\n      import rhinoscriptsyntax as rs\n      filter = rs.filter.curve | rs.filter.pointcloud | rs.filter.surface | rs.filter.polysurface\n      objects = rs.GetObjects(\"Select target objects for closest point\", filter)\n      if objects:\n          curve = rs.GetObject(\"Select curve\")\n          if curve:\n              results = rs.CurveClosestObject(curve, objects)\n              if results:\n                  print(\"Curve id: {}\".format(results[0]))\n                  rs.AddPoint( results[1] )\n                  rs.AddPoint( results[2] )\n    See Also:\n      CurveClosestPoint\n      EvaluateCurve\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id,-1,True)\n    geometry = []\n    id = rhutil.coerceguid(object_ids, False)\n    if id: object_ids = [id]\n    for object_id in object_ids:\n        rhobj = rhutil.coercerhinoobject(object_id, True, True)\n        geometry.append( rhobj.Geometry )\n    if not geometry: raise ValueError(\"object_ids must contain at least one item\")\n    success, curve_point, geom_point, which_geom = curve.ClosestPoints(geometry, 0.0)\n    if success: return object_ids[which_geom], geom_point, curve_point\n\n    \ndef CurveClosestPoint(curve_id, test_point, segment_index=-1 ):\n    \"\"\"Returns parameter of the point on a curve that is closest to a test point.\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      point (point): sampling point\n      segment_index (number, optional): curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The parameter of the closest point on the curve\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a curve\")\n      if id:\n          point = rs.GetPointOnCurve(id, \"Pick a test point\")\n          if point:\n              param = rs.CurveClosestPoint(id, point)\n              print(\"Curve parameter: {}\".format(param))\n    See Also:\n      EvaluateCurve\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    point = rhutil.coerce3dpoint(test_point, True)\n    rc, t = curve.ClosestPoint(point, 0.0)\n    if not rc: raise Exception(\"ClosestPoint failed\")\n    return t\n\n\ndef CurveContourPoints(curve_id, start_point, end_point, interval=None):\n    \"\"\"Returns the 3D point locations calculated by contouring a curve object.\n    Parameters:\n      curve_id (guid): identifier of a curve object.\n      start_point (point): 3D starting point of a center line.\n      end_point (point): 3D ending point of a center line.\n      interval (number, optional): The distance between contour curves. If omitted,\n      the interval will be equal to the diagonal distance of the object's\n      bounding box divided by 50.\n    Returns:\n      list(point, ....): A list of 3D points, one for each contour\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      start_point = rs.GetPoint(\"Base point of center line\")\n      end_point = rs.GetPoint(\"Endpoint of center line\", start_point)\n      contour = rs.CurveContourPoints(obj, start_point, end_point)\n      if contour: rs.AddPoints(contour)\n    See Also:\n      AddSrfContourCrvs\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    start_point = rhutil.coerce3dpoint(start_point, True)\n    end_point = rhutil.coerce3dpoint(end_point, True)\n    if start_point.DistanceTo(end_point)<Rhino.RhinoMath.ZeroTolerance:\n        raise Exception(\"start and end point are too close to define a line\")\n    if not interval:\n        bbox = curve.GetBoundingBox(True)\n        diagonal = bbox.Max - bbox.Min\n        interval = diagonal.Length / 50.0\n    rc = curve.DivideAsContour( start_point, end_point, interval )\n    return list(rc)\n\n\ndef CurveCurvature(curve_id, parameter):\n    \"\"\"Returns the curvature of a curve at a parameter. See the Rhino help for\n    details on curve curvature\n    Parameters:\n      curve_id (guid): identifier of the curve\n      parameter (number): parameter to evaluate\n    Returns:\n      tuple[point, vector, point, number, vector]: of curvature information on success\n        [0] = point at specified parameter\n        [1] = tangent vector\n        [2] = center of radius of curvature\n        [3] = radius of curvature\n        [4] = curvature vector\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          point = rs.GetPointOnCurve(obj, \"Pick a test point\")\n          if point:\n              param = rs.CurveClosestPoint(obj, point)\n              if param:\n                  data = rs.CurveCurvature(obj, param)\n                  if data:\n                      print(\"Curve curvature evaluation at parameter {}\".format(param, \":\"))\n                      print(\" 3-D Point: {}\".format(data[0]))\n                      print(\" 3-D Tangent: {}\".format(data[1]))\n                      print(\" Center of radius of curvature: {}\".format(data[2]))\n                      print(\" Radius of curvature: {}\".format(data[3]))\n                      print(\" 3-D Curvature: {}\".format(data[4]))\n    See Also:\n      SurfaceCurvature\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    point = curve.PointAt(parameter)\n    tangent = curve.TangentAt(parameter)\n    if tangent.IsTiny(0): return scriptcontext.errorhandler()\n    cv = curve.CurvatureAt(parameter)\n    k = cv.Length\n    if k<Rhino.RhinoMath.SqrtEpsilon: return scriptcontext.errorhandler()\n    rv = cv / (k*k)\n    circle = Rhino.Geometry.Circle(point, tangent, point + 2.0*rv)\n    center = point + rv\n    radius = circle.Radius\n    return point, tangent, center, radius, cv\n\n\ndef CurveCurveIntersection(curveA, curveB=None, tolerance=-1):\n    \"\"\"Calculates intersection of two curve objects.\n    Parameters:\n      curveA (guid): identifier of the first curve object.\n      curveB  (guid, optional): identifier of the second curve object. If omitted, then a\n               self-intersection test will be performed on curveA.\n      tolerance (number, optional): absolute tolerance in drawing units. If omitted,\n                        the document's current absolute tolerance is used.\n    Returns:\n      list of tuples: containing intersection information if successful.\n      The list will contain one or more of the following elements:\n        Element Type     Description\n        [n][0]  Number   The intersection event type, either Point (1) or Overlap (2).\n        [n][1]  Point3d  If the event type is Point (1), then the intersection point \n                         on the first curve. If the event type is Overlap (2), then\n                         intersection start point on the first curve.\n        [n][2]  Point3d  If the event type is Point (1), then the intersection point\n                         on the first curve. If the event type is Overlap (2), then\n                         intersection end point on the first curve.\n        [n][3]  Point3d  If the event type is Point (1), then the intersection point \n                         on the second curve. If the event type is Overlap (2), then\n                         intersection start point on the second curve.\n        [n][4]  Point3d  If the event type is Point (1), then the intersection point\n                         on the second curve. If the event type is Overlap (2), then\n                         intersection end point on the second curve.\n        [n][5]  Number   If the event type is Point (1), then the first curve parameter.\n                         If the event type is Overlap (2), then the start value of the\n                         first curve parameter range.\n        [n][6]  Number   If the event type is Point (1), then the first curve parameter.\n                         If the event type is Overlap (2), then the end value of the\n                         first curve parameter range.\n        [n][7]  Number   If the event type is Point (1), then the second curve parameter.\n                         If the event type is Overlap (2), then the start value of the\n                         second curve parameter range.\n        [n][8]  Number   If the event type is Point (1), then the second curve parameter.\n                         If the event type is Overlap (2), then the end value of the \n                         second curve parameter range.\n    Example:\n      import rhinoscriptsyntax as rs\n      def ccx():\n          curve1 = rs.GetObject(\"Select first curve\", rs.filter.curve)\n          if curve1 is None: return\n          curve2 = rs.GetObject(\"Select second curve\", rs.filter.curve)\n          if curve2 is None: return\n          intersection_list = rs.CurveCurveIntersection(curve1, curve2)\n          if intersection_list is None:\n              print(\"Selected curves do not intersect.\")\n              return\n          for intersection in intersection_list:\n              if intersection[0] == 1:\n                  print(\"Point\")\n                  print(\"Intersection point on first curve:  {}\".format(intersection[1]))\n                  print(\"Intersection point on second curve:  {}\".format(intersection[3]))\n                  print(\"First curve parameter:  {}\".format(intersection[5]))\n                  print(\"Second curve parameter:  {}\".format(intersection[7]))\n              else:\n                  print(\"Overlap\")\n                  print(\"Intersection start point on first curve: {}\".format(intersection[1]))\n                  print(\"Intersection end point on first curve: {}\".format(intersection[2]))\n                  print(\"Intersection start point on second curve: {}\".format(intersection[3]))\n                  print(\"Intersection end point on second curve: {}\".format(intersection[4]))\n                  print(\"First curve parameter range: {} to {}\".format(intersection[5], intersection[6]))\n                  print(\"Second curve parameter range: {} to {}\".format(intersection[7], intersection[8]))\n      ccx()\n    See Also:\n      CurveSurfaceIntersection\n    \"\"\"\n    curveA = rhutil.coercecurve(curveA, -1, True)\n    if curveB: curveB = rhutil.coercecurve(curveB, -1, True)\n    if tolerance is None or tolerance<0.0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if curveB:\n        rc = Rhino.Geometry.Intersect.Intersection.CurveCurve(curveA, curveB, tolerance, 0.0)\n    else:\n        rc = Rhino.Geometry.Intersect.Intersection.CurveSelf(curveA, tolerance)\n    if rc:\n        events = []\n        for i in compat.RANGE(rc.Count):\n            event_type = 1\n            if( rc[i].IsOverlap ): event_type = 2\n            oa = rc[i].OverlapA\n            ob = rc[i].OverlapB\n            element = (event_type, rc[i].PointA, rc[i].PointA2, rc[i].PointB, rc[i].PointB2, oa[0], oa[1], ob[0], ob[1])\n            events.append(element)\n        return events\n\n\ndef CurveDegree(curve_id, segment_index=-1):\n    \"\"\"Returns the degree of a curve object.\n    Parameters:\n      curve_id (guid): identifier of a curve object.\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve.\n    Returns:\n      number: The degree of the curve if successful.\n      None: on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          degree = rs.CurveDegree(obj)\n          print(\"Curve degree:{}\".format(degree))\n    See Also:\n      CurveDomain\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.Degree\n\n\ndef CurveDeviation(curve_a, curve_b):\n    \"\"\"Returns the minimum and maximum deviation between two curve objects\n    Parameters:\n      curve_a, curve_b (guid): identifiers of two curves\n    Returns:\n      tuple[number, number, number, number, number, number]: of deviation information on success\n        [0] = curve_a parameter at maximum overlap distance point\n        [1] = curve_b parameter at maximum overlap distance point\n        [2] = maximum overlap distance\n        [3] = curve_a parameter at minimum overlap distance point\n        [4] = curve_b parameter at minimum overlap distance point\n        [5] = minimum distance between curves\n      None on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curveA = rs.GetObject(\"Select first curve to test\", rs.filter.curve)\n      curveB = rs.GetObject(\"Select second curve to test\", rs.filter.curve)\n      deviation = rs.CurveDeviation(curveA, curveB)\n      if deviation:\n          print(\"Minimum deviation = {}\".format(deviation[5]))\n          print(\"Maximum deviation = {}\".format(deviation[2]))\n    See Also:\n      CurveArea\n      CurveAreaCentroid\n    \"\"\"\n    curve_a = rhutil.coercecurve(curve_a, -1, True)\n    curve_b = rhutil.coercecurve(curve_b, -1, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc = Rhino.Geometry.Curve.GetDistancesBetweenCurves(curve_a, curve_b, tol)\n    if not rc[0]: return scriptcontext.errorhandler()\n    maxa = rc[2]\n    maxb = rc[3]\n    maxd = rc[1]\n    mina = rc[5]\n    minb = rc[6]\n    mind = rc[4]\n    return maxa, maxb, maxd, mina, minb, mind\n\n\ndef CurveDim(curve_id, segment_index=-1):\n    \"\"\"Returns the dimension of a curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object.\n      segment_index (number, optional): the curve segment if `curve_id` identifies a polycurve.\n    Returns:\n      number: The dimension of the curve if successful. None on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(curve):\n          print(\"Curve dimension = {}\".format(rs.CurveDim(curve)))\n    See Also:\n      CurveDegree\n      CurveDomain\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.Dimension\n\n\ndef CurveDirectionsMatch(curve_id_0, curve_id_1):\n    \"\"\"Tests if two curve objects are generally in the same direction or if they\n    would be more in the same direction if one of them were flipped. When testing\n    curve directions, both curves must be either open or closed - you cannot test\n    one open curve and one closed curve.\n    Parameters:\n      curve_id_0 (guid): identifier of first curve object\n      curve_id_1 (guid): identifier of second curve object\n    Returns:\n      bool: True if the curve directions match, otherwise False.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve1 = rs.GetObject(\"Select first curve to compare\", rs.filter.curve)\n      curve2 = rs.GetObject(\"Select second curve to compare\", rs.filter.curve)\n      if rs.CurveDirectionsMatch(curve1, curve2):\n          print(\"Curves are in the same direction\")\n      else:\n          print(\"Curve are not in the same direction\")\n    See Also:\n      ReverseCurve\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    return Rhino.Geometry.Curve.DoDirectionsMatch(curve0, curve1)\n\n\ndef CurveDiscontinuity(curve_id, style):   \n    \"\"\"Search for a derivatitive, tangent, or curvature discontinuity in\n    a curve object.\n    Parameters:\n      curve_id (guid): identifier of curve object\n      style (number): The type of continuity to test for. The types of\n          continuity are as follows:\n          Value    Description\n          1        C0 - Continuous function\n          2        C1 - Continuous first derivative\n          3        C2 - Continuous first and second derivative\n          4        G1 - Continuous unit tangent\n          5        G2 - Continuous unit tangent and curvature\n    Returns:\n      list(point, ...): 3D points where the curve is discontinuous\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.IsCurve(curve):\n          points = rs.CurveDiscontinuity(curve, 2)\n          if points: rs.AddPoints( points )\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    dom = curve.Domain\n    t0 = dom.Min\n    t1 = dom.Max\n    points = []\n    get_next = True\n    while get_next:\n        get_next, t = curve.GetNextDiscontinuity(System.Enum.ToObject(Rhino.Geometry.Continuity, style), t0, t1)\n        if get_next:\n            points.append(curve.PointAt(t))\n            t0 = t # Advance to the next parameter\n    return points\n\n\ndef CurveDomain(curve_id, segment_index=-1):\n    \"\"\"Returns the domain of a curve object\n    as an indexable object with two elements.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve.\n    Returns:\n      list(number, number): the domain of the curve if successful.\n         [0] Domain minimum\n         [1] Domain maximum\n      None: on error\n\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          domain = rs.CurveDomain(obj)\n          print(\"Curve domain: {} to {}\".format(domain[0], domain[1]))\n    See Also:\n      CurveDegree\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.Domain\n\n\ndef CurveEditPoints(curve_id, return_parameters=False, segment_index=-1):\n    \"\"\"Returns the edit, or Greville, points of a curve object. \n    For each curve control point, there is a corresponding edit point.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      return_parameters (bool, optional): if True, return as a list of curve parameters.\n                                          If False, return as a list of 3d points\n      segment_index (number, optional): the curve segment index is `curve_id` identifies a polycurve\n    Returns:\n      list(point, ....): curve edit points on success\n      None on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          points = rs.CurveEditPoints(obj)\n          if points: rs.AddPointCloud( points )\n    See Also:\n      IsCurve\n      CurvePointCount\n      CurvePoints\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if not nc: return scriptcontext.errorhandler()\n    if return_parameters: return nc.GrevilleParameters()\n    return list(nc.GrevillePoints())\n\n\ndef CurveEndPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the end point of a curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: The 3d endpoint of the curve if successful.\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          point = rs.CurveEndPoint(object)\n          rs.AddPoint(point)\n    See Also:\n      CurveMidPoint\n      CurveStartPoint\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.PointAtEnd\n\n\ndef CurveFilletPoints(curve_id_0, curve_id_1, radius=1.0, base_point_0=None, base_point_1=None, return_points=True):\n    \"\"\"Find points at which to cut a pair of curves so that a fillet of a\n    specified radius fits. A fillet point is a pair of points (point0, point1)\n    such that there is a circle of radius tangent to curve curve0 at point0 and\n    tangent to curve curve1 at point1. Of all possible fillet points, this\n    function returns the one which is the closest to the base point base_point_0,\n    base_point_1. Distance from the base point is measured by the sum of arc\n    lengths along the two curves. \n    Parameters:\n      curve_id_0 (guid): identifier of the first curve object.\n      curve_id_1 (guid): identifier of the second curve object.\n      radius (number, optional): The fillet radius. If omitted, a radius\n                     of 1.0 is specified.\n      base_point_0 (point, optional): The base point on the first curve.\n                     If omitted, the starting point of the curve is used.\n      base_point_1 (point, optional): The base point on the second curve. If omitted,\n                     the starting point of the curve is used.\n      return_points (bool, optional): If True (Default), then fillet points are\n                     returned. Otherwise, a fillet curve is created and\n                     it's identifier is returned.\n    Returns:\n      list(point, point, point, vector, vector, vector): If return_points is True, then a list of point and vector values\n      if successful. The list elements are as follows:\n          [0]    A point on the first curve at which to cut (point).\n          [1]    A point on the second curve at which to cut (point).\n          [2]    The fillet plane's origin (point). This point is also\n                   the center point of the fillet\n          [3]    The fillet plane's X axis (vector).\n          [4]    The fillet plane's Y axis (vector).\n          [5]    The fillet plane's Z axis (vector).\n      \n      guid: If return_points is False, then the identifier of the fillet curve\n            if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve0 = rs.AddLine([0,0,0], [5,1,0])\n      curve1 = rs.AddLine([0,0,0], [1,5,0])\n      fillet = rs.CurveFilletPoints(curve0, curve1)\n      if fillet:\n          rs.AddPoint( fillet[0] )\n          rs.AddPoint( fillet[1] )\n          rs.AddPoint( fillet[2] )\n    See Also:\n      AddFilletCurve\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    t0_base = curve0.Domain.Min\n    \n    if base_point_0:\n        rc = curve0.ClosestPoint(base_point_0, t0_base)\n        if not rc[0]: return scriptcontext.errorhandler()\n    \n    t1_base = curve1.Domain.Min\n    if base_point_1:\n        rc = curve1.ClosestPoint(base_point_1, t1_base)\n        if not rc[0]: return scriptcontext.errorhandler()\n\n    r = radius if (radius and radius>0) else 1.0\n    rc = Rhino.Geometry.Curve.GetFilletPoints(curve0, curve1, r, t0_base, t1_base)\n    if rc[0]:\n        point_0 = curve0.PointAt(rc[1])\n        point_1 = curve1.PointAt(rc[2])\n        return point_0, point_1, rc[3].Origin, rc[3].XAxis, rc[3].YAxis, rc[3].ZAxis\n    return scriptcontext.errorhandler()\n\n\ndef CurveFrame(curve_id, parameter, segment_index=-1):\n    \"\"\"Returns the plane at a parameter of a curve. The plane is based on the\n    tangent and curvature vectors at a parameter.\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n      parameter (number): parameter to evaluate.\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      plane: The plane at the specified parameter if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetCurveObject(\"Select a curve\")\n      if curve:\n          plane = rs.CurveFrame(curve[0], curve[4])\n          rs.AddPlaneSurface(plane, 5.0, 3.0)\n    See Also:\n      CurvePerpFrame\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    domain = curve.Domain\n    if not domain.IncludesParameter(parameter):\n        tol = scriptcontext.doc.ModelAbsoluteTolerance\n        if parameter>domain.Max and (parameter-domain.Max)<=tol:\n            parameter = domain.Max\n        elif parameter<domain.Min and (domain.Min-parameter)<=tol:\n            parameter = domain.Min\n        else:\n            return scriptcontext.errorhandler()\n    rc, frame = curve.FrameAt(parameter)\n    if rc and frame.IsValid: return frame\n    return scriptcontext.errorhandler()\n\n\ndef CurveKnotCount(curve_id, segment_index=-1):\n    \"\"\"Returns the knot count of a curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n      segment_index (number, optional): the curve segment if `curve_id` identifies a polycurve.\n    Returns:\n      number: The number of knots if successful.\n      None: if not successful or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          count = rs.CurveKnotCount(obj)\n          print(\"Curve knot count:{}\".format(count))\n    See Also:\n      DivideCurve\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if not nc: return scriptcontext.errorhandler()\n    return nc.Knots.Count\n\n\ndef CurveKnots(curve_id, segment_index=-1):\n    \"\"\"Returns the knots, or knot vector, of a curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve.\n    Returns:\n      list(number, ....): knot values if successful.\n      None: if not successful or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          knots = rs.CurveKnots(obj)\n          if knots:\n              for knot in knots: print(\"Curve knot value:{}\".format(knot))\n    See Also:\n      CurveKnotCount\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if not nc: return scriptcontext.errorhandler()\n    rc = [nc.Knots[i] for i in range(nc.Knots.Count)]\n    return rc\n\n\ndef CurveLength(curve_id, segment_index=-1, sub_domain=None):\n    \"\"\"Returns the length of a curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n      sub_domain ([number, number], optional): list of two numbers identifying the sub-domain of the\n          curve on which the calculation will be performed. The two parameters\n          (sub-domain) must be non-decreasing. If omitted, the length of the\n          entire curve is returned.\n    Returns:\n      number: The length of the curve if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          length = rs.CurveLength(object)\n          print(\"Curve length:{}\".format(length))\n    See Also:\n      CurveDomain\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    if sub_domain:\n        if len(sub_domain)==2:\n            dom = Rhino.Geometry.Interval(sub_domain[0], sub_domain[1])\n            return curve.GetLength(dom)\n        return scriptcontext.errorhandler()\n    return curve.GetLength()\n\n\ndef CurveMidPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the mid point of a curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: The 3D midpoint of the curve if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          point = rs.CurveMidPoint(pbject)\n          rs.AddPoint( point )\n    See Also:\n      CurveEndPoint\n      CurveStartPoint\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, t = curve.NormalizedLengthParameter(0.5)\n    if rc: return curve.PointAt(t)\n    return scriptcontext.errorhandler()\n\n\ndef CurveNormal(curve_id, segment_index=-1):\n    \"\"\"Returns the normal direction of the plane in which a planar curve object lies.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment if curve_id identifies a polycurve\n    Returns:\n      vector: The 3D normal vector if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a planar curve\")\n      if rs.IsCurve(object) and rs.IsCurvePlanar(object):\n          normal = rs.CurveNormal(object)\n          if normal: print(\"Curve Normal:{}\".format(normal))\n    See Also:\n      IsCurve\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, plane = curve.TryGetPlane(tol)\n    if rc: return plane.Normal\n    return scriptcontext.errorhandler()\n\n\ndef CurveNormalizedParameter(curve_id, parameter):\n    \"\"\"Converts a curve parameter to a normalized curve parameter;\n    one that ranges between 0-1\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): the curve parameter to convert\n    Returns:\n      number: normalized curve parameter\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\")\n      if rs.IsCurve(obj):\n          domain = rs.CurveDomain(obj)\n          parameter = (domain[0]+domain[1])/2.0\n          print(\"Curve parameter:{}\".format(parameter))\n          normalized = rs.CurveNormalizedParameter(obj, parameter)\n          print(\"Normalized parameter:{}\".format(normalized))\n    See Also:\n      CurveDomain\n      CurveParameter\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    return curve.Domain.NormalizedParameterAt(parameter)\n\n\ndef CurveParameter(curve_id, parameter):\n    \"\"\"Converts a normalized curve parameter to a curve parameter;\n    one within the curve's domain\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): the normalized curve parameter to convert\n    Returns:\n      number: curve parameter\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\")\n      if rs.IsCurve(obj):\n          normalized = 0.5\n          print(\"Normalized parameter:{}\".format(normalized))\n          parameter = rs.CurveParameter(obj, normalized)\n          print(\"Curve parameter:{}\".format(parameter))\n    See Also:\n      CurveDomain\n      CurveNormalizedParameter\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    return curve.Domain.ParameterAt(parameter)\n\n\ndef CurvePerpFrame(curve_id, parameter):\n    \"\"\"Returns the perpendicular plane at a parameter of a curve. The result\n    is relatively parallel (zero-twisting) plane\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): parameter to evaluate\n    Returns:\n      plane: Plane on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      crv = rs.GetCurveObject(\"Select a curve\")\n      if crv:\n          plane = rs.CurvePerpFrame(crv[0], crv[4])\n          rs.AddPlaneSurface( plane, 1, 1 )\n    See Also:\n      CurveFrame\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    parameter = float(parameter)\n    rc, plane = curve.PerpendicularFrameAt(parameter)\n    if rc: return plane\n\n\ndef CurvePlane(curve_id, segment_index=-1):\n    \"\"\"Returns the plane in which a planar curve lies. Note, this function works\n    only on planar curves.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      plane: The plane in which the curve lies if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.IsCurvePlanar(curve):\n          plane = rs.CurvePlane(curve)\n          rs.ViewCPlane(None, plane)\n    See Also:\n      IsCurve\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, plane = curve.TryGetPlane(tol)\n    if rc: return plane\n    return scriptcontext.errorhandler()\n\n\ndef CurvePointCount(curve_id, segment_index=-1):\n    \"\"\"Returns the control points count of a curve object.\n    Parameters:\n      curve_id (guid) identifier of the curve object\n      segment_index (number, optional): the curve segment if `curve_id` identifies a polycurve\n    Returns:\n      number: Number of control points if successful.\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          count = rs.CurvePointCount(obj)\n          print(\"Curve point count:{}\".format(count))\n    See Also:\n      DivideCurve\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if nc: return nc.Points.Count\n    return scriptcontext.errorhandler()\n\n\ndef CurvePoints(curve_id, segment_index=-1):\n    \"\"\"Returns the control points, or control vertices, of a curve object.\n    If the curve is a rational NURBS curve, the euclidean control vertices\n    are returned.\n    Parameters:\n      curve_id (guid): the object's identifier\n      segment_index (number, optional): the curve segment if `curve_id` identifies a polycurve\n    Returns:\n      list(point, ...): the control points, or control vertices, of a curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          points = rs.CurvePoints(obj)\n          if points: [rs.AddPoint(pt) for pt in points]\n    See Also:\n      CurvePointCount\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if nc is None: return scriptcontext.errorhandler()\n    points = [nc.Points[i].Location for i in compat.RANGE(nc.Points.Count)]\n    return points\n\n\ndef CurveRadius(curve_id, test_point, segment_index=-1):\n    \"\"\"Returns the radius of curvature at a point on a curve.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      test_point (point): sampling point\n      segment_index (number, optional): the curve segment if curve_id identifies a polycurve\n    Returns:\n      number: The radius of curvature at the point on the curve if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          point = rs.GetPointOnCurve(obj, \"Pick a test point\")\n          if point:\n              radius = rs.CurveRadius(obj, point)\n              print(\"Radius of curvature:{}\".format(radius))\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    point = rhutil.coerce3dpoint(test_point, True)\n    rc, t = curve.ClosestPoint(point, 0.0)\n    if not rc: return scriptcontext.errorhandler()\n    v = curve.CurvatureAt( t )\n    k = v.Length\n    if k>Rhino.RhinoMath.ZeroTolerance: return 1/k\n    return scriptcontext.errorhandler()\n\n\ndef CurveSeam(curve_id, parameter):\n    \"\"\"Adjusts the seam, or start/end, point of a closed curve.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): The parameter of the new start/end point.\n                  Note, if successful, the resulting curve's\n                  domain will start at `parameter`.\n    Returns:\n      bool: True or False indicating success or failure.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select closed curve\", rs.filter.curve)\n      if rs.IsCurveClosed(obj):\n          domain = rs.CurveDomain(obj)\n          parameter = (domain[0] + domain[1])/2.0\n          rs.CurveSeam( obj, parameter )\n    See Also:\n      IsCurve\n      IsCurveClosed\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if (not curve.IsClosed or not curve.Domain.IncludesParameter(parameter)):\n        return False\n    dupe = curve.Duplicate()\n    if dupe:\n        dupe.ChangeClosedCurveSeam(parameter)\n        curve_id = rhutil.coerceguid(curve_id)\n        dupe_obj = scriptcontext.doc.Objects.Replace(curve_id, dupe)\n        return dupe_obj is not None\n    return False\n\n\ndef CurveStartPoint(curve_id, segment_index=-1, point=None):\n    \"\"\"Returns the start point of a curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n      point (point, optional): new start point\n    Returns:\n      point: The 3D starting point of the curve if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          point = rs.CurveStartPoint(object)\n          rs.AddPoint(point)\n    See Also:\n      CurveEndPoint\n      CurveMidPoint\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc = curve.PointAtStart\n    if point:\n        point = rhutil.coerce3dpoint(point, True)\n        if point and curve.SetStartPoint(point):\n            curve_id = rhutil.coerceguid(curve_id, True)\n            scriptcontext.doc.Objects.Replace(curve_id, curve)\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef CurveSurfaceIntersection(curve_id, surface_id, tolerance=-1, angle_tolerance=-1):\n    \"\"\"Calculates intersection of a curve object with a surface object.\n    Note, this function works on the untrimmed portion of the surface.\n    Parameters:\n      curve_id (guid): The identifier of the first curve object.\n      surface_id (guid): The identifier of the second curve object. If omitted,\n          the a self-intersection test will be performed on curve.\n      tolerance (number, optional): The absolute tolerance in drawing units. If omitted,\n          the document's current absolute tolerance is used.\n      angle_tolerance (number, optional) angle tolerance in degrees. The angle\n          tolerance is used to determine when the curve is tangent to the\n          surface. If omitted, the document's current angle tolerance is used.\n    Returns:\n      list(list(point, point, point, point, number, number, number, number, number, number), ...): of intersection information if successful.\n      The list will contain one or more of the following elements:\n        Element Type     Description\n        [n][0]  Number   The intersection event type, either Point(1) or Overlap(2).\n        [n][1]  Point3d  If the event type is Point(1), then the intersection point\n                         on the first curve. If the event type is Overlap(2), then\n                         intersection start point on the first curve.\n        [n][2]  Point3d  If the event type is Point(1), then the intersection point\n                         on the first curve. If the event type is Overlap(2), then\n                         intersection end point on the first curve.\n        [n][3]  Point3d  If the event type is Point(1), then the intersection point\n                         on the second curve. If the event type is Overlap(2), then\n                         intersection start point on the surface.\n        [n][4]  Point3d  If the event type is Point(1), then the intersection point\n                         on the second curve. If the event type is Overlap(2), then\n                         intersection end point on the surface.\n        [n][5]  Number   If the event type is Point(1), then the first curve parameter.\n                         If the event type is Overlap(2), then the start value of the\n                         first curve parameter range.\n        [n][6]  Number   If the event type is Point(1), then the first curve parameter.\n                         If the event type is Overlap(2), then the end value of the\n                         curve parameter range.\n        [n][7]  Number   If the event type is Point(1), then the U surface parameter.\n                         If the event type is Overlap(2), then the U surface parameter\n                         for curve at (n, 5).\n        [n][8]  Number   If the event type is Point(1), then the V surface parameter.\n                         If the event type is Overlap(2), then the V surface parameter\n                         for curve at (n, 5).\n        [n][9]  Number   If the event type is Point(1), then the U surface parameter.\n                         If the event type is Overlap(2), then the U surface parameter\n                         for curve at (n, 6).\n        [n][10] Number   If the event type is Point(1), then the V surface parameter.\n                         If the event type is Overlap(2), then the V surface parameter\n                         for curve at (n, 6).\n    Example:\n      import rhinoscriptsyntax as rs\n      def csx():\n          curve = rs.GetObject(\"Select curve\", rs.filter.curve)\n          if curve is None: return\n          surface = rs.GetObject(\"Select surface\", rs.filter.surface)\n          if surface is None: return\n          intersection_list = rs.CurveSurfaceIntersection(curve, surface)\n          if intersection_list is None:\n              print(\"Curve and surface do not intersect.\")\n              return\n          for intersection in intersection_list:\n              if intersection[0]==1:\n                  print(\"Point\")\n                  print(\"Intersection point on curve:{}\".format(intersection[1]))\n                  print(\"Intersection point on surface:{}\".format(intersection[3]))\n                  print(\"Curve parameter:{}\".format(intersection[5]))\n                  print(\"Surface parameter: {}, {}\".format(intersection[7], intersection[8]))\n              else:\n                  print(\"Overlap\")\n                  print(\"Intersection start point on curve:{}\".format(intersection[1]))\n                  print(\"Intersection end point on curve:{}\".format(intersection[2]))\n                  print(\"Intersection start point on surface:{}\".format(intersection[3]))\n                  print(\"Intersection end point on surface:{}\".format(intersection[4]))\n                  print(\"Curve parameter range: {} to {}\".format(intersection[5], intersection[6]))\n                  print(\"Surface parameter range: {}, {} to {}, {}\".format(intersection[7] intersection[8], intersection[9], intersection[10]))\n      csx()\n    See Also:\n      CurveCurveIntersection\n      CurveBrepIntersect\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    surface = rhutil.coercesurface(surface_id, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if angle_tolerance is None or angle_tolerance<0:\n        angle_tolerance = scriptcontext.doc.ModelAngleToleranceRadians\n    else:\n        angle_tolerance = math.radians(angle_tolerance)\n    rc = Rhino.Geometry.Intersect.Intersection.CurveSurface(curve, surface, tolerance, angle_tolerance)\n    if rc:\n        events = []\n        for i in compat.RANGE(rc.Count):\n            event_type = 2 if rc[i].IsOverlap else 1\n            item = rc[i]\n            oa = item.OverlapA\n            u,v = item.SurfaceOverlapParameter()\n            e = (event_type, item.PointA, item.PointA2, item.PointB, item.PointB2, oa[0], oa[1], u[0], u[1], v[0], v[1])\n            events.append(e)\n        return events\n\n\ndef CurveTangent(curve_id, parameter, segment_index=-1):\n    \"\"\"Returns a 3D vector that is the tangent to a curve at a parameter.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number) parameter to evaluate\n      segment_index (number, optional) the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      vector: A 3D vector if successful.\n      None: on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if obj:\n          point = rs.GetPointOnCurve(obj)\n          if point:\n              param = rs.CurveClosestPoint(obj, point)\n              normal = rs.CurveTangent(obj, param)\n              print(normal)\n    See Also:\n      CurveClosestPoint\n      CurveDomain\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc = Rhino.Geometry.Point3d.Unset\n    if curve.Domain.IncludesParameter(parameter):\n        return curve.TangentAt(parameter)\n    return scriptcontext.errorhandler()\n\n\ndef CurveWeights(curve_id, segment_index=-1):\n    \"\"\"Returns list of weights that are assigned to the control points of a curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The weight values of the curve if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          weights = rs.CurveWeights(obj)\n          if weights:\n              for weight in weights:\n                  print(\"Curve control point weight value:{}\".format(weight))\n    See Also:\n      CurveKnots\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve\n    if type(curve) is not Rhino.Geometry.NurbsCurve:\n        nc = curve.ToNurbsCurve()\n    if nc is None: return scriptcontext.errorhandler()\n    return [pt.Weight for pt in nc.Points]\n\n\ndef DivideCurve(curve_id, segments, create_points=False, return_points=True):\n    \"\"\"Divides a curve object into a specified number of segments.\n    Parameters:\n      curve_id (guid):identifier of the curve object\n      segments (number): The number of segments.\n      create_points (bool, optional): Create the division points. If omitted or False,\n          points are not created.\n      return_points (bool, optional): If omitted or True, points are returned.\n          If False, then a list of curve parameters are returned.\n    Returns:\n      list(point|number, ...): If `return_points` is not specified or True, then a list containing 3D division points.\n      list(point|number, ...): If `return_points` is False, then an array containing division curve parameters.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if obj:\n          points = rs.DivideCurve(obj, 4)\n          for point in points: rs.AddPoint(point)\n    See Also:\n      DivideCurveEquidistant\n      DivideCurveLength\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc = curve.DivideByCount(segments, True)\n    if not rc: return scriptcontext.errorhandler()\n    if return_points or create_points:\n        outputpoints = [curve.PointAt(t) for t in rc]\n        if return_points: rc = outputpoints\n        if create_points:\n            for point in outputpoints:\n                if point.IsValid: scriptcontext.doc.Objects.AddPoint(point)\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef DivideCurveEquidistant(curve_id, distance, create_points=False, return_points=True):\n    \"\"\"Divides a curve such that the linear distance between the points is equal.\n    Parameters:\n      curve_id (guid): the object's identifier\n      distance (number): linear distance between division points\n      create_points (bool, optional): create the division points if True.\n      return_points (bool, optional): If True, return a list of points.\n                                      If False, return a list of curve parameters\n    Returns:\n      list(point|number, ...): points or curve parameters based on the value of return_points\n      none on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if obj:\n          points = rs.DivideCurveEquidistant(obj, 4, True)\n    See Also:\n      DivideCurve\n      DivideCurveLength\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    points = curve.DivideEquidistant(distance)\n    if not points: return scriptcontext.errorhandler()\n    if create_points:\n        for point in points: scriptcontext.doc.Objects.AddPoint(point)\n        scriptcontext.doc.Views.Redraw()\n    if return_points: return points\n    tvals = []\n    for point in points:\n        rc, t = curve.ClosestPoint(point)\n        tvals.append(t)\n    return tvals\n\n\ndef DivideCurveLength(curve_id, length, create_points=False, return_points=True):\n    \"\"\"Divides a curve object into segments of a specified length.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      length (number): The length of each segment.\n      create_points (bool, optional): Create the division points. If omitted or False,\n          points are not created.\n      return_points (bool, optional): If omitted or True, points are returned.\n          If False, then a list of curve parameters are returned.\n    Returns:\n      list(point, ...): If return_points is not specified or True, then a list containing division points.\n      list(number, ...): If return_points is False, then an array containing division curve parameters.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          length = rs.CurveLength(obj) / 4\n          points = rs.DivideCurveLength(obj, length)\n          for point in points: rs.AddPoint(point)\n    See Also:\n      DivideCurve\n      DivideCurveEquidistant\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc = curve.DivideByLength(length, True)\n    if not rc: return scriptcontext.errorhandler()\n    if return_points or create_points:\n        outputpoints = [curve.PointAt(t) for t in rc]\n        if create_points:\n            for point in outputpoints:\n                if (point.IsValid): scriptcontext.doc.Objects.AddPoint(point)\n        if return_points: rc = outputpoints\n    return rc\n\n\ndef EllipseCenterPoint(curve_id):\n    \"\"\"Returns the center point of an elliptical-shaped curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n    Returns:\n      point: The 3D center point of the ellipse if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select ellipse\")\n      if rs.IsEllipse(obj):\n          point = rs.EllipseCenterPoint(obj)\n          rs.AddPoint( point )\n    See Also:\n      IsEllipse\n      EllipseQuadPoints\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc, ellipse = curve.TryGetEllipse()\n    if not rc: raise ValueError(\"curve is not an ellipse\")\n    return ellipse.Plane.Origin\n\n\ndef EllipseQuadPoints(curve_id):\n    \"\"\"Returns the quadrant points of an elliptical-shaped curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n    Returns:\n      list(point, point, point, point): Four points identifying the quadrants of the ellipse\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select ellipse\")\n      if rs.IsEllipse(obj):\n          rs.AddPoints( rs.EllipseQuadPoints(obj) )\n    See Also:\n      IsEllipse\n      EllipseCenterPoint\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc, ellipse = curve.TryGetEllipse()\n    if not rc: raise ValueError(\"curve is not an ellipse\")\n    origin = ellipse.Plane.Origin;\n    xaxis = ellipse.Radius1 * ellipse.Plane.XAxis;\n    yaxis = ellipse.Radius2 * ellipse.Plane.YAxis;\n    return (origin-xaxis, origin+xaxis, origin-yaxis, origin+yaxis)\n\n\ndef EvaluateCurve(curve_id, t, segment_index=-1):\n    \"\"\"Evaluates a curve at a parameter and returns a 3D point\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      t (number): the parameter to evaluate\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: a 3-D point if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          domain = rs.CurveDomain(obj)\n          t = domain[1]/2.0\n          point = rs.EvaluateCurve(obj, t)\n          rs.AddPoint( point )\n    See Also:\n      CurveClosestPoint\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.PointAt(t)\n\n\ndef ExplodeCurves(curve_ids, delete_input=False):\n    \"\"\"Explodes, or un-joins, one curves. Polycurves will be exploded into curve\n    segments. Polylines will be exploded into line segments. ExplodeCurves will\n    return the curves in topological order. \n    Parameters:\n      curve_ids (guid): the curve object(s) to explode.\n      delete_input (bool, optional): Delete input objects after exploding if True.\n    Returns:\n      list(guid, ...): identifying the newly created curve objects\n    Example:\n      import rhinoscriptsyntax as rs\n      crv = rs.GetObject(\"Select curve to explode\", rs.filter.curve)\n      if rs.IsCurve(crv): rs.ExplodeCurves(crv)\n    See Also:\n      IsCurve\n      IsPolyCurve\n      IsPolyline\n      JoinCurves\n    \"\"\"\n    if( type(curve_ids) is list or type(curve_ids) is tuple ): pass\n    else: curve_ids = [curve_ids]\n    rc = []\n    for id in curve_ids:\n        curve = rhutil.coercecurve(id, -1, True)\n        pieces = curve.DuplicateSegments()\n        if pieces:\n            for piece in pieces:\n                rc.append(scriptcontext.doc.Objects.AddCurve(piece))\n            if delete_input:\n                id = rhutil.coerceguid(id, True)\n                scriptcontext.doc.Objects.Delete(id, True)\n    if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ExtendCurve(curve_id, extension_type, side, boundary_object_ids):\n    \"\"\"Extends a non-closed curve object by a line, arc, or smooth extension\n    until it intersects a collection of objects.\n    Parameters:\n      curve_id (guid): identifier of curve to extend\n      extension_type (number):\n        0 = line\n        1 = arc\n        2 = smooth\n      side (number):\n        0=extend from the start of the curve\n        1=extend from the end of the curve\n        2=extend from both the start and the end of the curve\n      boundary_object_ids (guid): curve, surface, and polysurface objects to extend to\n    Returns:\n      guid: The identifier of the new object if successful.\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      filter = rs.filter.curve | rs.filter.surface | rs.filter.polysurface\n      objects = rs.GetObjects(\"Select boundary objects\", filter)\n      if objects:\n          curve = rs.GetObject(\"Select curve to extend\", rs.filter.curve)\n          if curve: rs.ExtendCurve( curve, 2, 1, objects )\n    See Also:\n      ExtendCurveLength\n      ExtendCurvePoint\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if extension_type==0: extension_type = Rhino.Geometry.CurveExtensionStyle.Line\n    elif extension_type==1: extension_type = Rhino.Geometry.CurveExtensionStyle.Arc\n    elif extension_type==2: extension_type = Rhino.Geometry.CurveExtensionStyle.Smooth\n    else: raise ValueError(\"extension_type must be 0, 1, or 2\")\n    \n    if side==0: side = Rhino.Geometry.CurveEnd.Start\n    elif side==1: side = Rhino.Geometry.CurveEnd.End\n    elif side==2: side = Rhino.Geometry.CurveEnd.Both\n    else: raise ValueError(\"side must be 0, 1, or 2\")\n    \n    rhobjs = [rhutil.coercerhinoobject(id) for id in boundary_object_ids]\n    if not rhobjs: raise ValueError(\"boundary_object_ids must contain at least one item\")\n    geometry = [obj.Geometry for obj in rhobjs]\n    newcurve = curve.Extend(side, extension_type, geometry)\n    if newcurve and newcurve.IsValid:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        if scriptcontext.doc.Objects.Replace(curve_id, newcurve):\n            scriptcontext.doc.Views.Redraw()\n            return curve_id\n    return scriptcontext.errorhandler()\n\n\ndef ExtendCurveLength(curve_id, extension_type, side, length):\n    \"\"\"Extends a non-closed curve by a line, arc, or smooth extension for a\n    specified distance\n    Parameters:\n      curve_id (guid): curve to extend\n      extension_type (number):\n        0 = line\n        1 = arc\n        2 = smooth\n      side (number):\n        0=extend from start of the curve\n        1=extend from end of the curve\n        2=Extend from both ends\n      length (number): distance to extend\n    Returns:\n      guid: The identifier of the new object\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select curve to extend\", rs.filter.curve)\n      if curve:\n          length = rs.GetReal(\"Length to extend\", 3.0)\n          if length: rs.ExtendCurveLength( curve, 2, 2, length )\n    See Also:\n      ExtendCurve\n      ExtendCurvePoint\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if extension_type==0: extension_type = Rhino.Geometry.CurveExtensionStyle.Line\n    elif extension_type==1: extension_type = Rhino.Geometry.CurveExtensionStyle.Arc\n    elif extension_type==2: extension_type = Rhino.Geometry.CurveExtensionStyle.Smooth\n    else: raise ValueError(\"extension_type must be 0, 1, or 2\")\n    \n    if side==0: side = Rhino.Geometry.CurveEnd.Start\n    elif side==1: side = Rhino.Geometry.CurveEnd.End\n    elif side==2: side = Rhino.Geometry.CurveEnd.Both\n    else: raise ValueError(\"side must be 0, 1, or 2\")\n    newcurve = None\n    if length<0: newcurve = curve.Trim(side, -length)\n    else: newcurve = curve.Extend(side, length, extension_type)\n    if newcurve and newcurve.IsValid:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        if scriptcontext.doc.Objects.Replace(curve_id, newcurve):\n            scriptcontext.doc.Views.Redraw()\n            return curve_id\n    return scriptcontext.errorhandler()\n\n\ndef ExtendCurvePoint(curve_id, side, point, extension_type=2):\n    \"\"\"Extends a non-closed curve by smooth extension to a point\n    Parameters:\n      curve_id (guid): curve to extend\n      side (number):\n        0=extend from start of the curve\n        1=extend from end of the curve\n      point (guid|point): point to extend to\n      extension_type (number, optional): type of extension\n        0 = Line\n        1 = Arc\n        2 = Smooth\n    Returns:\n      guid: The identifier of the new object if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select curve to extend\", rs.filter.curve)\n      if curve:\n          point = rs.GetPoint(\"Point to extend to\")\n          if point: rs.ExtendCurvePoint(curve, 1, point)\n    See Also:\n      ExtendCurve\n      ExtendCurveLength\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    point = rhutil.coerce3dpoint(point, True)\n    \n    if side==0: side = Rhino.Geometry.CurveEnd.Start\n    elif side==1: side = Rhino.Geometry.CurveEnd.End\n    elif side==2: side = Rhino.Geometry.CurveEnd.Both\n    else: raise ValueError(\"side must be 0, 1, or 2\")\n    \n    if extension_type==0: extension_type = Rhino.Geometry.CurveExtensionStyle.Line\n    elif extension_type==1: extension_type = Rhino.Geometry.CurveExtensionStyle.Arc\n    elif extension_type==2: extension_type = Rhino.Geometry.CurveExtensionStyle.Smooth\n    else: raise ValueError(\"extension_type must be 0, 1, or 2\")\n    \n    newcurve = curve.Extend(side, extension_type, point)\n    if newcurve and newcurve.IsValid:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        if scriptcontext.doc.Objects.Replace( curve_id, newcurve ):\n            scriptcontext.doc.Views.Redraw()\n            return curve_id\n    return scriptcontext.errorhandler()\n\n\ndef FairCurve(curve_id, tolerance=1.0):\n    \"\"\"Fairs a curve. Fair works best on degree 3 (cubic) curves. Fair attempts\n    to remove large curvature variations while limiting the geometry changes to\n    be no more than the specified tolerance. Sometimes several applications of\n    this method are necessary to remove nasty curvature problems.\n    Parameters:\n      curve_id (guid): curve to fair\n      tolerance (number, optional): fairing tolerance\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      curves = rs.GetObjects(\"Select curves to fair\", rs.filter.curve)\n      if curves:\n          [rs.FairCurve(curve) for curve in curves]\n    See Also:\n      \n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    angle_tol = 0.0\n    clamp = 0\n    if curve.IsPeriodic:\n        curve = curve.ToNurbsCurve()\n        clamp = 1\n    newcurve = curve.Fair(tolerance, angle_tol, clamp, clamp, 100)\n    if not newcurve: return False\n    curve_id = rhutil.coerceguid(curve_id, True)\n    if scriptcontext.doc.Objects.Replace(curve_id, newcurve):\n        scriptcontext.doc.Views.Redraw()\n        return True\n    return False\n\n\ndef FitCurve(curve_id, degree=3, distance_tolerance=-1, angle_tolerance=-1):\n    \"\"\"Reduces number of curve control points while maintaining the curve's same\n    general shape. Use this function for replacing curves with many control\n    points. For more information, see the Rhino help for the FitCrv command.\n    Parameters:\n      curve_id (guid): Identifier of the curve object\n      degree (number, optional): The curve degree, which must be greater than 1.\n                     The default is 3.\n      distance_tolerance (number, optional): The fitting tolerance. If distance_tolerance\n          is not specified or <= 0.0, the document absolute tolerance is used.\n      angle_tolerance (number, optional): The kink smoothing tolerance in degrees. If\n          angle_tolerance is 0.0, all kinks are smoothed. If angle_tolerance\n          is > 0.0, kinks smaller than angle_tolerance are smoothed. If\n          angle_tolerance is not specified or < 0.0, the document angle\n          tolerance is used for the kink smoothing.\n    Returns:\n      guid: The identifier of the new object\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      oldCurve = rs.GetObject(\"Select curve to fit\", rs.filter.curve)\n      if oldCurve:\n          newCurve = rs.FitCurve(oldCurve)\n          if newCurve: rs.DeleteObject(oldCurve)\n    See Also:\n      \n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if distance_tolerance is None or distance_tolerance<0:\n        distance_tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if angle_tolerance is None or angle_tolerance<0:\n        angle_tolerance = scriptcontext.doc.ModelAngleToleranceRadians\n    nc = curve.Fit(degree, distance_tolerance, angle_tolerance)\n    if nc:\n        rhobj = rhutil.coercerhinoobject(curve_id)\n        rc = None\n        if rhobj:\n            rc = scriptcontext.doc.Objects.AddCurve(nc, rhobj.Attributes)\n        else:\n            rc = scriptcontext.doc.Objects.AddCurve(nc)\n        if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n        scriptcontext.doc.Views.Redraw()\n        return rc\n    return scriptcontext.errorhandler()\n\n\ndef InsertCurveKnot(curve_id, parameter, symmetrical=False ):\n    \"\"\"Inserts a knot into a curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): parameter on the curve\n      symmetrical (bool, optional): if True, then knots are added on both sides of\n          the center of the curve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve for knot insertion\", rs.filter.curve)\n      if obj:\n          point = rs.GetPointOnCurve(obj, \"Point on curve to add knot\")\n          if point:\n              parameter = rs.CurveClosestPoint(obj, point)\n              rs.InsertCurveKnot( obj, parameter )\n    See Also:\n      CurveKnotCount\n      CurveKnots\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if not curve.Domain.IncludesParameter(parameter): return False\n    nc = curve.ToNurbsCurve()\n    if not nc: return False\n    rc, t = curve.GetNurbsFormParameterFromCurveParameter(parameter)\n    if rc:\n        rc = nc.Knots.InsertKnot(t,1)\n        if rc and symmetrical:\n            domain = nc.Domain\n            t_sym = domain.T1 - t + domain.T0\n            if abs(t_sym)>Rhino.RhinoMath.SqrtEpsilon:\n                rc = nc.Knots.InsertKnot(t_sym,1)\n        if rc:\n            curve_id = rhutil.coerceguid(curve_id)\n            rc = scriptcontext.doc.Objects.Replace(curve_id, nc)\n            if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef IsArc(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is an open arc curve\n    Parameters:\n      curve_id (guid): Identifier of the curve object\n      segment_index (number): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select an arc\")\n      if rs.IsArc(obj):\n          print(\"The object is an arc.\")\n      else:\n          print(\"The object is not an arc.\")\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcCenterPoint\n      ArcMidPoint\n      ArcRadius\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.IsArc() and not curve.IsClosed\n\n\ndef IsCircle(curve_id, tolerance=None):\n    \"\"\"Verifies an object is a circle curve\n    Parameters:\n      curve_id (guid): Identifier of the curve object\n      tolerance (number, optional) If the curve is not a circle, then the tolerance used\n        to determine whether or not the NURBS form of the curve has the\n        properties of a circle. If omitted, Rhino's internal zero tolerance is used\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a circle\")\n      if rs.IsCircle(obj):\n          print(\"The object is a circle.\")\n      else:\n          print(\"The object is not a circle.\")\n    See Also:\n      AddCircle\n      AddCircle3Pt\n      CircleCenterPoint\n      CircleCircumference\n      CircleRadius\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if tolerance is None or tolerance < 0:\n        tolerance = Rhino.RhinoMath.ZeroTolerance\n    return curve.IsCircle(tolerance)\n\n\ndef IsCurve(object_id):\n    \"\"\"Verifies an object is a curve\n    Parameters:\n      object_id (guid): the object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          print(\"The object is a curve.\")\n      else:\n          print(\"The object is not a curve.\")\n    See Also:\n      IsCurveClosed\n      IsCurveLinear\n      IsCurvePeriodic\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(object_id)\n    return curve is not None\n\n\ndef IsCurveClosable(curve_id, tolerance=None):\n    \"\"\"Decide if it makes sense to close off the curve by moving the end point\n    to the start point based on start-end gap size and length of curve as\n    approximated by chord defined by 6 points\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      tolerance[opt] = maximum allowable distance between start point and end\n        point. If omitted, the document's current absolute tolerance is used\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      crv = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if not rs.IsCurveClosed(crv) and rs.IsCurveClosable(crv):\n          rs.CloseCurve( crv, 0.1 )\n    See Also:\n      CloseCurve\n      IsCurveClosed\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if tolerance is None: tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    return curve.IsClosable(tolerance)\n\n\ndef IsCurveClosed(object_id):\n    \"\"\"Verifies an object is a closed curve object\n    Parameters:\n      object_id (guid): the object's identifier\n    Returns:\n      bool: True if successful otherwise False.  None on error\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          if rs.IsCurveClosed(oObject):\n              print(\"The object is a closed curve.\")\n          else:\n              print(\"The object is not a closed curve.\")\n      else:\n          print(\"The object is not a curve.\")\n    See Also:\n      IsCurve\n      IsCurveLinear\n      IsCurvePeriodic\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(object_id)\n    return None if not curve else curve.IsClosed\n\n\ndef IsCurveInPlane(object_id, plane=None):\n    \"\"\"Test a curve to see if it lies in a specific plane\n    Parameters:\n      object_id (guid): the object's identifier\n      plane (plane, optional): plane to test. If omitted, the active construction plane is used\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj) and rs.IsCurvePlanar(obj):\n          if rs.IsCurveInPlane(obj):\n              print(\"The curve lies in the current cplane.\")\n          else:\n              print(\"The curve does not lie in the current cplane.\")\n      else:\n          print(\"The object is not a planar curve.\")\n    See Also:\n      IsCurve\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, -1, True)\n    if not plane:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    else:\n        plane = rhutil.coerceplane(plane, True)\n    return curve.IsInPlane(plane, scriptcontext.doc.ModelAbsoluteTolerance)\n\n\ndef IsCurveLinear(object_id, segment_index=-1):\n    \"\"\"Verifies an object is a linear curve\n    Parameters:\n      curve_id (guid):identifier of the curve object\n      segment_index (number): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(id):\n          if rs.IsCurveLinear(id):\n              print(\"The object is a linear curve.\")\n          else:\n              print(\"The object is not a linear curve.\")\n      else:\n          print(\"The object is not a curve.\")\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurvePeriodic\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return curve.IsLinear()\n\n\ndef IsCurvePeriodic(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a periodic curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          if rs.IsCurvePeriodic(obj):\n              print(\"The object is a periodic curve.\")\n          else:\n              print(\"The object is not a periodic curve.\")\n      else:\n          print(\"The object is not a curve.\")\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurveLinear\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.IsPeriodic\n\n\ndef IsCurvePlanar(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a planar curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          if rs.IsCurvePlanar(obj):\n              print(\"The object is a planar curve.\")\n          else:\n              print(\"The object is not a planar curve.\")\n      else:\n          print(\"The object is not a curve.\")\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurveLinear\n      IsCurvePeriodic\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    return curve.IsPlanar(tol)\n\n\ndef IsCurveRational(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a rational NURBS curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          if rs.IsCurveRational(obj):\n              print(\"The object is a rational NURBS curve.\")\n          else:\n              print(\"The object is not a rational NURBS curve.\")\n      else:\n          print(\"The object is not a curve.\")\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurveLinear\n      IsCurvePeriodic\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    if isinstance(curve, Rhino.Geometry.NurbsCurve): return curve.IsRational\n    return False\n\n\ndef IsEllipse(object_id, segment_index=-1):\n    \"\"\"Verifies an object is an elliptical-shaped curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select an ellipse\")\n      if rs.IsEllipse(obj):\n          print(\"The object is an ellipse.\")\n      else:\n          print(\"The object is not an ellipse.\")\n    See Also:\n      EllipseCenterPoint\n      EllipseQuadPoints\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return curve.IsEllipse()\n\n\ndef IsLine(object_id, segment_index=-1):\n    \"\"\"Verifies an object is a line curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a line\")\n      if rs.IsLine(obj):\n          print(\"The object is a line.\")\n      else:\n          print(\"The object is not a line.\")\n    See Also:\n      AddLine\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    if isinstance(curve, Rhino.Geometry.LineCurve): return True\n    rc, polyline = curve.TryGetPolyline()\n    if rc and polyline.Count==2: return True\n    return False\n\n\ndef IsPointOnCurve(object_id, point, segment_index=-1):\n    \"\"\"Verifies that a point is on a curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      point (point): the test point\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          point = rs.GetPoint(\"Pick a test point\")\n          if point:\n              if rs.IsPointOnCurve(obj, point):\n                  print(\"The point is on the curve\")\n              else:\n                  print(\"The point is not on the curve\")\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    point = rhutil.coerce3dpoint(point, True)\n    rc, t = curve.ClosestPoint(point, Rhino.RhinoMath.SqrtEpsilon)\n    return rc\n\n\ndef IsPolyCurve(object_id, segment_index=-1):\n    \"\"\"Verifies an object is a PolyCurve curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional) the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polycurve\")\n      if rs.IsPolyCurve(obj):\n          print(\"The object is a polycurve.\")\n      else:\n          print(\"The object is not a polycurve.\")\n    See Also:\n      PolyCurveCount\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return isinstance(curve, Rhino.Geometry.PolyCurve)\n\n\ndef IsPolyline( object_id, segment_index=-1 ):\n    \"\"\"Verifies an object is a Polyline curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polyline\")\n      if rs.IsPolyline(obj):\n          print(\"The object is a polyline.\")\n      else:\n          print(\"The object is not a polyline.\")\n    See Also:\n      IsPolyline\n      PolylineVertices\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return isinstance(curve, Rhino.Geometry.PolylineCurve)\n\n\ndef JoinCurves(object_ids, delete_input=False, tolerance=None):\n    \"\"\"Joins multiple curves together to form one or more curves or polycurves\n    Parameters:\n      object_ids (guid): list of multiple curves\n      delete_input (bool, optional): delete input objects after joining\n      tolerance (number, optional): join tolerance. If omitted, 2.1 * document absolute\n          tolerance is used\n    Returns:\n      list(guid, ...): Object id representing the new curves\n    Example:\n      import rhinoscriptsyntax as rs\n      objs = rs.GetObjects(\"Select curves to join\", rs.filter.curve)\n      if objs: rs.JoinCurves(objs)\n    See Also:\n      ExplodeCurves\n      IsCurve\n      IsCurveClosed\n    \"\"\"\n    if len(object_ids)<2: raise ValueError(\"object_ids must contain at least 2 items\")\n    curves = [rhutil.coercecurve(id, -1, True) for id in object_ids]\n    if tolerance is None:\n        tolerance = 2.1 * scriptcontext.doc.ModelAbsoluteTolerance\n    newcurves = Rhino.Geometry.Curve.JoinCurves(curves, tolerance)\n    rc = []\n    if newcurves:\n        rc = [scriptcontext.doc.Objects.AddCurve(crv) for crv in newcurves]\n    if rc and delete_input:\n        for id in object_ids:\n            id = rhutil.coerceguid(id, True)\n            scriptcontext.doc.Objects.Delete(id, False)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef LineFitFromPoints(points):\n    \"\"\"Returns a line that was fit through an array of 3D points\n    Parameters:\n      points ([point, point, ...]): a list of at least two 3D points\n    Returns:\n      line: line on success\n    Example:\n      import rhinoscriptsyntax as rs\n      points = rs.GetPoints()\n      if points and len(points)>1:\n          line=rs.LineFitFromPoints(points)\n          if line: rs.AddLine(line.From, line.To)\n    See Also:\n      AddLine\n      CurveEndPoint\n      CurveStartPoint\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    rc, line = Rhino.Geometry.Line.TryFitLineToPoints(points)\n    if rc: return line\n    return scriptcontext.errorhandler()\n\n\ndef MakeCurveNonPeriodic(curve_id, delete_input=False):\n    \"\"\"Makes a periodic curve non-periodic. Non-periodic curves can develop\n    kinks when deformed\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      delete_input (bool): delete the input curve. If omitted, the input curve will not be deleted.\n    Returns:\n      guid: id of the new or modified curve if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.IsCurvePeriodic(curve): rs.MakeCurveNonPeriodic( curve )\n    See Also:\n      IsCurvePeriodic\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if not curve.IsPeriodic: return scriptcontext.errorhandler()\n    nc = curve.ToNurbsCurve()\n    if nc is None: return scriptcontext.errorhandler()\n    nc.Knots.ClampEnd( Rhino.Geometry.CurveEnd.Both )\n    rc = None\n    if delete_input:\n        if type(curve_id) is Rhino.DocObjects.ObjRef: pass\n        else: curve_id = rhutil.coerceguid(curve_id)\n        if curve_id:\n            rc = scriptcontext.doc.Objects.Replace(curve_id, nc)\n            if not rc: return scriptcontext.errorhandler()\n            rc = rhutil.coerceguid(curve_id)\n    else:\n        attrs = None\n        if type(scriptcontext.doc) is Rhino.RhinoDoc:\n            rhobj = rhutil.coercerhinoobject(curve_id)\n            if rhobj: attrs = rhobj.Attributes\n        rc = scriptcontext.doc.Objects.AddCurve(nc, attrs)\n        if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef MeanCurve(curve0, curve1, tolerance=None):\n    \"\"\"Creates an average curve from two curves\n    Parameters:\n      curve0, curve1 (guid): identifiers of two curves\n      tolerance (number, optional): angle tolerance used to match kinks between curves\n    Returns:\n      guid: id of the new or modified curve if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve0 = rs.GetObject(\"Select the first curve\", rs.filter.curve)\n      curve1 = rs.GetObject(\"Select the second curve\", rs.filter.curve)\n      rs.MeanCurve( curve0, curve1 )\n    See Also:\n      UnitAngleTolerance\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve0, -1, True)\n    curve1 = rhutil.coercecurve(curve1, -1, True)\n    if tolerance is None: tolerance=Rhino.RhinoMath.UnsetValue\n    crv = Rhino.Geometry.Curve.CreateMeanCurve(curve0,curve1,tolerance)\n    if crv:\n        rc = scriptcontext.doc.Objects.AddCurve(crv)\n        scriptcontext.doc.Views.Redraw()\n        return rc\n\n\ndef MeshPolyline(polyline_id):\n    \"\"\"Creates a polygon mesh object based on a closed polyline curve object.\n    The created mesh object is added to the document\n    Parameters:\n      polyline_id (guid): identifier of the polyline curve object\n    Returns:\n      guid: identifier of the new mesh object\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      polyline = rs.GetObject(\"Select a polyline\", rs.filter.curve)\n      if polyline:\n          if rs.IsPolyline(polyline) and rs.IsCurveClosed(polyline):\n              rs.MeshPolyline( polyline )\n    See Also:\n      IsCurveClosed\n      IsPolyline\n    \"\"\"\n    curve = rhutil.coercecurve(polyline_id, -1, True)\n    ispolyline, polyline = curve.TryGetPolyline()\n    if not ispolyline: return scriptcontext.errorhandler()\n    mesh = Rhino.Geometry.Mesh.CreateFromClosedPolyline(polyline)\n    if not mesh: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddMesh(mesh)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef OffsetCurve(object_id, direction, distance, normal=None, style=1):\n    \"\"\"Offsets a curve by a distance. The offset curve will be added to Rhino\n    Parameters:\n      object_id (guid): identifier of a curve object\n      direction (point): point describing direction of the offset\n      distance (number): distance of the offset\n      normal (vector, optional): normal of the plane in which the offset will occur.\n          If omitted, the normal of the active construction plane will be used\n      style (number, optional): the corner style. If omitted, the style is sharp.\n                                0 = None\n                                1 = Sharp\n                                2 = Round\n                                3 = Smooth\n                                4 = Chamfer\n    Returns:\n      list(guid, ...): list of ids for the new curves on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.IsCurve(obj):\n          rs.OffsetCurve( obj, [0,0,0], 1.0 )\n    See Also:\n      OffsetCurveOnSurface\n      OffsetSurface\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, -1, True)\n    direction = rhutil.coerce3dpoint(direction, True)\n    if normal:\n        normal = rhutil.coerce3dvector(normal, True)\n    else:\n        normal = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane().Normal\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    style = System.Enum.ToObject(Rhino.Geometry.CurveOffsetCornerStyle, style)\n    curves = curve.Offset(direction, normal, distance, tolerance, style)\n    if curves is None: return scriptcontext.errorhandler()\n    rc = [scriptcontext.doc.Objects.AddCurve(curve) for curve in curves]\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef OffsetCurveOnSurface(curve_id, surface_id, distance_or_parameter):\n    \"\"\"Offset a curve on a surface. The source curve must lie on the surface.\n    The offset curve or curves will be added to Rhino\n    Parameters:\n      curve_id, surface_id (guid): curve and surface identifiers\n      distance_or_parameter (number|tuple(number, number)): If a single number is passed, then this is the\n        distance of the offset. Based on the curve's direction, a positive value\n        will offset to the left and a negative value will offset to the right.\n        If a tuple of two values is passed, this is interpreted as the surface\n        U,V parameter that the curve will be offset through\n    Returns:\n      list(guid, ...): identifiers of the new curves if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      def TestOffset():\n          curve = rs.GetObject(\"Select curve on a surface\", rs.filter.curve)\n          if curve is None: return False\n          surface = rs.GetObject(\"Select base surface\", rs.filter.surface)\n          if surface is None: return False\n          point = rs.GetPointOnSurface( surface, \"Through point\" )\n          if point is None: return False\n          parameter = rs.SurfaceClosestPoint(surface, point)\n          rc = rs.OffsetCurveOnSurface( curve, surface, parameter )\n          return rc is not None\n       \n      TestOffset()\n    See Also:\n      OffsetCurve\n      OffsetSurface\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    surface = rhutil.coercesurface(surface_id, True)\n    x = None\n    if type(distance_or_parameter) is list or type(distance_or_parameter) is tuple:\n        x = Rhino.Geometry.Point2d( distance_or_parameter[0], distance_or_parameter[1] )\n    else:\n        x = float(distance_or_parameter)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    curves = curve.OffsetOnSurface(surface, x, tol)\n    if curves is None: return scriptcontext.errorhandler()\n    curves = [curve.ExtendOnSurface(Rhino.Geometry.CurveEnd.Both, surface) for curve in curves]\n    rc = [scriptcontext.doc.Objects.AddCurve(curve) for curve in curves]\n    if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef PlanarClosedCurveContainment(curve_a, curve_b, plane=None, tolerance=None):\n    \"\"\"Determines the relationship between the regions bounded by two coplanar\n    simple closed curves\n    Parameters:\n      curve_a, curve_b (guid): identifiers of two planar, closed curves\n      plane (plane, optional): test plane. If omitted, the currently active construction\n        plane is used\n      tolerance (number, optional): if omitted, the document absolute tolerance is used\n    Returns:\n      number: a number identifying the relationship if successful\n        0 = the regions bounded by the curves are disjoint\n        1 = the two curves intersect\n        2 = the region bounded by curve_a is inside of curve_b\n        3 = the region bounded by curve_b is inside of curve_a\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      curve1 = rs.GetObject(\"Select first curve\", rs.filter.curve )\n      curve2 = rs.GetObject(\"Select second curve\", rs.filter.curve )\n      if rs.IsCurvePlanar(curve1) and rs.IsCurvePlanar(curve2):\n          if rs.IsCurveClosed(curve1) and rs.IsCurveClosed(curve2):\n              if rs.IsCurveInPlane(curve1) and rs.IsCurveInPlane(curve2):\n                  result = rs.PlanarClosedCurveContainment(curve1, curve2)\n                  if result==0: print(\"The regions bounded by the curves are disjoint.\")\n                  elif result==1: print(\"The two curves intersect..\")\n                  elif result==2: print(\"The region bounded by Curve1 is inside of Curve2.\")\n                  else: print(\"The region bounded by Curve2 is inside of Curve1.\")\n    See Also:\n      PlanarCurveCollision\n      PointInPlanarClosedCurve\n    \"\"\"\n    curve_a = rhutil.coercecurve(curve_a, -1, True)\n    curve_b = rhutil.coercecurve(curve_b, -1, True)\n    if tolerance is None or tolerance<=0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if plane:\n        plane = rhutil.coerceplane(plane)\n    else:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    rc = Rhino.Geometry.Curve.PlanarClosedCurveRelationship(curve_a, curve_b, plane, tolerance)\n    return int(rc)\n\n\ndef PlanarCurveCollision(curve_a, curve_b, plane=None, tolerance=None):\n    \"\"\"Determines if two coplanar curves intersect\n    Parameters:\n      curve_a, curve_b (guid): identifiers of two planar curves\n      plane (plane, optional): test plane. If omitted, the currently active construction\n        plane is used\n      tolerance (number, optional): if omitted, the document absolute tolerance is used\n    Returns:\n      bool: True if the curves intersect; otherwise False\n    Example:\n      import rhinoscriptsyntax as rs\n      curve1 = rs.GetObject(\"Select first curve\")\n      curve2 = rs.GetObject(\"Select second curve\")\n      if( rs.IsCurvePlanar(curve1) and rs.IsCurvePlanar(curve2) and rs.IsCurveInPlane(curve1) and rs.IsCurveInPlane(curve2) ):\n          if rs.PlanarCurveCollision(curve1, curve2):\n              print(\"The coplanar curves intersect.\")\n          else:\n              print(\"The coplanar curves do not intersect.\")\n    See Also:\n      CurveCurveIntersection\n      PlanarClosedCurveContainment\n      PointInPlanarClosedCurve\n    \"\"\"\n    curve_a = rhutil.coercecurve(curve_a, -1, True)\n    curve_b = rhutil.coercecurve(curve_b, -1, True)\n    if tolerance is None or tolerance<=0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if plane:\n        plane = rhutil.coerceplane(plane)\n    else:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    return Rhino.Geometry.Curve.PlanarCurveCollision(curve_a, curve_b, plane, tolerance)\n\n\ndef PointInPlanarClosedCurve(point, curve, plane=None, tolerance=None):\n    \"\"\"Determines if a point is inside of a closed curve, on a closed curve, or\n    outside of a closed curve\n    Parameters:\n      point (point|guid): text point\n      curve (guid): identifier of a curve object\n      plane (plane, optional): plane containing the closed curve and point. If omitted,\n          the currently active construction plane is used\n      tolerance (number, optional) it omitted, the document abosulte tolerance is used\n    Returns:\n      number: number identifying the result if successful\n              0 = point is outside of the curve\n              1 = point is inside of the curve\n              2 = point in on the curve\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a planar, closed curve\", rs.filter.curve)\n      if rs.IsCurveClosed(curve) and rs.IsCurvePlanar(curve):\n          point = rs.GetPoint(\"Pick a point\")\n          if point:\n              result = rs.PointInPlanarClosedCurve(point, curve)\n              if result==0: print(\"The point is outside of the closed curve.\")\n              elif result==1: print(\"The point is inside of the closed curve.\")\n              else: print(\"The point is on the closed curve.\")\n    See Also:\n      PlanarClosedCurveContainment\n      PlanarCurveCollision\n    \"\"\"\n    point = rhutil.coerce3dpoint(point, True)\n    curve = rhutil.coercecurve(curve, -1, True)\n    if tolerance is None or tolerance<=0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if plane:\n        plane = rhutil.coerceplane(plane)\n    else:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    rc = curve.Contains(point, plane, tolerance)\n    if rc==Rhino.Geometry.PointContainment.Unset: raise Exception(\"Curve.Contains returned Unset\")\n    if rc==Rhino.Geometry.PointContainment.Outside: return 0\n    if rc==Rhino.Geometry.PointContainment.Inside: return 1\n    return 2\n\n\ndef PolyCurveCount(curve_id, segment_index=-1):\n    \"\"\"Returns the number of curve segments that make up a polycurve\n    Parameters:\n      curve_id (guid): the object's identifier\n      segment_index (number, optional): if `curve_id` identifies a polycurve object, then `segment_index` identifies the curve segment of the polycurve to query.\n    Returns:\n      number: the number of curve segments in a polycurve if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polycurve\")\n      if rs.IsPolyCurve(obj):\n          count = rs.PolyCurveCount(obj)\n          if count: print(\"The polycurve contains {} curves\".format(count))\n    See Also:\n      IsPolyCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    if isinstance(curve, Rhino.Geometry.PolyCurve): return curve.SegmentCount\n    raise ValueError(\"curve_id does not reference a polycurve\")\n\n\ndef PolylineVertices(curve_id, segment_index=-1):\n    \"\"\"Returns the vertices of a polyline curve on success\n    Parameters:\n      curve_id (guid): the object's identifier\n      segment_index (number, optional): if curve_id identifies a polycurve object, then segment_index identifies the curve segment of the polycurve to query.\n    Returns:\n      list(point, ...): an list of Point3d vertex points if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polyline\")\n      if rs.IsPolyline(obj):\n          points = rs.PolylineVertices(obj)\n          if points:\n              for point in points: rs.AddPoint(point)\n    See Also:\n      AddPolyline\n      IsPolyline\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, polyline = curve.TryGetPolyline()\n    if rc: return [pt for pt in polyline]\n    raise ValueError(\"curve_id does not reference a polyline\")\n\n\ndef ProjectCurveToMesh(curve_ids, mesh_ids, direction):\n    \"\"\"Projects one or more curves onto one or more surfaces or meshes\n    Parameters:\n      curve_ids ([guid, ...]): identifiers of curves to project\n      mesh_ids ([guid, ...]): identifiers of meshes to project onto\n      direction (vector): projection direction\n    Returns:\n      list(guid, ...): list of identifiers for the resulting curves.\n    Example:\n      import rhinoscriptsyntax as rs\n      mesh = rs.GetObject(\"Select mesh to project onto\", rs.filter.mesh)\n      curve= rs.GetObject(\"Select curve to project\", rs.filter.curve)\n      #Project down...\n      results = rs.ProjectCurveToMesh(curve, mesh, (0,0,-1))\n    See Also:\n      ProjectCurveToSurface\n      ProjectPointToMesh\n      ProjectPointToSurface\n    \"\"\"\n    curve_ids = rhutil.coerceguidlist(curve_ids)\n    mesh_ids = rhutil.coerceguidlist(mesh_ids)\n    direction = rhutil.coerce3dvector(direction, True)\n    curves = [rhutil.coercecurve(id, -1, True) for id in curve_ids]\n    meshes = [rhutil.coercemesh(id, True) for id in mesh_ids]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newcurves = Rhino.Geometry.Curve.ProjectToMesh(curves, meshes, direction, tolerance)\n    ids = [scriptcontext.doc.Objects.AddCurve(curve) for curve in newcurves]\n    if ids: scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef ProjectCurveToSurface(curve_ids, surface_ids, direction):\n    \"\"\"Projects one or more curves onto one or more surfaces or polysurfaces\n    Parameters:\n      curve_ids ([guid, ...]): identifiers of curves to project\n      surface_ids ([guid, ...]): identifiers of surfaces to project onto\n      direction (vector): projection direction\n    Returns:\n      list(guid, ...): list of identifiers\n    Example:\n      import rhinoscriptsyntax as rs\n      surface = rs.GetObject(\"Select surface to project onto\", rs.filter.surface)\n      curve = rs.GetObject(\"Select curve to project\", rs.filter.curve)\n      # Project down...\n      results = rs.ProjectCurveToSurface(curve, surface, (0,0,-1))\n    See Also:\n      ProjectCurveToMesh\n      ProjectPointToMesh\n      ProjectPointToSurface\n    \"\"\"\n    curve_ids = rhutil.coerceguidlist(curve_ids)\n    surface_ids = rhutil.coerceguidlist(surface_ids)\n    direction = rhutil.coerce3dvector(direction, True)\n    curves = [rhutil.coercecurve(id, -1, True) for id in curve_ids]\n    breps = [rhutil.coercebrep(id, True) for id in surface_ids]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newcurves = Rhino.Geometry.Curve.ProjectToBrep(curves, breps, direction, tolerance)\n    ids = [scriptcontext.doc.Objects.AddCurve(curve) for curve in newcurves]\n    if ids: scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef RebuildCurve(curve_id, degree=3, point_count=10):\n    \"\"\"Rebuilds a curve to a given degree and control point count. For more\n    information, see the Rhino help for the Rebuild command.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      degree (number, optional): new degree (must be greater than 0)\n      point_count (number, optional) new point count, which must be bigger than degree.\n    Returns:\n      bool: True of False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select curve to rebuild\", rs.filter.curve)\n      if curve: rs.RebuildCurve(curve, 3, 10)\n    See Also:\n      RebuildSurface\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if degree<1: raise ValueError(\"degree must be greater than 0\")\n    newcurve = curve.Rebuild(point_count, degree, False)\n    if not newcurve: return False\n    scriptcontext.doc.Objects.Replace(curve_id, newcurve)\n    scriptcontext.doc.Views.Redraw()\n    return True\n\n\ndef RemoveCurveKnot(curve, parameter):\n    \"\"\"Deletes a knot from a curve object.\n    Parameters:\n      curve (guid): The reference of the source object\n      parameter (number): The parameter on the curve. Note, if the parameter is not equal to one\n                      of the existing knots, then the knot closest to the specified parameter\n                      will be removed.\n    Returns:\n      bool: True of False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n\n      crv_info = rs.GetCurveObject(\"Select curve near knot to be removed\")\n      if crv_info:\n          crv_id = crv_info[0]\n          crv_param = crv_info[4]\n          rs.RemoveCurveKnot(crv_id, crv_param)\n    See Also:\n      RemoveSurfaceKnot\n    \"\"\"\n    curve_inst = rhutil.coercecurve(curve, -1, True)\n    success, n_param = curve_inst.GetCurveParameterFromNurbsFormParameter(parameter)\n    if not success: return False\n    n_curve = curve_inst.ToNurbsCurve()\n    if not n_curve: return False\n    success = n_curve.Knots.RemoveKnotAt(n_param)\n    if not success: return False\n    scriptcontext.doc.Objects.Replace(curve, n_curve)\n    scriptcontext.doc.Views.Redraw()\n    return True\n\n\ndef ReverseCurve(curve_id):\n    \"\"\"Reverses the direction of a curve object. Same as Rhino's Dir command\n    Parameters:\n      curve_id (guid): identifier of the curve object\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve to reverse\")\n      if rs.IsCurve(curve): rs.ReverseCurve(curve)\n    See Also:\n      CurveDirectionsMatch\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if curve.Reverse():\n        curve_id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Replace(curve_id, curve)\n        return True\n    return False\n\n\ndef SimplifyCurve(curve_id, flags=0):\n    \"\"\"Replace a curve with a geometrically equivalent polycurve.\n    \n    The polycurve will have the following properties:\n     - All the polycurve segments are lines, polylines, arcs, or NURBS curves.\n     - The NURBS curves segments do not have fully multiple interior knots.\n     - Rational NURBS curves do not have constant weights.\n     - Any segment for which IsCurveLinear or IsArc is True is a line, polyline segment, or an arc.\n     - Adjacent co-linear or co-circular segments are combined.\n     - Segments that meet with G1-continuity have there ends tuned up so that they meet with G1-continuity to within machine precision.\n     - If the polycurve is a polyline, a polyline will be created\n\n\n    Parameters:\n      curve_id (guid): the object's identifier\n      flags (number, optional): the simplification methods to use. By default, all methods are used (flags = 0)\n        Value Description\n        0     Use all methods.\n        1     Do not split NURBS curves at fully multiple knots.\n        2     Do not replace segments with IsCurveLinear = True with line curves.\n        4     Do not replace segments with IsArc = True with arc curves.\n        8     Do not replace rational NURBS curves with constant denominator with an equivalent non-rational NURBS curve.\n        16    Do not adjust curves at G1-joins.\n        32    Do not merge adjacent co-linear lines or co-circular arcs or combine consecutive line segments into a polyline.\n\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve to simplify\", rs.filter.curve)\n      if curve: rs.SimplifyCurve(curve)\n    See Also:\n      IsArc\n      IsCurveLinear\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    _flags = Rhino.Geometry.CurveSimplifyOptions.All\n    if( flags&1 ==1 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.SplitAtFullyMultipleKnots)\n    if( flags&2 ==2 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.RebuildLines)\n    if( flags&4 ==4 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.RebuildArcs)\n    if( flags&8 ==8 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.RebuildRationals)\n    if( flags&16==16 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.AdjustG1)\n    if( flags&32==32 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.Merge)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    ang_tol = scriptcontext.doc.ModelAngleToleranceRadians\n    newcurve = curve.Simplify(_flags, tol, ang_tol)\n    if newcurve:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Replace(curve_id, newcurve)\n        scriptcontext.doc.Views.Redraw()\n        return True\n    return False\n\n\ndef SplitCurve(curve_id, parameter, delete_input=True):\n    \"\"\"Splits, or divides, a curve at a specified parameter. The parameter must\n    be in the interior of the curve's domain\n    Parameters:\n      curve_id (guid): the curve to split\n      parameter ({number, ...]) one or more parameters to split the curve at\n      delete_input (bool, optional): delete the input curve\n    Returns:\n      list(guid, ....): list of new curves on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve to split\", rs.filter.curve)\n      if rs.IsCurve(curve):\n          domain = rs.CurveDomain(curve)\n          parameter = domain[1] / 2.0\n          rs.SplitCurve( curve, parameter )\n    See Also:\n      TrimCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    newcurves = curve.Split(parameter)\n    if newcurves is None: return scriptcontext.errorhandler()\n    att = None\n    rhobj = rhutil.coercerhinoobject(curve_id)\n    if rhobj: att = rhobj.Attributes\n    rc = [scriptcontext.doc.Objects.AddCurve(crv, att) for crv in newcurves]\n    if rc and delete_input:\n        id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef TrimCurve(curve_id, interval, delete_input=True):\n    \"\"\"Trims a curve by removing portions of the curve outside a specified interval\n    Parameters:\n      curve_id (guid):the curve to trim\n      interval ([number, number]): two numbers identifying the interval to keep. Portions of\n        the curve before domain[0] and after domain[1] will be removed. If the\n        input curve is open, the interval must be increasing. If the input\n        curve is closed and the interval is decreasing, then the portion of\n        the curve across the start and end of the curve is returned\n      delete_input (bool): delete the input curve. If omitted the input curve is deleted.\n    Returns:\n      list(guid, ...): identifier of the new curve on success\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve to trim\", rs.filter.curve)\n      if rs.IsCurve(curve):\n          domain = rs.CurveDomain(curve)\n          domain[1] /= 2.0\n          rs.TrimCurve( curve, domain )\n    See Also:\n      SplitCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if interval[0]==interval[1]: raise ValueError(\"interval values are equal\")\n    newcurve = curve.Trim(interval[0], interval[1])\n    if not newcurve: return scriptcontext.errorhandler()\n    att = None\n    rhobj = rhutil.coercerhinoobject(curve_id)\n    if rhobj: att = rhobj.Attributes\n    rc = scriptcontext.doc.Objects.AddCurve(newcurve, att)\n    if delete_input:\n        id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ChangeCurveDegree(object_id, degree):\n    \"\"\"Changes the degree of a curve object. For more information see the Rhino help file for the ChangeDegree command.\n      Parameters:\n        object_id (guid): the object's identifier.\n        degree (number): the new degree.\n      Returns:\n        bool: True of False indicating success or failure.\n        None: on failure\n      Example:\n    \n      See Also:\n        IsCurve\n        CurveDegree\n    \"\"\" \n    curve = rhutil.coercerhinoobject(object_id)\n    if not curve: return None\n    if not isinstance(curve, Rhino.DocObjects.CurveObject): return None\n\n    curve = curve.CurveGeometry\n    if not isinstance(curve, Rhino.Geometry.NurbsCurve):\n        curve = curve.ToNurbsCurve()\n\n    max_nurbs_degree = 11\n    if degree < 1 or degree > max_nurbs_degree or curve.Degree == degree:\n        return None\n\n    r = False\n    if curve.IncreaseDegree(degree):\n        r = scriptcontext.doc.Objects.Replace(object_id, curve)\n    return r\n\n\ndef AddTweenCurves(from_curve_id, to_curve_id, number_of_curves = 1, method = 0, sample_number = 10):\n    \"\"\"Creates curves between two open or closed input curves.\n    Parameters:\n      from_curve_id (guid): identifier of the first curve object.\n      to_curve_id (guid): identifier of the second curve object.\n      number_of_curves (number): The number of curves to create. The default is 1.\n      method (number): The method for refining the output curves, where:\n        0: (Default) Uses the control points of the curves for matching. So the first control point of first curve is matched to first control point of the second curve.\n        1: Refits the output curves like using the FitCurve method.  Both the input curve and the output curve will have the same structure. The resulting curves are usually more complex than input unless input curves are compatible.\n        2: Input curves are divided to the specified number of points on the curve, corresponding points define new points that output curves go through. If you are making one tween curve, the method essentially does the following: divides the two curves into an equal number of points, finds the midpoint between the corresponding points on the curves, and interpolates the tween curve through those points.\n      sample_number (number): The number of samples points to use if method is 2. The default is 10.\n    Returns:\n      list(guid, ...): The identifiers of the new tween objects if successful, None on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curveA = rs.GetObject(\"Select first curve\", rs.filter.curve)\n      curveB = rs.GetObject(\"Select second curve\", rs.filter.curve)\n      arrResult = rs.AddTweenCurves(curveA, curveB, 6, 2, 30)\n    \"\"\"\n    curve0 = rhutil.coercecurve(from_curve_id, -1, True)\n    curve1 = rhutil.coercecurve(to_curve_id, -1, True)\n    out_curves = 0\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if method == 0:\n        out_curves = Rhino.Geometry.Curve.CreateTweenCurves(curve0, curve1, number_of_curves, tolerance)\n    elif method == 1:\n        out_curves = Rhino.Geometry.Curve.CreateTweenCurvesWithMatching(curve0, curve1, number_of_curves, tolerance)\n    elif method == 2:\n        out_curves = Rhino.Geometry.Curve.CreateTweenCurvesWithSampling(curve0, curve1, number_of_curves, sample_number, tolerance)\n    else: raise ValueError(\"method must be 0, 1, or 2\")\n    curves = None\n    if out_curves:\n        curves = []\n        for curve in out_curves:\n            if curve and curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n            curve.Dispose()\n            if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n            curves.append(rc)\n        scriptcontext.doc.Views.Redraw()\n    return curves\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "brep", "line", "dimension", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "McMuff86_rhinomcp_e2f442bdc5.json", "repo": "McMuff86/rhinomcp"}
{"instruction": "Implement the function 'polygonArea' for Rhino scripting", "code": "from flask import Flask\nimport ghhops_server as hs\nimport rhino3dm as rdm\nimport math\nfrom load_model_rhino import runDaylightPrediction\n\n# utilties:\n# calculate area\n# (X[i], Y[i]) are coordinates of i'th point.\n# This code is contributed by\n# Smitha Dinesh Semwal\ndef polygonArea(X, Y, n):\n \n    # Initialize area\n    area = 0.0\n \n    # Calculate value of shoelace formula\n    j = n - 1\n    for i in range(0,n):\n        area += (X[j] + X[i]) * (Y[j] - Y[i])\n        j = i   # j is previous vertex to i\n \n    # Return absolute value\n    return int(abs(area / 2.0))\n\n# register hops app as middleware\napp = Flask(__name__)\nhops = hs.Hops(app)\n\n@hops.component(\n    \"/getUDIPrediction\",\n    name=\"Get UDI prediction\",\n    description=\"Predicts the UDI of a given room object\",\n    #icon=\"learncarbon_logo_without_text.png\",\n    inputs=[\n        hs.HopsCurve(\"roomBoundary\", \"Room Boundary Curve\", \"Closed curve representing the room boundary\"),\n        hs.HopsNumber(\"windowWidth\", \"Window Width\", \"Width of Window\"),\n        hs.HopsNumber(\"windowHeight\", \"Window Height\", \"Height of Window\"),\n    ],\n    outputs=[\n        hs.HopsNumber(\"UDIPrediction\", \"UDI Prediction\", \"Prediction of UDI for room\")\n    ]\n)\ndef getUDIPrediction(roomBoundary, windowWidth,windowHeight):\n\n    #convert to polyline to be able to measure distances\n    myPolyline = roomBoundary.ToPolyline()\n    \n    point0: rdm.Point3d = myPolyline[0]\n    point1: rdm.Point3d = myPolyline[1]\n    point2: rdm.Point3d = myPolyline[2]\n    point3: rdm.Point3d = myPolyline[3]\n\n    # calculating distances\n    sideA = point0.DistanceTo(point1)\n    sideB = point1.DistanceTo(point2)\n    sideC = point2.DistanceTo(point3)\n    sideD = point3.DistanceTo(point0)\n\n    # calculating orientation\n    # get first vector\n    vX = point1.X - point0.X\n    vY = point1.Y - point0.Y\n    vZ = point1.Z - point0.Z \n\n    fVector = rdm.Vector3d(vX,vY,vZ)\n\n    #compute north vector\n    nVector = rdm.Vector3d(0.0,0.0,0.0)\n\n    # calculate angle according to x access\n    # based on https://stackoverflow.com/questions/42258637/how-to-know-the-angle-between-two-vectors\n    radAngle = math.atan2(fVector.X-nVector.X, fVector.Y-nVector.Y) - math.pi*0.5\n    degAngle = abs(math.degrees(radAngle))\n\n    if degAngle <= 180 and degAngle >= 90:\n        orientation = abs(degAngle - 180)\n    elif degAngle <= 90 and degAngle >= 0 and radAngle < 0:\n        orientation = abs(degAngle - 180)\n    elif degAngle <= 90 and degAngle >= 0 and radAngle > 0:\n        orientation = degAngle + 180\n    elif degAngle  <= 270 and degAngle >= 180:\n        orientation = (360 - degAngle) + 180\n\n    # calcute area:\n    X = [point0.X, point1.X, point2.X, point3.X]\n    Y = [point0.Y, point1.Y, point2.Y, point3.Y]\n    n = len(X)\n    area = polygonArea(X, Y, n)\n\n    prediction = runDaylightPrediction(sideA,sideB,sideC,sideD,windowWidth,windowHeight,orientation,area)\n    #print(prediction)\n\n    myPredictions = []\n    for p in prediction:\n        fValue = float(p)\n        if fValue < 0.0:\n            fValue = 0.0\n            myPredictions.append(fValue)\n        else:\n            myPredictions.append(fValue)\n    \n\n    print(orientation)\n\n    return myPredictions\n\nif __name__ == \"__main__\":\n    app.run()\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["curve", "line", "functions", "point"], "original_file": "Mluminance_model_fec2e034ab.json", "repo": "Mluminance/model"}
{"instruction": "Calculate the moment of a force around a point.", "code": "\nimport rhinoscriptsyntax as rs\nimport gmsh\nimport numpy as np\nimport importlib\nimport plotly.graph_objects as go\n#import meshio\nfrom cvxopt import matrix, solvers, spmatrix\n#from scipy.sparse import coo_matrix\nimport sys\nimport time\nfrom sklearn.cluster import KMeans\n#import pandas as pd\nimport os\nimport vtk\nfrom pyevtk.hl import unstructuredGridToVTK\nfrom pyevtk.vtk import VtkTriangle, VtkQuad, VtkVertex, VtkPolyLine, VtkPolygon\nimport mesh\nimport mosek\nimport math\nfrom scipy.linalg import block_diag\nfrom scipy.spatial import cKDTree\nimport os\nimport json\nimport locale\nfrom urllib.request import urlopen\nfrom datetime import datetime\n\n\n\ndef blocks_face_neighboring(blocks_centroid,face_centroid, k_neighbors):\n    kdtree = cKDTree(blocks_centroid[:,-3:])\n \n    distances, neighbors = kdtree.query(face_centroid, k=k_neighbors + 1)\n  \n    return distances, neighbors\n\n\ndef calculate_moment(point_coords, force_coords, applied_point_coords):\n    \"\"\"\n    Calculate the moment of a force around a point.\n\n    Parameters:\n    - point_coords: Coordinates of the point where the moment is calculated (numpy array).\n    - force_coords: Coordinates of the force vector (numpy array).\n    - applied_point_coords: Coordinates of the point where the force is applied (numpy array).\n\n    Returns:\n    - moment: Moment of the force around the point (numpy array).\n    \"\"\"\n    r = - point_coords + applied_point_coords\n    F = force_coords\n\n    # Calculate the cross product to get the moment\n    moment = np.cross(r, F)\n\n    return moment\ndef rotate_x(theta):\n    return np.array([\n        [1, 0, 0],\n        [0, np.cos(theta), -np.sin(theta)],\n        [0, np.sin(theta), np.cos(theta)]\n    ])\n\ndef rotate_y(theta):\n    return np.array([\n        [np.cos(theta), 0, np.sin(theta)],\n        [0, 1, 0],\n        [-np.sin(theta), 0, np.cos(theta)]\n    ])\n\ndef rotate_z(theta):\n    return np.array([\n        [np.cos(theta), -np.sin(theta), 0],\n        [np.sin(theta), np.cos(theta), 0],\n        [0, 0, 1]\n    ])\ndef transform_point(point, displacement, rotations):\n    \n\n    # Apply rotations\n    for rotation in rotations:\n        axis, angle = rotation[0], rotation[1]\n        if axis == 'x':\n            rotation_matrix = rotate_x(angle)\n        elif axis == 'y':\n            rotation_matrix = rotate_y(angle)\n        elif axis == 'z':\n            rotation_matrix = rotate_z(angle)\n        else:\n            raise ValueError(\"Invalid rotation axis. Use 'x', 'y', or 'z'.\")\n\n        point = np.dot(rotation_matrix, point)\n        # Apply displacement\n    point = np.array(point) + np.array(displacement)\n    return point.tolist()\n\ndef check_outward_normal(block_centroid,face_ind, face_centroid,face_normal,local_ref):\n\n    block_centroid = [ block_centroid[0], block_centroid[1], block_centroid[2]]\n   \n    if np.dot(face_normal, np.array(block_centroid )- np.array(face_centroid)) > 0:\n        face_normal = [-1*element for element in face_normal]\n        \n        \n    if face_normal[1] != 0 or face_normal[2] != 0:\n        x_local = [face_normal[1]**2 + face_normal[2]**2, -face_normal[0]*face_normal[1] , -face_normal[0]*face_normal[2] ]\n        y_local = [0, face_normal[2] , -face_normal[1] ]\n    else:\n        if face_normal[0] > 0:\n            x_local = [0,1,0]\n            y_local = [0,0,1]\n        else:\n            x_local = [0,-1,0]\n            y_local = [0,0,1]\n  \n        \n    x_local /= np.linalg.norm(x_local)\n    y_local /= np.linalg.norm(y_local)\n\n    x_local = [round(element,4) for element in x_local ]\n    y_local = [round(element,4) for element in y_local ]\n    \n\n    local_ref = np.append(local_ref, np.array([[ face_ind, face_normal[0], face_normal[1],face_normal[2], \\\n                                              x_local[0],x_local[1],x_local[2], y_local[0],y_local[1],y_local[2]  ]]), axis =0)\n        \n  \n    return local_ref\n\n\ndef stat_parav(data, calc_type, stat_sol):\n\n    all_unique_points = data[\"all_unique_points\"]\n    all_triangles = data[\"all_triangles\"]\n\n \n    \n    FILE_PATH = data[\"rhino_file_path\"]  + \"\\\\\" + calc_type + \"_stat\"\n\n    print(\"Running unstructured...\")\n\n    \n    \n    \n    if calc_type == \"ub\":\n        area = data[\"Coutput\"][12]\n  \n        normal_load = [ stat_sol[ind+2]/area[int(ind/3)]   for ind in range(0,len(stat_sol[0:-1:]),3) ]\n        shear_loadx = [ stat_sol[ind]/area[int(ind/3)]    for ind in range(0,len(stat_sol[0:-1:]),3) ]\n        shear_loady = [ stat_sol[ind+1]/area[int(ind/3)]    for ind in range(0,len(stat_sol[0:-1:]),3) ]\n     \n\n    \n    else:\n        normal_load = [ stat_sol[ind+2]   for ind in range(0,len(stat_sol[0:-1:]),3) ]\n        shear_loadx = [ stat_sol[ind]   for ind in range(0,len(stat_sol[0:-1:]),3) ]\n        shear_loady = [ stat_sol[ind+1]   for ind in range(0,len(stat_sol[0:-1:]),3) ]\n    \n  \n    all_unique_points = np.array(all_unique_points)\n\n    # Define vertices\n    x = [float(element) for element in all_unique_points[:, 0]]\n    y = [float(element) for element in all_unique_points[:, 1]]\n    z = [float(element) for element in all_unique_points[:, 2]]\n\n\n    x = np.array(x, dtype = np.float64)\n    y = np.array(y,dtype = np.float64)\n    z = np.array(z,dtype = np.float64)\n    \n\n    # Define connectivity or vertices that belong to each element\n    conn = []\n    # Define offset of the last vertex of each element\n    offset = []\n    # Define cell types\n    ctype = []\n   \n    node_ind = 0\n \n    for face_triangles in all_triangles:\n      \n        for triangle in face_triangles:\n            for node in triangle:\n                conn.append(int(node-1))\n                node_ind += 1\n\n\n            offset.append(node_ind )\n\n            if len(triangle) == 3:\n                ctype.append(VtkTriangle.tid)\n            else:\n                \n                ctype.append(VtkQuad.tid)\n          \n\n    conn =  np.array(conn)\n    offset =  np.array(offset)\n    ctype =  np.array(ctype)\n\n    #cd = np.random.rand(2)\n    cellData = {\"pressure\": []}\n\n    \n    # Define displacement components\n    normal_stress = np.array(normal_load)\n    shear_stress1 = np.array(shear_loadx)\n    shear_stress2 = np.array(shear_loady)\n\n    # Combine displacement components into separate arrays\n    pointData = {\"normal_stress\":normal_stress, \"shear_stress1\": shear_stress1, \"shear_stress2\": shear_stress2  }\n \n    unstructuredGridToVTK(FILE_PATH, x, y, z, connectivity=conn, offsets=offset, cell_types=ctype, pointData=pointData)\n    \ndef blocks_mesh_parav(data):\n\n    noc_triangles_coor = data[\"noc_triangles_coor\"]\n    noc_triangles = data[\"noc_triangles\"]\n    \n    FILE_PATH = data[\"rhino_file_path\"] + \"\\\\blocks_mesh\"\n   \n    # Define vertices\n    \n    noc_triangles_coor = np.array(noc_triangles_coor)\n\n    # Define vertices\n    x = [float(element) for element in noc_triangles_coor[:, 0]]\n    y = [float(element) for element in noc_triangles_coor[:, 1]]\n    z = [float(element) for element in noc_triangles_coor[:, 2]]\n\n   \n    x = np.array(x, dtype = np.float64)\n    y = np.array(y,dtype = np.float64)\n    z = np.array(z,dtype = np.float64)\n    \n     # Define connectivity or vertices that belong to each element\n    conn = []\n    # Define offset of the last vertex of each element\n    offset = []\n    # Define cell types\n    ctype = []\n\n    tri_ind = 0\n    node_ind = 0\n \n    for face_triangles in noc_triangles:\n      \n        for triangle in face_triangles:\n            for node in triangle:\n                conn.append(int(node-1))\n                node_ind += 1\n\n\n            offset.append(node_ind )\n\n            if len(triangle) == 3:\n                ctype.append(VtkTriangle.tid)\n            else:\n\n                ctype.append(VtkQuad.tid)\n          \n  \n\n    conn =  np.array(conn)\n    offset =  np.array(offset)\n    ctype =  np.array(ctype)\n\n    pointData = {'d': np.ones(x.shape[0])}\n\n    unstructuredGridToVTK(FILE_PATH, x, y, z, connectivity=conn, offsets=offset, cell_types=ctype, pointData=pointData)\n\n\ndef streamprinter(text):\n    sys.stdout.write(text)\n    sys.stdout.flush()\n\n\n\ndef kin_parav(data,calc_type,ub):\n\n    blocks_centroid = data[\"blocks_centroid\"]\n    blocks = data[\"blocks\"]\n    faces = data[\"faces\"]\n    points = data[\"points\"]\n\n\n    ub = [ element for element in ub ]\n\n    new_points = []\n    initial_points = np.empty((0,3))\n    points_disp = np.empty((0,3))\n\n    FILE_PATH =  data[\"rhino_file_path\"] + \"\\\\\" + calc_type +  \"_disp\"\n  \n    # Define connectivity or vertices that belong to each element\n    conn = []\n    # Define offset of the last vertex of each element\n    offset = []\n    # Define cell types\n    ctype = []\n  \n    for ind, block_centroid in enumerate(blocks_centroid):\n    \n      \n        faces_ind = blocks[np.where( blocks[:,0] == ind+1)][:,1]\n      \n        for face in faces_ind:\n          \n            points_ind = faces[ np.where(faces[:,0] == face)][:,2]\n            points_ind = [ int(element) -1 for element in points_ind] \n            \n            points_coor = points[points_ind][:,-3:]\n            points_coor.astype(float)\n            points_coor = np.array([[float(element) for element in row] for row in points_coor])\n            \n\n            all_new = []\n            reference_point = block_centroid[-3:]\n       \n            \n            displacement_vector = [ ub[6*ind], ub[6*ind +1], ub[6*ind +2] ]\n      \n            \n            rotations = [('x', ub[6*ind +3]), ('y',ub[6*ind +4]),('z',  ub[6*ind +5])]\n            \n            for element in points_coor:\n             \n                initial_points = np.append(initial_points, np.array([element]), axis = 0)\n                \n\n                conn.extend( [initial_points.shape[0] - 1 ])\n                \n                point_new_ref = [element[element1] - reference_point[element1] for element1 in range(3) ]\n               \n                \n                new_point = transform_point(point_new_ref , displacement_vector, rotations)\n                \n               \n                new_point = [new_point[element] + reference_point[element] for element in range(3) ]\n                \n                all_new.append(new_point)\n\n                points_disp = np.append(points_disp, np.array( [new_point[:] - element[:] ] ), axis = 0)\n             \n                \n            ctype.extend ([VtkQuad.tid])\n            offset.extend( [initial_points.shape[0] ])\n            \n            new_points.append(all_new[0]) \n            \n            all_new = np.array(all_new)   \n            \n            \n\n            \n    \n    points = new_points\n   \n    point = np.array([[float(element) for element in row] for row in points])\n    \n    # Define vertices\n    x = [float(element) for element in initial_points[:, 0]]\n    y = [float(element) for element in initial_points[:, 1]]\n    z = [float(element) for element in initial_points[:, 2]]\n\n    x = np.array(x)\n    y = np.array(y)\n    z = np.array(z)\n\n    # Define displacement components\n    dx = np.array(points_disp[:,0])\n    dy = np.array(points_disp[:,1])\n    dz = np.array(points_disp[:,2])\n\n    pointData = {'dx': dx, 'dy': dy, 'dz': dz } \n    conn = np.array(conn)\n    offset = np.array(offset)\n    ctype = np.array(ctype)\n    \n\n    unstructuredGridToVTK(FILE_PATH, x, y, z, connectivity=conn, offsets=offset, cell_types=ctype, pointData=pointData)\n\n\n##first part\n# Reload the RhinoScriptSyntax module\n\n\ndef read_data_from_rhino(data):\n  \n\n    read_data_start = time.time()\n    importlib.reload(rs)\n\n    lc = data[\"lc\"]\n    faces_rep = []\n    pts_coor = np.empty((0,3))\n\n    block_ind = 1  # initialize blocks counter variable \n    face_ind = 1    # initialize faces counter variable \n\n    blocks = np.empty((0, 7), dtype = np.float64) # blocks array shape( block ind | face_unique_ind | block_name | face_non_unique_ind | face_type | cohesion_ind | 11 if the face is principal 22 if not  )\n    faces = np.empty((0,3))   # shape(face_unique_ind | face_non_unique_ind | node ind )\n    blocks_centroid = np.empty((0,4), dtype = np.float64 ) # shape(block ind |x | y |z)\n    blocks_volume = np.empty((0,2), dtype = np.float64)  # shape( block ind |  volume )\n    blocks_att = dict()    # variable to store blocks attributes          \n\n    unsorted_faces_rep = [] # variable to store the faces representation without sorting the nodes indices  ( ex: a face whose the boundary passes through the nodes having indcides 1,3,7,5  have the representation 1#3#7#5)\n    plans_data = np.empty((0,4)) # local variable to store the external surfaces data shape( surface ind |  coordinates for a single point that constitutes the boundary of the surface  )\n    plan_ind = 1  # initialize surfaces counter variable \n    f_points = [] #local variable to store faces points\n    keys_of_interest = [\"fx\", \"fy\", \"fz\", \"mx\", \"my\", \"mz\"] # keys for blocks loading applied on their centroids\n    local_ref = np.empty((0,10),  dtype = np.float64) # shape(face_unique_ind | normal local axis(x,y,z) |   local_1 axis(x,y,z)  | local_2 axis(x,y,z) )\n    \n    blocks_brep = [] \n    bars = []\n    supports_type = [] \n\n    # store some contacts data (A face belonging to more than one block is called a contact)\n    contacts_ind = [] \n    contacts_nodes = []\n    contacts_FE = [0]\n\n    # store some faces data (A face belonging to at least one block is called face)\n\n    faces_ind = [] \n    faces_nodes = []\n    faces_FE = [0]\n\n    #store some data for external surfaces attributes\n\n    phi_type = [] # contains the friction agnle value attributated to an external surface. If no attribute is found -1 is stored\n    coh_type = [] # contains the cohesion value attributated to an external surface. If no attribute is found -1 is stored\n    lc_type = []  # contains the friction agnle value attributated to an external surface. If no attribute is found -1 is stored\n    fc_type = []\n\n    objs = rs.AllObjects()\n\n    loading_keys_interest = [\"px_l\", \"py_l\", \"pz_l\", \"pn_l\", \"px_d\", \"py_d\", \"pz_d\", \"pn_d\"]\n\n    linear_loading_key_interest = [\"wx_l\", \"wy_l\", \"wz_l\", \"wn_l\", \"wx_d\", \"wy_d\", \"wz_d\", \"wn_d\"]\n    \n    ponc_loading_key_interest = [\"fx_l\", \"fy_l\", \"fz_l\",\"mx_l\", \"my_l\", \"mz_l\",               \"fx_d\", \"fy_d\", \"fz_d\" , \"mx_d\", \"my_d\", \"mz_d\"] \n\n    loaded_faces_values = []\n    loaded_faces_adress = []\n    blocks_adress = []\n    loaded_blocks = []\n    torseur_blocks_live = []\n    torseur_blocks_dead = []\n    loaded_poly_adress = []\n    loaded_poly_values = []\n\n    loaded_points_values = []\n    loaded_points_adress = []\n\n    for obj in objs:\n        obj_type = rs.ObjectType(obj)\n\n        if obj_type == 1: # chekc if the object is a point\n            point_att = [element.lower() for element in rs.GetUserText(obj)]\n            if set(point_att) & set(ponc_loading_key_interest ):\n                loaded_points_values.append([0]*12)\n                loaded_points_adress.append(obj)\n\n\n                loading_att = set(point_att) & set(ponc_loading_key_interest )\n                for att in loading_att:\n                    \n                    att_pos = ponc_loading_key_interest.index( att.lower() )\n                   \n                    if rs.GetUserText(obj, att) != \" \":\n                        loaded_points_values[-1][att_pos] += float( rs.GetUserText(obj, att) )\n\n\n        \n        if obj_type == 4: # Check if the object is a curve\n            poly_att = [element.lower() for element in rs.GetUserText(obj)]\n            if \"fy\" in poly_att and \"as\" in poly_att:\n                bars.append(obj) \n            elif set(poly_att) & set(linear_loading_key_interest ) :\n                loaded_poly_values.append([0]*8)\n                loaded_poly_adress.append(obj)\n                \n                loading_att = set(poly_att) & set(linear_loading_key_interest )\n                for att in loading_att:\n                    \n                    att_pos = linear_loading_key_interest.index( att.lower() )\n                   \n                    if rs.GetUserText(obj, att) != \" \":\n                        loaded_poly_values[-1][att_pos] += float( rs.GetUserText(obj, att) )\n\n\n\n        if obj_type == 8: # Check if the object is a surface\n        \n            \n            boundary_curve_id = rs.DuplicateSurfaceBorder(obj)\n            # Get points along the boundary curve\n            points = rs.CurvePoints(boundary_curve_id)\n\n            rs.DeleteObjects(boundary_curve_id)\n            points = points[0:-1:]\n            \n            for i, point in enumerate(points):\n            \n                plans_data = np.append(plans_data, np.array([[ plan_ind, np.round(point[0],5) , np.round( point[1],5), np.round(point[2],5) ]]), axis = 0)\n            \n            plan_ind += 1\n            att_lcase = [item.lower() for item in  rs.GetUserText(obj)]\n        \n\n            if 'type' in att_lcase:\n                index = att_lcase.index('type')\n                if rs.GetUserText(obj, rs.GetUserText(obj)[index]) == '3':\n                    supports_type.append(3)\n                elif rs.GetUserText(obj, rs.GetUserText(obj)[index]) == '2':\n                    supports_type.append(2)\n            else:\n                supports_type.append(-1)\n\n            \n            if 'c' in att_lcase:\n                index = att_lcase.index('c')\n                coh_type.append(float(rs.GetUserText(obj, rs.GetUserText(obj)[index])))\n                \n            else:\n                coh_type.append(-1)\n            \n            if 'phi' in att_lcase:\n                index = att_lcase.index('phi')\n                phi_type.append(float(rs.GetUserText(obj, rs.GetUserText(obj)[index])))\n                \n            else:\n                phi_type.append(-1)\n\n            if 'fc' in att_lcase:\n                index = att_lcase.index('fc')\n                fc_type.append(float(rs.GetUserText(obj, rs.GetUserText(obj)[index])))\n                \n            else:\n                fc_type.append(-1)\n\n            \n            if 'lc' in att_lcase:\n                index = att_lcase.index('lc')\n                lc_type.append(float(rs.GetUserText(obj, rs.GetUserText(obj)[index])))\n                \n            else:\n                lc_type.append(-1)\n\n        \n\n\n            loading_att = set(loading_keys_interest) & set(att_lcase) # surface loading\n            \n            if loading_att:\n                loaded_faces_values.append([0]*8)\n                loaded_faces_adress.append(obj)\n\n                for att in loading_att:\n                    \n                    att_pos = loading_keys_interest.index( att.lower() )\n                  \n                    if rs.GetUserText(obj, att) != \" \":\n                        loaded_faces_values[-1][att_pos] += float( rs.GetUserText(obj, att) )\n                        \n\n\n\n                \n    \n        print(\"loadeddd face\", loaded_faces_values)\n        if obj_type in [16, 1073741824]:  # Check if the object is a solid\n            blocks_adress.append(obj)\n\n            block_name = rs.ObjectName(obj)\n            \n            blocks_brep.append(obj)\n            # Explode the solid into its faces\n            faces_data = rs.ExplodePolysurfaces(obj)\n            \n            if faces_data:\n                for face in faces_data:\n\n                    boundary_curve_id = rs.DuplicateSurfaceBorder(face)\n                    if not boundary_curve_id:\n                        print(\"Failed to extract surface boundary.\")\n                        \n        \n                    # Get points along the boundary curve\n                    points = rs.CurvePoints(boundary_curve_id)\n                    rs.DeleteObjects(boundary_curve_id)\n                    \n                    points = points[0:-1:]\n                    \n\n                    \n                    face_pts = np.empty((0,3))\n                    # Loop through the control points\n                    for i, point in enumerate(points):\n                    \n                        # Print the coordinates of each control point\n                        face_pts = np.append(face_pts, np.array([[ np.round(point[0],5), np.round(point[1],5), np.round(point[2],5) ]]), axis = 0)\n                    \n                \n                    \n                    b_centroid = rs.SurfaceVolumeCentroid(obj)[0]\n                    \n                    face_centroid = np.mean(face_pts, axis = 0)\n                    \n                    face_normal = np.cross(face_centroid - face_pts[0], face_pts[1] - face_pts[0])\n                \n                    face_normal /= np.linalg.norm(face_normal)\n                    \n                    \n                    pts_coor = np.append(pts_coor, face_pts, axis=0)\n\n                    # Get unique points and their indices\n                    pts_coor , unique_indices = np.unique(pts_coor, axis=0, return_index=True)\n\n                    # Reorder the unique points based on their original order\n                    pts_coor = pts_coor[np.argsort(unique_indices)]\n\n                    added_positions = []\n\n                    for point in face_pts:\n                        pt_position = np.where(np.all(pts_coor == point, axis=1))[0][0]\n                        added_positions.append(pt_position +1 )\n                    \n\n                    unsorted_face_rep = '#'.join(map(str, added_positions.copy() ))\n\n                    added_positions_copy = added_positions.copy()\n\n                    sorted_point_indices = sorted(set(added_positions_copy))\n                    #sorted_point_indices = [element + 1 for element in sorted_point_indices]\n\n                    face_rep = '#'.join(map(str, sorted_point_indices ))\n                \n                    if (not face_rep in faces_rep) or block_ind == 1:\n                        faces_rep.append(face_rep)\n                        f_points.append(face_pts)\n                        unsorted_faces_rep.append(unsorted_face_rep)\n\n                        faces_ind += [faces_rep.index(face_rep) + 1 ]\n                        faces_nodes += added_positions\n                        faces_FE.append(faces_FE[-1:][0] + len(added_positions))\n\n\n                        local_ref = check_outward_normal(b_centroid,face_ind,face_centroid,face_normal,local_ref)\n                        local_ref[-1:, 0] = len(faces_rep)\n                    \n                        block_name = -99\n                        blocks = np.append(blocks, np.array([[block_ind, len(faces_rep), block_name, face_ind  , 0,-1, 11 ]]), axis = 0)\n                        for ind in added_positions:\n                            faces = np.append(faces, np.array([[len(faces_rep), face_ind, ind  ]]),axis = 0) #ind or ind+1\n                    else:\n                        contacts_ind += [faces_rep.index(face_rep) + 1 ]\n                        contacts_nodes += added_positions\n                    \n                        contacts_FE.append(contacts_FE[-1:][0] + len(added_positions))\n\n                        block_name = -99\n                        blocks = np.append(blocks, np.array([[block_ind, faces_rep.index(face_rep) + 1, block_name, face_ind, 0 , -1, 22 ]]), axis = 0)\n    \n                    # Do something with each face (e.g., print face area)\n                    face_area = rs.SurfaceArea(face)[1]\n                    \n                    \n                    \n                    face_ind += 1\n\n                    #  delete the exploded face\n                    rs.DeleteObject(face)\n                    rs.DeleteObject(boundary_curve_id)\n                    \n            \n        \n            b_centroid = rs.SurfaceVolumeCentroid(obj)[0]\n            b_volume = rs.SurfaceVolume(obj)[0]\n\n            blocks_volume = np.append(blocks_volume, np.array([[block_ind, b_volume ]]), axis = 0)\n\n            blocks_centroid = np.append(blocks_centroid, np.array([[block_ind, b_centroid[0], b_centroid[1], b_centroid[2] ]]), axis = 0)\n            \n            atb_keys = rs.GetUserText(obj)\n            \n            if atb_keys:\n                \n                b_att = []\n\n                for atb_key in atb_keys:\n                    if atb_key in keys_of_interest:\n                        key_ind = keys_of_interest.index(atb_key)\n                        \n\n                        b_att.extend([key_ind +1, rs.GetUserText(obj, atb_key) ])\n                \n                blocks_att[block_ind] = b_att\n\n    \n            \n            block_ind += 1\n\n\n    nb = block_ind - 1\n\n    # Get the number of rows in the array\n    num_rows = pts_coor.shape[0]\n\n    # Create an array of 1-based indices\n    indices_column = (np.arange(num_rows) + 1).reshape(-1, 1)\n\n    # Add the indices column to the original array\n    points = np.hstack((indices_column, pts_coor),dtype = np.float64)\n\n    data[\"faces_number\"] =  len(faces_rep)\n  \n    plans_rep = []\n    supports_ind = []\n\n    if plans_data.shape[0] != 0:\n        for ind in range(plan_ind-1):\n        \n            plan_elements = plans_data[ np.where(plans_data[:,0] == ind +1 )[0] ]\n    \n            plan_pts = []\n            for  element in plan_elements:\n                pt_coor = element[-3:]\n                pt_ind = np.where( np.all(points[:,-3:] == pt_coor, axis=1)  )[0]\n                \n                plan_pts.extend(pt_ind)\n            \n            sorted_plan_pts = sorted(set(plan_pts))\n            sorted_plan_pts = [element + 1 for element in sorted_plan_pts]\n\n            plan_rep = '#'.join(map(str, sorted_plan_pts ))\n            \n            plans_rep.append(plan_rep)\n            \n        \n    for ind in contacts_ind:    blocks[np.where(blocks[:,1] == ind)[0], 4] = 1\n\n\n    supports_rep = set(plans_rep) &  set(faces_rep)\n\n    for ind in supports_rep :\n        if supports_type[plans_rep.index(ind)] == 2:\n            \n            blocks[np.where(blocks[:,1] == faces_rep.index(ind) +1)[0] , 4] = 2\n            \n            contacts_ind += [faces_rep.index(ind) +1]\n            \n            \n            unsorted_rep = unsorted_faces_rep[faces_rep.index(ind)] \n        \n            nodes_ind = [int(num) for num in unsorted_rep.split('#')]\n            \n            contacts_nodes += nodes_ind\n            \n            contacts_FE += [ contacts_FE[-1:][0] + len(nodes_ind)]\n        \n        if supports_type[plans_rep.index(ind)] == 3:\n\n            supports_ind += [faces_rep.index(ind) +1]\n            blocks[np.where(blocks[:,1] == faces_rep.index(ind) +1)[0] , 4 ] = 3\n\n            contacts_ind += [faces_rep.index(ind) +1]\n        \n            unsorted_rep = unsorted_faces_rep[faces_rep.index(ind)] \n            \n            nodes_ind = [int(num) for num in unsorted_rep.split('#')]\n            \n            contacts_nodes += nodes_ind\n            \n            contacts_FE += [ contacts_FE[-1:][0] + len(nodes_ind)]\n        if coh_type[plans_rep.index(ind)] != -1:\n            blocks[np.where(blocks[:,1] == faces_rep.index(ind) +1)[0] , 5 ] = float(coh_type[plans_rep.index(ind)])\n\n\n\n    contacts_ind_sorted = sorted(contacts_ind)\n\n    for face_pos, face_adress in enumerate(loaded_faces_adress):\n\n        face_centroid = rs.SurfaceAreaCentroid(face_adress)[0]\n        face_centroid = [face_centroid[0],face_centroid[1],  face_centroid[2] ]\n        distances , neighboors = blocks_face_neighboring( blocks_centroid[:, -3:] , face_centroid, 40  )\n        print(distances)\n\n        real_distances_pos = np.where(distances != np.inf)[0] \n\n        print(real_distances_pos)\n\n        for index in real_distances_pos:\n            \n            block_adress  = blocks_adress[neighboors[index]]\n            inter = rs.IntersectBreps(face_adress, block_adress)\n            \n            \n            if inter:\n                if rs.IsCurveClosed(inter):\n                    \n                    print(\"enteredddd\")\n                    area = rs.Area(inter)\n                    centroid = rs.CurveAreaCentroid(inter)[0]\n                    centroid = [ centroid[0],  centroid[1], centroid[2] ]\n\n                    crv_points = rs.CurvePoints(inter)  \n\n                    print(crv_points)    \n                    pt1 =  crv_points[0]\n                    pt2 =  crv_points[1]\n                    pt3 =  crv_points[-2]\n                    print(pt1)\n                    print(pt2)\n                    print(pt3)\n                    vect1 = [pt1[i]-pt2[i] for i in range(3)]\n                    vect2 = [pt3[i]-pt2[i] for i in range(3)]\n\n                    normal = np.cross(vect1, vect2)\n                    normal /= np.linalg.norm(normal)\n                    print(vect1, vect2 , normal)\n                    test_vector = [blocks_centroid[index][i+1] - centroid[i]  for i in range(3)  ]\n\n                    if np.dot(test_vector, normal ) >0:\n                        normal = [-element for element in normal]\n\n                    \n                    Dead_load = [area*loaded_faces_values[face_pos][4], area*loaded_faces_values[face_pos][5], area*loaded_faces_values[face_pos][6] ]\n                    print(Dead_load)\n\n                    Dead_load = [Dead_load[i] + normal[i]*area*loaded_faces_values[face_pos][7] for i in range(3) ]\n                        \n                    print(Dead_load)\n                    Live_load = [area*loaded_faces_values[face_pos][0], area*loaded_faces_values[face_pos][1], area*loaded_faces_values[face_pos][2] ]\n                    Live_load = [Live_load[i] + normal[i]*area*loaded_faces_values[face_pos][3] for i in range(3) ]\n                    \n                    \n\n                    moment_dead = calculate_moment(blocks_centroid[index][-3:], Dead_load  , centroid  )\n                    print(moment_dead)\n\n                    moment_live = calculate_moment(blocks_centroid[index][-3:], Live_load  , centroid  )\n\n                    if neighboors[index] not in loaded_blocks:\n                        loaded_blocks.append(neighboors[index])\n                        torseur_blocks_dead.append( [*Dead_load, *moment_dead ])\n                        torseur_blocks_live.append( [*Live_load, *moment_live ])\n                    else:\n                        block_pos = loaded_blocks.index(neighboors[index])#not sure\n\n                        torseur_blocks_dead[block_pos] = [  element + torseur_blocks_dead[block_pos][ind]  for ind, element in enumerate([*Dead_load, *moment_dead ])  ]\n                        torseur_blocks_live[block_pos] = [  element + torseur_blocks_live[block_pos][ind]  for ind, element in enumerate([*Live_load, *moment_live ]) ]\n\n\n                    \n                    \n                    rs.DeleteObjects(inter)\n    \n       \n    for point_pos, point_adress in enumerate(loaded_points_adress):\n        \n        loading_point_points = np.empty((0,3)) #mesh for poly loading and\n        points_ind = []\n\n        points_torseur_blocks_dead = []\n\n        points_torseur_blocks_live = []\n\n        points_loaded_blocks = []\n\n    \n\n        \n        point_coor = [ rs.PointCoordinates(point_adress)[0], rs.PointCoordinates(point_adress)[1], rs.PointCoordinates(point_adress)[2] ]\n        \n\n        distances , neighboors = blocks_face_neighboring( blocks_centroid[:, -3:] , point_coor , 40  )\n\n        real_distances_pos = np.where(distances != np.inf)[0] \n\n       \n        \n\n        for index in real_distances_pos:\n\n            block_adress  = blocks_adress[neighboors[index]]\n\n            faces_adress = rs.ExplodePolysurfaces(block_adress)\n            \n\n            for face in faces_adress :\n\n                if rs.IsPointOnSurface(face,point_adress):\n                   \n                    \n                    rs.DeleteObject(face)\n                    search_pt1 = np.where( np.all(loading_point_points == point_coor , axis = 1) )[0]\n                    if len(search_pt1) != 0:\n                        points_ind.append( int(search_pt1[0]) + 1)\n                    else:\n                        loading_point_points = np.append(loading_point_points , np.array([point_coor]) ,axis = 0 )\n                        points_ind.append( loading_point_points.shape[0] )\n                \n                    Dead_load = [ loaded_points_values[point_pos][6], loaded_points_values[point_pos][7], loaded_points_values[point_pos][8] ]\n                        \n                    Live_load = [ loaded_points_values[point_pos][0], loaded_points_values[point_pos][1], loaded_points_values[point_pos][2] ]\n            \n                    moment_dead = calculate_moment(blocks_centroid[neighboors[index]][-3:], Dead_load  , point_coor  )\n                    moment_live = calculate_moment(blocks_centroid[neighboors[index]][-3:], Live_load  , point_coor  )\n\n                    moment_dead = [ element1 + element2 for element1, element2 in zip(moment_dead, loaded_points_values[point_pos][9:12] ) ]   \n\n                    moment_live = [ element1 + element2 for element1, element2 in zip(moment_live, loaded_points_values[point_pos][3:6] ) ]  \n\n\n                    points_torseur_blocks_dead.append( [*Dead_load, *moment_dead ])\n                    points_torseur_blocks_live.append( [*Live_load, *moment_live ])\n\n                    points_loaded_blocks.append(neighboors[index])\n                    \n                    \n                    \n                    break\n                else:\n                 \n                    rs.DeleteObject(face)\n\n            rs.DeleteObjects(faces_adress)\n                \n      \n\n        for i, point_loaded_block in enumerate(points_loaded_blocks):\n            point_occ = points_ind.count( points_ind[i] )\n     \n\n            if point_loaded_block not in loaded_blocks:\n                loaded_blocks.append(point_loaded_block)\n                torseur_blocks_dead.append( [ element/point_occ  for element in points_torseur_blocks_dead[i]   ])\n                torseur_blocks_live.append(  [ element/point_occ  for element in points_torseur_blocks_live[i]   ])\n            \n            else:\n\n                block_pos = loaded_blocks.index(point_loaded_block)\n\n                torseur_blocks_dead[block_pos] = [  element/point_occ + torseur_blocks_dead[block_pos][ind]  for ind, element in enumerate( points_torseur_blocks_dead[i] )  ]\n                torseur_blocks_live[block_pos] = [  element/point_occ + torseur_blocks_live[block_pos][ind]  for ind, element in enumerate( points_torseur_blocks_live[i] ) ]\n\n\n\n    for poly_pos, poly_adress in enumerate(loaded_poly_adress):\n        \n        loading_poly_points = np.empty((0,3)) #mesh for poly loading and\n        polys_rep = []\n\n        poly_torseur_blocks_dead = []\n\n        poly_torseur_blocks_live = []\n\n        poly_loaded_blocks = []\n\n        points_poly = rs.CurvePoints(poly_adress)\n             \n        pt1 =  [round(points_poly[0][i],5) for i in range(3) ] \n        \n\n        distances , neighboors = blocks_face_neighboring( blocks_centroid[:, -3:] , pt1, 40  )\n\n        real_distances_pos = np.where(distances != np.inf)[0] \n\n        for index in real_distances_pos:\n\n            \n            block_adress  = blocks_adress[neighboors[index]]\n            \n            inter = rs.CurveBrepIntersect(poly_adress , block_adress   )\n            \n            \n            if inter:\n                for line in inter[0]:\n            \n                    points_poly = rs.CurvePoints(line)\n             \n                    pt1 =  [round(points_poly[0][i],5) for i in range(3) ] \n                    pt2 =  [round(points_poly[-1][i],5) for i in range(3) ]\n                    \n                    search_pt1 = np.where( np.all(loading_poly_points == pt1 , axis = 1) )[0]\n                    if len(search_pt1) != 0:\n                        pt1_pos = int(search_pt1[0]) + 1\n                    else:\n                        loading_poly_points = np.append(loading_poly_points , np.array([pt1]) ,axis = 0 )\n                        pt1_pos = loading_poly_points.shape[0]\n\n                    search_pt2 = np.where( np.all(loading_poly_points == pt2 , axis = 1) )[0]\n                    if len(search_pt2) != 0:\n                        pt2_pos = int(search_pt2[0]) + 1\n                    else:\n                        loading_poly_points = np.append(loading_poly_points , np.array([pt2]) ,axis = 0 )\n                        pt2_pos = loading_poly_points.shape[0]\n\n                    poly_rep = '#'.join(map(str, [min(pt1_pos, pt2_pos) ,  max(pt1_pos, pt2_pos) ] )) \n\n                    polys_rep.append(poly_rep)\n\n\n                    line_centroid = [ 0.5*pt1[i] + 0.5*pt2[i] for i in range(3)]\n                    line_length = rs.CurveLength(line)\n            \n                    Dead_load = [line_length*loaded_poly_values[poly_pos][4], line_length*loaded_poly_values[poly_pos][5], line_length*loaded_poly_values[poly_pos][6] ]\n                    \n                    Live_load = [line_length*loaded_poly_values[poly_pos][0], line_length*loaded_poly_values[poly_pos][1], line_length*loaded_poly_values[poly_pos][2] ]\n          \n                    moment_dead = calculate_moment(blocks_centroid[neighboors[index]][-3:], Dead_load  , line_centroid  )\n                    moment_live = calculate_moment(blocks_centroid[neighboors[index]][-3:], Live_load  , line_centroid  )\n\n\n                    poly_torseur_blocks_dead.append( [*Dead_load, *moment_dead ])\n                    poly_torseur_blocks_live.append( [*Live_load, *moment_live ])\n\n                    poly_loaded_blocks.append(neighboors[index])\n\n                    rs.DeleteObjects(line)  \n        \n        for i, poly_loaded_block in enumerate(poly_loaded_blocks):\n            poly_occ = polys_rep.count( polys_rep[i] )\n      \n\n            if poly_loaded_block not in loaded_blocks:\n                loaded_blocks.append(poly_loaded_block)\n                torseur_blocks_dead.append( [ element/poly_occ  for element in poly_torseur_blocks_dead[i]   ])\n                torseur_blocks_live.append(  [ element/poly_occ  for element in poly_torseur_blocks_live[i]   ])\n            \n            else:\n\n                block_pos = loaded_blocks.index(poly_loaded_block)\n\n                torseur_blocks_dead[block_pos] = [  element/poly_occ + torseur_blocks_dead[block_pos][ind]  for ind, element in enumerate( poly_torseur_blocks_dead[i] )  ]\n                torseur_blocks_live[block_pos] = [  element/poly_occ + torseur_blocks_live[block_pos][ind]  for ind, element in enumerate( poly_torseur_blocks_live[i] ) ]\n        #jkjk\n\n\n\n    supports_pos = []\n    for ind in supports_ind:\n        supports_pos += [contacts_ind_sorted.index(ind)]\n\n\n\n    curve_ids = bars\n\n    if not curve_ids:\n        print(\"No curve selected. Exiting...\")\n        #quit()\n    rs.EnableRedraw(False)\n\n\n    bpts_inter = np.empty((0,3))\n    bars_data = np.empty((0,7))\n\n    ##Calculate steel rebars load and moment effect\n\n    for block_ind, solid_id in enumerate(blocks_brep):\n        pts_pos = set()\n        # Split the curves with the solid\n        for curve_id in curve_ids:\n            added_positions = []\n            att_num = 0\n\n            atb_keys = rs.GetUserText(curve_id)   \n            if atb_keys:\n                \n                for atb_key in atb_keys:\n                    if atb_key == 'A':\n                        bar_area = rs.GetUserText(curve_id, 'A')\n                        att_num += 1\n                    if atb_key == 'fy':\n                        bar_fy = rs.GetUserText(curve_id, 'fy')\n                        att_num += 1\n                        \n            if att_num == 2:\n                exploded_curve = rs.ExplodeCurves(curve_id)\n            \n                for line in exploded_curve:\n                    start_pt = rs.CurvePoints(line)[0]\n                    end_pt = rs.CurvePoints(line)[1]\n                \n                    bar_dir = np.array([start_pt[0]- end_pt[0]  , start_pt[1]- end_pt[1], start_pt[2]- end_pt[2]  ] )\n                    \n                    bar_dir /= np.linalg.norm(bar_dir)  \n                    bar_dir = [np.round(element, 5)  for element in bar_dir]\n                    # Check if the curve intersects with the solid\n                    if rs.CurveBrepIntersect(line, solid_id):\n            \n                        \n                        inter1_coor = rs.PointCoordinates((rs.CurveBrepIntersect(line, solid_id)[1][0]))\n                        inter1_coor = [inter1_coor[0], inter1_coor[1], inter1_coor[2] ]\n                        part_to_add = np.array( [inter1_coor])\n\n                        if len(rs.CurveBrepIntersect(line, solid_id)[1]) == 2:\n                            inter2_coor = rs.PointCoordinates((rs.CurveBrepIntersect(line, solid_id)[1][1]))\n                            inter2_coor = [inter2_coor[0], inter2_coor[1], inter2_coor[2]]\n                            part_to_add = np.array( [inter1_coor, inter2_coor])\n                    \n                        part_to_add = np.round(part_to_add, decimals=5)\n\n                        bpts_inter = np.append(bpts_inter, part_to_add , axis = 0)\n                        # Get unique points and their indice\n                        bpts_inter , unique_indices = np.unique(bpts_inter, axis=0, return_index=True)\n                \n                        # Reorder the unique points based on their original order\n                        bpts_inter = bpts_inter[np.argsort(unique_indices)]\n                    \n                        # Use broadcasting to compare all points in points_array with each point in set_of_points\n                        matches = np.all(np.expand_dims( bpts_inter, axis=1) == part_to_add, axis=2)\n\n                        # Find row indices where any row in set_of_points matches points_array\n                        added_positions = np.where(matches.any(axis=1))[0]\n                    \n                \n                        \n                        if len(added_positions) != 0:\n                            \n                            for  pt_pos in added_positions:\n                                \n                                pt_coor = bpts_inter[pt_pos]\n                                if np.dot(bar_dir, np.array(blocks_centroid[block_ind, -3:] )- np.array(pt_coor)) > 0:\n                                    bar_dir = [-1*element for element in bar_dir]\n                                \n                                bars_data = np.append( bars_data, np.array([[int(block_ind +1) , int(pt_pos +1), float(bar_area), float(bar_fy), *bar_dir  ]] ),axis = 0   )  \n            \n                rs.DeleteObjects(exploded_curve)\n\n    rs.EnableRedraw(True)\n\n\n    \n\n    lc_faces_val = lc*np.ones((len(contacts_ind)), dtype = np.float64)\n\n\n    for ind, lc_face  in enumerate(lc_type):\n        if lc_face != -1:\n        \n            face_ind = faces_rep.index( plans_rep[ind] )\n            contact_ind = contacts_ind.index(face_ind + 1)\n        \n            lc_faces_val[contact_ind] = float(lc_face)\n\n\n    bars_data = np.unique(bars_data,axis = 0)\n\n    contacts_ind = np.array(contacts_ind, dtype = np.int32)\n    contacts_nodes = np.array(contacts_nodes, dtype = np.int32)\n    contacts_FE = np.array(contacts_FE, dtype = np.int32)\n\n    \n\n    contacts_ind = np.array(contacts_ind, dtype = np.int32)\n    faces_nodes = np.array(faces_nodes, dtype = np.int32)\n    faces_FE = np.array(faces_FE, dtype = np.int32)\n\n    data[\"points\"] = points\n    data[\"blocks\"] = blocks\n    data[\"faces\"] = faces\n    data[\"blocks_volume\"] = blocks_volume\n    data[\"blocks_centroid\"] = blocks_centroid\n    data[\"local_ref\"] = local_ref\n    data[\"lc_faces_val\"] = lc_faces_val\n    data[\"contacts_ind\"] = contacts_ind\n    data[\"faces_FE\"] = faces_FE\n    data[\"faces_nodes\"] = faces_nodes\n\n    data[\"faces_rep\"] = faces_rep\n    data[\"plans_rep\"] = plans_rep\n\n    data[\"supports_pos\"] = supports_pos\n    data[\"coh_type\"] = coh_type\n    data[\"phi_type\"] = phi_type\n    data[\"fc_type\"] = fc_type\n    data[\"blocks_att\"] = blocks_att\n    data[\"bpts_inter\"] = bpts_inter\n    data[\"bars_data\"] = bars_data\n\n    data[\"contacts_ind_sorted\"] = contacts_ind_sorted\n\n    data[\"nb\"] = nb\n    data[\"loaded_blocks\"] = loaded_blocks\n    data[\"torseur_blocks_dead\"] = torseur_blocks_dead\n    data[\"torseur_blocks_live\"] = torseur_blocks_live\n\n    read_data_end = time.time()\n\n    calc_time = dict()\n    data[\"calc_time\"] = {\"read_rhino_data_time\" : read_data_end - read_data_start }\n\n    \n    \n    \n\n    return data\n    \n\n\n#### second part \ndef generate_mesh_and_construct_matrices(data):  \n    \n    contacts_ind = data[\"contacts_ind\"]\n    blocks = data[\"blocks\"]\n    points = data[\"points\"]\n    faces_FE = data[\"faces_FE\"]\n    faces_nodes = data[\"faces_nodes\"]\n    blocks_centroid = data[\"blocks_centroid\"]\n    local_ref = data[\"local_ref\"]\n    lc_faces_val = data[\"lc_faces_val\"]\n\n    coh_type = data[\"coh_type\"]\n    supports_pos = data[\"supports_pos\"]\n    faces_rep = data[\"faces_rep\"] \n    plans_rep = data[\"plans_rep\"]\n    contacts_ind_sorted = data[\"contacts_ind_sorted\"]\n    phi_type = data[\"phi_type\"]\n    \n    #fc_type = data[\"fc_type\"]\n\n    tri_mesh = data[\"tri_mesh\"]\n\n    lc_ncn = data[\"lc_ncn\"]\n\n    # Call C++ function \n\n    points_coor = np.array(points[:,1:4] , dtype = np.float64)\n   \n\n    output = mesh.generate_mesh_and_construct_matrices( contacts_ind,  blocks , points_coor,  faces_FE, faces_nodes, blocks_centroid , \\\n                        local_ref, np.array(lc_faces_val, dtype = np.float64), lc_ncn, tri_mesh )\n\n    \n    data[\"calc_time\"][\" \"] = \" \"\n    data[\"calc_time\"][\"faces_mesh\"] = output[-1:][0][0]\n    data[\"calc_time\"][\"read_mesh\"] = output[-1:][0][1]\n    data[\"calc_time\"][\"Cpp_matrices_construction\"] = output[-1:][0][2]\n\n   \n    supports_nodes = set()\n\n\n    for pos in supports_pos:\n        for tri in output[7][pos]:\n                supports_nodes.update({ element for element in tri } )\n\n    supports_nodes = list(supports_nodes)\n\n    all_coh_nodes = []\n    all_coh_val = []\n\n\n    for ind, coh in enumerate(coh_type):\n        if coh != -1:\n            faces_pos = faces_rep.index( plans_rep[ind] )\n            contact_pos = contacts_ind_sorted.index( faces_pos + 1 )\n\n            contact_nodes = []\n            for tri in output[7][contact_pos]:\n                contact_nodes += [element for element in tri if element not in contact_nodes ]\n            \n            all_coh_nodes += contact_nodes \n            all_coh_val += [coh for i in range(len(contact_nodes))] \n\n\n    all_coh_nodes = list(all_coh_nodes)\n\n\n    all_phi_nodes = []\n    all_phi_val = []\n \n    for ind, phi in enumerate(phi_type):\n        if phi != -1:\n            \n            faces_pos = faces_rep.index( plans_rep[ind] )\n            contact_pos = contacts_ind_sorted.index( faces_pos + 1 )\n\n            contact_nodes = []\n            for tri in output[7][contact_pos]:\n                contact_nodes += [element for element in tri if element not in contact_nodes ]\n            \n            all_phi_nodes += contact_nodes\n            all_phi_val += [phi for i in range(len(contact_nodes))] \n\n    all_fc_nodes = []\n    all_fc_val = []\n\n    fc_type = data[\"fc_type\"]\n    for ind, fc in enumerate(fc_type):\n        if fc != -1:\n            \n            faces_pos = faces_rep.index( plans_rep[ind] )\n            contact_pos = contacts_ind_sorted.index( faces_pos + 1 )\n\n            contact_nodes = []\n            for tri in output[7][contact_pos]:\n                \n                contact_nodes += [element for element in tri if element not in contact_nodes ]\n            \n            all_fc_nodes += contact_nodes\n            all_fc_val += [fc for i in range(len(contact_nodes))] \n\n    \n\n\n    all_fc_nodes = list(all_fc_nodes)\n    all_phi_nodes = list(all_phi_nodes)\n\n    data[\"supports_nodes\"] = supports_nodes\n    \n    data[\"all_phi_nodes\"] = all_phi_nodes\n    data[\"all_fc_nodes\"] = all_fc_nodes\n    data[\"all_coh_nodes\"] = all_coh_nodes\n\n    data[\"all_phi_val\"] = all_phi_val\n    data[\"all_fc_val\"] = all_fc_val\n    data[\"all_coh_val\"] = all_coh_val\n    \n    data[\"Coutput\"] = output\n \n    return data\n\n\n### third part\n\n\n\n# Define a stream printer to capture the solver output\ndef stream_printer(text,log_path):\n    with open(log_path, \"a\") as f:\n        f.write(text)\n\n\n# New function to add a title/header to the log file\ndef add_solution_title(title,log_path):\n    with open(log_path, \"a\") as f:\n        f.write(f\"\\n{title}\\n\")  # Write the title with newlines for separation\n        f.flush()  # Explicitly flush to ensure it's written immediately\n\ndef log_objective_value(task,log_path):\n    obj_value = task.getprimalobj(mosek.soltype.itr)  # Assuming you're interested in the interior solution\n    with open(log_path, \"a\") as f:\n        f.write(f\"Objective Value: {obj_value}\\n\")\n        f.flush()\n\ndef solve_problem_with_solvers(data):\n    loaded_blocks = data[\"loaded_blocks\"]  \n    torseur_blocks_dead= data[\"torseur_blocks_dead\"] \n    torseur_blocks_live = data[\"torseur_blocks_live\"] \n\n    fig = go.Figure()\n\n    \n    nb = data[\"nb\"]\n\n    output = data[\"Coutput\"]  \n    \n    equilibrium_matrix_row = output[1]\n    equilibrium_matrix_col = output[2]\n    equilibrium_matrix = output[0]\n\n    equilibrium_matrix_load_row = output[4]\n    equilibrium_matrix_load_col = output[5]\n    equilibrium_matrix_load = output[3]\n\n    area = output[12]\n\n \n    n = int((max(equilibrium_matrix_col)+1)/3)\n    \n    \n    equilibrium_matrix_row = [int(element) for element in equilibrium_matrix_row]\n\n    equilibrium_matrix_col = [int(element) for element in equilibrium_matrix_col]\n\n\n    equilibrium_matrix_load_row = [int(element) for element in equilibrium_matrix_load_row]\n\n    equilibrium_matrix_load_col = [int(element) for element in equilibrium_matrix_load_col]\n\n\n    live_load = [0]*6*nb\n    \n    blocks_att = data[\"blocks_att\"]\n    bpts_inter = data[\"bpts_inter\"] \n\n    #### blocks attributes\n \n\n    for index, block_ind in enumerate(loaded_blocks):\n        block_att = [ ]\n        live = [0]*6\n       \n        \n\n        if block_ind + 1 in blocks_att : # are both floats\n                for att in range(0, len(blocks_att[block_ind + 1]), 2):\n                    live[ blocks_att[block_ind + 1][att] - 1 ] += float(blocks_att[block_ind + 1][att + 1])\n        \n        \n        live = [live[i] + torseur_blocks_live[index][i] for i in range(6)]\n\n        for ind, element in enumerate(live):\n            if abs(element) > 1e-10:\n                block_att += [ind+1, element]\n        \n        blocks_att[block_ind + 1] = block_att\n\n    for block_ind , block_attributes in blocks_att.items():\n        for ind in range(0,len(block_attributes),2):\n            key = block_attributes[ind]\n            \n            \n            val = block_attributes[ind+1]\n            \n            #live_load[block_ind*6 - 6 + key - 1] =  float(val)\n            \n            equilibrium_matrix.append( float(val))\n            equilibrium_matrix_row.append(  (block_ind)*6 - 6 + key - 1  )\n            equilibrium_matrix_col.append(3*n)\n\n            equilibrium_matrix_load.append( float(val))\n            equilibrium_matrix_load_row.append(  (block_ind)*6 - 6 + key - 1  )\n            equilibrium_matrix_load_col.append(3*n)\n    \n    \n\n    c = np.zeros((3*n +1,1))\n  \n    c[3*n] = -1\n\n    #c = matrix(c) \n    \n    b = np.zeros((6*nb,1 )) \n    \n    blocks_volume = data[\"blocks_volume\"]\n    \n    density = 1.4e-5 # blocks density\n    density = data[\"blocks_density\"]\n    \n\n    weight = 0\n    volume = 0\n   \n    for block_ind, block_volume in enumerate(blocks_volume):\n        b[6*block_ind +2] = density*block_volume[1] \n        volume += block_volume[1] \n        weight += density*block_volume[1] \n        if data[\"seisme\"]:\n            equilibrium_matrix.append( density*block_volume[1]  )\n            equilibrium_matrix_row.append(  (block_ind)*6    )\n            equilibrium_matrix_col.append(3*n)\n\n            equilibrium_matrix_load.append( density*block_volume[1]  )\n            equilibrium_matrix_load_row.append(  (block_ind)*6   )\n            equilibrium_matrix_load_col.append(3*n)\n\n        if data[\"self_weight_failure\"]:\n            equilibrium_matrix.append( -density*block_volume[1]  )\n            equilibrium_matrix_row.append(  (block_ind)*6 + 2    )\n            equilibrium_matrix_col.append(3*n)\n\n            equilibrium_matrix_load.append( -density*block_volume[1]  )\n            equilibrium_matrix_load_row.append(  (block_ind)*6  + 2 )\n            equilibrium_matrix_load_col.append(3*n)\n\n    \n    for ind ,block_ind in enumerate(loaded_blocks):\n        \n        b[6*block_ind:6*block_ind+6] = [ b[6*block_ind+i  ] - torseur_blocks_dead[ind][i]   for i in range(6)]\n\n    \n    print(torseur_blocks_dead)\n\n \n    # sparse matrices for the stresses approach to be used in Mosek solver\n    aval = equilibrium_matrix\n    acol = equilibrium_matrix_col\n    arow = equilibrium_matrix_row\n\n\n    # sparse matrices for the loads approach to be used in Mosek solver\n\n    aval_load = equilibrium_matrix_load\n    acol_load = equilibrium_matrix_load_col\n    arow_load = equilibrium_matrix_load_row\n\n    avalk = equilibrium_matrix\n    acolk = equilibrium_matrix_col\n    arowk = equilibrium_matrix_row\n    \n\n    ####Steel rebars attributes\n\n    bars_cap = []\n    bars_data = data[\"bars_data\"]\n    blocks_centroid = data[\"blocks_centroid\"]\n\n    for ind, point_coor in enumerate(bpts_inter):\n        blocks_data = bars_data[ np.where(bars_data[:,1] == ind +1)[0] ]\n        var_col = max(acol) + 1\n        \n        bars_cap.append( float(blocks_data[0][2]) * float(blocks_data[0][3] ) )\n        \n        for block in blocks_data:\n            block_ind = int(block[0]) - 1\n            block_centroid = blocks_centroid[block_ind][-3:]\n            bar_dir = block[-3:]\n            bar_dir = [float(element) for element in bar_dir]\n            \n            bar_moment = calculate_moment( block_centroid, bar_dir, point_coor )\n            \n            bar_tor = list(bar_dir) + list(bar_moment)\n        \n            nzero_pos = [ind for ind in range(6) if np.round(bar_tor[ind],5) != 0]\n            \n            for pos in nzero_pos:\n                \n                arow.append( block_ind*6 + pos )\n                acol.append( var_col )\n                aval.append( float(bar_tor[pos]) )\n\n                arow_load.append( block_ind*6 + pos )\n                acol_load.append( var_col )\n                aval_load.append( float(bar_tor[pos]) )\n\n\n\n    # Since the actual value of Infinity is ignores, we define it solely\n    # for symbolic purposes:\n    inf = 0.0\n\n    nef = n\n    supports_nodes = data[\"supports_nodes\"]\n    all_phi_nodes = data[\"all_phi_nodes\"]\n    all_coh_nodes = data[\"all_coh_nodes\"]\n\n    all_coh_val = data[\"all_coh_val\"]\n    all_phi_val = data[\"all_phi_val\"]\n\n    # Get the directory of the current script\n    rhino_file_dir = data[\"rhino_file_path\"]\n\n    # Construct the path to the log file in the same directory as the script\n    log_path = os.path.join(rhino_file_dir, 'lower_upper_bounds_solutions.log')\n\n\n    data[\"all_unique_points\"] = output[6]\n    data[\"all_triangles\"] = output[7]\n    #triangles_num = max(output[8]) \n\n    data[\"noc_triangles_coor\"] = output[9]\n    data[\"noc_triangles\"] = output[10]\n    #Ntriangles_num = max(output[11]) \n\n    blocks_mesh_parav( data )\n\n    with open(log_path, \"w\") as f:\n        f.write(\"\")  # Clear the file\n\n\n    if data[\"lower_bound_calc\"]:\n        \n        prep_data_lower_bound_start = time.time()\n        add_solution_title(\"Lower Bound Problem: \", log_path)\n        with mosek.Task() as task:\n            task = mosek.Task() \n            # Attach a printer to the task\n            task.set_Stream(mosek.streamtype.log, streamprinter)\n\n            bkx_lb = []\n            cohs = []\n            blx_lb = []\n            bux_lb = []\n\n            \n            for i in range(nef):\n                if (i+1) not in supports_nodes:\n                    \n                    fc = data[\"fc\"]\n                    if (i+1) in data[\"all_fc_nodes\"]:\n                        fc = float( data[\"all_fc_val\"][ data[\"all_fc_nodes\"].index(i + 1)])\n\n                    if fc != False:    \n                        blx_lb += [-inf, -inf , -abs(fc)  ] #variables lower bounds\n                        bkx_lb += [mosek.boundkey.fr, mosek.boundkey.fr, mosek.boundkey.ra] #variables TYPE\n                    else:\n                        blx_lb += [-inf, -inf , -inf ] #variables lower bounds\n                        bkx_lb += [mosek.boundkey.fr, mosek.boundkey.fr, mosek.boundkey.up] #variables TYPE\n                else:\n                    bkx_lb += [mosek.boundkey.fr, mosek.boundkey.fr, mosek.boundkey.fr] #variables TYPE\n                    blx_lb += [-inf, -inf , -inf  ] #variables lower bounds\n            \n            bkx_lb +=  [mosek.boundkey.lo]*1 + [mosek.boundkey.ra]*len(bars_cap)\n\n            \n           \n                \n                \n            blx_lb +=  [0]*1 +  [ -0*element for element in bars_cap] \n\n           \n            ft = data[\"ft\"] \n            for i in range(nef):\n                if i not in supports_nodes:\n                    bux_lb += [inf, inf , abs(ft) ] #variables upper bounds\n                else:\n                    bux_lb += [inf, inf , inf ] #variables upper bounds\n                \n            bux_lb += [inf]*1 + list(bars_cap) #variables upper bounds\n\n            \n            bkc_lb = [mosek.boundkey.fx]*nb*6 #type of constraints (equalities here)\n            print(\"bbbbb\", b )\n            blc_lb = list(b)    #b for equalities\n            buc_lb = list(b) #b for equalities\n          \n        \n            \n            c_lb = np.zeros((3*nef +1,1))\n           \n            c_lb[3*nef] = -1\n            \n            z_lb = [element for element in list(c_lb)] + [0]*len(bars_cap) #objective function \n\n            aval_lb = list(aval)\n            arow_lb = list(arow)\n            acol_lb = list(acol)\n\n\n            ####### a remettre\n            if False:\n                # equalities for kinematic problem\n                arowk = acol.copy()\n                acolk = arow.copy()\n                avalk = aval.copy()\n                for i in range(3*nef):\n                    index = arowk.index(i)\n                    arowk.insert(index, i)\n                    acolk.insert(index, 6*nb + i)\n                    avalk.insert(index, 1)\n                    if ((i+1) % 3 == 0):\n                        index = arowk.index(i)\n                        arowk.insert(index, i)\n                        acolk.insert(  index, 6*nb + 3*n + int((i+1)/3) - 1 )\n                        avalk.insert(index, 1)\n\n             ###### till here        \n      \n           \n            num_lists = 3*nef + 1 + len(bars_cap)  # Adjust the number of inner lists \n    \n          \n            asub_mos_lb = [[] for _ in range(num_lists)]\n            aval_mos_lb  = [[] for _ in range(num_lists)]\n            \n            for i,j in enumerate(acol_lb):\n                asub_mos_lb[int(j)].append(arow_lb[i])\n                aval_mos_lb[int(j)].append(aval_lb[i])\n            \n            numvar_lb = len(bkx_lb)\n            numcon_lb = len(bkc_lb)\n            NUMANZ = 4 \n    \n         # Append 'numcon' empty constraints.\n            # The constraints will initially have no bounds.\n            task.appendcons(numcon_lb)\n    \n            #Append 'numvar' variables.\n            # The variables will initially be fixed at zero (x=0).\n            task.appendvars(numvar_lb)\n    \n            for j in range(numvar_lb):\n                # Set the linear term c_j in the objective.\n                task.putcj(j, z_lb[j])\n                # Set the bounds on variable j\n                # blx[j] <= x_j <= bux[j]\n                task.putvarbound(j, bkx_lb[j], blx_lb[j], bux_lb[j])\n            \n            \n            for j in range(len(aval_mos_lb)):\n                # Input column j of A\n                task.putacol(j,     asub_mos_lb[j],aval_mos_lb[j])            # Non-zero Values of column j.\n            \n         \n        # Input the affine conic constraints\n            task.appendafes(3*nef)\n         \n            list_con_lb = []\n            list_coef_lb = []\n         \n            for ind in range(nef):\n                if (ind +1) not in supports_nodes:\n                    friction_ang = data[\"friction_ang\"]\n                    c = data[\"c\"] # input value\n  \n                    if (ind+1) in all_phi_nodes:\n                        friction_ang = float(all_phi_val[all_phi_nodes.index(ind + 1)])\n      \n                    if (ind+1) in all_coh_nodes:\n                        c = all_coh_val[all_coh_nodes.index(ind+1)]\n                    \n                    cohs += [-c,0,0]\n                    list_con_lb += [3*ind + 2 , 3*ind,3*ind + 1]\n                   \n                    list_coef_lb += [-math.tan(math.radians(friction_ang)),1.0,1.0]\n                    \n             \n            task.putafefentrylist(range(3*nef - len(supports_nodes) ),                      # Rows\n                                list_con_lb ,            # Columns \n                                list_coef_lb  )          #coefficients\n    \n            # Quadratic cone (x(3),x(0),x(1)) \\in QUAD_3 \n            \n            \n            coh_vect_lb = []\n            for ind in range(nef - len(supports_nodes) ):\n                \n                #if ind not in all_supports_ind:\n                if True:\n                   \n                    coh = cohs[3*ind: 3*ind +3]\n                   \n                    coh_vect_lb += coh\n                    quadcone  = task.appendquadraticconedomain(3)\n                    task.appendacc(quadcone,          [3*ind, 3*ind +1, 3*ind + 2],  coh)                    # None if there is no b for conic \n           \n            \n\n            for i in range(numcon_lb):\n                task.putconbound(i, bkc_lb[i], blc_lb[i], buc_lb[i])\n    \n    \n           # Input the objective sense (minimize/maximize)\n            task.putobjsense(mosek.objsense.minimize)\n\n            # Define a stream printer to capture the solver output\n          \n\n            # Attach the stream printer to the task for logging\n            task.set_Stream(mosek.streamtype.log, lambda text: stream_printer(text, log_path))\n            \n            \n            \n            # Now, when you run the optimizer, detailed output will be captured in the specified log file\n            prep_data_lower_bound_end = time.time()\n\n            task.optimize()\n\n            calc_lower_bound_end = time.time()\n\n            log_objective_value(task,log_path)\n\n            data[\"calc_time\"][\"prep_data_lower_bound\"] =   prep_data_lower_bound_end - prep_data_lower_bound_start \n            data[\"calc_time\"][\"calc_data_lower_bound\"] = calc_lower_bound_end - prep_data_lower_bound_end \n\n\n            \n            # Print a summary containing information\n            # about the solution for debugging purposes\n            #task.solutionsummary(mosek.streamtype.msg)\n            prosta = task.getprosta(mosek.soltype.itr)\n            solsta = task.getsolsta(mosek.soltype.itr)\n    \n            # Output a solution\n            xx_lb = task.getxx(mosek.soltype.itr)\n            ub = [task.getsuc(mosek.soltype.itr)[ind] - task.getslc(mosek.soltype.itr)[ind]  for ind in range(6*nb) ] # get dual variables for equilibrium but why upper ? not slb\n            #print(\"xxx\",xx)\n            #print(task.getsuc(mosek.soltype.itr)[0:6*nb])\n            #print(task.getslc(mosek.soltype.itr)[0:6*nb])\n            #print(ub)\n\n            stat_parav(data, \"lb\",xx_lb[0:3*nef + 1])\n\n            kin_parav(data, \"lb\",ub)\n\n           \n\n            if solsta == mosek.solsta.optimal:\n                print(\"Objective: %s\" % xx_lb[-1:])\n                #print(\"Optimal solution: %s\" % dual(xx))\n                # Get dual variables for the linear constraints\n            elif solsta == mosek.solsta.dual_infeas_cer:\n                print(\"Primal or dual infeasibility.\\n\")\n            elif solsta == mosek.solsta.prim_infeas_cer:\n                print(\"Primal or dual infeasibility.\\n\")\n            elif mosek.solsta.unknown:\n                print(\"Unknown solution status\")\n            else:\n                print(\"Other solution status\")\n          \n\n    if data[\"upper_bound_calc\"]:\n        prep_data_upper_bound_start = time.time()\n        add_solution_title(\"Upper Bound Problem: \", log_path)\n        with mosek.Task() as task:\n            task = mosek.Task() \n\n            \n            bkx_ub = []\n            cohs = []\n\n            blx_ub = []\n            bux_ub = []\n\n            #bkx = [mosek.boundkey.fr, mosek.boundkey.fr, mosek.boundkey.up]*nef   #variables lower bounded, if free just put .fr\n            for i in range(nef):\n                if (i+1) not in supports_nodes:\n                    \n                    fc = data[\"fc\"]\n                    if (i+1) in data[\"all_fc_nodes\"]:\n                        fc = float( data[\"all_fc_val\"][ data[\"all_fc_nodes\"].index(i + 1)])\n\n                    if fc != False:    \n                        blx_ub += [-inf, -inf , -abs(fc)*abs(area[i])  ] #variables lower bounds\n                        bkx_ub += [mosek.boundkey.fr, mosek.boundkey.fr, mosek.boundkey.ra] #variables TYPE\n                    else:\n                        blx_ub += [-inf, -inf , -inf ] #variables lower bounds\n                        bkx_ub += [mosek.boundkey.fr, mosek.boundkey.fr, mosek.boundkey.up] #variables TYPE\n                else:\n                    bkx_ub += [mosek.boundkey.fr, mosek.boundkey.fr, mosek.boundkey.fr] #variables TYPE\n                    blx_ub += [-inf, -inf , -inf  ] #variables lower bounds\n\n            bkx_ub +=  [mosek.boundkey.lo]*1 + [mosek.boundkey.ra]*len(bars_cap)\n                              \n            blx_ub +=  [0]*1 +  [ -0*element for element in bars_cap] \n            \n            for i in range(nef):\n                if (i+1) not in supports_nodes:\n                    bux_ub += [inf, inf , 0 ] #variables upper bounds\n                else:\n                   \n                    bux_ub += [inf, inf , inf ] #variables upper bounds\n                \n            bux_ub += [inf]*1 + list(bars_cap) #variables upper bounds\n  \n            \n            bkc_ub = [mosek.boundkey.fx]*nb*6 #type of constraints (equalities here)\n            blc_ub = list(b)    #b for equalities\n            buc_ub = list(b) #b for equalities\n          \n        \n            \n            c = np.zeros((3*nef +1,1))\n            #c =  spmatrix( [-1], [3*n], [0], (3*n +1, 1 ) )   \n           \n            c[3*nef] = -1\n          \n            z_ub = [element for element in list(c)] + [0]*len(bars_cap) #objective function \n\n            \n       \n            aval_ub = list(aval_load)\n            arow_ub = list(arow_load)\n            acol_ub = list(acol_load)\n \n           \n            num_lists = 3*nef + 1 + len(bars_cap)   # Adjust the number of inner lists as needed\n    \n          \n            asub_mos_ub = [[] for _ in range(num_lists)]\n            aval_mos_ub  = [[] for _ in range(num_lists)]\n            \n            for i,j in enumerate(acol_ub):\n                asub_mos_ub[int(j)].append(arow_ub[i])\n                aval_mos_ub[int(j)].append(aval_ub[i])\n            \n\n            numvar_ub = len(bkx_ub)\n            numcon_ub = len(bkc_ub)\n            NUMANZ = 4 \n    \n         # Append 'numcon' empty constraints.\n            # The constraints will initially have no bounds.\n            task.appendcons(numcon_ub)\n    \n            #Append 'numvar' variables.\n            # The variables will initially be fixed at zero (x=0).\n            task.appendvars(numvar_ub)\n    \n            for j in range(numvar_ub):\n                # Set the linear term c_j in the objective.\n                task.putcj(j, z_ub[j])\n                task.putvarbound(j, bkx_ub[j], blx_ub[j], bux_ub[j])\n            \n            \n            for j in range(len(aval_mos_ub)):\n                \n               \n                # Input column j of A\n                task.putacol(j,     asub_mos_ub[j],aval_mos_ub[j])            # Non-zero Values of column j.\n            \n         \n        # Input the affine conic constraints\n            # Create a matrix F such that F * x = [x(3),x(0),x(1),x(4),x(5),x(2)] \n            task.appendafes(3*nef)\n         \n            list_con_ub = []\n            list_coef_ub = []\n           \n            \n            for ind in range(nef):\n                if (ind +1) not in supports_nodes:\n                    friction_ang = data[\"friction_ang\"]\n                    c = data[\"c\"]*area[ind] # input value\n                    \n                    if (ind+1) in all_phi_nodes:\n                        friction_ang = float(all_phi_val[all_phi_nodes.index(ind + 1)])\n      \n                    if (ind+1) in all_coh_nodes:\n                        c = all_coh_val[all_coh_nodes.index(ind+1)]*area[ind]\n                        \n                    cohs += [-c,0,0]\n                    list_con_ub += [3*ind + 2 , 3*ind,3*ind + 1]\n                   \n                    list_coef_ub += [-math.tan(math.radians(friction_ang)),1.0,1.0]\n                    \n             \n            task.putafefentrylist(range(3*nef - len(supports_nodes) ),                      # Rows\n                                list_con_ub ,            # Columns \n                                list_coef_ub  )          #coefficients\n    \n        \n            coh_vect_ub = []\n            for ind in range(nef - len(supports_nodes) ):\n                \n                #if ind not in all_supports_ind:\n                if True:\n                   \n                    coh = cohs[3*ind: 3*ind +3]\n                   \n                    coh_vect_ub += coh\n                    quadcone  = task.appendquadraticconedomain(3)\n                    task.appendacc(quadcone,          [3*ind, 3*ind +1, 3*ind + 2],  coh)                    # None if there is no b for conic \n           \n            \n           \n            \n            for i in range(numcon_ub):\n                task.putconbound(i, bkc_ub[i], blc_ub[i], buc_ub[i])\n    \n    \n        # Input the objective sense (minimize/maximize)\n            task.putobjsense(mosek.objsense.minimize)\n\n            task.set_Stream(mosek.streamtype.log, lambda text: stream_printer(text, log_path))\n\n            prep_data_upper_bound_end = time.time()\n            \n            # Optimize the task\n            task.optimize()\n\n            calc_upper_bound_end = time.time()\n\n            data[\"calc_time\"][\"prep_data_upper_bound\"] =  prep_data_upper_bound_end - prep_data_upper_bound_start \n            data[\"calc_time\"][\"calc_data_upper_bound\"] =  calc_upper_bound_end - prep_data_upper_bound_end \n\n\n            log_objective_value(task,log_path)\n            #task.writedata(\"cqo1.ptf\")\n            # Print a summary containing information\n            # about the solution for debugging purposes\n            #task.solutionsummary(mosek.streamtype.msg)\n            prosta = task.getprosta(mosek.soltype.itr)\n            solsta = task.getsolsta(mosek.soltype.itr)\n    \n            # Output a solution\n            xx_ub = task.getxx(mosek.soltype.itr)\n            ub = [task.getsuc(mosek.soltype.itr)[ind] - task.getslc(mosek.soltype.itr)[ind]  for ind in range(6*nb) ] # get dual variables for equilibrium but why upper ? not slb\n            \n\n            stat_parav(data, \"ub\",xx_ub[0:3*nef + 1])\n\n            kin_parav(data, \"ub\",ub)\n            \n            #skc, y = task.getsolution(mosek.soltype.bas)\n            if solsta == mosek.solsta.optimal:\n                print(\"Objective: %s\" % xx_ub[3*nef])\n                #print(\"Optimal solution: %s\" % dual(xx))\n                # Get dual variables for the linear constraints\n                \n              \n            elif solsta == mosek.solsta.dual_infeas_cer:\n                print(\"Primal or dual infeasibility.\\n\")\n            elif solsta == mosek.solsta.prim_infeas_cer:\n                print(\"Primal or dual infeasibility.\\n\")\n            elif mosek.solsta.unknown:\n                print(\"Unknown solution status\")\n            else:\n                print(\"Other solution status\")\n          \n        \n    #non associative calc\n    tol =1\n    itr = 0\n    \n    alpha= data[\"alpha\"]\n    beta= data[\"beta\"]\n    #tolerance=0.001\n    tolerance= data[\"tolerance\"]\n    \n\n \n    if data[\"ub_non_ass_calc\"]:\n\n        \n        # Construct the path to the log file in the same directory as the script\n        log_path = os.path.join(rhino_file_dir, 'ub_non_ass_solutions.log')\n\n        with open(log_path, \"w\") as f:\n            f.write(\"\")  # Clear the file\n\n        \n\n        while tol >tolerance: \n    \n            # Check if the solver found an optimal solution\n            if solsta == mosek.solsta.optimal:\n          \n                if itr>1:\n                    normalvalues_old = normalvalues\n                else:\n                    normalvalues_old = np.zeros((int(nef) - len(supports_nodes),1))\n                    normal = []\n                    for element in range(0,len(xx_ub)-2,3):\n                        if int(element /3 + 1) not in supports_nodes:\n                            normal += [xx_ub[element+2]]\n\n                    normal = np.array(normal).reshape(-1,1)\n                    # Apply KMeans with 2 clusters to normal loads values\n                    kmeans_normal = KMeans(n_clusters=2, random_state=0).fit(normal)\n\n                    # Split values based on the KMeans labels\n                    cluster_1 = [normal[i] for i in range(len(normal)) if kmeans_normal.labels_[i] == 0]\n                    min_normal = min(cluster_1)\n\n                statsolver_old = xx_ub[3*nef]   \n                \n                normalvalues = np.empty((0,1))\n               \n                \n                for element in range(0,len(xx_ub)-2,3):\n                    if int(element /3 + 1) not in supports_nodes:\n                        normalvalues = np.append(normalvalues,xx_ub[element+2]) \n            \n            coh_vect_new = [0,0,0]*len(coh_vect_ub)\n            friction_coef_new = [1,1,1]*len(list_coef_ub)\n       \n\n            \n            for element in range(int(nef - len(supports_nodes))):\n\n                if abs(normalvalues[element]) > 1e-5:\n                    coh_corr = normalvalues[element]\n                else:\n                    coh_corr = min_normal\n                 \n\n\n                if itr >1:\n                    coh_vect_new[3*element] =  0.00001*coh_corr +  coh_vect_ub[3*element] + (1+alpha)*abs(list_coef_ub[3*element])*(beta*normalvalues[element] + (1-beta)*normalvalues_old[element]) \n                    friction_coef_new[3*element] = -math.tan(math.radians(data[\"friction_ang\"])*alpha)\n                    \n                else:\n        \n                    coh_vect_new[3*element] = 0.00001*coh_corr + coh_vect_ub[3*element] + (1+alpha)*abs(list_coef_ub[3*element])*(normalvalues[element] )\n                    friction_coef_new[3*element] = -math.tan(math.radians(data[\"friction_ang\"])*alpha)\n                    \n            #-list_coef[3*element]*alpha\n            statsol_old = xx_ub\n\n           \n    \n            #mosek\n            with mosek.Task() as task:\n                # Attach a printer to the task\n                task.set_Stream(mosek.streamtype.log, streamprinter)\n        \n                \n             # Append 'numcon' empty constraints.\n                # The constraints will initially have no bounds.\n                task.appendcons(numcon_ub)\n        \n                #Append 'numvar' variables.\n                # The variables will initially be fixed at zero (x=0).\n                task.appendvars(numvar_ub)\n        \n                for j in range(numvar_ub):\n                    # Set the linear term c_j in the objective.\n                    task.putcj(j, z_ub[j])\n                    # Set the bounds on variable j\n                    # blx[j] <= x_j <= bux[j]\n                    task.putvarbound(j, bkx_ub[j], blx_ub[j], bux_ub[j])\n                \n                \n                for j in range(len(aval_mos_ub)):\n                    \n                   \n                    # Input column j of A\n                    task.putacol(j,      asub_mos_ub[j],aval_mos_ub[j])            # Non-zero Values of column j.\n                \n                \n        \n            # Input the affine conic constraints\n\n                task.appendafes(3*nef)\n                \n                list_con_ub = []\n                \n\n                for ind in range(nef):\n                    if (ind+1) not in supports_nodes:\n                    \n                        list_con_ub += [3*ind + 2 , 3*ind,3*ind + 1]\n                        #list_coef += [-math.tan(math.radians(friction_ang)),1.0,1.0]\n                    \n                task.putafefentrylist(range(3*nef - len(supports_nodes) ),                      # Rows\n                                    list_con_ub ,            # Columns \n                                    friction_coef_new  )          #coefficients\n        \n                # Quadratic cone (x(3),x(0),x(1)) \\in QUAD_3 \n       \n\n           \n                for ind in range(nef - len(supports_nodes) ):\n                    \n                    #if ind not in all_supports_ind:\n                    if True:\n                        quadcone  = task.appendquadraticconedomain(3)\n                        task.appendacc(quadcone, [3*ind, 3*ind +1, 3*ind + 2],   [coh_vect_new[3*ind], coh_vect_new[3*ind +1] , coh_vect_new[3*ind +2] ] )                    # None if there is no b for conic \n           \n                \n                for i in range(numcon_ub):\n                    task.putconbound(i, bkc_ub[i], blc_ub[i], buc_ub[i])\n        \n        \n            # Input the objective sense (minimize/maximize)\n                task.putobjsense(mosek.objsense.minimize)\n\n                #task.putintparam(mosek.iparam.log, 0)\n\n                # Attach the stream printer to the task for logging\n                task.set_Stream(mosek.streamtype.log, lambda text: stream_printer(text, log_path))\n                # Optimize the task\n                task.optimize()\n                with open(log_path, \"a\") as f:\n                    f.write(f\"min normal: {min(normalvalues)}\\n\")\n                    f.write(f\"min_normal: {min_normal}\\n\")\n\n                    f.flush()\n                #task.writedata(\"cqo1.ptf\")\n                # Print a summary containing information\n                # about the solution for debugging purposes\n                #task.solutionsummary(mosek.streamtype.msg)\n                prosta = task.getprosta(mosek.soltype.itr)\n                solsta = task.getsolsta(mosek.soltype.itr)\n        \n                # Output a solution\n                xx_ub = task.getxx(mosek.soltype.itr)\n                \n                ub = [task.getsuc(mosek.soltype.itr)[ind] - task.getslc(mosek.soltype.itr)[ind]  for ind in range(6*nb) ] # get dual variables for equilibrium but why upper ? not slb\n            \n                \n                #skc, y = task.getsolution(mosek.soltype.bas)\n                if solsta == mosek.solsta.optimal:\n                    print(\"Objective: %s\" % xx_ub[3*nef])\n                    #print(\"Optimal solution: %s\" % dual(xx))\n                    # Get dual variables for the linear constraints\n                    \n                  \n                elif solsta == mosek.solsta.dual_infeas_cer:\n                    print(\"Primal or dual infeasibility.\\n\")\n                elif solsta == mosek.solsta.prim_infeas_cer:\n                    print(\"Primal or dual infeasibility.\\n\")\n                elif mosek.solsta.unknown:\n                    print(\"Unknown solution status\")\n                else:\n                    print(\"Other solution status\")\n            #end mosek\n    \n                if solsta == mosek.solsta.optimal:\n     \n                    if itr >1:\n                    \n                        tol = abs(xx_ub[3*nef] - statsolver_old)/abs(xx_ub[3*nef] )\n                        print(\"tolerance\", tol)\n                else:\n                    statsol = statsol_old\n                    \n                if alpha <= 0.0001:\n                    alpha = 0.0001\n                else:\n                    alpha = alpha*0.5\n        \n                itr = itr+1\n                # Clear or reset the task\n                \n                del task  # Delete the task object\n                    \n        stat_parav(data, \"ub_non_ass\",xx_ub[0:3*nef + 1])\n\n        kin_parav(data, \"ub_non_ass\",ub)\n\n\n\n    if data[\"lb_non_ass_calc\"]:\n\n        tol =1\n        itr = 0\n        \n        alpha= data[\"alpha\"]\n        beta= data[\"beta\"]\n        #tolerance=0.001\n        tolerance= data[\"tolerance\"]\n\n        \n        # Construct the path to the log file in the same directory as the script\n        log_path = os.path.join(rhino_file_dir, 'lb_non_ass_solutions.log')\n\n        with open(log_path, \"w\") as f:\n            f.write(\"\")  # Clear the file\n\n        \n\n        while tol >tolerance: \n    \n            # Check if the solver found an optimal solution\n            if solsta == mosek.solsta.optimal:\n          \n                if itr>1:\n                    normalvalues_old = normalvalues\n                else:\n                    normalvalues_old = np.zeros((int(nef) - len(supports_nodes),1))\n                    normal = []\n                    for element in range(0,len(xx_lb)-2,3):\n                        if int(element /3 + 1) not in supports_nodes:\n                            normal += [xx_lb[element+2]]\n\n                    normal = np.array(normal).reshape(-1,1)\n                    # Apply KMeans with 2 clusters to normal loads values\n                    kmeans_normal = KMeans(n_clusters=2, random_state=0).fit(normal)\n\n                    # Split values based on the KMeans labels\n                    cluster_1 = [normal[i] for i in range(len(normal)) if kmeans_normal.labels_[i] == 0]\n                    min_normal = min(cluster_1)\n\n                statsolver_old = xx_lb[3*nef]   \n                \n                normalvalues = np.empty((0,1))\n               \n                \n                for element in range(0,len(xx_lb)-2,3):\n                    if int(element /3 + 1) not in supports_nodes:\n                        normalvalues = np.append(normalvalues,xx_lb[element+2]) \n            \n            coh_vect_new = [0,0,0]*len(coh_vect_lb)\n            friction_coef_new = [1,1,1]*len(list_coef_lb)\n       \n\n            \n            for element in range(int(nef - len(supports_nodes))):\n\n                if abs(normalvalues[element]) > 1e-5:\n                    coh_corr = normalvalues[element]\n                else:\n                    coh_corr = min(normalvalues)\n                 \n\n\n                if itr >1:\n                    coh_vect_new[3*element] =  0.000001*coh_corr +  coh_vect_lb[3*element] + (1+alpha)*abs(list_coef_lb[3*element])*(beta*normalvalues[element] + (1-beta)*normalvalues_old[element]) \n                    friction_coef_new[3*element] = -math.tan(math.radians(data[\"friction_ang\"])*alpha)\n                    \n                else:\n        \n                    coh_vect_new[3*element] = 0.000001*coh_corr + coh_vect_lb[3*element] + (1+alpha)*abs(list_coef_lb[3*element])*(normalvalues[element] )\n                    friction_coef_new[3*element] = -math.tan(math.radians(data[\"friction_ang\"])*alpha)\n                    \n            #-list_coef[3*element]*alpha\n            statsol_old = xx_lb\n\n           \n    \n            #mosek\n            with mosek.Task() as task:\n                # Attach a printer to the task\n                task.set_Stream(mosek.streamtype.log, streamprinter)\n    \n             # Append 'numcon' empty constraints.\n                # The constraints will initially have no bounds.\n                task.appendcons(numcon_lb)\n        \n                #Append 'numvar' variables.\n                # The variables will initially be fixed at zero (x=0).\n                task.appendvars(numvar_lb)\n        \n                for j in range(numvar_lb):\n                    # Set the linear term c_j in the objective.\n                    task.putcj(j, z_lb[j])\n                    # Set the bounds on variable j\n                    # blx[j] <= x_j <= bux[j]\n                    task.putvarbound(j, bkx_lb[j], blx_lb[j], bux_lb[j])\n                \n                \n                for j in range(len(aval_mos_lb)):\n                    \n                   \n                    # Input column j of A\n                    task.putacol(j,      asub_mos_lb[j],aval_mos_lb[j])            # Non-zero Values of column j.\n                \n            # Input the affine conic constraints\n\n                task.appendafes(3*nef)\n                \n                list_con_lb = []\n                \n\n                for ind in range(nef):\n                    if (ind+1) not in supports_nodes:\n                    \n                        list_con_lb += [3*ind + 2 , 3*ind,3*ind + 1]\n                      \n                    \n                task.putafefentrylist(range(3*nef - len(supports_nodes) ),                      # Rows\n                                    list_con_lb ,            # Columns \n                                    friction_coef_new  )          #coefficients\n        \n                # Quadratic cone (x(3),x(0),x(1)) \\in QUAD_3 \n       \n\n           \n                for ind in range(nef - len(supports_nodes) ):\n                    \n                    #if ind not in all_supports_ind:\n                    if True:\n                        quadcone  = task.appendquadraticconedomain(3)\n                        task.appendacc(quadcone, [3*ind, 3*ind +1, 3*ind + 2],   [coh_vect_new[3*ind], coh_vect_new[3*ind +1] , coh_vect_new[3*ind +2] ] )                    # None if there is no b for conic \n           \n               \n                for i in range(numcon_lb):\n                    task.putconbound(i, bkc_lb[i], blc_lb[i], buc_lb[i])\n        \n        \n            # Input the objective sense (minimize/maximize)\n                task.putobjsense(mosek.objsense.minimize)\n\n                #task.putintparam(mosek.iparam.log, 0)\n\n                # Attach the stream printer to the task for logging\n                task.set_Stream(mosek.streamtype.log, lambda text: stream_printer(text, log_path))\n                # Optimize the task\n                task.optimize()\n                with open(log_path, \"a\") as f:\n                    f.write(f\"min normal: {min(normalvalues)}\\n\")\n                    f.write(f\"min_normal: {min_normal}\\n\")\n\n                    f.flush()\n               \n                prosta = task.getprosta(mosek.soltype.itr)\n                solsta = task.getsolsta(mosek.soltype.itr)\n        \n                # Output a solution\n                xx_lb = task.getxx(mosek.soltype.itr)\n                \n                ub = [task.getsuc(mosek.soltype.itr)[ind] - task.getslc(mosek.soltype.itr)[ind]  for ind in range(6*nb) ] # get dual variables for equilibrium but why upper ? not slb\n            \n                \n                #skc, y = task.getsolution(mosek.soltype.bas)\n                if solsta == mosek.solsta.optimal:\n                    print(\"Objective: %s\" % xx_lb[3*nef])\n                    #print(\"Optimal solution: %s\" % dual(xx))\n                    # Get dual variables for the linear constraints\n                    \n                  \n                elif solsta == mosek.solsta.dual_infeas_cer:\n                    print(\"Primal or dual infeasibility.\\n\")\n                elif solsta == mosek.solsta.prim_infeas_cer:\n                    print(\"Primal or dual infeasibility.\\n\")\n                elif mosek.solsta.unknown:\n                    print(\"Unknown solution status\")\n                else:\n                    print(\"Other solution status\")\n            #end mosek\n    \n            if solsta == mosek.solsta.optimal:\n    \n                if itr >1:\n                   \n                    tol = abs(xx_lb[3*nef] - statsolver_old)/abs(xx_lb[3*nef] )\n                    print(\"tolerance\", tol)\n            else:\n                statsol = statsol_old\n                \n            if alpha <= 0.0001:\n                alpha = 0.0001\n            else:\n                alpha = alpha*0.5\n    \n            itr = itr+1\n            # Clear or reset the task\n            \n            del task  # Delete the task object\n                \n        stat_parav(data, \"lb_non_ass\",xx_lb[0:3*nef + 1])\n\n        kin_parav(data, \"lb_non_ass\",ub)\n    \n\n    # Construct the path to the data.json file\n    json_file_path = os.path.join(data[\"script_dir\"] , 'calc_time.json')\n    \n\n    with open(json_file_path, 'w') as file:\n        json.dump(data[\"calc_time\"], file, indent=4)\n\n\n    return ub\n\n\ndef main():\n\n    # Get the directory of the current script\n    script_dir = os.path.dirname(__file__)\n\n\n    # Get the path of the currently open Rhino file\n    rhino_file_path = rs.DocumentPath()\n  \n    # Construct the path to the data.json file\n    json_file_path = os.path.join(rhino_file_path, 'data.json')\n\n    # Load the data from the JSON file\n    with open(json_file_path, 'r') as file:\n        data = json.load(file)\n\n    data[\"script_dir\"] = script_dir\n    data[\"rhino_file_path\"] = rhino_file_path\n\n    #call main function\n    #main(data)\n\n    # Get the current date and time from the URL\n    now = urlopen('http://just-the-time.appspot.com/')\n    now_str = now.read().strip().decode('utf-8')\n    try:\n    # Try setting to 'en_US' for UNIX/Linux systems or 'English_United States' for Windows.\n        locale.setlocale(locale.LC_ALL, 'en_US')  # Try 'en_US.UTF-8' if 'en_US' doesn't work\n    except locale.Error:\n        print(\"Locale 'en-US' could not be set.\")\n\n    exp_date = datetime( year = 2024, month = 8 , day = 31   )\n\n    now_datetime = datetime.strptime(now_str, '%Y-%m-%d %H:%M:%S')\n\n    # Compare the two dates\n    if exp_date > now_datetime:\n        #print(\"You can still use the script\")\n    \n    \n        ## read rhino file\n        data = read_data_from_rhino(data)\n\n        ## call C++ function to generate mesh and construct problem\n        data = generate_mesh_and_construct_matrices(data)\n\n        ## solve different approaches and generate paraview file\n\n        ub = solve_problem_with_solvers(data)\n\n        #\n        #block_disp_plot(data[\"blocks_centroid\"],data[\"blocks\"],data[\"faces\"],data[\"points\"],ub)\n\n\n\n#call main function\nmain()\n\n\n\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "brep", "line", "curve", "functions", "block", "mesh"], "original_file": "Moussa-mohamad_these_work_78a6c04d51.json", "repo": "Moussa-mohamad/these_work"}
{"instruction": "Implement the function 'memoized_grasshopper_analysis' for Rhino scripting", "code": "import json\nimport rhino3dm\nfrom pathlib import Path\n\nfrom viktor import ViktorController, File\nfrom viktor.views import DataGroup, DataItem, GeoJSONAndDataResult, GeometryResult, TableResult, TableView, GeoJSONAndDataView, GeometryView, MapLabel\nfrom viktor.external.grasshopper import GrasshopperAnalysis\nfrom viktor.utils import memoize\n\nfrom gis_functions import get_gdf, create_legend, find_climate_zone\nfrom json_utils import parse_data_string, get_inner_tree_by_param_name\nfrom parametrization import Parametrization\n\n@memoize\ndef memoized_grasshopper_analysis(json_input):\n        #Funktion die die Grasshopper simulation ausfhrt\n        #wird im Arbeitsspeicher zwischengespeichert       \n        #Ergebnis kann deswegen mehrfach wieder aufgerufen werden\n\n        formatted_params = json.loads(json_input)\n\n\n        #Festlegen wo das gh Skript liegt und bergeben der Hops-Parameter an das Skript\n        grasshopper_script_path = Path(__file__).parent / \"files/Tinyhouse Generator.gh\"\n        script = File.from_path(grasshopper_script_path)\n\n        analysis = GrasshopperAnalysis(script=script, input_parameters=formatted_params)\n        #Analyse wird durchgefhrt, sollte sie lger als 240 Sekunden dauern, wird sie angebrochen\n        analysis.execute(timeout=240)\n\n        return analysis.get_output()\n\nclass Controller(ViktorController):\n    label = 'My Entity Type'\n    parametrization = Parametrization(width=20)\n\n    #######################################################\n    # Views fr Step 1 Beinhalten GIS und deren Funktionen#\n    #######################################################\n\n    @GeoJSONAndDataView(\"Kartenansicht - Standortauswahl\", duration_guess=1)\n    def get_geojson_view(self, params, **kwargs) -> GeoJSONAndDataResult:\n\n        #Kartenansicht mit GroJSON Overlay\n\n        gdf = get_gdf(params.step_1.styling)\n        geojson = json.loads(gdf.to_json())\n        gdf_labels = gdf.copy()\n        gdf_labels[\"label_geometry\"] = gdf_labels.representative_point()\n        labels = [MapLabel(gdf_labels.label_geometry[0].x, gdf_labels.label_geometry[0].x, \" \", 20)]\n\n        #Festlegen der Position des Pins und das Styling des\n\n        if 'GeoPointField' in params.step_1.point:\n            latitude = params.step_1.point.GeoPointField.lat\n            longitude = params.step_1.point.GeoPointField.lon\n            point_geojson = {\n                \"type\": \"Feature\",\n                \"geometry\": {\n                    \"type\": \"Point\",\n                    \"coordinates\": [longitude, latitude]\n                },\n                \"properties\": {\n                    \"marker-symbol\": \"pin\",\n                    \"marker-color\": \"#ff0000\"\n                }\n            }\n        else:\n            print(\"Kein valider Punkt angegeben\")\n\n        #Runden des Lngen und Breitengrades in bliches Format\n        #zur spteren Anzeige in der Webapp\n\n        longitude = round(params.step_1.point.GeoPointField.lon, 3)\n        latitude = round(params.step_1.point.GeoPointField.lat, 2)\n\n        selected_zone = find_climate_zone(gdf, latitude, longitude)\n\n        #Wurde eine Korrekte Klimazone ausgewhlt?\n        if selected_zone:\n            climate_zone = f\"Klimazone am Punkt ({latitude}, {longitude}): {selected_zone}\"\n        else:\n            climate_zone = f\"Keine Klimazone am Punkt ({latitude}, {longitude}) gefunden\"\n\n        #Hinzufgen der Information zum View\n        geojson['features'].append(point_geojson)\n        data_items = DataItem(\"\", climate_zone)\n        attribute_results = DataGroup(data_items)\n        legend = create_legend()\n\n        #Abrufen der Legende samt Farben\n        if params.step_1.styling.showlegend:\n            return GeoJSONAndDataResult(geojson, attribute_results, labels, legend)\n        else:\n            return GeoJSONAndDataResult(geojson, attribute_results, labels)\n\n    ################################################\n    # Views fr Step 2 Beinhaltet Gebude Geometrie#\n    ################################################\n\n\n\n    @GeometryView(\"3D Modell Ansicht\", duration_guess=10, x_axis_to_right=True, update_label='Simulation starten')\n    def run_grasshopper(self, params, **kwargs):\n        \n        #Geometrieanzeige\n        #Zunchst initialisierung der Parameter\n        gdf = get_gdf(params.step_1.styling)\n        latitude = params.step_1.point.GeoPointField.lat\n        longitude = params.step_1.point.GeoPointField.lon\n        raumhoehe = params.step_2.geometrie.Raumhhe\n        azimutRichtungEingang = params.step_2.geometrie.AzimutRichtungEingang\n        klimazone = find_climate_zone(gdf, latitude, longitude)\n\n        formatted_params = dict(\n            Raumhhe=raumhoehe,\n            Lngengrad=longitude,\n            Breitangrad=latitude,\n            Klimazone=klimazone,\n            AzimutRichtungEingang=azimutRichtungEingang\n        )\n\n        #Parameter in ein JSON String damit Hops sie lesen kann\n        json_input = json.dumps(formatted_params)\n\n        #memoized Function aufrufen fr GH Skript, fragt immer vorher ab ob sich Parameter verndert haben\n        output = memoized_grasshopper_analysis(json_input)\n\n        file3dm = rhino3dm.File3dm()\n        geometry_inner_tree = get_inner_tree_by_param_name(output, \"Geometry\")\n\n        #Hinzufgen der Geometrien zum Viewmodel\n        def add_objects_to_model(inner_tree):\n            if not inner_tree:\n                print(\"Kein InnerTree gefunden.\")\n                return\n            for key in inner_tree:\n                for data_item in inner_tree[key]:\n                    obj = rhino3dm.CommonObject.Decode(json.loads(data_item[\"data\"]))\n                    file3dm.Objects.Add(obj)\n\n        add_objects_to_model(geometry_inner_tree)\n\n        geometry_file = File()\n        file3dm.Write(geometry_file.source, version=7)\n\n        return GeometryResult(geometry=geometry_file, geometry_type=\"3dm\")\n\n    @GeometryView(\"Grundriss und Schnitte\", duration_guess=10, x_axis_to_right=True, update_label='Lade aktuellen Grundriss', view_mode=\"2D\")\n    def view_floorplan(self, params, **kwargs):\n\n        #2D View fr Grundriss und Schnitte\n        #Zunchst initialisierung der Parameter\n        gdf = get_gdf(params.step_1.styling)\n        latitude = params.step_1.point.GeoPointField.lat\n        longitude = params.step_1.point.GeoPointField.lon\n        raumhoehe = params.step_2.geometrie.Raumhhe\n        azimutRichtungEingang = params.step_2.geometrie.AzimutRichtungEingang\n        klimazone = find_climate_zone(gdf, latitude, longitude)\n\n        formatted_params = dict(\n            Raumhhe=raumhoehe,\n            Lngengrad=longitude,\n            Breitangrad=latitude,\n            Klimazone=klimazone,\n            AzimutRichtungEingang=azimutRichtungEingang\n        )\n\n        #Parameter in ein JSON String damit Hops sie lesen kann\n        json_input = json.dumps(formatted_params)\n\n        #memoized Function aufrufen fr GH Skript, fragt immer vorher ab ob sich Parameter verndert haben\n        output = memoized_grasshopper_analysis(json_input)\n\n        file3dm = rhino3dm.File3dm()\n        floorplan_inner_tree = output[\"values\"][2][\"InnerTree\"]\n\n        #Hinzufgen der Geometrien zum Viewmodel\n        def add_objects_to_model(inner_tree):\n            for key in inner_tree:\n                for data_item in inner_tree[key]:\n                    obj = rhino3dm.CommonObject.Decode(json.loads(data_item[\"data\"]))\n                    file3dm.Objects.Add(obj)\n\n        add_objects_to_model(floorplan_inner_tree)\n\n        geometry_file = File()\n        file3dm.Write(geometry_file.source, version=7)\n        return GeometryResult(geometry=geometry_file, geometry_type=\"3dm\")\n\n    ################################################\n    # Views fr Step 3 Beinhaltet Datenverarbeitung#\n    ################################################\n\n    @TableView(\"Informationen zur Parametrisierung\", duration_guess=1)\n    def run_data_analysis(self, params, **kwargs):\n\n        #Tabelle fr Datenansicht\n        #Zunchst initialisierung der Parameter\n        gdf = get_gdf(params.step_1.styling)\n        latitude = params.step_1.point.GeoPointField.lat\n        longitude = params.step_1.point.GeoPointField.lon\n        raumhoehe = params.step_2.geometrie.Raumhhe\n        azimutRichtungEingang = params.step_2.geometrie.AzimutRichtungEingang\n        klimazone = find_climate_zone(gdf, latitude, longitude)\n\n        formatted_params = dict(\n            Raumhhe=raumhoehe,\n            Lngengrad=longitude,\n            Breitangrad=latitude,\n            Klimazone=klimazone,\n            AzimutRichtungEingang=azimutRichtungEingang\n        )\n\n        #Parameter in ein JSON String damit Hops sie lesen kann\n        json_input = json.dumps(formatted_params)\n\n        #memoized Function aufrufen fr GH Skript, fragt immer vorher ab ob sich Parameter verndert haben\n        output = memoized_grasshopper_analysis(json_input)\n        text_inner_tree = get_inner_tree_by_param_name(output, \"Tx\")\n\n        #Hinzufgen der Infos zur richtigen Tabelle\n        if text_inner_tree and '{0}' in text_inner_tree:\n            #String aus dem Textdata bilden\n            text_data = text_inner_tree['{0}'][0]['data']\n            formatted_text = text_data.replace(\"\\\\r\\\\n\", \"\\n\").splitlines()\n\n            #\"Parameter_data\" aus dem String herauslesen (erste Ausgabe)\n            parameter_data, _ = parse_data_string(formatted_text)\n\n            #Tablle Vorbereiten und hinzufgen der Daten\n            table_data = []\n            row_headers = []\n            for key, value_dict in parameter_data.items():\n                row_headers.append(key)\n                table_data.append([value_dict[\"value\"], value_dict[\"begrndung\"]])\n\n            return TableResult(table_data, column_headers=[\"Wert\", \"Begrndung\"], row_headers=row_headers)\n        else:\n            print(\"Keine Daten gefunden\")\n            return TableResult([], column_headers=[\"Wert\", \"Begrndung\"], row_headers=[])\n\n    @TableView(\"Wetterdaten\", duration_guess=1)\n    def run_weather_data(self, params, **kwargs):\n\n        #Tabelle fr Wetterdaten\n        #Zunchst initialisierung der Parameter\n        gdf = get_gdf(params.step_1.styling)\n        latitude = params.step_1.point.GeoPointField.lat\n        longitude = params.step_1.point.GeoPointField.lon\n        raumhoehe = params.step_2.geometrie.Raumhhe\n        azimutRichtungEingang = params.step_2.geometrie.AzimutRichtungEingang\n        klimazone = find_climate_zone(gdf, latitude, longitude)\n\n        formatted_params = dict(\n            Raumhhe=raumhoehe,\n            Lngengrad=longitude,\n            Breitangrad=latitude,\n            Klimazone=klimazone,\n            AzimutRichtungEingang=azimutRichtungEingang\n        )\n\n        #Parameter in ein JSON String damit Hops sie lesen kann\n        json_input = json.dumps(formatted_params)\n\n        #memoized Function aufrufen fr GH Skript, fragt immer vorher ab ob sich Parameter verndert haben\n        output = memoized_grasshopper_analysis(json_input)\n        text_inner_tree = get_inner_tree_by_param_name(output, \"Tx\")\n\n        #Hinzufgen der Infos zur richtigen Tabelle\n        if text_inner_tree and '{0}' in text_inner_tree:\n            #String aus dem Textdata bilden\n            text_data = text_inner_tree['{0}'][0]['data']\n            formatted_text = text_data.replace(\"\\\\r\\\\n\", \"\\n\").splitlines()\n\n            #\"wetterdaten\" aus dem String herauslesen (zweite Ausgabe)\n            _, wetterdaten = parse_data_string(formatted_text)\n\n            #Tablle Vorbereiten und hinzufgen der Daten\n            table_data = []\n            row_headers = []\n            for monat, daten in wetterdaten.items():\n                row_headers.append(monat)\n                table_data.append([\n                    daten.get(\"Schneefall [mm]\", 0),\n                    daten.get(\"Niederschlag [mm]\", 0)\n                ])\n\n            return TableResult(table_data, column_headers=[\"Schneefall [mm]\", \"Niederschlag [mm]\"], row_headers=row_headers)\n        else:\n            print(\"Keine Daten gefunden\")\n            return TableResult([], column_headers=[\"Schneefall [mm]\", \"Niederschlag [mm]\"], row_headers=[])", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["line", "classes", "functions", "point"], "original_file": "Mulimark_Tinyhouse-Generator_3f41e54689.json", "repo": "Mulimark/Tinyhouse-Generator"}
{"instruction": "Implement the function 'run_accs' for Rhino scripting", "code": "from termcolor import cprint\nfrom modules.bridge_off_most import of_most_main\nfrom modules.dmail_main import dmail_main\nfrom config import RANDOM_SWAP, PAUSA_MIN, PAUSA_MAX\nfrom sys import stderr\nfrom modules.swap_main import pool_main, colateral_main, swap_main, mint_main\nimport config\nfrom random import shuffle\nfrom modules.utils import WindowName, sleeping, logger, sleep\nfrom modules.browser import Browser\nfrom modules.wallet import Wallet\nfrom modules.bridge_rhinofi import Rhino\n\n\n\n\nlogger.remove()\nlogger.add(stderr, format=\"<white>{time:HH:mm:ss}</white> | <level>{level: <3}</level> | <level>{message}</level>\")\n\n\ndef run_accs(p_keys: list):\n    for private_key in p_keys:\n        try:\n            browser = Browser()\n            windowname.update_accs()\n            wallet = Wallet(privatekey=private_key, browser=browser)\n            logger.info(f'[{windowname.accs_done}/{windowname.accs_amount}] {wallet.address}')\n\n            Rhino(wallet=wallet)\n\n\n        except Exception as err:\n            wallet.error = ' ' + str(err)\n            logger.error(f'[-] Account #{windowname.accs_done} error: {err}')\n\n        finally:\n            sleeping(PAUSA_MIN, PAUSA_MAX) #   \n\n\nif __name__ == '__main__':\n    while True:\n        print(' : ')\n        print('1.   ()')\n        print('2. ')\n        print('3. Dmail')\n        print('4.  Layerbank')\n        print('5.  (Collateral)')\n        print('6. Wrap/Unwrap ETH')\n        print('7.  ')\n        print('8. Mint NFT   ')\n        print('9. Bridge RhinoFi')\n\n        cprint('0.  ', 'red')\n        nomer = int(input(' : '))\n\n        if nomer == 1:\n            procent_min = int(input('min % ETH  : '))\n            procent_max = int(input('max % ETH  : '))\n\n            parametrs = {\n                'procent_min': procent_min,\n                'procent_max': procent_max,\n                'current_account': 0,\n                'max_acconts': 0,\n\n            }\n\n            of_most_main(2, parametrs)\n\n        elif nomer == 2:\n\n            count_min = int(input('min - : '))\n            count_max = int(input('max - : '))\n            nomer_puti = 0\n\n            if not RANDOM_SWAP:\n                print(' : ')\n                print('1.  USDC')\n                print('2.  ETH')\n                nomer_puti = int(input(' : '))\n\n                procent_min = int(input('min %   : '))\n                procent_max = int(input('max %   : '))\n\n            parametrs = {\n                'procent_min': procent_min if nomer_puti!= 0 else 0,\n                'procent_max': procent_max if nomer_puti!= 0 else 0,\n                'count_min': count_min,\n                'count_max': count_max,\n            }\n\n            swap_main(nomer_puti, parametrs)\n\n        elif nomer == 3:\n\n            count_min = int(input('min - : '))\n            count_max = int(input('max - : '))\n\n            parametrs = {\n                'count_min': count_min,\n                'count_max': count_max,\n            }\n\n            dmail_main(parametrs)\n\n        elif nomer == 4:\n            marshrut = int(input('1. \\n2.  \\n'))\n\n            procent_min = int(input('min % ETH  : '))\n            procent_max = int(input('max % ETH  : '))\n\n            parametrs = {\n                'marshrut': marshrut,\n                'procent_min': procent_min,\n                'procent_max': procent_max,\n                'deploy': 0,\n            }\n\n            pool_main(parametrs)\n\n        elif nomer == 5:\n\n            count_min = int(input('min -: '))\n            count_max = int(input('max -: '))\n\n            parametrs = {\n                'count_min': count_min,\n                'count_max': count_max,\n            }\n\n            colateral_main(parametrs)\n\n        elif nomer == 6:\n            wrap_check = int(input('Wrap = 1, Unwrap = 2,   = 3 '))\n            procent_min = int(input('min % ETH  wrap/unwrap: '))\n            procent_max = int(input('max % ETH  wrap/unwrap: '))\n\n            if wrap_check == 3:\n                count_min = int(input('min -: '))\n                count_max = int(input('max -: '))\n\n            parametrs = {\n                'procent_min': procent_min,\n                'procent_max': procent_max,\n                'current_account': 0,\n                'max_acconts': 0,\n                'wrap_check': wrap_check,\n                'count_min': count_min if wrap_check == 3 else 0,\n                'count_max': count_max if wrap_check == 3 else 0,\n            }\n\n            if parametrs['wrap_check'] == 3:\n                swap_main(0, parametrs)\n            else:\n                of_most_main(1, parametrs)\n\n        elif nomer == 7:\n\n            parametrs = {\n                'current_account': 0,\n                'max_acconts': 0,\n                'deploy': 1\n            }\n\n            pool_main(parametrs)\n        elif nomer == 8:\n\n            parametrs = {\n                'current_account': 0,\n                'max_acconts': 0\n            }\n\n            mint_main(parametrs)\n\n        elif nomer == 9:\n\n            with open('keys.txt') as f:\n                p_keys = f.read().splitlines()\n\n            windowname = WindowName(len(p_keys))\n            if config.SHUFFLE_WALLET: shuffle(p_keys)\n\n            try:\n                run_accs(p_keys=p_keys)\n\n            except Exception as err:\n                logger.error(f'Global error: {err}')\n\n            logger.success(f'All accs done.\\n\\n')\n            sleep(0.1)\n\n        else:\n            break\n\n    print(\"  !!!\")\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["layer", "line", "functions"], "original_file": "NP66666_SOFTS_3872c5ac04.json", "repo": "NP66666/SOFTS"}
{"instruction": "Write a Rhino script that uses rs.AddLayer", "code": "# -*- coding:utf-8 -*-\nfrom Generate import Generate\nimport rhinoscriptsyntax as rs\nimport time\n# import copy\n# import random as rnd\nimport sys\nfrom forMain import Sort\nfrom forMain import timberMethod\nfrom forMain import Instance\nfrom forMain import MoveObject\nimport Rhino.Geometry\nimport scriptcontext\nfrom forMain import drawInformatinon\n# from matplotlib import pyplot\nimport GA.Selection\nimport GA.Evaluation\nimport GA.Crossover\nimport GA.Method\nimport ReGenerate\n\n\nnum_timber = 30         # timber\nnum_base_timber = 10\ncantilever_num = 10     # cantilever\nbridge_num = 10\n\ndivide_range = 5        # \npop_num = 30            # ttm add 181003\nelite_num = 2           # \ngeneration_num = 30     # \ntournament_size = 5     # \ntournament_num = 3      # \nmutation_ratio = 3      # \ninitial_population_draw = False\nflag_high = True        # TrueFalse\n\nconnect_count = 10      # \nname_list = []          # timber\nprototype_ID = 0        # \npop_size = pop_num      # \ngenerate_range = 3000   #  TODO \nbetween_draw_rhino = generation_num  # generation_num\n\n\nevaluate_list = []        # \n# temp_center_line = []   # \n# temp_surface = []       # \n# temp_mark = []\ntimber_num = []           # Timber\nnew_gene_num_list = []\n\n# \nlimit_degree = [45, 135]  # \n\n\n# boolean\ninput_flag = False        # \nredraw_flag = False       # False\ninformation_flag = False\nlayer_flag = False\n\n\nrs.AddLayer('all_pop_layer')\nrs.CurrentLayer('all_pop_layer')\n\n# Step0: rhino\nget_center_line = rs.GetObjects(\"select %s lines\" % num_timber, rs.filter.curve)\nget_surface = rs.GetObjects(\"Select %s Surfaces\" % num_timber, rs.filter.surface)\nget_obj = Sort.scanObjectSort(num_timber, get_center_line, get_surface)\n\nprogram_start = time.time()\n\n# \ncenter_line = get_obj[0]\nall_surface = get_obj[1]\n# all_mark = get_obj[2]\n\nfor i in range(0, num_timber):\n    name_list.append(i)\n\n\n# Step1: *Timber\ntemp_center_line = Instance.axis_instance(pop_num, center_line)\ntemp_surface = Instance.surface_instance(pop_num, all_surface)\n# temp_mark = inst.mark_instance(pop_num, all_mark)\n\n# print(\"temp_surface\", temp_surface)\n# print(\"temp_center_line\", temp_center_line)\n\n\n# Step2: Generate\ndic = {}\nfor foo in range(pop_num):\n    dic['generate' + str(foo)] = foo\n\nfor i in range(pop_num):\n    timber_num.append(i)\n\n# \nfor i in range(pop_num):\n    dic['generate' + str(i)] = Generate(temp_center_line[i], temp_surface[i], name_list, num_timber, prototype_ID,\n                                        timber_num[i])\n\n\n# Step3: GenerateTimber\nfor j in range(pop_num):\n    dic['generate' + str(j)].instantiate_timber()  # TimberGenerate\n    dic['generate' + str(j)].pop_index = j  # \n    # print(\"pop_index\", dic['generate' + str(j)].pop_index)\n\n\nclosed_curve = rs.GetObjects(\"select closed curves, base timber generated\")\nobjects_curve = []\nif closed_curve:\n    for i in range(len(closed_curve)):\n        curve = rs.coercecurve(closed_curve[i])\n        objects_curve.append(curve)\nelse:\n    raise Exception('select closed curve is Error')\n\n\n# Step4 \nt1 = time.time()\nrs.EnableRedraw(False)\nfor i in range(pop_num):\n\n    for j in range(num_base_timber):\n        flag_gl = dic['generate' + str(i)].generate_ground_init(generate_range, objects_curve=objects_curve)\n        if flag_gl:\n            pass\n        else:\n            raise Exception('init_base_generation is fail')\n\n    for j in range(num_base_timber):\n        tim = dic['generate' + str(i)].used_list[j]\n\n        copy_from = Rhino.Geometry.Point3d(0, 0, 0)\n        copy_to = Rhino.Geometry.Point3d((generate_range * 2) * i, - generate_range * 2, 0)\n        vec_move = copy_to - copy_from\n\n        MoveObject.MoveTimberObjects(vec_move, tim)\n\n    for j in range(cantilever_num):\n        flag_canti = dic['generate' + str(i)].cantilever(limit_degree)\n        if flag_canti:\n            pass\n        else:\n            raise Exception('cantilever is fail')\n\n    for j in range(bridge_num):\n        flag_bridge = dic['generate' + str(i)].bridge(limit_degree)\n        if flag_bridge:\n            pass\n        else:\n            raise Exception('bridge is fail')\n    \n    # # flag_success = False\n    # flag_success = dic['generate' + str(i)].cantilever(limit_degree)  # Initial Generate Method.\n    # # if not flag_success:\n    # #     input(\"initial cantilever not success\")\n    #\n    # tim1 = dic['generate' + str(i)].used_list[0]\n    # tim2 = dic['generate' + str(i)].used_list[1]\n    #\n    # copy_from = Rhino.Geometry.Point3d(0, 0, 0)\n    # copy_to = Rhino.Geometry.Point3d((generate_range * 2) * i, - generate_range * 2, 0)\n    # vec_move = copy_to - copy_from\n    #\n    # MoveObject.MoveTimberObjects(vec_move, tim1, tim2)  # Moving Objects method for tim1,tim2\n    #\n    # if cantilever_num > num_timber - 2:  # if cantilever_num is not good, stop python script\n    #     sys.exit(\"cantilever_num is not suitable for num_timber\")\n    #\n    # cantilever_start = time.time()  # Initial Cantilever generate part\n    # for j in range(cantilever_num - 2):\n    #     # flag_success = False\n    #     flag_success = dic['generate' + str(i)].cantilever(limit_degree)\n    #     # if not flag_success:\n    #     #     input(\"line 128 cantilever not success\")\n    # cantilever_end = time.time()\n    # # print(\"Initial Cantilever Method end time: %s this is num %s population\" %(cantilever_end - cantilever_start, i))\n    #\n    # bridge_start = time.time()  # Initial Bridge generate part\n    # for j in range(num_timber - cantilever_num):\n    #     # flag_success = False\n    #     flag_success = dic['generate' + str(i)].bridge(limit_degree)\n    #     # if not flag_success:\n    #     #     input(\"line 137 bridge not success\")\n    # bridge_end = time.time()\n    # # print(\"Initial Bridge Method end time: %s this is num %s population\" %(bridge_end - bridge_start, i))\n\n\n# \nfor i in range(pop_num):\n    pop = dic['generate' + str(i)]\n    flag_divide = GA.Method.confirm_pop_divide(num_timber, pop)\n    print(\"flag_divide : %s  Time: %s\" % flag_divide)\n\n\n# Rhino\nif initial_population_draw:\n    for i in range(pop_num):\n        for j in range(num_timber):\n            if layer_flag:\n                a = 'tim'\n                b = str(dic['generate' + str(i)].used_list[j].name)\n                rs.CurrentLayer(a+b)\n\n            sf = scriptcontext.doc.Objects.AddBrep(dic['generate' + str(i)].used_list[j].surface)\n            crv = scriptcontext.doc.Objects.AddCurve(dic['generate' + str(i)].used_list[j].center_line)\n\nt2 = time.time()\ninit_generation_time = t2 - t1  # time of Initial Generate\nprint(\"\\n\")\nprint(\"init generation time: %s\" % init_generation_time)\n\n\n# Step5: Generategene_infoappend\nall_gene_info = []\nfor i in range(pop_num):\n    gene_info = []\n    for j in range(num_timber):\n        gene_info.append(dic['generate' + str(i)].used_list[j].name)\n    all_gene_info.append(gene_info)\n\nif information_flag:\n    print(\"\\n\")\n    print(\"All gene info\", all_gene_info)\n\nfor i in range(pop_num):\n    for j in range(num_timber):\n        dic['generate' + str(i)].gene_info.append(dic['generate' + str(i)].used_list[j].name)\n\n\n# Main Loop \nfor main_loop in range(generation_num):\n\n    # Step6:  # EVALUATION\n    evaluation_value = []  # \n    t3 = time.time()\n    for i in range(pop_num):\n        instance_pop = dic['generate' + str(i)]\n\n        # \n        # evaluate_value = GA.Evaluation.overlap_num2(num_timber, instance_pop)\n        # evaluate_value = GA.Evaluation.partner_num_evaluate(num_timber, instance_pop, 2, 10)\n        # evaluate_value = GA.Evaluation.pop_height_evaluate(num_timber, instance_pop)\n        evaluate_value = GA.Evaluation.pop_evaluation(num_timber, instance_pop)\n\n        dic['generate' + str(i)].evaluation = evaluate_value\n        evaluation_value.append(dic['generate' + str(i)].evaluation)\n\n    evaluate_list.append(evaluation_value)  # \n\n    t4 = time.time()\n    print(\"\\n\")\n    print(\"Result of EVALUATION --- Generation : %s  Result : %s\" % (main_loop, evaluation_value))\n    print(\"Evaluation Time: %s\" % (t4 - t3))\n\n    # Step7:  # SELECTION  \n    selected_list = []\n    sort_generate_instance_list = []  # Genarate\n    for i in range(pop_num):\n        sort_generate_instance_list.append(dic['generate' + str(i)])\n\n    # \n    if flag_high:\n        GA.Selection.sort_high(sort_generate_instance_list)\n    else:\n        GA.Selection.sort_low(sort_generate_instance_list)\n\n    # elite selection\n    GA.Selection.eliteSelection(elite_num, sort_generate_instance_list, selected_list)\n\n    # tournament selection\n    GA.Selection.tournamentSelection_min(tournament_size, tournament_num, sort_generate_instance_list, selected_list)\n\n    # Step8: \n    # \n    temp_list_center_for_next_generation = [[[] for i in range(num_timber)] for j in range(pop_num)]\n    temp_list_srf_for_next_generation = [[[] for i in range(num_timber)] for j in range(pop_num)]\n    temp_list_select_domain_list_for_next_generation = [[[] for i in range(num_timber)] for j in range(pop_num)]\n    list_temp_partner_tim = [[[] for i in range(num_timber)] for j in range(pop_num)]  # partner_tim\n    list_temp_gene_tim = []  # \n\n    # partner_tim\n    list_partner_tim_prior_generation = [[[] for i in range(num_timber)] for j in range(pop_num)]  # partner_tim\n    for i in range(pop_num):\n        for j in range(num_timber):\n            for k in range(num_timber):\n                if dic['generate' + str(i)].used_list[k].name == j:\n                    list_partner_tim_prior_generation[i][j].extend(dic['generate' + str(i)].used_list[j].partner_tim)\n                    break\n    print(\"list_partner_tim_prior_generation\", list_partner_tim_prior_generation)\n\n    for loop in range(pop_size):\n        if information_flag:\n            print(\"\\n\")\n            print(\"start regeneration No.%s\" % loop)\n            print(\"------------------------------------------------------------\")\n\n        # decide the 2 crossover point\n        divide_point1, divide_point2 = GA.Crossover.selectDividePoints(num_timber, divide_range)\n\n        # Get the index in the 'selected_list' of the individual used for crossover\n        pop_1, pop_2 = GA.Crossover.select2Poplation(selected_list)\n\n        # 2Generatelist_temp_gene_timappend return\n        already_regenerate = GA.Crossover.TwoPointCrossover(num_timber, pop_1, pop_2, divide_point1, divide_point2,\n                                                            list_temp_gene_tim)\n\n        # pop_2 addTODO\n        decide_inheritance_num_list, connect_list = GA.Method.decide_inheritance_timber(pop_1, pop_2, already_regenerate,\n                                                                                      generate_range)\n        # print('\\n')\n        # print('connect_list', connect_list)\n\n        # print(\"decide_inheritance_num_list %s\"%(decide_inheritance_num_list))\n\n        # pop_1\n        list_srf_temp = []\n        list_center_line_temp = []\n        list_select_domain_temp = []\n        GA.Method.saveInstanceInformation(num_timber, pop_1, list_srf_temp, list_center_line_temp,\n                                          list_select_domain_temp)\n\n        # pop_2Timberselect_domain_listDomain  add 190218\n        GA.Method.RenewalPop2(pop_1, pop_2, decide_inheritance_num_list)\n\n        # select_domain_list\n        GA.Method.selectDomainRenewal(already_regenerate, num_timber, pop_1)\n\n        # select_domain_list2.\n        GA.Method.selectDomainRenewal2(decide_inheritance_num_list, num_timber, pop_1)\n\n        # print('inheritance form 1', already_regenerate)\n        # print('inheritance form 2', decide_inheritance_num_list)\n\n        # MoveObjectpartner\n        GA.Method.move_and_pop_update_for_already(already_regenerate, pop_1, generate_range, generation_num, between_draw_rhino,\n                                       main_loop, loop, list_temp_partner_tim)\n\n        # MoveObjectpartneradd 190220\n        GA.Method.move_and_pop_update_for_inheritance(decide_inheritance_num_list, pop_1, pop_2, generate_range, generation_num,\n                                        between_draw_rhino, main_loop, loop, list_temp_partner_tim)\n\n        # TODO \n\n        # pop_2\n        for i in range(len(connect_list)):\n            index = decide_inheritance_num_list.index(connect_list[i][0])\n            del decide_inheritance_num_list[index]\n            already_regenerate.append(connect_list[i][0])\n        # print('check del inheritance form', decide_inheritance_num_list)\n\n        already_regenerate.extend(decide_inheritance_num_list)  # add 190220\n        # print('check already_regenerate', already_regenerate)\n        # print(\"already_regenerate_list : %s\"%(already_regenerate))\n        for i in range(len(connect_list)):\n            decide_inheritance_num_list.append(connect_list[i][0])\n\n        yet_regenerate = []\n        yet_regenerate.extend(pop_1.temp_yet_regenerate)\n\n        # print(\"before yet_regenerate_list : %s\"%(yet_regenerate))  # add 190220\n        for ex in range(len(decide_inheritance_num_list)):\n            index_ex = yet_regenerate.index(decide_inheritance_num_list[ex])\n            yet_regenerate.pop(index_ex)\n        # print(\"after yet_regenerate_list : %s\" % (yet_regenerate))\n\n        # partner_timcheck_timber_partner3\n        # check_timber_partner1 = []\n        # for i in range(num_timber):\n        #     for j in range(num_timber):\n        #         if pop_1.used_list[j].name == i:\n        #             check_timber_partner1.append(pop_1.used_list[j].partner_tim)\n        #             break\n\n        # print(\"check_timber_partner1\", check_timber_partner1)\n\n        # pop1partner_list\n        for i in range(num_timber):\n            for j in range(num_timber):\n                if pop_1.used_list[j].name == i:\n                    pop_1.used_list[j].partner_tim = []\n                    pop_1.used_list[j].partner_tim.extend(list_temp_partner_tim[loop][i])\n                    break\n\n        # partner_tim\n        # check_timber_partner2 = []\n        # for i in range(num_timber):\n        #     for j in range(num_timber):\n        #         if pop_1.used_list[j].name == i:\n        #             check_timber_partner2.append(pop_1.used_list[j].partner_tim)\n        #             break\n        # print(\"check temp timber partner : %s\" % (check_timber_partner2))\n        # print(\"list_temp_partner_tim\", list_temp_partner_tim)\n\n        # \n        ReGenerate.regenerate(already_regenerate, yet_regenerate, pop_1, pop_2, num_timber, limit_degree,\n                              generation_num, main_loop, loop, between_draw_rhino, list_temp_partner_tim,\n                              mutation_ratio)\n\n        # \n        t1_flag_divede = time.time()\n        flag_divide = GA.Method.confirm_pop_divide(num_timber, pop_1)\n        t2_flag_divide = time.time()\n        print(\"flag_divide : %s  Time: %s\" % (flag_divide, t2_flag_divide-t1_flag_divede))\n\n        # partner_tim\n        check_timber_partner3 = []\n        for i in range(num_timber):\n            for j in range(num_timber):\n                if pop_1.used_list[j].name == i:\n                    check_timber_partner3.append(pop_1.used_list[j].partner_tim)\n                    break\n\n        if check_timber_partner3 == list_temp_partner_tim[loop]:\n            pass\n        else:\n            raise ValueError('check_timber_partner3 & list_temp_partner_tim is not same, did not working')\n\n        # pop_1partner_tim\n        for i in range(num_timber):\n            for j in range(num_timber):\n                if pop_1.used_list[j].name == i:\n                    pop_1.used_list[j].partner_tim = []\n                    pop_1.used_list[j].partner_tim.extend(list_partner_tim_prior_generation[pop_1.population_num][i])\n                    break\n\n        # partner_tim check_timber_partner1\n        # check_timber_partner4 = []\n        # for i in range(num_timber):\n        #     for j in range(num_timber):\n        #         if pop_1.used_list[j].name == i:\n        #             check_timber_partner4.append(pop_1.used_list[j].partner_tim)\n        #             break\n        #\n        # print(\"check_timber_partner4\", check_timber_partner4)\n\n        # if check_timber_partner1 == check_timber_partner4:\n        #     pass\n        # else:\n        #     raise ValueError('check_timber_partner1 & check_timber_partner4 is not same')\n\n        # Generate\n        # Generate\n        GA.Method.RenewalInstanceInformationSameGeneration(pop_1, temp_list_srf_for_next_generation,\n                                                           temp_list_center_for_next_generation,\n                                                           temp_list_select_domain_list_for_next_generation,\n                                                           list_srf_temp, list_center_line_temp,\n                                                           list_select_domain_temp, loop)\n\n        rs.EnableRedraw(True)\n        rs.Redraw()\n        rs.EnableRedraw(False)\n\n        # print(\"list_temp_partner_tim\", list_temp_partner_tim)\n        # input(\"stop\")\n\n    # Generate\n    # srf, center_line\n    for i in range(pop_num):\n        for j in range(num_timber):\n            name_tim = dic['generate' + str(i)].used_list[j].name\n            # print(\"name_tim\", name_tim)\n            dic['generate' + str(i)].used_list[j].center_line = None  # list\n            dic['generate' + str(i)].used_list[j].center_line = temp_list_center_for_next_generation[i][name_tim]\n\n            dic['generate' + str(i)].used_list[j].surface = None\n            dic['generate' + str(i)].used_list[j].surface = temp_list_srf_for_next_generation[i][name_tim]\n\n    #  partner_tim\n    for i in range(pop_num):\n        for j in range(num_timber):\n            for k in range(num_timber):  # TODO\n                if dic['generate' + str(i)].used_list[k].name == j:\n                    dic['generate' + str(i)].used_list[k].partner_tim = []\n                    dic['generate' + str(i)].used_list[k].partner_tim.extend(list_temp_partner_tim[i][j])\n\n            # print(\"update partner_tim\", dic['generate' + str(i)].used_list[j].partner_tim)\n\n            # b\n            # print(\"check error\", dic['generate' + str(i)].used_list[j].center_line)\n            dic['generate' + str(i)].used_list[j].mesureLength_RhinoCommon()\n\n    # tim_distance \n    for i in range(pop_num):\n        for j in range(num_timber):\n            for k in range(num_timber):\n                if k != j:\n                    timberMethod.distanceBetweenTimber_RhinoCommon(dic['generate' + str(i)].used_list[j],\n                                                                   dic['generate' + str(i)].used_list[k])\n                else:\n                    dic['generate' + str(i)].used_list[j].tim_distance[dic['generate' + str(i)].used_list[j].name] = []\n                    continue\n\n    # gene_information \n    for i in range(pop_num):\n        dic['generate' + str(i)].gene_info = []\n        dic['generate' + str(i)].gene_info.extend(list_temp_gene_tim[i])\n\n    # select_domain_list\n    for i in range(pop_num):\n        for j in range(num_timber):\n            dic['generate' + str(i)].used_list[j].select_domain_list = []\n            dic['generate' + str(i)].used_list[j].select_domain_list.extend(\n                temp_list_select_domain_list_for_next_generation[i][dic['generate' + str(i)].used_list[j].name])\n\n# Step10:  EVALUATION\nevaluation_value = []\nt3_1 = time.time()\nfor i in range(pop_num):\n    instance_pop = dic['generate' + str(i)]\n\n    # evaluate_value = GA.Evaluation.overlap_num2(num_timber, instance_pop)\n    # evaluate_value = GA.Evaluation.partner_num_evaluate(num_timber, instance_pop, 2, 3)\n    evaluate_value = GA.Evaluation.pop_evaluation(num_timber, instance_pop)\n\n    dic['generate' + str(i)].evaluation = evaluate_value\n\n    evaluation_value.append(dic['generate' + str(i)].evaluation)\n    # print('evaluation value Pop: %s : value is %s'%(i, dic['generate' + str(i)].evaluation))\nevaluate_list.append(evaluation_value)\n\n\n# \neva_high_index = evaluation_value.index(max(evaluation_value))\nfor i in range(pop_num):\n    rs.AddLayer('pop' + str(i))\n\n\nfor i in range(pop_num):\n    for j in range(num_timber):\n        center_line = scriptcontext.doc.Objects.AddCurve(dic['generate' + str(i)].used_list[j].center_line)\n        surface = scriptcontext.doc.Objects.AddBrep(dic['generate' + str(i)].used_list[j].surface)\n        rs.ObjectLayer(center_line, 'pop' + str(i))\n        rs.ObjectLayer(surface, 'pop' + str(i))\n\nfor i in range(pop_num):\n    if i == eva_high_index:\n        pass\n    else:\n        rs.LayerVisible('pop' + str(i), False)\n\nrs.CurrentLayer('pop' + str(eva_high_index))\nrs.LayerVisible('all_pop_layer', False)\n\n\nt4_1 = time.time()\nprint(\"\\n\")\nprint(\"Result of EVALUATION --- Generation : %s  Result : %s\" % (generation_num, evaluation_value))\nprint(\"Evaluation Time: %s\" % (t4_1 - t3_1))\n\n\nprogram_finish = time.time()\nprint(\"\\n\")\nprint(\"EVALUATE : result --- %s\" % evaluate_list)\nprint(\"Processing Time : %s\" % (program_finish - program_start))\n\n\n# \ndrawInformatinon.drawEvaluateValue(evaluate_list)\n\n#\n# partner_list = []\n# for i in range(len(pop_1.used_list)):\n#     partner_list.append(pop_1.used_list[i].partner_tim)\n# print(\"partner_list : %s\"%(partner_list))\n\n#\n# value = []\n# for i in range(pop_num):\n#     length = len(dic['generate' + str(i)].used_list)\n#     value.append(length)\n# sum_list = sum(value)\n# print(\"sum of used_timber_num\", sum_list)\n#\n# for i in range(pop_num):\n#     for j in range(num_timber):\n#         srf = dic['generate' + str(i)].used_list[j].surface\n#         print(\"srf\", srf)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "layer", "brep", "line", "curve", "RhinoCommon"], "original_file": "TTM-KK_TimberFormOptimization_23cf24abf6.json", "repo": "TTM-KK/TimberFormOptimization"}
{"instruction": "Implement the function 'scanObjectSort' for Rhino scripting", "code": "# -*- coding:utf-8 -*-\n\nimport rhinoscriptsyntax as rs\n\n\ndef scanObjectSort(num_timber, get_center_line, get_surface):\n    # \n    center_line_list = []  # \n    surface_list = []  # \n    mark_line_list = []  # mark line\n\n    #  --> \n    end_point_list = []\n\n    for i in range(0, num_timber):\n        start_end_point = rs.CurveStartPoint(get_center_line[i])  # \n        end_point_list.append(start_end_point[0])  # x\n\n    # \n    for _ in range(0, num_timber):\n        select_index = end_point_list.index(min(end_point_list))\n        select_timber_center_line = get_center_line[select_index]\n\n        # \n        center_line_list.append(select_timber_center_line)\n\n        # \n        get_center_line.pop(select_index)\n        end_point_list.pop(select_index)\n\n    #  --> \n    point_on_surface_list = []\n\n    for i in range(0, num_timber):\n        domainU = rs.SurfaceDomain(get_surface[i], 0)\n        domainV = rs.SurfaceDomain(get_surface[i], 1)\n        u = domainU[1] / 2.0\n        v = domainV[1] / 2.0\n        point = rs.EvaluateSurface(get_surface[i], u, v)\n\n        # x\n        point_on_surface_list.append(point[0])\n\n    # \n    for _ in range(0, num_timber):\n        select_index = point_on_surface_list.index(min(point_on_surface_list))\n        select_timber_surface = get_surface[select_index]\n\n        # \n        surface_list.append(select_timber_surface)\n\n        # \n        get_surface.pop(select_index)\n        point_on_surface_list.pop(select_index)\n\n    # mark line --> mark line\n    # point_on_mark_line = []\n    #\n    # for i in range(0, len(get_mark_line)):\n    #     mid_point = rs.CurveMidPoint(get_mark_line[i])\n    #     point_on_mark_line.append(mid_point[0])\n    #\n    # # \n    # for _ in range(0, num_timber):\n    #     select_index1 = point_on_mark_line.index(min(point_on_mark_line))\n    #     select_timber_mark_line1 = get_mark_line[select_index1]\n    #\n    #     # \n    #     point_on_mark_line.pop(select_index1)\n    #     get_mark_line.pop(select_index1)\n    #\n    #     select_index2 = point_on_mark_line.index(min(point_on_mark_line))\n    #     select_timber_mark_line2 = get_mark_line[select_index2]\n    #\n    #     # \n    #     point_on_mark_line.pop(select_index2)\n    #     get_mark_line.pop(select_index2)\n    #\n    #     # \n    #     two_mark_line = [select_timber_mark_line1, select_timber_mark_line2]\n    #\n    #     mark_line_list.append(two_mark_line)\n\n    return [center_line_list, surface_list]\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "line", "curve", "functions"], "original_file": "TTM-KK_TimberFormOptimization_562cf2843c.json", "repo": "TTM-KK/TimberFormOptimization"}
{"instruction": "Document basics", "code": "from contextlib import contextmanager\r\n\r\nfrom Rhino.Geometry import BoundingBox\r\nimport rhinoscriptsyntax as rs\r\n\r\nfrom geometry import points\r\n\r\n\r\ndef silent(command):\r\n    rs.Command(command, False)\r\n\r\n\r\n\"\"\"\r\nDocument basics\r\n\"\"\"\r\n\r\n\r\ndef save():\r\n    silent(\"-save enter\")\r\n\r\n\r\ndef close():\r\n    silent(\"exit\")\r\n\r\n\r\ndef current_folder():\r\n    return rs.WorkingFolder()\r\n\r\n\r\n@contextmanager\r\ndef no_redraw():\r\n    try:\r\n        silent(\"setredrawoff\")\r\n        yield\r\n    finally:\r\n        silent(\"setredrawon\")\r\n\r\n\r\ndef clear():\r\n    print(\"Clearing document\")\r\n    silent(\"selall enter delete\")\r\n\r\n\r\ndef zoom(pts):\r\n    zoom_box = BoundingBox(pts)\r\n    zoom_box.Inflate(30, 30, 0)\r\n    rs.ZoomBoundingBox(zoom_box)\r\n\r\n\r\ndef zoom_upper_left_close_pair(pts):\r\n    pts = points.Points(pts)\r\n    pts = sorted(pts)\r\n    pts = pts[0], points.nearest_neighbor(pts[0], pts[1:])\r\n    pts = map(points.toPoint3d, pts)\r\n    zoom(pts)\r\n    return pts\r\n\r\n\r\ndef zoom_random_close_pair(pts):\r\n    pts = points.Points(pts)\r\n    pts = points.random_nearest_pair(pts)\r\n    pts = map(points.toPoint3d, pts)\r\n    zoom(pts)\r\n    return pts\r\n\r\n\r\n\"\"\"\r\nMarkup\r\n\"\"\"\r\n\r\n\r\ndef text(string, height, position):\r\n    x, y = position\r\n    command = '-text Height={height} \"{string}\" {x},{y}'.format(\r\n        height=height,\r\n        string=string,\r\n        x=x,\r\n        y=y,\r\n    )\r\n    silent(command)\r\n\r\n\r\ndef text_centered(string, height, position):\r\n    silent(\"-SetCurrentAnnotationStyle Centered\")\r\n    text(string, height, position)\r\n    silent(\"-SetCurrentAnnotationStyle Default\")\r\n\r\n\r\ndef text_centered_vertical(string, height, position):\r\n    silent(\"-SetCurrentAnnotationStyle Centered-Vertical\")\r\n    text(string, height, position)\r\n    silent(\"-SetCurrentAnnotationStyle Default\")\r\n\r\n\r\n\"\"\"\r\nGeometry\r\n\"\"\"\r\n\r\n\r\ndef guid2geom(guids):\r\n    \"\"\"Get a list of geometry objects from a list of guids\r\n\r\n    Args:\r\n        guids (GuidList): The list of guis to process\r\n\r\n    Returns:\r\n        GeomList: The list of geometry objects\r\n    \"\"\"\r\n    return [rs.rhutil.coercegeometry(guid, False) for guid in guids]\r\n\r\n\r\ndef end_points(curves, tol=0.001):\r\n    \"\"\"\r\n    Grab the endpoints of open curves\r\n    \"\"\"\r\n    results = []\r\n\r\n    for curve in curves:\r\n        start = rs.CurveStartPoint(curve)\r\n        end = rs.CurveEndPoint(curve)\r\n        distance = start.DistanceTo(end)\r\n\r\n        # Add endpoints only if they are distinct (= open curve)\r\n        if distance > tol:\r\n            results += [start, end]\r\n\r\n    return results\r\n\r\n\r\ndef bbox(guids):\r\n    \"\"\"Get a rhino.geometry bbox object\r\n\r\n    Args:\r\n        geom_list (Iterable[GuidList]): A iterator of object guids\r\n\r\n    Returns:\r\n        Rhino.Geometry.BoundingBox: The input's bounding box\r\n    \"\"\"\r\n    _bbox = BoundingBox.Empty\r\n\r\n    for geom in guid2geom(guids):\r\n        _bbox.Union(geom.GetBoundingBox(accurate=True))\r\n\r\n    return _bbox\r\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "point", "curve", "functions", "RhinoCommon"], "original_file": "Teakomatic_RETools-6d40c603-c950-4785-9bb8-cc46930ae150-_1a50615f86.json", "repo": "Teakomatic/RETools-6d40c603-c950-4785-9bb8-cc46930ae150-"}
{"instruction": "Implement the function 'tcp' for Rhino scripting", "code": "from imp import reload\nimport Rhino.Geometry as rg\nimport simple_ur_script as ur\nreload(ur)\nimport simple_comm as c\nreload(c)\n\ndef tcp(script):\n    script += ur.set_tcp_by_angles(TCP[0], TCP[1], TCP[2], TCP[3], TCP[4], TCP[5])\n    return script\n\ndef set_robot_base():\n    pt_0 = TABLE_NAVIGATION_POINTS[0] # base plane origin\n    pt_1 = TABLE_NAVIGATION_POINTS[1] \n    pt_2 = TABLE_NAVIGATION_POINTS[2]\n    robot_base = rg.Plane(pt_0,pt_1-pt_0,pt_2-pt_0)\n    return robot_base\n\ndef rhino_to_robot_space(rhino_plane):\n    plane = rhino_plane.Clone()\n    robot_base_plane = set_robot_base()\n    rhino_matrix = rg.Transform.PlaneToPlane(rg.Plane.WorldXY,robot_base_plane)\n    plane.Transform(rhino_matrix)\n    return plane\n\ndef pickup_brick(script,pick_up_plane):\n    planes = []\n    #change the distance if needed\n    SAFE_DIST = 150\n    \n    safe_plane = pick_up_plane.Clone()\n    safe_plane.Translate(rg.Vector3d.ZAxis*SAFE_DIST)\n    \n    ## add to the path: go to the safe plane\n    script += ur.move_l(safe_plane, SAFE_ROBOT_ACC, SAFE_ROBOT_VEL)\n    planes.append(safe_plane)\n    \n    ## add to the path: go to the pick up plane\n    script += ur.move_l(pick_up_plane, SAFE_ROBOT_ACC, SAFE_ROBOT_VEL)\n    planes.append(pick_up_plane)\n    \n    ## add to the path: turn on the vacuum and wait 1 sec.\n    script += ur.set_digital_out(IO,True)\n    script += ur.sleep(SAFE_SLEEP_TIME)\n\n    # add to the path: go back to the safe_plane\n    script += ur.move_l(safe_plane, SAFE_ROBOT_ACC, SAFE_ROBOT_VEL)\n    planes.append(safe_plane)\n    return script, planes\n\ndef place_brick(script, place_plane):\n    \n    planes = []\n\n    safe_plane = place_plane.Clone()\n    safe_plane.Translate(rg.Vector3d.ZAxis*SAFE_DIST)\n    \n    # add to the path: go to the safe plane\n    script += ur.move_l(safe_plane, SAFE_ROBOT_ACC, SAFE_ROBOT_VEL)\n    planes.append(safe_plane)\n    \n    # add to the path: go to the place plane\n    script += ur.move_l(place_plane, SAFE_ROBOT_ACC, SAFE_ROBOT_VEL)\n    planes.append(place_plane)\n    \n    ## add to the path: turn off the vacuum and wait 1 second (hold the brick)\n    script += ur.set_digital_out(IO,False)\n    script += ur.sleep(SAFE_SLEEP_TIME)\n    # add to the path: go back to the safe plane\n    script += ur.move_l(safe_plane, SAFE_ROBOT_ACC, SAFE_ROBOT_VEL)\n    planes.append(safe_plane)\n    \n    return script,planes\n\ndef send(script):\n    script = c.concatenate_script(script)\n    c.send_script(script, ROBOT_IP)\n    return script \n\nscript = \"\"\nscript = tcp(script)\n\nif is_debug_mode:\n    test_plane = debug_plane.Clone()\n    script += ur.move_l(rhino_to_robot_space(test_plane), SAFE_ROBOT_ACC, SAFE_ROBOT_VEL)\n\nelse:\n    for i in range(len(brick_planes)):\n        script, p = pickup_brick(script,rhino_to_robot_space(picking_planes[i%len(picking_planes)]))\n        script, p = place_brick(script,rhino_to_robot_space(brick_planes[i]))\n\nif fabricate:\n    send(script)", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "functions", "RhinoCommon"], "original_file": "ZacZhangzhuo_endless-wall-teamwork_a078760f10.json", "repo": "ZacZhangzhuo/endless-wall-teamwork"}
{"instruction": "Implement the function 'check_files' for Rhino scripting", "code": "import rhino3dm\nimport compute_rhino3d\nimport compute_rhino3d.Util\nimport requests\nimport os\nimport json\nimport traceback\n\n# Rhino Compute URL\nRHINO_COMPUTE_URL = \"http://localhost:5000\"\n\n# File paths\nGEOMETRY_PATH = r\"D:\\spz_analysis2\\\\newyork.3dm\"\nSCALED_GEOMETRY_PATH = r\"D:\\spz_analysis2\\\\newyork_scaled.3dm\"\nSCALE_FACTOR = 2.0  # Scaling factor\n\n# Function to check if files exist\ndef check_files():\n    print(\"Checking file paths:\")\n    if not os.path.exists(GEOMETRY_PATH):\n        raise FileNotFoundError(f\"Error: Geometry file '{GEOMETRY_PATH}' is missing!\")\n    print(\" Geometry file found!\")\n\n# Function to test Rhino Compute connection\ndef test_rhino_compute():\n    try:\n        response = requests.get(f\"{RHINO_COMPUTE_URL}/version\")\n        print(\"Rhino Compute Response:\", response.text)\n        return response.status_code == 200\n    except requests.exceptions.RequestException as e:\n        print(\"Error connecting to Rhino Compute:\", e)\n        return False\n\n# Function to load .3dm file and extract geometry\ndef load_geometry():\n    try:\n        print(\" Loading 3DM File:\", GEOMETRY_PATH)\n        model = rhino3dm.File3dm.Read(GEOMETRY_PATH)\n        \n        if not model:\n            raise ValueError(\" Failed to load the 3DM file!\")\n\n        # Extract objects (Meshes, Breps, or Curves)\n        objects = [obj.Geometry for obj in model.Objects]\n        if not objects:\n            raise ValueError(\" No geometry found in the 3DM file!\")\n\n        print(f\" Found {len(objects)} objects in the file.\")\n        return objects\n\n    except Exception as e:\n        print(\" Error loading geometry:\", e)\n        return None\n\n# Function to scale geometry using Rhino Compute\ndef scale_geometry(objects):\n    try:\n        print(\" Scaling Geometry via Rhino Compute...\")\n\n        # Define the scaling transformation\n        scale_transform = rhino3dm.Transform.Scale(rhino3dm.Point3d(0, 0, 0), SCALE_FACTOR)\n\n        # Serialize geometry using compute_rhino3d.Geometry.encode\n        serialized_objects = [compute_rhino3d.Geometry.encode(obj) for obj in objects]\n\n        # Send transformation request to Rhino Compute\n        response = requests.post(\n            f\"{RHINO_COMPUTE_URL}/rhino/geometry/transform\",\n            json={\n                \"transforms\": [scale_transform.ToFloatArray()] * len(serialized_objects),  # Correct transformation format\n                \"geometry\": serialized_objects\n            }\n        )\n\n        # Process response\n        if response.status_code == 200:\n            scaled_data = response.json()\n            scaled_objects = [compute_rhino3d.Geometry.decode(obj) for obj in scaled_data]\n            print(f\" Successfully scaled {len(scaled_objects)} objects.\")\n            return scaled_objects\n        else:\n            print(\" Error:\", response.status_code)\n            print(\" Rhino Compute Response:\", response.text)\n            return None\n\n    except Exception as e:\n        print(\" Error during scaling:\", e)\n        print(traceback.format_exc())\n        return None\n\n# Function to save the scaled geometry into a new .3dm file\ndef save_scaled_geometry(scaled_objects):\n    try:\n        print(\" Saving Scaled Geometry...\")\n\n        # Create a new 3DM model\n        model = rhino3dm.File3dm()\n        for obj in scaled_objects:\n            model.Objects.Add(obj)\n\n        # Save file\n        model.Write(SCALED_GEOMETRY_PATH, 6)  # Rhino 6 file format\n        print(f\" Scaled geometry saved to {SCALED_GEOMETRY_PATH}\")\n\n    except Exception as e:\n        print(\" Error saving file:\", e)\n        print(traceback.format_exc())\n\n# Run the script\nif __name__ == \"__main__\":\n    try:\n        print(\"Requests module imported successfully.\")\n\n        # Step 1: Check files\n        check_files()\n\n        # Step 2: Test Rhino Compute\n        if not test_rhino_compute():\n            raise ConnectionError(\"Rhino Compute is not reachable. Make sure it is running.\")\n\n        # Step 3: Load geometry from .3dm file\n        objects = load_geometry()\n        if not objects:\n            raise ValueError(\"No geometry found in the 3DM file.\")\n\n        # Step 4: Scale the geometry\n        scaled_objects = scale_geometry(objects)\n        if not scaled_objects:\n            raise ValueError(\"Scaling failed.\")\n\n        # Step 5: Save the scaled geometry\n        save_scaled_geometry(scaled_objects)\n\n    except Exception as e:\n        print(\" Fatal Error:\")\n        print(traceback.format_exc())\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["point", "brep", "curve", "functions", "mesh"], "original_file": "adapt-ai-team_ADAPT_AI_25b636458d.json", "repo": "adapt-ai-team/ADAPT_AI"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "from package.scripts import frame as f\nimport rhinoscriptsyntax as rs\nfrom package.scripts import settings as s\n\nclass Layer(object):\n    prohibited_characters = [' ', '#']\n\n    def __init__(self):\n        pass\n\n    @classmethod                                ##  done 08-05\n    def new(cls, name_in):\n        \"\"\"Receives:\n            name_in         str. A well-formed and available layer name\n        Adds a layer named <name_in>. Returns:\n            name_out        str. The name of the layer\n        \"\"\"\n        name_out = rs.AddLayer(name_in)\n        return name_out\n\n    @classmethod                                ##  done 08-06\n    def get_layer_name_from_user(cls):\n        \"\"\"Gets a valid name from the user. Returns:\n            name            str. A unique and well-formed layer name\n        \"\"\"\n        message_1 = \"%s %s\" % (\n            \"Enter the layer name.\", \n            \"It must be unique and contain no spaces or '#' characters\")\n        message_2 = \"%s %s %s\" % (\n            \"That name is already in use\",\n            \"or it contains spaces or '#' characters.\",\n            \"Try again\")\n        name = rs.GetString(message_1)\n        while not (\n            cls._is_well_formed(name) and \n            cls._is_available(name)\n        ):\n            name = rs.GetString(message_2)\n        return name\n\n    @classmethod                                ##  called\n    def _is_well_formed(cls, name):\n        \"\"\"Receives:\n            name            str. The name of a layer\n        Returns:\n            boolean         True, if the name is well-formed. False, \n                            otherwise\n        \"\"\"\n        return_value = True\n        for character in cls.prohibited_characters:\n            if character in name:\n                return_value = False\n                break\n        return return_value\n\n    @classmethod                                ##  called\n    def _is_available(cls, name):\n        \"\"\"Receives:\n            name            str. The name of a layer\n        Returns:\n            boolean         True, if the name is available. False, otherwise\n        \"\"\"\n        return_value = not rs.IsLayer(name)\n        return return_value\n\n    @classmethod                                ##  called\n    def get_frame_instance(cls, initial_shape):\n        \"\"\"Receives:\n            initial_shape   str. The name of a layer containing one frame \n                            instance (i.e., an initial shape layer). The value \n                            is guaranteed\n        Returns:\n            frame_instance  guid. The guid of the frame instance on the layer \n                            Isn't this redundant?\n        \"\"\"\n        if not rs.IsLayer(initial_shape):\n            message = \"There is no layer named '%s'\" % initial_shape\n        all_frame_instances = rs.BlockInstances(s.Settings.frame_name)\n        frame_instances_on_layer = []\n        for frame_instance in all_frame_instances:\n            if rs.ObjectLayer(frame_instance) == initial_shape:\n                frame_instances_on_layer.append(frame_instance)\n        n_instances = len(frame_instances_on_layer)\n        if n_instances == 0:\n            message = \"%s %s\" % (\n                \"There is no frame instance\", \n                \"on the layer '%s'\" % initial_shape)\n            return_value = None\n        elif n_instances == 1:\n            message = None\n            return_value = frame_instances_on_layer.pop()\n        else:\n            message = \"%s %s\" % (\n                \"There is more than 1 frame instance\", \n                \"on the layer '%s'\" % initial_shape)\n            return_value = None\n        if message:\n            print(message)\n        return return_value\n\n    @classmethod                                ##  called\n    def get_frame_instance_pair(cls, rule):\n        \"\"\"Receives:\n            rule            str. The name of a layer containing two frame \n                            instances (i.e., a rule layer). The value is \n                            guaranteed\n        Returns:\n            ordered_frame_instance_pair\n                            (guid, guid). A pair of the guids of the two frame \n                            instances on the layer, ordered from left to right \n        \"\"\"\n        all_frame_instances = rs.BlockInstances(s.Settings.frame_name)\n        frame_instances = []\n        for instance_i in all_frame_instances:\n            if rs.ObjectLayer(instance_i) == rule:\n                frame_instances.append(instance_i)\n        p0 = f.Frame.get_instance_position(frame_instances[0])\n        p1 = f.Frame.get_instance_position(frame_instances[1])\n        if p0 < p1:\n            ordered_frame_instance_pair = (\n                frame_instances[0], frame_instances[1])\n        elif p0 > p1:\n            ordered_frame_instance_pair = (\n                frame_instances[1], frame_instances[0])\n        else:\n            pass\n        return ordered_frame_instance_pair\n\n    @classmethod                                ##  called\n    def contains_initial_shape(cls, name):\n        \"\"\"Receives:\n            name            str. The name of the layer\n        Returns:\n            boolean         True, if the layer contains an initial shape. \n                            False, otherwise\n        \"\"\"\n        value = cls._get_number_of_frames(name) == 1\n        return value\n\n    @classmethod                                ##  called\n    def contains_rule(cls, name):\n        \"\"\"Receives:\n            name            str. The name of the layer_name\n        Returns:\n            boolean         True, if the layer contains a rule. False, \n                            otherwise\n        \"\"\"\n        value = cls._get_number_of_frames(name) == 2\n        return value\n\n    @classmethod                                ##  called\n    def _get_number_of_frames(cls, layer_name):\n        \"\"\"Receives:\n            layer_name      str. The name of the layer\n        Returns:\n            n               int. The number of frame instances on the layer\n        \"\"\"\n        frame_name = s.Settings.frame_name\n        if not rs.IsBlock(frame_name):\n            n = 0\n        else:\n            frame_instance_guids = rs.BlockInstances(frame_name)\n            n = 0\n            for guid in frame_instance_guids:\n                if cls._contains_guid(guid, layer_name):\n                    n = n + 1\n        return n\n\n    @classmethod                                ##  called\n    def _contains_guid(cls, frame_guid, layer_name):\n        \"\"\"Receives:\n            frame_guid      The guid of a frame instance\n        Returns:\n            value           boolean. True, if the layer contains the frame \n                            instance. False, otherwise\n        \"\"\"\n        frame_layer_name = rs.ObjectLayer(frame_guid)\n        value = frame_layer_name == layer_name\n        return value\n\n    @classmethod                                ##  called\n    def get_objects_on_layer(cls, frame_instance):\n        \"\"\"Receives:\n            frame_instance  The guid of a frame instance\n        Returns:\n            objects_on_layer\n                            [guid, ...]. A list of the guids of the objects \n                            on the layer containing the frame instance, if \n                            successful\n            None            otherwise\n        \"\"\"\n        layer_name = rs.ObjectLayer(frame_instance)\n        objects_on_layer = rs.ObjectsByLayer(layer_name)\n        return objects_on_layer\n\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "classes", "layer", "functions", "block"], "original_file": "andrewili_shape-grammar-engine_f71bdd2201.json", "repo": "andrewili/shape-grammar-engine"}
{"instruction": "Write a function to delete all", "code": "import rhinoscriptsyntax as rs\nimport math as ma\nimport random as rd\n\ndef delete_all():\n    all_objects = rs.ObjectsByType(0)\n    rs.DeleteObjects(all_objects)\n\ndef delete_something(n):\n    something = rs.ObjectsByType(n)\n    rs.DeleteObjects(something)\n\ndef polar(r, theta):\n    x = r * ma.cos(theta)\n    y = r * ma.sin(theta)\n    return (x, y, 0)\n\ndef noise_circle((xx, yy, zz), R):\n    point = []\n    for t in rs.frange(0, 360, 20):\n        ranran = rd.randint(4, 8)\n        ranranran = rd.random()/ranran + 0.3\n        sin = ma.sin(ma.radians(t/5 + 54))/2\n        R_real = ( ranranran + sin ) * R \n        \n        ran = rd.randint(1, 2)\n        \n        p = rs.AddPoint(xx, yy, zz)\n        rs.MoveObject(p, polar(R_real, ma.radians(t)))\n        \n        point.append(p)\n    point.append(point[0])\n    c = rs.AddCurve(point)\n    ran = rd.randint(1, 90)\n    rs.RotateObject(c, (xx, yy, zz), ran, None, False)\n\ndef draw_stone():\n    r_box     = []\n    theta_box = []\n    R_box     = []\n    \n    #how many circles\n    n = 100\n    \n    for a in range(0, n):\n        if a == 0 :\n            #center big circle\n            R = 20\n            noise_circle(polar(0,0), R)\n            \n            theta_box.append(0)\n            r_box.append(0)\n            R_box.append(R)\n        else:\n            #probability to make big circle is1/7 \n            random = rd.randint(1,7)\n            \n            if random == 1:\n                #big circle size\n                max_circle = 15\n                min_circle = 10\n                R = rd.randint(min_circle, max_circle)\n            else:\n                #normal circle size\n                max_circle = 8\n                min_circle = 3\n                R = rd.randint(min_circle, max_circle) \n            \n            angle = []\n            for t in rs.frange(1,360,72):\n                angle.append(t)\n            theta = rd.choice(angle) + rd.randint(-5, +5)\n            \n            r_contact       = []\n            r_contacted     = []\n            theta_contact   = []\n            theta_contacted = []\n            R_contact       = []\n            R_contacted     = []\n            \n            L = R*0.5\n            \n            b = 0\n            #determine contact or not contact\n            while (b != a):\n                D = -(r_box[b] * ma.sin(theta_box[b] - theta))**2 + (R + L/2 + R_box[b])**2\n                #if contact\n                if D  > 0 :\n                    r = (r_box[b]) * ma.cos(theta - theta_box[b]) + ma.sqrt(D)                   \n                    if r > R_box[b]:\n                        theta_contact.append(theta)\n                        r_contact.append(r)\n                        R_contact.append(R)\n                        \n                        theta_contacted.append(theta_box[b])\n                        r_contacted.append(r_box[b])\n                        R_contacted.append(R_box[b])\n                        \n                        b += 1\n                    else:\n                        b += 1\n               #if not contact\n                else:\n                    b += 1\n            \n            else :\n                #if we have contacted circle\n                if 1 <= len(r_contact) :\n                    r_real   = max(r_contact)\n                    number   = r_contact.index(r_real)\n                    r_before = r_contacted[number]\n                    \n                    theta_real   = theta_contact[number]\n                    theta_before = theta_contacted[number]\n                    \n                    R_real   = R_contact[number]\n                    R_before = R_contacted[number]\n                    \n                    noise_circle(polar(r_real, theta_real), R_real)\n                    \n                    #line ga aruto wakariyasui\n                    #p_before = polar(r_before , theta_before)\n                    #p_real = polar(r_real , theta_real)\n                    #line1 = rs.AddLine(p_before, p_real)\n                    \n                    r_box.append(r_real)\n                    theta_box.append(theta_real)\n                    R_box.append(R_real)\n                #if do not have\n                else:\n                    noise_circle(polar(R_box[0] + R + L, theta), R)\n                    \n                    theta_box.append(theta)\n                    r_box.append(R + L + R_box[0])\n                    R_box.append(R)\n\ndelete_all()\n\ndraw_stone()\ndelete_something(1)", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "point", "line", "curve", "functions"], "original_file": "bayasshii_RhinoPython_d527d1aa28.json", "repo": "bayasshii/RhinoPython"}
{"instruction": "Write a function to delete all", "code": "import rhinoscriptsyntax as rs\nimport math as ma\nimport random as rd\n\ndef delete_all():\n    all_objects = rs.ObjectsByType(0)\n    rs.DeleteObjects(all_objects)\n\ndef delete_something(n):\n    something = rs.ObjectsByType(n)\n    rs.DeleteObjects(something)\n\ndef polar_to_rectangular(r,theta):\n    x = r * ma.cos(theta)\n    y = r * ma.sin(theta)\n    return (x, y, 0)\n\ndef draw_tree():\n    x_coordinate = []\n    y_coordinate = []\n    r = 2\n    ran = 10\n    n = 100\n    for a in range(0, n):\n        if a == 0 :\n            x = rd.uniform(-1, 1) * ran\n            rs.AddCircle((x, r, 0), r)\n            x_coordinate.append(x)\n            y_coordinate.append(r)\n            \n        else:\n            maxx = max(x_coordinate)\n            minn = min(x_coordinate)\n            x = rd.uniform(minn, maxx) + rd.uniform(-1, 1) * ran \n            \n            y_contact = []\n            x_contact = []\n            y_contacted = []\n            x_contacted = []\n            \n            b = len(x_coordinate) -1\n            \n            while (b != -1):\n                if x_coordinate[b] - r*3 <= x <= x_coordinate[b] + r*3:\n                    y = ma.sqrt((r*3)**2 - (x_coordinate[b] - x)**2) + y_coordinate[b] \n                    \n                    y_contact.append(y)\n                    x_contact.append(x)\n                    y_contacted.append(y_coordinate[b])\n                    x_contacted.append(x_coordinate[b])\n                    b -= 1\n                    \n                else:\n                    b -= 1\n            else :\n                if 1 <= len(y_contact) :\n                    y_real = max(y_contact)\n                    number = y_contact.index(y_real)\n                    x_real = x_contact[number]\n                    \n                    y_coordinate.append(y_real)\n                    x_coordinate.append(x_real)\n                    \n                    d =( (x_real - x_contacted[number])*1/3 + x_contacted[number], (y_real - y_contacted[number])*1/3 + y_contacted[number], 0)\n                    e =( (x_real - x_contacted[number])*2/3 + x_contacted[number], (y_real - y_contacted[number])*2/3 + y_contacted[number], 0)\n                    rs.AddLine(d, e)\n                    rs.AddCircle((x_real, y_real, 0), r)\n                else:\n                    rs.AddCircle((x, r, 0), r)\n                    x_coordinate.append(x)\n                    y_coordinate.append(r)\n\ndelete_all()\ndraw_tree()", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "line", "functions"], "original_file": "bayasshii_RhinoPython_ffd8343036.json", "repo": "bayasshii/RhinoPython"}
{"instruction": "The default service life and wastage coefficients are indicative only and can vary substantially.", "code": "# -*- coding: UTF-8 -*-\r\n\r\nimport copy\r\nimport datetime\r\nimport os.path\r\nfrom collections import OrderedDict\r\nfrom math import sqrt, floor, ceil, log10, isnan\r\nfrom scriptcontext import sticky as st\r\nimport Grasshopper.Kernel as ghKernel\r\nimport cPickle\r\nimport ghpythonlib.components as ghcomponents\r\nimport rhinoscriptsyntax as rs\r\nfrom Grasshopper import DataTree\r\nfrom Rhino import Display\r\nfrom Rhino import Geometry\r\nfrom System import Drawing\r\nfrom System import Guid\r\nfrom System.Drawing import Color\r\nimport os\r\nimport random\r\n\r\n__author__ = \"Andr Stephan & Fabian Prideaux\"\r\n__version__ = \"1.02\"\r\n__date__ = 'May, 2024'\r\n__message__ = 'EPiC Plugin ' + __version__ + '\\n' + __date__\r\nepic_version = 'AU2024'\r\nEPIC_DATABASE_WEBSITE = 'http://www.msd.unimelb.edu.au/epic'\r\nREPORT_A_BUG = 'https://bit.ly/EPiCGrasshopperBugs'\r\nDISCLAIMER = \"\"\" \r\nThe default service life and wastage coefficients are indicative only and can vary substantially. \r\n\r\nThe authors disclaim any liability, in whole or in part, arising from information contained in this plugin.\r\nThey do not take any responsibility for any action taken, decision-made, or result associated with use of this plugin\r\n\r\nFurther information about the EPiC Database and EPiC Grasshopper can be found at <http://www.epicdatabase.com.au/>\r\nTo download a full copy of the database, goto <http://doi.org/10.26188/5dc228ef98c5a>\r\n\"\"\"\r\n\r\n# Colour scheme used for EPiC Grasshopper / EPiC Database\r\nCOLOURS = {\r\n    'light_teal': Color.FromArgb(124, 189, 206),\r\n    'teal': Color.FromArgb(63, 167, 196),\r\n    'light_orange': Color.FromArgb(255, 164, 120),\r\n    'orange': Color.FromArgb(231, 112, 82),\r\n    'light_yellow': Color.FromArgb(255, 220, 162),\r\n    'yellow': Color.FromArgb(236, 174, 101),\r\n    'light_green': Color.FromArgb(152, 214, 195),\r\n    'green': Color.FromArgb(89, 177, 127),\r\n    'grey': Color.FromArgb(153, 162, 170),\r\n    'dark_grey': Color.FromArgb(100, 100, 100),\r\n    'light_blue': Color.FromArgb(173, 205, 240),\r\n    'blue': Color.FromArgb(64, 116, 178),\r\n    'light_purple': Color.FromArgb(176, 188, 225),\r\n    'purple': Color.FromArgb(114, 131, 191),\r\n    'light_pink': Color.FromArgb(255, 189, 204),\r\n    'pink': Color.FromArgb(238, 136, 137)\r\n}\r\n\r\n# Generic variables used throughout\r\nDEFINED_FLOWS = OrderedDict()\r\nDEFINED_FLOWS['energy'] = {'code_name': 'energy', 'print_name': 'Energy', 'unit': 'MJ',\r\n                           'colour': COLOURS['orange'], 'secondary_colour': COLOURS['light_orange']}\r\nDEFINED_FLOWS['water'] = {'code_name': 'water', 'print_name': 'Water', 'unit': 'L',\r\n                          'colour': COLOURS['teal'], 'secondary_colour': COLOURS['light_teal']}\r\nDEFINED_FLOWS['ghg'] = {'code_name': 'ghg', 'print_name': 'Greenhouse Gas Emissions', 'unit': 'kgCOe',\r\n                        'colour': COLOURS['yellow'], 'secondary_colour': COLOURS['light_yellow']}\r\n\r\nHYBRID_VALUE_BREAKDOWN_DICT = {flow: {'process': None, 'io': None} for flow in DEFINED_FLOWS.keys()}\r\n\r\n# Generic epic categories\r\nEPIC_CATEGORIES = [\r\n    \"0: Concrete and plaster products\",\r\n    \"1: Glass\",\r\n    \"2: Insulation\",\r\n    \"3: Metals\",\r\n    \"4: Miscellaneous\",\r\n    \"5: Plastics\",\r\n    \"6: Sand, stone and ceramics\",\r\n    \"7: Timber products\"]\r\n\r\nPICKLE_DB = \"EPiC_Database_2024.pkl\"\r\n\r\n\r\ndef remove_commas_and_flatten_list_for_csv_export(text_inputs, list_separator=' | ',\r\n                                                  remove_spaces=False, limit_characters=False):\r\n    \"\"\"\r\n    Remove any commas from text provided. Flatten if provided as a list of multiple strings.\r\n    :param text_inputs: a string, or list of strings\r\n    :param list_separator: separator (string) to use if a list is provided\r\n    :param remove_spaces: change spaces to underscores\r\n    :param limit_characters: limit string to 50 characters\r\n    :return: string\r\n    \"\"\"\r\n    if isinstance(text_inputs, list):\r\n        flat_text = list_separator.join(text_inputs).replace(\",\", \" \")\r\n    elif isinstance(text_inputs, str):\r\n        flat_text = text_inputs.replace(\",\", \" \")\r\n    else:\r\n        return text_inputs\r\n\r\n    if remove_spaces:\r\n        flat_text = flat_text.replace(' ', '_')\r\n\r\n    if limit_characters:\r\n        flat_text = flat_text[:50]\r\n\r\n    return flat_text\r\n\r\n\r\ndef version_mismatch(component_version):\r\n    \"\"\"\r\n    Display error message if grasshopper component is a different version to epic.py\r\n    :param component_version: Grasshopper component version\r\n    :return: Error message as string\r\n    \"\"\"\r\n    error = '*** WARNING VERSION MISMATCH, PLEASE UPDATE YOUR USER OBJECTS ***\\n' \\\r\n            'DOWNLOAD NEW USER OBJECTS AND COPY + PASTE THE NEW CODE INTO THIS COMPONENT\\n' \\\r\n            'EPiC Plugin version: {}\\n' \\\r\n            'Component version: {}'.format(__version__, component_version)\r\n    return error\r\n\r\n\r\ndef check_functional_unit_and_return_formatted_version(functional_unit):\r\n    \"\"\"\r\n    Check the functional unit and return correctly formatted funcational unit.\r\n    Will generate warning if incorrect input is used\r\n    :param functional_unit: Functional unit for EPiC/Custom Material\r\n    :return: warning message (or None), and formatted functional unit string\r\n    \"\"\"\r\n    warning = None\r\n    if functional_unit and isinstance(functional_unit, str):\r\n        functional_unit = str(functional_unit).lower()\r\n        if functional_unit in ('m', 'm', 'm', 'no.', 'm2', 'm3'):\r\n            if functional_unit == 'm2':\r\n                functional_unit = 'm'\r\n            elif functional_unit == 'm3':\r\n                functional_unit = 'm'\r\n            else:\r\n                pass\r\n    else:\r\n        warning = 'The functional unit can only be \"m\", \"m\", \"m\", \"kg\" or \"no.\" ' \\\r\n                  '(\"m2\" or \"m3\" are accepted and will be corrected).'\r\n    return warning, functional_unit\r\n\r\n\r\ndef make_value_list_input_component(input_node, valuelist_values, ghenv, nickname=None, valuelist_names=None,\r\n                                    xloc=0, yloc=0):\r\n    # type: (int, list, object, str, list, int, int) -> str\r\n    \"\"\"\r\n    Instantiate a new valuelist element in Grasshopper (dropdown list).\r\n    This new valuelist will be connected to the specified component, with preset list of values\r\n    :param input_node: Specify the input node number (in integers)\r\n    :param valuelist_values: List of values to be used in the dropdown list\r\n    :param ghenv: The current grasshopper running environment\r\n    :param nickname: Nickname for the new component\r\n    :param valuelist_names: List of names to be used in the dropdown list\r\n    :param xloc: Move component to the left (negative value) / right (positive value)\r\n    :param xloc: Move component up (negative value) / down (positive value)\r\n    :return: new valuelist Instance Guid\r\n    \"\"\"\r\n    # Ensure that the component expires, so that values load correctly\r\n    # ghenv.Component.ExpireSolution(True)\r\n\r\n    # Check if component already has input\r\n    if ghenv.Component.Params.Input[input_node].SourceCount == 0:\r\n\r\n        # Instantiate new value list\r\n        new_component = ghKernel.Special.GH_ValueList()\r\n\r\n        # Set up default values for the new component\r\n        new_component.CreateAttributes()\r\n\r\n        # Clear any existing list items\r\n        new_component.ListItems.Clear()\r\n        if nickname is not None:\r\n            new_component.NickName = nickname\r\n\r\n        if not xloc:\r\n            xloc = max([len(x) for x in valuelist_values]) * -5 - 100\r\n\r\n        # If no valuelist_names, or the list size is different, then use the values as a default\r\n        if not valuelist_names or len(valuelist_names) != len(valuelist_values):\r\n            valuelist_names = valuelist_values\r\n\r\n        #  Populate the new valuelist with items from the selected category\r\n        for num, vals in enumerate(valuelist_values):\r\n            new_component.ListItems.Add(ghKernel.Special.GH_ValueListItem(str(valuelist_names[num]), '\"'\r\n                                                                          + str(valuelist_values[num]) + '\"'))\r\n\r\n        new_component.Attributes.Pivot = Drawing.PointF(ghenv.Component.Params.Input[input_node].Attributes.Bounds.X\r\n                                                        + xloc - new_component.Attributes.Bounds.Width,\r\n                                                        ghenv.Component.Params.Input[input_node].Attributes.Bounds.Y\r\n                                                        + yloc)\r\n\r\n        # Add valuelist to canvas\r\n        ghdoc = ghenv.Component.OnPingDocument()\r\n        ghdoc.AddObject(new_component, False)\r\n\r\n        # Connect valuelist to component\r\n        ghenv.Component.Params.Input[input_node].AddSource(new_component)\r\n        ghenv.Component.Params.OnParametersChanged()\r\n\r\n        def expire_solution():\r\n            ghenv.Component.ExpireSolution(False)\r\n\r\n        ghdoc.ScheduleSolution(5, expire_solution())\r\n\r\n        return str(new_component.InstanceGuid)\r\n\r\n\r\ndef sum_numerical_dictionary_values(dict_1, dict_2):\r\n    \"\"\"\r\n    Sum together 2 dictionaries (if values are int / float).\r\n    :param dict_1: First dictionary (this will be used as the base dictionary).\r\n    :param dict_2: Second dictionary to merge\r\n    :return: New dictionary with summed values\r\n    \"\"\"\r\n    dict_3 = copy.deepcopy(dict_1)\r\n    for key, value in dict_2.items():\r\n        if isinstance(value, (int, float)):\r\n            dict_3[key] += value\r\n        elif isinstance(value, (dict)):\r\n            dict_3[key] = sum_numerical_dictionary_values(dict_3[key], dict_2[key])\r\n    return dict_3\r\n\r\n\r\ndef list_to_datatree(nestedlist):\r\n    \"\"\" Convert a nested python iterable to a datatree\r\n    Adapted from code by Anders Deluran (2017)\r\n    from https://discourse.mcneel.com/t/outputting-a-nested-python-list-as-tree/48188\r\n    \"\"\"\r\n\r\n    dt = DataTree[object]()\r\n\r\n    # Convert dictionary to list if needed\r\n    if isinstance(nestedlist, dict):\r\n        nestedList = nestedlist.values()\r\n\r\n    if nestedlist:\r\n        for i, l in enumerate(nestedlist):\r\n            dt.AddRange(l, ghKernel.Data.GH_Path(i))\r\n    else:\r\n        return None\r\n    return dt\r\n\r\n\r\ndef _flatten_list(list_of_lists):\r\n    \"\"\"\r\n    Recursive function to iterate through list of lists and return a flattened list of objects\r\n    :param list_of_lists: A list containing nested lists\r\n    :return: A flattened list (no nested lists)\r\n    \"\"\"\r\n    list_vals = []\r\n    for list_item in list_of_lists:\r\n        if isinstance(list_item, list):\r\n            list_vals += _flatten_list(list_item)\r\n        else:\r\n            list_vals.append(list_item)\r\n    return list_vals\r\n\r\n\r\ndef _get_accumulated_number_of_instances(period_of_analysis, service_life, include_initial=True):\r\n    \"\"\"\r\n    Generates a list representing the number of replacements of a material or assembly to date. The length of that list is\r\n    equal to period of built_assets\r\n    :param period_of_analysis: the period of built_assets in years\r\n    :param service_life: the service of the material or assembly\r\n    :param include_initial: boolean flag that specifies if the initial installation should be included\r\n    :return: a list of integers representing the accumulated number of material/assembly in the building at a given year\r\n    \"\"\"\r\n\r\n    if include_initial:\r\n        acc_num_instances = [1] * period_of_analysis\r\n    else:\r\n        acc_num_instances = [0] * period_of_analysis\r\n\r\n    num_replacements = _get_num_replacements(period_of_analysis=period_of_analysis, service_life=service_life)\r\n\r\n    if num_replacements == 0:\r\n        pass\r\n    else:\r\n        for replacement in range(1, num_replacements + 1):\r\n            acc_num_instances[replacement * service_life:] = [num_instances + 1 for num_instances in\r\n                                                              acc_num_instances[replacement * service_life:]]\r\n\r\n    return acc_num_instances\r\n\r\n\r\ndef _get_num_replacements(period_of_analysis, service_life):\r\n    \"\"\"\r\n    Calculates the number of material replacements\r\n    :param period_of_analysis: the period of built_assets in years\r\n    :param service_life: the service_life in years\r\n    :return: an integer, representing the number of replacements\r\n    \"\"\"\r\n    if service_life >= period_of_analysis:\r\n        return 0\r\n    else:\r\n        if period_of_analysis % service_life == 0:\r\n            return period_of_analysis // service_life - 1\r\n        else:\r\n            return period_of_analysis // service_life\r\n\r\n\r\ndef print_csv(report_name, folder_location, period_of_analysis, analysis, epic_assemblies):\r\n    \"\"\"\r\n    Print a csv report based on an EPiCAnalysis component\r\n    :param report_name: Name of report to generate\r\n    :param folder_location: Folder location pathway\r\n    :param period_of_analysis: The period of built_assets for the life cycle assessment report\r\n    :param analysis: EPiCAnalysis objects that are used for the csv report\r\n    :param epic_assemblies: EPiCAssembly objects that are used for the csv report\r\n    \"\"\"\r\n\r\n    message = \"FAILED TO WRITE CSV. Folder location:\" + folder_location\r\n    report_name = remove_commas_and_flatten_list_for_csv_export(report_name, list_separator='_',\r\n                                                                remove_spaces=True) \\\r\n        if report_name else 'EPiC Assembly'\r\n    if not folder_location:\r\n        raise ValueError('No folder location provided')\r\n\r\n    counter = 1\r\n\r\n    filepath = os.path.join(folder_location, report_name + '.csv')\r\n\r\n    # Check if the file already exists. If so, rename. Maximum of 50 versions\r\n    if os.path.exists(filepath):\r\n        while os.path.exists(filepath) and counter < 50:\r\n            counter += 1\r\n            filepath = os.path.join(folder_location, report_name + '_' + str(counter) + '.csv')\r\n\r\n    # Separate epic assemblies and built assets\r\n    epic_built_assets = [x for x in epic_assemblies if x and x.component_type == 'EPiCBuiltAsset'\r\n                         or x.component_type == 'EPiCAnalysis']\r\n    epic_assemblies = [x for x in epic_assemblies if x and x.component_type == 'EPiCAssembly']\r\n\r\n    with open(filepath, 'wb') as csv:\r\n        _write_report_details_to_csv(csv, period_of_analysis, report_name)\r\n        _write_flow_values_to_csv(analysis, csv)\r\n\r\n        if len(epic_built_assets) > 0:\r\n            _write_built_asset_flow_values_to_csv(epic_built_assets, csv)\r\n\r\n        if len(epic_assemblies) > 0:\r\n            _write_assembly_flow_info_to_csv(csv)\r\n            _write_assembly_flows_to_csv(epic_assemblies, csv)\r\n\r\n        _write_boq_to_csv(csv, analysis)\r\n        message = \"Successfully printed to .csv file: \" + filepath\r\n    return message\r\n\r\n\r\ndef _write_report_details_to_csv(csv, period_of_analysis, report_name):\r\n    \"\"\"\r\n    Write report details to .csv file.\r\n    :param csv: The csv file to write to\r\n    :param period_of_analysis: Period of analysis for the report in years\r\n    :param report_name: Name of the report (EPiCAnalysis name)\r\n    \"\"\"\r\n    # csv.write('                                                 @@@@                          \\n')\r\n    # csv.write(' /////////////////      ///////////////         @@@@@@          ////////////   \\n')\r\n    # csv.write(' /////////////////      //////////////////       @@@@        ///////////////// \\n')\r\n    # csv.write(' /////                  /////         /////                 /////              \\n')\r\n    # csv.write(' /////                  /////          ////     /////      /////               \\n')\r\n    # csv.write(' /////                  /////         /////     /////     /////                \\n')\r\n    # csv.write(' ///////////////        /////     ////////      /////     /////                \\n')\r\n    # csv.write(' /////                  ////////////////        /////     //////               \\n')\r\n    # csv.write(' /////                  /////                   /////      /////               \\n')\r\n    # csv.write(' /////                  /////                   /////       /////              \\n')\r\n    # csv.write(' /////////////////      /////                   /////        ///////////////// \\n')\r\n    # csv.write(' /////////////////      /////                   /////           ////////////   \\n')\r\n    # csv.write('\\n')\r\n    csv.write(\r\n        'This is a report generated by EPiC Grasshopper: A plugin for analysing hybrid embodied environmental flows')\r\n    csv.write('\\nReport date: ' + datetime.datetime.now().strftime(\"%d %B %Y\"))\r\n    csv.write('\\nTime: ' + datetime.datetime.now().strftime(\"%H:%M\"))\r\n    csv.write('\\n\\nPlugin Version: ' + __version__)\r\n    csv.write('\\nEPiC Database Version: ' + epic_version)\r\n    csv.write('\\nThe authors disclaim any liability - in whole or in part - arising from information contained '\r\n              'in this report.'\r\n              '\\nThey do not take any responsibility for any action taken - decision-made - or result '\r\n              'associated with use of this plugin'\r\n              '\\n*Default service life and wastage coefficients are indicative only and can vary substantially.'\r\n              '\\nFurther information about the EPiC Database and EPiC Grasshopper can be found at: '\r\n              '<http://www.epicdatabase.com.au/> '\r\n              '\\nTo download a full copy of the database - goto <http://doi.org/10.26188/5dc228ef98c5a>'\r\n              '\\n_______________________________________________________________________________________')\r\n    csv.write('\\n\\n' + report_name)\r\n    csv.write('\\nPeriod of Analysis: {} years \\n'.format(period_of_analysis))\r\n    csv.write('\\n')\r\n\r\n\r\ndef _write_flow_values_to_csv(analysis, csv):\r\n    \"\"\"\r\n    Write to a .csv file. Include the total flow values for the analysis object, all assemblies and built asset objects\r\n    :param analysis: EPiCAnalysis class object for calculations\r\n    :param csv: The csv file to write to\r\n    \"\"\"\r\n\r\n    # Life Cycle Total = lc\r\n    lc_energy = analysis.flows['life_cycle']['energy']\r\n    lc_water = analysis.flows['life_cycle']['water']\r\n    lc_ghg = analysis.flows['life_cycle']['ghg']\r\n\r\n    # Total Initial (excl. wastage) = i\r\n    i_energy = analysis.flows['initial']['energy'] - analysis.flows['initial_wastage']['energy']\r\n    i_water = analysis.flows['initial']['water'] - analysis.flows['initial_wastage']['water']\r\n    i_ghg = analysis.flows['initial']['ghg'] - analysis.flows['initial_wastage']['ghg']\r\n\r\n    # Initial Wastage = iw\r\n    iw_energy = analysis.flows['initial_wastage']['energy']\r\n    iw_water = analysis.flows['initial_wastage']['water']\r\n    iw_ghg = analysis.flows['initial_wastage']['ghg']\r\n\r\n    # Total Recurrent (excl. wastage) = r\r\n    r_energy = analysis.flows['recurrent']['energy'] - analysis.flows['recurrent_wastage']['energy']\r\n    r_water = analysis.flows['recurrent']['water'] - analysis.flows['recurrent_wastage']['water']\r\n    r_ghg = analysis.flows['recurrent']['ghg'] - analysis.flows['recurrent_wastage']['ghg']\r\n\r\n    # Total Recurrent Wastage = rw\r\n    rw_energy = analysis.flows['recurrent_wastage']['energy']\r\n    rw_water = analysis.flows['recurrent_wastage']['water']\r\n    rw_ghg = analysis.flows['recurrent_wastage']['ghg']\r\n\r\n    # Write Values to csv\r\n    csv.write('{},{},{},{}\\n'.format('', 'Total Energy (MJ)', 'Total Water (L)', 'Total GHG (kgCO2e)'))\r\n    csv.write('{},{},{},{},{}\\n'.format('Life Cycle Total', lc_energy, lc_water, lc_ghg, ''))\r\n    csv.write('{},{},{},{},{}\\n'.format('>> Total Initial (excl. wastage)', i_energy, i_water, i_ghg, ''))\r\n    csv.write('{},{},{},{},{}\\n'.format('>>>> Total Initial Wastage', iw_energy, iw_water, iw_ghg, ''))\r\n    csv.write('{},{},{},{},{}\\n'.format('>> Total Recurrent (excl. wastage)', r_energy, r_water, r_ghg, ''))\r\n    csv.write('{},{},{},{},{}\\n'.format('>>>> Total Recurrent Wastage', rw_energy, rw_water, rw_ghg, ''))\r\n    csv.write('\\n\\n')\r\n\r\n\r\ndef _write_built_asset_flow_values_to_csv(built_assets, csv):\r\n    \"\"\"\r\n    Write to a .csv file. For each build asset object, write a new section listing all of the flow values.\r\n    :param built_assets: EPiCBuiltAsset items to include in the analysis\r\n    :param csv: The csv file to write to\r\n    \"\"\"\r\n    csv.write('*** BREAKDOWN BY BUILT ASSET ***\\n\\n')\r\n    csv.write('{},{},{},{},{},{},{}\\n'.format('', 'Total Energy (MJ)', 'Total Water (L)', 'Total GHG (kgCO2e)',\r\n                                              'Qty', 'Functional Unit', 'Comments'))\r\n\r\n    for built_asset in built_assets:\r\n        built_asset_name = '<<-' + built_asset.name.replace(\",\", \".\") + '->>'\r\n        csv.write('\\n')\r\n        if built_asset.comments:\r\n            csv.write('{},{},{},{},{},{},{}\\n'.format(built_asset_name, '', '', '', '',\r\n                                                      '', built_asset.comments.replace(\",\", \".\")))\r\n        else:\r\n            csv.write(built_asset_name)\r\n\r\n        csv.write('\\n')\r\n        _write_assembly_flows_to_csv(built_asset.epic_assemblies, csv)\r\n\r\n\r\ndef _write_assembly_flow_info_to_csv(csv):\r\n    \"\"\"\r\n    Write to a .csv file. The title for the assembly section, and all column headings.\r\n    :param csv: The csv file to write to\r\n    \"\"\"\r\n    csv.write('*** BREAKDOWN BY ASSEMBLIES ***\\n\\n')\r\n    csv.write('{},{},{},{},{},{},{}\\n'.format('', 'Total Energy (MJ)', 'Total Water (L)', 'Total GHG (kgCO2e)',\r\n                                              'Qty', 'Functional Unit', 'Comments'))\r\n\r\n\r\ndef _write_assembly_flows_to_csv(assemblies, csv):\r\n    \"\"\"\r\n    Write to a .csv file. For each assembly item, write a new section listing all of the flow values, by material.\r\n    :param assemblies: EPiCAssembly items to include in the analysis\r\n    :param csv: The csv file to write to\r\n    \"\"\"\r\n    for assembly in assemblies:\r\n        if not assembly.comments:\r\n            assembly.comments = ' '\r\n        if len(assembly.selected_geometry) > 0 and assembly.total_units > 0:\r\n            if assembly.category == assembly.name: # no category has been defined\r\n                built_asset_name = \"<{} ({} {})>\".format(assembly.name.replace(\",\", \".\"),\r\n                                                                      str(assembly.total_units),\r\n                                                                      str(assembly.assembly_units))\r\n            else:\r\n                built_asset_name = \"<{} | Category: {} ({} {})>\".format(assembly.name.replace(\",\", \".\"),\r\n                                                                      assembly.category.replace(\",\", \".\"),\r\n                                                                      str(assembly.total_units),\r\n                                                                      str(assembly.assembly_units))\r\n\r\n            csv.write('{},{},{},{},{},{},{}\\n'.format(built_asset_name, '', '', '', '', '',\r\n                                                      assembly.comments.replace(\",\", \".\")))\r\n            for mat in assembly.recalculated_flows['by_material'].values():\r\n                csv.write('{},{},{},{},{},{},{}\\n'.format(mat['material_name'].replace(\",\", \".\").encode('utf-8'),\r\n                                                          '', '', '', (mat['quantity'] * assembly.total_units),\r\n                                                          mat['material_object'].functional_unit,\r\n                                                          mat['material_object'].comments))\r\n                csv.write('{},{},{},{},{}\\n'.format('>> Initial (excl. wastage)', mat['initial']['energy']\r\n                                                    - mat['initial_wastage']['energy'], mat['initial']['water']\r\n                                                    - mat['initial_wastage']['water'], mat['initial']['ghg']\r\n                                                    - mat['initial_wastage']['ghg'], ''))\r\n\r\n                if mat['initial_wastage']['energy'] > 0:\r\n                    csv.write('{},{},{},{},{}\\n'.format('>>>> Initial Wastage (' + str(\r\n                        (mat['initial_wastage']['energy'] * 100) / mat['initial']['energy']) + '%)',\r\n                                                        mat['initial_wastage']['energy'],\r\n                                                        mat['initial_wastage']['water'],\r\n                                                        mat['initial_wastage']['ghg'],\r\n                                                        ''))\r\n\r\n                if (mat['recurrent']['energy']) > 0:\r\n                    csv.write('{},{},{},{},{}\\n'.format('>> Recurrent (excl. wastage)',\r\n                                                        mat['recurrent']['energy']\r\n                                                        - mat['recurrent_wastage']['energy'],\r\n                                                        mat['recurrent']['water']\r\n                                                        - mat['recurrent_wastage']['water'],\r\n                                                        mat['recurrent']['ghg']\r\n                                                        - mat['recurrent_wastage']['ghg'], ''))\r\n\r\n                if (mat['recurrent_wastage']['energy']) > 0:\r\n                    csv.write('{},{},{},{},{}\\n'.format('>>>> Recurrent Wastage',\r\n                                                        mat['recurrent_wastage']['energy'],\r\n                                                        mat['recurrent_wastage']['water'],\r\n                                                        mat['recurrent_wastage']['ghg'], ''))\r\n            csv.write('\\n')\r\n\r\n\r\ndef _write_boq_to_csv(csv, analysis):\r\n    \"\"\"\r\n    Write to a .csv file. Sum the total quantity for each material in all of the assemblies and built assets,\r\n    :param analysis: :param analysis: EPiCAnalysis class object for calculations\r\n    :param csv: The csv file to write to\r\n    \"\"\"\r\n    boq = {}\r\n    for mat in analysis.epic_materials:\r\n        if str(mat[0].name) not in boq:\r\n            boq[mat[0].name] = {'units': mat[0].functional_unit,\r\n                                'total_units': mat[1]}\r\n        else:\r\n            boq[mat[0].name]['total_units'] += mat[1]\r\n\r\n    csv.write('*** MATERIAL BOQ *** \\n\\n')\r\n    csv.write('Material Name, Qty, Units \\n')\r\n    for x in boq:\r\n        csv.write(\r\n            '{}, {}, {} \\n'.format(x.replace(\",\", \".\").encode('utf-8'), boq[x]['total_units'],\r\n                                   boq[x]['units']))\r\n\r\n\r\nclass EPiCVisualisations:\r\n    \"\"\"\r\n    Custom geometry to be visualised in Grasshopper. This class stores all visualisation classes.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        pass\r\n\r\n    class GraphSegmentGeometry(ghKernel.Types.GH_GeometricGoo[Geometry.Rectangle3d],\r\n                               ghKernel.IGH_BakeAwareData, ghKernel.IGH_PreviewData):\r\n        def __init__(self, rect, fill_colour=COLOURS['light_teal'], outline_colour=COLOURS['dark_grey'],\r\n                     outline_thickness=1, show_hatch=False):\r\n            \"\"\"\r\n            A custom coloured rectangle that represents a graph segment within EPiCGraphColumn.\r\n            This class overrides DrawViewportWires and DrawViewportMeshes\r\n            :param rect: A Rhino 3D Rectangle Object to be used as a base object\r\n            \"\"\"\r\n\r\n            # Set the initial attributes\r\n            self.m_value = rect\r\n            self.fill_colour = fill_colour\r\n            self.outline_colour = outline_colour\r\n            self.outline_thickness = outline_thickness\r\n            self.show_hatch = show_hatch\r\n\r\n            # Create a fill and outline for the rectangle\r\n            self.poly_line = self.m_value.ToPolyline()\r\n            self.fill = Geometry.Hatch.Create(self.poly_line.ToPolylineCurve(), 0, 0, 0, 0)\r\n            self.fill = self.fill[0]\r\n\r\n        # region properties for grasshopper.\r\n        def get_TypeName(self):\r\n            return \"Graph Segment\"\r\n\r\n        def get_TypeDescription(self):\r\n            return \"Graph Segment\"\r\n\r\n        def ToString(self):\r\n            if self.m_value is None: return \"<null>\"\r\n            return 'Graph Segment'\r\n\r\n        def get_Boundingbox(self):\r\n            if self.m_value is None:\r\n                return Geometry.BoundingBox.Empty\r\n            return self.m_value.BoundingBox\r\n\r\n        def GetBoundingBox(self, xform):\r\n            if self.m_value is None:\r\n                return Geometry.BoundingBox.Empty\r\n            box = self.m_value.BoundingBox\r\n            corners = xform.TransformList(box.GetCorners())\r\n            return Geometry.BoundingBox(corners)\r\n\r\n        # region methods for grasshopper.\r\n        def DuplicateGeometry(self):\r\n            new_geometry = EPiCVisualisations.GraphSegmentGeometry(self.m_value)\r\n            new_geometry.fill_colour = self.fill_colour\r\n            new_geometry.outline_colour = self.outline_colour\r\n            new_geometry.outline_thickness = self.outline_thickness\r\n            new_geometry.show_hatch = self.show_hatch\r\n            return new_geometry\r\n\r\n        def Transform(self, xform):\r\n            rect = self.m_value\r\n            if rect is None: return EPiCVisualisations.GraphSegmentGeometry(None)\r\n\r\n            plane = rect.Plane\r\n            point = plane.PointAt(1, 1)\r\n\r\n            plane.Transform(xform)\r\n            point.Transform(xform)\r\n            dd = point.DistanceTo(plane.Origin)\r\n\r\n            new_geometry = EPiCVisualisations.GraphSegmentGeometry(\r\n                Geometry.Rectangle3d(plane, rect.Width * dd / sqrt(2), rect.Height * dd / sqrt(2)))\r\n            new_geometry.fill_colour = self.fill_colour\r\n            new_geometry.outline_colour = self.outline_colour\r\n            new_geometry.outline_thickness = self.outline_thickness\r\n            new_geometry.show_hatch = self.show_hatch\r\n            return new_geometry\r\n\r\n        def Morph(self, xmorph):\r\n            return self.DuplicateGeometry()\r\n\r\n        # region preview properties for grasshopper.\r\n        def get_ClippingBox(self):\r\n            return self.get_Boundingbox()\r\n\r\n        def DrawViewportWires(self, args):\r\n            args.Pipeline.DrawBox(self.m_value.BoundingBox, self.outline_colour, self.outline_thickness)\r\n            if self.show_hatch:\r\n                corners = self.m_value.BoundingBox.GetCorners()\r\n                args.Pipeline.DrawLine(Geometry.Line(Geometry.Point3d(corners[0]), Geometry.Point3d(corners[2])),\r\n                                       self.outline_colour)\r\n                args.Pipeline.DrawLine(Geometry.Line(Geometry.Point3d(corners[1]), Geometry.Point3d(corners[3])),\r\n                                       self.outline_colour)\r\n\r\n        def DrawViewportMeshes(self, args):\r\n            args.Pipeline.DrawHatch(self.fill, self.fill_colour, Color.Transparent)\r\n\r\n        # region baking for grasshopper.\r\n        def BakeGeometry(self, doc, att, id):\r\n            id = Guid.Empty\r\n            if self.m_value is None:\r\n                return False, id\r\n\r\n            if att is None:\r\n                att = doc.CreateDefaultAttributes()\r\n            att.ObjectColor = self.fill_colour\r\n            doc.Objects.AddRectangle(self.m_value, att)\r\n            hatch_att = doc.CreateDefaultAttributes()\r\n            hatch_att.ObjectColor = self.fill_colour\r\n            doc.Objects.AddHatch(self.fill, hatch_att)\r\n            id = doc.Objects\r\n\r\n            return True, id\r\n\r\n    @staticmethod\r\n    def bakeable_text_from_str(text, text_size=1.0, text_location=(0, 0, 0), bold=False, italic=False, font='Arial',\r\n                               text_rotation=0,\r\n                               align_right=False, align_top=False):\r\n        \"\"\"\r\n        Create bakeable text objects from string inputs\r\n        :param text: Input string\r\n        :param text_size: Size of the text, measured in Rhino units\r\n        :param text_location: Location for the text. Defaults to (0,0,0)\r\n        :param bold: If True, then the text will be bold\r\n        :param italic: If True, then the text will be italic\r\n        :param font: Font to use (default is Arial)\r\n        :param text_rotation: Rotation angle for the text (in degrees)\r\n        :param align_right: If True, then the text will be aligned to the right\r\n        :param align_top: If True, then the text will be aligned to the top\r\n        :return: EPiCText class object that can be visualised and baked from grasshopper\r\n        \"\"\"\r\n\r\n        # Create a base plane for the text\r\n        point = rs.AddPoint(*text_location)\r\n        point2 = rs.AddPoint(10, 0, 0)\r\n        point3 = rs.AddPoint(0, 10, 0)\r\n        plane = rs.CreatePlane(point, point2, point3)\r\n\r\n        # Rotate the text\r\n        if text_rotation:\r\n            plane = rs.RotatePlane(plane, text_rotation, plane.ZAxis)\r\n\r\n        # Check if text input is a string, and convert to a Text3D object\r\n        if isinstance(text, str):\r\n            text = Display.Text3d(text, plane, text_size)\r\n        elif isinstance(text, Display.Text3d):\r\n            pass\r\n        else:\r\n            raise TypeError(\"bakeable_text_from_str: text input must be string or Text3D\")\r\n\r\n        if align_right:\r\n            text_bounds_length = EPiCVisualisations.EPiCText(text).get_Boundingbox().GetEdges()[0].Length\r\n            plane = rs.MovePlane(plane, (text_location[0] - text_bounds_length, text_location[1], text_location[2]))\r\n            text = Display.Text3d(text.Text, plane, text_size)\r\n\r\n        if align_top:\r\n            text_bounds_length = EPiCVisualisations.EPiCText(text).get_Boundingbox().GetEdges()[1].Length\r\n            plane = rs.MovePlane(plane, (text_location[0], text_location[1] - text_bounds_length, text_location[2]))\r\n            text = Display.Text3d(text.Text, plane, text_size)\r\n\r\n        text.Bold = bold\r\n        text.Italic = italic\r\n        text.FontFace = font\r\n\r\n        return EPiCVisualisations.EPiCText(text)\r\n\r\n    class EPiCText(ghKernel.Types.GH_GeometricGoo[Display.Text3d],\r\n                   ghKernel.IGH_BakeAwareData,\r\n                   ghKernel.IGH_PreviewData):\r\n\r\n        \"\"\"A Text object that can be baked and transformed in Grasshopper.\r\n        The majority of the code for this class was taken from David Rutten and Giulio Piacentino's\r\n        script described here:\r\n        https://discourse.mcneel.com/t/creating-text-objects-and-outputting-them-as-normal-rhino-geometry/47834/7\"\"\"\r\n\r\n        # region construction\r\n        def __init__(self, text):\r\n            self.m_value = text\r\n\r\n        @staticmethod\r\n        def DuplicateText3d(original):\r\n            if original is None: return None\r\n            text = Display.Text3d(original.Text, original.TextPlane, original.Height)\r\n            text.Bold = original.Bold\r\n            text.Italic = original.Italic\r\n            text.FontFace = original.FontFace\r\n            return text\r\n\r\n        def DuplicateGeometry(self):\r\n            return EPiCVisualisations.EPiCText(EPiCVisualisations.EPiCText.DuplicateText3d(self.m_value))\r\n\r\n        # region properties\r\n        def get_TypeName(self):\r\n            return \"3D Text\"\r\n\r\n        def get_TypeDescription(self):\r\n            return \"3D Text\"\r\n\r\n        def ToString(self):\r\n            if self.m_value is None: return \"<null>\"\r\n            return self.m_value.Text\r\n\r\n        def get_Boundingbox(self):\r\n            if self.m_value is None:\r\n                return Geometry.BoundingBox.Empty;\r\n            return self.m_value.BoundingBox;\r\n\r\n        def GetBoundingBox(self, xform):\r\n            if self.m_value is None:\r\n                return Geometry.BoundingBox.Empty\r\n            box = self.m_value.BoundingBox\r\n            corners = xform.TransformList(box.GetCorners())\r\n            return Geometry.BoundingBox(corners)\r\n\r\n        # region methods\r\n        def Transform(self, xform):\r\n            text = EPiCVisualisations.EPiCText.DuplicateText3d(self.m_value)\r\n            text = EPiCVisualisations.EPiCText.DuplicateText3d(self.m_value)\r\n            if text is None: return EPiCVisualisations.EPiCText(None)\r\n            plane = text.TextPlane\r\n            point = plane.PointAt(1, 1)\r\n\r\n            plane.Transform(xform)\r\n            point.Transform(xform)\r\n            dd = point.DistanceTo(plane.Origin)\r\n\r\n            text.TextPlane = plane\r\n            text.Height *= dd / sqrt(2)\r\n            return EPiCVisualisations.EPiCText(text)\r\n\r\n        def Morph(self, xmorph):\r\n            return self.DuplicateGeometry()\r\n\r\n        # region preview\r\n        def get_ClippingBox(self):\r\n            return self.get_Boundingbox()\r\n\r\n        def DrawViewportWires(self, args):\r\n            if self.m_value is None: return\r\n            args.Pipeline.Draw3dText(self.m_value, args.Color)\r\n\r\n        def DrawViewportMeshes(self, args):\r\n            # Do not draw in meshing layer.\r\n            pass\r\n\r\n        # region baking\r\n        def BakeGeometry(self, doc, att, id):\r\n            id = Guid.Empty\r\n\r\n            if self.m_value is None:\r\n                return False, id\r\n\r\n            if att is None:\r\n                att = doc.CreateDefaultAttributes()\r\n\r\n            id = doc.Objects.AddText(self.m_value, att)\r\n\r\n            return True, id\r\n\r\n\r\nclass EPiCMaterial:\r\n    \"\"\"\r\n    A class object that represents a single material from the EPiC Database\r\n    \"\"\"\r\n    FUNCTIONAL_UNIT_SEP = '|'\r\n\r\n    def __init__(self, name=str, energy=float, water=float, ghg=float, functional_unit=str, doi=str, category=str,\r\n                 material_id=str, wastage=float, service_life=float, comments=str, density=float, process_shares=dict):\r\n        \"\"\"\r\n        A material class object that can be passed to EPiCAssemblies and EPiCBuiltAssets\r\n        :param name: Name of the material\r\n        :param energy: Energy coefficient in MJ/Functional Unit\r\n        :param water: Water coefficient in L/Functional Unit\r\n        :param ghg: Greenhouse gas emissions coefficient in kgCOe/Functional Unit\r\n        :param functional_unit: Functional unit for the material (e.g. kg, no., m, m, m)\r\n        :param doi: A link to the material information sheet in the EPiC Database\r\n        :param category: Material category\r\n        :param material_id: EPiCDatabase id for the material\r\n        :param wastage: Estimated wastage percentage (%) for the material.\r\n        :param service_life: Estimated service life for the material.\r\n        :param comments: Material comments - these will be displayed in any reports\r\n        :param density: Material density\r\n        :param process_shares: A dictionary with flows as keys and the process data share of the hybrid coefficient as a value\r\n        \"\"\"\r\n\r\n        self.component_type = 'EPiCMaterial'\r\n\r\n        try:\r\n            self.name = name\r\n            self.functional_unit = functional_unit\r\n            self.category = category\r\n            self.doi = doi\r\n            self.energy = energy\r\n            self.water = water\r\n            self.ghg = ghg\r\n            self.density = density\r\n            self.wastage = wastage / 100 if wastage else 0\r\n            self.service_life = service_life\r\n            self.process_shares = process_shares\r\n            self.id = random.getrandbits(128)\r\n            self.comments = remove_commas_and_flatten_list_for_csv_export(comments) if comments else ''\r\n            self.material_id = material_id\r\n\r\n        except TypeError:\r\n            raise TypeError(\"Couldn't load material attributes...\")\r\n\r\n    def __str__(self):\r\n        return self.print_report(print_to_str=True)\r\n\r\n    @staticmethod\r\n    def remove_func_unit_from_mat_name(mat_name_and_func_unit):\r\n        \"\"\"\r\n        Remove the functional unit between \"()\" after the | sign, and the space beforehand\r\n        :param mat_name_and_func_unit: the concatenated material name and its functional unit\r\n        :return: the material name cleaned up\r\n        \"\"\"\r\n        return mat_name_and_func_unit[:(mat_name_and_func_unit.index('|') - 1)]\r\n\r\n    @staticmethod\r\n    def _concatenate_mat_name_func_unit(mat_name, functional_unit):\r\n        \"\"\"\r\n        Adds the funtional unit to a material name\r\n        :param mat_name: a string represent an EPiC material name\r\n        :param functional_unit: a string representing the functional unit of the material\r\n        :return: a concatenated material_name and string\r\n        \"\"\"\r\n        return mat_name + ' ' + '|' + ' (' + functional_unit + ')'\r\n\r\n    def generate_breakdown_dict(self):\r\n        \"\"\"\r\n        Generates a dictionary that will be provided to EPiCBreakdown, as per the HYBRID_VALUE_BREAKDOWN_DICT template\r\n        :return: as dictionary representing the process and input-output shares of the hybrid value\r\n        \"\"\"\r\n        breakdown_dict = copy.deepcopy(HYBRID_VALUE_BREAKDOWN_DICT)\r\n\r\n        for flow in breakdown_dict.keys():\r\n            breakdown_dict[flow]['process'] = self.process_shares[flow]\r\n            breakdown_dict[flow]['io'] = 1 - self.process_shares[flow]\r\n\r\n        return breakdown_dict\r\n\r\n    @staticmethod\r\n    def generate_material_and_category_dropdown_list(component_object, ghenv, epic_db,\r\n                                                     category=\"Concrete and plaster products\"):\r\n        \"\"\"\r\n        Generate a material and category list for the EPiC_Material grasshopper component\r\n        :param component_object: Component object to modify\r\n        :param ghenv: The current grasshopper environment\r\n        :param epic_db: EPiCDatabase object to query\r\n        :param category: Default category to be used for initialising the valuelist\r\n        \"\"\"\r\n\r\n        # Check if input[1] has a value list connected, if not, create one\r\n        if component_object.Params.Input[1].SourceCount == 0:\r\n            make_value_list_input_component(1, EPIC_CATEGORIES, ghenv, xloc=-230, yloc=0)\r\n\r\n        # Check if input[2] has a value list connected, if not, create one, but only if input[1] is connected.\r\n        if component_object.Params.Input[1].SourceCount == 1 and component_object.Params.Input[2].SourceCount == 0:\r\n\r\n            list_of_mat_values, list_of_mat_names = (zip(*sorted(epic_db.dict_of_categories[category].items())))\r\n\r\n            # Use the category created above (input[1]) to generate material list. Set the category to concrete.\r\n            make_value_list_input_component(2, list_of_mat_values, ghenv,\r\n                                            valuelist_names = list_of_mat_names, xloc=-365, yloc=0)\r\n            ghenv.Component.OnPingDocument().ScheduleSolution(5, ghenv.Component.ExpireSolution(True))\r\n\r\n    @staticmethod\r\n    def generate_slider_input(component_object, ghenv, slider_value, input_node, slider_min = 0, slider_max = 100):\r\n        \"\"\"\r\n        Generate a slider input attached to the current component object\r\n        :param component_object: Component object to modify\r\n        :param ghenv: The current grasshopper environment (not used)\r\n        :param slider_value: value to set for the slider\r\n        :param input_node: node number that the slider should be instantiated on\r\n        :param slider_min: minimum value for the slider\r\n        :param slider_max: maximum value for the slider\r\n        \"\"\"\r\n\r\n        # Check if input has a slider connected\r\n        if component_object.Params.Input[input_node].SourceCount == 0:\r\n\r\n            num_slider = EPiCMaterial.create_slider(component_object, input_node, slider_max, slider_min, slider_value)\r\n\r\n            # Connect slider to component\r\n            component_object.Params.Input[input_node].AddSource(num_slider)\r\n\r\n            # Expire the solution outside of current loop to refresh values\r\n            component_object.OnPingDocument().ScheduleSolution(1, component_object.ExpireSolution(False))\r\n\r\n            return str(num_slider.InstanceGuid)\r\n        else:\r\n            pass\r\n\r\n    @staticmethod\r\n    def create_slider(component_object, input_node, slider_max, slider_min, slider_value):\r\n        ghdoc = component_object.OnPingDocument()\r\n        num_slider = ghKernel.Special.GH_NumberSlider()\r\n        num_slider.Slider.Minimum = slider_min\r\n        # Check if the proposed slider value is more than the slider max value. If so, increase the max value.\r\n        if slider_value > slider_max:\r\n            num_slider.Slider.Maximum = slider_value\r\n        else:\r\n            num_slider.Slider.Maximum = slider_max\r\n        num_slider.Slider.DecimalPlaces = 0\r\n        num_slider.SetSliderValue(slider_value)\r\n        num_slider.CreateAttributes()\r\n        num_slider.Attributes.Pivot = Drawing.PointF(component_object.Params.Input[input_node].Attributes.Bounds.X\r\n                                                     - num_slider.Attributes.Bounds.Width * 2,\r\n                                                     component_object.Params.Input[input_node].Attributes.Bounds.Y)\r\n        ghdoc.AddObject(num_slider, False)\r\n        return num_slider\r\n\r\n    @staticmethod\r\n    def recreate_material_list(epic_db, ghObject, material_category, component, set_material=None):\r\n        \"\"\"\r\n        Recreate the material list based on the currently selected material category\r\n        :param epic_db: EPiCDatabase object\r\n        :param ghObject: Grasshopper component\r\n        :param material_category: Currently selected material category\r\n        :param Params: The component parameters, this is needed to recreate the input values\r\n        :pamam set_material: Specify the chosen material for the new list\r\n        \"\"\"\r\n\r\n        # Create a sticky that makes sure itemlist won't continuously load\r\n        if not \"is_running\" in st.keys():\r\n            st[\"is_running\"] = False\r\n\r\n        # Check if the sticky is 0 (and therefore the list isn't in the middle of initialising)\r\n        if st[\"is_running\"] == False:\r\n            try:\r\n                # set the running to true at the start of the function, indicating that it is in progress\r\n                st[\"is_running\"] = True\r\n                new_list = zip(*sorted(epic_db.dict_of_categories[material_category].items()))\r\n                ghObject.ListItems.Clear()\r\n                selected_material = 0\r\n                list_number = 0\r\n                for id, name in zip(new_list[0], new_list[1]):\r\n                    _ = ghObject.ListItems.Add(ghKernel.Special.GH_ValueListItem(str(name), '\"' + str(id) + '\"'))\r\n                    if set_material and set_material == id:\r\n                        selected_material = list_number\r\n                    list_number += 1\r\n\r\n                # Select the chosen material\r\n                if selected_material:\r\n                    ghObject.SelectItem(selected_material)\r\n\r\n                # Expire the current solution\r\n                component.OnPingDocument().ScheduleSolution(5, ghObject.ExpireSolution(True))\r\n                st[\"is_running\"] = False\r\n            except:\r\n                # If the list loading fails, global running value will be reset\r\n                st[\"is_running\"] = False\r\n\r\n\r\n    def print_report(self, print_to_str=False, custom_material=False):\r\n        \"\"\"\r\n        Print a report, based on the material coefficient values and material attributes\r\n        :param print_to_str: Print to string should be marked as true when outputting as a string, otherwise a list\r\n        :param custom_material: switch to true to omit printing the DOI as a custom material won't have one\r\n        :return: string(print_to_str=True) or list\r\n        \"\"\"\r\n\r\n        results = []\r\n        results.append('<< {} >>'.format(self.name))\r\n        results.append('Category: {}'.format(self.category))\r\n        results.append('Functional Unit: {}'.format(self.functional_unit))\r\n        results.append('')\r\n        results.append('Embodied Energy Coefficient: {} MJ/{}'.format(self.energy, self.functional_unit))\r\n        results.append('Embodied Water Coefficient: {} L/{}'.format(self.water, self.functional_unit))\r\n        results.append('Embodied GHG Coefficient: {} kgCOe/{}'.format(self.ghg, self.functional_unit))\r\n\r\n        # Only include wastage / service life in the report if values exist\r\n        if self.wastage > 0 or self.service_life > 0:\r\n            results.append('')\r\n            if self.wastage > 0:\r\n                results.append('Wastage: {}%'.format(self.wastage * 100))\r\n            if self.service_life > 0:\r\n                results.append('Service Life: {} years'.format(self.service_life))\r\n\r\n        results.append('')\r\n        if not custom_material:\r\n            results.append('DOI: {}'.format(self.doi))\r\n            results.append('')\r\n            results.append('Process-based data proportion of hybrid value')\r\n            for flow_properties in DEFINED_FLOWS.values():\r\n                results.append(flow_properties['print_name'] + ': {:.0%}'.format(\r\n                    self.process_shares[flow_properties['code_name']]))\r\n\r\n        return results if not print_to_str else '\\n'.join(results)\r\n\r\n\r\nclass CustomMaterial(EPiCMaterial):\r\n    \"\"\"\r\n    A class object that represents a single custom material, based on the EPiCMaterial template\r\n    \"\"\"\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        EPiCMaterial.__init__(self, *args, **kwargs)\r\n\r\n    def __str__(self):\r\n        return self.print_report(print_to_str=True, custom_material=True)\r\n\r\n\r\nclass EPiCGraph:\r\n    \"\"\"\r\n    Enables the visualisation of EPiC_Analysis, using data from associated EPiC_Assembly & EPiC_Material classes\r\n    \"\"\"\r\n\r\n    seg_pref_template = OrderedDict([\r\n        ('initial', {'flow_type': ['initial', 'initial_wastage'], 'colour': 'colour',\r\n                     'label': 'Initial', 'hatch_type': 0, 'hatch_scale': 0.5,\r\n                     'hatch_angle': 45}),\r\n        ('initial_wastage', {'flow_type': 'initial_wastage', 'colour': 'colour',\r\n                             'label': 'Initial wastage', 'hatch_type': 1, 'hatch_scale': 1,\r\n                             'hatch_angle': 135}),\r\n        ('recurrent', {'flow_type': ['recurrent', 'recurrent_wastage'],\r\n                       'colour': 'secondary_colour', 'label': 'Recurrent', 'hatch_type': 0,\r\n                       'hatch_scale': 0.5, 'hatch_angle': 45}),\r\n        ('recurrent_wastage', {'flow_type': 'recurrent_wastage',\r\n                               'colour': 'secondary_colour', 'label': 'Recurrent wastage',\r\n                               'hatch_type': 1, 'hatch_scale': 1, 'hatch_angle': 135}),\r\n        ('life_cycle', {'flow_type': ['life_cycle', 'life_cycle_wastage'],\r\n                        'colour': 'colour', 'label': 'Life cycle', 'hatch_type': 0,\r\n                        'hatch_scale': 0.5, 'hatch_angle': 45}),\r\n        ('life_cycle_wastage', {'flow_type': 'life_cycle_wastage', 'colour': 'colour',\r\n                                'label': 'Life cycle wastage', 'hatch_type': 1,\r\n                                'hatch_scale': 1, 'hatch_angle': 135})])\r\n\r\n    def __init__(self, data, graph_origin=(0, 0, 0), graph_height=10., graph_spacing=1., graph_width=1.,\r\n                 graph_padding=6, analysis_type='by_material', graph_subset_2=None, show_recurrent=True,\r\n                 flows=('energy', 'water', 'ghg'), sort_graph=True, graph_scale=1, column_width=0.7,\r\n                 column_padding=0.2, space_between_graphs=5, hide_null_columns=True, minimum_spacing_for_graph=3,\r\n                 text_size=0.3, heading_text_size=0.8, axis_label_text_size=0.65, tick_size=0.2, text_padding=0.3,\r\n                 legend_box_size=0.5):\r\n\r\n        # Set all instance attributes based on inputs\r\n        vars = locals()  # dict of local names\r\n        self.__dict__.update(vars)  # __dict__ holds and object's attributes\r\n        del self.__dict__[\"self\"]  # don't need `self`\r\n\r\n        # Make sure origin is either a tuple or Rhino Point3d object.\r\n        # If origin is a tuple, convert to Point3d Object.\r\n        if isinstance(graph_origin, tuple):\r\n            self.origin = Geometry.Point3d(graph_origin[0], graph_origin[1], graph_origin[2])\r\n        elif isinstance(graph_origin, (Geometry.Point, Geometry.Point3d)):\r\n            self.origin = graph_origin\r\n        else:\r\n            TypeError('The origin_point should be a tuple, eg (0,0,0) or a 3dPoint value')\r\n\r\n        # only allow 'by_material' and 'analysis_type' as input for analysis_type.\r\n        # All other values will default to 'total' (analysis_type = None)\r\n        if 'by_material' not in analysis_type and 'by_assembly' not in analysis_type:\r\n            analysis_type = None\r\n        self.analysis_type = analysis_type\r\n\r\n        # Make sure data input is in list format\r\n        if not isinstance(data, list):\r\n            data = [data]\r\n        self.data = data\r\n\r\n        # Number of comparison values for the graph\r\n        self.num_comparisons = len(data)\r\n\r\n        # Cycle through all of the materials to branch_count the number of unique materials\r\n        _all_materials = _flatten_list([y.epic_materials for x in self.data for y in x.epic_assemblies])\r\n        self.number_of_materials = len(set([x for x in _all_materials if not isinstance(x, (float, int))]))\r\n\r\n        # Cycle through all of the assemblies to branch_count the number of unique assembly categories\r\n        self.number_assembly_cats = len(set(_flatten_list([x.epic_assemblies for x in self.data])))\r\n\r\n        # Set additional instance attributes\r\n        self.graph_subset_2_colours = {}\r\n\r\n        # Generate graphs\r\n        self.graph_data = self._create_bar_graph_for_each_flow(self.data, analysis_type=analysis_type,\r\n                                                               show_recurrent=show_recurrent)\r\n\r\n    @property\r\n    def elements_to_render(self):\r\n        \"\"\"\r\n        A list of graph elements (legend, text, columns) to visualise\r\n        :return: List of graph elements\r\n        \"\"\"\r\n        graph_elements = _flatten_list([graph.elements_to_render for graph in self.graph_data])\r\n\r\n\r\n        # Print error message if no values are found\r\n        if not graph_elements:\r\n            # Specific an offset value for the error message text.\r\n            graph_offset = (1, 5, 0)\r\n            text_origin = tuple(sum(x) for x in zip(self.graph_origin, graph_offset))\r\n            error_msg = \"No bar chart can be displayed.\\nIt is likely that all embodied flows have zero values.\"\\\r\n                        \"\\nOR there has been a calculation error.\\nCheck your assembly quantities.\"\r\n            graph_elements = EPiCVisualisations.bakeable_text_from_str(error_msg,\r\n                                                      text_size=self.heading_text_size,\r\n                                                      text_location=text_origin)\r\n\r\n        if self.graph_scale != 1:\r\n            graph_elements = self._scale_graph_elements(graph_elements)\r\n\r\n        return graph_elements\r\n\r\n    def _scale_graph_elements(self, graph_elements):\r\n        \"\"\"\r\n        Scale graph elements\r\n        :param graph_elements: Graph elements to scale\r\n        :return: Scaled graph elements\r\n        :rtype: list\r\n        \"\"\"\r\n        self.graph_scale = [self.graph_scale, self.graph_scale, 0]\r\n        scaled_elements = []\r\n        for graph_element in graph_elements:\r\n            if isinstance(graph_element, Geometry.Line):\r\n                transform = False\r\n                try:\r\n                    transform = graph_element.Transform(rs.XformScale(self.graph_scale, self.origin))\r\n                except:\r\n                    pass\r\n                if transform:\r\n                    scaled_elements.append(graph_element)\r\n\r\n            elif isinstance(graph_element, (EPiCVisualisations.EPiCText, EPiCVisualisations.GraphSegmentGeometry)):\r\n                try:\r\n                    scaled_elements.append(graph_element.Transform(rs.XformScale(self.graph_scale, self.origin)))\r\n                except:\r\n                    pass\r\n        return scaled_elements\r\n\r\n    def _create_bar_graph_for_each_flow(self, data, analysis_type=None, show_recurrent=True):\r\n        \"\"\"\r\n        Create a separate bar graph for each flow (energy, water and ghg)\r\n        :param data: Graph data\r\n        :param analysis_type: The type of built_assets to use for each graph (e.g. by_material, by_assembly, total)\r\n        :param show_recurrent: Show breakdown of recurrent values\r\n        :return: A list of epic.BarGraph object instances, one for each flow.\r\n        \"\"\"\r\n\r\n        list_of_graphs = []\r\n        graph_cumulative_width = 0\r\n        sub_group_data = None\r\n        graph_origin_point = Geometry.Point3d(self.origin.X, self.origin.Y, self.origin.Z)\r\n\r\n        # Change graph visualisation style depending if breakdown of recurrent values is shown\r\n        if show_recurrent:\r\n            list_of_keys = ['initial', 'initial_wastage', 'recurrent', 'recurrent_wastage']\r\n        else:\r\n            list_of_keys = ['life_cycle', 'life_cycle_wastage']\r\n\r\n        # Create a list of the stacked bar segments to be shown\r\n        self.segment_properties = OrderedDict((key, copy.deepcopy(value)) for (key, value)\r\n                                              in self.seg_pref_template.items() if key in list_of_keys)\r\n\r\n        # Multiple graph values can be included for comparison\r\n        for num, d in enumerate(data):\r\n            pass\r\n\r\n        # if the analysis_type is 'by_material' or 'by_assembly'\r\n        if analysis_type == 'by_material' or analysis_type == 'by_assembly':\r\n            if isinstance(data, list):\r\n                data = [d.flows[analysis_type] if analysis_type in d.flows else {d.name: d.flows} for d in data]\r\n\r\n        # if the analysis_type is 'by_assembly_and_material'\r\n\r\n        elif analysis_type == 'by_assembly_and_material':\r\n            if isinstance(data, list):\r\n                if len(data) > 1:\r\n                    sub_group_data = [\r\n                        (d.flows['by_assembly'], d.name) if 'by_assembly' in d.flows else {d.name: d.flows}\r\n                        for d in data]\r\n                data = [d.flows['by_assembly'] if 'by_assembly' in d.flows else {d.name: d.flows} for d in data]\r\n\r\n        # if the analysis_type is 'total'\r\n        else:\r\n            if isinstance(data, list):\r\n                data = [{'total': data.flows} for data in data]\r\n\r\n        # For each flow, create a new graph_origin point (based on the graph width + spacing)\r\n        for flow_num, flow in enumerate(self.flows):\r\n            # Set the graph_origin point\r\n            graph_origin_point.X += graph_cumulative_width\r\n\r\n            # Create a graph for each flow\r\n            epic_graph = EPiCGraph.BarGraph(data,\r\n                                            sub_group_data=sub_group_data,\r\n                                            graph_preferences=self,\r\n                                            origin=graph_origin_point,\r\n                                            name=flow,\r\n                                            flow=flow,\r\n                                            flow_units=DEFINED_FLOWS[flow]['unit'],\r\n                                            title=DEFINED_FLOWS[flow]['print_name'])\r\n            list_of_graphs.append(epic_graph)\r\n\r\n            # Move the graph_origin point for the next flow\r\n            graph_cumulative_width = self.graph_width\r\n\r\n        return list_of_graphs\r\n\r\n    class BarGraph:\r\n        def __init__(self, data, sub_group_data=None, graph_preferences=None, origin=Geometry.Point3d(0, 0, 0), name='',\r\n                     flow='', title='', flow_units=''):\r\n            \"\"\"\r\n            A bar graph based on an EPiCAnalysis class object\r\n            :param data: Flow data for each EPiCAnalysis input, if multiple inputs, these will be used as a comparison\r\n            :param graph_preferences: Graph preferences inherited from the EPiCGraph class instance\r\n            :param origin: Origin point for the bar graph\r\n            :param name: Name of the bar graph (environmental flow abbreviation)\r\n            :param flow: Enironmental flow type\r\n            :param title: Title of the bar graph (environmental flow)\r\n            :param flow_units: Flow units used for the bar graph\r\n            \"\"\"\r\n\r\n            self.data = data\r\n            self.sub_group_data = sub_group_data\r\n            self.graph_preferences = graph_preferences\r\n            self.origin = origin\r\n            self.name = name\r\n            self.flow = flow\r\n            self.title = title\r\n            self.flow_units = flow_units\r\n\r\n            # Set the graph origin plane based on the graph origin\r\n            if isinstance(origin, tuple):\r\n                self.origin = Geometry.Point3d(origin[0], origin[1], origin[2])\r\n            elif isinstance(origin, (Geometry.Point, Geometry.Point3d)):\r\n                self.origin = Geometry.Point3d(origin.X, origin.Y, origin.Z)\r\n            else:\r\n                TypeError('The origin_point should be a tuple, eg (0,0,0) or a 3dPoint value')\r\n            self.origin_plane = rs.MovePlane(rs.WorldXYPlane(), self.origin)\r\n\r\n            # Attributes used in graph creation process\r\n            self.max_data_value = 0\r\n            self.legend = None\r\n            self.columns = []\r\n            self.column_group_names = OrderedDict()\r\n            self.cumulative_column_spacing = 0\r\n\r\n            # Build the bar graph\r\n            self.build_graph()\r\n\r\n            # Create a list of all visualisation elements for the graph\r\n            self.elements_to_render = self._render_elements()\r\n\r\n        def _render_elements(self):\r\n            \"\"\"\r\n            Create a list of all visualisation elements for the graph.\r\n            These are taken from the individual graph segments and graph legend\r\n            :return: a flattened list of elements to render\r\n            :rtype: list\r\n            \"\"\"\r\n            _items_to_render = {'graph': [], 'legend': {}}\r\n            if self.legend:\r\n                _items_to_render['legend'] = [y for y in [x for x in self.legend.elements_to_render.values()]]\r\n            if self.segments:\r\n                _items_to_render['graph'] = [seg.elements_to_render for seg in self.segments]\r\n            return _flatten_list(_items_to_render['legend'] + _items_to_render['graph'])\r\n\r\n        @property\r\n        def segments(self):\r\n            \"\"\"\r\n            A list of segment items for the graph\r\n            :rtype: list\r\n            \"\"\"\r\n            segs = []\r\n            if self.columns:\r\n                for col in self.columns:\r\n                    segs += col.segments\r\n            return segs\r\n\r\n        def _get_max_values(self):\r\n            \"\"\"\r\n            Get the maximum life_cycle value for this flow.\r\n            This can be used to set the maximum y axis value for the graph\r\n            :return: Maximum life cycle value\r\n            :rtype: float\r\n            \"\"\"\r\n            for _data in self.data:\r\n                for _mat in _data.values():\r\n                    if 'life_cycle' in _mat:\r\n                        max_data_value = max([_mat['life_cycle'][self.flow]])\r\n                        self.max_data_value = max(max_data_value, self.max_data_value)\r\n            return self.max_data_value\r\n\r\n        def build_graph(self):\r\n            \"\"\"\r\n            Generate a new graph.\r\n            This will override graphs already created in this class instance\r\n            \"\"\"\r\n\r\n            self.cumulative_column_spacing = 0\r\n            column_origin_plane = self.origin_plane.Clone()\r\n\r\n            # Delete previous class instances\r\n            for _col in self.columns:\r\n                del _col\r\n            self.columns = []\r\n\r\n            # Get the unique names of each column (in both the original graph + comparison graphs)\r\n            # If the graph has more than one column, the following code will run\r\n            if self.graph_preferences.analysis_type:\r\n\r\n                all_keys = list(set([key for d in self.data for key in d.keys()]))\r\n                self.max_data_value = self._get_max_values()\r\n\r\n                # Populate dictionary with life cycle flow values, based on column keys\r\n                # Then rank the columns from highest life cycle value to lowest.\r\n                dictionary_of_column_flow_values = self._get_life_cycle_flow_values_for_column_keys(all_keys)\r\n                self.column_group_names = self._sort_dictionary_highest_to_lowest_value(\r\n                    dictionary_of_column_flow_values)\r\n\r\n            else:\r\n                if isinstance(self.data, list):\r\n                    for _ in self.data:\r\n                        self.column_group_names = {'Total': {'group_label_origin': None}}\r\n                        self.max_data_value = self._get_max_values()\r\n\r\n            # Create the column groups. Each group might multiple columns (comparison values)\r\n            for num, key in enumerate(self.column_group_names.keys()):\r\n                self._create_column_group(self.data, column_origin_plane, key, num, sub_group=self.sub_group_data)\r\n\r\n            # Delete previous class instances\r\n            del self.legend\r\n\r\n            # Create a legend for the graph\r\n            self.legend = EPiCGraph.BarGraphLegend(self, graph_preferences=self.graph_preferences)\r\n\r\n        def _create_column_group(self, group_data, column_origin_plane, column_group_name, column_number_in_group,\r\n                                 sub_group=False, show_group_name=True):\r\n            \"\"\"\r\n            Create a bar graph column group (can contain subgroups and multiple bars)\r\n            :param group_data: data used to create the group of columns\r\n            :param column_origin_plane: Origin plane for the column\r\n            :param column_group_name: Name of the column group (this group might contain multiple columns)\r\n            :param column_number_in_group: The order number in the column group. 0=First\r\n            :param sub_group: data used to create a sub_group\r\n            :param show_group_name: toggle for group name labels\r\n            \"\"\"\r\n\r\n            # Condition for displaying the group column name\r\n            if len(group_data) == 1 and self.graph_preferences.analysis_type != 'by_assembly_and_material':\r\n                show_group_name = False\r\n\r\n            # Condition for displaying sub-graphs\r\n            if sub_group:\r\n                group_data = sub_group\r\n\r\n            # Create a column for each data point\r\n            for column_number, data in enumerate(group_data):\r\n                count = 0\r\n\r\n                column_name = self._set_column_name(column_group_name, column_number, group_data)\r\n                column_data, sub_group_name = self._extract_column_data(column_group_name, data, sub_group)\r\n\r\n                # If hide_null_columns set to True, only show column if flow data > 0\r\n\r\n                if self.graph_preferences.hide_null_columns:\r\n                    if not column_data or column_data['life_cycle'][self.flow] == 0:\r\n                        continue\r\n\r\n                if self.graph_preferences.analysis_type == \"by_assembly_and_material\":\r\n                    if column_data:\r\n                        if self.graph_preferences.hide_null_columns:\r\n                            columns = {key: mat for key, mat in column_data['by_material'].items()\r\n                                       if mat['life_cycle'][self.flow] != 0}\r\n                        else:\r\n                            columns = column_data['by_material']\r\n                        for key, mat in columns.items():\r\n\r\n                            # Create location values for the legend labels.\r\n                            # These are only needed when creating group labels\r\n                            if show_group_name:\r\n                                self._create_legend_attributes(column_group_name, column_number_in_group,\r\n                                                               column_origin_plane, sub_group_name=sub_group_name)\r\n\r\n                            # Create a BarGraphColumn object\r\n                            self._create_column(mat, column_number_in_group, column_origin_plane,\r\n                                                column_name=key, show_group_name=show_group_name, sub_group_count=count)\r\n\r\n                else:\r\n                    if column_data:\r\n\r\n                        # Create location values for the legend labels.\r\n                        # These are only needed when creating group labels\r\n                        if show_group_name:\r\n                            self._create_legend_attributes(column_group_name, column_number_in_group,\r\n                                                           column_origin_plane, sub_group_name=sub_group_name)\r\n\r\n                        # Create a BarGraphColumn object\r\n                        self._create_column(column_data, column_number_in_group, column_origin_plane,\r\n                                            column_name=column_name, show_group_name=show_group_name)\r\n\r\n        def _set_column_name(self, column_group_name, column_number, group_data):\r\n            \"\"\"\r\n            Set the column name, according to the number of data inputs and analysis type selected\r\n            :param column_group_name: The name of the column group\r\n            :param column_number: The column number, in the current column group\r\n            :param group_data: The column group data\r\n            :return: Name of the column\r\n            :rtype: str\r\n            \"\"\"\r\n            column_name = str(self.graph_preferences.data[column_number].name)\r\n\r\n            # Condition where there are no comparison bars\r\n            if len(group_data) == 1:\r\n                if self.graph_preferences.analysis_type == 'by_material':\r\n                    column_name = column_group_name\r\n\r\n                elif self.graph_preferences.analysis_type == 'by_assembly':\r\n                    column_name = column_group_name\r\n\r\n                elif not self.graph_preferences.analysis_type:\r\n                    column_name = 'Total'\r\n\r\n            return column_name\r\n\r\n        def _extract_column_data(self, column_group_name, data, sub_group):\r\n            \"\"\"\r\n            Extract the column data, depending on the analysis type\r\n            :param column_group_name: The name of the column group\r\n            :param data: Data to extract the column data from\r\n            :param sub_group: Data used to create a sub_group\r\n            :return: The column data and subgroup name (if used, otherwise None)\r\n            \"\"\"\r\n\r\n            sub_group_name = None\r\n\r\n            if sub_group:\r\n                if column_group_name in data[0]:\r\n                    column_data = data[0][column_group_name]\r\n                    sub_group_name = data[1]\r\n                else:\r\n                    column_data = None\r\n                    sub_group_name = None\r\n\r\n            elif self.graph_preferences.analysis_type in ['by_material', 'by_assembly', 'by_assembly_and_material']:\r\n                if column_group_name in data:\r\n                    column_data = data[column_group_name]\r\n                else:\r\n                    column_data = None\r\n\r\n            else:\r\n                if 'life_cycle' not in data:  # When 'total' value is used to generate graph\r\n                    _temp_val = data[list(data.keys())[0]]\r\n                    if 'life_cycle' in _temp_val:\r\n                        column_data = _temp_val\r\n                    else:\r\n                        column_data = None\r\n                else:\r\n                    column_data = data\r\n            return column_data, sub_group_name\r\n\r\n        def _create_column(self, column_data, column_number_in_group, column_origin_plane,\r\n                           column_name='', show_group_name=True, sub_group_count=0):\r\n            \"\"\"\r\n            Create a BarGraphColumn that represents a column in EPiCGraph\r\n            :param column_data: Data used to generate the column\r\n            :param column_number_in_group: The column number - based on the current column group\r\n            :param column_origin_plane: Origin plane for the column\r\n            :param column_name: Name of the column\r\n            :param show_group_name: Show group name if True\r\n            :param sub_group_count:\r\n            \"\"\"\r\n            graph_spacing = self.graph_preferences.graph_spacing\r\n\r\n            # Move the column origin plane, based on the column number, graph spacing and sub-group count\r\n            column_origin_plane = self._move_column_origin_plane(column_number_in_group, column_origin_plane,\r\n                                                                 graph_spacing, sub_group_count)\r\n\r\n            # If needed, increase the graph_width to make sure it fits all of the data\r\n            self.graph_preferences.graph_width = max(self.graph_preferences.graph_width,\r\n                                                     ((graph_spacing * column_number_in_group)\r\n                                                      + self.cumulative_column_spacing\r\n                                                      + self.graph_preferences.space_between_graphs))\r\n            # Generate Column\r\n            graph_column = EPiCGraph.BarGraphColumn(column_data,\r\n                                                    graph_preferences=self.graph_preferences,\r\n                                                    name=column_name,\r\n                                                    column_group_name=column_number_in_group,\r\n                                                    origin_plane=column_origin_plane,\r\n                                                    flow=self.flow,\r\n                                                    max_data_value=self.max_data_value,\r\n                                                    show_group_name=show_group_name\r\n                                                    )\r\n            self.columns.append(graph_column)\r\n\r\n        def _create_legend_attributes(self, column_group_name, column_number_in_group, column_origin_plane,\r\n                                      sub_group_name=False):\r\n            \"\"\"\r\n            Based on the column group - create attributes used to generate the graph legend.\r\n            This includes location of break line (above group column name) for graph visualisation\r\n            :param column_group_name: Column group name\r\n            :param column_number_in_group: The column number, in the current column group 0=First\r\n            :param column_origin_plane: Column origin plane\r\n            \"\"\"\r\n\r\n            # Attributes are stored in the self.column_group_names dictionary\r\n            attributes = self.column_group_names[column_group_name]\r\n\r\n            if sub_group_name:\r\n                # Populate the group attributes\r\n                self._populate_attributes(attributes, column_number_in_group, column_origin_plane)\r\n\r\n                # Populate the sub-group attributes\r\n                _att = self.column_group_names[column_group_name]\r\n                if 'sub_group' not in _att:\r\n                    _att['sub_group'] = {}\r\n                if sub_group_name not in _att['sub_group']:\r\n                    _att['sub_group'][sub_group_name] = {}\r\n                attributes = _att['sub_group'][sub_group_name]\r\n                self._populate_attributes(attributes, column_number_in_group, column_origin_plane)\r\n            else:\r\n                self._populate_attributes(attributes, column_number_in_group, column_origin_plane)\r\n\r\n        def _populate_attributes(self, attributes, column_number_in_group, column_origin_plane):\r\n            \"\"\"\r\n            Populate the column attributes - these are used to calculate the location of the text for the legend\r\n            :param attributes: Attributes dictionary to populate\r\n            :param column_number_in_group: The column number, in the current column group 0=First\r\n            :param column_origin_plane: Column origin plane\r\n            \"\"\"\r\n\r\n            # Retrieve preferences from parent EPiCGraph class\r\n            prefs = self.graph_preferences\r\n            graph_spacing = prefs.graph_spacing\r\n\r\n            # If label hasn't been created, generate the base attributes\r\n            if 'group_label_origin_x_line_start' not in attributes:\r\n                x_axis_value_for_column_group_line_start = self.origin.X + (graph_spacing * column_number_in_group) \\\r\n                                                           + self.cumulative_column_spacing + graph_spacing\r\n                attributes['group_label_origin_x_line_start'] = x_axis_value_for_column_group_line_start\r\n                attributes['group_label_origin_y'] = column_origin_plane.OriginY\r\n                attributes['group_label_origin_z'] = column_origin_plane.OriginZ\r\n                attributes['number_of_columns_in_group'] = 1\r\n\r\n            # If label already exists, increase the 'number of columns' counter\r\n            else:\r\n                attributes['number_of_columns_in_group'] += 1\r\n            centre_text = (prefs.column_padding * 2) + ((prefs.column_width + prefs.column_padding) / 2\r\n                                                        * (attributes['number_of_columns_in_group'] - 1))\r\n            end_text = (prefs.column_padding * 3) + ((prefs.column_width + prefs.column_padding)\r\n                                                     * (attributes['number_of_columns_in_group'] - 1))\r\n            attributes['group_label_origin_x_line_end'] = attributes['group_label_origin_x_line_start'] + end_text\r\n            attributes['group_label_origin_x'] = attributes['group_label_origin_x_line_start'] + centre_text\r\n\r\n        @staticmethod\r\n        def _sort_dictionary_highest_to_lowest_value(dictionary_to_rank):\r\n            \"\"\"\r\n            Sort dictionary based on it's values.\r\n            Rank from highest to lowest.\r\n            :param dictionary_to_rank: dictionary to rank, with float for value\r\n            :return: New sorted dictionary\r\n            :rtype: OrderedDict\r\n            \"\"\"\r\n\r\n            ranked_dictionary = OrderedDict()\r\n            while len(dictionary_to_rank) > 0:\r\n                max_key = max(dictionary_to_rank, key=dictionary_to_rank.get)\r\n                ranked_dictionary[max_key] = {'max_value': dictionary_to_rank.pop(max_key), 'group_label_origin': None}\r\n            return ranked_dictionary\r\n\r\n        def _get_life_cycle_flow_values_for_column_keys(self, column_keys):\r\n            \"\"\"\r\n            Get life cycle flow values based on column keys. Values are collected from self.data\r\n            Values must be above 0.\r\n            :param column_keys: List of column keys\r\n            :return: Dictionary with keys based on input list, and associated life cycle flow values\r\n            :rtype: dict\r\n            \"\"\"\r\n\r\n            column_values = {}\r\n            for column_key in column_keys:\r\n                column_values[column_key] = 0\r\n                for d in self.data:\r\n                    try:\r\n                        if d[column_key]['life_cycle'][self.flow] > column_values[column_key]:\r\n                            column_values[column_key] = d[column_key]['life_cycle'][self.flow]\r\n                    except KeyError:  # Condition when comparison graph has different column names.\r\n                        pass\r\n            return column_values\r\n\r\n        def _move_column_origin_plane(self, column_number_in_column_group, column_origin_plane, graph_spacing,\r\n                                      sub_group_count=0):\r\n            \"\"\"\r\n            Move the column origin plane based on the column number (in the column group) and graph spacing\r\n            :param column_number_in_column_group: Column number in the column group (0=First column of the group)\r\n            :param column_origin_plane: Previous column origin plane\r\n            :param graph_spacing: Graph spacing\r\n            :return: Origin plane, moved to the new location\r\n            \"\"\"\r\n\r\n            self.cumulative_column_spacing += \\\r\n                (self.graph_preferences.column_padding + self.graph_preferences.column_width)\r\n            x_axis_origin = self.origin.X + (graph_spacing * column_number_in_column_group) \\\r\n                            + (sub_group_count * column_number_in_column_group) + self.cumulative_column_spacing\r\n            column_origin_plane.OriginX = x_axis_origin\r\n            return column_origin_plane\r\n\r\n    class BarGraphColumn:\r\n        def __init__(self, data, graph_preferences=None, name='', origin_plane=rs.WorldXYPlane(), flow='',\r\n                     max_data_value=0, column_group_name='', show_group_name=False):\r\n            \"\"\"\r\n            A bar graph column element (inside BarGraph())\r\n            :param data: Bar graph data\r\n            :param graph_preferences: Graph preferences inherited from the EPiCGraph class instance\r\n            :param name: Name of the column\r\n            :param origin_plane: Origin plane for the column\r\n            :param flow: Enironmental flow type\r\n            :param max_data_value: the highest life cycle data value in the flow (sets the y-axis)\r\n            :param column_group_name: Name of the column group\r\n            \"\"\"\r\n\r\n            self.data = data\r\n            self.graph_preferences = graph_preferences\r\n            self.name = name\r\n            self.origin_plane = origin_plane\r\n            self.flow = flow\r\n            self.max_data_value = max_data_value\r\n            self.column_group_name = column_group_name\r\n            self.show_group_name = show_group_name\r\n\r\n            # Set the column attributes\r\n            self.segments = []\r\n            self.origin = Geometry.Point3d(origin_plane.OriginX, origin_plane.OriginY, origin_plane.OriginZ)\r\n\r\n            if max_data_value == 0:\r\n                self.elements_to_render = None\r\n\r\n            else:\r\n                self.max_data_value = max_data_value\r\n                if self.data:\r\n                    self.build_segments()\r\n                self.elements_to_render = None\r\n\r\n        def _build_segment(self, data, segment_type, segment_origin_plane, flow_type, colour=None):\r\n            \"\"\"\r\n            Create a stacked bar segment for the current EPiCGraph column\r\n            :param data: Data used to create the segment\r\n            :param segment_type: The flow type that the segment represents (e.g initial, recurrent, initial wastage)\r\n            :param segment_origin_plane: Origin plane for the segment\r\n            :param flow_type: The flow type (e.g. Energy, Water, GHG)\r\n            :param colour: segment colour\r\n            :param subset:\r\n            :return:\r\n            \"\"\"\r\n\r\n            segment = segment_type\r\n\r\n            # If no value provided, use the default colour based on the flow + segment type\r\n            colour = DEFINED_FLOWS[self.flow][segment['colour']] if not colour else colour\r\n\r\n            # Get the flow values to create the segment\r\n            if isinstance(segment['flow_type'], list):\r\n                if data[segment['flow_type'][1]][self.flow] > 0 and self.max_data_value > 0:\r\n                    normalised_graph_value = ((data[segment['flow_type'][0]][self.flow]\r\n                                               - data[segment['flow_type'][1]][self.flow])\r\n                                              / self.max_data_value) * self.graph_preferences.graph_height\r\n                elif data[segment['flow_type'][0]][self.flow] > 0 and self.max_data_value > 0:\r\n                    normalised_graph_value = (data[segment['flow_type'][0]][self.flow]\r\n                                              / self.max_data_value) * self.graph_preferences.graph_height\r\n                else:\r\n                    normalised_graph_value = 0\r\n\r\n            # The other flows can be taken directly. Values are normalised for the graph height\r\n            else:\r\n                if data[segment['flow_type']][self.flow] > 0:\r\n                    normalised_graph_value = (data[segment['flow_type']][self.flow]\r\n                                              / self.max_data_value) * self.graph_preferences.graph_height\r\n                else:\r\n                    normalised_graph_value = 0\r\n\r\n            # Only create a segment is the value is more than 0\r\n            if normalised_graph_value > 0:\r\n                self.segments.append(\r\n                    EPiCGraph.BarGraphSegment(graph_preferences=self.graph_preferences,\r\n                                              origin_plane=segment_origin_plane,\r\n                                              height=normalised_graph_value,\r\n                                              origin_point=(segment_origin_plane.OriginX,\r\n                                                            segment_origin_plane.OriginY,\r\n                                                            segment_origin_plane.OriginZ),\r\n                                              colour=colour,\r\n                                              show_hatch='wastage' in segment['label'],\r\n                                              segment_type=segment['label'],\r\n                                              label=flow_type\r\n                                              ))\r\n            return normalised_graph_value\r\n\r\n        @staticmethod\r\n        def make_tint(colour_tuple, tint_factor):\r\n            \"\"\"\r\n            Create a tint value for a a specified colour\r\n            :param colour_tuple: an aRBG colour tuple with values of 0-255 (A,R,G,B) A = alpha\r\n            :param tint_factor: A tint factor from 0 to 1, 0 being a lighter value\r\n            :return: (A,R,G,B) tuple\r\n            :rtype: tuple\r\n            \"\"\"\r\n            alpha = colour_tuple[0]\r\n            newR = min([255, colour_tuple[1] + (255 - colour_tuple[1]) * tint_factor])\r\n            newG = min([255, colour_tuple[2] + (255 - colour_tuple[2]) * tint_factor])\r\n            newB = min([255, colour_tuple[3] + (255 - colour_tuple[3]) * tint_factor])\r\n            return (alpha, newR, newG, newB)\r\n\r\n        def build_segments(self):\r\n            segment_origin_plane = rs.MovePlane(rs.WorldXYPlane(), self.origin)\r\n\r\n            for key, segment in self.graph_preferences.segment_properties.items():\r\n                normalised_graph_value = self._build_segment(self.data, segment, segment_origin_plane, key)\r\n                segment_origin_plane = rs.MovePlane(segment_origin_plane, rs.AddPoint(\r\n                    segment_origin_plane.OriginX,\r\n                    segment_origin_plane.OriginY + normalised_graph_value,\r\n                    segment_origin_plane.OriginZ))\r\n\r\n    class BarGraphSegment:\r\n        def __init__(self, graph_preferences=None, origin_plane=rs.WorldXYPlane(), height=0, colour=None,\r\n                     segment_type='', origin_point=(0, 0, 0), label='', show_hatch=False):\r\n            \"\"\"\r\n            A stacked bar segment for the current EPiCGraph column\r\n            :param graph_preferences: Graph preference inherited from EPiCGraph\r\n            :param origin_plane: The segment origin plane\r\n            :param height: Height of the segment\r\n            :param colour: Colour of the segment\r\n            :param segment_type: The type of flow that the segment represents\r\n            :param origin_point: Origin point for the segment\r\n            :param label: The flow type for the segment\r\n            :param show_hatch: Show hatch if True\r\n            \"\"\"\r\n\r\n            self.graph_preferences = graph_preferences\r\n            self.origin_plane = origin_plane\r\n            self.origin = origin_point\r\n            self.colour = colour\r\n            self.show_hatch = show_hatch\r\n            self.name = segment_type\r\n            self.label = label\r\n\r\n            # Create segment\r\n            segment = EPiCVisualisations.GraphSegmentGeometry(Geometry.Rectangle3d(origin_plane,\r\n                                                                                   self.graph_preferences.column_width,\r\n                                                                                   height))\r\n            segment.fill_colour = colour\r\n            segment.show_hatch = show_hatch\r\n            self.elements_to_render = segment\r\n\r\n    class BarGraphLegend:\r\n\r\n        def __init__(self, graph, graph_preferences=None):\r\n            \"\"\"\r\n            Creates a legend for each graph component. This includes titles, labels, axis lines & legends.\r\n            :param graph: BarGraph class object. Used to extract legend values.\r\n            :param graph_preferences: Graph preference inherited from EPiCGraph\r\n            \"\"\"\r\n\r\n            self.graph_preferences = graph_preferences\r\n            self.graph = graph\r\n\r\n            # Load the individual graph preferences\r\n            self.column_spacing = graph_preferences.column_width + graph_preferences.text_padding\r\n            self.legend_box_size = graph_preferences.legend_box_size\r\n            self.text_size = graph_preferences.text_size\r\n            self.heading_text_size = graph_preferences.heading_text_size\r\n            self.tick_size = graph_preferences.tick_size\r\n            self.text_padding = graph_preferences.text_padding\r\n            self.axis_label_text = graph_preferences.axis_label_text_size\r\n\r\n            # Create a dictionary for all geometry and text that needs to be visualised\r\n            elements = {\r\n                'legend_boxes': [],\r\n                'legend_text': [],\r\n                'column_names': None,\r\n                'axis_lines': [],\r\n                'axis': [],\r\n                'y_axis_label': str}\r\n            prefs = []\r\n\r\n            # Extract preferences (the flow_types used in the graph) from each segment\r\n            if self.graph and isinstance(self.graph, EPiCGraph.BarGraph):\r\n                for column in self.graph.columns:\r\n                    prefs += [seg.label for seg in column.segments if seg]\r\n                self.segment_preferences = set(prefs)\r\n                if len(self.segment_preferences) == 0:\r\n                    self.segment_preferences = None\r\n            else:\r\n                self.segment_preferences = None\r\n\r\n            # Build a legend for the graph, including all axis lines and labels.\r\n            self.elements_to_render = {}\r\n            self.create_legend(elements)\r\n\r\n        def create_legend(self, elements):\r\n            \"\"\"\r\n            Create a legend for the current EPiCBarGraph element\r\n            :param elements: A dictionary of visualisation elements to be populated\r\n            \"\"\"\r\n\r\n            # Create a legend for each of the flow types\r\n            if self.segment_preferences:\r\n                legend_top_y_axis = self._create_legend(elements)\r\n                self._create_column_labels(elements)\r\n                if len(self.graph.column_group_names) > 0:  # Only used when multiple column values\r\n                    self._create_column_group_labels(elements)\r\n                self._create_axis_lines(elements)\r\n                self._create_ticks(elements)\r\n                self._create_graph_title(elements, legend_top_y_axis)\r\n                self._create_y_axis_labels(elements)\r\n\r\n                # Create a dictionary entry for each geometry / text that needs to be rendered\r\n                self.elements_to_render = elements\r\n\r\n        def _create_y_axis_labels(self, elements):\r\n            \"\"\"\r\n            Create the y-axis labels\r\n            :param elements: A dictionary of visualisation elements to be populated\r\n            \"\"\"\r\n            # find the minimum x origin value for the bounding boxes for the tick_text\r\n            tick_text_x_limit = min(text.get_Boundingbox().GetCorners()[0].X for text in elements['tick_text'])\r\n            # Create a label for the y-axis based on flow units\r\n            elements['y_axis_label'] = EPiCVisualisations.bakeable_text_from_str(\r\n                self.graph.flow_units,\r\n                text_size=(self.axis_label_text),\r\n                text_location=(tick_text_x_limit - 0.5,\r\n                               self.graph.origin.Y + self.graph_preferences.graph_height / 2,\r\n                               self.graph.origin.Z),\r\n                text_rotation=90)\r\n\r\n        def _create_graph_title(self, elements, legend_top_y_axis):\r\n            \"\"\"\r\n            Create a graph title\r\n            :param elements: A dictionary of visualisation elements to be populated\r\n            :param legend_top_y_axis: location of the top y-axis element (legend)\r\n            \"\"\"\r\n\r\n            elements['heading'] = EPiCVisualisations.bakeable_text_from_str(self.graph.title,\r\n                                                                            text_size=self.heading_text_size,\r\n                                                                            text_location=(self.graph.origin.X,\r\n                                                                                           legend_top_y_axis\r\n                                                                                           + self.column_spacing,\r\n                                                                                           self.graph.origin.Z))\r\n\r\n        def _create_legend(self, elements):\r\n            \"\"\"\r\n            Create a legend for the graph\r\n            :param elements: A dictionary of visualisation elements to be populated\r\n            :return: The y-axis location of the legend, needed to calculate the Title location\r\n            \"\"\"\r\n\r\n            for num, legend in enumerate(self.segment_preferences):\r\n                legend = self.graph_preferences.seg_pref_template[legend]\r\n                x_axis = self.graph.origin.X\r\n                y_axis = self.graph.origin.Y + self.graph_preferences.graph_height \\\r\n                         + self.graph_preferences.graph_spacing \\\r\n                         + (self.column_spacing * num)\r\n                z_axis = self.graph.origin.Z\r\n                legend_origin = rs.MovePlane(rs.WorldXYPlane(),\r\n                                             Geometry.Point3d(x_axis, y_axis, z_axis))\r\n                legend_colour = DEFINED_FLOWS[self.graph.flow][legend['colour']]\r\n                show_hatch = 'wastage' in legend['label']\r\n                legend_box = EPiCVisualisations.GraphSegmentGeometry(\r\n                    Geometry.Rectangle3d(legend_origin, self.legend_box_size, self.legend_box_size))\r\n                legend_box.show_hatch = show_hatch\r\n                legend_box.fill_colour = legend_colour\r\n\r\n                elements['legend_boxes'].append(legend_box)\r\n                elements['legend_text'].append(\r\n                    EPiCVisualisations.bakeable_text_from_str(legend['label'],\r\n                                                              text_size=self.text_size,\r\n                                                              text_location=(\r\n                                                                  (legend_origin.OriginX + self.column_spacing),\r\n                                                                  legend_origin.OriginY,\r\n                                                                  legend_origin.OriginZ)))\r\n            return y_axis\r\n\r\n        def _create_ticks(self, elements):\r\n            \"\"\"\r\n            Create the y-axis ticks and tick text for the graph\r\n            :param elements: A dictionary of visualisation elements to be populated\r\n            \"\"\"\r\n\r\n            # Create list of ticks\r\n            tick_values = (self.create_list_of_ticks([0, self.graph.max_data_value],\r\n                                                     normalised_y_axis_height=self.graph_preferences.graph_height))\r\n            tick_values_not_normalised = (self.create_list_of_ticks([0, self.graph.max_data_value]))\r\n\r\n            # Create ticks\r\n            elements['axis'] += [Geometry.Line(self.graph.origin.X, self.graph.origin.Y + tick, self.graph.origin.Z,\r\n                                               self.graph.origin.X - self.tick_size, self.graph.origin.Y + tick,\r\n                                               self.graph.origin.Z) for tick in tick_values]\r\n            # Tick values\r\n            elements['tick_text'] = [EPiCVisualisations.bakeable_text_from_str(str(int(tick)),\r\n                                                                               text_size=self.text_size,\r\n                                                                               align_right=True,\r\n                                                                               text_location=((\r\n                                                                                                      self.graph.origin.X - self.tick_size - self.text_padding),\r\n                                                                                              self.graph.origin.Y + tick_normalised - (\r\n                                                                                                      self.text_size / 2),\r\n                                                                                              self.graph.origin.Z)) for\r\n                                     tick_normalised, tick in\r\n                                     zip(tick_values, tick_values_not_normalised)]\r\n\r\n        def _create_axis_lines(self, elements):\r\n            \"\"\"\r\n            Create the axis lines for the graph\r\n            :param elements: A dictionary of visualisation elements to be populated\r\n            \"\"\"\r\n            elements['axis_lines'] = [Geometry.Line(self.graph.origin.X, self.graph.origin.Y, self.graph.origin.Z,\r\n                                                    self.graph.origin.X,\r\n                                                    self.graph.origin.Y + self.graph_preferences.graph_height,\r\n                                                    self.graph.origin.Z),\r\n                                      Geometry.Line(self.graph.origin.X, self.graph.origin.Y, self.graph.origin.Z,\r\n                                                    self.graph.origin.X + self.graph_preferences.graph_width\r\n                                                    - self.graph_preferences.space_between_graphs, self.graph.origin.Y,\r\n                                                    self.graph.origin.Z)]\r\n\r\n        def _create_column_group_labels(self, elements):\r\n            \"\"\"\r\n            Create the column group names (and sub-group names) for the graph\r\n            :param elements: A dictionary of visualisation elements to be populated\r\n            \"\"\"\r\n            if 'sub_group' in [y for x in self.graph.column_group_names.values() for y in x.keys()]:\r\n                for subgroup in self.graph.column_group_names.values():\r\n                    if 'sub_group' in subgroup:\r\n                        new_text_box_y_extent = self._generate_group_labels(elements, subgroup['sub_group'])\r\n                self._generate_group_labels(elements, self.graph.column_group_names, new_text_box_y_extent)\r\n            else:\r\n                self._generate_group_labels(elements, self.graph.column_group_names)\r\n\r\n        def _generate_group_labels(self, elements, labels, text_box_y_extent=False):\r\n            \"\"\"\r\n            Generate a group label, or sub-group label for the graph\r\n            :param elements: A dictionary of visualisation elements to be populated\r\n            :param labels: A list of labels and label locations\r\n            :param text_box_y_extent: y_axis location of the nearest test (above)\r\n            :return: text_box_y_extent needed to generate sub-label locations\r\n            \"\"\"\r\n\r\n            if not text_box_y_extent:\r\n                text_box_y_extent = min(text.get_Boundingbox().GetCorners()[0].Y for text in elements['column_names'])\r\n\r\n            for key, value in labels.items():\r\n                if 'group_label_origin_x' in value:\r\n                    if 'column_section_names' not in elements:\r\n                        elements['column_section_names'] = []\r\n                    if 'column_section_lines' not in elements:\r\n                        elements['column_section_lines'] = []\r\n                    elements['column_section_names'].append(EPiCVisualisations.bakeable_text_from_str(key,\r\n                                                                                                      text_size=self.text_size,\r\n                                                                                                      bold=True,\r\n                                                                                                      text_rotation=90,\r\n                                                                                                      align_top=True,\r\n                                                                                                      text_location=(\r\n                                                                                                          value[\r\n                                                                                                              'group_label_origin_x'],\r\n                                                                                                          text_box_y_extent\r\n                                                                                                          - (\r\n                                                                                                              self.graph_preferences.graph_spacing),\r\n                                                                                                          (value[\r\n                                                                                                              'group_label_origin_z'])\r\n                                                                                                      )))\r\n\r\n                    elements['column_section_lines'].append(Geometry.Line(value['group_label_origin_x_line_start'],\r\n                                                                          text_box_y_extent - (\r\n                                                                                  self.graph_preferences.graph_spacing / 3),\r\n                                                                          self.graph.origin.Z,\r\n                                                                          value['group_label_origin_x_line_end'],\r\n                                                                          text_box_y_extent\r\n                                                                          - (self.graph_preferences.graph_spacing / 3),\r\n                                                                          self.graph.origin.Z))\r\n            if 'column_section_names' in elements:\r\n                text_box_y_extent = min(text.get_Boundingbox().GetCorners()[0].Y for text\r\n                                        in elements['column_section_names'])\r\n            return text_box_y_extent\r\n\r\n        def _create_column_labels(self, elements):\r\n            \"\"\"\r\n            Create column labels for the graph\r\n            :param elements: A dictionary of visualisation elements to be populated\r\n            \"\"\"\r\n\r\n            elements['column_names'] = [EPiCVisualisations.bakeable_text_from_str(column.name,\r\n                                                                                  text_size=self.text_size,\r\n                                                                                  text_rotation=90,\r\n                                                                                  align_top=True,\r\n                                                                                  text_location=(\r\n                                                                                      column.origin.X + self.column_spacing / 2,\r\n                                                                                      column.origin.Y -\r\n                                                                                      (self.column_spacing / 2),\r\n                                                                                      column.origin.Z)) for num, column\r\n                                        in\r\n                                        enumerate(self.graph.columns)]\r\n\r\n        @staticmethod\r\n        def create_list_of_ticks(data_list, zero_val=0, max_ticks=10, normalised_y_axis_height=False):\r\n            \"\"\"\r\n            A tool that calculates optimal tick sizes based on list values\r\n            Adapted from code by Shaobo Guan (2017)\r\n            https://stackoverflow.com/questions/4947682/intelligently-calculating-chart-tick-positions\r\n\r\n            :param data_list: a list to evaluate\r\n            :param max_ticks: max number of ticks, an interger, defaults to 10\r\n            :param zero_val: y-axis zero value for the graph, defaults to 0\r\n            :return: tick size\r\n            \"\"\"\r\n\r\n            data_span = max(data_list) - zero_val\r\n\r\n            # scale data by the order of 10\r\n            scale = 10.0 ** floor(log10(data_span))\r\n\r\n            # possible tick sizes in range [1, 10]\r\n            standard_tick_size = [5.0, 2.0, 1.0, 0.5, 0.2, 0.1, 0.05, 0.02, 0.01]\r\n\r\n            # initial tick size for normalised data\r\n            initial_tick_size = 1.0\r\n\r\n            # every loop reduces tick size\r\n            for i in range(len(standard_tick_size)):\r\n\r\n                # number of ticks for the current tick size\r\n                num_tick = data_span / scale / standard_tick_size[i]\r\n\r\n                # break loop when tick limit reached\r\n                if num_tick > max_ticks:\r\n                    initial_tick_size = standard_tick_size[i - 1]\r\n                    break\r\n\r\n            # resize to original data\r\n            tick_size = initial_tick_size * scale\r\n            ticks = ceil(tick_size)\r\n\r\n            # Normalise the y-axis height\r\n            if normalised_y_axis_height:\r\n                return [((ticks * num) / max(data_list)) * normalised_y_axis_height for num in range(10) if\r\n                        ticks * num < max(data_list)]\r\n            else:\r\n                return [ticks * num for num in range(10) if ticks * num < max(data_list)]\r\n\r\n\r\nclass EPiCAssembly:\r\n    \"\"\"\r\n    An EPiC Assembly, enabling the combination of various EPiC materials and the calculation of associated embodied\r\n    environmental flows\r\n    \"\"\"\r\n\r\n    template_flows = OrderedDict([('initial', dict()),\r\n                                  ('initial_wastage', dict()),\r\n                                  ('recurrent', dict()),\r\n                                  ('recurrent_wastage', dict()),\r\n                                  ('life_cycle', dict()),\r\n                                  ('life_cycle_wastage', dict()),\r\n                                  ])\r\n\r\n    unit_calculation = {'no.': None,\r\n                        'm': ghcomponents.Length,\r\n                        'm': ghcomponents.Area,\r\n                        'm': ghcomponents.Volume}\r\n\r\n    def __str__(self):\r\n        return self.print_report(print_as_str=True)\r\n\r\n    def __init__(self, selected_geometry, name, service_life, wastage, comments,\r\n                 epic_materials, assembly_units, category=None):\r\n        \"\"\"\r\n        :param selected_geometry: a list of rhino geometries\r\n        :param name: the name of the assembly (str)\r\n        :param service_life: the service_life of the assembly, overriding the service_span of all nested materials (int)\r\n        :param wastage: wastage coefficient of the assembly in %, overriding the wastage coeffs of nested mats (float)\r\n        :param comments: a custom comment (str)\r\n        :param epic_materials: a list of tuples, item 0 the epic mat instance and item 1 being the quantity of material\r\n        :param assembly_units: the functional unit of the assembly (str), e.g. m\r\n        :param category: the assembly category, used in graph comparisons e.g. Interior Walls, Exterior Walls\r\n        \"\"\"\r\n\r\n        self.output_geometry = []\r\n        self.component_type = 'EPiCAssembly'\r\n        self.name = remove_commas_and_flatten_list_for_csv_export(name) if name else 'EPiC Assembly'\r\n        self.category = self.name if not category else remove_commas_and_flatten_list_for_csv_export(category)\r\n        self.comments = remove_commas_and_flatten_list_for_csv_export(comments) if comments else ''\r\n        self.service_life = abs(service_life) if service_life else None\r\n        self.assembly_units = assembly_units\r\n\r\n        # A zero value will override the EPiCDB wastage coefficient\r\n        if wastage:\r\n            self.wastage_override = abs(wastage) / 100\r\n        elif wastage == 0:\r\n            self.wastage_override = 0.\r\n        else:\r\n            self.wastage_override = None\r\n\r\n        self.total_units, self.individual_units = \\\r\n            self.verify_input_and_calculate_geometry_units(selected_geometry, assembly_units)\r\n\r\n        self.selected_geometry = selected_geometry\r\n        # create attribute to store inputted geometry\r\n\r\n        # list of lists of EPiC materials, sublists contain an instance of an EPiC material\r\n        # in index 0 and the quantity in 1\r\n        self.epic_materials = [[y[0][0], abs(y[1])] for y in epic_materials]\r\n\r\n        # run calculations\r\n        self.flows = self.calculate_flows()\r\n        self.recalculated_flows = self.calculate_flows()\r\n\r\n    def verify_input_and_calculate_geometry_units(self, selected_geometry, assembly_units):\r\n        \"\"\"\r\n        Verify input geometry based on the FU of the selected assembly. Calculate unit values for each item\r\n        :param selected_geometry: a list of geometry inputs and numerical input values\r\n        :param assembly_units: functional unit used for the selected geometry\r\n        :return: total_units, individual_units\r\n        \"\"\"\r\n\r\n        individual_units = []\r\n        total_units = 0\r\n\r\n        for num, geometry in enumerate(selected_geometry):\r\n            if geometry:\r\n                # Allow numerical input\r\n                if isinstance(geometry, (int, float)):\r\n                    _value = geometry\r\n\r\n                # Count each geometry item\r\n                elif assembly_units == 'no.':\r\n                    _value = 1\r\n\r\n                elif assembly_units == 'm':\r\n                    # Test if geometry is a line, curve or polyline\r\n                    if not isinstance(geometry, (Geometry.ArcCurve,\r\n                                                 Geometry.BezierCurve,\r\n                                                 Geometry.BrepEdge,\r\n                                                 Geometry.BrepLoop,\r\n                                                 Geometry.Curve,\r\n                                                 Geometry.Line,\r\n                                                 Geometry.LineCurve,\r\n                                                 Geometry.NurbsCurve,\r\n                                                 Geometry.Polyline,\r\n                                                 Geometry.PolyCurve,\r\n                                                 Geometry.PolylineCurve)):\r\n                        raise TypeError()\r\n                    _value = self.unit_calculation[assembly_units](geometry)\r\n\r\n                elif assembly_units == 'm':\r\n                    # Test if this is a surface\r\n                    # Create surface from polyline inputs\r\n                    if isinstance(geometry, (Geometry.PolylineCurve, Geometry.Polyline)):\r\n                        if geometry.IsClosed and geometry.IsPlanar():\r\n                            geometry = Geometry.Brep.CreatePlanarBreps(geometry)[0]\r\n                        else:\r\n                            raise TypeError()\r\n                    # Allow Brep - but only if it is not a solid\r\n                    elif isinstance(geometry, Geometry.Brep):\r\n                        if geometry.IsSolid:\r\n                            raise TypeError()\r\n                    elif not isinstance(geometry, (Geometry.BezierSurface,\r\n                                                   Geometry.BrepFace,\r\n                                                   Geometry.Surface,\r\n                                                   Geometry.Rectangle3d,\r\n                                                   Geometry.Mesh,\r\n                                                   Geometry.MeshNgon,\r\n                                                   Geometry.NurbsSurface,\r\n                                                   Geometry.PlaneSurface,\r\n                                                   Geometry.SubD,\r\n                                                   Geometry.SubDFace)):\r\n                        raise TypeError()\r\n                    _value = self.unit_calculation[assembly_units](geometry)[0]\r\n\r\n                elif assembly_units == 'm':\r\n                    # Test if this is a Brep, line or surface\r\n                    if not isinstance(geometry, (Geometry.Brep,\r\n                                                 Geometry.Extrusion)):\r\n                        raise TypeError()\r\n                    _value = self.unit_calculation[assembly_units](geometry)[0]\r\n\r\n                else:\r\n                    raise ValueError('No functional unit found for assembly')\r\n\r\n                total_units += _value\r\n                individual_units.append(_value)\r\n                if not isinstance(geometry, (int, float)):\r\n                    self.output_geometry.append(geometry)\r\n        return abs(total_units), individual_units\r\n\r\n    def _calculate_flows(self, materials_list, flow, wastage_only=False, period_of_analysis=None, quantity=None):\r\n        \"\"\"\r\n        Calculates embodied environmental flows\r\n        :param materials_list: the list of EPiC materials for which to run the calculations\r\n        :param flow: an embodied environmental flow, e.g. energy\r\n        :param period_of_analysis: period of analysis for calculating the flows\r\n        :param wastage_only: specify if we only want to calculate wastage\r\n        :param quantity: the quantity of assembly to use, specify when we want results by geometry\r\n        :return:\r\n        \"\"\"\r\n\r\n        if wastage_only:\r\n            base_quantity = 0.\r\n        else:\r\n            base_quantity = 1.\r\n\r\n        if quantity is None:\r\n            quantity = self.total_units\r\n\r\n        if self.wastage_override:\r\n            result = [quantity * abs(m[1]) * getattr(m[0], flow) * (base_quantity + self.wastage_override) for m\r\n                      in materials_list]\r\n\r\n        elif self.wastage_override == 0:  # Forcing wastage to be zero\r\n            result = [quantity * abs(m[1]) * getattr(m[0], flow) * base_quantity for m in materials_list]\r\n        else:\r\n            result = [quantity * abs(m[1]) * getattr(m[0], flow) * (base_quantity + getattr(m[0], 'wastage'))\r\n                      for m in\r\n                      materials_list]\r\n\r\n        if period_of_analysis is None:\r\n            pass\r\n        elif period_of_analysis == 0:  # we are forcing recurrent env flows to be zero\r\n            result = [0.]\r\n        elif period_of_analysis > 0 and self.service_life:  # we calculate only the recurrent embodied flows\r\n\r\n            replacements = _get_num_replacements(period_of_analysis, self.service_life)\r\n            result = [ef * replacements for ef in result]\r\n        elif period_of_analysis > 0 and not self.service_life:\r\n            recurrent_results = []\r\n            for embodied_flow, material in zip(result, materials_list):\r\n                try:\r\n                    recurrent_results.append(\r\n                        embodied_flow * _get_num_replacements(period_of_analysis, getattr(material[0], 'service_life')))\r\n                except (ZeroDivisionError, TypeError):  # if the material service life is 0 or None\r\n                    recurrent_results.append(0.)  # no replacement\r\n            result = recurrent_results\r\n\r\n        return sum(result)\r\n\r\n    def _fill_flows_dict(self, period_of_analysis=None, materials_list=None, quantity=None):\r\n        \"\"\"\r\n        Calculates the initial embodied environmental flows for a list of materials\r\n        :param period_of_analysis: the period of analysis in years (int)\r\n        :param materials_list: a list of EPiC materials (list of tuples)\r\n        :param quantity: the quantity of assembly to run the calculation for, use only when calculating by geometry\r\n        \"\"\"\r\n\r\n        if materials_list is None:\r\n            materials_list = self.epic_materials\r\n\r\n        results = copy.deepcopy(self.template_flows)\r\n        for flow_type in results.keys():\r\n            for env_flow in DEFINED_FLOWS.keys():\r\n                setup = {'materials_list': materials_list, 'flow': env_flow, 'quantity': quantity}\r\n                if 'wastage' in flow_type:\r\n                    setup['wastage_only'] = True\r\n                if 'recurrent' in flow_type:\r\n                    if period_of_analysis is None:\r\n                        # set the period of built_assets to zero to force zero recurrent flows\r\n                        setup['period_of_analysis'] = 0\r\n                    else:\r\n                        setup['period_of_analysis'] = period_of_analysis\r\n\r\n                if 'life' not in flow_type:\r\n                    results[flow_type][env_flow] = self._calculate_flows(**setup)\r\n                else:\r\n                    if 'wastage' in flow_type:\r\n                        initial = results['initial_wastage'][env_flow]\r\n                        recurrent = results['recurrent_wastage'][env_flow]\r\n                    else:\r\n                        initial = results['initial'][env_flow]\r\n                        recurrent = results['recurrent'][env_flow]\r\n\r\n                    results[flow_type][env_flow] = initial + recurrent\r\n        return results\r\n\r\n    def calculate_flows(self, period_of_analysis=None):\r\n        \"\"\"\r\n        Calculates all flows, at the assembly level, as well as by material and by geometry\r\n        :param period_of_analysis: The period of built_assets used for the calculation of environmental flows\r\n        :return: a dictionary, that follows the template dictionary\r\n        \"\"\"\r\n        result = self._fill_flows_dict(period_of_analysis)\r\n\r\n        # calculate the same by material\r\n        result['by_material'] = {}\r\n        for material, quantity in self.epic_materials:\r\n            mat_name = material.name\r\n            by_material = self._fill_flows_dict(period_of_analysis, materials_list=[[material, quantity]])\r\n            if mat_name not in result['by_material']:\r\n                by_material.update([('quantity', quantity), ('material_object', material), ('material_name', mat_name)])\r\n            else:\r\n                # Merge together any materials that have the same name\r\n                by_material = sum_numerical_dictionary_values(result['by_material'][mat_name], by_material)\r\n                by_material['quantity'] += quantity\r\n                if by_material['material_object'].material_id == material.material_id:\r\n                    pass\r\n                else:\r\n                    raise ValueError(\"Mismatched material name in 'by_material' calculation\")\r\n            result['by_material'][mat_name] = by_material\r\n        return result\r\n\r\n    def print_report(self, initial_flow=True, assembly_part_details=True, print_as_str=False):\r\n        \"\"\"\r\n        Print a report for the Assembly with all of the flow and material values & metadata\r\n        :param initial_flow: Specify if this is the initial flow\r\n        :param assembly_part_details: Provide details on the different geometry in the assembly\r\n        :param print_as_str: returns the results as a string\r\n        :return: string (if print_as_str=True), otherwise a list\r\n        \"\"\"\r\n\r\n        assembly_units_dict = {\r\n            'm': ['Total volume: ', 'Number of volumes (parts): ', 'Volume: '],\r\n            'm': ['Total area: ', 'Number of surfaces (parts): ', 'Area: '],\r\n            'm': ['Total linear meters: ', 'Number of lines/curves (parts): ', 'Linear meters: '],\r\n            'no.': ['Total number of units: ', 'Number of units (parts): ', 'Units: '],\r\n        }\r\n\r\n        mat_attributes = []\r\n        assembly_attributes = []\r\n        assembly_attributes.append('<< {} >>'.format(self.name))\r\n        selected_geometry_count = str(len(self.selected_geometry))\r\n        unit = self.assembly_units\r\n\r\n        assembly_attributes.append(assembly_units_dict[unit][0] + str(self.total_units) + unit)\r\n        if unit != 'no.':\r\n            assembly_attributes.append(assembly_units_dict[unit][1] + selected_geometry_count)\r\n\r\n        if self.wastage_override:\r\n            assembly_attributes.append('Wastage override: {}%'.format(str(self.wastage_override * 100)))\r\n\r\n        if self.service_life:\r\n            assembly_attributes.append('Service Life override: {} years'.format(str(self.service_life)))\r\n\r\n        if self.comments:\r\n            assembly_attributes.append('Comments: {}'.format(str(self.comments)))\r\n        assembly_attributes.append('')\r\n\r\n        if initial_flow is True:\r\n            results_dict = self.flows\r\n        else:\r\n            results_dict = self.recalculated_flows\r\n\r\n        for flow in DEFINED_FLOWS.keys():\r\n            if results_dict['recurrent'][flow] > 0:\r\n                assembly_attributes.append(\r\n                    '{}: {}'.format(\r\n                        'Life cycle embodied ' + DEFINED_FLOWS[flow]['print_name'] + ' (' + DEFINED_FLOWS[flow][\r\n                            'unit'] + ')',\r\n                        results_dict['life_cycle'][flow]))\r\n                if results_dict['life_cycle_wastage'][flow] > 0:\r\n                    assembly_attributes.append(\r\n                        '--- of which wastage (' + DEFINED_FLOWS[flow]['unit'] + '): {}'.format(\r\n                            results_dict['life_cycle_wastage'][flow]))\r\n\r\n            assembly_attributes.append(\r\n                '{}: {}'.format(\r\n                    'Initial embodied ' + DEFINED_FLOWS[flow]['print_name'] + ' (' + DEFINED_FLOWS[flow]['unit'] + ')',\r\n                    results_dict['initial'][flow]))\r\n\r\n            if results_dict['initial_wastage'][flow] > 0:\r\n                assembly_attributes.append(\r\n                    '--- of which wastage (' + DEFINED_FLOWS[flow]['unit'] + '): {}'.format(\r\n                        results_dict['initial_wastage'][flow]))\r\n\r\n            if results_dict['recurrent'][flow] > 0:\r\n                assembly_attributes.append(\r\n                    'Recurrent embodied ' + DEFINED_FLOWS[flow]['print_name'] + ' (' + DEFINED_FLOWS[flow][\r\n                        'unit'] + '): {}'.format(results_dict['recurrent'][flow]))\r\n            if results_dict['recurrent_wastage'][flow] > 0:\r\n                assembly_attributes.append(\r\n                    '--- of which wastage (' + DEFINED_FLOWS[flow]['unit'] + '): {}'.format(\r\n                        results_dict['recurrent_wastage'][flow]))\r\n            assembly_attributes.append('')\r\n\r\n        assembly_attributes.append('Materials in assembly: {}'.format(str(len(self.epic_materials))))\r\n\r\n        for mat_num, mat in enumerate(self.epic_materials):\r\n            assembly_attributes.append('Material {}: {}'.format(mat_num + 1, mat[0].name))\r\n            assembly_attributes.append(\r\n                '--- Qty: {}{} / {}'.format(mat[1], mat[0].functional_unit, self.assembly_units))\r\n            assembly_attributes.append(\r\n                '--- Total: {}{}'.format(mat[1] * self.total_units, mat[0].functional_unit))\r\n\r\n        mat_attributes.append(assembly_attributes)\r\n\r\n        if assembly_part_details is True:\r\n            if self.assembly_units != 'no.':\r\n                for num, geom in enumerate(self.selected_geometry):\r\n                    part_attributes = list()\r\n                    part_attributes.append('')\r\n                    part_attributes.append(\r\n                        'Assembly Part {} of {}'.format(str(num + 1), selected_geometry_count))\r\n                    if isinstance(geom, (int, float)):\r\n                        part_units = geom\r\n                    else:\r\n                        if self.assembly_units == 'm':\r\n                            part_units = ghcomponents.Area(geom)[0]\r\n                        elif self.assembly_units == 'm':\r\n                            part_units = ghcomponents.Volume(geom)[0]\r\n                        elif self.assembly_units == 'm':\r\n                            part_units = ghcomponents.Length(geom)\r\n\r\n                    part_attributes.append(assembly_units_dict[unit][2] + str(part_units) + self.assembly_units)\r\n                    mat_attributes.append(part_attributes)\r\n\r\n        if print_as_str:\r\n            print_str = []\r\n            for mat in mat_attributes:\r\n                print_str.append('\\n'.join(mat))\r\n            print_str = '\\n'.join(print_str)\r\n            return print_str\r\n\r\n        return mat_attributes\r\n\r\n    @staticmethod\r\n    def create_list_of_input_materials_and_qty(component, units, args):\r\n        \"\"\"\r\n        Create a list of input materials and their quantity. Only create an extry when there is valid data for both.\r\n        :param component: Base component to modify\r\n        :param units: Functional unit used for component\r\n        :param args: Arguments to iterate through\r\n        :return: A nested list containing each material and quantity [[mat, qty], [mat, qty]]\r\n        \"\"\"\r\n        material_list = []\r\n        for num, arg in enumerate(args):  # Make a list of all the valid materials and material quantities\r\n\r\n            # Handle list values passed from component. Only use first list item\r\n            #todo develop cleaner way to deal with list items, rather than using try except\r\n            try:\r\n                arg = arg[0]\r\n            except:\r\n                pass\r\n\r\n            # todo changing the NickName with Rhino 8 will break the component. Future fix.\r\n            if (num + 2) % 2 == 0:\r\n                if arg and 'functional_unit' in dir(arg):  # Check if material has the attribute (functional unit). Will return False for a number or string\r\n                    material = [arg]\r\n                    component.Params.Input[7+num].NickName = component.Params.Input[7+num].Name \\\r\n                        = \"Material: \" + str(arg.name)\r\n                    component.Params.Input[8+num].NickName = component.Params.Input[8+num].Name \\\r\n                        = \"({0} / {1})\".format(arg.functional_unit, units)\r\n                else:\r\n                    material = None\r\n                    component.Params.Input[7 + num].NickName = \"Material \" + str(num/2 + 1)\r\n                    component.Params.Input[8 + num].NickName = \"Material \" + str(num/2 + 1) + \\\r\n                                                               \": Quantity (FU / {0})\".format(units)\r\n            else:\r\n                if arg and material:\r\n                    material_list.append([material, arg])\r\n        return material_list\r\n\r\nclass EPiCAnalysis:\r\n    \"\"\"\r\n        A component that visualises life cycle assessment results and generates CSV reports.\r\n        Uses EPiCAssembly and EPiCBuiltAssets items to generate assessment report.\r\n        \"\"\"\r\n\r\n    def __str__(self):\r\n        return self.print_report()\r\n\r\n    def __init__(self, name='EPiCAnalysis', epic_assemblies=None, period_of_analysis=100,\r\n                 graph_origin=(0, 0, 0), analysis_type='total', sort_graph=True, graph_scale=1, generate_graph=True,\r\n                 comments=''):\r\n        \"\"\"\r\n        :param name: Name of the built_assets\r\n        :param epic_assemblies: A single, or multiple EPiCAssembly items. These are used to calculate the assessment.\r\n        :param period_of_analysis: The period of time (in years) used for the life cycle assessment\r\n        :param graph_origin: Origin point for the graph visualisation element. defaults to (0, 0, 0)\r\n        :param analysis_type: Type of built_assets to conduct ('total', 'by_smaterial' OR 'by assembly')\r\n        :param sort_graph: Specifies if the graph should be sorted from highest value to lowest. True/False.\r\n        :param graph_scale: Scale of the graph visualisation. 1=normal size 0.5=half size 2=double size\r\n        :param generate_graph: Specifies if a graph visualisation should be generated. True/False.\r\n        :param comments: Comments will be shown the in report .csv.\r\n        \"\"\"\r\n\r\n        # Set attributes and variables\r\n        self.component_type = 'EPiCAnalysis'\r\n        self.name = remove_commas_and_flatten_list_for_csv_export(name) if name else 'EPiCAnalysis'\r\n        self.comments = remove_commas_and_flatten_list_for_csv_export(comments) if comments else ''\r\n        self.period_of_analysis = period_of_analysis\r\n\r\n        list_of_assembly_names = []\r\n\r\n        # Code to enable built_assets for built_assets / comparison of multiple assemblies.\r\n        built_asset_objects = [x for x in epic_assemblies if x.component_type == 'EPiCBuiltAsset'\r\n                               or x.component_type == 'EPiCAnalysis']\r\n\r\n        epic_assemblies = [x for x in epic_assemblies if x.component_type == 'EPiCAssembly']\r\n\r\n        if built_asset_objects:\r\n            for asset in built_asset_objects:\r\n                epic_assemblies += asset.epic_assemblies\r\n\r\n        self.epic_assemblies = epic_assemblies\r\n\r\n        # Create a list of all of the materials (and qty) in the Analysis component\r\n        self.epic_materials = [(y[0], y[1] * x.total_units) for x in epic_assemblies for y in x.epic_materials if x]\r\n\r\n        # Recalculate the flows, based on the period of analysis\r\n        for assembly in epic_assemblies:\r\n            assembly.recalculated_flows = assembly.calculate_flows(period_of_analysis)\r\n\r\n        for assembly in epic_assemblies:\r\n            list_of_assembly_names.append(assembly.name)\r\n\r\n        self.flows = self.sum_by_assembly_and_material()\r\n\r\n        # Generate a graph element if this is set to true.\r\n        if generate_graph:\r\n            if built_asset_objects:\r\n                self.graph_visualisations = EPiCGraph(built_asset_objects, graph_origin=graph_origin,\r\n                                                      analysis_type=analysis_type,\r\n                                                      sort_graph=sort_graph, graph_scale=graph_scale)\r\n            else:\r\n                self.graph_visualisations = EPiCGraph(self, graph_origin=graph_origin, analysis_type=analysis_type,\r\n                                                      sort_graph=sort_graph, graph_scale=graph_scale)\r\n            self.elements_to_render = self.graph_visualisations.elements_to_render\r\n        else:\r\n            self.graph_visualisations = None\r\n            self.elements_to_render = None\r\n\r\n    @staticmethod\r\n    def process_inputs(epic_inputs, analysis_type='total', graph_origin=(0, 0, 0), graph_scale=1,\r\n                       period_of_analysis=None, report_name='EPiC Analysis',\r\n                       epic_assemblies_name='Assembly Collection'):\r\n        \"\"\"\r\n        :param epic_inputs: Inputs - either EPiC_Assembly and/or EPiC_Built_Asset components\r\n        :param analysis_type: Type of built_assets to be used for graph visualisations. 'total', 'by_material',\r\n        'by_assembly', or 'by_assembly_and_material'\r\n        :param graph_origin: Origin point for the graph. Defaults to (0, 0, 0)\r\n        :param graph_scale: Graph scale. 1=Default scale\r\n        :param period_of_analysis: The period of built_assets to be used for calculations.\r\n        Default value of None - indicating that no recurrent calculations will be made.\r\n        :param report_name: Name for the Analysis Report\r\n        :param epic_assemblies_name: Default name for a group of EPiCAssembly inputs\r\n        :return:\r\n        epic_analysis - an EPiCAnalysis class instance\r\n        epic_inputs - sorted list of inputs\r\n        \"\"\"\r\n\r\n        # Set default values for the variables\r\n        graph_origin = (0, 0, 0) if not graph_origin else graph_origin\r\n        graph_scale = 1 if not graph_scale else graph_scale\r\n        analysis_type = 'total' if not analysis_type else analysis_type\r\n\r\n        # Initialise variables\r\n        epic_analysis = None\r\n        _epic_analyses = []\r\n\r\n        # Remove null values from input list\r\n        epic_inputs = [x for x in epic_inputs if x]\r\n\r\n        # Clean the epic_inputs list, and separate EPiCAssembly and EPiCBuiltAsset items for built_assets\r\n        epic_inputs = [x for x in epic_inputs if x.component_type == 'EPiCAssembly'\r\n                       or x.component_type == 'EPiCBuiltAsset']\r\n        epic_assemblies = [x for x in epic_inputs if x.component_type == 'EPiCAssembly']\r\n        built_assets = [x for x in epic_inputs if x.component_type == 'EPiCBuiltAsset']\r\n\r\n        if built_assets:\r\n            for built_asset in built_assets:\r\n                _epic_analyses.append(EPiCAnalysis(built_asset.name,\r\n                                                   [built_asset],\r\n                                                   period_of_analysis, graph_origin=graph_origin,\r\n                                                   analysis_type=analysis_type, graph_scale=graph_scale,\r\n                                                   generate_graph=False))\r\n        if epic_assemblies:\r\n            _epic_analyses.append(EPiCAnalysis(epic_assemblies_name,\r\n                                               epic_assemblies,\r\n                                               period_of_analysis, graph_origin=graph_origin,\r\n                                               analysis_type=analysis_type, graph_scale=graph_scale,\r\n                                               generate_graph=False))\r\n        if _epic_analyses:\r\n            epic_analysis = EPiCAnalysis(report_name,\r\n                                         _epic_analyses,\r\n                                         period_of_analysis, graph_origin=graph_origin,\r\n                                         analysis_type=analysis_type, graph_scale=graph_scale,\r\n                                         generate_graph=True)\r\n        return epic_analysis, epic_inputs\r\n\r\n    # Region baking\r\n    # TODO: Fix colouring for baked objects\r\n    def BakeGeometry(self, doc, att, id):\r\n        id = Guid.Empty\r\n        if self.elements_to_render is None:\r\n            return False, id\r\n\r\n        if att is None:\r\n            att = doc.CreateDefaultAttributes()\r\n\r\n        if self.elements_to_render:\r\n            for graph_element in self.elements_to_render:\r\n\r\n                # Bake legend lines\r\n                if isinstance(graph_element, Geometry.Line):\r\n                    doc.Objects.AddLine(graph_element, att)\r\n\r\n                # Bake graph text\r\n                elif isinstance(graph_element, EPiCVisualisations.EPiCText):\r\n                    if graph_element.m_value is None:\r\n                        pass\r\n                    else:\r\n                        doc.Objects.AddText(graph_element.m_value, att)\r\n\r\n                # Bake graph columns\r\n                elif isinstance(graph_element, EPiCVisualisations.GraphSegmentGeometry):\r\n                    doc.Objects.AddRectangle(graph_element.m_value, att)\r\n                    att.ObjectColor = graph_element.fill_colour\r\n                    doc.Objects.AddHatch(graph_element.fill, att)\r\n\r\n        id = doc.Objects\r\n        return True, id\r\n\r\n    def sum_by_assembly_and_material(self):\r\n        \"\"\"\r\n        Sums all flows by assembly and material\r\n        :return:a dictionary, containing the same keys as the flows dictionary in an assembly and materials\r\n        \"\"\"\r\n        result = OrderedDict()\r\n\r\n        for assembly in self.epic_assemblies:\r\n            self._sum_by_assembly_and_material(result, assembly.recalculated_flows,\r\n                                               by_material=True,\r\n                                               assembly=assembly)\r\n\r\n            # create the 'by_assembly' dictionary. This will contain a nested 'by_material' dict\r\n            if 'by_assembly' not in result:\r\n                result['by_assembly'] = dict()\r\n            if assembly.category not in result['by_assembly']:\r\n                result['by_assembly'][assembly.category] = dict()\r\n            self._sum_by_assembly_and_material(result['by_assembly'][assembly.category], assembly.recalculated_flows,\r\n                                               by_material=True)\r\n\r\n        return result\r\n\r\n    def fetch_geometry_as_list(self):\r\n        \"\"\"\r\n        Compiles a list of all geometries contained within each EPiC Assembly and EPiC Built Assets\r\n        :return: a list of geometries\r\n        \"\"\"\r\n\r\n        # Exclude numbers from geometry output and change to datatree structure\r\n        return list_to_datatree([[x for x in assembly.output_geometry if not isinstance(x, (float, int))]\r\n                                 for assembly in self.epic_assemblies])\r\n\r\n    def _sum_by_assembly_and_material(self, final_dict_result, iterative_dict_result,\r\n                                      by_material=False, assembly=False):\r\n        \"\"\"\r\n        Recursive method to move within nested dicts and calculate the sum\r\n        :param final_dict_result: The final dictionary result\r\n        :param iterative_dict_result: The iterative dictionary result\r\n        :param by_material: if True, iterate through the by_material dictionary\r\n        :param assembly: An EPiCAssembly item to get materials from\r\n        \"\"\"\r\n        for k, v in iterative_dict_result.items():\r\n\r\n            if isinstance(v, dict) or isinstance(v, OrderedDict):\r\n                if k == 'by_material':\r\n                    if by_material:\r\n                        self._sum_by_assembly_and_material(final_dict_result.setdefault(k, dict()), v,\r\n                                                           by_material=True, assembly=assembly)\r\n                else:\r\n                    # Create a new 'by_assembly' dictionary nested within each material dictionary and populate\r\n                    self._sum_by_assembly_and_material(final_dict_result.setdefault(k, dict()), v)\r\n                    if assembly and by_material:\r\n                        if len(assembly.epic_materials) > 0:\r\n                            if k in [mat[0].name for mat in assembly.epic_materials]:\r\n                                if 'by_assembly' not in final_dict_result[k]:\r\n                                    final_dict_result[k]['by_assembly'] = dict()\r\n                                if assembly.name not in final_dict_result[k]['by_assembly']:\r\n                                    final_dict_result[k]['by_assembly'][assembly.name] = dict()\r\n                                self._sum_by_assembly_and_material(\r\n                                    final_dict_result[k]['by_assembly'][assembly.name], v)\r\n\r\n\r\n            elif isinstance(v, float):\r\n                final_dict_result[k] = final_dict_result.get(k, 0) + v\r\n\r\n            elif isinstance(v, str):  # for material column_group_name\r\n                if k in final_dict_result:\r\n                    if not final_dict_result[k] == v:\r\n                        final_dict_result[k] = final_dict_result.get(k, '') + '/' + v\r\n                else:\r\n                    final_dict_result[k] = v\r\n            else:  # for EPiCMaterial object file\r\n                final_dict_result[k] = v\r\n\r\n    def generate_analysis_breakdown_for_outputs(self, analysis_type='total'):\r\n        \"\"\"\r\n        Generate outputs for the EPiCAnalysis component based on the built_assets type\r\n        :param analysis_type: Type of built_assets used ('total,'by_material' OR 'by_assembly')\r\n        :return: list of outputs for the EPiCAnalysis component\r\n        \"\"\"\r\n        results_list = []\r\n        output_keys = []\r\n\r\n        if not analysis_type:\r\n            analysis_type = 'total'\r\n\r\n        for flow in DEFINED_FLOWS.keys():\r\n            results_list.append(None)\r\n            for flow_type in self.flows.keys():\r\n                if flow_type != 'by_material' and flow_type != 'by_assembly':\r\n                    if analysis_type == 'by_assembly_and_material':\r\n                        _mats = set([y for x in self.flows['by_assembly'].values() for y in x['by_material'].keys()])\r\n                        _assemblies = self.flows['by_assembly'].keys()\r\n                        nested_list = []\r\n                        output_keys = []\r\n                        for key, assembly in self.flows['by_assembly'].items():\r\n                            _assembly_container = []\r\n                            mat_keys = []\r\n                            for mat in _mats:\r\n                                mat_keys.append(str(key) + ': ' + mat)\r\n                                if mat in assembly['by_material']:\r\n                                    _assembly_container.append(assembly['by_material'][mat][flow_type][flow])\r\n                                else:\r\n                                    _assembly_container.append(0)\r\n                            nested_list.append(_assembly_container)\r\n                            output_keys.append(mat_keys)\r\n                        results_list.append(list_to_datatree(nested_list))\r\n                        output_keys = list_to_datatree(output_keys)\r\n                    elif analysis_type == 'by_assembly':\r\n                        results_list.append([x[flow_type][flow] for x in self.flows['by_assembly'].values()])\r\n                        output_keys = self.flows['by_assembly'].keys()\r\n                    elif analysis_type == 'by_material':\r\n                        results_list.append([x[flow_type][flow] for x in self.flows['by_material'].values()])\r\n                        output_keys = self.flows['by_material'].keys()\r\n                    elif analysis_type == 'total':\r\n                        results_list.append(self.flows[flow_type][flow])\r\n                        output_keys = 'total'\r\n\r\n        return [self, self.elements_to_render, output_keys] + results_list + [None] + [self.fetch_geometry_as_list()]\r\n\r\n    def print_report(self):\r\n        \"\"\"\r\n        Print all EPiCAssembly inputs/outputs and results of the life cycle assessment calculation\r\n        :return: A string with all of the report results\r\n        \"\"\"\r\n\r\n        report_writer = []\r\n        temp_report = []\r\n        for assembly in self.epic_assemblies:\r\n            if self.period_of_analysis:\r\n                pass\r\n            else:\r\n                self.period_of_analysis = None\r\n            assembly.recalculated_flows = assembly.calculate_flows(self.period_of_analysis)\r\n        temp_report.append('<<<' + str(self.name) + '>>>')\r\n        if isinstance(self, EPiCBuiltAsset):\r\n            temp_report.append('Built Asset')\r\n        else:\r\n            temp_report.append('Assessment duration: {} years'.format(self.period_of_analysis))\r\n        temp_report.append('Number of Assemblies: {}'.format(len(self.epic_assemblies)))\r\n\r\n        for flow in DEFINED_FLOWS.keys():\r\n            temp_report.append('Total embodied ' + flow + ' (' + DEFINED_FLOWS[flow]['unit'] + '): {}'.format(\r\n                sum([x.recalculated_flows['life_cycle'][flow] for x in self.epic_assemblies])))\r\n            temp_report.append(\r\n                '--- of which wastage (' + DEFINED_FLOWS[flow]['unit'] + '): {}'.format(\r\n                    sum([x.recalculated_flows['life_cycle_wastage'][flow] for x in self.epic_assemblies])))\r\n\r\n            temp_report.append('Initial embodied ' + flow + ' (' + DEFINED_FLOWS[flow]['unit'] + '): {}'.format(\r\n                sum([x.recalculated_flows['initial'][flow] for x in self.epic_assemblies])))\r\n            temp_report.append(\r\n                '--- of which wastage (' + DEFINED_FLOWS[flow]['unit'] + '): {}'.format(\r\n                    sum([x.recalculated_flows['initial_wastage'][flow] for x in self.epic_assemblies])))\r\n\r\n            temp_report.append('Recurrent embodied ' + flow + ' (' + DEFINED_FLOWS[flow]['unit'] + '): {}'.format(\r\n                sum([x.recalculated_flows['recurrent'][flow] for x in self.epic_assemblies])))\r\n            temp_report.append(\r\n                '--- of which wastage (' + DEFINED_FLOWS[flow]['unit'] + '): {}'.format(\r\n                    sum([x.recalculated_flows['recurrent_wastage'][flow] for x in self.epic_assemblies])))\r\n\r\n        report_writer.append(temp_report)\r\n\r\n        for num, assembly in enumerate(self.epic_assemblies):\r\n            temp_report = assembly.print_report(assembly_part_details=False, initial_flow=False)[0]\r\n            report_writer.append(temp_report)\r\n\r\n        # Return string value\r\n        print_str = []\r\n        for report in report_writer:\r\n            print_str.append('\\n'.join(report))\r\n        return '\\n'.join(print_str)\r\n\r\n\r\nclass EPiCBuiltAsset(EPiCAnalysis):\r\n    \"\"\"\r\n    A single built asset containing multiple EPiCAssembly items\r\n    \"\"\"\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        EPiCAnalysis.__init__(self, *args, **kwargs)\r\n        self.period_of_analysis = 0\r\n        self.component_type = 'EPiCBuiltAsset'\r\n\r\n\r\nclass EPiCBreakdown:\r\n    \"\"\"\r\n    Enables breaking down embodied environmental flows into their shares of process data and input-output data.\r\n    Works on EPiC Material, EPiC Assembly, EPiC Built Asset and EPiC Analysis - (only on the total).\r\n    \"\"\"\r\n\r\n    def __init__(self, epic_entity):\r\n        if isinstance(epic_entity, (EPiCMaterial, EPiCAssembly, EPiCBuiltAsset, EPiCAnalysis)):\r\n            self.epic_entity = epic_entity\r\n            self.breakdown_dict = copy.deepcopy(HYBRID_VALUE_BREAKDOWN_DICT)\r\n        else:\r\n            raise TypeError(\r\n                'You can only breakdown the embodied environmental flows of an EPiCMaterial, EPiCAssembly, EPiCBuiltAsset and EPiCAnalysis')\r\n\r\n    def breakdown_embodied_flows(self):\r\n        \"\"\"\r\n        Breaks down the embodied environmental flows of the EPiC entity into its process and input-output components\r\n        :return: the populated breakdown dict\r\n        \"\"\"\r\n        return self.epic_entity.generate_breakdown_dict()\r\n\r\n\r\nclass EPiCDatabase:\r\n    \"\"\"\r\n    Provides access to the EPiCDatabase through the use of queries. Data is held as a class attribute (database)\r\n    \"\"\"\r\n\r\n    database = {}\r\n\r\n    def __init__(self, local_directory=None):\r\n        self.component_type = 'EPiCDatabase'\r\n        self.custom_database = None\r\n\r\n        if not self.database:\r\n            if local_directory:\r\n                with open(local_directory + os.sep + r'EPiC Grasshopper' + os.sep + PICKLE_DB, 'rb') as f:\r\n                    self.database = cPickle.load(f)\r\n\r\n        # Load set of categories in the database\r\n\r\n        self.categories = EPiCDatabase.get_categories(self.database)\r\n        self.dict_of_categories = EPiCDatabase.get_dict_of_categories(self.database)\r\n        self.dict_of_ids_and_names = {key: self.database[key]['name'] for key in self.database.keys()}\r\n        self.dict_of_legacy_names = {key: self.database[key]['Legacy_names'] for key in self.database.keys()}\r\n\r\n    @staticmethod\r\n    def get_categories(database):\r\n        \"\"\"\r\n        Returns a set containing all categories in the database\r\n        \"\"\"\r\n        return {x['Category'] for x in database.values() if x['Latest_Version']}\r\n\r\n    @staticmethod\r\n    def get_dict_of_categories(database):\r\n        \"\"\"\r\n        Returns a dictionary of categories, which contains a list of mat ids [(mat_id, mat_name), (... , ...)]\r\n        \"\"\"\r\n        # if the class instance already has a set of categories, use that, otherwise create a set\r\n\r\n        if hasattr(database, 'categories'):\r\n            categories = database.categories\r\n\r\n        else:\r\n            categories = EPiCDatabase.get_categories(database)\r\n\r\n        return {category: dict([(id, EPiCMaterial._concatenate_mat_name_func_unit(mat['name'], mat['Functional Unit']))\r\n                for id, mat in database.items() if mat['Category'] == category]) for category in categories}\r\n\r\n    def load_custom_database(self, file_path, file_name):\r\n        \"\"\"\r\n        Load a custom database file\r\n        :param file_path: The full file path directory\r\n        :param file_name: Name of database file\r\n        \"\"\"\r\n\r\n        if file_path and file_name:\r\n            try:\r\n                with open(file_path + r'//' + file_name, 'rb') as f:\r\n                    self.custom_database = cPickle.load(f)\r\n\r\n                    # Overwrite categories\r\n                    self.categories = EPiCDatabase.get_categories(self.custom_database)\r\n                    self.dict_of_categories = EPiCDatabase.get_dict_of_categories(\r\n                        self.custom_database)\r\n                    self.dict_of_ids_and_names = {key: self.custom_database[key]['name']\r\n                                                for key in self.custom_database.keys()}\r\n                    self.dict_of_legacy_names = self.dict_of_ids_and_names\r\n            except:\r\n                self.custom_database = 'Error'\r\n                raise (RuntimeError(\"Couldn't load database from: \" + file_path + r'//' + file_name))\r\n\r\n    def _query_for_name_or_old_mat_id(self, lookup_item):\r\n        \"\"\"\r\n        Lookup material based on name, or legacy name.\r\n        :param lookup_item: Name of the material to lookup\r\n        :return: material ID as string\r\n        \"\"\"\r\n        lookup_item = str(lookup_item)\r\n\r\n        # Remove decoration from material name (if it exists)\r\n        if '|' in lookup_item:\r\n            lookup_item = EPiCMaterial.remove_func_unit_from_mat_name(lookup_item)\r\n\r\n        # Search in the list of material names followed by a search of legacy names\r\n        if lookup_item in self.dict_of_ids_and_names.values():\r\n            return [key for key, value in self.dict_of_ids_and_names.items() if lookup_item == value][0]\r\n        elif lookup_item in self.dict_of_legacy_names.values():\r\n            return [key for key, value in self.dict_of_legacy_names.items() if lookup_item == value][0]\r\n        return None\r\n\r\n    def query(self, material_id, material_attributes=None):\r\n        \"\"\"\r\n        Query the EPiC Database using a material name & optional attribute\r\n        :param material_id: ID of the material S-String, I-Integer Region(SS)Year(IIII)Cat(SS)Material(III)Variation(II)\r\n        :param material_attributes: Name of the attribute to return (e.g DOI, Functional Unit), or list of attributes\r\n        :return: material dictionary OR material attribute (if specified)\r\n        \"\"\"\r\n        query = None\r\n        # Use the default database unless a custom database has been provided\r\n        database = self.database if not self.custom_database else self.custom_database\r\n\r\n        try:\r\n            _ = database[material_id]\r\n        except KeyError:\r\n            material_id = self._query_for_name_or_old_mat_id(material_id)\r\n\r\n        if material_attributes is None:\r\n            try:\r\n                query = database[material_id]\r\n            except KeyError:\r\n                raise TypeError('Material not found')\r\n\r\n        else:\r\n            try:\r\n                if isinstance(material_attributes, list):\r\n                    # if an attribute doesn't exist, return None for that list item\r\n                    query = [database[material_id][attribute] if attribute in database[material_id]\r\n                             else 'None'\r\n                             for attribute in material_attributes]\r\n                else:\r\n                    query = database[material_id][material_attributes]\r\n            except KeyError:\r\n                raise TypeError('Material or material attribute not found')\r\n\r\n        # Return None if there are no results\r\n        if not isinstance(query, list):\r\n            if isnan(query):\r\n                return None\r\n            else:\r\n                return query\r\n        else:\r\n            # Remove nan values from the results and return\r\n            return [x if not isnan(x) else None for x in query]\r\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "classes", "point", "layer", "brep", "line", "curve", "functions", "mesh"], "original_file": "beyondepic_EPiC_Grasshopper_9e7ffcdf37.json", "repo": "beyondepic/EPiC_Grasshopper"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "import rhinoscriptsyntax as rs\nimport ghpythonlib.components as ghc\nimport scriptcontext as sc\nimport Rhino\nimport math\nimport random\n\nclass Agent(object):\n    #initilize data in class\n    def __init__(self, point, coord, vec):\n        #initialize agent data\n        self.ptID = point\n        self.pos = coord\n        self.vector = vec\n        self.trailPts = []\n        self.trailPts += [self.pos]\n        self.curveID = None\n\n    # find out the closest mesh\n    def detectMesh(self, mesh):\n        distances = []\n        closestMesh = {}\n        for each in mesh:\n            ptData = ghc.MeshClosestPoint(self.ptID, each)\n            distance = rs.Distance(ptData[0], self.pos)\n            distances += [distance]\n            closestMesh[distance] = [each, ptData[0]]\n        distance = min(distances)\n        self.closestMesh = closestMesh[distance]\n        return self\n\n    # find the closest agent\n    def detectAgent(self, agentPopulation):\n        distances = []\n        closestAgent = {}\n        for agent in agentPopulation:\n            distance = rs.Distance(self.pos, agent.pos)\n            # select a closest agent within a random distance\n            if distance > random.randint(2,20):\n                distances += [distance]\n                closestAgent[distance] = [agent, distance]\n        distance = min(distances)\n        self.closestAgent = closestAgent[distance]\n        return self\n\n    def vectorAttract(self):\n        # if the closest agent is close enough, change the default vector to push agent toward other agents\n        if self.closestAgent[1] > random.randint(5,8) and self.closestAgent[1] < random.randint(9,13) and self.pos[2] > 1:\n            direction = rs.AddLine(self.pos, self.closestAgent[0].pos)\n            translation = rs.CreatePoint((0,0,1)) - rs.CreatePoint(self.pos)\n            rs.MoveObject(direction, translation)\n            self.tempVector = rs.VectorCreate(rs.CurveEndPoint(direction), (0,0,0))\n            rs.DeleteObject(direction)\n            if rs.VectorLength(self.tempVector) >= 1:\n                self.tempVector = rs.VectorUnitize(self.tempVector)\n        # if agent is too close to each other, push it away from other agents\n        elif self.closestAgent[1] <= 5 and self.pos[2] > 1:\n            direction = rs.AddLine(self.closestAgent[0].pos, self.pos)\n            translation = rs.CreatePoint((0,0,1)) - rs.CreatePoint(self.pos)\n            rs.MoveObject(direction, translation)\n            self.tempVector = rs.VectorCreate(rs.CurveEndPoint(direction), (0,0,0))\n            rs.DeleteObject(direction)\n            if rs.VectorLength(self.tempVector) >= 1:\n                self.tempVector = rs.VectorUnitize(self.tempVector)\n        else:\n            self.tempVector = self.vector\n\n    def move(self):\n        self.vectorAttract()\n        # keep moving upward if agent is far from barriers\n        if rs.Distance(self.closestMesh[1], self.pos) > 2 or self.closestMesh[1][2] == self.pos[2]:\n            self.pos = rs.PointAdd(self.pos, self.tempVector)\n        else: # make agent detour\n            # get normal from the closest point on the closest mesh\n            self.closestMesh[0].FaceNormals.ComputeFaceNormals()\n            fid,mPt = self.closestMesh[0].ClosestPoint(self.closestMesh[1],2)\n            meshNormal = self.closestMesh[0].FaceNormals[fid]\n            # add vector to the closest point on the closest mesh\n            vecPt = rs.PointAdd(self.closestMesh[1], meshNormal)\n            # create direction line starting from vector point to ClosestPoint\n            # when agent is below half the height of the sphere\n            if self.closestMesh[1][2] > self.pos[2]:\n                direction = rs.AddLine(self.closestMesh[1], vecPt)\n            # when the height of agent is more than half the height of the sphere\n            elif self.closestMesh[1][2] < self.pos[2]:\n                direction = rs.AddLine(vecPt, self.closestMesh[1])\n            startPt = rs.CurveStartPoint(direction)\n            # create an elevated point from agent\n            pt = (self.pos[0], self.pos[1], self.pos[2]+1/math.sin(math.radians(45)))\n            # move direction line to elevated point\n            translation = rs.CreatePoint(pt) - startPt\n            rs.MoveObject(direction, translation)\n            # relocate agent at the end point of moved direction line\n            self.pos = rs.CurveEndPoint(direction)\n            rs.DeleteObject(direction)\n        self.trailPts += [self.pos]\n        rs.DeleteObject(self.ptID)\n        self.ptID = rs.AddPoint(self.pos)\n        return self\n\n    # draw trails\n    def drawTrails(self):\n        if self.curveID != None:\n            rs.DeleteObject(self.curveID)\n        self.curveID = rs.AddCurve(self.trailPts)\n\ndef main():\n    ptNum = rs.GetInteger('how many attractor points?', 60)\n    startPtNum = rs.GetInteger('how many streams?', 80)\n    steps = rs.GetInteger('How many steps?', 80)\n\n    # moving direction\n    vector = (0,0,1)\n    spheres = []\n    agentPopulation = []\n\n    # setup barrier sphere mesh\n    for i in range(ptNum):\n        x = random.randrange(5, 45)\n        y = random.randrange(5, 45)\n        z = random.randrange(5, 80)\n        point = (x,y,z) # center point\n        radius = random.randrange(3, 10) # random radius\n        plane = ghc.XYPlane(rs.AddPoint(point))\n        sphere = ghc.MeshSphere(plane, radius)\n        spheres += [sphere]\n\n    # convert separate sphere into subD and then convert subD in to mesh\n    mesh = ghc.MeshUnion(spheres)\n    subD = ghc.SubDfromMesh(mesh)\n    meshFSubD = ghc.MeshfromSubD(subD)\n    meshIDs = []\n    for i in meshFSubD:\n        meshIDs += [sc.doc.Objects.AddMesh(i)]\n\n    # setup start points for line structure\n    for i in range(startPtNum):\n        x = random.randrange(0, 50)\n        y = random.randrange(0, 50)\n        z = 0\n        point = (x,y,z)\n        agentPopulation += [Agent(rs.AddPoint(point), point, vector)]\n\n    # call Agent methods\n    n = 0\n    while n <= steps:\n    #while not sc.escape_test():\n        n += 1\n        for agent in agentPopulation:\n            agent.detectMesh(meshFSubD).detectAgent(agentPopulation).move().drawTrails()\n\nmain()\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "classes", "point", "line", "curve", "functions", "mesh"], "original_file": "billbillbilly_generativeRhinoScript_55e0b5e026.json", "repo": "billbillbilly/generativeRhinoScript"}
{"instruction": "Implement the function 'block_list_count' for Rhino scripting", "code": "import rhinoscriptsyntax as rs\nimport Rhino\nimport scriptcontext as sc\nimport sys\n\n# BOM\n# Creates bill of materials based on the blocks being in the BOM layer (user defined)\n\nitems = (\"Use_BOM_Layer\", \"No\", \"Yes\")\nresults = rs.GetBoolean(\"Use BOM Layer\", items, (True))\n\nif results is None:\n    print(\"None Selected\")\n    sys.exit()\n\n# Definition on block list counting\ndef block_list_count():\n    # Create list and dictionary to hold keys and values\n    block_list = []\n    block_desc = []\n    counts = {}\n    font=\"Roboto\"\n\n    # for each object in the layer, check if it is a block\n    for obj in layer:\n        if rs.IsBlockInstance(obj):\n            block_name = rs.BlockInstanceName(obj)\n            block_description = rs.BlockDescription(block_name) or \"XXXX\"\n            block_list.append(block_name)\n            block_desc.append(block_description)\n\n    # Sort both block names and block descriptions together to maintain alignment\n    block_list_desc = sorted(zip(block_list, block_desc))\n\n    # Unzip back into two lists (sorted and aligned)\n    block_list, block_desc = zip(*block_list_desc)\n\n    # Count the occurrences of each block\n    for block_name in block_list:\n        counts[block_name] = counts.get(block_name, 0) + 1\n\n    # Filter the descriptions by making sure there are no duplicates\n    unique_block_desc = []\n    for name, description in zip(block_list, block_desc):\n        if (name, description) not in unique_block_desc:\n            unique_block_desc.append((name, description))\n\n    # Separate the names and descriptions after filtering\n    filtered_block_list, filtered_block_desc = zip(*unique_block_desc)\n\n    # Now display the filtered names, descriptions, and counts\n    key_list = list(counts.keys())\n    values_list = list(counts.values())\n    uniq_desc = list(filtered_block_desc)\n\n    # Get maximum lengths for string display\n    key_list_length = [len(string) for string in key_list]\n    block_desc_length = [len(string) for string in uniq_desc]\n\n    max_length_desc = max(block_desc_length)\n    max_length_names = max(key_list_length)\n\n    pt = rs.GetPoint(\"Pick Point\")\n    text_height = rs.GetReal(\"Text_Height\", 0.1)\n    if text_height is None:\n        return\n\n    # Spacings\n    spacingy = text_height *2\n    spacingx_name = max_length_names * text_height * 1.7\n    spacingx_desc = (max_length_names * text_height) + (max_length_desc * text_height * 1.4)+0.8\n    spacingx_amt = spacingx_desc *1.2\n\n    vector_y = Rhino.Geometry.Vector3d(0, -spacingy, 0)\n    vector_x_names = Rhino.Geometry.Vector3d(spacingx_name, 0, 0)\n    vector_x_desc = Rhino.Geometry.Vector3d(spacingx_desc, 0, 0)\n    vector_x_amt = Rhino.Geometry.Vector3d(spacingx_amt, 0, 0)\n    pg_num_vector = Rhino.Geometry.Vector3d(spacingx_name + (text_height * 3), 0, 0)\n\n    # Define the x direction\n    x_dir = pt + vector_x_names\n    x_dir_desc = pt + vector_x_desc\n    blk_amt = pt + vector_x_amt\n\n    vector_x_names.Unitize()  # Unitize the vector\n    length = spacingx_name\n    scaled_vector = vector_x_names * length * 0.8\n\n    left = []\n    left_middle = []\n    right_middle = []\n    right = []\n\n    \n\n    #Title block\n    \n    global_text_offset=Rhino.Geometry.Vector3d(text_height*1.02,0,0)\n\n    #store headers in a list\n    headers=[\"ITEMS\",\"PART NO\",\"PART_DESC\",\"QTY\"]\n\n    #ITEM\n    item_offset=-0.05\n    item_pt=pt+Rhino.Geometry.Vector3d(item_offset,0,0)-(vector_y/2)\n    #rs.AddPoint(item_pt)\n\n    rs.AddText(\"ITEM\",item_pt,text_height,font,justification=131076)\n\n\n    #PART NO\n    \n    title_block_pts=(pt-(vector_y/2))+Rhino.Geometry.Vector3d(text_height*1.02,0,0)\n    #rs.AddPoint(title_block_pts)\n\n    item_name=rs.AddText(\"PART NO\",title_block_pts,text_height,font,justification=131073)\n\n    #PART DESCR\n    part_desc_pt=(x_dir_desc-(vector_y/2))-global_text_offset\n    #rs.AddPoint(part_desc_pt)\n\n    part_descr_name=rs.AddText(\"PART DESCR\",part_desc_pt,text_height,font,justification=131076)\n\n    #QTY\n    quantity_pt=blk_amt-(vector_y/2)-global_text_offset\n    #rs.AddPoint(quantity_pt)\n\n    quantity_name=rs.AddText(\"QTY\",quantity_pt,text_height,font,justification=131076)\n\n\n    #Lines for title blocks\n    #Top lines\n    item_ln_offset=(-4*text_height)*((item_offset*-1)+1)\n\n    pt_1=pt-vector_y\n    #rs.AddPoint(pt_1)\n    pt_2=blk_amt-vector_y\n    #rs.AddPoint(pt_2)\n\n    #Header\n    header_pt=blk_amt-vector_y\n    \n\n    print(pt_2-(pt_1+Rhino.Geometry.Vector3d(item_ln_offset,0,0)))\n\n    header_pt=rs.AddPoint((pt_1+Rhino.Geometry.Vector3d(item_ln_offset,0,0))+((pt_2-(pt_1+Rhino.Geometry.Vector3d(item_ln_offset,-0.5,0)))/2))\n\n    header_text=rs.StringBox(message=\"Bill of Materials Header Name\", default_value=None, title=\"BOM Header\")\n\n    rs.AddText(header_text.upper(),header_pt,0.1,justification=2)\n\n    #rs.AddPoint(pt_1+Rhino.Geometry.Vector3d(item_ln_offset,0,0))\n    \n    #top horizontial line\n    rs.AddLine(pt_1+Rhino.Geometry.Vector3d(item_ln_offset,0,0),pt_2)\n\n    #vertial lines\n    \n    rs.AddLine(pt_1,pt+(vector_y/2))\n\n    rs.AddLine(x_dir_desc+(vector_y/2),x_dir_desc-(vector_y))\n\n    rs.AddLine(blk_amt+(vector_y/2),blk_amt-vector_y)\n    \n    #rs.AddLine()\n\n    \n    \n\n    items_number=[]\n    Left_horiz_ln=[]\n\n    item_num_csv=[]\n    block_names=[]\n    block_description=[]\n    block_amounts=[]\n\n    # Add text for block names\n    for items in key_list:\n        pt += vector_y\n        \n        new_pt=pt+Rhino.Geometry.Vector3d(item_ln_offset,0,0)+(vector_y/2)\n        Left_horiz_ln.append((pt+Rhino.Geometry.Vector3d(item_ln_offset,0,0)+(vector_y/2)))\n\n        \n\n        items_number.append(pt)\n\n        \n\n\n        \n\n        # Horizontial Line Bottom\n        offset_y = Rhino.Geometry.Vector3d(0, (spacingy / 2), 0)\n        \n        bottom_crv=rs.AddLine(new_pt,pt+vector_x_amt-offset_y)\n\n        # Horizontial Line Top\n        transform=Rhino.Geometry.Transform.Translation(offset_y*2)\n        \n        top_crv=rs.coercecurve(bottom_crv)\n        top_crv.Transform(transform)\n\n        sc.doc.Objects.AddCurve(top_crv)\n        # Left Line\n        l = rs.AddLine((pt + offset_y), (pt - offset_y))\n        left.append(l)\n\n        # Left Middle Line\n        \n        lm = rs.AddLine((pt + scaled_vector + offset_y), (pt + scaled_vector - offset_y))\n        \n        left_middle.append(lm)\n\n        # Add text\n        offset_pt=pt+Rhino.Geometry.Vector3d(text_height*1.02,0,0)\n        rs.AddText(items.upper(), offset_pt, text_height,font, justification=131073)\n        block_names.append(items.upper())\n\n\n    rs.AddPolyline(Left_horiz_ln)\n    rs.AddLine(pt_1+Rhino.Geometry.Vector3d(item_ln_offset,0,0),Left_horiz_ln[0])\n\n    total=len(items_number)\n    total_numbers=[]\n    total_pts=[]\n\n    #Numbers for items numbers\n    for i in range(1,total+1):\n        total_numbers.append(i)\n\n    \n    #print(total_numbers)\n    \n    #Item numbers\n    for item in items_number:\n        offset_x=Rhino.Geometry.Vector3d(item_offset,0,0)\n        \n        pt=item+offset_x\n        #rs.AddPoint(pt)\n        total_pts.append(pt)\n    \n    for point,num in zip(total_pts,total_numbers):\n        rs.AddText(num,point,text_height,font,justification=131076)\n        item_num_csv.append(num)\n\n     \n\n    # Add text for block descriptions\n    for i in uniq_desc:\n        x_dir_desc += vector_y\n        #rs.AddPoint(x_dir_desc)\n        \n\n        # Right Middle Line\n        rm = rs.AddLine((x_dir_desc + offset_y), (x_dir_desc - offset_y))\n        right_middle.append(rm)\n\n        offset_desc=x_dir_desc-global_text_offset\n        rs.AddText(i.upper(), offset_desc, text_height,font, justification=131076)\n        block_description.append(i.upper())\n\n    # Add text for block counts\n    for items in values_list:\n        blk_amt += vector_y\n\n        # Right Line\n        r = rs.AddLine((blk_amt - (vector_y / 2)), (blk_amt + (vector_y / 2)))\n        right.append(r)\n\n        #rs.AddPoint(blk_amt)\n\n        offset_count=blk_amt-global_text_offset\n        rs.AddText(items, offset_count, text_height, font, justification=131076)\n        block_amounts.append(items)\n\n    # Join left middle side of curves and simplify\n    if len(left_middle) != 1:\n        a = rs.JoinCurves(left_middle, True)\n        rs.SimplifyCurve(a)\n        c=rs.coercecurve(a)\n        start_pt=c.PointAtStart\n        x=Rhino.Geometry.Line(start_pt,vector_y,spacingy*-1.5)\n        \n\n        sc.doc.Objects.AddCurve(Rhino.Geometry.LineCurve(x))\n        \n\n    # Join left side of curves and simplify\n    if len(left) != 1:\n        a = rs.JoinCurves(left, True)\n        rs.SimplifyCurve(a)\n        \n\n    # Join right middle side of curves and simplify\n    if len(right_middle) != 1:\n        a = rs.JoinCurves(right_middle, True)\n        rs.SimplifyCurve(a)\n        \n\n    \n\n    # Join right side of curves and simplify\n    if len(right) != 1:\n        a = rs.JoinCurves(right, True)\n        rs.SimplifyCurve(a)\n        \n    #print(item_num_csv, block_names,block_description,block_amounts)\n\n    export_options = (\"Export_as_CSV\",\"No\",\"Yes\")\n    export_csv = rs.GetBoolean(\"Export as CSV?\", export_options, False)\n\n    if export_csv == [True]:\n\n\n        #Excel exporting\n        combined_lists=[item_num_csv, block_names,block_description,block_amounts]\n\n        export = [list(row) for row in zip(*combined_lists)]\n        #print(export)\n\n        #Empty string\n        csv_data=\"\"\n\n        #for each string in export, add a comma and convert to string\n        for string in export:\n            \n                \n                \n            row=\",\".join(map(str,string))\n            \n\n            #add to empty string\n            csv_data+=row+\"\\n\"\n        \n        #print(csv_data)\n\n        filepath=rs.SaveFileName(\"Save CSV\",\"CSV Files (*.csv)|*.csv||\")\n        \n        if filepath is None:\n            return\n        else:\n            with open(filepath,'w') as file:\n                file.write(csv_data)\n            print(\"File has been saved to\",filepath)\n    else:\n        return\n        \n    \n\n\nif results == [True]:\n    # Check if BOM layer exists in document\n    if not rs.IsLayer(\"BOM\"):\n        print(\"Make BOM Layer\")\n    else:\n    \n        if rs.IsLayerEmpty(\"BOM\")==True:\n            print(\"Layer is empty\")\n            sys.exit()\n        else:\n            # Read from the Layer BOM\n            layername = rs.LayerName(\"BOM\")\n\n            # Get objects by layer name\n            layer = rs.ObjectsByLayer(layername, True)\n\n            # Run the function\n            block_list_count()\n    \n\n\nelse:\n    # Get all blocks from Rhino Environment\n    layer = rs.ObjectsByType(4096)\n    block_list_count()\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "point", "layer", "line", "curve", "functions", "block", "RhinoCommon"], "original_file": "ccheng-design_Ptarmigan_01c5bd8379.json", "repo": "ccheng-design/Ptarmigan"}
{"instruction": "Represents the type of a brep loop.", "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport Rhino  # type: ignore\n\nfrom compas.geometry import BrepLoop\n\nfrom .edge import RhinoBrepEdge\nfrom .trim import RhinoBrepTrim\n\n\nclass LoopType(object):\n    \"\"\"Represents the type of a brep loop.\n\n    Attributes\n    ----------\n    UNKNOWN\n    OUTER\n    INNTER\n    SLIT\n    CURVE_ON_SURFACE\n    POINT_ON_SURFACE\n\n    \"\"\"\n\n    UNKNOWN = 0\n    OUTER = 1\n    INNTER = 2\n    SLIT = 3\n    CURVE_ON_SURFACE = 4\n    POINT_ON_SURFACE = 5\n\n\nclass RhinoBrepLoop(BrepLoop):\n    \"\"\"A wrapper for Rhino.Geometry.BrepLoop\n\n    Attributes\n    ----------\n    edges : list[:class:`compas_rhino.geometry.RhinoBrepEdge`], read-only\n        The list of edges which comprise this loop.\n    trims : list[:class:`compas_rhino.geometry.RhinoBrepTrim`], read-only\n        The list of trims which comprise this loop.\n    loop_type : :class:`compas_rhino.geometry.brep.loop.LoopType`, read-only\n        The type of this loop.\n    is_outer : bool, read-only\n        True if this loop is an outer boundary, False otherwise.\n    is_inner : bool, read-only\n        True if this loop is an inner hole, False otherwise.\n    native_loop : :class:`Rhino.Geometry.BrepLoop`\n        The underlying Rhino BrepLoop object.\n\n    \"\"\"\n\n    def __init__(self, rhino_loop=None):\n        super(RhinoBrepLoop, self).__init__()\n        self._loop = None\n        self._type = LoopType.UNKNOWN\n        self._trims = None\n        self._type = None\n        if rhino_loop:\n            self.native_loop = rhino_loop\n\n    # ==============================================================================\n    # Data\n    # ==============================================================================\n\n    @property\n    def __data__(self):\n        return {\"type\": str(self._loop.LoopType), \"trims\": [t.__data__ for t in self._trims]}\n\n    @classmethod\n    def __from_data__(cls, data, builder):\n        \"\"\"Construct an object of this type from the provided data.\n\n        Parameters\n        ----------\n        data : dict\n            The data dictionary.\n        builder : :class:`compas_rhino.geometry.BrepFaceBuilder`\n            The object reconstructing the current BrepFace.\n\n        Returns\n        -------\n        :class:`compas.data.Data`\n            An instance of this object type if the data contained in the dict has the correct schema.\n\n        \"\"\"\n        instance = cls()\n        instance._type = Rhino.Geometry.BrepLoopType.Outer if data[\"type\"] == \"Outer\" else Rhino.Geometry.BrepLoopType.Inner\n        loop_builder = builder.add_loop(instance._type)\n        for trim_data in data[\"trims\"]:\n            RhinoBrepTrim.__from_data__(trim_data, loop_builder)\n        instance.native_loop = loop_builder.result\n        return instance\n\n    # ==============================================================================\n    # Properties\n    # ==============================================================================\n\n    @property\n    def edges(self):\n        return [RhinoBrepEdge(trim.Edge) for trim in self._loop.Trims]\n\n    @property\n    def trims(self):\n        return self._trims\n\n    @property\n    def is_outer(self):\n        return self._type == LoopType.OUTER\n\n    @property\n    def is_inner(self):\n        return self._type == LoopType.INNTER\n\n    @property\n    def loop_type(self):\n        return Rhino.Geometry.BrepLoopType(self._type)\n\n    @property\n    def native_loop(self):\n        return self._loop\n\n    @native_loop.setter\n    def native_loop(self, rhino_loop):\n        self._loop = rhino_loop\n        self._type = int(self._loop.LoopType)\n        self._trims = [RhinoBrepTrim(trim) for trim in self._loop.Trims]\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "classes", "point", "brep", "curve", "functions", "RhinoCommon"], "original_file": "compas-dev_compas_05251ef47c.json", "repo": "compas-dev/compas"}
{"instruction": "Trims hold topological information about how the edges of a Brep face are are organized.", "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport Rhino  # type: ignore\n\nfrom compas.geometry import BrepTrim\nfrom compas_rhino.geometry import RhinoNurbsCurve\n\nfrom .vertex import RhinoBrepVertex\n\n\nclass RhinoBrepTrim(BrepTrim):\n    \"\"\"Trims hold topological information about how the edges of a Brep face are are organized.\n\n    Attributes\n    ----------\n    curve : :class:`compas.geometry.NurbsCurve`, read_only\n        Returns the geometry for this trim as a 2d curve.\n    iso_status : literal(NONE|X|Y|West|South|East|North)\n        The isoparametric curve direction on the surface.\n    is_reversed : bool\n        True if this trim is reversed from its associated edge curve and False otherwise.\n    native_trim : :class:`Rhino.Geometry.BrepTrim`\n        The underlying Rhino BrepTrim object.\n    start_vertex : :class:`compas_rhino.geometry.RhinoBrepVertex`, read-only\n        The start vertex of this trim.\n    end_vertex : :class:`compas_rhino.geometry.RhinoBrepVertex`, read-only\n        The end vertex of this trim.\n    vertices : list[:class:`compas_rhino.geometry.RhinoBrepVertex`], read-only\n        The list of vertices which comprise this trim (start and end).\n\n    \"\"\"\n\n    def __init__(self, rhino_trim=None):\n        super(RhinoBrepTrim, self).__init__()\n        self._trim = None\n        self._curve = None\n        self._is_reversed = None\n        self._iso_type = None\n        self._start_vertex = None\n        self._end_vertex = None\n        if rhino_trim:\n            self.native_trim = rhino_trim\n\n    # ==============================================================================\n    # Data\n    # ==============================================================================\n\n    @property\n    def __data__(self):\n        return {\n            \"start_vertex\": self._trim.StartVertex.VertexIndex,\n            \"end_vertex\": self._trim.EndVertex.VertexIndex,\n            \"edge\": self._trim.Edge.EdgeIndex if self._trim.Edge else -1,  # singular trims have no associated edge\n            \"curve\": RhinoNurbsCurve.from_rhino(self._trim.TrimCurve.ToNurbsCurve()).__data__,\n            \"iso\": str(self._trim.IsoStatus),\n            \"is_reversed\": \"true\" if self._trim.IsReversed() else \"false\",\n        }\n\n    @classmethod\n    def __from_data__(cls, data, builder):\n        \"\"\"Construct an object of this type from the provided data.\n\n        Parameters\n        ----------\n        data : dict\n            The data dictionary.\n        builder : :class:`compas_rhino.geometry.BrepLoopBuilder`\n            The object reconstructing the current BrepLoop.\n\n        Returns\n        -------\n        :class:`compas.data.Data`\n            An instance of this object type if the data contained in the dict has the correct schema.\n\n        \"\"\"\n        instance = cls()\n        curve = RhinoNurbsCurve.__from_data__(data[\"curve\"]).rhino_curve\n        try:\n            iso_status = getattr(Rhino.Geometry.IsoStatus, data[\"iso\"])\n        except AttributeError:\n            # due to discrepancy in how IsoStatus.None looks like in Rhino7 vs Rhino8 (`IsoStatus.NONE`)\n            iso_status = Rhino.Geometry.IsoStatus.NONE\n        is_reversed = True if data[\"is_reversed\"] == \"true\" else False\n        instance.native_trim = builder.add_trim(curve, data[\"edge\"], is_reversed, iso_status, data[\"start_vertex\"])\n        return instance\n\n    # ==============================================================================\n    # Properties\n    # ==============================================================================\n\n    @property\n    def curve(self):\n        return self._curve\n\n    @property\n    def start_vertex(self):\n        return self._start_vertex\n\n    @property\n    def end_vertex(self):\n        return self._end_vertex\n\n    @property\n    def vertices(self):\n        return [self.start_vertex, self.end_vertex]\n\n    @property\n    def is_reverse(self):\n        return self._curve\n\n    @property\n    def iso_status(self):\n        return self._iso_type\n\n    @property\n    def native_trim(self):\n        return self._trim\n\n    @native_trim.setter\n    def native_trim(self, rhino_trim):\n        self._trim = rhino_trim\n        self._curve = RhinoNurbsCurve.from_rhino(rhino_trim.TrimCurve.ToNurbsCurve())\n        self._is_reversed = rhino_trim.IsReversed()\n        self._iso_type = int(rhino_trim.IsoStatus)\n        self._start_vertex = RhinoBrepVertex(rhino_trim.StartVertex)\n        self._end_vertex = RhinoBrepVertex(rhino_trim.EndVertex)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "classes", "brep", "curve", "functions", "RhinoCommon"], "original_file": "compas-dev_compas_05a2e09806.json", "repo": "compas-dev/compas"}
{"instruction": "Implement the function 'toggle_toolbargroup' for Rhino scripting", "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\n\nimport rhinoscriptsyntax as rs  # type: ignore\n\n\ndef toggle_toolbargroup(rui, group):\n    if not os.path.exists(rui) or not os.path.isfile(rui):\n        return\n    collection = rs.IsToolbarCollection(rui)\n    if not collection:\n        collection = rs.OpenToolbarCollection(rui)\n        if rs.IsToolbar(collection, group, True):\n            rs.ShowToolbar(collection, group)\n    else:\n        if rs.IsToolbar(collection, group, True):\n            if rs.IsToolbarVisible(collection, group):\n                rs.HideToolbar(collection, group)\n            else:\n                rs.ShowToolbar(collection, group)\n\n\ndef pick_point(message=\"Pick a point.\"):\n    point = rs.GetPoint(message)\n    if point:\n        return list(point)\n    return None\n\n\ndef browse_for_folder(message=None, default=None):\n    return rs.BrowseForFolder(folder=default, message=message, title=\"compas\")\n\n\nselect_folder = browse_for_folder\n\n\ndef browse_for_file(title=None, folder=None, filter=None):\n    if filter == \"json\":\n        filter = \"JSON files (*.json)|*.json||\"\n    elif filter == \"obj\":\n        filter = \"OBJ files (*.obj)|*.obj||\"\n    elif filter == \"fofin\":\n        filter = \"FOFIN session files (*.fofin)|*.fofin||\"\n    else:\n        pass\n    return rs.OpenFileName(title, filter=filter, folder=folder)\n\n\nselect_file = browse_for_file\n\n\ndef print_display_on(on=True):\n    if on:\n        rs.Command(\"_PrintDisplay State On Color Display Thickness 1 _Enter\")\n    else:\n        rs.Command(\"_PrintDisplay State Off _Enter\")\n\n\n# def display_message(message):\n#     return ShowMessageBox(message, \"Message\")\n\n\n# def display_text(text, title=\"Text\", width=800, height=600):\n#     if isinstance(text, (list, tuple)):\n#         text = \"{0}\".format(System.Environment.NewLine).join(text)\n#     form = TextForm(text, title, width, height)\n#     return form.show()\n\n\n# def display_image(image, title=\"Image\", width=800, height=600):\n#     form = ImageForm(image, title, width, height)\n#     return form.show()\n\n\n# def display_html():\n#     raise NotImplementedError\n\n\n# ==============================================================================\n# Settings and attributes\n# ==============================================================================\n\n\n# def update_named_values(names, values, message=\"\", title=\"Update named values\", evaluate=False):\n#     values = ShowPropertyListBox(message, title, names, values)\n#     if evaluate:\n#         if values:\n#             values = list(values)\n#             for i in range(len(values)):\n#                 value = values[i]\n#                 try:\n#                     value = ast.literal_eval(value)\n#                 except (TypeError, ValueError, SyntaxError):\n#                     pass\n#                 values[i] = value\n#     return values\n\n\n# def update_settings(settings, message=\"\", title=\"Update settings\"):\n#     names = sorted(settings.keys())\n#     values = [str(settings[name]) for name in names]\n#     values = update_named_values(names, values, message=message, title=title)\n#     if values:\n#         values = list(values)\n#         for name, value in zip(names, values):\n#             try:\n#                 settings[name] = ast.literal_eval(value)\n#             except (TypeError, ValueError, SyntaxError):\n#                 settings[name] = value\n#         return True\n#     return False\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "line", "functions", "point"], "original_file": "compas-dev_compas_0a20fe2876.json", "repo": "compas-dev/compas"}
{"instruction": "Base class for conduits.", "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport time\nfrom contextlib import contextmanager\n\nimport Rhino  # type: ignore\nimport scriptcontext as sc  # type: ignore\n\n\nclass BaseConduit(Rhino.Display.DisplayConduit):\n    \"\"\"Base class for conduits.\n\n    Parameters\n    ----------\n    refreshrate : int, optional\n        The number of iterations after which the conduit should be redrawn.\n\n    \"\"\"\n\n    def __init__(self, refreshrate=1):\n        super(BaseConduit, self).__init__()\n        self.refreshrate = refreshrate\n\n    @contextmanager\n    def enabled(self):\n        \"\"\"Create a context for the conduit with automatic enabling and disabling.\n\n        Yields\n        ------\n        None\n\n        Notes\n        -----\n        The conduit is automatically enabled when the context is entered,\n        and is guaranteed to be disabled when the context is exited,\n        even when an error occurs during the execution of the code in the context.\n\n        Examples\n        --------\n        .. code-block:: python\n\n            with conduit.enabled():\n                for i in range(10):\n                    conduit.redraw(k=1)\n\n        \"\"\"\n        self.enable()\n        try:\n            yield\n        except Exception as e:\n            print(e)\n        finally:\n            self.disable()\n\n    def CalculateBoundingBox(self, e):\n        \"\"\"Calculate the model extents that should be included in the visualization.\n\n        Parameters\n        ----------\n        e : Rhino.DisplayCalculateBoundingBoxEventArgs\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        bbox = Rhino.Geometry.BoundingBox(-1000, -1000, -1000, 1000, 1000, 1000)\n        e.IncludeBoundingBox(bbox)\n\n    def enable(self):\n        \"\"\"Enable the conduit.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        self.Enabled = True\n\n    def disable(self):\n        \"\"\"Disable the conduit.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        self.Enabled = False\n\n    def redraw(self, k=0, pause=0.0):\n        \"\"\"Redraw the conduit.\n\n        Parameters\n        ----------\n        k : int, optional\n            The current iteration.\n            If the current iteration is a multiple of :attr:`BaseConduit.refreshrate`, the conduit will be redrawn.\n        pause : float, optional\n            Include a pause after redrawing.\n            The pause value should be provided in seconds.\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            If `pause` is not a positive number.\n\n        \"\"\"\n        if pause < 0:\n            raise ValueError(\"The value of pause should be a positive number.\")\n\n        if k % self.refreshrate == 0:\n            sc.doc.Views.Redraw()\n        Rhino.RhinoApp.Wait()\n        if pause:\n            time.sleep(pause)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["block", "classes", "functions", "RhinoCommon"], "original_file": "compas-dev_compas_138d69325a.json", "repo": "compas-dev/compas"}
{"instruction": "A wrapper for Rhino.Geometry.BrepFace", "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport Rhino  # type: ignore\n\nfrom compas.geometry import Brep\nfrom compas.geometry import BrepFace\nfrom compas.geometry import Cylinder\nfrom compas.geometry import Frame\nfrom compas.geometry import Sphere\nfrom compas.geometry import SurfaceType\nfrom compas_rhino.conversions import cylinder_to_compas\nfrom compas_rhino.conversions import cylinder_to_rhino\nfrom compas_rhino.conversions import frame_to_rhino_plane\nfrom compas_rhino.conversions import plane_to_compas_frame\nfrom compas_rhino.conversions import sphere_to_compas\nfrom compas_rhino.conversions import sphere_to_rhino\nfrom compas_rhino.geometry import RhinoNurbsSurface\nfrom compas_rhino.geometry.surfaces import RhinoSurface\n\nfrom .edge import RhinoBrepEdge\nfrom .loop import RhinoBrepLoop\n\n\nclass RhinoBrepFace(BrepFace):\n    \"\"\"A wrapper for Rhino.Geometry.BrepFace\n\n    Attributes\n    ----------\n    native_surface : :class:`Rhino.Geometry.Surface`\n        The rhino native underlying geometry of this face.\n    loops : list[:class:`compas_rhino.geometry.RhinoBrepLoop`], read-only\n        The list of loops which comprise this face.\n    surface : :class:`compas_rhino.geometry.RhinoNurbsSurface`\n        The compas_rhino wrapper of the underlying geometry of this face.\n    boundary : :class:`compas_rhino.geometry.RhinoBrepLoop`, read-only\n        The loop which defines the outer boundary of this face.\n    holes : list[:class:`compas_rhino.geometry.RhinoBrepLoop`], read-only\n        The list of loops which comprise the holes of this brep, if any.\n    is_plane : float, read-only\n        True if the geometry of this face is a plane, False otherwise.\n    is_reversed : bool, read-only\n        True if the orientation of this face is reversed, False otherwise.\n    native_face : :class:`Rhino.Geometry.BrepFace`\n        The underlying BrepFace object.\n\n    \"\"\"\n\n    def __init__(self, rhino_face=None):\n        super(RhinoBrepFace, self).__init__()\n        self._loops = None\n        self._surface = None\n        self._face = None\n        if rhino_face:\n            self.native_face = rhino_face\n\n    # ==============================================================================\n    # Data\n    # ==============================================================================\n\n    @property\n    def __data__(self):\n        surface_type, surface, uv_domain, plane = self._get_surface_geometry(self._face.UnderlyingSurface())\n        return {\n            \"surface_type\": surface_type,\n            \"surface\": surface.__data__,\n            \"uv_domain\": uv_domain,\n            \"frame\": plane_to_compas_frame(plane).__data__,  # until all shapes have a frame\n            \"loops\": [loop.__data__ for loop in self._loops],\n        }\n\n    @classmethod\n    def __from_data__(cls, data, builder):\n        \"\"\"Construct an object of this type from the provided data.\n\n        Parameters\n        ----------\n        data : dict\n            The data dictionary.\n        builder : :class:`compas_rhino.geometry.BrepBuilder`\n            The object reconstructing the current Brep.\n\n        Returns\n        -------\n        :class:`compas.data.Data`\n            An instance of this object type if the data contained in the dict has the correct schema.\n\n        \"\"\"\n\n        instance = cls()\n        instance._surface = instance._make_surface__from_data__(data[\"surface_type\"], data[\"surface\"], data[\"uv_domain\"], data[\"frame\"])\n        face_builder = builder.add_face(instance._surface)\n        for loop_data in data[\"loops\"]:\n            RhinoBrepLoop.__from_data__(loop_data, face_builder)\n        instance.native_face = face_builder.result\n        return instance\n\n    # ==============================================================================\n    # Properties\n    # ==============================================================================\n\n    @property\n    def native_surface(self):\n        return self._surface\n\n    @property\n    def area(self):\n        return self._mass_props.Area\n\n    @property\n    def centroid(self):\n        return self._mass_props.Centroid\n\n    @property\n    def edges(self):\n        brep = self._face.Brep\n        edge_indices = self._face.AdjacentEdges()\n        return [RhinoBrepEdge(brep.Edges[index]) for index in edge_indices]\n\n    @property\n    def loops(self):\n        return self._loops\n\n    @property\n    def surface(self):\n        return self._surface\n\n    @property\n    def boundary(self):\n        return self._loops[0]\n\n    @property\n    def holes(self):\n        return self._loops[1:]\n\n    @property\n    def is_plane(self):\n        return self._face.UnderlyingSurface().IsPlanar()\n\n    @property\n    def is_cone(self):\n        return self._face.UnderlyingSurface().IsCone()\n\n    @property\n    def is_cylinder(self):\n        return self._face.UnderlyingSurface().IsCylinder()\n\n    @property\n    def is_sphere(self):\n        return self._face.UnderlyingSurface().IsSphere()\n\n    @property\n    def is_torus(self):\n        return self._face.UnderlyingSurface().IsTorus()\n\n    @property\n    def is_reversed(self):\n        return self._face.OrientationIsReversed\n\n    @property\n    def native_face(self):\n        return self._face\n\n    @native_face.setter\n    def native_face(self, rhino_face):\n        self._face = rhino_face\n        self._mass_props = Rhino.Geometry.AreaMassProperties.Compute(rhino_face.ToBrep())\n        self._loops = [RhinoBrepLoop(loop) for loop in rhino_face.Loops]\n        self._surface = RhinoNurbsSurface.from_rhino(self._face.UnderlyingSurface().ToNurbsSurface())\n\n    @property\n    def nurbssurface(self):\n        return self._surface\n\n    @property\n    def vertices(self):\n        vertices = []\n        for edge in self.edges:\n            vertices.extend(edge.vertices)\n        return vertices\n\n    @property\n    def type(self):\n        if self.is_cone:\n            return SurfaceType.CONE\n        elif self.is_cylinder:\n            return SurfaceType.CYLINDER\n        elif self.is_sphere:\n            return SurfaceType.SPHERE\n        elif self.is_torus:\n            return SurfaceType.TORUS\n        elif self.is_plane:\n            return SurfaceType.PLANE\n        else:\n            return SurfaceType.OTHER_SURFACE\n\n    # ==============================================================================\n    # Methods\n    # ==============================================================================\n\n    @staticmethod\n    def _get_surface_geometry(surface):\n        uv_domain = [[surface.Domain(0)[0], surface.Domain(0)[1]], [surface.Domain(1)[0], surface.Domain(1)[1]]]\n        if isinstance(surface, Rhino.Geometry.PlaneSurface):\n            _, plane = surface.FrameAt(0.0, 0.0)\n            return \"plane\", plane_to_compas_frame(plane), uv_domain, plane\n        if isinstance(surface, Rhino.Geometry.NurbsSurface):\n            _, plane = surface.FrameAt(0.0, 0.0)\n            return \"nurbs\", RhinoNurbsSurface.from_rhino(surface), uv_domain, plane\n        if isinstance(surface, Rhino.Geometry.RevSurface):\n            success, cast_surface = surface.TryGetSphere()\n            if success:\n                return \"sphere\", sphere_to_compas(cast_surface), uv_domain, cast_surface.EquatorialPlane\n            success, cast_surface = surface.TryGetCylinder()\n            if success:\n                return \"cylinder\", cylinder_to_compas(cast_surface), uv_domain, cast_surface.BasePlane\n            success, cast_surface = surface.TryGetTorus()\n        raise NotImplementedError(\"Support for surface type: {} is not yet implemented.\".format(surface.__class__.__name__))\n\n    def _make_surface__from_data__(self, surface_type, surface_data, uv_domain, frame_data):\n        u_domain, v_domain = uv_domain\n        frame = Frame.__from_data__(frame_data)  # workaround until all shapes have a frame\n        if surface_type == \"plane\":\n            frame = Frame.__from_data__(surface_data)  # redundancy in shapes which already have a frame\n            surface = RhinoSurface.from_frame(frame, u_domain, v_domain)\n        elif surface_type == \"sphere\":\n            sphere = self._make_sphere_surface(surface_data, u_domain, v_domain, frame)\n            surface = RhinoSurface.from_rhino(sphere)\n        elif surface_type == \"cylinder\":\n            cylinder = self._make_cylinder_surface(surface_data, u_domain, v_domain, frame)\n            surface = RhinoSurface.from_rhino(cylinder)\n        elif surface_type == \"nurbs\":\n            surface = RhinoNurbsSurface.__from_data__(surface_data)\n        elif surface_type == \"torus\":\n            raise NotImplementedError(\"Support for torus surface is not yet implemented!\")\n        else:\n            raise NotImplementedError(\"Support for surface type: {} is not yet implemented.\".format(surface_type))\n        surface.rhino_surface.SetDomain(0, Rhino.Geometry.Interval(*u_domain))\n        surface.rhino_surface.SetDomain(1, Rhino.Geometry.Interval(*v_domain))\n        return surface\n\n    @staticmethod\n    def _make_cylinder_surface(surface_data, u_domain, v_domain, frame):\n        cylinder = Cylinder.__from_data__(surface_data)\n        cylinder = cylinder_to_rhino(cylinder)\n        cylinder.BasePlane = frame_to_rhino_plane(frame)\n        surface = Rhino.Geometry.RevSurface.CreateFromCylinder(cylinder)\n        surface.SetDomain(0, Rhino.Geometry.Interval(*u_domain))\n        surface.SetDomain(1, Rhino.Geometry.Interval(*v_domain))\n        return surface\n\n    @staticmethod\n    def _make_sphere_surface(surface_data, u_domain, v_domain, frame):\n        sphere = Sphere.__from_data__(surface_data)\n        sphere = sphere_to_rhino(sphere)\n        # seems Sphere => Rhino.Geometry.RevSurface conversion modifies the orientation of the sphere\n        # setting the plane here is overriden by this modification and surface ends up oriented differntly than\n        # original.\n        # sphere.EquatorialPlane = frame_to_rhino_plane(frame)\n        surface = Rhino.Geometry.RevSurface.CreateFromSphere(sphere)\n        surface.SetDomain(0, Rhino.Geometry.Interval(*u_domain))\n        surface.SetDomain(1, Rhino.Geometry.Interval(*v_domain))\n        return surface\n\n    # ==============================================================================\n    # Methods\n    # ==============================================================================\n\n    def adjacent_faces(self):\n        \"\"\"Returns a list of the faces adjacent to this face.\n\n        Returns\n        -------\n        list[:class:`compas_rhino.geometry.RhinoBrepFace`]\n            The list of adjacent faces.\n\n        \"\"\"\n        face_indices = self._face.AdjacentFaces()\n        brep = self._face.Brep\n        return [RhinoBrepFace(brep.Faces[index]) for index in face_indices]\n\n    def as_brep(self):\n        \"\"\"Returns a Brep representation of this face.\n\n        Returns\n        -------\n        :class:`~compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        return Brep.from_native(self._face.ToBrep())\n\n    def frame_at(self, u, v):\n        \"\"\"Returns the frame at the given uv parameters.\n\n        Parameters\n        ----------\n        u : float\n            The u parameter.\n        v : float\n            The v parameter.\n\n        Returns\n        -------\n        :class:`compas.geometry.Frame`\n            The frame at the given uv parameters.\n\n        \"\"\"\n        success, rhino_plane = self._face.FrameAt(u, v)\n        if not success:\n            raise ValueError(\"Failed to get frame at uv parameters: ({},{}).\".format(u, v))\n        return plane_to_compas_frame(rhino_plane)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "classes", "brep", "functions", "RhinoCommon"], "original_file": "compas-dev_compas_284e294cf6.json", "repo": "compas-dev/compas"}
{"instruction": "Class representing a NURBS surface.", "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom itertools import groupby\n\nimport Rhino.Geometry  # type: ignore\n\nfrom compas.geometry import NurbsSurface\nfrom compas.geometry import knots_and_mults_to_knotvector\nfrom compas.itertools import flatten\nfrom compas_rhino.conversions import cylinder_to_rhino\nfrom compas_rhino.conversions import frame_to_rhino_plane\nfrom compas_rhino.conversions import plane_to_rhino\nfrom compas_rhino.conversions import point_to_compas\nfrom compas_rhino.conversions import point_to_rhino\nfrom compas_rhino.conversions import sphere_to_rhino\n\nfrom .surface import RhinoSurface\n\n\nclass ControlPoints(object):\n    def __init__(self, surface):\n        self.native_surface = surface\n\n    @property\n    def points(self):\n        points = []\n        for i in range(self.native_surface.Points.CountU):\n            row = []\n            for j in range(self.native_surface.Points.CountV):\n                row.append(point_to_compas(self.native_surface.Points.GetControlPoint(i, j).Location))\n            points.append(row)\n        return points\n\n    def __getitem__(self, index):\n        try:\n            u, v = index\n        except TypeError:\n            return self.points[index]\n        else:\n            point = self.native_surface.Points.GetControlPoint(u, v).Location\n            return point_to_compas(point)\n\n    def __setitem__(self, index, point):\n        u, v = index\n        self.native_surface.Points.SetControlPoint(u, v, Rhino.Geometry.ControlPoint(point_to_rhino(point)))\n\n    def __len__(self):\n        return self.native_surface.Points.CountU\n\n    def __iter__(self):\n        return iter(self.points)\n\n\ndef native_surface_from_parameters(\n    points,\n    weights,\n    knots_u,\n    knots_v,\n    mults_u,\n    mults_v,\n    degree_u,\n    degree_v,\n    is_periodic_u=False,\n    is_periodic_v=False,\n):\n    order_u = degree_u + 1\n    order_v = degree_v + 1\n    pointcount_u = len(points)\n    pointcount_v = len(points[0])\n    is_rational = any(weight != 1.0 for weight in flatten(weights))\n    dimensions = 3\n\n    native_surface = Rhino.Geometry.NurbsSurface.Create(\n        dimensions,\n        is_rational,\n        order_u,\n        order_v,\n        pointcount_u,\n        pointcount_v,\n    )\n\n    if not native_surface:\n        message = \"dimensions: {} is_rational: {} order_u: {} order_v: {} u_points: {} v_points: {}\".format(\n            dimensions,\n            is_rational,\n            order_u,\n            order_v,\n            pointcount_u,\n            pointcount_v,\n        )\n        raise ValueError(\"Failed to create NurbsSurface with params:\\n{}\".format(message))\n\n    knotvector_u = knots_and_mults_to_knotvector(knots_u, mults_u)\n    knotvector_v = knots_and_mults_to_knotvector(knots_v, mults_v)\n    # account for superfluous knots\n    # https://developer.rhino3d.com/guides/opennurbs/superfluous-knots/\n    if len(knotvector_u) == pointcount_u + order_u:\n        knotvector_u[:] = knotvector_u[1:-1]\n    if len(knotvector_v) == pointcount_v + order_v:\n        knotvector_v[:] = knotvector_v[1:-1]\n    # add knots\n    for index, knot in enumerate(knotvector_u):\n        native_surface.KnotsU[index] = knot\n    for index, knot in enumerate(knotvector_v):\n        native_surface.KnotsV[index] = knot\n    # add control points\n    for i in range(pointcount_u):\n        for j in range(pointcount_v):\n            native_surface.Points.SetPoint(i, j, point_to_rhino(points[i][j]), weights[i][j])\n    return native_surface\n\n\nclass RhinoNurbsSurface(RhinoSurface, NurbsSurface):\n    \"\"\"Class representing a NURBS surface.\n\n    Attributes\n    ----------\n    points: list[list[:class:`compas.geometry.Point`]]\n        The control points of the surface.\n    weights: list[list[float]]\n        The weights of the control points.\n    knots_u: list[float]\n        The knot vector, in the U direction, without duplicates.\n    knots_v: list[float]\n        The knot vector, in the V direction, without duplicates.\n    mults_u: list[int]\n        The multiplicities of the knots in the knot vector of the U direction.\n    mults_v: list[int]\n        The multiplicities of the knots in the knot vector of the V direction.\n    degree_u: int\n        The degree of the polynomials in the U direction.\n    degree_v: int\n        The degree of the polynomials in the V direction.\n\n    \"\"\"\n\n    # ==============================================================================\n    # Data\n    # ==============================================================================\n\n    @property\n    def __data__(self):\n        # add superfluous knots\n        # for compatibility with all/most other NURBS implementations\n        # https://developer.rhino3d.com/guides/opennurbs/superfluous-knots/\n        mults_u = self.mults_u[:]  # type: ignore\n        mults_v = self.mults_v[:]  # type: ignore\n        mults_u[0] += 1\n        mults_u[-1] += 1\n        mults_v[0] += 1\n        mults_v[-1] += 1\n        return {\n            \"points\": [[point.__data__ for point in row] for row in self.points],  # type: ignore\n            \"weights\": self.weights,\n            \"knots_u\": self.knots_u,\n            \"knots_v\": self.knots_v,\n            \"mults_u\": mults_u,\n            \"mults_v\": mults_v,\n            \"degree_u\": self.degree_u,\n            \"degree_v\": self.degree_v,\n            \"is_periodic_u\": self.is_periodic_u,\n            \"is_periodic_v\": self.is_periodic_v,\n        }\n\n    # ==============================================================================\n    # Properties\n    # ==============================================================================\n\n    @property\n    def points(self):\n        if self.native_surface:\n            if not hasattr(self, \"_points\"):\n                self._points = ControlPoints(self.native_surface)\n            return self._points\n\n    @property\n    def weights(self):\n        if self.native_surface:\n            weights = []\n            for i in range(self.native_surface.Points.CountU):\n                row = []\n                for j in range(self.native_surface.Points.CountV):\n                    row.append(self.native_surface.Points.GetWeight(i, j))\n                weights.append(row)\n            return weights\n\n    @property\n    def knots_u(self):\n        if self.native_surface:\n            return [key for key, _ in groupby(self.native_surface.KnotsU)]\n\n    @property\n    def mults_u(self):\n        if self.native_surface:\n            return [len(list(group)) for _, group in groupby(self.native_surface.KnotsU)]\n\n    @property\n    def knotvector_u(self):\n        if self.native_surface:\n            return list(self.native_surface.KnotsU)\n\n    @property\n    def knots_v(self):\n        if self.native_surface:\n            return [key for key, _ in groupby(self.native_surface.KnotsV)]\n\n    @property\n    def mults_v(self):\n        if self.native_surface:\n            return [len(list(group)) for _, group in groupby(self.native_surface.KnotsV)]\n\n    @property\n    def knotvector_v(self):\n        if self.native_surface:\n            return list(self.native_surface.KnotsV)\n\n    @property\n    def degree_u(self):\n        if self.native_surface:\n            return self.native_surface.Degree(0)\n\n    @property\n    def degree_v(self):\n        if self.native_surface:\n            return self.native_surface.Degree(1)\n\n    # ==============================================================================\n    # Constructors\n    # ==============================================================================\n\n    @classmethod\n    def from_corners(cls, corners):\n        \"\"\"Creates a NURBS surface using the given 4 corners.\n\n        The order of the given points determins the normal direction of the generated surface.\n\n        Parameters\n        ----------\n        corners : list(:class:`compas.geometry.Point`)\n            4 points in 3d space to represent the corners of the planar surface.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        rhino_points = [Rhino.Geometry.Point3d(corner.x, corner.y, corner.z) for corner in corners]\n        return cls.from_native(Rhino.Geometry.NurbsSurface.CreateFromCorners(*rhino_points))\n\n    @classmethod\n    def from_cylinder(cls, cylinder):\n        \"\"\"Create a NURBS surface from a cylinder.\n\n        Parameters\n        ----------\n        cylinder : :class:`compas.geometry.Cylinder`\n            The surface's geometry.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        cylinder = cylinder_to_rhino(cylinder)\n        surface = Rhino.Geometry.NurbsSurface.CreateFromCylinder(cylinder)\n        return cls.from_native(surface)\n\n    @classmethod\n    def from_fill(cls, curve1, curve2):\n        \"\"\"Construct a NURBS surface from the infill between two NURBS curves.\n\n        Parameters\n        ----------\n        curve1 : :class:`compas.geometry.NurbsCurve`\n        curve2 : :class:`compas.geometry.NurbsCurve`\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        native_surface = Rhino.Geometry.NurbsSurface.CreateRuledSurface(curve1, curve2)\n        return cls.from_native(native_surface)\n\n    @classmethod\n    def from_frame(cls, frame, domain_u=(0, 1), domain_v=(0, 1), degree_u=1, degree_v=1, pointcount_u=2, pointcount_v=2):\n        \"\"\"Creates a planar surface from a frame and parametric domain information.\n\n        Parameters\n        ----------\n        frame : :class:`compas.geometry.Frame`\n            A frame with point at the center of the wanted plannar surface and\n            x and y axes the direction of u and v respectively.\n        domain_u : tuple[int, int], optional\n            The domain of the U parameter.\n        domain_v : tuple[int, int], optional\n            The domain of the V parameter.\n        degree_u : int, optional\n            Degree in the U direction.\n        degree_v : int, optional\n            Degree in the V direction.\n        pointcount_u : int, optional\n            Number of control points in the U direction.\n        pointcount_v : int, optional\n            Number of control points in the V direction.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        plane = frame_to_rhino_plane(frame)\n        du = Rhino.Geometry.Interval(*domain_u)\n        dv = Rhino.Geometry.Interval(*domain_v)\n        native_surface = Rhino.Geometry.NurbsSurface.CreateFromPlane(plane, du, dv, degree_u, degree_v, pointcount_u, pointcount_v)\n        return cls.from_native(native_surface)\n\n    @classmethod\n    def from_native(cls, native_surface):\n        \"\"\"Construct a NURBS surface from an existing Rhino surface.\n\n        Parameters\n        ----------\n        native_surface : :rhino:`Rhino.Geometry.Surface`\n            A Rhino surface.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        return cls(native_surface)\n\n    @classmethod\n    def from_parameters(\n        cls,\n        points,\n        weights,\n        knots_u,\n        knots_v,\n        mults_u,\n        mults_v,\n        degree_u,\n        degree_v,\n        is_periodic_u=False,\n        is_periodic_v=False,\n    ):\n        \"\"\"Construct a NURBS surface from explicit parameters.\n\n        Parameters\n        ----------\n        points : list[list[:class:`compas.geometry.Point`]]\n            The control points.\n        weights : list[list[float]]\n            The weights of the control points.\n        knots_u : list[float]\n            The knots in the U direction, without multiplicity.\n        knots_v : list[float]\n            The knots in the V direction, without multiplicity.\n        mults_u : list[int]\n            Multiplicity of the knots in the U direction.\n        mults_v : list[int]\n            Multiplicity of the knots in the V direction.\n        degree_u : int\n            Degree in the U direction.\n        degree_v : int\n            Degree in the V direction.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        native_surface = native_surface_from_parameters(points, weights, knots_u, knots_v, mults_u, mults_v, degree_u, degree_v)\n        return cls.from_native(native_surface)\n\n    @classmethod\n    def from_plane(cls, plane, domain_u=(0, 1), domain_v=(0, 1), degree_u=1, degree_v=1, pointcount_u=2, pointcount_v=2):\n        \"\"\"Construct a surface from a plane.\n\n        Parameters\n        ----------\n        plane : :class:`compas.geometry.Plane`\n            The plane.\n        domain_u : tuple[int, int], optional\n            The domain of the U parameter.\n        domain_v : tuple[int, int], optional\n            The domain of the V parameter.\n        degree_u : int, optional\n            Degree in the U direction.\n        degree_v : int, optional\n            Degree in the V direction.\n        pointcount_u : int, optional\n            Number of control points in the U direction.\n        pointcount_v : int, optional\n            Number of control points in the V direction.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        plane = plane_to_rhino(plane)\n        du = Rhino.Geometry.Interval(*domain_u)\n        dv = Rhino.Geometry.Interval(*domain_v)\n        native_surface = Rhino.Geometry.NurbsSurface.CreateFromPlane(plane, du, dv, degree_u, degree_v, pointcount_u, pointcount_v)\n        return cls.from_native(native_surface)\n\n    @classmethod\n    def from_points(cls, points, degree_u=3, degree_v=3):\n        \"\"\"Construct a NURBS surface from control points.\n\n        Parameters\n        ----------\n        points : list[list[:class:`compas.geometry.Point`]]\n            The control points.\n        degree_u : int\n            Degree in the U direction.\n        degree_v : int\n            Degree in the V direction.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        # this of course depends on the order in which the points are given.\n        # with the current convention this should not be needed.\n        points = list(zip(*points))\n\n        pointcount_u = len(points)\n        pointcount_v = len(points[0])\n        points[:] = [point_to_rhino(point) for row in points for point in row]\n        native_surface = Rhino.Geometry.NurbsSurface.CreateFromPoints(points, pointcount_u, pointcount_v, degree_u, degree_v)\n        return cls.from_native(native_surface)\n\n    @classmethod\n    def from_sphere(cls, sphere):\n        \"\"\"Creates a NURBS surface from a sphere.\n\n        Parameters\n        ----------\n        sphere : :class:`compas.geometry.Sphere`\n            The surface's geometry.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        sphere = sphere_to_rhino(sphere)\n        surface = Rhino.Geometry.NurbsSurface.CreateFromSphere(sphere)\n        return cls.from_native(surface)\n\n    @classmethod\n    def from_torus(cls, torus):\n        \"\"\"Create a NURBS surface from a torus.\n\n        Parameters\n        ----------\n        torus : :class:`compas.geometry.Torus`\n            The surface's geometry.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        raise NotImplementedError\n\n    # ==============================================================================\n    # Conversions\n    # ==============================================================================\n\n    # ==============================================================================\n    # Methods\n    # ==============================================================================\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "classes", "point", "dimension", "curve", "functions", "RhinoCommon"], "original_file": "compas-dev_compas_5f05656728.json", "repo": "compas-dev/compas"}
{"instruction": "Class representing a NURBS curve based on the NurbsCurve of Rhino.Geometry.", "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom itertools import groupby\n\nimport Rhino.Geometry  # type: ignore\n\nfrom compas.geometry import NurbsCurve\nfrom compas.geometry import Point\nfrom compas_rhino.conversions import point_to_compas\nfrom compas_rhino.conversions import point_to_rhino\n\nfrom .curve import RhinoCurve\n\n\ndef native_curve_from_parameters(points, weights, knots, multiplicities, degree):\n    native_curve = Rhino.Geometry.NurbsCurve(3, True, degree + 1, len(points))\n    for index, (point, weight) in enumerate(zip(points, weights)):\n        native_curve.Points.SetPoint(index, point_to_rhino(point), weight)\n    knotvector = [knot for knot, mult in zip(knots, multiplicities) for _ in range(mult)]\n    # account for superfluous knots\n    # https://developer.rhino3d.com/guides/opennurbs/superfluous-knots/\n    p = len(points)\n    o = degree + 1\n    k = p + o\n    if len(knotvector) == k:\n        knotvector[:] = knotvector[1:-1]\n    for index, knot in enumerate(knotvector):\n        native_curve.Knots[index] = knot\n    return native_curve\n\n\nclass RhinoNurbsCurve(RhinoCurve, NurbsCurve):\n    \"\"\"Class representing a NURBS curve based on the NurbsCurve of Rhino.Geometry.\n\n    Parameters\n    ----------\n    name : str, optional\n        Name of the curve.\n\n    Attributes\n    ----------\n    points : list[:class:`compas.geometry.Point`], read-only\n        The control points of the curve.\n    weights : list[float], read-only\n        The weights of the control points.\n    knots : list[float], read-only\n        The knot vector, without duplicates.\n    multiplicities : list[int], read-only\n        The multiplicities of the knots in the knot vector.\n    knotsequence : list[float], read-only\n        The knot vector, with repeating values according to the multiplicities.\n    continuity : int, read-only\n        The degree of continuity of the curve.\n    degree : int, read-only\n        The degree of the curve.\n    order : int, read-only\n        The order of the curve (degree + 1).\n    is_rational : bool, read-only\n        True is the curve is rational.\n\n    References\n    ----------\n    * https://developer.rhino3d.com/api/RhinoCommon/html/T_Rhino_Geometry_NurbsCurve.htm\n    * https://en.wikipedia.org/wiki/Non-uniform_rational_B-spline\n    * https://developer.rhino3d.com/guides/opennurbs/nurbs-geometry-overview/\n\n    \"\"\"\n\n    # ==============================================================================\n    # Data\n    # ==============================================================================\n\n    @property\n    def __data__(self):\n        # add superfluous knots\n        # for compatibility with all/most other NURBS implementations\n        # https://developer.rhino3d.com/guides/opennurbs/superfluous-knots/\n        multiplicities = self.multiplicities[:]  # type: ignore\n        multiplicities[0] += 1\n        multiplicities[-1] += 1\n        return {\n            \"points\": [point.__data__ for point in self.points],  # type: ignore\n            \"weights\": self.weights,\n            \"knots\": self.knots,\n            \"multiplicities\": multiplicities,\n            \"degree\": self.degree,\n            \"is_periodic\": self.is_periodic,\n        }\n\n    @classmethod\n    def __from_data__(cls, data):\n        points = [Point.__from_data__(point) for point in data[\"points\"]]\n        weights = data[\"weights\"]\n        knots = data[\"knots\"]\n        multiplicities = data[\"multiplicities\"]\n        degree = data[\"degree\"]\n        # is_periodic = data['is_periodic']\n        # have not found a way to actually set this\n        # not sure if that is actually possible...\n        native_curve = native_curve_from_parameters(points, weights, knots, multiplicities, degree)\n        return cls.from_native(native_curve)\n\n    # ==============================================================================\n    # Rhino Properties\n    # ==============================================================================\n\n    # ==============================================================================\n    # Properties\n    # ==============================================================================\n\n    @property\n    def points(self):\n        if self.native_curve:\n            return [point_to_compas(point.Location) for point in self.native_curve.Points]\n\n    @property\n    def weights(self):\n        if self.native_curve:\n            return [point.Weight for point in self.native_curve.Points]\n\n    @property\n    def knots(self):\n        if self.native_curve:\n            return [key for key, _ in groupby(self.native_curve.Knots)]\n\n    @property\n    def knotsequence(self):\n        if self.native_curve:\n            return list(self.native_curve.Knots)\n\n    @property\n    def multiplicities(self):\n        if self.native_curve:\n            return [len(list(group)) for _, group in groupby(self.native_curve.Knots)]\n\n    @property\n    def degree(self):\n        if self.native_curve:\n            return self.native_curve.Degree\n\n    @property\n    def order(self):\n        if self.native_curve:\n            return self.native_curve.Order\n\n    @property\n    def is_rational(self):\n        if self.native_curve:\n            return self.native_curve.IsRational\n\n    # ==============================================================================\n    # Constructors\n    # ==============================================================================\n\n    @classmethod\n    def from_interpolation(cls, points, precision=1e-3):\n        \"\"\"Construct a NURBS curve by interpolating a set of points.\n\n        Parameters\n        ----------\n        points : list[:class:`compas.geometry.Point`]\n            The control points.\n        precision : float, optional\n            The required precision of the interpolation.\n            This parameter is currently not supported.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsCurve`\n\n        \"\"\"\n        native_curve = Rhino.Geometry.NurbsCurve.CreateHSpline([point_to_rhino(point) for point in points])\n        return cls.from_native(native_curve)\n\n    @classmethod\n    def from_native(cls, native_curve):\n        \"\"\"Construct a NURBS curve from an existing Rhino curve.\n\n        Parameters\n        ----------\n        native_curve : Rhino.Geometry.Curve\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsCurve`\n\n        \"\"\"\n        return cls(native_curve)\n\n    @classmethod\n    def from_parameters(cls, points, weights, knots, multiplicities, degree, is_periodic=False):\n        \"\"\"Construct a NURBS curve from explicit curve parameters.\n\n        Parameters\n        ----------\n        points : list[:class:`compas.geometry.Point`]\n            The control points.\n        weights : list[float]\n            The control point weights.\n        knots : list[float]\n            The curve knots, without duplicates.\n        multiplicities : list[int]\n            The multiplicities of the knots.\n        degree : int\n            The degree of the curve.\n        is_periodic : bool, optional\n            Flag indicating whether the curve is periodic or not.\n            Note that this parameters is currently not supported.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsCurve`\n\n        \"\"\"\n        degree = min(degree, len(points) - 1)\n        native_curve = native_curve_from_parameters(points, weights, knots, multiplicities, degree)\n        return cls.from_native(native_curve)\n\n    @classmethod\n    def from_points(cls, points, degree=3, is_periodic=False):\n        \"\"\"Construct a NURBS curve from control points.\n\n        Parameters\n        ----------\n        points : list[:class:`compas.geometry.Point`]\n            The control points.\n        degree : int, optional\n            The degree of the curve.\n        is_periodic : bool, optional\n            Flag indicating whether the curve is periodic or not.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsCurve`\n\n        \"\"\"\n        degree = min(degree, len(points) - 1)\n        native_curve = Rhino.Geometry.NurbsCurve.Create(is_periodic, degree, [point_to_rhino(point) for point in points])\n        return cls.from_native(native_curve)\n\n    # ==============================================================================\n    # Conversions\n    # ==============================================================================\n\n    # ==============================================================================\n    # Methods\n    # ==============================================================================\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "line", "curve", "functions", "RhinoCommon"], "original_file": "compas-dev_compas_6480773ce1.json", "repo": "compas-dev/compas"}
{"instruction": "Convert a COMPAS Brep to a Rhino Brep.", "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport Rhino.Geometry  # type: ignore  # noqa: F401\nimport scriptcontext as sc  # type: ignore\n\nimport compas\nimport compas.geometry  # noqa: F401\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Brep\nfrom compas.tolerance import TOL\n\nfrom .exceptions import ConversionError\nfrom .extrusions import extrusion_to_compas_box\nfrom .geometry import point_to_compas\nfrom .shapes import cone_to_compas\nfrom .shapes import cylinder_to_compas\nfrom .shapes import sphere_to_compas\nfrom .surfaces import surface_to_compas\n\nif not compas.IPY:\n    from typing import Callable  # noqa: F401\n    from typing import Type  # noqa: F401\n\n# =============================================================================\n# To Rhino\n# =============================================================================\n\n\ndef brep_to_rhino(brep):\n    # type: (Brep) -> Rhino.Geometry.Brep\n    \"\"\"Convert a COMPAS Brep to a Rhino Brep.\n\n    Parameters\n    ----------\n    brep : :class:`compas.geometry.Brep`\n\n    Returns\n    -------\n    :rhino:`Rhino.Geometry.Brep`\n\n    \"\"\"\n    return brep.native_brep\n\n\n# =============================================================================\n# To COMPAS\n# =============================================================================\n\n\ndef brep_to_compas(brep):\n    # type: (Rhino.Geometry.Brep) -> Brep\n    \"\"\"Convert a Rhino Brep to a COMPAS Brep.\n\n    Parameters\n    ----------\n    brep : :rhino:`Rhino.Geometry.Brep`\n\n    Returns\n    -------\n    :class:`compas.geometry.Brep`\n\n    \"\"\"\n    return Brep.from_native(brep)\n\n\n# =============================================================================\n# To COMPAS Shapes\n# =============================================================================\n\n\ndef brep_to_compas_box(brep):\n    # type: (Rhino.Geometry.Brep) -> compas.geometry.Box\n    \"\"\"Convert a Rhino brep to a COMPAS box.\n\n    Parameters\n    ----------\n    brep : :rhino:`Rhino.Geometry.Brep`\n\n    Returns\n    -------\n    :class:`compas.geometry.Box`\n\n    \"\"\"\n    return extrusion_to_compas_box(brep.Geometry)\n\n\ndef brep_to_compas_cone(brep):\n    # type: (Rhino.Geometry.Brep) -> compas.geometry.Cone\n    \"\"\"Convert a Rhino brep to a COMPAS cone.\n\n    Parameters\n    ----------\n    brep : :rhino:`Rhino.Geometry.Brep`\n\n    Returns\n    -------\n    :class:`compas.geometry.Cone`\n\n    Raises\n    ------\n    ConversionError\n\n    \"\"\"\n    if brep.Faces.Count > 2:\n        raise ConversionError(\"Brep cannot be converted to a cone.\")\n\n    for face in brep.Faces:\n        if face.IsCone():\n            result, cone = face.TryGetCone()\n            if result:\n                return cone_to_compas(cone)\n\n    raise ConversionError(\"Brep cannot be converted to a cone.\")\n\n\ndef brep_to_compas_cylinder(brep, tol=None):\n    # type: (Rhino.Geometry.Brep, float | None) -> compas.geometry.Cylinder\n    \"\"\"Convert a Rhino brep to a COMPAS cylinder.\n\n    Parameters\n    ----------\n    brep : :rhino:`Rhino.Geometry.Brep`\n\n    Returns\n    -------\n    :class:`compas.geometry.Cylinder`\n\n    Raises\n    ------\n    ConversionError\n\n    \"\"\"\n    tol = tol or sc.doc.ModelAbsoluteTolerance\n\n    if brep.Faces.Count > 3:\n        raise ConversionError(\"Brep cannot be converted to a cylinder.\")\n\n    for face in brep.Faces:\n        # being too strict about what is considered a cylinder\n        # results in cylinders created by Rhino itself\n        # to not be recognized...\n        if face.IsCylinder(tol):\n            result, cylinder = face.TryGetFiniteCylinder(tol)\n            if result:\n                return cylinder_to_compas(cylinder)\n\n    raise ConversionError(\"Brep cannot be converted to a cylinder.\")\n\n\ndef brep_to_compas_sphere(brep):\n    # type: (Rhino.Geometry.Brep) -> compas.geometry.Sphere\n    \"\"\"Convert a Rhino brep to a COMPAS sphere.\n\n    Parameters\n    ----------\n    brep : :rhino:`Rhino.Geometry.Brep`\n\n    Returns\n    -------\n    :class:`compas.geometry.Sphere`\n\n    Raises\n    ------\n    ConversionError\n\n    \"\"\"\n    if brep.Faces.Count != 1:\n        raise ConversionError(\"Brep cannot be converted to a sphere.\")\n\n    face = brep.Faces.Item[0]\n    if not face.IsSphere():\n        raise ConversionError(\"Brep cannot be converted to a sphere.\")\n\n    result, sphere = face.TryGetSphere()\n    if result:\n        return sphere_to_compas(sphere)\n\n    raise ConversionError(\"Brep cannot be converted to a sphere.\")\n\n\n# =============================================================================\n# To COMPAS Surface\n# =============================================================================\n\n\ndef brep_to_compas_surface(brep, tol=None):\n    # type: (Rhino.Geometry.Brep, float | None) -> compas.geometry.NurbsSurface\n    \"\"\"Convert a Rhino brep to a COMPAS surface.\n\n    Parameters\n    ----------\n    brep : :rhino:`Rhino.Geometry.Brep`\n\n    Returns\n    -------\n    :class:`compas.geometry.NurbsSurface`\n\n    Raises\n    ------\n    ConversionError\n\n    \"\"\"\n    tol = tol or sc.doc.ModelAbsoluteTolerance\n\n    if brep.Faces.Count != 1:\n        raise ConversionError(\"Brep cannot be converted to a surface.\")\n\n    face = brep.Faces.Item[0]\n\n    if not face.HasNurbsForm():\n        raise ConversionError(\"Brep cannot be converted to a surface.\")\n\n    result, surface = face.ToNurbsSurface(tol)\n    if result:\n        return surface_to_compas(surface)\n\n    raise ConversionError(\"Brep cannot be converted to a surface.\")\n\n\n# =============================================================================\n# To COMPAS Mesh\n# =============================================================================\n\n\ndef brep_to_compas_mesh(brep, facefilter=None, cleanup=False, cls=None):\n    # type: (Rhino.Geometry.Brep, Callable | None, bool, Type[Mesh] | None) -> Mesh\n    \"\"\"Convert the face loops of a Rhino brep to a COMPAS mesh.\n\n    Parameters\n    ----------\n    brep : :class:`Rhino.Geometry.Brep`\n        A Rhino brep.\n    facefilter : callable, optional\n        A filter for selection which Brep faces to include.\n        If provided, the filter should return True or False per face.\n        A very simple filter that includes all faces is ``def facefilter(face): return True``.\n        Default parameter value is None in which case all faces are included.\n    cleanup : bool, optional\n        Flag indicating to clean up the result.\n        Cleaning up means to remove isolated faces and unused vertices.\n        Default is False.\n    cls : :class:`compas.datastructures.Mesh`, optional\n        The type of COMPAS mesh.\n\n    Returns\n    -------\n    :class:`compas.datastructures.Mesh`\n        The resulting mesh.\n\n    \"\"\"\n    if facefilter and callable(facefilter):\n        brepfaces = [face for face in brep.Faces if facefilter(face)]\n    else:\n        brepfaces = brep.Faces\n\n    # vertex maps and face lists\n    gkey_xyz = {}\n    faces = []\n    for face in brepfaces:\n        loop = face.OuterLoop\n        curve = loop.To3dCurve()\n        segments = list(curve.Explode())\n        a = point_to_compas(segments[0].PointAtStart)\n        b = point_to_compas(segments[0].PointAtEnd)\n        a_gkey = TOL.geometric_key(a)\n        b_gkey = TOL.geometric_key(b)\n        gkey_xyz[a_gkey] = a\n        gkey_xyz[b_gkey] = b\n        face = [a_gkey, b_gkey]\n        for segment in segments[1:-1]:\n            b = point_to_compas(segment.PointAtEnd)\n            b_gkey = TOL.geometric_key(b)\n            face.append(b_gkey)\n            gkey_xyz[b_gkey] = b\n        faces.append(face)\n\n    # vertices and faces\n    gkey_index = {gkey: index for index, gkey in enumerate(gkey_xyz)}\n    vertices = [list(xyz) for gkey, xyz in gkey_xyz.items()]\n    faces = [[gkey_index[gkey] for gkey in face] for face in faces]\n\n    # remove duplicates from vertexlist\n    polygons = []\n    for temp in faces:\n        face = []\n        for vertex in temp:\n            if vertex not in face:\n                face.append(vertex)\n        polygons.append(face)\n\n    # define mesh type\n    cls = cls or Mesh\n    # create mesh\n    mesh = cls.from_vertices_and_faces(vertices, polygons)\n\n    # remove isolated faces\n    if cleanup:\n        if mesh.number_of_faces() > 1:\n            for face in list(mesh.faces()):\n                if not mesh.face_neighbors(face):\n                    mesh.delete_face(face)\n        mesh.remove_unused_vertices()\n\n    return mesh\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "point", "brep", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "compas-dev_compas_701cd3c4a1.json", "repo": "compas-dev/compas"}
{"instruction": "A Rhino display conduit for lines.", "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport Rhino  # type: ignore\nimport System  # type: ignore\n\nfrom compas.data.validators import is_sequence_of_iterable\nfrom compas.itertools import iterable_like\n\nfrom .base import BaseConduit\n\n\nclass LinesConduit(BaseConduit):\n    \"\"\"A Rhino display conduit for lines.\n\n    Parameters\n    ----------\n    lines : list[[point, point] | :class:`compas.geometry.Line`]\n        A list of start-end point pairs that define the lines.\n    thickness : list[int], optional\n        The thickness of the individual lines.\n        Default is :attr:`LinesConduit.default_thickness` for all lines.\n    color : list[tuple[int, int, int]], optional\n        The colors of the faces.\n        Default is :attr:`LinesConduit.default_color` for all lines.\n\n    Attributes\n    ----------\n    color : list[System.Drawing.Color]\n        A color per line.\n    thickness : list[float]\n        A thickness per line.\n\n    Class Attributes\n    ----------------\n    default_thickness : float\n        The default thickness is ``1.0``.\n    default_color : System.Drawing.Color\n        the default color is ``FromArgb(255, 255, 255)``.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        from random import randint\n\n        points = [(1.0 * randint(0, 30), 1.0 * randint(0, 30), 0.0) for _ in range(100)]\n        lines = [(points[i], points[i + 1]) for i in range(99)]\n        conduit = LinesConduit(lines)\n\n        with conduit.enabled():\n            for i in range(100):\n                points = [(1.0 * randint(0, 30), 1.0 * randint(0, 30), 0.0) for _ in range(100)]\n                conduit.lines = [(points[i], points[i + 1]) for i in range(99)]\n                conduit.redraw(pause=0.1)\n\n    \"\"\"\n\n    default_thickness = 1.0\n    default_color = System.Drawing.Color.FromArgb(255, 255, 255)\n\n    def __init__(self, lines, thickness=None, color=None, **kwargs):\n        super(LinesConduit, self).__init__(**kwargs)\n        self._thickness = None\n        self._color = None\n        self.lines = lines or []\n        self.thickness = thickness\n        self.color = color\n\n    @property\n    def thickness(self):\n        return self._thickness\n\n    @thickness.setter\n    def thickness(self, thickness):\n        thickness = thickness or self.default_thickness\n        try:\n            len(thickness)  # type: ignore\n        except TypeError:\n            thickness = [thickness]\n        thickness = iterable_like(self.lines, thickness, self.default_thickness)\n        self._thickness = list(thickness)\n\n    @property\n    def color(self):\n        return self._color\n\n    @color.setter\n    def color(self, color):\n        color = color or self.default_color\n        if not is_sequence_of_iterable(color):\n            color = [color]\n        self._color = [System.Drawing.Color.FromArgb(*c) for c in iterable_like(self.lines, color, self.default_color)]\n\n    def DrawForeground(self, e):\n        \"\"\"Draw the lines.\n\n        Parameters\n        ----------\n        e : Rhino.Display.DrawEventArgs\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        for (start, end), color, thickness in zip(self.lines, self.color, self.thickness):  # type: ignore\n            e.Display.DrawLine(\n                Rhino.Geometry.Point3d(*start),\n                Rhino.Geometry.Point3d(*end),\n                color,\n                thickness,\n            )\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "line", "functions", "block", "RhinoCommon"], "original_file": "compas-dev_compas_726c1c1f09.json", "repo": "compas-dev/compas"}
{"instruction": "Rhino Brep backend class.", "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport Rhino  # type: ignore\nimport rhinoscriptsyntax as rs  # type: ignore\n\nimport compas_rhino.objects\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Brep\nfrom compas.geometry import BrepError\nfrom compas.geometry import BrepFilletError\nfrom compas.geometry import BrepTrimmingError\nfrom compas.geometry import Frame\nfrom compas.geometry import Line\nfrom compas.geometry import Plane\nfrom compas.geometry import Point\nfrom compas.geometry import Polyline\nfrom compas.tolerance import TOL\nfrom compas_rhino.conversions import box_to_rhino\nfrom compas_rhino.conversions import cone_to_rhino\nfrom compas_rhino.conversions import curve_to_compas\nfrom compas_rhino.conversions import curve_to_rhino\nfrom compas_rhino.conversions import cylinder_to_rhino\nfrom compas_rhino.conversions import frame_to_rhino_plane\nfrom compas_rhino.conversions import line_to_rhino_curve\nfrom compas_rhino.conversions import mesh_to_compas\nfrom compas_rhino.conversions import mesh_to_rhino\nfrom compas_rhino.conversions import plane_to_rhino\nfrom compas_rhino.conversions import point_to_rhino\nfrom compas_rhino.conversions import polyline_to_rhino_curve\nfrom compas_rhino.conversions import sphere_to_rhino\nfrom compas_rhino.conversions import torus_to_rhino\nfrom compas_rhino.conversions import transformation_to_rhino\nfrom compas_rhino.conversions import vector_to_rhino\nfrom compas_rhino.geometry import RhinoNurbsCurve\nfrom compas_rhino.geometry import RhinoNurbsSurface\n\nfrom .builder import _RhinoBrepBuilder\nfrom .edge import RhinoBrepEdge\nfrom .face import RhinoBrepFace\nfrom .loop import RhinoBrepLoop\nfrom .vertex import RhinoBrepVertex\n\n\ndef _export_brep_to_file(brep, filepath):\n    objects = Rhino.RhinoDoc.ActiveDoc.Objects\n    obj_id = objects.Add(brep)\n    obj = objects.Find(obj_id)\n    obj.Select(True)\n    rs.Command('_-Export \"' + filepath + '\" _Enter', False)\n    objects.Delete(obj_id, True)\n\n\ndef _import_brep_from_file(filepath):\n    # TODO: this only seems to work in ScriptEditor (AKA rhino, not GH)\n    rs.Command('_-Import \"' + filepath + '\" _Enter', False)\n    guid = rs.LastCreatedObjects()[0]  # this fails, could be Rhino bug\n    obj = compas_rhino.objects.find_object(guid)\n    geometry = obj.Geometry.Duplicate()\n    compas_rhino.objects.delete_object(guid)\n    return RhinoBrep.from_native(geometry)\n\n\ndef _join_meshes(meshes):\n    result = Mesh()\n    for mesh in meshes:\n        result.join(mesh)\n    return result\n\n\nclass RhinoBrep(Brep):\n    \"\"\"Rhino Brep backend class.\n\n    Wraps around and allows serialization and de-serialization of a :class:`Rhino.Geometry.Brep`.\n\n    Attributes\n    ----------\n    native_brep : :class:`Rhino.Geometry.Brep`\n        The underlying Rhino Brep instance.\n    vertices : list[:class:`compas_rhino.geometry.RhinoBrepVertex`], read-only\n        The list of vertices which comprise this Brep.\n    points : list[:class:`compas.geometry.Point`], read-only\n        The list of vertex geometries as points in 3D space.\n    edges : list[:class:`compas_rhino.geometry.RhinoBrepEdge`], read-only\n        The list of edges which comprise this brep.\n    trims : list[:class:`compas_rhino.geometry.RhinoBrepTrim`], read-only\n        The list of trims which comprise this brep.\n    loops : list[:class:`compas_rhino.geometry.RhinoBrepLoop`], read-only\n        The list of loops which comprise this brep.\n    faces : list[:class:`compas_rhino.geometry.RhinoBrepFace`], read-only\n        The list of faces which comprise this brep.\n    frame : :class:`compas.geometry.Frame`, read-only\n        The brep's origin (Frame.worldXY()).\n    area : float, read-only\n        The calculated area of this brep.\n    volume : float, read-only\n        The calculated volume of this brep.\n    centroid : :class:`compas.geometry.Point`, read-only\n        The calculated centroid of this brep.\n    curves : list[:class:`compas_rhino.geometry.RhinoNurbsCurve`], read-only\n        The list of curves which comprise this brep.\n    is_closed : bool, read-only\n        True if this brep is closed, False otherwise.\n    is_compound : bool, read-only\n        True if this brep is compound, False otherwise.\n    is_compoundsolid : bool, read-only\n        True if this brep is compound solid, False otherwise.\n    is_convex : bool, read-only\n        True if this brep is convex, False otherwise.\n    is_infinite : bool, read-only\n        True if this brep is infinite, False otherwise.\n    is_orientable : bool, read-only\n        True if this brep is orientable, False otherwise.\n    is_shell : bool, read-only\n        True if this brep is a shell, False otherwise.\n    is_surface : bool, read-only\n        True if this brep is a surface, False otherwise.\n    is_valid : bool, read-only\n        True if this brep is valid, False otherwise.\n    orientation : literal(:class:`~compas.geometry.BrepOrientation`), read-only\n        The orientation of this brep. One of: FORWARD, REVERSED, INTERNAL, EXTERNAL.\n    shells : list[:class:`compas_rhino.geometry.RhinoBrep`], read-only\n        The list of shells which comprise this brep.\n    solids : list[:class:`compas_rhino.geometry.RhinoBrep`], read-only\n        The list of solids which comprise this brep.\n    surfaces : list[:class:`compas_rhino.geometry.RhinoNurbsSurface`], read-only\n        The list of surfaces which comprise this brep.\n\n    \"\"\"\n\n    def __init__(self):\n        super(RhinoBrep, self).__init__()\n        self._brep = Rhino.Geometry.Brep()\n\n    def __deepcopy__(self, *args, **kwargs):\n        return self.copy()\n\n    # ==============================================================================\n    # Data\n    # ==============================================================================\n\n    @property\n    def __data__(self):\n        return {\n            \"vertices\": [v.__data__ for v in self.vertices],  # type: ignore\n            \"edges\": [e.__data__ for e in self.edges],  # type: ignore\n            \"faces\": [f.__data__ for f in self.faces],  # type: ignore\n        }\n\n    @classmethod\n    def __from_data__(cls, data):\n        \"\"\"Construct a RhinoBrep from its data representation.\n\n        Parameters\n        ----------\n        data : :obj:`dict`\n            The data dictionary.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        instance = cls()\n        builder = _RhinoBrepBuilder()\n        for v_data in data[\"vertices\"]:\n            RhinoBrepVertex.__from_data__(v_data, builder)\n        for e_data in data[\"edges\"]:\n            RhinoBrepEdge.__from_data__(e_data, builder)\n        for f_data in data[\"faces\"]:\n            RhinoBrepFace.__from_data__(f_data, builder)\n        instance.native_brep = builder.result\n        return instance\n\n    def copy(self, cls=None):\n        \"\"\"Creates a deep-copy of this Brep using the native Rhino.Geometry.Brep copying mechanism.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        # Avoid reconstruction when just copying. for sake of efficiency and stability\n        return RhinoBrep.from_native(self._brep.DuplicateBrep())\n\n    # ==============================================================================\n    # Properties\n    # ==============================================================================\n\n    @property\n    def is_manifold(self):\n        return self._brep.IsManifold\n\n    @property\n    def is_solid(self):\n        return self._brep.IsSolid\n\n    @property\n    def native_brep(self):\n        return self._brep\n\n    @native_brep.setter\n    def native_brep(self, rhino_brep):\n        self._brep = rhino_brep\n\n    @property\n    def vertices(self):\n        return self.points\n\n    @property\n    def points(self):\n        if self._brep:\n            return [RhinoBrepVertex(vertex) for vertex in self._brep.Vertices]\n\n    @property\n    def edges(self):\n        if self._brep:\n            return [RhinoBrepEdge(edge) for edge in self._brep.Edges]\n\n    @property\n    def trims(self):\n        if self._brep:\n            return [RhinoBrepEdge(trim) for trim in self._brep.Trims]\n\n    @property\n    def loops(self):\n        if self._brep:\n            return [RhinoBrepLoop(loop) for loop in self._brep.Loops]\n\n    @property\n    def faces(self):\n        if self._brep:\n            return [RhinoBrepFace(face) for face in self._brep.Faces]\n\n    @property\n    def frame(self):\n        return Frame.worldXY()\n\n    @property\n    def area(self):\n        if self._brep:\n            return self._brep.GetArea()\n\n    @property\n    def volume(self):\n        if self._brep:\n            return self._brep.GetVolume()\n\n    @property\n    def centroid(self):\n        assert self._brep\n        centroid = Rhino.Geometry.AreaMassProperties.Compute(self._brep).Centroid\n        return Point(*centroid)\n\n    @property\n    def curves(self):\n        assert self._brep\n        return [RhinoNurbsCurve.from_native(c.ToNurbsCurve()) for c in self._brep.Curves3D]\n\n    @property\n    def is_closed(self):\n        assert self._brep\n        return self._brep.IsSolid\n\n    @property\n    def is_convex(self):\n        raise NotImplementedError(\"Convexity check is not implemented for Rhino Breps.\")\n\n    @property\n    def is_infinite(self):\n        # TODO: what does this exactly mean? couldn't find in the Rhino API\n        raise NotImplementedError\n\n    @property\n    def is_orientable(self):\n        assert self._brep\n        return self._brep.SolidOrientation in (Rhino.Geometry.BrepSolidOrientation.Inward, Rhino.Geometry.BrepSolidOrientation.Outward)\n\n    @property\n    def is_shell(self):\n        # not sure how to get this one\n        raise NotImplementedError\n\n    @property\n    def is_surface(self):\n        assert self._brep\n        return self._brep.IsSurface\n\n    @property\n    def is_valid(self):\n        assert self._brep\n        return self.IsValid\n\n    @property\n    def orientation(self):\n        assert self._brep\n        # TODO: align this with compas.geometry.BrepOrientation\n        return self._brep.SolidOrientation\n\n    @property\n    def surfaces(self):\n        assert self._brep\n        return [[RhinoNurbsSurface.from_native(s.ToNurbsSurface()) for s in self._brep.Surfaces]]\n\n    # ==============================================================================\n    # Constructors\n    # ==============================================================================\n\n    @classmethod\n    def from_boolean_difference(cls, breps_a, breps_b):\n        \"\"\"Construct a Brep from the boolean difference of two groups of Breps.\n\n        Parameters\n        ----------\n        breps_a : :class:`compas_rhino.geometry.RhinoBrep` or list(:class:`compas_rhino.geometry.RhinoBrep`)\n            One or more Breps from which to substract.\n        breps_b : :class:`compas_rhino.geometry.RhinoBrep` or list(:class:`compas_rhino.geometry.RhinoBrep`)\n            One or more Breps to substract.\n\n        Returns\n        -------\n        list(:class:`compas_rhino.geometry.RhinoBrep`)\n            list of one or more resulting Breps.\n\n        \"\"\"\n        if not isinstance(breps_a, list):\n            breps_a = [breps_a]\n        if not isinstance(breps_b, list):\n            breps_b = [breps_b]\n        resulting_breps = Rhino.Geometry.Brep.CreateBooleanDifference(\n            [b.native_brep for b in breps_a],\n            [b.native_brep for b in breps_b],\n            TOL.absolute,\n        )\n        return [RhinoBrep.from_native(brep) for brep in resulting_breps]\n\n    @classmethod\n    def from_boolean_union(cls, breps_a, breps_b):\n        \"\"\"Construct a Brep from the boolean union of two groups of Breps.\n\n        Parameters\n        ----------\n        breps_a : :class:`compas_rhino.geometry.RhinoBrep` or list(:class:`compas_rhino.geometry.RhinoBrep`)\n            One of more breps to join.\n        breps_b : :class:`compas_rhino.geometry.RhinoBrep` or list(:class:`compas_rhino.geometry.RhinoBrep`)\n            Another one of more breps to join.\n\n        Returns\n        -------\n        list(:class:`compas_rhino.geometry.RhinoBrep`)\n            list of one or more resulting Breps.\n\n        \"\"\"\n        if not isinstance(breps_a, list):\n            breps_a = [breps_a]\n        if not isinstance(breps_b, list):\n            breps_b = [breps_b]\n\n        resulting_breps = Rhino.Geometry.Brep.CreateBooleanUnion([b.native_brep for b in breps_a + breps_b], TOL.absolute)\n        return [RhinoBrep.from_native(brep) for brep in resulting_breps]\n\n    @classmethod\n    def from_boolean_intersection(cls, breps_a, breps_b):\n        \"\"\"Construct a Brep from the boolean intersection of two groups of Breps.\n\n        Parameters\n        ----------\n        breps_a : :class:`compas_rhino.geometry.RhinoBrep` or list(:class:`compas_rhino.geometry.RhinoBrep`)\n            One or more Breps to instrsect.\n        breps_b : :class:`compas_rhino.geometry.RhinoBrep` or list(:class:`compas_rhino.geometry.RhinoBrep`)\n            Another one or more Breps to intersect.\n\n        Returns\n        -------\n        list(:class:`compas_rhino.geometry.RhinoBrep`)\n            list of one or more resulting Breps.\n\n        \"\"\"\n        if not isinstance(breps_a, list):\n            breps_a = [breps_a]\n        if not isinstance(breps_b, list):\n            breps_b = [breps_b]\n        resulting_breps = Rhino.Geometry.Brep.CreateBooleanIntersection(\n            [b.native_brep for b in breps_a],\n            [b.native_brep for b in breps_b],\n            TOL.absolute,\n        )\n        return [RhinoBrep.from_native(brep) for brep in resulting_breps]\n\n    @classmethod\n    def from_box(cls, box):\n        \"\"\"Create a RhinoBrep from a box.\n\n        Parameters\n        ----------\n        box : :class:`compas.geometry.Box`\n            The box geometry of the brep.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        rhino_box = box_to_rhino(box)\n        return cls.from_native(rhino_box.ToBrep())\n\n    @classmethod\n    def from_brepfaces(cls, faces):\n        \"\"\"Create a Brep from a list of Brep faces forming an open or closed shell.\n\n        Parameters\n        ----------\n        faces : list[:class:`compas.geometry.BrepFace`]\n\n        Returns\n        -------\n        :class:`compas.geometry.Brep`\n\n        \"\"\"\n        brep = Rhino.Geometry.Brep()\n        for face in faces:\n            brep.Faces.Add(face.native_face.UnderlyingSurface())\n        return cls.from_native(brep)\n\n    @classmethod\n    def from_breps(cls, breps, tolerance=None):\n        \"\"\"Joins the breps at any overlapping edges to form as few as possible resulting breps. There may be more than one brep in the result array.\n\n        Parameters\n        ----------\n        breps : list of :class:`compas.geometry.Brep`\n\n        Returns\n        -------\n        list of :class:`compas.geometry.Brep`\n\n        \"\"\"\n        tolerance = tolerance or TOL\n        rhino_breps = [b.native_brep for b in breps]\n        resulting_breps = Rhino.Geometry.Brep.JoinBreps(rhino_breps, tolerance.absolute, tolerance.angular)\n        return [cls.from_native(brep) for brep in resulting_breps]\n\n    @classmethod\n    def from_cone(cls, cone, cap_bottom=True):\n        \"\"\"Create a RhinoBrep from a cone.\n\n        Parameters\n        ----------\n        cone : :class:`compas.geometry.Cone`\n            The cone geometry of the brep.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        rhino_cone = cone_to_rhino(cone)\n        return cls.from_native(rhino_cone.ToBrep(cap_bottom))\n\n    @classmethod\n    def from_cylinder(cls, cylinder):\n        \"\"\"Create a RhinoBrep from a box.\n\n        Parameters\n        ----------\n        box : :class:`compas.geometry.Box`\n            The box geometry of the brep.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        rhino_cylinder = cylinder_to_rhino(cylinder)\n        return cls.from_native(rhino_cylinder.ToBrep(True, True))\n\n    @classmethod\n    def from_curves(cls, curves, tolerance=None):\n        \"\"\"Create a RhinoBreps from a list of planar face boundary curves.\n\n        Parameters\n        ----------\n        curves : list of :class:`~compas.geometry.Curve` or :class:`~compas.geometry.Polyline`\n            The planar curves that make up the face borders of brep faces.\n\n        Returns\n        -------\n        list of :class:`~compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        tolerance = tolerance or TOL.absolute\n        if not isinstance(curves, list):\n            curves = [curves]\n        faces = []\n        for curve in curves:\n            if isinstance(curve, Polyline):\n                rhino_curve = polyline_to_rhino_curve(curve)\n            else:\n                rhino_curve = curve_to_rhino(curve)\n            face = Rhino.Geometry.Brep.CreatePlanarBreps(rhino_curve, tolerance)\n            if face is None:\n                raise BrepError(\"Failed to create face from curve: {} \".format(curve))\n            if len(face) > 1:\n                raise BrepError(\"Failed to create single face from curve: {} \".format(curve))\n            faces.append(face[0])\n        rhino_brep = Rhino.Geometry.Brep.JoinBreps(faces, tolerance)\n        if rhino_brep is None:\n            raise BrepError(\"Failed to create Brep from faces: {} \".format(faces))\n        return [cls.from_native(brep) for brep in rhino_brep]\n\n    @classmethod\n    def from_extrusion(cls, curve, vector, cap_ends=True):\n        \"\"\"Create a RhinoBrep from an extrusion.\n\n        Parameters\n        ----------\n        curve : :class:`~compas.geometry.Curve` or :class:`~compas.geometry.Polyline`\n            The curve to extrude.\n        vector : :class:`~compas.geometry.Vector`\n            The vector to extrude the curve along.\n        cap_ends : bool, optional\n            If True, the plannar ends of the extrusion will be capped, if possible.\n\n        Returns\n        -------\n        :class:`~compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        if isinstance(curve, Polyline):\n            rhino_curve = polyline_to_rhino_curve(curve)\n        else:\n            rhino_curve = curve_to_rhino(curve)\n        extrusion = Rhino.Geometry.Surface.CreateExtrusion(rhino_curve, vector_to_rhino(vector))\n        if extrusion is None:\n            raise BrepError(\"Failed to create extrusion from curve: {} and vector: {}\".format(curve, vector))\n        rhino_brep = extrusion.ToBrep()\n        if cap_ends:\n            capped = rhino_brep.CapPlanarHoles(TOL.absolute)\n            if capped:\n                rhino_brep = capped\n        return cls.from_native(rhino_brep)\n\n    @classmethod\n    def from_iges(cls, filepath):\n        \"\"\"Construct a RhinoBrep from a IGES file.\n\n        Parameters\n        ----------\n        filepath : str\n            The path to the step file.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        if not filepath.endswith(\".igs\"):\n            raise ValueError(\"Expected file with .igs extension\")\n        return _import_brep_from_file(filepath)\n\n    @classmethod\n    def from_loft(cls, curves):\n        \"\"\"Construct a Brep by lofting a set of curves.\n\n        Parameters\n        ----------\n        curves : list[:class:`compas.geometry.Curve`]\n\n        Returns\n        -------\n        :class:`compas.geometry.Brep`\n\n        \"\"\"\n        rhino_curves = [curve_to_rhino(curve) for curve in curves]\n        start = Rhino.Geometry.Point3d.Unset\n        end = Rhino.Geometry.Point3d.Unset\n        loft_type = Rhino.Geometry.LoftType.Normal\n\n        results = Rhino.Geometry.Brep.CreateFromLoft(rhino_curves, start, end, loft_type, closed=False)\n        if not results:\n            raise BrepTrimmingError(\"Loft operation ended with no result\")\n        result = results[0]\n\n        return cls.from_native(result)\n\n    @classmethod\n    def from_mesh(cls, mesh):\n        \"\"\"Create a RhinoBrep from a mesh.\n\n        Parameters\n        ----------\n        mesh : :class:`compas.datastructures.Mesh`\n            The source mesh.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        rhino_mesh = mesh_to_rhino(mesh)\n        return cls.from_native(Rhino.Geometry.Brep.CreateFromMesh(rhino_mesh, True))\n\n    @classmethod\n    def from_native(cls, rhino_brep):\n        \"\"\"Constructs a RhinoBrep from an instance of a Rhino.Geometry.Brep.\n\n        Parameters\n        ----------\n        rhino_brep : :class:`Rhino.Geometry.Brep`\n            The instance of Rhino brep to wrap.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        brep = cls()\n        brep._brep = rhino_brep\n        return brep\n\n    @classmethod\n    def from_pipe(cls, path, radius, cap_mode=\"none\", tolerance=None, *args, **kwargs):\n        \"\"\"Construct a Brep by extruding a circle curve along the path curve.\n\n        Parameters\n        ----------\n        curve : :class:`compas.geometry.Curve`\n            The curve to extrude\n        radius : float\n            The radius of the pipe.\n        cap_mode : literal('none', 'flat', 'round'), optional\n            The type of end caps to create. Defaults to 'none'.\n        tolerance : :class:`~compas.tolerance.Tolerance`, optional\n            A Tolerance instance to use for the operation. Defaults to `TOL`.\n\n        Returns\n        -------\n        :class:`compas.geometry.Brep`\n\n        \"\"\"\n        tolerance = tolerance or TOL\n\n        if cap_mode == \"none\":\n            cap_mode = Rhino.Geometry.PipeCapMode.NONE\n        elif cap_mode == \"flat\":\n            cap_mode = Rhino.Geometry.PipeCapMode.Flat\n        elif cap_mode == \"round\":\n            cap_mode = Rhino.Geometry.PipeCapMode.Round\n        else:\n            raise ValueError(\"Invalid cap_ends value. Must be 'none', 'flat' or 'round'.\")\n\n        if hasattr(path, \"native_curve\"):\n            path = curve_to_rhino(path)\n        elif isinstance(path, Polyline):\n            path = polyline_to_rhino_curve(path)\n        elif isinstance(path, Line):\n            path = line_to_rhino_curve(path)\n        else:\n            raise TypeError(\"Unsupported path curve type: {}\".format(type(path)))\n\n        result = Rhino.Geometry.Brep.CreatePipe(path, radius, False, cap_mode, True, tolerance.absolute, tolerance.angular)\n        if result is None:\n            raise BrepError(\"Failed to create pipe from curve: {} and radius: {}\".format(path, radius))\n\n        return [cls.from_native(brep) for brep in result]\n\n    @classmethod\n    def from_plane(cls, plane, domain_u=(-1, +1), domain_v=(-1, +1)):\n        \"\"\"Create a RhinoBrep from a plane.\n\n        Parameters\n        ----------\n        plane : :class:`compas.geometry.Plane` or :class:`compas.geometry.Frame`\n            The source plane.\n        domain_u : tuple of float, optional\n            The U domain of the plane. Defaults to (-1, +1).\n        domain_v : tuple of float, optional\n            The V domain of the plane. Defaults to (-1, +1).\n\n        Notes\n        -----\n        When using a Rhino Plane, to maintain the original orientation data\n        use :meth:`~compas_rhino.conversions.plane_to_compas_frame` and :meth:`~compas_rhino.conversions.frame_to_rhino_plane`.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        if isinstance(plane, Frame):\n            rhino_plane = frame_to_rhino_plane(plane)\n        else:\n            rhino_plane = plane_to_rhino(plane)\n        u = Rhino.Geometry.Interval(domain_u[0], domain_u[1])\n        v = Rhino.Geometry.Interval(domain_v[0], domain_v[1])\n        surface = Rhino.Geometry.PlaneSurface(rhino_plane, u, v)\n        return cls.from_native(surface.ToBrep())\n\n    @classmethod\n    def from_polygons(cls, polygons, tolerance=None, *args, **kwargs):\n        \"\"\"Create a RhinoBrep from a list of polygons.\n\n        Parameters\n        ----------\n        polygons : list of :class:`compas.geometry.Polygon`\n            The source polygons.\n\n        Returns\n        -------\n        list of :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        tolerance = tolerance or TOL.absolute\n        polylines = []\n        for polygon in polygons:\n            points = polygon.points + [polygon.points[0]]  # make a closed polyline from the polygon\n            polylines.append(Polyline(points=[*points]))\n        return cls.from_curves(polylines, tolerance)\n\n    @classmethod\n    def from_sphere(cls, sphere):\n        \"\"\"Create a RhinoBrep from a sphere.\n\n        Parameters\n        ----------\n        sphere : :class:`compas.geometry.Sphere`\n            The source sphere.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        rhino_sphere = sphere_to_rhino(sphere)\n        return cls.from_native(rhino_sphere.ToBrep())\n\n    @classmethod\n    def from_step(cls, filepath):\n        \"\"\"Construct a RhinoBrep from a STEP file.\n\n        Parameters\n        ----------\n        filepath : str\n            The path to the step file.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        if not (filepath.endswith(\".step\") or filepath.endswith(\".stp\")):\n            raise ValueError(\"Expected file with .step or .stp extension\")\n        return _import_brep_from_file(filepath)\n\n    @classmethod\n    def from_sweep(cls, profile, path, is_closed=False, tolerance=None):\n        \"\"\"Construct one or more RhinoBrep(s) from a sweep operation.\n\n        Parameters\n        ----------\n        profile : :class:`compas.geometry.Curve`\n            Curve describing the cross-section of the surface created by the sweep operation.\n        path : :class:`compas.geometry.Curve`\n            Curve describing the edge of the sweep surface. The profile curve is sweeped along this curve.\n        is_closed : bool, optional\n            If True, the resulting surface will be closed, if possible. Defaults to False.\n        tolerance : float, optional\n            The precision to use for the operation. Defaults to `TOL.absolute`.\n\n        Returns\n        -------\n        list of :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        tolerance = tolerance or TOL.absolute\n        if hasattr(profile, \"native_curve\"):\n            profile = curve_to_rhino(profile)\n        elif isinstance(profile, Polyline):\n            profile = polyline_to_rhino_curve(profile)\n        elif isinstance(profile, Line):\n            profile = line_to_rhino_curve(profile)\n        else:\n            raise TypeError(\"Unsupported profile type: {}\".format(type(profile)))\n\n        if hasattr(path, \"native_curve\"):\n            path = curve_to_rhino(path)\n        elif isinstance(path, Polyline):\n            path = polyline_to_rhino_curve(path)\n        elif isinstance(path, Line):\n            path = line_to_rhino_curve(path)\n        else:\n            raise TypeError(\"Unsupported path type: {}\".format(type(path)))\n\n        results = Rhino.Geometry.Brep.CreateFromSweep(path, profile, is_closed, tolerance)\n        if not results:\n            raise BrepError(\"Sweep operation ended with no result\")\n\n        return [cls.from_native(result) for result in results]\n\n    @classmethod\n    def from_torus(cls, torus):\n        \"\"\"Construct a RhinoBrep from a COMPAS torus.\n\n        Parameters\n        ----------\n        torus : :class:`compas.geometry.Torus`\n\n        Returns\n        -------\n        :class:`compas.geometry.BRep`\n\n        \"\"\"\n        rhino_torus = torus_to_rhino(torus)\n        return cls.from_native(rhino_torus.ToBrep())\n\n    # ==============================================================================\n    # Conversions\n    # ==============================================================================\n\n    # ==============================================================================\n    # Methods\n    # ==============================================================================\n\n    def contains(self, object):\n        \"\"\"Check if the Brep contains a given geometric primitive.\n\n        Only closed and manifold breps can be checked for containment.\n\n        Parameters\n        ----------\n        object : :class:`~compas.geometry.Point`, :class:`~compas.geometry.Curve`, :class:`~compas.geometry.Surface`\n            The object to check for containment.\n\n        Raises\n        ------\n        BrepError\n            If the Brep is not solid.\n\n        Returns\n        -------\n        bool\n            True if the object is contained in the Brep, False otherwise.\n\n        \"\"\"\n        if not self.is_solid:\n            raise BrepError(\"Cannot check for containment if brep is not manifold or is not closed\")\n\n        if isinstance(object, Point):\n            return self._brep.IsPointInside(point_to_rhino(object), TOL.absolute, False)\n        else:\n            raise NotImplementedError\n\n    def to_meshes(self, u=16, v=16):\n        \"\"\"Convert the faces of this Brep shape to meshes.\n\n        Parameters\n        ----------\n        u : int, optional\n            The number of mesh faces in the U direction of the underlying surface geometry of every face of the Brep.\n        v : int, optional\n            The number of mesh faces in the V direction of the underlying surface geometry of every face of the Brep.\n\n        Returns\n        -------\n        list[:class:`~compas.datastructures.Mesh`]\n\n        \"\"\"\n        rg_meshes = Rhino.Geometry.Mesh.CreateFromBrep(self._brep, Rhino.Geometry.MeshingParameters.Default)\n        meshes = [mesh_to_compas(m) for m in rg_meshes]\n        return meshes\n\n    def to_viewmesh(self, linear_deflection: float = 0.001):\n        \"\"\"\n        Convert the Brep to a single view mesh.\n\n        Note\n        ----\n        Edges as polylines is not currently implemented for RhinoBrep. Therefore, an empty list will be returned.\n\n        Parameters\n        ----------\n        linear_deflection : float, optional\n            The maximum linear deflection between the geometry and its discrete representation.\n\n        Returns\n        -------\n        tuple[:class:`compas.datastructures.Mesh`, list[:class:`compas.geometry.Polyline`]]\n\n        \"\"\"\n        return _join_meshes(self.to_meshes()), []\n\n    def to_step(self, filepath):\n        if not (filepath.endswith(\".step\") or filepath.endswith(\".stp\")):\n            raise ValueError(\"Attempted to export STEP but file ends with {} extension\".format(filepath.split(\".\")[-1]))\n        _export_brep_to_file(self._brep, filepath)\n\n    def transform(self, matrix):\n        \"\"\"Transform this Brep by given transformation matrix\n\n        Parameters\n        ----------\n        matrix: :class:`compas.geometry.Transformation`\n            The transformation matrix by which to transform this Brep.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        self._brep.Transform(transformation_to_rhino(matrix))\n\n    def trim(self, plane, tolerance=None):\n        \"\"\"Trim this brep by the given trimming plane.\n\n        Parameters\n        ----------\n        plane : :class:`compas.geometry.Frame` or :class:`compas.geometry.Plane`\n            The frame or plane to use when trimming. The discarded bit is in the direction of the frame's normal.\n        tolerance : float, optional\n            The precision to use for the trimming operation. Defaults to `TOL.absolute`.\n\n        Notes\n        -----\n        Trimming operation may result in multiple results (breps). When trimming, only one is used.\n        The used bit is the one on the opposite side of the cutting plane's normal.\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        BrepTrimmingError\n            If the trimming operation ended with no result.\n\n        See Also\n        --------\n        :meth:`compas_rhino.geometry.RhinoBrep.trimmed`\n\n        \"\"\"\n        result = self.trimmed(plane, tolerance)\n        self._brep = result.native_brep\n\n    def trimmed(self, plane, tolerance=None):\n        \"\"\"Returns a trimmed copy of this brep by the given trimming plane.\n\n        Parameters\n        ----------\n        plane : :class:`compas.geometry.Frame` or :class:`compas.geometry.Plane`\n            The frame or plane to use when trimming. The discarded bit is in the direction of the plane's normal.\n        tolerance : float, optional\n            The precision to use for the trimming operation. Defaults to `TOL.absolute`.\n\n        Notes\n        -----\n        Trimming operation may result in multiple results (breps). When trimming, only one is used.\n        The used bit is the one on the opposite side of the cutting plane's normal.\n\n        Returns\n        -------\n        :class:`~compas_rhino.geometry.RhinoBrep`\n\n        Raises\n        ------\n        BrepTrimmingError\n            If the trimming operation ended with no result.\n\n        See Also\n        --------\n        :meth:`compas_rhino.geometry.RhinoBrep.trim`\n\n        \"\"\"\n        tolerance = tolerance or TOL.absolute\n        if isinstance(plane, Frame):\n            plane = Plane.from_frame(plane)\n        results = self._brep.Trim(plane_to_rhino(plane), tolerance)\n        if not results:\n            raise BrepTrimmingError(\"Trim operation ended with no result\")\n        result = results[0]\n        capped = result.CapPlanarHoles(tolerance)\n        if capped:\n            result = capped\n        return RhinoBrep.from_native(result)\n\n    def slice(self, plane):\n        \"\"\"Slice through the Brep with a plane.\n\n        Parameters\n        ----------\n        plane : :class:`~compas.geometry.Plane` or :class:`~compas.geometry.Frame`\n            The plane to slice through the brep.\n\n        Returns\n        -------\n        list(:class:`~compas.geometry.Curve`)\n            Zero or more curves which represent the intersection(s) between the brep and the plane.\n\n        \"\"\"\n        if isinstance(plane, Frame):\n            plane = Plane.from_frame(plane)\n        curves = Rhino.Geometry.Brep.CreateContourCurves(self._brep, plane_to_rhino(plane))\n        return [curve_to_compas(curve) for curve in curves]\n\n    def split(self, cutter):\n        \"\"\"Splits a Brep into pieces using a Brep as a cutter.\n\n        Parameters\n        ----------\n        cutter : :class:`compas_rhino.geometry.RhinoBrep`\n            Another Brep to use as a cutter.\n\n        Returns\n        -------\n        list(:class:`compas_rhino.geometry.RhinoBrep`)\n            list of zero or more resulting Breps.\n\n        \"\"\"\n        resulting_breps = self._brep.Split(cutter.native_brep, TOL.absolute)\n        return [RhinoBrep.from_native(brep) for brep in resulting_breps]\n\n    def fillet(self, radius, edges=None):\n        \"\"\"Fillet edges of the Brep.\n\n        Parameters\n        ----------\n        radius : float\n            The radius of the fillet.\n        edges : list(:class:`compas_rhino.geometry.RhinoBrepEdge`)\n            The edges to fillet.\n\n        Raises\n        -------\n        BrepFilletingError\n            If the fillet operation fails.\n\n        \"\"\"\n        resulting_breps = self.filleted(radius, edges)\n        self._brep = resulting_breps.native_brep\n\n    def filleted(self, radius, edges=None):\n        \"\"\"Returns a filleted copy of the Brep.\n\n        Parameters\n        ----------\n        radius : float\n            The radius of the fillet.\n        edges : list(:class:`compas_rhino.geometry.RhinoBrepEdge`)\n            List of edges to exclude from the operation. When None all edges are included.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n            The resulting Brep.\n\n        Raises\n        -------\n        BrepFilletingError\n            If the fillet operation fails.\n\n        \"\"\"\n        all_edge_indices = set(edge.native_edge.EdgeIndex for edge in self.edges)  # type: ignore\n        excluded_indices = set(edge.native_edge.EdgeIndex for edge in edges or [])\n\n        edge_indices = all_edge_indices - excluded_indices\n        radii = [radius] * len(edge_indices)\n        blend = Rhino.Geometry.BlendType.Fillet\n        rail = Rhino.Geometry.RailType.DistanceFromEdge\n\n        resulting_breps = Rhino.Geometry.Brep.CreateFilletEdges(self._brep, edge_indices, radii, radii, blend, rail, TOL.absolute)\n        if not resulting_breps:\n            raise BrepFilletError(\"Fillet operation ended with no result\")\n        return RhinoBrep.from_native(resulting_breps[0])\n\n    def flip(self):\n        \"\"\"Flip the orientation of all faces of the Brep.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        self._brep.Flip()\n\n    def cap_planar_holes(self, tolerance=None):\n        \"\"\"Cap all planar holes in the Brep.\n\n        Parameters\n        ----------\n        tolerance : float, optional\n            The precision to use for the operation. Defaults to `TOL.absolute`.\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        BrepError\n            If the operation fails.\n\n        \"\"\"\n        tolerance = tolerance or TOL.absolute\n        result = self._brep.CapPlanarHoles(tolerance)\n        if result:\n            self._brep = result\n        else:\n            raise BrepError(\"Failed to cap planar holes\")\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "classes", "point", "brep", "line", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "compas-dev_compas_80c9a781a6.json", "repo": "compas-dev/compas"}
{"instruction": "A Rhino display conduit for faces.", "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport Rhino  # type: ignore\nimport System  # type: ignore\n\nfrom compas.data.validators import is_sequence_of_iterable\nfrom compas.itertools import iterable_like\n\nfrom .base import BaseConduit\n\n\nclass FacesConduit(BaseConduit):\n    \"\"\"A Rhino display conduit for faces.\n\n    Parameters\n    ----------\n    vertices : list[[float, float, float] | :class:`compas.geometry.Point`]\n        The coordinates of the vertices of the faces.\n    faces : list[list[int]]\n        The faces defined as lists of indices in `vertices`.\n    color : tuple[int, int, int] or list[tuple[int, int, int]], optional\n        The colors of the faces.\n        Default is None, in which case the default color is used for all faces (:attr:`FacesConduit.default_color`).\n\n    Attributes\n    ----------\n    color : list[System.Drawing.Color]\n        The color specification per face.\n\n    Class Attributes\n    ----------------\n    default_color : System.Drawing.Color\n        The default color is ``FromArgb(255, 255, 255)``.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        from compas.geometry import Polyhedron\n        from compas_rhino.conduits import FacesConduit\n\n        polyhedron = Polyhedron.generate(6)\n        conduit = FacesConduit(polyhedron.vertices, polyhedron.faces)\n\n        with conduit.enabled():\n            conduit.redraw(pause=5.0)\n\n    \"\"\"\n\n    default_color = System.Drawing.Color.FromArgb(255, 255, 255)\n\n    def __init__(self, vertices, faces, color=None, **kwargs):\n        super(FacesConduit, self).__init__(**kwargs)\n        self._color = None\n        self.vertices = vertices or []\n        self.faces = faces or []\n        self.color = color\n\n    @property\n    def color(self):\n        return self._color\n\n    @color.setter\n    def color(self, color):\n        if not color:\n            return\n        if not is_sequence_of_iterable(color):\n            color = [color]\n        color = [System.Drawing.Color.FromArgb(*c) for c in iterable_like(self.faces, color, self.default_color)]\n        self._color = color\n\n    def DrawForeground(self, e):\n        \"\"\"Draw the faces as polygons.\n\n        Parameters\n        ----------\n        e : Rhino.Display.DrawEventArgs\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        for i, face in enumerate(self.faces):\n            points = [Rhino.Geometry.Point3d(*self.vertices[key]) for key in face]\n            if self.color:\n                e.Display.DrawPolygon(points, self.color[i], True)\n            else:\n                e.Display.DrawPolygon(points, self.default_color, True)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "functions", "block", "RhinoCommon"], "original_file": "compas-dev_compas_a55ba016b3.json", "repo": "compas-dev/compas"}
{"instruction": "A wrapper for Rhino.Geometry.BrepEdge.", "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport Rhino  # type: ignore\n\nfrom compas.geometry import Arc\nfrom compas.geometry import BrepEdge\nfrom compas.geometry import Circle\nfrom compas.geometry import Ellipse\nfrom compas.geometry import Frame\nfrom compas.geometry import Line\nfrom compas_rhino.conversions import arc_to_compas\nfrom compas_rhino.conversions import arc_to_rhino\nfrom compas_rhino.conversions import circle_to_compas\nfrom compas_rhino.conversions import circle_to_rhino\nfrom compas_rhino.conversions import curve_to_compas_line\nfrom compas_rhino.conversions import ellipse_to_compas\nfrom compas_rhino.conversions import ellipse_to_rhino\nfrom compas_rhino.conversions import frame_to_rhino_plane\nfrom compas_rhino.conversions import line_to_rhino\nfrom compas_rhino.conversions import plane_to_compas_frame\nfrom compas_rhino.conversions import point_to_compas\nfrom compas_rhino.geometry import RhinoNurbsCurve\n\nfrom .vertex import RhinoBrepVertex\n\n\nclass RhinoBrepEdge(BrepEdge):\n    \"\"\"A wrapper for Rhino.Geometry.BrepEdge.\n\n    The expected native type here is a Rhino.Geometry.BrepTrim.\n    a BrepTrim holds a reference to its associated BrepEdge as well as its start a end vertices\n    in a correct topological order (!).\n\n    Attributes\n    ----------\n    curve : :class:`Rhino.Geometry.Curve3D`\n        The underlying geometry of this edge.\n    start_vertex : :class:`compas_rhino.geometry.RhinoBrepVertex`, read-only\n        The start vertex of this edge (taken from BrepTrim).\n    end_vertex : :class:`compas_rhino.geometry.RhinoBrepVertex`, read-only\n        The end vertex of this edge (taken from BrepTrim).\n    vertices : list[:class:`compas_rhino.geometry.RhinoBrepVertex`], read-only\n        The list of vertices which comprise this edge (start and end)\n    is_circle : bool, read-only\n        True if the geometry of this edge is a circle, False otherwise.\n    is_line : bool, read-only\n        True if the geometry of this edge is a line, False otherwise.\n    native_edge : :class:`Rhino.Geometry.BrepEdge`\n        The underlying BrepEdge object.\n\n    \"\"\"\n\n    def __init__(self, rhino_edge=None):\n        super(RhinoBrepEdge, self).__init__()\n        self._edge = None\n        self._curve = None\n        self._curve_type = None\n        self._start_vertex = None\n        self._end_vertex = None\n        self._mass_props = None\n        if rhino_edge:\n            self.native_edge = rhino_edge\n\n    # ==============================================================================\n    # Data\n    # ==============================================================================\n\n    @property\n    def __data__(self):\n        curve_type, curve, plane, domain = self._get_curve_geometry()\n        return {\n            \"curve_type\": curve_type,\n            \"curve\": curve.__data__,\n            \"frame\": plane_to_compas_frame(plane).__data__,\n            \"start_vertex\": self._edge.StartVertex.VertexIndex,\n            \"end_vertex\": self._edge.EndVertex.VertexIndex,\n            \"domain\": domain,\n        }\n\n    @classmethod\n    def __from_data__(cls, data, builder):\n        \"\"\"Construct an object of this type from the provided data.\n\n        Parameters\n        ----------\n        data : dict\n            The data dictionary.\n        builder : :class:`compas_rhino.geometry.BrepBuilder`\n            The object reconstructing the current Brep.\n\n        Returns\n        -------\n        :class:`compas.data.Data`\n            An instance of this object type if the data contained in the dict has the correct schema.\n\n        \"\"\"\n        instance = cls()\n        edge_curve = cls._create_curve__from_data__(data[\"curve_type\"], data[\"curve\"], data[\"frame\"], data[\"domain\"])\n        instance.native_edge = builder.add_edge(edge_curve, data[\"start_vertex\"], data[\"end_vertex\"])\n        return instance\n\n    # ==============================================================================\n    # Properties\n    # ==============================================================================\n\n    @property\n    def centroid(self):\n        return point_to_compas(self._mass_props.Centroid)\n\n    @property\n    def curve(self):\n        return self._curve\n\n    @property\n    def native_edge(self):\n        return self._edge\n\n    @native_edge.setter\n    def native_edge(self, value):\n        self._edge = value\n        self._mass_props = Rhino.Geometry.LengthMassProperties.Compute(value.EdgeCurve)\n        self._curve = RhinoNurbsCurve.from_rhino(value.EdgeCurve.ToNurbsCurve())\n        self._start_vertex = RhinoBrepVertex(value.StartVertex)\n        self._end_vertex = RhinoBrepVertex(value.EndVertex)\n\n    @property\n    def start_vertex(self):\n        return self._start_vertex\n\n    @property\n    def end_vertex(self):\n        return self._end_vertex\n\n    @property\n    def vertices(self):\n        return [self.start_vertex, self.end_vertex]\n\n    @property\n    def is_circle(self):\n        return self._edge.EdgeCurve.IsCircle()\n\n    @property\n    def is_line(self):\n        return self._edge.EdgeCurve.IsLinear()\n\n    @property\n    def is_ellipse(self):\n        return self._edge.EdgeCurve.IsEllipse()\n\n    @property\n    def length(self):\n        return self._mass_props.Length\n\n    # ==============================================================================\n    # Methods\n    # ==============================================================================\n\n    def _get_curve_geometry(self):\n        curve = self._edge.EdgeCurve\n        domain = [self._edge.Domain[0], self._edge.Domain[1]]\n        _, frame = curve.FrameAt(0)\n        if isinstance(curve, Rhino.Geometry.LineCurve):\n            return \"line\", curve_to_compas_line(curve), frame, domain\n        if isinstance(curve, Rhino.Geometry.NurbsCurve):\n            return \"nurbs\", RhinoNurbsCurve.from_rhino(curve), frame, domain\n        if isinstance(curve, Rhino.Geometry.ArcCurve):\n            if not curve.IsClosed:\n                return \"arc\", arc_to_compas(curve.Arc), curve.Arc.Plane, domain\n            is_circle, circle = curve.TryGetCircle()\n            if is_circle:\n                return \"circle\", circle_to_compas(circle), circle.Plane, domain\n            is_ellipse, ellipse = curve.TryGetEllipse()\n            if is_ellipse:\n                return \"ellipse\", ellipse_to_compas(ellipse), ellipse.Plane, domain\n            return \"nurbs\", curve.ToNurbsCurve(), frame, domain\n        raise ValueError(\"Unknown curve type: {}\".format(curve.__class__.__name__))\n\n    @staticmethod\n    def _create_curve__from_data__(curve_type, curve_data, frame_data, domain):\n        frame = Frame.__from_data__(frame_data)\n        if curve_type == \"line\":\n            line = Line.__from_data__(curve_data)\n            curve = Rhino.Geometry.LineCurve(line_to_rhino(line))\n        elif curve_type == \"circle\":\n            circle = circle_to_rhino(Circle.__from_data__(curve_data))\n            circle.Plane = frame_to_rhino_plane(frame)\n            curve = Rhino.Geometry.ArcCurve(circle)\n        elif curve_type == \"ellipse\":\n            ellipse = ellipse_to_rhino(Ellipse.__from_data__(curve_data))\n            ellipse.Plane = frame_to_rhino_plane(frame)\n            curve = Rhino.Geometry.NurbsCurve.CreateFromEllipse(ellipse)\n        elif curve_type == \"arc\":\n            arc = arc_to_rhino(Arc.__from_data__(curve_data))\n            curve = Rhino.Geometry.ArcCurve(arc)\n        elif curve_type == \"nurbs\":\n            curve = RhinoNurbsCurve.__from_data__(curve_data).rhino_curve\n        else:\n            raise ValueError(\"Unknown curve type: {}\".format(curve_type))\n        curve.Domain = Rhino.Geometry.Interval(*domain)\n        return curve\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "brep", "line", "curve", "functions", "RhinoCommon"], "original_file": "compas-dev_compas_cec111d832.json", "repo": "compas-dev/compas"}
{"instruction": "Class representing a general curve object.", "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport Rhino.Geometry  # type: ignore\n\nfrom compas.geometry import Curve\nfrom compas.geometry import Plane\nfrom compas_rhino.conversions import box_to_compas\nfrom compas_rhino.conversions import plane_to_compas_frame\nfrom compas_rhino.conversions import plane_to_rhino\nfrom compas_rhino.conversions import point_to_compas\nfrom compas_rhino.conversions import point_to_rhino\nfrom compas_rhino.conversions import transformation_to_rhino\nfrom compas_rhino.conversions import vector_to_compas\n\n\nclass RhinoCurve(Curve):\n    \"\"\"Class representing a general curve object.\n\n    Parameters\n    ----------\n    native_curve : :rhino:`Curve`\n        A Rhino curve.\n    name : str, optional\n        Name of the curve.\n\n    Attributes\n    ----------\n    dimension : int, read-only\n        The spatial dimension of the curve.\n    domain : tuple[float, float], read-only\n        The parameter domain.\n    start : :class:`compas.geometry.Point`, read-only\n        The point corresponding to the start of the parameter domain.\n    end : :class:`compas.geometry.Point`, read-only\n        The point corresponding to the end of the parameter domain.\n    is_closed : bool, read-only\n        True if the curve is closed.\n    is_periodic : bool, read-only\n        True if the curve is periodic.\n\n    Other Attributes\n    ----------------\n    native_curve : :rhino:`Curve`\n        The underlying Rhino curve.\n\n    \"\"\"\n\n    def __init__(self, native_curve, name=None):\n        super(RhinoCurve, self).__init__(name=name)\n        self._native_curve = native_curve\n\n    def __eq__(self, other):\n        return self.native_curve.IsEqual(other.native_curve)  # type: ignore\n\n    # ==============================================================================\n    # Data\n    # ==============================================================================\n\n    # ==============================================================================\n    # Properties\n    # ==============================================================================\n\n    @property\n    def rhino_curve(self):\n        return self._native_curve\n\n    @property\n    def native_curve(self):\n        return self._native_curve\n\n    @native_curve.setter\n    def native_curve(self, curve):\n        self._native_curve = curve\n\n    @property\n    def dimension(self):\n        if self.native_curve:\n            return self.native_curve.Dimension\n\n    @property\n    def domain(self):\n        if self.native_curve:\n            return self.native_curve.Domain.T0, self.native_curve.Domain.T1\n\n    @property\n    def start(self):\n        if self.native_curve:\n            return point_to_compas(self.native_curve.PointAtStart)\n\n    @property\n    def end(self):\n        if self.native_curve:\n            return point_to_compas(self.native_curve.PointAtEnd)\n\n    @property\n    def is_closed(self):\n        if self.native_curve:\n            return self.native_curve.IsClosed\n\n    @property\n    def is_periodic(self):\n        if self.native_curve:\n            return self.native_curve.IsPeriodic\n\n    # ==============================================================================\n    # Constructors\n    # ==============================================================================\n\n    @classmethod\n    def from_native(cls, native_curve):\n        \"\"\"Construct a curve from an existing Rhino curve.\n\n        Parameters\n        ----------\n        native_curve : Rhino.Geometry.Curve\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoCurve`\n\n        \"\"\"\n        return cls(native_curve)\n\n    @classmethod\n    def from_rhino(cls, native_curve):\n        \"\"\"Construct a curve from an existing Rhino curve.\n\n        Parameters\n        ----------\n        native_curve : Rhino.Geometry.Curve\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoCurve`\n\n        Warnings\n        --------\n        .. deprecated:: 2.3\n            Use `from_native` instead.\n\n        \"\"\"\n        return cls(native_curve)\n\n    # ==============================================================================\n    # Conversions\n    # ==============================================================================\n\n    # ==============================================================================\n    # Methods\n    # ==============================================================================\n\n    def copy(self):\n        \"\"\"Make an independent copy of the current curve.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoCurve`\n\n        \"\"\"\n        cls = type(self)\n        native_curve = self.native_curve.Duplicate()\n        return cls.from_native(native_curve)\n\n    def transform(self, T):\n        \"\"\"Transform this curve.\n\n        Parameters\n        ----------\n        T : :class:`compas.geometry.Transformation`\n            A COMPAS transformation.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        self.native_curve.Transform(transformation_to_rhino(T))  # type: ignore\n\n    def reverse(self):\n        \"\"\"Reverse the parametrisation of the curve.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        self.native_curve.Reverse()  # type: ignore\n\n    def point_at(self, t):\n        \"\"\"Compute a point on the curve.\n\n        Parameters\n        ----------\n        t : float\n            The value of the curve parameter. Must be between 0 and 1.\n\n        Returns\n        -------\n        :class:`compas.geometry.Point`\n            the corresponding point on the curve.\n\n        \"\"\"\n        point = self.native_curve.PointAt(t)  # type: ignore\n        return point_to_compas(point)\n\n    def tangent_at(self, t):\n        \"\"\"Compute the tangent vector at a point on the curve.\n\n        Parameters\n        ----------\n        t : float\n            The value of the curve parameter. Must be between 0 and 1.\n\n        Returns\n        -------\n        :class:`compas.geometry.Vector`\n            The corresponding tangent vector.\n\n        \"\"\"\n        vector = self.native_curve.TangentAt(t)  # type: ignore\n        return vector_to_compas(vector)\n\n    def curvature_at(self, t):\n        \"\"\"Compute the curvature at a point on the curve.\n\n        Parameters\n        ----------\n        t : float\n            The value of the curve parameter. Must be between 0 and 1.\n\n        Returns\n        -------\n        :class:`compas.geometry.Vector`\n            The corresponding curvature vector.\n\n        \"\"\"\n        vector = self.native_curve.CurvatureAt(t)  # type: ignore\n        return vector_to_compas(vector)\n\n    def frame_at(self, t):\n        \"\"\"Compute the local frame at a point on the curve.\n\n        Parameters\n        ----------\n        t : float\n            The value of the curve parameter.\n\n        Returns\n        -------\n        :class:`compas.geometry.Frame`\n            The corresponding local frame.\n\n        \"\"\"\n        t, plane = self.native_curve.FrameAt(t)  # type: ignore\n        return plane_to_compas_frame(plane)\n\n    def torsion_at(self, t):\n        \"\"\"Compute the torsion of the curve at a parameter.\n\n        Parameters\n        ----------\n        t : float\n            The value of the curve parameter.\n\n        Returns\n        -------\n        float\n            The torsion value.\n\n        \"\"\"\n        return self.native_curve.TorsionAt(t)  # type: ignore\n\n    # ==============================================================================\n    # Methods continued\n    # ==============================================================================\n\n    def closest_point(self, point, return_parameter=False):\n        \"\"\"Compute the closest point on the curve to a given point.\n\n        Parameters\n        ----------\n        point : :class:`compas.geometry.Point`\n            The test point.\n        return_parameter : bool, optional\n            If True, the parameter corresponding to the closest point should be returned in addition to the point.\n\n        Returns\n        -------\n        :class:`compas.geometry.Point` | tuple[:class:`compas.geometry.Point`, float]\n            If `return_parameter` is False, only the closest point is returned.\n            If `return_parameter` is True, the closest point and the corresponding parameter are returned.\n\n        \"\"\"\n        result, t = self.native_curve.ClosestPoint(point_to_rhino(point))  # type: ignore\n        if not result:\n            return\n        point = self.point_at(t)\n        if return_parameter:\n            return point, t\n        return point\n\n    def divide_by_count(self, count, return_points=False):\n        \"\"\"Divide the curve into a specific number of equal length segments.\n\n        Parameters\n        ----------\n        count : int\n            The number of segments.\n        return_points : bool, optional\n            If True, return the list of division parameters,\n            and the points corresponding to those parameters.\n            If False, return only the list of parameters.\n\n        Returns\n        -------\n        list[float] | tuple[list[float], list[:class:`compas.geometry.Point`]]\n            If `return_points` is False, the parameters of the discretisation.\n            If `return_points` is True, a list of points in addition to the parameters of the discretisation.\n\n        \"\"\"\n        params = self.native_curve.DivideByCount(count, True)  # type: ignore\n        if return_points:\n            points = [self.point_at(t) for t in params]\n            return params, points\n        return params\n\n    def divide_by_length(self, length, return_points=False):\n        \"\"\"Divide the curve into segments of specified length.\n\n        Parameters\n        ----------\n        length : float\n            The length of the segments.\n        return_points : bool, optional\n            If True, return the list of division parameters,\n            and the points corresponding to those parameters.\n            If False, return only the list of parameters.\n\n        Returns\n        -------\n        list[float] | tuple[list[float], list[:class:`compas.geometry.Point`]]\n            If `return_points` is False, the parameters of the discretisation.\n            If `return_points` is True, a list of points in addition to the parameters of the discretisation.\n\n        \"\"\"\n        params = self.native_curve.DivideByLength(length, True)  # type: ignore\n        if return_points:\n            points = [self.point_at(t) for t in params]\n            return params, points\n        return params\n\n    def aabb(self):\n        \"\"\"Compute the axis aligned bounding box of the curve.\n\n        Returns\n        -------\n        :class:`compas.geometry.Box`\n\n        \"\"\"\n        box = self.native_curve.getBoundingBox(True)  # type: ignore\n        return box_to_compas(box)\n\n    def length(self, precision=1e-8):\n        \"\"\"Compute the length of the curve.\n\n        Parameters\n        ----------\n        precision : float, optional\n            Required precision of the calculated length.\n\n        \"\"\"\n        return self.native_curve.GetLength(precision)  # type: ignore\n\n    def fair(self, tol=1e-3):\n        raise NotImplementedError\n\n    def offset(self, distance, direction, tolerance=1e-3):\n        \"\"\"Compute the length of the curve.\n\n        Parameters\n        ----------\n        distance : float\n            The offset distance.\n        direction : :class:`compas.geometry.Vector`\n            The normal direction of the offset plane.\n        tolerance : float, optional\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        point = self.point_at(self.domain[0])  # type: ignore\n        plane = Plane(point, direction)\n        plane = plane_to_rhino(plane)\n        offset_style = Rhino.Geometry.CurveOffsetCornerStyle.NONE\n        self.native_curve = self.native_curve.Offset(plane, distance, tolerance, offset_style)[0]  # type: ignore\n\n    def smooth(self):\n        raise NotImplementedError\n\n    def split(self):\n        raise NotImplementedError\n\n    def trim(self):\n        raise NotImplementedError\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "dimension", "curve", "functions", "RhinoCommon"], "original_file": "compas-dev_compas_ebc1c60672.json", "repo": "compas-dev/compas"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "import copy\nimport gzip\nimport json\nimport os\nimport time\n\nimport rhino3dm\nfrom rhino3dm import _rhino3dm as rh\n\n\n# sys.path.extend([\"/Users/andrewastakhov/PycharmProjects\", \"/Users/andrewastakhov/PycharmProjects/mmodel/panels_gh\"])\n\n\n#os.environ['PANELS_GH_DUMPS']=\"panels_gh/dumps\"\n\n\n\nclass RH:\n    def __init__(self, tag, time, layers, **kwargs):\n        self.time = time\n        super().__init__()\n        # self.frame = frame\n        self.tag = tag\n        self.__dict__ |= kwargs\n        self.model = rhino3dm.File3dm()\n        self.model2 = rhino3dm.File3dm()\n        self.layers = []\n        self.layers2 = []\n        for l in copy.deepcopy(layers):\n            try:\n                self.layers.append(Lay(model=self.model, **l))\n            except:\n                pass\n        for l2 in layers:\n            try:\n                self.layers2.append(Lay2(model=self.model2, **l2))\n            except:\n                pass\n\n    def write(self):\n\n        fp = f\"{os.getenv('PANELS_GH_DUMPS')}/build/cut/{self.tag}[:-2]/{self.tag}\"\n\n        fpfrez = f\"{os.getenv('PANELS_GH_DUMPS')}/build/frez/{self.tag}[:-2]/{self.tag}.3dm\"\n        self.model.Write(fp + \".3dm\", 7)\n        self.model2.Write(fpfrez, 7)\n\n        # self.model.Write(f\"dumps/{self.tag}/{self.tag}\"+\".dxf\")\n        # client.s3.put_object(Bucket=client.bucket,Key=f\"{client.bucket}/{client.prefix}/build{self.time}/{self.tag}/{self.time}\", Body=self.model.Encode())\n        return f\"{os.getenv('PANELS_GH_DUMPS')}/build/cut/{self.tag}[:-2]/{self.tag}.3dm\"\n\n   \n\nclass Lay:\n\n    def __init__(self, model=None, **kwargs):\n        super().__init__()\n        self.model = model\n        self._lay = rhino3dm.Layer()\n        self._lay.Name = kwargs[\"name\"]\n\n        self._lay.Color = tuple(kwargs[\"color\"])\n        self._lay.Visible = (kwargs[\"visible\"])\n\n        lay_index = self.model.Layers.Add(self._lay)\n        #m = rh.Transform.Mirror(rhino3dm.Plane.WorldYZ())\n        if kwargs[\"objects\"] is not None:\n            for o in kwargs[\"objects\"]:\n                # obj = list(self.model.Objects)[-1]\n\n                attrs = rhino3dm.ObjectAttributes()\n                attrs.PlotColorSource = rhino3dm.ObjectPlotColorSource.PlotColorFromLayer\n                attrs.ColorSource = rhino3dm.ObjectColorSource.ColorFromLayer\n                attrs.LayerIndex = lay_index\n                o[\"archive3dm\"] = 70\n                obj = rhino3dm.CommonObject.Decode(o)\n                #obj.Transform(m)\n                print(obj)\n                self.model.Objects.Add(obj, attrs)\nclass Lay2:\n\n    def __init__(self, model=None, **kwargs):\n        super().__init__()\n        self.model = model\n        self._lay = rhino3dm.Layer()\n        print(kwargs)\n\n        self._lay.Name = kwargs[\"name\"]\n\n        self._lay.Color = tuple(kwargs[\"color\"] + [255])\n        self._lay.Visible = (not kwargs[\"visible\"])\n\n        lay_index = self.model.Layers.Add(self._lay)\n        m = rh.Transform.Mirror(rhino3dm.Plane.WorldYZ())\n        if kwargs[\"objects\"] is not None:\n            for o in kwargs[\"objects\"]:\n                # obj = list(self.model.Objects)[-1]\n\n                attrs = rhino3dm.ObjectAttributes()\n                attrs.PlotColorSource = rhino3dm.ObjectPlotColorSource.PlotColorFromLayer\n                attrs.ColorSource = rhino3dm.ObjectColorSource.ColorFromLayer\n                attrs.LayerIndex = lay_index\n                o[\"archive3dm\"] = 70\n                obj = rhino3dm.CommonObject.Decode(o)\n\n                print(obj)\n                self.model.Objects.Add(obj, attrs)\n\n\nif __name__ == \"__main__\":\n\n    s = round(time.time())\n    ## os.mkdir(f\"{os.getenv('PANELS_GH_DUMPS')}/build{s}/cut\")\n    # os.mkdir(f\"{os.getenv('PANELS_GH_DUMPS')}/build{s}/frez\")\n    # client = sessions.S3Client(bucket=os.getenv('BUCKET'), prefix=\"workspace/cxm/arc/\")\n    for i in [\"build1670414928\"]:\n        with gzip.open(f\"{os.getenv('PANELS_GH_DUMPS')}/{i}.gz\", \"rb\", compresslevel=9) as gz:\n            bts = gz.read()\n            # client.s3.put_object(Bucket=client.bucket, Key=f\"{client.bucket }/{client.prefix}/build{s}\", Body=bts)\n            for obj in json.loads(bts):\n                print(obj)\n                a = RH(**obj, time=1)\n\n                os.environ['RHINO_TARGET'] = a.write()\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["layer", "classes", "functions"], "original_file": "contextmachine_mmodel_57b8737c97.json", "repo": "contextmachine/mmodel"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "__author__ = \"sofyadobycina\"\n\nimport os\n\ntry:\n    rs = __import__(\"rhinoscriptsyntax\")\nexcept:\n    import rhinoscript as rs\n\nimport sys\nimport imp\nimport ghpythonlib.treehelpers as th\n\nif os.getenv(\"USER\") == \"sofyadobycina\":\n    PWD = os.getenv(\"HOME\") + \"/Documents/GitHub/mmodel/panels_gh\"\n    sys.path.extend([os.getenv(\"HOME\") + \"/Documents/GitHub/mmodel/panels_gh\",\n                     os.getenv(\"HOME\") + \"Documents/GitHub/mmodel/panels_gh/cogs\",\n                     os.getenv(\"HOME\") + \"/Documents/GitHub/mmodel/panels_gh/main_panels\"])\nelse:\n    PWD = os.getenv(\"MMODEL_DIR\") + \"/panels_gh\"\n    sys.path.extend(\n        [os.getenv(\"MMODEL_DIR\") + \"/panels_gh\", os.getenv(\"MMODEL_DIR\") + \"/panels_gh/cogs\"])\n\ncogsfile, cogsfilename, (cogssuffix, cogsmode, cogstype) = imp.find_module(\"cogs\", path=[PWD])\ncogs = imp.load_module(\"cogs\", cogsfile, cogsfilename, (cogssuffix, cogsmode, cogstype))\n\ncogs.__init__(\"cogs\", \"generic nodule\")\nfrom cogs import TT\n\nreload(cogs)\n\nsidesfile, sidesfilename, (sidessuffix, sidesmode, sidestype) = imp.find_module(\"main_sides\", path=[PWD])\nmain_sides = imp.load_module(\"main_sides\", sidesfile, sidesfilename, (sidessuffix, sidesmode, sidestype))\n\nmain_sides.__init__(\"main_sides\", \"generic nodule\")\n\npfile, pfilename, (psuffix, pmode, ptype) = imp.find_module(\"main_panels\", path=[PWD])\nmain_panels = imp.load_module(\"main_panels\", pfile, pfilename, (psuffix, pmode, ptype))\n\nmain_panels.__init__(\"main_panels\", \"generic nodule\")\nfrom main_panels import N_4\n\nreload(main_panels)\n\npanelfile, panelfilename, (panelsuffix, panelmode, paneltype) = imp.find_module(\"panel_types\", path=[PWD])\npanel_types = imp.load_module(\"panel_types\", panelfile, panelfilename, (panelsuffix, panelmode, paneltype))\n\npanel_types.__init__(\"panel_types\", \"generic nodule\")\nfrom panel_types import P_1, P_2, N_1, N_3, N_2, P_3\n\nreload(panel_types)\n\nframelfile, framefilename, (framesuffix, framemode, frametype) = imp.find_module(\"main_framing\", path=[PWD])\nmain_framing = imp.load_module(\"main_framing\", framelfile, framefilename, (framesuffix, framemode, frametype))\n\nmain_framing.__init__(\"main_framing\", \"generic nodule\")\n\nreload(main_framing)\n\nfrom main_framing import MainFrame, MiniFrame\n\nimport main_tagging\n\nreload(main_tagging)\n\n\n\n\nclass UnrollPackage:\n    panels_dict = {'P_1': P_1, 'P_2': P_2, 'P_3': P_3, 'N_1': N_1, 'N_2': N_2, 'N_3': N_3, 'N_4': N_4}\n\n    def __init__(self, x, y, circle, bend_hole, p3_hole, cog_hole, elements):\n        self.cog = TT(x, y, circle)\n\n        self.bend_hole = bend_hole\n        self.p3_hole = p3_hole\n        self.cog_hole = cog_hole\n\n        self.data = []\n        self.m = []\n\n        # self.cogs_bend = random.choice([True, False])\n\n        for key, value in elements.items():\n\n            if key != 'N_4' and key != 'N_2' and key != 'P_3':\n\n                new = self.panels_dict[key](**value)\n\n                new.niche.cg = self.cog\n                new.niche.cog_hole = self.cog_hole\n                new.niche.generate_cogs()\n\n                try:\n                    for i in new.side:\n                        i.hls = self.bend_hole\n                except AttributeError:\n                    pass\n                setattr(self, key, MainFrame(new))\n\n                det = getattr(self, key)\n                self.data.append(det.all_elems)\n\n\n            elif key == 'N_2':\n                new = self.panels_dict[key](**value)\n                setattr(self, key, MainFrame(new))\n\n                det = getattr(self, key)\n                self.data.append(det.all_elems)\n\n\n\n\n            elif key == 'P_3':\n                new = self.panels_dict[key](**value)\n                new.hls = self.p3_hole\n                setattr(self, key, MiniFrame(new))\n                det = getattr(self, key)\n                self.data.append(det.all_elems)\n\n            else:\n                new = self.panels_dict[key](**value)\n                setattr(self, key, new)\n                det = getattr(self, key)\n\n\ndef main():\n    global x, y, circle, bend_hole, p3_hole, cog_hole, crv\n\n    a = UnrollPackage(x, y, circle, bend_hole, p3_hole, cog_hole, crv.__dict__)\n    side = th.list_to_tree(a.data)\n    #m = th.list_to_tree(a.m)\n    #m=a.m\n\n    return a, side\n\n\nif __name__ == \"__main__\":\n    a, side = main()\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "classes", "functions"], "original_file": "contextmachine_mmodel_7a70f1f24d.json", "repo": "contextmachine/mmodel"}
{"instruction": "Reads control points from a text file and generates a 1-dimensional list of control points.", "code": "from geomdl import _exchange as exch\nfrom geomdl._utilities import export\nfrom geomdl.exceptions import GeomdlException\n\n\ndef read_file(file, **kwargs):\n    binary = kwargs.get('binary', False)\n    skip_lines = kwargs.get('skip_lines', 0)\n    callback = kwargs.get('callback', None)\n    try:\n        for _ in range(skip_lines):\n            next(file)\n        content = fp.read() if callback is None else callback(fp)\n        return content\n    except IOError as e:\n        raise GeomdlException(\"An error occurred during reading '{0}': {1}\".format(file_name, e.args[-1]))\n    except Exception as e:\n        raise GeomdlException(\"An error occurred: {0}\".format(str(e)))\n\n\ndef write_file(file, content, **kwargs):\n    binary = kwargs.get('binary', False)\n    callback = kwargs.get('callback', None)\n    try:\n\n        if callback is None:\n            fp.write(content)\n        else:\n            callback(fp, content)\n        return True\n    except IOError as e:\n        raise GeomdlException(\"An error occurred during writing '{0}': {1}\".format(file_name, e.args[-1]))\n    except Exception as e:\n        raise GeomdlException(\"An error occurred: {0}\".format(str(e)))\n\n\n@export\ndef import_txt(file, two_dimensional=False, **kwargs):\n    \"\"\" Reads control points from a text file and generates a 1-dimensional list of control points.\n    The following code examples illustrate importing different types of text files for curves and surfaces:\n    .. code-block:: python\n        :linenos:\n        # Import curve control points from a text file\n        curve_ctrlpts = exchange.import_txt(file_name=\"control_points.txt\")\n        # Import surface control points from a text file (1-dimensional file)\n        surf_ctrlpts = exchange.import_txt(file_name=\"control_points.txt\")\n        # Import surface control points from a text file (2-dimensional file)\n        surf_ctrlpts, size_u, size_v = exchange.import_txt(file_name=\"control_points.txt\", two_dimensional=True)\n    If argument ``jinja2=True`` is set, then the input file is processed as a `Jinja2 <http://jinja.pocoo.org/>`_\n    template. You can also use the following convenience template functions which correspond to the given mathematical\n    equations:\n    * ``sqrt(x)``:  :math:`\\\\sqrt{x}`\n    * ``cubert(x)``: :math:`\\\\sqrt[3]{x}`\n    * ``pow(x, y)``: :math:`x^{y}`\n    You may set the file delimiters using the keyword arguments ``separator`` and ``col_separator``, respectively.\n    ``separator`` is the delimiter between the coordinates of the control points. It could be comma\n    ``1, 2, 3`` or space ``1 2 3`` or something else. ``col_separator`` is the delimiter between the control\n    points and is only valid when ``two_dimensional`` is ``True``. Assuming that ``separator`` is set to space, then\n    ``col_operator`` could be semi-colon ``1 2 3; 4 5 6`` or pipe ``1 2 3| 4 5 6`` or comma ``1 2 3, 4 5 6`` or\n    something else.\n    The defaults for ``separator`` and ``col_separator`` are *comma (,)* and *semi-colon (;)*, respectively.\n    The following code examples illustrate the usage of the keyword arguments discussed above.\n    .. code-block:: python\n        :linenos:\n        # Import curve control points from a text file delimited with space\n        curve_ctrlpts = exchange.import_txt(file_name=\"control_points.txt\", separator=\" \")\n        # Import surface control points from a text file (2-dimensional file) w/ space and comma delimiters\n        surf_ctrlpts, size_u, size_v = exchange.import_txt(file_name=\"control_points.txt\", two_dimensional=True,\n                                                           separator=\" \", col_separator=\",\")\n    Please note that this function does not check whether the user set delimiters to the same value or not.\n    :param file_name: file name of the text file\n    :type file_name: str\n    :param two_dimensional: type of the text file\n    :type two_dimensional: bool\n    :return: list of control points, if two_dimensional, then also returns size in u- and v-directions\n    :rtype: list\n    :raises GeomdlException: an error occurred reading the file\n    \"\"\"\n    # Read file\n    content = file.read()\n\n    # Are we using a Jinja2 template?\n    j2tmpl = kwargs.get('jinja2', False)\n    if j2tmpl:\n        content = exch.process_template(content)\n\n    # File delimiters\n    col_sep = kwargs.get('col_separator', \";\")\n    sep = kwargs.get('separator', \",\")\n\n    return exch.import_text_data(content, sep, col_sep, two_dimensional)\n\n\n@export\ndef export_txt(obj, file, two_dimensional=False, **kwargs):\n    \"\"\" Exports control points as a text file.\n    For curves the output is always a list of control points. For surfaces, it is possible to generate a 2-dimensional\n    control point output file using ``two_dimensional``.\n    Please see :py:func:`.exchange.import_txt()` for detailed description of the keyword arguments.\n    :param obj: a spline geometry object\n    :type obj: abstract.SplineGeometry\n    :param file_name: file name of the text file to be saved\n    :type file_name: str\n    :param two_dimensional: type of the text file (only works for Surface objects)\n    :type two_dimensional: bool\n    :raises GeomdlException: an error occurred writing the file\n    \"\"\"\n    # Check if the user has set any control points\n    if obj.ctrlpts is None or len(obj.ctrlpts) == 0:\n        raise exch.GeomdlException(\"There are no control points to save!\")\n\n    # Check the usage of two_dimensional flag\n    if obj.pdimension == 1 and two_dimensional:\n        # Silently ignore two_dimensional flag\n        two_dimensional = False\n\n    # File delimiters\n    col_sep = kwargs.get('col_separator', \";\")\n    sep = kwargs.get('separator', \",\")\n\n    content = exch.export_text_data(obj, sep, col_sep, two_dimensional)\n    return write_file(file, content)\nimport rhino3dm._rhino3dm as rh\nrh.Transform.Rotation()\nrhino3dm.Transform.", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["surface", "point", "line", "dimension", "curve", "functions", "block"], "original_file": "contextmachine_mmodel_b7ace913cb.json", "repo": "contextmachine/mmodel"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "import copy\nimport gzip\nimport json\nimport os\nimport time\n\nimport rhino3dm\nimport rhino3dm as rh\n\n\nclass RH:\n    def __init__(self, tag, time, layers, **kwargs):\n\n        self.time = time\n        super().__init__()\n        # self.frame = frame\n        self.tag = tag\n        self.__dict__ |= kwargs\n        self.model = rhino3dm.File3dm()\n        self.model2 = rhino3dm.File3dm()\n        self.layers = []\n        self.layers2 = []\n\n        for l in copy.deepcopy(layers):\n            try:\n                self.layers.append(Lay(model=self.model, **l))\n            except:\n                continue\n\n        for l2 in layers:\n\n            try:\n                self.layers2.append(Lay2(model=self.model2, **l2))\n            except:\n                continue\n\n    def write(self):\n        spl = self.tag.split(\"-\")\n\n        try:\n            os.makedirs(f\"{os.getenv('PANELS_GH_DUMPS')}/build/cut/{self.tag[:-2]}\", exist_ok=False)\n            os.makedirs(f\"{os.getenv('PANELS_GH_DUMPS')}/build/frez/{self.tag[:-2]}\", exist_ok=False)\n        except:\n            pass\n        fp = f\"{os.getenv('PANELS_GH_DUMPS')}/build/cut/{self.tag[:-2]}/{self.tag}.3dm\"\n        fpfrez = f\"{os.getenv('PANELS_GH_DUMPS')}/build/frez/{self.tag[:-2]}/{self.tag}.3dm\"\n        self.model.Write(fp, 7)\n        self.model2.Write(fpfrez, 7)\n        # todxf(fp + \".3dm\", fp2 + \".dxf\")\n\n        # self.model.Write(f\"dumps/{self.tag}/{self.tag}\"+\".dxf\")\n        # client.s3.put_object(Bucket=client.bucket,Key=f\"{client.bucket}/{client.prefix}/build{self.time}/{self.tag}/{self.time}\", Body=self.model.Encode())\n        return f\"{os.getenv('PANELS_GH_DUMPS')}/build/cut/{spl[:-1]}/{self.tag}.3dm\"\n\n\nclass Lay:\n\n    def __init__(self, model=None, **kwargs):\n        super().__init__()\n        self.model = model\n        self._lay = rhino3dm.Layer()\n        self._lay.Name = kwargs[\"name\"]\n\n        self._lay.Color = tuple(kwargs[\"color\"])\n        if kwargs[\"name\"] == \"Laser Cut\":\n            self._lay.Visible = True\n        else:\n            self._lay.Visible = (kwargs[\"visible\"])\n\n        lay_index = self.model.Layers.Add(self._lay)\n        m = rh.Transform.Mirror(rhino3dm.Plane.WorldYZ())\n        if kwargs[\"objects\"] is not None:\n            for o in kwargs[\"objects\"]:\n                # obj = list(self.model.Objects)[-1]\n\n                attrs = rhino3dm.ObjectAttributes()\n                attrs.PlotColorSource = rhino3dm.ObjectPlotColorSource.PlotColorFromLayer\n                attrs.ColorSource = rhino3dm.ObjectColorSource.ColorFromLayer\n                attrs.LayerIndex = lay_index\n                o[\"archive3dm\"] = 70\n                obj = rhino3dm.CommonObject.Decode(o)\n                obj.Transform(m)\n                # print(obj)\n                self.model.Objects.Add(obj, attrs)\n\n\nclass Lay2:\n\n    def __init__(self, model=None, **kwargs):\n        super().__init__()\n        self.model = model\n        self._lay = rhino3dm.Layer()\n        self._lay.Name = kwargs[\"name\"]\n\n        self._lay.Color = tuple(kwargs[\"color\"] + [255])\n        if kwargs[\"name\"] == \"Laser Cut\":\n            self._lay.Visible = True\n        else:\n            self._lay.Visible = (kwargs[\"visible\"])\n\n        lay_index = self.model.Layers.Add(self._lay)\n        m = rh.Transform.Mirror(rhino3dm.Plane.WorldYZ())\n        if kwargs[\"objects\"] is not None:\n            for o in kwargs[\"objects\"]:\n                # obj = list(self.model.Objects)[-1]\n\n                attrs = rhino3dm.ObjectAttributes()\n                attrs.PlotColorSource = rhino3dm.ObjectPlotColorSource.PlotColorFromLayer\n                attrs.ColorSource = rhino3dm.ObjectColorSource.ColorFromLayer\n                attrs.LayerIndex = lay_index\n                o[\"archive3dm\"] = 70\n                obj = rhino3dm.CommonObject.Decode(o)\n\n                # print(obj)\n                self.model.Objects.Add(obj, attrs)\n\n\nif __name__ == \"__main__\":\n\n    s = round(time.time())\n    os.makedirs(f\"{os.getenv('PANELS_GH_DUMPS')}/build/cut\")\n    os.makedirs(f\"{os.getenv('PANELS_GH_DUMPS')}/build/frez\")\n    # client = sessions.S3Client(bucket=os.getenv('BUCKET'), prefix=\"workspace/cxm/arc/\")\n    for i in os.scandir(f\"{os.getenv('PANELS_GH_DUMPS')}/panels\"):\n        with open(i.path, \"rb\") as gz:\n            print(i.name, end=\"\", flush=True)\n            # client.s3.put_object(Bucket=client.bucket, Key=f\"{client.bucket }/{client.prefix}/build{s}\", Body=bts)\n            for obj in json.loads(gzip.decompress(gz)):\n                print(obj['tag'])\n                # print(obj)\n                a = RH(**obj, time=1)\n\n                a.write()\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["layer", "classes", "functions"], "original_file": "contextmachine_mmodel_ea825e4873.json", "repo": "contextmachine/mmodel"}
{"instruction": "Implement the function 'try_catch' for Rhino scripting", "code": "import Rhino\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport traceback\n\n\nimport Eto\n\nimport os\nFORM_KEY = 'AECademy_modeless_form'\nBIN_FOLDER = \"{}\\\\bin\".format(os.path.dirname(os.path.realpath(__file__)))\nimport sys\nsys.path.append(os.path.dirname(os.path.realpath(__file__)))\nsys.path.append(BIN_FOLDER)\nimport utility\nreload(utility)\n\n\ndef try_catch(func):\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            rs.TextOut(traceback.format_exc())\n            return None\n        \n    return wrapper\n\n\nclass AECedamyUI(Eto.Forms.Form):\n\n    # Initializer\n    @try_catch\n    def __init__(self):\n \n        self.data = None\n        self.main_url = \"https://github.com/zsenarchitect/AEC-Hack\"\n        \n        \n        # Basic form initialization\n        self.initiate_form()\n        # Create the form's controls\n        self.build_form()\n        \n        self.check_ui()\n\n\n    # Basic form initialization\n    def initiate_form(self):\n        self.Title = 'AECademy'\n        self.Padding = Eto.Drawing.Padding(5)\n        self.Resizable = True\n        self.Maximizable = False\n        self.Minimizable = False\n        self.ShowInTaskbar = False\n        \n        self.MinimumSize = Eto.Drawing.Size(200, 150)\n        \n        \n        \n        # self.resource_folder = \"{}\\\\bin\".format(Path.cwd().parent)\n        self.resource_folder = BIN_FOLDER\n\n        # FormClosed event handler\n        self.Closed += self.form_close_clicked\n\n    \n    # Create all of the controls used by the form\n    def build_form(self):\n        # Create table layout\n        layout = Eto.Forms.TableLayout()\n        layout.Padding = Eto.Drawing.Padding(10)\n        layout.Spacing = Eto.Drawing.Size(5, 5)\n\n        layout.Rows.Add(self.build_logo())\n        \n        A = Eto.Forms.Label(Text = 'Search Database with your sketch!\\nScan QR code below to begin sketching!' )\n        A.TextColor = Eto.Drawing.Color.FromArgb(255, 255, 255)\n        # A.Font = Eto.Drawing.Font(size = 20)\n        # A.HorizontalAlignment = Eto.Forms.HorizontalAlignment.Center\n        # A.FontFamily = Eto.Drawing.FontFamily(\"Cascadia Mono\")\n        layout.Rows.Add(A)\n        layout.Rows.Add(self.build_qr_code())\n        layout.Rows.Add(Rhino.UI.Controls.Divider())\n        layout.Rows.Add(self.create_user_buttons())\n        \n        layout.BackgroundColor = Eto.Drawing.Color.FromArgb(0, 0, 0)\n        \n        # Set the content\n        self.Content = layout\n\n            \n    def build_logo(self):\n        self.logo = Eto.Forms.ImageView()\n        logo_path = r\"{}\\\\logo.png\".format(self.resource_folder)\n        temp_bitmap = Eto.Drawing.Bitmap(logo_path)\n        self.logo.Image = temp_bitmap.WithSize(200,200)\n        return self.logo\n\n\n    def build_qr_code(self):\n        layout = Eto.Forms.TableLayout(Spacing = Eto.Drawing.Size(5, 5))\n        self.qr_code = Eto.Forms.ImageView()\n        qr_code_path = r\"{}\\\\QR.png\".format(self.resource_folder)\n        temp_bitmap = Eto.Drawing.Bitmap(qr_code_path)\n        self.qr_code.Image = temp_bitmap.WithSize(100,100)\n        \n        bt_open_url = Eto.Forms.Button(Text = ' Open In Browser ')\n        bt_open_url.Click += self.open_url_clicked\n        bt_open_url.BackgroundColor = Eto.Drawing.Color.FromArgb(50,50,50)\n        bt_open_url.TextColor = Eto.Drawing.Color.FromArgb(255, 255, 255)\n        \n        layout.Rows.Add(Eto.Forms.TableRow(None, self.qr_code, None))\n        layout.Rows.Add(Eto.Forms.TableRow(None, bt_open_url, None))\n        return layout\n\n\n    def create_user_buttons(self):\n        # Action button, func TBD\n        self.bt_action = Eto.Forms.Button(Text = ' Aquire! ')\n        self.bt_action.Click += self.action_bt_clicked\n        self.bt_action.BackgroundColor = Eto.Drawing.Color.FromArgb(50,50,50)\n        self.bt_action.TextColor = Eto.Drawing.Color.FromArgb(255, 255, 255)\n        \n        bt_fetch = Eto.Forms.Button(Text = ' Get Update! ')\n        bt_fetch.Click += self.fetch_bt_clicked\n        bt_fetch.BackgroundColor = Eto.Drawing.Color.FromArgb(50,50,50)\n        bt_fetch.TextColor = Eto.Drawing.Color.FromArgb(255, 255, 255)\n\n\n        self.bt_upload = Eto.Forms.Button(Text = ' Publish! ')\n        self.bt_upload.Click += self.fetch_bt_clicked\n        self.bt_upload.BackgroundColor = Eto.Drawing.Color.FromArgb(50,50,50)\n        self.bt_upload.TextColor = Eto.Drawing.Color.FromArgb(255, 255, 255)\n        \n        \n        layout = Eto.Forms.TableLayout(Spacing = Eto.Drawing.Size(5, 5))\n        layout.Rows.Add(Eto.Forms.TableRow(None,bt_fetch, self.bt_action, self.bt_upload, None))\n        return layout\n\n    def check_ui(self):\n        if self.data:\n            self.bt_action.Enabled = True\n            self.bt_action.BackgroundColor = Eto.Drawing.Color.FromArgb(50,50,50)\n            self.bt_upload.Enabled = True\n            self.bt_upload.BackgroundColor = Eto.Drawing.Color.FromArgb(50,50,50)\n        else:\n            self.bt_action.Enabled = False\n            self.bt_action.BackgroundColor = Eto.Drawing.Color.FromArgb(100 ,200,200)\n            self.bt_upload.Enabled = True\n            self.bt_upload.BackgroundColor = Eto.Drawing.Color.FromArgb(100,150,150)\n\n    @try_catch\n    def action_bt_clicked(self, sender, e):\n        self.check_ui()\n        if not self.data:\n            return\n        print (\"importing\")\n        utility.import_to_rhino(self.data)\n        \n        \n    @try_catch\n    def open_url_clicked(self, sender, e):\n        import webbrowser\n        webbrowser.open(self.main_url)\n        \n    @try_catch\n    def fetch_bt_clicked(self, sender, e):\n        print (\"fetching\")\n        self.data = utility.fetch_from_web()\n        self.check_ui()\n        \n        \n    @try_catch\n    def form_close_clicked(self, sender, e):\n\n        # Dispose of the form and remove it from the sticky dictionary\n        if sc.sticky.has_key(FORM_KEY):\n            form = sc.sticky[FORM_KEY]\n            if form:\n                form.Dispose()\n                form = None\n            sc.sticky.Remove(FORM_KEY)\n            \n\n@try_catch\ndef show_ui():\n    # See if the form is already visible\n    if sc.sticky.has_key(FORM_KEY):\n        return\n        \n\n    # Create and show form\n    form = AECedamyUI()   \n    form.Owner = Rhino.UI.RhinoEtoApp.MainWindow\n    form.Show()\n    sc.sticky[FORM_KEY] = form\n\n\n######################  main code below   #########\nif __name__ == \"__main__\":\n\n    show_ui()\n\n\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "classes", "functions"], "original_file": "czwangxtt_AEC-Hack_71bd78e9b1.json", "repo": "czwangxtt/AEC-Hack"}
{"instruction": "Implement the function 'split_curve' for Rhino scripting", "code": "import Rhino.Geometry as rh\nfrom scriptcontext import doc\n\n# get absolute and angle tolerances from document\nabs_tol = doc.ModelAbsoluteTolerance\nang_tol = doc.ModelAngleToleranceRadians\n\n# this function splits a curve c1 with another curve c2\n\n\ndef split_curve(c1, c2, close):\n    # get intersection events between two curves\n    inter = rh.Intersect.Intersection.CurveCurve(c1, c2, abs_tol, abs_tol)\n\n    # get parameters on first curve from all intersection events\n    # this code uses a \"list comprehension\" which is a shortcut for iterating over a list in Python\n    # this single line does the same thing as:\n\n    # p = []\n    # for i in range(inter.Count):\n    # p.append(inter[i].ParameterA)\n\n    p = [inter[i].ParameterA for i in range(inter.Count)]\n\n    # handle multiple intersections (for non-convex boundaries)\n\n    # if more than two parameters are returned, it means that the boundary shape is non-convex\n    # and was split by the split line into more than two pieces\n    # since we only want two pieces, we must find two consecutive parameters\n    # which split the boundary into only two separate pieces\n\n    if len(p) > 2:\n\n        # loop over all parameters\n        for i in range(len(p)):\n\n            # get the points at the previous and current parameters in the list\n            pt1 = c1.PointAt(p[i-1])\n            pt2 = c1.PointAt(p[i])\n\n            # get the line between the two points\n            l = rh.Line(pt1, pt2).ToNurbsCurve()\n\n            # check how many times the line intersects the boundary\n            inter = rh.Intersect.Intersection.CurveCurve(\n                c1, l.ToNurbsCurve(), abs_tol, abs_tol)\n\n            # if there are only two intersections, return the two parameters\n            # and break out of loop\n            if len(inter) == 2:\n                p = [p[i-1], p[i]]\n                break\n\n    # split the curve by the parameters\n    pieces = c1.Split(p)\n\n    # create a new list to store the final curves\n    curves = []\n\n    # iterate over pieces\n    for piece in pieces:\n        # if closed curves were requested and the curve is not closed\n        if close == True and not piece.IsClosed:\n            # create a new line to close the curve, join them together, and add the result to curves list\n            line = rh.Line(piece.PointAtStart, piece.PointAtEnd).ToNurbsCurve()\n            curves += rh.NurbsCurve.JoinCurves([piece, line])\n        else:\n            # otherwise add the original piece to the curves list\n            curves.append(piece)\n\n    # return the final curves\n    return curves\n\n# this function splits a space with two parameters\n\n\ndef split_space(curve, dir, param):\n\n    # get the bounding box of the curve\n    bb = curve.GetBoundingBox(True)\n    # get the base point of the bounding box\n    base_pt = rh.Point3d(bb.Min.X, bb.Min.Y, 0.0)\n\n    # get the x and y dimensions of the bounding box\n    x = bb.Max.X - bb.Min.X\n    y = bb.Max.Y - bb.Min.Y\n\n    # create a list of the x,y dimensions and x,y unit vectors\n    dims = [x, y]\n    vecs = [rh.Vector3d(1, 0, 0), rh.Vector3d(0, 1, 0)]\n\n    # create a vector to position the split line based on the two parameters\n    vec_1 = vecs[dir] * dims[dir] * param\n\n    # copy the base point\n    new_pt_1 = rh.Point3d(base_pt)\n    # move the new point according to the vector\n    new_pt_1.Transform(rh.Transform.Translation(vec_1))\n\n    # calculate the opposite of the dir parameter\n    # if the parameter is 0 this results in 1, if 1 then 0\n    other_dir = abs(dir-1)\n\n    # create a vector in the other direction the full extent of the bounding box\n    vec_2 = vecs[other_dir] * dims[other_dir]\n\n    # create a copy of the moved point\n    new_pt_2 = rh.Point3d(new_pt_1)\n    # move the point to define the other end point of the split line\n    new_pt_2.Transform(rh.Transform.Translation(vec_2))\n\n    # create the split line and convert it to a Nurbs Curve\n    # (this is necessary to make the splitting work in the next function)\n    split_line = rh.Line(new_pt_1, new_pt_2).ToNurbsCurve()\n\n    # use the split_curve() function to split the boundary with the split line\n    parts = split_curve(curve, split_line, True)\n\n    # return the curves resulting from the split\n    return parts\n\n# this function calls the split_space() function recursively\n# to continuosly split an input curve into parts based on a set of parameters\n\n\ndef split_recursively(curves, dirs, params):\n\n    # if there are no more parameters in the list, return the input curves\n    if len(dirs) <= 0 or len(params) <= 0:\n        return curves\n\n    # get the first parameters and the first curve from the input lists\n    dir = dirs.pop(0)\n    param = params.pop(0)\n    curve = curves.pop(0)\n\n    # split the curve and add the results to the curves list\n    curves += split_space(curve, dir, param)\n\n    # run the split_recursively() function again with the updated curves list and the remaining parameters\n    return split_recursively(curves, dirs, params)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "line", "dimension", "curve", "functions", "RhinoCommon"], "original_file": "danilnagy_design-ai_d823fac191.json", "repo": "danilnagy/design-ai"}
{"instruction": "temp function for playing around", "code": "import rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\nimport Rhino\r\nfrom Rhino.Geometry import Point3d, Vector3d, Ellipse, Curve\r\nimport math\r\nimport random\r\nimport System\r\n\r\ndef single_curve(scale, n_intermediate=3):\r\n    \r\n    zs = [0]\r\n    ys = [0]\r\n    \r\n    for _ in range(n_intermediate):\r\n        zs.append(scale * random.uniform(0, 1))\r\n        ys.append(random.normalvariate(.5, .2) * scale)\r\n    \r\n    zs.sort()\r\n    zs.append(scale)\r\n    ys.append(0)\r\n    xs = [0] * (n_intermediate + 2)\r\n    \r\n    points = [ Rhino.Geometry.Point3d(x,y,z) for x, y, z in zip(xs, ys, zs) ]\r\n    \r\n    return Curve.CreateInterpolatedCurve(points, degree=3)\r\n    \r\n\r\ndef treetop(scale = 10, **kwargs):\r\n    \r\n    curves = []\r\n    for step in range(4):\r\n        angle = step * math.pi/2\r\n        \r\n        curve = single_curve(scale)\r\n        curve.Rotate(angle, Vector3d(0,0,1), Point3d(0,0,0))\r\n        curves.append(curve)\r\n    \r\n    result = Rhino.Geometry.Brep.CreateFromLoft(curves, Point3d.Unset, Point3d.Unset, Rhino.Geometry.LoftType.Loose, closed=True)\r\n \r\n    # TODO: material: Paint, (100, 200, 100), matte\r\n    return result # For some reason, it returns an array\r\n    \r\n    \r\ndef ellipse(scale = 10, x=0, y=0, z=0):\r\n    base_half_length = scale * random.normalvariate(0.1, .02)\r\n    base_half_width =  scale * random.normalvariate(0.1, .02) \r\n    \r\n    return Rhino.Geometry.Ellipse(Point3d(x,y,z), Point3d(x + base_half_length, y, z), Point3d(x, y + base_half_width, z))\r\n\r\ndef jitter(n):\r\n    return n * random.normalvariate(1, .2)\r\n\r\ndef trunk(scale = 10, n_intermediate = 1, **kwargs):\r\n    \r\n    ellipses = [ellipse(scale)]\r\n    \r\n    for i in range(n_intermediate):\r\n        \r\n        x = jitter(scale/2) - scale / 2\r\n        y = jitter(scale/2) - scale / 2\r\n        z = scale * (i + 1) / (n_intermediate + 1)\r\n        \r\n        this_one = ellipse(scale / 2, x, y, z)\r\n        ellipses.append(this_one)\r\n        \r\n    ellipses.append(ellipse(scale, z = scale))\r\n    \r\n    curves = []\r\n    \r\n    for e in ellipses:\r\n        \r\n        curve = e.ToNurbsCurve()\r\n        curve.Rotate(random.uniform(0, 1) * 2 * math.pi, Vector3d(0,0,1), Point3d(0,0,0))\r\n        #sc.doc.Objects.AddCurve(curve)\r\n        curves.append(curve)\r\n        \r\n    # Normal Loft returns a lot funkier trunks\r\n    result = Rhino.Geometry.Brep.CreateFromLoft(curves, Point3d.Unset, Point3d.Unset, Rhino.Geometry.LoftType.Loose, closed=False)\r\n    result = result[0].CapPlanarHoles(1e-2)\r\n    \r\n    return [result]\r\n \r\ndef tree(scale = 10, **kwargs):\r\n    \r\n    top = treetop(scale, **kwargs)[0]\r\n    tr = trunk(scale, **kwargs)[0]\r\n    \r\n    center_top = Rhino.Geometry.AreaMassProperties.Compute(top).Centroid\r\n    apex_trunk = tr.ClosestPoint(Point3d(0,0, 2*scale))\r\n    \r\n    \r\n    top.Translate(apex_trunk - center_top)\r\n    \r\n    # TODO: align to center of mass\r\n    \r\n    return [tr, top]\r\n    \r\ndef rendermaterial(name):\r\n    for rendermaterial in sc.doc.RenderMaterials.GetEnumerator():\r\n        if rendermaterial.Name == name:\r\n            return rendermaterial\r\n\r\n\r\ndef many(scale = 10, side = 5, **kwargs):\r\n    \"\"\"temp function for playing around\r\n    \"\"\"\r\n    attributes = Rhino.DocObjects.ObjectAttributes()\r\n    attributes.MaterialSource = Rhino.DocObjects.ObjectMaterialSource.MaterialFromObject\r\n    \r\n    for x in range(-scale * side, scale * side, 2 * scale):\r\n        for y in range(-scale * side, scale * side, 2 * scale):\r\n            ids = []\r\n            for ix, each in enumerate(tree(scale, **kwargs)):\r\n                \r\n                each.Translate(x, y, 0)\r\n\r\n                this_id = sc.doc.Objects.AddBrep(each, attributes)\r\n                obj = rs.coercerhinoobject(this_id)\r\n                obj.RenderMaterial = rendermaterial('bark') if ix == 0 else rendermaterial('leaves')\r\n                obj.CommitChanges()\r\n                \r\n                ids.append(this_id)\r\n            \r\n                \r\n            group_id = sc.doc.Groups.Add(ids)\r\n            \r\n    sc.doc.Views.Redraw()\r\n    \r\n\r\n    \r\ndef add_materials():\r\n    \r\n    if sc.doc.RenderMaterials.Count > 0:\r\n        return list(sc.doc.RenderMaterials.GetEnumerator())\r\n    \r\n    leaves = Rhino.DocObjects.Material()\r\n    light_green = System.Drawing.Color.FromArgb(255, 100, 200, 100)\r\n    leaves.DiffuseColor = light_green\r\n    leaves.Name = 'leaves'\r\n    render_leaves = Rhino.Render.RenderMaterial.CreateBasicMaterial(leaves)\r\n    sc.doc.RenderMaterials.Add(render_leaves)\r\n    \r\n    \r\n    bark = Rhino.DocObjects.Material()\r\n    light_brown = System.Drawing.Color.FromArgb(255, 200, 100, 30)\r\n    bark.DiffuseColor = light_brown\r\n    bark.Name = 'bark'\r\n    render_bark = Rhino.Render.RenderMaterial.CreateBasicMaterial(bark)\r\n    sc.doc.RenderMaterials.Add(render_bark)\r\n\r\n    # from https://github.com/mcneel/rhino-developer-samples/blob/6/rhinopython/SampleAddRenderMaterials.py\r\n    \r\n    \r\n    return render_leaves, render_bark\r\n    \r\nif __name__ == \"__main__\":\r\n    \r\n    \r\n    leaves, bark = add_materials()\r\n    many(side = 5)\r\n           \r\n    \r\n    sc.doc.Views.Redraw()", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "point", "brep", "curve", "functions", "RhinoCommon"], "original_file": "danimateos_rhino-python_74e79b1df1.json", "repo": "danimateos/rhino-python"}
{"instruction": "Implement the function 'help' for Rhino scripting", "code": "from flask import Flask\nimport ghhops_server as hs\nfrom ghhops_server.params import HopsCurve, HopsInteger, HopsNumber\nimport rhino3dm as rh\n\nfrom owlready2 import *\n\n# register hops app as middleware\napp = Flask(__name__)\nhops: hs.HopsFlask = hs.Hops(app)\n\n# flask app can be used for other stuff drectly\n@app.route(\"/help\")\ndef help():\n    return \"Welcome to Grashopper Hops for CPython!\"\n\n#-- Point At component --#\n@hops.component(\n    \"/pointat\",\n    name=\"PointAt\",\n    description=\"Get a point along a curve\",\n    inputs=[\n        hs.HopsCurve(\"Curve\", \"C\", \"Curve to evaluate\"),\n        hs.HopsNumber(\"t\", \"t\", \"Parameter on Curve to evaluate.\")\n    ],\n    outputs=[\n        hs.HopsPoint(\"P\", \"P\", \"Point on Curve at parameter t\")\n    ]\n)\ndef pointat(curve: rh.Curve, t: float=0):\n    pt = curve.PointAt(t)\n    return pt\n\n\n#-- Profile Levels component --#\n@hops.component(\n    \"/plevels\",\n    name=\"ProfileLevels\",\n    description=\"Creates a series of levels from a profile\",\n    inputs=[\n        hs.HopsCurve(\"Curve\", \"C\", \"Curve to replicate\"),\n        hs.HopsNumber(\"Dist\", \"D\", \"Distance between levels\"),\n        hs.HopsInteger(\"Num\", \"N\", \"Number of levels\")\n    ],\n    outputs=[hs.HopsCurve(\"Curves\", \"Cs\", \"Series of profile curves\")]\n)\ndef plevels(curve: rh.Curve, d: float=1.0, n: int=1):\n    crvs = []\n    dists = [d*i for i in range(n+1)]\n\n    for dist in dists:\n        vec = rh.Vector3d(0, 0, dist)\n        trans = rh.Transform.Translation(vec)\n        temp = curve.Duplicate()\n        temp.Transform(trans)\n        crvs.append(temp)\n\n    return crvs\n\n\n#-- OWLREADY2 Demo --#\n@hops.component(\n    \"/owldemo\",\n    name=\"OwlDemo\",\n    description=\"Demo using Owlready2\",\n    inputs=[hs.HopsString(\"Url\", \"U\", \"Url to ontology\")],\n    outputs=[\n        hs.HopsString(\"Classes\", \"Cls\", \"Classes in the ontology\"),\n        hs.HopsString(\"Properties\", \"Prop\", \"Properties in the ontology\"),\n        hs.HopsString(\"Individuals\", \"Ind\", \"Individuals in the ontology\")\n    ]\n)\ndef owlDemo(owlurl: str):\n    \n    onto = get_ontology(owlurl).load()\n    owl_class = set(onto.classes())\n    owl_prop = set(onto.properties())\n    owl_ind = set(onto.individuals())\n\n    ls_class = [str(c) for c in owl_class]\n    ls_prop = [str(p) for p in owl_prop]\n    ls_ind = [str(i) for i in owl_ind]\n\n    return (ls_class, ls_prop, ls_ind)\n\n\nif __name__ == '__main__':\n    # set debug=True\n    app.run(debug=True)", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["curve", "functions", "point"], "original_file": "deKlerk_Hops_938ace9e4d.json", "repo": "deKlerk/Hops"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "import rhinoscriptsyntax as rs\n\nboardThickness = 1.6\n\nclass PathXY:\n\n    def __init__(self):\n        self.firstPoint = None\n        self.currentPoint = None\n        self.curves = []\n        self.z = 0\n\n    def BeginPath(self):\n        self.firstPoint = None\n        self.currentPoint = None\n        self.curves = []\n\n    def MoveTo(self, a, b):\n        self.currentPoint = (a, b, self.z)\n        if self.firstPoint is None:\n            self.firstPoint = self.currentPoint\n\n    def LineTo(self, a, b):\n        p = (a, b, self.z)\n        if p == self.currentPoint:\n            return\n        self.curves.append(rs.AddLine(self.currentPoint, p))\n        self.currentPoint = p\n\n    def ArcTo(self, a, b, xm, ym):\n        p = (a, b, self.z)\n        if p == self.currentPoint:\n            return\n        self.curves.append(rs.AddArc3Pt(self.currentPoint, p, (xm, ym, self.z)))\n        self.currentPoint = p\n\n    def Fillet(self, radius):\n        curve0 = self.curves.pop()\n        curve1 = self.curves.pop()\n        curve = rs.AddFilletCurve(curve0, curve1, radius, self.currentPoint, self.currentPoint)\n        rs.DeleteObject(curve0)\n        rs.DeleteObject(curve1)\n        self.curves.append(curve)\n\n    def ClosePath(self):\n        if self.currentPoint != self.firstPoint:\n            self.curves.append(rs.AddLine(self.currentPoint, self.firstPoint))\n\n    def Join(self):\n        if len(self.curves) > 1:\n            self.curves = rs.JoinCurves(self.curves, True)\n\ndef CreateRoundedRectangle(x0, y0, x1, y1, z0, r=0.5):\n    if r == 0.0:\n        path = PathXY()\n        path.z = z0\n        path.MoveTo(x0, y0)\n        path.LineTo(x0, y1)\n        path.LineTo(x1, y1)\n        path.LineTo(x1, y0)\n        path.ClosePath()\n        path.Join()\n        return path.curves[0]\n\n    xa = x0 + r\n    xz = x1 - r\n    ya = y0 + r\n    yz = y1 - r\n    path = PathXY()\n    path.z = z0\n    path.MoveTo(x0, ya)\n    path.LineTo(x0, yz)\n    path.LineTo(x0, y1)\n    path.LineTo(xa, y1)\n    path.Fillet(r)\n    path.LineTo(xz, y1)\n    path.LineTo(x1, y1)\n    path.LineTo(x1, yz)\n    path.Fillet(r)\n    path.LineTo(x1, ya)\n    path.LineTo(x1, y0)\n    path.LineTo(xz, y0)\n    path.Fillet(r)\n    path.LineTo(xa, y0)\n    path.LineTo(x0, y0)\n    path.LineTo(x0, ya)\n    path.Fillet(r)\n    path.Join()\n    return path.curves[0]\n\ndef PlaceInstance(file, x, y, mirror, rotate):\n    rs.Command(\"_-Insert _File=_Yes /Users/denis/sandbox/denisbohm/firefly-ice-mechanical/scripts/packages/\" + file + \".3dm B 0,0,0 1 0 _Enter\")\n    objects = rs.SelectedObjects()\n    if not len(objects):\n        return None\n    object = objects[0]\n    rs.UnselectAllObjects()\n    rs.RotateObject(object, (0, 0, 0), rotate)\n    if mirror:\n        rs.RotateObject(object, (0, 0, 0), 180, (0, 1, 0))\n        rs.MoveObject(object, (0, 0, -boardThickness))\n    rs.MoveObject(object, (x, y, 0))\n    return object\n\ndef ColorAndMove(object, layer):\n    index = rs.AddMaterialToObject(object)\n    if layer == 1:\n        rs.MaterialColor(index, (255, 0, 0))\n    if layer == 16:\n        rs.MaterialColor(index, (0, 0, 255))\n        rs.MoveObject(object, (0, 0, -boardThickness - 0.1))\n\ndef PlaceCircle(x, y, radius, layer):\n    if (layer != 1) and (layer != 16):\n        return None\n    object = rs.AddCylinder((x, y, 0), 0.1, radius)\n    ColorAndMove(object, layer)\n    return object\n\ndef PlaceSmd(x, y, w, h, r, layer):\n    f = min(w, h) * r * 0.5\n    curve = CreateRoundedRectangle(x - w / 2.0, y - h / 2.0, x + w / 2.0, y + h / 2.0, 0.0, f)\n    extrusion = rs.ExtrudeCurveStraight(curve, (0, 0, 0), (0, 0, 0.1))\n    top = rs.AddPlanarSrf([curve])\n    bot = rs.CopyObject(top, (0, 0, 0.1))\n    object = rs.JoinSurfaces([top, extrusion, bot], True)\n    rs.DeleteObjects([curve])\n    ColorAndMove(object, layer)\n    return object\n\ndef PlacePad(x, y, w, h, r, layer):\n    f = min(w, h) * r * 0.5\n    curve = CreateRoundedRectangle(x - w / 2.0, y - h / 2.0, x + w / 2.0, y + h / 2.0, 0.0, f)\n    extrusion = rs.ExtrudeCurveStraight(curve, (0, 0, 0), (0, 0, 0.1))\n    top = rs.AddPlanarSrf([curve])\n    bot = rs.CopyObject(top, (0, 0, 0.1))\n    object = rs.JoinSurfaces([top, extrusion, bot], True)\n    rs.DeleteObjects([curve])\n    ColorAndMove(object, layer)\n    return object\n\ndef PlaceRing(x, y, r0, r1, layer):\n    if (layer != 1) and (layer != 16):\n        return None\n    c0 = rs.AddCircle((x, y, 0), r0)\n    c1 = rs.AddCircle((x, y, 0), r1)\n    e0 = rs.ExtrudeCurveStraight(c0, (0, 0, 0), (0, 0, 0.1))\n    e1 = rs.ExtrudeCurveStraight(c1, (0, 0, 0), (0, 0, 0.1))\n    curves = [c0, c1]\n    top = rs.AddPlanarSrf(curves)\n    bot = rs.CopyObject(top, (0, 0, 0.1))\n    object = rs.JoinSurfaces([top, e0, e1, bot], True)\n    rs.DeleteObjects(curves)\n    ColorAndMove(object, layer)\n    return object\n\ndef PlacePolygon(points, layer):\n    if (layer != 1) and (layer != 16):\n        return None\n    path = PathXY()\n    first = True\n    for point in points:\n        if first:\n            first = False\n            path.MoveTo(point[0], point[1])\n            if len(point) >= 9:\n                path.ArcTo(point[3], point[4], point[6], point[7])\n        else:\n            if len(point) >= 9:\n                path.LineTo(point[0], point[1])\n                path.ArcTo(point[3], point[4], point[6], point[7])\n            else:\n                path.LineTo(point[0], point[1])\n    path.ClosePath()\n    path.Join()\n    curve = path.curves[0]\n#    curve = rs.AddPolyline(points)\n    extrusion = rs.ExtrudeCurveStraight(curve, (0, 0, 0), (0, 0, 0.1))\n    top = rs.AddPlanarSrf([curve])\n    bot = rs.CopyObject(top, (0, 0, 0.1))\n    object = rs.JoinSurfaces([top, extrusion, bot], True)\n    rs.DeleteObject(curve)\n    ColorAndMove(object, layer)\n    return object\n\ndef PlacePCB(curves):\n    curves = rs.JoinCurves(curves, True)\n    surface = rs.AddPlanarSrf(curves)\n    other = rs.CopyObject(surface, (0, 0, -boardThickness))\n    surfaces = [surface, other]\n    for curve in curves:\n        surfaces.append(rs.ExtrudeCurveStraight(curve, (0, 0, 0), (0, 0, -boardThickness)))\n    rs.DeleteObjects(curves)\n    surface = rs.JoinSurfaces(surfaces, True)\n    index = rs.AddMaterialToObject(surface)\n    rs.MaterialColor(index, (20, 150, 20))\n    return surface\n\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "classes", "point", "layer", "line", "curve", "functions"], "original_file": "denisbohm_firefly-ice-mechanical_3551e404fb.json", "repo": "denisbohm/firefly-ice-mechanical"}
{"instruction": "Implement the function 'capture_viewport' for Rhino scripting", "code": "import os, sys, threading, tempfile\nimport os.path as op\n\n# -------------------------------------------\n# make sure to change the cache path\n# -------------------------------------------\ncache_path = \"Z:\\\\Development Projects\\\\huggingface\"\nos.environ[\"TRANSFORMERS_CACHE\"] = cache_path\nos.environ[\"HF_HUB_CACHE\"] = cache_path\nos.environ[\"HUGGINGFACE_HUB_CACHE\"] = cache_path \nos.environ[\"HF_HOME\"] = cache_path\n\nimport rhinoscriptsyntax as rs\nimport Rhino\nimport scriptcontext as sc\nimport Eto.Forms as forms\nimport Eto.Drawing as drawing\nfrom System.Drawing import Bitmap, Imaging\nfrom PIL import Image, ImageOps\nimport shutil  # For file copying\n\n# -------------------------------------------\n# make sure to change the env environment path\n# -------------------------------------------\n\n# Configure environment\nCONDA_ENV = r'C:\\Users\\Hesham.Shawqy\\anaconda3\\envs\\generative_ai'\nsys.path.append(op.join(CONDA_ENV, r\"Lib\\site-packages\"))\nos.add_dll_directory(op.join(CONDA_ENV, r'Library\\bin'))\n\nfrom image_generation.image_generation import generate_from_rhino_view, initialize_models, is_loading_complete\n\n# Track temporary files\ntemp_files = []\n\n# viewport to bitmap to pil image\ndef capture_viewport():\n    view = sc.doc.Views.ActiveView\n    bitmap = view.CaptureToBitmap()\n    \n    with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as temp_file:\n        temp_path = temp_file.name\n        temp_files.append(temp_path)\n    \n    bitmap.Save(temp_path, Imaging.ImageFormat.Png)\n    pil_image = Image.open(temp_path)\n    \n    return pil_image\n\n# pil to bitmap to eto\ndef pil_to_eto_image(pil_image):\n    with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as temp_file:\n        temp_path = temp_file.name\n        temp_files.append(temp_path)\n    \n    pil_image.save(temp_path, format='PNG')\n    bitmap = Bitmap(temp_path)\n    \n    with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as eto_temp_file:\n        eto_temp_path = eto_temp_file.name\n        temp_files.append(eto_temp_path)\n    \n    bitmap.Save(eto_temp_path, Imaging.ImageFormat.Png)\n    eto_bitmap = drawing.Bitmap(eto_temp_path)\n\n    return eto_bitmap\n\n# Clean up temporary files\ndef cleanup_temp_files():\n    global temp_files\n    for file_path in temp_files:\n        try:\n            if os.path.exists(file_path):\n                os.unlink(file_path)\n        except Exception as e:\n            print(f\"Error cleaning up temporary file {file_path}: {str(e)}\")\n    temp_files = []\n\n# creating the UI components\ndef create_ui_controls():\n    # Create image view\n    image_view = forms.ImageView()\n    image_view.BackgroundColor = drawing.Color.FromArgb(255, 255, 255)\n    \n    # Create buttons\n    ai_button = forms.Button()\n    ai_button.Text = \"Generate AI Image\"\n    ai_button.Enabled = is_loading_complete()\n    \n    save_button = forms.Button()\n    save_button.Text = \"Save Image\"\n    save_button.Enabled = False\n    \n    # Create status label\n    status_label = forms.Label()\n    if not is_loading_complete():\n        status_label.Text = \"Loading AI models...this might take a few minutes\"\n        status_label.TextColor = drawing.Color.FromArgb(200, 0, 0)\n    else:\n        status_label.Text = \"AI models loaded and ready\"\n        status_label.TextColor = drawing.Color.FromArgb(0, 128, 0)\n    \n    # Create prompt controls\n    prompt_text = forms.TextArea()\n    prompt_text.Text = \"a stunning architectural visualization of the design, photorealistic render, 4k, high resolution\"\n    prompt_text.Height = 60\n    \n    # Create negative prompt controls\n    negative_prompt_text = forms.TextArea()\n    negative_prompt_text.Text = \"ugly, low quality\"\n    negative_prompt_text.Height = 40\n    \n    # Create text inputs for parameters\n    steps_input = forms.TextBox()\n    steps_input.Text = \"8\"\n    \n    guidance_input = forms.TextBox()\n    guidance_input.Text = \"5.0\"\n    \n    control_strength_input = forms.TextBox()\n    control_strength_input.Text = \"0.5\"\n    \n    # Create seed control\n    seed_numeric = forms.NumericUpDown()\n    seed_numeric.MinValue = 0\n    seed_numeric.MaxValue = 2147483647\n    seed_numeric.Value = 0\n    seed_numeric.DecimalPlaces = 0\n    \n    return (image_view, ai_button, save_button, status_label, prompt_text, \n            negative_prompt_text, steps_input, guidance_input, \n            control_strength_input, seed_numeric)\n\n\ndef show_image_dialog():\n    initialize_models()\n    \n    # Create form\n    form = forms.Form()\n    form.Title = \"Rhino AI Image Generator\"\n    form.ClientSize = drawing.Size(600, 700)\n    form.Padding = drawing.Padding(10)\n    form.Topmost = True\n    \n    # Get UI controls\n    (image_view, ai_button, save_button, status_label, prompt_text,\n     negative_prompt_text, steps_input, guidance_input,\n     control_strength_input, seed_numeric) = create_ui_controls()\n    \n    # Create the main layout\n    layout = forms.DynamicLayout()\n    layout.Padding = drawing.Padding(10)\n    layout.Spacing = drawing.Size(5, 5)\n    \n    layout.Add(image_view, yscale=True)\n    \n    # Prompt section\n    prompt_label = forms.Label()\n    prompt_label.Text = \"Text Prompt\"\n    layout.Add(prompt_label)\n    layout.Add(prompt_text)\n    \n    # Negative prompt section\n    negative_prompt_label = forms.Label()\n    negative_prompt_label.Text = \"Negative Prompt\"\n    layout.Add(negative_prompt_label)\n    layout.Add(negative_prompt_text)\n    \n    # Parameter inputs section\n    params_layout = forms.TableLayout()\n    params_layout.Spacing = drawing.Size(5, 5)\n    \n    # Inference steps row\n    steps_label = forms.Label()\n    steps_label.Text = \"Inference Steps (4-12)\"\n    steps_cell = forms.TableCell()\n    steps_cell.Control = steps_label\n    steps_cell.ScaleWidth = True\n    \n    steps_input_cell = forms.TableCell()\n    steps_input_cell.Control = steps_input\n    steps_input_cell.ScaleWidth = False\n    \n    steps_row = forms.TableRow()\n    steps_row.Cells.Add(steps_cell)\n    steps_row.Cells.Add(steps_input_cell)\n    params_layout.Rows.Add(steps_row)\n    \n    # Guidance scale row\n    guidance_label = forms.Label()\n    guidance_label.Text = \"Guidance Scale (0.0-10.0)\"\n    guidance_cell = forms.TableCell()\n    guidance_cell.Control = guidance_label\n    guidance_cell.ScaleWidth = True\n    \n    guidance_input_cell = forms.TableCell()\n    guidance_input_cell.Control = guidance_input\n    guidance_input_cell.ScaleWidth = False\n    \n    guidance_row = forms.TableRow()\n    guidance_row.Cells.Add(guidance_cell)\n    guidance_row.Cells.Add(guidance_input_cell)\n    params_layout.Rows.Add(guidance_row)\n    \n    # Control strength row\n    control_label = forms.Label()\n    control_label.Text = \"Control Strength (0.0-1.0)\"\n    control_cell = forms.TableCell()\n    control_cell.Control = control_label\n    control_cell.ScaleWidth = True\n    \n    control_input_cell = forms.TableCell()\n    control_input_cell.Control = control_strength_input\n    control_input_cell.ScaleWidth = False\n    \n    control_row = forms.TableRow()\n    control_row.Cells.Add(control_cell)\n    control_row.Cells.Add(control_input_cell)\n    params_layout.Rows.Add(control_row)\n    \n    # Seed row\n    seed_label = forms.Label()\n    seed_label.Text = \"Seed (0 = random)\"\n    seed_cell = forms.TableCell()\n    seed_cell.Control = seed_label\n    seed_cell.ScaleWidth = True\n    \n    seed_input_cell = forms.TableCell()\n    seed_input_cell.Control = seed_numeric\n    seed_input_cell.ScaleWidth = False\n    \n    seed_row = forms.TableRow()\n    seed_row.Cells.Add(seed_cell)\n    seed_row.Cells.Add(seed_input_cell)\n    params_layout.Rows.Add(seed_row)\n    \n    layout.Add(params_layout)\n    layout.Add(status_label)\n    \n    # Create button layout\n    button_layout = forms.TableLayout()\n    button_layout.Spacing = drawing.Size(5, 0)\n    \n    empty_cell = forms.TableCell()\n    empty_cell.ScaleWidth = True\n    \n    ai_button_cell = forms.TableCell()\n    ai_button_cell.Control = ai_button\n    ai_button_cell.ScaleWidth = False\n    \n    save_button_cell = forms.TableCell()\n    save_button_cell.Control = save_button\n    save_button_cell.ScaleWidth = False\n    \n    button_row = forms.TableRow()\n    button_row.Cells.Add(empty_cell)\n    button_row.Cells.Add(ai_button_cell)\n    button_row.Cells.Add(save_button_cell)\n    \n    button_layout.Rows.Add(button_row)\n    layout.Add(button_layout)\n    \n    form.Content = layout\n    \n    # Store generated image and temp file path\n    generated_image = None\n    temp_image_path = None\n    \n    # Setup loading timer\n    check_loading_timer = forms.UITimer()\n    check_loading_timer.Interval = 1.0\n    \n    # Timer event handler\n    def update_loading_status(sender, e):\n        if is_loading_complete():\n            status_label.Text = \"AI models loaded and ready\"\n            status_label.TextColor = drawing.Color.FromArgb(0, 128, 0)\n            ai_button.Enabled = True\n            check_loading_timer.Stop()\n    \n    check_loading_timer.Elapsed += update_loading_status\n    check_loading_timer.Start()\n    \n    def on_ai_button_click(sender, e):\n        try:\n            if not is_loading_complete():\n                print(\"AI models are still loading. Please wait...\")\n                return\n            \n            # Validate inputs\n            try:\n                steps = int(steps_input.Text)\n                if not (4 <= steps <= 12):\n                    raise ValueError(\"Inference steps must be between 4 and 12\")\n                \n                guidance = float(guidance_input.Text)\n                if not (0.0 <= guidance <= 10.0):\n                    raise ValueError(\"Guidance scale must be between 0.0 and 10.0\")\n                \n                control = float(control_strength_input.Text)\n                if not (0.0 <= control <= 1.0):\n                    raise ValueError(\"Control strength must be between 0.0 and 1.0\")\n                \n                seed = int(seed_numeric.Value) if seed_numeric.Value > 0 else None\n            except ValueError as ve:\n                status_label.Text = f\"Error: {str(ve)}\"\n                return\n            \n            captured_image = capture_viewport()\n            prompt = prompt_text.Text\n            negative_prompt = negative_prompt_text.Text\n            \n            status_label.Text = \"Generating AI image...\"\n            ai_button.Enabled = False\n            save_button.Enabled = False\n            \n            def generate_in_background():\n                nonlocal generated_image, temp_image_path\n                try:\n                    ai_image = generate_from_rhino_view(\n                        captured_image, \n                        prompt=prompt,\n                        negative_prompt=negative_prompt,\n                        num_inference_steps=steps,\n                        guidance_scale=guidance,\n                        control_strength=control,\n                        seed=seed\n                    )\n                    \n                    generated_image = ai_image\n                    \n                    # Save to temporary file right away\n                    with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as temp_file:\n                        temp_image_path = temp_file.name\n                        temp_files.append(temp_image_path)\n                    \n                    ai_image.save(temp_image_path, format='PNG')\n                    \n                    def update_ui():\n                        if image_view.Image is not None:\n                            image_view.Image = None\n                        \n                        image_view.Image = pil_to_eto_image(ai_image)\n                        \n                        ai_button.Enabled = True\n                        save_button.Enabled = True\n                        status_label.Text = \"AI models loaded and ready\"\n                        \n                        print(\"AI image generated and displayed\")\n                    \n                    forms.Application.Instance.Invoke(update_ui)\n                    \n                except Exception as ex:\n                    def show_error():\n                        print(f\"Error generating AI image: {str(ex)}\")\n                        status_label.Text = f\"Error: {str(ex)}\"\n                        ai_button.Enabled = True\n                    \n                    forms.Application.Instance.Invoke(show_error)\n            \n            threading.Thread(target=generate_in_background).start()\n            \n        except Exception as e:\n            print(f\"Error generating AI image: {str(e)}\")\n            status_label.Text = f\"Error: {str(e)}\"\n            ai_button.Enabled = True\n    \n    def on_save_button_click(sender, e):\n        nonlocal temp_image_path\n        if temp_image_path is None or not os.path.exists(temp_image_path):\n            status_label.Text = \"No image to save\"\n            return\n        \n        # Disable the save button during the operation\n        save_button.Enabled = False\n        status_label.Text = \"Preparing to save...\"\n        \n        # Use a fixed path in the user's documents folder instead of a dialog\n        try:\n            # Get user documents folder\n            documents_folder = os.path.expanduser(\"~/Documents\")\n            rhino_ai_folder = os.path.join(documents_folder, \"RhinoAI\")\n            \n            # Create the folder if it doesn't exist\n            if not os.path.exists(rhino_ai_folder):\n                os.makedirs(rhino_ai_folder)\n            \n            # Create a filename with timestamp\n            import datetime\n            timestamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            file_name = f\"rhino_ai_{timestamp}.png\"\n            file_path = os.path.join(rhino_ai_folder, file_name)\n            \n            # Copy the file\n            shutil.copy2(temp_image_path, file_path)\n            \n            status_label.Text = f\"Image saved to {file_path}\"\n            print(f\"Image saved to {file_path}\")\n        except Exception as ex:\n            status_label.Text = f\"Error saving image: {str(ex)}\"\n            print(f\"Error saving image: {str(ex)}\")\n        finally:\n            save_button.Enabled = True\n    \n    def on_form_closing(sender, e):\n        if image_view.Image is not None:\n            image_view.Image = None\n        check_loading_timer.Stop()\n        cleanup_temp_files()\n    \n    # Connect events\n    ai_button.Click += on_ai_button_click\n    save_button.Click += on_save_button_click\n    form.Closing += on_form_closing\n    \n    form.Show()\n    \n    return form\n\nif __name__ == \"__main__\":\n    show_image_dialog()", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "functions"], "original_file": "design-technology_S2F-AI-ScriptEditor_1ce045060d.json", "repo": "design-technology/S2F-AI-ScriptEditor"}
{"instruction": "Implement the function 'capture_viewport' for Rhino scripting", "code": "import os, sys, threading, tempfile\nimport os.path as op\n# -------------------------------------------\n# make sure to change the cache path\n# -------------------------------------------\ncache_path = \"Z:\\\\Development Projects\\\\huggingface\"\nos.environ[\"TRANSFORMERS_CACHE\"] = cache_path\nos.environ[\"HF_HUB_CACHE\"] = cache_path\nos.environ[\"HUGGINGFACE_HUB_CACHE\"] = cache_path \nos.environ[\"HF_HOME\"] = cache_path\n\nimport rhinoscriptsyntax as rs\nimport Rhino\nimport scriptcontext as sc\nimport Eto.Forms as forms\nimport Eto.Drawing as drawing\nfrom System.Drawing import Bitmap, Imaging\nfrom PIL import Image, ImageOps\n\n# -------------------------------------------\n# make sure to change the env environment path\n# -------------------------------------------\n\n# Configure environment\nCONDA_ENV = r'C:\\Users\\Hesham.Shawqy\\anaconda3\\envs\\generative_ai'\nsys.path.append(op.join(CONDA_ENV, r\"Lib\\site-packages\"))\nos.add_dll_directory(op.join(CONDA_ENV, r'Library\\bin'))\n\nfrom image_generation.image_generation import generate_from_rhino_view, initialize_models, is_loading_complete\n# viewport to bitmap to pil image\ndef capture_viewport():\n    view = sc.doc.Views.ActiveView\n    bitmap = view.CaptureToBitmap()\n    \n    with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as temp_file:\n        temp_path = temp_file.name\n    \n    bitmap.Save(temp_path, Imaging.ImageFormat.Png)\n    pil_image = Image.open(temp_path)\n    \n    return pil_image\n\n# pil to bitmap to eto\ndef pil_to_eto_image(pil_image):\n    with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as temp_file:\n        temp_path = temp_file.name\n    \n    pil_image.save(temp_path, format='PNG')\n    bitmap = Bitmap(temp_path)\n    \n    with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as eto_temp_file:\n        eto_temp_path = eto_temp_file.name\n    \n    bitmap.Save(eto_temp_path, Imaging.ImageFormat.Png)\n    eto_bitmap = drawing.Bitmap(eto_temp_path)\n\n    return eto_bitmap\n\n# Initialize sticky dictionary for form reference\n# if 'negative_viewport_form' not in sc.sticky:\n#     sc.sticky['negative_viewport_form'] = None\n\n# creating the UI components\ndef create_ui_controls():\n    # Create image view\n    image_view = forms.ImageView()\n    image_view.BackgroundColor = drawing.Color.FromArgb(255, 255, 255)\n    \n    \n    ai_button = forms.Button()\n    ai_button.Text = \"Generate AI Image\"\n    # only active when the model is loaded\n    ai_button.Enabled = is_loading_complete()\n    \n    # Create status label\n    status_label = forms.Label()\n    if not is_loading_complete():\n        status_label.Text = \"Loading AI models...this might take a few minutes\"\n        status_label.TextColor = drawing.Color.FromArgb(200, 0, 0)\n    else:\n        status_label.Text = \"AI models loaded and ready\"\n        status_label.TextColor = drawing.Color.FromArgb(0, 128, 0)\n    \n    # Create prompt controls\n    prompt_label = forms.Label()\n    prompt_label.Text = \"Text Prompt\"\n    \n    prompt_text = forms.TextArea()\n    prompt_text.Text = \"a stunning architectural visualization of the design, photorealistic render, 4k, high resolution\"\n    prompt_text.Height = 60\n    \n    return image_view, ai_button, status_label, prompt_label, prompt_text\n\n\ndef show_image_dialog():\n    \n    initialize_models()\n    \n    # Create form\n    form = forms.Form()\n    form.Title = \"Rhino AI Image Generator\"\n    form.ClientSize = drawing.Size(600, 600)\n    form.Padding = drawing.Padding(10)\n    # bring the form forward above other applications\n    form.Topmost = True\n    \n    # Get UI controls\n    image_view, ai_button, status_label, prompt_label, prompt_text = create_ui_controls()\n    \n    # Create the main layout\n    layout = forms.DynamicLayout()\n    layout.Padding = drawing.Padding(10)\n    layout.Spacing = drawing.Size(5, 5)\n    \n    layout.Add(image_view, yscale=True)\n    layout.Add(prompt_label)\n    layout.Add(prompt_text)\n    layout.Add(status_label)\n    \n    # Create button layout\n    button_layout = forms.DynamicLayout()\n    button_layout.Spacing = drawing.Size(5, 0)\n    button_layout.AddRow(None, ai_button)\n    \n    layout.Add(button_layout)\n    form.Content = layout\n    \n    # Store image capture\n    captured_image = None\n    \n    # Setup loading timer\n    check_loading_timer = forms.UITimer()\n    check_loading_timer.Interval = 1.0\n    \n    #timer event handler\n    def update_loading_status(sender, e):\n        if is_loading_complete():\n            status_label.Text = \"AI models loaded and ready\"\n            status_label.TextColor = drawing.Color.FromArgb(0, 128, 0)\n            ai_button.Enabled = True\n            check_loading_timer.Stop()\n    \n    check_loading_timer.Elapsed += update_loading_status\n    check_loading_timer.Start()\n    \n    \n    def on_ai_button_click(sender, e):\n        try:\n            if not is_loading_complete():\n                print(\"AI models are still loading. Please wait...\")\n                return\n            \n            nonlocal captured_image\n            captured_image = capture_viewport()\n            \n            prompt = prompt_text.Text\n            status_label.Text = \"Generating AI image...\"\n            ai_button.Enabled = False\n            \n            def generate_in_background():\n                try:\n                    ai_image = generate_from_rhino_view(captured_image, prompt=prompt)\n                    \n                    def update_ui():\n                        nonlocal ai_image\n                        if image_view.Image is not None:\n                            image_view.Image = None\n                        \n                        image_view.Image = pil_to_eto_image(ai_image)\n                        \n                        ai_button.Enabled = True\n                        status_label.Text = \"AI models loaded and ready\"\n                        \n                        print(\"AI image generated and displayed\")\n                    \n                    forms.Application.Instance.Invoke(update_ui)\n                    \n                except Exception as ex:\n                    def show_error():\n                        nonlocal ex\n                        print(f\"Error generating AI image: {str(ex)}\")\n                        status_label.Text = f\"Error: {str(ex)}\"\n                        ai_button.Enabled = True\n                    \n                    forms.Application.Instance.Invoke(show_error)\n            \n            threading.Thread(target=generate_in_background).start()\n            \n        except Exception as e:\n            print(f\"Error generating AI image: {str(e)}\")\n            status_label.Text = f\"Error: {str(e)}\"\n            ai_button.Enabled = True\n    \n    def on_form_closing(sender, e):\n        if image_view.Image is not None:\n            image_view.Image = None\n        check_loading_timer.Stop()\n    \n    # Connect events\n    ai_button.Click += on_ai_button_click\n    form.Closing += on_form_closing\n    \n    form.Show()\n    \n    return form\n\nif __name__ == \"__main__\":\n    show_image_dialog()", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "functions"], "original_file": "design-technology_S2F-AI-ScriptEditor_ddc2f318eb.json", "repo": "design-technology/S2F-AI-ScriptEditor"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\n\nimport Rhino\nfrom ghpythonlib.componentbase import executingcomponent as component\n\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\n\nfrom diffCheck import diffcheck_bindings\nfrom diffCheck import df_cvt_bindings\n\n\nclass DFFastGlobalRegistration(component):\n    def RunScript(self,\n            i_cloud_source: Rhino.Geometry.PointCloud,\n            i_cloud_target: Rhino.Geometry.PointCloud,\n            i_radius_kd_search: float,\n            i_neighbours_kd_search: int,\n            i_max_corrspondence_dist: float,\n            i_iteration_number: int,\n            i_max_tuple_count: int) -> Rhino.Geometry.Transform:\n        if i_cloud_source is None or i_cloud_target is None:\n            ghenv.Component.AddRuntimeMessage(RML.Warning, \"Please provide both objects of type point clouds to align\")  # noqa: F821\n            return None\n        if not i_cloud_source.ContainsNormals or not i_cloud_target.ContainsNormals:\n            ghenv.Component.AddRuntimeMessage(RML.Error, \"Please compute cloud's normals with a component before\")  # noqa: F821\n\n        # set default values\n        if i_radius_kd_search is None:\n            i_radius_kd_search = 0.8\n        if i_neighbours_kd_search is None:\n            i_neighbours_kd_search = 50\n        if i_max_corrspondence_dist is None:\n            i_max_corrspondence_dist = 0.05\n        if i_iteration_number is None:\n            i_iteration_number = 128\n        if i_max_tuple_count is None:\n            i_max_tuple_count = 1000\n\n        df_cloud_source = df_cvt_bindings.cvt_rhcloud_2_dfcloud(i_cloud_source)\n        df_cloud_target = df_cvt_bindings.cvt_rhcloud_2_dfcloud(i_cloud_target)\n\n        df_xform = diffcheck_bindings.dfb_registrations.DFGlobalRegistrations.O3DFastGlobalRegistrationFeatureMatching(\n            source=df_cloud_source,\n            target=df_cloud_target,\n            voxelize=False,  # set as default\n            voxel_size=0.1,  # set as default\n            radius_kd_tree_search=i_radius_kd_search,\n            max_neighbor_kd_tree_search=i_neighbours_kd_search,\n            max_correspondence_distance=i_max_corrspondence_dist,\n            iteration_number=i_iteration_number,\n            max_tuple_count=i_max_tuple_count\n        )\n        print(\"-------------------\")\n        print(\"Estimated transformation matrix:\")\n        print(df_xform.transformation_matrix)\n        print(\"-------------------\")\n\n        # cvt df xform to rhino xform\n        df_xform_matrix = df_xform.transformation_matrix\n        rh_form = Rhino.Geometry.Transform()\n        for i in range(4):\n            for j in range(4):\n                rh_form[i, j] = df_xform_matrix[i, j]\n        if rh_form == Rhino.Geometry.Transform.Identity:\n            ghenv.Component.AddRuntimeMessage(RML.Warning, \"The transformation matrix is identity, no transformation is applied\")  # noqa: F821\n            return None\n\n        o_x_form = rh_form\n\n        return o_x_form\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "classes", "functions", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_185d03de49.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\n\nimport Rhino\nfrom ghpythonlib.componentbase import executingcomponent as component\n\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\n\nfrom diffCheck import diffcheck_bindings\nfrom diffCheck import df_cvt_bindings\n\n\nclass DFRANSACGlobalRegistration(component):\n    def RunScript(self,\n        i_cloud_source: Rhino.Geometry.PointCloud,\n        i_cloud_target: Rhino.Geometry.PointCloud,\n        i_radius_kd_search: float,\n        i_neighbours_kd_search: int,\n        i_max_corrspondence_dist: float,\n        is_t_estimate_pt2pt: bool,\n        i_ransac_n: int,\n        i_checker_dist: float,\n        i_similarity_threshold: float,\n        i_max_iterations: int,\n        i_confidence_threshold: float\n    ) -> Rhino.Geometry.Transform:\n        if i_cloud_source is None or i_cloud_target is None:\n            ghenv.Component.AddRuntimeMessage(RML.Warning, \"Please provide both objects of type point clouds to align\")  # noqa: F821\n            return None\n        if not i_cloud_source.ContainsNormals or not i_cloud_target.ContainsNormals:\n            ghenv.Component.AddRuntimeMessage(RML.Error, \"Please compute cloud's normals with a component before\")  # noqa: F821\n\n        # set default values\n        if i_radius_kd_search is None:\n            i_radius_kd_search = 1\n        if i_neighbours_kd_search is None:\n            i_neighbours_kd_search = 50\n        if i_max_corrspondence_dist is None:\n            i_max_corrspondence_dist = 0.5\n        if is_t_estimate_pt2pt is None:\n            is_t_estimate_pt2pt = False\n        if i_ransac_n is None:\n            i_ransac_n = 3\n        if i_checker_dist is None:\n            i_checker_dist = 0.5\n        if i_similarity_threshold is None:\n            i_similarity_threshold = 1.5\n        if i_max_iterations is None:\n            i_max_iterations = 5000\n        if i_confidence_threshold is None:\n            i_confidence_threshold = 0.999\n\n        # conversion\n        df_cloud_source = df_cvt_bindings.cvt_rhcloud_2_dfcloud(i_cloud_source)\n        df_cloud_target = df_cvt_bindings.cvt_rhcloud_2_dfcloud(i_cloud_target)\n\n        # fast registration\n        df_xform = diffcheck_bindings.dfb_registrations.DFGlobalRegistrations.O3DRansacOnFeatureMatching(\n            source=df_cloud_source,\n            target=df_cloud_target,\n            voxelize=False,  # set as default\n            voxel_size=0.1,  # set as default\n            radius_kd_tree_search=i_radius_kd_search,\n            max_neighbor_kd_tree_search=i_neighbours_kd_search,\n            max_correspondence_distance=i_max_corrspondence_dist,\n            is_t_estimate_pt2pt=is_t_estimate_pt2pt,\n            ransac_n=i_ransac_n,\n            correspondence_checker_distance=i_checker_dist,\n            similarity_threshold=i_similarity_threshold,\n            ransac_max_iteration=i_max_iterations,\n            ransac_confidence_threshold=i_confidence_threshold\n        )\n        print(\"-------------------\")\n        print(\"Estimated transformation matrix:\")\n        print(df_xform.transformation_matrix)\n        print(\"-------------------\")\n\n        # cvt df xform to rhino xform\n        df_xform_matrix = df_xform.transformation_matrix\n        rh_form = Rhino.Geometry.Transform()\n        for i in range(4):\n            for j in range(4):\n                rh_form[i, j] = df_xform_matrix[i, j]\n        if rh_form == Rhino.Geometry.Transform.Identity:\n            ghenv.Component.AddRuntimeMessage(RML.Warning, \"The transformation matrix is identity, no transformation is applied\")  # noqa: F821\n            return None\n\n        o_x_form = rh_form\n\n        return o_x_form\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "classes", "functions", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_21b103628d.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Adds a button to the component input", "code": "#! python3\n\nimport System\n\nimport Rhino  # noqa: F401\nimport Rhino.Geometry as rg\nfrom ghpythonlib.componentbase import executingcomponent as component\n\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\nimport Grasshopper as gh\n\nfrom diffCheck import diffcheck_bindings\nfrom diffCheck import df_cvt_bindings\n\n\ndef add_button(self,\n    nickname: str,\n    indx: int,\n    X_param_coord: float,\n    Y_param_coord: float,\n    X_offset: int=45\n    ) -> None:\n    \"\"\"\n        Adds a button to the component input\n\n        :param nickname: the nickname of the button\n        :param indx: the index of the input parameter\n        :param X_param_coord: the x coordinate of the input parameter\n        :param Y_param_coord: the y coordinate of the input parameter\n        :param X_offset: the offset of the button from the input parameter\n    \"\"\"\n    param = ghenv.Component.Params.Input[indx]  # noqa: F821\n    if param.SourceCount == 0:\n        button = gh.Kernel.Special.GH_ButtonObject()\n        button.NickName = \"\"\n        button.Description = \"\"\n        button.CreateAttributes()\n        button.Attributes.Pivot = System.Drawing.PointF(\n            X_param_coord - (button.Attributes.Bounds.Width) - X_offset,\n            Y_param_coord - (button.Attributes.Bounds.Height / 2 - 0.1)\n            )\n        button.Attributes.ExpireLayout()\n        gh.Instances.ActiveCanvas.Document.AddObject(button, False)\n        ghenv.Component.Params.Input[indx].AddSource(button)    # noqa: F821\n\nclass DFExportCloudToFile(component):\n    def __init__(self):\n        super(DFExportCloudToFile, self).__init__()\n        ghenv.Component.ExpireSolution(True)  # noqa: F821\n        ghenv.Component.Attributes.PerformLayout()    # noqa: F821\n        params = getattr(ghenv.Component.Params, \"Input\")    # noqa: F821\n        for j in range(len(params)):\n            X_cord = params[j].Attributes.Pivot.X\n            Y_cord = params[j].Attributes.InputGrip.Y\n            if params[j].Name == \"i_dump\":\n                add_button(self, \"\", j, X_cord, Y_cord)\n\n    def RunScript(self,\n        i_dump: bool,\n        i_file_path: str,\n        i_cloud: rg.PointCloud) -> None:\n        if i_dump is None or i_file_path is None or i_cloud is None:\n            return None\n\n        # check that the i_file_path is a valid path and it has the .ply extension\n        if not i_file_path.endswith(\".ply\"):\n            ghenv.Component.AddRuntimeMessage(RML.Warning, \"Attention: the format should be .ply\")  # noqa: F821\n            return None\n\n        if i_dump:\n            df_cloud: diffcheck_bindings.dfb_geometry.DFPointCloud = df_cvt_bindings.cvt_rhcloud_2_dfcloud(i_cloud)\n            df_cloud.save_to_PLY(i_file_path)\n\n        return None\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "classes", "functions", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_29e8a6ee53.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Adds a value list of string values to the component input", "code": "#! python3\n\nimport System\nimport typing\nimport Rhino\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper as gh\nfrom Grasshopper import Instances\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\n\nfrom diffCheck import df_visualization\n\n\ndef add_str_valuelist(self,\n    values_list: typing.List[str],\n    nickname: str,\n    indx: int,\n    X_param_coord: float,\n    Y_param_coord: float,\n    X_offset: int=87\n    ) -> None:\n    \"\"\"\n        Adds a value list of string values to the component input\n\n        :param values_list: a list of string values to add to the value list\n        :param nickname: the nickname of the value list\n        :param indx: the index of the input parameter\n        :param X_param_coord: the x coordinate of the input parameter\n        :param Y_param_coord: the y coordinate of the input parameter\n        :param X_offset: the offset of the value list from the input parameter\n    \"\"\"\n    param = ghenv.Component.Params.Input[indx]  # noqa: F821\n    if param.SourceCount == 0:\n        valuelist = gh.Kernel.Special.GH_ValueList()\n        valuelist.NickName = nickname\n        valuelist.Description = \"Select the value to use with DFVizSettings\"\n        selected = valuelist.FirstSelectedItem\n        valuelist.ListItems.Clear()\n        for v in values_list:\n            vli = gh.Kernel.Special.GH_ValueListItem(str(v),str('\"' + v + '\"'))\n            valuelist.ListItems.Add(vli)\n        if selected in values_list:\n            valuelist.SelectItem(values_list.index(selected))\n        valuelist.CreateAttributes()\n        valuelist.Attributes.Pivot = System.Drawing.PointF(\n            X_param_coord - (valuelist.Attributes.Bounds.Width) - X_offset,\n            Y_param_coord - (valuelist.Attributes.Bounds.Height / 2 + 0.1)\n            )\n        valuelist.Attributes.ExpireLayout()\n        gh.Instances.ActiveCanvas.Document.AddObject(valuelist, False)\n        ghenv.Component.Params.Input[indx].AddSource(valuelist)  # noqa: F821\n\ndef add_slider(self,\n    nickname: str,\n    indx: int,\n    lower_bound: float,\n    upper_bound: float,\n    default_value: float,\n    X_param_coord: float,\n    Y_param_coord: float,\n    X_offset: int=100\n    ) -> None:\n    \"\"\"\n        Adds a slider to the component input\n\n        :param nickname: the nickname of the slider\n        :param indx: the index of the input parameter\n        :param X_param_coord: the x coordinate of the input parameter\n        :param Y_param_coord: the y coordinate of the input parameter\n        :param X_offset: the offset of the slider from the input parameter\n    \"\"\"\n    param = ghenv.Component.Params.Input[indx]  # noqa: F821\n    if param.SourceCount == 0:\n        slider = gh.Kernel.Special.GH_NumberSlider()\n        slider.NickName = nickname\n        slider.Description = \"Set the value for the threshold\"\n        slider.Slider.Minimum = System.Decimal(lower_bound)\n        slider.Slider.Maximum = System.Decimal(upper_bound)\n        slider.Slider.DecimalPlaces = 3\n        slider.Slider.SmallChange = System.Decimal(0.001)\n        slider.Slider.LargeChange = System.Decimal(0.01)\n        slider.Slider.Value = System.Decimal(default_value)\n        slider.CreateAttributes()\n        slider.Attributes.Pivot = System.Drawing.PointF(\n            X_param_coord - (slider.Attributes.Bounds.Width) - X_offset,\n            Y_param_coord - (slider.Attributes.Bounds.Height / 2 - 0.1)\n            )\n        slider.Attributes.ExpireLayout()\n        gh.Instances.ActiveCanvas.Document.AddObject(slider, False)\n        ghenv.Component.Params.Input[indx].AddSource(slider)  # noqa: F821\n\ndef add_plane_object(self,\n    nickname: str,\n    indx: int,\n    X_param_coord: float,\n    Y_param_coord: float,\n    X_offset: int=75\n    ) -> None:\n    \"\"\"\n        Adds a plane object to the component input\n\n        :param nickname: the nickname of the plane object\n        :param indx: the index of the input parameter\n        :param X_param_coord: the x coordinate of the input parameter\n        :param Y_param_coord: the y coordinate of the input parameter\n        :param X_offset: the offset of the plane object from the input parameter\n    \"\"\"\n    param = ghenv.Component.Params.Input[indx]  # noqa: F821\n    if param.SourceCount == 0:\n        doc = Instances.ActiveCanvas.Document\n        if doc:\n            plane = gh.Kernel.Parameters.Param_Plane()\n            plane.NickName = nickname\n            plane.CreateAttributes()\n            plane.Attributes.Pivot = System.Drawing.PointF(\n                X_param_coord - (plane.Attributes.Bounds.Width) - X_offset,\n                Y_param_coord\n                )\n            plane.Attributes.ExpireLayout()\n            doc.AddObject(plane, False)\n            ghenv.Component.Params.Input[indx].AddSource(plane)  # noqa: F821\n\n\nclass DFVisualizationSettings(component):\n    def __init__(self):\n        self.poss_value_types = [\"Dist\", \"MEAN\", \"RMSE\", \"MAX\", \"MIN\", \"STD\"]\n        self.poss_palettes = [\"Jet\", \"Rainbow\", \"RdPu\", \"Viridis\"]\n\n        ghenv.Component.ExpireSolution(True)  # noqa: F821\n        ghenv.Component.Attributes.PerformLayout()  # noqa: F821\n        params = getattr(ghenv.Component.Params, \"Input\")  # noqa: F821\n        for j in range(len(params)):\n            Y_cord = params[j].Attributes.InputGrip.Y\n            X_cord = params[j].Attributes.Pivot.X\n            input_indx = j\n            if \"i_value_type\" == params[j].NickName:\n                add_str_valuelist(\n                    ghenv.Component,  # noqa: F821\n                    self.poss_value_types,\n                    \"DF_value_t\",\n                    input_indx, X_cord, Y_cord)\n            if \"i_palette\" == params[j].NickName:\n                add_str_valuelist(\n                    ghenv.Component,  # noqa: F821\n                    self.poss_palettes,\n                    \"DF_palette\",\n                    input_indx, X_cord, Y_cord)\n            if \"i_legend_height\" == params[j].NickName:\n                add_slider(\n                    ghenv.Component,  # noqa: F821\n                    \"DF_legend_height\",\n                    input_indx,\n                    0.000, 20.000, 10.000,\n                    X_cord, Y_cord)\n            if \"i_legend_width\" == params[j].NickName:\n                add_slider(\n                    ghenv.Component,  # noqa: F821\n                    \"DF_legend_width\",\n                    input_indx,\n                    0.000, 2.000, 0.500,\n                    X_cord, Y_cord)\n            if \"i_legend_plane\" == params[j].NickName:\n                add_plane_object(\n                    ghenv.Component,  # noqa: F821\n                    \"DF_legend_plane\",\n                    input_indx, X_cord, Y_cord)\n            if \"i_histogram_scale_factor\" == params[j].NickName:\n                add_slider(\n                    ghenv.Component,  # noqa: F821\n                    \"DF_histogram_scale_factor\",\n                    input_indx,\n                    0.000, 1.000, 0.01,\n                    X_cord, Y_cord)\n\n    def RunScript(self,\n        i_value_type: str,\n        i_palette: str,\n        i_upper_threshold: float,\n        i_lower_threshold: float,\n        i_legend_height: float,\n        i_legend_width: float,\n        i_legend_plane: Rhino.Geometry.Plane,\n        i_histogram_scale_factor: float,\n        i_one_histogram_per_item: bool):\n\n        \"\"\"\n        Compiles all the visualization settings to feed to the visualization component\n\n        :param i_value_type: selected type indicates Which values to display. Possible values: \"dist\", \"RMSE\", \"MAX\", \"MIN\", \"STD\"\n        :param i_palette: Select a color palette to map the values to. Possible values: \"Jet\", \"Rainbow\", \"RdPu\", \"Viridis\"\n        :param i_upper_threshold: Thresholds the values with a maximum value\n        :param i_lower_threshold: Thresholds the values with a minimum value\n        :param i_legend_height: the total height of the legend\n        :param i_legend_width: the total width of the legend\n        :param i_legend_plane: the construction plane of the legend\n        :param i_histogram_scale_factor: Scales the height of the histogram with a factor\n\n        :returns o_viz_settings: the results of the comparison all in one object\n        \"\"\"\n        # set default values\n        if i_value_type is not None:\n            if i_value_type not in self.poss_value_types:\n                ghenv.Component.AddRuntimeMessage(RML.Warning, \"Possible values for i_value_type are: dist, MEAN, RMSE, MAX, MIN, STD\")  # noqa: F821\n                return None\n        else:\n            i_value_type = \"Dist\"\n        if i_palette is not None:\n            if i_palette not in self.poss_palettes:\n                ghenv.Component.AddRuntimeMessage(RML.Warning, \"Possible values for i_palette are: Jet, Rainbow, RdPu, Viridis\")  # noqa: F821\n                return None\n        else:\n            i_palette = \"Jet\"\n        if i_legend_height is None:\n            i_legend_height = 10\n        if i_legend_width is None:\n            i_legend_width = 0.5\n        if i_legend_plane is None:\n            i_legend_plane = Rhino.Geometry.Plane.WorldXY\n        if i_histogram_scale_factor is None:\n            i_histogram_scale_factor = 0.01\n        if i_one_histogram_per_item is None:\n            i_one_histogram_per_item = False\n\n        # pack settings\n        o_viz_settings = df_visualization.DFVizSettings(i_value_type,\n                                                        i_palette,\n                                                        i_upper_threshold,\n                                                        i_lower_threshold,\n                                                        i_legend_height,\n                                                        i_legend_width,\n                                                        i_legend_plane,\n                                                        i_histogram_scale_factor,\n                                                        i_one_histogram_per_item)\n\n        return o_viz_settings\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "classes", "functions", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_4ae88dfb77.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\nimport System\n\nimport Rhino\nfrom ghpythonlib.componentbase import executingcomponent as component\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\n\n\nfrom diffCheck.diffcheck_bindings import dfb_segmentation\nfrom diffCheck.diffcheck_bindings import dfb_geometry\n\nfrom diffCheck import df_cvt_bindings\n\n\n\nclass DFCADSegmentator(component):\n    def RunScript(self,\n        i_clouds: System.Collections.Generic.IList[Rhino.Geometry.PointCloud],\n        i_assembly,\n        i_angle_threshold: float = 0.1,\n        i_association_threshold: float = 0.1) -> Rhino.Geometry.PointCloud:\n\n        if i_clouds is None or i_assembly is None:\n            self.AddRuntimeMessage(RML.Warning, \"Please provide a cloud and an assembly to segment.\")\n            return None\n        if i_angle_threshold is None:\n            i_angle_threshold = 0.1\n        if i_association_threshold is None:\n            i_association_threshold = 0.1\n\n        o_clusters = []\n        df_clusters = []\n        # we make a deepcopy of the input clouds\n        df_clouds = [df_cvt_bindings.cvt_rhcloud_2_dfcloud(cloud.Duplicate()) for cloud in i_clouds]\n\n        df_beams = i_assembly.beams\n        df_beams_meshes = []\n        rh_beams_meshes = []\n\n        for df_b in df_beams:\n            rh_b_mesh_faces = [df_b_f.to_mesh() for df_b_f in df_b.side_faces]\n            df_b_mesh_faces = [df_cvt_bindings.cvt_rhmesh_2_dfmesh(rh_b_mesh_face) for rh_b_mesh_face in rh_b_mesh_faces]\n            df_beams_meshes.append(df_b_mesh_faces)\n            rh_beams_meshes.append(rh_b_mesh_faces)\n\n            # different association depending on the type of beam\n            df_asssociated_cluster_faces = dfb_segmentation.DFSegmentation.associate_clusters(\n                is_roundwood=df_b.is_roundwood,\n                reference_mesh=df_b_mesh_faces,\n                unassociated_clusters=df_clouds,\n                angle_threshold=i_angle_threshold,\n                association_threshold=i_association_threshold\n            )\n\n            df_asssociated_cluster = dfb_geometry.DFPointCloud()\n            for df_associated_face in df_asssociated_cluster_faces:\n                df_asssociated_cluster.add_points(df_associated_face)\n\n            dfb_segmentation.DFSegmentation.clean_unassociated_clusters(\n                is_roundwood=df_b.is_roundwood,\n                unassociated_clusters=df_clouds,\n                associated_clusters=[df_asssociated_cluster],\n                reference_mesh=[df_b_mesh_faces],\n                angle_threshold=i_angle_threshold,\n                association_threshold=i_association_threshold\n            )\n\n            df_clusters.append(df_asssociated_cluster)\n\n        o_clusters = [df_cvt_bindings.cvt_dfcloud_2_rhcloud(cluster) for cluster in df_clusters]\n\n        for o_cluster in o_clusters:\n            if not o_cluster.IsValid:\n                o_cluster = None\n                ghenv.Component.AddRuntimeMessage(RML.Warning, \"Some beams could not be segmented and were replaced by 'None'\")  # noqa: F821\n\n\n        return o_clusters\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "functions", "mesh", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_5409cea690.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Adds a button to the component input", "code": "#! python3\n\nimport System\n\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper\n\n\ndef add_button(self,\n    nickname: str,\n    indx: int,\n    X_param_coord: float,\n    Y_param_coord: float,\n    X_offset: int=45\n    ) -> None:\n    \"\"\"\n        Adds a button to the component input\n\n        :param nickname: the nickname of the button\n        :param indx: the index of the input parameter\n        :param X_param_coord: the x coordinate of the input parameter\n        :param Y_param_coord: the y coordinate of the input parameter\n        :param X_offset: the offset of the button from the input parameter\n    \"\"\"\n    param = ghenv.Component.Params.Input[indx]    # noqa: F821\n    if param.SourceCount == 0:\n        button = Grasshopper.Kernel.Special.GH_ButtonObject()\n        button.NickName = \"\"\n        button.Description = \"\"\n        button.CreateAttributes()\n        button.Attributes.Pivot = System.Drawing.PointF(\n            X_param_coord - (button.Attributes.Bounds.Width) - X_offset,\n            Y_param_coord - (button.Attributes.Bounds.Height / 2 - 0.1)\n            )\n        button.Attributes.ExpireLayout()\n        Grasshopper.Instances.ActiveCanvas.Document.AddObject(button, False)\n        ghenv.Component.Params.Input[indx].AddSource(button)    # noqa: F821\n\nclass DFExportResults(component):\n    def __init__(self):\n        super(DFExportResults, self).__init__()\n        ghenv.Component.ExpireSolution(True)  # noqa: F821\n        ghenv.Component.Attributes.PerformLayout()    # noqa: F821\n        params = getattr(ghenv.Component.Params, \"Input\")    # noqa: F821\n        for j in range(len(params)):\n            X_cord = params[j].Attributes.Pivot.X\n            Y_cord = params[j].Attributes.InputGrip.Y\n            if params[j].Name == \"i_dump\":\n                add_button(self, \"\", j, X_cord, Y_cord)\n\n    def RunScript(self, i_dump: bool, i_export_dir: str, i_results):\n        if i_dump is None or i_export_dir is None or i_results is None:\n            return None\n\n        o_path = None\n        if i_dump:\n            o_path = i_results.dump_serialization(i_export_dir)\n\n        return o_path\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["classes", "functions", "point"], "original_file": "diffCheckOrg_diffCheck_580b19a96b.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Adds a boolean toggle to the component input", "code": "#! python3\n\nimport System\nimport csv\nimport os\nimport typing\n\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper as gh\n\nfrom diffCheck.df_error_estimation import DFInvalidData, DFVizResults\n\n\ndef add_bool_toggle(self,\n    nickname: str,\n    indx: int,\n    X_param_coord: float,\n    Y_param_coord: float,\n    X_offset: int=87\n    ) -> None:\n    \"\"\"\n        Adds a boolean toggle to the component input\n\n        :param nickname: the nickname of the value list\n        :param indx: the index of the input parameter\n        :param X_param_coord: the x coordinate of the input parameter\n        :param Y_param_coord: the y coordinate of the input parameter\n        :param X_offset: the offset of the value list from the input parameter\n    \"\"\"\n    param = ghenv.Component.Params.Input[indx]  # noqa: F821\n    if param.SourceCount == 0:\n        toggle = gh.Kernel.Special.GH_BooleanToggle()\n        toggle.NickName = nickname\n        toggle.Description = \"Toggle the value to use with DFVizSettings\"\n        toggle.CreateAttributes()\n        toggle.Attributes.Pivot = System.Drawing.PointF(\n            X_param_coord - (toggle.Attributes.Bounds.Width) - X_offset,\n            Y_param_coord - (toggle.Attributes.Bounds.Height / 2 + 0.1)\n            )\n        toggle.Attributes.ExpireLayout()\n        gh.Instances.ActiveCanvas.Document.AddObject(toggle, False)\n        ghenv.Component.Params.Input[indx].AddSource(toggle)  # noqa: F821\n\n\nclass DFCsvExporter(component):\n    def __init__(self):\n        super(DFCsvExporter, self).__init__()\n        self.prefix = \"\"\n        self.counter = 0\n\n        ghenv.Component.ExpireSolution(True)  # noqa: F821\n        ghenv.Component.Attributes.PerformLayout()  # noqa: F821\n        params = getattr(ghenv.Component.Params, \"Input\")  # noqa: F821\n        for j in range(len(params)):\n            Y_cord = params[j].Attributes.InputGrip.Y + 1\n            X_cord = params[j].Attributes.Pivot.X + 10\n            input_indx = j\n            if \"i_export_seperate_files\" == params[j].NickName:\n                add_bool_toggle(\n                    ghenv.Component,  # noqa: F821\n                    \"export_asfiles\",\n                    input_indx, X_cord, Y_cord)\n            if \"i_export_distances\" == params[j].NickName:\n                add_bool_toggle(\n                    ghenv.Component,  # noqa: F821\n                    \"export_dist\",\n                    input_indx, X_cord, Y_cord)\n\n    def _prepare_row(self,\n            idx: int,\n            i_result: DFVizResults\n        ) -> typing.Dict[str, typing.Any]:\n        \"\"\"\n            Convert the results contained in the DFVizResults object to a dict to be written in the CSV file\n\n            :param idx: Index of the element\n            :param i_result: DFVizResults object containing all the values\n\n            :return: Dict of values containing as keys the header and as items the values to be written in the CSV file\n        \"\"\"\n        if i_result.sanity_check[idx].value != DFInvalidData.VALID.value:\n            invalid_type = i_result.sanity_check[idx].name\n            return {\n                f\"{self.prefix} id\": i_result.find_id(idx),\n                \"invalid_type\": invalid_type,\n                \"min_deviation\": invalid_type,\n                \"max_deviation\": invalid_type,\n                \"std_deviation\": invalid_type,\n                \"rmse\": invalid_type,\n                \"mean\": invalid_type\n            }\n\n        distances = [round(value, 4) for value in i_result.distances[idx]]\n        min_dev = round(i_result.distances_min_deviation[idx], 4)\n        max_dev = round(i_result.distances_max_deviation[idx], 4)\n        std_dev = round(i_result.distances_sd_deviation[idx], 4)\n        rmse = round(i_result.distances_rmse[idx], 4)\n        mean = round(i_result.distances_mean[idx], 4)\n\n        row: typing.Dict[str, typing.Any] = {\n            f\"{self.prefix} id\": i_result.find_id(idx),\n            \"distances\": distances,\n            \"min_deviation\": min_dev,\n            \"max_deviation\": max_dev,\n            \"std_deviation\": std_dev,\n            \"rmse\": rmse,\n            \"mean\": mean\n        }\n\n        # Add extra geometric info based on analysis type here:\n        if i_result.analysis_type == \"beam\":\n            row.update({\n                \"beam_length\": i_result.assembly.beams[idx].length\n            })\n        elif i_result.analysis_type == \"joint\":\n            # NB:: for conviniency, if there is only one beam, we add the lenght of the beam i nthe joint csv analysis output\n            if i_result.assembly.has_only_one_beam:\n                row.update({\n                    \"beam_length\": i_result.assembly.beams[0].length\n                })\n            row.update({\n                \"joint_distance_to_beam_midpoint\": i_result.assembly.compute_all_joint_distances_to_midpoint()[idx]\n            })\n        elif i_result.analysis_type == \"joint_face\":\n            row.update({\n                \"jointface_angle\": i_result.assembly.compute_all_joint_angles()[idx]\n            })\n\n        return row\n\n    def _write_csv(self,\n        csv_path: str,\n        rows: typing.List[typing.Dict[str, typing.Any]],\n        is_writing_only_distances: bool = False\n        ) -> None:\n        \"\"\"\n            Write the CSV file\n\n            :param csv_path: Path of the CSV file\n            :param rows: List of dictionaries containing values to be written in the CSV file\n            :param is_writing_only_distances: Flag to check if to write ONLY distances or the whole analysis\n\n            :return: None\n        \"\"\"\n        with open(csv_path, mode='w', newline='') as file:\n            writer = csv.writer(file, quoting=csv.QUOTE_MINIMAL)\n            if is_writing_only_distances:\n                writer.writerow(list(rows[0].keys())[:2])  # header\n                element_id = [row[f\"{self.prefix} id\"] for row in rows]\n                dist_rows = [row[\"distances\"] for row in rows]\n                for idx, dist_row in enumerate(dist_rows):\n                    for dist in dist_row:\n                        writer.writerow([element_id[idx], dist])\n            else:\n                rows = [{k: v for k, v in row.items() if k != \"distances\"} for row in rows]  # no distances\n                writer.writerow(list(rows[0].keys()))  # header\n                writer.writerows([list(row.values()) for row in rows])\n\n    def RunScript(self,\n            i_dump: bool,\n            i_export_dir: str,\n            i_file_name: str,\n            i_export_seperate_files: bool,\n            i_export_distances: bool,\n            i_result: DFVizResults) -> None:\n\n        csv_analysis_path: str = None\n        csv_distances_path: str = None\n\n        if i_dump:\n            os.makedirs(i_export_dir, exist_ok=True)\n\n            self.prefix = i_result.analysis_type\n\n            if i_export_seperate_files:\n                for idx in range(len(i_result.source)):\n                    element_id = self._get_id(idx, i_result)\n                    csv_analysis_path = os.path.join(i_export_dir, f\"{i_file_name}_{self.prefix}_{element_id}.csv\")\n                    rows = [self._prepare_row(idx, i_result)]\n                    self._write_csv(csv_analysis_path, rows)\n                    if i_export_distances:\n                        csv_distances_path = os.path.join(i_export_dir, f\"{i_file_name}_{self.prefix}_{element_id}_distances.csv\")\n                        self._write_csv(csv_distances_path, rows, is_writing_only_distances=True)\n            else:\n                csv_analysis_path = os.path.join(i_export_dir, f\"{i_file_name}.csv\")\n                merged_rows = [self._prepare_row(idx, i_result) for idx in range(len(i_result.source))]\n                self._write_csv(csv_analysis_path, merged_rows)\n                if i_export_distances:\n                    csv_distances_path = os.path.join(i_export_dir, f\"{i_file_name}_distances.csv\")\n                    self._write_csv(csv_distances_path, merged_rows, is_writing_only_distances=True)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["line", "classes", "functions", "point"], "original_file": "diffCheckOrg_diffCheck_5ef23c1ea9.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\n\nimport Rhino\nfrom ghpythonlib.componentbase import executingcomponent as component\n\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\n\nfrom diffCheck import diffcheck_bindings\nfrom diffCheck import df_cvt_bindings\n\n\nclass DFICPRegistration(component):\n    def RunScript(self,\n            i_use_generalized_icp: bool,\n            i_cloud_source: Rhino.Geometry.PointCloud,\n            i_cloud_target: Rhino.Geometry.PointCloud,\n            i_max_corrspondence_dist: float,\n            i_max_iteration: int,\n            is_t_estimate_pt2pt: bool,\n            i_use_point_to_plane: bool) -> Rhino.Geometry.Transform:\n        if i_cloud_source is None or i_cloud_target is None:\n            ghenv.Component.AddRuntimeMessage(RML.Warning, \"Please provide both objects of type point clouds to align\")  # noqa: F821\n            return None\n        if not i_cloud_source.ContainsNormals or not i_cloud_target.ContainsNormals:\n            ghenv.Component.AddRuntimeMessage(RML.Error, \"Please compute cloud's normals with a component before\")  # noqa: F821\n\n        # set default values\n        if i_use_generalized_icp is None:\n            i_use_generalized_icp = True\n        if i_max_corrspondence_dist is None:\n            i_max_corrspondence_dist = 5\n        if i_max_iteration is None:\n            i_max_iteration = 50\n\n        # conversion\n        df_cloud_source = df_cvt_bindings.cvt_rhcloud_2_dfcloud(i_cloud_source)\n        df_cloud_target = df_cvt_bindings.cvt_rhcloud_2_dfcloud(i_cloud_target)\n\n        # fast registration\n        # these are the only hardcoded values since it will get the best result\n        RELATIVE_FITNESS = 1e-6\n        RELATIVE_RMSE = 1e-6\n\n        df_xform = None\n        if i_use_generalized_icp:\n            df_xform = diffcheck_bindings.dfb_registrations.DFRefinedRegistration.O3DGeneralizedICP(\n                source=df_cloud_source,\n                target=df_cloud_target,\n                max_correspondence_distance=i_max_corrspondence_dist,\n                max_iteration=i_max_iteration,\n                relative_fitness=RELATIVE_FITNESS,\n                relative_rmse=RELATIVE_RMSE\n            )\n        else:\n            df_xform = diffcheck_bindings.dfb_registrations.DFRefinedRegistration.O3DICP(\n                source=df_cloud_source,\n                target=df_cloud_target,\n                max_correspondence_distance=i_max_corrspondence_dist,\n                is_t_estimate_pt2pt=is_t_estimate_pt2pt,\n                relative_fitness=RELATIVE_FITNESS,\n                relative_rmse=RELATIVE_RMSE,\n                max_iteration=i_max_iteration,\n                use_point_to_plane=i_use_point_to_plane\n            )\n        print(\"-------------------\")\n        print(\"Estimated transformation matrix:\")\n        print(df_xform.transformation_matrix)\n        print(\"-------------------\")\n\n        # cvt df xform to rhino xform\n        df_xform_matrix = df_xform.transformation_matrix\n        rh_form = Rhino.Geometry.Transform()\n        for i in range(4):\n            for j in range(4):\n                rh_form[i, j] = df_xform_matrix[i, j]\n        if rh_form == Rhino.Geometry.Transform.Identity:\n            ghenv.Component.AddRuntimeMessage(RML.Warning, \"The transformation matrix is identity, no transformation is applied\")  # noqa: F821\n            return None\n\n        o_x_form = rh_form\n\n        return o_x_form\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "classes", "functions", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_66eec2165d.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Adds a boolean toggle to the component input", "code": "#! python3\n\nimport System\n\nimport Rhino.Geometry as rg\n\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper as gh\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\n\nimport diffCheck\nimport diffCheck.diffcheck_bindings\nimport diffCheck.df_util\n\nimport numpy as np\n\n\ndef add_bool_toggle(self,\n    nickname: str,\n    indx: int,\n    X_param_coord: float,\n    Y_param_coord: float,\n    X_offset: int=87\n    ) -> None:\n    \"\"\"\n        Adds a boolean toggle to the component input\n\n        :param nickname: the nickname of the value list\n        :param indx: the index of the input parameter\n        :param X_param_coord: the x coordinate of the input parameter\n        :param Y_param_coord: the y coordinate of the input parameter\n        :param X_offset: the offset of the value list from the input parameter\n    \"\"\"\n    param = ghenv.Component.Params.Input[indx]  # noqa: F821\n    if param.SourceCount == 0:\n        toggle = gh.Kernel.Special.GH_BooleanToggle()\n        toggle.NickName = nickname\n        toggle.Description = \"Toggle the value to use with DFVizSettings\"\n        toggle.CreateAttributes()\n        toggle.Attributes.Pivot = System.Drawing.PointF(\n            X_param_coord - (toggle.Attributes.Bounds.Width) - X_offset,\n            Y_param_coord - (toggle.Attributes.Bounds.Height / 2 + 0.1)\n            )\n        toggle.Attributes.ExpireLayout()\n        gh.Instances.ActiveCanvas.Document.AddObject(toggle, False)\n        ghenv.Component.Params.Input[indx].AddSource(toggle)  # noqa: F821\n\nclass DFPreviewAssembly(component):\n    def __init__(self):\n        super(DFPreviewAssembly, self).__init__()\n        self._dfassembly = None\n        self._joint_rnd_clr = None\n\n        ghenv.Component.ExpireSolution(True)  # noqa: F821\n        ghenv.Component.Attributes.PerformLayout()  # noqa: F821\n        params = getattr(ghenv.Component.Params, \"Input\")  # noqa: F821\n        for j in range(len(params)):\n            Y_cord = params[j].Attributes.InputGrip.Y + 1\n            X_cord = params[j].Attributes.Pivot.X + 20\n            input_indx = j\n            if \"i_are_joints_visible\" == params[j].NickName:\n                add_bool_toggle(\n                    ghenv.Component,  # noqa: F821\n                    \"show_joints\",\n                    input_indx, X_cord, Y_cord)\n\n\n    def RunScript(self, i_assembly, i_are_joints_visible: bool):\n        if i_assembly is None:\n            return None\n        if i_are_joints_visible is None:\n            i_are_joints_visible = False\n\n        self._dfassembly = i_assembly\n\n        self._joint_rnd_clr = [System.Drawing.Color.FromArgb(\n            System.Convert.ToInt32(255 * np.random.rand()),\n            System.Convert.ToInt32(255 * np.random.rand()),\n            System.Convert.ToInt32(255 * np.random.rand())) for _ in range(len(self._dfassembly.beams))]\n\n        self._are_joints_visible = i_are_joints_visible\n\n        return None\n\n    # Preview overrides\n    def DrawViewportWires(self, args):\n        if self._dfassembly is None:\n            return\n        for idx_beam, beam in enumerate(self._dfassembly.beams):\n            #######################################\n            ## DFBeams\n            #######################################\n            if len(self._dfassembly.beams) > 1:\n                beam_axis = beam.axis\n                extension_length = 0.5 * diffCheck.df_util.get_doc_2_meters_unitf()\n                beam_axis.Extend(extension_length, extension_length)\n                args.Display.DrawArrow(beam_axis, System.Drawing.Color.Magenta)\n\n                # beam assembly index\n                anchor_pt: rg.Point3d = beam_axis.From - beam_axis.UnitTangent * 0.5 * extension_length\n                args.Display.Draw2dText(\n                    str(beam.index_assembly),\n                    System.Drawing.Color.Violet,\n                    anchor_pt,\n                    True, 18)\n\n            #######################################\n            ## DFJoints\n            #######################################\n            if self._are_joints_visible:\n                clr = self._joint_rnd_clr[idx_beam]\n                for idx_joint, joint in enumerate(beam.joints):\n                    joint_faces = joint.faces\n                    for idx_face, face in enumerate(joint_faces):\n                        if len(self._dfassembly.beams) == 1:\n                            clr: System.Drawing.Color = System.Drawing.Color.Magenta\n\n                        face_center = face.to_brep_face().GetBoundingBox(False).Center\n                        args.Display.DrawPoint(face_center, clr)\n\n                        vector_face_center_2_beam_center = face_center - beam.center\n                        vector_face_center_2_beam_center.Unitize()\n                        vector_face_center_2_beam_center *= 0.4 * 0.5 * diffCheck.df_util.get_doc_2_meters_unitf()\n\n                        ln = rg.Line(face_center, face_center + vector_face_center_2_beam_center)\n                        args.Display.DrawDottedLine(ln, clr)\n\n                        ghenv.Component.AddRuntimeMessage(RML.Remark, \"legend joint naming: the beam index - the joint index - the face index by list order\")  # noqa: F821\n                        name_face_joint: str = f\"{beam.index_assembly}-{joint.id}-{idx_face}\"\n                        args.Display.Draw2dText(\n                            name_face_joint,\n                            clr,\n                            ln.To,\n                            True, 18)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "brep", "line", "functions", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_995791c731.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\nfrom ghpythonlib.componentbase import executingcomponent as component\n\nfrom diffCheck import df_cvt_bindings\nfrom diffCheck import df_visualization\nfrom diffCheck.df_visualization import DFVizSettings\nfrom diffCheck.df_error_estimation import DFVizResults, DFInvalidData\n\nclass DFVisualization(component):\n    def RunScript(self,\n                  i_result: DFVizResults,\n                  i_viz_settings: DFVizSettings):\n\n        if i_result is None or i_viz_settings is None:\n            return None, None, None\n\n        # make a DFVizResult copy to avoid modifying the original result to be exported in csv\n        result_cp = DFVizResults(i_result.assembly)\n        exclude_indices = [idx for idx, sanity_val in enumerate(i_result.sanity_check) if sanity_val.value != DFInvalidData.VALID.value]\n        result_cp.source = [val for idx, val in enumerate(i_result.source) if idx not in exclude_indices]\n        result_cp.target = [val for idx, val in enumerate(i_result.target) if idx not in exclude_indices]\n        result_cp.distances = [val for idx, val in enumerate(i_result.distances) if idx not in exclude_indices]\n        result_cp.distances_mean = [val for idx, val in enumerate(i_result.distances_mean) if idx not in exclude_indices]\n        result_cp.distances_rmse = [val for idx, val in enumerate(i_result.distances_rmse) if idx not in exclude_indices]\n        result_cp.distances_max_deviation = [val for idx, val in enumerate(i_result.distances_rmse) if idx not in exclude_indices]\n        result_cp.distances_min_deviation = [val for idx, val in enumerate(i_result.distances_min_deviation) if idx not in exclude_indices]\n        result_cp.distances_sd_deviation = [val for idx, val in enumerate(i_result.distances_sd_deviation) if idx not in exclude_indices]\n\n        values, min_value, max_value = result_cp.filter_values_based_on_valuetype(i_viz_settings)\n\n        # check if result_cp.source is a list of pointclouds or a mesh\n        if result_cp.is_source_cloud:\n            o_source = [df_cvt_bindings.cvt_dfcloud_2_rhcloud(src) for src in result_cp.source]\n            o_colored_geo = [df_visualization.color_rh_pcd(src, dist, min_value, max_value, i_viz_settings.palette) for src, dist in zip(o_source, values)]\n        else:\n            o_source = result_cp.source\n            o_colored_geo = [df_visualization.color_rh_mesh(src, dist, min_value, max_value, i_viz_settings.palette) for src, dist in zip(o_source, values)]\n\n        o_legend = df_visualization.create_legend(min_value,\n                                                  max_value,\n                                                  i_viz_settings.palette,\n                                                  steps=10,\n                                                  plane=i_viz_settings.legend_plane,\n                                                  width=i_viz_settings.legend_width,\n                                                  total_height=i_viz_settings.legend_height)\n\n        if len(result_cp.source) > 1 and i_viz_settings.one_histogram_per_item:\n            multiple_curves = True\n        else:\n            multiple_curves = False\n\n        o_histogram = df_visualization.create_histogram(values,\n                                                        min_value,\n                                                        max_value,\n                                                        res=100,\n                                                        steps=10,\n                                                        plane=i_viz_settings.legend_plane,\n                                                        total_height=i_viz_settings.legend_height,\n                                                        scaling_factor=i_viz_settings.histogram_scale_factor,\n                                                        multiple_curves = multiple_curves)\n\n        return o_colored_geo, o_legend, o_histogram\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["classes", "point", "curve", "functions", "mesh"], "original_file": "diffCheckOrg_diffCheck_a6e4bbcaa1.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\nimport System\nimport Rhino\nfrom ghpythonlib.componentbase import executingcomponent as component\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\nimport ghpythonlib.treehelpers as th\n\nimport diffCheck\nfrom diffCheck import df_error_estimation\n\n\nclass DFCloudMeshDistance(component):\n\n    def RunScript(self,\n            i_cloud_source: System.Collections.Generic.List[Rhino.Geometry.PointCloud],\n            i_assembly,\n            i_signed_flag: bool,\n            i_swap: bool,\n            i_analysis_resolution: float):\n\n        if i_cloud_source is None or i_assembly is None:\n            return None, None, None, None, None, None\n\n        if i_analysis_resolution is None:\n            scalef = diffCheck.df_util.get_doc_2_meters_unitf()\n            i_analysis_resolution = 0.1 / scalef\n\n        if len(i_assembly.beams) == len(i_cloud_source):\n            ghenv.Component.Message = \"Per Beam\"  # noqa: F821\n            rh_mesh_target_list = [beam.to_mesh(i_analysis_resolution) for beam in i_assembly.beams]\n        elif len(i_assembly.all_joints) == len(i_cloud_source):\n            ghenv.Component.Message = \"Per Joint\"  # noqa: F821\n            rh_mesh_target_list = [joint.to_mesh(i_analysis_resolution) for joint in i_assembly._all_joints]\n        elif len(i_assembly.all_joint_faces) == len(i_cloud_source):\n            ghenv.Component.Message = \"Per Joint Face\"  # noqa: F821\n            rh_mesh_target_list = []\n            for joint in i_assembly._all_joints:\n                for face in joint.faces:\n                    rh_mesh_target_list.append(face.to_mesh())\n        else:\n            ghenv.Component.AddRuntimeMessage(RML.Warning, \"The input number of objects to compare matches neither the number of beams nor the number of joints\")  # noqa: F821\n            return None, None, None, None, None, None\n\n        o_result = df_error_estimation.rh_cloud_2_rh_mesh_comparison(\n            i_assembly,\n            i_cloud_source,\n            rh_mesh_target_list,\n            i_signed_flag,\n            i_swap)  # noqa: F821\n\n        distances_gh_tree = th.list_to_tree(o_result.distances)\n\n        return distances_gh_tree, o_result.distances_mean, o_result.distances_rmse, o_result.distances_max_deviation, o_result.distances_min_deviation, o_result.distances_sd_deviation, o_result\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "functions", "mesh", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_cb7ede0338.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "from compas_rhino.exceptions import RhinoCurveError\n\ntry:\n    from Rhino.Geometry import Point3d\n\n    import rhinoscriptsyntax as rs\n    import scriptcontext as sc\n\n    find_object = sc.doc.Objects.Find\n\nexcept ImportError:\n    import platform\n    if platform.python_implementation() == 'IronPython':\n        raise\n\n\n__author__     = ['Tom Van Mele', ]\n__copyright__  = 'Copyright 2014, BLOCK Research Group - ETH Zurich'\n__license__    = 'MIT License'\n__email__      = 'vanmelet@ethz.ch'\n\n\nclass RhinoCurve(object):\n    \"\"\"\"\"\"\n\n    def __init__(self, guid):\n        self.guid = guid\n        self.curve = find_object(guid)\n        self.geometry = self.curve.Geometry\n        self.attributes = self.curve.Attributes\n        self.otype = self.geometry.ObjectType\n\n    def hide(self):\n        return rs.HideObject(self.guid)\n\n    def show(self):\n        return rs.ShowObject(self.guid)\n\n    def select(self):\n        return rs.SelectObject(self.guid)\n\n    def unselect(self):\n        return rs.UnselectObject(self.guid)\n\n    def is_line(self):\n        return (rs.IsLine(self.guid) and\n                rs.CurveDegree(self.guid) == 1 and\n                len(rs.CurvePoints(self.guid)) == 2)\n\n    def is_polyline(self):\n        return (rs.IsPolyline(self.guid) and\n                rs.CurveDegree(self.guid) == 1 and\n                len(rs.CurvePoints(self.guid)) > 2)\n\n    def space(self, density):\n        space = []\n        density = int(density)\n        if rs.IsCurve(self.guid):\n            domain = rs.CurveDomain(self.guid)\n            u = (domain[1] - domain[0]) / (density - 1)\n            for i in range(density):\n                space.append(domain[0] + u * i)\n        elif rs.IsPolyCurve(self.guid):\n            rs.EnableRedraw(False)\n            segments = rs.ExplodeCurves(self.guid)\n            for segment in segments:\n                domain = rs.CurveDomain(segment)\n                u = (domain[1] - domain[0]) / (density - 1)\n                for i in range(density):\n                    space.append(domain[0] + u * i)\n            rs.DeleteObjects(segments)\n            rs.EnableRedraw(True)\n        else:\n            raise RhinoCurveError('object is not a curve')\n        return space\n\n    def heightfield(self, density):\n        heightfield = []\n        space = self.space(density)\n        if space:\n            xyz = [rs.EvaluateCurve(self.guid, param) for param in space]\n            heightfield = map(list, xyz)\n        return heightfield\n\n    def curvature(self):\n        raise NotImplementedError\n\n    def tangents(self, points):\n        tangents = []\n        if rs.IsPolyCurve(self.guid):\n            pass\n        elif rs.IsCurve(self.guid):\n            for point in points:\n                param = rs.CurveClosestPoint(self.guid, point)\n                vector = list(rs.CurveTangent(self.guid, param))\n                tangents.append((point, vector))\n        else:\n            raise RhinoCurveError('object is not a curve')\n        return tangents\n\n    def descent(self, points):\n        tangents = self.tangents(points)\n        tangents = [\n            (point, vector) if vector[2] < 0 else (point, [-v for v in vector])\n            for point, vector in tangents\n        ]\n        return tangents\n\n    def divide(self, number_of_segments, over_space=False):\n        points = []\n        rs.EnableRedraw(False)\n        if over_space:\n            space = self.space(number_of_segments + 1)\n            if space:\n                points = [list(rs.EvaluateCurve(self.guid, param)) for param in space]\n        else:\n            points = rs.DivideCurve(self.guid, number_of_segments, create_points=False, return_points=True)\n            points[:] = map(list, points)\n        rs.EnableRedraw(True)\n        return points\n\n    def divide_length(self, length_of_segments):\n        rs.EnableRedraw(False)\n        points = rs.DivideCurveLength(self.guid, length_of_segments, create_points=False, return_points=True)\n        points[:] = map(list, points)\n        rs.EnableRedraw(True)\n        return points\n\n    def closest_point(self, point, maxdist=None):\n        maxdist = maxdist or 0.0\n        rc, t = self.geometry.ClosestPoint(Point3d(*point), maxdist)\n        return list(self.geometry.PointAt(t))\n\n    def closest_points(self, points, maxdist=None):\n        return [self.closest_point(point, maxdist) for point in points]\n\n\n# ==============================================================================\n# Debugging\n# ==============================================================================\n\nif __name__ == '__main__':\n\n    pass\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "classes", "point", "line", "curve", "functions", "block", "RhinoCommon"], "original_file": "dtbinh_T1_python-exercises_42afffaa4c.json", "repo": "dtbinh/T1_python-exercises"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "from compas_rhino.conduits import Conduit\nfrom compas_rhino.ui.mouse import Mouse\n\nfrom compas.geometry import length_vector\nfrom compas.geometry import cross_vectors\nfrom compas.geometry import subtract_vectors\n\ntry:\n    from Rhino.Geometry import Point3d\n\n    from System.Drawing.Color import FromArgb\n\nexcept ImportError:\n    import platform\n    if platform.python_implementation() == 'IronPython':\n        raise\n\n\n__author__     = ['Tom Van Mele', ]\n__copyright__  = 'Copyright 2014, BLOCK Research Group - ETH Zurich'\n__license__    = 'MIT License'\n__email__      = 'vanmelet@ethz.ch'\n\n\n__all__ = ['MeshVertexInspector', ]\n\n\nclass MeshVertexInspector(Conduit):\n    \"\"\"\"\"\"\n    def __init__(self, mesh, tol=0.1, dotcolor=None, textcolor=None, **kwargs):\n        super(MeshVertexInspector, self).__init__(**kwargs)\n        self.mesh      = mesh\n        self.tol       = tol\n        dotcolor       = dotcolor or (255, 0, 0)\n        textcolor      = textcolor or (0, 0, 0)\n        self.dotcolor  = FromArgb(*dotcolor)\n        self.textcolor = FromArgb(*textcolor)\n        self.mouse     = Mouse()\n\n    def enable(self):\n        self.mouse.Enabled = True\n        self.Enabled = True\n\n    def disable(self):\n        self.mouse.Enabled = False\n        self.Enabled = False\n\n    def DrawForeground(self, e):\n        p1  = self.mouse.p1\n        p2  = self.mouse.p2\n        v12 = subtract_vectors(p2, p1)\n        l12 = length_vector(v12)\n        for index, (key, attr) in enumerate(self.mesh.vertices(True)):\n            p0   = attr['x'], attr['y'], attr['z']\n            text = str(index)\n            v01  = subtract_vectors(p1, p0)\n            v02  = subtract_vectors(p2, p0)\n            l    = length_vector(cross_vectors(v01, v02))\n            if l12 == 0.0 or (l / l12) < self.tol:\n                point = Point3d(*p0)\n                e.Display.DrawDot(point, text, self.dotcolor, self.textcolor)\n                break\n\n\n# ==============================================================================\n# Debugging\n# ==============================================================================\n\nif __name__ == \"__main__\":\n\n    pass\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "functions", "block", "mesh", "RhinoCommon"], "original_file": "dtbinh_T1_python-exercises_494a5849ab.json", "repo": "dtbinh/T1_python-exercises"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "from __future__ import print_function\n\ntry:\n    from Rhino.UI import MouseCallback\nexcept ImportError:\n    import platform\n    if platform.python_implementation() == 'IronPython':\n        raise\n\n    class MouseCallback(object):\n        pass\n\n\n__author__     = ['Tom Van Mele', ]\n__copyright__  = 'Copyright 2014, BLOCK Research Group - ETH Zurich'\n__license__    = 'MIT License'\n__email__      = 'vanmelet@ethz.ch'\n\n\n__all__ = ['Mouse', ]\n\n\nclass Mouse(MouseCallback):\n    \"\"\"\"\"\"\n    def __init__(self):\n        super(Mouse, self).__init__()\n        self.x  = None  # x-coordinate of 2D point in the viewport\n        self.y  = None  # y-coordinate of 2D point in the viewport\n        self.p1 = None  # start of the frustum line in world coordinates\n        self.p2 = None  # end of the frustum line in world coordinates\n\n    def OnMouseMove(self, e):\n        line    = e.View.ActiveViewport.ClientToWorld(e.ViewportPoint)\n        self.x  = e.ViewportPoint.X\n        self.y  = e.ViewportPoint.Y\n        self.p1 = line.From\n        self.p2 = line.To\n        e.View.Redraw()\n\n    def OnMouseDown(self, e):\n        pass\n\n    def OnMouseUp(self, e):\n        pass\n\n\n# ==============================================================================\n# Debugging\n# ==============================================================================\n\nif __name__ == '__main__':\n\n    from compas.geometry import distance_point_line\n\n    import System\n    from System.Drawing import Color\n\n    import Rhino\n    from Rhino.Geometry import Point3d\n\n    import rhinoscriptsyntax as rs\n\n    # calculate \"right angle distance\" from point to frustum line\n    # to check if mouse is hovering over that point\n    # the distance from a point P to a line defined by points A, B\n    # is twice the area of the trianlge ABP divided by the length of AB\n    # see: https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n    class Inspector(Rhino.Display.DisplayConduit):\n        \"\"\"\"\"\"\n\n        def __init__(self, points, tol=0.1):\n            super(Inspector, self).__init__()\n            self.mouse     = Mouse()\n            self.points    = points\n            self.tol       = tol\n            self.dotcolor  = Color.FromArgb(255, 0, 0)\n            self.textcolor = Color.FromArgb(0, 0, 0)\n\n        def DrawForeground(self, e):\n            p1  = self.mouse.p1\n            p2  = self.mouse.p2\n            for i, p0 in enumerate(self.points):\n                if distance_point_line(p0, (p1, p2)) < self.tol:\n                    e.Display.DrawDot(Point3d(*p0), str(i), self.dotcolor, self.textcolor)\n                    break\n\n    points = [[i, i, 0] for i in range(10)]\n\n    try:\n        inspector = Inspector(points)\n        inspector.mouse.Enabled = True\n        inspector.Enabled = True\n\n        # this interrupts the script until the user provides a string or escapes\n        rs.GetString(message='Do some hovering')\n\n    except Exception as e:\n        print(e)\n\n    finally:\n        inspector.mouse.Enabled = False\n        inspector.Enabled = False\n        del inspector.mouse\n        del inspector\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "classes", "point", "line", "functions", "block", "RhinoCommon"], "original_file": "dtbinh_T1_python-exercises_59abd923af.json", "repo": "dtbinh/T1_python-exercises"}
{"instruction": "Creates an instance of a compAS mesh class from an identifier", "code": "from __future__ import print_function\nimport sys\n\ntry:\n    import rhinoscriptsyntax as rs\n    import ghpythonlib.components as ghcomp\nexcept ImportError:\n    import platform\n    if platform.python_implementation() == 'IronPython':\n        raise\n    \nfrom compas.datastructures.mesh import Mesh\nfrom compas_fabrication.fabrication.grasshopper import xdraw_mesh\nfrom compas.utilities.colors import color_to_colordict\n\ndef mesh_from_guid(guid, **kwargs):\n    \"\"\"Creates an instance of a compAS mesh class from an identifier\n    in Rhino/Grasshopper.\n\n    This function is almost identical to ``mesh_from_guid`` in the core\n    framework, but there were some import issues when used from within\n    Grasshopper, but eventually, it should be migrated into the core.\n    \"\"\"\n    trimesh = ghcomp.Triangulate(rs.coercemesh(guid))[0]\n    vertices = [map(float, vertex) for vertex in rs.MeshVertices(trimesh)]\n    faces = map(list, rs.MeshFaceVertices(trimesh))\n    faces = [face[: -1] if face[-2] == face[-1] else face for face in faces]\n    mesh = Mesh.from_vertices_and_faces(vertices, faces)\n    mesh.attributes.update(kwargs)\n    return mesh\n\n\ndef draw_mesh(mesh,\n              layer=None,\n              show_faces=True,\n              show_vertices=False,\n              show_edges=False,\n              show_wireframe=False,\n              vertexcolor=None,\n              edgecolor=None,\n              wireframecolor=None,\n              facecolor=None,\n              ):\n    \"\"\"\n    Draw a mesh object in Grasshopper.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        show_faces (bool): Optional. Show the faces. Default is ``True``.\n        show_vertices (bool): Optional. Show the vertices. Default is ``True``.\n        show_edges (bool): Optional. Show the edges. Default is ``True``.\n        vertexcolor (str, tuple, list, dict): Optional. The vertex color specification. Default is ``None``.\n        edgecolor (str, tuple, list, dict): Optional. The edge color specification. Default is ``None``.\n        facecolor (str, tuple, list, dict): Optional. The face color specification. Default is ``None``.\n        redraw (bool): Optional. Redraw instructions. Default is ``True``.\n\n    Note:\n        Colors can be specified in different ways:\n\n        * str: A hexadecimal color that will be applied to all elements subject to the specification.\n        * tuple, list: RGB color that will be applied to all elements subject to the specification.\n        * dict: RGB or hex color dict with a specification for some or all of the related elements.\n\n    Important:\n        RGB colors should specify color values between 0 and 255.\n\n    \"\"\"\n\n    vertexcolor = color_to_colordict(vertexcolor,\n                                     mesh.vertices(),\n                                     default=mesh.attributes['color.vertex'],\n                                     colorformat='rgb',\n                                     normalize=False)\n\n    edgecolor = color_to_colordict(edgecolor,\n                                   mesh.edges(),\n                                   default=mesh.attributes['color.edge'],\n                                   colorformat='rgb',\n                                   normalize=False)\n\n    # facecolor = color_to_colordict(facecolor,\n    #                                mesh.faces(),\n    #                                default=mesh.attributes['color.face'],\n    #                                colorformat='rgb',\n    #                                normalize=False)\n\n    if show_faces:\n        key_index = {key: index for index, key in enumerate(mesh.vertices())}\n        xyz       = [mesh.vertex_coordinates(key) for key in mesh.vertices()]\n        faces     = []\n        color     = mesh.attributes['color.face']\n\n        for fkey in mesh.face:\n            face = mesh.face_vertices(fkey, ordered=True)\n            v = len(face)\n\n            if v < 3:\n                print('Degenerate face: {0} => {1}'.format(fkey, face))\n            elif v == 3:\n                faces.append([key_index[k] for k in face + [face[-1]]])\n            elif v == 4:\n                faces.append([key_index[k] for k in face])\n            else:\n                c = len(xyz)\n                xyz.append(mesh.face_center(fkey))\n                for i in range(-1, len(face) - 1):\n                    key = face[i]\n                    nbr = face[i + 1]\n                    vertices = [c, key_index[key], key_index[nbr], key_index[nbr]]\n                    faces.append(vertices)\n\n        return xdraw_mesh(xyz, faces, color)\n    \n    \n#     if show_edges:\n#         lines = []\n#         color = mesh.attributes['color.edge']\n#         for u, v in mesh.edges():\n#             lines.append({\n#                 'start': mesh.vertex_coordinates(u),\n#                 'end'  : mesh.vertex_coordinates(v),\n#                 'name' : '{0}.edge.{1}-{2}'.format(mesh.attributes['name'], repr(u), repr(v)),\n#                 'color': edgecolor.get((u, v), color),\n#             })\n#         xdraw_lines(lines)\n# \n#     if show_wireframe:\n#         lines = []\n#         color = mesh.attributes['color.edge']\n#         for u, v in mesh.wireframe():\n#             lines.append({\n#                 'start': mesh.vertex_coordinates(u),\n#                 'end'  : mesh.vertex_coordinates(v),\n#                 'name' : '{0}.edge.{1}-{2}'.format(mesh.attributes['name'], repr(u), repr(v)),\n#                 'color': edgecolor.get((u, v), color),\n#             })\n#         xdraw_lines(lines)\n# \n#     if show_vertices:\n#         points = []\n#         color  = mesh.attributes['color.vertex']\n#         for key in mesh.vertices():\n#             points.append({\n#                 'pos'  : mesh.vertex_coordinates(key),\n#                 'name' : '{0}.vertex.{1}'.format(mesh.attributes['name'], repr(key)),\n#                 'color': vertexcolor.get(key, color),\n#             })\n#         xdraw_points(points)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "classes", "point", "layer", "line", "functions", "mesh"], "original_file": "dtbinh_T1_python-exercises_6aec20ca9b.json", "repo": "dtbinh/T1_python-exercises"}
{"instruction": "A Rhino display conduit for meshes.", "code": "from compas_rhino.conduits import Conduit\n\ntry:\n    from Rhino.Geometry import Point3d\n    from Rhino.Geometry import Line\n\n    from System.Collections.Generic import List\n    from System.Drawing.Color import FromArgb\n\nexcept ImportError:\n    import platform\n    if platform.python_implementation() == 'IronPython':\n        raise\n\n\n__author__     = ['Tom Van Mele', ]\n__copyright__  = 'Copyright 2014, BLOCK Research Group - ETH Zurich'\n__license__    = 'MIT License'\n__email__      = 'vanmelet@ethz.ch'\n\n\n__all__ = ['MeshConduit', ]\n\n\nclass MeshConduit(Conduit):\n    \"\"\"A Rhino display conduit for meshes.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        color (tuple): Optional.\n            The conduit color.\n            Default is ``(255, 0, 0)``.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as compas_rhino\n\n            from compas.datastructures.mesh import Mesh\n            from compas.datastructures.mesh.algorithms import smooth_mesh_centroid\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            conduit = MeshConduit(mesh)\n            conduit.enable()\n\n            def update_conduit(mesh, k):\n                if k % 10 == 0:\n                    conduit.redraw()\n\n            try:\n                smooth_mesh_centroid(mesh, callback=update_conduit)\n            except:\n                raise\n\n            finally:\n                conduit.disable()\n                del conduit\n\n    \"\"\"\n    def __init__(self, mesh, color=None, **kwargs):\n        super(MeshConduit, self).__init__(**kwargs)\n        self.mesh = mesh\n        color = color or (255, 0, 0)\n        self.color = FromArgb(*color)\n\n    def DrawForeground(self, e):\n        edges = self.mesh.wireframe()\n        lines = List[Line](len(edges))\n        for u, v in edges:\n            sp = self.mesh.vertex_coordinates(u)\n            ep = self.mesh.vertex_coordinates(v)\n            lines.Add(Line(Point3d(*sp), Point3d(*ep)))\n        e.Display.DrawLines(lines, self.color)\n\n\n# ==============================================================================\n# Debugging\n# ==============================================================================\n\nif __name__ == \"__main__\":\n\n    pass\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "line", "functions", "block", "mesh", "RhinoCommon"], "original_file": "dtbinh_T1_python-exercises_b670400724.json", "repo": "dtbinh/T1_python-exercises"}
{"instruction": "A Rhino display conduit for lines.", "code": "from compas_rhino.conduits import Conduit\n\ntry:\n    from Rhino.Geometry import Point3d\n    from Rhino.Geometry import Line\n\n    from System.Collections.Generic import List\n    from System.Drawing.Color import FromArgb\n\nexcept ImportError:\n    import platform\n    if platform.python_implementation() == 'IronPython':\n        raise\n\n\n__author__     = 'Tom Van Mele'\n__copyright__  = 'Copyright 2014, BLOCK Research Group - ETH Zurich'\n__license__    = 'MIT License'\n__email__      = 'vanmelet@ethz.ch'\n\n\n__all__ = ['LinesConduit', ]\n\n\nclass LinesConduit(Conduit):\n    \"\"\"A Rhino display conduit for lines.\n\n    Parameters:\n        lines (list): A list of start-end point pairs that define the lines.\n        thickness (float): Optional.\n            The thickness of the conduit lines.\n            Default is ``1.0``.\n        color (tuple): Optional.\n            RGB color spec for the conduit lines.\n            Default is ``None``.\n\n    Example:\n\n        .. code-block:: python\n\n            import random\n            import time\n\n            points = [(1.0 * random.ranint(0, 30), 1.0 * random.randint(0, 30), 0.0) for _ in range(100)]\n            lines  = [(points[i], points[i + 1]) for i in range(99)]\n\n            conduit = LinesConduit(lines)\n            conduit.enable()\n\n            try:\n                for i in range(100):\n                    points = [(1.0 * random.randint(0, 30), 1.0 * random.randint(0, 30), 0.0) for _ in range(100)]\n                    conduit.lines = [(points[i], points[i + 1]) for i in range(99)]\n                    conduit.redraw()\n\n                    time.sleep(0.1)\n            except:\n                raise\n\n            finally:\n                conduit.disable()\n                del conduit\n\n    \"\"\"\n    def __init__(self, lines, thickness=1.0, color=None, **kwargs):\n        super(LinesConduit, self).__init__(**kwargs)\n        self.lines = lines\n        self.n = len(lines)\n        self.thickness = thickness\n        color = color or (255, 255, 255)\n        self.color = FromArgb(*color)\n\n    def DrawForeground(self, e):\n        lines = List[Line](self.n)\n        for start, end in self.lines:\n            lines.Add(Line(Point3d(*start), Point3d(*end)))\n        e.Display.DrawLines(lines, self.color, self.thickness)\n\n\n# ==============================================================================\n# Debugging\n# ==============================================================================\n\nif __name__ == \"__main__\":\n\n    from random import randint\n    import time\n\n    points = [(1.0 * randint(0, 30), 1.0 * randint(0, 30), 0.0) for _ in range(100)]\n    lines  = [(points[i], points[i + 1]) for i in range(99)]\n\n    try:\n        conduit = LinesConduit(lines)\n        conduit.Enabled = True\n\n        for i in range(100):\n            points = [(1.0 * randint(0, 30), 1.0 * randint(0, 30), 0.0) for _ in range(100)]\n            conduit.lines = [(points[i], points[i + 1]) for i in range(99)]\n\n            conduit.redraw()\n\n            time.sleep(0.1)\n\n    except Exception as e:\n        print(e)\n\n    finally:\n        conduit.Enabled = False\n        del conduit\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "line", "functions", "block", "RhinoCommon"], "original_file": "dtbinh_T1_python-exercises_d03bd81980.json", "repo": "dtbinh/T1_python-exercises"}
{"instruction": "Create a mesh data structure from a point grid aligned with the uv space of a Rhino NURBS surface.", "code": "from __future__ import print_function\n\nimport ast\n\nfrom compas.utilities import geometric_key\nfrom compas.utilities import color_to_colordict\n\nfrom compas_rhino.geometry.surface import RhinoSurface\n\nimport compas_rhino\n\ntry:\n    import Rhino\n    from Rhino.Geometry import Point3d\n    import scriptcontext as sc\n    import rhinoscriptsyntax as rs\nexcept ImportError:\n    import platform\n    if platform.python_implementation() == 'IronPython':\n        raise\n\n\n__author__    = ['Tom Van Mele', ]\n__copyright__ = 'Copyright 2016 - Block Research Group, ETH Zurich'\n__license__   = 'MIT License'\n__email__     = 'vanmelet@ethz.ch'\n\n\n__all__ = [\n    'mesh_from_guid',\n    'mesh_from_surface',\n    'mesh_from_surface_uv',\n    'mesh_from_surface_heightfield',\n    'draw_mesh',\n    'draw_mesh_as_faces',\n    'select_mesh_vertices',\n    'select_mesh_vertex',\n    'select_mesh_edges',\n    'select_mesh_edge',\n    'select_mesh_faces',\n    'select_mesh_face',\n    'update_mesh_vertex_attributes',\n    'update_mesh_edge_attributes',\n    'update_mesh_face_attributes',\n    'display_mesh_vertex_labels',\n    'display_mesh_edge_labels',\n    'display_mesh_face_labels',\n    'move_mesh_vertex',\n]\n\n\n# ==============================================================================\n# constructors\n# ==============================================================================\n\n\ndef mesh_from_guid(cls, guid, **kwargs):\n    vertices, faces = compas_rhino.get_mesh_vertices_and_faces(guid)\n    faces = [face[:-1] if face[-2] == face[-1] else face for face in faces]\n    mesh  = cls.from_vertices_and_faces(vertices, faces)\n    mesh.attributes.update(kwargs)\n    return mesh\n\n\ndef mesh_from_surface(cls, guid, **kwargs):\n    gkey_xyz = {}\n    faces = []\n    obj = sc.doc.Objects.Find(guid)\n\n    if not obj.Geometry.HasBrepForm:\n        return\n\n    brep = Rhino.Geometry.Brep.TryConvertBrep(obj.Geometry)\n\n    for loop in brep.Loops:\n        curve = loop.To3dCurve()\n        segments = curve.Explode()\n        face = []\n        sp = segments[0].PointAtStart\n        ep = segments[0].PointAtEnd\n        sp_gkey = geometric_key(sp)\n        ep_gkey = geometric_key(ep)\n        gkey_xyz[sp_gkey] = sp\n        gkey_xyz[ep_gkey] = ep\n        face.append(sp_gkey)\n        face.append(ep_gkey)\n\n        for segment in segments[1:-1]:\n            ep = segment.PointAtEnd\n            ep_gkey = geometric_key(ep)\n            face.append(ep_gkey)\n            gkey_xyz[ep_gkey] = ep\n\n        faces.append(face)\n\n    gkey_index = {gkey: index for index, gkey in enumerate(gkey_xyz)}\n    vertices = [list(xyz) for gkey, xyz in gkey_xyz.items()]\n    faces = [[gkey_index[gkey] for gkey in f] for f in faces]\n    mesh = cls.from_vertices_and_faces(vertices, faces)\n    mesh.attributes.update(kwargs)\n\n    return mesh\n\n\ndef mesh_from_surface_uv(cls, guid, density=(10, 10), **kwargs):\n    return mesh_from_surface_heightfield(cls, guid, density=density, **kwargs)\n\n\ndef mesh_from_surface_heightfield(cls, guid, density=(10, 10), **kwargs):\n    \"\"\"Create a mesh data structure from a point grid aligned with the uv space of a Rhino NURBS surface.\n\n    Parameters:\n        cls (compas.datastructures.mesh.Mesh): The class of mesh that will be created.\n        guid (str): The GUID of the Rhino surface.\n        density (tuple): Optional. The density of the grid in the direction of u and v.\n        kwargs (dict): Optional. Mesh attributes in the form of keyword arguments.\n\n    Returns:\n        compas.datastructures.mesh.Mesh: The mesh that was created.\n\n    \"\"\"\n    try:\n        u, v = density\n    except Exception:\n        u, v = density, density\n\n    surface = RhinoSurface(guid)\n\n    mesh = cls()\n    mesh.attributes.update(kwargs)\n\n    vertices = surface.heightfield(density=(u, v), over_space=True)\n\n    for x, y, z in vertices:\n        mesh.add_vertex(x=x, y=y, z=z)\n\n    for i in range(u - 1):\n        for j in range(v - 1):\n            face = ((i + 0) * v + j,\n                    (i + 0) * v + j + 1,\n                    (i + 1) * v + j + 1,\n                    (i + 1) * v + j)\n            mesh.add_face(face)\n\n    return mesh\n\n\n# ==============================================================================\n# drawing\n# ==============================================================================\n\n# change clear to clearlayer\n# remove redraw?\n# process color spec into color dict\n\ndef draw_mesh(mesh,\n              layer=None,\n              clear_layer=False,\n              show_faces=True,\n              show_vertices=False,\n              show_edges=False,\n              show_wireframe=False,\n              vertexcolor=None,\n              edgecolor=None,\n              wireframecolor=None,\n              facecolor=None,\n              ):\n    \"\"\"\n    Draw a mesh object in Rhino.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        layer (str): Optional. The layer to draw in. Default is ``None``.\n        clear_layer (bool): Optional. Clear the drawing layer. Default is ``True``.\n        show_faces (bool): Optional. Show the faces. Default is ``True``.\n        show_vertices (bool): Optional. Show the vertices. Default is ``True``.\n        show_edges (bool): Optional. Show the edges. Default is ``True``.\n        vertexcolor (str, tuple, list, dict): Optional. The vertex color specification. Default is ``None``.\n        edgecolor (str, tuple, list, dict): Optional. The edge color specification. Default is ``None``.\n        facecolor (str, tuple, list, dict): Optional. The face color specification. Default is ``None``.\n        redraw (bool): Optional. Redraw instructions. Default is ``True``.\n\n    Note:\n        Colors can be specifiedin different ways:\n\n        * str: A hexadecimal color that will be applied to all elements subject to the specification.\n        * tuple, list: RGB color that will be applied to all elements subject to the specification.\n        * dict: RGB or hex color dict with a specification for some or all of the related elements.\n\n    Important:\n        RGB colors should specify color values between 0 and 255.\n\n    \"\"\"\n\n    vertexcolor = color_to_colordict(vertexcolor,\n                                     mesh.vertices(),\n                                     default=mesh.attributes['color.vertex'],\n                                     colorformat='rgb',\n                                     normalize=False)\n\n    edgecolor = color_to_colordict(edgecolor,\n                                   mesh.edges(),\n                                   default=mesh.attributes['color.edge'],\n                                   colorformat='rgb',\n                                   normalize=False)\n\n    # facecolor = color_to_colordict(facecolor,\n    #                                mesh.faces(),\n    #                                default=mesh.attributes['color.face'],\n    #                                colorformat='rgb',\n    #                                normalize=False)\n\n    guids = compas_rhino.get_objects(name='{0}.*'.format(mesh.attributes['name']))\n    compas_rhino.delete_objects(guids)\n\n    if clear_layer:\n        if not layer:\n            compas_rhino.clear_current_layer()\n        else:\n            compas_rhino.clear_layer(layer)\n\n    if show_faces:\n        key_index = {key: index for index, key in enumerate(mesh.vertices())}\n        xyz       = [mesh.vertex_coordinates(key) for key in mesh.vertices()]\n        faces     = []\n        color     = mesh.attributes['color.face']\n\n        for fkey in mesh.face:\n            face = mesh.face_vertices(fkey, ordered=True)\n            v = len(face)\n\n            if v < 3:\n                print('Degenerate face: {0} => {1}'.format(fkey, face))\n            elif v == 3:\n                faces.append([key_index[k] for k in face + [face[-1]]])\n            elif v == 4:\n                faces.append([key_index[k] for k in face])\n            else:\n                c = len(xyz)\n                xyz.append(mesh.face_center(fkey))\n                for i in range(-1, len(face) - 1):\n                    key = face[i]\n                    nbr = face[i + 1]\n                    vertices = [c, key_index[key], key_index[nbr], key_index[nbr]]\n                    faces.append(vertices)\n\n        compas_rhino.xdraw_mesh(xyz,\n                                faces,\n                                color,\n                                '{0}.mesh'.format(mesh.attributes['name']),\n                                layer=layer,\n                                clear=False,\n                                redraw=False)\n\n    if show_edges:\n        lines = []\n        color = mesh.attributes['color.edge']\n        for u, v in mesh.edges():\n            lines.append({\n                'start': mesh.vertex_coordinates(u),\n                'end'  : mesh.vertex_coordinates(v),\n                'name' : '{0}.edge.{1}-{2}'.format(mesh.attributes['name'], repr(u), repr(v)),\n                'color': edgecolor.get((u, v), color),\n            })\n        compas_rhino.xdraw_lines(lines, layer=layer, clear=False, redraw=False)\n\n    if show_wireframe:\n        lines = []\n        color = mesh.attributes['color.edge']\n        for u, v in mesh.wireframe():\n            lines.append({\n                'start': mesh.vertex_coordinates(u),\n                'end'  : mesh.vertex_coordinates(v),\n                'name' : '{0}.edge.{1}-{2}'.format(mesh.attributes['name'], repr(u), repr(v)),\n                'color': edgecolor.get((u, v), color),\n            })\n        compas_rhino.xdraw_lines(lines, layer=layer, clear=False, redraw=False)\n\n    if show_vertices:\n        points = []\n        color  = mesh.attributes['color.vertex']\n        for key in mesh.vertices():\n            points.append({\n                'pos'  : mesh.vertex_coordinates(key),\n                'name' : '{0}.vertex.{1}'.format(mesh.attributes['name'], repr(key)),\n                'color': vertexcolor.get(key, color),\n            })\n        compas_rhino.xdraw_points(points, layer=layer, clear=False, redraw=False)\n\n    rs.EnableRedraw()\n    rs.Redraw()\n\n\ndef draw_mesh_as_faces(mesh,\n                       layer=None,\n                       clear_layer=False,\n                       facecolor=None,\n                       redraw=True):\n\n    guids = compas_rhino.get_objects(name='{0}.*'.format(mesh.attributes['name']))\n    compas_rhino.delete_objects(guids)\n\n    if clear_layer:\n        if not layer:\n            compas_rhino.clear_current_layer()\n        else:\n            compas_rhino.clear_layer(layer)\n\n    facecolor = facecolor or {}\n\n    meshes = []\n\n    for fkey in mesh.faces():\n        vertices = mesh.face_coordinates(fkey)\n        faces = [range(len(vertices))]\n        color = facecolor.get(fkey, (255, 255, 255))\n        guid = compas_rhino.xdraw_mesh(vertices,\n                                       faces,\n                                       None,\n                                       '{0}.face.{1}'.format(mesh.attributes['name'], fkey),\n                                       layer=layer,\n                                       clear=False,\n                                       redraw=False)\n        compas_rhino.set_mesh_vertex_colors(guid, [color for i in range(len(vertices))])\n        meshes.append(guid)\n\n    if layer:\n        previous = rs.CurrentLayer(layer)\n\n    guid = rs.JoinMeshes(meshes, delete_input=True)\n\n    if layer:\n        rs.CurrentLayer(previous)\n\n    rs.ObjectName(guid, '{0}'.format(mesh.attributes['name']))\n\n    rs.EnableRedraw()\n    rs.Redraw()\n\n\n# ==============================================================================\n# selection\n# ==============================================================================\n\n\ndef select_mesh_vertices(mesh, message=\"Select mesh vertices.\"):\n    \"\"\"Select vertices of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        message (str): Optional. The message to display to the user.\n            Default is ``\"Select mesh vertices.\"``\n\n    Returns:\n        list: The keys of the selected vertices.\n\n    Note:\n        Selection is based on naming conventions.\n        When a mesh is drawn using the function :func:`draw_mesh`,\n        the point objects representing the vertices get assigned a name that\n        has the following pattern::\n\n            '{0}.vertex.{1}'.format(mesh.attributes['name'], key)\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino as rhino\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            keys = compas_rhino.select_mesh_vertices(mesh)\n\n            print(keys)\n\n\n    See Also:\n        * :func:`select_mesh_edges`\n        * :func:`select_mesh_faces`\n\n    \"\"\"\n    keys = []\n    guids = rs.GetObjects(message, preselect=True, filter=rs.filter.point | rs.filter.textdot)\n    if guids:\n        prefix = mesh.attributes['name']\n        seen = set()\n        for guid in guids:\n            name = rs.ObjectName(guid).split('.')\n            if 'vertex' in name:\n                if not prefix or prefix in name:\n                    key = name[-1]\n                    if not seen.add(key):\n                        key = ast.literal_eval(key)\n                        keys.append(key)\n    return keys\n\n\ndef select_mesh_vertex(mesh, message=\"Select a mesh vertex\"):\n    \"\"\"Select one vertex of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        message (str): Optional. The message to display to the user.\n            Default is ``\"Select mesh vertex.\"``\n\n    Returns:\n        * str: The key of the selected vertex.\n        * None: If no vertex was selected.\n\n    See Also:\n        * :func:`select_mesh_vertices`\n\n    \"\"\"\n    guid = rs.GetObject(message, preselect=True, filter=rs.filter.point | rs.filter.textdot)\n    if guid:\n        prefix = mesh.attributes['name']\n        name = rs.ObjectName(guid).split('.')\n        if 'vertex' in name:\n            if not prefix or prefix in name:\n                key = name[-1]\n                key = ast.literal_eval(key)\n                return key\n    return None\n\n\ndef select_mesh_edges(mesh, message=\"Select mesh edges\"):\n    \"\"\"Select edges of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        message (str): Optional. The message to display to the user.\n            Default is ``\"Select mesh edges.\"``\n\n    Returns:\n        list: The keys of the selected edges. Each key is a *uv* pair.\n\n    Note:\n        Selection is based on naming conventions.\n        When a mesh is drawn using the function :func:`draw_mesh`,\n        the curve objects representing the edges get assigned a name that\n        has the following pattern::\n\n            '{0}.edge.{1}-{2}'.format(mesh.attributes['name'], u, v)\n\n    See Also:\n        * :func:`select_mesh_vertices`\n        * :func:`select_mesh_faces`\n\n    \"\"\"\n    keys = []\n    guids = rs.GetObjects(message, preselect=True, filter=rs.filter.curve | rs.filter.textdot)\n    if guids:\n        prefix = mesh.attributes['name']\n        seen = set()\n        for guid in guids:\n            name = rs.ObjectName(guid).split('.')\n            if 'edge' in name:\n                if not prefix or prefix in name:\n                    key = name[-1]\n                    if not seen.add(key):\n                        u, v = key.split('-')\n                        u = ast.literal_eval(u)\n                        v = ast.literal_eval(v)\n                        keys.append((u, v))\n    return keys\n\n\ndef select_mesh_edge(mesh, message=\"Select a mesh edge\"):\n    \"\"\"Select one edge of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        message (str): Optional. The message to display to the user.\n            Default is ``\"Select mesh edges.\"``\n\n    Returns:\n        tuple: The key of the selected edge.\n        None: If no edge was selected.\n\n    See Also:\n        * :func:`select_mesh_edges`\n\n    \"\"\"\n    guid = rs.GetObject(message, preselect=True, filter=rs.filter.curve | rs.filter.textdot)\n    if guid:\n        prefix = mesh.attributes['name']\n        name = rs.ObjectName(guid).split('.')\n        if 'edge' in name:\n            if not prefix or prefix in name:\n                key = name[-1]\n                u, v = key.split('-')\n                u = ast.literal_eval(u)\n                v = ast.literal_eval(v)\n                return u, v\n    return None\n\n\ndef select_mesh_faces(mesh, message='Select mesh faces.'):\n    \"\"\"Select faces of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        message (str): Optional. The message to display to the user.\n            Default is ``\"Select mesh edges.\"``\n\n    Returns:\n        list: The keys of the selected faces.\n\n    Note:\n        Selection of faces is based on naming conventions.\n        When a mesh is drawn using the function :func:`draw_mesh`,\n        the curve objects representing the edges get assigned a name that\n        has the following pattern::\n\n            '{0}.edge.{1}-{2}'.format(mesh.attributes['name'], u, v)\n\n    Example:\n\n        .. code-block:: python\n            :emphasize-lines: 14\n\n            import compas\n            import compas_rhino as rhino as rhino\n\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            find_mesh_faces(mesh, mesh.leaves())\n\n            compas_rhino.draw_mesh(mesh)\n            compas_rhino.display_mesh_face_labels(mesh)\n\n            fkeys = compas_rhino.select_mesh_faces(mesh)\n\n            print(fkeys)\n\n\n    See Also:\n        * :func:`select_mesh_vertices`\n        * :func:`select_mesh_edges`\n\n    \"\"\"\n    keys = []\n    guids = rs.GetObjects(message, preselect=True, filter=rs.filter.textdot)\n    if guids:\n        prefix = mesh.attributes['name']\n        seen = set()\n        for guid in guids:\n            name = rs.ObjectName(guid).split('.')\n            if 'face' in name:\n                if not prefix or prefix in name:\n                    key = name[-1]\n                    if not seen.add(key):\n                        key = ast.literal_eval(key)\n                        keys.append(key)\n    return keys\n\n\ndef select_mesh_face(mesh, message='Select face.'):\n    \"\"\"Select one face of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        message (str): Optional. The message to display to the user.\n            Default is ``\"Select mesh edges.\"``\n\n    Returns:\n        tuple: The key of the selected face.\n        None: If no face was selected.\n\n    See Also:\n        * :func:`select_mesh_faces`\n\n    \"\"\"\n    guid = rs.GetObjects(message, preselect=True, filter=rs.filter.textdot)\n    if guid:\n        prefix = mesh.attributes['name']\n        name = rs.ObjectName(guid).split('.')\n        if 'face' in name:\n            if not prefix or prefix in name:\n                key = name[-1]\n                key = ast.literal_eval(key)\n                return key\n    return None\n\n\n# ==============================================================================\n# attributes\n# ==============================================================================\n\n\ndef update_mesh_attributes(mesh):\n    \"\"\"Update the attributes of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n\n    Returns:\n        bool: ``True`` if the update was successful, and ``False`` otherwise.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            if compas_rhino.update_mesh_attributes(mesh):\n                print('mesh attributes updated')\n            else:\n                print('mesh attributres not updated')\n\n\n    See Also:\n        * :func:`update_mesh_vertex_attributes`\n        * :func:`update_mesh_edge_attributes`\n        * :func:`update_mesh_face_attributes`\n\n    \"\"\"\n    names  = sorted(mesh.attributes.keys())\n    values = [str(mesh.attributes[name]) for name in names]\n    values = compas_rhino.update_named_values(names, values)\n    if values:\n        for name, value in zip(names, values):\n            try:\n                mesh.attributes[name] = ast.literal_eval(value)\n            except (TypeError, ValueError):\n                mesh.attributes[name] = value\n        return True\n    return False\n\n\ndef update_mesh_vertex_attributes(mesh, keys, names=None):\n    \"\"\"Update the attributes of the vertices of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        keys (tuple, list): The keys of the vertices to update.\n        names (tuple, list): Optional. The names of the atrtibutes to update.\n            Defaults to ``None``. If ``None``, all attributes are included in the\n            update.\n\n    Returns:\n        bool: ``True`` if the update was successful, and ``False`` otherwise.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino\n\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            keys = mesh.vertices()\n\n            if compas_rhino.update_mesh_vertex_attributes(mesh, keys):\n                print('mesh vertex attributes updated')\n            else:\n                print('mesh vertex attributes not updated')\n\n\n    See Also:\n        * :func:`update_mesh_attributes`\n        * :func:`update_mesh_edge_attributes`\n        * :func:`update_mesh_face_attributes`\n\n    \"\"\"\n    if not names:\n        names = mesh.default_vertex_attributes.keys()\n    names = sorted(names)\n    values = [mesh.vertex[keys[0]][name] for name in names]\n    if len(keys) > 1:\n        for i, name in enumerate(names):\n            for key in keys[1:]:\n                if values[i] != mesh.vertex[key][name]:\n                    values[i] = '-'\n                    break\n    values = map(str, values)\n    values = compas_rhino.update_named_values(names, values)\n    if values:\n        for name, value in zip(names, values):\n            if value != '-':\n                for key in keys:\n                    try:\n                        mesh.vertex[key][name] = ast.literal_eval(value)\n                    except (TypeError, ValueError):\n                        mesh.vertex[key][name] = value\n        return True\n    return False\n\n\ndef update_mesh_edge_attributes(mesh, keys, names=None):\n    \"\"\"Update the attributes of the edges of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        keys (tuple, list): The keys of the edges to update. Note that the keys\n            should be pairs of vertex keys.\n        names (tuple, list): Optional. The names of the atrtibutes to update.\n            Defaults to ``None``. If ``None``, all attributes are included in the\n            update.\n\n    Returns:\n        bool: ``True`` if the update was successful, and ``False`` otherwise.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino\n\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            keys = mesh.edges()\n\n            if compas_rhino.update_mesh_edge_attributes(mesh, keys):\n                print('mesh edge attributes updated')\n            else:\n                print('mesh edge attributes not updated')\n\n\n    See Also:\n        * :func:`update_mesh_attributes`\n        * :func:`update_mesh_vertex_attributes`\n        * :func:`update_mesh_face_attributes`\n\n    \"\"\"\n    if not names:\n        names = mesh.default_edge_attributes.keys()\n\n    names = sorted(names)\n\n    u, v = keys[0]\n    values = [mesh.edge[u][v][name] for name in names]\n\n    if len(keys) > 1:\n        for i, name in enumerate(names):\n            for u, v in keys[1:]:\n                if values[i] != mesh.edge[u][v][name]:\n                    values[i] = '-'\n                    break\n\n    values = map(str, values)\n    values = compas_rhino.update_named_values(names, values)\n\n    if values:\n        for name, value in zip(names, values):\n            if value != '-':\n                for u, v in keys:\n                    try:\n                        mesh.edge[u][v][name] = ast.literal_eval(value)\n                    except (TypeError, ValueError):\n                        mesh.edge[u][v][name] = value\n\n        return True\n\n    return False\n\n\ndef update_mesh_face_attributes(mesh, fkeys, names=None):\n    \"\"\"Update the attributes of the faces of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        keys (tuple, list): The keys of the faces to update.\n        names (tuple, list): Optional. The names of the atrtibutes to update.\n            Defaults to ``None``. If ``None``, all attributes are included in the\n            update.\n\n    Returns:\n        bool: ``True`` if the update was successful, and ``False`` otherwise.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino\n\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            keys = mesh.faces()\n\n            if compas_rhino.update_mesh_face_attributes(mesh, keys):\n                print('mesh face attributes updated')\n            else:\n                print('mesh face attributes not updated')\n\n\n    See Also:\n        * :func:`update_mesh_attributes`\n        * :func:`update_mesh_vertex_attributes`\n        * :func:`update_mesh_edge_attributes`\n\n    \"\"\"\n    if not mesh.facedata:\n        return\n    if not names:\n        names = sorted(mesh.default_face_attributes.keys())\n    values = [mesh.facedata[fkeys[0]][name] for name in names]\n    if len(fkeys) > 1:\n        for i, name in enumerate(names):\n            for fkey in fkeys[1:]:\n                if values[i] != mesh.facedata[fkey][name]:\n                    values[i] = '-'\n                    break\n    values = map(str, values)\n    values = compas_rhino.update_attributes(names, values)\n    if values:\n        for name, value in zip(names, values):\n            if value != '-':\n                for fkey in fkeys:\n                    try:\n                        mesh.facedata[fkey][name] = ast.literal_eval(value)\n                    except (TypeError, ValueError):\n                        mesh.facedata[fkey][name] = value\n        return True\n    return False\n\n\n# ==============================================================================\n# labels\n# ==============================================================================\n\n\ndef display_mesh_vertex_labels(mesh, attr_name=None, layer=None, color=None, formatter=None):\n    \"\"\"Display labels for the vertices of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        attr_name (str): Optional. The name of the attribute value to display in the label.\n            Default is ``None``. If ``None``, the key of the vertex is displayed.\n        layer (str): Optional. The layer to draw in. Default is ``None``.\n        color (str, tuple, list, dict): Optional. The color specification. Default is ``None``.\n            The following values are supported:\n\n                * str: A HEX color. For example, ``'#ff0000'``.\n                * tuple, list: RGB color. For example, ``(255, 0, 0)``.\n                * dict: A dictionary of RGB and/or HEX colors.\n\n            If ``None``, the default vertex color of the mesh will be used.\n        formatter (callable): Optional. A formatting function. Default is ``None``.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino\n\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            compas_rhino.display_mesh_vertex_labels(mesh)\n\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino\n\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            def formatter(value):\n                return '{0:.3f}'.format(value)\n\n            compas_rhino.display_mesh_vertex_labels(mesh, attr_name='x' formatter=formatter)\n\n\n    See Also:\n        * :func:`display_mesh_edge_labels`\n        * :func:`display_mesh_face_labels`\n\n    \"\"\"\n    compas_rhino.delete_objects(compas_rhino.get_objects(name=\"{0}.vertex.label.*\".format(mesh.attributes['name'])))\n\n    if not attr_name:\n        attr_name = 'key'\n\n    colordict = color_to_colordict(color,\n                                   mesh.vertices(),\n                                   default=mesh.attributes['color.vertex'],\n                                   colorformat='rgb',\n                                   normalize=False)\n    if formatter:\n        if not callable(formatter):\n            raise Exception('The provided formatter is not callable.')\n    else:\n        formatter = str\n\n    labels = []\n\n    for index, (key, attr) in enumerate(mesh.vertices(True)):\n        if 'key' == attr_name:\n            value = key\n        elif 'index' == attr_name:\n            value = index\n        else:\n            value = attr[attr_name]\n\n        labels.append({'pos'  : mesh.vertex_coordinates(key),\n                       'text' : formatter(value),\n                       'name' : '{0}.vertex.label.{1}'.format(mesh.attributes['name'], key),\n                       'color': colordict[key], })\n\n    compas_rhino.xdraw_labels(\n        labels,\n        layer=layer,\n        clear=False,\n        redraw=True\n    )\n\n\ndef display_mesh_edge_labels(mesh, attr_name=None, layer=None, color=None, formatter=None):\n    \"\"\"Display labels for the edges of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        attr_name (str): Optional. The name of the attribute value to display in the label.\n            Default is ``None``. If ``None``, the key of the edge is displayed.\n        layer (str): Optional. The layer to draw in. Default is ``None``.\n        color (str, tuple, list, dict): Optional. The color specification. Default is ``None``.\n            The following values are supported:\n\n                * str: A HEX color. For example, ``'#ff0000'``.\n                * tuple, list: RGB color. For example, ``(255, 0, 0)``.\n                * dict: A dictionary of RGB and/or HEX colors.\n\n            If ``None``, the default edge color of the mesh will be used.\n        formatter (callable): Optional. A formatting function. Default is ``None``.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino\n\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            compas_rhino.display_mesh_edge_labels(mesh)\n\n\n    See Also:\n        * :func:`display_mesh_vertex_labels`\n        * :func:`display_mesh_face_labels`\n\n    \"\"\"\n    compas_rhino.delete_objects(compas_rhino.get_objects(name=\"{0}.edge.label.*\".format(mesh.attributes['name'])))\n\n    if not attr_name:\n        attr_name = 'key'\n\n    colordict = color_to_colordict(color,\n                                   mesh.edges(),\n                                   default=mesh.attributes['color.edge'],\n                                   colorformat='rgb',\n                                   normalize=False)\n    if formatter:\n        if not callable(formatter):\n            raise Exception('The provided formatter is not callable.')\n    else:\n        formatter = str\n\n    labels = []\n\n    for index, (u, v, attr) in enumerate(mesh.edges(True)):\n\n        if attr_name == 'key':\n            value = '{0}-{1}'.format(u, v)\n        elif attr_name == 'index':\n            value = index\n        else:\n            value = attr[attr_name]\n\n        labels.append({'pos'  : mesh.edge_midpoint(u, v),\n                       'text' : formatter(value),\n                       'name' : '{0}.edge.label.{1}-{2}'.format(mesh.attributes['name'], u, v),\n                       'color': colordict[(u, v)], })\n\n    compas_rhino.xdraw_labels(\n        labels,\n        layer=layer,\n        clear=False,\n        redraw=True\n    )\n\n\ndef display_mesh_face_labels(mesh, attr_name=None, layer=None, color=None, formatter=None):\n    \"\"\"Display labels for the faces of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        attr_name (str): Optional. The name of the attribute value to display in the label.\n            Default is ``None``. If ``None``, the key of the face is displayed.\n        layer (str): Optional. The layer to draw in. Default is ``None``.\n        color (str, tuple, list, dict): Optional. The color specification. Default is ``None``.\n            The following values are supported:\n\n                * str: A HEX color. For example, ``'#ff0000'``.\n                * tuple, list: RGB color. For example, ``(255, 0, 0)``.\n                * dict: A dictionary of RGB and/or HEX colors.\n\n            If ``None``, the default face color of the mesh will be used.\n        formatter (callable): Optional. A formatting function. Default is ``None``.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino\n\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            compas_rhino.display_mesh_face_labels(mesh)\n\n\n    See Also:\n        * :func:`display_mesh_vertex_labels`\n        * :func:`display_mesh_edge_labels`\n\n    \"\"\"\n    compas_rhino.delete_objects(compas_rhino.get_objects(name=\"{0}.face.label.*\".format(mesh.attributes['name'])))\n\n    if not attr_name:\n        attr_name = 'key'\n\n    colordict = color_to_colordict(color,\n                                   mesh.faces(),\n                                   default=mesh.attributes['color.face'],\n                                   colorformat='rgb',\n                                   normalize=False)\n\n    if formatter:\n        if not callable(formatter):\n            raise Exception('The provided formatter is not callable.')\n    else:\n        formatter = str\n\n    labels = []\n\n    for index, fkey in enumerate(mesh.faces()):\n        if attr_name == 'key':\n            value = fkey\n        elif attr_name == 'index':\n            value = index\n        else:\n            value = mesh.facedata[fkey][attr_name]\n\n        labels.append({\n            'pos'  : mesh.face_centroid(fkey),\n            'text' : formatter(value),\n            'name' : '{0}.face.label.{1}'.format(mesh.attributes['name'], fkey),\n            'color': colordict[fkey]\n        })\n\n    compas_rhino.xdraw_labels(\n        labels,\n        layer=layer,\n        clear=False,\n        redraw=True\n    )\n\n\n# ==============================================================================\n# geometry\n# ==============================================================================\n\n\ndef display_mesh_vertex_normals(mesh,\n                                display=True,\n                                layer=None,\n                                scale=1.0,\n                                color=(0, 0, 255)):\n\n    guids = compas_rhino.get_objects(name='{0}.vertex.normal.*'.format(mesh.attributes['name']))\n    compas_rhino.delete_objects(guids)\n\n    if not display:\n        return\n\n    lines = []\n\n    for key in mesh.vertices():\n        normal = mesh.vertex_normal(key)\n        start  = mesh.vertex_coordinates(key)\n        end    = [start[axis] + normal[axis] for axis in range(3)]\n        name   = '{0}.vertex.normal.{1}'.format(mesh.attributes['name'], key)\n\n        lines.append({\n            'start': start,\n            'end'  : end,\n            'name' : name,\n            'color': color,\n            'arrow': 'end',\n        })\n\n    compas_rhino.xdraw_lines(lines, layer=layer, clear=False, redraw=True)\n\n\ndef display_mesh_face_normals(mesh,\n                              display=True,\n                              layer=None,\n                              scale=1.0,\n                              color=(0, 0, 255)):\n\n    guids = compas_rhino.get_objects(name='{0}.face.normal.*'.format(mesh.attributes['name']))\n    compas_rhino.delete_objects(guids)\n\n    if not display:\n        return\n\n    lines = []\n\n    for fkey in mesh.faces():\n        normal = mesh.face_normal(fkey)\n        start  = mesh.face_center(fkey)\n        end    = [start[axis] + normal[axis] for axis in range(3)]\n        name   = '{0}.face.normal.{1}'.format(mesh.attributes['name'], fkey)\n\n        lines.append({\n            'start' : start,\n            'end'   : end,\n            'name'  : name,\n            'color' : color,\n            'arrow' : 'end',\n        })\n\n    compas_rhino.xdraw_lines(lines, layer=layer, clear=False, redraw=True)\n\n\n# ==============================================================================\n# geometry\n# ==============================================================================\n\n\ndef move_mesh_vertex(mesh, key, constraint=None, allow_off=None, redraw=True):\n    \"\"\"Move on vertex of the mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Network): The mesh object.\n        key (str): The vertex to move.\n        constraint (Rhino.Geometry): Optional. A ``Rhino.Geometry`` object to\n            constrain the movement to. Default is ``None``.\n        allow_off (bool): Optional. Allow the vertex to move off the constraint.\n            Default is ``None``.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino\n\n            from compas.datastructures.mesh import Network\n\n            mesh = Mesh.from_obj(compas.get_data('lines.obj'))\n\n            key = compas_rhino.select_mesh_vertex(mesh)\n\n            if key:\n                compas_rhino.move_mesh_vertex(mesh, key)\n\n    \"\"\"\n    color = Rhino.ApplicationSettings.AppearanceSettings.FeedbackColor\n    nbrs  = [mesh.vertex_coordinates(nbr) for nbr in mesh.halfedge[key]]\n    nbrs  = [Point3d(*xyz) for xyz in nbrs]\n\n    def OnDynamicDraw(sender, e):\n        for ep in nbrs:\n            sp = e.CurrentPoint\n            e.Display.DrawDottedLine(sp, ep, color)\n\n    gp = Rhino.Input.Custom.GetPoint()\n    gp.SetCommandPrompt('Point to move to?')\n    gp.DynamicDraw += OnDynamicDraw\n\n    if constraint:\n        if allow_off is not None:\n            gp.Constrain(constraint, allow_off)\n        else:\n            gp.Constrain(constraint)\n\n    gp.Get()\n\n    if gp.CommandResult() == Rhino.Commands.Result.Success:\n        pos = list(gp.Point())\n        mesh.vertex[key]['x'] = pos[0]\n        mesh.vertex[key]['y'] = pos[1]\n        mesh.vertex[key]['z'] = pos[2]\n\n    if redraw:\n        try:\n            mesh.draw()\n        except AttributeError:\n            # this may result in the mesh being drawn in a different layer then before\n            draw_mesh(mesh)\n\n\n# ==============================================================================\n# Debugging\n# ==============================================================================\n\nif __name__ == \"__main__\":\n\n    pass\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "classes", "point", "layer", "brep", "line", "curve", "functions", "block", "mesh", "RhinoCommon"], "original_file": "dtbinh_T1_python-exercises_dd7f7a9ecd.json", "repo": "dtbinh/T1_python-exercises"}
{"instruction": "A Rhino display conduit for faces.", "code": "from __future__ import print_function\n\nfrom compas_rhino.conduits import Conduit\n\ntry:\n    from Rhino.Geometry import Point3d\n    from System.Drawing.Color import FromArgb\n    from System.Collections.Generic import List\n\nexcept ImportError:\n    import platform\n    if platform.python_implementation() == 'IronPython':\n        raise\n\n\n__author__     = 'Tom Van Mele'\n__copyright__  = 'Copyright 2014, BLOCK Research Group - ETH Zurich'\n__license__    = 'MIT License'\n__email__      = 'vanmelet@ethz.ch'\n\n\n__all__ = ['FacesConduit', ]\n\n\nclass FacesConduit(Conduit):\n    \"\"\"A Rhino display conduit for faces.\n\n    Parameters:\n        labels (list): A list of label tuples. Each tuple contains a position and text for the label.\n        color (tuple): Optional.\n            RGB color spec for the dots.\n            Default is ``None``.\n\n    Example:\n\n        .. code-block:: python\n\n            import time\n            from compas.geometry.elements import Polyhedron\n\n            polyhedron = Polyhedron.generate(6)\n\n            faces = polyhedron.faces\n            vertices = polyhedron.vertices\n\n            polygons = [[vertices[index] for index in face] for face in faces]\n\n            try:\n                conduit = FacesConduit(polygons)\n                conduit.enable()\n                conduit.redraw()\n                time.sleep(5.0)\n\n            except Exception as e:\n                print e\n\n            finally:\n                conduit.disable()\n                del conduit\n\n    \"\"\"\n    def __init__(self, faces, color=None, **kwargs):\n        super(FacesConduit, self).__init__(**kwargs)\n        self.faces = faces\n        color = color or (255, 0, 0)\n        self.color = FromArgb(*color)\n\n    def DrawForeground(self, e):\n        for points in self.faces:\n            points = [Point3d(*point) for point in points]\n            e.Display.DrawPolygon(points, self.color, True)\n\n\n# ==============================================================================\n# Debugging\n# ==============================================================================\n\nif __name__ == \"__main__\":\n\n    import time\n    from compas.geometry.elements import Polyhedron\n\n    polyhedron = Polyhedron.generate(6)\n\n    faces = polyhedron.faces\n    vertices = polyhedron.vertices\n\n    polygons = [[vertices[index] for index in face] for face in faces]\n\n    try:\n        conduit = FacesConduit(polygons)\n        conduit.enable()\n        conduit.redraw()\n        time.sleep(5.0)\n\n    except Exception as e:\n        print(e)\n\n    finally:\n        conduit.disable()\n        del conduit\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "functions", "block", "RhinoCommon"], "original_file": "dtbinh_T1_python-exercises_e004e8ed35.json", "repo": "dtbinh/T1_python-exercises"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "try:\n    from System.Collections.Generic import List\n\n    import Rhino\n    import rhinoscriptsyntax as rs\n    import scriptcontext as sc\n\n    from Rhino.Geometry import Point3d\n\n    find_object = sc.doc.Objects.Find\n\nexcept ImportError:\n    import platform\n    if platform.python_implementation() == 'IronPython':\n        raise\n\n\n__author__     = ['Tom Van Mele', ]\n__copyright__  = 'Copyright 2014, BLOCK Research Group - ETH Zurich'\n__license__    = 'MIT'\n__email__      = 'vanmelet@ethz.ch'\n\n\nclass RhinoMesh(object):\n    \"\"\"\"\"\"\n\n    def __init__(self, guid):\n        self.guid = guid\n        self.mesh = find_object(self.guid)\n        self.geometry = self.mesh.Geometry\n        self.attributes = self.mesh.Attributes\n        self.otype = self.geometry.ObjectType\n\n    def get_vertex_coordinates(self):\n        return [map(float, vertex) for vertex in rs.MeshVertices(self.guid)]\n\n    def get_face_vertices(self):\n        return map(list, rs.MeshFaceVertices(self.guid))\n\n    def get_vertex_colors(self):\n        return map(list, rs.MeshVertexColors(self.guid))\n\n    def set_vertex_colors(self, colors):\n        return rs.MeshVertexColors(self.guid, colors)\n\n    def unset_vertex_colors(self):\n        return rs.MeshVertexColors(self.guid, None)\n\n    def get_vertices_and_faces(self):\n        vertices = [map(float, vertex) for vertex in rs.MeshVertices(self.guid)]\n        faces = map(list, rs.MeshFaceVertices(self.guid))\n        return vertices, faces\n\n    def get_border(self):\n        return rs.DuplicateMeshBorder(self.guid)\n\n    def get_vertex_index(self):\n        guid = self.guid\n\n        class CustomGetObject(Rhino.Input.Custom.GetObject):\n            def CustomGeometryFilter(self, rhino_object, geometry, component_index):\n                # return True if selection is on current mesh object (guid)\n                return guid == rhino_object.Id\n\n        go = CustomGetObject()\n        go.SetCommandPrompt('Select a vertex of the mesh.')\n        go.GeometryFilter = Rhino.DocObjects.ObjectType.MeshVertex\n        go.AcceptNothing(True)\n        if go.Get() != Rhino.Input.GetResult.Object:\n            return None\n        objref = go.Object(0)\n        if not objref:\n            return None\n        tvindex = objref.GeometryComponentIndex.Index\n        mesh    = sc.doc.Objects.Find(guid)\n        temp    = mesh.Geometry.TopologyVertices.MeshVertexIndices(tvindex)\n        vindex  = temp[0]\n        go.Dispose()\n        return vindex\n\n    def get_face_index(self):\n        guid = self.guid\n\n        class CustomGetObject(Rhino.Input.Custom.GetObject):\n            def CustomGeometryFilter(self, rhino_object, geometry, component_index):\n                # return True if selecion is on current mesh object (guid)\n                return guid == rhino_object.Id\n\n        go = CustomGetObject()\n        go.SetCommandPrompt('Select a face of the mesh.')\n        go.GeometryFilter = Rhino.DocObjects.ObjectType.MeshFace\n        go.AcceptNothing(True)\n        if go.Get() != Rhino.Input.GetResult.Object:\n            return None\n        objref = go.Object(0)\n        if not objref:\n            return None\n        findex = objref.GeometryComponentIndex.Index\n        go.Dispose()\n        return findex\n\n    # def get_edge_index(guid):\n    #     class CustomGetObject(Rhino.Input.Custom.GetObject):\n    #         def CustomGeometryFilter(self, rhino_object, geometry, component_index):\n    #             return guid == rhino_object.Id\n    #     go = CustomGetObject()\n    #     go.SetCommandPrompt('Select an edge of the mesh.')\n    #     go.GeometryFilter = Rhino.DocObjects.ObjectType.MeshEdge\n    #     go.AcceptNothing(True)\n    #     if go.Get() != Rhino.Input.GetResult.Object:\n    #         return None\n    #     objref = go.Object(0)\n    #     if not objref:\n    #         return None\n    #     eindex = objref.GeometryComponentIndex.Index\n    #     go.Dispose()\n    #     return eindex\n    #\n    # def get_vertex_indices(guid):\n    #     tvindices = rs.GetMeshVertices(guid, 'Select mesh vertices.')\n    #     if not tvindices:\n    #         return\n    #     mobj = sc.doc.Objects.Find(guid)\n    #     mgeo = mobj.Geometry\n    #     vindices = []\n    #     for tvindex in tvindices:\n    #         temp = mgeo.TopologyVertices.MeshVertexIndices(tvindex)\n    #         vindices.append(temp[0])\n    #     return vindices\n    #\n    # def get_face_indices(guid):\n    #     return rs.GetMeshFaces(guid, 'Select mesh faces.')\n    #\n    # def get_vertex_face_indices(guid):\n    #     vindex = get_mesh_vertex_index(guid)\n    #     if vindex is None:\n    #         return\n    #     mobj = sc.doc.Objects.Find(guid)\n    #     mgeo = mobj.Geometry\n    #     findices = mgeo.TopologyVertices.ConnectedFaces(vindex)\n    #     return findices\n    #\n    # def get_face_vertex_indices(guid):\n    #     findex = get_mesh_face_index(guid)\n    #     if findex is None:\n    #         return\n    #     mobj = sc.doc.Objects.Find(guid)\n    #     mgeo = mobj.Geometry\n    #     tvertices = mgeo.Faces.GetTopologicalVertices(findex)\n    #     vindices = []\n    #     for tvertex in tvertices:\n    #         temp = mgeo.TopologyVertices.MeshVertexIndices(tvertex)\n    #         vindices.append(temp[0])\n    #     return vindices\n    #\n    # def get_edge_vertex_indices(guid):\n    #     eindex = get_mesh_edge_index(guid)\n    #     if eindex is None:\n    #         return\n    #     mobj = sc.doc.Objects.Find(guid)\n    #     mgeo = mobj.Geometry\n    #     temp = mgeo.TopologyEdges.GetTopologyVertices(eindex)\n    #     tvindices = temp.I, temp.J\n    #     vindices = []\n    #     for tvindex in tvindices:\n    #         temp = mgeo.TopologyVertices.MeshVertexIndices(tvindex)\n    #         vindices.append(temp[0])\n    #     return vindices\n\n    # ==========================================================================\n    # geometric stuff\n    # ==========================================================================\n\n    def normal(self, point):\n        pass\n\n    def normals(self, points):\n        pass\n\n    def closest_point(self, point, maxdist=None):\n        maxdist = maxdist or 0.0\n        face, point = self.geometry.ClosestPoint(Point3d(*point), maxdist)\n        return list(point)\n\n    def closest_points(self, points, maxdist=None):\n        # points = List[Point3d](len(points))\n        # points = self.geometry.PullPointsToMesh()\n        return [self.closest_point(point, maxdist) for point in points]\n\n\n# ==============================================================================\n# Debugging\n# ==============================================================================\n\nif __name__ == '__main__':\n\n    pass\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "classes", "point", "functions", "block", "mesh", "RhinoCommon"], "original_file": "dtbinh_T1_python-exercises_ec644983a6.json", "repo": "dtbinh/T1_python-exercises"}
{"instruction": "Implement the function 'faces' for Rhino scripting", "code": "import rhinoscriptsyntax as rs\nfrom collections import defaultdict\nfrom collections import Iterable\nimport Rhino\n\ndef faces():\n  surfaces = rs.GetObjects(\"select surfaces\", filter=rs.filter.surface)\n  \n  points = [rs.EvaluateSurface(surface, *rs.SurfaceParameter(surface, (0.5, 0.5))) for surface in surfaces]\n  x = reduce(lambda s, point: s+point.X, points, 0) / len(points)\n  y = reduce(lambda s, point: s+point.Y, points, 0) / len(points)\n  z = reduce(lambda s, point: s+point.Z, points, 0) / len(points)\n\n  # find the center of the object\n  mass_center = rs.AddPoint(x,y,z)\n\n  extrude_curves = {}\n  # find the appropriate extrusion curve with the lowest dot product\n  for surface in surfaces:\n    surface_center = rs.EvaluateSurface(surface, *rs.SurfaceParameter(surface, (0.5, 0.5)))\n    center_vector = rs.VectorCreate(surface_center, mass_center)\n\n    normals = []\n    normals.append(rs.SurfaceNormal(surface, rs.SurfaceParameter(surface, (0.5, 0.5))))\n    normals.append(-rs.SurfaceNormal(surface, rs.SurfaceParameter(surface, (0.5, 0.5))))\n\n    if (rs.VectorDotProduct(normals[0], center_vector) < rs.VectorDotProduct(normals[1], center_vector)):\n      extrude_curve = normals[0]\n    else:\n      extrude_curve = normals[1]\n    extrude_curve = rs.VectorUnitize(extrude_curve)\n    extrude_curve = rs.VectorScale(extrude_curve, 0.25)\n    extrude_curve = [surface_center, rs.VectorAdd(surface_center, extrude_curve)]\n    extrude_curve = rs.AddCurve(extrude_curve)\n    \n    rs.ExtrudeSurface(surface, extrude_curve)\n    rs.DeleteObject(extrude_curve)\n    rs.DeleteObject(surface)\n\n  rs.DeleteObject(mass_center)\n\n\n\n\n\n\n\n\nif __name__=='__main__':\n  faces()\n\n#\"\"\"\n## notes\n#- doesn't handle laser curf currently.  to do this, simple scale alternating\n#  cylinders along the intersection axis\n#\n#\"\"\"\n#\n## this dictionary maps a guid to the fingers\n## which will be booleansubtracted from it\n## in the final step\n#guid_to_difference = defaultdict(list)\n#\n#def perform_subtraction():\n#  # each time make_fingers is run, it fills guid_to_difference\n#  # with more fingers to subtract.\n#  # after all the fingers are subtracted at once\n#  for guid, objs in guid_to_difference.items():\n#    print guid, len(objs)\n#    rs.BooleanDifference(guid, objs)\n#\n#def make_fingers(positive, negative, subdivisions):\n#  \"\"\"\n#  intersect two collections of planes\n#  subdivide the intersections\n#  assign each subdivision to a guid from which it will be subtracted\n#  \"\"\"\n#\n#  # this vector is used to indicate axis of the intersection.\n#  # it needs to be parallel to the intersection\n#  # (there are other ways of doing this!)\n#  p0 = rs.GetPoint(\"select start of intersection\")\n#  p1 = rs.GetPoint(\"select end of intersection\")\n#\n#  edge = rs.AddLine(p0, p1)\n#  vector = rs.VectorCreate(p0, p1)\n#\n#  rs.EnableRedraw(False)\n#\n#  # this dict maps a pair of planes (ps, ns) to their booleanintersection\n#  intersections = {}\n#\n#  for ps in positive:\n#    for ns in negative:\n#      intersection = rs.BooleanIntersection(ps, ns, False)\n#      intersections[(ps, ns)] = intersection\n#\n#  # here we construct some very large cylinders aligned with the axis you drew\n#  origins = []\n#  cylinders = []\n#  for i in range(subdivisions+1):\n#    origin = rs.EvaluateCurve(edge, rs.CurveParameter(edge, i * 1.0/(subdivisions)))\n#    origins.append(origin)\n#\n#  rs.DeleteObject(edge)\n#\n#  for i in range(subdivisions):\n#    plane = rs.PlaneFromNormal(origins[i], vector)\n#    circle = rs.AddCircle(plane, 100)\n#    planar_circle = rs.AddPlanarSrf(circle)\n#\n#    extrusion_curve = rs.AddLine(origins[i], origins[i+1])\n#    cylinders.append(rs.ExtrudeSurface(planar_circle, extrusion_curve))\n#\n#    rs.DeleteObject(circle)\n#    rs.DeleteObject(planar_circle)\n#    rs.DeleteObject(extrusion_curve)\n#\n#\n#  # we perform a boolean intersection between each intersection and\n#  # the cylinders to construct the fingers\n#  for key, intersection in intersections.items():\n#    ps, ns = key\n#\n#    for i, cylinder in enumerate(cylinders):\n#      print \"intersection\", intersection\n#      print \"cylinder\", cylinder\n#      objs = [brep for brep in rs.BooleanIntersection(intersection, cylinder, False) if rs.IsBrep(brep)]\n#      # assign the resulting fingers to either the positive or negative\n#      if i % 2 == 0:\n#        guid_to_difference[ps].extend(objs)\n#      else:\n#        guid_to_difference[ns].extend(objs)\n#\n#  DeleteItemOrList(cylinders)\n#  DeleteItemOrList(intersections.values())\n#\n#  rs.EnableRedraw(True)\n#\n#def DeleteItemOrList(d):\n#  \"\"\"\n#  helper to delete a guid or a list of guids\n#  \"\"\"\n#  if isinstance(d, Iterable):\n#    for item in d: DeleteItemOrList(item)\n#  else:\n#    rs.DeleteObject(d)\n#\n#if __name__ == '__main__':\n#  main()\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "brep", "line", "curve", "functions"], "original_file": "egradman_rhinotools_16ccd4f076.json", "repo": "egradman/rhinotools"}
{"instruction": "Implement a function to find or add rhino layer", "code": "from pyrevit import script\nimport clr\n\n# Get logger and output from script\nLOGGER = script.get_logger()\nOUTPUT = script.get_output()\n\n# Add references to Rhino libraries\nclr.AddReference(\"RhinoCommon\")\nclr.AddReference(\"RhinoInside.Revit\")\nfrom Rhino import RhinoDoc, DocObjects\n\n# Function to find or add a layer in Rhino\ndef FindOrAddRhinoLayer(layerFullPath, rhinoDoc=None):\n    # Log the function call\n    LOGGER.debug(\n        \"FindOrAddRhinoLayer(layerFullPath={}, rhinoDoc={})\".format(\n            layerFullPath, rhinoDoc\n        )\n    )\n    # If no document is provided, use the active document\n    rhinoDoc = rhinoDoc or RhinoDoc.ActiveDoc\n    # Try to find the layer by its full path\n    layerIndex = rhinoDoc.Layers.FindByFullPath(layerFullPath, -1)\n    # If the layer is found, return its index\n    if not layerIndex < 0:\n        LOGGER.debug(\"Layer Found: layerIndex = {}\".format(layerIndex))\n        return layerIndex\n    # If the layer is not found, split the full path into individual layer names\n    layerNameSplit = layerFullPath.split(\"::\")\n    parentLayerId = None\n    # Iterate over the layer names\n    for i, layerName in enumerate(layerNameSplit):\n        # Construct the current path\n        currentPath = \"::\".join(layerNameSplit[0 : i + 1])\n        LOGGER.debug(\"currentPath = {}\".format(currentPath))\n        # Try to find the layer by the current path\n        layerIndex = rhinoDoc.Layers.FindByFullPath(currentPath, -1)\n        LOGGER.debug(\"parentLayerId = {}\".format(parentLayerId))\n        # If the layer is found, get its parent layer\n        if not layerIndex < 0:\n            LOGGER.debug(\"Matched: layerIndex = {}\".format(layerIndex))\n            parentLayer = rhinoDoc.Layers.FindIndex(layerIndex)\n            LOGGER.debug(\"type(parentLayer) = {}\".format(type(parentLayer)))\n            LOGGER.debug(\"parentLayer.Id = {}\".format(parentLayer.Id))\n            # Set the parent layer id for the next iteration\n            parentLayerId = parentLayer.Id\n            continue\n        # If the layer is not found, create a new layer\n        childLayer = DocObjects.Layer()\n        childLayer.Name = layerName\n        # If there is a parent layer, set its id as the parent layer id of the new layer\n        if parentLayerId:\n            childLayer.ParentLayerId = parentLayerId\n        # Add the new layer to the document\n        layerIndex = rhinoDoc.Layers.Add(childLayer)\n        # Get the new layer from the document\n        childLayer = rhinoDoc.Layers.FindIndex(layerIndex)\n        # Assert that the layer was added successfully\n        assert layerIndex >= 0\n        # Set the id of the new layer as the parent layer id for the next iteration\n        parentLayerId = childLayer.Id\n    # Return the index of the last layer added\n    return layerIndex", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["layer", "functions", "RhinoCommon"], "original_file": "gnomesoup_flamingo_lib_31357271d5.json", "repo": "gnomesoup/flamingo.lib"}
{"instruction": "tell application \"Terminal\"", "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport urllib2\n\nimport compas\nimport compas._os\nfrom ghpythonlib.componentbase import executingcomponent as component\nfrom scriptcontext import sticky as st\n\nfrom aixd_ara.constants import DEFAULT_PORT\n\ntry:\n    from subprocess import PIPE\n    from subprocess import Popen\nexcept ImportError:\n    from System.Diagnostics import Process\n\nimport os\n\nimport aixd_ara as ag\n\n\nclass ApiRunner(object):\n    def __init__(\n        self,\n        package=None,\n        python=None,\n        url=\"http://127.0.0.1\",\n        port=DEFAULT_PORT,\n        service=None,\n        max_conn_attempts=100,\n        autoreload=True,\n        show_window=False,\n        path=None,\n        working_directory=None,\n    ):\n        self.python = compas._os.select_python(python)\n        self.service = \"aixd_ara.api\"\n        self.working_directory = working_directory\n        self.show_window = show_window\n        self.port = port\n\n        self.start_process()\n\n    def start_process(self):\n        env = compas._os.prepare_environment()\n\n        try:\n            Popen\n        except NameError:\n            self._process = Process()\n            for name in env:\n                if self._process.StartInfo.EnvironmentVariables.ContainsKey(name):\n                    self._process.StartInfo.EnvironmentVariables[name] = env[name]\n                else:\n                    self._process.StartInfo.EnvironmentVariables.Add(name, env[name])\n            self._process.StartInfo.UseShellExecute = True\n            self._process.StartInfo.RedirectStandardOutput = not self.show_window\n            self._process.StartInfo.RedirectStandardError = not self.show_window\n            self._process.StartInfo.FileName = self.python\n            self._process.StartInfo.Arguments = \"-m {0} {1}\".format(self.service, self.port)\n            self._process.Start()\n        else:\n            args = [self.python, \"-m\", self.service, str(self.port)]\n            kwargs = dict(env=env)\n\n            if self.show_window:\n                if compas.is_mono():\n                    python_command = \" \".join(args)\n                    apple_script = \"\"\"\n                    tell application \"Terminal\"\n                        do script \"{}\"\n                        activate\n                    end tell\n                    \"\"\".format(\n                        python_command\n                    )\n                    args = [\"osascript\", \"-e\", apple_script]\n            else:\n                kwargs[\"stdout\"] = PIPE\n                kwargs[\"stderr\"] = PIPE\n\n            if self.working_directory:\n                kwargs[\"cwd\"] = self.working_directory\n            self._process = Popen(args, **kwargs)\n\n    def stop_process(self):\n        \"\"\"Attempts to terminate the python process hosting the proxy server.\n\n        The process reference might not be present, e.g. in the case\n        of reusing an existing connection. In that case, this is a no-op.\n        \"\"\"\n        print(\"Stopping the server process.\")\n\n        if not self._process:\n            return\n\n        try:\n            self._process.terminate()\n        except Exception:\n            pass\n        try:\n            self._process.kill()\n        except Exception:\n            pass\n\n\napi_path = os.path.dirname(ag.__file__)\n\nprint(api_path)\n\n\ndef create_api_runner_id(component):\n    name = \"api-runner\"\n    return \"{}_{}\".format(name, component.InstanceGuid)\n\n\nclass ApiRunnerComponent(component):\n\n    def RunScript(self, start, stop, show_window=True):\n        key = create_api_runner_id(self)\n        port = DEFAULT_PORT\n\n        if show_window:\n            python = \"python\"\n        else:\n            python = \"pythonw\"\n\n        if start:\n            self.stop(key)\n            runner = ApiRunner(python=python, port=port, show_window=show_window, working_directory=api_path)\n            st[key] = runner\n\n        if stop:\n            self.stop(key)\n\n    def stop(self, key):\n        # Attempt gracefully stopping the server\n        try:\n            urllib2.urlopen(\"http://127.0.0.1:8765/shutdown\", timeout=1)\n        except Exception:\n            pass\n\n        # stop previous API runner if any\n        previous_api_runner = st.get(key)\n        if previous_api_runner:\n            try:\n                previous_api_runner.stop_process()\n            except Exception as e:\n                print(\"Unable to stop previous process\")\n                print(e)\n            st.pop(key)\n        else:\n            print(\"No previous process runner found\")\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["classes", "functions"], "original_file": "gramaziokohler_aixd_ara_0cb9e9c17b.json", "repo": "gramaziokohler/aixd_ara"}
{"instruction": "Implement the function 'calc_processing_duration' for Rhino scripting", "code": "import os\nimport datetime\n\nfrom compas.geometry import Circle, Plane, Point, Vector\n\n##### ONLY if you need to bake the geometry in rhino\n# from compas_rhino import unload_modules\n# import rhino_specific\n\n# unload_modules(\"ddad_geometry\")\n# unload_modules(\"rhino_specific\")\n######\n\nfrom ddad.config import PROCESSED_DATA_PATH\nfrom ddad_geometry import surface_generator as sg\nfrom ddad_geometry.utilities import easing\nfrom ddad_geometry.export import export_panel_for_ml, export_panel_for_3dprint\nfrom ddad_geometry.constants import LF_WAVE_ATTRACTORS_01, LF_WAVE_ATTRACTORS_02, LF_WAVE_ATTRACTORS_03\n\nRHINO_LAYER = 'lf_wave_circles'\nTEST_OBJ_EXPORT_FOLDER = '/Users/axydis/PROJECTS/PhD/DDAD_data/test_obj'\nOBJ_EXPORT_FOLDER_ML = os.path.abspath(os.path.join(PROCESSED_DATA_PATH, '..', 'OBJ', 'ml'))\nOBJ_EXPORT_FOLDER_3DPRINT = os.path.abspath(os.path.join(PROCESSED_DATA_PATH, '..', 'OBJ', '3D_print'))\n\n\ndef calc_processing_duration(start, end):\n    duration = end - start\n    print(\"Processing time: \" + str(duration))\n\n\nprint(\"\")\nstart_time = datetime.datetime.utcnow()\n\n# Get the circlular attractors from Rhino\n# lf_wave_attractors = rhino_specific.get_circle_attractors(layer=RHINO_LAYER)\n\npanel_options = sg.PanelOptions(\n   panel_id=9107,\n   function=sg.dutch_bond,\n   parameters=dict(\n       lf_wave_attractors=LF_WAVE_ATTRACTORS_03,\n       dutch_bond_settings=dict(\n           b_length=21.5,\n           b_width=10.25,\n           b_height=6.5,\n           m_width=1.2,\n           m_height=1.2,\n           shift_distance=21.5 / 2\n       ),\n       top_side_extrusion_settings=dict(\n           function=sg.extrude_random_dutch_bond_2,\n           kwargs={\n               'max_extrusion_distance_front': 3.0,\n               'max_extrusion_distance_side': 5.0,\n               'random_seed': 2\n           }\n       ),\n       bottom_side_extrusion_settings=dict(\n           function=sg.extrude_random_dutch_bond_2,\n           kwargs={\n               'max_extrusion_distance_front': 3.0,\n               'max_extrusion_distance_side': 5.0,\n               'random_seed': 2\n           }\n       )\n   )\n)\n\n# serialise\n# panel_options.to_json()\n\nmesh = panel_options.get_panel()\n# ml_panel_side_0, ml_panel_side_1 = export_panel_for_ml(mesh, panel_options, OBJ_EXPORT_FOLDER_ML)\n# export_panel_for_3dprint(mesh, panel_options, OBJ_EXPORT_FOLDER_3DPRINT)\n\n\n# Draw the Mesh in Rhino\n# rhino_specific.bake_mesh_faces(mesh, 'Compas_MeshArtist:print', clear_layer=True, join_faces=True)\n# rhino_specific.bake_mesh_faces(ml_panel_side_0, 'Compas_MeshArtist::ml::side_0', clear_layer=False, join_faces=True)\n# rhino_specific.bake_mesh_faces(ml_panel_side_1, 'Compas_MeshArtist::ml::side_1', clear_layer=False, join_faces=True)\n\nend_time = datetime.datetime.utcnow()\ncalc_processing_duration(start_time, end_time)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["surface", "point", "layer", "functions", "mesh"], "original_file": "gramaziokohler_sdsc_data_driven_acoustic_design_b569c53176.json", "repo": "gramaziokohler/sdsc_data_driven_acoustic_design"}
{"instruction": "**********************************************************************************", "code": "import spatial_timber_assemblies.geometry_generation.helper_functions as hp\r\nimport compas.geometry.spatial as spatial\r\nimport Rhino.Geometry as rg\r\nimport scriptcontext\r\n\r\n__author__ = 'Arash Adel'\r\n__email__ = '<adel@arch.ethz.ch>'\r\n__copyright__ = 'Copyright 2017, Gramazio Kohler Research - ETH Zurich'\r\n\r\n\r\n\"\"\"\r\n**********************************************************************************\r\nIn this module, Beam Class and its Methods for the generation of the structural\r\nelements (horizontal, verticals and diagonal beams) are defined.\r\n**********************************************************************************\r\n\"\"\"\r\n\r\n\r\nclass Beam(object):\r\n\r\n    def __init__(self, beam_attr_dict):\r\n        '''\r\n        TODO: change all lists to tuples for better performance\r\n        The Beam class is initialized with an attribute dictionary.\r\n        attr_dict = {\"init_end_pts\": initial_end_pts, \"end_planes\": end_planes,\r\n        \"dim\": beam_dim = [thickness, height],\r\n        \"xAxis\":beam_x_axis,  \"yAxis\": beam_y_axis}\r\n        The Beam class is initialized with following inputs:\r\n        end_planes: list of two planes to define the short cuts of the beam.\r\n        dim: dimensions of the beam profile in y and z direction of the frame.\r\n\r\n        It has methods for generating the geometry of the beam.\r\n        It should keep track of the neighboring elements.\r\n        It should have the fabrication data associated with it\r\n        # direction of the deepest thickness (Rhino.Geometry.Vector3d)\r\n        self.orinetation   = Rhino.Geometry.Vector3d(_orinetation)\r\n        self.orientation: orientation of the beam (frame.zAxis without the z.val)\r\n        z value of self.orientation (orientation.Z) should be 0 for verticals/diagonals/chords or -1 for rafters\r\n        # Profile thickness in direction of z\r\n        self.height = _height\r\n        # Profile thickness in direction of y\r\n        self.width  = _width\r\n        Type of beam (0 = bottom chord, 1 = top chord, 2 = verticals and diagonals, 3 = wall rafter, 4= slab rafter)\r\n        '''\r\n        # setting beam attributes\r\n        self._set_beam_attributes(beam_attr_dict)\r\n        # weight of the beam in KG\r\n        self.weight = 0\r\n        # center of the mass for the beam\r\n        self.center_mass = None\r\n        # list of neighboring beams\r\n        self.neigbors = []  # TODO: include this information\r\n        # list of the beam necessary fabrication data\r\n        self.fab_data = []\r\n        # Suggested Gripping Plane(s)\r\n        self.gripping_planes = []\r\n        # TODO: include the following attribute for the beam\r\n        self.governing_neighbours = None\r\n        # each module has an interior center point to be used for defining\r\n        # beam in/ex vertices and other necessary info\r\n        # information after measuring the fabricated beam and define its tolerance\r\n        self.fabricated_tolerance = None\r\n        # structural bar instance key that gets filled after structural analysis\r\n        self.structure_bar_key = None\r\n        # Loads for structural analysis\r\n        self.loads = []\r\n        # Screw Information\r\n        # self.screws = (screws_bot, screws_top)\r\n        # screws_bot = ((screw_0_point, screw_0_vec), (screw_1_point, screw_1_vec),...)\r\n        self.screws = []\r\n        self.is_saw_blade_shifted = None  # If shifted, the vector of the shift is passed!\r\n        # TODO: Add milling info for the facade on the bottom and top cord\r\n        self.facade_milling_info = None\r\n        self.steel_plate_milling_info = None\r\n        self.high_tension_connection_milling_info = None\r\n        self.high_tension_connection_screws = None  # Two points (anchor point and end point)\r\n        self.high_tension_connection_screws_vertical_beam = None\r\n        # High Tension beam attribute\r\n        self.is_high_tension_beam = (False, None)\r\n        self.has_high_tension_screws = {\r\n            \"bot\": False, \"top\": False}\r\n        self.is_sharing_axis_point_with_other = (False, None)\r\n\r\n        # If a high-tension beam, set the attribute to True\r\n        # Note: need to run this after all the beams of the modules are generated\r\n        # from the building class\r\n\r\n    @classmethod\r\n    def from_side_edge(cls, beam_side_edge, offset_dir, beam_attr_dict):\r\n        \"\"\"\r\n        Initialize a beam instance from its edge as input (not axis).\r\n        \"\"\"\r\n\r\n        # Calculate the beam axis points.\r\n        z_axis = rg.Vector3d(beam_attr_dict.get(\"zAxis\"))\r\n        z_axis.Unitize()\r\n        axis_vec = beam_side_edge.UnitTangent\r\n        if rg.Vector3d.Multiply(offset_dir, z_axis) < 0:\r\n            z_axis.Reverse()\r\n            x_axis = rg.Vector3d.CrossProduct(axis_vec, z_axis)\r\n            x_axis.Reverse()\r\n        else:\r\n            x_axis = rg.Vector3d.CrossProduct(axis_vec, z_axis)\r\n\r\n        beam_dim = beam_attr_dict.get(\"dim\")\r\n        beam_thickness = beam_dim[0]\r\n        half_thickness = beam_thickness / 2.0\r\n        beam_height = beam_dim[1]\r\n        half_height = beam_height / 2.0\r\n        translation_vec_x = rg.Vector3d.Multiply(x_axis, half_thickness)\r\n        translation_vec_z = rg.Vector3d.Multiply(z_axis, half_height)\r\n        translation_vec = rg.Vector3d.Add(translation_vec_x, translation_vec_z)\r\n        # Find beam init axis sp (using the profile info)\r\n        beam_axis_sp = rg.Point3d.Add(beam_side_edge.From, translation_vec)\r\n\r\n        # Find beam init axis ep (use the edge info and add it to the beam init sp)\r\n        beam_axis_ep = rg.Point3d.Add(beam_side_edge.To, translation_vec)\r\n\r\n        init_axis_pts = [beam_axis_sp, beam_axis_ep]\r\n        beam_attr_dict[\"init_end_pts\"] = init_axis_pts\r\n        beam_attr_dict[\"ref_side_edge\"] = beam_side_edge\r\n        beam = cls(beam_attr_dict)\r\n        return beam\r\n\r\n    def _set_beam_attributes (self, beam_attr_dict):\r\n        \"\"\"\r\n        finds and sets the attributes for the beam.\r\n        \"\"\"\r\n        self.tolerance = scriptcontext.doc.ModelAbsoluteTolerance\r\n        self.attr_dict = {\"init_end_pts\": None, \"end_planes\": None,\r\n                          \"dim\": None, \"zAxis\": None, \"type\": None,\r\n                          \"parent_bar\": None, \"parent_building\": None,\r\n                          \"is_corner_vertical\": False, \"is_corner_diagonal\": False,\r\n                          \"corner_diagonal_aligned_edge\": None,\r\n                          \"is_opening_beam\": False,\r\n                          \"parent_floor\": None,\r\n                          \"parent_walls\": [], \"parent_slabs\": [],\r\n                          \"is_window_main_beam\": False,\r\n                          \"is_window_cross_beam\": False,\r\n                          \"parent_module\": None,\r\n                          \"ref_side_edge\": None, \"mesh\":None, \"beam_vertices\": None}\r\n\r\n        self.attr_dict.update(beam_attr_dict)\r\n        self.ref_side_edge = self.attr_dict[\"ref_side_edge\"]  # if initialized from side edge\r\n        self.is_window_main_beam = self.attr_dict.get(\"is_window_main_beam\")\r\n        self.is_window_cross_beam = self.attr_dict.get(\"is_window_cross_beam\")\r\n        self.initial_end_pts = self.attr_dict.get(\"init_end_pts\")\r\n        self.beam_vertices = self.attr_dict.get(\"beam_vertices\")\r\n        # TODO: make zAxis consistent for all beam and change it to beam.orientation\r\n        # TODO: get rid of zAxis\r\n        self.zAxis = rg.Vector3d(self.attr_dict.get(\"zAxis\"))\r\n        self.zAxis.Unitize()\r\n        self.type = self.attr_dict.get(\"type\")\r\n        if self.type == 0 or self.type == 1:\r\n            self.zAxis.Z = 0.0\r\n        self.parent_bar = self.attr_dict.get(\"parent_bar\")\r\n        self.parent_building = self.attr_dict.get(\"parent_building\")\r\n        self.parent_floor = self.attr_dict.get(\"parent_floor\")\r\n        self.parent_walls = self.attr_dict.get(\"parent_walls\")\r\n        self.parent_slabs = self.attr_dict.get(\"parent_slabs\")\r\n        self.end_planes = self.attr_dict.get(\"end_planes\")\r\n        self.dim = self.attr_dict.get(\"dim\")\r\n        self.thickness = self.dim[0]\r\n        self.half_thickness = self.thickness / 2.0\r\n        self.height = self.dim[1]\r\n        self.half_height = self.height / 2.0\r\n        self.is_corner_diagonal = self.attr_dict.get(\"is_corner_diagonal\")\r\n        self.corner_diagonal_aligned_edge = self.attr_dict.get(\"corner_diagonal_aligned_edge\")\r\n        self.is_corner_vertical = self.attr_dict.get(\"is_corner_vertical\")\r\n        self.parent_module = self.attr_dict.get(\"parent_module\")\r\n\r\n        # Generate the axis unit vector\r\n        self.axis_vec = self.gen_axis_unit_vec(self.initial_end_pts)\r\n        # List of the start and end point of bar axis\r\n        self.axis_end_points = self.gen_axis_end_points(self.end_planes)\r\n        # Regenerating the end planes\r\n        self.end_planes = self.re_gen_end_planes()\r\n        # Generating the beam frame\r\n        self.frame = self.gen_frame(self.axis_end_points)\r\n        # Generating beam vertices\r\n        beam_vertices_info = self.gen_beam_vertices(self.frame, self.axis_vec, self.end_planes)\r\n        self.vertices = beam_vertices_info[0]\r\n        self.vertices_tuple = beam_vertices_info[1]\r\n        # Generating beam faces and side planes\r\n        beam_faces_info = self.gen_beam_faces(self.vertices)\r\n        self.faces = beam_faces_info[0]\r\n        self.side_planes = beam_faces_info[1]\r\n        self.side_frames = beam_faces_info[2]\r\n        self.mesh=self.attr_dict.get(\"mesh\")\r\n        # Generating the beam geometry\r\n\r\n        # beam_vol_info = self.gen_beam_vol(self.faces, self.vertices, self.tolerance)\r\n        # self.polysurface = beam_vol_info[0]\r\n        # self.mesh = beam_vol_info[1]\r\n\r\n        # Replace zAxis with self.orientation\r\n        self.orientation = self.re_gen_beam_orientation(self.vertices)\r\n        # tuple of four long side edges of the beam\r\n        self.side_edges = self.gen_beam_side_edges(self.vertices)\r\n\r\n    def reset_attributes(self, new_beam_attr_dict):\r\n        \"\"\"\r\n        Reset the attribute of the beam.\r\n        new_beam_attr_dict = {\"init_end_pts\": initial_end_pts, \"end_planes\": end_planes,\r\n                  \"dim\": [80.0,120.0], \"zAxis\": z_axis}\r\n        \"init_end_pts\": List of start and end point of the beam axis\r\n        \"end_planes\": List of the start and end cut planes of the beam\r\n        \"dim\": beam_dim = [thickness, height]\r\n        \"zAxis\": rg vector\r\n        \"\"\"\r\n        self.attr_dict.update(new_beam_attr_dict)\r\n        self.initial_end_pts = self.attr_dict.get(\"init_end_pts\")\r\n        self.zAxis = rg.Vector3d(self.attr_dict.get(\"zAxis\"))\r\n        self.zAxis.Unitize()\r\n        if self.type == 0 or self.type == 1:\r\n            self.zAxis.Z = 0.0\r\n        self.end_planes = self.attr_dict.get(\"end_planes\")\r\n        self.dim = self.attr_dict.get(\"dim\")\r\n        self.thickness = self.dim[0]\r\n        self.half_thickness = self.thickness / 2.0\r\n        self.height = self.dim[1]\r\n        self.half_height = self.height / 2.0\r\n\r\n        # Generate the axis unit vector\r\n        self.axis_vec = self.gen_axis_unit_vec(self.initial_end_pts)\r\n        # List of the start and end point of bar axis\r\n        self.axis_end_points = self.gen_axis_end_points(self.end_planes)\r\n        # Regenerating the end planes\r\n        self.end_planes = self.re_gen_end_planes()\r\n        # Generating the beam frame\r\n        self.frame = self.gen_frame(self.axis_end_points)\r\n        # Generating beam vertices\r\n        beam_vertices_info = self.gen_beam_vertices(self.frame, self.axis_vec, self.end_planes)\r\n        self.vertices = beam_vertices_info[0]\r\n        self.vertices_tuple = beam_vertices_info[1]\r\n        # Generating beam faces and side planes\r\n        beam_faces_info = self.gen_beam_faces(self.vertices)\r\n        self.faces = beam_faces_info[0]\r\n        self.side_planes = beam_faces_info[1]\r\n        self.side_frames = beam_faces_info[2]\r\n        # Generating the beam geometry\r\n        beam_vol_info = self.gen_beam_vol(self.faces, self.vertices, self.tolerance)\r\n        self.polysurface = beam_vol_info[0]\r\n        self.mesh = beam_vol_info[1]\r\n        self.orientation = self.re_gen_beam_orientation(self.vertices)\r\n        # tuple of four long side edges of the beam\r\n        self.side_edges = self.gen_beam_side_edges(self.vertices)\r\n\r\n    def get_attribute(self, beam_attr):\r\n        \"\"\"\r\n        Return a specific beam attribute.\r\n        TODO: double check that this function is properly written.\r\n        \"\"\"\r\n        try:\r\n            return self.__dict__[beam_attr]\r\n        except KeyError:\r\n            print \"beam does not have the input attribute!\"\r\n            # return None\r\n\r\n    def get_corner_vertical_neighbor_diagonals(self):\r\n        \"\"\"\r\n        Check if the beam is a corner diagonal and return its attached diagonals.\r\n        \"\"\"\r\n        pass\r\n\r\n    # -----------------------------------------------------------------------\r\n    # Methods to update beam attributes\r\n    # -----------------------------------------------------------------------\r\n\r\n    def set_structure_bar_key(self, new_structure_bar_key):\r\n        \"\"\"\r\n        Sets a new structure bar key for the beam.\r\n        \"\"\"\r\n        self.structure_bar_key = new_structure_bar_key\r\n\r\n    # -----------------------------------------------------------------------\r\n    # Methods to generate beam geometry data\r\n    # -----------------------------------------------------------------------\r\n\r\n    def gen_axis_unit_vec(self, initial_end_pts):\r\n        \"\"\"\r\n        Generates the unit axis vector of the beam.\r\n        \"\"\"\r\n        return hp.create_line_unit_vec(initial_end_pts[0], initial_end_pts[1])\r\n\r\n    def gen_axis_end_points(self, end_planes):\r\n        \"\"\"\r\n        Generate the list of start and end point of bar axis.\r\n        This is used for structural calculations.\r\n        change to rg point3d\r\n        TODO: calculate initi_mid_pt with rg\r\n        \"\"\"\r\n        init_mid_pt_xyz = spatial.midpoint_line(self.initial_end_pts[0], self.initial_end_pts[1])\r\n        init_mid_pt = rg.Point3d(init_mid_pt_xyz[0], init_mid_pt_xyz[1], init_mid_pt_xyz[2])\r\n        infin_axis_line = hp.infinite_line(init_mid_pt, self.axis_vec)\r\n        axis_st_pt = hp.intersect_line_plane(infin_axis_line, end_planes[0])\r\n        axis_en_pt = hp.intersect_line_plane(infin_axis_line, end_planes[1])\r\n        return (axis_st_pt, axis_en_pt)\r\n\r\n    def re_gen_end_planes(self):\r\n        \"\"\"\r\n        Regenerates the beam cut_planes at the axis end points.\r\n        \"\"\"\r\n        end_plane_0 = rg.Plane(self.axis_end_points[0], self.end_planes[0].XAxis, self.end_planes[0].YAxis)\r\n        end_plane_1 = rg.Plane(self.axis_end_points[1], self.end_planes[1].XAxis, self.end_planes[1].YAxis)\r\n        return (end_plane_0, end_plane_1)\r\n\r\n    def gen_frame(self, axis_end_points):\r\n        \"\"\"\r\n        Generates and sets the frame for the beam on the middle of axis line.\r\n        TODO: maybe better to have frame_zAxis and xaxis as inputs (double check)\r\n        \"\"\"\r\n        axis_mid_point = rg.Point3d((axis_end_points[0] + axis_end_points[1]) / 2.0)\r\n        frame_zAxis = self.zAxis\r\n        xaxis = self.axis_vec\r\n        yaxis = rg.Vector3d.CrossProduct(frame_zAxis, xaxis)\r\n        return rg.Plane(axis_mid_point, xaxis, yaxis)\r\n\r\n    def gen_rect_corners(self, beam_frame):\r\n        \"\"\"\r\n        Returns corners of a rectangle on the frame plane of the beam\r\n        rectangle width = beam thickness\r\n        rectangle length = beam height\r\n        Output: list of four corners\r\n                pt_3----------pt_0\r\n                    |        |\r\n                    |        |\r\n                    |   cp   |\r\n                    |        |\r\n                    |        |\r\n                pt_2----------pt_1\r\n        \"\"\"\r\n        cen_pt = beam_frame.Origin\r\n        translation_vec_y = rg.Vector3d.Multiply(beam_frame.YAxis, self.half_thickness)\r\n        translation_vec_z = rg.Vector3d.Multiply(beam_frame.ZAxis, self.half_height)\r\n        translation_vec_1 = rg.Vector3d.Add(translation_vec_y, translation_vec_z)\r\n        translation_vec_2 = rg.Vector3d.Add(translation_vec_y, rg.Vector3d.Negate(translation_vec_z))\r\n        translation_vec_3 = rg.Vector3d.Add(rg.Vector3d.Negate(translation_vec_y), rg.Vector3d.Negate(translation_vec_z))\r\n        translation_vec_4 = rg.Vector3d.Add(rg.Vector3d.Negate(translation_vec_y), translation_vec_z)\r\n        corner_0 = rg.Point3d.Add(cen_pt, translation_vec_1)\r\n        corner_1 = rg.Point3d.Add(cen_pt, translation_vec_2)\r\n        corner_2 = rg.Point3d.Add(cen_pt, translation_vec_3)\r\n        corner_3 = rg.Point3d.Add(cen_pt, translation_vec_4)\r\n        corners = [corner_0, corner_1, corner_2, corner_3]\r\n        return corners\r\n\r\n    def gen_beam_vertices(self, beam_frame, beam_axis_vec, beam_end_planes):\r\n        \"\"\"\r\n        Returns points of the structural element volume\r\n        \"\"\"\r\n        vertices_bot = []\r\n        vertices_bot_tuple = []\r\n        vertices_top_tuple = []\r\n        vertices_top = []\r\n        profile_corners = self.gen_rect_corners(beam_frame)\r\n        for corner in profile_corners:\r\n            infin_line = hp.infinite_line(corner, beam_axis_vec)\r\n            sp_ep_line = hp.intersect_line_planes(infin_line, beam_end_planes)\r\n            vertex_bot = sp_ep_line.From\r\n            vertex_top = sp_ep_line.To\r\n            vertices_bot.append(vertex_bot)\r\n            vertices_top.append(vertex_top)\r\n            vertices_bot_tuple.append((vertex_bot.X, vertex_bot.Y, vertex_bot.Z))\r\n            vertices_top_tuple.append((vertex_top.X, vertex_top.Y, vertex_top.Z))\r\n        vertices_bot = tuple(vertices_bot)\r\n        vertices_top = tuple(vertices_top)\r\n        vertices_bot_tuple = tuple(vertices_bot_tuple)\r\n        vertices_top_tuple = tuple(vertices_top_tuple)\r\n        return (vertices_bot, vertices_top), (vertices_bot_tuple, vertices_top_tuple)\r\n\r\n    def gen_beam_faces(self, beam_vertices):\r\n        \"\"\"\r\n        Generates the faces of the beam out of two sets of 4 points (8 vertices)\r\n        Inputs: 2 lists of points (4 each) for the bottom and top face\r\n        pts_bot: list of four corner points for the bottom face\r\n        pts_top: list of four points for the top face\r\n        self.faces = a list of the six breps of the beam volume\r\n        \"\"\"\r\n        faces = []\r\n        side_frames = []  # list of six frames (one on each beam face) facing outwards\r\n        # vertices_bot = beam_vertices[0:4]\r\n        vertices_bot = beam_vertices[0]\r\n        # vertices_top = beam_vertices[4:]\r\n        vertices_top = beam_vertices[1]\r\n        prof_bot_pts = [vertices_bot[0], vertices_bot[1], vertices_bot[2], vertices_bot[3]]\r\n        bot_frame = rg.Plane(vertices_bot[0], vertices_bot[3], vertices_bot[1])\r\n        prof_top_pts = [vertices_top[0], vertices_top[1], vertices_top[2], vertices_top[3]]\r\n        top_frame = rg.Plane(vertices_top[0], vertices_top[1], vertices_top[3])\r\n        prof_sd_01_pts = [vertices_bot[0], vertices_top[0], vertices_top[1], vertices_bot[1]]\r\n        plane_sd_01 = rg.Plane(vertices_bot[0], vertices_bot[1], vertices_top[0])\r\n        prof_sd_02_pts = [vertices_bot[1], vertices_top[1], vertices_top[2], vertices_bot[2]]\r\n        plane_sd_02 = rg.Plane(vertices_bot[1], vertices_bot[2], vertices_top[1])\r\n        prof_sd_03_pts = [vertices_bot[2], vertices_top[2], vertices_top[3], vertices_bot[3]]\r\n        plane_sd_03 = rg.Plane(vertices_bot[2], vertices_bot[3], vertices_top[2])\r\n        prof_sd_04_pts = [vertices_bot[3], vertices_top[3], vertices_top[0], vertices_bot[0]]\r\n        plane_sd_04 = rg.Plane(vertices_bot[3], vertices_bot[0], vertices_top[3])\r\n        profiles_pts = [prof_bot_pts, prof_top_pts, prof_sd_01_pts, prof_sd_02_pts, prof_sd_03_pts, prof_sd_04_pts]\r\n        side_frames = [bot_frame, top_frame, plane_sd_01, plane_sd_02, plane_sd_03, plane_sd_04]\r\n        # drawing faces and add them to the list of faces\r\n        for profile_pts in profiles_pts:\r\n            beam_face = rg.Brep.CreateFromCornerPoints(\r\n                profile_pts[0], profile_pts[1], profile_pts[2], profile_pts[3], 0)\r\n            faces.append(beam_face)\r\n\r\n        faces = tuple(faces)\r\n        return faces, (plane_sd_01, plane_sd_02, plane_sd_03, plane_sd_04), side_frames\r\n\r\n    def gen_beam_side_edges(self, beam_vertices):\r\n        \"\"\"\r\n        Generates the four side long edges of the beam geometry out of two sets of 4 points (8 vertices)\r\n        Inputs: 2 lists of points (4 each) for the bottom and top face\r\n        pts_bot: list of four corner points for the bottom face\r\n        pts_top: list of four points for the top face\r\n        \"\"\"\r\n        side_edges = []\r\n\r\n        vertices_bot = beam_vertices[0]\r\n        vertices_top = beam_vertices[1]\r\n        for bot_index, bot_vert in enumerate(vertices_bot):\r\n            top_vert = vertices_top[bot_index]\r\n            edge_line = rg.Line(bot_vert, top_vert)\r\n            side_edges.append(edge_line)\r\n        side_edges = tuple(side_edges)\r\n        return side_edges\r\n\r\n    def re_gen_beam_orientation(self, beam_vertices):\r\n        \"\"\"\r\n        Regenerates the orientation unit vector of the beam.\r\n        orientation_vec.z = 0.0\r\n        \"\"\"\r\n        bot_vertices = beam_vertices[0]\r\n        line_0 = rg.Line(bot_vertices[0], bot_vertices[3])\r\n        line_1 = rg.Line(bot_vertices[1], bot_vertices[2])\r\n        sp = line_0.PointAt(0.50)\r\n        ep = line_1.PointAt(0.50)\r\n        orientation_vec = rg.Vector3d(ep - sp)\r\n        orientation_vec.Unitize()\r\n        return orientation_vec\r\n\r\n    # -----------------------------------------------------------------------\r\n    # Methods to add screws information to the beam\r\n    # -----------------------------------------------------------------------\r\n    def check_is_beam_high_tension(self):\r\n        \"\"\"\r\n        Checks if the beam is a high tension beam and\r\n        add necessary information.\r\n        NOTE: this method is called in the building class after\r\n        all beams are generated.\r\n        \"\"\"\r\n        is_high_tension_bar = self.parent_building.get_bar_attribute(\r\n            self.parent_bar, \"is_high_tension_bar\")\r\n        if is_high_tension_bar[0] == False:\r\n            self.is_high_tension_beam = (False, None)\r\n        else:\r\n            bot_top_neigh_bar_dict = is_high_tension_bar[1]\r\n            bot_neighbor_bar = bot_top_neigh_bar_dict[\"bot_neighbor\"]\r\n            top_neighbor_bar = bot_top_neigh_bar_dict[\"top_neighbor\"]\r\n            # print \"beam bar: \", self.parent_bar\r\n            # print bot_neighbor_bar, top_neighbor_bar\r\n            if bot_neighbor_bar is not None:\r\n                bot_neighbor_beam = self.parent_building._find_bar_beam_in_module(\r\n                    bot_neighbor_bar, self.parent_module, 2)\r\n            else:\r\n                bot_neighbor_beam = None\r\n            if top_neighbor_bar is not None:\r\n                top_neighbor_beam = self.parent_building._find_bar_beam_in_module(\r\n                    top_neighbor_bar, self.parent_module, 2)\r\n            else:\r\n                top_neighbor_beam = None\r\n            bot_top_neigh_dict = {\r\n                \"bot_neighbor\": bot_neighbor_beam,\r\n                \"top_neighbor\": top_neighbor_beam}\r\n            # Add has_high_tension_screws attr to neighbor beams\r\n            if bot_neighbor_beam is not None:\r\n                bot_neighbor_beam.has_high_tension_screws[\"bot\"] = True\r\n            if top_neighbor_beam is not None:\r\n                top_neighbor_beam.has_high_tension_screws[\"top\"] = True\r\n            self.is_high_tension_beam = (True, bot_top_neigh_dict)\r\n            # Add has_high_tension_screws attr to beam\r\n            self.has_high_tension_screws = {\r\n                \"bot\": True, \"top\": True}\r\n\r\n    def add_screws_information(self, screws_information):\r\n        \"\"\"\r\n        Adds the screws information to the beam class.\r\n        Screws information are generated after the FEM analysis is performed, in\r\n        the analysis package.\r\n        # self.screws = (screws_bot, screws_top)\r\n        # screws_bot = ((screw_0_point, screw_0_vec), (screw_1_point, screw_1_vec),...)\r\n        # screws_top = ((screw_0_point, screw_0_vec), (screw_1_point, screw_1_vec),...)\r\n        \"\"\"\r\n        # TODO: define bottom and top screws\r\n        self.screws = screws_information\r\n\r\n    def add_screw_to_beam_screws(self, new_screw_information, screw_side=\"bottom\"):\r\n        \"\"\"\r\n        Adds the screws information to the beam class. This function used\r\n        for the screws at the either end of the beam.\r\n        Screws information are generated after the FEM analysis is performed, in\r\n        the analysis package.\r\n        # self.screws = (screws_bot, screws_top)\r\n        # screws_bot = ((screw_0_point, screw_0_vec), (screw_1_point, screw_1_vec),...)\r\n        # screws_top = ((screw_0_point, screw_0_vec), (screw_1_point, screw_1_vec),...)\r\n        \"\"\"\r\n        # TODO: define bottom and top screws\r\n        beam_screws = self.screws[:]\r\n        if beam_screws == []:\r\n            beam_screws = [[], []]\r\n        if screw_side == \"bottom\":\r\n            beam_screws[0].append(new_screw_information)\r\n        elif screw_side == \"top\":\r\n            beam_screws[1].append(new_screw_information)\r\n        else:\r\n            raise Exception(\"Side is not defined correctly!\")\r\n\r\n        self.screws = beam_screws\r\n\r\n    def add_screw_to_horizontal_beam_screws(self, new_screw_information):\r\n        \"\"\"\r\n        Adds the screws information to the beam class, this function is not used for\r\n        the screws that are at the either end of the beam.\r\n        Screws information are generated after the FEM analysis is performed, in\r\n        the analysis package.\r\n        # self.screws = (screws_bot, screws_top)\r\n        # screws[0] = screws_bot = ((screw_0_point, screw_0_vec), (screw_1_point, screw_1_vec),...)\r\n        # screws[1] = screws_top = ((screw_0_point, screw_0_vec), (screw_1_point, screw_1_vec),...)\r\n        # screws[2] = all the screws that belong to the cross bar and are a result of the main bars.\r\n        \"\"\"\r\n        beam_screws = self.screws[:]\r\n        if beam_screws == []:\r\n            beam_screws = [[], [], []]\r\n        elif len(beam_screws) == 2:\r\n            beam_screws.append([])\r\n        beam_screws[2].append(new_screw_information)\r\n        self.screws = beam_screws\r\n\r\n    # -----------------------------------------------------------------------\r\n    # Methods to work with fabrication tolerances and sensors data\r\n    # -----------------------------------------------------------------------\r\n\r\n    def get_outside_vertices(self):\r\n        \"\"\"\r\n        Returns four vertices of the beam that face outside of the parent module.\r\n        output:\r\n        a list of four vertices [bot_left, bot_right, top_left, top_right]\r\n\r\n        TODO: for interior beams there needs to be a logic based on\r\n              maybe where the structure is exposed!\r\n        \"\"\"\r\n        raise(\"Not implemented!\")\r\n\r\n    def get_inside_vertices(self):\r\n        \"\"\"\r\n        Returns four vertices of the beam that face inside of the parent module.\r\n        output:\r\n        a list of four vertices [bot_left, bot_right, top_left, top_right]\r\n\r\n        TODO: for interior beams there needs to be a logic based on\r\n              maybe where the structure is exposed!\r\n        \"\"\"\r\n        raise(\"Not implemented!\")\r\n\r\n    def is_fabricated(self):\r\n        \"\"\"\r\n        Returns True if beam is fabricated (check the self.fabricated_tolerance).\r\n        \"\"\"\r\n        if self.fabricated_tolerance is None:\r\n            return False\r\n        else:\r\n            return True\r\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "classes", "point", "brep", "line", "dimension", "functions", "mesh", "RhinoCommon"], "original_file": "gramaziokohler_tolerance_analysis_9b513a3c3c.json", "repo": "gramaziokohler/tolerance_analysis"}
{"instruction": "Represents a base class that is common to most RhinoCommon curve types.", "code": "class Curve(GeometryBase,IDisposable,ISerializable):\r\n \"\"\"\r\n Represents a base class that is common to most RhinoCommon curve types.\r\n\r\n    A curve represents an entity that can be all visited by providing\r\n\r\n    a single parameter,usually called t.\r\n \"\"\"\r\n def ChangeClosedCurveSeam(self,t):\r\n  \"\"\"\r\n  ChangeClosedCurveSeam(self: Curve,t: float) -> bool\r\n\r\n  \r\n\r\n   If this curve is closed,then modify it so that the start/end point is at curve parameter t.\r\n\r\n  \r\n\r\n   t: Curve parameter of new start/end point. The returned curves domain will start at t.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def ChangeDimension(self,desiredDimension):\r\n  \"\"\"\r\n  ChangeDimension(self: Curve,desiredDimension: int) -> bool\r\n\r\n  \r\n\r\n   Changes the dimension of a curve.\r\n\r\n  \r\n\r\n   desiredDimension: The desired dimension.\r\n\r\n   Returns: true if the curve's dimension was already desiredDimension\r\n\r\n     or if the curve's \r\n\r\n    dimension was successfully changed to desiredDimension;\r\n\r\n     otherwise false.\r\n  \"\"\"\r\n  pass\r\n def ClosedCurveOrientation(self,*__args):\r\n  \"\"\"\r\n  ClosedCurveOrientation(self: Curve,xform: Transform) -> CurveOrientation\r\n\r\n  \r\n\r\n   Determines the orientation (counterclockwise or clockwise) of a closed planar curve.\r\n\r\n       \r\n\r\n     Only works with simple (no self intersections) closed planar curves.\r\n\r\n  \r\n\r\n  \r\n\r\n   xform: Transformation to map the curve to the xy plane. If the curve is parallel\r\n\r\n     to the xy \r\n\r\n    plane,you may pass Identity matrix.\r\n\r\n  \r\n\r\n   Returns: The orientation of this curve in the world xy-plane.\r\n\r\n  ClosedCurveOrientation(self: Curve,plane: Plane) -> CurveOrientation\r\n\r\n  \r\n\r\n   Determines the orientation (counterclockwise or clockwise) of a closed planar curve in a given \r\n\r\n    plane.\r\n\r\n     Only works with simple (no self intersections) closed planar curves.\r\n\r\n  \r\n\r\n  \r\n\r\n   plane: The plane in which to solve the orientation.\r\n\r\n   Returns: The orientation of this curve in the given plane.\r\n\r\n  ClosedCurveOrientation(self: Curve,upDirection: Vector3d) -> CurveOrientation\r\n\r\n  \r\n\r\n   Determines the orientation (counterclockwise or clockwise) of a closed planar curve in a given \r\n\r\n    plane.\r\n\r\n     Only works with simple (no self intersections) closed planar curves.\r\n\r\n  \r\n\r\n  \r\n\r\n   upDirection: A vector that is considered \"up\".\r\n\r\n   Returns: The orientation of this curve with respect to a defined up direction.\r\n  \"\"\"\r\n  pass\r\n def ClosestPoint(self,testPoint,t,maximumDistance=None):\r\n  \"\"\"\r\n  ClosestPoint(self: Curve,testPoint: Point3d,maximumDistance: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Finds the parameter of the point on a curve that is closest to testPoint.\r\n\r\n     If the \r\n\r\n    maximumDistance parameter is > 0,then only points whose distance\r\n\r\n     to the given \r\n\r\n    point is <= maximumDistance will be returned.  Using a \r\n\r\n     positive value of \r\n\r\n    maximumDistance can substantially speed up the search.\r\n\r\n  \r\n\r\n  \r\n\r\n   testPoint: Point to project.\r\n\r\n   maximumDistance: The maximum allowed distance.\r\n\r\n     Past this distance,the search is given up and false \r\n\r\n    is returned.Use 0 to turn off this parameter.\r\n\r\n  \r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  ClosestPoint(self: Curve,testPoint: Point3d) -> (bool,float)\r\n\r\n  \r\n\r\n   Finds parameter of the point on a curve that is closest to testPoint.\r\n\r\n     If the \r\n\r\n    maximumDistance parameter is > 0,then only points whose distance\r\n\r\n     to the given \r\n\r\n    point is <= maximumDistance will be returned.  Using a \r\n\r\n     positive value of \r\n\r\n    maximumDistance can substantially speed up the search.\r\n\r\n  \r\n\r\n  \r\n\r\n   testPoint: Point to search from.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def ClosestPoints(self,*__args):\r\n  \"\"\"\r\n  ClosestPoints(self: Curve,otherCurve: Curve) -> (bool,Point3d,Point3d)\r\n\r\n  \r\n\r\n   Gets closest points between this and another curves.\r\n\r\n  \r\n\r\n   otherCurve: The other curve.\r\n\r\n   Returns: true on success; false on error.\r\n\r\n  ClosestPoints(self: Curve,geometry: IEnumerable[GeometryBase]) -> (bool,Point3d,Point3d,int)\r\n\r\n  ClosestPoints(self: Curve,geometry: IEnumerable[GeometryBase],maximumDistance: float) -> (bool,Point3d,Point3d,int)\r\n  \"\"\"\r\n  pass\r\n def ConstructConstObject(self,*args):\r\n  \"\"\"\r\n  ConstructConstObject(self: CommonObject,parentObject: object,subobject_index: int)\r\n\r\n   Assigns a parent object and a subobject index to this.\r\n\r\n  \r\n\r\n   parentObject: The parent object.\r\n\r\n   subobject_index: The subobject index.\r\n  \"\"\"\r\n  pass\r\n def Contains(self,testPoint,plane=None,tolerance=None):\r\n  \"\"\"\r\n  Contains(self: Curve,testPoint: Point3d,plane: Plane,tolerance: float) -> PointContainment\r\n\r\n  \r\n\r\n   Computes the relationship between a point and a closed curve region. \r\n\r\n     This curve \r\n\r\n    must be closed or the return value will be Unset.\r\n\r\n  \r\n\r\n  \r\n\r\n   testPoint: Point to test.\r\n\r\n   plane: Plane in in which to compare point and region.\r\n\r\n   tolerance: Tolerance to use during comparison.\r\n\r\n   Returns: Relationship between point and curve region.\r\n\r\n  Contains(self: Curve,testPoint: Point3d,plane: Plane) -> PointContainment\r\n\r\n  \r\n\r\n   Computes the relationship between a point and a closed curve region. \r\n\r\n     This curve \r\n\r\n    must be closed or the return value will be Unset.\r\n\r\n  \r\n\r\n  \r\n\r\n   testPoint: Point to test.\r\n\r\n   plane: Plane in in which to compare point and region.\r\n\r\n   Returns: Relationship between point and curve region.\r\n\r\n  Contains(self: Curve,testPoint: Point3d) -> PointContainment\r\n\r\n  \r\n\r\n   Computes the relationship between a point and a closed curve region. \r\n\r\n     This curve \r\n\r\n    must be closed or the return value will be Unset.\r\n\r\n     Both curve and point are \r\n\r\n    projected to the World XY plane.\r\n\r\n  \r\n\r\n  \r\n\r\n   testPoint: Point to test.\r\n\r\n   Returns: Relationship between point and curve region.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateBlendCurve(*__args):\r\n  \"\"\"\r\n  CreateBlendCurve(curve0: Curve,t0: float,reverse0: bool,continuity0: BlendContinuity,curve1: Curve,t1: float,reverse1: bool,continuity1: BlendContinuity) -> Curve\r\n\r\n  \r\n\r\n   Makes a curve blend between 2 curves at the parameters specified\r\n\r\n     with the \r\n\r\n    directions and continuities specified\r\n\r\n  \r\n\r\n  \r\n\r\n   curve0: First curve to blend from\r\n\r\n   t0: Parameter on first curve for blend endpoint\r\n\r\n   reverse0: If false,the blend will go in the natural direction of the curve.\r\n\r\n     If true,the \r\n\r\n    blend will go in the opposite direction to the curve\r\n\r\n  \r\n\r\n   continuity0: continuity for the blend at the start\r\n\r\n   curve1: Second curve to blend from\r\n\r\n   t1: Parameter on second curve for blend endpoint\r\n\r\n   reverse1: If false,the blend will go in the natural direction of the curve.\r\n\r\n     If true,the \r\n\r\n    blend will go in the opposite direction to the curve\r\n\r\n  \r\n\r\n   continuity1: continuity for the blend at the end\r\n\r\n   Returns: the blend curve on success. null on failure\r\n\r\n  CreateBlendCurve(curveA: Curve,curveB: Curve,continuity: BlendContinuity,bulgeA: float,bulgeB: float) -> Curve\r\n\r\n  \r\n\r\n   Create a Blend curve between two existing curves.\r\n\r\n  \r\n\r\n   curveA: Curve to blend from (blending will occur at curve end point).\r\n\r\n   curveB: Curve to blend to (blending will occur at curve start point).\r\n\r\n   continuity: Continuity of blend.\r\n\r\n   bulgeA: Bulge factor at curveA end of blend. Values near 1.0 work best.\r\n\r\n   bulgeB: Bulge factor at curveB end of blend. Values near 1.0 work best.\r\n\r\n   Returns: A curve representing the blend between A and B or null on failure.\r\n\r\n  CreateBlendCurve(curveA: Curve,curveB: Curve,continuity: BlendContinuity) -> Curve\r\n\r\n  \r\n\r\n   Create a Blend curve between two existing curves.\r\n\r\n  \r\n\r\n   curveA: Curve to blend from (blending will occur at curve end point).\r\n\r\n   curveB: Curve to blend to (blending will occur at curve start point).\r\n\r\n   continuity: Continuity of blend.\r\n\r\n   Returns: A curve representing the blend between A and B or null on failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateBooleanDifference(curveA,*__args):\r\n  \"\"\"\r\n  CreateBooleanDifference(curveA: Curve,subtractors: IEnumerable[Curve]) -> Array[Curve]\r\n\r\n  CreateBooleanDifference(curveA: Curve,curveB: Curve) -> Array[Curve]\r\n\r\n  \r\n\r\n   Calculates the boolean difference between two closed,planar curves. \r\n\r\n     Note,curves \r\n\r\n    must be co-planar.\r\n\r\n  \r\n\r\n  \r\n\r\n   curveA: The first closed,planar curve.\r\n\r\n   curveB: The second closed,planar curve.\r\n\r\n   Returns: Result curves on success,empty array if no difference could be calculated.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateBooleanIntersection(curveA,curveB):\r\n  \"\"\"\r\n  CreateBooleanIntersection(curveA: Curve,curveB: Curve) -> Array[Curve]\r\n\r\n  \r\n\r\n   Calculates the boolean intersection of two closed,planar curves. \r\n\r\n     Note,curves \r\n\r\n    must be co-planar.\r\n\r\n  \r\n\r\n  \r\n\r\n   curveA: The first closed,planar curve.\r\n\r\n   curveB: The second closed,planar curve.\r\n\r\n   Returns: Result curves on success,empty array if no intersection could be calculated.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateBooleanUnion(curves):\r\n  \"\"\" CreateBooleanUnion(curves: IEnumerable[Curve]) -> Array[Curve] \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateControlPointCurve(points,degree=None):\r\n  \"\"\"\r\n  CreateControlPointCurve(points: IEnumerable[Point3d]) -> Curve\r\n\r\n  CreateControlPointCurve(points: IEnumerable[Point3d],degree: int) -> Curve\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateFillet(curve0,curve1,radius,t0Base,t1Base):\r\n  \"\"\"\r\n  CreateFillet(curve0: Curve,curve1: Curve,radius: float,t0Base: float,t1Base: float) -> Arc\r\n\r\n  \r\n\r\n   Computes the fillet arc for a curve filleting operation.\r\n\r\n  \r\n\r\n   curve0: First curve to fillet.\r\n\r\n   curve1: Second curve to fillet.\r\n\r\n   radius: Fillet radius.\r\n\r\n   t0Base: Parameter on curve0 where the fillet ought to start (approximately).\r\n\r\n   t1Base: Parameter on curve1 where the fillet ought to end (approximately).\r\n\r\n   Returns: The fillet arc on success,or Arc.Unset on failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateFilletCurves(curve0,point0,curve1,point1,radius,join,trim,arcExtension,tolerance,angleTolerance):\r\n  \"\"\"\r\n  CreateFilletCurves(curve0: Curve,point0: Point3d,curve1: Curve,point1: Point3d,radius: float,join: bool,trim: bool,arcExtension: bool,tolerance: float,angleTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Creates a tangent arc between two curves and trims or extends the curves to the arc.\r\n\r\n  \r\n\r\n   curve0: The first curve to fillet.\r\n\r\n   point0: A point on the first curve that is near the end where the fillet will\r\n\r\n     be created.\r\n\r\n   curve1: The second curve to fillet.\r\n\r\n   point1: A point on the second curve that is near the end where the fillet will\r\n\r\n     be created.\r\n\r\n   radius: The radius of the fillet.\r\n\r\n   join: Join the output curves.\r\n\r\n   trim: Trim copies of the input curves to the output fillet curve.\r\n\r\n   arcExtension: Applies when arcs are filleted but need to be extended to meet the\r\n\r\n     fillet curve or \r\n\r\n    chamfer line. If true,then the arc is extended\r\n\r\n     maintaining its validity. If false,\r\n\r\n    then the arc is extended with a\r\n\r\n     line segment,which is joined to the arc converting \r\n\r\n    it to a polycurve.\r\n\r\n  \r\n\r\n   tolerance: The tolerance,generally the document's absolute tolerance.\r\n\r\n   Returns: The results of the fillet operation. The number of output curves depends\r\n\r\n     on the \r\n\r\n    input curves and the values of the parameters that were used\r\n\r\n     during the fillet \r\n\r\n    operation. In most cases,the output array will contain\r\n\r\n     either one or three curves,\r\n\r\n    although two curves can be returned if the\r\n\r\n     radius is zero and join=false.\r\n\r\n      \r\n\r\n      For example,if both join and trim=true,then the output curve\r\n\r\n     will be a \r\n\r\n    polycurve containing the fillet curve joined with trimmed copies\r\n\r\n     of the input \r\n\r\n    curves. If join=false and trim=true,then three curves,\r\n\r\n     the fillet curve and \r\n\r\n    trimmed copies of the input curves,will be returned.\r\n\r\n     If both join and trim=\r\n\r\n    false,then just the fillet curve is returned.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateInterpolatedCurve(points,degree,knots=None,startTangent=None,endTangent=None):\r\n  \"\"\"\r\n  CreateInterpolatedCurve(points: IEnumerable[Point3d],degree: int,knots: CurveKnotStyle,startTangent: Vector3d,endTangent: Vector3d) -> Curve\r\n\r\n  CreateInterpolatedCurve(points: IEnumerable[Point3d],degree: int,knots: CurveKnotStyle) -> Curve\r\n\r\n  CreateInterpolatedCurve(points: IEnumerable[Point3d],degree: int) -> Curve\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateMeanCurve(curveA,curveB,angleToleranceRadians=None):\r\n  \"\"\"\r\n  CreateMeanCurve(curveA: Curve,curveB: Curve) -> Curve\r\n\r\n  \r\n\r\n   Constructs a mean,or average,curve from two curves.\r\n\r\n  \r\n\r\n   curveA: A first curve.\r\n\r\n   curveB: A second curve.\r\n\r\n   Returns: The average curve,or null on error.\r\n\r\n  CreateMeanCurve(curveA: Curve,curveB: Curve,angleToleranceRadians: float) -> Curve\r\n\r\n  \r\n\r\n   Constructs a mean,or average,curve from two curves.\r\n\r\n  \r\n\r\n   curveA: A first curve.\r\n\r\n   curveB: A second curve.\r\n\r\n   angleToleranceRadians: The angle tolerance,in radians,used to match kinks between curves.\r\n\r\n     If you are \r\n\r\n    unsure how to set this parameter,then either use the\r\n\r\n     document's angle tolerance \r\n\r\n    RhinoDoc.AngleToleranceRadians,\r\n\r\n     or the default value (RhinoMath.UnsetValue)\r\n\r\n  \r\n\r\n   Returns: The average curve,or null on error.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateTweenCurves(curve0,curve1,numCurves):\r\n  \"\"\"\r\n  CreateTweenCurves(curve0: Curve,curve1: Curve,numCurves: int) -> Array[Curve]\r\n\r\n  \r\n\r\n   Creates curves between two open or closed input curves. Uses the control points of the curves \r\n\r\n    for finding tween curves.\r\n\r\n     That means the first control point of first curve is \r\n\r\n    matched to first control point of the second curve and so on.\r\n\r\n     There is no matching \r\n\r\n    of curves direction. Caller must match input curves direction before calling the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   curve0: The first,or starting,curve.\r\n\r\n   curve1: The second,or ending,curve.\r\n\r\n   numCurves: Number of tween curves to create.\r\n\r\n   Returns: An array of joint curves. This array can be empty.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateTweenCurvesWithMatching(curve0,curve1,numCurves):\r\n  \"\"\"\r\n  CreateTweenCurvesWithMatching(curve0: Curve,curve1: Curve,numCurves: int) -> Array[Curve]\r\n\r\n  \r\n\r\n   Creates curves between two open or closed input curves. Make the structure of input curves \r\n\r\n    compatible if needed.\r\n\r\n     Refits the input curves to have the same structure. The \r\n\r\n    resulting curves are usually more complex than input unless\r\n\r\n     input curves are \r\n\r\n    compatible and no refit is needed. There is no matching of curves direction.\r\n\r\n     Caller \r\n\r\n    must match input curves direction before calling the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   curve0: The first,or starting,curve.\r\n\r\n   curve1: The second,or ending,curve.\r\n\r\n   numCurves: Number of tween curves to create.\r\n\r\n   Returns: An array of joint curves. This array can be empty.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateTweenCurvesWithSampling(curve0,curve1,numCurves,numSamples):\r\n  \"\"\"\r\n  CreateTweenCurvesWithSampling(curve0: Curve,curve1: Curve,numCurves: int,numSamples: int) -> Array[Curve]\r\n\r\n  \r\n\r\n   Creates curves between two open or closed input curves. Use sample points method to make curves \r\n\r\n    compatible.\r\n\r\n     This is how the algorithm workd: Divides the two curves into an equal \r\n\r\n    number of points,finds the midpoint between the \r\n\r\n     corresponding points on the \r\n\r\n    curves and interpolates the tween curve through those points. There is no matching of curves\r\n\r\n     \r\n\r\n       direction. Caller must match input curves direction before calling the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   curve0: The first,or starting,curve.\r\n\r\n   curve1: The second,or ending,curve.\r\n\r\n   numCurves: Number of tween curves to create.\r\n\r\n   numSamples: Number of sample points along input curves.\r\n\r\n   Returns: >An array of joint curves. This array can be empty.\r\n  \"\"\"\r\n  pass\r\n def CurvatureAt(self,t):\r\n  \"\"\"\r\n  CurvatureAt(self: Curve,t: float) -> Vector3d\r\n\r\n  \r\n\r\n   Evaluate the curvature vector at a curve parameter.\r\n\r\n  \r\n\r\n   t: Evaluation parameter.\r\n\r\n   Returns: Curvature vector of the curve at the parameter t.\r\n  \"\"\"\r\n  pass\r\n def DerivativeAt(self,t,derivativeCount,side=None):\r\n  \"\"\"\r\n  DerivativeAt(self: Curve,t: float,derivativeCount: int,side: CurveEvaluationSide) -> Array[Vector3d]\r\n\r\n  \r\n\r\n   Evaluate the derivatives at the specified curve parameter.\r\n\r\n  \r\n\r\n   t: Curve parameter to evaluate.\r\n\r\n   derivativeCount: Number of derivatives to evaluate,must be at least 0.\r\n\r\n   side: Side of parameter to evaluate. If the parameter is at a kink,\r\n\r\n     it makes a big \r\n\r\n    difference whether the evaluation is from below or above.\r\n\r\n  \r\n\r\n   Returns: An array of vectors that represents all the derivatives starting at zero.\r\n\r\n  DerivativeAt(self: Curve,t: float,derivativeCount: int) -> Array[Vector3d]\r\n\r\n  \r\n\r\n   Evaluate the derivatives at the specified curve parameter.\r\n\r\n  \r\n\r\n   t: Curve parameter to evaluate.\r\n\r\n   derivativeCount: Number of derivatives to evaluate,must be at least 0.\r\n\r\n   Returns: An array of vectors that represents all the derivatives starting at zero.\r\n  \"\"\"\r\n  pass\r\n def Dispose(self):\r\n  \"\"\"\r\n  Dispose(self: Curve,disposing: bool)\r\n\r\n   For derived class implementers.\r\n\r\n     This method is called with argument true when class \r\n\r\n    user calls Dispose(),while with argument false when\r\n\r\n     the Garbage Collector invokes \r\n\r\n    the finalizer,or Finalize() method.You must reclaim all used unmanaged resources in both cases,\r\n\r\n    and can use this chance to call Dispose on disposable fields if the argument is true.Also,you \r\n\r\n    must call the base virtual method within your overriding method.\r\n\r\n  \r\n\r\n  \r\n\r\n   disposing: true if the call comes from the Dispose() method; false if it comes from the Garbage Collector \r\n\r\n    finalizer.\r\n  \"\"\"\r\n  pass\r\n def DivideAsContour(self,contourStart,contourEnd,interval):\r\n  \"\"\"\r\n  DivideAsContour(self: Curve,contourStart: Point3d,contourEnd: Point3d,interval: float) -> Array[Point3d]\r\n\r\n  \r\n\r\n   Divides this curve at fixed steps along a defined contour line.\r\n\r\n  \r\n\r\n   contourStart: The start of the contouring line.\r\n\r\n   contourEnd: The end of the contouring line.\r\n\r\n   interval: A distance to measure on the contouring axis.\r\n\r\n   Returns: An array of points; or null on error.\r\n  \"\"\"\r\n  pass\r\n def DivideByCount(self,segmentCount,includeEnds,points=None):\r\n  \"\"\"\r\n  DivideByCount(self: Curve,segmentCount: int,includeEnds: bool) -> (Array[float],Array[Point3d])\r\n\r\n  \r\n\r\n   Divide the curve into a number of equal-length segments.\r\n\r\n  \r\n\r\n   segmentCount: Segment count. Note that the number of division points may differ from the segment count.\r\n\r\n   includeEnds: If true,then the points at the start and end of the curve are included.\r\n\r\n   Returns: Array containing division curve parameters on success,null on failure.\r\n\r\n  DivideByCount(self: Curve,segmentCount: int,includeEnds: bool) -> Array[float]\r\n\r\n  \r\n\r\n   Divide the curve into a number of equal-length segments.\r\n\r\n  \r\n\r\n   segmentCount: Segment count. Note that the number of division points may differ from the segment count.\r\n\r\n   includeEnds: If true,then the points at the start and end of the curve are included.\r\n\r\n   Returns: List of curve parameters at the division points on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def DivideByLength(self,segmentLength,includeStart,points=None):\r\n  \"\"\"\r\n  DivideByLength(self: Curve,segmentLength: float,includeStart: bool) -> (Array[float],Array[Point3d])\r\n\r\n  \r\n\r\n   Divide the curve into specific length segments.\r\n\r\n  \r\n\r\n   segmentLength: The length of each and every segment (except potentially the last one).\r\n\r\n   includeStart: If true,then the point at the start of the curve is included.\r\n\r\n   Returns: Array containing division curve parameters if successful,null on failure.\r\n\r\n  DivideByLength(self: Curve,segmentLength: float,includeStart: bool) -> Array[float]\r\n\r\n  \r\n\r\n   Divide the curve into specific length segments.\r\n\r\n  \r\n\r\n   segmentLength: The length of each and every segment (except potentially the last one).\r\n\r\n   includeStart: If true,then the points at the start of the curve is included.\r\n\r\n   Returns: Array containing division curve parameters if successful,null on failure.\r\n  \"\"\"\r\n  pass\r\n def DivideEquidistant(self,distance):\r\n  \"\"\"\r\n  DivideEquidistant(self: Curve,distance: float) -> Array[Point3d]\r\n\r\n  \r\n\r\n   Calculates 3d points on a curve where the linear distance between the points is equal.\r\n\r\n  \r\n\r\n   distance: The distance betwen division points.\r\n\r\n   Returns: An array of equidistant points,or null on error.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def DoDirectionsMatch(curveA,curveB):\r\n  \"\"\"\r\n  DoDirectionsMatch(curveA: Curve,curveB: Curve) -> bool\r\n\r\n  \r\n\r\n   Determines whether two curves travel more or less in the same direction.\r\n\r\n  \r\n\r\n   curveA: First curve to test.\r\n\r\n   curveB: Second curve to test.\r\n\r\n   Returns: true if both curves more or less point in the same direction,\r\n\r\n     false if they point \r\n\r\n    in the opposite directions.\r\n  \"\"\"\r\n  pass\r\n def Duplicate(self):\r\n  \"\"\"\r\n  Duplicate(self: Curve) -> GeometryBase\r\n\r\n  \r\n\r\n   Constructs an exact duplicate of this Curve.\r\n  \"\"\"\r\n  pass\r\n def DuplicateCurve(self):\r\n  \"\"\"\r\n  DuplicateCurve(self: Curve) -> Curve\r\n\r\n  \r\n\r\n   Constructs an exact duplicate of this curve.\r\n\r\n   Returns: An exact copy of this curve.\r\n  \"\"\"\r\n  pass\r\n def DuplicateSegments(self):\r\n  \"\"\"\r\n  DuplicateSegments(self: Curve) -> Array[Curve]\r\n\r\n  \r\n\r\n   Polylines will be exploded into line segments. ExplodeCurves will\r\n\r\n     return the curves \r\n\r\n    in topological order.\r\n\r\n  \r\n\r\n   Returns: An array of all the segments that make up this curve.\r\n  \"\"\"\r\n  pass\r\n def Extend(self,*__args):\r\n  \"\"\"\r\n  Extend(self: Curve,side: CurveEnd,style: CurveExtensionStyle,geometry: IEnumerable[GeometryBase]) -> Curve\r\n\r\n  Extend(self: Curve,side: CurveEnd,style: CurveExtensionStyle,endPoint: Point3d) -> Curve\r\n\r\n  \r\n\r\n   Extends a curve to a point.\r\n\r\n  \r\n\r\n   side: The end of the curve to extend.\r\n\r\n   style: The style or type of extension to use.\r\n\r\n   endPoint: A new end point.\r\n\r\n   Returns: New extended curve result on success,null on failure.\r\n\r\n  Extend(self: Curve,side: CurveEnd,length: float,style: CurveExtensionStyle) -> Curve\r\n\r\n  \r\n\r\n   Extends a curve by a specific length.\r\n\r\n  \r\n\r\n   side: Curve end to extend.\r\n\r\n   length: Length to add to the curve end.\r\n\r\n   style: Extension style.\r\n\r\n   Returns: A curve with extended ends or null on failure.\r\n\r\n  Extend(self: Curve,t0: float,t1: float) -> Curve\r\n\r\n  \r\n\r\n   Where possible,analytically extends curve to include the given domain. \r\n\r\n     This will \r\n\r\n    not work on closed curves. The original curve will be identical to the \r\n\r\n     restriction \r\n\r\n    of the resulting curve to the original curve domain.\r\n\r\n  \r\n\r\n  \r\n\r\n   t0: Start of extension domain,if the start is not inside the \r\n\r\n     Domain of this curve,an \r\n\r\n    attempt will be made to extend the curve.\r\n\r\n  \r\n\r\n   t1: End of extension domain,if the end is not inside the \r\n\r\n     Domain of this curve,an \r\n\r\n    attempt will be made to extend the curve.\r\n\r\n  \r\n\r\n   Returns: Extended curve on success,null on failure.\r\n\r\n  Extend(self: Curve,domain: Interval) -> Curve\r\n\r\n  \r\n\r\n   Where possible,analytically extends curve to include the given domain. \r\n\r\n     This will \r\n\r\n    not work on closed curves. The original curve will be identical to the \r\n\r\n     restriction \r\n\r\n    of the resulting curve to the original curve domain.\r\n\r\n  \r\n\r\n  \r\n\r\n   domain: Extension domain.\r\n\r\n   Returns: Extended curve on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def ExtendByArc(self,side,geometry):\r\n  \"\"\" ExtendByArc(self: Curve,side: CurveEnd,geometry: IEnumerable[GeometryBase]) -> Curve \"\"\"\r\n  pass\r\n def ExtendByLine(self,side,geometry):\r\n  \"\"\" ExtendByLine(self: Curve,side: CurveEnd,geometry: IEnumerable[GeometryBase]) -> Curve \"\"\"\r\n  pass\r\n def ExtendOnSurface(self,side,*__args):\r\n  \"\"\"\r\n  ExtendOnSurface(self: Curve,side: CurveEnd,face: BrepFace) -> Curve\r\n\r\n  \r\n\r\n   Extends a curve on a surface.\r\n\r\n  \r\n\r\n   side: The end of the curve to extend.\r\n\r\n   face: BrepFace that contains the curve.\r\n\r\n   Returns: New extended curve result on success,null on failure.\r\n\r\n  ExtendOnSurface(self: Curve,side: CurveEnd,surface: Surface) -> Curve\r\n\r\n  \r\n\r\n   Extends a curve on a surface.\r\n\r\n  \r\n\r\n   side: The end of the curve to extend.\r\n\r\n   surface: Surface that contains the curve.\r\n\r\n   Returns: New extended curve result on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def Fair(self,distanceTolerance,angleTolerance,clampStart,clampEnd,iterations):\r\n  \"\"\"\r\n  Fair(self: Curve,distanceTolerance: float,angleTolerance: float,clampStart: int,clampEnd: int,iterations: int) -> Curve\r\n\r\n  \r\n\r\n   Fairs a curve object. Fair works best on degree 3 (cubic) curves. Attempts to \r\n\r\n     \r\n\r\n    remove large curvature variations while limiting the geometry changes to be no \r\n\r\n     \r\n\r\n    more than the specified tolerance.\r\n\r\n  \r\n\r\n  \r\n\r\n   distanceTolerance: Maximum allowed distance the faired curve is allowed to deviate from the input.\r\n\r\n   angleTolerance: (in radians) kinks with angles <= angleTolerance are smoothed out 0.05 is a good default.\r\n\r\n   clampStart: The number of (control vertices-1) to preserve at start. \r\n\r\n     0=preserve start point1 \r\n\r\n   =preserve start point and 1st derivative2=preserve start point,1st and 2nd derivative\r\n\r\n  \r\n\r\n   clampEnd: Same as clampStart.\r\n\r\n   iterations: The number of iteratoins to use in adjusting the curve.\r\n\r\n   Returns: Returns new faired Curve on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def Fit(self,degree,fitTolerance,angleTolerance):\r\n  \"\"\"\r\n  Fit(self: Curve,degree: int,fitTolerance: float,angleTolerance: float) -> Curve\r\n\r\n  \r\n\r\n   Fits a new curve through an existing curve.\r\n\r\n  \r\n\r\n   degree: The degree of the returned Curve. Must be bigger than 1.\r\n\r\n   fitTolerance: The fitting tolerance. If fitTolerance is RhinoMath.UnsetValue or <=0.0,\r\n\r\n     the \r\n\r\n    document absolute tolerance is used.\r\n\r\n  \r\n\r\n   angleTolerance: The kink smoothing tolerance in radians.\r\n\r\n     If angleTolerance is 0.0,all kinks are \r\n\r\n    smoothedIf angleTolerance is >0.0,kinks smaller than angleTolerance are smoothedIf \r\n\r\n    angleTolerance is RhinoMath.UnsetValue or <0.0,the document angle tolerance is used for the \r\n\r\n    kink smoothing\r\n\r\n  \r\n\r\n   Returns: Returns a new fitted Curve if successful,null on failure.\r\n  \"\"\"\r\n  pass\r\n def FrameAt(self,t,plane):\r\n  \"\"\"\r\n  FrameAt(self: Curve,t: float) -> (bool,Plane)\r\n\r\n  \r\n\r\n   Returns a 3d frame at a parameter.\r\n\r\n  \r\n\r\n   t: Evaluation parameter.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def GetCurveParameterFromNurbsFormParameter(self,nurbsParameter,curveParameter):\r\n  \"\"\"\r\n  GetCurveParameterFromNurbsFormParameter(self: Curve,nurbsParameter: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Convert a NURBS curve parameter to a curve parameter.\r\n\r\n  \r\n\r\n   nurbsParameter: Nurbs form parameter.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def GetDistancesBetweenCurves(curveA,curveB,tolerance,maxDistance,maxDistanceParameterA,maxDistanceParameterB,minDistance,minDistanceParameterA,minDistanceParameterB):\r\n  \"\"\"\r\n  GetDistancesBetweenCurves(curveA: Curve,curveB: Curve,tolerance: float) -> (bool,float,float,float,float,float,float)\r\n\r\n  \r\n\r\n   Computes the distances between two arbitrary curves that overlap.\r\n\r\n  \r\n\r\n   curveA: A curve.\r\n\r\n   curveB: Another curve.\r\n\r\n   tolerance: A tolerance value.\r\n\r\n   Returns: true if the operation succeeded; otherwise false.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def GetFilletPoints(curve0,curve1,radius,t0Base,t1Base,t0,t1,filletPlane):\r\n  \"\"\"\r\n  GetFilletPoints(curve0: Curve,curve1: Curve,radius: float,t0Base: float,t1Base: float) -> (bool,float,float,Plane)\r\n\r\n  \r\n\r\n   Finds points at which to cut a pair of curves so that a fillet of given radius can be inserted.\r\n\r\n  \r\n\r\n   curve0: First curve to fillet.\r\n\r\n   curve1: Second curve to fillet.\r\n\r\n   radius: Fillet radius.\r\n\r\n   t0Base: Parameter value for base point on curve0.\r\n\r\n   t1Base: Parameter value for base point on curve1.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def GetLength(self,*__args):\r\n  \"\"\"\r\n  GetLength(self: Curve,subdomain: Interval) -> float\r\n\r\n  \r\n\r\n   Get the length of a sub-section of the curve with a fractional tolerance of 1e-8.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).\r\n\r\n   Returns: The length of the sub-curve on success,or zero on failure.\r\n\r\n  GetLength(self: Curve,fractionalTolerance: float,subdomain: Interval) -> float\r\n\r\n  \r\n\r\n   Get the length of a sub-section of the curve.\r\n\r\n  \r\n\r\n   fractionalTolerance: Desired fractional precision. \r\n\r\n     fabs((\"exact\" length from start to t) - \r\n\r\n    arc_length)/arc_length <= fractionalTolerance.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).\r\n\r\n   Returns: The length of the sub-curve on success,or zero on failure.\r\n\r\n  GetLength(self: Curve) -> float\r\n\r\n  \r\n\r\n   Gets the length of the curve with a fractional tolerance of 1.0e-8.\r\n\r\n   Returns: The length of the curve on success,or zero on failure.\r\n\r\n  GetLength(self: Curve,fractionalTolerance: float) -> float\r\n\r\n  \r\n\r\n   Get the length of the curve.\r\n\r\n  \r\n\r\n   fractionalTolerance: Desired fractional precision. \r\n\r\n     fabs((\"exact\" length from start to t) - \r\n\r\n    arc_length)/arc_length <= fractionalTolerance.\r\n\r\n  \r\n\r\n   Returns: The length of the curve on success,or zero on failure.\r\n  \"\"\"\r\n  pass\r\n def GetNextDiscontinuity(self,continuityType,t0,t1,t):\r\n  \"\"\"\r\n  GetNextDiscontinuity(self: Curve,continuityType: Continuity,t0: float,t1: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Searches for a derivative,tangent,or curvature discontinuity.\r\n\r\n  \r\n\r\n   continuityType: Type of continuity to search for.\r\n\r\n   t0: Search begins at t0. If there is a discontinuity at t0,it will be ignored. This makes it\r\n\r\n     \r\n\r\n       possible to repeatedly call GetNextDiscontinuity() and step through the discontinuities.\r\n\r\n  \r\n\r\n   t1: (t0 != t1)  If there is a discontinuity at t1 it will be ignored unless continuityType is\r\n\r\n     \r\n\r\n       a locus discontinuity type and t1 is at the start or end of the curve.\r\n\r\n  \r\n\r\n   Returns: Parametric continuity tests c=(C0_continuous,...,G2_continuous):\r\n\r\n      true if a \r\n\r\n    parametric discontinuity was found strictly between t0 and t1. Note well that\r\n\r\n      all \r\n\r\n    curves are parametrically continuous at the ends of their domains.\r\n\r\n     \r\n\r\n     \r\n\r\n    Locus continuity tests c=(C0_locus_continuous,...,G2_locus_continuous):\r\n\r\n      true if \r\n\r\n    a locus discontinuity was found strictly between t0 and t1 or at t1 is the at the end\r\n\r\n      \r\n\r\n    of a curve. Note well that all open curves (IsClosed()=false) are locus discontinuous at the\r\n\r\n  \r\n\r\n        ends of their domains.  All closed curves (IsClosed()=true) are at least \r\n\r\n    C0_locus_continuous at \r\n\r\n      the ends of their domains.\r\n  \"\"\"\r\n  pass\r\n def GetNurbsFormParameterFromCurveParameter(self,curveParameter,nurbsParameter):\r\n  \"\"\"\r\n  GetNurbsFormParameterFromCurveParameter(self: Curve,curveParameter: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Convert a curve parameter to a NURBS curve parameter.\r\n\r\n  \r\n\r\n   curveParameter: Curve parameter.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def GetPerpendicularFrames(self,parameters):\r\n  \"\"\" GetPerpendicularFrames(self: Curve,parameters: IEnumerable[float]) -> Array[Plane] \"\"\"\r\n  pass\r\n def HasNurbsForm(self):\r\n  \"\"\"\r\n  HasNurbsForm(self: Curve) -> int\r\n\r\n  \r\n\r\n   Does a NURBS curve representation of this curve exist?\r\n\r\n   Returns: 0   unable to create NURBS representation with desired accuracy.\r\n\r\n     1   success - \r\n\r\n    NURBS parameterization matches the curve's to the desired accuracy\r\n\r\n     2   success - \r\n\r\n    NURBS point locus matches the curve's and the domain of the NURBS\r\n\r\n          \r\n\r\n    curve is correct. However,This curve's parameterization and the\r\n\r\n          \r\n\r\n    NURBS curve parameterization may not match. This situation happens\r\n\r\n          \r\n\r\n    when getting NURBS representations of curves that have a\r\n\r\n          \r\n\r\n    transendental parameterization like circles.\r\n  \"\"\"\r\n  pass\r\n def IsArc(self,tolerance=None):\r\n  \"\"\"\r\n  IsArc(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it can be represented by an arc or circle within the given tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve can be represented by an arc or a circle within tolerance.\r\n\r\n  IsArc(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it can be represented by an arc or circle within RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the curve can be represented by an arc or a circle within tolerance.\r\n  \"\"\"\r\n  pass\r\n def IsCircle(self,tolerance=None):\r\n  \"\"\"\r\n  IsCircle(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it can be represented by a circle within the given tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve can be represented by a circle to within tolerance.\r\n\r\n  IsCircle(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it can be represented by a circle within RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the Curve can be represented by a circle within tolerance.\r\n  \"\"\"\r\n  pass\r\n def IsClosable(self,tolerance,minimumAbsoluteSize=None,minimumRelativeSize=None):\r\n  \"\"\"\r\n  IsClosable(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Decide if it makes sense to close off this curve by moving the endpoint \r\n\r\n     to the \r\n\r\n    start based on start-end gap size and length of curve as \r\n\r\n     approximated by chord \r\n\r\n    defined by 6 points.\r\n\r\n  \r\n\r\n  \r\n\r\n   tolerance: Maximum allowable distance between start and end. \r\n\r\n     If start - end gap is greater \r\n\r\n    than tolerance,this function will return false.\r\n\r\n  \r\n\r\n   Returns: true if start and end points are close enough based on above conditions.\r\n\r\n  IsClosable(self: Curve,tolerance: float,minimumAbsoluteSize: float,minimumRelativeSize: float) -> bool\r\n\r\n  \r\n\r\n   Decide if it makes sense to close off this curve by moving the endpoint\r\n\r\n     to the \r\n\r\n    start based on start-end gap size and length of curve as\r\n\r\n     approximated by chord \r\n\r\n    defined by 6 points.\r\n\r\n  \r\n\r\n  \r\n\r\n   tolerance: Maximum allowable distance between start and end. \r\n\r\n     If start - end gap is greater \r\n\r\n    than tolerance,this function will return false.\r\n\r\n  \r\n\r\n   minimumAbsoluteSize: If greater than 0.0 and none of the interior sampled points are at\r\n\r\n     least \r\n\r\n    minimumAbsoluteSize from start,this function will return false.\r\n\r\n  \r\n\r\n   minimumRelativeSize: If greater than 1.0 and chord length is less than \r\n\r\n     minimumRelativeSize*gap,this \r\n\r\n    function will return false.\r\n\r\n  \r\n\r\n   Returns: true if start and end points are close enough based on above conditions.\r\n  \"\"\"\r\n  pass\r\n def IsContinuous(self,continuityType,t):\r\n  \"\"\"\r\n  IsContinuous(self: Curve,continuityType: Continuity,t: float) -> bool\r\n\r\n  \r\n\r\n   Test continuity at a curve parameter value.\r\n\r\n  \r\n\r\n   continuityType: Type of continuity to test for.\r\n\r\n   t: Parameter to test.\r\n\r\n   Returns: true if the curve has at least the c type continuity at the parameter t.\r\n  \"\"\"\r\n  pass\r\n def IsEllipse(self,tolerance=None):\r\n  \"\"\"\r\n  IsEllipse(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it can be represented by an ellipse within a given tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use for checking.\r\n\r\n   Returns: true if the Curve can be represented by an ellipse within tolerance.\r\n\r\n  IsEllipse(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it can be represented by an ellipse within RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the Curve can be represented by an ellipse within tolerance.\r\n  \"\"\"\r\n  pass\r\n def IsInPlane(self,testPlane,tolerance=None):\r\n  \"\"\"\r\n  IsInPlane(self: Curve,testPlane: Plane,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it lies in a specific plane.\r\n\r\n  \r\n\r\n   testPlane: Plane to test for.\r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the maximum distance from the curve to the testPlane is <= tolerance.\r\n\r\n  IsInPlane(self: Curve,testPlane: Plane) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it lies in a specific plane.\r\n\r\n  \r\n\r\n   testPlane: Plane to test for.\r\n\r\n   Returns: true if the maximum distance from the curve to the testPlane is <= RhinoMath.ZeroTolerance.\r\n  \"\"\"\r\n  pass\r\n def IsLinear(self,tolerance=None):\r\n  \"\"\"\r\n  IsLinear(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it is linear to within the custom tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking linearity.\r\n\r\n   Returns: true if the ends of the curve are farther than tolerance apart\r\n\r\n     and the maximum \r\n\r\n    distance from any point on the curve to\r\n\r\n     the line segment connecting the curve ends \r\n\r\n    is <= tolerance.\r\n\r\n  \r\n\r\n  IsLinear(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it is linear to within RhinoMath.ZeroTolerance units (1e-12).\r\n\r\n   Returns: true if the curve is linear.\r\n  \"\"\"\r\n  pass\r\n def IsPlanar(self,tolerance=None):\r\n  \"\"\"\r\n  IsPlanar(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Test a curve for planarity.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if there is a plane such that the maximum distance from the curve to the plane is <= \r\n\r\n    tolerance.\r\n\r\n  \r\n\r\n  IsPlanar(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Test a curve for planarity.\r\n\r\n   Returns: true if the curve is planar (flat) to within RhinoMath.ZeroTolerance units (1e-12).\r\n  \"\"\"\r\n  pass\r\n def IsPolyline(self):\r\n  \"\"\"\r\n  IsPolyline(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Several types of Curve can have the form of a polyline\r\n\r\n     including a degree 1 \r\n\r\n    NurbsCurve,a PolylineCurve,\r\n\r\n     and a PolyCurve all of whose segments are some form of\r\n\r\n\r\n    \r\n     polyline. IsPolyline tests a curve to see if it can be\r\n\r\n     represented as \r\n\r\n    a polyline.\r\n\r\n  \r\n\r\n   Returns: true if this curve can be represented as a polyline; otherwise,false.\r\n  \"\"\"\r\n  pass\r\n def IsShort(self,tolerance,subdomain=None):\r\n  \"\"\"\r\n  IsShort(self: Curve,tolerance: float,subdomain: Interval) -> bool\r\n\r\n  \r\n\r\n   Used to quickly find short curves.\r\n\r\n  \r\n\r\n   tolerance: Length threshold value for \"shortness\".\r\n\r\n   subdomain: The test is performed on the interval that is the intersection of subdomain with Domain()\r\n\r\n   Returns: true if the length of the curve is <= tolerance.\r\n\r\n  IsShort(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Used to quickly find short curves.\r\n\r\n  \r\n\r\n   tolerance: Length threshold value for \"shortness\".\r\n\r\n   Returns: true if the length of the curve is <= tolerance.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def JoinCurves(inputCurves,joinTolerance=None,preserveDirection=None):\r\n  \"\"\"\r\n  JoinCurves(inputCurves: IEnumerable[Curve],joinTolerance: float,preserveDirection: bool) -> Array[Curve]\r\n\r\n  JoinCurves(inputCurves: IEnumerable[Curve],joinTolerance: float) -> Array[Curve]\r\n\r\n  JoinCurves(inputCurves: IEnumerable[Curve]) -> Array[Curve]\r\n  \"\"\"\r\n  pass\r\n def LengthParameter(self,segmentLength,t,*__args):\r\n  \"\"\"\r\n  LengthParameter(self: Curve,segmentLength: float,subdomain: Interval) -> (bool,float)\r\n\r\n  \r\n\r\n   Gets the parameter along the curve which coincides with a given length along the curve. \r\n\r\n      \r\n\r\n      A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the subdomain.\r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve rather than the whole \r\n\r\n    curve.\r\n\r\n  \r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  LengthParameter(self: Curve,segmentLength: float,fractionalTolerance: float,subdomain: Interval) -> (bool,float)\r\n\r\n  \r\n\r\n   Gets the parameter along the curve which coincides with a given length along the curve.\r\n\r\n  \r\n\r\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the subdomain.\r\n\r\n   fractionalTolerance: Desired fractional precision. \r\n\r\n     fabs((\"exact\" length from start to t) - \r\n\r\n    arc_length)/arc_length <= fractionalTolerance.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve rather than the whole \r\n\r\n    curve.\r\n\r\n  \r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  LengthParameter(self: Curve,segmentLength: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Gets the parameter along the curve which coincides with a given length along the curve. \r\n\r\n      \r\n\r\n      A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the curve.\r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  LengthParameter(self: Curve,segmentLength: float,fractionalTolerance: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Gets the parameter along the curve which coincides with a given length along the curve.\r\n\r\n  \r\n\r\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the curve.\r\n\r\n   fractionalTolerance: Desired fractional precision.\r\n\r\n     fabs((\"exact\" length from start to t) - \r\n\r\n    arc_length)/arc_length <= fractionalTolerance.\r\n\r\n  \r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def MakeClosed(self,tolerance):\r\n  \"\"\"\r\n  MakeClosed(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   If IsClosed,just return true. Otherwise,decide if curve can be closed as \r\n\r\n     \r\n\r\n    follows: Linear curves polylinear curves with 2 segments,Nurbs with 3 or less \r\n\r\n     \r\n\r\n    control points cannot be made closed. Also,if tolerance > 0 and the gap between \r\n\r\n     \r\n\r\n    start and end is larger than tolerance,curve cannot be made closed. \r\n\r\n     Adjust the \r\n\r\n    curve's endpoint to match its start point.\r\n\r\n  \r\n\r\n  \r\n\r\n   tolerance: If nonzero,and the gap is more than tolerance,curve cannot be made closed.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def MakeEndsMeet(curveA,adjustStartCurveA,curveB,adjustStartCurveB):\r\n  \"\"\"\r\n  MakeEndsMeet(curveA: Curve,adjustStartCurveA: bool,curveB: Curve,adjustStartCurveB: bool) -> bool\r\n\r\n  \r\n\r\n   Makes adjustments to the ends of one or both input curves so that they meet at a point.\r\n\r\n  \r\n\r\n   curveA: 1st curve to adjust.\r\n\r\n   adjustStartCurveA: Which end of the 1st curve to adjust: true is start,false is end.\r\n\r\n   curveB: 2nd curve to adjust.\r\n\r\n   adjustStartCurveB: which end of the 2nd curve to adjust true==start,false==end.\r\n\r\n   Returns: true on success.\r\n  \"\"\"\r\n  pass\r\n def NonConstOperation(self,*args):\r\n  \"\"\"\r\n  NonConstOperation(self: Curve)\r\n\r\n   For derived classes implementers.\r\n\r\n     Defines the necessary implementation to free the \r\n\r\n    instance from being const.\r\n  \"\"\"\r\n  pass\r\n def NormalizedLengthParameter(self,s,t,*__args):\r\n  \"\"\"\r\n  NormalizedLengthParameter(self: Curve,s: float,subdomain: Interval) -> (bool,float)\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve. \r\n\r\n     A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Normalized arc length parameter. \r\n\r\n     E.g.,0=start of curve,1/2=midpoint of \r\n\r\n    curve,1=end of curve.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve.\r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  NormalizedLengthParameter(self: Curve,s: float,fractionalTolerance: float,subdomain: Interval) -> (bool,float)\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Normalized arc length parameter. \r\n\r\n     E.g.,0=start of curve,1/2=midpoint of \r\n\r\n    curve,1=end of curve.\r\n\r\n  \r\n\r\n   fractionalTolerance: Desired fractional precision. \r\n\r\n     fabs((\"exact\" length from start to t) - \r\n\r\n    arc_length)/arc_length <= fractionalTolerance.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve.\r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  NormalizedLengthParameter(self: Curve,s: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve. \r\n\r\n     A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Normalized arc length parameter. \r\n\r\n     E.g.,0=start of curve,1/2=midpoint of \r\n\r\n    curve,1=end of curve.\r\n\r\n  \r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  NormalizedLengthParameter(self: Curve,s: float,fractionalTolerance: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Normalized arc length parameter. \r\n\r\n     E.g.,0=start of curve,1/2=midpoint of \r\n\r\n    curve,1=end of curve.\r\n\r\n  \r\n\r\n   fractionalTolerance: Desired fractional precision. \r\n\r\n     fabs((\"exact\" length from start to t) - \r\n\r\n    arc_length)/arc_length <= fractionalTolerance.\r\n\r\n  \r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def NormalizedLengthParameters(self,s,absoluteTolerance,*__args):\r\n  \"\"\"\r\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float,subdomain: Interval) -> Array[float]\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve. \r\n\r\n     A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Array of normalized arc length parameters. \r\n\r\n     E.g.,0=start of curve,1/2=\r\n\r\n    midpoint of curve,1=end of curve.\r\n\r\n  \r\n\r\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \r\n\r\n     \r\n\r\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve. \r\n\r\n     A 0.0 s \r\n\r\n    value corresponds to subdomain->Min() and a 1.0 s value corresponds to subdomain->Max().\r\n\r\n  \r\n\r\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \r\n\r\n    t[i] is s[i]*curve_length. \r\n\r\n     Null on failure.\r\n\r\n  \r\n\r\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float,fractionalTolerance: float,subdomain: Interval) -> Array[float]\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Array of normalized arc length parameters. \r\n\r\n     E.g.,0=start of curve,1/2=\r\n\r\n    midpoint of curve,1=end of curve.\r\n\r\n  \r\n\r\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \r\n\r\n     \r\n\r\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\r\n\r\n  \r\n\r\n   fractionalTolerance: Desired fractional precision for each segment. \r\n\r\n     fabs(\"true\" length - actual \r\n\r\n    length)/(actual length) <= fractionalTolerance.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve. \r\n\r\n     A 0.0 s \r\n\r\n    value corresponds to subdomain->Min() and a 1.0 s value corresponds to subdomain->Max().\r\n\r\n  \r\n\r\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \r\n\r\n    t[i] is s[i]*curve_length. \r\n\r\n     Null on failure.\r\n\r\n  \r\n\r\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float) -> Array[float]\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve. \r\n\r\n     A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Array of normalized arc length parameters. \r\n\r\n     E.g.,0=start of curve,1/2=\r\n\r\n    midpoint of curve,1=end of curve.\r\n\r\n  \r\n\r\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \r\n\r\n     \r\n\r\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\r\n\r\n  \r\n\r\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \r\n\r\n    t[i] is s[i]*curve_length. \r\n\r\n     Null on failure.\r\n\r\n  \r\n\r\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float,fractionalTolerance: float) -> Array[float]\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Array of normalized arc length parameters. \r\n\r\n     E.g.,0=start of curve,1/2=\r\n\r\n    midpoint of curve,1=end of curve.\r\n\r\n  \r\n\r\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \r\n\r\n     \r\n\r\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\r\n\r\n  \r\n\r\n   fractionalTolerance: Desired fractional precision for each segment. \r\n\r\n     fabs(\"true\" length - actual \r\n\r\n    length)/(actual length) <= fractionalTolerance.\r\n\r\n  \r\n\r\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \r\n\r\n    t[i] is s[i]*curve_length. \r\n\r\n     Null on failure.\r\n  \"\"\"\r\n  pass\r\n def Offset(self,*__args):\r\n  \"\"\"\r\n  Offset(self: Curve,directionPoint: Point3d,normal: Vector3d,distance: float,tolerance: float,cornerStyle: CurveOffsetCornerStyle) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offsets this curve. If you have a nice offset,then there will be one entry in \r\n\r\n     the \r\n\r\n    array. If the original curve had kinks or the offset curve had self \r\n\r\n     intersections,\r\n\r\n    you will get multiple segments in the offset_curves[] array.\r\n\r\n  \r\n\r\n  \r\n\r\n   directionPoint: A point that indicates the direction of the offset.\r\n\r\n   normal: The normal to the offset plane.\r\n\r\n   distance: The positive or negative distance to offset.\r\n\r\n   tolerance: The offset or fitting tolerance.\r\n\r\n   cornerStyle: Corner style for offset kinks.\r\n\r\n   Returns: Offset curves on success,null on failure.\r\n\r\n  Offset(self: Curve,plane: Plane,distance: float,tolerance: float,cornerStyle: CurveOffsetCornerStyle) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offsets this curve. If you have a nice offset,then there will be one entry in \r\n\r\n     the \r\n\r\n    array. If the original curve had kinks or the offset curve had self \r\n\r\n     intersections,\r\n\r\n    you will get multiple segments in the offset_curves[] array.\r\n\r\n  \r\n\r\n  \r\n\r\n   plane: Offset solution plane.\r\n\r\n   distance: The positive or negative distance to offset.\r\n\r\n   tolerance: The offset or fitting tolerance.\r\n\r\n   cornerStyle: Corner style for offset kinks.\r\n\r\n   Returns: Offset curves on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def OffsetNormalToSurface(self,surface,height):\r\n  \"\"\"\r\n  OffsetNormalToSurface(self: Curve,surface: Surface,height: float) -> Curve\r\n\r\n  \r\n\r\n   Finds a curve by offsetting an existing curve normal to a surface.\r\n\r\n     The caller is \r\n\r\n    responsible for ensuring that the curve lies on the input surface.\r\n\r\n  \r\n\r\n  \r\n\r\n   surface: Surface from which normals are calculated.\r\n\r\n   height: offset distance (distance from surface to result curve)\r\n\r\n   Returns: Offset curve at distance height from the surface.  The offset curve is\r\n\r\n     interpolated \r\n\r\n    through a small number of points so if the surface is irregular\r\n\r\n     or complicated,the \r\n\r\n    result will not be a very accurate offset.\r\n  \"\"\"\r\n  pass\r\n def OffsetOnSurface(self,*__args):\r\n  \"\"\"\r\n  OffsetOnSurface(self: Curve,surface: Surface,distance: float,fittingTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offset a curve on a surface. This curve must lie on the surface.\r\n\r\n  \r\n\r\n   surface: A surface on which to offset.\r\n\r\n   distance: A distance to offset (+)left,(-)right.\r\n\r\n   fittingTolerance: A fitting tolerance.\r\n\r\n   Returns: Offset curves on success,or null on failure.\r\n\r\n  OffsetOnSurface(self: Curve,surface: Surface,throughPoint: Point2d,fittingTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offset a curve on a surface. This curve must lie on the surface.\r\n\r\n     This overload \r\n\r\n    allows to specify a surface point at which the offset will pass.\r\n\r\n  \r\n\r\n  \r\n\r\n   surface: A surface on which to offset.\r\n\r\n   throughPoint: 2d point on the brep face to offset through.\r\n\r\n   fittingTolerance: A fitting tolerance.\r\n\r\n   Returns: Offset curves on success,or null on failure.\r\n\r\n  OffsetOnSurface(self: Curve,surface: Surface,curveParameters: Array[float],offsetDistances: Array[float],fittingTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offset this curve on a surface. This curve must lie on the surface.\r\n\r\n     This overload \r\n\r\n    allows to specify different offsets for different curve parameters.\r\n\r\n  \r\n\r\n  \r\n\r\n   surface: A surface on which to offset.\r\n\r\n   curveParameters: Curve parameters corresponding to the offset distances.\r\n\r\n   offsetDistances: Distances to offset (+)left,(-)right.\r\n\r\n   fittingTolerance: A fitting tolerance.\r\n\r\n   Returns: Offset curves on success,or null on failure.\r\n\r\n  OffsetOnSurface(self: Curve,face: BrepFace,distance: float,fittingTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offset this curve on a brep face surface. This curve must lie on the surface.\r\n\r\n  \r\n\r\n   face: The brep face on which to offset.\r\n\r\n   distance: A distance to offset (+)left,(-)right.\r\n\r\n   fittingTolerance: A fitting tolerance.\r\n\r\n   Returns: Offset curves on success,or null on failure.\r\n\r\n  OffsetOnSurface(self: Curve,face: BrepFace,throughPoint: Point2d,fittingTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offset a curve on a brep face surface. This curve must lie on the surface.\r\n\r\n     This \r\n\r\n    overload allows to specify a surface point at which the offset will pass.\r\n\r\n  \r\n\r\n  \r\n\r\n   face: The brep face on which to offset.\r\n\r\n   throughPoint: 2d point on the brep face to offset through.\r\n\r\n   fittingTolerance: A fitting tolerance.\r\n\r\n   Returns: Offset curves on success,or null on failure.\r\n\r\n  OffsetOnSurface(self: Curve,face: BrepFace,curveParameters: Array[float],offsetDistances: Array[float],fittingTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offset a curve on a brep face surface. This curve must lie on the surface.\r\n\r\n     This \r\n\r\n    overload allows to specify different offsets for different curve parameters.\r\n\r\n  \r\n\r\n  \r\n\r\n   face: The brep face on which to offset.\r\n\r\n   curveParameters: Curve parameters corresponding to the offset distances.\r\n\r\n   offsetDistances: distances to offset (+)left,(-)right.\r\n\r\n   fittingTolerance: A fitting tolerance.\r\n\r\n   Returns: Offset curves on success,or null on failure.\r\n  \"\"\"\r\n  pass\r\n def OnSwitchToNonConst(self,*args):\r\n  \"\"\"\r\n  OnSwitchToNonConst(self: GeometryBase)\r\n\r\n   Is called when a non-const operation occurs.\r\n  \"\"\"\r\n  pass\r\n def PerpendicularFrameAt(self,t,plane):\r\n  \"\"\"\r\n  PerpendicularFrameAt(self: Curve,t: float) -> (bool,Plane)\r\n\r\n  \r\n\r\n   Return a 3d frame at a parameter. This is slightly different than FrameAt in\r\n\r\n     that \r\n\r\n    the frame is computed in a way so there is minimal rotation from one\r\n\r\n     frame to the \r\n\r\n    next.\r\n\r\n  \r\n\r\n  \r\n\r\n   t: Evaluation parameter.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def PlanarClosedCurveRelationship(curveA,curveB,testPlane,tolerance):\r\n  \"\"\"\r\n  PlanarClosedCurveRelationship(curveA: Curve,curveB: Curve,testPlane: Plane,tolerance: float) -> RegionContainment\r\n\r\n  \r\n\r\n   Determines whether two coplanar simple closed curves are disjoint or intersect;\r\n\r\n     \r\n\r\n    otherwise,if the regions have a containment relationship,discovers\r\n\r\n     which curve \r\n\r\n    encloses the other.\r\n\r\n  \r\n\r\n  \r\n\r\n   curveA: A first curve.\r\n\r\n   curveB: A second curve.\r\n\r\n   testPlane: A plane.\r\n\r\n   tolerance: A tolerance value.\r\n\r\n   Returns: A value indicating the relationship between the first and the second curve.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def PlanarCurveCollision(curveA,curveB,testPlane,tolerance):\r\n  \"\"\"\r\n  PlanarCurveCollision(curveA: Curve,curveB: Curve,testPlane: Plane,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Determines if two coplanar curves collide (intersect).\r\n\r\n  \r\n\r\n   curveA: A curve.\r\n\r\n   curveB: Another curve.\r\n\r\n   testPlane: A valid plane containing the curves.\r\n\r\n   tolerance: A tolerance value for intersection.\r\n\r\n   Returns: true if the curves intersect,otherwise false\r\n  \"\"\"\r\n  pass\r\n def PointAt(self,t):\r\n  \"\"\"\r\n  PointAt(self: Curve,t: float) -> Point3d\r\n\r\n  \r\n\r\n   Evaluates point at a curve parameter.\r\n\r\n  \r\n\r\n   t: Evaluation parameter.\r\n\r\n   Returns: Point (location of curve at the parameter t).\r\n  \"\"\"\r\n  pass\r\n def PointAtLength(self,length):\r\n  \"\"\"\r\n  PointAtLength(self: Curve,length: float) -> Point3d\r\n\r\n  \r\n\r\n   Gets a point at a certain length along the curve. The length must be \r\n\r\n     non-negative \r\n\r\n    and less than or equal to the length of the curve. \r\n\r\n     Lengths will not be wrapped \r\n\r\n    when the curve is closed or periodic.\r\n\r\n  \r\n\r\n  \r\n\r\n   length: Length along the curve between the start point and the returned point.\r\n\r\n   Returns: Point on the curve at the specified length from the start point or Poin3d.Unset on failure.\r\n  \"\"\"\r\n  pass\r\n def PointAtNormalizedLength(self,length):\r\n  \"\"\"\r\n  PointAtNormalizedLength(self: Curve,length: float) -> Point3d\r\n\r\n  \r\n\r\n   Gets a point at a certain normalized length along the curve. The length must be \r\n\r\n     \r\n\r\n    between or including 0.0 and 1.0,where 0.0 equals the start of the curve and \r\n\r\n     1.0 \r\n\r\n    equals the end of the curve.\r\n\r\n  \r\n\r\n  \r\n\r\n   length: Normalized length along the curve between the start point and the returned point.\r\n\r\n   Returns: Point on the curve at the specified normalized length from the start point or Poin3d.Unset on \r\n\r\n    failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def ProjectToBrep(*__args):\r\n  \"\"\"\r\n  ProjectToBrep(curves: IEnumerable[Curve],breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> Array[Curve]\r\n\r\n  ProjectToBrep(curves: IEnumerable[Curve],breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> (Array[Curve],Array[int],Array[int])\r\n\r\n  ProjectToBrep(curve: Curve,breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> (Array[Curve],Array[int])\r\n\r\n  ProjectToBrep(curve: Curve,brep: Brep,direction: Vector3d,tolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Projects a Curve onto a Brep along a given direction.\r\n\r\n  \r\n\r\n   curve: Curve to project.\r\n\r\n   brep: Brep to project onto.\r\n\r\n   direction: Direction of projection.\r\n\r\n   tolerance: Tolerance to use for projection.\r\n\r\n   Returns: An array of projected curves or empty array if the projection set is empty.\r\n\r\n  ProjectToBrep(curve: Curve,breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> Array[Curve]\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def ProjectToMesh(*__args):\r\n  \"\"\"\r\n  ProjectToMesh(curves: IEnumerable[Curve],meshes: IEnumerable[Mesh],direction: Vector3d,tolerance: float) -> Array[Curve]\r\n\r\n  ProjectToMesh(curve: Curve,meshes: IEnumerable[Mesh],direction: Vector3d,tolerance: float) -> Array[Curve]\r\n\r\n  ProjectToMesh(curve: Curve,mesh: Mesh,direction: Vector3d,tolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Projects a curve to a mesh using a direction and tolerance.\r\n\r\n  \r\n\r\n   curve: A curve.\r\n\r\n   mesh: A mesh.\r\n\r\n   direction: A direction vector.\r\n\r\n   tolerance: A tolerance value.\r\n\r\n   Returns: A curve array.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def ProjectToPlane(curve,plane):\r\n  \"\"\"\r\n  ProjectToPlane(curve: Curve,plane: Plane) -> Curve\r\n\r\n  \r\n\r\n   Constructs a curve by projecting an existing curve to a plane.\r\n\r\n  \r\n\r\n   curve: A curve.\r\n\r\n   plane: A plane.\r\n\r\n   Returns: The projected curve on success; null on failure.\r\n  \"\"\"\r\n  pass\r\n def PullToBrepFace(self,*__args):\r\n  \"\"\"\r\n  PullToBrepFace(curve: Curve,face: BrepFace,tolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Pull a curve to a BrepFace using closest point projection.\r\n\r\n  \r\n\r\n   curve: Curve to pull.\r\n\r\n   face: Brepface that pulls.\r\n\r\n   tolerance: Tolerance to use for pulling.\r\n\r\n   Returns: An array of pulled curves,or an empty array on failure.\r\n\r\n  PullToBrepFace(self: Curve,face: BrepFace,tolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Pulls this curve to a brep face and returns the result of that operation.\r\n\r\n  \r\n\r\n   face: A brep face.\r\n\r\n   tolerance: A tolerance value.\r\n\r\n   Returns: An array containing the resulting curves after pulling. This array could be empty.\r\n  \"\"\"\r\n  pass\r\n def PullToMesh(self,mesh,tolerance):\r\n  \"\"\"\r\n  PullToMesh(self: Curve,mesh: Mesh,tolerance: float) -> PolylineCurve\r\n\r\n  \r\n\r\n   Makes a polyline approximation of the curve and gets the closest point on the mesh for each \r\n\r\n    point on the curve. \r\n\r\n     Then it \"connects the points\" so that you have a polyline on \r\n\r\n    the mesh.\r\n\r\n  \r\n\r\n  \r\n\r\n   mesh: Mesh to project onto.\r\n\r\n   tolerance: Input tolerance (RhinoDoc.ModelAbsoluteTolerance is a good default)\r\n\r\n   Returns: A polyline curve on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def Rebuild(self,pointCount,degree,preserveTangents):\r\n  \"\"\"\r\n  Rebuild(self: Curve,pointCount: int,degree: int,preserveTangents: bool) -> NurbsCurve\r\n\r\n  \r\n\r\n   Rebuild a curve with a specific point count.\r\n\r\n  \r\n\r\n   pointCount: Number of control points in the rebuild curve.\r\n\r\n   degree: Degree of curve. Valid values are between and including 1 and 11.\r\n\r\n   preserveTangents: If true,the end tangents of the input curve will be preserved.\r\n\r\n   Returns: A Nurbs curve on success or null on failure.\r\n  \"\"\"\r\n  pass\r\n def RemoveShortSegments(self,tolerance):\r\n  \"\"\"\r\n  RemoveShortSegments(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Looks for segments that are shorter than tolerance that can be removed. \r\n\r\n     Does not \r\n\r\n    change the domain,but it will change the relative parameterization.\r\n\r\n  \r\n\r\n  \r\n\r\n   tolerance: Tolerance which defines \"short\" segments.\r\n\r\n   Returns: true if removable short segments were found. \r\n\r\n     false if no removable short segments \r\n\r\n    were found.\r\n  \"\"\"\r\n  pass\r\n def Reverse(self):\r\n  \"\"\"\r\n  Reverse(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Reverses the direction of the curve.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def SetEndPoint(self,point):\r\n  \"\"\"\r\n  SetEndPoint(self: Curve,point: Point3d) -> bool\r\n\r\n  \r\n\r\n   Forces the curve to end at a specified point. \r\n\r\n     Not all curve types support this \r\n\r\n    operation.\r\n\r\n  \r\n\r\n  \r\n\r\n   point: New end point of curve.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def SetStartPoint(self,point):\r\n  \"\"\"\r\n  SetStartPoint(self: Curve,point: Point3d) -> bool\r\n\r\n  \r\n\r\n   Forces the curve to start at a specified point. \r\n\r\n     Not all curve types support this \r\n\r\n    operation.\r\n\r\n  \r\n\r\n  \r\n\r\n   point: New start point of curve.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def Simplify(self,options,distanceTolerance,angleToleranceRadians):\r\n  \"\"\"\r\n  Simplify(self: Curve,options: CurveSimplifyOptions,distanceTolerance: float,angleToleranceRadians: float) -> Curve\r\n\r\n  \r\n\r\n   Returns a geometrically equivalent PolyCurve.\r\n\r\n     The PolyCurve has the following \r\n\r\n    properties\r\n\r\n     1. All the PolyCurve segments are LineCurve,PolylineCurve,ArcCurve,or \r\n\r\n    NurbsCurve.\r\n\r\n     \r\n\r\n     2. The Nurbs Curves segments do not have fully multiple \r\n\r\n    interior knots.\r\n\r\n     \r\n\r\n     3. Rational Nurbs curves do not have constant \r\n\r\n    weights.\r\n\r\n     \r\n\r\n     4. Any segment for which IsLinear() or IsArc() is true is a \r\n\r\n    Line,\r\n\r\n        Polyline segment,or an Arc.\r\n\r\n     \r\n\r\n     5. Adjacent \r\n\r\n    Colinear or Cocircular segments are combined.\r\n\r\n     \r\n\r\n     6. Segments that meet \r\n\r\n    with G1-continuity have there ends tuned up so\r\n\r\n        that they meet with G1-continuity \r\n\r\n    to within machine precision.\r\n\r\n  \r\n\r\n  \r\n\r\n   options: Simplification options.\r\n\r\n   distanceTolerance: A distance tolerance for the simplification.\r\n\r\n   angleToleranceRadians: An angle tolerance for the simplification.\r\n\r\n   Returns: New simplified curve on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def SimplifyEnd(self,end,options,distanceTolerance,angleToleranceRadians):\r\n  \"\"\"\r\n  SimplifyEnd(self: Curve,end: CurveEnd,options: CurveSimplifyOptions,distanceTolerance: float,angleToleranceRadians: float) -> Curve\r\n\r\n  \r\n\r\n   Same as SimplifyCurve,but simplifies only the last two segments at \"side\" end.\r\n\r\n  \r\n\r\n   end: If CurveEnd.Start the function simplifies the last two start \r\n\r\n     side segments,\r\n\r\n    otherwise if CurveEnd.End the last two end side segments are simplified.\r\n\r\n  \r\n\r\n   options: Simplification options.\r\n\r\n   distanceTolerance: A distance tolerance for the simplification.\r\n\r\n   angleToleranceRadians: An angle tolerance for the simplification.\r\n\r\n   Returns: New simplified curve on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def SpanDomain(self,spanIndex):\r\n  \"\"\"\r\n  SpanDomain(self: Curve,spanIndex: int) -> Interval\r\n\r\n  \r\n\r\n   Get the domain of the curve span with the given index. \r\n\r\n     Use the SpanCount property \r\n\r\n    to test how many spans there are.\r\n\r\n  \r\n\r\n  \r\n\r\n   spanIndex: Index of span.\r\n\r\n   Returns: Interval of the span with the given index.\r\n  \"\"\"\r\n  pass\r\n def Split(self,*__args):\r\n  \"\"\"\r\n  Split(self: Curve,cutter: Brep,tolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Splits a curve into pieces using a polysurface.\r\n\r\n  \r\n\r\n   cutter: A cutting surface or polysurface.\r\n\r\n   tolerance: A tolerance for computing intersections.\r\n\r\n   Returns: An array of curves. This array can be empty.\r\n\r\n  Split(self: Curve,cutter: Surface,tolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Splits a curve into pieces using a surface.\r\n\r\n  \r\n\r\n   cutter: A cutting surface or polysurface.\r\n\r\n   tolerance: A tolerance for computing intersections.\r\n\r\n   Returns: An array of curves. This array can be empty.\r\n\r\n  Split(self: Curve,t: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Splits (divides) the curve at the specified parameter. \r\n\r\n     The parameter must be in \r\n\r\n    the interior of the curve's domain.\r\n\r\n  \r\n\r\n  \r\n\r\n   t: Parameter to split the curve at in the interval returned by Domain().\r\n\r\n   Returns: Two curves on success,null on failure.\r\n\r\n  Split(self: Curve,t: IEnumerable[float]) -> Array[Curve]\r\n  \"\"\"\r\n  pass\r\n def TangentAt(self,t):\r\n  \"\"\"\r\n  TangentAt(self: Curve,t: float) -> Vector3d\r\n\r\n  \r\n\r\n   Evaluates the unit tangent vector at a curve parameter.\r\n\r\n  \r\n\r\n   t: Evaluation parameter.\r\n\r\n   Returns: Unit tangent vector of the curve at the parameter t.\r\n  \"\"\"\r\n  pass\r\n def ToNurbsCurve(self,subdomain=None):\r\n  \"\"\"\r\n  ToNurbsCurve(self: Curve) -> NurbsCurve\r\n\r\n  \r\n\r\n   Constructs a NURBS curve representation of this curve.\r\n\r\n   Returns: NURBS representation of the curve on success,null on failure.\r\n\r\n  ToNurbsCurve(self: Curve,subdomain: Interval) -> NurbsCurve\r\n\r\n  \r\n\r\n   Constructs a NURBS curve representation of this curve.\r\n\r\n  \r\n\r\n   subdomain: The NURBS representation for this portion of the curve is returned.\r\n\r\n   Returns: NURBS representation of the curve on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def ToPolyline(self,mainSegmentCount,subSegmentCount,maxAngleRadians,maxChordLengthRatio,maxAspectRatio,tolerance,minEdgeLength,maxEdgeLength,keepStartPoint,curveDomain=None):\r\n  \"\"\"\r\n  ToPolyline(self: Curve,mainSegmentCount: int,subSegmentCount: int,maxAngleRadians: float,maxChordLengthRatio: float,maxAspectRatio: float,tolerance: float,minEdgeLength: float,maxEdgeLength: float,keepStartPoint: bool,curveDomain: Interval) -> PolylineCurve\r\n\r\n  \r\n\r\n   Gets a polyline approximation of a curve.\r\n\r\n  \r\n\r\n   mainSegmentCount: If mainSegmentCount <= 0,then both subSegmentCount and mainSegmentCount are ignored. \r\n\r\n     \r\n\r\n    If mainSegmentCount > 0,then subSegmentCount must be >= 1. In this \r\n\r\n     case the \r\n\r\n    nurb will be broken into mainSegmentCount equally spaced \r\n\r\n     chords. If needed,each \r\n\r\n    of these chords can be split into as many \r\n\r\n     subSegmentCount sub-parts if the \r\n\r\n    subdivision is necessary for the \r\n\r\n     mesh to meet the other meshing constraints. In \r\n\r\n    particular,if \r\n\r\n     subSegmentCount=0,then the curve is broken into mainSegmentCount \r\n\r\n    \r\n\r\n     pieces and no further testing is performed.\r\n\r\n  \r\n\r\n   subSegmentCount: An amount of subsegments.\r\n\r\n   maxAngleRadians: ( 0 to pi ) Maximum angle (in radians) between unit tangents at \r\n\r\n     adjacent vertices.\r\n\r\n   maxChordLengthRatio: Maximum permitted value of \r\n\r\n     (distance chord midpoint to curve) / (length of chord).\r\n\r\n   maxAspectRatio: If maxAspectRatio < 1.0,the parameter is ignored. \r\n\r\n     If 1 <= maxAspectRatio < \r\n\r\n    sqrt(2),it is treated as if maxAspectRatio=sqrt(2). \r\n\r\n     This parameter controls the \r\n\r\n    maximum permitted value of \r\n\r\n     (length of longest chord) / (length of shortest chord).\r\n\r\n  \r\n\r\n   tolerance: If tolerance=0,the parameter is ignored. \r\n\r\n     This parameter controls the maximum \r\n\r\n    permitted value of the \r\n\r\n     distance from the curve to the polyline.\r\n\r\n  \r\n\r\n   minEdgeLength: The minimum permitted edge length.\r\n\r\n   maxEdgeLength: If maxEdgeLength=0,the parameter \r\n\r\n     is ignored. This parameter controls the \r\n\r\n    maximum permitted edge length.\r\n\r\n  \r\n\r\n   keepStartPoint: If true the starting point of the curve \r\n\r\n     is added to the polyline. If false the \r\n\r\n    starting point of the curve is \r\n\r\n     not added to the polyline.\r\n\r\n  \r\n\r\n   curveDomain: This subdomain of the NURBS curve is approximated.\r\n\r\n   Returns: PolylineCurve on success,null on error.\r\n\r\n  ToPolyline(self: Curve,mainSegmentCount: int,subSegmentCount: int,maxAngleRadians: float,maxChordLengthRatio: float,maxAspectRatio: float,tolerance: float,minEdgeLength: float,maxEdgeLength: float,keepStartPoint: bool) -> PolylineCurve\r\n\r\n  \r\n\r\n   Gets a polyline approximation of a curve.\r\n\r\n  \r\n\r\n   mainSegmentCount: If mainSegmentCount <= 0,then both subSegmentCount and mainSegmentCount are ignored. \r\n\r\n     \r\n\r\n    If mainSegmentCount > 0,then subSegmentCount must be >= 1. In this \r\n\r\n     case the \r\n\r\n    nurb will be broken into mainSegmentCount equally spaced \r\n\r\n     chords. If needed,each \r\n\r\n    of these chords can be split into as many \r\n\r\n     subSegmentCount sub-parts if the \r\n\r\n    subdivision is necessary for the \r\n\r\n     mesh to meet the other meshing constraints. In \r\n\r\n    particular,if \r\n\r\n     subSegmentCount=0,then the curve is broken into mainSegmentCount \r\n\r\n    \r\n\r\n     pieces and no further testing is performed.\r\n\r\n  \r\n\r\n   subSegmentCount: An amount of subsegments.\r\n\r\n   maxAngleRadians: ( 0 to pi ) Maximum angle (in radians) between unit tangents at \r\n\r\n     adjacent vertices.\r\n\r\n   maxChordLengthRatio: Maximum permitted value of \r\n\r\n     (distance chord midpoint to curve) / (length of chord).\r\n\r\n   maxAspectRatio: If maxAspectRatio < 1.0,the parameter is ignored. \r\n\r\n     If 1 <= maxAspectRatio < \r\n\r\n    sqrt(2),it is treated as if maxAspectRatio=sqrt(2). \r\n\r\n     This parameter controls the \r\n\r\n    maximum permitted value of \r\n\r\n     (length of longest chord) / (length of shortest chord).\r\n\r\n  \r\n\r\n   tolerance: If tolerance=0,the parameter is ignored. \r\n\r\n     This parameter controls the maximum \r\n\r\n    permitted value of the \r\n\r\n     distance from the curve to the polyline.\r\n\r\n  \r\n\r\n   minEdgeLength: The minimum permitted edge length.\r\n\r\n   maxEdgeLength: If maxEdgeLength=0,the parameter \r\n\r\n     is ignored. This parameter controls the \r\n\r\n    maximum permitted edge length.\r\n\r\n  \r\n\r\n   keepStartPoint: If true the starting point of the curve \r\n\r\n     is added to the polyline. If false the \r\n\r\n    starting point of the curve is \r\n\r\n     not added to the polyline.\r\n\r\n  \r\n\r\n   Returns: PolylineCurve on success,null on error.\r\n  \"\"\"\r\n  pass\r\n def Trim(self,*__args):\r\n  \"\"\"\r\n  Trim(self: Curve,side: CurveEnd,length: float) -> Curve\r\n\r\n  \r\n\r\n   Shortens a curve by a given length\r\n\r\n   Returns: Trimmed curve if successful,null on failure.\r\n\r\n  Trim(self: Curve,domain: Interval) -> Curve\r\n\r\n  \r\n\r\n   Removes portions of the curve outside the specified interval.\r\n\r\n  \r\n\r\n   domain: Trimming interval. Portions of the curve before curve(domain[0])\r\n\r\n     and after \r\n\r\n    curve(domain[1]) are removed.\r\n\r\n  \r\n\r\n   Returns: Trimmed curve if successful,null on failure.\r\n\r\n  Trim(self: Curve,t0: float,t1: float) -> Curve\r\n\r\n  \r\n\r\n   Removes portions of the curve outside the specified interval.\r\n\r\n  \r\n\r\n   t0: Start of the trimming interval. Portions of the curve before curve(t0) are removed.\r\n\r\n   t1: End of the trimming interval. Portions of the curve after curve(t1) are removed.\r\n\r\n   Returns: Trimmed portion of this curve is successfull,null on failure.\r\n  \"\"\"\r\n  pass\r\n def TryGetArc(self,*__args):\r\n  \"\"\"\r\n  TryGetArc(self: Curve,plane: Plane) -> (bool,Arc)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Arc using RhinoMath.ZeroTolerance.\r\n\r\n  \r\n\r\n   plane: Plane in which the comparison is performed.\r\n\r\n   Returns: true if the curve could be converted into an arc within the given plane.\r\n\r\n  TryGetArc(self: Curve,plane: Plane,tolerance: float) -> (bool,Arc)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Arc using a custom tolerance.\r\n\r\n  \r\n\r\n   plane: Plane in which the comparison is performed.\r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve could be converted into an arc within the given plane.\r\n\r\n  TryGetArc(self: Curve) -> (bool,Arc)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Arc using RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the curve could be converted into an arc.\r\n\r\n  TryGetArc(self: Curve,tolerance: float) -> (bool,Arc)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Arc using a custom tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve could be converted into an arc.\r\n  \"\"\"\r\n  pass\r\n def TryGetCircle(self,circle,tolerance=None):\r\n  \"\"\"\r\n  TryGetCircle(self: Curve,tolerance: float) -> (bool,Circle)\r\n\r\n  \r\n\r\n   Try to convert this curve into a Circle using a custom tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve could be converted into a Circle within tolerance.\r\n\r\n  TryGetCircle(self: Curve) -> (bool,Circle)\r\n\r\n  \r\n\r\n   Try to convert this curve into a circle using RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the curve could be converted into a Circle.\r\n  \"\"\"\r\n  pass\r\n def TryGetEllipse(self,*__args):\r\n  \"\"\"\r\n  TryGetEllipse(self: Curve,plane: Plane) -> (bool,Ellipse)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Ellipse within RhinoMath.ZeroTolerance.\r\n\r\n  \r\n\r\n   plane: Plane in which the comparison is performed.\r\n\r\n   Returns: true if the curve could be converted into an Ellipse within the given plane.\r\n\r\n  TryGetEllipse(self: Curve,plane: Plane,tolerance: float) -> (bool,Ellipse)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Ellipse using a custom tolerance.\r\n\r\n  \r\n\r\n   plane: Plane in which the comparison is performed.\r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve could be converted into an Ellipse within the given plane.\r\n\r\n  TryGetEllipse(self: Curve) -> (bool,Ellipse)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Ellipse within RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the curve could be converted into an Ellipse.\r\n\r\n  TryGetEllipse(self: Curve,tolerance: float) -> (bool,Ellipse)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Ellipse using a custom tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve could be converted into an Ellipse.\r\n  \"\"\"\r\n  pass\r\n def TryGetPlane(self,plane,tolerance=None):\r\n  \"\"\"\r\n  TryGetPlane(self: Curve,tolerance: float) -> (bool,Plane)\r\n\r\n  \r\n\r\n   Test a curve for planarity and return the plane.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if there is a plane such that the maximum distance from the curve to the plane is <= \r\n\r\n    tolerance.\r\n\r\n  \r\n\r\n  TryGetPlane(self: Curve) -> (bool,Plane)\r\n\r\n  \r\n\r\n   Test a curve for planarity and return the plane.\r\n\r\n   Returns: true if there is a plane such that the maximum distance from the curve to the plane is <= \r\n\r\n    RhinoMath.ZeroTolerance.\r\n  \"\"\"\r\n  pass\r\n def TryGetPolyline(self,polyline,parameters=None):\r\n  \"\"\"\r\n  TryGetPolyline(self: Curve) -> (bool,Polyline,Array[float])\r\n\r\n  \r\n\r\n   Several types of Curve can have the form of a polyline \r\n\r\n     including a degree 1 \r\n\r\n    NurbsCurve,a PolylineCurve,\r\n\r\n     and a PolyCurve all of whose segments are some form \r\n\r\n    of \r\n\r\n     polyline. IsPolyline tests a curve to see if it can be \r\n\r\n     \r\n\r\n    represented as a polyline.\r\n\r\n  \r\n\r\n   Returns: true if this curve can be represented as a polyline; otherwise,false.\r\n\r\n  TryGetPolyline(self: Curve) -> (bool,Polyline)\r\n\r\n  \r\n\r\n   Several types of Curve can have the form of a polyline \r\n\r\n     including a degree 1 \r\n\r\n    NurbsCurve,a PolylineCurve,\r\n\r\n     and a PolyCurve all of whose segments are some form \r\n\r\n    of \r\n\r\n     polyline. IsPolyline tests a curve to see if it can be \r\n\r\n     \r\n\r\n    represented as a polyline.\r\n\r\n  \r\n\r\n   Returns: true if this curve can be represented as a polyline; otherwise,false.\r\n  \"\"\"\r\n  pass\r\n def __enter__(self,*args):\r\n  \"\"\"\r\n  __enter__(self: IDisposable) -> object\r\n\r\n  \r\n\r\n   Provides the implementation of __enter__ for objects which implement IDisposable.\r\n  \"\"\"\r\n  pass\r\n def __exit__(self,*args):\r\n  \"\"\"\r\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\r\n\r\n   Provides the implementation of __exit__ for objects which implement IDisposable.\r\n  \"\"\"\r\n  pass\r\n def __init__(self,*args):\r\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n  pass\r\n @staticmethod\r\n def __new__(self,*args): #cannot find CLR constructor\r\n  \"\"\"\r\n  __new__(cls: type)\r\n\r\n  __new__(cls: type,info: SerializationInfo,context: StreamingContext)\r\n  \"\"\"\r\n  pass\r\n def __reduce_ex__(self,*args):\r\n  pass\r\n Degree=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets the maximum algebraic degree of any span\r\n\r\n   or a good estimate if curve spans are not algebraic.\r\n\r\n\r\n\r\nGet: Degree(self: Curve) -> int\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n Dimension=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets the dimension of the object.\r\n\r\n   The dimension is typically three. For parameter space trimming\r\n\r\n   curves the dimension is two. In rare cases the dimension can\r\n\r\n   be one or greater than three.\r\n\r\n\r\n\r\nGet: Dimension(self: Curve) -> int\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n Domain=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets or sets the domain of the curve.\r\n\r\n\r\n\r\nGet: Domain(self: Curve) -> Interval\r\n\r\n\r\n\r\nSet: Domain(self: Curve)=value\r\n\r\n\"\"\"\r\n\r\n IsClosed=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets a value indicating whether or not this curve is a closed curve.\r\n\r\n\r\n\r\nGet: IsClosed(self: Curve) -> bool\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n IsPeriodic=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets a value indicating whether or not this curve is considered to be Periodic.\r\n\r\n\r\n\r\nGet: IsPeriodic(self: Curve) -> bool\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n PointAtEnd=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Evaluates point at the end of the curve.\r\n\r\n\r\n\r\nGet: PointAtEnd(self: Curve) -> Point3d\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n PointAtStart=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Evaluates point at the start of the curve.\r\n\r\n\r\n\r\nGet: PointAtStart(self: Curve) -> Point3d\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n SpanCount=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets the number of non-empty smooth (c-infinity) spans in the curve.\r\n\r\n\r\n\r\nGet: SpanCount(self: Curve) -> int\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n TangentAtEnd=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Evaluate unit tangent vector at the end of the curve.\r\n\r\n\r\n\r\nGet: TangentAtEnd(self: Curve) -> Vector3d\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n TangentAtStart=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Evaluates the unit tangent vector at the start of the curve.\r\n\r\n\r\n\r\nGet: TangentAtStart(self: Curve) -> Vector3d\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n\r\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "classes", "point", "brep", "line", "dimension", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "gtalarico_ironpython-stubs_c36b448b75.json", "repo": "gtalarico/ironpython-stubs"}
{"instruction": "Represents a base class that is common to most RhinoCommon curve types.", "code": "class Curve(GeometryBase,IDisposable,ISerializable):\r\n \"\"\"\r\n Represents a base class that is common to most RhinoCommon curve types.\r\n\r\n    A curve represents an entity that can be all visited by providing\r\n\r\n    a single parameter,usually called t.\r\n \"\"\"\r\n def ChangeClosedCurveSeam(self,t):\r\n  \"\"\"\r\n  ChangeClosedCurveSeam(self: Curve,t: float) -> bool\r\n\r\n  \r\n\r\n   If this curve is closed,then modify it so that the start/end point is at curve parameter t.\r\n\r\n  \r\n\r\n   t: Curve parameter of new start/end point. The returned curves domain will start at t.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def ChangeDimension(self,desiredDimension):\r\n  \"\"\"\r\n  ChangeDimension(self: Curve,desiredDimension: int) -> bool\r\n\r\n  \r\n\r\n   Changes the dimension of a curve.\r\n\r\n  \r\n\r\n   desiredDimension: The desired dimension.\r\n\r\n   Returns: true if the curve's dimension was already desiredDimension\r\n\r\n     or if the curve's \r\n\r\n    dimension was successfully changed to desiredDimension;\r\n\r\n     otherwise false.\r\n  \"\"\"\r\n  pass\r\n def ClosedCurveOrientation(self,*__args):\r\n  \"\"\"\r\n  ClosedCurveOrientation(self: Curve,xform: Transform) -> CurveOrientation\r\n\r\n  \r\n\r\n   Determines the orientation (counterclockwise or clockwise) of a closed planar curve.\r\n\r\n       \r\n\r\n     Only works with simple (no self intersections) closed planar curves.\r\n\r\n  \r\n\r\n  \r\n\r\n   xform: Transformation to map the curve to the xy plane. If the curve is parallel\r\n\r\n     to the xy \r\n\r\n    plane,you may pass Identity matrix.\r\n\r\n  \r\n\r\n   Returns: The orientation of this curve in the world xy-plane.\r\n\r\n  ClosedCurveOrientation(self: Curve,plane: Plane) -> CurveOrientation\r\n\r\n  \r\n\r\n   Determines the orientation (counterclockwise or clockwise) of a closed planar curve in a given \r\n\r\n    plane.\r\n\r\n     Only works with simple (no self intersections) closed planar curves.\r\n\r\n  \r\n\r\n  \r\n\r\n   plane: The plane in which to solve the orientation.\r\n\r\n   Returns: The orientation of this curve in the given plane.\r\n\r\n  ClosedCurveOrientation(self: Curve,upDirection: Vector3d) -> CurveOrientation\r\n\r\n  \r\n\r\n   Determines the orientation (counterclockwise or clockwise) of a closed planar curve in a given \r\n\r\n    plane.\r\n\r\n     Only works with simple (no self intersections) closed planar curves.\r\n\r\n  \r\n\r\n  \r\n\r\n   upDirection: A vector that is considered \"up\".\r\n\r\n   Returns: The orientation of this curve with respect to a defined up direction.\r\n  \"\"\"\r\n  pass\r\n def ClosestPoint(self,testPoint,t,maximumDistance=None):\r\n  \"\"\"\r\n  ClosestPoint(self: Curve,testPoint: Point3d,maximumDistance: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Finds the parameter of the point on a curve that is closest to testPoint.\r\n\r\n     If the \r\n\r\n    maximumDistance parameter is > 0,then only points whose distance\r\n\r\n     to the given \r\n\r\n    point is <= maximumDistance will be returned.  Using a \r\n\r\n     positive value of \r\n\r\n    maximumDistance can substantially speed up the search.\r\n\r\n  \r\n\r\n  \r\n\r\n   testPoint: Point to project.\r\n\r\n   maximumDistance: The maximum allowed distance.\r\n\r\n     Past this distance,the search is given up and false \r\n\r\n    is returned.Use 0 to turn off this parameter.\r\n\r\n  \r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  ClosestPoint(self: Curve,testPoint: Point3d) -> (bool,float)\r\n\r\n  \r\n\r\n   Finds parameter of the point on a curve that is closest to testPoint.\r\n\r\n     If the \r\n\r\n    maximumDistance parameter is > 0,then only points whose distance\r\n\r\n     to the given \r\n\r\n    point is <= maximumDistance will be returned.  Using a \r\n\r\n     positive value of \r\n\r\n    maximumDistance can substantially speed up the search.\r\n\r\n  \r\n\r\n  \r\n\r\n   testPoint: Point to search from.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def ClosestPoints(self,*__args):\r\n  \"\"\"\r\n  ClosestPoints(self: Curve,otherCurve: Curve) -> (bool,Point3d,Point3d)\r\n\r\n  \r\n\r\n   Gets closest points between this and another curves.\r\n\r\n  \r\n\r\n   otherCurve: The other curve.\r\n\r\n   Returns: true on success; false on error.\r\n\r\n  ClosestPoints(self: Curve,geometry: IEnumerable[GeometryBase]) -> (bool,Point3d,Point3d,int)\r\n\r\n  ClosestPoints(self: Curve,geometry: IEnumerable[GeometryBase],maximumDistance: float) -> (bool,Point3d,Point3d,int)\r\n  \"\"\"\r\n  pass\r\n def ConstructConstObject(self,*args):\r\n  \"\"\"\r\n  ConstructConstObject(self: CommonObject,parentObject: object,subobject_index: int)\r\n\r\n   Assigns a parent object and a subobject index to this.\r\n\r\n  \r\n\r\n   parentObject: The parent object.\r\n\r\n   subobject_index: The subobject index.\r\n  \"\"\"\r\n  pass\r\n def Contains(self,testPoint,plane=None,tolerance=None):\r\n  \"\"\"\r\n  Contains(self: Curve,testPoint: Point3d,plane: Plane,tolerance: float) -> PointContainment\r\n\r\n  \r\n\r\n   Computes the relationship between a point and a closed curve region. \r\n\r\n     This curve \r\n\r\n    must be closed or the return value will be Unset.\r\n\r\n  \r\n\r\n  \r\n\r\n   testPoint: Point to test.\r\n\r\n   plane: Plane in in which to compare point and region.\r\n\r\n   tolerance: Tolerance to use during comparison.\r\n\r\n   Returns: Relationship between point and curve region.\r\n\r\n  Contains(self: Curve,testPoint: Point3d,plane: Plane) -> PointContainment\r\n\r\n  \r\n\r\n   Computes the relationship between a point and a closed curve region. \r\n\r\n     This curve \r\n\r\n    must be closed or the return value will be Unset.\r\n\r\n  \r\n\r\n  \r\n\r\n   testPoint: Point to test.\r\n\r\n   plane: Plane in in which to compare point and region.\r\n\r\n   Returns: Relationship between point and curve region.\r\n\r\n  Contains(self: Curve,testPoint: Point3d) -> PointContainment\r\n\r\n  \r\n\r\n   Computes the relationship between a point and a closed curve region. \r\n\r\n     This curve \r\n\r\n    must be closed or the return value will be Unset.\r\n\r\n     Both curve and point are \r\n\r\n    projected to the World XY plane.\r\n\r\n  \r\n\r\n  \r\n\r\n   testPoint: Point to test.\r\n\r\n   Returns: Relationship between point and curve region.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateBlendCurve(*__args):\r\n  \"\"\"\r\n  CreateBlendCurve(curve0: Curve,t0: float,reverse0: bool,continuity0: BlendContinuity,curve1: Curve,t1: float,reverse1: bool,continuity1: BlendContinuity) -> Curve\r\n\r\n  \r\n\r\n   Makes a curve blend between 2 curves at the parameters specified\r\n\r\n     with the \r\n\r\n    directions and continuities specified\r\n\r\n  \r\n\r\n  \r\n\r\n   curve0: First curve to blend from\r\n\r\n   t0: Parameter on first curve for blend endpoint\r\n\r\n   reverse0: If false,the blend will go in the natural direction of the curve.\r\n\r\n     If true,the \r\n\r\n    blend will go in the opposite direction to the curve\r\n\r\n  \r\n\r\n   continuity0: continuity for the blend at the start\r\n\r\n   curve1: Second curve to blend from\r\n\r\n   t1: Parameter on second curve for blend endpoint\r\n\r\n   reverse1: If false,the blend will go in the natural direction of the curve.\r\n\r\n     If true,the \r\n\r\n    blend will go in the opposite direction to the curve\r\n\r\n  \r\n\r\n   continuity1: continuity for the blend at the end\r\n\r\n   Returns: the blend curve on success. null on failure\r\n\r\n  CreateBlendCurve(curveA: Curve,curveB: Curve,continuity: BlendContinuity,bulgeA: float,bulgeB: float) -> Curve\r\n\r\n  \r\n\r\n   Create a Blend curve between two existing curves.\r\n\r\n  \r\n\r\n   curveA: Curve to blend from (blending will occur at curve end point).\r\n\r\n   curveB: Curve to blend to (blending will occur at curve start point).\r\n\r\n   continuity: Continuity of blend.\r\n\r\n   bulgeA: Bulge factor at curveA end of blend. Values near 1.0 work best.\r\n\r\n   bulgeB: Bulge factor at curveB end of blend. Values near 1.0 work best.\r\n\r\n   Returns: A curve representing the blend between A and B or null on failure.\r\n\r\n  CreateBlendCurve(curveA: Curve,curveB: Curve,continuity: BlendContinuity) -> Curve\r\n\r\n  \r\n\r\n   Create a Blend curve between two existing curves.\r\n\r\n  \r\n\r\n   curveA: Curve to blend from (blending will occur at curve end point).\r\n\r\n   curveB: Curve to blend to (blending will occur at curve start point).\r\n\r\n   continuity: Continuity of blend.\r\n\r\n   Returns: A curve representing the blend between A and B or null on failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateBooleanDifference(curveA,*__args):\r\n  \"\"\"\r\n  CreateBooleanDifference(curveA: Curve,subtractors: IEnumerable[Curve]) -> Array[Curve]\r\n\r\n  CreateBooleanDifference(curveA: Curve,curveB: Curve) -> Array[Curve]\r\n\r\n  \r\n\r\n   Calculates the boolean difference between two closed,planar curves. \r\n\r\n     Note,curves \r\n\r\n    must be co-planar.\r\n\r\n  \r\n\r\n  \r\n\r\n   curveA: The first closed,planar curve.\r\n\r\n   curveB: The second closed,planar curve.\r\n\r\n   Returns: Result curves on success,empty array if no difference could be calculated.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateBooleanIntersection(curveA,curveB):\r\n  \"\"\"\r\n  CreateBooleanIntersection(curveA: Curve,curveB: Curve) -> Array[Curve]\r\n\r\n  \r\n\r\n   Calculates the boolean intersection of two closed,planar curves. \r\n\r\n     Note,curves \r\n\r\n    must be co-planar.\r\n\r\n  \r\n\r\n  \r\n\r\n   curveA: The first closed,planar curve.\r\n\r\n   curveB: The second closed,planar curve.\r\n\r\n   Returns: Result curves on success,empty array if no intersection could be calculated.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateBooleanUnion(curves):\r\n  \"\"\" CreateBooleanUnion(curves: IEnumerable[Curve]) -> Array[Curve] \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateControlPointCurve(points,degree=None):\r\n  \"\"\"\r\n  CreateControlPointCurve(points: IEnumerable[Point3d]) -> Curve\r\n\r\n  CreateControlPointCurve(points: IEnumerable[Point3d],degree: int) -> Curve\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateFillet(curve0,curve1,radius,t0Base,t1Base):\r\n  \"\"\"\r\n  CreateFillet(curve0: Curve,curve1: Curve,radius: float,t0Base: float,t1Base: float) -> Arc\r\n\r\n  \r\n\r\n   Computes the fillet arc for a curve filleting operation.\r\n\r\n  \r\n\r\n   curve0: First curve to fillet.\r\n\r\n   curve1: Second curve to fillet.\r\n\r\n   radius: Fillet radius.\r\n\r\n   t0Base: Parameter on curve0 where the fillet ought to start (approximately).\r\n\r\n   t1Base: Parameter on curve1 where the fillet ought to end (approximately).\r\n\r\n   Returns: The fillet arc on success,or Arc.Unset on failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateFilletCurves(curve0,point0,curve1,point1,radius,join,trim,arcExtension,tolerance,angleTolerance):\r\n  \"\"\"\r\n  CreateFilletCurves(curve0: Curve,point0: Point3d,curve1: Curve,point1: Point3d,radius: float,join: bool,trim: bool,arcExtension: bool,tolerance: float,angleTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Creates a tangent arc between two curves and trims or extends the curves to the arc.\r\n\r\n  \r\n\r\n   curve0: The first curve to fillet.\r\n\r\n   point0: A point on the first curve that is near the end where the fillet will\r\n\r\n     be created.\r\n\r\n   curve1: The second curve to fillet.\r\n\r\n   point1: A point on the second curve that is near the end where the fillet will\r\n\r\n     be created.\r\n\r\n   radius: The radius of the fillet.\r\n\r\n   join: Join the output curves.\r\n\r\n   trim: Trim copies of the input curves to the output fillet curve.\r\n\r\n   arcExtension: Applies when arcs are filleted but need to be extended to meet the\r\n\r\n     fillet curve or \r\n\r\n    chamfer line. If true,then the arc is extended\r\n\r\n     maintaining its validity. If false,\r\n\r\n    then the arc is extended with a\r\n\r\n     line segment,which is joined to the arc converting \r\n\r\n    it to a polycurve.\r\n\r\n  \r\n\r\n   tolerance: The tolerance,generally the document's absolute tolerance.\r\n\r\n   Returns: The results of the fillet operation. The number of output curves depends\r\n\r\n     on the \r\n\r\n    input curves and the values of the parameters that were used\r\n\r\n     during the fillet \r\n\r\n    operation. In most cases,the output array will contain\r\n\r\n     either one or three curves,\r\n\r\n    although two curves can be returned if the\r\n\r\n     radius is zero and join=false.\r\n\r\n      \r\n\r\n      For example,if both join and trim=true,then the output curve\r\n\r\n     will be a \r\n\r\n    polycurve containing the fillet curve joined with trimmed copies\r\n\r\n     of the input \r\n\r\n    curves. If join=false and trim=true,then three curves,\r\n\r\n     the fillet curve and \r\n\r\n    trimmed copies of the input curves,will be returned.\r\n\r\n     If both join and trim=\r\n\r\n    false,then just the fillet curve is returned.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateInterpolatedCurve(points,degree,knots=None,startTangent=None,endTangent=None):\r\n  \"\"\"\r\n  CreateInterpolatedCurve(points: IEnumerable[Point3d],degree: int,knots: CurveKnotStyle,startTangent: Vector3d,endTangent: Vector3d) -> Curve\r\n\r\n  CreateInterpolatedCurve(points: IEnumerable[Point3d],degree: int,knots: CurveKnotStyle) -> Curve\r\n\r\n  CreateInterpolatedCurve(points: IEnumerable[Point3d],degree: int) -> Curve\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateMeanCurve(curveA,curveB,angleToleranceRadians=None):\r\n  \"\"\"\r\n  CreateMeanCurve(curveA: Curve,curveB: Curve) -> Curve\r\n\r\n  \r\n\r\n   Constructs a mean,or average,curve from two curves.\r\n\r\n  \r\n\r\n   curveA: A first curve.\r\n\r\n   curveB: A second curve.\r\n\r\n   Returns: The average curve,or null on error.\r\n\r\n  CreateMeanCurve(curveA: Curve,curveB: Curve,angleToleranceRadians: float) -> Curve\r\n\r\n  \r\n\r\n   Constructs a mean,or average,curve from two curves.\r\n\r\n  \r\n\r\n   curveA: A first curve.\r\n\r\n   curveB: A second curve.\r\n\r\n   angleToleranceRadians: The angle tolerance,in radians,used to match kinks between curves.\r\n\r\n     If you are \r\n\r\n    unsure how to set this parameter,then either use the\r\n\r\n     document's angle tolerance \r\n\r\n    RhinoDoc.AngleToleranceRadians,\r\n\r\n     or the default value (RhinoMath.UnsetValue)\r\n\r\n  \r\n\r\n   Returns: The average curve,or null on error.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateTweenCurves(curve0,curve1,numCurves):\r\n  \"\"\"\r\n  CreateTweenCurves(curve0: Curve,curve1: Curve,numCurves: int) -> Array[Curve]\r\n\r\n  \r\n\r\n   Creates curves between two open or closed input curves. Uses the control points of the curves \r\n\r\n    for finding tween curves.\r\n\r\n     That means the first control point of first curve is \r\n\r\n    matched to first control point of the second curve and so on.\r\n\r\n     There is no matching \r\n\r\n    of curves direction. Caller must match input curves direction before calling the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   curve0: The first,or starting,curve.\r\n\r\n   curve1: The second,or ending,curve.\r\n\r\n   numCurves: Number of tween curves to create.\r\n\r\n   Returns: An array of joint curves. This array can be empty.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateTweenCurvesWithMatching(curve0,curve1,numCurves):\r\n  \"\"\"\r\n  CreateTweenCurvesWithMatching(curve0: Curve,curve1: Curve,numCurves: int) -> Array[Curve]\r\n\r\n  \r\n\r\n   Creates curves between two open or closed input curves. Make the structure of input curves \r\n\r\n    compatible if needed.\r\n\r\n     Refits the input curves to have the same structure. The \r\n\r\n    resulting curves are usually more complex than input unless\r\n\r\n     input curves are \r\n\r\n    compatible and no refit is needed. There is no matching of curves direction.\r\n\r\n     Caller \r\n\r\n    must match input curves direction before calling the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   curve0: The first,or starting,curve.\r\n\r\n   curve1: The second,or ending,curve.\r\n\r\n   numCurves: Number of tween curves to create.\r\n\r\n   Returns: An array of joint curves. This array can be empty.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateTweenCurvesWithSampling(curve0,curve1,numCurves,numSamples):\r\n  \"\"\"\r\n  CreateTweenCurvesWithSampling(curve0: Curve,curve1: Curve,numCurves: int,numSamples: int) -> Array[Curve]\r\n\r\n  \r\n\r\n   Creates curves between two open or closed input curves. Use sample points method to make curves \r\n\r\n    compatible.\r\n\r\n     This is how the algorithm workd: Divides the two curves into an equal \r\n\r\n    number of points,finds the midpoint between the \r\n\r\n     corresponding points on the \r\n\r\n    curves and interpolates the tween curve through those points. There is no matching of curves\r\n\r\n     \r\n\r\n       direction. Caller must match input curves direction before calling the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   curve0: The first,or starting,curve.\r\n\r\n   curve1: The second,or ending,curve.\r\n\r\n   numCurves: Number of tween curves to create.\r\n\r\n   numSamples: Number of sample points along input curves.\r\n\r\n   Returns: >An array of joint curves. This array can be empty.\r\n  \"\"\"\r\n  pass\r\n def CurvatureAt(self,t):\r\n  \"\"\"\r\n  CurvatureAt(self: Curve,t: float) -> Vector3d\r\n\r\n  \r\n\r\n   Evaluate the curvature vector at a curve parameter.\r\n\r\n  \r\n\r\n   t: Evaluation parameter.\r\n\r\n   Returns: Curvature vector of the curve at the parameter t.\r\n  \"\"\"\r\n  pass\r\n def DerivativeAt(self,t,derivativeCount,side=None):\r\n  \"\"\"\r\n  DerivativeAt(self: Curve,t: float,derivativeCount: int,side: CurveEvaluationSide) -> Array[Vector3d]\r\n\r\n  \r\n\r\n   Evaluate the derivatives at the specified curve parameter.\r\n\r\n  \r\n\r\n   t: Curve parameter to evaluate.\r\n\r\n   derivativeCount: Number of derivatives to evaluate,must be at least 0.\r\n\r\n   side: Side of parameter to evaluate. If the parameter is at a kink,\r\n\r\n     it makes a big \r\n\r\n    difference whether the evaluation is from below or above.\r\n\r\n  \r\n\r\n   Returns: An array of vectors that represents all the derivatives starting at zero.\r\n\r\n  DerivativeAt(self: Curve,t: float,derivativeCount: int) -> Array[Vector3d]\r\n\r\n  \r\n\r\n   Evaluate the derivatives at the specified curve parameter.\r\n\r\n  \r\n\r\n   t: Curve parameter to evaluate.\r\n\r\n   derivativeCount: Number of derivatives to evaluate,must be at least 0.\r\n\r\n   Returns: An array of vectors that represents all the derivatives starting at zero.\r\n  \"\"\"\r\n  pass\r\n def Dispose(self):\r\n  \"\"\"\r\n  Dispose(self: Curve,disposing: bool)\r\n\r\n   For derived class implementers.\r\n\r\n     This method is called with argument true when class \r\n\r\n    user calls Dispose(),while with argument false when\r\n\r\n     the Garbage Collector invokes \r\n\r\n    the finalizer,or Finalize() method.You must reclaim all used unmanaged resources in both cases,\r\n\r\n    and can use this chance to call Dispose on disposable fields if the argument is true.Also,you \r\n\r\n    must call the base virtual method within your overriding method.\r\n\r\n  \r\n\r\n  \r\n\r\n   disposing: true if the call comes from the Dispose() method; false if it comes from the Garbage Collector \r\n\r\n    finalizer.\r\n  \"\"\"\r\n  pass\r\n def DivideAsContour(self,contourStart,contourEnd,interval):\r\n  \"\"\"\r\n  DivideAsContour(self: Curve,contourStart: Point3d,contourEnd: Point3d,interval: float) -> Array[Point3d]\r\n\r\n  \r\n\r\n   Divides this curve at fixed steps along a defined contour line.\r\n\r\n  \r\n\r\n   contourStart: The start of the contouring line.\r\n\r\n   contourEnd: The end of the contouring line.\r\n\r\n   interval: A distance to measure on the contouring axis.\r\n\r\n   Returns: An array of points; or null on error.\r\n  \"\"\"\r\n  pass\r\n def DivideByCount(self,segmentCount,includeEnds,points=None):\r\n  \"\"\"\r\n  DivideByCount(self: Curve,segmentCount: int,includeEnds: bool) -> (Array[float],Array[Point3d])\r\n\r\n  \r\n\r\n   Divide the curve into a number of equal-length segments.\r\n\r\n  \r\n\r\n   segmentCount: Segment count. Note that the number of division points may differ from the segment count.\r\n\r\n   includeEnds: If true,then the points at the start and end of the curve are included.\r\n\r\n   Returns: Array containing division curve parameters on success,null on failure.\r\n\r\n  DivideByCount(self: Curve,segmentCount: int,includeEnds: bool) -> Array[float]\r\n\r\n  \r\n\r\n   Divide the curve into a number of equal-length segments.\r\n\r\n  \r\n\r\n   segmentCount: Segment count. Note that the number of division points may differ from the segment count.\r\n\r\n   includeEnds: If true,then the points at the start and end of the curve are included.\r\n\r\n   Returns: List of curve parameters at the division points on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def DivideByLength(self,segmentLength,includeStart,points=None):\r\n  \"\"\"\r\n  DivideByLength(self: Curve,segmentLength: float,includeStart: bool) -> (Array[float],Array[Point3d])\r\n\r\n  \r\n\r\n   Divide the curve into specific length segments.\r\n\r\n  \r\n\r\n   segmentLength: The length of each and every segment (except potentially the last one).\r\n\r\n   includeStart: If true,then the point at the start of the curve is included.\r\n\r\n   Returns: Array containing division curve parameters if successful,null on failure.\r\n\r\n  DivideByLength(self: Curve,segmentLength: float,includeStart: bool) -> Array[float]\r\n\r\n  \r\n\r\n   Divide the curve into specific length segments.\r\n\r\n  \r\n\r\n   segmentLength: The length of each and every segment (except potentially the last one).\r\n\r\n   includeStart: If true,then the points at the start of the curve is included.\r\n\r\n   Returns: Array containing division curve parameters if successful,null on failure.\r\n  \"\"\"\r\n  pass\r\n def DivideEquidistant(self,distance):\r\n  \"\"\"\r\n  DivideEquidistant(self: Curve,distance: float) -> Array[Point3d]\r\n\r\n  \r\n\r\n   Calculates 3d points on a curve where the linear distance between the points is equal.\r\n\r\n  \r\n\r\n   distance: The distance betwen division points.\r\n\r\n   Returns: An array of equidistant points,or null on error.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def DoDirectionsMatch(curveA,curveB):\r\n  \"\"\"\r\n  DoDirectionsMatch(curveA: Curve,curveB: Curve) -> bool\r\n\r\n  \r\n\r\n   Determines whether two curves travel more or less in the same direction.\r\n\r\n  \r\n\r\n   curveA: First curve to test.\r\n\r\n   curveB: Second curve to test.\r\n\r\n   Returns: true if both curves more or less point in the same direction,\r\n\r\n     false if they point \r\n\r\n    in the opposite directions.\r\n  \"\"\"\r\n  pass\r\n def Duplicate(self):\r\n  \"\"\"\r\n  Duplicate(self: Curve) -> GeometryBase\r\n\r\n  \r\n\r\n   Constructs an exact duplicate of this Curve.\r\n  \"\"\"\r\n  pass\r\n def DuplicateCurve(self):\r\n  \"\"\"\r\n  DuplicateCurve(self: Curve) -> Curve\r\n\r\n  \r\n\r\n   Constructs an exact duplicate of this curve.\r\n\r\n   Returns: An exact copy of this curve.\r\n  \"\"\"\r\n  pass\r\n def DuplicateSegments(self):\r\n  \"\"\"\r\n  DuplicateSegments(self: Curve) -> Array[Curve]\r\n\r\n  \r\n\r\n   Polylines will be exploded into line segments. ExplodeCurves will\r\n\r\n     return the curves \r\n\r\n    in topological order.\r\n\r\n  \r\n\r\n   Returns: An array of all the segments that make up this curve.\r\n  \"\"\"\r\n  pass\r\n def Extend(self,*__args):\r\n  \"\"\"\r\n  Extend(self: Curve,side: CurveEnd,style: CurveExtensionStyle,geometry: IEnumerable[GeometryBase]) -> Curve\r\n\r\n  Extend(self: Curve,side: CurveEnd,style: CurveExtensionStyle,endPoint: Point3d) -> Curve\r\n\r\n  \r\n\r\n   Extends a curve to a point.\r\n\r\n  \r\n\r\n   side: The end of the curve to extend.\r\n\r\n   style: The style or type of extension to use.\r\n\r\n   endPoint: A new end point.\r\n\r\n   Returns: New extended curve result on success,null on failure.\r\n\r\n  Extend(self: Curve,side: CurveEnd,length: float,style: CurveExtensionStyle) -> Curve\r\n\r\n  \r\n\r\n   Extends a curve by a specific length.\r\n\r\n  \r\n\r\n   side: Curve end to extend.\r\n\r\n   length: Length to add to the curve end.\r\n\r\n   style: Extension style.\r\n\r\n   Returns: A curve with extended ends or null on failure.\r\n\r\n  Extend(self: Curve,t0: float,t1: float) -> Curve\r\n\r\n  \r\n\r\n   Where possible,analytically extends curve to include the given domain. \r\n\r\n     This will \r\n\r\n    not work on closed curves. The original curve will be identical to the \r\n\r\n     restriction \r\n\r\n    of the resulting curve to the original curve domain.\r\n\r\n  \r\n\r\n  \r\n\r\n   t0: Start of extension domain,if the start is not inside the \r\n\r\n     Domain of this curve,an \r\n\r\n    attempt will be made to extend the curve.\r\n\r\n  \r\n\r\n   t1: End of extension domain,if the end is not inside the \r\n\r\n     Domain of this curve,an \r\n\r\n    attempt will be made to extend the curve.\r\n\r\n  \r\n\r\n   Returns: Extended curve on success,null on failure.\r\n\r\n  Extend(self: Curve,domain: Interval) -> Curve\r\n\r\n  \r\n\r\n   Where possible,analytically extends curve to include the given domain. \r\n\r\n     This will \r\n\r\n    not work on closed curves. The original curve will be identical to the \r\n\r\n     restriction \r\n\r\n    of the resulting curve to the original curve domain.\r\n\r\n  \r\n\r\n  \r\n\r\n   domain: Extension domain.\r\n\r\n   Returns: Extended curve on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def ExtendByArc(self,side,geometry):\r\n  \"\"\" ExtendByArc(self: Curve,side: CurveEnd,geometry: IEnumerable[GeometryBase]) -> Curve \"\"\"\r\n  pass\r\n def ExtendByLine(self,side,geometry):\r\n  \"\"\" ExtendByLine(self: Curve,side: CurveEnd,geometry: IEnumerable[GeometryBase]) -> Curve \"\"\"\r\n  pass\r\n def ExtendOnSurface(self,side,*__args):\r\n  \"\"\"\r\n  ExtendOnSurface(self: Curve,side: CurveEnd,face: BrepFace) -> Curve\r\n\r\n  \r\n\r\n   Extends a curve on a surface.\r\n\r\n  \r\n\r\n   side: The end of the curve to extend.\r\n\r\n   face: BrepFace that contains the curve.\r\n\r\n   Returns: New extended curve result on success,null on failure.\r\n\r\n  ExtendOnSurface(self: Curve,side: CurveEnd,surface: Surface) -> Curve\r\n\r\n  \r\n\r\n   Extends a curve on a surface.\r\n\r\n  \r\n\r\n   side: The end of the curve to extend.\r\n\r\n   surface: Surface that contains the curve.\r\n\r\n   Returns: New extended curve result on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def Fair(self,distanceTolerance,angleTolerance,clampStart,clampEnd,iterations):\r\n  \"\"\"\r\n  Fair(self: Curve,distanceTolerance: float,angleTolerance: float,clampStart: int,clampEnd: int,iterations: int) -> Curve\r\n\r\n  \r\n\r\n   Fairs a curve object. Fair works best on degree 3 (cubic) curves. Attempts to \r\n\r\n     \r\n\r\n    remove large curvature variations while limiting the geometry changes to be no \r\n\r\n     \r\n\r\n    more than the specified tolerance.\r\n\r\n  \r\n\r\n  \r\n\r\n   distanceTolerance: Maximum allowed distance the faired curve is allowed to deviate from the input.\r\n\r\n   angleTolerance: (in radians) kinks with angles <= angleTolerance are smoothed out 0.05 is a good default.\r\n\r\n   clampStart: The number of (control vertices-1) to preserve at start. \r\n\r\n     0=preserve start point1 \r\n\r\n   =preserve start point and 1st derivative2=preserve start point,1st and 2nd derivative\r\n\r\n  \r\n\r\n   clampEnd: Same as clampStart.\r\n\r\n   iterations: The number of iteratoins to use in adjusting the curve.\r\n\r\n   Returns: Returns new faired Curve on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def Fit(self,degree,fitTolerance,angleTolerance):\r\n  \"\"\"\r\n  Fit(self: Curve,degree: int,fitTolerance: float,angleTolerance: float) -> Curve\r\n\r\n  \r\n\r\n   Fits a new curve through an existing curve.\r\n\r\n  \r\n\r\n   degree: The degree of the returned Curve. Must be bigger than 1.\r\n\r\n   fitTolerance: The fitting tolerance. If fitTolerance is RhinoMath.UnsetValue or <=0.0,\r\n\r\n     the \r\n\r\n    document absolute tolerance is used.\r\n\r\n  \r\n\r\n   angleTolerance: The kink smoothing tolerance in radians.\r\n\r\n     If angleTolerance is 0.0,all kinks are \r\n\r\n    smoothedIf angleTolerance is >0.0,kinks smaller than angleTolerance are smoothedIf \r\n\r\n    angleTolerance is RhinoMath.UnsetValue or <0.0,the document angle tolerance is used for the \r\n\r\n    kink smoothing\r\n\r\n  \r\n\r\n   Returns: Returns a new fitted Curve if successful,null on failure.\r\n  \"\"\"\r\n  pass\r\n def FrameAt(self,t,plane):\r\n  \"\"\"\r\n  FrameAt(self: Curve,t: float) -> (bool,Plane)\r\n\r\n  \r\n\r\n   Returns a 3d frame at a parameter.\r\n\r\n  \r\n\r\n   t: Evaluation parameter.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def GetCurveParameterFromNurbsFormParameter(self,nurbsParameter,curveParameter):\r\n  \"\"\"\r\n  GetCurveParameterFromNurbsFormParameter(self: Curve,nurbsParameter: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Convert a NURBS curve parameter to a curve parameter.\r\n\r\n  \r\n\r\n   nurbsParameter: Nurbs form parameter.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def GetDistancesBetweenCurves(curveA,curveB,tolerance,maxDistance,maxDistanceParameterA,maxDistanceParameterB,minDistance,minDistanceParameterA,minDistanceParameterB):\r\n  \"\"\"\r\n  GetDistancesBetweenCurves(curveA: Curve,curveB: Curve,tolerance: float) -> (bool,float,float,float,float,float,float)\r\n\r\n  \r\n\r\n   Computes the distances between two arbitrary curves that overlap.\r\n\r\n  \r\n\r\n   curveA: A curve.\r\n\r\n   curveB: Another curve.\r\n\r\n   tolerance: A tolerance value.\r\n\r\n   Returns: true if the operation succeeded; otherwise false.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def GetFilletPoints(curve0,curve1,radius,t0Base,t1Base,t0,t1,filletPlane):\r\n  \"\"\"\r\n  GetFilletPoints(curve0: Curve,curve1: Curve,radius: float,t0Base: float,t1Base: float) -> (bool,float,float,Plane)\r\n\r\n  \r\n\r\n   Finds points at which to cut a pair of curves so that a fillet of given radius can be inserted.\r\n\r\n  \r\n\r\n   curve0: First curve to fillet.\r\n\r\n   curve1: Second curve to fillet.\r\n\r\n   radius: Fillet radius.\r\n\r\n   t0Base: Parameter value for base point on curve0.\r\n\r\n   t1Base: Parameter value for base point on curve1.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def GetLength(self,*__args):\r\n  \"\"\"\r\n  GetLength(self: Curve,subdomain: Interval) -> float\r\n\r\n  \r\n\r\n   Get the length of a sub-section of the curve with a fractional tolerance of 1e-8.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).\r\n\r\n   Returns: The length of the sub-curve on success,or zero on failure.\r\n\r\n  GetLength(self: Curve,fractionalTolerance: float,subdomain: Interval) -> float\r\n\r\n  \r\n\r\n   Get the length of a sub-section of the curve.\r\n\r\n  \r\n\r\n   fractionalTolerance: Desired fractional precision. \r\n\r\n     fabs((\"exact\" length from start to t) - \r\n\r\n    arc_length)/arc_length <= fractionalTolerance.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).\r\n\r\n   Returns: The length of the sub-curve on success,or zero on failure.\r\n\r\n  GetLength(self: Curve) -> float\r\n\r\n  \r\n\r\n   Gets the length of the curve with a fractional tolerance of 1.0e-8.\r\n\r\n   Returns: The length of the curve on success,or zero on failure.\r\n\r\n  GetLength(self: Curve,fractionalTolerance: float) -> float\r\n\r\n  \r\n\r\n   Get the length of the curve.\r\n\r\n  \r\n\r\n   fractionalTolerance: Desired fractional precision. \r\n\r\n     fabs((\"exact\" length from start to t) - \r\n\r\n    arc_length)/arc_length <= fractionalTolerance.\r\n\r\n  \r\n\r\n   Returns: The length of the curve on success,or zero on failure.\r\n  \"\"\"\r\n  pass\r\n def GetNextDiscontinuity(self,continuityType,t0,t1,t):\r\n  \"\"\"\r\n  GetNextDiscontinuity(self: Curve,continuityType: Continuity,t0: float,t1: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Searches for a derivative,tangent,or curvature discontinuity.\r\n\r\n  \r\n\r\n   continuityType: Type of continuity to search for.\r\n\r\n   t0: Search begins at t0. If there is a discontinuity at t0,it will be ignored. This makes it\r\n\r\n     \r\n\r\n       possible to repeatedly call GetNextDiscontinuity() and step through the discontinuities.\r\n\r\n  \r\n\r\n   t1: (t0 != t1)  If there is a discontinuity at t1 it will be ignored unless continuityType is\r\n\r\n     \r\n\r\n       a locus discontinuity type and t1 is at the start or end of the curve.\r\n\r\n  \r\n\r\n   Returns: Parametric continuity tests c=(C0_continuous,...,G2_continuous):\r\n\r\n      true if a \r\n\r\n    parametric discontinuity was found strictly between t0 and t1. Note well that\r\n\r\n      all \r\n\r\n    curves are parametrically continuous at the ends of their domains.\r\n\r\n     \r\n\r\n     \r\n\r\n    Locus continuity tests c=(C0_locus_continuous,...,G2_locus_continuous):\r\n\r\n      true if \r\n\r\n    a locus discontinuity was found strictly between t0 and t1 or at t1 is the at the end\r\n\r\n      \r\n\r\n    of a curve. Note well that all open curves (IsClosed()=false) are locus discontinuous at the\r\n\r\n  \r\n\r\n        ends of their domains.  All closed curves (IsClosed()=true) are at least \r\n\r\n    C0_locus_continuous at \r\n\r\n      the ends of their domains.\r\n  \"\"\"\r\n  pass\r\n def GetNurbsFormParameterFromCurveParameter(self,curveParameter,nurbsParameter):\r\n  \"\"\"\r\n  GetNurbsFormParameterFromCurveParameter(self: Curve,curveParameter: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Convert a curve parameter to a NURBS curve parameter.\r\n\r\n  \r\n\r\n   curveParameter: Curve parameter.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def GetPerpendicularFrames(self,parameters):\r\n  \"\"\" GetPerpendicularFrames(self: Curve,parameters: IEnumerable[float]) -> Array[Plane] \"\"\"\r\n  pass\r\n def HasNurbsForm(self):\r\n  \"\"\"\r\n  HasNurbsForm(self: Curve) -> int\r\n\r\n  \r\n\r\n   Does a NURBS curve representation of this curve exist?\r\n\r\n   Returns: 0   unable to create NURBS representation with desired accuracy.\r\n\r\n     1   success - \r\n\r\n    NURBS parameterization matches the curve's to the desired accuracy\r\n\r\n     2   success - \r\n\r\n    NURBS point locus matches the curve's and the domain of the NURBS\r\n\r\n          \r\n\r\n    curve is correct. However,This curve's parameterization and the\r\n\r\n          \r\n\r\n    NURBS curve parameterization may not match. This situation happens\r\n\r\n          \r\n\r\n    when getting NURBS representations of curves that have a\r\n\r\n          \r\n\r\n    transendental parameterization like circles.\r\n  \"\"\"\r\n  pass\r\n def IsArc(self,tolerance=None):\r\n  \"\"\"\r\n  IsArc(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it can be represented by an arc or circle within the given tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve can be represented by an arc or a circle within tolerance.\r\n\r\n  IsArc(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it can be represented by an arc or circle within RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the curve can be represented by an arc or a circle within tolerance.\r\n  \"\"\"\r\n  pass\r\n def IsCircle(self,tolerance=None):\r\n  \"\"\"\r\n  IsCircle(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it can be represented by a circle within the given tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve can be represented by a circle to within tolerance.\r\n\r\n  IsCircle(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it can be represented by a circle within RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the Curve can be represented by a circle within tolerance.\r\n  \"\"\"\r\n  pass\r\n def IsClosable(self,tolerance,minimumAbsoluteSize=None,minimumRelativeSize=None):\r\n  \"\"\"\r\n  IsClosable(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Decide if it makes sense to close off this curve by moving the endpoint \r\n\r\n     to the \r\n\r\n    start based on start-end gap size and length of curve as \r\n\r\n     approximated by chord \r\n\r\n    defined by 6 points.\r\n\r\n  \r\n\r\n  \r\n\r\n   tolerance: Maximum allowable distance between start and end. \r\n\r\n     If start - end gap is greater \r\n\r\n    than tolerance,this function will return false.\r\n\r\n  \r\n\r\n   Returns: true if start and end points are close enough based on above conditions.\r\n\r\n  IsClosable(self: Curve,tolerance: float,minimumAbsoluteSize: float,minimumRelativeSize: float) -> bool\r\n\r\n  \r\n\r\n   Decide if it makes sense to close off this curve by moving the endpoint\r\n\r\n     to the \r\n\r\n    start based on start-end gap size and length of curve as\r\n\r\n     approximated by chord \r\n\r\n    defined by 6 points.\r\n\r\n  \r\n\r\n  \r\n\r\n   tolerance: Maximum allowable distance between start and end. \r\n\r\n     If start - end gap is greater \r\n\r\n    than tolerance,this function will return false.\r\n\r\n  \r\n\r\n   minimumAbsoluteSize: If greater than 0.0 and none of the interior sampled points are at\r\n\r\n     least \r\n\r\n    minimumAbsoluteSize from start,this function will return false.\r\n\r\n  \r\n\r\n   minimumRelativeSize: If greater than 1.0 and chord length is less than \r\n\r\n     minimumRelativeSize*gap,this \r\n\r\n    function will return false.\r\n\r\n  \r\n\r\n   Returns: true if start and end points are close enough based on above conditions.\r\n  \"\"\"\r\n  pass\r\n def IsContinuous(self,continuityType,t):\r\n  \"\"\"\r\n  IsContinuous(self: Curve,continuityType: Continuity,t: float) -> bool\r\n\r\n  \r\n\r\n   Test continuity at a curve parameter value.\r\n\r\n  \r\n\r\n   continuityType: Type of continuity to test for.\r\n\r\n   t: Parameter to test.\r\n\r\n   Returns: true if the curve has at least the c type continuity at the parameter t.\r\n  \"\"\"\r\n  pass\r\n def IsEllipse(self,tolerance=None):\r\n  \"\"\"\r\n  IsEllipse(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it can be represented by an ellipse within a given tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use for checking.\r\n\r\n   Returns: true if the Curve can be represented by an ellipse within tolerance.\r\n\r\n  IsEllipse(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it can be represented by an ellipse within RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the Curve can be represented by an ellipse within tolerance.\r\n  \"\"\"\r\n  pass\r\n def IsInPlane(self,testPlane,tolerance=None):\r\n  \"\"\"\r\n  IsInPlane(self: Curve,testPlane: Plane,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it lies in a specific plane.\r\n\r\n  \r\n\r\n   testPlane: Plane to test for.\r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the maximum distance from the curve to the testPlane is <= tolerance.\r\n\r\n  IsInPlane(self: Curve,testPlane: Plane) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it lies in a specific plane.\r\n\r\n  \r\n\r\n   testPlane: Plane to test for.\r\n\r\n   Returns: true if the maximum distance from the curve to the testPlane is <= RhinoMath.ZeroTolerance.\r\n  \"\"\"\r\n  pass\r\n def IsLinear(self,tolerance=None):\r\n  \"\"\"\r\n  IsLinear(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it is linear to within the custom tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking linearity.\r\n\r\n   Returns: true if the ends of the curve are farther than tolerance apart\r\n\r\n     and the maximum \r\n\r\n    distance from any point on the curve to\r\n\r\n     the line segment connecting the curve ends \r\n\r\n    is <= tolerance.\r\n\r\n  \r\n\r\n  IsLinear(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it is linear to within RhinoMath.ZeroTolerance units (1e-12).\r\n\r\n   Returns: true if the curve is linear.\r\n  \"\"\"\r\n  pass\r\n def IsPlanar(self,tolerance=None):\r\n  \"\"\"\r\n  IsPlanar(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Test a curve for planarity.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if there is a plane such that the maximum distance from the curve to the plane is <= \r\n\r\n    tolerance.\r\n\r\n  \r\n\r\n  IsPlanar(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Test a curve for planarity.\r\n\r\n   Returns: true if the curve is planar (flat) to within RhinoMath.ZeroTolerance units (1e-12).\r\n  \"\"\"\r\n  pass\r\n def IsPolyline(self):\r\n  \"\"\"\r\n  IsPolyline(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Several types of Curve can have the form of a polyline\r\n\r\n     including a degree 1 \r\n\r\n    NurbsCurve,a PolylineCurve,\r\n\r\n     and a PolyCurve all of whose segments are some form of\r\n\r\n\r\n    \r\n     polyline. IsPolyline tests a curve to see if it can be\r\n\r\n     represented as \r\n\r\n    a polyline.\r\n\r\n  \r\n\r\n   Returns: true if this curve can be represented as a polyline; otherwise,false.\r\n  \"\"\"\r\n  pass\r\n def IsShort(self,tolerance,subdomain=None):\r\n  \"\"\"\r\n  IsShort(self: Curve,tolerance: float,subdomain: Interval) -> bool\r\n\r\n  \r\n\r\n   Used to quickly find short curves.\r\n\r\n  \r\n\r\n   tolerance: Length threshold value for \"shortness\".\r\n\r\n   subdomain: The test is performed on the interval that is the intersection of subdomain with Domain()\r\n\r\n   Returns: true if the length of the curve is <= tolerance.\r\n\r\n  IsShort(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Used to quickly find short curves.\r\n\r\n  \r\n\r\n   tolerance: Length threshold value for \"shortness\".\r\n\r\n   Returns: true if the length of the curve is <= tolerance.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def JoinCurves(inputCurves,joinTolerance=None,preserveDirection=None):\r\n  \"\"\"\r\n  JoinCurves(inputCurves: IEnumerable[Curve],joinTolerance: float,preserveDirection: bool) -> Array[Curve]\r\n\r\n  JoinCurves(inputCurves: IEnumerable[Curve],joinTolerance: float) -> Array[Curve]\r\n\r\n  JoinCurves(inputCurves: IEnumerable[Curve]) -> Array[Curve]\r\n  \"\"\"\r\n  pass\r\n def LengthParameter(self,segmentLength,t,*__args):\r\n  \"\"\"\r\n  LengthParameter(self: Curve,segmentLength: float,subdomain: Interval) -> (bool,float)\r\n\r\n  \r\n\r\n   Gets the parameter along the curve which coincides with a given length along the curve. \r\n\r\n      \r\n\r\n      A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the subdomain.\r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve rather than the whole \r\n\r\n    curve.\r\n\r\n  \r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  LengthParameter(self: Curve,segmentLength: float,fractionalTolerance: float,subdomain: Interval) -> (bool,float)\r\n\r\n  \r\n\r\n   Gets the parameter along the curve which coincides with a given length along the curve.\r\n\r\n  \r\n\r\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the subdomain.\r\n\r\n   fractionalTolerance: Desired fractional precision. \r\n\r\n     fabs((\"exact\" length from start to t) - \r\n\r\n    arc_length)/arc_length <= fractionalTolerance.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve rather than the whole \r\n\r\n    curve.\r\n\r\n  \r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  LengthParameter(self: Curve,segmentLength: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Gets the parameter along the curve which coincides with a given length along the curve. \r\n\r\n      \r\n\r\n      A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the curve.\r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  LengthParameter(self: Curve,segmentLength: float,fractionalTolerance: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Gets the parameter along the curve which coincides with a given length along the curve.\r\n\r\n  \r\n\r\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the curve.\r\n\r\n   fractionalTolerance: Desired fractional precision.\r\n\r\n     fabs((\"exact\" length from start to t) - \r\n\r\n    arc_length)/arc_length <= fractionalTolerance.\r\n\r\n  \r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def MakeClosed(self,tolerance):\r\n  \"\"\"\r\n  MakeClosed(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   If IsClosed,just return true. Otherwise,decide if curve can be closed as \r\n\r\n     \r\n\r\n    follows: Linear curves polylinear curves with 2 segments,Nurbs with 3 or less \r\n\r\n     \r\n\r\n    control points cannot be made closed. Also,if tolerance > 0 and the gap between \r\n\r\n     \r\n\r\n    start and end is larger than tolerance,curve cannot be made closed. \r\n\r\n     Adjust the \r\n\r\n    curve's endpoint to match its start point.\r\n\r\n  \r\n\r\n  \r\n\r\n   tolerance: If nonzero,and the gap is more than tolerance,curve cannot be made closed.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def MakeEndsMeet(curveA,adjustStartCurveA,curveB,adjustStartCurveB):\r\n  \"\"\"\r\n  MakeEndsMeet(curveA: Curve,adjustStartCurveA: bool,curveB: Curve,adjustStartCurveB: bool) -> bool\r\n\r\n  \r\n\r\n   Makes adjustments to the ends of one or both input curves so that they meet at a point.\r\n\r\n  \r\n\r\n   curveA: 1st curve to adjust.\r\n\r\n   adjustStartCurveA: Which end of the 1st curve to adjust: true is start,false is end.\r\n\r\n   curveB: 2nd curve to adjust.\r\n\r\n   adjustStartCurveB: which end of the 2nd curve to adjust true==start,false==end.\r\n\r\n   Returns: true on success.\r\n  \"\"\"\r\n  pass\r\n def NonConstOperation(self,*args):\r\n  \"\"\"\r\n  NonConstOperation(self: Curve)\r\n\r\n   For derived classes implementers.\r\n\r\n     Defines the necessary implementation to free the \r\n\r\n    instance from being const.\r\n  \"\"\"\r\n  pass\r\n def NormalizedLengthParameter(self,s,t,*__args):\r\n  \"\"\"\r\n  NormalizedLengthParameter(self: Curve,s: float,subdomain: Interval) -> (bool,float)\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve. \r\n\r\n     A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Normalized arc length parameter. \r\n\r\n     E.g.,0=start of curve,1/2=midpoint of \r\n\r\n    curve,1=end of curve.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve.\r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  NormalizedLengthParameter(self: Curve,s: float,fractionalTolerance: float,subdomain: Interval) -> (bool,float)\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Normalized arc length parameter. \r\n\r\n     E.g.,0=start of curve,1/2=midpoint of \r\n\r\n    curve,1=end of curve.\r\n\r\n  \r\n\r\n   fractionalTolerance: Desired fractional precision. \r\n\r\n     fabs((\"exact\" length from start to t) - \r\n\r\n    arc_length)/arc_length <= fractionalTolerance.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve.\r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  NormalizedLengthParameter(self: Curve,s: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve. \r\n\r\n     A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Normalized arc length parameter. \r\n\r\n     E.g.,0=start of curve,1/2=midpoint of \r\n\r\n    curve,1=end of curve.\r\n\r\n  \r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  NormalizedLengthParameter(self: Curve,s: float,fractionalTolerance: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Normalized arc length parameter. \r\n\r\n     E.g.,0=start of curve,1/2=midpoint of \r\n\r\n    curve,1=end of curve.\r\n\r\n  \r\n\r\n   fractionalTolerance: Desired fractional precision. \r\n\r\n     fabs((\"exact\" length from start to t) - \r\n\r\n    arc_length)/arc_length <= fractionalTolerance.\r\n\r\n  \r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def NormalizedLengthParameters(self,s,absoluteTolerance,*__args):\r\n  \"\"\"\r\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float,subdomain: Interval) -> Array[float]\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve. \r\n\r\n     A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Array of normalized arc length parameters. \r\n\r\n     E.g.,0=start of curve,1/2=\r\n\r\n    midpoint of curve,1=end of curve.\r\n\r\n  \r\n\r\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \r\n\r\n     \r\n\r\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve. \r\n\r\n     A 0.0 s \r\n\r\n    value corresponds to subdomain->Min() and a 1.0 s value corresponds to subdomain->Max().\r\n\r\n  \r\n\r\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \r\n\r\n    t[i] is s[i]*curve_length. \r\n\r\n     Null on failure.\r\n\r\n  \r\n\r\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float,fractionalTolerance: float,subdomain: Interval) -> Array[float]\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Array of normalized arc length parameters. \r\n\r\n     E.g.,0=start of curve,1/2=\r\n\r\n    midpoint of curve,1=end of curve.\r\n\r\n  \r\n\r\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \r\n\r\n     \r\n\r\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\r\n\r\n  \r\n\r\n   fractionalTolerance: Desired fractional precision for each segment. \r\n\r\n     fabs(\"true\" length - actual \r\n\r\n    length)/(actual length) <= fractionalTolerance.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve. \r\n\r\n     A 0.0 s \r\n\r\n    value corresponds to subdomain->Min() and a 1.0 s value corresponds to subdomain->Max().\r\n\r\n  \r\n\r\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \r\n\r\n    t[i] is s[i]*curve_length. \r\n\r\n     Null on failure.\r\n\r\n  \r\n\r\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float) -> Array[float]\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve. \r\n\r\n     A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Array of normalized arc length parameters. \r\n\r\n     E.g.,0=start of curve,1/2=\r\n\r\n    midpoint of curve,1=end of curve.\r\n\r\n  \r\n\r\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \r\n\r\n     \r\n\r\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\r\n\r\n  \r\n\r\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \r\n\r\n    t[i] is s[i]*curve_length. \r\n\r\n     Null on failure.\r\n\r\n  \r\n\r\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float,fractionalTolerance: float) -> Array[float]\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Array of normalized arc length parameters. \r\n\r\n     E.g.,0=start of curve,1/2=\r\n\r\n    midpoint of curve,1=end of curve.\r\n\r\n  \r\n\r\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \r\n\r\n     \r\n\r\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\r\n\r\n  \r\n\r\n   fractionalTolerance: Desired fractional precision for each segment. \r\n\r\n     fabs(\"true\" length - actual \r\n\r\n    length)/(actual length) <= fractionalTolerance.\r\n\r\n  \r\n\r\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \r\n\r\n    t[i] is s[i]*curve_length. \r\n\r\n     Null on failure.\r\n  \"\"\"\r\n  pass\r\n def Offset(self,*__args):\r\n  \"\"\"\r\n  Offset(self: Curve,directionPoint: Point3d,normal: Vector3d,distance: float,tolerance: float,cornerStyle: CurveOffsetCornerStyle) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offsets this curve. If you have a nice offset,then there will be one entry in \r\n\r\n     the \r\n\r\n    array. If the original curve had kinks or the offset curve had self \r\n\r\n     intersections,\r\n\r\n    you will get multiple segments in the offset_curves[] array.\r\n\r\n  \r\n\r\n  \r\n\r\n   directionPoint: A point that indicates the direction of the offset.\r\n\r\n   normal: The normal to the offset plane.\r\n\r\n   distance: The positive or negative distance to offset.\r\n\r\n   tolerance: The offset or fitting tolerance.\r\n\r\n   cornerStyle: Corner style for offset kinks.\r\n\r\n   Returns: Offset curves on success,null on failure.\r\n\r\n  Offset(self: Curve,plane: Plane,distance: float,tolerance: float,cornerStyle: CurveOffsetCornerStyle) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offsets this curve. If you have a nice offset,then there will be one entry in \r\n\r\n     the \r\n\r\n    array. If the original curve had kinks or the offset curve had self \r\n\r\n     intersections,\r\n\r\n    you will get multiple segments in the offset_curves[] array.\r\n\r\n  \r\n\r\n  \r\n\r\n   plane: Offset solution plane.\r\n\r\n   distance: The positive or negative distance to offset.\r\n\r\n   tolerance: The offset or fitting tolerance.\r\n\r\n   cornerStyle: Corner style for offset kinks.\r\n\r\n   Returns: Offset curves on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def OffsetNormalToSurface(self,surface,height):\r\n  \"\"\"\r\n  OffsetNormalToSurface(self: Curve,surface: Surface,height: float) -> Curve\r\n\r\n  \r\n\r\n   Finds a curve by offsetting an existing curve normal to a surface.\r\n\r\n     The caller is \r\n\r\n    responsible for ensuring that the curve lies on the input surface.\r\n\r\n  \r\n\r\n  \r\n\r\n   surface: Surface from which normals are calculated.\r\n\r\n   height: offset distance (distance from surface to result curve)\r\n\r\n   Returns: Offset curve at distance height from the surface.  The offset curve is\r\n\r\n     interpolated \r\n\r\n    through a small number of points so if the surface is irregular\r\n\r\n     or complicated,the \r\n\r\n    result will not be a very accurate offset.\r\n  \"\"\"\r\n  pass\r\n def OffsetOnSurface(self,*__args):\r\n  \"\"\"\r\n  OffsetOnSurface(self: Curve,surface: Surface,distance: float,fittingTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offset a curve on a surface. This curve must lie on the surface.\r\n\r\n  \r\n\r\n   surface: A surface on which to offset.\r\n\r\n   distance: A distance to offset (+)left,(-)right.\r\n\r\n   fittingTolerance: A fitting tolerance.\r\n\r\n   Returns: Offset curves on success,or null on failure.\r\n\r\n  OffsetOnSurface(self: Curve,surface: Surface,throughPoint: Point2d,fittingTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offset a curve on a surface. This curve must lie on the surface.\r\n\r\n     This overload \r\n\r\n    allows to specify a surface point at which the offset will pass.\r\n\r\n  \r\n\r\n  \r\n\r\n   surface: A surface on which to offset.\r\n\r\n   throughPoint: 2d point on the brep face to offset through.\r\n\r\n   fittingTolerance: A fitting tolerance.\r\n\r\n   Returns: Offset curves on success,or null on failure.\r\n\r\n  OffsetOnSurface(self: Curve,surface: Surface,curveParameters: Array[float],offsetDistances: Array[float],fittingTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offset this curve on a surface. This curve must lie on the surface.\r\n\r\n     This overload \r\n\r\n    allows to specify different offsets for different curve parameters.\r\n\r\n  \r\n\r\n  \r\n\r\n   surface: A surface on which to offset.\r\n\r\n   curveParameters: Curve parameters corresponding to the offset distances.\r\n\r\n   offsetDistances: Distances to offset (+)left,(-)right.\r\n\r\n   fittingTolerance: A fitting tolerance.\r\n\r\n   Returns: Offset curves on success,or null on failure.\r\n\r\n  OffsetOnSurface(self: Curve,face: BrepFace,distance: float,fittingTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offset this curve on a brep face surface. This curve must lie on the surface.\r\n\r\n  \r\n\r\n   face: The brep face on which to offset.\r\n\r\n   distance: A distance to offset (+)left,(-)right.\r\n\r\n   fittingTolerance: A fitting tolerance.\r\n\r\n   Returns: Offset curves on success,or null on failure.\r\n\r\n  OffsetOnSurface(self: Curve,face: BrepFace,throughPoint: Point2d,fittingTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offset a curve on a brep face surface. This curve must lie on the surface.\r\n\r\n     This \r\n\r\n    overload allows to specify a surface point at which the offset will pass.\r\n\r\n  \r\n\r\n  \r\n\r\n   face: The brep face on which to offset.\r\n\r\n   throughPoint: 2d point on the brep face to offset through.\r\n\r\n   fittingTolerance: A fitting tolerance.\r\n\r\n   Returns: Offset curves on success,or null on failure.\r\n\r\n  OffsetOnSurface(self: Curve,face: BrepFace,curveParameters: Array[float],offsetDistances: Array[float],fittingTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offset a curve on a brep face surface. This curve must lie on the surface.\r\n\r\n     This \r\n\r\n    overload allows to specify different offsets for different curve parameters.\r\n\r\n  \r\n\r\n  \r\n\r\n   face: The brep face on which to offset.\r\n\r\n   curveParameters: Curve parameters corresponding to the offset distances.\r\n\r\n   offsetDistances: distances to offset (+)left,(-)right.\r\n\r\n   fittingTolerance: A fitting tolerance.\r\n\r\n   Returns: Offset curves on success,or null on failure.\r\n  \"\"\"\r\n  pass\r\n def OnSwitchToNonConst(self,*args):\r\n  \"\"\"\r\n  OnSwitchToNonConst(self: GeometryBase)\r\n\r\n   Is called when a non-const operation occurs.\r\n  \"\"\"\r\n  pass\r\n def PerpendicularFrameAt(self,t,plane):\r\n  \"\"\"\r\n  PerpendicularFrameAt(self: Curve,t: float) -> (bool,Plane)\r\n\r\n  \r\n\r\n   Return a 3d frame at a parameter. This is slightly different than FrameAt in\r\n\r\n     that \r\n\r\n    the frame is computed in a way so there is minimal rotation from one\r\n\r\n     frame to the \r\n\r\n    next.\r\n\r\n  \r\n\r\n  \r\n\r\n   t: Evaluation parameter.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def PlanarClosedCurveRelationship(curveA,curveB,testPlane,tolerance):\r\n  \"\"\"\r\n  PlanarClosedCurveRelationship(curveA: Curve,curveB: Curve,testPlane: Plane,tolerance: float) -> RegionContainment\r\n\r\n  \r\n\r\n   Determines whether two coplanar simple closed curves are disjoint or intersect;\r\n\r\n     \r\n\r\n    otherwise,if the regions have a containment relationship,discovers\r\n\r\n     which curve \r\n\r\n    encloses the other.\r\n\r\n  \r\n\r\n  \r\n\r\n   curveA: A first curve.\r\n\r\n   curveB: A second curve.\r\n\r\n   testPlane: A plane.\r\n\r\n   tolerance: A tolerance value.\r\n\r\n   Returns: A value indicating the relationship between the first and the second curve.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def PlanarCurveCollision(curveA,curveB,testPlane,tolerance):\r\n  \"\"\"\r\n  PlanarCurveCollision(curveA: Curve,curveB: Curve,testPlane: Plane,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Determines if two coplanar curves collide (intersect).\r\n\r\n  \r\n\r\n   curveA: A curve.\r\n\r\n   curveB: Another curve.\r\n\r\n   testPlane: A valid plane containing the curves.\r\n\r\n   tolerance: A tolerance value for intersection.\r\n\r\n   Returns: true if the curves intersect,otherwise false\r\n  \"\"\"\r\n  pass\r\n def PointAt(self,t):\r\n  \"\"\"\r\n  PointAt(self: Curve,t: float) -> Point3d\r\n\r\n  \r\n\r\n   Evaluates point at a curve parameter.\r\n\r\n  \r\n\r\n   t: Evaluation parameter.\r\n\r\n   Returns: Point (location of curve at the parameter t).\r\n  \"\"\"\r\n  pass\r\n def PointAtLength(self,length):\r\n  \"\"\"\r\n  PointAtLength(self: Curve,length: float) -> Point3d\r\n\r\n  \r\n\r\n   Gets a point at a certain length along the curve. The length must be \r\n\r\n     non-negative \r\n\r\n    and less than or equal to the length of the curve. \r\n\r\n     Lengths will not be wrapped \r\n\r\n    when the curve is closed or periodic.\r\n\r\n  \r\n\r\n  \r\n\r\n   length: Length along the curve between the start point and the returned point.\r\n\r\n   Returns: Point on the curve at the specified length from the start point or Poin3d.Unset on failure.\r\n  \"\"\"\r\n  pass\r\n def PointAtNormalizedLength(self,length):\r\n  \"\"\"\r\n  PointAtNormalizedLength(self: Curve,length: float) -> Point3d\r\n\r\n  \r\n\r\n   Gets a point at a certain normalized length along the curve. The length must be \r\n\r\n     \r\n\r\n    between or including 0.0 and 1.0,where 0.0 equals the start of the curve and \r\n\r\n     1.0 \r\n\r\n    equals the end of the curve.\r\n\r\n  \r\n\r\n  \r\n\r\n   length: Normalized length along the curve between the start point and the returned point.\r\n\r\n   Returns: Point on the curve at the specified normalized length from the start point or Poin3d.Unset on \r\n\r\n    failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def ProjectToBrep(*__args):\r\n  \"\"\"\r\n  ProjectToBrep(curves: IEnumerable[Curve],breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> Array[Curve]\r\n\r\n  ProjectToBrep(curves: IEnumerable[Curve],breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> (Array[Curve],Array[int],Array[int])\r\n\r\n  ProjectToBrep(curve: Curve,breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> (Array[Curve],Array[int])\r\n\r\n  ProjectToBrep(curve: Curve,brep: Brep,direction: Vector3d,tolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Projects a Curve onto a Brep along a given direction.\r\n\r\n  \r\n\r\n   curve: Curve to project.\r\n\r\n   brep: Brep to project onto.\r\n\r\n   direction: Direction of projection.\r\n\r\n   tolerance: Tolerance to use for projection.\r\n\r\n   Returns: An array of projected curves or empty array if the projection set is empty.\r\n\r\n  ProjectToBrep(curve: Curve,breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> Array[Curve]\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def ProjectToMesh(*__args):\r\n  \"\"\"\r\n  ProjectToMesh(curves: IEnumerable[Curve],meshes: IEnumerable[Mesh],direction: Vector3d,tolerance: float) -> Array[Curve]\r\n\r\n  ProjectToMesh(curve: Curve,meshes: IEnumerable[Mesh],direction: Vector3d,tolerance: float) -> Array[Curve]\r\n\r\n  ProjectToMesh(curve: Curve,mesh: Mesh,direction: Vector3d,tolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Projects a curve to a mesh using a direction and tolerance.\r\n\r\n  \r\n\r\n   curve: A curve.\r\n\r\n   mesh: A mesh.\r\n\r\n   direction: A direction vector.\r\n\r\n   tolerance: A tolerance value.\r\n\r\n   Returns: A curve array.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def ProjectToPlane(curve,plane):\r\n  \"\"\"\r\n  ProjectToPlane(curve: Curve,plane: Plane) -> Curve\r\n\r\n  \r\n\r\n   Constructs a curve by projecting an existing curve to a plane.\r\n\r\n  \r\n\r\n   curve: A curve.\r\n\r\n   plane: A plane.\r\n\r\n   Returns: The projected curve on success; null on failure.\r\n  \"\"\"\r\n  pass\r\n def PullToBrepFace(self,*__args):\r\n  \"\"\"\r\n  PullToBrepFace(curve: Curve,face: BrepFace,tolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Pull a curve to a BrepFace using closest point projection.\r\n\r\n  \r\n\r\n   curve: Curve to pull.\r\n\r\n   face: Brepface that pulls.\r\n\r\n   tolerance: Tolerance to use for pulling.\r\n\r\n   Returns: An array of pulled curves,or an empty array on failure.\r\n\r\n  PullToBrepFace(self: Curve,face: BrepFace,tolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Pulls this curve to a brep face and returns the result of that operation.\r\n\r\n  \r\n\r\n   face: A brep face.\r\n\r\n   tolerance: A tolerance value.\r\n\r\n   Returns: An array containing the resulting curves after pulling. This array could be empty.\r\n  \"\"\"\r\n  pass\r\n def PullToMesh(self,mesh,tolerance):\r\n  \"\"\"\r\n  PullToMesh(self: Curve,mesh: Mesh,tolerance: float) -> PolylineCurve\r\n\r\n  \r\n\r\n   Makes a polyline approximation of the curve and gets the closest point on the mesh for each \r\n\r\n    point on the curve. \r\n\r\n     Then it \"connects the points\" so that you have a polyline on \r\n\r\n    the mesh.\r\n\r\n  \r\n\r\n  \r\n\r\n   mesh: Mesh to project onto.\r\n\r\n   tolerance: Input tolerance (RhinoDoc.ModelAbsoluteTolerance is a good default)\r\n\r\n   Returns: A polyline curve on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def Rebuild(self,pointCount,degree,preserveTangents):\r\n  \"\"\"\r\n  Rebuild(self: Curve,pointCount: int,degree: int,preserveTangents: bool) -> NurbsCurve\r\n\r\n  \r\n\r\n   Rebuild a curve with a specific point count.\r\n\r\n  \r\n\r\n   pointCount: Number of control points in the rebuild curve.\r\n\r\n   degree: Degree of curve. Valid values are between and including 1 and 11.\r\n\r\n   preserveTangents: If true,the end tangents of the input curve will be preserved.\r\n\r\n   Returns: A Nurbs curve on success or null on failure.\r\n  \"\"\"\r\n  pass\r\n def RemoveShortSegments(self,tolerance):\r\n  \"\"\"\r\n  RemoveShortSegments(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Looks for segments that are shorter than tolerance that can be removed. \r\n\r\n     Does not \r\n\r\n    change the domain,but it will change the relative parameterization.\r\n\r\n  \r\n\r\n  \r\n\r\n   tolerance: Tolerance which defines \"short\" segments.\r\n\r\n   Returns: true if removable short segments were found. \r\n\r\n     false if no removable short segments \r\n\r\n    were found.\r\n  \"\"\"\r\n  pass\r\n def Reverse(self):\r\n  \"\"\"\r\n  Reverse(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Reverses the direction of the curve.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def SetEndPoint(self,point):\r\n  \"\"\"\r\n  SetEndPoint(self: Curve,point: Point3d) -> bool\r\n\r\n  \r\n\r\n   Forces the curve to end at a specified point. \r\n\r\n     Not all curve types support this \r\n\r\n    operation.\r\n\r\n  \r\n\r\n  \r\n\r\n   point: New end point of curve.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def SetStartPoint(self,point):\r\n  \"\"\"\r\n  SetStartPoint(self: Curve,point: Point3d) -> bool\r\n\r\n  \r\n\r\n   Forces the curve to start at a specified point. \r\n\r\n     Not all curve types support this \r\n\r\n    operation.\r\n\r\n  \r\n\r\n  \r\n\r\n   point: New start point of curve.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def Simplify(self,options,distanceTolerance,angleToleranceRadians):\r\n  \"\"\"\r\n  Simplify(self: Curve,options: CurveSimplifyOptions,distanceTolerance: float,angleToleranceRadians: float) -> Curve\r\n\r\n  \r\n\r\n   Returns a geometrically equivalent PolyCurve.\r\n\r\n     The PolyCurve has the following \r\n\r\n    properties\r\n\r\n     1. All the PolyCurve segments are LineCurve,PolylineCurve,ArcCurve,or \r\n\r\n    NurbsCurve.\r\n\r\n     \r\n\r\n     2. The Nurbs Curves segments do not have fully multiple \r\n\r\n    interior knots.\r\n\r\n     \r\n\r\n     3. Rational Nurbs curves do not have constant \r\n\r\n    weights.\r\n\r\n     \r\n\r\n     4. Any segment for which IsLinear() or IsArc() is true is a \r\n\r\n    Line,\r\n\r\n        Polyline segment,or an Arc.\r\n\r\n     \r\n\r\n     5. Adjacent \r\n\r\n    Colinear or Cocircular segments are combined.\r\n\r\n     \r\n\r\n     6. Segments that meet \r\n\r\n    with G1-continuity have there ends tuned up so\r\n\r\n        that they meet with G1-continuity \r\n\r\n    to within machine precision.\r\n\r\n  \r\n\r\n  \r\n\r\n   options: Simplification options.\r\n\r\n   distanceTolerance: A distance tolerance for the simplification.\r\n\r\n   angleToleranceRadians: An angle tolerance for the simplification.\r\n\r\n   Returns: New simplified curve on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def SimplifyEnd(self,end,options,distanceTolerance,angleToleranceRadians):\r\n  \"\"\"\r\n  SimplifyEnd(self: Curve,end: CurveEnd,options: CurveSimplifyOptions,distanceTolerance: float,angleToleranceRadians: float) -> Curve\r\n\r\n  \r\n\r\n   Same as SimplifyCurve,but simplifies only the last two segments at \"side\" end.\r\n\r\n  \r\n\r\n   end: If CurveEnd.Start the function simplifies the last two start \r\n\r\n     side segments,\r\n\r\n    otherwise if CurveEnd.End the last two end side segments are simplified.\r\n\r\n  \r\n\r\n   options: Simplification options.\r\n\r\n   distanceTolerance: A distance tolerance for the simplification.\r\n\r\n   angleToleranceRadians: An angle tolerance for the simplification.\r\n\r\n   Returns: New simplified curve on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def SpanDomain(self,spanIndex):\r\n  \"\"\"\r\n  SpanDomain(self: Curve,spanIndex: int) -> Interval\r\n\r\n  \r\n\r\n   Get the domain of the curve span with the given index. \r\n\r\n     Use the SpanCount property \r\n\r\n    to test how many spans there are.\r\n\r\n  \r\n\r\n  \r\n\r\n   spanIndex: Index of span.\r\n\r\n   Returns: Interval of the span with the given index.\r\n  \"\"\"\r\n  pass\r\n def Split(self,*__args):\r\n  \"\"\"\r\n  Split(self: Curve,cutter: Brep,tolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Splits a curve into pieces using a polysurface.\r\n\r\n  \r\n\r\n   cutter: A cutting surface or polysurface.\r\n\r\n   tolerance: A tolerance for computing intersections.\r\n\r\n   Returns: An array of curves. This array can be empty.\r\n\r\n  Split(self: Curve,cutter: Surface,tolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Splits a curve into pieces using a surface.\r\n\r\n  \r\n\r\n   cutter: A cutting surface or polysurface.\r\n\r\n   tolerance: A tolerance for computing intersections.\r\n\r\n   Returns: An array of curves. This array can be empty.\r\n\r\n  Split(self: Curve,t: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Splits (divides) the curve at the specified parameter. \r\n\r\n     The parameter must be in \r\n\r\n    the interior of the curve's domain.\r\n\r\n  \r\n\r\n  \r\n\r\n   t: Parameter to split the curve at in the interval returned by Domain().\r\n\r\n   Returns: Two curves on success,null on failure.\r\n\r\n  Split(self: Curve,t: IEnumerable[float]) -> Array[Curve]\r\n  \"\"\"\r\n  pass\r\n def TangentAt(self,t):\r\n  \"\"\"\r\n  TangentAt(self: Curve,t: float) -> Vector3d\r\n\r\n  \r\n\r\n   Evaluates the unit tangent vector at a curve parameter.\r\n\r\n  \r\n\r\n   t: Evaluation parameter.\r\n\r\n   Returns: Unit tangent vector of the curve at the parameter t.\r\n  \"\"\"\r\n  pass\r\n def ToNurbsCurve(self,subdomain=None):\r\n  \"\"\"\r\n  ToNurbsCurve(self: Curve) -> NurbsCurve\r\n\r\n  \r\n\r\n   Constructs a NURBS curve representation of this curve.\r\n\r\n   Returns: NURBS representation of the curve on success,null on failure.\r\n\r\n  ToNurbsCurve(self: Curve,subdomain: Interval) -> NurbsCurve\r\n\r\n  \r\n\r\n   Constructs a NURBS curve representation of this curve.\r\n\r\n  \r\n\r\n   subdomain: The NURBS representation for this portion of the curve is returned.\r\n\r\n   Returns: NURBS representation of the curve on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def ToPolyline(self,mainSegmentCount,subSegmentCount,maxAngleRadians,maxChordLengthRatio,maxAspectRatio,tolerance,minEdgeLength,maxEdgeLength,keepStartPoint,curveDomain=None):\r\n  \"\"\"\r\n  ToPolyline(self: Curve,mainSegmentCount: int,subSegmentCount: int,maxAngleRadians: float,maxChordLengthRatio: float,maxAspectRatio: float,tolerance: float,minEdgeLength: float,maxEdgeLength: float,keepStartPoint: bool,curveDomain: Interval) -> PolylineCurve\r\n\r\n  \r\n\r\n   Gets a polyline approximation of a curve.\r\n\r\n  \r\n\r\n   mainSegmentCount: If mainSegmentCount <= 0,then both subSegmentCount and mainSegmentCount are ignored. \r\n\r\n     \r\n\r\n    If mainSegmentCount > 0,then subSegmentCount must be >= 1. In this \r\n\r\n     case the \r\n\r\n    nurb will be broken into mainSegmentCount equally spaced \r\n\r\n     chords. If needed,each \r\n\r\n    of these chords can be split into as many \r\n\r\n     subSegmentCount sub-parts if the \r\n\r\n    subdivision is necessary for the \r\n\r\n     mesh to meet the other meshing constraints. In \r\n\r\n    particular,if \r\n\r\n     subSegmentCount=0,then the curve is broken into mainSegmentCount \r\n\r\n    \r\n\r\n     pieces and no further testing is performed.\r\n\r\n  \r\n\r\n   subSegmentCount: An amount of subsegments.\r\n\r\n   maxAngleRadians: ( 0 to pi ) Maximum angle (in radians) between unit tangents at \r\n\r\n     adjacent vertices.\r\n\r\n   maxChordLengthRatio: Maximum permitted value of \r\n\r\n     (distance chord midpoint to curve) / (length of chord).\r\n\r\n   maxAspectRatio: If maxAspectRatio < 1.0,the parameter is ignored. \r\n\r\n     If 1 <= maxAspectRatio < \r\n\r\n    sqrt(2),it is treated as if maxAspectRatio=sqrt(2). \r\n\r\n     This parameter controls the \r\n\r\n    maximum permitted value of \r\n\r\n     (length of longest chord) / (length of shortest chord).\r\n\r\n  \r\n\r\n   tolerance: If tolerance=0,the parameter is ignored. \r\n\r\n     This parameter controls the maximum \r\n\r\n    permitted value of the \r\n\r\n     distance from the curve to the polyline.\r\n\r\n  \r\n\r\n   minEdgeLength: The minimum permitted edge length.\r\n\r\n   maxEdgeLength: If maxEdgeLength=0,the parameter \r\n\r\n     is ignored. This parameter controls the \r\n\r\n    maximum permitted edge length.\r\n\r\n  \r\n\r\n   keepStartPoint: If true the starting point of the curve \r\n\r\n     is added to the polyline. If false the \r\n\r\n    starting point of the curve is \r\n\r\n     not added to the polyline.\r\n\r\n  \r\n\r\n   curveDomain: This subdomain of the NURBS curve is approximated.\r\n\r\n   Returns: PolylineCurve on success,null on error.\r\n\r\n  ToPolyline(self: Curve,mainSegmentCount: int,subSegmentCount: int,maxAngleRadians: float,maxChordLengthRatio: float,maxAspectRatio: float,tolerance: float,minEdgeLength: float,maxEdgeLength: float,keepStartPoint: bool) -> PolylineCurve\r\n\r\n  \r\n\r\n   Gets a polyline approximation of a curve.\r\n\r\n  \r\n\r\n   mainSegmentCount: If mainSegmentCount <= 0,then both subSegmentCount and mainSegmentCount are ignored. \r\n\r\n     \r\n\r\n    If mainSegmentCount > 0,then subSegmentCount must be >= 1. In this \r\n\r\n     case the \r\n\r\n    nurb will be broken into mainSegmentCount equally spaced \r\n\r\n     chords. If needed,each \r\n\r\n    of these chords can be split into as many \r\n\r\n     subSegmentCount sub-parts if the \r\n\r\n    subdivision is necessary for the \r\n\r\n     mesh to meet the other meshing constraints. In \r\n\r\n    particular,if \r\n\r\n     subSegmentCount=0,then the curve is broken into mainSegmentCount \r\n\r\n    \r\n\r\n     pieces and no further testing is performed.\r\n\r\n  \r\n\r\n   subSegmentCount: An amount of subsegments.\r\n\r\n   maxAngleRadians: ( 0 to pi ) Maximum angle (in radians) between unit tangents at \r\n\r\n     adjacent vertices.\r\n\r\n   maxChordLengthRatio: Maximum permitted value of \r\n\r\n     (distance chord midpoint to curve) / (length of chord).\r\n\r\n   maxAspectRatio: If maxAspectRatio < 1.0,the parameter is ignored. \r\n\r\n     If 1 <= maxAspectRatio < \r\n\r\n    sqrt(2),it is treated as if maxAspectRatio=sqrt(2). \r\n\r\n     This parameter controls the \r\n\r\n    maximum permitted value of \r\n\r\n     (length of longest chord) / (length of shortest chord).\r\n\r\n  \r\n\r\n   tolerance: If tolerance=0,the parameter is ignored. \r\n\r\n     This parameter controls the maximum \r\n\r\n    permitted value of the \r\n\r\n     distance from the curve to the polyline.\r\n\r\n  \r\n\r\n   minEdgeLength: The minimum permitted edge length.\r\n\r\n   maxEdgeLength: If maxEdgeLength=0,the parameter \r\n\r\n     is ignored. This parameter controls the \r\n\r\n    maximum permitted edge length.\r\n\r\n  \r\n\r\n   keepStartPoint: If true the starting point of the curve \r\n\r\n     is added to the polyline. If false the \r\n\r\n    starting point of the curve is \r\n\r\n     not added to the polyline.\r\n\r\n  \r\n\r\n   Returns: PolylineCurve on success,null on error.\r\n  \"\"\"\r\n  pass\r\n def Trim(self,*__args):\r\n  \"\"\"\r\n  Trim(self: Curve,side: CurveEnd,length: float) -> Curve\r\n\r\n  \r\n\r\n   Shortens a curve by a given length\r\n\r\n   Returns: Trimmed curve if successful,null on failure.\r\n\r\n  Trim(self: Curve,domain: Interval) -> Curve\r\n\r\n  \r\n\r\n   Removes portions of the curve outside the specified interval.\r\n\r\n  \r\n\r\n   domain: Trimming interval. Portions of the curve before curve(domain[0])\r\n\r\n     and after \r\n\r\n    curve(domain[1]) are removed.\r\n\r\n  \r\n\r\n   Returns: Trimmed curve if successful,null on failure.\r\n\r\n  Trim(self: Curve,t0: float,t1: float) -> Curve\r\n\r\n  \r\n\r\n   Removes portions of the curve outside the specified interval.\r\n\r\n  \r\n\r\n   t0: Start of the trimming interval. Portions of the curve before curve(t0) are removed.\r\n\r\n   t1: End of the trimming interval. Portions of the curve after curve(t1) are removed.\r\n\r\n   Returns: Trimmed portion of this curve is successfull,null on failure.\r\n  \"\"\"\r\n  pass\r\n def TryGetArc(self,*__args):\r\n  \"\"\"\r\n  TryGetArc(self: Curve,plane: Plane) -> (bool,Arc)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Arc using RhinoMath.ZeroTolerance.\r\n\r\n  \r\n\r\n   plane: Plane in which the comparison is performed.\r\n\r\n   Returns: true if the curve could be converted into an arc within the given plane.\r\n\r\n  TryGetArc(self: Curve,plane: Plane,tolerance: float) -> (bool,Arc)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Arc using a custom tolerance.\r\n\r\n  \r\n\r\n   plane: Plane in which the comparison is performed.\r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve could be converted into an arc within the given plane.\r\n\r\n  TryGetArc(self: Curve) -> (bool,Arc)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Arc using RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the curve could be converted into an arc.\r\n\r\n  TryGetArc(self: Curve,tolerance: float) -> (bool,Arc)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Arc using a custom tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve could be converted into an arc.\r\n  \"\"\"\r\n  pass\r\n def TryGetCircle(self,circle,tolerance=None):\r\n  \"\"\"\r\n  TryGetCircle(self: Curve,tolerance: float) -> (bool,Circle)\r\n\r\n  \r\n\r\n   Try to convert this curve into a Circle using a custom tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve could be converted into a Circle within tolerance.\r\n\r\n  TryGetCircle(self: Curve) -> (bool,Circle)\r\n\r\n  \r\n\r\n   Try to convert this curve into a circle using RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the curve could be converted into a Circle.\r\n  \"\"\"\r\n  pass\r\n def TryGetEllipse(self,*__args):\r\n  \"\"\"\r\n  TryGetEllipse(self: Curve,plane: Plane) -> (bool,Ellipse)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Ellipse within RhinoMath.ZeroTolerance.\r\n\r\n  \r\n\r\n   plane: Plane in which the comparison is performed.\r\n\r\n   Returns: true if the curve could be converted into an Ellipse within the given plane.\r\n\r\n  TryGetEllipse(self: Curve,plane: Plane,tolerance: float) -> (bool,Ellipse)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Ellipse using a custom tolerance.\r\n\r\n  \r\n\r\n   plane: Plane in which the comparison is performed.\r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve could be converted into an Ellipse within the given plane.\r\n\r\n  TryGetEllipse(self: Curve) -> (bool,Ellipse)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Ellipse within RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the curve could be converted into an Ellipse.\r\n\r\n  TryGetEllipse(self: Curve,tolerance: float) -> (bool,Ellipse)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Ellipse using a custom tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve could be converted into an Ellipse.\r\n  \"\"\"\r\n  pass\r\n def TryGetPlane(self,plane,tolerance=None):\r\n  \"\"\"\r\n  TryGetPlane(self: Curve,tolerance: float) -> (bool,Plane)\r\n\r\n  \r\n\r\n   Test a curve for planarity and return the plane.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if there is a plane such that the maximum distance from the curve to the plane is <= \r\n\r\n    tolerance.\r\n\r\n  \r\n\r\n  TryGetPlane(self: Curve) -> (bool,Plane)\r\n\r\n  \r\n\r\n   Test a curve for planarity and return the plane.\r\n\r\n   Returns: true if there is a plane such that the maximum distance from the curve to the plane is <= \r\n\r\n    RhinoMath.ZeroTolerance.\r\n  \"\"\"\r\n  pass\r\n def TryGetPolyline(self,polyline,parameters=None):\r\n  \"\"\"\r\n  TryGetPolyline(self: Curve) -> (bool,Polyline,Array[float])\r\n\r\n  \r\n\r\n   Several types of Curve can have the form of a polyline \r\n\r\n     including a degree 1 \r\n\r\n    NurbsCurve,a PolylineCurve,\r\n\r\n     and a PolyCurve all of whose segments are some form \r\n\r\n    of \r\n\r\n     polyline. IsPolyline tests a curve to see if it can be \r\n\r\n     \r\n\r\n    represented as a polyline.\r\n\r\n  \r\n\r\n   Returns: true if this curve can be represented as a polyline; otherwise,false.\r\n\r\n  TryGetPolyline(self: Curve) -> (bool,Polyline)\r\n\r\n  \r\n\r\n   Several types of Curve can have the form of a polyline \r\n\r\n     including a degree 1 \r\n\r\n    NurbsCurve,a PolylineCurve,\r\n\r\n     and a PolyCurve all of whose segments are some form \r\n\r\n    of \r\n\r\n     polyline. IsPolyline tests a curve to see if it can be \r\n\r\n     \r\n\r\n    represented as a polyline.\r\n\r\n  \r\n\r\n   Returns: true if this curve can be represented as a polyline; otherwise,false.\r\n  \"\"\"\r\n  pass\r\n def __enter__(self,*args):\r\n  \"\"\"\r\n  __enter__(self: IDisposable) -> object\r\n\r\n  \r\n\r\n   Provides the implementation of __enter__ for objects which implement IDisposable.\r\n  \"\"\"\r\n  pass\r\n def __exit__(self,*args):\r\n  \"\"\"\r\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\r\n\r\n   Provides the implementation of __exit__ for objects which implement IDisposable.\r\n  \"\"\"\r\n  pass\r\n def __init__(self,*args):\r\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n  pass\r\n @staticmethod\r\n def __new__(self,*args): #cannot find CLR constructor\r\n  \"\"\"\r\n  __new__(cls: type)\r\n\r\n  __new__(cls: type,info: SerializationInfo,context: StreamingContext)\r\n  \"\"\"\r\n  pass\r\n def __reduce_ex__(self,*args):\r\n  pass\r\n Degree=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets the maximum algebraic degree of any span\r\n\r\n   or a good estimate if curve spans are not algebraic.\r\n\r\n\r\n\r\nGet: Degree(self: Curve) -> int\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n Dimension=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets the dimension of the object.\r\n\r\n   The dimension is typically three. For parameter space trimming\r\n\r\n   curves the dimension is two. In rare cases the dimension can\r\n\r\n   be one or greater than three.\r\n\r\n\r\n\r\nGet: Dimension(self: Curve) -> int\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n Domain=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets or sets the domain of the curve.\r\n\r\n\r\n\r\nGet: Domain(self: Curve) -> Interval\r\n\r\n\r\n\r\nSet: Domain(self: Curve)=value\r\n\r\n\"\"\"\r\n\r\n IsClosed=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets a value indicating whether or not this curve is a closed curve.\r\n\r\n\r\n\r\nGet: IsClosed(self: Curve) -> bool\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n IsPeriodic=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets a value indicating whether or not this curve is considered to be Periodic.\r\n\r\n\r\n\r\nGet: IsPeriodic(self: Curve) -> bool\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n PointAtEnd=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Evaluates point at the end of the curve.\r\n\r\n\r\n\r\nGet: PointAtEnd(self: Curve) -> Point3d\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n PointAtStart=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Evaluates point at the start of the curve.\r\n\r\n\r\n\r\nGet: PointAtStart(self: Curve) -> Point3d\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n SpanCount=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets the number of non-empty smooth (c-infinity) spans in the curve.\r\n\r\n\r\n\r\nGet: SpanCount(self: Curve) -> int\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n TangentAtEnd=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Evaluate unit tangent vector at the end of the curve.\r\n\r\n\r\n\r\nGet: TangentAtEnd(self: Curve) -> Vector3d\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n TangentAtStart=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Evaluates the unit tangent vector at the start of the curve.\r\n\r\n\r\n\r\nGet: TangentAtStart(self: Curve) -> Vector3d\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n\r\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "classes", "point", "brep", "line", "dimension", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "halaaro_ironpython-stubs-solidworks_c36b448b75.json", "repo": "halaaro/ironpython-stubs-solidworks"}
{"instruction": "Use this plugin to take any list of closed brep masses to calculate the risk of overheating. By Hamidreza Shahriari", "code": "\r\n\"\"\"Use this plugin to take any list of closed brep masses to calculate the risk of overheating. By Hamidreza Shahriari\r\n    Inputs:\r\n        North: A vector to represent the North direction. If not provided the default Y axis will be selected as North\r\n        Latitude: Latitude of the locatation of the building\r\n        masses: A list of closed Breps to perform the overheating study on the building masses\r\n        g_value: g_value of the windows\r\n        bld_type: Building type according to the SAP Table p1. The values: {\"single story dwelling with possibility of cross ventilation\" = 0 , \"single story dwelling cross ventilation not possible\" = 1, \"Dwelling of two or more storeys windows open upstairs and downstairs Cross ventilation possible\" = 2, \"Dwelling of two or more storeys windows open upstairs and downstairs Cross ventilation not possible\" =3} \r\n        solar_access: Percentage of Sky blocked by obstecles. {\"Heavy\" > 80, \"More than avarage\" >60 & <80, \"average or Unknown\" >20 & <60, \"very little\" <20} \r\n        U_window: Total U_value of the window system\r\n        U_wall : U_value of the walls.\r\n        WWR: Window to WAll Ratio\r\n        solar_flux: solar flux on the horizontal surface during the summer period\r\n        Roof: Set to True if there is roof\r\n        max_roof_angle: Maximum angle of the pitched roof\r\n        U_roof: U_value of the roof\r\n        overhangs: Overhang depth from the glass (in meter)\r\n        curt_blind: Selcet the type of blinds, curtains or external shutters to calculate the shading factor according to SAP table P3: {\"Net curtain (covering whole window)\" = 0, \" Net curtain (covering half window)\" = 1, \" Dark-coloured curtain or roller blind (note 1)\" = 2, \" Light-coloured curtain or roller blind (note 1)\" = 3, \" Dark-coloured venetian blind (note 2)\" = 4,\" Light-coloured venetian blind (note 2) = 5, Dark-coloured external shutter, window closed (notes 1, 3)\" = 6, White external shutter, window closed (notes 1, 3) = 7, Dark-coloured external shutter, window fully open (notes 1, 3) = 8, White external shutter, window fully open (notes 1, 3) = 9}\r\n        opn_type: Ventilation Opening type according to the SAP Table p1.he values: {\"Trickle vents only\" = 0 , \"Windows slightly open (50 mm)\" = 1, \"Windows open half the time\" = 2,\"Windows fully open\" = 3}\r\n        TMP: Thermal mass parameter\r\n        FF: The frame factor for windows and doors (fraction of opening that is glazed). Frame factor according to material: {\"wood\" = 0.7, \"metal\" = 0.8, PVC-U = 0.7} \r\n        ex_t_average: The mean external temperature for the selected summer month and climate region.\r\n        time_fraction: fraction of the daylight hours that shading blinds are in use\r\n        window_height: The height of the window frame\r\n        month_Solar_declination: \r\n    Outputs:\r\n        results: Likelihood of high internal temperature during hot weather.\r\n        preview: Colored mesh preview\r\n\"\"\"\r\n#Copyright (c) 2021, Hamidreza Shahriari \r\n__author__ = \"Hamidreza\"\r\n\r\n\r\n\r\nimport rhinoscriptsyntax as rs\r\nimport Rhino.Geometry as rg\r\nimport ghpythonlib.components as ghc\r\nimport math\r\nimport Grasshopper.Kernel.GH_Convert as ghconvert\r\nfrom scriptcontext import doc\r\n\r\nif not max_roof_angle:\r\n    max_roof_angle = 1\r\n\r\ndef air_change_rate(op_type,bld_type):\r\n    # calculating air change rate according to the guide lines in SAP 2012 Appendix P\r\n    if (op_type == 0) and (bld_type == 0):\r\n        return float(0.1)\r\n    elif (op_type == 0) and (bld_type == 1):\r\n        return float(0.1)\r\n    elif (op_type == 0) and (bld_type == 2):\r\n        return float(0.2)\r\n    elif (op_type == 0) and (bld_type == 3):\r\n        return float(0.1)\r\n    elif (op_type == 1) and (bld_type == 0):\r\n        return float(0.8)\r\n    elif (op_type == 1) and (bld_type == 1):\r\n        return float(0.5)\r\n    elif (op_type == 1) and (bld_type == 2):\r\n        return float(1)\r\n    elif (op_type == 1) and (bld_type == 3):\r\n        return float(0.6)\r\n    elif (op_type == 2) and (bld_type == 0):\r\n        return float(3)\r\n    elif (op_type == 2) and (bld_type == 1):\r\n        return float(2)\r\n    elif (op_type == 2) and (bld_type == 2):\r\n        return float(4)\r\n    elif (op_type == 2) and (bld_type == 3):\r\n        return float(2.5)\r\n    elif (op_type == 3) and (bld_type == 0):\r\n        return float(6)\r\n    elif (op_type == 3) and (bld_type == 1):\r\n        return float(4)\r\n    elif (op_type == 3) and (bld_type == 2):\r\n        return float(8)\r\n    elif (op_type == 3) and (bld_type == 3):\r\n        return float(5)\r\n    else:\r\n        print(\"Please enter the building type and opening type according to the guide line\")\r\n        \r\ndef guid_to_brep(breps):\r\n    # this definition converts the brep list to GUID in order to be used for union process\r\n    list = []\r\n    for brep in breps:\r\n        list.append(doc.Objects.AddBrep(brep))\r\n    return list\r\n\r\n\r\ndef solar_flux_calculator(surface, s_flux, latitude, North, max_roof_angle, month_Solar_declination):\r\n    if not North:\r\n        North = rg.Vector3d.YAxis\r\n    else:\r\n        North = North\r\n    k_values = { 'North' : [26.3,-38.5,14.8,-16.5,27.3 ,-11.9,-1.06, 0.0872, -0.191],\r\n    'South' : [-0.66,-0.106,2.93,3.63,-0.374,-7.4,-2.71,-0.991,4.59],\r\n    'SE' : [-2.95,2.89,1.17,5.67,-3.54,-4.28,-2.72,-0.25,3.07],\r\n    'East' : [1.44,-2.36,1.07,-0.514,1.89,-1.64,-0.542,-0.757,0.604],\r\n    'NE' : [0.165,-3.68,3.0 ,6.38 ,-4.53 ,-0.405 ,-4.38 ,4.89 ,-1.99]}\r\n            \r\n    surface_vector = surface.NormalAt(0.5,0.5)\r\n    delta = math.radians(latitude - month_Solar_declination)\r\n    # calculating surface inclination\r\n    srf_incl = rg.Vector3d.VectorAngle(surface_vector, rg.Vector3d.ZAxis) * 180 / math.pi\r\n            \r\n    # calculating conveting factor\r\n    if srf_incl <= max_roof_angle:\r\n        Rh = 1\r\n        key = 0\r\n    else:\r\n        # calculating the orientation\r\n        vector_angle = rg.Vector3d.VectorAngle(surface_vector, North) * 180 / math.pi\r\n        if vector_angle < 36:\r\n            key = 'North'\r\n        if vector_angle >= 36 and vector_angle < 72:\r\n            key = 'NE'\r\n        if vector_angle >= 72 and vector_angle < 108:\r\n            key = 'East'\r\n        if vector_angle >= 108 and vector_angle < 144:\r\n            key = 'SE'\r\n        if vector_angle >= 144 and vector_angle <= 180:\r\n            key = 'South'\r\n    A = k_values[key][0] * (math.sin(math.radians(srf_incl/2)) ** 3) + k_values[key][1] * ((math.radians(srf_incl/2)) ** 2) + k_values[key][2] * (math.radians(srf_incl/2))\r\n    B = k_values[key][3] * (math.sin(math.radians(srf_incl/2)) ** 3) + k_values[key][4] * ((math.radians(srf_incl/2)) ** 2) + k_values[key][5] * (math.radians(srf_incl/2))\r\n    C = k_values[key][6] * (math.sin(math.radians(srf_incl/2)) ** 3) + k_values[key][7] * ((math.radians(srf_incl/2)) ** 2) + k_values[key][8] * (math.radians(srf_incl/2)) + 1\r\n    Rh = (A * (math.cos(delta)**2)) + (B * (math.cos(delta))) + C\r\n    return (s_flux * Rh, key, srf_incl)\r\n\r\n\r\ndef z_summer(surface, window_height, z_blinds, solar_acces, overhang, time_fraction, orientation, srf_incl, WWR, max_roof_angle):\r\n    if srf_incl < max_roof_angle:\r\n        return 1\r\n    if solar_acces > 80:\r\n         solar_acces_factor = 0.5\r\n    elif solar_acces > 60 and solar_acces <= 80:\r\n        solar_acces_factor = 0.7\r\n    elif solar_acces > 20 and solar_acces <= 60:\r\n        solar_acces_factor = 0.9\r\n    elif solar_acces <= 20:\r\n        solar_acces_factor = 1\r\n    if not overhang and not z_blinds and not time_fraction:\r\n        return solar_acces_factor\r\n    if not window_height:\r\n        window_height = math.sqrt(surface.GetSurfaceSize()[2])\r\n    # defining a dictionary for Shading factors for blinds, curtains or external shutters according to SAP table P3\r\n    blind_dic = { '0' : 0.8 , '1' : 0.9, '2' : 0.85, '3' : 0.6, '4' : 0.88 , '5' : 0.7, '6' : 0.27, '7' : 0.24, '8' : 0.85, '9' : 0.65}\r\n    # Defining the shading factor of the blinds according to the fraction of the daylight hours\r\n    if time_fraction and z_blinds:\r\n        blind_factor = time_fraction * blind_dic ['{}'.format(z_blinds)] + (1 - time_fraction)\r\n    elif not time_fraction and z_blinds:\r\n        blind_factor = blind_dic ['{}'.format(z_blinds)]\r\n    elif not z_blinds:\r\n        blind_factor = 1\r\n    # finding the depth factor of the overhang window \r\n    d_factor = overhang / window_height\r\n    if d_factor < 0.1:\r\n        depth_factor = 'zr'\r\n    elif d_factor >= 0.1 and d_factor < 0.3:\r\n        depth_factor = 'two'\r\n    elif d_factor >= 0.3 and d_factor < 0.5:\r\n        depth_factor = 'four'\r\n    elif d_factor >= 0.5 and d_factor < 0.7:\r\n        depth_factor = 'six'\r\n    elif d_factor >= 0.7 and d_factor < 0.9:\r\n        depth_factor = 'eight'\r\n    elif d_factor >= 0.9 and d_factor < 1.1:\r\n        depth_factor = 'ten'\r\n    else:\r\n        depth_factor = 'twlv'\r\n    window_width = surface.GetSurfaceSize()[1]\r\n    if overhang/window_width < 2:\r\n        overhang_dic = {'Northzr': 1, 'NEzr': 1, 'Eastzr': 1, 'SEzr': 1, 'Southzr': 1, \r\n        'Northtwo': 0.94, 'NEtwo': 0.91, 'Easttwo': 0.89, 'SEtwo': 0.84, 'Southtwo': 0.79,\r\n        'Northfour': 0.9, 'NEfour': 0.85, 'Eastfour': 0.79, 'SEfour': 0.72, 'Southfour': 0.64,\r\n        'Northsix': 0.88, 'NEsix': 0.81, 'Eastsix': 0.72, 'SEsix': 0.62, 'Southsix': 0.53,\r\n        'Northeight': 0.86, 'NEeight': 0.79, 'Easteight': 0.66, 'SEeight': 0.55, 'Southeight': 0.5,\r\n        'Northten': 0.85, 'NEten': 0.77, 'Eastten': 0.61, 'SEten': 0.52, 'Southten': 0.49,\r\n        'Northtwlv': 0.84, 'NEtwlv': 0.76, 'Easttwlv': 0.57, 'SEtwlv': 0.5, 'Southtwlv': 0.48}\r\n    else:\r\n        overhang_dic = {'Northzr': 1, 'NEzr': 1, 'Eastzr': 1, 'SEzr': 1, 'Southzr': 1, \r\n        'Northtwo': 0.92, 'NEtwo': 0.89, 'Easttwo': 0.88, 'SEtwo': 0.83, 'Southtwo': 0.79,\r\n        'Northfour': 0.85, 'NEfour': 0.8, 'Eastfour': 0.76, 'SEfour': 0.67, 'Southfour': 0.55,\r\n        'Northsix': 0.79, 'NEsix': 0.72, 'Eastsix': 0.66, 'SEsix': 0.54, 'Southsix': 0.38,\r\n        'Northeight': 0.73, 'NEeight': 0.65, 'Easteight': 0.58, 'SEeight': 0.43, 'Southeight': 0.32,\r\n        'Northten': 0.69, 'NEten': 0.59, 'Eastten': 0.51, 'SEten': 0.36, 'Southten': 0.3,\r\n        'Northtwlv': 0.66, 'NEtwlv': 0.55, 'Easttwlv': 0.46, 'SEtwlv': 0.31, 'Southtwlv': 0.29}\r\n    return float(blind_factor * (solar_acces_factor+ overhang_dic[orientation + depth_factor] - 1))\r\n\r\ndef temprature_threshold(TMP, Summer_ratio, ex_t_average):\r\n    # Obtaining the threshold internal temperature which is used to estimate likelihood of high internal temperature.\r\n    if TMP < 285:\r\n        delta_t_mass = 2.0 - 0.007 * TMP\r\n    else:\r\n        delta_t_mass = 0\r\n    temp_thresh = ex_t_average + Summer_ratio + delta_t_mass\r\n    if temp_thresh < 20.5:\r\n        overheating = 'Not significant'\r\n        color = \"3,166,90\"\r\n    elif temp_thresh >= 20.5 and temp_thresh < 22:\r\n        overheating = 'Slight'\r\n        color = \"242,191,39\"\r\n    elif temp_thresh >= 22 and temp_thresh < 23.5:\r\n        overheating = 'Medium'\r\n        color = \"217,121,4\"\r\n    else:\r\n        overheating = 'High'\r\n        color = \"191,4,4\"\r\n    return overheating, color\r\n\r\n\r\n# making the union of the breps to exclude the inner partions of the faces\r\nb1 = rs.BooleanUnion(guid_to_brep(masses))\r\n\r\n# convering the new unioned brep GUID into brep class\r\nbrep_union = rs.coercebrep(b1)\r\n\r\nresults = []\r\npreview = []\r\n\r\nfor i, brep in enumerate(masses):\r\n    loss  = 0\r\n    gain = 0\r\n    for face in brep_union.Faces:\r\n        # Calculating the Trimed faces center points in order to find which zone the new face belongs to \r\n        center_point = rg.AreaMassProperties.Compute(face).Centroid\r\n        # Calculating the heat gain and heat loss of each external surface\r\n        if ghc.PointInBrep(brep, center_point, False) and ((rg.Vector3d.VectorAngle(face.NormalAt(0.5,0.5), rg.Vector3d.ZAxis) * 180 / math.pi) < 170) and ((rg.Vector3d.VectorAngle(face.NormalAt(0.5,0.5), rg.Vector3d.ZAxis) * 180 / math.pi) > max_roof_angle):\r\n            s_flux, key, srf_incl = solar_flux_calculator(face, solar_flux, Latitude, North, max_roof_angle, month_Solar_declination)\r\n            wall_area = rg.AreaMassProperties.Compute(face).Area\r\n            shade_factor = z_summer(face, window_height, curt_blind, solar_access, overhangs, time_fraction, key, srf_incl, WWR, max_roof_angle)\r\n            s_gain = 0.9 * wall_area * WWR * FF * s_flux * shade_factor * g_value\r\n            gain += s_gain\r\n            heat_loss = (wall_area * (1-WWR) * U_wall) + (wall_area * WWR * U_window) + 0.15 * wall_area\r\n            loss += heat_loss\r\n        elif ghc.PointInBrep(brep, center_point, False) and ((rg.Vector3d.VectorAngle(face.NormalAt(0.5,0.5), rg.Vector3d.ZAxis) * 180 / math.pi) <= max_roof_angle) and Roof:\r\n            loss += (rg.AreaMassProperties.Compute(face).Area) * (U_roof+0.15)\r\n        else:\r\n            continue\r\n    # calculating the volume of the space\r\n    vol = rg.VolumeMassProperties.Compute(brep).Volume\r\n    # calculating ventilation heat loss:\r\n    n = air_change_rate(opn_type,bld_type)\r\n    vent_loss = 0.33 * n * vol\r\n    loss += vent_loss\r\n    ratio = gain / loss\r\n    results.append(temprature_threshold(TMP, ratio, ex_t_average)[0])\r\n    # coloring the mesh according to the temprature threshold\r\n    for mesh in rg.Mesh.CreateFromBrep(brep):\r\n        preview.append(ghc.MeshColours(mesh,(temprature_threshold(TMP, ratio, ex_t_average)[1])))", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "brep", "line", "functions", "block", "mesh", "RhinoCommon"], "original_file": "hr-shahriari_Overheating_71175b8b61.json", "repo": "hr-shahriari/Overheating"}
{"instruction": "defines the foil parts to model", "code": "import os\r\nimport sys\r\nimport Rhino\r\nfrom Rhino.Geometry import *\r\nfrom Rhino.Input import RhinoGet\r\nfrom Rhino.Commands import Result\r\nfrom Rhino.DocObjects import ObjectType\r\nimport rhinoscriptsyntax as rs\r\nfrom scriptcontext import doc\r\n\r\nfrom Class_Stab import Stab\r\nfrom Class_Wing import Wing\r\nfrom Class_Foil import Foil\r\nfrom Class_Mast import Mast\r\nfrom Class_Fuselage_front import Fuselagefront\r\nfrom Class_Fuselage_rear import Fuselagerear\r\n\r\n\r\n\r\ndef PartsToModel(filename='..\\\\input_parameters.txt'):\r\n    \"\"\" defines the foil parts to model \"\"\"\r\n    try:\r\n        f = open(filename, 'r+')\r\n    except IOError as e:\r\n        print('Unable to open de file\\n', e)\r\n        sys.exit()\r\n    Parts = dict()\r\n    for el in f.readlines():\r\n        el_split = el.split('=')\r\n        if len(el_split) == 2:\r\n            if str(el_split[0]).strip(' ') in ['wing','stab','mast','fuselage']:\r\n                    Parts[str(el_split[0]).strip(' ')] = str(el_split[1]).strip('\\n ')\r\n    return Parts\r\n\r\n\r\ndef SaveAsRhinoFile(extension,Parts_foil_export):\r\n    \"\"\" exports the whole foil \"\"\"\r\n    for key_export in Parts_foil_export.keys():\r\n        rs.SelectObject(str(Parts_foil_export[key_export]))\r\n        if os.path.exists('..\\\\Exports\\\\part_' + key_export + extension):\r\n            os.remove('..\\\\Exports\\\\part_' + key_export + extension)\r\n        path = os.path.abspath('..\\\\Exports\\\\part_' + key_export + extension)\r\n        cmd = \"_-Export \" + path + \" _Enter\"\r\n        rs.Command(cmd)\r\n        rs.UnselectObjects(str(Parts_foil_export[key_export]))\r\n\r\n\r\ndef ClearRhinoFile():\r\n    \"\"\" deletes every surfaces that are not useful polysurfaces \"\"\"\r\n    arrObjects = rs.AllObjects()\r\n    for el in arrObjects:\r\n        if not rs.IsPolysurface(el):\r\n            rs.DeleteObject(el)\r\n\r\n\r\ndef ClearLayerRhinoFile():\r\n    \"\"\" deletes every layers that are empty \"\"\"\r\n    arrLayers = rs.LayerNames(False)\r\n    for layerName in arrLayers:\r\n        if rs.IsLayerEmpty(layerName):\r\n            rs.DeleteLayer(layerName)\r\n\r\n\r\ndef CreateObjectRhinoFile():\r\n    \"\"\" creates a layer for each object within the Rhino file \"\"\"\r\n    arrObjects = rs.AllObjects()\r\n    i = 0\r\n    for el in arrObjects:\r\n        i = i + 1\r\n        name = \"Layer_number_\" + str(i)\r\n        rs.EnableRedraw(False)\r\n        rs.AddLayer(name)\r\n        rs.ObjectLayer(el, name)\r\n        rs.LayerVisible(name, True)\r\n        rs.EnableRedraw(True)\r\n    return i\r\n\r\n\r\n\r\nif __name__ == '__main__':\r\n    try :\r\n        rs.Command(\"-_SelAll\")\r\n        rs.Command(\"-_Delete\")\r\n    except:\r\n        pass\r\n    \r\n    \"\"\" construction and saving of the foil \"\"\"\r\n\r\n    # Construction \r\n    rs.UnitSystem(4)  # meters\r\n\r\n    Parts = PartsToModel()  # Parts = {\"wing\":'yes',\"stab\":'yes',\"mast\":'yes',\"fuselage\":'yes'}\r\n    Parts_foil = dict()\r\n\r\n    if Parts[\"wing\"] == 'yes':\r\n        # front wing\r\n        wing = Wing()\r\n        Parts_foil[\"wing\"] = wing\r\n\r\n    if Parts[\"stab\"] == 'yes': \r\n        # stabilizer\r\n        stab = Stab()\r\n        Parts_foil[\"stab\"] = stab\r\n\r\n    if Parts[\"mast\"] == 'yes':\r\n        # mast\r\n        mast = Mast()\r\n        Parts_foil[\"mast\"] = mast\r\n    \r\n    if Parts[\"fuselage\"] == 'yes':\r\n        # front part of the fuselage (nose)\r\n        fuselagefront = Fuselagefront()\r\n        # rear part of the fuselage\r\n        fuselagerear = Fuselagerear()\r\n        fuselage = [fuselagefront, fuselagerear]\r\n        Parts_foil[\"fuselage\"] = fuselage\r\n\r\n    # whole foil\r\n    foil = Foil(Parts_foil)\r\n    id_Parts_foil = foil.make_foil(Parts_foil)\r\n    Parts_foil_export = dict()\r\n\r\n    if \"wing\" in Parts_foil.keys():\r\n        \"\"\" closed front wing \"\"\"\r\n        id_wing = id_Parts_foil[\"wing\"]\r\n        try:  # blunt trailing edge  \r\n            if foil.symmetric == 'no':\r\n                curve_wing = rs.DuplicateEdgeCurves(id_wing)  # in : str - out : array of strings\r\n                # 0 left, 1 bottom, 2 right, 3 top\r\n                id_patch_wing = rs.AddEdgeSrf((curve_wing[0], curve_wing[2]))  # in : array - out : str\r\n                id_full_wing = rs.JoinSurfaces((id_patch_wing, id_wing), True)\r\n                curve_wing_new = rs.DuplicateEdgeCurves(id_full_wing)\r\n                id_patch_wing_bot = rs.AddEdgeSrf((curve_wing_new[0], curve_wing_new[5]))  # in : array - out : array\r\n                id_patch_wing_top = rs.AddEdgeSrf((curve_wing_new[2], curve_wing_new[4]))\r\n                # array of strings  # 0 left, 1 bottom, 2 right, 3 top, 4 bottom trailing edge, 5 top trailing edge\r\n                front_wing_export = rs.JoinSurfaces((id_full_wing, id_patch_wing_bot, id_patch_wing_top), True)  # in : array - out : str                \r\n                # in : str - out : str\r\n                Parts_foil_export[\"wing\"] = front_wing_export\r\n            elif foil.symmetric == 'yes':\r\n                # right\r\n                curve_wing = rs.DuplicateEdgeCurves(id_wing)  # in : str - out : array of strings\r\n                # 0 left, 1 bottom, 2 right, 3 top\r\n                id_patch_wing = rs.AddEdgeSrf((curve_wing[0], curve_wing[2]))  # in : array - out : str\r\n                id_full_wing = rs.JoinSurfaces((id_patch_wing, id_wing), True)  # in : array - out : str\r\n                curve_wing_new = rs.DuplicateEdgeCurves(id_full_wing)\r\n                id_patch_wing_bot = rs.AddEdgeSrf((curve_wing_new[2], curve_wing_new[4]))\r\n                # array of strings  # 0 left, 1 bottom, 2 right, 3 top, 4 bottom trailing edge, 5 top trailing edge\r\n                id_full_wing_new = rs.JoinSurfaces((id_full_wing, id_patch_wing_bot), True)  # in : array - out : str\r\n                # left\r\n                id_full_wing_mirror = rs.MirrorObject(id_full_wing_new, (-10, 0, -10), (10, 0, 10), True)\r\n                # in : str - out : str\r\n                front_wing_export = rs.JoinSurfaces((id_full_wing_new, id_full_wing_mirror), True)  # in : array - out : str\r\n                Parts_foil_export[\"wing\"] = front_wing_export\r\n        except:  # sharp trailing edge \r\n            if foil.symmetric == 'no':\r\n                curve_wing = rs.DuplicateEdgeCurves(id_wing)  # in : str - out : array of strings\r\n                id_patch_wing_bot = rs.AddPlanarSrf((curve_wing[1]))  # in : array - out : array\r\n                id_patch_wing_top = rs.AddPlanarSrf((curve_wing[2]))  # in : array - out : array\r\n                front_wing_export = rs.JoinSurfaces((id_patch_wing_bot, id_patch_wing_top, id_wing), True)\r\n                Parts_foil_export[\"wing\"] = front_wing_export\r\n                rs.DeleteObject(id_wing)\r\n                rs.DeleteObject(id_patch_wing_top)\r\n                rs.DeleteObject(id_patch_wing_bot)\r\n            elif foil.symmetric == 'yes':\r\n                # right\r\n                curve_wing = rs.DuplicateEdgeCurves(id_wing)  # in : str - out : array of strings\r\n                id_patch_wing = rs.AddPlanarSrf((curve_wing[1]))  # in : array - out : array\r\n                id_full_wing = rs.JoinSurfaces((id_patch_wing[0], id_wing), True)  # in : array - out : str\r\n                # left\r\n                id_full_wing_mirror = rs.MirrorObject(id_full_wing, (-10, 0, -10), (10, 0, 10), True)\r\n                # in : str - out : str\r\n                front_wing_export = rs.JoinSurfaces((id_full_wing, id_full_wing_mirror), True)  # in : array - out : str\r\n                Parts_foil_export[\"wing\"] = front_wing_export\r\n                # surface deletion\r\n                rs.DeleteObject(id_wing)\r\n                rs.DeleteObject(id_full_wing)\r\n                rs.DeleteObject(id_full_wing_mirror)\r\n\r\n    if \"stab\" in Parts_foil.keys():\r\n        id_stab = id_Parts_foil[\"stab\"]\r\n        \"\"\" closed stabilizer \"\"\"\r\n        try:\r\n            # right\r\n            curve_stab_0 = rs.DuplicateEdgeCurves(id_stab)\r\n            # array of strings  # 0 left, 1 bottom, 2 right, 3 top\r\n            id_patch_stab = rs.AddEdgeSrf((curve_stab_0[0], curve_stab_0[2]))\r\n            id_full_stab_0 = rs.JoinSurfaces((id_patch_stab, id_stab), True)\r\n            curve_stab = rs.DuplicateEdgeCurves(id_full_stab_0)\r\n            id_patch_stab_bot = rs.AddEdgeSrf((curve_stab[2], curve_stab[4]))\r\n            # array of strings  # 0 left, 1 bottom, 2 right, 3 top, 4 bottom trailing edge, 5 top trailing edge\r\n            id_full_stab = rs.JoinSurfaces((id_full_stab_0, id_patch_stab_bot), True)\r\n\r\n            # left\r\n            id_full_stab_mirror = rs.MirrorObject(id_full_stab, (-10, 0, -10), (10, 0, 10), True)\r\n\r\n            stab_export = rs.JoinSurfaces((id_full_stab, id_full_stab_mirror), True)\r\n            Parts_foil_export[\"stab\"] = stab_export\r\n\r\n            # surface deletion\r\n            rs.DeleteObject(id_stab)\r\n            rs.DeleteObject(id_patch_stab)\r\n            rs.DeleteObject(id_full_stab_0)\r\n            rs.DeleteObject(id_patch_stab_bot)\r\n            rs.DeleteObject(id_full_stab)\r\n            rs.DeleteObject(id_full_stab_mirror)\r\n\r\n        except:\r\n            curve_stab = rs.DuplicateEdgeCurves(id_stab)  # array of strings\r\n            id_patch_stab = rs.AddPlanarSrf((curve_stab[1]))  # array of strings\r\n            id_full_stab = rs.JoinSurfaces((id_patch_stab[0], id_stab), True)\r\n\r\n            id_full_stab_mirror = rs.MirrorObject(id_full_stab, (-10, 0, -10), (10, 0, 10), True)\r\n\r\n            stab_export = rs.JoinSurfaces((id_full_stab, id_full_stab_mirror), True)\r\n            Parts_foil_export[\"stab\"] = stab_export\r\n\r\n            # surface deletion\r\n            rs.DeleteObject(id_stab)\r\n            rs.DeleteObject(id_full_stab)\r\n            rs.DeleteObject(id_full_stab_mirror)\r\n\r\n    if \"mast\" in Parts_foil.keys():\r\n        \"\"\" closed mast \"\"\"\r\n        id_mast = id_Parts_foil[\"mast\"]\r\n        try:\r\n            curve_mast_0 = rs.DuplicateEdgeCurves(id_mast)  # array of strings  # 0 left, 1 bottom, 2 right, 3 top\r\n            id_patch_mast = rs.AddEdgeSrf((curve_mast_0[0], curve_mast_0[2]))\r\n            id_full_mast = rs.JoinSurfaces((id_patch_mast, id_mast), True)\r\n            curve_mast = rs.DuplicateEdgeCurves(id_full_mast)\r\n            id_patch_mast_top = rs.AddEdgeSrf((curve_mast[0], curve_mast[5]))\r\n            id_patch_mast_bot = rs.AddEdgeSrf((curve_mast[2], curve_mast[4]))\r\n            # array of strings  # 0 left, 1 bottom, 2 right, 3 top, 4 bottom trailing edge, 5 top trailing edge\r\n\r\n            mast_export = rs.JoinSurfaces((id_full_mast, id_patch_mast_top, id_patch_mast_bot), True)\r\n            Parts_foil_export[\"mast\"] = mast_export\r\n\r\n            # surface deletion\r\n            rs.DeleteObject(id_mast)\r\n            rs.DeleteObject(id_patch_mast)\r\n            rs.DeleteObject(id_patch_mast_top)\r\n            rs.DeleteObject(id_patch_mast_bot)\r\n            rs.DeleteObject(id_full_mast)\r\n\r\n        except:\r\n            curve_mast = rs.DuplicateEdgeCurves(id_mast)  # array of strings\r\n            id_patch_mast_bot = rs.AddPlanarSrf((curve_mast[1]))  # array of strings\r\n            id_patch_mast_top = rs.AddPlanarSrf((curve_mast[2]))  # array of strings\r\n\r\n            mast_export = rs.JoinSurfaces((id_patch_mast_bot, id_patch_mast_top, id_mast), True)\r\n            Parts_foil_export[\"mast\"] = mast_export\r\n\r\n            # surface deletion\r\n            rs.DeleteObject(id_mast)\r\n            rs.DeleteObject(id_patch_mast_bot)\r\n            rs.DeleteObject(id_patch_mast_top)\r\n\r\n    if \"fuselage\" in Parts_foil.keys():\r\n        \"\"\" closed fuselage \"\"\"\r\n        # front\r\n        id_fuselagefront = id_Parts_foil[\"fuselage_front\"]\r\n        curve_fuselagefront = rs.DuplicateEdgeCurves(id_fuselagefront)\r\n        id_patch_fuselagefront = rs.AddPlanarSrf((curve_fuselagefront[1]))\r\n        id_full_fuselagefront = rs.JoinSurfaces((id_patch_fuselagefront, id_fuselagefront), True)\r\n\r\n        # rear\r\n        id_fuselagerear = id_Parts_foil[\"fuselage_rear\"]\r\n        curve_fuselagerear = rs.DuplicateEdgeCurves(id_fuselagerear)\r\n        id_patch_fuselagerear = rs.AddPlanarSrf((curve_fuselagerear[1]))  # string\r\n        id_full_fuselagerear = rs.JoinSurfaces((id_patch_fuselagerear, id_fuselagerear), True)\r\n\r\n        fuselage_export = rs.JoinSurfaces((id_full_fuselagefront, id_full_fuselagerear), True)\r\n        Parts_foil_export[\"fuselage\"] = fuselage_export\r\n\r\n        # surface deletion\r\n        rs.DeleteObject(id_fuselagefront)\r\n        rs.DeleteObject(id_patch_fuselagefront)\r\n        rs.DeleteObject(id_full_fuselagefront)\r\n        rs.DeleteObject(id_fuselagerear)\r\n        rs.DeleteObject(id_patch_fuselagerear)\r\n        rs.DeleteObject(id_full_fuselagerear)\r\n\r\n    # curve deletion\r\n    arrObjects = rs.AllObjects()\r\n    for el in arrObjects:\r\n        if not(rs.IsPolysurface(el)):\r\n            rs.DeleteObject(str(el))\r\n\r\n    # Clears, saves and exports\r\n    for extension in foil.L_extension:\r\n       SaveAsRhinoFile(extension,Parts_foil_export)\r\n    ClearRhinoFile()\r\n    ClearLayerRhinoFile()\r\n    rs.DocumentModified(False)  # prevents a dialog box from popping when closing Rhino\r\n    if foil.close_Rhino == 'yes':\r\n        rs.Exit()\r\n    ", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "layer", "line", "curve", "functions", "RhinoCommon"], "original_file": "hugo-nicolas_LEModeler_168711ecc7.json", "repo": "hugo-nicolas/LEModeler"}
{"instruction": "Get the the vertex with the lowest y,x and z values", "code": "#! python2\n\nimport Rhino as rc\nimport Rhino.Geometry as rg\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport datetime as dt\nimport math\n\nimport log\nimport acim\nimport hole\nimport cut\nimport util\n\nimport visual_debug as vd\n\ndef get_lowest_brep_vertex(brep):\n    \"\"\" Get the the vertex with the lowest y,x and z values \"\"\"\n    biggest_vertices = brep.Vertices\n    lowest_x = 0\n    lowest_y = 0\n    lowest_z = 0\n    for vertex in biggest_vertices:\n        if vertex.Location.X < lowest_x:\n            lowest_x = vertex.Location.X\n        if vertex.Location.Y < lowest_y:\n            lowest_y = vertex.Location.Y\n        if vertex.Location.Z < lowest_z:\n            lowest_z = vertex.Location.Z\n    return rc.Geometry.Point3d(lowest_x, lowest_y, lowest_z)\n\ndef pln_2_pln_world_transform(brep):\n    \"\"\" Transform a brep to the world plane \"\"\"\n    log.info(\"Computing Oriented Bounding Boxes...\")\n\n    # find the longest edge of the brep\n    edges = brep.Edges\n    longest_edge = None\n    longest_edge_length = 0\n    for edge in edges:\n        if edge.GetLength() > longest_edge_length:\n            longest_edge_length = edge.GetLength()\n            longest_edge = edge\n\n    # find biggest face\n    face_indices = longest_edge.AdjacentFaces()\n    faces = [brep.Faces[face_index] for face_index in face_indices]\n    biggest_face = None\n    biggest_face_area = 0\n    for face in faces:\n        if rg.AreaMassProperties.Compute(face).Area > biggest_face_area:\n            biggest_face_area = rg.AreaMassProperties.Compute(face).Area\n            biggest_face = face\n    \n    # get the plane of the biggest face\n    if biggest_face.TryGetPlane()[0] is False:\n        log.error(\"Could not find plane for longest edge. Exiting...\")\n        return\n    plane_src = biggest_face.TryGetPlane()[1]\n    plane_tgt = rc.Geometry.Plane.WorldXY\n    log.info(\"Found plane for longest edge: \" + str(plane_src))\n\n    # plane to plane transformation\n    plane_to_world = rc.Geometry.Transform.PlaneToPlane(plane_src, plane_tgt)\n    brep.Transform(plane_to_world)\n\n    # adjust to x,y,z positive\n    lowest_vertex = get_lowest_brep_vertex(brep)\n    lowest_vertex_transform = rc.Geometry.Transform.Translation(rg.Vector3d(-lowest_vertex))\n    brep.Transform(lowest_vertex_transform)\n\n    bbox = brep.GetBoundingBox(True)\n    bbox_corners = bbox.GetCorners()\n    y_val_sum = 0\n    x_val_sum = 0\n    for corner in bbox_corners:\n        y_val_sum += corner.Y\n        x_val_sum += corner.X\n\n    if x_val_sum > y_val_sum:\n        log.info(\"Bounding box is alligned to x axis. No rotation needed.\")\n    else:\n        log.info(\"Bounding box is not alligned to y axis. A 90 deg rotation is needed.\")\n        rot_90_z = rc.Geometry.Transform.Rotation(math.radians(90), rg.Vector3d.ZAxis, rg.Point3d.Origin)\n        brep.Transform(rot_90_z)\n        lowest_vertex = get_lowest_brep_vertex(brep)\n\n        lowest_vertex_transform = rc.Geometry.Transform.Translation(rg.Vector3d(-lowest_vertex))\n        brep.Transform(lowest_vertex_transform)\n\n    vd.addBrep(brep, clr=(255, 0, 0, 30))\n\ndef distinguish_holes_cuts(breps):\n    \"\"\" \n        Analyse the result breps from the boolean difference operation\n        and distinguish between holes and cuts\n    \"\"\"\n    is_hole = False\n    is_cut = False\n    is_mix = False\n    holes_b = []\n    cuts_b = []\n    mix_b = []\n\n    # parse holes, cuts and mix\n    for b in breps:\n        is_cut = True\n        for f in b.Faces:\n            f_brep = f.ToBrep()\n            f = f_brep.Faces[0]\n            if not f.IsPlanar():\n                is_cut = False\n                is_hole = True\n                b_faces = util.explode_brep(b)\n                for b_face in b_faces:\n                    if b_face.Faces[0].IsPlanar():\n                        b_face_edges = b_face.Edges\n                        for b_face_edge in b_face_edges:\n                            if not b_face_edge.IsClosed:\n                                is_mix = True\n                                is_hole = False\n                                break\n                        if is_mix:\n                            break\n                break\n\n        if is_hole:\n            holes_b.append(b)\n        elif is_cut: \n            cuts_b.append(b)\n        elif is_mix:\n            mix_b.append(b)\n\n        is_hole = False\n        is_cut = False\n        is_mix = False\n    \n    # deal with mix\n    candidate_cuts = []\n    candidate_holes = []\n    for b in mix_b:\n        # -- algorithm draft --\n        # (1) explode\n        # (2) seperate in tow list flat surfaces (cuts + cylinder's bases) and non flat surfaces (cylinders)\n        # (3) cap each object in both lists\n        # (4) boolunion every object in both lists\n        # (5) check if closed, if it is \n        # ----------------------\n        # (1) explode\n        faces_b = util.explode_brep(b)\n\n        # (2) seperate in tow list flat surfaces (cuts + cylinder's bases) and non flat surfaces (cylinders)\n        flat_faces_b = []\n        non_flat_faces_b = []\n        for f_b in faces_b:\n            if f_b.Faces[0].IsPlanar():\n                flat_faces_b.append(f_b)\n            else:\n                non_flat_faces_b.append(f_b)\n  \n        # (*) cap the cylinders\n        non_flat_faces_b = [f_b.CapPlanarHoles(sc.doc.ModelAbsoluteTolerance) for f_b in non_flat_faces_b]\n        \n        # (4) boolunion every object in both lists\n        flat_faces_b = rc.Geometry.Brep.CreateBooleanUnion(flat_faces_b, sc.doc.ModelAbsoluteTolerance)\n        non_flat_faces_b = rc.Geometry.Brep.CreateBooleanUnion(non_flat_faces_b, sc.doc.ModelAbsoluteTolerance)\n\n        # (3) cap candidate cuts\n        flat_faces_b = [f_b.CapPlanarHoles(sc.doc.ModelAbsoluteTolerance) for f_b in flat_faces_b]\n        # non_flat_faces_b = [f_b.CapPlanarHoles(sc.doc.ModelAbsoluteTolerance) for f_b in non_flat_faces_b]\n\n        # (*) merge all coplanar faces in breps cut candidates\n        for f_b in flat_faces_b:\n            if f_b is not None:\n                f_b.MergeCoplanarFaces(sc.doc.ModelAbsoluteTolerance)\n\n        # (5) check if closed, if it is add to cuts, if not add to holes\n        for f_b in flat_faces_b:\n            if f_b is not None:\n                if f_b.IsSolid:\n                    cuts_b.append(f_b)\n        for f_b in non_flat_faces_b:\n            if f_b is not None:\n                if f_b.IsSolid:\n                    holes_b.append(f_b)\n\n    return holes_b, cuts_b\n\ndef main():\n\n    vd.set_on()\n    print(vd.__IS_VDEBUG__)\n\n    log.info(\".acim exporter started\")\n    rh_doc_path = rs.DocumentPath()\n    timestamp = dt.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    acim_path = rh_doc_path + timestamp\n    log.info(\"Creating ACIM file at: \" + acim_path)\n    ACIM = acim.ACIM(acim_path)\n\n    pieces = rs.GetObjects(\"Select pieces to be exported\", rs.filter.polysurface, preselect=True)\n    if not pieces:\n        log.error(\"No pieces selected. Exiting...\")\n        return\n    log.info(\"Selected \" + str(len(pieces)) + \" pieces.\")\n\n    for p_GUID in pieces:\n        log.info(\"Processing piece: \" + str(p_GUID))\n        ACIM.add_timber(str(p_GUID))\n        ACIM.add_timber_state(str(p_GUID), 0)\n        brep = rs.coercebrep(p_GUID)\n        \n        # transform to world plane\n        pln_2_pln_world_transform(brep)\n\n        # compute the bounding box\n        bbox = brep.GetBoundingBox(True)\n        bbox_b = bbox.ToBrep()\n        ACIM.add_bbox(str(p_GUID), bbox.GetCorners())\n\n        # boolean difference between the bounding box and the brep transformed\n        brep_result = rc.Geometry.Brep.CreateBooleanDifference(bbox_b, brep, sc.doc.ModelAbsoluteTolerance)\n        if brep_result is None or len(brep_result) == 0:\n            log.error(\"No breps found after boolean difference. Exiting...\")\n            return\n\n        # get holes and cuts breps\n        holes_b, cuts_b = distinguish_holes_cuts(brep_result)\n        log.info(\"Found:\\n\" \\\n            + \"\\t --holes: \" +  str(len(holes_b)) + \"\\n\" \\\n            + \"\\t --cuts: \" + str(len(cuts_b)) + \"\\n\")\n\n        ############################################################\n        # analyse and loading holes and cuts into .acim\n        if holes_b.__len__() != 0:\n            for hole_b in holes_b:\n                vd.addBrep(hole_b, clr=(255, 255, 0, 30))\n                log.info(\"Processing hole: \" + str(hole_b))\n                hole.parse_data_from_brep(ACIM, str(p_GUID), hole_b, bbox_b)\n\n        if cuts_b.__len__() != 0:\n            cut_counter = 1\n            for cut_b in cuts_b:\n                vd.addBrep(cut_b, clr=(255, 0, 255, 30))\n                log.info(\"Processing cut: \" + str(cut_b))\n                cut.parse_data_from_brep(ACIM, str(p_GUID), cut_b, bbox_b)\n\n                vd.addSingleDot(cut_b.GetBoundingBox(True).Center, str(cut_counter), (0,0,255))\n                cut_counter += 1\n\n        sc.doc.Views.Redraw()\n    ACIM.dump_data()\n\n\nif __name__ == '__main__':\n    main()", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "brep", "functions", "RhinoCommon"], "original_file": "ibois-epfl_augmented-carpentry_78548151d8.json", "repo": "ibois-epfl/augmented-carpentry"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "import System\n\nimport Rhino\n\nfrom ghpythonlib.componentbase import executingcomponent as component\n\nfrom joint_calc import face, joint, stress_field, geometry\n\n\nclass RWJCMomentCalculator(component):\n    def RunScript(\n        self,\n        brep_faces: System.Collections.Generic.List[Rhino.Geometry.BrepFace],\n        moment_vector: Rhino.Geometry.Vector3d,\n        rotation_center: Rhino.Geometry.Point3d,\n    ):\n        vectors = []\n        anchors = []\n\n        joint_faces = []\n        for i, brep_face in enumerate(brep_faces):\n            face_area = Rhino.Geometry.AreaMassProperties.Compute(brep_face).Area\n            joint_face = face.JointFace(\n                id=i,\n                parent_joint_id=0,\n                area=face_area,\n                normal=geometry.Vector.from_vector_3d(\n                    brep_face.Faces[0].NormalAt(0.5, 0.5)\n                ),\n                brep_surface=brep_face,\n            )\n            joint_faces.append(joint_face)\n\n            vectors.append(\n                Rhino.Geometry.Vector3d(\n                    joint_face.normal.x / 10,\n                    joint_face.normal.y / 10,\n                    joint_face.normal.z / 10,\n                )\n            )\n\n        my_joint = joint.Joint(name=\"Joint1\", faces=joint_faces, moment_weights=None)\n\n        stress_computer = stress_field.StressFieldComputer(\n            moment=geometry.Vector(\n                moment_vector.X,\n                moment_vector.Y,\n                moment_vector.Z,\n            ),\n            rotation_point=geometry.Point(\n                rotation_center.X,\n                rotation_center.Y,\n                rotation_center.Z,\n            ),\n            joint=my_joint,\n        )\n        stress_computer.compute_stress_field()\n        print(\n            f\"Total tensile component: {round(stress_computer.total_tensile_component) / 1000} kN\"\n        )\n\n        for joint_face in my_joint.faces:\n            anchors.append(\n                Rhino.Geometry.Point3d(\n                    joint_face.resultant_location.x,\n                    joint_face.resultant_location.y,\n                    joint_face.resultant_location.z,\n                )\n            )\n        stress_distributions = [\n            joint_face.stress_distribution for joint_face in my_joint.faces\n        ]\n        sigma_maxs = [\n            f\"sigma_max = {round(joint_face.max_stress / 1e6, 2)} MPa\"\n            for joint_face in my_joint.faces\n        ]\n\n        return [vectors, anchors, stress_distributions, sigma_maxs]\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "classes", "point", "brep", "functions", "RhinoCommon"], "original_file": "ibois-epfl_rw-joint-calculator_92d8a7ed22.json", "repo": "ibois-epfl/rw-joint-calculator"}
{"instruction": "Adds a button to the component input", "code": "import System\nimport System.Drawing\nimport sys\nimport os\nimport time\n\nimport contextlib\nimport io\n\nimport typing\n\nimport abc\nimport socket\nimport threading\nimport queue\nimport json\n\nimport importlib\nimport sys\n\nimport traceback\n\nimport Rhino\nimport rhinoscriptsyntax as rs\nimport Grasshopper\nimport Grasshopper as gh\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\nimport ghpythonlib.treehelpers as th\n\n\ndef add_button(self,\n    nickname: str,\n    indx: int,\n    X_param_coord: float,\n    Y_param_coord: float,\n    X_offset: int=100\n    ) -> None:\n    \"\"\"\n        Adds a button to the component input\n\n        :param nickname: the nickname of the button\n        :param indx: the index of the input parameter\n        :param X_param_coord: the x coordinate of the input parameter\n        :param Y_param_coord: the y coordinate of the input parameter\n        :param X_offset: the offset of the button from the input parameter\n    \"\"\"\n    param = ghenv.Component.Params.Input[indx]\n    if param.SourceCount == 0:\n        button = Grasshopper.Kernel.Special.GH_ButtonObject()\n        button.NickName = \"\"\n        button.Description = \"\"\n        button.CreateAttributes()\n        button.Attributes.Pivot = System.Drawing.PointF(\n            X_param_coord - (button.Attributes.Bounds.Width) - X_offset,\n            Y_param_coord - (button.Attributes.Bounds.Height / 2 - 0.1)\n            )\n        button.Attributes.ExpireLayout()\n        Grasshopper.Instances.ActiveCanvas.Document.AddObject(button, False)\n        ghenv.Component.Params.Input[indx].AddSource(button)\n\nclass GHThread(threading.Thread, metaclass=abc.ABCMeta):\n    \"\"\"\n        A base class for Grasshopper threads.\n    \"\"\"\n    def __init__(self, name : str):\n        super().__init__(name=name, daemon=False)\n        self._component_on_canvas = True\n        self._component_enabled = True\n\n    @abc.abstractmethod\n    def run(self):\n        \"\"\" Run the thread. \"\"\"\n        pass\n\n    def _check_if_component_on_canvas(self):\n        \"\"\" Check if the component is on canvas from thread. \"\"\"\n        def __check_if_component_on_canvas():\n            if ghenv.Component.OnPingDocument() is None:\n                self._component_on_canvas = False\n                return False\n            else:\n                self._component_on_canvas = True\n                return True\n        action = System.Action(__check_if_component_on_canvas)\n        Rhino.RhinoApp.InvokeOnUiThread(action)\n\n    def _check_if_component_enabled(self):\n        \"\"\" Check if the component is enabled from thread. \"\"\"\n        def __check_if_component_enabled():\n            if ghenv.Component.Locked:\n                self._component_enabled = False\n            else:\n                self._component_enabled = True\n        action = System.Action(__check_if_component_enabled)\n        Rhino.RhinoApp.InvokeOnUiThread(action)\n\n    def expire_component_solution(self):\n        \"\"\" Fire the recalculation of the component solution from thread. \"\"\"\n        def __expire_component_solution():\n            ghenv.Component.Params.Output[0].ClearData()  # clear the output\n            ghenv.Component.ExpireSolution(True)  # expire the component\n        action = System.Action(__expire_component_solution)\n        Rhino.RhinoApp.InvokeOnUiThread(action)\n\n    def clear_component(self):\n        \"\"\" Clear the component from thread. \"\"\"\n        def __clear_component():\n            ghenv.Component.ClearData()\n        action = System.Action(__clear_component)\n        Rhino.RhinoApp.InvokeOnUiThread(action)\n\n    def add_runtime_warning(self, exception : str):\n        \"\"\" Add a warning tab to the component from main thread. \"\"\"\n        action = System.Action(\n            lambda: ghenv.Component.AddRuntimeMessage(RML.Warning, exception)\n        )\n        Rhino.RhinoApp.InvokeOnUiThread(action)\n\n    def add_runtime_error(self, exception : str):\n        \"\"\" Add an error tab to the component from main thread. \"\"\"\n        action = System.Action(\n            lambda: ghenv.Component.AddRuntimeMessage(RML.Error, exception)\n        )\n        Rhino.RhinoApp.InvokeOnUiThread(action)\n\n    def add_runtime_remark(self, exception : str):\n        \"\"\" Add a blank tab to the component from main thread. \"\"\"\n        action = System.Action(\n            lambda: ghenv.Component.AddRuntimeMessage(RML.Remark, exception)\n        )\n        Rhino.RhinoApp.InvokeOnUiThread(action)\n\n    @property\n    def component_enabled(self):\n        self._check_if_component_enabled()\n        return self._component_enabled\n\n    @property\n    def component_on_canvas(self):\n        self._check_if_component_on_canvas()\n        return self._component_on_canvas\n\nclass ClientThread(GHThread):\n    \"\"\"\n    A thread to connect to the VSCode server.\n    \"\"\"\n    def __init__(self, vscode_server_ip: str, vscode_server_port: int, name: str,\n                 queue_msg: queue.Queue = None, lock_queue_msg: threading.Lock = None,\n                 event_fire_msg: threading.Event = None):\n        super().__init__(name=name)\n        self.vscode_server_ip = vscode_server_ip\n        self.vscode_server_port = vscode_server_port\n        self.is_connected = False\n        self.connect_refresh_rate = 1  # seconds\n        self.queue_msg = queue_msg\n        self.lock_queue_msg = lock_queue_msg\n        self.event_fire_msg = event_fire_msg\n        self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    def run(self):\n        \"\"\" Run the thread. Send the message to the vscode server.\"\"\"\n        while self.component_on_canvas and self.component_enabled:\n            try:\n                if not self.is_connected:\n                    self.connect_to_vscode_server()\n                    self.clear_component()\n                    self.expire_component_solution()\n                    continue\n\n                self.event_fire_msg.wait()\n                self.send_message_from_queue()\n\n            except Exception as e:\n                self.add_runtime_warning(f\"script-sync::Unkown error from run: {str(e)}\")\n                self.is_connected = False\n                self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n        self.client_socket.close()\n\n    def send_message_from_queue(self):\n        with self.lock_queue_msg:\n            if self.queue_msg and not self.queue_msg.empty():\n                msg = self.queue_msg.get()\n                self.queue_msg.task_done()\n                self.event_fire_msg.set()\n                self.event_fire_msg.clear()\n                self.client_socket.send(msg)\n\n    def connect_to_vscode_server(self):\n        \"\"\" Connect to the VSCode server. \"\"\"\n        while self.component_on_canvas and not self.is_connected:\n            try:\n                self.client_socket.send(b\"\")\n                self.is_connected = True\n            except socket.error:\n                try:\n                    self.client_socket.connect((self.vscode_server_ip, self.vscode_server_port))\n                    self.is_connected = True\n                except (ConnectionRefusedError, ConnectionResetError, socket.error) as e:\n                    self.handle_connection_error(e)\n            finally:\n                time.sleep(self.connect_refresh_rate)\n\n    def handle_connection_error(self, e):\n        error_messages = {\n            ConnectionRefusedError: \"script-sync::Not connected to vscode\",\n            ConnectionResetError: \"script-sync::Connection was forcibly closed by the vscode\",\n            socket.error: f\"script-sync::Error connecting to the vscode: {str(e)}, have you tried to press Shift+F4 on VSCode?\"\n        }\n        self.add_runtime_warning(error_messages[type(e)])\n        self.is_connected = False if type(e) != socket.error or e.winerror != 10056 else True\n\nclass FileChangedThread(GHThread):\n    \"\"\"\n        A thread to check if the file has changed on disk.\n    \"\"\"\n    def __init__(self,\n                path : str,\n                name : str\n                ):\n        super().__init__(name=name)\n        self.path = path\n        self.refresh_rate = 1000  # milliseconds\n        self._on_file_changed = threading.Event()\n\n    def run(self):\n        \"\"\"\n            Check if the file has changed on disk.\n        \"\"\"\n        last_modified = os.path.getmtime(self.path)\n        while self.component_on_canvas and not self._on_file_changed.is_set():\n            System.Threading.Thread.Sleep(self.refresh_rate)\n            last_modified = self.is_file_modified(last_modified)\n        self._on_file_changed.clear()\n        return\n\n    def stop(self):\n        \"\"\" Stop the thread. \"\"\"\n        self._on_file_changed.set()\n\n    def is_file_modified(self, last_modified):\n        current_modified = os.path.getmtime(self.path)\n        if current_modified != last_modified:\n            self.expire_component_solution()\n            return current_modified\n        return last_modified\n\nclass ScriptSyncCPy(Grasshopper.Kernel.GH_ScriptInstance):\n    def __init__(self):\n        self._var_output = []\n\n        self.is_success = False\n\n        self.client_thread_name : str = f\"script-sync-client-thread::{ghenv.Component.InstanceGuid}\"\n        self.vscode_server_ip = \"127.0.0.1\"\n        self.vscode_server_port = 58260\n        self.stdout = None\n        self.queue_msg = queue.Queue()\n        self.queue_msg_lock = threading.Lock()\n        self.event_fire_msg = threading.Event()\n\n        self.filechanged_thread_name : str = f\"script-sync-fileChanged-thread::{ghenv.Component.InstanceGuid}\"\n        self.__path_name_table_value = \"script-sync::\" + \"path::\" + str(ghenv.Component.InstanceGuid)\n        if self.path is None:\n            ghenv.Component.Message = \"select-script\"\n        else:\n            ghenv.Component.Message = os.path.basename(self.path)\n\n        ghenv.Component.ExpireSolution(True)\n        ghenv.Component.Attributes.PerformLayout()\n        params = getattr(ghenv.Component.Params, \"Input\")\n        for j in range(len(params)):\n            X_cord = params[j].Attributes.Pivot.X\n            Y_cord = params[j].Attributes.InputGrip.Y\n            if params[j].Name == \"select_file\":\n                add_button(self, \"Select file\", j, X_cord, Y_cord)\n\n    def RemovedFromDocument(self, doc):\n        \"\"\" Remove the component from the document. \"\"\"\n        if self.client_thread_name in [t.name for t in threading.enumerate()]:\n            client_thread = [t for t in threading.enumerate() if t.name == self.client_thread_name][0]\n            client_thread.join()\n        if self.filechanged_thread_name in [t.name for t in threading.enumerate()]:\n            filechanged_thread = [t for t in threading.enumerate() if t.name == self.filechanged_thread_name][0]\n            filechanged_thread.join()\n        if self.queue_msg is not None:\n            self.queue_msg.join()\n        if self.queue_msg_lock is not None:\n            self.queue_msg_lock.release()\n        if self.event_fire_msg is not None:\n            self.event_fire_msg.clear()\n\n        # clear the path from the table view\n        del self.path\n\n    def init_script_path(self, select_file : bool = False) -> None:\n        \"\"\"\n            Check if the button is pressed and load/change path script.\n            \n            :param select_file: A boolean of the button\n        \"\"\"\n        # check if button is pressed\n        if select_file is True:\n            filename = rs.OpenFileName(\"Open\", \"Python Files (*.py)|*.py||\")\n            if filename is None:\n                raise Exception(\"script-sync::No file selected\")\n            self.path = filename\n\n        if self.path is None:\n            ghenv.Component.AddRuntimeMessage(RML.Remark, \"script-sync::No file selected\")\n            return\n        else:\n            # if file is in table view before\n            if not os.path.exists(self.path):\n                raise Exception(\"script-sync::File does not exist\")\n\n    def reload_all_modules(self, directory):\n        for filename in os.listdir(directory):\n            if filename.endswith('.py') and filename != '__init__.py':\n                module_name = filename[:-3]  # remove '.py' from filename\n                if module_name in sys.modules:\n                    importlib.reload(sys.modules[module_name])\n\n    def safe_exec(self, path, globals, locals, package_2_reload):\n        \"\"\"\n            Execute Python3 code safely. It redirects the output of the code\n            to a string buffer 'stdout' to output to the GH component param.\n            It is send to the vscode server.\n            \n            :param path: The path of the file to execute.\n            :param globals: The globals dictionary.\n            :param locals: The locals dictionary.\n            :param package_2_reload: The list of packages to reload, this is used for custom packages developement.\n            installed on the system via an editable pip installation for example.\n        \"\"\"\n        output_buffer = io.StringIO()\n        try:\n            sys.stdout = output_buffer\n            with open(path, 'r') as f:\n                # reload the specifyed packages\n                if package_2_reload is not None:\n                    if package_2_reload.__len__() != 0:\n                        for key in list(sys.modules.keys()):\n                            if package_2_reload in key:\n                                # check that the package must have the attribute __file__ (to avoid reloading pyd)\n                                if hasattr(sys.modules[key], '__file__'):\n                                    importlib.reload(sys.modules[key])\n\n                # add the path and sub directories to  the sys path\n                path_dir = os.path.dirname(path)\n                sub_dirs = []\n                for root, dirs, files in os.walk(path_dir):\n                    for d in dirs:\n                        sub_dirs.append(os.path.join(root, d))\n                sys.path.extend([path_dir] + sub_dirs)\n\n                # reload all the modules also of the sub directories\n                for root, dirs, files in os.walk(path_dir):\n                    for d in dirs:\n                        self.reload_all_modules(os.path.join(root, d))\n                self.reload_all_modules(path_dir)\n\n                # refresh the python interpreter\n                importlib.invalidate_caches()\n\n                # parse the code\n                code = compile(f.read(), path, 'exec')\n                # output = io.StringIO()\n\n                # empty the queue and event\n                with self.queue_msg_lock:\n                    while not self.queue_msg.empty():\n                        self.queue_msg.get()\n                        self.queue_msg.task_done()\n                self.event_fire_msg.clear()\n\n                # clear all the locals dictionary to avoid that the output variables stick between the component\n                # executions when it is recomputed\n                outparam = ghenv.Component.Params.Output\n                outparam_names = [p.NickName for p in outparam]\n                for outp in outparam_names:\n                    if outp in locals.keys():\n                        del locals[outp]\n\n                # execute the code\n                with contextlib.redirect_stdout(output_buffer):\n                    exec(code, globals, locals)\n                locals[\"stdout\"] = output_buffer.getvalue()\n\n                # send the msg to the vscode server\n                msg_json = json.dumps({\"script_path\": path,\n                                       \"guid\": str(ghenv.Component.InstanceGuid),\n                                       \"msg\": output_buffer.getvalue()})\n                msg_json = msg_json.encode('utf-8')\n                self.queue_msg.put(msg_json)\n                self.event_fire_msg.set()\n\n                # pass the script variables to the GH component outputs\n                for outp in outparam_names:\n                    if outp in locals.keys():\n                        self._var_output.append(locals[outp])\n                    else:\n                        self._var_output.append(None)\n            return locals\n\n        except Exception as e:\n            # Get the traceback\n            tb = traceback.format_exc()\n\n            # Send the error message to the vscode server\n            err_json = json.dumps({\n                \"script_path\": path,\n                \"guid\": str(ghenv.Component.InstanceGuid),\n                \"msg\": \"err:\" + str(e),\n                \"traceback\": tb  # Include the traceback in the JSON\n            })\n            err_json = err_json.encode('utf-8')\n            self.queue_msg.put(err_json)\n            self.event_fire_msg.set()\n\n            # FIXME: this is not working the retrival of the previous messages\n            # for debugging purposes we include the prints before and the error message\n            err_msg_header = f\"script-sync::Error in the code file {path}\"\n            err_msg_sep = \">\" * 30\n            err_msg = f\"script-sync::Error in the code: {str(e)}\\n{tb}\"\n            prints_before_err_msg = output_buffer.getvalue()\n            prints_before_msg = prints_before_err_msg.split(\"\\n\")\n\n            err_msg = err_msg_header + \\\n                f\"\\n{err_msg_sep}\\n\" + \"Error msg:\" + f\"\\n{err_msg_sep}\\n\" + \\\n                err_msg\n                # f\"\\n{err_msg_sep}\\n\" + \"Preavious prints before error:\" + f\"\\n{err_msg_sep}\\n\" + \\\n                # \"\\n\".join(prints_before_msg[:-1])\n\n            raise Exception(err_msg)\n        \n        finally:\n            sys.stdout = sys.__stdout__\n            output_buffer.close()\n\n    def RunScript(self, select_file: bool, package_2_reload: str, x : int):\n        \"\"\" This method is called whenever the component has to be recalculated it's the solve main instance. \"\"\"\n        self.is_success = False\n\n        # set up the tcp client to connect to the vscode server\n        _ = [print(t.name) for t in threading.enumerate()]\n        if self.client_thread_name not in [t.name for t in threading.enumerate()]:\n            ClientThread(self.vscode_server_ip,\n                        self.vscode_server_port,\n                        self.client_thread_name,\n                        self.queue_msg,\n                        self.queue_msg_lock,\n                        self.event_fire_msg\n                        ).start()\n        \n        # set the path if button is pressed\n        self.init_script_path(select_file)\n\n        # file change listener thread\n        if self.filechanged_thread_name not in [t.name for t in threading.enumerate()]:\n            FileChangedThread(self.path,\n                            self.filechanged_thread_name\n                            ).start()\n\n    \n\n        # add to the globals all the input parameters of the component (the locals)\n        globals().update(locals())\n\n        # execute the external script\n        if self.path is not None:\n            res = self.safe_exec(self.path, None, globals(), package_2_reload)\n            self.is_success = True\n        \n        return\n\n    def AfterRunScript(self):\n        \"\"\"\n            This method is called as soon as the component has finished\n            its calculation. It is used to load the GHComponent outputs\n            with the values created in the script.\n        \"\"\"\n        def _is_first_lvl_nested_iterable(lst : typing.List) -> bool:\n            \"\"\"\n            Detect if the first level of a list is nested. \n            e.g. \n                [1, 2, 3, 4, [5,6]] --> return value: False\n                [[1, 2], [3, 4]] --> return value: True\n\n            :param lst: The list to check\n            :return: True if the first level is nested, False otherwise\n            \"\"\"\n            return all(isinstance(item, list) for item in lst)\n        \n        def _nesting_level(container: typing.Union[typing.List, typing.Tuple]) -> int:\n            \"\"\" Get the level of nesting of a list or tuple. \"\"\"\n            if isinstance(container, (list, tuple)):\n                return 1 + max(_nesting_level(item) for item in container)\n            else:\n                return 0\n\n        def _force_nesting_list(lst : typing.List) -> list:\n            \"\"\"\n                Transform a list with nested lists into a list of lists.\n                \n                Example:\n                >>> list_C = [\n                                1, 2, 3, 4,  # {0;0}\n                                [5, 6],      # {1;0}\n                                [7, 8]       # {2;0}\n                            ]\n                >>> _force_nesting_list(list_C)\n                [[1, 2, 3, 4], [5, 6], [7, 8]]\n\n                :param lst: The list to transform\n                :return: The transformed list\n            \"\"\"\n            transformed_list = []\n            sublist = []\n            \n            for item in lst:\n                if isinstance(item, list):\n                    if sublist:\n                        transformed_list.append(sublist)\n                        sublist = []\n                    transformed_list.append(item)\n                else:\n                    sublist.append(item)\n            if sublist:\n                transformed_list.append(sublist)\n            \n            return transformed_list\n\n        def _get_list_shape(lst : typing.List) -> tuple:\n            \"\"\"\n                Get the shape of a list of lists.\n                \n                Example:\n                >>> list_A = [\n                                [\n                                    [1, 2],  # {0;0}\n                                    [3, 4]   # {0;1}\n                                ],\n                                [\n                                    [5, 6],  # {1;0}\n                                    [7, 8]   # {1;1}\n                                ]\n                            ]\n                >>> _get_list_shape(list_A)\n                (2, 2, 2)\n\n                :param lst: The list to get the shape of\n                :return: The shape of the list\n            \"\"\"\n            if isinstance(lst, list):\n                if len(lst) == 0:\n                    return (0,)\n                return (len(lst),) + _get_list_shape(lst[0])\n            else:\n                return ()\n\n        if not self.is_success:\n            return\n\n        outparam = [p for p in ghenv.Component.Params.Output]\n        outparam_names = [p.NickName for p in outparam]\n\n        for idx, outp in enumerate(outparam):\n            # case 1: nested lists\n            if type(self._var_output[idx]) == tuple or type(self._var_output[idx]) == list:\n                self._var_output[idx] = th.list_to_tree(self._var_output[idx])\n\n\n                # ghenv.Component.Params.Output[idx].VolatileData.Clear()\n\n                # list_nest_lvl = _nesting_level(self._var_output[idx])\n\n                # # case *: force the nesting of the list if it is nested but also with single elements on the first level (e.g. [1, 2, [3, 4]] --> [[1, 2], [3, 4]])\n                # if list_nest_lvl >= 2 and _is_first_lvl_nested_iterable(self._var_output[idx]) is False:\n                #     self._var_output[idx] = _force_nesting_list(self._var_output[idx])\n\n                # # case 1.A: <<< DESCRIPTION >>>\n                # if list_nest_lvl == 1:\n                #     ghenv.Component.Params.Output[idx].AddVolatileDataList(gh.Kernel.Data.GH_Path(0), self._var_output[idx])\n                # # case 1.B: <<< DESCRIPTION >>>\n                # elif list_nest_lvl == 2:\n                #     nbr_tuples_aka_branches = len(self._var_output[idx])\n                #     for i in range(nbr_tuples_aka_branches):\n                #         ghenv.Component.Params.Output[idx].AddVolatileDataList(gh.Kernel.Data.GH_Path(i), self._var_output[idx][i])\n                # # case 1.C: <<< DESCRIPTION >>>\n                # elif list_nest_lvl > 2:\n\n\n                #     # TODO: to be solved\n                #     # >>>>>>>>>>>>>>>>>>>>>>>>>\n                #     list_shape = _get_list_shape(self._var_output[idx])\n                #     # Create a recursive function to add the volatile data\n\n\n                #     def add_volatile_data_recursive(output_param, data, path):\n                #         if isinstance(data, list):\n                #             for i, item in enumerate(data):\n                #                 new_path = gh.Kernel.Data.GH_Path(path)\n                #                 new_path = new_path.AppendElement(i)\n                #                 add_volatile_data_recursive(output_param, item, new_path)\n                #         else:\n                #             output_param.AddVolatileData(path, 0, data)  # Use index 0 for leaf nodes\n\n                #     # Example usage within your existing code\n                #     nbr_tuples_aka_branches = len(self._var_output[idx])\n                #     for i in range(nbr_tuples_aka_branches):\n                #         path = gh.Kernel.Data.GH_Path(i)\n                #         add_volatile_data_recursive(ghenv.Component.Params.Output[idx], self._var_output[idx][i], path)\n                #     # <<<<<<<<<<<<<<<<<<<<<<<<<\n            # else:\n            # case 2: single values\n            ghenv.Component.Params.Output[idx].VolatileData.Clear()\n            # case 2.A: the user is returning a Grasshopper.DataTree[System.Object] via the utility ghpythonlib.treehelpers\n            # e.g.: list_tree = th.list_to_tree(list_A)\n            # this will be conserve the structure\n            if type(self._var_output[idx]) == Grasshopper.DataTree[System.Object]:\n                # self._var_output[idx].SimplifyPaths()\n                branch_count = self._var_output[idx].BranchCount\n                for i in range(branch_count):\n                    path = self._var_output[idx].Paths[i]\n                    data = self._var_output[idx].Branch(path)\n                    ghenv.Component.Params.Output[idx].AddVolatileDataList(path, data)\n            # case 2.B: simple single value\n            else:\n                ghenv.Component.Params.Output[idx].AddVolatileData(gh.Kernel.Data.GH_Path(0), 0, self._var_output[idx])\n        \n        self._var_output.clear()\n\n    @property\n    def path(self):\n        \"\"\" Get the path of the file from the table view to be sticking between the sessions. \"\"\"\n        table_value = ghenv.Component.OnPingDocument().ValueTable.GetValue(\n            self.__path_name_table_value, \"not_found\"\n        )\n        if table_value != \"not_found\":\n            return table_value\n        else:\n            return None\n\n    @path.setter\n    def path(self, path : str):\n        \"\"\" Set the path of the file to the table view to be sticking between the sessions. \"\"\"\n        ghenv.Component.OnPingDocument().ValueTable.SetValue(self.__path_name_table_value, path)\n\n        script_name = os.path.basename(path)\n        ghenv.Component.Message = f\"{script_name}\"\n\n        if self.filechanged_thread_name in [t.name for t in threading.enumerate()]:\n            _ = [t for t in threading.enumerate() if t.name == self.filechanged_thread_name][0].stop()\n\n    @path.deleter\n    def path(self):\n        \"\"\" Delete the path of the file from the table view if the object is erased. \"\"\"\n        ghenv.Component.OnPingDocument().ValueTable.DeleteValue(self.__path_name_table_value)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "classes", "functions", "point"], "original_file": "ibois-epfl_script-sync_b1afdf97a0.json", "repo": "ibois-epfl/script-sync"}
{"instruction": "Finds the point on an infinite line that is closest to a test point", "code": "import Rhino\n\nimport scriptcontext\n\nimport rhinocompat as compat\nfrom rhinoscript import utility as rhutil\n\n\ndef LineClosestPoint(line, testpoint):\n    \"\"\"Finds the point on an infinite line that is closest to a test point\n    Parameters:\n      line ([point, point]): List of 6 numbers or 2 Point3d.  Two 3-D points identifying the starting and ending points of the line.\n      testpoint (point): List of 3 numbers or Point3d.  The test point.\n    Returns:\n      point: the point on the line that is closest to the test point if successful, otherwise None\n    Example:\n      import rhinoscriptsyntax as rs\n      line = (0,0,0), (5,5,0)\n      point = (15, 10, 0)\n      result = rs.LineClosestPoint( line, point)\n      if result: rs.AddPoint(result)\n    See Also:\n      LineIsFartherThan\n      LineMaxDistanceTo\n      LineMinDistanceTo\n      LinePlane\n      LineTransform\n    \"\"\"\n    line = rhutil.coerceline(line, True)\n    testpoint = rhutil.coerce3dpoint(testpoint, True)\n    return line.ClosestPoint(testpoint, False)\n\n\ndef LineCylinderIntersection(line, cylinder_plane, cylinder_height, cylinder_radius):\n    \"\"\"Calculates the intersection of a line and a cylinder\n    Parameters:\n      line (guid|line): the line to intersect\n      cylinder_plane (plane): base plane of the cylinder\n      cylinder_height (number): height of the cylinder\n      cylinder_radius (number): radius of the cylinder\n    Returns:\n      list(point, ...): list of intersection points (0, 1, or 2 points)\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.WorldXYPlane()\n      line = (-10,0,0), (10,0,10)\n      points = rs.LineCylinderIntersection(line, plane, cylinder_height=10, cylinder_radius=5)\n      if points:\n          for point in points: rs.AddPoint(point)\n    See Also:\n      LineLineIntersection\n      LinePlaneIntersection\n      LineSphereIntersection\n    \"\"\"\n    line = rhutil.coerceline(line, True)\n    cylinder_plane = rhutil.coerceplane(cylinder_plane, True)\n    circle = Rhino.Geometry.Circle( cylinder_plane, cylinder_radius )\n    if not circle.IsValid: raise ValueError(\"unable to create valid circle with given plane and radius\")\n    cyl = Rhino.Geometry.Cylinder( circle, cylinder_height )\n    if not cyl.IsValid: raise ValueError(\"unable to create valid cylinder with given circle and height\")\n    rc, pt1, pt2 = Rhino.Geometry.Intersect.Intersection.LineCylinder(line, cyl)\n    if rc==compat.ENUM_NONE(Rhino.Geometry.Intersect.LineCylinderIntersection):\n        return []\n    if rc==Rhino.Geometry.Intersect.LineCylinderIntersection.Single:\n        return [pt1]\n    return [pt1, pt2]\n\n\ndef LineIsFartherThan(line, distance, point_or_line):\n    \"\"\"Determines if the shortest distance from a line to a point or another\n    line is greater than a specified distance\n    Parameters:\n      line (line | [point, point]): List of 6 numbers, 2 Point3d, or Line.\n      distance (number): the distance\n      point_or_line (point|line) the test point or the test line\n    Returns:\n      bool: True if the shortest distance from the line to the other project is\n            greater than distance, False otherwise\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      line = (0,0,0), (10,10,0)\n      testPoint = (10,5,0)\n      print(rs.LineIsFartherThan(line, 3, testPoint))\n    See Also:\n      LineClosestPoint\n      LineMaxDistanceTo\n      LineMinDistanceTo\n      LinePlane\n      LineTransform\n    \"\"\"\n    line = rhutil.coerceline(line, True)\n    test = rhutil.coerceline(point_or_line)\n    if not test: test = rhutil.coerce3dpoint(point_or_line, True)\n    minDist = line.MinimumDistanceTo(test)\n    return minDist>distance\n\n\ndef LineLineIntersection(lineA, lineB):\n    \"\"\"Calculates the intersection of two non-parallel lines. Note, the two\n    lines do not have to intersect for an intersection to be found. (see help)\n    Parameters:\n      lineA, lineB (line): lines to intersect\n    Returns:\n      tuple(point, point): containing a point on the first line and a point on the second line if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      lineA = (1,1,0), (5,0,0)\n      lineB = (1,3,0), (5,5,0)\n      point = rs.LineLineIntersection(lineA, lineB)\n      if point:\n          rs.AddPoint(point[0])\n          rs.AddPoint(point[1])\n    See Also:\n      IntersectPlanes\n      LinePlaneIntersection\n      PlanePlaneIntersection\n    \"\"\"\n    lineA = rhutil.coerceline(lineA, True)\n    lineB = rhutil.coerceline(lineB, True)\n    rc, a, b = Rhino.Geometry.Intersect.Intersection.LineLine(lineA, lineB)\n    if not rc: return None\n    return lineA.PointAt(a), lineB.PointAt(b)\n\n\ndef LineMaxDistanceTo(line, point_or_line):\n    \"\"\"Finds the longest distance between a line as a finite chord, and a point\n    or another line\n    Parameters:\n      line (line | [point, point]): List of 6 numbers, two Point3d, or Line.\n      point_or_line (point|line): the test point or test line.\n    Returns:\n      number: A distance (D) such that if Q is any point on the line and P is any point on the other object, then D >= Rhino.Distance(Q, P).\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      line = (0,0,0), (10,10,0)\n      print(rs.LineMaxDistanceTo( line, (10,5,0) ))\n    See Also:\n      LineClosestPoint\n      LineIsFartherThan\n      LineMinDistanceTo\n      LinePlane\n      LineTransform\n    \"\"\"\n    line = rhutil.coerceline(line, True)\n    test = rhutil.coerceline(point_or_line)\n    if test is None: test = rhutil.coerce3dpoint(point_or_line, True)\n    return line.MaximumDistanceTo(test)\n\n\ndef LineMinDistanceTo(line, point_or_line):\n    \"\"\"Finds the shortest distance between a line as a finite chord, and a point\n    or another line\n    Parameters:\n      line (line | [point, point]): List of 6 numbers, two Point3d, or Line.\n      point_or_line (point|line): the test point or test line.\n    Returns:\n      number: A distance (D) such that if Q is any point on the line and P is any point on the other object, then D <= Rhino.Distance(Q, P).\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      line = (0,0,0), (10,10,0)\n      print(rs.LineMinDistanceTo(line, (10,5,0)))\n    See Also:\n      LineClosestPoint\n      LineIsFartherThan\n      LineMaxDistanceTo\n      LinePlane\n      LineTransform\n    \"\"\"\n    line = rhutil.coerceline(line, True)\n    test = rhutil.coerceline(point_or_line)\n    if test is None: test = rhutil.coerce3dpoint(point_or_line, True)\n    return line.MinimumDistanceTo(test)\n\n\ndef LinePlane(line):\n    \"\"\"Returns a plane that contains the line. The origin of the plane is at the start of\n    the line. If possible, a plane parallel to the world XY, YZ, or ZX plane is returned\n    Parameters:\n      line (line | [point, point]):  List of 6 numbers, two Point3d, or Line.\n    Returns:\n      plane: the plane if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      lineFrom = (0,0,0)\n      lineTo = (10,10,0)\n      distance = rs.Distance(lineFrom, lineTo)\n      plane = rs.LinePlane([lineFrom, lineTo])\n      rs.AddPlaneSurface( plane, distance, distance )\n    See Also:\n      LineClosestPoint\n      LineIsFartherThan\n      LineMaxDistanceTo\n      LineMinDistanceTo\n      LineTransform\n    \"\"\"\n    line = rhutil.coerceline(line, True)\n    rc, plane = line.TryGetPlane()\n    if not rc: return scriptcontext.errorhandler()\n    return plane\n\n\ndef LinePlaneIntersection(line, plane):\n    \"\"\"Calculates the intersection of a line and a plane.\n    Parameters:\n      line ([point, point]): Two 3D points identifying the starting and ending points of the line to intersect.\n      plane (plane): The plane to intersect.\n    Returns:\n      point: The 3D point of intersection is successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.WorldXYPlane()\n      line = (2, 11, 13), (20, 4, -10)\n      point = rs.LinePlaneIntersection(line, plane)\n      if( point!=None ): rs.AddPoint(point)\n    See Also:\n      LineLineIntersection\n      PlanePlaneIntersection\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    line_points = rhutil.coerce3dpointlist(line, True)\n    line = Rhino.Geometry.Line(line_points[0], line_points[1])\n    rc, t = Rhino.Geometry.Intersect.Intersection.LinePlane(line, plane) \n    if  not rc: return scriptcontext.errorhandler()\n    return line.PointAt(t)\n\n\ndef LineSphereIntersection(line, sphere_center, sphere_radius):\n    \"\"\"Calculates the intersection of a line and a sphere\n    Parameters:\n      line (line | [point, point]): the line\n      sphere_center (point): the center point of the sphere\n      sphere_radius (number): the radius of the sphere\n    Returns:\n      list(point, ...): list of intersection points if successful, otherwise None\n    Example:\n      import rhinoscriptsyntax as rs\n      radius = 10\n      line = (-10,0,0), (10,0,10)\n      points = rs.LineSphereIntersection(line, (0,0,0), radius)\n      if points:\n          for point in points: rs.AddPoint(point)\n    See Also:\n      LineCylinderIntersection\n      LineLineIntersection\n      LinePlaneIntersection\n    \"\"\"\n    line = rhutil.coerceline(line, True)\n    sphere_center = rhutil.coerce3dpoint(sphere_center, True)\n    sphere = Rhino.Geometry.Sphere(sphere_center, sphere_radius)\n    rc, pt1, pt2 = Rhino.Geometry.Intersect.Intersection.LineSphere(line, sphere)\n    if rc==compat.ENUM_NONE(Rhino.Geometry.Intersect.LineSphereIntersection): return []\n    if rc==Rhino.Geometry.Intersect.LineSphereIntersection.Single: return [pt1]\n    return [pt1, pt2]\n\n\ndef LineTransform(line, xform):\n    \"\"\"Transforms a line\n    Parameters:\n      line (guid): the line to transform\n      xform (transform): the transformation to apply\n    Returns:\n      guid: transformed line\n    Example:\n      import rhinoscriptsyntax as rs\n      line = (0,0,0), (10,10,0)\n      rs.AddLine( line[0], line[1] )\n      plane = rs.WorldXYPlane()\n      xform = rs.XformRotation(30, plane.Zaxis, plane.Origin)\n      line = rs.LineTransform(line, xform)\n      rs.AddLine( line.From, line.To )\n    See Also:\n      LineClosestPoint\n      LineIsFartherThan\n      LineMaxDistanceTo\n      LineMinDistanceTo\n      LinePlane\n    \"\"\"\n    line = rhutil.coerceline(line, True)\n    xform = rhutil.coercexform(xform, True)\n    success = line.Transform(xform)\n    if not success: raise Exception(\"unable to transform line\")\n    return line\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "line", "functions", "RhinoCommon"], "original_file": "jingcheng-chen_rhinomcp_04108076ce.json", "repo": "jingcheng-chen/rhinomcp"}
{"instruction": "Adds a new block definition to the document", "code": "import math\n\nimport System\n\nimport Rhino\n\nimport scriptcontext\n\nfrom rhinoscript import utility as rhutil\n\n\ndef __InstanceObjectFromId(id, raise_if_missing):\n    rhobj = rhutil.coercerhinoobject(id, True, raise_if_missing)\n    if isinstance(rhobj, Rhino.DocObjects.InstanceObject): return rhobj\n    if raise_if_missing: raise ValueError(\"unable to find InstanceObject\")\n\n\ndef AddBlock(object_ids, base_point, name=None, delete_input=False):\n    \"\"\"Adds a new block definition to the document\n    Parameters:\n      object_ids ([guid, ....]) objects that will be included in the block\n      base_point (point): 3D base point for the block definition\n      name (str, optional): name of the block definition. If omitted a name will be\n        automatically generated\n      delete_input (bool): if True, the object_ids will be deleted\n    Returns:\n      str: name of new block definition on success\n    Example:\n      import rhinoscriptsyntax as rs\n      objs = rs.GetObjects(\"Select objects to define block\")\n      if objs:\n          point = rs.GetPoint(\"Block base point\")\n          if point:\n              block = rs.AddBlock(objs, point, None, True)\n              rs.InsertBlock(block, point)\n    See Also:\n      InsertBlock\n    \"\"\"\n    base_point = rhutil.coerce3dpoint(base_point, True)\n    if not name:\n        name = scriptcontext.doc.InstanceDefinitions.GetUnusedInstanceDefinitionName()\n    found = scriptcontext.doc.InstanceDefinitions.Find(name)\n    objects = []\n    for id in object_ids:\n        obj = rhutil.coercerhinoobject(id, True)\n        if obj.IsReference: return\n        ot = obj.ObjectType\n        if ot==Rhino.DocObjects.ObjectType.Light: return\n        if ot==Rhino.DocObjects.ObjectType.Grip: return\n        if ot==Rhino.DocObjects.ObjectType.Phantom: return\n        if ot==Rhino.DocObjects.ObjectType.InstanceReference and found:\n            uses, nesting = obj.UsesDefinition(found.Index)\n            if uses: return\n        objects.append(obj)\n    if objects:\n        geometry = [obj.Geometry for obj in objects]\n        attrs = [obj.Attributes for obj in objects]\n        rc = 0\n        if found:\n          rc = scriptcontext.doc.InstanceDefinitions.ModifyGeometry(found.Index, geometry, attrs)\n        else:\n          rc = scriptcontext.doc.InstanceDefinitions.Add(name, \"\", base_point, geometry, attrs)\n        if rc>=0:\n            if delete_input:\n                for obj in objects: scriptcontext.doc.Objects.Delete(obj, True)\n            scriptcontext.doc.Views.Redraw()\n    return name\n\n\ndef BlockContainerCount(block_name):\n    \"\"\"Returns number of block definitions that contain a specified\n    block definition\n    Parameters:\n      block_name (str): the name of an existing block definition\n    Returns:\n      number: the number of block definitions that contain a specified block definition\n    Example:\n      import rhinoscriptscriptsyntax as rs\n      block = rs.GetString(\"Block name to query\")\n      if rs.IsBlock(block):\n          count = rs.BlockContainerCount(block)\n          print(\"This block is nested in {} block(s).\".format(count))\n    See Also:\n      BlockContainers\n      IsBlock\n    \"\"\"\n    return len(BlockContainers(block_name))\n\n\ndef BlockContainers(block_name):\n    \"\"\"Returns names of the block definitions that contain a specified block\n    definition.\n    Parameters:\n      block_name (str): the name of an existing block definition\n    Returns:\n      list(str, ...): A list of block definition names\n    Example:\n      import rhinoscriptsyntax as rs\n      blockname = rs.GetString(\"Block name to query\")\n      if rs.IsBlock(blockname):\n          blocks = rs.BlockContainers(blockname)\n          for block in blocks: print(block)\n    See Also:\n      BlockContainerCount\n      IsBlock\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    containers = idef.GetContainers()\n    rc = []\n    for item in containers:\n        if not item.IsDeleted: rc.append(item.Name)\n    return rc\n\n\ndef BlockCount():\n    \"\"\"Returns the number of block definitions in the document\n    Returns:\n      number: the number of block definitions in the document\n    Example:\n      import rhinoscriptsyntax as rs\n      count = rs.BlockCount()\n      print(\"There are {} blocks\".format(count)\n    See Also:\n      BlockNames\n      IsBlock\n    \"\"\"\n    return scriptcontext.doc.InstanceDefinitions.ActiveCount\n\n\ndef BlockDescription(block_name, description=None):\n    \"\"\"Returns or sets the description of a block definition\n    Parameters:\n      block_name (str): the name of an existing block definition\n      description (str, optional): The new description.\n    Returns:\n      str: if description is not specified, the current description\n      str: if description is specified, the previous description\n    Example:\n      import rhinoscriptsyntax as rs\n      blockname = rs.GetString(\"Block name to list description\")\n      if rs.IsBlock(blockname):\n          desc = rs.BlockDescription(blockname)\n          if desc is None: print(\"No description\")\n          else: print(desc)\n    See Also:\n      IsBlock\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    rc = idef.Description\n    if description: scriptcontext.doc.InstanceDefinitions.Modify( idef, idef.Name, description, True )\n    return rc\n\n\ndef BlockInstanceCount(block_name,where_to_look=0):\n    \"\"\"Counts number of instances of the block in the document.\n    Nested instances are not included in the count.\n    Parameters:\n      block_name (str): the name of an existing block definition\n      where_to_look (number, optional):\n        0 = get top level references in active document.\n        1 = get top level and nested references in active document.\n        2 = check for references from other instance definitions\n    Returns:\n      number: the number of instances of the block in the document\n    Example:\n      import rhinoscriptsyntax as rs\n      blockname = rs.GetString(\"Block to count\")\n      if rs.IsBlock(blockname):\n          count = rs.BlockInstanceCount(blockname)\n          print(\"{} block(s) found.\".format(count))\n    See Also:\n      BlockInstanceInsertPoint\n      BlockInstances\n      BlockInstanceXform\n      IsBlockInstance\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    refs = idef.GetReferences(where_to_look)\n    return len(refs)\n\n\ndef BlockInstanceInsertPoint(object_id):\n    \"\"\"Returns the insertion point of a block instance.\n    Parameters:\n      object_id (guid): The identifier of an existing block insertion object\n    Returns:\n      point: The insertion 3D point if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      strObject = rs.GetObject(\"Select block\")\n      if rs.IsBlockInstance(strObject):\n          rs.AddPoint( rs.BlockInstanceInsertPoint(strObject) )\n    See Also:\n      BlockInstanceCount\n      BlockInstances\n      BlockInstanceXform\n      IsBlockInstance\n    \"\"\"\n    instance = __InstanceObjectFromId(object_id, True)\n    xf = instance.InstanceXform\n    pt = Rhino.Geometry.Point3d.Origin\n    pt.Transform(xf)\n    return pt\n\n\ndef BlockInstanceName(object_id):\n    \"\"\"Returns the block name of a block instance\n    Parameters:\n      object_id (guid): The identifier of an existing block insertion object\n    Returns:\n      str: the block name of a block instance\n    Example:\n      import rhinoscriptsyntax as rs\n      strObject = rs.GetObject(\"Select block\")\n      if rs.IsBlockInstance(strObject):\n          print(rs.BlockInstanceName(strObject))\n    See Also:\n      BlockInstanceCount\n      BlockInstances\n      BlockInstanceXform\n      IsBlockInstance\n    \"\"\"\n    instance = __InstanceObjectFromId(object_id, True)\n    idef = instance.InstanceDefinition\n    return idef.Name\n\n\ndef BlockInstances(block_name,where_to_look=0):\n    \"\"\"Returns the identifiers of the inserted instances of a block.\n    Parameters:\n      block_name (str): the name of an existing block definition\n      where_to_look (number, optional):\n        0 = get top level references in active document.\n        1 = get top level and nested references in active document.\n        2 = check for references from other instance definitions\n    Returns:\n      list(guid, ...): Ids identifying the instances of a block in the model.\n    Example:\n      import rhinoscriptsyntax as rs\n      strBlock = rs.GetString(\"Block to select\")\n      if rs.IsBlock(strBlock):\n          arrObjects = rs.BlockInstances(strBlock)\n          if arrobjects:\n              rs.SelectObjects(arrObjects)\n    See Also:\n      BlockInstanceCount\n      BlockInstanceInsertPoint\n      BlockInstanceXform\n      IsBlockInstance\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    instances = idef.GetReferences(where_to_look)\n    return [item.Id for item in instances]\n\n\ndef BlockInstanceXform(object_id):\n    \"\"\"Returns the location of a block instance relative to the world coordinate\n    system origin (0,0,0). The position is returned as a 4x4 transformation\n    matrix\n    Parameters:\n      object_id (guid): The identifier of an existing block insertion object\n    Returns:\n      transform: the location, as a transform matrix, of a block instance relative to the world coordinate\n    system origin\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select block to query\")\n      if rs.IsBlockInstance(obj):\n          arrMatrix = rs.BlockInstanceXform(obj)\n          if arrMatrix is not None:\n              pointId = rs.AddPoint([0,0,0])\n              rs.TransformObject( pointId, arrMatrix)\n    See Also:\n      BlockInstanceCount\n      BlockInstanceInsertPoint\n      BlockInstances\n      IsBlockInstance\n    \"\"\"\n    instance = __InstanceObjectFromId(object_id, True)\n    return instance.InstanceXform\n\n\ndef BlockNames( sort=False ):\n    \"\"\"Returns the names of all block definitions in the document\n    Parameters:\n      sort (bool): True to return a sorted list\n    Returns:\n      list(str, ...): the names of all block definitions in the document\n    Example:\n      import rhinoscriptsyntax as rs\n      names = rs.BlockNames(True)\n      if names:\n          for name in names: print(name)\n    See Also:\n      BlockCount\n      IsBlock\n    \"\"\"\n    ideflist = scriptcontext.doc.InstanceDefinitions.GetList(True)\n    rc = [item.Name for item in ideflist]\n    if(sort): rc.sort()\n    return rc\n\n\ndef BlockObjectCount(block_name):\n    \"\"\"Returns number of objects that make up a block definition\n    Parameters:\n      block_name (str): name of an existing block definition\n    Returns:\n      number: the number of objects that make up a block definition\n    Example:\n      import rhinoscriptsyntax as rs\n      count = rs.BlockObjectCount()\n      print(\"There are {} blocks\".format(count))\n    See Also:\n      BlockNames\n      BlockObjects\n      IsBlock\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    return idef.ObjectCount\n\n\ndef BlockObjects(block_name):\n    \"\"\"Returns identifiers of the objects that make up a block definition\n    Parameters:\n      block_name (str): name of an existing block definition\n    Returns:\n      list(guid, ...): list of identifiers on success\n    Example:\n      import rhinoscriptsyntax as rs\n      strBlock = rs.GetString(\"Block name to list identifiers\")\n      if rs.IsBlock(strBlock):\n          objects = rs.BlockObjects(strBlock)\n          if objects:\n              for item in objects: print(item)\n    See Also:\n      BlockNames\n      BlockObjectCount\n      IsBlock\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    rhobjs = idef.GetObjects()\n    return [obj.Id for obj in rhobjs]\n\n\ndef BlockPath(block_name):\n    \"\"\"Returns path to the source of a linked or embedded block definition.\n    A linked or embedded block definition is a block definition that was\n    inserted from an external file.\n    Parameters:\n      block_name (str): name of an existing block definition\n    Returns:\n      str: path to the linked block on success\n    Example:\n      import rhinoscriptsyntax as rs\n      strBlock = rs.GetString(\"Block name to list path\")\n      if rs.IsBlockEmbedded(strBlock):\n          print(rs.BlockPath(strBlock))\n    See Also:\n      IsBlock\n      IsBlockEmbedded\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    return idef.SourceArchive\n\n\ndef BlockStatus(block_name):\n    \"\"\"Returns the status of a linked block\n    Parameters:\n        block_name (str): Name of an existing block\n    Returns:\n      number: the status of a linked block\n        Value Description\n        -3    Not a linked block definition.\n        -2    The linked block definition's file could not be opened or could not be read.\n        -1    The linked block definition's file could not be found.\n         0    The linked block definition is up-to-date.\n         1    The linked block definition's file is newer than definition.\n         2    The linked block definition's file is older than definition.\n         3    The linked block definition's file is different than definition.\n    Example:\n      import rhinoscriptsyntax as rs\n      block = rs.GetString(\"Block name to list description\")\n      if rs.IsBlock(block):\n          status = rs.BlockStatus(block)\n          print(\"block status for {} is {}\".format(block, status))\n    See Also:\n      IsBlock\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: return -3\n    return int(idef.ArchiveFileStatus)\n\n\ndef DeleteBlock(block_name):\n    \"\"\"Deletes a block definition and all of it's inserted instances.\n    Parameters:\n      block_name (str): name of an existing block definition\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      strBlock = rs.GetString(\"Block name to delete\")\n      if rs.IsBlock(strBlock):\n          rs.DeleteBlock(strBlock)\n    See Also:\n      BlockNames\n      ExplodeBlockInstance\n      IsBlock\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    rc = scriptcontext.doc.InstanceDefinitions.Delete(idef.Index, True, False)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ExplodeBlockInstance(object_id, explode_nested_instances=False):\n    \"\"\"Explodes a block instance into it's geometric components. The\n    exploded objects are added to the document\n    Parameters:\n      object_id (guid): The identifier of an existing block insertion object\n      explode_nested_instances (bool, optional): By default nested blocks are not exploded.\n    Returns:\n      list(guid, ...): identifiers for the newly exploded objects on success\n    Example:\n      import rhinoscriptsyntax as rs\n      strObject = rs.GetObject(\"Select block instance to explode\")\n      if rs.IsBlockInstance(strObject):\n          rs.ExplodeBlockInstance(strObject)\n    See Also:\n      DeleteBlock\n      IsBlockInstance\n    \"\"\"\n    instance = __InstanceObjectFromId(object_id, True)\n    guids = scriptcontext.doc.Objects.AddExplodedInstancePieces(instance, explodeNestedInstances=explode_nested_instances, deleteInstance=True)\n    if guids:\n      scriptcontext.doc.Views.Redraw()\n    return guids\n\n\ndef InsertBlock( block_name, insertion_point, scale=(1,1,1), angle_degrees=0, rotation_normal=(0,0,1) ):\n    \"\"\"Inserts a block whose definition already exists in the document\n    Parameters:\n      block_name (str): name of an existing block definition\n      insertion_point (point): insertion point for the block\n      scale ({number, number, number]): x,y,z scale factors\n      angle_degrees (number, optional): rotation angle in degrees\n      rotation_normal (vector, optional): the axis of rotation.\n    Returns:\n      guid: id for the block that was added to the doc\n    Example:\n    See Also:\n    \"\"\"\n    insertion_point = rhutil.coerce3dpoint(insertion_point, True)\n    rotation_normal = rhutil.coerce3dvector(rotation_normal, True)\n    angle_radians = math.radians(angle_degrees)\n    trans = Rhino.Geometry.Transform\n    move = trans.Translation(insertion_point[0],insertion_point[1],insertion_point[2])\n    scale = trans.Scale(Rhino.Geometry.Plane.WorldXY, scale[0], scale[1], scale[2])\n    rotate = trans.Rotation(angle_radians, rotation_normal, Rhino.Geometry.Point3d.Origin)\n    xform = move * scale * rotate\n    return InsertBlock2( block_name, xform )\n\n\ndef InsertBlock2(block_name, xform):\n    \"\"\"Inserts a block whose definition already exists in the document\n    Parameters:\n      block_name (str): name of an existing block definition\n      xform (transform): 4x4 transformation matrix to apply\n    Returns:\n      guid: id for the block that was added to the doc on success\n    Example:\n    See Also:\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    xform = rhutil.coercexform(xform, True)\n    id = scriptcontext.doc.Objects.AddInstanceObject(idef.Index, xform )\n    if id!=System.Guid.Empty:\n        scriptcontext.doc.Views.Redraw()\n        return id\n\n\ndef IsBlock(block_name):\n    \"\"\"Verifies the existence of a block definition in the document.\n    Parameters:\n      block_name (str): name of an existing block definition\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      strBlock = rs.GetString(\"Block name\")\n      if rs.IsBlock(strBlock):\n          print(\"The block definition exists.\")\n      else:\n          print(\"The block definition does not exist.\")\n    See Also:\n      IsBlockEmbedded\n      IsBlockInstance\n      IsBlockInUse\n      IsBlockReference\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    return (idef is not None)\n\n\ndef IsBlockEmbedded(block_name):\n    \"\"\"Verifies a block definition is embedded, or linked, from an external file.\n    Parameters:\n      block_name (str): name of an existing block definition\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      strBlock = rs.GetString(\"Block name\")\n      if rs.IsBlock(strBlock):\n          if rs.IsBlockEmbedded(strBlock):\n              print(\"The block definition is embedded.\")\n          else:\n              print(\"The block definition is not embedded.\")\n      else:\n          print(\"The block definition does not exist.\")\n    See Also:\n      IsBlock\n      IsBlockInstance\n      IsBlockInUse\n      IsBlockReference\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    ut = Rhino.DocObjects.InstanceDefinitionUpdateType\n    return (idef.UpdateType==ut.Embedded or idef.UpdateType==ut.Static or idef.UpdateType==ut.LinkedAndEmbedded)\n\n\ndef IsBlockInstance(object_id):\n    \"\"\"Verifies an object is a block instance\n    Parameters:\n      object_id (guid): The identifier of an existing block insertion object\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select block instance\")\n      if rs.IsBlockInstance(obj):\n          print(\"The object is a block instance.\")\n      else:\n          print(\"The object is not a block instance.\")\n    See Also:\n      IsBlock\n      IsBlockEmbedded\n      IsBlockInUse\n      IsBlockReference\n    \"\"\"\n    return  __InstanceObjectFromId(object_id, False) is not None\n\n\ndef IsBlockInUse(block_name, where_to_look=0):\n    \"\"\"Verifies that a block definition is being used by an inserted instance\n    Parameters:\n      block_name (str): name of an existing block definition\n      where_to_look (number, optional): One of the following values\n           0 = Check for top level references in active document\n           1 = Check for top level and nested references in active document\n           2 = Check for references in other instance definitions\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      strBlock = rs.GetString(\"Block name\")\n      if rs.IsBlock(strBlock):\n          if rs.IsBlockInUse(strBlock):\n              print(\"The block definition is in use.\")\n          else:\n              print(\"The block definition is not in use.\")\n      else:\n          print(\"The block definition does not exist.\")\n    See Also:\n      IsBlock\n      IsBlockInstance\n      IsBlockEmbedded\n      IsBlockReference\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    return idef.InUse(where_to_look)\n\n\ndef IsBlockReference(block_name):\n    \"\"\"Verifies that a block definition is from a reference file.\n    Parameters:\n      block_name (str): name of an existing block definition\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      strBlock = rs.GetString(\"Block name\")\n      if rs.IsBlock(strBlock):\n          if rs.IsBlockReference(strBlock):\n              print(\"The block definition is a reference definition.\")\n          else:\n              print(\"The block definition is not a reference definition.\")\n      else:\n          print(\"The block definition does not exist.\")\n    See Also:\n      IsBlock\n      IsBlockEmbedded\n      IsBlockInUse\n      IsBlockInstance\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    return idef.IsReference\n\n\ndef RenameBlock( block_name, new_name ):\n    \"\"\"Renames an existing block definition\n    Parameters:\n      block_name (str): name of an existing block definition\n      new_name (str): name to change to\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      strOldBlock = rs.GetString(\"Old block name\")\n      if strOldBlock:\n          strNewBlock = rs.GetString(\"New block name\")\n          if strNewBlock:\n              rs.RenameBlock (strOldBlock, strNewBlock)\n    See Also:\n      BlockNames\n      IsBlock\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    description = idef.Description\n    rc = scriptcontext.doc.InstanceDefinitions.Modify(idef, new_name, description, False)\n    return rc\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "point", "functions", "block", "RhinoCommon"], "original_file": "jingcheng-chen_rhinomcp_1e169170ac.json", "repo": "jingcheng-chen/rhinomcp"}
{"instruction": "Enables or disables an object's grips. For curves and surfaces, these are", "code": "import Rhino\n\nimport scriptcontext\n\nimport rhinocompat as compat\nfrom rhinoscript import utility as rhutil\n\n\ndef __neighborgrip(i, object_id, index, direction, enable):\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    grips = rhobj.GetGrips()\n    if not grips or len(grips)<=index: return scriptcontext.errorhandler()\n    grip = grips[index]\n    next_grip=None\n    if direction==0:\n        next_grip = grip.NeighborGrip(i,0,0,False)\n    else:\n        next_grip = grip.NeighborGrip(0,i,0,False)\n    if next_grip and enable:\n        next_grip.Select(True)\n        scriptcontext.doc.Views.Redraw()\n    return next_grip\n\n\ndef EnableObjectGrips(object_id, enable=True):\n    \"\"\"Enables or disables an object's grips. For curves and surfaces, these are\n    also called control points.\n    Parameters:\n      object_id (guid): identifier of the object\n      enable (bool, optional): if True, the specified object's grips will be turned on.\n        Otherwise, they will be turned off\n    Returns:\n      bool: True on success, False on failure\n    Example:\n      import rhinoscriptsyntax as  rs\n      objects = rs.GetObjects(\"Select  objects\")\n      if objects: [rs.EnableObjectGrips(obj)  for obj in objs]\n    See Also:\n      ObjectGripCount\n      ObjectGripsOn\n      ObjectGripsSelected\n      SelectObjectGrips\n      UnselectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if enable!=rhobj.GripsOn:\n        rhobj.GripsOn = enable\n        scriptcontext.doc.Views.Redraw()\n\n\ndef GetObjectGrip(message=None, preselect=False, select=False):\n    \"\"\"Prompts the user to pick a single object grip\n    Parameters:\n      message (str, optional): prompt for picking\n      preselect (bool, optional): allow for selection of pre-selected object grip.\n      select (bool, optional): select the picked object grip.\n    Returns:\n      tuple(guid, number, point): defining a grip record.\n         [0] = identifier of the object that owns the grip\n         [1] = index value of the grip\n         [2] = location of the grip\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if curve:\n          rs.EnableObjectGrips( curve )\n          grip = rs.GetObjectGrip(\"Select a curve grip\")\n          if grip: print(grip[2])\n    See Also:\n      GetObjectGrips\n    \"\"\"\n    if not preselect:\n        scriptcontext.doc.Objects.UnselectAll()\n        scriptcontext.doc.Views.Redraw()\n    rc, grip = Rhino.Input.RhinoGet.GetGrip(message)\n    if rc!=Rhino.Commands.Result.Success: return scriptcontext.errorhandler()\n    if select:\n        grip.Select(True, True)\n        scriptcontext.doc.Views.Redraw()\n    return grip.OwnerId, grip.Index, grip.CurrentLocation\n\n\ndef GetObjectGrips(message=None, preselect=False, select=False):\n    \"\"\"Prompts user to pick one or more object grips from one or more objects.\n    Parameters:\n      message (str, optional): prompt for picking\n      preselect (bool, optional): allow for selection of pre-selected object grips\n      select (bool, optional) select the picked object grips\n    Returns:\n      list((guid, number, point), ...): containing one or more grip records. Each grip record is a tuple\n        [n][0] = identifier of the object that owns the grip\n        [n][1] = index value of the grip\n        [n][2] = location of the grip\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curves = rs.GetObjects(\"Select curves\", rs.filter.curves)\n      if curves:\n          for curve in curves: rs.EnableObjectGrips(curve)\n          grips = rs.GetObjectGrips(\"Select curve grips\")\n          if grips: for grip in grips: print(grip[0])\n    See Also:\n      GetObjectGrip\n    \"\"\"\n    if not preselect:\n        scriptcontext.doc.Objects.UnselectAll()\n        scriptcontext.doc.Views.Redraw()\n    getrc, grips = Rhino.Input.RhinoGet.GetGrips(message)\n    if getrc!=Rhino.Commands.Result.Success or not grips:\n        return scriptcontext.errorhandler()\n    rc = []\n    for grip in grips:\n        id = grip.OwnerId\n        index = grip.Index\n        location = grip.CurrentLocation\n        rc.append((id, index, location))\n        if select: grip.Select(True, True)\n    if select: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef NextObjectGrip(object_id, index, direction=0, enable=True):\n    \"\"\"Returns the next grip index from a specified grip index of an object\n    Parameters:\n      object_id (guid): identifier of the object\n      index (number): zero based grip index from which to get the next grip index\n      direction ([number, number], optional): direction to get the next grip index (0=U, 1=V)\n      enable (bool, optional): if True, the next grip index found will be selected\n    Returns:\n      number: index of the next grip on success\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      object_id = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if object_id:\n          rs.EnableObjectGrips( object_id )\n          count = rs.ObjectGripCount( object_id )\n          for i in range(0,count,2):\n              rs.NextObjectGrip(object_id, i, 0, True)\n    See Also:\n      EnableObjectGrips\n      PrevObjectGrip\n    \"\"\"\n    return __neighborgrip(1, object_id, index, direction, enable)\n\n\ndef ObjectGripCount(object_id):\n    \"\"\"Returns number of grips owned by an object\n    Parameters:\n      object_id (guid): identifier of the object\n    Returns:\n      number: number of grips if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select object\")\n      if rs.ObjectGripsOn(obj):\n          print(\"Grip count ={}\".format(rs.ObjectGripCount(obj)))\n    See Also:\n      EnableObjectGrips\n      ObjectGripsOn\n      ObjectGripsSelected\n      SelectObjectGrips\n      UnselectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    grips = rhobj.GetGrips()\n    if not grips: return scriptcontext.errorhandler()\n    return grips.Length\n\n\ndef ObjectGripLocation(object_id, index, point=None):\n    \"\"\"Returns or modifies the location of an object's grip\n    Parameters:\n      object_id (guid) identifier of the object\n      index (number): index of the grip to either query or modify\n      point (point, optional): 3D point defining new location of the grip\n    Returns:\n      point: if point is not specified, the current location of the grip referenced by index\n      point: if point is specified, the previous location of the grip referenced by index\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if obj:\n          rs.EnableObjectGrips(obj)\n          point = rs.ObjectGripLocation(obj, 0)\n          point[0] = point[0] + 1.0\n          point[1] = point[1] + 1.0\n          point[2] = point[2] + 1.0\n          rs.ObjectGripLocation(obj, 0, point)\n          rs.EnableObjectGrips(obj, False)\n    See Also:\n      EnableObjectGrips\n      ObjectGripLocations\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return scriptcontext.errorhandler()\n    grips = rhobj.GetGrips()\n    if not grips or index<0 or index>=grips.Length:\n        return scriptcontext.errorhandler()\n    grip = grips[index]\n    rc = grip.CurrentLocation\n    if point:\n        grip.CurrentLocation = rhutil.coerce3dpoint(point, True)\n        scriptcontext.doc.Objects.GripUpdate(rhobj, True)\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ObjectGripLocations(object_id, points=None):\n    \"\"\"Returns or modifies the location of all grips owned by an object. The\n    locations of the grips are returned in a list of Point3d with each position\n    in the list corresponding to that grip's index. To modify the locations of\n    the grips, you must provide a list of points that contain the same number\n    of points at grips\n    Parameters:\n      object_id (guid): identifier of the object\n      points ([point, ...], optional) list of 3D points identifying the new grip locations\n    Returns:\n      list(point, ...): if points is not specified, the current location of all grips\n      list(point, ...): if points is specified, the previous location of all grips\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if obj:\n          rs.EnableObjectGrips( obj )\n          points = rs.ObjectGripLocations(obj)\n          for point in points:  print(point)\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      ObjectGripLocation\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return scriptcontext.errorhandler()\n    grips = rhobj.GetGrips()\n    if grips is None: return scriptcontext.errorhandler()\n    rc = [grip.CurrentLocation for grip in grips]\n    if points and len(points)==len(grips):\n        points = rhutil.coerce3dpointlist(points, True)\n        for i, grip in enumerate(grips):\n            point = points[i]\n            grip.CurrentLocation = point\n        scriptcontext.doc.Objects.GripUpdate(rhobj, True)\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ObjectGripsOn(object_id):\n    \"\"\"Verifies that an object's grips are turned on\n    Parameters:\n      object_id (guid): identifier of the object\n    Returns:\n      bool: True or False indicating Grips state\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select object\")\n      if rs.ObjectGripsOn(obj):\n          print(\"Grip count = {}\".format(rs.ObjectGripCount(obj)))\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      ObjectGripsSelected\n      SelectObjectGrips\n      UnselectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    return rhobj.GripsOn\n\n\ndef ObjectGripsSelected(object_id):\n    \"\"\"Verifies that an object's grips are turned on and at least one grip\n    is selected\n    Parameters:\n      object_id (guid): identifier of the object\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select object\")\n      if rs.ObjectGripsSelected(obj):\n          rs.UnselectObjectGrips( obj )\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      ObjectGripsOn\n      SelectObjectGrips\n      UnselectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return False\n    grips = rhobj.GetGrips()\n    if grips is None: return False\n    for grip in grips:\n        if grip.IsSelected(False): return True\n    return False\n\n\ndef PrevObjectGrip(object_id, index, direction=0, enable=True):\n    \"\"\"Returns the previous grip index from a specified grip index of an object\n    Parameters:\n      object_id (guid): identifier of the object\n      index (number): zero based grip index from which to get the previous grip index\n      direction ([number, number], optional): direction to get the next grip index (0=U, 1=V)\n      enable (bool, optional): if True, the next grip index found will be selected\n    Returns:\n      number: index of the next grip on success\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      object_id = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if object_id:\n          rs.EnableObjectGrips(object_id)\n          count = rs.ObjectGripCount(object_id)\n          for i in range(count-1, 0, -2):\n              rs.PrevObjectGrip(object_id, i, 0, True)\n    See Also:\n      EnableObjectGrips\n      NextObjectGrip\n    \"\"\"\n    return __neighborgrip(-1, object_id, index, direction, enable)\n\n\ndef SelectedObjectGrips(object_id):\n    \"\"\"Returns a list of grip indices indentifying an object's selected grips\n    Parameters:\n      object_id (guid): identifier of the object\n    Returns:\n      list(number): list of indices on success\n      None: on failure or if no grips are selected\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if obj:\n          rs.EnableObjectGrips( obj )\n          count = rs.ObjectGripCount( obj )\n          for i in range(0,count,2):\n              rs.SelectObjectGrip( obj, i )\n          grips = rs.SelectedObjectGrips(obj)\n          if grips: print(len(grips{}).format(\"grips selected\"))\n    See Also:\n      EnableObjectGrips\n      SelectObjectGrip\n      SelectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return None\n    grips = rhobj.GetGrips()\n    rc = []\n    if grips:\n        for i in compat.RANGE(grips.Length):\n            if grips[i].IsSelected(False): rc.append(i)\n    return rc\n\n\ndef SelectObjectGrip(object_id, index):\n    \"\"\"Selects a single grip owned by an object. If the object's grips are\n    not turned on, the grips will not be selected\n    Parameters:\n      object_id (guid) identifier of the object\n      index (number): index of the grip to select\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if obj:\n          rs.EnableObjectGrips( obj )\n          count = rs.ObjectGripCount( obj )\n          for i in range(0,count,2): rs.SelectObjectGrip(obj,i)\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      SelectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return False\n    grips = rhobj.GetGrips()\n    if grips is None: return False\n    if index<0 or index>=grips.Length: return False\n    grip = grips[index]\n    if grip.Select(True,True)>0:\n        scriptcontext.doc.Views.Redraw()\n        return True\n    return False\n\n\ndef SelectObjectGrips(object_id):\n    \"\"\"Selects an object's grips. If the object's grips are not turned on,\n    they will not be selected\n    Parameters:\n      object_id (guid): identifier of the object\n    Returns:\n      number: Number of grips selected on success\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select object\")\n      if rs.ObjectGripsSelected(obj)==False:\n          rs.SelectObjectGrips( obj )\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      SelectObjectGrip\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return scriptcontext.errorhandler()\n    grips = rhobj.GetGrips()\n    if grips is None: return scriptcontext.errorhandler()\n    count = 0\n    for grip in grips:\n        if grip.Select(True,True)>0: count+=1\n    if count>0:\n        scriptcontext.doc.Views.Redraw()\n        return count\n    return scriptcontext.errorhandler()\n\n\ndef UnselectObjectGrip(object_id, index):\n    \"\"\"Unselects a single grip owned by an object. If the object's grips are\n    not turned on, the grips will not be unselected\n    Parameters:\n      object_id (guid): identifier of the object\n      index (number): index of the grip to unselect\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if obj:\n          rs.EnableObjectGrips( obj )\n          count = rs.ObjectGripCount(obj)\n          for i in range(0,count,2):\n              rs.UnselectObjectGrip( obj, i )\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      UnselectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return False\n    grips = rhobj.GetGrips()\n    if grips is None: return False\n    if index<0 or index>=grips.Length: return False\n    grip = grips[index]\n    if grip.Select(False)==0:\n        scriptcontext.doc.Views.Redraw()\n        return True\n    return False\n\n\ndef UnselectObjectGrips(object_id):\n    \"\"\"Unselects an object's grips. Note, the grips will not be turned off.\n    Parameters:\n      object_id (guid): identifier of the object\n    Returns:\n      number: Number of grips unselected on success\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select object\")\n      if rs.ObjectGripsSelected(obj): rs.UnselectObjectGrips(obj)\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      UnselectObjectGrip\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return scriptcontext.errorhandler()\n    grips = rhobj.GetGrips()\n    if grips is None: return scriptcontext.errorhandler()\n    count = 0\n    for grip in grips:\n        if grip.Select(False)==0: count += 1\n    if count>0:\n        scriptcontext.doc.Views.Redraw()\n        return count\n    return scriptcontext.errorhandler()\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "curve", "functions"], "original_file": "jingcheng-chen_rhinomcp_20737059db.json", "repo": "jingcheng-chen/rhinomcp"}
{"instruction": "Adds a new directional light object to the document", "code": "import math\n\nimport Rhino.Geometry\n\nimport scriptcontext\n\nimport rhinocompat as compat\nfrom rhinoscript import utility as rhutil\n\n\ndef __coercelight(id, raise_if_missing=False):\n    light = rhutil.coercegeometry(id)\n    if isinstance(light, Rhino.Geometry.Light): return light\n    if raise_if_missing: raise ValueError(\"unable to retrieve light from %s\"%id)\n\n\ndef AddDirectionalLight(start_point, end_point):\n    \"\"\"Adds a new directional light object to the document\n    Parameters:\n      start_point(point): starting point of the light\n      end_point (point): ending point and direction of the light\n    Returns:\n      (guid): identifier of the new object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      end = rs.GetPoint(\"End of light vector direction\")\n      if end:\n          start = rs.GetPoint(\"Start of light vector direction\", end)\n          if start: rs.AddDirectionalLight( start, end )\n    See Also:\n      IsDirectionalLight\n    \"\"\"\n    start = rhutil.coerce3dpoint(start_point, True)\n    end = rhutil.coerce3dpoint(end_point, True)\n    light = Rhino.Geometry.Light()\n    light.LightStyle = Rhino.Geometry.LightStyle.WorldDirectional\n    light.Location = start\n    light.Direction = end-start\n    index = scriptcontext.doc.Lights.Add(light)\n    if index<0: raise Exception(\"unable to add light to LightTable\")\n    rc = scriptcontext.doc.Lights[index].Id\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddLinearLight(start_point, end_point, width=None):\n    \"\"\"Adds a new linear light object to the document\n    Parameters:\n      start_point (point): starting point of the light\n      end_point (point): ending point and direction of the light\n      width (number): width of the light\n    Returns:\n      guid: identifier of the new object if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      start = rs.GetPoint(\"Light origin\")\n      if start:\n          end = rs.GetPoint(\"Light length and direction\", start)\n          if end: rs.AddLinearLight(start, end)\n    See Also:\n      IsLinearLight\n    \"\"\"\n    start = rhutil.coerce3dpoint(start_point, True)\n    end = rhutil.coerce3dpoint(end_point, True)\n    if width is None:\n        radius=0.5\n        units = scriptcontext.doc.ModelUnitSystem\n        if units!=compat.ENUM_NONE(Rhino.UnitSystem):\n            scale = Rhino.RhinoMath.UnitScale(Rhino.UnitSystem.Inches, units)\n            radius *= scale\n        width = radius\n    light = Rhino.Geometry.Light()\n    light.LightStyle = Rhino.Geometry.LightStyle.WorldLinear\n    light.Location = start\n    v = end-start\n    light.Direction = v\n    light.Length = light.Direction\n    light.Width = -light.Width\n    plane = Rhino.Geometry.Plane(light.Location, light.Direction)\n    xaxis = plane.XAxis\n    xaxis.Unitize()\n    plane.XAxis = xaxis\n    light.Width = xaxis * min(width, v.Length/20)\n    #light.Location = start - light.Direction\n    index = scriptcontext.doc.Lights.Add(light)\n    if index<0: raise Exception(\"unable to add light to LightTable\")\n    rc = scriptcontext.doc.Lights[index].Id\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddPointLight(point):\n    \"\"\"Adds a new point light object to the document\n    Parameters:\n      point (point): the 3d location of the point\n    Returns:\n      guid: identifier of the new object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      point = rs.GetPoint(\"Point light location\")\n      if point: rs.AddPointLight(point)\n    See Also:\n      IsPointLight\n    \"\"\"\n    point = rhutil.coerce3dpoint(point, True)\n    light = Rhino.Geometry.Light()\n    light.LightStyle = Rhino.Geometry.LightStyle.WorldPoint\n    light.Location = point\n    index = scriptcontext.doc.Lights.Add(light)\n    if index<0: raise Exception(\"unable to add light to LightTable\")\n    rc = scriptcontext.doc.Lights[index].Id\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddRectangularLight(origin, width_point, height_point):\n    \"\"\"Adds a new rectangular light object to the document\n    Parameters:\n      origin (point): 3d origin point of the light\n      width_point (point): 3d width and direction point of the light\n      height_point (point): 3d height and direction point of the light\n    Returns:\n      guid: identifier of the new object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      rect = rs.GetRectangle(2)\n      if rect: rs.AddRectangularLight( rect[0], rect[1], rect[3] )\n    See Also:\n      IsRectangularLight\n    \"\"\"\n    origin = rhutil.coerce3dpoint(origin, True)\n    ptx = rhutil.coerce3dpoint(width_point, True)\n    pty = rhutil.coerce3dpoint(height_point, True)\n    length = pty-origin\n    width = ptx-origin\n    normal = Rhino.Geometry.Vector3d.CrossProduct(width, length)\n    normal.Unitize()\n    light = Rhino.Geometry.Light()\n    light.LightStyle = Rhino.Geometry.LightStyle.WorldRectangular\n    light.Location = origin\n    light.Width = width\n    light.Length = length\n    light.Direction = normal\n    index = scriptcontext.doc.Lights.Add(light)\n    if index<0: raise Exception(\"unable to add light to LightTable\")\n    rc = scriptcontext.doc.Lights[index].Id\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSpotLight(origin, radius, apex_point):\n    \"\"\"Adds a new spot light object to the document\n    Parameters:\n      origin (point): 3d origin point of the light\n      radius (number):  radius of the cone\n      apex_point (point): 3d apex point of the light\n    Returns:\n      guid: identifier of the new object\n    Example:\n      import rhinoscriptsyntax as rs\n      radius = 5.0\n      origin = rs.GetPoint(\"Base of cone\")\n      if origin:\n          apex = rs.GetPoint(\"End of cone\", origin)\n          if apex: rs.AddSpotLight(origin, radius, apex)\n    See Also:\n      IsSpotLight\n      SpotLightHardness\n      SpotLightShadowIntensity\n    \"\"\"\n    origin = rhutil.coerce3dpoint(origin, True)\n    apex_point = rhutil.coerce3dpoint(apex_point, True)\n    if radius<0: radius=1.0\n    light = Rhino.Geometry.Light()\n    light.LightStyle = Rhino.Geometry.LightStyle.WorldSpot\n    light.Location = apex_point\n    light.Direction = origin-apex_point\n    light.SpotAngleRadians = math.atan(radius / (light.Direction.Length))\n    light.HotSpot = 0.50\n    index = scriptcontext.doc.Lights.Add(light)\n    if index<0: raise Exception(\"unable to add light to LightTable\")\n    rc = scriptcontext.doc.Lights[index].Id\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef EnableLight(object_id, enable=None):\n    \"\"\"Enables or disables a light object\n    Parameters:\n      object_id (guid): the light object's identifier\n      enable (bool, optional): the light's enabled status\n    Returns:\n      bool: if enable is not specified, the current enabled status\n      bool: if enable is specified, the previous enabled status\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select light\", rs.filter.light)\n      if id: rs.EnableLight( id, False )\n    See Also:\n      IsLight\n      IsLightEnabled\n      LightColor\n      LightCount\n      LightName\n      LightObjects\n    \"\"\"\n    light = __coercelight(object_id, True)\n    rc = light.IsEnabled\n    if enable is not None and enable!=rc:\n        light.IsEnabled = enable\n        id = rhutil.coerceguid(object_id)\n        if not scriptcontext.doc.Lights.Modify(id, light):\n            return scriptcontext.errorhandler()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef IsDirectionalLight(object_id):\n    \"\"\"Verifies a light object is a directional light\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsDirectionalLight(id):\n          print(\"The object is a directional light.\")\n      else:\n          print(\"The object is not a directional light.\")\n    See Also:\n      AddDirectionalLight\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsDirectionalLight\n\n\ndef IsLight(object_id):\n    \"\"\"Verifies an object is a light object\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\")\n      if rs.IsLight(id):\n          print(\"The object is a light.\")\n      else:\n          print(\"The object is not a light.\")\n    See Also:\n      EnableLight\n      IsLightEnabled\n      LightColor\n      LightCount\n      LightName\n      LightObjects\n    \"\"\"\n    light = __coercelight(object_id, False)\n    return light is not None\n\n\ndef IsLightEnabled(object_id):\n    \"\"\"Verifies a light object is enabled\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsLightEnabled(id):\n          print(\"The light is enabled (on).\")\n      else:\n          print(\"The light is disabled (off).\")\n    See Also:\n      EnableLight\n      IsLight\n      LightColor\n      LightCount\n      LightName\n      LightObjects\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsEnabled\n\n\ndef IsLightReference(object_id):\n    \"\"\"Verifies a light object is referenced from another file\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsLightReference(id):\n          print(\"The light is a reference object.\")\n      else:\n          print(\"The light is not a reference object.\")\n    See Also:\n      IsObjectReference\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsReference\n\n\ndef IsLinearLight(object_id):\n    \"\"\"Verifies a light object is a linear light\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsLinearLight(id):\n          print(\"The object is a linear light.\")\n      else:\n          print(\"The object is not a linear light.\")\n    See Also:\n      AddLinearLight\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsLinearLight\n\n\ndef IsPointLight(object_id):\n    \"\"\"Verifies a light object is a point light\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsPointLight(id):\n          print(\"The object is a point light.\")\n      else:\n          print(\"The object is not a point light.\")\n    See Also:\n      AddPointLight\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsPointLight\n\n\ndef IsRectangularLight(object_id):\n    \"\"\"Verifies a light object is a rectangular light\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsRectangularLight(id):\n          print(\"The object is a rectangular light.\")\n      else:\n          print(\"The object is not a rectangular light.\")\n    See Also:\n      AddRectangularLight\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsRectangularLight\n\n\ndef IsSpotLight(object_id):\n    \"\"\"Verifies a light object is a spot light\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsSpotLight(id):\n          print(\"The object is a spot light.\")\n      else:\n          print(\"The object is not a spot light.\")\n    See Also:\n      AddSpotLight\n      SpotLightHardness\n      SpotLightShadowIntensity\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsSpotLight\n\n\ndef LightColor(object_id, color=None):\n    \"\"\"Returns or changes the color of a light\n    Parameters:\n      object_id (guid): the light object's identifier\n      color (color, optional): the light's new color\n    Returns:\n      color: if color is not specified, the current color\n      color: if color is specified, the previous color\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id: rs.LightColor( id, (0,255,255) )\n    See Also:\n      EnableLight\n      IsLight\n      IsLightEnabled\n      LightCount\n      LightName\n      LightObjects\n    \"\"\"\n    light = __coercelight(object_id, True)\n    rc = light.Diffuse\n    if color:\n        color = rhutil.coercecolor(color, True)\n        if color!=rc:\n            light.Diffuse = color\n            id = rhutil.coerceguid(object_id, True)\n            if not scriptcontext.doc.Lights.Modify(id, light):\n                return scriptcontext.errorhandler()\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef LightCount():\n    \"\"\"Returns the number of light objects in the document\n    Returns:\n      number: the number of light objects in the document\n    Example:\n      import rhinoscriptsyntax as rs\n      print(\"There are {} lights\".format(rs.LightCount()))\n    See Also:\n      EnableLight\n      IsLight\n      IsLightEnabled\n      LightColor\n      LightName\n      LightObjects\n    \"\"\"\n    return scriptcontext.doc.Lights.Count\n\n\ndef LightDirection(object_id, direction=None):\n    \"\"\"Returns or changes the direction of a light object\n    Parameters:\n      object_id (guid): the light object's identifier\n      direction (vector, optional): the light's new direction\n    Returns:\n      vector: if direction is not specified, the current direction\n      vector: if direction is specified, the previous direction\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id: print( rs.LightDirection(id) )\n    See Also:\n      IsLight\n      LightLocation\n    \"\"\"\n    light = __coercelight(object_id, True)\n    rc = light.Direction\n    if direction:\n        direction = rhutil.coerce3dvector(direction, True)\n        if direction!=rc:\n            light.Direction = direction\n            id = rhutil.coerceguid(object_id, True)\n            if not scriptcontext.doc.Lights.Modify(id, light):\n                return scriptcontext.errorhandler()\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef LightLocation(object_id, location=None):\n    \"\"\"Returns or changes the location of a light object\n    Parameters:\n      object_id (guid): the light object's identifier\n      location (point, optional): the light's new location\n    Returns:\n      point: if location is not specified, the current location\n      point: if location is specified, the previous location\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id: rs.AddPoint( rs.LightLocation(id) )\n    See Also:\n      IsLight\n      LightDirection\n    \"\"\"\n    light = __coercelight(object_id, True)\n    rc = light.Location\n    if location:\n        location = rhutil.coerce3dpoint(location, True)\n        if location!=rc:\n            light.Location = location\n            id = rhutil.coerceguid(object_id, True)\n            if not scriptcontext.doc.Lights.Modify(id, light):\n                return scriptcontext.errorhandler()\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef LightName(object_id, name=None):\n    \"\"\"Returns or changes the name of a light object\n    Parameters:\n      object_id (guid): the light object's identifier\n      name (str, optional): the light's new name\n    Returns:\n      str: if name is not specified, the current name\n      str: if name is specified, the previous name\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id:\n          name = rs.GetString(\"New light name\")\n          if name: rs.LightName(id, name)\n    See Also:\n      EnableLight\n      IsLight\n      IsLightEnabled\n      LightColor\n      LightCount\n      LightObjects\n    \"\"\"\n    light = __coercelight(object_id, True)\n    rc = light.Name\n    if name and name!=rc:\n        light.Name = name\n        id = rhutil.coerceguid(object_id, True)\n        if not scriptcontext.doc.Lights.Modify(id, light):\n            return scriptcontext.errorhandler()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef LightObjects():\n    \"\"\"Returns list of identifiers of light objects in the document\n    Returns:\n      list(guid, ...): the list of identifiers of light objects in the document\n    Example:\n      import rhinoscriptsyntax as rs\n      lights = rs.LightObjects()\n      if lights:\n          rs.AddLayer( \"Lights\" )\n          for light in lights: rs.ObjectLayer( light, \"Lights\" )\n    See Also:\n      EnableLight\n      IsLight\n      IsLightEnabled\n      LightColor\n      LightCount\n      LightName\n    \"\"\"\n    count = scriptcontext.doc.Lights.Count\n    rc = []\n    for i in range(count):\n        rhlight = scriptcontext.doc.Lights[i]\n        if not rhlight.IsDeleted: rc.append(rhlight.Id)\n    return rc\n\n\ndef RectangularLightPlane(object_id):\n    \"\"\"Returns the plane of a rectangular light object\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      plane: the plane if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a rectangular light\", rs.filter.light)\n      if id:\n          rc = rs.RectangularLightPlane(id)\n          if rc:\n              plane, extents = rc\n              rs.AddPlaneSurface( plane, extents[0], extents[1] )\n    See Also:\n      IsRectangularLight\n    \"\"\"\n    light = __coercelight(object_id, True)\n    if light.LightStyle!=Rhino.Geometry.LightStyle.WorldRectangular:\n        return scriptcontext.errorhandler()\n    location = light.Location\n    length = light.Length\n    width = light.Width\n    direction = light.Direction\n    plane = Rhino.Geometry.Plane(location, length, width)\n    return plane, (length.Length, width.Length)\n\n\ndef SpotLightHardness(object_id, hardness=None):\n    \"\"\"Returns or changes the hardness of a spot light. Spotlight hardness\n    controls the fully illuminated region.\n    Parameters:\n      object_id (guid): the light object's identifier\n      hardness (number, optional): the light's new hardness\n    Returns:\n      number: if hardness is not specified, the current hardness\n      number: if hardness is specified, the previous hardness\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id: rs.SpotLightHardness(id, 0.75)\n    See Also:\n      AddSpotLight\n      IsSpotLight\n      SpotLightRadius\n      SpotLightShadowIntensity\n    \"\"\"\n    light = __coercelight(object_id, True)\n    if light.LightStyle!=Rhino.Geometry.LightStyle.WorldSpot:\n        return scriptcontext.errorhandler()\n    rc = light.HotSpot\n    if hardness and hardness!=rc:\n        light.HotSpot = hardness\n        id = rhutil.coerceguid(object_id, True)\n        if not scriptcontext.doc.Lights.Modify(id, light):\n            return scriptcontext.errorhandler()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef SpotLightRadius(object_id, radius=None):\n    \"\"\"Returns or changes the radius of a spot light.\n    Parameters:\n      object_id (guid): the light object's identifier\n      radius (number, optional): the light's new radius\n    Returns:\n      number: if radius is not specified, the current radius\n      number: if radius is specified, the previous radius\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id: rs.SpotLightRadius(id, 5.0)\n    See Also:\n      AddSpotLight\n      IsSpotLight\n      SpotLightHardness\n      SpotLightShadowIntensity\n    \"\"\"\n    light = __coercelight(object_id, True)\n    if light.LightStyle!=Rhino.Geometry.LightStyle.WorldSpot:\n        return scriptcontext.errorhandler()\n    radians = light.SpotAngleRadians\n    rc = light.Direction.Length * math.tan(radians)\n    if radius and radius!=rc:\n        radians = math.atan(radius/light.Direction.Length)\n        light.SpotAngleRadians = radians\n        id = rhutil.coerceguid(object_id, True)\n        if not scriptcontext.doc.Lights.Modify(id, light):\n            return scriptcontext.errorhandler()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef SpotLightShadowIntensity(object_id, intensity=None):\n    \"\"\"Returns or changes the shadow intensity of a spot light.\n    Parameters:\n      object_id (guid): the light object's identifier\n      intensity (number, optional): the light's new intensity\n    Returns:\n      number: if intensity is not specified, the current intensity\n      number: if intensity is specified, the previous intensity\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id: rs.SpotLightShadowIntensity(id, 0.75)\n    See Also:\n      AddSpotLight\n      IsSpotLight\n      SpotLightHardness\n      SpotLightRadius\n    \"\"\"\n    light = __coercelight(object_id, True)\n    if light.LightStyle!=Rhino.Geometry.LightStyle.WorldSpot:\n        return scriptcontext.errorhandler()\n    rc = light.SpotLightShadowIntensity\n    if intensity and intensity!=rc:\n        light.SpotLightShadowIntensity = intensity\n        id = rhutil.coerceguid(object_id, True)\n        if not scriptcontext.doc.Lights.Modify(id, light):\n            return scriptcontext.errorhandler()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "layer", "line", "functions", "RhinoCommon"], "original_file": "jingcheng-chen_rhinomcp_7dd5385255.json", "repo": "jingcheng-chen/rhinomcp"}
{"instruction": "Adds an arc curve to the document", "code": "import math\n\nimport System\n\nimport Rhino\n\nimport scriptcontext\n\nimport rhinocompat as compat\nfrom rhinoscript import utility as rhutil\n\n\ndef AddArc(plane, radius, angle_degrees):\n    \"\"\"Adds an arc curve to the document\n    Parameters:\n      plane (str): plane on which the arc will lie. The origin of the plane will be\n        the center point of the arc. x-axis of the plane defines the 0 angle\n        direction.\n      radius(number): radius of the arc\n      angle_degrees (number): interval of arc in degrees\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as  rs\n      plane = rs.WorldXYPlane()\n      plane = rs.RotatePlane(plane,  45.0, [0,0,1])\n      rs.AddArc( plane, 5.0, 45.0  )\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcCenterPoint\n      ArcMidPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    radians = math.radians(angle_degrees)\n    arc = Rhino.Geometry.Arc(plane, radius, radians)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add arc to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddArc3Pt(start, end, point_on_arc):\n    \"\"\"Adds a 3-point arc curve to the document\n    Parameters:\n      start, end (point|guid): endpoints of the arc\n      point_on_arc (point|guid): a point on the arc\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      start = rs.GetPoint(\"Start of arc\")\n      if start is not None:\n          end = rs.GetPoint(\"End of arc\")\n          if end is not None:\n              pton = rs.GetPoint(\"Point on arc\")\n              if pton is not None:\n                  rs.AddArc3Pt(start, end, pton)\n    See Also:\n      AddArc\n      ArcAngle\n      ArcCenterPoint\n      ArcMidPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    start = rhutil.coerce3dpoint(start, True)\n    end = rhutil.coerce3dpoint(end, True)\n    pton = rhutil.coerce3dpoint(point_on_arc, True)\n    arc = Rhino.Geometry.Arc(start, pton, end)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add arc to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddArcPtTanPt(start, direction, end):\n    \"\"\"Adds an arc curve, created from a start point, a start direction, and an\n    end point, to the document\n    Parameters:\n      start (point): the starting point of the arc\n      direction (vector): the arc direction at start\n      end (point): the ending point of the arc\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      pick = rs.GetCurveObject(\"Select curve to extend\")\n      point = rs.GetPoint(\"End of extension\")\n      domain = rs.CurveDomain(pick[0])\n      if abs(pick[4]-domain[0]) < abs(pick[4]-domain[1]):\n          origin = rs.CurveStartPoint(pick[0])\n          tangent = rs.VectorReverse(rs.CurveTangent(pick[0], domain[0]))\n      else:\n          origin = rs.CurveEndPoint(pick[0])\n          tangent = rs.CurveTangent(pick[0], domain[1])\n      rs.AddArcPtTanPt(origin, tangent, point)\n    See Also:\n      AddArc\n      AddArc3Pt\n      IsArc\n    \"\"\"\n    start = rhutil.coerce3dpoint(start, True)\n    direction = rhutil.coerce3dvector(direction, True)\n    end = rhutil.coerce3dpoint(end, True)\n    arc = Rhino.Geometry.Arc(start, direction, end)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add arc to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddBlendCurve(curves, parameters, reverses, continuities):\n    \"\"\"Makes a curve blend between two curves\n    Parameters:\n      curves ([guid|curve, guid|curve]): list of two curves\n      parameters ([number, number]): list of two curve parameters defining the blend end points\n      reverses ([bool, bool]): list of two boolean values specifying to use the natural or opposite direction of the curve\n      continuities ([number, number]): list of two numbers specifying continuity at end points\n                                            0 = position\n                                            1 = tangency\n                                            2 = curvature\n    Returns:\n      guid: identifier of new curve on success\n    Example:\n        import rhinoscriptsyntax as rs\n        curve0 = rs.AddLine((0,0,0), (0,9,0))\n        curve1 = rs.AddLine((1,10,0), (10,10,0))\n        curves = curve0, curve1\n        domain_crv0 = rs.CurveDomain(curve0)\n        domain_crv1 = rs.CurveDomain(curve1)\n        params = domain_crv0[1], domain_crv1[0]\n        revs = False, True\n        cont = 2,2\n        rs.AddBlendCurve( curves, params, revs, cont )\n    See Also:\n      AddFilletCurve\n    \"\"\"\n    crv0 = rhutil.coercecurve(curves[0], -1, True)\n    crv1 = rhutil.coercecurve(curves[1], -1, True)\n    c0 = System.Enum.ToObject(Rhino.Geometry.BlendContinuity, continuities[0])\n    c1 = System.Enum.ToObject(Rhino.Geometry.BlendContinuity, continuities[1])\n    curve = Rhino.Geometry.Curve.CreateBlendCurve(crv0, parameters[0], reverses[0], c0, crv1, parameters[1], reverses[1], c1)\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCircle(plane_or_center, radius):\n    \"\"\"Adds a circle curve to the document\n    Parameters:\n      plane_or_center (point|plane): plane on which the circle will lie. If a point is\n        passed, this will be the center of the circle on the active\n        construction plane\n      radius (number): the radius of the circle\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.WorldXYPlane()\n      rs.AddCircle( plane, 5.0 )\n    See Also:\n      AddCircle3Pt\n      CircleCenterPoint\n      CircleCircumference\n      CircleRadius\n      IsCircle\n    \"\"\"\n    rc = None\n    plane = rhutil.coerceplane(plane_or_center, False)\n    if plane:\n        circle = Rhino.Geometry.Circle(plane, radius)\n        rc = scriptcontext.doc.Objects.AddCircle(circle)\n    else:\n        center = rhutil.coerce3dpoint(plane_or_center, True)\n        view = scriptcontext.doc.Views.ActiveView\n        plane = view.ActiveViewport.ConstructionPlane()\n        plane.Origin = center\n        circle = Rhino.Geometry.Circle(plane, radius)\n        rc = scriptcontext.doc.Objects.AddCircle(circle)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add circle to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCircle3Pt(first, second, third):\n    \"\"\"Adds a 3-point circle curve to the document\n    Parameters:\n      first, second, third (point|guid): points on the circle\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      point1 = rs.GetPoint(\"First point on circle\")\n      if point1:\n          point2 = rs.GetPoint(\"Second point on circle\")\n          if point2:\n              point3 = rs.GetPoint(\"Third point on circle\")\n              if point3:\n                  rs.AddCircle3Pt(point1, point2, point3)\n    See Also:\n      AddCircle\n      CircleCenterPoint\n      CircleCircumference\n      CircleRadius\n      IsCircle\n    \"\"\"\n    start = rhutil.coerce3dpoint(first, True)\n    end = rhutil.coerce3dpoint(second, True)\n    third = rhutil.coerce3dpoint(third, True)\n    circle = Rhino.Geometry.Circle(start, end, third)\n    rc = scriptcontext.doc.Objects.AddCircle(circle)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add circle to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCurve(points, degree=3):\n    \"\"\"Adds a control points curve object to the document\n    Parameters:\n      points ([point|guid, ...]) a list of points\n      degree (number): degree of the curve\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      points = rs.GetPoints(True, message1=\"Pick curve point\")\n      if points: rs.AddCurve(points)\n    See Also:\n      AddInterpCurve\n      IsCurve\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    curve = Rhino.Geometry.Curve.CreateControlPointCurve(points, degree)\n    if not curve: raise Exception(\"unable to create control point curve from given points\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddEllipse(plane, radiusX, radiusY):\n    \"\"\"Adds an elliptical curve to the document\n    Parameters:\n      plane (plane) the plane on which the ellipse will lie. The origin of\n              the plane will be the center of the ellipse\n      radiusX, radiusY (number): radius in the X and Y axis directions\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.WorldXYPlane()\n      rs.AddEllipse( plane, 5.0, 10.0 )\n    See Also:\n      AddEllipse3Pt\n      IsEllipse\n      EllipseCenterPoint\n      EllipseQuadPoints\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    ellipse = Rhino.Geometry.Ellipse(plane, radiusX, radiusY)\n    rc = scriptcontext.doc.Objects.AddEllipse(ellipse)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddEllipse3Pt(center, second, third):\n    \"\"\"Adds a 3-point elliptical curve to the document\n    Parameters:\n      center (point|guid): center point of the ellipse\n      second (point|guid): end point of the x axis\n      third  (point|guid): end point of the y axis\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      center = (0,0,0)\n      second = (5,0,0)\n      third = (0,10,0)\n      rs.AddEllipse3Pt( center, second, third )\n    See Also:\n      AddEllipse\n      IsEllipse\n      EllipseCenterPoint\n      EllipseQuadPoints\n    \"\"\"\n    center = rhutil.coerce3dpoint(center, True)\n    second = rhutil.coerce3dpoint(second, True)\n    third = rhutil.coerce3dpoint(third, True)\n    ellipse = Rhino.Geometry.Ellipse(center, second, third)\n    rc = scriptcontext.doc.Objects.AddEllipse(ellipse)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddFilletCurve(curve0id, curve1id, radius=1.0, base_point0=None, base_point1=None):\n    \"\"\"Adds a fillet curve between two curve objects\n    Parameters:\n      curve0id (guid): identifier of the first curve object\n      curve1id (guid): identifier of the second curve object\n      radius (number, optional): fillet radius\n      base_point0 (point|guid, optional): base point of the first curve. If omitted,\n                          starting point of the curve is used\n      base_point1 (point|guid, optional): base point of the second curve. If omitted,\n                          starting point of the curve is used\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      curve0 = rs.AddLine([0,0,0], [5,1,0])\n      curve1 = rs.AddLine([0,0,0], [1,5,0])\n      rs.AddFilletCurve( curve0, curve1 )\n    See Also:\n      CurveFilletPoints\n    \"\"\"\n    if base_point0: base_point0 = rhutil.coerce3dpoint(base_point0, True)\n    else: base_point0 = Rhino.Geometry.Point3d.Unset\n    if base_point1: base_point1 = rhutil.coerce3dpoint(base_point1, True)\n    else: base_point1 = Rhino.Geometry.Point3d.Unset\n    curve0 = rhutil.coercecurve(curve0id, -1, True)\n    curve1 = rhutil.coercecurve(curve1id, -1, True)\n    crv0_t = 0.0\n    if base_point0==Rhino.Geometry.Point3d.Unset:\n        crv0_t = curve0.Domain.Min\n    else:\n        rc, t = curve0.ClosestPoint(base_point0, 0.0)\n        if not rc: raise Exception(\"ClosestPoint failed\")\n        crv0_t = t\n    crv1_t = 0.0\n    if base_point1==Rhino.Geometry.Point3d.Unset:\n        crv1_t = curve1.Domain.Min\n    else:\n        rc, t = curve1.ClosestPoint(base_point1, 0.0)\n        if not rc: raise Exception(\"ClosestPoint failed\")\n        crv1_t = t\n    arc = Rhino.Geometry.Curve.CreateFillet(curve0, curve1, radius, crv0_t, crv1_t)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddInterpCrvOnSrf(surface_id, points):\n    \"\"\"Adds an interpolated curve object that lies on a specified\n    surface.  Note, this function will not create periodic curves,\n    but it will create closed curves.\n    Parameters:\n      surface_id (guid): identifier of the surface to create the curve on\n      points ([point|guid, point|guid, ...])list of 3D points that lie on the specified surface.\n               The list must contain at least 2 points\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      surface_id = rs.GetObject(\"Select surface to draw curve on\", rs.filter.surface)\n      if surface_id:\n          point1 = rs.GetPointOnSurface( surface_id, \"First point on surface\")\n          if point1:\n              point2 = rs.GetPointOnSurface( surface_id, \"Second point on surface\")\n              if point2:\n                  rs.AddInterpCrvOnSrf( surface_id, [point1, point2])\n    See Also:\n      AddCurve\n      AddInterpCurve\n      AddInterpCrvOnSrfUV\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    points = rhutil.coerce3dpointlist(points, True)\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    curve = surface.InterpolatedCurveOnSurface(points, tolerance)\n    if not curve: raise Exception(\"unable to create InterpolatedCurveOnSurface\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddInterpCrvOnSrfUV(surface_id, points):\n    \"\"\"Adds an interpolated curve object based on surface parameters,\n    that lies on a specified surface. Note, this function will not\n    create periodic curves, but it will create closed curves.\n    Parameters:\n      surface_id (guid): identifier of the surface to create the curve on\n      points ([[number, number}, [number,number], ...]): a list of 2D surface parameters. The list must contain\n                                                         at least 2 sets of parameters\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      surface_id = rs.GetObject(\"Select surface to draw curve on\", rs.filter.surface)\n      if surface_id:\n          domainU = rs.SurfaceDomain( surface_id, 0)\n          u0 = domainU[0]/2\n          u1 = domainU[1]/2\n          domainV = rs.SurfaceDomain( surface_id, 1)\n          v0 = domainV[0]/2\n          v1 = domainV[1]/2\n          rs.AddInterpCrvOnSrfUV( surface_id, [[u0,v0],[u1,v1]])\n    See Also:\n      AddCurve\n      AddInterpCurve\n      AddInterpCrvOnSrf\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    points = rhutil.coerce2dpointlist(points)\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    curve = surface.InterpolatedCurveOnSurfaceUV(points, tolerance)\n    if not curve: raise Exception(\"unable to create InterpolatedCurveOnSurfaceUV\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddInterpCurve(points, degree=3, knotstyle=0, start_tangent=None, end_tangent=None):\n    \"\"\"Adds an interpolated curve object to the document. Options exist to make\n    a periodic curve or to specify the tangent at the endpoints. The resulting\n    curve is a non-rational NURBS curve of the specified degree.\n    Parameters:\n      points (point|guid, point|guid, ...]): a list containing 3D points to interpolate. For periodic curves,\n          if the final point is a duplicate of the initial point, it is\n          ignored. The number of control points must be >= (degree+1).\n      degree (number, optional): The degree of the curve (must be >=1).\n          Periodic curves must have a degree >= 2. For knotstyle = 1 or 2,\n          the degree must be 3. For knotstyle = 4 or 5, the degree must be odd\n      knotstyle(opt):\n          0 Uniform knots.  Parameter spacing between consecutive knots is 1.0.\n          1 Chord length spacing.  Requires degree = 3 with arrCV1 and arrCVn1 specified.\n          2 Sqrt (chord length).  Requires degree = 3 with arrCV1 and arrCVn1 specified.\n          3 Periodic with uniform spacing.\n          4 Periodic with chord length spacing.  Requires an odd degree value.\n          5 Periodic with sqrt (chord length) spacing.  Requires an odd degree value.\n      start_tangent (vector, optional): a vector that specifies a tangency condition at the\n          beginning of the curve. If the curve is periodic, this argument must be omitted.\n      end_tangent (vector, optional): 3d vector that specifies a tangency condition at the\n          end of the curve. If the curve is periodic, this argument must be omitted.\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      points = (0,0,0), (1,1,0), (2,0,0), (3,1,0), (4,0,0), (5,1,0)\n      rs.AddInterpCurve(points)\n    See Also:\n      AddCurve\n      CurvePointCount\n      IsCurve\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    if not start_tangent: start_tangent = Rhino.Geometry.Vector3d.Unset\n    start_tangent = rhutil.coerce3dvector(start_tangent, True)\n    if not end_tangent: end_tangent = Rhino.Geometry.Vector3d.Unset\n    end_tangent = rhutil.coerce3dvector(end_tangent, True)\n    knotstyle = System.Enum.ToObject(Rhino.Geometry.CurveKnotStyle, knotstyle)\n    curve = Rhino.Geometry.Curve.CreateInterpolatedCurve(points, degree, knotstyle, start_tangent, end_tangent)\n    if not curve: raise Exception(\"unable to CreateInterpolatedCurve\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddLine(start, end):\n    \"\"\"Adds a line curve to the current model.\n    Parameters:\n      start, end (point|guid) end points of the line\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      start = rs.GetPoint(\"Start of line\")\n      if start:\n          end = rs.GetPoint(\"End of line\")\n          if end: rs.AddLine(start, end)\n    See Also:\n      CurveEndPoint\n      CurveStartPoint\n      IsLine\n    \"\"\"\n    start = rhutil.coerce3dpoint(start, True)\n    end = rhutil.coerce3dpoint(end, True)\n    rc = scriptcontext.doc.Objects.AddLine(start, end)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add line to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddNurbsCurve(points, knots, degree, weights=None):\n    \"\"\"Adds a NURBS curve object to the document\n    Parameters:\n      points ([guid|point, guid|point, ...]): a list containing 3D control points\n      knots ([number, number, ...]): Knot values for the curve. The number of elements in knots must\n          equal the number of elements in points plus degree minus 1\n      degree (number): degree of the curve. must be greater than of equal to 1\n      weights([number, number, ...], optional) weight values for the curve. Number of elements should\n          equal the number of elements in points. Values must be greater than 0\n    Returns:\n      guid: the identifier of the new object if successful, otherwise None\n    Example:\n      import rhinoscriptsyntax as rs\n      curve_id = rs.GetObject(\"Pick a curve\", rs.filter.curve)\n      if curve_id:\n          points = rs.CurvePoints(curve_id)\n          knots = rs.CurveKnots(curve_id)\n          degree = rs.CurveDegree(curve_id)\n          newcurve = rs.AddNurbsCurve( points, knots, degree)\n          if newcurve: rs.SelectObject(newcurve)\n    See Also:\n      CurveDegree\n      CurveKnots\n      CurvePoints\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    cvcount = len(points)\n    knotcount = cvcount + degree - 1\n    if len(knots)!=knotcount:\n        raise Exception(\"Number of elements in knots must equal the number of elements in points plus degree minus 1\")\n    if weights and len(weights)!=cvcount:\n        raise Exception(\"Number of elements in weights should equal the number of elements in points\")\n    rational = (weights!=None)\n    \n    nc = Rhino.Geometry.NurbsCurve(3,rational,degree+1,cvcount)\n    if rational: \n        for i in compat.RANGE(cvcount):\n            nc.Points.SetPoint(i, points[i], weights[i])\n    else:\n        for i in compat.RANGE(cvcount):\n            nc.Points.SetPoint(i, points[i])\n    for i in compat.RANGE(knotcount): nc.Knots[i] = knots[i]\n    rc = scriptcontext.doc.Objects.AddCurve(nc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddPolyline(points, replace_id=None):\n    \"\"\"Adds a polyline curve to the current model\n    Parameters:\n      points ([guid|point, guid|point, ...]): list of 3D points. Duplicate, consecutive points will be\n               removed. The list must contain at least two points. If the\n               list contains less than four points, then the first point and\n               last point must be different.\n      replace_id (guid, optional): If set to the id of an existing object, the object\n               will be replaced by this polyline\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      points = rs.GetPoints(True)\n      if points: rs.AddPolyline(points)\n    See Also:\n      IsPolyline\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    if replace_id: replace_id = rhutil.coerceguid(replace_id, True)\n    rc = System.Guid.Empty\n    pl = Rhino.Geometry.Polyline(points)\n    pl.DeleteShortSegments(scriptcontext.doc.ModelAbsoluteTolerance)\n    if replace_id:\n        if scriptcontext.doc.Objects.Replace(replace_id, pl):\n            rc = replace_id\n    else:\n        rc = scriptcontext.doc.Objects.AddPolyline(pl)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add polyline to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddRectangle(plane, width, height):\n    \"\"\"Add a rectangular curve to the document\n    Parameters:\n      plane (plane) plane on which the rectangle will lie\n      width, height (number): width and height of rectangle as measured along the plane's\n        x and y axes\n    Returns:\n      guid: id of new rectangle\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.WorldXYPlane()\n      plane = rs.RotatePlane(plane, 45.0, [0,0,1])\n      rs.AddRectangle( plane, 5.0, 15.0 )\n    See Also:\n      \n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    rect = Rhino.Geometry.Rectangle3d(plane, width, height)\n    poly = rect.ToPolyline()\n    rc = scriptcontext.doc.Objects.AddPolyline(poly)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add polyline to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSpiral(point0, point1, pitch, turns, radius0, radius1=None):\n    \"\"\"Adds a spiral or helical curve to the document\n    Parameters:\n      point0 (point|guid): helix axis start point or center of spiral\n      point1 (point|guid): helix axis end point or point normal on spiral plane\n      pitch (number): distance between turns. If 0, then a spiral. If > 0 then the\n              distance between helix \"threads\"\n      turns (number): number of turns\n      radius0 (number): starting radius of spiral\n      radius1 (number, optional): ending radius of spiral. If omitted, the starting radius is used for the complete spiral.\n    Returns:\n      guid: id of new curve on success\n    Example:\n      import rhinoscriptsyntax as rs\n      point0 = (0,0,0)\n      point1 = (0,0,10)\n      pitch = 1\n      turns = 10\n      radius0 = 5.0\n      radius1 = 8.0\n      rs.AddSpiral(point0, point1, pitch, turns, radius0, radius1)\n    See Also:\n      \n    \"\"\"\n    if radius1 is None: radius1 = radius0\n    point0 = rhutil.coerce3dpoint(point0, True)\n    point1 = rhutil.coerce3dpoint(point1, True)\n    dir = point1 - point0\n    plane = Rhino.Geometry.Plane(point0, dir)\n    point2 = point0 + plane.XAxis\n    curve = Rhino.Geometry.NurbsCurve.CreateSpiral(point0, dir, point2, pitch, turns, radius0, radius1)\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSubCrv(curve_id, param0, param1):\n    \"\"\"Add a curve object based on a portion, or interval of an existing curve\n    object. Similar in operation to Rhino's SubCrv command\n    Parameters:\n      curve_id (guid): identifier of a closed planar curve object\n      param0, param1 (number): first and second parameters on the source curve\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      getresult = rs.GetCurveObject()\n      if getresult:\n          curve_id = getresult[0]\n          point0 = rs.GetPointOnCurve( curve_id )\n          if point0:\n              point1 = rs.GetPointOnCurve( curve_id )\n              if point1:\n                  t0 = rs.CurveClosestPoint( curve_id, point0)\n                  t1 = rs.CurveClosestPoint( curve_id, point1)\n                  rs.AddSubCrv( curve_id, t0, t1 )\n    See Also:\n      CurveClosestPoint\n      GetCurveObject\n      GetPointOnCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    trimcurve = curve.Trim(param0, param1)\n    if not trimcurve: raise Exception(\"unable to trim curve\")\n    rc = scriptcontext.doc.Objects.AddCurve(trimcurve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ArcAngle(curve_id, segment_index=-1):\n    \"\"\"Returns the angle of an arc curve object.\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): identifies the curve segment if\n      curve_id (guid): identifies a polycurve\n    Returns:\n      number: The angle in degrees if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select arc\")\n      if rs.IsArc(id):\n          angle = rs.ArcAngle(id)\n          print(\"Arc angle: {}\".format(angle))\n    See Also:\n      AddArc3Pt\n      ArcCenterPoint\n      ArcMidPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.AngleDegrees\n\n\ndef ArcCenterPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the center point of an arc curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: The 3D center point of the arc if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select arc\")\n      if rs.IsArc(id):\n      point = rs.ArcCenterPoint(id)\n      rs.AddPoint(point)\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcMidPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.Center\n\n\ndef ArcMidPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the mid point of an arc curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: The 3D mid point of the arc if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select arc\")\n      if rs.IsArc(id):\n          point = rs.ArcMidPoint(id)\n          rs.AddPoint(point)\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcCenterPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.MidPoint\n\n\ndef ArcRadius(curve_id, segment_index=-1):\n    \"\"\"Returns the radius of an arc curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The radius of the arc if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select arc\")\n      if rs.IsArc(id):\n          radius = rs.ArcRadius(id)\n          print(\"Arc radius: {}\".format(radius))\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcCenterPoint\n      ArcMidPoint\n      IsArc\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.Radius\n\n\ndef CircleCenterPoint(curve_id, segment_index=-1, return_plane=False):\n    \"\"\"Returns the center point of a circle curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n      return_plane (bool, optional): if True, the circle's plane is returned. If omitted the plane is not returned.\n    Returns:\n      point: The 3D center point of the circle if successful.\n      plane: The plane of the circle if return_plane is True\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select circle\")\n      if rs.IsCircle(id):\n          point = rs.CircleCenterPoint(id)\n          rs.AddPoint( point )\n    See Also:\n      AddCircle\n      AddCircle3Pt\n      CircleCircumference\n      CircleRadius\n      IsCircle\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, circle = curve.TryGetCircle(Rhino.RhinoMath.ZeroTolerance)\n    if not rc: raise Exception(\"curve is not circle\")\n    if return_plane: return circle.Plane\n    return circle.Center\n\n\ndef CircleCircumference(curve_id, segment_index=-1):\n    \"\"\"Returns the circumference of a circle curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The circumference of the circle if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select circle\")\n      if rs.IsCircle(id):\n          circumference = rs.CircleCircumference(id)\n          print(\"Circle circumference: {}\".format(circumference))\n    See Also:\n      AddCircle\n      AddCircle3Pt\n      CircleCenterPoint\n      CircleRadius\n      IsCircle\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, circle = curve.TryGetCircle( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not circle\")\n    return circle.Circumference\n\n\ndef CircleRadius(curve_id, segment_index=-1):\n    \"\"\"Returns the radius of a circle curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The radius of the circle if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select circle\")\n      if rs.IsCircle(id):\n          radius = rs.CircleRadius(id)\n          print(\"Circle radius: {}\".format(radius))\n    See Also:\n      AddCircle\n      AddCircle3Pt\n      CircleCenterPoint\n      CircleCircumference\n      IsCircle\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, circle = curve.TryGetCircle( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not circle\")\n    return circle.Radius\n\n\ndef CloseCurve(curve_id, tolerance=-1.0):\n    \"\"\"Closes an open curve object by making adjustments to the end points so\n    they meet at a point\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      tolerance (number, optional): maximum allowable distance between start and end\n                                    point. If omitted, the current absolute tolerance is used\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if not rs.IsCurveClosed(obj) and rs.IsCurveClosable(obj):\n          rs.CloseCurve( obj )\n    See Also:\n      IsCurveClosable\n      IsCurveClosed\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if curve.IsClosed: return curve_id\n    if tolerance<0.0: tolerance = Rhino.RhinoMath.ZeroTolerance\n    if not curve.MakeClosed(tolerance): return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ClosedCurveOrientation(curve_id, direction=(0,0,1)):\n    \"\"\"Determine the orientation (counter-clockwise or clockwise) of a closed,\n    planar curve\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      direction (vector, optional): 3d vector that identifies up, or Z axs, direction of\n                                    the plane to test against\n    Returns:\n      number: 1 if the curve's orientation is counter-clockwise\n             -1 if the curve's orientation is clockwise\n              0 if unable to compute the curve's orientation\n    Example:\n    See Also:\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1 ,True)\n    direction = rhutil.coerce3dvector(direction, True)\n    if not curve.IsClosed: return 0\n    orientation = curve.ClosedCurveOrientation(direction)\n    return int(orientation)\n\n\ndef ConvertCurveToPolyline(curve_id, angle_tolerance=5.0, tolerance=0.01, delete_input=False, min_edge_length=0, max_edge_length=0):\n    \"\"\"Convert curve to a polyline curve\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      angle_tolerance (number, optional): The maximum angle between curve tangents at line endpoints.\n                                          If omitted, the angle tolerance is set to 5.0.\n      tolerance(number, optional): The distance tolerance at segment midpoints. If omitted, the tolerance is set to 0.01.\n      delete_input(bool, optional): Delete the curve object specified by curve_id. If omitted, curve_id will not be deleted.\n      min_edge_length (number, optional): Minimum segment length\n      max_edge_length (number, optonal): Maximum segment length\n    Returns:\n      guid: The new curve if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          polyline = rs.ConvertCurveToPolyline(obj)\n          if polyline: rs.SelectObject(polyline)\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if angle_tolerance<=0: angle_tolerance = 5.0\n    angle_tolerance = Rhino.RhinoMath.ToRadians(angle_tolerance)\n    if tolerance<=0.0: tolerance = 0.01;\n    polyline_curve = curve.ToPolyline( 0, 0, angle_tolerance, 0.0, 0.0, tolerance, min_edge_length, max_edge_length, True)\n    if not polyline_curve: return scriptcontext.errorhandler()\n    id = System.Guid.Empty\n    if delete_input:\n        if scriptcontext.doc.Objects.Replace( curve_id, polyline_curve): id = curve_id\n    else:\n        id = scriptcontext.doc.Objects.AddCurve( polyline_curve )\n    if System.Guid.Empty==id: return scriptcontext.errorhandler()\n    return id\n\n  \ndef CurveArcLengthPoint(curve_id, length, from_start=True):\n    \"\"\"Returns the point on the curve that is a specified arc length\n    from the start of the curve.\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      length (number): The arc length from the start of the curve to evaluate.\n      from_start (bool, optional): If not specified or True, then the arc length point is\n          calculated from the start of the curve. If False, the arc length\n          point is calculated from the end of the curve.\n    Returns:\n      point: on curve if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          length = rs.CurveLength(obj)\n          point = rs.CurveArcLengthPoint(obj, length/3.0)\n          rs.AddPoint( point )\n    See Also:\n      CurveEndPoint\n      CurveMidPoint\n      CurveStartPoint\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    curve_length = curve.GetLength()\n    if curve_length>=length:\n        s = 0.0\n        if length==0.0: s = 0.0\n        elif length==curve_length: s = 1.0\n        else: s = length / curve_length\n        dupe = curve.Duplicate()\n        if dupe:\n            if from_start==False: dupe.Reverse()\n            rc, t = dupe.NormalizedLengthParameter(s)\n            if rc: return dupe.PointAt(t)\n            dupe.Dispose()\n\n\ndef CurveArea(curve_id):\n    \"\"\"Returns area of closed planar curves. The results are based on the\n    current drawing units.\n    Parameters:\n      curve_id (guid): The identifier of a closed, planar curve object.\n    Returns:\n      list[number, number]: List of area information. The list will contain the following information:\n        Element  Description\n        [0]      The area. If more than one curve was specified, the\n                   value will be the cumulative area.\n        [1]      The absolute (+/-) error bound for the area.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if id:\n          props = rs.CurveArea(id)\n          if props:\n              print(\"The curve area is: {}\".format(props[0]))\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    mp = Rhino.Geometry.AreaMassProperties.Compute(curve, tol)\n    if mp == None: return None\n    return mp.Area, mp.AreaError\n\n\ndef CurveAreaCentroid(curve_id):\n    \"\"\"Returns area centroid of closed, planar curves. The results are based\n    on the current drawing units.\n    Parameters:\n      curve_id (guid)The identifier of a closed, planar curve object.\n    Returns:\n      tuple(point, vector): of area centroid information containing the following information:\n        Element  Description\n        [0]        The 3d centroid point. If more than one curve was specified,\n                 the value will be the cumulative area.\n        [1]        A 3d vector with the absolute (+/-) error bound for the area\n                 centroid.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if id:\n          props = rs.CurveAreaCentroid(id)\n          if props:\n              print(\"The curve area centroid is: {}\".format(props[0]))\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    mp = Rhino.Geometry.AreaMassProperties.Compute(curve, tol)\n    if mp == None: return None\n    return mp.Centroid, mp.CentroidError\n\n\ndef CurveArrows(curve_id, arrow_style=None):\n    \"\"\"Enables or disables a curve object's annotation arrows\n    Parameters:\n      curve_id (guid): identifier of a curve\n      arrow_style (number, optional): the style of annotation arrow to be displayed. If omitted the current type is returned.\n        0 = no arrows\n        1 = display arrow at start of curve\n        2 = display arrow at end of curve\n        3 = display arrow at both start and end of curve\n      Returns:\n        number: if arrow_style is not specified, the current annotation arrow style\n        number: if arrow_style is specified, the previous arrow style\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.CurveArrows(obj)!=3: rs.CurveArrows(obj, 3)\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rhobj = rhutil.coercerhinoobject(curve_id, True, True)\n    attr = rhobj.Attributes\n    rc = attr.ObjectDecoration\n    none_obj_decor = compat.ENUM_NONE(Rhino.DocObjects.ObjectDecoration)\n    if arrow_style is not None:\n        if arrow_style==0:\n            attr.ObjectDecoration = none_obj_decor\n        elif arrow_style==1:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.StartArrowhead\n        elif arrow_style==2:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.EndArrowhead\n        elif arrow_style==3:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.BothArrowhead\n        id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.ModifyAttributes(id, attr, True)\n        scriptcontext.doc.Views.Redraw()\n    if rc==none_obj_decor: return 0\n    if rc==Rhino.DocObjects.ObjectDecoration.StartArrowhead: return 1\n    if rc==Rhino.DocObjects.ObjectDecoration.EndArrowhead: return 2\n    if rc==Rhino.DocObjects.ObjectDecoration.BothArrowhead: return 3\n\n\ndef CurveBooleanDifference(curve_id_0, curve_id_1, tolerance=None):\n    \"\"\"Calculates the difference between two closed, planar curves and\n    adds the results to the document. Note, curves must be coplanar.\n    Parameters:\n      curve_id_0 (guid): identifier of the first curve object.\n      curve_id_1 (guid): identifier of the second curve object.\n      tolerance (float, optional): a positive tolerance value, or None for the doc default.\n    Returns:\n      list(guid, ...): The identifiers of the new objects if successful, None on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curveA = rs.GetObject(\"Select first curve\", rs.filter.curve)\n      curveB = rs.GetObject(\"Select second curve\", rs.filter.curve)\n      arrResult = rs.CurveBooleanDifference(curveA, curveB)\n      if arrResult:\n          rs.DeleteObject( curveA )\n          rs.DeleteObject( curveB )\n    See Also:\n      CurveBooleanIntersection\n      CurveBooleanUnion\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    out_curves = Rhino.Geometry.Curve.CreateBooleanDifference(curve0, curve1, tolerance)\n    curves = []\n    if out_curves:\n        for curve in out_curves:\n            if curve and curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n                curve.Dispose()\n                if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n                curves.append(rc)\n    scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef CurveBooleanIntersection(curve_id_0, curve_id_1, tolerance=None):\n    \"\"\"Calculates the intersection of two closed, planar curves and adds\n    the results to the document. Note, curves must be coplanar.\n    Parameters:\n      curve_id_0 (guid): identifier of the first curve object.\n      curve_id_1 (guid): identifier of the second curve object.\n      tolerance (float, optional): a positive tolerance value, or None for the doc default.\n    Returns:\n      list(guid, ...): The identifiers of the new objects.\n    Example:\n      import rhinoscriptsyntax as rs\n      curveA = rs.GetObject(\"Select first curve\", rs.filter.curve)\n      curveB = rs.GetObject(\"Select second curve\", rs.filter.curve)\n      result = rs.CurveBooleanIntersection(curveA, curveB)\n      if result:\n          rs.DeleteObject( curveA )\n          rs.DeleteObject( curveB )\n    See Also:\n      CurveBooleanDifference\n      CurveBooleanUnion\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    out_curves = Rhino.Geometry.Curve.CreateBooleanIntersection(curve0, curve1, tolerance)\n    curves = []\n    if out_curves:\n        for curve in out_curves:\n            if curve and curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n                curve.Dispose()\n                if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n                curves.append(rc)\n    scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef CurveBooleanUnion(curve_id, tolerance=None):\n    \"\"\"Calculate the union of two or more closed, planar curves and\n    add the results to the document. Note, curves must be coplanar.\n    Parameters:\n      curve_id ([guid, guid, ...])list of two or more close planar curves identifiers\n      tolerance (float, optional): a positive tolerance value, or None for the doc default.\n    Returns:\n      list(guid, ...): The identifiers of the new objects.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve_ids = rs.GetObjects(\"Select curves to union\", rs.filter.curve)\n      if curve_ids and len(curve_ids)>1:\n          result = rs.CurveBooleanUnion(curve_ids)\n          if result: rs.DeleteObjects(curve_ids)\n    See Also:\n      CurveBooleanDifference\n      CurveBooleanIntersection\n    \"\"\"\n    in_curves = [rhutil.coercecurve(id,-1,True) for id in curve_id]\n    if len(in_curves)<2: raise ValueException(\"curve_id must have at least 2 curves\")\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    out_curves = Rhino.Geometry.Curve.CreateBooleanUnion(in_curves, tolerance)\n    curves = []\n    if out_curves:\n        for curve in out_curves:\n            if curve and curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n                curve.Dispose()\n                if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n                curves.append(rc)\n        scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef CurveBrepIntersect(curve_id, brep_id, tolerance=None):\n    \"\"\"Intersects a curve object with a brep object. Note, unlike the\n    CurveSurfaceIntersection function, this function works on trimmed surfaces.\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      brep_id (guid): identifier of a brep object\n      tolerance (number, optional): distance tolerance at segment midpoints.\n                        If omitted, the current absolute tolerance is used.\n    Returns:\n      list(guid, ...): identifiers for the newly created intersection objects if successful.\n      None: on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if curve:\n          brep = rs.GetObject(\"Select a brep\", rs.filter.surface + rs.filter.polysurface)\n          if brep: rs.CurveBrepIntersect( curve, brep )\n    See Also:\n      CurveSurfaceIntersection\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    brep = rhutil.coercebrep(brep_id, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, out_curves, out_points = Rhino.Geometry.Intersect.Intersection.CurveBrep(curve, brep, tolerance)\n    if not rc: return scriptcontext.errorhandler()\n    \n    curves = []\n    points = []\n    for curve in out_curves:\n        if curve and curve.IsValid:\n            rc = scriptcontext.doc.Objects.AddCurve(curve)\n            curve.Dispose()\n            if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n            curves.append(rc)\n    for point in out_points:\n        if point and point.IsValid:\n            rc = scriptcontext.doc.Objects.AddPoint(point)\n            points.append(rc)\n    if not curves and not points: return None\n    scriptcontext.doc.Views.Redraw()\n    return curves, points\n\n\ndef CurveClosestObject(curve_id, object_ids):\n    \"\"\"Returns the 3D point locations on two objects where they are closest to\n    each other. Note, this function provides similar functionality to that of\n    Rhino's ClosestPt command.\n    Parameters:\n      curve_id (guid):identifier of the curve object to test\n      object_ids ([guid, ...]) list of identifiers of point cloud, curve, surface, or\n        polysurface to test against\n    Returns:\n      tuple[guid, point, point]: containing the results of the closest point calculation.\n      The elements are as follows:\n        [0]    The identifier of the closest object.\n        [1]    The 3-D point that is closest to the closest object.\n        [2]    The 3-D point that is closest to the test curve.\n    Example:\n      import rhinoscriptsyntax as rs\n      filter = rs.filter.curve | rs.filter.pointcloud | rs.filter.surface | rs.filter.polysurface\n      objects = rs.GetObjects(\"Select target objects for closest point\", filter)\n      if objects:\n          curve = rs.GetObject(\"Select curve\")\n          if curve:\n              results = rs.CurveClosestObject(curve, objects)\n              if results:\n                  print(\"Curve id: {}\".format(results[0]))\n                  rs.AddPoint( results[1] )\n                  rs.AddPoint( results[2] )\n    See Also:\n      CurveClosestPoint\n      EvaluateCurve\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id,-1,True)\n    geometry = []\n    id = rhutil.coerceguid(object_ids, False)\n    if id: object_ids = [id]\n    for object_id in object_ids:\n        rhobj = rhutil.coercerhinoobject(object_id, True, True)\n        geometry.append( rhobj.Geometry )\n    if not geometry: raise ValueError(\"object_ids must contain at least one item\")\n    success, curve_point, geom_point, which_geom = curve.ClosestPoints(geometry, 0.0)\n    if success: return object_ids[which_geom], geom_point, curve_point\n\n    \ndef CurveClosestPoint(curve_id, test_point, segment_index=-1 ):\n    \"\"\"Returns parameter of the point on a curve that is closest to a test point.\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      point (point): sampling point\n      segment_index (number, optional): curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The parameter of the closest point on the curve\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a curve\")\n      if id:\n          point = rs.GetPointOnCurve(id, \"Pick a test point\")\n          if point:\n              param = rs.CurveClosestPoint(id, point)\n              print(\"Curve parameter: {}\".format(param))\n    See Also:\n      EvaluateCurve\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    point = rhutil.coerce3dpoint(test_point, True)\n    rc, t = curve.ClosestPoint(point, 0.0)\n    if not rc: raise Exception(\"ClosestPoint failed\")\n    return t\n\n\ndef CurveContourPoints(curve_id, start_point, end_point, interval=None):\n    \"\"\"Returns the 3D point locations calculated by contouring a curve object.\n    Parameters:\n      curve_id (guid): identifier of a curve object.\n      start_point (point): 3D starting point of a center line.\n      end_point (point): 3D ending point of a center line.\n      interval (number, optional): The distance between contour curves. If omitted,\n      the interval will be equal to the diagonal distance of the object's\n      bounding box divided by 50.\n    Returns:\n      list(point, ....): A list of 3D points, one for each contour\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      start_point = rs.GetPoint(\"Base point of center line\")\n      end_point = rs.GetPoint(\"Endpoint of center line\", start_point)\n      contour = rs.CurveContourPoints(obj, start_point, end_point)\n      if contour: rs.AddPoints(contour)\n    See Also:\n      AddSrfContourCrvs\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    start_point = rhutil.coerce3dpoint(start_point, True)\n    end_point = rhutil.coerce3dpoint(end_point, True)\n    if start_point.DistanceTo(end_point)<Rhino.RhinoMath.ZeroTolerance:\n        raise Exception(\"start and end point are too close to define a line\")\n    if not interval:\n        bbox = curve.GetBoundingBox(True)\n        diagonal = bbox.Max - bbox.Min\n        interval = diagonal.Length / 50.0\n    rc = curve.DivideAsContour( start_point, end_point, interval )\n    return list(rc)\n\n\ndef CurveCurvature(curve_id, parameter):\n    \"\"\"Returns the curvature of a curve at a parameter. See the Rhino help for\n    details on curve curvature\n    Parameters:\n      curve_id (guid): identifier of the curve\n      parameter (number): parameter to evaluate\n    Returns:\n      tuple[point, vector, point, number, vector]: of curvature information on success\n        [0] = point at specified parameter\n        [1] = tangent vector\n        [2] = center of radius of curvature\n        [3] = radius of curvature\n        [4] = curvature vector\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          point = rs.GetPointOnCurve(obj, \"Pick a test point\")\n          if point:\n              param = rs.CurveClosestPoint(obj, point)\n              if param:\n                  data = rs.CurveCurvature(obj, param)\n                  if data:\n                      print(\"Curve curvature evaluation at parameter {}\".format(param, \":\"))\n                      print(\" 3-D Point: {}\".format(data[0]))\n                      print(\" 3-D Tangent: {}\".format(data[1]))\n                      print(\" Center of radius of curvature: {}\".format(data[2]))\n                      print(\" Radius of curvature: {}\".format(data[3]))\n                      print(\" 3-D Curvature: {}\".format(data[4]))\n    See Also:\n      SurfaceCurvature\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    point = curve.PointAt(parameter)\n    tangent = curve.TangentAt(parameter)\n    if tangent.IsTiny(0): return scriptcontext.errorhandler()\n    cv = curve.CurvatureAt(parameter)\n    k = cv.Length\n    if k<Rhino.RhinoMath.SqrtEpsilon: return scriptcontext.errorhandler()\n    rv = cv / (k*k)\n    circle = Rhino.Geometry.Circle(point, tangent, point + 2.0*rv)\n    center = point + rv\n    radius = circle.Radius\n    return point, tangent, center, radius, cv\n\n\ndef CurveCurveIntersection(curveA, curveB=None, tolerance=-1):\n    \"\"\"Calculates intersection of two curve objects.\n    Parameters:\n      curveA (guid): identifier of the first curve object.\n      curveB  (guid, optional): identifier of the second curve object. If omitted, then a\n               self-intersection test will be performed on curveA.\n      tolerance (number, optional): absolute tolerance in drawing units. If omitted,\n                        the document's current absolute tolerance is used.\n    Returns:\n      list of tuples: containing intersection information if successful.\n      The list will contain one or more of the following elements:\n        Element Type     Description\n        [n][0]  Number   The intersection event type, either Point (1) or Overlap (2).\n        [n][1]  Point3d  If the event type is Point (1), then the intersection point \n                         on the first curve. If the event type is Overlap (2), then\n                         intersection start point on the first curve.\n        [n][2]  Point3d  If the event type is Point (1), then the intersection point\n                         on the first curve. If the event type is Overlap (2), then\n                         intersection end point on the first curve.\n        [n][3]  Point3d  If the event type is Point (1), then the intersection point \n                         on the second curve. If the event type is Overlap (2), then\n                         intersection start point on the second curve.\n        [n][4]  Point3d  If the event type is Point (1), then the intersection point\n                         on the second curve. If the event type is Overlap (2), then\n                         intersection end point on the second curve.\n        [n][5]  Number   If the event type is Point (1), then the first curve parameter.\n                         If the event type is Overlap (2), then the start value of the\n                         first curve parameter range.\n        [n][6]  Number   If the event type is Point (1), then the first curve parameter.\n                         If the event type is Overlap (2), then the end value of the\n                         first curve parameter range.\n        [n][7]  Number   If the event type is Point (1), then the second curve parameter.\n                         If the event type is Overlap (2), then the start value of the\n                         second curve parameter range.\n        [n][8]  Number   If the event type is Point (1), then the second curve parameter.\n                         If the event type is Overlap (2), then the end value of the \n                         second curve parameter range.\n    Example:\n      import rhinoscriptsyntax as rs\n      def ccx():\n          curve1 = rs.GetObject(\"Select first curve\", rs.filter.curve)\n          if curve1 is None: return\n          curve2 = rs.GetObject(\"Select second curve\", rs.filter.curve)\n          if curve2 is None: return\n          intersection_list = rs.CurveCurveIntersection(curve1, curve2)\n          if intersection_list is None:\n              print(\"Selected curves do not intersect.\")\n              return\n          for intersection in intersection_list:\n              if intersection[0] == 1:\n                  print(\"Point\")\n                  print(\"Intersection point on first curve:  {}\".format(intersection[1]))\n                  print(\"Intersection point on second curve:  {}\".format(intersection[3]))\n                  print(\"First curve parameter:  {}\".format(intersection[5]))\n                  print(\"Second curve parameter:  {}\".format(intersection[7]))\n              else:\n                  print(\"Overlap\")\n                  print(\"Intersection start point on first curve: {}\".format(intersection[1]))\n                  print(\"Intersection end point on first curve: {}\".format(intersection[2]))\n                  print(\"Intersection start point on second curve: {}\".format(intersection[3]))\n                  print(\"Intersection end point on second curve: {}\".format(intersection[4]))\n                  print(\"First curve parameter range: {} to {}\".format(intersection[5], intersection[6]))\n                  print(\"Second curve parameter range: {} to {}\".format(intersection[7], intersection[8]))\n      ccx()\n    See Also:\n      CurveSurfaceIntersection\n    \"\"\"\n    curveA = rhutil.coercecurve(curveA, -1, True)\n    if curveB: curveB = rhutil.coercecurve(curveB, -1, True)\n    if tolerance is None or tolerance<0.0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if curveB:\n        rc = Rhino.Geometry.Intersect.Intersection.CurveCurve(curveA, curveB, tolerance, 0.0)\n    else:\n        rc = Rhino.Geometry.Intersect.Intersection.CurveSelf(curveA, tolerance)\n    if rc:\n        events = []\n        for i in compat.RANGE(rc.Count):\n            event_type = 1\n            if( rc[i].IsOverlap ): event_type = 2\n            oa = rc[i].OverlapA\n            ob = rc[i].OverlapB\n            element = (event_type, rc[i].PointA, rc[i].PointA2, rc[i].PointB, rc[i].PointB2, oa[0], oa[1], ob[0], ob[1])\n            events.append(element)\n        return events\n\n\ndef CurveDegree(curve_id, segment_index=-1):\n    \"\"\"Returns the degree of a curve object.\n    Parameters:\n      curve_id (guid): identifier of a curve object.\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve.\n    Returns:\n      number: The degree of the curve if successful.\n      None: on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          degree = rs.CurveDegree(obj)\n          print(\"Curve degree:{}\".format(degree))\n    See Also:\n      CurveDomain\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.Degree\n\n\ndef CurveDeviation(curve_a, curve_b):\n    \"\"\"Returns the minimum and maximum deviation between two curve objects\n    Parameters:\n      curve_a, curve_b (guid): identifiers of two curves\n    Returns:\n      tuple[number, number, number, number, number, number]: of deviation information on success\n        [0] = curve_a parameter at maximum overlap distance point\n        [1] = curve_b parameter at maximum overlap distance point\n        [2] = maximum overlap distance\n        [3] = curve_a parameter at minimum overlap distance point\n        [4] = curve_b parameter at minimum overlap distance point\n        [5] = minimum distance between curves\n      None on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curveA = rs.GetObject(\"Select first curve to test\", rs.filter.curve)\n      curveB = rs.GetObject(\"Select second curve to test\", rs.filter.curve)\n      deviation = rs.CurveDeviation(curveA, curveB)\n      if deviation:\n          print(\"Minimum deviation = {}\".format(deviation[5]))\n          print(\"Maximum deviation = {}\".format(deviation[2]))\n    See Also:\n      CurveArea\n      CurveAreaCentroid\n    \"\"\"\n    curve_a = rhutil.coercecurve(curve_a, -1, True)\n    curve_b = rhutil.coercecurve(curve_b, -1, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc = Rhino.Geometry.Curve.GetDistancesBetweenCurves(curve_a, curve_b, tol)\n    if not rc[0]: return scriptcontext.errorhandler()\n    maxa = rc[2]\n    maxb = rc[3]\n    maxd = rc[1]\n    mina = rc[5]\n    minb = rc[6]\n    mind = rc[4]\n    return maxa, maxb, maxd, mina, minb, mind\n\n\ndef CurveDim(curve_id, segment_index=-1):\n    \"\"\"Returns the dimension of a curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object.\n      segment_index (number, optional): the curve segment if `curve_id` identifies a polycurve.\n    Returns:\n      number: The dimension of the curve if successful. None on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(curve):\n          print(\"Curve dimension = {}\".format(rs.CurveDim(curve)))\n    See Also:\n      CurveDegree\n      CurveDomain\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.Dimension\n\n\ndef CurveDirectionsMatch(curve_id_0, curve_id_1):\n    \"\"\"Tests if two curve objects are generally in the same direction or if they\n    would be more in the same direction if one of them were flipped. When testing\n    curve directions, both curves must be either open or closed - you cannot test\n    one open curve and one closed curve.\n    Parameters:\n      curve_id_0 (guid): identifier of first curve object\n      curve_id_1 (guid): identifier of second curve object\n    Returns:\n      bool: True if the curve directions match, otherwise False.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve1 = rs.GetObject(\"Select first curve to compare\", rs.filter.curve)\n      curve2 = rs.GetObject(\"Select second curve to compare\", rs.filter.curve)\n      if rs.CurveDirectionsMatch(curve1, curve2):\n          print(\"Curves are in the same direction\")\n      else:\n          print(\"Curve are not in the same direction\")\n    See Also:\n      ReverseCurve\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    return Rhino.Geometry.Curve.DoDirectionsMatch(curve0, curve1)\n\n\ndef CurveDiscontinuity(curve_id, style):   \n    \"\"\"Search for a derivatitive, tangent, or curvature discontinuity in\n    a curve object.\n    Parameters:\n      curve_id (guid): identifier of curve object\n      style (number): The type of continuity to test for. The types of\n          continuity are as follows:\n          Value    Description\n          1        C0 - Continuous function\n          2        C1 - Continuous first derivative\n          3        C2 - Continuous first and second derivative\n          4        G1 - Continuous unit tangent\n          5        G2 - Continuous unit tangent and curvature\n    Returns:\n      list(point, ...): 3D points where the curve is discontinuous\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.IsCurve(curve):\n          points = rs.CurveDiscontinuity(curve, 2)\n          if points: rs.AddPoints( points )\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    dom = curve.Domain\n    t0 = dom.Min\n    t1 = dom.Max\n    points = []\n    get_next = True\n    while get_next:\n        get_next, t = curve.GetNextDiscontinuity(System.Enum.ToObject(Rhino.Geometry.Continuity, style), t0, t1)\n        if get_next:\n            points.append(curve.PointAt(t))\n            t0 = t # Advance to the next parameter\n    return points\n\n\ndef CurveDomain(curve_id, segment_index=-1):\n    \"\"\"Returns the domain of a curve object\n    as an indexable object with two elements.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve.\n    Returns:\n      list(number, number): the domain of the curve if successful.\n         [0] Domain minimum\n         [1] Domain maximum\n      None: on error\n\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          domain = rs.CurveDomain(obj)\n          print(\"Curve domain: {} to {}\".format(domain[0], domain[1]))\n    See Also:\n      CurveDegree\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.Domain\n\n\ndef CurveEditPoints(curve_id, return_parameters=False, segment_index=-1):\n    \"\"\"Returns the edit, or Greville, points of a curve object. \n    For each curve control point, there is a corresponding edit point.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      return_parameters (bool, optional): if True, return as a list of curve parameters.\n                                          If False, return as a list of 3d points\n      segment_index (number, optional): the curve segment index is `curve_id` identifies a polycurve\n    Returns:\n      list(point, ....): curve edit points on success\n      None on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          points = rs.CurveEditPoints(obj)\n          if points: rs.AddPointCloud( points )\n    See Also:\n      IsCurve\n      CurvePointCount\n      CurvePoints\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if not nc: return scriptcontext.errorhandler()\n    if return_parameters: return nc.GrevilleParameters()\n    return list(nc.GrevillePoints())\n\n\ndef CurveEndPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the end point of a curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: The 3d endpoint of the curve if successful.\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          point = rs.CurveEndPoint(object)\n          rs.AddPoint(point)\n    See Also:\n      CurveMidPoint\n      CurveStartPoint\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.PointAtEnd\n\n\ndef CurveFilletPoints(curve_id_0, curve_id_1, radius=1.0, base_point_0=None, base_point_1=None, return_points=True):\n    \"\"\"Find points at which to cut a pair of curves so that a fillet of a\n    specified radius fits. A fillet point is a pair of points (point0, point1)\n    such that there is a circle of radius tangent to curve curve0 at point0 and\n    tangent to curve curve1 at point1. Of all possible fillet points, this\n    function returns the one which is the closest to the base point base_point_0,\n    base_point_1. Distance from the base point is measured by the sum of arc\n    lengths along the two curves. \n    Parameters:\n      curve_id_0 (guid): identifier of the first curve object.\n      curve_id_1 (guid): identifier of the second curve object.\n      radius (number, optional): The fillet radius. If omitted, a radius\n                     of 1.0 is specified.\n      base_point_0 (point, optional): The base point on the first curve.\n                     If omitted, the starting point of the curve is used.\n      base_point_1 (point, optional): The base point on the second curve. If omitted,\n                     the starting point of the curve is used.\n      return_points (bool, optional): If True (Default), then fillet points are\n                     returned. Otherwise, a fillet curve is created and\n                     it's identifier is returned.\n    Returns:\n      list(point, point, point, vector, vector, vector): If return_points is True, then a list of point and vector values\n      if successful. The list elements are as follows:\n          [0]    A point on the first curve at which to cut (point).\n          [1]    A point on the second curve at which to cut (point).\n          [2]    The fillet plane's origin (point). This point is also\n                   the center point of the fillet\n          [3]    The fillet plane's X axis (vector).\n          [4]    The fillet plane's Y axis (vector).\n          [5]    The fillet plane's Z axis (vector).\n      \n      guid: If return_points is False, then the identifier of the fillet curve\n            if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve0 = rs.AddLine([0,0,0], [5,1,0])\n      curve1 = rs.AddLine([0,0,0], [1,5,0])\n      fillet = rs.CurveFilletPoints(curve0, curve1)\n      if fillet:\n          rs.AddPoint( fillet[0] )\n          rs.AddPoint( fillet[1] )\n          rs.AddPoint( fillet[2] )\n    See Also:\n      AddFilletCurve\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    t0_base = curve0.Domain.Min\n    \n    if base_point_0:\n        rc = curve0.ClosestPoint(base_point_0, t0_base)\n        if not rc[0]: return scriptcontext.errorhandler()\n    \n    t1_base = curve1.Domain.Min\n    if base_point_1:\n        rc = curve1.ClosestPoint(base_point_1, t1_base)\n        if not rc[0]: return scriptcontext.errorhandler()\n\n    r = radius if (radius and radius>0) else 1.0\n    rc = Rhino.Geometry.Curve.GetFilletPoints(curve0, curve1, r, t0_base, t1_base)\n    if rc[0]:\n        point_0 = curve0.PointAt(rc[1])\n        point_1 = curve1.PointAt(rc[2])\n        return point_0, point_1, rc[3].Origin, rc[3].XAxis, rc[3].YAxis, rc[3].ZAxis\n    return scriptcontext.errorhandler()\n\n\ndef CurveFrame(curve_id, parameter, segment_index=-1):\n    \"\"\"Returns the plane at a parameter of a curve. The plane is based on the\n    tangent and curvature vectors at a parameter.\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n      parameter (number): parameter to evaluate.\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      plane: The plane at the specified parameter if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetCurveObject(\"Select a curve\")\n      if curve:\n          plane = rs.CurveFrame(curve[0], curve[4])\n          rs.AddPlaneSurface(plane, 5.0, 3.0)\n    See Also:\n      CurvePerpFrame\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    domain = curve.Domain\n    if not domain.IncludesParameter(parameter):\n        tol = scriptcontext.doc.ModelAbsoluteTolerance\n        if parameter>domain.Max and (parameter-domain.Max)<=tol:\n            parameter = domain.Max\n        elif parameter<domain.Min and (domain.Min-parameter)<=tol:\n            parameter = domain.Min\n        else:\n            return scriptcontext.errorhandler()\n    rc, frame = curve.FrameAt(parameter)\n    if rc and frame.IsValid: return frame\n    return scriptcontext.errorhandler()\n\n\ndef CurveKnotCount(curve_id, segment_index=-1):\n    \"\"\"Returns the knot count of a curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n      segment_index (number, optional): the curve segment if `curve_id` identifies a polycurve.\n    Returns:\n      number: The number of knots if successful.\n      None: if not successful or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          count = rs.CurveKnotCount(obj)\n          print(\"Curve knot count:{}\".format(count))\n    See Also:\n      DivideCurve\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if not nc: return scriptcontext.errorhandler()\n    return nc.Knots.Count\n\n\ndef CurveKnots(curve_id, segment_index=-1):\n    \"\"\"Returns the knots, or knot vector, of a curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve.\n    Returns:\n      list(number, ....): knot values if successful.\n      None: if not successful or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          knots = rs.CurveKnots(obj)\n          if knots:\n              for knot in knots: print(\"Curve knot value:{}\".format(knot))\n    See Also:\n      CurveKnotCount\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if not nc: return scriptcontext.errorhandler()\n    rc = [nc.Knots[i] for i in range(nc.Knots.Count)]\n    return rc\n\n\ndef CurveLength(curve_id, segment_index=-1, sub_domain=None):\n    \"\"\"Returns the length of a curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n      sub_domain ([number, number], optional): list of two numbers identifying the sub-domain of the\n          curve on which the calculation will be performed. The two parameters\n          (sub-domain) must be non-decreasing. If omitted, the length of the\n          entire curve is returned.\n    Returns:\n      number: The length of the curve if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          length = rs.CurveLength(object)\n          print(\"Curve length:{}\".format(length))\n    See Also:\n      CurveDomain\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    if sub_domain:\n        if len(sub_domain)==2:\n            dom = Rhino.Geometry.Interval(sub_domain[0], sub_domain[1])\n            return curve.GetLength(dom)\n        return scriptcontext.errorhandler()\n    return curve.GetLength()\n\n\ndef CurveMidPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the mid point of a curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: The 3D midpoint of the curve if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          point = rs.CurveMidPoint(pbject)\n          rs.AddPoint( point )\n    See Also:\n      CurveEndPoint\n      CurveStartPoint\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, t = curve.NormalizedLengthParameter(0.5)\n    if rc: return curve.PointAt(t)\n    return scriptcontext.errorhandler()\n\n\ndef CurveNormal(curve_id, segment_index=-1):\n    \"\"\"Returns the normal direction of the plane in which a planar curve object lies.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment if curve_id identifies a polycurve\n    Returns:\n      vector: The 3D normal vector if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a planar curve\")\n      if rs.IsCurve(object) and rs.IsCurvePlanar(object):\n          normal = rs.CurveNormal(object)\n          if normal: print(\"Curve Normal:{}\".format(normal))\n    See Also:\n      IsCurve\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, plane = curve.TryGetPlane(tol)\n    if rc: return plane.Normal\n    return scriptcontext.errorhandler()\n\n\ndef CurveNormalizedParameter(curve_id, parameter):\n    \"\"\"Converts a curve parameter to a normalized curve parameter;\n    one that ranges between 0-1\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): the curve parameter to convert\n    Returns:\n      number: normalized curve parameter\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\")\n      if rs.IsCurve(obj):\n          domain = rs.CurveDomain(obj)\n          parameter = (domain[0]+domain[1])/2.0\n          print(\"Curve parameter:{}\".format(parameter))\n          normalized = rs.CurveNormalizedParameter(obj, parameter)\n          print(\"Normalized parameter:{}\".format(normalized))\n    See Also:\n      CurveDomain\n      CurveParameter\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    return curve.Domain.NormalizedParameterAt(parameter)\n\n\ndef CurveParameter(curve_id, parameter):\n    \"\"\"Converts a normalized curve parameter to a curve parameter;\n    one within the curve's domain\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): the normalized curve parameter to convert\n    Returns:\n      number: curve parameter\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\")\n      if rs.IsCurve(obj):\n          normalized = 0.5\n          print(\"Normalized parameter:{}\".format(normalized))\n          parameter = rs.CurveParameter(obj, normalized)\n          print(\"Curve parameter:{}\".format(parameter))\n    See Also:\n      CurveDomain\n      CurveNormalizedParameter\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    return curve.Domain.ParameterAt(parameter)\n\n\ndef CurvePerpFrame(curve_id, parameter):\n    \"\"\"Returns the perpendicular plane at a parameter of a curve. The result\n    is relatively parallel (zero-twisting) plane\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): parameter to evaluate\n    Returns:\n      plane: Plane on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      crv = rs.GetCurveObject(\"Select a curve\")\n      if crv:\n          plane = rs.CurvePerpFrame(crv[0], crv[4])\n          rs.AddPlaneSurface( plane, 1, 1 )\n    See Also:\n      CurveFrame\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    parameter = float(parameter)\n    rc, plane = curve.PerpendicularFrameAt(parameter)\n    if rc: return plane\n\n\ndef CurvePlane(curve_id, segment_index=-1):\n    \"\"\"Returns the plane in which a planar curve lies. Note, this function works\n    only on planar curves.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      plane: The plane in which the curve lies if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.IsCurvePlanar(curve):\n          plane = rs.CurvePlane(curve)\n          rs.ViewCPlane(None, plane)\n    See Also:\n      IsCurve\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, plane = curve.TryGetPlane(tol)\n    if rc: return plane\n    return scriptcontext.errorhandler()\n\n\ndef CurvePointCount(curve_id, segment_index=-1):\n    \"\"\"Returns the control points count of a curve object.\n    Parameters:\n      curve_id (guid) identifier of the curve object\n      segment_index (number, optional): the curve segment if `curve_id` identifies a polycurve\n    Returns:\n      number: Number of control points if successful.\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          count = rs.CurvePointCount(obj)\n          print(\"Curve point count:{}\".format(count))\n    See Also:\n      DivideCurve\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if nc: return nc.Points.Count\n    return scriptcontext.errorhandler()\n\n\ndef CurvePoints(curve_id, segment_index=-1):\n    \"\"\"Returns the control points, or control vertices, of a curve object.\n    If the curve is a rational NURBS curve, the euclidean control vertices\n    are returned.\n    Parameters:\n      curve_id (guid): the object's identifier\n      segment_index (number, optional): the curve segment if `curve_id` identifies a polycurve\n    Returns:\n      list(point, ...): the control points, or control vertices, of a curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          points = rs.CurvePoints(obj)\n          if points: [rs.AddPoint(pt) for pt in points]\n    See Also:\n      CurvePointCount\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if nc is None: return scriptcontext.errorhandler()\n    points = [nc.Points[i].Location for i in compat.RANGE(nc.Points.Count)]\n    return points\n\n\ndef CurveRadius(curve_id, test_point, segment_index=-1):\n    \"\"\"Returns the radius of curvature at a point on a curve.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      test_point (point): sampling point\n      segment_index (number, optional): the curve segment if curve_id identifies a polycurve\n    Returns:\n      number: The radius of curvature at the point on the curve if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          point = rs.GetPointOnCurve(obj, \"Pick a test point\")\n          if point:\n              radius = rs.CurveRadius(obj, point)\n              print(\"Radius of curvature:{}\".format(radius))\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    point = rhutil.coerce3dpoint(test_point, True)\n    rc, t = curve.ClosestPoint(point, 0.0)\n    if not rc: return scriptcontext.errorhandler()\n    v = curve.CurvatureAt( t )\n    k = v.Length\n    if k>Rhino.RhinoMath.ZeroTolerance: return 1/k\n    return scriptcontext.errorhandler()\n\n\ndef CurveSeam(curve_id, parameter):\n    \"\"\"Adjusts the seam, or start/end, point of a closed curve.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): The parameter of the new start/end point.\n                  Note, if successful, the resulting curve's\n                  domain will start at `parameter`.\n    Returns:\n      bool: True or False indicating success or failure.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select closed curve\", rs.filter.curve)\n      if rs.IsCurveClosed(obj):\n          domain = rs.CurveDomain(obj)\n          parameter = (domain[0] + domain[1])/2.0\n          rs.CurveSeam( obj, parameter )\n    See Also:\n      IsCurve\n      IsCurveClosed\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if (not curve.IsClosed or not curve.Domain.IncludesParameter(parameter)):\n        return False\n    dupe = curve.Duplicate()\n    if dupe:\n        dupe.ChangeClosedCurveSeam(parameter)\n        curve_id = rhutil.coerceguid(curve_id)\n        dupe_obj = scriptcontext.doc.Objects.Replace(curve_id, dupe)\n        return dupe_obj is not None\n    return False\n\n\ndef CurveStartPoint(curve_id, segment_index=-1, point=None):\n    \"\"\"Returns the start point of a curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n      point (point, optional): new start point\n    Returns:\n      point: The 3D starting point of the curve if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          point = rs.CurveStartPoint(object)\n          rs.AddPoint(point)\n    See Also:\n      CurveEndPoint\n      CurveMidPoint\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc = curve.PointAtStart\n    if point:\n        point = rhutil.coerce3dpoint(point, True)\n        if point and curve.SetStartPoint(point):\n            curve_id = rhutil.coerceguid(curve_id, True)\n            scriptcontext.doc.Objects.Replace(curve_id, curve)\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef CurveSurfaceIntersection(curve_id, surface_id, tolerance=-1, angle_tolerance=-1):\n    \"\"\"Calculates intersection of a curve object with a surface object.\n    Note, this function works on the untrimmed portion of the surface.\n    Parameters:\n      curve_id (guid): The identifier of the first curve object.\n      surface_id (guid): The identifier of the second curve object. If omitted,\n          the a self-intersection test will be performed on curve.\n      tolerance (number, optional): The absolute tolerance in drawing units. If omitted,\n          the document's current absolute tolerance is used.\n      angle_tolerance (number, optional) angle tolerance in degrees. The angle\n          tolerance is used to determine when the curve is tangent to the\n          surface. If omitted, the document's current angle tolerance is used.\n    Returns:\n      list(list(point, point, point, point, number, number, number, number, number, number), ...): of intersection information if successful.\n      The list will contain one or more of the following elements:\n        Element Type     Description\n        [n][0]  Number   The intersection event type, either Point(1) or Overlap(2).\n        [n][1]  Point3d  If the event type is Point(1), then the intersection point\n                         on the first curve. If the event type is Overlap(2), then\n                         intersection start point on the first curve.\n        [n][2]  Point3d  If the event type is Point(1), then the intersection point\n                         on the first curve. If the event type is Overlap(2), then\n                         intersection end point on the first curve.\n        [n][3]  Point3d  If the event type is Point(1), then the intersection point\n                         on the second curve. If the event type is Overlap(2), then\n                         intersection start point on the surface.\n        [n][4]  Point3d  If the event type is Point(1), then the intersection point\n                         on the second curve. If the event type is Overlap(2), then\n                         intersection end point on the surface.\n        [n][5]  Number   If the event type is Point(1), then the first curve parameter.\n                         If the event type is Overlap(2), then the start value of the\n                         first curve parameter range.\n        [n][6]  Number   If the event type is Point(1), then the first curve parameter.\n                         If the event type is Overlap(2), then the end value of the\n                         curve parameter range.\n        [n][7]  Number   If the event type is Point(1), then the U surface parameter.\n                         If the event type is Overlap(2), then the U surface parameter\n                         for curve at (n, 5).\n        [n][8]  Number   If the event type is Point(1), then the V surface parameter.\n                         If the event type is Overlap(2), then the V surface parameter\n                         for curve at (n, 5).\n        [n][9]  Number   If the event type is Point(1), then the U surface parameter.\n                         If the event type is Overlap(2), then the U surface parameter\n                         for curve at (n, 6).\n        [n][10] Number   If the event type is Point(1), then the V surface parameter.\n                         If the event type is Overlap(2), then the V surface parameter\n                         for curve at (n, 6).\n    Example:\n      import rhinoscriptsyntax as rs\n      def csx():\n          curve = rs.GetObject(\"Select curve\", rs.filter.curve)\n          if curve is None: return\n          surface = rs.GetObject(\"Select surface\", rs.filter.surface)\n          if surface is None: return\n          intersection_list = rs.CurveSurfaceIntersection(curve, surface)\n          if intersection_list is None:\n              print(\"Curve and surface do not intersect.\")\n              return\n          for intersection in intersection_list:\n              if intersection[0]==1:\n                  print(\"Point\")\n                  print(\"Intersection point on curve:{}\".format(intersection[1]))\n                  print(\"Intersection point on surface:{}\".format(intersection[3]))\n                  print(\"Curve parameter:{}\".format(intersection[5]))\n                  print(\"Surface parameter: {}, {}\".format(intersection[7], intersection[8]))\n              else:\n                  print(\"Overlap\")\n                  print(\"Intersection start point on curve:{}\".format(intersection[1]))\n                  print(\"Intersection end point on curve:{}\".format(intersection[2]))\n                  print(\"Intersection start point on surface:{}\".format(intersection[3]))\n                  print(\"Intersection end point on surface:{}\".format(intersection[4]))\n                  print(\"Curve parameter range: {} to {}\".format(intersection[5], intersection[6]))\n                  print(\"Surface parameter range: {}, {} to {}, {}\".format(intersection[7] intersection[8], intersection[9], intersection[10]))\n      csx()\n    See Also:\n      CurveCurveIntersection\n      CurveBrepIntersect\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    surface = rhutil.coercesurface(surface_id, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if angle_tolerance is None or angle_tolerance<0:\n        angle_tolerance = scriptcontext.doc.ModelAngleToleranceRadians\n    else:\n        angle_tolerance = math.radians(angle_tolerance)\n    rc = Rhino.Geometry.Intersect.Intersection.CurveSurface(curve, surface, tolerance, angle_tolerance)\n    if rc:\n        events = []\n        for i in compat.RANGE(rc.Count):\n            event_type = 2 if rc[i].IsOverlap else 1\n            item = rc[i]\n            oa = item.OverlapA\n            u,v = item.SurfaceOverlapParameter()\n            e = (event_type, item.PointA, item.PointA2, item.PointB, item.PointB2, oa[0], oa[1], u[0], u[1], v[0], v[1])\n            events.append(e)\n        return events\n\n\ndef CurveTangent(curve_id, parameter, segment_index=-1):\n    \"\"\"Returns a 3D vector that is the tangent to a curve at a parameter.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number) parameter to evaluate\n      segment_index (number, optional) the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      vector: A 3D vector if successful.\n      None: on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if obj:\n          point = rs.GetPointOnCurve(obj)\n          if point:\n              param = rs.CurveClosestPoint(obj, point)\n              normal = rs.CurveTangent(obj, param)\n              print(normal)\n    See Also:\n      CurveClosestPoint\n      CurveDomain\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc = Rhino.Geometry.Point3d.Unset\n    if curve.Domain.IncludesParameter(parameter):\n        return curve.TangentAt(parameter)\n    return scriptcontext.errorhandler()\n\n\ndef CurveWeights(curve_id, segment_index=-1):\n    \"\"\"Returns list of weights that are assigned to the control points of a curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The weight values of the curve if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          weights = rs.CurveWeights(obj)\n          if weights:\n              for weight in weights:\n                  print(\"Curve control point weight value:{}\".format(weight))\n    See Also:\n      CurveKnots\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve\n    if type(curve) is not Rhino.Geometry.NurbsCurve:\n        nc = curve.ToNurbsCurve()\n    if nc is None: return scriptcontext.errorhandler()\n    return [pt.Weight for pt in nc.Points]\n\n\ndef DivideCurve(curve_id, segments, create_points=False, return_points=True):\n    \"\"\"Divides a curve object into a specified number of segments.\n    Parameters:\n      curve_id (guid):identifier of the curve object\n      segments (number): The number of segments.\n      create_points (bool, optional): Create the division points. If omitted or False,\n          points are not created.\n      return_points (bool, optional): If omitted or True, points are returned.\n          If False, then a list of curve parameters are returned.\n    Returns:\n      list(point|number, ...): If `return_points` is not specified or True, then a list containing 3D division points.\n      list(point|number, ...): If `return_points` is False, then an array containing division curve parameters.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if obj:\n          points = rs.DivideCurve(obj, 4)\n          for point in points: rs.AddPoint(point)\n    See Also:\n      DivideCurveEquidistant\n      DivideCurveLength\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc = curve.DivideByCount(segments, True)\n    if not rc: return scriptcontext.errorhandler()\n    if return_points or create_points:\n        outputpoints = [curve.PointAt(t) for t in rc]\n        if return_points: rc = outputpoints\n        if create_points:\n            for point in outputpoints:\n                if point.IsValid: scriptcontext.doc.Objects.AddPoint(point)\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef DivideCurveEquidistant(curve_id, distance, create_points=False, return_points=True):\n    \"\"\"Divides a curve such that the linear distance between the points is equal.\n    Parameters:\n      curve_id (guid): the object's identifier\n      distance (number): linear distance between division points\n      create_points (bool, optional): create the division points if True.\n      return_points (bool, optional): If True, return a list of points.\n                                      If False, return a list of curve parameters\n    Returns:\n      list(point|number, ...): points or curve parameters based on the value of return_points\n      none on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if obj:\n          points = rs.DivideCurveEquidistant(obj, 4, True)\n    See Also:\n      DivideCurve\n      DivideCurveLength\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    points = curve.DivideEquidistant(distance)\n    if not points: return scriptcontext.errorhandler()\n    if create_points:\n        for point in points: scriptcontext.doc.Objects.AddPoint(point)\n        scriptcontext.doc.Views.Redraw()\n    if return_points: return points\n    tvals = []\n    for point in points:\n        rc, t = curve.ClosestPoint(point)\n        tvals.append(t)\n    return tvals\n\n\ndef DivideCurveLength(curve_id, length, create_points=False, return_points=True):\n    \"\"\"Divides a curve object into segments of a specified length.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      length (number): The length of each segment.\n      create_points (bool, optional): Create the division points. If omitted or False,\n          points are not created.\n      return_points (bool, optional): If omitted or True, points are returned.\n          If False, then a list of curve parameters are returned.\n    Returns:\n      list(point, ...): If return_points is not specified or True, then a list containing division points.\n      list(number, ...): If return_points is False, then an array containing division curve parameters.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          length = rs.CurveLength(obj) / 4\n          points = rs.DivideCurveLength(obj, length)\n          for point in points: rs.AddPoint(point)\n    See Also:\n      DivideCurve\n      DivideCurveEquidistant\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc = curve.DivideByLength(length, True)\n    if not rc: return scriptcontext.errorhandler()\n    if return_points or create_points:\n        outputpoints = [curve.PointAt(t) for t in rc]\n        if create_points:\n            for point in outputpoints:\n                if (point.IsValid): scriptcontext.doc.Objects.AddPoint(point)\n        if return_points: rc = outputpoints\n    return rc\n\n\ndef EllipseCenterPoint(curve_id):\n    \"\"\"Returns the center point of an elliptical-shaped curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n    Returns:\n      point: The 3D center point of the ellipse if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select ellipse\")\n      if rs.IsEllipse(obj):\n          point = rs.EllipseCenterPoint(obj)\n          rs.AddPoint( point )\n    See Also:\n      IsEllipse\n      EllipseQuadPoints\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc, ellipse = curve.TryGetEllipse()\n    if not rc: raise ValueError(\"curve is not an ellipse\")\n    return ellipse.Plane.Origin\n\n\ndef EllipseQuadPoints(curve_id):\n    \"\"\"Returns the quadrant points of an elliptical-shaped curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n    Returns:\n      list(point, point, point, point): Four points identifying the quadrants of the ellipse\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select ellipse\")\n      if rs.IsEllipse(obj):\n          rs.AddPoints( rs.EllipseQuadPoints(obj) )\n    See Also:\n      IsEllipse\n      EllipseCenterPoint\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc, ellipse = curve.TryGetEllipse()\n    if not rc: raise ValueError(\"curve is not an ellipse\")\n    origin = ellipse.Plane.Origin;\n    xaxis = ellipse.Radius1 * ellipse.Plane.XAxis;\n    yaxis = ellipse.Radius2 * ellipse.Plane.YAxis;\n    return (origin-xaxis, origin+xaxis, origin-yaxis, origin+yaxis)\n\n\ndef EvaluateCurve(curve_id, t, segment_index=-1):\n    \"\"\"Evaluates a curve at a parameter and returns a 3D point\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      t (number): the parameter to evaluate\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: a 3-D point if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          domain = rs.CurveDomain(obj)\n          t = domain[1]/2.0\n          point = rs.EvaluateCurve(obj, t)\n          rs.AddPoint( point )\n    See Also:\n      CurveClosestPoint\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.PointAt(t)\n\n\ndef ExplodeCurves(curve_ids, delete_input=False):\n    \"\"\"Explodes, or un-joins, one curves. Polycurves will be exploded into curve\n    segments. Polylines will be exploded into line segments. ExplodeCurves will\n    return the curves in topological order. \n    Parameters:\n      curve_ids (guid): the curve object(s) to explode.\n      delete_input (bool, optional): Delete input objects after exploding if True.\n    Returns:\n      list(guid, ...): identifying the newly created curve objects\n    Example:\n      import rhinoscriptsyntax as rs\n      crv = rs.GetObject(\"Select curve to explode\", rs.filter.curve)\n      if rs.IsCurve(crv): rs.ExplodeCurves(crv)\n    See Also:\n      IsCurve\n      IsPolyCurve\n      IsPolyline\n      JoinCurves\n    \"\"\"\n    if( type(curve_ids) is list or type(curve_ids) is tuple ): pass\n    else: curve_ids = [curve_ids]\n    rc = []\n    for id in curve_ids:\n        curve = rhutil.coercecurve(id, -1, True)\n        pieces = curve.DuplicateSegments()\n        if pieces:\n            for piece in pieces:\n                rc.append(scriptcontext.doc.Objects.AddCurve(piece))\n            if delete_input:\n                id = rhutil.coerceguid(id, True)\n                scriptcontext.doc.Objects.Delete(id, True)\n    if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ExtendCurve(curve_id, extension_type, side, boundary_object_ids):\n    \"\"\"Extends a non-closed curve object by a line, arc, or smooth extension\n    until it intersects a collection of objects.\n    Parameters:\n      curve_id (guid): identifier of curve to extend\n      extension_type (number):\n        0 = line\n        1 = arc\n        2 = smooth\n      side (number):\n        0=extend from the start of the curve\n        1=extend from the end of the curve\n        2=extend from both the start and the end of the curve\n      boundary_object_ids (guid): curve, surface, and polysurface objects to extend to\n    Returns:\n      guid: The identifier of the new object if successful.\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      filter = rs.filter.curve | rs.filter.surface | rs.filter.polysurface\n      objects = rs.GetObjects(\"Select boundary objects\", filter)\n      if objects:\n          curve = rs.GetObject(\"Select curve to extend\", rs.filter.curve)\n          if curve: rs.ExtendCurve( curve, 2, 1, objects )\n    See Also:\n      ExtendCurveLength\n      ExtendCurvePoint\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if extension_type==0: extension_type = Rhino.Geometry.CurveExtensionStyle.Line\n    elif extension_type==1: extension_type = Rhino.Geometry.CurveExtensionStyle.Arc\n    elif extension_type==2: extension_type = Rhino.Geometry.CurveExtensionStyle.Smooth\n    else: raise ValueError(\"extension_type must be 0, 1, or 2\")\n    \n    if side==0: side = Rhino.Geometry.CurveEnd.Start\n    elif side==1: side = Rhino.Geometry.CurveEnd.End\n    elif side==2: side = Rhino.Geometry.CurveEnd.Both\n    else: raise ValueError(\"side must be 0, 1, or 2\")\n    \n    rhobjs = [rhutil.coercerhinoobject(id) for id in boundary_object_ids]\n    if not rhobjs: raise ValueError(\"boundary_object_ids must contain at least one item\")\n    geometry = [obj.Geometry for obj in rhobjs]\n    newcurve = curve.Extend(side, extension_type, geometry)\n    if newcurve and newcurve.IsValid:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        if scriptcontext.doc.Objects.Replace(curve_id, newcurve):\n            scriptcontext.doc.Views.Redraw()\n            return curve_id\n    return scriptcontext.errorhandler()\n\n\ndef ExtendCurveLength(curve_id, extension_type, side, length):\n    \"\"\"Extends a non-closed curve by a line, arc, or smooth extension for a\n    specified distance\n    Parameters:\n      curve_id (guid): curve to extend\n      extension_type (number):\n        0 = line\n        1 = arc\n        2 = smooth\n      side (number):\n        0=extend from start of the curve\n        1=extend from end of the curve\n        2=Extend from both ends\n      length (number): distance to extend\n    Returns:\n      guid: The identifier of the new object\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select curve to extend\", rs.filter.curve)\n      if curve:\n          length = rs.GetReal(\"Length to extend\", 3.0)\n          if length: rs.ExtendCurveLength( curve, 2, 2, length )\n    See Also:\n      ExtendCurve\n      ExtendCurvePoint\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if extension_type==0: extension_type = Rhino.Geometry.CurveExtensionStyle.Line\n    elif extension_type==1: extension_type = Rhino.Geometry.CurveExtensionStyle.Arc\n    elif extension_type==2: extension_type = Rhino.Geometry.CurveExtensionStyle.Smooth\n    else: raise ValueError(\"extension_type must be 0, 1, or 2\")\n    \n    if side==0: side = Rhino.Geometry.CurveEnd.Start\n    elif side==1: side = Rhino.Geometry.CurveEnd.End\n    elif side==2: side = Rhino.Geometry.CurveEnd.Both\n    else: raise ValueError(\"side must be 0, 1, or 2\")\n    newcurve = None\n    if length<0: newcurve = curve.Trim(side, -length)\n    else: newcurve = curve.Extend(side, length, extension_type)\n    if newcurve and newcurve.IsValid:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        if scriptcontext.doc.Objects.Replace(curve_id, newcurve):\n            scriptcontext.doc.Views.Redraw()\n            return curve_id\n    return scriptcontext.errorhandler()\n\n\ndef ExtendCurvePoint(curve_id, side, point, extension_type=2):\n    \"\"\"Extends a non-closed curve by smooth extension to a point\n    Parameters:\n      curve_id (guid): curve to extend\n      side (number):\n        0=extend from start of the curve\n        1=extend from end of the curve\n      point (guid|point): point to extend to\n      extension_type (number, optional): type of extension\n        0 = Line\n        1 = Arc\n        2 = Smooth\n    Returns:\n      guid: The identifier of the new object if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select curve to extend\", rs.filter.curve)\n      if curve:\n          point = rs.GetPoint(\"Point to extend to\")\n          if point: rs.ExtendCurvePoint(curve, 1, point)\n    See Also:\n      ExtendCurve\n      ExtendCurveLength\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    point = rhutil.coerce3dpoint(point, True)\n    \n    if side==0: side = Rhino.Geometry.CurveEnd.Start\n    elif side==1: side = Rhino.Geometry.CurveEnd.End\n    elif side==2: side = Rhino.Geometry.CurveEnd.Both\n    else: raise ValueError(\"side must be 0, 1, or 2\")\n    \n    if extension_type==0: extension_type = Rhino.Geometry.CurveExtensionStyle.Line\n    elif extension_type==1: extension_type = Rhino.Geometry.CurveExtensionStyle.Arc\n    elif extension_type==2: extension_type = Rhino.Geometry.CurveExtensionStyle.Smooth\n    else: raise ValueError(\"extension_type must be 0, 1, or 2\")\n    \n    newcurve = curve.Extend(side, extension_type, point)\n    if newcurve and newcurve.IsValid:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        if scriptcontext.doc.Objects.Replace( curve_id, newcurve ):\n            scriptcontext.doc.Views.Redraw()\n            return curve_id\n    return scriptcontext.errorhandler()\n\n\ndef FairCurve(curve_id, tolerance=1.0):\n    \"\"\"Fairs a curve. Fair works best on degree 3 (cubic) curves. Fair attempts\n    to remove large curvature variations while limiting the geometry changes to\n    be no more than the specified tolerance. Sometimes several applications of\n    this method are necessary to remove nasty curvature problems.\n    Parameters:\n      curve_id (guid): curve to fair\n      tolerance (number, optional): fairing tolerance\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      curves = rs.GetObjects(\"Select curves to fair\", rs.filter.curve)\n      if curves:\n          [rs.FairCurve(curve) for curve in curves]\n    See Also:\n      \n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    angle_tol = 0.0\n    clamp = 0\n    if curve.IsPeriodic:\n        curve = curve.ToNurbsCurve()\n        clamp = 1\n    newcurve = curve.Fair(tolerance, angle_tol, clamp, clamp, 100)\n    if not newcurve: return False\n    curve_id = rhutil.coerceguid(curve_id, True)\n    if scriptcontext.doc.Objects.Replace(curve_id, newcurve):\n        scriptcontext.doc.Views.Redraw()\n        return True\n    return False\n\n\ndef FitCurve(curve_id, degree=3, distance_tolerance=-1, angle_tolerance=-1):\n    \"\"\"Reduces number of curve control points while maintaining the curve's same\n    general shape. Use this function for replacing curves with many control\n    points. For more information, see the Rhino help for the FitCrv command.\n    Parameters:\n      curve_id (guid): Identifier of the curve object\n      degree (number, optional): The curve degree, which must be greater than 1.\n                     The default is 3.\n      distance_tolerance (number, optional): The fitting tolerance. If distance_tolerance\n          is not specified or <= 0.0, the document absolute tolerance is used.\n      angle_tolerance (number, optional): The kink smoothing tolerance in degrees. If\n          angle_tolerance is 0.0, all kinks are smoothed. If angle_tolerance\n          is > 0.0, kinks smaller than angle_tolerance are smoothed. If\n          angle_tolerance is not specified or < 0.0, the document angle\n          tolerance is used for the kink smoothing.\n    Returns:\n      guid: The identifier of the new object\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      oldCurve = rs.GetObject(\"Select curve to fit\", rs.filter.curve)\n      if oldCurve:\n          newCurve = rs.FitCurve(oldCurve)\n          if newCurve: rs.DeleteObject(oldCurve)\n    See Also:\n      \n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if distance_tolerance is None or distance_tolerance<0:\n        distance_tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if angle_tolerance is None or angle_tolerance<0:\n        angle_tolerance = scriptcontext.doc.ModelAngleToleranceRadians\n    nc = curve.Fit(degree, distance_tolerance, angle_tolerance)\n    if nc:\n        rhobj = rhutil.coercerhinoobject(curve_id)\n        rc = None\n        if rhobj:\n            rc = scriptcontext.doc.Objects.AddCurve(nc, rhobj.Attributes)\n        else:\n            rc = scriptcontext.doc.Objects.AddCurve(nc)\n        if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n        scriptcontext.doc.Views.Redraw()\n        return rc\n    return scriptcontext.errorhandler()\n\n\ndef InsertCurveKnot(curve_id, parameter, symmetrical=False ):\n    \"\"\"Inserts a knot into a curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): parameter on the curve\n      symmetrical (bool, optional): if True, then knots are added on both sides of\n          the center of the curve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve for knot insertion\", rs.filter.curve)\n      if obj:\n          point = rs.GetPointOnCurve(obj, \"Point on curve to add knot\")\n          if point:\n              parameter = rs.CurveClosestPoint(obj, point)\n              rs.InsertCurveKnot( obj, parameter )\n    See Also:\n      CurveKnotCount\n      CurveKnots\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if not curve.Domain.IncludesParameter(parameter): return False\n    nc = curve.ToNurbsCurve()\n    if not nc: return False\n    rc, t = curve.GetNurbsFormParameterFromCurveParameter(parameter)\n    if rc:\n        rc = nc.Knots.InsertKnot(t,1)\n        if rc and symmetrical:\n            domain = nc.Domain\n            t_sym = domain.T1 - t + domain.T0\n            if abs(t_sym)>Rhino.RhinoMath.SqrtEpsilon:\n                rc = nc.Knots.InsertKnot(t_sym,1)\n        if rc:\n            curve_id = rhutil.coerceguid(curve_id)\n            rc = scriptcontext.doc.Objects.Replace(curve_id, nc)\n            if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef IsArc(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is an open arc curve\n    Parameters:\n      curve_id (guid): Identifier of the curve object\n      segment_index (number): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select an arc\")\n      if rs.IsArc(obj):\n          print(\"The object is an arc.\")\n      else:\n          print(\"The object is not an arc.\")\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcCenterPoint\n      ArcMidPoint\n      ArcRadius\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.IsArc() and not curve.IsClosed\n\n\ndef IsCircle(curve_id, tolerance=None):\n    \"\"\"Verifies an object is a circle curve\n    Parameters:\n      curve_id (guid): Identifier of the curve object\n      tolerance (number, optional) If the curve is not a circle, then the tolerance used\n        to determine whether or not the NURBS form of the curve has the\n        properties of a circle. If omitted, Rhino's internal zero tolerance is used\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a circle\")\n      if rs.IsCircle(obj):\n          print(\"The object is a circle.\")\n      else:\n          print(\"The object is not a circle.\")\n    See Also:\n      AddCircle\n      AddCircle3Pt\n      CircleCenterPoint\n      CircleCircumference\n      CircleRadius\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if tolerance is None or tolerance < 0:\n        tolerance = Rhino.RhinoMath.ZeroTolerance\n    return curve.IsCircle(tolerance)\n\n\ndef IsCurve(object_id):\n    \"\"\"Verifies an object is a curve\n    Parameters:\n      object_id (guid): the object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          print(\"The object is a curve.\")\n      else:\n          print(\"The object is not a curve.\")\n    See Also:\n      IsCurveClosed\n      IsCurveLinear\n      IsCurvePeriodic\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(object_id)\n    return curve is not None\n\n\ndef IsCurveClosable(curve_id, tolerance=None):\n    \"\"\"Decide if it makes sense to close off the curve by moving the end point\n    to the start point based on start-end gap size and length of curve as\n    approximated by chord defined by 6 points\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      tolerance[opt] = maximum allowable distance between start point and end\n        point. If omitted, the document's current absolute tolerance is used\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      crv = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if not rs.IsCurveClosed(crv) and rs.IsCurveClosable(crv):\n          rs.CloseCurve( crv, 0.1 )\n    See Also:\n      CloseCurve\n      IsCurveClosed\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if tolerance is None: tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    return curve.IsClosable(tolerance)\n\n\ndef IsCurveClosed(object_id):\n    \"\"\"Verifies an object is a closed curve object\n    Parameters:\n      object_id (guid): the object's identifier\n    Returns:\n      bool: True if successful otherwise False.  None on error\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          if rs.IsCurveClosed(oObject):\n              print(\"The object is a closed curve.\")\n          else:\n              print(\"The object is not a closed curve.\")\n      else:\n          print(\"The object is not a curve.\")\n    See Also:\n      IsCurve\n      IsCurveLinear\n      IsCurvePeriodic\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(object_id)\n    return None if not curve else curve.IsClosed\n\n\ndef IsCurveInPlane(object_id, plane=None):\n    \"\"\"Test a curve to see if it lies in a specific plane\n    Parameters:\n      object_id (guid): the object's identifier\n      plane (plane, optional): plane to test. If omitted, the active construction plane is used\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj) and rs.IsCurvePlanar(obj):\n          if rs.IsCurveInPlane(obj):\n              print(\"The curve lies in the current cplane.\")\n          else:\n              print(\"The curve does not lie in the current cplane.\")\n      else:\n          print(\"The object is not a planar curve.\")\n    See Also:\n      IsCurve\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, -1, True)\n    if not plane:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    else:\n        plane = rhutil.coerceplane(plane, True)\n    return curve.IsInPlane(plane, scriptcontext.doc.ModelAbsoluteTolerance)\n\n\ndef IsCurveLinear(object_id, segment_index=-1):\n    \"\"\"Verifies an object is a linear curve\n    Parameters:\n      curve_id (guid):identifier of the curve object\n      segment_index (number): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(id):\n          if rs.IsCurveLinear(id):\n              print(\"The object is a linear curve.\")\n          else:\n              print(\"The object is not a linear curve.\")\n      else:\n          print(\"The object is not a curve.\")\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurvePeriodic\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return curve.IsLinear()\n\n\ndef IsCurvePeriodic(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a periodic curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          if rs.IsCurvePeriodic(obj):\n              print(\"The object is a periodic curve.\")\n          else:\n              print(\"The object is not a periodic curve.\")\n      else:\n          print(\"The object is not a curve.\")\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurveLinear\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.IsPeriodic\n\n\ndef IsCurvePlanar(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a planar curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          if rs.IsCurvePlanar(obj):\n              print(\"The object is a planar curve.\")\n          else:\n              print(\"The object is not a planar curve.\")\n      else:\n          print(\"The object is not a curve.\")\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurveLinear\n      IsCurvePeriodic\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    return curve.IsPlanar(tol)\n\n\ndef IsCurveRational(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a rational NURBS curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          if rs.IsCurveRational(obj):\n              print(\"The object is a rational NURBS curve.\")\n          else:\n              print(\"The object is not a rational NURBS curve.\")\n      else:\n          print(\"The object is not a curve.\")\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurveLinear\n      IsCurvePeriodic\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    if isinstance(curve, Rhino.Geometry.NurbsCurve): return curve.IsRational\n    return False\n\n\ndef IsEllipse(object_id, segment_index=-1):\n    \"\"\"Verifies an object is an elliptical-shaped curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select an ellipse\")\n      if rs.IsEllipse(obj):\n          print(\"The object is an ellipse.\")\n      else:\n          print(\"The object is not an ellipse.\")\n    See Also:\n      EllipseCenterPoint\n      EllipseQuadPoints\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return curve.IsEllipse()\n\n\ndef IsLine(object_id, segment_index=-1):\n    \"\"\"Verifies an object is a line curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a line\")\n      if rs.IsLine(obj):\n          print(\"The object is a line.\")\n      else:\n          print(\"The object is not a line.\")\n    See Also:\n      AddLine\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    if isinstance(curve, Rhino.Geometry.LineCurve): return True\n    rc, polyline = curve.TryGetPolyline()\n    if rc and polyline.Count==2: return True\n    return False\n\n\ndef IsPointOnCurve(object_id, point, segment_index=-1):\n    \"\"\"Verifies that a point is on a curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      point (point): the test point\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          point = rs.GetPoint(\"Pick a test point\")\n          if point:\n              if rs.IsPointOnCurve(obj, point):\n                  print(\"The point is on the curve\")\n              else:\n                  print(\"The point is not on the curve\")\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    point = rhutil.coerce3dpoint(point, True)\n    rc, t = curve.ClosestPoint(point, Rhino.RhinoMath.SqrtEpsilon)\n    return rc\n\n\ndef IsPolyCurve(object_id, segment_index=-1):\n    \"\"\"Verifies an object is a PolyCurve curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional) the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polycurve\")\n      if rs.IsPolyCurve(obj):\n          print(\"The object is a polycurve.\")\n      else:\n          print(\"The object is not a polycurve.\")\n    See Also:\n      PolyCurveCount\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return isinstance(curve, Rhino.Geometry.PolyCurve)\n\n\ndef IsPolyline( object_id, segment_index=-1 ):\n    \"\"\"Verifies an object is a Polyline curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polyline\")\n      if rs.IsPolyline(obj):\n          print(\"The object is a polyline.\")\n      else:\n          print(\"The object is not a polyline.\")\n    See Also:\n      IsPolyline\n      PolylineVertices\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return isinstance(curve, Rhino.Geometry.PolylineCurve)\n\n\ndef JoinCurves(object_ids, delete_input=False, tolerance=None):\n    \"\"\"Joins multiple curves together to form one or more curves or polycurves\n    Parameters:\n      object_ids (guid): list of multiple curves\n      delete_input (bool, optional): delete input objects after joining\n      tolerance (number, optional): join tolerance. If omitted, 2.1 * document absolute\n          tolerance is used\n    Returns:\n      list(guid, ...): Object id representing the new curves\n    Example:\n      import rhinoscriptsyntax as rs\n      objs = rs.GetObjects(\"Select curves to join\", rs.filter.curve)\n      if objs: rs.JoinCurves(objs)\n    See Also:\n      ExplodeCurves\n      IsCurve\n      IsCurveClosed\n    \"\"\"\n    if len(object_ids)<2: raise ValueError(\"object_ids must contain at least 2 items\")\n    curves = [rhutil.coercecurve(id, -1, True) for id in object_ids]\n    if tolerance is None:\n        tolerance = 2.1 * scriptcontext.doc.ModelAbsoluteTolerance\n    newcurves = Rhino.Geometry.Curve.JoinCurves(curves, tolerance)\n    rc = []\n    if newcurves:\n        rc = [scriptcontext.doc.Objects.AddCurve(crv) for crv in newcurves]\n    if rc and delete_input:\n        for id in object_ids:\n            id = rhutil.coerceguid(id, True)\n            scriptcontext.doc.Objects.Delete(id, False)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef LineFitFromPoints(points):\n    \"\"\"Returns a line that was fit through an array of 3D points\n    Parameters:\n      points ([point, point, ...]): a list of at least two 3D points\n    Returns:\n      line: line on success\n    Example:\n      import rhinoscriptsyntax as rs\n      points = rs.GetPoints()\n      if points and len(points)>1:\n          line=rs.LineFitFromPoints(points)\n          if line: rs.AddLine(line.From, line.To)\n    See Also:\n      AddLine\n      CurveEndPoint\n      CurveStartPoint\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    rc, line = Rhino.Geometry.Line.TryFitLineToPoints(points)\n    if rc: return line\n    return scriptcontext.errorhandler()\n\n\ndef MakeCurveNonPeriodic(curve_id, delete_input=False):\n    \"\"\"Makes a periodic curve non-periodic. Non-periodic curves can develop\n    kinks when deformed\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      delete_input (bool): delete the input curve. If omitted, the input curve will not be deleted.\n    Returns:\n      guid: id of the new or modified curve if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.IsCurvePeriodic(curve): rs.MakeCurveNonPeriodic( curve )\n    See Also:\n      IsCurvePeriodic\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if not curve.IsPeriodic: return scriptcontext.errorhandler()\n    nc = curve.ToNurbsCurve()\n    if nc is None: return scriptcontext.errorhandler()\n    nc.Knots.ClampEnd( Rhino.Geometry.CurveEnd.Both )\n    rc = None\n    if delete_input:\n        if type(curve_id) is Rhino.DocObjects.ObjRef: pass\n        else: curve_id = rhutil.coerceguid(curve_id)\n        if curve_id:\n            rc = scriptcontext.doc.Objects.Replace(curve_id, nc)\n            if not rc: return scriptcontext.errorhandler()\n            rc = rhutil.coerceguid(curve_id)\n    else:\n        attrs = None\n        if type(scriptcontext.doc) is Rhino.RhinoDoc:\n            rhobj = rhutil.coercerhinoobject(curve_id)\n            if rhobj: attrs = rhobj.Attributes\n        rc = scriptcontext.doc.Objects.AddCurve(nc, attrs)\n        if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef MeanCurve(curve0, curve1, tolerance=None):\n    \"\"\"Creates an average curve from two curves\n    Parameters:\n      curve0, curve1 (guid): identifiers of two curves\n      tolerance (number, optional): angle tolerance used to match kinks between curves\n    Returns:\n      guid: id of the new or modified curve if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve0 = rs.GetObject(\"Select the first curve\", rs.filter.curve)\n      curve1 = rs.GetObject(\"Select the second curve\", rs.filter.curve)\n      rs.MeanCurve( curve0, curve1 )\n    See Also:\n      UnitAngleTolerance\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve0, -1, True)\n    curve1 = rhutil.coercecurve(curve1, -1, True)\n    if tolerance is None: tolerance=Rhino.RhinoMath.UnsetValue\n    crv = Rhino.Geometry.Curve.CreateMeanCurve(curve0,curve1,tolerance)\n    if crv:\n        rc = scriptcontext.doc.Objects.AddCurve(crv)\n        scriptcontext.doc.Views.Redraw()\n        return rc\n\n\ndef MeshPolyline(polyline_id):\n    \"\"\"Creates a polygon mesh object based on a closed polyline curve object.\n    The created mesh object is added to the document\n    Parameters:\n      polyline_id (guid): identifier of the polyline curve object\n    Returns:\n      guid: identifier of the new mesh object\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      polyline = rs.GetObject(\"Select a polyline\", rs.filter.curve)\n      if polyline:\n          if rs.IsPolyline(polyline) and rs.IsCurveClosed(polyline):\n              rs.MeshPolyline( polyline )\n    See Also:\n      IsCurveClosed\n      IsPolyline\n    \"\"\"\n    curve = rhutil.coercecurve(polyline_id, -1, True)\n    ispolyline, polyline = curve.TryGetPolyline()\n    if not ispolyline: return scriptcontext.errorhandler()\n    mesh = Rhino.Geometry.Mesh.CreateFromClosedPolyline(polyline)\n    if not mesh: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddMesh(mesh)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef OffsetCurve(object_id, direction, distance, normal=None, style=1):\n    \"\"\"Offsets a curve by a distance. The offset curve will be added to Rhino\n    Parameters:\n      object_id (guid): identifier of a curve object\n      direction (point): point describing direction of the offset\n      distance (number): distance of the offset\n      normal (vector, optional): normal of the plane in which the offset will occur.\n          If omitted, the normal of the active construction plane will be used\n      style (number, optional): the corner style. If omitted, the style is sharp.\n                                0 = None\n                                1 = Sharp\n                                2 = Round\n                                3 = Smooth\n                                4 = Chamfer\n    Returns:\n      list(guid, ...): list of ids for the new curves on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.IsCurve(obj):\n          rs.OffsetCurve( obj, [0,0,0], 1.0 )\n    See Also:\n      OffsetCurveOnSurface\n      OffsetSurface\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, -1, True)\n    direction = rhutil.coerce3dpoint(direction, True)\n    if normal:\n        normal = rhutil.coerce3dvector(normal, True)\n    else:\n        normal = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane().Normal\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    style = System.Enum.ToObject(Rhino.Geometry.CurveOffsetCornerStyle, style)\n    curves = curve.Offset(direction, normal, distance, tolerance, style)\n    if curves is None: return scriptcontext.errorhandler()\n    rc = [scriptcontext.doc.Objects.AddCurve(curve) for curve in curves]\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef OffsetCurveOnSurface(curve_id, surface_id, distance_or_parameter):\n    \"\"\"Offset a curve on a surface. The source curve must lie on the surface.\n    The offset curve or curves will be added to Rhino\n    Parameters:\n      curve_id, surface_id (guid): curve and surface identifiers\n      distance_or_parameter (number|tuple(number, number)): If a single number is passed, then this is the\n        distance of the offset. Based on the curve's direction, a positive value\n        will offset to the left and a negative value will offset to the right.\n        If a tuple of two values is passed, this is interpreted as the surface\n        U,V parameter that the curve will be offset through\n    Returns:\n      list(guid, ...): identifiers of the new curves if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      def TestOffset():\n          curve = rs.GetObject(\"Select curve on a surface\", rs.filter.curve)\n          if curve is None: return False\n          surface = rs.GetObject(\"Select base surface\", rs.filter.surface)\n          if surface is None: return False\n          point = rs.GetPointOnSurface( surface, \"Through point\" )\n          if point is None: return False\n          parameter = rs.SurfaceClosestPoint(surface, point)\n          rc = rs.OffsetCurveOnSurface( curve, surface, parameter )\n          return rc is not None\n       \n      TestOffset()\n    See Also:\n      OffsetCurve\n      OffsetSurface\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    surface = rhutil.coercesurface(surface_id, True)\n    x = None\n    if type(distance_or_parameter) is list or type(distance_or_parameter) is tuple:\n        x = Rhino.Geometry.Point2d( distance_or_parameter[0], distance_or_parameter[1] )\n    else:\n        x = float(distance_or_parameter)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    curves = curve.OffsetOnSurface(surface, x, tol)\n    if curves is None: return scriptcontext.errorhandler()\n    curves = [curve.ExtendOnSurface(Rhino.Geometry.CurveEnd.Both, surface) for curve in curves]\n    rc = [scriptcontext.doc.Objects.AddCurve(curve) for curve in curves]\n    if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef PlanarClosedCurveContainment(curve_a, curve_b, plane=None, tolerance=None):\n    \"\"\"Determines the relationship between the regions bounded by two coplanar\n    simple closed curves\n    Parameters:\n      curve_a, curve_b (guid): identifiers of two planar, closed curves\n      plane (plane, optional): test plane. If omitted, the currently active construction\n        plane is used\n      tolerance (number, optional): if omitted, the document absolute tolerance is used\n    Returns:\n      number: a number identifying the relationship if successful\n        0 = the regions bounded by the curves are disjoint\n        1 = the two curves intersect\n        2 = the region bounded by curve_a is inside of curve_b\n        3 = the region bounded by curve_b is inside of curve_a\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      curve1 = rs.GetObject(\"Select first curve\", rs.filter.curve )\n      curve2 = rs.GetObject(\"Select second curve\", rs.filter.curve )\n      if rs.IsCurvePlanar(curve1) and rs.IsCurvePlanar(curve2):\n          if rs.IsCurveClosed(curve1) and rs.IsCurveClosed(curve2):\n              if rs.IsCurveInPlane(curve1) and rs.IsCurveInPlane(curve2):\n                  result = rs.PlanarClosedCurveContainment(curve1, curve2)\n                  if result==0: print(\"The regions bounded by the curves are disjoint.\")\n                  elif result==1: print(\"The two curves intersect..\")\n                  elif result==2: print(\"The region bounded by Curve1 is inside of Curve2.\")\n                  else: print(\"The region bounded by Curve2 is inside of Curve1.\")\n    See Also:\n      PlanarCurveCollision\n      PointInPlanarClosedCurve\n    \"\"\"\n    curve_a = rhutil.coercecurve(curve_a, -1, True)\n    curve_b = rhutil.coercecurve(curve_b, -1, True)\n    if tolerance is None or tolerance<=0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if plane:\n        plane = rhutil.coerceplane(plane)\n    else:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    rc = Rhino.Geometry.Curve.PlanarClosedCurveRelationship(curve_a, curve_b, plane, tolerance)\n    return int(rc)\n\n\ndef PlanarCurveCollision(curve_a, curve_b, plane=None, tolerance=None):\n    \"\"\"Determines if two coplanar curves intersect\n    Parameters:\n      curve_a, curve_b (guid): identifiers of two planar curves\n      plane (plane, optional): test plane. If omitted, the currently active construction\n        plane is used\n      tolerance (number, optional): if omitted, the document absolute tolerance is used\n    Returns:\n      bool: True if the curves intersect; otherwise False\n    Example:\n      import rhinoscriptsyntax as rs\n      curve1 = rs.GetObject(\"Select first curve\")\n      curve2 = rs.GetObject(\"Select second curve\")\n      if( rs.IsCurvePlanar(curve1) and rs.IsCurvePlanar(curve2) and rs.IsCurveInPlane(curve1) and rs.IsCurveInPlane(curve2) ):\n          if rs.PlanarCurveCollision(curve1, curve2):\n              print(\"The coplanar curves intersect.\")\n          else:\n              print(\"The coplanar curves do not intersect.\")\n    See Also:\n      CurveCurveIntersection\n      PlanarClosedCurveContainment\n      PointInPlanarClosedCurve\n    \"\"\"\n    curve_a = rhutil.coercecurve(curve_a, -1, True)\n    curve_b = rhutil.coercecurve(curve_b, -1, True)\n    if tolerance is None or tolerance<=0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if plane:\n        plane = rhutil.coerceplane(plane)\n    else:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    return Rhino.Geometry.Curve.PlanarCurveCollision(curve_a, curve_b, plane, tolerance)\n\n\ndef PointInPlanarClosedCurve(point, curve, plane=None, tolerance=None):\n    \"\"\"Determines if a point is inside of a closed curve, on a closed curve, or\n    outside of a closed curve\n    Parameters:\n      point (point|guid): text point\n      curve (guid): identifier of a curve object\n      plane (plane, optional): plane containing the closed curve and point. If omitted,\n          the currently active construction plane is used\n      tolerance (number, optional) it omitted, the document abosulte tolerance is used\n    Returns:\n      number: number identifying the result if successful\n              0 = point is outside of the curve\n              1 = point is inside of the curve\n              2 = point in on the curve\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a planar, closed curve\", rs.filter.curve)\n      if rs.IsCurveClosed(curve) and rs.IsCurvePlanar(curve):\n          point = rs.GetPoint(\"Pick a point\")\n          if point:\n              result = rs.PointInPlanarClosedCurve(point, curve)\n              if result==0: print(\"The point is outside of the closed curve.\")\n              elif result==1: print(\"The point is inside of the closed curve.\")\n              else: print(\"The point is on the closed curve.\")\n    See Also:\n      PlanarClosedCurveContainment\n      PlanarCurveCollision\n    \"\"\"\n    point = rhutil.coerce3dpoint(point, True)\n    curve = rhutil.coercecurve(curve, -1, True)\n    if tolerance is None or tolerance<=0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if plane:\n        plane = rhutil.coerceplane(plane)\n    else:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    rc = curve.Contains(point, plane, tolerance)\n    if rc==Rhino.Geometry.PointContainment.Unset: raise Exception(\"Curve.Contains returned Unset\")\n    if rc==Rhino.Geometry.PointContainment.Outside: return 0\n    if rc==Rhino.Geometry.PointContainment.Inside: return 1\n    return 2\n\n\ndef PolyCurveCount(curve_id, segment_index=-1):\n    \"\"\"Returns the number of curve segments that make up a polycurve\n    Parameters:\n      curve_id (guid): the object's identifier\n      segment_index (number, optional): if `curve_id` identifies a polycurve object, then `segment_index` identifies the curve segment of the polycurve to query.\n    Returns:\n      number: the number of curve segments in a polycurve if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polycurve\")\n      if rs.IsPolyCurve(obj):\n          count = rs.PolyCurveCount(obj)\n          if count: print(\"The polycurve contains {} curves\".format(count))\n    See Also:\n      IsPolyCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    if isinstance(curve, Rhino.Geometry.PolyCurve): return curve.SegmentCount\n    raise ValueError(\"curve_id does not reference a polycurve\")\n\n\ndef PolylineVertices(curve_id, segment_index=-1):\n    \"\"\"Returns the vertices of a polyline curve on success\n    Parameters:\n      curve_id (guid): the object's identifier\n      segment_index (number, optional): if curve_id identifies a polycurve object, then segment_index identifies the curve segment of the polycurve to query.\n    Returns:\n      list(point, ...): an list of Point3d vertex points if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polyline\")\n      if rs.IsPolyline(obj):\n          points = rs.PolylineVertices(obj)\n          if points:\n              for point in points: rs.AddPoint(point)\n    See Also:\n      AddPolyline\n      IsPolyline\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, polyline = curve.TryGetPolyline()\n    if rc: return [pt for pt in polyline]\n    raise ValueError(\"curve_id does not reference a polyline\")\n\n\ndef ProjectCurveToMesh(curve_ids, mesh_ids, direction):\n    \"\"\"Projects one or more curves onto one or more surfaces or meshes\n    Parameters:\n      curve_ids ([guid, ...]): identifiers of curves to project\n      mesh_ids ([guid, ...]): identifiers of meshes to project onto\n      direction (vector): projection direction\n    Returns:\n      list(guid, ...): list of identifiers for the resulting curves.\n    Example:\n      import rhinoscriptsyntax as rs\n      mesh = rs.GetObject(\"Select mesh to project onto\", rs.filter.mesh)\n      curve= rs.GetObject(\"Select curve to project\", rs.filter.curve)\n      #Project down...\n      results = rs.ProjectCurveToMesh(curve, mesh, (0,0,-1))\n    See Also:\n      ProjectCurveToSurface\n      ProjectPointToMesh\n      ProjectPointToSurface\n    \"\"\"\n    curve_ids = rhutil.coerceguidlist(curve_ids)\n    mesh_ids = rhutil.coerceguidlist(mesh_ids)\n    direction = rhutil.coerce3dvector(direction, True)\n    curves = [rhutil.coercecurve(id, -1, True) for id in curve_ids]\n    meshes = [rhutil.coercemesh(id, True) for id in mesh_ids]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newcurves = Rhino.Geometry.Curve.ProjectToMesh(curves, meshes, direction, tolerance)\n    ids = [scriptcontext.doc.Objects.AddCurve(curve) for curve in newcurves]\n    if ids: scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef ProjectCurveToSurface(curve_ids, surface_ids, direction):\n    \"\"\"Projects one or more curves onto one or more surfaces or polysurfaces\n    Parameters:\n      curve_ids ([guid, ...]): identifiers of curves to project\n      surface_ids ([guid, ...]): identifiers of surfaces to project onto\n      direction (vector): projection direction\n    Returns:\n      list(guid, ...): list of identifiers\n    Example:\n      import rhinoscriptsyntax as rs\n      surface = rs.GetObject(\"Select surface to project onto\", rs.filter.surface)\n      curve = rs.GetObject(\"Select curve to project\", rs.filter.curve)\n      # Project down...\n      results = rs.ProjectCurveToSurface(curve, surface, (0,0,-1))\n    See Also:\n      ProjectCurveToMesh\n      ProjectPointToMesh\n      ProjectPointToSurface\n    \"\"\"\n    curve_ids = rhutil.coerceguidlist(curve_ids)\n    surface_ids = rhutil.coerceguidlist(surface_ids)\n    direction = rhutil.coerce3dvector(direction, True)\n    curves = [rhutil.coercecurve(id, -1, True) for id in curve_ids]\n    breps = [rhutil.coercebrep(id, True) for id in surface_ids]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newcurves = Rhino.Geometry.Curve.ProjectToBrep(curves, breps, direction, tolerance)\n    ids = [scriptcontext.doc.Objects.AddCurve(curve) for curve in newcurves]\n    if ids: scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef RebuildCurve(curve_id, degree=3, point_count=10):\n    \"\"\"Rebuilds a curve to a given degree and control point count. For more\n    information, see the Rhino help for the Rebuild command.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      degree (number, optional): new degree (must be greater than 0)\n      point_count (number, optional) new point count, which must be bigger than degree.\n    Returns:\n      bool: True of False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select curve to rebuild\", rs.filter.curve)\n      if curve: rs.RebuildCurve(curve, 3, 10)\n    See Also:\n      RebuildSurface\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if degree<1: raise ValueError(\"degree must be greater than 0\")\n    newcurve = curve.Rebuild(point_count, degree, False)\n    if not newcurve: return False\n    scriptcontext.doc.Objects.Replace(curve_id, newcurve)\n    scriptcontext.doc.Views.Redraw()\n    return True\n\n\ndef RemoveCurveKnot(curve, parameter):\n    \"\"\"Deletes a knot from a curve object.\n    Parameters:\n      curve (guid): The reference of the source object\n      parameter (number): The parameter on the curve. Note, if the parameter is not equal to one\n                      of the existing knots, then the knot closest to the specified parameter\n                      will be removed.\n    Returns:\n      bool: True of False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n\n      crv_info = rs.GetCurveObject(\"Select curve near knot to be removed\")\n      if crv_info:\n          crv_id = crv_info[0]\n          crv_param = crv_info[4]\n          rs.RemoveCurveKnot(crv_id, crv_param)\n    See Also:\n      RemoveSurfaceKnot\n    \"\"\"\n    curve_inst = rhutil.coercecurve(curve, -1, True)\n    success, n_param = curve_inst.GetCurveParameterFromNurbsFormParameter(parameter)\n    if not success: return False\n    n_curve = curve_inst.ToNurbsCurve()\n    if not n_curve: return False\n    success = n_curve.Knots.RemoveKnotAt(n_param)\n    if not success: return False\n    scriptcontext.doc.Objects.Replace(curve, n_curve)\n    scriptcontext.doc.Views.Redraw()\n    return True\n\n\ndef ReverseCurve(curve_id):\n    \"\"\"Reverses the direction of a curve object. Same as Rhino's Dir command\n    Parameters:\n      curve_id (guid): identifier of the curve object\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve to reverse\")\n      if rs.IsCurve(curve): rs.ReverseCurve(curve)\n    See Also:\n      CurveDirectionsMatch\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if curve.Reverse():\n        curve_id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Replace(curve_id, curve)\n        return True\n    return False\n\n\ndef SimplifyCurve(curve_id, flags=0):\n    \"\"\"Replace a curve with a geometrically equivalent polycurve.\n    \n    The polycurve will have the following properties:\n     - All the polycurve segments are lines, polylines, arcs, or NURBS curves.\n     - The NURBS curves segments do not have fully multiple interior knots.\n     - Rational NURBS curves do not have constant weights.\n     - Any segment for which IsCurveLinear or IsArc is True is a line, polyline segment, or an arc.\n     - Adjacent co-linear or co-circular segments are combined.\n     - Segments that meet with G1-continuity have there ends tuned up so that they meet with G1-continuity to within machine precision.\n     - If the polycurve is a polyline, a polyline will be created\n\n\n    Parameters:\n      curve_id (guid): the object's identifier\n      flags (number, optional): the simplification methods to use. By default, all methods are used (flags = 0)\n        Value Description\n        0     Use all methods.\n        1     Do not split NURBS curves at fully multiple knots.\n        2     Do not replace segments with IsCurveLinear = True with line curves.\n        4     Do not replace segments with IsArc = True with arc curves.\n        8     Do not replace rational NURBS curves with constant denominator with an equivalent non-rational NURBS curve.\n        16    Do not adjust curves at G1-joins.\n        32    Do not merge adjacent co-linear lines or co-circular arcs or combine consecutive line segments into a polyline.\n\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve to simplify\", rs.filter.curve)\n      if curve: rs.SimplifyCurve(curve)\n    See Also:\n      IsArc\n      IsCurveLinear\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    _flags = Rhino.Geometry.CurveSimplifyOptions.All\n    if( flags&1 ==1 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.SplitAtFullyMultipleKnots)\n    if( flags&2 ==2 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.RebuildLines)\n    if( flags&4 ==4 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.RebuildArcs)\n    if( flags&8 ==8 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.RebuildRationals)\n    if( flags&16==16 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.AdjustG1)\n    if( flags&32==32 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.Merge)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    ang_tol = scriptcontext.doc.ModelAngleToleranceRadians\n    newcurve = curve.Simplify(_flags, tol, ang_tol)\n    if newcurve:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Replace(curve_id, newcurve)\n        scriptcontext.doc.Views.Redraw()\n        return True\n    return False\n\n\ndef SplitCurve(curve_id, parameter, delete_input=True):\n    \"\"\"Splits, or divides, a curve at a specified parameter. The parameter must\n    be in the interior of the curve's domain\n    Parameters:\n      curve_id (guid): the curve to split\n      parameter ({number, ...]) one or more parameters to split the curve at\n      delete_input (bool, optional): delete the input curve\n    Returns:\n      list(guid, ....): list of new curves on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve to split\", rs.filter.curve)\n      if rs.IsCurve(curve):\n          domain = rs.CurveDomain(curve)\n          parameter = domain[1] / 2.0\n          rs.SplitCurve( curve, parameter )\n    See Also:\n      TrimCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    newcurves = curve.Split(parameter)\n    if newcurves is None: return scriptcontext.errorhandler()\n    att = None\n    rhobj = rhutil.coercerhinoobject(curve_id)\n    if rhobj: att = rhobj.Attributes\n    rc = [scriptcontext.doc.Objects.AddCurve(crv, att) for crv in newcurves]\n    if rc and delete_input:\n        id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef TrimCurve(curve_id, interval, delete_input=True):\n    \"\"\"Trims a curve by removing portions of the curve outside a specified interval\n    Parameters:\n      curve_id (guid):the curve to trim\n      interval ([number, number]): two numbers identifying the interval to keep. Portions of\n        the curve before domain[0] and after domain[1] will be removed. If the\n        input curve is open, the interval must be increasing. If the input\n        curve is closed and the interval is decreasing, then the portion of\n        the curve across the start and end of the curve is returned\n      delete_input (bool): delete the input curve. If omitted the input curve is deleted.\n    Returns:\n      list(guid, ...): identifier of the new curve on success\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve to trim\", rs.filter.curve)\n      if rs.IsCurve(curve):\n          domain = rs.CurveDomain(curve)\n          domain[1] /= 2.0\n          rs.TrimCurve( curve, domain )\n    See Also:\n      SplitCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if interval[0]==interval[1]: raise ValueError(\"interval values are equal\")\n    newcurve = curve.Trim(interval[0], interval[1])\n    if not newcurve: return scriptcontext.errorhandler()\n    att = None\n    rhobj = rhutil.coercerhinoobject(curve_id)\n    if rhobj: att = rhobj.Attributes\n    rc = scriptcontext.doc.Objects.AddCurve(newcurve, att)\n    if delete_input:\n        id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ChangeCurveDegree(object_id, degree):\n    \"\"\"Changes the degree of a curve object. For more information see the Rhino help file for the ChangeDegree command.\n      Parameters:\n        object_id (guid): the object's identifier.\n        degree (number): the new degree.\n      Returns:\n        bool: True of False indicating success or failure.\n        None: on failure\n      Example:\n    \n      See Also:\n        IsCurve\n        CurveDegree\n    \"\"\" \n    curve = rhutil.coercerhinoobject(object_id)\n    if not curve: return None\n    if not isinstance(curve, Rhino.DocObjects.CurveObject): return None\n\n    curve = curve.CurveGeometry\n    if not isinstance(curve, Rhino.Geometry.NurbsCurve):\n        curve = curve.ToNurbsCurve()\n\n    max_nurbs_degree = 11\n    if degree < 1 or degree > max_nurbs_degree or curve.Degree == degree:\n        return None\n\n    r = False\n    if curve.IncreaseDegree(degree):\n        r = scriptcontext.doc.Objects.Replace(object_id, curve)\n    return r\n\n\ndef AddTweenCurves(from_curve_id, to_curve_id, number_of_curves = 1, method = 0, sample_number = 10):\n    \"\"\"Creates curves between two open or closed input curves.\n    Parameters:\n      from_curve_id (guid): identifier of the first curve object.\n      to_curve_id (guid): identifier of the second curve object.\n      number_of_curves (number): The number of curves to create. The default is 1.\n      method (number): The method for refining the output curves, where:\n        0: (Default) Uses the control points of the curves for matching. So the first control point of first curve is matched to first control point of the second curve.\n        1: Refits the output curves like using the FitCurve method.  Both the input curve and the output curve will have the same structure. The resulting curves are usually more complex than input unless input curves are compatible.\n        2: Input curves are divided to the specified number of points on the curve, corresponding points define new points that output curves go through. If you are making one tween curve, the method essentially does the following: divides the two curves into an equal number of points, finds the midpoint between the corresponding points on the curves, and interpolates the tween curve through those points.\n      sample_number (number): The number of samples points to use if method is 2. The default is 10.\n    Returns:\n      list(guid, ...): The identifiers of the new tween objects if successful, None on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curveA = rs.GetObject(\"Select first curve\", rs.filter.curve)\n      curveB = rs.GetObject(\"Select second curve\", rs.filter.curve)\n      arrResult = rs.AddTweenCurves(curveA, curveB, 6, 2, 30)\n    \"\"\"\n    curve0 = rhutil.coercecurve(from_curve_id, -1, True)\n    curve1 = rhutil.coercecurve(to_curve_id, -1, True)\n    out_curves = 0\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if method == 0:\n        out_curves = Rhino.Geometry.Curve.CreateTweenCurves(curve0, curve1, number_of_curves, tolerance)\n    elif method == 1:\n        out_curves = Rhino.Geometry.Curve.CreateTweenCurvesWithMatching(curve0, curve1, number_of_curves, tolerance)\n    elif method == 2:\n        out_curves = Rhino.Geometry.Curve.CreateTweenCurvesWithSampling(curve0, curve1, number_of_curves, sample_number, tolerance)\n    else: raise ValueError(\"method must be 0, 1, or 2\")\n    curves = None\n    if out_curves:\n        curves = []\n        for curve in out_curves:\n            if curve and curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n            curve.Dispose()\n            if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n            curves.append(rc)\n        scriptcontext.doc.Views.Redraw()\n    return curves\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "brep", "line", "dimension", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "jingcheng-chen_rhinomcp_e2f442bdc5.json", "repo": "jingcheng-chen/rhinomcp"}
{"instruction": "better names?", "code": "from rhino_unwrapper import visualization as vis\nfrom rhino_unwrapper import rhino_helpers as helpers\nfrom rhino_unwrapper import transformations as trans\nreload(vis)\nreload(helpers)\nreload(trans)\n\nimport scriptcontext\nimport rhinoscriptsyntax as rs\nimport Rhino.Geometry as geom\nimport System\nimport clr\n\ndef make_test_mesh():\n    '''\n    returns an instance of myMesh and adds the rhinoMesh to the document\n    '''\n    vertices = []\n    vertices.append((0.0,0.0,0.0))\n    vertices.append((5.0, 0.0, 0.0))\n    vertices.append((10.0, 0.0, 0.0))\n    vertices.append((0.0, 5.0, 0.0))\n    vertices.append((5.0, 5.0, 0.0))\n    vertices.append((10.0, 5.0, 0.0))\n    vertices.append((0.0, 10.0, 0.0))\n    vertices.append((5.0, 10.0, 0.0))\n    vertices.append((10.0, 10.0, 0.0))\n    faceVertices = []\n    faceVertices.append((0,1,4,4))\n    faceVertices.append((2,4,1,1))\n    faceVertices.append((0,4,3,3))\n    faceVertices.append((2,5,4,4))\n    faceVertices.append((3,4,6,6))\n    faceVertices.append((5,8,4,4))\n    faceVertices.append((6,4,7,7))\n    faceVertices.append((8,7,4,4))\n    return get_myMesh(vertices,faceVertices)\n\ndef make_upright_mesh():\n    verts = []\n    verts.append((0.0,0.0,0.0))\n    verts.append((5.0,0.0,0.0))\n    verts.append((5.0,0.0,5.0))\n    verts.append((0.0,0.0,5.0))\n    face_verts = []\n    face_verts.append((0,1,3,3))\n    face_verts.append((1,2,3,3))\n    return get_myMesh(verts,face_verts)\n\ndef make_cube_mesh():\n    vertices = []\n    vertices.append((0.0,0.0,0.0)) #0\n    vertices.append((5.0,0.0,0.0)) #1\n    vertices.append((5.0,5.0,0.0)) #2\n    vertices.append((0.0,5.0,0.0)) #3\n    vertices.append((0.0,0.0,5.0)) #4\n    vertices.append((5.0,0.0,5.0)) #5\n    vertices.append((5.0,5.0,5.0)) #6\n    vertices.append((0.0,5.0,5.0)) #7\n    faceVertices = []\n    faceVertices.append((3,2,1,0)) #bottom face\n    faceVertices.append((4,5,6,7)) #top face\n    faceVertices.append((0,1,5,4)) #front face\n    faceVertices.append((4,7,3,0)) #left face\n    faceVertices.append((1,2,6,5)) #right face\n    faceVertices.append((2,3,7,6)) #back face\n    return get_myMesh(vertices,faceVertices)\n\ndef get_myMesh(vertices,face_vertices):\n    '''add a mesh to doc and get the Rhino.Geometry.Mesh object''' \n    mesh_GUID = rs.AddMesh( vertices, face_vertices )\n    obj = scriptcontext.doc.Objects.Find(mesh_GUID)\n    return Mesh(obj.Geometry)\n\n#NOTE: even more hierarchical:\n# Mesh.\n#     .elements\n#     .display\n#     .select\n#     .unfold <=!?\n\n#NOTE: what if did something like:\n# Mesh.\n#     .vertexQuiery\n#     .edgeQuiery\n#     .faceQuiery\n#     .special\n\n#or mabe:\n# mesh.Vertices\n# mesh.Edges\n# mesh.Faces\n# mesh.Special\n# ex: mesh.Vertices.get_\n# ex: mesh.Speical.get_frame_asdfsdf()\n\nclass Mesh(object): \n    \"\"\"\n    better names?\n    MeshQuieryer\n    MeshFinder\n    MeshElementFinder\n    MeshElementGetter\n    PythonMesh\n    MyMesh\n\n    Does custom queiries on a Rhino mesh that make layout easy\n    see http://4.rhino3d.com/5/rhinocommon/ for rhino mesh class members\n    - queries\n    - visualizing info\n    \"\"\"\n\n    def __init__(self,mesh):\n        self.mesh = mesh\n        #NOTE: the below line seems to wipe the UserDictionary for later access\n        #self.mesh.FaceNormals.ComputeFaceNormals()\n        self.cut_key = 'cuts'\n        if not self.mesh.UserDictionary.ContainsKey(self.cut_key):\n            self.set_cuts([])\n\n    ### GENERAL\n\n    def edge_indices(self):\n        pass\n\n    def face_indices(self):\n        return range(self.mesh.Faces.Count)\n\n    def get_set_of_edges(self):\n        count = self.mesh.TopologyEdges.Count\n        return set(range(count))\n\n    def get_set_of_face_idxs(self):\n        return set(self.face_indices())\n\n    def get_mesh_faces(self):\n        \"\"\"\n        returns list of MeshFace instances that make up mesh\n        \"\"\"\n        return (self.mesh.Faces.GetFace(i) for i in xrange(self.mesh.Faces.Count))\n\n    def meshTVerts(self):\n        return xrange(self.mesh.TopologyVertices.Count)\n\n    ### SPECIAL, ie requires more than one extra index\n\n    def get_frame_oriented_with_face_normal(self,edge,face):\n        '''\n        an edge and a face (meshLoc) imply a unique frame, \n        since the edge can be oriented according the the face's normal (right hand rule)\n        '''\n        face_edges = self.getFaceEdges(face)\n        assert (edge in face_edges), \"edge {} not in face {}\".format(edge,face)\n        basePoint,endPoint = self.get_oriented_points_for_edge(edge,face)\n        normal = self.get_face_normal(face)\n        xVec = helpers.getVectorForPoints(basePoint,endPoint)\n        return trans.Frame.create_frame_from_normal_and_x(basePoint,normal,xVec)\n\n    def getOtherFaceIdx(self,edgeIdx, faceIdx):\n        connectedFaces = self.getFacesForEdge(edgeIdx)\n        assert(faceIdx in connectedFaces), \"faceIdx not in faces associated with edge\"\n\n        if len(connectedFaces) != 2:\n            # This is a naked edge\n            #print(\"did not find two connected faces for edgeIdx %i, \" %(edgeIdx))\n            return None\n\n        newFaceIdx = None\n        if (connectedFaces[0] == faceIdx):\n            newFaceIdx = connectedFaces[1]\n        elif (connectedFaces[1] == faceIdx):\n            newFaceIdx = connectedFaces[0]\n        else:\n            print \"problem in getOtherFaceIdx: edgeIdx not in faceIdx,assert should have caught error\"\n            return None\n\n        assert(newFaceIdx != faceIdx), \"getOtherFaceIdx(): newFaceIdx == faceIdx!\"\n        return newFaceIdx\n\n    ### QUIRED OBJECT IS VERTEX\n\n    def get_point_for_tVert(self,tVert):\n        '''\n        Note: convertes Point3f to Point3d!\n        '''\n        return geom.Point3d(self.mesh.TopologyVertices.Item[tVert])\n\n    def get_point3f_for_tVert(self,vert):\n        return self.mesh.TopologyVertices.Item[vert]\n\n    def getTVertsForVert(self,tVert):\n        arrTVerts = self.mesh.TopologyVertices.ConnectedTopologyVertices(tVert)\n        listVerts = vis.convertArray(arrTVerts)\n        if tVert in listVerts:\n            listVerts = listVerts.remove(tVert)\n        return listVerts\n\n    def getEdgesForVert(self,tVert):\n        # not implimented in rhinoCommon! ::::(\n        # rather inefficient\n        neighVerts = self.getTVertsForVert(tVert)\n        facesVert = set(self.getFacesForVert(tVert))\n        edges = []\n        for neighVert in neighVerts:\n\n            edge = self.get_edge_for_vert_pair(tVert, neighVert)\n            if edge:\n                edges.append(edge)\n        return edges\n\n    def get_edge_for_vert_pair(self,vertA,vertB):\n        return self.mesh.TopologyEdges.GetEdgeIndex(vertA,vertB)\n\n    def getEdgeForTVertPair(self,tVertA, tVertB, facesVertA=None):\n        ''' Depricated, use get_edge_for_vert_pair() '''\n        if facesVertA is None:\n            facesVertA = self.getFacesForVert(tVertA)\n        facesVertB = set(self.getFacesForVert(tVertB))\n        facePair = list(facesVertA.intersection(facesVertB))\n        if len(facePair) == 2:\n            edgesA = set(self.getFaceEdges(facePair[0]))\n            edgesB = set(self.getFaceEdges(facePair[1]))\n            edge = edgesA.intersection(edgesB)\n            if len(edge) == 0:\n                print \"probably encountered naked edge in chain selection\"\n                return\n            return list(edge)[0]\n        elif len(facePair) == 1:\n            # naked edge\n            edges = self.getFaceEdges(facePair[0], self.mesh)\n            for edge in edges:\n                tVerts = self.getTVertsForEdge(edge)\n                if tVertB in tVerts and tVertA in tVerts:\n                    return edge\n        return      \n\n    def getFacesForVert(self,tVert):\n        arrfaces = self.mesh.TopologyVertices.ConnectedFaces(tVert)\n        return vis.convertArray(arrfaces)\n    \n    def getOtherTVert(self,edge, tVert):\n        tVerts = self.getTVertsForEdge(edge)\n        tVerts.remove(tVert)\n        return tVerts[0]\n\n    ### SPECIAL EDGE\n    def get_aligned_points(self,orientedEdge):\n        '''\n        get points ordered according to orientation \n        '''\n        edge, aligned_with_face = orientedEdge\n        points = self.getPointsForEdge(edge)\n        if not aligned_with_face:\n            points.reverse()\n        return points\n\n    ### STUFF FOR LAYOUT\n\n    def set_cuts(self,cutList):\n        edges = self.get_set_of_edges()\n        assert (edges.issuperset(set(cutList))), \"cutList {} was not a subset of mesh edges\".format(cutList)\n        did_set = self.mesh.UserDictionary.Set(self.cut_key, System.Array[int](cutList))\n        return did_set\n\n    def get_cuts(self):\n        return list(self.mesh.UserDictionary[self.cut_key])\n\n    def is_cut_edge(self,edge):\n        return edge in self.get_cuts()\n\n    def is_fold_edge(self,edge):\n        return edge not in self.get_cuts() and not self.is_naked_edge(edge)\n\n    def is_naked_edge(self,edge):\n        faces = self.getFacesForEdge(edge)\n        nFaces = len(faces)\n        assert (nFaces >0), \"did not get any faces for edge {}\".format(edge)\n        if nFaces== 1:\n            return True\n        return False\n\n    ### Main OBJECT IS EDGE\n\n    def getTangentEdge(self,edge, tVert, angleTolerance, chain):\n        '''\n        return edge that is closest in angle, or none if none\n        of the edges are within angleTolerance\n        '''\n        edges = self.getEdgesForVert( tVert)\n        if edge in edges:\n            edges.remove(edge)\n        winEdge = (None, angleTolerance)\n        for neighEdge in edges:\n            angle = self.compareEdgeAngle(edge, tVert, neighEdge)\n            if angle < angleTolerance and angle < winEdge[1]:\n                winEdge = (neighEdge, angle)\n\n        newEdge = winEdge[0]\n        if newEdge is None:\n            return chain\n        if newEdge in chain:\n            return chain\n        else:\n            chain.append(newEdge)\n            nextTVert = self.getOtherTVert( newEdge, tVert)\n            return self.getTangentEdge(newEdge, nextTVert, angleTolerance, chain)\n\n    def getChain(self,edge, angleTolerance):\n        '''\n        gets chains extending from both ends of a given edge,\n        using angleTolerance as stopping criterion\n        '''\n        chain = []\n        tVerts = self.getTVertsForEdge(edge)\n        for tVert in tVerts:\n            subChain = self.getTangentEdge(edge, tVert, angleTolerance, [])\n            chain.extend(subChain)\n        chain.append(edge)\n        return chain\n\n    def getFacesForEdge(self,edge):\n        '''\n        returns an array of indices of the faces connected to a given edge\n        if the array has only one face this indicates it is a naked edge\n        '''\n        return list(self.mesh.TopologyEdges.GetConnectedFaces(edge))\n\n    def getTVertsForEdge(self,edge):\n        vertPair = self.mesh.TopologyEdges.GetTopologyVertices(edge)\n        return [vertPair.I, vertPair.J]\n\n    def getEdgeAngle(self,edge):\n        '''\n        get dihedral angle, in radians of a given edge in the mesh\n        '''\n        faceIdxs = self.getFacesForEdge(edge)\n        if (len(faceIdxs)==2):\n            faceNormA = self.get_face_normal(faceIdxs[0])\n            faceNormB = self.get_face_normal(faceIdxs[1])\n            return geom.Vector3d.VectorAngle(faceNormA,faceNormB)\n        else:\n            return None\n\n    def getDistanceToEdge(self,edge, point):\n        '''\n        edge = Topology edgeIdx in mesh\n        point = Point3d to get distance to edge\n        '''\n        edgeLine = self.mesh.TopologyEdges.EdgeLine(edge)\n        return edgeLine.DistanceTo(point, True)\n\n    def getEdgeVector(self,edgeIdx): \n        edgeLine = self.mesh.TopologyEdges.EdgeLine(edgeIdx)\n        # Vector3d\n        vec = edgeLine.Direction\n        return vec\n    \n    def get_edge_vec_oriented(self,edgeIdx,faceIdx):\n        tVerts = self.get_oriented_TVerts_for_edge(edgeIdx,faceIdx)\n        pntA,pntB = self._get_points_for_tVerts(tVerts)\n        return helpers.getVectorForPoints(pntA,pntB)\n\n    def get_oriented_points_for_edge(self,edgIdx,faceIdx):\n        tVerts = self.get_oriented_TVerts_for_edge(edgIdx,faceIdx)\n        return self._get_points_for_tVerts(tVerts)\n\n    def _get_points_for_tVerts(self,verts):\n        points = []\n        for vert in verts:\n            points.append(self.mesh.TopologyVertices.Item[vert])\n        return points\n\n    def getPointsForEdge(self,edgeIdx):\n        tVertI, tVertJ = self.getTVertsForEdge(edgeIdx)\n        pntI = self.mesh.TopologyVertices.Item[tVertI]\n        pntJ = self.mesh.TopologyVertices.Item[tVertJ]\n        return [pntI, pntJ]\n     \n    def get_oriented_TVerts_for_edge(self,edgeIdx,faceIdx):\n        \"\"\"\n        using the right-hand rule for face normals, each edge has a specific\n        direction, given one of its ajoining faces. Returns the TVerts of that\n        edge in that order.\n        \"\"\"\n        correct_list = self.getTVertsForFace(faceIdx)\n        edge_IJ = self.getTVertsForEdge(edgeIdx)\n        assert set(edge_IJ).issubset(set(correct_list)), \\\n        \"edge {} does not belong to face {}\".format(edgeIdx,faceIdx)\n        ordered_IJ = sorted(edge_IJ,key=lambda x:correct_list.index(x))\n        if ordered_IJ[0]== correct_list[0] and ordered_IJ[-1] == correct_list[-1]:\n            ordered_IJ.reverse()\n        return ordered_IJ\n\n    def get_edge_line(self,edgeIdx):\n        return self.mesh.TopologyEdges.EdgeLine(edgeIdx)\n    \n    def getEdgeLen(self,edgIdx):\n        edgeLine = self.get_edge_line(edgeIdx)\n        return edgeLine.Length\n    \n    def get_edge_center_point(self,edgeIdx):\n        line = self.get_edge_line(edgeIdx)\n        cenX = (line.FromX + line.ToX) / 2.0\n        cenY = (line.FromY + line.ToY) / 2.0\n        cenZ = (line.FromZ + line.ToZ) / 2.0\n        point =  geom.Point3d(cenX, cenY, cenZ)\n        return point\n\n    def compareEdgeAngle(self,edge, tVert, neighEdge):\n        vecBase = self._getOrientedVector(edge, tVert, True)\n        vecCompare = self._getOrientedVector(neighEdge, tVert, False)\n        angle = geom.Vector3d.VectorAngle(vecBase, vecCompare)\n        return angle\n\n    def _getOrientedVector(self,edgeIdx, tVert, isEnd):\n        '''\n        tVert is the end point of this vector\n        '''\n        tVerts = self.getTVertsForEdge(edgeIdx)\n        assert(tVert in tVerts)\n        tVerts.remove(tVert)\n        otherVert = tVerts[0]\n        if isEnd:\n            pntB = self.mesh.TopologyVertices.Item[tVert]\n            pntA = self.mesh.TopologyVertices.Item[otherVert]\n        else:\n            pntA = self.mesh.TopologyVertices.Item[tVert]\n            pntB = self.mesh.TopologyVertices.Item[otherVert]\n        vecPnt = pntB - pntA\n        vec = geom.Vector3d(vecPnt)\n        return vec\n\n    def getEdgeLengths(self):\n        edgeLens = []\n        for i in range(self.mesh.TopologyEdges.Count):\n            edgeLine = self.mesh.TopologyEdges.EdgeLine(i)\n            edgeLen = edgeLine.Length\n            edgeLens.append(edgeLen)\n        return edgeLens\n\n    def getMedianEdgeLen(self):\n        edgeLens = self.getEdgeLengths(self.mesh)\n        return getMedian(edgeLens)\n\n    ### Main OBJECT IS FACE\n    def get_adjacent_faces(self,faceIdx):\n        return list(self.mesh.Faces.AdjacentFaces(faceIdx))\n\n    def getTVertsForFace(self,faceIdx):\n        '''\n        list of 4 values if quad, 3 values if triangle\n        '''\n        arrTVerts = self.mesh.Faces.GetTopologicalVertices(faceIdx)\n        tVerts = list(arrTVerts)\n        return helpers.uniqueList(tVerts)\n    \n    def get_points_for_face(self,faceIdx):\n        '''\n        Note: converts TopologyVertices as Point3f to Point3d\n        '''\n        tVerts = self.getTVertsForFace(faceIdx)\n        points = []\n        for tVert in tVerts:\n            points.append(geom.Point3d(self.mesh.TopologyVertices.Item[tVert]))\n        return points\n\n    def getFaceEdges(self,faceIdx):\n        arrFaceEdges = self.mesh.TopologyEdges.GetEdgesForFace(faceIdx)\n        return list(arrFaceEdges)\n\n    def get_edges_ccw_besides_base(self,baseEdge=None,face=None):\n        '''\n        get the edges for the face, except the baseEdges, ordered\n        ccw around face, startin with the edge after the baseEdge\n        '''\n        #TODO: do assertion check that baseEdge belongs to the face\n        edges,orientations = self.get_edges_and_orientation_for_face(face)\n        index = edges.index(baseEdge)\n        edges = helpers.rotate_and_remove(edges,index)\n        orientations = helpers.rotate_and_remove(orientations,index)\n        return zip(edges,orientations)\n\n    def get_edges_and_orientation_for_face(self,faceIdx):\n        orientations = clr.StrongBox[System.Array[bool]]()\n        edges =  self.mesh.TopologyEdges.GetEdgesForFace(faceIdx,orientations)\n        edges = list(edges)\n        orientations = list(orientations.Value)\n        #edges_with_orientations = zip(edges,orientations)\n        return edges,orientations\n\n    def get_edges_except(self,faceIdx,edgeIdx):\n        face_edges = self.getFaceEdges(faceIdx)\n        return face_edges.remove(edgeIdx)\n\n    def face_normal(self,face):\n        '''\n        wrap the FaceNormals.Item method to provide usefull error message\n        '''\n        face_normal_command = \"RebuildMeshNormals\"\n        assert self.mesh.FaceNormals.Count > 0, \"the FaceNormals have not been computed for this mesh. Try running {}\".format(face_normal_command)\n        return self.mesh.FaceNormals.Item[face]\n\n\n    def get_face_normal(self,face):\n        '''\n        rhinocommon returns Vector3f, but most other rhioncommon\n        stuff uses vector3d, so returns vector3d\n        '''\n        return geom.Vector3d(self.face_normal(face))\n\n    def get_naked_or_cut_edge_from_candidate_faces(self,canditate_faces):\n        assert self.get_cuts() , \"Mesh has no cuts set. Make sure to assign cuts first\"\n        for face in canditate_faces:\n            edges = self.getFaceEdges(face)\n            for edge in edges:\n                if self.is_cut_edge(edge) or self.is_naked_edge(edge):\n                    return edge,face\n        assert False, \"unable to find valid face\"\n\n    def get_face_next_to_a_cut(self): \n        cuts = self.get_cuts()\n        arbitrary_cut_edge = cuts[0]\n        faces = self.getFacesForEdge(arbitrary_cut_edge)\n        arbitrary_face = faces[0]\n        return arbitrary_face\n\nclass MeshDisplayer(object):\n\n    def __init__(self,meshElementFinder):\n        self.meshElementFinder = meshElementFinder\n\n    def displayTVertsIdx(self):\n        for vert in self.meshElementFinder.meshTVerts():\n            self.displayTVertIdx(vert)\n\n    def displayTVertIdx(self,vert, disp=None, color=(0, 255, 0, 255)):\n        if disp is None:\n           disp = vert\n        point = self.meshElementFinder.mesh.TopologyVertices.Item[vert]\n        vis.drawTextDot(point, str(disp), color)\n\n    def displayEdgesIdx(self):\n        for edge in self.meshElementFinder.get_set_of_edges():\n            self.displayEdgeIdx(edge)\n\n    def displayEdgeIdx(self,edgeIdx,color=(0,0,255,0)):\n        point = self.meshElementFinder.get_edge_center_point(edgeIdx)\n        return vis.drawTextDot(point, str(edgeIdx), color)\n\n    def displayIJEdge(self, edgeIdx):\n        pntI,pntJ = self.meshElementFinder.getPointsForEdge(edgeIdx)\n        rs.AddTextDot('I', pntI)\n        rs.AddTextDot('J', pntJ)\n\n    def displayFacesIdx(self):\n        for i,face in enumerate(self.meshElementFinder.get_set_of_face_idxs()):\n            self.displayFaceIdx(i)\n\n    def displayFaceIdx(self, face):\n        centerPnt = self.meshElementFinder.mesh.Faces.GetFaceCenter(face)\n        rs.AddTextDot(str(face), centerPnt)\n\n    def displayNormals(self):\n        normLines = []\n        for i in range(self.meshElementFinder.mesh.FaceNormals.Count):\n            pntCenter = self.meshElementFinder.mesh.Faces.GetFaceCenter(i)  # Point3d\n            posVecCenter = geom.Vector3d(pntCenter)\n            vecNormal = self.meshElementFinder.mesh.FaceNormals.Item[i]  # Vector3f\n            vecNormal.Unitize()\n            lineGuid = vis.drawVector(vecNormal, pntCenter)\n            normLines.append(lineGuid)\n\n    def display_face_vert_ordering(self,faceIdx):\n        points = self.meshElementFinder.get_points_for_face(faceIdx)\n        points.append(points[0])\n        vis.drawPolyline(points,arrowType='end')\n\n    def display_all_face_vert_ordering(self):\n        faces = self.meshElementFinder.get_set_of_face_idxs()\n        for face in faces:\n            self.display_face_vert_ordering(face)\n\n    def display_edge_direction_IJ(self,edgeIdx):\n        pnts = self.meshElementFinder.getPointsForEdge(edgeIdx)\n        vis.show_line_from_points(pnts,color=(0,0,0,255),arrowType='end')\n\n    def display_all_edges_direction_IJ(self):\n        for i in self.meshElementFinder.get_set_of_edges():\n            self.display_edge_direction_IJ(i)\n        \n    def display_edge_direction(self,edgeIdx):\n        line = self.meshElementFinder.get_edge_line(edgeIdx)\n        vis.draw_arrow(line,color=(0,255,0,255))\n\n    def display_all_edges_direction(self):\n        for edge in self.meshElementFinder.get_set_of_edges():\n            self.display_edge_direction(edge)\n\n    def display_all_elements(self):\n        self.displayFacesIdx()\n        self.displayEdgesIdx()\n        self.displayTVertsIdx()\n\n    def display_edges(self, edgeIdxs,color=(0,255,0,255)):\n        drawnEdges = {}\n        if edgeIdxs:\n            for edgeIdx in edgeIdxs:\n                points = self.meshElementFinder.getPointsForEdge(edgeIdx)\n                lineGuid, line = vis.show_line_from_points(points, color, 'none')\n                drawnEdges[edgeIdx] = lineGuid\n        return drawnEdges\n\nif __name__ == \"__main__\":\n    mesh = make_test_mesh()\n    displayer = MeshDisplayer(mesh)\n    displayer.display_all_elements()\n    for i in mesh.get_set_of_face_idxs():\n        print \"face {} has edges: {}\".format(i,mesh.getFaceEdges(i))\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "classes", "point", "layer", "line", "functions", "mesh", "RhinoCommon"], "original_file": "jlopezbi_rhinoUnfolder_d7bed443ac.json", "repo": "jlopezbi/rhinoUnfolder"}
{"instruction": "What does a net do?, slash know about?", "code": "\nimport Rhino\nimport Rhino.Geometry as geom\nimport rhinoscriptsyntax as rs\nimport math\nimport transformations as trans\nfrom UnionFind import UnionFind\n\nreload(trans)\n\n\nclass Net():\n    \"\"\" \n    What does a net do?, slash know about?\n        => it stores the mesh that is the net. In fact perhaps should just use rhino's mesh! but lets save that for later\n    Right now the net does this:\n        * Segmentation <= this is the main thing!\n            * Selection\n        * Display\n\n    Queries: (this will help determine best Data structure)\n        * for a given edge its parent face and its otherParnet face (assuming a manifold edge)\n        * for a given cut edge, its corresponding edge\n        * for a given edge, the two sets of edges/faces/verts on either side, or for a given edge, the set of edges/faces/verts on the side indicated by the user (faster)\n        non essential:\n        * for a given edge, the corrseponding edge in the 3d mesh\n    \"\"\"\n#myMesh.mesh.Faces.Count\n\n    def __init__(self, myMesh=None, holeRadius=10):\n        #NOTE: I do not see why net needs to hold onto myMesh\n        self.holeRadius = holeRadius\n        self.angleThresh = math.radians(3.3)\n        self.myMesh = myMesh\n        self.islands = []\n        self.group_island_dict = {}\n        #self.groups,self.leaders = segmentIsland(self.flatFaces,[])\n\n    def get_island_list(self):\n        return self.islands\n\n    def add_island(self,island):\n        self.islands.append(island)\n        index = len(self.islands) - 1\n        self.group_island_dict[island.group_name] = index\n\n    def get_island(self,index):\n        return self.islands[index]\n\n    def display(self):\n        for island in self.islands:\n            island.display()\n\n    def get_island_for_line(self,line_guid):\n        '''\n        CURRENTLY NOT FUNCTIONING: fix this when this becomes necessary. At the moment this function is not useful.\n        Assumes each element of the island has a group with geometry in it, and each geometry member has group0-> element level, group1 -> island level structure\n        '''\n        groups = rs.ObjectGroups(line_guid)\n        # group should be the second one\n        group_name = groups[1]\n        index = self.group_island_dict[group_name]\n        return self.islands[index]\n\n\n    '''SEGMENTATION, seems like should be a seperate thing!'''\n    #Now when segmentation happens a two new islands should be created\n    #A new challenge is finding the island that owns the line or meshEdge that the user selected!\n    #it seems like union find is not necessary when using island idea! whoa! but keep this code in case wrong\n    def segment_island(self):\n        pass\n\n    def segmentIsland(flatFaces, island):\n        sets = UnionFind(True)\n        if len(island) == 0:\n            island = range(len(flatFaces))\n        for face in island:\n            if face not in sets.leader.keys():\n                sets.makeSet([face])\n            neighbor = flatFaces[face].fromFace\n            if neighbor is not None:\n                if neighbor not in sets.leader.keys():\n                    sets.makeSet([neighbor])\n                sets.union(face, neighbor)\n        return sets.group, sets.leader\n\n    def findInitalSegments(self):\n        group, leader = self.segmentIsland(self.flatFaces, [])\n        self.groups = group\n        self.leaders = leader\n\n    def findSegment(self, flatEdgeCut, face):\n        island = self.getGroupForMember(face)\n        self.removeFaceConnection(flatEdgeCut)\n        group, leader = self.segmentIsland(self.flatFaces, island)\n        self.updateIslands(group, leader, face)\n        return group[leader[face]]\n\n    def getGroupForMember(self, member):\n        if member not in self.leaders.keys():\n            print \"face not in leaders: \",\n            print member\n            return\n        leader = self.leaders[member]\n        return self.groups[leader]\n\n    def updateIslands(self, newGroups, newLeaders, face):\n        # get rid of old island\n        leader = self.leaders[face]\n        del self.groups[leader]\n\n        for group in newGroups.items():\n            self.groups[group[0]] = group[1]\n        for leader in newLeaders.items():\n            self.leaders[leader[0]] = leader[1]\n\n    def copyAndReasign(self, dataMap, flatEdge, idx, segment, face):\n        # TODO: this must change because of change to cut/fold edge types\n        # GOT TO REWORK THIS ONE\n        newEdgeIdx = len(self.flatEdges)\n        resetEdge = fe.change_to_cut_edge(flatEdge,newEdgeIdx)\n        resetEdge.resetFromFace(face)\n        changedVertPairs = self.makeNewNetVerts(dataMap, flatEdge)\n        newEdge = self.makeNewEdge(\n            dataMap,\n            changedVertPairs,\n            flatEdge.meshEdgeIdx,\n            idx,\n            face,flatEdge.getOtherFace(face))\n        flatEdge.pair = newEdge\n        flatEdge.show_line(self.flatVerts)\n        # flatEdge.drawHoles(self,connectorDist,safetyRadius,holeRadius)\n        self.resetSegment(dataMap, changedVertPairs, segment)\n\n    def translateSegment(self, segment, xForm):\n        # TODO: make a more efficent version of this, would be easier if half-edge or\n        # winged edge mesh. H-E: could traverse edges recursively, first going to sibling h-edge\n        # Sstopping when the edge points to no other edge(naked),or to a face not in the segment,or\n        # if the h-edge is part of the user-selected edge to be cut\n        group = rs.AddGroup()\n        collection = []\n        movedNetVerts = []\n        for netEdge in self.flatEdges:\n            if netEdge.fromFace in segment:\n                collection.append(netEdge)\n                netEdge.clearAllGeom()\n                netEdge.translateGeom(movedNetVerts, self.flatVerts, xForm)\n        return collection\n\n    def redrawSegment(self, translatedEdges):\n        geom = []\n        for netEdge in translatedEdges:\n            netEdge.show_line(self.flatVerts)\n\n    def removeFaceConnection(self, flatEdgeCut):\n        faceA = flatEdgeCut.fromFace\n        faceB = flatEdgeCut.toFace\n        netFaceA = self.flatFaces[faceA]\n        netFaceB = self.flatFaces[faceB]\n        if netFaceB.fromFace == faceA:\n            netFaceB.fromFace = None\n        elif netFaceA.fromFace == faceB:\n            netFaceA.fromFace = None\n\n    def makeNewEdge(self, dataMap, changedVertPairs, meshEdge, otherEdge, fromFace,toFace):\n        newVertI = changedVertPairs[0][0]\n        newVertJ = changedVertPairs[1][0]\n        newFlatEdge = fe.CutEdge(meshEdgeIdx=meshEdge,\n                                 vertAidx=newVertI,\n                                 vertBidx=newVertJ,\n                                 fromFace=fromFace,\n                                 toFace=toFace,\n                                 sibling=otherEdge)\n        newFlatEdge.hasTab = True\n        newFlatEdge.tabFaceCenter = self.flatFaces[toFace].getCenterPoint(self.flatVerts)\n        \n        # This is where need to add a tabFaceCenter thing that will find the otherFace\n        # of the edge and find its center\n        # TODO: need to set tab angles or something. NOTE: .fromFace and\n        # .toFace of flatEdge referes to a MESH face!!\n        netEdge = self.addEdge(newFlatEdge)\n        dataMap.updateEdgeMap(meshEdge, netEdge)\n        return netEdge\n\n    def makeNewNetVerts(self, dataMap, flatEdgeCut):\n        oldNetI, oldNetJ = flatEdgeCut.getNetVerts()\n        flatI, flatJ = flatEdgeCut.getFlatVerts(self.flatVerts)\n        pointI = Rhino.Geometry.Point3d(flatI.point)  # important copy vert\n        pointJ = Rhino.Geometry.Point3d(flatJ.point)\n        newI = FlatVert(flatI.tVertIdx, pointI)\n        newJ = FlatVert(flatJ.tVertIdx, pointJ)\n        newNetI = self.addVert(newI)\n        newNetJ = self.addVert(newJ)\n        dataMap.updateVertMap(flatI.tVertIdx, newNetI)\n        dataMap.updateVertMap(flatJ.tVertIdx, newNetJ)\n        return [(newNetI, oldNetI), (newNetJ, oldNetJ)]\n\n    def resetSegment(self, dataMap, changedVertPairs, segment):\n        self.resetFaces(changedVertPairs, segment)\n        self.resetEdges(dataMap, changedVertPairs, segment)\n\n    def resetFaces(self, changedVertPairs, segment):\n        # REPLACE: this is slow hack\n        newVertI, oldVertI = changedVertPairs[0]\n        newVertJ, oldVertJ = changedVertPairs[1]\n        for face in segment:\n            verts = self.flatFaces[face].vertices\n            if oldVertI in verts:\n                index = verts.index(oldVertI)\n                verts.insert(index, newVertI)  # does order matter? yes\n                verts.pop(index + 1)\n            if oldVertJ in verts:\n                index = verts.index(oldVertJ)\n                verts.insert(index, newVertJ)  # does order matter? yes\n                verts.pop(index + 1)\n\n    def resetEdges(self, dataMap, changedVertPairs, segment):\n        '''\n        reset all edges touching the newely added vertices\n        '''\n        # REPLACE: if using he-mesh then this will be unnecessary\n        for pair in changedVertPairs:\n            newVert, oldVert = pair\n            tVert = self.flatVerts[newVert].tVertIdx\n            print \"Tvert:\",\n            print tVert\n            # in original mesh,eventually use he-mesh\n            edges = self.myMesh.getEdgesForVert(tVert)\n            for edge in edges:\n                netEdges = dataMap.getNetEdges(edge)\n                for netEdge in netEdges:\n                    flatEdge = self.getFlatEdge(netEdge)\n                    netPair = flatEdge.getNetVerts()\n                    if oldVert in netPair and flatEdge.fromFace in segment:\n                        #assert(flatEdge.fromFace in segment), \"flatEdge not in segment\"\n                        flatEdge.reset(oldVert, newVert) \n\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "classes", "point", "line", "functions", "mesh", "RhinoCommon"], "original_file": "jlopezbi_rhinoUnfolder_fcf7c27db6.json", "repo": "jlopezbi/rhinoUnfolder"}
{"instruction": "floor_area = [result for result in response_object if result['ParamName'] == 'RH_OUT:max_area'][0]['InnerTree']['{0}'][0]['data']", "code": "import pandas\n# rhino 3dm import\n# from rhino3dm import *\nimport rhino3dm as rhino3dm\nimport compute_rhino3d.Util\nimport json\nimport requests\nimport base64\n\n# Rhino compute by default launches on port 6500\ncompute_url = \"http://localhost:6500/\"\n\n# set the URL\ncompute_rhino3d.Util.url = compute_url\n# no auth token required\ncompute_rhino3d.Util.authToken = \"\"\n\n# test, should return version object\nversion_test = requests.get(compute_url + '/version')\npload = json.loads(version_test.content)\n\nprint(pload)\n\ngh_energy = open(r\"./Rhino/single_zone_energy_model_v0.1.ghx\", mode=\"r\", encoding=\"utf-8-sig\").read()\ngh_energy_bytes = gh_energy.encode(\"utf-8\")\ngh_energy_encoded = base64.b64encode(gh_energy_bytes)\ngh_energy_decoded = gh_energy_encoded.decode(\"utf-8\")\n\n\n'''\nRhino 3dm Encoder\n'''\n\nclass __Rhino3dmEncoder(json.JSONEncoder):\n    def default(self, o):\n        if hasattr(o, \"Encode\"):\n            return o.Encode()\n        return json.JSONEncoder.default(self, o)\n\ndef getCurves(objs):\n    curves = [item.Geometry for item in objs if item.Geometry.ObjectType == rhino3dm.ObjectType.Curve]\n    return json.dumps(curves, cls=__Rhino3dmEncoder)\n\ndef getBreps(objs):\n    breps = [item.Geometry for item in objs if item.Geometry.ObjectType == rhino3dm.ObjectType.Brep]\n    return list(map(lambda x: {\"type\":\"Rhino.Geometry.Brep\",\"data\":json.dumps(x, cls=__Rhino3dmEncoder)}, breps))\n\n'''\nLoad Rhino 3dm model via File3dm.Read\n'''\n\nrhino_dir = \"./Rhino/\"\nmodel_path = \"singleZone.3dm\"\ngh_path = \"geometry\"\nfile_path = rhino_dir + model_path\nprint(file_path)\n\n# read the 3dm file and encode the geometry for transit\nrhFile = rhino3dm.File3dm.Read(file_path)\nmodelBreps = getBreps(rhFile.Objects)\n\nroomGeometry = json.loads(modelBreps[0][\"data\"])\nroomGeometry = json.dumps(roomGeometry)\n\nprint('Geometry encoded ready to go!')\n\n# # Inputs\n\n# # adjust between 0 and 0.9\nroomName = \"MyPythonRoom\"\nclimateZoneNumber = 4 # mixed\nmodelName = \"MyPythonModel\"\napertureFromInput = True\nwwr = 0.5\nrunSimulation = True\n\n\n#print((roomGeometry))\n\n# payload\ngeo_payload = {\n    \"algo\": gh_energy_decoded,\n    \"pointer\": None,\n    \"values\": [\n        {\n            \"ParamName\": \"RoomGeometry\",\n            \"InnerTree\": {\n                \"{ 0; }\": [\n                    {\n                        \"type\": \"Rhino.Geometry.Brep\",\n                        \"data\": roomGeometry\n                    }\n                ]\n            }\n        },\n        {\n            \"ParamName\": \"RoomName\",\n            \"InnerTree\":{\n                \"{ 0; }\": [\n                    {\n                        \"type\": \"System.String\",\n                        \"data\": roomName\n                    }\n                ]\n            }\n        },\n        {\n            \"ParamName\": \"ClimateZoneNumber\",\n            \"InnerTree\":{\n                \"{ 0; }\": [\n                    {\n                        \"type\": \"System.Double\",\n                        \"data\": climateZoneNumber\n                    }\n                ]\n            }\n        },\n        {\n            \"ParamName\": \"ModelName\",\n            \"InnerTree\":{\n                \"{ 0; }\": [\n                    {\n                        \"type\": \"System.String\",\n                        \"data\": modelName\n                    }\n                ]\n            }\n        },\n        {\n            \"ParamName\": \"ApertureFromInput\",\n            \"InnerTree\":{\n                \"{ 0; }\": [\n                    {\n                        \"type\": \"System.Double\",\n                        \"data\": apertureFromInput\n                    }\n                ]\n            }\n        },\n        {\n            \"ParamName\": \"WWR\",\n            \"InnerTree\":{\n                \"{ 0; }\": [\n                    {\n                        \"type\": \"System.Double\",\n                        \"data\": wwr\n                    }\n                ]\n            }\n        },\n        {\n            \"ParamName\": \"RunSimulation\",\n            \"InnerTree\":{\n                \"{ 0; }\": [\n                    {\n                        \"type\": \"System.Bool\",\n                        \"data\": runSimulation\n                    }\n                ]\n            }\n        },\n    ]\n}\n\n\n\n# send HTTP request to Rhino Compute Server\nres = requests.post(compute_url + \"grasshopper\", json=geo_payload)\n\nprint(\"status code: {}\".format(res.status_code))\n\n# deserialize response object\nresponse_object = json.loads(res.content)['values']\n\nprint(len(response_object))\n#print(response_object[0])\n\ncomputed_eui = [result for result in response_object if result['ParamName'] == 'EUI'][0]['InnerTree']['{0}'][0]['data']\nprint('computed EUI: {}'.format(computed_eui))\n\n\nsql_object = [result for result in response_object if result['ParamName'] == 'sql'][0]['InnerTree']['{0}'][0]['data']\nprint(\"Computed SQL: : {}\".format(len(sql_object)))\n\n\"\"\"\nfloor_area = [result for result in response_object if result['ParamName'] == 'RH_OUT:max_area'][0]['InnerTree']['{0}'][0]['data']\nprint('max floor area: {}'.format(floor_area))\n\nfloor_area = [result for result in response_object if result['ParamName'] == 'RH_OUT:max_open'][0]['InnerTree']['{0}'][0]['data']\nprint('max open area: {}'.format(floor_area))\"\"\"", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "brep", "curve", "functions", "RhinoCommon"], "original_file": "karim-daw_RhinoCompute-EnergyModelling_938ace9e4d.json", "repo": "karim-daw/RhinoCompute-EnergyModelling"}
{"instruction": "Adds a new empty group to the document", "code": "import scriptcontext\nfrom . import utility as rhutil\n\ndef AddGroup(group_name=None):\n    \"\"\"Adds a new empty group to the document\n    Parameters:\n      group_name[opt] = name of the new group. If omitted, rhino automatically\n          generates the group name\n    Returns:\n      name of the new group if successful\n      None is not successful or on error\n    \"\"\"\n    index = -1\n    if group_name is None:\n        index = scriptcontext.doc.Groups.Add()\n    else:\n        if not isinstance(group_name, str): group_name = str(group_name)\n        index = scriptcontext.doc.Groups.Add( group_name )\n    rc = scriptcontext.doc.Groups.GroupName(index)\n    if rc is None: return scriptcontext.errorhandler()\n    return rc\n\n\ndef AddObjectsToGroup(object_ids, group_name):\n    \"\"\"Adds one or more objects to an existing group.\n    Parameters:\n      object_ids = list of Strings or Guids representing the object identifiers\n      group_name = the name of an existing group\n    Returns:\n      number of objects added to the group\n    \"\"\"\n    if not isinstance(group_name, str): group_name = str(group_name)\n    index = scriptcontext.doc.Groups.Find(group_name, True)\n    object_ids = rhutil.coerceguidlist(object_ids)\n    if index<0 or not object_ids: return 0\n    if not scriptcontext.doc.Groups.AddToGroup(index, object_ids): return 0\n    return len(object_ids)\n\n\ndef AddObjectToGroup(object_id, group_name):\n    \"\"\"Adds a single object to an existing group.\n    Parameters:\n      object_id = String or Guid representing the object identifier\n      group_name = the name of an existing group\n    Returns:\n      True or False representing success or failure\n    \"\"\"\n    object_id = rhutil.coerceguid(object_id)\n    if not isinstance(group_name, str): group_name = str(group_name)\n    index = scriptcontext.doc.Groups.Find(group_name, True)\n    if object_id is None or index<0: return False\n    return scriptcontext.doc.Groups.AddToGroup(index, object_id)\n\n\ndef DeleteGroup(group_name):\n    \"\"\"Removes an existing group from the document. Reference groups cannot be\n    removed. Deleting a group does not delete the member objects\n    Parameters:\n      group_name = the name of an existing group\n    Returns:\n      True or False representing success or failure\n    \"\"\"\n    if not isinstance(group_name, str): group_name = str(group_name)\n    index = scriptcontext.doc.Groups.Find(group_name, True)\n    return scriptcontext.doc.Groups.Delete(index)\n\n\ndef GroupCount():\n    \"Returns the number of groups in the document\"\n    return scriptcontext.doc.Groups.Count\n\n\ndef GroupNames():\n    \"\"\"Returns the names of all the groups in the document\n    None if no names exist in the document\n    \"\"\"\n    names = scriptcontext.doc.Groups.GroupNames(True)\n    if names is None: return None\n    return list(names)\n\n\ndef HideGroup(group_name):\n    \"\"\"Hides a group of objects. Hidden objects are not visible, cannot be\n    snapped to, and cannot be selected\n    Parameters:\n      group_name = the name of an existing group\n    Returns:\n      The number of objects that were hidden\n    \"\"\"\n    index = scriptcontext.doc.Groups.Find(group_name, True)\n    if index<0: return 0\n    return scriptcontext.doc.Groups.Hide(index);\n\n\ndef IsGroup(group_name):\n    \"\"\"Verifies the existance of a group\n    Paramters:\n      group_name = the name of the group to check for\n    Returns:\n      True or False\n    \"\"\"\n    if not isinstance(group_name, str): group_name = str(group_name)\n    return scriptcontext.doc.Groups.Find(group_name, True)>=0\n\n\ndef IsGroupEmpty(group_name):\n    \"\"\"Verifies that an existing group is empty, or contains no object members\n    Parameters:\n      group_name = the name of an existing group\n    Returns:\n      True or False if group_name exists\n      None if group_name does not exist\n    \"\"\"\n    if not isinstance(group_name, str): group_name = str(group_name)\n    index = scriptcontext.doc.Groups.Find(group_name, True)\n    if index<0: return scriptcontext.errorhandler()\n    return scriptcontext.doc.Groups.GroupObjectCount(index)>0\n\n\ndef LockGroup(group_name):\n    \"\"\"Locks a group of objects. Locked objects are visible and they can be\n    snapped to. But, they cannot be selected\n    Parameters:\n      group_name = the name of an existing group\n    Returns:\n      Number of objects that were locked if successful\n      None on error\n    \"\"\"\n    if not isinstance(group_name, str): group_name = str(group_name)\n    index = scriptcontext.doc.Groups.Find(group_name, True)\n    if index<0: return scriptcontext.errorhandler()\n    return scriptcontext.doc.Groups.Lock(index);\n\n\ndef RemoveObjectFromAllGroups(object_id):\n    \"\"\"Removes a single object from any and all groups that it is a member.\n    Neither the object nor the group can be reference objects\n    Parameters:\n      object_id = the object identifier\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    rhinoobject = rhutil.coercerhinoobject(object_id, True, True)\n    if rhinoobject.GroupCount<1: return False\n    attrs = rhinoobject.Attributes\n    attrs.RemoveFromAllGroups()\n    return scriptcontext.doc.Objects.ModifyAttributes(rhinoobject, attrs, True)\n\n\ndef RemoveObjectFromGroup(object_id, group_name):\n    \"\"\"Remove a single object from an existing group\n    Parameters:\n      object_id = the object identifier\n      group_name = the name of an existing group\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    count = RemoveObjectsFromGroup(object_id, group_name)\n    return not (count is None or count<1)\n\n\ndef RemoveObjectsFromGroup(object_ids, group_name):\n    \"\"\"Removes one or more objects from an existing group\n    Parameters:\n      object_ids = a list of object identifiers\n      group_name = the name of an existing group\n    Returns:\n      The number of objects removed from the group is successful\n      None on error\n    \"\"\"\n    if not isinstance(group_name, str): group_name = str(group_name)\n    index = scriptcontext.doc.Groups.Find(group_name, True)\n    if index<0: return scriptcontext.errorhandler()\n    id = rhutil.coerceguid(objects_ids, False)\n    if id: object_ids = [id]\n    objects_removed = 0\n    for id in object_ids:\n        rhinoobject = rhutil.coercerhinoobject(id, True, True)\n        attrs = rhinoobject.Attributes\n        attrs.RemoveFromGroup(index)\n        if scriptcontext.doc.Objects.ModifyAttributes(rhinoobject, attrs, True):\n            objects_removed+=1\n    return objects_removed\n\n\ndef RenameGroup(old_name, new_name):\n    \"\"\"Renames an existing group\n    Parameters:\n      old_name = the name of an existing group\n      new_name = the new group name\n    Returns:\n      the new group name if successful\n      None on error\n    \"\"\"\n    if not isinstance(old_name, str): old_name = str(old_name)\n    index = scriptcontext.doc.Groups.Find(old_name, True)\n    if index<0: return scriptcontext.errorhandler()\n    if not isinstance(new_name, str): new_name = str(new_name)\n    if scriptcontext.doc.Groups.ChangeGroupName(index, new_name):\n        return new_name\n    return scriptcontext.errorhandler()\n\n\ndef ShowGroup(group_name):\n    \"\"\"Shows a group of previously hidden objects. Hidden objects are not\n    visible, cannot be snapped to, and cannot be selected\n    Parameters:\n      group_name = the name of an existing group\n    Returns:\n      The number of objects that were shown if successful\n      None on error  \n    \"\"\"\n    if not isinstance(group_name, str): group_name = str(group_name)\n    index = scriptcontext.doc.Groups.Find(group_name, True)\n    if index<0: return scriptcontext.errorhandler()\n    return scriptcontext.doc.Groups.Show(index);\n\n\ndef UnlockGroup(group_name):\n    \"\"\"Unlocks a group of previously locked objects. Lockes objects are visible,\n    can be snapped to, but cannot be selected\n    Parameters:\n      group_name = the name of an existing group\n    Returns:\n      The number of objects that were unlocked if successful\n      None on error  \n    \"\"\"\n    if not isinstance(group_name, str): group_name = str(group_name)\n    index = scriptcontext.doc.Groups.Find(group_name, True)\n    if index<0: return scriptcontext.errorhandler()\n    return scriptcontext.doc.Groups.Unlock(index);\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["functions"], "original_file": "ksteinfe_decodes_2092331660.json", "repo": "ksteinfe/decodes"}
{"instruction": "Adds a mesh object to the document", "code": "import scriptcontext\nfrom . import utility as rhutil\nimport Rhino\nimport System.Guid, System.Array, System.Drawing.Color\n\n\ndef AddMesh(vertices, face_vertices, vertex_normals=None, texture_coordinates=None, vertex_colors=None):\n    \"\"\"Adds a mesh object to the document\n    Parameters:\n      vertices = list of 3D points defining the vertices of the mesh\n      face_vertices = list containing lists of 3 or 4 numbers that define the\n        vertex indices for each face of the mesh. If the third a fourth vertex\n        indices of a face are identical, a triangular face will be created.\n      vertex_normals[opt] = list of 3D vectors defining the vertex normals of\n        the mesh. Note, for every vertex, there must be a corresponding vertex\n        normal\n      texture_coordinates[opt] = list of 2D texture coordinates. Note, for\n        every vertex, there must be a corresponding texture coordinate\n      vertex_colors[opt] = a list of color values. Note, for every vertex,\n        there must be a corresponding vertex color\n    Returns:\n      Identifier of the new object if successful\n      None on error\n    \"\"\"\n    mesh = Rhino.Geometry.Mesh()\n    for a, b, c in vertices: mesh.Vertices.Add(a, b, c)\n    for face in face_vertices:\n        if len(face)<4:\n            mesh.Faces.AddFace(face[0], face[1], face[2])\n        else:\n            mesh.Faces.AddFace(face[0], face[1], face[2], face[3])\n    if vertex_normals:\n        count = len(vertex_normals)\n        normals = System.Array.CreateInstance(Rhino.Geometry.Vector3f, count)\n        for i, normal in enumerate(vertex_normals):\n            normals[i] = Rhino.Geometry.Vector3f(normal[0], normal[1], normal[2])\n        mesh.Normals.SetNormals(normals)\n    if texture_coordinates:\n        count = len(texture_coordinates)\n        tcs = System.Array.CreateInstance(Rhino.Geometry.Point2f, count)\n        for i, tc in enumerate(texture_coordinates):\n            tcs[i] = Rhino.Geometry.Point2f(tc[0], tc[1], tc[2])\n        mesh.TextureCoordinates.SetTextureCoordinates(tcs)\n    if vertex_colors:\n        count = len(vertex_colors)\n        colors = System.Array.CreateInstance(System.Drawing.Color, count)\n        for i, color in enumerate(vertex_colors):\n            colors[i] = System.Drawing.Color.FromArgb(color[0], color[1], color[2])\n        mesh.VertexColors.SetColors(colors)\n    rc = scriptcontext.doc.Objects.AddMesh(mesh)\n    if rc==System.Guid.Empty: raise Exception(\"unable to add mesh to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddPlanarMesh(object_id, delete_input=False):\n    \"\"\"Creates a planar mesh from a closed, planar curve\n    Parameters:\n      object_id = identifier of a closed, planar curve\n      delete_input[opt] = if True, delete the input curve defined by object_id\n    Returns:\n      id of the new mesh on success\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, -1, True)\n    mesh = Rhino.Geometry.Mesh.CreateFromPlanarBoundary(curve, Rhino.Geometry.MeshingParameters.Default)\n    if not mesh: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddMesh(mesh)\n    if rc==System.Guid.Empty: raise Exception(\"unable to add mesh to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef CurveMeshIntersection(curve_id, mesh_id, return_faces=False):\n    \"\"\"Calculates the intersection of a curve object and a mesh object\n    Parameters:\n      curve_id = identifier of a curve object\n      mesh_id = identifier or a mesh object\n      return_faces[opt] = return both intersection points and face indices.\n        If False, then just the intersection points are returned\n    Returns:\n      if return_false is omitted or False, then a list of intersection points\n      if return_false is True, the a one-dimensional list containing information\n        about each intersection. Each element contains the following two elements\n        (point of intersection, mesh face index where intersection lies)\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    mesh = rhutil.coercemesh(mesh_id, True)\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    polylinecurve = curve.ToPolyline(0,0,0,0,0.0,tolerance,0.0,0.0,True)\n    pts, faceids = Rhino.Geometry.Intersect.Intersection.MeshPolyline(mesh, polylinecurve)\n    if not pts: return scriptcontext.errorhandler()\n    pts = list(pts)\n    if return_faces:\n        faceids = list(faceids)\n        return list(zip(pts, faceids))\n    return pts\n\n\ndef DisjointMeshCount(object_id):\n    \"\"\"Returns number of meshes that could be created by calling SplitDisjointMesh\n    Parameters:\n      object_id = identifier of a mesh object\n    Returns:\n      The number of meshes that could be created\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.DisjointMeshCount\n\n\ndef DuplicateMeshBorder(mesh_id):\n    \"\"\"Creates curves that duplicates a mesh border\n    Parameters:\n      mesh_id = identifier of a mesh object\n    Returns:\n      list of curve ids on success\n      None on error\n    \"\"\"\n    mesh = rhutil.coercemesh(mesh_id, True)\n    polylines = mesh.GetNakedEdges()\n    rc = []\n    if polylines:\n        for polyline in polylines:\n            id = scriptcontext.doc.Objects.AddPolyline(polyline)\n            if id!=System.Guid.Empty: rc.append(id)\n    if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ExplodeMeshes(mesh_ids, delete=False):\n    \"\"\"Explodes a mesh object, or mesh objects int submeshes. A submesh is a\n    collection of mesh faces that are contained within a closed loop of\n    unwelded mesh edges. Unwelded mesh edges are where the mesh faces that\n    share the edge have unique mesh vertices (not mesh topology vertices)\n    at both ends of the edge\n    Parameters:\n      mesh_ids = list of mesh identifiers\n      delete[opt] = delete the input meshes\n    Returns:\n      List of identifiers\n    \"\"\"\n    id = rhutil.coerceguid(mesh_ids)\n    if id: mesh_ids = [mesh_ids]\n    rc = []\n    for mesh_id in mesh_ids:\n        mesh = rhutil.coercemesh(mesh_id, True)\n        if mesh:\n            submeshes = mesh.ExplodeAtUnweldedEdges()\n            if submeshes:\n                for submesh in submeshes:\n                    id = scriptcontext.doc.Objects.AddMesh(submesh)\n                    if id!=System.Guid.Empty: rc.append(id)\n    if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef IsMesh(object_id):\n    \"Verifies if an object is a mesh\"\n    mesh = rhutil.coercemesh(object_id)\n    return mesh is not None\n\n\ndef IsMeshClosed(object_id):\n    \"\"\"Verifies a mesh object is closed\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.IsClosed\n\n\ndef IsMeshManifold(object_id):\n    \"\"\"Verifies a mesh object is manifold. A mesh for which every edge is shared\n    by at most two faces is called manifold. If a mesh has at least one edge\n    that is shared by more than two faces, then that mesh is called non-manifold\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    rc = mesh.IsManifold(True)\n    return rc[0]\n\n\ndef IsPointOnMesh(object_id, point):\n    \"\"\"Verifies that a point is on a mesh\n    Parameters:\n      object_id = identifier of a mesh object\n      point = test point\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    point = rhutil.coerce3dpoint(point, True)\n    max_distance = Rhino.RhinoMath.SqrtEpsilon\n    face, pt = mesh.ClosestPoint(point, max_distance)\n    return face>=0\n\n\ndef MeshArea(object_ids):\n    \"\"\"Returns the approximate area of one or more mesh objects\n    Parameters:\n      object_ids = identifiers of one or more mesh objects\n    Returns:\n      a list containing 3 numbers if successful where\n        element[0] = number of meshes used in calculation\n        element[1] = total area of all meshes\n        element[2] = the error estimate\n      None if not successful\n    \"\"\"\n    id = rhutil.coerceguid(object_ids)\n    if id: object_ids = [object_ids]\n    meshes_used = 0\n    total_area = 0.0\n    error_estimate = 0.0\n    for id in object_ids:\n        mesh = rhutil.coercemesh(id, True)\n        if mesh:\n            mp = Rhino.Geometry.AreaMassProperties.Compute(mesh)\n            if mp:\n                meshes_used += 1\n                total_area += mp.Area\n                error_estimate += mp.AreaError\n    if meshes_used==0: return scriptcontext.errorhandler()\n    return meshes_used, total_area, error_estimate\n\n\ndef MeshAreaCentroid(object_id):\n    \"\"\"Calculates the area centroid of a mesh object\n    Parameters:\n      object_id = identifier of a mesh object\n    Returns:\n      Point3d representing the area centroid if successful\n      None on error  \n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    mp = Rhino.Geometry.AreaMassProperties.Compute(mesh)\n    if mp is None: return scriptcontext.errorhandler()\n    return mp.Centroid\n\n\ndef MeshBooleanDifference(input0, input1, delete_input=True):\n    \"\"\"Performs a boolean difference operation on two sets of input meshes\n    Parameters:\n      input0, input1 = identifiers of meshes\n      delete_input[opt] = delete the input meshes\n    Returns:\n      list of identifiers of new meshes\n    \"\"\"\n    id = rhutil.coerceguid(input0)\n    if id: input0 = [id]\n    id = rhutil.coerceguid(input1)\n    if id: input1 = [id]\n    meshes0 = [rhutil.coercemesh(id, True) for id in input0]\n    meshes1 = [rhutil.coercemesh(id, True) for id in input1]\n    if not meshes0 or not meshes1: raise ValueError(\"no meshes to work with\")\n    newmeshes = Rhino.Geometry.Mesh.CreateBooleanDifference(meshes0, meshes1)\n    rc = []\n    for mesh in newmeshes:\n        id = scriptcontext.doc.Objects.AddMesh(mesh)\n        if id!=System.Guid.Empty: rc.append(id)\n    if rc and delete_input:\n        input = input0 + input1\n        for id in input:\n            id = rhutil.coerceguid(id, True)\n            scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef MeshBooleanIntersection(input0, input1, delete_input=True):\n    \"\"\"Performs a boolean intersection operation on two sets of input meshes\n    Parameters:\n      input0, input1 = identifiers of meshes\n      delete_input[opt] = delete the input meshes\n    Returns:\n      list of identifiers of new meshes on success\n    \"\"\"\n    id = rhutil.coerceguid(input0)\n    if id: input0 = [id]\n    id = rhutil.coerceguid(input1)\n    if id: input1 = [id]\n    meshes0 = [rhutil.coercemesh(id, True) for id in input0]\n    meshes1 = [rhutil.coercemesh(id, True) for id in input1]\n    if not meshes0 or not meshes1: raise ValueError(\"no meshes to work with\")\n    newmeshes = Rhino.Geometry.Mesh.CreateBooleanIntersection(meshes0, meshes1)\n    rc = []\n    for mesh in newmeshes:\n        id = scriptcontext.doc.Objects.AddMesh(mesh)\n        if id!=System.Guid.Empty: rc.append(id)\n    if rc and delete_input:\n        input = input0 + input1\n        for id in input:\n            id = rhutil.coerceguid(id, True)\n            scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\ndef MeshBooleanSplit(input0, input1, delete_input=True):\n    \"\"\"Performs a boolean split operation on two sets of input meshes\n    Parameters:\n      input0, input1 = identifiers of meshes\n      delete_input[opt] = delete the input meshes\n    Returns:\n      list of identifiers of new meshes on success\n      None on error\n    \"\"\"\n    id = rhutil.coerceguid(input0)\n    if id: input0 = [id]\n    id = rhutil.coerceguid(input1)\n    if id: input1 = [id]\n    meshes0 = [rhutil.coercemesh(id, True) for id in input0]\n    meshes1 = [rhutil.coercemesh(id, True) for id in input1]\n    if not meshes0 or not meshes1: raise ValueError(\"no meshes to work with\")\n    newmeshes = Rhino.Geometry.Mesh.CreateBooleanSplit(meshes0, meshes1)\n    rc = []\n    for mesh in newmeshes:\n        id = scriptcontext.doc.Objects.AddMesh(mesh)\n        if id!=System.Guid.Empty: rc.append(id)\n    if rc and delete_input:\n        input = input0 + input1\n        for id in input:\n            id = rhutil.coerceguid(id, True)\n            scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef MeshBooleanUnion(mesh_ids, delete_input=True):\n    \"\"\"Performs a boolean union operation on a set of input meshes\n    Parameters:\n      mesh_ids = identifiers of meshes\n      delete_input[opt] = delete the input meshes\n    Returns:\n      list of identifiers of new meshes\n    \"\"\"\n    if len(mesh_ids)<2: raise ValueError(\"mesh_ids must contain at least 2 meshes\")\n    meshes = [rhutil.coercemesh(id, True) for id in mesh_ids]\n    newmeshes = Rhino.Geometry.Mesh.CreateBooleanUnion(meshes)\n    rc = []\n    for mesh in newmeshes:\n        id = scriptcontext.doc.Objects.AddMesh(mesh)\n        if id!=System.Guid.Empty: rc.append(id)\n    if rc and delete_input:\n        for id in mesh_ids:\n            id = rhutil.coerceguid(id, True)\n            scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef MeshClosestPoint(object_id, point, maximum_distance=None):\n    \"\"\"Returns the point on a mesh that is closest to a test point\n    Parameters:\n      object_id = identifier of a mesh object\n      point = point to test\n      maximum_distance[opt] = upper bound used for closest point calculation.\n        If you are only interested in finding a point Q on the mesh when\n        point.DistanceTo(Q) < maximum_distance, then set maximum_distance to\n        that value\n    Returns:\n      Tuple containing the results of the calculation where\n        element[0] = the 3-D point on the mesh\n        element[1] = the index of the mesh face on which the 3-D point lies\n      None on error\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    point = rhutil.coerce3dpoint(point, True)\n    tolerance=maximum_distance if maximum_distance else 0.0\n    face, closest_point = mesh.ClosestPoint(point, tolerance)\n    if face<0: return scriptcontext.errorhandler()\n    return closest_point, face\n\n\n# [skipping for now] MeshContourPoints\n\ndef MeshFaceCenters(mesh_id):\n    \"\"\"Returns the center of each face of the mesh object\n    Parameters:\n      mesh_id = identifier of a mesh object\n    Returns:\n      list of 3d points defining the center of each face\n    \"\"\"\n    mesh = rhutil.coercemesh(mesh_id, True)\n    count = mesh.Faces.Count\n    rc = [mesh.Faces.GetFaceCenter(i) for i in range(count)]\n    return rc\n\n\ndef MeshFaceCount(object_id):\n    \"\"\"Returns the total face count of a mesh object\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.Faces.Count\n\n\ndef MeshFaceNormals(mesh_id):\n    \"\"\"Returns the face unit normal for each face of a mesh object\n    Paramters:\n      mesh_id = identifier of a mesh object\n    Returns:\n      A list of 3D vectors that define the face unit normals of the mesh\n      None on error    \n    \"\"\"\n    mesh = rhutil.coercemesh(mesh_id, True)\n    if mesh.FaceNormals.Count != mesh.Faces.Count:\n        mesh.FaceNormals.ComputeFaceNormals()\n    rc = []\n    for i in range(mesh.FaceNormals.Count):\n        normal = mesh.FaceNormals[i]\n        rc.append(Rhino.Geometry.Vector3d(normal))\n    return rc\n\n\ndef MeshFaces(object_id, face_type=True):\n    \"\"\"Returns the face vertices of a mesh\n    Parameters:\n      object_id = identifier of a mesh object\n      face_type[opt] = The face type to be returned. True = both triangles\n        and quads. False = only triangles\n    Returns:\n      a list of 3D points that define the face vertices of the mesh. If\n      face_type is True, then faces are returned as both quads and triangles\n      (4 3D points). For triangles, the third and fourth vertex will be\n      identical. If face_type is False, then faces are returned as only\n      triangles(3 3D points). Quads will be converted to triangles.\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    rc = []\n    for i in range(mesh.Faces.Count):\n        getrc, p0, p1, p2, p3 = mesh.Faces.GetFaceVertices(i)\n        p0 = Rhino.Geometry.Point3d(p0)\n        p1 = Rhino.Geometry.Point3d(p1)\n        p2 = Rhino.Geometry.Point3d(p2)\n        p3 = Rhino.Geometry.Point3d(p3)\n        rc.append( p0 )\n        rc.append( p1 )\n        rc.append( p2 )\n        if face_type:\n            rc.append(p3)\n        else:\n            if p2!=p3:\n                rc.append( p2 )\n                rc.append( p3 )\n                rc.append( p0 )\n    return rc\n\n\ndef MeshFaceVertices(object_id):\n    \"\"\"Returns the vertex indices of all faces of a mesh object\n    Paramters:\n      object_id = identifier of a mesh object\n    Returns:\n      A list containing tuples of 4 numbers that define the vertex indices for\n      each face of the mesh. Both quad and triangle faces are returned. If the\n      third and fourth vertex indices are identical, the face is a triangle.\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    rc = []\n    for i in range(mesh.Faces.Count):\n        face = mesh.Faces.GetFace(i)\n        rc.append( (face.A, face.B, face.C, face.D) )\n    return rc\n\n\ndef MeshHasFaceNormals(object_id):\n    \"\"\"Verifies a mesh object has face normals\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.FaceNormals.Count>0\n\n\ndef MeshHasTextureCoordinates(object_id):\n    \"\"\"Verifies a mesh object has texture coordinates\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.TextureCoordinates.Count>0\n\n\ndef MeshHasVertexColors(object_id):\n    \"\"\"Verifies a mesh object has vertex colors\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.VertexColors.Count>0\n\n\ndef MeshHasVertexNormals(object_id):\n    \"\"\"Verifies a mesh object has vertex normals\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.Normals.Count>0\n\n\ndef MeshMeshIntersection(mesh1, mesh2, tolerance=None):\n    \"\"\"Calculates the intersections of a mesh object with another mesh object\n    Parameters:\n      mesh1, mesh2 = identifiers of meshes\n      tolerance[opt] = the intersection tolerance\n    Returns:\n      List of 3d point arrays that define the vertices of the intersection curves\n    \"\"\"\n    mesh1 = rhutil.coercemesh(mesh1, True)\n    mesh2 = rhutil.coercemesh(mesh2, True)\n    if tolerance is None: tolerance = Rhino.RhinoMath.ZeroTolerance\n    polylines = Rhino.Geometry.Intersect.Intersection.MeshMeshAccurate(mesh1, mesh2, tolerance)\n    if polylines: return list(polylines)\n    return []\n\n\ndef MeshNakedEdgePoints(object_id):\n    \"\"\"Identifies the naked edge points of a mesh object. This function shows\n    where mesh vertices are not completely surrounded by faces. Joined\n    meshes, such as are made by MeshBox, have naked mesh edge points where\n    the sub-meshes are joined\n    Parameters:\n      object_id = identifier of a mesh object\n    Returns:\n      List of boolean values that represent whether or not a mesh vertex is\n      naked or not. The number of elements in the list will be equal to\n      the value returned by MeshVertexCount. In which case, the list will\n      identify the naked status for each vertex returned by MeshVertices\n      None on error\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    rc = mesh.GetNakedEdgePointStatus()\n    return rc\n\n\ndef MeshOffset(mesh_id, distance):\n    \"\"\"Makes a new mesh with vertices offset at a distance in the opposite\n    direction of the existing vertex normals\n    Parameters:\n      mesh_id = identifier of a mesh object\n      distance = the distance to offset\n    Returns:\n      id of the new mesh object if successful\n      None on error\n    \"\"\"\n    mesh = rhutil.coercemesh(mesh_id, True)\n    offsetmesh = mesh.Offset(distance)\n    if offsetmesh is None: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddMesh(offsetmesh)\n    if rc==System.Guid.Empty: raise Exception(\"unable to add mesh to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef MeshQuadCount(object_id):\n    \"\"\"Returns the number of quad faces of a mesh object\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.Faces.QuadCount\n\n\ndef MeshQuadsToTriangles(object_id):\n    \"\"\"Converts a mesh object's quad faces to triangles\n    Parameters:\n      object_id = identifier of a mesh object\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    rc = True\n    if mesh.Faces.QuadCount>0:\n        rc = mesh.Faces.ConvertQuadsToTriangles()\n        if rc:\n            id = rhutil.coerceguid(object_id, True)\n            scriptcontext.doc.Objects.Replace(id, mesh)\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n# [skipping for now] MeshTextureCoordinates\n\ndef MeshTriangleCount(object_id):\n    \"\"\"Returns the number of triangular faces of a mesh object\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.Faces.TriangleCount\n\n\ndef MeshVertexColors(mesh_id, colors=0):\n    \"\"\"Returns of modifies the vertex colors of a mesh object\n    Parameters:\n      mesh_id = identifier of a mesh object\n      colors[opt] = A list of color values. Note, for each vertex, there must\n        be a corresponding vertex color. If the value is None, then any\n        existing vertex colors will be removed from the mesh\n    Returns:\n      if colors is not specified, the current vertex colors\n      if colors is specified, the previous vertex colors\n    \"\"\"\n    mesh = rhutil.coercemesh(mesh_id, True)\n    rc = [mesh.VertexColors[i] for i in range(mesh.VertexColors.Count)]\n    if colors==0: return rc\n    if colors is None:\n        mesh.VertexColors.Clear()\n    else:\n        color_count = len(colors)\n        if color_count!=mesh.Vertices.Count:\n            raise ValueError(\"length of colors must match vertex count\")\n        colors = [rhutil.coercecolor(c) for c in colors]\n        mesh.VertexColors.Clear()\n        for c in colors: mesh.VertexColors.Add(c)\n        id = rhutil.coerceguid(mesh_id, True)\n        scriptcontext.doc.Objects.Replace(id, mesh)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef MeshVertexCount(object_id):\n    \"\"\"Returns the vertex count of a mesh object\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.Vertices.Count\n\n\ndef MeshVertexFaces(mesh_id, vertex_index):\n    \"\"\"Returns the mesh faces that share a specified mesh vertex\n    Parameters:\n      mesh_id = identifier of a mesh object\n      vertex_index = index of the mesh vertex to find faces for\n    Returns:\n      list of face indices on success\n      None on error\n    \"\"\"\n    mesh = rhutil.coercemesh(mesh_id, True)\n    return mesh.Vertices.GetVertexFaces(vertex_index)\n\n\ndef MeshVertexNormals(mesh_id):\n    \"\"\"Returns the vertex unit normal for each vertex of a mesh object\n    Parameters:\n      mesh_id = identifier of a mesh object\n    Returns:\n      list of vertex normals, (empty list if no normals exist)\n    \"\"\"\n    mesh = rhutil.coercemesh(mesh_id, True)\n    count = mesh.Normals.Count\n    if count<1: return []\n    return [Rhino.Geometry.Vector3d(mesh.Normals[i]) for i in range(count)]\n\n\ndef MeshVertices(object_id):\n    \"\"\"Returns the vertices of a mesh object\n    Parameters:\n      object_id = identifier of a mesh object\n    Returns:\n      list of 3D points\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    count = mesh.Vertices.Count\n    rc = []\n    for i in range(count):\n        vertex = mesh.Vertices[i]\n        rc.append(Rhino.Geometry.Point3d(vertex))\n    return rc\n\n\ndef MeshVolume(object_ids, True):\n    \"\"\"\n    Returns the approximate volume of one or more closed mesh objects\n    Parameters:\n      object_ids = identifiers of one or more mesh objects\n    Returns:\n      a tuple containing 3 numbers if successful where\n        element[0] = number of meshes used in volume calculation\n        element[1] = total volume of all meshes\n        element[2] = the error estimate\n      None if not successful\n    \"\"\"\n    id = rhutil.coerceguid(object_ids)\n    if id: object_ids = [id]\n    meshes_used = 0\n    total_volume = 0.0\n    error_estimate = 0.0\n    for id in object_ids:\n        mesh = rhutil.coercemesh(id, True)\n        mp = Rhino.Geometry.VolumeMassProperties.Compute(mesh)\n        if mp:\n            meshes_used += 1\n            total_volume += mp.Volume\n            error_estimate += mp.VolumeError\n    if meshes_used==0: return scriptcontext.errorhandler()\n    return meshes_used, total_volume, error_estimate\n\n\ndef MeshVolumeCentroid(object_id):\n    \"\"\"Calculates the volume centroid of a mesh object\n    Parameters:\n      object_id = identifier of a mesh object\n    Returns:\n      Point3d representing the volume centroid\n      None on error\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    mp = Rhino.Geometry.VolumeMassProperties.Compute(mesh)\n    if mp: return mp.Centroid\n    return scriptcontext.errorhandler()\n\n\ndef PullCurveToMesh(mesh_id, curve_id):\n    \"\"\"Pulls a curve object to a mesh object. The function makes a polyline\n    approximation of the input curve and get the closest point on the mesh\n    for each point on the polyline. Then it \"connects the points\" so that\n    you have a polyline on the mesh\n    Paramters:\n      mesh_id = identifier of mesh object that pulls\n      curve_id = identifier of curve object to pull\n    Returns:\n      Guid of new curve on success\n      None on error\n    \"\"\"\n    mesh = rhutil.coercemesh(mesh_id, True)\n    curve = rhutil.coercecurve(curve_id, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    polyline = curve.PullToMesh(mesh, tol)\n    if not polyline: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddCurve(polyline)\n    if rc==System.Guid.Empty: raise Exception(\"unable to add polyline to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef SplitDisjointMesh(object_id, delete_input=False):\n    \"\"\"Splits up a mesh object into its unconnected pieces\n    Parameters:\n      object_id = identifier of a mesh object\n      delete_input [opt] = delete the input object\n    Returns:\n      list of Guids for the new meshes\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    pieces = mesh.SplitDisjointPieces()\n    rc = [scriptcontext.doc.Objects.AddMesh(piece) for piece in pieces]\n    if rc and delete_input:\n        id = rhutil.coerceguid(object_id, True)\n        scriptcontext.doc.Objects.Delete(id)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef UnifyMeshNormals(object_id):\n    \"\"\"Fixes inconsistencies in the directions of faces of a mesh\n    Parameters:\n      object_id = identifier of a mesh object\n    Returns:\n      number of faces that were modified\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    rc = mesh.UnifyNormals()\n    if rc>0:\n        id = rhutil.coerceguid(object_id, True)\n        scriptcontext.doc.Objects.Replace(id, mesh)\n        scriptcontext.doc.Views.Redraw()\n    return rc\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "line", "dimension", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "ksteinfe_decodes_5f5238a6ed.json", "repo": "ksteinfe/decodes"}
{"instruction": "Adds an arc curve to the document", "code": "import scriptcontext\nfrom . import utility as rhutil\nimport Rhino\nimport math\nimport System.Guid, System.Array, System.Enum\n\ndef AddArc(plane, radius, angle_degrees):\n    \"\"\"Adds an arc curve to the document\n    Parameters:\n      plane = plane on which the arc will lie. The origin of the plane will be\n        the center point of the arc. x-axis of the plane defines the 0 angle\n        direction.\n      radius = radius of the arc\n      angle_degrees = interval of arc\n    Returns:\n      id of the new curve object\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    radians = math.radians(angle_degrees)\n    arc = Rhino.Geometry.Arc(plane, radius, radians)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add arc to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddArc3Pt(start, end, point_on_arc):\n    \"\"\"Adds a 3-point arc curve to the document\n    Parameters:\n      start, end = endpoints of the arc\n      point_on_arc = a point on the arc\n    Returns:\n      id of the new curve object\n    \"\"\"\n    start = rhutil.coerce3dpoint(start, True)\n    end = rhutil.coerce3dpoint(end, True)\n    pton = rhutil.coerce3dpoint(point_on_arc, True)\n    arc = Rhino.Geometry.Arc(start, pton, end)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add arc to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddArcPtTanPt(start, direction, end):\n    \"\"\"Adds an arc curve, created from a start point, a start direction, and an\n    end point, to the document\n    Returns:\n      id of the new curve object\n    \"\"\"\n    start = rhutil.coerce3dpoint(start, True)\n    direction = rhutil.coerce3dvector(direction, True)\n    end = rhutil.coerce3dpoint(end, True)\n    arc = Rhino.Geometry.Arc(start, direction, end)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add arc to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCircle(plane_or_center, radius):\n    \"\"\"Adds a circle curve to the document\n    Parameters:\n      plane_or_center = plane on which the circle will lie. If a point is\n        passed, this will be the center of the circle on the active\n        construction plane\n      radius = the radius of the circle\n    Returns:\n      id of the new curve object\n    \"\"\"\n    rc = None\n    plane = rhutil.coerceplane(plane_or_center, False)\n    if plane:\n        circle = Rhino.Geometry.Circle(plane, radius)\n        rc = scriptcontext.doc.Objects.AddCircle(circle)\n    else:\n        center = rhutil.coerce3dpoint(plane_or_center, True)\n        view = scriptcontext.doc.Views.ActiveView\n        plane = view.ActiveViewport.ConstructionPlane()\n        plane.Origin = center\n        circle = Rhino.Geometry.Circle(plane, radius)\n        rc = scriptcontext.doc.Objects.AddCircle(circle)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add circle to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCircle3Pt(first, second, third):\n    \"\"\"Adds a 3-point circle curve to the document\n    Parameters:\n      first, second, third = points on the circle\n    Returns:\n      id of the new curve object\n    \"\"\"\n    start = rhutil.coerce3dpoint(first, True)\n    end = rhutil.coerce3dpoint(second, True)\n    third = rhutil.coerce3dpoint(third, True)\n    circle = Rhino.Geometry.Circle(start, end, third)\n    rc = scriptcontext.doc.Objects.AddCircle(circle)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add circle to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCurve(points, degree=3):\n    \"\"\"Adds a control points curve object to the document\n    Parameters:\n      points = a list of points\n      degree[opt] = degree of the curve\n    Returns:\n      id of the new curve object\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    curve = Rhino.Geometry.Curve.CreateControlPointCurve(points, degree)\n    if not curve: raise Exception(\"unable to create control point curve from given points\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddEllipse(plane, radiusX, radiusY):\n    \"\"\"Adds an elliptical curve to the document\n    Parameters:\n      plane = the plane on which the ellipse will lie. The origin of\n              the plane will be the center of the ellipse\n      radiusX, radiusY = radius in the X and Y axis directions\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    ellipse = Rhino.Geometry.Ellipse(plane, radiusX, radiusY)\n    rc = scriptcontext.doc.Objects.AddEllipse(ellipse)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddEllipse3Pt(center, second, third):\n    \"\"\"Adds a 3-point elliptical curve to the document\n    Parameters:\n      center = center point of the ellipse\n      second = end point of the x axis\n      third  = end point of the y axis\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n    center = rhutil.coerce3dpoint(center, True)\n    second = rhutil.coerce3dpoint(second, True)\n    third = rhutil.coerce3dpoint(third, True)\n    ellipse = Rhino.Geometry.Ellipse(center, second, third)\n    rc = scriptcontext.doc.Objects.AddEllipse(ellipse)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddFilletCurve(curve0id, curve1id, radius=1.0, base_point0=None, base_point1=None):\n    \"\"\"Adds a fillet curve between two curve objects\n    Parameters:\n      curve0id = identifier of the first curve object\n      curve1id = identifier of the second curve object\n      radius [opt] = fillet radius\n      base_point0 [opt] = base point of the first curve. If omitted,\n                          starting point of the curve is used\n      base_point1 [opt] = base point of the second curve. If omitted,\n                          starting point of the curve is used\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n    if base_point0: base_point0 = rhutil.coerce3dpoint(base_point0, True)\n    else: base_point0 = Rhino.Geometry.Point3d.Unset\n    if base_point1: base_point1 = rhutil.coerce3dpoint(base_point1, True)\n    else: base_point1 = Rhino.Geometry.Point3d.Unset\n    curve0 = rhutil.coercecurve(curve0id, -1, True)\n    curve1 = rhutil.coercecurve(curve1id, -1, True)\n    crv0_t = 0.0\n    if base_point0==Rhino.Geometry.Point3d.Unset:\n        crv0_t = curve0.Domain.Min\n    else:\n        rc, t = curve0.ClosestPoint(base_point0, 0.0)\n        if not rc: raise Exception(\"ClosestPoint failed\")\n        crv0_t = t\n    crv1_t = 0.0\n    if base_point1==Rhino.Geometry.Point3d.Unset:\n        crv1_t = curve1.Domain.Min\n    else:\n        rc, t = curve1.ClosestPoint(base_point1, 0.0)\n        if not rc: raise Exception(\"ClosestPoint failed\")\n        crv1_t = t\n    arc = Rhino.Geometry.Curve.CreateFillet(curve0, curve1, radius, crv0_t, crv1_t)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddInterpCrvOnSrf(surface_id, points):\n    \"\"\"Adds an interpolated curve object that lies on a specified\n    surface.  Note, this function will not create periodic curves,\n    but it will create closed curves.\n    Parameters:\n      surface_id = identifier of the surface to create the curve on\n      points = list of 3D points that lie on the specified surface.\n               The list must contain at least 2 points\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    points = rhutil.coerce3dpointlist(points, True)\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    curve = surface.InterpolatedCurveOnSurface(points, tolerance)\n    if not curve: raise Exception(\"unable to create InterpolatedCurveOnSurface\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddInterpCrvOnSrfUV(surface_id, points):\n    \"\"\"Adds an interpolated curve object based on surface parameters,\n    that lies on a specified surface. Note, this function will not\n    create periodic curves, but it will create closed curves.\n    Parameters:\n      surface_id = identifier of the surface to create the curve on\n      points = list of 2D surface parameters. The list must contain\n               at least 2 sets of parameters\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    points = rhutil.coerce2dpointlist(points, True)\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    curve = surface.InterpolatedCurveOnSurfaceUV(points, tolerance)\n    if not curve: raise Exception(\"unable to create InterpolatedCurveOnSurfaceUV\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddInterpCurve(points, degree=3, knotstyle=0, start_tangent=None, end_tangent=None):\n    \"\"\"Adds an interpolated curve object to the document. Options exist to make\n    a periodic curve or to specify the tangent at the endpoints. The resulting\n    curve is a non-rational NURBS curve of the specified degree.\n    Parameters:\n      points = list containing 3D points to interpolate. For periodic curves,\n          if the final point is a duplicate of the initial point, it is\n          ignored. The number of control points must be >= (degree+1).\n      degree[opt] = The degree of the curve (must be >=1).\n          Periodic curves must have a degree >= 2. For knotstyle = 1 or 2,\n          the degree must be 3. For knotstyle = 4 or 5, the degree must be odd\n      knotstyle[opt]\n          0 Uniform knots.  Parameter spacing between consecutive knots is 1.0.\n          1 Chord length spacing.  Requires degree = 3 with arrCV1 and arrCVn1 specified.\n          2 Sqrt (chord length).  Requires degree = 3 with arrCV1 and arrCVn1 specified.\n          3 Periodic with uniform spacing.\n          4 Periodic with chord length spacing.  Requires an odd degree value.\n          5 Periodic with sqrt (chord length) spacing.  Requires an odd degree value.\n      start_tangent [opt] = 3d vector that specifies a tangency condition at the\n          beginning of the curve. If the curve is periodic, this argument must be omitted.\n      end_tangent [opt] = 3d vector that specifies a tangency condition at the\n          end of the curve. If the curve is periodic, this argument must be omitted.\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    if not start_tangent: start_tangent = Rhino.Geometry.Vector3d.Unset\n    start_tangent = rhutil.coerce3dvector(start_tangent, True)\n    if not end_tangent: end_tangent = Rhino.Geometry.Vector3d.Unset\n    end_tangent = rhutil.coerce3dvector(end_tangent, True)\n    curve = Rhino.Geometry.Curve.CreateInterpolatedCurve(points, degree, knotstyle, start_tangent, end_tangent)\n    if not curve: raise Exception(\"unable to CreateInterpolatedCurve\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddLine(start, end):\n    \"\"\"Adds a line curve to the current model.\n    Parameters:\n      start, end = end points of the line\n    Returns:\n      id of the new curve object\n    \"\"\"\n    start = rhutil.coerce3dpoint(start, True)\n    end = rhutil.coerce3dpoint(end, True)\n    rc = scriptcontext.doc.Objects.AddLine(start, end)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add line to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddNurbsCurve(points, knots, degree, weights=None):\n    \"\"\"Adds a NURBS curve object to the document\n    Parameters:\n      points = list containing 3D control points\n      knots = Knot values for the curve. The number of elements in knots must\n          equal the number of elements in points plus degree minus 1\n      degree = degree of the curve. must be greater than of equal to 1\n      weights[opt] = weight values for the curve. Number of elements should\n          equal the number of elements in points. Values must be greater than 0\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    cvcount = len(points)\n    knotcount = cvcount + degree - 1\n    if len(knots)!=knotcount:\n        raise Exception(\"Number of elements in knots must equal the number of elements in points plus degree minus 1\")\n    if weights and len(weights)!=cvcount:\n        raise Exception(\"Number of elements in weights should equal the number of elements in points\")\n    rational = (weights!=None)\n    \n    nc = Rhino.Geometry.NurbsCurve(3,rational,degree+1,cvcount)\n    for i in range(cvcount):\n        cp = Rhino.Geometry.ControlPoint()\n        cp.Location = points[i]\n        if weights: cp.Weight = weights[i]\n        nc.Points[i] = cp\n    for i in range(knotcount): nc.Knots[i] = knots[i]\n    rc = scriptcontext.doc.Objects.AddCurve(nc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddPolyline(points, replace_id=None):\n    \"\"\"Adds a polyline curve to the current model\n    Parameters:\n      points = list of 3D points. Duplicate, consecutive points found in\n               the array will be removed. The array must contain at least\n               two points. If the array contains less than four points,\n               then the first point and the last point must be different.\n      replace_id[opt] = If set to the id of an existing object, the object\n               will be replaced by this polyline\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    if replace_id: replace_id = rhutil.coerceguid(replace_id, True)\n    rc = System.Guid.Empty\n    if replace_id:\n        pl = Rhino.Geometry.Polyline(points)\n        if scriptcontext.doc.Objects.Replace(replace_id, pl):\n            rc = replace_id\n    else:\n        rc = scriptcontext.doc.Objects.AddPolyline(points)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add polyline to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddRectangle(plane, width, height):\n    \"\"\"Adds a rectangular curve to the document\n    Paramters:\n      plane = plane on which the rectangle will lie\n      width, height = width and height of rectangle as measured along the plane's\n        x and y axes\n    Returns:\n      id of new rectangle\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    rect = Rhino.Geometry.Rectangle3d(plane, width, height)\n    poly = rect.ToPolyline()\n    rc = scriptcontext.doc.Objects.AddPolyline(poly)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add polyline to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSubCrv(curve_id, param0, param1):\n    \"\"\"Adds a curve object based on a portion, or interval of an existing curve\n    object. Similar in operation to Rhino's SubCrv command\n    Parameters:\n      curve_id = identifier of a closed planar curve object\n      param0, param1 = first and second parameters on the source curve\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    trimcurve = curve.Trim(param0, param1)\n    if not trimcurve: raise Exception(\"unable to trim curve\")\n    rc = scriptcontext.doc.Objects.AddCurve(trimcurve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ArcAngle(curve_id, segment_index=-1):\n    \"\"\"Returns the angle of an arc curve object.\n    Parameters:\n      curve_id = identifier of a curve object\n      segment_index [opt] = identifies the curve segment if \n      curve_id identifies a polycurve\n    Returns:\n      The angle in degrees if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.AngleDegrees\n\n\ndef ArcCenterPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the center point of an arc curve object\n    Parameters:\n      curve_id = identifier of a curve object\n      segment_index [opt] = identifies the curve segment if\n      curve_id identifies a polycurve\n    Returns:\n      The 3D center point of the arc if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.Center\n\n\ndef ArcMidPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the mid point of an arc curve object\n    Parameters:\n      curve_id = identifier of a curve object\n      segment_index [opt] = identifies the curve segment if\n      curve_id identifies a polycurve\n    Returns:\n      The 3D mid point of the arc if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.MidPoint\n\n\ndef ArcRadius(curve_id, segment_index=-1):\n    \"\"\"Returns the radius of an arc curve object\n    Parameters:\n      curve_id = identifier of a curve object\n      segment_index [opt] = identifies the curve segment if \n      curve_id identifies a polycurve\n    Returns:\n      The radius of the arc if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.Radius\n\n\ndef CircleCenterPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the center point of a circle curve object\n    Parameters:\n      curve_id = identifier of a curve object\n      segment_index [opt] = identifies the curve segment if\n      curve_id identifies a polycurve\n    Returns:\n      The 3D center point of the circle if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, circle = curve.TryGetCircle(Rhino.RhinoMath.ZeroTolerance)\n    if not rc: raise Exception(\"curve is not circle\")\n    return circle.Center\n\n\ndef CircleCircumference(curve_id, segment_index=-1):\n    \"\"\"Returns the circumference of a circle curve object\n    Parameters:\n      curve_id = identifier of a curve object\n      segment_index [opt] = identifies the curve segment if\n      curve_id identifies a polycurve\n    Returns:\n      The circumference of the circle if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, circle = curve.TryGetCircle( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not circle\")\n    return circle.Circumference\n\ndef CircleRadius(curve_id, segment_index=-1):\n    \"\"\"Returns the radius of a circle curve object\n    Parameters:\n      curve_id = identifier of a curve object\n      segment_index [opt] = identifies the curve segment if\n      curve_id identifies a polycurve\n    Returns:\n      The radius of the circle if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, circle = curve.TryGetCircle( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not circle\")\n    return circle.Radius\n\ndef CloseCurve(curve_id, tolerance=-1.0):\n    \"\"\"Closes an open curve object by making adjustments to the end points so\n    they meet at a point\n    Parameters:\n      curve_id = identifier of a curve object\n      tolerance[opt] = maximum allowable distance between start and end\n          point. If omitted, the current absolute tolerance is used\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if curve.IsClosed: return curve_id\n    if tolerance<0.0: tolerance = Rhino.RhinoMath.ZeroTolerance\n    if not curve.MakeClosed(tolerance): return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\ndef ClosedCurveOrientation(curve_id, direction=(0,0,1)):\n    \"\"\"Determine the orientation (counter-clockwise or clockwise) of a closed,\n    planar curve\n    Parameters:\n      curve_id = identifier of a curve object\n      direction[opt] = 3d vector that identifies up, or Z axs, direction of\n          the plane to test against\n    Returns:\n      1 if the curve's orientation is clockwise\n      -1 if the curve's orientation is counter-clockwise\n      0 if unable to compute the curve's orientation\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1 ,True)\n    direction = rhutil.coerce3dvector(direction, True)\n    if not curve.IsClosed: return 0\n    orientation = curve.ClosedCurveOrientation(direction)\n    return int(orientation)\n\n\ndef ConvertCurveToPolyline(curve_id, angle_tolerance=5.0, tolerance=0.01, delete_input=False):\n    \"\"\"Converts a curve to a polyline curve\n    Parameters:\n      curve_id = identifier of a curve object\n      angle_tolerance [opt] = The maximum angle between curve\n        tangents at line endpoints. If omitted, the angle tolerance is set to 5.0.\n      tolerance [opt] = The distance tolerance at segment midpoints.\n        If omitted, the tolerance is set to 0.01.\n      delete_input [opt] = Delete the curve object specified by curve_id.\n        If omitted, curve_id will not be deleted.\n    Returns:\n      The new curve if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if angle_tolerance<=0: angle_tolerance = 5.0\n    angle_tolerance = Rhino.RhinoMath.ToRadians(angle_tolerance)\n    if tolerance<=0.0: tolerance = 0.01;\n    polyline_curve = curve.ToPolyline( 0, 0, angle_tolerance, 0.0, 0.0, tolerance, 0.0, 0.0, True)\n    if not polyline_curve: return scriptcontext.errorhandler()\n    id = System.Guid.Empty\n    if delete_input:\n        if scriptcontext.doc.Objects.Replace( curve_id, polyline_curve): id = curve_id\n    else:\n        id = scriptcontext.doc.Objects.AddCurve( polyline_curve )\n    if System.Guid.Empty==id: return scriptcontext.errorhandler()\n    return id\n\n  \ndef CurveArcLengthPoint(curve_id, length, from_start=True):\n    \"\"\"Returns the point on the curve that is a specified arc length\n    from the start of the curve.\n    Parameters:\n      curve_id = identifier of a curve object\n      length = The arc length from the start of the curve to evaluate.\n      from_start[opt] = If not specified or True, then the arc length point is\n          calculated from the start of the curve. If False, the arc length\n          point is calculated from the end of the curve.\n    Returns:\n      Point3d if successful\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    curve_length = curve.GetLength()\n    if curve_length>=length:\n        s = 0.0\n        if length==0.0: s = 0.0\n        elif length==curve_length: s = 1.0\n        else: s = length / curve_length\n        dupe = curve.Duplicate()\n        if dupe:\n            if from_start==False: dupe.Reverse()\n            rc, t = dupe.NormalizedLengthParameter(s)\n            if rc: return dupe.PointAt(t)\n            dupe.Dispose()\n\n\ndef CurveArea(curve_id):\n    \"\"\"Returns area of closed planar curves. The results are based on the\n    current drawing units.\n    Parameters:\n      curve_id = The identifier of a closed, planar curve object.\n    Returns:\n      List of area information. The list will contain the following information:\n        Element  Description\n        0        The area. If more than one curve was specified, the\n                 value will be the cumulative area.\n        1        The absolute (+/-) error bound for the area.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    mp = Rhino.Geometry.AreaMassProperties.Compute(curve)\n    return mp.Area, mp.AreaError\n\n\ndef CurveAreaCentroid(curve_id):\n    \"\"\"Returns area centroid of closed, planar curves. The results are based\n    on the current drawing units.\n    Parameters:\n      curve_id = The identifier of a closed, planar curve object.\n    Returns:\n      Tuple of area centroid information containing the following information:\n        Element  Description\n        0        The 3d centroid point. If more than one curve was specified,\n                 the value will be the cumulative area.\n        1        A 3d vector with the absolute (+/-) error bound for the area\n                 centroid.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    mp = Rhino.Geometry.AreaMassProperties.Compute(curve)\n    return mp.Centroid, mp.CentroidError\n\n\ndef CurveArrows(curve_id, arrow_style=None):\n    \"\"\"Enables or disables a curve object's annotation arrows\n    Parameters:\n      curve_id = identifier of a curve\n      arrow_style[opt] = the style of annotation arrow to be displayed\n        0 = no arrows\n        1 = display arrow at start of curve\n        2 = display arrow at end of curve\n        3 = display arrow at both start and end of curve\n      Returns:\n        if arrow_style is not specified, the current annotation arrow style\n        if arrow_style is specified, the previos arrow style\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rhobj = rhutil.coercerhinoobject(curve_id, True, True)\n    attr = rhobj.Attributes\n    rc = attr.ObjectDecoration\n    if arrow_style is not None:\n        if arrow_style==0:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.None\n        elif arrow_style==1:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.StartArrowhead\n        elif arrow_style==2:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.EndArrowhead\n        elif arrow_style==3:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.BothArrowhead\n        id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.ModifyAttributes(id, attr, True)\n        scriptcontext.doc.Views.Redraw()\n    if rc==Rhino.DocObjects.ObjectDecoration.None: return 0\n    if rc==Rhino.DocObjects.ObjectDecoration.StartArrowhead: return 1\n    if rc==Rhino.DocObjects.ObjectDecoration.EndArrowhead: return 2\n    if rc==Rhino.DocObjects.ObjectDecoration.BothArrowhead: return 3\n\n\ndef CurveBooleanDifference(curve_id_0, curve_id_1):\n    \"\"\"Calculates the difference between two closed, planar curves and\n    adds the results to the document. Note, curves must be coplanar.\n    Parameters:\n      curve_id_0 = identifier of the first curve object.\n      curve_id_1 = identifier of the second curve object.\n    Returns:\n      The identifiers of the new objects if successful, None on error.\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    out_curves = Rhino.Geometry.Curve.CreateBooleanDifference(curve0, curve1)\n    curves = []\n    for curve in out_curves:\n        if curve and curve.IsValid:\n            rc = scriptcontext.doc.Objects.AddCurve(curve)\n            curve.Dispose()\n            if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n            curves.append(rc)\n    scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef CurveBooleanIntersection(curve_id_0, curve_id_1):\n    \"\"\"Calculates the intersection of two closed, planar curves and adds\n    the results to the document. Note, curves must be coplanar.\n    Parameters:\n      curve_id_0 = identifier of the first curve object.\n      curve_id_1 = identifier of the second curve object.\n    Returns:\n      The identifiers of the new objects.\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    \n    out_curves = Rhino.Geometry.Curve.CreateBooleanIntersection(curve0, curve1)\n    curves = []\n    for curve in out_curves:\n        if curve and curve.IsValid:\n            rc = scriptcontext.doc.Objects.AddCurve(curve)\n            curve.Dispose()\n            if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n            curves.append(rc)\n    scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef CurveBooleanUnion(curve_id):\n    \"\"\"Calculates the union of two or more closed, planar curves and\n    adds the results to the document. Note, curves must be coplanar.\n    Parameters:\n      curve_id = list of two or more close planar curves identifiers\n    Returns:\n      The identifiers of the new objects.\n    \"\"\"\n    in_curves = [rhutil.coercecurve(id,-1,True) for id in curve_id]\n    if len(in_curves)<2: raise ValueException(\"curve_id must have at least 2 curves\")\n    out_curves = Rhino.Geometry.Curve.CreateBooleanUnion(in_curves)\n    curves = []\n    for curve in out_curves:\n        if curve and curve.IsValid:\n            rc = scriptcontext.doc.Objects.AddCurve(curve)\n            curve.Dispose()\n            if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n            curves.append(rc)\n    scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef CurveBrepIntersect(curve_id, brep_id, tolerance=None):\n    \"\"\"Intersects a curve object with a brep object. Note, unlike the\n    CurveSurfaceIntersection function, this function works on trimmed surfaces.\n    Parameters:\n      curve_id = identifier of a curve object\n      brep_id = identifier of a brep object\n      tolerance [opt] = The distance tolerance at segment midpoints.\n                        If omitted, the current absolute tolerance is used.\n    Returns:\n      List of identifiers for the newly created intersection curve and\n      point objects if successful. None on error.            \n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    brep = rhutil.coercebrep(brep_id, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, out_curves, out_points = Rhino.Geometry.Intersect.Intersection.CurveBrep(curve, brep, tolerance)\n    if not rc: return scriptcontext.errorhandler()\n    \n    curves = []\n    points = []\n    for curve in out_curves:\n        if curve and curve.IsValid:\n            rc = scriptcontext.doc.Objects.AddCurve(curve)\n            curve.Dispose()\n            if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n            curves.append(rc)\n    for point in out_points:\n        if point and point.IsValid:\n            rc = scriptcontext.doc.Objects.AddPoint(point)\n            points.append(rc)\n    scriptcontext.doc.Views.Redraw()\n    return curves, points\n\n\ndef CurveClosestObject(curve_id, object_ids):\n    \"\"\"Returns the 3D point locations on two objects where they are closest to\n    each other. Note, this function provides similar functionality to that of\n    Rhino's ClosestPt command.\n    Parameters:\n      curve_id = identifier of a closed planar curve object\n      object_ids = list of identifiers of one or more closed, planar curves\n    Returns:\n      Tuple containing the results of the closest point calculation.\n      The elements are as follows:\n        0    The identifier of the closest object.\n        1    The 3-D point that is closest to the closest object. \n        2    The 3-D point that is closest to the test curve.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id,-1,True)\n    geometry = []\n    id = rhutil.coerceguid(object_ids, False)\n    if id: object_ids = [id]\n    for object_id in object_ids:\n        rhobj = rhutil.coercerhinoobject(object_id, True, True)\n        geometry.append( rhobj.Geometry )\n    if not geometry: raise ValueError(\"object_ids must contain at least one item\")\n    success, curve_point, geom_point, which_geom = curve.ClosestPoints(geometry, 0.0)\n    if success: return object_ids[which_geom], geom_point, curve_point\n\n    \ndef CurveClosestPoint(curve_id, test_point, segment_index=-1 ):\n    \"\"\"Returns parameter of the point on a curve that is closest to a test point.\n    Parameters:\n      curve_id = identifier of a curve object\n      point = sampling point\n      segment_index [opt] = curve segment if curve_id identifies a polycurve\n    Returns:\n      The parameter of the closest point on the curve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    point = rhutil.coerce3dpoint(test_point, True)\n    rc, t = curve.ClosestPoint(point, 0.0)\n    if not rc: raise Exception(\"ClosestPoint failed\")\n    return t\n\n\ndef CurveContourPoints(curve_id, start_point, end_point, interval=None):\n    \"\"\"Returns the 3D point locations calculated by contouring a curve object.\n    Parameters:\n      curve_id = identifier of a curve object.\n      start_point = 3D starting point of a center line.\n      end_point = 3D ending point of a center line.\n      interval [opt] = The distance between contour curves. If omitted, \n      the interval will be equal to the diagonal distance of the object's\n      bounding box divided by 50.\n    Returns:\n      A list of 3D points, one for each contour\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    start_point = rhutil.coerce3dpoint(start_point, True)\n    end_point = rhutil.coerce3dpoint(end_point, True)\n    if start_point.DistanceTo(end_point)<Rhino.RhinoMath.ZeroTolerance:\n        raise Exception(\"start and end point are too close to define a line\")\n    if not interval:\n        bbox = curve.GetBoundingBox(True)\n        diagonal = bbox.Max - bbox.Min\n        interval = diagonal.Length / 50.0\n    rc = curve.DivideAsContour( start_point, end_point, interval )\n    return list(rc)\n\n\ndef CurveCurvature(curve_id, parameter):\n    \"\"\"Returns the curvature of a curve at a parameter. See the Rhino help for\n    details on curve curvature\n    Parameters:\n      curve_id = identifier of the curve\n      parameter = parameter to evaluate\n    Returns:\n      Tuple of curvature information on success\n        element 0 = point at specified parameter\n        element 1 = tangent vector\n        element 2 = center of radius of curvature\n        element 3 = radius of curvature\n        element 4 = curvature vector\n      None on failure\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    point = curve.PointAt(parameter)\n    tangent = curve.TangentAt(parameter)\n    if tangent.IsTiny(0): return scriptcontext.errorhandler()\n    cv = curve.CurvatureAt(parameter)\n    k = cv.Length\n    if k<Rhino.RhinoMath.SqrtEpsilon: return scriptcontext.errorhandler()\n    rv = cv / (k*k)\n    circle = Rhino.Geometry.Circle(point, tangent, point + 2.0*rv)\n    center = point + rv\n    radius = circle.Radius\n    return point, tangent, center, radius, cv\n\n\ndef CurveCurveIntersection(curveA, curveB, tolerance=-1):\n    \"\"\"Calculates the intersection of two curve objects.\n    Parameters:\n      curveA = The identifier of the first curve object.\n      curveB = The identifier of the second curve object. If omitted, then a\n               self-intersection test will be performed on curveA.\n      tolerance [opt] = The absolute tolerance in drawing units. If omitted,\n                        the document's current absolute tolerance is used.\n    Returns:\n      A two-dimensional list of intersection information if successful.\n      The list will contain one or more of the following elements:\n        Element Type     Description\n        (n, 0)  Number   The intersection event type, either Point (1) or Overlap (2).\n        (n, 1)  Point3d  If the event type is Point (1), then the intersection point \n                         on the first curve. If the event type is Overlap (2), then\n                         intersection start point on the first curve.\n        (n, 2)  Point3d  If the event type is Point (1), then the intersection point\n                         on the first curve. If the event type is Overlap (2), then\n                         intersection end point on the first curve.\n        (n, 3)  Point3d  If the event type is Point (1), then the intersection point \n                         on the second curve. If the event type is Overlap (2), then\n                         intersection start point on the second curve.\n        (n, 4)  Point3d  If the event type is Point (1), then the intersection point\n                         on the second curve. If the event type is Overlap (2), then\n                         intersection end point on the second curve.\n        (n, 5)  Number   If the event type is Point (1), then the first curve parameter.\n                         If the event type is Overlap (2), then the start value of the\n                         first curve parameter range.\n        (n, 6)  Number   If the event type is Point (1), then the first curve parameter.\n                         If the event type is Overlap (2), then the end value of the\n                         first curve parameter range.\n        (n, 7)  Number   If the event type is Point (1), then the second curve parameter.\n                         If the event type is Overlap (2), then the start value of the\n                         second curve parameter range.\n        (n, 8)  Number   If the event type is Point (1), then the second curve parameter.\n                         If the event type is Overlap (2), then the end value of the \n                         second curve parameter range.\n    \"\"\"\n    curveA = rhutil.coercecurve(curveA, -1, True)\n    curveB = rhutil.coercecurve(curveB, -1, True)\n    if tolerance is None or tolerance<0.0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    rc = Rhino.Geometry.Intersect.Intersection.CurveCurve(curveA, curveB, tolerance, 0.0)\n    events = []\n    if rc:\n        for i in range(rc.Count):\n            event_type = 1\n            if( rc[i].IsOverlap ): event_type = 2\n            oa = rc[i].OverlapA\n            ob = rc[i].OverlapB\n            element = (event_type, rc[i].PointA, rc[i].PointA2, rc[i].PointB, rc[i].PointB2, oa[0], oa[1], ob[0], ob[1])\n            events.append(element)\n    return events\n\n\ndef CurveDegree(curve_id, segment_index=-1):\n    \"\"\"Returns the degree of a curve object.\n    Parameters:\n      curve_id = identifier of a curve object.\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve.\n    Returns:\n      The degree of the curve if successful. None on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.Degree\n\n\ndef CurveDeviation(curve_a, curve_b):\n    \"\"\"Returns the minimum and maximum deviation between two curve objects\n    Parameters:\n      curve_a, curve_b = identifiers of two curves\n    Returns:\n      tuple of deviation information on success\n        element 0 = curve_a parameter at maximum overlap distance point\n        element 1 = curve_b parameter at maximum overlap distance point\n        element 2 = maximum overlap distance\n        element 3 = curve_a parameter at minimum overlap distance point\n        element 4 = curve_b parameter at minimum overlap distance point\n        element 5 = minimum distance between curves\n      None on error\n    \"\"\"\n    curve_a = rhutil.coercecurve(curve_a, -1, True)\n    curve_b = rhutil.coercecurve(curve_b, -1, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc = Rhino.Geometry.Curve.GetDistancesBetweenCurves(curve_a, curve_b, tol)\n    if not rc[0]: return scriptcontext.errorhandler()\n    maxa = rc[2]\n    maxb = rc[3]\n    maxd = rc[1]\n    mina = rc[5]\n    minb = rc[6]\n    mind = rc[4]\n    return maxa, maxb, maxd, mina, minb, mind\n\n\ndef CurveDim(curve_id, segment_index=-1):\n    \"\"\"Returns the dimension of a curve object\n    Parameters:\n      curve_id = identifier of a curve object.\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve.\n    Returns:\n      The dimension of the curve if successful. None on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.Dimension\n\n\ndef CurveDirectionsMatch(curve_id_0, curve_id_1):\n    \"\"\"Tests if two curve objects are generally in the same direction or if they\n    would be more in the same direction if one of them were flipped. When testing\n    curve directions, both curves must be either open or closed - you cannot test\n    one open curve and one closed curve.\n    Parameters:\n      curve_id_0 = identifier of first curve object\n      curve_id_1 = identifier of second curve object\n    Returns:\n      True if the curve directions match, otherwise False. \n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    return Rhino.Geometry.Curve.DoDirectionsMatch(curve0, curve1)\n\n\ndef CurveDiscontinuity(curve_id, style):   \n    \"\"\"Search for a derivatitive, tangent, or curvature discontinuity in\n    a curve object.\n    Parameters:\n      curve_id = identifier of curve object\n      style = The type of continuity to test for. The types of\n          continuity are as follows:\n          Value    Description\n          1        C0 - Continuous function\n          2        C1 - Continuous first derivative\n          3        C2 - Continuous first and second derivative\n          4        G1 - Continuous unit tangent\n          5        G2 - Continuous unit tangent and curvature\n    Returns:\n      List 3D points where the curve is discontinuous\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    dom = curve.Domain\n    t0 = dom.Min\n    t1 = dom.Max\n    points = []\n    get_next = True\n    while get_next:\n        get_next, t = curve.GetNextDiscontinuity(System.Enum.ToObject(Rhino.Geometry.Continuity, style), t0, t1)\n        if get_next:\n            points.append(curve.PointAt(t))\n            t0 = t # Advance to the next parameter\n    return points\n\n\ndef CurveDomain(curve_id, segment_index=-1):\n    \"\"\"Returns the domain of a curve object.\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index[opt] = the curve segment if curve_id identifies a polycurve.\n    Returns:\n      The domain of the curve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    dom = curve.Domain\n    return dom.Min, dom.Max\n\n\ndef CurveEditPoints(curve_id, return_parameters=False, segment_index=-1):\n    \"\"\"Returns the edit, or Greville, points of a curve object. \n    For each curve control point, there is a corresponding edit point.\n    Parameters:\n      curve_id = identifier of the curve object\n      return_parameters[opt] = if True, return as a list of curve parameters.\n        If False, return as a list of 3d points\n      segment_index[opt] = the curve segment is curve_id identifies a polycurve\n    Returns:\n      a list of curve parameters of 3d points on success\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if not nc: return scriptcontext.errorhandler()\n    if return_parameters: return nc.GrevilleParameters()\n    return nc.GrevillePoints()\n\n\ndef CurveEndPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the end point of a curve object\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      The 3-D end point of the curve if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.PointAtEnd\n\n\ndef CurveFilletPoints(curve_id_0, curve_id_1, radius=1.0, base_point_0=None, base_point_1=None, return_points=True):\n    \"\"\"Find points at which to cut a pair of curves so that a fillet of a\n    specified radius fits. A fillet point is a pair of points (point0, point1)\n    such that there is a circle of radius tangent to curve curve0 at point0 and\n    tangent to curve curve1 at point1. Of all possible fillet points, this\n    function returns the one which is the closest to the base point base_point_0,\n    base_point_1. Distance from the base point is measured by the sum of arc\n    lengths along the two curves. \n    Parameters:\n      curve_id_0 = identifier of the first curve object.\n      curve_id_1 = identifier of the second curve object.\n      radius [opt] = The fillet radius. If omitted, a radius\n                     of 1.0 is specified.\n      base_point_0 [opt] = The base point on the first curve.\n                     If omitted, the starting point of the curve is used.\n      base_point_1 [opt] = The base point on the second curve. If omitted,\n                     the starting point of the curve is used.\n      return_points [opt] = If True (Default), then fillet points are\n                     returned. Otherwise, a fillet curve is created and\n                     it's identifier is returned.\n    Returns:\n      If return_points is True, then a list of point and vector values\n      if successful. The list elements are as follows:\n      \n      0    A point on the first curve at which to cut (arrPoint0).\n      1    A point on the second curve at which to cut (arrPoint1).\n      2    The fillet plane's origin (3-D point). This point is also\n           the center point of the fillet\n      3    The fillet plane's X axis (3-D vector).\n      4    The fillet plane's Y axis (3-D vector).\n      5    The fillet plane's Z axis (3-D vector).\n      \n      If return_points is False, then the identifier of the fillet curve\n      if successful.\n      None if not successful, or on error.                  \n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    t0_base = curve0.Domain.Min\n    \n    if base_point_0:\n        rc = curve0.ClosestPoint(base_point_0, t0_base)\n        if not rc[0]: return scriptcontext.errorhandler()\n    \n    t1_base = curve1.Domain.Min\n    if base_point_1:\n        rc = curve1.ClosestPoint(base_point_1, t1_base)\n        if not rc[0]: return scriptcontext.errorhandler()\n\n    r = radius if (radius and radius>0) else 1.0\n    rc = Rhino.Geometry.Curve.GetFilletPoints(curve0, curve1, r, t0_base, t1_base)\n    if rc[0]:\n        point_0 = curve0.PointAt(rc[1])\n        point_1 = curve1.PointAt(rc[2])\n        return point_0, point_1, rc[3].Origin, rc[3].XAxis, rc[3].YAxis, rc[3].ZAxis\n    return scriptcontext.errorhandler()\n\n\ndef CurveFrame(curve_id, parameter, segment_index=-1):\n    \"\"\"Returns the plane at a parameter of a curve. The plane is based on the\n    tangent and curvature vectors at a parameter.\n    Parameters:\n      curve_id = identifier of the curve object.\n      parameter = parameter to evaluate.\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      The plane at the specified parameter if successful. \n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    domain = curve.Domain\n    if not domain.IncludesParameter(parameter):\n        tol = scriptcontext.doc.ModelAbsoluteTolerance\n        if parameter>domain.Max and (parameter-domain.Max)<=tol:\n            parameter = domain.Max\n        elif parameter<domain.Min and (domain.Min-parameter)<=tol:\n            parameter = domain.Min\n        else:\n            return scriptcontext.errorhandler()\n    rc, frame = curve.FrameAt(parameter)\n    if rc and frame.IsValid: return frame\n    return scriptcontext.errorhandler()\n\n\ndef CurveKnotCount(curve_id, segment_index=-1):\n    \"\"\"Returns the knot count of a curve object.\n    Parameters:\n      curve_id = identifier of the curve object.\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve.\n    Returns:\n      The number of knots if successful.\n      None if not successful or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if not nc: return scriptcontext.errorhandler()\n    return nc.Knots.Count\n\n\ndef CurveKnots(curve_id, segment_index=-1):\n    \"\"\"Returns the knots, or knot vector, of a curve object\n    Parameters:\n      curve_id = identifier of the curve object.\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve.\n    Returns:\n      knot values if successful.\n      None if not successful or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if not nc: return scriptcontext.errorhandler()\n    rc = [nc.Knots[i] for i in range(nc.Knots.Count)]\n    return rc\n\n\ndef CurveLength(curve_id, segment_index=-1, sub_domain=None):\n    \"\"\"Returns the length of a curve object.\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n      sub_domain [opt] = list of two numbers identifing the sub-domain of the\n          curve on which the calculation will be performed. The two parameters\n          (sub-domain) must be non-decreasing. If omitted, the length of the\n          entire curve is returned.\n    Returns:\n      The length of the curve if successful.\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    if sub_domain:\n        if len(sub_domain)==2:\n            dom = Rhino.Geometry.Interval(sub_domain[0], sub_domain[1])\n            return curve.GetLength(dom)\n        return scriptcontext.errorhandler()\n    return curve.GetLength()\n\n\ndef CurveMidPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the mid point of a curve object.\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      The 3D mid point of the curve if successful.\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, t = curve.NormalizedLengthParameter(0.5)\n    if rc: return curve.PointAt(t)\n    return scriptcontext.errorhandler()\n\n\ndef CurveNormal(curve_id, segment_index=-1):\n    \"\"\"Returns the normal direction of the plane in which a planar curve object lies.\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      The 3D normal vector if sucessful.\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, plane = curve.TryGetPlane(tol)\n    if rc: return plane.Normal\n    return scriptcontext.errorhandler()\n\n\ndef CurveNormalizedParameter(curve_id, parameter):\n    \"\"\"Converts a curve parameter to a normalized curve parameter;\n    one that ranges between 0-1\n    Parameters:\n      curve_id = identifier of the curve object\n      parameter = the curve parameter to convert\n    Returns:\n      normalized curve parameter\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    return curve.Domain.NormalizedParameterAt(parameter)\n\n\ndef CurveParameter(curve_id, parameter):\n    \"\"\"Converts a normalized curve parameter to a curve parameter;\n    one within the curve's domain\n    Parameters:\n      curve_id = identifier of the curve object\n      parameter = the normalized curve parameter to convert\n    Returns:\n      curve parameter\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    return curve.Domain.ParameterAt(parameter)\n\n\ndef CurvePerpFrame(curve_id, parameter):\n    \"\"\"Returns the perpendicular plane at a parameter of a curve. The result\n    is relatively parallel (zero-twisting) plane\n    Parameters:\n      curve_id = identifier of the curve object\n      parameter = parameter to evaluate\n    Returns:\n      Plane on success\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    parameter = float(parameter)\n    params = (parameter, parameter+0.05)\n    if parameter>0.9: params = (parameter-0.05, parameter)\n    planes = curve.GetPerpendicularFrames(params)\n    if planes is None or len(planes)<2: return scriptcontext.errorhandler()\n    if parameter>0.9: return planes[1]\n    return planes[0]\n\n\ndef CurvePlane(curve_id, segment_index=-1):\n    \"\"\"Returns the plane in which a planar curve lies. Note, this function works\n    only on planar curves.\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index[opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      The plane in which the curve lies if successful.\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, plane = curve.TryGetPlane(tol)\n    if rc: return plane\n    return scriptcontext.errorhandler()\n\n\ndef CurvePointCount(curve_id, segment_index=-1):\n    \"\"\"Returns the control points count of a curve object.\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      Number of control points if successful.\n      None if not successful\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if nc: return nc.Points.Count\n    return scriptcontext.errorhandler()\n\n\ndef CurvePoints(curve_id, segment_index=-1):\n    \"\"\"Returns the control points, or control vertices, of a curve object.\n    If the curve is a rational NURBS curve, the euclidean control vertices\n    are returned.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if nc is None: return scriptcontext.errorhandler()\n    points = [nc.Points[i].Location for i in range(nc.Points.Count)]\n    return points\n\n\ndef CurveRadius(curve_id, test_point, segment_index=-1):\n    \"\"\"Returns the radius of curvature at a point on a curve.\n    Parameters:\n      curve_id = identifier of the curve object\n      test_point = sampling point\n      segment_index[opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      The radius of curvature at the point on the curve if successful.\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    point = rhutil.coerce3dpoint(test_point, True)\n    rc, t = curve.ClosestPoint(point, 0.0)\n    if not rc: return scriptcontext.errorhandler()\n    v = curve.CurvatureAt( t )\n    k = v.Length()\n    if k>Rhino.RhinoMath.ZeroTolerance: return 1/k\n    return scriptcontext.errorhandler()\n\n\ndef CurveSeam(curve_id, parameter):\n    \"\"\"Adjusts the seam, or start/end, point of a closed curve.\n    Parameters:\n      curve_id = identifier of the curve object\n      parameter = The parameter of the new start/end point. \n                  Note, if successful, the resulting curve's\n                  domain will start at dblParameter.\n    Returns:\n      True or False indicating success or failure.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if (not curve.IsClosed or not curve.Domain.IncludesParameter(parameter)):\n        return False\n    dupe = curve.Duplicate()\n    if dupe:\n        dupe.ChangeClosedCurveSeam(parameter)\n        curve_id = rhutil.coerceguid(curve_id)\n        dupe_obj = scriptcontext.doc.Objects.Replace(curve_id, dupe)\n        return dupe_obj is not None\n    return False\n\n\ndef CurveStartPoint(curve_id, segment_index=-1, point=None):\n    \"\"\"Returns the start point of a curve object\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n      point [opt] = new start point\n    Returns:\n      The 3D starting point of the curve if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc = curve.PointAtStart\n    if point:\n        point = rhutil.coerce3dpoint(point, True)\n        if point and curve.SetStartPoint(point):\n            curve_id = rhutil.coerceguid(curve_id, True)\n            scriptcontext.doc.Objects.Replace(curve_id, curve)\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef CurveSurfaceIntersection(curve_id, surface_id, tolerance=-1, angle_tolerance=-1):\n    \"\"\"Calculates the intersection of a curve object with a surface object.\n    Note, this function works on the untrimmed portion of the surface.\n    Parameters:\n      curve_id = The identifier of the first curve object.\n      surface_id = The identifier of the second curve object. If omitted,\n          the a self-intersection test will be performed on curve.\n      tolerance [opt] = The absolute tolerance in drawing units. If omitted, \n          the document's current absolute tolerance is used.\n      angle_tolerance [opt] = The angle tolerance in degrees. The angle\n          tolerance is used to determine when the curve is tangent to the\n          surface. If omitted, the document's current angle tolerance is used.\n    Returns:\n      A two-dimensional list of intersection information if successful.\n      The list will contain one or more of the following elements:\n        Element Type     Description\n        (n, 0)  Number   The intersection event type, either Point(1) or Overlap(2).\n        (n, 1)  Point3d  If the event type is Point(1), then the intersection point \n                         on the first curve. If the event type is Overlap(2), then\n                         intersection start point on the first curve.\n        (n, 2)  Point3d  If the event type is Point(1), then the intersection point\n                         on the first curve. If the event type is Overlap(2), then\n                         intersection end point on the first curve.\n        (n, 3)  Point3d  If the event type is Point(1), then the intersection point \n                         on the second curve. If the event type is Overlap(2), then\n                         intersection start point on the surface.\n        (n, 4)  Point3d  If the event type is Point(1), then the intersection point\n                         on the second curve. If the event type is Overlap(2), then\n                         intersection end point on the surface.\n        (n, 5)  Number   If the event type is Point(1), then the first curve parameter.\n                         If the event type is Overlap(2), then the start value of the\n                         first curve parameter range.\n        (n, 6)  Number   If the event type is Point(1), then the first curve parameter.\n                         If the event type is Overlap(2), then the end value of the\n                         curve parameter range.\n        (n, 7)  Number   If the event type is Point(1), then the U surface parameter.\n                         If the event type is Overlap(2), then the U surface parameter\n                         for curve at (n, 5).\n        (n, 8)  Number   If the event type is Point(1), then the V surface parameter.\n                         If the event type is Overlap(2), then the V surface parameter\n                         for curve at (n, 5).\n        (n, 9)  Number   If the event type is Point(1), then the U surface parameter.\n                         If the event type is Overlap(2), then the U surface parameter\n                         for curve at (n, 6).\n        (n, 10) Number   If the event type is Point(1), then the V surface parameter.\n                         If the event type is Overlap(2), then the V surface parameter\n                         for curve at (n, 6).\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    surface = rhutil.coercesurface(surface_id, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if angle_tolerance is None or angle_tolerance<0:\n        angle_tolerance = scriptcontext.doc.ModelAngleToleranceRadians\n    else:\n        angle_tolerance = math.radians(angle_tolerance)\n    rc = Rhino.Geometry.Intersect.Intersection.CurveSurface(curve, surface, tolerance, angle_tolerance)\n    events = []\n    if rc:\n      for i in range(rc.Count):\n          event_type = 2 if rc[i].IsOverlap else 1\n          item = rc[i]\n          oa = item.OverlapA\n          u,v = item.SurfaceOverlapParameter()\n          e = (event_type, item.PointA, item.PointA2, item.PointB, item.PointB2, oa[0], oa[1], u[0], u[1], v[0], v[1])\n          events.append(e)\n    return events\n\n\ndef CurveTangent(curve_id, parameter, segment_index=-1):\n    \"\"\"Returns a 3D vector that is the tangent to a curve at a parameter.\n    Parameters:\n      curve_id = identifier of the curve object\n      parameter = parameter to evaluate\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      A 3D vector if successful.\n      None on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc = Rhino.Geometry.Point3d.Unset\n    if curve.Domain.IncludesParameter(parameter):\n        return curve.TangentAt(parameter)\n    return scriptcontext.errorhandler()\n\n\ndef CurveWeights(curve_id, segment_index=-1):\n    \"\"\"Returns list of weights that are assigned to the control points of a curve\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index[opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      The weight values of the curve if successful.\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve\n    if type(curve) is not Rhino.Geometry.NurbsCurve:\n        nc = curve.ToNurbsCurve()\n    if nc is None: return scriptcontext.errorhandler()\n    return [pt.Weight for pt in nc.Points]\n\n\ndef DivideCurve(curve_id, segments, create_points=False, return_points=True):\n    \"\"\"Divides a curve object into a specified number of segments.\n    Parameters:\n      curve_id = identifier of the curve object\n      segments = The number of segments.\n      create_points [opt] = Create the division points. If omitted or False,\n          points are not created.\n      return_points [opt] = If omitted or True, points are returned.\n          If False, then a list of curve parameters are returned.\n    Returns:\n      If return_points is not specified or True, then a list containing 3D\n      division points.\n      If return_points is False, then an array containing division curve\n      parameters.\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc = curve.DivideByCount(segments, True)\n    if not rc: return scriptcontext.errorhandler()\n    if return_points or create_points:\n        outputpoints = [curve.PointAt(t) for t in rc]\n        if return_points: rc = outputpoints\n        if create_points:\n            for point in outputpoints:\n                if point.IsValid: scriptcontext.doc.Objects.AddPoint(point)\n    return rc\n\n\ndef DivideCurveEquidistant(curve_id, distance, create_points=False, return_points=True):\n    \"\"\"Divides a curve such that the linear distance between the points is equal.\n    Parameters:\n      curve_id = the object's identifier\n      distance = linear distance between division points\n      create_points[opt] = create the division points\n      return_points[opt] = If True, return a list of points.\n          If False, return a list of curve parameters\n    Returns:\n      A list of points or curve parameters based on the value of return_points\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    points = curve.DivideEquidistant(distance)\n    if not points: return scriptcontext.errorhandler()\n    if create_points:\n        for point in points: scriptcontext.doc.Objects.AddPoint(point)\n        scriptcontext.doc.Views.Redraw()\n    if return_points: return points\n    tvals = []\n    for point in points:\n        rc, t = curve.ClosestPoint(point)\n        tvals.append(t)\n    return tvals\n\n\ndef DivideCurveLength(curve_id, length, create_points=False, return_points=True):\n    \"\"\"Divides a curve object into segments of a specified length.\n    Parameters:\n      curve_id = identifier of the curve object\n      length = The length of each segment.\n      create_points [opt] = Create the division points. If omitted or False,\n          points are not created.\n      return_points [opt] = If omitted or True, points are returned.\n          If False, then a list of curve parameters are returned.\n    Returns:\n      If return_points is not specified or True, then a list containing 3D\n      division points if successful.\n      If return_points is False, then an array containing division curve\n      parameters if successful.\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc = curve.DivideByLength(length, True)\n    if not rc: return scriptcontext.errorhandler()\n    if return_points or create_points:\n        outputpoints = [curve.PointAt(t) for t in rc]\n        if create_points:\n            for point in outputpoints:\n                if (point.IsValid): scriptcontext.doc.Objects.AddPoint(point)\n        if return_points: rc = outputpoints\n    return rc\n\n\ndef EllipseCenterPoint(curve_id):\n    \"\"\"Returns the center point of an elliptical-shaped curve object.\n    Parameters:\n      curve_id = identifier of the curve object.    \n    Returns:\n      The 3D center point of the ellipse if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc, ellipse = curve.TryGetEllipse()\n    if not rc: raise ValueError(\"curve is not an ellipse\")\n    return ellipse.Plane.Origin\n\n\ndef EllipseQuadPoints(curve_id):\n    \"\"\"Returns the quadrant points of an elliptical-shaped curve object.\n    Parameters:\n      curve_id = identifier of the curve object.\n    Returns:\n      Four 3D points identifying the quadrants of the ellipse\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc, ellipse = curve.TryGetEllipse()\n    if not rc: raise ValueError(\"curve is not an ellipse\")\n    origin = ellipse.Plane.Origin;\n    xaxis = ellipse.Radius1 * ellipse.Plane.XAxis;\n    yaxis = ellipse.Radius2 * ellipse.Plane.YAxis;\n    return (origin-xaxis, origin+xaxis, origin-yaxis, origin+yaxis)\n\n\ndef EvaluateCurve(curve_id, t, segment_index=-1):\n    \"\"\"Evaluates a curve at a parameter and returns a 3D point\n    Parameters:\n      curve_id = identifier of the curve object\n      t = the parameter to evaluate\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.PointAt(t)\n\n\ndef ExplodeCurves(curve_ids, delete_input=False):\n    \"\"\"Explodes, or un-joins, one curves. Polycurves will be exploded into curve\n    segments. Polylines will be exploded into line segments. ExplodeCurves will\n    return the curves in topological order. \n    Parameters:\n      curve_ids = the curve object(s) to explode.\n      delete_input[opt] = Delete input objects after exploding.\n    Returns:\n      List identifying the newly created curve objects\n    \"\"\"\n    if( type(curve_ids) is list or type(curve_ids) is tuple ): pass\n    else: curve_ids = [curve_ids]\n    rc = []\n    for id in curve_ids:\n        curve = rhutil.coercecurve(id, -1, True)\n        pieces = curve.DuplicateSegments()\n        if pieces:\n            for piece in pieces:\n                rc.append(scriptcontext.doc.Objects.AddCurve(piece))\n            if delete_input:\n                id = rhutil.coerceguid(id, True)\n                scriptcontext.doc.Objects.Delete(id, True)\n    if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ExtendCurve(curve_id, extension_type, side, boundary_object_ids):\n    \"\"\"Extends a non-closed curve object by a line, arc, or smooth extension\n    until it intersects a collection of objects.\n    Parameters:\n      curve_id: identifier of curve to extend\n      extension_type: 0 = line, 1 = arc, 2 = smooth\n      side: 0=extend from the start of the curve, 1=extend from the end of the curve\n      boundary_object_ids: curve, surface, and polysurface objects to extend to\n    Returns:\n      The identifier of the new object if successful.\n      None if not successful\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if extension_type==0: extension_type = Rhino.Geometry.CurveExtensionStyle.Line\n    elif extension_type==1: extension_type = Rhino.Geometry.CurveExtensionStyle.Arc\n    elif extension_type==2: extension_type = Rhino.Geometry.CurveExtensionStyle.Smooth\n    else: raise ValueError(\"extension_type must be 0, 1, or 2\")\n    \n    if side==0: side = Rhino.Geometry.CurveEnd.Start\n    elif side==1: side = Rhino.Geometry.CurveEnd.End\n    elif side==2: side = Rhino.Geometry.CurveEnd.Both\n    else: raise ValueError(\"side must be 0, 1, or 2\")\n    \n    rhobjs = [rhutil.coercerhinoobject(id) for id in boundary_object_ids]\n    if not rhobjs: raise ValueError(\"boundary_object_ids must contain at least one item\")\n    geometry = [obj.Geometry for obj in rhobjs]\n    newcurve = curve.Extend(side, extension_type, geometry)\n    if newcurve and newcurve.IsValid:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        if scriptcontext.doc.Objects.Replace(curve_id, newcurve):\n            scriptcontext.doc.Views.Redraw()\n            return curve_id\n    return scriptcontext.errorhandler()\n\n\ndef ExtendCurveLength(curve_id, extension_type, side, length):\n    \"\"\"Extends a non-closed curve object by a line, arc, or smooth extension\n    for a specified distance\n    Parameters:\n      curve_id: identifier of curve to extend\n      extension_type: 0 = line, 1 = arc, 2 = smooth\n      side: 0=extend from start of the curve, 1=extend from end of the curve\n      length: distance to extend\n    Returns:\n      The identifier of the new object\n      None if not successful\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if extension_type==0: extension_type = Rhino.Geometry.CurveExtensionStyle.Line\n    elif extension_type==1: extension_type = Rhino.Geometry.CurveExtensionStyle.Arc\n    elif extension_type==2: extension_type = Rhino.Geometry.CurveExtensionStyle.Smooth\n    else: raise ValueError(\"extension_type must be 0, 1, or 2\")\n    \n    if side==0: side = Rhino.Geometry.CurveEnd.Start\n    elif side==1: side = Rhino.Geometry.CurveEnd.End\n    elif side==2: side = Rhino.Geometry.CurveEnd.Both\n    else: raise ValueError(\"side must be 0, 1, or 2\")\n    \n    newcurve = curve.Extend(side, length, extension_type)\n    if newcurve and newcurve.IsValid:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        if scriptcontext.doc.Objects.Replace(curve_id, newcurve):\n            scriptcontext.doc.Views.Redraw()\n            return curve_id\n    return scriptcontext.errorhandler()\n\n\ndef ExtendCurvePoint(curve_id, side, point):\n    \"\"\"Extends a non-closed curve object by smooth extension to a point\n    Parameters:\n      curve_id: identifier of curve to extend\n      side: 0=extend from start of the curve, 1=extend from end of the curve\n      point: point to extend to\n    Returns:\n      The identifier of the new object if successful.\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    point = rhutil.coerce3dpoint(point, True)\n    \n    if side==0: side = Rhino.Geometry.CurveEnd.Start\n    elif side==1: side = Rhino.Geometry.CurveEnd.End\n    elif side==2: side = Rhino.Geometry.CurveEnd.Both\n    else: raise ValueError(\"side must be 0, 1, or 2\")\n    \n    extension_type = Rhino.Geometry.CurveExtensionStyle.Smooth\n    newcurve = curve.Extend(side, extension_type, point)\n    if newcurve and newcurve.IsValid:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        if scriptcontext.doc.Objects.Replace( curve_id, newcurve ):\n            scriptcontext.doc.Views.Redraw()\n            return curve_id\n    return scriptcontext.errorhandler()\n\n\ndef FairCurve(curve_id, tolerance=1.0):\n    \"\"\"Fairs a curve object. Fair works best on degree 3 (cubic) curves. Fair\n    attempts to remove large curvature variations while limiting the geometry\n    changes to be no more than the specified tolerance. Sometimes several\n    applications of this method are necessary to remove nasty curvature problems.\n    Parameters:\n      curve_id = identifier of the curve object\n      tolerance[opt] = fairing tolerance\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    angle_tol = 0.0\n    clamp = 0\n    if curve.IsPeriodic:\n        curve = curve.ToNurbsCurve()\n        clamp = 1\n    newcurve = curve.Fair(tolerance, angle_tol, clamp, clamp, 100)\n    if not newcurve: return False\n    curve_id = rhutil.coerceguid(curve_id, True)\n    if scriptcontext.doc.Objects.Replace(curve_id, newcurve):\n        scriptcontext.doc.Views.Redraw()\n        return True\n    return False\n\n\ndef FitCurve(curve_id, degree=3, distance_tolerance=-1, angle_tolerance=-1):\n    \"\"\"Reduces number of curve control points while maintaining the curve's same\n    general shape. Use this function for replacing curves with many control\n    points. For more information, see the Rhino help for the FitCrv command.\n    Parameters:\n      curve_id = Identifier of the curve object\n      degree [opt] = The curve degree, which must be greater than 1.\n                     The default is 3.\n      distance_tolerance [opt] = The fitting tolerance. If distance_tolerance\n          is not specified or <= 0.0, the document absolute tolerance is used.\n      angle_tolerance [opt] = The kink smoothing tolerance in degrees. If\n          angle_tolerance is 0.0, all kinks are smoothed. If angle_tolerance\n          is > 0.0, kinks smaller than angle_tolerance are smoothed. If\n          angle_tolerance is not specified or < 0.0, the document angle\n          tolerance is used for the kink smoothing.\n    Returns:\n      The identifier of the new object\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if distance_tolerance is None or distance_tolerance<0:\n        distance_tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if angle_tolerance is None or angle_tolerance<0:\n        angle_tolerance = scriptcontext.doc.ModelAngleToleranceRadians\n    nc = curve.Fit(degree, distance_tolerance, angle_tolerance)\n    if nc:\n        rhobj = rhutil.coercerhinoobject(curve_id)\n        rc = None\n        if rhobj:\n            rc = scriptcontext.doc.Objects.AddCurve(curve, rhobj.Attributes)\n        else:\n            rc = scriptcontext.doc.Objects.AddCurve(curve)\n        if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n        scriptcontext.doc.Views.Redraw()\n        return rc\n    return scriptcontext.errorhandler()\n\n\ndef InsertCurveKnot(curve_id, parameter, symmetrical=False ):\n    \"\"\"Inserts a knot into a curve object\n    Parameters:\n      curve_id = identifier of the curve object\n      parameter = parameter on the curve\n      symmetrical[opt] = if True, then knots are added on both sides of\n          the center of the curve\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if not curve.Domain.IncludesParameter(parameter): return False\n    nc = curve.ToNurbsCurve()\n    if not nc: return False\n    rc, t = curve.GetNurbsFormParameterFromCurveParameter(parameter)\n    if rc:\n        rc = nc.Knots.InsertKnot(t,1)\n        if rc and symmetrical:\n            domain = nc.Domain\n            t_sym = domain.T1 - t + domain.T0\n            if abs(t_sym)>Rhino.RhinoMath.SqrtEpsilon:\n                rc = nc.Knots.InsertKnot(t_sym,1)\n        if rc:\n            curve_id = rhutil.coerceguid(curve_id)\n            rc = scriptcontext.doc.Objects.Replace(curve_id, nc)\n            if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef IsArc(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is an arc curve\n    Parameters:\n      curve_id = Identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.IsArc()\n\n\ndef IsCircle(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a circle curve\n    Parameters:\n      curve_id = Identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.IsCircle()\n\n\ndef IsCurve(object_id):\n    \"Verifies an object is a curve\"\n    curve = rhutil.coercecurve(object_id)\n    return curve is not None\n\n\ndef IsCurveClosable(curve_id, tolerance=None):\n    \"\"\"Decide if it makes sense to close off the curve by moving the end point\n    to the start point based on start-end gap size and length of curve as\n    approximated by chord defined by 6 points\n    Parameters:\n      curve_id = identifier of the curve object\n      tolerance[opt] = maximum allowable distance between start point and end\n        point. If omitted, the document's current absolute tolerance is used\n    Returns:\n      True or False\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if tolerance is None: tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    return curve.IsClosable(tolerance)\n\n\ndef IsCurveClosed(object_id):\n    curve = rhutil.coercecurve(object_id, -1, True)\n    return curve.IsClosed\n\n\ndef IsCurveInPlane(object_id, plane=None):\n    \"\"\"Test a curve to see if it lies in a specific plane\n    Parameters:\n      object_id = the object's identifier\n      plane[opt] = plane to test. If omitted, the active construction plane is used\n    Returns:\n      True or False\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, -1, True)\n    if not plane:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    else:\n        plane = rhutil.coerceplane(plane, True)\n    return curve.IsInPlane(plane, scriptcontext.doc.ModelAbsoluteTolerance)\n\n\ndef IsCurveLinear(object_id, segment_index=-1):\n    \"\"\"Verifies an object is a linear curve\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return curve.IsLinear()\n\n\ndef IsCurvePeriodic(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a periodic curve object\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.IsPeriodic\n\n\ndef IsCurvePlanar(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a planar curve\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    return curve.IsPlanar(tol)\n\n\ndef IsCurveRational(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a rational NURBS curve\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    if isinstance(curve, Rhino.Geometry.NurbsCurve): return curve.IsRational\n    return False\n\n\ndef IsEllipse(object_id):\n    \"\"\"Verifies an object is an elliptical-shaped curve\n    Parameters:\n      curve_id = identifier of the curve object\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return curve.IsEllipse()\n\n\ndef IsLine(object_id, segment_index=-1):\n    \"\"\"Verifies an object is a line curve\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return isinstance(curve, Rhino.Geometry.LineCurve)\n\n\ndef IsPointOnCurve(object_id, point, segment_index=-1):\n    \"\"\"Verifies that a point is on a curve\n    Parameters:\n      curve_id = identifier of the curve object\n      point = the test point\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    point = rhutil.coerce3dpoint(point, True)\n    rc, t = curve.ClosestPoint(point, Rhino.RhinoMath.SqrtEpsilon)\n    return rc\n\n\ndef IsPolyCurve(object_id, segment_index=-1):\n    \"\"\"Verifies an object is a PolyCurve curve\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return isinstance(curve, Rhino.Geometry.PolyCurve)\n\n\ndef IsPolyline( object_id, segment_index=-1 ):\n    \"\"\"Verifies an object is a Polyline curve object\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return isinstance(curve, Rhino.Geometry.PolylineCurve)\n\n\ndef JoinCurves(object_ids, delete_input=False, tolerance=None):\n    \"\"\"Joins multiple curves together to form one or more curves or polycurves\n    Parameters:\n      object_ids = list of identifiers of multiple curve objects\n      delete_input[opt] = delete input objects after joining\n      tolerance[opt] = join tolerance. If omitted, 2.1 * document absolute\n          tolerance is used\n    Returns:\n      List of Guids representing the new curves\n    \"\"\"\n    if len(object_ids)<2: raise ValueError(\"object_ids must contain at least 2 items\")\n    curves = [rhutil.coercecurve(id, -1, True) for id in object_ids]\n    if tolerance is None:\n        tolerance = 2.1 * scriptcontext.doc.ModelAbsoluteTolerance\n    newcurves = Rhino.Geometry.Curve.JoinCurves(curves, tolerance)\n    rc = []\n    if newcurves:\n        rc = [scriptcontext.doc.Objects.AddCurve(crv) for crv in newcurves]\n    if rc and delete_input:\n        for id in object_ids:\n            id = rhutil.coerceguid(id, True)\n            scriptcontext.doc.Objects.Delete(id, False)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef LineFitFromPoints(points):\n    \"\"\"Returns a line that was fit through an array of 3D points\n    Parameters:\n      points = a list of at least two 3D points\n    Returns:\n      line on success\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    rc, line = Rhino.Geometry.Line.TryFitLineToPoints(points)\n    if rc: return line\n    return scriptcontext.errorhandler()\n\n\ndef MakeCurveNonPeriodic(curve_id, delete_input=False):\n    \"\"\"Makes a periodic curve non-periodic. Non-periodic curves can develop\n    kinks when deformed\n    Parameters:\n      curve_id = identifier of the curve object\n      delete_input[opt] = delete the input curve\n    Returns:\n      id of the new or modified curve if successful\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if not curve.IsPeriodic: return scriptcontext.errorhandler()\n    nc = curve.ToNurbsCurve()\n    if nc is None: return scriptcontext.errorhandler()\n    nc.Knots.ClampEnd( Rhino.Geometry.CurveEnd.Both )\n    rc = None\n    if delete_input:\n        if type(curve_id) is Rhino.DocObjects.ObjRef: pass\n        else: curve_id = rhutil.coerceguid(curve_id)\n        if curve_id:\n            rc = scriptcontext.doc.Objects.Replace(curve_id, nc)\n            if not rc: return scriptcontext.errorhandler()\n            rc = rhutil.coerceguid(curve_id)\n    else:\n        attrs = None\n        if type(scriptcontext.doc) is Rhino.RhinoDoc:\n            rhobj = rhutil.coercerhinoobject(curve_id)\n            if rhobj: attrs = rhobj.Attributes\n        rc = scriptcontext.doc.Objects.AddCurve(nc, attrs)\n        if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef MeshPolyline(polyline_id):\n    \"\"\"Creates a polygon mesh object based on a closed polyline curve object.\n    The newly created mesh object is added to the document\n    Parameters:\n      polyline_id = identifier of the polyline curve object\n    Returns:\n      identifier of the new mesh object\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(polyline_id, -1, True)\n    mesh = Rhino.Geometry.Mesh.CreateFromPlanarBoundary(curve)\n    if mesh is None: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddMesh(mesh)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef OffsetCurve(object_id, direction, distance, normal=None, style=1):\n    \"\"\"Offsets a curve by a distance. The offset curve will be added to Rhino\n    Parameters:\n      object_id = identifier of a curve object\n      direction = point describing direction of the offset\n      distance = distance of the offset\n      normal[opt] = normal of the plane in which the offset will occur.\n          If omitted, the normal of the active construction plane will be used\n      style[opt] = the corner style\n          0 = None\n          1 = Sharp\n          2 = Round\n          3 = Smooth\n          4 = Chamfer\n    Returns:\n      List of ids for the new curves on success\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, -1, True)\n    direction = rhutil.coerce3dpoint(direction, True)\n    if normal:\n        normal = rhutil.coerce3dvector(normal, True)\n    else:\n        normal = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane().Normal\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    style = System.Enum.ToObject(Rhino.Geometry.CurveOffsetCornerStyle, style)\n    curves = curve.Offset(direction, normal, distance, tolerance, style)\n    if curves is None: return scriptcontext.errorhandler()\n    rc = [scriptcontext.doc.Objects.AddCurve(curve) for curve in curves]\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef OffsetCurveOnSurface(curve_id, surface_id, distance_or_parameter):\n    \"\"\"Offset a curve on a surface. The source curve must lie on the surface.\n    The offset curve or curves will be added to Rhino\n    Parameters:\n      curve_id, surface_id = curve and surface identifiers\n      distance_or_parameter = If a single number is passed, then this is the\n        distance of the offset. Based on the curve's direction, a positive value\n        will offset to the left and a negative value will offset to the right.\n        If a tuple of two values is passed, this is interpreted as the surface\n        U,V parameter that the curve will be offset through\n    Returns:\n      Identifiers of the new curves if successful\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    surface = rhutil.coercesurface(surface_id, True)\n    x = None\n    if type(distance_or_parameter) is list or type(distance_or_parameter) is tuple:\n        x = Rhino.Geometry.Point2d( distance_or_parameter[0], distance_or_parameter[1] )\n    else:\n        x = float(distance_or_parameter)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    curves = curve.OffsetOnSurface(surface, x, tol)\n    if curves is None: return scriptcontext.errorhandler()\n    rc = [scriptcontext.doc.Objects.AddCurve(curve) for curve in curves]\n    if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef PlanarClosedCurveContainment(curve_a, curve_b, plane=None, tolerance=None):\n    \"\"\"Determines the relationship between the regions bounded by two coplanar\n    simple closed curves\n    Paramters:\n      curve_a, curve_b = identifiers of two planar, closed curves\n      plane[opt] = test plane. If omitted, the currently active construction\n        plane is used\n      tolerance[opt] = if omitted, the document absolute tolerance is used\n    Returns:\n      a number identifying the relationship if successful\n        0 = the regions bounded by the curves are disjoint\n        1 = the two curves intersect\n        2 = the region bounded by curve_a is inside of curve_b\n        3 = the region bounded by curve_b is inside of curve_a\n      None if not successful\n    \"\"\"\n    curve_a = rhutil.coercecurve(curve_a, -1, True)\n    curve_b = rhutil.coercecurve(curve_b, -1, True)\n    if tolerance is None or tolerance<=0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if plane:\n        plane = rhutil.coerceplane(plane)\n    else:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    rc = Rhino.Geometry.Curve.PlanarClosedCurveContainmentTest(curve_a, curve_b, plane, tolerance)\n    return rc\n\n\ndef PointInPlanarClosedCurve(point, curve, plane=None, tolerance=None):\n    \"\"\"Determines if a point is inside of a closed curve, on a closed curve, or\n    outside of a closed curve\n    Parameters:\n      point = text point\n      curve = identifier of a curve object\n      plane[opt] = plane containing the closed curve and point. If omitted,\n          the currently active construction plane is used\n      tolerance[opt] = it omitted, the document abosulte tolerance is used\n    Returns:\n      number identifying the result if successful\n          0 = point is outside of the curve\n          1 = point is inside of the curve\n          2 = point in on the curve\n    \"\"\"\n    point = rhutil.coerce3dpoint(point, True)\n    curve = rhutil.coercecurve(curve, -1, True)\n    if tolerance is None or tolerance<=0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if plane:\n        plane = rhutil.coerceplane(plane)\n    else:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    rc = curve.Contains(point, plane, tolerance)\n    if rc==Rhino.Geometry.PointContainment.Unset: raise Exception(\"Curve.Contains returned Unset\")\n    if rc==Rhino.Geometry.PointContainment.Outside: return 0\n    if rc==Rhino.Geometry.PointContainment.Inside: return 1\n    return 2\n\n\ndef PolyCurveCount(curve_id, segment_index=-1):\n    \"\"\"Returns the number of curve segments that make up a polycurve\"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    if isinstance(curve, Rhino.Geometry.PolyCurve): return curve.SegmentCount\n    raise ValueError(\"curve_id does not reference a polycurve\")\n\n\ndef PolylineVertices(curve_id, segment_index=-1):\n    \"Returns the vertices of a polyline curve on success\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, polyline = curve.TryGetPolyline()\n    if rc: return [pt for pt in polyline]\n    raise ValueError(\"curve_id does not reference a polyline\")\n\n\ndef ProjectCurveToMesh(curve_ids, mesh_ids, direction):\n    \"\"\"Projects one or more curves onto one or more surfaces or meshes\n    Parameters:\n      curve_ids = identifiers of curves to project\n      mesh_ids = identifiers of meshes to project onto\n      direction = projection direction\n    Returns:\n      list of identifiers\n    \"\"\"\n    curve_ids = rhutil.coerceguidlist(curve_ids)\n    mesh_ids = rhutil.coerceguidlist(mesh_ids)\n    direction = rhutil.coerce3dvector(direction, True)\n    curves = [rhutil.coercecurve(id, -1, True) for id in curve_ids]\n    meshes = [rhutil.coercemesh(id, True) for id in mesh_ids]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newcurves = Rhino.Geometry.Curve.ProjectToMesh(curves, meshes, direction, tolerance)\n    ids = [scriptcontext.doc.Objects.AddCurve(curve) for curve in newcurves]\n    if ids: scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef ProjectCurveToSurface(curve_ids, surface_ids, direction):\n    \"\"\"Projects one or more curves onto one or more surfaces or polysurfaces\n    Parameters:\n      curve_ids = identifiers of curves to project\n      surface_ids = identifiers of surfaces to project onto\n      direction = projection direction\n    Returns:\n      list of identifiers\n    \"\"\"\n    curve_ids = rhutil.coerceguidlist(curve_ids)\n    surface_ids = rhutil.coerceguidlist(surface_ids)\n    direction = rhutil.coerce3dvector(direction, True)\n    curves = [rhutil.coercecurve(id, -1, True) for id in curve_ids]\n    breps = [rhutil.coercebrep(id, True) for id in surface_ids]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newcurves = Rhino.Geometry.Curve.ProjectToBrep(curves, breps, direction, tolerance)\n    ids = [scriptcontext.doc.Objects.AddCurve(curve) for curve in newcurves]\n    if ids: scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef RebuildCurve(curve_id, degree=3, point_count=10):\n    \"\"\"Rebuilds a curve to a given degree and control point count. For more\n    information, see the Rhino help for the Rebuild command.\n    Parameters:\n      curve_id = identifier of the curve object\n      degree[opt] = new degree (must be greater than 0)\n      point_count [opt] = new point count, which must be bigger than degree.\n    Returns:\n      True of False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if degree<1: raise ValueError(\"degree must be greater than 0\")\n    newcurve = curve.Rebuild(point_count, degree, False)\n    if not newcurve: return False\n    scriptcontext.doc.Objects.Replace(curve_id, newcurve)\n    scriptcontext.doc.Views.Redraw()\n    return True\n\n\ndef ReverseCurve(curve_id):\n    \"\"\"Reverses the direction of a curve object. Same as Rhino's Dir command\n    Parameters:\n      curve_id = identifier of the curve object\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if curve.Reverse():\n        curve_id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Replace(curve_id, curve)\n        return True\n    return False\n\n\ndef SimplifyCurve(curve_id, flags=0):\n    \"Replace a curve with a geometrically equivalent polycurve\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    _flags = Rhino.Geometry.CurveSimplifyOptions.All\n    if( flags&1 ==1 ): _flags = _flags - Rhino.Geometry.CurveSimplifyOptions.SplitAtFullyMultipleKnots\n    if( flags&2 ==2 ): _flags = _flags - Rhino.Geometry.CurveSimplifyOptions.RebuildLines\n    if( flags&4 ==4 ): _flags = _flags - Rhino.Geometry.CurveSimplifyOptions.RebuildArcs\n    if( flags&8 ==8 ): _flags = _flags - Rhino.Geometry.CurveSimplifyOptions.RebuildRationals\n    if( flags&16==16 ): _flags = _flags - Rhino.Geometry.CurveSimplifyOptions.AdjustG1\n    if( flags&32==32 ): _flags = _flags - Rhino.Geometry.CurveSimplifyOptions.Merge\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    ang_tol = scriptcontext.doc.ModelAngleToleranceRadians\n    newcurve = curve.Simplify(_flags, tol, ang_tol)\n    if newcurve:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Replace(curve_id, newcurve)\n        scriptcontext.doc.Views.Redraw()\n        return True\n    return False\n\n\ndef SplitCurve(curve_id, parameter, delete_input=True):\n    \"\"\"Splits, or divides, a curve at a specified parameter. The parameter must\n    be in the interior of the curve's domain\n    Parameters:\n      curve_id = identifier of the curve object\n      parameter = one or more parameters to split the curve at\n      delete_input[opt] = delete the input curve\n    Returns:\n      list of new curve ids on success\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    newcurves = curve.Split(parameter)\n    if newcurves is None: return scriptcontext.errorhandler()\n    att = None\n    rhobj = rhutil.coercerhinoobject(curve_id)\n    if rhobj: att = rhobj.Attributes\n    rc = [scriptcontext.doc.Objects.AddCurve(crv, att) for crv in newcurves]\n    if rc and delete_input:\n        id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef TrimCurve(curve_id, interval, delete_input=True):\n    \"\"\"Trims a curve by removing portions of the curve outside a specified interval\n    Paramters:\n      curve_id = identifier of the curve object\n      interval = two numbers indentifying the interval to keep. Portions of\n        the curve before domain[0] and after domain[1] will be removed. If the\n        input curve is open, the interval must be increasing. If the input\n        curve is closed and the interval is decreasing, then the portion of\n        the curve across the start and end of the curve is returned\n      delete_input[opt] = delete the input curve\n    Reutrns:\n      identifier of the new curve on success\n      None on failure\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if interval[0]==interval[1]: raise ValueError(\"interval values are equal\")\n    newcurve = curve.Trim(interval[0], interval[1])\n    if not newcurve: return scriptcontext.errorhandler()\n    att = None\n    rhobj = rhutil.coercerhinoobject(curve_id)\n    if rhobj: att = rhobj.Attributes\n    rc = scriptcontext.doc.Objects.AddCurve(newcurve, att)\n    if delete_input:\n        id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "point", "brep", "line", "dimension", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "ksteinfe_decodes_7d37eb4b13.json", "repo": "ksteinfe/decodes"}
{"instruction": "Evaluates a plane at a U,V parameter", "code": "from . import utility as rhutil\nimport Rhino.Geometry\nimport scriptcontext\nimport math\n\ndef DistanceToPlane(plane, point):\n    \"Returns the distance from a 3D point to a plane\"\n    plane = rhutil.coerceplane(plane, True)\n    point = rhutil.coerce3dpoint(point, True)\n    return plane.DistanceTo(point)\n\n\ndef EvaluatePlane(plane, parameter):\n    \"\"\"Evaluates a plane at a U,V parameter\n    Parameters:\n      plane = the plane to evaluate\n      parameter = list of two numbers defining the U,V parameter to evaluate\n    Returns:\n      Point3d on success\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    return plane.PointAt(parameter[0], parameter[1])\n\n\ndef IntersectPlanes(plane1, plane2, plane3):\n    \"\"\"Calculates the intersection of three planes\n    Returns:\n      Point3d on success\n      None on error\n    \"\"\"\n    plane1 = rhutil.coerceplane(plane1, True)\n    plane2 = rhutil.coerceplane(plane2, True)\n    plane3 = rhutil.coerceplane(plane3, True)\n    rc, point = Rhino.Geometry.Intersect.Intersection.PlanePlanePlane(plane1, plane2, plane3)\n    if rc: return point\n    return scriptcontext.errorhandler()\n\n\ndef MovePlane(plane, origin):\n    \"\"\"Moves the origin of a plane\n    Parameters:\n      plane = Plane or ConstructionPlane\n      origin = Point3d or list of three numbers\n    Returns:\n      moved plane\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    origin = rhutil.coerce3dpoint(origin, True)\n    rc = Rhino.Geometry.Plane(plane)\n    rc.Origin = origin\n    return rc\n\n\ndef PlaneClosestPoint(plane, point, return_point=True):\n    \"\"\"Returns the point on a plane that is closest to a test point.\n    Parameters:\n      plane = The plane\n      point = The 3-D point to test.\n      return_point [opt] = If omitted or True, then the point on the plane\n         that is closest to the test point is returned. If False, then the\n         parameter of the point on the plane that is closest to the test\n         point is returned.\n    Returns:\n      If return_point is omitted or True, then the 3-D point\n      If return_point is False, then an array containing the U,V parameters\n      of the point\n      None if not successful, or on error.\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    point = rhutil.coerce3dpoint(point, True)\n    if return_point:\n        return plane.ClosestPoint(point)\n        if rc.IsValid: return rc\n    else:\n        rc, s, t = plane.ClosestParameter(point)\n        if rc: return s, t\n    return scriptcontext.errorhandler()\n\n\ndef PlaneEquation(plane):\n    \"\"\"Returns the equation of a plane as a tuple of four numbers. The standard\n    equation of a plane with a non-zero vector is Ax+By+Cz+D=0\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    rc = plane.GetPlaneEquation()\n    return rc[0], rc[1], rc[2], rc[3]\n\n\ndef PlaneFitFromPoints(points):\n    \"\"\"Returns a plane that was fit through an array of 3D points.\n    Parameters:\n    points = An array of 3D points.\n    Returns: \n      The plane if successful\n      None if not successful\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    rc, plane = Rhino.Geometry.Plane.FitPlaneToPoints(points)\n    if rc==Rhino.Geometry.PlaneFitResult.Success: return plane\n    return scriptcontext.errorhandler()\n\n\ndef PlaneFromFrame(origin, x_axis, y_axis):\n    \"\"\"Construct a plane from a point, and two vectors in the plane.\n    Parameters:\n      origin = A 3D point identifying the origin of the plane.\n      x_axis = A non-zero 3D vector in the plane that determines the X axis\n               direction.\n      y_axis = A non-zero 3D vector not parallel to x_axis that is used\n               to determine the Y axis direction. Note, y_axis does not\n               have to be perpendicular to x_axis.\n    Returns:\n      The plane if successful. \n      None if not successful\n    \"\"\"\n    origin = rhutil.coerce3dpoint(origin, True)\n    x_axis = rhutil.coerce3dvector(x_axis, True)\n    y_axis = rhutil.coerce3dvector(y_axis, True)\n    return Rhino.Geometry.Plane(origin, x_axis, y_axis)\n\n\ndef PlaneFromNormal(origin, normal, xaxis=None):\n    \"\"\"Creates a plane from an origin point and a normal direction vector.\n    Parameters:\n      origin = A 3D point identifying the origin of the plane.\n      normal = A 3D vector identifying the normal direction of the plane.\n      xaxis[opt] = optional vector defining the plane's x-axis\n    Returns:\n      The plane if successful.\n      None if not successful, or on error.  \n    \"\"\"\n    origin = rhutil.coerce3dpoint(origin, True)\n    normal = rhutil.coerce3dvector(normal, True)\n    rc = Rhino.Geometry.Plane(origin, normal)\n    if xaxis:\n        xaxis = rhutil.coerce3dpoint(xaxis, True)\n        projected_start = rc.ClosestPoint(Rhino.Geometry.Point3d(0,0,0))\n        projected_end = rc.ClosestPoint(xaxis)\n        xaxis = projected_end - projected_start\n        if xaxis.IsValid and not xaxis.IsParallelTo(rc.YAxis):\n            rc = Rhino.Geometry.Plane(origin, xaxis, rc.YAxis)\n    return rc\n\n\ndef PlaneFromPoints(origin, x, y):\n    \"\"\"Creates a plane from three non-colinear points\n    Parameters:\n      origin = origin point of the plane\n      x, y = points on the plane's x and y axes\n    \"\"\"\n    origin = rhutil.coerce3dpoint(origin, True)\n    x = rhutil.coerce3dpoint(x, True)\n    y = rhutil.coerce3dpoint(y, True)\n    plane = Rhino.Geometry.Plane(origin, x, y)\n    if plane.IsValid: return plane\n    return scriptcontext.errorhandler()\n\n\ndef PlanePlaneIntersection(plane1, plane2):\n    \"\"\"Calculates the intersection of two planes\n    Paramters:\n      plane1, plane2 = two planes\n    Returns:\n      two 3d points identifying the starting/ending points of the intersection\n      None on error\n    \"\"\"\n    plane1 = rhutil.coerceplane(plane1, True)\n    plane2 = rhutil.coerceplane(plane2, True)\n    rc, line = Rhino.Geometry.Intersect.Intersection.PlanePlane(plane1, plane2)\n    if rc: return line.From, line.To\n    return scriptcontext.errorhandler()\n\n\ndef PlaneSphereIntersection(plane, sphere_plane, sphere_radius):\n    \"\"\"Calculates the intersection of a plane and a sphere\n    Parameters:\n      plane = the plane to intersect\n      sphere_plane = equitorial plane of the sphere. origin of the plane is\n        the center of the sphere\n      sphere_radius = radius of the sphere\n    Returns:\n      list of intersection results - see help\n      None on error\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    sphere_plane = rhutil.coerceplane(sphere_plane, True)\n    sphere = Rhino.Geometry.Sphere(sphere_plane, sphere_radius)\n    rc, circle = Rhino.Geometry.Intersect.Intersection.PlaneSphere(plane, sphere)\n    if rc==Rhino.Geometry.Intersect.PlaneSphereIntersection.Point:\n        return 0, circle.Center\n    if rc==Rhino.Geometry.Intersect.PlaneSphereIntersection.Circle:\n        return 1, circle.Plane, circle.Radius\n    return scriptcontext.errorhandler()\n\n\ndef PlaneTransform(plane, xform):\n    \"\"\"Transforms a plane\n    Parameters:\n      plane = OnPlane or On3dmConstructionPlane\n      xform = \n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    xform = rhutil.coercexform(xform, True)\n    rc = Rhino.Geometry.Plane(plane)\n    if rc.Transform(xform): return rc\n    return scriptcontext.errorhandler()\n\n\ndef RotatePlane(plane, angle_degrees, axis):\n    \"\"\"Rotates a plane\n    Parameters:\n      plane = OnPlane or On3dmConstructionPlane\n      angle_degrees = rotation angle in degrees\n      axis = On3dVector or list of three numbers\n    Returns:\n      rotated plane on success\n      None on error\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    axis = rhutil.coerce3dvector(axis, True)\n    angle_radians = math.radians(angle_degrees)\n    rc = Rhino.Geometry.Plane(plane)\n    if rc.Rotate(angle_radians, axis): return rc\n    return scriptcontext.errorhandler()\n\n\ndef WorldXYPlane():\n    \"Returns Rhino's world XY plane\"\n    return Rhino.Geometry.Plane.WorldXY\n\n\ndef WorldYZPlane():\n    \"Returns Rhino's world YZ plane\"\n    return Rhino.Geometry.Plane.WorldYZ\n\n\ndef WorldZXPlane():\n    \"Returns Rhino's world ZX plane\"\n    return Rhino.Geometry.Plane.WorldZX\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["line", "point", "functions", "RhinoCommon"], "original_file": "ksteinfe_decodes_8e805a01b0.json", "repo": "ksteinfe/decodes"}
{"instruction": "Returns number of block definitions that contain a specified", "code": "import Rhino\nimport scriptcontext\nfrom . import utility as rhutil\nimport math\nimport System.Guid\n\ndef __InstanceObjectFromId( id, raise_if_missing ):\n    rhobj = rhutil.coercerhinoobject(id, True, raise_if_missing)\n    if isinstance(rhobj, Rhino.DocObjects.InstanceObject): return rhobj\n    if raise_if_missing: raise ValueError(\"unable to find InstanceObject\")\n\n\ndef BlockContainerCount(block_name):\n    \"\"\"Returns number of block definitions that contain a specified\n    block definition\n    Parameters:\n      block_name = the name of an existing block definition\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name, True)\n    if idef is None: return 0\n    containers = idef.GetContainers()\n    if not containers: return 0\n    return len(containers)\n\n\ndef BlockContainers(block_name):\n    \"\"\"Returns names of the block definitions that contain a specified block\n    definition.\n    Parameters:\n      block_name = the name of an existing block definition\n    Returns:\n      A list of block definition names\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name, True)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    containers = idef.GetContainers()\n    rc = []\n    for item in containers:\n        if not item.IsDeleted: rc.append(item.Name)\n    return rc\n\n\ndef BlockCount():\n    \"Returns the number of block definitions in the document\"\n    return scriptcontext.doc.InstanceDefinitions.ActiveCount\n\n\ndef BlockDescription(block_name, description=None):\n    \"\"\"Returns or sets the description of a block definition\n    Parameters:\n      block_name = the name of an existing block definition\n      description[opt] = The new description.\n    Returns:\n      if description is not specified, the current description\n      if description is specified, the previous description\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name, True)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    rc = idef.Description\n    if description: table.Modify( idef, idef.Name, description )\n    return rc\n\n\ndef BlockInstanceCount(block_name):\n    \"\"\"Counts number of instances of the block in the document.\n    Nested instances are not included in the count.\n    Parameters:\n      block_name = the name of an existing block definition\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name, True)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    refs = idef.GetReferences()\n    return len(refs)\n\n\ndef BlockInstanceInsertPoint(object_id):\n    \"\"\"Returns the insertion point of a block instance.\n    Parameters:\n      object_id = The identifier of an existing block insertion object\n    Returns:\n      list representing 3D point if successful\n    \"\"\"\n    instance = __InstanceObjectFromId(object_id, True)\n    xf = instance.InstanceXform\n    pt = Rhino.Geometry.Point3d.Origin\n    pt.Transform(xf)\n    return pt\n\n\ndef BlockInstanceName(object_id):\n    \"\"\"Returns the block name of a block instance\n    Parameters:\n      object_id = The identifier of an existing block insertion object\n    \"\"\"\n    instance = __InstanceObjectFromId(object_id, True)\n    idef = instance.InstanceDefinition\n    return idef.Name\n\n\ndef BlockInstances(block_name):\n    \"\"\"Returns the identifiers of the inserted instances of a block.\n    Parameters:\n      block_name = the name of an existing block definition\n    Returns:\n      list of guids identifying the instances of a block\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name, True)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    instances = idef.GetReferences(0)\n    return [item.Id for item in instances]\n\n\ndef BlockInstanceXform(object_id):\n    \"\"\"Returns the location of a block instance relative to the world coordinate\n    system origin (0,0,0). The position is returned as a 4x4 transformation\n    matrix\n    Parameters:\n      object_id = The identifier of an existing block insertion object  \n    \"\"\"\n    instance = __InstanceObjectFromId(object_id, True)\n    return instance.InstanceXform\n\n\ndef BlockNames( sort=False ):\n    \"\"\"Returns the names of all block definitions in the document\n    Parameters:\n      sort = return a sorted list\n    \"\"\"\n    ideflist = scriptcontext.doc.InstanceDefinitions.GetList(True)\n    rc = [item.Name for item in ideflist]\n    if(sort): rc.sort()\n    return rc\n\n\ndef BlockObjectCount(block_name):\n    \"\"\"Returns the number of objects that make up a block definition\n    Parameters:\n      block_name = name of an existing block definition\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name, True)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    return idef.ObjectCount\n\n\ndef BlockObjects(block_name):\n    \"\"\"Returns the identifiers of the objects that make up a block definition\n    Parameters:\n      block_name = name of an existing block definition\n    Returns:\n      list of identifiers on success\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name, True)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    rhobjs = idef.GetObjects()\n    return [obj.Id for obj in rhobjs]\n\n\ndef BlockPath(block_name):\n    \"\"\"Returns the path to the source of a linked or embedded block definition.\n    A linked or embedded block definition is a block definition that was\n    inserted from an external file.\n    Parameters:\n      block_name = name of an existing block definition\n    Returns:\n      path to the linked block on success\n      None on error\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name, True)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    return idef.SourceArchive\n\n\ndef DeleteBlock(block_name):\n    \"\"\"Deletes a block definition and all of it's inserted instances.\n    Parameters:\n      block_name = name of an existing block definition\n    Returns:\n      True or False indicating success or failure  \n    \"\"\"\n    return scriptcontext.doc.InstanceDefinitions.Delete(index, True, False)\n\n\ndef ExplodeBlockInstance(object_id):\n    \"\"\"Explodes a block instance into it's geometric components. The\n    exploded objects are added to the document\n    Parameters:\n      object_id = The identifier of an existing block insertion object  \n    Returns:\n      list of identifiers for the newly exploded objects on success\n    \"\"\"\n    instance = __InstanceObjectFromId(object_id, True)\n    subobjects = instance.GetSubObjects()\n    persistSelect = (instance.IsSelected(False)>=2)\n    instance.Select(False, True)\n    rc = []\n    for item in subobjects:\n        id = scriptcontext.doc.Objects.AddObject(item)\n        if id!=System.Guid.Empty:\n            rc.append(id)\n            if persistSelect:\n                rhobj = scriptcontext.doc.Objects.Find(id)\n                rhobj.Select(True, True)\n    if rc:\n        scriptcontext.doc.Objects.Delete(instance)\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef InsertBlock( block_name, insertion_point, scale=(1,1,1), angle_degrees=0, rotation_normal=(0,0,1) ):\n    \"\"\"Inserts a block whose definition already exists in the document\n    Parameters:\n      block_name = name of an existing block definition\n      insertion_point = insertion point for the block\n      scale [opt] = x,y,z scale factors\n      angle_degrees [opt] = rotation angle in degrees\n      rotation_normal [opt] = the axis of rotation.\n    Returns:\n      id for the block that was added to the doc\n    \"\"\"\n    insertion_point = rhutil.coerce3dpoint(insertion_point, True)\n    rotation_normal = rhutil.coerce3dvector(rotation_normal, True)\n    angle_radians = math.radians(angle_degrees)\n    trans = Rhino.Geometry.Transform\n    move = trans.Translation(insertion_point[0],insertion_point[1],insertion_point[2])\n    scale = trans.Scale(Rhino.Geometry.Plane.WorldXY, scale[0], scale[1], scale[2])\n    rotate = trans.Rotation(angle_radians, rotation_normal, Rhino.Geometry.Point3d.Origin)\n    xform = move * scale * rotate\n    return InsertBlock2( block_name, xform )\n\n\ndef InsertBlock2(block_name, xform):\n    \"\"\"Inserts a block whose definition already exists in the document\n    Parameters:\n      block_name = name of an existing block definition\n      xform = 4x4 transformation matrix to apply\n    Returns:\n      id for the block that was added to the doc on success\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name, True)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    xform = rhutil.coercexform(xform, True)\n    id = scriptcontext.doc.Objects.AddInstanceObject(idef.Index, xform )\n    if id!=System.Guid.Empty:\n        scriptcontext.doc.Views.Redraw()\n        return id\n\n\ndef IsBlock(block_name):\n    \"\"\"Verifies the existence of a block definition in the document.\n    Parameters:\n      block_name = name of an existing block definition\n    Returns:\n      True or False\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name, True)\n    return (idef is not None)\n\n\ndef IsBlockEmbedded(block_name):\n    \"\"\"Verifies a block definition is embedded, or linked, from an external file.\n    Parameters:\n      block_name = name of an existing block definition\n    Returns:\n      True or False\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name, True)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    ut = Rhino.DocObjects.InstanceDefinitionUpdateType\n    return (idef.UpdateType==ut.Embedded or idef.UpdateType==ut.LinkedAndEmbedded)\n\n\ndef IsBlockInstance( object_id ):\n    \"\"\"Verifies an object is a block instance\n    Parameters:\n      object_id = The identifier of an existing block insertion object\n    Returns:\n      True or False\n    \"\"\"\n    return  __InstanceObjectFromId(object_id, False) is not None\n\n\ndef IsBlockInUse( block_name, where_to_look=0 ):\n    \"\"\"Verifies that a block definition is being used by an inserted instance\n    Parameters:\n      block_name = name of an existing block definition\n      where_to_look [opt] = One of the following values\n           0 = Check for top level references in active document\n           1 = Check for top level and nested references in active document\n           2 = Check for references in other instance definitions\n    Returns:\n      True or False\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name, True)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    return idef.InUse(where_to_look)\n\n\ndef IsBlockReference(block_name):\n    \"\"\"Verifies that a block definition is from a reference file.\n    Parameters:\n      block_name = name of an existing block definition\n    Returns:\n      True or False\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name, True)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    return idef.IsReference\n\n\ndef RenameBlock( block_name, new_name ):\n    \"\"\"Renames an existing block definition\n    Parameters:\n      block_name = name of an existing block definition\n      new_name = name to change to\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    idef = scriptcontext.doc.InstanceDefinitions.Find(block_name, True)\n    if not idef: raise ValueError(\"%s does not exist in InstanceDefinitionsTable\"%block_name)\n    description = idef.Description\n    rc = scriptcontext.doc.InstanceDefinitions.Modify(idef, new_name, description, False)\n    return rc\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["block", "point", "functions", "RhinoCommon"], "original_file": "ksteinfe_decodes_e23d69855d.json", "repo": "ksteinfe/decodes"}
{"instruction": "Creates a new hatch object from a closed planar curve object", "code": "import scriptcontext\nfrom . import utility as rhutil\nimport Rhino\nimport System.Guid\n\ndef AddHatch(curve_id, hatch_pattern=None, scale=1.0, rotation=0.0):\n    \"\"\"Creates a new hatch object from a closed planar curve object\n    Parameters:\n      curve_id = identifier of the closed planar curve that defines the\n          boundary of the hatch object\n      hatch_pattern[opt] = name of the hatch pattern to be used by the hatch\n          object. If omitted, the current hatch pattern will be used\n      scale[opt] = hatch pattern scale factor\n      rotation[opt] = hatch pattern rotation angle in degrees.\n    Returns:\n      identifier of the newly created hatch on success\n      None on error\n    \"\"\"\n    rc = AddHatches(curve_id, hatch_pattern, scale, rotation)\n    if rc: return rc[0]\n    return scriptcontext.errorhandler()\n\n\ndef AddHatches(curve_ids, hatch_pattern=None, scale=1.0, rotation=0.0):\n    \"\"\"Creates one or more new hatch objects a list of closed planar curves\n    Parameters:\n      curve_ids = identifiers of the closed planar curves that defines the\n          boundary of the hatch objects\n      hatch_pattern[opt] = name of the hatch pattern to be used by the hatch\n          object. If omitted, the current hatch pattern will be used\n      scale[opt] = hatch pattern scale factor\n      rotation[opt] = hatch pattern rotation angle in degrees.\n    Returns:\n      identifiers of the newly created hatch on success\n      None on error\n    \"\"\"\n    id = rhutil.coerceguid(curve_ids, False)\n    if id: curve_ids = [id]\n    index = scriptcontext.doc.HatchPatterns.CurrentHatchPatternIndex\n    if hatch_pattern and hatch_pattern!=index:\n        if isinstance(hatch_pattern, int):\n            index = hatch_pattern\n        else:\n            index = scriptcontext.doc.HatchPatterns.Find(hatch_pattern, True)\n        if index<0: return scriptcontext.errorhandler()\n    curves = [rhutil.coercecurve(id, -1, True) for id in curve_ids]\n    rotation = Rhino.RhinoMath.ToRadians(rotation)\n    hatches = Rhino.Geometry.Hatch.Create(curves, index, rotation, scale)\n    if not hatches: return scriptcontext.errorhandler()\n    ids = []\n    for hatch in hatches:\n        id = scriptcontext.doc.Objects.AddHatch(hatch)\n        if id==System.Guid.Empty: continue\n        ids.append(id)\n    if not ids: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef AddHatchPatterns(filename, replace=False):\n    \"\"\"Adds hatch patterns to the document by importing hatch pattern definitions\n    from a pattern file.\n    Parameters:\n      filename = name of the hatch pattern file\n      replace[opt] = If hatch pattern names already in the document match hatch\n          pattern names in the pattern definition file, then the existing hatch\n          patterns will be redefined\n    Returns:\n      Names of the newly added hatch patterns if successful\n      None on error\n    \"\"\"\n    patterns = Rhino.DocObjects.HatchPattern.ReadFromFile(filename, True)\n    if not patterns: return scriptcontext.errorhandler()\n    rc = []\n    for pattern in patterns:\n         index = scriptcontext.doc.HatchPatterns.Add(pattern)\n         if index>=0:\n             pattern = scriptcontext.doc.HatchPatterns[index]\n             rc.append(pattern.Name)\n    if not rc: return scriptcontext.errorhandler()\n    return rc\n\n\ndef CurrentHatchPattern(hatch_pattern=None):\n    \"\"\"Returns or sets the current hatch pattern file\n    Parameters:\n      hatch_pattern[opt] = name of an existing hatch pattern to make current\n    Returns:\n      if hatch_pattern is not specified, the current hatch pattern\n      if hatch_pattern is specified, the previous hatch pattern\n      None on error\n    \"\"\"\n    rc = scriptcontext.doc.HatchPatterns.CurrentHatchPatternIndex\n    if hatch_pattern:\n        index = scriptcontext.doc.HatchPatterns.Find(hatch_pattern, True)\n        if index<0: return scriptcontext.errorhandler()\n        scriptcontext.doc.HatchPatterns.CurrentHatchPatternIndex = index\n    return rc\n\n\ndef ExplodeHatch(hatch_id, delete=False):\n    \"\"\"Explodes a hatch object into its component objects. The exploded objects\n    will be added to the document. If the hatch object uses a solid pattern,\n    then planar face Brep objects will be created. Otherwise, line curve objects\n    will be created\n    Parameters:\n      hatch_id = identifier of a hatch object\n      delete[opt] = delete the hatch object\n    Returns:\n      list of identifiers for the newly created objects\n      None on error\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(hatch_id, True, True)\n    if not isinstance(rhobj, Rhino.DocObjects.HatchObject):\n        return scriptcontext.errorhandler()\n    pieces = rhobj.HatchGeometry.Explode()\n    if not pieces: return scriptcontext.errorhandler()\n    attr = rhobj.Attributes\n    rc = []\n    for piece in pieces:\n        id = None\n        if isinstance(piece, Rhino.Geometry.Curve):\n            id = scriptcontext.doc.Objects.AddCurve(piece, attr)\n        elif isinstance(piece, Rhino.Geometry.Brep):\n            id = scriptcontext.doc.Objects.AddBrep(piece, attr)\n        if id: rc.append(id)\n    return rc\n\n\ndef HatchPattern(hatch_id, hatch_pattern=None):\n    \"\"\"Returns or changes a hatch object's hatch pattern\n    Paramters:\n      hatch_id = identifier of a hatch object\n      hatch_pattern[opt] = name of an existing hatch pattern to replace the\n          current hatch pattern\n    Returns:\n      if hatch_pattern is not specified, the current hatch pattern\n      if hatch_pattern is specified, the previous hatch pattern\n      None on error\n    \"\"\"\n    hatchobj = rhutil.coercerhinoobject(hatch_id, True, True)\n    if not isinstance(hatchobj, Rhino.DocObjects.HatchObject):\n        return scriptcontext.errorhandler()\n    old_index = hatchobj.HatchGeometry.PatternIndex\n    if hatch_pattern:\n        new_index = scriptcontext.doc.HatchPatterns.Find(hatch_pattern, True)\n        if new_index<0: return scriptcontext.errorhandler()\n        hatchobj.HatchGeometry.PatternIndex = new_index\n        hatchobj.CommitChanges()\n        scriptcontext.doc.Views.Redraw()\n    return scriptcontext.doc.HatchPatterns[old_index].Name\n\n\ndef HatchPatternCount():\n    \"Returns the number of hatch patterns in the document\"\n    return scriptcontext.doc.HatchPatterns.Count\n\n\ndef HatchPatternDescription(hatch_pattern):\n    \"\"\"Returns the description of a hatch pattern. Note, not all hatch patterns\n    have descriptions\n    Parameters:\n      hatch_pattern = name of an existing hatch pattern\n    \"\"\"\n    index = scriptcontext.doc.HatchPatterns.Find(hatch_pattern, True)\n    if index<0: return scriptcontext.errorhandler()\n    return scriptcontext.doc.HatchPatterns[index].Description\n\n\ndef HatchPatternFillType(hatch_pattern):\n    \"\"\"Returns the fill type of a hatch pattern.\n        0 = solid, uses object color\n        1 = lines, uses pattern file definition\n        2 = gradient, uses fill color definition\n    Parameters:\n      hatch_pattern = name of an existing hatch pattern\n    \"\"\"\n    index = scriptcontext.doc.HatchPatterns.Find(hatch_pattern, True)\n    if index<0: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.HatchPatterns[index].FillType\n    return int(rc)\n\n\ndef HatchPatternNames():\n    \"Returns the names of all of the hatch patterns in the document\"\n    rc = []\n    for i in range(scriptcontext.doc.HatchPatterns.Count):\n        hatchpattern = scriptcontext.doc.HatchPatterns[i]\n        if hatchpattern.IsDeleted: continue\n        rc.append(hatchpattern.Name)\n    return rc\n\ndef HatchRotation(hatch_id, rotation=None):\n    \"\"\"Returns or modifies the rotation applied to the hatch pattern when\n    it is mapped to the hatch's plane\n    Parameters:\n      hatch_id = identifier of a hatch object\n      rotation[opt] = rotation angle in degrees\n    Returns:\n      if rotation is not defined, the current rotation angle\n      if rotation is specified, the previous rotation angle\n      None on error\n    \"\"\"\n    hatchobj = rhutil.coercerhinoobject(hatch_id, True, True)\n    if not isinstance(hatchobj, Rhino.DocObjects.HatchObject):\n        return scriptcontext.errorhandler()\n    rc = hatchobj.HatchGeometry.PatternRotation\n    rc = Rhino.RhinoMath.ToDegrees(rc)\n    if rotation is not None and rotation!=rc:\n        rotation = Rhino.RhinoMath.ToRadians(rotation)\n        hatchobj.HatchGeometry.PatternRotation = rotation\n        hatchobj.CommitChanges()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef HatchScale(hatch_id, scale=None):\n    \"\"\"Returns or modifies the scale applied to the hatch pattern when it is\n    mapped to the hatch's plane\n    Parameters:\n      hatch_id = identifier of a hatch object\n      scale[opt] = scale factor\n    Returns:\n      if scale is not defined, the current scale factor\n      if scale is defined, the previous scale factor\n      None on error\n    \"\"\"\n    hatchobj = rhutil.coercerhinoobject(hatch_id)\n    if not isinstance(hatchobj, Rhino.DocObjects.HatchObject):\n        return scriptcontext.errorhandler()\n    rc = hatchobj.HatchGeometry.PatternScale\n    if scale and scale!=rc:\n        hatchobj.HatchGeometry.PatternScale = scale\n        hatchobj.CommitChanges()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef IsHatch(object_id):\n    \"\"\"Verifies the existence of a hatch object in the document\n    Paramters:\n      object_id = identifier of an object\n    Returns:\n      True or False\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, False)\n    return isinstance(rhobj, Rhino.DocObjects.HatchObject)\n\n\ndef IsHatchPattern(name):\n    \"\"\"Verifies the existence of a hatch pattern in the document\n    Parameters:\n      name = the name of a hatch pattern\n    Returns:\n      True or False\n    \"\"\"\n    return scriptcontext.doc.HatchPatterns.Find(name, True)>=0\n\n\ndef IsHatchPatternCurrent(hatch_pattern):\n    \"\"\"Verifies that a hatch pattern is the current hatch pattern\n    Parameters:\n      hatch_pattern = name of an existing hatch pattern\n    Returns:\n      True or False\n      None on error\n    \"\"\"\n    index = scriptcontext.doc.HatchPatterns.Find(hatch_pattern, True)\n    if index<0: return scriptcontext.errorhandler()\n    return index==scriptcontext.doc.HatchPatterns.CurrentHatchPatternIndex\n\n\ndef IsHatchPatternReference(hatch_pattern):\n    \"\"\"Verifies that a hatch pattern is from a reference file\n    Parameters:\n      hatch_pattern = name of an existing hatch pattern\n    Returns:\n      True or False\n      None on error\n    \"\"\"\n    index = scriptcontext.doc.HatchPatterns.Find(hatch_pattern, True)\n    if index<0: return scriptcontext.errorhandler()\n    return scriptcontext.doc.HatchPatterns[index].IsReference\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["brep", "line", "curve", "functions", "RhinoCommon"], "original_file": "ksteinfe_decodes_f7bd20ea65.json", "repo": "ksteinfe/decodes"}
{"instruction": "Estimates the trail of a drainage path on a mesh.", "code": "__author__ = \"Christian Kongsgaard\"\n__license__ = \"MIT\"\n__version__ = \"0.0.1\"\n\n# -------------------------------------------------------------------------------------------------------------------- #\n# Imports\n\n# Module imports\nimport threading\nimport queue\nimport pymesh as pm\nimport numpy as np\n\n# Livestock imports\nimport livestock_linux.geometry as ls_geo\n\n# -------------------------------------------------------------------------------------------------------------------- #\n# Livestock Rain and Flow Library\n\n\ndef drain_mesh_paths(files_path):\n    \"\"\" Estimates the trail of a drainage path on a mesh. \"\"\"\n\n    # Get files\n    mesh_path = files_path + '/drain_mesh.obj'\n    cpus = open(files_path + '/cpu.txt', 'r').readline()\n\n    # Load mesh\n    mesh = pm.load_mesh(mesh_path)\n    mesh.enable_connectivity()\n\n    # Result list\n    drain_points = []\n    drain_faces = []\n\n    # Initialize mesh data\n    mesh.add_attribute('face_centroid')\n    mesh.add_attribute('face_index')\n    start_pts = mesh.get_attribute('face_centroid')\n    center_z = []\n    face_index = mesh.get_attribute('face_index')\n    faces = mesh.faces\n    vertices = mesh.vertices\n    face_destination = []\n    ray_points = []\n\n    # Construct start point list\n    start_points = []\n    i = 0\n    while i < len(start_pts):\n        for j in range(0, len(face_index)):\n            start_points.append([face_index[j], np.array([start_pts[i], start_pts[i+1], start_pts[i+2]])])\n            center_z.append(start_pts[i + 2])\n            i += 3\n\n    # Helper functions\n    def face_vertices(face_index_):\n        face = faces[int(face_index_)]\n        v0 = vertices[face[0]]\n        v1 = vertices[face[1]]\n        v2 = vertices[face[2]]\n        return v0, v1, v2\n\n    def over_edge(point):\n        \"\"\"Handles when paths goes over the edge.\"\"\"\n\n        for k in range(0, len(face_index)):\n            if center_z[k] >= point[2]:\n                pass\n\n            elif center_z[k] <= point[2]:\n                # check to see if a similar point has already been processed\n\n                for j_ in range(0, len(ray_points)):\n                    if np.allclose(point, ray_points[j_]):\n                        return face_destination[j_]\n\n                # if not shoot ray\n                v = face_vertices(k)\n                intersect = ls_geo.ray_triangle_intersection(point, np.array([0, 0, -1]), v)\n\n                if intersect[0]:\n                    ray_points.append(point)\n                    face_destination.append(k)\n                    return k\n\n                else:\n                    pass\n\n            else:\n                print('Error in over_edge function!')\n                print('centerZ:', center_z[k])\n                print('point:', point)\n                return None\n\n    # Task function\n    def drain_path():\n\n        while 1:\n            # Get job from queue\n            job = q.get()\n            index = job[0]\n            pt = job[1]\n\n            particles = []\n            particles.append(pt)\n            face_indices = []\n            face_indices.append(int(index))\n            run = True\n            # print('index:',index)\n            # print('point:',pt)\n\n            while run:\n                # Get adjacent faces\n                adjacent_faces = mesh.get_face_adjacent_faces(int(index))\n\n                # Check if center points of adjacent faces have a lower Z-value\n                z = None\n\n                for ad in adjacent_faces:\n                    if not z:\n                        z = center_z[ad]\n                        i = ad\n\n                    elif z > center_z[ad]:\n                        z = center_z[ad]\n                        i = ad\n\n                if z > pt[2]:\n                    v0, v1, v2 = face_vertices(index)\n                    pt = ls_geo.lowest_face_vertex(v0, v1, v2)\n\n                    if len(adjacent_faces) < 3:\n                        over = over_edge(pt)\n\n                        if over:\n                            particles.append(pt)\n                            index = over\n                            pt = start_points[index][1]\n\n                        else:\n                            run = False\n\n                    else:\n                        run = False\n\n                else:\n                    index = start_points[i][0]\n                    pt = start_points[i][1]\n\n                particles.append(pt)\n                face_indices.append(int(index))\n            #print('particles:',particles)\n            #print(len(particles))\n\n            # End task\n            drain_points.append(particles)\n            drain_faces.append(face_indices)\n            q.task_done()\n\n    # Call task function\n    q = queue.Queue()\n\n    for i in range(int(cpus)):\n        t = threading.Thread(target=drain_path)\n        t.setDaemon(True)\n        t.start()\n\n    # Put jobs in queue\n    for pts in start_points:\n        q.put(pts)\n\n    # Wait until all tasks in the queue have been processed\n    q.join()\n\n    # Open file, which the points should be written to\n    pt_file = open('drain_points.txt', 'w')\n    face_file = open('drain_faces.txt', 'w')\n\n    # Write points to file\n    for particles in drain_points:\n        for pt in particles:\n            pt_file.write(str(pt[0]) + ',' + str(pt[1]) + ',' + str(pt[2]) + '\\t')\n        pt_file.write('\\n')\n\n    # Write face indices to file\n    for curves in drain_faces:\n        for index in curves:\n            face_file.write(str(index) + '\\t')\n        face_file.write('\\n')\n\n\n    #Close outfiles and save mesh\n    pt_file.close()\n    face_file.close()\n    pm.save_mesh('new_drain_mesh.obj', mesh)\n\n    return True\n\n\ndef drain_pools(path):\n    import pymesh as pm\n    from numpy import array, allclose\n    from numpy import sum as npsum\n    from scipy.optimize import newton\n\n    # Paths\n    meshFile = path + '/drainMesh.obj'\n    endPtsFile = path + '/EndPoints.txt'\n    volPtsFile = path + '/VolumePoints.txt'\n\n    # Initialize Mesh\n    mesh = pm.load_mesh(meshFile)\n    mesh.enable_connectivity()\n    mesh.add_attribute('face_centroid')\n    mesh.add_attribute('face_index')\n    mesh.add_attribute('face_area')\n    cenPts = mesh.get_attribute('face_centroid')\n    faceIndex = mesh.get_attribute('face_index')\n    faceArea = mesh.get_attribute('face_area')\n    faceVert = mesh.faces\n    vertices = mesh.vertices\n    #print(mesh.get_attribute_names())\n    boolWarning = None\n    poolWarning = None\n\n    # Construct face center list\n    faceCen = []\n    i = 0\n    while i < len(cenPts):\n        faceCen.append(array([float(cenPts[i]), float(cenPts[i + 1]), float(cenPts[i + 2])]))\n        i += 3\n\n    # Load points\n    ptsLine = open(endPtsFile, 'r').readlines()\n    endPts = []\n    for l in ptsLine:\n        l = l[:-1]\n        l = l.split(',')\n        endPts.append(array([float(l[0]), float(l[1]), float(l[2])]))\n    #print(len(endPts))\n\n    # Load volumes\n    volLine = open(volPtsFile, 'r').readlines()\n    vol = []\n    for v in volLine:\n        v = v[:-1]\n        vol.append(float(v))\n\n    pts = []\n    vols = []\n    fI = []\n\n    for i,pt in enumerate(endPts):\n\n        # Check if point is in list:\n        if i == 0:\n            pts.append(pt)\n            vols.append(vol[i])\n\n            # Find equivalent face center of points\n            for index, cen in enumerate(faceCen):\n                if allclose(cen,pt):\n                    fI.append(index)\n                    break\n\n        else:\n            found = False\n            j = 0\n            while j < len(pts):\n                # If it is in list: add volume\n                if allclose(pts[j], pt):\n                    vols[j] += vol[i]\n                    j = len(pts)\n                    found = True\n                j += 1\n\n            # Else: put point and volume in list\n            if not found:\n                pts.append(pt)\n                vols.append(vol[i])\n\n                # Find equivalent face center of points\n                for index, cen in enumerate(faceCen):\n                    if allclose(cen,pt):\n                        fI.append(index)\n                        break\n\n    # Pool function\n    def pool(faceIndex,point,volume):\n        found = False\n\n        # Compute first z-value\n        A = faceArea[faceIndex]\n        h = volume/A\n        Z = point[2]+h\n\n        # Initialize face index, z-values and areas\n        adjFace = [faceIndex, ]\n        faceZ = [point[2],]\n        faceA = [A,]\n\n        # Find adjacent faces\n        for faceIn in adjFace:\n\n            for af in mesh.get_face_adjacent_faces(faceIn):\n\n                # Get Z-value of face-centroid\n                fc = faceCen[af][2]\n\n                # Append them to list if their centroid is lower than the computed Z-value and are not already in list\n                if fc < Z:\n                    if af not in adjFace:\n\n                        # If current face holds a volume add that volume to the current volume\n                        if af in fI:\n                            #print('found in fI')\n                            queueIndex = fI.index(af)\n\n                            if queueIndex in notDoneList:\n                                #print('found in notDoneList')\n                                volume += vols[queueIndex]\n                                notDoneList.remove(queueIndex)\n                                doneList.append(queueIndex)\n\n                            elif queueIndex in doneList:\n                                #print('found in doneList')\n                                vols[queueIndex] += volume\n                                notDoneList.append(queueIndex)\n                                doneList.remove(queueIndex)\n                                return\n\n                            else:\n                                pass\n\n                        # Append Z-value, area and face-index\n                        faceZ.append(fc)\n                        faceA.append(faceArea[af])\n                        adjFace.append(int(af))\n\n                        # Convert to numpy array\n                        faZ = array(faceZ)\n                        faA = array(faceA)\n\n                        # Compute new z-value\n                        Z = (npsum(faZ*faA)+volume)/npsum(faA)\n\n        #print('Approx Z:',Z)\n\n        # Create approximate volume mesh\n        apxVert = []\n        apxFace = []\n        iApxVert = 0\n\n        for af in adjFace:\n            iApxVert = len(apxVert)\n            apxVert.append(vertices[faceVert[af][0]])\n            apxVert.append(vertices[faceVert[af][1]])\n            apxVert.append(vertices[faceVert[af][2]])\n            apxFace.append([iApxVert, iApxVert + 1, iApxVert + 2])\n\n        # Create boundary mesh\n        apxVert = array(apxVert)\n        apxFace = array(apxFace)\n        apxMesh = pm.form_mesh(apxVert, apxFace)\n\n        # Boundary Box\n        maxmin = apxMesh.bbox\n        x1, y1, z1 = maxmin[0]\n        x2, y2, z2 = maxmin[1]*1.1  # Increase Bbox with 10%\n        x1 = x1*0.9  # Decrease Bbox with 10%\n        y1 = y1*0.9  # Decrease Bbox with 10%\n\n        #print('apxMesh:',maxmin[0],'\\n\\t',maxmin[1])\n\n        zMax = mesh.bbox[1][2]\n        #print('zMax:',zMax)\n        #pm.save_mesh('apxmesh.obj', apxMesh)\n\n        # Findheight helper functions\n        def createBbox(z):\n            bVert = []\n            bFace = []\n            bVox = []\n\n            # Add vertices\n            bVert.append(array([x1, y1, z1]))  # 0\n            bVert.append(array([x1, y2, z1]))  # 1\n            bVert.append(array([x1, y2, z]))  # 2\n            bVert.append(array([x1, y1, z]))  # 3\n\n            bVert.append(array([x2, y2, z]))  # 4\n            bVert.append(array([x2, y2, z1]))  # 5\n            bVert.append(array([x2, y1, z1]))  # 6\n            bVert.append(array([x2, y1, z]))  # 7\n\n            # Add faces\n            bFace.append([0, 1, 3])  # side 1\n            bFace.append([1, 2, 3])  # side 1\n            bFace.append([0, 3, 7])  # side 2\n            bFace.append([0, 6, 7])  # side 2\n            bFace.append([7, 6, 5])  # side 3\n            bFace.append([5, 7, 4])  # side 3\n            bFace.append([4, 5, 1])  # side 4\n            bFace.append([4, 2, 1])  # side 4\n            bFace.append([0, 1, 6])  # side 5\n            bFace.append([1, 5, 6])  # side 5\n            bFace.append([3, 7, 2])  # side 6\n            bFace.append([2, 7, 4])  # side 6\n\n            # Add voxels\n            bVox.append([0, 2, 3, 7])\n            bVox.append([0, 1, 2, 7])\n            bVox.append([0, 1, 6, 7])\n            bVox.append([2, 4, 5, 7])\n            bVox.append([1, 2, 5, 6])\n            bVox.append([2, 4, 6, 7])\n\n            # Create boundary mesh\n            bVert = array(bVert)\n            bFace = array(bFace)\n            bVox = array(bVox)\n            bMesh = pm.form_mesh(bVert, bFace, bVox)\n            #pm.save_mesh('bMesh.obj', bMesh)\n\n            return bMesh\n\n        def getVolMesh(newMesh, bottomFaces, z):\n\n            # Prepare to create volume mesh\n            newMeshVert = newMesh.vertices\n            volVert = []\n            volFace = []\n            volVox = []\n\n            # Create volume mesh from bottom part of mesh\n            for f in bottomFaces:\n                iVer = len(volVert)\n\n                oldVerts = []\n                newVerts = []\n                for v in f:\n                    oldVerts.append(newMeshVert[v])\n                    newV = array([newMeshVert[v][0], newMeshVert[v][1], z])\n                    newVerts.append(newV)\n\n                # Append vertices\n                volVert += oldVerts\n                volVert += newVerts\n\n                # Append faces\n                volFace.append([iVer, iVer + 1, iVer + 2])\n                volFace.append([iVer + 3, iVer + 4, iVer + 5])\n\n                # Append voxels\n                volVox.append([iVer, iVer + 1, iVer + 2, iVer + 3])\n                volVox.append([iVer + 1, iVer + 3, iVer + 4, iVer + 5])\n                volVox.append([iVer + 1, iVer + 2, iVer + 3, iVer + 5])\n\n            # Create volume mesh\n            volVert = array(volVert)\n            volFace = array(volFace)\n            volVox = array(volVox)\n            volMesh = pm.form_mesh(volVert, volFace, volVox)\n\n            return volMesh\n\n        def intersectAndBottomFaces(bMesh, z):\n            warning = None\n\n            # Make intersection with auto boolean engine\n            newMesh = pm.boolean(mesh, bMesh, 'intersection')\n\n            if newMesh.num_faces == 0:\n                # Change boolean engine to Cork\n                warning = 'Changing Boolean Engine to Cork!'\n                print(warning)\n                newMesh = pm.boolean(bMesh, mesh, 'difference', engine='cork')\n\n            #pm.save_mesh('intMesh.obj', newMesh)\n\n            # Get bottom part of mesh\n            try:\n                newSource = newMesh.get_attribute('source')\n                newFace = newMesh.faces\n                bottomFaces = []\n\n                for i, s in enumerate(newSource):\n                    if int(s) == 1:\n                        bottomFaces.append(newFace[i])\n\n                return newMesh, bottomFaces, warning\n\n            except RuntimeError:\n                # Try different approach to getting bottom faces\n                newMesh.add_attribute('face_centroid')\n                newFace = newMesh.faces\n                # print('len newFace:',len(newFace))\n                # print('first newFace:',newFace[0])\n                newCen = newMesh.get_attribute('face_centroid')\n                bottomFaces = []\n\n                for newFaceIndex in range(len(newFace)):\n                    newCenZ = newCen[newFaceIndex * 3 + 2]\n                    if newCenZ < z:\n                        bottomFaces.append(newFace[newFaceIndex])\n\n                return newMesh, bottomFaces, warning\n\n        # Volume function to solve\n        def findHeight(z):\n            #print('current z:',z)\n\n            # Check if pools will overflow mesh\n            if z > zMax:\n                z = zMax\n\n            # Create Bbox\n            bMesh = createBbox(z)\n\n            # Make intersection\n            newMesh, bottomFaces, warning = intersectAndBottomFaces(bMesh, z)\n\n            # Create volume mesh\n            volMesh = getVolMesh(newMesh, bottomFaces, z)\n\n            if z == zMax:\n                return 0\n\n            else:\n                # Compute volume\n                volMesh.add_attribute('voxel_volume')\n                volVol = volMesh.get_attribute('voxel_volume')\n                volVol = sum(list((map(abs, volVol))))\n\n                #print('volume',volume)\n                #print('volVol1',volVol)\n\n                return volume - volVol\n\n        # Get final height\n        zFinal = newton(findHeight,Z)\n\n        # Create final mesh\n        def finalMesh(z):\n            poolWarning = None\n\n            # Check if pools will overflow mesh\n            if z > zMax:\n                z = zMax\n                poolWarning = 'The pool have a greater volume than the mesh can contain. Pool set to fill entire mesh.'\n\n            # Create Bbox\n            bMesh = createBbox(z)\n\n            # Make intersection\n            newMesh, bottomFaces, boolWarning = intersectAndBottomFaces(bMesh, z)\n\n            # Create volume mesh\n            volMesh = getVolMesh(newMesh, bottomFaces, z)\n\n            volMesh.add_attribute('voxel_volume')\n            volVol = volMesh.get_attribute('voxel_volume')\n            volVol = sum(list(map(abs, volVol)))\n\n            # Clean up mesh\n            volMesh, info = pm.remove_isolated_vertices(volMesh)\n            #print('num vertex removed', info[\"num_vertex_removed\"])\n            volMesh, info = pm.remove_duplicated_faces(volMesh)\n\n            return volMesh, volVol, poolWarning, poolWarning\n\n        # Save final mesh\n        #print('zFinal',zFinal,'type:',type(zFinal))\n        finalMesh, finalVol, poolWarning, boolWarning = finalMesh(zFinal)\n        meshName = \"poolMesh_\" + str(faceIndex) + \".obj\"\n        hullMesh = pm.compute_outer_hull(finalMesh)\n        pm.save_mesh(meshName, hullMesh)\n\n        print(' ')\n        print('volume',\"{0:.3f}\".format(volume))\n        print('computed volume',\"{0:.3f}\".format(finalVol))\n        print('closed?',finalMesh.is_closed())\n        print(' ')\n\n        return meshName\n\n\n    # Initialize pool-loop\n    Z = []\n    i = 0\n    doneList = []\n    notDoneList = list(range(0,len(pts)))\n    loopLength = len(notDoneList)\n    meshNames = []\n\n    # Use pool function on each set of points\n    while i < loopLength:\n        I = notDoneList.pop(i)\n        names = pool(fI[I],pts[I],vols[I])\n\n        # Put meshNames in name list\n        if names:\n            if not names in meshNames:\n                meshNames.append(names)\n            else:\n                pass\n\n        doneList.append(i)\n        loopLength = len(notDoneList)\n\n    # Open InData and edit last line\n    file_obj = open(\"InData.txt\",'r')\n    file = file_obj.readlines()\n    file_obj.close()\n\n    mNames = ''\n    for n in meshNames:\n        mNames += ',' + n\n\n    file[6] = 'meshNames.txt' + mNames\n\n    outfile_obj = open(\"InData.txt\", 'w')\n    outfile_obj.writelines(file)\n\n    # Write meshNames.txt\n    file_obj = open(\"meshNames.txt\", 'w')\n    file_obj.write(mNames)\n    file_obj.close()\n\n    #print('function warn', [boolWarning, poolWarning])\n    if boolWarning or poolWarning:\n        return [boolWarning, poolWarning]\n    else:\n        return None\n\n\nclass simple_rain():\n    def __init__(self, cpus, precipitation, windSpeed, windDirection, testPoints, testVectors, context, temperature, k):\n        self.prec = precipitation\n        self.windSpeed = windSpeed\n        self.windDir = windDirection\n        self.testPts = testPoints\n        self.testVecs = testVectors\n        self.context = context\n        self.temp = temperature\n        self.kMiss = k[0]\n        self.kHit = k[1]\n        self.dirVec = False\n        self.hourlyResult = False\n        self.wdr = False\n        self.xyAngles = []\n        self.yzAngles = []\n        self.cpus = int(cpus)\n\n    # Final function\n    def rainHits(self):\n        from math import degrees, exp, log, acos, sqrt, pi, cos, radians\n        from rhinoscriptsyntax import XformMultiply, VectorCreate, AddPoint, VectorTransform, XformRotation2\n        from Rhino.Geometry.Intersect.Intersection import RayShoot\n        from Rhino.Geometry import Ray3d\n        import threading\n        import Queue\n\n        # Helper functions\n\n        def rain_vector(Vw, regn):\n\n            # Rain drop radius:\n            A = 1.3\n            p = 0.232\n            n = 2.25\n\n            if regn == 0:\n                return 0\n\n            def f_a(I):\n                return A * I ** p\n\n            a = f_a(regn)\n            r = a * exp(log(-log(0.5)) / n) / 1000\n\n            # Angle:\n            # rho_L = 1.2\n            # rho_w = 1000\n            # g = 9.81\n            # c = 0.3\n            # alpha = 3*c*rho_L*Vw^2*r^2/sqrt(4*r^4*(9*Vw^2*c^2*rho_L^2+64*g^2*r^2*rho_w^2))\n            # Simplified it becomes:\n\n            a = (0.54 * Vw ** 2 * r ** 2) / sqrt(r ** 4 * (1.1664 * Vw ** 2 + 6.159110400 * 10 ** 9 * r ** 2))\n            if a > 1:\n                a = 1\n            alpha = acos(a)\n\n            return alpha\n\n        def rotate_yz(angle):\n            return XformRotation2(angle, [1, 0, 0], [0, 0, 0])\n\n        def rotate_xy(angle):\n            return XformRotation2(angle, [0, 0, 1], [0, 0, 0])\n\n        # Correction of wind direction\n        def B_wind(angle, direction):\n            c = 360 - (angle + 90)\n            # print(c)\n\n            a = abs(c - direction)\n            if a < 180:\n                b = a\n            else:\n                b = 360 - a\n\n            return radians(b)\n\n        def rayShoot():\n            \"\"\"Build on: Ladybug - RayTrace\"\"\"\n\n            # Initialize\n            while not q.empty():\n                numOfBounce = 1\n                startPt, xyAngle, yzAngle = q.get()\n\n                vector = direction_vector\n                ray = Ray3d(startPt, vector)\n                # Check the wind direction\n                B = B_wind(xyAngle, self.windDir[i])\n                # print(B)\n                if B > pi / 2:\n                    # print('more than 90')\n                    hourly_rain.append(0)\n                    hourly_result.append(False)\n\n                else:\n                    # print('less than 90')\n                    # Compute rain amount\n                    K_wind = cos(B) / sqrt(\n                        1 + 1142 * (sqrt(self.prec[i]) / self.windSpeed[i] ** 4)) * exp(\n                        -12 / (self.windSpeed[i] * 5 * self.prec[i] ** (0.25)))\n\n                    # Shoot ray\n                    intPt = RayShoot(ray, [self.context], numOfBounce)\n\n                    # Check for intersection\n                    if intPt:\n                        # print('Intersection!')\n                        hourly_result.append(True)\n                        kRain = self.kHit\n                        # verticalFactor = (1/(90*K_wind*kRain)-1/90)*yzAngle\n                        # print(verticalFactor)\n                        hourly_rain.append((K_wind * kRain * self.prec[i]))\n\n                    else:\n                        # print('No intersection!')\n                        hourly_result.append(False)\n                        kRain = self.kMiss\n                        # verticalFactor = (1 / (90 * K_wind * kRain) - 1 / 90) * yzAngle\n                        # print('vf',verticalFactor)\n                        hourly_rain.append((K_wind * kRain * self.prec[i]))\n\n                # print('done')\n                q.task_done()\n\n        result = []\n        dirVec_hourly = []\n        wdr = []\n\n        for i in range(0, len(self.prec)):\n\n            if self.temp[i] <= -2 or self.windSpeed[i] <= 0 or self.prec[i] <= 0:\n                dirVec_hourly.append(None)\n                result.append([False] * len(self.testPts))\n\n            else:\n\n                # Rotate vectors towards the sky\n                R_v = rain_vector(self.windSpeed[i], self.prec[i])\n                towards_sky = rotate_yz(degrees(R_v))\n\n                # Rotate vectors towards the wind\n                w_d = self.windDir[i]\n                towards_wind = rotate_xy(w_d)\n\n                # Combine:\n                transformation = XformMultiply(towards_wind, towards_sky)\n                north_vector = VectorCreate(AddPoint(0, 0, 0), AddPoint(0, -1, 0))\n                direction_vector = VectorTransform(north_vector, transformation)\n                hourly_result = []\n                hourly_rain = []\n\n                # Put jobs in queue\n                q = Queue.Queue()\n                for fi, pts in enumerate(self.testPts):\n                    q.put((pts, self.xyAngles[fi], self.yzAngles[fi]))\n                # Call task function\n\n                for c in range(self.cpus):\n                    t = threading.Thread(target=rayShoot)\n                    t.setDaemon(True)\n                    t.start()\n\n                # break\n                # Wait until all tasks in the queue have been processed\n                q.join()\n\n                dirVec_hourly.append(direction_vector)\n                result.append(hourly_result)\n                wdr.append(hourly_rain)\n\n        self.hourlyResult = result\n        self.dirVec = dirVec_hourly\n        self.wdr = wdr\n\n    def computeAngles(self):\n        import Rhino.Geometry as rc\n        from math import degrees\n\n        # Construct planes\n        zero = rc.Point3d(0, 0, 0)\n        z = rc.Vector3d(0, 0, 1)\n        x = rc.Vector3d(1, 0, 0)\n        y = rc.Vector3d(0, 1, 0)\n        xy = rc.Plane(zero, z).WorldXY\n        yz = rc.Plane(zero, x).WorldYZ\n\n        # Compute angles on the XY and YZ plane\n        for fn in self.testVecs:\n            self.xyAngles.append(degrees(rc.Vector3d.VectorAngle(fn, y, xy)))\n            yz_tmp = degrees(rc.Vector3d.VectorAngle(fn, z, yz))\n\n            # Correct angles\n            if yz_tmp > 90:\n                yz_tmp = 180 - yz_tmp\n            elif yz_tmp > 180:\n                yz_tmp = yz_tmp - 180\n            elif yz_tmp > 270:\n                yz_tmp = abs(yz_tmp - 360)\n            elif yz_tmp < 0:\n                yz_tmp = yz_tmp * (-1)\n\n            self.yzAngles.append(yz_tmp)\n\n\ndef topographic_index(meshPath, drainCurvesPath):\n    import numpy as np\n    import GeometryClasses as gc\n    import pymesh as pm\n\n    # Load mesh and curves\n    mesh = pm.load_mesh(meshPath)\n    drainCurves = []\n    file = open(drainCurvesPath, 'r')\n    lines = file.readlines()\n    for l in lines:\n        drainCurves.append(int(i) for i in l.split(',')[1:-1])\n\n    # Initilize mesh data\n    mesh.add_attribute('face_normal')\n    mesh.add_attribute('face_area')\n    faceArea = mesh.get_attribute('face_area')\n    fn = mesh.get_attribute('face_normal')\n    faceNormal = []\n    i = 0\n    while i < len(fn):\n        faceNormal.append(np.array([fn[i], fn[i+1], fn[i+2]]))\n        i += 3\n    drainArea = faceArea\n    TI = []\n\n    def topoIndex(a, beta):\n        return np.log(a / np.tan(beta))\n\n    def computeBeta(normal):\n        z = np.array([0,0,1])\n        return gc.angleBetweenVectors(z, normal, forceAngle='acute')[0]\n\n    def processDrainCurve(curveIndex):\n        \"\"\"Processes a single drain curve\"\"\"\n\n        A = 0\n\n        for face in drainCurves[curveIndex]:\n            a = faceArea[face]\n            drainArea[face] += a\n            A += a\n\n        return True\n\n    for curve in range(len(drainCurves)):\n        processDrainCurve(curve)\n\n    for face in range(mesh.num_faces):\n        a = drainArea[face]\n        b = computeBeta(faceNormal[face])\n        TI.append(topoIndex(a,b))\n\n    # Write topographic indices to file\n    topoFile = open('topographicIndex.txt', 'w')\n\n    for face in TI:\n        topoFile.write(str(face) + '\\n')\n    topoFile.write('\\n')\n\n    topoFile.close()\n\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "classes", "point", "line", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "livestock3d_livestock_9f1b25e8b6.json", "repo": "livestock3d/livestock"}
{"instruction": "Extracts the SSH information from a sticky", "code": "__author__ = \"Christian Kongsgaard\"\n__license__ = \"GNU GPLv3\"\n\n# -------------------------------------------------------------------------------------------------------------------- #\n# Imports\n\n# Module imports\nimport os\n\n# Livestock imports\nimport livestock.lib.misc as gh_misc\nimport livestock.lib.templates as templates\n\n# Grasshopper imports\nimport scriptcontext as sc\n\n\n# -------------------------------------------------------------------------------------------------------------------- #\n# Grasshopper SSH functions\n\nlivestock_path = r'C:\\livestock'\nssh_path = os.path.join(livestock_path, 'ssh')\nlocal_path = os.path.join(livestock_path, 'local')\n\n\ndef get_ssh():\n    \"\"\"Extracts the SSH information from a sticky\"\"\"\n\n    ip = str(sc.sticky[\"SSH\"]['ip'])\n    port = str(sc.sticky[\"SSH\"]['port'])\n    user = str(sc.sticky[\"SSH\"]['user'])\n    pw = str(sc.sticky[\"SSH\"]['password'])\n\n    ssh_dict = {'ip': ip, 'port': port, 'user': user, 'password': pw}\n\n    return ssh_dict\n\n\ndef clean_ssh_folder():\n    \"\"\"Cleans the livestock/ssh folder on the C drive.\"\"\"\n\n    if os.path.isdir(ssh_path):\n        for file in os.listdir(ssh_path):\n            os.remove(ssh_path + '/' + file)\n    else:\n        os.mkdir(ssh_path)\n\n\ndef clean_local_folder():\n    \"\"\"Cleans the livestock/local folder on the C drive.\"\"\"\n\n    if os.path.isdir(local_path):\n        for file in os.listdir(local_path):\n            os.remove(local_path + '/' + file)\n    else:\n        os.mkdir(local_path)\n\n\ndef write_ssh_commands(ssh_dict):\n    \"\"\"\n    Write the files need for Livestock SSH connection to work.\n\n    :param ssh_dict: Dictionary with all SSH information. Needs to be on the following form:\n    {'ip': string, 'user': string,\n    'port': string, 'password': 'string',\n    'file_transfer': list of strings, 'file_run': list of strings,\n    'file_return': list of strings, 'template': string}\n    \"\"\"\n\n    # Write SSH commands\n    gh_misc.write_file([ssh_dict['ip'],\n                        ssh_dict['port'],\n                        ssh_dict['user'],\n                        ssh_dict['password'],\n                        ssh_dict['file_transfer'],\n                        ssh_dict['file_run'],\n                        ssh_dict['file_return']\n                        ],\n                        ssh_path,\n                        'in_data')\n\n    # Write templates\n    templates.ssh_template(ssh_path)\n    templates.pick_template(ssh_dict['template'], ssh_path)\n\n    return True\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["functions"], "original_file": "livestock3d_livestock_gh_6ea5e2eaab.json", "repo": "livestock3d/livestock_gh"}
{"instruction": "Extracts the SSH information from a sticky", "code": "__author__ = \"Christian Kongsgaard\"\n__license__ = \"GNU GPLv3\"\n\n# -------------------------------------------------------------------------------------------------------------------- #\n# Imports\n\n# Module imports\nimport os\n\n# Livestock imports\nimport livestock.lib.misc as gh_misc\nimport livestock.lib.templates as templates\n\n# Grasshopper imports\nimport scriptcontext as sc\n\n\n# -------------------------------------------------------------------------------------------------------------------- #\n# Grasshopper SSH functions\n\nlivestock_path = r'C:\\livestock'\nssh_path = os.path.join(livestock_path, 'ssh')\nlocal_path = os.path.join(livestock_path, 'local')\n\n\ndef get_ssh():\n    \"\"\"Extracts the SSH information from a sticky\"\"\"\n\n    ip = str(sc.sticky[\"SSH\"]['ip'])\n    port = str(sc.sticky[\"SSH\"]['port'])\n    user = str(sc.sticky[\"SSH\"]['user'])\n    pw = str(sc.sticky[\"SSH\"]['password'])\n\n    ssh_dict = {'ip': ip, 'port': port, 'user': user, 'password': pw}\n\n    return ssh_dict\n\n\ndef clean_ssh_folder():\n    \"\"\"Cleans the livestock/ssh folder on the C drive.\"\"\"\n\n    if os.path.isdir(ssh_path):\n        for file in os.listdir(ssh_path):\n            os.remove(ssh_path + '/' + file)\n    else:\n        os.mkdir(ssh_path)\n\n\ndef clean_local_folder():\n    \"\"\"Cleans the livestock/local folder on the C drive.\"\"\"\n\n    if os.path.isdir(local_path):\n        for file in os.listdir(local_path):\n            os.remove(local_path + '/' + file)\n    else:\n        os.mkdir(local_path)\n\n\ndef write_ssh_commands(ssh_dict):\n    \"\"\"\n    Write the files need for Livestock SSH connection to work.\n\n    :param ssh_dict: Dictionary with all SSH information. Needs to be on the following form:\n    {'ip': string, 'user': string,\n    'port': string, 'password': 'string',\n    'file_transfer': list of strings, 'file_run': list of strings,\n    'file_return': list of strings, 'template': string}\n    \"\"\"\n\n    # Write SSH commands\n    gh_misc.write_file([ssh_dict['ip'],\n                        ssh_dict['port'],\n                        ssh_dict['user'],\n                        ssh_dict['password'],\n                        ssh_dict['file_transfer'],\n                        ssh_dict['file_run'],\n                        ssh_dict['file_return']\n                        ],\n                        ssh_path,\n                        'in_data')\n\n    # Write templates\n    templates.ssh_template(ssh_path)\n    templates.pick_template(ssh_dict['template'], ssh_path)\n\n    return True\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["functions"], "original_file": "livestock3d_livestock_gh_ba5a1736a2.json", "repo": "livestock3d/livestock_gh"}
{"instruction": "Uses GPT to manipulate Grasshopper scripts through natural language.", "code": "from ghpythonlib.componentbase import dotnetcompiledcomponent as component\r\nimport Grasshopper, GhPython\r\nimport System\r\nimport Rhino\r\nimport rhinoscriptsyntax as rs\r\nimport clr\r\nimport json\r\nimport traceback\r\nimport System\r\nfrom System import Array\r\nfrom System.Text import Encoding\r\nfrom System.Net import WebRequest, WebHeaderCollection, WebProxy, WebException\r\n\r\n\r\n# FUNCTION TO SEND API CALL\r\ndef send_request(user_prompt, Description, API_Key):\r\n    plugin_context = \"You are GrasshopperAI, an AI tool working within Grasshopper to manipulate Grasshopper scripts through natural language. You will be given a description of the entire script and data about the sliders in the format <SLIDER_NAME> - <SLIDER_VALUE>. After understanding the prompt, you have to understand what slider to change and what the new slider value would be. To do that, all you have to do is call a function that I have already programmed which is change_slider_value(str(<SLIDER_NAME>), <NEW_SLIDER_VALUE>). Remember to respond only with the function and enclose the name in an str() function.\" # system prompt for gpt\r\n    url = \"https://api.openai.com/v1/chat/completions\"  # reference api url\r\n    data = { # prepare data for request\r\n        \"model\": \"gpt-3.5-turbo-16k\", # gpt model, gpt-3.5 is much cheaper to run than gpt4\r\n        \"messages\": [\r\n            {\r\n                \"role\": \"system\",\r\n                \"content\": str(plugin_context) + \"\\n\" + \"\\n\" + str(Description)  # system prompt is set up here\r\n            },\r\n            {\r\n                \"role\": \"user\",\r\n                \"content\": user_prompt  # user prompt goes here\r\n            }\r\n        ],\r\n        \"temperature\": 0.5,\r\n        \"max_tokens\": 4096,\r\n        \"top_p\": 1,\r\n        \"frequency_penalty\": 0,\r\n        \"presence_penalty\": 0\r\n    }\r\n    data_string = json.dumps(data)\r\n    data_bytes = Encoding.UTF8.GetBytes(data_string)\r\n    request = WebRequest.Create(url) # create a web request\r\n    request.Method = \"POST\"\r\n    request.ContentType = \"application/json\"\r\n    request.Headers.Add(\"Authorization\", \"Bearer \" + str(API_Key)) # authentication\r\n    request_stream = request.GetRequestStream() # write request to data stream\r\n    request_stream.Write(Array[System.Byte](data_bytes), 0, len(data_bytes))\r\n    request_stream.Close()\r\n    try:\r\n        response = request.GetResponse()\r\n        response_stream = response.GetResponseStream()\r\n        response_reader = System.IO.StreamReader(response_stream)\r\n        response_text = response_reader.ReadToEnd()\r\n\r\n        response_json = json.loads(response_text) # get response from openai\r\n        return response_json\r\n\r\n    except WebException as e: # error handling\r\n        display_error(str(e))\r\n        return None\r\n\r\n\r\n# DEFINE USER PROMPT HERE\r\ndef construct_prompt(param_data):\r\n    sliders = str(param_data)[1:-1] # get slider data\r\n    user_prompt = rs.StringBox(message=\"Enter prompt\", title=\"Brain\")\r\n    if user_prompt is None:  # check if user cancelled the input\r\n        return None\r\n    prompt = str(sliders) + \"\\n\" + \"\\n\" + str(user_prompt) # construct prompt\r\n    return prompt\r\n\r\n\r\nclass Brain(component): # set up component class\r\n    def __new__(cls):\r\n        instance = Grasshopper.Kernel.GH_Component.__new__(cls,\r\n            \"Brain\", \"Brain\", \"\"\"Uses GPT to manipulate Grasshopper scripts through natural language.\"\"\", \"Params\", \"Util\") # component info\r\n        return instance\r\n    \r\n    def get_ComponentGuid(self):\r\n        return System.Guid(\"bc7f32af-9b9c-4cf6-938a-21b24702c0da\")\r\n    \r\n    def SetUpParam(self, p, name, nickname, description): # set up component parameters\r\n        p.Name = name\r\n        p.NickName = nickname\r\n        p.Description = description\r\n        p.Optional = True\r\n    \r\n    def RegisterInputParams(self, pManager):\r\n        p = Grasshopper.Kernel.Parameters.Param_Number()\r\n        self.SetUpParam(p, \"Parameters\", \"P\", \"Parameters to control\")\r\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.list\r\n        self.Params.Input.Add(p)\r\n        \r\n        p = Grasshopper.Kernel.Parameters.Param_String()\r\n        self.SetUpParam(p, \"API_Key\", \"K\", \"OpenAI API Key\")\r\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\r\n        self.Params.Input.Add(p)\r\n        \r\n        p = Grasshopper.Kernel.Parameters.Param_String()\r\n        self.SetUpParam(p, \"Description\", \"D\", \"A brief description of the GH definition\")\r\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\r\n        self.Params.Input.Add(p)\r\n        \r\n        p = Grasshopper.Kernel.Parameters.Param_Boolean()\r\n        self.SetUpParam(p, \"Trigger\", \"R\", \"Runs the component\")\r\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\r\n        self.Params.Input.Add(p)\r\n        \r\n    def RegisterOutputParams(self, pManager):\r\n        pass    \r\n\r\n    def SolveInstance(self, DA):\r\n        p0 = self.marshal.GetInput(DA, 0)\r\n        p1 = self.marshal.GetInput(DA, 1)\r\n        p2 = self.marshal.GetInput(DA, 2)\r\n        p3 = self.marshal.GetInput(DA, 3)\r\n        result = self.RunScript(p0, p1, p2, p3)\r\n\r\n    def get_Internal_Icon_24x24(self): # component icon\r\n        o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAFiUAABYlAUlSJPAAAAI6SURBVEhLvdVJyE5RHMfxa54zZYqQspAsJDZkLgtZGBYoUli9xcKwYMdKWFmYsjBmWGBhxUqRjQgrJXNKUobM0/d77jk99z3v875vj0d+9em553Tv+d9znnPvLRpMn/j7TzIBY9AVk3AFvyt+4TrGoaGsxWM4gO7jG37iAtZhYzy20FtMQ6fpi4vwouc4hZOx/QJTkWcxPsEbGmhHR0mD7URvO8guOIsZoVWme9QPw7ABXteCdjMbnrQ3tMpMgX2HQ6sopuMdLPgFLpm+w/NeYyHqxkE8aVRoFUUX3MQHjLCDOLiDPcFRrMECWNhZW9QxDsEZtspdeHHKSnjyptAql+8HVoVW/YzEPnjdETuquQOna9yWz2Dbfe9SfcV7WHg1lkbL4u9wGGd+BhaZZUfKHtjpfjdX4Yx8Fs7BYs6guuZV15AyFC7XwdCKGQ//vMuhVT48nuRWddAtGILJmIM3yIusQIpb91Z5WMtxeOL80Kr98bdDq3XcmhauFngInyXjLG+Uh7UMhmv9CP4PnvwRB5BnIqqDJ9vQAxY4hjbZDk9cH1rlVvQ14fJU41K6pHmBl3DtPV6ENvHOH8Dpb8VyWOAS5sIH8iy8w0E4gbyITqPdzIQDeIfuHPmnfYZLaHszjFs2H/wVOn0vdUOvqGc0AKMxFsa+e8gLuEz90XTSSy73FOll+dfxYfJO6xU4j6azH/UG1zw0Fb9e6c2Z8/vRdNI+r3LndPjBaSR+xZZgB3bDb3TaWf87RfEHQBfFoHsNd3QAAAAASUVORK5CYII=\"\r\n        return System.Drawing.Bitmap(System.IO.MemoryStream(System.Convert.FromBase64String(o)))\r\n\r\n    def RunScript(self, Parameters, API_Key, Description, Trigger):\r\n        # FUNCTION FOR ERROR HANDLING\r\n        def display_error(message): # display error box\r\n            rs.MessageBox(message, 16, \"Error\")\r\n        # FUNCTION TO CHANGE SLIDER VALUE\r\n        def change_slider_value(nickname, value):\r\n            ghdoc = self.OnPingDocument()\r\n            if not ghdoc:\r\n                display_error(\"Error accessing Grasshopper document.\")\r\n                return\r\n            for obj in ghdoc.Objects:\r\n                if isinstance(obj, Grasshopper.Kernel.Special.GH_NumberSlider) and obj.NickName == nickname:\r\n                    if obj.Slider.Minimum <= value <= obj.Slider.Maximum: # check slider domains\r\n                        obj.SetSliderValue(value)\r\n                        obj.ExpireSolution(True)\r\n                    else:\r\n                        display_error(\"{} is out of range for '{}'.\".format(value, nickname)) # error handling\r\n\r\n        # START RUNSCRIPT\r\n        ghdoc = self.OnPingDocument()\r\n        if not ghdoc:\r\n            display_error(\"Error accessing Grasshopper document.\") # error handling\r\n        else:\r\n            input_params = self.Params.Input[0].Sources if self.Params.Input else [] # get component inputs\r\n            param_data = [(param.NickName, param.CurrentValue) for param in input_params if isinstance(param, Grasshopper.Kernel.Special.GH_NumberSlider)] # get slider data\r\n        if param_data:\r\n            if Trigger:\r\n                prompt = construct_prompt(param_data) # construct user prompt\r\n                if prompt is not None: # avoid running when user hits cancel\r\n                    response = send_request(prompt, Description, API_Key) # send api call\r\n                    if response:  # check if response is not None\r\n                        function = response['choices'][0]['message']['content'] # pick out the answer from the response json\r\n                        try:\r\n                            eval(str(function)) # call function\r\n                        except Exception as e:  # catch exceptions raised during the evaluation\r\n                            display_error(\"Error evaluating function: {}\".format(str(e)))\r\n                    else:\r\n                        display_error(\"Failed to get a valid response from the OpenAI API.\")\r\n                else:\r\n                    pass\r\n\r\n\r\nimport GhPython\r\nimport System\r\n\r\nclass AssemblyInfo(GhPython.Assemblies.PythonAssemblyInfo):\r\n    def get_AssemblyName(self):\r\n        return \"Brain\"\r\n    \r\n    def get_AssemblyDescription(self):\r\n        return \"\"\"\"\"\"\r\n\r\n    def get_AssemblyVersion(self):\r\n        return \"0.1\"\r\n\r\n    def get_AuthorName(self):\r\n        return \"Sandheep Rajkumar\" # haha me hahaha\r\n    \r\n    def get_Id(self):\r\n        return System.Guid(\"88adbca2-bd32-4edc-9be2-9ebf3faaf3fb\")\r\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "classes", "functions"], "original_file": "lolrazh_Brain_8ad3a577ef.json", "repo": "lolrazh/Brain"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "__all__ = ['InProcess','InteropWrappers','Notifications']\nfrom typing import Tuple, Set, Iterable, List\n\n\nclass Analytics:\n    @overload\n    def __init__(self, TrackingID: str, Name: str): ...\n    @overload\n    def __init__(self, TrackingID: str, Name: str, Platform: str, InstallerId: str, Version: str): ...\n    @property\n    def AppInstallerId(self) -> str: ...\n    @property\n    def AppName(self) -> str: ...\n    @property\n    def AppPlatform(self) -> str: ...\n    @property\n    def AppVersion(self) -> str: ...\n    @property\n    def GoogleAnalyticsTrackingID(self) -> str: ...\n    @property\n    def UsageStatisticsEnabled() -> bool: ...\n    @property\n    def UserId() -> Guid: ...\n    @overload\n    def Send(self, data: NameValueCollection) -> None: ...\n    @overload\n    def Send(self, Category: str) -> None: ...\n    @overload\n    def Send(self, Category: str, Action: str) -> None: ...\n    @overload\n    def Send(self, Category: str, Action: str, Label: str) -> None: ...\n    @overload\n    def Send(self, Category: str, Action: str, Label: str, Value: UInt32) -> None: ...\n    @AppInstallerId.setter\n    def AppInstallerId(self, value: str) -> None: ...\n    @AppName.setter\n    def AppName(self, value: str) -> None: ...\n    @AppPlatform.setter\n    def AppPlatform(self, value: str) -> None: ...\n    @AppVersion.setter\n    def AppVersion(self, value: str) -> None: ...\n    @GoogleAnalyticsTrackingID.setter\n    def GoogleAnalyticsTrackingID(self, value: str) -> None: ...\n\n\nclass AssemblyResolver:\n    def AddSearchFile(file: str) -> None: ...\n    def AddSearchFolder(folder: str) -> None: ...\n\n\nclass CommonObject:\n    def Dispose(self) -> None: ...\n    def EnsurePrivateCopy(self) -> None: ...\n    @property\n    def Disposed(self) -> bool: ...\n    @property\n    def HasUserData(self) -> bool: ...\n    @property\n    def IsDocumentControlled(self) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def PerformCorruptionTesting() -> bool: ...\n    @property\n    def UserData(self) -> UserDataList: ...\n    @property\n    def UserDictionary(self) -> ArchivableDictionary: ...\n    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...\n    def IsValidWithLog(self) -> Tuple[bool, str]: ...\n    @PerformCorruptionTesting.setter\n    def PerformCorruptionTesting(value: bool) -> None: ...\n\n\nclass CorruptGeometryException:\n    @property\n    def CommonObject(self) -> CommonObject: ...\n    @property\n    def Pointer(self) -> IntPtr: ...\n\n\nclass DocumentCollectedException:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, message: str): ...\n\n\nclass ExceptionReportDelegate:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, source: str, ex: Exception, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, source: str, ex: Exception) -> None: ...\n\n\nclass HostUtils:\n    def add_OnExceptionReport(value: ExceptionReportDelegate) -> None: ...\n    def add_OnSendLogMessageToCloud(value: SendLogMessageToCloudDelegate) -> None: ...\n    def AutoInstallPlugInFolder(currentUser: bool) -> str: ...\n    def CallFromCoreRhino(task: str) -> int: ...\n    def CheckForRdk(throwOnFalse: bool, usePreviousResult: bool) -> bool: ...\n    def ClearFpuExceptionStatus() -> None: ...\n    @overload\n    def CreateCommands(plugin: PlugIn) -> None: ...\n    @overload\n    def CreateCommands(pPlugIn: IntPtr, pluginAssembly: Assembly) -> int: ...\n    def CreatePlugIn(pluginType: Type, printDebugMessages: bool) -> PlugIn: ...\n    @overload\n    def DebugDumpToString(bezierCurve: BezierCurve) -> str: ...\n    @overload\n    def DebugDumpToString(geometry: GeometryBase) -> str: ...\n    @overload\n    def DebugString(msg: str) -> None: ...\n    @overload\n    def DebugString(format: str, args: Set(Object)) -> None: ...\n    def DisplayOleAlerts(display: bool) -> None: ...\n    @overload\n    def ExceptionReport(ex: Exception) -> None: ...\n    @overload\n    def ExceptionReport(source: str, ex: Exception) -> None: ...\n    def FileNameEndsWithRhinoBackupExtension(fileName: str) -> bool: ...\n    def FileNameEndsWithRhinoExtension(fileName: str) -> bool: ...\n    @property\n    def ComputerSerialNumber() -> str: ...\n    @property\n    def CurrentOSLanguage() -> UInt32: ...\n    @property\n    def DeviceId() -> Guid: ...\n    @property\n    def DeviceName() -> str: ...\n    @property\n    def OperatingSystemBuildNumber() -> str: ...\n    @property\n    def OperatingSystemEdition() -> str: ...\n    @property\n    def OperatingSystemInstallationType() -> str: ...\n    @property\n    def OperatingSystemProductName() -> str: ...\n    @property\n    def OperatingSystemVersion() -> str: ...\n    @property\n    def RunningInDarkMode() -> bool: ...\n    @property\n    def RunningInMono() -> bool: ...\n    @property\n    def RunningInRhino() -> bool: ...\n    @property\n    def RunningOnOSX() -> bool: ...\n    @property\n    def RunningOnWindows() -> bool: ...\n    @property\n    def SendDebugToCommandLine() -> bool: ...\n    def GetAbsolutePath(relativePath: str, bRelativePathisFileName: bool, relativeTo: str, bRelativeToIsFileName: bool) -> Tuple[bool, str]: ...\n    def GetActivePlugInVersionFolders(currentUser: bool) -> Iterable[DirectoryInfo]: ...\n    def GetAssemblySearchPaths() -> Set(str): ...\n    def GetCurrentProcessInfo() -> Tuple[str, Version]: ...\n    def GetCustomComputeEndpoints() -> Set(Tuple): ...\n    def GetPlatformService(assemblyPath: str, typeFullName: str) -> T: ...\n    def GetRhinoDotNetAssembly() -> Assembly: ...\n    def InitializeRhinoCommon() -> None: ...\n    def InitializeRhinoCommon_RDK() -> None: ...\n    def InitializeZooClient() -> None: ...\n    def InPlaceConstCast(geometry: GeometryBase, makeNonConst: bool) -> None: ...\n    def IsManagedDll(path: str) -> bool: ...\n    def IsRhinoBackupFileExtension(fileExtension: str) -> bool: ...\n    def IsRhinoFileExtension(fileExtension: str) -> bool: ...\n    def RecordInitInstanceTime(description: str) -> None: ...\n    def RegisterComputeEndpoint(endpointPath: str, t: Type) -> None: ...\n    def RegisterDynamicCommand(plugin: PlugIn, cmd: Command) -> bool: ...\n    def RegisterNamedCallback(name: str, callback: EventHandler) -> None: ...\n    def remove_OnExceptionReport(value: ExceptionReportDelegate) -> None: ...\n    def remove_OnSendLogMessageToCloud(value: SendLogMessageToCloudDelegate) -> None: ...\n    def RhinoCommonExceptionHandler(title: str, sender: Object, ex: Exception) -> None: ...\n    def SendLogMessageToCloudCallbackProc(msg_type: LogMessageType, pwStringClass: IntPtr, pwStringDesc: IntPtr, pwStringMessage: IntPtr) -> None: ...\n    @SendDebugToCommandLine.setter\n    def SendDebugToCommandLine(value: bool) -> None: ...\n    def SetInShutDown() -> None: ...\n    def ShutDownRhinoCommon_RDK() -> None: ...\n    def UnhandledThreadException(sender: Object, e: ThreadExceptionEventArgs) -> None: ...\n\n\nclass ImportOptionsSections:\n    AdvancedDisplay = 0\n    Alias = 1\n    Appearance = 2\n    ChooseOneObject = 3\n    ControlPointContextMenu = 4\n    CursorToolTip = 5\n    Display = 6\n    File = 7\n    General = 8\n    Grid = 9\n    ModelAid = 10\n    Mouse = 11\n    ObjectContextMenu = 12\n    SearchPath = 13\n    ShortcutKey = 14\n    Smarttrack = 15\n    View = 16\n    ViewportContextMenu = 17\n    ToolPaletteSettings = 18\n    Count = 19\n\n\nclass InstanceAttributeField:\n    def __init__(self, key: str, prompt: str, defaultValue: str): ...\n    @property\n    def DefaultValue(self) -> str: ...\n    @property\n    def Key(self) -> str: ...\n    @property\n    def Prompt(self) -> str: ...\n\n\nclass Interop:\n    def CreateFromNativePointer(pGeometry: IntPtr) -> GeometryBase: ...\n    def FileReadOptionsConstPointer(options: FileReadOptions) -> IntPtr: ...\n    def FileWriteOptionsConstPointer(options: FileWriteOptions) -> IntPtr: ...\n    def FontFromPointer(ptrManagedFont: IntPtr) -> Font: ...\n    def FromOnBrep(source: Object) -> Brep: ...\n    def FromOnCurve(source: Object) -> Curve: ...\n    def FromOnMesh(source: Object) -> Mesh: ...\n    def FromOnSurface(source: Object) -> Surface: ...\n    def NativeGeometryConstPointer(geometry: GeometryBase) -> IntPtr: ...\n    def NativeGeometryNonConstPointer(geometry: GeometryBase) -> IntPtr: ...\n    @overload\n    def NativeNonConstPointer(settings: ViewCaptureSettings) -> IntPtr: ...\n    @overload\n    def NativeNonConstPointer(pipeline: DisplayPipeline) -> IntPtr: ...\n    @overload\n    def NativeNonConstPointer(getPoint: GetPoint) -> IntPtr: ...\n    @overload\n    def NativeNonConstPointer(viewport: RhinoViewport) -> IntPtr: ...\n    @overload\n    def NativeNonConstPointer(viewport: ViewportInfo) -> IntPtr: ...\n    def NativeRhinoDocPointer(doc: RhinoDoc) -> IntPtr: ...\n    @overload\n    def NSFontFromFont(font: Font) -> IntPtr: ...\n    @overload\n    def NSFontFromFont(font: Font, pointSize: float) -> IntPtr: ...\n    def PlugInPointer(plugin: PlugIn) -> IntPtr: ...\n    def RhinoObjectConstPointer(rhinoObject: RhinoObject) -> IntPtr: ...\n    def RhinoObjectFromPointer(pRhinoObject: IntPtr) -> RhinoObject: ...\n    def ToIRhinoViewport(source: RhinoViewport) -> Object: ...\n    def ToOnBrep(source: Brep) -> Object: ...\n    def ToOnCurve(source: Curve) -> Object: ...\n    def ToOnMesh(source: Mesh) -> Object: ...\n    def ToOnSurface(source: Surface) -> Object: ...\n    def ToOnXform(source: Transform) -> Object: ...\n    def TryCopyFromOnArc(source: Object) -> Tuple[bool, Arc]: ...\n    def TryCopyToOnArc(source: Arc, destination: Object) -> bool: ...\n    def ViewCaptureFromPointer(ptrViewCapture: IntPtr) -> ViewCaptureSettings: ...\n\n\nclass IPlatformServiceLocator:\n    def GetService(self) -> T: ...\n\n\nclass IZooClientUtilities:\n    def AskUserForLicense(self, verify: Object, parameters: ZooClientParameters) -> bool: ...\n    def CheckInLicense(self, verify: Object, productId: Guid) -> bool: ...\n    def CheckOutLicense(self, verify: Object, productId: Guid) -> bool: ...\n    def ConvertLicense(self, verify: Object, productId: Guid) -> bool: ...\n    def DeleteLicense(self, verify: Object, productId: Guid) -> bool: ...\n    def Echo(self, verify: Object, message: str) -> str: ...\n    @property\n    def LoggedInUserAvatar(self) -> Image: ...\n    @property\n    def LoggedInUserName(self) -> str: ...\n    @property\n    def UserIsLoggedIn(self) -> bool: ...\n    def GetCurrentTime(self) -> DateTime: ...\n    def GetLicense(self, verify: Object, parameters: ZooClientParameters) -> bool: ...\n    def GetLicenseStatus(self, verify: Object) -> Set(LicenseStatus): ...\n    def GetLicenseType(self, verify: Object, productId: Guid) -> int: ...\n    def GetOneLicenseStatus(self, verify: Object, productId: Guid) -> LicenseStatus: ...\n    def GetRegisteredOwnerInfo(self, verify: Object, productId: Guid, registeredOwner: str, registeredOrganization: str) -> Tuple[bool, str, str]: ...\n    def Initialize(self, verify: Object) -> bool: ...\n    def IsCheckOutEnabled(self, verify: Object) -> bool: ...\n    def LicenseOptionsHandler(self, verify: Object, parameters: ZooClientParameters) -> bool: ...\n    def LoginToCloudZoo(self) -> bool: ...\n    def LogoutOfCloudZoo(self) -> bool: ...\n    @overload\n    def ReturnLicense(self, verify: Object, productId: Guid) -> bool: ...\n    @overload\n    def ReturnLicense(self, verify: Object, productPath: str, productId: Guid) -> bool: ...\n    def ShowBuyLicenseUi(self, verify: Object, productId: Guid) -> None: ...\n    def ShowLicenseValidationUi(self, verify: Object, cdkey: str) -> bool: ...\n    def ShowRhinoExpiredMessage(self, mode: Mode, result: int) -> Tuple[bool, int]: ...\n\n\nclass LicenseTypes:\n    Undefined = 0\n    Standalone = 1\n    ZooAutoDetect = 2\n    ZooManualDetect = 3\n    CloudZoo = 4\n\n\nclass LogMessageType:\n    unknown = 0\n    information = 1\n    warning = 2\n    error = 3\n    assert = 4\n\n\nclass Mode:\n    NormalMode = 0\n    ViewerMode = 1\n    BetaMode = 2\n    InvalidMode = 100\n\n\nclass NamedParametersEventArgs:\n    def SetBool(self, name: str, value: bool) -> None: ...\n    def SetDouble(self, name: str, value: float) -> None: ...\n    def SetHatchObjects(self, name: str, value: Iterable[HatchObject]) -> None: ...\n    def SetInt(self, name: str, value: int) -> None: ...\n    def SetPoint(self, name: str, value: Point3d) -> None: ...\n    def SetString(self, name: str, value: str) -> None: ...\n    def SetUnsignedInt(self, name: str, value: UInt32) -> None: ...\n    def TryGetBool(self, name: str) -> Tuple[bool, bool]: ...\n    def TryGetDouble(self, name: str) -> Tuple[bool, float]: ...\n    def TryGetHatchObjects(self, name: str) -> Tuple[bool, List]: ...\n    def TryGetInt(self, name: str) -> Tuple[bool, int]: ...\n    def TryGetPoint(self, name: str) -> Tuple[bool, Point3d]: ...\n    def TryGetString(self, name: str) -> Tuple[bool, str]: ...\n    def TryGetUnsignedInt(self, name: str) -> Tuple[bool, UInt32]: ...\n\n\nclass PathPoint:\n    @property\n    def Location(self) -> PointF: ...\n    @property\n    def PointType(self) -> PointType: ...\n    @Location.setter\n    def Location(self, value: PointF) -> None: ...\n    @PointType.setter\n    def PointType(self, value: PointType) -> None: ...\n\n\nclass Pen:\n    def __init__(self): ...\n    @property\n    def Color(self) -> Color: ...\n    @property\n    def Width(self) -> Single: ...\n\n\nclass PointType:\n    Move = 0\n    Line = 1\n    CubicBezier = 2\n    Close = 3\n\n\nclass PythonCompiledCode:\n    def Execute(self, scope: PythonScript) -> None: ...\n\n\nclass PythonScript:\n    def Compile(self, script: str) -> PythonCompiledCode: ...\n    def ContainsVariable(self, name: str) -> bool: ...\n    def Create() -> PythonScript: ...\n    def CreateTextEditorControl(self, script: str, helpcallback: Action) -> Object: ...\n    def EvaluateExpression(self, statements: str, expression: str) -> Object: ...\n    def ExecuteFile(self, path: str) -> bool: ...\n    def ExecuteFileInScope(self, path: str) -> bool: ...\n    def ExecuteScript(self, script: str) -> bool: ...\n    @property\n    def ContextId(self) -> int: ...\n    @property\n    def Output(self) -> Action: ...\n    @property\n    def ScriptContextCommand(self) -> Command: ...\n    @property\n    def ScriptContextDoc(self) -> Object: ...\n    def GetStackTraceFromException(self, ex: Exception) -> str: ...\n    def GetVariable(self, name: str) -> Object: ...\n    def GetVariableNames(self) -> Iterable[str]: ...\n    def RemoveVariable(self, name: str) -> None: ...\n    @ContextId.setter\n    def ContextId(self, value: int) -> None: ...\n    @Output.setter\n    def Output(self, value: Action) -> None: ...\n    @ScriptContextCommand.setter\n    def ScriptContextCommand(self, value: Command) -> None: ...\n    @ScriptContextDoc.setter\n    def ScriptContextDoc(self, value: Object) -> None: ...\n    def SetIntellisenseVariable(self, name: str, value: Object) -> None: ...\n    def SetupScriptContext(self, doc: Object) -> None: ...\n    def SetVariable(self, name: str, value: Object) -> None: ...\n\n\nclass RdkNotLoadedException:\n    def __init__(self): ...\n\n\nclass RiskyAction:\n    def __init__(self, description: str, file: str, member: str, line: int): ...\n    def Dispose(self) -> None: ...\n\n\nclass SendLogMessageToCloudDelegate:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, msg_type: LogMessageType, sClass: str, sDesc: str, sMessage: str, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, msg_type: LogMessageType, sClass: str, sDesc: str, sMessage: str) -> None: ...\n\n\nclass SetClipRectProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, left: int, top: int, right: int, bottom: int, callback: AsyncCallback, object: Object) -> Tuple[IAsyncResult, int, int, int, int]: ...\n    def EndInvoke(self, left: int, top: int, right: int, bottom: int, result: IAsyncResult) -> Tuple[int, int, int, int]: ...\n    def Invoke(self, left: int, top: int, right: int, bottom: int) -> Tuple[int, int, int, int]: ...\n\n\nclass Skin:\n    @property\n    def ActiveSkin() -> Skin: ...\n    @property\n    def Settings(self) -> PersistentSettings: ...\n\n\nclass TextFields:\n    def Area(id: str) -> float: ...\n    def BlockInstanceCount(instanceDefinitionName: str) -> int: ...\n    def CurveLength(id: str) -> float: ...\n    @overload\n    def Date() -> str: ...\n    @overload\n    def Date(dateFormat: str) -> str: ...\n    @overload\n    def DateModified() -> str: ...\n    @overload\n    def DateModified(dateFormat: str) -> str: ...\n    def DetailScaleValue() -> str: ...\n    def DocumentText(key: str) -> str: ...\n    @overload\n    def FileName() -> str: ...\n    @overload\n    def FileName(options: str) -> str: ...\n    def GetInstanceAttributeFields(idef: InstanceDefinition) -> Set(InstanceAttributeField): ...\n    def ModelUnits() -> str: ...\n    def Notes() -> str: ...\n    def NumPages() -> int: ...\n    def ObjectName(id: str) -> str: ...\n    def PageHeight() -> float: ...\n    def PageName() -> str: ...\n    def PageNumber() -> int: ...\n    def PageWidth() -> float: ...\n    def PaperName() -> str: ...\n    @overload\n    def UserText(id: str, key: str) -> str: ...\n    @overload\n    def UserText(id: str, key: str, prompt: str) -> str: ...\n    @overload\n    def UserText(id: str, key: str, prompt: str, defaultValue: str) -> str: ...\n    def Volume(id: str) -> float: ...\n\n\nclass VectorArcProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, argb: int, thickness: Single, dashed: int, arc: Arc, callback: AsyncCallback, object: Object) -> Tuple[IAsyncResult, Arc]: ...\n    def EndInvoke(self, arc: Arc, result: IAsyncResult) -> Tuple[Arc]: ...\n    def Invoke(self, argb: int, thickness: Single, dashed: int, arc: Arc) -> Tuple[Arc]: ...\n\n\nclass VectorBitmapProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, hBmp: IntPtr, m11: float, m12: float, m21: float, m22: float, dx: float, dy: float, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, hBmp: IntPtr, m11: float, m12: float, m21: float, m22: float, dx: float, dy: float) -> None: ...\n\n\nclass VectorClipPathProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, count: int, points: IntPtr, asBeziers: int, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, count: int, points: IntPtr, asBeziers: int) -> None: ...\n\n\nclass VectorFillPolygonProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, argb: int, count: int, points: IntPtr, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, argb: int, count: int, points: IntPtr) -> None: ...\n\n\nclass VectorGradientProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, pEngine: IntPtr, pHatch: IntPtr, strokeWidth: Single, pHatchPattern: IntPtr, gradientCount: int, colors: IntPtr, stops: IntPtr, points: IntPtr, linearGradient: int, boundaryColor: int, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, pEngine: IntPtr, pHatch: IntPtr, strokeWidth: Single, pHatchPattern: IntPtr, gradientCount: int, colors: IntPtr, stops: IntPtr, points: IntPtr, linearGradient: int, boundaryColor: int) -> None: ...\n\n\nclass VectorPathProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, begin: int, argb: int, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, begin: int, argb: int) -> None: ...\n\n\nclass VectorPointProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, style: int, screenX: Single, screenY: Single, fillArgb: int, strokeArgb: int, diameterPixels: Single, innerDiameterPixels: Single, strokeWidthPixels: Single, rotationRadians: Single, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, style: int, screenX: Single, screenY: Single, fillArgb: int, strokeArgb: int, diameterPixels: Single, innerDiameterPixels: Single, strokeWidthPixels: Single, rotationRadians: Single) -> None: ...\n\n\nclass VectorPolylineProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, argb: int, thickness: Single, dashed: int, count: int, points: IntPtr, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, argb: int, thickness: Single, dashed: int, count: int, points: IntPtr) -> None: ...\n\n\nclass VectorRoundedRectProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, centerX: Single, centerY: Single, pixelWidth: Single, pixelHeight: Single, cornerRadius: Single, strokeColor: int, strokeWidth: Single, fillColor: int, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, centerX: Single, centerY: Single, pixelWidth: Single, pixelHeight: Single, cornerRadius: Single, strokeColor: int, strokeWidth: Single, fillColor: int) -> None: ...\n\n\nclass VectorStringProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, constPtrString: IntPtr, argbTextColor: int, x: float, y: float, angle: Single, alignment: int, heightPixels: Single, constPtrFont: IntPtr, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, constPtrString: IntPtr, argbTextColor: int, x: float, y: float, angle: Single, alignment: int, heightPixels: Single, constPtrFont: IntPtr) -> None: ...\n\n\nclass ViewCaptureWriter:\n    def __init__(self, dpi: float, pageSize: Size): ...\n    def Draw(self, constPtrPrintInfo: IntPtr, doc: RhinoDoc) -> None: ...\n\n\nclass ZooClientParameters:\n    def __init__(self, productGuid: Guid, licenseGuid: Guid, productTitle: str, productBuildType: int, capabilities: LicenseCapabilities, licenseEntryTextMask: str, productPath: str, parentWindow: Object, selectedLicenseType: LicenseTypes, validateProductKey: ValidateProductKeyDelegate, onLeaseChangedDelegate: OnLeaseChangedDelegate, verifyLicenseKeyDelegate: VerifyLicenseKeyDelegate, verifyPreviousVersionLicenseKeyDelegate: VerifyPreviousVersionLicenseDelegate): ...\n    @property\n    def Capabilities(self) -> LicenseCapabilities: ...\n    @property\n    def LicenseEntryTextMask(self) -> str: ...\n    @property\n    def LicenseGuid(self) -> Guid: ...\n    @property\n    def OnLeaseChanged(self) -> OnLeaseChangedDelegate: ...\n    @property\n    def ParentWindow(self) -> Object: ...\n    @property\n    def ProductBuildType(self) -> int: ...\n    @property\n    def ProductGuid(self) -> Guid: ...\n    @property\n    def ProductPath(self) -> str: ...\n    @property\n    def ProductTitle(self) -> str: ...\n    @property\n    def SelectedLicenseType(self) -> LicenseTypes: ...\n    @Capabilities.setter\n    def Capabilities(self, value: LicenseCapabilities) -> None: ...\n    @SelectedLicenseType.setter\n    def SelectedLicenseType(self, value: LicenseTypes) -> None: ...\n    def VerifyLicenseKey(self, licenseKey: str, validationCode: str, validationCodeInstallDate: DateTime, gracePeriodExpired: bool) -> Tuple[ValidateResult, LicenseData]: ...\n    def VerifyPreviousVersionLicense(self, license: str, previousVersionLicense: str) -> Tuple[bool, str]: ...\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "classes", "point", "brep", "line", "curve", "functions", "block", "mesh", "RhinoCommon"], "original_file": "mahaidong_p4r-vscode_04f5b54ec8.json", "repo": "mahaidong/p4r-vscode"}
{"instruction": "Adds a new directional light object to the document", "code": "import scriptcontext\nimport utility as rhutil\nimport Rhino.Geometry\nimport math\n\n\ndef __coercelight(id, raise_if_missing=False):\n    light = rhutil.coercegeometry(id)\n    if isinstance(light, Rhino.Geometry.Light): return light\n    if raise_if_missing: raise ValueError(\"unable to retrieve light from %s\"%id)\n\n\ndef AddDirectionalLight(start_point, end_point):\n    \"\"\"Adds a new directional light object to the document\n    Parameters:\n      start_point(point): starting point of the light\n      end_point (point): ending point and direction of the light\n    Returns:\n      (guid): identifier of the new object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      end = rs.GetPoint(\"End of light vector direction\")\n      if end:\n          start = rs.GetPoint(\"Start of light vector direction\", end)\n          if start: rs.AddDirectionalLight( start, end )\n    See Also:\n      IsDirectionalLight\n    \"\"\"\n    start = rhutil.coerce3dpoint(start_point, True)\n    end = rhutil.coerce3dpoint(end_point, True)\n    light = Rhino.Geometry.Light()\n    light.LightStyle = Rhino.Geometry.LightStyle.WorldDirectional\n    light.Location = start\n    light.Direction = end-start\n    index = scriptcontext.doc.Lights.Add(light)\n    if index<0: raise Exception(\"unable to add light to LightTable\")\n    rc = scriptcontext.doc.Lights[index].Id\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddLinearLight(start_point, end_point, width=None):\n    \"\"\"Adds a new linear light object to the document\n    Parameters:\n      start_point (point): starting point of the light\n      end_point (point): ending point and direction of the light\n      width (number): width of the light\n    Returns:\n      guid: identifier of the new object if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      start = rs.GetPoint(\"Light origin\")\n      if start:\n          end = rs.GetPoint(\"Light length and direction\", start)\n          if end: rs.AddLinearLight(start, end)\n    See Also:\n      IsLinearLight\n    \"\"\"\n    start = rhutil.coerce3dpoint(start_point, True)\n    end = rhutil.coerce3dpoint(end_point, True)\n    if width is None:\n        radius=0.5\n        units = scriptcontext.doc.ModelUnitSystem\n        if units!=Rhino.UnitSystem.None:\n            scale = Rhino.RhinoMath.UnitScale(Rhino.UnitSystem.Inches, units)\n            radius *= scale\n        width = radius\n    light = Rhino.Geometry.Light()\n    light.LightStyle = Rhino.Geometry.LightStyle.WorldLinear\n    light.Location = start\n    v = end-start\n    light.Direction = v\n    light.Length = light.Direction\n    light.Width = -light.Width\n    plane = Rhino.Geometry.Plane(light.Location, light.Direction)\n    xaxis = plane.XAxis\n    xaxis.Unitize()\n    plane.XAxis = xaxis\n    light.Width = xaxis * min(width, v.Length/20)\n    #light.Location = start - light.Direction\n    index = scriptcontext.doc.Lights.Add(light)\n    if index<0: raise Exception(\"unable to add light to LightTable\")\n    rc = scriptcontext.doc.Lights[index].Id\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddPointLight(point):\n    \"\"\"Adds a new point light object to the document\n    Parameters:\n      point (point): the 3d location of the point\n    Returns:\n      guid: identifier of the new object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      point = rs.GetPoint(\"Point light location\")\n      if point: rs.AddPointLight(point)\n    See Also:\n      IsPointLight\n    \"\"\"\n    point = rhutil.coerce3dpoint(point, True)\n    light = Rhino.Geometry.Light()\n    light.LightStyle = Rhino.Geometry.LightStyle.WorldPoint\n    light.Location = point\n    index = scriptcontext.doc.Lights.Add(light)\n    if index<0: raise Exception(\"unable to add light to LightTable\")\n    rc = scriptcontext.doc.Lights[index].Id\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddRectangularLight(origin, width_point, height_point):\n    \"\"\"Adds a new rectangular light object to the document\n    Parameters:\n      origin (point): 3d origin point of the light\n      width_point (point): 3d width and direction point of the light\n      height_point (point): 3d height and direction point of the light\n    Returns:\n      guid: identifier of the new object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      rect = rs.GetRectangle(2)\n      if rect: rs.AddRectangularLight( rect[0], rect[1], rect[3] )\n    See Also:\n      IsRectangularLight\n    \"\"\"\n    origin = rhutil.coerce3dpoint(origin, True)\n    ptx = rhutil.coerce3dpoint(width_point, True)\n    pty = rhutil.coerce3dpoint(height_point, True)\n    length = pty-origin\n    width = ptx-origin\n    normal = Rhino.Geometry.Vector3d.CrossProduct(width, length)\n    normal.Unitize()\n    light = Rhino.Geometry.Light()\n    light.LightStyle = Rhino.Geometry.LightStyle.WorldRectangular\n    light.Location = origin\n    light.Width = width\n    light.Length = length\n    light.Direction = normal\n    index = scriptcontext.doc.Lights.Add(light)\n    if index<0: raise Exception(\"unable to add light to LightTable\")\n    rc = scriptcontext.doc.Lights[index].Id\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSpotLight(origin, radius, apex_point):\n    \"\"\"Adds a new spot light object to the document\n    Parameters:\n      origin (point): 3d origin point of the light\n      radius (number):  radius of the cone\n      apex_point (point): 3d apex point of the light\n    Returns:\n      guid: identifier of the new object\n    Example:\n      import rhinoscriptsyntax as rs\n      radius = 5.0\n      origin = rs.GetPoint(\"Base of cone\")\n      if origin:\n          apex = rs.GetPoint(\"End of cone\", origin)\n          if apex: rs.AddSpotLight(origin, radius, apex)\n    See Also:\n      IsSpotLight\n      SpotLightHardness\n      SpotLightShadowIntensity\n    \"\"\"\n    origin = rhutil.coerce3dpoint(origin, True)\n    apex_point = rhutil.coerce3dpoint(apex_point, True)\n    if radius<0: radius=1.0\n    light = Rhino.Geometry.Light()\n    light.LightStyle = Rhino.Geometry.LightStyle.WorldSpot\n    light.Location = apex_point\n    light.Direction = origin-apex_point\n    light.SpotAngleRadians = math.atan(radius / (light.Direction.Length))\n    light.HotSpot = 0.50\n    index = scriptcontext.doc.Lights.Add(light)\n    if index<0: raise Exception(\"unable to add light to LightTable\")\n    rc = scriptcontext.doc.Lights[index].Id\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef EnableLight(object_id, enable=None):\n    \"\"\"Enables or disables a light object\n    Parameters:\n      object_id (guid): the light object's identifier\n      enable (bool, optional): the light's enabled status\n    Returns:\n      bool: if enable is not specified, the current enabled status\n      bool: if enable is specified, the previous enabled status\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select light\", rs.filter.light)\n      if id: rs.EnableLight( id, False )\n    See Also:\n      IsLight\n      IsLightEnabled\n      LightColor\n      LightCount\n      LightName\n      LightObjects\n    \"\"\"\n    light = __coercelight(object_id, True)\n    rc = light.IsEnabled\n    if enable is not None and enable!=rc:\n        light.IsEnabled = enable\n        id = rhutil.coerceguid(object_id)\n        if not scriptcontext.doc.Lights.Modify(id, light):\n            return scriptcontext.errorhandler()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\ndef IsDirectionalLight(object_id):\n    \"\"\"Verifies a light object is a directional light\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsDirectionalLight(id):\n          print \"The object is a directional light.\"\n      else:\n          print \"The object is not a directional light.\"\n    See Also:\n      AddDirectionalLight\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsDirectionalLight\n\n\ndef IsLight(object_id):\n    \"\"\"Verifies an object is a light object\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\")\n      if rs.IsLight(id):\n          print \"The object is a light.\"\n      else:\n          print \"The object is not a light.\"\n    See Also:\n      EnableLight\n      IsLightEnabled\n      LightColor\n      LightCount\n      LightName\n      LightObjects\n    \"\"\"\n    light = __coercelight(object_id, False)\n    return light is not None\n\n\ndef IsLightEnabled(object_id):\n    \"\"\"Verifies a light object is enabled\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsLightEnabled(id):\n          print \"The light is enabled (on).\"\n      else:\n          print \"The light is disabled (off).\"\n    See Also:\n      EnableLight\n      IsLight\n      LightColor\n      LightCount\n      LightName\n      LightObjects\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsEnabled\n\n\ndef IsLightReference(object_id):\n    \"\"\"Verifies a light object is referenced from another file\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsLightReference(id):\n          print \"The light is a reference object.\"\n      else:\n          print \"The light is not a reference object.\"\n    See Also:\n      IsObjectReference\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsReference\n\n\ndef IsLinearLight(object_id):\n    \"\"\"Verifies a light object is a linear light\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsLinearLight(id):\n          print \"The object is a linear light.\"\n      else:\n          print \"The object is not a linear light.\"\n    See Also:\n      AddLinearLight\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsLinearLight\n\n\ndef IsPointLight(object_id):\n    \"\"\"Verifies a light object is a point light\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsPointLight(id):\n          print \"The object is a point light.\"\n      else:\n          print \"The object is not a point light.\"\n    See Also:\n      AddPointLight\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsPointLight\n\n\ndef IsRectangularLight(object_id):\n    \"\"\"Verifies a light object is a rectangular light\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsRectangularLight(id):\n          print \"The object is a rectangular light.\"\n      else:\n          print \"The object is not a rectangular light.\"\n    See Also:\n      AddRectangularLight\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsRectangularLight\n\n\ndef IsSpotLight(object_id):\n    \"\"\"Verifies a light object is a spot light\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if rs.IsSpotLight(id):\n          print \"The object is a spot light.\"\n      else:\n          print \"The object is not a spot light.\"\n    See Also:\n      AddSpotLight\n      SpotLightHardness\n      SpotLightShadowIntensity\n    \"\"\"\n    light = __coercelight(object_id, True)\n    return light.IsSpotLight\n\n\ndef LightColor(object_id, color=None):\n    \"\"\"Returns or changes the color of a light\n    Parameters:\n      object_id (guid): the light object's identifier\n      color (color, optional): the light's new color\n    Returns:\n      color: if color is not specified, the current color\n      color: if color is specified, the previous color\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id: rs.LightColor( id, (0,255,255) )\n    See Also:\n      EnableLight\n      IsLight\n      IsLightEnabled\n      LightCount\n      LightName\n      LightObjects\n    \"\"\"\n    light = __coercelight(object_id, True)\n    rc = light.Diffuse\n    if color:\n        color = rhutil.coercecolor(color, True)\n        if color!=rc:\n            light.Diffuse = color\n            id = rhutil.coerceguid(object_id, True)\n            if not scriptcontext.doc.Lights.Modify(id, light):\n                return scriptcontext.errorhandler()\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef LightCount():\n    \"\"\"Returns the number of light objects in the document\n    Returns:\n      number: the number of light objects in the document\n    Example:\n      import rhinoscriptsyntax as rs\n      print \"There are\", rs.LightCount(), \" lights.\"\n    See Also:\n      EnableLight\n      IsLight\n      IsLightEnabled\n      LightColor\n      LightName\n      LightObjects\n    \"\"\"\n    return scriptcontext.doc.Lights.Count\n\n\ndef LightDirection(object_id, direction=None):\n    \"\"\"Returns or changes the direction of a light object\n    Parameters:\n      object_id (guid): the light object's identifier\n      direction (vector, optional): the light's new direction\n    Returns:\n      vector: if direction is not specified, the current direction\n      vector: if direction is specified, the previous direction\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id: print( rs.LightDirection(id) )\n    See Also:\n      IsLight\n      LightLocation\n    \"\"\"\n    light = __coercelight(object_id, True)\n    rc = light.Direction\n    if direction:\n        direction = rhutil.coerce3dvector(direction, True)\n        if direction!=rc:\n            light.Direction = direction\n            id = rhutil.coerceguid(object_id, True)\n            if not scriptcontext.doc.Lights.Modify(id, light):\n                return scriptcontext.errorhandler()\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef LightLocation(object_id, location=None):\n    \"\"\"Returns or changes the location of a light object\n    Parameters:\n      object_id (guid): the light object's identifier\n      location (point, optional): the light's new location\n    Returns:\n      point: if location is not specified, the current location\n      point: if location is specified, the previous location\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id: rs.AddPoint( rs.LightLocation(id) )\n    See Also:\n      IsLight\n      LightDirection\n    \"\"\"\n    light = __coercelight(object_id, True)\n    rc = light.Location\n    if location:\n        location = rhutil.coerce3dpoint(location, True)\n        if location!=rc:\n            light.Location = location\n            id = rhutil.coerceguid(object_id, True)\n            if not scriptcontext.doc.Lights.Modify(id, light):\n                return scriptcontext.errorhandler()\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef LightName(object_id, name=None):\n    \"\"\"Returns or changes the name of a light object\n    Parameters:\n      object_id (guid): the light object's identifier\n      name (str, optional): the light's new name\n    Returns:\n      str: if name is not specified, the current name\n      str: if name is specified, the previous name\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id:\n          name = rs.GetString(\"New light name\")\n          if name: rs.LightName(id, name)\n    See Also:\n      EnableLight\n      IsLight\n      IsLightEnabled\n      LightColor\n      LightCount\n      LightObjects\n    \"\"\"\n    light = __coercelight(object_id, True)\n    rc = light.Name\n    if name and name!=rc:\n        light.Name = name\n        id = rhutil.coerceguid(object_id, True)\n        if not scriptcontext.doc.Lights.Modify(id, light):\n            return scriptcontext.errorhandler()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef LightObjects():\n    \"\"\"Returns list of identifiers of light objects in the document\n    Returns:\n      list(guid, ...): the list of identifiers of light objects in the document\n    Example:\n      import rhinoscriptsyntax as rs\n      lights = rs.LightObjects()\n      if lights:\n          rs.AddLayer( \"Lights\" )\n          for light in lights: rs.ObjectLayer( light, \"Lights\" )\n    See Also:\n      EnableLight\n      IsLight\n      IsLightEnabled\n      LightColor\n      LightCount\n      LightName\n    \"\"\"\n    count = scriptcontext.doc.Lights.Count\n    rc = []\n    for i in range(count):\n        rhlight = scriptcontext.doc.Lights[i]\n        if not rhlight.IsDeleted: rc.append(rhlight.Id)\n    return rc\n\n\ndef RectangularLightPlane(object_id):\n    \"\"\"Returns the plane of a rectangular light object\n    Parameters:\n      object_id (guid): the light object's identifier\n    Returns:\n      plane: the plane if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a rectangular light\", rs.filter.light)\n      if id:\n          rc = rs.RectangularLightPlane(id)\n          if rc:\n              plane, extents = rc\n              rs.AddPlaneSurface( plane, extents[0], extents[1] )\n    See Also:\n      IsRectangularLight\n    \"\"\"\n    light = __coercelight(object_id, True)\n    if light.LightStyle!=Rhino.Geometry.LightStyle.WorldRectangular:\n        return scriptcontext.errorhandler()\n    location = light.Location\n    length = light.Length\n    width = light.Width\n    direction = light.Direction\n    plane = Rhino.Geometry.Plane(location, length, width)\n    return plane, (length.Length, width.Length)\n\n\ndef SpotLightHardness(object_id, hardness=None):\n    \"\"\"Returns or changes the hardness of a spot light. Spotlight hardness\n    controls the fully illuminated region.\n    Parameters:\n      object_id (guid): the light object's identifier\n      hardness (number, optional): the light's new hardness\n    Returns:\n      number: if hardness is not specified, the current hardness\n      number: if hardness is specified, the previous hardness\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id: rs.SpotLightHardness(id, 0.75)\n    See Also:\n      AddSpotLight\n      IsSpotLight\n      SpotLightRadius\n      SpotLightShadowIntensity\n    \"\"\"\n    light = __coercelight(object_id, True)\n    if light.LightStyle!=Rhino.Geometry.LightStyle.WorldSpot:\n        return scriptcontext.errorhandler()\n    rc = light.HotSpot\n    if hardness and hardness!=rc:\n        light.HotSpot = hardness\n        id = rhutil.coerceguid(object_id, True)\n        if not scriptcontext.doc.Lights.Modify(id, light):\n            return scriptcontext.errorhandler()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef SpotLightRadius(object_id, radius=None):\n    \"\"\"Returns or changes the radius of a spot light.\n    Parameters:\n      object_id (guid): the light object's identifier\n      radius (number, optional): the light's new radius\n    Returns:\n      number: if radius is not specified, the current radius\n      number: if radius is specified, the previous radius\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id: rs.SpotLightRadius(id, 5.0)\n    See Also:\n      AddSpotLight\n      IsSpotLight\n      SpotLightHardness\n      SpotLightShadowIntensity\n    \"\"\"\n    light = __coercelight(object_id, True)\n    if light.LightStyle!=Rhino.Geometry.LightStyle.WorldSpot:\n        return scriptcontext.errorhandler()\n    radians = light.SpotAngleRadians\n    rc = light.Direction.Length * math.tan(radians)\n    if radius and radius!=rc:\n        radians = math.atan(radius/light.Direction.Length)\n        light.SpotAngleRadians = radians\n        id = rhutil.coerceguid(object_id, True)\n        if not scriptcontext.doc.Lights.Modify(id, light):\n            return scriptcontext.errorhandler()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef SpotLightShadowIntensity(object_id, intensity=None):\n    \"\"\"Returns or changes the shadow intensity of a spot light.\n    Parameters:\n      object_id (guid): the light object's identifier\n      intensity (number, optional): the light's new intensity\n    Returns:\n      number: if intensity is not specified, the current intensity\n      number: if intensity is specified, the previous intensity\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a light\", rs.filter.light)\n      if id: rs.SpotLightShadowIntensity(id, 0.75)\n    See Also:\n      AddSpotLight\n      IsSpotLight\n      SpotLightHardness\n      SpotLightRadius\n    \"\"\"\n    light = __coercelight(object_id, True)\n    if light.LightStyle!=Rhino.Geometry.LightStyle.WorldSpot:\n        return scriptcontext.errorhandler()\n    rc = light.SpotLightShadowIntensity\n    if intensity and intensity!=rc:\n        light.SpotLightShadowIntensity = intensity\n        id = rhutil.coerceguid(object_id, True)\n        if not scriptcontext.doc.Lights.Modify(id, light):\n            return scriptcontext.errorhandler()\n        scriptcontext.doc.Views.Redraw()\n    return rc", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "layer", "line", "functions", "RhinoCommon"], "original_file": "mahaidong_p4r-vscode_50914e62a7.json", "repo": "mahaidong/p4r-vscode"}
{"instruction": "Creates a new hatch object from a closed planar curve object", "code": "import scriptcontext\nimport utility as rhutil\nimport Rhino\nimport System.Guid\n\ndef AddHatch(curve_id, hatch_pattern=None, scale=1.0, rotation=0.0):\n    \"\"\"Creates a new hatch object from a closed planar curve object\n    Parameters:\n      curve_id (guid): identifier of the closed planar curve that defines the\n          boundary of the hatch object\n      hatch_pattern (str, optional): name of the hatch pattern to be used by the hatch\n          object. If omitted, the current hatch pattern will be used\n      scale (number, optional): hatch pattern scale factor\n      rotation (number, optional): hatch pattern rotation angle in degrees.\n    Returns:\n      guid:identifier of the newly created hatch on success\n      None on error\n    Example:\n      import rhinoscriptsyntax as rs\n      circle = rs.AddCircle(rs.WorldXYPlane(), 10.0)\n      if rs.IsHatchPattern(\"Grid\"):\n          rs.AddHatch( circle, \"Grid\" )\n      else:\n          rs.AddHatch( circle, rs.CurrentHatchPattern() )\n    See Also:\n      AddHatches\n      CurrentHatchPattern\n      HatchPatternNames\n    \"\"\"\n    rc = AddHatches(curve_id, hatch_pattern, scale, rotation)\n    if rc: return rc[0]\n    return scriptcontext.errorhandler()\n\n\ndef AddHatches(curve_ids, hatch_pattern=None, scale=1.0, rotation=0.0, tolerance=None):\n    \"\"\"Creates one or more new hatch objects a list of closed planar curves\n    Parameters:\n      curve_ids ([guid, ...]): identifiers of the closed planar curves that defines the\n          boundary of the hatch objects\n      hatch_pattern (str, optional):  name of the hatch pattern to be used by the hatch\n          object. If omitted, the current hatch pattern will be used\n      scale (number, optional): hatch pattern scale factor\n      rotation (number, optional): hatch pattern rotation angle in degrees.\n      tolerance (number, optional): tolerance for hatch fills.\n    Returns:\n      list(guid, ...): identifiers of the newly created hatch on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curves = rs.GetObjects(\"Select closed planar curves\", rs.filter.curve)\n      if curves:\n          if rs.IsHatchPattern(\"Grid\"):\n              rs.AddHatches( curves, \"Grid\" )\n          else:\n              rs.AddHatches( curves, rs.CurrentHatchPattern() )\n    See Also:\n      AddHatch\n      CurrentHatchPattern\n      HatchPatternNames\n    \"\"\"\n    id = rhutil.coerceguid(curve_ids, False)\n    if id: curve_ids = [id]\n    index = scriptcontext.doc.HatchPatterns.CurrentHatchPatternIndex\n    if hatch_pattern and hatch_pattern!=index:\n        if isinstance(hatch_pattern, int):\n            index = hatch_pattern\n        else:\n            pattern_instance = scriptcontext.doc.HatchPatterns.FindName(hatch_pattern)\n            index = Rhino.RhinoMath.UnsetIntIndex if pattern_instance is None else pattern_instance.Index\n        if index<0: return scriptcontext.errorhandler()\n    curves = [rhutil.coercecurve(id, -1, True) for id in curve_ids]\n    rotation = Rhino.RhinoMath.ToRadians(rotation)\n    if tolerance is None or tolerance < 0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    hatches = Rhino.Geometry.Hatch.Create(curves, index, rotation, scale, tolerance)\n    if not hatches: return scriptcontext.errorhandler()\n    ids = []\n    for hatch in hatches:\n        id = scriptcontext.doc.Objects.AddHatch(hatch)\n        if id==System.Guid.Empty: continue\n        ids.append(id)\n    if not ids: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef AddHatchPatterns(filename, replace=False):\n    \"\"\"Adds hatch patterns to the document by importing hatch pattern definitions\n    from a pattern file.\n    Parameters:\n      filename (str): name of the hatch pattern file\n      replace (bool, optional): If hatch pattern names already in the document match hatch\n          pattern names in the pattern definition file, then the existing hatch\n          patterns will be redefined\n    Returns:\n      list(str, ...): Names of the newly added hatch patterns if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      filename = rs.OpenFileName(\"Import\", \"Pattern Files (*.pat)|*.pat||\")\n      if filename:\n          patterns = rs.AddHatchPatterns(filename)\n          if patterns:\n              for pattern in patterns: print pattern\n    See Also:\n      HatchPatternCount\n      HatchPatternNames\n    \"\"\"\n    patterns = Rhino.DocObjects.HatchPattern.ReadFromFile(filename, True)\n    if not patterns: return scriptcontext.errorhandler()\n    rc = []\n    for pattern in patterns:\n         index = scriptcontext.doc.HatchPatterns.Add(pattern)\n         if index>=0:\n             pattern = scriptcontext.doc.HatchPatterns[index]\n             rc.append(pattern.Name)\n    if not rc: return scriptcontext.errorhandler()\n    return rc\n\n\ndef CurrentHatchPattern(hatch_pattern=None):\n    \"\"\"Returns or sets the current hatch pattern file\n    Parameters:\n      hatch_pattern(str, optional):  name of an existing hatch pattern to make current\n    Returns:\n      str: if hatch_pattern is not specified, the current hatch pattern\n      str: if hatch_pattern is specified, the previous hatch pattern\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      if rs.IsHatchPattern(\"Hatch2\"): rs.CurrentHatchPattern(\"Hatch2\")\n    See Also:\n      HatchPatternCount\n      HatchPatternNames\n    \"\"\"\n    rc = scriptcontext.doc.HatchPatterns.CurrentHatchPatternIndex\n    if hatch_pattern:\n        pattern_instance = scriptcontext.doc.HatchPatterns.FindName(hatch_pattern)\n        if pattern_instance is None: return scriptcontext.errorhandler()\n        scriptcontext.doc.HatchPatterns.CurrentHatchPatternIndex = pattern_instance.Index\n    return rc\n\n\ndef ExplodeHatch(hatch_id, delete=False):\n    \"\"\"Explodes a hatch object into its component objects. The exploded objects\n    will be added to the document. If the hatch object uses a solid pattern,\n    then planar face Brep objects will be created. Otherwise, line curve objects\n    will be created\n    Parameters:\n      hatch_id (guid): identifier of a hatch object\n      delete (bool, optional): delete the hatch object\n    Returns:\n      list(guid, ...): list of identifiers for the newly created objects\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select object\")\n      if rs.IsHatch(id): rs.ExplodeHatch(id, True)\n    See Also:\n      IsHatch\n      HatchPattern\n      HatchRotation\n      HatchScale\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(hatch_id, True, True)\n    pieces = rhobj.HatchGeometry.Explode()\n    if not pieces: return scriptcontext.errorhandler()\n    attr = rhobj.Attributes\n    rc = []\n    for piece in pieces:\n        id = None\n        if isinstance(piece, Rhino.Geometry.Curve):\n            id = scriptcontext.doc.Objects.AddCurve(piece, attr)\n        elif isinstance(piece, Rhino.Geometry.Brep):\n            id = scriptcontext.doc.Objects.AddBrep(piece, attr)\n        if id: rc.append(id)\n    if delete: scriptcontext.doc.Objects.Delete(rhobj)\n    return rc\n\n\ndef HatchPattern(hatch_id, hatch_pattern=None):\n    \"\"\"Returns or changes a hatch object's hatch pattern\n    Parameters:\n      hatch_id (guid): identifier of a hatch object\n      hatch_pattern (str, optional): name of an existing hatch pattern to replace the\n          current hatch pattern\n    Returns:\n      str: if hatch_pattern is not specified, the current hatch pattern\n      str: if hatch_pattern is specified, the previous hatch pattern\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      objects = rs.AllObjects()\n      if objects is not None:\n          for obj in objects:\n              if rs.IsHatch(obj) and rs.HatchPattern(obj)==\"Solid\":\n                  rs.SelectObject(obj)\n    See Also:\n      AddHatch\n      AddHatches\n      HatchRotation\n      HatchScale\n      IsHatch\n    \"\"\"\n    hatchobj = rhutil.coercerhinoobject(hatch_id, True, True)\n    if not isinstance(hatchobj, Rhino.DocObjects.HatchObject):\n        return scriptcontext.errorhandler()\n    old_index = hatchobj.HatchGeometry.PatternIndex\n    if hatch_pattern:\n        new_patt = scriptcontext.doc.HatchPatterns.FindName(hatch_pattern)\n        if new_patt is None: return scriptcontext.errorhandler()\n        hatchobj.HatchGeometry.PatternIndex = new_patt.Index\n        hatchobj.CommitChanges()\n        scriptcontext.doc.Views.Redraw()\n    return scriptcontext.doc.HatchPatterns[old_index].Name\n\n\ndef HatchPatternCount():\n    \"\"\"Returns the number of hatch patterns in the document\n    Returns:\n      number: the number of hatch patterns in the document\n    Example:\n      import rhinoscriptsyntax as rs\n      print \"There are\", rs.HatchPatternCount(), \"hatch patterns.\"\n    See Also:\n      HatchPatternNames\n    \"\"\"\n    return scriptcontext.doc.HatchPatterns.Count\n\n\ndef HatchPatternDescription(hatch_pattern):\n    \"\"\"Returns the description of a hatch pattern. Note, not all hatch patterns\n    have descriptions\n    Parameters:\n      hatch_pattern (str): name of an existing hatch pattern\n    Returns:\n      str: description of the hatch pattern on success otherwise None\n    Example:\n      import rhinoscriptsyntax as rs\n      patterns = rs.HatchPatternNames()\n      for pattern in patterns:\n          description = rs.HatchPatternDescription(pattern)\n          if description: print pattern, \"-\", description\n          else: print pattern\n    See Also:\n      HatchPatternCount\n      HatchPatternNames\n    \"\"\"\n    pattern_instance = scriptcontext.doc.HatchPatterns.FindName(hatch_pattern)\n    if pattern_instance is None: return scriptcontext.errorhandler()\n    return pattern_instance.Description\n\n\ndef HatchPatternFillType(hatch_pattern):\n    \"\"\"Returns the fill type of a hatch pattern.\n    Parameters:\n      hatch_pattern (str): name of an existing hatch pattern\n    Returns:\n      number: hatch pattern's fill type if successful\n              0 = solid, uses object color\n              1 = lines, uses pattern file definition\n              2 = gradient, uses fill color definition\n      None: if unsuccessful\n    Example:\n      import rhinoscriptsyntax as rs\n      patterns = rs.HatchPatternNames()\n      for pattern in patterns:\n          fill = rs.HatchPatternFillType(pattern)\n          print pattern, \"-\", fill\n    See Also:\n      HatchPatternCount\n      HatchPatternNames\n    \"\"\"\n    pattern_instance = scriptcontext.doc.HatchPatterns.FindName(hatch_pattern)\n    if pattern_instance is None: return scriptcontext.errorhandler()\n    return int(pattern_instance.FillType)\n\n\ndef HatchPatternNames():\n    \"\"\"Returns the names of all of the hatch patterns in the document\n    Returns:\n      list(str, ...): the names of all of the hatch patterns in the document\n    Example:\n      import rhinoscriptsyntax as rs\n      patterns = rs.HatchPatternNames()\n      for pattern in patterns:\n          description = rs.HatchPatternDescription(pattern)\n          if description: print pattern, \"-\", description\n          else: print pattern\n    See Also:\n      HatchPatternCount\n    \"\"\"\n    rc = []\n    for i in range(scriptcontext.doc.HatchPatterns.Count):\n        hatchpattern = scriptcontext.doc.HatchPatterns[i]\n        if hatchpattern.IsDeleted: continue\n        rc.append(hatchpattern.Name)\n    return rc\n\ndef HatchRotation(hatch_id, rotation=None):\n    \"\"\"Returns or modifies the rotation applied to the hatch pattern when\n    it is mapped to the hatch's plane\n    Parameters:\n      hatch_id (guid): identifier of a hatch object\n      rotation (number, optional): rotation angle in degrees\n    Returns:\n      number: if rotation is not defined, the current rotation angle\n      number: if rotation is specified, the previous rotation angle\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      objects = rs.AllObjects()\n      if objects:\n          for obj in objects:\n              if rs.IsHatch(obj) and rs.HatchRotation(obj)>0:\n                  rs.HatchRotation(obj,0)\n    See Also:\n      AddHatch\n      AddHatches\n      HatchPattern\n      HatchScale\n      IsHatch\n    \"\"\"\n    hatchobj = rhutil.coercerhinoobject(hatch_id, True, True)\n    if not isinstance(hatchobj, Rhino.DocObjects.HatchObject):\n        return scriptcontext.errorhandler()\n    rc = hatchobj.HatchGeometry.PatternRotation\n    rc = Rhino.RhinoMath.ToDegrees(rc)\n    if rotation is not None and rotation!=rc:\n        rotation = Rhino.RhinoMath.ToRadians(rotation)\n        hatchobj.HatchGeometry.PatternRotation = rotation\n        hatchobj.CommitChanges()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef HatchScale(hatch_id, scale=None):\n    \"\"\"Returns or modifies the scale applied to the hatch pattern when it is\n    mapped to the hatch's plane\n    Parameters:\n      hatch_id (guid): identifier of a hatch object\n      scale (number, optional):  scale factor\n    Returns:\n      number: if scale is not defined, the current scale factor\n      number: if scale is defined, the previous scale factor\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      objects = rs.NormalObjects()\n      if objects:\n          for obj in objects:\n              if rs.IsHatch(obj) and rs.HatchScale(obj)>1.0:\n                  rs.HatchScale(obj, 1.0)\n    See Also:\n      HatchPattern\n      HatchRotation\n      IsHatch\n    \"\"\"\n    hatchobj = rhutil.coercerhinoobject(hatch_id)\n    if not isinstance(hatchobj, Rhino.DocObjects.HatchObject):\n        return scriptcontext.errorhandler()\n    rc = hatchobj.HatchGeometry.PatternScale\n    if scale and scale!=rc:\n        hatchobj.HatchGeometry.PatternScale = scale\n        hatchobj.CommitChanges()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef IsHatch(object_id):\n    \"\"\"Verifies the existence of a hatch object in the document\n    Parameters:\n      object_id (guid): identifier of an object\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select object\")\n      if rs.IsHatch(obj): print \"Object is a hatch\"\n      else: print \"Object is not a hatch\"\n    See Also:\n      HatchPattern\n      HatchRotation\n      HatchScale\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, False)\n    return isinstance(rhobj, Rhino.DocObjects.HatchObject)\n\n\ndef IsHatchPattern(name):\n    \"\"\"Verifies the existence of a hatch pattern in the document\n    Parameters:\n      name (str): the name of a hatch pattern\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      hatch = rs.GetString(\"Hatch pattern name\")\n      if rs.IsHatchPattern(hatch): print \"The hatch pattern exists.\"\n      else: print \"The hatch pattern does not exist.\"\n    See Also:\n      IsHatchPatternCurrent\n      IsHatchPatternReference\n    \"\"\"\n    return scriptcontext.doc.HatchPatterns.FindName(name) is not None\n\n\ndef IsHatchPatternCurrent(hatch_pattern):\n    \"\"\"Verifies that a hatch pattern is the current hatch pattern\n    Parameters:\n      hatch_pattern (str): name of an existing hatch pattern\n    Returns:\n      bool: True or False\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      hatch = rs.GetString(\"Hatch pattern name\")\n      if rs.IsHatchPattern(hatch):\n          if rs.IsHatchPatternCurrent(hatch):\n              print \"The hatch pattern is current.\"\n          else:\n              print \"The hatch pattern is not current.\"\n      else: print \"The hatch pattern does not exist.\"\n    See Also:\n      IsHatchPattern\n      IsHatchPatternReference\n    \"\"\"\n    pattern_instance = scriptcontext.doc.HatchPatterns.FindName(hatch_pattern)\n    if pattern_instance is None: return scriptcontext.errorhandler()\n    return pattern_instance.Index==scriptcontext.doc.HatchPatterns.CurrentHatchPatternIndex\n\n\ndef IsHatchPatternReference(hatch_pattern):\n    \"\"\"Verifies that a hatch pattern is from a reference file\n    Parameters:\n      hatch_pattern (str): name of an existing hatch pattern\n    Returns:\n      bool: True or False\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      hatch = rs.GetString(\"Hatch pattern name\")\n      if rs.IsHatchPattern(hatch):\n          if rs.IsHatchPatternReference(hatch):\n              print \"The hatch pattern is reference.\"\n          else:\n              print \"The hatch pattern is not reference.\"\n      else:\n          print \"The hatch pattern does not exist.\"\n    See Also:\n      IsHatchPattern\n      IsHatchPatternCurrent\n    \"\"\"\n    pattern_instance = scriptcontext.doc.HatchPatterns.FindName(hatch_pattern)\n    if pattern_instance is None: return scriptcontext.errorhandler()\n    return pattern_instance.IsReference", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "brep", "line", "curve", "functions", "RhinoCommon"], "original_file": "mahaidong_p4r-vscode_982b3e1abc.json", "repo": "mahaidong/p4r-vscode"}
{"instruction": "Enables or disables an object's grips. For curves and surfaces, these are", "code": "import utility as rhutil\nimport scriptcontext\nimport Rhino\n\n\ndef EnableObjectGrips(object_id, enable=True):\n    \"\"\"Enables or disables an object's grips. For curves and surfaces, these are\n    also called control points.\n    Parameters:\n      object_id (guid): identifier of the object\n      enable (bool, optional): if True, the specified object's grips will be turned on.\n        Otherwise, they will be turned off\n    Returns:\n      bool: True on success, False on failure\n    Example:\n      import rhinoscriptsyntax as  rs\n      objects = rs.GetObjects(\"Select  objects\")\n      if objects: [rs.EnableObjectGrips(obj)  for obj in objs]\n    See Also:\n      ObjectGripCount\n      ObjectGripsOn\n      ObjectGripsSelected\n      SelectObjectGrips\n      UnselectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if enable!=rhobj.GripsOn:\n        rhobj.GripsOn = enable\n        scriptcontext.doc.Views.Redraw()\n\n\ndef GetObjectGrip(message=None, preselect=False, select=False):\n    \"\"\"Prompts the user to pick a single object grip\n    Parameters:\n      message (str, optional): prompt for picking\n      preselect (bool, optional): allow for selection of pre-selected object grip.\n      select (bool, optional): select the picked object grip.\n    Returns:\n      tuple(guid, number, point): defining a grip record.\n         [0] = identifier of the object that owns the grip\n         [1] = index value of the grip\n         [2] = location of the grip\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if curve:\n          rs.EnableObjectGrips( curve )\n          grip = rs.GetObjectGrip(\"Select a curve grip\")\n          if grip: print grip[2]\n    See Also:\n      GetObjectGrips\n    \"\"\"\n    if not preselect:\n        scriptcontext.doc.Objects.UnselectAll()\n        scriptcontext.doc.Views.Redraw()\n    rc, grip = Rhino.Input.RhinoGet.GetGrip(message)\n    if rc!=Rhino.Commands.Result.Success: return scriptcontext.errorhandler()\n    if select:\n        grip.Select(True, True)\n        scriptcontext.doc.Views.Redraw()\n    return grip.OwnerId, grip.Index, grip.CurrentLocation\n\n\ndef GetObjectGrips(message=None, preselect=False, select=False):\n    \"\"\"Prompts user to pick one or more object grips from one or more objects.\n    Parameters:\n      message (str, optional): prompt for picking\n      preselect (bool, optional): allow for selection of pre-selected object grips\n      select (bool, optional) select the picked object grips\n    Returns:\n      list((guid, number, point), ...): containing one or more grip records. Each grip record is a tuple\n        [n][0] = identifier of the object that owns the grip\n        [n][1] = index value of the grip\n        [n][2] = location of the grip\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curves = rs.GetObjects(\"Select curves\", rs.filter.curves)\n      if curves:\n          for curve in curves: rs.EnableObjectGrips(curve)\n          grips = rs.GetObjectGrips(\"Select curve grips\")\n          if grips: for grip in grips: print grip[0]\n    See Also:\n      GetObjectGrip\n    \"\"\"\n    if not preselect:\n        scriptcontext.doc.Objects.UnselectAll()\n        scriptcontext.doc.Views.Redraw()\n    getrc, grips = Rhino.Input.RhinoGet.GetGrips(message)\n    if getrc!=Rhino.Commands.Result.Success or not grips:\n        return scriptcontext.errorhandler()\n    rc = []\n    for grip in grips:\n        id = grip.OwnerId\n        index = grip.Index\n        location = grip.CurrentLocation\n        rc.append((id, index, location))\n        if select: grip.Select(True, True)\n    if select: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef __neighborgrip(i, object_id, index, direction, enable):\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    grips = rhobj.GetGrips()\n    if not grips or len(grips)<=index: return scriptcontext.errorhandler()\n    grip = grips[index]\n    next_grip=None\n    if direction==0:\n        next_grip = grip.NeighborGrip(i,0,0,False)\n    else:\n        next_grip = grip.NeighborGrip(0,i,0,False)\n    if next_grip and enable:\n        next_grip.Select(True)\n        scriptcontext.doc.Views.Redraw()\n    return next_grip\n\n\ndef NextObjectGrip(object_id, index, direction=0, enable=True):\n    \"\"\"Returns the next grip index from a specified grip index of an object\n    Parameters:\n      object_id (guid): identifier of the object\n      index (number): zero based grip index from which to get the next grip index\n      direction ([number, number], optional): direction to get the next grip index (0=U, 1=V)\n      enable (bool, optional): if True, the next grip index found will be selected\n    Returns:\n      number: index of the next grip on success\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      object_id = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if object_id:\n          rs.EnableObjectGrips( object_id )\n          count = rs.ObjectGripCount( object_id )\n          for i in range(0,count,2):\n              rs.NextObjectGrip(object_id, i, 0, True)\n    See Also:\n      EnableObjectGrips\n      PrevObjectGrip\n    \"\"\"\n    return __neighborgrip(1, object_id, index, direction, enable)\n\n\ndef ObjectGripCount(object_id):\n    \"\"\"Returns number of grips owned by an object\n    Parameters:\n      object_id (guid): identifier of the object\n    Returns:\n      number: number of grips if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select object\")\n      if rs.ObjectGripsOn(obj):\n          print \"Grip count =\", rs.ObjectGripCount(obj)\n    See Also:\n      EnableObjectGrips\n      ObjectGripsOn\n      ObjectGripsSelected\n      SelectObjectGrips\n      UnselectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    grips = rhobj.GetGrips()\n    if not grips: return scriptcontext.errorhandler()\n    return grips.Length\n\n\ndef ObjectGripLocation(object_id, index, point=None):\n    \"\"\"Returns or modifies the location of an object's grip\n    Parameters:\n      object_id (guid) identifier of the object\n      index (number): index of the grip to either query or modify\n      point (point, optional): 3D point defining new location of the grip\n    Returns:\n      point: if point is not specified, the current location of the grip referenced by index\n      point: if point is specified, the previous location of the grip referenced by index\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if obj:\n          rs.EnableObjectGrips(obj)\n          point = rs.ObjectGripLocation(obj, 0)\n          point[0] = point[0] + 1.0\n          point[1] = point[1] + 1.0\n          point[2] = point[2] + 1.0\n          rs.ObjectGripLocation(obj, 0, point)\n          rs.EnableObjectGrips(obj, False)\n    See Also:\n      EnableObjectGrips\n      ObjectGripLocations\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return scriptcontext.errorhandler()\n    grips = rhobj.GetGrips()\n    if not grips or index<0 or index>=grips.Length:\n        return scriptcontext.errorhandler()\n    grip = grips[index]\n    rc = grip.CurrentLocation\n    if point:\n        grip.CurrentLocation = rhutil.coerce3dpoint(point, True)\n        scriptcontext.doc.Objects.GripUpdate(rhobj, True)\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ObjectGripLocations(object_id, points=None):\n    \"\"\"Returns or modifies the location of all grips owned by an object. The\n    locations of the grips are returned in a list of Point3d with each position\n    in the list corresponding to that grip's index. To modify the locations of\n    the grips, you must provide a list of points that contain the same number\n    of points at grips\n    Parameters:\n      object_id (guid): identifier of the object\n      points ([point, ...], optional) list of 3D points identifying the new grip locations\n    Returns:\n      list(point, ...): if points is not specified, the current location of all grips\n      list(point, ...): if points is specified, the previous location of all grips\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if obj:\n          rs.EnableObjectGrips( obj )\n          points = rs.ObjectGripLocations(obj)\n          for point in points:  print point\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      ObjectGripLocation\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return scriptcontext.errorhandler()\n    grips = rhobj.GetGrips()\n    if grips is None: return scriptcontext.errorhandler()\n    rc = [grip.CurrentLocation for grip in grips]\n    if points and len(points)==len(grips):\n        points = rhutil.coerce3dpointlist(points, True)\n        for i, grip in enumerate(grips):\n            point = points[i]\n            grip.CurrentLocation = point\n        scriptcontext.doc.Objects.GripUpdate(rhobj, True)\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ObjectGripsOn(object_id):\n    \"\"\"Verifies that an object's grips are turned on\n    Parameters:\n      object_id (guid): identifier of the object\n    Returns:\n      bool: True or False indicating Grips state\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select object\")\n      if rs.ObjectGripsOn(obj):\n          print \"Grip count =\", rs.ObjectGripCount(obj)\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      ObjectGripsSelected\n      SelectObjectGrips\n      UnselectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    return rhobj.GripsOn\n\n\ndef ObjectGripsSelected(object_id):\n    \"\"\"Verifies that an object's grips are turned on and at least one grip\n    is selected\n    Parameters:\n      object_id (guid): identifier of the object\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select object\")\n      if rs.ObjectGripsSelected(obj):\n          rs.UnselectObjectGrips( obj )\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      ObjectGripsOn\n      SelectObjectGrips\n      UnselectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return False\n    grips = rhobj.GetGrips()\n    if grips is None: return False\n    for grip in grips:\n        if grip.IsSelected(False): return True\n    return False\n\n\ndef PrevObjectGrip(object_id, index, direction=0, enable=True):\n    \"\"\"Returns the previous grip index from a specified grip index of an object\n    Parameters:\n      object_id (guid): identifier of the object\n      index (number): zero based grip index from which to get the previous grip index\n      direction ([number, number], optional): direction to get the next grip index (0=U, 1=V)\n      enable (bool, optional): if True, the next grip index found will be selected\n    Returns:\n      number: index of the next grip on success\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      object_id = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if object_id:\n          rs.EnableObjectGrips(object_id)\n          count = rs.ObjectGripCount(object_id)\n          for i in range(count-1, 0, -2):\n              rs.PrevObjectGrip(object_id, i, 0, True)\n    See Also:\n      EnableObjectGrips\n      NextObjectGrip\n    \"\"\"\n    return __neighborgrip(-1, object_id, index, direction, enable)\n\n\ndef SelectedObjectGrips(object_id):\n    \"\"\"Returns a list of grip indices indentifying an object's selected grips\n    Parameters:\n      object_id (guid): identifier of the object\n    Returns:\n      list(number): list of indices on success\n      None: on failure or if no grips are selected\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if obj:\n          rs.EnableObjectGrips( obj )\n          count = rs.ObjectGripCount( obj )\n          for i in xrange(0,count,2):\n              rs.SelectObjectGrip( obj, i )\n          grips = rs.SelectedObjectGrips(obj)\n          if grips: print len(grips), \"grips selected\"\n    See Also:\n      EnableObjectGrips\n      SelectObjectGrip\n      SelectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return None\n    grips = rhobj.GetGrips()\n    rc = []\n    if grips:\n        for i in xrange(grips.Length):\n            if grips[i].IsSelected(False): rc.append(i)\n    return rc\n\n\ndef SelectObjectGrip(object_id, index):\n    \"\"\"Selects a single grip owned by an object. If the object's grips are\n    not turned on, the grips will not be selected\n    Parameters:\n      object_id (guid) identifier of the object\n      index (number): index of the grip to select\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if obj:\n          rs.EnableObjectGrips( obj )\n          count = rs.ObjectGripCount( obj )\n          for i in xrange(0,count,2): rs.SelectObjectGrip(obj,i)\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      SelectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return False\n    grips = rhobj.GetGrips()\n    if grips is None: return False\n    if index<0 or index>=grips.Length: return False\n    grip = grips[index]\n    if grip.Select(True,True)>0:\n        scriptcontext.doc.Views.Redraw()\n        return True\n    return False\n\n\ndef SelectObjectGrips(object_id):\n    \"\"\"Selects an object's grips. If the object's grips are not turned on,\n    they will not be selected\n    Parameters:\n      object_id (guid): identifier of the object\n    Returns:\n      number: Number of grips selected on success\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select object\")\n      if rs.ObjectGripsSelected(obj)==False:\n          rs.SelectObjectGrips( obj )\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      SelectObjectGrip\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return scriptcontext.errorhandler()\n    grips = rhobj.GetGrips()\n    if grips is None: return scriptcontext.errorhandler()\n    count = 0\n    for grip in grips:\n        if grip.Select(True,True)>0: count+=1\n    if count>0:\n        scriptcontext.doc.Views.Redraw()\n        return count\n    return scriptcontext.errorhandler()\n\n\ndef UnselectObjectGrip(object_id, index):\n    \"\"\"Unselects a single grip owned by an object. If the object's grips are\n    not turned on, the grips will not be unselected\n    Parameters:\n      object_id (guid): identifier of the object\n      index (number): index of the grip to unselect\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if obj:\n          rs.EnableObjectGrips( obj )\n          count = rs.ObjectGripCount(obj)\n          for i in xrange(0,count,2):\n              rs.UnselectObjectGrip( obj, i )\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      UnselectObjectGrips\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return False\n    grips = rhobj.GetGrips()\n    if grips is None: return False\n    if index<0 or index>=grips.Length: return False\n    grip = grips[index]\n    if grip.Select(False)==0:\n        scriptcontext.doc.Views.Redraw()\n        return True\n    return False\n\n\ndef UnselectObjectGrips(object_id):\n    \"\"\"Unselects an object's grips. Note, the grips will not be turned off.\n    Parameters:\n      object_id (guid): identifier of the object\n    Returns:\n      number: Number of grips unselected on success\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select object\")\n      if rs.ObjectGripsSelected(obj): rs.UnselectObjectGrips(obj)\n    See Also:\n      EnableObjectGrips\n      ObjectGripCount\n      UnselectObjectGrip\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, True)\n    if not rhobj.GripsOn: return scriptcontext.errorhandler()\n    grips = rhobj.GetGrips()\n    if grips is None: return scriptcontext.errorhandler()\n    count = 0\n    for grip in grips:\n        if grip.Select(False)==0: count += 1\n    if count>0:\n        scriptcontext.doc.Views.Redraw()\n        return count\n    return scriptcontext.errorhandler()", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "curve", "functions"], "original_file": "mahaidong_p4r-vscode_a8a1fc09ae.json", "repo": "mahaidong/p4r-vscode"}
{"instruction": "Adds an arc curve to the document", "code": "import scriptcontext\nimport utility as rhutil\nimport Rhino\nimport math\nimport System.Guid, System.Array, System.Enum\n\n\ndef AddArc(plane, radius, angle_degrees):\n    \"\"\"Adds an arc curve to the document\n    Parameters:\n      plane (str): plane on which the arc will lie. The origin of the plane will be\n        the center point of the arc. x-axis of the plane defines the 0 angle\n        direction.\n      radius(number): radius of the arc\n      angle_degrees (number): interval of arc in degrees\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as  rs\n      plane = rs.WorldXYPlane()\n      plane = rs.RotatePlane(plane,  45.0, [0,0,1])\n      rs.AddArc( plane, 5.0, 45.0  )\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcCenterPoint\n      ArcMidPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    radians = math.radians(angle_degrees)\n    arc = Rhino.Geometry.Arc(plane, radius, radians)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add arc to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddArc3Pt(start, end, point_on_arc):\n    \"\"\"Adds a 3-point arc curve to the document\n    Parameters:\n      start, end (point|guid): endpoints of the arc\n      point_on_arc (point|guid): a point on the arc\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      start = rs.GetPoint(\"Start of arc\")\n      if start is not None:\n          end = rs.GetPoint(\"End of arc\")\n          if end is not None:\n              pton = rs.GetPoint(\"Point on arc\")\n              if pton is not None:\n                  rs.AddArc3Pt(start, end, pton)\n    See Also:\n      AddArc\n      ArcAngle\n      ArcCenterPoint\n      ArcMidPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    start = rhutil.coerce3dpoint(start, True)\n    end = rhutil.coerce3dpoint(end, True)\n    pton = rhutil.coerce3dpoint(point_on_arc, True)\n    arc = Rhino.Geometry.Arc(start, pton, end)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add arc to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddArcPtTanPt(start, direction, end):\n    \"\"\"Adds an arc curve, created from a start point, a start direction, and an\n    end point, to the document\n    Parameters:\n      start (point): the starting point of the arc\n      direction (vector): the arc direction at start\n      end (point): the ending point of the arc\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      pick = rs.GetCurveObject(\"Select curve to extend\")\n      point = rs.GetPoint(\"End of extension\")\n      domain = rs.CurveDomain(pick[0])\n      if abs(pick[4]-domain[0]) < abs(pick[4]-domain[1]):\n          origin = rs.CurveStartPoint(pick[0])\n          tangent = rs.VectorReverse(rs.CurveTangent(pick[0], domain[0]))\n      else:\n          origin = rs.CurveEndPoint(pick[0])\n          tangent = rs.CurveTangent(pick[0], domain[1])\n      rs.AddArcPtTanPt(origin, tangent, point)\n    See Also:\n      AddArc\n      AddArc3Pt\n      IsArc\n    \"\"\"\n    start = rhutil.coerce3dpoint(start, True)\n    direction = rhutil.coerce3dvector(direction, True)\n    end = rhutil.coerce3dpoint(end, True)\n    arc = Rhino.Geometry.Arc(start, direction, end)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add arc to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddBlendCurve(curves, parameters, reverses, continuities):\n    \"\"\"Makes a curve blend between two curves\n    Parameters:\n      curves ([guid|curve, guid|curve]): list of two curves\n      parameters ([number, number]): list of two curve parameters defining the blend end points\n      reverses ([bool, bool]): list of two boolean values specifying to use the natural or opposite direction of the curve\n      continuities ([number, number]): list of two numbers specifying continuity at end points\n                                            0 = position\n                                            1 = tangency\n                                            2 = curvature\n    Returns:\n      guid: identifier of new curve on success\n    Example:\n        import rhinoscriptsyntax as rs\n        curve0 = rs.AddLine((0,0,0), (0,9,0))\n        curve1 = rs.AddLine((1,10,0), (10,10,0))\n        curves = curve0, curve1\n        domain_crv0 = rs.CurveDomain(curve0)\n        domain_crv1 = rs.CurveDomain(curve1)\n        params = domain_crv0[1], domain_crv1[0]\n        revs = False, True\n        cont = 2,2\n        rs.AddBlendCurve( curves, params, revs, cont )\n    See Also:\n      AddFilletCurve\n    \"\"\"\n    crv0 = rhutil.coercecurve(curves[0], -1, True)\n    crv1 = rhutil.coercecurve(curves[1], -1, True)\n    c0 = System.Enum.ToObject(Rhino.Geometry.BlendContinuity, continuities[0])\n    c1 = System.Enum.ToObject(Rhino.Geometry.BlendContinuity, continuities[1])\n    curve = Rhino.Geometry.Curve.CreateBlendCurve(crv0, parameters[0], reverses[0], c0, crv1, parameters[1], reverses[1], c1)\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCircle(plane_or_center, radius):\n    \"\"\"Adds a circle curve to the document\n    Parameters:\n      plane_or_center (point|plane): plane on which the circle will lie. If a point is\n        passed, this will be the center of the circle on the active\n        construction plane\n      radius (number): the radius of the circle\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.WorldXYPlane()\n      rs.AddCircle( plane, 5.0 )\n    See Also:\n      AddCircle3Pt\n      CircleCenterPoint\n      CircleCircumference\n      CircleRadius\n      IsCircle\n    \"\"\"\n    rc = None\n    plane = rhutil.coerceplane(plane_or_center, False)\n    if plane:\n        circle = Rhino.Geometry.Circle(plane, radius)\n        rc = scriptcontext.doc.Objects.AddCircle(circle)\n    else:\n        center = rhutil.coerce3dpoint(plane_or_center, True)\n        view = scriptcontext.doc.Views.ActiveView\n        plane = view.ActiveViewport.ConstructionPlane()\n        plane.Origin = center\n        circle = Rhino.Geometry.Circle(plane, radius)\n        rc = scriptcontext.doc.Objects.AddCircle(circle)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add circle to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCircle3Pt(first, second, third):\n    \"\"\"Adds a 3-point circle curve to the document\n    Parameters:\n      first, second, third (point|guid): points on the circle\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      point1 = rs.GetPoint(\"First point on circle\")\n      if point1:\n          point2 = rs.GetPoint(\"Second point on circle\")\n          if point2:\n              point3 = rs.GetPoint(\"Third point on circle\")\n              if point3:\n                  rs.AddCircle3Pt(point1, point2, point3)\n    See Also:\n      AddCircle\n      CircleCenterPoint\n      CircleCircumference\n      CircleRadius\n      IsCircle\n    \"\"\"\n    start = rhutil.coerce3dpoint(first, True)\n    end = rhutil.coerce3dpoint(second, True)\n    third = rhutil.coerce3dpoint(third, True)\n    circle = Rhino.Geometry.Circle(start, end, third)\n    rc = scriptcontext.doc.Objects.AddCircle(circle)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add circle to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCurve(points, degree=3):\n    \"\"\"Adds a control points curve object to the document\n    Parameters:\n      points ([point|guid, ...]) a list of points\n      degree (number): degree of the curve\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      points = rs.GetPoints(True, message1=\"Pick curve point\")\n      if points: rs.AddCurve(points)\n    See Also:\n      AddInterpCurve\n      IsCurve\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    curve = Rhino.Geometry.Curve.CreateControlPointCurve(points, degree)\n    if not curve: raise Exception(\"unable to create control point curve from given points\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddEllipse(plane, radiusX, radiusY):\n    \"\"\"Adds an elliptical curve to the document\n    Parameters:\n      plane (plane) the plane on which the ellipse will lie. The origin of\n              the plane will be the center of the ellipse\n      radiusX, radiusY (number): radius in the X and Y axis directions\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.WorldXYPlane()\n      rs.AddEllipse( plane, 5.0, 10.0 )\n    See Also:\n      AddEllipse3Pt\n      IsEllipse\n      EllipseCenterPoint\n      EllipseQuadPoints\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    ellipse = Rhino.Geometry.Ellipse(plane, radiusX, radiusY)\n    rc = scriptcontext.doc.Objects.AddEllipse(ellipse)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddEllipse3Pt(center, second, third):\n    \"\"\"Adds a 3-point elliptical curve to the document\n    Parameters:\n      center (point|guid): center point of the ellipse\n      second (point|guid): end point of the x axis\n      third  (point|guid): end point of the y axis\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      center = (0,0,0)\n      second = (5,0,0)\n      third = (0,10,0)\n      rs.AddEllipse3Pt( center, second, third )\n    See Also:\n      AddEllipse\n      IsEllipse\n      EllipseCenterPoint\n      EllipseQuadPoints\n    \"\"\"\n    center = rhutil.coerce3dpoint(center, True)\n    second = rhutil.coerce3dpoint(second, True)\n    third = rhutil.coerce3dpoint(third, True)\n    ellipse = Rhino.Geometry.Ellipse(center, second, third)\n    rc = scriptcontext.doc.Objects.AddEllipse(ellipse)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddFilletCurve(curve0id, curve1id, radius=1.0, base_point0=None, base_point1=None):\n    \"\"\"Adds a fillet curve between two curve objects\n    Parameters:\n      curve0id (guid): identifier of the first curve object\n      curve1id (guid): identifier of the second curve object\n      radius (number, optional): fillet radius\n      base_point0 (point|guid, optional): base point of the first curve. If omitted,\n                          starting point of the curve is used\n      base_point1 (point|guid, optional): base point of the second curve. If omitted,\n                          starting point of the curve is used\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      curve0 = rs.AddLine([0,0,0], [5,1,0])\n      curve1 = rs.AddLine([0,0,0], [1,5,0])\n      rs.AddFilletCurve( curve0, curve1 )\n    See Also:\n      CurveFilletPoints\n    \"\"\"\n    if base_point0: base_point0 = rhutil.coerce3dpoint(base_point0, True)\n    else: base_point0 = Rhino.Geometry.Point3d.Unset\n    if base_point1: base_point1 = rhutil.coerce3dpoint(base_point1, True)\n    else: base_point1 = Rhino.Geometry.Point3d.Unset\n    curve0 = rhutil.coercecurve(curve0id, -1, True)\n    curve1 = rhutil.coercecurve(curve1id, -1, True)\n    crv0_t = 0.0\n    if base_point0==Rhino.Geometry.Point3d.Unset:\n        crv0_t = curve0.Domain.Min\n    else:\n        rc, t = curve0.ClosestPoint(base_point0, 0.0)\n        if not rc: raise Exception(\"ClosestPoint failed\")\n        crv0_t = t\n    crv1_t = 0.0\n    if base_point1==Rhino.Geometry.Point3d.Unset:\n        crv1_t = curve1.Domain.Min\n    else:\n        rc, t = curve1.ClosestPoint(base_point1, 0.0)\n        if not rc: raise Exception(\"ClosestPoint failed\")\n        crv1_t = t\n    arc = Rhino.Geometry.Curve.CreateFillet(curve0, curve1, radius, crv0_t, crv1_t)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddInterpCrvOnSrf(surface_id, points):\n    \"\"\"Adds an interpolated curve object that lies on a specified\n    surface.  Note, this function will not create periodic curves,\n    but it will create closed curves.\n    Parameters:\n      surface_id (guid): identifier of the surface to create the curve on\n      points ([point|guid, point|guid, ...])list of 3D points that lie on the specified surface.\n               The list must contain at least 2 points\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      surface_id = rs.GetObject(\"Select surface to draw curve on\", rs.filter.surface)\n      if surface_id:\n          point1 = rs.GetPointOnSurface( surface_id, \"First point on surface\")\n          if point1:\n              point2 = rs.GetPointOnSurface( surface_id, \"Second point on surface\")\n              if point2:\n                  rs.AddInterpCrvOnSrf( surface_id, [point1, point2])\n    See Also:\n      AddCurve\n      AddInterpCurve\n      AddInterpCrvOnSrfUV\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    points = rhutil.coerce3dpointlist(points, True)\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    curve = surface.InterpolatedCurveOnSurface(points, tolerance)\n    if not curve: raise Exception(\"unable to create InterpolatedCurveOnSurface\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddInterpCrvOnSrfUV(surface_id, points):\n    \"\"\"Adds an interpolated curve object based on surface parameters,\n    that lies on a specified surface. Note, this function will not\n    create periodic curves, but it will create closed curves.\n    Parameters:\n      surface_id (guid): identifier of the surface to create the curve on\n      points ([[number, number}, [number,number], ...]): a list of 2D surface parameters. The list must contain\n                                                         at least 2 sets of parameters\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      surface_id = rs.GetObject(\"Select surface to draw curve on\", rs.filter.surface)\n      if surface_id:\n          domainU = rs.SurfaceDomain( surface_id, 0)\n          u0 = domainU[0]/2\n          u1 = domainU[1]/2\n          domainV = rs.SurfaceDomain( surface_id, 1)\n          v0 = domainV[0]/2\n          v1 = domainV[1]/2\n          rs.AddInterpCrvOnSrfUV( surface_id, [[u0,v0],[u1,v1]])\n    See Also:\n      AddCurve\n      AddInterpCurve\n      AddInterpCrvOnSrf\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    points = rhutil.coerce2dpointlist(points)\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    curve = surface.InterpolatedCurveOnSurfaceUV(points, tolerance)\n    if not curve: raise Exception(\"unable to create InterpolatedCurveOnSurfaceUV\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddInterpCurve(points, degree=3, knotstyle=0, start_tangent=None, end_tangent=None):\n    \"\"\"Adds an interpolated curve object to the document. Options exist to make\n    a periodic curve or to specify the tangent at the endpoints. The resulting\n    curve is a non-rational NURBS curve of the specified degree.\n    Parameters:\n      points (point|guid, point|guid, ...]): a list containing 3D points to interpolate. For periodic curves,\n          if the final point is a duplicate of the initial point, it is\n          ignored. The number of control points must be >= (degree+1).\n      degree (number, optional): The degree of the curve (must be >=1).\n          Periodic curves must have a degree >= 2. For knotstyle = 1 or 2,\n          the degree must be 3. For knotstyle = 4 or 5, the degree must be odd\n      knotstyle(opt):\n          0 Uniform knots.  Parameter spacing between consecutive knots is 1.0.\n          1 Chord length spacing.  Requires degree = 3 with arrCV1 and arrCVn1 specified.\n          2 Sqrt (chord length).  Requires degree = 3 with arrCV1 and arrCVn1 specified.\n          3 Periodic with uniform spacing.\n          4 Periodic with chord length spacing.  Requires an odd degree value.\n          5 Periodic with sqrt (chord length) spacing.  Requires an odd degree value.\n      start_tangent (vector, optional): a vector that specifies a tangency condition at the\n          beginning of the curve. If the curve is periodic, this argument must be omitted.\n      end_tangent (vector, optional): 3d vector that specifies a tangency condition at the\n          end of the curve. If the curve is periodic, this argument must be omitted.\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      points = (0,0,0), (1,1,0), (2,0,0), (3,1,0), (4,0,0), (5,1,0)\n      rs.AddInterpCurve(points)\n    See Also:\n      AddCurve\n      CurvePointCount\n      IsCurve\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    if not start_tangent: start_tangent = Rhino.Geometry.Vector3d.Unset\n    start_tangent = rhutil.coerce3dvector(start_tangent, True)\n    if not end_tangent: end_tangent = Rhino.Geometry.Vector3d.Unset\n    end_tangent = rhutil.coerce3dvector(end_tangent, True)\n    knotstyle = System.Enum.ToObject(Rhino.Geometry.CurveKnotStyle, knotstyle)\n    curve = Rhino.Geometry.Curve.CreateInterpolatedCurve(points, degree, knotstyle, start_tangent, end_tangent)\n    if not curve: raise Exception(\"unable to CreateInterpolatedCurve\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddLine(start, end):\n    \"\"\"Adds a line curve to the current model.\n    Parameters:\n      start, end (point|guid) end points of the line\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      start = rs.GetPoint(\"Start of line\")\n      if start:\n          end = rs.GetPoint(\"End of line\")\n          if end: rs.AddLine(start, end)\n    See Also:\n      CurveEndPoint\n      CurveStartPoint\n      IsLine\n    \"\"\"\n    start = rhutil.coerce3dpoint(start, True)\n    end = rhutil.coerce3dpoint(end, True)\n    rc = scriptcontext.doc.Objects.AddLine(start, end)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add line to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddNurbsCurve(points, knots, degree, weights=None):\n    \"\"\"Adds a NURBS curve object to the document\n    Parameters:\n      points ([guid|point, guid|point, ...]): a list containing 3D control points\n      knots ([number, number, ...]): Knot values for the curve. The number of elements in knots must\n          equal the number of elements in points plus degree minus 1\n      degree (number): degree of the curve. must be greater than of equal to 1\n      weights([number, number, ...], optional) weight values for the curve. Number of elements should\n          equal the number of elements in points. Values must be greater than 0\n    Returns:\n      guid: the identifier of the new object if successful, otherwise None\n    Example:\n      import rhinoscriptsyntax as rs\n      curve_id = rs.GetObject(\"Pick a curve\", rs.filter.curve)\n      if curve_id:\n          points = rs.CurvePoints(curve_id)\n          knots = rs.CurveKnots(curve_id)\n          degree = rs.CurveDegree(curve_id)\n          newcurve = rs.AddNurbsCurve( points, knots, degree)\n          if newcurve: rs.SelectObject(newcurve)\n    See Also:\n      CurveDegree\n      CurveKnots\n      CurvePoints\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    cvcount = len(points)\n    knotcount = cvcount + degree - 1\n    if len(knots)!=knotcount:\n        raise Exception(\"Number of elements in knots must equal the number of elements in points plus degree minus 1\")\n    if weights and len(weights)!=cvcount:\n        raise Exception(\"Number of elements in weights should equal the number of elements in points\")\n    rational = (weights!=None)\n    \n    nc = Rhino.Geometry.NurbsCurve(3,rational,degree+1,cvcount)\n    for i in xrange(cvcount):\n        cp = Rhino.Geometry.ControlPoint()\n        cp.Location = points[i]\n        if weights: \n            cp.Weight = weights[i]\n        else:\n            cp.Weight = 1.0\n        nc.Points[i] = cp\n    for i in xrange(knotcount): nc.Knots[i] = knots[i]\n    rc = scriptcontext.doc.Objects.AddCurve(nc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddPolyline(points, replace_id=None):\n    \"\"\"Adds a polyline curve to the current model\n    Parameters:\n      points ([guid|point, guid|point, ...]): list of 3D points. Duplicate, consecutive points will be\n               removed. The list must contain at least two points. If the\n               list contains less than four points, then the first point and\n               last point must be different.\n      replace_id (guid, optional): If set to the id of an existing object, the object\n               will be replaced by this polyline\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      points = rs.GetPoints(True)\n      if points: rs.AddPolyline(points)\n    See Also:\n      IsPolyline\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    if replace_id: replace_id = rhutil.coerceguid(replace_id, True)\n    rc = System.Guid.Empty\n    pl = Rhino.Geometry.Polyline(points)\n    pl.DeleteShortSegments(scriptcontext.doc.ModelAbsoluteTolerance)\n    if replace_id:\n        if scriptcontext.doc.Objects.Replace(replace_id, pl):\n            rc = replace_id\n    else:\n        rc = scriptcontext.doc.Objects.AddPolyline(pl)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add polyline to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddRectangle(plane, width, height):\n    \"\"\"Add a rectangular curve to the document\n    Parameters:\n      plane (plane) plane on which the rectangle will lie\n      width, height (number): width and height of rectangle as measured along the plane's\n        x and y axes\n    Returns:\n      guid: id of new rectangle\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.WorldXYPlane()\n      plane = rs.RotatePlane(plane, 45.0, [0,0,1])\n      rs.AddRectangle( plane, 5.0, 15.0 )\n    See Also:\n      \n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    rect = Rhino.Geometry.Rectangle3d(plane, width, height)\n    poly = rect.ToPolyline()\n    rc = scriptcontext.doc.Objects.AddPolyline(poly)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add polyline to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSpiral(point0, point1, pitch, turns, radius0, radius1=None):\n    \"\"\"Adds a spiral or helical curve to the document\n    Parameters:\n      point0 (point|guid): helix axis start point or center of spiral\n      point1 (point|guid): helix axis end point or point normal on spiral plane\n      pitch (number): distance between turns. If 0, then a spiral. If > 0 then the\n              distance between helix \"threads\"\n      turns (number): number of turns\n      radius0 (number): starting radius of spiral\n      radius1 (number, optional): ending radius of spiral. If omitted, the starting radius is used for the complete spiral.\n    Returns:\n      guid: id of new curve on success\n    Example:\n      import rhinoscriptsyntax as rs\n      point0 = (0,0,0)\n      point1 = (0,0,10)\n      pitch = 1\n      turns = 10\n      radius0 = 5.0\n      radius1 = 8.0\n      rs.AddSpiral(point0, point1, pitch, turns, radius0, radius1)\n    See Also:\n      \n    \"\"\"\n    if radius1 is None: radius1 = radius0\n    point0 = rhutil.coerce3dpoint(point0, True)\n    point1 = rhutil.coerce3dpoint(point1, True)\n    dir = point1 - point0\n    plane = Rhino.Geometry.Plane(point0, dir)\n    point2 = point0 + plane.XAxis\n    curve = Rhino.Geometry.NurbsCurve.CreateSpiral(point0, dir, point2, pitch, turns, radius0, radius1)\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSubCrv(curve_id, param0, param1):\n    \"\"\"Add a curve object based on a portion, or interval of an existing curve\n    object. Similar in operation to Rhino's SubCrv command\n    Parameters:\n      curve_id (guid): identifier of a closed planar curve object\n      param0, param1 (number): first and second parameters on the source curve\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      getresult = rs.GetCurveObject()\n      if getresult:\n          curve_id = getresult[0]\n          point0 = rs.GetPointOnCurve( curve_id )\n          if point0:\n              point1 = rs.GetPointOnCurve( curve_id )\n              if point1:\n                  t0 = rs.CurveClosestPoint( curve_id, point0)\n                  t1 = rs.CurveClosestPoint( curve_id, point1)\n                  rs.AddSubCrv( curve_id, t0, t1 )\n    See Also:\n      CurveClosestPoint\n      GetCurveObject\n      GetPointOnCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    trimcurve = curve.Trim(param0, param1)\n    if not trimcurve: raise Exception(\"unable to trim curve\")\n    rc = scriptcontext.doc.Objects.AddCurve(trimcurve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ArcAngle(curve_id, segment_index=-1):\n    \"\"\"Returns the angle of an arc curve object.\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): identifies the curve segment if\n      curve_id (guid): identifies a polycurve\n    Returns:\n      number: The angle in degrees if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select arc\")\n      if rs.IsArc(id):\n          angle = rs.ArcAngle(id)\n          print \"Arc angle:\", angle\n    See Also:\n      AddArc3Pt\n      ArcCenterPoint\n      ArcMidPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.AngleDegrees\n\n\ndef ArcCenterPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the center point of an arc curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: The 3D center point of the arc if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select arc\")\n      if rs.IsArc(id):\n      point = rs.ArcCenterPoint(id)\n      rs.AddPoint(point)\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcMidPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.Center\n\n\ndef ArcMidPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the mid point of an arc curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: The 3D mid point of the arc if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select arc\")\n      if rs.IsArc(id):\n          point = rs.ArcMidPoint(id)\n          rs.AddPoint(point)\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcCenterPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.MidPoint\n\n\ndef ArcRadius(curve_id, segment_index=-1):\n    \"\"\"Returns the radius of an arc curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The radius of the arc if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select arc\")\n      if rs.IsArc(id):\n          radius = rs.ArcRadius(id)\n          print \"Arc radius:\", radius\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcCenterPoint\n      ArcMidPoint\n      IsArc\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.Radius\n\n\ndef CircleCenterPoint(curve_id, segment_index=-1, return_plane=False):\n    \"\"\"Returns the center point of a circle curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n      return_plane (bool, optional): if True, the circle's plane is returned. If omitted the plane is not returned.\n    Returns:\n      point: The 3D center point of the circle if successful.\n      plane: The plane of the circle if return_plane is True\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select circle\")\n      if rs.IsCircle(id):\n          point = rs.CircleCenterPoint(id)\n          rs.AddPoint( point )\n    See Also:\n      AddCircle\n      AddCircle3Pt\n      CircleCircumference\n      CircleRadius\n      IsCircle\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, circle = curve.TryGetCircle(Rhino.RhinoMath.ZeroTolerance)\n    if not rc: raise Exception(\"curve is not circle\")\n    if return_plane: return circle.Plane\n    return circle.Center\n\n\ndef CircleCircumference(curve_id, segment_index=-1):\n    \"\"\"Returns the circumference of a circle curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The circumference of the circle if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select circle\")\n      if rs.IsCircle(id):\n          circumference = rs.CircleCircumference(id)\n          print \"Circle circumference:\", circumference\n    See Also:\n      AddCircle\n      AddCircle3Pt\n      CircleCenterPoint\n      CircleRadius\n      IsCircle\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, circle = curve.TryGetCircle( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not circle\")\n    return circle.Circumference\n\ndef CircleRadius(curve_id, segment_index=-1):\n    \"\"\"Returns the radius of a circle curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The radius of the circle if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select circle\")\n      if rs.IsCircle(id):\n          radius = rs.CircleRadius(id)\n          print \"Circle radius:\", radius\n    See Also:\n      AddCircle\n      AddCircle3Pt\n      CircleCenterPoint\n      CircleCircumference\n      IsCircle\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, circle = curve.TryGetCircle( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not circle\")\n    return circle.Radius\n\ndef CloseCurve(curve_id, tolerance=-1.0):\n    \"\"\"Closes an open curve object by making adjustments to the end points so\n    they meet at a point\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      tolerance (number, optional): maximum allowable distance between start and end\n                                    point. If omitted, the current absolute tolerance is used\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if not rs.IsCurveClosed(obj) and rs.IsCurveClosable(obj):\n          rs.CloseCurve( obj )\n    See Also:\n      IsCurveClosable\n      IsCurveClosed\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if curve.IsClosed: return curve_id\n    if tolerance<0.0: tolerance = Rhino.RhinoMath.ZeroTolerance\n    if not curve.MakeClosed(tolerance): return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\ndef ClosedCurveOrientation(curve_id, direction=(0,0,1)):\n    \"\"\"Determine the orientation (counter-clockwise or clockwise) of a closed,\n    planar curve\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      direction (vector, optional): 3d vector that identifies up, or Z axs, direction of\n                                    the plane to test against\n    Returns:\n      number: 1 if the curve's orientation is clockwise\n             -1 if the curve's orientation is counter-clockwise\n              0 if unable to compute the curve's orientation\n    Example:\n    See Also:\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1 ,True)\n    direction = rhutil.coerce3dvector(direction, True)\n    if not curve.IsClosed: return 0\n    orientation = curve.ClosedCurveOrientation(direction)\n    return int(orientation)\n\n\ndef ConvertCurveToPolyline(curve_id, angle_tolerance=5.0, tolerance=0.01, delete_input=False, min_edge_length=0, max_edge_length=0):\n    \"\"\"Convert curve to a polyline curve\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      angle_tolerance (number, optional): The maximum angle between curve tangents at line endpoints.\n                                          If omitted, the angle tolerance is set to 5.0.\n      tolerance(number, optional): The distance tolerance at segment midpoints. If omitted, the tolerance is set to 0.01.\n      delete_input(bool, optional): Delete the curve object specified by curve_id. If omitted, curve_id will not be deleted.\n      min_edge_length (number, optional): Minimum segment length\n      max_edge_length (number, optonal): Maximum segment length\n    Returns:\n      guid: The new curve if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          polyline = rs.ConvertCurveToPolyline(obj)\n          if polyline: rs.SelectObject(polyline)\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if angle_tolerance<=0: angle_tolerance = 5.0\n    angle_tolerance = Rhino.RhinoMath.ToRadians(angle_tolerance)\n    if tolerance<=0.0: tolerance = 0.01;\n    polyline_curve = curve.ToPolyline( 0, 0, angle_tolerance, 0.0, 0.0, tolerance, min_edge_length, max_edge_length, True)\n    if not polyline_curve: return scriptcontext.errorhandler()\n    id = System.Guid.Empty\n    if delete_input:\n        if scriptcontext.doc.Objects.Replace( curve_id, polyline_curve): id = curve_id\n    else:\n        id = scriptcontext.doc.Objects.AddCurve( polyline_curve )\n    if System.Guid.Empty==id: return scriptcontext.errorhandler()\n    return id\n\n  \ndef CurveArcLengthPoint(curve_id, length, from_start=True):\n    \"\"\"Returns the point on the curve that is a specified arc length\n    from the start of the curve.\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      length (number): The arc length from the start of the curve to evaluate.\n      from_start (bool, optional): If not specified or True, then the arc length point is\n          calculated from the start of the curve. If False, the arc length\n          point is calculated from the end of the curve.\n    Returns:\n      point: on curve if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          length = rs.CurveLength(obj)\n          point = rs.CurveArcLengthPoint(obj, length/3.0)\n          rs.AddPoint( point )\n    See Also:\n      CurveEndPoint\n      CurveMidPoint\n      CurveStartPoint\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    curve_length = curve.GetLength()\n    if curve_length>=length:\n        s = 0.0\n        if length==0.0: s = 0.0\n        elif length==curve_length: s = 1.0\n        else: s = length / curve_length\n        dupe = curve.Duplicate()\n        if dupe:\n            if from_start==False: dupe.Reverse()\n            rc, t = dupe.NormalizedLengthParameter(s)\n            if rc: return dupe.PointAt(t)\n            dupe.Dispose()\n\n\ndef CurveArea(curve_id):\n    \"\"\"Returns area of closed planar curves. The results are based on the\n    current drawing units.\n    Parameters:\n      curve_id (guid): The identifier of a closed, planar curve object.\n    Returns:\n      list[number, number]: List of area information. The list will contain the following information:\n        Element  Description\n        [0]      The area. If more than one curve was specified, the\n                   value will be the cumulative area.\n        [1]      The absolute (+/-) error bound for the area.\n    Example:\n      import rhinocsriptsyntax as rs\n      id = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if id:\n          props = rs.CurveArea(id)\n          if props:\n              print \"The curve area is:\", props[0]\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    mp = Rhino.Geometry.AreaMassProperties.Compute(curve, tol)\n    if mp == None: return None\n    return mp.Area, mp.AreaError\n\n\ndef CurveAreaCentroid(curve_id):\n    \"\"\"Returns area centroid of closed, planar curves. The results are based\n    on the current drawing units.\n    Parameters:\n      curve_id (guid)The identifier of a closed, planar curve object.\n    Returns:\n      tuple(point, vector): of area centroid information containing the following information:\n        Element  Description\n        [0]        The 3d centroid point. If more than one curve was specified,\n                 the value will be the cumulative area.\n        [1]        A 3d vector with the absolute (+/-) error bound for the area\n                 centroid.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if id:\n          props = rs.CurveAreaCentroid(id)\n          if props:\n              print \"The curve area centroid is:\", props[0]\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    mp = Rhino.Geometry.AreaMassProperties.Compute(curve, tol)\n    if mp == None: return None\n    return mp.Centroid, mp.CentroidError\n\n\ndef CurveArrows(curve_id, arrow_style=None):\n    \"\"\"Enables or disables a curve object's annotation arrows\n    Parameters:\n      curve_id (guid): identifier of a curve\n      arrow_style (number, optional): the style of annotation arrow to be displayed. If omitted the current type is returned.\n        0 = no arrows\n        1 = display arrow at start of curve\n        2 = display arrow at end of curve\n        3 = display arrow at both start and end of curve\n      Returns:\n        number: if arrow_style is not specified, the current annotation arrow style\n        number: if arrow_style is specified, the previous arrow style\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.CurveArrows(obj)!=3: rs.CurveArrows(obj, 3)\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rhobj = rhutil.coercerhinoobject(curve_id, True, True)\n    attr = rhobj.Attributes\n    rc = attr.ObjectDecoration\n    if arrow_style is not None:\n        if arrow_style==0:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.None\n        elif arrow_style==1:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.StartArrowhead\n        elif arrow_style==2:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.EndArrowhead\n        elif arrow_style==3:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.BothArrowhead\n        id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.ModifyAttributes(id, attr, True)\n        scriptcontext.doc.Views.Redraw()\n    if rc==Rhino.DocObjects.ObjectDecoration.None: return 0\n    if rc==Rhino.DocObjects.ObjectDecoration.StartArrowhead: return 1\n    if rc==Rhino.DocObjects.ObjectDecoration.EndArrowhead: return 2\n    if rc==Rhino.DocObjects.ObjectDecoration.BothArrowhead: return 3\n\n\ndef CurveBooleanDifference(curve_id_0, curve_id_1, tolerance=None):\n    \"\"\"Calculates the difference between two closed, planar curves and\n    adds the results to the document. Note, curves must be coplanar.\n    Parameters:\n      curve_id_0 (guid): identifier of the first curve object.\n      curve_id_1 (guid): identifier of the second curve object.\n      tolerance (float, optional): a positive tolerance value, or None for the doc default.\n    Returns:\n      list(guid, ...): The identifiers of the new objects if successful, None on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curveA = rs.GetObject(\"Select first curve\", rs.filter.curve)\n      curveB = rs.GetObject(\"Select second curve\", rs.filter.curve)\n      arrResult = rs.CurveBooleanDifference(curveA, curveB)\n      if arrResult:\n          rs.DeleteObject( curveA )\n          rs.DeleteObject( curveB )\n    See Also:\n      CurveBooleanIntersection\n      CurveBooleanUnion\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    out_curves = Rhino.Geometry.Curve.CreateBooleanDifference(curve0, curve1, tolerance)\n    curves = []\n    if out_curves:\n        for curve in out_curves:\n            if curve and curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n                curve.Dispose()\n                if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n                curves.append(rc)\n    scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef CurveBooleanIntersection(curve_id_0, curve_id_1, tolerance=None):\n    \"\"\"Calculates the intersection of two closed, planar curves and adds\n    the results to the document. Note, curves must be coplanar.\n    Parameters:\n      curve_id_0 (guid): identifier of the first curve object.\n      curve_id_1 (guid): identifier of the second curve object.\n      tolerance (float, optional): a positive tolerance value, or None for the doc default.\n    Returns:\n      list(guid, ...): The identifiers of the new objects.\n    Example:\n      import rhinoscriptsyntax as rs\n      curveA = rs.GetObject(\"Select first curve\", rs.filter.curve)\n      curveB = rs.GetObject(\"Select second curve\", rs.filter.curve)\n      result = rs.CurveBooleanIntersection(curveA, curveB)\n      if result:\n          rs.DeleteObject( curveA )\n          rs.DeleteObject( curveB )\n    See Also:\n      CurveBooleanDifference\n      CurveBooleanUnion\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    out_curves = Rhino.Geometry.Curve.CreateBooleanIntersection(curve0, curve1, tolerance)\n    curves = []\n    if out_curves:\n        for curve in out_curves:\n            if curve and curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n                curve.Dispose()\n                if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n                curves.append(rc)\n    scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef CurveBooleanUnion(curve_id, tolerance=None):\n    \"\"\"Calculate the union of two or more closed, planar curves and\n    add the results to the document. Note, curves must be coplanar.\n    Parameters:\n      curve_id ([guid, guid, ...])list of two or more close planar curves identifiers\n      tolerance (float, optional): a positive tolerance value, or None for the doc default.\n    Returns:\n      list(guid, ...): The identifiers of the new objects.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve_ids = rs.GetObjects(\"Select curves to union\", rs.filter.curve)\n      if curve_ids and len(curve_ids)>1:\n          result = rs.CurveBooleanUnion(curve_ids)\n          if result: rs.DeleteObjects(curve_ids)\n    See Also:\n      CurveBooleanDifference\n      CurveBooleanIntersection\n    \"\"\"\n    in_curves = [rhutil.coercecurve(id,-1,True) for id in curve_id]\n    if len(in_curves)<2: raise ValueException(\"curve_id must have at least 2 curves\")\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    out_curves = Rhino.Geometry.Curve.CreateBooleanUnion(in_curves, tolerance)\n    curves = []\n    if out_curves:\n        for curve in out_curves:\n            if curve and curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n                curve.Dispose()\n                if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n                curves.append(rc)\n        scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef CurveBrepIntersect(curve_id, brep_id, tolerance=None):\n    \"\"\"Intersects a curve object with a brep object. Note, unlike the\n    CurveSurfaceIntersection function, this function works on trimmed surfaces.\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      brep_id (guid): identifier of a brep object\n      tolerance (number, optional): distance tolerance at segment midpoints.\n                        If omitted, the current absolute tolerance is used.\n    Returns:\n      list(guid, ...): identifiers for the newly created intersection objects if successful.\n      None: on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if curve:\n          brep = rs.GetObject(\"Select a brep\", rs.filter.surface + rs.filter.polysurface)\n          if brep: rs.CurveBrepIntersect( curve, brep )\n    See Also:\n      CurveSurfaceIntersection\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    brep = rhutil.coercebrep(brep_id, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, out_curves, out_points = Rhino.Geometry.Intersect.Intersection.CurveBrep(curve, brep, tolerance)\n    if not rc: return scriptcontext.errorhandler()\n    \n    curves = []\n    points = []\n    for curve in out_curves:\n        if curve and curve.IsValid:\n            rc = scriptcontext.doc.Objects.AddCurve(curve)\n            curve.Dispose()\n            if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n            curves.append(rc)\n    for point in out_points:\n        if point and point.IsValid:\n            rc = scriptcontext.doc.Objects.AddPoint(point)\n            points.append(rc)\n    if not curves and not points: return None\n    scriptcontext.doc.Views.Redraw()\n    return curves, points\n\n\ndef CurveClosestObject(curve_id, object_ids):\n    \"\"\"Returns the 3D point locations on two objects where they are closest to\n    each other. Note, this function provides similar functionality to that of\n    Rhino's ClosestPt command.\n    Parameters:\n      curve_id (guid):identifier of the curve object to test\n      object_ids ([guid, ...]) list of identifiers of point cloud, curve, surface, or\n        polysurface to test against\n    Returns:\n      tuple[guid, point, point]: containing the results of the closest point calculation.\n      The elements are as follows:\n        [0]    The identifier of the closest object.\n        [1]    The 3-D point that is closest to the closest object.\n        [2]    The 3-D point that is closest to the test curve.\n    Example:\n      import rhinoscriptsyntax as rs\n      filter = rs.filter.curve | rs.filter.pointcloud | rs.filter.surface | rs.filter.polysurface\n      objects = rs.GetObjects(\"Select target objects for closest point\", filter)\n      if objects:\n          curve = rs.GetObject(\"Select curve\")\n          if curve:\n              results = rs.CurveClosestObject(curve, objects)\n              if results:\n                    print \"Curve id:\", results[0]\n                    rs.AddPoint( results[1] )\n                    rs.AddPoint( results[2] )\n    See Also:\n      CurveClosestPoint\n      EvaluateCurve\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id,-1,True)\n    geometry = []\n    id = rhutil.coerceguid(object_ids, False)\n    if id: object_ids = [id]\n    for object_id in object_ids:\n        rhobj = rhutil.coercerhinoobject(object_id, True, True)\n        geometry.append( rhobj.Geometry )\n    if not geometry: raise ValueError(\"object_ids must contain at least one item\")\n    success, curve_point, geom_point, which_geom = curve.ClosestPoints(geometry, 0.0)\n    if success: return object_ids[which_geom], geom_point, curve_point\n\n    \ndef CurveClosestPoint(curve_id, test_point, segment_index=-1 ):\n    \"\"\"Returns parameter of the point on a curve that is closest to a test point.\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      point (point): sampling point\n      segment_index (number, optional): curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The parameter of the closest point on the curve\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a curve\")\n      if id:\n          point = rs.GetPointOnCurve(id, \"Pick a test point\")\n          if point:\n              param = rs.CurveClosestPoint(id, point)\n              print \"Curve parameter:\", param\n    See Also:\n      EvaluateCurve\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    point = rhutil.coerce3dpoint(test_point, True)\n    rc, t = curve.ClosestPoint(point, 0.0)\n    if not rc: raise Exception(\"ClosestPoint failed\")\n    return t\n\n\ndef CurveContourPoints(curve_id, start_point, end_point, interval=None):\n    \"\"\"Returns the 3D point locations calculated by contouring a curve object.\n    Parameters:\n      curve_id (guid): identifier of a curve object.\n      start_point (point): 3D starting point of a center line.\n      end_point (point): 3D ending point of a center line.\n      interval (number, optional): The distance between contour curves. If omitted,\n      the interval will be equal to the diagonal distance of the object's\n      bounding box divided by 50.\n    Returns:\n      list(point, ....): A list of 3D points, one for each contour\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      start_point = rs.GetPoint(\"Base point of center line\")\n      end_point = rs.GetPoint(\"Endpoint of center line\", start_point)\n      contour = rs.CurveContourPoints(obj, start_point, end_point)\n      if contour: rs.AddPoints(contour)\n    See Also:\n      AddSrfContourCrvs\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    start_point = rhutil.coerce3dpoint(start_point, True)\n    end_point = rhutil.coerce3dpoint(end_point, True)\n    if start_point.DistanceTo(end_point)<Rhino.RhinoMath.ZeroTolerance:\n        raise Exception(\"start and end point are too close to define a line\")\n    if not interval:\n        bbox = curve.GetBoundingBox(True)\n        diagonal = bbox.Max - bbox.Min\n        interval = diagonal.Length / 50.0\n    rc = curve.DivideAsContour( start_point, end_point, interval )\n    return list(rc)\n\n\ndef CurveCurvature(curve_id, parameter):\n    \"\"\"Returns the curvature of a curve at a parameter. See the Rhino help for\n    details on curve curvature\n    Parameters:\n      curve_id (guid): identifier of the curve\n      parameter (number): parameter to evaluate\n    Returns:\n      tuple[point, vector, point, number, vector]: of curvature information on success\n        [0] = point at specified parameter\n        [1] = tangent vector\n        [2] = center of radius of curvature\n        [3] = radius of curvature\n        [4] = curvature vector\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          point = rs.GetPointOnCurve(obj, \"Pick a test point\")\n          if point:\n              param = rs.CurveClosestPoint(obj, point)\n              if param:\n                  data = rs.CurveCurvature(obj, param)\n                  if data:\n                      print \"Curve curvature evaluation at parameter\", param, \":\"\n                      print \" 3-D Point:\", data[0]\n                      print \" 3-D Tangent:\", data[1]\n                      print \" Center of radius of curvature:\", data[2]\n                      print \" Radius of curvature:\", data[3]\n                      print \" 3-D Curvature:\", data[4]\n    See Also:\n      SurfaceCurvature\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    point = curve.PointAt(parameter)\n    tangent = curve.TangentAt(parameter)\n    if tangent.IsTiny(0): return scriptcontext.errorhandler()\n    cv = curve.CurvatureAt(parameter)\n    k = cv.Length\n    if k<Rhino.RhinoMath.SqrtEpsilon: return scriptcontext.errorhandler()\n    rv = cv / (k*k)\n    circle = Rhino.Geometry.Circle(point, tangent, point + 2.0*rv)\n    center = point + rv\n    radius = circle.Radius\n    return point, tangent, center, radius, cv\n\n\ndef CurveCurveIntersection(curveA, curveB=None, tolerance=-1):\n    \"\"\"Calculates intersection of two curve objects.\n    Parameters:\n      curveA (guid): identifier of the first curve object.\n      curveB  (guid, optional): identifier of the second curve object. If omitted, then a\n               self-intersection test will be performed on curveA.\n      tolerance (number, optional): absolute tolerance in drawing units. If omitted,\n                        the document's current absolute tolerance is used.\n    Returns:\n      list of tuples: containing intersection information if successful.\n      The list will contain one or more of the following elements:\n        Element Type     Description\n        [n][0]  Number   The intersection event type, either Point (1) or Overlap (2).\n        [n][1]  Point3d  If the event type is Point (1), then the intersection point \n                         on the first curve. If the event type is Overlap (2), then\n                         intersection start point on the first curve.\n        [n][2]  Point3d  If the event type is Point (1), then the intersection point\n                         on the first curve. If the event type is Overlap (2), then\n                         intersection end point on the first curve.\n        [n][3]  Point3d  If the event type is Point (1), then the intersection point \n                         on the second curve. If the event type is Overlap (2), then\n                         intersection start point on the second curve.\n        [n][4]  Point3d  If the event type is Point (1), then the intersection point\n                         on the second curve. If the event type is Overlap (2), then\n                         intersection end point on the second curve.\n        [n][5]  Number   If the event type is Point (1), then the first curve parameter.\n                         If the event type is Overlap (2), then the start value of the\n                         first curve parameter range.\n        [n][6]  Number   If the event type is Point (1), then the first curve parameter.\n                         If the event type is Overlap (2), then the end value of the\n                         first curve parameter range.\n        [n][7]  Number   If the event type is Point (1), then the second curve parameter.\n                         If the event type is Overlap (2), then the start value of the\n                         second curve parameter range.\n        [n][8]  Number   If the event type is Point (1), then the second curve parameter.\n                         If the event type is Overlap (2), then the end value of the \n                         second curve parameter range.\n    Example:\n      import rhinoscriptsyntax as rs\n      def ccx():\n          curve1 = rs.GetObject(\"Select first curve\", rs.filter.curve)\n          if curve1 is None: return\n          curve2 = rs.GetObject(\"Select second curve\", rs.filter.curve)\n          if curve2 is None: return\n          intersection_list = rs.CurveCurveIntersection(curve1, curve2)\n          if intersection_list is None:\n              print \"Selected curves do not intersect.\"\n              return\n          for intersection in intersection_list:\n              if intersection[0] == 1:\n                  print \"Point\"\n                  print \"Intersection point on first curve: \", intersection[1]\n                  print \"Intersection point on second curve: \", intersection[3]\n                  print \"First curve parameter: \", intersection[5]\n                  print \"Second curve parameter: \", intersection[7]\n              else:\n                  print \"Overlap\"\n                  print \"Intersection start point on first curve: \", intersection[1]\n                  print \"Intersection end point on first curve: \", intersection[2]\n                  print \"Intersection start point on second curve: \", intersection[3]\n                  print \"Intersection end point on second curve: \", intersection[4]\n                  print \"First curve parameter range: \", intersection[5], \" to \", intersection[6]\n                  print \"Second curve parameter range: \", intersection[7], \" to \", intersection[8]\n      ccx()\n    See Also:\n      CurveSurfaceIntersection\n    \"\"\"\n    curveA = rhutil.coercecurve(curveA, -1, True)\n    if curveB: curveB = rhutil.coercecurve(curveB, -1, True)\n    if tolerance is None or tolerance<0.0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if curveB:\n        rc = Rhino.Geometry.Intersect.Intersection.CurveCurve(curveA, curveB, tolerance, 0.0)\n    else:\n        rc = Rhino.Geometry.Intersect.Intersection.CurveSelf(curveA, tolerance)\n    if rc:\n        events = []\n        for i in xrange(rc.Count):\n            event_type = 1\n            if( rc[i].IsOverlap ): event_type = 2\n            oa = rc[i].OverlapA\n            ob = rc[i].OverlapB\n            element = (event_type, rc[i].PointA, rc[i].PointA2, rc[i].PointB, rc[i].PointB2, oa[0], oa[1], ob[0], ob[1])\n            events.append(element)\n        return events\n\n\ndef CurveDegree(curve_id, segment_index=-1):\n    \"\"\"Returns the degree of a curve object.\n    Parameters:\n      curve_id (guid): identifier of a curve object.\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve.\n    Returns:\n      number: The degree of the curve if successful.\n      None: on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          degree = rs.CurveDegree(obj)\n          print \"Curve degree:\", degree\n    See Also:\n      CurveDomain\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.Degree\n\n\ndef CurveDeviation(curve_a, curve_b):\n    \"\"\"Returns the minimum and maximum deviation between two curve objects\n    Parameters:\n      curve_a, curve_b (guid): identifiers of two curves\n    Returns:\n      tuple[number, number, number, number, number, number]: of deviation information on success\n        [0] = curve_a parameter at maximum overlap distance point\n        [1] = curve_b parameter at maximum overlap distance point\n        [2] = maximum overlap distance\n        [3] = curve_a parameter at minimum overlap distance point\n        [4] = curve_b parameter at minimum overlap distance point\n        [5] = minimum distance between curves\n      None on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curveA = rs.GetObject(\"Select first curve to test\", rs.filter.curve)\n      curveB = rs.GetObject(\"Select second curve to test\", rs.filter.curve)\n      deviation = rs.CurveDeviation(curveA, curveB)\n      if deviation:\n          print \"Minimum deviation =\", deviation[5]\n          print \"Maximum deviation =\", deviation[2]\n    See Also:\n      CurveArea\n      CurveAreaCentroid\n    \"\"\"\n    curve_a = rhutil.coercecurve(curve_a, -1, True)\n    curve_b = rhutil.coercecurve(curve_b, -1, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc = Rhino.Geometry.Curve.GetDistancesBetweenCurves(curve_a, curve_b, tol)\n    if not rc[0]: return scriptcontext.errorhandler()\n    maxa = rc[2]\n    maxb = rc[3]\n    maxd = rc[1]\n    mina = rc[5]\n    minb = rc[6]\n    mind = rc[4]\n    return maxa, maxb, maxd, mina, minb, mind\n\n\ndef CurveDim(curve_id, segment_index=-1):\n    \"\"\"Returns the dimension of a curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object.\n      segment_index (number, optional): the curve segment if `curve_id` identifies a polycurve.\n    Returns:\n      number: The dimension of the curve if successful. None on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(curve):\n          print \"Curve dimension =\", rs.CurveDim(curve)\n    See Also:\n      CurveDegree\n      CurveDomain\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.Dimension\n\n\ndef CurveDirectionsMatch(curve_id_0, curve_id_1):\n    \"\"\"Tests if two curve objects are generally in the same direction or if they\n    would be more in the same direction if one of them were flipped. When testing\n    curve directions, both curves must be either open or closed - you cannot test\n    one open curve and one closed curve.\n    Parameters:\n      curve_id_0 (guid): identifier of first curve object\n      curve_id_1 (guid): identifier of second curve object\n    Returns:\n      bool: True if the curve directions match, otherwise False.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve1 = rs.GetObject(\"Select first curve to compare\", rs.filter.curve)\n      curve2 = rs.GetObject(\"Select second curve to compare\", rs.filter.curve)\n      if rs.CurveDirectionsMatch(curve1, curve2):\n          print \"Curves are in the same direction\"\n      else:\n          print \"Curve are not in the same direction\"\n    See Also:\n      ReverseCurve\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    return Rhino.Geometry.Curve.DoDirectionsMatch(curve0, curve1)\n\n\ndef CurveDiscontinuity(curve_id, style):   \n    \"\"\"Search for a derivatitive, tangent, or curvature discontinuity in\n    a curve object.\n    Parameters:\n      curve_id (guid): identifier of curve object\n      style (number): The type of continuity to test for. The types of\n          continuity are as follows:\n          Value    Description\n          1        C0 - Continuous function\n          2        C1 - Continuous first derivative\n          3        C2 - Continuous first and second derivative\n          4        G1 - Continuous unit tangent\n          5        G2 - Continuous unit tangent and curvature\n    Returns:\n      list(point, ...): 3D points where the curve is discontinuous\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.IsCurve(curve):\n          points = rs.CurveDiscontinuity(curve, 2)\n          if points: rs.AddPoints( points )\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    dom = curve.Domain\n    t0 = dom.Min\n    t1 = dom.Max\n    points = []\n    get_next = True\n    while get_next:\n        get_next, t = curve.GetNextDiscontinuity(System.Enum.ToObject(Rhino.Geometry.Continuity, style), t0, t1)\n        if get_next:\n            points.append(curve.PointAt(t))\n            t0 = t # Advance to the next parameter\n    return points\n\n\ndef CurveDomain(curve_id, segment_index=-1):\n    \"\"\"Returns the domain of a curve object\n    as an indexable object with two elements.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve.\n    Returns:\n      list(number, number): the domain of the curve if successful.\n         [0] Domain minimum\n         [1] Domain maximum\n      None: on error\n\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          domain = rs.CurveDomain(obj)\n          print \"Curve domain:\", domain[0], \"to\", domain[1]\n    See Also:\n      CurveDegree\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.Domain\n\n\ndef CurveEditPoints(curve_id, return_parameters=False, segment_index=-1):\n    \"\"\"Returns the edit, or Greville, points of a curve object. \n    For each curve control point, there is a corresponding edit point.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      return_parameters (bool, optional): if True, return as a list of curve parameters.\n                                          If False, return as a list of 3d points\n      segment_index (number, optional): the curve segment index is `curve_id` identifies a polycurve\n    Returns:\n      list(point, ....): curve edit points on success\n      None on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          points = rs.CurveEditPoints(obj)\n          if points: rs.AddPointCloud( points )\n    See Also:\n      IsCurve\n      CurvePointCount\n      CurvePoints\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if not nc: return scriptcontext.errorhandler()\n    if return_parameters: return nc.GrevilleParameters()\n    return list(nc.GrevillePoints())\n\n\ndef CurveEndPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the end point of a curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: The 3d endpoint of the curve if successful.\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          point = rs.CurveEndPoint(object)\n          rs.AddPoint(point)\n    See Also:\n      CurveMidPoint\n      CurveStartPoint\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.PointAtEnd\n\n\ndef CurveFilletPoints(curve_id_0, curve_id_1, radius=1.0, base_point_0=None, base_point_1=None, return_points=True):\n    \"\"\"Find points at which to cut a pair of curves so that a fillet of a\n    specified radius fits. A fillet point is a pair of points (point0, point1)\n    such that there is a circle of radius tangent to curve curve0 at point0 and\n    tangent to curve curve1 at point1. Of all possible fillet points, this\n    function returns the one which is the closest to the base point base_point_0,\n    base_point_1. Distance from the base point is measured by the sum of arc\n    lengths along the two curves. \n    Parameters:\n      curve_id_0 (guid): identifier of the first curve object.\n      curve_id_1 (guid): identifier of the second curve object.\n      radius (number, optional): The fillet radius. If omitted, a radius\n                     of 1.0 is specified.\n      base_point_0 (point, optional): The base point on the first curve.\n                     If omitted, the starting point of the curve is used.\n      base_point_1 (point, optional): The base point on the second curve. If omitted,\n                     the starting point of the curve is used.\n      return_points (bool, optional): If True (Default), then fillet points are\n                     returned. Otherwise, a fillet curve is created and\n                     it's identifier is returned.\n    Returns:\n      list(point, point, point, vector, vector, vector): If return_points is True, then a list of point and vector values\n      if successful. The list elements are as follows:\n          [0]    A point on the first curve at which to cut (point).\n          [1]    A point on the second curve at which to cut (point).\n          [2]    The fillet plane's origin (point). This point is also\n                   the center point of the fillet\n          [3]    The fillet plane's X axis (vector).\n          [4]    The fillet plane's Y axis (vector).\n          [5]    The fillet plane's Z axis (vector).\n      \n      guid: If return_points is False, then the identifier of the fillet curve\n            if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve0 = rs.AddLine([0,0,0], [5,1,0])\n      curve1 = rs.AddLine([0,0,0], [1,5,0])\n      fillet = rs.CurveFilletPoints(curve0, curve1)\n      if fillet:\n          rs.AddPoint( fillet[0] )\n          rs.AddPoint( fillet[1] )\n          rs.AddPoint( fillet[2] )\n    See Also:\n      AddFilletCurve\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    t0_base = curve0.Domain.Min\n    \n    if base_point_0:\n        rc = curve0.ClosestPoint(base_point_0, t0_base)\n        if not rc[0]: return scriptcontext.errorhandler()\n    \n    t1_base = curve1.Domain.Min\n    if base_point_1:\n        rc = curve1.ClosestPoint(base_point_1, t1_base)\n        if not rc[0]: return scriptcontext.errorhandler()\n\n    r = radius if (radius and radius>0) else 1.0\n    rc = Rhino.Geometry.Curve.GetFilletPoints(curve0, curve1, r, t0_base, t1_base)\n    if rc[0]:\n        point_0 = curve0.PointAt(rc[1])\n        point_1 = curve1.PointAt(rc[2])\n        return point_0, point_1, rc[3].Origin, rc[3].XAxis, rc[3].YAxis, rc[3].ZAxis\n    return scriptcontext.errorhandler()\n\n\ndef CurveFrame(curve_id, parameter, segment_index=-1):\n    \"\"\"Returns the plane at a parameter of a curve. The plane is based on the\n    tangent and curvature vectors at a parameter.\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n      parameter (number): parameter to evaluate.\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      plane: The plane at the specified parameter if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetCurveObject(\"Select a curve\")\n      if curve:\n          plane = rs.CurveFrame(curve[0], curve[4])\n          rs.AddPlaneSurface(plane, 5.0, 3.0)\n    See Also:\n      CurvePerpFrame\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    domain = curve.Domain\n    if not domain.IncludesParameter(parameter):\n        tol = scriptcontext.doc.ModelAbsoluteTolerance\n        if parameter>domain.Max and (parameter-domain.Max)<=tol:\n            parameter = domain.Max\n        elif parameter<domain.Min and (domain.Min-parameter)<=tol:\n            parameter = domain.Min\n        else:\n            return scriptcontext.errorhandler()\n    rc, frame = curve.FrameAt(parameter)\n    if rc and frame.IsValid: return frame\n    return scriptcontext.errorhandler()\n\n\ndef CurveKnotCount(curve_id, segment_index=-1):\n    \"\"\"Returns the knot count of a curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n      segment_index (number, optional): the curve segment if `curve_id` identifies a polycurve.\n    Returns:\n      number: The number of knots if successful.\n      None: if not successful or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          count = rs.CurveKnotCount(obj)\n          print \"Curve knot count:\", count\n    See Also:\n      DivideCurve\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if not nc: return scriptcontext.errorhandler()\n    return nc.Knots.Count\n\n\ndef CurveKnots(curve_id, segment_index=-1):\n    \"\"\"Returns the knots, or knot vector, of a curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve.\n    Returns:\n      list(number, ....): knot values if successful.\n      None: if not successful or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          knots = rs.CurveKnots(obj)\n          if knots:\n              for knot in knots: print \"Curve knot value:\", knot\n    See Also:\n      CurveKnotCount\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if not nc: return scriptcontext.errorhandler()\n    rc = [nc.Knots[i] for i in range(nc.Knots.Count)]\n    return rc\n\n\ndef CurveLength(curve_id, segment_index=-1, sub_domain=None):\n    \"\"\"Returns the length of a curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n      sub_domain ([number, number], optional): list of two numbers identifying the sub-domain of the\n          curve on which the calculation will be performed. The two parameters\n          (sub-domain) must be non-decreasing. If omitted, the length of the\n          entire curve is returned.\n    Returns:\n      number: The length of the curve if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          length = rs.CurveLength(object)\n          print \"Curve length:\", length\n    See Also:\n      CurveDomain\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    if sub_domain:\n        if len(sub_domain)==2:\n            dom = Rhino.Geometry.Interval(sub_domain[0], sub_domain[1])\n            return curve.GetLength(dom)\n        return scriptcontext.errorhandler()\n    return curve.GetLength()\n\n\ndef CurveMidPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the mid point of a curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: The 3D midpoint of the curve if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          point = rs.CurveMidPoint(pbject)\n          rs.AddPoint( point )\n    See Also:\n      CurveEndPoint\n      CurveStartPoint\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, t = curve.NormalizedLengthParameter(0.5)\n    if rc: return curve.PointAt(t)\n    return scriptcontext.errorhandler()\n\n\ndef CurveNormal(curve_id, segment_index=-1):\n    \"\"\"Returns the normal direction of the plane in which a planar curve object lies.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment if curve_id identifies a polycurve\n    Returns:\n      vector: The 3D normal vector if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a planar curve\")\n      if rs.IsCurve(object) and rs.IsCurvePlanar(object):\n          normal = rs.CurveNormal(object)\n          if normal: print \"Curve Normal:\", normal\n    See Also:\n      IsCurve\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, plane = curve.TryGetPlane(tol)\n    if rc: return plane.Normal\n    return scriptcontext.errorhandler()\n\n\ndef CurveNormalizedParameter(curve_id, parameter):\n    \"\"\"Converts a curve parameter to a normalized curve parameter;\n    one that ranges between 0-1\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): the curve parameter to convert\n    Returns:\n      number: normalized curve parameter\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\")\n      if rs.IsCurve(obj):\n          domain = rs.CurveDomain(obj)\n          parameter = (domain[0]+domain[1])/2.0\n          print \"Curve parameter:\", parameter\n          normalized = rs.CurveNormalizedParameter(obj, parameter)\n          print \"Normalized parameter:\", normalized\n    See Also:\n      CurveDomain\n      CurveParameter\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    return curve.Domain.NormalizedParameterAt(parameter)\n\n\ndef CurveParameter(curve_id, parameter):\n    \"\"\"Converts a normalized curve parameter to a curve parameter;\n    one within the curve's domain\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): the normalized curve parameter to convert\n    Returns:\n      number: curve parameter\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\")\n      if rs.IsCurve(obj):\n          normalized = 0.5\n          print \"Normalized parameter:\", normalized\n          parameter = rs.CurveParameter(obj, normalized)\n          print \"Curve parameter:\", parameter\n    See Also:\n      CurveDomain\n      CurveNormalizedParameter\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    return curve.Domain.ParameterAt(parameter)\n\n\ndef CurvePerpFrame(curve_id, parameter):\n    \"\"\"Returns the perpendicular plane at a parameter of a curve. The result\n    is relatively parallel (zero-twisting) plane\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): parameter to evaluate\n    Returns:\n      plane: Plane on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      crv = rs.GetCurveObject(\"Select a curve\")\n      if crv:\n          plane = rs.CurvePerpFrame(crv[0], crv[4])\n          rs.AddPlaneSurface( plane, 1, 1 )\n    See Also:\n      CurveFrame\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    parameter = float(parameter)\n    rc, plane = curve.PerpendicularFrameAt(parameter)\n    if rc: return plane\n\n\ndef CurvePlane(curve_id, segment_index=-1):\n    \"\"\"Returns the plane in which a planar curve lies. Note, this function works\n    only on planar curves.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      plane: The plane in which the curve lies if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.IsCurvePlanar(curve):\n          plane = rs.CurvePlane(curve)\n          rs.ViewCPlane(None, plane)\n    See Also:\n      IsCurve\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, plane = curve.TryGetPlane(tol)\n    if rc: return plane\n    return scriptcontext.errorhandler()\n\n\ndef CurvePointCount(curve_id, segment_index=-1):\n    \"\"\"Returns the control points count of a curve object.\n    Parameters:\n      curve_id (guid) identifier of the curve object\n      segment_index (number, optional): the curve segment if `curve_id` identifies a polycurve\n    Returns:\n      number: Number of control points if successful.\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          count = rs.CurvePointCount(obj)\n          print \"Curve point count:\", count\n    See Also:\n      DivideCurve\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if nc: return nc.Points.Count\n    return scriptcontext.errorhandler()\n\n\ndef CurvePoints(curve_id, segment_index=-1):\n    \"\"\"Returns the control points, or control vertices, of a curve object.\n    If the curve is a rational NURBS curve, the euclidean control vertices\n    are returned.\n    Parameters:\n      curve_id (guid): the object's identifier\n      segment_index (number, optional): the curve segment if `curve_id` identifies a polycurve\n    Returns:\n      list(point, ...): the control points, or control vertices, of a curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          points = rs.CurvePoints(obj)\n          if points: [rs.AddPoint(pt) for pt in points]\n    See Also:\n      CurvePointCount\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if nc is None: return scriptcontext.errorhandler()\n    points = [nc.Points[i].Location for i in xrange(nc.Points.Count)]\n    return points\n\n\ndef CurveRadius(curve_id, test_point, segment_index=-1):\n    \"\"\"Returns the radius of curvature at a point on a curve.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      test_point (point): sampling point\n      segment_index (number, optional): the curve segment if curve_id identifies a polycurve\n    Returns:\n      number: The radius of curvature at the point on the curve if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          point = rs.GetPointOnCurve(obj, \"Pick a test point\")\n          if point:\n              radius = rs.CurveRadius(obj, point)\n              print \"Radius of curvature:\", radius\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    point = rhutil.coerce3dpoint(test_point, True)\n    rc, t = curve.ClosestPoint(point, 0.0)\n    if not rc: return scriptcontext.errorhandler()\n    v = curve.CurvatureAt( t )\n    k = v.Length\n    if k>Rhino.RhinoMath.ZeroTolerance: return 1/k\n    return scriptcontext.errorhandler()\n\n\ndef CurveSeam(curve_id, parameter):\n    \"\"\"Adjusts the seam, or start/end, point of a closed curve.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): The parameter of the new start/end point.\n                  Note, if successful, the resulting curve's\n                  domain will start at `parameter`.\n    Returns:\n      bool: True or False indicating success or failure.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select closed curve\", rs.filter.curve)\n      if rs.IsCurveClosed(obj):\n          domain = rs.CurveDomain(obj)\n          parameter = (domain[0] + domain[1])/2.0\n          rs.CurveSeam( obj, parameter )\n    See Also:\n      IsCurve\n      IsCurveClosed\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if (not curve.IsClosed or not curve.Domain.IncludesParameter(parameter)):\n        return False\n    dupe = curve.Duplicate()\n    if dupe:\n        dupe.ChangeClosedCurveSeam(parameter)\n        curve_id = rhutil.coerceguid(curve_id)\n        dupe_obj = scriptcontext.doc.Objects.Replace(curve_id, dupe)\n        return dupe_obj is not None\n    return False\n\n\ndef CurveStartPoint(curve_id, segment_index=-1, point=None):\n    \"\"\"Returns the start point of a curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n      point (point, optional): new start point\n    Returns:\n      point: The 3D starting point of the curve if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          point = rs.CurveStartPoint(object)\n          rs.AddPoint(point)\n    See Also:\n      CurveEndPoint\n      CurveMidPoint\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc = curve.PointAtStart\n    if point:\n        point = rhutil.coerce3dpoint(point, True)\n        if point and curve.SetStartPoint(point):\n            curve_id = rhutil.coerceguid(curve_id, True)\n            scriptcontext.doc.Objects.Replace(curve_id, curve)\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef CurveSurfaceIntersection(curve_id, surface_id, tolerance=-1, angle_tolerance=-1):\n    \"\"\"Calculates intersection of a curve object with a surface object.\n    Note, this function works on the untrimmed portion of the surface.\n    Parameters:\n      curve_id (guid): The identifier of the first curve object.\n      surface_id (guid): The identifier of the second curve object. If omitted,\n          the a self-intersection test will be performed on curve.\n      tolerance (number, optional): The absolute tolerance in drawing units. If omitted,\n          the document's current absolute tolerance is used.\n      angle_tolerance (number, optional) angle tolerance in degrees. The angle\n          tolerance is used to determine when the curve is tangent to the\n          surface. If omitted, the document's current angle tolerance is used.\n    Returns:\n      list(list(point, point, point, point, number, number, number, number, number, number), ...): of intersection information if successful.\n      The list will contain one or more of the following elements:\n        Element Type     Description\n        [n][0]  Number   The intersection event type, either Point(1) or Overlap(2).\n        [n][1]  Point3d  If the event type is Point(1), then the intersection point\n                         on the first curve. If the event type is Overlap(2), then\n                         intersection start point on the first curve.\n        [n][2]  Point3d  If the event type is Point(1), then the intersection point\n                         on the first curve. If the event type is Overlap(2), then\n                         intersection end point on the first curve.\n        [n][3]  Point3d  If the event type is Point(1), then the intersection point\n                         on the second curve. If the event type is Overlap(2), then\n                         intersection start point on the surface.\n        [n][4]  Point3d  If the event type is Point(1), then the intersection point\n                         on the second curve. If the event type is Overlap(2), then\n                         intersection end point on the surface.\n        [n][5]  Number   If the event type is Point(1), then the first curve parameter.\n                         If the event type is Overlap(2), then the start value of the\n                         first curve parameter range.\n        [n][6]  Number   If the event type is Point(1), then the first curve parameter.\n                         If the event type is Overlap(2), then the end value of the\n                         curve parameter range.\n        [n][7]  Number   If the event type is Point(1), then the U surface parameter.\n                         If the event type is Overlap(2), then the U surface parameter\n                         for curve at (n, 5).\n        [n][8]  Number   If the event type is Point(1), then the V surface parameter.\n                         If the event type is Overlap(2), then the V surface parameter\n                         for curve at (n, 5).\n        [n][9]  Number   If the event type is Point(1), then the U surface parameter.\n                         If the event type is Overlap(2), then the U surface parameter\n                         for curve at (n, 6).\n        [n][10] Number   If the event type is Point(1), then the V surface parameter.\n                         If the event type is Overlap(2), then the V surface parameter\n                         for curve at (n, 6).\n    Example:\n      import rhinoscriptsyntax as rs\n      def csx():\n          curve = rs.GetObject(\"Select curve\", rs.filter.curve)\n          if curve is None: return\n          surface = rs.GetObject(\"Select surface\", rs.filter.surface)\n          if surface is None: return\n          intersection_list = rs.CurveSurfaceIntersection(curve, surface)\n          if intersection_list is None:\n              print \"Curve and surface do not intersect.\"\n              return\n          for intersection in intersection_list:\n              if intersection[0]==1:\n                  print \"Point\"\n                  print \"Intersection point on curve:\", intersection[1]\n                  print \"Intersection point on surface:\", intersection[3]\n                  print \"Curve parameter:\", intersection[5]\n                  print \"Surface parameter:\", intersection[7], \",\", intersection[8]\n              else:\n                  print \"Overlap\"\n                  print \"Intersection start point on curve:\", intersection[1]\n                  print \"Intersection end point on curve:\", intersection[2]\n                  print \"Intersection start point on surface:\", intersection[3]\n                  print \"Intersection end point on surface:\", intersection[4]\n                  print \"Curve parameter range:\", intersection[5], \"to\", intersection[6]\n                  print \"Surface parameter range:\", intersection[7], \",\", intersection[8], \"to\", intersection[9], \",\", intersection[10]\n      csx()\n    See Also:\n      CurveCurveIntersection\n      CurveBrepIntersect\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    surface = rhutil.coercesurface(surface_id, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if angle_tolerance is None or angle_tolerance<0:\n        angle_tolerance = scriptcontext.doc.ModelAngleToleranceRadians\n    else:\n        angle_tolerance = math.radians(angle_tolerance)\n    rc = Rhino.Geometry.Intersect.Intersection.CurveSurface(curve, surface, tolerance, angle_tolerance)\n    if rc:\n        events = []\n        for i in xrange(rc.Count):\n            event_type = 2 if rc[i].IsOverlap else 1\n            item = rc[i]\n            oa = item.OverlapA\n            u,v = item.SurfaceOverlapParameter()\n            e = (event_type, item.PointA, item.PointA2, item.PointB, item.PointB2, oa[0], oa[1], u[0], u[1], v[0], v[1])\n            events.append(e)\n        return events\n\n\ndef CurveTangent(curve_id, parameter, segment_index=-1):\n    \"\"\"Returns a 3D vector that is the tangent to a curve at a parameter.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number) parameter to evaluate\n      segment_index (number, optional) the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      vector: A 3D vector if successful.\n      None: on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if obj:\n          point = rs.GetPointOnCurve(obj)\n          if point:\n              param = rs.CurveClosestPoint(obj, point)\n              normal = rs.CurveTangent(obj, param)\n              print normal\n    See Also:\n      CurveClosestPoint\n      CurveDomain\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc = Rhino.Geometry.Point3d.Unset\n    if curve.Domain.IncludesParameter(parameter):\n        return curve.TangentAt(parameter)\n    return scriptcontext.errorhandler()\n\n\ndef CurveWeights(curve_id, segment_index=-1):\n    \"\"\"Returns list of weights that are assigned to the control points of a curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The weight values of the curve if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          weights = rs.CurveWeights(obj)\n          if weights:\n              for weight in weights:\n                  print \"Curve control point weight value:\", weight\n    See Also:\n      CurveKnots\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve\n    if type(curve) is not Rhino.Geometry.NurbsCurve:\n        nc = curve.ToNurbsCurve()\n    if nc is None: return scriptcontext.errorhandler()\n    return [pt.Weight for pt in nc.Points]\n\n\ndef DivideCurve(curve_id, segments, create_points=False, return_points=True):\n    \"\"\"Divides a curve object into a specified number of segments.\n    Parameters:\n      curve_id (guid):identifier of the curve object\n      segments (number): The number of segments.\n      create_points (bool, optional): Create the division points. If omitted or False,\n          points are not created.\n      return_points (bool, optional): If omitted or True, points are returned.\n          If False, then a list of curve parameters are returned.\n    Returns:\n      list(point|number, ...): If `return_points` is not specified or True, then a list containing 3D division points.\n      list(point|number, ...): If `return_points` is False, then an array containing division curve parameters.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if obj:\n          points = rs.DivideCurve(obj, 4)\n          for point in points: rs.AddPoint(point)\n    See Also:\n      DivideCurveEquidistant\n      DivideCurveLength\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc = curve.DivideByCount(segments, True)\n    if not rc: return scriptcontext.errorhandler()\n    if return_points or create_points:\n        outputpoints = [curve.PointAt(t) for t in rc]\n        if return_points: rc = outputpoints\n        if create_points:\n            for point in outputpoints:\n                if point.IsValid: scriptcontext.doc.Objects.AddPoint(point)\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef DivideCurveEquidistant(curve_id, distance, create_points=False, return_points=True):\n    \"\"\"Divides a curve such that the linear distance between the points is equal.\n    Parameters:\n      curve_id (guid): the object's identifier\n      distance (number): linear distance between division points\n      create_points (bool, optional): create the division points if True.\n      return_points (bool, optional): If True, return a list of points.\n                                      If False, return a list of curve parameters\n    Returns:\n      list(point|number, ...): points or curve parameters based on the value of return_points\n      none on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if obj:\n          points = rs.DivideCurveEquidistant(obj, 4, True)\n    See Also:\n      DivideCurve\n      DivideCurveLength\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    points = curve.DivideEquidistant(distance)\n    if not points: return scriptcontext.errorhandler()\n    if create_points:\n        for point in points: scriptcontext.doc.Objects.AddPoint(point)\n        scriptcontext.doc.Views.Redraw()\n    if return_points: return points\n    tvals = []\n    for point in points:\n        rc, t = curve.ClosestPoint(point)\n        tvals.append(t)\n    return tvals\n\n\ndef DivideCurveLength(curve_id, length, create_points=False, return_points=True):\n    \"\"\"Divides a curve object into segments of a specified length.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      length (number): The length of each segment.\n      create_points (bool, optional): Create the division points. If omitted or False,\n          points are not created.\n      return_points (bool, optional): If omitted or True, points are returned.\n          If False, then a list of curve parameters are returned.\n    Returns:\n      list(point, ...): If return_points is not specified or True, then a list containing division points.\n      list(number, ...): If return_points is False, then an array containing division curve parameters.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          length = rs.CurveLength(obj) / 4\n          points = rs.DivideCurveLength(obj, length)\n          for point in points: rs.AddPoint(point)\n    See Also:\n      DivideCurve\n      DivideCurveEquidistant\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc = curve.DivideByLength(length, True)\n    if not rc: return scriptcontext.errorhandler()\n    if return_points or create_points:\n        outputpoints = [curve.PointAt(t) for t in rc]\n        if create_points:\n            for point in outputpoints:\n                if (point.IsValid): scriptcontext.doc.Objects.AddPoint(point)\n        if return_points: rc = outputpoints\n    return rc\n\n\ndef EllipseCenterPoint(curve_id):\n    \"\"\"Returns the center point of an elliptical-shaped curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n    Returns:\n      point: The 3D center point of the ellipse if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select ellipse\")\n      if rs.IsEllipse(obj):\n          point = rs.EllipseCenterPoint(obj)\n          rs.AddPoint( point )\n    See Also:\n      IsEllipse\n      EllipseQuadPoints\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc, ellipse = curve.TryGetEllipse()\n    if not rc: raise ValueError(\"curve is not an ellipse\")\n    return ellipse.Plane.Origin\n\n\ndef EllipseQuadPoints(curve_id):\n    \"\"\"Returns the quadrant points of an elliptical-shaped curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n    Returns:\n      list(point, point, point, point): Four points identifying the quadrants of the ellipse\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select ellipse\")\n      if rs.IsEllipse(obj):\n          rs.AddPoints( rs.EllipseQuadPoints(obj) )\n    See Also:\n      IsEllipse\n      EllipseCenterPoint\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc, ellipse = curve.TryGetEllipse()\n    if not rc: raise ValueError(\"curve is not an ellipse\")\n    origin = ellipse.Plane.Origin;\n    xaxis = ellipse.Radius1 * ellipse.Plane.XAxis;\n    yaxis = ellipse.Radius2 * ellipse.Plane.YAxis;\n    return (origin-xaxis, origin+xaxis, origin-yaxis, origin+yaxis)\n\n\ndef EvaluateCurve(curve_id, t, segment_index=-1):\n    \"\"\"Evaluates a curve at a parameter and returns a 3D point\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      t (number): the parameter to evaluate\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: a 3-D point if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          domain = rs.CurveDomain(obj)\n          t = domain[1]/2.0\n          point = rs.EvaluateCurve(obj, t)\n          rs.AddPoint( point )\n    See Also:\n      CurveClosestPoint\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.PointAt(t)\n\n\ndef ExplodeCurves(curve_ids, delete_input=False):\n    \"\"\"Explodes, or un-joins, one curves. Polycurves will be exploded into curve\n    segments. Polylines will be exploded into line segments. ExplodeCurves will\n    return the curves in topological order. \n    Parameters:\n      curve_ids (guid): the curve object(s) to explode.\n      delete_input (bool, optional): Delete input objects after exploding if True.\n    Returns:\n      list(guid, ...): identifying the newly created curve objects\n    Example:\n      import rhinoscriptsyntax as rs\n      crv = rs.GetObject(\"Select curve to explode\", rs.filter.curve)\n      if rs.IsCurve(crv): rs.ExplodeCurves(crv)\n    See Also:\n      IsCurve\n      IsPolyCurve\n      IsPolyline\n      JoinCurves\n    \"\"\"\n    if( type(curve_ids) is list or type(curve_ids) is tuple ): pass\n    else: curve_ids = [curve_ids]\n    rc = []\n    for id in curve_ids:\n        curve = rhutil.coercecurve(id, -1, True)\n        pieces = curve.DuplicateSegments()\n        if pieces:\n            for piece in pieces:\n                rc.append(scriptcontext.doc.Objects.AddCurve(piece))\n            if delete_input:\n                id = rhutil.coerceguid(id, True)\n                scriptcontext.doc.Objects.Delete(id, True)\n    if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ExtendCurve(curve_id, extension_type, side, boundary_object_ids):\n    \"\"\"Extends a non-closed curve object by a line, arc, or smooth extension\n    until it intersects a collection of objects.\n    Parameters:\n      curve_id (guid): identifier of curve to extend\n      extension_type (number):\n        0 = line\n        1 = arc\n        2 = smooth\n      side (number):\n        0=extend from the start of the curve\n        1=extend from the end of the curve\n        2=extend from both the start and the end of the curve\n      boundary_object_ids (guid): curve, surface, and polysurface objects to extend to\n    Returns:\n      guid: The identifier of the new object if successful.\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      filter = rs.filter.curve | rs.filter.surface | rs.filter.polysurface\n      objects = rs.GetObjects(\"Select boundary objects\", filter)\n      if objects:\n          curve = rs.GetObject(\"Select curve to extend\", rs.filter.curve)\n          if curve: rs.ExtendCurve( curve, 2, 1, objects )\n    See Also:\n      ExtendCurveLength\n      ExtendCurvePoint\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if extension_type==0: extension_type = Rhino.Geometry.CurveExtensionStyle.Line\n    elif extension_type==1: extension_type = Rhino.Geometry.CurveExtensionStyle.Arc\n    elif extension_type==2: extension_type = Rhino.Geometry.CurveExtensionStyle.Smooth\n    else: raise ValueError(\"extension_type must be 0, 1, or 2\")\n    \n    if side==0: side = Rhino.Geometry.CurveEnd.Start\n    elif side==1: side = Rhino.Geometry.CurveEnd.End\n    elif side==2: side = Rhino.Geometry.CurveEnd.Both\n    else: raise ValueError(\"side must be 0, 1, or 2\")\n    \n    rhobjs = [rhutil.coercerhinoobject(id) for id in boundary_object_ids]\n    if not rhobjs: raise ValueError(\"boundary_object_ids must contain at least one item\")\n    geometry = [obj.Geometry for obj in rhobjs]\n    newcurve = curve.Extend(side, extension_type, geometry)\n    if newcurve and newcurve.IsValid:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        if scriptcontext.doc.Objects.Replace(curve_id, newcurve):\n            scriptcontext.doc.Views.Redraw()\n            return curve_id\n    return scriptcontext.errorhandler()\n\n\ndef ExtendCurveLength(curve_id, extension_type, side, length):\n    \"\"\"Extends a non-closed curve by a line, arc, or smooth extension for a\n    specified distance\n    Parameters:\n      curve_id (guid): curve to extend\n      extension_type (number):\n        0 = line\n        1 = arc\n        2 = smooth\n      side (number):\n        0=extend from start of the curve\n        1=extend from end of the curve\n        2=Extend from both ends\n      length (number): distance to extend\n    Returns:\n      guid: The identifier of the new object\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select curve to extend\", rs.filter.curve)\n      if curve:\n          length = rs.GetReal(\"Length to extend\", 3.0)\n          if length: rs.ExtendCurveLength( curve, 2, 2, length )\n    See Also:\n      ExtendCurve\n      ExtendCurvePoint\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if extension_type==0: extension_type = Rhino.Geometry.CurveExtensionStyle.Line\n    elif extension_type==1: extension_type = Rhino.Geometry.CurveExtensionStyle.Arc\n    elif extension_type==2: extension_type = Rhino.Geometry.CurveExtensionStyle.Smooth\n    else: raise ValueError(\"extension_type must be 0, 1, or 2\")\n    \n    if side==0: side = Rhino.Geometry.CurveEnd.Start\n    elif side==1: side = Rhino.Geometry.CurveEnd.End\n    elif side==2: side = Rhino.Geometry.CurveEnd.Both\n    else: raise ValueError(\"side must be 0, 1, or 2\")\n    newcurve = None\n    if length<0: newcurve = curve.Trim(side, -length)\n    else: newcurve = curve.Extend(side, length, extension_type)\n    if newcurve and newcurve.IsValid:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        if scriptcontext.doc.Objects.Replace(curve_id, newcurve):\n            scriptcontext.doc.Views.Redraw()\n            return curve_id\n    return scriptcontext.errorhandler()\n\n\ndef ExtendCurvePoint(curve_id, side, point):\n    \"\"\"Extends a non-closed curve by smooth extension to a point\n    Parameters:\n      curve_id (guid): curve to extend\n      side (number):\n        0=extend from start of the curve\n        1=extend from end of the curve\n      point (guid|point): point to extend to\n    Returns:\n      guid: The identifier of the new object if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select curve to extend\", rs.filter.curve)\n      if curve:\n          point = rs.GetPoint(\"Point to extend to\")\n          if point: rs.ExtendCurvePoint(curve, 1, point)\n    See Also:\n      ExtendCurve\n      ExtendCurveLength\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    point = rhutil.coerce3dpoint(point, True)\n    \n    if side==0: side = Rhino.Geometry.CurveEnd.Start\n    elif side==1: side = Rhino.Geometry.CurveEnd.End\n    elif side==2: side = Rhino.Geometry.CurveEnd.Both\n    else: raise ValueError(\"side must be 0, 1, or 2\")\n    \n    extension_type = Rhino.Geometry.CurveExtensionStyle.Smooth\n    newcurve = curve.Extend(side, extension_type, point)\n    if newcurve and newcurve.IsValid:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        if scriptcontext.doc.Objects.Replace( curve_id, newcurve ):\n            scriptcontext.doc.Views.Redraw()\n            return curve_id\n    return scriptcontext.errorhandler()\n\n\ndef FairCurve(curve_id, tolerance=1.0):\n    \"\"\"Fairs a curve. Fair works best on degree 3 (cubic) curves. Fair attempts\n    to remove large curvature variations while limiting the geometry changes to\n    be no more than the specified tolerance. Sometimes several applications of\n    this method are necessary to remove nasty curvature problems.\n    Parameters:\n      curve_id (guid): curve to fair\n      tolerance (number, optional): fairing tolerance\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      curves = rs.GetObjects(\"Select curves to fair\", rs.filter.curve)\n      if curves:\n          [rs.FairCurve(curve) for curve in curves]\n    See Also:\n      \n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    angle_tol = 0.0\n    clamp = 0\n    if curve.IsPeriodic:\n        curve = curve.ToNurbsCurve()\n        clamp = 1\n    newcurve = curve.Fair(tolerance, angle_tol, clamp, clamp, 100)\n    if not newcurve: return False\n    curve_id = rhutil.coerceguid(curve_id, True)\n    if scriptcontext.doc.Objects.Replace(curve_id, newcurve):\n        scriptcontext.doc.Views.Redraw()\n        return True\n    return False\n\n\ndef FitCurve(curve_id, degree=3, distance_tolerance=-1, angle_tolerance=-1):\n    \"\"\"Reduces number of curve control points while maintaining the curve's same\n    general shape. Use this function for replacing curves with many control\n    points. For more information, see the Rhino help for the FitCrv command.\n    Parameters:\n      curve_id (guid): Identifier of the curve object\n      degree (number, optional): The curve degree, which must be greater than 1.\n                     The default is 3.\n      distance_tolerance (number, optional): The fitting tolerance. If distance_tolerance\n          is not specified or <= 0.0, the document absolute tolerance is used.\n      angle_tolerance (number, optional): The kink smoothing tolerance in degrees. If\n          angle_tolerance is 0.0, all kinks are smoothed. If angle_tolerance\n          is > 0.0, kinks smaller than angle_tolerance are smoothed. If\n          angle_tolerance is not specified or < 0.0, the document angle\n          tolerance is used for the kink smoothing.\n    Returns:\n      guid: The identifier of the new object\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      oldCurve = rs.GetObject(\"Select curve to fit\", rs.filter.curve)\n      if oldCurve:\n          newCurve = rs.FitCurve(oldCurve)\n          if newCurve: rs.DeleteObject(oldCurve)\n    See Also:\n      \n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if distance_tolerance is None or distance_tolerance<0:\n        distance_tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if angle_tolerance is None or angle_tolerance<0:\n        angle_tolerance = scriptcontext.doc.ModelAngleToleranceRadians\n    nc = curve.Fit(degree, distance_tolerance, angle_tolerance)\n    if nc:\n        rhobj = rhutil.coercerhinoobject(curve_id)\n        rc = None\n        if rhobj:\n            rc = scriptcontext.doc.Objects.AddCurve(nc, rhobj.Attributes)\n        else:\n            rc = scriptcontext.doc.Objects.AddCurve(nc)\n        if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n        scriptcontext.doc.Views.Redraw()\n        return rc\n    return scriptcontext.errorhandler()\n\n\ndef InsertCurveKnot(curve_id, parameter, symmetrical=False ):\n    \"\"\"Inserts a knot into a curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): parameter on the curve\n      symmetrical (bool, optional): if True, then knots are added on both sides of\n          the center of the curve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve for knot insertion\", rs.filter.curve)\n      if obj:\n          point = rs.GetPointOnCurve(obj, \"Point on curve to add knot\")\n          if point:\n              parameter = rs.CurveClosestPoint(obj, point)\n              rs.InsertCurveKnot( obj, parameter )\n    See Also:\n      CurveKnotCount\n      CurveKnots\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if not curve.Domain.IncludesParameter(parameter): return False\n    nc = curve.ToNurbsCurve()\n    if not nc: return False\n    rc, t = curve.GetNurbsFormParameterFromCurveParameter(parameter)\n    if rc:\n        rc = nc.Knots.InsertKnot(t,1)\n        if rc and symmetrical:\n            domain = nc.Domain\n            t_sym = domain.T1 - t + domain.T0\n            if abs(t_sym)>Rhino.RhinoMath.SqrtEpsilon:\n                rc = nc.Knots.InsertKnot(t_sym,1)\n        if rc:\n            curve_id = rhutil.coerceguid(curve_id)\n            rc = scriptcontext.doc.Objects.Replace(curve_id, nc)\n            if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef IsArc(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is an open arc curve\n    Parameters:\n      curve_id (guid): Identifier of the curve object\n      segment_index (number): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select an arc\")\n      if rs.IsArc(obj):\n          print \"The object is an arc.\"\n      else:\n          print \"The object is not an arc.\"\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcCenterPoint\n      ArcMidPoint\n      ArcRadius\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.IsArc() and not curve.IsClosed\n\n\ndef IsCircle(curve_id, tolerance=None):\n    \"\"\"Verifies an object is a circle curve\n    Parameters:\n      curve_id (guid): Identifier of the curve object\n      tolerance (number, optional) If the curve is not a circle, then the tolerance used\n        to determine whether or not the NURBS form of the curve has the\n        properties of a circle. If omitted, Rhino's internal zero tolerance is used\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a circle\")\n      if rs.IsCircle(obj):\n          print \"The object is a circle.\"\n      else:\n          print \"The object is not a circle.\"\n    See Also:\n      AddCircle\n      AddCircle3Pt\n      CircleCenterPoint\n      CircleCircumference\n      CircleRadius\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if tolerance is None or tolerance < 0:\n        tolerance = Rhino.RhinoMath.ZeroTolerance\n    return curve.IsCircle(tolerance)\n\n\ndef IsCurve(object_id):\n    \"\"\"Verifies an object is a curve\n    Parameters:\n      object_id (guid): the object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          print \"The object is a curve.\"\n      else:\n          print \"The object is not a curve.\"\n    See Also:\n      IsCurveClosed\n      IsCurveLinear\n      IsCurvePeriodic\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(object_id)\n    return curve is not None\n\n\ndef IsCurveClosable(curve_id, tolerance=None):\n    \"\"\"Decide if it makes sense to close off the curve by moving the end point\n    to the start point based on start-end gap size and length of curve as\n    approximated by chord defined by 6 points\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      tolerance[opt] = maximum allowable distance between start point and end\n        point. If omitted, the document's current absolute tolerance is used\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      crv = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if not rs.IsCurveClosed(crv) and rs.IsCurveClosable(crv):\n          rs.CloseCurve( crv, 0.1 )\n    See Also:\n      CloseCurve\n      IsCurveClosed\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if tolerance is None: tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    return curve.IsClosable(tolerance)\n\n\ndef IsCurveClosed(object_id):\n    \"\"\"Verifies an object is a closed curve object\n    Parameters:\n      object_id (guid): the object's identifier\n    Returns:\n      bool: True if successful otherwise False.  None on error\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          if rs.IsCurveClosed(oObject):\n              print \"The object is a closed curve.\"\n          else:\n              print \"The object is not a closed curve.\"\n      else:\n          print \"The object is not a curve.\"\n    See Also:\n      IsCurve\n      IsCurveLinear\n      IsCurvePeriodic\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(object_id)\n    return None if not curve else curve.IsClosed\n\n\ndef IsCurveInPlane(object_id, plane=None):\n    \"\"\"Test a curve to see if it lies in a specific plane\n    Parameters:\n      object_id (guid): the object's identifier\n      plane (plane, optional): plane to test. If omitted, the active construction plane is used\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj) and rs.IsCurvePlanar(obj):\n          if rs.IsCurveInPlane(obj):\n              print \"The curve lies in the current cplane.\"\n          else:\n              print \"The curve does not lie in the current cplane.\"\n      else:\n          print \"The object is not a planar curve.\"\n    See Also:\n      IsCurve\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, -1, True)\n    if not plane:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    else:\n        plane = rhutil.coerceplane(plane, True)\n    return curve.IsInPlane(plane, scriptcontext.doc.ModelAbsoluteTolerance)\n\n\ndef IsCurveLinear(object_id, segment_index=-1):\n    \"\"\"Verifies an object is a linear curve\n    Parameters:\n      curve_id (guid):identifier of the curve object\n      segment_index (number): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(id):\n          if rs.IsCurveLinear(id):\n              print \"The object is a linear curve.\"\n          else:\n              print \"The object is not a linear curve.\"\n      else:\n          print \"The object is not a curve.\"\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurvePeriodic\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return curve.IsLinear()\n\n\ndef IsCurvePeriodic(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a periodic curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          if rs.IsCurvePeriodic(obj):\n              print \"The object is a periodic curve.\"\n          else:\n              print \"The object is not a periodic curve.\"\n      else:\n          print \"The object is not a curve.\"\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurveLinear\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.IsPeriodic\n\n\ndef IsCurvePlanar(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a planar curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          if rs.IsCurvePlanar(obj):\n              print \"The object is a planar curve.\"\n          else:\n              print \"The object is not a planar curve.\"\n      else:\n          print \"The object is not a curve.\"\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurveLinear\n      IsCurvePeriodic\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    return curve.IsPlanar(tol)\n\n\ndef IsCurveRational(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a rational NURBS curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          if rs.IsCurveRational(obj):\n              print \"The object is a rational NURBS curve.\"\n          else:\n              print \"The object is not a rational NURBS curve.\"\n      else:\n         print \"The object is not a curve.\"\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurveLinear\n      IsCurvePeriodic\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    if isinstance(curve, Rhino.Geometry.NurbsCurve): return curve.IsRational\n    return False\n\n\ndef IsEllipse(object_id, segment_index=-1):\n    \"\"\"Verifies an object is an elliptical-shaped curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select an ellipse\")\n      if rs.IsEllipse(obj):\n          print \"The object is an ellipse.\"\n      else:\n          print \"The object is not an ellipse.\"\n    See Also:\n      EllipseCenterPoint\n      EllipseQuadPoints\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return curve.IsEllipse()\n\n\ndef IsLine(object_id, segment_index=-1):\n    \"\"\"Verifies an object is a line curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a line\")\n      if rs.IsLine(obj):\n          print \"The object is a line.\"\n      else:\n          print \"The object is not a line.\"\n    See Also:\n      AddLine\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    if isinstance(curve, Rhino.Geometry.LineCurve): return True\n    rc, polyline = curve.TryGetPolyline()\n    if rc and polyline.Count==2: return True\n    return False\n\n\ndef IsPointOnCurve(object_id, point, segment_index=-1):\n    \"\"\"Verifies that a point is on a curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      point (point): the test point\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          point = rs.GetPoint(\"Pick a test point\")\n          if point:\n              if rs.IsPointOnCurve(obj, point):\n                  print \"The point is on the curve\"\n              else:\n                  print \"The point is not on the curve\"\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    point = rhutil.coerce3dpoint(point, True)\n    rc, t = curve.ClosestPoint(point, Rhino.RhinoMath.SqrtEpsilon)\n    return rc\n\n\ndef IsPolyCurve(object_id, segment_index=-1):\n    \"\"\"Verifies an object is a PolyCurve curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional) the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polycurve\")\n      if rs.IsPolyCurve(obj):\n          print \"The object is a polycurve.\"\n      else:\n          print \"The object is not a polycurve.\"\n    See Also:\n      PolyCurveCount\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return isinstance(curve, Rhino.Geometry.PolyCurve)\n\n\ndef IsPolyline( object_id, segment_index=-1 ):\n    \"\"\"Verifies an object is a Polyline curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polyline\")\n      if rs.IsPolyline(obj):\n          print \"The object is a polyline.\"\n      else:\n          print \"The object is not a polyline.\"\n    See Also:\n      IsPolyline\n      PolylineVertices\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return isinstance(curve, Rhino.Geometry.PolylineCurve)\n\n\ndef JoinCurves(object_ids, delete_input=False, tolerance=None):\n    \"\"\"Joins multiple curves together to form one or more curves or polycurves\n    Parameters:\n      object_ids (guid): list of multiple curves\n      delete_input (bool, optional): delete input objects after joining\n      tolerance (number, optional): join tolerance. If omitted, 2.1 * document absolute\n          tolerance is used\n    Returns:\n      list(guid, ...): Object id representing the new curves\n    Example:\n      import rhinoscriptsyntax as rs\n      objs = rs.GetObjects(\"Select curves to join\", rs.filter.curve)\n      if objs: rs.JoinCurves(objs)\n    See Also:\n      ExplodeCurves\n      IsCurve\n      IsCurveClosed\n    \"\"\"\n    if len(object_ids)<2: raise ValueError(\"object_ids must contain at least 2 items\")\n    curves = [rhutil.coercecurve(id, -1, True) for id in object_ids]\n    if tolerance is None:\n        tolerance = 2.1 * scriptcontext.doc.ModelAbsoluteTolerance\n    newcurves = Rhino.Geometry.Curve.JoinCurves(curves, tolerance)\n    rc = []\n    if newcurves:\n        rc = [scriptcontext.doc.Objects.AddCurve(crv) for crv in newcurves]\n    if rc and delete_input:\n        for id in object_ids:\n            id = rhutil.coerceguid(id, True)\n            scriptcontext.doc.Objects.Delete(id, False)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef LineFitFromPoints(points):\n    \"\"\"Returns a line that was fit through an array of 3D points\n    Parameters:\n      points ([point, point, ...]): a list of at least two 3D points\n    Returns:\n      line: line on success\n    Example:\n      import rhinoscriptsyntax as rs\n      points = rs.GetPoints()\n      if points and len(points)>1:\n          line=rs.LineFitFromPoints(points)\n          if line: rs.AddLine(line.From, line.To)\n    See Also:\n      AddLine\n      CurveEndPoint\n      CurveStartPoint\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    rc, line = Rhino.Geometry.Line.TryFitLineToPoints(points)\n    if rc: return line\n    return scriptcontext.errorhandler()\n\n\ndef MakeCurveNonPeriodic(curve_id, delete_input=False):\n    \"\"\"Makes a periodic curve non-periodic. Non-periodic curves can develop\n    kinks when deformed\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      delete_input (bool): delete the input curve. If omitted, the input curve will not be deleted.\n    Returns:\n      guid: id of the new or modified curve if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.IsCurvePeriodic(curve): rs.MakeCurveNonPeriodic( curve )\n    See Also:\n      IsCurvePeriodic\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if not curve.IsPeriodic: return scriptcontext.errorhandler()\n    nc = curve.ToNurbsCurve()\n    if nc is None: return scriptcontext.errorhandler()\n    nc.Knots.ClampEnd( Rhino.Geometry.CurveEnd.Both )\n    rc = None\n    if delete_input:\n        if type(curve_id) is Rhino.DocObjects.ObjRef: pass\n        else: curve_id = rhutil.coerceguid(curve_id)\n        if curve_id:\n            rc = scriptcontext.doc.Objects.Replace(curve_id, nc)\n            if not rc: return scriptcontext.errorhandler()\n            rc = rhutil.coerceguid(curve_id)\n    else:\n        attrs = None\n        if type(scriptcontext.doc) is Rhino.RhinoDoc:\n            rhobj = rhutil.coercerhinoobject(curve_id)\n            if rhobj: attrs = rhobj.Attributes\n        rc = scriptcontext.doc.Objects.AddCurve(nc, attrs)\n        if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef MeanCurve(curve0, curve1, tolerance=None):\n    \"\"\"Creates an average curve from two curves\n    Parameters:\n      curve0, curve1 (guid): identifiers of two curves\n      tolerance (number, optional): angle tolerance used to match kinks between curves\n    Returns:\n      guid: id of the new or modified curve if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve0 = rs.GetObject(\"Select the first curve\", rs.filter.curve)\n      curve1 = rs.GetObject(\"Select the second curve\", rs.filter.curve)\n      rs.MeanCurve( curve0, curve1 )\n    See Also:\n      UnitAngleTolerance\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve0, -1, True)\n    curve1 = rhutil.coercecurve(curve1, -1, True)\n    if tolerance is None: tolerance=Rhino.RhinoMath.UnsetValue\n    crv = Rhino.Geometry.Curve.CreateMeanCurve(curve0,curve1,tolerance)\n    if crv:\n        rc = scriptcontext.doc.Objects.AddCurve(crv)\n        scriptcontext.doc.Views.Redraw()\n        return rc\n\n\ndef MeshPolyline(polyline_id):\n    \"\"\"Creates a polygon mesh object based on a closed polyline curve object.\n    The created mesh object is added to the document\n    Parameters:\n      polyline_id (guid): identifier of the polyline curve object\n    Returns:\n      guid: identifier of the new mesh object\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      polyline = rs.GetObject(\"Select a polyline\", rs.filter.curve)\n      if polyline:\n          if rs.IsPolyline(polyline) and rs.IsCurveClosed(polyline):\n              rs.MeshPolyline( polyline )\n    See Also:\n      IsCurveClosed\n      IsPolyline\n    \"\"\"\n    curve = rhutil.coercecurve(polyline_id, -1, True)\n    ispolyline, polyline = curve.TryGetPolyline()\n    if not ispolyline: return scriptcontext.errorhandler()\n    mesh = Rhino.Geometry.Mesh.CreateFromClosedPolyline(polyline)\n    if not mesh: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddMesh(mesh)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef OffsetCurve(object_id, direction, distance, normal=None, style=1):\n    \"\"\"Offsets a curve by a distance. The offset curve will be added to Rhino\n    Parameters:\n      object_id (guid): identifier of a curve object\n      direction (point): point describing direction of the offset\n      distance (number): distance of the offset\n      normal (vector, optional): normal of the plane in which the offset will occur.\n          If omitted, the normal of the active construction plane will be used\n      style (number, optional): the corner style. If omitted, the style is sharp.\n                                0 = None\n                                1 = Sharp\n                                2 = Round\n                                3 = Smooth\n                                4 = Chamfer\n    Returns:\n      list(guid, ...): list of ids for the new curves on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.IsCurve(obj):\n          rs.OffsetCurve( obj, [0,0,0], 1.0 )\n    See Also:\n      OffsetCurveOnSurface\n      OffsetSurface\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, -1, True)\n    direction = rhutil.coerce3dpoint(direction, True)\n    if normal:\n        normal = rhutil.coerce3dvector(normal, True)\n    else:\n        normal = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane().Normal\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    style = System.Enum.ToObject(Rhino.Geometry.CurveOffsetCornerStyle, style)\n    curves = curve.Offset(direction, normal, distance, tolerance, style)\n    if curves is None: return scriptcontext.errorhandler()\n    rc = [scriptcontext.doc.Objects.AddCurve(curve) for curve in curves]\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef OffsetCurveOnSurface(curve_id, surface_id, distance_or_parameter):\n    \"\"\"Offset a curve on a surface. The source curve must lie on the surface.\n    The offset curve or curves will be added to Rhino\n    Parameters:\n      curve_id, surface_id (guid): curve and surface identifiers\n      distance_or_parameter (number|tuple(number, number)): If a single number is passed, then this is the\n        distance of the offset. Based on the curve's direction, a positive value\n        will offset to the left and a negative value will offset to the right.\n        If a tuple of two values is passed, this is interpreted as the surface\n        U,V parameter that the curve will be offset through\n    Returns:\n      list(guid, ...): identifiers of the new curves if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      def TestOffset():\n          curve = rs.GetObject(\"Select curve on a surface\", rs.filter.curve)\n          if curve is None: return False\n          surface = rs.GetObject(\"Select base surface\", rs.filter.surface)\n          if surface is None: return False\n          point = rc.GetPointOnSurface( surface, \"Through point\" )\n          if point is None: return False\n          parameter = rs.SurfaceClosestPoint(surface, point)\n          rc = rs.OffsetCurveOnSurface( curve, surface, parameter )\n          return rc is not None\n       \n      TestOffset()\n    See Also:\n      OffsetCurve\n      OffsetSurface\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    surface = rhutil.coercesurface(surface_id, True)\n    x = None\n    if type(distance_or_parameter) is list or type(distance_or_parameter) is tuple:\n        x = Rhino.Geometry.Point2d( distance_or_parameter[0], distance_or_parameter[1] )\n    else:\n        x = float(distance_or_parameter)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    curves = curve.OffsetOnSurface(surface, x, tol)\n    if curves is None: return scriptcontext.errorhandler()\n    rc = [scriptcontext.doc.Objects.AddCurve(curve) for curve in curves]\n    if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef PlanarClosedCurveContainment(curve_a, curve_b, plane=None, tolerance=None):\n    \"\"\"Determines the relationship between the regions bounded by two coplanar\n    simple closed curves\n    Parameters:\n      curve_a, curve_b (guid): identifiers of two planar, closed curves\n      plane (plane, optional): test plane. If omitted, the currently active construction\n        plane is used\n      tolerance (number, optional): if omitted, the document absolute tolerance is used\n    Returns:\n      number: a number identifying the relationship if successful\n        0 = the regions bounded by the curves are disjoint\n        1 = the two curves intersect\n        2 = the region bounded by curve_a is inside of curve_b\n        3 = the region bounded by curve_b is inside of curve_a\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      curve1 = rs.GetObject(\"Select first curve\", rs.filter.curve )\n      curve2 = rs.GetObject(\"Select second curve\", rs.filter.curve )\n      if rs.IsCurvePlanar(curve1) and rs.IsCurvePlanar(curve2):\n          if rs.IsCurveClosed(curve1) and rs.IsCurveClosed(curve2):\n              if rs.IsCurveInPlane(curve1) and rs.IsCurveInPlane(curve2):\n                  result = rs.PlanarClosedCurveContainment(curve1, curve2)\n                  if result==0: print \"The regions bounded by the curves are disjoint.\"\n                  elif result==1: print \"The two curves intersect..\"\n                  elif result==2: print \"The region bounded by Curve1 is inside of Curve2.\"\n                  else: print \"The region bounded by Curve2 is inside of Curve1.\"\n    See Also:\n      PlanarCurveCollision\n      PointInPlanarClosedCurve\n    \"\"\"\n    curve_a = rhutil.coercecurve(curve_a, -1, True)\n    curve_b = rhutil.coercecurve(curve_b, -1, True)\n    if tolerance is None or tolerance<=0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if plane:\n        plane = rhutil.coerceplane(plane)\n    else:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    rc = Rhino.Geometry.Curve.PlanarClosedCurveRelationship(curve_a, curve_b, plane, tolerance)\n    return int(rc)\n\n\ndef PlanarCurveCollision(curve_a, curve_b, plane=None, tolerance=None):\n    \"\"\"Determines if two coplanar curves intersect\n    Parameters:\n      curve_a, curve_b (guid): identifiers of two planar curves\n      plane (plane, optional): test plane. If omitted, the currently active construction\n        plane is used\n      tolerance (number, optional): if omitted, the document absolute tolerance is used\n    Returns:\n      bool: True if the curves intersect; otherwise False\n    Example:\n      import rhinoscriptsyntax as rs\n      curve1 = rs.GetObject(\"Select first curve\")\n      curve2 = rs.GetObject(\"Select second curve\")\n      if( rs.IsCurvePlanar(curve1) and rs.IsCurvePlanar(curve2) and rs.IsCurveInPlane(curve1) and rs.IsCurveInPlane(curve2) ):\n          if rs.PlanarCurveCollision(curve1, curve2):\n              print \"The coplanar curves intersect.\"\n          else:\n              print \"The coplanar curves do not intersect.\"\n    See Also:\n      CurveCurveIntersection\n      PlanarClosedCurveContainment\n      PointInPlanarClosedCurve\n    \"\"\"\n    curve_a = rhutil.coercecurve(curve_a, -1, True)\n    curve_b = rhutil.coercecurve(curve_b, -1, True)\n    if tolerance is None or tolerance<=0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if plane:\n        plane = rhutil.coerceplane(plane)\n    else:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    return Rhino.Geometry.Curve.PlanarCurveCollision(curve_a, curve_b, plane, tolerance)\n\n\ndef PointInPlanarClosedCurve(point, curve, plane=None, tolerance=None):\n    \"\"\"Determines if a point is inside of a closed curve, on a closed curve, or\n    outside of a closed curve\n    Parameters:\n      point (point|guid): text point\n      curve (guid): identifier of a curve object\n      plane (plane, optional): plane containing the closed curve and point. If omitted,\n          the currently active construction plane is used\n      tolerance (number, optional) it omitted, the document abosulte tolerance is used\n    Returns:\n      number: number identifying the result if successful\n              0 = point is outside of the curve\n              1 = point is inside of the curve\n              2 = point in on the curve\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a planar, closed curve\", rs.filter.curve)\n      if rs.IsCurveClosed(curve) and rs.IsCurvePlanar(curve):\n          point = rs.GetPoint(\"Pick a point\")\n          if point:\n              result = rs.PointInPlanarClosedCurve(point, curve)\n              if result==0: print \"The point is outside of the closed curve.\"\n              elif result==1: print \"The point is inside of the closed curve.\"\n              else: print \"The point is on the closed curve.\"\n    See Also:\n      PlanarClosedCurveContainment\n      PlanarCurveCollision\n    \"\"\"\n    point = rhutil.coerce3dpoint(point, True)\n    curve = rhutil.coercecurve(curve, -1, True)\n    if tolerance is None or tolerance<=0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if plane:\n        plane = rhutil.coerceplane(plane)\n    else:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    rc = curve.Contains(point, plane, tolerance)\n    if rc==Rhino.Geometry.PointContainment.Unset: raise Exception(\"Curve.Contains returned Unset\")\n    if rc==Rhino.Geometry.PointContainment.Outside: return 0\n    if rc==Rhino.Geometry.PointContainment.Inside: return 1\n    return 2\n\n\ndef PolyCurveCount(curve_id, segment_index=-1):\n    \"\"\"Returns the number of curve segments that make up a polycurve\n    Parameters:\n      curve_id (guid): the object's identifier\n      segment_index (number, optional): if `curve_id` identifies a polycurve object, then `segment_index` identifies the curve segment of the polycurve to query.\n    Returns:\n      number: the number of curve segments in a polycurve if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polycurve\")\n      if rs.IsPolyCurve(obj):\n          count = rs.PolyCurveCount(obj)\n          if count: print \"The polycurve contains\", count, \" curves.\"\n    See Also:\n      IsPolyCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    if isinstance(curve, Rhino.Geometry.PolyCurve): return curve.SegmentCount\n    raise ValueError(\"curve_id does not reference a polycurve\")\n\n\ndef PolylineVertices(curve_id, segment_index=-1):\n    \"\"\"Returns the vertices of a polyline curve on success\n    Parameters:\n      curve_id (guid): the object's identifier\n      segment_index (number, optional): if curve_id identifies a polycurve object, then segment_index identifies the curve segment of the polycurve to query.\n    Returns:\n      list(point, ...): an list of Point3d vertex points if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polyline\")\n      if rs.IsPolyline(obj):\n          points = rs.PolylineVertices(obj)\n          if points:\n              for point in points: rs.AddPoint(point)\n    See Also:\n      AddPolyline\n      IsPolyline\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, polyline = curve.TryGetPolyline()\n    if rc: return [pt for pt in polyline]\n    raise ValueError(\"curve_id does not reference a polyline\")\n\n\ndef ProjectCurveToMesh(curve_ids, mesh_ids, direction):\n    \"\"\"Projects one or more curves onto one or more surfaces or meshes\n    Parameters:\n      curve_ids ([guid, ...]): identifiers of curves to project\n      mesh_ids ([guid, ...]): identifiers of meshes to project onto\n      direction (vector): projection direction\n    Returns:\n      list(guid, ...): list of identifiers for the resulting curves.\n    Example:\n      import rhinoscriptsyntax as rs\n      mesh = rs.GetObject(\"Select mesh to project onto\", rs.filter.mesh)\n      curve= rs.GetObject(\"Select curve to project\", rs.filter.curve)\n      #Project down...\n      results = rs.ProjectCurveToMesh(curve, mesh, (0,0,-1))\n    See Also:\n      ProjectCurveToSurface\n      ProjectPointToMesh\n      ProjectPointToSurface\n    \"\"\"\n    curve_ids = rhutil.coerceguidlist(curve_ids)\n    mesh_ids = rhutil.coerceguidlist(mesh_ids)\n    direction = rhutil.coerce3dvector(direction, True)\n    curves = [rhutil.coercecurve(id, -1, True) for id in curve_ids]\n    meshes = [rhutil.coercemesh(id, True) for id in mesh_ids]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newcurves = Rhino.Geometry.Curve.ProjectToMesh(curves, meshes, direction, tolerance)\n    ids = [scriptcontext.doc.Objects.AddCurve(curve) for curve in newcurves]\n    if ids: scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef ProjectCurveToSurface(curve_ids, surface_ids, direction):\n    \"\"\"Projects one or more curves onto one or more surfaces or polysurfaces\n    Parameters:\n      curve_ids ([guid, ...]): identifiers of curves to project\n      surface_ids ([guid, ...]): identifiers of surfaces to project onto\n      direction (vector): projection direction\n    Returns:\n      list(guid, ...): list of identifiers\n    Example:\n      import rhinoscriptsyntax as rs\n      surface = rs.GetObject(\"Select surface to project onto\", rs.filter.surface)\n      curve = rs.GetObject(\"Select curve to project\", rs.filter.curve)\n      # Project down...\n      results = rs.ProjectCurveToSurface(curve, surface, (0,0,-1))\n    See Also:\n      ProjectCurveToMesh\n      ProjectPointToMesh\n      ProjectPointToSurface\n    \"\"\"\n    curve_ids = rhutil.coerceguidlist(curve_ids)\n    surface_ids = rhutil.coerceguidlist(surface_ids)\n    direction = rhutil.coerce3dvector(direction, True)\n    curves = [rhutil.coercecurve(id, -1, True) for id in curve_ids]\n    breps = [rhutil.coercebrep(id, True) for id in surface_ids]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newcurves = Rhino.Geometry.Curve.ProjectToBrep(curves, breps, direction, tolerance)\n    ids = [scriptcontext.doc.Objects.AddCurve(curve) for curve in newcurves]\n    if ids: scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef RebuildCurve(curve_id, degree=3, point_count=10):\n    \"\"\"Rebuilds a curve to a given degree and control point count. For more\n    information, see the Rhino help for the Rebuild command.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      degree (number, optional): new degree (must be greater than 0)\n      point_count (number, optional) new point count, which must be bigger than degree.\n    Returns:\n      bool: True of False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select curve to rebuild\", rs.filter.curve)\n      if curve: rs.RebuildCurve(curve, 3, 10)\n    See Also:\n      RebuildSurface\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if degree<1: raise ValueError(\"degree must be greater than 0\")\n    newcurve = curve.Rebuild(point_count, degree, False)\n    if not newcurve: return False\n    scriptcontext.doc.Objects.Replace(curve_id, newcurve)\n    scriptcontext.doc.Views.Redraw()\n    return True\n\n\ndef RemoveCurveKnot(curve, parameter):\n    \"\"\"Deletes a knot from a curve object.\n    Parameters:\n      curve (guid): The reference of the source object\n      parameter (number): The parameter on the curve. Note, if the parameter is not equal to one\n                      of the existing knots, then the knot closest to the specified parameter\n                      will be removed.\n    Returns:\n      bool: True of False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n\n      crv_info = rs.GetCurveObject(\"Select curve near knot to be removed\")\n      if crv_info:\n          crv_id = crv_info[0]\n          crv_param = crv_info[4]\n          rs.RemoveCurveKnot(crv_id, crv_param)\n    See Also:\n      RemoveSurfaceKnot\n    \"\"\"\n    curve_inst = rhutil.coercecurve(curve, -1, True)\n    success, n_param = curve_inst.GetCurveParameterFromNurbsFormParameter(parameter)\n    if not success: return False\n    n_curve = curve_inst.ToNurbsCurve()\n    if not n_curve: return False\n    success = n_curve.Knots.RemoveKnotAt(n_param)\n    if not success: return False\n    scriptcontext.doc.Objects.Replace(curve, n_curve)\n    scriptcontext.doc.Views.Redraw()\n    return True\n\n\ndef ReverseCurve(curve_id):\n    \"\"\"Reverses the direction of a curve object. Same as Rhino's Dir command\n    Parameters:\n      curve_id (guid): identifier of the curve object\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve to reverse\")\n      if rs.IsCurve(curve): rs.ReverseCurve(curve)\n    See Also:\n      CurveDirectionsMatch\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if curve.Reverse():\n        curve_id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Replace(curve_id, curve)\n        return True\n    return False\n\n\ndef SimplifyCurve(curve_id, flags=0):\n    \"\"\"Replace a curve with a geometrically equivalent polycurve.\n    \n    The polycurve will have the following properties:\n     - All the polycurve segments are lines, polylines, arcs, or NURBS curves.\n     - The NURBS curves segments do not have fully multiple interior knots.\n     - Rational NURBS curves do not have constant weights.\n     - Any segment for which IsCurveLinear or IsArc is True is a line, polyline segment, or an arc.\n     - Adjacent co-linear or co-circular segments are combined.\n     - Segments that meet with G1-continuity have there ends tuned up so that they meet with G1-continuity to within machine precision.\n     - If the polycurve is a polyline, a polyline will be created\n\n\n    Parameters:\n      curve_id (guid): the object's identifier\n      flags (number, optional): the simplification methods to use. By default, all methods are used (flags = 0)\n        Value Description\n        0     Use all methods.\n        1     Do not split NURBS curves at fully multiple knots.\n        2     Do not replace segments with IsCurveLinear = True with line curves.\n        4     Do not replace segments with IsArc = True with arc curves.\n        8     Do not replace rational NURBS curves with constant denominator with an equivalent non-rational NURBS curve.\n        16    Do not adjust curves at G1-joins.\n        32    Do not merge adjacent co-linear lines or co-circular arcs or combine consecutive line segments into a polyline.\n\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve to simplify\", rs.filter.curve)\n      if curve: rs.SimplifyCurve(curve)\n    See Also:\n      IsArc\n      IsCurveLinear\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    _flags = Rhino.Geometry.CurveSimplifyOptions.All\n    if( flags&1 ==1 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.SplitAtFullyMultipleKnots)\n    if( flags&2 ==2 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.RebuildLines)\n    if( flags&4 ==4 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.RebuildArcs)\n    if( flags&8 ==8 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.RebuildRationals)\n    if( flags&16==16 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.AdjustG1)\n    if( flags&32==32 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.Merge)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    ang_tol = scriptcontext.doc.ModelAngleToleranceRadians\n    newcurve = curve.Simplify(_flags, tol, ang_tol)\n    if newcurve:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Replace(curve_id, newcurve)\n        scriptcontext.doc.Views.Redraw()\n        return True\n    return False\n\n\ndef SplitCurve(curve_id, parameter, delete_input=True):\n    \"\"\"Splits, or divides, a curve at a specified parameter. The parameter must\n    be in the interior of the curve's domain\n    Parameters:\n      curve_id (guid): the curve to split\n      parameter ({number, ...]) one or more parameters to split the curve at\n      delete_input (bool, optional): delete the input curve\n    Returns:\n      list(guid, ....): list of new curves on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve to split\", rs.filter.curve)\n      if rs.IsCurve(curve):\n          domain = rs.CurveDomain(curve)\n          parameter = domain[1] / 2.0\n          rs.SplitCurve( curve, parameter )\n    See Also:\n      TrimCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    newcurves = curve.Split(parameter)\n    if newcurves is None: return scriptcontext.errorhandler()\n    att = None\n    rhobj = rhutil.coercerhinoobject(curve_id)\n    if rhobj: att = rhobj.Attributes\n    rc = [scriptcontext.doc.Objects.AddCurve(crv, att) for crv in newcurves]\n    if rc and delete_input:\n        id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef TrimCurve(curve_id, interval, delete_input=True):\n    \"\"\"Trims a curve by removing portions of the curve outside a specified interval\n    Parameters:\n      curve_id (guid):the curve to trim\n      interval ([number, number]): two numbers identifying the interval to keep. Portions of\n        the curve before domain[0] and after domain[1] will be removed. If the\n        input curve is open, the interval must be increasing. If the input\n        curve is closed and the interval is decreasing, then the portion of\n        the curve across the start and end of the curve is returned\n      delete_input (bool): delete the input curve. If omitted the input curve is deleted.\n    Returns:\n      list(guid, ...): identifier of the new curve on success\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve to trim\", rs.filter.curve)\n      if rs.IsCurve(curve):\n          domain = rs.CurveDomain(curve)\n          domain[1] /= 2.0\n          rs.TrimCurve( curve, domain )\n    See Also:\n      SplitCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if interval[0]==interval[1]: raise ValueError(\"interval values are equal\")\n    newcurve = curve.Trim(interval[0], interval[1])\n    if not newcurve: return scriptcontext.errorhandler()\n    att = None\n    rhobj = rhutil.coercerhinoobject(curve_id)\n    if rhobj: att = rhobj.Attributes\n    rc = scriptcontext.doc.Objects.AddCurve(newcurve, att)\n    if delete_input:\n        id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ChangeCurveDegree(object_id, degree):\n    \"\"\"Changes the degree of a curve object. For more information see the Rhino help file for the ChangeDegree command.\n      Parameters:\n        object_id (guid): the object's identifier.\n        degree (number): the new degree.\n      Returns:\n        bool: True of False indicating success or failure.\n        None: on failure\n      Example:\n    \n      See Also:\n        IsCurve\n        CurveDegree\n    \"\"\" \n    curve = rhutil.coercerhinoobject(object_id)\n    if not curve: return None\n    if not isinstance(curve, Rhino.DocObjects.CurveObject): return None\n\n    curve = curve.CurveGeometry\n    if not isinstance(curve, Rhino.Geometry.NurbsCurve):\n        curve = curve.ToNurbsCurve()\n\n    max_nurbs_degree = 11\n    if degree < 1 or degree > max_nurbs_degree or curve.Degree == degree:\n        return None\n\n    r = False\n    if curve.IncreaseDegree(degree):\n        r = scriptcontext.doc.Objects.Replace(object_id, curve)\n    return r\n\ndef AddTweenCurves(from_curve_id, to_curve_id, number_of_curves = 1, method = 0, sample_number = 10):\n    \"\"\"Creates curves between two open or closed input curves.\n    Parameters:\n      from_curve_id (guid): identifier of the first curve object.\n      to_curve_id (guid): identifier of the second curve object.\n      number_of_curves (number): The number of curves to create. The default is 1.\n      method (number): The method for refining the output curves, where:\n        0: (Default) Uses the control points of the curves for matching. So the first control point of first curve is matched to first control point of the second curve.\n        1: Refits the output curves like using the FitCurve method.  Both the input curve and the output curve will have the same structure. The resulting curves are usually more complex than input unless input curves are compatible.\n        2: Input curves are divided to the specified number of points on the curve, corresponding points define new points that output curves go through. If you are making one tween curve, the method essentially does the following: divides the two curves into an equal number of points, finds the midpoint between the corresponding points on the curves, and interpolates the tween curve through those points.\n      sample_number (number): The number of samples points to use if method is 2. The default is 10.\n    Returns:\n      list(guid, ...): The identifiers of the new tween objects if successful, None on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curveA = rs.GetObject(\"Select first curve\", rs.filter.curve)\n      curveB = rs.GetObject(\"Select second curve\", rs.filter.curve)\n      arrResult = rs.AddTweenCurves(curveA, curveB, 6, 2, 30)\n    \"\"\"\n    curve0 = rhutil.coercecurve(from_curve_id, -1, True)\n    curve1 = rhutil.coercecurve(to_curve_id, -1, True)\n    out_curves = 0\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if method == 0:\n        out_curves = Rhino.Geometry.Curve.CreateTweenCurves(curve0, curve1, number_of_curves, tolerance)\n    elif method == 1:\n        out_curves = Rhino.Geometry.Curve.CreateTweenCurvesWithMatching(curve0, curve1, number_of_curves, tolerance)\n    elif method == 2:\n        out_curves = Rhino.Geometry.Curve.CreateTweenCurvesWithSampling(curve0, curve1, number_of_curves, sample_number, tolerance)\n    else: raise ValueError(\"method must be 0, 1, or 2\")\n    curves = None\n    if out_curves:\n        curves = []\n        for curve in out_curves:\n            if curve and curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n            curve.Dispose()\n            if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n            curves.append(rc)\n        scriptcontext.doc.Views.Redraw()\n    return curves\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "brep", "line", "dimension", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "mahaidong_p4r-vscode_e7e7c4d5bb.json", "repo": "mahaidong/p4r-vscode"}
{"instruction": "Add new detail view to an existing layout view", "code": "import scriptcontext\nimport utility as rhutil\nimport Rhino\nimport System.Enum\nimport math\n\ndef __viewhelper(view):\n    if view is None: return scriptcontext.doc.Views.ActiveView\n    allviews = scriptcontext.doc.Views.GetViewList(True, True)\n    view_id = rhutil.coerceguid(view, False)\n    for item in allviews:\n        if view_id:\n            if item.MainViewport.Id == view_id: return item\n        elif item.MainViewport.Name == view:\n            return item\n    raise ValueError(\"unable to coerce %s into a view\"%view)\n\n\ndef AddDetail(layout_id, corner1, corner2, title=None, projection=1):\n    \"\"\"Add new detail view to an existing layout view\n    Parameters:\n      layout_id (guid): identifier of an existing layout\n      corner1, corner2 (point): 2d corners of the detail in the layout's unit system\n      title (str, optional): title of the new detail\n      projection (number, optional): type of initial view projection for the detail\n          1 = parallel top view\n          2 = parallel bottom view\n          3 = parallel left view\n          4 = parallel right view\n          5 = parallel front view\n          6 = parallel back view\n          7 = perspective view\n    Returns:\n      guid: identifier of the newly created detail on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      layout = rs.AddLayout(\"Portrait\", (8.5,11))\n      if layout:\n          rs.AddDetail(layout, (0.5,0.5), (8,10.5), None, 7)\n    See Also:\n      DeleteNamedView\n      NamedViews\n      RestoreNamedView\n    \"\"\"\n    layout_id = rhutil.coerceguid(layout_id, True)\n    corner1 = rhutil.coerce2dpoint(corner1, True)\n    corner2 = rhutil.coerce2dpoint(corner2, True)\n    if projection<1 or projection>7: raise ValueError(\"projection must be a value between 1-7\")\n    layout = scriptcontext.doc.Views.Find(layout_id)\n    if not layout: raise ValueError(\"no layout found for given layout_id\")\n    projection = System.Enum.ToObject(Rhino.Display.DefinedViewportProjection, projection)\n    detail = layout.AddDetailView(title, corner1, corner2, projection)\n    if not detail: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return detail.Id\n\n\ndef AddLayout(title=None, size=None):\n    \"\"\"Adds a new page layout view\n    Parameters:\n      title (str, optional): title of new layout\n      size ([number, number], optional): width and height of paper for the new layout\n    Returns:\n      guid: id of new layout\n    Example:\n      import rhinoscriptsyntax as rs\n      rs.AddLayout(\"Portrait\")\n    See Also:\n      DeleteNamedView\n      NamedViews\n      RestoreNamedView\n    \"\"\"\n    page = None\n    if size is None: page = scriptcontext.doc.Views.AddPageView(title)\n    else: page = scriptcontext.doc.Views.AddPageView(title, size[0], size[1])\n    if page: return page.MainViewport.Id\n\n\ndef AddNamedCPlane(cplane_name, view=None):\n    \"\"\"Adds new named construction plane to the document\n    Parameters:\n      cplane_name (str): the name of the new named construction plane\n      view (guid|str): Title or identifier of the view from which to save\n               the construction plane. If omitted, the current active view is used.\n    Returns:\n      atr: name of the newly created construction plane if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      views = rs.ViewNames()\n      if views:\n          for view in views:\n              name = view + \"_cplane\"\n              rs.AddNamedCPlane( name, view )\n    See Also:\n      DeleteNamedCPlane\n      NamedCPlane\n      NamedCPlanes\n      RestoreNamedCPlane\n    \"\"\"\n    view = __viewhelper(view)\n    if not cplane_name: raise ValueError(\"cplane_name is empty\")\n    plane = view.MainViewport.ConstructionPlane()\n    index = scriptcontext.doc.NamedConstructionPlanes.Add(cplane_name, plane)\n    if index<0: return scriptcontext.errorhandler()\n    return cplane_name\n\n\ndef AddNamedView(name, view=None):\n    \"\"\"Adds a new named view to the document\n    Parameters:\n      name (str): the name of the new named view\n      view: (guid|str): the title or identifier of the view to save. If omitted, the current\n            active view is saved\n    Returns:\n      str: name fo the newly created named view if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      views = rs.ViewNames()\n      if views:\n          for view in views:\n              name = view + \"_view\"\n              rs.AddNamedView( name, view )\n    See Also:\n      DeleteNamedView\n      NamedViews\n      RestoreNamedView\n    \"\"\"\n    view = __viewhelper(view)\n    if not name: raise ValueError(\"name is empty\")\n    viewportId = view.MainViewport.Id\n    index = scriptcontext.doc.NamedViews.Add(name, viewportId)\n    if index<0: return scriptcontext.errorhandler()\n    return name\n\n\ndef CurrentDetail(layout, detail=None, return_name=True):\n    \"\"\"Returns or changes the current detail view in a page layout view\n    Parameters:\n      layout (str|guid): title or identifier of an existing page layout view\n      detail (str|guid, optional): title or identifier the the detail view to set\n      return_name (bool, optional): return title if True, else return identifier\n    Returns:\n      str: if detail is not specified, the title or id of the current detail view\n      str: if detail is specified, the title or id of the previous detail view\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      layout = rs.CurrentView(return_name=False)\n      if rs.IsLayout(layout):\n          rs.CurrentDetail( layout, layout )\n    See Also:\n      IsDetail\n      IsLayout\n    \"\"\"\n    layout_id = rhutil.coerceguid(layout)\n    page = None\n    if layout_id is None: page = scriptcontext.doc.Views.Find(layout, False)\n    else: page = scriptcontext.doc.Views.Find(layout_id)\n    if page is None: return scriptcontext.errorhandler()\n    rc = None\n    active_viewport = page.ActiveViewport\n    if return_name: rc = active_viewport.Name\n    else: rc = active_viewport.Id\n    if detail:\n        id = rhutil.coerceguid(detail)\n        if( (id and id==page.MainViewport.Id) or (id is None and detail==page.MainViewport.Name) ):\n            page.SetPageAsActive()\n        else:\n            if id: page.SetActiveDetail(id)\n            else: page.SetActiveDetail(detail, False)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef CurrentView(view=None, return_name=True):\n    \"\"\"Returns or sets the currently active view\n    Parameters:\n      view (str|guid): Title or id of the view to set current.\n        If omitted, only the title or identifier of the current view is returned\n      return_name (bool, optional): If True, then the name, or title, of the view is returned.\n        If False, then the identifier of the view is returned\n    Returns:\n      str: if the title is not specified, the title or id of the current view\n      str: if the title is specified, the title or id of the previous current view\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      previous = rs.CurrentView(\"Perspective\")\n      print \"The previous current view was \", previous\n      viewId = rs.CurrentView( return_name=False )\n      print \"The identifier of the current view is \", viewId\n    See Also:\n      IsViewCurrent\n      ViewNames\n    \"\"\"\n    rc = None\n    if return_name: rc = scriptcontext.doc.Views.ActiveView.MainViewport.Name\n    else: rc = scriptcontext.doc.Views.ActiveView.MainViewport.Id\n    if view:\n        id = rhutil.coerceguid(view)\n        rhview = None\n        if id: rhview = scriptcontext.doc.Views.Find(id)\n        else: rhview = scriptcontext.doc.Views.Find(view, False)\n        if rhview is None: return scriptcontext.errorhandler()\n        scriptcontext.doc.Views.ActiveView = rhview\n    return rc\n\n\ndef DeleteNamedCPlane(name):\n    \"\"\"Removes a named construction plane from the document\n    Parameters:\n      name (str): name of the construction plane to remove\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      cplanes = rs.NamedCplanes()\n      if cplanes:\n          for cplane in cplanes: rs.DeleteNamedCPlane(cplane)\n    See Also:\n      AddNamedCPlane\n      NamedCPlane\n      NamedCPlanes\n      RestoreNamedCPlane\n    \"\"\"\n    return scriptcontext.doc.NamedConstructionPlanes.Delete(name)\n\n\ndef DeleteNamedView(name):\n    \"\"\"Removes a named view from the document\n    Parameters:\n      name (str): name of the named view to remove\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      views = rs.NamedViews()\n      if views:\n          for view in views: rs.DeleteNamedView(view)\n    See Also:\n      AddNamedView\n      NamedViews\n      RestoreNamedView\n    \"\"\"\n    return scriptcontext.doc.NamedViews.Delete(name)\n\n\ndef DetailLock(detail_id, lock=None):\n    \"\"\"Returns or modifies the projection locked state of a detail\n    Parameters:\n      detail_id (guid): identifier of a detail object\n      lock (bool, optional) the new lock state\n    Returns:\n      bool: if lock==None, the current detail projection locked state\n      bool: if lock is True or False, the previous detail projection locked state\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      detail = rs.GetObject(\"select a detail\", rs.filter.detail)\n      if detail: rs.DetailLock(detail,True)\n    See Also:\n      IsDetail\n      IsLayout\n    \"\"\"\n    detail_id = rhutil.coerceguid(detail_id, True)\n    detail = scriptcontext.doc.Objects.Find(detail_id)\n    if not detail: return scriptcontext.errorhandler()\n    rc = detail.DetailGeometry.IsProjectionLocked\n    if lock is not None and lock!=rc:\n        detail.DetailGeometry.IsProjectionLocked = lock\n        detail.CommitChanges()\n    return rc\n\n\ndef DetailScale(detail_id, model_length=None, page_length=None):\n    \"\"\"Returns or modifies the scale of a detail object\n    Parameters:\n      detail_id (guid): identifier of a detail object\n      model_length (number, optional): a length in the current model units\n      page_length (number, optional): a length in the current page units\n    Returns:\n      number: current page to model scale ratio if model_length and page_length are both None\n      number: previous page to model scale ratio if model_length and page_length are values\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      detail = rs.GetObject(\"select a detail\", rs.filter.detail)\n      if detail: rs.DetailScale(detail,1,1)\n    See Also:\n      IsDetail\n      IsLayout\n    \"\"\"\n    detail_id = rhutil.coerceguid(detail_id, True)\n    detail = scriptcontext.doc.Objects.Find(detail_id)\n    if detail is None: return scriptcontext.errorhandler()\n    rc = detail.DetailGeometry.PageToModelRatio\n    if model_length or page_length:\n        if model_length is None or page_length is None:\n            return scriptcontext.errorhandler()\n        model_units = scriptcontext.doc.ModelUnitSystem\n        page_units = scriptcontext.doc.PageUnitSystem\n        if detail.DetailGeometry.SetScale(model_length, model_units, page_length, page_units):\n            detail.CommitChanges()\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef IsDetail(layout, detail):\n    \"\"\"Verifies that a detail view exists on a page layout view\n    Parameters:\n      layout (str|guid): title or identifier of an existing page layout\n      detail (str|guid): title or identifier of an existing detail view\n    Returns:\n      bool: True if detail is a detail view\n      bool: False if detail is not a detail view\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      if rs.IsLayout(view):\n          isdetail = rs.IsDetail(view, \"Top\")\n          if isdetail:\n              print \"Top is a detail view.\"\n          else:\n              print \"Top is not a detail view.\"\n    See Also:\n      IsLayout\n      CurrentDetail\n    \"\"\"\n    layout_id = rhutil.coerceguid(layout)\n    views = scriptcontext.doc.Views.GetViewList(False, True)\n    found_layout = None\n    for view in views:\n        if layout_id:\n            if view.MainViewport.Id==layout_id:\n                found_layout = view\n                break\n        elif view.MainViewport.Name==layout:\n            found_layout = view\n            break\n    # if we couldn't find a layout, this is an error\n    if found_layout is None: return scriptcontext.errorhandler()\n    detail_id = rhutil.coerceguid(detail)\n    details = view.GetDetailViews()\n    if not details: return False\n    for detail_view in details:\n        if detail_id:\n            if detail_view.Id==detail_id: return True\n        else:\n            if detail_view.Name==detail: return True\n    return False\n\n\ndef IsLayout(layout):\n    \"\"\"Verifies that a view is a page layout view\n    Parameters:\n      layout (guid|str): title or identifier of an existing page layout view\n    Returns:\n      bool: True if layout is a page layout view\n      bool: False is layout is a standard, model view\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      if rs.IsLayout(view):\n          print \"The current view is a page layout view.\"\n      else:\n          print \"The current view is standard, model view.\"\n    See Also:\n      IsLayout\n      CurrentDetail\n    \"\"\"\n    layout_id = rhutil.coerceguid(layout)\n    alllayouts = scriptcontext.doc.Views.GetViewList(False, True)\n    for layoutview in alllayouts:\n        if layout_id:\n            if layoutview.MainViewport.Id==layout_id: return True\n        elif layoutview.MainViewport.Name==layout: return True\n    allmodelviews = scriptcontext.doc.Views.GetViewList(True, False)\n    for modelview in allmodelviews:\n        if layout_id:\n          if modelview.MainViewport.Id==layout_id: return False\n        elif modelview.MainViewport.Name==layout: return False\n    return scriptcontext.errorhandler()\n\n\ndef IsView(view):\n    \"\"\"Verifies that the specified view exists\n    Parameters:\n      view (str|guid): title or identifier of the view\n    Returns:\n      bool: True of False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      title = \"Perspective\"\n      result = rs.IsView(title)\n      if result:\n          print \"The \" + title + \" view exists.\"\n      else:\n          print \"The \" + title + \" view does not exist.\"\n    See Also:\n      ViewNames\n    \"\"\"\n    view_id = rhutil.coerceguid(view)\n    if view_id is None and view is None: return False\n    allviews = scriptcontext.doc.Views.GetViewList(True, True)\n    for item in allviews:\n        if view_id:\n            if item.MainViewport.Id==view_id: return True\n        elif item.MainViewport.Name==view: return True\n    return False\n\n\ndef IsViewCurrent(view):\n    \"\"\"Verifies that the specified view is the current, or active view\n    Parameters:\n      view (str|guid): title or identifier of the view\n    Returns:\n      bool: True of False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      title = \"Perspective\"\n      result = rs.IsViewCurrent(title)\n      if result:\n          print \"The \" + title + \" view is current.\"\n      else:\n          print \"The \" + title + \" view is not current.\"\n    See Also:\n      CurrentView\n    \"\"\"\n    activeview = scriptcontext.doc.Views.ActiveView\n    view_id = rhutil.coerceguid(view)\n    if view_id: return view_id==activeview.MainViewport.Id\n    return view==activeview.MainViewport.Name\n\n\ndef IsViewMaximized(view=None):\n    \"\"\"Verifies that the specified view is maximized (enlarged so as to fill\n    the entire Rhino window)\n    Parameters:\n      view: (str|guid): title or identifier of the view. If omitted, the current\n            view is used\n    Returns:\n      bool: True of False\n    Example:\n      import rhinoscriptsyntax as rs\n      title = rs.CurrentView()\n      result = rs.IsViewMaximized(title)\n      if result:\n          print \"The \" + title + \" view is maximized.\"\n      else:\n          print \"The \" + title + \" view is not maximized.\"\n    See Also:\n      MaximizeRestoreView\n    \"\"\"\n    view = __viewhelper(view)\n    return view.Maximized\n\n\ndef IsViewPerspective(view):\n    \"\"\"Verifies that the specified view's projection is set to perspective\n    Parameters:\n      view (str|guid): title or identifier of the view\n    Returns:\n      bool: True of False\n    Example:\n      import rhinoscriptsyntax as rs\n      title = rs.CurrentView()\n      result = rs.IsViewPerspective(title)\n      if result:\n          print \"The \" + title + \" view is set to perspective projection.\"\n      else:\n          print \"The \" + title + \" view is set to parallel projection.\"\n    See Also:\n      ViewProjection\n    \"\"\"\n    view = __viewhelper(view)\n    return view.MainViewport.IsPerspectiveProjection\n\n\ndef IsViewTitleVisible(view=None):\n    \"\"\"Verifies that the specified view's title window is visible\n    Parameters:\n      view: (str|guid, optional): The title or identifier of the view. If omitted, the current\n            active view is used\n    Returns:\n      bool: True of False\n    Example:\n      import rhinoscriptsyntax as rs\n      title = rs.CurrentView()\n      vis = rs.IsViewTitleVisible(title)\n      if vis:\n          print \"The \", title, \" view's title is visible.\"\n      else:\n          print \"The \", title, \" view's title is not visible.\"\n    See Also:\n      ShowViewTitle\n    \"\"\"\n    view = __viewhelper(view)\n    return view.MainViewport.TitleVisible\n\n\ndef IsWallpaper(view):\n    \"\"\"Verifies that the specified view contains a wallpaper image\n    Parameters:\n      view (str|guid): view to verify\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      filename = rs.OpenFileName()\n      if filename and not rs.IsWallpaper(view):\n          rs.Wallpaper(view, filename)\n    See Also:\n      Wallpaper\n    \"\"\"\n    view = __viewhelper(view)\n    return len(view.MainViewport.WallpaperFilename)>0\n\n\ndef MaximizeRestoreView(view=None):\n    \"\"\"Toggles a view's maximized/restore window state of the specified view\n    Parameters:\n      view: (str|guid, optional): the title or identifier of the view. If omitted, the current\n            active view is used\n    Returns:\n      None\n    Example:\n      import rhinoscriptsyntax as rs\n      title = rs.CurrentView()\n      if rs.IsViewMaximized(title):\n          rs.MaximizeRestoreView( title )\n    See Also:\n      IsViewMaximized\n    \"\"\"\n    view = __viewhelper(view)\n    view.Maximized = not view.Maximized\n\n\ndef NamedCPlane(name):\n    \"\"\"Returns the plane geometry of the specified named construction plane\n    Parameters:\n      name (str): the name of the construction plane\n    Returns:\n      plane: a plane on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      names = rs.NamedCPlanes()\n      if names:\n          for name in names:\n              plane = rs.NamedCPlane(name)\n              print \"CPlane name:\" + name\n              print \"CPlane origin:\" + plane.Origin\n              print \"CPlane x-axis:\" + plane.Xaxis\n              print \"CPlane y-axis:\" + plane.Yaxis\n              print \"CPlane z-axis:\" + plane.Zaxis\n    See Also:\n      AddNamedCPlane\n      DeleteNamedCPlane\n      NamedCPlanes\n      RestoreNamedCPlane\n    \"\"\"\n    index = scriptcontext.doc.NamedConstructionPlanes.Find(name)\n    if index<0: return scriptcontext.errorhandler()\n    return scriptcontext.doc.NamedConstructionPlanes[index].Plane\n\n\ndef NamedCPlanes():\n    \"\"\"Returns the names of all named construction planes in the document\n    Returns:\n      list(str, ...): the names of all named construction planes in the document\n    Example:\n      import rhinoscriptsyntax as rs\n      cplanes = rs.NamedCPlanes()\n      if cplanes:\n          for cplane in cplanes: print cplane\n    See Also:\n      AddNamedCPlane\n      DeleteNamedCPlane\n      NamedCPlane\n      RestoreNamedCPlane\n    \"\"\"\n    count = scriptcontext.doc.NamedConstructionPlanes.Count\n    rc = [scriptcontext.doc.NamedConstructionPlanes[i].Name for i in range(count)]\n    return rc\n\n\ndef NamedViews():\n    \"\"\"Returns the names of all named views in the document\n    Returns:\n      list(str, ...): the names of all named views in the document\n    Example:\n      import rhinoscriptsyntax as rs\n      views = rs.NamedViews()\n      if views:\n          for view in views: print view\n    See Also:\n      AddNamedView\n      DeleteNamedView\n      RestoreNamedView\n    \"\"\"\n    count = scriptcontext.doc.NamedViews.Count\n    return [scriptcontext.doc.NamedViews[i].Name for i in range(count)]\n\n\ndef RenameView(old_title, new_title):\n    \"\"\"Changes the title of the specified view\n    Parameters:\n      old_title (str|guid): the title or identifier of the view to rename\n      new_title (str): the new title of the view\n    Returns:\n      str: the view's previous title if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      oldtitle = rs.CurrentView()\n      rs.renameview( oldtitle, \"Current\" )\n    See Also:\n      ViewNames\n    \"\"\"\n    if not old_title or not new_title: return scriptcontext.errorhandler()\n    old_id = rhutil.coerceguid(old_title)\n    foundview = None\n    allviews = scriptcontext.doc.Views.GetViewList(True, True)\n    for view in allviews:\n        if old_id:\n            if view.MainViewport.Id==old_id:\n                foundview = view\n                break\n        elif view.MainViewport.Name==old_title:\n            foundview = view\n            break\n    if foundview is None: return scriptcontext.errorhandler()\n    old_title = foundview.MainViewport.Name\n    foundview.MainViewport.Name = new_title\n    return old_title\n\n\ndef RestoreNamedCPlane(cplane_name, view=None):\n    \"\"\"Restores a named construction plane to the specified view.\n    Parameters:\n      cplane_name (str): name of the construction plane to restore\n      view: (str|guid, optional): the title or identifier of the view. If omitted, the current\n            active view is used\n    Returns:\n      str: name of the restored named construction plane if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      cplanes = rs.NamedCplanes()\n      if cplanes: rs.RestoreNamedCPlane( cplanes[0] )\n    See Also:\n      AddNamedCPlane\n      DeleteNamedCPlane\n      NamedCPlane\n      NamedCPlanes\n    \"\"\"\n    view = __viewhelper(view)\n    index = scriptcontext.doc.NamedConstructionPlanes.Find(cplane_name)\n    if index<0: return scriptcontext.errorhandler()\n    cplane = scriptcontext.doc.NamedConstructionPlanes[index]\n    view.MainViewport.PushConstructionPlane(cplane)\n    view.Redraw()\n    return cplane_name\n\n\ndef RestoreNamedView(named_view, view=None, restore_bitmap=False):\n    \"\"\"Restores a named view to the specified view\n    Parameters:\n      named_view (str): name of the named view to restore\n      view (str|guid, optional):  title or id of the view to restore the named view.\n           If omitted, the current active view is used\n      restore_bitmap: (bool, optional): restore the named view's background bitmap\n    Returns:\n      str: name of the restored view if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      views = rs.NamedViews()\n      if views: rs.RestoreNamedView(views[0])\n    See Also:\n      AddNamedView\n      DeleteNamedView\n      NamedViews\n    \"\"\"\n    view = __viewhelper(view)\n    index = scriptcontext.doc.NamedViews.FindByName(named_view)\n    if index<0: return scriptcontext.errorhandler()\n    viewinfo = scriptcontext.doc.NamedViews[index]\n    if view.MainViewport.PushViewInfo(viewinfo, restore_bitmap):\n        view.Redraw()\n        return view.MainViewport.Name\n    return scriptcontext.errorhandler()\n\n\ndef RotateCamera(view=None, direction=0, angle=None):\n    \"\"\"Rotates a perspective-projection view's camera. See the RotateCamera\n    command in the Rhino help file for more details\n    Parameters:\n      view (str|guid, optional):  title or id of the view. If omitted, current active view is used\n      direction(number, optional): the direction to rotate the camera where\n        0=right\n        1=left\n        2=down\n        3=up\n      angle: (number, optional): the angle to rotate. If omitted, the angle of rotation\n            is specified by the \"Increment in divisions of a circle\" parameter\n            specified in Options command's View tab\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      rs.RotateCamera( angle=15 )\n    See Also:\n      RotateView\n      TiltView\n    \"\"\"\n    view = __viewhelper(view)\n    viewport = view.ActiveViewport\n    if angle is None:\n        angle = 2.0*math.pi/Rhino.ApplicationSettings.ViewSettings.RotateCircleIncrement\n    else:\n        angle = Rhino.RhinoMath.ToRadians( abs(angle) )\n    target_distance = (viewport.CameraLocation-viewport.CameraTarget)*viewport.CameraZ\n    axis = viewport.CameraY\n    if direction==0 or direction==2: angle=-angle\n    if direction==0 or direction==1:\n        if Rhino.ApplicationSettings.ViewSettings.RotateToView:\n            axis = viewport.CameraY\n        else:\n            axis = Rhino.Geometry.Vector3d.ZAxis\n    elif direction==2 or direction==3:\n        axis = viewport.CameraX\n    else:\n        return False\n    if Rhino.ApplicationSettings.ViewSettings.RotateReverseKeyboard: angle=-angle\n    rot = Rhino.Geometry.Transform.Rotation(angle, axis, Rhino.Geometry.Point3d.Origin)\n    camUp = rot * viewport.CameraY\n    camDir = -(rot * viewport.CameraZ)\n    target = viewport.CameraLocation + target_distance*camDir\n    viewport.SetCameraLocations(target, viewport.CameraLocation)\n    viewport.CameraUp = camUp\n    view.Redraw()\n    return True\n\n\ndef RotateView(view=None, direction=0, angle=None):\n    \"\"\"Rotates a view. See RotateView command in Rhino help for more information\n    Parameters:\n      view (str|guid, optional): title or id of the view. If omitted, the current active view is used\n      direction (number, optional): the direction to rotate the view where\n            0=right\n            1=left\n            2=down\n            3=up\n      angle (number): angle to rotate. If omitted, the angle of rotation is specified\n            by the \"Increment in divisions of a circle\" parameter specified in\n            Options command's View tab\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      rs.RotateView( angle=90.0 )\n    See Also:\n      RotateCamera\n      TiltView\n    \"\"\"\n    view = __viewhelper(view)\n    viewport = view.ActiveViewport\n    if angle is None:\n        angle = 2.0*math.pi/Rhino.ApplicationSettings.ViewSettings.RotateCircleIncrement\n    else:\n        angle = Rhino.RhinoMath.ToRadians( abs(angle) )\n    if Rhino.ApplicationSettings.ViewSettings.RotateReverseKeyboard: angle = -angle\n    if direction==0: viewport.KeyboardRotate(True, angle)\n    elif direction==1: viewport.KeyboardRotate(True, -angle)\n    elif direction==2: viewport.KeyboardRotate(False, -angle)\n    elif direction==3: viewport.KeyboardRotate(False, angle)\n    else: return False\n    view.Redraw()\n    return True\n\n\ndef ShowGrid(view=None, show=None):\n    \"\"\"Shows or hides a view's construction plane grid\n    Parameters:\n      view (str|guid, optional): title or id of the view. If omitted, the current active view is used\n      show (bool, optional): The grid state to set. If omitted, the current grid display state is returned\n    Returns:\n      bool: If show is not specified, then the grid display state if successful\n      bool: If show is specified, then the previous grid display state if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      if rs.ShowGrid(view)==False:\n          rs.ShowGrid( view, True )\n    See Also:\n      ShowGridAxes\n      ShowWorldAxes\n    \"\"\"\n    view = __viewhelper(view)\n    viewport = view.ActiveViewport\n    rc = viewport.ConstructionGridVisible\n    if show is not None and rc!=show:\n        viewport.ConstructionGridVisible = show\n        view.Redraw()\n    return rc\n\n\ndef ShowGridAxes(view=None, show=None):\n    \"\"\"Shows or hides a view's construction plane grid axes.\n    Parameters:\n      view (str|guid, optional): title or id of the view. If omitted, the current active view is used\n      show (bool, optional): The state to set. If omitted, the current grid axes display state is returned\n    Returns:\n      bool: If show is not specified, then the grid axes display state\n      bool: If show is specified, then the previous grid axes display state\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      if rs.ShowGridAxes(view)==False:\n          rs.ShowGridAxes( view, True )\n    See Also:\n      ShowGrid\n      ShowWorldAxes\n    \"\"\"\n    view = __viewhelper(view)\n    viewport = view.ActiveViewport\n    rc = viewport.ConstructionAxesVisible\n    if show is not None and rc!=show:\n        viewport.ConstructionAxesVisible = show\n        view.Redraw()\n    return rc\n\n\ndef ShowViewTitle(view=None, show=True):\n    \"\"\"Shows or hides the title window of a view\n    Parameters:\n      view (str|guid, optional): title or id of the view. If omitted, the current active view is used\n      show (bool, optional): The state to set.\n    Returns:\n      None\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      if rs.IsViewTitleVisible(view)==False:\n          rs.ShowViewTitle( view, True )\n    See Also:\n      IsViewTitleVisible\n    \"\"\"\n    view = __viewhelper(view)\n    if view is None: return scriptcontext.errorhandler()\n    view.TitleVisible = show\n\n\ndef ShowWorldAxes(view=None, show=None):\n    \"\"\"Shows or hides a view's world axis icon\n    Parameters:\n      view (str|guid, optional):  title or id of the view. If omitted, the current active view is used\n      show: (bool, optional): The state to set.\n    Returns:\n      bool: If show is not specified, then the world axes display state\n      bool: If show is specified, then the previous world axes display state\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      if rs.ShowWorldAxes(view)==False:\n          rs.ShowWorldAxes( view, True )\n    See Also:\n      ShowGrid\n      ShowGridAxes\n    \"\"\"\n    view = __viewhelper(view)\n    viewport = view.ActiveViewport\n    rc = viewport.WorldAxesVisible\n    if show is not None and rc!=show:\n        viewport.WorldAxesVisible = show\n        view.Redraw()\n    return rc\n\n\ndef TiltView(view=None, direction=0, angle=None):\n    \"\"\"Tilts a view by rotating the camera up vector. See the TiltView command in\n    the Rhino help file for more details.\n    Parameters:\n      view (str|guid, optional):  title or id of the view. If omitted, the current active view is used\n      direction (number, optional): the direction to rotate the view where\n        0=right\n        1=left\n      angle (number, optional): the angle to rotate. If omitted, the angle of rotation is\n        specified by the \"Increment in divisions of a circle\" parameter specified\n        in Options command's View tab\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      rs.TiltView( angle=15 )\n    See Also:\n      RotateCamera\n    \"\"\"\n    view = __viewhelper(view)\n    viewport = view.ActiveViewport\n    if angle is None:\n        angle = 2.0*math.pi/Rhino.ApplicationSettings.ViewSettings.RotateCircleIncrement\n    else:\n        angle = Rhino.RhinoMath.ToRadians( abs(angle) )\n    \n    if Rhino.ApplicationSettings.ViewSettings.RotateReverseKeyboard: angle = -angle\n    axis = viewport.CameraLocation - viewport.CameraTarget\n    if direction==0: viewport.Rotate(angle, axis, viewport.CameraLocation)\n    elif direction==1: viewport.Rotate(-angle, axis, viewport.CameraLocation)\n    else: return False\n    view.Redraw()\n    return True\n\n\ndef ViewCamera(view=None, camera_location=None):\n    \"\"\"Returns or sets the camera location of the specified view\n    Parameters:\n      view (str|guid, optional): title or id of the view. If omitted, the current active view is used\n      camera_location (point, optional): a 3D point identifying the new camera location.\n        If omitted, the current camera location is returned\n    Returns:\n      point: If camera_location is not specified, the current camera location\n      point: If camera_location is specified, the previous camera location\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      camera = rs.GetPoint(\"Select new camera location\")\n      if camera: rs.ViewCamera(view,camera)\n    See Also:\n      ViewCameraTarget\n      ViewTarget\n    \"\"\"\n    view = __viewhelper(view)\n    rc = view.ActiveViewport.CameraLocation\n    if camera_location is None: return rc\n    camera_location = rhutil.coerce3dpoint(camera_location)\n    if camera_location is None: return scriptcontext.errorhandler()\n    view.ActiveViewport.SetCameraLocation(camera_location, True)\n    view.Redraw()\n    return rc\n\n\ndef ViewCameraLens(view=None, length=None):\n    \"\"\"Returns or sets the 35mm camera lens length of the specified perspective\n    projection view.\n    Parameters:\n      view (str|guid, optional): title or id of the view. If omitted, the current active view is used\n      length (number, optional): the new 35mm camera lens length. If omitted, the previous\n        35mm camera lens length is returned\n    Returns:\n      number: If lens length is not specified, the current lens length\n      number: If lens length is specified, the previous lens length\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      if rs.IsViewPerspective(view):\n          length = rs.ViewCameraLens(view, 100)\n    See Also:\n      ViewCameraTarget\n      ViewCPlane\n      ViewDisplayModes\n      ViewProjection\n      ViewSize\n    \"\"\"\n    view = __viewhelper(view)\n    rc = view.ActiveViewport.Camera35mmLensLength\n    if not length: return rc\n    view.ActiveViewport.Camera35mmLensLength = length\n    view.Redraw()\n    return rc\n\n\ndef ViewCameraPlane(view=None):\n    \"\"\"Returns the orientation of a view's camera.\n    Parameters:\n      view (str|guid, optional): title or id of the view. If omitted, the current active view is used\n    Returns:\n      plane: the view's camera plane if successful\n      None: on error\n    Example:\n      import rhinocsriptsyntax as rs\n      view = rs.CurrentView()\n      target = rs.ViewTarget(view)\n      camplane = rs.ViewCameraPlane(view)\n      plane = rs.MovePlane(camplane, target)\n      rs.ViewCPlane( view, plane )\n    See Also:\n      ViewCamera\n      ViewTarget\n    \"\"\"\n    view = __viewhelper(view)\n    rc, frame = view.ActiveViewport.GetCameraFrame()\n    if not rc: return scriptcontext.errorhandler()\n    return frame\n\n\ndef ViewCameraTarget(view=None, camera=None, target=None):\n    \"\"\"Returns or sets the camera and target positions of the specified view\n    Parameters:\n      view (str|guid, optional): title or id of the view. If omitted, current active view is used\n      camera (point): 3d point identifying the new camera location. If camera and\n         target are not specified, current camera and target locations are returned\n      target (point): 3d point identifying the new target location. If camera and\n         target are not specified, current camera and target locations are returned\n    Returns:\n      list(point, point): if both camera and target are not specified, then the 3d points containing\n        the current camera and target locations is returned\n      point: if either camera or target are specified, then the 3d points containing the\n        previous camera and target locations is returned\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      camera = rs.GetPoint(\"Select new camera location\")\n      target = rs.GetPoint(\"Select new target location\")\n      if camera and target:\n          rs.ViewCameraTarget( view, camera, target )\n    See Also:\n      ViewCamera\n      ViewTarget\n    \"\"\"\n    view = __viewhelper(view)\n    rc = view.ActiveViewport.CameraLocation, view.ActiveViewport.CameraTarget\n    if not camera and not target: return rc\n    if camera: camera = rhutil.coerce3dpoint(camera, True)\n    if target: target = rhutil.coerce3dpoint(target, True)\n    if camera and target: view.ActiveViewport.SetCameraLocations(target, camera)\n    elif camera is None: view.ActiveViewport.SetCameraTarget(target, True)\n    else: view.ActiveViewport.SetCameraLocation(camera, True)\n    view.Redraw()\n    return rc\n\n\ndef ViewCameraUp(view=None, up_vector=None):\n    \"\"\"Returns or sets the camera up direction of a specified\n    Parameters:\n      view (str|guid, optional): title or id of the view. If omitted, the current active view is used\n      up_vector (vector): 3D vector identifying the new camera up direction\n    Returns:\n      vector: if up_vector is not specified, then the current camera up direction\n      vector: if up_vector is specified, then the previous camera up direction\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      upVector = rs.ViewCameraUp(view)\n      print up_vector\n    See Also:\n      ViewCamera\n      ViewTarget\n    \"\"\"\n    view = __viewhelper(view)\n    rc = view.ActiveViewport.CameraUp\n    if up_vector:\n        view.ActiveViewport.CameraUp = rhutil.coerce3dvector(up_vector, True)\n        view.Redraw()\n    return rc\n\n\ndef ViewCPlane(view=None, plane=None):\n    \"\"\"Return or set a view's construction plane\n    Parameters:\n      view (str|guid, optional): title or id of the view. If omitted, current active view is used.\n      plane (plane): the new construction plane if setting\n    Returns:\n      plane: If a construction plane is not specified, the current construction plane\n      plane: If a construction plane is specified, the previous construction plane\n    Example:\n      import rhinoscriptsyntax as rs\n      origin = rs.GetPoint(\"CPlane origin\")\n      if origin:\n          plane = rs.ViewCPlane()\n          plane = rs.MovePlane(plane,origin)\n          rs.ViewCPlane(None, plane)\n    See Also:\n      ViewCameraLens\n      ViewCameraTarget\n      ViewDisplayModes\n      ViewProjection\n      ViewSize\n    \"\"\"\n    view = __viewhelper(view)\n    cplane = view.ActiveViewport.ConstructionPlane()\n    if plane:\n        plane = rhutil.coerceplane(plane, True)\n        view.ActiveViewport.SetConstructionPlane(plane)\n        view.Redraw()\n    return cplane\n\ndef ViewDisplayMode(view=None, mode=None, return_name=True):\n    \"\"\"Return or set a view display mode\n    Parameters:\n      view (str|guid, optional): Title or id of a view. If omitted, active view is used\n      mode (str|guid, optional): Name or id of a display mode\n      return_name (bool, optional): If true, return display mode name. If False, display mode id\n    Returns:\n      str: If mode is specified, the previous mode\n      str: If mode is not specified, the current mode\n    Example:\n      import rhinoscriptsyntax as rs\n      views = rs.ViewNames()\n      for view in views:\n          rs.ViewDisplayMode(view, 'Ghosted')\n    See Also:\n      CurrentView\n      ViewNames\n    \"\"\"\n    view = __viewhelper(view)\n    current = view.ActiveViewport.DisplayMode\n    if return_name: rc = current.EnglishName\n    else: rc = current.Id\n    if mode:\n        mode_id = rhutil.coerceguid(mode)\n        if mode_id:\n            desc = Rhino.Display.DisplayModeDescription.GetDisplayMode(mode_id)\n        else:\n            desc = Rhino.Display.DisplayModeDescription.FindByName(mode)\n        if desc: view.ActiveViewport.DisplayMode = desc\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ViewDisplayModeId(name):\n    \"\"\"Return id of a display mode given it's name\n    Parameters:\n      name (str): name of the display mode\n    Returns:\n      guid: The id of the display mode if successful, otherwise None\n    Example:\n      import rhinoscriptsyntax as rs\n      modes = rs.ViewDisplayModes(True)\n      for mode in modes: print mode,\"=\",rs.ViewDisplayModeId(mode)\n    See Also:\n      ViewDisplayMode\n      ViewDisplayModes\n    \"\"\"\n    desc = Rhino.Display.DisplayModeDescription.FindByName(name)\n    if desc: return desc.Id\n\n\ndef ViewDisplayModeName(mode_id):\n    \"\"\"Return name of a display mode given it's id\n    Parameters:\n      mode_id (guid): The identifier of the display mode obtained from the ViewDisplayModes method.\n    Returns:\n      str: The name of the display mode if successful, otherwise None\n    Example:\n      import rhinoscriptsyntax as rs\n      modes = rs.ViewDisplayModes(False)\n      for mode in modes: print mode, \"=\", rs.ViewDisplayModeName(mode)\n    See Also:\n      ViewDisplayMode\n      ViewDisplayModes\n    \"\"\"\n    mode_id = rhutil.coerceguid(mode_id, True)\n    desc = Rhino.Display.DisplayModeDescription.GetDisplayMode(mode_id)\n    if desc: return desc.EnglishName\n\n\ndef ViewDisplayModes(return_names=True):\n    \"\"\"Return list of display modes\n    Parameters:\n      return_name (bool, otpional): If True, return mode names. If False, return ids\n    Returns:\n      list(str|guid, ...): strings identifying the display mode names or identifiers if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      modes = rs.ViewDisplayModes(False)\n      for mode in modes: print mode, \"=\", rs.ViewDisplayModeName(mode)\n    See Also:\n      ViewDisplayMode\n      ViewDisplayModeName\n    \"\"\"\n    modes = Rhino.Display.DisplayModeDescription.GetDisplayModes()\n    if return_names:\n        return [mode.EnglishName for mode in modes]\n    return [mode.Id for mode in modes]\n\n\ndef ViewNames(return_names=True, view_type=0):\n    \"\"\"Return the names, titles, or identifiers of all views in the document\n    Parameters:\n      return_names (bool, optional): if True then the names of the views are returned.\n        If False, then the identifiers of the views are returned\n      view_type: (number, optional): the type of view to return\n                       0 = standard model views\n                       1 = page layout views\n                       2 = both standard and page layout views\n    Returns:\n      list(str|guid, ...): of the view names or identifiers on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      # Print view names\n      views = rs.ViewNames()\n      if views:\n          for view in views: print view\n      # Print view identifiers\n      view_ids = rs.ViewNames(False)\n      if view_ids:\n          for id in view_ids:\n              print id, \" = \", rs.ViewTitle(id)\n    See Also:\n      IsView\n      ViewTitle\n    \"\"\"\n    views = scriptcontext.doc.Views.GetViewList(view_type!=1, view_type>0)\n    if views is None: return scriptcontext.errorhandler()\n    if return_names: return [view.MainViewport.Name for view in views]\n    return [view.MainViewport.Id for view in views]\n\n\ndef ViewNearCorners(view=None):\n    \"\"\"Return 3d corners of a view's near clipping plane rectangle. Useful\n    in determining the \"real world\" size of a parallel-projected view\n    Parameters:\n      view (str|guid, optional): title or id of the view. If omitted, current active view is used\n    Returns:\n      list(point, point, point, point): Four Point3d that define the corners of the rectangle (counter-clockwise order)\n    Example:\n      import rhinoscriptsyntax as rs\n      rect = rs.ViewNearCorners()\n      if rect:\n          for i in range(4): rs.AddTextDot( i, rect[i] )\n    See Also:\n      CurrentView\n    \"\"\"\n    view = __viewhelper(view)\n    rc = view.ActiveViewport.GetNearRect()\n    return rc[0], rc[1], rc[3], rc[2]\n\n\ndef ViewProjection(view=None, mode=None):\n    \"\"\"Return or set a view's projection mode.\n    Parameters:\n      view (str|guid, optional): title or id of the view. If omitted, current active view is used\n      mode (number, optional): the projection mode\n        1 = parallel\n        2 = perspective\n        3 = two point perspective\n    Returns:\n      number: if mode is not specified, the current projection mode for the specified view\n      number: if mode is specified, the previous projection mode for the specified view\n    Example:\n      import rhinoscriptsyntax as rs\n      views = rs.ViewNames()\n      if views:\n          for view in views: rs.ViewProjection(view,1)\n    See Also:\n      IsViewPerspective\n    \"\"\"\n    view = __viewhelper(view)\n    viewport = view.ActiveViewport\n    rc = 2\n    if viewport.IsParallelProjection: rc = 1\n    elif viewport.IsTwoPointPerspectiveProjection: rc = 3\n    if mode is None or mode==rc: return rc\n    if mode==1: viewport.ChangeToParallelProjection(True)\n    elif mode==2: viewport.ChangeToPerspectiveProjection(True, 50)\n    elif mode==3: viewport.ChangeToTwoPointPerspectiveProjection(50)\n    else: return\n    view.Redraw()\n    return rc\n\ndef ViewRadius(view=None, radius=None, mode=False):\n    \"\"\"Returns or sets the radius of a parallel-projected view. Useful\n    when you need an absolute zoom factor for a parallel-projected view\n    Parameters:\n      view (str|guid, optional): title or id of the view. If omitted, current active view is used\n      radius (number): the view radius\n      mode (bool, optional): perform a \"dolly\" magnification by moving the camera\n        towards/away from the target so that the amount of the screen \n        subtended by an object changes.  true = perform a \"zoom\" \n        magnification by adjusting the \"lens\" angle\n    Returns:\n      number: if radius is not specified, the current view radius for the specified view\n      number: if radius is specified, the previous view radius for the specified view\n    Example:\n      import rhinoscriptsyntax as rs\n      rhParallelView = 1\n      views = rs.ViewNames()\n      if views:\n          for view in views:\n              if rs.ViewProjection(view)==rhParallelView:\n                  rs.ViewRadius(view, 10.0)\n    See Also:\n      IsViewPerspective\n      ViewProjection\n    \"\"\"\n    view = __viewhelper(view)\n    viewport = view.ActiveViewport\n    if not viewport.IsParallelProjection: return scriptcontext.errorhandler()\n    fr = viewport.GetFrustum()\n    frus_right = fr[2]\n    frus_top = fr[4]\n    old_radius = min(frus_top, frus_right)\n    if radius is None: return old_radius\n    magnification_factor = radius / old_radius\n    d = 1.0 / magnification_factor\n    viewport.Magnify(d, mode)\n    view.Redraw()\n    return old_radius\n\n\ndef ViewSize(view=None):\n    \"\"\"Returns the width and height in pixels of the specified view\n    Parameters:\n      view (str|guid): title or id of the view. If omitted, current active view is used\n    Returns:\n      tuple(number, number): of two numbers identifying width and height\n    Example:\n      import rhinoscriptsyntax as rs\n      size = rs.ViewSize()\n      if size:\n          print \"Width: \", size[0], \" pixels.\"\n          print \"Height: \", size[1], \" pixels.\"\n    See Also:\n      ViewCameraLens\n      ViewCameraTarget\n      ViewCPlane\n      ViewDisplayModes\n      ViewProjection\n    \"\"\"\n    view = __viewhelper(view)\n    cr = view.ClientRectangle\n    return cr.Width, cr.Height\n\n\ndef ViewSpeedTest(view=None, frames=100, freeze=True, direction=0, angle_degrees=5):\n    \"\"\"Test's Rhino's display performance\n    Parameters:\n      view (str|guid, optional): The title or identifier of the view.  If omitted, the current active view is used\n      frames (number, optional): The number of frames, or times to regenerate the view. If omitted, the view will be regenerated 100 times.\n      freeze (bool, optional): If True (Default), then Rhino's display list will not be updated with every frame redraw. If False, then Rhino's display list will be updated with every frame redraw.\n      direction (number, optional): The direction to rotate the view. The default direction is Right (0). Modes:\n        0 = Right\n        1 = Left\n        2 = Down\n        3 = Up.\n      angle_degrees (number, optional): The angle to rotate. If omitted, the rotation angle of 5.0 degrees will be used.\n    Returns:\n      number: The number of seconds it took to regenerate the view frames number of times, if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      view = \"Perspective\"\n      seconds = rs.ViewSpeedTest(view, 100)\n      if seconds:\n          print \"Time to regen viewport 100 times =\", seconds, \"seconds.\"\n    See Also:\n      \n    \"\"\"\n    view = __viewhelper(view)\n    angle_radians = math.radians(angle_degrees)\n    return view.SpeedTest(frames, freeze, direction, angle_radians)\n\n\ndef ViewTarget(view=None, target=None):\n    \"\"\"Returns or sets the target location of the specified view\n    Parameters:\n      view (str|guid, optional): title or id of the view. If omitted, current active view is used\n      target (point, optional): 3d point identifying the new target location. If omitted,\n        the current target location is returned\n    Returns:\n      point: is target is not specified, then the current target location\n      point: is target is specified, then the previous target location\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      target = rs.GetPoint(\"Select new target location\")\n      if target: rs.ViewTarget( view, target )\n    See Also:\n      ViewCamera\n      ViewCameraTarget\n    \"\"\"\n    view = __viewhelper(view)\n    viewport = view.ActiveViewport\n    old_target = viewport.CameraTarget\n    if target is None: return old_target\n    target = rhutil.coerce3dpoint(target)\n    if target is None: return scriptcontext.errorhandler()\n    viewport.SetCameraTarget(target, True)\n    view.Redraw()\n    return old_target\n\n\ndef ViewTitle(view_id):\n    \"\"\"Returns the name, or title, of a given view's identifier\n    Parameters:\n      view_id (str|guid): The identifier of the view\n    Returns:\n      str: name or title of the view on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      view_ids = rs.ViewNames(False)\n      for id in view_ids:\n          print id + \" = \" + rs.ViewTitle(id)\n    See Also:\n      CurrentView\n      ViewNames\n    \"\"\"\n    view_id = rhutil.coerceguid(view_id)\n    if view_id is None: return scriptcontext.errorhandler()\n    view = scriptcontext.doc.Views.Find(view_id)\n    if view is None: return scriptcontext.errorhandler()\n    return view.MainViewport.Name\n\n\ndef Wallpaper(view=None, filename=None):\n    \"\"\"Returns or sets the wallpaper bitmap of the specified view. To remove a\n    wallpaper bitmap, pass an empty string \"\"\n    Parameters:\n      view (str|guid, optional): The identifier of the view. If omitted, the\n        active view is used\n      filename (str): Name of the bitmap file to set as wallpaper\n    Returns:\n      str: If filename is not specified, the current wallpaper bitmap filename\n      str: If filename is specified, the previous wallpaper bitmap filename\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      filename = rs.OpenFileName()\n      if filename and not rs.IsWallpaper(view):\n          rs.Wallpaper(view, filename)\n    See Also:\n      IsWallpaper\n      WallpaperGrayScale\n      WallpaperHidden\n    \"\"\"\n    view = __viewhelper(view)\n    rc = view.ActiveViewport.WallpaperFilename\n    if filename is not None and filename!=rc:\n        view.ActiveViewport.SetWallpaper(filename, False)\n        view.Redraw()\n    return rc\n\n\ndef WallpaperGrayScale(view=None, grayscale=None):\n    \"\"\"Returns or sets the grayscale display option of the wallpaper bitmap in a\n    specified view\n    Parameters:\n      view (str|guid, optional):  The identifier of the view. If omitted, the\n        active view is used\n      grayscale (bool, optional): Display the wallpaper in gray(True) or color (False)\n    Returns:\n      bool: If grayscale is not specified, the current grayscale display option\n      bool: If grayscale is specified, the previous grayscale display option\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      if rs.WallpaperGrayScale(view)==False: rs.WallpaperGrayScale(view, True)\n    See Also:\n      Wallpaper\n      WallpaperHidden\n    \"\"\"\n    view = __viewhelper(view)\n    rc = view.ActiveViewport.WallpaperGrayscale\n    if grayscale is not None and grayscale!=rc:\n        filename = view.ActiveViewport.WallpaperFilename\n        view.ActiveViewport.SetWallpaper(filename, grayscale)\n        view.Redraw()\n    return rc\n\n\ndef WallpaperHidden(view=None, hidden=None):\n    \"\"\"Returns or sets the visibility of the wallpaper bitmap in a specified view\n    Parameters:\n      view (str|guid, optional): The identifier of the view. If omitted, the\n        active view is used\n      hidden (bool, optional): Show or hide the wallpaper\n    Returns:\n      bool: If hidden is not specified, the current hidden state\n      bool: If hidden is specified, the previous hidden state\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      if rs.WallpaperHidden(view) == False: rs.WallpaperHidden(view, True)\n    See Also:\n      Wallpaper\n      WallpaperGrayScale\n    \"\"\"\n    view = __viewhelper(view)\n    rc = not view.ActiveViewport.WallpaperVisible\n    if hidden is not None and hidden!=rc:\n        filename = view.ActiveViewport.WallpaperFilename\n        gray = view.ActiveViewport.WallpaperGrayscale\n        view.ActiveViewport.SetWallpaper(filename, gray, not hidden)\n        view.Redraw()\n    return rc\n\n\ndef ZoomBoundingBox(bounding_box, view=None, all=False):\n    \"\"\"Zooms to the extents of a specified bounding box in the specified view\n    Parameters:\n      bounding_box ([point, point, point ,point, point, point, point, point]): eight points that define the corners\n        of a bounding box or a BoundingBox class instance\n      view  (str|guid, optional): title or id of the view. If omitted, current active view is used\n      all (bool, optional): zoom extents in all views\n    Returns:\n      None\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject()\n      if obj:\n          bbox = rs.BoundingBox(obj)\n          rs.ZoomBoundingBox( bbox )\n    See Also:\n      ZoomExtents\n      ZoomSelected\n    \"\"\"\n    bbox = rhutil.coerceboundingbox(bounding_box)\n    if bbox:\n      if all:\n          views = scriptcontext.doc.Views.GetViewList(True, True)\n          for view in views: view.ActiveViewport.ZoomBoundingBox(bbox)\n      else:\n          view = __viewhelper(view)\n          view.ActiveViewport.ZoomBoundingBox(bbox)\n      scriptcontext.doc.Views.Redraw()\n\n\ndef ZoomExtents(view=None, all=False):\n    \"\"\"Zooms to extents of visible objects in the specified view\n    Parameters:\n      view  (str|guid, optional): title or id of the view. If omitted, current active view is used\n      all (bool, optional): zoom extents in all views\n    Returns:\n      None\n    Example:\n      import rhinoscriptsyntax as rs\n      rs.ZoomExtents()\n    See Also:\n      ZoomBoundingBox\n      ZoomSelected\n    \"\"\"\n    if all:\n        views = scriptcontext.doc.Views.GetViewList(True, True)\n        for view in views: view.ActiveViewport.ZoomExtents()\n    else:\n        view = __viewhelper(view)\n        view.ActiveViewport.ZoomExtents()\n    scriptcontext.doc.Views.Redraw()\n\n\ndef ZoomSelected(view=None, all=False):\n    \"\"\"Zoom to extents of selected objects in a view\n    Parameters:\n      view  (str|guid, optional): title or id of the view. If omitted, active view is used\n      all (bool, optional): zoom extents in all views\n    Returns:\n      None\n    Example:\n      import rhinocriptsyntax as rs\n      obj = rs.GetObject(\"Select object\", select=True)\n      if obj: rs.ZoomSelected()\n    See Also:\n      ZoomBoundingBox\n      ZoomExtents\n    \"\"\"\n    if all:\n        views = scriptcontext.doc.Views.GetViewList(True, True)\n        for view in views: view.ActiveViewport.ZoomExtentsSelected()\n    else:\n        view = __viewhelper(view)\n        view.ActiveViewport.ZoomExtentsSelected()\n    scriptcontext.doc.Views.Redraw()\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "classes", "point", "functions", "RhinoCommon"], "original_file": "mahaidong_p4r-vscode_ebb41c5542.json", "repo": "mahaidong/p4r-vscode"}
{"instruction": "Returns the distance from a 3D point to a plane", "code": "import utility as rhutil\nimport Rhino.Geometry\nimport scriptcontext\nimport math\n\ndef DistanceToPlane(plane, point):\n    \"\"\"Returns the distance from a 3D point to a plane\n    Parameters:\n      plane (plane): the plane\n      point (point): List of 3 numbers or Point3d\n    Returns:\n      number: The distance if successful, otherwise None\n    Example:\n      import rhinoscriptsyntax as rs\n      point = rs.GetPoint(\"Point to test\")\n      if point:\n          plane = rs.ViewCPlane()\n          if plane:\n              distance = rs.DistanceToPlane(plane, point)\n              if distance is not None:\n                  print \"Distance to plane: \", distance\n    See Also:\n      Distance\n      PlaneClosestPoint\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    point = rhutil.coerce3dpoint(point, True)\n    return plane.DistanceTo(point)\n\n\ndef EvaluatePlane(plane, parameter):\n    \"\"\"Evaluates a plane at a U,V parameter\n    Parameters:\n      plane (plane): the plane to evaluate\n      parameter ([number, number]): list of two numbers defining the U,V parameter to evaluate\n    Returns:\n      point: Point3d on success\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      plane = rs.ViewCPlane(view)\n      point = rs.EvaluatePlane(plane, (5,5))\n      rs.AddPoint( point )\n    See Also:\n      PlaneClosestPoint\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    return plane.PointAt(parameter[0], parameter[1])\n\n\ndef IntersectPlanes(plane1, plane2, plane3):\n    \"\"\"Calculates the intersection of three planes\n    Parameters:\n      plane1 (plane): the 1st plane to intersect\n      plane2 (plane): the 2nd plane to intersect\n      plane3 (plane): the 3rd plane to intersect\n    Returns:\n      point: the intersection point between the 3 planes on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      plane1 = rs.WorldXYPlane()\n      plane2 = rs.WorldYZPlane()\n      plane3 = rs.WorldZXPlane()\n      point = rs.IntersectPlanes(plane1, plane2, plane3)\n      if point: rs.AddPoint(point)\n    See Also:\n      LineLineIntersection\n      LinePlaneIntersection\n      PlanePlaneIntersection\n    \"\"\"\n    plane1 = rhutil.coerceplane(plane1, True)\n    plane2 = rhutil.coerceplane(plane2, True)\n    plane3 = rhutil.coerceplane(plane3, True)\n    rc, point = Rhino.Geometry.Intersect.Intersection.PlanePlanePlane(plane1, plane2, plane3)\n    if rc: return point\n\n\ndef MovePlane(plane, origin):\n    \"\"\"Moves the origin of a plane\n    Parameters:\n      plane (plane): Plane or ConstructionPlane\n      origin (point): Point3d or list of three numbers\n    Returns:\n      plane: moved plane\n    Example:\n      import rhinoscriptsyntax as rs\n      origin = rs.GetPoint(\"CPlane origin\")\n      if origin:\n          plane = rs.ViewCPlane()\n          plane = rs.MovePlane(plane,origin)\n          rs.ViewCplane(plane)\n    See Also:\n      PlaneFromFrame\n      PlaneFromNormal\n      RotatePlane\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    origin = rhutil.coerce3dpoint(origin, True)\n    rc = Rhino.Geometry.Plane(plane)\n    rc.Origin = origin\n    return rc\n\n\ndef PlaneClosestPoint(plane, point, return_point=True):\n    \"\"\"Returns the point on a plane that is closest to a test point.\n    Parameters:\n      plane (plane): The plane\n      point (point): The 3-D point to test.\n      return_point (bool, optional): If omitted or True, then the point on the plane\n         that is closest to the test point is returned. If False, then the\n         parameter of the point on the plane that is closest to the test\n         point is returned.\n    Returns:\n      point: If return_point is omitted or True, then the 3-D point\n      point: If return_point is False, then an array containing the U,V parameters\n      of the point\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      point = rs.GetPoint(\"Point to test\")\n      if point:\n          plane = rs.ViewCPlane()\n          if plane:\n              print rs.PlaneClosestPoint(plane, point)\n    See Also:\n      DistanceToPlane\n      EvaluatePlane\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    point = rhutil.coerce3dpoint(point, True)\n    if return_point:\n        return plane.ClosestPoint(point)\n    else:\n        rc, s, t = plane.ClosestParameter(point)\n        if rc: return s, t\n\n\ndef PlaneCurveIntersection(plane, curve, tolerance=None):\n    \"\"\"Intersect an infinite plane and a curve object\n    Parameters:\n      plane (plane): The plane to intersect.\n      curve (guid): The identifier of the curve object\n      torerance (number, optional): The intersection tolerance. If omitted, the document's absolute tolerance is used.\n    Returns:\n      A list of intersection information tuple if successful.  The list will contain one or more of the following tuple:\n\n        Element Type        Description\n\n        [0]       Number      The intersection event type, either Point (1) or Overlap (2).\n\n        [1]       Point3d     If the event type is Point (1), then the intersection point on the curve.\n                            If the event type is Overlap (2), then intersection start point on the curve.\n\n        [2]       Point3d     If the event type is Point (1), then the intersection point on the curve.\n                            If the event type is Overlap (2), then intersection end point on the curve.\n\n        [3]       Point3d     If the event type is Point (1), then the intersection point on the plane.\n                            If the event type is Overlap (2), then intersection start point on the plane.\n\n        [4]       Point3d     If the event type is Point (1), then the intersection point on the plane.\n\n                            If the event type is Overlap (2), then intersection end point on the plane.\n\n        [5]       Number      If the event type is Point (1), then the curve parameter.\n                            If the event type is Overlap (2), then the start value of the curve parameter range.\n                            \n        [6]       Number      If the event type is Point (1), then the curve parameter.\n                            If the event type is Overlap (2),  then the end value of the curve parameter range.\n\n        [7]       Number      If the event type is Point (1), then the U plane parameter.\n                            If the event type is Overlap (2), then the U plane parameter for curve at (n, 5).\n\n        [8]       Number      If the event type is Point (1), then the V plane parameter.\n                            If the event type is Overlap (2), then the V plane parameter for curve at (n, 5).\n\n        [9]       Number      If the event type is Point (1), then the U plane parameter.\n                            If the event type is Overlap (2), then the U plane parameter for curve at (n, 6).\n                            \n        [10]      Number      If the event type is Point (1), then the V plane parameter.\n                            If the event type is Overlap (2), then the V plane parameter for curve at (n, 6).\n\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if curve:\n          plane = rs.WorldXYPlane()\n          intersections = rs.PlaneCurveIntersection(plane, curve)\n          if intersections:\n              for intersection in intersections:\n                  rs.AddPoint(intersection[1])\n    See Also:\n      IntersectPlanes\n      PlanePlaneIntersection\n      PlaneSphereIntersection\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    curve = rhutil.coercecurve(curve, -1, True)\n    if tolerance is None: tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    intersections = Rhino.Geometry.Intersect.Intersection.CurvePlane(curve, plane, tolerance)\n    if intersections:\n        rc = []\n        for intersection in intersections:\n            a = 1\n            if intersection.IsOverlap: a = 2\n            b = intersection.PointA\n            c = intersection.PointA2\n            d = intersection.PointB\n            e = intersection.PointB2\n            f = intersection.ParameterA\n            g = intersection.ParameterB\n            h = intersection.OverlapA[0]\n            i = intersection.OverlapA[1]\n            j = intersection.OverlapB[0]\n            k = intersection.OverlapB[1]\n            rc.append( (a,b,c,d,e,f,g,h,i,j,k) )\n        return rc\n\n\ndef PlaneEquation(plane):\n    \"\"\"Returns the equation of a plane as a tuple of four numbers. The standard\n    equation of a plane with a non-zero vector is Ax+By+Cz+D=0\n    Parameters:\n      plane (plane): the plane to deconstruct\n    Returns:\n      tuple(number, number, number, number): containing four numbers that represent the coefficients of the equation  (A, B, C, D) if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.ViewCPlane()\n      equation = rs.PlaneEquation(plane)\n      print \"A =\", equation[0]\n      print \"B =\", equation[1]\n      print \"C =\", equation[2]\n      print \"D =\", equation[3]\n    See Also:\n      PlaneFromFrame\n      PlaneFromNormal\n      PlaneFromPoints\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    rc = plane.GetPlaneEquation()\n    return rc[0], rc[1], rc[2], rc[3]\n\n\ndef PlaneFitFromPoints(points):\n    \"\"\"Returns a plane that was fit through an array of 3D points.\n    Parameters:\n    points (point): An array of 3D points.\n    Returns: \n      plane: The plane if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      points = rs.GetPoints()\n      if points:\n          plane = rs.PlaneFitFromPoints(points)\n          if plane:\n              magX = plane.XAxis.Length\n              magY = plane.YAxis.Length\n              rs.AddPlaneSurface( plane, magX, magY )\n    See Also:\n      PlaneFromFrame\n      PlaneFromNormal\n      PlaneFromPoints\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    rc, plane = Rhino.Geometry.Plane.FitPlaneToPoints(points)\n    if rc==Rhino.Geometry.PlaneFitResult.Success: return plane\n\n\ndef PlaneFromFrame(origin, x_axis, y_axis):\n    \"\"\"Construct a plane from a point, and two vectors in the plane.\n    Parameters:\n      origin (point): A 3D point identifying the origin of the plane.\n      x_axis (vector): A non-zero 3D vector in the plane that determines the X axis\n               direction.\n      y_axis (vector): A non-zero 3D vector not parallel to x_axis that is used\n               to determine the Y axis direction. Note, y_axis does not\n               have to be perpendicular to x_axis.\n    Returns:\n      plane: The plane if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      origin = rs.GetPoint(\"CPlane origin\")\n      if origin:\n          xaxis = (1,0,0)\n          yaxis = (0,0,1)\n          plane = rs.PlaneFromFrame( origin, xaxis, yaxis )\n          rs.ViewCPlane(None, plane)\n    See Also:\n      MovePlane\n      PlaneFromNormal\n      PlaneFromPoints\n      RotatePlane\n    \"\"\"\n    origin = rhutil.coerce3dpoint(origin, True)\n    x_axis = rhutil.coerce3dvector(x_axis, True)\n    y_axis = rhutil.coerce3dvector(y_axis, True)\n    return Rhino.Geometry.Plane(origin, x_axis, y_axis)\n\n\ndef PlaneFromNormal(origin, normal, xaxis=None):\n    \"\"\"Creates a plane from an origin point and a normal direction vector.\n    Parameters:\n      origin (point): A 3D point identifying the origin of the plane.\n      normal (vector): A 3D vector identifying the normal direction of the plane.\n      xaxis (vector, optional): optional vector defining the plane's x-axis\n    Returns:\n      plane: The plane if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      origin = rs.GetPoint(\"CPlane origin\")\n      if origin:\n          direction = rs.GetPoint(\"CPlane direction\")\n          if direction:\n              normal = direction - origin\n              normal = rs.VectorUnitize(normal)\n              rs.ViewCPlane( None, rs.PlaneFromNormal(origin, normal) )\n    See Also:\n      MovePlane\n      PlaneFromFrame\n      PlaneFromPoints\n      RotatePlane\n    \"\"\"\n    origin = rhutil.coerce3dpoint(origin, True)\n    normal = rhutil.coerce3dvector(normal, True)\n    rc = Rhino.Geometry.Plane(origin, normal)\n    if xaxis:\n        xaxis = rhutil.coerce3dvector(xaxis, True)\n        xaxis = Rhino.Geometry.Vector3d(xaxis)#prevent original xaxis parameter from being unitized too\n        xaxis.Unitize()\n        yaxis = Rhino.Geometry.Vector3d.CrossProduct(rc.Normal, xaxis)\n        rc = Rhino.Geometry.Plane(origin, xaxis, yaxis)\n    return rc\n\n\ndef PlaneFromPoints(origin, x, y):\n    \"\"\"Creates a plane from three non-colinear points\n    Parameters:\n      origin (point): origin point of the plane\n      x, y (point): points on the plane's x and y axes\n    Returns:\n      plane: The plane if successful, otherwise None\n    Example:\n      import rhinoscriptsyntax as rs\n      corners = rs.GetRectangle()\n      if corners:\n          rs.ViewCPlane( rs.PlaneFromPoints(corners[0], corners[1], corners[3]))\n    See Also:\n      PlaneFromFrame\n      PlaneFromNormal\n    \"\"\"\n    origin = rhutil.coerce3dpoint(origin, True)\n    x = rhutil.coerce3dpoint(x, True)\n    y = rhutil.coerce3dpoint(y, True)\n    plane = Rhino.Geometry.Plane(origin, x, y)\n    if plane.IsValid: return plane\n\n\ndef PlanePlaneIntersection(plane1, plane2):\n    \"\"\"Calculates the intersection of two planes\n    Parameters:\n      plane1 (plane): the 1st plane to intersect\n      plane2 (plane): the 2nd plane to intersect\n    Returns:\n      line:  a line with two 3d points identifying the starting/ending points of the intersection\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      plane1 = rs.WorldXYPlane()\n      plane2 = rs.WorldYZPlane()\n      line = rs.PlanePlaneIntersection(plane1, plane2)\n      if line: rs.AddLine(line[0], line[1])\n    See Also:\n      IntersectPlanes\n      LineLineIntersection\n      LinePlaneIntersection\n    \"\"\"\n    plane1 = rhutil.coerceplane(plane1, True)\n    plane2 = rhutil.coerceplane(plane2, True)\n    rc, line = Rhino.Geometry.Intersect.Intersection.PlanePlane(plane1, plane2)\n    if rc: return line.From, line.To\n\n\ndef PlaneSphereIntersection(plane, sphere_plane, sphere_radius):\n    \"\"\"Calculates the intersection of a plane and a sphere\n    Parameters:\n      plane (plane): the plane to intersect\n      sphere_plane (plane): equatorial plane of the sphere. origin of the plane is\n        the center of the sphere\n      sphere_radius (number): radius of the sphere\n    Returns:\n      list(number, point|plane, number): of intersection results\n          Element    Type      Description\n          [0]       number     The type of intersection, where 0 = point and 1 = circle.\n          [1]   point or plane If a point intersection, the a Point3d identifying the 3-D intersection location.\n                               If a circle intersection, then the circle's plane. The origin of the plane will be the center point of the circle\n          [2]       number     If a circle intersection, then the radius of the circle.\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.WorldXYPlane()\n      radius = 10\n      results = rs.PlaneSphereIntersection(plane, plane, radius)\n      if results:\n          if results[0]==0:\n              rs.AddPoint(results[1])\n          else:\n              rs.AddCircle(results[1], results[2])\n    See Also:\n      IntersectPlanes\n      LinePlaneIntersection\n      PlanePlaneIntersection\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    sphere_plane = rhutil.coerceplane(sphere_plane, True)\n    sphere = Rhino.Geometry.Sphere(sphere_plane, sphere_radius)\n    rc, circle = Rhino.Geometry.Intersect.Intersection.PlaneSphere(plane, sphere)\n    if rc==Rhino.Geometry.Intersect.PlaneSphereIntersection.Point:\n        return 0, circle.Center\n    if rc==Rhino.Geometry.Intersect.PlaneSphereIntersection.Circle:\n        return 1, circle.Plane, circle.Radius\n\n\ndef PlaneTransform(plane, xform):\n    \"\"\"Transforms a plane\n    Parameters:\n      plane (plane): Plane to transform\n      xform (transform): Transformation to apply\n    Returns:\n      plane:the resulting plane if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.ViewCPlane()\n      xform = rs.XformRotation(45.0, plane.Zaxis, plane.Origin)\n      plane = rs.PlaneTransform(plane, xform)\n      rs.ViewCPlane(None, plane)\n    See Also:\n      PlaneFromFrame\n      PlaneFromNormal\n      PlaneFromPoints\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    xform = rhutil.coercexform(xform, True)\n    rc = Rhino.Geometry.Plane(plane)\n    if rc.Transform(xform): return rc\n\n\ndef RotatePlane(plane, angle_degrees, axis):\n    \"\"\"Rotates a plane\n    Parameters:\n      plane (plane): Plane to rotate\n      angle_degrees (number): rotation angle in degrees\n      axis (vector): Axis of rotation or list of three numbers\n    Returns:\n      plane: rotated plane on success\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.ViewCPlane()\n      rotated = rs.RotatePlane(plane, 45.0, plane.XAxis)\n      rs.ViewCPlane( None, rotated )\n    See Also:\n      MovePlane\n      PlaneFromFrame\n      PlaneFromNormal\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    axis = rhutil.coerce3dvector(axis, True)\n    angle_radians = math.radians(angle_degrees)\n    rc = Rhino.Geometry.Plane(plane)\n    if rc.Rotate(angle_radians, axis): return rc\n\n\ndef WorldXYPlane():\n    \"\"\"Returns Rhino's world XY plane\n    Returns:\n      plane: Rhino's world XY plane\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      rs.ViewCPlane( view, rs.WorldXYPlane() )\n    See Also:\n      WorldYZPlane\n      WorldZXPlane\n    \"\"\"\n    return Rhino.Geometry.Plane.WorldXY\n\n\ndef WorldYZPlane():\n    \"\"\"Returns Rhino's world YZ plane\n    Returns:\n      plane: Rhino's world YZ plane\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      rs.ViewCPlane( view, rs.WorldYZPlane() )\n    See Also:\n      WorldXYPlane\n      WorldZXPlane\n    \"\"\"\n    return Rhino.Geometry.Plane.WorldYZ\n\n\ndef WorldZXPlane():\n    \"\"\"Returns Rhino's world ZX plane\n    Returns:\n      plane: Rhino's world ZX plane\n    Example:\n      import rhinoscriptsyntax as rs\n      view = rs.CurrentView()\n      rs.ViewCPlane( view, rs.WorldZXPlane() )\n    See Also:\n      WorldXYPlane\n      WorldYZPlane\n    \"\"\"\n    return Rhino.Geometry.Plane.WorldZX", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "surface", "point", "line", "curve", "functions", "RhinoCommon"], "original_file": "mahaidong_p4r-vscode_ff926d1e60.json", "repo": "mahaidong/p4r-vscode"}
{"instruction": "This object represents a License object for your product. See https://developer.rhino3d.com/guides/rhinocommon/cloudzoo/cloudzoo-license/ for details on a license object.", "code": "from flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask import jsonify\nfrom os import environ\nimport datetime\nimport time\nfrom functools import wraps\nfrom flask import request\nfrom flask_talisman import Talisman\n\napp = Flask(__name__)\nTalisman(app)\ndb_uri = environ.get('DATABASE_URL')\nif not db_uri:\n    db_uri = 'sqlite:///test.db' # local dev\nelif db_uri.startswith(\"postgres://\"):\n    # https://help.heroku.com/ZKNTJQSK/why-is-sqlalchemy-1-4-x-not-connecting-to-heroku-postgres\n    db_uri = db_uri.replace(\"postgres://\", \"postgresql://\", 1)\napp.config['SQLALCHEMY_DATABASE_URI'] = db_uri\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\ndb = SQLAlchemy(app)\napp.config['JSONIFY_PRETTYPRINT_REGULAR'] = True\napp.config['JSON_SORT_KEYS'] = False\n\nISSUER_ID = environ.get('ISSUER_ID')\nISSUER_SECRET = environ.get('ISSUER_SECRET')\nISSUER_NAME = environ.get('ISSUER_NAME') or \"Dolfinito\"\nISSUER_SUPPORT_URL = environ.get('ISSUER_SUPPORT_URL') or \"https://www.dolfinito.com/support\"\n\n################################################## DATABSE CODE ########################################################\n\n\nclass License(db.Model):\n    __tablename__ = 'licenses'\n    \"\"\"This object represents a License object for your product. See https://developer.rhino3d.com/guides/rhinocommon/cloudzoo/cloudzoo-license/ for details on a license object.\"\"\"\n    serial = db.Column(db.String(), primary_key=True)\n    key = db.Column(db.String(), unique=True, nullable=False)\n    product_id = db.Column(db.String(), nullable=False)\n    entity_id = db.Column(db.String(), nullable=True)\n    enabled = db.Column(db.Boolean, nullable=False)\n    number_of_seats = db.Column(db.Integer(), nullable=False, default=1)\n    expiration_date = db.Column(db.DateTime(), nullable=True)\n    is_upgrade = db.Column(db.Boolean, nullable=False, default=False)\n    upgrade_from_key = db.Column(db.String(), nullable=True)\n    date = db.Column(db.DateTime(), nullable=True, onupdate=datetime.datetime.utcnow)\n\n    def to_json_dict(self):\n        return {\n            \"id\": self.serial,\n            \"key\": self.key,\n            \"aud\": self.product_id,\n            \"iss\": ISSUER_ID,\n            \"exp\": int(time.mktime(self.expiration_date.timetuple())) if self.expiration_date is not None else None,\n            \"numberOfSeats\": self.number_of_seats,\n            \"editions\": {\"en\": \"Full Edition\"},\n            \"metadata\": None\n        }\n\n    def __repr__(self):\n        return '<License %r>' % self.serial\n\n@app.cli.command()\ndef create_db():\n    \"\"\"This method simply creates some dummy licenses for demo purposes and inserts them into the database.\"\"\"\n    db.create_all()\n\n    license_1 = License(\n        key=\"LICENSE_KEY_1\",\n        serial=\"SERIAL_NO_1\",\n        product_id=\"3e200daa-6bf8-470b-bd6a-4f55996052c3\",\n        enabled=True\n    )\n\n    license_2 = License(\n        key=\"LICENSE_KEY_2\",\n        serial=\"SERIAL_NO_2\",\n        product_id=\"3e200daa-6bf8-470b-bd6a-4f55996052c3\",\n        enabled=False\n    )\n\n    license_3 = License(\n        key=\"LICENSE_KEY_3\",\n        serial=\"SERIAL_NO_3\",\n        product_id=\"3e200daa-6bf8-470b-bd6a-4f55996052c3\",\n        enabled=True,\n        entity_id=\"595959595959595-|-User\",\n        date=datetime.datetime(year=2018,month=11,day=30)\n    )\n\n    db.session.add(license_1)\n    db.session.add(license_2)\n    db.session.add(license_3)\n    db.session.commit()\n\n\n########################################### AUTHENTICATION CODE ########################################################\n\n\ndef check_auth(issuer_id, secret):\n    \"\"\"This function is called to check if a issuer_id /\n    secret combination is valid.\n    \"\"\"\n    return issuer_id == ISSUER_ID and secret == ISSUER_SECRET\n\ndef authenticate():\n    \"\"\"Sends a 401 response that enables basic auth\"\"\"\n    return (\n        jsonify({\"description\": \"Incorrect Credentials\"}),\n        401,\n        {'WWW-Authenticate': 'Basic realm=\"Credentials Required\"'})\n\ndef requires_auth(f):\n    \"\"\"A convenience decorator that makes it simple to enforce authentication on enddpoints.\"\"\"\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        auth = request.authorization\n        if not auth or not check_auth(auth.username, auth.password):\n            return authenticate()\n        return f(*args, **kwargs)\n    return decorated\n\n\n##################################################### ENDPOINTS ########################################################\n\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello World!\"\n\n@app.route(\"/info\")\ndef info():\n    licenses = License.query.all()\n    return \"You have {} licenses!\".format(len(licenses))\n\n\n@app.route(\"/add_license\", methods=[\"POST\"])\n@requires_auth\ndef add_license():\n    \"\"\"See if a license can be added to an entity or whether we should ask more information, or whether we should\n    deny the request. Note that you may have additional requirements depending on your business requirements.\n    See more info about this endpoint at: https://developer.rhino3d.com/guides/rhinocommon/cloudzoo/cloudzoo-implement-http-callbacks/#post-add_license\"\"\"\n    payload_dict = request.get_json()\n    product_id = payload_dict['license'].get(\"aud\")\n    key = payload_dict['license'].get(\"key\")\n    entity_id = payload_dict.get(\"entityId\")\n    precondition = payload_dict.get(\"precondition\")\n\n    license = License.query.filter_by(key=key, product_id=product_id).first()\n\n    #Add non-existing license.\n    if license is None:\n        return (\n            jsonify({\"description\": \"The license key '{}' is not a valid license\".format(key)}),\n            409\n        )\n\n    #Add disabled license.\n    if not license.enabled:\n        return (\n            jsonify({\"description\": \"The license key '{}' cannot be added at this time. Please contact \"\n                                    \"[{}]({}) for assistance.\".format(key, ISSUER_NAME, ISSUER_SUPPORT_URL)}),\n            409\n        )\n\n    #Add license to different entity.\n    if license.entity_id is not None and license.entity_id != entity_id:\n        return (\n            jsonify({\"description\": \"The license key '{}' has already been validated by someone else. Please contact \"\n                                    \"[{}]({}) for assistance.\".format(key, ISSUER_NAME, ISSUER_SUPPORT_URL)}),\n            409\n        )\n\n\n    #Add upgrade\n    if license.is_upgrade:\n        #Missing precondition.\n        if precondition is None:\n            return (\n                jsonify({\"description\": \"Please enter a previous license key to upgrade from.\"}),\n                428\n            )\n\n        previous_key = License.query.filter_by(key=precondition).first()\n\n        #Non-existing previous license key\n        if previous_key is None:\n            return (\n                jsonify({\"description\": \"The license key '{}' is not a valid license. \"\n                                        \"Please enter a different license to upgrade from.\".format(precondition)}),\n                412\n            )\n\n        #Previous license already upgraded\n        if license.upgrade_from_key is not None and license.upgrade_from_key != precondition:\n            return (\n                jsonify({\"description\": \"The license key '{}' has already been upgraded to a different license key. Please contact \"\n                                        \"[{}]({}) for assistance.\".format(precondition, ISSUER_NAME, ISSUER_SUPPORT_URL)}),\n                412\n            )\n\n        #Previous license is a non-validated upgrade.\n        if previous_key.is_upgrade and previous_key.entity_id is None:\n            return (\n                jsonify({\n                            \"description\": \"The license key '{}' cannot be used to upgrade. Please enter \"\n                                           \"a different license key to upgrade from.\".format(precondition)}),\n                412\n            )\n\n        #Valid upgrade. We make sure to cluster all licenses.\n        licenses = [previous_key.to_json_dict(), license.to_json_dict()]\n        a_license = previous_key\n\n        while a_license.upgrade_from_key is not None:\n            a_license = License.query.filter_by(key=a_license.upgrade_from_key).first()\n            licenses.append(a_license.to_json_dict())\n    else:\n        license.entity_id = entity_id\n        license.date = datetime.datetime.utcnow()\n        db.session.commit()\n        licenses = [license.to_json_dict()]\n\n    return jsonify({\"licenses\": licenses})\n\n@app.route(\"/remove_license\", methods=[\"POST\"])\n@requires_auth\ndef remove_license():\n    \"\"\"See if a license cluster can be removed from an entity. We make sure to note that a license is no longer\n    in the entity. See more info about this endpoint at: https://developer.rhino3d.com/guides/rhinocommon/cloudzoo/cloudzoo-implement-http-callbacks/#post-remove_license\"\"\"\n    payload_dict = request.get_json()\n\n    licenses = []\n\n    for license in payload_dict[\"licenseCluster\"][\"licenses\"]:\n        result = License.query.filter_by(\n            serial=license[\"id\"],\n            product_id=license[\"aud\"],\n            entity_id=payload_dict[\"entityId\"]\n        ).first()\n\n        if result is not None:\n            licenses.append(result)\n\n    if len(licenses) == 0 or len(licenses) == len(payload_dict[\"licenseCluster\"][\"licenses\"]):\n\n        # remove the entity id from the licenses\n        for license in licenses:\n            license.entity_id = None\n            license.date = datetime.datetime.utcnow()\n\n        db.session.commit()\n        return ('', 200)\n    else:\n        #There is an issue with the state of the data.\n        return (\n            jsonify({\"description\": \"The license(s) cannot be currently be removed. Please contact \"\n                                    \"[{}]({}) for assistance.\".format(ISSUER_NAME, ISSUER_SUPPORT_URL),\n                     \"details\": \"License key count mismatch\"}),\n            400\n        )\n\n@app.route(\"/get_license\", methods=[\"GET\"])\n@requires_auth\ndef get_license():\n    \"\"\"Return information about a specific license so users can see details about the license.\n    See more info about this endpoint at https://developer.rhino3d.com/guides/rhinocommon/cloudzoo/cloudzoo-implement-http-callbacks/#get-get_license\"\"\"\n    product_id = request.args.get(\"aud\")\n    key = request.args.get(\"key\")\n\n    license = License.query.filter_by(key=key, product_id=product_id).first()\n\n    if license is None:\n        return (\n            jsonify({\"description\": \"The license key is not valid\"}),\n            400\n        )\n    else:\n        return jsonify(license.to_json_dict())\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "classes", "functions", "RhinoCommon"], "original_file": "mcneel_cloudzoo-issuer_3f41e54689.json", "repo": "mcneel/cloudzoo-issuer"}
{"instruction": "Returns the type of conic section based on the curve's shape.", "code": "from . import Util\ntry:\n    from itertools import izip as zip # python 2\nexcept ImportError:\n    pass # python 3\n\n\ndef GetConicSectionType(thisCurve, multiple=False):\n    \"\"\"\n    Returns the type of conic section based on the curve's shape.\n    \"\"\"\n    url = \"rhino/geometry/curve/getconicsectiontype-curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve]\n    if multiple: args = [[item] for item in thisCurve]\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CreateInterpolatedCurve(points, degree, multiple=False):\n    \"\"\"\n    Interpolates a sequence of points. Used by InterpCurve Command\n    This routine works best when degree=3.\n\n    Args:\n        degree (int): The degree of the curve >=1.  Degree must be odd.\n        points (IEnumerable<Point3d>): Points to interpolate (Count must be >= 2)\n\n    Returns:\n        Curve: interpolated curve on success. None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createinterpolatedcurve-point3darray_int\"\n    if multiple: url += \"?multiple=true\"\n    args = [points, degree]\n    if multiple: args = list(zip(points, degree))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateInterpolatedCurve1(points, degree, knots, multiple=False):\n    \"\"\"\n    Interpolates a sequence of points. Used by InterpCurve Command\n    This routine works best when degree=3.\n\n    Args:\n        degree (int): The degree of the curve >=1.  Degree must be odd.\n        points (IEnumerable<Point3d>): Points to interpolate. For periodic curves if the final point is a\n            duplicate of the initial point it is  ignored. (Count must be >=2)\n        knots (CurveKnotStyle): Knot-style to use  and specifies if the curve should be periodic.\n\n    Returns:\n        Curve: interpolated curve on success. None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createinterpolatedcurve-point3darray_int_curveknotstyle\"\n    if multiple: url += \"?multiple=true\"\n    args = [points, degree, knots]\n    if multiple: args = list(zip(points, degree, knots))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateInterpolatedCurve2(points, degree, knots, startTangent, endTangent, multiple=False):\n    \"\"\"\n    Interpolates a sequence of points. Used by InterpCurve Command\n    This routine works best when degree=3.\n\n    Args:\n        degree (int): The degree of the curve >=1.  Degree must be odd.\n        points (IEnumerable<Point3d>): Points to interpolate. For periodic curves if the final point is a\n            duplicate of the initial point it is  ignored. (Count must be >=2)\n        knots (CurveKnotStyle): Knot-style to use  and specifies if the curve should be periodic.\n        startTangent (Vector3d): A starting tangent.\n        endTangent (Vector3d): An ending tangent.\n\n    Returns:\n        Curve: interpolated curve on success. None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createinterpolatedcurve-point3darray_int_curveknotstyle_vector3d_vector3d\"\n    if multiple: url += \"?multiple=true\"\n    args = [points, degree, knots, startTangent, endTangent]\n    if multiple: args = list(zip(points, degree, knots, startTangent, endTangent))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateSoftEditCurve(curve, t, delta, length, fixEnds, multiple=False):\n    \"\"\"\n    Creates a soft edited curve from an existing curve using a smooth field of influence.\n\n    Args:\n        curve (Curve): The curve to soft edit.\n        t (double): A parameter on the curve to move from. This location on the curve is moved, and the move\n            is smoothly tapered off with increasing distance along the curve from this parameter.\n        delta (Vector3d): The direction and magnitude, or maximum distance, of the move.\n        length (double): The distance along the curve from the editing point over which the strength\n            of the editing falls off smoothly.\n\n    Returns:\n        Curve: The soft edited curve if successful. None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createsofteditcurve-curve_double_vector3d_double_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, t, delta, length, fixEnds]\n    if multiple: args = list(zip(curve, t, delta, length, fixEnds))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateFilletCornersCurve(curve, radius, tolerance, angleTolerance, multiple=False):\n    \"\"\"\n    Rounds the corners of a kinked curve with arcs of a single, specified radius.\n\n    Args:\n        curve (Curve): The curve to fillet.\n        radius (double): The fillet radius.\n        tolerance (double): The tolerance. When in doubt, use the document's model space absolute tolerance.\n        angleTolerance (double): The angle tolerance in radians. When in doubt, use the document's model space angle tolerance.\n\n    Returns:\n        Curve: The filleted curve if successful. None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createfilletcornerscurve-curve_double_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, radius, tolerance, angleTolerance]\n    if multiple: args = list(zip(curve, radius, tolerance, angleTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef JoinCurves(inputCurves, joinTolerance, preserveDirection, multiple=False):\n    \"\"\"\n    Joins a collection of curve segments together.\n\n    Args:\n        inputCurves (IEnumerable<Curve>): An array, a list or any enumerable set of curve segments to join.\n        joinTolerance (double): Joining tolerance,\n            i.e. the distance between segment end-points that is allowed.\n        preserveDirection (bool): If true, curve endpoints will be compared to curve start points.If false, all start and endpoints will be compared and copies of input curves may be reversed in output.\n\n    Returns:\n        Curve[]: An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/joincurves-curvearray_double_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [inputCurves, joinTolerance, preserveDirection]\n    if multiple: args = list(zip(inputCurves, joinTolerance, preserveDirection))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateArcLineArcBlend(startPt, startDir, endPt, endDir, radius, multiple=False):\n    \"\"\"\n    Creates an arc-line-arc blend curve between two curves.\n    The output is generally a PolyCurve with three segments: arc, line, arc.\n    In some cases, one or more of those segments will be absent because they would have 0 length.\n    If there is only a single segment, the result will either be an ArcCurve or a LineCurve.\n\n    Args:\n        startPt (Point3d): Start of the blend curve.\n        startDir (Vector3d): Start direction of the blend curve.\n        endPt (Point3d): End of the blend curve.\n        endDir (Vector3d): End direction of the arc blend curve.\n        radius (double): The radius of the arc segments.\n\n    Returns:\n        Curve: The blend curve if successful, False otherwise.\n    \"\"\"\n    url = \"rhino/geometry/curve/createarclinearcblend-point3d_vector3d_point3d_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [startPt, startDir, endPt, endDir, radius]\n    if multiple: args = list(zip(startPt, startDir, endPt, endDir, radius))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateArcBlend(startPt, startDir, endPt, endDir, controlPointLengthRatio, multiple=False):\n    \"\"\"\n    Creates a polycurve consisting of two tangent arc segments that connect two points and two directions.\n\n    Args:\n        startPt (Point3d): Start of the arc blend curve.\n        startDir (Vector3d): Start direction of the arc blend curve.\n        endPt (Point3d): End of the arc blend curve.\n        endDir (Vector3d): End direction of the arc blend curve.\n        controlPointLengthRatio (double): The ratio of the control polygon lengths of the two arcs. Note, a value of 1.0\n            means the control polygon lengths for both arcs will be the same.\n\n    Returns:\n        Curve: The arc blend curve, or None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/createarcblend-point3d_vector3d_point3d_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [startPt, startDir, endPt, endDir, controlPointLengthRatio]\n    if multiple: args = list(zip(startPt, startDir, endPt, endDir, controlPointLengthRatio))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateMeanCurve(curveA, curveB, angleToleranceRadians, multiple=False):\n    \"\"\"\n    Constructs a mean, or average, curve from two curves.\n\n    Args:\n        curveA (Curve): A first curve.\n        curveB (Curve): A second curve.\n        angleToleranceRadians (double): The angle tolerance, in radians, used to match kinks between curves.\n            If you are unsure how to set this parameter, then either use the\n            document's angle tolerance RhinoDoc.AngleToleranceRadians,\n            or the default value (RhinoMath.UnsetValue)\n\n    Returns:\n        Curve: The average curve, or None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/createmeancurve-curve_curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, angleToleranceRadians]\n    if multiple: args = list(zip(curveA, curveB, angleToleranceRadians))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateMeanCurve1(curveA, curveB, multiple=False):\n    \"\"\"\n    Constructs a mean, or average, curve from two curves.\n\n    Args:\n        curveA (Curve): A first curve.\n        curveB (Curve): A second curve.\n\n    Returns:\n        Curve: The average curve, or None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/createmeancurve-curve_curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB]\n    if multiple: args = list(zip(curveA, curveB))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBlendCurve(curveA, curveB, continuity, multiple=False):\n    \"\"\"\n    Create a Blend curve between two existing curves.\n\n    Args:\n        curveA (Curve): Curve to blend from (blending will occur at curve end point).\n        curveB (Curve): Curve to blend to (blending will occur at curve start point).\n        continuity (BlendContinuity): Continuity of blend.\n\n    Returns:\n        Curve: A curve representing the blend between A and B or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createblendcurve-curve_curve_blendcontinuity\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, continuity]\n    if multiple: args = list(zip(curveA, curveB, continuity))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBlendCurve1(curveA, curveB, continuity, bulgeA, bulgeB, multiple=False):\n    \"\"\"\n    Create a Blend curve between two existing curves.\n\n    Args:\n        curveA (Curve): Curve to blend from (blending will occur at curve end point).\n        curveB (Curve): Curve to blend to (blending will occur at curve start point).\n        continuity (BlendContinuity): Continuity of blend.\n        bulgeA (double): Bulge factor at curveA end of blend. Values near 1.0 work best.\n        bulgeB (double): Bulge factor at curveB end of blend. Values near 1.0 work best.\n\n    Returns:\n        Curve: A curve representing the blend between A and B or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createblendcurve-curve_curve_blendcontinuity_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, continuity, bulgeA, bulgeB]\n    if multiple: args = list(zip(curveA, curveB, continuity, bulgeA, bulgeB))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBlendCurve2(curve0, t0, reverse0, continuity0, curve1, t1, reverse1, continuity1, multiple=False):\n    \"\"\"\n    Makes a curve blend between 2 curves at the parameters specified\n    with the directions and continuities specified\n\n    Args:\n        curve0 (Curve): First curve to blend from\n        t0 (double): Parameter on first curve for blend endpoint\n        reverse0 (bool): If false, the blend will go in the natural direction of the curve.\n            If true, the blend will go in the opposite direction to the curve\n        continuity0 (BlendContinuity): Continuity for the blend at the start\n        curve1 (Curve): Second curve to blend from\n        t1 (double): Parameter on second curve for blend endpoint\n        reverse1 (bool): If false, the blend will go in the natural direction of the curve.\n            If true, the blend will go in the opposite direction to the curve\n        continuity1 (BlendContinuity): Continuity for the blend at the end\n\n    Returns:\n        Curve: The blend curve on success. None on failure\n    \"\"\"\n    url = \"rhino/geometry/curve/createblendcurve-curve_double_bool_blendcontinuity_curve_double_bool_blendcontinuity\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, t0, reverse0, continuity0, curve1, t1, reverse1, continuity1]\n    if multiple: args = list(zip(curve0, t0, reverse0, continuity0, curve1, t1, reverse1, continuity1))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateMatchCurve(curve0, reverse0, continuity, curve1, reverse1, preserve, average, multiple=False):\n    \"\"\"\n    Changes a curve end to meet a specified curve with a specified continuity.\n\n    Args:\n        curve0 (Curve): The open curve to change.\n        reverse0 (bool): Reverse the directon of the curve to change before matching.\n        continuity (BlendContinuity): The continuity at the curve end.\n        curve1 (Curve): The open curve to match.\n        reverse1 (bool): Reverse the directon of the curve to match before matching.\n        preserve (PreserveEnd): Prevent modification of the curvature at the end opposite the match for curves with fewer than six control points.\n        average (bool): Adjust both curves to match each other.\n\n    Returns:\n        Curve[]: The results of the curve matching, if successful, otherwise an empty array.\n    \"\"\"\n    url = \"rhino/geometry/curve/creatematchcurve-curve_bool_blendcontinuity_curve_bool_preserveend_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, reverse0, continuity, curve1, reverse1, preserve, average]\n    if multiple: args = list(zip(curve0, reverse0, continuity, curve1, reverse1, preserve, average))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateTweenCurves(curve0, curve1, numCurves, multiple=False):\n    \"\"\"\n    Creates curves between two open or closed input curves. Uses the control points of the curves for finding tween curves.\n    That means the first control point of first curve is matched to first control point of the second curve and so on.\n    There is no matching of curves direction. Caller must match input curves direction before calling the function.\n\n    Args:\n        curve0 (Curve): The first, or starting, curve.\n        curve1 (Curve): The second, or ending, curve.\n        numCurves (int): Number of tween curves to create.\n\n    Returns:\n        Curve[]: An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtweencurves-curve_curve_int\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, numCurves]\n    if multiple: args = list(zip(curve0, curve1, numCurves))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateTweenCurves1(curve0, curve1, numCurves, tolerance, multiple=False):\n    \"\"\"\n    Creates curves between two open or closed input curves. Uses the control points of the curves for finding tween curves.\n    That means the first control point of first curve is matched to first control point of the second curve and so on.\n    There is no matching of curves direction. Caller must match input curves direction before calling the function.\n\n    Args:\n        curve0 (Curve): The first, or starting, curve.\n        curve1 (Curve): The second, or ending, curve.\n        numCurves (int): Number of tween curves to create.\n\n    Returns:\n        Curve[]: An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtweencurves-curve_curve_int_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, numCurves, tolerance]\n    if multiple: args = list(zip(curve0, curve1, numCurves, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateTweenCurvesWithMatching(curve0, curve1, numCurves, multiple=False):\n    \"\"\"\n    Creates curves between two open or closed input curves. Make the structure of input curves compatible if needed.\n    Refits the input curves to have the same structure. The resulting curves are usually more complex than input unless\n    input curves are compatible and no refit is needed. There is no matching of curves direction.\n    Caller must match input curves direction before calling the function.\n\n    Args:\n        curve0 (Curve): The first, or starting, curve.\n        curve1 (Curve): The second, or ending, curve.\n        numCurves (int): Number of tween curves to create.\n\n    Returns:\n        Curve[]: An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtweencurveswithmatching-curve_curve_int\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, numCurves]\n    if multiple: args = list(zip(curve0, curve1, numCurves))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateTweenCurvesWithMatching1(curve0, curve1, numCurves, tolerance, multiple=False):\n    \"\"\"\n    Creates curves between two open or closed input curves. Make the structure of input curves compatible if needed.\n    Refits the input curves to have the same structure. The resulting curves are usually more complex than input unless\n    input curves are compatible and no refit is needed. There is no matching of curves direction.\n    Caller must match input curves direction before calling the function.\n\n    Args:\n        curve0 (Curve): The first, or starting, curve.\n        curve1 (Curve): The second, or ending, curve.\n        numCurves (int): Number of tween curves to create.\n\n    Returns:\n        Curve[]: An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtweencurveswithmatching-curve_curve_int_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, numCurves, tolerance]\n    if multiple: args = list(zip(curve0, curve1, numCurves, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateTweenCurvesWithSampling(curve0, curve1, numCurves, numSamples, multiple=False):\n    \"\"\"\n    Creates curves between two open or closed input curves. Use sample points method to make curves compatible.\n    This is how the algorithm works: Divides the two curves into an equal number of points, finds the midpoint between the\n    corresponding points on the curves and interpolates the tween curve through those points. There is no matching of curves\n    direction. Caller must match input curves direction before calling the function.\n\n    Args:\n        curve0 (Curve): The first, or starting, curve.\n        curve1 (Curve): The second, or ending, curve.\n        numCurves (int): Number of tween curves to create.\n        numSamples (int): Number of sample points along input curves.\n\n    Returns:\n        Curve[]: >An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtweencurveswithsampling-curve_curve_int_int\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, numCurves, numSamples]\n    if multiple: args = list(zip(curve0, curve1, numCurves, numSamples))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateTweenCurvesWithSampling1(curve0, curve1, numCurves, numSamples, tolerance, multiple=False):\n    \"\"\"\n    Creates curves between two open or closed input curves. Use sample points method to make curves compatible.\n    This is how the algorithm works: Divides the two curves into an equal number of points, finds the midpoint between the\n    corresponding points on the curves and interpolates the tween curve through those points. There is no matching of curves\n    direction. Caller must match input curves direction before calling the function.\n\n    Args:\n        curve0 (Curve): The first, or starting, curve.\n        curve1 (Curve): The second, or ending, curve.\n        numCurves (int): Number of tween curves to create.\n        numSamples (int): Number of sample points along input curves.\n\n    Returns:\n        Curve[]: >An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtweencurveswithsampling-curve_curve_int_int_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, numCurves, numSamples, tolerance]\n    if multiple: args = list(zip(curve0, curve1, numCurves, numSamples, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef MakeEndsMeet(curveA, adjustStartCurveA, curveB, adjustStartCurveB, multiple=False):\n    \"\"\"\n    Makes adjustments to the ends of one or both input curves so that they meet at a point.\n\n    Args:\n        curveA (Curve): 1st curve to adjust.\n        adjustStartCurveA (bool): Which end of the 1st curve to adjust: True is start, False is end.\n        curveB (Curve): 2nd curve to adjust.\n        adjustStartCurveB (bool): which end of the 2nd curve to adjust true==start, false==end.\n\n    Returns:\n        bool: True on success.\n    \"\"\"\n    url = \"rhino/geometry/curve/makeendsmeet-curve_bool_curve_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, adjustStartCurveA, curveB, adjustStartCurveB]\n    if multiple: args = list(zip(curveA, adjustStartCurveA, curveB, adjustStartCurveB))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CreateFillet(curve0, curve1, radius, t0Base, t1Base, multiple=False):\n    \"\"\"\n    Computes the fillet arc for a curve filleting operation.\n\n    Args:\n        curve0 (Curve): First curve to fillet.\n        curve1 (Curve): Second curve to fillet.\n        radius (double): Fillet radius.\n        t0Base (double): Parameter on curve0 where the fillet ought to start (approximately).\n        t1Base (double): Parameter on curve1 where the fillet ought to end (approximately).\n\n    Returns:\n        Arc: The fillet arc on success, or Arc.Unset on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createfillet-curve_curve_double_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, radius, t0Base, t1Base]\n    if multiple: args = list(zip(curve0, curve1, radius, t0Base, t1Base))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CreateFilletCurves(curve0, point0, curve1, point1, radius, join, trim, arcExtension, tolerance, angleTolerance, multiple=False):\n    \"\"\"\n    Creates a tangent arc between two curves and trims or extends the curves to the arc.\n\n    Args:\n        curve0 (Curve): The first curve to fillet.\n        point0 (Point3d): A point on the first curve that is near the end where the fillet will\n            be created.\n        curve1 (Curve): The second curve to fillet.\n        point1 (Point3d): A point on the second curve that is near the end where the fillet will\n            be created.\n        radius (double): The radius of the fillet.\n        join (bool): Join the output curves.\n        trim (bool): Trim copies of the input curves to the output fillet curve.\n        arcExtension (bool): Applies when arcs are filleted but need to be extended to meet the\n            fillet curve or chamfer line. If true, then the arc is extended\n            maintaining its validity. If false, then the arc is extended with a\n            line segment, which is joined to the arc converting it to a polycurve.\n        tolerance (double): The tolerance, generally the document's absolute tolerance.\n\n    Returns:\n        Curve[]: The results of the fillet operation. The number of output curves depends\n        on the input curves and the values of the parameters that were used\n        during the fillet operation. In most cases, the output array will contain\n        either one or three curves, although two curves can be returned if the\n        radius is zero and join = false.\n        For example, if both join and trim = true, then the output curve\n        will be a polycurve containing the fillet curve joined with trimmed copies\n        of the input curves. If join = False and trim = true, then three curves,\n        the fillet curve and trimmed copies of the input curves, will be returned.\n        If both join and trim = false, then just the fillet curve is returned.\n    \"\"\"\n    url = \"rhino/geometry/curve/createfilletcurves-curve_point3d_curve_point3d_double_bool_bool_bool_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, point0, curve1, point1, radius, join, trim, arcExtension, tolerance, angleTolerance]\n    if multiple: args = list(zip(curve0, point0, curve1, point1, radius, join, trim, arcExtension, tolerance, angleTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanUnion(curves, multiple=False):\n    \"\"\"\n    Calculates the boolean union of two or more closed, planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curves (IEnumerable<Curve>): The co-planar curves to union.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no union could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleanunion-curvearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves]\n    if multiple: args = [[item] for item in curves]\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanUnion1(curves, tolerance, multiple=False):\n    \"\"\"\n    Calculates the boolean union of two or more closed, planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curves (IEnumerable<Curve>): The co-planar curves to union.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no union could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleanunion-curvearray_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves, tolerance]\n    if multiple: args = list(zip(curves, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanIntersection(curveA, curveB, multiple=False):\n    \"\"\"\n    Calculates the boolean intersection of two closed, planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curveA (Curve): The first closed, planar curve.\n        curveB (Curve): The second closed, planar curve.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no intersection could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleanintersection-curve_curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB]\n    if multiple: args = list(zip(curveA, curveB))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanIntersection1(curveA, curveB, tolerance, multiple=False):\n    \"\"\"\n    Calculates the boolean intersection of two closed, planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curveA (Curve): The first closed, planar curve.\n        curveB (Curve): The second closed, planar curve.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no intersection could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleanintersection-curve_curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, tolerance]\n    if multiple: args = list(zip(curveA, curveB, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanDifference(curveA, curveB, multiple=False):\n    \"\"\"\n    Calculates the boolean difference between two closed, planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curveA (Curve): The first closed, planar curve.\n        curveB (Curve): The second closed, planar curve.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no difference could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleandifference-curve_curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB]\n    if multiple: args = list(zip(curveA, curveB))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanDifference1(curveA, curveB, tolerance, multiple=False):\n    \"\"\"\n    Calculates the boolean difference between two closed, planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curveA (Curve): The first closed, planar curve.\n        curveB (Curve): The second closed, planar curve.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no difference could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleandifference-curve_curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, tolerance]\n    if multiple: args = list(zip(curveA, curveB, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanDifference2(curveA, subtractors, multiple=False):\n    \"\"\"\n    Calculates the boolean difference between a closed planar curve, and a list of closed planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curveA (Curve): The first closed, planar curve.\n        subtractors (IEnumerable<Curve>): curves to subtract from the first closed curve.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no difference could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleandifference-curve_curvearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, subtractors]\n    if multiple: args = list(zip(curveA, subtractors))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanDifference3(curveA, subtractors, tolerance, multiple=False):\n    \"\"\"\n    Calculates the boolean difference between a closed planar curve, and a list of closed planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curveA (Curve): The first closed, planar curve.\n        subtractors (IEnumerable<Curve>): curves to subtract from the first closed curve.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no difference could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleandifference-curve_curvearray_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, subtractors, tolerance]\n    if multiple: args = list(zip(curveA, subtractors, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanRegions(curves, plane, points, combineRegions, tolerance, multiple=False):\n    \"\"\"\n    Curve Boolean method, which trims and splits curves based on their overlapping regions.\n\n    Args:\n        curves (IEnumerable<Curve>): The input curves.\n        plane (Plane): Regions will be found in the projection of the curves to this plane.\n        points (IEnumerable<Point3d>): These points will be projected to plane. All regions that contain at least one of these points will be found.\n        combineRegions (bool): If true, then adjacent regions will be combined.\n        tolerance (double): Function tolerance. When in doubt, use the document's model absolute tolerance.\n\n    Returns:\n        CurveBooleanRegions: The curve Boolean regions if successful, None of no successful.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleanregions-curvearray_plane_point3darray_bool_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves, plane, points, combineRegions, tolerance]\n    if multiple: args = list(zip(curves, plane, points, combineRegions, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CreateBooleanRegions1(curves, plane, combineRegions, tolerance, multiple=False):\n    \"\"\"\n    Calculates curve Boolean regions, which trims and splits curves based on their overlapping regions.\n\n    Args:\n        curves (IEnumerable<Curve>): The input curves.\n        plane (Plane): Regions will be found in the projection of the curves to this plane.\n        combineRegions (bool): If true, then adjacent regions will be combined.\n        tolerance (double): Function tolerance. When in doubt, use the document's model absolute tolerance.\n\n    Returns:\n        CurveBooleanRegions: The curve Boolean regions if successful, None of no successful.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleanregions-curvearray_plane_bool_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves, plane, combineRegions, tolerance]\n    if multiple: args = list(zip(curves, plane, combineRegions, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CreateTextOutlines(text, font, textHeight, textStyle, closeLoops, plane, smallCapsScale, tolerance, multiple=False):\n    \"\"\"\n    Creates outline curves created from a text string. The functionality is similar to what you find in Rhino's TextObject command or TextEntity.Explode() in RhinoCommon.\n\n    Args:\n        text (string): The text from which to create outline curves.\n        font (string): The text font.\n        textHeight (double): The text height.\n        textStyle (int): The font style. The font style can be any number of the following: 0 - Normal, 1 - Bold, 2 - Italic\n        closeLoops (bool): Set this value to True when dealing with normal fonts and when you expect closed loops. You may want to set this to False when specifying a single-stroke font where you don't want closed loops.\n        plane (Plane): The plane on which the outline curves will lie.\n        smallCapsScale (double): Displays lower-case letters as small caps. Set the relative text size to a percentage of the normal text.\n        tolerance (double): The tolerance for the operation.\n\n    Returns:\n        Curve[]: An array containing one or more curves if successful.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtextoutlines-string_string_double_int_bool_plane_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [text, font, textHeight, textStyle, closeLoops, plane, smallCapsScale, tolerance]\n    if multiple: args = list(zip(text, font, textHeight, textStyle, closeLoops, plane, smallCapsScale, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateCurve2View(curveA, curveB, vectorA, vectorB, tolerance, angleTolerance, multiple=False):\n    \"\"\"\n    Creates a third curve from two curves that are planar in different construction planes.\n    The new curve looks the same as each of the original curves when viewed in each plane.\n\n    Args:\n        curveA (Curve): The first curve.\n        curveB (Curve): The second curve.\n        vectorA (Vector3d): A vector defining the normal direction of the plane which the first curve is drawn upon.\n        vectorB (Vector3d): A vector defining the normal direction of the plane which the second curve is drawn upon.\n        tolerance (double): The tolerance for the operation.\n        angleTolerance (double): The angle tolerance for the operation.\n\n    Returns:\n        Curve[]: An array containing one or more curves if successful.\n    \"\"\"\n    url = \"rhino/geometry/curve/createcurve2view-curve_curve_vector3d_vector3d_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, vectorA, vectorB, tolerance, angleTolerance]\n    if multiple: args = list(zip(curveA, curveB, vectorA, vectorB, tolerance, angleTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef DoDirectionsMatch(curveA, curveB, multiple=False):\n    \"\"\"\n    Determines whether two curves travel more or less in the same direction.\n\n    Args:\n        curveA (Curve): First curve to test.\n        curveB (Curve): Second curve to test.\n\n    Returns:\n        bool: True if both curves more or less point in the same direction,\n        False if they point in the opposite directions.\n    \"\"\"\n    url = \"rhino/geometry/curve/dodirectionsmatch-curve_curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB]\n    if multiple: args = list(zip(curveA, curveB))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ProjectToMesh(curve, mesh, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a curve to a mesh using a direction and tolerance.\n\n    Args:\n        curve (Curve): A curve.\n        mesh (Mesh): A mesh.\n        direction (Vector3d): A direction vector.\n        tolerance (double): A tolerance value.\n\n    Returns:\n        Curve[]: A curve array.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttomesh-curve_mesh_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, mesh, direction, tolerance]\n    if multiple: args = list(zip(curve, mesh, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ProjectToMesh1(curve, meshes, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a curve to a set of meshes using a direction and tolerance.\n\n    Args:\n        curve (Curve): A curve.\n        meshes (IEnumerable<Mesh>): A list, an array or any enumerable of meshes.\n        direction (Vector3d): A direction vector.\n        tolerance (double): A tolerance value.\n\n    Returns:\n        Curve[]: A curve array.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttomesh-curve_mesharray_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, meshes, direction, tolerance]\n    if multiple: args = list(zip(curve, meshes, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ProjectToMesh2(curves, meshes, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a curve to a set of meshes using a direction and tolerance.\n\n    Args:\n        curves (IEnumerable<Curve>): A list, an array or any enumerable of curves.\n        meshes (IEnumerable<Mesh>): A list, an array or any enumerable of meshes.\n        direction (Vector3d): A direction vector.\n        tolerance (double): A tolerance value.\n\n    Returns:\n        Curve[]: A curve array.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttomesh-curvearray_mesharray_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves, meshes, direction, tolerance]\n    if multiple: args = list(zip(curves, meshes, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ProjectToBrep(curve, brep, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a Curve onto a Brep along a given direction.\n\n    Args:\n        curve (Curve): Curve to project.\n        brep (Brep): Brep to project onto.\n        direction (Vector3d): Direction of projection.\n        tolerance (double): Tolerance to use for projection.\n\n    Returns:\n        Curve[]: An array of projected curves or empty array if the projection set is empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttobrep-curve_brep_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, brep, direction, tolerance]\n    if multiple: args = list(zip(curve, brep, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ProjectToBrep1(curve, breps, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a Curve onto a collection of Breps along a given direction.\n\n    Args:\n        curve (Curve): Curve to project.\n        breps (IEnumerable<Brep>): Breps to project onto.\n        direction (Vector3d): Direction of projection.\n        tolerance (double): Tolerance to use for projection.\n\n    Returns:\n        Curve[]: An array of projected curves or empty array if the projection set is empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttobrep-curve_breparray_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, breps, direction, tolerance]\n    if multiple: args = list(zip(curve, breps, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ProjectToBrep2(curve, breps, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a Curve onto a collection of Breps along a given direction.\n\n    Args:\n        curve (Curve): Curve to project.\n        breps (IEnumerable<Brep>): Breps to project onto.\n        direction (Vector3d): Direction of projection.\n        tolerance (double): Tolerance to use for projection.\n\n    Returns:\n        Curve[]: An array of projected curves or None if the projection set is empty.\n        brepIndices (int[]): (out) Integers that identify for each resulting curve which Brep it was projected onto.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttobrep-curve_breparray_vector3d_double_intarray\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, breps, direction, tolerance]\n    if multiple: args = list(zip(curve, breps, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ProjectToBrep3(curves, breps, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a collection of Curves onto a collection of Breps along a given direction.\n\n    Args:\n        curves (IEnumerable<Curve>): Curves to project.\n        breps (IEnumerable<Brep>): Breps to project onto.\n        direction (Vector3d): Direction of projection.\n        tolerance (double): Tolerance to use for projection.\n\n    Returns:\n        Curve[]: An array of projected curves or empty array if the projection set is empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttobrep-curvearray_breparray_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves, breps, direction, tolerance]\n    if multiple: args = list(zip(curves, breps, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ProjectToBrep4(curves, breps, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a collection of Curves onto a collection of Breps along a given direction.\n\n    Args:\n        curves (IEnumerable<Curve>): Curves to project.\n        breps (IEnumerable<Brep>): Breps to project onto.\n        direction (Vector3d): Direction of projection.\n        tolerance (double): Tolerance to use for projection.\n\n    Returns:\n        Curve[]: An array of projected curves. Array is empty if the projection set is empty.\n        curveIndices (int[]): Index of which curve in the input list was the source for a curve in the return array.\n        brepIndices (int[]): Index of which brep was used to generate a curve in the return array.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttobrep-curvearray_breparray_vector3d_double_intarray_intarray\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves, breps, direction, tolerance]\n    if multiple: args = list(zip(curves, breps, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ProjectToPlane(curve, plane, multiple=False):\n    \"\"\"\n    Constructs a curve by projecting an existing curve to a plane.\n\n    Args:\n        curve (Curve): A curve.\n        plane (Plane): A plane.\n\n    Returns:\n        Curve: The projected curve on success; None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttoplane-curve_plane\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, plane]\n    if multiple: args = list(zip(curve, plane))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef PullToBrepFace(curve, face, tolerance, multiple=False):\n    \"\"\"\n    Pull a curve to a BrepFace using closest point projection.\n\n    Args:\n        curve (Curve): Curve to pull.\n        face (BrepFace): Brep face that pulls.\n        tolerance (double): Tolerance to use for pulling.\n\n    Returns:\n        Curve[]: An array of pulled curves, or an empty array on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/pulltobrepface-curve_brepface_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, face, tolerance]\n    if multiple: args = list(zip(curve, face, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef PlanarClosedCurveRelationship(curveA, curveB, testPlane, tolerance, multiple=False):\n    \"\"\"\n    Determines whether two coplanar simple closed curves are disjoint or intersect;\n    otherwise, if the regions have a containment relationship, discovers\n    which curve encloses the other.\n\n    Args:\n        curveA (Curve): A first curve.\n        curveB (Curve): A second curve.\n        testPlane (Plane): A plane.\n        tolerance (double): A tolerance value.\n\n    Returns:\n        RegionContainment: A value indicating the relationship between the first and the second curve.\n    \"\"\"\n    url = \"rhino/geometry/curve/planarclosedcurverelationship-curve_curve_plane_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, testPlane, tolerance]\n    if multiple: args = list(zip(curveA, curveB, testPlane, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef PlanarCurveCollision(curveA, curveB, testPlane, tolerance, multiple=False):\n    \"\"\"\n    Determines if two coplanar curves collide (intersect).\n\n    Args:\n        curveA (Curve): A curve.\n        curveB (Curve): Another curve.\n        testPlane (Plane): A valid plane containing the curves.\n        tolerance (double): A tolerance value for intersection.\n\n    Returns:\n        bool: True if the curves intersect, otherwise false\n    \"\"\"\n    url = \"rhino/geometry/curve/planarcurvecollision-curve_curve_plane_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, testPlane, tolerance]\n    if multiple: args = list(zip(curveA, curveB, testPlane, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DuplicateSegments(thisCurve, multiple=False):\n    \"\"\"\n    Duplicates curve segments.\n    Explodes polylines, polycurves and G1 discontinuous NURBS curves.\n    Single segment curves, such as lines, arcs, unkinked NURBS curves, are duplicated.\n\n    Returns:\n        Curve[]: An array of all the segments that make up this curve.\n    \"\"\"\n    url = \"rhino/geometry/curve/duplicatesegments-curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve]\n    if multiple: args = [[item] for item in thisCurve]\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Smooth(thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem, multiple=False):\n    \"\"\"\n    Smooths a curve by averaging the positions of control points in a specified region.\n\n    Args:\n        smoothFactor (double): The smoothing factor, which controls how much control points move towards the average of the neighboring control points.\n        bXSmooth (bool): When True control points move in X axis direction.\n        bYSmooth (bool): When True control points move in Y axis direction.\n        bZSmooth (bool): When True control points move in Z axis direction.\n        bFixBoundaries (bool): When True the curve ends don't move.\n        coordinateSystem (SmoothingCoordinateSystem): The coordinates to determine the direction of the smoothing.\n\n    Returns:\n        Curve: The smoothed curve if successful, None otherwise.\n    \"\"\"\n    url = \"rhino/geometry/curve/smooth-curve_double_bool_bool_bool_bool_smoothingcoordinatesystem\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem]\n    if multiple: args = list(zip(thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Smooth1(thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem, plane, multiple=False):\n    \"\"\"\n    Smooths a curve by averaging the positions of control points in a specified region.\n\n    Args:\n        smoothFactor (double): The smoothing factor, which controls how much control points move towards the average of the neighboring control points.\n        bXSmooth (bool): When True control points move in X axis direction.\n        bYSmooth (bool): When True control points move in Y axis direction.\n        bZSmooth (bool): When True control points move in Z axis direction.\n        bFixBoundaries (bool): When True the curve ends don't move.\n        coordinateSystem (SmoothingCoordinateSystem): The coordinates to determine the direction of the smoothing.\n        plane (Plane): If SmoothingCoordinateSystem.CPlane specified, then the construction plane.\n\n    Returns:\n        Curve: The smoothed curve if successful, None otherwise.\n    \"\"\"\n    url = \"rhino/geometry/curve/smooth-curve_double_bool_bool_bool_bool_smoothingcoordinatesystem_plane\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem, plane]\n    if multiple: args = list(zip(thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem, plane))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef GetLocalPerpPoint(thisCurve, testPoint, seedParmameter, multiple=False):\n    \"\"\"\n    Search for a location on the curve, near seedParmameter, that is perpendicular to a test point.\n\n    Args:\n        testPoint (Point3d): The test point.\n        seedParmameter (double): A \"seed\" parameter on the curve.\n\n    Returns:\n        bool: True if a solution is found, False otherwise.\n        curveParameter (double): The parameter value at the perpendicular point\n    \"\"\"\n    url = \"rhino/geometry/curve/getlocalperppoint-curve_point3d_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, seedParmameter]\n    if multiple: args = list(zip(thisCurve, testPoint, seedParmameter))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLocalPerpPoint1(thisCurve, testPoint, seedParmameter, subDomain, multiple=False):\n    \"\"\"\n    Search for a location on the curve, near seedParmameter, that is perpendicular to a test point.\n\n    Args:\n        testPoint (Point3d): The test point.\n        seedParmameter (double): A \"seed\" parameter on the curve.\n        subDomain (Interval): The sub-domain of the curve to search.\n\n    Returns:\n        bool: True if a solution is found, False otherwise.\n        curveParameter (double): The parameter value at the perpendicular point\n    \"\"\"\n    url = \"rhino/geometry/curve/getlocalperppoint-curve_point3d_double_interval_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, seedParmameter, subDomain]\n    if multiple: args = list(zip(thisCurve, testPoint, seedParmameter, subDomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLocalTangentPoint(thisCurve, testPoint, seedParmameter, multiple=False):\n    \"\"\"\n    Search for a location on the curve, near seedParmameter, that is tangent to a test point.\n\n    Args:\n        testPoint (Point3d): The test point.\n        seedParmameter (double): A \"seed\" parameter on the curve.\n\n    Returns:\n        bool: True if a solution is found, False otherwise.\n        curveParameter (double): The parameter value at the tangent point\n    \"\"\"\n    url = \"rhino/geometry/curve/getlocaltangentpoint-curve_point3d_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, seedParmameter]\n    if multiple: args = list(zip(thisCurve, testPoint, seedParmameter))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLocalTangentPoint1(thisCurve, testPoint, seedParmameter, subDomain, multiple=False):\n    \"\"\"\n    Search for a location on the curve, near seedParmameter, that is tangent to a test point.\n\n    Args:\n        testPoint (Point3d): The test point.\n        seedParmameter (double): A \"seed\" parameter on the curve.\n        subDomain (Interval): The sub-domain of the curve to search.\n\n    Returns:\n        bool: True if a solution is found, False otherwise.\n        curveParameter (double): The parameter value at the tangent point\n    \"\"\"\n    url = \"rhino/geometry/curve/getlocaltangentpoint-curve_point3d_double_interval_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, seedParmameter, subDomain]\n    if multiple: args = list(zip(thisCurve, testPoint, seedParmameter, subDomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef InflectionPoints(thisCurve, multiple=False):\n    \"\"\"\n    Returns a curve's inflection points. An inflection point is a location on\n    a curve at which the sign of the curvature (i.e., the concavity) changes.\n    The curvature at these locations is always 0.\n\n    Returns:\n        Point3d[]: An array of points if successful, None if not successful or on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/inflectionpoints-curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve]\n    if multiple: args = [[item] for item in thisCurve]\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToPoint3d(response)\n    return response\n\n\ndef MaxCurvaturePoints(thisCurve, multiple=False):\n    \"\"\"\n    Returns a curve's maximum curvature points. The maximum curvature points identify\n    where the curvature starts to decrease in both directions from the points.\n\n    Returns:\n        Point3d[]: An array of points if successful, None if not successful or on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/maxcurvaturepoints-curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve]\n    if multiple: args = [[item] for item in thisCurve]\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToPoint3d(response)\n    return response\n\n\ndef MakeClosed(thisCurve, tolerance, multiple=False):\n    \"\"\"\n    If IsClosed, just return true. Otherwise, decide if curve can be closed as\n    follows: Linear curves polylinear curves with 2 segments, NURBS with 3 or less\n    control points cannot be made closed. Also, if tolerance > 0 and the gap between\n    start and end is larger than tolerance, curve cannot be made closed.\n    Adjust the curve's endpoint to match its start point.\n\n    Args:\n        tolerance (double): If nonzero, and the gap is more than tolerance, curve cannot be made closed.\n\n    Returns:\n        bool: True on success, False on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/makeclosed-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance]\n    if multiple: args = list(zip(thisCurve, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CombineShortSegments(thisCurve, tolerance, multiple=False):\n    \"\"\"\n    Looks for segments that are shorter than tolerance that can be combined.\n    For NURBS of degree greater than 1, spans are combined by removing\n    knots. Similarly for NURBS segments of polycurves. Otherwise,\n    RemoveShortSegments() is called. Does not change the domain, but it will\n    change the relative parameterization.\n\n    Returns:\n        bool: True if short segments were combined or removed. False otherwise.\n    \"\"\"\n    url = \"rhino/geometry/curve/combineshortsegments-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance]\n    if multiple: args = list(zip(thisCurve, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef LcoalClosestPoint(thisCurve, testPoint, seed, multiple=False):\n    \"\"\"\n    Find parameter of the point on a curve that is locally closest to\n    the testPoint.  The search for a local close point starts at\n    a seed parameter.\n\n    Args:\n        testPoint (Point3d): A point to test against.\n        seed (double): The seed parameter.\n\n    Returns:\n        bool: True if the search is successful, False if the search fails.\n        t (double): >Parameter of the curve that is closest to testPoint.\n    \"\"\"\n    url = \"rhino/geometry/curve/lcoalclosestpoint-curve_point3d_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, seed]\n    if multiple: args = list(zip(thisCurve, testPoint, seed))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef LocalClosestPoint(thisCurve, testPoint, seed, multiple=False):\n    \"\"\"\n    Find parameter of the point on a curve that is locally closest to\n    the testPoint.  The search for a local close point starts at\n    a seed parameter.\n\n    Args:\n        testPoint (Point3d): A point to test against.\n        seed (double): The seed parameter.\n\n    Returns:\n        bool: True if the search is successful, False if the search fails.\n        t (double): >Parameter of the curve that is closest to testPoint.\n    \"\"\"\n    url = \"rhino/geometry/curve/localclosestpoint-curve_point3d_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, seed]\n    if multiple: args = list(zip(thisCurve, testPoint, seed))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ClosestPoint(thisCurve, testPoint, multiple=False):\n    \"\"\"\n    Finds parameter of the point on a curve that is closest to testPoint.\n    If the maximumDistance parameter is > 0, then only points whose distance\n    to the given point is <= maximumDistance will be returned.  Using a\n    positive value of maximumDistance can substantially speed up the search.\n\n    Args:\n        testPoint (Point3d): Point to search from.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter of local closest point.\n    \"\"\"\n    url = \"rhino/geometry/curve/closestpoint-curve_point3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint]\n    if multiple: args = list(zip(thisCurve, testPoint))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ClosestPoint1(thisCurve, testPoint, maximumDistance, multiple=False):\n    \"\"\"\n    Finds the parameter of the point on a curve that is closest to testPoint.\n    If the maximumDistance parameter is > 0, then only points whose distance\n    to the given point is <= maximumDistance will be returned.  Using a\n    positive value of maximumDistance can substantially speed up the search.\n\n    Args:\n        testPoint (Point3d): Point to project.\n        maximumDistance (double): The maximum allowed distance.\n            Past this distance, the search is given up and False is returned.Use 0 to turn off this parameter.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): parameter of local closest point returned here.\n    \"\"\"\n    url = \"rhino/geometry/curve/closestpoint-curve_point3d_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, maximumDistance]\n    if multiple: args = list(zip(thisCurve, testPoint, maximumDistance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ClosestPoints(thisCurve, otherCurve, multiple=False):\n    \"\"\"\n    Gets closest points between this and another curves.\n\n    Args:\n        otherCurve (Curve): The other curve.\n\n    Returns:\n        bool: True on success; False on error.\n        pointOnThisCurve (Point3d): The point on this curve. This out parameter is assigned during this call.\n        pointOnOtherCurve (Point3d): The point on other curve. This out parameter is assigned during this call.\n    \"\"\"\n    url = \"rhino/geometry/curve/closestpoints-curve_curve_point3d_point3d\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, otherCurve]\n    if multiple: args = list(zip(thisCurve, otherCurve))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef Contains(thisCurve, testPoint, multiple=False):\n    \"\"\"\n    Computes the relationship between a point and a closed curve region.\n    This curve must be closed or the return value will be Unset.\n    Both curve and point are projected to the World XY plane.\n\n    Args:\n        testPoint (Point3d): Point to test.\n\n    Returns:\n        PointContainment: Relationship between point and curve region.\n    \"\"\"\n    url = \"rhino/geometry/curve/contains-curve_point3d\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint]\n    if multiple: args = list(zip(thisCurve, testPoint))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef Contains1(thisCurve, testPoint, plane, multiple=False):\n    \"\"\"\n    Computes the relationship between a point and a closed curve region.\n    This curve must be closed or the return value will be Unset.\n\n    Args:\n        testPoint (Point3d): Point to test.\n        plane (Plane): Plane in which to compare point and region.\n\n    Returns:\n        PointContainment: Relationship between point and curve region.\n    \"\"\"\n    url = \"rhino/geometry/curve/contains-curve_point3d_plane\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, plane]\n    if multiple: args = list(zip(thisCurve, testPoint, plane))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef Contains2(thisCurve, testPoint, plane, tolerance, multiple=False):\n    \"\"\"\n    Computes the relationship between a point and a closed curve region.\n    This curve must be closed or the return value will be Unset.\n\n    Args:\n        testPoint (Point3d): Point to test.\n        plane (Plane): Plane in which to compare point and region.\n        tolerance (double): Tolerance to use during comparison.\n\n    Returns:\n        PointContainment: Relationship between point and curve region.\n    \"\"\"\n    url = \"rhino/geometry/curve/contains-curve_point3d_plane_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, plane, tolerance]\n    if multiple: args = list(zip(thisCurve, testPoint, plane, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ExtremeParameters(thisCurve, direction, multiple=False):\n    \"\"\"\n    Returns the parameter values of all local extrema.\n    Parameter values are in increasing order so consecutive extrema\n    define an interval on which each component of the curve is monotone.\n    Note, non-periodic curves always return the end points.\n\n    Args:\n        direction (Vector3d): The direction in which to perform the calculation.\n\n    Returns:\n        double[]: The parameter values of all local extrema.\n    \"\"\"\n    url = \"rhino/geometry/curve/extremeparameters-curve_vector3d\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, direction]\n    if multiple: args = list(zip(thisCurve, direction))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CreatePeriodicCurve(curve, multiple=False):\n    \"\"\"\n    Removes kinks from a curve. Periodic curves deform smoothly without kinks.\n\n    Args:\n        curve (Curve): The curve to make periodic. Curve must have degree >= 2.\n\n    Returns:\n        Curve: The resulting curve if successful, None otherwise.\n    \"\"\"\n    url = \"rhino/geometry/curve/createperiodiccurve-curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve]\n    if multiple: args = [[item] for item in curve]\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreatePeriodicCurve1(curve, smooth, multiple=False):\n    \"\"\"\n    Removes kinks from a curve. Periodic curves deform smoothly without kinks.\n\n    Args:\n        curve (Curve): The curve to make periodic. Curve must have degree >= 2.\n        smooth (bool): If true, smooths any kinks in the curve and moves control points to make a smooth curve.\n            If false, control point locations are not changed or changed minimally (only one point may move) and only the knot vector is altered.\n\n    Returns:\n        Curve: The resulting curve if successful, None otherwise.\n    \"\"\"\n    url = \"rhino/geometry/curve/createperiodiccurve-curve_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, smooth]\n    if multiple: args = list(zip(curve, smooth))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef PointAtLength(thisCurve, length, multiple=False):\n    \"\"\"\n    Gets a point at a certain length along the curve. The length must be\n    non-negative and less than or equal to the length of the curve.\n    Lengths will not be wrapped when the curve is closed or periodic.\n\n    Args:\n        length (double): Length along the curve between the start point and the returned point.\n\n    Returns:\n        Point3d: Point on the curve at the specified length from the start point or Poin3d.Unset on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/pointatlength-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, length]\n    if multiple: args = list(zip(thisCurve, length))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToPoint3d(response)\n    return response\n\n\ndef PointAtNormalizedLength(thisCurve, length, multiple=False):\n    \"\"\"\n    Gets a point at a certain normalized length along the curve. The length must be\n    between or including 0.0 and 1.0, where 0.0 equals the start of the curve and\n    1.0 equals the end of the curve.\n\n    Args:\n        length (double): Normalized length along the curve between the start point and the returned point.\n\n    Returns:\n        Point3d: Point on the curve at the specified normalized length from the start point or Poin3d.Unset on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/pointatnormalizedlength-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, length]\n    if multiple: args = list(zip(thisCurve, length))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToPoint3d(response)\n    return response\n\n\ndef PerpendicularFrameAt(thisCurve, t, multiple=False):\n    \"\"\"\n    Return a 3d frame at a parameter. This is slightly different than FrameAt in\n    that the frame is computed in a way so there is minimal rotation from one\n    frame to the next.\n\n    Args:\n        t (double): Evaluation parameter.\n\n    Returns:\n        bool: True on success, False on failure.\n        plane (Plane): The frame is returned here.\n    \"\"\"\n    url = \"rhino/geometry/curve/perpendicularframeat-curve_double_plane\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, t]\n    if multiple: args = list(zip(thisCurve, t))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetPerpendicularFrames(thisCurve, parameters, multiple=False):\n    \"\"\"\n    Gets a collection of perpendicular frames along the curve. Perpendicular frames\n    are also known as 'Zero-twisting frames' and they minimize rotation from one frame to the next.\n\n    Args:\n        parameters (IEnumerable<double>): A collection of strictly increasing curve parameters to place perpendicular frames on.\n\n    Returns:\n        Plane[]: An array of perpendicular frames on success or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/getperpendicularframes-curve_doublearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, parameters]\n    if multiple: args = list(zip(thisCurve, parameters))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLength(thisCurve, multiple=False):\n    \"\"\"\n    Gets the length of the curve with a fractional tolerance of 1.0e-8.\n\n    Returns:\n        double: The length of the curve on success, or zero on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/getlength-curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve]\n    if multiple: args = [[item] for item in thisCurve]\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLength1(thisCurve, fractionalTolerance, multiple=False):\n    \"\"\"\n    Get the length of the curve.\n\n    Args:\n        fractionalTolerance (double): Desired fractional precision.\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\n\n    Returns:\n        double: The length of the curve on success, or zero on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/getlength-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, fractionalTolerance]\n    if multiple: args = list(zip(thisCurve, fractionalTolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLength2(thisCurve, subdomain, multiple=False):\n    \"\"\"\n    Get the length of a sub-section of the curve with a fractional tolerance of 1e-8.\n\n    Args:\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).\n\n    Returns:\n        double: The length of the sub-curve on success, or zero on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/getlength-curve_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, subdomain]\n    if multiple: args = list(zip(thisCurve, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLength3(thisCurve, fractionalTolerance, subdomain, multiple=False):\n    \"\"\"\n    Get the length of a sub-section of the curve.\n\n    Args:\n        fractionalTolerance (double): Desired fractional precision.\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).\n\n    Returns:\n        double: The length of the sub-curve on success, or zero on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/getlength-curve_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, fractionalTolerance, subdomain]\n    if multiple: args = list(zip(thisCurve, fractionalTolerance, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef IsShort(thisCurve, tolerance, multiple=False):\n    \"\"\"\n    Used to quickly find short curves.\n\n    Args:\n        tolerance (double): Length threshold value for \"shortness\".\n\n    Returns:\n        bool: True if the length of the curve is <= tolerance.\n    \"\"\"\n    url = \"rhino/geometry/curve/isshort-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance]\n    if multiple: args = list(zip(thisCurve, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef IsShort1(thisCurve, tolerance, subdomain, multiple=False):\n    \"\"\"\n    Used to quickly find short curves.\n\n    Args:\n        tolerance (double): Length threshold value for \"shortness\".\n        subdomain (Interval): The test is performed on the interval that is the intersection of sub-domain with Domain()\n\n    Returns:\n        bool: True if the length of the curve is <= tolerance.\n    \"\"\"\n    url = \"rhino/geometry/curve/isshort-curve_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance, subdomain]\n    if multiple: args = list(zip(thisCurve, tolerance, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef RemoveShortSegments(thisCurve, tolerance, multiple=False):\n    \"\"\"\n    Looks for segments that are shorter than tolerance that can be removed.\n    Does not change the domain, but it will change the relative parameterization.\n\n    Args:\n        tolerance (double): Tolerance which defines \"short\" segments.\n\n    Returns:\n        bool: True if removable short segments were found.\n        False if no removable short segments were found.\n    \"\"\"\n    url = \"rhino/geometry/curve/removeshortsegments-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance]\n    if multiple: args = list(zip(thisCurve, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef LengthParameter(thisCurve, segmentLength, multiple=False):\n    \"\"\"\n    Gets the parameter along the curve which coincides with a given length along the curve.\n    A fractional tolerance of 1e-8 is used in this version of the function.\n\n    Args:\n        segmentLength (double): Length of segment to measure. Must be less than or equal to the length of the curve.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from the curve start point to t equals length.\n    \"\"\"\n    url = \"rhino/geometry/curve/lengthparameter-curve_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength]\n    if multiple: args = list(zip(thisCurve, segmentLength))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef LengthParameter1(thisCurve, segmentLength, fractionalTolerance, multiple=False):\n    \"\"\"\n    Gets the parameter along the curve which coincides with a given length along the curve.\n\n    Args:\n        segmentLength (double): Length of segment to measure. Must be less than or equal to the length of the curve.\n        fractionalTolerance (double): Desired fractional precision.\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from the curve start point to t equals s.\n    \"\"\"\n    url = \"rhino/geometry/curve/lengthparameter-curve_double_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, fractionalTolerance]\n    if multiple: args = list(zip(thisCurve, segmentLength, fractionalTolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef LengthParameter2(thisCurve, segmentLength, subdomain, multiple=False):\n    \"\"\"\n    Gets the parameter along the curve which coincides with a given length along the curve.\n    A fractional tolerance of 1e-8 is used in this version of the function.\n\n    Args:\n        segmentLength (double): Length of segment to measure. Must be less than or equal to the length of the sub-domain.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve rather than the whole curve.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from the start of the sub-domain to t is s.\n    \"\"\"\n    url = \"rhino/geometry/curve/lengthparameter-curve_double_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, subdomain]\n    if multiple: args = list(zip(thisCurve, segmentLength, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef LengthParameter3(thisCurve, segmentLength, fractionalTolerance, subdomain, multiple=False):\n    \"\"\"\n    Gets the parameter along the curve which coincides with a given length along the curve.\n\n    Args:\n        segmentLength (double): Length of segment to measure. Must be less than or equal to the length of the sub-domain.\n        fractionalTolerance (double): Desired fractional precision.\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve rather than the whole curve.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from the start of the sub-domain to t is s.\n    \"\"\"\n    url = \"rhino/geometry/curve/lengthparameter-curve_double_double_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, fractionalTolerance, subdomain]\n    if multiple: args = list(zip(thisCurve, segmentLength, fractionalTolerance, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameter(thisCurve, s, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n    A fractional tolerance of 1e-8 is used in this version of the function.\n\n    Args:\n        s (double): Normalized arc length parameter.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from its start to t is arc_length.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameter-curve_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s]\n    if multiple: args = list(zip(thisCurve, s))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameter1(thisCurve, s, fractionalTolerance, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n\n    Args:\n        s (double): Normalized arc length parameter.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        fractionalTolerance (double): Desired fractional precision.\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from its start to t is arc_length.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameter-curve_double_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, fractionalTolerance]\n    if multiple: args = list(zip(thisCurve, s, fractionalTolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameter2(thisCurve, s, subdomain, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n    A fractional tolerance of 1e-8 is used in this version of the function.\n\n    Args:\n        s (double): Normalized arc length parameter.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from its start to t is arc_length.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameter-curve_double_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, subdomain]\n    if multiple: args = list(zip(thisCurve, s, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameter3(thisCurve, s, fractionalTolerance, subdomain, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n\n    Args:\n        s (double): Normalized arc length parameter.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        fractionalTolerance (double): Desired fractional precision.\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from its start to t is arc_length.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameter-curve_double_double_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, fractionalTolerance, subdomain]\n    if multiple: args = list(zip(thisCurve, s, fractionalTolerance, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameters(thisCurve, s, absoluteTolerance, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n    A fractional tolerance of 1e-8 is used in this version of the function.\n\n    Args:\n        s (double[]): Array of normalized arc length parameters.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        absoluteTolerance (double): If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length\n            and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n\n    Returns:\n        double[]: If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length.\n        Null on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameters-curve_doublearray_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, absoluteTolerance]\n    if multiple: args = list(zip(thisCurve, s, absoluteTolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameters1(thisCurve, s, absoluteTolerance, fractionalTolerance, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n\n    Args:\n        s (double[]): Array of normalized arc length parameters.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        absoluteTolerance (double): If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length\n            and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n        fractionalTolerance (double): Desired fractional precision for each segment.\n            fabs(\"true\" length - actual length)/(actual length) <= fractionalTolerance.\n\n    Returns:\n        double[]: If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length.\n        Null on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameters-curve_doublearray_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, absoluteTolerance, fractionalTolerance]\n    if multiple: args = list(zip(thisCurve, s, absoluteTolerance, fractionalTolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameters2(thisCurve, s, absoluteTolerance, subdomain, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n    A fractional tolerance of 1e-8 is used in this version of the function.\n\n    Args:\n        s (double[]): Array of normalized arc length parameters.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        absoluteTolerance (double): If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length\n            and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve.\n            A 0.0 s value corresponds to sub-domain->Min() and a 1.0 s value corresponds to sub-domain->Max().\n\n    Returns:\n        double[]: If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length.\n        Null on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameters-curve_doublearray_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, absoluteTolerance, subdomain]\n    if multiple: args = list(zip(thisCurve, s, absoluteTolerance, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameters3(thisCurve, s, absoluteTolerance, fractionalTolerance, subdomain, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n\n    Args:\n        s (double[]): Array of normalized arc length parameters.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        absoluteTolerance (double): If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length\n            and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n        fractionalTolerance (double): Desired fractional precision for each segment.\n            fabs(\"true\" length - actual length)/(actual length) <= fractionalTolerance.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve.\n            A 0.0 s value corresponds to sub-domain->Min() and a 1.0 s value corresponds to sub-domain->Max().\n\n    Returns:\n        double[]: If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length.\n        Null on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameters-curve_doublearray_double_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, absoluteTolerance, fractionalTolerance, subdomain]\n    if multiple: args = list(zip(thisCurve, s, absoluteTolerance, fractionalTolerance, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideByCount(thisCurve, segmentCount, includeEnds, multiple=False):\n    \"\"\"\n    Divide the curve into a number of equal-length segments.\n\n    Args:\n        segmentCount (int): Segment count. Note that the number of division points may differ from the segment count.\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\n\n    Returns:\n        double[]: List of curve parameters at the division points on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/dividebycount-curve_int_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentCount, includeEnds]\n    if multiple: args = list(zip(thisCurve, segmentCount, includeEnds))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideByCount1(thisCurve, segmentCount, includeEnds, multiple=False):\n    \"\"\"\n    Divide the curve into a number of equal-length segments.\n\n    Args:\n        segmentCount (int): Segment count. Note that the number of division points may differ from the segment count.\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\n\n    Returns:\n        double[]: Array containing division curve parameters on success, None on failure.\n        points (Point3d[]): A list of division points. If the function returns successfully, this point-array will be filled in.\n    \"\"\"\n    url = \"rhino/geometry/curve/dividebycount-curve_int_bool_point3darray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentCount, includeEnds]\n    if multiple: args = list(zip(thisCurve, segmentCount, includeEnds))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideByLength(thisCurve, segmentLength, includeEnds, multiple=False):\n    \"\"\"\n    Divide the curve into specific length segments.\n\n    Args:\n        segmentLength (double): The length of each and every segment (except potentially the last one).\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\n\n    Returns:\n        double[]: Array containing division curve parameters if successful, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/dividebylength-curve_double_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, includeEnds]\n    if multiple: args = list(zip(thisCurve, segmentLength, includeEnds))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideByLength1(thisCurve, segmentLength, includeEnds, reverse, multiple=False):\n    \"\"\"\n    Divide the curve into specific length segments.\n\n    Args:\n        segmentLength (double): The length of each and every segment (except potentially the last one).\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\n        reverse (bool): If true, then the divisions start from the end of the curve.\n\n    Returns:\n        double[]: Array containing division curve parameters if successful, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/dividebylength-curve_double_bool_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, includeEnds, reverse]\n    if multiple: args = list(zip(thisCurve, segmentLength, includeEnds, reverse))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideByLength2(thisCurve, segmentLength, includeEnds, multiple=False):\n    \"\"\"\n    Divide the curve into specific length segments.\n\n    Args:\n        segmentLength (double): The length of each and every segment (except potentially the last one).\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\n\n    Returns:\n        double[]: Array containing division curve parameters if successful, None on failure.\n        points (Point3d[]): If function is successful, points at each parameter value are returned in points.\n    \"\"\"\n    url = \"rhino/geometry/curve/dividebylength-curve_double_bool_point3darray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, includeEnds]\n    if multiple: args = list(zip(thisCurve, segmentLength, includeEnds))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideByLength3(thisCurve, segmentLength, includeEnds, reverse, multiple=False):\n    \"\"\"\n    Divide the curve into specific length segments.\n\n    Args:\n        segmentLength (double): The length of each and every segment (except potentially the last one).\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\n        reverse (bool): If true, then the divisions start from the end of the curve.\n\n    Returns:\n        double[]: Array containing division curve parameters if successful, None on failure.\n        points (Point3d[]): If function is successful, points at each parameter value are returned in points.\n    \"\"\"\n    url = \"rhino/geometry/curve/dividebylength-curve_double_bool_bool_point3darray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, includeEnds, reverse]\n    if multiple: args = list(zip(thisCurve, segmentLength, includeEnds, reverse))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideEquidistant(thisCurve, distance, multiple=False):\n    \"\"\"\n    Calculates 3d points on a curve where the linear distance between the points is equal.\n\n    Args:\n        distance (double): The distance between division points.\n\n    Returns:\n        Point3d[]: An array of equidistant points, or None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/divideequidistant-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, distance]\n    if multiple: args = list(zip(thisCurve, distance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToPoint3d(response)\n    return response\n\n\ndef DivideAsContour(thisCurve, contourStart, contourEnd, interval, multiple=False):\n    \"\"\"\n    Divides this curve at fixed steps along a defined contour line.\n\n    Args:\n        contourStart (Point3d): The start of the contouring line.\n        contourEnd (Point3d): The end of the contouring line.\n        interval (double): A distance to measure on the contouring axis.\n\n    Returns:\n        Point3d[]: An array of points; or None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/divideascontour-curve_point3d_point3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, contourStart, contourEnd, interval]\n    if multiple: args = list(zip(thisCurve, contourStart, contourEnd, interval))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToPoint3d(response)\n    return response\n\n\ndef Trim(thisCurve, side, length, multiple=False):\n    \"\"\"\n    Shortens a curve by a given length\n\n    Returns:\n        Curve: Trimmed curve if successful, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/trim-curve_curveend_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, length]\n    if multiple: args = list(zip(thisCurve, side, length))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Split(thisCurve, cutter, tolerance, multiple=False):\n    \"\"\"\n    Splits a curve into pieces using a polysurface.\n\n    Args:\n        cutter (Brep): A cutting surface or polysurface.\n        tolerance (double): A tolerance for computing intersections.\n\n    Returns:\n        Curve[]: An array of curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/split-curve_brep_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, cutter, tolerance]\n    if multiple: args = list(zip(thisCurve, cutter, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Split1(thisCurve, cutter, tolerance, angleToleranceRadians, multiple=False):\n    \"\"\"\n    Splits a curve into pieces using a polysurface.\n\n    Args:\n        cutter (Brep): A cutting surface or polysurface.\n        tolerance (double): A tolerance for computing intersections.\n\n    Returns:\n        Curve[]: An array of curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/split-curve_brep_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, cutter, tolerance, angleToleranceRadians]\n    if multiple: args = list(zip(thisCurve, cutter, tolerance, angleToleranceRadians))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Split2(thisCurve, cutter, tolerance, multiple=False):\n    \"\"\"\n    Splits a curve into pieces using a surface.\n\n    Args:\n        cutter (Surface): A cutting surface or polysurface.\n        tolerance (double): A tolerance for computing intersections.\n\n    Returns:\n        Curve[]: An array of curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/split-curve_surface_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, cutter, tolerance]\n    if multiple: args = list(zip(thisCurve, cutter, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Split3(thisCurve, cutter, tolerance, angleToleranceRadians, multiple=False):\n    \"\"\"\n    Splits a curve into pieces using a surface.\n\n    Args:\n        cutter (Surface): A cutting surface or polysurface.\n        tolerance (double): A tolerance for computing intersections.\n\n    Returns:\n        Curve[]: An array of curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/split-curve_surface_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, cutter, tolerance, angleToleranceRadians]\n    if multiple: args = list(zip(thisCurve, cutter, tolerance, angleToleranceRadians))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Extend(thisCurve, t0, t1, multiple=False):\n    \"\"\"\n    Where possible, analytically extends curve to include the given domain.\n    This will not work on closed curves. The original curve will be identical to the\n    restriction of the resulting curve to the original curve domain.\n\n    Args:\n        t0 (double): Start of extension domain, if the start is not inside the\n            Domain of this curve, an attempt will be made to extend the curve.\n        t1 (double): End of extension domain, if the end is not inside the\n            Domain of this curve, an attempt will be made to extend the curve.\n\n    Returns:\n        Curve: Extended curve on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extend-curve_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, t0, t1]\n    if multiple: args = list(zip(thisCurve, t0, t1))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Extend1(thisCurve, domain, multiple=False):\n    \"\"\"\n    Where possible, analytically extends curve to include the given domain.\n    This will not work on closed curves. The original curve will be identical to the\n    restriction of the resulting curve to the original curve domain.\n\n    Args:\n        domain (Interval): Extension domain.\n\n    Returns:\n        Curve: Extended curve on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extend-curve_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, domain]\n    if multiple: args = list(zip(thisCurve, domain))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Extend2(thisCurve, side, length, style, multiple=False):\n    \"\"\"\n    Extends a curve by a specific length.\n\n    Args:\n        side (CurveEnd): Curve end to extend.\n        length (double): Length to add to the curve end.\n        style (CurveExtensionStyle): Extension style.\n\n    Returns:\n        Curve: A curve with extended ends or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extend-curve_curveend_double_curveextensionstyle\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, length, style]\n    if multiple: args = list(zip(thisCurve, side, length, style))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Extend3(thisCurve, side, style, geometry, multiple=False):\n    \"\"\"\n    Extends a curve until it intersects a collection of objects.\n\n    Args:\n        side (CurveEnd): The end of the curve to extend.\n        style (CurveExtensionStyle): The style or type of extension to use.\n        geometry (System.Collections.Generic.IEnumerable<GeometryBase>): A collection of objects. Allowable object types are Curve, Surface, Brep.\n\n    Returns:\n        Curve: New extended curve result on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extend-curve_curveend_curveextensionstyle_geometrybasearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, style, geometry]\n    if multiple: args = list(zip(thisCurve, side, style, geometry))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Extend4(thisCurve, side, style, endPoint, multiple=False):\n    \"\"\"\n    Extends a curve to a point.\n\n    Args:\n        side (CurveEnd): The end of the curve to extend.\n        style (CurveExtensionStyle): The style or type of extension to use.\n        endPoint (Point3d): A new end point.\n\n    Returns:\n        Curve: New extended curve result on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extend-curve_curveend_curveextensionstyle_point3d\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, style, endPoint]\n    if multiple: args = list(zip(thisCurve, side, style, endPoint))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ExtendOnSurface(thisCurve, side, surface, multiple=False):\n    \"\"\"\n    Extends a curve on a surface.\n\n    Args:\n        side (CurveEnd): The end of the curve to extend.\n        surface (Surface): Surface that contains the curve.\n\n    Returns:\n        Curve: New extended curve result on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extendonsurface-curve_curveend_surface\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, surface]\n    if multiple: args = list(zip(thisCurve, side, surface))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ExtendOnSurface1(thisCurve, side, face, multiple=False):\n    \"\"\"\n    Extends a curve on a surface.\n\n    Args:\n        side (CurveEnd): The end of the curve to extend.\n        face (BrepFace): BrepFace that contains the curve.\n\n    Returns:\n        Curve: New extended curve result on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extendonsurface-curve_curveend_brepface\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, face]\n    if multiple: args = list(zip(thisCurve, side, face))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ExtendByLine(thisCurve, side, geometry, multiple=False):\n    \"\"\"\n    Extends a curve by a line until it intersects a collection of objects.\n\n    Args:\n        side (CurveEnd): The end of the curve to extend.\n        geometry (System.Collections.Generic.IEnumerable<GeometryBase>): A collection of objects. Allowable object types are Curve, Surface, Brep.\n\n    Returns:\n        Curve: New extended curve result on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extendbyline-curve_curveend_geometrybasearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, geometry]\n    if multiple: args = list(zip(thisCurve, side, geometry))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ExtendByArc(thisCurve, side, geometry, multiple=False):\n    \"\"\"\n    Extends a curve by an Arc until it intersects a collection of objects.\n\n    Args:\n        side (CurveEnd): The end of the curve to extend.\n        geometry (System.Collections.Generic.IEnumerable<GeometryBase>): A collection of objects. Allowable object types are Curve, Surface, Brep.\n\n    Returns:\n        Curve: New extended curve result on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extendbyarc-curve_curveend_geometrybasearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, geometry]\n    if multiple: args = list(zip(thisCurve, side, geometry))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Simplify(thisCurve, options, distanceTolerance, angleToleranceRadians, multiple=False):\n    \"\"\"\n    Returns a geometrically equivalent PolyCurve.\n    The PolyCurve has the following properties\n    1. All the PolyCurve segments are LineCurve, PolylineCurve, ArcCurve, or NurbsCurve.\n    \n    2. The NURBS Curves segments do not have fully multiple interior knots.\n    \n    3. Rational NURBS curves do not have constant weights.\n    \n    4. Any segment for which IsLinear() or IsArc() is True is a Line,\n    Polyline segment, or an Arc.\n    \n    5. Adjacent co-linear or co-circular segments are combined.\n    \n    6. Segments that meet with G1-continuity have there ends tuned up so\n    that they meet with G1-continuity to within machine precision.\n\n    Args:\n        options (CurveSimplifyOptions): Simplification options.\n        distanceTolerance (double): A distance tolerance for the simplification.\n        angleToleranceRadians (double): An angle tolerance for the simplification.\n\n    Returns:\n        Curve: New simplified curve on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/simplify-curve_curvesimplifyoptions_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, options, distanceTolerance, angleToleranceRadians]\n    if multiple: args = list(zip(thisCurve, options, distanceTolerance, angleToleranceRadians))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef SimplifyEnd(thisCurve, end, options, distanceTolerance, angleToleranceRadians, multiple=False):\n    \"\"\"\n    Same as SimplifyCurve, but simplifies only the last two segments at \"side\" end.\n\n    Args:\n        end (CurveEnd): If CurveEnd.Start the function simplifies the last two start\n            side segments, otherwise if CurveEnd.End the last two end side segments are simplified.\n        options (CurveSimplifyOptions): Simplification options.\n        distanceTolerance (double): A distance tolerance for the simplification.\n        angleToleranceRadians (double): An angle tolerance for the simplification.\n\n    Returns:\n        Curve: New simplified curve on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/simplifyend-curve_curveend_curvesimplifyoptions_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, end, options, distanceTolerance, angleToleranceRadians]\n    if multiple: args = list(zip(thisCurve, end, options, distanceTolerance, angleToleranceRadians))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Fair(thisCurve, distanceTolerance, angleTolerance, clampStart, clampEnd, iterations, multiple=False):\n    \"\"\"\n    Fairs a curve object. Fair works best on degree 3 (cubic) curves. Attempts to\n    remove large curvature variations while limiting the geometry changes to be no\n    more than the specified tolerance.\n\n    Args:\n        distanceTolerance (double): Maximum allowed distance the faired curve is allowed to deviate from the input.\n        angleTolerance (double): (in radians) kinks with angles <= angleTolerance are smoothed out 0.05 is a good default.\n        clampStart (int): The number of (control vertices-1) to preserve at start.\n            0 = preserve start point1 = preserve start point and 1st derivative2 = preserve start point, 1st and 2nd derivative\n        clampEnd (int): Same as clampStart.\n        iterations (int): The number of iterations to use in adjusting the curve.\n\n    Returns:\n        Curve: Returns new faired Curve on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/fair-curve_double_double_int_int_int\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, distanceTolerance, angleTolerance, clampStart, clampEnd, iterations]\n    if multiple: args = list(zip(thisCurve, distanceTolerance, angleTolerance, clampStart, clampEnd, iterations))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Fit(thisCurve, degree, fitTolerance, angleTolerance, multiple=False):\n    \"\"\"\n    Fits a new curve through an existing curve.\n\n    Args:\n        degree (int): The degree of the returned Curve. Must be bigger than 1.\n        fitTolerance (double): The fitting tolerance. If fitTolerance is RhinoMath.UnsetValue or <=0.0,\n            the document absolute tolerance is used.\n        angleTolerance (double): The kink smoothing tolerance in radians.\n            If angleTolerance is 0.0, all kinks are smoothedIf angleTolerance is >0.0, kinks smaller than angleTolerance are smoothedIf angleTolerance is RhinoMath.UnsetValue or <0.0, the document angle tolerance is used for the kink smoothing\n\n    Returns:\n        Curve: Returns a new fitted Curve if successful, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/fit-curve_int_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, degree, fitTolerance, angleTolerance]\n    if multiple: args = list(zip(thisCurve, degree, fitTolerance, angleTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Rebuild(thisCurve, pointCount, degree, preserveTangents, multiple=False):\n    \"\"\"\n    Rebuild a curve with a specific point count.\n\n    Args:\n        pointCount (int): Number of control points in the rebuild curve.\n        degree (int): Degree of curve. Valid values are between and including 1 and 11.\n        preserveTangents (bool): If true, the end tangents of the input curve will be preserved.\n\n    Returns:\n        NurbsCurve: A NURBS curve on success or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/rebuild-curve_int_int_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, pointCount, degree, preserveTangents]\n    if multiple: args = list(zip(thisCurve, pointCount, degree, preserveTangents))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ToPolyline(thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint, multiple=False):\n    \"\"\"\n    Gets a polyline approximation of a curve.\n\n    Args:\n        mainSegmentCount (int): If mainSegmentCount <= 0, then both subSegmentCount and mainSegmentCount are ignored.\n            If mainSegmentCount > 0, then subSegmentCount must be >= 1. In this\n            case the NURBS will be broken into mainSegmentCount equally spaced\n            chords. If needed, each of these chords can be split into as many\n            subSegmentCount sub-parts if the subdivision is necessary for the\n            mesh to meet the other meshing constraints. In particular, if\n            subSegmentCount = 0, then the curve is broken into mainSegmentCount\n            pieces and no further testing is performed.\n        subSegmentCount (int): An amount of subsegments.\n        maxAngleRadians (double): ( 0 to pi ) Maximum angle (in radians) between unit tangents at\n            adjacent vertices.\n        maxChordLengthRatio (double): Maximum permitted value of\n            (distance chord midpoint to curve) / (length of chord).\n        maxAspectRatio (double): If maxAspectRatio < 1.0, the parameter is ignored.\n            If 1 <= maxAspectRatio < sqrt(2), it is treated as if maxAspectRatio = sqrt(2).\n            This parameter controls the maximum permitted value of\n            (length of longest chord) / (length of shortest chord).\n        tolerance (double): If tolerance = 0, the parameter is ignored.\n            This parameter controls the maximum permitted value of the\n            distance from the curve to the polyline.\n        minEdgeLength (double): The minimum permitted edge length.\n        maxEdgeLength (double): If maxEdgeLength = 0, the parameter\n            is ignored. This parameter controls the maximum permitted edge length.\n        keepStartPoint (bool): If True the starting point of the curve\n            is added to the polyline. If False the starting point of the curve is\n            not added to the polyline.\n\n    Returns:\n        PolylineCurve: PolylineCurve on success, None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/topolyline-curve_int_int_double_double_double_double_double_double_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint]\n    if multiple: args = list(zip(thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ToPolyline1(thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint, curveDomain, multiple=False):\n    \"\"\"\n    Gets a polyline approximation of a curve.\n\n    Args:\n        mainSegmentCount (int): If mainSegmentCount <= 0, then both subSegmentCount and mainSegmentCount are ignored.\n            If mainSegmentCount > 0, then subSegmentCount must be >= 1. In this\n            case the NURBS will be broken into mainSegmentCount equally spaced\n            chords. If needed, each of these chords can be split into as many\n            subSegmentCount sub-parts if the subdivision is necessary for the\n            mesh to meet the other meshing constraints. In particular, if\n            subSegmentCount = 0, then the curve is broken into mainSegmentCount\n            pieces and no further testing is performed.\n        subSegmentCount (int): An amount of subsegments.\n        maxAngleRadians (double): ( 0 to pi ) Maximum angle (in radians) between unit tangents at\n            adjacent vertices.\n        maxChordLengthRatio (double): Maximum permitted value of\n            (distance chord midpoint to curve) / (length of chord).\n        maxAspectRatio (double): If maxAspectRatio < 1.0, the parameter is ignored.\n            If 1 <= maxAspectRatio < sqrt(2), it is treated as if maxAspectRatio = sqrt(2).\n            This parameter controls the maximum permitted value of\n            (length of longest chord) / (length of shortest chord).\n        tolerance (double): If tolerance = 0, the parameter is ignored.\n            This parameter controls the maximum permitted value of the\n            distance from the curve to the polyline.\n        minEdgeLength (double): The minimum permitted edge length.\n        maxEdgeLength (double): If maxEdgeLength = 0, the parameter\n            is ignored. This parameter controls the maximum permitted edge length.\n        keepStartPoint (bool): If True the starting point of the curve\n            is added to the polyline. If False the starting point of the curve is\n            not added to the polyline.\n        curveDomain (Interval): This sub-domain of the NURBS curve is approximated.\n\n    Returns:\n        PolylineCurve: PolylineCurve on success, None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/topolyline-curve_int_int_double_double_double_double_double_double_bool_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint, curveDomain]\n    if multiple: args = list(zip(thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint, curveDomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ToPolyline2(thisCurve, tolerance, angleTolerance, minimumLength, maximumLength, multiple=False):\n    \"\"\"\n    Gets a polyline approximation of a curve.\n\n    Args:\n        tolerance (double): The tolerance. This is the maximum deviation from line midpoints to the curve. When in doubt, use the document's model space absolute tolerance.\n        angleTolerance (double): The angle tolerance in radians. This is the maximum deviation of the line directions. When in doubt, use the document's model space angle tolerance.\n        minimumLength (double): The minimum segment length.\n        maximumLength (double): The maximum segment length.\n\n    Returns:\n        PolylineCurve: PolyCurve on success, None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/topolyline-curve_double_double_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance, angleTolerance, minimumLength, maximumLength]\n    if multiple: args = list(zip(thisCurve, tolerance, angleTolerance, minimumLength, maximumLength))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ToArcsAndLines(thisCurve, tolerance, angleTolerance, minimumLength, maximumLength, multiple=False):\n    \"\"\"\n    Converts a curve into polycurve consisting of arc segments. Sections of the input curves that are nearly straight are converted to straight-line segments.\n\n    Args:\n        tolerance (double): The tolerance. This is the maximum deviation from arc midpoints to the curve. When in doubt, use the document's model space absolute tolerance.\n        angleTolerance (double): The angle tolerance in radians. This is the maximum deviation of the arc end directions from the curve direction. When in doubt, use the document's model space angle tolerance.\n        minimumLength (double): The minimum segment length.\n        maximumLength (double): The maximum segment length.\n\n    Returns:\n        PolyCurve: PolyCurve on success, None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/toarcsandlines-curve_double_double_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance, angleTolerance, minimumLength, maximumLength]\n    if multiple: args = list(zip(thisCurve, tolerance, angleTolerance, minimumLength, maximumLength))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef PullToMesh(thisCurve, mesh, tolerance, multiple=False):\n    \"\"\"\n    Makes a polyline approximation of the curve and gets the closest point on the mesh for each point on the curve.\n    Then it \"connects the points\" so that you have a polyline on the mesh.\n\n    Args:\n        mesh (Mesh): Mesh to project onto.\n        tolerance (double): Input tolerance (RhinoDoc.ModelAbsoluteTolerance is a good default)\n\n    Returns:\n        PolylineCurve: A polyline curve on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/pulltomesh-curve_mesh_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, mesh, tolerance]\n    if multiple: args = list(zip(thisCurve, mesh, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef Offset(thisCurve, plane, distance, tolerance, cornerStyle, multiple=False):\n    \"\"\"\n    Offsets this curve. If you have a nice offset, then there will be one entry in\n    the array. If the original curve had kinks or the offset curve had self\n    intersections, you will get multiple segments in the output array.\n\n    Args:\n        plane (Plane): Offset solution plane.\n        distance (double): The positive or negative distance to offset.\n        tolerance (double): The offset or fitting tolerance.\n        cornerStyle (CurveOffsetCornerStyle): Corner style for offset kinks.\n\n    Returns:\n        Curve[]: Offset curves on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offset-curve_plane_double_double_curveoffsetcornerstyle\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, plane, distance, tolerance, cornerStyle]\n    if multiple: args = list(zip(thisCurve, plane, distance, tolerance, cornerStyle))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Offset1(thisCurve, directionPoint, normal, distance, tolerance, cornerStyle, multiple=False):\n    \"\"\"\n    Offsets this curve. If you have a nice offset, then there will be one entry in\n    the array. If the original curve had kinks or the offset curve had self\n    intersections, you will get multiple segments in the output array.\n\n    Args:\n        directionPoint (Point3d): A point that indicates the direction of the offset.\n        normal (Vector3d): The normal to the offset plane.\n        distance (double): The positive or negative distance to offset.\n        tolerance (double): The offset or fitting tolerance.\n        cornerStyle (CurveOffsetCornerStyle): Corner style for offset kinks.\n\n    Returns:\n        Curve[]: Offset curves on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offset-curve_point3d_vector3d_double_double_curveoffsetcornerstyle\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, directionPoint, normal, distance, tolerance, cornerStyle]\n    if multiple: args = list(zip(thisCurve, directionPoint, normal, distance, tolerance, cornerStyle))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Offset2(thisCurve, directionPoint, normal, distance, tolerance, angleTolerance, loose, cornerStyle, endStyle, multiple=False):\n    \"\"\"\n    Offsets this curve. If you have a nice offset, then there will be one entry in\n    the array. If the original curve had kinks or the offset curve had self\n    intersections, you will get multiple segments in the output array.\n\n    Args:\n        directionPoint (Point3d): A point that indicates the direction of the offset.\n        normal (Vector3d): The normal to the offset plane.\n        distance (double): The positive or negative distance to offset.\n        tolerance (double): The offset or fitting tolerance.\n        angleTolerance (double): The angle tolerance, in radians, used to decide whether to split at kinks.\n        loose (bool): If false, offset within tolerance. If true, offset by moving edit points.\n        cornerStyle (CurveOffsetCornerStyle): Corner style for offset kinks.\n        endStyle (CurveOffsetEndStyle): End style for non-loose, non-closed curve offsets.\n\n    Returns:\n        Curve[]: Offset curves on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offset-curve_point3d_vector3d_double_double_double_bool_curveoffsetcornerstyle_curveoffsetendstyle\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, directionPoint, normal, distance, tolerance, angleTolerance, loose, cornerStyle, endStyle]\n    if multiple: args = list(zip(thisCurve, directionPoint, normal, distance, tolerance, angleTolerance, loose, cornerStyle, endStyle))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef RibbonOffset(thisCurve, distance, blendRadius, directionPoint, normal, tolerance, multiple=False):\n    \"\"\"\n    Offsets a closed curve in the following way: pProject the curve to a plane with given normal.\n    Then, loose Offset the projection by distance + blend_radius and trim off self-intersection.\n    THen, Offset the remaining curve back in the opposite direction by blend_radius, filling gaps with blends.\n    Finally, use the elevations of the input curve to get the correct elevations of the result.\n\n    Args:\n        distance (double): The positive distance to offset the curve.\n        blendRadius (double): Positive, typically the same as distance. When the offset results in a self-intersection\n            that gets trimmed off at a kink, the kink will be blended out using this radius.\n        directionPoint (Point3d): A point that indicates the direction of the offset. If the offset is inward,\n            the point's projection to the plane should be well within the curve.\n            It will be used to decide which part of the offset to keep if there are self-intersections.\n        normal (Vector3d): A vector that indicates the normal of the plane in which the offset will occur.\n        tolerance (double): Used to determine self-intersections, not offset error.\n\n    Returns:\n        Curve: The offset curve if successful.\n    \"\"\"\n    url = \"rhino/geometry/curve/ribbonoffset-curve_double_double_point3d_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, distance, blendRadius, directionPoint, normal, tolerance]\n    if multiple: args = list(zip(thisCurve, distance, blendRadius, directionPoint, normal, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetOnSurface(thisCurve, face, distance, fittingTolerance, multiple=False):\n    \"\"\"\n    Offset this curve on a brep face surface. This curve must lie on the surface.\n\n    Args:\n        face (BrepFace): The brep face on which to offset.\n        distance (double): A distance to offset (+)left, (-)right.\n        fittingTolerance (double): A fitting tolerance.\n\n    Returns:\n        Curve[]: Offset curves on success, or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetonsurface-curve_brepface_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, face, distance, fittingTolerance]\n    if multiple: args = list(zip(thisCurve, face, distance, fittingTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetOnSurface1(thisCurve, face, throughPoint, fittingTolerance, multiple=False):\n    \"\"\"\n    Offset a curve on a brep face surface. This curve must lie on the surface.\n    This overload allows to specify a surface point at which the offset will pass.\n\n    Args:\n        face (BrepFace): The brep face on which to offset.\n        throughPoint (Point2d): 2d point on the brep face to offset through.\n        fittingTolerance (double): A fitting tolerance.\n\n    Returns:\n        Curve[]: Offset curves on success, or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetonsurface-curve_brepface_point2d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, face, throughPoint, fittingTolerance]\n    if multiple: args = list(zip(thisCurve, face, throughPoint, fittingTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetOnSurface2(thisCurve, face, curveParameters, offsetDistances, fittingTolerance, multiple=False):\n    \"\"\"\n    Offset a curve on a brep face surface. This curve must lie on the surface.\n    This overload allows to specify different offsets for different curve parameters.\n\n    Args:\n        face (BrepFace): The brep face on which to offset.\n        curveParameters (double[]): Curve parameters corresponding to the offset distances.\n        offsetDistances (double[]): distances to offset (+)left, (-)right.\n        fittingTolerance (double): A fitting tolerance.\n\n    Returns:\n        Curve[]: Offset curves on success, or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetonsurface-curve_brepface_doublearray_doublearray_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, face, curveParameters, offsetDistances, fittingTolerance]\n    if multiple: args = list(zip(thisCurve, face, curveParameters, offsetDistances, fittingTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetOnSurface3(thisCurve, surface, distance, fittingTolerance, multiple=False):\n    \"\"\"\n    Offset a curve on a surface. This curve must lie on the surface.\n\n    Args:\n        surface (Surface): A surface on which to offset.\n        distance (double): A distance to offset (+)left, (-)right.\n        fittingTolerance (double): A fitting tolerance.\n\n    Returns:\n        Curve[]: Offset curves on success, or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetonsurface-curve_surface_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, surface, distance, fittingTolerance]\n    if multiple: args = list(zip(thisCurve, surface, distance, fittingTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetOnSurface4(thisCurve, surface, throughPoint, fittingTolerance, multiple=False):\n    \"\"\"\n    Offset a curve on a surface. This curve must lie on the surface.\n    This overload allows to specify a surface point at which the offset will pass.\n\n    Args:\n        surface (Surface): A surface on which to offset.\n        throughPoint (Point2d): 2d point on the brep face to offset through.\n        fittingTolerance (double): A fitting tolerance.\n\n    Returns:\n        Curve[]: Offset curves on success, or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetonsurface-curve_surface_point2d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, surface, throughPoint, fittingTolerance]\n    if multiple: args = list(zip(thisCurve, surface, throughPoint, fittingTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetOnSurface5(thisCurve, surface, curveParameters, offsetDistances, fittingTolerance, multiple=False):\n    \"\"\"\n    Offset this curve on a surface. This curve must lie on the surface.\n    This overload allows to specify different offsets for different curve parameters.\n\n    Args:\n        surface (Surface): A surface on which to offset.\n        curveParameters (double[]): Curve parameters corresponding to the offset distances.\n        offsetDistances (double[]): Distances to offset (+)left, (-)right.\n        fittingTolerance (double): A fitting tolerance.\n\n    Returns:\n        Curve[]: Offset curves on success, or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetonsurface-curve_surface_doublearray_doublearray_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, surface, curveParameters, offsetDistances, fittingTolerance]\n    if multiple: args = list(zip(thisCurve, surface, curveParameters, offsetDistances, fittingTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef PullToBrepFace1(thisCurve, face, tolerance, multiple=False):\n    \"\"\"\n    Pulls this curve to a brep face and returns the result of that operation.\n\n    Args:\n        face (BrepFace): A brep face.\n        tolerance (double): A tolerance value.\n\n    Returns:\n        Curve[]: An array containing the resulting curves after pulling. This array could be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/pulltobrepface-curve_brepface_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, face, tolerance]\n    if multiple: args = list(zip(thisCurve, face, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetNormalToSurface(thisCurve, surface, height, multiple=False):\n    \"\"\"\n    Finds a curve by offsetting an existing curve normal to a surface.\n    The caller is responsible for ensuring that the curve lies on the input surface.\n\n    Args:\n        surface (Surface): Surface from which normals are calculated.\n        height (double): offset distance (distance from surface to result curve)\n\n    Returns:\n        Curve: Offset curve at distance height from the surface.  The offset curve is\n        interpolated through a small number of points so if the surface is irregular\n        or complicated, the result will not be a very accurate offset.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetnormaltosurface-curve_surface_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, surface, height]\n    if multiple: args = list(zip(thisCurve, surface, height))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "point", "brep", "line", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "mcneel_computeclient_py_a821886856.json", "repo": "mcneel/computeclient_py"}
{"instruction": "Evaluate a python script on the compute server. The script can reference an", "code": "import rhino3dm\nimport json\nimport requests\n\n__version__ = '0.14.0'\n\nurl = 'https://compute.rhino3d.com/'\nauthToken = ''\napiKey = ''\nstopat = 0\n\n\ndef ComputeFetch(endpoint, arglist):\n    class __Rhino3dmEncoder(json.JSONEncoder):\n        def default(self, o):\n            if hasattr(o, \"Encode\"):\n                return o.Encode()\n            return json.JSONEncoder.default(self, o)\n    global authToken\n    global apiKey\n    global url\n    global stopat\n    posturl = url + endpoint\n    if(stopat>0):\n        if(posturl.find('?')>0): posturl += '&stopat='\n        else: posturl += '?stopat='\n        posturl += str(stopat)\n    postdata = json.dumps(arglist, cls=__Rhino3dmEncoder)\n    headers = { 'User-Agent': 'compute.rhino3d.py/' + __version__ }\n    if authToken:\n        headers['Authorization'] = 'Bearer ' + authToken\n    if apiKey:\n        headers['RhinoComputeKey'] = apiKey\n    r = requests.post(posturl, data=postdata, headers=headers)\n    return r.json()\n\n\ndef PythonEvaluate(script, inputs, output_names):\n    \"\"\"\n    Evaluate a python script on the compute server. The script can reference an\n    `input` parameter which is passed as a dictionary. The script also has\n    access to an 'output' parameter which is returned from the server.\n\n    Args:\n        script (str): the python script to evaluate\n        inputs (dict): dictionary of data passed to the server for use by the\n                       script as an input variable\n        output_names (list): list of strings defining which variables in the\n                       script to return\n    Returns:\n        dict: The script has access to an output dict variable that it can\n              fill with values. This information is returned from the server\n              to the client.\n    \"\"\"\n    encodedInput = rhino3dm.ArchivableDictionary.EncodeDict(inputs)\n    url = 'rhino/python/evaluate'\n    args = [script, json.dumps(encodedInput), output_names]\n    response = ComputeFetch(url, args)\n    output = rhino3dm.ArchivableDictionary.DecodeDict(json.loads(response))\n    return output\n\n\ndef DecodeToCommonObject(item):\n    if item is None:\n        return None\n    if isinstance(item, list):\n        return [DecodeToCommonObject(x) for x in item]\n    return rhino3dm.CommonObject.Decode(item)\n\n\ndef DecodeToPoint3d(item):\n    if item is None:\n        return None\n    if isinstance(item, list):\n        return [DecodeToPoint3d(x) for x in item]\n    return rhino3dm.Point3d(item['X'], item['Y'], item['Z'])\n\n\ndef DecodeToVector3d(item):\n    if item is None:\n        return None\n    if isinstance(item, list):\n        return [DecodeToVector3d(x) for x in item]\n    return rhino3dm.Vector3d(item['X'], item['Y'], item['Z'])\n\n\ndef DecodeToLine(item):\n    if item is None:\n        return None\n    if isinstance(item, list):\n        return [DecodeToLine(x) for x in item]\n    start = DecodeToPoint3d(item['From'])\n    end = DecodeToPoint3d(item['To'])\n    return rhino3dm.Line(start,end)\n\n\ndef DecodeToBoundingBox(item):\n    if item is None:\n        return None\n    if isinstance(item, list):\n        return [DecodeToBoundingBox(x) for x in item]\n    return rhino3dm.BoundingBox(item['Min']['X'], item['Min']['Y'], item['Min']['Z'], item['Max']['X'], item['Max']['Y'], item['Max']['Z'])\n\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["line", "classes", "functions", "point"], "original_file": "mcneel_computeclient_py_df9bdad08a.json", "repo": "mcneel/computeclient_py"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "__all__ = ['InProcess','InteropWrappers','Notifications','RhinoAccounts']\nfrom typing import Tuple, Set, Iterable, List, overload\n\n\nclass AdvancedSetting:\n    UseNewDraftAngleAnalysisUi = 0\n    UseCompressionWhenSaving = 1\n    TestAdvancedString = 2\n    TestAdvancedInt = 3\n    PdfOptionalContentGroups = 4\n    LeaveFloatingPanelsHiddenOnMac = 5\n    DisableFileWatchers = 6\n    EnableCheckForUpdates = 7\n    LeftJustifyNumericText = 8\n    EnableWindowsGestures = 9\n    MakeInteriorNgonVertexesSelectable = 10\n    MacDisplayOldVersionAutosaveWarning = 11\n    UseNewMissingFontUI = 12\n    ExportDocumentUserText = 13\n\n\nclass Analytics:\n    @overload\n    def __init__(self, TrackingID: str, Name: str): ...\n    @overload\n    def __init__(self, TrackingID: str, Name: str, Platform: str, InstallerId: str, Version: str): ...\n    @property\n    def AppInstallerId(self) -> str: ...\n    @property\n    def AppName(self) -> str: ...\n    @property\n    def AppPlatform(self) -> str: ...\n    @property\n    def AppVersion(self) -> str: ...\n    @property\n    def GoogleAnalyticsTrackingID(self) -> str: ...\n    @property\n    def UsageStatisticsEnabled() -> bool: ...\n    @property\n    def UserId() -> Guid: ...\n    @overload\n    def Send(self, data: NameValueCollection) -> None: ...\n    @overload\n    def Send(self, Category: str) -> None: ...\n    @overload\n    def Send(self, Category: str, Action: str) -> None: ...\n    @overload\n    def Send(self, Category: str, Action: str, Label: str) -> None: ...\n    @overload\n    def Send(self, Category: str, Action: str, Label: str, Value: UInt32) -> None: ...\n    @AppInstallerId.setter\n    def AppInstallerId(self, value: str) -> None: ...\n    @AppName.setter\n    def AppName(self, value: str) -> None: ...\n    @AppPlatform.setter\n    def AppPlatform(self, value: str) -> None: ...\n    @AppVersion.setter\n    def AppVersion(self, value: str) -> None: ...\n    @GoogleAnalyticsTrackingID.setter\n    def GoogleAnalyticsTrackingID(self, value: str) -> None: ...\n\n\nclass AssemblyResolver:\n    def AddSearchFile(file: str) -> None: ...\n    def AddSearchFolder(folder: str) -> None: ...\n\n\nclass CommonObject:\n    def Dispose(self) -> None: ...\n    def EnsurePrivateCopy(self) -> None: ...\n    def FromBase64String(archive3dm: int, opennurbs: int, base64Data: str) -> CommonObject: ...\n    @overload\n    def FromJSON(jsonDictionary: Dictionary) -> CommonObject: ...\n    @overload\n    def FromJSON(json: str) -> CommonObject: ...\n    @property\n    def Disposed(self) -> bool: ...\n    @property\n    def HasUserData(self) -> bool: ...\n    @property\n    def IsDocumentControlled(self) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def PerformCorruptionTesting() -> bool: ...\n    @property\n    def UserData(self) -> UserDataList: ...\n    @property\n    def UserDictionary(self) -> ArchivableDictionary: ...\n    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...\n    def IsValidWithLog(self) -> Tuple[bool, str]: ...\n    @PerformCorruptionTesting.setter\n    def PerformCorruptionTesting(value: bool) -> None: ...\n    def ToJSON(self, options: SerializationOptions) -> str: ...\n\n\nclass CorruptGeometryException:\n    @property\n    def CommonObject(self) -> CommonObject: ...\n    @property\n    def Pointer(self) -> IntPtr: ...\n\n\nclass DocumentCollectedException:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, message: str): ...\n\n\nclass ExceptionReportDelegate:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, source: str, ex: Exception, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, source: str, ex: Exception) -> None: ...\n\n\nclass FillProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, topl: int, bottoml: int, topr: int, bottomr: int, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, topl: int, bottoml: int, topr: int, bottomr: int) -> None: ...\n\n\nclass HostUtils:\n    def add_OnExceptionReport(value: ExceptionReportDelegate) -> None: ...\n    def add_OnSendLogMessageToCloud(value: SendLogMessageToCloudDelegate) -> None: ...\n    def AutoInstallPlugInFolder(currentUser: bool) -> str: ...\n    def CallFromCoreRhino(task: str) -> int: ...\n    def CheckForRdk(throwOnFalse: bool, usePreviousResult: bool) -> bool: ...\n    def ClearFpuExceptionStatus() -> None: ...\n    @overload\n    def CreateCommands(plugin: PlugIn) -> None: ...\n    @overload\n    def CreateCommands(pPlugIn: IntPtr, pluginAssembly: Assembly) -> int: ...\n    def CreatePlugIn(pluginType: Type, printDebugMessages: bool) -> PlugIn: ...\n    @overload\n    def DebugDumpToString(geometry: GeometryBase) -> str: ...\n    @overload\n    def DebugDumpToString(bezierCurve: BezierCurve) -> str: ...\n    @overload\n    def DebugString(msg: str) -> None: ...\n    @overload\n    def DebugString(format: str, args: Set(Object)) -> None: ...\n    def DisplayOleAlerts(display: bool) -> None: ...\n    @overload\n    def ExceptionReport(ex: Exception) -> None: ...\n    @overload\n    def ExceptionReport(source: str, ex: Exception) -> None: ...\n    def ExecuteNamedCallback(name: str, args: NamedParametersEventArgs) -> bool: ...\n    def FileNameEndsWithRhinoBackupExtension(fileName: str) -> bool: ...\n    def FileNameEndsWithRhinoExtension(fileName: str) -> bool: ...\n    @property\n    def ComputerSerialNumber() -> str: ...\n    @property\n    def CurrentOSLanguage() -> UInt32: ...\n    @property\n    def DeviceId() -> Guid: ...\n    @property\n    def DeviceName() -> str: ...\n    @property\n    def OperatingSystemBuildNumber() -> str: ...\n    @property\n    def OperatingSystemEdition() -> str: ...\n    @property\n    def OperatingSystemInstallationType() -> str: ...\n    @property\n    def OperatingSystemProductName() -> str: ...\n    @property\n    def OperatingSystemVersion() -> str: ...\n    @property\n    def RunningAsRhinoInside() -> bool: ...\n    @property\n    def RunningInDarkMode() -> bool: ...\n    @property\n    def RunningInMono() -> bool: ...\n    @property\n    def RunningInRhino() -> bool: ...\n    @property\n    def RunningInWindowsContainer() -> bool: ...\n    @property\n    def RunningOnOSX() -> bool: ...\n    @property\n    def RunningOnWindows() -> bool: ...\n    @property\n    def SendDebugToCommandLine() -> bool: ...\n    def GetAbsolutePath(relativePath: str, bRelativePathisFileName: bool, relativeTo: str, bRelativeToIsFileName: bool) -> Tuple[bool, str]: ...\n    def GetActivePlugInVersionFolders(currentUser: bool) -> Iterable[DirectoryInfo]: ...\n    def GetAssemblySearchPaths() -> Set(str): ...\n    def GetCurrentProcessInfo() -> Tuple[str, Version]: ...\n    def GetCustomComputeEndpoints() -> Set(Tuple): ...\n    def GetPlatformService(assemblyPath: str, typeFullName: str) -> T: ...\n    def GetRhinoDotNetAssembly() -> Assembly: ...\n    def GetSystemProcessorCount() -> int: ...\n    def InitializeRhinoCommon() -> None: ...\n    def InitializeRhinoCommon_RDK() -> None: ...\n    def InitializeZooClient() -> None: ...\n    def InPlaceConstCast(geometry: GeometryBase, makeNonConst: bool) -> None: ...\n    def IsManagedDll(path: str) -> bool: ...\n    def IsRhinoBackupFileExtension(fileExtension: str) -> bool: ...\n    def IsRhinoFileExtension(fileExtension: str) -> bool: ...\n    def RecordInitInstanceTime(description: str) -> None: ...\n    def RegisterComputeEndpoint(endpointPath: str, t: Type) -> None: ...\n    def RegisterDynamicCommand(plugin: PlugIn, cmd: Command) -> bool: ...\n    def RegisterNamedCallback(name: str, callback: EventHandler) -> None: ...\n    def remove_OnExceptionReport(value: ExceptionReportDelegate) -> None: ...\n    def remove_OnSendLogMessageToCloud(value: SendLogMessageToCloudDelegate) -> None: ...\n    def RhinoCommonExceptionHandler(title: str, sender: Object, ex: Exception) -> None: ...\n    def SendLogMessageToCloudCallbackProc(msg_type: LogMessageType, pwStringClass: IntPtr, pwStringDesc: IntPtr, pwStringMessage: IntPtr) -> None: ...\n    @SendDebugToCommandLine.setter\n    def SendDebugToCommandLine(value: bool) -> None: ...\n    def SetInShutDown() -> None: ...\n    def ShutDownRhinoCommon_RDK() -> None: ...\n    def UnhandledThreadException(sender: Object, e: ThreadExceptionEventArgs) -> None: ...\n\n\nclass ImportOptionsSections:\n    AdvancedDisplay = 0\n    Alias = 1\n    Appearance = 2\n    ChooseOneObject = 3\n    ControlPointContextMenu = 4\n    CursorToolTip = 5\n    Display = 6\n    File = 7\n    General = 8\n    Grid = 9\n    ModelAid = 10\n    Mouse = 11\n    NeverRepeatCommands = 12\n    ObjectContextMenu = 13\n    SearchPath = 14\n    ShortcutKey = 15\n    Smarttrack = 16\n    View = 17\n    ViewportContextMenu = 18\n    ToolPaletteSettings = 19\n    Count = 20\n\n\nclass InstanceAttributeField:\n    def __init__(self, key: str, prompt: str, defaultValue: str): ...\n    @property\n    def DefaultValue(self) -> str: ...\n    @property\n    def Key(self) -> str: ...\n    @property\n    def Prompt(self) -> str: ...\n\n\nclass Interop:\n    def CreateFromNativePointer(pGeometry: IntPtr) -> GeometryBase: ...\n    def FileReadOptionsConstPointer(options: FileReadOptions) -> IntPtr: ...\n    def FileWriteOptionsConstPointer(options: FileWriteOptions) -> IntPtr: ...\n    def FontFromPointer(ptrManagedFont: IntPtr) -> Font: ...\n    def FromOnBrep(source: Object) -> Brep: ...\n    def FromOnCurve(source: Object) -> Curve: ...\n    def FromOnMesh(source: Object) -> Mesh: ...\n    def FromOnSurface(source: Object) -> Surface: ...\n    def NativeGeometryConstPointer(geometry: GeometryBase) -> IntPtr: ...\n    def NativeGeometryNonConstPointer(geometry: GeometryBase) -> IntPtr: ...\n    @overload\n    def NativeNonConstPointer(settings: ViewCaptureSettings) -> IntPtr: ...\n    @overload\n    def NativeNonConstPointer(pipeline: DisplayPipeline) -> IntPtr: ...\n    @overload\n    def NativeNonConstPointer(getPoint: GetPoint) -> IntPtr: ...\n    @overload\n    def NativeNonConstPointer(viewport: RhinoViewport) -> IntPtr: ...\n    @overload\n    def NativeNonConstPointer(viewport: ViewportInfo) -> IntPtr: ...\n    def NativeRhinoDocPointer(doc: RhinoDoc) -> IntPtr: ...\n    @overload\n    def NSFontFromFont(font: Font) -> IntPtr: ...\n    @overload\n    def NSFontFromFont(font: Font, pointSize: float) -> IntPtr: ...\n    def PlugInPointer(plugin: PlugIn) -> IntPtr: ...\n    def RhinoObjectConstPointer(rhinoObject: RhinoObject) -> IntPtr: ...\n    def RhinoObjectFromPointer(pRhinoObject: IntPtr) -> RhinoObject: ...\n    def ToIRhinoViewport(source: RhinoViewport) -> Object: ...\n    def ToOnBrep(source: Brep) -> Object: ...\n    def ToOnCurve(source: Curve) -> Object: ...\n    def ToOnMesh(source: Mesh) -> Object: ...\n    def ToOnSurface(source: Surface) -> Object: ...\n    def ToOnXform(source: Transform) -> Object: ...\n    def TryCopyFromOnArc(source: Object) -> Tuple[bool, Arc]: ...\n    def TryCopyToOnArc(source: Arc, destination: Object) -> bool: ...\n    def ViewCaptureFromPointer(ptrViewCapture: IntPtr) -> ViewCaptureSettings: ...\n\n\nclass IPlatformServiceLocator:\n    def GetService(self) -> T: ...\n\n\nclass IZooClientUtilities:\n    def AskUserForLicense(self, verify: Object, parameters: ZooClientParameters) -> bool: ...\n    def CheckInLicense(self, verify: Object, productId: Guid) -> bool: ...\n    def CheckOutLicense(self, verify: Object, productId: Guid) -> bool: ...\n    def ConvertLicense(self, verify: Object, productId: Guid) -> bool: ...\n    def DeleteLicense(self, verify: Object, productId: Guid) -> bool: ...\n    def Echo(self, verify: Object, message: str) -> str: ...\n    @property\n    def LoggedInUserAvatar(self) -> Image: ...\n    @property\n    def LoggedInUserName(self) -> str: ...\n    @property\n    def UserIsLoggedIn(self) -> bool: ...\n    def GetCurrentTime(self) -> DateTime: ...\n    def GetLicense(self, verify: Object, parameters: ZooClientParameters) -> bool: ...\n    def GetLicenseStatus(self, verify: Object) -> Set(LicenseStatus): ...\n    def GetLicenseType(self, verify: Object, productId: Guid) -> int: ...\n    def GetOneLicenseStatus(self, verify: Object, productId: Guid) -> LicenseStatus: ...\n    def GetRegisteredOwnerInfo(self, verify: Object, productId: Guid, registeredOwner: str, registeredOrganization: str) -> Tuple[bool, str, str]: ...\n    def Initialize(self, verify: Object) -> bool: ...\n    def IsCheckOutEnabled(self, verify: Object) -> bool: ...\n    def LicenseOptionsHandler(self, verify: Object, parameters: ZooClientParameters) -> bool: ...\n    def LoginToCloudZoo(self) -> bool: ...\n    def LogoutOfCloudZoo(self) -> bool: ...\n    @overload\n    def ReturnLicense(self, verify: Object, productId: Guid) -> bool: ...\n    @overload\n    def ReturnLicense(self, verify: Object, productPath: str, productId: Guid) -> bool: ...\n    def ShowBuyLicenseUi(self, verify: Object, productId: Guid) -> None: ...\n    def ShowLicenseValidationUi(self, verify: Object, cdkey: str) -> bool: ...\n    def ShowRhinoExpiredMessage(self, mode: Mode, result: int) -> Tuple[bool, int]: ...\n\n\nclass LicenseStateChangedEventArgs:\n    def __init__(self, callingRhinoCommonAllowed: bool): ...\n    @property\n    def CallingRhinoCommonAllowed(self) -> bool: ...\n\n\nclass LicenseTypes:\n    Undefined = 0\n    Standalone = 1\n    ZooAutoDetect = 2\n    ZooManualDetect = 3\n    CloudZoo = 4\n\n\nclass LogMessageType:\n    unknown = 0\n    information = 1\n    warning = 2\n    error = 3\n    assert = 4\n\n\nclass Mode:\n    NormalMode = 0\n    ViewerMode = 1\n    BetaMode = 2\n    InvalidMode = 100\n\n\nclass NamedParametersEventArgs:\n    def __init__(self): ...\n    def Dispose(self) -> None: ...\n    @overload\n    def Set(self, name: str, values: Iterable[GeometryBase]) -> None: ...\n    @overload\n    def Set(self, name: str, value: GeometryBase) -> None: ...\n    @overload\n    def Set(self, name: str, value: Color) -> None: ...\n    @overload\n    def Set(self, name: str, value: Vector3d) -> None: ...\n    @overload\n    def Set(self, name: str, value: float) -> None: ...\n    @overload\n    def Set(self, name: str, value: UInt32) -> None: ...\n    @overload\n    def Set(self, name: str, value: Point3d) -> None: ...\n    @overload\n    def Set(self, name: str, strings: Iterable[str]) -> None: ...\n    @overload\n    def Set(self, name: str, value: int) -> None: ...\n    @overload\n    def Set(self, name: str, value: str) -> None: ...\n    @overload\n    def Set(self, name: str, value: bool) -> None: ...\n    def SetWindowHandle(self, name: str, value: IntPtr) -> None: ...\n    def TryGetBool(self, name: str) -> Tuple[bool, bool]: ...\n    def TryGetColor(self, name: str) -> Tuple[bool, Color]: ...\n    def TryGetDouble(self, name: str) -> Tuple[bool, float]: ...\n    def TryGetGeometry(self, name: str) -> Tuple[bool, Set(GeometryBase)]: ...\n    def TryGetInt(self, name: str) -> Tuple[bool, int]: ...\n    def TryGetPoint(self, name: str) -> Tuple[bool, Point3d]: ...\n    def TryGetRhinoObjects(self, key: str) -> Tuple[bool, Set(RhinoObject)]: ...\n    def TryGetString(self, name: str) -> Tuple[bool, str]: ...\n    def TryGetStrings(self, name: str) -> Tuple[bool, Set(str)]: ...\n    def TryGetUnsignedInt(self, name: str) -> Tuple[bool, UInt32]: ...\n    def TryGetVector(self, name: str) -> Tuple[bool, Vector3d]: ...\n    def TryGetViewport(self, name: str) -> Tuple[bool, ViewportInfo]: ...\n    def TryGetWindowHandle(self, name: str) -> Tuple[bool, IntPtr]: ...\n\n\nclass NotLicensedException:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, message: str): ...\n    @overload\n    def __init__(self, message: str, inner: Exception): ...\n\n\nclass PathPoint:\n    @property\n    def Location(self) -> PointF: ...\n    @property\n    def PointType(self) -> PointType: ...\n    @Location.setter\n    def Location(self, value: PointF) -> None: ...\n    @PointType.setter\n    def PointType(self, value: PointType) -> None: ...\n\n\nclass Pen:\n    def __init__(self): ...\n    @property\n    def Color(self) -> Color: ...\n    @property\n    def Width(self) -> Single: ...\n\n\nclass PointType:\n    Move = 0\n    Line = 1\n    CubicBezier = 2\n    Close = 3\n\n\nclass PythonCompiledCode:\n    def Execute(self, scope: PythonScript) -> None: ...\n\n\nclass PythonScript:\n    def AddRuntimeAssembly(assembly: Assembly) -> None: ...\n    def Compile(self, script: str) -> PythonCompiledCode: ...\n    def ContainsVariable(self, name: str) -> bool: ...\n    def Create() -> PythonScript: ...\n    def CreateTextEditorControl(self, script: str, helpcallback: Action) -> Object: ...\n    def EvaluateExpression(self, statements: str, expression: str) -> Object: ...\n    def ExecuteFile(self, path: str) -> bool: ...\n    def ExecuteFileInScope(self, path: str) -> bool: ...\n    def ExecuteScript(self, script: str) -> bool: ...\n    @property\n    def ContextId(self) -> int: ...\n    @property\n    def Output(self) -> Action: ...\n    @property\n    def ScriptContextCommand(self) -> Command: ...\n    @property\n    def ScriptContextDoc(self) -> Object: ...\n    @property\n    def SearchPaths() -> Set(str): ...\n    def GetStackTraceFromException(self, ex: Exception) -> str: ...\n    def GetVariable(self, name: str) -> Object: ...\n    def GetVariableNames(self) -> Iterable[str]: ...\n    def RemoveVariable(self, name: str) -> None: ...\n    def RuntimeAssemblies() -> Set(Assembly): ...\n    @ContextId.setter\n    def ContextId(self, value: int) -> None: ...\n    @Output.setter\n    def Output(self, value: Action) -> None: ...\n    @ScriptContextCommand.setter\n    def ScriptContextCommand(self, value: Command) -> None: ...\n    @ScriptContextDoc.setter\n    def ScriptContextDoc(self, value: Object) -> None: ...\n    @SearchPaths.setter\n    def SearchPaths(value: Set(str)) -> None: ...\n    def SetIntellisenseVariable(self, name: str, value: Object) -> None: ...\n    def SetupScriptContext(self, doc: Object) -> None: ...\n    def SetVariable(self, name: str, value: Object) -> None: ...\n\n\nclass RdkNotLoadedException:\n    def __init__(self): ...\n\n\nclass RiskyAction:\n    def __init__(self, description: str, file: str, member: str, line: int): ...\n    def Dispose(self) -> None: ...\n\n\nclass SendLogMessageToCloudDelegate:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, msg_type: LogMessageType, sClass: str, sDesc: str, sMessage: str, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, msg_type: LogMessageType, sClass: str, sDesc: str, sMessage: str) -> None: ...\n\n\nclass SetClipRectProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, left: int, top: int, right: int, bottom: int, callback: AsyncCallback, object: Object) -> Tuple[IAsyncResult, int, int, int, int]: ...\n    def EndInvoke(self, left: int, top: int, right: int, bottom: int, result: IAsyncResult) -> Tuple[int, int, int, int]: ...\n    def Invoke(self, left: int, top: int, right: int, bottom: int) -> Tuple[int, int, int, int]: ...\n\n\nclass Skin:\n    @property\n    def ActiveSkin() -> Skin: ...\n    @property\n    def Settings(self) -> PersistentSettings: ...\n\n\nclass TextFields:\n    @overload\n    def Area(id: str) -> float: ...\n    @overload\n    def Area(id: str, unitSystem: str) -> float: ...\n    def BlockAttributeText(key: str, prompt: str, defaultValue: str) -> str: ...\n    def BlockInstanceCount(instanceDefinitionNameOrId: str) -> int: ...\n    def BlockInstanceName(blockId: str) -> str: ...\n    @overload\n    def CurveLength(id: str) -> float: ...\n    @overload\n    def CurveLength(id: str, unitSystem: str) -> float: ...\n    @overload\n    def Date() -> str: ...\n    @overload\n    def Date(dateFormat: str) -> str: ...\n    @overload\n    def Date(dateFormat: str, languageId: str) -> str: ...\n    @overload\n    def DateModified() -> str: ...\n    @overload\n    def DateModified(dateFormat: str) -> str: ...\n    @overload\n    def DateModified(dateFormat: str, languageId: str) -> str: ...\n    def DetailScale(detailId: str, scaleFormat: str) -> str: ...\n    def DocumentText(key: str) -> str: ...\n    @overload\n    def FileName() -> str: ...\n    @overload\n    def FileName(options: str) -> str: ...\n    @overload\n    def GetInstanceAttributeFields(idef: InstanceDefinition) -> Set(InstanceAttributeField): ...\n    @overload\n    def GetInstanceAttributeFields(text: TextObject) -> Set(InstanceAttributeField): ...\n    @overload\n    def GetInstanceAttributeFields(str: str) -> Set(InstanceAttributeField): ...\n    def LayerName(layerId: str) -> str: ...\n    @overload\n    def LayoutUserText(key: str) -> str: ...\n    @overload\n    def LayoutUserText(layoutId: str, key: str) -> str: ...\n    def ModelUnits() -> str: ...\n    def Notes() -> str: ...\n    def NumPages() -> int: ...\n    def ObjectLayer(id: str) -> str: ...\n    @overload\n    def ObjectName() -> str: ...\n    @overload\n    def ObjectName(id: str) -> str: ...\n    def PageHeight() -> float: ...\n    @overload\n    def PageName() -> str: ...\n    @overload\n    def PageName(id: str) -> str: ...\n    def PageNumber() -> int: ...\n    def PageWidth() -> float: ...\n    def PaperName() -> str: ...\n    def PointCoordinate(pointId: str, axis: str) -> str: ...\n    @overload\n    def UserText(id: str, key: str) -> str: ...\n    @overload\n    def UserText(id: str, key: str, prompt: str) -> str: ...\n    @overload\n    def UserText(id: str, key: str, prompt: str, defaultValue: str) -> str: ...\n    @overload\n    def Volume(id: str) -> float: ...\n    @overload\n    def Volume(id: str, unitSystem: str) -> float: ...\n\n\nclass VectorArcProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, argb: int, thickness: Single, dashed: int, arc: Arc, callback: AsyncCallback, object: Object) -> Tuple[IAsyncResult, Arc]: ...\n    def EndInvoke(self, arc: Arc, result: IAsyncResult) -> Tuple[Arc]: ...\n    def Invoke(self, argb: int, thickness: Single, dashed: int, arc: Arc) -> Tuple[Arc]: ...\n\n\nclass VectorBitmapProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, hBmp: IntPtr, m11: float, m12: float, m21: float, m22: float, dx: float, dy: float, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, hBmp: IntPtr, m11: float, m12: float, m21: float, m22: float, dx: float, dy: float) -> None: ...\n\n\nclass VectorClipPathProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, count: int, points: IntPtr, asBeziers: int, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, count: int, points: IntPtr, asBeziers: int) -> None: ...\n\n\nclass VectorFillPolygonProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, argb: int, count: int, points: IntPtr, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, argb: int, count: int, points: IntPtr) -> None: ...\n\n\nclass VectorGradientProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, pEngine: IntPtr, pHatch: IntPtr, strokeWidth: Single, pHatchPattern: IntPtr, gradientCount: int, colors: IntPtr, stops: IntPtr, points: IntPtr, linearGradient: int, boundaryColor: int, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, pEngine: IntPtr, pHatch: IntPtr, strokeWidth: Single, pHatchPattern: IntPtr, gradientCount: int, colors: IntPtr, stops: IntPtr, points: IntPtr, linearGradient: int, boundaryColor: int) -> None: ...\n\n\nclass VectorPathProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, begin: int, argb: int, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, begin: int, argb: int) -> None: ...\n\n\nclass VectorPointProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, style: int, screenX: Single, screenY: Single, fillArgb: int, strokeArgb: int, diameterPixels: Single, innerDiameterPixels: Single, strokeWidthPixels: Single, rotationRadians: Single, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, style: int, screenX: Single, screenY: Single, fillArgb: int, strokeArgb: int, diameterPixels: Single, innerDiameterPixels: Single, strokeWidthPixels: Single, rotationRadians: Single) -> None: ...\n\n\nclass VectorPolylineProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, argb: int, thickness: Single, dashed: int, count: int, points: IntPtr, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, argb: int, thickness: Single, dashed: int, count: int, points: IntPtr) -> None: ...\n\n\nclass VectorRoundedRectProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, centerX: Single, centerY: Single, pixelWidth: Single, pixelHeight: Single, cornerRadius: Single, strokeColor: int, strokeWidth: Single, fillColor: int, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, centerX: Single, centerY: Single, pixelWidth: Single, pixelHeight: Single, cornerRadius: Single, strokeColor: int, strokeWidth: Single, fillColor: int) -> None: ...\n\n\nclass VectorStringProc:\n    def __init__(self, object: Object, method: IntPtr): ...\n    def BeginInvoke(self, constPtrString: IntPtr, argbTextColor: int, x: float, y: float, angle: Single, alignment: int, heightPixels: Single, constPtrFont: IntPtr, callback: AsyncCallback, object: Object) -> IAsyncResult: ...\n    def EndInvoke(self, result: IAsyncResult) -> None: ...\n    def Invoke(self, constPtrString: IntPtr, argbTextColor: int, x: float, y: float, angle: Single, alignment: int, heightPixels: Single, constPtrFont: IntPtr) -> None: ...\n\n\nclass ViewCaptureWriter:\n    def __init__(self, dpi: float, pageSize: Size): ...\n    def Draw(self, constPtrPrintInfo: IntPtr, doc: RhinoDoc) -> None: ...\n\n\nclass ZooClientParameters:\n    def __init__(self, productGuid: Guid, licenseGuid: Guid, productTitle: str, productBuildType: int, capabilities: LicenseCapabilities, licenseEntryTextMask: str, productPath: str, parentWindow: Object, selectedLicenseType: LicenseTypes, validateProductKey: ValidateProductKeyDelegate, onLeaseChangedDelegate: OnLeaseChangedDelegate, verifyLicenseKeyDelegate: VerifyLicenseKeyDelegate, verifyPreviousVersionLicenseKeyDelegate: VerifyPreviousVersionLicenseDelegate): ...\n    @property\n    def Capabilities(self) -> LicenseCapabilities: ...\n    @property\n    def LicenseEntryTextMask(self) -> str: ...\n    @property\n    def LicenseGuid(self) -> Guid: ...\n    @property\n    def OnLeaseChanged(self) -> OnLeaseChangedDelegate: ...\n    @property\n    def ParentWindow(self) -> Object: ...\n    @property\n    def ProductBuildType(self) -> int: ...\n    @property\n    def ProductGuid(self) -> Guid: ...\n    @property\n    def ProductPath(self) -> str: ...\n    @property\n    def ProductTitle(self) -> str: ...\n    @property\n    def SelectedLicenseType(self) -> LicenseTypes: ...\n    @Capabilities.setter\n    def Capabilities(self, value: LicenseCapabilities) -> None: ...\n    @SelectedLicenseType.setter\n    def SelectedLicenseType(self, value: LicenseTypes) -> None: ...\n    def VerifyLicenseKey(self, licenseKey: str, validationCode: str, validationCodeInstallDate: DateTime, gracePeriodExpired: bool) -> Tuple[ValidateResult, LicenseData]: ...\n    def VerifyPreviousVersionLicense(self, license: str, previousVersionLicense: str) -> Tuple[bool, str]: ...\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "classes", "point", "layer", "brep", "line", "curve", "functions", "block", "mesh", "RhinoCommon"], "original_file": "mcneel_pythonstubs_6cc3b94461.json", "repo": "mcneel/pythonstubs"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "__all__ = ['Alignment','Base','Canvas','Colours','Equations','Gradient','HTML','IconEditor','Layout','MRU','RemotePanel','Ribbon','Script','SettingsControls','Stacks','StringDisplay','Theme','Widgets']\nfrom typing import Tuple, Set, Iterable, List, overload\n\n\nclass AggregateShortcutMenuItemsEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_MenuShortcutEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_MenuShortcutEventArgs) -> None: ...\n\n\nclass AttributesAcceptedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_MarkupAttributesDialog, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_MarkupAttributesDialog) -> None: ...\n\n\nclass AttributesChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_MarkupAttributesDialog, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_MarkupAttributesDialog) -> None: ...\n\n\nclass AttributesDeniedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_MarkupAttributesDialog, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_MarkupAttributesDialog) -> None: ...\n\n\nclass ColourChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: EventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: EventArgs) -> None: ...\n\n\nclass ColourChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_ColourPickerEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_ColourPickerEventArgs) -> None: ...\n\n\nclass ColourChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_ColourSwatchEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_ColourSwatchEventArgs) -> None: ...\n\n\nclass ColoursChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_PreviewSettingsChangedEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_PreviewSettingsChangedEventArgs) -> None: ...\n\n\nclass DataChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: EventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: EventArgs) -> None: ...\n\n\nclass DocumentSavedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: EventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: EventArgs) -> None: ...\n\n\nclass EditorFoldStateChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_DocumentEditor, e: EventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_DocumentEditor, e: EventArgs) -> None: ...\n\n\nclass FileChangedDelegate:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_AsynchFileData, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_AsynchFileData) -> None: ...\n\n\nclass FileDeleteClickedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self) -> None: ...\n\n\nclass FileLoadClickedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self) -> None: ...\n\n\nclass GH_AlignWidgetSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_AnimatedProcessPanel(GH_DoubleBufferedPanel):\n    def __init__(self): ...\n    def BezierPaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def BugColonyPaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def CharacterTumblePaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def CirclePaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def CodeBreakerPaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def DeformPaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def DelaunayPaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def EulerTrianglePaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def FeynmanDiagramPaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def GaussianPaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    @property\n    def OverlayDelegate(self) -> GH_PaintDelegate: ...\n    @property\n    def PaintDelegate(self) -> GH_PaintDelegate: ...\n    @property\n    def ParticleCount(self) -> int: ...\n    @property\n    def ParticleDirections(self) -> List: ...\n    @property\n    def Particles(self) -> List: ...\n    @property\n    def ParticleSpeed(self) -> float: ...\n    def HilbertCurvePaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def kdTreePaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def LightConePaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def MetaballPaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def OildropPaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def OrreryPaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def ParticleDusterPaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def PoincareDiscPaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def PrismPaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def ProximityPaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    @OverlayDelegate.setter\n    def OverlayDelegate(self, Value: GH_PaintDelegate) -> None: ...\n    @PaintDelegate.setter\n    def PaintDelegate(self, Value: GH_PaintDelegate) -> None: ...\n    @ParticleCount.setter\n    def ParticleCount(self, Value: int) -> None: ...\n    @ParticleSpeed.setter\n    def ParticleSpeed(self, Value: float) -> None: ...\n    def SyrpinskiPaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def VennDiagramPaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n    def VoronoiPaintDelegate(control: Control, e: PaintEventArgs) -> None: ...\n\n\nclass GH_AnimationPhase:\n    Before = 0\n    During = 1\n    After = 2\n\n\nclass GH_Animator:\n    @overload\n    def DecimalAnimator(A: Decimal, B: Decimal) -> GH_Animator: ...\n    @overload\n    def DecimalAnimator(A: Decimal, B: Decimal, duration: int) -> GH_Animator: ...\n    @overload\n    def DecimalAnimator(A: Decimal, B: Decimal, time0: DateTime, time1: DateTime) -> GH_Animator: ...\n    @overload\n    def DoubleAnimator(A: float, B: float) -> GH_Animator: ...\n    @overload\n    def DoubleAnimator(A: float, B: float, duration: int) -> GH_Animator: ...\n    @overload\n    def DoubleAnimator(A: float, B: float, time0: DateTime, time1: DateTime) -> GH_Animator: ...\n    @overload\n    def IntegerAnimator(A: int, B: int) -> GH_Animator: ...\n    @overload\n    def IntegerAnimator(A: int, B: int, duration: int) -> GH_Animator: ...\n    @overload\n    def IntegerAnimator(A: int, B: int, time0: DateTime, time1: DateTime) -> GH_Animator: ...\n    def InterpolateDecimal(A: Decimal, B: Decimal, factor: float) -> Decimal: ...\n    def InterpolateDouble(A: float, B: float, factor: float) -> float: ...\n    def InterpolateInteger(A: int, B: int, factor: float) -> int: ...\n    def InterpolatePoint(A: Point, B: Point, factor: float) -> Point: ...\n    def InterpolatePointF(A: PointF, B: PointF, factor: float) -> PointF: ...\n    def InterpolateRectangle(A: Rectangle, B: Rectangle, factor: float) -> Rectangle: ...\n    def InterpolateRectangleF(A: RectangleF, B: RectangleF, factor: float) -> RectangleF: ...\n    def InterpolateSingle(A: Single, B: Single, factor: float) -> Single: ...\n    @overload\n    def PointAnimator(A: Point, B: Point) -> GH_Animator: ...\n    @overload\n    def PointAnimator(A: Point, B: Point, duration: int) -> GH_Animator: ...\n    @overload\n    def PointAnimator(A: Point, B: Point, time0: DateTime, time1: DateTime) -> GH_Animator: ...\n    @overload\n    def PointFAnimator(A: PointF, B: PointF) -> GH_Animator: ...\n    @overload\n    def PointFAnimator(A: PointF, B: PointF, duration: int) -> GH_Animator: ...\n    @overload\n    def PointFAnimator(A: PointF, B: PointF, time0: DateTime, time1: DateTime) -> GH_Animator: ...\n    @overload\n    def RectangleAnimator(A: Rectangle, B: Rectangle) -> GH_Animator: ...\n    @overload\n    def RectangleAnimator(A: Rectangle, B: Rectangle, duration: int) -> GH_Animator: ...\n    @overload\n    def RectangleAnimator(A: Rectangle, B: Rectangle, time0: DateTime, time1: DateTime) -> GH_Animator: ...\n    @overload\n    def RectangleFAnimator(A: RectangleF, B: RectangleF) -> GH_Animator: ...\n    @overload\n    def RectangleFAnimator(A: RectangleF, B: RectangleF, duration: int) -> GH_Animator: ...\n    @overload\n    def RectangleFAnimator(A: RectangleF, B: RectangleF, time0: DateTime, time1: DateTime) -> GH_Animator: ...\n    @overload\n    def SingleAnimator(A: Single, B: Single) -> GH_Animator: ...\n    @overload\n    def SingleAnimator(A: Single, B: Single, duration: int) -> GH_Animator: ...\n    @overload\n    def SingleAnimator(A: Single, B: Single, time0: DateTime, time1: DateTime) -> GH_Animator: ...\n\n\n\n\nclass GH_ArrowControl:\n    def __init__(self): ...\n\n\nclass GH_AssemblyInfoDialog:\n    def __init__(self): ...\n    @property\n    def Assembly(self) -> GH_AssemblyInfo: ...\n    def RegisterProxies(self, proxies: Iterable[IGH_ObjectProxy]) -> None: ...\n    @Assembly.setter\n    def Assembly(self, AutoPropertyValue: GH_AssemblyInfo) -> None: ...\n\n\nclass GH_ASSERT_DIALOG:\n    def __init__(self): ...\n    def AddFrame(self, method: str, type: str, file: str, line: str) -> None: ...\n    @property\n    def GUID(self) -> Guid: ...\n    @property\n    def Message(self) -> str: ...\n    @GUID.setter\n    def GUID(self, Value: Guid) -> None: ...\n    @Message.setter\n    def Message(self, Value: str) -> None: ...\n\n\nclass GH_AsynchFileData:\n    def __init__(self, filePath: str, harvestThumbnail: bool, callback: FileChangedDelegate): ...\n    def Dispose(self) -> None: ...\n    @property\n    def Callback(self) -> FileChangedDelegate: ...\n    @property\n    def FileCreated(self) -> DateTime: ...\n    @property\n    def FileExists(self) -> bool: ...\n    @property\n    def FileLastChanged(self) -> DateTime: ...\n    @property\n    def FileSize(self) -> Int64: ...\n    @property\n    def FileThumbnail(self) -> Bitmap: ...\n    @property\n    def HarvestThumbnail(self) -> bool: ...\n    @property\n    def IsFileData(self) -> bool: ...\n    @Callback.setter\n    def Callback(self, AutoPropertyValue: FileChangedDelegate) -> None: ...\n    @HarvestThumbnail.setter\n    def HarvestThumbnail(self, AutoPropertyValue: bool) -> None: ...\n    def UpdateProperties(self) -> None: ...\n\n\nclass GH_AuthorSettingsCategory(GH_SettingsCategory):\n    def __init__(self): ...\n    @property\n    def Description(self) -> str: ...\n\n\nclass GH_AuthorSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_AutoSaveLastChanceForm:\n    def __init__(self): ...\n    @property\n    def RecoveryAction(self) -> GH_FileRecoveryAction: ...\n\n\nclass GH_AutoSaveSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_Banner:\n    def __init__(self): ...\n    def AddAllAssemblyInfo(self) -> None: ...\n    def AddAssemblyInfo(self, info: GH_AssemblyInfo) -> None: ...\n    @property\n    def ShowLibraryIcons(self) -> bool: ...\n    def HideBanner(self) -> None: ...\n    @ShowLibraryIcons.setter\n    def ShowLibraryIcons(self, Value: bool) -> None: ...\n    def UpdateLibraryUI(self) -> None: ...\n\n\nclass GH_BezierSolver:\n    def __init__(self): ...\n    def AngleAt(P0: PointF, P1: PointF, P2: PointF, P3: PointF, t: Single) -> Tuple[Single, PointF, PointF, PointF, PointF]: ...\n    def PointAt(P0: PointF, P1: PointF, P2: PointF, P3: PointF, t: Single) -> Tuple[PointF, PointF, PointF, PointF, PointF]: ...\n    def TangentAt(P0: PointF, P1: PointF, P2: PointF, P3: PointF, t: Single) -> Tuple[SizeF, PointF, PointF, PointF, PointF]: ...\n\n\nclass GH_CanvasMouseEvent:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, vp: GH_Viewport, e_args: MouseEventArgs): ...\n    @overload\n    def __init__(self, pt_control: Point, pt_canvas: PointF, mButton: MouseButtons, iClicks: int, iDelta: int): ...\n    @property\n    def Button(self) -> MouseButtons: ...\n    @property\n    def CanvasLocation(self) -> PointF: ...\n    @property\n    def CanvasX(self) -> Single: ...\n    @property\n    def CanvasY(self) -> Single: ...\n    @property\n    def Clicks(self) -> int: ...\n    @property\n    def ControlLocation(self) -> Point: ...\n    @property\n    def ControlX(self) -> int: ...\n    @property\n    def ControlY(self) -> int: ...\n    @property\n    def Delta(self) -> int: ...\n    @property\n    def WinFormsEventArgs(self) -> MouseEventArgs: ...\n\n\nclass GH_CanvasObjectMouseDownEventArgs:\n    def __init__(self, sender: GH_Canvas, object: GH_RelevantObjectData): ...\n    @property\n    def Canvas(self) -> GH_Canvas: ...\n    @property\n    def Document(self) -> GH_Document: ...\n    @property\n    def Object(self) -> GH_RelevantObjectData: ...\n\n\nclass GH_CanvasOverlaySettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_CanvasZuiSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_CapsuleDisabledPaletteSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_CapsuleErrorPaletteSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_CapsuleHiddenPaletteSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_CapsuleStandardPaletteSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_CapsuleWarningPaletteSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_ClusterGateWayProperties:\n    def __init__(self): ...\n    @property\n    def CustomDescription(self) -> str: ...\n    @property\n    def CustomName(self) -> str: ...\n    @property\n    def CustomNickName(self) -> str: ...\n    @CustomDescription.setter\n    def CustomDescription(self, Value: str) -> None: ...\n    @CustomName.setter\n    def CustomName(self, Value: str) -> None: ...\n    @CustomNickName.setter\n    def CustomNickName(self, Value: str) -> None: ...\n\n\nclass GH_ClusterPasswordWindow:\n    def __init__(self): ...\n\n\nclass GH_ClusterPropertiesEditor:\n    def __init__(self): ...\n    @overload\n    def LoadCluster(self, cluster: GH_Cluster_OBSOLETE) -> None: ...\n    @overload\n    def LoadCluster(self, cluster: GH_Cluster) -> None: ...\n    def SaveCluster(self, cluster: GH_Cluster_OBSOLETE) -> None: ...\n    def WriteToCluster(self, cluster: GH_Cluster) -> None: ...\n\n\nclass GH_ColourPicker:\n    def __init__(self): ...\n    def add_ColourChanged(self, obj: ColourChangedEventHandler) -> None: ...\n    @property\n    def AllowNumericInput(self) -> bool: ...\n    @property\n    def Colour(self) -> Color: ...\n    @property\n    def DesiredHeight(self) -> int: ...\n    @property\n    def ShowAlphaSlider(self) -> bool: ...\n    @property\n    def ShowChannelSliders(self) -> bool: ...\n    @property\n    def SliceRectangle(self) -> Rectangle: ...\n    def remove_ColourChanged(self, obj: ColourChangedEventHandler) -> None: ...\n    def RespondToEnter(self) -> GH_ToolstripItemKeyHandlerResult: ...\n    def RespondToEscape(self) -> GH_ToolstripItemKeyHandlerResult: ...\n    @AllowNumericInput.setter\n    def AllowNumericInput(self, Value: bool) -> None: ...\n    @Colour.setter\n    def Colour(self, Value: Color) -> None: ...\n    @ShowAlphaSlider.setter\n    def ShowAlphaSlider(self, Value: bool) -> None: ...\n    @ShowChannelSliders.setter\n    def ShowChannelSliders(self, Value: bool) -> None: ...\n\n\nclass GH_ColourSwatchControl(GH_DoubleBufferedPanel):\n    def __init__(self): ...\n    def add_ColourChanged(self, obj: ColourChangedEventHandler) -> None: ...\n    @property\n    def Colour(self) -> Color: ...\n    def remove_ColourChanged(self, obj: ColourChangedEventHandler) -> None: ...\n    @Colour.setter\n    def Colour(self, Value: Color) -> None: ...\n\n\nclass GH_ColourSwatchEventArgs:\n    def __init__(self, colour: Color): ...\n    @property\n    def Colour(self) -> Color: ...\n\n\nclass GH_CompassWidgetSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_ComponentAggregateForm:\n    def __init__(self): ...\n    @property\n    def ProxyCount(self) -> int: ...\n    def PopProxy(self) -> IGH_ObjectProxy: ...\n    def PushProxy(self, proxy: IGH_ObjectProxy) -> None: ...\n\n\nclass GH_ComponentGuidConflictDialog:\n    def __init__(self): ...\n    @property\n    def ConflictingProxy(self) -> IGH_ObjectProxy: ...\n    @property\n    def LoadedProxy(self) -> IGH_ObjectProxy: ...\n    @property\n    def Solution(self) -> GH_GuidConflictSolution: ...\n    def SetupDialog(self, cLoaded: IGH_ObjectProxy, cConflicted: IGH_ObjectProxy) -> None: ...\n\n\nclass GH_ComponentInfoForm:\n    def __init__(self): ...\n    @property\n    def MarkerType(self) -> GH_MarkerType: ...\n    def SetupMarker(self, control: Control, target: Rectangle, type: GH_MarkerType) -> None: ...\n\n\nclass GH_ComponentMenuSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_Constraint:\n    #None = 0\n    Vertical = 1\n    Horizontal = 2\n\n\nclass GH_ControlKnobOptionsForm:\n    def __init__(self): ...\n    @property\n    def Decimals(self) -> int: ...\n    @property\n    def DisplayFormat(self) -> str: ...\n    @property\n    def KnobName(self) -> str: ...\n    @property\n    def LimitValue(self) -> bool: ...\n    @property\n    def MaximumValue(self) -> Decimal: ...\n    @property\n    def MinimumValue(self) -> Decimal: ...\n    @property\n    def Modified(self) -> bool: ...\n    @property\n    def Range(self) -> Decimal: ...\n    @property\n    def Value(self) -> Decimal: ...\n    @Decimals.setter\n    def Decimals(self, Value: int) -> None: ...\n    @DisplayFormat.setter\n    def DisplayFormat(self, Value: str) -> None: ...\n    @KnobName.setter\n    def KnobName(self, Value: str) -> None: ...\n    @LimitValue.setter\n    def LimitValue(self, Value: bool) -> None: ...\n    @MaximumValue.setter\n    def MaximumValue(self, Value: Decimal) -> None: ...\n    @MinimumValue.setter\n    def MinimumValue(self, Value: Decimal) -> None: ...\n    @Range.setter\n    def Range(self, Value: Decimal) -> None: ...\n    @Value.setter\n    def Value(self, Value: Decimal) -> None: ...\n\n\nclass GH_ControlKnobValueEditor:\n    def __init__(self): ...\n    def add_ValuesChanged(self, obj: ValuesChangedEventHandler) -> None: ...\n    @property\n    def Limited(self) -> bool: ...\n    @property\n    def LowerLimit(self) -> Decimal: ...\n    @property\n    def OriginalLowerLimit(self) -> Decimal: ...\n    @property\n    def OriginalUpperLimit(self) -> Decimal: ...\n    @property\n    def OriginalValue(self) -> Decimal: ...\n    @property\n    def tblLayout(self) -> TableLayoutPanel: ...\n    @property\n    def UpperLimit(self) -> Decimal: ...\n    @property\n    def Value(self) -> Decimal: ...\n    def PrepareForCancel(self) -> None: ...\n    def PrepareForCommit(self) -> None: ...\n    def remove_ValuesChanged(self, obj: ValuesChangedEventHandler) -> None: ...\n    @tblLayout.setter\n    def tblLayout(self, WithEventsValue: TableLayoutPanel) -> None: ...\n    def SetupValues(self, limit: bool, lower: Decimal, upper: Decimal, value: Decimal, decimals: int) -> None: ...\n\n\nclass GH_CreateStateDialog:\n    def __init__(self): ...\n    def AddAllDocumentObjects(self, def: GH_Document) -> None: ...\n    @property\n    def StateList(self) -> List: ...\n\n\nclass GH_CursorServer:\n    def AttachCursor(self, control: Control, name: str) -> bool: ...\n    def Cursor(self, name: str) -> Cursor: ...\n    @property\n    def Count(self) -> int: ...\n    def IsCursor(self, name: str) -> bool: ...\n    def ReferenceCursors(self, folder: str) -> int: ...\n    def ResetCursor(self, control: Control) -> bool: ...\n\n\nclass GH_CustomButton:\n    def __init__(self): ...\n    @property\n    def Description(self) -> str: ...\n    @property\n    def Icon(self) -> Bitmap: ...\n    @property\n    def Name(self) -> str: ...\n    @property\n    def RequireCode(self) -> str: ...\n    @property\n    def RequireCodeInstance(self) -> GH_CustomButtonRequireFilter: ...\n    @property\n    def RequireDocument(self) -> bool: ...\n    @property\n    def RequireObjects(self) -> bool: ...\n    @property\n    def RequireSelection(self) -> bool: ...\n    @property\n    def RunCode(self) -> str: ...\n    @property\n    def RunCodeInstance(self) -> GH_CustomButtonRunCode: ...\n    @property\n    def UseCustomRequirementCode(self) -> bool: ...\n    def Read(self, reader: GH_IReader) -> bool: ...\n    @Description.setter\n    def Description(self, Value: str) -> None: ...\n    @Icon.setter\n    def Icon(self, Value: Bitmap) -> None: ...\n    @Name.setter\n    def Name(self, Value: str) -> None: ...\n    @RequireCode.setter\n    def RequireCode(self, Value: str) -> None: ...\n    @RequireDocument.setter\n    def RequireDocument(self, Value: bool) -> None: ...\n    @RequireObjects.setter\n    def RequireObjects(self, Value: bool) -> None: ...\n    @RequireSelection.setter\n    def RequireSelection(self, Value: bool) -> None: ...\n    @RunCode.setter\n    def RunCode(self, Value: str) -> None: ...\n    @UseCustomRequirementCode.setter\n    def UseCustomRequirementCode(self, Value: bool) -> None: ...\n    def Write(self, writer: GH_IWriter) -> bool: ...\n\n\nclass GH_CustomButtonRequireFilter:\n    pass\n\n\nclass GH_CustomButtonRunCode:\n    pass\n\n\nclass GH_DataTreeBranchGraphic:\n    def __init__(self): ...\n    def RenderFullBranch(self, graphics: Graphics, colour: Color) -> None: ...\n    def RenderPartialBranch(self, graphics: Graphics, colour: Color) -> None: ...\n\n\nclass GH_DataTreeGraphic:\n    def __init__(self): ...\n\n\nclass GH_DateTimePicker:\n    def __init__(self): ...\n\n\nclass GH_DebugLogForm:\n    def __init__(self): ...\n\n\nclass GH_DefaultPreviewSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_DeveloperSettings:\n    def __init__(self): ...\n\n\nclass GH_DigitScroller(GH_TextInputBaseControl):\n    def __init__(self): ...\n    def add_ValueChanged(self, obj: ValueChangedEventHandler) -> None: ...\n    @property\n    def AllowRadixDrag(self) -> bool: ...\n    @property\n    def AllowTextInput(self) -> bool: ...\n    @property\n    def Amplify(self) -> bool: ...\n    @property\n    def DecimalPlaces(self) -> int: ...\n    @property\n    def DigitAlign(self) -> GH_DigitAlign: ...\n    @property\n    def Digits(self) -> int: ...\n    @property\n    def DigitScroller(self) -> GH_DigitScrollerBase: ...\n    @property\n    def Epsilon(self) -> Decimal: ...\n    @property\n    def MaximumValue(self) -> Decimal: ...\n    @property\n    def MinimumValue(self) -> Decimal: ...\n    @property\n    def Prefix(self) -> str: ...\n    @property\n    def Presets(self) -> GH_NumberPresets: ...\n    @property\n    def Radix(self) -> int: ...\n    @property\n    def Suffix(self) -> str: ...\n    @property\n    def Value(self) -> Decimal: ...\n    def remove_ValueChanged(self, obj: ValueChangedEventHandler) -> None: ...\n    @AllowRadixDrag.setter\n    def AllowRadixDrag(self, Value: bool) -> None: ...\n    @AllowTextInput.setter\n    def AllowTextInput(self, Value: bool) -> None: ...\n    @Amplify.setter\n    def Amplify(self, Value: bool) -> None: ...\n    @DecimalPlaces.setter\n    def DecimalPlaces(self, Value: int) -> None: ...\n    @DigitAlign.setter\n    def DigitAlign(self, Value: GH_DigitAlign) -> None: ...\n    @Digits.setter\n    def Digits(self, Value: int) -> None: ...\n    @MaximumValue.setter\n    def MaximumValue(self, Value: Decimal) -> None: ...\n    @MinimumValue.setter\n    def MinimumValue(self, Value: Decimal) -> None: ...\n    @Prefix.setter\n    def Prefix(self, Value: str) -> None: ...\n    @Radix.setter\n    def Radix(self, Value: int) -> None: ...\n    @Suffix.setter\n    def Suffix(self, Value: str) -> None: ...\n    @Value.setter\n    def Value(self, Value: Decimal) -> None: ...\n\n\nclass GH_DisplaySettingsCategory(GH_SettingsCategory):\n    def __init__(self): ...\n    @property\n    def Description(self) -> str: ...\n\n\nclass GH_DocumentEditor:\n    def __init__(self): ...\n    def add_AggregateShortcutMenuItems(obj: AggregateShortcutMenuItemsEventHandler) -> None: ...\n    def add_EditorFoldStateChanged(self, obj: EditorFoldStateChangedEventHandler) -> None: ...\n    def ClearStatusBar(self) -> None: ...\n    def CloseForReal(self) -> None: ...\n    def CollapseForm(self) -> None: ...\n    def DisableUI(self) -> None: ...\n    def EnableUI(self) -> None: ...\n    def ExpandForm(self) -> None: ...\n    def FadeIn(self) -> None: ...\n    def FadeOut(self) -> None: ...\n    def FixCanvasToolbarState(self) -> None: ...\n    @property\n    def Collapsed(self) -> bool: ...\n    @property\n    def FormShepard(self) -> GH_FormShepard: ...\n    def remove_AggregateShortcutMenuItems(obj: AggregateShortcutMenuItemsEventHandler) -> None: ...\n    def remove_EditorFoldStateChanged(self, obj: EditorFoldStateChangedEventHandler) -> None: ...\n    def ScriptAccess_CloseAllDocuments(self) -> bool: ...\n    def ScriptAccess_CloseDocument(self) -> bool: ...\n    def ScriptAccess_IsDocument(self) -> bool: ...\n    def ScriptAccess_IsDocumentModified(self) -> bool: ...\n    def ScriptAccess_NewDocument(self) -> bool: ...\n    @overload\n    def ScriptAccess_OpenDocument(self) -> bool: ...\n    @overload\n    def ScriptAccess_OpenDocument(self, filename: str) -> bool: ...\n    def ScriptAccess_SaveDocument(self) -> bool: ...\n    @overload\n    def ScriptAccess_SaveDocumentAs(self) -> bool: ...\n    @overload\n    def ScriptAccess_SaveDocumentAs(self, path: str) -> bool: ...\n    def SetStatusBarEvent(self, event: GH_RuntimeMessage) -> None: ...\n    def ToggleForm(self) -> None: ...\n\n\nclass GH_DocumentMdiItem(GH_DoubleBufferedPanel):\n    def __init__(self): ...\n    @property\n    def CloseArea(self) -> Rectangle: ...\n    @property\n    def ClusterArea(self) -> Rectangle: ...\n    @property\n    def DesiredHeight(self) -> int: ...\n    @property\n    def DesiredWidth(self) -> int: ...\n    @property\n    def Document(self) -> GH_Document: ...\n    @Document.setter\n    def Document(self, Value: GH_Document) -> None: ...\n\n\nclass GH_DocumentPreviewSettings:\n    def __init__(self): ...\n    def add_ColoursChanged(self, obj: ColoursChangedEventHandler) -> None: ...\n    @property\n    def NormalColour(self) -> Color: ...\n    @property\n    def SelectedColour(self) -> Color: ...\n    def LoadPresets(self) -> None: ...\n    def remove_ColoursChanged(self, obj: ColoursChangedEventHandler) -> None: ...\n    def SavePresets(self) -> None: ...\n    @NormalColour.setter\n    def NormalColour(self, Value: Color) -> None: ...\n    @SelectedColour.setter\n    def SelectedColour(self, Value: Color) -> None: ...\n\n\nclass GH_DocumentPreviewSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_DocumentPropertiesEditor:\n    def __init__(self): ...\n    def SetDocumentProperties(self, Props: GH_DocumentProperties) -> None: ...\n    def UpdateIconControl(self) -> None: ...\n\n\nclass GH_DoubleBufferedPanel:\n    def __init__(self): ...\n\n\nclass GH_DragDropImageRenderer:\n    def __init__(self): ...\n    def CompleteDrag(self) -> None: ...\n    def Dispose(self) -> None: ...\n    @property\n    def ImageList(self) -> ImageList: ...\n    @property\n    def Owner(self) -> Control: ...\n    def HideDragDropImage(self, hide: bool) -> None: ...\n    def PaintDragDropImage(self) -> None: ...\n    @ImageList.setter\n    def ImageList(self, Value: ImageList) -> None: ...\n    @Owner.setter\n    def Owner(self, Value: Control) -> None: ...\n    @overload\n    def StartDrag(self, imageIndex: int) -> None: ...\n    @overload\n    def StartDrag(self, imageIndex: int, xOffset: int, yOffset: int) -> None: ...\n\n\nclass GH_DragInfo:\n    def __init__(self, drag_point: Point, initial_shape: Rectangle): ...\n    def Drag(self, new_point: Point) -> None: ...\n    @property\n    def Box_Drag(self) -> Rectangle: ...\n    @property\n    def Box_Start(self) -> Rectangle: ...\n    @property\n    def Constraint(self) -> GH_Constraint: ...\n    @property\n    def Point_Drag(self) -> Point: ...\n    @property\n    def Point_Start(self) -> Point: ...\n    @property\n    def Region(self) -> Rectangle: ...\n    @Constraint.setter\n    def Constraint(self, Value: GH_Constraint) -> None: ...\n    @Region.setter\n    def Region(self, Value: Rectangle) -> None: ...\n\n\nclass GH_EtoUtil:\n    def CenterFormOnCursor(F: Window, limitToScreen: bool) -> None: ...\n    def CenterFormOnEditor(F: Window, limitToScreen: bool) -> None: ...\n    def CenterFormOnScreen(F: Window, limitToScreen: bool) -> None: ...\n    def CenterFormOnWindow(F: Window, parentWindow: Window, limitToScreen: bool) -> None: ...\n\n\nclass GH_ExpressionEditor:\n    def __init__(self): ...\n    @property\n    def Expression(self) -> str: ...\n    @property\n    def PreviewDelegate(self) -> GH_PreviewExpression: ...\n    @property\n    def Variables(self) -> Dictionary: ...\n    @Expression.setter\n    def Expression(self, Value: str) -> None: ...\n    @PreviewDelegate.setter\n    def PreviewDelegate(self, Value: GH_PreviewExpression) -> None: ...\n\n\nclass GH_ExternalFileConflictDialog:\n    def __init__(self): ...\n    @property\n    def FilePathA(self) -> str: ...\n    @property\n    def FilePathB(self) -> str: ...\n    @property\n    def InfoLabel(self) -> Label: ...\n    @property\n    def LoadFileCode(self) -> int: ...\n    @FilePathA.setter\n    def FilePathA(self, Value: str) -> None: ...\n    @FilePathB.setter\n    def FilePathB(self, Value: str) -> None: ...\n    @InfoLabel.setter\n    def InfoLabel(self, WithEventsValue: Label) -> None: ...\n\n\nclass GH_ExternalFilePanel(GH_DoubleBufferedPanel):\n    def __init__(self): ...\n    def add_FileDeleteClicked(self, obj: FileDeleteClickedEventHandler) -> None: ...\n    def add_FileLoadClicked(self, obj: FileLoadClickedEventHandler) -> None: ...\n    @property\n    def File(self) -> str: ...\n    def remove_FileDeleteClicked(self, obj: FileDeleteClickedEventHandler) -> None: ...\n    def remove_FileLoadClicked(self, obj: FileLoadClickedEventHandler) -> None: ...\n    @File.setter\n    def File(self, Value: str) -> None: ...\n\n\nclass GH_FadeAnimation:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, threshold: Single): ...\n    @overload\n    def __init__(self, threshold: Single, duration: int): ...\n    @overload\n    def Evaluate(self, canvas: GH_Canvas) -> None: ...\n    @overload\n    def Evaluate(self, canvas: GH_Canvas, scheduleRedraw: bool) -> None: ...\n    @overload\n    def Evaluate(self, canvas: GH_Canvas, value: Single) -> None: ...\n    @overload\n    def Evaluate(self, canvas: GH_Canvas, value: Single, scheduleRedraw: bool) -> None: ...\n    @property\n    def Duration(self) -> int: ...\n    @property\n    def FadeAlpha(self) -> int: ...\n    @property\n    def FadeFactor(self) -> float: ...\n    @property\n    def IsFinished(self) -> bool: ...\n    @property\n    def Phase(self) -> GH_FadePhase: ...\n    @property\n    def Threshold(self) -> Single: ...\n    @property\n    def TriggerUpdate(self) -> bool: ...\n    @Duration.setter\n    def Duration(self, Value: int) -> None: ...\n    @Threshold.setter\n    def Threshold(self, Value: Single) -> None: ...\n    @TriggerUpdate.setter\n    def TriggerUpdate(self, Value: bool) -> None: ...\n\n\nclass GH_FadePhase:\n    Hidden = 0\n    Hiding = 1\n    Shown = 2\n    Showing = 3\n\n\nclass GH_FileRecoveryAction:\n    #None = 0\n    OpenRecoveryFile = 1\n    SaveRecoveryFile = 2\n    DeleteRecoveryFile = 3\n\n\nclass GH_FilesSettingsCategory(GH_SettingsCategory):\n    def __init__(self): ...\n    @property\n    def Description(self) -> str: ...\n\n\nclass GH_FindObjectDialog:\n    def __init__(self): ...\n    @property\n    def Canvas(self) -> GH_Canvas: ...\n    @property\n    def SelectedHit(self) -> int: ...\n    @Canvas.setter\n    def Canvas(self, Value: GH_Canvas) -> None: ...\n    @SelectedHit.setter\n    def SelectedHit(self, Value: int) -> None: ...\n\n\nclass GH_FolderPathBrowser:\n    def __init__(self): ...\n    def add_PathChanged(self, obj: PathChangedEventHandler) -> None: ...\n    @property\n    def BrowseText(self) -> str: ...\n    @property\n    def Filter(self) -> str: ...\n    @property\n    def IsFileBrowser(self) -> bool: ...\n    @property\n    def IsFolderBrowser(self) -> bool: ...\n    @property\n    def Path(self) -> str: ...\n    @property\n    def RequireExisting(self) -> bool: ...\n    def IsValidPath(pathString: str) -> bool: ...\n    def remove_PathChanged(self, obj: PathChangedEventHandler) -> None: ...\n    @BrowseText.setter\n    def BrowseText(self, Value: str) -> None: ...\n    @Filter.setter\n    def Filter(self, Value: str) -> None: ...\n    @Path.setter\n    def Path(self, Value: str) -> None: ...\n    @RequireExisting.setter\n    def RequireExisting(self, Value: bool) -> None: ...\n\n\nclass GH_FontConsoleSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_FontControl:\n    def __init__(self): ...\n    @property\n    def AllowFamilyOverride(self) -> bool: ...\n    @property\n    def AllowSizeOverride(self) -> bool: ...\n    @property\n    def AllowStyleOverride(self) -> bool: ...\n    @AllowFamilyOverride.setter\n    def AllowFamilyOverride(self, Value: bool) -> None: ...\n    @AllowSizeOverride.setter\n    def AllowSizeOverride(self, Value: bool) -> None: ...\n    @AllowStyleOverride.setter\n    def AllowStyleOverride(self, Value: bool) -> None: ...\n\n\nclass GH_FontList(GH_DoubleBufferedPanel):\n    def __init__(self): ...\n    def CreateFont(self) -> Font: ...\n    @property\n    def DisplayText(self) -> str: ...\n    @property\n    def Filter(self) -> str: ...\n    @property\n    def FontFamily(self) -> FontFamily: ...\n    @property\n    def FontSize(self) -> Single: ...\n    @property\n    def FontStyle(self) -> FontStyle: ...\n    def RecreateFontList(self) -> None: ...\n    @DisplayText.setter\n    def DisplayText(self, Value: str) -> None: ...\n    @Filter.setter\n    def Filter(self, Value: str) -> None: ...\n    @FontFamily.setter\n    def FontFamily(self, Value: FontFamily) -> None: ...\n    @FontSize.setter\n    def FontSize(self, Value: Single) -> None: ...\n    @FontStyle.setter\n    def FontStyle(self, Value: FontStyle) -> None: ...\n\n\nclass GH_FontMappingDialog:\n    def __init__(self): ...\n    @property\n    def lblFont(self) -> Label: ...\n    @property\n    def lnkSubstitution(self) -> LinkLabel: ...\n    @property\n    def OriginalFont(self) -> str: ...\n    @property\n    def Substitution(self) -> str: ...\n    @lblFont.setter\n    def lblFont(self, WithEventsValue: Label) -> None: ...\n    @lnkSubstitution.setter\n    def lnkSubstitution(self, WithEventsValue: LinkLabel) -> None: ...\n    @OriginalFont.setter\n    def OriginalFont(self, Value: str) -> None: ...\n    @Substitution.setter\n    def Substitution(self, Value: str) -> None: ...\n\n\nclass GH_FontPicker:\n    def __init__(self): ...\n    def CreateFontPickerWindow(defaultFont: Font) -> Form: ...\n    @property\n    def SelectedFont(self) -> Font: ...\n    @SelectedFont.setter\n    def SelectedFont(self, Value: Font) -> None: ...\n    @overload\n    def ShowFontPickerWindow(font: Font) -> Font: ...\n    @overload\n    def ShowFontPickerWindow(font: Font, parent: Form) -> Font: ...\n\n\nclass GH_FontScriptSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_FontScroller(GH_DoubleBufferedPanel):\n    def __init__(self): ...\n    @property\n    def PostPaintDelegate(self) -> PostPaint: ...\n    @PostPaintDelegate.setter\n    def PostPaintDelegate(self, Value: PostPaint) -> None: ...\n\n\nclass GH_FontsSettingsCategory(GH_SettingsCategory):\n    def __init__(self): ...\n    @property\n    def Description(self) -> str: ...\n\n\nclass GH_FontStandardSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_FormattingSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_FormShepard:\n    def __init__(self, nOwner: Form): ...\n    @property\n    def Sheep(self) -> Iterable[Form]: ...\n    def RegisterForm(self, dialog: Form) -> None: ...\n    def UnregisterForm(self, dialog: Form) -> None: ...\n\n\nclass GH_GDI_PolyArc:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, other: GH_GDI_PolyArc): ...\n    @overload\n    def AppendArc(self, Arc: Arc) -> None: ...\n    @overload\n    def AppendArc(self, A: Point3d, B: Point3d, Ta: Vector3d) -> None: ...\n    @overload\n    def AppendArc(self, Ax: float, Ay: float, Bx: float, By: float, Tx: float, Ty: float) -> None: ...\n    @overload\n    def AppendArc3Pt(self, A: Point3d, B: Point3d, C: Point3d) -> None: ...\n    @overload\n    def AppendArc3Pt(self, Ax: float, Ay: float, Bx: float, By: float, Cx: float, Cy: float) -> None: ...\n    @overload\n    def AppendLine(self, A: Point3d, B: Point3d) -> None: ...\n    @overload\n    def AppendLine(self, Ax: float, Ay: float, Bx: float, By: float) -> None: ...\n    def StartNewPath(self) -> None: ...\n    def ToPath(self) -> GraphicsPath: ...\n\n\nclass GH_GDI_Util:\n    def BoxUnion(rectangles: Iterable[Rectangle]) -> List: ...\n    def FilletBoxOutline(boxes: Iterable[Rectangle], radius: int) -> GraphicsPath: ...\n    @overload\n    def FilletPolyline(corners: Set(Point), radius: int) -> GraphicsPath: ...\n    @overload\n    def FilletPolyline(corners: Set(PointF), radius: Single) -> GraphicsPath: ...\n    def FilletRectangle(box: Rectangle, radius: int) -> GraphicsPath: ...\n    @overload\n    def Freeform_Blob(content: Iterable[RectangleF], padding: int, accuracy: float) -> GraphicsPath: ...\n    @overload\n    def Freeform_Blob(content: Iterable[RectangleF], padding: int, accuracy: float, solver: FieldSolver, section: float) -> GraphicsPath: ...\n    def SimplifyBoxes(boxes: Iterable[Rectangle]) -> Set(Rectangle): ...\n\n\nclass GH_GeometricFont:\n    def Draw0(graphics: Graphics, colour: Color, position: PointF) -> None: ...\n    def Draw1(graphics: Graphics, colour: Color, position: PointF) -> None: ...\n    def Draw2(graphics: Graphics, colour: Color, position: PointF) -> None: ...\n    def Draw3(graphics: Graphics, colour: Color, position: PointF) -> None: ...\n    def Draw4(graphics: Graphics, colour: Color, position: PointF) -> None: ...\n    def Draw5(graphics: Graphics, colour: Color, position: PointF) -> None: ...\n    def Draw6(graphics: Graphics, colour: Color, position: PointF) -> None: ...\n    def Draw7(graphics: Graphics, colour: Color, position: PointF) -> None: ...\n    def Draw8(graphics: Graphics, colour: Color, position: PointF) -> None: ...\n    def Draw9(graphics: Graphics, colour: Color, position: PointF) -> None: ...\n    def DrawBracketClose(graphics: Graphics, colour: Color, position: PointF) -> None: ...\n    def DrawBracketOpen(graphics: Graphics, colour: Color, position: PointF) -> None: ...\n    def DrawDash(graphics: Graphics, colour: Color, position: PointF) -> None: ...\n    @overload\n    def DrawNumber(graphics: Graphics, number: UInt32, colour: Color, position: PointF) -> None: ...\n    @overload\n    def DrawNumber(graphics: Graphics, number: Int64, colour: Color, position: PointF) -> None: ...\n    @overload\n    def DrawNumber(graphics: Graphics, number: UInt64, colour: Color, position: PointF) -> None: ...\n    @overload\n    def DrawNumber(graphics: Graphics, number: int, colour: Color, position: PointF) -> None: ...\n    def DrawPath(graphics: Graphics, path: GH_Path, colour: Color, position: PointF) -> None: ...\n    def DrawSemiColon(graphics: Graphics, colour: Color, position: PointF) -> None: ...\n    @property\n    def Char0() -> GraphicsPath: ...\n    @property\n    def Char1() -> GraphicsPath: ...\n    @property\n    def Char2() -> GraphicsPath: ...\n    @property\n    def Char3() -> GraphicsPath: ...\n    @property\n    def Char4() -> GraphicsPath: ...\n    @property\n    def Char5() -> GraphicsPath: ...\n    @property\n    def Char6() -> GraphicsPath: ...\n    @property\n    def Char7() -> GraphicsPath: ...\n    @property\n    def Char8() -> GraphicsPath: ...\n    @property\n    def Char9() -> GraphicsPath: ...\n    @property\n    def CharBracketClose() -> GraphicsPath: ...\n    @property\n    def CharBracketOpen() -> GraphicsPath: ...\n    @property\n    def CharDash() -> GraphicsPath: ...\n    @property\n    def CharSemiColon() -> GraphicsPath: ...\n\n\nclass GH_GHALoadSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_GooProxyList(GH_DoubleBufferedPanel):\n    def __init__(self): ...\n    def add_DataChanged(self, obj: DataChangedEventHandler) -> None: ...\n    def add_SelectionChanged(self, obj: SelectionChangedEventHandler) -> None: ...\n    @property\n    def SelectedData(self) -> List: ...\n    def GetData(self) -> GH_Structure: ...\n    def remove_DataChanged(self, obj: DataChangedEventHandler) -> None: ...\n    def remove_SelectionChanged(self, obj: SelectionChangedEventHandler) -> None: ...\n    def SetData(self, data: GH_Structure, baseType: IGH_Goo) -> None: ...\n\n\nclass GH_GradientEditor:\n    def __init__(self): ...\n    @property\n    def Gradient(self) -> GH_Gradient: ...\n    @Gradient.setter\n    def Gradient(self, Value: GH_Gradient) -> None: ...\n\n\nclass GH_GradientMenuItem:\n    def __init__(self): ...\n    @property\n    def DeleteRequested(self) -> bool: ...\n    @property\n    def Gradient(self) -> GH_Gradient: ...\n    @property\n    def Index(self) -> int: ...\n    @DeleteRequested.setter\n    def DeleteRequested(self, Value: bool) -> None: ...\n    @Gradient.setter\n    def Gradient(self, Value: GH_Gradient) -> None: ...\n    @Index.setter\n    def Index(self, Value: int) -> None: ...\n\n\nclass GH_GraphEditor:\n    def __init__(self): ...\n    @property\n    def Graph(self) -> GH_GraphContainer: ...\n    def SetGraph(self, G: GH_GraphContainer) -> None: ...\n\n\nclass GH_GraphicsUtil:\n    @overload\n    def AppendArc(p0: Point3d, p1: Point3d, dir: Vector3d, path: GraphicsPath) -> None: ...\n    @overload\n    def AppendArc(p0: PointF, p1: PointF, dir: SizeF, path: GraphicsPath) -> None: ...\n    @overload\n    def BlendColour(bottom: Color, top: Color) -> Color: ...\n    @overload\n    def BlendColour(bottom: Color, top: Color, factor: float) -> Color: ...\n    def BlendInteger(t0: float, t1: float, a0: int, a1: int, t: float) -> int: ...\n    def BoxClosestArcPoint(pt: PointF, box: RectangleF) -> PointF: ...\n    @overload\n    def BoxClosestPoint(pt: Point, box: Rectangle) -> Point: ...\n    @overload\n    def BoxClosestPoint(pt: PointF, box: RectangleF) -> PointF: ...\n    @overload\n    def BoxFurthestPoint(pt: Point, box: Rectangle) -> Point: ...\n    @overload\n    def BoxFurthestPoint(pt: PointF, box: RectangleF) -> PointF: ...\n    def BoxViewCone(pt: PointF, box: RectangleF) -> GraphicsPath: ...\n    @overload\n    def ColourARGB(r: int, g: int, b: int) -> Color: ...\n    @overload\n    def ColourARGB(r: float, g: float, b: float) -> Color: ...\n    @overload\n    def ColourARGB(a: int, r: int, g: int, b: int) -> Color: ...\n    def CreateColourIcon(width: int, height: int, colour: Color) -> Bitmap: ...\n    @overload\n    def DentHorizontal(g: Graphics, box: Rectangle) -> None: ...\n    @overload\n    def DentHorizontal(g: Graphics, box: Rectangle, alphaEdge: int, alphaFill: int) -> None: ...\n    @overload\n    def DentVertical(g: Graphics, box: Rectangle) -> None: ...\n    @overload\n    def DentVertical(g: Graphics, box: Rectangle, alphaEdge: int, alphaFill: int) -> None: ...\n    def Distance(a: PointF, b: PointF) -> Single: ...\n    def DistanceS(a: PointF, b: PointF) -> Single: ...\n    def EtchFadingHorizontal(g: Graphics, x0: int, x1: int, y: int, alphaLight: int, alphaDark: int) -> None: ...\n    def EtchFadingVertical(g: Graphics, y0: int, y1: int, x: int, alphaLight: int, alphaDark: int) -> None: ...\n    @overload\n    def EtchHorizontal(g: Graphics, x0: Single, x1: Single, y: Single, alpha: int) -> None: ...\n    @overload\n    def EtchHorizontal(g: Graphics, x0: int, x1: int, y: int, alphaLight: int, alphaDark: int) -> None: ...\n    @overload\n    def EtchVertical(g: Graphics, x: Single, y0: Single, y1: Single, alpha: int) -> None: ...\n    @overload\n    def EtchVertical(g: Graphics, x: int, y0: int, y1: int, alpha: int) -> None: ...\n    def FadeColour(t0: float, t1: float, t: float, col: Color) -> Color: ...\n    def ForegroundColour(col: Color, contrast: int) -> Color: ...\n    @property\n    def UiScale() -> Single: ...\n    @overload\n    def Grid(g: Graphics, rec: RectangleF, density: int) -> None: ...\n    @overload\n    def Grid(g: Graphics, rec: RectangleF, densityX: int, densityY: int) -> None: ...\n    @overload\n    def Grid(g: Graphics, rec: RectangleF, densityX: int, densityY: int, colorBg: Color, colorWire: Color) -> None: ...\n    def HighlightBrush() -> Brush: ...\n    def HighlightPen() -> Pen: ...\n    def InvertColour(col: Color) -> Color: ...\n    def IsPointInEllipse(ellipse: RectangleF, point: PointF) -> bool: ...\n    def LimitInteger(channel: int) -> Tuple[int]: ...\n    def LimitIntegers(r: int, g: int, b: int) -> Tuple[int, int, int]: ...\n    @overload\n    def OffsetColour(col: Color, shift: int) -> Color: ...\n    @overload\n    def OffsetColour(col: Color, redShift: int, greenShift: int, blueShift: int) -> Color: ...\n    @overload\n    def RenderBalloonTag(g: Graphics, text: str, tip: PointF, container: RectangleF) -> None: ...\n    @overload\n    def RenderBalloonTag(g: Graphics, text: str, font: Font, tip: PointF, container: RectangleF) -> None: ...\n    @overload\n    def RenderBalloonTag(g: Graphics, text: str, font: Font, backColor: Color, foreColor: Color, tip: PointF, container: RectangleF) -> None: ...\n    @overload\n    def RenderBalloonTag(g: Graphics, text: str, font: Font, backColor: Color, foreColor: Color, tip: PointF, upright: bool) -> None: ...\n    def RenderCenteredIcon(g: Graphics, frame: RectangleF, icon: Image, alpha: float) -> None: ...\n    def RenderCenteredText(g: Graphics, text: str, font: Font, color: Color, center: PointF) -> None: ...\n    def RenderColourIcon(g: Graphics, rec: Rectangle, colour: Color, scale: Single) -> None: ...\n    @overload\n    def RenderFadedImage(graphics: Graphics, image: Image, destination: Rectangle, alpha: int) -> None: ...\n    @overload\n    def RenderFadedImage(graphics: Graphics, image: Image, destination: Rectangle, fade: float) -> None: ...\n    @overload\n    def RenderHighlightBox(g: Graphics, box: Rectangle, cornerRadius: int) -> None: ...\n    @overload\n    def RenderHighlightBox(g: Graphics, box: Rectangle, cornerRadius: int, fill: Color, edge: Color) -> None: ...\n    @overload\n    def RenderHighlightBox(g: Graphics, box: Rectangle, cornerRadius: int, drawFill: bool, drawEdge: bool) -> None: ...\n    def RenderIcon(graphics: Graphics, frame: RectangleF, icon: Image) -> None: ...\n    @overload\n    def RenderObjectOverlay(graphics: Graphics, obj: IGH_ObjectProxy, target: RectangleF) -> None: ...\n    @overload\n    def RenderObjectOverlay(graphics: Graphics, obj: IGH_DocumentObject, target: RectangleF) -> None: ...\n    def RenderRoundBar(graphics: Graphics, rec: RectangleF, colour: Color) -> None: ...\n    def RenderTag(g: Graphics, tag: str, font: Font, backColor: Color, foreColor: Color, frame: RectangleF, alignH: StringAlignment, alignV: StringAlignment) -> None: ...\n    def RenderVerticalString(g: Graphics, text: str, font: Font, colour: Color, rec: RectangleF, format: StringFormat) -> None: ...\n    def RenderWarningIcon(graphics: Graphics, center: PointF, radius: Single, alpha: int) -> None: ...\n    def ScaleColour(col: Color, factor: float) -> Color: ...\n    @overload\n    def ShadowHorizontal(g: Graphics, x0: int, x1: int, y: int, size: int, below: bool, darkness: int) -> None: ...\n    @overload\n    def ShadowHorizontal(g: Graphics, x0: Single, x1: Single, y: Single, size: Single, below: bool, darkness: int) -> None: ...\n    @overload\n    def ShadowHorizontal(g: Graphics, x0: int, x1: int, y: int, size: int, below: bool, color: Color) -> None: ...\n    @overload\n    def ShadowRectangle(g: Graphics, rec: Rectangle, size: int, color: Color) -> None: ...\n    @overload\n    def ShadowRectangle(g: Graphics, rec: Rectangle, size: int, darkness: int) -> None: ...\n    @overload\n    def ShadowVertical(g: Graphics, x: int, y0: int, y1: int, size: int, right: bool, color: Color) -> None: ...\n    @overload\n    def ShadowVertical(g: Graphics, x: Single, y0: Single, y1: Single, size: Single, right: bool, darkness: int) -> None: ...\n    @overload\n    def ShadowVertical(g: Graphics, x: int, y0: int, y1: int, size: int, right: bool, darkness: int) -> None: ...\n    @overload\n    def SolveArc(p0: PointF, p1: PointF, dir: SizeF, box: RectangleF, angle: Single, sweep: Single) -> Tuple[bool, RectangleF, Single, Single]: ...\n    @overload\n    def SolveArc(p0: Point3d, p1: Point3d, dir: Vector3d, box: RectangleF, angle: Single, sweep: Single) -> Tuple[bool, RectangleF, Single, Single]: ...\n    @overload\n    def SolveArc(p0X: float, p0Y: float, p1X: float, p1Y: float, dx: float, dy: float, box: RectangleF, angle: Single, sweep: Single) -> Tuple[bool, RectangleF, Single, Single]: ...\n    @overload\n    def TransparencyMatrix(fade: float) -> ColorMatrix: ...\n    @overload\n    def TransparencyMatrix(alpha: int) -> ColorMatrix: ...\n\n\nclass GH_GumballAndMeshingSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_HiResExportForm:\n    def __init__(self): ...\n    @property\n    def CanvasColor(self) -> Color: ...\n    @property\n    def FilePath(self) -> str: ...\n    @property\n    def ZoomFactor(self) -> Single: ...\n    def StorePersistentSettings(self) -> None: ...\n\n\nclass GH_HorizontalSeparator(GH_DoubleBufferedPanel):\n    def __init__(self): ...\n    @property\n    def DisplayMode(self) -> GH_SeparatorDisplay: ...\n    @DisplayMode.setter\n    def DisplayMode(self, Value: GH_SeparatorDisplay) -> None: ...\n\n\nclass GH_IconLabel:\n    def __init__(self): ...\n    @property\n    def LabelIcon(self) -> Bitmap: ...\n    @LabelIcon.setter\n    def LabelIcon(self, Value: Bitmap) -> None: ...\n\n\nclass GH_IconPicker:\n    def __init__(self): ...\n    @property\n    def Icon(self) -> Bitmap: ...\n    @property\n    def IconChanged(self) -> bool: ...\n    @Icon.setter\n    def Icon(self, Value: Bitmap) -> None: ...\n\n\nclass GH_IconTable:\n    @property\n    def Count() -> int: ...\n    def Icon(index: int) -> Bitmap: ...\n    def RegisterIcon(icon: Bitmap) -> int: ...\n    def ResizeImage(img: Image, size: Size, mode: InterpolationMode, format: PixelFormat) -> Bitmap: ...\n    def To32BppArgb(img: Image) -> Bitmap: ...\n    def To32BppPArgb(img: Image) -> Bitmap: ...\n\n\nclass GH_IconVariations:\n    def _IconBlackAdditionLL(icon: Bitmap) -> Bitmap: ...\n    def _IconBlackAdditionLR(icon: Bitmap) -> Bitmap: ...\n    def _IconBlackAdditionTL(icon: Bitmap) -> Bitmap: ...\n    def _IconBlackAdditionTR(icon: Bitmap) -> Bitmap: ...\n    def _IconBlackNewBottomOverlay(icon: Bitmap) -> Bitmap: ...\n    def _IconBlackNewTopOverlay(icon: Bitmap) -> Bitmap: ...\n    def _IconDropShadow0(icon: Bitmap) -> Bitmap: ...\n    def _IconDropShadow1(icon: Bitmap) -> Bitmap: ...\n    def _IconDropShadow2(icon: Bitmap) -> Bitmap: ...\n    def _IconDropShadow3(icon: Bitmap) -> Bitmap: ...\n    def _IconGreyScale0(icon: Bitmap) -> Bitmap: ...\n    def _IconGreyScale1(icon: Bitmap) -> Bitmap: ...\n    def _IconGreyScale2(icon: Bitmap) -> Bitmap: ...\n    def _IconGreyScale3(icon: Bitmap) -> Bitmap: ...\n    def _IconSatScale0(icon: Bitmap) -> Bitmap: ...\n    def _IconSatScale1(icon: Bitmap) -> Bitmap: ...\n    def _IconSatScale2(icon: Bitmap) -> Bitmap: ...\n    def _IconSatScale3(icon: Bitmap) -> Bitmap: ...\n    def _IconWhiteAdditionLL(icon: Bitmap) -> Bitmap: ...\n    def _IconWhiteAdditionLR(icon: Bitmap) -> Bitmap: ...\n    def _IconWhiteAdditionTL(icon: Bitmap) -> Bitmap: ...\n    def _IconWhiteAdditionTR(icon: Bitmap) -> Bitmap: ...\n    def _IconWhiteBoxBackground(icon: Bitmap) -> Bitmap: ...\n    def _IconWhiteGridBackground(icon: Bitmap) -> Bitmap: ...\n    def _TintCustomColour(icon: Bitmap, tint: Color) -> Bitmap: ...\n    def CreateIconVariations(icon: Bitmap) -> List: ...\n    def CreateIconVariationTexts() -> List: ...\n\n\nclass GH_ImageSamplerSettingsDialog:\n    def __init__(self): ...\n    def ApplySettings(self) -> None: ...\n    @property\n    def Sampler(self) -> GH_ImageSampler: ...\n    def RevertSettings(self) -> None: ...\n    @Sampler.setter\n    def Sampler(self, Value: GH_ImageSampler) -> None: ...\n\n\nclass GH_InfoTextBox:\n    def __init__(self): ...\n    @overload\n    def add_TextChanged(self, obj: TextChangedEventHandler) -> None: ...\n    @property\n    def DefaultMessage(self) -> str: ...\n    @property\n    def Text(self) -> str: ...\n    @property\n    def TextBox(self) -> TextBox: ...\n    @overload\n    def remove_TextChanged(self, obj: TextChangedEventHandler) -> None: ...\n    @DefaultMessage.setter\n    def DefaultMessage(self, Value: str) -> None: ...\n    @Text.setter\n    def Text(self, Value: str) -> None: ...\n    @TextBox.setter\n    def TextBox(self, WithEventsValue: TextBox) -> None: ...\n\n\nclass GH_InfoTextBoxEventArgs:\n    def __init__(self, control: GH_InfoTextBox): ...\n    @property\n    def Control(self) -> GH_InfoTextBox: ...\n    @property\n    def Text(self) -> str: ...\n    @property\n    def TextBox(self) -> TextBox: ...\n\n\nclass GH_InterfaceSettingsCategory(GH_SettingsCategory):\n    def __init__(self): ...\n    @property\n    def Description(self) -> str: ...\n\n\nclass GH_Interpolation:\n    #None = 0\n    NearestNeighbour = 1\n    Linear = 2\n    EaseIn = 3\n    EaseOut = 4\n    EaseInAndOut = 5\n\n\nclass GH_Interval2DPicker:\n    def __init__(self): ...\n    def add_IntervalChanged(self, obj: IntervalChangedEventHandler) -> None: ...\n    @property\n    def Interval(self) -> UVInterval: ...\n    def OnIntervalChanged(self) -> None: ...\n    def remove_IntervalChanged(self, obj: IntervalChangedEventHandler) -> None: ...\n    @Interval.setter\n    def Interval(self, Value: UVInterval) -> None: ...\n\n\nclass GH_KernelAssemblyCopyLocalWarning:\n    def __init__(self): ...\n\n\nclass GH_Label(GH_DoubleBufferedPanel):\n    def __init__(self): ...\n    @property\n    def Image(self) -> Image: ...\n    @property\n    def ImageAlign(self) -> ContentAlignment: ...\n    @property\n    def Text(self) -> str: ...\n    @property\n    def TextAlign(self) -> ContentAlignment: ...\n    @Image.setter\n    def Image(self, AutoPropertyValue: Image) -> None: ...\n    @ImageAlign.setter\n    def ImageAlign(self, AutoPropertyValue: ContentAlignment) -> None: ...\n    @Text.setter\n    def Text(self, AutoPropertyValue: str) -> None: ...\n    @TextAlign.setter\n    def TextAlign(self, AutoPropertyValue: ContentAlignment) -> None: ...\n\n\nclass GH_LexerComboEditor:\n    def __init__(self): ...\n    @property\n    def Lexers(self) -> List: ...\n    @Lexers.setter\n    def Lexers(self, Value: List) -> None: ...\n\n\nclass GH_LexerMaskEditor:\n    def __init__(self): ...\n\n\nclass GH_ListScroller:\n    def __init__(self): ...\n    def add_SelectedIndexChanged(self, obj: SelectedIndexChangedEventHandler) -> None: ...\n    def AddItem(self, sItem: str) -> None: ...\n    @property\n    def DebugItems(self) -> bool: ...\n    @property\n    def ItemHeight(self) -> int: ...\n    @property\n    def SelectedIndex(self) -> int: ...\n    @property\n    def WrapItems(self) -> bool: ...\n    def OnSelectedItemChanged(self, bIntermediate: bool) -> None: ...\n    def remove_SelectedIndexChanged(self, obj: SelectedIndexChangedEventHandler) -> None: ...\n    @DebugItems.setter\n    def DebugItems(self, Value: bool) -> None: ...\n    @ItemHeight.setter\n    def ItemHeight(self, Value: int) -> None: ...\n    @SelectedIndex.setter\n    def SelectedIndex(self, Value: int) -> None: ...\n    @WrapItems.setter\n    def WrapItems(self, Value: bool) -> None: ...\n\n\nclass GH_ListScrollerChangedEventArgs:\n    def __init__(self, nItem: str, nIndex: int, bIntermediate: bool): ...\n    @property\n    def Index(self) -> int: ...\n    @property\n    def Intermediate(self) -> bool: ...\n    @property\n    def Item(self) -> str: ...\n\n\nclass GH_LoadingError:\n    def __init__(self): ...\n    @property\n    def ErrorMessage(self) -> str: ...\n    @property\n    def ErrorTitle(self) -> str: ...\n    @property\n    def Folded(self) -> bool: ...\n    @ErrorMessage.setter\n    def ErrorMessage(self, Value: str) -> None: ...\n    @ErrorTitle.setter\n    def ErrorTitle(self, Value: str) -> None: ...\n    @Folded.setter\n    def Folded(self, Value: bool) -> None: ...\n\n\nclass GH_LoadingExceptionBrowser:\n    def __init__(self): ...\n    def LoadErrors(self, errors: List) -> None: ...\n\n\nclass GH_LoadProtectDialog:\n    def __init__(self): ...\n    def SetAssemblyName(self, name: str) -> None: ...\n\n\nclass GH_MarkerType:\n    DocumentObject = 0\n    RibbonTab = 1\n    RibbonIcon = 2\n\n\nclass GH_MarkovWidgetSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_MarkupAttributesDialog:\n    def __init__(self): ...\n    def add_AttributesAccepted(self, obj: AttributesAcceptedEventHandler) -> None: ...\n    def add_AttributesChanged(self, obj: AttributesChangedEventHandler) -> None: ...\n    def add_AttributesDenied(self, obj: AttributesDeniedEventHandler) -> None: ...\n    @property\n    def AcceptRegion(self) -> Rectangle: ...\n    @property\n    def CancelRegion(self) -> Rectangle: ...\n    @property\n    def ColourRegion(self) -> Rectangle: ...\n    @property\n    def DashRegion(self) -> Rectangle: ...\n    @property\n    def GripRegion(self) -> Rectangle: ...\n    @property\n    def ModifiedProperties(self) -> GH_MarkupProperties: ...\n    @property\n    def OriginalProperties(self) -> GH_MarkupProperties: ...\n    @property\n    def WidthRegion(self) -> Rectangle: ...\n    def ReadAttributes(self, iAtt: GH_MarkupAttributes) -> None: ...\n    def remove_AttributesAccepted(self, obj: AttributesAcceptedEventHandler) -> None: ...\n    def remove_AttributesChanged(self, obj: AttributesChangedEventHandler) -> None: ...\n    def remove_AttributesDenied(self, obj: AttributesDeniedEventHandler) -> None: ...\n    @ModifiedProperties.setter\n    def ModifiedProperties(self, AutoPropertyValue: GH_MarkupProperties) -> None: ...\n    @OriginalProperties.setter\n    def OriginalProperties(self, AutoPropertyValue: GH_MarkupProperties) -> None: ...\n    def UndoAttributes(self, iAtt: GH_MarkupAttributes) -> None: ...\n    def WriteAttributes(self, iAtt: GH_MarkupAttributes) -> None: ...\n\n\nclass GH_MaterialPreview:\n    def __init__(self): ...\n    @property\n    def Colour(self) -> Color: ...\n    @property\n    def Selected(self) -> bool: ...\n    def Image(self) -> Bitmap: ...\n    @Colour.setter\n    def Colour(self, Value: Color) -> None: ...\n    @Selected.setter\n    def Selected(self, Value: bool) -> None: ...\n    def Thumbnail(self, size: int) -> Bitmap: ...\n\n\nclass GH_MaterialPreviewControl:\n    def __init__(self): ...\n    def add_ColourChanged(self, obj: ColourChangedEventHandler) -> None: ...\n    def add_MaterialImagePostPaint(self, obj: MaterialImagePostPaintEventHandler) -> None: ...\n    def add_SelectedChanged(self, obj: SelectedChangedEventHandler) -> None: ...\n    @property\n    def Colour(self) -> Color: ...\n    @property\n    def Selected(self) -> bool: ...\n    @property\n    def SelectOnClick(self) -> bool: ...\n    def remove_ColourChanged(self, obj: ColourChangedEventHandler) -> None: ...\n    def remove_MaterialImagePostPaint(self, obj: MaterialImagePostPaintEventHandler) -> None: ...\n    def remove_SelectedChanged(self, obj: SelectedChangedEventHandler) -> None: ...\n    @Colour.setter\n    def Colour(self, Value: Color) -> None: ...\n    @Selected.setter\n    def Selected(self, Value: bool) -> None: ...\n    @SelectOnClick.setter\n    def SelectOnClick(self, Value: bool) -> None: ...\n\n\nclass GH_MDSliderDialog:\n    def __init__(self): ...\n    def LoadSettings(self, owner: GH_MultiDimensionalSlider) -> None: ...\n    def SaveSettings(self, owner: GH_MultiDimensionalSlider) -> None: ...\n\n\nclass GH_MenuCustomControl:\n    def __init__(self, dropdown: ToolStripDropDown, control: Control, lockFocus: bool, width: int): ...\n    def add_KeyDown(self, obj: KeyDownEventHandler) -> None: ...\n    def CloseEntireMenuStructure(self) -> None: ...\n    @property\n    def CancelItem(self) -> ToolStripMenuItem: ...\n    @property\n    def CommitItem(self) -> ToolStripMenuItem: ...\n    @property\n    def Control(self) -> Control: ...\n    def remove_KeyDown(self, obj: KeyDownEventHandler) -> None: ...\n\n\nclass GH_MenuShortcut:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, itemPath: str): ...\n    @overload\n    def __init__(self, itemPath: str, shortcut: Keys, shortcutText: str): ...\n    def ApplyToMenu(self, menu: MenuStrip, filter: Iterable[ToolStripMenuItem]) -> ToolStripMenuItem: ...\n    @property\n    def ItemHierarchy(self) -> Set(str): ...\n    @property\n    def ItemPath(self) -> str: ...\n    @property\n    def Shortcut(self) -> Keys: ...\n    @property\n    def ShortcutText(self) -> str: ...\n    def Read(self, reader: GH_IReader) -> bool: ...\n    @ItemPath.setter\n    def ItemPath(self, Value: str) -> None: ...\n    @Shortcut.setter\n    def Shortcut(self, Value: Keys) -> None: ...\n    @ShortcutText.setter\n    def ShortcutText(self, Value: str) -> None: ...\n    def Write(self, writer: GH_IWriter) -> bool: ...\n\n\nclass GH_MenuShortcutEventArgs:\n    def AppendItem(self, item: ToolStripMenuItem) -> None: ...\n    @property\n    def MainMenu(self) -> MenuStrip: ...\n    @property\n    def Owner(self) -> GH_DocumentEditor: ...\n\n\nclass GH_MenuShortcutSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_MenuShortCutWrapper:\n    def GenerateShortcutCommand(keyCode: Keys, menu: ToolStrip) -> bool: ...\n\n\nclass GH_MenuStrip:\n    def __init__(self): ...\n    @property\n    def ClickThrough(self) -> bool: ...\n    @ClickThrough.setter\n    def ClickThrough(self, Value: bool) -> None: ...\n\n\nclass GH_MenuTextBox:\n    def __init__(self, dropDown: ToolStripDropDown, text: str, lockFocus: bool): ...\n    def add_KeyDown(self, obj: KeyDownEventHandler) -> None: ...\n    def add_TextChanged(self, obj: TextChangedEventHandler) -> None: ...\n    def CloseEntireMenuStructure(self) -> None: ...\n    @property\n    def OriginalText(self) -> str: ...\n    @property\n    def Text(self) -> str: ...\n    @property\n    def TextBoxItem(self) -> ToolStripTextBox: ...\n    @property\n    def Width(self) -> int: ...\n    def remove_KeyDown(self, obj: KeyDownEventHandler) -> None: ...\n    def remove_TextChanged(self, obj: TextChangedEventHandler) -> None: ...\n    @OriginalText.setter\n    def OriginalText(self, AutoPropertyValue: str) -> None: ...\n    @Text.setter\n    def Text(self, Value: str) -> None: ...\n    @Width.setter\n    def Width(self, Value: int) -> None: ...\n\n\nclass GH_MeshingParameterDialog:\n    def __init__(self): ...\n    @property\n    def MeshingParameters(self) -> GH_MeshingParametersFrontEnd: ...\n    @MeshingParameters.setter\n    def MeshingParameters(self, WithEventsValue: GH_MeshingParametersFrontEnd) -> None: ...\n\n\nclass GH_MeshingParametersEventArgs:\n    def __init__(self, parameters: MeshingParameters): ...\n    @property\n    def MeshingParameters(self) -> MeshingParameters: ...\n\n\nclass GH_MeshingParametersFrontEnd:\n    def __init__(self): ...\n    def add_MeshingParametersChanged(self, obj: MeshingParametersChangedEventHandler) -> None: ...\n    @property\n    def Parameters(self) -> MeshingParameters: ...\n    def remove_MeshingParametersChanged(self, obj: MeshingParametersChangedEventHandler) -> None: ...\n    @Parameters.setter\n    def Parameters(self, Value: MeshingParameters) -> None: ...\n\n\nclass GH_MessageMustReadWindow:\n    def __init__(self): ...\n    @property\n    def Content(self) -> str: ...\n    @property\n    def Delay(self) -> int: ...\n    @property\n    def Title(self) -> str: ...\n    @Content.setter\n    def Content(self, Value: str) -> None: ...\n    @Delay.setter\n    def Delay(self, Value: int) -> None: ...\n    @Title.setter\n    def Title(self, Value: str) -> None: ...\n\n\nclass GH_MessagesWidgetSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_MouseTracker:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, initialPosition: Point): ...\n    @overload\n    def __init__(self, initialPosition: Point, tag: Object): ...\n    @overload\n    def Deviation(self) -> float: ...\n    @overload\n    def Deviation(self, t0: DateTime, t1: DateTime) -> float: ...\n    @overload\n    def DropFrames(self, deviation: float) -> None: ...\n    @overload\n    def DropFrames(self, timeLimit: DateTime) -> None: ...\n    @overload\n    def DropFrames(self, deviation: float, anchor: Point) -> None: ...\n    @property\n    def Duration(self) -> TimeSpan: ...\n    @property\n    def Frame(self, index: int) -> GH_TrackerFrame: ...\n    @property\n    def FrameCount(self) -> int: ...\n    @property\n    def MaximumDuration(self) -> TimeSpan: ...\n    @property\n    def MaximumFrameCount(self) -> int: ...\n    @property\n    def NewestFrame(self) -> GH_TrackerFrame: ...\n    @property\n    def OldestFrame(self) -> GH_TrackerFrame: ...\n    @property\n    def TemporalAccuracy(self) -> TimeSpan: ...\n    def LastFrameWithinDeviation(self, deviation: float) -> int: ...\n    @overload\n    def Record(self, position: Point) -> None: ...\n    @overload\n    def Record(self, position: Point, tag: Object) -> None: ...\n    @MaximumDuration.setter\n    def MaximumDuration(self, Value: TimeSpan) -> None: ...\n    @MaximumFrameCount.setter\n    def MaximumFrameCount(self, Value: int) -> None: ...\n    @TemporalAccuracy.setter\n    def TemporalAccuracy(self, Value: TimeSpan) -> None: ...\n    def ToString(self) -> str: ...\n\n\nclass GH_MRUSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_MultiDocSave:\n    def __init__(self): ...\n    def AddDocument(self, doc: GH_Document) -> None: ...\n\n\nclass GH_MultilineGooEditor:\n    def __init__(self): ...\n    @property\n    def Modified(self) -> bool: ...\n    @property\n    def ParsePaths(self) -> bool: ...\n    def GetDataTree(self) -> GH_Structure: ...\n    @Modified.setter\n    def Modified(self, Value: bool) -> None: ...\n    @ParsePaths.setter\n    def ParsePaths(self, Value: bool) -> None: ...\n    def SetDataTree(self, data: IGH_Structure) -> None: ...\n\n\nclass GH_MultiSaveDocumentEntry:\n    def __init__(self): ...\n    def add_DocumentSaved(self, obj: DocumentSavedEventHandler) -> None: ...\n    @property\n    def Document(self) -> GH_Document: ...\n    @property\n    def IsSaved(self) -> bool: ...\n    def remove_DocumentSaved(self, obj: DocumentSavedEventHandler) -> None: ...\n    @Document.setter\n    def Document(self, Value: GH_Document) -> None: ...\n\n\nclass GH_NamedViewMenuItem(GH_DoubleBufferedPanel):\n    def __init__(self): ...\n    @property\n    def ApplyRegion(self) -> Rectangle: ...\n    @property\n    def Canvas(self) -> GH_Canvas: ...\n    @property\n    def DeleteRegion(self) -> Rectangle: ...\n    @property\n    def Document(self) -> GH_Document: ...\n    @property\n    def LabelRegion(self) -> Rectangle: ...\n    @property\n    def View(self) -> GH_NamedView: ...\n    @Canvas.setter\n    def Canvas(self, Value: GH_Canvas) -> None: ...\n    @Document.setter\n    def Document(self, Value: GH_Document) -> None: ...\n    @View.setter\n    def View(self, Value: GH_NamedView) -> None: ...\n\n\nclass GH_NickNameTextBox:\n    def __init__(self): ...\n    def add_IconModeChanged(self, obj: IconModeChangedEventHandler) -> None: ...\n    def add_NickNameChangeAccepted(self, obj: NickNameChangeAcceptedEventHandler) -> None: ...\n    def add_NickNameChangeCancelled(self, obj: NickNameChangeCancelledEventHandler) -> None: ...\n    def add_NickNameChanged(self, obj: NickNameChangedEventHandler) -> None: ...\n    @property\n    def NewIconMode(self) -> GH_IconDisplayMode: ...\n    @property\n    def NewNickName(self) -> str: ...\n    @property\n    def OldIconMode(self) -> GH_IconDisplayMode: ...\n    @property\n    def OldNickName(self) -> str: ...\n    def remove_IconModeChanged(self, obj: IconModeChangedEventHandler) -> None: ...\n    def remove_NickNameChangeAccepted(self, obj: NickNameChangeAcceptedEventHandler) -> None: ...\n    def remove_NickNameChangeCancelled(self, obj: NickNameChangeCancelledEventHandler) -> None: ...\n    def remove_NickNameChanged(self, obj: NickNameChangedEventHandler) -> None: ...\n    @OldIconMode.setter\n    def OldIconMode(self, Value: GH_IconDisplayMode) -> None: ...\n    @OldNickName.setter\n    def OldNickName(self, Value: str) -> None: ...\n\n\nclass GH_NumberPresets:\n    def __init__(self): ...\n    @overload\n    def AddPreset(self, name: str, value: float) -> None: ...\n    @overload\n    def AddPreset(self, name: str, value: Decimal) -> None: ...\n    @overload\n    def AddPreset(self, name: str, value: float, description: str) -> None: ...\n    @overload\n    def AddPreset(self, name: str, value: Decimal, description: str) -> None: ...\n    @property\n    def Count(self) -> int: ...\n    @overload\n    def PopulateMenu(self, menu: ToolStrip, current: Decimal, clickDelegate: EventHandler) -> None: ...\n    @overload\n    def PopulateMenu(self, menu: ToolStrip, current: Decimal, format: str, clickDelegate: EventHandler) -> None: ...\n    def PresetDescription(self, index: int) -> str: ...\n    def PresetName(self, index: int) -> str: ...\n    def PresetValue(self, index: int) -> Decimal: ...\n\n\nclass GH_NumberSliderPopup:\n    def __init__(self): ...\n    def Setup(self, owner: GH_NumberSlider) -> None: ...\n\n\nclass GH_NumberSliderSnappingEditor:\n    def __init__(self): ...\n    @property\n    def SnapLines(self) -> List: ...\n\n\nclass GH_NumericScrollerValueEditor:\n    def __init__(self): ...\n    def add_OnLimitsChanged(self, obj: OnLimitsChangedEventHandler) -> None: ...\n    def add_OnValueChanged(self, obj: OnValueChangedEventHandler) -> None: ...\n    @property\n    def LowerLimit(self) -> Decimal: ...\n    @property\n    def OriginalLowerLimit(self) -> Decimal: ...\n    @property\n    def OriginalUpperLimit(self) -> Decimal: ...\n    @property\n    def OriginalValue(self) -> Decimal: ...\n    @property\n    def tblLayout(self) -> TableLayoutPanel: ...\n    @property\n    def UpperLimit(self) -> Decimal: ...\n    @property\n    def Value(self) -> Decimal: ...\n    def PrepareForCancel(self) -> None: ...\n    def PrepareForCommit(self) -> None: ...\n    def remove_OnLimitsChanged(self, obj: OnLimitsChangedEventHandler) -> None: ...\n    def remove_OnValueChanged(self, obj: OnValueChangedEventHandler) -> None: ...\n    @tblLayout.setter\n    def tblLayout(self, WithEventsValue: TableLayoutPanel) -> None: ...\n    def SetupValues(self, lower: Decimal, upper: Decimal, value: Decimal, decimals: int) -> None: ...\n\n\nclass GH_NumericTextBox:\n    def __init__(self): ...\n    def add_OnScrollEnd(self, obj: OnScrollEndEventHandler) -> None: ...\n    def add_OnScrollStart(self, obj: OnScrollStartEventHandler) -> None: ...\n    def add_ValueChanged(self, obj: ValueChangedEventHandler) -> None: ...\n    @property\n    def Decimals(self) -> int: ...\n    @property\n    def InScrollMode(self) -> bool: ...\n    @property\n    def LowerLimit(self) -> float: ...\n    @property\n    def Prefix(self) -> str: ...\n    @property\n    def PreScrollValue(self) -> float: ...\n    @property\n    def ScrollDamping(self) -> int: ...\n    @property\n    def ScrollIncrement(self) -> float: ...\n    @property\n    def ScrollingHasBegun(self) -> bool: ...\n    @property\n    def ScrollingUpwards(self) -> bool: ...\n    @property\n    def ScrollMethod(self) -> GH_Scroll_Method: ...\n    @property\n    def ScrollMouseRelation(self) -> GH_ScrollMouseRelation: ...\n    @property\n    def ScrollWidth(self) -> int: ...\n    @property\n    def Suffix(self) -> str: ...\n    @property\n    def UpperLimit(self) -> float: ...\n    @property\n    def Value(self) -> float: ...\n    def OnValueChanged(self, newvalue: float, oldvalue: float, final: bool) -> None: ...\n    def PrepareForCancel(self) -> None: ...\n    def PrepareForCommit(self) -> None: ...\n    def RefreshScrollPanel(self) -> None: ...\n    def remove_OnScrollEnd(self, obj: OnScrollEndEventHandler) -> None: ...\n    def remove_OnScrollStart(self, obj: OnScrollStartEventHandler) -> None: ...\n    def remove_ValueChanged(self, obj: ValueChangedEventHandler) -> None: ...\n    @Decimals.setter\n    def Decimals(self, val: int) -> None: ...\n    @LowerLimit.setter\n    def LowerLimit(self, val: float) -> None: ...\n    @Prefix.setter\n    def Prefix(self, Value: str) -> None: ...\n    def Set(self, l_limit: float, u_limit: float, v_value: float) -> None: ...\n    @ScrollDamping.setter\n    def ScrollDamping(self, Value: int) -> None: ...\n    @ScrollIncrement.setter\n    def ScrollIncrement(self, val: float) -> None: ...\n    @ScrollMethod.setter\n    def ScrollMethod(self, val: GH_Scroll_Method) -> None: ...\n    @ScrollMouseRelation.setter\n    def ScrollMouseRelation(self, Value: GH_ScrollMouseRelation) -> None: ...\n    @ScrollWidth.setter\n    def ScrollWidth(self, val: int) -> None: ...\n    @Suffix.setter\n    def Suffix(self, Value: str) -> None: ...\n    @UpperLimit.setter\n    def UpperLimit(self, val: float) -> None: ...\n    @Value.setter\n    def Value(self, val: float) -> None: ...\n    def SetDefault(self, num: float) -> None: ...\n\n\nclass GH_ObjectExceptionDialog:\n    def __init__(self): ...\n\n\nclass GH_PageCurl:\n    def __init__(self, anchor: Point, tip: Point): ...\n    @property\n    def BackgroundPath(self) -> GraphicsPath: ...\n    @property\n    def BackgroundShadowBrush(self) -> Brush: ...\n    @property\n    def BackgroundShadowPath(self) -> GraphicsPath: ...\n    @property\n    def CurlBrush(self) -> Brush: ...\n    @property\n    def CurlEdge(self) -> GraphicsPath: ...\n    @property\n    def CurlInterior(self) -> GraphicsPath: ...\n    @property\n    def CurlPath(self) -> GraphicsPath: ...\n    @property\n    def CurlShadowBrush(self) -> Brush: ...\n    @property\n    def CurlShadowPath(self) -> GraphicsPath: ...\n    @property\n    def CurlTip(self) -> PointF: ...\n    def RenderTopology(self, g: Graphics) -> None: ...\n\n\nclass GH_PaintDelegate:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, control: Control, e: PaintEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, control: Control, e: PaintEventArgs) -> None: ...\n\n\nclass GH_PaletteSettingsCategory(GH_SettingsCategory):\n    def __init__(self): ...\n    @property\n    def Description(self) -> str: ...\n\n\nclass GH_PanelEditor:\n    def __init__(self): ...\n\n\nclass GH_PanelEditorControl:\n    def __init__(self): ...\n    @property\n    def PanelContent(self) -> str: ...\n    @property\n    def PanelProperties(self) -> GH_PanelProperties: ...\n    def PickNewFont(self) -> None: ...\n    @PanelContent.setter\n    def PanelContent(self, Value: str) -> None: ...\n    @PanelProperties.setter\n    def PanelProperties(self, Value: GH_PanelProperties) -> None: ...\n\n\nclass GH_ParamViewerForm:\n    def __init__(self): ...\n    @property\n    def AutoUpdateOnPick(self) -> bool: ...\n    @property\n    def Canvas(self) -> GH_Canvas: ...\n    @AutoUpdateOnPick.setter\n    def AutoUpdateOnPick(self, Value: bool) -> None: ...\n    @Canvas.setter\n    def Canvas(self, Value: GH_Canvas) -> None: ...\n\n\nclass GH_ParseAssemblyProgressDialog:\n    def __init__(self): ...\n    def SetMaxSteps(self, Steps: int) -> None: ...\n    def SetStep(self, Text: str) -> None: ...\n\n\nclass GH_ParserFunctionViewer:\n    def __init__(self): ...\n\n\nclass GH_PasswordBox:\n    def __init__(self): ...\n    def add_ValidPasswordEntered(self, obj: ValidPasswordEnteredEventHandler) -> None: ...\n    @property\n    def Key(self) -> Set(Byte): ...\n    @property\n    def Password(self) -> str: ...\n    def remove_ValidPasswordEntered(self, obj: ValidPasswordEnteredEventHandler) -> None: ...\n    @Key.setter\n    def Key(self, Value: Set(Byte)) -> None: ...\n    @Password.setter\n    def Password(self, Value: str) -> None: ...\n\n\nclass GH_PersistentDataEditor:\n    def __init__(self): ...\n    def GetData(self) -> GH_Structure: ...\n    def SetData(self, data: GH_Structure, typeInstance: IGH_Goo) -> None: ...\n\n\nclass GH_PingMessageWindow:\n    def __init__(self): ...\n    @property\n    def Expire(self) -> DateTime: ...\n    @property\n    def Message(self) -> str: ...\n    @Expire.setter\n    def Expire(self, Value: DateTime) -> None: ...\n    @Message.setter\n    def Message(self, Value: str) -> None: ...\n\n\nclass GH_PointCurveParamEditor:\n    def __init__(self): ...\n    def LoadPoint(self, pt: GH_Point) -> None: ...\n    def SetDataToPoint(self) -> None: ...\n\n\nclass GH_PreviewExpression:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, nExpression: str, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, nExpression: str) -> None: ...\n\n\nclass GH_PreviewPreset:\n    def __init__(self): ...\n    def add_SelectedChanged(self, obj: SelectedChangedEventHandler) -> None: ...\n    @property\n    def Colour(self) -> Color: ...\n    @property\n    def Selected(self) -> bool: ...\n    def remove_SelectedChanged(self, obj: SelectedChangedEventHandler) -> None: ...\n    @Colour.setter\n    def Colour(self, Value: Color) -> None: ...\n    @Selected.setter\n    def Selected(self, Value: bool) -> None: ...\n\n\nclass GH_PreviewSettingsChangedEventArgs:\n    def __init__(self, colNormal: Color, colSelected: Color): ...\n    @property\n    def NormalColour(self) -> Color: ...\n    @property\n    def SelectedColour(self) -> Color: ...\n\n\nclass GH_ProfilerWidgetSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_ProgressBar:\n    def __init__(self): ...\n    @property\n    def CurrentStep(self) -> int: ...\n    @property\n    def DrawPercentage(self) -> bool: ...\n    @property\n    def DrawSteps(self) -> bool: ...\n    @property\n    def Message(self) -> str: ...\n    @property\n    def Progress(self) -> float: ...\n    @DrawPercentage.setter\n    def DrawPercentage(self, Value: bool) -> None: ...\n    @DrawSteps.setter\n    def DrawSteps(self, Value: bool) -> None: ...\n    @Message.setter\n    def Message(self, Value: str) -> None: ...\n    @Progress.setter\n    def Progress(self, Value: float) -> None: ...\n    def SetMaxSteps(self, S: int) -> None: ...\n    @overload\n    def SetStep(self, N: int) -> None: ...\n    @overload\n    def SetStep(self, N: int, sText: str) -> None: ...\n\n\nclass GH_PruderyFilter:\n    #None = 0\n    Low = 1\n    Medium = 2\n    High = 3\n    Total = 4\n    Unset = -1\n\n\nclass GH_PruderySettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_QuickImageEditor:\n    def __init__(self): ...\n    @property\n    def CanvasImage(self) -> Bitmap: ...\n    @property\n    def FrameCrop(self) -> Rectangle: ...\n    @property\n    def FrameFocus(self) -> Rectangle3d: ...\n    @property\n    def FrameViewport(self) -> Rectangle3d: ...\n    @property\n    def ViewportImage(self) -> Bitmap: ...\n    @property\n    def ViewportName(self) -> str: ...\n    @CanvasImage.setter\n    def CanvasImage(self, AutoPropertyValue: Bitmap) -> None: ...\n    @FrameCrop.setter\n    def FrameCrop(self, AutoPropertyValue: Rectangle) -> None: ...\n    @FrameFocus.setter\n    def FrameFocus(self, AutoPropertyValue: Rectangle3d) -> None: ...\n    @FrameViewport.setter\n    def FrameViewport(self, AutoPropertyValue: Rectangle3d) -> None: ...\n    @ViewportImage.setter\n    def ViewportImage(self, AutoPropertyValue: Bitmap) -> None: ...\n    @ViewportName.setter\n    def ViewportName(self, AutoPropertyValue: str) -> None: ...\n\n\nclass GH_RemoteSliderControl:\n    def __init__(self): ...\n    def IsTarget(self, iObject: IGH_DocumentObject) -> bool: ...\n    def RegisterTarget(self, iSlider: GH_NumberSlider) -> None: ...\n    def UnregisterTarget(self) -> None: ...\n\n\nclass GH_RemoteSwitchControl:\n    def __init__(self): ...\n    def IsTarget(self, iObject: IGH_DocumentObject) -> bool: ...\n    def RegisterTarget(self, iSwitch: GH_BooleanSwitch_Obsolete) -> None: ...\n    def UnregisterTarget(self) -> None: ...\n\n\nclass GH_RevisionEditor:\n    def __init__(self): ...\n\n\nclass GH_RhAttributesEditor:\n    def __init__(self): ...\n    def GetAttributes(self) -> ObjectAttributes: ...\n    def SetDefaultAttributes(self) -> None: ...\n\n\nclass GH_RibbonLayoutEditor(GH_DoubleBufferedPanel):\n    def __init__(self): ...\n    def add_UndoRedoChanged(self, obj: UndoRedoChangedEventHandler) -> None: ...\n    def ClearUndo(self) -> None: ...\n    @property\n    def RedoCount(self) -> int: ...\n    @property\n    def RibbonLayout(self) -> GH_Layout: ...\n    @property\n    def UndoCount(self) -> int: ...\n    def RecordUndo(self) -> None: ...\n    def Redo(self) -> None: ...\n    def remove_UndoRedoChanged(self, obj: UndoRedoChangedEventHandler) -> None: ...\n    @RibbonLayout.setter\n    def RibbonLayout(self, Value: GH_Layout) -> None: ...\n    def Undo(self) -> None: ...\n\n\nclass GH_RibbonLayoutEditorDialog:\n    def __init__(self): ...\n\n\nclass GH_RibbonLayoutEditorUndoRedoEventArgs:\n    def __init__(self, owner: GH_RibbonLayoutEditor): ...\n    @property\n    def Editor(self) -> GH_RibbonLayoutEditor: ...\n    @property\n    def RedoCount(self) -> int: ...\n    @property\n    def UndoCount(self) -> int: ...\n\n\nclass GH_RibbonSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_RotationalFrame:\n    @property\n    def Angle(self) -> float: ...\n    @property\n    def Pivot(self) -> PointF: ...\n    @property\n    def Point(self) -> PointF: ...\n    @property\n    def Time(self) -> DateTime: ...\n    @Angle.setter\n    def Angle(self, AutoPropertyValue: float) -> None: ...\n    @Pivot.setter\n    def Pivot(self, AutoPropertyValue: PointF) -> None: ...\n    @Point.setter\n    def Point(self, AutoPropertyValue: PointF) -> None: ...\n    @Time.setter\n    def Time(self, AutoPropertyValue: DateTime) -> None: ...\n\n\n\n\nclass GH_SamplingSphere:\n    def __init__(self, size: int): ...\n    @property\n    def SampleCount(self) -> int: ...\n    @property\n    def Size(self) -> int: ...\n    @overload\n    def SampleSphere(self, sphere: Sphere) -> Point2d[,]: ...\n    @overload\n    def SampleSphere(self, sphere: Sphere, texture: GH_MemoryBitmap) -> Bitmap: ...\n\n\nclass GH_ScribblePropertiesDialog:\n    def __init__(self): ...\n    def GetUserFont(self) -> Font: ...\n    def SetUserFont(self, f: Font) -> None: ...\n\n\nclass GH_Scroll_Method:\n    none = 0\n    linear = 1\n    exponential = 2\n\n\nclass GH_ScrollMouseRelation:\n    #None = 0\n    Top = 1\n    Bottom = 2\n    Both = 3\n\n\nclass GH_SeparatorDisplay:\n    #None = 0\n    Etched = 1\n    EtchedFading = 2\n    Dashed = 3\n\n\nclass GH_SettingsCategory:\n    @property\n    def Description(self) -> str: ...\n    @property\n    def Icon(self) -> Bitmap: ...\n    @property\n    def Name(self) -> str: ...\n    @property\n    def Parent(self) -> str: ...\n\n\nclass GH_SettingsGUI:\n    def __init__(self): ...\n\n\nclass GH_SettingsServerBrowser:\n    def __init__(self): ...\n    @property\n    def Server(self) -> GH_SettingsServer: ...\n    @Server.setter\n    def Server(self, Value: GH_SettingsServer) -> None: ...\n\n\nclass GH_Slider(GH_TextInputBaseControl):\n    def __init__(self): ...\n    def add_ValueChanged(self, obj: ValueChangedEventHandler) -> None: ...\n    @property\n    def ControlEdgeColour(self) -> Color: ...\n    @property\n    def ControlShadowColour(self) -> Color: ...\n    @property\n    def DecimalPlaces(self) -> int: ...\n    @property\n    def DrawControlBorder(self) -> bool: ...\n    @property\n    def DrawControlShadows(self) -> bool: ...\n    @property\n    def FormatMask(self) -> str: ...\n    @property\n    def GripBottomColour(self) -> Color: ...\n    @property\n    def GripDisplay(self) -> GH_SliderGripDisplay: ...\n    @property\n    def GripEdgeColour(self) -> Color: ...\n    @property\n    def GripTopColour(self) -> Color: ...\n    @property\n    def InternalSlider(self) -> GH_SliderBase: ...\n    @property\n    def Maximum(self) -> Decimal: ...\n    @property\n    def Minimum(self) -> Decimal: ...\n    @property\n    def RailBrightColour(self) -> Color: ...\n    @property\n    def RailDarkColour(self) -> Color: ...\n    @property\n    def RailDisplay(self) -> GH_SliderRailDisplay: ...\n    @property\n    def RailEmptyColour(self) -> Color: ...\n    @property\n    def RailFullColour(self) -> Color: ...\n    @property\n    def ShadowSize(self) -> Padding: ...\n    @property\n    def TextColour(self) -> Color: ...\n    @property\n    def TickCount(self) -> int: ...\n    @property\n    def TickDisplay(self) -> GH_SliderTickDisplay: ...\n    @property\n    def TickFrequency(self) -> int: ...\n    @property\n    def Type(self) -> GH_SliderAccuracy: ...\n    @property\n    def Value(self) -> Decimal: ...\n    def remove_ValueChanged(self, obj: ValueChangedEventHandler) -> None: ...\n    @ControlEdgeColour.setter\n    def ControlEdgeColour(self, Value: Color) -> None: ...\n    @ControlShadowColour.setter\n    def ControlShadowColour(self, Value: Color) -> None: ...\n    @DecimalPlaces.setter\n    def DecimalPlaces(self, Value: int) -> None: ...\n    @DrawControlBorder.setter\n    def DrawControlBorder(self, Value: bool) -> None: ...\n    @DrawControlShadows.setter\n    def DrawControlShadows(self, Value: bool) -> None: ...\n    @FormatMask.setter\n    def FormatMask(self, Value: str) -> None: ...\n    @GripBottomColour.setter\n    def GripBottomColour(self, Value: Color) -> None: ...\n    @GripDisplay.setter\n    def GripDisplay(self, Value: GH_SliderGripDisplay) -> None: ...\n    @GripEdgeColour.setter\n    def GripEdgeColour(self, Value: Color) -> None: ...\n    @GripTopColour.setter\n    def GripTopColour(self, Value: Color) -> None: ...\n    @Maximum.setter\n    def Maximum(self, Value: Decimal) -> None: ...\n    @Minimum.setter\n    def Minimum(self, Value: Decimal) -> None: ...\n    @RailBrightColour.setter\n    def RailBrightColour(self, Value: Color) -> None: ...\n    @RailDarkColour.setter\n    def RailDarkColour(self, Value: Color) -> None: ...\n    @RailDisplay.setter\n    def RailDisplay(self, Value: GH_SliderRailDisplay) -> None: ...\n    @RailEmptyColour.setter\n    def RailEmptyColour(self, Value: Color) -> None: ...\n    @RailFullColour.setter\n    def RailFullColour(self, Value: Color) -> None: ...\n    @ShadowSize.setter\n    def ShadowSize(self, Value: Padding) -> None: ...\n    @TextColour.setter\n    def TextColour(self, Value: Color) -> None: ...\n    @TickCount.setter\n    def TickCount(self, Value: int) -> None: ...\n    @TickDisplay.setter\n    def TickDisplay(self, Value: GH_SliderTickDisplay) -> None: ...\n    @TickFrequency.setter\n    def TickFrequency(self, Value: int) -> None: ...\n    @Type.setter\n    def Type(self, Value: GH_SliderAccuracy) -> None: ...\n    @Value.setter\n    def Value(self, Value: Decimal) -> None: ...\n\n\nclass GH_Slider_Obsolete:\n    def __init__(self): ...\n    def add_ValueChanged(self, obj: ValueChangedEventHandler) -> None: ...\n    @property\n    def DisplayFormat(self) -> str: ...\n    @property\n    def DrawRail(self) -> bool: ...\n    @property\n    def GripBackColor(self) -> Color: ...\n    @property\n    def GripForeColor(self) -> Color: ...\n    @property\n    def IsIntermediate(self) -> bool: ...\n    @property\n    def Max(self) -> float: ...\n    @property\n    def Min(self) -> float: ...\n    @property\n    def NumericFormat(self) -> str: ...\n    @property\n    def TextInputMode(self) -> GH_SliderInputMode: ...\n    @property\n    def TickFrequency(self) -> int: ...\n    @property\n    def Value(self) -> float: ...\n    @property\n    def ValueF(self) -> Single: ...\n    def OnValueChanged(self) -> None: ...\n    def remove_ValueChanged(self, obj: ValueChangedEventHandler) -> None: ...\n    def SendMessage(hWnd: IntPtr, msg: int, wParam: int, lParam: IntPtr) -> IntPtr: ...\n    @DisplayFormat.setter\n    def DisplayFormat(self, Value: str) -> None: ...\n    @DrawRail.setter\n    def DrawRail(self, Value: bool) -> None: ...\n    @GripBackColor.setter\n    def GripBackColor(self, Value: Color) -> None: ...\n    @GripForeColor.setter\n    def GripForeColor(self, Value: Color) -> None: ...\n    @Max.setter\n    def Max(self, Value: float) -> None: ...\n    @Min.setter\n    def Min(self, Value: float) -> None: ...\n    @NumericFormat.setter\n    def NumericFormat(self, Value: str) -> None: ...\n    @TextInputMode.setter\n    def TextInputMode(self, Value: GH_SliderInputMode) -> None: ...\n    @TickFrequency.setter\n    def TickFrequency(self, Value: int) -> None: ...\n    @Value.setter\n    def Value(self, Value: float) -> None: ...\n    @ValueF.setter\n    def ValueF(self, Value: Single) -> None: ...\n\n\nclass GH_SliderAnimationSetup:\n    def __init__(self): ...\n    def CreatePreview(self) -> None: ...\n    def FindViewport(self, view: str) -> RhinoViewport: ...\n    def RegisterAnimator(self, nAnimator: GH_SliderAnimator) -> None: ...\n    def RhinoViews(self) -> List: ...\n\n\nclass GH_SliderInputMode:\n    #None = 0\n    OnKeyDown = 1\n    OnDoubleClick = 2\n    All = 3\n\n\nclass GH_SolverSettingsCategory(GH_SettingsCategory):\n    def __init__(self): ...\n    @property\n    def Description(self) -> str: ...\n\n\nclass GH_SolverSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_SourceCodeBlock:\n    def __init__(self, i0: int, i1: int, b_readonly: bool): ...\n    @property\n    def End(self) -> int: ...\n    @property\n    def LineCount(self) -> int: ...\n    @property\n    def Readonly(self) -> bool: ...\n    @property\n    def Start(self) -> int: ...\n    def Grow(self, line_index: int) -> None: ...\n\n\nclass GH_SourceCodeEditor:\n    def __init__(self): ...\n    @overload\n    def AppendLine(self, line: GH_SourceCodeLine) -> None: ...\n    @overload\n    def AppendLine(self, line: str, readonly: bool) -> None: ...\n    @overload\n    def AppendLines(self, lines: Iterable[GH_SourceCodeLine]) -> None: ...\n    @overload\n    def AppendLines(self, block: str, readonly: bool) -> None: ...\n    def Clear(self) -> None: ...\n    def CollapseAll(self, line_index: int) -> None: ...\n    def CreateManagedEditor(id: Guid) -> GH_SourceCodeEditor: ...\n    def DestroyManagedEditor(id: Guid) -> bool: ...\n    @property\n    def CustomPanel(self) -> Panel: ...\n    @property\n    def ManagedID(self) -> Guid: ...\n    @property\n    def SC_Lines(self) -> GH_SourceCodeLines: ...\n    def GetManagedEditor(id: Guid) -> GH_SourceCodeEditor: ...\n    def IsManagedEditor(id: Guid) -> bool: ...\n    def RegisterDefaultAssemblies(self) -> None: ...\n    def RegisterDefaultGrasshopperNameSpaces(self) -> None: ...\n    def RegisterDefaultRhinoCommonNameSpaces(self) -> None: ...\n    def RegisterDefaultSystemNameSpaces(self) -> None: ...\n\n\nclass GH_SourceCodeLine:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, n_text: str): ...\n    @overload\n    def __init__(self, n_text: str, b_readonly: bool): ...\n\n\nclass GH_SourceCodeLines:\n    def __init__(self): ...\n    @overload\n    def Add(self, text: str, readonly: bool) -> None: ...\n    def FindNthBlock(self, N: int, b_include_readonly: bool, b_include_editable: bool) -> GH_SourceCodeBlock: ...\n    @property\n    def Blocks(self) -> List: ...\n    def GetLines(self, block: GH_SourceCodeBlock) -> List: ...\n    def StringSplit(delim: str, stream: str) -> List: ...\n\n\nclass GH_Splitter:\n    def __init__(self): ...\n    def AdjustNeighbour(self) -> None: ...\n    def FindNeighbour(self) -> None: ...\n    @property\n    def MaxSize(self) -> int: ...\n    @property\n    def MinSize(self) -> int: ...\n    @property\n    def Neighbour(self) -> str: ...\n    @MaxSize.setter\n    def MaxSize(self, Value: int) -> None: ...\n    @MinSize.setter\n    def MinSize(self, Value: int) -> None: ...\n\n\nclass GH_StandardIcons:\n    @property\n    def BlankObjectIcon_24x24() -> Bitmap: ...\n    @property\n    def BlankParameterIcon_24x24() -> Bitmap: ...\n    @property\n    def ClusterIcon_24x24() -> Bitmap: ...\n    @property\n    def FileIconDll_32x32() -> Bitmap: ...\n    @property\n    def FileIconExe_32x32() -> Bitmap: ...\n    @property\n    def FileIconGH_32x36() -> Bitmap: ...\n    @property\n    def FileIconGha_32x32() -> Bitmap: ...\n    @property\n    def FileIconGHMissing_32x36() -> Bitmap: ...\n    @property\n    def FileIconGHX_32x36() -> Bitmap: ...\n    @property\n    def FileIconGHXMissing_32x36() -> Bitmap: ...\n    @property\n    def FileIconRhp_32x32() -> Bitmap: ...\n    @property\n    def FlattenIcon_24x24() -> Bitmap: ...\n    @property\n    def GraftIcon_24x24() -> Bitmap: ...\n    @property\n    def GroupIcon_24x24() -> Bitmap: ...\n    @property\n    def UnknownObjectIcon_24x24() -> Bitmap: ...\n    @property\n    def UserObjectIcon_24x24() -> Bitmap: ...\n\n\nclass GH_StateObjectFrontEnd:\n    def __init__(self): ...\n    @property\n    def Include(self) -> bool: ...\n    @property\n    def Selected(self) -> bool: ...\n    @property\n    def Target(self) -> IGH_DocumentObject: ...\n    @Include.setter\n    def Include(self, Value: bool) -> None: ...\n    def SetupObject(self, obj: IGH_DocumentObject) -> None: ...\n\n\nclass GH_TemplatePathSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_TextInputBaseControl:\n    def __init__(self): ...\n    @property\n    def IsTextInputActive(self) -> bool: ...\n    @property\n    def ShowTextInputOnDoubleClick(self) -> bool: ...\n    @property\n    def ShowTextInputOnKeyDown(self) -> bool: ...\n    @ShowTextInputOnDoubleClick.setter\n    def ShowTextInputOnDoubleClick(self, Value: bool) -> None: ...\n    @ShowTextInputOnKeyDown.setter\n    def ShowTextInputOnKeyDown(self, Value: bool) -> None: ...\n\n\nclass GH_TextRenderingConstants:\n    @property\n    def CenterCenter() -> StringFormat: ...\n    @property\n    def FarCenter() -> StringFormat: ...\n    @property\n    def GH_CrispText() -> TextRenderingHint: ...\n    @property\n    def GH_SmoothText() -> TextRenderingHint: ...\n    @property\n    def NearCenter() -> StringFormat: ...\n    def StringFormat(horizontalAlignment: StringAlignment, verticalAlignment: StringAlignment) -> StringFormat: ...\n\n\nclass GH_Toolstrip:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, items: Set(ToolStripItem)): ...\n    @property\n    def ClickThrough(self) -> bool: ...\n    @ClickThrough.setter\n    def ClickThrough(self, Value: bool) -> None: ...\n\n\nclass GH_ToolstripItemKeyHandlerResult:\n    Ignored = 0\n    CloseMenu = 1\n    MaintainMenu = 2\n\n\nclass GH_Tooltip:\n    def Adjust() -> None: ...\n    def AssignTooltipFields(title: str, text: str, description: str, icon: Image, diagram: Image) -> None: ...\n    def Clear() -> None: ...\n    @property\n    def Tag() -> Object: ...\n    @property\n    def TooltipForm() -> GH_ToolTipForm: ...\n    def IsOwner(test: Control) -> bool: ...\n    def IsTag(test: Object) -> bool: ...\n    def Layout() -> None: ...\n    @Tag.setter\n    def Tag(Value: Object) -> None: ...\n    def Show(owner: Control) -> None: ...\n    def TooltipDetailedInformation() -> str: ...\n\n\nclass GH_TooltipComponent:\n    def __init__(self): ...\n    def add_PopulateTooltip(self, obj: PopulateTooltipEventHandler) -> None: ...\n    @property\n    def Delay(self) -> int: ...\n    @property\n    def Enabled(self) -> bool: ...\n    @property\n    def Tag(self) -> Object: ...\n    @property\n    def Target(self) -> Control: ...\n    def Hide(self) -> None: ...\n    def IsTag(self, object: Object) -> bool: ...\n    def remove_PopulateTooltip(self, obj: PopulateTooltipEventHandler) -> None: ...\n    @Delay.setter\n    def Delay(self, Value: int) -> None: ...\n    @Enabled.setter\n    def Enabled(self, Value: bool) -> None: ...\n    @Tag.setter\n    def Tag(self, Value: Object) -> None: ...\n    @Target.setter\n    def Target(self, Value: Control) -> None: ...\n\n\nclass GH_TooltipDisplayEventArgs:\n    @property\n    def Control(self) -> Control: ...\n    @property\n    def Description(self) -> str: ...\n    @property\n    def Diagram(self) -> Bitmap: ...\n    @property\n    def Icon(self) -> Bitmap: ...\n    @property\n    def Point(self) -> Point: ...\n    @property\n    def Region(self) -> Rectangle: ...\n    @property\n    def Text(self) -> str: ...\n    @property\n    def Title(self) -> str: ...\n    @property\n    def Valid(self) -> bool: ...\n    @Description.setter\n    def Description(self, Value: str) -> None: ...\n    @Diagram.setter\n    def Diagram(self, Value: Bitmap) -> None: ...\n    @Icon.setter\n    def Icon(self, Value: Bitmap) -> None: ...\n    @Region.setter\n    def Region(self, Value: Rectangle) -> None: ...\n    @Text.setter\n    def Text(self, Value: str) -> None: ...\n    @Title.setter\n    def Title(self, Value: str) -> None: ...\n\n\nclass GH_ToolTipForm:\n    def __init__(self): ...\n    @property\n    def DefaultBlockWidth() -> int: ...\n    @property\n    def DefaultTooltipWidth() -> int: ...\n    @property\n    def TT_Description(self) -> str: ...\n    @property\n    def TT_Palette(self) -> GH_TooltipPalette: ...\n    @property\n    def TT_Text(self) -> str: ...\n    @property\n    def TT_Title(self) -> str: ...\n    @TT_Description.setter\n    def TT_Description(self, Value: str) -> None: ...\n    @TT_Diagram.setter\n    def TT_Diagram(self, Value: Image) -> None: ...\n    @TT_Icon.setter\n    def TT_Icon(self, Value: Image) -> None: ...\n    @TT_Palette.setter\n    def TT_Palette(self, Value: GH_TooltipPalette) -> None: ...\n    @TT_Text.setter\n    def TT_Text(self, Value: str) -> None: ...\n    @TT_Title.setter\n    def TT_Title(self, Value: str) -> None: ...\n\n\nclass GH_TooltipPalette:\n    White = 0\n    Black = 1\n    Grey = 2\n    Yellow = 3\n    Orange = 4\n    Red = 5\n    Green = 6\n    Blue = 7\n\n\nclass GH_TooltipWiggleSettingsUI:\n    def __init__(self): ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass GH_TrackerFrame:\n    def __init__(self, position: Point): ...\n\n\nclass GH_UndoRecordBrowser:\n    def __init__(self): ...\n    def LoadUndoRecords(self, server: GH_UndoServer) -> None: ...\n\n\nclass GH_UndoServerBrowser:\n    def __init__(self): ...\n    @property\n    def Canvas(self) -> GH_Canvas: ...\n    @Canvas.setter\n    def Canvas(self, Value: GH_Canvas) -> None: ...\n\n\nclass GH_UnrecognizedObjectsForm:\n    def __init__(self): ...\n\n\nclass GH_UpgradeComponentControl(GH_DoubleBufferedPanel):\n    def __init__(self): ...\n    @property\n    def Document(self) -> GH_Document: ...\n    @property\n    def Upgraders(self) -> List: ...\n    def PopulateTooltip(self, sender: Object, e: GH_TooltipDisplayEventArgs) -> None: ...\n    @Document.setter\n    def Document(self, Value: GH_Document) -> None: ...\n\n\nclass GH_UpgradeComponentForm:\n    def __init__(self): ...\n\n\nclass GH_UpgradeUndoWarningDialog:\n    def __init__(self): ...\n\n\nclass GH_UserObjectDeleteConfirmationDialog:\n    def __init__(self): ...\n    def SetMessage(self, objectName: str) -> None: ...\n\n\nclass GH_UserObjectProperties:\n    def __init__(self): ...\n    @property\n    def Exposure(self) -> GH_Exposure: ...\n    @property\n    def InstanceDescription(self) -> GH_InstanceDescription: ...\n    @property\n    def ObjectIcon(self) -> Bitmap: ...\n    @ObjectIcon.setter\n    def ObjectIcon(self, Value: Bitmap) -> None: ...\n\n\nclass GH_ValueChangedEventArgs:\n    def __init__(self, newval: float, oldval: float, final: bool): ...\n    @property\n    def IsFinal(self) -> bool: ...\n    @property\n    def NewValue(self) -> float: ...\n    @property\n    def OldValue(self) -> float: ...\n\n\nclass GH_ValueListEditor:\n    def __init__(self): ...\n    def AssignValues(self, values: List[GH_ValueListItem]) -> None: ...\n    @property\n    def Changed(self) -> bool: ...\n    def RetrieveValues(self) -> List: ...\n\n\nclass GH_VariableParameterManager:\n    def __init__(self): ...\n    @overload\n    def AddProxy(self, param: IGH_Param, bVariable: bool, bMutable: bool) -> None: ...\n    @overload\n    def AddProxy(self, sNickName: str, bVariable: bool, bMutable: bool) -> None: ...\n    def ClearParameters(self) -> None: ...\n    @property\n    def Component(self) -> IGH_VarParamComponent: ...\n    @property\n    def NameConstructor(self) -> IGH_ParamNameConstructor: ...\n    @property\n    def Proxies(self) -> List: ...\n    @property\n    def Side(self) -> GH_VarParamSide: ...\n    @Component.setter\n    def Component(self, Value: IGH_VarParamComponent) -> None: ...\n    @NameConstructor.setter\n    def NameConstructor(self, Value: IGH_ParamNameConstructor) -> None: ...\n    @Side.setter\n    def Side(self, Value: GH_VarParamSide) -> None: ...\n\n\nclass GH_VariableParamProxy:\n    def __init__(self): ...\n    @property\n    def BlankID(self) -> bool: ...\n    @property\n    def Deleted(self) -> bool: ...\n    @property\n    def ID(self) -> Guid: ...\n    @property\n    def Mutable(self) -> bool: ...\n    @property\n    def NickName(self) -> str: ...\n    @property\n    def Variable(self) -> bool: ...\n    @Deleted.setter\n    def Deleted(self, Value: bool) -> None: ...\n    @ID.setter\n    def ID(self, Value: Guid) -> None: ...\n    @Mutable.setter\n    def Mutable(self, Value: bool) -> None: ...\n    @NickName.setter\n    def NickName(self, Value: str) -> None: ...\n    @Variable.setter\n    def Variable(self, Value: bool) -> None: ...\n    def UpdateUI(self) -> None: ...\n\n\nclass GH_VersionHistoryForm:\n    def __init__(self): ...\n\n\nclass GH_VersionHistoryRelease:\n    def __init__(self): ...\n    @property\n    def Expanded(self) -> bool: ...\n    def LayoutRelease(self) -> None: ...\n    def PopulateRelease(self, lines: Iterable[str]) -> None: ...\n    @Expanded.setter\n    def Expanded(self, Value: bool) -> None: ...\n\n\nclass GH_VerticalScrollBar(GH_DoubleBufferedPanel):\n    def __init__(self): ...\n    def add_ScrollRatioChanged(self, obj: ScrollRatioChangedEventHandler) -> None: ...\n    @property\n    def Grip(self) -> Rectangle: ...\n    @property\n    def GripRegion(self) -> Rectangle: ...\n    @property\n    def ImpliedVerticalOffset(self) -> int: ...\n    @property\n    def ScreenHeight(self) -> int: ...\n    @property\n    def TargetHeight(self) -> int: ...\n    @property\n    def TargetRatio(self) -> float: ...\n    def remove_ScrollRatioChanged(self, obj: ScrollRatioChangedEventHandler) -> None: ...\n    @ImpliedVerticalOffset.setter\n    def ImpliedVerticalOffset(self, Value: int) -> None: ...\n    @ScreenHeight.setter\n    def ScreenHeight(self, Value: int) -> None: ...\n    @TargetHeight.setter\n    def TargetHeight(self, Value: int) -> None: ...\n    @TargetRatio.setter\n    def TargetRatio(self, Value: float) -> None: ...\n\n\nclass GH_VerticalSeparator(GH_DoubleBufferedPanel):\n    def __init__(self): ...\n\n\nclass GH_ViewportSettingsCategory(GH_SettingsCategory):\n    def __init__(self): ...\n    @property\n    def Description(self) -> str: ...\n\n\nclass GH_VoronoiWarningForm:\n    def __init__(self): ...\n\n\nclass GH_WidgetsSettingsCategory(GH_SettingsCategory):\n    def __init__(self): ...\n    @property\n    def Description(self) -> str: ...\n\n\nclass GH_WindowsControlUtil:\n    @overload\n    def FixTextRenderingDefault(control: Control) -> None: ...\n    @overload\n    def FixTextRenderingDefault(iControls: ControlCollection) -> None: ...\n\n\nclass GH_WindowsFormUtil:\n    def CenterFormOnCursor(F: Form, limitToScreen: bool) -> None: ...\n    def CenterFormOnEditor(F: Form, limitToScreen: bool) -> None: ...\n    def CenterFormOnScreen(F: Form, limitToScreen: bool) -> None: ...\n    def CenterFormOnWindow(F: Form, parentWindow: Form, limitToScreen: bool) -> None: ...\n\n\nclass GH_YakDownloadFormEto:\n    def __init__(self, items: Iterable[MissingObjectItem]): ...\n\n\nclass IconModeChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, new_mode: GH_IconDisplayMode, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, new_mode: GH_IconDisplayMode) -> None: ...\n\n\nclass IGH_Embeddable:\n    def PrepareForCancel(self) -> None: ...\n    def PrepareForCommit(self) -> None: ...\n\n\nclass IGH_FileDropTarget:\n    def AcceptableFile(self, path: str) -> bool: ...\n    def HandleDrop(self, path: str, mouse_pt: PointF) -> bool: ...\n\n\nclass IGH_FixedSizeControl:\n    def NearestHeight(self, h: int) -> int: ...\n    def NearestWidth(self, w: int) -> int: ...\n\n\nclass IGH_SettingCategory:\n    @property\n    def Description(self) -> str: ...\n    @property\n    def Icon(self) -> Bitmap: ...\n    @property\n    def Name(self) -> str: ...\n    @property\n    def Parent(self) -> str: ...\n\n\nclass IGH_SettingFrontend:\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    def SettingsUI(self) -> Control: ...\n\n\nclass IGH_ToolstripItemKeyHandler:\n    def RespondToEnter(self) -> GH_ToolstripItemKeyHandlerResult: ...\n    def RespondToEscape(self) -> GH_ToolstripItemKeyHandlerResult: ...\n\n\nclass IGH_Tooltip:\n    @property\n    def Description(self) -> str: ...\n    @property\n    def Palette(self) -> GH_TooltipPalette: ...\n    @property\n    def Text(self) -> str: ...\n    @property\n    def Title(self) -> str: ...\n    @Description.setter\n    def Description(self, Value: str) -> None: ...\n    @Diagram.setter\n    def Diagram(self, Value: Image) -> None: ...\n    @Icon.setter\n    def Icon(self, Value: Image) -> None: ...\n    @Palette.setter\n    def Palette(self, Value: GH_TooltipPalette) -> None: ...\n    @Text.setter\n    def Text(self, Value: str) -> None: ...\n    @Title.setter\n    def Title(self, Value: str) -> None: ...\n\n\n\n\nclass IntervalChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_Interval2DPicker, int: UVInterval, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_Interval2DPicker, int: UVInterval) -> None: ...\n\n\nclass KeyDownEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_MenuCustomControl, e: KeyEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_MenuCustomControl, e: KeyEventArgs) -> None: ...\n\n\nclass KeyDownEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_MenuTextBox, e: KeyEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_MenuTextBox, e: KeyEventArgs) -> None: ...\n\n\nclass MaterialImagePostPaintEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, image: Bitmap, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, image: Bitmap) -> None: ...\n\n\nclass MeshingParametersChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_MeshingParametersEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_MeshingParametersEventArgs) -> None: ...\n\n\nclass MissingObjectItem:\n    def __init__(self): ...\n    @property\n    def Id(self) -> Guid: ...\n    @property\n    def Name(self) -> str: ...\n    @property\n    def Version(self) -> str: ...\n    @Id.setter\n    def Id(self, AutoPropertyValue: Guid) -> None: ...\n    @Name.setter\n    def Name(self, AutoPropertyValue: str) -> None: ...\n    @Version.setter\n    def Version(self, value: str) -> None: ...\n\n\nclass NickNameChangeAcceptedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_NickNameTextBox, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_NickNameTextBox) -> None: ...\n\n\nclass NickNameChangeCancelledEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_NickNameTextBox, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_NickNameTextBox) -> None: ...\n\n\nclass NickNameChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, new_name: str, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, new_name: str) -> None: ...\n\n\nclass OnLimitsChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_NumericScrollerValueEditor, lower: Decimal, upper: Decimal, value: Decimal, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_NumericScrollerValueEditor, lower: Decimal, upper: Decimal, value: Decimal) -> None: ...\n\n\nclass OnScrollEndEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_NumericTextBox, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_NumericTextBox) -> None: ...\n\n\nclass OnScrollStartEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_NumericTextBox, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_NumericTextBox) -> None: ...\n\n\nclass OnValueChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_NumericScrollerValueEditor, lower: Decimal, upper: Decimal, value: Decimal, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_NumericScrollerValueEditor, lower: Decimal, upper: Decimal, value: Decimal) -> None: ...\n\n\nclass PathChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_FolderPathBrowser, nPath: str, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_FolderPathBrowser, nPath: str) -> None: ...\n\n\nclass PopulateTooltipEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_TooltipDisplayEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_TooltipDisplayEventArgs) -> None: ...\n\n\nclass PostPaint:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, graphics: Graphics, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, graphics: Graphics) -> None: ...\n\n\nclass ScrollRatioChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_VerticalScrollBar, ratio: float, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_VerticalScrollBar, ratio: float) -> None: ...\n\n\nclass SelectedChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: EventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: EventArgs) -> None: ...\n\n\nclass SelectedChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: EventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: EventArgs) -> None: ...\n\n\nclass SelectedIndexChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_ListScroller, e: GH_ListScrollerChangedEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_ListScroller, e: GH_ListScrollerChangedEventArgs) -> None: ...\n\n\nclass SelectionChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: EventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: EventArgs) -> None: ...\n\n\nclass TextChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_InfoTextBoxEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_InfoTextBoxEventArgs) -> None: ...\n\n\nclass TextChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_MenuTextBox, newText: str, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_MenuTextBox, newText: str) -> None: ...\n\n\nclass UndoRedoChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_RibbonLayoutEditorUndoRedoEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_RibbonLayoutEditorUndoRedoEventArgs) -> None: ...\n\n\nclass ValidPasswordEnteredEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: EventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: EventArgs) -> None: ...\n\n\nclass ValueChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_DigitScrollerEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_DigitScrollerEventArgs) -> None: ...\n\n\nclass ValueChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_NumericTextBox, e: GH_ValueChangedEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_NumericTextBox, e: GH_ValueChangedEventArgs) -> None: ...\n\n\nclass ValueChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_SliderEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_SliderEventArgs) -> None: ...\n\n\nclass ValueChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_Slider_Obsolete, nValue: float, bIntermediate: bool, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_Slider_Obsolete, nValue: float, bIntermediate: bool) -> None: ...\n\n\nclass ValuesChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_ControlKnobValueEditor, lower: Decimal, upper: Decimal, value: Decimal, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_ControlKnobValueEditor, lower: Decimal, upper: Decimal, value: Decimal) -> None: ...\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "line", "dimension", "curve", "functions", "block", "mesh", "RhinoCommon"], "original_file": "mcneel_pythonstubs_ab4098417b.json", "repo": "mcneel/pythonstubs"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "__all__ = ['Attributes','Components','Data','Expressions','Geometry','Graphs','Parameters','Sorting','Special','Types','Undo','Utility']\nfrom typing import Tuple, Set, Iterable, List, overload\n\n\nclass AttributesChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: IGH_DocumentObject, e: GH_AttributesChangedEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: IGH_DocumentObject, e: GH_AttributesChangedEventArgs) -> None: ...\n\n\nclass AutoSaveFileFormatChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self) -> None: ...\n\n\nclass ColourEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_ColourPicker, e: GH_ColourPickerEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_ColourPicker, e: GH_ColourPickerEventArgs) -> None: ...\n\n\nclass ConsoleFamilyChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self) -> None: ...\n\n\nclass ContextChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_DocContextEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_DocContextEventArgs) -> None: ...\n\n\nclass DefaultPreviewColourChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, colour: Color, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, colour: Color) -> None: ...\n\n\nclass DefaultSelectedPreviewColourChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, colour: Color, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, colour: Color) -> None: ...\n\n\nclass DisplayExpiredEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: IGH_DocumentObject, e: GH_DisplayExpiredEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: IGH_DocumentObject, e: GH_DisplayExpiredEventArgs) -> None: ...\n\n\nclass DocumentAddedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_DocumentServer, doc: GH_Document, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_DocumentServer, doc: GH_Document) -> None: ...\n\n\nclass DocumentRemovedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_DocumentServer, doc: GH_Document, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_DocumentServer, doc: GH_Document) -> None: ...\n\n\nclass EnableAutoSaveChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self) -> None: ...\n\n\nclass EnabledChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_DocEnabledEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_DocEnabledEventArgs) -> None: ...\n\n\nclass EnableSolutionsChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, state: bool, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, state: bool) -> None: ...\n\n\nclass FileChanged:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: GH_FileWatcher, filename: str, change: WatcherChangeTypes, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: GH_FileWatcher, filename: str, change: WatcherChangeTypes) -> None: ...\n\n\nclass FileChangedSimple:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, filename: str, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, filename: str) -> None: ...\n\n\nclass FileEvent:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, path: str, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, path: str) -> None: ...\n\n\nclass FilePathChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_DocFilePathEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_DocFilePathEventArgs) -> None: ...\n\n\nclass GH_ActiveObject(GH_DocumentObject):\n    def AddRuntimeMessage(self, level: GH_RuntimeMessageLevel, text: str) -> None: ...\n    def AppendAdditionalMenuItems(self, menu: ToolStripDropDown) -> None: ...\n    def AppendMenuItems(self, menu: ToolStripDropDown) -> bool: ...\n    def ClearData(self) -> None: ...\n    def ClearRuntimeMessages(self) -> None: ...\n    def CollectData(self) -> None: ...\n    def ComputeData(self) -> None: ...\n    def DependsOn(self, PotentialSource: IGH_ActiveObject) -> bool: ...\n    def ExpireSolution(self, recompute: bool) -> None: ...\n    @property\n    def IconCapableUI(self) -> bool: ...\n    @property\n    def IsDataProvider(self) -> bool: ...\n    @property\n    def Locked(self) -> bool: ...\n    @property\n    def MutableNickName(self) -> bool: ...\n    @property\n    def Phase(self) -> GH_SolutionPhase: ...\n    @property\n    def ProcessorTime(self) -> TimeSpan: ...\n    @property\n    def RuntimeMessageLevel(self) -> GH_RuntimeMessageLevel: ...\n    def Read(self, reader: GH_IReader) -> bool: ...\n    def RegisterRemoteIDs(self, id_list: GH_GuidTable) -> None: ...\n    def RuntimeMessages(self, level: GH_RuntimeMessageLevel) -> List[str]: ...\n    def SDKCompliancy(self, exeVersion: int, exeServiceRelease: int) -> bool: ...\n    @Locked.setter\n    def Locked(self, Value: bool) -> None: ...\n    @MutableNickName.setter\n    def MutableNickName(self, Value: bool) -> None: ...\n    @Phase.setter\n    def Phase(self, Value: GH_SolutionPhase) -> None: ...\n    def Write(self, writer: GH_IWriter) -> bool: ...\n\n\nclass GH_ActiveObjectFilter:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, iObj: IGH_ActiveObject, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> bool: ...\n    def Invoke(self, iObj: IGH_ActiveObject) -> bool: ...\n\n\nclass GH_Alias:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, other: GH_Alias): ...\n    @overload\n    def __init__(self, alias: str, target: Guid): ...\n    def AliasToString(aliases: Iterable[str]) -> str: ...\n    def CompareTo(self, other: GH_Alias) -> int: ...\n    @property\n    def Alias(self) -> str: ...\n    @property\n    def Target(self) -> Guid: ...\n    @Alias.setter\n    def Alias(self, AutoPropertyValue: str) -> None: ...\n    @Target.setter\n    def Target(self, AutoPropertyValue: Guid) -> None: ...\n    def StringToAlias(text: str) -> Set(str): ...\n\n\nclass GH_Arrange:\n    MoveToFront = 0\n    MoveForwards = 1\n    MoveToBack = 2\n    MoveBackwards = 3\n\n\nclass GH_AssemblyFolderInfo:\n    def __init__(self, folder: str, type: GH_PluginFolderType): ...\n    @property\n    def SearchOption(self) -> SearchOption: ...\n    def ToString(self) -> str: ...\n\n\nclass GH_AssemblyInfo:\n    @property\n    def Assembly(self) -> Assembly: ...\n    @property\n    def AssemblyDescription(self) -> str: ...\n    @property\n    def AssemblyIcon(self) -> Bitmap: ...\n    @property\n    def AssemblyLicense(self) -> GH_LibraryLicense: ...\n    @property\n    def AssemblyName(self) -> str: ...\n    @property\n    def AssemblyVersion(self) -> str: ...\n    @property\n    def AuthorContact(self) -> str: ...\n    @property\n    def AuthorName(self) -> str: ...\n    @property\n    def Description(self) -> str: ...\n    @property\n    def Icon(self) -> Bitmap: ...\n    @property\n    def Id(self) -> Guid: ...\n    @property\n    def IsCoreLibrary(self) -> bool: ...\n    @property\n    def License(self) -> GH_LibraryLicense: ...\n    @property\n    def LoadingMechanism(self) -> GH_LoadingMechanism: ...\n    @property\n    def Location(self) -> str: ...\n    @property\n    def Name(self) -> str: ...\n    @property\n    def Version(self) -> str: ...\n\n\nclass GH_AssemblyInfoStub(GH_AssemblyInfo):\n    def __init__(self, assembly: Assembly): ...\n    @property\n    def AssemblyName(self) -> str: ...\n    @property\n    def AssemblyVersion(self) -> str: ...\n\n\nclass GH_AssemblyPriority:\n    def PriorityLoad(self) -> GH_LoadingInstruction: ...\n\n\n\n\nclass GH_AttributesChangedEventArgs:\n    def __init__(self): ...\n\n\nclass GH_Author:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, other: IGH_Author): ...\n    def Clear(self) -> None: ...\n    @property\n    def Address(self) -> str: ...\n    @property\n    def AddressReadonly(self) -> str: ...\n    @property\n    def Company(self) -> str: ...\n    @property\n    def CompanyReadonly(self) -> str: ...\n    @property\n    def Copyright(self) -> str: ...\n    @property\n    def CopyrightReadonly(self) -> str: ...\n    @property\n    def EMail(self) -> str: ...\n    @property\n    def EMailReadonly(self) -> str: ...\n    @property\n    def IsEmpty(self) -> bool: ...\n    @property\n    def Name(self) -> str: ...\n    @property\n    def NameReadonly(self) -> str: ...\n    @property\n    def Phone(self) -> str: ...\n    @property\n    def PhoneReadonly(self) -> str: ...\n    @property\n    def Website(self) -> str: ...\n    @property\n    def WebsiteReadonly(self) -> str: ...\n    def Read(self, reader: GH_IReader) -> bool: ...\n    @Address.setter\n    def Address(self, AutoPropertyValue: str) -> None: ...\n    @Company.setter\n    def Company(self, AutoPropertyValue: str) -> None: ...\n    @Copyright.setter\n    def Copyright(self, AutoPropertyValue: str) -> None: ...\n    @EMail.setter\n    def EMail(self, AutoPropertyValue: str) -> None: ...\n    @Name.setter\n    def Name(self, AutoPropertyValue: str) -> None: ...\n    @Phone.setter\n    def Phone(self, AutoPropertyValue: str) -> None: ...\n    @Website.setter\n    def Website(self, AutoPropertyValue: str) -> None: ...\n    def Write(self, writer: GH_IWriter) -> bool: ...\n\n\nclass GH_AutoSaveSettings:\n    def __init__(self): ...\n    def add_AutoSaveFileFormatChanged(obj: AutoSaveFileFormatChangedEventHandler) -> None: ...\n    def add_EnableAutoSaveChanged(obj: EnableAutoSaveChangedEventHandler) -> None: ...\n    def add_SaveOnDataFlatteningChanged(obj: SaveOnDataFlatteningChangedEventHandler) -> None: ...\n    def add_SaveOnDocumentUnloadChanged(obj: SaveOnDocumentUnloadChangedEventHandler) -> None: ...\n    def add_SaveOnObjectAddedChanged(obj: SaveOnObjectAddedChangedEventHandler) -> None: ...\n    def add_SaveOnObjectChangeChanged(obj: SaveOnObjectChangeChangedEventHandler) -> None: ...\n    def add_SaveOnObjectRemovedChanged(obj: SaveOnObjectRemovedChangedEventHandler) -> None: ...\n    def add_SaveOnWireEventChanged(obj: SaveOnWireEventChangedEventHandler) -> None: ...\n    def AutosaveFilter(trigger: GH_AutoSaveTrigger) -> bool: ...\n    @property\n    def EnableAutoSave() -> bool: ...\n    @property\n    def SaveOnDataFlattening() -> bool: ...\n    @property\n    def SaveOnDocumentUnload() -> bool: ...\n    @property\n    def SaveOnObjectAdded() -> bool: ...\n    @property\n    def SaveOnObjectChange() -> bool: ...\n    @property\n    def SaveOnObjectRemoved() -> bool: ...\n    @property\n    def SaveOnWireEvent() -> bool: ...\n    def remove_AutoSaveFileFormatChanged(obj: AutoSaveFileFormatChangedEventHandler) -> None: ...\n    def remove_EnableAutoSaveChanged(obj: EnableAutoSaveChangedEventHandler) -> None: ...\n    def remove_SaveOnDataFlatteningChanged(obj: SaveOnDataFlatteningChangedEventHandler) -> None: ...\n    def remove_SaveOnDocumentUnloadChanged(obj: SaveOnDocumentUnloadChangedEventHandler) -> None: ...\n    def remove_SaveOnObjectAddedChanged(obj: SaveOnObjectAddedChangedEventHandler) -> None: ...\n    def remove_SaveOnObjectChangeChanged(obj: SaveOnObjectChangeChangedEventHandler) -> None: ...\n    def remove_SaveOnObjectRemovedChanged(obj: SaveOnObjectRemovedChangedEventHandler) -> None: ...\n    def remove_SaveOnWireEventChanged(obj: SaveOnWireEventChangedEventHandler) -> None: ...\n    @EnableAutoSave.setter\n    def EnableAutoSave(Value: bool) -> None: ...\n    @SaveOnDataFlattening.setter\n    def SaveOnDataFlattening(Value: bool) -> None: ...\n    @SaveOnDocumentUnload.setter\n    def SaveOnDocumentUnload(Value: bool) -> None: ...\n    @SaveOnObjectAdded.setter\n    def SaveOnObjectAdded(Value: bool) -> None: ...\n    @SaveOnObjectChange.setter\n    def SaveOnObjectChange(Value: bool) -> None: ...\n    @SaveOnObjectRemoved.setter\n    def SaveOnObjectRemoved(Value: bool) -> None: ...\n    @SaveOnWireEvent.setter\n    def SaveOnWireEvent(Value: bool) -> None: ...\n\n\nclass GH_AutoSaveTrigger:\n    undefined = 0\n    doc_unload = 1\n    object_added = 2\n    object_removed = 3\n    wire_event = 4\n    data_matching_event = 5\n    data_modification_event = 6\n    object_generic = 7\n\n\nclass GH_BakeUtility:\n    def __init__(self, document: GH_Document): ...\n    def BakeObject(self, obj: Object, att: ObjectAttributes, doc: RhinoDoc) -> bool: ...\n    def BakeObjects(self, objects: IEnumerable, att: ObjectAttributes, doc: RhinoDoc) -> int: ...\n    @property\n    def BakedCount(self) -> int: ...\n    @property\n    def BakedIds(self) -> Set(Guid): ...\n    @property\n    def InvalidCount(self) -> int: ...\n\n\nclass GH_BitmapChannel:\n    A = 1\n    R = 2\n    G = 4\n    B = 8\n    RGB = 14\n    ARGB = 15\n\n\nclass GH_CaseInsensitiveStringComparer:\n    def __init__(self): ...\n    def Compare(self, x: str, y: str) -> int: ...\n\n\nclass GH_ClipboardType:\n    System = 0\n    Local = 1\n    Global = 2\n\n\nclass GH_Component(GH_ActiveObject):\n    def AddedToDocument(self, document: GH_Document) -> None: ...\n    def AppendAdditionalMenuItems(self, menu: ToolStripDropDown) -> None: ...\n    @overload\n    def BakeGeometry(self, doc: RhinoDoc, obj_ids: List) -> None: ...\n    @overload\n    def BakeGeometry(self, doc: RhinoDoc, att: ObjectAttributes, obj_ids: List) -> None: ...\n    def ClearData(self) -> None: ...\n    def ClearRuntimeMessages(self) -> None: ...\n    def CollectData(self) -> None: ...\n    def ComputeData(self) -> None: ...\n    def CreateAttributes(self) -> None: ...\n    def DependsOn(self, potentialSource: IGH_ActiveObject) -> bool: ...\n    def DocumentContextChanged(self, document: GH_Document, context: GH_DocumentContext) -> None: ...\n    def DrawViewportMeshes(self, args: IGH_PreviewArgs) -> None: ...\n    def DrawViewportWires(self, args: IGH_PreviewArgs) -> None: ...\n    @property\n    def ClippingBox(self) -> BoundingBox: ...\n    @property\n    def DataComparison(self) -> GH_DataComparison: ...\n    @property\n    def Hidden(self) -> bool: ...\n    @property\n    def InConstructor(self) -> bool: ...\n    @property\n    def InstanceDescription(self) -> str: ...\n    @property\n    def IsBakeCapable(self) -> bool: ...\n    @property\n    def IsDataProvider(self) -> bool: ...\n    @property\n    def IsPreviewCapable(self) -> bool: ...\n    @property\n    def IsValidPrincipalParameterIndex(self) -> bool: ...\n    @property\n    def Locked(self) -> bool: ...\n    @property\n    def Message(self) -> str: ...\n    @property\n    def Params(self) -> GH_ComponentParamServer: ...\n    @property\n    def PrincipalParameterIndex(self) -> int: ...\n    @property\n    def ProcessorTime(self) -> TimeSpan: ...\n    @property\n    def RunCount(self) -> int: ...\n    @property\n    def RuntimeMessageLevel(self) -> GH_RuntimeMessageLevel: ...\n    def IsolateObject(self) -> None: ...\n    def MovedBetweenDocuments(self, oldDocument: GH_Document, newDocument: GH_Document) -> None: ...\n    def Read(self, reader: GH_IReader) -> bool: ...\n    def RegisterRemoteIDs(self, table: GH_GuidTable) -> None: ...\n    def RemovedFromDocument(self, document: GH_Document) -> None: ...\n    def RuntimeMessages(self, level: GH_RuntimeMessageLevel) -> List[str]: ...\n    @DataComparison.setter\n    def DataComparison(self, Value: GH_DataComparison) -> None: ...\n    @Hidden.setter\n    def Hidden(self, Value: bool) -> None: ...\n    @Locked.setter\n    def Locked(self, Value: bool) -> None: ...\n    @Message.setter\n    def Message(self, Value: str) -> None: ...\n    @PrincipalParameterIndex.setter\n    def PrincipalParameterIndex(self, AutoPropertyValue: int) -> None: ...\n    def Write(self, writer: GH_IWriter) -> bool: ...\n\n\nclass GH_ComponentParamServer:\n    def AccessCount(self, access: GH_ParamAccess) -> int: ...\n    def add_ParameterChanged(self, obj: ParameterChangedEventHandler) -> None: ...\n    def add_ParameterNickNameChanged(self, obj: ParameterNickNameChangedEventHandler) -> None: ...\n    def add_ParameterSourcesChanged(self, obj: ParameterSourcesChangedEventHandler) -> None: ...\n    @overload\n    def Clear(self) -> None: ...\n    @overload\n    def Clear(self, isolate: bool) -> None: ...\n    def CreateDuplicate(original: IGH_Param) -> IGH_Param: ...\n    def EmitSyncObject(self) -> IGH_SyncObject: ...\n    def Find(self, id: Guid) -> IGH_Param: ...\n    @property\n    def Input(self) -> List: ...\n    @property\n    def InputWidth(self) -> Single: ...\n    @property\n    def OnlyTreeAndListParameters(self) -> bool: ...\n    @property\n    def OnlyTreeParameters(self) -> bool: ...\n    @property\n    def Output(self) -> List: ...\n    @property\n    def OutputWidth(self) -> Single: ...\n    @property\n    def Owner(self) -> IGH_Component: ...\n    def GetEnumerator(self) -> IEnumerator: ...\n    def GetEnumerator1(self) -> IEnumerator: ...\n    @overload\n    def GetHashCode(self) -> int: ...\n    @overload\n    def GetHashCode(self, fields: GH_ParamHashFields) -> Guid: ...\n    @overload\n    def IndexOfInputParam(self, name: str) -> int: ...\n    @overload\n    def IndexOfInputParam(self, id: Guid) -> int: ...\n    @overload\n    def IndexOfOutputParam(self, id: Guid) -> int: ...\n    @overload\n    def IndexOfOutputParam(self, name: str) -> int: ...\n    @overload\n    def InventUniqueNickname(allowedChars: str, existingNames: Iterable[str]) -> str: ...\n    @overload\n    def InventUniqueNickname(allowedChars: str, existingNames: Iterable[IGH_Param]) -> str: ...\n    def IsInputParam(self, param: IGH_Param) -> bool: ...\n    def IsOutputParam(self, param: IGH_Param) -> bool: ...\n    def IsParam(self, param: IGH_Param) -> bool: ...\n    def OnParametersChanged(self) -> None: ...\n    def Read(self, reader: GH_IReader) -> bool: ...\n    def ReadAllParameterData(self, reader: GH_IReader) -> bool: ...\n    @overload\n    def RegisterInputParam(self, new_param: IGH_Param) -> bool: ...\n    @overload\n    def RegisterInputParam(self, new_param: IGH_Param, at_index: int) -> bool: ...\n    @overload\n    def RegisterOutputParam(self, new_param: IGH_Param) -> bool: ...\n    @overload\n    def RegisterOutputParam(self, new_param: IGH_Param, at_index: int) -> bool: ...\n    def remove_ParameterChanged(self, obj: ParameterChangedEventHandler) -> None: ...\n    def remove_ParameterNickNameChanged(self, obj: ParameterNickNameChangedEventHandler) -> None: ...\n    def remove_ParameterSourcesChanged(self, obj: ParameterSourcesChangedEventHandler) -> None: ...\n    def RepairParamAssociations(self) -> None: ...\n    def RepairProxyParams(self, document: GH_Document) -> bool: ...\n    @overload\n    def SortInput(self, keys: Set(Single)) -> None: ...\n    @overload\n    def SortInput(self, keys: Set(int)) -> None: ...\n    @overload\n    def SortInput(self, keys: Set(float)) -> None: ...\n    @overload\n    def SortOutput(self, keys: Set(Single)) -> None: ...\n    @overload\n    def SortOutput(self, keys: Set(float)) -> None: ...\n    @overload\n    def SortOutput(self, keys: Set(int)) -> None: ...\n    @overload\n    def Sync(self, sync_data: Object) -> None: ...\n    @overload\n    def Sync(self, sync_data: IGH_SyncObject) -> None: ...\n    @overload\n    def Sync(self, sync_data: IGH_SyncObject) -> Tuple[int]: ...\n    @overload\n    def UnregisterInputParameter(self, param: IGH_Param) -> bool: ...\n    @overload\n    def UnregisterInputParameter(self, param: IGH_Param, isolate: bool) -> bool: ...\n    @overload\n    def UnregisterOutputParameter(self, param: IGH_Param) -> bool: ...\n    @overload\n    def UnregisterOutputParameter(self, param: IGH_Param, isolate: bool) -> bool: ...\n    @overload\n    def UnregisterParameter(self, param: IGH_Param) -> bool: ...\n    @overload\n    def UnregisterParameter(self, param: IGH_Param, isolate: bool) -> bool: ...\n    def Write(self, writer: GH_IWriter) -> bool: ...\n    def WriteAllParameterData(self, writer: GH_IWriter) -> bool: ...\n    def WriteParamHashData(writer: BinaryWriter, param: IGH_Param, fields: GH_ParamHashFields) -> None: ...\n\n\nclass GH_ComponentServer:\n    def __init__(self): ...\n    def add_GHAFileLoaded(self, obj: GHAFileLoadedEventHandler) -> None: ...\n    def AddAlias(self, alias: str, target: Guid) -> None: ...\n    def AddCategoryIcon(self, fullCategoryName: str, icon: Bitmap) -> None: ...\n    def AddCategoryShortName(self, fullCategoryName: str, categoryAbbreviation: str) -> None: ...\n    def AddCategorySymbolName(self, fullCategoryName: str, symbol: Char) -> None: ...\n    def AddProxy(self, proxy: IGH_ObjectProxy) -> bool: ...\n    def AddProxyLibraryInfo(self, assemblyInfo: GH_AssemblyInfo) -> bool: ...\n    def AliasTargets(self, alias: str) -> List: ...\n    def Clear(self) -> None: ...\n    def ClearStaleUserObjects(self) -> None: ...\n    def CompareProxies(A: IGH_ObjectProxy, B: IGH_ObjectProxy) -> int: ...\n    def CopyFileToAppropriateFolder(filepath: str, moveOriginalToBin: bool) -> str: ...\n    def DestroyLoadingUI(self) -> None: ...\n    def EmitGraph(self, id: Guid) -> IGH_Graph: ...\n    def EmitObject(self, id: Guid) -> IGH_DocumentObject: ...\n    def EmitObjectIcon(self, id: Guid) -> Bitmap: ...\n    def EmitObjectProxy(self, id: Guid) -> IGH_ObjectProxy: ...\n    def ExternalFiles(testGrasshopperCollisions: bool, testExternalCollisions: bool) -> List: ...\n    def FindAssembly(self, libraryId: Guid) -> GH_AssemblyInfo: ...\n    @overload\n    def FindAssemblyByObject(self, object: IGH_DocumentObject) -> GH_AssemblyInfo: ...\n    @overload\n    def FindAssemblyByObject(self, objectId: Guid) -> GH_AssemblyInfo: ...\n    def FindObjectByName(self, name: str, ignoreWhiteSpace: bool, ignoreCapitalisation: bool) -> IGH_ObjectProxy: ...\n    @overload\n    def FindObjects(self, libraryID: Guid) -> List: ...\n    @overload\n    def FindObjects(self, terms: Set(str), maximumResults: int, results: Set(IGH_ObjectProxy), resultWeights: Set(float)) -> Tuple[int, Set(IGH_ObjectProxy), Set(float)]: ...\n    def FindUpgrader(self, target: Guid) -> IGH_UpgradeObject: ...\n    @property\n    def Aliases(self) -> List: ...\n    @property\n    def AllAddOns() -> List: ...\n    @property\n    def CompleteRibbonLayout(self) -> GH_Layout: ...\n    @property\n    def DiscardedProxies(self) -> int: ...\n    @property\n    def GHA_AppDataDirectory() -> str: ...\n    @property\n    def GHA_Directories() -> List: ...\n    @property\n    def GHUser_AppDataDirectory() -> str: ...\n    @property\n    def GraphProxies(self) -> List[GH_GraphProxy]: ...\n    @property\n    def Libraries(self) -> ReadOnlyCollection: ...\n    @property\n    def LoadingExceptions(self) -> List: ...\n    @property\n    def ObjectProxies(self) -> List[IGH_ObjectProxy]: ...\n    @property\n    def ObjectProxyNames(self) -> AutoCompleteStringCollection: ...\n    @property\n    def TypeHints(self) -> List[Type]: ...\n    @property\n    def Upgraders(self) -> List[IGH_UpgradeObject]: ...\n    def GetAlias(self, target: Guid) -> str: ...\n    def GetCategoryIcon(self, fullName: str) -> Bitmap: ...\n    def GetCategoryShortName(self, fullName: str) -> str: ...\n    def GetCategorySymbolName(self, fullName: str) -> str: ...\n    def IsGraphCached(self, id: Guid) -> bool: ...\n    def IsObjectCached(self, id: Guid) -> bool: ...\n    def IsUpgrader(self, objs: Iterable[IGH_DocumentObject]) -> bool: ...\n    def LoadAliases(self) -> None: ...\n    def LoadExternalFiles(self, loadOneByOne: bool) -> bool: ...\n    def NewUserObject(obj: IGH_DocumentObject) -> bool: ...\n    def remove_GHAFileLoaded(self, obj: GHAFileLoadedEventHandler) -> None: ...\n    def RemoveCachedGraph(self, id: Guid) -> bool: ...\n    @overload\n    def RemoveCachedObject(self, id: Guid) -> bool: ...\n    @overload\n    def RemoveCachedObject(self, userObjectFilePath: str) -> bool: ...\n    def SaveAliases(self) -> None: ...\n    def SetAlias(self, alias: str, target: Guid) -> None: ...\n    def UpdateRibbonUI() -> None: ...\n\n\nclass GH_ConnectivityDiagram:\n    @overload\n    def __init__(self, doc: GH_Document): ...\n    @overload\n    def __init__(self, other: GH_ConnectivityDiagram): ...\n    def ContainsID(self, id: Guid) -> bool: ...\n    @property\n    def Node(self, id: Guid) -> GH_ConnectivityNode: ...\n    @property\n    def NodeCount(self) -> int: ...\n    @property\n    def Nodes(self) -> ReadOnlyCollection: ...\n    def GetAllInputs(self, id: Guid) -> List: ...\n    def GetAllOutputs(self, id: Guid) -> List: ...\n\n\nclass GH_ConnectivityDisparity:\n    def __init__(self, topset: GH_ConnectivityDiagram, subset: GH_ConnectivityDiagram): ...\n    def ExternalInputs(self, id: Guid) -> List: ...\n    def ExternalOutputs(self, id: Guid) -> List: ...\n    @property\n    def SubNodes(self) -> ReadOnlyCollection: ...\n    @property\n    def SubSet(self) -> GH_ConnectivityDiagram: ...\n    @property\n    def TopNodes(self) -> ReadOnlyCollection: ...\n    @property\n    def TopSet(self) -> GH_ConnectivityDiagram: ...\n    def InternalInputs(self, id: Guid) -> List: ...\n    def InternalOutputs(self, id: Guid) -> List: ...\n\n\nclass GH_ConnectivityNode:\n    def __init__(self, other: GH_ConnectivityNode): ...\n    @property\n    def NodeID(self) -> Guid: ...\n    @property\n    def NodeIn(self) -> ReadOnlyCollection: ...\n    @property\n    def NodeOut(self) -> ReadOnlyCollection: ...\n\n\nclass GH_Conversion:\n    Primary = 0\n    Secondary = 1\n    Both = 2\n\n\nclass GH_Convert:\n    def BackSolveExpression(exp: str, variable: str, target: float, minimum: float, maximum: float, steps: int) -> Tuple[bool, float, float]: ...\n    def ByteArrayToCommonObject(data: Set(Byte)) -> T: ...\n    def CombineDateAndTime(date: DateTime, time: DateTime) -> DateTime: ...\n    def CommonObjectToByteArray(data: CommonObject) -> Set(Byte): ...\n    def CreatePureDate(date: DateTime) -> DateTime: ...\n    @overload\n    def CreatePureTime(date: DateTime) -> DateTime: ...\n    @overload\n    def CreatePureTime(hours: int, minutes: int, seconds: int) -> DateTime: ...\n    def FileToHash(path: str) -> Guid: ...\n    def FindRhinoObjectByNameAndType(name: str, type: ObjectType) -> RhinoObject: ...\n    def GeometryToObjRef(in: IGH_GeometricGoo) -> ObjRef: ...\n    @property\n    def CultureTable() -> SortedDictionary: ...\n    def GetBrepFromDocument(doc: RhinoDoc, id: Guid) -> Tuple[bool, Brep]: ...\n    def GetClippingPlaneFromDocument(doc: RhinoDoc, id: Guid) -> Tuple[bool, Plane]: ...\n    def GetCurveFromDocument(doc: RhinoDoc, id: Guid) -> Tuple[bool, Curve]: ...\n    def GetMeshFromDocument(doc: RhinoDoc, id: Guid) -> Tuple[bool, Mesh]: ...\n    def GetPointFromDocument(doc: RhinoDoc, id: Guid) -> Tuple[bool, Point3d]: ...\n    def GetSubDFromDocument(doc: RhinoDoc, id: Guid) -> Tuple[bool, SubD]: ...\n    def GetSurfaceFromDocument(doc: RhinoDoc, id: Guid) -> Tuple[bool, Surface]: ...\n    @overload\n    def GetTimeKind(time: DateTime) -> GH_TimeKind: ...\n    @overload\n    def GetTimeKind(A: DateTime, B: DateTime) -> GH_TimeKind: ...\n    def IsPureDate(potentialDate: DateTime) -> bool: ...\n    def IsPureTime(potentialTime: DateTime) -> bool: ...\n    def ObjRefToGeometry(in: ObjRef) -> IGH_GeometricGoo: ...\n    def ParseExpression(exp: str, recursive: bool) -> GH_Variant: ...\n    def StringToDate(text: str, date: DateTime) -> Tuple[bool, DateTime]: ...\n    def StringToGuid(text: str) -> Guid: ...\n    def StringToTime(text: str, time: DateTime) -> Tuple[bool, DateTime]: ...\n    def To_GH_ClassPrefixTypeName(old_name: str) -> str: ...\n    def ToArc_Primary(data: Object, rc: Arc) -> Tuple[bool, Arc]: ...\n    def ToArc(data: Object, rc: Arc, conversion_level: GH_Conversion) -> Tuple[bool, Arc]: ...\n    def ToArc_Secondary(data: Object, rc: Arc) -> Tuple[bool, Arc]: ...\n    def ToBoolean_Primary(data: Object, destination: bool) -> Tuple[bool, bool]: ...\n    def ToBoolean(data: Object, conversion_level: GH_Conversion) -> Tuple[bool, bool]: ...\n    def ToBoolean_Secondary(data: Object, destination: bool) -> Tuple[bool, bool]: ...\n    def ToBoundingBox_Primary(data: Object, rc: BoundingBox) -> Tuple[bool, BoundingBox]: ...\n    def ToBox_Primary(data: Object, rc: Box) -> Tuple[bool, Box]: ...\n    def ToBrep_Primary(data: Object, rc: Brep) -> Tuple[bool, Brep]: ...\n    def ToBrep(data: Object, rc: Brep, conversion_level: GH_Conversion) -> Tuple[bool, Brep]: ...\n    def ToBrep_Secondary(data: Object, rc: Brep) -> Tuple[bool, Brep]: ...\n    def ToCircle_Primary(data: Object, rc: Circle) -> Tuple[bool, Circle]: ...\n    def ToCircle(data: Object, rc: Circle, conversion_level: GH_Conversion) -> Tuple[bool, Circle]: ...\n    def ToCircle_Secondary(data: Object, rc: Circle) -> Tuple[bool, Circle]: ...\n    def ToColor_Primary(data: Object, destination: Color) -> Tuple[bool, Color]: ...\n    def ToColor(data: Object, conversion_level: GH_Conversion) -> Tuple[bool, Color]: ...\n    def ToColor_Secondary(data: Object, destination: Color) -> Tuple[bool, Color]: ...\n    def ToComplex_Primary(data: Object, destination: Complex) -> Tuple[bool, Complex]: ...\n    def ToComplex(data: Object, conversion_level: GH_Conversion) -> Tuple[bool, Complex]: ...\n    def ToComplex_Secondary(data: Object, destination: Complex) -> Tuple[bool, Complex]: ...\n    def ToCoordinates(data: Object, x: float, y: float, z: float, w: float) -> Tuple[bool, float, float, float, float]: ...\n    def ToCulture_Primary(data: Object, destination: CultureInfo) -> Tuple[bool, CultureInfo]: ...\n    def ToCulture(data: Object, conversion_level: GH_Conversion) -> Tuple[bool, CultureInfo]: ...\n    def ToCulture_Secondary(data: Object, destination: CultureInfo) -> Tuple[bool, CultureInfo]: ...\n    def ToCurve_Primary(data: Object, rc: Curve) -> Tuple[bool, Curve]: ...\n    def ToCurve(data: Object, rc: Curve, conversion_level: GH_Conversion) -> Tuple[bool, Curve]: ...\n    def ToCurve_Secondary(data: Object, rc: Curve) -> Tuple[bool, Curve]: ...\n    def ToDate_Primary(data: Object, destination: DateTime) -> Tuple[bool, DateTime]: ...\n    def ToDate(data: Object, conversion_level: GH_Conversion) -> Tuple[bool, DateTime]: ...\n    def ToDate_Secondary(data: Object, destination: DateTime) -> Tuple[bool, DateTime]: ...\n    def ToDouble_Primary(data: Object, destination: float) -> Tuple[bool, float]: ...\n    def ToDouble(data: Object, conversion_level: GH_Conversion) -> Tuple[bool, float]: ...\n    def ToDouble_Secondary(data: Object, destination: float) -> Tuple[bool, float]: ...\n    def ToGeometricGoo(data: Object) -> IGH_GeometricGoo: ...\n    def ToGeometryBase(data: Object) -> GeometryBase: ...\n    def ToGHArc_Primary(data: Object, target: GH_Arc) -> Tuple[bool, GH_Arc]: ...\n    def ToGHArc(data: Object, conversion_level: GH_Conversion, target: GH_Arc) -> Tuple[bool, GH_Arc]: ...\n    def ToGHArc_Secondary(data: Object, target: GH_Arc) -> Tuple[bool, GH_Arc]: ...\n    def ToGHBoolean_Primary(data: Object, target: GH_Boolean) -> Tuple[bool, GH_Boolean]: ...\n    def ToGHBoolean(data: Object, conversion_level: GH_Conversion, target: GH_Boolean) -> Tuple[bool, GH_Boolean]: ...\n    def ToGHBoolean_Secondary(data: Object, target: GH_Boolean) -> Tuple[bool, GH_Boolean]: ...\n    def ToGHBox_Primary(data: Object, target: GH_Box) -> Tuple[bool, GH_Box]: ...\n    def ToGHBox(data: Object, conversion_level: GH_Conversion, target: GH_Box) -> Tuple[bool, GH_Box]: ...\n    def ToGHBox_Secondary(data: Object, target: GH_Box) -> Tuple[bool, GH_Box]: ...\n    def ToGHBrep_Primary(data: Object, target: GH_Brep) -> Tuple[bool, GH_Brep]: ...\n    def ToGHBrep(data: Object, conversion_level: GH_Conversion, target: GH_Brep) -> Tuple[bool, GH_Brep]: ...\n    def ToGHBrep_Secondary(data: Object, target: GH_Brep) -> Tuple[bool, GH_Brep]: ...\n    def ToGHCircle_Primary(data: Object, target: GH_Circle) -> Tuple[bool, GH_Circle]: ...\n    def ToGHCircle(data: Object, conversion_level: GH_Conversion, target: GH_Circle) -> Tuple[bool, GH_Circle]: ...\n    def ToGHCircle_Secondary(data: Object, target: GH_Circle) -> Tuple[bool, GH_Circle]: ...\n    def ToGHColour_Primary(data: Object, target: GH_Colour) -> Tuple[bool, GH_Colour]: ...\n    def ToGHColour(data: Object, conversion_level: GH_Conversion, target: GH_Colour) -> Tuple[bool, GH_Colour]: ...\n    def ToGHColour_Secondary(data: Object, target: GH_Colour) -> Tuple[bool, GH_Colour]: ...\n    def ToGHComplexNumber_Primary(data: Object, target: GH_ComplexNumber) -> Tuple[bool, GH_ComplexNumber]: ...\n    def ToGHComplexNumber(data: Object, conversion_level: GH_Conversion, target: GH_ComplexNumber) -> Tuple[bool, GH_ComplexNumber]: ...\n    def ToGHComplexNumber_Secondary(data: Object, target: GH_ComplexNumber) -> Tuple[bool, GH_ComplexNumber]: ...\n    def ToGHCurve_Primary(data: Object, target: GH_Curve) -> Tuple[bool, GH_Curve]: ...\n    def ToGHCurve(data: Object, conversion_level: GH_Conversion, target: GH_Curve) -> Tuple[bool, GH_Curve]: ...\n    def ToGHCurve_Secondary(data: Object, target: GH_Curve) -> Tuple[bool, GH_Curve]: ...\n    def ToGHGuid_Primary(data: Object, target: GH_Guid) -> Tuple[bool, GH_Guid]: ...\n    def ToGHGuid(data: Object, conversion_level: GH_Conversion, target: GH_Guid) -> Tuple[bool, GH_Guid]: ...\n    def ToGHGuid_Secondary(data: Object, target: GH_Guid) -> Tuple[bool, GH_Guid]: ...\n    def ToGHInteger_Primary(data: Object, target: GH_Integer) -> Tuple[bool, GH_Integer]: ...\n    def ToGHInteger(data: Object, conversion_level: GH_Conversion, target: GH_Integer) -> Tuple[bool, GH_Integer]: ...\n    def ToGHInteger_Secondary(data: Object, target: GH_Integer) -> Tuple[bool, GH_Integer]: ...\n    def ToGHInterval_Primary(data: Object, target: GH_Interval) -> Tuple[bool, GH_Interval]: ...\n    def ToGHInterval(data: Object, conversion_level: GH_Conversion, target: GH_Interval) -> Tuple[bool, GH_Interval]: ...\n    def ToGHInterval_Secondary(data: Object, target: GH_Interval) -> Tuple[bool, GH_Interval]: ...\n    def ToGHInterval2D_Primary(data: Object, target: GH_Interval2D) -> Tuple[bool, GH_Interval2D]: ...\n    def ToGHInterval2D(data: Object, conversion_level: GH_Conversion, target: GH_Interval2D) -> Tuple[bool, GH_Interval2D]: ...\n    def ToGHInterval2D_Secondary(data: Object, target: GH_Interval2D) -> Tuple[bool, GH_Interval2D]: ...\n    def ToGHLine_Primary(data: Object, target: GH_Line) -> Tuple[bool, GH_Line]: ...\n    def ToGHLine(data: Object, conversion_level: GH_Conversion, target: GH_Line) -> Tuple[bool, GH_Line]: ...\n    def ToGHLine_Secondary(data: Object, target: GH_Line) -> Tuple[bool, GH_Line]: ...\n    def ToGHMatrix_Primary(data: Object, target: GH_Matrix) -> Tuple[bool, GH_Matrix]: ...\n    def ToGHMatrix(data: Object, conversion_level: GH_Conversion, target: GH_Matrix) -> Tuple[bool, GH_Matrix]: ...\n    def ToGHMatrix_Secondary(data: Object, target: GH_Matrix) -> Tuple[bool, GH_Matrix]: ...\n    def ToGHMesh_Primary(data: Object, target: GH_Mesh) -> Tuple[bool, GH_Mesh]: ...\n    def ToGHMesh(data: Object, conversion_level: GH_Conversion, target: GH_Mesh) -> Tuple[bool, GH_Mesh]: ...\n    def ToGHMesh_Secondary(data: Object, target: GH_Mesh) -> Tuple[bool, GH_Mesh]: ...\n    def ToGHMeshFace_Primary(data: Object, target: GH_MeshFace) -> Tuple[bool, GH_MeshFace]: ...\n    def ToGHMeshFace(data: Object, conversion_level: GH_Conversion, target: GH_MeshFace) -> Tuple[bool, GH_MeshFace]: ...\n    def ToGHMeshFace_Secondary(data: Object, target: GH_MeshFace) -> Tuple[bool, GH_MeshFace]: ...\n    def ToGHNumber_Primary(data: Object, target: GH_Number) -> Tuple[bool, GH_Number]: ...\n    def ToGHNumber(data: Object, conversion_level: GH_Conversion, target: GH_Number) -> Tuple[bool, GH_Number]: ...\n    def ToGHNumber_Secondary(data: Object, target: GH_Number) -> Tuple[bool, GH_Number]: ...\n    def ToGHPlane_Primary(data: Object, target: GH_Plane) -> Tuple[bool, GH_Plane]: ...\n    def ToGHPlane(data: Object, conversion_level: GH_Conversion, target: GH_Plane) -> Tuple[bool, GH_Plane]: ...\n    def ToGHPlane_Secondary(data: Object, target: GH_Plane) -> Tuple[bool, GH_Plane]: ...\n    def ToGHPoint_Primary(data: Object, target: GH_Point) -> Tuple[bool, GH_Point]: ...\n    def ToGHPoint(data: Object, conversion_level: GH_Conversion, target: GH_Point) -> Tuple[bool, GH_Point]: ...\n    def ToGHPoint_Secondary(data: Object, target: GH_Point) -> Tuple[bool, GH_Point]: ...\n    def ToGHRectangle_Primary(data: Object, target: GH_Rectangle) -> Tuple[bool, GH_Rectangle]: ...\n    def ToGHRectangle(data: Object, conversion_level: GH_Conversion, target: GH_Rectangle) -> Tuple[bool, GH_Rectangle]: ...\n    def ToGHRectangle_Secondary(data: Object, target: GH_Rectangle) -> Tuple[bool, GH_Rectangle]: ...\n    def ToGHString_Primary(data: Object, target: GH_String) -> Tuple[bool, GH_String]: ...\n    def ToGHString(data: Object, conversion_level: GH_Conversion, target: GH_String) -> Tuple[bool, GH_String]: ...\n    def ToGHString_Secondary(data: Object, target: GH_String) -> Tuple[bool, GH_String]: ...\n    def ToGHSubD_Primary(data: Object, target: GH_SubD) -> Tuple[bool, GH_SubD]: ...\n    def ToGHSubD(data: Object, conversion_level: GH_Conversion, target: GH_SubD) -> Tuple[bool, GH_SubD]: ...\n    def ToGHSubD_Secondary(data: Object, target: GH_SubD) -> Tuple[bool, GH_SubD]: ...\n    def ToGHSurface_Primary(data: Object, target: GH_Surface) -> Tuple[bool, GH_Surface]: ...\n    def ToGHSurface(data: Object, conversion_level: GH_Conversion, target: GH_Surface) -> Tuple[bool, GH_Surface]: ...\n    def ToGHSurface_Secondary(data: Object, target: GH_Surface) -> Tuple[bool, GH_Surface]: ...\n    def ToGHTime_Primary(data: Object, target: GH_Time) -> Tuple[bool, GH_Time]: ...\n    def ToGHTime(data: Object, conversion_level: GH_Conversion, target: GH_Time) -> Tuple[bool, GH_Time]: ...\n    def ToGHTime_Secondary(data: Object, target: GH_Time) -> Tuple[bool, GH_Time]: ...\n    def ToGHVector_Primary(data: Object, target: GH_Vector) -> Tuple[bool, GH_Vector]: ...\n    def ToGHVector(data: Object, conversion_level: GH_Conversion, target: GH_Vector) -> Tuple[bool, GH_Vector]: ...\n    def ToGHVector_Secondary(data: Object, target: GH_Vector) -> Tuple[bool, GH_Vector]: ...\n    def ToGoo(data: Object) -> IGH_Goo: ...\n    def ToGUID_Primary(data: Object, destination: Guid) -> Tuple[bool, Guid]: ...\n    def ToGUID(data: Object, conversion_level: GH_Conversion) -> Tuple[bool, Guid]: ...\n    def ToGUID_Secondary(data: Object, destination: Guid) -> Tuple[bool, Guid]: ...\n    def ToInt32_Primary(data: Object, destination: int) -> Tuple[bool, int]: ...\n    def ToInt32(data: Object, conversion_level: GH_Conversion) -> Tuple[bool, int]: ...\n    def ToInt32_Secondary(data: Object, destination: int) -> Tuple[bool, int]: ...\n    def ToInterval_Primary(data: Object, rc: Interval) -> Tuple[bool, Interval]: ...\n    def ToInterval(data: Object, rc: Interval, conversion_level: GH_Conversion) -> Tuple[bool, Interval]: ...\n    def ToInterval_Secondary(data: Object, rc: Interval) -> Tuple[bool, Interval]: ...\n    def ToLine_Primary(data: Object, rc: Line) -> Tuple[bool, Line]: ...\n    def ToLine(data: Object, rc: Line, conversion_level: GH_Conversion) -> Tuple[bool, Line]: ...\n    def ToLine_Secondary(data: Object, rc: Line) -> Tuple[bool, Line]: ...\n    def ToMatrix_Primary(data: Object, rc: Matrix) -> Tuple[bool, Matrix]: ...\n    def ToMatrix(data: Object, rc: Matrix, conversion_level: GH_Conversion) -> Tuple[bool, Matrix]: ...\n    def ToMatrix_Secondary(data: Object, rc: Matrix) -> Tuple[bool, Matrix]: ...\n    def ToMesh_Primary(data: Object, rc: Mesh) -> Tuple[bool, Mesh]: ...\n    def ToMesh(data: Object, rc: Mesh, conversion_level: GH_Conversion) -> Tuple[bool, Mesh]: ...\n    def ToMesh_Secondary(data: Object, rc: Mesh) -> Tuple[bool, Mesh]: ...\n    def ToNextPowerOfTen(num: float) -> float: ...\n    def ToPlane_Primary(data: Object, rc: Plane) -> Tuple[bool, Plane]: ...\n    def ToPlane(data: Object, rc: Plane, conversion_level: GH_Conversion) -> Tuple[bool, Plane]: ...\n    def ToPlane_Secondary(data: Object, rc: Plane) -> Tuple[bool, Plane]: ...\n    def ToPlural(singular: str) -> str: ...\n    def ToPoint(in: PointF) -> Point: ...\n    def ToPoint3d_Primary(data: Object, rc: Point3d) -> Tuple[bool, Point3d]: ...\n    def ToPoint3d(data: Object, rc: Point3d, conversion_level: GH_Conversion) -> Tuple[bool, Point3d]: ...\n    def ToPoint3d_Secondary(data: Object, rc: Point3d) -> Tuple[bool, Point3d]: ...\n    def ToPointF(in: Point3d) -> PointF: ...\n    def ToPrevPowerOfTen(num: float) -> float: ...\n    def ToRectangle(in: RectangleF) -> Rectangle: ...\n    def ToRectangle3d_Primary(data: Object, rc: Rectangle3d) -> Tuple[bool, Rectangle3d]: ...\n    def ToRectangle3d(data: Object, rc: Rectangle3d, conversion_level: GH_Conversion) -> Tuple[bool, Rectangle3d]: ...\n    def ToRectangle3d_Secondary(data: Object, rc: Rectangle3d) -> Tuple[bool, Rectangle3d]: ...\n    def ToSafeRhinoCommonObject(data: Object) -> Object: ...\n    @overload\n    def ToSHA_Hash(data: Stream) -> Guid: ...\n    @overload\n    def ToSHA_Hash(data: Set(Byte)) -> Guid: ...\n    def ToSize(in: SizeF) -> Size: ...\n    def ToString_Primary(data: Object, destination: str) -> Tuple[bool, str]: ...\n    @overload\n    def ToString(data: Object, conversion_level: GH_Conversion) -> Tuple[bool, str]: ...\n    def ToString_Secondary(data: Object, destination: str) -> Tuple[bool, str]: ...\n    def ToSubD_Secondary(data: Object, rc: SubD) -> Tuple[bool, SubD]: ...\n    def ToSurface_Primary(data: Object, rc: Surface) -> Tuple[bool, Surface]: ...\n    def ToSurface(data: Object, rc: Surface, conversion_level: GH_Conversion) -> Tuple[bool, Surface]: ...\n    def ToSurface_Secondary(data: Object, rc: Surface) -> Tuple[bool, Surface]: ...\n    def ToUVInterval_Primary(data: Object, rc: UVInterval) -> Tuple[bool, UVInterval]: ...\n    def ToUVInterval(data: Object, rc: UVInterval, conversion_level: GH_Conversion) -> Tuple[bool, UVInterval]: ...\n    def ToUVInterval_Secondary(data: Object, rc: UVInterval) -> Tuple[bool, UVInterval]: ...\n    def ToVariableName(compound: str) -> str: ...\n    def ToVariant(value: Object) -> GH_Variant: ...\n    def ToVector3d_Primary(data: Object, rc: Vector3d) -> Tuple[bool, Vector3d]: ...\n    def ToVector3d(data: Object, rc: Vector3d, conversion_level: GH_Conversion) -> Tuple[bool, Vector3d]: ...\n    def ToVector3d_Secondary(data: Object, rc: Vector3d) -> Tuple[bool, Vector3d]: ...\n\n\nclass GH_CustomEventServer:\n    def __init__(self, consumer: IGH_EventConsumer): ...\n    @property\n    def Enabled(self) -> bool: ...\n    @property\n    def GuidTable(self) -> SortedDictionary: ...\n    @property\n    def GuidTableCount(self) -> int: ...\n    @Enabled.setter\n    def Enabled(self, Value: bool) -> None: ...\n\n\nclass GH_DataComparison:\n    ShortestList = 0\n    LongestList = 1\n    CrossReference = 2\n\n\nclass GH_DataMapping:\n    #None = 0\n    Flatten = 1\n    Graft = 2\n\n\nclass GH_DebugDescriptionWriter:\n    def __init__(self): ...\n    def CloseBlock(self) -> None: ...\n    def CreateBlock(self, name: str) -> None: ...\n    def CreateLog(self) -> str: ...\n    @property\n    def Depth(self) -> int: ...\n    @overload\n    def WriteLine(self) -> None: ...\n    @overload\n    def WriteLine(self, line: str) -> None: ...\n    @overload\n    def WriteLine(self, line: str, args: Set(Object)) -> None: ...\n    def WriteLogToFile(self, path: str) -> bool: ...\n\n\nclass GH_DisplayExpiredEventArgs:\n    def __init__(self, eForceRedraw: bool): ...\n    @property\n    def ForceRedraw(self) -> bool: ...\n\n\nclass GH_DocContextEventArgs:\n    @property\n    def Context(self) -> GH_DocumentContext: ...\n    @property\n    def Document(self) -> GH_Document: ...\n\n\nclass GH_DocEnabledEventArgs:\n    @property\n    def Document(self) -> GH_Document: ...\n    @property\n    def Enabled(self) -> bool: ...\n\n\nclass GH_DocFilePathEventArgs:\n    def __init__(self, document: GH_Document, oldPath: str, newPath: str): ...\n    @property\n    def Document(self) -> GH_Document: ...\n    @property\n    def NewFilePath(self) -> str: ...\n    @property\n    def OldFilePath(self) -> str: ...\n\n\nclass GH_DocModifiedEventArgs:\n    @property\n    def Document(self) -> GH_Document: ...\n    @property\n    def Modified(self) -> bool: ...\n\n\nclass GH_DocObjectEventArgs:\n    @property\n    def Attributes(self) -> List: ...\n    @property\n    def Document(self) -> GH_Document: ...\n    @property\n    def Object(self, index: int) -> IGH_DocumentObject: ...\n    @property\n    def ObjectCount(self) -> int: ...\n    @property\n    def Objects(self) -> ReadOnlyCollection: ...\n\n\nclass GH_DocSettingsEventArgs:\n    @property\n    def Document(self) -> GH_Document: ...\n    @property\n    def Kind(self) -> GH_DocumentSettings: ...\n\n\nclass GH_Document:\n    def __init__(self): ...\n    def ActiveObjects(self) -> List: ...\n    def add_ContextChanged(self, obj: ContextChangedEventHandler) -> None: ...\n    def add_DefaultPreviewColourChanged(obj: DefaultPreviewColourChangedEventHandler) -> None: ...\n    def add_DefaultSelectedPreviewColourChanged(obj: DefaultSelectedPreviewColourChangedEventHandler) -> None: ...\n    def add_EnabledChanged(self, obj: EnabledChangedEventHandler) -> None: ...\n    def add_EnableSolutionsChanged(obj: EnableSolutionsChangedEventHandler) -> None: ...\n    def add_FilePathChanged(self, obj: FilePathChangedEventHandler) -> None: ...\n    def add_ModifiedChanged(self, obj: ModifiedChangedEventHandler) -> None: ...\n    def add_ObjectsAdded(self, obj: ObjectsAddedEventHandler) -> None: ...\n    def add_ObjectsDeleted(self, obj: ObjectsDeletedEventHandler) -> None: ...\n    def add_SettingsChanged(self, obj: SettingsChangedEventHandler) -> None: ...\n    def add_SolutionEnd(self, obj: SolutionEndEventHandler) -> None: ...\n    def add_SolutionStart(self, obj: SolutionStartEventHandler) -> None: ...\n    def add_UndoStateChanged(self, obj: UndoStateChangedEventHandler) -> None: ...\n    def AddObject(self, docObject: IGH_DocumentObject, update: bool, index: int) -> bool: ...\n    @overload\n    def AlignObjects(self, align: GH_Align, distribute: GH_Distribute) -> None: ...\n    @overload\n    def AlignObjects(self, align: GH_Align, distribute: GH_Distribute, objs: List) -> None: ...\n    def AppendToDebugLog(self, writer: GH_DebugDescriptionWriter) -> None: ...\n    def ArrangeObject(self, obj: IGH_DocumentObject, motion: GH_Arrange) -> bool: ...\n    def ArrangeObjects(self, objs: Iterable[IGH_DocumentObject], motion: GH_Arrange) -> bool: ...\n    def AssociateWithRhinoDocument(self) -> None: ...\n    def AutoLayoutComponents(self, limitToSelection: bool) -> None: ...\n    @overload\n    def AutoSave(self, trigger: GH_AutoSaveTrigger) -> bool: ...\n    @overload\n    def AutoSave(self, trigger: GH_AutoSaveTrigger, id: Guid) -> bool: ...\n    def AutoSaveFileName(filename: str) -> str: ...\n    def BoundingBox(self, limitToSelection: bool) -> RectangleF: ...\n    def BringSelectionToTop(self) -> None: ...\n    def ClearIgnoreList(self) -> None: ...\n    def ClearReferenceTable(self) -> None: ...\n    def CloseAllSubsidiaries(self) -> int: ...\n    def ClusterInputHooks(self) -> Set(GH_ClusterInputHook): ...\n    def ClusterInstanceCount(self, id: Guid) -> int: ...\n    def ClusterOutputHooks(self) -> Set(GH_ClusterOutputHook): ...\n    def CompareTo(self, other: GH_Document) -> int: ...\n    def ConstructDocumentTree(self) -> GH_DocumentTree: ...\n    def ContainsClusterHooks(self) -> bool: ...\n    def ConvertFullNamesToNickNames(self) -> None: ...\n    def ConvertNickNamesToFullNames(self) -> None: ...\n    def CreateAutomaticClusterHooks(self) -> None: ...\n    def CreateConnectivityDiagram(self) -> GH_ConnectivityDiagram: ...\n    def CreateExpressionParser(self) -> GH_ExpressionParser: ...\n    def DefineConstant(self, name: str, value: GH_Variant) -> None: ...\n    def DeselectAll(self) -> None: ...\n    def DestroyAttributeCache(self) -> None: ...\n    def DestroyAutoSaveFiles(self) -> None: ...\n    def DestroyObjectTable(self) -> None: ...\n    def DestroyPreviewCaches(self) -> None: ...\n    def DestroyPreviewMeshes(self) -> None: ...\n    def DestroyProxySources(self) -> None: ...\n    def DisabledObjects(self) -> List: ...\n    def Dispose(self) -> None: ...\n    def DuplicateDocument(doc: GH_Document) -> GH_Document: ...\n    def EnabledObjects(self) -> List: ...\n    def ExpandSelection(self, Upstream: bool, Downstream: bool, GrowSelection: bool) -> None: ...\n    def ExpirePreview(self, redraw: bool) -> None: ...\n    def ExpireSolution(self) -> None: ...\n    def FilterActive(in: List) -> List: ...\n    def FilterDisabled(in: List) -> List: ...\n    def FilterEnabled(in: List) -> List: ...\n    def FilterInactive(in: List) -> List: ...\n    @overload\n    def FilterObjects(self, selectedObjects: GH_Filter, enabledObjects: GH_Filter, activeObjects: GH_Filter) -> List: ...\n    @overload\n    def FilterObjects(in: List, bSelectedObjects: GH_Filter, bEnabledObjects: GH_Filter, bActiveObjects: GH_Filter) -> List: ...\n    def FilterSelected(in: List) -> List: ...\n    def FilterUnselected(in: List) -> List: ...\n    @overload\n    def FindAllDownstreamObjects(self, from_: IGH_ActiveObject) -> List: ...\n    @overload\n    def FindAllDownstreamObjects(self, from_: List) -> List: ...\n    @overload\n    def FindAllDownstreamObjects(self, from_: IGH_ActiveObject, filter: GH_ActiveObjectFilter) -> List: ...\n    @overload\n    def FindAllDownstreamObjects(self, from_: List, filter: GH_ActiveObjectFilter) -> List: ...\n    @overload\n    def FindAttribute(self, id: Guid) -> IGH_Attributes: ...\n    @overload\n    def FindAttribute(self, pt: PointF, topLevelOnly: bool) -> IGH_Attributes: ...\n    @overload\n    def FindAttributeByGrip(self, pt: PointF, bLimitToOutside: bool, SearchRadius: int) -> IGH_Attributes: ...\n    @overload\n    def FindAttributeByGrip(self, pt: PointF, bLimitToOutside: bool, bIncludeInputs: bool, bIncludeOutputs: bool, SearchRadius: int) -> IGH_Attributes: ...\n    @overload\n    def FindClusters(self, id: Guid) -> List: ...\n    @overload\n    def FindClusters(self, filepath: str) -> List: ...\n    @overload\n    def FindComponent(self, pt: Point) -> IGH_Component: ...\n    @overload\n    def FindComponent(self, id: Guid) -> IGH_Component: ...\n    def FindFloatingParameter(self, pt: Point) -> IGH_Param: ...\n    def FindInputParameter(self, pt: Point) -> IGH_Param: ...\n    @overload\n    def FindObject(self, id: Guid, topLevelOnly: bool) -> IGH_DocumentObject: ...\n    @overload\n    def FindObject(self, id: Guid, topLevelOnly: bool) -> T: ...\n    @overload\n    def FindObject(self, pt: PointF, radius: Single) -> IGH_DocumentObject: ...\n    def FindObjects(self, keys: List, maxCount: int) -> List: ...\n    def FindOutputParameter(self, pt: Point) -> IGH_Param: ...\n    def FindParameter(self, id: Guid) -> IGH_Param: ...\n    def FindWireAt(self, point: PointF, radius: Single, source: IGH_Param, target: IGH_Param) -> Tuple[bool, IGH_Param, IGH_Param]: ...\n    def ForcePreview(self, previewOn: bool) -> None: ...\n    @property\n    def AbortRequested(self) -> bool: ...\n    @property\n    def AttributeCount(self) -> int: ...\n    @property\n    def Attributes(self) -> List[IGH_Attributes]: ...\n    @property\n    def Author(self) -> IGH_Author: ...\n    @property\n    def ConstantServer(self) -> SortedDictionary: ...\n    @property\n    def ContainsCustomPreviewObjects(self) -> bool: ...\n    @property\n    def ContainsCustomRenderObjects(self) -> bool: ...\n    @property\n    def Context(self) -> GH_DocumentContext: ...\n    @property\n    def CustomRenderObjects(self) -> Iterable[GH_CustomPreviewComponent]: ...\n    @property\n    def DefaultPreviewColour() -> Color: ...\n    @property\n    def DefaultSelectedPreviewColour() -> Color: ...\n    @property\n    def DisplayName(self) -> str: ...\n    @property\n    def DocumentID(self) -> Guid: ...\n    @property\n    def Enabled(self) -> bool: ...\n    @property\n    def EnableSolutions() -> bool: ...\n    @property\n    def EventServer(self) -> GH_DocumentEventServer: ...\n    @property\n    def FileNameProxy(self) -> str: ...\n    @property\n    def FilePath(self) -> str: ...\n    @property\n    def IgnoredCount(self) -> int: ...\n    @property\n    def IsFilePathDefined(self) -> bool: ...\n    @property\n    def IsModified(self) -> bool: ...\n    @property\n    def ModifiedSubsidiaries(self) -> int: ...\n    @property\n    def Nested(self) -> bool: ...\n    @property\n    def ObjectCount(self) -> int: ...\n    @property\n    def Objects(self) -> List[IGH_DocumentObject]: ...\n    @property\n    def ObjectSpan(self) -> TimeSpan: ...\n    @property\n    def Owner(self) -> IGH_DocumentOwner: ...\n    @property\n    def PreviewBoundary(self) -> GH_PreviewBoundary: ...\n    @property\n    def PreviewBoundingBox(self) -> BoundingBox: ...\n    @property\n    def PreviewColour(self) -> Color: ...\n    @property\n    def PreviewColourSelected(self) -> Color: ...\n    @property\n    def PreviewCustomMeshParameters(self) -> MeshingParameters: ...\n    @property\n    def PreviewFilter(self) -> GH_PreviewFilter: ...\n    @property\n    def PreviewMeshType(self) -> GH_PreviewMesh: ...\n    @property\n    def PreviewMode(self) -> GH_PreviewMode: ...\n    @property\n    def Profiler(self) -> GH_ProfilerMode: ...\n    @property\n    def Properties(self) -> GH_DocumentProperties: ...\n    @property\n    def RaiseEvents(self) -> bool: ...\n    @property\n    def RemotePanelLayout(self) -> RcpLayout: ...\n    @property\n    def RuntimeID(self) -> UInt64: ...\n    @property\n    def ScheduleDelay(self) -> int: ...\n    @property\n    def SelectedCount(self) -> int: ...\n    @property\n    def SelectionTopology(self) -> GH_SelectionTopology: ...\n    @property\n    def SolutionDepth(self) -> int: ...\n    @property\n    def SolutionHistory(self) -> List: ...\n    @property\n    def SolutionSpan(self) -> TimeSpan: ...\n    @property\n    def SolutionState(self) -> GH_ProcessStep: ...\n    @property\n    def StateServer(self) -> GH_StateServer: ...\n    @property\n    def Thumbnail(self) -> Bitmap: ...\n    @property\n    def UndoServer(self) -> GH_UndoServer: ...\n    @property\n    def UndoUtil(self) -> GH_UndoUtil: ...\n    @property\n    def ValueTable(self) -> GH_SettingsServer: ...\n    def GetAllInstanceIDs(self, topLevelOnly: bool) -> SortedList: ...\n    def InactiveObjects(self) -> List: ...\n    def InvertSelection(self) -> None: ...\n    def IsEscapeKeyDown() -> bool: ...\n    def IsRenderMeshPipelineViewport(self, pipeline: DisplayPipeline) -> bool: ...\n    @overload\n    def MergeDocument(self, other: GH_Document) -> bool: ...\n    @overload\n    def MergeDocument(self, other: GH_Document, resolveProxies: bool) -> bool: ...\n    @overload\n    def MergeDocument(self, other: GH_Document, resolveProxies: bool, removeProxies: bool) -> bool: ...\n    def Modified(self) -> None: ...\n    def MutateAllIds(self) -> None: ...\n    @overload\n    def NewSolution(self, expireAllObjects: bool) -> None: ...\n    @overload\n    def NewSolution(self, expireAllObjects: bool, mode: GH_SolutionMode) -> None: ...\n    def NonBlankFilter(iObj: IGH_ActiveObject) -> bool: ...\n    def NullFilter(iObj: IGH_ActiveObject) -> bool: ...\n    def OnContextChanged(self) -> None: ...\n    def OnEnabledChanged(self) -> None: ...\n    def OnFilePathChanged(self, old: str, new: str) -> None: ...\n    def OnModifiedChanged(self) -> None: ...\n    def OnObjectAdded(self, doc_object: IGH_DocumentObject) -> None: ...\n    def OnObjectDeleted(self, doc_object: IGH_DocumentObject) -> None: ...\n    def OnObjectsAdded(self, doc_objects: Iterable[IGH_DocumentObject]) -> None: ...\n    def OnObjectsDeleted(self, doc_objects: Iterable[IGH_DocumentObject]) -> None: ...\n    def OnSettingsChanged(self, kind: GH_DocumentSettings) -> None: ...\n    def OnUndoStateChanged(self, op: GH_UndoOperation, rec: GH_UndoRecord) -> None: ...\n    def PreviewCurrentMeshParameters(self) -> MeshingParameters: ...\n    def Read(self, reader: GH_IReader) -> bool: ...\n    def Redo(self) -> bool: ...\n    @overload\n    def RelevantObjectAtPoint(self, pt: PointF) -> GH_RelevantObjectData: ...\n    @overload\n    def RelevantObjectAtPoint(self, pt: PointF, searchFilter: GH_RelevantObjectFilter) -> GH_RelevantObjectData: ...\n    def remove_ContextChanged(self, obj: ContextChangedEventHandler) -> None: ...\n    def remove_DefaultPreviewColourChanged(obj: DefaultPreviewColourChangedEventHandler) -> None: ...\n    def remove_DefaultSelectedPreviewColourChanged(obj: DefaultSelectedPreviewColourChangedEventHandler) -> None: ...\n    def remove_EnabledChanged(self, obj: EnabledChangedEventHandler) -> None: ...\n    def remove_EnableSolutionsChanged(obj: EnableSolutionsChangedEventHandler) -> None: ...\n    def remove_FilePathChanged(self, obj: FilePathChangedEventHandler) -> None: ...\n    def remove_ModifiedChanged(self, obj: ModifiedChangedEventHandler) -> None: ...\n    def remove_ObjectsAdded(self, obj: ObjectsAddedEventHandler) -> None: ...\n    def remove_ObjectsDeleted(self, obj: ObjectsDeletedEventHandler) -> None: ...\n    def remove_SettingsChanged(self, obj: SettingsChangedEventHandler) -> None: ...\n    def remove_SolutionEnd(self, obj: SolutionEndEventHandler) -> None: ...\n    def remove_SolutionStart(self, obj: SolutionStartEventHandler) -> None: ...\n    def remove_UndoStateChanged(self, obj: UndoStateChangedEventHandler) -> None: ...\n    @overload\n    def RemoveObject(self, docObject: IGH_DocumentObject, update: bool) -> bool: ...\n    @overload\n    def RemoveObject(self, attribute: IGH_Attributes, update: bool) -> bool: ...\n    def RemoveObjects(self, objectList: Iterable[IGH_DocumentObject], update: bool) -> int: ...\n    def RemoveSelection(self, update: bool) -> None: ...\n    def RepairProxySources(self) -> bool: ...\n    def ReplaceProxySources(self) -> None: ...\n    def RequestAbortSolution(self) -> None: ...\n    def RunningAsCommand(self) -> Command: ...\n    @overload\n    def ScheduleSolution(self, delay: int) -> None: ...\n    @overload\n    def ScheduleSolution(self, delay: int, callback: GH_ScheduleDelegate) -> None: ...\n    @overload\n    def Select(self, obj_dat: GH_RelevantObjectData) -> GH_SelectionState: ...\n    @overload\n    def Select(self, obj_dat: GH_RelevantObjectData, bAdd: bool, bRemove: bool) -> GH_SelectionState: ...\n    def SelectAll(self) -> None: ...\n    def SelectedObjects(self) -> List: ...\n    @Context.setter\n    def Context(self, Value: GH_DocumentContext) -> None: ...\n    @DefaultPreviewColour.setter\n    def DefaultPreviewColour(Value: Color) -> None: ...\n    @DefaultSelectedPreviewColour.setter\n    def DefaultSelectedPreviewColour(Value: Color) -> None: ...\n    @Enabled.setter\n    def Enabled(self, Value: bool) -> None: ...\n    @EnableSolutions.setter\n    def EnableSolutions(Value: bool) -> None: ...\n    @FilePath.setter\n    def FilePath(self, Value: str) -> None: ...\n    @IsModified.setter\n    def IsModified(self, Value: bool) -> None: ...\n    @Nested.setter\n    def Nested(self, Value: bool) -> None: ...\n    @Owner.setter\n    def Owner(self, Value: IGH_DocumentOwner) -> None: ...\n    @PreviewBoundary.setter\n    def PreviewBoundary(self, value: GH_PreviewBoundary) -> None: ...\n    @PreviewColour.setter\n    def PreviewColour(self, Value: Color) -> None: ...\n    @PreviewColourSelected.setter\n    def PreviewColourSelected(self, Value: Color) -> None: ...\n    @PreviewCustomMeshParameters.setter\n    def PreviewCustomMeshParameters(self, Value: MeshingParameters) -> None: ...\n    @PreviewFilter.setter\n    def PreviewFilter(self, Value: GH_PreviewFilter) -> None: ...\n    @PreviewMeshType.setter\n    def PreviewMeshType(self, Value: GH_PreviewMesh) -> None: ...\n    @PreviewMode.setter\n    def PreviewMode(self, Value: GH_PreviewMode) -> None: ...\n    @Profiler.setter\n    def Profiler(self, Value: GH_ProfilerMode) -> None: ...\n    @RaiseEvents.setter\n    def RaiseEvents(self, Value: bool) -> None: ...\n    @Thumbnail.setter\n    def Thumbnail(self, Value: Bitmap) -> None: ...\n    @overload\n    def SetEnabledFlags(self, bEnable: bool) -> None: ...\n    @overload\n    def SetEnabledFlags(self, objects: List, bEnable: bool) -> None: ...\n    @overload\n    def SetPreviewFlags(self, bPreview: bool) -> None: ...\n    @overload\n    def SetPreviewFlags(self, objects: List, bPreview: bool) -> None: ...\n    def SetStatusBarEventHelper(self, message: GH_RuntimeMessage) -> None: ...\n    def ShowPreviewSettings(self) -> None: ...\n    def SolutionProgress(self) -> Tuple[int, int, int]: ...\n    @overload\n    def ToggleEnabledFlags(self) -> None: ...\n    @overload\n    def ToggleEnabledFlags(self, objects: List) -> None: ...\n    @overload\n    def TogglePreviewFlags(self) -> None: ...\n    @overload\n    def TogglePreviewFlags(self, objects: List) -> None: ...\n    def ToString(self) -> str: ...\n    def TranslateObjects(self, trXForm: Size, bLimitToSelection: bool) -> None: ...\n    def Undo(self) -> bool: ...\n    def UnselectedObjects(self) -> List: ...\n    def UpdateAllSubsidiaries(self) -> int: ...\n    @overload\n    def Write(self, writer: GH_IWriter) -> bool: ...\n    @overload\n    def Write(self, writer: GH_IWriter, objList: List[IGH_DocumentObject]) -> bool: ...\n\n\nclass GH_DocumentAssociations:\n    def __init__(self): ...\n    def Associate(self, rhinoFile: str, grasshopperFile: str) -> None: ...\n    def GetGrasshopperAssociations(self, rhinoFile: str) -> List: ...\n    def GetRhinoAssociations(self, grasshopperFile: str) -> List: ...\n\n\nclass GH_DocumentContext:\n    Unknown = 0\n    #None = 1\n    Open = 2\n    Close = 3\n    Loaded = 4\n    Unloaded = 5\n    Lock = 6\n    Unlock = 7\n\n\nclass GH_DocumentEventServer:\n    def __init__(self, document: GH_Document): ...\n    def AppendToDebugLog(self, writer: GH_DebugDescriptionWriter) -> None: ...\n    def ClearGuidTable(self) -> None: ...\n    def CreateGuidTable(self) -> None: ...\n    def EnsureGuidTable(self) -> None: ...\n    @property\n    def Enabled(self) -> bool: ...\n    @property\n    def GuidTableRefCount(self) -> int: ...\n    @Enabled.setter\n    def Enabled(self, Value: bool) -> None: ...\n\n\nclass GH_DocumentIO:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, internal_doc: GH_Document): ...\n    def ClearClipboard(self, clipboard: GH_ClipboardType) -> None: ...\n    @overload\n    def Copy(self, clipboard: GH_ClipboardType) -> bool: ...\n    @overload\n    def Copy(self, clipboard: GH_ClipboardType, limitToSelection: bool) -> bool: ...\n    @overload\n    def Copy(self, clipboard: GH_ClipboardType, guids: Iterable[Guid]) -> bool: ...\n    @property\n    def DisableOverwriteProtection() -> bool: ...\n    @property\n    def Document(self) -> GH_Document: ...\n    @property\n    def IsDocument(self) -> bool: ...\n    def GetDocumentIcon(filePath: str, size: Size) -> Bitmap: ...\n    def GetDocumentThumbnail(filePath: str) -> Bitmap: ...\n    @overload\n    def Open(self) -> bool: ...\n    @overload\n    def Open(self, filePath: str) -> bool: ...\n    def OpenDocumentDialog(self, path: str, title: str) -> str: ...\n    def Paste(self, clipboard: GH_ClipboardType) -> bool: ...\n    def Save(self) -> bool: ...\n    def SaveAs(self) -> bool: ...\n    def SaveAsCopyDocumentDialog(self, path: str) -> str: ...\n    def SaveAsDocumentDialog(self, path: str) -> str: ...\n    def SaveBackup(self) -> bool: ...\n    def SaveDocumentDialog(self, path: str, title: str) -> str: ...\n    def SaveQuiet(self, path: str) -> bool: ...\n    @DisableOverwriteProtection.setter\n    def DisableOverwriteProtection(AutoPropertyValue: bool) -> None: ...\n    @Document.setter\n    def Document(self, AutoPropertyValue: GH_Document) -> None: ...\n    @overload\n    def ShowOverwriteDialog(filename: str) -> int: ...\n    @overload\n    def ShowOverwriteDialog(filename: str, lastSave: DateTime, fileOnDisk: DateTime) -> int: ...\n    @overload\n    def SubsidiaryDocumentSavePrompt(document: GH_Document) -> DialogResult: ...\n    @overload\n    def SubsidiaryDocumentSavePrompt(documentName: str, modified: bool, modifiedSubsidiaries: int) -> DialogResult: ...\n\n\nclass GH_DocumentObject(GH_InstanceDescription):\n    def add_AttributesChanged(self, obj: AttributesChangedEventHandler) -> None: ...\n    def add_DisplayExpired(self, obj: DisplayExpiredEventHandler) -> None: ...\n    def add_ObjectChanged(self, obj: ObjectChangedEventHandler) -> None: ...\n    def add_PingDocument(self, obj: PingDocumentEventHandler) -> None: ...\n    def add_PreviewExpired(self, obj: PreviewExpiredEventHandler) -> None: ...\n    def add_SolutionExpired(self, obj: SolutionExpiredEventHandler) -> None: ...\n    def AddedToDocument(self, document: GH_Document) -> None: ...\n    def AppendMenuItems(self, menu: ToolStripDropDown) -> bool: ...\n    def CreateAttributes(self) -> None: ...\n    def DocumentContextChanged(self, document: GH_Document, context: GH_DocumentContext) -> None: ...\n    def ExpirePreview(self, redraw: bool) -> None: ...\n    def ExpireSolution(self, recompute: bool) -> None: ...\n    @property\n    def Attributes(self) -> IGH_Attributes: ...\n    @property\n    def ComponentGuid(self) -> Guid: ...\n    @property\n    def Exposure(self) -> GH_Exposure: ...\n    @property\n    def Icon_24x24(self) -> Bitmap: ...\n    @property\n    def Icon_24x24_Locked(self) -> Bitmap: ...\n    @property\n    def IconDisplayMode(self) -> GH_IconDisplayMode: ...\n    @property\n    def Obsolete(self) -> bool: ...\n    def IsolateObject(self) -> None: ...\n    def Menu_AppendColourPicker(menu: ToolStripDropDown, colour: Color, colourChanged: ColourEventHandler) -> GH_ColourPicker: ...\n    @overload\n    def Menu_AppendCustomItem(menu: ToolStripDropDown, control: Control) -> bool: ...\n    @overload\n    def Menu_AppendCustomItem(menu: ToolStripDropDown, control: Control, keydown: KeyDownEventHandler) -> bool: ...\n    @overload\n    def Menu_AppendCustomItem(menu: ToolStripDropDown, control: Control, keydown: KeyDownEventHandler, enabled: bool, width: int, lockOnFocus: bool) -> bool: ...\n    def Menu_AppendDigitScrollerItem(menu: ToolStripDropDown, min: Decimal, max: Decimal, value: Decimal, decimals: int) -> GH_DigitScrollerBase: ...\n    @overload\n    def Menu_AppendItem(menu: ToolStrip, text: str) -> ToolStripMenuItem: ...\n    @overload\n    def Menu_AppendItem(menu: ToolStrip, text: str, click: EventHandler) -> ToolStripMenuItem: ...\n    @overload\n    def Menu_AppendItem(menu: ToolStrip, text: str, click: EventHandler, enabled: bool) -> ToolStripMenuItem: ...\n    @overload\n    def Menu_AppendItem(menu: ToolStrip, text: str, click: EventHandler, icon: Image) -> ToolStripMenuItem: ...\n    @overload\n    def Menu_AppendItem(menu: ToolStrip, text: str, click: EventHandler, enabled: bool, checked: bool) -> ToolStripMenuItem: ...\n    @overload\n    def Menu_AppendItem(menu: ToolStrip, text: str, click: EventHandler, icon: Image, tag: Object) -> ToolStripMenuItem: ...\n    @overload\n    def Menu_AppendItem(menu: ToolStrip, text: str, click: EventHandler, icon: Image, enabled: bool, checked: bool) -> ToolStripMenuItem: ...\n    def Menu_AppendSeparator(menu: ToolStrip) -> ToolStripSeparator: ...\n    @overload\n    def Menu_AppendTextItem(menu: ToolStripDropDown, text: str, keydown: KeyDownEventHandler, textchanged: TextChangedEventHandler, lockOnFocus: bool) -> ToolStripTextBox: ...\n    @overload\n    def Menu_AppendTextItem(menu: ToolStripDropDown, text: str, keydown: KeyDownEventHandler, textchanged: TextChangedEventHandler, enabled: bool, width: int, lockOnFocus: bool) -> ToolStripTextBox: ...\n    @overload\n    def Menu_MoveItem(item: ToolStripItem, precedingItems: Set(str)) -> bool: ...\n    @overload\n    def Menu_MoveItem(item: ToolStripItem, insertBelow: bool, targets: Set(str)) -> bool: ...\n    def MovedBetweenDocuments(self, oldDocument: GH_Document, newDocument: GH_Document) -> None: ...\n    def OnAttributesChanged(self) -> None: ...\n    def OnDisplayExpired(self, redraw: bool) -> None: ...\n    @overload\n    def OnObjectChanged(self, eventType: GH_ObjectEventType) -> None: ...\n    @overload\n    def OnObjectChanged(self, customEvent: str) -> None: ...\n    @overload\n    def OnObjectChanged(self, e: GH_ObjectChangedEventArgs) -> None: ...\n    @overload\n    def OnObjectChanged(self, eventType: GH_ObjectEventType, tag: Object) -> None: ...\n    @overload\n    def OnObjectChanged(self, customEvent: str, tag: Object) -> None: ...\n    def OnPingDocument(self) -> GH_Document: ...\n    def OnPreviewExpired(self, redraw: bool) -> None: ...\n    def OnSolutionExpired(self, recompute: bool) -> None: ...\n    def Read(self, reader: GH_IReader) -> bool: ...\n    @overload\n    def RecordUndoEvent(self, undoName: str) -> Guid: ...\n    @overload\n    def RecordUndoEvent(self, record: GH_UndoRecord) -> None: ...\n    @overload\n    def RecordUndoEvent(self, undoName: str, action: IGH_UndoAction) -> Guid: ...\n    def remove_AttributesChanged(self, obj: AttributesChangedEventHandler) -> None: ...\n    def remove_DisplayExpired(self, obj: DisplayExpiredEventHandler) -> None: ...\n    def remove_ObjectChanged(self, obj: ObjectChangedEventHandler) -> None: ...\n    def remove_PingDocument(self, obj: PingDocumentEventHandler) -> None: ...\n    def remove_PreviewExpired(self, obj: PreviewExpiredEventHandler) -> None: ...\n    def remove_SolutionExpired(self, obj: SolutionExpiredEventHandler) -> None: ...\n    def RemovedFromDocument(self, document: GH_Document) -> None: ...\n    @Attributes.setter\n    def Attributes(self, Value: IGH_Attributes) -> None: ...\n    @IconDisplayMode.setter\n    def IconDisplayMode(self, Value: GH_IconDisplayMode) -> None: ...\n    def SetIconOverride(self, customIcon: Bitmap) -> None: ...\n    @overload\n    def TriggerAutoSave(self) -> None: ...\n    @overload\n    def TriggerAutoSave(self, trigger: GH_AutoSaveTrigger) -> None: ...\n    @overload\n    def TriggerAutoSave(self, id: Guid) -> None: ...\n    @overload\n    def TriggerAutoSave(self, trigger: GH_AutoSaveTrigger, id: Guid) -> None: ...\n    def Write(self, writer: GH_IWriter) -> bool: ...\n\n\nclass GH_DocumentProperties:\n    def __init__(self): ...\n    def DisplayProperties(self) -> None: ...\n    @property\n    def CopyRight(self) -> str: ...\n    @property\n    def Date(self) -> DateTime: ...\n    @property\n    def DateTag(self) -> DateTime: ...\n    @property\n    def Description(self) -> str: ...\n    @property\n    def IconImageData(self) -> str: ...\n    @property\n    def ProjectFileName(self) -> str: ...\n    @property\n    def Revisions(self) -> List: ...\n    @property\n    def ViewList(self) -> List: ...\n    @property\n    def ViewTarget(self) -> Point: ...\n    @property\n    def ZoomFactor(self) -> Single: ...\n    def IconBitmap(self, size: Size) -> Bitmap: ...\n    def Read(self, reader: GH_IReader) -> bool: ...\n    @CopyRight.setter\n    def CopyRight(self, Value: str) -> None: ...\n    @DateTag.setter\n    def DateTag(self, Value: DateTime) -> None: ...\n    @Description.setter\n    def Description(self, Value: str) -> None: ...\n    @IconImageData.setter\n    def IconImageData(self, Value: str) -> None: ...\n    @ProjectFileName.setter\n    def ProjectFileName(self, Value: str) -> None: ...\n    @ViewTarget.setter\n    def ViewTarget(self, Value: Point) -> None: ...\n    @ZoomFactor.setter\n    def ZoomFactor(self, Value: Single) -> None: ...\n    def Write(self, writer: GH_IWriter) -> bool: ...\n\n\nclass GH_DocumentRank:\n    Unset = 0\n    TopLevel = 1\n    Subsidiary = 2\n\n\nclass GH_DocumentRenderMeshProvider:\n    def __init__(self): ...\n    @overload\n    def BoundingBox(self, vp: ViewportInfo, obj: RhinoObject, doc: RhinoDoc, requestingPlugIn: Guid, attrs: DisplayPipelineAttributes) -> BoundingBox: ...\n    @overload\n    def BuildCustomMeshes(self, vp: ViewportInfo, doc: RhinoDoc, objMeshes: RenderPrimitiveList, requestingPlugIn: Guid, attrs: DisplayPipelineAttributes) -> bool: ...\n    @property\n    def Name(self) -> str: ...\n    @overload\n    def WillBuildCustomMeshes(self, vp: ViewportInfo, obj: RhinoObject, doc: RhinoDoc, requestingPlugIn: Guid, attrs: DisplayPipelineAttributes) -> bool: ...\n\n\nclass GH_DocumentServer:\n    def __init__(self): ...\n    def add_DocumentAdded(self, obj: DocumentAddedEventHandler) -> None: ...\n    def add_DocumentRemoved(self, obj: DocumentRemovedEventHandler) -> None: ...\n    @overload\n    def AddDocument(self, document: GH_Document) -> None: ...\n    @overload\n    def AddDocument(self, filepath: str, makeActive: bool) -> GH_Document: ...\n    def AddNewDocument(self) -> GH_Document: ...\n    def Contains(self, doc: GH_Document) -> bool: ...\n    @property\n    def Document(self, index: int) -> GH_Document: ...\n    @property\n    def DocumentCount(self) -> int: ...\n    @property\n    def DocumentNames(self) -> List: ...\n    @property\n    def ModifiedDocumentCount(self) -> int: ...\n    def GetEnumerator(self) -> IEnumerator: ...\n    def GetEnumerator_Generic(self) -> IEnumerator: ...\n    @overload\n    def IndexOf(self, doc: GH_Document) -> int: ...\n    @overload\n    def IndexOf(self, filepath: str) -> int: ...\n    def IndexOfAutoSave(self, autoSavePath: str) -> int: ...\n    def NextAvailableDocument(self) -> GH_Document: ...\n    def PromoteDocument(self, document: GH_Document) -> None: ...\n    def remove_DocumentAdded(self, obj: DocumentAddedEventHandler) -> None: ...\n    def remove_DocumentRemoved(self, obj: DocumentRemovedEventHandler) -> None: ...\n    def RemoveAllDocuments(self) -> None: ...\n    def RemoveDocument(self, document: GH_Document) -> None: ...\n    def SafeRemoveDocument(self, document: GH_Document) -> bool: ...\n\n\nclass GH_DocumentSettings:\n    Preview = 0\n    Properties = 1\n\n\nclass GH_DocumentTree:\n    def __init__(self, root: GH_Document): ...\n    def AppendToDebugLog(self, writer: GH_DebugDescriptionWriter) -> None: ...\n    @property\n    def FlatCollection(self) -> Iterable[GH_Document]: ...\n    @property\n    def Root(self) -> GH_DocumentTreeNode: ...\n    @property\n    def RootDocument(self) -> GH_Document: ...\n\n\nclass GH_DocumentTreeNode:\n    def __init__(self, node: GH_Document): ...\n    @property\n    def Document(self) -> GH_Document: ...\n    @property\n    def SubNodes(self) -> List: ...\n\n\nclass GH_DocUndoEventArgs:\n    @property\n    def Document(self) -> GH_Document: ...\n    @property\n    def Operation(self) -> GH_UndoOperation: ...\n    @property\n    def Record(self) -> GH_UndoRecord: ...\n\n\nclass GH_Exposure:\n    primary = 2\n    secondary = 4\n    tertiary = 8\n    quarternary = 16\n    quinary = 32\n    senary = 64\n    septenary = 128\n    dropdown = 65536\n    obscure = 65536\n    hidden = -1\n\n\nclass GH_ExternalFile:\n    def __init__(self, path: str): ...\n    @property\n    def FileHash(self) -> Guid: ...\n    @property\n    def FileName(self) -> str: ...\n    @property\n    def FilePath(self) -> str: ...\n    @property\n    def FileSize(self) -> Int64: ...\n    @property\n    def FileType(self) -> GH_ExternalFileType: ...\n    def IsIdenticalTo(self, other: GH_ExternalFile) -> bool: ...\n\n\nclass GH_ExternalFileType:\n    Unknown = 0\n    Assembly = 1\n    UserObject = 2\n    Cluster = 3\n\n\nclass GH_FileSystemEventServer:\n    def AddWatcher(owner: Object, path: str, callback: FileEvent) -> None: ...\n    @property\n    def AllPaths() -> Iterable[str]: ...\n    @overload\n    def RemoveWatcher(owner: Object) -> None: ...\n    @overload\n    def RemoveWatcher(owner: Object, path: str) -> None: ...\n\n\nclass GH_FileWatcher:\n    @overload\n    def CreateDirectoryWatcher(folderPath: str, filter: str, events: GH_FileWatcherEvents, delegate: FileChangedSimple) -> GH_FileWatcher: ...\n    @overload\n    def CreateDirectoryWatcher(folderPath: str, filter: str, events: GH_FileWatcherEvents, delegate: FileChanged) -> GH_FileWatcher: ...\n    @overload\n    def CreateFileWatcher(filePath: str, events: GH_FileWatcherEvents, delegate: FileChangedSimple) -> GH_FileWatcher: ...\n    @overload\n    def CreateFileWatcher(filePath: str, events: GH_FileWatcherEvents, delegate: FileChanged) -> GH_FileWatcher: ...\n    def Dispose(self) -> None: ...\n    @property\n    def Active(self) -> bool: ...\n    @property\n    def Buffer(self) -> TimeSpan: ...\n    @property\n    def InvokeOnDefaultThread(self) -> bool: ...\n    @property\n    def IsDisposed(self) -> bool: ...\n    @property\n    def Path(self) -> str: ...\n    @Active.setter\n    def Active(self, Value: bool) -> None: ...\n    @Buffer.setter\n    def Buffer(self, Value: TimeSpan) -> None: ...\n    @InvokeOnDefaultThread.setter\n    def InvokeOnDefaultThread(self, Value: bool) -> None: ...\n    @overload\n    def SetCustomUIThread(self, target: Control) -> None: ...\n    @overload\n    def SetCustomUIThread(self, target: Form) -> None: ...\n\n\nclass GH_FileWatcherEvents:\n    #None = 0\n    Changed = 1\n    Renamed = 2\n    Created = 4\n    Deleted = 8\n    All = 15\n\n\nclass GH_Filter:\n    DontCare = 0\n    Include = 1\n    Exclude = 2\n\n\nclass GH_FontServer:\n    def add_ConsoleFamilyChanged(obj: ConsoleFamilyChangedEventHandler) -> None: ...\n    def add_ScriptFamilyChanged(obj: ScriptFamilyChangedEventHandler) -> None: ...\n    def add_StandardFamilyChanged(obj: StandardFamilyChangedEventHandler) -> None: ...\n    def FontToString(font: Font) -> str: ...\n    @property\n    def Console() -> Font: ...\n    @property\n    def ConsoleAdjusted() -> Font: ...\n    @property\n    def ConsoleSmall() -> Font: ...\n    @property\n    def ConsoleSmallAdjusted() -> Font: ...\n    @property\n    def FamilyConsole() -> FontFamily: ...\n    @property\n    def FamilyScript() -> FontFamily: ...\n    @property\n    def FamilyStandard() -> FontFamily: ...\n    @property\n    def Large() -> Font: ...\n    @property\n    def LargeAdjusted() -> Font: ...\n    @property\n    def Script() -> Font: ...\n    @property\n    def ScriptSmall() -> Font: ...\n    @property\n    def Small() -> Font: ...\n    @property\n    def Standard() -> Font: ...\n    @property\n    def StandardAdjusted() -> Font: ...\n    @property\n    def StandardBold() -> Font: ...\n    @property\n    def StandardItalic() -> Font: ...\n    @overload\n    def MeasureString(text: str, font: Font) -> Size: ...\n    @overload\n    def MeasureString(text: str, font: Font, maxwidth: Single) -> Size: ...\n    @overload\n    def MeasureString(text: str, font: Font, iLayout: SizeF) -> Size: ...\n    @overload\n    def NewFont(family: FontFamily, size: Single) -> Font: ...\n    @overload\n    def NewFont(font: Font, style: FontStyle) -> Font: ...\n    @overload\n    def NewFont(font: Font, size: Single) -> Font: ...\n    @overload\n    def NewFont(family: str, size: Single, style: FontStyle) -> Font: ...\n    @overload\n    def NewFont(family: FontFamily, size: Single, style: FontStyle) -> Font: ...\n    @overload\n    def NewFont(font: Font, size: Single, style: FontStyle) -> Font: ...\n    def remove_ConsoleFamilyChanged(obj: ConsoleFamilyChangedEventHandler) -> None: ...\n    def remove_ScriptFamilyChanged(obj: ScriptFamilyChangedEventHandler) -> None: ...\n    def remove_StandardFamilyChanged(obj: StandardFamilyChangedEventHandler) -> None: ...\n    @FamilyConsole.setter\n    def FamilyConsole(Value: FontFamily) -> None: ...\n    @FamilyScript.setter\n    def FamilyScript(Value: FontFamily) -> None: ...\n    @FamilyStandard.setter\n    def FamilyStandard(Value: FontFamily) -> None: ...\n    def StringToFont(text: str) -> Font: ...\n    @overload\n    def StringWidth(text: str, font: Font) -> int: ...\n    @overload\n    def StringWidth(text: Iterable[str], font: Font) -> int: ...\n\n\nclass GH_Format:\n    def DefaultCulture() -> IFormatProvider: ...\n    @overload\n    def FormatArc(data: GH_Arc) -> str: ...\n    @overload\n    def FormatArc(data: Arc) -> str: ...\n    def FormatArcValidity(val: Arc, identifier: str) -> str: ...\n    @overload\n    def FormatBoolean(data: GH_Boolean) -> str: ...\n    @overload\n    def FormatBoolean(data: bool) -> str: ...\n    def FormatBoundingBoxValidity(val: BoundingBox, identifier: str) -> str: ...\n    @overload\n    def FormatBox(data: Box) -> str: ...\n    @overload\n    def FormatBox(data: GH_Box) -> str: ...\n    def FormatBoxValidity(val: Box, identifier: str) -> str: ...\n    @overload\n    def FormatBrep(data: GH_Brep) -> str: ...\n    @overload\n    def FormatBrep(data: Brep) -> str: ...\n    def FormatBrepValidity(val: Brep, identifier: str) -> str: ...\n    @overload\n    def FormatCircle(data: GH_Circle) -> str: ...\n    @overload\n    def FormatCircle(data: Circle) -> str: ...\n    def FormatCircleValidity(val: Circle, identifier: str) -> str: ...\n    @overload\n    def FormatColour(data: Color) -> str: ...\n    @overload\n    def FormatColour(data: GH_Colour) -> str: ...\n    @overload\n    def FormatComplexNumber(num: Complex) -> str: ...\n    @overload\n    def FormatComplexNumber(data: GH_ComplexNumber) -> str: ...\n    def FormatComplexValidity(val: Complex, identifier: str) -> str: ...\n    @overload\n    def FormatCurve(data: GH_Curve) -> str: ...\n    @overload\n    def FormatCurve(data: Curve, prefix: str, name: str) -> str: ...\n    def FormatCurveValidity(val: Curve, identifier: str) -> str: ...\n    @overload\n    def FormatDate(data: DateTime) -> str: ...\n    @overload\n    def FormatDate(data: GH_Time) -> str: ...\n    @overload\n    def FormatDouble(data: GH_Number) -> str: ...\n    @overload\n    def FormatDouble(data: float) -> str: ...\n    def FormatDoubleValidity(val: float, identifier: str) -> str: ...\n    @overload\n    def FormatFilePath(path: str, maxLength: int) -> str: ...\n    @overload\n    def FormatFilePath(path: str, maxWidth: int, font: Font) -> str: ...\n    def FormatGeometry(data: IGH_GeometricGoo) -> str: ...\n    @overload\n    def FormatInteger(data: GH_Integer) -> str: ...\n    @overload\n    def FormatInteger(data: int) -> str: ...\n    @overload\n    def FormatInterval(data: GH_Interval) -> str: ...\n    @overload\n    def FormatInterval(data: Interval) -> str: ...\n    @overload\n    def FormatInterval(data: GH_Interval2D) -> str: ...\n    @overload\n    def FormatInterval(t0: float, t1: float) -> str: ...\n    def FormatIntervalValidity(val: Interval, identifier: str, testSingleton: bool, testDecreasing: bool) -> str: ...\n    def FormatKeys(keys: Keys) -> str: ...\n    @overload\n    def FormatLine(data: Line) -> str: ...\n    @overload\n    def FormatLine(data: GH_Line) -> str: ...\n    def FormatLineValidity(val: Line, identifier: str) -> str: ...\n    @overload\n    def FormatMatrix(data: GH_Matrix) -> str: ...\n    @overload\n    def FormatMatrix(data: Matrix) -> str: ...\n    @overload\n    def FormatMesh(data: GH_Mesh) -> str: ...\n    @overload\n    def FormatMesh(data: Mesh, sPrefix: str) -> str: ...\n    def FormatMeshFace(data: GH_MeshFace) -> str: ...\n    def FormatMeshFaceValidity(val: MeshFace, identifier: str) -> str: ...\n    def FormatMeshValidity(val: Mesh, identifier: str) -> str: ...\n    @overload\n    def FormatPlane(data: GH_Plane) -> str: ...\n    @overload\n    def FormatPlane(data: Plane) -> str: ...\n    def FormatPlaneValidity(val: Plane, identifier: str, testUnitAxes: bool) -> str: ...\n    @overload\n    def FormatPoint(data: GH_Point) -> str: ...\n    @overload\n    def FormatPoint(data: Point3d) -> str: ...\n    def FormatPointCloud(data: PointCloud) -> str: ...\n    def FormatPointValidity(val: Point3d, identifier: str) -> str: ...\n    def FormatRectangleValidity(val: Rectangle3d, identifier: str) -> str: ...\n    def FormatSingle(data: Single) -> str: ...\n    @overload\n    def FormatSubD(data: GH_SubD) -> str: ...\n    @overload\n    def FormatSubD(data: SubD) -> str: ...\n    def FormatSubDValidity(val: SubD, identifier: str) -> str: ...\n    @overload\n    def FormatSurface(data: Brep) -> str: ...\n    @overload\n    def FormatSurface(data: GH_Surface) -> str: ...\n    def FormatSurfaceValidity(val: Surface, identifier: str) -> str: ...\n    def FormatTransformValidity(val: Transform, identifier: str) -> str: ...\n    @overload\n    def FormatVector(data: Vector3d) -> str: ...\n    @overload\n    def FormatVector(data: GH_Vector) -> str: ...\n    def FormatVectorValidity(val: Vector3d, identifier: str, testZero: bool, testUnit: bool) -> str: ...\n    def RhinoUnitName() -> str: ...\n    def RhinoUnitSymbol() -> str: ...\n    def TreatAsCollection(obj: Object) -> bool: ...\n\n\nclass GH_GetterResult:\n    accept = 0\n    success = 1\n    cancel = 2\n\n\nclass GH_GHALoadingEventArgs:\n    @property\n    def Assembly(self) -> Assembly: ...\n    @property\n    def FileName(self) -> str: ...\n    @property\n    def Icon(self) -> Bitmap: ...\n    @property\n    def Id(self) -> Guid: ...\n    @property\n    def LoadingMechanism(self) -> GH_LoadingMechanism: ...\n    @property\n    def Name(self) -> str: ...\n\n\nclass GH_GHXHarvester:\n    @overload\n    def HarvestBoundingBoxes(file: str) -> List: ...\n    @overload\n    def HarvestBoundingBoxes(archive: GH_Archive) -> List: ...\n    @overload\n    def HarvestBoundingBoxes(node: GH_IReader) -> List: ...\n    @overload\n    def HarvestPivots(file: str) -> List: ...\n    @overload\n    def HarvestPivots(archive: GH_Archive) -> List: ...\n    @overload\n    def HarvestPivots(node: GH_IReader) -> List: ...\n\n\nclass GH_GraphProxy:\n    def __init__(self, nGraph: IGH_Graph, T: Type): ...\n    def CompareTo(self, other: GH_GraphProxy) -> int: ...\n    @property\n    def Description(self) -> str: ...\n    @property\n    def GUID(self) -> Guid: ...\n    @property\n    def Icon(self) -> Image: ...\n    @property\n    def Name(self) -> str: ...\n    @property\n    def Type(self) -> Type: ...\n\n\nclass GH_GuidConflictSolution:\n    Unset = 0\n    Replace = 1\n    ReplaceAll = 2\n    Skip = 3\n    SkipAll = 4\n\n\nclass GH_GuidTable:\n    def __init__(self): ...\n    def Add(self, id: Guid, obj: IGH_ActiveObject) -> None: ...\n    def AllObjects(self) -> List: ...\n    def Clear(self) -> None: ...\n    def Contains(self, id: Guid) -> bool: ...\n    @property\n    def Count(self) -> int: ...\n    @property\n    def IsEmpty(self) -> bool: ...\n    def Objects(self, id: Guid) -> List: ...\n\n\nclass GH_IconDisplayMode:\n    application = 0\n    icon = 1\n    name = 2\n\n\nclass GH_IncrementalParamNameConstructor:\n    def __init__(self, format_mask: str, start_index: int): ...\n    def Current(self) -> str: ...\n    @property\n    def FormatMask(self) -> str: ...\n    def Next(self) -> str: ...\n    def Reset(self) -> None: ...\n    @FormatMask.setter\n    def FormatMask(self, Value: str) -> None: ...\n\n\nclass GH_InstanceDescription:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, other: IGH_InstanceDescription): ...\n    @overload\n    def __init__(self, name: str, nickName: str, description: str, category: str): ...\n    @overload\n    def __init__(self, name: str, nickName: str, description: str, category: str, subCategory: str): ...\n    def CopyFrom(self, other: IGH_InstanceDescription) -> None: ...\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Description(self) -> str: ...\n    @property\n    def HasCategory(self) -> bool: ...\n    @property\n    def HasSubCategory(self) -> bool: ...\n    @property\n    def InstanceDescription(self) -> str: ...\n    @property\n    def InstanceGuid(self) -> Guid: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    @property\n    def NickName(self) -> str: ...\n    @property\n    def SubCategory(self) -> str: ...\n    @overload\n    def NewInstanceGuid(self) -> None: ...\n    @overload\n    def NewInstanceGuid(self, UUID: Guid) -> None: ...\n    def Read(self, reader: GH_IReader) -> bool: ...\n    def ReadFull(self, reader: GH_IReader) -> bool: ...\n    @Category.setter\n    def Category(self, Value: str) -> None: ...\n    @Description.setter\n    def Description(self, Value: str) -> None: ...\n    @Name.setter\n    def Name(self, Value: str) -> None: ...\n    @NickName.setter\n    def NickName(self, Value: str) -> None: ...\n    @SubCategory.setter\n    def SubCategory(self, Value: str) -> None: ...\n    def Write(self, writer: GH_IWriter) -> bool: ...\n    def WriteFull(self, writer: GH_IWriter) -> bool: ...\n\n\nclass GH_LibraryLicense:\n    unset = 0\n    expired = 1\n    alpha = 2\n    beta = 3\n    free = 4\n    opensource = 5\n    trial = 6\n    commercial = 7\n    educational = 8\n    developer = 9\n    reseller = 10\n    other = 11\n\n\nclass GH_LineParser:\n    def ParseLine(self, line: str, action: GH_LineParserAction) -> Tuple[Object, GH_LineParserAction]: ...\n\n\nclass GH_LineParserAction:\n    Include = 0\n    Ignore = 1\n    Abort = 2\n\n\nclass GH_ListUtil:\n    def CountNonNullRefs(L: List) -> int: ...\n    def CountNullRefs(L: List) -> int: ...\n    def EnsureNonNullCount(L: List, N: int) -> bool: ...\n    def FirstNonNullItem(L: List) -> int: ...\n    def RemoveNullRefs(L: List) -> List: ...\n\n\nclass GH_LoadingAttribute:\n    def __init__(self, demand: GH_LoadingDemand): ...\n\n\nclass GH_LoadingDemand:\n    Default = 0\n    ForceCOFF = 1\n    ForceDirect = 2\n    #None = -1\n\n\nclass GH_LoadingException:\n    @overload\n    def __init__(self, name: str, message: str): ...\n    @overload\n    def __init__(self, name: str, ex: Exception): ...\n    @overload\n    def __init__(self, name: str, message: str, type: str): ...\n    @property\n    def Message(self) -> str: ...\n    @property\n    def Name(self) -> str: ...\n    @property\n    def Type(self) -> str: ...\n\n\nclass GH_LoadingInstruction:\n    Proceed = 0\n    Abort = 1\n\n\nclass GH_LoadingMechanism:\n    COFF = 1\n    Direct = 2\n    Unknown = -1\n\n\nclass GH_MarkovChain:\n    def __init__(self): ...\n    def AppendPattern(self, pattern: GH_MarkovPattern) -> None: ...\n    def Clear(self) -> None: ...\n    def Description(self) -> str: ...\n    def ExtendHistory(self, new_id: Guid) -> None: ...\n    @overload\n    def FindPattern(self, id: Guid) -> GH_MarkovPattern: ...\n    @overload\n    def FindPattern(self, id1: Guid, id2: Guid) -> GH_MarkovPattern: ...\n    @overload\n    def FindPattern(self, id1: Guid, id2: Guid, id3: Guid) -> GH_MarkovPattern: ...\n    @property\n    def Level1(self) -> List: ...\n    @property\n    def Level2(self) -> List: ...\n    @property\n    def Level3(self) -> List: ...\n    @property\n    def PatternCount(self) -> int: ...\n    def ReadFromDisc(self) -> None: ...\n    def ReduceDataset(self) -> None: ...\n    def SuggestEvents(self) -> Set(Guid): ...\n    def WriteToDisc(self) -> None: ...\n\n\nclass GH_MarkovOutcome:\n    @overload\n    def __init__(self, newId: Guid): ...\n    @overload\n    def __init__(self, other: GH_MarkovOutcome): ...\n    @overload\n    def __init__(self, newId: Guid, newValence: Int64): ...\n    def DecreaseValence(self) -> None: ...\n    @property\n    def Id(self) -> Guid: ...\n    @property\n    def IsInsignificant(self) -> bool: ...\n    @property\n    def Valence(self) -> Int64: ...\n    def IncreaseValence(self) -> None: ...\n    @Valence.setter\n    def Valence(self, AutoPropertyValue: Int64) -> None: ...\n\n\nclass GH_MarkovPattern:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, pat: Set(Guid)): ...\n    @overload\n    def __init__(self, other: GH_MarkovPattern): ...\n    @overload\n    def AppendOutcome(self, id: Guid) -> None: ...\n    @overload\n    def AppendOutcome(self, outcome: GH_MarkovOutcome) -> None: ...\n    def CompareTo(self, other: GH_MarkovPattern) -> int: ...\n    @property\n    def Depth(self) -> int: ...\n    @property\n    def IsInsignificant(self) -> bool: ...\n    @property\n    def MaximumValence(self) -> Int64: ...\n    @property\n    def Outcomes(self) -> List: ...\n    @property\n    def Pattern(self) -> Set(Guid): ...\n    def RemoveInsignificantOutcomes(self) -> None: ...\n    def Simplify(self) -> None: ...\n\n\nclass GH_MatchLevel:\n    #None = 0\n    Exact = 1\n    Start = 2\n    WordExact = 4\n    WordStart = 8\n    Contains = 16\n    AllClean = 31\n    Fuzzy = 32\n    All = 63\n\n\nclass GH_MatchWeight:\n    Fuzzy = 10\n    Contains = 10\n    WordExact = 100\n    Start = 100\n    WordStart = 100\n    Exact = 100\n\n\nclass GH_MathUtil:\n    @overload\n    def WrapInteger(X: int, upper: int) -> int: ...\n    @overload\n    def WrapInteger(number: int, lower: int, upper: int) -> int: ...\n\n\nclass GH_MemoryBitmap:\n    @overload\n    def __init__(self, bitmap: Bitmap): ...\n    @overload\n    def __init__(self, bitmap: Bitmap, wrap: WrapMode): ...\n    def A(self, x: int, y: int) -> Byte: ...\n    def B(self, x: int, y: int) -> Byte: ...\n    @overload\n    def Colour(self, x: int, y: int) -> Color: ...\n    @overload\n    def Colour(self, x: int, y: int, col: Color) -> None: ...\n    def CopyChannel(self, source: GH_BitmapChannel, target: GH_BitmapChannel) -> None: ...\n    def Filter_AlphaEdges(self, padding: Padding, alpha_override: Byte) -> None: ...\n    @overload\n    def Filter_Blur(self) -> None: ...\n    @overload\n    def Filter_Blur(self, N: int) -> None: ...\n    @overload\n    def Filter_Blur(self, interior_weight: int, exterior_weight: int) -> None: ...\n    @overload\n    def Filter_Blur(self, N: int, interior_weight: int, exterior_weight: int) -> None: ...\n    def Filter_BlurAlpha(self, N: int, interior_weight: int, exterior_weight: int) -> None: ...\n    def Filter_Contrast(self, channel: GH_BitmapChannel, factor: float) -> None: ...\n    def Filter_DitherPattern(self, colour: Color) -> None: ...\n    def Filter_DropShadow(self, offset: Size, blur: int, darkness: float) -> None: ...\n    def Filter_Dullify(self) -> None: ...\n    def Filter_Equalize(self, channel: GH_BitmapChannel, value: Byte) -> None: ...\n    @overload\n    def Filter_GreyScale(self) -> None: ...\n    @overload\n    def Filter_GreyScale(self, amount: float) -> None: ...\n    def Filter_HueScale(self) -> None: ...\n    def Filter_Invert(self, channel: GH_BitmapChannel) -> None: ...\n    def Filter_LumScale(self) -> None: ...\n    @overload\n    def Filter_Multiply(self, channel: GH_BitmapChannel, factor: float) -> None: ...\n    @overload\n    def Filter_Multiply(self, channel: GH_BitmapChannel, factor: float, anchor: Byte) -> None: ...\n    def Filter_SatScale(self) -> None: ...\n    def Filter_Shift(self, channel: GH_BitmapChannel, amount: Byte) -> None: ...\n    def Filter_SpectrumScale(self) -> None: ...\n    def Filter_Tint(self, tint: Color, lum_factor: float, sat_factor: float) -> None: ...\n    def G(self, x: int, y: int) -> Byte: ...\n    @property\n    def HasAlphaChannel(self) -> bool: ...\n    @property\n    def Height(self) -> int: ...\n    @property\n    def SizeOf(self) -> int: ...\n    @property\n    def Width(self) -> int: ...\n    def OpaqueArea(self) -> Rectangle: ...\n    def PadBitmap(bmp: Image, padding: Padding, padding_color: Color) -> Bitmap: ...\n    def R(self, x: int, y: int) -> Byte: ...\n    def Release(self, includeChanges: bool) -> None: ...\n    @overload\n    def Sample(self, x: float, y: float, col: Color) -> Tuple[bool, Color]: ...\n    @overload\n    def Sample(self, x: int, y: int, col: Color) -> Tuple[bool, Color]: ...\n    def ShrinkBitmap(image: Bitmap) -> Bitmap: ...\n\n\nclass GH_NoiseTable:\n    def Permutation(N: int) -> int: ...\n    def Sample(N: int) -> float: ...\n\n\nclass GH_ObjectChangedEventArgs:\n    @overload\n    def __init__(self, eSender: IGH_DocumentObject, eType: GH_ObjectEventType): ...\n    @overload\n    def __init__(self, eSender: IGH_DocumentObject, eCustomDescription: str): ...\n    @overload\n    def __init__(self, eSender: IGH_DocumentObject, eType: GH_ObjectEventType, eTag: Object): ...\n    @overload\n    def __init__(self, eSender: IGH_DocumentObject, eCustomDescription: str, eTag: Object): ...\n    @property\n    def CustomType(self) -> str: ...\n    @property\n    def Sender(self) -> IGH_DocumentObject: ...\n    @property\n    def Tag(self) -> Object: ...\n    @property\n    def Type(self) -> GH_ObjectEventType: ...\n\n\nclass GH_ObjectEventType:\n    Unset = 0\n    NickName = 1\n    NickNameAccepted = 2\n    Icon = 3\n    IconDisplayMode = 4\n    Layout = 5\n    Sources = 6\n    Selected = 7\n    Enabled = 8\n    Preview = 9\n    PersistentData = 10\n    DataMatching = 11\n    DataMapping = 12\n    Options = 13\n    Custom = 2147483647\n\n\nclass GH_ObjectSpecies:\n    none = 0\n    doc_object = 1\n    parameter = 16\n    component = 32\n    group = 64\n    wire = 128\n    grip_in = 256\n    grip_out = 512\n    grip = 768\n    balloon = 1024\n    any = 4294967295\n\n\nclass GH_ObjectType:\n    #None = 0\n    CompiledObject = 1\n    UserObject = 2\n\n\n\n\nclass GH_ParamAccess:\n    item = 0\n    list = 1\n    tree = 2\n\n\nclass GH_ParamData:\n    unknown = 0\n    void = 1\n    local = 2\n    remote = 3\n\n\nclass GH_ParameterContext:\n    def __init__(self, name: str, rhDoc: RhinoDoc, runmode: RunMode): ...\n    @property\n    def IsScripted(self) -> bool: ...\n    @property\n    def Name(self) -> str: ...\n    @property\n    def RhinoDoc(self) -> RhinoDoc: ...\n    @property\n    def SolveIndex(self) -> int: ...\n    @SolveIndex.setter\n    def SolveIndex(self, AutoPropertyValue: int) -> None: ...\n\n\nclass GH_ParameterSide:\n    Input = 0\n    Output = 1\n\n\nclass GH_ParamHashFields:\n    #None = 0\n    Input = 1\n    Output = 2\n    InputAndOutput = 3\n    InstanceId = 4\n    NickName = 8\n    Access = 16\n    TypeId = 32\n    PersistentData = 64\n    Expression = 128\n    TypeHint = 256\n    Sources = 65536\n    Recipients = 131072\n    SourcesAndRecipients = 196608\n    SerialData = 16777216\n    All = 16974335\n\n\nclass GH_ParamKind:\n    unknown = 0\n    floating = 1\n    input = 2\n    output = 3\n\n\nclass GH_ParamServerEventArgs:\n    @property\n    def OriginalArguments(self) -> GH_ObjectChangedEventArgs: ...\n    @property\n    def Parameter(self) -> IGH_Param: ...\n    @property\n    def ParameterIndex(self) -> int: ...\n    @property\n    def ParameterSide(self) -> GH_ParameterSide: ...\n    @property\n    def Server(self) -> GH_ComponentParamServer: ...\n\n\nclass GH_ParamWireDisplay:\n    default = 0\n    faint = 1\n    hidden = 2\n\n\n\n\n\n\nclass GH_PickBox:\n    Window = 0\n    Crossing = 1\n\n\nclass GH_PingDocumentEventArgs:\n    def __init__(self): ...\n    @property\n    def Document(self) -> GH_Document: ...\n    @Document.setter\n    def Document(self, Value: GH_Document) -> None: ...\n\n\nclass GH_PluginFolderType:\n    Core = 0\n    Default = 1\n    RhiFolder = 2\n    UserFolder = 3\n\n\nclass GH_PreviewArgs:\n    @property\n    def DefaultCurveThickness(self) -> int: ...\n    @property\n    def Display(self) -> DisplayPipeline: ...\n    @property\n    def Document(self) -> GH_Document: ...\n    @property\n    def MeshingParameters(self) -> MeshingParameters: ...\n    @property\n    def ShadeMaterial(self) -> DisplayMaterial: ...\n    @property\n    def ShadeMaterial_Selected(self) -> DisplayMaterial: ...\n    @property\n    def Viewport(self) -> RhinoViewport: ...\n    @property\n    def WireColour(self) -> Color: ...\n    @property\n    def WireColour_Selected(self) -> Color: ...\n\n\nclass GH_PreviewBoundary:\n    def __init__(self, points: Set(PointF)): ...\n    @property\n    def Boundary(self) -> Region: ...\n    @property\n    def Limits(self) -> RectangleF: ...\n    @property\n    def Points(self) -> Set(PointF): ...\n    def IsVisible(self, obj: IGH_DocumentObject) -> bool: ...\n    def Read(self, reader: GH_IReader) -> bool: ...\n    def Write(self, writer: GH_IWriter) -> bool: ...\n\n\nclass GH_PreviewExpiredEventArgs:\n    def __init__(self, eForceRedraw: bool): ...\n    @property\n    def ForceRedraw(self) -> bool: ...\n\n\nclass GH_PreviewFilter:\n    #None = 0\n    Selected = 1\n\n\nclass GH_PreviewMesh:\n    #None = 0\n    LowQuality = 1\n    HighQuality = 2\n    Document = 3\n    Custom = 4\n\n\nclass GH_PreviewMeshArgs:\n    def __init__(self, vp: RhinoViewport, pl: DisplayPipeline, mat: DisplayMaterial, meshParams: MeshingParameters): ...\n    @property\n    def Material(self) -> DisplayMaterial: ...\n    @property\n    def MeshingParameters(self) -> MeshingParameters: ...\n    @property\n    def Pipeline(self) -> DisplayPipeline: ...\n    @property\n    def Viewport(self) -> RhinoViewport: ...\n\n\nclass GH_PreviewMode:\n    Disabled = 0\n    Wireframe = 1\n    Shaded = 2\n\n\nclass GH_PreviewUtil:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, enable: bool): ...\n    def AddBox(self, box: Box) -> None: ...\n    def AddBrep(self, brep: Brep) -> None: ...\n    def AddCurve(self, curve: Curve) -> None: ...\n    def AddLine(self, line: Line) -> None: ...\n    def AddMesh(self, mesh: Mesh) -> None: ...\n    def AddPlane(self, plane: Plane) -> None: ...\n    def AddPoint(self, point: Point3d) -> None: ...\n    def AddVector(self, vector: Line) -> None: ...\n    def Clear(self) -> None: ...\n    def Dispose(self) -> None: ...\n    @property\n    def Enabled(self) -> bool: ...\n    @property\n    def WireColour(self) -> Color: ...\n    def Redraw(self) -> None: ...\n    @Enabled.setter\n    def Enabled(self, Value: bool) -> None: ...\n    @WireColour.setter\n    def WireColour(self, Value: Color) -> None: ...\n\n\nclass GH_PreviewWireArgs:\n    def __init__(self, vp: RhinoViewport, pl: DisplayPipeline, col: Color, thickness: int): ...\n    @property\n    def Color(self) -> Color: ...\n    @property\n    def Pipeline(self) -> DisplayPipeline: ...\n    @property\n    def Thickness(self) -> int: ...\n    @property\n    def Viewport(self) -> RhinoViewport: ...\n\n\nclass GH_PrincipalState:\n    CannotBePrincipal = 0\n    IsPrincipal = 1\n    IsNotPrincipal = 2\n\n\nclass GH_Process:\n    @property\n    def Handle() -> IntPtr: ...\n    @property\n    def HandleCount() -> int: ...\n    @property\n    def HasExited() -> bool: ...\n    @property\n    def MaxWorkingSet() -> Int64: ...\n    @property\n    def Name() -> str: ...\n    @property\n    def PeakPrivateBytes() -> Int64: ...\n    @property\n    def PrivateBytes() -> Int64: ...\n    @property\n    def WorkingSet() -> Int64: ...\n\n\nclass GH_ProcessForm:\n    def __init__(self): ...\n    def FormatBytes(B: Int64) -> str: ...\n\n\nclass GH_ProcessStep:\n    PreProcess = 0\n    Process = 1\n    PostProcess = 2\n    Aborted = 3\n\n\nclass GH_ProfilerMode:\n    #None = 0\n    Processor = 1\n    Memory = 2\n\n\nclass GH_RelevantObjectData:\n    def __init__(self, pt: PointF): ...\n    def CreateBalloonData(self, obj: IGH_DocumentObject) -> None: ...\n    def CreateGripData(self, obj: IGH_DocumentObject, is_input: bool) -> None: ...\n    def CreateGroupData(self, group: GH_Group) -> None: ...\n    def CreateObjectData(self, obj: IGH_DocumentObject) -> None: ...\n    def CreateWireData(self) -> None: ...\n    @property\n    def Attributes(self) -> IGH_Attributes: ...\n    @property\n    def Group(self) -> GH_Group: ...\n    @property\n    def IsTopLevelObject(self) -> bool: ...\n    @property\n    def Object(self) -> IGH_DocumentObject: ...\n    @property\n    def ObjectType(self) -> GH_ObjectSpecies: ...\n    @property\n    def Parameter(self) -> IGH_Param: ...\n    @property\n    def Point(self) -> PointF: ...\n    @property\n    def TopLevelObject(self) -> IGH_DocumentObject: ...\n\n\nclass GH_RelevantObjectFilter:\n    #None = 0\n    Groups = 1\n    InputGrips = 2\n    OutputGrips = 4\n    Grips = 6\n    Attributes = 8\n    Wires = 1024\n    All = 2147483647\n\n\nclass GH_RenderArgs:\n    @overload\n    def __init__(self, doc: RhinoDoc, vp: ViewportInfo, geometry: RenderPrimitiveList, id: Guid, materialCache: Dictionary): ...\n    @overload\n    def __init__(self, doc: RhinoDoc, vp: ViewportInfo, geometry: RenderPrimitiveList, id: Guid, matNormal: RenderMaterial, matSelected: RenderMaterial): ...\n    @property\n    def Document(self) -> RhinoDoc: ...\n    @property\n    def Geomety(self) -> RenderPrimitiveList: ...\n    @property\n    def MaterialCache(self) -> Dictionary: ...\n    @property\n    def MaterialNormal(self) -> RenderMaterial: ...\n    @property\n    def MaterialSelected(self) -> RenderMaterial: ...\n    @property\n    def PluginId(self) -> Guid: ...\n    @property\n    def Viewport(self) -> ViewportInfo: ...\n\n\nclass GH_Revision:\n    def __init__(self): ...\n    @property\n    def Date(self) -> DateTime: ...\n    @property\n    def DateTag(self) -> DateTime: ...\n    @property\n    def Description(self) -> str: ...\n    def Read(self, reader: GH_IReader) -> bool: ...\n    @DateTag.setter\n    def DateTag(self, Value: DateTime) -> None: ...\n    @Description.setter\n    def Description(self, Value: str) -> None: ...\n    def ToString(self) -> str: ...\n    def Write(self, writer: GH_IWriter) -> bool: ...\n\n\nclass GH_RuntimeMessage:\n    def __init__(self, nMessage: str, nType: GH_RuntimeMessageLevel, nSource: str): ...\n    @property\n    def Event(self) -> DateTime: ...\n    @property\n    def HasSource(self) -> bool: ...\n    @property\n    def Message(self) -> str: ...\n    @property\n    def Source(self) -> str: ...\n    @property\n    def Type(self) -> GH_RuntimeMessageLevel: ...\n\n\nclass GH_RuntimeMessageLevel:\n    Blank = 0\n    Warning = 10\n    Error = 20\n    Remark = 255\n\n\nclass GH_ScheduleDelegate:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, doc: GH_Document, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, doc: GH_Document) -> None: ...\n\n\nclass GH_ScriptComponentUtilities:\n    def FindAllNameSpaces(asm: Assembly) -> List: ...\n    def FindTopLevelNameSpaces(asm: Assembly) -> List: ...\n    @overload\n    def ReflectType_CS(obj: Object) -> str: ...\n    @overload\n    def ReflectType_CS(obj: Object, method_name: str) -> str: ...\n    @overload\n    def ReflectType_VB(obj: Object) -> str: ...\n    @overload\n    def ReflectType_VB(obj: Object, method_name: str) -> str: ...\n\n\nclass GH_ScriptInstance:\n    def AfterRunScript(self) -> None: ...\n    def BeforeRunScript(self) -> None: ...\n    def DrawViewportMeshes(self, args: IGH_PreviewArgs) -> None: ...\n    def DrawViewportWires(self, args: IGH_PreviewArgs) -> None: ...\n    @property\n    def ClippingBox(self) -> BoundingBox: ...\n    @property\n    def Hidden(self) -> bool: ...\n    @property\n    def IsPreviewCapable(self) -> bool: ...\n    def InvokeRunScript(self, owner: IGH_Component, rhinoDocument: Object, iteration: int, inputs: List, DA: IGH_DataAccess) -> None: ...\n    @Hidden.setter\n    def Hidden(self, Value: bool) -> None: ...\n\n\nclass GH_SearchHit:\n    def __init__(self, obj: IGH_DocumentObject, weight: int): ...\n    def CompareTo(self, other: GH_SearchHit) -> int: ...\n    @property\n    def Object(self) -> IGH_DocumentObject: ...\n    @property\n    def Weight(self) -> int: ...\n\n\nclass GH_SelectionState:\n    Changed = 0\n    Unchanged = 1\n\n\nclass GH_SelectionTopology:\n    #None = 0\n    Convex = 1\n    Concave = 2\n\n\nclass GH_SettingsServer:\n    @overload\n    def __init__(self, databaseName: str): ...\n    @overload\n    def __init__(self, databaseName: str, loadSettings: bool): ...\n    def Clear(self) -> None: ...\n    def ConstainsEntry(self, name: str) -> bool: ...\n    def DeleteValue(self, key: str) -> None: ...\n    def EntryNames(self) -> List: ...\n    def EntryType(self, name: str) -> GH_SettingsType: ...\n    @property\n    def Count(self) -> int: ...\n    @property\n    def DatabaseName(self) -> str: ...\n    @overload\n    def GetValue(self, key: str, default: Byte) -> Byte: ...\n    @overload\n    def GetValue(self, key: str, default: int) -> int: ...\n    @overload\n    def GetValue(self, key: str, default: float) -> float: ...\n    @overload\n    def GetValue(self, key: str, default: DateTime) -> DateTime: ...\n    @overload\n    def GetValue(self, key: str, default: str) -> str: ...\n    @overload\n    def GetValue(self, key: str, default: Size) -> Size: ...\n    @overload\n    def GetValue(self, key: str, default: Point) -> Point: ...\n    @overload\n    def GetValue(self, key: str, default: Rectangle) -> Rectangle: ...\n    @overload\n    def GetValue(self, key: str, default: bool) -> bool: ...\n    @overload\n    def GetValue(self, key: str, default: Color) -> Color: ...\n    def Read(self, reader: GH_IReader) -> bool: ...\n    @overload\n    def SetValue(self, key: str) -> None: ...\n    @overload\n    def SetValue(self, key: str, value: Color) -> None: ...\n    @overload\n    def SetValue(self, key: str, value: Size) -> None: ...\n    @overload\n    def SetValue(self, key: str, value: Point) -> None: ...\n    @overload\n    def SetValue(self, key: str, value: DateTime) -> None: ...\n    @overload\n    def SetValue(self, key: str, value: str) -> None: ...\n    @overload\n    def SetValue(self, key: str, value: float) -> None: ...\n    @overload\n    def SetValue(self, key: str, value: int) -> None: ...\n    @overload\n    def SetValue(self, key: str, value: Byte) -> None: ...\n    @overload\n    def SetValue(self, key: str, value: bool) -> None: ...\n    @overload\n    def SetValue(self, key: str, value: Rectangle) -> None: ...\n    def ShowSettingsBrowser(self, parent: IWin32Window) -> None: ...\n    def Write(self, writer: GH_IWriter) -> bool: ...\n    def WritePersistentSettings(self) -> None: ...\n\n\nclass GH_SettingsType:\n    _null = 0\n    _boolean = 1\n    _byte = 2\n    _integer = 3\n    _double = 4\n    _string = 6\n    _date = 7\n    _color = 8\n    _point = 9\n    _size = 10\n    _rectangle = 11\n    _unknown = -1\n\n\nclass GH_SolutionEventArgs:\n    @property\n    def Document(self) -> GH_Document: ...\n    @property\n    def Duration(self) -> TimeSpan: ...\n    @property\n    def EndTime(self) -> DateTime: ...\n    @property\n    def StartTime(self) -> DateTime: ...\n\n\nclass GH_SolutionExpiredEventArgs:\n    def __init__(self, eRecompute: bool): ...\n    @property\n    def Recompute(self) -> bool: ...\n\n\nclass GH_SolutionMode:\n    Default = 0\n    CommandLine = 1\n    Silent = 2\n\n\nclass GH_SolutionPhase:\n    Blank = 0\n    Collecting = 1\n    Collected = 2\n    Computing = 3\n    Computed = 4\n    Failed = 10\n\n\nclass GH_SolutionSpan:\n    def __init__(self, t0: DateTime, t1: DateTime): ...\n    @property\n    def EndTime(self) -> DateTime: ...\n    @property\n    def StartTime(self) -> DateTime: ...\n\n\nclass GH_State:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, other: GH_State): ...\n    def AddStateObject(self, obj: IGH_StateAwareObject, obj_id: Guid) -> None: ...\n    def ClearStates(self) -> None: ...\n    def CreateStateFromDocument(self, doc: GH_Document) -> int: ...\n    @property\n    def Data(self, id: Guid) -> str: ...\n    @property\n    def Data(self, index: int) -> str: ...\n    @property\n    def LastModified(self) -> DateTime: ...\n    @property\n    def Name(self) -> str: ...\n    @property\n    def StateCount(self) -> int: ...\n    @property\n    def StateData(self) -> SortedList: ...\n    def Read(self, reader: GH_IReader) -> bool: ...\n    def RemoveStateObject(self, obj_id: Guid) -> None: ...\n    @Name.setter\n    def Name(self, Value: str) -> None: ...\n    def Write(self, writer: GH_IWriter) -> bool: ...\n\n\nclass GH_StateServer:\n    def __init__(self, owner: GH_Document): ...\n    @property\n    def Names(self) -> List: ...\n    @property\n    def Owner(self) -> GH_Document: ...\n    def NewStateFromDocument(self) -> GH_State: ...\n    def Read(self, reader: GH_IReader) -> bool: ...\n    def RemoveState(self, index: int) -> bool: ...\n    @overload\n    def RestoreState(self, name: str) -> Tuple[bool, int, int]: ...\n    @overload\n    def RestoreState(self, index: int) -> Tuple[bool, int, int]: ...\n    @overload\n    def RestoreState(self, index: int, recompute: bool) -> Tuple[bool, int, int]: ...\n    def Write(self, writer: GH_IWriter) -> bool: ...\n\n\nclass GH_StateTag:\n    @property\n    def Description(self) -> str: ...\n    @property\n    def Icon(self) -> Bitmap: ...\n    @property\n    def Name(self) -> str: ...\n    @property\n    def Stage(self) -> Rectangle: ...\n    @property\n    def StateDescription(self) -> str: ...\n    def Render(self, graphics: Graphics) -> None: ...\n    @Stage.setter\n    def Stage(self, Value: Rectangle) -> None: ...\n    @StateDescription.setter\n    def StateDescription(self, Value: str) -> None: ...\n\n\nclass GH_StateTagLayoutDirection:\n    Left = 0\n    Right = 1\n\n\nclass GH_StateTagList:\n    def __init__(self): ...\n    @property\n    def BoundingBox(self) -> Rectangle: ...\n    @property\n    def TooltipEnabled(self) -> bool: ...\n    def IsTtipPoint(self, canvas_coordinate: PointF) -> bool: ...\n    def Layout(self, box: Rectangle, direction: GH_StateTagLayoutDirection) -> None: ...\n    def RenderStateTags(self, G: Graphics) -> None: ...\n    def TooltipSetup(self, canvasPoint: PointF, e: GH_TooltipDisplayEventArgs) -> None: ...\n\n\nclass GH_StringMatcher:\n    def __init__(self): ...\n    @overload\n    def ComputeWeight(value: str, key: str, comp: StringComparison) -> int: ...\n    @overload\n    def ComputeWeight(value: str, key: str, level: GH_MatchLevel, comp: StringComparison) -> int: ...\n    def LevenshteinDistance(A: str, B: str) -> int: ...\n\n\nclass GH_StringPattern:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, char_pool: str): ...\n    @overload\n    def __init__(self, char_pool: str, depth: int): ...\n    def Current(self) -> str: ...\n    @property\n    def FormatMask(self) -> str: ...\n    @property\n    def StackDepth(self) -> int: ...\n    def Next(self) -> str: ...\n    def Reset(self) -> None: ...\n    @FormatMask.setter\n    def FormatMask(self, Value: str) -> None: ...\n    @StackDepth.setter\n    def StackDepth(self, Value: int) -> None: ...\n    @overload\n    def SetCharPool(self, char_pool: str) -> None: ...\n    @overload\n    def SetCharPool(self, char_pool: Iterable[str]) -> None: ...\n\n\n\n\nclass GH_TimeKind:\n    Unset = 0\n    Mixed = 1\n    PureTime = 2\n    PureDate = 3\n    DateAndTime = 4\n\n\nclass GH_TypeLib:\n    pass\n\n\nclass GH_UndoOperation:\n    ClearUndoStack = 0\n    ClearRedoStack = 1\n    RecordAdded = 2\n    RecordRemoved = 3\n    Undo = 4\n    Redo = 5\n\n\nclass GH_UndoUtil:\n    @overload\n    def CreateAddObjectEvent(self, name: str, objs: Iterable[IGH_DocumentObject]) -> GH_UndoRecord: ...\n    @overload\n    def CreateAddObjectEvent(self, name: str, obj: IGH_DocumentObject) -> GH_UndoRecord: ...\n    def CreateAddStateEvent(self, name: str, stateIndex: int, state: GH_State) -> GH_UndoRecord: ...\n    def CreateEnabledEvent(self, name: str, obj: IGH_ActiveObject) -> GH_UndoRecord: ...\n    def CreateGenericObjectEvent(self, name: str, obj: IGH_DocumentObject) -> GH_UndoRecord: ...\n    @overload\n    def CreateLayoutEvent(self, name: str, obj: IGH_DocumentObject) -> GH_UndoRecord: ...\n    @overload\n    def CreateLayoutEvent(self, name: str, objs: Iterable[IGH_DocumentObject]) -> GH_UndoRecord: ...\n    def CreateNickNameEvent(self, name: str, obj: IGH_DocumentObject) -> GH_UndoRecord: ...\n    def CreatePersistentDataEvent(self, name: str, obj: GH_PersistentParam) -> GH_UndoRecord: ...\n    @overload\n    def CreatePivotEvent(self, name: str, obj: IGH_DocumentObject) -> GH_UndoRecord: ...\n    @overload\n    def CreatePivotEvent(self, name: str, objs: Iterable[IGH_DocumentObject]) -> GH_UndoRecord: ...\n    def CreatePreviewEvent(self, name: str, obj: IGH_ActiveObject) -> GH_UndoRecord: ...\n    @overload\n    def CreateRemoveObjectEvent(self, name: str, objs: Iterable[IGH_DocumentObject]) -> GH_UndoRecord: ...\n    @overload\n    def CreateRemoveObjectEvent(self, name: str, obj: IGH_DocumentObject) -> GH_UndoRecord: ...\n    def CreateRemoveStateEvent(self, name: str, stateIndex: int, state: GH_State) -> GH_UndoRecord: ...\n    def CreateReplaceStateEvent(self, name: str, stateIndex: int, oldState: GH_State, newState: GH_State) -> GH_UndoRecord: ...\n    @overload\n    def CreateWireEvent(self, name: str, param: IGH_Param) -> GH_UndoRecord: ...\n    @overload\n    def CreateWireEvent(self, name: str, params: Iterable[IGH_Param]) -> GH_UndoRecord: ...\n    def MergeRecords(self, count: int) -> bool: ...\n    @overload\n    def RecordAddObjectEvent(self, name: str, obj: IGH_DocumentObject) -> Guid: ...\n    @overload\n    def RecordAddObjectEvent(self, name: str, objs: Iterable[IGH_DocumentObject]) -> Guid: ...\n    def RecordAddStateEvent(self, name: str, stateIndex: int, state: GH_State) -> Guid: ...\n    def RecordEnabledEvent(self, name: str, obj: IGH_ActiveObject) -> Guid: ...\n    @overload\n    def RecordEvent(self, record: GH_UndoRecord) -> Guid: ...\n    @overload\n    def RecordEvent(self, name: str, actions: Iterable[IGH_UndoAction]) -> Guid: ...\n    @overload\n    def RecordEvent(self, name: str, action: IGH_UndoAction) -> Guid: ...\n    @overload\n    def RecordEvent(self, name: str, actions: Set(IGH_UndoAction)) -> Guid: ...\n    def RecordGenericObjectEvent(self, name: str, obj: IGH_DocumentObject) -> Guid: ...\n    @overload\n    def RecordLayoutEvent(self, name: str, objs: Iterable[IGH_DocumentObject]) -> Guid: ...\n    @overload\n    def RecordLayoutEvent(self, name: str, obj: IGH_DocumentObject) -> Guid: ...\n    def RecordNickNameEvent(self, name: str, obj: IGH_DocumentObject) -> Guid: ...\n    def RecordPersistentDataEvent(self, name: str, obj: GH_PersistentParam) -> Guid: ...\n    @overload\n    def RecordPivotEvent(self, name: str, objs: Iterable[IGH_DocumentObject]) -> Guid: ...\n    @overload\n    def RecordPivotEvent(self, name: str, obj: IGH_DocumentObject) -> Guid: ...\n    def RecordPreviewEvent(self, name: str, obj: IGH_ActiveObject) -> Guid: ...\n    @overload\n    def RecordRemoveObjectEvent(self, name: str, objs: Iterable[IGH_DocumentObject]) -> Guid: ...\n    @overload\n    def RecordRemoveObjectEvent(self, name: str, obj: IGH_DocumentObject) -> Guid: ...\n    def RecordRemoveStateEvent(self, name: str, stateIndex: int, state: GH_State) -> Guid: ...\n    def RecordReplaceStateEvent(self, name: str, stateIndex: int, oldState: GH_State, newState: GH_State) -> Guid: ...\n    @overload\n    def RecordWireEvent(self, name: str, params: Iterable[IGH_Param]) -> Guid: ...\n    @overload\n    def RecordWireEvent(self, name: str, param: IGH_Param) -> Guid: ...\n\n\nclass GH_UpgradeUtil:\n    def __init__(self): ...\n    @overload\n    def MigrateInputParameters(source: IGH_Component, target: IGH_Component) -> bool: ...\n    @overload\n    def MigrateInputParameters(source: IGH_Component, target: IGH_Component, index0: Set(int), index1: Set(int)) -> bool: ...\n    @overload\n    def MigrateOutputParameters(source: IGH_Component, target: IGH_Component) -> bool: ...\n    @overload\n    def MigrateOutputParameters(source: IGH_Component, target: IGH_Component, index0: Set(int), index1: Set(int)) -> bool: ...\n    @overload\n    def MigrateRecipients(from_: IGH_Param, to: IGH_Param) -> int: ...\n    @overload\n    def MigrateRecipients(recipients: Iterable[IGH_Param], target: IGH_Param) -> int: ...\n    @overload\n    def MigrateSources(from_: IGH_Param, to: IGH_Param) -> int: ...\n    @overload\n    def MigrateSources(sources: Iterable[IGH_Param], target: IGH_Param) -> int: ...\n    def ReplaceInputParameters(source: IGH_Component, target: IGH_Component) -> None: ...\n    def ReplaceOutputParameters(source: IGH_Component, target: IGH_Component) -> None: ...\n    @overload\n    def SwapComponents(oldComponent: IGH_Component, newComponent: IGH_Component) -> bool: ...\n    @overload\n    def SwapComponents(oldComponent: IGH_Component, newComponentGuid: Guid) -> IGH_Component: ...\n    @overload\n    def SwapComponents(oldComponent: IGH_Component, newComponent: IGH_Component, migrateParameters: bool) -> bool: ...\n    @overload\n    def SwapComponents(oldComponent: IGH_Component, newComponentGuid: Guid, migrateParameters: bool) -> IGH_Component: ...\n\n\nclass GH_UserObject:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, source_file: str): ...\n    def Clear(self) -> None: ...\n    def CreateDefaultPath(self, avoid_conflict: bool) -> None: ...\n    @property\n    def BaseGuid(self) -> Guid: ...\n    @property\n    def Data(self) -> Set(Byte): ...\n    @property\n    def Description(self) -> GH_InstanceDescription: ...\n    @property\n    def Exposure(self) -> GH_Exposure: ...\n    @property\n    def Guid(self) -> Guid: ...\n    @property\n    def Icon(self) -> Bitmap: ...\n    @property\n    def Path(self) -> str: ...\n    def InstantiateObject(self) -> IGH_DocumentObject: ...\n    def ReadFromFile(self) -> None: ...\n    def SaveToFile(self) -> bool: ...\n    @BaseGuid.setter\n    def BaseGuid(self, Value: Guid) -> None: ...\n    @Data.setter\n    def Data(self, Value: Set(Byte)) -> None: ...\n    @Description.setter\n    def Description(self, Value: GH_InstanceDescription) -> None: ...\n    @Exposure.setter\n    def Exposure(self, Value: GH_Exposure) -> None: ...\n    @Guid.setter\n    def Guid(self, Value: Guid) -> None: ...\n    @Icon.setter\n    def Icon(self, Value: Bitmap) -> None: ...\n    @Path.setter\n    def Path(self, Value: str) -> None: ...\n    def SetDataFromObject(self, obj: IGH_DocumentObject) -> None: ...\n\n\n\n\nclass GH_VarParamEventArgs:\n    @overload\n    def __init__(self, n_param: IGH_Param, n_side: GH_VarParamSide): ...\n    @overload\n    def __init__(self, n_param: IGH_Param, n_side: GH_VarParamSide, n_index: int): ...\n    @property\n    def Index(self) -> int: ...\n    @property\n    def Param(self) -> IGH_Param: ...\n    @property\n    def Side(self) -> GH_VarParamSide: ...\n\n\nclass GH_VarParamSide:\n    Input = 0\n    Output = 1\n\n\nclass GH_WireTopology:\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, source_id: Guid, target_id: Guid): ...\n    @overload\n    def __init__(self, source: IGH_Param, target: IGH_Param): ...\n    @overload\n    def __init__(self, target: IGH_Param, index: int): ...\n    @overload\n    def __init__(self, source_id: Guid, target_id: Guid, source_index: int): ...\n    def DestroyConnection(self, doc: GH_Document) -> None: ...\n    def EnsureConnection(self, doc: GH_Document) -> None: ...\n    @property\n    def SourceIndex(self) -> int: ...\n    @property\n    def SourceParameterID(self) -> Guid: ...\n    @property\n    def TargetParameterID(self) -> Guid: ...\n    @property\n    def ValidIndex(self) -> bool: ...\n    def Read(self, reader: GH_IReader) -> bool: ...\n    def Write(self, writer: GH_IWriter) -> bool: ...\n\n\nclass GH_WireTopologyDiagram:\n    def __init__(self): ...\n    @overload\n    def Add(self, wire: GH_WireTopology, filter_duplicates: bool) -> None: ...\n    @overload\n    def AppendDiagram(self, doc: GH_Document) -> None: ...\n    @overload\n    def AppendDiagram(self, objs: Iterable[IGH_DocumentObject]) -> None: ...\n    @overload\n    def AppendDiagram(self, obj: IGH_DocumentObject) -> None: ...\n    def DestroyConnections(self, doc: GH_Document, throw_exceptions: bool) -> None: ...\n    def EnsureConnections(self, doc: GH_Document, throw_exceptions: bool) -> None: ...\n    def Read(self, reader: GH_IReader) -> bool: ...\n    def Write(self, writer: GH_IWriter) -> bool: ...\n\n\nclass GH_ZuiAction:\n    @property\n    def Name(self) -> str: ...\n    @property\n    def TooltipEnabled(self) -> bool: ...\n    def IsTooltipRegion(self, canvasPoint: PointF) -> bool: ...\n    def Perform(self) -> None: ...\n    def SetupTooltip(self, canvasPoint: PointF, e: GH_TooltipDisplayEventArgs) -> None: ...\n\n\nclass GHAFileLoadedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_GHALoadingEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_GHALoadingEventArgs) -> None: ...\n\n\nclass IGH_ActiveObject:\n    def AddRuntimeMessage(self, Type: GH_RuntimeMessageLevel, Message: str) -> None: ...\n    def ClearData(self) -> None: ...\n    def ClearRuntimeMessages(self) -> None: ...\n    def CollectData(self) -> None: ...\n    def ComputeData(self) -> None: ...\n    def DependsOn(self, PotentialSource: IGH_ActiveObject) -> bool: ...\n    @property\n    def IsDataProvider(self) -> bool: ...\n    @property\n    def Locked(self) -> bool: ...\n    @property\n    def MutableNickName(self) -> bool: ...\n    @property\n    def Phase(self) -> GH_SolutionPhase: ...\n    @property\n    def ProcessorTime(self) -> TimeSpan: ...\n    @property\n    def RuntimeMessageLevel(self) -> GH_RuntimeMessageLevel: ...\n    def RegisterRemoteIDs(self, id_list: GH_GuidTable) -> None: ...\n    def RuntimeMessages(self, level: GH_RuntimeMessageLevel) -> List[str]: ...\n    def SDKCompliancy(self, exeVersion: int, exeServiceRelease: int) -> bool: ...\n    @Locked.setter\n    def Locked(self, Value: bool) -> None: ...\n    @MutableNickName.setter\n    def MutableNickName(self, Value: bool) -> None: ...\n    @Phase.setter\n    def Phase(self, Value: GH_SolutionPhase) -> None: ...\n\n\nclass IGH_Attributes:\n    def AppendToAttributeTree(self, attributes: List) -> None: ...\n    def ExpireLayout(self) -> None: ...\n    @property\n    def AllowMessageBalloon(self) -> bool: ...\n    @property\n    def Bounds(self) -> RectangleF: ...\n    @property\n    def DocObject(self) -> IGH_DocumentObject: ...\n    @property\n    def GetTopLevel(self) -> IGH_Attributes: ...\n    @property\n    def HasInputGrip(self) -> bool: ...\n    @property\n    def HasOutputGrip(self) -> bool: ...\n    @property\n    def InputGrip(self) -> PointF: ...\n    @property\n    def InstanceGuid(self) -> Guid: ...\n    @property\n    def IsTopLevel(self) -> bool: ...\n    @property\n    def OutputGrip(self) -> PointF: ...\n    @property\n    def Parent(self) -> IGH_Attributes: ...\n    @property\n    def PathName(self) -> str: ...\n    @property\n    def Pivot(self) -> PointF: ...\n    @property\n    def Selected(self) -> bool: ...\n    def InvalidateCanvas(self, canvas: GH_Canvas, e: GH_CanvasMouseEvent) -> bool: ...\n    def IsMenuRegion(self, point: PointF) -> bool: ...\n    @overload\n    def IsPickRegion(self, point: PointF) -> bool: ...\n    @overload\n    def IsPickRegion(self, box: RectangleF, method: GH_PickBox) -> bool: ...\n    @overload\n    def NewInstanceGuid(self) -> None: ...\n    @overload\n    def NewInstanceGuid(self, newID: Guid) -> None: ...\n    def PerformLayout(self) -> None: ...\n    def RenderToCanvas(self, canvas: GH_Canvas, channel: GH_CanvasChannel) -> None: ...\n    @Bounds.setter\n    def Bounds(self, Value: RectangleF) -> None: ...\n    @Parent.setter\n    def Parent(self, Value: IGH_Attributes) -> None: ...\n    @Pivot.setter\n    def Pivot(self, Value: PointF) -> None: ...\n    @Selected.setter\n    def Selected(self, Value: bool) -> None: ...\n\n\nclass IGH_Author:\n    @property\n    def Address(self) -> str: ...\n    @property\n    def Company(self) -> str: ...\n    @property\n    def Copyright(self) -> str: ...\n    @property\n    def Email(self) -> str: ...\n    @property\n    def IsEmpty(self) -> bool: ...\n    @property\n    def Name(self) -> str: ...\n    @property\n    def Phone(self) -> str: ...\n    @property\n    def Website(self) -> str: ...\n\n\nclass IGH_BakeAwareData:\n    def BakeGeometry(self, doc: RhinoDoc, att: ObjectAttributes) -> Tuple[bool, Guid]: ...\n\n\nclass IGH_BakeAwareObject:\n    @overload\n    def BakeGeometry(self, doc: RhinoDoc, obj_ids: List) -> None: ...\n    @overload\n    def BakeGeometry(self, doc: RhinoDoc, att: ObjectAttributes, obj_ids: List) -> None: ...\n    @property\n    def IsBakeCapable(self) -> bool: ...\n\n\nclass IGH_Component:\n    @property\n    def DataComparison(self) -> GH_DataComparison: ...\n    @property\n    def InConstructor(self) -> bool: ...\n    @property\n    def IsValidMasterParameterIndex(self) -> bool: ...\n    @property\n    def MasterParameterIndex(self) -> int: ...\n    @property\n    def Message(self) -> str: ...\n    @property\n    def Params(self) -> GH_ComponentParamServer: ...\n    @property\n    def RunCount(self) -> int: ...\n    @DataComparison.setter\n    def DataComparison(self, Value: GH_DataComparison) -> None: ...\n    @MasterParameterIndex.setter\n    def MasterParameterIndex(self, Value: int) -> None: ...\n    @Message.setter\n    def Message(self, Value: str) -> None: ...\n\n\nclass IGH_ContextualParameter:\n    def AssignContextualData(self, data: IEnumerable) -> None: ...\n    def AutoAssignContextualData(self, context: GH_ParameterContext) -> bool: ...\n    @property\n    def AtLeast(self) -> int: ...\n    @property\n    def AtMost(self) -> int: ...\n    @property\n    def ContextualData(self) -> Iterable[Object]: ...\n    @property\n    def Immediate(self) -> bool: ...\n    @property\n    def Prompt(self) -> str: ...\n\n\nclass IGH_DataAccess:\n    def AbortComponentSolution(self) -> None: ...\n    def BlitData(self, paramIndex: int, tree: GH_Structure, overwrite: bool) -> bool: ...\n    @overload\n    def DisableGapLogic(self) -> None: ...\n    @overload\n    def DisableGapLogic(self, paramIndex: int) -> None: ...\n    @property\n    def Iteration(self) -> int: ...\n    @overload\n    def GetData(self, name: str, destination: T) -> Tuple[bool, T]: ...\n    @overload\n    def GetData(self, index: int, destination: T) -> Tuple[bool, T]: ...\n    @overload\n    def GetDataList(self, name: str, list: List) -> bool: ...\n    @overload\n    def GetDataList(self, index: int, list: List) -> bool: ...\n    @overload\n    def GetDataTree(self, index: int) -> Tuple[bool, GH_Structure]: ...\n    @overload\n    def GetDataTree(self, name: str) -> Tuple[bool, GH_Structure]: ...\n    def IncrementIteration(self) -> None: ...\n    def ParameterTargetIndex(self, paramIndex: int) -> int: ...\n    def ParameterTargetPath(self, paramIndex: int) -> GH_Path: ...\n    @overload\n    def SetData(self, paramIndex: int, data: Object) -> bool: ...\n    @overload\n    def SetData(self, paramName: str, data: Object) -> bool: ...\n    @overload\n    def SetData(self, paramIndex: int, data: Object, itemIndexOverride: int) -> bool: ...\n    @overload\n    def SetDataList(self, paramIndex: int, data: IEnumerable) -> bool: ...\n    @overload\n    def SetDataList(self, paramName: str, data: IEnumerable) -> bool: ...\n    @overload\n    def SetDataList(self, paramIndex: int, data: IEnumerable, listIndexOverride: int) -> bool: ...\n    @overload\n    def SetDataTree(self, paramIndex: int, tree: IGH_DataTree) -> bool: ...\n    @overload\n    def SetDataTree(self, paramIndex: int, tree: IGH_Structure) -> bool: ...\n    def Util_CountNonNullRefs(self, L: List) -> int: ...\n    def Util_CountNullRefs(self, L: List) -> int: ...\n    def Util_EnsureNonNullCount(self, L: List, N: int) -> bool: ...\n    def Util_FirstNonNullItem(self, L: List) -> int: ...\n    def Util_RemoveNullRefs(self, L: List) -> List: ...\n\n\nclass IGH_DebugDescription:\n    def AppendToDebugLog(self, writer: GH_DebugDescriptionWriter) -> None: ...\n\n\nclass IGH_DocumentObject:\n    def add_AttributesChanged(self, obj: AttributesChangedEventHandler) -> None: ...\n    def add_DisplayExpired(self, obj: DisplayExpiredEventHandler) -> None: ...\n    def add_ObjectChanged(self, obj: ObjectChangedEventHandler) -> None: ...\n    def add_PingDocument(self, obj: PingDocumentEventHandler) -> None: ...\n    def add_PreviewExpired(self, obj: PreviewExpiredEventHandler) -> None: ...\n    def add_SolutionExpired(self, obj: SolutionExpiredEventHandler) -> None: ...\n    def AddedToDocument(self, document: GH_Document) -> None: ...\n    def AppendMenuItems(self, menu: ToolStripDropDown) -> bool: ...\n    def CreateAttributes(self) -> None: ...\n    def DocumentContextChanged(self, document: GH_Document, context: GH_DocumentContext) -> None: ...\n    def ExpirePreview(self, redraw: bool) -> None: ...\n    def ExpireSolution(self, recompute: bool) -> None: ...\n    @property\n    def Attributes(self) -> IGH_Attributes: ...\n    @property\n    def ComponentGuid(self) -> Guid: ...\n    @property\n    def Exposure(self) -> GH_Exposure: ...\n    @property\n    def Icon_24x24(self) -> Bitmap: ...\n    @property\n    def Icon_24x24_Locked(self) -> Bitmap: ...\n    @property\n    def IconDisplayMode(self) -> GH_IconDisplayMode: ...\n    @property\n    def Obsolete(self) -> bool: ...\n    def IsolateObject(self) -> None: ...\n    def MovedBetweenDocuments(self, oldDocument: GH_Document, newDocument: GH_Document) -> None: ...\n    def OnAttributesChanged(self) -> None: ...\n    def OnDisplayExpired(self, redraw: bool) -> None: ...\n    @overload\n    def OnObjectChanged(self, customEvent: str) -> None: ...\n    @overload\n    def OnObjectChanged(self, e: GH_ObjectChangedEventArgs) -> None: ...\n    @overload\n    def OnObjectChanged(self, eventType: GH_ObjectEventType) -> None: ...\n    @overload\n    def OnObjectChanged(self, eventType: GH_ObjectEventType, tag: Object) -> None: ...\n    @overload\n    def OnObjectChanged(self, customEvent: str, tag: Object) -> None: ...\n    def OnPingDocument(self) -> GH_Document: ...\n    def OnPreviewExpired(self, redraw: bool) -> None: ...\n    def OnSolutionExpired(self, recompute: bool) -> None: ...\n    @overload\n    def RecordUndoEvent(self, record: GH_UndoRecord) -> None: ...\n    @overload\n    def RecordUndoEvent(self, undoName: str) -> Guid: ...\n    @overload\n    def RecordUndoEvent(self, undoName: str, action: IGH_UndoAction) -> Guid: ...\n    def remove_AttributesChanged(self, obj: AttributesChangedEventHandler) -> None: ...\n    def remove_DisplayExpired(self, obj: DisplayExpiredEventHandler) -> None: ...\n    def remove_ObjectChanged(self, obj: ObjectChangedEventHandler) -> None: ...\n    def remove_PingDocument(self, obj: PingDocumentEventHandler) -> None: ...\n    def remove_PreviewExpired(self, obj: PreviewExpiredEventHandler) -> None: ...\n    def remove_SolutionExpired(self, obj: SolutionExpiredEventHandler) -> None: ...\n    def RemovedFromDocument(self, document: GH_Document) -> None: ...\n    @Attributes.setter\n    def Attributes(self, Value: IGH_Attributes) -> None: ...\n    @IconDisplayMode.setter\n    def IconDisplayMode(self, Value: GH_IconDisplayMode) -> None: ...\n    @overload\n    def TriggerAutoSave(self) -> None: ...\n    @overload\n    def TriggerAutoSave(self, trigger: GH_AutoSaveTrigger) -> None: ...\n    @overload\n    def TriggerAutoSave(self, id: Guid) -> None: ...\n    @overload\n    def TriggerAutoSave(self, trigger: GH_AutoSaveTrigger, id: Guid) -> None: ...\n\n\nclass IGH_DocumentOwner:\n    def DocumentClosed(self, document: GH_Document) -> None: ...\n    def DocumentModified(self, document: GH_Document) -> None: ...\n    def OwnerDocument(self) -> GH_Document: ...\n\n\nclass IGH_EventConsumer:\n    def IsRelevantEvent(self, obj: RhinoObject) -> bool: ...\n    def PartialExpiration(self, server: GH_CustomEventServer) -> None: ...\n    def TotalExpiration(self, server: GH_CustomEventServer) -> None: ...\n\n\nclass IGH_InitCodeAware:\n    def SetInitCode(self, code: str) -> None: ...\n\n\nclass IGH_InstanceDescription:\n    @property\n    def Category(self) -> str: ...\n    @property\n    def Description(self) -> str: ...\n    @property\n    def HasCategory(self) -> bool: ...\n    @property\n    def HasSubCategory(self) -> bool: ...\n    @property\n    def InstanceDescription(self) -> str: ...\n    @property\n    def InstanceGuid(self) -> Guid: ...\n    @property\n    def Keywords(self) -> Iterable[str]: ...\n    @property\n    def Name(self) -> str: ...\n    @property\n    def NickName(self) -> str: ...\n    @property\n    def SubCategory(self) -> str: ...\n    @overload\n    def NewInstanceGuid(self) -> None: ...\n    @overload\n    def NewInstanceGuid(self, UUID: Guid) -> None: ...\n    @Category.setter\n    def Category(self, Value: str) -> None: ...\n    @Description.setter\n    def Description(self, Value: str) -> None: ...\n    @Name.setter\n    def Name(self, Value: str) -> None: ...\n    @NickName.setter\n    def NickName(self, Value: str) -> None: ...\n    @SubCategory.setter\n    def SubCategory(self, Value: str) -> None: ...\n\n\nclass IGH_InstanceGuidDependent:\n    def InstanceGuidsChanged(self, map: SortedDictionary) -> None: ...\n\n\nclass IGH_ObjectProxy:\n    def CreateInstance(self) -> IGH_DocumentObject: ...\n    def DuplicateProxy(self) -> IGH_ObjectProxy: ...\n    @property\n    def Desc(self) -> IGH_InstanceDescription: ...\n    @property\n    def Exposure(self) -> GH_Exposure: ...\n    @property\n    def Guid(self) -> Guid: ...\n    @property\n    def Icon(self) -> Bitmap: ...\n    @property\n    def Kind(self) -> GH_ObjectType: ...\n    @property\n    def LibraryGuid(self) -> Guid: ...\n    @property\n    def Location(self) -> str: ...\n    @property\n    def Obsolete(self) -> bool: ...\n    @property\n    def SDKCompliant(self) -> bool: ...\n    @property\n    def Type(self) -> Type: ...\n    @Exposure.setter\n    def Exposure(self, Value: GH_Exposure) -> None: ...\n\n\nclass IGH_Param:\n    @overload\n    def AddSource(self, source: IGH_Param) -> None: ...\n    @overload\n    def AddSource(self, source: IGH_Param, index: int) -> None: ...\n    def AddVolatileData(self, path: GH_Path, index: int, data: Object) -> bool: ...\n    def AddVolatileDataList(self, path: GH_Path, list: IEnumerable) -> bool: ...\n    def AddVolatileDataTree(self, tree: IGH_Structure) -> bool: ...\n    def ClearProxySources(self) -> None: ...\n    def CreateProxySources(self) -> None: ...\n    @property\n    def Access(self) -> GH_ParamAccess: ...\n    @property\n    def DataMapping(self) -> GH_DataMapping: ...\n    @property\n    def DataType(self) -> GH_ParamData: ...\n    @property\n    def HasProxySources(self) -> bool: ...\n    @property\n    def Kind(self) -> GH_ParamKind: ...\n    @property\n    def Optional(self) -> bool: ...\n    @property\n    def ProxySourceCount(self) -> int: ...\n    @property\n    def Recipients(self) -> List[IGH_Param]: ...\n    @property\n    def Reverse(self) -> bool: ...\n    @property\n    def Simplify(self) -> bool: ...\n    @property\n    def SourceCount(self) -> int: ...\n    @property\n    def Sources(self) -> List[IGH_Param]: ...\n    @property\n    def StateTags(self) -> GH_StateTagList: ...\n    @property\n    def Type(self) -> Type: ...\n    @property\n    def TypeName(self) -> str: ...\n    @property\n    def VolatileData(self) -> IGH_Structure: ...\n    @property\n    def VolatileDataCount(self) -> int: ...\n    @property\n    def WireDisplay(self) -> GH_ParamWireDisplay: ...\n    def RelinkProxySources(self, document: GH_Document) -> bool: ...\n    def RemoveAllSources(self) -> None: ...\n    def RemoveEffects(self) -> None: ...\n    @overload\n    def RemoveSource(self, source: IGH_Param) -> None: ...\n    @overload\n    def RemoveSource(self, source_id: Guid) -> None: ...\n    @overload\n    def ReplaceSource(self, old_source: IGH_Param, new_source: IGH_Param) -> None: ...\n    @overload\n    def ReplaceSource(self, old_source_id: Guid, new_source: IGH_Param) -> None: ...\n    @Access.setter\n    def Access(self, Value: GH_ParamAccess) -> None: ...\n    @DataMapping.setter\n    def DataMapping(self, Value: GH_DataMapping) -> None: ...\n    @Optional.setter\n    def Optional(self, Value: bool) -> None: ...\n    @Reverse.setter\n    def Reverse(self, Value: bool) -> None: ...\n    @Simplify.setter\n    def Simplify(self, Value: bool) -> None: ...\n    @WireDisplay.setter\n    def WireDisplay(self, Value: GH_ParamWireDisplay) -> None: ...\n\n\nclass IGH_ParamNameConstructor:\n    def Current(self) -> str: ...\n    def Next(self) -> str: ...\n    def Reset(self) -> None: ...\n\n\nclass IGH_ParamWithPostProcess:\n    def PostProcessData(self) -> None: ...\n\n\nclass IGH_PreviewArgs:\n    @property\n    def DefaultCurveThickness(self) -> int: ...\n    @property\n    def Display(self) -> DisplayPipeline: ...\n    @property\n    def Document(self) -> GH_Document: ...\n    @property\n    def MeshingParameters(self) -> MeshingParameters: ...\n    @property\n    def ShadeMaterial(self) -> DisplayMaterial: ...\n    @property\n    def ShadeMaterial_Selected(self) -> DisplayMaterial: ...\n    @property\n    def Viewport(self) -> RhinoViewport: ...\n    @property\n    def WireColour(self) -> Color: ...\n    @property\n    def WireColour_Selected(self) -> Color: ...\n\n\nclass IGH_PreviewData:\n    def DrawViewportMeshes(self, args: GH_PreviewMeshArgs) -> None: ...\n    def DrawViewportWires(self, args: GH_PreviewWireArgs) -> None: ...\n    @property\n    def ClippingBox(self) -> BoundingBox: ...\n\n\nclass IGH_PreviewMeshData:\n    def DestroyPreviewMeshes(self) -> None: ...\n    def GetPreviewMeshes(self) -> Set(Mesh): ...\n\n\nclass IGH_PreviewObject:\n    def DrawViewportMeshes(self, args: IGH_PreviewArgs) -> None: ...\n    def DrawViewportWires(self, args: IGH_PreviewArgs) -> None: ...\n    @property\n    def ClippingBox(self) -> BoundingBox: ...\n    @property\n    def Hidden(self) -> bool: ...\n    @property\n    def IsPreviewCapable(self) -> bool: ...\n    @Hidden.setter\n    def Hidden(self, Value: bool) -> None: ...\n\n\nclass IGH_ProxyParameter:\n    @property\n    def ProxyGuid(self) -> Guid: ...\n\n\nclass IGH_RenderAwareData:\n    def AppendRenderGeometry(self, args: GH_RenderArgs, material: RenderMaterial) -> None: ...\n\n\nclass IGH_ScriptInstance:\n    def AfterRunScript(self) -> None: ...\n    def BeforeRunScript(self) -> None: ...\n    def InvokeRunScript(self, owner: IGH_Component, rhinoDocument: Object, iteration: int, inputs: List, DA: IGH_DataAccess) -> None: ...\n\n\nclass IGH_StateAwareObject:\n    def LoadState(self, state: str) -> None: ...\n    def SaveState(self) -> str: ...\n\n\nclass IGH_StateTag:\n    @property\n    def Description(self) -> str: ...\n    @property\n    def Icon(self) -> Bitmap: ...\n    @property\n    def Name(self) -> str: ...\n    @property\n    def Stage(self) -> Rectangle: ...\n    @property\n    def StateDescription(self) -> str: ...\n    def Render(self, graphics: Graphics) -> None: ...\n    @Stage.setter\n    def Stage(self, Value: Rectangle) -> None: ...\n    @StateDescription.setter\n    def StateDescription(self, Value: str) -> None: ...\n\n\nclass IGH_SyncObject:\n    pass\n\n\nclass IGH_TaskCapableComponent:\n    @property\n    def InPreSolve(self) -> bool: ...\n    @property\n    def UseTasks(self) -> bool: ...\n    def RequestTaskCancellation(self) -> None: ...\n    @InPreSolve.setter\n    def InPreSolve(self, Value: bool) -> None: ...\n    @UseTasks.setter\n    def UseTasks(self, Value: bool) -> None: ...\n\n\nclass IGH_UpgradeObject:\n    @property\n    def UpgradeFrom(self) -> Guid: ...\n    @property\n    def UpgradeTo(self) -> Guid: ...\n    @property\n    def Version(self) -> DateTime: ...\n    def Upgrade(self, target: IGH_DocumentObject, document: GH_Document) -> IGH_DocumentObject: ...\n\n\nclass IGH_UserPromptAware:\n    def PromptMenuMultipleItems(self) -> ToolStripMenuItem: ...\n    def PromptMenuSingleItem(self) -> ToolStripMenuItem: ...\n    def PromptMultipleItems(self) -> IGH_Structure: ...\n    def PromptSingleItem(self) -> IGH_Goo: ...\n\n\nclass IGH_ValueProxy:\n    def Duplicate(self) -> IGH_ValueProxy: ...\n    def FromString(self, in: str) -> bool: ...\n    @property\n    def IsParsable(self) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def ProxyName(self) -> str: ...\n    @property\n    def ProxyType(self) -> Type: ...\n    @property\n    def ProxyValue(self) -> Object: ...\n    @property\n    def UserString(self) -> str: ...\n    def MutateString(self, in: str) -> str: ...\n    @UserString.setter\n    def UserString(self, Value: str) -> None: ...\n    def ToString(self) -> str: ...\n\n\nclass IGH_VariableParameterComponent:\n    def CanInsertParameter(self, side: GH_ParameterSide, index: int) -> bool: ...\n    def CanRemoveParameter(self, side: GH_ParameterSide, index: int) -> bool: ...\n    def CreateParameter(self, side: GH_ParameterSide, index: int) -> IGH_Param: ...\n    def DestroyParameter(self, side: GH_ParameterSide, index: int) -> bool: ...\n    def VariableParameterMaintenance(self) -> None: ...\n\n\nclass IGH_VarParamComponent:\n    def ConstructVariable(self, e: GH_VarParamEventArgs) -> IGH_Param: ...\n    @property\n    def IsInputVariable(self) -> bool: ...\n    @property\n    def IsOutputVariable(self) -> bool: ...\n    def IsVariableParam(self, e: GH_VarParamEventArgs) -> bool: ...\n    def ManagerConstructed(self, side: GH_VarParamSide, manager: GH_VariableParameterManager) -> None: ...\n    def ParametersModified(self, side: GH_VarParamSide) -> None: ...\n\n\nclass IGH_ZuiAction:\n    @property\n    def Name(self) -> str: ...\n    def Perform(self) -> None: ...\n\n\nclass IRcpAwareObject:\n    def PublishRcpItem(self) -> IRcpItem: ...\n\n\nclass ModifiedChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_DocModifiedEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_DocModifiedEventArgs) -> None: ...\n\n\nclass ObjectChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: IGH_DocumentObject, e: GH_ObjectChangedEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: IGH_DocumentObject, e: GH_ObjectChangedEventArgs) -> None: ...\n\n\nclass ObjectsAddedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_DocObjectEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_DocObjectEventArgs) -> None: ...\n\n\nclass ObjectsDeletedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_DocObjectEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_DocObjectEventArgs) -> None: ...\n\n\nclass ParameterChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_ParamServerEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_ParamServerEventArgs) -> None: ...\n\n\nclass ParameterNickNameChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_ParamServerEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_ParamServerEventArgs) -> None: ...\n\n\nclass ParameterSourcesChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_ParamServerEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_ParamServerEventArgs) -> None: ...\n\n\nclass PingDocumentEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: IGH_DocumentObject, e: GH_PingDocumentEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: IGH_DocumentObject, e: GH_PingDocumentEventArgs) -> None: ...\n\n\nclass PreviewExpiredEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: IGH_DocumentObject, e: GH_PreviewExpiredEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: IGH_DocumentObject, e: GH_PreviewExpiredEventArgs) -> None: ...\n\n\nclass SaveOnDataFlatteningChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self) -> None: ...\n\n\nclass SaveOnDocumentUnloadChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self) -> None: ...\n\n\nclass SaveOnObjectAddedChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self) -> None: ...\n\n\nclass SaveOnObjectChangeChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self) -> None: ...\n\n\nclass SaveOnObjectRemovedChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self) -> None: ...\n\n\nclass SaveOnWireEventChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self) -> None: ...\n\n\nclass ScriptFamilyChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self) -> None: ...\n\n\nclass SettingsChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_DocSettingsEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_DocSettingsEventArgs) -> None: ...\n\n\nclass SolutionEndEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_SolutionEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_SolutionEventArgs) -> None: ...\n\n\nclass SolutionExpiredEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: IGH_DocumentObject, e: GH_SolutionExpiredEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: IGH_DocumentObject, e: GH_SolutionExpiredEventArgs) -> None: ...\n\n\nclass SolutionStartEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_SolutionEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_SolutionEventArgs) -> None: ...\n\n\nclass StandardFamilyChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self) -> None: ...\n\n\nclass UndoStateChangedEventHandler:\n    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...\n    def BeginInvoke(self, sender: Object, e: GH_DocUndoEventArgs, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...\n    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> None: ...\n    def Invoke(self, sender: Object, e: GH_DocUndoEventArgs) -> None: ...\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["surface", "classes", "point", "brep", "line", "curve", "functions", "block", "mesh", "RhinoCommon"], "original_file": "mcneel_pythonstubs_e3c6dd44ba.json", "repo": "mcneel/pythonstubs"}
