{
  "source_url": "https://github.com/969flash/parcel_layout_evaluation_analysis/blob/af8592ec3f658bf5bb8b63064ff33fdbf46240d0/grasshopper/units.py",
  "repo": "969flash/parcel_layout_evaluation_analysis",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "grasshopper/units.py",
  "instruction": null,
  "code": "import Rhino.Geometry as geo\nfrom typing import List, Any, Optional, Tuple\nfrom constants import TOL\nimport importlib\nimport scriptcontext as sc\nimport utils\nimport constants\nfrom constants import RAW_TOL\n\nimportlib.reload(utils)\nimportlib.reload(constants)\n\n\nclass Parcel:\n    \"\"\"기본 필지 클래스 (지오메트리 보관용)\n\n    전처리 로직은 utils의 함수에 위임하여 중복을 줄입니다.\n    \"\"\"\n\n    def __init__(\n        self,\n        curve_crv: geo.Curve,\n        pnu: str,\n        jimok: str,\n        record: List[Any],\n        hole_regions: Optional[List[geo.Curve]] = None,\n    ):\n        self.region: geo.Curve = curve_crv  # 외부 경계 커브\n        self.hole_regions: List[geo.Curve] = hole_regions or []  # 내부 구멍들\n        self.pnu = pnu\n        self.jimok = jimok\n        self.record = record\n\n    def preprocess_curve(self) -> bool:\n        \"\"\"커브 전처리 (invalid 제거, 자체교차 제거, 단순화)\n\n        구현은 utils.preprocess_curve_util에 위임하여 순환 의존성을 피하기 위해 지연 임포트를 사용합니다.\n        \"\"\"\n        if not self.region or not getattr(self.region, \"IsValid\", False):\n            return False\n\n        # 지연 임포트로 순환 의존성 방지\n        try:\n            import utils  # type: ignore\n        except Exception:\n            return False\n\n        result = self._preprocess_curve_util(self.region, self.hole_regions)\n        if result is None:\n            return False\n\n        region, holes = result\n        self.region = region\n        self.hole_regions = holes\n        return True\n\n    def _preprocess_curve_util(\n        self, region: geo.Curve, hole_regions: Optional[List[geo.Curve]]\n    ) -> Optional[Tuple[geo.Curve, List[geo.Curve]]]:\n        \"\"\"\n        커브의 자체 교차를 제거하고 단순화하여 유효한 폴리곤으로 전처리합니다.\n        홀(hole) 커브들도 함께 처리합니다.\n        \"\"\"\n\n        if region is None or not getattr(region, \"IsValid\", False):\n            return None\n\n        # 자체교차 확인 및 단순화\n        try:\n            if geo.Intersect.Intersection.CurveSelf(region, TOL):\n                simplified = region.Simplify(geo.CurveSimplifyOptions.All, 0.1, 1.0)\n                region = simplified or region\n        except Exception:\n            pass  # 실패 시 원본 사용\n\n        # 일반 단순화\n        try:\n            simplified = region.Simplify(geo.CurveSimplifyOptions.All, 0.1, 1.0)\n            region = simplified or region\n        except Exception:\n            pass\n\n        # 홀 커브들 단순화\n        valid_holes: List[geo.Curve] = []\n        for hole in hole_regions or []:\n            try:\n                if hole and hole.IsValid:\n                    simplified_hole = hole.Simplify(\n                        geo.CurveSimplifyOptions.All, 0.1, 1.0\n                    )\n                    valid_holes.append(simplified_hole or hole)\n            except Exception:\n                continue\n\n        return region, valid_holes\n\n\nclass Road(Parcel):\n    \"\"\"도로 클래스\"\"\"\n\n    pass\n\n\nclass Lot(Parcel):\n    \"\"\"대지 클래스\"\"\"\n\n    def __init__(\n        self,\n        curve_crv: geo.Curve,\n        pnu: str,\n        jimok: str,\n        record: List[Any],\n        hole_regions: Optional[List[geo.Curve]] = None,\n        road_adj: Optional[int] = None,\n        max_height: Optional[float] = None,\n        min_height: Optional[float] = None,\n    ):\n        super().__init__(curve_crv, pnu, jimok, record, hole_regions)\n        self.is_flag_lot: bool = False  # 자루형 토지 여부\n        self.has_road_access: bool = False  # 도로 접근 여부\n        self.road_adj = road_adj  # 인접 도로 점수\n        self.max_height = max_height  # 대지 최대 고도\n        self.min_height = min_height  # 대지 최소 고도\n\n\nclass Block:\n    def __init__(self, lots: List[Lot], id: int):\n        self.id = id\n        self.lots = lots\n        self.region: geo.Curve = None  # 블록 경계\n        # 막힌 도로를 포함한 블록 여부\n        self.is_donut = False\n        self._set_block_region()\n        self.layout_score: LayoutScore = None  # 평가 점수 저장용\n        self.max_height = self.get_max_height()\n        self.min_height = self.get_min_height()\n\n    def get_max_height(self) -> Optional[float]:\n        \"\"\"블록 내 대지들의 최대 고도를 반환합니다.\"\"\"\n        heights = [lot.max_height for lot in self.lots if lot.max_height is not None]\n        return max(heights) if heights else None\n\n    def get_min_height(self) -> Optional[float]:\n        \"\"\"블록 내 대지들의 최소 고도를 반환합니다.\"\"\"\n        heights = [lot.min_height for lot in self.lots if lot.min_height is not None]\n        return min(heights) if heights else None\n\n    def _set_block_region(self) -> None:\n        \"\"\"주어진 Lot들의 경계를 생성합니다.\"\"\"\n        # 모든 Lot의 경계를 합쳐서 하나의 경계로 만듭니다.\n        lot_regions = [lot.region for lot in self.lots if lot.region]\n        offset_regions = utils.offset_regions_outward(lot_regions, RAW_TOL)\n        block_regions = utils.get_union_regions(offset_regions)\n        if len(block_regions) != 1:\n            block_region = self._get_out_region(block_regions)\n            self.is_donut = True\n\n        else:\n            block_region = block_regions[0]\n\n        block_region = utils.offset_regions_inward(block_region, RAW_TOL)\n\n        if len(block_region) != 1:\n            raise ValueError(\"오프셋 이후 블록 경계가 단일 커브가 아닙니다.\")\n\n        try:\n            block_region = utils.simplify_crv_by_reducing_segments(block_region[0], TOL)\n        except Exception:\n            print(\"블록 경계 단순화 실패\")\n            block_region = block_region[0]\n\n        self.region = block_region\n\n    def _get_out_region(self, regions: List[geo.Curve]) -> geo.Curve:\n        \"\"\"가장 바깥쪽의 영역 커브를 반환합니다.\"\"\"\n        if len(regions) == 1:\n            return regions[0]\n\n        out_region = None\n\n        for candidate in regions:\n            contains_all = True\n            for other in regions:\n                if other is candidate:\n                    continue\n                if not utils.is_region_inside(other, candidate):\n                    contains_all = False\n                    break\n            if contains_all:\n                out_region = candidate\n                break\n\n        if out_region is None:\n            raise ValueError(\"모든 영역을 포함하는 단일 외곽 영역을 찾을 수 없습니다.\")\n\n        return out_region\n\n\nclass LayoutScore:\n    def __init__(\n        self,\n        region_score: float = 0.0,\n        shape_score: float = 0.0,\n        road_score: float = 0.0,\n        topo_score: float = 0.0,\n    ):\n        self.region_score = region_score\n        self.shape_score = shape_score\n        self.road_score = road_score\n        self.topo_score = topo_score\n\n    def __repr__(self):\n        # 출력용 문자열 반환\n        return f\"LayoutScore(region_score={self.region_score}, shape_score={self.shape_score}, road_score={self.road_score}, topo_score={self.topo_score})\"\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}