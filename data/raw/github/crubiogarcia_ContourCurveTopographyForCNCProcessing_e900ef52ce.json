{
  "source_url": "https://github.com/crubiogarcia/ContourCurveTopographyForCNCProcessing/blob/a3420f7c059ef6c30055d99b54c62bdda7306667/contour_topography.py",
  "repo": "crubiogarcia/ContourCurveTopographyForCNCProcessing",
  "repo_stars": 0,
  "repo_description": "Process contour curves of a topography to obtain 3D Data for the CNC Machine",
  "license": "unknown",
  "filepath": "contour_topography.py",
  "instruction": "Inputs:\n        S: List of Surfaces ordered\n        step: distance between surfaces\n    Output:\n        T: The topography surfaces",
  "code": "\"\"\"\n    Inputs:\n        S: List of Surfaces ordered\n        step: distance between surfaces\n    Output:\n        T: The topography surfaces\"\"\"\n\n__author__ = \"crubiogarcia\"\n__version__ = \"2023.12.06\"\n\nimport rhinoscriptsyntax as rs\nimport ghpythonlib.treehelpers as th\nfrom itertools import combinations\nfrom collections import defaultdict\n\n\n#Convert to nested list\nall = th.tree_to_list(S, None)\n\n#get highest level contours\ninit = all.pop(0)\n\nmax_a = 0\n\n\nfor i in range(len(init)):\n    area = rs.Area(init[i])\n    if area > max_a:\n        max_a = area\n        elem = i\n\n#initialize the list of the wanted curves\nsurfaces = []\naux = [init[i] for i in range(len(init)) if i != elem]\n\n#append highest curves\nsurfaces.append(aux)\nauxi =  surfaces\n\ndef get_curves(prev):\n    \n    global all\n    \n    #Create array\n    possible = []\n    possible = all.pop(0)\n    \n    if len(all)<1:\n        return\n    if isinstance(prev[0], list):\n        previous = prev[0][0]\n    else:\n        previous = prev[0]\n    cs = rs.DuplicateEdgeCurves(previous)\n    if len(cs) > 1:\n        cs = rs.JoinCurves(cs)\n    \n    for i in range(len(cs)):\n        max = 0\n        ln = rs.CurveLength(cs[i])\n        if ln > max:\n            max = ln\n            cc=cs[i]\n\n    p = rs.CurveAreaCentroid(cc)[0]\n    cv= rs.OffsetCurve(cc,p,0.0001)\n\n    pt = rs.CurveEndPoint(cv)\n    scaled = rs.VectorScale([0,0,-1], STEP+1)\n    line = rs.AddLine(pt, pt + scaled)\n\n    for j in range(len(possible)):\n        if rs.CurveBrepIntersect(line,possible[j]):\n            want=j\n\n    wanted = [want]\n    unwanted = []\n    \n    adjacency_graph = build_surface_adjacency_graph(possible)\n    splitlist(adjacency_graph, possible, want, wanted, unwanted, visited=None)\n    \n    srfs = [possible[i] for i in wanted]\n    surfaces.append(srfs)\n    \n    get_curves(srfs)\n\ndef are_surfaces_adjacent(surface_id1, surface_id2):\n    ls = [surface_id1, surface_id2]\n    return len(rs.BooleanUnion(ls, False)) == 1\n\ndef build_surface_adjacency_graph(surface_ids):\n    adjacency_graph = {}\n\n    for surface_id1, surface_id2 in combinations(surface_ids, 2):\n        if are_surfaces_adjacent(surface_id1, surface_id2):\n            adjacency_graph[(surface_id1, surface_id2)] = True\n            adjacency_graph[(surface_id2, surface_id1)] = True\n        else:\n            adjacency_graph[(surface_id1, surface_id2)] = False\n            adjacency_graph[(surface_id2, surface_id1)] = False\n\n    return adjacency_graph\n\ndef splitlist(graph, items, idx, yes, no, visited=None):\n    if visited is None:\n        visited = set()\n    \n    visited.add(idx)\n    \n    if idx in yes:\n        for i in range(len(items)):\n            if i != idx and graph[(items[idx], items[i])] == True and i not in no:\n                no.append(i)\n                splitlist(graph, items, i, yes, no, visited)\n    \n    elif idx in no:\n        for j in range(len(items)):\n            if j != idx and graph[(items[idx], items[j])] == True and j not in yes:\n                yes.append(j)\n                splitlist(graph, items, j, yes, no, visited)\n    \n    return\n\n\na = get_curves(auxi)\n\nT = []\nfor i in surfaces:\n    for j in i:\n        T.append(j)\n\n\n\n",
  "language": "python",
  "imports": [
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}