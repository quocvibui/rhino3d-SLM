{
  "source_url": "https://github.com/969flash/UrbanFrame/blob/0f253b7a73233f7217608b7815c1a99f71e14f35/utils.py",
  "repo": "969flash/UrbanFrame",
  "repo_stars": 0,
  "repo_description": "Generate Urban Frame",
  "license": "unknown",
  "filepath": "utils.py",
  "instruction": "============================================================================== Imports ==============================================================================",
  "code": "# -*- coding:utf-8 -*-\n\n# ==============================================================================\n# Imports\n# ==============================================================================\nimport functools\nimport collections\nfrom operator import attrgetter\nfrom typing import List, Tuple, Any, Optional, Union\n\n# Rhino Libraries\nimport Rhino\nimport Rhino.Geometry as geo\nimport ghpythonlib.components as ghcomp\n\n\n# ==============================================================================\n# Constants\n# ==============================================================================\nBIGNUM = 10000000\nROUNDING_PRECISION = 6  # 반올림 소수점 자리수\n\n# Tolerances\nTOL = 0.01  # 기본 허용 오차\nDIST_TOL = 0.01\nAREA_TOL = 0.1\nOP_TOL = 0.00001\nCLIPPER_TOL = 0.0000000001\n\n\n# ==============================================================================\n# Decorators\n# ==============================================================================\ndef convert_io_to_list(func):\n    \"\"\"입력과 출력을 리스트 형태로 일관되게 만들어주는 데코레이터\"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        new_args = []\n        for arg in args:\n            if isinstance(arg, geo.Curve):\n                arg = [arg]\n            new_args.append(arg)\n\n        result = func(*new_args, **kwargs)\n        if isinstance(result, geo.Curve):\n            result = [result]\n\n        if hasattr(result, \"__dict__\"):\n            for key, values in result.__dict__.items():\n                if isinstance(values, geo.Curve):\n                    setattr(result, key, [values])\n        return result\n\n    return wrapper\n\n\n# ==============================================================================\n# Core Geometry Utilities\n# ==============================================================================\ndef get_distance_between_points(point_a: geo.Point3d, point_b: geo.Point3d) -> float:\n    \"\"\"두 점 사이의 거리를 계산합니다.\"\"\"\n    return round(point_a.DistanceTo(point_b), ROUNDING_PRECISION)\n\n\ndef get_distance_between_point_and_curve(point: geo.Point3d, curve: geo.Curve) -> float:\n    \"\"\"점과 커브 사이의 최단 거리를 계산합니다.\"\"\"\n    _, param = curve.ClosestPoint(point)\n    dist = point.DistanceTo(curve.PointAt(param))\n    return round(dist, ROUNDING_PRECISION)\n\n\ndef get_distance_between_curves(curve_a: geo.Curve, curve_b: geo.Curve) -> float:\n    \"\"\"두 커브 사이의 최소 거리를 계산합니다.\"\"\"\n    _, pt_a, pt_b = curve_a.ClosestPoints(curve_b)\n    dist = pt_a.DistanceTo(pt_b)\n    return round(dist, ROUNDING_PRECISION)\n\n\ndef has_intersection(\n    curve_a: geo.Curve,\n    curve_b: geo.Curve,\n    plane: geo.Plane = geo.Plane.WorldXY,\n    tol: float = TOL,\n) -> bool:\n    \"\"\"두 커브가 교차하는지 여부를 확인합니다.\"\"\"\n    return geo.Curve.PlanarCurveCollision(curve_a, curve_b, plane, tol)\n\n\ndef get_pts_from_crv_crv(\n    curve_a: geo.Curve, curve_b: geo.Curve, tol: float = TOL\n) -> List[geo.Point3d]:\n    \"\"\"두 커브 사이의 교차점을 계산합니다.\"\"\"\n    intersections = geo.Intersect.Intersection.CurveCurve(curve_a, curve_b, tol, tol)\n    if not intersections:\n        return []\n    return [event.PointA for event in intersections]\n\n\ndef get_pts_from_crvs(crvs: List[geo.Curve], tol=TOL) -> List[geo.Point3d]:\n    intersection = ghcomp.MultipleCurves(crvs)\n\n    return list(geo.Point3d.CullDuplicates(list(intersection.points), tol))\n\n\ndef explode_curve(curve: Union[geo.Curve, List[geo.Curve]]) -> List[geo.Curve]:\n    \"\"\"커브를 분할하여 개별 세그먼트(직선) 리스트로 반환합니다.\"\"\"\n    if not curve:\n        return []\n    # PolyCurve인 경우, 내부 세그먼트들을 직접 반환\n    if isinstance(curve, geo.PolyCurve):\n        return list(curve.DuplicateSegments())\n    # 일반 커브는 Span 기준으로 분할\n    segments = []\n    for i in range(curve.SpanCount):\n        param_start, param_end = curve.SpanDomain(i)\n        pt_start = curve.PointAt(param_start)\n        pt_end = curve.PointAt(param_end)\n        segments.append(geo.LineCurve(pt_start, pt_end))\n    return segments\n\n\ndef get_outside_perp_vec_from_pt(pt: geo.Point3d, region: geo.Curve) -> geo.Vector3d:\n    _, param = region.ClosestPoint(pt)\n    vec_perp_outer = region.PerpendicularFrameAt(param)[1].XAxis\n\n    if region.ClosedCurveOrientation() != geo.CurveOrientation.Clockwise:\n        vec_perp_outer = -vec_perp_outer\n\n    return vec_perp_outer\n\n\ndef get_pts_by_length(\n    crv: geo.Curve, length: float, include_start: bool = False\n) -> List[geo.Point3d]:\n    \"\"\"커브를 주어진 길이로 나누는 점을 구한다.\"\"\"\n    params = crv.DivideByLength(length, include_start)\n\n    # crv가 length보다 짧은 경우\n    if not params:\n        return []\n\n    return [crv.PointAt(param) for param in params]\n\n\ndef get_vector_from_pts(pt_a: geo.Point3d, pt_b: geo.Point3d) -> geo.Vector3d:\n    \"\"\"두 점 사이의 벡터를 계산합니다.\"\"\"\n    return geo.Vector3d(pt_b.X - pt_a.X, pt_b.Y - pt_a.Y, pt_b.Z - pt_a.Z)\n\n\ndef get_vertices(curve: geo.Curve) -> List[geo.Point3d]:\n    \"\"\"커브의 모든 정점(Vertex)들을 추출합니다.\"\"\"\n    vertices = [curve.PointAt(curve.SpanDomain(i)[0]) for i in range(curve.SpanCount)]\n    if not curve.IsClosed:\n        vertices.append(curve.PointAtEnd)\n    return vertices\n\n\ndef move_curve(curve: geo.Curve, vector: geo.Vector3d) -> geo.Curve:\n    \"\"\"커브를 주어진 벡터만큼 이동시킨 복사본을 반환합니다.\"\"\"\n    moved_curve = curve.Duplicate()\n    moved_curve.Translate(vector)\n    return moved_curve\n\n\ndef move_brep(brep: geo.Brep, vector: geo.Vector3d) -> geo.Brep:\n    \"\"\"Brep를 주어진 벡터만큼 이동시킨 복사본을 반환합니다.\"\"\"\n    moved_brep = brep.Duplicate()\n    moved_brep.Translate(vector)\n    return moved_brep\n\n\ndef split_curve_at_pts(\n    curve: geo.Curve, points: List[geo.Point3d], tol: float = TOL\n) -> List[geo.Curve]:\n    \"\"\"커브를 주어진 점들에서 분할합니다.\"\"\"\n    if len(points) == 0:\n        return [curve]\n\n    params = []\n    for pt in points:\n        ok, param = curve.ClosestPoint(pt, tol)\n        if ok:\n            params.append(param)\n\n    if not params or len(params) == 0:\n        return [curve]\n\n    params = list(set(params))  # 중복 제거\n    params.sort()\n    split_curves = ghcomp.Shatter(curve, params)\n    if isinstance(split_curves, geo.Curve):\n        return [split_curves]\n    return split_curves if split_curves else [curve]\n\n\ndef get_inside_check_pt(crv):\n    \"\"\"crv 내부의 임의점\"\"\"\n    _, ply = crv.TryGetPolyline()\n    mesh = geo.Mesh.CreateFromClosedPolyline(ply)\n    return mesh.Faces.GetFaceCenter(0)\n\n\ndef is_pt_inside(pt: geo.Point3d, crv: geo.Curve, tol: float = TOL) -> bool:\n    # -1: 일치, 0: 밖, 1: 안\n    result = ghcomp.ClipperComponents.PolylineContainment(\n        crv, pt, geo.Plane.WorldXY, tol\n    )\n    return result == 1\n\n\ndef move_curve_endpoint(\n    curve: geo.Curve, target: geo.Point3d, which: str = \"start\"\n) -> geo.Curve:\n    \"\"\"커브의 시작점 또는 끝점을 주어진 좌표로 이동시킵니다.\"\"\"\n    pts = get_vertices(curve)\n    if which not in (\"start\", \"end\"):\n        raise ValueError(\"which는 'start' 또는 'end'만 허용됩니다.\")\n\n    if which == \"start\":\n        pts[0] = target\n    else:\n        pts[-1] = target\n\n    return geo.PolylineCurve(pts)\n\n\ndef is_pt_on_crv(pt: geo.Point3d, crv: geo.Curve, tol: float = TOL) -> bool:\n    \"\"\"점이 커브 위에 있는지 확인합니다.\"\"\"\n    if not pt or not crv:\n        return False\n    _, param = crv.ClosestPoint(pt, tol)\n    if param is None:\n        return False\n    closest_pt = crv.PointAt(param)\n    return pt.DistanceTo(closest_pt) <= tol\n\n\n# ==============================================================================\n# Advanced Curve & Region Operations\n# ==============================================================================\ndef get_overlapped_curves(curve_a: geo.Curve, curve_b: geo.Curve) -> List[geo.Curve]:\n    \"\"\"두 커브가 겹치는 구간의 커브들을 반환합니다.\"\"\"\n    if not has_intersection(curve_a, curve_b):\n        return []\n\n    intersection_points = get_pts_from_crv_crv(curve_a, curve_b)\n    explode_points = ghcomp.Explode(curve_a, True).vertices + intersection_points\n    if not explode_points:\n        return []\n\n    params = [ghcomp.CurveClosestPoint(pt, curve_a).parameter for pt in explode_points]\n    segments = ghcomp.Shatter(curve_a, params)\n\n    overlapped_segments = [seg for seg in segments if has_intersection(seg, curve_b)]\n    if not overlapped_segments:\n        return []\n\n    return geo.Curve.JoinCurves(overlapped_segments)\n\n\ndef get_overlapped_length(curve_a: geo.Curve, curve_b: geo.Curve) -> float:\n    \"\"\"두 커브가 겹치는 총 길이를 계산합니다.\"\"\"\n    overlapped_curves = get_overlapped_curves(curve_a, curve_b)\n    if not overlapped_curves:\n        return 0.0\n    return sum(crv.GetLength() for crv in overlapped_curves)\n\n\ndef has_region_intersection(\n    region_a: geo.Curve, region_b: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"두 닫힌 영역 커브가 교차(겹침 포함)하는지 확인합니다.\"\"\"\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        region_a, region_b, geo.Plane.WorldXY, tol\n    )\n    return relationship != geo.RegionContainment.Disjoint\n\n\ndef is_region_inside_region(\n    region: geo.Curve, other_region: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"'region'이 'other_region' 내부에 완전히 포함되는지 확인합니다.\"\"\"\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        region, other_region, geo.Plane.WorldXY, tol\n    )\n    return relationship == geo.RegionContainment.AInsideB\n\n\ndef get_outline_from_closed_brep(brep: geo.Brep, plane: geo.Plane) -> geo.Curve:\n    \"\"\"\n    닫힌 폴리서페이스(Brep)를 받아, 주어진 Plane 기준으로 Contour를 생성하고,\n    결과 커브들 중 Z값이 가장 낮은 커브를 반환합니다.\n    brep가 닫힌 Brep가 아니면 TypeError를 발생시킵니다.\n    \"\"\"\n    if not isinstance(brep, geo.Brep) or not brep.IsSolid:\n        raise TypeError(\"입력은 닫힌 Brep(폴리서페이스)만 허용됩니다.\")\n    bbox = brep.GetBoundingBox(True)\n    contour_start = geo.Point3d(0, 0, bbox.Min.Z)\n    contour_end = geo.Point3d(0, 0, bbox.Max.Z)\n    curves = geo.Brep.CreateContourCurves(\n        brep, contour_start, contour_end, (bbox.Max.Z - bbox.Min.Z)\n    )\n\n    if not curves or len(curves) == 0:\n        return None\n\n    # Z값이 가장 낮은 커브 선택 (평균 Z값 기준)\n    def avg_z(curve):\n        return curve.PointAtStart.Z\n\n    return min(curves, key=avg_z)\n\n\ndef offset_regions_inward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"영역 커브를 안쪽으로 offset 한다.\n    단일커브나 커브리스트 관계없이 커브 리스트로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n\n    Returns:\n        offset 후 커브\n    \"\"\"\n\n    if not dist:\n        return regions\n    return Offset().polyline_offset(regions, dist, miter).holes\n\n\ndef offset_regions_outward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"영역 커브를 바깥쪽으로 offset 한다.\n    단일커브나 커브리스트 관계없이 커브 리스트로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n    returns:\n        offset 후 커브\n    \"\"\"\n    if isinstance(regions, geo.Curve):\n        regions = [regions]\n\n    return [offset_region_outward(region, dist, miter) for region in regions]\n\n\ndef offset_region_outward(\n    region: geo.Curve, dist: float, miter: float = BIGNUM\n) -> geo.Curve:\n    \"\"\"영역 커브를 바깥쪽으로 offset 한다.\n    단일 커브를 받아서 단일 커브로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n\n    Returns:\n        offset 후 커브\n    \"\"\"\n\n    if not dist:\n        return region\n    if not isinstance(region, geo.Curve):\n        raise ValueError(\"region must be curve\")\n    if not region.IsClosed:\n        raise ValueError(\"region must be closed curve\")\n    return Offset().polyline_offset(region, dist, miter).contour[0]\n\n\ndef offset_crv_outward(crv: geo.Curve, dist: float, miter: float = BIGNUM) -> geo.Curve:\n    \"\"\"커브를 바깥쪽으로 offset 한다.\n    단일 커브를 받아서 단일 커브로 리턴한다.\n    Args:\n        crv: offset할 대상 커브\n        dist: offset할 거리\n\n    Returns:\n        offset 후 커브\n    \"\"\"\n\n    if not dist:\n        return crv\n    if not isinstance(crv, geo.Curve):\n        raise ValueError(\"crv must be curve\")\n    if crv.IsClosed:\n        raise ValueError(\"crv must be open curve\")\n\n    return Offset().polyline_offset(crv, dist, miter).contour\n\n\nclass Offset:\n    class _PolylineOffsetResult:\n        def __init__(self):\n            self.contour: Optional[List[geo.Curve]] = None\n            self.holes: Optional[List[geo.Curve]] = None\n\n    @convert_io_to_list\n    def polyline_offset(\n        self,\n        crvs: List[geo.Curve],\n        dists: List[float],\n        miter: int = BIGNUM,\n        closed_fillet: int = 2,\n        open_fillet: int = 2,\n        tol: float = Rhino.RhinoMath.ZeroTolerance,\n    ) -> _PolylineOffsetResult:\n        \"\"\"\n        Args:\n            crv (_type_): _description_\n            dists (_type_): _description_\n            miter : miter\n            closed_fillet : 0 = round, 1 = square, 2 = miter\n            open_fillet : 0 = round, 1 = square, 2 = butt\n\n        Returns:\n            _type_: _PolylineOffsetResult\n        \"\"\"\n        if not crvs:\n            raise ValueError(\"No Curves to offset\")\n\n        plane = geo.Plane(geo.Point3d(0, 0, crvs[0].PointAtEnd.Z), geo.Vector3d.ZAxis)\n        result = ghcomp.ClipperComponents.PolylineOffset(\n            crvs,\n            dists,\n            plane,\n            tol,\n            closed_fillet,\n            open_fillet,\n            miter,\n        )\n\n        polyline_offset_result = Offset._PolylineOffsetResult()\n        for name in (\"contour\", \"holes\"):\n            setattr(polyline_offset_result, name, result[name])\n        return polyline_offset_result\n\n\nclass RegionBool:\n    @convert_io_to_list\n    def _polyline_boolean(\n        self, crvs0, crvs1, boolean_type=None, plane=None, tol=CLIPPER_TOL\n    ):\n        # type: (List[geo.Curve], List[geo.Curve], int, geo.Plane, float) -> List[geo.Curve]\n        if not crvs0 or not crvs1:\n            raise ValueError(\"Check input values\")\n        result = ghcomp.ClipperComponents.PolylineBoolean(\n            crvs0, crvs1, boolean_type, plane, tol\n        )\n\n        # 결과는 IronPython.Runtime.List (파이썬 list처럼 동작) 이거나 단일 커브일 수 있으므로 통일해서 list로 반환\n        if not result:\n            return []\n\n        # IronPython.Runtime.List, System.Collections.Generic.List, tuple 등 반복 가능한 결과를 모두 처리\n        if isinstance(result, geo.Curve):\n            # 단일 커브 객체\n            result = [result]\n        else:\n            try:\n                # IEnumerable / IronPython.Runtime.List / tuple / System.Collections.Generic.List 모두 list() 시도로 통일\n                result = [crv for crv in list(result) if crv]\n            except TypeError:\n                # 반복 불가능한 단일 객체인 예외 상황\n                result = [result]\n\n        return result\n\n    def polyline_boolean_union(self, crvs0, crvs1, plane=None, tol=CLIPPER_TOL):\n        # type: (Union[geo.Curve, List[geo.Curve]], Union[geo.Curve, List[geo.Curve]], geo.Plane, float) -> List[geo.Curve]\n        return self._polyline_boolean(crvs0, crvs1, 1, plane, tol)\n\n    def polyline_boolean_difference(self, crvs0, crvs1, plane=None, tol=CLIPPER_TOL):\n        # type: (Union[geo.Curve, List[geo.Curve]], Union[geo.Curve, List[geo.Curve]], geo.Plane, float) -> List[geo.Curve]\n        return self._polyline_boolean(crvs0, crvs1, 2, plane, tol)\n\n\ndef get_difference_regions(\n    regions_a: Union[List[geo.Curve], geo.Curve],\n    regions_b: Union[List[geo.Curve], geo.Curve],\n    offset_tol: float = None,\n) -> List[geo.Curve]:\n    \"\"\"주어진 두 영역 커브의 차집합을 구합니다.\n    Args:\n        regions_a: 차집합의 대상이 되는 영역 커브\n        regions_b: 차집합에서 제외할 영역 커브\n\n    Returns:\n        차집합 결과 커브들\n    \"\"\"\n\n    result = RegionBool().polyline_boolean_difference(regions_a, regions_b)\n    if offset_tol and result:\n        result = offset_regions_inward(result, offset_tol)\n        result = offset_regions_outward(result, offset_tol)\n\n    return result\n\n\ndef get_union_regions(regions: List[geo.Curve] = None) -> List[geo.Curve]:\n    \"\"\"주어진 영역 커브들의 합집합을 구합니다.\n    Args:\n        regions: 합집합을 구할 영역 커브들\n    Returns:\n        합집합 결과 커브들\n    \"\"\"\n    if not regions:\n        return []\n\n    if len(regions) == 1:\n        return regions\n\n    union_result = list(geo.Curve.CreateBooleanUnion(regions, TOL))\n    if union_result:\n        return union_result\n\n    union_result = regions[0]\n    for region in regions[1:]:\n        union_result = RegionBool().polyline_boolean_union(union_result, region)\n\n    if not isinstance(union_result, list):\n        union_result = [union_result]\n\n    return union_result\n\n\ndef get_regions_from_crvs(crvs: List[geo.Curve]) -> List[geo.Curve]:\n    \"\"\"주어진 커브들로부터 닫힌 영역 커브들을 추출합니다.\n    Args:\n        crvs: 닫힌 영역을 형성하는 커브들\n    Returns:\n        닫힌 영역 커브들\n    \"\"\"\n    if not crvs:\n        return []\n\n    boolean_regions = geo.Curve.CreateBooleanRegions(\n        crvs, geo.Plane.WorldXY, False, OP_TOL\n    )  # type: geo.CurveBooleanRegions\n\n    regions_count = boolean_regions.RegionCount\n\n    result_regions = []\n    for i in range(regions_count):\n        region_crvs = boolean_regions.RegionCurves(i)  # type: List[geo.Curve]\n        result_regions.extend(region_crvs)\n    return result_regions\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}