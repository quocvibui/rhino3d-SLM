{
  "source_url": "https://github.com/gramaziokohler/integral_timber_joints/blob/d543a28ccfaeb8a56ff692a29d5510c3e649477f/src/integral_timber_joints/rhino/process_artist.py",
  "repo": "gramaziokohler/integral_timber_joints",
  "repo_stars": 11,
  "repo_description": "Robotic Assembled Timber Structures with Integral Timber Joints",
  "license": "MIT",
  "filepath": "src/integral_timber_joints/rhino/process_artist.py",
  "instruction": "Process artist",
  "code": "import uuid\n\nimport Rhino  # type: ignore\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc  # type: ignore\nfrom compas.datastructures import Mesh, mesh_weld\nfrom compas.geometry import Frame, Transformation, Cylinder, transform_points, transpose_matrix\nfrom compas.robots import Configuration\nfrom compas_rhino.artists import MeshArtist, RobotModelArtist\nfrom compas_rhino.geometry import RhinoPlane\nfrom compas_rhino.utilities import clear_layer, delete_objects, draw_mesh, draw_polylines\nfrom Rhino.DocObjects.ObjectColorSource import ColorFromObject  # type: ignore\nfrom System.Drawing import Color  # type: ignore\n\nfrom integral_timber_joints.assembly import Assembly, BeamAssemblyMethod\nfrom integral_timber_joints.geometry import Beam\nfrom integral_timber_joints.process import RobotClampAssemblyProcess, RoboticMovement\nfrom integral_timber_joints.process.state import ObjectState, SceneState\nfrom integral_timber_joints.rhino.tool_artist import ToolArtist\nfrom integral_timber_joints.rhino.utility import purge_objects\nfrom integral_timber_joints.rhino.assembly_artist import AssemblyNurbsArtist\nfrom integral_timber_joints.tools import Clamp, Gripper, Screwdriver, Tool\n\ntry:\n    from typing import Any, Dict, List, Optional, Tuple, Type\nexcept:\n    pass\n\n\nTOL = sc.doc.ModelAbsoluteTolerance\n\nguid = uuid.UUID\n\n\ndef AddAnnotationText(frame, text, height, layer, redraw=True):\n    rs.EnableRedraw(False)\n    font = \"Arial\"\n    plane = RhinoPlane.from_geometry(frame).geometry\n    justification = Rhino.Geometry.TextJustification.BottomLeft\n    guid = sc.doc.Objects.AddText(text, plane, height, font, False, False, justification)\n    import System.Guid  # type: ignore\n    if guid != System.Guid.Empty:\n        rs.ObjectLayer(guid, layer)\n        # o = sc.doc.Objects.FindId(rs.coerceguid(guid))\n        # o.Geometry.TextOrientation = Rhino.DocObjects.TextOrientation.InPlane\n        # o.CommitChanges()\n        if redraw:\n            rs.EnableRedraw(True)\n            sc.doc.Views.Redraw()\n        return guid\n\n\nclass ProcessKeyPosition(object):\n    def __init__(self, process=None, beam_id=None, current_pos_num=0):\n        # type: (RobotClampAssemblyProcess, str, int) -> None\n        \"\"\"Initializing the Key Positions accoring to the assembly method of beam.\"\"\"\n        if process is not None and beam_id is not None:\n            self.beam_tool_count = len(list(process.assembly.get_joint_ids_with_tools_for_beam(beam_id)))\n            self.beam_assembly_method = process.assembly.get_assembly_method(beam_id)\n        else:\n            self.beam_tool_count = 0\n            self.beam_assembly_method = BeamAssemblyMethod.UNDEFINED\n        self.current_pos_num = current_pos_num\n\n    # pos_name, beam_pos, gripper_pos, clamp_pos\n    pos_names_for_beam_with_clamps = [\n        ('clamp_attachapproach1',   'assembly_wcf_storage',         None,\n         'clamp_wcf_attachapproach1.open_clamp.open_gripper'),\n        ('clamp_attachapproach2',   'assembly_wcf_storage',         None,\n         'clamp_wcf_attachapproach2.open_clamp.open_gripper'),\n        ('beam_pickup_approach',    'assembly_wcf_pickup',\n         'assembly_wcf_pickupapproach.open_gripper',         'clamp_wcf_final.open_clamp.close_gripper'),\n        ('beam_pickup_pick',        'assembly_wcf_pickup',\n         'assembly_wcf_pickup.close_gripper',                'clamp_wcf_final.open_clamp.close_gripper'),\n        ('beam_pickup_retract',     'assembly_wcf_pickupretract',\n         'assembly_wcf_pickupretract.close_gripper',         'clamp_wcf_final.open_clamp.close_gripper'),\n        ('beam_inclampapproach',    'assembly_wcf_inclampapproach',\n         'assembly_wcf_inclampapproach.close_gripper',       'clamp_wcf_final.open_clamp.close_gripper'),\n        ('beam_inclamp',            'assembly_wcf_inclamp',\n         'assembly_wcf_inclamp.close_gripper',               'clamp_wcf_final.open_clamp.close_gripper'),\n        ('beam_final',              'assembly_wcf_final',\n         'assembly_wcf_final.close_gripper',                 'clamp_wcf_final.close_clamp.close_gripper'),\n        ('beam_finalretract',       'assembly_wcf_final',\n         'assembly_wcf_finalretract.open_gripper',           'clamp_wcf_final.close_clamp.close_gripper'),\n        ('clamp_detachretract1',    'assembly_wcf_final',           None,\n         'clamp_wcf_detachretract1.open_clamp.open_gripper'),\n        ('clamp_detachretract2',    'assembly_wcf_final',           None,\n         'clamp_wcf_detachretract2.open_clamp.open_gripper'),\n    ]\n\n    pos_names_for_beam_without_clamps = [\n        ('beam_pickup_approach',\n         'assembly_wcf_pickup',  # Beam Position\n         'assembly_wcf_pickupapproach.open_gripper',  # Gripper Position\n         None),\n\n        ('beam_pickup_pick',\n         'assembly_wcf_pickup',  # Beam Position\n         'assembly_wcf_pickup.close_gripper',  # Gripper Position\n         None),\n\n        ('beam_pickup_retract',\n         'assembly_wcf_pickupretract',  # Beam Position\n         'assembly_wcf_pickupretract.close_gripper',  # Gripper Position\n         None),\n\n        ('beam_inclamp',\n         'assembly_wcf_inclamp',  # Beam Position\n         'assembly_wcf_inclamp.close_gripper',  # Gripper Position\n         None),\n\n        ('beam_final',\n         'assembly_wcf_final',  # Beam Position\n         'assembly_wcf_final.close_gripper',  # Gripper Position\n         None),\n\n        ('beam_finalretract',\n         'assembly_wcf_final',  # Beam Position\n         'assembly_wcf_finalretract.open_gripper',  # Gripper Position\n         None),\n    ]\n\n    # pos_name, beam_pos, gripper_pos, screwdriver_pos\n    pos_names_for_beam_with_screwdriver_with_gripper = [\n        ('beam_pickup',\n         'assembly_wcf_pickup',  # Beam Position\n         'assembly_wcf_pickup.close_gripper',  # Gripper Position\n         None),  # Screwdriver Position\n\n        ('screwdriver_attachment_pose',\n         'assembly_wcf_screwdriver_attachment_pose',  # Beam Position\n         'assembly_wcf_screwdriver_attachment_pose.close_gripper',  # Gripper Position\n         'screwdriver_attachment_pose_attached.close_gripper'),  # Screwdriver Position\n\n        ('screwdriver_assembleapproach',\n         'assembly_wcf_assembleapproach',  # Beam Position\n         'assembly_wcf_assembleapproach.close_gripper',  # Gripper Position\n         'screwdriver_assembleapproach_attached.close_gripper'),  # Screwdriver Position\n\n        ('screwdriver_assembled',\n         'assembly_wcf_final',  # Beam Position\n         'assembly_wcf_final.close_gripper',  # Gripper Position\n         'screwdriver_assembled_attached.close_gripper'),  # Screwdriver Position\n\n        ('screwdriver_assembled',\n         'assembly_wcf_final',  # Beam Position\n         'assembly_wcf_finalretract.open_gripper',  # Gripper Position\n         'screwdriver_assembled_attached.close_gripper'),  # Screwdriver Position\n\n        ('screwdriver_retracted',\n         'assembly_wcf_final',  # Beam Position\n         None,  # Gripper Position\n         'screwdriver_assembled_retractedfurther.open_gripper'),  # Screwdriver Position\n    ]\n\n    # pos_name, beam_pos, gripper_pos, screwdriver_pos\n    pos_names_for_beam_with_screwdriver_without_gripper = [\n        ('beam_pickup',\n         'assembly_wcf_pickup',  # Beam Position\n         'assembly_wcf_pickup.close_gripper',\n         None),  # Screwdriver Position\n\n        ('screwdriver_attachment_pose',\n         'assembly_wcf_screwdriver_attachment_pose',  # Beam Position\n         None,  # Gripper Position\n         'screwdriver_attachment_pose_attached.close_gripper'),  # Screwdriver Position\n\n        ('screwdriver_assembleapproach',\n         'assembly_wcf_assembleapproach',  # Beam Position\n         None,\n         'screwdriver_assembleapproach_attached.close_gripper'),  # Screwdriver Position\n\n        ('screwdriver_assembled',\n         'assembly_wcf_final',  # Beam Position\n         None,\n         'screwdriver_assembled_attached.close_gripper'),  # Screwdriver Position\n\n        ('screwdriver_retracted',\n         'assembly_wcf_final',  # Beam Position\n         None,\n         'screwdriver_assembled_retractedfurther.open_gripper'),  # Screwdriver Position\n    ]\n\n    # pos_name, beam_pos, gripper_pos, screwdriver_pos\n    pos_names_for_beam_manual_assembly = [\n        ('assembly_wcf_final',\n         'assembly_wcf_final',  # Beam Position\n         None,\n         None),  # Screwdriver Position\n    ]\n\n    @property\n    def _all_pos_names(self):\n        return self.pos_names_for_beam_with_clamps +\\\n            self.pos_names_for_beam_without_clamps +\\\n            self.pos_names_for_beam_with_screwdriver_with_gripper +\\\n            self.pos_names_for_beam_with_screwdriver_without_gripper\n\n    @property\n    def possible_beam_positions(self):\n        # type: () -> set[str]\n        \"\"\"All possible beam positions. Used for creating layers in Rhino\"\"\"\n        positions = [names[1] for names in self._all_pos_names if names[1] is not None]\n        return set(positions)\n\n    @property\n    def possible_gripper_positions(self):\n        # type: () -> set[str]\n        \"\"\"All possible gripper positions. Used for creating layers in Rhino\"\"\"\n        positions = [names[2] for names in self._all_pos_names if names[2] is not None]\n        return set(positions)\n\n    @property\n    def possible_tool_positions(self):\n        # type: () -> set[str]\n        \"\"\"All possible tool positions. Used for creating layers in Rhino\"\"\"\n        positions = [names[3] for names in self._all_pos_names if names[3] is not None]\n        return set(positions)\n\n    def next_position(self):\n        self.current_pos_num += 1\n        if self.current_pos_num >= self.total_pos_number:\n            self.current_pos_num = self.total_pos_number - 1\n\n    def prev_position(self):\n        self.current_pos_num += -1\n        if self.current_pos_num < 0:\n            self.current_pos_num = 0\n\n    def first_position(self):\n        \"\"\" Set `self.current_pos_num` to beam_final\n        \"\"\"\n        self.current_pos_num = 0\n\n    def final_position(self):\n        \"\"\" Set `self.current_pos_num` to beam_final\n        \"\"\"\n        if self.beam_tool_count == 0:\n            self.current_pos_num = 5\n        elif self.beam_assembly_method == BeamAssemblyMethod.CLAMPED:\n            self.current_pos_num = 7\n        elif self.beam_assembly_method == BeamAssemblyMethod.SCREWED_WITH_GRIPPER:\n            self.current_pos_num = 2\n        elif self.beam_assembly_method == BeamAssemblyMethod.SCREWED_WITHOUT_GRIPPER:\n            self.current_pos_num = 2\n        else:\n            self.current_pos_num = 0\n\n    def _get_pos_names(self):\n        # type: () -> List[Tuple[str,str,str,str]]\n        \"\"\"Getting the right pos_name array depending on the assembly method\"\"\"\n\n        # Switching between two sets of key positions depending if it has clamps\n        if self.beam_tool_count == 0:\n            return self.pos_names_for_beam_without_clamps\n        elif self.beam_assembly_method == BeamAssemblyMethod.CLAMPED:\n            return self.pos_names_for_beam_with_clamps\n        elif self.beam_assembly_method == BeamAssemblyMethod.SCREWED_WITH_GRIPPER:\n            return self.pos_names_for_beam_with_screwdriver_with_gripper\n        elif self.beam_assembly_method == BeamAssemblyMethod.SCREWED_WITHOUT_GRIPPER:\n            return self.pos_names_for_beam_with_screwdriver_without_gripper\n        elif self.beam_assembly_method == BeamAssemblyMethod.MANUAL_ASSEMBLY:\n            return self.pos_names_for_beam_manual_assembly\n        else:\n            return []\n\n    @property\n    def _get_current_pos_names(self):\n        # type: () -> Tuple[str,str,str,str]\n        \"\"\"Getting the 4 part Tuple of where things are.\n        Order is: pos_name, beam_pos, gripper_pos, assembly_tool_pos\n        \"\"\"\n        # just in case\n        if self.current_pos_num >= self.total_pos_number:\n            self.final_position()\n\n        # Switching between two sets of key positions depending if it has clamps\n        pos_names = self._get_pos_names()\n        return pos_names[self.current_pos_num]\n\n    @property\n    def current_pos_name(self):\n        # type: () -> str\n        return self._get_current_pos_names[0]\n\n    @property\n    def current_beam_pos(self):\n        return self._get_current_pos_names[1]\n\n    @property\n    def current_gripper_pos(self):\n        return self._get_current_pos_names[2]\n\n    @property\n    def current_clamp_pos(self):\n        return self._get_current_pos_names[3]\n\n    @property\n    def total_pos_number(self):\n        return len(self._get_pos_names())\n\n    @property\n    def get_all_asstool_positions(self):\n        \"\"\"Returning all possible Assembly Tool Positions according to the current beam\"\"\"\n        return set([x[3] for x in self._get_pos_names() if x[3] is not None])\n\n    def to_data(self):\n        # type: () -> dict[str, Any]\n        data = {'current_pos_num': self.current_pos_num,\n                'beam_tool_count': self.beam_tool_count,\n                'beam_assembly_method': self.beam_assembly_method,\n                }\n        return data\n\n    @classmethod\n    def from_data(cls, data):\n        # type: (dict[str, Any]) -> ProcessKeyPosition\n        p = cls()\n        p.current_beam_pos = data.get('current_pos_num', 0)\n        p.beam_tool_count = data.get('beam_tool_count', 0)\n        p.beam_assembly_method = data.get('beam_assembly_method', BeamAssemblyMethod.UNDEFINED)\n        return p\n\n\nclass ProcessArtist(object):\n    \"\"\" Artist to draw Beams in Rhino\n    Items are drawn in specific layers for quickly turning them on and off.\n    Beam Brep : layer = itj::beams_brep         name = beam_id\n    Beam Mesh : layer =  itj::beams_mesh        name = beam_id\n    Beam Sequence Tag - itj::beams_seqtag\n    self.gripper_guids, asstool_guids, beam_guids, interactive_guids\n    are dictionary that keep track of the objects drawn in Rhino.\n    \"\"\"\n\n    # Rhino layers used to hold temporary visualization objects\n    interactive_layers = [\n        'itj::interactive::beams_mesh',\n        'itj::interactive::beams_brep',\n        'itj::interactive::beams_seqtag',\n        'itj::interactive::clamps_at_final',\n    ]\n\n    state_visualization_layer = 'itj::state_visualization'\n    tools_in_storage_layer = 'itj::tools::in_storage'\n    env_mesh_layer = 'itj::envmesh'\n    robot_layer = 'itj::robot'\n\n    color_meaning = {\n        'normal': (0, 0, 0),\n        'warning': (255, 152, 0),\n        'error': (244, 67, 54),\n        'active': (76, 175, 80),\n        'unbuilt': (220, 220, 220),\n        'unbuilt_warning': (255, 204, 204),\n        'built': (61, 167, 219),\n        'built_warning': (130, 20, 20),\n        'neighbors': (0, 188, 212),\n        'env_model': (230, 153, 0),\n        'assembly_method_undefined': (176, 65, 62),  # red\n        'assembly_method_ground': (71, 51, 53),  # black\n        'assembly_method_clamped': (84, 155, 135),  # green\n        'assembly_method_screwed_w_gripper': (126, 178, 221),  # lightblue\n        'assembly_method_screwed_wo_gripper': (68, 94, 147),  # deepblue\n        'assembly_method_manual_assembly': (181, 118, 24),  # Dark Orange\n        'gripper_normal': (35, 78, 160),  # Blue\n        'asstool_normal': (30, 120, 50),  # Green\n    }\n\n    key_positions = [\n        'storage_approach',\n\n    ]\n\n    def __init__(self, process):\n        # type: (RobotClampAssemblyProcess) -> None\n        self.process = process\n        self.assembly_artist = AssemblyNurbsArtist(process.assembly, 'itj::interactive::beams_brep')\n\n        # # Create guid in dictionary to store geometries added to Rhino document\n        self._beam_guids = {}  # type: dict[str, dict(str, List[str])]\n        self._gripper_guids = {}  # type: dict(str, dict(str, List[str]))\n        self._asstool_guids = {}  # type: dict(str, dict(str, List[str]))\n        self._interactive_guids = {}  # type: dict(str, dict(str, List[str]))\n        self._state_visualization_guids = {}  # type: dict[str, List[str]]\n        self.state_visualization_current_state = {}\n        self._trajectory_visualization_guids = {}  # type: dict[str, List[str]]\n        self._tools_in_storage_guids = {}  # type: dict[str, List[str]]\n        self._env_mesh_guids = {}  # type: dict[str, List[str]]\n        self._robot_guids = {'visual': [], 'collision': []}  # type: dict[str, List[str]]\n\n        self.settings = {\n            'color.vertex': (255, 255, 255),\n            'color.edge': (0, 0, 0),\n            'color.face': (210, 210, 210),\n            'color.normal:vertex': (0, 255, 0),\n            'color.normal:face': (0, 255, 0),\n            'scale.normal:vertex': 0.1,\n            'scale.normal:face': 0.1,\n            'show.vertices': True,\n            'show.edges': True,\n            'show.faces': True}\n\n        # Empty existing layers and create them if not existing.\n        # This also creates the guid dictionary\n        self.empty_layers()\n\n        self._selected_beam_id = None  # type: str\n        self.selected_state_id = 0  # type: str # State Id = Start State of Movement with the same ID\"\"\"\n        self.selected_key_position = ProcessKeyPosition(process, self.selected_beam_id, 0)\n\n        self.visualize_smooth_trajectory = True\n        # Robot\n        self._robot_artist = None\n\n    @property\n    def robot_artist(self):\n        # type: () -> RobotModelArtist\n        if self._robot_artist is not None:\n            return self._robot_artist\n\n        if self.process.robot_model is not None:\n            print(\"Creating new RobotModelArtist\")\n            self._robot_artist = RobotModelArtist(self.process.robot_model, self.robot_layer)\n            self._robot_artist.scale(1000)\n            return self._robot_artist\n        else:\n            print(\"Error: Attempy to create new RobotModelArtist but process.robot_model is None\")\n            self._robot_artist = None\n            return None\n\n    #######################################\n    # Functions to handle the guid records\n    #######################################\n    def beam_guids(self, beam_id):\n        # type: (str) -> dict[str, List[guid]]\n        if beam_id not in self._beam_guids:\n            self._beam_guids[beam_id] = {}\n        return self._beam_guids[beam_id]\n\n    def beam_guids_at_position(self, beam_id, position_id):\n        # type: (str, str) -> list[guid]\n        if position_id not in self.beam_guids(beam_id):\n            self.beam_guids(beam_id)[position_id] = []\n        return self.beam_guids(beam_id)[position_id]\n\n    def gripper_guids(self, beam_id):\n        # type: (str) -> dict[str, List[guid]]\n        if beam_id not in self._gripper_guids:\n            self._gripper_guids[beam_id] = {}\n        return self._gripper_guids[beam_id]\n\n    def gripper_guids_at_position(self, beam_id, position_id):\n        # type: (str, str) -> List[guid]\n        if position_id not in self.gripper_guids(beam_id):\n            self.gripper_guids(beam_id)[position_id] = []\n        return self.gripper_guids(beam_id)[position_id]\n\n    def asstool_guids(self, joint_id):\n        # type: (tuple(str, str)) -> dict[str, List[guid]]\n        if joint_id not in self._asstool_guids:\n            self._asstool_guids[joint_id] = {}\n        return self._asstool_guids[joint_id]\n\n    def asstool_guids_at_position(self, joint_id, position_id):\n        # type: (str, str) -> List[guid]\n        if position_id not in self.asstool_guids(joint_id):\n            self.asstool_guids(joint_id)[position_id] = []\n        return self.asstool_guids(joint_id)[position_id]\n\n    def interactive_guids(self, beam_id):\n        # type: (tuple(str, str)) -> dict[str, List[guid]]\n        if beam_id not in self._interactive_guids:\n            self._interactive_guids[beam_id] = {}\n        return self._interactive_guids[beam_id]\n\n    def interactive_guids_at_layer(self, beam_id, layer_name):\n        # type: (str, str) -> List[guid]\n        if layer_name not in self.interactive_guids(beam_id):\n            self.interactive_guids(beam_id)[layer_name] = []\n        return self.interactive_guids(beam_id)[layer_name]\n\n    def state_visualization_guids(self, object_id):\n        # type: (str) -> List[guid]\n        if object_id not in self._state_visualization_guids:\n            self._state_visualization_guids[object_id] = []\n        return self._state_visualization_guids[object_id]\n\n    def tools_in_storage_guids(self, tool_id):\n        # type: (str) -> List[guid]\n        if tool_id not in self._tools_in_storage_guids:\n            self._tools_in_storage_guids[tool_id] = []\n        return self._tools_in_storage_guids[tool_id]\n\n    def env_mesh_guids(self, env_id):\n        # type: (str) -> List[guid]\n        if env_id not in self._env_mesh_guids:\n            self._env_mesh_guids[env_id] = []\n        return self._env_mesh_guids[env_id]\n\n    ###########################################################\n    # Functions to keep track of user selected interactive beam\n    ###########################################################\n\n    @property\n    def selected_beam_id(self):\n        return self._selected_beam_id\n\n    @selected_beam_id.setter\n    def selected_beam_id(self, beam_id):\n        # Do not change anything if the id is the same\n        if beam_id == self._selected_beam_id:\n            return\n        self._selected_beam_id = beam_id\n\n        # update selected_key_position object\n        if beam_id is not None:\n            self.selected_key_position = ProcessKeyPosition(self.process, self.selected_beam_id, 0)\n            self.selected_key_position.final_position()\n\n    def select_next_beam(self):\n        # type: () -> str\n        \"\"\" Increment self.selected_beam_id based on its seq_num \"\"\"\n        assembly = self.process.assembly\n        seq_num = assembly.get_beam_sequence(self.selected_beam_id) + 1\n        seq_num = min(seq_num,  len(assembly.sequence) - 1)  # seq_num not more than len(assembly.sequence) - 1\n        self.selected_beam_id = assembly.sequence[seq_num]\n\n    def select_previous_beam(self):\n        # type: () -> str\n        \"\"\" Increment self.selected_beam_id based on its seq_num \"\"\"\n        assembly = self.process.assembly\n        seq_num = assembly.get_beam_sequence(self.selected_beam_id) - 1\n        seq_num = max(seq_num,  0)  # seq_num not less than 0\n        self.selected_beam_id = assembly.sequence[seq_num]\n\n    #############################\n    # Beam in Interactive Layers\n    #############################\n\n    def draw_beam_seqtag(self, beam_id, faces=[1, 3], padding_factor=0.2, size_factor=0.6, redraw=True):\n        assembly = self.process.assembly\n        seq_num = assembly.sequence.index(beam_id)\n        rs.EnableRedraw(False)\n        for face_id in faces:\n            # Get Face Frame\n            beam = assembly.beam(beam_id)\n            face_frame = beam.reference_side_wcf(face_id)\n\n            # Move Frame orgin for padding\n            beam_size_min = min(beam.height, beam.width)\n            padding = beam_size_min * padding_factor\n            padded_location_origin = face_frame.to_world_coordinates([padding, padding, beam_size_min * 0.01])\n            face_frame.point = padded_location_origin\n\n            # Test and Size\n            tag_text = \".%s.\" % seq_num\n            tag_height = beam_size_min * size_factor\n\n            # Create Tag\n            layer = 'itj::interactive::beams_seqtag'\n            guid = AddAnnotationText(face_frame, tag_text, tag_height, layer, redraw=redraw)\n            self.interactive_guids_at_layer(beam_id, layer).append(guid)\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def draw_beam_mesh(self, beam_id, update_cache=False, redraw=True):\n        # type:(str, bool, bool) -> None\n        assembly = self.process.assembly\n        if beam_id not in assembly.beam_ids():\n            raise KeyError(\"Beam %i not in Assembly\" % beam_id)\n        beam_mesh = assembly.get_beam_mesh_in_wcf(beam_id, not update_cache)\n\n        # Layer\n        layer = 'itj::interactive::beams_mesh'\n        rs.CurrentLayer(layer)\n\n        # Draw Mesh\n        guids = self.draw_meshes_get_guids([beam_mesh], beam_id)\n        self.interactive_guids_at_layer(beam_id, layer).extend(guids)\n\n        # Redraw\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def draw_beam_brep(self, beam_id, delete_old_brep=True, update_mesh_cache=False, redraw=True):\n        # type: (str, bool, bool, bool) -> List[guid]\n        assembly = self.process.assembly\n        if beam_id not in assembly.beam_ids():\n            raise KeyError(\"Beam %i not in Assembly\" % beam_id)\n\n        if update_mesh_cache:\n            assembly.beam(beam_id).remove_cached_mesh()\n            assembly.get_beam_mesh_in_wcf(beam_id, False)\n\n        # Layer\n        layer = 'itj::interactive::beams_brep'\n        rs.CurrentLayer(layer)\n\n        # Obtain tool features on Beam from Process\n        other_feature_shapes = self.process.get_tool_features_on_beam(beam_id)\n\n        # * Call assembly artist with all the extra feature shapes\n        guids = self.assembly_artist.draw_beam(beam_id=beam_id, delete_old=delete_old_brep, redraw=False, other_feature_shapes=other_feature_shapes)\n        self.interactive_guids_at_layer(beam_id, layer).extend(guids)\n\n        # Redraw\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def redraw_interactive_beam(self, beam_id, force_update=True, draw_mesh=False, draw_nurbs=True, draw_tag=True, redraw=True):\n        ''' Redraw beam visualizations.\n        Redraws interactive beam mesh and sequence tag\n        '''\n        rs.EnableRedraw(False)\n        if force_update:\n            self.delete_interactive_beam_visualization(beam_id, redraw=False)\n\n        if draw_mesh:\n            self.draw_beam_mesh(beam_id, update_cache=force_update, redraw=False)\n        if draw_nurbs:\n            self.draw_beam_brep(beam_id, delete_old_brep=force_update, update_mesh_cache=False, redraw=False)\n        if draw_tag:\n            self.draw_beam_seqtag(beam_id, redraw=False)\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def interactive_beam_guid(self, beam_id, layer='itj::interactive::beams_brep'):\n        # type:(str, str) -> list[guid]\n        ''' Returns the interactive beam's guid(s)\n        Typically this is a list of one mesh that represent the beam.\n        '''\n        return self.interactive_guids_at_layer(beam_id, layer)\n\n    ######################\n    # Beam in Interactive Layers\n    # Show Hide Color\n    ######################\n\n    def show_interactive_beam(self, beam_id):\n        \"\"\" Show the beam of the beam_id.\n        \"\"\"\n        for layer in self.interactive_layers:\n            rs.ShowObject(self.interactive_guids_at_layer(beam_id, layer))\n\n    def hide_interactive_beam(self, beam_id):\n        \"\"\" Show the beam of the beam_id.\n        \"\"\"\n        for layer in self.interactive_layers:\n            rs.HideObject(self.interactive_guids_at_layer(beam_id, layer))\n\n    def show_interactive_beam_until(self, beam_id):\n        \"\"\" Show only the beams before and the given beam_id, others are hidden.\n        If beam_id is None, all beams are hidden.\n        If beam_id is not in the list of sequence, all beams are shown.\n        \"\"\"\n\n        assembly = self.process.assembly\n        show = True\n        if beam_id is None:\n            show = False\n        # Looping through beams in sequence, flip the show switch after it reaches the beam_id\n        for _beam_id in assembly.sequence:\n            if show:\n                self.show_interactive_beam(_beam_id)\n            else:\n                self.hide_interactive_beam(_beam_id)\n            if _beam_id == beam_id:\n                show = False\n\n    def change_interactive_beam_colour(self, beam_id, meaning, layer='itj::interactive::beams_brep'):\n        # type(str, str) -> None\n        \"\"\" Chagne the beam brep and mesh color to a given colour string\n        Colour string refer to color_meaning dict\n        \"\"\"\n        for guid in self.interactive_guids_at_layer(beam_id, layer):\n            rs.ObjectColor(guid, self.color_meaning.get(meaning, (0, 0, 0)))\n\n    #############################\n    # Beam in different positions\n    #############################\n\n    def draw_beam_all_positions(self, beam_id, delete_old=False, verbose=False, redraw=True):\n        \"\"\" Delete old beam geometry if delete_old is True\n        Redraw them in Rhino in different layers.\n        The resulting Rhino guids are kept in self.beam_guids_at_position(beam_id, position)\n\n        This applies to all positions where the attribute is set in beam attributes.\n        \"\"\"\n        rs.EnableRedraw(False)\n\n        for beam_position in ProcessKeyPosition().possible_beam_positions:\n            layer_name = 'itj::beam::' + beam_position\n            # If not delete_old, and there are already items drawn, we preserve them.\n            if len(self.beam_guids_at_position(beam_id, beam_position)) > 0 and not delete_old:\n                continue\n\n            # Delete old geometry\n            self.delete_beam_at_position(beam_id, beam_position, redraw=False)\n\n            # Skip the rest of code if the position does not exist.\n            if self.process.assembly.get_beam_attribute(beam_id, beam_position) is None:\n                if verbose:\n                    print(\"Skipping Beam (%s) position: %s\" % (beam_id, beam_position))\n                continue\n\n            if verbose:\n                print(\"Drawing Beam(%s) in position: %s\" % (beam_id, beam_position))\n\n            # Transform the beam_mesh to location and\n            T = self.process.assembly.get_beam_transformaion_to(beam_id, beam_position)\n\n            beam_mesh = self.process.assembly.get_beam_mesh_in_wcf(beam_id).transformed(T)  # type: Mesh\n            guids = self.draw_meshes_get_guids([beam_mesh], beam_id, redraw=False)\n            self.beam_guids_at_position(beam_id, beam_position).extend(guids)\n\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def delete_beam_all_positions(self, beam_id, redraw=True):\n        \"\"\"Delete all Rhino geometry associated to a beam at all position.\n        \"\"\"\n        rs.EnableRedraw(False)\n        for beam_position in ProcessKeyPosition().possible_beam_positions:\n            # The redraw is supressed in each individual call to save time.\n            self.delete_beam_at_position(beam_id, beam_position, redraw=False)\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def delete_beam_at_position(self, beam_id, beam_position, redraw=True):\n        # type:(str, str, bool) -> None\n        \"\"\"Delete all Rhino geometry associated to a beam at specified position\n\n        No change will be made if the beam_id or beam_position do not exist in the guid dictionary.\n        \"\"\"\n        if len(self.beam_guids_at_position(beam_id, beam_position)) == 0:\n            return\n        guids = self.beam_guids_at_position(beam_id, beam_position)\n        if len(guids) > 0:\n            purge_objects(guids, redraw)\n            del self.beam_guids_at_position(beam_id, beam_position)[:]\n\n    def show_beam_at_one_position(self, beam_id, position=None):\n        \"\"\" Show Beam only at the specified position.\n        Position is the position attribute name, if left None, selected_key_position will be used.\n        \"\"\"\n        if position is None:\n            position = self.selected_key_position.current_beam_pos\n\n        for beam_position in ProcessKeyPosition().possible_beam_positions:\n            if beam_position == position:\n                rs.ShowObject(self.beam_guids_at_position(beam_id, beam_position))\n            else:\n                rs.HideObject(self.beam_guids_at_position(beam_id, beam_position))\n\n    def hide_beam_all_positions(self, beam_id):\n        \"\"\" Hide all gripper instances in the specified positions.\n        `positions` are defaulted to all position.\n        # \"\"\"\n\n        self.show_beam_at_one_position(beam_id, '')\n\n    def delete_interactive_beam_visualization(self, beam_id, redraw=True):\n        # type:(str, bool) -> None\n        \"\"\" Delete visualization geometry geometry (brep, mesh, tag etc) related to a beam.\n        Tools are not affected.\n        Stored guid reference is also removed.\n\n        If beam_id is not yet tracked in self.guid, the new entry will be created.\n        \"\"\"\n        rs.EnableRedraw(False)\n        if beam_id in self.process.assembly.beam_ids():\n            for layer in self.interactive_layers:\n                if len(self.interactive_guids_at_layer(beam_id, layer)) > 0:\n                    purge_objects(self.interactive_guids_at_layer(beam_id, layer), redraw=False)\n                    del self.interactive_guids_at_layer(beam_id, layer)[:]\n            del self.assembly_artist.beam_guids(beam_id)[:]\n        if redraw:\n            rs.EnableRedraw(True)\n\n    @property\n    def all_layer_names(self):\n        for layer in self.interactive_layers:\n            yield layer\n        for gripper_position in ProcessKeyPosition().possible_gripper_positions:\n            yield 'itj::gripper::' + gripper_position\n        for tool_position in ProcessKeyPosition().possible_tool_positions:\n            yield 'itj::tool::' + tool_position\n        for beam_position in ProcessKeyPosition().possible_beam_positions:\n            yield 'itj::beam::' + beam_position\n        yield self.state_visualization_layer\n        yield self.tools_in_storage_layer\n        yield self.env_mesh_layer\n        yield self.robot_layer\n\n    def empty_layers(self):\n        # type:() -> None\n        \"\"\"Clear the default artist layers in Rhino.\n        Create those layers if doesnt exist\n        Gguid dictionary is reset to all empty lists.\n        \"\"\"\n        # Clear Interactive, Gripper, Clamp, BeamPos, State Visualization layers\n        for layer_name in self.all_layer_names:\n            if not rs.IsLayer(layer_name):\n                rs.AddLayer(layer_name)\n            else:\n                clear_layer(layer_name)\n\n        # Create new guid dictionary / clear out previously-saved guids.\n        for beam_id in self.process.assembly.beam_ids():\n            self.delete_interactive_beam_visualization(beam_id, redraw=False)\n            self.delete_beam_all_positions(beam_id=beam_id, redraw=False)\n            self.delete_gripper_all_positions(beam_id, redraw=False)\n            for joint_id in self.process.assembly.get_joint_ids_of_beam(beam_id):\n                self.delete_asstool_all_positions(joint_id=joint_id, redraw=False)\n\n        self._state_visualization_guids = {}\n        self._tools_in_storage_guids = {}\n\n    ######################\n    # Drawing Gripper\n    ######################\n\n    def draw_gripper_all_positions(self, beam_id, delete_old=False, verbose=False, redraw=True):\n        \"\"\" Delete old gripper geometry if delete_old is True\n        Redraw them in Rhino in different layers.\n        The resulting Rhino guids are kept in self.gripper_guids[beam_id][gripper_position]\n\n        This applies to all positions where the attribute is set in beam attributes.\n        \"\"\"\n        rs.EnableRedraw(False)\n\n        if self.process.assembly.get_assembly_method(beam_id) != BeamAssemblyMethod.MANUAL_ASSEMBLY:\n            for gripper_position in ProcessKeyPosition().possible_gripper_positions:\n                layer_name = 'itj::gripper::' + gripper_position\n                # If not delete_old, and there are already items drawn, we preserve them.\n                if len(self.gripper_guids_at_position(beam_id, gripper_position)) > 0 and not delete_old:\n                    continue\n\n                # Check if the position string contains a dot notation for states , such as open gripper\n                tool_states = []  # tool_states are function names that chagen state of the tool\n                attribute_name = gripper_position\n                if '.' in gripper_position:\n                    attribute_name = gripper_position.split('.')[0]\n                    tool_states = gripper_position.split('.')[1:]\n                layer_name = 'itj::gripper::' + gripper_position\n\n                # Delete old geometry\n                self.delete_gripper_at_position(beam_id, gripper_position, redraw=False)\n\n                # Skip the rest of code if the position does not exist.\n                if self.process.assembly.get_beam_attribute(beam_id, attribute_name) is None:\n                    if verbose:\n                        print(\"Skipping Gripper on Beam(%s) at position: %s\" % (beam_id, attribute_name))\n                    continue\n\n                # Draw Gripper\n                if verbose:\n                    print(\"Drawing Gripper for Beam(%s) in position: %s\" % (beam_id, attribute_name))\n                gripper = self.process.get_gripper_of_beam(beam_id, attribute_name)\n\n                # Set Tool State (better visualization)\n                for state in tool_states:\n                    getattr(gripper, state)()\n\n                artist = ToolArtist(gripper, layer_name)\n                new_guids = gripper.draw_visual(artist)\n                self.gripper_guids_at_position(beam_id, gripper_position).extend(new_guids)\n\n                # Draw ToolChanger and Robot Wrist\n                new_guids = self.draw_toolchanger_and_robot_wrist(beam_id, gripper.current_frame, layer_name, )\n                self.gripper_guids_at_position(beam_id, gripper_position).extend(new_guids)\n\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def draw_toolchanger_and_robot_wrist(self, beam_id, tcp_frame, layer_name):\n        # type: (str, Frame, str) -> list[guid]\n        new_guids = []\n\n        # Draw Tool Changer with TCP at tcp_frame\n        tool_changer = self.process.robot_toolchanger\n        tool_changer.set_current_frame_from_tcp(tcp_frame)\n        new_guids.extend(tool_changer.draw_visual(ToolArtist(tool_changer, layer_name)))\n        # Draw rob_wrist at tool_changer.current_frame\n        robot_wrist = self.process.robot_wrist\n        robot_wrist.current_frame = tool_changer.current_frame\n        new_guids.extend(robot_wrist.draw_visual(ToolArtist(robot_wrist, layer_name)))\n\n        return new_guids\n\n    def delete_gripper_all_positions(self, beam_id, redraw=True):\n        \"\"\"Delete all Rhino geometry associated to a a gripper.\n        All positions are deleted\n        \"\"\"\n        rs.EnableRedraw(False)\n        for gripper_position in ProcessKeyPosition().possible_gripper_positions:\n            # The redraw is supressed in each individual call to save time.\n            self.delete_gripper_at_position(beam_id, gripper_position, redraw=False)\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def delete_gripper_at_position(self, beam_id, gripper_position, redraw=True):\n        \"\"\"Delete all Rhino geometry associated to a gripper at specified position\n\n        No change will be made if the beam_id or gripper_position do not exist in the guid dictionary.\n        \"\"\"\n\n        guids = self.gripper_guids_at_position(beam_id, gripper_position)\n        if len(guids) > 0:\n            purge_objects(guids, redraw)\n            del self.gripper_guids_at_position(beam_id, gripper_position)[:]\n\n    def show_gripper_at_one_position(self, beam_id, position=None, color=None):\n        \"\"\" Show Gripper only at the specified position.\n\n        `position` is the position attribute name, if left `None`,\n        selected_key_position saved in artist will be used.\n\n        `color` is a string as used in artist.color_meaning.get(color)\n        \"\"\"\n        if position is None:\n            position = self.selected_key_position.current_gripper_pos\n\n        for gripper_position in ProcessKeyPosition().possible_gripper_positions:\n            if gripper_position == position:\n                rs.ShowObject(self.gripper_guids_at_position(beam_id, gripper_position))\n                # Change color for shown object\n                if color is not None:\n                    rs.ObjectColor(self.gripper_guids_at_position(beam_id, gripper_position), self.color_meaning.get(color))\n            else:\n                rs.HideObject(self.gripper_guids_at_position(beam_id, gripper_position))\n\n    def hide_gripper_all_positions(self, beam_id):\n        \"\"\" Hide all gripper instances in the specified positions.\n\n        `positions` are defaulted to all position.\n        \"\"\"\n\n        self.show_gripper_at_one_position(beam_id, '')\n\n    ######################\n    # Drawing Clamp\n    ######################\n\n    def draw_asstool_all_positions(self, beam_id, delete_old=False, verbose=False, redraw=True):\n        \"\"\" Delete old Assembly Tool (Clamps/Screwdrivers) geometry if delete_old is True\n        Redraw them in Rhino in different layers.\n        The resulting Rhino guids are kept in self.asstool_guids(joint_id, clamp_position)\n\n        This applies to all positions where the attribute is set in joint attributes.\n        \"\"\"\n        rs.EnableRedraw(False)\n        # Loop through all clamps that are clamping this beam\n        for joint_id in self.process.assembly.get_joint_ids_with_tools_for_beam(beam_id):\n            # Smart about the tool positions of this beam\n            tool_positions = ProcessKeyPosition(self.process, beam_id).get_all_asstool_positions\n            # Loop through each position\n            for tool_position in tool_positions:\n                # If not delete_old, and there are already items drawn, we preserve them.\n                if len(self.asstool_guids_at_position(joint_id, tool_position)) > 0 and not delete_old:\n                    continue\n\n                # Check if the position string contains a dot notation for states , such as open gripper\n                tool_states = []  # tool_states are function names that chagen state of the tool\n                attribute_name = tool_position\n                if '.' in tool_position:\n                    attribute_name = tool_position.split('.')[0]\n                    tool_states = tool_position.split('.')[1:]\n                layer_name = 'itj::tool::' + tool_position\n\n                # Delete old geometry\n                self.delete_asstool_at_position(joint_id, tool_position, redraw=False)\n\n                # Skip the rest of code if the position does not exist.\n                if self.process.assembly.get_joint_attribute(joint_id, attribute_name) is None:\n                    if verbose:\n                        print(\"Skipping tool(%s) at position: %s\" % (joint_id, attribute_name))\n                    continue\n\n                # Draw Tool\n                if verbose:\n                    print(\"Drawing Tool(%s) for Beam(%s) in position: %s\" % (joint_id, beam_id, tool_position))\n                tool = self.process.get_tool_of_joint(joint_id, attribute_name)\n\n                # Set Tool State (better visualization)\n                for state in tool_states:\n                    getattr(tool, state)()\n\n                artist = ToolArtist(tool, layer_name)\n                new_guids = tool.draw_visual(artist)\n                self.asstool_guids_at_position(joint_id, tool_position).extend(new_guids)\n\n                # Draw ToolChanger and Robot Wrist\n                new_guids = self.draw_toolchanger_and_robot_wrist(beam_id, tool.current_frame, layer_name)\n                self.asstool_guids_at_position(joint_id, tool_position).extend(new_guids)\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def delete_asstool_all_positions(self, joint_id, redraw=True):\n        \"\"\"Delete all Rhino geometry associated to Assembly Tool\n        (Clamp/Screwdriver). All positions are deleted\n        \"\"\"\n        rs.EnableRedraw(False)\n        beam_id = joint_id[1]\n        for tool_position in ProcessKeyPosition(self.process, beam_id).get_all_asstool_positions:\n            # The redraw is supressed in each individual call to save time.\n            self.delete_asstool_at_position(joint_id, tool_position, redraw=False)\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def delete_asstool_at_position(self, joint_id, tool_position, redraw=True):\n        \"\"\"Delete all Rhino geometry associated to an Assembly Tool\n        (Clamp/Screwdriver) at specified position\n\n        No change will be made if the joint_id or tool_position\n        do not exist in the guid dictionary.\n        \"\"\"\n\n        guids = self.asstool_guids_at_position(joint_id, tool_position)\n        if len(guids) > 0:\n            purge_objects(guids, redraw=False)\n            del self.asstool_guids_at_position(joint_id, tool_position)[:]\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def show_asstool_at_one_position(self, beam_id, position=None, color=None):\n        \"\"\" Show Assembly Tool (Clamp/Screwdriver) only at the specified position.\n\n        `position` is the position attribute name, if left `None`,\n        selected_key_position saved in artist will be used.\n\n        `color` is a string as used in artist.color_meaning.get(color)\n        \"\"\"\n        if position is None:\n            position = self.selected_key_position.current_clamp_pos\n\n        for joint_id in self.process.assembly.get_joint_ids_with_tools_for_beam(beam_id):\n            for tool_position in ProcessKeyPosition(self.process, beam_id).get_all_asstool_positions:\n                if tool_position == position:\n                    rs.ShowObject(self.asstool_guids_at_position(joint_id, tool_position))\n                    # Change color for shown object\n                    if color is not None:\n                        rs.ObjectColor(self.asstool_guids_at_position(joint_id, tool_position), self.color_meaning.get(color))\n                else:\n                    rs.HideObject(self.asstool_guids_at_position(joint_id, tool_position))\n\n    def hide_asstool_all_positions(self, beam_id):\n        \"\"\" Hide all gripper instances in the specified positions.\n\n        `positions` are defaulted to all position.\n        \"\"\"\n        self.show_asstool_at_one_position(beam_id, '')\n\n    #################################\n    # Tools in storage Visualization\n    #################################\n\n    def draw_tool_in_storage(self, tool_id, delete_old=False):\n        tool = self.process.tool(tool_id)\n        if len(self.tools_in_storage_guids(tool_id)) > 0 and not delete_old:\n            self.show_tool_in_storage(tool_id)\n            return\n        layer_name = self.tools_in_storage_layer\n\n        # Set default state\n        if isinstance(tool, Clamp):\n            tool.open_clamp()\n        if isinstance(tool, Gripper):\n            tool.close_gripper()\n\n        # Delete old geometry\n            self.delete_tool_in_storage(tool_id)\n\n        # Set Tool to storage frame\n        tool.current_frame = tool.tool_storage_frame.copy()\n\n        # Artist Draw Tool add Guids to dictionary\n        artist = ToolArtist(tool, layer_name)\n        new_guids = tool.draw_visual(artist)\n        del self.tools_in_storage_guids(tool_id)[:]\n        self.tools_in_storage_guids(tool_id).extend(new_guids)\n\n    def show_tool_in_storage(self, tool_id):\n        rs.ShowObject(self.tools_in_storage_guids(tool_id))\n\n    def hide_tool_in_storage(self, tool_id):\n        rs.HideObject(self.tools_in_storage_guids(tool_id))\n\n    def hide_all_tools_in_storage(self):\n        for tool_id in self._tools_in_storage_guids.keys():\n            self.hide_tool_in_storage(tool_id)\n\n    def delete_tool_in_storage(self, tool_id):\n        purge_objects(self.tools_in_storage_guids(tool_id), redraw=False)\n        del self.tools_in_storage_guids(tool_id)[:]\n\n    def delete_all_tools_in_storage(self):\n        for tool_id in self._tools_in_storage_guids.keys():\n            self.delete_tool_in_storage(tool_id)\n\n    #############\n    # Env Mesh\n    #############\n\n    def draw_all_env_mesh(self, delete_old=False, redraw=True):\n        rs.EnableRedraw(False)\n        if delete_old:\n            self.draw_all_env_mesh(redraw=False)\n        rs.CurrentLayer(self.env_mesh_layer)\n        for env_id, mesh in self.process.environment_models.items():\n            # Draw the geometry only if it hasen't been drawn yet\n            if len(self.env_mesh_guids(env_id)) == 0:\n                guids = self.draw_meshes_get_guids([mesh], env_id, redraw=False, color=self.color_meaning['env_model'])\n                self.env_mesh_guids(env_id).extend(guids)\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def delete_all_env_mesh(self, redraw=True):\n        rs.EnableRedraw(False)\n        for env_id, guids in self._env_mesh_guids.items():\n            purge_objects(guids, redraw=False)\n            del self.env_mesh_guids(env_id)[:]\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def hide_all_env_mesh(self, redraw=True):\n        rs.EnableRedraw(False)\n        for env_id in self._env_mesh_guids.keys():\n            rs.HideObject(self.env_mesh_guids(env_id))\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def show_all_env_mesh(self, redraw=True):\n        rs.EnableRedraw(False)\n        for env_id in self._env_mesh_guids.keys():\n            rs.ShowObject(self.env_mesh_guids(env_id))\n        if redraw:\n            rs.EnableRedraw(True)\n\n    ######################\n    # Robot\n    ######################\n\n    def draw_robot(self, configuration, draw_collision=True, auto_hide=True, redraw=False):\n        # type: (Configuration, bool, bool, bool) -> None\n        \"\"\"Draws process.robot_model in Rhino viewport in mm scale.\n\n        `configuration` can be full or partial Configuration of the RobotModel.\n        If a partial config is given, the other values will be filled in from robot_initial_config.\n        It must be in meter scale as consistent with process.robot_initial_config\n\n        \"\"\"\n        # Skip if robot model is not set\n        if self.process.robot_model is None:\n            return\n\n        # Update config\n        merged_config = self.process.robot_initial_config.scaled(1000).merged(configuration.scaled(1000))\n        self.robot_artist.update(merged_config)\n\n        # Clear old geometry\n        guid_key = 'collision' if draw_collision else 'visual'\n        self.delete_robot(guid_key)\n\n        # Redraw Robot\n        rs.EnableRedraw(False)\n        if auto_hide:\n            self.hide_robot()\n        if draw_collision:\n            self._robot_guids[guid_key] = self.robot_artist.draw_collision()\n        else:\n            self._robot_guids[guid_key] = self.robot_artist.draw_visual()\n\n        # Redraw\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def delete_robot(self, guid_key=None, redraw=False):\n        # type: (str, bool) -> None\n        if guid_key is None:\n            guid_keys = ['collision', 'visual']\n        else:\n            guid_keys = [guid_key]\n\n        for guid_key in guid_keys:\n            purge_objects(self._robot_guids[guid_key], redraw=False)\n            self._robot_guids[guid_key] = []\n\n    def show_robot_collision(self, redraw=False):\n        # type: (bool) -> None\n        rs.EnableRedraw(False)\n        for guid in self._robot_guids['collision']:\n            rs.ShowObject(guid)\n        print(\"Unhiding Robot collision\")\n        # Redraw\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def show_robot_visual(self, redraw=False):\n        # type: (bool) -> None\n        rs.EnableRedraw(False)\n        for guid in self._robot_guids['visual']:\n            rs.ShowObject(guid)\n        print(\"Unhiding Robot visual\")\n        # Redraw\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def hide_robot(self, redraw=False):\n        # type: (bool) -> None\n        \"\"\"Hide the RobotModel in Rhino. Not deleting it\"\"\"\n        rs.EnableRedraw(False)\n\n        for guid in self._robot_guids['collision']:\n            rs.HideObject(guid)\n        for guid in self._robot_guids['visual']:\n            rs.HideObject(guid)\n\n        if redraw:\n            rs.EnableRedraw(True)\n\n    ######################\n    # State\n    ######################\n\n    def get_current_selected_scene_state(self, override_attached_objects_with_fk=True, robot_config_override=None):\n        # type: (bool, Configuration) -> SceneState\n        \"\"\"\n        Return the currently selected SceneState\n\n        if `override_attached_objects_with_fk` is true, and if robot config is defined,\n        the frame of the attached objects will be overridden by the FK result of the robot.\n\n        Note state_id = 1 is referring to end of the first (0) movement.\n\n        robot_config_override can be used to supply an alternative robot configuration\n        for visualizing a trajectory point. Otherwise the end config the movement is the\n        default configuration.\n        \"\"\"\n        state_id = self.selected_state_id\n        scene = None\n        # Short circuit for returning the initial state.\n        # No override_attached_objects_with_fk will be performed.\n        if state_id == 0:\n            scene = self.process.initial_state\n            return scene\n\n        movement = self.process.movements[state_id - 1]  # type: RoboticMovement\n        scene = self.process.get_movement_end_scene(movement)\n\n        # Override robot configuration\n        if robot_config_override is not None:\n            scene[('robot', 'c')] = robot_config_override\n\n        process = self.process\n        if override_attached_objects_with_fk:\n            if isinstance(movement, RoboticMovement):\n                if ('robot', 'c') in scene and scene[('robot', 'c')] is not None:\n                    from copy import deepcopy\n                    scene = deepcopy(scene)\n\n                    # * Compute FK\n                    configuration = scene[('robot', 'c')]  # type: Configuration\n                    fk_flange_frame = process.robot_model.forward_kinematics(configuration.scaled(1000), process.ROBOT_END_LINK)\n                    t_world_from_flange = Transformation.from_frame(fk_flange_frame)\n                    scene[('tool_changer', 'f')] = fk_flange_frame\n\n                    # * Set attached objects, use `t_flange_from_attached_objects` in Movement\n                    for object_id, t_flange_from_attached_objects in zip(movement.attached_objects, movement.t_flange_from_attached_objects):\n                        t_world_from_object = t_world_from_flange * t_flange_from_attached_objects\n                        scene[(object_id, 'f')] = Frame.from_transformation(t_world_from_object)\n\n        return scene\n\n    def _get_state_attached_objects_meshes(self, scene, attached_objects_only=False, moved_objects_only=False):\n        # type: (SceneState, bool, bool) -> Dict[str, Tuple[Frame, List[Mesh]]]\n        \"\"\"Returns all object meshes in the given scene\n\n        Meshes of each object is accessed from `dict[object_id]`.\n        This contains a tuple:\n        - First item is the ObjectState of that object\n        - Second item is a list of all the Meshes\n\n        If `moved_objects_only == True` it will return only object whose current state is different from\n        that in `self.state_visualization_current_state`. This can allow more efficiently redrawing to avoid repeating already existing geometry.\n\n        If `attached_objects_only == True`, it will return only the the objects whose `scene[(obj_id, 'a')]` == True\n        This is useful for drawing sweep visualization for attached geometry.\n\n        \"\"\"\n\n        # * Temp holder for object_id and their list of Compas Meshes\n        meshes_for_objects = {}\n\n        # * Beams\n        for beam_id in self.process.assembly.sequence:\n            if attached_objects_only and not scene[(beam_id, 'a')]:\n                continue\n            object_state = ObjectState(scene[(beam_id, 'f')], scene[(beam_id, 'a')], scene[(beam_id, 'c')])\n            if moved_objects_only and object_state == self.state_visualization_current_state.get(beam_id, None):\n                continue\n            beam = self.process.assembly.beam(beam_id)\n            beam_mesh = self.process.assembly.get_beam_mesh_in_wcf(beam_id)\n            T = Transformation.from_frame_to_frame(beam.frame, scene[(beam_id, 'f')])\n            meshes_for_objects[beam_id] = (object_state, [beam_mesh.transformed(T)])\n\n        # # * Tools\n        for tool_id in self.process.tool_ids:\n            if attached_objects_only and not scene[(tool_id, 'a')]:\n                continue\n            object_state = ObjectState(scene[(tool_id, 'f')], scene[(tool_id, 'a')], scene[(tool_id, 'c')])\n            if moved_objects_only and object_state == self.state_visualization_current_state.get(tool_id, None):\n                continue\n            tool = self.process.tool(tool_id)\n            meshes_for_objects[tool_id] = (object_state, tool.draw_state(object_state))\n\n        # * Tool Changer\n        object_state = ObjectState(scene[('tool_changer', 'f')], True, None)\n        if moved_objects_only and object_state == self.state_visualization_current_state.get('tool_changer', None):\n            pass\n        else:\n            meshes_for_objects['tool_changer'] = (object_state, self.process.robot_toolchanger.draw_state(object_state))\n\n        return meshes_for_objects\n\n    def draw_meshes_get_guids(self, meshes, name, disjoint=True, redraw=False, color=None):\n        \"\"\"\n        Draws a mesh to Rhino in a specific color and return the guids.\n\n        Layer is not handeled here to avoid unnecessary repeated calls and save time.\n        Call rs.CurrentLayer(layer) to change layer.\n\n        To save time, redraw defaults to False, which will not trigger Rhino redrawing.\n        You should call rs.EnableRedraw(True) after multiple calls to this function.\n        \"\"\"\n        guids = []\n        rs.EnableRedraw(False)\n        for mesh in meshes:\n            v, f = mesh.to_vertices_and_faces()\n            # Redraw for individual call supressed here.\n            guid = draw_mesh(v, f, name=name, redraw=False, disjoint=disjoint, color=color)\n            guids.append(guid)\n        if redraw:\n            rs.EnableRedraw(True)\n        return guids\n\n    def draw_state(self, scene=None, redraw=True):\n        # type: (SceneState, bool) -> None\n        \"\"\"Draw objects that relates to a specific object state dictionary.\n\n        If robot configuration is defined, the robot model will be drawn. Otherwise, rob_wrist will be displayed.\n\n        This function is used for both Visualize Movement and Visualize Trajectory\n\n        You do not have to call delete_state() to erase previous geometry.\n        Old geometry that are same as new geometry will not be redrawn\n\n        \"\"\"\n        if scene is None:\n            # Limit range\n            if self.selected_state_id < 0:\n                self.selected_state_id = 0\n            if self.selected_state_id > len(self.process.movements):\n                self.selected_state_id = len(self.process.movements)\n            scene = self.get_current_selected_scene_state()\n\n        # Layer:\n        rs.CurrentLayer(self.state_visualization_layer)\n        rs.EnableRedraw(False)\n\n        # * Temp holder for object_id and their list of Compas Meshes\n        meshes_for_objects = self._get_state_attached_objects_meshes(scene, moved_objects_only=True)\n\n        # * Draw Robot if state has robot config otherwise draw robot wrist\n        # Drawing Robot Geometry in Rhino and GUIDs is not managed by the draw method above.\n        # It is directly managed by the draw_robot() function\n        if ('robot', 'c') in scene and scene[('robot', 'c')] is not None:\n            # Delete rob_wrist\n            if len(self.state_visualization_guids('rob_wrist')) > 0:\n                self.delete_state_by_object_id('rob_wrist')\n            # Draw Robot\n            configuration = scene[('robot', 'c')]\n            self.draw_robot(configuration)\n\n        else:\n            # Delete Robot\n            self.delete_robot()\n            # Draw rob_wrist\n            robot_wrist = self.process.robot_wrist\n            robot_wrist.current_frame = scene[('robot', 'f')]\n            meshes_for_objects['rob_wrist'] = (scene[('robot', 'f')], robot_wrist.draw_visual())\n\n        # * Draw meshes to Rhino and add guids to tracking dict\n        for object_id in meshes_for_objects:\n            object_state, meshes = meshes_for_objects[object_id]\n            if meshes is None:\n                continue\n\n            # * Delete old geometry automatically\n            if len(self.state_visualization_guids(object_id)) > 0:\n                self.delete_state_by_object_id(object_id)\n\n            # * Draw mesh, save its current frame for faster partial refresh later.\n            guids = self.draw_meshes_get_guids(meshes, object_id, redraw=False)\n            self.state_visualization_guids(object_id).extend(guids)\n            self.state_visualization_current_state[object_id] = object_state\n            # Add a color to the objects that are attached-to-robot\n            attachment_key = (object_id, 'a')\n            if attachment_key in scene and scene[attachment_key]:\n                meshes_apply_color(guids, (0.7, 1, 1, 1))\n            if object_id == 'rob_wrist':\n                meshes_apply_color(guids, (0.6, 1, 1, 1))\n\n        # Enable Redraw\n        if redraw:\n            rs.EnableRedraw(True)\n            sc.doc.Views.Redraw()\n\n    def delete_state_by_object_id(self, object_id):\n        guids = self.state_visualization_guids(object_id)\n        purge_objects(guids, redraw=False)\n        del self.state_visualization_guids(object_id)[:]\n        del self.state_visualization_current_state[object_id]\n\n    def delete_state(self, redraw=True):\n        # type: (bool) -> None\n        \"\"\"Delete all geometry that is related to showing object state\"\"\"\n        for object_id, guids in self._state_visualization_guids.items():\n            purge_objects(guids, redraw=False)\n        self._state_visualization_guids = {}\n        self.state_visualization_current_state = {}\n        # Delete old robot visualization\n        self.delete_robot()\n        # Enable Redraw\n        if redraw:\n            rs.EnableRedraw(True)\n            sc.doc.Views.Redraw()\n\n    ######################\n    # Trajectory\n    ######################\n\n    def _draw_mesh_sweep_polyline(self, mesh, transformations, color=(0, 30, 180)):\n        # type: (Mesh, list[Transformation], Tuple(int,int,int)) -> list[guid]\n        polyline_dicts = []\n        welded_mesh = mesh_weld(mesh, 15)\n        vertices, faces = welded_mesh.to_vertices_and_faces()\n        transposed_transformations = [transpose_matrix(T) for T in transformations]\n\n        for vertex in vertices:\n            polyline_dict = {'points': [], 'color': color}\n            for t in transformations:\n                # vertice = Point(* vertice)\n                # mesh_vertice_on_trajectory = vertice.transformed(t)\n                mesh_vertice_on_trajectory = transform_points([vertex], t)[0]\n                polyline_dict['points'].append(mesh_vertice_on_trajectory)\n            polyline_dicts.append(polyline_dict)\n        return draw_polylines(polyline_dicts, redraw=False)\n\n    def draw_sweep_trajectory(self, scene, redraw=True):\n        # type: (SceneState, bool) -> None\n        from compas.geometry import Transformation, Frame\n        assembly = self.process.assembly  # type: Assembly\n        rs.EnableRedraw(False)\n\n        # * Skip if the state is at initial_state\n        state_id = self.selected_state_id\n        if state_id <= 0:\n            return\n        if state_id > len(self.process.movements):\n            return\n\n        # * Skip if the movement is not RoboticMovement or if movement.trajectory is empty\n        movement = self.process.movements[state_id - 1]  # type: RoboticMovement\n        movement_id = movement.movement_id\n        if not isinstance(movement, RoboticMovement):\n            return\n        if movement.trajectory is None:\n            return\n\n        # * Perform FK to convert JointTrajectoryPoint to frame (mm scale)\n        trajectory_frames = []\n        for config in movement.trajectory.points:\n            configuration = self.process.robot_initial_config.merged(config)\n            trajectory_frame = self.process.robot_model.forward_kinematics(configuration.scaled(1000), self.process.ROBOT_END_LINK)\n            trajectory_frames.append(trajectory_frame)\n\n        # * Convert Trajectory to a list of transforamtion\n        t_t0cp_at_final_from_world = Transformation.from_frame(movement.target_frame).inverse()\n        transformations = []\n        for frame in trajectory_frames:\n            t_world_from_t0cp_at_traj = Transformation.from_frame(frame)\n            t = t_world_from_t0cp_at_traj * t_t0cp_at_final_from_world\n            transformations.append(t)\n\n        # * Draw Attached objects\n        # Scene\n        guids = {}\n        meshes_for_objects = self._get_state_attached_objects_meshes(scene, attached_objects_only=True)\n        print(\"Drawing %s Sweep Trajectory with %i meshes and %i trajectory points.\" % (movement_id, len(meshes_for_objects), len(trajectory_frames)))\n        for object_id in meshes_for_objects:\n            guids[object_id] = []\n            object_state, meshes = meshes_for_objects[object_id]\n            for mesh in meshes:\n                new_guids = self._draw_mesh_sweep_polyline(mesh, transformations, (0, 30, 180))\n                guids[object_id].extend(new_guids)\n        self._trajectory_visualization_guids = guids\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def delete_sweep_trajectory(self, redraw=False):\n        # type: (bool) -> None\n        \"\"\"Delete all geometry that is related to showing object state\"\"\"\n        for object_id, guids in self._trajectory_visualization_guids.items():\n            # print (\"Del old sweep: %i\" % len(guids))\n            purge_objects(guids, redraw=False)\n        self._trajectory_visualization_guids = {}\n        # Delete old robot visualization\n        self.delete_robot()\n        # Enable Redraw\n        if redraw:\n            rs.EnableRedraw(True)\n\n\ndef meshes_apply_color(guids, color):\n    for guid in guids:\n        obj = sc.doc.Objects.Find(guid)\n        r, g, b, a = [i * 255 for i in color]\n        attr = obj.Attributes\n        attr.ObjectColor = Color.FromArgb(a, r, g, b)\n        attr.ColorSource = ColorFromObject\n        obj.CommitChanges()\n\n\nif __name__ == \"__main__\":\n\n    from integral_timber_joints.rhino.load import get_process, get_process_artist, load_process\n\n    # Draw beams to canvas\n    # load_process()\n\n    artist = get_process_artist()\n    # artist.empty_layers()\n    process = get_process()\n    # for beam_id in process.assembly.beam_ids():\n    #     artist.draw_beam_seqtag(beam_id)\n    \"\"\"Draw the clamp as a block. Block name is the clamp_type\"\"\"\n    for tool_type in process.available_assembly_tool_types:\n        tool = process.get_one_tool_by_type(tool_type).copy()\n        tool.open_gripper()\n        tool.current_frame = Frame.worldXY()\n        meshes = tool.draw_visuals()\n        guids = []\n        for mesh in meshes:\n            v, f = mesh.to_vertices_and_faces()\n            layer = 'itj::tool'\n            guids.append(draw_mesh(v, f, name=tool_type, layer=layer))\n        block = rs.AddBlock(guids, (0, 0, 0), tool_type, True)\n        #rs.InsertBlock(block, (10,10,10))\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}