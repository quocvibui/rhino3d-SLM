{
  "source_url": "https://github.com/bjacquemyn/coral-growth-gh/blob/a73d7eebc91e342de6069c42aa29b3be9a3144c6/gh/coral_component_example.py",
  "repo": "bjacquemyn/coral-growth-gh",
  "repo_stars": 0,
  "repo_description": "Coral growth algorithms for Grasshopper + Python with Git version control",
  "license": "unknown",
  "filepath": "gh/coral_component_example.py",
  "instruction": "Example GhPython component script for coral growth.",
  "code": "\"\"\"\nExample GhPython component script for coral growth.\n\nThis shows the recommended pattern for using the coral growth algorithm\nin Grasshopper, with proper Point3d to tuple conversion.\n\nINPUTS:\n  start: Point3d - Starting point for coral growth (as a Grasshopper Point)\n  iterations: int - Number of growth iterations (default: 5)\n  branch_length: float - Length of each branch segment (default: 2.0)\n  branch_angle: float - Maximum deviation angle in degrees (default: 25)\n  split_probability: float - Probability of branching (0-1, default: 0.7)\n  seed: int - Random seed for reproducibility (optional)\n  stem_generations: int - Generations forced to single stem before branching (default: 0)\n  stem_angle: float - Max deviation angle for the main stem in degrees (optional; default: use branch_angle)\n  length_jitter: float - Random variation factor for branch length (0-1, default: 0.0)\n  angle_jitter: float - Random variation factor for branch angle (0-1, default: 0.0)\n  length_decay: float - Multiplicative decay factor for branch length per generation (0-1, default: 0.0)\n  angle_scale: float - Scaling factor for branch angles (default: 1.0)\n  avoid_radius: float - Minimum distance between branch endpoints (default: 0.0)\n  twist_rate: float - Rotational twist rate in degrees per iteration (default: 0.0)\n  terminate_probability: float - Probability of branch tip termination (0-1, default: 0.0)\n  mean_branch_number: float - Mean number of children per node (optional; >0 enables multi-branching)\n\nOUTPUTS:\n  out: Primary output - List of Curve objects (LineCurve) for visualization\n  lines: Same as 'out' - List of Curve objects (LineCurve) for visualization\n  segments: Alias of 'lines' for convenience (Curve list)\n  segments_raw: List of raw segment data (tuples)\n  end_segments: LineCurves that terminate the coral (no further branching)\n  end_points: Points at the tips of end_segments (Point3d list)\n\"\"\"\n\nimport sys\nimport os\n\n# Ensure the repo's python/ folder is on sys.path so we can import coral.*\ndef _ensure_repo_python_on_path():\n    attempted = []\n\n    def _add(p):\n        if p and os.path.isdir(p) and p not in sys.path:\n            sys.path.insert(0, p)\n\n    # 1) Explicit override via environment variable\n    env_path = os.getenv('CORAL_GH_PYTHON_PATH')\n    if env_path:\n        attempted.append(env_path)\n        _add(env_path)\n\n    # 2) Based on the Grasshopper document location\n    gh_doc = ghenv.Component.OnPingDocument()\n    if gh_doc:\n        gh_file = getattr(gh_doc, 'FilePath', None)\n        if gh_file:\n            gh_dir = os.path.dirname(gh_file)\n\n            # Common layout: repo_root/gh/<file>.gh -> repo_root/python\n            if os.path.basename(gh_dir).lower() == 'gh':\n                repo_root = os.path.dirname(gh_dir)\n            else:\n                # If the .gh is not inside a 'gh' folder, try its parent as root\n                repo_root = gh_dir\n\n            candidates = [\n                os.path.join(repo_root, 'python'),   # preferred\n                os.path.join(gh_dir, 'python'),      # legacy sibling layout\n            ]\n\n            # Upward search (max 5 levels) for a python/coral folder\n            cur = gh_dir\n            for _ in range(5):\n                candidates.append(os.path.join(cur, 'python'))\n                cur = os.path.dirname(cur)\n\n            for c in candidates:\n                c = os.path.normpath(c)\n                if c not in attempted:\n                    attempted.append(c)\n                if os.path.isdir(os.path.join(c, 'coral')):\n                    _add(c)\n\n    return attempted\n\n_attempted_paths = _ensure_repo_python_on_path()\n\n# Import coral growth algorithm module and force a reload so changes are picked up in GH\ntry:\n    import coral.growth_models.simple_branching as _simple_branching\nexcept ImportError as _e:\n    msg = (\n        \"Could not import 'coral.growth_models.simple_branching'.\\n\"\n        \"Check that your Grasshopper file is saved inside the repo (e.g., ...\\\\coral-growth-gh\\\\gh\\\\yourfile.gh),\\n\"\n        \"or set the environment variable CORAL_GH_PYTHON_PATH to the absolute path of the repo's 'python' folder.\\n\\n\"\n        \"Attempted locations:\\n  - \" + \"\\n  - \".join(_attempted_paths)\n    )\n    raise ImportError(msg)\n\n# Reload for CPython3 (Rhino 8) or IronPython fallback\ntry:\n    import importlib  # CPython 3.x\n    _simple_branching = importlib.reload(_simple_branching)\nexcept Exception:\n    try:\n        # IronPython 2.7 reload\n        _simple_branching = reload(_simple_branching)  # type: ignore\n    except Exception:\n        pass\n\ngrow_coral = _simple_branching.grow_coral\nimport Rhino.Geometry as rg\n\n# Convert Grasshopper input to a plain (x, y, z) tuple at the boundary\n# Accepts Rhino.Geometry.Point3d or an (x, y, z) iterable\ndef _as_tuple3(value):\n    try:\n        # Support tuple/list-like\n        x, y, z = value\n        return (float(x), float(y), float(z))\n    except Exception:\n        pass\n    # Support Rhino Point3d\n    if hasattr(value, \"X\") and hasattr(value, \"Y\") and hasattr(value, \"Z\"):\n        return (float(value.X), float(value.Y), float(value.Z))\n    # Fallback default\n    return (0.0, 0.0, 0.0)\n\nstart_tuple = _as_tuple3(start)\n\n# Call the growth algorithm with plain tuple\n# Robustly coerce GH inputs to valid Python types with sensible defaults\ndef _as_int(value, default):\n    try:\n        if value is None:\n            return default\n        return int(round(float(value)))\n    except Exception:\n        return default\n\ndef _as_float(value, default):\n    try:\n        if value is None:\n            return default\n        return float(value)\n    except Exception:\n        return default\n\ndef _as_prob(value, default):\n    v = _as_float(value, default)\n    # clamp to [0, 1]\n    return max(0.0, min(1.0, v))\n\ndef _as_seed(value):\n    if value in (None, \"\", False):\n        return None\n    try:\n        return int(value)\n    except Exception:\n        return None\n\niterations_val = _as_int(globals().get('iterations', None), 5)\nbranch_length_val = _as_float(globals().get('branch_length', None), 2.0)\nbranch_angle_val = _as_float(globals().get('branch_angle', None), 25)\nsplit_prob_val = _as_prob(globals().get('split_probability', None), 0.7)\nseed_val = _as_seed(globals().get('seed', None))\nstem_generations_val = max(0, _as_int(globals().get('stem_generations', None), 0))\nstem_angle_val = globals().get('stem_angle', None)\ntry:\n    stem_angle_val = None if stem_angle_val in (None, \"\", False) else float(stem_angle_val)\nexcept Exception:\n    stem_angle_val = None\n\n# New parameters\nlength_jitter_val = _as_prob(globals().get('length_jitter', None), 0.0)\nangle_jitter_val = _as_prob(globals().get('angle_jitter', None), 0.0)\nlength_decay_val = _as_prob(globals().get('length_decay', None), 0.0)\nangle_scale_val = _as_float(globals().get('angle_scale', None), 1.0)\navoid_radius_val = _as_float(globals().get('avoid_radius', None), 0.0)\ntwist_rate_val = _as_float(globals().get('twist_rate', None), 0.0)\nterminate_probability_val = _as_prob(globals().get('terminate_probability', None), 0.0)\n\n# New branching multiplicity parameter (optional)\ndef _as_mean_branches(value):\n    try:\n        if value in (None, \"\", False):\n            return None\n        v = float(value)\n        return None if v <= 0 else v\n    except Exception:\n        return None\n\nmean_branch_number_val = _as_mean_branches(globals().get('mean_branch_number', None))\n\n_debug_lines = []\n\n_debug_lines.append(\"=== Coral growth inputs ===\")\n_debug_lines.append(\"start: {}\".format(start_tuple))\n_debug_lines.append(\"iterations: {}\".format(iterations_val))\n_debug_lines.append(\"branch_length: {:.6g}\".format(branch_length_val))\n_debug_lines.append(\"branch_angle: {:.6g}\".format(branch_angle_val))\n_debug_lines.append(\"split_probability: {:.6g}\".format(split_prob_val))\n_debug_lines.append(\"seed: {}\".format(seed_val if seed_val is not None else \"<auto>\"))\n_debug_lines.append(\"stem_generations: {}\".format(stem_generations_val))\n_debug_lines.append(\"stem_angle: {}\".format(\n    \"<inherit>\" if stem_angle_val is None else \"{:.6g}\".format(stem_angle_val)\n))\n_debug_lines.append(\"length_jitter: {:.6g}\".format(length_jitter_val))\n_debug_lines.append(\"angle_jitter: {:.6g}\".format(angle_jitter_val))\n_debug_lines.append(\"length_decay: {:.6g}\".format(length_decay_val))\n_debug_lines.append(\"angle_scale: {:.6g}\".format(angle_scale_val))\n_debug_lines.append(\"avoid_radius: {:.6g}\".format(avoid_radius_val))\n_debug_lines.append(\"twist_rate: {:.6g}\".format(twist_rate_val))\n_debug_lines.append(\"terminate_probability: {:.6g}\".format(terminate_probability_val))\n_debug_lines.append(\"mean_branch_number: {}\".format(\n    \"<legacy>\" if mean_branch_number_val is None else \"{:.6g}\".format(mean_branch_number_val)\n))\n\ngrowth_debug_lines = []\n\nsegments_raw = grow_coral(\n    start=start_tuple,\n    iterations=iterations_val,\n    branch_length=branch_length_val,\n    branch_angle=branch_angle_val,\n    split_probability=split_prob_val,\n    seed=seed_val,\n    stem_generations=stem_generations_val,\n    stem_angle=stem_angle_val,\n    length_jitter=length_jitter_val,\n    angle_jitter=angle_jitter_val,\n    length_decay=length_decay_val,\n    angle_scale=angle_scale_val,\n    avoid_radius=avoid_radius_val,\n    twist_rate=twist_rate_val,\n    terminate_probability=terminate_probability_val,\n    mean_branch_number=mean_branch_number_val,\n    debug_log=growth_debug_lines,\n)\n\n# Convert output tuples back to Rhino geometry for Grasshopper display\n# Use LineCurve to ensure the output is a Curve type, which plugs into Crv params.\nlines = []\nfor seg in segments_raw:\n    start_pt = rg.Point3d(*seg[0])  # Tuple -> Point3d\n    end_pt = rg.Point3d(*seg[1])    # Tuple -> Point3d\n    lines.append(rg.LineCurve(start_pt, end_pt))\n\n# Identify terminal segments (their end point never reappears as another segment's start)\nstart_points = {seg[0] for seg in segments_raw}\nend_segments_list = []\nend_points_list = []\nseen_end_points = set()\n\nfor seg, curve in zip(segments_raw, lines):\n    endpoint = seg[1]\n    if endpoint not in start_points:\n        end_segments_list.append(curve)\n        if endpoint not in seen_end_points:\n            end_points_list.append(rg.Point3d(*endpoint))\n            seen_end_points.add(endpoint)\n\n# Backward/compat outputs:\n# - 'out' is the primary output (same as 'lines' and 'segments')\n# - 'segments' outputs curves as well (for users already wiring this output into a Curve param)\n# - 'segments_raw' exposes the tuple data for debugging/analysis\n_debug_lines.append(\"=== Coral growth results ===\")\n_debug_lines.append(\"segments generated: {}\".format(len(segments_raw)))\n_debug_lines.append(\"terminal segments: {}\".format(len(end_segments_list)))\n_debug_lines.append(\"terminal points: {}\".format(len(end_points_list)))\n\nif growth_debug_lines:\n    _debug_lines.append(\"=== Growth trace ===\")\n    _debug_lines.extend(growth_debug_lines)\n\nfor _line in _debug_lines:\n    print(_line)\n\nout = lines\nsegments = lines\nsegments_raw = segments_raw\nend_segments = end_segments_list\nend_points = end_points_list\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}