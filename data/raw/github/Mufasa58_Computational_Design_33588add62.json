{
  "source_url": "https://github.com/Mufasa58/Computational_Design/blob/9a751b01687073e7aa4b4314128501cb7ddb6225/Bismuth%20Logic.py",
  "repo": "Mufasa58/Computational_Design",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Bismuth Logic.py",
  "instruction": "Bismuth logic",
  "code": "import Rhino.Geometry as rg\r\nimport random\r\nimport math\r\n\r\nclass OrganicGrowthSystem:\r\n    def __init__(self, start_curve, params):\r\n        self.current_curve = start_curve.Duplicate()\r\n        self.iterations = int(params.get('iterations', 10))\r\n        self.z_dist = params.get('z_dist', 1.0)\r\n        self.prob = params.get('prob', 0.5)\r\n        self.shrink = params.get('shrink', 0.8)\r\n        self.size_proportion = params.get('size_proportion', 1.5)\r\n        \r\n        # FIXED LENGTH LOGIC\r\n        self.fixed_L1 = params.get('fixed_L1', 2.0)\r\n        self.fixed_L3 = params.get('fixed_L3', 1.0)\r\n        self.jitter = params.get('jitter', 0.1) \r\n        \r\n        # GRADUAL & CONSTRAINTS\r\n        self.base_offset = params.get('xy_off', 1.0)\r\n        self.taper_factor = params.get('taper_factor', 0.95)\r\n        self.decay_rate = params.get('decay_rate', 0.02)\r\n        \r\n        # MINIMUM SIZE LOGIC (Safety Stops)\r\n        self.initial_length = self.current_curve.GetLength()\r\n        self.min_length = self.initial_length * 0.35 \r\n        self.stop_threshold = 0.01 # Stop when total length is very close to zero\r\n        \r\n        self.current_trim = params.get('step_base', 0.1)\r\n        self.history = []\r\n        random.seed(params.get('seed', 1))\r\n\r\n    def _get_random_fixed(self, base_val, iter_idx):\r\n        decayed = base_val * (self.taper_factor ** iter_idx)\r\n        variation = decayed * self.jitter\r\n        return decayed + random.uniform(-variation, variation)\r\n\r\n    def _grow_three_relative(self, start_pt, start_dir, anterior_len, is_clockwise, iter_idx):\r\n        lines = []\r\n        curr_pos = start_pt\r\n        curr_dir = rg.Vector3d(start_dir)\r\n        if not curr_dir.Unitize(): return lines\r\n\r\n        l1 = self._get_random_fixed(self.fixed_L1, iter_idx)\r\n        l2 = anterior_len * self.shrink\r\n        l3 = self._get_random_fixed(self.fixed_L3, iter_idx)\r\n        \r\n        lengths = [max(0.001, l1), max(0.001, l2), max(0.001, l3)]\r\n        angle = -math.pi / 2 if is_clockwise else math.pi / 2\r\n\r\n        for i in range(3):\r\n            curr_dir.Rotate(angle, rg.Vector3d.ZAxis)\r\n            seg_len = lengths[i]\r\n            new_p = curr_pos + (curr_dir * seg_len)\r\n            lines.append(rg.LineCurve(curr_pos, new_p))\r\n            curr_pos = new_p\r\n            \r\n        return lines\r\n\r\n    def run(self):\r\n        for i in range(self.iterations):\r\n            self.current_curve.Domain = rg.Interval(0, 1)\r\n            total_len = self.current_curve.GetLength()\r\n\r\n            # 1. SAFETY STOP: Exit if curve is near zero\r\n            if total_len < self.stop_threshold:\r\n                break\r\n\r\n            potential_trim = self.current_trim + (total_len * self.decay_rate)\r\n            resulting_len = total_len - (2 * potential_trim)\r\n\r\n            if resulting_len > self.min_length:\r\n                self.current_trim = potential_trim\r\n            else:\r\n                self.current_trim = (total_len - self.min_length) / 2\r\n            \r\n            self.current_trim = max(0, self.current_trim)\r\n\r\n            # Avoid trimming the curve into non-existence\r\n            if (self.current_trim * 2) >= total_len:\r\n                break\r\n\r\n            t_start = self.current_trim / total_len\r\n            t_end = 1.0 - (self.current_trim / total_len)\r\n\r\n            shrunk_curve = self.current_curve.Trim(t_start, t_end)\r\n            if not shrunk_curve: break\r\n\r\n            # 2. BRANCHING\r\n            to_join = [shrunk_curve]\r\n            success, polyline = shrunk_curve.TryGetPolyline()\r\n            \r\n            if success and polyline.Count >= 2:\r\n                p0, p_last = polyline[0], polyline[polyline.Count - 1]\r\n                \r\n                branch_len_start = p0.DistanceTo(polyline[1]) / self.size_proportion\r\n                branch_len_end = p_last.DistanceTo(polyline[polyline.Count-2]) / self.size_proportion\r\n\r\n                if branch_len_start > self.stop_threshold and random.random() < self.prob:\r\n                    branches = self._grow_three_relative(p0, p0 - polyline[1], branch_len_start, True, i)\r\n                    for seg in branches: seg.Reverse()\r\n                    branches.reverse()\r\n                    to_join = branches + to_join\r\n\r\n                if branch_len_end > self.stop_threshold and random.random() < self.prob:\r\n                    branches = self._grow_three_relative(p_last, p_last - polyline[polyline.Count-2], branch_len_end, False, i)\r\n                    to_join.extend(branches)\r\n\r\n            # 3. JOIN AND DYNAMIC OFFSET\r\n            # FIX: Used rg.Curve.JoinCurves instead of rg.JoinCurves\r\n            joined = rg.Curve.JoinCurves(to_join, 0.01)\r\n            if not joined or len(joined) == 0: break\r\n            \r\n            temp_curve = joined[0]\r\n            current_offset = self.base_offset * (self.taper_factor ** i)\r\n            \r\n            # Stop if offset becomes too small to solve\r\n            if current_offset < 0.001: break\r\n\r\n            offset_result = temp_curve.Offset(rg.Plane.WorldXY, current_offset, 0.01, rg.CurveOffsetCornerStyle.Sharp)\r\n            \r\n            if offset_result:\r\n                self.current_curve = offset_result[0]\r\n            else:\r\n                break # Stop if offset fails\r\n\r\n            # 4. RECORD\r\n            self.current_curve.Transform(rg.Transform.Translation(0, 0, self.z_dist))\r\n            self.history.append(self.current_curve.DuplicateCurve())\r\n\r\n        return self.history\r\n\r\n# =========================================================\r\n# GH SCRIPT AREA\r\n# =========================================================\r\nparams = {\r\n    'iterations': N,\r\n    'step_base': Step,\r\n    'xy_off': XY_Off,\r\n    'z_dist': Z_Dist,\r\n    'seed': Seed,\r\n    'prob': prob,\r\n    'shrink': shrink,\r\n    'size_proportion': size_proportion,\r\n    'decay_rate': 0.01,\r\n    'taper_factor': 0.98,\r\n    'fixed_L1': 1,\r\n    'fixed_L3': 1,\r\n    'jitter': 0.05\r\n}\r\n\r\nsystem = OrganicGrowthSystem(C, params)\r\na = system.run()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}