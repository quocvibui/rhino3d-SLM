{
  "source_url": "https://github.com/KeithSloan/ladybug_freeCAD/blob/7b40cdc3178b4a1d533375b21132a82c2cc05fa2/ladybug_freeCAD/preview.py",
  "repo": "KeithSloan/ladybug_freeCAD",
  "repo_stars": 0,
  "repo_description": "Ladybug FreeCAD",
  "license": "AGPL-3.0",
  "filepath": "ladybug_freeCAD/preview.py",
  "instruction": "Classes to preview things in the Rhino Display Pipeline.",
  "code": "\"\"\"Classes to preview things in the Rhino Display Pipeline.\"\"\"\nfrom __future__ import division\n\nfrom ladybug_geometry.geometry2d import Vector2D, Point2D, Ray2D, LineSegment2D, \\\n    Polyline2D, Arc2D, Polygon2D, Mesh2D\nfrom ladybug_geometry.geometry3d import Vector3D, Point3D, Ray3D, Plane, LineSegment3D, \\\n    Polyline3D, Arc3D, Face3D, Mesh3D, Polyface3D, Sphere, Cone, Cylinder\n\nfrom ladybug.graphic import GraphicContainer\nfrom ladybug_display.altnumber import Default\nfrom ladybug_display.geometry3d import DisplayText3D\nfrom ladybug_display.visualization import AnalysisGeometry\n\nfrom .config import units_system, rhino_version\nfrom .color import color_to_color, argb_color_to_color, black\nfrom .fromgeometry import from_point2d, from_vector2d, from_ray2d, \\\n    from_arc2d, from_polygon2d, from_polyline2d, from_mesh2d, \\\n    from_point3d, from_vector3d, from_ray3d, from_plane, \\\n    from_arc3d, from_polyline3d, from_mesh3d, from_face3d, from_polyface3d, \\\n    from_sphere, from_cone, from_cylinder\n\ntry:\n    import System\nexcept ImportError as e:\n    raise ImportError(\"Failed to import Windows/.NET libraries\\n{}\".format(e))\n\ntry:\n    import Rhino.Geometry as rg\n    import Rhino.Display as rd\n    import Rhino.DocObjects as ro\nexcept ImportError as e:\n    raise ImportError('Failed to import Rhino.\\n{}'.format(e))\n\ntry:\n    import scriptcontext as sc\nexcept ImportError:\n    pass  # previewing 2D legends will not be available\n\n\nclass VisualizationSetConduit(rd.DisplayConduit):\n    \"\"\"Class to preview VisualizationSet in the Rhino Display pipeline.\n\n    Args:\n        visualization_set: A Ladybug Display VisualizationSet object to be translated\n            into arguments for the Rhino display pipeline.\n        render_3d_legend: A Boolean to note whether the VisualizationSet should be\n            rendered with 3D legends for any AnalysisGeometries it\n            includes. (Default: False).\n        render_2d_legend: A Boolean to note whether the VisualizationSet should be\n            rendered with 2D screen-oriented legends for any AnalysisGeometries it\n            includes. (Default: False).\n    \"\"\"\n\n    def __init__(self, visualization_set, render_3d_legend=False, render_2d_legend=False):\n        \"\"\"Initialize VisualizationSetConduit.\"\"\"\n        # set the primary properties\n        self.vis_con = VisualizationSetConverter(\n            visualization_set, render_3d_legend, render_2d_legend)\n\n    def CalculateBoundingBox(self, calculateBoundingBoxEventArgs):\n        \"\"\"Overwrite the method that passes the bounding box to the display.\"\"\"\n        calculateBoundingBoxEventArgs.IncludeBoundingBox(self.vis_con.bbox)\n\n    def DrawForeground(self, drawEventArgs):\n        \"\"\"Overwrite the method that draws the objects in the display.\"\"\"\n        # get the DisplayPipeline from the event arguments\n        display = drawEventArgs.Display\n\n        # for each object to be rendered, pass the drawing arguments\n        for draw_args in self.vis_con.draw_2d_text:\n            display.Draw2dText(*draw_args)\n        for draw_args in self.vis_con.draw_sprite:\n            display.DrawSprite(*draw_args)\n\n    def PreDrawObjects(self, drawEventArgs):\n        \"\"\"Overwrite the method that draws the objects in the display.\"\"\"\n        # get the DisplayPipeline from the event arguments\n        display = drawEventArgs.Display\n\n        # for each object to be rendered, pass the drawing arguments\n        for draw_args in self.vis_con.draw_mesh_false_colors:\n            display.DrawMeshFalseColors(draw_args)\n        for draw_args in self.vis_con.draw_mesh_shaded:\n            display.DrawMeshFalseColors(draw_args[0])\n        for draw_args in self.vis_con.draw_brep_shaded:\n            display.DrawBrepShaded(*draw_args)\n\n    def PostDrawObjects(self, drawEventArgs):\n        \"\"\"Overwrite the method that draws the objects in the display.\"\"\"\n        # get the DisplayPipeline from the event arguments\n        display = drawEventArgs.Display\n\n        # for each object to be rendered, pass the drawing arguments\n        for draw_args in self.vis_con.draw_3d_text:\n            display.Draw3dText(*draw_args)\n        for draw_args in self.vis_con.draw_mesh_wires:\n            display.DrawMeshWires(*draw_args)\n        for draw_args in self.vis_con.draw_mesh_vertices:\n            display.DrawMeshVertices(*draw_args)\n        for draw_args in self.vis_con.draw_point:\n            display.DrawPoint(*draw_args)\n        for draw_args in self.vis_con.draw_arrow:\n            display.DrawArrow(*draw_args)\n        for draw_args in self.vis_con.draw_brep_wires:\n            display.DrawBrepWires(*draw_args)\n        for draw_args in self.vis_con.draw_line:\n            display.DrawLine(*draw_args)\n        for draw_args in self.vis_con.draw_patterned_line:\n            display.DrawPatternedLine(*draw_args)\n        for draw_args in self.vis_con.draw_patterned_polyline:\n            display.DrawPatternedPolyline(*draw_args)\n        for draw_args in self.vis_con.draw_curve:\n            display.DrawCurve(*draw_args)\n        for draw_args in self.vis_con.draw_circle:\n            display.DrawCircle(*draw_args)\n        for draw_args in self.vis_con.draw_arc:\n            display.DrawArc(*draw_args)\n        for draw_args in self.vis_con.draw_sphere:\n            display.DrawSphere(*draw_args)\n        for draw_args in self.vis_con.draw_cone:\n            display.DrawCone(*draw_args)\n        for draw_args in self.vis_con.draw_cylinder:\n            display.DrawCylinder(*draw_args)\n\n\nclass VisualizationSetConverter(object):\n    \"\"\"Class to translate VisualizationSets to arguments for the Rhino display pipeline.\n\n    Args:\n        visualization_set: A Ladybug Display VisualizationSet object to be translated\n            into arguments for the Rhino display pipeline.\n        render_3d_legend: A Boolean to note whether the VisualizationSet should be\n            rendered with 3D legends for any AnalysisGeometries it\n            includes. (Default: False).\n        render_2d_legend: A Boolean to note whether the VisualizationSet should be\n            rendered with 2D screen-oriented legends for any AnalysisGeometries it\n            includes. (Default: False).\n\n    Properties:\n        * vis_set\n        * render_3d_legend\n        * render_2d_legend\n        * min_pt\n        * max_pt\n        * bbox\n        * draw_sprite\n        * draw_2d_text\n        * draw_3d_text\n        * draw_mesh_false_colors\n        * draw_mesh_shaded\n        * draw_mesh_wires\n        * draw_mesh_vertices\n        * draw_brep_shaded\n        * draw_brep_wires\n        * draw_point\n        * draw_arrow\n        * draw_line\n        * draw_patterned_line\n        * draw_patterned_polyline\n        * draw_curve\n        * draw_circle\n        * draw_arc\n        * draw_sphere\n        * draw_cone\n        * draw_cylinder\n    \"\"\"\n    TEXT_HORIZ = {\n        'Left': ro.TextHorizontalAlignment.Left,\n        'Center': ro.TextHorizontalAlignment.Center,\n        'Right': ro.TextHorizontalAlignment.Right\n    }\n    TEXT_VERT = {\n        'Top': ro.TextVerticalAlignment.Top,\n        'Middle': ro.TextVerticalAlignment.Middle,\n        'Bottom': ro.TextVerticalAlignment.Bottom\n    }\n    LINE_TYPE = {\n        'Dashed': int('0x1C7', base=16),\n        'Dotted': int('0x00001111', base=16),\n        'DashDot': int('0x1F11F1', base=16)\n    }\n\n    def __init__(\n            self, visualization_set, render_3d_legend=False, render_2d_legend=False):\n        \"\"\"Initialize VisualizationSetConverter.\"\"\"\n        # set the primary properties\n        self.vis_set = visualization_set\n        self.render_3d_legend = bool(render_3d_legend)\n        self.render_2d_legend = bool(render_2d_legend)\n\n        # get the active viewport width and height if 2D legends are requested\n        if self.render_2d_legend:\n            active_view = sc.doc.Views.ActiveView.ActiveViewport\n            v_size = active_view.Size\n            self.view_width = v_size.Width\n            self.view_height = v_size.Height\n        else:  # just use some defaults as it's probably not critical\n            self.view_width, self.view_height = 800, 600\n\n        # ensure the visualization set is in Rhino model units\n        units_sys = units_system()\n        if self.vis_set.units is not None and units_sys is not None \\\n                and self.vis_set.units != units_sys:\n            self.vis_set.convert_to_units(units_sys)\n\n        # set up the bounding box and min/max point\n        self.min_pt = self.vis_set.min_point\n        self.max_pt = self.vis_set.max_point\n        if self.render_3d_legend:  # leave extra room for legend\n            center = Point3D(\n                (self.min_pt.x + self.max_pt.x) / 2,\n                (self.min_pt.y + self.max_pt.y) / 2,\n                (self.min_pt.z + self.max_pt.z) / 2)\n            self.bbox = rg.BoundingBox(\n                from_point3d(self.min_pt.scale(2, center)),\n                from_point3d(self.max_pt.scale(2, center)))\n        else:\n            self.bbox = rg.BoundingBox(\n                from_point3d(self.min_pt), from_point3d(self.max_pt))\n\n        # translate all of the rhino objects to be rendered in the scene\n        self.translate_objects()\n        self.sort_shaded_objects()\n\n    def translate_objects(self):\n        \"\"\"Translate all of the objects in the VisualizationSet into a Rhino equivalent.\n\n        This is a necessary pre-step before frames of the visualization set\n        can be rendered in the display pipeline.\n        \"\"\"\n        # initialize all of the lists to hold the drawing arguments\n        self.draw_sprite = []\n        self.draw_2d_text = []\n        self.draw_3d_text = []\n        self.draw_mesh_false_colors = []\n        self.draw_mesh_shaded = []\n        self.draw_mesh_wires = []\n        self.draw_mesh_vertices = []\n        self.draw_brep_shaded = []\n        self.draw_brep_wires = []\n        self.draw_point = []\n        self.draw_arrow = []\n        self.draw_line = []\n        self.draw_patterned_line = []\n        self.draw_patterned_polyline = []\n        self.draw_curve = []\n        self.draw_circle = []\n        self.draw_arc = []\n        self.draw_sphere = []\n        self.draw_cone = []\n        self.draw_cylinder = []\n\n        # loop through visualization geometry objects and draw them\n        default_leg_x3d, default_leg_x2d, default_leg_y2d = 0, 10, 50\n        for geo in self.vis_set.geometry:\n            if geo.hidden:\n                continue\n            # translate it as AnalysisGeometry if specified\n            if isinstance(geo, AnalysisGeometry):\n                # generate the colors that correspond to the values\n                data = geo.data_sets[geo.active_data]\n                graphic = GraphicContainer(\n                    data.values, self.min_pt, self.max_pt,\n                    data.legend_parameters, data.data_type, data.unit)\n                colors = graphic.value_colors\n                # translate the analysis geometry using the matching method\n                if geo.matching_method == 'faces':\n                    c_count = 0\n                    for mesh in geo.geometry:\n                        mesh.colors = colors[c_count:c_count + len(mesh.faces)]\n                        c_count += len(mesh.faces)\n                        self.translate_analysis_mesh(mesh, geo.display_mode)\n                elif geo.matching_method == 'vertices':\n                    c_count = 0\n                    for mesh in geo.geometry:\n                        mesh.colors = colors[c_count:c_count + len(mesh.vertices)]\n                        c_count += len(mesh.vertices)\n                        self.translate_analysis_mesh(mesh, geo.display_mode)\n                else:  # one color per geometry object\n                    for geo_obj, col in zip(geo.geometry, colors):\n                        self.translate_analysis_geometry(\n                            geo_obj, col, geo.display_mode)\n                # if the object is set to translate 3D legends, then display it\n                if self.render_3d_legend:\n                    # ensure multiple legends are not on top of each other\n                    if graphic.legend_parameters.is_base_plane_default:\n                        l_par = graphic.legend_parameters\n                        m_vec = Vector3D(default_leg_x3d, 0, 0)\n                        l_par.base_plane = l_par.base_plane.move(m_vec)\n                        l_par.properties_3d._is_base_plane_default = True\n                        leg_width = l_par.segment_width + 6 * l_par.text_height \\\n                            if l_par.vertical else \\\n                            l_par.segment_width * (l_par.segment_count + 2)\n                        default_leg_x3d += leg_width\n                    self.translate_legend3d(graphic.legend)\n                # if the object is set to translate 2D legends, then display it\n                if self.render_2d_legend:\n                    # ensure multiple legends are not on top of each other\n                    l_par = graphic.legend_parameters\n                    if l_par.vertical and l_par.is_origin_x_default:\n                        l_par.origin_x = '{}px'.format(default_leg_x2d)\n                        l_par.properties_2d._is_origin_x_default = True\n                        sw = graphic.legend.parse_dim_2d(\n                            l_par.segment_width_2d, self.view_width)\n                        th = graphic.legend.parse_dim_2d(\n                            l_par.text_height_2d, self.view_height)\n                        leg_width = sw + 6 * th\n                        default_leg_x2d += leg_width\n                    elif not l_par.vertical and l_par.is_origin_y_default:\n                        l_par.origin_y = '{}px'.format(default_leg_y2d)\n                        l_par.properties_2d._is_origin_y_default = True\n                        sh = graphic.legend.parse_dim_2d(\n                            l_par.segment_height_2d, self.view_height)\n                        th = graphic.legend.parse_dim_2d(\n                            l_par.text_height_2d, self.view_height)\n                        leg_height = sh + 4 * th\n                        default_leg_y2d += leg_height\n                    self.translate_legend2d(graphic.legend)\n            else:  # it's a ContextGeometry object\n                for display_obj in geo.geometry:\n                    if isinstance(display_obj, DisplayText3D):\n                        self.translate_display_text3d(display_obj)\n                    else:\n                        self.translate_context_geometry(display_obj)\n\n    def translate_display_text3d(self, text_obj):\n        \"\"\"Translate ladybug DisplayText3D into arguments for drawing in the scene.\n\n        Args:\n            text_obj: The ladybug DisplayText3D to be translated.\n        \"\"\"\n        self.draw_3d_text.append((\n            text_obj.text, color_to_color(text_obj.color), from_plane(text_obj.plane),\n            text_obj.height, text_obj.font, False, False,\n            self.TEXT_HORIZ[text_obj.horizontal_alignment],\n            self.TEXT_VERT[text_obj.vertical_alignment]))\n\n    def translate_legend3d(self, legend):\n        \"\"\"Translate a ladybug Legend into arguments for drawing in the scene.\n\n        Args:\n            legend: A Ladybug Legend object to be converted to Rhino geometry.\n        \"\"\"\n        # translate the legend mesh\n        rh_mesh = from_mesh3d(legend.segment_mesh)\n        self.draw_mesh_false_colors.append(rh_mesh)\n        self.draw_mesh_wires.append((rh_mesh, black()))\n\n        # translate the legend text\n        _height = legend.legend_parameters.text_height\n        _font = legend.legend_parameters.font\n        if legend.legend_parameters.continuous_legend is False:\n            legend_text = [\n                DisplayText3D(txt, loc, _height, None, _font, 'Left', 'Bottom')\n                for txt, loc in zip(legend.segment_text, legend.segment_text_location)]\n        elif legend.legend_parameters.vertical is True:\n            legend_text = [\n                DisplayText3D(txt, loc, _height, None, _font, 'Left', 'Middle')\n                for txt, loc in zip(legend.segment_text, legend.segment_text_location)]\n        else:\n            legend_text = [\n                DisplayText3D(txt, loc, _height, None, _font, 'Center', 'Bottom')\n                for txt, loc in zip(legend.segment_text, legend.segment_text_location)]\n        legend_title = DisplayText3D(\n            legend.title, legend.title_location, _height, None, _font)\n        legend_text.insert(0, legend_title)\n        for txt_obj in legend_text:\n            self.translate_display_text3d(txt_obj)\n\n    def translate_legend2d(self, legend):\n        \"\"\"Translate a ladybug Legend into arguments for drawing in the scene.\n\n        Args:\n            legend: A Ladybug Legend object to be converted to 2D\n                screen-oriented geometry.\n        \"\"\"\n        d_sprite, d_2d_text = self.convert_legend2d(\n            legend, self.view_width, self.view_height)\n        self.draw_sprite.append(d_sprite)\n        self.draw_2d_text.extend(d_2d_text)\n\n    def translate_analysis_mesh(self, mesh, display_mode):\n        \"\"\"Translate an analysis mesh into arguments for drawing in the scene.\n\n        Args:\n            mesh: The Ladybug Mesh3D or Mesh2D object to be translated.\n            display_mode: Text for the display mode in which to translate the mesh.\n        \"\"\"\n        if display_mode in ('Surface', 'SurfaceWithEdges'):\n            rh_mesh = from_mesh3d(mesh) if isinstance(mesh, Mesh3D) \\\n                else from_mesh2d(mesh)\n            self.draw_mesh_false_colors.append(rh_mesh)\n            if display_mode == 'SurfaceWithEdges':\n                self.draw_mesh_wires.append((rh_mesh, black()))\n        elif display_mode == 'Wireframe':\n            rh_mesh = from_mesh3d(mesh) if isinstance(mesh, Mesh3D) \\\n                else from_mesh2d(mesh)\n            self.draw_mesh_wires.append((rh_mesh, black()))\n        elif display_mode == 'Points':\n            if isinstance(mesh, Mesh3D):\n                points = [from_point3d(pt) for pt in mesh.face_centroids] \\\n                    if mesh.is_color_by_face else \\\n                    [from_point3d(pt) for pt in mesh.vertices]\n            else:\n                points = [from_point2d(pt) for pt in mesh.face_centroids] \\\n                    if mesh.is_color_by_face else \\\n                    [from_point2d(pt) for pt in mesh.vertices]\n            colors = [color_to_color(col) for col in mesh.colors]\n            for col, pt in zip(colors, points):\n                self.draw_point.append((pt, rd.PointStyle.RoundSimple, 3, col))\n\n    def translate_analysis_geometry(self, geo_obj, color, display_mode):\n        \"\"\"Translate analysis geometry objects into arguments for drawing in the scene.\n\n        Args:\n            geo_obj: The Ladybug Geometry object to be translated.\n            color: The Ladybug Color object with which the object will be translated.\n            display_mode: Text for the display mode in which to translate the mesh.\n        \"\"\"\n        # translate the color\n        col = color_to_color(color)\n\n        if isinstance(geo_obj, (Point3D, Point2D)):\n            # translate analysis point\n            pt = from_point3d(geo_obj) if isinstance(geo_obj, Point3D) \\\n                else from_point2d(geo_obj)\n            self.draw_point.append((pt, rd.PointStyle.RoundSimple, 5, col))\n\n        elif isinstance(geo_obj, (LineSegment3D, LineSegment2D)):\n            # translate analysis line segment\n            if isinstance(geo_obj, LineSegment3D):\n                pt1, pt2 = from_point3d(geo_obj.p1), from_point3d(geo_obj.p2)\n            else:\n                pt1, pt2 = from_point2d(geo_obj.p1), from_point2d(geo_obj.p2)\n            self.draw_line.append((pt1, pt2, col, 3))\n\n        elif isinstance(geo_obj, (Polyline3D, Polyline2D)):\n            # translate analysis polyline\n            crv = from_polyline3d(geo_obj) if isinstance(geo_obj, Polyline3D) \\\n                else from_polyline2d(geo_obj)\n            self.draw_curve.append((crv, col, 3))\n\n        elif isinstance(geo_obj, (Face3D, Polyface3D)):\n            # translate analysis Face3D and Polyface3D\n            if display_mode in ('Surface', 'SurfaceWithEdges'):\n                mat = rd.DisplayMaterial(col)\n                rh_obj = from_face3d(geo_obj) if isinstance(geo_obj, Face3D) \\\n                    else from_polyface3d(geo_obj)\n                self.draw_brep_shaded.append((rh_obj, mat))\n                if display_mode == 'SurfaceWithEdges':\n                    self.draw_brep_wires.append((rh_obj, black(), -1))\n            elif display_mode == 'Wireframe':\n                rh_obj = from_face3d(geo_obj) if isinstance(geo_obj, Face3D) \\\n                    else from_polyface3d(geo_obj)\n                self.draw_brep_wires.append((rh_obj, col, 1))\n            elif display_mode == 'Points':\n                for pt in geo_obj.vertices:\n                    self.draw_point.append(\n                        (from_point3d(pt), rd.PointStyle.RoundSimple, 3, col))\n\n        elif isinstance(geo_obj, (Mesh3D, Mesh2D)):\n            # translate analysis mesh\n            rh_obj = from_mesh3d(geo_obj) if isinstance(geo_obj, Mesh3D) \\\n                else from_mesh2d(geo_obj)\n            if display_mode in ('Surface', 'SurfaceWithEdges'):\n                mat = rd.DisplayMaterial(col)\n                rh_obj.VertexColors.CreateMonotoneMesh(col)\n                self.draw_mesh_shaded.append((rh_obj, mat))\n                if display_mode == 'SurfaceWithEdges':\n                    self.draw_mesh_wires.append((rh_obj, black(), 1))\n            elif display_mode == 'Wireframe':\n                self.draw_mesh_wires.append((rh_obj, col, 3))\n            elif display_mode == 'Points':\n                self.draw_mesh_vertices.append((rh_obj, col))\n\n        elif isinstance(geo_obj, (Ray2D, Ray3D)):\n            # translate analysis rays\n            rh_ray = from_ray3d(geo_obj) if isinstance(geo_obj, Ray3D) \\\n                else from_ray2d(geo_obj)\n            rh_obj = rg.Line(rh_ray.Position, rh_ray.Direction)\n            self.draw_arrow.append((rh_obj, col))\n\n        elif isinstance(geo_obj, Sphere):\n            # translate analysis sphere\n            if display_mode in ('Surface', 'SurfaceWithEdges'):\n                rh_obj, mat = from_sphere(geo_obj), rd.DisplayMaterial(col)\n                self.draw_brep_shaded.append((rh_obj.ToBrep(), mat))\n                if display_mode == 'SurfaceWithEdges':\n                    self.draw_sphere.append((rh_obj, black()))\n            elif display_mode == 'Wireframe':\n                self.draw_sphere.append((from_sphere(geo_obj), col))\n            elif display_mode == 'Points':\n                pt_arg = (from_point3d(geo_obj.center),\n                          rd.PointStyle.RoundSimple, 3, col)\n                self.draw_point.append(pt_arg)\n\n        elif isinstance(geo_obj, (Vector2D, Vector3D)):\n            # translate analysis vectors\n            rh_vec = from_vector3d(geo_obj) if isinstance(geo_obj, Vector3D) \\\n                else from_vector2d(geo_obj)\n            rh_obj = rg.Line(rg.Point3d(0, 0, 0), rh_vec)\n            self.draw_arrow.append((rh_obj, col))\n\n        elif isinstance(geo_obj, Polygon2D):\n            # translate analysis polygon\n            self.draw_curve.append((from_polygon2d(geo_obj), col, 3))\n\n        elif isinstance(geo_obj, (Arc3D, Arc2D)):\n            # translate analysis arcs\n            crv = from_arc3d(geo_obj) if isinstance(geo_obj, Arc3D) \\\n                else from_arc2d(geo_obj)\n            if geo_obj.is_circle:\n                self.draw_circle.append((crv, col, 3))\n            else:\n                self.draw_arc.append((crv, col, 3))\n\n        elif isinstance(geo_obj, Cone):\n            # translate analysis cone\n            if display_mode in ('Surface', 'SurfaceWithEdges'):\n                rh_obj, mat = from_cone(geo_obj), rd.DisplayMaterial(col)\n                self.draw_brep_shaded.append((rh_obj.ToBrep(True), mat))\n                if display_mode == 'SurfaceWithEdges':\n                    self.draw_cone.append((rh_obj, black()))\n            elif display_mode == 'Wireframe':\n                self.draw_cone.append((from_cone(geo_obj), col))\n            elif display_mode == 'Points':\n                pt_arg = (from_point3d(geo_obj.vertex),\n                          rd.PointStyle.RoundSimple, 3, col)\n                self.draw_point.append(pt_arg)\n\n        elif isinstance(geo_obj, Cylinder):\n            # translate analysis cylinder\n            if display_mode in ('Surface', 'SurfaceWithEdges'):\n                rh_obj, mat = from_cylinder(geo_obj), rd.DisplayMaterial(col)\n                self.draw_brep_shaded.append((rh_obj.ToBrep(True, True), mat))\n                if display_mode == 'SurfaceWithEdges':\n                    self.draw_cylinder.append((rh_obj, black()))\n            elif display_mode == 'Wireframe':\n                self.draw_cylinder.append((from_cylinder(geo_obj), col))\n            elif display_mode == 'Points':\n                pt_arg = (from_point3d(geo_obj.center),\n                          rd.PointStyle.RoundSimple, 3, col)\n                self.draw_point.append(pt_arg)\n\n        elif isinstance(geo_obj, Plane):\n            # translate analysis planes\n            pln = from_plane(geo_obj)\n            r = 10  # default radius for a plane object in rhino model units\n            # grid lines\n            for j in range(-5, 6):\n                i = j / 5\n                p0 = pln.PointAt(i * r, -r)\n                p1 = pln.PointAt(i * r, r)\n                self.draw_line.append((p0, p1, col, 1))\n                p0 = pln.PointAt(-r, i * r)\n                p1 = pln.PointAt(r, i * r)\n                self.draw_line.append((p0, p1, col, 1))\n            # axes\n            self.draw_line.append((pln.Origin, pln.Origin + pln.XAxis * r, col, 3))\n            self.draw_line.append((pln.Origin, pln.Origin + pln.YAxis * r, col, 3))\n\n    def translate_context_geometry(self, dis_obj):\n        \"\"\"Translate a display geometry object into arguments for drawing in the scene.\n\n        Args:\n            dis_obj: The Ladybug Display geometry object to be translated.\n        \"\"\"\n        # first translate the color and get the geometry object\n        col = color_to_color(dis_obj.color)\n        geo_obj = dis_obj.geometry\n\n        if isinstance(geo_obj, (Point3D, Point2D)):\n            # translate display point\n            pt = from_point3d(geo_obj) if isinstance(geo_obj, Point3D) \\\n                else from_point2d(geo_obj)\n            radius = 3 if isinstance(dis_obj.radius, Default) else int(dis_obj.radius)\n            self.draw_point.append((pt, rd.PointStyle.RoundSimple, radius, col))\n\n        elif isinstance(geo_obj, (LineSegment3D, LineSegment2D)):\n            # translate display line segment\n            if isinstance(geo_obj, LineSegment3D):\n                pt1, pt2 = from_point3d(geo_obj.p1), from_point3d(geo_obj.p2)\n            else:\n                pt1, pt2 = from_point2d(geo_obj.p1), from_point2d(geo_obj.p2)\n            lw = 1 if isinstance(dis_obj.line_width, Default) \\\n                else int(dis_obj.line_width)\n            if dis_obj.line_type == 'Continuous':\n                self.draw_line.append((pt1, pt2, col, lw))\n            else:\n                self.draw_patterned_line.append(\n                    (pt1, pt2, col, self.LINE_TYPE[dis_obj.line_type], lw))\n\n        elif isinstance(geo_obj, (Polyline3D, Polyline2D)):\n            # translate display polyline\n            lw = 1 if isinstance(dis_obj.line_width, Default) \\\n                else int(dis_obj.line_width)\n            if dis_obj.line_type == 'Continuous':\n                crv = from_polyline3d(geo_obj) if isinstance(geo_obj, Polyline3D) \\\n                    else from_polyline2d(geo_obj)\n                self.draw_curve.append((crv, col, lw))\n            else:  # ensure the line pattern is respected\n                verts = [from_point3d(pt) for pt in geo_obj.vertices] \\\n                    if isinstance(geo_obj, Polyline3D) else \\\n                    [from_point2d(pt) for pt in geo_obj.vertices]\n                self.draw_patterned_polyline.append(\n                    (verts, col, self.LINE_TYPE[dis_obj.line_type], lw, False))\n\n        elif isinstance(geo_obj, (Ray2D, Ray3D)):\n            # translate display rays\n            rh_ray = from_ray3d(geo_obj) if isinstance(geo_obj, Ray3D) \\\n                else from_ray2d(geo_obj)\n            rh_obj = rg.Line(rh_ray.Position, rh_ray.Direction)\n            self.draw_arrow.append((rh_obj, col))\n\n        elif isinstance(geo_obj, (Face3D, Polyface3D)):\n            # translate display Face3D and Polyface3D\n            if dis_obj.display_mode in ('Surface', 'SurfaceWithEdges'):\n                mat = rd.DisplayMaterial(col, 1 - (dis_obj.color.a / 255))\n                rh_obj = from_face3d(geo_obj) if isinstance(geo_obj, Face3D) \\\n                    else from_polyface3d(geo_obj)\n                self.draw_brep_shaded.append((rh_obj, mat))\n                if dis_obj.display_mode == 'SurfaceWithEdges':\n                    self.draw_brep_wires.append((rh_obj, black(), -1))\n            elif dis_obj.display_mode == 'Wireframe':\n                rh_obj = from_face3d(geo_obj) if isinstance(geo_obj, Face3D) \\\n                    else from_polyface3d(geo_obj)\n                self.draw_brep_wires.append((rh_obj, col, 1))\n            elif dis_obj.display_mode == 'Points':\n                for pt in geo_obj.vertices:\n                    self.draw_point.append(\n                        (from_point3d(pt), rd.PointStyle.RoundSimple, 3, col))\n\n        elif isinstance(geo_obj, (Mesh3D, Mesh2D)):\n            # translate display mesh\n            rh_obj = from_mesh3d(geo_obj) if isinstance(geo_obj, Mesh3D) \\\n                else from_mesh2d(geo_obj)\n            if dis_obj.display_mode in ('Surface', 'SurfaceWithEdges'):\n                mat = rd.DisplayMaterial(col, 1 - (dis_obj.color.a / 255))\n                t_color = argb_color_to_color(dis_obj.color)\n                rh_obj.VertexColors.CreateMonotoneMesh(t_color)\n                self.draw_mesh_shaded.append((rh_obj, mat))\n                if dis_obj.display_mode == 'SurfaceWithEdges':\n                    self.draw_mesh_wires.append((rh_obj, black(), 1))\n            elif dis_obj.display_mode == 'Wireframe':\n                self.draw_mesh_wires.append((rh_obj, col, 1))\n            elif dis_obj.display_mode == 'Points':\n                self.draw_mesh_vertices.append((rh_obj, col))\n\n        elif isinstance(geo_obj, Sphere):\n            # translate analysis sphere\n            if dis_obj.display_mode in ('Surface', 'SurfaceWithEdges'):\n                rh_obj = from_sphere(geo_obj)\n                mat = rd.DisplayMaterial(col, 1 - (dis_obj.color.a / 255))\n                self.draw_brep_shaded.append((rh_obj.ToBrep(), mat))\n                if dis_obj.display_mode == 'SurfaceWithEdges':\n                    self.draw_sphere.append((rh_obj, black()))\n            elif dis_obj.display_mode == 'Wireframe':\n                self.draw_sphere.append((from_sphere(geo_obj), col))\n            elif dis_obj.display_mode == 'Points':\n                pt_arg = (from_point3d(geo_obj.center),\n                          rd.PointStyle.RoundSimple, 3, col)\n                self.draw_point.append(pt_arg)\n\n        elif isinstance(geo_obj, Polygon2D):\n            # translate display polygon\n            lw = 1 if isinstance(dis_obj.line_width, Default) \\\n                else int(dis_obj.line_width)\n            if dis_obj.line_type == 'Continuous':\n                self.draw_curve.append((from_polygon2d(geo_obj), col, lw))\n            else:  # ensure the line pattern is respected\n                verts = [from_point2d(pt) for pt in geo_obj.vertices]\n                self.draw_patterned_polyline.append(\n                    (verts, col, self.LINE_TYPE[dis_obj.line_type], lw, True))\n\n        elif isinstance(geo_obj, (Arc3D, Arc2D)):\n            # translate display arc\n            lw = 1 if isinstance(dis_obj.line_width, Default) \\\n                else int(dis_obj.line_width)\n            if dis_obj.line_type == 'Continuous':\n                crv = from_arc3d(geo_obj) if isinstance(geo_obj, Arc3D) else \\\n                    from_arc2d(geo_obj)\n                if geo_obj.is_circle:\n                    self.draw_circle.append((crv, col, lw))\n                else:\n                    self.draw_arc.append((crv, col, lw))\n            else:  # ensure the line pattern is respected\n                p_line = geo_obj.to_polyline(\n                    int(abs(geo_obj.a2 - geo_obj.a1) / 0.0523599))\n                if geo_obj.is_circle:\n                    arc_verts, closed = p_line.vertices[:-1], True\n                else:\n                    arc_verts, closed = p_line.vertices, False\n                verts = [from_point3d(pt) for pt in arc_verts] \\\n                    if isinstance(p_line, Polyline3D) else \\\n                    [from_point2d(pt) for pt in arc_verts]\n                self.draw_patterned_polyline.append(\n                    (verts, col, self.LINE_TYPE[dis_obj.line_type], lw, closed))\n\n        elif isinstance(geo_obj, Cone):\n            # translate analysis cone\n            if dis_obj.display_mode in ('Surface', 'SurfaceWithEdges'):\n                rh_obj = from_cone(geo_obj)\n                mat = rd.DisplayMaterial(col, 1 - (dis_obj.color.a / 255))\n                self.draw_brep_shaded.append((rh_obj.ToBrep(True), mat))\n                if dis_obj.display_mode == 'SurfaceWithEdges':\n                    self.draw_cone.append((rh_obj, black()))\n            elif dis_obj.display_mode == 'Wireframe':\n                self.draw_cone.append((from_cone(geo_obj), col))\n            elif dis_obj.display_mode == 'Points':\n                pt_arg = (from_point3d(geo_obj.vertex),\n                          rd.PointStyle.RoundSimple, 3, col)\n                self.draw_point.append(pt_arg)\n\n        elif isinstance(geo_obj, Cylinder):\n            # translate analysis cylinder\n            if dis_obj.display_mode in ('Surface', 'SurfaceWithEdges'):\n                rh_obj = from_cylinder(geo_obj)\n                mat = rd.DisplayMaterial(col, 1 - (dis_obj.color.a / 255))\n                self.draw_brep_shaded.append((rh_obj.ToBrep(True, True), mat))\n                if dis_obj.display_mode == 'SurfaceWithEdges':\n                    self.draw_cylinder.append((rh_obj, black()))\n            elif dis_obj.display_mode == 'Wireframe':\n                self.draw_cylinder.append((from_cylinder(geo_obj), col))\n            elif dis_obj.display_mode == 'Points':\n                pt_arg = (from_point3d(geo_obj.center),\n                          rd.PointStyle.RoundSimple, 3, col)\n                self.draw_point.append(pt_arg)\n\n        elif isinstance(geo_obj, Plane):\n            # translate analysis planes\n            pln = from_plane(geo_obj)\n            r = 10  # default radius for a plane object in rhino model units\n            # grid lines\n            if dis_obj.show_grid:\n                for j in range(-5, 6):\n                    i = j / 5\n                    p0 = pln.PointAt(i * r, -r)\n                    p1 = pln.PointAt(i * r, r)\n                    self.draw_line.append((p0, p1, col, 1))\n                    p0 = pln.PointAt(-r, i * r)\n                    p1 = pln.PointAt(r, i * r)\n                    self.draw_line.append((p0, p1, col, 1))\n            # axes\n            if dis_obj.show_axes:\n                self.draw_line.append((pln.Origin, pln.Origin + pln.XAxis * r, col, 3))\n                self.draw_line.append((pln.Origin, pln.Origin + pln.YAxis * r, col, 3))\n\n    def sort_shaded_objects(self):\n        \"\"\"Sort shaded objects according to their transparency.\n\n        This ensures that the resulting display has visible objects behind\n        any transparent objects.\n        \"\"\"\n        if len(self.draw_brep_shaded) != 0:\n            trans = (args[1].Transparency for args in self.draw_brep_shaded)\n            self.draw_brep_shaded = \\\n                [a for _, a in sorted(zip(trans, self.draw_brep_shaded))]\n        if len(self.draw_mesh_shaded) != 0:\n            trans = (args[1].Transparency for args in self.draw_mesh_shaded)\n            self.draw_mesh_shaded = \\\n                [a for _, a in sorted(zip(trans, self.draw_mesh_shaded))]\n\n    @staticmethod\n    def convert_legend2d(legend, vw=None, vh=None):\n        \"\"\"Convert a ladybug Legend into arguments for drawing in 2D on the screen.\n\n        Args:\n            legend: A Ladybug Legend object to be converted to 2D screen-oriented\n                geometry.\n            vw: An integer for the view width in pixels. If None, it will\n                be obtained from the active viewport. (Default: None).\n            vh: An integer for the view height in pixels. If None, it will\n                be obtained from the active viewport. (Default: None).\n\n        Returns:\n            A tuple with two values needed to render the legend in the 2D scene:\n\n            -   legend_mesh -- A colored mesh for the legend.\n\n            -   legend_title -- A text object for the legend title.\n        \"\"\"\n        # figure out the dimensions of the active viewport\n        if vw is None or vh is None:\n            active_view = sc.doc.Views.ActiveView.ActiveViewport\n            v_size = active_view.Size\n            vw = v_size.Width if vw is None else vw\n            vh = v_size.Height if vh is None else vh\n\n        # translate the color matrix to a bitmap\n        l_par = legend.legend_parameters\n        color_mtx = legend.color_map_2d(vw, vh)\n        color_mtx = [[color_to_color(c) for c in row] for row in color_mtx]\n        if (8, 14) <= rhino_version < (8, 15, 25007):\n            color_mtx = list(reversed(color_mtx))\n        net_bm = System.Drawing.Bitmap(len(color_mtx[0]), len(color_mtx))\n        for y, row in enumerate(color_mtx):\n            for x, col in enumerate(row):\n                net_bm.SetPixel(x, y, col)\n        rh_bm = rd.DisplayBitmap(net_bm)\n        or_x, or_y, sh, sw, th = legend._pixel_dims_2d(vw, vh)\n        s_count = l_par.segment_count\n        s_count = s_count - 1 if l_par.continuous_legend else s_count\n        leg_width = sw if l_par.vertical else sw * s_count\n        leg_height = sh if not l_par.vertical else sh * s_count\n        cent_pt = rg.Point2d(or_x + (leg_width / 2), or_y + (leg_height / 2))\n        draw_sprite = (rh_bm, cent_pt, leg_width, leg_height)\n\n        # translate the legend text\n        _height = legend.parse_dim_2d(l_par.text_height_2d, vh)\n        _font = l_par.font\n        txt_pts = legend.segment_text_location_2d(vw, vh)\n        cent_txt = False if l_par.vertical else True\n        draw_2d_text = [\n            (txt, black(), rg.Point2d(loc.x, loc.y), cent_txt, _height, _font)\n            for txt, loc in zip(legend.segment_text, txt_pts)]\n        t_pt = legend.title_location_2d(vw, vh)\n        legend_title = (legend.title, black(), rg.Point2d(t_pt.x, t_pt.y),\n                        False, _height, _font)\n        draw_2d_text.insert(0, legend_title)\n\n        return draw_sprite, draw_2d_text\n\n    def ToString(self):\n        \"\"\"Overwrite .NET ToString method.\"\"\"\n        return 'VisualizationSet Converter'\n\n\nclass RhinoPointConduit(rd.DisplayConduit):\n    \"\"\"An optimized class to preview Rhino Point3d in the Rhino Display pipeline.\n    \n    Args:\n        points: A list of Rhino Point3d to be displayed in the pipeline.\n    \"\"\"\n\n    def __init__(self, points):\n        \"\"\"Initialize RhinoPointConduit.\"\"\"\n        self.draw_point_args = []\n        col = black()\n        for pt in points:\n            self.draw_point_args.append((pt, rd.PointStyle.RoundSimple, 5, col))\n        self.bbox = rg.BoundingBox(points)\n\n    def CalculateBoundingBox(self, calculateBoundingBoxEventArgs):\n        \"\"\"Overwrite the method that passes the bounding box to the display.\"\"\"\n        calculateBoundingBoxEventArgs.IncludeBoundingBox(self.bbox)\n\n    def PostDrawObjects(self, drawEventArgs):\n        \"\"\"Overwrite the method that draws the objects in the display.\"\"\"\n        # get the DisplayPipeline from the event arguments\n        display = drawEventArgs.Display\n\n        # for each object to be rendered, pass the drawing arguments\n        for draw_args in self.draw_point_args:\n            display.DrawPoint(*draw_args)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}