{
  "source_url": "https://github.com/969flash/HeightLimitCalculation/blob/e793366dae588cbea91bc240d86dcce9cd52a2a1/src/main.py",
  "repo": "969flash/HeightLimitCalculation",
  "repo_stars": 0,
  "repo_description": "가로구역별 높이제한 산정구역의 제한 높이 계산 자동화",
  "license": "unknown",
  "filepath": "src/main.py",
  "instruction": "가로구역별 최고높이 산정 메인 스크립트\nInputs:\n    shp_path: str : SHP 파일 경로\n    pnu: str : 필지 PNU 코드\nOutputs:\n    height_limit: float : 선택된 PNU의 대지 최고높이",
  "code": "# r: pyshp\n\"\"\"\n가로구역별 최고높이 산정 메인 스크립트\nInputs:\n    shp_path: str : SHP 파일 경로\n    pnu: str : 필지 PNU 코드\nOutputs:\n    height_limit: float : 선택된 PNU의 대지 최고높이\n\n1. 도로 생성\n2. 전면 도로 폭 계산\n3. 주변 필지 평균 종심깊이 계산\n4. 가로구역별 최고높이 산정 및 출력\n\n단, utils 모듈을 사용하지 않는다.\n\"\"\"\nfrom typing import List, Tuple, Any, Optional, Union\nimport functools\nimport math\nimport Rhino\nimport Rhino.Geometry as geo\nimport ghpythonlib.components as ghcomp\nimport scriptcontext as sc\n\n# 허용오차\nTOL = 0.001\nBIGNUM = 10000\n\n\n#### 유틸리티 함수 정의 ####\n\n\ndef convert_io_to_list(func):\n    \"\"\"단일 Curve 인/아웃을 리스트 형태로 표준화하는 데코레이터입니다.\n\n    함수가 단일 Curve와 Curve 리스트를 모두 받아야 하고,\n    반환도 일관된 리스트 형태로 맞추고 싶을 때 사용하세요.\n    커브가 아닌 값은 그대로 통과합니다.\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        new_args = []\n        for arg in args:\n            if isinstance(arg, geo.Curve):\n                arg = [arg]\n            new_args.append(arg)\n\n        result = func(*new_args, **kwargs)\n        if isinstance(result, geo.Curve):\n            result = [result]\n        if hasattr(result, \"__dict__\"):\n            for key, values in result.__dict__.items():\n                if isinstance(values, geo.Curve):\n                    setattr(result, key, [values])\n        return result\n\n    return wrapper\n\n\ndef is_region_inside(\n    inner_region: geo.Curve, outer_region: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"내부 영역이 외부 영역에 포함되는지 확인합니다.\"\"\"\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        inner_region, outer_region, geo.Plane.WorldXY, tol\n    )\n\n    return relationship == geo.RegionContainment.AInsideB\n\n\nclass Offset:\n    class _OffsetResult:\n        def __init__(self):\n            self.contour: Optional[List[geo.Curve]] = None\n            self.holes: Optional[List[geo.Curve]] = None\n\n    @convert_io_to_list\n    def polyline_offset(\n        self,\n        crvs: List[geo.Curve],\n        dists: List[float],\n        miter: int = BIGNUM,\n        closed_fillet: int = 2,\n        open_fillet: int = 2,\n        tol: float = Rhino.RhinoMath.ZeroTolerance,\n    ) -> _OffsetResult:\n        \"\"\"Clipper 컴포넌트를 이용한 폴리라인 오프셋.\n\n        입력 폴리라인(유사) 커브를 2D 평면에서 오프셋하고,\n        바깥 윤곽(contour)과 내부 공백(holes)을 각각의 리스트로 반환합니다.\n\n        Args:\n            crvs (List[geo.Curve]): 오프셋할(폴리라인 호환) 커브들.\n            dists (List[float]): 오프셋 거리. 양수는 바깥 윤곽을 생성하며,\n                대응되는 안쪽 결과는 holes에 위치합니다.\n            miter (int): 날카로운 코너를 위한 마이터 제한.\n            closed_fillet (int): 닫힌 형태의 코너 스타일\n                (0=round, 1=square, 2=miter).\n            open_fillet (int): 열린 세그먼트의 끝 처리\n                (0=round, 1=square, 2=butt).\n            tol (float): 연산에 사용할 공차.\n\n        Returns:\n            Offset._OffsetResult: 다음 필드를 포함합니다.\n                - contour: List[Curve] 바깥쪽 오프셋 결과\n                - holes: List[Curve] 안쪽 오프셋 결과\n        \"\"\"\n        if not crvs:\n            raise ValueError(\"No Curves to offset\")\n\n        plane = geo.Plane(geo.Point3d(0, 0, crvs[0].PointAtEnd.Z), geo.Vector3d.ZAxis)\n        result = ghcomp.ClipperComponents.PolylineOffset(\n            crvs,\n            dists,\n            plane,\n            tol,\n            closed_fillet,\n            open_fillet,\n            miter,\n        )\n\n        polyline_offset_result = Offset._OffsetResult()\n        for name in (\"contour\", \"holes\"):\n            setattr(polyline_offset_result, name, result[name])\n        return polyline_offset_result\n\n\ndef offset_regions_inward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"영역 커브를 안쪽으로 offset 한다.\n    단일커브나 커브리스트 관계없이 커브 리스트로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n\n    Returns:\n        offset 후 커브\n    \"\"\"\n\n    if not dist:\n        return regions\n    result = Offset().polyline_offset(regions, dist, miter).holes\n\n    if not result:\n        return []\n\n    if isinstance(regions, geo.Curve):\n        regions = [regions]\n\n    if len(result) < 2:\n        return result\n\n    filtered = [\n        crv for crv in result if any(is_region_inside(crv, reg) for reg in regions)\n    ]\n    return filtered\n\n\ndef offset_regions_outward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"영역 커브를 바깥쪽으로 offset 한다.\n    단일커브나 커브리스트 관계없이 커브 리스트로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n    returns:\n        offset 후 커브\n    \"\"\"\n    if isinstance(regions, geo.Curve):\n        regions = [regions]\n\n    return [offset_region_outward(region, dist, miter) for region in regions]\n\n\ndef offset_region_outward(\n    region: geo.Curve, dist: float, miter: float = BIGNUM\n) -> geo.Curve:\n    \"\"\"영역 커브를 바깥쪽으로 offset 한다.\n    단일 커브를 받아서 단일 커브로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n\n    Returns:\n        offset 후 커브\n    \"\"\"\n\n    if not dist:\n        return region\n    if not isinstance(region, geo.Curve):\n        raise ValueError(\"region must be curve\")\n    return Offset().polyline_offset(region, dist, miter).contour[0]\n\n\ndef simplify_regions_with_offset(\n    regions: List[geo.Curve], dist: float, miter: int = BIGNUM\n) -> Union[List[geo.Curve], geo.Curve]:\n    \"\"\"영역 커브를 안팎으로 offset 하여 단순화한다.\n    이로인해 dist 미만의 폭을 가진 영역이 사라진다.\n    Args:\n        region: 단순화할 대상 커브\n        dist: 안팎으로 offset할 거리\n\n    Returns:\n        단순화된 커브 리스트\n    \"\"\"\n    if not regions:\n        return []\n\n    if dist <= 0.0:\n        return regions\n\n    inner = offset_regions_inward(regions, dist * 0.5, miter)\n    if not inner:\n        return []\n\n    outer = offset_regions_outward(inner, dist * 0.5, miter)\n\n    return outer\n\n\ndef simplify_crv_by_reducing_segments(\n    crv: geo.Curve,\n    tol: float = TOL,\n    angle_tol: Optional[float] = None,\n) -> geo.Curve:\n    \"\"\"MergeColinearSegments + ReduceSegments 기반 단순화.\n\n    - colinear(동일선상) 세그먼트 병합 후, 길이/변화가 tol 이내인 세그먼트 제거로 안정화.\n    - 닫힌 커브의 시작/끝 점 처리 보정 포함.\n    - 실패/과도 단순화 시 원본 반환.\n    \"\"\"\n    if crv is None:\n        return crv\n\n    if angle_tol is None:\n        # 가능하면 constants.ANGLE_TOL 사용, 없으면 약 1도(라디안)\n        try:\n            from constants import ANGLE_TOL as _ANGLE_TOL  # type: ignore\n\n            angle_tol = float(_ANGLE_TOL)\n        except Exception:\n            angle_tol = math.radians(1.0)\n\n    # vertices 기반 polyline 작성\n    pts = get_vertices(crv)\n    if not pts:\n        return crv\n    if crv.IsClosed:\n        pts.append(pts[0])\n\n    pl = geo.Polyline(pts)\n\n    # colinear 병합 및 세그먼트 감소\n    try:\n        pl.MergeColinearSegments(angle_tol, True)\n    except Exception:\n        pass\n    try:\n        pl.ReduceSegments(tol)\n    except Exception:\n        pass\n\n    # 닫힌 커브의 시작점 보정(일부 케이스에서 ReduceSegments가 시작점에 동작하지 않음)\n    try:\n        if pl.IsClosed and pl.Count > 3:\n            pt_items = list(pl.Item)\n            pt_first = pt_items[0]\n            pt1 = pt_items[1]\n            pt2 = pt_items[pl.Count - 2]\n            if geo.Line(pt1, pt2).DistanceTo(pt_first, True) <= tol:\n                pl.RemoveAt(0)\n                pl.RemoveAt(pl.Count - 1)\n                pl.Add(pl.First)\n    except Exception:\n        pass\n\n    polycrv = pl.ToPolylineCurve()\n    if not getattr(polycrv, \"IsValid\", False):\n        # 너무 작은/불안정한 경우 원본 유지\n        return crv\n    return polycrv\n\n\ndef has_intersection(\n    curve_a: geo.Curve,\n    curve_b: geo.Curve,\n    plane: geo.Plane = geo.Plane.WorldXY,\n    tol: float = TOL,\n) -> bool:\n    \"\"\"두 커브가 교차하는지 여부를 확인합니다.\"\"\"\n    return geo.Curve.PlanarCurveCollision(curve_a, curve_b, plane, tol)\n\n\ndef get_intersection_points(\n    curve_a: geo.Curve, curve_b: geo.Curve, tol: float = TOL\n) -> List[geo.Point3d]:\n    \"\"\"두 커브 사이의 교차점을 계산합니다.\"\"\"\n    intersections = geo.Intersect.Intersection.CurveCurve(curve_a, curve_b, tol, tol)\n    if not intersections:\n        return []\n    return [event.PointA for event in intersections]\n\n\ndef get_vertices(curve: geo.Curve) -> List[geo.Point3d]:\n    \"\"\"커브의 모든 정점(Vertex)들을 추출합니다.\"\"\"\n    if not curve:\n        return []\n    vertices = [curve.PointAt(curve.SpanDomain(i)[0]) for i in range(curve.SpanCount)]\n    if not curve.IsClosed:\n        vertices.append(curve.PointAtEnd)\n    return vertices\n\n\ndef is_pt_on_crv(pt: geo.Point3d, crv: geo.Curve, tol=TOL):\n    \"\"\"pt가 crv 위에 있는지 확인\"\"\"\n    rc, param = crv.ClosestPoint(pt, tol)\n    if not rc:\n        return False\n\n    closest_pt = crv.PointAt(param)\n    if closest_pt.DistanceTo(pt) <= tol:\n        return True\n\n    return False\n\n\ndef is_seg_on_crv(seg: geo.Curve, crv: geo.Curve, tol=TOL):\n    \"\"\"seg가 crv 위에 있는지 확인\"\"\"\n    # seg의 끝점 밑 중점은 crv 위에 있어야 한다.\n    for pt in (seg.PointAtStart, seg.PointAtEnd):\n        if not is_pt_on_crv(pt, crv, tol):\n            return False\n\n    pt_mid = seg.PointAtNormalizedLength(0.5)\n    if not is_pt_on_crv(pt_mid, crv, tol):\n        return False\n\n    return True\n\n\ndef is_pt_on_crv(pt: geo.Point3d, crv: geo.Curve, tol=TOL):\n    \"\"\"pt가 crv 위에 있는지 확인\"\"\"\n    rc, param = crv.ClosestPoint(pt, tol)\n    if not rc:\n        return False\n\n    closest_pt = crv.PointAt(param)\n    if closest_pt.DistanceTo(pt) <= tol:\n        return True\n\n    return False\n\n\ndef get_overlapped_curves(\n    curve_a: geo.Curve, curve_b: geo.Curve, tol: float = TOL\n) -> List[geo.Curve]:\n    \"\"\"두 커브가 겹치는 구간의 커브들을 반환합니다.\"\"\"\n    intersection_points = get_intersection_points(curve_a, curve_b)\n    if not intersection_points:\n        return []\n\n    params = [curve_a.SpanDomain(i)[0] for i in range(curve_a.SpanCount)]\n    params += [curve_a.ClosestPoint(pt, tol)[1] for pt in intersection_points]\n    shatter_result = ghcomp.Shatter(curve_a, params)\n\n    if not shatter_result:\n        return []\n\n    overlapped_segments = [seg for seg in shatter_result if is_seg_on_crv(seg, curve_b)]\n    if not overlapped_segments:\n        return []\n\n    return geo.Curve.JoinCurves(overlapped_segments)\n\n\ndef get_overlapped_length(curve_a: geo.Curve, curve_b: geo.Curve) -> float:\n    \"\"\"두 커브가 겹치는 총 길이를 계산합니다.\"\"\"\n    overlapped_curves = get_overlapped_curves(curve_a, curve_b)\n    if not overlapped_curves:\n        return 0.0\n    return sum(crv.GetLength() for crv in overlapped_curves)\n\n\ndef get_area(regions: Union[List[geo.Curve], geo.Curve]) -> float:\n    \"\"\"영역 커브의 면적을 계산합니다.\"\"\"\n    if not isinstance(regions, list):\n        regions = [regions]\n\n    area = sum([geo.AreaMassProperties.Compute(r).Area for r in regions])\n    return round(area, 6)\n\n\ndef get_union_regions(regions: List[geo.Curve] = None) -> List[geo.Curve]:\n    \"\"\"주어진 영역 커브들의 합집합을 구합니다.\n    Args:\n        regions: 합집합을 구할 영역 커브들\n    Returns:\n        합집합 결과 커브들\n    \"\"\"\n    if not regions:\n        return []\n\n    if len(regions) == 1:\n        return regions\n\n    return list(geo.Curve.CreateBooleanUnion(regions, TOL))\n\n\ndef get_bounding_box_region(\n    crvs: List[geo.Curve], plane: geo.Plane = geo.Plane.WorldXY\n) -> geo.Curve:\n    \"\"\"영역 커브들의 바운딩 박스 커브를 구합니다.\"\"\"\n\n    box_list = []\n    for geo_object in crvs:\n        box = geo_object.GetBoundingBox(plane)\n        box_list.append(box)\n\n    box_union = box_list[0]\n    if len(box_list) >= 2:\n        for box_addition in box_list[1:]:\n            box_union = geo.BoundingBox.Union(box_union, box_addition)\n\n    corners = list(box_union.GetCorners())[:4]  # type: List[geo.Point3d]\n    corners.append(corners[0])  # 닫힌 커브를 위해 첫 점 추가\n    polyline = geo.Polyline(corners)\n    return polyline.ToPolylineCurve()\n\n\ndef _polyline_containment(\n    region: geo.Curve, pt: geo.Point3d, plane: geo.Plane = None, tol: float = TOL\n) -> int:\n    \"\"\"점이 영역 안에 있는지 여부를 확인합니다.\"\"\"\n    # -1: 일치, 0: 밖, 1: 안\n    int_result = ghcomp.ClipperComponents.PolylineContainment(region, pt, plane, tol)\n    return int_result\n\n\ndef is_pt_outside(\n    pt: geo.Point3d, region: geo.Curve, plane: geo.Plane = None, tol: float = TOL\n) -> bool:\n    \"\"\"점이 영역 밖에 있는지 여부를 확인합니다.\"\"\"\n    containment = _polyline_containment(region, pt, plane, tol)\n    return containment == 0\n\n\ndef is_pt_inside(\n    pt: geo.Point3d, region: geo.Curve, plane: geo.Plane = None, tol: float = TOL\n) -> bool:\n    \"\"\"점이 영역 안에 있는지 여부를 확인합니다.\"\"\"\n    containment = _polyline_containment(region, pt, plane, tol)\n    return containment == 1\n\n\ndef is_seg_inside(seg: geo.Curve, region: geo.Curve) -> bool:\n    \"\"\"seg가 region 안에 있는지 여부를 확인합니다.\"\"\"\n    if has_intersection(seg, region):\n        return False\n\n    # 점이 하나라도 밖이면 안된다.\n    return all(is_pt_inside(pt, region) for pt in (seg.PointAtStart, seg.PointAtEnd))\n\n\ndef explode_curve(curve: geo.Curve) -> List[geo.Curve]:\n    \"\"\"커브를 분할하여 개별 세그먼트 리스트로 반환합니다.\"\"\"\n    if not curve:\n        return []\n    if isinstance(curve, geo.PolyCurve):\n        return list(curve.DuplicateSegments())\n\n    segments = []\n    if curve.SpanCount > 0:\n        for i in range(curve.SpanCount):\n            sub_curve = curve.Trim(curve.SpanDomain(i))\n            if sub_curve:\n                segments.append(sub_curve)\n    elif curve.IsLinear():\n        segments.append(curve.Duplicate())\n\n    return segments\n\n\n#### 메인 함수 및 클래스 정의 ####\nclass Road:\n    \"\"\"도로 클래스\"\"\"\n\n    def __init__(self, region: geo.Curve, center_crv: geo.Curve):\n        self.region = region\n        self.center_crv = center_crv\n\n\ndef get_roads(lot_regions: List[geo.Curve]) -> List[Road]:\n    \"\"\"도로 생성\n    입력된 대지 영역 리스트에서 도로 영역을 추출하여 Road 객체 리스트를 반환합니다.\n    \"\"\"\n\n    def get_block_regions(lot_regions: List[geo.Curve]) -> List[geo.Curve]:\n        \"\"\"블록 영역 생성\n        대지 영역 리스트에서 블록 영역(대지로 둘러싸인 영역)들을 생성합니다.\n        \"\"\"\n        # 모든 Lot의 경계를 합쳐서 하나의 경계로 만듭니다.\n        LOT_TOL = 0.1  # 대지 경계 병합 허용오차\n\n        offset_regions = offset_regions_outward(lot_regions, LOT_TOL)\n        block_regions = get_union_regions(offset_regions)\n        block_regions = offset_regions_inward(block_regions, LOT_TOL)\n\n        # 연산이후 단순화\n        block_regions = [\n            simplify_crv_by_reducing_segments(region, TOL) for region in block_regions\n        ]\n\n        return block_regions\n\n    def get_road_center_crvs_optimized(bounding_box_region, block_regions):\n        VORONOI_DIV = 2\n\n        # 1. 블록 영역을 하나로 합치기 (연산 횟수 급감)\n        # 수백 개의 블록과 비교하는 대신, 합쳐진 몇 개의 외곽선하고만 비교함\n        union_blocks = geo.Curve.CreateBooleanUnion(block_regions, 0.01)\n        if not union_blocks:\n            union_blocks = block_regions\n\n        # 2. 보로노이 포인트 생성 (모든 커브가 아닌 합집합 커브에서만 생성)\n        # 도로 경계(BBox)와 블록 합집합의 경계에서만 포인트를 추출\n        all_boundary_curves = [bounding_box_region] + list(union_blocks)\n        voronoi_pts = []\n        for crv in all_boundary_curves:\n            params = crv.DivideByLength(VORONOI_DIV, True)\n            if params:\n                voronoi_pts.extend([crv.PointAt(p) for p in params])\n\n        # 3. 보로노이 실행 (BIGNUM 대신 BoundingBox 활용)\n        bbox = bounding_box_region.GetBoundingBox(True)\n        voronoi_result = ghcomp.Voronoi(voronoi_pts, bbox)\n\n        # 4. R-Tree 공간 인덱스 구축 (검색 속도 최적화)\n        # 합쳐진 블록들을 R-Tree에 넣어 주변에 블록이 있는지 빠르게 확인\n        tree = Rhino.Geometry.RTree()\n        for i, b_poly in enumerate(union_blocks):\n            tree.Insert(b_poly.GetBoundingBox(True), i)\n\n        road_center_crvs = []\n\n        # 5. 세그먼트 필터링 및 중복 제거\n        # 이미 처리한 선분을 체크하기 위한 set\n        seen_lines = set()\n\n        for cell_curve in voronoi_result:\n            # Curve를 Line들로 분해\n            segments = cell_curve.DuplicateSegments()\n            for seg in segments:\n                # 중복 체크 (Kangaroo 없이 수동 체크가 더 빠를 수 있음)\n                line_id = tuple(\n                    sorted(\n                        [\n                            (\n                                round(seg.PointAtStart.X, 2),\n                                round(seg.PointAtStart.Y, 2),\n                            ),\n                            (round(seg.PointAtEnd.X, 2), round(seg.PointAtEnd.Y, 2)),\n                        ]\n                    )\n                )\n                if line_id in seen_lines:\n                    continue\n                seen_lines.add(line_id)\n\n                mid_pt = seg.PointAt(0.5)\n\n                # (A) 도로 영역(BBox) 안에 있는지 확인\n                if (\n                    bounding_box_region.Contains(mid_pt, geo.Plane.WorldXY, 0.01)\n                    != geo.PointContainment.Inside\n                ):\n                    continue\n\n                # (B) 블록 내부에 있는지 확인 (R-Tree 활용)\n                is_inside = False\n\n                # mid_pt 근처에 있는 블록만 골라내서 테스트\n                def rtree_callback(sender, e):\n                    nonlocal is_inside\n                    if (\n                        union_blocks[e.Id].Contains(mid_pt, geo.Plane.WorldXY, 0.01)\n                        == geo.PointContainment.Inside\n                    ):\n                        is_inside = True\n                        # 내부임을 확인하면 더 이상 검색 안 함\n\n                tree.Search(geo.Sphere(mid_pt, 0.01), rtree_callback)\n\n                if not is_inside:\n                    road_center_crvs.append(seg)\n\n        return road_center_crvs\n\n    roads: List[Road] = []\n    # 1. 블록 영역 생성\n    block_regions = get_block_regions(lot_regions)\n\n    # 2. 전체 블록을 영역을 포함하는 바운딩 박스 생성\n    bounding_box_region = get_bounding_box_region(block_regions)\n\n    # 3. 도로 중심선 생성\n    road_center_crvs = get_road_center_crvs_optimized(\n        bounding_box_region, block_regions\n    )\n\n    sc.sticky[\"road_center_crvs\"] = road_center_crvs\n\n    # 4. 도로 중심선의 교차점을 중심으로 분할된 도로 생성\n    roads = create_roads_from_junction(road_center_crvs, block_regions)\n\n    return roads\n\n\ndef get_road_width(road: Road) -> float:\n    \"\"\"도로 폭(W) = 도로 면적 / 도로 중심선 길이\"\"\"\n    road_area = ghcomp.Area(road.region)[0]\n    return road_area / road.center_crv.GetLength()\n\n\ndef get_front_road(lot_region: geo.Curve, roads: List[Road]) -> Optional[Road]:\n    \"\"\"전면도로(Front Road) 선택\n\n    전면도로 산정기준(요약):\n    - 2개 이상 도로에 접하면: 대지둘레 길이의 1/8 이상 접한 도로 중 '가장 넓은 도로'를 전면도로로.\n      단, 가장 넓은 도로가 동폭이면 '가장 많이 접한 도로'를 전면도로로.\n    - 1/8 이상 접한 도로가 없으면: '가장 많이 접한 도로'를 전면도로로,\n      접합길이가 동일할 경우 '가장 넓은 도로'를 전면도로로.\n    \"\"\"\n    if not roads:\n        return None\n\n    lot_length = lot_region.GetLength()\n    min_overlap_length = lot_length / 8.0\n\n    touched_roads_over_minlength = []\n    touched_roads = []\n\n    for road in roads:\n        if not has_intersection(lot_region, road.region):\n            continue\n        overlap_length = get_overlapped_length(lot_region, road.region)\n\n        if overlap_length > 0.0:\n            touched_roads.append((road, overlap_length))\n            if overlap_length >= min_overlap_length:\n                touched_roads_over_minlength.append((road, overlap_length))\n\n    front_road_candiates = []\n\n    if touched_roads_over_minlength:\n        front_road_candiates = touched_roads_over_minlength\n    elif touched_roads:\n        front_road_candiates = touched_roads\n    else:\n        raise ValueError(\"선택된 필지에 접하는 도로가 없습니다.(가로구역이 아닙니다)\")\n\n    # 접합 길이가 가장 긴 도로 선택\n    front_road = max(front_road_candiates, key=lambda x: x[1])[0]\n\n    return front_road\n\n\ndef get_average_depth_from_sides(\n    lot_region: geo.Curve, front_road: Road, other_lot_regions: List[geo.Curve]\n) -> float:\n    \"\"\"선택된 필지 주변(최대 5필지)의 평균 종심깊이(L) 계산\n\n    규정 개념상 L은 대상지 기준 전면도로가 같은 좌/우 인접 필지들의 종심을 평균내는 값이다.\n    \"\"\"\n    # 1. 선택된 필지와 같은 도로를 전면도로로 하는 필지만을 구한다.\n    if not other_lot_regions:\n        return 0.0\n    candidate_lot_regions = []\n    for other_lot_region in other_lot_regions:\n        other_front_road = get_front_road(other_lot_region, [front_road])\n        if not other_front_road:\n            raise ValueError(\"인접 필지의 전면도로 산정에 실패했습니다.\")\n        if other_front_road == front_road:\n            candidate_lot_regions.append(other_lot_region)\n\n    # 2. 선택된 필지 중심점 기준으로 좌/우 인접 필지 최대 5필지를 선택\n    # 2-1. 선택된 필지와 전면도로 인접커브의 양 끝점과 닿아있는 필지를 구한다.\n    road_side_crvs = get_overlap_crvs(lot_region, front_road.region)\n    if len(road_side_crvs) != 1:\n        raise ValueError(\"선택된 필지와 전면도로가 한 개의 구간에서만 접하지 않습니다.\")\n\n    # 2-2. 양 옆 필지와 전면도로 인접커브의 양 끝점과 닿아있는 필지를 구한다.\n\n\ndef calculate_height_limit(front_road_width: float, avg_sides_depth: float) -> float:\n    \"\"\"가로구역별 최고높이(H) 산정\n\n    산정식(개념도 기준):\n        H = (W + L/2) * α\n    - W: 전면도로 폭\n    - L: (대상지 포함) 주변 필지 평균 종심깊이\n    - α: 높이계수(도로폭 W에 따라 구간 적용)\n        W ≤ 4m     -> α = 2.0\n        4m < W ≤ 8m -> α = 2 - (W - 4) / 10\n        W > 8m     -> α = 1.5\n    \"\"\"\n\n    w = max(0.0, float(front_road_width or 0.0))\n    l = max(0.0, float(avg_sides_depth or 0.0))\n\n    if w <= 4.0:\n        alpha = 2.0\n    elif w <= 8.0:\n        alpha = 2.0 - (w - 4.0) / 10.0\n    else:\n        alpha = 1.5\n\n    height_limit = (w + (l / 2.0)) * alpha\n    print(\n        f\"산정된 가로구역별 최고높이: {height_limit:.2f} m (W={w:.2f}, L={l:.2f}, α={alpha:.3f})\"\n    )\n    return height_limit\n\n\nif __name__ == \"__main__\":\n    ### 메인 실행 코드 ###\n    # 인풋 값 설정\n    # 파일 경로 읽기\n    target_lot_region = globals().get(\"target_lot_region\", None)\n    other_lot_regions = globals().get(\"other_lot_regions\", None)\n\n    # 1. 도로 생성\n    roads = get_roads(other_lot_regions + [target_lot_region])\n\n    # 2. 전면 도로 폭 계산\n    front_road = get_front_road(target_lot_region, roads)\n    front_road_width = get_road_width(front_road)\n\n    # 3. 주변 필지 평균 종심깊이 계산\n    avg_sides_depth = get_average_depth_from_sides(\n        target_lot_region, front_road, other_lot_regions\n    )\n\n    # 4. 가로구역별 최고높이 산정 및 출력\n    height_limit = calculate_height_limit(front_road_width, avg_sides_depth)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": true
}