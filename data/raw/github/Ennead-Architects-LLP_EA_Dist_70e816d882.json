{
  "source_url": "https://github.com/Ennead-Architects-LLP/EA_Dist/blob/635520d89b8308b78eabf5b60bb80121d0fa3838/Apps/_revit/EnneaDuck.extension/EnneadTab.tab/Import%20Export.panel/Rhino.pulldown/revit2rhino.pushbutton/revit2rhino_script.py_backup.py",
  "repo": "Ennead-Architects-LLP/EA_Dist",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Apps/_revit/EnneaDuck.extension/EnneadTab.tab/Import Export.panel/Rhino.pulldown/revit2rhino.pushbutton/revit2rhino_script.py_backup.py",
  "instruction": "Revit2rhino script.py backup",
  "code": "#!/usr/bin/python\r\n# -*- coding: utf-8 -*-\r\n\r\n__doc__ =\"\"\"\r\nScript for exporting Revit Family Instances to Rhino.\r\nIt converts each FamilyInstance's geometry into a Rhino block containing all its Breps\r\n(or fallback Meshes). The block definition is annotated with 'RevitElementID'.\r\n\r\nGEOMETRY EXTRACTION METHODS:\r\n1. First tries GetSymbolGeometry() - Returns untransformed geometry in family coordinate system.\r\n   This is ideal for block definitions as it's in the symbol's local coordinate space.\r\n\r\n2. If that fails, uses GetInstanceGeometry() - Returns geometry that includes the instance\r\n   transformation and is already in the project coordinate system.\r\n   For this case, we untransform the geometry before creating the block definition.\r\n\r\nBlock names in Rhino follow the format: \"FamilyName_TypeName\"\r\nEach export includes a timestamp in the filename.\r\n\"\"\"\r\n\r\n__title__ = \"Revit2Rhino\"\r\n\r\nimport clr  # pyright: ignore\r\nimport os\r\nimport time\r\nimport logging\r\n\r\n# Configure logging\r\nlogger = logging.getLogger(\"Revit2Rhino\")\r\nlogger.setLevel(logging.INFO)\r\nconsole_handler = logging.StreamHandler()\r\nconsole_handler.setLevel(logging.INFO)\r\nformatter = logging.Formatter('%(levelname)s - %(message)s')\r\nconsole_handler.setFormatter(formatter)\r\nlogger.addHandler(console_handler)\r\n\r\ndef enable_debug_logging():\r\n    logger.setLevel(logging.DEBUG)\r\n    console_handler.setLevel(logging.DEBUG)\r\n    logger.debug(\"Debug logging enabled\")\r\n\r\ntry:\r\n    import System  # pyright: ignore\r\n    clr.AddReference('RhinoCommon')\r\n    import Rhino  # pyright: ignore\r\n    clr.AddReference('RhinoInside.Revit')\r\n    from RhinoInside.Revit.Convert.Geometry import GeometryDecoder as RIR_DECODER  # pyright: ignore\r\n    IMPORT_OK = True\r\nexcept:\r\n    IMPORT_OK = False\r\n\r\n\r\nimport proDUCKtion  # pyright: ignore\r\nproDUCKtion.validify()\r\n\r\nfrom pyrevit import forms\r\nfrom EnneadTab import ERROR_HANDLE, LOG, NOTIFICATION, UI, ENVIRONMENT, USER\r\nfrom EnneadTab.REVIT import REVIT_APPLICATION, REVIT_UNIT, REVIT_RHINO, REVIT_FORMS\r\nfrom Autodesk.Revit import DB  # pyright: ignore\r\n\r\nUIDOC = REVIT_APPLICATION.get_uidoc()\r\nDOC = REVIT_APPLICATION.get_doc()\r\n\r\n\r\n@LOG.log(__file__, __title__)\r\n@ERROR_HANDLE.try_catch_error()\r\ndef revit2rhino(doc):\r\n    \"\"\"Main entry point for Revit to Rhino export.\"\"\"\r\n    # Check if Rhino.Inside is available\r\n    if not IMPORT_OK:\r\n        NOTIFICATION.messenger(\"Please initiate [Rhino.Inside] First\")\r\n        return\r\n    \r\n    # Enable debug logging for developers\r\n    if USER.IS_DEVELOPER:\r\n        enable_debug_logging()\r\n    \r\n    # Collect family instances\r\n    logger.info(\"Collecting family instances from current view...\")\r\n    all_family_instances = (\r\n        DB.FilteredElementCollector(doc, doc.ActiveView.Id)\r\n        .OfClass(DB.FamilyInstance)\r\n        .WhereElementIsNotElementType()\r\n        .ToElements()\r\n    )\r\n    \r\n    # Organize by family\r\n    family_dict = {}\r\n    for instance in all_family_instances:\r\n        try:\r\n            family_name = instance.Symbol.FamilyName\r\n            if family_name not in family_dict:\r\n                family_dict[family_name] = []\r\n            family_dict[family_name].append(instance)\r\n        except:\r\n            pass\r\n    \r\n    # Check if families were found\r\n    family_names = sorted(list(family_dict.keys()))\r\n    if not family_names:\r\n        NOTIFICATION.messenger(\"No family instances found in the current view\")\r\n        return\r\n    \r\n    # Let user select which families to export\r\n    selected_families = forms.SelectFromList.show(\r\n        family_names,\r\n        multiselect=True,\r\n        title=\"Select Families to Export\",\r\n        button_name=\"Export Selected Families\"\r\n    )\r\n    \r\n    if not selected_families:\r\n        NOTIFICATION.messenger(\"No families selected for export\")\r\n        return\r\n    \r\n    # Collect all instances from selected families\r\n    selected_instances = []\r\n    for family_name in selected_families:\r\n        selected_instances.extend(family_dict[family_name])\r\n    \r\n    total_count = len(selected_instances)\r\n    logger.info(\"Selected {} instances from {} families\".format(total_count, len(selected_families)))\r\n    \r\n    # Confirm large exports\r\n    if total_count > 10000:\r\n        options = [\"Yes, proceed with export\", \"No, cancel export\"]\r\n        result = REVIT_FORMS.dialogue(\r\n            title=\"Large Export Warning\",\r\n            main_text=\"You are about to export {} elements.\".format(total_count),\r\n            sub_text=\"This operation may take a while to complete. Do you want to continue?\",\r\n            options=options,\r\n            icon=\"warning\"\r\n        )\r\n        \r\n        if result == options[1]:\r\n            NOTIFICATION.messenger(\"Export canceled by user\")\r\n            return\r\n    \r\n    # Track start time for performance measurement\r\n    start_time = time.time()\r\n    \r\n    # Initialize exporter\r\n    exporter = RevitToRhinoExporter(doc)\r\n    exporter.family_instances = selected_instances\r\n    exporter.setup_document()\r\n    \r\n    # Process elements with progress bar\r\n    def process_element(element):\r\n        exporter.process_element(element)\r\n    \r\n    def label_func(element):\r\n        element_name = \"{} - {}\".format(\r\n            exporter._get_family_name(element), \r\n            element.Id.IntegerValue\r\n        )\r\n        return \"Exporting: {}\".format(element_name)\r\n    \r\n    # Process elements with progress bar\r\n    UI.progress_bar(\r\n        selected_instances,\r\n        process_element,\r\n        label_func=label_func,\r\n        title=\"Revit2Rhino: Exporting Elements\"\r\n    )\r\n    \r\n    # Complete export and save file\r\n    logger.info(\"Finalizing Rhino file...\")\r\n    export_result = exporter.finalize_export()\r\n    \r\n    # Calculate elapsed time\r\n    elapsed_time = time.time() - start_time\r\n    mins, secs = divmod(elapsed_time, 60)\r\n    hours, mins = divmod(mins, 60)\r\n    \r\n    time_str = \"\"\r\n    if hours > 0:\r\n        time_str += \"{:.0f} hours \".format(hours)\r\n    if mins > 0:\r\n        time_str += \"{:.0f} minutes \".format(mins)\r\n    time_str += \"{:.1f} seconds\".format(secs)\r\n    \r\n    if export_result:\r\n        NOTIFICATION.messenger(\"Successfully exported to: {}\\nTotal time: {}\".format(export_result, time_str))\r\n    else:\r\n        NOTIFICATION.messenger(\"Export failed. Check log for details.\\nTotal time: {}\".format(time_str))\r\n\r\n\r\nclass RevitToRhinoExporter(object):\r\n    def __init__(self, revit_doc):\r\n        self.revit_doc = revit_doc\r\n        \r\n        # Generate timestamp for filename\r\n        timestamp = time.strftime(\"%Y%m%d_%H%M%S\", time.localtime())\r\n        self.output_file = os.path.join(ENVIRONMENT.DUMP_FOLDER, \"{}_Revit2Rhino_{}.3dm\".format(ENVIRONMENT.PLUGIN_NAME, timestamp))\r\n        \r\n        self.rhino_doc = None\r\n        self.family_instances = None\r\n        self.geom_options = None\r\n        \r\n        # Statistics tracking\r\n        self.symbol_geo_count = 0\r\n        self.instance_geo_count = 0\r\n        self.failed_geo_count = 0\r\n        self.layer_dict = {}\r\n        \r\n        # Cache for block definitions\r\n        self.block_cache = {}\r\n        self.block_geo_source = {}\r\n        \r\n        # Get the current document unit\r\n        self.revit_unit = REVIT_UNIT.get_doc_length_unit_name(revit_doc)\r\n        \r\n    def setup_document(self):\r\n        \"\"\"Initialize Rhino document and geometry options\"\"\"\r\n        self.rhino_doc = REVIT_RHINO.setup_rhino_doc(self.revit_doc)\r\n        \r\n        # Create geometry options\r\n        opts = DB.Options()\r\n        opts.DetailLevel = DB.ViewDetailLevel.Fine\r\n        opts.IncludeNonVisibleObjects = True\r\n        self.geom_options = opts\r\n        \r\n        return True\r\n            \r\n    def process_element(self, element):\r\n        \"\"\"Process a single family instance\"\"\"\r\n        return self._process_element(element)\r\n    \r\n    def finalize_export(self):\r\n        \"\"\"Generate statistics and save the Rhino file\"\"\"\r\n        # Print statistics\r\n        logger.info(\"Geometry source statistics:\")\r\n        logger.info(\"  - Blocks using symbol geometry: {}\".format(self.symbol_geo_count))\r\n        logger.info(\"  - Blocks using instance geometry: {}\".format(self.instance_geo_count))\r\n        logger.info(\"  - Elements with no usable geometry: {}\".format(self.failed_geo_count))\r\n        \r\n        # Save the file\r\n        self._write_rhino_file()\r\n        return self.output_file\r\n\r\n    def _get_family_name(self, element):\r\n        \"\"\"Get family name from an element with error handling\"\"\"\r\n        try:\r\n            return element.Symbol.FamilyName\r\n        except:\r\n            return \"Unknown\"\r\n\r\n    def _get_type_name(self, element):\r\n        \"\"\"Get type name from an element with error handling\"\"\"\r\n        try:\r\n            return element.Symbol.Name\r\n        except:\r\n            return \"NoType\"\r\n\r\n    def _process_element(self, element):\r\n        \"\"\"Process a single family instance for export.\"\"\"\r\n        element_id = element.Id.IntegerValue\r\n        family_name = self._get_family_name(element)\r\n        type_name = self._get_type_name(element)\r\n        symbol_id = element.Symbol.Id.IntegerValue\r\n        \r\n        # Check if we've already created a block for this symbol\r\n        if symbol_id in self.block_cache:\r\n            block_idx = self.block_cache[symbol_id]\r\n            geo_source = self.block_geo_source.get(symbol_id, \"Unknown\")\r\n            logger.debug(\"  Using cached block for symbol {}\".format(symbol_id))\r\n        else:\r\n            # Extract geometry for this element\r\n            geometry_data = self._get_geometry(element)\r\n            \r\n            if not geometry_data or len(geometry_data) <= 1:\r\n                logger.warning(\"  WARNING: No valid geometry found for {}\".format(family_name))\r\n                self.failed_geo_count += 1\r\n                return\r\n            \r\n            # Update statistics based on geometry source\r\n            geo_source = geometry_data.get(\"geometry_source\", \"Unknown\")\r\n            if geo_source == \"Symbol\":\r\n                self.symbol_geo_count += 1\r\n            elif geo_source.startswith(\"Instance\"):\r\n                self.instance_geo_count += 1\r\n            \r\n            # For Instance geometry, untransform it to get it in symbol coordinates\r\n            if geo_source == \"Instance\" and hasattr(element, \"GetTransform\"):\r\n                transform = element.GetTransform()\r\n                if transform:\r\n                    geometry_data = self._untransform_geometry(geometry_data, transform)\r\n                    geo_source = geometry_data.get(\"geometry_source\", \"Unknown\")\r\n            \r\n            # Create a block definition from the geometry\r\n            block_idx = self._create_block_definition(family_name, type_name, geometry_data)\r\n            \r\n            if block_idx < 0:\r\n                logger.error(\"  ERROR: Failed to create block for {}\".format(family_name))\r\n                return\r\n                \r\n            # Cache the block for future instances of the same symbol\r\n            self.block_cache[symbol_id] = block_idx\r\n            self.block_geo_source[symbol_id] = geo_source\r\n        \r\n        # Place a block instance with the element's transformation\r\n        self._place_block_instance(block_idx, element, geo_source)\r\n\r\n    def _get_geometry(self, element):\r\n        \"\"\"Extract geometry from a family instance.\"\"\"\r\n        family_name = self._get_family_name(element)\r\n        \r\n        # First try to get symbol geometry (preferred)\r\n        symbol_geometry = self._get_symbol_geometry(element.Symbol)\r\n        \r\n        if symbol_geometry and len(symbol_geometry) > 1:  # More than just metadata\r\n            return symbol_geometry\r\n        \r\n        # If symbol geometry failed, try instance geometry\r\n        instance_geometry = self._get_instance_geometry(element)\r\n        \r\n        if instance_geometry and len(instance_geometry) > 1:  # More than just metadata\r\n            return instance_geometry\r\n        \r\n        # If both approaches failed\r\n        return {\"geometry_source\": \"None\"}\r\n\r\n    def _get_symbol_geometry(self, symbol):\r\n        \"\"\"Extract geometry directly from a family symbol (untransformed).\"\"\"\r\n        try:\r\n            # Initialize result dictionary with geometry source metadata\r\n            geometry_by_subcategory = {\"geometry_source\": \"Symbol\"}\r\n            total_objects = 0\r\n            \r\n            # Get the symbol's geometry\r\n            geom_elem = symbol.get_Geometry(self.geom_options)\r\n            if not geom_elem:\r\n                return geometry_by_subcategory\r\n                \r\n            # Process each geometry object\r\n            for geometry_object in geom_elem:\r\n                if isinstance(geometry_object, DB.GeometryInstance):\r\n                    # GetSymbolGeometry returns untransformed geometry\r\n                    symbol_geo = geometry_object.GetSymbolGeometry()\r\n                    if not symbol_geo:\r\n                        continue\r\n                    \r\n                    # Process each geometry object in the symbol\r\n                    for g_obj in symbol_geo:\r\n                        # Get subcategory name for layer assignment\r\n                        subcat_name = self._get_subcategory_name(g_obj)\r\n                        \r\n                        # Convert to Rhino geometry\r\n                        converted = self._convert_revit_geometry(g_obj)\r\n                        \r\n                        if converted:\r\n                            # Add to the appropriate subcategory/layer\r\n                            if subcat_name not in geometry_by_subcategory:\r\n                                geometry_by_subcategory[subcat_name] = []\r\n                            geometry_by_subcategory[subcat_name].extend(converted)\r\n                            total_objects += len(converted)\r\n                \r\n                elif isinstance(geometry_object, DB.Solid) or hasattr(geometry_object, 'Mesh'):\r\n                    # Direct geometry objects in symbol\r\n                    subcat_name = self._get_subcategory_name(geometry_object)\r\n                    \r\n                    converted = self._convert_revit_geometry(geometry_object)\r\n                    \r\n                    if converted:\r\n                        if subcat_name not in geometry_by_subcategory:\r\n                            geometry_by_subcategory[subcat_name] = []\r\n                        geometry_by_subcategory[subcat_name].extend(converted)\r\n                        total_objects += len(converted)\r\n            \r\n            return geometry_by_subcategory\r\n            \r\n        except Exception as e:\r\n            logger.debug(\"  Error getting symbol geometry: {}\".format(str(e)))\r\n            return {\"geometry_source\": \"Symbol\"}\r\n\r\n    def _get_instance_geometry(self, element):\r\n        \"\"\"Extract geometry from a family instance (transformed to project coordinates).\"\"\"\r\n        try:\r\n            # Initialize result dictionary with geometry source metadata\r\n            geometry_by_subcategory = {\"geometry_source\": \"Instance\"}\r\n            total_objects = 0\r\n            \r\n            # Get the instance's geometry\r\n            geom_elem = element.get_Geometry(self.geom_options)\r\n            if not geom_elem:\r\n                return geometry_by_subcategory\r\n                \r\n            # Process each geometry object\r\n            for geometry_object in geom_elem:\r\n                if isinstance(geometry_object, DB.GeometryInstance):\r\n                    # GetInstanceGeometry returns geometry already transformed to project coordinates\r\n                    inst_geo = geometry_object.GetInstanceGeometry()\r\n                    if not inst_geo:\r\n                        continue\r\n                    \r\n                    # Process each geometry object in the instance\r\n                    for g_obj in inst_geo:\r\n                        # Get subcategory name for layer assignment\r\n                        subcat_name = self._get_subcategory_name(g_obj)\r\n                        \r\n                        # Convert to Rhino geometry\r\n                        converted = self._convert_revit_geometry(g_obj)\r\n                        \r\n                        if converted:\r\n                            # Add to the appropriate subcategory/layer\r\n                            if subcat_name not in geometry_by_subcategory:\r\n                                geometry_by_subcategory[subcat_name] = []\r\n                            geometry_by_subcategory[subcat_name].extend(converted)\r\n                            total_objects += len(converted)\r\n                \r\n                elif isinstance(geometry_object, DB.Solid) or hasattr(geometry_object, 'Mesh'):\r\n                    # Direct geometry objects\r\n                    subcat_name = self._get_subcategory_name(geometry_object)\r\n                    \r\n                    converted = self._convert_revit_geometry(geometry_object)\r\n                    \r\n                    if converted:\r\n                        if subcat_name not in geometry_by_subcategory:\r\n                            geometry_by_subcategory[subcat_name] = []\r\n                        geometry_by_subcategory[subcat_name].extend(converted)\r\n                        total_objects += len(converted)\r\n            \r\n            return geometry_by_subcategory\r\n            \r\n        except Exception as e:\r\n            logger.debug(\"  Error getting instance geometry: {}\".format(str(e)))\r\n            return {\"geometry_source\": \"Instance\"}\r\n\r\n    def _get_subcategory_name(self, g_obj):\r\n        \"\"\"Get the subcategory name for a geometry object\"\"\"\r\n        try:\r\n            if g_obj.GraphicsStyleId and self.revit_doc.GetElement(g_obj.GraphicsStyleId):\r\n                style = self.revit_doc.GetElement(g_obj.GraphicsStyleId)\r\n                if hasattr(style, \"GraphicsStyleCategory\") and style.GraphicsStyleCategory:\r\n                    return style.GraphicsStyleCategory.Name\r\n        except:\r\n            pass\r\n        \r\n        return \"UnCategorized\"\r\n\r\n    def _convert_revit_geometry(self, g_obj):\r\n        \"\"\"Convert Revit geometry to Rhino geometry.\"\"\"\r\n        results = []\r\n        \r\n        # Handle Solids - convert to Breps if volume is significant\r\n        if isinstance(g_obj, DB.Solid):\r\n            if g_obj.Volume > 1e-6:\r\n                try:\r\n                    breps = RIR_DECODER.ToBrep(g_obj)\r\n                    if breps:\r\n                        if isinstance(breps, list):\r\n                            for b in breps:\r\n                                if b:\r\n                                    results.append(b)\r\n                        else:\r\n                            results.append(breps)\r\n                except:\r\n                    pass\r\n                    \r\n        # Handle Meshes\r\n        elif hasattr(g_obj, 'Mesh'):\r\n            revit_mesh = g_obj.Mesh\r\n            if revit_mesh and revit_mesh.NumTriangles > 0:\r\n                try:\r\n                    r_mesh = self._mesh_to_rhino(revit_mesh)\r\n                    results.append(r_mesh)\r\n                except:\r\n                    pass\r\n                \r\n        return results\r\n\r\n    def _mesh_to_rhino(self, revit_mesh):\r\n        \"\"\"Convert a Revit mesh to a Rhino mesh\"\"\"\r\n        rhino_mesh = Rhino.Geometry.Mesh()\r\n        \r\n        # Add vertices\r\n        for i in range(revit_mesh.NumVertices):\r\n            rv_vertex = revit_mesh.Vertices[i]\r\n            rhino_mesh.Vertices.Add(rv_vertex.X, rv_vertex.Y, rv_vertex.Z)\r\n            \r\n        # Add triangular faces\r\n        for i in range(revit_mesh.NumTriangles):\r\n            tri = revit_mesh.get_Triangle(i)\r\n            idx0 = tri.get_VertexIndex(0)\r\n            idx1 = tri.get_VertexIndex(1)\r\n            idx2 = tri.get_VertexIndex(2)\r\n            rhino_mesh.Faces.AddFace(idx0, idx1, idx2)\r\n            \r\n        return rhino_mesh\r\n\r\n    def _create_block_definition(self, family_name, type_name, geometry_data):\r\n        \"\"\"Create a Rhino block definition for a family symbol.\"\"\"\r\n        # Create a block name\r\n        if type_name == \"NoType\":\r\n            block_name = \"{}\".format(family_name)\r\n        else:\r\n            block_name = \"{}_{}\".format(family_name, type_name)\r\n        \r\n        # Remove invalid characters\r\n        block_name = block_name.replace(\":\", \"_\").replace(\"/\", \"_\").replace(\"\\\\\", \"_\").replace(\" \", \"_\")\r\n        \r\n        # Collect all geometry and create layers for subcategories\r\n        all_geometry = []\r\n        all_attributes = []\r\n        \r\n        # Check if there's any actual geometry\r\n        has_geometry = False\r\n        for subcat_name, geo_list in geometry_data.items():\r\n            if subcat_name != \"geometry_source\" and len(geo_list) > 0:\r\n                has_geometry = True\r\n                break\r\n                \r\n        if not has_geometry:\r\n            return -1\r\n            \r\n        # Process each subcategory\r\n        for subcat_name, geo_list in geometry_data.items():\r\n            if subcat_name == \"geometry_source\" or not geo_list:\r\n                continue\r\n                \r\n            # Create or get layer for this subcategory\r\n            layer_index = self._get_or_create_layer(subcat_name)\r\n            \r\n            for geo in geo_list:\r\n                if geo is None:\r\n                    continue\r\n                    \r\n                all_geometry.append(geo)\r\n                \r\n                # Create attributes for this object that reference the layer\r\n                attrib = Rhino.DocObjects.ObjectAttributes()\r\n                attrib.LayerIndex = layer_index\r\n                all_attributes.append(attrib)\r\n                \r\n                # Keep track of geometry by layer for statistics\r\n                if subcat_name not in self.layer_dict:\r\n                    self.layer_dict[subcat_name] = []\r\n                self.layer_dict[subcat_name].append(geo)\r\n        \r\n        # Final validation\r\n        if not all_geometry:\r\n            return -1\r\n        \r\n        # Create the block definition\r\n        base_point = Rhino.Geometry.Point3d(0, 0, 0)\r\n        \r\n        block_idx = self.rhino_doc.InstanceDefinitions.Add(\r\n            block_name,\r\n            \"Created from Revit family\",\r\n            base_point,\r\n            all_geometry,\r\n            all_attributes\r\n        )\r\n            \r\n        return block_idx\r\n\r\n    def _get_or_create_layer(self, layer_name):\r\n        \"\"\"Get or create a layer with the given name and return its index\"\"\"\r\n        # Check if layer already exists\r\n        layer_index = self.rhino_doc.Layers.FindByFullPath(layer_name, True)\r\n        if layer_index >= 0:\r\n            return layer_index\r\n            \r\n        # Create new layer\r\n        layer = Rhino.DocObjects.Layer()\r\n        layer.Name = layer_name\r\n        \r\n        # Generate a color based on the layer name\r\n        name_hash = hash(layer_name) % 1000\r\n        r = (name_hash * 13) % 256\r\n        g = (name_hash * 17) % 256\r\n        b = (name_hash * 19) % 256\r\n        layer.Color = System.Drawing.Color.FromArgb(r, g, b)\r\n        \r\n        # Add the layer to the document\r\n        return self.rhino_doc.Layers.Add(layer)\r\n\r\n    def _revit_transform_to_rhino(self, revit_transform):\r\n        \"\"\"Convert a Revit transform to a Rhino transform\"\"\"\r\n        rhino_transform = Rhino.Geometry.Transform.Identity\r\n        \r\n        # Set basis vectors\r\n        rhino_transform.M00 = revit_transform.BasisX.X\r\n        rhino_transform.M10 = revit_transform.BasisX.Y\r\n        rhino_transform.M20 = revit_transform.BasisX.Z\r\n        \r\n        rhino_transform.M01 = revit_transform.BasisY.X\r\n        rhino_transform.M11 = revit_transform.BasisY.Y\r\n        rhino_transform.M21 = revit_transform.BasisY.Z\r\n        \r\n        rhino_transform.M02 = revit_transform.BasisZ.X\r\n        rhino_transform.M12 = revit_transform.BasisZ.Y\r\n        rhino_transform.M22 = revit_transform.BasisZ.Z\r\n        \r\n        # Set origin (no unit conversion here - we'll handle that separately)\r\n        rhino_transform.M03 = revit_transform.Origin.X\r\n        rhino_transform.M13 = revit_transform.Origin.Y\r\n        rhino_transform.M23 = revit_transform.Origin.Z\r\n        \r\n        return rhino_transform\r\n\r\n    def _untransform_geometry(self, geometry_data, transform):\r\n        \"\"\"Untransform geometry extracted with GetInstanceGeometry() to get it back to symbol space.\"\"\"\r\n        # Make a copy of the input data\r\n        result = dict(geometry_data)\r\n        \r\n        try:\r\n            # If there's no geometry other than metadata, return as is\r\n            if len(geometry_data) <= 1 and \"geometry_source\" in geometry_data:\r\n                return result\r\n                \r\n            # Create the inverse transform to get back to symbol space\r\n            inverse_transform = transform.Inverse\r\n            \r\n            # Convert the inverse transform to a Rhino transform\r\n            rhino_inverse = self._revit_transform_to_rhino(inverse_transform)\r\n            \r\n            # Process each subcategory\r\n            for subcat_name, geo_list in list(result.items()):\r\n                if subcat_name == \"geometry_source\":\r\n                    continue\r\n                    \r\n                # Create a new list for the untransformed geometry\r\n                untransformed_list = []\r\n                \r\n                # Apply inverse transform to each geometry object\r\n                for geo in geo_list:\r\n                    try:\r\n                        # Create a duplicate to avoid modifying the original\r\n                        geo_copy = geo.Duplicate()\r\n                        geo_copy.Transform(rhino_inverse)\r\n                        untransformed_list.append(geo_copy)\r\n                    except:\r\n                        untransformed_list.append(geo)  # Keep original if transform fails\r\n                \r\n                # Replace the original list with the untransformed one\r\n                result[subcat_name] = untransformed_list\r\n            \r\n            # Update the geometry source in the metadata\r\n            result[\"geometry_source\"] = \"Instance_Untransformed\"\r\n            \r\n            return result\r\n        except:\r\n            return geometry_data  # Return original data if anything fails\r\n\r\n    def _place_block_instance(self, block_idx, element, geo_source):\r\n        \"\"\"Place a block instance in the Rhino document with the element's transformation.\"\"\"\r\n        # Get the element's transformation\r\n        instance_transform = self._get_element_transform_no_scale(element)\r\n        \r\n        # Create a block instance with the transformation\r\n        instance_id = self.rhino_doc.Objects.AddInstanceObject(block_idx, instance_transform)\r\n        \r\n        # Add element metadata if successful\r\n        if instance_id:\r\n            inst_obj = self.rhino_doc.Objects.FindId(instance_id)\r\n            if inst_obj:\r\n                element_id = element.Id.IntegerValue\r\n                \r\n                # Add metadata as user strings\r\n                inst_obj.Attributes.SetUserString(\"RevitElementID\", str(element_id))\r\n                family_name = self._get_family_name(element)\r\n                type_name = self._get_type_name(element)\r\n                inst_obj.Attributes.SetUserString(\"FamilyName\", family_name)\r\n                inst_obj.Attributes.SetUserString(\"TypeName\", type_name)\r\n                \r\n                inst_obj.CommitChanges()\r\n\r\n    def _get_element_transform_no_scale(self, element):\r\n        \"\"\"Get a Rhino transform from a Revit family instance.\"\"\"\r\n        # Get the element's transform\r\n        revit_transform = element.GetTransform()\r\n        if revit_transform is None:\r\n            return Rhino.Geometry.Transform.Identity\r\n          \r\n        # Create a new Rhino transform\r\n        rhTrans = Rhino.Geometry.Transform.Identity\r\n\r\n        # Copy basis vectors from Revit transform\r\n        rhTrans.M00 = revit_transform.BasisX.X\r\n        rhTrans.M10 = revit_transform.BasisX.Y\r\n        rhTrans.M20 = revit_transform.BasisX.Z\r\n        rhTrans.M30 = 0.0\r\n\r\n        rhTrans.M01 = revit_transform.BasisY.X\r\n        rhTrans.M11 = revit_transform.BasisY.Y\r\n        rhTrans.M21 = revit_transform.BasisY.Z\r\n        rhTrans.M31 = 0.0\r\n\r\n        rhTrans.M02 = revit_transform.BasisZ.X\r\n        rhTrans.M12 = revit_transform.BasisZ.Y\r\n        rhTrans.M22 = revit_transform.BasisZ.Z\r\n        rhTrans.M32 = 0.0\r\n\r\n        # Convert origin coordinates to the proper units\r\n        origin_x = REVIT_UNIT.internal_to_unit(revit_transform.Origin.X, self.revit_unit)\r\n        origin_y = REVIT_UNIT.internal_to_unit(revit_transform.Origin.Y, self.revit_unit)\r\n        origin_z = REVIT_UNIT.internal_to_unit(revit_transform.Origin.Z, self.revit_unit)\r\n        \r\n        rhTrans.M03 = origin_x\r\n        rhTrans.M13 = origin_y\r\n        rhTrans.M23 = origin_z\r\n        rhTrans.M33 = 1.0\r\n        \r\n        return rhTrans\r\n\r\n    def _write_rhino_file(self):\r\n        \"\"\"Write the Rhino document to a 3DM file and open it\"\"\"\r\n        # Configure file write options\r\n        write_option = Rhino.FileIO.FileWriteOptions()\r\n        write_option.FileVersion = 7  # Save as Rhino 7 3dm\r\n        \r\n        # Zoom extents to all objects before saving\r\n        if self.rhino_doc.Objects.Count > 0:\r\n            # Get all objects' bounding box\r\n            bbox = Rhino.Geometry.BoundingBox.Empty\r\n            for obj in self.rhino_doc.Objects:\r\n                if obj.Geometry is not None:\r\n                    bbox.Union(obj.Geometry.GetBoundingBox(True))\r\n            \r\n            # Set all active views to this bounding box\r\n            if bbox.IsValid:\r\n                # Add some padding to the bounding box (10%)\r\n                pad = bbox.Diagonal.Length * 0.1\r\n                bbox.Inflate(pad, pad, pad)\r\n                \r\n                for view in self.rhino_doc.Views:\r\n                    view.ActiveViewport.ZoomBoundingBox(bbox)\r\n                    view.Redraw()\r\n        \r\n        # Write the file and dispose the document\r\n        self.rhino_doc.Write3dmFile(self.output_file, write_option)\r\n        self.rhino_doc.Dispose()\r\n        \r\n        # Open the file\r\n        os.startfile(self.output_file)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    revit2rhino(DOC)\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": false
}