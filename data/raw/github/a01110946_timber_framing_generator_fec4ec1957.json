{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh-main.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh-main.py",
  "instruction": "Main script for timber framing generation within Grasshopper.",
  "code": "# File: gh-main.py\n\"\"\"\nMain script for timber framing generation within Grasshopper.\n\nThis script is designed to be run in Python within the Grasshopper environment.\nIt integrates with Rhino and Revit to extract wall data, generate framing\nelements, and convert the results into serializable objects.\n\nThe script handles the following main tasks:\n1. Extracting data from selected Revit walls\n2. Generating framing elements (studs, plates, headers, etc.)\n3. Converting framing results into standardized TimberFramingResults objects\n\nNote: This script requires the Rhino.Inside.Revit environment to function properly.\n\nUsage:\n    Place this script in a Python component within a Grasshopper definition.\n    Ensure all necessary inputs (e.g., selected walls) are provided to the component.\n\"\"\"\n\nimport sys\nimport os\nimport importlib\nfrom typing import Dict, List, Any, Optional, Union, Tuple\nimport traceback\nimport tempfile\nimport os.path\n\n# CRITICAL: Ensure we use RhinoCommon, not Rhino3dmIO\nimport clr\n\n# STEP 1: Remove rhino3dm from sys.path BEFORE any Rhino imports\n# The rhino3dm package provides Rhino.Geometry from Rhino3dmIO, which conflicts with RhinoCommon\n_paths_to_remove = []\nfor _path in sys.path:\n    if 'rhino3dm' in _path.lower() or 'site-packages' in _path.lower():\n        _paths_to_remove.append(_path)\n\nfor _path in _paths_to_remove:\n    sys.path.remove(_path)\n    print(f\"Removed from sys.path: {_path}\")\n\n# STEP 2: Remove any cached rhino3dm modules\n_modules_to_remove = [k for k in list(sys.modules.keys())\n                      if 'rhino3dm' in k.lower() or k.startswith('Rhino')]\nfor _mod in _modules_to_remove:\n    del sys.modules[_mod]\nprint(f\"Removed {len(_modules_to_remove)} cached Rhino/rhino3dm modules\")\n\n# STEP 3: Add CLR references to RhinoCommon\nclr.AddReference('RhinoCommon')\nclr.AddReference('Grasshopper')\nclr.AddReference('RhinoInside.Revit')\n\n# STEP 4: Import Rhino from RhinoCommon\nimport Rhino\nimport Rhino.Geometry as rg\n\n# STEP 5: Force sys.modules to use RhinoCommon\n# This ensures all subsequent 'import Rhino' statements use our version\nsys.modules['Rhino'] = Rhino\nsys.modules['Rhino.Geometry'] = rg\n\n# Verify we got RhinoCommon\ntry:\n    _test_pt = rg.Point3d(0, 0, 0)\n    _asm_name = _test_pt.GetType().Assembly.GetName().Name\n    print(f\"Rhino.Geometry is from assembly: {_asm_name}\")\n    if \"RhinoCommon\" in _asm_name:\n        print(\"SUCCESS: Using RhinoCommon!\")\n    else:\n        print(f\"WARNING: Expected RhinoCommon but got {_asm_name}\")\nexcept Exception as e:\n    print(f\"Could not verify assembly: {e}\")\nimport scriptcontext as sc\nimport ghpythonlib.treehelpers as th\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\nfrom Grasshopper.Kernel import GH_Convert, GH_Conversion\nfrom Grasshopper.Kernel.Types import GH_Brep, GH_Curve, GH_Point, GH_Mesh, GH_Surface\nfrom RhinoInside.Revit import Revit\nimport System\n\n# Verify we have the correct assembly\ntry:\n    # Try multiple ways to get assembly info\n    _point_type = rg.Point3d(0, 0, 0).GetType()\n    _assembly = _point_type.Assembly\n    _rhino_assembly = _assembly.GetName().Name\n    print(f\"Rhino.Geometry loaded from assembly: {_rhino_assembly}\")\n    if \"RhinoCommon\" not in _rhino_assembly and \"Rhino3dm\" not in _rhino_assembly:\n        print(f\"Assembly details: {_assembly.FullName}\")\nexcept Exception as e:\n    print(f\"Could not verify assembly: {e}\")\n    # Try alternative method\n    try:\n        print(f\"Rhino module location: {Rhino.__file__ if hasattr(Rhino, '__file__') else 'N/A'}\")\n        print(f\"rg module: {rg}\")\n    except:\n        pass\n\n\ndef patch_module_rhino_geometry(module):\n    \"\"\"\n    Patch a module to use the correct Rhino.Geometry from RhinoCommon.\n    This fixes the assembly mismatch issue where modules import Rhino3dmIO instead.\n    \"\"\"\n    if hasattr(module, 'rg'):\n        # Check if the module's rg is from the wrong assembly\n        try:\n            module_assembly = str(module.rg.Point3d.GetType().Assembly.FullName).split(',')[0]\n            if module_assembly != \"RhinoCommon\":\n                print(f\"  Patching {module.__name__}: {module_assembly} -> RhinoCommon\")\n                module.rg = rg  # Replace with our correct rg\n        except:\n            pass\n\n\n# =============================================================================\n# RHINOCOMMON GEOMETRY FACTORY\n# =============================================================================\n# This factory creates geometry directly using RhinoCommon assembly types,\n# bypassing any rhino3dm/Rhino3dmIO assembly conflicts.\n#\n# The solution uses .NET reflection to:\n# 1. Find the RhinoCommon assembly from AppDomain\n# 2. Get types directly from that assembly\n# 3. Create instances using System.Activator.CreateInstance()\n#\n# This ensures all geometry is created with the correct assembly that\n# Grasshopper expects.\n# =============================================================================\n\nclass RhinoCommonFactory:\n    \"\"\"\n    Factory for creating RhinoCommon geometry directly via CLR reflection.\n\n    This bypasses the rhino3dm package which creates Rhino3dmIO geometry\n    that Grasshopper cannot use. All geometry created through this factory\n    is guaranteed to be from the RhinoCommon assembly.\n    \"\"\"\n\n    _instance = None\n    _rc_assembly = None\n    _types_cache = {}\n\n    def __new__(cls):\n        \"\"\"Singleton pattern - reuse the same factory instance.\"\"\"\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n\n    def __init__(self):\n        \"\"\"Initialize the factory by finding RhinoCommon assembly.\"\"\"\n        if self._initialized:\n            return\n\n        from System import AppDomain\n\n        # Find RhinoCommon assembly\n        for asm in AppDomain.CurrentDomain.GetAssemblies():\n            name = asm.GetName().Name\n            if name == \"RhinoCommon\":\n                self._rc_assembly = asm\n                print(f\"RhinoCommonFactory: Found RhinoCommon assembly\")\n                break\n\n        if self._rc_assembly is None:\n            raise RuntimeError(\"RhinoCommon assembly not found in AppDomain\")\n\n        # Pre-cache commonly used types\n        self._cache_types()\n        self._initialized = True\n\n    def _cache_types(self):\n        \"\"\"Pre-cache commonly used RhinoCommon types.\"\"\"\n        type_names = [\n            \"Rhino.Geometry.Point3d\",\n            \"Rhino.Geometry.Vector3d\",\n            \"Rhino.Geometry.Plane\",\n            \"Rhino.Geometry.Line\",\n            \"Rhino.Geometry.LineCurve\",\n            \"Rhino.Geometry.PolylineCurve\",\n            \"Rhino.Geometry.Polyline\",\n            \"Rhino.Geometry.BoundingBox\",\n            \"Rhino.Geometry.Box\",\n            \"Rhino.Geometry.Interval\",\n            \"Rhino.Geometry.Rectangle3d\",\n            \"Rhino.Geometry.Extrusion\",\n            \"Rhino.Geometry.Brep\",\n            \"Rhino.Geometry.NurbsCurve\",\n            \"Rhino.Geometry.NurbsSurface\",\n            \"Rhino.Geometry.Curve\",\n        ]\n\n        for full_name in type_names:\n            short_name = full_name.split(\".\")[-1]\n            self._types_cache[short_name] = self._rc_assembly.GetType(full_name)\n\n    def _get_type(self, type_name: str):\n        \"\"\"Get a RhinoCommon type by short name.\"\"\"\n        if type_name not in self._types_cache:\n            full_name = f\"Rhino.Geometry.{type_name}\"\n            self._types_cache[type_name] = self._rc_assembly.GetType(full_name)\n        return self._types_cache[type_name]\n\n    def _create_instance(self, type_name: str, *args):\n        \"\"\"Create an instance of a RhinoCommon type.\"\"\"\n        from System import Activator, Array\n\n        rc_type = self._get_type(type_name)\n        if rc_type is None:\n            raise TypeError(f\"Could not find type: {type_name}\")\n\n        if len(args) == 0:\n            return Activator.CreateInstance(rc_type)\n        else:\n            return Activator.CreateInstance(rc_type, Array[object](list(args)))\n\n    # =========================================================================\n    # Basic Geometry Creation Methods\n    # =========================================================================\n\n    def create_point3d(self, x: float, y: float, z: float):\n        \"\"\"Create a RhinoCommon Point3d from coordinates.\"\"\"\n        return self._create_instance(\"Point3d\", float(x), float(y), float(z))\n\n    def create_vector3d(self, x: float, y: float, z: float):\n        \"\"\"Create a RhinoCommon Vector3d from components.\"\"\"\n        return self._create_instance(\"Vector3d\", float(x), float(y), float(z))\n\n    def create_plane(self, origin, x_axis, y_axis):\n        \"\"\"\n        Create a RhinoCommon Plane.\n\n        Args:\n            origin: Point3d or (x, y, z) tuple\n            x_axis: Vector3d or (x, y, z) tuple\n            y_axis: Vector3d or (x, y, z) tuple\n        \"\"\"\n        # Convert origin if needed\n        if isinstance(origin, (tuple, list)):\n            origin = self.create_point3d(*origin)\n        elif hasattr(origin, 'X'):  # Existing Point3d (possibly from wrong assembly)\n            origin = self.create_point3d(float(origin.X), float(origin.Y), float(origin.Z))\n\n        # Convert x_axis if needed\n        if isinstance(x_axis, (tuple, list)):\n            x_axis = self.create_vector3d(*x_axis)\n        elif hasattr(x_axis, 'X'):\n            x_axis = self.create_vector3d(float(x_axis.X), float(x_axis.Y), float(x_axis.Z))\n\n        # Convert y_axis if needed\n        if isinstance(y_axis, (tuple, list)):\n            y_axis = self.create_vector3d(*y_axis)\n        elif hasattr(y_axis, 'X'):\n            y_axis = self.create_vector3d(float(y_axis.X), float(y_axis.Y), float(y_axis.Z))\n\n        return self._create_instance(\"Plane\", origin, x_axis, y_axis)\n\n    def create_line(self, start_point, end_point):\n        \"\"\"\n        Create a RhinoCommon Line.\n\n        Args:\n            start_point: Point3d or (x, y, z) tuple\n            end_point: Point3d or (x, y, z) tuple\n        \"\"\"\n        # Convert points if needed\n        if isinstance(start_point, (tuple, list)):\n            start_point = self.create_point3d(*start_point)\n        elif hasattr(start_point, 'X'):\n            start_point = self.create_point3d(float(start_point.X), float(start_point.Y), float(start_point.Z))\n\n        if isinstance(end_point, (tuple, list)):\n            end_point = self.create_point3d(*end_point)\n        elif hasattr(end_point, 'X'):\n            end_point = self.create_point3d(float(end_point.X), float(end_point.Y), float(end_point.Z))\n\n        return self._create_instance(\"Line\", start_point, end_point)\n\n    def create_line_curve(self, start_point, end_point):\n        \"\"\"\n        Create a RhinoCommon LineCurve.\n\n        Args:\n            start_point: Point3d or (x, y, z) tuple\n            end_point: Point3d or (x, y, z) tuple\n        \"\"\"\n        line = self.create_line(start_point, end_point)\n        return self._create_instance(\"LineCurve\", line)\n\n    def create_closed_polyline_from_points(self, points):\n        \"\"\"\n        Create a closed RhinoCommon curve from corner points.\n\n        Uses NurbsCurve.Create static method via reflection (same pattern as\n        create_surface_from_corners which works).\n\n        Args:\n            points: List of 4 corner points as Point3d or (x, y, z) tuples\n\n        Returns:\n            NurbsCurve from RhinoCommon assembly, or None if creation fails\n        \"\"\"\n        from System import Array\n        from System.Reflection import BindingFlags\n\n        # Convert all points to RhinoCommon Point3d\n        rc_points = []\n        for pt in points:\n            if isinstance(pt, (tuple, list)):\n                rc_points.append(self.create_point3d(*pt))\n            elif hasattr(pt, 'X'):\n                rc_points.append(self.create_point3d(\n                    float(pt.X), float(pt.Y), float(pt.Z)\n                ))\n            else:\n                rc_points.append(pt)\n\n        # Close by adding first point at end\n        if len(rc_points) > 0:\n            first_pt = rc_points[0]\n            rc_points.append(self.create_point3d(\n                float(first_pt.X), float(first_pt.Y), float(first_pt.Z)\n            ))\n\n        # Get NurbsCurve type\n        RC_NurbsCurve = self._get_type(\"NurbsCurve\")\n        RC_Point3d = self._get_type(\"Point3d\")\n\n        if RC_NurbsCurve is None:\n            print(\"  ERROR: Could not get NurbsCurve type\")\n            return None\n\n        try:\n            # Create typed Point3d array\n            pt_array = Array.CreateInstance(RC_Point3d, len(rc_points))\n            for i, pt in enumerate(rc_points):\n                pt_array[i] = pt\n\n            # Try NurbsCurve.Create static method with points array\n            # Look for Create(IEnumerable<Point3d>, int degree, NurbsCurveKnotStyle)\n            create_methods = RC_NurbsCurve.GetMethods(BindingFlags.Public | BindingFlags.Static)\n\n            for method in create_methods:\n                if method.Name == \"Create\":\n                    params = method.GetParameters()\n                    # Look for overload: Create(bool periodic, int degree, IEnumerable<Point3d>)\n                    if len(params) == 3:\n                        try:\n                            # Try: Create(false, 1, points) for linear interpolation\n                            result = method.Invoke(None, [False, 1, pt_array])\n                            if result is not None:\n                                return result\n                        except:\n                            pass\n\n            # Fallback: Create 4 line curves and join them manually\n            print(\"  NurbsCurve.Create failed, using LineCurve segments\")\n            line_curves = []\n            for i in range(len(rc_points) - 1):\n                line = self.create_line_curve(rc_points[i], rc_points[i + 1])\n                if line is not None:\n                    line_curves.append(line)\n\n            if line_curves:\n                # Return first line curve as minimal fallback\n                return line_curves[0]\n\n            return None\n\n        except Exception as e:\n            print(f\"  create_closed_polyline_from_points error: {e}\")\n            return None\n\n    def get_boundary_curves_from_surface(self, surface):\n        \"\"\"\n        Extract boundary curves from a surface.\n\n        Since create_surface_from_corners works, we can create the surface\n        first and then extract its boundary as the rectangle curve.\n\n        Args:\n            surface: NurbsSurface from RhinoCommon\n\n        Returns:\n            Array of boundary curves, or None\n        \"\"\"\n        if surface is None:\n            return None\n\n        try:\n            # Get outer boundary curves from the surface\n            # Brep has better boundary extraction\n            brep = surface.ToBrep()\n            if brep is not None:\n                # Get naked edges (boundary)\n                edges = brep.Edges\n                if edges is not None and edges.Count > 0:\n                    # Join the edges into a single curve\n                    edge_curves = []\n                    for i in range(edges.Count):\n                        edge = edges[i]\n                        if edge is not None:\n                            crv = edge.DuplicateCurve()\n                            if crv is not None:\n                                edge_curves.append(crv)\n\n                    if edge_curves:\n                        # Try to join\n                        RC_Curve = self._get_type(\"Curve\")\n                        if RC_Curve is not None and len(edge_curves) > 1:\n                            from System import Array\n                            from System.Reflection import BindingFlags\n\n                            curve_array = Array.CreateInstance(RC_Curve, len(edge_curves))\n                            for i, crv in enumerate(edge_curves):\n                                curve_array[i] = crv\n\n                            join_methods = RC_Curve.GetMethods(BindingFlags.Public | BindingFlags.Static)\n                            for method in join_methods:\n                                if method.Name == \"JoinCurves\":\n                                    params = method.GetParameters()\n                                    try:\n                                        if len(params) >= 1:\n                                            joined = method.Invoke(None, [curve_array])\n                                            if joined is not None and len(joined) > 0:\n                                                return joined[0]\n                                    except:\n                                        continue\n\n                        # Return first edge if join fails\n                        return edge_curves[0] if edge_curves else None\n\n        except Exception as e:\n            print(f\"  get_boundary_curves_from_surface error: {e}\")\n\n        return None\n\n    def create_surface_from_corners(self, p1, p2, p3, p4):\n        \"\"\"\n        Create a RhinoCommon NurbsSurface from 4 corner points.\n\n        Uses NurbsSurface.CreateFromCorners static method via proper reflection.\n\n        Args:\n            p1, p2, p3, p4: Corner points as Point3d or (x, y, z) tuples\n\n        Returns:\n            NurbsSurface from RhinoCommon assembly, or None if creation fails\n        \"\"\"\n        from System.Reflection import BindingFlags\n\n        # Convert all points to RhinoCommon Point3d\n        corners = []\n        for pt in [p1, p2, p3, p4]:\n            if isinstance(pt, (tuple, list)):\n                corners.append(self.create_point3d(*pt))\n            elif hasattr(pt, 'X'):\n                corners.append(self.create_point3d(\n                    float(pt.X), float(pt.Y), float(pt.Z)\n                ))\n            else:\n                corners.append(pt)\n\n        # Get NurbsSurface type and invoke static method\n        RC_NurbsSurface = self._get_type(\"NurbsSurface\")\n        if RC_NurbsSurface is None:\n            print(\"  ERROR: Could not get NurbsSurface type\")\n            return None\n\n        try:\n            # Use reflection to invoke the static CreateFromCorners method\n            method_info = RC_NurbsSurface.GetMethod(\n                \"CreateFromCorners\",\n                BindingFlags.Public | BindingFlags.Static,\n                None,\n                [self._get_type(\"Point3d\")] * 4,  # 4 Point3d parameters\n                None\n            )\n\n            if method_info is not None:\n                result = method_info.Invoke(None, corners)\n                return result\n            else:\n                # Try alternative: direct call (works in some IronPython versions)\n                return RC_NurbsSurface.CreateFromCorners(\n                    corners[0], corners[1], corners[2], corners[3]\n                )\n        except Exception as e:\n            print(f\"  NurbsSurface.CreateFromCorners error: {e}\")\n            return None\n\n    def create_interval(self, t0: float, t1: float):\n        \"\"\"Create a RhinoCommon Interval.\"\"\"\n        return self._create_instance(\"Interval\", float(t0), float(t1))\n\n    def create_rectangle3d(self, plane, width: float, height: float):\n        \"\"\"\n        Create a RhinoCommon Rectangle3d centered on a plane.\n\n        Args:\n            plane: Plane or origin point (will use XY axes)\n            width: Width of rectangle\n            height: Height of rectangle\n        \"\"\"\n        # Convert plane if it's a point\n        if isinstance(plane, (tuple, list)):\n            origin = self.create_point3d(*plane)\n            x_axis = self.create_vector3d(1.0, 0.0, 0.0)\n            y_axis = self.create_vector3d(0.0, 1.0, 0.0)\n            plane = self._create_instance(\"Plane\", origin, x_axis, y_axis)\n        elif hasattr(plane, 'Origin') and hasattr(plane, 'XAxis'):\n            # Existing plane - convert it\n            origin = self.create_point3d(float(plane.Origin.X), float(plane.Origin.Y), float(plane.Origin.Z))\n            x_axis = self.create_vector3d(float(plane.XAxis.X), float(plane.XAxis.Y), float(plane.XAxis.Z))\n            y_axis = self.create_vector3d(float(plane.YAxis.X), float(plane.YAxis.Y), float(plane.YAxis.Z))\n            plane = self._create_instance(\"Plane\", origin, x_axis, y_axis)\n\n        # Create intervals for width and height (centered)\n        x_interval = self.create_interval(-float(width) / 2.0, float(width) / 2.0)\n        y_interval = self.create_interval(-float(height) / 2.0, float(height) / 2.0)\n\n        return self._create_instance(\"Rectangle3d\", plane, x_interval, y_interval)\n\n    def create_bounding_box(self, min_point, max_point):\n        \"\"\"\n        Create a RhinoCommon BoundingBox.\n\n        Args:\n            min_point: Point3d or (x, y, z) tuple for min corner\n            max_point: Point3d or (x, y, z) tuple for max corner\n        \"\"\"\n        if isinstance(min_point, (tuple, list)):\n            min_point = self.create_point3d(*min_point)\n        elif hasattr(min_point, 'X'):\n            min_point = self.create_point3d(float(min_point.X), float(min_point.Y), float(min_point.Z))\n\n        if isinstance(max_point, (tuple, list)):\n            max_point = self.create_point3d(*max_point)\n        elif hasattr(max_point, 'X'):\n            max_point = self.create_point3d(float(max_point.X), float(max_point.Y), float(max_point.Z))\n\n        return self._create_instance(\"BoundingBox\", min_point, max_point)\n\n    def create_box(self, bounding_box):\n        \"\"\"Create a RhinoCommon Box from a BoundingBox.\"\"\"\n        return self._create_instance(\"Box\", bounding_box)\n\n    # =========================================================================\n    # Framing-Specific Geometry Creation\n    # =========================================================================\n\n    def create_extrusion_brep(self, profile_plane, width: float, depth: float,\n                               direction, length: float):\n        \"\"\"\n        Create a Brep by extruding a rectangular profile.\n\n        This is the core method for creating timber framing elements (studs,\n        plates, headers, etc.) from centerline and dimension data.\n\n        Args:\n            profile_plane: Plane at the profile center (start of extrusion)\n            width: Width of the rectangular profile\n            depth: Depth of the rectangular profile\n            direction: Extrusion direction vector\n            length: Length of extrusion\n\n        Returns:\n            Brep geometry from RhinoCommon assembly\n        \"\"\"\n        # Create the profile rectangle\n        rect = self.create_rectangle3d(profile_plane, width, depth)\n\n        # Convert rectangle to NurbsCurve for extrusion\n        rect_curve = rect.ToNurbsCurve()\n\n        # Calculate the extrusion vector\n        if isinstance(direction, (tuple, list)):\n            direction = self.create_vector3d(*direction)\n        elif hasattr(direction, 'X'):\n            direction = self.create_vector3d(float(direction.X), float(direction.Y), float(direction.Z))\n\n        # Scale direction by length\n        ext_x = direction.X * length\n        ext_y = direction.Y * length\n        ext_z = direction.Z * length\n        extrusion_vec = self.create_vector3d(ext_x, ext_y, ext_z)\n\n        # Create extrusion\n        RC_Extrusion = self._get_type(\"Extrusion\")\n        extrusion = RC_Extrusion.Create(rect_curve, float(length), True)\n\n        if extrusion is not None and extrusion.IsValid:\n            brep = extrusion.ToBrep()\n            if brep is not None and brep.IsValid:\n                return brep\n\n        # Fallback: Create box from bounding box\n        return self.create_box_brep_from_centerline(\n            profile_plane.Origin, direction, length, width, depth\n        )\n\n    def create_box_brep_from_centerline(self, start_point, direction, length: float,\n                                         width: float, depth: float):\n        \"\"\"\n        Create a box Brep from centerline parameters.\n\n        This creates a timber element as a simple box aligned with the centerline.\n\n        Args:\n            start_point: Start point of centerline\n            direction: Direction vector (normalized)\n            length: Length along direction\n            width: Width perpendicular to direction (in XY plane)\n            depth: Depth perpendicular to direction and width\n\n        Returns:\n            Brep geometry from RhinoCommon assembly\n        \"\"\"\n        # Convert inputs\n        if isinstance(start_point, (tuple, list)):\n            sx, sy, sz = start_point\n        else:\n            sx, sy, sz = float(start_point.X), float(start_point.Y), float(start_point.Z)\n\n        if isinstance(direction, (tuple, list)):\n            dx, dy, dz = direction\n        else:\n            dx, dy, dz = float(direction.X), float(direction.Y), float(direction.Z)\n\n        # Normalize direction\n        mag = (dx*dx + dy*dy + dz*dz) ** 0.5\n        if mag > 0:\n            dx, dy, dz = dx/mag, dy/mag, dz/mag\n\n        # Calculate end point\n        ex = sx + dx * length\n        ey = sy + dy * length\n        ez = sz + dz * length\n\n        # Calculate perpendicular vectors for width and depth\n        # Simple approach: if direction is vertical, use X and Y\n        # Otherwise, use cross products\n        if abs(dz) > 0.9:  # Nearly vertical\n            perp1 = (1.0, 0.0, 0.0)  # Width in X\n            perp2 = (0.0, 1.0, 0.0)  # Depth in Y\n        else:\n            # Cross with Z to get perpendicular\n            p1x = -dy\n            p1y = dx\n            p1z = 0.0\n            # Normalize\n            p1_mag = (p1x*p1x + p1y*p1y) ** 0.5\n            if p1_mag > 0:\n                p1x, p1y = p1x/p1_mag, p1y/p1_mag\n            perp1 = (p1x, p1y, p1z)\n\n            # Cross direction with perp1 to get perp2\n            p2x = dy * p1z - dz * p1y\n            p2y = dz * p1x - dx * p1z\n            p2z = dx * p1y - dy * p1x\n            perp2 = (p2x, p2y, p2z)\n\n        # Calculate bounding box corners (accounting for width/depth offsets)\n        half_w = width / 2.0\n        half_d = depth / 2.0\n\n        # Find min/max by checking all corners\n        corners = []\n        for start_end in [(sx, sy, sz), (ex, ey, ez)]:\n            px, py, pz = start_end\n            for w_sign in [-1, 1]:\n                for d_sign in [-1, 1]:\n                    cx = px + perp1[0] * half_w * w_sign + perp2[0] * half_d * d_sign\n                    cy = py + perp1[1] * half_w * w_sign + perp2[1] * half_d * d_sign\n                    cz = pz + perp1[2] * half_w * w_sign + perp2[2] * half_d * d_sign\n                    corners.append((cx, cy, cz))\n\n        # Find actual min/max from corners\n        min_x = min(c[0] for c in corners)\n        min_y = min(c[1] for c in corners)\n        min_z = min(c[2] for c in corners)\n        max_x = max(c[0] for c in corners)\n        max_y = max(c[1] for c in corners)\n        max_z = max(c[2] for c in corners)\n\n        # Create bounding box and box\n        bbox = self.create_bounding_box((min_x, min_y, min_z), (max_x, max_y, max_z))\n        box = self.create_box(bbox)\n\n        return box.ToBrep()\n\n    def convert_geometry_from_rhino3dm(self, geom):\n        \"\"\"\n        Convert geometry from Rhino3dmIO assembly to RhinoCommon assembly.\n\n        This extracts the bounding box from the source geometry and creates\n        a new box using RhinoCommon. While this loses exact shape fidelity,\n        it works for simple box-like timber framing elements.\n\n        Args:\n            geom: Geometry object (likely from Rhino3dmIO)\n\n        Returns:\n            Brep from RhinoCommon assembly, or None if conversion fails\n        \"\"\"\n        if geom is None:\n            return None\n\n        try:\n            # Get bounding box coordinates\n            bbox = geom.GetBoundingBox(True)\n            if not bbox.IsValid:\n                return None\n\n            min_pt = (float(bbox.Min.X), float(bbox.Min.Y), float(bbox.Min.Z))\n            max_pt = (float(bbox.Max.X), float(bbox.Max.Y), float(bbox.Max.Z))\n\n            # Create RhinoCommon box\n            rc_bbox = self.create_bounding_box(min_pt, max_pt)\n            rc_box = self.create_box(rc_bbox)\n\n            return rc_box.ToBrep()\n        except Exception as e:\n            print(f\"RhinoCommonFactory.convert_geometry_from_rhino3dm error: {e}\")\n            return None\n\n\n# Create global factory instance\ntry:\n    rc_factory = RhinoCommonFactory()\n    print(\"RhinoCommonFactory initialized successfully\")\nexcept Exception as e:\n    rc_factory = None\n    print(f\"WARNING: Could not initialize RhinoCommonFactory: {e}\")\n\n\ndef patch_all_timber_modules():\n    \"\"\"\n    Patch all timber_framing_generator modules to use RhinoCommon.\n    Call this after importing/reloading modules.\n    \"\"\"\n    print(\"Patching modules to use RhinoCommon...\")\n    patched = 0\n    for name, module in sys.modules.items():\n        if module is not None and 'timber_framing_generator' in name:\n            patch_module_rhino_geometry(module)\n            patched += 1\n    print(f\"  Checked {patched} modules\")\n\n# Store reference to ghdoc for geometry operations\n# ghdoc is a special Grasshopper document that handles geometry correctly\ntry:\n    import ghdoc\n    GHDOC_AVAILABLE = True\nexcept:\n    GHDOC_AVAILABLE = False\n    print(\"Warning: ghdoc not available\")\n\n\ndef convert_to_gh_brep(brep):\n    \"\"\"\n    Convert a Rhino.Geometry.Brep to a Grasshopper-compatible format.\n    Tries multiple methods to handle cross-assembly conversion.\n\n    Args:\n        brep: Rhino.Geometry.Brep object\n\n    Returns:\n        Geometry compatible with Grasshopper output or None on failure\n    \"\"\"\n    if brep is None:\n        return None\n\n    # Method 1: Try direct duplicate - sometimes this creates a new object in current context\n    try:\n        if hasattr(brep, 'DuplicateBrep'):\n            dup = brep.DuplicateBrep()\n            if dup is not None:\n                return dup\n    except Exception as e:\n        print(f\"DuplicateBrep error: {e}\")\n\n    # Method 2: Try Duplicate() (base GeometryBase method)\n    try:\n        if hasattr(brep, 'Duplicate'):\n            dup = brep.Duplicate()\n            if dup is not None:\n                return dup\n    except Exception as e:\n        print(f\"Duplicate error: {e}\")\n\n    # Method 3: Try using ghdoc to force geometry into GH context\n    if GHDOC_AVAILABLE:\n        try:\n            current_doc = sc.doc\n            sc.doc = ghdoc\n            guid = sc.doc.Objects.AddBrep(brep)\n            if guid != System.Guid.Empty:\n                obj = sc.doc.Objects.FindId(guid)\n                if obj and obj.Geometry:\n                    result = obj.Geometry.Duplicate()\n                    sc.doc.Objects.Delete(guid, True)\n                    sc.doc = current_doc\n                    return result\n            sc.doc = current_doc\n        except Exception as e:\n            print(f\"ghdoc conversion error: {e}\")\n            try:\n                sc.doc = current_doc\n            except:\n                pass\n\n    # Method 4: Return as-is and let GH try to handle it\n    return brep\n\n\ndef convert_to_gh_curve(curve):\n    \"\"\"\n    Convert a Rhino.Geometry.Curve to a Grasshopper-compatible GH_Curve.\n\n    Args:\n        curve: Rhino.Geometry.Curve object\n\n    Returns:\n        GH_Curve or None on failure\n    \"\"\"\n    if curve is None:\n        return None\n\n    try:\n        # Method 1: Direct CastFrom\n        gh_curve = GH_Curve()\n        if gh_curve.CastFrom(curve):\n            return gh_curve\n    except Exception as e:\n        print(f\"GH_Curve CastFrom error: {e}\")\n\n    try:\n        # Method 2: GH_Convert\n        gh_curve = GH_Curve()\n        result = GH_Convert.ToGHCurve(curve, GH_Conversion.Both, gh_curve)\n        if isinstance(result, tuple):\n            success, gh_curve = result[0], result[1]\n            if success and gh_curve is not None:\n                return gh_curve\n        elif result:\n            return gh_curve\n    except Exception as e:\n        print(f\"GH_Curve ToGHCurve error: {e}\")\n\n    return None\n\n\ndef convert_to_gh_point(point):\n    \"\"\"\n    Convert a Rhino.Geometry.Point3d to a Grasshopper-compatible GH_Point.\n\n    Args:\n        point: Rhino.Geometry.Point3d object\n\n    Returns:\n        GH_Point or None on failure\n    \"\"\"\n    if point is None:\n        return None\n\n    try:\n        # Method 1: Direct CastFrom\n        gh_point = GH_Point()\n        if gh_point.CastFrom(point):\n            return gh_point\n    except Exception as e:\n        print(f\"GH_Point CastFrom error: {e}\")\n\n    try:\n        # Method 2: GH_Convert\n        gh_point = GH_Point()\n        result = GH_Convert.ToGHPoint(point, GH_Conversion.Both, gh_point)\n        if isinstance(result, tuple):\n            success, gh_point = result[0], result[1]\n            if success and gh_point is not None:\n                return gh_point\n        elif result:\n            return gh_point\n    except Exception as e:\n        print(f\"GH_Point ToGHPoint error: {e}\")\n\n    return None\n\n\ndef convert_to_gh_mesh(mesh):\n    \"\"\"\n    Convert a Rhino.Geometry.Mesh to a Grasshopper-compatible GH_Mesh.\n\n    Args:\n        mesh: Rhino.Geometry.Mesh object\n\n    Returns:\n        GH_Mesh or None on failure\n    \"\"\"\n    if mesh is None:\n        return None\n\n    try:\n        # Method 1: Direct CastFrom\n        gh_mesh = GH_Mesh()\n        if gh_mesh.CastFrom(mesh):\n            return gh_mesh\n    except Exception as e:\n        print(f\"GH_Mesh CastFrom error: {e}\")\n\n    try:\n        # Method 2: GH_Convert\n        gh_mesh = GH_Mesh()\n        result = GH_Convert.ToGHMesh(mesh, GH_Conversion.Both, gh_mesh)\n        if isinstance(result, tuple):\n            success, gh_mesh = result[0], result[1]\n            if success and gh_mesh is not None:\n                return gh_mesh\n        elif result:\n            return gh_mesh\n    except Exception as e:\n        print(f\"GH_Mesh ToGHMesh error: {e}\")\n\n    return None\n\n\ndef convert_to_gh_surface(surface):\n    \"\"\"\n    Convert a Rhino.Geometry.Surface to a Grasshopper-compatible GH_Surface.\n\n    Args:\n        surface: Rhino.Geometry.Surface object\n\n    Returns:\n        GH_Surface or None on failure\n    \"\"\"\n    if surface is None:\n        return None\n\n    try:\n        # Method 1: Direct CastFrom\n        gh_surface = GH_Surface()\n        if gh_surface.CastFrom(surface):\n            return gh_surface\n    except Exception as e:\n        print(f\"GH_Surface CastFrom error: {e}\")\n\n    try:\n        # Method 2: GH_Convert\n        gh_surface = GH_Surface()\n        result = GH_Convert.ToGHSurface(surface, GH_Conversion.Both, gh_surface)\n        if isinstance(result, tuple):\n            success, gh_surface = result[0], result[1]\n            if success and gh_surface is not None:\n                return gh_surface\n        elif result:\n            return gh_surface\n    except Exception as e:\n        print(f\"GH_Surface ToGHSurface error: {e}\")\n\n    return None\n\n\ndef convert_geometry_for_gh(geometry):\n    \"\"\"\n    Convert any Rhino geometry to its Grasshopper-compatible equivalent.\n    Automatically detects geometry type and applies appropriate conversion.\n\n    Args:\n        geometry: Any Rhino.Geometry object\n\n    Returns:\n        Grasshopper-compatible geometry (GH_Brep, GH_Curve, etc.) or None\n    \"\"\"\n    if geometry is None:\n        return None\n\n    try:\n        # Get the type name for more reliable type checking across assemblies\n        type_name = geometry.GetType().Name\n\n        # Check geometry type and convert accordingly\n        if type_name == \"Brep\" or isinstance(geometry, rg.Brep):\n            return convert_to_gh_brep(geometry)\n        elif type_name == \"Mesh\" or isinstance(geometry, rg.Mesh):\n            return convert_to_gh_mesh(geometry)\n        elif type_name in [\"Surface\", \"NurbsSurface\", \"BrepFace\"] or isinstance(geometry, rg.Surface):\n            return convert_to_gh_surface(geometry)\n        elif type_name in [\"Curve\", \"LineCurve\", \"NurbsCurve\", \"PolylineCurve\", \"ArcCurve\"] or isinstance(geometry, rg.Curve):\n            return convert_to_gh_curve(geometry)\n        elif type_name == \"Line\":\n            # Line is a struct, not a Curve - convert to LineCurve first\n            try:\n                # Use factory to create RhinoCommon LineCurve\n                if rc_factory is not None:\n                    start = (float(geometry.From.X), float(geometry.From.Y), float(geometry.From.Z))\n                    end = (float(geometry.To.X), float(geometry.To.Y), float(geometry.To.Z))\n                    return rc_factory.create_line_curve(start, end)\n                else:\n                    line_curve = rg.LineCurve(geometry)\n                    return convert_to_gh_curve(line_curve)\n            except Exception as e:\n                print(f\"Line conversion error: {e}\")\n                return None\n        elif type_name == \"Point3d\" or isinstance(geometry, rg.Point3d):\n            return convert_to_gh_point(geometry)\n        elif type_name in [\"Extrusion\", \"Box\"]:\n            # For objects that can be converted to Brep\n            brep = geometry.ToBrep()\n            if brep:\n                return convert_to_gh_brep(brep)\n        elif hasattr(geometry, 'ToBrep'):\n            brep = geometry.ToBrep()\n            if brep:\n                return convert_to_gh_brep(brep)\n        else:\n            print(f\"Unknown geometry type: {type_name} ({type(geometry)})\")\n    except Exception as e:\n        print(f\"Geometry conversion error for {type(geometry)}: {e}\")\n\n    return None\n\n\ndef convert_breps_for_output(brep_list, debug=False):\n    \"\"\"\n    Convert Breps from Rhino.Inside context to Grasshopper-compatible geometry.\n\n    Uses RhinoCommonFactory to handle assembly mismatch between Rhino3dmIO\n    and RhinoCommon. All geometry is recreated using the correct assembly.\n\n    Args:\n        brep_list: List of Breps or objects with ToBrep() method\n        debug: If True, print detailed diagnostic information\n\n    Returns:\n        List of Grasshopper-compatible geometry (from RhinoCommon assembly)\n    \"\"\"\n    if not brep_list:\n        return []\n\n    result = []\n    conversion_errors = 0\n    factory_successes = 0\n    direct_successes = 0\n\n    for i, item in enumerate(brep_list):\n        if item is None:\n            continue\n\n        converted = None\n\n        try:\n            # Check if item is from wrong assembly\n            item_assembly = None\n            if hasattr(item, 'GetType'):\n                try:\n                    item_assembly = item.GetType().Assembly.GetName().Name\n                except:\n                    pass\n\n            if debug and i < 3:  # Only debug first 3 items\n                print(f\"\\n  DEBUG item {i}:\")\n                print(f\"    Input type: {type(item)}\")\n                print(f\"    Input type name: {item.GetType().Name if hasattr(item, 'GetType') else 'N/A'}\")\n                print(f\"    Input assembly: {item_assembly or 'N/A'}\")\n                if hasattr(item, 'IsValid'):\n                    print(f\"    IsValid: {item.IsValid}\")\n\n            # PRIMARY METHOD: Use RhinoCommonFactory if item is from wrong assembly\n            if rc_factory is not None and item_assembly and item_assembly != \"RhinoCommon\":\n                converted = rc_factory.convert_geometry_from_rhino3dm(item)\n                if converted is not None:\n                    factory_successes += 1\n                    if debug and i < 3:\n                        print(f\"    Factory conversion: SUCCESS\")\n                        print(f\"    Output assembly: {converted.GetType().Assembly.GetName().Name}\")\n\n            # FALLBACK: If factory failed or item is already from correct assembly\n            if converted is None:\n                # Item might already be from RhinoCommon\n                if item_assembly == \"RhinoCommon\":\n                    converted = item\n                    direct_successes += 1\n                    if debug and i < 3:\n                        print(f\"    Direct pass-through (already RhinoCommon)\")\n                else:\n                    # Try legacy conversion methods\n                    converted = convert_geometry_for_gh(item)\n                    if converted is not None:\n                        direct_successes += 1\n\n            if debug and i < 3 and converted is not None:\n                print(f\"    Output type: {type(converted)}\")\n                if hasattr(converted, 'GetType'):\n                    print(f\"    Output type name: {converted.GetType().Name}\")\n                    print(f\"    Output assembly: {converted.GetType().Assembly.GetName().Name}\")\n\n            if converted is not None:\n                result.append(converted)\n            else:\n                conversion_errors += 1\n        except Exception as e:\n            print(f\"Error converting geometry {i}: {e}\")\n            import traceback\n            traceback.print_exc()\n            conversion_errors += 1\n\n    if debug or conversion_errors > 0:\n        print(f\"  Conversion summary: {len(result)} succeeded ({factory_successes} via factory, {direct_successes} direct), {conversion_errors} failed\")\n\n    return result\n\n# Simplified path handling\nproject_dir = r'C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator'\n\n# Add to sys.path if not already there\nif project_dir not in sys.path:\n    sys.path.append(project_dir)\n    print(f\"Added {project_dir} to sys.path\")\n\nfrom src.timber_framing_generator.utils.logging_config import TimberFramingLogger\nlog_dir = os.path.join(tempfile.gettempdir(), 'timber_framing_logs')\nlog_file = TimberFramingLogger.configure(debug_mode=True, log_dir=log_dir, rhino_mode=True)\nlogger = TimberFramingLogger.get_logger(__name__)\nlogger.info(f\"Timber Framing Generator started. Logging to {log_file}\")\n\n# Module reloading function\ndef reload_timber_modules():\n    \"\"\"Reload all timber_framing_generator modules.\"\"\"\n    # First, ensure Rhino modules point to RhinoCommon\n    # by injecting our correct Rhino into sys.modules\n    sys.modules['Rhino'] = Rhino\n    sys.modules['Rhino.Geometry'] = rg\n\n    modules_to_reload = [m for m in sys.modules.keys()\n                      if m.startswith('src.timber_framing_generator')]\n\n    reload_count = 0\n    for module_name in modules_to_reload:\n        try:\n            importlib.reload(sys.modules[module_name])\n            reload_count += 1\n        except Exception as e:\n            print(f\"Failed to reload {module_name}: {str(e)}\")\n\n    print(f\"Reloaded {reload_count} modules\")\n\n    # Patch all modules after reload\n    patch_all_timber_modules()\n\n    return reload_count\n\n# CRITICAL: Clear any cached timber modules before importing\n# This ensures they import Rhino.Geometry from our forced sys.modules entry\n_timber_modules_to_clear = [k for k in list(sys.modules.keys())\n                            if 'timber_framing_generator' in k]\nfor _mod in _timber_modules_to_clear:\n    del sys.modules[_mod]\nprint(f\"Cleared {len(_timber_modules_to_clear)} cached timber modules\")\n\n# Now import modules fresh - they will use our Rhino from sys.modules\ntry:\n    from src.timber_framing_generator.utils.serialization import (\n        TimberFramingResults, DebugGeometry,\n        serialize_results, deserialize_results\n    )\n    from src.timber_framing_generator.wall_data.wall_selector import pick_walls_from_active_view\n    from src.timber_framing_generator.wall_data.revit_data_extractor import extract_wall_data_from_revit\n    from src.timber_framing_generator.cell_decomposition.cell_visualizer import create_rectangles_from_cell_data\n    from src.timber_framing_generator.framing_elements.plates import create_plates\n    from src.timber_framing_generator.framing_elements import FramingGenerator\n    print(\"Successfully imported all modules\")\n    # Patch modules to use RhinoCommon\n    patch_all_timber_modules()\nexcept ImportError as e:\n    print(f\"Import error: {str(e)}\")\n    print(\"Make sure the timber_framing_generator package is correctly installed\")\n    # Exit or handle the error appropriately\n\n# Reload modules if requested\nif reload:\n    reload_count = reload_timber_modules()\n    \n    # Re-import after reloading to ensure we have the latest versions\n    from src.timber_framing_generator.wall_data.wall_selector import pick_walls_from_active_view\n    from src.timber_framing_generator.wall_data.revit_data_extractor import extract_wall_data_from_revit\n    from src.timber_framing_generator.cell_decomposition.cell_visualizer import create_rectangles_from_cell_data\n    from src.timber_framing_generator.framing_elements.plates import create_plates\n    from src.timber_framing_generator.framing_elements import FramingGenerator\n    from src.timber_framing_generator.utils.safe_rhino import safe_create_extrusion\n    from src.timber_framing_generator.utils.safe_rhino import safe_add_brep\n    from src.timber_framing_generator.utils.safe_rhino import is_valid_geometry\n    from src.timber_framing_generator.utils.serialization import inspect_framing_results\n\n    print(f\"Re-imported all modules after reloading {reload_count} modules\")\n    # Patch modules to use RhinoCommon after reload\n    patch_all_timber_modules()\n\nprint(\"DEBUG: Script starting\")\nprint(f\"DEBUG: TimberFramingResults imported: {TimberFramingResults is not None}\")\nprint(f\"DEBUG: DebugGeometry imported: {DebugGeometry is not None}\")\n\ndef extract_wall_data(walls) -> List[Dict[str, Any]]:\n    \"\"\"\n    Extract data from selected Revit walls using our data extractor.\n    \n    This function processes each wall to capture its geometry, properties,\n    and spatial information needed for framing generation. It handles\n    errors gracefully and reports issues for individual walls.\n    \"\"\"\n    print(\"DEBUG: Starting wall data extraction\")\n    uidoc = Revit.ActiveUIDocument\n    doc = uidoc.Document\n    \n    all_walls_data = []\n    successfull_walls = 0\n    for wall in walls:\n        try:\n            wall_data = extract_wall_data_from_revit(wall, doc)\n            print(f\"This is wall_data: {wall_data}\")\n            print(f\"DEBUG: Raw wall_data exists: {wall_data is not None}\")\n            if wall_data is not None:\n                successfull_walls += 1\n                print(f\"DEBUG: wall_data keys: {list(wall_data.keys())}\")\n                print(f\"DEBUG: base_plane exists: {wall_data.get('base_plane') is not None}\")\n            all_walls_data.append(wall_data)\n            print(f\"Processed wall ID: {wall.Id}\")\n        except Exception as e:\n            print(f\"Error processing wall {wall.Id}: {str(e)}\")\n            import traceback\n            print(f\"Error: Traceback: {traceback.format_exc()}\")\n        print(f\"DEBUG: Extracted data for {successfull_walls}/{len(walls)} walls\")\n\n    print(f\"DEBUG: Extracted data for {len(all_walls_data)} walls\")\n    all_walls_data = [wall for wall in all_walls_data if wall is not None]\n    print(f\"DEBUG: After filtering None values, found {len(all_walls_data)} valid walls\")\n    print(f\"DEBUG: Before filtering, wall data list has {len(all_walls_data)} items\")\n    valid_walls = []\n    for i, wall in enumerate(all_walls_data):\n        if wall is not None:\n            valid_walls.append(wall)\n            print(f\"DEBUG: Wall {i} is valid\")\n        else:\n            print(f\"DEBUG: Wall {i} is None\")\n    all_walls_data = valid_walls\n    print(f\"DEBUG: After filtering None values, found {len(all_walls_data)} valid walls\")\n    return all_walls_data\n\ndef convert_framing_to_objects(all_framing_results: List[Dict[str, Any]]) -> List[TimberFramingResults]:\n    \"\"\"\n    Convert framing results dictionaries to custom objects.\n    \n    Args:\n        all_framing_results: List of framing result dictionaries\n        \n    Returns:\n        List of TimberFramingResults objects\n    \"\"\"\n    # Import safe_rhino utilities here to avoid circular imports\n    from src.timber_framing_generator.utils.safe_rhino import safe_add_brep, is_valid_geometry\n    import Rhino.Geometry as rg\n    \n    result_objects = []\n    \n    for wall_index, framing in enumerate(all_framing_results):\n        # Create a result object for this wall\n        result = TimberFramingResults(f\"Wall_{wall_index}\")\n        \n        logger.info(f\"\\nProcessing wall {wall_index}:\")\n        \n        # Get base plane from various sources\n        base_plane = None\n        if 'base_plane' in framing:\n            base_plane = framing['base_plane']\n            logger.debug(\"  Found base_plane in framing results\")\n        elif 'wall_data' in framing and 'base_plane' in framing['wall_data']:\n            base_plane = framing['wall_data']['base_plane']\n            logger.debug(\"  Extracted base_plane from wall_data\")\n            \n        result.base_plane = base_plane\n        result.cells = framing.get('cells', [])\n        result.wall_data = framing.get('wall_data', {})\n        \n        # Helper function to extract geometry with fallback methods\n        def extract_geometry_with_fallback(element):\n            \"\"\"\n            Extract geometry from framing element with multiple fallback methods.\n            \n            This function tries various approaches to extract valid geometry:\n            1. Use get_geometry_data method if available\n            2. Access brep property directly if it exists\n            3. Access geometry property if it exists\n            4. Create geometry from scratch if possible\n            \n            Returns:\n                Rhino geometry object or None if extraction fails\n            \"\"\"\n            try:\n                # Special case: Direct handling of PlateGeometry objects\n                if element.__class__.__name__ == \"PlateGeometry\":\n                    try:\n                        # Call create_rhino_geometry directly for PlateGeometry objects\n                        rhino_geom = element.create_rhino_geometry()\n                        if rhino_geom is not None:\n                            logger.debug(f\"  Successfully extracted geometry via direct PlateGeometry.create_rhino_geometry()\")\n                            return rhino_geom\n                    except Exception as e:\n                        logger.warning(f\"  Error calling create_rhino_geometry: {str(e)}\")\n                \n                # Method 1: Try using get_geometry_data\n                if hasattr(element, 'get_geometry_data'):\n                    try:\n                        geometry_data = element.get_geometry_data(platform=\"rhino\")\n                        if 'platform_geometry' in geometry_data:\n                            geom = geometry_data['platform_geometry']\n                            logger.debug(f\"  Successfully extracted geometry via get_geometry_data\")\n                            return safe_add_brep(geom)\n                    except Exception as e:\n                        logger.debug(f\"  get_geometry_data failed: {str(e)}\")\n                \n                # Method 2: Try accessing brep directly\n                if hasattr(element, 'brep') and element.brep is not None:\n                    brep = safe_add_brep(element.brep)\n                    if brep is not None:\n                        logger.debug(f\"  Successfully extracted geometry via direct brep property\")\n                        return brep\n                \n                # Method 3: Try accessing geometry directly\n                if hasattr(element, 'geometry') and element.geometry is not None:\n                    geom = safe_add_brep(element.geometry)\n                    if geom is not None:\n                        logger.debug(f\"  Successfully extracted geometry via direct geometry property\")\n                        return geom\n                \n                # Method 4: Try extracting from raw element properties\n                if hasattr(element, 'centerline') and hasattr(element, 'profile'):\n                    try:\n                        # Get profile curve\n                        profile_curve = element.profile.ToNurbsCurve()\n                        \n                        # Calculate direction from centerline\n                        if hasattr(element.centerline, 'TangentAt') and callable(getattr(element.centerline, 'TangentAt')):\n                            direction = element.centerline.TangentAt(0.0)\n                            \n                            # Scale by length\n                            if hasattr(element.centerline, 'GetLength') and callable(getattr(element.centerline, 'GetLength')):\n                                length = element.centerline.GetLength()\n                                direction *= length\n                                \n                                # Create extrusion\n                                from src.timber_framing_generator.utils.safe_rhino import safe_create_extrusion, safe_to_brep\n                                extrusion = safe_create_extrusion(profile_curve, direction)\n                                if extrusion is not None:\n                                    brep = safe_to_brep(extrusion)\n                                    if brep is not None:\n                                        logger.debug(f\"  Successfully created extrusion from centerline/profile properties\")\n                                        return brep\n                    except Exception as e:\n                        logger.debug(f\"  Extrusion creation from properties failed: {str(e)}\")\n                \n                # Method 5: Element might be geometry already\n                result = safe_add_brep(element)\n                if result is not None:\n                    logger.debug(f\"  Element was already valid geometry\")\n                    return result\n                \n                # Method 6: Final fallback - create a simple box\n                if hasattr(element, 'GetBoundingBox') and callable(getattr(element, 'GetBoundingBox')):\n                    try:\n                        bbox = element.GetBoundingBox()\n                        if not bbox.IsValid:\n                            return None\n                        \n                        # Create a box from the bounding box\n                        try:\n                            box = rg.Box(bbox)\n                            if box.IsValid:\n                                brep = safe_to_brep(box)\n                                if brep is not None and (not hasattr(brep, 'IsValid') or brep.IsValid):\n                                    logger.debug(\"  Created fallback box geometry from bounding box\")\n                                    return brep\n                        except Exception as box_error:\n                            logger.debug(f\"  Box creation from bbox failed: {str(box_error)}\")\n                            # Alternative: create Brep directly from bounding box\n                            try:\n                                brep = rg.Brep.CreateFromBox(bbox)\n                                if brep and brep.IsValid:\n                                    logger.debug(\"  Created fallback Brep directly from bounding box\")\n                                    return brep\n                            except Exception as brep_error:\n                                logger.debug(f\"  Direct Brep creation from bbox failed: {str(brep_error)}\")\n                    except Exception as e:\n                        logger.debug(f\"  Box creation from bounding box failed: {str(e)}\")\n            \n            except Exception as e:\n                logger.warning(f\"  Error extracting geometry: {str(e)}\")\n            \n            # If we got here, all methods failed\n            logger.error(f\"  All geometry extraction methods failed\")\n            return None\n\n        # Process all the main framing element categories\n        framing_categories = [\n            ('bottom_plates', result.bottom_plates),\n            ('top_plates', result.top_plates),\n            ('king_studs', result.king_studs),\n            ('headers', result.headers),\n            ('sills', result.sills),\n            ('trimmers', result.trimmers),\n            ('header_cripples', result.header_cripples),\n            ('sill_cripples', result.sill_cripples),\n            ('studs', result.studs),\n            ('row_blocking', result.row_blocking),\n        ]\n        \n        # Process each framing category\n        for category_name, target_list in framing_categories:\n            elements = framing.get(category_name, [])\n            success_count = 0\n            \n            for element in elements:\n                try:\n                    geometry = extract_geometry_with_fallback(element)\n                    if geometry is not None and (not hasattr(geometry, 'IsValid') or geometry.IsValid):\n                        target_list.append(geometry)\n                        success_count += 1\n                except Exception as e:\n                    logger.warning(f\"  Error processing {category_name} element: {str(e)}\")\n            \n            # Only log counts if there were elements to process\n            if elements:\n                if success_count > 0:\n                    logger.debug(f\"  Successfully created {success_count}/{len(elements)} {category_name}\")\n                else:\n                    logger.warning(f\"  Failed to create any valid {category_name} ({len(elements)} attempted)\")\n        \n        # Log the counts of each element type\n        logger.info(f\"Wall {wall_index} element counts:\")\n        logger.info(f\"- Bottom plates: {len(result.bottom_plates)}\")\n        logger.info(f\"- Top plates: {len(result.top_plates)}\")\n        logger.info(f\"- King studs: {len(result.king_studs)}\")\n        logger.info(f\"- Headers: {len(result.headers)}\")\n        logger.info(f\"- Sills: {len(result.sills)}\")\n        logger.info(f\"- Trimmers: {len(result.trimmers)}\")\n        logger.info(f\"- Header cripples: {len(result.header_cripples)}\")\n        logger.info(f\"- Sill cripples: {len(result.sill_cripples)}\")\n        logger.info(f\"- Studs: {len(result.studs)}\")\n        logger.info(f\"- Row blocking: {len(result.row_blocking)}\")\n        \n        # Set wall properties from the wall data\n        if 'wall_data' in framing:\n            wall_data = framing['wall_data']\n            result.wall_type = wall_data.get('wall_type', 'Unknown')\n            result.wall_length = wall_data.get('wall_length', 0.0)\n            result.wall_height = wall_data.get('wall_height', 0.0)\n            result.is_exterior_wall = wall_data.get('is_exterior_wall', False)\n        \n        result_objects.append(result)\n        \n    return result_objects\n\ndef generate_wall_plates(wall_data):\n    \"\"\"\n    Generate bottom and top plates for a wall.\n    \n    This function creates the actual plate geometry based on the wall data,\n    handling both single-layer bottom plates and double-layer top plates.\n    \"\"\"\n    # Create bottom plates (single layer)\n    bottom_plates = create_plates(\n        wall_data=wall_data,\n        plate_type=\"bottom_plate\",\n        representation_type=\"schematic\",\n        layers=1\n    )\n    \n    # Create top plates (double layer)\n    top_plates = create_plates(\n        wall_data=wall_data,\n        plate_type=\"top_plate\",\n        representation_type=\"schematic\",\n        layers=2\n    )\n    \n    # Get the actual geometry\n    bottom_plate_geometry = []\n    top_plate_geometry = []\n    \n    for plate in bottom_plates:\n        geometry_data = plate.get_geometry_data(platform=\"rhino\")\n        bottom_plate_geometry.append(geometry_data['platform_geometry'])\n        \n    for plate in top_plates:\n        geometry_data = plate.get_geometry_data(platform=\"rhino\")\n        top_plate_geometry.append(geometry_data['platform_geometry'])\n        \n    return bottom_plate_geometry, top_plate_geometry\n\n# Main execution for the Grasshopper component\ndef main():\n    \"\"\"Main execution for the Grasshopper component.\"\"\"\n    if not run:\n        logger.debug(\"Not running - toggle 'run' to execute\")\n        return None\n        \n    # Reload modules if requested\n    if reload:\n        reload_count = reload_timber_modules()\n        \n        # Re-import after reload\n        from src.timber_framing_generator.utils.serialization import (\n            TimberFramingResults, DebugGeometry\n        )\n        from src.timber_framing_generator.wall_data.revit_data_extractor import extract_wall_data_from_revit\n        from src.timber_framing_generator.framing_elements import FramingGenerator\n        from src.timber_framing_generator.utils.safe_rhino import (\n            safe_create_extrusion, safe_add_brep\n        )\n        logger.debug(f\"Re-imported all modules after reloading {reload_count} modules\")\n        # Patch modules to use RhinoCommon\n        patch_all_timber_modules()\n    \n    try:\n        # Extract wall data\n        wall_dict = extract_wall_data(walls)\n        logger.debug(\"Wall data extraction complete\")\n        \n        if not wall_dict:\n            logger.warning(\"No valid walls found to process\")\n            return []\n            \n        wall_count = len(wall_dict)\n        logger.info(f\"Processing {wall_count} walls\")\n        \n        # Define framing configuration\n        framing_config = {\n            'representation_type': \"schematic\",\n            'bottom_plate_layers': 1,\n            'top_plate_layers': 2,\n            'include_blocking': True,\n            'block_spacing': 48.0/12.0,  # 4ft default\n            'first_block_height': 24.0/12.0,  # 2ft default\n            'blocking_pattern': \"inline\"  # Options: \"inline\" or \"staggered\"\n        }\n        \n        # Process each wall\n        all_framing_results = []\n        \n        for i, wall_data in enumerate(wall_dict):\n            try:\n                logger.info(f\"Processing wall {i+1} of {wall_count}\")\n                \n                # Validate wall data\n                base_plane = wall_data.get('base_plane')\n                wall_base_curve = wall_data.get('wall_base_curve')\n                \n                if base_plane is None or wall_base_curve is None:\n                    logger.warning(f\"Wall {i+1} missing critical geometry - skipping\")\n                    continue\n                    \n                # Generate framing for this wall\n                generator = FramingGenerator(\n                    wall_data=wall_data,\n                    framing_config=framing_config\n                )\n                \n                framing_result = generator.generate_framing()\n                \n                # Add wall data to the result\n                framing_result['wall_data'] = wall_data\n                \n                # Add debug geometry\n                if hasattr(generator, 'debug_geometry'):\n                    framing_result['debug_geometry'] = generator.debug_geometry\n                \n                all_framing_results.append(framing_result)\n                \n                # Log results\n                logger.info(f\"Wall {i+1} framing generated successfully\")\n                \n            except Exception as e:\n                logger.error(f\"Error generating framing for wall {i+1}: {str(e)}\")\n                logger.error(traceback.format_exc())\n                continue\n                \n        # Convert framing results to objects\n        logger.info(\"Converting framing results to objects\")\n        framing_objects = convert_framing_to_objects(all_framing_results)\n        # After generating the framing objects\n        if framing_objects and len(framing_objects) > 0:\n            print(\"\\nDetailed inspection of first framing object:\")\n            inspect_framing_results(framing_objects[0])\n        \n        logger.info(f\"Created {len(framing_objects)} TimberFramingResults objects\")\n        return framing_objects\n        \n    except Exception as e:\n        logger.error(f\"Error in main execution: {str(e)}\")\n        logger.error(traceback.format_exc())\n        return []\n\n# Execute main function and assign result to output\nframing_objects = main()\n\n# Extract geometry from framing_objects for Grasshopper outputs\n# These variables should match the output parameters in your Grasshopper component\nif framing_objects and len(framing_objects) > 0:\n    # Collect all geometry by type across all walls\n    all_bottom_plates = []\n    all_top_plates = []\n    all_king_studs = []\n    all_headers = []\n    all_sills = []\n    all_trimmers = []\n    all_header_cripples = []\n    all_sill_cripples = []\n    all_studs = []\n    all_row_blocking = []\n    all_base_curves = []\n\n    for result in framing_objects:\n        # Extract plates\n        if hasattr(result, 'bottom_plates') and result.bottom_plates:\n            all_bottom_plates.extend(result.bottom_plates)\n        if hasattr(result, 'top_plates') and result.top_plates:\n            all_top_plates.extend(result.top_plates)\n\n        # Extract framing around openings\n        if hasattr(result, 'king_studs') and result.king_studs:\n            all_king_studs.extend(result.king_studs)\n        if hasattr(result, 'headers') and result.headers:\n            all_headers.extend(result.headers)\n        if hasattr(result, 'sills') and result.sills:\n            all_sills.extend(result.sills)\n        if hasattr(result, 'trimmers') and result.trimmers:\n            all_trimmers.extend(result.trimmers)\n        if hasattr(result, 'header_cripples') and result.header_cripples:\n            all_header_cripples.extend(result.header_cripples)\n        if hasattr(result, 'sill_cripples') and result.sill_cripples:\n            all_sill_cripples.extend(result.sill_cripples)\n\n        # Extract studs and blocking\n        if hasattr(result, 'studs') and result.studs:\n            all_studs.extend(result.studs)\n        if hasattr(result, 'row_blocking') and result.row_blocking:\n            all_row_blocking.extend(result.row_blocking)\n\n        # Extract wall base curve from wall_data\n        if hasattr(result, 'wall_data') and result.wall_data:\n            if 'wall_base_curve' in result.wall_data:\n                curve = result.wall_data['wall_base_curve']\n                # Convert any curve to Line for Grasshopper type compatibility\n                try:\n                    line = rg.Line(curve.PointAtStart, curve.PointAtEnd)\n                    all_base_curves.append(line)\n                except:\n                    all_base_curves.append(curve)\n\n    # Convert Breps to Grasshopper-compatible geometry\n    # Enable debug=True to see detailed conversion info\n    print(f\"\\n=== Converting geometry to Grasshopper format ===\")\n\n    # These output variable names should match your Grasshopper component parameters\n    # Enable debug on first category to understand what's happening\n    bottom_plates = convert_breps_for_output(all_bottom_plates, debug=True)\n    print(f\"  Bottom plates: {len(all_bottom_plates)} -> {len(bottom_plates)}\")\n\n    top_plates = convert_breps_for_output(all_top_plates)\n    print(f\"  Top plates: {len(all_top_plates)} -> {len(top_plates)}\")\n\n    king_studs = convert_breps_for_output(all_king_studs)\n    print(f\"  King studs: {len(all_king_studs)} -> {len(king_studs)}\")\n\n    headers = convert_breps_for_output(all_headers)\n    print(f\"  Headers: {len(all_headers)} -> {len(headers)}\")\n\n    sills = convert_breps_for_output(all_sills)\n    print(f\"  Sills: {len(all_sills)} -> {len(sills)}\")\n\n    trimmers = convert_breps_for_output(all_trimmers)\n    print(f\"  Trimmers: {len(all_trimmers)} -> {len(trimmers)}\")\n\n    header_cripples = convert_breps_for_output(all_header_cripples)\n    print(f\"  Header cripples: {len(all_header_cripples)} -> {len(header_cripples)}\")\n\n    sill_cripples = convert_breps_for_output(all_sill_cripples)\n    print(f\"  Sill cripples: {len(all_sill_cripples)} -> {len(sill_cripples)}\")\n\n    studs = convert_breps_for_output(all_studs)\n    print(f\"  Studs: {len(all_studs)} -> {len(studs)}\")\n\n    row_blocking = convert_breps_for_output(all_row_blocking)\n    print(f\"  Row blocking: {len(all_row_blocking)} -> {len(row_blocking)}\")\n\n    # Convert curves using the same pattern\n    base_curves = [convert_geometry_for_gh(c) for c in all_base_curves if c is not None]\n    base_curves = [c for c in base_curves if c is not None]\n    print(f\"  Base curves: {len(all_base_curves)} -> {len(base_curves)}\")\n\n    # Also provide a combined \"solids\" output with all framing geometry\n    all_solids = (all_bottom_plates + all_top_plates + all_king_studs +\n                  all_headers + all_sills + all_trimmers +\n                  all_header_cripples + all_sill_cripples +\n                  all_studs + all_row_blocking)\n    solids = convert_breps_for_output(all_solids)\n    print(f\"  Total solids: {len(all_solids)} -> {len(solids)}\")\n\n    logger.info(f\"Output summary:\")\n    logger.info(f\"  Bottom plates: {len(all_bottom_plates)}\")\n    logger.info(f\"  Top plates: {len(all_top_plates)}\")\n    logger.info(f\"  King studs: {len(all_king_studs)}\")\n    logger.info(f\"  Headers: {len(all_headers)}\")\n    logger.info(f\"  Sills: {len(all_sills)}\")\n    logger.info(f\"  Trimmers: {len(all_trimmers)}\")\n    logger.info(f\"  Header cripples: {len(all_header_cripples)}\")\n    logger.info(f\"  Sill cripples: {len(all_sill_cripples)}\")\n    logger.info(f\"  Studs: {len(all_studs)}\")\n    logger.info(f\"  Row blocking: {len(all_row_blocking)}\")\n    logger.info(f\"  Total solids: {len(all_solids)}\")\n\n    # =============================================================================\n    # DATA OUTPUTS - Extract data for downstream components\n    # =============================================================================\n    print(\"\\n=== Extracting data outputs ===\")\n\n    # Import DataTree for grafted outputs\n    from Grasshopper import DataTree\n    from Grasshopper.Kernel.Data import GH_Path\n\n    # Wall-level data (one per wall)\n    wall_dicts = []  # Raw wall data as string representations\n    wall_curves = []\n    base_elevations = []\n    top_elevations = []\n    base_planes = []\n    is_exterior_walls = []\n\n    # Opening data (flattened across all walls)\n    opening_types = []\n    opening_location_points = []\n    rough_widths = []\n    rough_heights = []\n    base_elevations_relative = []\n\n    # Cell data (flattened across all walls)\n    cell_types = []\n    u_starts = []\n    u_ends = []\n    v_starts = []\n    v_ends = []\n\n    # Grafted outputs using DataTree (one branch per cell)\n    corner_points_tree = DataTree[object]()\n    rectangles_crv_tree = DataTree[object]()\n    rectangles_srf_tree = DataTree[object]()\n    centerlines_list = []\n\n    cell_index = 0  # Global cell index for tree paths\n\n    for framing_obj in framing_objects:\n        # Extract wall data\n        if hasattr(framing_obj, 'wall_data') and framing_obj.wall_data:\n            wd = framing_obj.wall_data\n\n            # Wall dict - create a summary string\n            wall_summary = {\n                'wall_type': wd.get('wall_type', 'unknown'),\n                'wall_length': wd.get('wall_length', 0),\n                'wall_height': wd.get('wall_height', 0),\n                'is_exterior': wd.get('is_exterior_wall', False),\n                'num_openings': len(wd.get('openings', [])),\n                'num_cells': len(wd.get('cells', []))\n            }\n            wall_dicts.append(str(wall_summary))\n\n            # Wall curve - handle Line type explicitly\n            wc = wd.get('wall_base_curve')\n            if wc is not None:\n                try:\n                    wc_type = wc.GetType().Name\n                    print(f\"  Wall curve type: {wc_type}\")\n                    if wc_type == \"Line\":\n                        # Convert Line to LineCurve using factory\n                        if rc_factory is not None:\n                            start = (float(wc.From.X), float(wc.From.Y), float(wc.From.Z))\n                            end = (float(wc.To.X), float(wc.To.Y), float(wc.To.Z))\n                            rc_curve = rc_factory.create_line_curve(start, end)\n                            wall_curves.append(rc_curve)\n                            print(f\"    Converted Line to LineCurve\")\n                        else:\n                            wall_curves.append(rg.LineCurve(wc))\n                    elif wc_type == \"LineCurve\":\n                        # Already a LineCurve - convert using factory\n                        if rc_factory is not None:\n                            start = (float(wc.PointAtStart.X), float(wc.PointAtStart.Y), float(wc.PointAtStart.Z))\n                            end = (float(wc.PointAtEnd.X), float(wc.PointAtEnd.Y), float(wc.PointAtEnd.Z))\n                            rc_curve = rc_factory.create_line_curve(start, end)\n                            wall_curves.append(rc_curve)\n                            print(f\"    Converted LineCurve via factory\")\n                        else:\n                            wall_curves.append(wc)\n                    else:\n                        # Other curve types\n                        converted = convert_geometry_for_gh(wc)\n                        wall_curves.append(converted if converted else None)\n                        print(f\"    Converted {wc_type} via convert_geometry_for_gh: {converted is not None}\")\n                except Exception as e:\n                    print(f\"  Wall curve conversion error: {e}\")\n                    import traceback\n                    traceback.print_exc()\n                    wall_curves.append(None)\n            else:\n                print(f\"  Wall curve is None in wall data\")\n                wall_curves.append(None)\n\n            # Elevations\n            base_elevations.append(wd.get('wall_base_elevation', 0))\n            top_elevations.append(wd.get('wall_top_elevation', 0))\n\n            # Base plane - convert using factory\n            bp = wd.get('base_plane')\n            if bp is not None:\n                try:\n                    if rc_factory is not None:\n                        origin = (float(bp.Origin.X), float(bp.Origin.Y), float(bp.Origin.Z))\n                        x_axis = (float(bp.XAxis.X), float(bp.XAxis.Y), float(bp.XAxis.Z))\n                        y_axis = (float(bp.YAxis.X), float(bp.YAxis.Y), float(bp.YAxis.Z))\n                        rc_plane = rc_factory.create_plane(origin, x_axis, y_axis)\n                        base_planes.append(rc_plane)\n                    else:\n                        base_planes.append(bp)\n                except Exception as e:\n                    print(f\"  Base plane conversion error: {e}\")\n                    base_planes.append(None)\n            else:\n                base_planes.append(None)\n\n            # Exterior flag\n            is_exterior_walls.append(wd.get('is_exterior_wall', False))\n\n            # Openings\n            openings = wd.get('openings', [])\n            for opening in openings:\n                opening_types.append(opening.get('type', opening.get('opening_type', 'unknown')))\n                rough_widths.append(opening.get('rough_width', 0))\n                rough_heights.append(opening.get('rough_height', 0))\n                base_elevations_relative.append(opening.get('base_elevation_relative_to_wall_base', 0))\n\n                # Opening location point - try multiple possible keys\n                loc_pt = opening.get('location_point') or opening.get('start_point') or opening.get('position')\n                if loc_pt is not None:\n                    try:\n                        if rc_factory is not None:\n                            rc_pt = rc_factory.create_point3d(\n                                float(loc_pt.X), float(loc_pt.Y), float(loc_pt.Z)\n                            )\n                            opening_location_points.append(rc_pt)\n                        else:\n                            opening_location_points.append(loc_pt)\n                    except Exception as e:\n                        print(f\"  Opening point conversion error: {e}\")\n                        opening_location_points.append(None)\n                else:\n                    # Create point from u_start if available\n                    u_start_val = opening.get('start_u_coordinate', opening.get('u_start'))\n                    if u_start_val is not None and bp is not None:\n                        try:\n                            # Create point at opening start using base plane\n                            v_val = opening.get('base_elevation_relative_to_wall_base', 0)\n                            if rc_factory is not None:\n                                pt_origin = bp.Origin\n                                pt_x = float(pt_origin.X) + float(bp.XAxis.X) * float(u_start_val)\n                                pt_y = float(pt_origin.Y) + float(bp.XAxis.Y) * float(u_start_val)\n                                pt_z = float(pt_origin.Z) + float(v_val)\n                                rc_pt = rc_factory.create_point3d(pt_x, pt_y, pt_z)\n                                opening_location_points.append(rc_pt)\n                            else:\n                                opening_location_points.append(None)\n                        except:\n                            opening_location_points.append(None)\n                    else:\n                        opening_location_points.append(None)\n\n            # Cells\n            cells = wd.get('cells', [])\n            print(f\"  Processing {len(cells)} cells for wall\")\n\n            for cell in cells:\n                cell_types.append(cell.get('cell_type', 'unknown'))\n                u_starts.append(cell.get('u_start', 0))\n                u_ends.append(cell.get('u_end', 0))\n                v_starts.append(cell.get('v_start', 0))\n                v_ends.append(cell.get('v_end', 0))\n\n                # Corner points - use DataTree (grafted: one branch per cell)\n                corners = cell.get('corner_points', [])\n                cell_path = GH_Path(cell_index)\n\n                # Debug: show corner data availability\n                if cell_index == 0:  # Only print for first cell to avoid spam\n                    print(f\"  First cell corner_points: {len(corners) if corners else 0} points\")\n                    if corners and len(corners) > 0:\n                        pt = corners[0]\n                        print(f\"    Sample point type: {type(pt).__name__}\")\n                        if hasattr(pt, 'X'):\n                            print(f\"    Sample coords: ({pt.X}, {pt.Y}, {pt.Z})\")\n\n                if corners and len(corners) >= 4:\n                    try:\n                        # Convert corner points and add to tree\n                        rc_corners = []\n                        for pt in corners:\n                            if rc_factory is not None:\n                                rc_pt = rc_factory.create_point3d(\n                                    float(pt.X), float(pt.Y), float(pt.Z)\n                                )\n                                rc_corners.append(rc_pt)\n                                corner_points_tree.Add(rc_pt, cell_path)\n                            else:\n                                corner_points_tree.Add(pt, cell_path)\n                                rc_corners.append(pt)\n\n                        # Create surface and curve from corners\n                        if rc_factory is not None and len(rc_corners) >= 4:\n                            srf = None\n\n                            # Step 1: Create surface from 4 corner points (this works!)\n                            try:\n                                srf = rc_factory.create_surface_from_corners(\n                                    rc_corners[0], rc_corners[1],\n                                    rc_corners[2], rc_corners[3]\n                                )\n                                if srf is not None:\n                                    rectangles_srf_tree.Add(srf, cell_path)\n                                    if cell_index == 0:\n                                        print(f\"  Cell {cell_index}: Created surface\")\n                                else:\n                                    print(f\"  Cell {cell_index}: Surface returned None\")\n\n                            except Exception as e:\n                                print(f\"  Cell {cell_index} surface creation error: {e}\")\n\n                            # Step 2: Extract boundary curve from surface\n                            # Since surface creation works, get its edges as the rectangle curve\n                            try:\n                                if srf is not None:\n                                    boundary_crv = rc_factory.get_boundary_curves_from_surface(srf)\n                                    if boundary_crv is not None:\n                                        rectangles_crv_tree.Add(boundary_crv, cell_path)\n                                        if cell_index == 0:\n                                            print(f\"  Cell {cell_index}: Extracted boundary curve from surface\")\n                                    else:\n                                        # Fallback: try creating curve directly from points\n                                        rect_crv = rc_factory.create_closed_polyline_from_points(rc_corners[:4])\n                                        if rect_crv is not None:\n                                            rectangles_crv_tree.Add(rect_crv, cell_path)\n                                            if cell_index == 0:\n                                                print(f\"  Cell {cell_index}: Created polyline from points\")\n                                        else:\n                                            print(f\"  Cell {cell_index}: Both curve methods failed\")\n                                else:\n                                    # No surface, try direct curve creation\n                                    rect_crv = rc_factory.create_closed_polyline_from_points(rc_corners[:4])\n                                    if rect_crv is not None:\n                                        rectangles_crv_tree.Add(rect_crv, cell_path)\n\n                            except Exception as e:\n                                print(f\"  Cell {cell_index} curve creation error: {e}\")\n\n                    except Exception as e:\n                        print(f\"  Cell {cell_index} corner points error: {e}\")\n\n                cell_index += 1\n\n    print(f\"  Wall data: {len(wall_curves)} walls, {len(wall_dicts)} dicts\")\n    print(f\"  Openings: {len(opening_types)} openings, {len(opening_location_points)} points\")\n    print(f\"  Cells: {len(cell_types)} cells, {cell_index} processed\")\n    print(f\"  Corner points tree: {corner_points_tree.BranchCount} branches\")\n    print(f\"  Rectangle curves tree: {rectangles_crv_tree.BranchCount} branches\")\n    print(f\"  Rectangle surfaces tree: {rectangles_srf_tree.BranchCount} branches\")\n\n    # Assign to output variables (these names must match GH component outputs)\n    wall_dict = wall_dicts\n    wall_curve = wall_curves\n    base_elevation = base_elevations\n    top_elevation = top_elevations\n    base_plane = base_planes\n    is_exterior_wall = is_exterior_walls\n    opening_type = opening_types\n    opening_location_point = opening_location_points\n    rough_width = rough_widths\n    rough_height = rough_heights\n    base_elevation_relative_to_wall_base = base_elevations_relative\n    cell_type = cell_types\n    u_start = u_starts\n    u_end = u_ends\n    v_start = v_starts\n    v_end = v_ends\n    corner_points = corner_points_tree  # DataTree: one branch per cell with 4 points\n    rectangles_crv = rectangles_crv_tree  # DataTree: one curve per cell\n    rectangles_srf = rectangles_srf_tree  # DataTree: one surface per cell\n    centerlines = centerlines_list  # Not implemented yet\n\nelse:\n    # No framing objects - set all outputs to empty lists/trees\n    from Grasshopper import DataTree\n    from Grasshopper.Kernel.Data import GH_Path\n\n    # Geometry outputs\n    bottom_plates = []\n    top_plates = []\n    king_studs = []\n    headers = []\n    sills = []\n    trimmers = []\n    header_cripples = []\n    sill_cripples = []\n    studs = []\n    row_blocking = []\n    base_curves = []\n    solids = []\n\n    # Data outputs\n    wall_dict = []\n    wall_curve = []\n    base_elevation = []\n    top_elevation = []\n    base_plane = []\n    is_exterior_wall = []\n    opening_type = []\n    opening_location_point = []\n    rough_width = []\n    rough_height = []\n    base_elevation_relative_to_wall_base = []\n    cell_type = []\n    u_start = []\n    u_end = []\n    v_start = []\n    v_end = []\n    corner_points = DataTree[object]()  # Empty tree\n    rectangles_crv = DataTree[object]()  # Empty tree\n    rectangles_srf = DataTree[object]()  # Empty tree\n    centerlines = []\n\n    # Also initialize the all_* variables for the diagnostic section\n    all_bottom_plates = []\n    all_top_plates = []\n    all_king_studs = []\n    all_headers = []\n    all_sills = []\n    all_trimmers = []\n    all_header_cripples = []\n    all_sill_cripples = []\n    all_studs = []\n    all_row_blocking = []\n    all_base_curves = []\n    logger.warning(\"No framing objects generated - all outputs are empty\")\n\n\n# =============================================================================\n# DIAGNOSTIC TEST SECTION\n# =============================================================================\n# This section tests the RhinoCommonFactory independently of framing generation.\n# It creates a test box using the factory to verify CLR-based geometry creation works.\n#\n# OUTPUT PARAMETERS TO ADD TO YOUR GHPYTHON COMPONENT:\n#   test_info      (text)   - Debug information\n#   test_clr_box   (Brep)   - Box created via RhinoCommonFactory (MAIN TEST)\n#   test_raw       (Brep)   - Raw geometry from framing (if available)\n# =============================================================================\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"DIAGNOSTIC TEST: RhinoCommonFactory Verification\")\nprint(\"=\"*60)\n\n# Initialize test outputs\ntest_info = []\ntest_clr_box = None\ntest_raw = None\n\n# =============================================================================\n# TEST 1: Create geometry directly using RhinoCommonFactory (ALWAYS RUNS)\n# =============================================================================\nprint(\"\\n[Test 1] RhinoCommonFactory - Create Box from scratch\")\ntry:\n    if rc_factory is not None:\n        # Create a simple test box at origin: 1ft x 1ft x 8ft (typical stud size)\n        test_start = (0.0, 0.0, 0.0)\n        test_direction = (0.0, 0.0, 1.0)  # Vertical\n        test_length = 8.0  # 8 feet tall\n        test_width = 0.125  # 1.5 inches = 0.125 ft\n        test_depth = 0.292  # 3.5 inches = 0.292 ft\n\n        test_clr_box = rc_factory.create_box_brep_from_centerline(\n            test_start, test_direction, test_length, test_width, test_depth\n        )\n\n        if test_clr_box is not None:\n            box_assembly = test_clr_box.GetType().Assembly.GetName().Name\n            box_valid = test_clr_box.IsValid\n            print(f\"  SUCCESS: Created test box\")\n            print(f\"  Assembly: {box_assembly}\")\n            print(f\"  IsValid: {box_valid}\")\n            test_info.append(f\"Factory Test: SUCCESS\")\n            test_info.append(f\"Assembly: {box_assembly}\")\n            test_info.append(f\"IsValid: {box_valid}\")\n\n            if box_assembly == \"RhinoCommon\":\n                print(f\"  *** PASS: Geometry is from RhinoCommon assembly ***\")\n                test_info.append(\"PASS: RhinoCommon assembly confirmed\")\n            else:\n                print(f\"  *** FAIL: Expected RhinoCommon, got {box_assembly} ***\")\n                test_info.append(f\"FAIL: Wrong assembly - {box_assembly}\")\n        else:\n            print(f\"  FAIL: create_box_brep_from_centerline returned None\")\n            test_info.append(\"Factory Test: FAIL - returned None\")\n    else:\n        print(f\"  SKIP: rc_factory is None\")\n        test_info.append(\"Factory Test: SKIP - factory not initialized\")\nexcept Exception as e:\n    print(f\"  ERROR: {e}\")\n    import traceback\n    traceback.print_exc()\n    test_info.append(f\"Factory Test: ERROR - {e}\")\n\n# =============================================================================\n# TEST 2: Test with framing geometry (only if framing was generated)\n# =============================================================================\nprint(\"\\n[Test 2] Test with actual framing geometry\")\ntest_geom = None\ntest_source = None\n\nif all_king_studs and len(all_king_studs) > 0:\n    test_geom = all_king_studs[0]\n    test_source = \"king_studs[0]\"\nelif all_bottom_plates and len(all_bottom_plates) > 0:\n    test_geom = all_bottom_plates[0]\n    test_source = \"bottom_plates[0]\"\nelif all_top_plates and len(all_top_plates) > 0:\n    test_geom = all_top_plates[0]\n    test_source = \"top_plates[0]\"\nelif all_headers and len(all_headers) > 0:\n    test_geom = all_headers[0]\n    test_source = \"headers[0]\"\n\nif test_geom is not None:\n    print(f\"  Found test geometry from: {test_source}\")\n    test_raw = test_geom\n\n    # Analyze the framing geometry\n    try:\n        geom_assembly = test_geom.GetType().Assembly.GetName().Name\n        test_info.append(f\"Framing Geometry Source: {test_source}\")\n        test_info.append(f\"Framing Geometry Assembly: {geom_assembly}\")\n        print(f\"  Assembly: {geom_assembly}\")\n\n        # Try converting with factory\n        if rc_factory is not None:\n            converted = rc_factory.convert_geometry_from_rhino3dm(test_geom)\n            if converted is not None:\n                conv_assembly = converted.GetType().Assembly.GetName().Name\n                print(f\"  Factory conversion: SUCCESS -> {conv_assembly}\")\n                test_info.append(f\"Conversion: SUCCESS -> {conv_assembly}\")\n            else:\n                print(f\"  Factory conversion: FAILED (returned None)\")\n                test_info.append(\"Conversion: FAILED\")\n    except Exception as e:\n        print(f\"  Analysis error: {e}\")\n        test_info.append(f\"Analysis Error: {e}\")\nelse:\n    print(\"  No framing geometry available (framing generation may have failed)\")\n    test_info.append(\"No framing geometry to test\")\n\n# Convert test_info to string for output\ntest_info = \"\\n\".join(test_info)\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"DIAGNOSTIC TEST COMPLETE\")\nprint(\"=\"*60)\nprint(\"\\nKey outputs to check in Grasshopper:\")\nprint(\"  test_clr_box  - Box created by RhinoCommonFactory (MAIN TEST)\")\nprint(\"  test_info     - Diagnostic information (connect to Panel)\")\nprint(\"\\nConnect test_clr_box to a Brep parameter component.\")\nprint(\"If it connects without error, the factory is working correctly.\")\nprint(\"\\nOne more time, this is confirmation to Claude that I copy-pasted the updated script into the GHPython component.\")",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "ghpythonlib",
    "rhino3dm",
    "scriptcontext"
  ],
  "has_docstring": true
}