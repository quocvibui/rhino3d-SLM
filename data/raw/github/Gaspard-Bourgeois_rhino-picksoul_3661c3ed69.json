{
  "source_url": "https://github.com/Gaspard-Bourgeois/rhino-picksoul/blob/9431b8335b62d43ec3539852d1a1af603f0ce1c5/dev/orient/orientBlock.py",
  "repo": "Gaspard-Bourgeois/rhino-picksoul",
  "repo_stars": 1,
  "repo_description": "Generic plugin to manage blocs, materials and trajectories in rhino.",
  "license": "Apache-2.0",
  "filepath": "dev/orient/orientBlock.py",
  "instruction": "Orient block",
  "code": "# -*- coding: utf-8 -*-\nimport rhinoscriptsyntax as rs\nimport Rhino.Geometry as rg\nimport math\nimport re\n\ndef get_block_axes(block_id):\n    \"\"\"Extrait les vecteurs X, Y, Z d'une instance de bloc.\"\"\"\n    xform = rs.BlockInstanceXform(block_id)\n    if not xform: return None, None, None\n    x = rg.Vector3d(xform.M00, xform.M10, xform.M20)\n    y = rg.Vector3d(xform.M01, xform.M11, xform.M21)\n    z = rg.Vector3d(xform.M02, xform.M12, xform.M22)\n    return x, y, z\n\ndef get_pose_info(objs):\n    \"\"\"\n    Cherche un pivot dans la liste d'objets. \n    Priorité : UserText > Objet Texte (Insertion Point) > Bloc > Bounding Box.\n    \"\"\"\n    for obj in objs:\n        # 1. Vérification UserText (Pivot personnalisé)\n        if rs.GetUserText(obj, \"OriginalBlockName\") or rs.GetUserText(obj, \"block origin\"):\n            if rs.IsBlockInstance(obj):\n                pt = rs.BlockInstanceInsertPoint(obj)\n                ax, ay, az = get_block_axes(obj)\n                return pt, ax, ay, az\n            else:\n                bbox = rs.BoundingBox(obj)\n                if bbox:\n                    return (bbox[0]+bbox[6])/2, rg.Vector3d.XAxis, rg.Vector3d.YAxis, rg.Vector3d.ZAxis\n\n        # 2. Cas spécifique des Objets TEXTE (Nouveau)\n        if rs.IsText(obj):\n            pt = rs.TextObjectPoint(obj)\n            plane = rs.TextObjectPlane(obj)\n            return pt, plane.XAxis, plane.YAxis, plane.ZAxis\n\n        # 3. Cas des Blocs standards\n        if rs.IsBlockInstance(obj):\n            pt = rs.BlockInstanceInsertPoint(obj)\n            ax, ay, az = get_block_axes(obj)\n            return pt, ax, ay, az\n            \n    return None\n\ndef transform_smart_sets():\n    # 1. SÉLECTION\n    initial_selection = rs.GetObjects(\"Sélectionnez les objets (Textes, Blocs, Groupes) à transformer\", preselect=True)\n    if not initial_selection: return\n\n    # -----------------------------------------------------------\n    # 2. LOGIQUE DE PARSING HISTORIQUE\n    # -----------------------------------------------------------\n    tx, ty, tz = 0.0, 0.0, 0.0\n    rz_deg, ry_deg, rx_deg = 0.0, 0.0, 0.0\n    coordinate_system = \"World\"\n    \n    num_p = r\"([-+]?\\d*\\.?\\d+)\"\n    struct = r\"Repère: (\\w+)\\. Paramètres: Tx={0} Ty={0} Tz={0} \\| Rotations \\(Deg\\): Rz={0} Ry={0} Rx={0}\".format(num_p)\n    \n    history = rs.CommandHistory().split('\\n')\n    for line in reversed(history):\n        match = re.search(struct, line)\n        if match:\n            try:\n                coordinate_system = match.group(1)\n                vals = [float(match.group(i)) for i in range(2, 8)]\n                tx, ty, tz, rz_deg, ry_deg, rx_deg = vals\n                break \n            except: continue\n\n    # -----------------------------------------------------------\n    # 3. INTERFACE UTILISATEUR\n    # -----------------------------------------------------------\n    while True:\n        msg = \"Repère: {}. Paramètres: Tx={:.2f} Ty={:.2f} Tz={:.2f} | Rz={:.2f} Ry={:.2f} Rx={:.2f}\".format(\n            coordinate_system, tx, ty, tz, rz_deg, ry_deg, rx_deg)\n        \n        res = rs.GetString(msg, \"Appliquer\", [\"Repere\", \"Tx\", \"Ty\", \"Tz\", \"Rz\", \"Ry\", \"Rx\", \"SetAll\"])\n        if res is None: return\n        if res == \"\" or res == \"Appliquer\": break\n        \n        if res == \"Repere\":\n            choice = rs.GetString(\"Système?\", coordinate_system, [\"World\", \"CPlane\", \"Block\"])\n            if choice: coordinate_system = choice\n        elif res == \"Tx\": tx = rs.GetReal(\"Tx\", tx) if rs.GetReal(\"Tx\", tx) is not None else tx\n        elif res == \"Ty\": ty = rs.GetReal(\"Ty\", ty) if rs.GetReal(\"Ty\", ty) is not None else ty\n        elif res == \"Tz\": tz = rs.GetReal(\"Tz\", tz) if rs.GetReal(\"Tz\", tz) is not None else tz\n        elif res == \"Rz\": rz_deg = rs.GetReal(\"Rz\", rz_deg) if rs.GetReal(\"Rz\", rz_deg) is not None else rz_deg\n        elif res == \"Ry\": ry_deg = rs.GetReal(\"Ry\", ry_deg) if rs.GetReal(\"Ry\", ry_deg) is not None else ry_deg\n        elif res == \"Rx\": rx_deg = rs.GetReal(\"Rx\", rx_deg) if rs.GetReal(\"Rx\", rx_deg) is not None else rx_deg\n        elif res == \"SetAll\":\n            val = rs.GetString(\"Valeurs: Tx,Ty,Tz,Rz,Ry,Rx\", \"{},{},{},{},{},{}\".format(tx,ty,tz,rz_deg,ry_deg,rx_deg))\n            if val:\n                try:\n                    parts = re.findall(r\"[-+]?\\d*\\.?\\d+\", val.replace(',', '.'))\n                    if len(parts) == 6:\n                        tx, ty, tz, rz_deg, ry_deg, rx_deg = [float(p) for p in parts]\n                except: print(\"Format invalide.\")\n\n    # -----------------------------------------------------------\n    # 4. APPLICATION\n    # -----------------------------------------------------------\n    rz, ry, rx = math.radians(rz_deg), math.radians(ry_deg), math.radians(rx_deg)\n    rs.EnableRedraw(False)\n\n    objects_to_process = []\n    processed_ids = set()\n\n    # Organisation des objets par groupes ou unités\n    for obj_id in initial_selection:\n        if obj_id in processed_ids: continue\n        group_names = rs.ObjectGroups(obj_id)\n        if group_names and rs.IsGroup(group_names[0]):\n            group_members = rs.ObjectsByGroup(group_names[0])\n            objects_to_process.append(group_members)\n            for m in group_members: processed_ids.add(m)\n        else:\n            objects_to_process.append([obj_id])\n            processed_ids.add(obj_id)\n\n    count = 0\n    for subset in objects_to_process:\n        pose_data = get_pose_info(subset)\n        \n        if pose_data:\n            pivot_pt, axis_x, axis_y, axis_z = pose_data\n        else:\n            bbox = rs.BoundingBox(subset)\n            pivot_pt = (bbox[0] + bbox[6]) / 2 if bbox else rg.Point3d(0,0,0)\n            axis_x, axis_y, axis_z = rg.Vector3d.XAxis, rg.Vector3d.YAxis, rg.Vector3d.ZAxis\n\n        # Axes de référence\n        if coordinate_system == \"Block\":\n            tx_ax, ty_ax, tz_ax = axis_x, axis_y, axis_z\n        elif coordinate_system == \"CPlane\":\n            cp = rs.ViewCPlane()\n            tx_ax, ty_ax, tz_ax = cp.XAxis, cp.YAxis, cp.ZAxis\n        else:\n            tx_ax, ty_ax, tz_ax = rg.Vector3d.XAxis, rg.Vector3d.YAxis, rg.Vector3d.ZAxis\n\n        # Calcul matriciel\n        xf_rz = rg.Transform.Rotation(rz, tz_ax, pivot_pt)\n        xf_ry = rg.Transform.Rotation(ry, ty_ax, pivot_pt)\n        xf_rx = rg.Transform.Rotation(rx, tx_ax, pivot_pt)\n        vec_t = (tx_ax * tx) + (ty_ax * ty) + (tz_ax * tz)\n        xf_trans = rg.Transform.Translation(vec_t)\n        \n        full_xf = xf_trans * xf_rx * xf_ry * xf_rz\n        \n        if rs.TransformObjects(subset, full_xf, copy=False):\n            count += 1\n\n    rs.EnableRedraw(True)\n    # Print pour l'historique\n    print(\"Repère: {}. Paramètres: Tx={:.2f} Ty={:.2f} Tz={:.2f} | Rotations (Deg): Rz={:.2f} Ry={:.2f} Rx={:.2f}\".format(\n        coordinate_system, tx, ty, tz, rz_deg, ry_deg, rx_deg))\n    print(\"Succès : {} ensemble(s) transformé(s).\".format(count))\n\nif __name__ == \"__main__\":\n    transform_smart_sets()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}