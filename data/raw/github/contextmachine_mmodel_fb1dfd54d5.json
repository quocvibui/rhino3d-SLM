{
  "source_url": "https://github.com/contextmachine/mmodel/blob/0545e5c2a11c641fc54e91f603e709d3dea549f3/panels_gh/main.py",
  "repo": "contextmachine/mmodel",
  "repo_stars": 0,
  "repo_description": "Deployment branch",
  "license": "Apache-2.0",
  "filepath": "panels_gh/main.py",
  "instruction": "Provides a scripting component.\n    Inputs:\n        x: The x script variable\n        y: The y script variable\n    Output:\n        a: The a output variable",
  "code": "\"\"\"Provides a scripting component.\n    Inputs:\n        x: The x script variable\n        y: The y script variable\n    Output:\n        a: The a output variable\"\"\"\n\n__author__ = \"sofyadobycina\"\n\ntry:\n    rs = __import__(\"rhinoscriptsyntax\")\nexcept:\n    import rhinoscript as rs\n\nimport imp\nimport math\nimport os\nimport sys\n\nimport Rhino.Geometry as rh\n\nif os.getenv(\"USER\") == \"sofyadobycina\":\n    PWD = os.getenv(\"HOME\") + \"/Documents/GitHub/mmodel/panels_gh\"\n    sys.path.extend([os.getenv(\"HOME\") + \"/Documents/GitHub/mmodel/panels_gh\",\n                     os.getenv(\"HOME\") + \"Documents/GitHub/mmodel/panels_gh/cogs\"])\nelse:\n    PWD = os.getenv(\"MMODEL_DIR\") + \"/panels_gh\"\n    sys.path.extend(\n        [os.getenv(\"MMODEL_DIR\") + \"/panels_gh\", os.getenv(\"MMODEL_DIR\") + \"/panels_gh/cogs\"])\n\ncogsfile, cogsfilename, (cogssuffix, cogsmode, cogstype) = imp.find_module(\"cogs\", path=[PWD])\n# print cogsfile, cogsfilename, (cogssuffix, cogsmode, cogstype)\ncogs = imp.load_module(\"cogs\", cogsfile, cogsfilename, (cogssuffix, cogsmode, cogstype))\nfrom functools import wraps\n\ncogs.__init__(\"cogs\", \"generic nodule\")\n\nfrom cogs import Pattern, TT\n\nreload(cogs)\n\n\ndef morph_decore(fun):\n    @wraps(fun)\n    def wrp(slf, *args, **kwargs):\n        geom = fun(*args, **kwargs)\n        try:\n            for g in geom:\n                if slf.otgib_morph.Morph(g):\n                    continue\n        except:\n            slf.otgib_morph.Morph(geom)\n            return\n\n        return geom\n\n    return wrp\n\n\nclass BendSide(object):\n    side_offset = 0.5\n    angle = 30\n    length = 35\n\n    @property\n    def top_offset(self):\n        self._top_offset = self.length / math.tan(math.radians(self.angle))\n        return self._top_offset\n\n    @property\n    def top_part(self):\n        return self._top_part\n\n    @property\n    def join(self):\n        one = rh.Line(self.fres.PointAtStart, self.top_part.PointAtStart).ToNurbsCurve()\n        two = rh.Line(self.fres.PointAtEnd, self.top_part.PointAtEnd).ToNurbsCurve()\n        self._join = rh.Curve.JoinCurves([one, self.top_part, two])\n        return self._join[0]\n\n    def __init__(self, curve):\n        object.__init__(self)\n        self.fres = self.curve_offset(curve)\n\n    def curve_offset(self, curve):\n        crv = rh.Curve.Offset(curve, rh.Plane.WorldXY, -self.side_offset, 0.01, rh.CurveOffsetCornerStyle.\n                              None)\n        return crv[0]\n\n\nclass Niche(BendSide):\n    side_offset = 0.5\n    cogs_shift = -1.466\n\n    @property\n    def top_part(self):\n        p_one = rh.Curve.LengthParameter(self.fres, self.top_offset)\n        p_two = rh.Curve.LengthParameter(self.fres, self.fres.GetLength() - self.top_offset)\n        trimed = rh.Curve.Trim(self.fres, p_one[1], p_two[1])\n\n        self._top_part = rh.Curve.Offset(trimed, rh.Plane.WorldXY, self.length, 0.01, rh.CurveOffsetCornerStyle.\n                                         None)\n        return self._top_part[0]\n\n    def __init__(self, curve):\n        BendSide.__init__(self, curve)\n        self.hls = None\n        self._cogs = None\n        self._join_brep = None\n\n    @property\n    def bend_axis(self):\n        # type: () -> rh.Line\n        return rh.Line(self.join.PointAtStart, self.join.PointAtEnd)\n\n    @property\n    def join_cp(self):\n        crv = self.bend_surf\n        return crv\n\n    @property\n    def bend_surf(self):\n        # type: () -> rh.NurbsSurface\n\n        return rh.NurbsSurface.CreateRuledSurface(self.top_part, self.bend_axis.ToNurbsCurve())\n\n    @property\n    def cogs(self):\n        return self._cogs\n\n    def generate_cogs(self):\n        _cogs = []\n        cu = self.cogs_unit\n        br = self.join_cp.ToBrep()\n        cr3d = list(br.Curves3D)\n        self.hls = []\n        cnt = []\n        for ii in cu:\n\n            h = self.choles(self, ii)\n            aa = rh.Curve.PlanarClosedCurveRelationship(rh.Curve.JoinCurves(br.Curves3D)[0], h[0], rh.Plane.WorldXY,\n                                                        0.01)\n            bb = rh.Curve.PlanarClosedCurveRelationship(rh.Curve.JoinCurves(br.Curves3D)[0], h[1], rh.Plane.WorldXY,\n                                                        0.01)\n\n            if bb == aa == rh.RegionContainment.BInsideA:\n                self.hls.extend(h)\n                cnt.append(ii.contour)\n\n            else:\n                pass\n\n        _cogs.extend(self.hls[2:-2])\n        ccnt = cnt[0:-1]\n        for cc in ccnt:\n            self.otgib_morph.Morph(cc)\n\n        self._join_brep = br.Faces[0].Split(ccnt, 0.01).GetRegions()[0]\n\n        _cogs.extend(list(self._join_brep.Brep.Faces)[-1].Brep.Edges)\n        self._cogs = _cogs\n\n    @property\n    def cogs_unit(self):\n        # type: () -> Pattern\n\n        return Pattern(self._cg, 23, self.bend_axis.Length)\n\n    @property\n    def otgib_morph(self):\n        # type: () -> rh.SpaceMorph\n        self._morph = rh.Morphs.FlowSpaceMorph(\n            rh.Line(rh.Point3d(0.0, self.cogs_shift, 0.0),\n                    rh.Point3d(self.bend_axis.Length, self.cogs_shift, 0.0)).ToNurbsCurve(),\n            self.bend_axis.ToNurbsCurve(), True, False, True\n        )\n        return self._morph\n\n    @morph_decore\n    def choles(self, geoms):\n        # type: (TT) -> types.ListType[ rh.Curve]\n        return geoms.hole\n\n    @morph_decore\n    def ccontour(self, geoms):\n        return geoms.contour\n\n    @property\n    def join_region(self):\n        # type: () -> rh.CurveBooleanRegions\n\n        # j = rh.Brep.JoinBreps(rh.Brep.CreatePlanarBreps(cg, 0.1), 0.1)\n\n        # brps = self.join_cp.Split(j, 0.1)\n\n        # brep_regions = brps\n        l = list(self._join_brep.Brep.Faces)\n        l.sort(key=lambda t: rh.AreaMassProperties.Compute(t).Area, reverse=True)\n        trg = l[0].OuterLoop.To3dCurve().Simplify(rh.CurveSimplifyOptions.All, 0.1, 0.01)\n\n        p_one = trg.ClosestPoint(self.fres.PointAtStart)[1]\n        p_two = trg.ClosestPoint(self.fres.PointAtEnd)[1]\n        trim = trg.Trim(p_one, p_two)\n\n        tt = []\n\n        tt.append(trim)\n        tt.extend(self.hls[2:-2])\n\n        return tt\n\n    @property\n    def cg(self):\n        return self._cg\n\n    @cg.setter\n    def cg(self, v):\n        self._cg = v\n\n\nclass Side(BendSide):\n    side_offset = 1.0\n\n    @property\n    def top_part(self):\n        if self.reverse is False:\n            p_one = rh.Curve.LengthParameter(self.fres, self.fres.GetLength() - self.top_offset)\n            trimed = rh.Curve.Trim(self.fres, self.fres.Domain[0], p_one[1])\n        else:\n            p_one = rh.Curve.LengthParameter(self.fres, self.top_offset)\n            trimed = rh.Curve.Trim(self.fres, p_one[1], self.fres.Domain[1])\n\n        self._top_part = rh.Curve.Offset(trimed, rh.Plane.WorldXY, self.length, 0.01, rh.CurveOffsetCornerStyle.\n                                         None)\n        return self._top_part[0]\n\n    def __init__(self, curve, reverse):\n        BendSide.__init__(self, curve)\n        self.reverse = reverse\n\n\nclass Bottom(BendSide):\n    side_offset = 1.25\n\n    def __init__(self, curve):\n        BendSide.__init__(self, curve)\n\n\nclass Panel:\n\n    @property\n    def bound_plane(self):\n        j = rh.Curve.JoinCurves([self.side[0].join, self.niche.join, self.side[1].join, self.bottom.fres])[0]\n        b_r = j.GetBoundingBox(rh.Plane.WorldXY)\n        if self.type == 0:\n            fr = self.side[0].fres.FrameAt(self.side[0].fres.Domain[1])[1]\n            bound_plane = rh.Plane(b_r.Min, fr.XAxis, fr.YAxis)\n        else:\n            fr = self.side[1].fres.FrameAt(self.side[1].fres.Domain[0])[1]\n            bound_plane = rh.Plane(b_r.Max, fr.XAxis, fr.YAxis)\n        tr = rh.Transform.PlaneToPlane(bound_plane, rh.Plane.WorldXY)\n        return tr\n\n    @property\n    def top_parts(self):\n        top = [self.side[0].top_part.DuplicateCurve(), self.niche.top_part.DuplicateCurve(),\n               self.side[1].top_part.DuplicateCurve()]\n        [i.Transform(self.bound_plane) for i in top]\n        return top\n\n    @property\n    def fres(self):\n        fres = [self.side[0].fres.DuplicateCurve(), self.niche.fres.DuplicateCurve(),\n                self.side[1].fres.DuplicateCurve()]\n        [i.Transform(self.bound_plane) for i in fres]\n        return fres\n\n    @property\n    def cut(self):\n        if self.cogs_bend is True:\n            side = \\\n                rh.Curve.JoinCurves(\n                    [self.side[0].join, self.niche.join_region[0], self.side[1].join, self.bottom.fres])[0]\n            side.Transform(self.bound_plane)\n\n            cut = [side]\n\n            reg = self.niche.join_region[1:]\n\n            for i in reg:\n                ii = i.DuplicateCurve()\n                ii.Transform(self.bound_plane)\n                cut.append(ii)\n        else:\n            side = rh.Curve.JoinCurves([self.side[0].join, self.niche.join, self.side[1].join, self.bottom.fres])[0]\n            side.Transform(self.bound_plane)\n            cut = [side]\n        return cut\n\n    @property\n    def unroll_dict(self):\n        _unroll_dict = {'tag': self.tag, 'unroll': self.unrol_surf, 'frame': {'bb': 0}}\n        return _unroll_dict\n\n    def __init__(self, surface, type, cogs_bend, tag):\n\n        self.type = type\n        self.cogs_bend = cogs_bend\n        self.tag = tag\n\n        self.surf = surface\n\n        self.unrol_surf = rh.Unroller(self.surf).PerformUnroll()[0][0]\n        self.edges = self.unrol_surf.Curves3D\n\n        self.gen_side_types()\n\n    def gen_side_types(self):\n\n        if self.type == 0:\n            self.niche = Niche(self.edges[0])\n            self.bottom = Bottom(self.edges[2])\n            self.side = [Side(self.edges[1], True), Side(self.edges[3], False)]\n\n        else:\n            self.niche = Niche(self.edges[2])\n            self.bottom = Bottom(self.edges[0])\n            self.side = [Side(self.edges[1], False), Side(self.edges[3], True)]\n\n        self.side_types = [self.niche, self.bottom, self.side[0], self.side[1]]\n        self.intersect()\n\n    def intersect(self):\n        for i, v in enumerate(self.side_types):\n            param = []\n            for ind, val in enumerate(self.side_types):\n                if i != ind:\n                    inters = rs.CurveCurveIntersection(v.fres, val.fres)\n                    if inters is not None:\n                        param.append(inters[0][5])\n            param = sorted(param)\n\n            trimed = rh.Curve.Trim(v.fres, param[0], param[1])\n            v.fres = trimed\n\n\npanel = Panel\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}