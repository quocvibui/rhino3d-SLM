{
  "source_url": "https://github.com/jackhymowitz/main/blob/7325131db23094f1a28bd184b6a68f864f41a729/01_GH_Components/py/BT_IDF2PHPPObjs.py",
  "repo": "jackhymowitz/main",
  "repo_stars": 0,
  "repo_description": "IDF2PH is a free open source toolkit for working with E+ and PHPP Energy Models",
  "license": "GPL-3.0",
  "filepath": "01_GH_Components/py/BT_IDF2PHPPObjs.py",
  "instruction": "Takes in the IDF 'Objects' from the reader and organizes them for export to the PHPP. Gets all the relevant Materials, Constructions and Surfaces from the IDF file.\r\r\n-\r\r\nEM August 1, 2020\r\r\n\r\r\n   ...",
  "code": "#\r\r\n# IDF2PHPP: A Plugin for exporting an EnergyPlus IDF file to the Passive House Planning Package (PHPP). Created by blgdtyp, llc\r\r\n# \r\r\n# This component is part of IDF2PHPP.\r\r\n# \r\r\n# Copyright (c) 2020, bldgtyp, llc <info@bldgtyp.com> \r\r\n# IDF2PHPP is free software; you can redistribute it and/or modify \r\r\n# it under the terms of the GNU General Public License as published \r\r\n# by the Free Software Foundation; either version 3 of the License, \r\r\n# or (at your option) any later version. \r\r\n# \r\r\n# IDF2PHPP is distributed in the hope that it will be useful,\r\r\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \r\r\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \r\r\n# GNU General Public License for more details.\r\r\n# \r\r\n# For a copy of the GNU General Public License\r\r\n# see <http://www.gnu.org/licenses/>.\r\r\n# \r\r\n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\r\r\n#\r\r\n\"\"\"\r\r\nTakes in the IDF 'Objects' from the reader and organizes them for export to the PHPP. Gets all the relevant Materials, Constructions and Surfaces from the IDF file.\r\r\n-\r\r\nEM August 1, 2020\r\r\n\r\r\n    Args:\r\r\n        _HBZones: <Optional> If connected, the component will try and read detailed 'Frame' and 'Glass' Object data for each window in building. If this isn't hooked up, the normal EP windows will be used to create PHPP-Style Window Components. \r\r\n        _IDF_Objs_List: Takes in a list if IDF objects. Connect to the 'IDF_Objs_List' output on the 'IDF Reader' Component\r\r\n    Returns:\r\r\n        opaqueSurfaces: A List of the opaque surface IDF Objects found \r\r\n        windowObjects: A List of the window surface IDF Objects found\r\r\n        zoneNames_: A List of the Zone names found\r\r\n        PHPPObjs_: DataTree of all the organized, setup PHPP objects to pass to the writer\r\r\n\"\"\"\r\r\n\r\r\nghenv.Component.Name = \"BT_IDF2PHPPObjs\"\r\r\nghenv.Component.NickName = \"IDF-->PHPP Objs\"\r\r\nghenv.Component.Message = 'AUG_01_2020'\r\r\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\r\r\nghenv.Component.Category = \"BT\"\r\r\nghenv.Component.SubCategory = \"02 | IDF2PHPP\"\r\r\n\r\r\nfrom System import Object\r\r\nfrom Grasshopper import DataTree\r\r\nfrom Grasshopper.Kernel.Data import GH_Path\r\r\nimport Grasshopper.Kernel as ghK\r\r\nimport scriptcontext as sc\r\r\nfrom collections import namedtuple\r\r\nimport ghpythonlib.components as ghc\r\r\nimport math\r\r\nimport copy\r\r\nfrom collections import defaultdict\r\r\n\r\r\n# Classes and Defs\r\r\npreview=sc.sticky['Preview']\r\r\nphpp_calcNorthAngle=sc.sticky['phpp_calcNorthAngle']\r\r\nphpp_GetWindowSize=sc.sticky['phpp_GetWindowSize']\r\r\nphpp_makeHBMaterial=sc.sticky['phpp_makeHBMaterial']\r\r\nphpp_makeHBConstruction=sc.sticky['phpp_makeHBConstruction']\r\r\n\r\r\nphpp_ClimateData = sc.sticky['phpp_ClimateData']\r\r\n\r\r\nPHPP_XL_Obj=sc.sticky['PHPP_XL_Obj']\r\r\nPHPP_Glazing=sc.sticky['PHPP_Glazing']\r\r\nPHPP_Frame=sc.sticky['PHPP_Frame']\r\r\nPHPP_Window_Install=sc.sticky['PHPP_Window_Install']\r\r\nPHPP_ClimateDataSet = sc.sticky['PHPP_ClimateDataSet']\r\r\n\r\r\nIDF_Zone = sc.sticky['IDF_Zone']\r\r\nIDF_ZoneInfilFlowRate = sc.sticky['IDF_ZoneInfilFlowRate']\r\r\nIDF_ZoneList = sc.sticky['IDF_ZoneList']\r\r\nIDF_Obj_building=sc.sticky['IDF_Obj_building']\r\r\nIDF_Obj_MaterialLayer=sc.sticky['IDF_Obj_MaterialLayer']\r\r\nIDF_Obj_MaterialWindowSimple=sc.sticky['IDF_Obj_MaterialWindowSimple']\r\r\nIDF_Obj_MaterialWindowGlazing = sc.sticky['IDF_Obj_MaterialWindowGlazing']\r\r\nIDF_Obj_MaterialWindowGas = sc.sticky['IDF_Obj_MaterialWindowGas']\r\r\nIDF_Obj_Construction=sc.sticky['IDF_Obj_Construction']\r\r\nIDF_Obj_surfaceWindow=sc.sticky['IDF_Obj_surfaceWindow']\r\r\nIDF_Obj_surfaceOpaque=sc.sticky['IDF_Obj_surfaceOpaque']\r\r\nIDF_Obj_location = sc.sticky['IDF_Obj_location']\r\r\n\r\r\nhb_hive = sc.sticky[\"honeybee_Hive\"]()\r\r\nHBZoneObjects = hb_hive.callFromHoneybeeHive(_HBZones)\r\r\n\r\r\ndef parseIDFObjects(_IDF_Objs):\r\r\n    # Looks at the IDF Objects and parses them  out\r\r\n    # Builds class objects as appropriate\r\r\n    zones = []\r\r\n    zoneInfiltrationRates = []\r\r\n    zonesList = []\r\r\n    opaqueMaterials = []\r\r\n    windowMaterialsSimple = {}\r\r\n    windowMaterialGas = {}\r\r\n    windowMaterialGlazing = {}\r\r\n    allConstructions = []\r\r\n    opaqueSurfaces = []\r\r\n    location = []\r\r\n    \r\r\n    # First, need to find the North Direction. Have to do that before the rest\r\r\n    for each in _IDF_Objs:\r\r\n    # Look at each of the IDF objects coming in....\r\r\n        try:\r\r\n            idfObjName = getattr(each, 'objName')\r\r\n        except:\r\r\n            idfObjName = ''\r\r\n        \r\r\n        if idfObjName == 'Building':\r\r\n            # If the IDF Obj is a 'Building'\r\r\n            # Create the Building Object and get the Project's North Angle Vector\r\r\n            bldg = IDF_Obj_building(each)\r\r\n            bldgNorthVec = bldg.NorthVector\r\r\n    \r\r\n    # Now go through and pull out each class object\r\r\n    for eachIDFobj in _IDF_Objs:\r\r\n        try:\r\r\n            idfObjName = getattr(eachIDFobj, 'objName')\r\r\n        except:\r\r\n            idfObjName = ''\r\r\n        \r\r\n        # If its an opaque Building Surface object\r\r\n        if 'BuildingSurface:Detailed' in idfObjName:\r\r\n            opaqueSurfaces.append(  IDF_Obj_surfaceOpaque(eachIDFobj, bldgNorthVec)  )\r\r\n        \r\r\n        # If its a 'Material' or 'Material:AirGap' object\r\r\n        elif idfObjName == 'Material:AirGap' or idfObjName == 'Material':\r\r\n            opaqueMaterials.append( IDF_Obj_MaterialLayer(eachIDFobj) )\r\r\n        \r\r\n        elif idfObjName == 'Material:NoMass':\r\r\n            opaqueMaterials.append( IDF_Obj_MaterialLayer(eachIDFobj, noMass=True) )\r\r\n        \r\r\n        # If its a simple EP Style Window Material\r\r\n        elif 'WindowMaterial:SimpleGlazingSystem' in idfObjName:\r\r\n            windowMaterialsSimple[eachIDFobj.Name] = IDF_Obj_MaterialWindowSimple(eachIDFobj)\r\r\n        \r\r\n        elif 'WindowMaterial:Gas' in idfObjName:\r\r\n            windowMaterialGas[eachIDFobj.Name]  = IDF_Obj_MaterialWindowGas( eachIDFobj )\r\r\n        \r\r\n        elif 'WindowMaterial:Glazing' in idfObjName:\r\r\n            windowMaterialGlazing[eachIDFobj.Name]  = IDF_Obj_MaterialWindowGlazing( eachIDFobj )\r\r\n        \r\r\n        elif 'Construction' in idfObjName:\r\r\n            allConstructions.append( IDF_Obj_Construction( eachIDFobj )  )\r\r\n        \r\r\n        elif idfObjName == 'Zone':\r\r\n            newObj = IDF_Zone( eachIDFobj )\r\r\n            zones.append( IDF_Zone( eachIDFobj ) )\r\r\n        \r\r\n        elif idfObjName == 'ZoneList':\r\r\n            zonesList.append( IDF_ZoneList( eachIDFobj ) )\r\r\n            \r\r\n        elif 'ZoneInfiltration:DesignFlowRate' in idfObjName:\r\r\n            zoneInfiltrationRates.append( IDF_ZoneInfilFlowRate( eachIDFobj  ) )\r\r\n        \r\r\n        elif 'Site:Location' in idfObjName:\r\r\n            location = eachIDFobj\r\r\n            \r\r\n    return opaqueSurfaces, opaqueMaterials, windowMaterialsSimple, windowMaterialGas, windowMaterialGlazing, allConstructions, zones, zoneInfiltrationRates, zonesList, location\r\r\n\r\r\ndef materialWindowSimpleFromLayers(_const):\r\r\n    # If its a Window 'construction' of multiple layers, calc an approximate effective Uw\r\r\n    # https://bigladdersoftware.com/epx/docs/8-5/engineering-reference/window-heat-balance-calculation.html#equivalent-layer-thermal-model\r\r\n    # NOTE: Not doing this correctly right now. Neglecting radiation of convective effects. Only a super simplified approximiation for now....\r\r\n    \r\r\n    class temp:\r\r\n        # temp holder for params to pass\r\r\n        def __init__(self):\r\r\n            pass\r\r\n    \r\r\n    # Ok... so its a window with multiple layers. So need to calc equiv conductivity\r\r\n    newWinUg = [0.04, 0.13] # Start with the Surface Film Resistances...\r\r\n    for eachLayer in _const.Layers:\r\r\n        if eachLayer[1] in windowMaterialGlazing:\r\r\n            newWinUg.append( 1 / windowMaterialGlazing[ eachLayer[1] ].uValue ) # Resistance of Glass Layers\r\r\n        elif eachLayer[1] in windowMaterialGas:\r\r\n            newWinUg.append( 1 / windowMaterialGas[ eachLayer[1] ].uValue * 0.5 ) # Resistance of Gas Layers\r\r\n    newWinUg = 1/sum(newWinUg)\r\r\n    \r\r\n    # Create a New WindowMaterial:SimpleGlazingSystem Object to approximate this built-up construction\r\r\n    tempObj = temp()\r\r\n    setattr(tempObj, 'U-Factor {W/m2-K}', newWinUg)\r\r\n    setattr(tempObj, 'Solar Heat Gain Coefficient', 0.4)\r\r\n    setattr(tempObj, 'Visible Transmittance', 0.75)\r\r\n    setattr(tempObj, 'Name', _const.Name)\r\r\n    \r\r\n    return IDF_Obj_MaterialWindowSimple( tempObj )\r\r\n\r\r\ndef filterConstructions(_allConst, _materialsWindowSimple, _windowMaterialGas, _windowMaterialGlazing):\r\r\n    # Takes in all the construction and splits them into \r\r\n    # Window and Opaque constructions\r\r\n    \r\r\n    opaqueConstructions = []\r\r\n    windowConstructionsSimple = {}\r\r\n    \r\r\n    for construction in allConstructions:\r\r\n        isWindow = False\r\r\n        \r\r\n        # Is it a Window Construction?\r\r\n        # If the Construction includes any materials found in the WindowMaterialsSimple, WindowGas or WindowGlazing, then yes\r\r\n        for eachMat in _materialsWindowSimple.keys():\r\r\n            if _materialsWindowSimple[eachMat].Name in construction.LayerNames:\r\r\n                 isWindow = True\r\r\n        for eachMat in _windowMaterialGas:\r\r\n            if eachMat in construction.LayerNames:\r\r\n                 isWindow = True\r\r\n        for eachMat in _windowMaterialGlazing:\r\r\n            if eachMat in construction.LayerNames:\r\r\n                 isWindow = True\r\r\n        \r\r\n        # Now branch off the construction as appropriate\r\r\n        if isWindow==True:\r\r\n            # Its a window, so add to the Window Construction list\r\r\n            \r\r\n            if len(construction.Layers) > 1:\r\r\n                # Its a built up window. So turn that into a Simple Window\r\r\n                # Modify window construction using approximation and create a 'Simple' Window\r\r\n                materialWindowSimple = materialWindowSimpleFromLayers( construction )  # Create a new MaterialWindowSimple\r\r\n                _materialsWindowSimple[construction.Name] = materialWindowSimple       # Add the new MaterialWindowSimple to the list\r\r\n                construction.Layers = [ ['Layer1', materialWindowSimple.Name]  ]       # Change the Construction Layers to ONLY include the MaterialWindowSimple now  \r\r\n                windowConstructionsSimple[construction.Name] = construction            # Add the modified window construction to the list\r\r\n            else:\r\r\n                windowConstructionsSimple[construction.Name] =  construction\r\r\n        else:\r\r\n            # its not a window, so add to the Opaque Construction List\r\r\n            opaqueConstructions.append( construction )\r\r\n    \r\r\n    return opaqueConstructions, windowConstructionsSimple, _materialsWindowSimple\r\r\n\r\r\ndef getPHPPRooms(_HBZoneObjects):\r\r\n    # Looks at for all the rooms and ventilation systems\r\r\n    \r\r\n    HBZonePHPPRooms=[]\r\r\n    HBZoneVentSystemsDict = {}\r\r\n    if len(_HBZones)>0:\r\r\n        # Pull out the rooms if there are any\r\r\n        for zone in _HBZoneObjects:\r\r\n            # Look at each HB Zone and see if there have been PHPP rooms added\r\r\n            if 'PHPProoms' in zone.__dict__.keys():\r\r\n                # Some PHPP Rooms there. Read them.\r\r\n                for eachRoom in zone.PHPProoms:\r\r\n                    HBZonePHPPRooms.append(eachRoom)\r\r\n        \r\r\n        # Get the Ventilation Systems from the HB Zones if there are any\r\r\n        for zone in _HBZoneObjects:\r\r\n            if 'PHPP_VentSys' in zone.__dict__.keys():\r\r\n                # There is a Ventilation System applied. Pull it out\r\r\n                HBZoneVentSystemsDict[zone.PHPP_VentSys.Unit_Name] = zone.PHPP_VentSys\r\r\n        HBZoneVentSystems = [HBZoneVentSystemsDict]\r\r\n    else:\r\r\n        HBZoneVentSystems = []\r\r\n        \r\r\n    return HBZonePHPPRooms, HBZoneVentSystems\r\r\n\r\r\ndef getIDFWindowObjects(_IDF_Objs, _windowConstructionsSimple, _windowMaterialsSimple):\r\r\n    # Finds all  the widnow surfaces and builds window objects\r\r\n    windowSurfaces = []\r\r\n    windowObjs_raw = []\r\r\n    windowObjs_filtered = []\r\r\n    windowObjs_triangulated = {}\r\r\n    \r\r\n    for eachIDFobj in _IDF_Objs:\r\r\n        try:\r\r\n            idfObjName = getattr(eachIDFobj, 'objName')\r\r\n            \r\r\n        except:\r\r\n            idfObjName = ''\r\r\n        \r\r\n        # If its an EP Window Object\r\r\n        if 'FenestrationSurface:Detailed' in idfObjName:\r\r\n            windowObjs_raw.append(eachIDFobj)\r\r\n    \r\r\n    ##################################################\r\r\n    # Fix for window triangulation\r\r\n    for windowObj in windowObjs_raw:\r\r\n        # Honeybee adds the code '..._glzP_0, ..._glzP_1, etc..' suffix to the name for its triangulated windows\r\r\n        if '_glzP_' in windowObj.Name:\r\r\n            # See if it has only 3 vertices as well just to double check\r\r\n            numOfVerts = 0\r\r\n            for key in windowObj.__dict__.keys():\r\r\n                if 'XYZ Vertex' in key:\r\r\n                    numOfVerts += 1\r\r\n            if numOfVerts == 3:\r\r\n                # Ok, so its a triangulated window.\r\r\n                # File the triangulated window in the dictionary using its name as key\r\r\n                \r\r\n                tempWindowName = windowObj.Name.split('_glzP_')[0]\r\r\n                if tempWindowName not in windowObjs_triangulated.keys():\r\r\n                    windowObjs_triangulated[ tempWindowName ] = [windowObj]\r\r\n                else:\r\r\n                    windowObjs_triangulated[ tempWindowName ].append(windowObj)\r\r\n            else:\r\r\n                windowObjs_filtered.append(windowObj)\r\r\n        else:\r\r\n            windowObjs_filtered.append(windowObj)\r\r\n\r\r\n    # Unite the triangulated objects\r\r\n    for key in windowObjs_triangulated.keys():\r\r\n        perims = []\r\r\n        for windowObj in windowObjs_triangulated[key]:\r\r\n            triangleVerts = []\r\r\n            # Get the verts\r\r\n            for key in windowObj.__dict__.keys():\r\r\n                if 'XYZ Vertex' in key:\r\r\n                    verts = getattr(windowObj, key).split(' ')\r\r\n                    verts = [float(x) for x in verts]\r\r\n                    point = ghc.ConstructPoint(verts[0], verts[1], verts[2])\r\r\n                    triangleVerts.append( point )\r\r\n            \r\r\n            # Union the Segments, find the outside perimeter\r\r\n            perim = ghc.PolyLine(triangleVerts, closed=True)\r\r\n            perims.append(perim)\r\r\n        \r\r\n        unionedPerim = ghc.RegionUnion(perims)\r\r\n        \r\r\n        # Build a new Window Obj using this now unioned geometry\r\r\n        newVertPoints = ghc.ControlPoints(unionedPerim).points #windowObj.__dict__\r\r\n        newWindowObj = copy.deepcopy(windowObj)\r\r\n        \r\r\n        for i in range(len(newVertPoints)):\r\r\n            setattr(newWindowObj, 'XYZ Vertex {} {}'.format(i+1, '{m}'), str(newVertPoints[i]).replace(',',' '))\r\r\n            setattr(newWindowObj, 'Name', windowObj.Name[:-7])\r\r\n        \r\r\n        windowObjs_filtered.append(newWindowObj)\r\r\n    \r\r\n    ##################################################\r\r\n    \r\r\n    # Build the Window Objects\r\r\n    for eachWindowObj in windowObjs_filtered:\r\r\n            # Find the windows's CONSTRUCTION and MATERIAL information in the IDF\r\r\n            thisWindowEP_CONST_Name = getattr(eachWindowObj, 'Construction Name')                         # Get the name of the Windows' Construction  \r\r\n            thisWindowEP_MAT_Name = _windowConstructionsSimple[  thisWindowEP_CONST_Name  ].Layers[0][1]  # Find the Material name of 'Layer 1' in the Window's Construction\r\r\n            thisWindowEP_WinSimp_Obj = _windowMaterialsSimple[  thisWindowEP_MAT_Name  ]                  # Find the 'WindowMaterial:SimpleGlazingSystem' Object with the same name as 'Layer 1' \r\r\n            winterShadingFactor = 0.75\r\r\n            summerShadingFactor = 0.75\r\r\n            \r\r\n            # Create the new IDF_Obj_surfaceWindow Object\r\r\n            windowSurfaces.append( IDF_Obj_surfaceWindow(eachWindowObj, thisWindowEP_WinSimp_Obj, winterShadingFactor, summerShadingFactor) )\r\r\n    \r\r\n    return windowSurfaces\r\r\n\r\r\ndef updatePHPPStyleWindows(_zoneObjs, _IDFwindowSurfaces):\r\r\n    # Used to update / overwrite the IDF window Params with the more detailed\r\r\n    # Params from the HB Zone 'phppWindowDict' <if they exist>\r\r\n    \r\r\n    for IDFwindowObj in _IDFwindowSurfaces:\r\r\n        # Find the IDFWindow's host zone\r\r\n        for zone in _zoneObjs:\r\r\n            for surface in zone.surfaces:\r\r\n                if surface.name in IDFwindowObj.HostSrfc:\r\r\n                    # Found the window's host zone\r\r\n                    try:\r\r\n                        #print 'Updating IDFWindow Object: <{}> with Params from HB Zone'.format(IDFwindowObj.Name)\r\r\n                        # Get the HB Zone's detailed PHPP Style Window Data\r\r\n                        phppWindowObj = zone.phppWindowDict[ IDFwindowObj.Name ]\r\r\n                        \r\r\n                        # Re-set the IDF-Window Obj's param data with the detailed HB Data\r\r\n                        setattr(IDFwindowObj, 'Type_Variant', phppWindowObj.Type_Variant)\r\r\n                        setattr(IDFwindowObj, 'Type_Frame', phppWindowObj.Type_Frame)\r\r\n                        setattr(IDFwindowObj, 'Type_Glass', phppWindowObj.Type_Glass)\r\r\n                        setattr(IDFwindowObj, 'Installs', phppWindowObj.Installs)\r\r\n                        \r\r\n                        shadingFactors = phppWindowObj.getShadingFactors_Simple()\r\r\n                        setattr(IDFwindowObj, 'winterShadingFac', shadingFactors[0])\r\r\n                        setattr(IDFwindowObj, 'summerShadingFac', shadingFactors[1])\r\r\n                    except:\r\r\n                        pass\r\r\n                    break\r\r\n\r\r\ndef filterSurfaces(_surfaces):\r\r\n    # Filter to only include the surface if its 'exposed' to the outdoors or Ground (not an interior floor / wall)\r\r\n    exposedSurfaces = []\r\r\n    \r\r\n    for srfc in _surfaces:\r\r\n        if srfc.exposure != 'Surface':\r\r\n        #if srfc.exposure == 'Outdoors' or srfc.exposure == 'Ground':\r\r\n            exposedSurfaces.append(srfc)\r\r\n        \r\r\n    return exposedSurfaces\r\r\n\r\r\ndef buildZoneBrep(_zoneObjs, _opaqueSurfaces):\r\r\n    # Takes in the IDF Surfaces and builds Zone Breps from them\r\r\n    # Sets the ZoneObj as an attr using the new Brep\r\r\n    \r\r\n    zoneBreps = []\r\r\n    \r\r\n    for zone in _zoneObjs:    \r\r\n        zoneSurfaces = []\r\r\n        for srfc in _opaqueSurfaces:\r\r\n            if srfc.HostZoneName == zone.ZoneName:\r\r\n                zoneSurfaces.append( ghc.BoundarySurfaces(srfc.Boundary) )\r\r\n        zoneBrep = ghc.BrepJoin( zoneSurfaces ).breps\r\r\n        zoneBreps.append( zoneBrep )\r\r\n        setattr(zone, 'ZoneBrep', zoneBrep)\r\r\n    \r\r\n    return zoneBreps\r\r\n\r\r\ndef calcZoneParams(_zonesList, _zoneObjs, _opaqueSurfaces, _rooms, _HBZoneObjs):\r\r\n    # Looks at the ZoneList, and for each Zone in the List\r\r\n    # Finds the Floor Area, the exposed Surface Area (Outdoors) and the Zone Volume\r\r\n    # And the right Infiltration Rate. Calcs the total Infiltration Rate in m3/h for each Zone\r\r\n    # Sets Zone Attributes for ACH, Volume, Floor Area\r\r\n    \r\r\n    blowerPressure = 50 #Pa - for calc'ing the tested/input ACH\r\r\n    \r\r\n    # Get the Infiltration Rate, Volume, Floor Area from the IDF File\r\r\n    for zoneList in _zonesList:\r\r\n        for zoneInfilObj in zoneInfiltrationRates:\r\r\n            if zoneInfilObj.ZoneName == zoneList.Name:\r\r\n                # Use this InfilObj's params...\r\r\n                # So now for each actual ZONE name in the Zone List...\r\r\n                for eachKey in zoneList.__dict__.keys():\r\r\n                    if eachKey != 'Name': # Cus' this key is only the name of the ZoneList Object\r\r\n                        zoneNameinList = getattr(zoneList, eachKey)\r\r\n                        for zoneObj in _zoneObjs:\r\r\n                            if zoneObj.ZoneName == zoneNameinList:\r\r\n                                # Find the HB Zone Obj\r\r\n                                for HBzone in _HBZoneObjs:\r\r\n                                    if HBzone.name == zoneObj.ZoneName:\r\r\n                                        thisHBZone = HBzone\r\r\n                                \r\r\n                                # Ok, found the right Zone Obj. Get the Reference Values\r\r\n                                # Find the PHPProom Volumes for the zone\r\r\n                                roomVn50s = []\r\r\n                                for room in _rooms:\r\r\n                                    if room.HostZoneName == zoneObj.ZoneName:\r\r\n                                        roomVn50s.append(room.RoomNetClearVolume)\r\r\n                                \r\r\n                                # Get the Gross Exposed Surface Area of the Zone\r\r\n                                zoneExposedFacadeArea = thisHBZone.getExposedArea()\r\r\n                                \r\r\n                                # The Gross Reference Floor area to use for calcs\r\r\n                                zoneRefFloorArea = thisHBZone.getFloorArea()\r\r\n                                \r\r\n                                # Zone Volume, but use Room Vn50s if there are any\r\r\n                                zoneRefVolume = thisHBZone.getZoneVolume()\r\r\n                                if len(roomVn50s) != 0:\r\r\n                                    zoneRefVolume = sum(roomVn50s)\r\r\n                                \r\r\n                                # Calc the Infiltration Rate by Floor Area or by Facade Area\r\r\n                                try:\r\r\n                                    infilRatebyFloor = float( getattr(zoneInfilObj, 'FlowRatePerFloorArea') )# m3/s-m2\r\r\n                                    infilRatebyFacadeArea = 0\r\r\n                                    zoneInfilRate = infilRatebyFloor * zoneRefFloorArea * 60 * 60 # sec/min * min/hour\r\r\n                                    zoneACH50 = ((math.pow((blowerPressure/4),0.63)) * zoneInfilRate ) / zoneRefVolume\r\r\n                                except:\r\r\n                                    try:\r\r\n                                        infilRatebyFloor = 0\r\r\n                                        infilRatebyFacadeArea = float( getattr(zoneInfilObj, 'FlowRatePerSurfaceArea') )# m3/s-m2\r\r\n                                        zoneInfilRate = infilRatebyFacadeArea * zoneExposedFacadeArea * 60 * 60\r\r\n                                        zoneACH50 = ((math.pow((blowerPressure/4),0.63)) * zoneInfilRate ) / zoneRefVolume\r\r\n                                    except:\r\r\n                                        print 'something went wrong. Maybe no Infiltration rate applied?'\r\r\n                                \r\r\n                                # Set the attributes on the Zone Objects\r\r\n                                setattr(zoneObj, 'InfiltrationACH50', zoneACH50)\r\r\n                                setattr(zoneObj, 'Volume_Gross', zoneRefVolume)\r\r\n                                setattr(zoneObj, 'FloorArea_Gross', zoneRefFloorArea)\r\r\n                                setattr(zoneObj, 'Volume_Vn50', zoneRefVolume)\r\r\n                                setattr(zoneObj, 'TFA', zoneRefFloorArea)\r\r\n                                \r\r\n    \r\r\n    # Try and get the room Vn50 and TFA from the PHPP_Roooms in the HB Zone\r\r\n    for zone in _zoneObjs:\r\r\n        zoneTFAs = []\r\r\n        zoneVn50s = []\r\r\n        \r\r\n        for room in _rooms:\r\r\n            if room.HostZoneName == zone.ZoneName:\r\r\n                zoneTFAs.append( room.FloorArea_TFA )\r\r\n                zoneVn50s.append( room.RoomNetClearVolume )\r\r\n        \r\r\n        if zoneTFAs and zoneVn50s:\r\r\n            setattr(zone, 'TFA', sum(zoneTFAs) )\r\r\n            setattr(zone, 'Volume_Vn50', sum(zoneVn50s) )\r\r\n\r\r\ndef getDHWSys(_zoneObjs):\r\r\n    dhwSystems = defaultdict()\r\r\n    \r\r\n    for zone in _zoneObjs:\r\r\n        dhwSystemObj = getattr(zone, 'PHPP_DHWSys', None)\r\r\n        if dhwSystemObj != None:\r\r\n            dhwSystems[dhwSystemObj.SystemName] = dhwSystemObj\r\r\n    \r\r\n    if len(dhwSystems.keys())>1:\r\r\n        warning = 'Found more than one type of DHW System applied. I will try and combine them\\n'\\\r\r\n        'together, but you might be better off exporting the different zones to separate PHPPs\\n'\\\r\r\n        'if you really have multiple different DHW systems in the building?'\r\r\n        ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\r\r\n    \r\r\n    return list(dhwSystems.values())\r\r\n\r\r\ndef getGround(_zoneObjs):\r\r\n    # Pull out the ground objects from the Honeybee Zones\r\r\n    groundObjs = []\r\r\n    \r\r\n    for zone in _zoneObjs:\r\r\n        if hasattr(zone, 'PHPP_ground'):\r\r\n            groundObjs.append( getattr(zone, 'PHPP_ground') )\r\r\n    \r\r\n    return groundObjs\r\r\n\r\r\ndef findNearestPHPPclimateZone(_lat, _long, _climateData):\r\r\n    \"\"\" Finds the nearest PHPP Climate zone to the EPW Lat /Long \r\r\n    \r\r\n    Methodology copied from the PHPP v 9.6a (SI) Climate worksheet\r\r\n    \"\"\"\r\r\n    def sortByDist(e):\r\r\n        return e['distToEPW']\r\r\n    \r\r\n    for each in _climateData:\r\r\n        eachLat = float(each.get('Latitude', 0))\r\r\n        eachLong = float(each.get('Longitude', 0))\r\r\n        \r\r\n        a = math.sin(math.pi/180*eachLat)*math.sin(math.pi/180*_lat)+math.cos(math.pi/180*eachLat)*math.cos(math.pi/180*_lat)*math.cos(math.pi/180*(eachLong-_long))\r\r\n        b = max([-1, a])\r\r\n        c = min([1, b])\r\r\n        d = math.acos(c)\r\r\n        kmFromEPWLocation = 6378 * d\r\r\n        \r\r\n        each['distToEPW'] = kmFromEPWLocation\r\r\n    \r\r\n    _climateData.sort(key=sortByDist)\r\r\n    climateSetToUse = _climateData[0]\r\r\n    \r\r\n    dataSet = climateSetToUse.get('Dataset', 'US0055b-New York')\r\r\n    alt = '=J23'\r\r\n    country = climateSetToUse.get('Country', 'US-United States of America')\r\r\n    region = climateSetToUse.get('Region', 'New York')\r\r\n    \r\r\n    climateSetToUse = PHPP_ClimateDataSet(dataSet, alt, country, region)\r\r\n    \r\r\n    return [climateSetToUse]\r\r\n\r\r\n#-------------------------------------------------------------------------------\r\r\n##### Read the IDF Objects and Build class objects  ##########\r\r\n\r\r\n# Get Material Layers, Constructions, Surfaces\r\r\n(opaqueSurfaces,\r\r\nopaqueMaterials,\r\r\nwindowMaterialsSimple,\r\r\nwindowMaterialGas,\r\r\nwindowMaterialGlazing,\r\r\nallConstructions,\r\r\nzones,\r\r\nzoneInfiltrationRates,\r\r\nzonesList,\r\r\nlocation) = parseIDFObjects(_IDF_Objs_List)\r\r\n\r\r\nopaqueSurfaces_Exposed = filterSurfaces(opaqueSurfaces)\r\r\n\r\r\n# Filter Constructions into Opaque/Window\r\r\n(opaqueConstructions,\r\r\nwindowConstructionsSimple,\r\r\nwindowMaterialsSimple) = filterConstructions(allConstructions, windowMaterialsSimple, windowMaterialGas, windowMaterialGlazing)\r\r\n\r\r\n# IDf Window Objects\r\r\nwindowObjects = getIDFWindowObjects(_IDF_Objs_List, windowConstructionsSimple, windowMaterialsSimple)\r\r\n\r\r\n# Zone Rooms, Ventialtion from HB, Update windows to Detailed data from HB Zones\r\r\nif len(_HBZones)>0 and len(_IDF_Objs_List)>1:\r\r\n    HBZonePHPPRooms, HBZoneVentSystems = getPHPPRooms(HBZoneObjects)\r\r\n    updatePHPPStyleWindows(HBZoneObjects, windowObjects)\r\r\n    \r\r\n    # Calc and  set Zone Attributes\r\r\n    buildZoneBrep(zones, opaqueSurfaces)  # Build the Zone Breps and add to Zone Objects\r\r\n    calcZoneParams(zonesList, zones, opaqueSurfaces, HBZonePHPPRooms, HBZoneObjects)   # Determine Infiltation and add to Zone Objects\r\r\n    dhwSystemObj = getDHWSys(HBZoneObjects)\r\r\n    groundObjs = getGround(HBZoneObjects)\r\r\nelse:\r\r\n    HBZonePHPPRooms, HBZoneVentSystems = [], []\r\r\n    dhwSystemObj = []\r\r\n    groundObjs = []\r\r\n\r\r\n# Figure out the Closest PHPP Climate Zone\r\r\nlatitude = float(getattr(location, 'Latitude {deg}', 51.30))\r\r\nlongitude = float(getattr(location, 'Longitude {deg}', 9.44))\r\r\nclimate = findNearestPHPPclimateZone(latitude, longitude, phpp_ClimateData)\r\r\n    \r\r\ntry:\r\r\n    latitude = float(getattr(location, 'Latitude {deg}', 51.30))\r\r\n    longitude = float(getattr(location, 'Longitude {deg}', 9.44))\r\r\n    climate = findNearestPHPPclimateZone(latitude, longitude, phpp_ClimateData)\r\r\nexcept:\r\r\n    print 'Error finding the nearest PHPP Climate Zone?'\r\r\n    climate = []\r\r\n\r\r\n#{'objName': 'Site:Location', 'Longitude {deg}': '-73.8', 'Elevation {m}': '5', 'Name': 'New York-Kennedy Intl AP\\tUSA', 'Time Zone {hr}': '-5', 'Latitude {deg}': '40.65'}\r\r\n#-------------------------------------------------------------------------------\r\r\n#########       Package up all the output objects    #########   \r\r\n#########       into a single tree for passing       #########    \r\r\n\r\r\nPHPPObjs_ = DataTree[Object]()\r\r\n# Materials and Constructions\r\r\nPHPPObjs_.AddRange(opaqueMaterials, GH_Path(0)) # Opaque Material Objects\r\r\nPHPPObjs_.AddRange(opaqueConstructions, GH_Path(1)) # Opaque IDF_Obj_Construction Objects\r\r\nPHPPObjs_.AddRange(windowMaterialsSimple, GH_Path(2)) # EP Style Window Material Objects\r\r\nPHPPObjs_.AddRange(windowConstructionsSimple, GH_Path(3)) # EP Style Window IDF_Obj_Construction Objects\r\r\n# Surfaces\r\r\nPHPPObjs_.AddRange(opaqueSurfaces_Exposed, GH_Path(4)) # Opaque Surface Objects\r\r\nPHPPObjs_.AddRange(windowObjects, GH_Path(5)) # PHPP Style Window IDF_Obj_Construction Objects\r\r\nPHPPObjs_.AddRange(HBZonePHPPRooms, GH_Path(6)) # List of all the HB Zone PHPP Rooms\r\r\nPHPPObjs_.AddRange(HBZoneVentSystems, GH_Path(7)) # List the Fresh Air Ventilation System Dictionary\r\r\n# Zones\r\r\nPHPPObjs_.AddRange(zones, GH_Path(8)) # All of the Zones\r\r\nPHPPObjs_.AddRange(zoneInfiltrationRates, GH_Path(9)) # Zone Infiltration Airflow rates\r\r\nPHPPObjs_.AddRange(dhwSystemObj, GH_Path(10)) # The DHW System\r\r\nPHPPObjs_.AddRange(groundObjs, GH_Path(11)) # Ground\r\r\nPHPPObjs_.AddRange(climate, GH_Path(12)) # Ground\r\r\n\r\r\n#-------------------------------------------------------------------------------\r\r\n# Output Preview of Zone Names\r\r\nzoneNames_ = []\r\r\nfor zoneObj in PHPPObjs_.Branch(8):\r\r\n    zoneNames_.append(zoneObj.ZoneName)\r\n",
  "language": "python",
  "imports": [
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": true
}