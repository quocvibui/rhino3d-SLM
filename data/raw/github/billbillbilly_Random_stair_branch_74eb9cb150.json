{
  "source_url": "https://github.com/billbillbilly/Random_stair_branch/blob/a477954098b483aa895edd8ccc83bc5537adbbea/random_stairs_v3.py",
  "repo": "billbillbilly/Random_stair_branch",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "random_stairs_v3.py",
  "instruction": "Random stairs v3",
  "code": "import rhinoscriptsyntax as rs\nimport ghpythonlib.components as ghc\nimport scriptcontext as sc\nimport random\nimport math\nimport sys\n\n# reference: Relative neighborhood graph - https://blog.schawe.me/relative-neighborhood-graph.html\n\nclass stairSystem():\n    def __init__(self, intX = None, intY = None, interval = None, elevation = None, num = None, multiple_start_point = False):\n        self.x = intX\n        self.y = intY\n        self.interval = interval\n        self.elevation = elevation\n        self.num = num\n        self.multipleStart = multiple_start_point\n\n    # set up point matrix\n    def pointMatrix(self):\n        # point matrix that provides x,y coordinates\n        self.pointDic = {}\n        # values that correspond point matrix to validate if the neighbor is locked ot not\n        self.valDic = {}\n        # collect rendered point matrix\n        pt_list = []\n        # collect attractors\n        self.attractors = []\n\n        for i in range(self.x):\n            for j in range(self.y):\n                self.pointDic[(i,j)] = (i*self.interval, j*self.interval, 0)\n                # 0 means the point is not locked\n                self.valDic[(i,j)] = 0\n                # render each point in rhino space\n                pt_list += [rs.AddPoint((i*self.interval, j*self.interval, 0))]\n        # allow users to pick up a point/several points from point matrix as (a) start point(s)\n        if self.multipleStart:\n            self.original = []\n            pts = rs.GetPoints(message1 = \"select points as start points\", max_points = 2)\n            for each in pts:\n                self.original += [rs.CreatePoint(each)]\n        else:\n            pt = rs.GetPoint(\"select one point in matrix\")\n            self.original = rs.CreatePoint(pt)\n\n        # select attractor points\n        attractors = rs.GetPoints(message1 = \"select points as attractors\", max_points = 10)\n        for each in attractors:\n            pt = rs.CreatePoint(each)\n            self.attractors += [(pt[0], pt[1], pt[2])]\n        rs.HideObjects(pt_list)\n        return self\n\n    # find the position of selected origin\n    def origin(self):\n        for each in self.pointDic:\n            x_ = self.pointDic[each][0]\n            y_ = self.pointDic[each][1]\n            if self.multipleStart:\n                for i in range(len(self.original)):\n                    if x_ == self.original[i][0] and y_ == self.original[i][1]:\n                        self.original[i] = each\n            else:\n                if x_ == self.original[0] and y_ == self.original[1]:\n                    self.original = each\n        return self\n\n    # identify positions to setup attractor points for creating\n    # a gradient of brach-out possibility\n    def attractor(self):\n        for each in self.pointDic:\n            x_ = self.pointDic[each][0]\n            y_ = self.pointDic[each][1]\n            for i in range(len(self.attractors)):\n                if x_ == self.attractors[i][0] and y_ == self.attractors[i][1]:\n                    self.attractors[i] = each\n        return self\n\n    # detect existing neighbors of a given position\n    def detectNeighbor(self, position, matrix_value, drop_postion):\n        # set up four different neighbors\n        front = (position[0],position[1]+1)\n        back = (position[0],position[1]-1)\n        left = (position[0]-1,position[1])\n        right = (position[0]+1,position[1])\n        neighbors = [front, back, left, right]\n        # set up conditions to ensure if the position is on the edges of matrix\n        if position[0] == 0:\n            neighbors.remove(left)\n        if position[0] == self.x - 1:\n            neighbors.remove(right)\n        if position[1] == 0:\n            neighbors.remove(back)\n        if position[1] == self.y - 1:\n            neighbors.remove(front)\n        # select unlocked neighbors\n        available_neighbors = []\n        for each in neighbors:\n            if matrix_value[each] == 0:\n                available_neighbors += [each]\n        # remove the position, where a step already exists\n        if drop_postion != None:\n            if drop_postion in available_neighbors:\n                available_neighbors.remove(drop_postion)\n        return available_neighbors\n\n    # set up how likely the stair will be branched out\n    def setPossibility(self, possibility):\n        split_num = int(round(possibility * 10))\n        index = random.sample(range(10), split_num)\n        self.if_list = list(range(10))\n        for i in range(10):\n            if i in index:\n                # 1 is for branching out. 0 is for keeping one neighbor\n                self.if_list[i] = 1\n            else:\n                self.if_list[i] = 0\n        return self\n\n    # randomly make a decision if branch out the stair or not based on possibility\n    def ifBranchOut(self, position, matrix_value, point, length, factor, step_population):\n        # find neighbors\n        if point in step_population:\n            drop_postion = step_population[point]\n        else:\n            drop_postion = None\n        neighbors = self.detectNeighbor(position, matrix_value, drop_postion)\n        # make a decision whether branch out stair or not\n        if_branch = random.choice(self.if_list)\n\n        # if the position is the attractors, branch out will be disabled\n        if position in self.attractors:\n            if_branch = 0\n\n        # if legnth of stair trial cannot be divided by factor, disable branch out\n        if length % factor != 0:\n            if_branch = 0\n\n        # when if_branch is true and there are more than 2 available neighbors,\n        # the stair will be branched out\n        if if_branch == 1 and len(neighbors) >= 2:\n            selected_neighbor = random.sample(neighbors, 2)\n        else:\n            if neighbors != []:\n                selected_neighbor = random.choice(neighbors)\n            else:\n                selected_neighbor = neighbors\n        return selected_neighbor\n\n    # start to generate stair\n    def update(self, step_node_population, step_population, node_list):\n        if self.multipleStart:\n            for pt in self.original:\n                stairBranch(pt[0], pt[1], 0, self.interval, self.num, 0, self.pointDic, self.valDic, self.ifBranchOut,\n                            self.elevation).generateStairs(step_node_population, step_population, node_list)\n        else:\n            stairBranch(self.original[0], self.original[1], 0, self.interval, self.num, 0, self.pointDic, self.valDic, self.ifBranchOut,\n                        self.elevation).generateStairs(step_node_population, step_population, node_list)\n\n# this class is for recursively generating or branching out stairs\nclass stairBranch():\n    def __init__(self, x, y, hight, interval, times, num, matrix, matrix_value, branch_function, elevation, previous_position = None):\n        self.original_position = (x, y)\n        self.current_position = None\n        self.previous_position = previous_position\n        self.hight = hight\n        self.interval = interval\n        self.recursion_times = times\n        self.pointDic = matrix\n        self.valDic = matrix_value\n        self.ifBranchOut = branch_function\n        self.elevation = elevation\n        self.count = num\n        self.curveID = None\n        self.trailPts = []\n\n    # generate stair step along the trail\n    def stepNode(self, point, elevation, interval, step_node_population, node_list):\n        if (point[0], point[1], point[2]) not in node_list:\n            points = []\n            for i in range(2):\n                if i == 0:\n                    factor1 = 1\n                else:\n                    factor1 = -1\n                for j in range(4):\n                    x = point[0] + interval * math.cos(math.radians(90*j))\n                    y = point[1] + interval * math.sin(math.radians(90*j))\n                    z = point[2] + factor1 * elevation/1.5\n                    points += [rs.CreatePoint((x,y,z))]\n            box = rs.AddBox(points)\n            scale = random.uniform(0.5, 1)\n            rs.ScaleObject(box, point, (scale, scale, 0.5))\n            rs.RotateObject(box, point, 45)\n\n            # get vertices of modefied box\n            # explore the box\n            surfaces = rs.ExplodePolysurfaces(box)\n\n            # get two surfaces that are not attached to each other\n            areas = []\n            areas_dic = {}\n            for srf in surfaces:\n                area = round(rs.SurfaceArea(srf)[0])\n                areas += [area]\n                areas_dic[area] = srf\n            area = max(areas)\n            srf1 = areas_dic[area]\n            srf2 = None\n            for each in surfaces:\n                if srf2 == None:\n                    if round(rs.SurfaceArea(srf1)[0]) == round(rs.SurfaceArea(each)[0]) and each != srf1:\n                        srf2 = each\n            srf = [srf1, srf2]\n            # save eight vertexes of surface\n            vertices = []\n            for each in srf:\n                # get edges of surface\n                edges = rs.DuplicateEdgeCurves(each)\n                    # get vertexes from each edge\n                for edge in edges:\n                    if rs.CurveEndPoint(edge)[2] == point[2] + elevation/1.5:\n                        # save each vertice\n                        vertices += [nodeNetwork(rs.CurveEndPoint(edge), interval, 0)]\n                    else:\n                        vertices += [nodeNetwork(rs.CurveEndPoint(edge), interval, 1)]\n                    rs.AddPoint(rs.CurveEndPoint(edge))\n                rs.DeleteObjects(edges)\n            node_list += [(point[0], point[1], point[2])]\n            step_node_population += vertices\n            rs.DeleteObjects(surfaces)\n\n    # create step and vertices\n    def populateStep(self, trails, interval, step_node_population, node_list):\n        for trail in trails:\n            length = rs.CurveLength(trail)\n            pts = rs.DivideCurve(trail, round(length/3))\n            delta_elevation = abs(rs.CurveEndPoint(trail)[2] - rs.CurveStartPoint(trail)[2])\n            for pt in pts[1:]:\n                self.stepNode(pt, delta_elevation/len(pts), math.sqrt(self.interval), step_node_population, node_list)\n\n    # generate stair trials\n    def generateStairs(self, step_node_population, step_population, node_list):\n        # set origin as start point\n        if self.current_position == None:\n            self.current_position = self.original_position\n            # add point into trail point list\n            pt = rs.CreatePoint(self.pointDic[self.original_position])\n            pt = rs.CreatePoint((pt[0],pt[1],self.hight))\n            # count the number of steps in the indivual branch\n            self.trailPts += [pt]\n            # save occupied point in a global directionary\n            step_population[(pt[0],pt[1],pt[2])] = self.current_position\n\n        # calcualate legnth of stair trail\n        length = len(self.trailPts)\n        factor = self.elevation*5\n        # get spatial point in the current position\n        currentPt = (self.pointDic[self.current_position][0],\n                     self.pointDic[self.current_position][1],\n                     self.hight)\n        # find unlocked neighbors and randomly celect one or two neighbors\n        neighbors = self.ifBranchOut(self.current_position, self.valDic, currentPt, length, factor, step_population)\n        # after getting the unlocked neighbors, unlock previous position\n        if self.previous_position != []:\n            self.valDic[self.previous_position] = 0\n            # if there is no available neighbor, unlock all neighbors\n            if neighbors != []:\n                for each in self.valDic:\n                    self.valDic[each] = 0\n\n        # lock current_position\n        self.valDic[self.current_position] = 1\n        # save current_position as previous_position\n        self.previous_position = self.current_position\n\n        # change the vertical direction of stairs\n        step = self.hight/self.elevation\n        direction = math.sin(self.count/(self.recursion_times/(self.elevation**2)))\n        # go up\n        if direction >= 0:\n            direction = 1\n        # go down\n        elif direction < 0 and self.hight >= 0:\n            direction = -1\n            # when the stair is gonging down, disable the function of branch\n            if isinstance(neighbors, list) == True:\n                neighbors = random.choice(neighbors)\n        # go up\n        else:\n            direction = 1\n        # change elevations\n        self.hight += self.elevation * direction\n\n        if neighbors != []:\n            # keep generating\n            if isinstance(neighbors, list) == False:\n                # update current_position by randomly picking up a neighbor\n                self.current_position = neighbors\n                # create point and add it into list\n                x = self.pointDic[self.current_position][0]\n                y = self.pointDic[self.current_position][1]\n                z = self.hight\n\n                pt = rs.CreatePoint((x,y,z))\n                self.trailPts += [pt]\n                if self.curveID != None:\n                    rs.DeleteObject(self.curveID)\n                self.curveID = rs.AddCurve(self.trailPts,1)\n                # explore trial\n                trails = rs.ExplodeCurves(self.curveID)\n                # generate steps\n                #if self.steps != None:\n                    #rs.DeleteObjects(self.steps)\n                self.populateStep(trails, self.interval, step_node_population, node_list)\n                rs.DeleteObjects(trails)\n\n                step_population[(x,y,z)] = [self.current_position]\n                # recursion\n                while self.count <= self.recursion_times:\n                    self.count += 1\n                    self.generateStairs(step_node_population, step_population, node_list)\n            # branch out\n            else:\n                # create point and add it into list\n                #rs.AddCurve(self.trailPts, degree=1)\n                for each in neighbors:\n                    x = self.pointDic[each][0]\n                    y = self.pointDic[each][1]\n                    z = self.hight\n                    pt = rs.CreatePoint((x,y,z))\n                    self.trailPts += [pt]\n                    if self.curveID != None:\n                        rs.DeleteObject(self.curveID)\n                    self.curveID = rs.AddCurve(self.trailPts, 1)\n                    # explore trial\n                    trails = rs.ExplodeCurves(self.curveID)\n                    # generate steps\n                    self.populateStep(trails, self.interval, step_node_population, node_list)\n                    self.trailPts.pop(-1)\n                    rs.DeleteObjects(trails)\n\n                    step_population[(x,y,z)] = [each]\n                if self.count <= self.recursion_times:\n                    # generate new stair branches\n                    stair1 = stairBranch(neighbors[0][0], neighbors[0][1], self.hight,\n                                         self.interval, self.recursion_times, self.count,\n                                         self.pointDic, self.valDic, self.ifBranchOut,\n                                         self.elevation, self.previous_position)\n                    stair2 = stairBranch(neighbors[1][0], neighbors[1][1], self.hight,\n                                         self.interval, self.recursion_times, self.count,\n                                         self.pointDic, self.valDic, self.ifBranchOut,\n                                         self.elevation, self.previous_position)\n                    # recursion\n                    stair1.generateStairs(step_node_population, step_population, node_list)\n                    stair2.generateStairs(step_node_population, step_population, node_list)\n\n# generate stair connections\nclass nodeNetwork():\n    def __init__(self, node, interval, upordown):\n        self.pos = node\n        self.interval = interval\n        self.up_down = upordown\n        self.connect_times = 0\n        self.connected = []\n\n    # connect neighbors\n    def connectNeighbors(self, nodePopulation, connections):\n        # check if two points are relative neighbors\n        for i in range(len(nodePopulation)):\n            d = rs.Distance(self.pos, nodePopulation[i].pos)\n            if d <= self.interval*2:\n                for j in range(len(nodePopulation)):\n                    distToSelf = rs.Distance(nodePopulation[j].pos, self.pos)\n                    distToNode = rs.Distance(nodePopulation[j].pos, nodePopulation[i].pos)\n                    if max(distToSelf, distToNode) < d:\n                        # this node is in the lune and blocks\n                        break\n                else:\n                    # prevent creating duplicate Curves\n                    if self.pos not in nodePopulation[i].connected:\n                        connections += [rs.AddCurve((self.pos, nodePopulation[i].pos), 1)]\n                        # label nodes as connected nodes and save them\n                        self.connected += [nodePopulation[i].pos]\n                        nodePopulation[i].connected += [self.pos]\n                        # count times of connections\n                        self.connect_times += 1\n                        nodePopulation[i].connect_times += 1\n        return self\n\n    # calculate horizontal distance between two vertices\n    def horizontal_dist(self, pt1, pt2):\n        return ((pt1[0] - pt2[0])**2 + (pt1[1] - pt2[1])**2)**0.5\n\n    # vertically connect vertices\n    def verticalConnect(self, nodePopulation, connections):\n        for i in range(len(nodePopulation)):\n            # only connect lower vertices to up vertices of other steps\n            if self.up_down == 1 and nodePopulation[i].up_down == 0 and self.pos[2] > nodePopulation[i].pos[2]:\n                if abs(self.pos[2] - nodePopulation[i].pos[2]) >= 0.5*self.interval:\n                    horizontal_distance = self.horizontal_dist(self.pos, nodePopulation[i].pos)\n                    if horizontal_distance <= math.sqrt(self.interval) and self.pos not in nodePopulation[i].connected:\n                        if nodePopulation[i].connect_times <= 3:\n                            connections += [rs.AddCurve((self.pos, nodePopulation[i].pos), 1)]\n                            # label nodes as connected nodes and save them\n                            self.connected += [nodePopulation[i].pos]\n                            nodePopulation[i].connected += [self.pos]\n                            # count times of connections\n                            self.pos += 1\n                            nodePopulation[i].connect_times += 1\n        return self\n\n    def connect(self, nodePopulation, connections):\n        self.connectNeighbors(nodePopulation, connections)\n        self.verticalConnect(nodePopulation, connections)\n\ndef main():\n    # get inpit\n    intX = rs.GetInteger(\"X\", 10)\n    intY = rs.GetInteger(\"Y\", 10)\n    interval = rs.GetInteger(\"set interval between each point\", 10)\n    if_multiple = rs.GetInteger(\"setup two start points = 1 or single start point = 0\", 0)\n    elevation = rs.GetInteger(\"set elevation\", 3)\n    possibility = rs.GetReal(\"set possibility (from 0.1 to 0.9) of branching out stairs\",\n                             0.4, minimum = 0.1, maximum = 0.9)\n    recursion_num = rs.GetInteger(\"set iteration of recursion\", 10)\n\n    # convert if_multiple to Boolean\n    if if_multiple == 0:\n        if_multiple = False\n    elif if_multiple == 1:\n        if_multiple = True\n    else:\n        sys.exit('wrong number, input should be 0 or 1')\n\n    # list of vertices of each step\n    step_node_population = []\n    # list of positions of each step\n    step_list = []\n    # dictionary of placed positions of steps\n    step_population = {}\n    # list of connections between steps\n    connections = []\n    # generate stairs\n    stairs = stairSystem(intX, intY, interval, elevation, recursion_num, if_multiple).pointMatrix().origin().attractor().setPossibility(possibility)\n    stairs.update(step_node_population, step_population, step_list)\n\n    # generate stair connections\n    for each in step_node_population:\n        each.connect(step_node_population, connections)\n    # conver connections into polylines\n    polylines = []\n    join = ghc.JoinCurves(connections)\n    for each in join:\n        polylines += [sc.doc.Objects.AddCurve(each)]\n    rs.DeleteObjects(connections)\n    # group up polylines\n    group = rs.AddGroup(\"polylines\")\n    rs.AddObjectsToGroup(polylines, group)\n\n    # generate solid geometry based on connections\n    # manually select polylines\n    rs.Command(\"_Select\")\n    # generate close subD\n    commandStr = \"_MultiPipe Enter 0.15 on Enter 1 Enter\"\n    rs.Command(commandStr)\n\nmain()\n",
  "language": "python",
  "imports": [
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}