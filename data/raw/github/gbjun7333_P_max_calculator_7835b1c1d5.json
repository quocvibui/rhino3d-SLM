{
  "source_url": "https://github.com/gbjun7333/P_max_calculator/blob/8844e2d7a8f3bd7c387827d6a834114aa901129d/grasshopper/shape_manager.py",
  "repo": "gbjun7333/P_max_calculator",
  "repo_stars": 0,
  "repo_description": "parking capacity calculation system",
  "license": "MIT",
  "filepath": "grasshopper/shape_manager.py",
  "instruction": "Shape manager",
  "code": "from __future__ import annotations\n\n# -*- coding: utf-8 -*-\n# r: pyshp\nimport importlib\nimport os\nfrom typing import List, Tuple, Any, Optional, TYPE_CHECKING, Dict\nimport shapefile\n\n# Rhino-specific imports\nimport Rhino\nimport Rhino.Geometry as geo\nimport ghpythonlib.components as ghcomp\n\n# Local class imports\n# 클래스는 units.py에 정의되어 있다고 가정합니다.\nfrom units import Parcel, Road, Lot, Block\nfrom constants import TOL\nimport utils, units\nfrom pathlib import Path, PureWindowsPath\nfrom datetime import datetime\n\nimportlib.reload(utils)\nimportlib.reload(units)\n\nif TYPE_CHECKING:\n    from units import Block\n\n\nclass ShapefileManager:\n    \"\"\"\n    - 기능 1: SHP 파일로부터 Parcel 객체 생성\n    - 기능 2: Block 객체 리스트를 받아 SHP 파일로 저장\n\n    생성자에서는 파일 경로를 받지 않습니다. 각 기능 메서드에서 경로를 인자로 받습니다.\n    \"\"\"\n\n    def __init__(self) -> None:\n        # 마지막 읽기에 사용한 DBF 인코딩(또는 .cpg에서 추출)\n        self._encoding = None  # type: Optional[str]\n        # 마지막 읽기 소스의 .prj WKT 텍스트\n        self._prj_wkt = None  # type: Optional[str]\n        # Grasshopper 실행 시 작업 디렉토리가 일정하지 않으므로, 모듈 기준 루트를 캐시해둔다.\n        self._module_root = Path(__file__).resolve().parent\n        self._project_root = self._module_root.parent\n        self._last_bundle = {}  # type: Dict[str, Path]\n\n    def _resolve_shapefile_path(self, file_path: Any) -> Path:\n        \"\"\"입력된 SHP 경로 문자열을 운영체제에 맞게 정규화하고 가능한 절대경로를 반환합니다.\n\n        - Windows 스타일 백슬래시(`\\\\`)를 슬래시(`/`)로 치환\n        - `~` 등 사용자 홈 확장\n        - 상대경로일 경우: (1) 현재 작업 디렉토리, (2) 모듈 폴더, (3) 프로젝트 루트에 대해 순차적으로 탐색\n        \"\"\"\n\n        if file_path is None:\n            raise ValueError(\"Shapefile path is empty.\")\n\n        # Grasshopper 입력이 리스트/tuple인 경우 첫 요소 사용\n        if isinstance(file_path, (list, tuple)):\n            if not file_path:\n                raise ValueError(\"Shapefile path list is empty.\")\n            file_path = file_path[0]\n\n        raw_str = str(file_path).strip()\n        if not raw_str:\n            raise ValueError(\"Shapefile path is empty string.\")\n\n        # Windows 스타일 경로는 PureWindowsPath로 먼저 파싱 후 POSIX와 호환되도록 변환\n        if \"\\\\\" in raw_str and \"/\" not in raw_str:\n            # 예: ..\\input_data\\foo.shp, C:\\data\\foo.shp\n            windows_path = PureWindowsPath(raw_str)\n            candidate = Path(windows_path.as_posix())\n        else:\n            normalized = raw_str.replace(\"\\\\\", \"/\")\n            candidate = Path(normalized)\n\n        candidate = candidate.expanduser()\n\n        search_roots = []\n        if candidate.is_absolute():\n            search_roots.append(candidate)\n        else:\n            # 상대경로 그대로 시도 (현재 작업 디렉토리 기준)\n            search_roots.append(Path.cwd() / candidate)\n            # 모듈 위치 기준 상대경로 시도 (grasshopper/)\n            search_roots.append(self._module_root / candidate)\n            # 프로젝트 루트 기준 상대경로 시도 (repo 루트)\n            search_roots.append(self._project_root / candidate)\n\n        tried: List[Path] = []\n        for path in search_roots:\n            try:\n                resolved = path.resolve(strict=False)\n            except Exception:\n                continue\n            tried.append(resolved)\n            if resolved.exists():\n                return resolved\n\n        # 존재하지 않는 경우: 진단을 위해 시도한 경로 정보를 포함한 예외를 발생시킨다.\n        search_msg = (\n            \"\\n\".join(f\"  - {p}\" for p in tried)\n            if tried\n            else \"  (no candidates resolved)\"\n        )\n        raise FileNotFoundError(\n            \"Unable to resolve shapefile path. Tried: \\n\" + search_msg\n        )\n\n    def _find_dataset_file(\n        self, directory: Path, stem: str, suffix: str\n    ) -> Optional[Path]:\n        \"\"\"같은 디렉터리 내에서 대소문자를 무시하고 동일한 스템+확장자를 찾아 Path를 반환합니다.\"\"\"\n\n        expected = directory / f\"{stem}{suffix}\"\n        if expected.exists():\n            return expected\n\n        # 대소문자 다른 파일을 탐색\n        try:\n            for child in directory.iterdir():\n                if (\n                    child.is_file()\n                    and child.stem == stem\n                    and child.suffix.lower() == suffix.lower()\n                ):\n                    return child\n        except Exception:\n            pass\n        return None\n\n    def _validate_shapefile_bundle(self, shp_path: Path) -> Path:\n        \"\"\"필수 구성요소(.shp, .dbf, .shx)가 모두 존재하는지 확인하고 실제 파일 경로를 반환합니다.\"\"\"\n\n        if shp_path.is_dir():\n            raise FileNotFoundError(\n                f\"Shapefile path points to a directory, not a .shp file: {shp_path}\"\n            )\n\n        # 확장자가 빠진 경우 .shp를 기본으로 추가\n        if shp_path.suffix == \"\":\n            shp_path = shp_path.with_suffix(\".shp\")\n\n        directory = shp_path.parent\n        stem = shp_path.stem\n\n        required_exts = [\".shp\", \".dbf\", \".shx\"]\n        optional_exts = [\".prj\", \".cpg\"]\n\n        resolved: Dict[str, Path] = {}\n        missing: List[str] = []\n\n        for ext in required_exts + optional_exts:\n            found = self._find_dataset_file(directory, stem, ext)\n            if found:\n                resolved[ext] = found\n            elif ext in required_exts:\n                missing.append(str(directory / f\"{stem}{ext}\"))\n\n        if missing:\n            missing_paths = \"\\n\".join(f\"  - {p}\" for p in missing)\n            raise FileNotFoundError(\"Missing shapefile component(s):\\n\" + missing_paths)\n\n        # 필수 파일이 모두 존재하면 캐시 후 .shp 경로 반환\n        self._last_bundle = resolved\n        return resolved[\".shp\"]\n\n    def _resolve_output_directory(self, dir_path: Any) -> Path:\n        \"\"\"Shapefile 저장용 출력 디렉토리를 정규화한다.\n\n        - Grasshopper 입력이 비어 있으면 프로젝트 루트의 output_data 디렉토리를 사용\n        - Windows 스타일 경로 백슬래시 처리\n        - 상대 경로는 작업 디렉토리, 모듈 디렉토리, 프로젝트 루트 순으로 탐색\n        \"\"\"\n\n        default_dir = self._project_root / \"output_data\"\n\n        if dir_path is None or (isinstance(dir_path, str) and not dir_path.strip()):\n            dir_path = default_dir\n\n        if isinstance(dir_path, (list, tuple)):\n            dir_path = dir_path[0] if dir_path else default_dir\n\n        raw_str = str(dir_path).strip()\n        if not raw_str:\n            return default_dir\n\n        # Windows 경로 처리\n        if \"\\\\\" in raw_str and \"/\" not in raw_str:\n            candidate = Path(PureWindowsPath(raw_str).as_posix())\n        else:\n            candidate = Path(raw_str.replace(\"\\\\\", \"/\"))\n\n        candidate = candidate.expanduser()\n\n        search_roots = []\n        if candidate.is_absolute():\n            search_roots.append(candidate)\n        else:\n            search_roots.append(Path.cwd() / candidate)\n            search_roots.append(self._module_root / candidate)\n            search_roots.append(self._project_root / candidate)\n\n        tried: List[Tuple[Path, str]] = []\n        for path in search_roots:\n            try:\n                resolved = path.resolve(strict=False)\n            except Exception as e:\n                tried.append((path, f\"resolve error: {e}\"))\n                continue\n\n            target_parent = resolved if resolved.is_dir() else resolved.parent\n            if not target_parent.exists():\n                tried.append((resolved, \"parent missing\"))\n                continue\n\n            if not os.access(str(target_parent), os.W_OK):\n                tried.append((resolved, \"parent not writable\"))\n                continue\n\n            return resolved\n\n        print(\n            \"[ShapefileManager] WARN: output directory candidates unsuitable; using default:\"\n        )\n        for entry, reason in tried:\n            print(f\"  - {entry} ({reason})\")\n\n        # 기본 경로가 없다면 생성 시도에서 다시 오류를 던지도록 그대로 반환\n        return default_dir\n\n    def _get_field_value(\n        self,\n        record: List[Any],\n        fields: List[str],\n        field_name: str,\n        default: Any = \"Unknown\",\n    ) -> Any:\n        \"\"\"레코드에서 특정 필드 이름을 이용해 값을 안전하게 추출합니다.\"\"\"\n        try:\n            index = fields.index(field_name)\n            return record[index]\n        except (ValueError, IndexError):\n            return default\n\n    def _get_part_indices(self, shape: Any) -> List[Tuple[int, int]]:\n        \"\"\"Shape의 각 파트(part)의 시작과 끝 인덱스 리스트를 반환합니다.\"\"\"\n        if not hasattr(shape, \"parts\") or len(shape.parts) <= 1:\n            return [(0, len(shape.points))]\n\n        parts = list(shape.parts) + [len(shape.points)]\n        return [(parts[i], parts[i + 1]) for i in range(len(parts) - 1)]\n\n    def _get_curve_from_points(\n        self, points: List[Tuple[float, float]], start_idx: int, end_idx: int\n    ) -> Optional[geo.PolylineCurve]:\n        \"\"\"점 리스트의 특정 구간으로 PolylineCurve를 생성합니다.\"\"\"\n        if end_idx - start_idx < 3:\n            return None\n\n        # 닫힌 커브인지 확인\n        first_pt, last_pt = points[start_idx], points[end_idx - 1]\n        if first_pt[0] != last_pt[0] or first_pt[1] != last_pt[1]:\n            return None\n\n        curve_points = [geo.Point3d(p[0], p[1], 0) for p in points[start_idx:end_idx]]\n        curve = geo.PolylineCurve(curve_points)\n        return curve if curve and curve.IsValid else None\n\n    def _get_curves_from_shape(\n        self,\n        shape: Any,\n    ) -> Tuple[Optional[geo.PolylineCurve], List[geo.PolylineCurve]]:\n        \"\"\"\n        단일 Shape에서 외부 경계(boundary)와 내부 홀(hole) 커브들을 추출합니다.\n        \"\"\"\n        part_indices = self._get_part_indices(shape)\n\n        boundary_region = None\n        hole_regions = []\n\n        for i, (start_idx, end_idx) in enumerate(part_indices):\n            curve = self._get_curve_from_points(shape.points, start_idx, end_idx)\n            if curve:\n                if i == 0:  # 첫 번째 파트는 외부 경계로 가정\n                    boundary_region = curve\n                else:\n                    hole_regions.append(curve)\n\n        # 파트가 하나이고 닫혀있지 않은 폴리곤 예외 처리\n        if boundary_region is None and len(part_indices) == 1:\n            points = [geo.Point3d(pt[0], pt[1], 0) for pt in shape.points]\n            if len(points) >= 3:\n                if points[0].DistanceTo(points[-1]) > TOL:\n                    points.append(points[0])  # 강제로 닫기\n                curve = geo.PolylineCurve(points)\n                if curve and curve.IsValid:\n                    boundary_region = curve\n\n        return boundary_region, hole_regions\n\n    def _create_parcel_from_shape(\n        self, shape: Any, record: List[Any], fields: List[str]\n    ) -> Optional[Parcel]:\n        \"\"\"Shape와 record 데이터로 단일 Parcel(Lot 또는 Road) 객체를 생성합니다.\"\"\"\n        boundary_region, hole_regions = self._get_curves_from_shape(shape)\n\n        if not boundary_region or not boundary_region.IsValid:\n            return None\n\n        pnu = self._get_field_value(record, fields, \"A1\")\n        jimok = self._get_field_value(record, fields, \"A11\")\n        road_adj = self._get_field_value(record, fields, \"A23\")\n        min_height = self._get_field_value(record, fields, \"min_height\")\n        max_height = self._get_field_value(record, fields, \"max_height\")\n\n        if jimok == \"도로\" or not jimok:\n            parcel = Road(boundary_region, pnu, jimok, record, hole_regions)\n        else:\n            parcel = Lot(\n                boundary_region,\n                pnu,\n                jimok,\n                record,\n                hole_regions,\n                road_adj,\n                max_height,\n                min_height,\n            )\n\n        # 지오메트리 전처리 후 유효한 경우에만 반환\n        return parcel  # if parcel.preprocess_curve() else None\n\n    def get_parcels_from_shapes(self, file_path: str) -> List[Parcel]:\n        \"\"\"\n        모든 Shape로부터 Parcel 객체 리스트를 생성합니다.\n        파일 경로는 이 메서드 호출 시 인자로 전달합니다.\n        \"\"\"\n        shp_path = self._validate_shapefile_bundle(\n            self._resolve_shapefile_path(file_path)\n        )\n\n        # 상세 디버그: 인코딩 순차 시도 + 내부 상태 점검\n        enc_attempts = [\"utf-8\", \"cp949\", None]\n        last_errors = []\n        sf = None\n        for enc in enc_attempts:\n            try:\n                path_for_reader = str(shp_path)\n                if enc:\n                    sf = shapefile.Reader(path_for_reader, encoding=enc)\n                else:\n                    sf = shapefile.Reader(path_for_reader)\n                print(\n                    f\"[ShapefileManager] opened OK with encoding={enc} path={path_for_reader}\"\n                )\n                # 인코딩 기록: 명시적 인코딩을 사용했다면 저장\n                if enc:\n                    self._encoding = enc\n                break\n            except Exception as e:\n                last_errors.append((enc, repr(e)))\n        if sf is None:\n            detail = \"\\n\".join([f\"  - {enc}: {err}\" for enc, err in last_errors])\n            raise RuntimeError(f\"Failed to open shapefile: {shp_path}\\n{detail}\")\n\n        # 원시 내부 속성(필요시) 확인\n        try:\n            print(\"[DEBUG] file_path:\", shp_path)\n            num_shapes = getattr(sf, \"numShapes\", None)\n            if callable(num_shapes):\n                num_shapes = num_shapes()\n            print(\"[DEBUG] numShapes:\", num_shapes if num_shapes is not None else \"n/a\")\n            print(\"[DEBUG] fields raw:\", getattr(sf, \"fields\", \"n/a\"))\n        except Exception as e:\n            print(\"[DEBUG] meta access error:\", e)\n\n        try:\n            shapes = sf.shapes()\n        except Exception as e:\n            raise RuntimeError(f\"Failed to read shapes(): {e}\")\n        try:\n            records = sf.records()\n        except Exception as e:\n            raise RuntimeError(f\"Failed to read records(): {e}\")\n        try:\n            raw_fields = sf.fields[1:]  # 첫 필드는 DeletionFlag\n            fields = [f[0] for f in raw_fields]\n        except Exception as e:\n            raise RuntimeError(f\"Failed to parse fields: {e}\")\n\n        if not fields:\n            print(\"[WARN] No fields parsed; DBF may be missing or corrupt\")\n\n        # 좌표계/인코딩 부가 정보 보존: .prj/.cpg\n        try:\n            prj_path = shp_path.with_suffix(\".prj\")\n            if prj_path.exists():\n                # WKT는 일반 텍스트. 인코딩은 보통 ASCII/UTF-8로 문제 없음\n                self._prj_wkt = prj_path.read_text(encoding=\"utf-8\", errors=\"ignore\")\n        except Exception:\n            pass\n        try:\n            # .cpg 파일이 있다면 인코딩으로 활용 (명시적 인코딩 미사용 시)\n            if not self._encoding:\n                cpg_path = shp_path.with_suffix(\".cpg\")\n                if cpg_path.exists():\n                    enc = cpg_path.read_text(encoding=\"utf-8\", errors=\"ignore\").strip()\n                    if enc:\n                        self._encoding = enc\n        except Exception:\n            pass\n\n        parcels: List[Parcel] = []\n        for shape, record in zip(shapes, records):\n            parcel = self._create_parcel_from_shape(shape, record, fields)\n            if parcel:\n                parcels.append(parcel)\n        return parcels\n\n    # ==============================================================\n    # 저장 기능: Block 리스트를 SHP로 저장\n    # ==============================================================\n    def save_blocks_to_shapefile(self, blocks: List[Block], dir_path: str) -> str:\n        \"\"\"\n        Block.region(폴리곤)을 geometry로 저장하고, Block.layout_score의 4개 점수를 속성으로 기록합니다.\n\n        - 필드: BLOCK_ID, REGION, SHAPE, ROAD, TOPO\n        - geometry: Polygon (단일 외곽 링; 현재 Block.region만 저장)\n        \"\"\"\n        if not blocks:\n            # 빈 입력이면 저장하지 않고 빈 경로 반환\n            return \"\"\n\n        # 출력 디렉토리 준비\n        out_dir = self._resolve_output_directory(dir_path)\n        try:\n            out_dir.mkdir(parents=True, exist_ok=True)\n        except PermissionError as e:\n            raise PermissionError(\n                \"Unable to create output directory due to permission error: {}\\n\"\n                \"Resolved directory: {}\\n\"\n                \"원하는 저장 위치가 쓰기 가능한지 확인해 주세요.\".format(e, out_dir)\n            )\n        except OSError as e:\n            raise OSError(\n                \"Failed to create output directory: {}\\n\"\n                \"Resolved directory: {}\\n\"\n                \"경로를 확인하거나 다른 위치를 지정해 주세요.\".format(e, out_dir)\n            )\n\n        # 날짜 기반 파일명 + 증분: YYYYMMDD_{n}_blocks.shp\n        date_str = datetime.now().strftime(\"%Y%m%d\")\n        n = 1\n        while True:\n            base_name = f\"{date_str}_{n}_blocks\"\n            shp_path = out_dir / f\"{base_name}.shp\"\n            if not shp_path.exists():\n                break\n            n += 1\n\n        # shapefile Writer 설정\n        # 읽기에서 기억한 인코딩을 사용 (기본: utf-8)\n        writer_encoding = self._encoding or \"utf-8\"\n        w = shapefile.Writer(\n            str(shp_path), shapeType=shapefile.POLYGON, encoding=writer_encoding\n        )\n        w.autoBalance = 1\n\n        # 필드 정의 (DBF 제약: 이름 <= 10자)\n        w.field(\"BLOCK_ID\", \"N\")\n        w.field(\"REGION\", \"F\", 10, 5)\n        w.field(\"SHAPE\", \"F\", 10, 5)\n        w.field(\"ROAD\", \"F\", 10, 5)\n        w.field(\"TOPO\", \"F\", 10, 5)\n\n        for block in blocks:\n            # 점 리스트 생성 (폴리라인 근사)\n            pts = utils.get_vertices(block.region)\n            pts = [(pt.X, pt.Y) for pt in pts] + [(pts[0].X, pts[0].Y)]  # 닫기\n\n            if len(pts) < 4:\n                # 최소 3점 + 폐합 필요\n                continue\n\n            # 속성값: layout_score 존재 시 사용, 없으면 0.0 기본값\n            region_s = block.layout_score.region_score\n            shape_s = block.layout_score.shape_score\n            road_s = block.layout_score.road_score\n            topo_s = block.layout_score.topo_score\n\n            # geometry + record 추가\n            w.poly([pts])  # 단일 외곽 링\n            w.record(\n                int(getattr(block, \"id\", -1)),\n                float(region_s),\n                float(shape_s),\n                float(road_s),\n                float(topo_s),\n            )\n\n        # 파일 저장\n        w.close()\n\n        # .prj/.cpg 파일 동반 저장 (읽은 설정 재사용)\n        try:\n            if self._prj_wkt:\n                (shp_path.with_suffix(\".prj\")).write_text(\n                    self._prj_wkt, encoding=\"utf-8\"\n                )\n        except Exception:\n            pass\n        try:\n            if writer_encoding:\n                (shp_path.with_suffix(\".cpg\")).write_text(\n                    writer_encoding, encoding=\"utf-8\"\n                )\n        except Exception:\n            pass\n\n        return str(shp_path)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}