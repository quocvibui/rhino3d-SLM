{
  "source_url": "https://github.com/createchaos/abb_communication/blob/740ea3c6bf93b9b0d03e63a6d56ee8ad748e4e38/src/abb_communication/clients/rfl_robot/robot.py",
  "repo": "createchaos/abb_communication",
  "repo_stars": 3,
  "repo_description": "communication library for abb robot control",
  "license": "NOASSERTION",
  "filepath": "src/abb_communication/clients/rfl_robot/robot.py",
  "instruction": ". . . . . . . . . . . . . . . . . .\r\n.                                 .\r\n.   <<><><>    <<><><>  <<        .\r\n.   <<    ><   <<       <<        .\r\n.   <<><><>    <<><><   <<        .\r\n.   <<  ><    ...",
  "code": "'''\r\n. . . . . . . . . . . . . . . . . .\r\n.                                 .\r\n.   <<><><>    <<><><>  <<        .\r\n.   <<    ><   <<       <<        .\r\n.   <<><><>    <<><><   <<        .\r\n.   <<  ><     <<       <<        .\r\n.   <<   <>    <<       <<        .\r\n.   <<    ><   <<       <<><><>   .\r\n.                                 .\r\n.             GKR 2016/17         .\r\n. . . . . . . . . . . . . . . . . .\r\n\r\nCreated on 09.12.2016\r\n\r\n@author: kathrind, stefanap\r\n'''\r\n\r\n\r\n\r\nfrom abb_communication.geometry import Frame\r\nimport Rhino.Geometry as rg\r\nimport ghpythonlib.components as ghcomp\r\nimport math as m\r\n\r\nfrom communication import ABBCommunication\r\n\r\n\r\nclass Robot(object):\r\n\r\n    #===========================================================================\r\n    def __init__(self, link_geo, base_geo, joint_planes, ip_abb = '192.168.125.1', tool = None):\r\n        ''' the robot class, it contains:\r\n        1) the geometry of the robot\r\n        2) the communication modules to send commands to the ABB arm.\r\n        '''\r\n\r\n        self.link_geo = link_geo\r\n        self.base_geo = base_geo\r\n\r\n        self.joint_planes = joint_planes\r\n        self.tool = tool # has to be set with the Tool class\r\n\r\n        self.origin_plane = rg.Plane.WorldXY\r\n\r\n        self.joint_values = [0,0,0,0,0,0]\r\n\r\n        # transform world to robot origin\r\n        self.T_W_R = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, self.origin_plane)\r\n        # transform robot to world\r\n        self.T_R_W = rg.Transform.PlaneToPlane(self.origin_plane, rg.Plane.WorldXY)\r\n\r\n        geo = self.get_geo_with_rotated_joints_in_world(self.joint_values)\r\n        # --> then self.T_R_TOOL0 and self.T_W_TOOL0 are set\r\n\r\n        self.comm = ABBCommunication(\"ABB\", ip_abb, port_snd=30003, port_rcv=30004)\r\n\r\n        self.colors_links = [ghcomp.ColourRGB(150, 220, 220, 220) for part in link_geo]\r\n        self.colors_base = [ghcomp.ColourRGB(150, 220, 220, 220) for part in base_geo]\r\n\r\n    #===========================================================================\r\n    def set_tool(self, tool):\r\n        ''' sets the tool of the robot using the tool class '''\r\n\r\n        self.tool = tool # shall be of the class Tool\r\n\r\n    #===========================================================================\r\n    def set_robot_origin(self, plane):\r\n        ''' sets to origin plane of the robot '''\r\n\r\n        self.origin_plane = plane\r\n        self.T_W_R = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, self.origin_plane)\r\n        self.T_R_W = rg.Transform.PlaneToPlane(self.origin_plane, rg.Plane.WorldXY)\r\n\r\n    #===========================================================================\r\n    def set_robot_origin_with_measured_base(self, base_plane):\r\n        ''' sets to origin plane of the robot based on a manual measured base '''\r\n\r\n        T = rg.Transform.PlaneToPlane(base_plane, rg.Plane.WorldXY)\r\n        plane = ghcomp.Transform(rg.Plane.WorldXY, T)\r\n\r\n        self.set_robot_origin(plane)\r\n\r\n    #===========================================================================\r\n    def get_tool_plane_in_RCS(self, tool_plane_WCS):\r\n        ''' returns the tool plane in the robot coordinate system from a plane in the world cs'''\r\n\r\n        tool_plane_RCS = ghcomp.Transform(tool_plane_WCS, self.T_R_W)\r\n        return tool_plane_RCS\r\n\r\n    #===========================================================================\r\n    def get_tool_pose_in_RCS(self, tp_WCS):\r\n        ''' returns the tool pose in the robot coordinate system from a plane in the world cs'''\r\n\r\n        frame = Frame(self.get_tool_plane_in_RCS(tp_WCS))\r\n        return frame.get_pose_angle_axis()\r\n\r\n    #===========================================================================\r\n    def get_tool0_plane_in_RCS(self, tp_WCS):\r\n        ''' returns the tool0 plane in the robot coordinate system from a plane in the world cs -\r\n        we want to 'subtract' the tool T from the tool plane in RCS '''\r\n\r\n        tool_plane_in_RCS = self.get_tool_plane_in_RCS(tp_WCS)\r\n\r\n        T_TP_in_zero_W = rg.Transform.PlaneToPlane(self.tool.plane, rg.Plane.WorldXY)\r\n\r\n        tool0_plane_in_RCS = rg.Plane.WorldXY\r\n        tool0_plane_in_RCS.Transform(T_TP_in_zero_W)\r\n\r\n        T_W_TP_in_RCS = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tool_plane_in_RCS)\r\n        tool0_plane_in_RCS.Transform(T_W_TP_in_RCS)\r\n\r\n        return tool0_plane_in_RCS\r\n\r\n    #===========================================================================\r\n    def get_tool_plane_from_pose_quaternion(self, pose_quaternion):\r\n        ''' Returns the tool plane according to the given pose in angle axis. '''\r\n        frame = Frame()\r\n        frame.set_to_pose_quaternion(pose_quaternion)\r\n        return frame.get_plane()\r\n\r\n    #===========================================================================\r\n    def get_tool0_plane_from_pose_quaternion(self, pose_quaternion):\r\n        ''' Returns the tool0 plane according to the given pose in angle axis. '''\r\n        tool_plane_RCS = self.get_tool_plane_from_pose_quaternion(pose_quaternion)\r\n\r\n        # Edit Romana:\r\n        T1 = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tool_plane_RCS)\r\n        T2 = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, self.tool.get_plane())\r\n        tool0_plane_RCS = rg.Plane.WorldXY\r\n        tool0_plane_RCS.Transform(T1 * T2)\r\n\r\n        # Kathrin TODO: this does not work... why??\r\n        #T = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, self.tool.get_plane())\r\n        #tcp_plane_RCS = ghcomp.Transform(tool_plane_RCS, T)\r\n        return tool0_plane_RCS\r\n\r\n    def get_geo_with_rotated_joints_in_world(self, joint_values):\r\n        ''' the joint values (in degrees) serve as the input, the method returns the link geo (and tool geo) and tool0 plane transformed '''\r\n\r\n        # the angles in radians\r\n        joint_values = [m.radians(j) for j in joint_values]\r\n        a1, a2, a3, a4, a5, a6 = joint_values\r\n        L1, L2, L3, L4, L5, L6 = self.link_geo\r\n\r\n        # calculate transformations\r\n        j1, j2, j3, j4, j5, j6 = [rg.Plane(jp) for jp in self.joint_planes]\r\n\r\n        T1 = rg.Transform.Rotation(a1, j1.ZAxis, j1.Origin)\r\n        T2 = T1 * rg.Transform.Rotation(a2, j2.ZAxis, j2.Origin)\r\n        T3 = T2 * rg.Transform.Rotation(a3, j3.ZAxis, j3.Origin)\r\n        T4 = T3 * rg.Transform.Rotation(a4, j4.ZAxis, j4.Origin)\r\n        T5 = T4 * rg.Transform.Rotation(a5, j5.ZAxis, j5.Origin)\r\n        T6 = T5 * rg.Transform.Rotation(a6, j6.ZAxis, j6.Origin)\r\n\r\n        L1_t = ghcomp.Transform(L1, T1)\r\n        L2_t = ghcomp.Transform(L2, T2)\r\n        L3_t = ghcomp.Transform(L3, T3)\r\n        L4_t = ghcomp.Transform(L4, T4)\r\n        L5_t = ghcomp.Transform(L5, T5)\r\n        L6_t = ghcomp.Transform(L6, T6)\r\n\r\n        link_geo_transformed = [L1_t, L2_t, L3_t, L4_t, L5_t, L6_t]\r\n\r\n        tool0_plane_transformed = ghcomp.Transform(j6, T6)\r\n        self.T_R_TOOL0 = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tool0_plane_transformed)\r\n\r\n        link_geo_transformed_world = ghcomp.Transform(link_geo_transformed, self.T_W_R)\r\n        tool0_plane_transformed_world = ghcomp.Transform(tool0_plane_transformed, self.T_W_R)\r\n        base_geo_world = ghcomp.Transform(self.base_geo, self.T_W_R)\r\n\r\n        self.T_W_TOOL0 = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tool0_plane_transformed_world)\r\n\r\n        if self.tool:\r\n            tool_geo_trfd_world = ghcomp.Transform(self.tool.geo, rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tool0_plane_transformed_world))\r\n            return [base_geo_world, link_geo_transformed_world, tool_geo_trfd_world]\r\n        else:\r\n            return [base_geo_world, link_geo_transformed_world]\r\n\r\n\r\n    def get_attachment_planes_for_cables(self, plane_transformer, plane_gripper, joint_values, tool_joint_values, extended = True, transformer_on_axis = 3):\r\n\r\n        tool0_plane_transformed_world = self.get_tool0_plane_from_joint_values_world(joint_values)\r\n\r\n        # the angles in radians\r\n        joint_values = [m.radians(j) for j in joint_values]\r\n        a1, a2, a3, a4, a5, a6 = joint_values\r\n\r\n        # calculate transformations\r\n        j1, j2, j3, j4, j5, j6 = [rg.Plane(jp) for jp in self.joint_planes]\r\n\r\n        T1 = rg.Transform.Rotation(a1, j1.ZAxis, j1.Origin)\r\n        T2 = T1 * rg.Transform.Rotation(a2, j2.ZAxis, j2.Origin)\r\n        T3 = T2 * rg.Transform.Rotation(a3, j3.ZAxis, j3.Origin)\r\n        T4 = T3 * rg.Transform.Rotation(a4, j4.ZAxis, j4.Origin)\r\n        T5 = T4 * rg.Transform.Rotation(a5, j5.ZAxis, j5.Origin)\r\n        T6 = T5 * rg.Transform.Rotation(a6, j6.ZAxis, j6.Origin)\r\n\r\n        if transformer_on_axis == 6: plane_transformer_transformed = ghcomp.Transform(plane_transformer, T6)\r\n        if transformer_on_axis == 4: plane_transformer_transformed = ghcomp.Transform(plane_transformer, T4)\r\n        if transformer_on_axis == 3: plane_transformer_transformed = ghcomp.Transform(plane_transformer, T3)\r\n\r\n        plane_transformer_transformed_world = ghcomp.Transform(plane_transformer_transformed, self.T_W_R)\r\n\r\n        T = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tool0_plane_transformed_world)\r\n        plane_gripper_transformed_world = self.tool.get_transformed_plane_gripper(T, tool_joint_values[0], tool_joint_values[1], plane_gripper, extended = extended)\r\n\r\n        return (plane_transformer_transformed_world, plane_gripper_transformed_world)\r\n\r\n    def get_geo_with_rotated_joints_in_world_with_tool_rot(self, joint_values, tool_joint_values, extended = True):\r\n        ''' the joint values (in degrees) serve as the input, the method returns the link geo (and tool geo) and tool0 plane transformed '''\r\n\r\n        # the angles in radians\r\n        joint_values = [m.radians(j) for j in joint_values]\r\n        a1, a2, a3, a4, a5, a6 = joint_values\r\n        L1, L2, L3, L4, L5, L6 = self.link_geo\r\n\r\n        # calculate transformations\r\n        j1, j2, j3, j4, j5, j6 = [rg.Plane(jp) for jp in self.joint_planes]\r\n\r\n        T1 = rg.Transform.Rotation(a1, j1.ZAxis, j1.Origin)\r\n        T2 = T1 * rg.Transform.Rotation(a2, j2.ZAxis, j2.Origin)\r\n        T3 = T2 * rg.Transform.Rotation(a3, j3.ZAxis, j3.Origin)\r\n        T4 = T3 * rg.Transform.Rotation(a4, j4.ZAxis, j4.Origin)\r\n        T5 = T4 * rg.Transform.Rotation(a5, j5.ZAxis, j5.Origin)\r\n        T6 = T5 * rg.Transform.Rotation(a6, j6.ZAxis, j6.Origin)\r\n\r\n        L1_t = ghcomp.Transform(L1, T1)\r\n        L2_t = ghcomp.Transform(L2, T2)\r\n        L3_t = ghcomp.Transform(L3, T3)\r\n        L4_t = ghcomp.Transform(L4, T4)\r\n        L5_t = ghcomp.Transform(L5, T5)\r\n        L6_t = ghcomp.Transform(L6, T6)\r\n\r\n        link_geo_transformed = [L1_t, L2_t, L3_t, L4_t, L5_t, L6_t]\r\n\r\n        tool0_plane_transformed = ghcomp.Transform(j6, T6)\r\n        self.T_R_TOOL0 = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tool0_plane_transformed)\r\n\r\n        link_geo_transformed_world = ghcomp.Transform(link_geo_transformed, self.T_W_R)\r\n        tool0_plane_transformed_world = ghcomp.Transform(tool0_plane_transformed, self.T_W_R)\r\n        base_geo_world = ghcomp.Transform(self.base_geo, self.T_W_R)\r\n\r\n        self.T_W_TOOL0 = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tool0_plane_transformed_world)\r\n\r\n        if self.tool:\r\n            T = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tool0_plane_transformed_world)\r\n            tool_geo_trfd_world = self.tool.get_transformed_geo_with_tool_transformation(T, tool_joint_values[0], tool_joint_values[1], extended = extended)\r\n            return [base_geo_world, link_geo_transformed_world, tool_geo_trfd_world]\r\n        else:\r\n            return [base_geo_world, link_geo_transformed_world]\r\n\r\n\r\n    def get_tool0_plane_from_joint_values(self, joint_values):\r\n        ''' the joint values (in degrees)'''\r\n\r\n        # the angles in radians\r\n        joint_values = [m.radians(j) for j in joint_values]\r\n        a1, a2, a3, a4, a5, a6 = joint_values\r\n\r\n        # calculate transformations\r\n        j1, j2, j3, j4, j5, j6 = [rg.Plane(jp) for jp in self.joint_planes]\r\n\r\n        T1 = rg.Transform.Rotation(a1, j1.ZAxis, j1.Origin)\r\n        T2 = T1 * rg.Transform.Rotation(a2, j2.ZAxis, j2.Origin)\r\n        T3 = T2 * rg.Transform.Rotation(a3, j3.ZAxis, j3.Origin)\r\n        T4 = T3 * rg.Transform.Rotation(a4, j4.ZAxis, j4.Origin)\r\n        T5 = T4 * rg.Transform.Rotation(a5, j5.ZAxis, j5.Origin)\r\n        T6 = T5 * rg.Transform.Rotation(a6, j6.ZAxis, j6.Origin)\r\n\r\n        tool0_plane_transformed = ghcomp.Transform(j6, T6)\r\n\r\n        return tool0_plane_transformed\r\n\r\n    def get_tool0_pose_from_joint_values(self, joint_values):\r\n        ''' the joint values (in degrees)'''\r\n\r\n        frame = Frame(self.get_tool0_plane_from_joint_values(joint_values))\r\n        return frame.get_pose_quaternion()\r\n\r\n    def get_tool0_plane_from_joint_values_world(self, joint_values):\r\n        ''' the joint values (in degrees)'''\r\n\r\n        tool0_plane_transformed = self.get_tool0_plane_from_joint_values(joint_values)\r\n        tool0_plane_transformed_world = ghcomp.Transform(tool0_plane_transformed, self.T_W_R)\r\n\r\n        return tool0_plane_transformed_world\r\n\r\n    def get_tool0_pose_from_joint_values_world(self, joint_values):\r\n        ''' the joint values (in degrees)'''\r\n\r\n        frame = Frame(self.get_tool0_plane_from_joint_values_world(joint_values))\r\n        return frame.get_pose_quaternion()\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}