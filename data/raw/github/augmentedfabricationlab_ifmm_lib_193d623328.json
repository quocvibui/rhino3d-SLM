{
  "source_url": "https://github.com/augmentedfabricationlab/ifmm_lib/blob/1cc6e87f5b07e0d6bd144f8f24462cc0d0a70fdb/useful/gh_useful.py",
  "repo": "augmentedfabricationlab/ifmm_lib",
  "repo_stars": 0,
  "repo_description": "In situ Fabricatr & Mesh Mould @ EMPA Nest 2017",
  "license": "unknown",
  "filepath": "useful/gh_useful.py",
  "instruction": ". . . . . . . . . . . . . . . . . . . . . \n.                                       .\n.    <<      ><      ><       >< <<     .\n.    < ><   ><<     ><<<    ><    ><<   .\n.    << >< > ><    ><  ><    ...",
  "code": "'''\n. . . . . . . . . . . . . . . . . . . . . \n.                                       .\n.    <<      ><      ><       >< <<     .\n.    < ><   ><<     ><<<    ><    ><<   .\n.    << >< > ><    ><  ><     ><        .  \n.    <<  ><  ><   ><<<<<><      ><      .\n.    <<      >< ><<     ><< ><    ><<   .\n.    <<      ><><<       ><<  >< <<     .\n.                                       .\n.             DFAB 2016/17              .\n. . . . . . . . . . . . . . . . . . . . . \n\nCreated on 22.09.2016\n\n@author: rustr\n'''\n\nimport Grasshopper as gh\nfrom Grasshopper import DataTree as Tree\nfrom Grasshopper.Kernel.Data import GH_Path as Path\nfrom System import Array\nimport Rhino.Geometry as rg\n\ndef gh_component_timer(ghenv, run, interval):\n    if interval <= 0: interval = 1\n    ghComp = ghenv.Component\n    ghDoc = ghComp.OnPingDocument()\n    def callBack(ghDoc):\n        ghComp.ExpireSolution(False)\n    if run:\n        ghDoc.ScheduleSolution(interval, gh.Kernel.GH_Document.GH_ScheduleDelegate(callBack))\n        \n        \ndef list_to_tree(alist, none_and_holes=False, base_path=[0]):\n    \"\"\"\n    Transforms nestings of lists or tuples to a Grasshopper DataTree\n    Usage:\n    mytree = [ [1,2], 3, [],[ 4,[5]] ]\n    a = list_to_tree(mytree)\n    b = list_to_tree(mytree, none_and_holes=True, base_path=[7,1])\n    \"\"\"\n    def process_one_item(alist, tree, track):\n        path = Path(Array[int](track))\n        if len(alist) == 0 and none_and_holes: \n            tree.EnsurePath(path)\n            return\n        for i,item in enumerate(alist):\n            if hasattr(item, '__iter__'): #if list or tuple\n                track.append(i)\n                process_one_item(item, tree, track)\n                track.pop()\n            else:\n                if none_and_holes: \n                    tree.Insert(item, path, i)\n                elif item is not None: \n                    tree.Add(item, path)\n                \n    tree = Tree[object]()\n    if alist is not None: \n        process_one_item(alist, tree, base_path[:])\n    return tree\n\ndef get_bounding_box_multiple_geometries(G):\n    bbmin = []\n    bbmax = []\n    \n    for g in G:\n        bb = g.GetBoundingBox(P)\n        bbmin.append(bb.Min)\n        bbmax.append(bb.Max)\n        \n    minX = min([p.X for p in bbmin])\n    minY = min([p.Y for p in bbmin])\n    minZ = min([p.Z for p in bbmin])\n    \n    maxX = max([p.X for p in bbmax])\n    maxY = max([p.Y for p in bbmax])\n    maxZ = max([p.Z for p in bbmax])\n    \n    B = rg.BoundingBox(rg.Point3d(minX, minY, minZ), rg.Point3d(maxX, maxY, maxZ))\n    return B\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}