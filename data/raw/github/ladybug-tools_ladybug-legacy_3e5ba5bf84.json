{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_SolarFan.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_SolarFan.py",
  "instruction": "Use this component to generate a solar fan for a given test surface and set of solar vectors.  Solar fans essentially illustrate the volume that should be clear of shading in order to provide solar...",
  "code": "# Solar Fan\n#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Mostapha Sadeghipour Roudsari and Chris Mackey <mostapha@ladybug.tools and Chris@MackeyArchitecture.com> \n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to generate a solar fan for a given test surface and set of solar vectors.  Solar fans essentially illustrate the volume that should be clear of shading in order to provide solar access to a test surface for a given set of sun vectors.\nSolar fans are typically used to ensure solar access for park vegetation in the midst of large developments constructed around it.  It can be also used to ensure solar access for windows that might want to use the sun for heating for ceratin hours of the year.\n\n-\nProvided by Ladybug 0.0.69\n    \n    Args:\n        _baseSrf: A surface representing a piece of land (such as a park) or a window for which solar access is desired.\n        _sunVectors: Sun vectors representing hours of the year when sun should be accessible to the baseSrf. sunVectors can be generated using the Ladybug sunPath component.\n        _size_: Input a number here to change how far the solar fan extends from the _baseSrf.  The default is set to 1, which will produce a solar fan that is half as tall as the longest side of the _baseSrf. Note that increasing the height too high can cause the fan to break up into multiple fans due to the resolution of the solar vectors.\n        _runIt: Set to \"True\" to run the analysis and generate a solar fan. Note that, for more than 500 sunVectors, calculation times can take more than a half-minute.\n        noUnion_: By default this component will attempt to boolean union all the solar fans created, sometimes the underlying boolean union rhino operation fails and as a result only some of the solar fans are created.\n        When this happens you can set this input to false and the boolean union operation will not be performed on the solar fans ensuring that all solar fans will be created.\n    Returns:\n        readMe!:...\n        solarFan: Brep representing a solar fan that should be clear of shading in order to ensure solar access to the _baseSrf for the given _sunVectors.\n\"\"\"\nghenv.Component.Name = 'Ladybug_SolarFan'\nghenv.Component.NickName = 'SolarFan'\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"3 | EnvironmentalAnalysis\"\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"3\"\nexcept: pass\n\n\nimport Rhino as rc\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nfrom clr import AddReference\nAddReference('Grasshopper')\nimport Grasshopper.Kernel as gh\nimport math\n\n\n\ndef checkTheInputs():\n    \n    if not _baseSrf!=None:\n        print \"_baseSrf is missing\"\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, \"_baseSrf is missing\")\n        \n        return False, []\n    elif not (_sunVectors and _sunVectors[0]!=None):\n        print \" _sunVectors is missing. You need to either provide a number as a depth or a vector as a sun vector.\"\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, \" _sunVectors is missing. You need to either provide a number as a depth or a vector as a sun vector.\")\n        return False, []\n        \n    sunVectors = []\n    # create vectors from generic type object\n    for v in _sunVectors:\n        sunV = rc.Geometry.Vector3d(v)\n        #sunV.Reverse()\n        sunVectors.append(sunV)\n    \n    \n    return True, sunVectors\n\ndef projectToPlane(geometry, plane, vector):\n    \n    def getTransform():\n        if plane.ZAxis.IsParallelTo(vector)**2 == 1:\n            x = rc.Geometry.Transform.PlanarProjection(plane)\n            return x\n        elif math.sin(rc.Geometry.Vector3d.VectorAngle(plane.ZAxis,vector)) == 1:\n            x = rc.Geometry.Transform.Unset\n            return x\n        \n        originalPlane = plane\n        newPlane = rc.Geometry.Plane(originalPlane.Origin, -vector)\n    \n        z0 = originalPlane.ZAxis\n        z1 = newPlane.ZAxis\n        angle = rc.Geometry.Vector3d.VectorAngle(z0, z1)\n        \n        intersect, axis = rc.Geometry.Intersect.Intersection.PlanePlane(originalPlane, newPlane)\n        \n        if intersect:\n            P2 = rc.Geometry.Plane(originalPlane)\n            P2.XAxis = axis.UnitTangent\n            P2.YAxis = rc.Geometry.Vector3d.CrossProduct(P2.XAxis, P2.ZAxis)\n            \n            beta = 0.5 * math.pi - angle\n            factor = 1.0 / math.sin(beta)\n            project = rc.Geometry.Transform.PlanarProjection(newPlane)\n            rotate = rc.Geometry.Transform.Rotation(z1, z0, originalPlane.Origin)\n            scale = rc.Geometry.Transform.Scale(P2, 1.0, factor, 1.0)\n            x = scale * rotate * project\n            return x\n    \n    geometry.Transform(getTransform())\n    return geometry\n\ndef getOutlineCrvFromSun (geometry, sunVector):\n    planeFromSun = rc.Geometry.Plane(rc.Geometry.Point3d.Origin, sunVector)\n    \n    outlineCrvFromSun = []\n    polylines = geometry.GetOutlines(planeFromSun)\n    [outlineCrvFromSun.append(pl.ToNurbsCurve()) for pl in polylines]\n    \n    return outlineCrvFromSun\n\ndef isShadingPossible(shadingBorder, baseSurfacePlane, sunVector, lb_preparation, printOut = True):\n    # find the points of shadingFace\n    crvPoints = lb_preparation.findDiscontinuity(shadingBorder, style = 4)\n    \n    shadingPts = []\n    nonShadingPts = []\n    thereIsMorePoint = True\n    while len(shadingPts) * len(nonShadingPts) == 0 and thereIsMorePoint:\n        # project to point\n        for pt in crvPoints:\n            projectedPt = projectToPlane(rc.Geometry.Point3d(pt), baseSurfacePlane, sunVector)\n            pVector = rc.Geometry.Vector3d(projectedPt - pt)\n            if pVector != rc.Geometry.Vector3d(0, 0, 0):\n                #print int(math.degrees(rc.Geometry.Vector3d.VectorAngle(sunVector, pVector)))\n                if int(round(math.degrees(rc.Geometry.Vector3d.VectorAngle(sunVector, pVector)))) == 0 or pVector.Length < sc.doc.ModelAbsoluteTolerance:\n                    shadingPts.append(pt)\n                else:\n                    nonShadingPts.append(pt)\n        \n        thereIsMorePoint = False\n    \n    if len(shadingPts) * len(nonShadingPts) != 0:\n        # this is a mixed situation, I need to subdivide toBeShadedFace\n        # and run the study for each part of the surface\n        # the function ideally can be written as a recursive function\n        # but I need to fix the rest of the code and the way I wrote the class\n        # for faces which I'll do later\n        if printOut:\n            print \"The shading surface is on both sides of the glazing surface\" + \\\n                \"\\nMove it to one of the sides and try again!\"\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, \"The shading surface is on both sides of the glazing surface\\nMove it to one of the sides and try again!\")\n        return False\n        \n    elif len(shadingPts)!= 0: return True\n    \n    elif len(nonShadingPts)!=0: return False\n\n\ndef getSrfPlane(brep):\n    cenPt = rc.Geometry.AreaMassProperties.Compute(brep).Centroid\n    # sometimes the center point is not in the right place\n    cenPt = brep.ClosestPoint(cenPt)\n    bool, centerPtU, centerPtV = brep.Faces[0].ClosestPoint(cenPt)\n    normalVector = brep.Faces[0].NormalAt(centerPtU, centerPtV)\n    return rc.Geometry.Plane(cenPt, normalVector)\n\ndef isSrfFacingTheVector(sunV, normalVector):\n    sunVRev = rc.Geometry.Vector3d(sunV)\n    sunVRev.Reverse()\n    #print math.degrees(rc.Geometry.Vector3d.VectorAngle(sunVRev, normalVector))\n    if rc.Geometry.Vector3d.VectorAngle(sunVRev, normalVector) < math.pi/2: return True\n    else: return False\n#mesh the input glazing\n\n\ndef createShadings(baseSrfs, planes, sunVectors, mergeCrvs, lb_preparation):\n    # create shading on planes\n    \n    unionedProjectedCrvsCollection = []\n    firsTime = True\n    \n    for brepCount, brep in enumerate(baseSrfs):\n        unionedProjectedCrvs = []\n        projectedCrvs = []\n        # find the normal of each surface\n        brepPlane = getSrfPlane(brep)\n        normalVector = brepPlane.Normal\n        # mesh the base surface\n        meshedBrep = rc.Geometry.Mesh.CreateFromBrep(brep, rc.Geometry.MeshingParameters.Smooth)[0]\n        \n        for sunV in sunVectors:\n\n            projectedCrv = None\n            #check if the window facing the sun vector\n            isFacingTheSun = isSrfFacingTheVector(sunV, normalVector)\n            \n            if isFacingTheSun:\n\n                # get the view from sun\n                outline = getOutlineCrvFromSun(meshedBrep, sunV)[0]\n\n                # project the outline to the plane\n                try:\n                    projectedCrv = projectToPlane(outline.DuplicateCurve(), planes[brepCount], sunV)\n                    \n                    if not isShadingPossible(projectedCrv, brepPlane, sunV, lb_preparation, False):\n                        \n                        #if brepCount== len(baseSrfs)-1: i = -1\n                        #else: i = 1\n                        i = 1\n                        # try + 1\n                        #if brepCount!= len(baseSrfs)-1:\n                        projectedCrv = projectToPlane(outline.DuplicateCurve(), planes[brepCount + i], sunV)\n\n                        #double check\n                        if not isShadingPossible(projectedCrv, brepPlane, sunV, lb_preparation, False):\n                            # print brepCount\n                            projectedCrv = None\n                            \n                            if brepCount == len(baseSrfs)-1: projectedCrv = None\n                            #else:\n                            #    print brepCount\n                            # try -1\n                            # projectedCrv = projectToPlane(outline.DuplicateCurve(), planes[brepCount - i], sunV)\n                except Exception, e:\n                    #print `e`\n                    pass\n                    print \"Number of planes doesn't match the number of surfaces.\" + \\\n                          \"\\nOne of the shadings won't be created. You can generate the planes manually\" + \\\n                          \"\\nand use optionalPlanes option.\"\n                          \n            if projectedCrv:\n                \n                try: projectedCrvs.extend(projectedCrv)\n                except: projectedCrvs.append(projectedCrv)\n        \n        # find the union the curves with the boundary of the shading\n        if mergeCrvs == True:\n            \n            unionedProjectedCrvs =rc.Geometry.Curve.CreateBooleanUnion(projectedCrvs)\n            \n            if (len(unionedProjectedCrvs) != len(projectedCrvs)) and (noUnion_ == True):\n                # Unable to perform boolean union operation so just return the projectedCrvs\n\n                return projectedCrvs\n            \n            if len(unionedProjectedCrvs) == 0:\n                unionedProjectedCrvs = rc.Geometry.Curve.JoinCurves(projectedCrvs)\n        else:\n            unionedProjectedCrvs = projectedCrvs\n\n        unionedProjectedCrvsCollection.extend(unionedProjectedCrvs)\n        \n    return unionedProjectedCrvsCollection\n\ndef unionAllFans(solarFans):\n    res = []\n    for fanCount in range(0, len(solarFans), 2):\n        try:\n            x = solarFans[fanCount]\n            y = solarFans[fanCount + 1]\n            x.Faces.SplitKinkyFaces(rc.RhinoMath.DefaultAngleTolerance, False)\n            y.Faces.SplitKinkyFaces(rc.RhinoMath.DefaultAngleTolerance, False)\n            a = rc.Geometry.Brep.CreateBooleanUnion([x, y], sc.doc.ModelAbsoluteTolerance)\n            if a == None:\n                a = [solarFans[fanCount], solarFans[fanCount + 1]]\n        except:\n            a = [solarFans[fanCount]]\n        \n        if a:\n            res.extend(a)\n    return res\n\ndef main(sunVectors):\n    \n    # import the classes\n    if sc.sticky.has_key('ladybug_release'):\n        try:\n            if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): return -1\n            if sc.sticky['ladybug_release'].isInputMissing(ghenv.Component): return -1\n        except:\n            warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n            \"Use updateLadybug component to update userObjects.\\n\" + \\\n            \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n            \"into canvas and try again.\"\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n            return -1\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n        lb_mesh = sc.sticky[\"ladybug_Mesh\"]()\n        lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\n        \n        # get the genter of the base surface.\n        baseSrfCenPt = rc.Geometry.AreaMassProperties.Compute(_baseSrf).Centroid\n        # mesh the base surface to ensure that we can get vertices all around the object for the bounding box.\n        _baseSrfMeshed = rc.Geometry.Mesh.CreateFromBrep(_baseSrf, rc.Geometry.MeshingParameters.Smooth)[0]\n        # generate a bounding box around the base surfaces and extract dimensions for use with generating the plane to project to.\n        points = []\n        for point in _baseSrfMeshed.Vertices:\n            points.append(rc.Geometry.Point3d(point))\n        baseSrfBBox = rc.Geometry.BoundingBox(points)\n        baseSrfBox = rc.Geometry.Box(baseSrfBBox)\n        # from the bounding box dimnesions, deriva a point to be used to generate the intersection plane.\n        X = baseSrfBox.X[1] - baseSrfBox.X[0]\n        Y = baseSrfBox.Y[1] - baseSrfBox.Y[0]\n        if X>Y:planeHeight = 0.5*X\n        else: planeHeight = 0.5*Y\n        try: Z = ((float(_size_))*planeHeight) + baseSrfBox.Z[1]\n        except: Z = planeHeight + baseSrfBox.Z[1]\n        planePt = rc.Geometry.Point3d(baseSrfCenPt.X, baseSrfCenPt.Y, Z)\n        # generate the intersection plane\n        plane = [rc.Geometry.Plane(planePt, rc.Geometry.Vector3d.ZAxis)]\n        \n        # create the outline curve shaded by the solar vectors. \n        shadingCrvs = createShadings([_baseSrf], plane, sunVectors, True, lb_preparation)\n        \n        if len(shadingCrvs) == 0:\n            try:\n                _baseSrf.Flip()\n                \n                shadingCrvs = createShadings([_baseSrf], plane, sunVectors, True, lb_preparation)\n\n            except: pass\n        \n        if noUnion_ == False:\n            # When a boolean union is conducted the following works well\n            # if one of the shading curves is contained inside the other, it can be deleted from the solar fan and can speed up the calculation down the line.\n            shdCrv2 = []\n            for curve in shadingCrvs:\n                if rc.Geometry.AreaMassProperties.Compute(curve).Area > rc.Geometry.AreaMassProperties.Compute(_baseSrf).Area:\n                    shdCrv2.append(curve)\n                \n        else:\n            # When a boolean union is not conducted the above code doesn't append anything to shdCrv2\n            shdCrv2 = shadingCrvs\n            \n        sortedCrvs = sorted(shdCrv2, key=lambda curve: rc.Geometry.AreaMassProperties.Compute(curve).Area)\n        largestCrv = sortedCrvs[-1]\n        finalShdCrvs =[]\n        \n        for curve in sortedCrvs:\n            if str(rc.Geometry.Curve.PlanarClosedCurveRelationship(largestCrv, curve, plane[0], sc.doc.ModelAbsoluteTolerance)) != 'BInsideA':\n                finalShdCrvs.append(curve)\n            else: pass\n        \n        # duplicate the border around the base surface, which will be used to loft the solar fan\n        baseSrfCrv = rc.Geometry.Curve.JoinCurves(_baseSrf.DuplicateEdgeCurves())[0]\n        # get a point from the center of the shading curve to a new seam to adjust the seam on the shading curve.\n        seamVectorPt = rc.Geometry.Vector3d((baseSrfCrv.PointAtStart.X - baseSrfCenPt.X)*planeHeight, (baseSrfCrv.PointAtStart.Y - baseSrfCenPt.Y)*planeHeight, 0)\n        # adjust the seam of the shading curves.\n        shadingCrvAdjust = []\n        for curve in finalShdCrvs:\n            try:\n                curve.Reverse()\n                curveParameter = curve.ClosestPoint(rc.Geometry.Intersect.Intersection.CurveCurve(curve, rc.Geometry.Line(rc.Geometry.AreaMassProperties.Compute(curve).Centroid, seamVectorPt).ToNurbsCurve(), sc.doc.ModelAbsoluteTolerance, sc.doc.ModelAbsoluteTolerance)[0].PointA)[1]\n                curveParameterRound = round(curveParameter)\n                curveParameterTol = round(curveParameter, (len(list(str(sc.doc.ModelAbsoluteTolerance)))-2))\n                if curveParameterRound + sc.doc.ModelAbsoluteTolerance > curveParameter and curveParameterRound - sc.doc.ModelAbsoluteTolerance < curveParameter:\n                    curve.ChangeClosedCurveSeam(curveParameterRound)\n                    shadingCrvAdjust.append(curve)\n                else:\n                    curve.ChangeClosedCurveSeam(curveParameterTol)\n                    if curve.IsClosed == True:\n                        shadingCrvAdjust.append(curve)\n                    else:\n                        curve.ChangeClosedCurveSeam(curveParameterTol+sc.doc.ModelAbsoluteTolerance)\n                        if curve.IsClosed == True:\n                            shadingCrvAdjust.append(curve)\n                        else:\n                            curve.ChangeClosedCurveSeam(curveParameterTol-sc.doc.ModelAbsoluteTolerance)\n                            if curve.IsClosed == True:\n                                shadingCrvAdjust.append(curve)\n                            else:\n                                curve.ChangeClosedCurveSeam(curveParameter)\n                                curve.MakeClosed(sc.doc.ModelAbsoluteTolerance)\n                                shadingCrvAdjust.append(curve)\n            except: shadingCrvAdjust.append(curve)\n        \n        # loft the shading curves with the base curve and generate a surface to cap the loft.\n        solarFanInit = []\n        shadingSrfs =[]\n        for curve in shadingCrvAdjust:\n            try:\n                solarFanInit.append(rc.Geometry.Brep.CreateFromLoft([curve, baseSrfCrv], rc.Geometry.Point3d.Unset, rc.Geometry.Point3d.Unset, rc.Geometry.LoftType.Normal, False)[0])\n                shadingSrfs.append(rc.Geometry.Brep.CreatePlanarBreps(curve)[0])\n            except: pass\n        \n        #See if the loft has failed for any of the vectors.  This can happen if vectors are too close to being parallel to the input surface.\n        if len(solarFanInit) != len(shadingCrvAdjust):\n            warning = \"Some of your input solar vectors are almost parallel to your input _baseSrf and this is causing the operations in the component to fail.  Either get rid of the vectors that are nearly parallel to your _baseSrf, or drop down the size of the fan to a very small level to get a true fan.\"\n            print warning\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n            return -1\n        else:\n            # close the brep of the solar fan\n            for brepCount, brep in enumerate(solarFanInit):\n                brep.Join(_baseSrf, sc.doc.ModelAbsoluteTolerance, True)\n                brep.Join(shadingSrfs[brepCount], sc.doc.ModelAbsoluteTolerance, True)\n            \n            # if more than one solar fan solids have been produced, resulting from multiple shading curves being produced, try to boolean union them together into one solar fan.\n            if len(solarFanInit) > 1:\n                listLength = len(solarFanInit)\n                solarFanFinal = solarFanInit\n                count  = 0\n                while len(solarFanFinal) > 1 and count < int(listLength/2) + 10:\n                    solarFanFinal = unionAllFans(solarFanFinal)\n                    count += 1\n                \n                if solarFanFinal == None or len(solarFanFinal) > 1:\n                    solarFanFinal = solarFanInit\n                    print \"Attempt to Boolean Union multiple solar fans into one failed.  Component will return multiple solar fans.  Try decreasing the '_adjustScale' parameter or using a greater timestep of solar vectors if a single solar fan is desired.\" \n            else:\n                solarFanFinal = solarFanInit\n            \n            return solarFanFinal\n        \n    else:\n        print \"You should first let Ladybug fly...\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"You should first let Ladybug fly...\")\n        return -1\n\ndef giveWarning(warningMsg):\n    w = gh.GH_RuntimeMessageLevel.Warning\n    ghenv.Component.AddRuntimeMessage(w, warningMsg)\n\n\nif _runIt:\n    checkList, sunVectors = checkTheInputs()\nelse:\n    print \"Set _runIt to True!\"\n    checkList = False\n\nif checkList:\n\n    solarFan = main(sunVectors)\n    if solarFan!=-1:\n        print \"Solar fan calculation is done!\"\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}