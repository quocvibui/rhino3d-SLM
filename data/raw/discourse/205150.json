{
  "source_url": "https://discourse.mcneel.com/t/public-splitedge-method-for-brep-in-rhinocommon-api/205150",
  "topic_id": 205150,
  "title": "Public SplitEdge method for Brep in RhinoCommon API",
  "question": "Hello Rhino developers,\n\n\nI have encountered a limitation in the RhinoCommon API that prevents automation of certain modeling workflows. I would like to request an enhancement to the API.\n\n\nProblem description:\n\n\nIn the Rhino UI, the \n_SplitEdge\n command allows users to split a Brep edge at specified points, resulting in new separate edges within the Brep topology.\n\nHowever, in the public API (RhinoCommon, both C# and Python), there is currently no way to programmatically split a Brep edge so that new edges appear in the Brep.\n\nThe method \nBrepEdge.Split(t)\n only returns a curve, but does not alter the underlying Brep topology or create new edges on the Brep.\n\n\nWhy this matters:\n\n\n\n\nIt is not possible to create an automated plugin that splits Brep edges at intersection points with curves or surfaces in one step.\n\n\nFor complex models with many edges, manual splitting is extremely time-consuming and error-prone.\n\n\nDuplicating edges as curves and splitting those curves does not solve the problem, since the result is just a set of auxiliary curves, not new Brep edges.\n\n\n\n\nHere is a sample C# code illustrating an attempt to programmatically split Brep edges using RhinoCommon:\n\n\nusing System.Collections.Generic;\nusing Rhino;\nusing Rhino.Commands;\nusing Rhino.DocObjects;\nusing Rhino.Geometry;\nusing Rhino.Input.Custom;\nusing Rhino.Geometry.Intersect;\n\npublic class SplitMultiEdgesCommand : Command\n{\n    public SplitMultiEdgesCommand()\n    {\n        Instance = this;\n    }\n    public static SplitMultiEdgesCommand Instance { get; private set; }\n    public override string EnglishName => \"SplitMultiEdges\";\n\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\n    {\n        // 1. Select edges (SubObject)\n        var go = new GetObject();\n        go.SetCommandPrompt(\"Select edges (sub-objects)\");\n        go.GeometryFilter = ObjectType.EdgeFilter;\n        go.SubObjectSelect = true;\n        go.EnablePreSelect(false, true);\n        go.GetMultiple(1, 0);\n        if (go....",
  "code_blocks": [
    {
      "code": "// #! csharp\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Rhino;\n\nRhino.DocObjects.ObjRef ob;\n\nRhino.Commands.Result res = Rhino.Input.RhinoGet.GetOneObject(\n    \"select brep edge\",\n    false,\n    Rhino.DocObjects.ObjectType.EdgeFilter,\n    out ob\n);\n\nif(res==Rhino.Commands.Result.Success && ob != null) {\n    Rhino.Geometry.Brep brep = ob.Brep();\n    Rhino.Geometry.ComponentIndex ci = ob.GeometryComponentIndex;\n    Console.WriteLine($\"{ci.Index}\");\n   \n    Rhino.Geometry.BrepEdge bredge = brep.Edges[ci.Index];\n    List<double> paramlist = new List<double>(1);\n    paramlist.Add(bredge.Domain.Mid);\n    brep.Edges.SplitEdgeAtParameters(ci.Index, paramlist.ToList());\n    brep.Compact();\n\n    Rhino.Geometry.Brep nbrep = brep.DuplicateBrep();\n    System.Guid nguid = __rhino_doc__.Objects.AddBrep(nbrep);\n    Console.WriteLine($\"Added object with GUID {nguid}\");\n}\n\n__rhino_doc__.Views.Redraw();",
      "language": "csharp",
      "author": "nathanletwory",
      "post_number": 2,
      "is_solution": false
    },
    {
      "code": "// This script attempts to split multiple selected edges of a Brep at intersections with selected curves.\n// For each Brep, it tries to split all selected edges, but only one edge actually gets split.\n\nusing System.Collections.Generic;\nusing Rhino;\nusing Rhino.Commands;\nusing Rhino.DocObjects;\nusing Rhino.Geometry;\nusing Rhino.Input.Custom;\nusing Rhino.Geometry.Intersect;\n\npublic class MultiEdgeSplitTestCommand : Command\n{\n    public override string EnglishName => \"MultiEdgeSplitTest\";\n\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\n    {\n        var go = new GetObject();\n        go.SetCommandPrompt(\"Select Brep edges (sub-objects)\");\n        go.GeometryFilter = ObjectType.EdgeFilter;\n        go.SubObjectSelect = true;\n        go.EnablePreSelect(false, true);\n        go.GetMultiple(1, 0);\n        if (go.CommandResult() != Result.Success)\n            return go.CommandResult();\n\n        var go2 = new GetObject();\n        go2.SetCommandPrompt(\"Select curves for splitting\");\n        go2.GeometryFilter = ObjectType.Curve;\n        go2.DeselectAllBeforePostSelect = false;\n        go2.GetMultiple(1, 0);\n        if (go2.CommandResult() != Result.Success)\n            return go2.CommandResult();\n\n        List<Curve> knives = new List<Curve>();\n        for (int i = 0; i < go2.ObjectCount; i++)\n        {\n            var crv = go2.Object(i).Curve();\n            if (crv != null)\n                knives.Add(crv.DuplicateCurve());\n        }\n        if (knives.Count == 0)\n            return Result.Cancel;\n\n        // Group selected edges by their Brep\n        var brepEdgeMap = new Dictionary<Brep, List<int>>();\n        var brepGuidMap = new Dictionary<Brep, System.Guid>();\n        foreach (var edgeRef in go.Objects())\n        {\n            var edge = edgeRef.Edge();\n            var brep = edge.Brep;\n            if (!brepEdgeMap.ContainsKey(brep))\n            {\n                brepEdgeMap[brep] = new List<int>();\n                brepGuidMap[brep] = edgeRef.ObjectId;\n            }\n            if (!brepEdgeMap[brep].Contains(edge.EdgeIndex))\n                brepEdgeMap[brep].Add(edge.EdgeIndex);\n        }\n\n        double tol = doc.ModelAbsoluteTolerance;\n\n        foreach (var kv in brepEdgeMap)\n        {\n            var brep = kv.Key;\n            var edgeIndices = new List<int>(kv.Value);\n            var brepGuid = brepGuidMap[brep];\n\n            // Try to split each selected edge\n            foreach (var ei in edgeIndices)\n            {\n                if (ei < 0 || ei >= brep.Edges.Count)\n                    continue;\n\n                var edgeCurve = brep.Edges[ei].DuplicateCurve();\n                if (edgeCurve == null)\n                    continue;\n\n                List<double> splitParams = new List<double>();\n                foreach (var knife in knives)\n                {\n                    var x = Intersection.CurveCurve(edgeCurve, knife, tol, tol);\n                    if (x != null)\n                        foreach (var it in x)\n                        {\n                            double t;\n                            if (edgeCurve.ClosestPoint(it.PointA, out t))\n                                splitParams.Add(t);\n                        }\n                }\n                if (splitParams.Count > 0)\n                {\n                    splitParams.Sort();\n                    // Remove duplicate parameters\n                    for (int i = splitParams.Count - 1; i > 0; i--)\n                        if (System.Math.Abs(splitParams[i] - splitParams[i - 1]) < tol)\n                            splitParams.RemoveAt(i);\n\n                    brep.Edges.SplitEdgeAtParameters(ei, splitParams);\n                }\n            }\n            doc.Objects.Replace(brepGuid, brep);\n        }\n\n        doc.Views.Redraw();\n        RhinoApp.WriteLine(\"Done!\");\n        return Result.Success;\n    }\n}",
      "language": "csharp",
      "author": "leex",
      "post_number": 4,
      "is_solution": false
    },
    {
      "code": "// #! csharp\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Rhino;\n\nRhino.DocObjects.ObjRef[] obs;\n\nRhino.Commands.Result res = Rhino.Input.RhinoGet.GetMultipleObjects(\n    \"select brep edges\",\n    false,\n    Rhino.DocObjects.ObjectType.EdgeFilter,\n    out obs\n);\n\nif(res==Rhino.Commands.Result.Success && obs != null) {\n    Rhino.Geometry.Brep brep = null;\n    foreach(var ob in obs) {\n        Rhino.DocObjects.RhinoObject rhob = ob.Object();\n        if(brep == null) {\n            brep = ob.Brep();\n        }\n        Rhino.Geometry.ComponentIndex ci = ob.GeometryComponentIndex;\n        Console.WriteLine($\"{rhob.Id} {ci.Index}\");\n        Rhino.Geometry.BrepEdge bredge = brep.Edges[ci.Index];\n        \n        List<double> paramlist = new List<double>(1);\n        paramlist.Add(bredge.Domain.ParameterAt(0.25));\n        paramlist.Add(bredge.Domain.Mid);\n        paramlist.Add(bredge.Domain.ParameterAt(0.75));\n        brep.Edges.SplitEdgeAtParameters(ci.Index, paramlist.ToList());        \n    }\n    brep.Compact();\n    Rhino.Geometry.Brep nbrep = brep.DuplicateBrep();\n    System.Guid nguid = __rhino_doc__.Objects.AddBrep(nbrep);\n    Console.WriteLine($\"Added object with GUID {nguid}\");\n}\n\n__rhino_doc__.Views.Redraw();",
      "language": "csharp",
      "author": "nathanletwory",
      "post_number": 5,
      "is_solution": false
    },
    {
      "code": "using System;\nusing System.Collections.Generic;\nusing Rhino;\nusing Rhino.Commands;\nusing Rhino.DocObjects;\nusing Rhino.Geometry;\nusing Rhino.Geometry.Intersect;\nusing Rhino.Input;\nusing Rhino.Input.Custom;\n\npublic class SplitMultiEdgesCommand : Command\n{\n    public override string EnglishName => \"SplitMultiEdges\";\n\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\n    {\n        // 1. Select edges\n        ObjRef[] obs;\n        var res = RhinoGet.GetMultipleObjects(\n            \"Select edges to split\",\n            false,\n            ObjectType.EdgeFilter,\n            out obs\n        );\n        if (res != Result.Success || obs == null)\n            return res;\n\n        // List of (Guid, ComponentIndex) pairs to highlight edges\n        var highlightEdgeRefs = new List<(Guid, ComponentIndex)>();\n\n        // Edges grouped by Brep object\n        var objEdgeMap = new Dictionary<Guid, List<int>>();\n        var objRefMap = new Dictionary<Guid, ObjRef>();\n        foreach (var ob in obs)\n        {\n            var rhObj = ob.Object();\n            if (rhObj == null) continue;\n            var id = rhObj.Id;\n            int edgeIdx = ob.GeometryComponentIndex.Index;\n            if (edgeIdx < 0) continue;\n\n            if (!objEdgeMap.ContainsKey(id))\n            {\n                objEdgeMap[id] = new List<int>();\n                objRefMap[id] = ob;\n            }\n            if (!objEdgeMap[id].Contains(edgeIdx))\n                objEdgeMap[id].Add(edgeIdx);\n\n            // For subobject highlighting\n            highlightEdgeRefs.Add((id, new ComponentIndex(ComponentIndexType.BrepEdge, edgeIdx)));\n        }\n\n        // Exclude the source Breps from being picked as cutting objects\n        var excludeBrepIds = new HashSet<Guid>();\n        foreach (var ob in obs)\n        {\n            var rhObj = ob.Object();\n            if (rhObj != null)\n                excludeBrepIds.Add(rhObj.Id);\n        }\n\n        // 2. Select cutting objects or Point option\n        var getKnife = new GetObject();\n        getKnife.SetCommandPrompt(\"Select cutting objects\");\n        getKnife.GeometryFilter = ObjectType.Curve | ObjectType.Surface | ObjectType.Brep;\n        getKnife.SubObjectSelect = false;\n        getKnife.GroupSelect = true;\n        getKnife.SetCustomGeometryFilter((rhObj, geometry, ci) => !excludeBrepIds.Contains(rhObj.Id));\n\n        // Add the Point option (split by points mode)\n        var optPoint = new OptionToggle(false, \"No\", \"Yes\");\n        getKnife.AddOptionToggle(\"Point\", ref optPoint);\n\n        bool usePoints = false;\n        List<ObjRef> knifeRefs = new List<ObjRef>();\n\n        while (true)\n        {\n            var resGet = getKnife.GetMultiple(1, 0);\n            if (getKnife.CommandResult() != Result.Success)\n                return getKnife.CommandResult();\n\n            if (getKnife.OptionIndex() > 0)\n            {\n                if (optPoint.CurrentValue)\n                {\n                    usePoints = true;\n                    break;\n                }\n                else\n                {\n                    continue;\n                }\n            }\n            if (getKnife.ObjectCount > 0)\n            {\n                for (int i = 0; i < getKnife.ObjectCount; i++)\n                    knifeRefs.Add(getKnife.Object(i));\n                break;\n            }\n        }\n\n        if (!usePoints && knifeRefs.Count == 0)\n            return Result.Cancel;\n\n        double tol = doc.ModelAbsoluteTolerance;\n\n        // 3. Prepare knives or split points\n        List<Curve> knives = new List<Curve>();\n        List<Brep> brepKnives = new List<Brep>();\n        List<Point3d> splitPoints = new List<Point3d>();\n\n        // For selecting split edges by points\n        var toSelect = new List<(Guid, int)>();\n\n        if (usePoints)\n        {\n            // --- HIGHLIGHT selected edges ---\n            foreach (var (objId, compIdx) in highlightEdgeRefs)\n            {\n                var rhObj = doc.Objects.FindId(objId);\n                if (rhObj != null)\n                    rhObj.HighlightSubObject(compIdx, true);\n            }\n            doc.Views.Redraw();\n\n            // Allow picking points only on selected edges\n            var edgeCurves = new List<Curve>();\n            foreach (var ob in obs)\n            {\n                var brep = ob.Brep();\n                int edgeIdx = ob.GeometryComponentIndex.Index;\n                if (brep != null && edgeIdx >= 0 && edgeIdx < brep.Edges.Count)\n                    edgeCurves.Add(brep.Edges[edgeIdx].DuplicateCurve());\n            }\n\n            RhinoApp.WriteLine(\"Pick split points on selected edges (multiple, Enter to finish)\");\n            while (true)\n            {\n                GetPoint gp = new GetPoint();\n                gp.SetCommandPrompt(\"Pick split point (Enter to finish)\");\n                gp.AcceptNothing(true);\n\n                // Here is the problem: there is not enough functionality to freely snap the cursor between multiple BrepEdge curves.\n                // Methods like GetPoint.Constrain(crv, false) in a loop for each edge,\n                // or using the GetPoint.Constrain(Curve[], false) overload, do not solve the issue.\n                // The cursor always snaps only to the first edge in the list and cannot freely move between edges as it does for polylines or SubD.\n\n                foreach (var crv in edgeCurves)\n                    gp.Constrain(crv, false);\n                // Alternatively (if available):\n                // gp.Constrain(edgeCurves.ToArray(), false);\n\n                var result = gp.Get();\n                if (result == GetResult.Point)\n                {\n                    Point3d pt = gp.Point();\n                    bool onEdge = false;\n                    foreach (var crv in edgeCurves)\n                    {\n                        double t;\n                        if (crv.ClosestPoint(pt, out t) && crv.PointAt(t).DistanceTo(pt) < tol * 10)\n                        {\n                            splitPoints.Add(crv.PointAt(t));\n                            onEdge = true;\n                            break;\n                        }\n                    }\n                    if (!onEdge)\n                    {\n                        RhinoApp.WriteLine(\"Pick a point ON the selected edges!\");\n                        continue;\n                    }\n                }\n                else\n                {\n                    break;\n                }\n            }\n\n            // --- REMOVE HIGHLIGHT ---\n            foreach (var (objId, compIdx) in highlightEdgeRefs)\n            {\n                var rhObj = doc.Objects.FindId(objId);\n                if (rhObj != null)\n                    rhObj.HighlightSubObject(compIdx, false);\n            }\n            doc.Views.Redraw();\n\n            if (splitPoints.Count == 0)\n            {\n                RhinoApp.WriteLine(\"No split points selected.\");\n                return Result.Cancel;\n            }\n        }\n        else\n        {\n            foreach (var kr in knifeRefs)\n            {\n                var crv = kr.Curve();\n                if (crv != null)\n                {\n                    knives.Add(crv.DuplicateCurve());\n                    continue;\n                }\n                var br = kr.Brep();\n                if (br != null)\n                {\n                    brepKnives.Add(br);\n                    continue;\n                }\n                var srf = kr.Surface();\n                if (srf != null)\n                {\n                    brepKnives.Add(Brep.CreateFromSurface(srf));\n                }\n            }\n\n            if (knives.Count == 0 && brepKnives.Count == 0)\n            {\n                RhinoApp.WriteLine(\"No cutting objects selected.\");\n                return Result.Cancel;\n            }\n        }\n\n        // Only count actually split edges and their segments\n        int totalSplitSegments = 0;\n        int splitEdgeCount = 0;\n\n        // 4. For each Brep, split all selected edges and replace the object\n        foreach (var kv in objEdgeMap)\n        {\n            var objId = kv.Key;\n            var edgeIndices = kv.Value;\n\n            var ob = objRefMap[objId];\n            var brep = ob.Brep();\n            if (brep == null)\n                continue;\n\n            var edgeSplitParams = new Dictionary<int, List<double>>();\n            foreach (int edgeIdx in edgeIndices)\n            {\n                if (edgeIdx < 0 || edgeIdx >= brep.Edges.Count)\n                    continue;\n\n                var bredge = brep.Edges[edgeIdx];\n                var edgeCurve = bredge.DuplicateCurve();\n                if (edgeCurve == null)\n                    continue;\n\n                List<double> paramlist = new List<double>();\n\n                if (usePoints)\n                {\n                    foreach (var pt in splitPoints)\n                    {\n                        double t;\n                        if (edgeCurve.ClosestPoint(pt, out t))\n                        {\n                            if (edgeCurve.PointAt(t).DistanceTo(pt) < tol * 10)\n                                paramlist.Add(t);\n                        }\n                    }\n                }\n                else\n                {\n                    foreach (var knife in knives)\n                    {\n                        var x = Rhino.Geometry.Intersect.Intersection.CurveCurve(edgeCurve, knife, tol, tol);\n                        if (x != null)\n                        {\n                            foreach (var it in x)\n                            {\n                                double t;\n                                if (edgeCurve.ClosestPoint(it.PointA, out t))\n                                    paramlist.Add(t);\n                            }\n                        }\n                    }\n                    foreach (var bknife in brepKnives)\n                    {\n                        Curve[] overlapCurves;\n                        Point3d[] intersectionPoints;\n                        bool found = Rhino.Geometry.Intersect.Intersection.CurveBrep(edgeCurve, bknife, tol, out overlapCurves, out intersectionPoints);\n                        if (found && intersectionPoints != null && intersectionPoints.Length > 0)\n                        {\n                            foreach (var pt in intersectionPoints)\n                            {\n                                double t;\n                                if (edgeCurve.ClosestPoint(pt, out t))\n                                    paramlist.Add(t);\n                            }\n                        }\n                    }\n                }\n\n                if (paramlist.Count > 0)\n                {\n                    paramlist.Sort();\n                    for (int i = paramlist.Count - 1; i > 0; i--)\n                        if (Math.Abs(paramlist[i] - paramlist[i - 1]) < tol)\n                            paramlist.RemoveAt(i);\n                    edgeSplitParams[edgeIdx] = paramlist;\n                }\n            }\n\n            // Only count actually split edges (those with split parameters)\n            foreach (int edgeIdx in edgeIndices)\n            {\n                if (edgeSplitParams.ContainsKey(edgeIdx) && edgeSplitParams[edgeIdx].Count > 0)\n                {\n                    splitEdgeCount += 1;\n                    totalSplitSegments += edgeSplitParams[edgeIdx].Count + 1;\n                    if (usePoints)\n                        toSelect.Add((objId, edgeIdx));\n                }\n            }\n\n            // Split edges in descending index order\n            var sortedEdgeIndices = new List<int>(edgeSplitParams.Keys);\n            sortedEdgeIndices.Sort();\n            sortedEdgeIndices.Reverse();\n\n            foreach (int edgeIdx in sortedEdgeIndices)\n            {\n                brep.Edges.SplitEdgeAtParameters(edgeIdx, edgeSplitParams[edgeIdx]);\n            }\n\n            brep.Compact();\n\n            doc.Objects.Replace(objId, brep);\n        }\n\n        doc.Views.Redraw();\n\n        // Select actually split edges (SubObject) if working by points\n        if (usePoints && toSelect.Count > 0)\n        {\n            foreach (var (objId, edgeIdx) in toSelect)\n            {\n                var rhObj = doc.Objects.FindId(objId);\n                if (rhObj != null)\n                {\n                    var ci = new ComponentIndex(ComponentIndexType.BrepEdge, edgeIdx);\n                    rhObj.SelectSubObject(ci, true, true, true);\n                }\n            }\n            doc.Views.Redraw();\n        }\n\n        // Final message (numbers only)\n        RhinoApp.WriteLine($\"{splitEdgeCount} edges split into {totalSplitSegments} segments.\");\n\n        return Result.Success;\n    }\n}",
      "language": "csharp",
      "author": "leex",
      "post_number": 6,
      "is_solution": false
    },
    {
      "code": "// Author: leex\n// Date: 2025-06-14\n\n/// <summary>\n/// Command for splitting multiple edges on Brep surfaces. Edges can be split using selected knife objects \n/// (curves, surfaces, or breps) or by picking split points manually on the edges.\n/// </summary>\n\nusing System;\nusing System.Collections.Generic;\nusing Rhino;\nusing Rhino.Commands;\nusing Rhino.DocObjects;\nusing Rhino.Geometry;\nusing Rhino.Input;\nusing Rhino.Input.Custom;\n\npublic class SplitMultiEdgesCommand : Command\n{\n    public override string EnglishName => \"SplitMultiEdges\";\n\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\n    {\n        // 1. Select edges\n        ObjRef[] obs;\n        var res = RhinoGet.GetMultipleObjects(\n            \"Select edges to split\",\n            false,\n            ObjectType.EdgeFilter,\n            out obs\n        );\n        if (res != Result.Success || obs == null)\n            return res;\n\n        // Save the list of selected edges as ObjRef and their indices\n        var selectedEdges = new List<(ObjRef ob, int edgeIdx)>();\n        foreach (var ob in obs)\n        {\n            var rhObj = ob.Object();\n            if (rhObj == null) continue;\n            int edgeIdx = ob.GeometryComponentIndex.Index;\n            if (edgeIdx < 0) continue;\n            selectedEdges.Add((ob, edgeIdx));\n        }\n\n        // Prepare highlight information for the selected edges\n        var highlightEdgeRefs = new List<(Guid, ComponentIndex)>();\n        foreach (var (ob, edgeIdx) in selectedEdges)\n        {\n            var rhObj = ob.Object();\n            if (rhObj == null) continue;\n            highlightEdgeRefs.Add((rhObj.Id, new ComponentIndex(ComponentIndexType.BrepEdge, edgeIdx)));\n        }\n\n        // Exclude selected objects from being used as cutting objects\n        var excludeBrepIds = new HashSet<Guid>();\n        foreach (var (ob, _) in selectedEdges)\n        {\n            var rhObj = ob.Object();\n            if (rhObj != null)\n                excludeBrepIds.Add(rhObj.Id);\n        }\n\n        // 2. Select cutting objects\n        var getKnife = new GetObject();\n        getKnife.SetCommandPrompt(\"Select cutting objects\");\n        getKnife.GeometryFilter = ObjectType.Curve | ObjectType.Surface | ObjectType.Brep;\n        getKnife.SubObjectSelect = false;\n        getKnife.GroupSelect = true;\n        getKnife.SetCustomGeometryFilter((rhObj, geometry, ci) => !excludeBrepIds.Contains(rhObj.Id));\n\n        var optPoint = new OptionToggle(false, \"No\", \"Yes\");\n        getKnife.AddOptionToggle(\"Point\", ref optPoint);\n\n        bool usePoints = false;\n        List<ObjRef> knifeRefs = new List<ObjRef>();\n\n        while (true)\n        {\n            var resGet = getKnife.GetMultiple(1, 0);\n            if (getKnife.CommandResult() != Result.Success)\n                return getKnife.CommandResult();\n\n            if (getKnife.OptionIndex() > 0)\n            {\n                if (optPoint.CurrentValue)\n                {\n                    usePoints = true;\n                    break;\n                }\n                else\n                    continue;\n            }\n\n            if (getKnife.ObjectCount > 0)\n            {\n                for (int i = 0; i < getKnife.ObjectCount; i++)\n                    knifeRefs.Add(getKnife.Object(i));\n                break;\n            }\n        }\n\n        if (!usePoints && knifeRefs.Count == 0)\n            return Result.Cancel;\n\n        double tol = doc.ModelAbsoluteTolerance;\n        List<Curve> knives = new List<Curve>();\n        List<Brep> brepKnives = new List<Brep>();\n        List<(ObjRef ob, int edgeIdx, double t)> splitParams = new List<(ObjRef, int, double)>();\n        var toSelect = new List<(Guid, int)>();\n\n        if (usePoints)\n        {\n            // Highlight the selected edges before picking points\n            foreach (var (objId, compIdx) in highlightEdgeRefs)\n            {\n                var rhObj = doc.Objects.FindId(objId);\n                if (rhObj != null)\n                    rhObj.HighlightSubObject(compIdx, true);\n            }\n            doc.Views.Redraw();\n\n            // Gather edge curves for closest point search\n            var edgeData = new List<(ObjRef ob, int edgeIdx, Curve curve)>();\n            foreach (var (ob, edgeIdx) in selectedEdges)\n            {\n                var brep = ob.Brep();\n                if (brep != null && edgeIdx >= 0 && edgeIdx < brep.Edges.Count)\n                    edgeData.Add((ob, edgeIdx, brep.Edges[edgeIdx].DuplicateCurve()));\n            }\n\n            // Build a PolyCurve from all edge curves (for point constraint)\n            PolyCurve poly = new PolyCurve();\n            foreach (var d in edgeData)\n            {\n                poly.AppendSegment(d.curve);\n            }\n\n            while (true)\n            {\n                GetPoint gp = new GetPoint();\n                gp.SetCommandPrompt(\"Pick split point (Enter to finish)\");\n                gp.AcceptNothing(true);\n                gp.Constrain(poly, false);\n\n                var result = gp.Get();\n                if (result == GetResult.Point)\n                {\n                    Point3d pt = gp.Point();\n                    double minDist = double.MaxValue;\n                    int chosenEdgeIdx = -1;\n                    double chosenT = 0;\n                    ObjRef chosenOb = null;\n                    foreach (var d in edgeData)\n                    {\n                        double t;\n                        if (d.curve.ClosestPoint(pt, out t))\n                        {\n                            double dist = d.curve.PointAt(t).DistanceTo(pt);\n                            if (dist < minDist && dist < tol * 10)\n                            {\n                                minDist = dist;\n                                chosenEdgeIdx = d.edgeIdx;\n                                chosenT = t;\n                                chosenOb = d.ob;\n                            }\n                        }\n                    }\n                    if (chosenEdgeIdx != -1 && chosenOb != null)\n                    {\n                        splitParams.Add((chosenOb, chosenEdgeIdx, chosenT));\n                    }\n                    else\n                    {\n                        continue;\n                    }\n                }\n                else break;\n            }\n\n            // Remove highlighting after picking points\n            foreach (var (objId, compIdx) in highlightEdgeRefs)\n            {\n                var rhObj = doc.Objects.FindId(objId);\n                if (rhObj != null)\n                    rhObj.HighlightSubObject(compIdx, false);\n            }\n            doc.Views.Redraw();\n\n            if (splitParams.Count == 0)\n            {\n                return Result.Cancel;\n            }\n        }\n        else\n        {\n            foreach (var kr in knifeRefs)\n            {\n                var crv = kr.Curve();\n                if (crv != null)\n                {\n                    knives.Add(crv.DuplicateCurve());\n                    continue;\n                }\n                var br = kr.Brep();\n                if (br != null)\n                {\n                    brepKnives.Add(br);\n                    continue;\n                }\n                var srf = kr.Surface();\n                if (srf != null)\n                    brepKnives.Add(Brep.CreateFromSurface(srf));\n            }\n\n            if (knives.Count == 0 && brepKnives.Count == 0)\n            {\n                return Result.Cancel;\n            }\n        }\n\n        // Group edges by Brep object for later update\n        var edgesByObj = new Dictionary<Guid, List<(ObjRef ob, int edgeIdx)>>();\n        foreach (var (ob, edgeIdx) in selectedEdges)\n        {\n            var id = ob.Object().Id;\n            if (!edgesByObj.ContainsKey(id))\n                edgesByObj[id] = new List<(ObjRef, int)>();\n            edgesByObj[id].Add((ob, edgeIdx));\n        }\n\n        int splitEdgeCount = 0;\n        int totalSplitSegments = 0;\n\n        foreach (var kv in edgesByObj)\n        {\n            var objId = kv.Key;\n            var edgeTuples = kv.Value;\n            var ob = edgeTuples[0].ob;\n            var brep = ob.Brep();\n            if (brep == null)\n                continue;\n\n            var edgeSplitParams = new Dictionary<int, List<double>>();\n            foreach (var (_, edgeIdx) in edgeTuples)\n            {\n                if (edgeIdx < 0 || edgeIdx >= brep.Edges.Count)\n                    continue;\n\n                var bredge = brep.Edges[edgeIdx];\n                var edgeCurve = bredge.DuplicateCurve();\n                if (edgeCurve == null)\n                    continue;\n\n                List<double> paramlist = new List<double>();\n\n                if (usePoints)\n                {\n                    foreach (var s in splitParams)\n                    {\n                        if (s.ob.Object().Id == objId && s.edgeIdx == edgeIdx)\n                        {\n                            Interval dom = edgeCurve.Domain;\n                            double t = s.t;\n                            if (t > dom.T0 + tol && t < dom.T1 - tol)\n                                paramlist.Add(t);\n                        }\n                    }\n                }\n                else\n                {\n                    foreach (var knife in knives)\n                    {\n                        var x = Rhino.Geometry.Intersect.Intersection.CurveCurve(edgeCurve, knife, tol, tol);\n                        if (x != null)\n                        {\n                            foreach (var it in x)\n                            {\n                                double t;\n                                if (edgeCurve.ClosestPoint(it.PointA, out t))\n                                    if (t > edgeCurve.Domain.T0 + tol && t < edgeCurve.Domain.T1 - tol)\n                                        paramlist.Add(t);\n                            }\n                        }\n                    }\n                    foreach (var bknife in brepKnives)\n                    {\n                        Curve[] overlapCurves;\n                        Point3d[] intersectionPoints;\n                        bool found = Rhino.Geometry.Intersect.Intersection.CurveBrep(edgeCurve, bknife, tol, out overlapCurves, out intersectionPoints);\n                        if (found && intersectionPoints != null && intersectionPoints.Length > 0)\n                        {\n                            foreach (var pt in intersectionPoints)\n                            {\n                                double t;\n                                if (edgeCurve.ClosestPoint(pt, out t))\n                                    if (t > edgeCurve.Domain.T0 + tol && t < edgeCurve.Domain.T1 - tol)\n                                        paramlist.Add(t);\n                            }\n                        }\n                    }\n                }\n\n                if (paramlist.Count > 0)\n                {\n                    paramlist.Sort();\n                    for (int i = paramlist.Count - 1; i > 0; i--)\n                        if (Math.Abs(paramlist[i] - paramlist[i - 1]) < tol)\n                            paramlist.RemoveAt(i);\n                    edgeSplitParams[edgeIdx] = paramlist;\n                }\n            }\n\n            // Count how many edges and segments were split\n            foreach (var pair in edgeSplitParams)\n            {\n                if (pair.Value.Count > 0)\n                {\n                    splitEdgeCount += 1;\n                    totalSplitSegments += pair.Value.Count + 1;\n                }\n            }\n\n            foreach (int edgeIdx in edgeSplitParams.Keys)\n            {\n                brep.Edges.SplitEdgeAtParameters(edgeIdx, edgeSplitParams[edgeIdx]);\n            }\n\n            brep.Compact();\n            doc.Objects.Replace(objId, brep);\n        }\n\n        doc.Views.Redraw();\n\n        // Proper singular/plural output and handle zero/no split cases\n        if (splitEdgeCount == 0)\n        {\n            RhinoApp.WriteLine(\"No edges were split.\");\n        }\n        else if (totalSplitSegments == splitEdgeCount)\n        {\n            RhinoApp.WriteLine($\"{splitEdgeCount} edge{(splitEdgeCount == 1 ? \"\" : \"s\")} selected, but no splits were made.\");\n        }\n        else\n        {\n            string edgeWord = splitEdgeCount == 1 ? \"edge\" : \"edges\";\n            string segmentWord = totalSplitSegments == 1 ? \"segment\" : \"segments\";\n            RhinoApp.WriteLine($\"{splitEdgeCount} {edgeWord} split into {totalSplitSegments} {segmentWord}.\");\n        }\n\n        return Result.Success;\n    }\n}",
      "language": "csharp",
      "author": "leex",
      "post_number": 13,
      "is_solution": false
    },
    {
      "code": "using System.Collections.Generic;\nusing Rhino;\nusing Rhino.Commands;\nusing Rhino.DocObjects;\nusing Rhino.Geometry;\nusing Rhino.Input.Custom;\nusing Rhino.Geometry.Intersect;\n\npublic class SplitMultiEdgesCommand : Command\n{\n    public SplitMultiEdgesCommand()\n    {\n        Instance = this;\n    }\n    public static SplitMultiEdgesCommand Instance { get; private set; }\n    public override string EnglishName => \"SplitMultiEdges\";\n\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\n    {\n        // 1. Select edges (SubObject)\n        var go = new GetObject();\n        go.SetCommandPrompt(\"Select edges (sub-objects)\");\n        go.GeometryFilter = ObjectType.EdgeFilter;\n        go.SubObjectSelect = true;\n        go.EnablePreSelect(false, true);\n        go.GetMultiple(1, 0);\n        if (go.CommandResult() != Result.Success)\n            return go.CommandResult();\n\n        List<ObjRef> edge_refs = new List<ObjRef>();\n        for (int i = 0; i < go.ObjectCount; i++)\n            edge_refs.Add(go.Object(i));\n\n        if (edge_refs.Count == 0)\n            return Result.Cancel;\n\n        // 2. Select splitting curves\n        var go2 = new GetObject();\n        go2.SetCommandPrompt(\"Select curves to split edges\");\n        go2.GeometryFilter = ObjectType.Curve;\n        go2.DeselectAllBeforePostSelect = false;\n        go2.GetMultiple(1, 0);\n        if (go2.CommandResult() != Result.Success)\n            return go2.CommandResult();\n\n        List<Curve> knives = new List<Curve>();\n        for (int i = 0; i < go2.ObjectCount; i++)\n        {\n            var crv = go2.Object(i).Curve();\n            if (crv != null)\n                knives.Add(crv.DuplicateCurve());\n        }\n        if (knives.Count == 0)\n            return Result.Cancel;\n\n        // 3. Map: for each brep -> list of edges for split and objectId\n        var brepEdgeMap = new Dictionary<Brep, List<int>>();\n        var brepGuidMap = new Dictionary<Brep, System.Guid>();\n        foreach (var edgeRef in edge_refs)\n        {\n            var edge = edgeRef.Edge();\n            var brep = edge.Brep;\n            if (!brepEdgeMap.ContainsKey(brep))\n            {\n                brepEdgeMap[brep] = new List<int>();\n                var brepObjId = edgeRef.ObjectId; // <--- IMPORTANT: take ObjectId from ObjRef!\n                brepGuidMap[brep] = brepObjId;\n            }\n            brepEdgeMap[brep].Add(edge.EdgeIndex);\n        }\n\n        // 4. For each Brep work with the required edges\n        foreach (var kv in brepEdgeMap)\n        {\n            var brep = kv.Key;\n            var edgeIndices = kv.Value;\n            var brepGuid = brepGuidMap[brep];\n\n            // For each edge â€” find intersection points with splitting curves\n            foreach (int ei in edgeIndices)\n            {\n                var edge = brep.Edges[ei];\n                var edgeCurve = edge.DuplicateCurve();\n                List<double> splitParams = new List<double>();\n                foreach (var knife in knives)\n                {\n                    var x = Intersection.CurveCurve(edgeCurve, knife, doc.ModelAbsoluteTolerance, doc.ModelAbsoluteTolerance);\n                    if (x != null)\n                        foreach (var it in x)\n                        {\n                            double t;\n                            if (edgeCurve.ClosestPoint(it.PointA, out t))\n                                splitParams.Add(t);\n                        }\n                }\n                if (splitParams.Count > 0)\n                {\n                    // Remove duplicates and sort\n                    splitParams.Sort();\n                    for (int i = splitParams.Count - 1; i > 0; i--)\n                        if (System.Math.Abs(splitParams[i] - splitParams[i - 1]) < doc.ModelAbsoluteTolerance)\n                            splitParams.RemoveAt(i);\n\n                    // Split the edge\n                    foreach (var t in splitParams)\n                    {\n                        edge.Split(t);\n                    }\n                }\n            }\n            // Update the object in the document\n            doc.Objects.Replace(brepGuid, brep);\n        }\n\n        doc.Views.Redraw();\n        RhinoApp.WriteLine(\"Done!\");\n        return Result.Success;\n    }\n}",
      "language": "csharp",
      "author": "leex",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "csharp",
    "file-io",
    "geometry",
    "python",
    "rhinocommon",
    "selection",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 3,
  "posts_count": 14,
  "views": 285
}