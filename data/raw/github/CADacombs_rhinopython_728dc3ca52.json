{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_NurbsCrv_makeNonRational.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_NurbsCrv_makeNonRational.py",
  "instruction": "This script will set all weights of a rational NURBS curve to 1.0 and\r\nIsRational (RhinoCommon) to False.  Option is included for allowed curve deviation.",
  "code": "\"\"\"\r\nThis script will set all weights of a rational NURBS curve to 1.0 and\r\nIsRational (RhinoCommon) to False.  Option is included for allowed curve deviation.\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n230114: Created.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bLimitDistDev'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fDistTol'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bModifyArcCrvs'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bModifyPolyCrvs'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bModify_NotAdd'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'DocAction'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Add', 'Modify')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fDistTol':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get curve and parameter with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select curves\")\r\n\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\r\n    go.GeometryAttributeFilter = ri.Custom.GeometryAttributeFilter.WireCurve\r\n\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    #go.SubObjectSelect = False\r\n    go.EnableClearObjectsOnEntry(False) # Keep objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False)\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    bPreselectedObjsChecked = False\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('bLimitDistDev')\r\n        if Opts.values['bLimitDistDev']:\r\n            addOption('fDistTol')\r\n        addOption('bModifyArcCrvs')\r\n        addOption('bModifyPolyCrvs')\r\n        addOption('bModify_NotAdd')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            continue\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number and Opts.values['bLimitDistDev']:\r\n            key = 'fDistTol'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef formatDistance(fDistance):\r\n    if fDistance is None: \r\n        return \"(No deviation provided)\"\r\n    if fDistance == 0.0:\r\n        return 0.0\r\n    if fDistance < 0.001:\r\n        return \"{:.2e}\".format(fDistance)\r\n    else:\r\n        return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\ndef areEpsilonEqual(a, b, epsilon):\r\n    # This is a relative comparison.\r\n    delta = abs(a-b)\r\n    #print f2s(delta),\r\n    fRelComp = delta / max(abs(a), abs(b))\r\n    #print f2s(fRelComp)\r\n    return fRelComp < epsilon\r\n\r\n\r\ndef hasRationalWeights(nc):\r\n    for cp in nc.Points:\r\n        weight = cp.Weight\r\n        if weight == 1.0: continue\r\n        return True\r\n    return False\r\n\r\n\r\ndef getDistancesBetweenCurves(crvA, crvB):\r\n    rc = rg.Curve.GetDistancesBetweenCurves(\r\n        crvA, crvB, 0.1*sc.doc.ModelAbsoluteTolerance)\r\n    if not rc[0]:\r\n        raise Exception(\"GetDistancesBetweenCurves returned None.\")\r\n        return None\r\n    return rc[1]\r\n\r\n\r\ndef createNonRationalNurbsCurve(nc_In, fDistTol=None, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        fDistTol: None for no limit.\r\n        bDebug\r\n\r\n    Returns:\r\n        Success: rgNurbsCurve, fMinRadius, fDeviation, None\r\n        Fail: None, None, None, sLog\r\n    \"\"\"\r\n    \r\n    if not isinstance(nc_In, rg.NurbsCurve):\r\n        return None, \"Not a NURBS curve.\"\r\n\r\n\r\n    if not nc_In.IsRational:\r\n        if hasRationalWeights(nc_In):\r\n            return None, \"Curve is flagged as being non-rational, but some of its weights are not 1.0!\"\r\n        else:\r\n            return None, \"Curve is flagged as being non-rational, and all its weights are 1.0.\"\r\n\r\n    nc_Out = rg.NurbsCurve(degree=nc_In.Degree, pointCount=nc_In.Points.Count)\r\n\r\n    for iK, k in enumerate(nc_In.Knots):\r\n        nc_Out.Knots[iK] = k\r\n\r\n    for iCp, cp in enumerate(nc_In.Points):\r\n        nc_Out.Points[iCp] = nc_In.Points[iCp].Location\r\n\r\n\r\n    if fDistTol is not None:\r\n        dev = getDistancesBetweenCurves(nc_In, nc_Out)\r\n        if dev > fDistTol:\r\n            nc_Out.Dispose()\r\n            return None, \"Result is not within allowed distance deviation of {}\".format(fDistTol)\r\n\r\n    return nc_Out, None\r\n\r\n\r\ndef processCurveObject(rhCrv_In, **kwargs):\r\n    \"\"\"\r\n    Parameters:\r\n        fDistTol\r\n        bModifyArcCrvs\r\n        bModifyPolyCrvs\r\n        bModify_NotAdd\r\n        bEcho\r\n        bDebug\r\n    \"\"\"\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fDistTol = getOpt('fDistTol')\r\n    bModifyArcCrvs = getOpt('bModifyArcCrvs')\r\n    bModifyPolyCrvs = getOpt('bModifyPolyCrvs')\r\n    bModify_NotAdd = getOpt('bModify_NotAdd')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    def getCurve(rhObj):\r\n        if isinstance(rhObj, rd.CurveObject):\r\n            return rhObj, rhObj.CurveGeometry\r\n\r\n        if isinstance(rhObj, rg.Curve):\r\n            return None, rhObj\r\n\r\n        if isinstance(rhObj, rg.GeometryBase):\r\n            rdObj = None\r\n            rgObj = rhObj\r\n        elif isinstance(rhObj, rd.ObjRef):\r\n            rdObj = rhObj.Object()\r\n            rgObj = rhObj.Geometry()\r\n        elif isinstance(rhObj, Guid):\r\n            rdObj = sc.doc.Objects.FindId(rhObj) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhObj)\r\n            rgObj = rdObj.Geometry\r\n        else:\r\n            return\r\n\r\n        if isinstance(rgObj, rg.Curve):\r\n            return rdObj, rgObj\r\n\r\n\r\n    rdCrv_In, rgCrv_In = getCurve(rhCrv_In)\r\n\r\n    if isinstance(rgCrv_In, rg.NurbsCurve):\r\n        nc_Start = rgCrv_In.DuplicateCurve()\r\n    elif bModifyArcCrvs and isinstance(rgCrv_In, rg.ArcCurve):\r\n        nc_Start = rgCrv_In.ToNurbsCurve()\r\n    elif bModifyPolyCrvs and isinstance(rgCrv_In, rg.PolyCurve):\r\n        nc_Start = rgCrv_In.ToNurbsCurve()\r\n    else:\r\n        return None, \"{} is not an accepted input.\".format(rgCrv_In.GetType().Name)\r\n\r\n    if not nc_Start.IsRational:\r\n        if hasRationalWeights(nc_Start):\r\n            nc_Start.Dispose()\r\n            return None, \"Curve is flagged as being non-rational, but some of its weights are not 1.0!\"\r\n        else:\r\n            nc_Start.Dispose()\r\n            return None, \"Curve is flagged as being non-rational, and all its weights are 1.0.\"\r\n\r\n\r\n    gCrv_In = rdCrv_In.Id\r\n\r\n    rc = createNonRationalNurbsCurve(\r\n        nc_In=nc_Start,\r\n        fDistTol=fDistTol,\r\n        bDebug=bDebug,\r\n        )\r\n    if rc[0] is None:\r\n        return rc\r\n\r\n    nc_Res, sLog = rc\r\n\r\n    if sLog:\r\n        raise Exception(\"sLog should be None but is {}\".format(sLog))\r\n\r\n    nc_Res = rc[0]\r\n\r\n    if bModify_NotAdd:\r\n        if sc.doc.Objects.Replace(gCrv_In, nc_Res):\r\n            return gCrv_In, \"Curve was replaced.\"\r\n        else:\r\n            return None, \"Curve could not be replaced.\"\r\n    else:\r\n        g1 = sc.doc.Objects.AddCurve(nc_Res)\r\n        if g1 != Guid.Empty:\r\n            return gCrv_In, \"Curve was added.\"\r\n        else:\r\n            return None, \"Curve could not be added.\"\r\n\r\n    nc_Start.Dispose()\r\n\r\n\r\n    return gs1, sLogs\r\n\r\n\r\ndef main():\r\n\r\n    objrefs = getInput()\r\n    if objrefs is None: return\r\n\r\n    fDistTol = Opts.values['fDistTol'] if Opts.values['bLimitDistDev'] else None\r\n    bModifyArcCrvs = Opts.values['bModifyArcCrvs']\r\n    bModifyPolyCrvs = Opts.values['bModifyPolyCrvs']\r\n    bModify_NotAdd = Opts.values['bModify_NotAdd']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n\r\n    if not bDebug:\r\n        sc.doc.Views.RedrawEnabled = False\r\n\r\n    gCs_Result = []\r\n    sLogs = []\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\r\n\r\n    for objref in objrefs:\r\n\r\n        gC_Result, sLog = processCurveObject(\r\n            objref,\r\n            fDistTol=fDistTol,\r\n            bModifyArcCrvs=bModifyArcCrvs,\r\n            bModifyPolyCrvs=bModifyPolyCrvs,\r\n            bModify_NotAdd=bModify_NotAdd,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug\r\n            )\r\n\r\n        if gC_Result:\r\n            gCs_Result.append(gC_Result)\r\n\r\n        if sLog:\r\n            sLogs.append(sLog)\r\n\r\n    if bEcho:\r\n        for sLog in set(sLogs):\r\n            print(\"[{}] {}\".format(sLogs.count(sLog), sLog))\r\n\r\n\r\n    for gC in gCs_Result:\r\n        sc.doc.Objects.Select(gC)\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": true
}