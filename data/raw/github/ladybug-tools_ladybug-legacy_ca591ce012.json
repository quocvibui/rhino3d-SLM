{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Bounce%20from%20Surface.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Bounce from Surface.py",
  "instruction": "Use this component to get a sense of how direct sunlight is reflected off of an initial _sourceSrf and subsequently to a set of context_ geometries by tracing sun rays forwards through this...",
  "code": "#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Mostapha Sadeghipour Roudsari <mostapha@ladybug.tools> \n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to get a sense of how direct sunlight is reflected off of an initial _sourceSrf and subsequently to a set of context_ geometries by tracing sun rays forwards through this geometry.\nExamples where this component might be useful include the evaluation of the diffusion of light by a light shelf, or testing to see whether a parabolic building geometry (like a Ghery building) might focus sunlight to dangerous levels at certain times of the year.\nNote that this component assumes that all sun light is reflected off of these geometries specularly (as if they were a mirror) and, for more detailed raytrace analysis, the Honeybee daylight components should be used.\n-\nProvided by Ladybug 0.0.69\n    \n    Args:\n        _sourceSrfs: A brep or mesh representing a surface that you are interested in seeing direct sunlight bounce off of.  You can also put in lists of breps or meshes. These surfaces will be used to generate the initial sun rays in a grid-like pattern.  Note that, for curved surfaces, smooth meshes of the geometry will be more accurate than inputing a Brep.\n        _gridSizeOrPoints: A number in Rhino model units that represents the average size of a grid cell to generate the points, or list of points itself.  Note that, if you put in meshes for the input above, the _gridSize number option of this input will not work as this component will use the vertices of the mesh to generate the sun rays.\n        context_: Breps or meshes of conext geometry, which will reflect the sun rays after they bounce off of the _sourceSrfs.  Note that, for curved surfaces, smooth meshes of the geometry will be more accurate than inputing a Brep.\n        _numOfBounce_: An interger representing the number of ray bounces to trace the sun rays forward.\n        firstBounceLen_: A number representing the length of the sun ray before the first bounce. If left empty, this length will be the diagonal of the bounding box surrounding all input geometries.\n        _lastBounceLen_: A number representing the length of the sun ray after the last bounce. If left empty, this length will be the diagonal of the bounding box surrounding all input geometries.\n    Returns:\n        bouncePts: The generated base points on the _sourceSrfs to which the sun rays will be directed. The preview of this output is set to be hidden by default.  Connect to a Grasshopper \"Point\" component to visualize.\n        rays: The sun rays traced forward through the geometry.\n        _runIt: Set to True to run the reflection study.\n\"\"\"\n\nghenv.Component.Name = \"Ladybug_Bounce from Surface\"\nghenv.Component.NickName = 'bounceFromSurface'\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"3 | EnvironmentalAnalysis\"\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"3\"\nexcept: pass\n\nimport Grasshopper.Kernel as gh\nimport Rhino as rc\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport math\n\ndef main(sourceSrfs, gridSizeOrPoints, sunVectors, context, numOfBounce, firstBounceLen, lastBounceLen):\n    # import the classes\n    if sc.sticky.has_key('ladybug_release'):\n        try:\n            if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): return -1\n            if sc.sticky['ladybug_release'].isInputMissing(ghenv.Component): return -1\n        except:\n            warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n            \"Use updateLadybug component to update userObjects.\\n\" + \\\n            \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n            \"into canvas and try again.\"\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n            return -1\n            \n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n        lb_mesh = sc.sticky[\"ladybug_Mesh\"]()\n        lb_runStudy_GH = sc.sticky[\"ladybug_RunAnalysis\"]()\n        lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\n    else:\n        print \"You should first let the Ladybug fly...\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"You should first let the Ladybug fly...\")\n        return -1\n    \n    # Check the geometry\n    \n    if len(context)==0: context = sourceSrfs\n    else: context = context + sourceSrfs\n    ## clean the geometry and bring them to rhinoCommon separated as mesh and Brep\n    contextMesh, contextBrep = lb_preparation.cleanAndCoerceList(context)\n    ## mesh Brep\n    contextMeshedBrep = lb_mesh.parallel_makeContextMesh(contextBrep)\n    \n    ## Flatten the list of surfaces\n    contextMeshedBrep = lb_preparation.flattenList(contextMeshedBrep)\n    contextSrfs = contextMesh + contextMeshedBrep\n    joinedContext = lb_mesh.joinMesh(contextSrfs)\n    \n    # Get rid of trimmed parts\n    cleanBrep = rc.Geometry.Brep.CreateFromMesh(joinedContext, False)\n    \n    try:\n        gridSize = float(gridSizeOrPoints[0])\n        basedOnGrid = True\n    except:\n        basedOnGrid = False\n        initialTestPoints = rs.coerce3dpointlist(gridSizeOrPoints)\n        ptsNormals = [cleanBrep.ClosestPoint(intPt, sc.doc.ModelAbsoluteTolerance)[5] for intPt in initialTestPoints]\n        \n    \n    # generate the test points\n    if basedOnGrid:\n        ## mesh Brep\n        analysisMesh, analysisBrep = lb_preparation.cleanAndCoerceList(sourceSrfs)\n        \n        analysisMeshedBrep = lb_mesh.parallel_makeSurfaceMesh(analysisBrep, float(gridSize))\n            \n        ## Flatten the list of surfaces\n        analysisMeshedBrep = lb_preparation.flattenList(analysisMeshedBrep)\n        analysisSrfs = analysisMesh + analysisMeshedBrep\n            \n        initialTestPoints, ptsNormals, meshSrfAreas = lb_mesh.parallel_testPointCalculator(analysisSrfs, 0, False)\n        initialTestPoints = lb_preparation.flattenList(initialTestPoints)\n        ptsNormals = lb_preparation.flattenList(ptsNormals)\n        \n    \n    # find the distance for moving the points backward\n    try:\n        firstBounceLen = float(firstBounceLen)\n    except:\n        maxPt =joinedContext.GetBoundingBox(True).Max\n        minPt = joinedContext.GetBoundingBox(True).Min\n        firstBounceLen = maxPt.DistanceTo(minPt)\n        \n    rays = []\n    for ptCount, testPt in enumerate(initialTestPoints):\n        for vector in sunVectors:\n            vector.Unitize()\n            testPt = rc.Geometry.Point3d.Add(testPt, -vector * firstBounceLen)\n            ray = rc.Geometry.Ray3d(testPt, vector)\n            \n            if numOfBounce>0 and rc.Geometry.Vector3d.VectorAngle(vector, ptsNormals[ptCount]) < math.pi/2:\n                intPts = rc.Geometry.Intersect.Intersection.RayShoot(ray, [cleanBrep], numOfBounce)\n                #print intPts\n                if intPts:\n                    ptList = [testPt]\n                    ptList.extend(intPts)\n                    ray = rc.Geometry.Polyline(ptList).ToNurbsCurve()\n                    \n                    try:\n                        # create last ray\n                        # calculate plane at intersection\n                        intNormal = cleanBrep.ClosestPoint(intPts[-1], sc.doc.ModelAbsoluteTolerance)[5]\n                        \n                        lastVector = rc.Geometry.Vector3d(ptList[-2] - ptList[-1])\n                        lastVector.Unitize()\n                        \n                        crossProductNormal = rc.Geometry.Vector3d.CrossProduct(intNormal, lastVector)\n                        \n                        plane = rc.Geometry.Plane(intPts[-1], intNormal, crossProductNormal)\n                        \n                        mirrorT = rc.Geometry.Transform.Mirror(intPts[-1], plane.Normal)\n                        \n                        lastRay = rc.Geometry.Line(intPts[-1], lastBounceLen * lastVector).ToNurbsCurve()\n                        lastRay.Transform(mirrorT)\n                        \n                        ray = rc.Geometry.Curve.JoinCurves([ray, lastRay])[0]\n                    except:\n                        pass\n                        \n                    rays.append(ray)\n                else:\n                    # no bounce so let's just create a line form the point\n                    firstRay = rc.Geometry.Line(testPt, lastBounceLen * vector).ToNurbsCurve()\n                    rays.append(firstRay)\n            else:\n                rays.append(None)\n    \n    return rays, initialTestPoints\n\nif (_sourceSrfs and _sourceSrfs[0]!=None) and (_sunVectors and _sunVectors[0]!=None) and (_gridSizeOrPoints and _gridSizeOrPoints[0]!=None) and _runIt == True:\n    results = main(_sourceSrfs, _gridSizeOrPoints, _sunVectors, context_, _numOfBounce_, firstBounceLen_, _lastBounceLen_)\n    if results!=-1:\n        rays, bouncePts = results\n        \n    ghenv.Component.Params.Output[1].Hidden= True\n    \nelif _sourceSrfs == [] and _gridSizeOrPoints == [] and _sunVectors == []:\n    print \"Provide start points, start vectors and context.\"\nelse:\n    #print _startPts\n    print \"Provide valid start points, start vectors and context...\"\n    ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, \"Provide start points, start vectors and context...\")\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}