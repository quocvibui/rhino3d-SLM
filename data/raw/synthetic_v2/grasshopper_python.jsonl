{"instruction": "Write a GhPython component that creates a point from x, y, z inputs", "code": "import Rhino.Geometry as rg\na = rg.Point3d(x, y, z)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["geometry", "point"]}
{"instruction": "GhPython component to create a line between two input points", "code": "import Rhino.Geometry as rg\na = rg.Line(pt1, pt2)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["geometry", "line"]}
{"instruction": "Create a circle from a center point and radius in GhPython", "code": "import Rhino.Geometry as rg\nplane = rg.Plane(center, rg.Vector3d.ZAxis)\na = rg.Circle(plane, radius).ToNurbsCurve()", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["geometry", "circle"]}
{"instruction": "GhPython: create a sphere from center and radius", "code": "import Rhino.Geometry as rg\na = rg.Sphere(center, radius)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["geometry", "sphere"]}
{"instruction": "Create a polyline from a list of points in GhPython", "code": "import Rhino.Geometry as rg\npline = rg.Polyline(pts)\na = pline.ToNurbsCurve()", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["geometry", "polyline"]}
{"instruction": "GhPython: create a vector between two points", "code": "import Rhino.Geometry as rg\na = rg.Vector3d(pt2 - pt1)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["geometry", "vector"]}
{"instruction": "Create a plane from origin, X, and Y vectors", "code": "import Rhino.Geometry as rg\na = rg.Plane(origin, x_vec, y_vec)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["geometry", "plane"]}
{"instruction": "GhPython: create an arc through three points", "code": "import Rhino.Geometry as rg\narc = rg.Arc(pt1, pt2, pt3)\na = arc.ToNurbsCurve()", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["geometry", "arc"]}
{"instruction": "Create a rectangle in GhPython from width and height", "code": "import Rhino.Geometry as rg\nplane = rg.Plane.WorldXY\ninterval_x = rg.Interval(0, width)\ninterval_y = rg.Interval(0, height)\na = rg.Rectangle3d(plane, interval_x, interval_y).ToNurbsCurve()", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["geometry", "rectangle"]}
{"instruction": "GhPython: create a cylinder from base plane, radius, and height", "code": "import Rhino.Geometry as rg\ncircle = rg.Circle(base_plane, radius)\ncyl = rg.Cylinder(circle, height)\na = cyl.ToBrep(True, True)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["geometry", "cylinder"]}
{"instruction": "Create a cone in GhPython", "code": "import Rhino.Geometry as rg\nplane = rg.Plane(base_pt, rg.Vector3d.ZAxis)\na = rg.Cone(plane, height, radius)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["geometry", "cone"]}
{"instruction": "GhPython: create an interpolated curve from points", "code": "import Rhino.Geometry as rg\na = rg.Curve.CreateInterpolatedCurve(pts, 3)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["geometry", "curve", "interpolated"]}
{"instruction": "Create a NURBS curve from control points in GhPython", "code": "import Rhino.Geometry as rg\na = rg.NurbsCurve.Create(False, 3, pts)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["geometry", "nurbs", "curve"]}
{"instruction": "GhPython: create a surface from four corner points", "code": "import Rhino.Geometry as rg\na = rg.NurbsSurface.CreateFromCorners(pt1, pt2, pt3, pt4)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["geometry", "surface", "corners"]}
{"instruction": "Create an ellipse in GhPython", "code": "import Rhino.Geometry as rg\nplane = rg.Plane(center, rg.Vector3d.ZAxis)\nellipse = rg.Ellipse(plane, radius_x, radius_y)\na = ellipse.ToNurbsCurve()", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["geometry", "ellipse"]}
{"instruction": "Output a DataTree of points organized by rows", "code": "import Grasshopper as gh\nimport Rhino.Geometry as rg\ntree = gh.DataTree[object]()\nfor i in range(rows):\n    path = gh.Kernel.Data.GH_Path(i)\n    for j in range(cols):\n        tree.Add(rg.Point3d(j * spacing, i * spacing, 0), path)\na = tree", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["datatree", "grid"]}
{"instruction": "Read branches from an input DataTree and process each", "code": "import Grasshopper as gh\nimport Rhino.Geometry as rg\nresults = gh.DataTree[object]()\nfor i in range(tree.BranchCount):\n    branch = tree.Branch(i)\n    path = tree.Path(i)\n    moved = []\n    for pt in branch:\n        moved.append(rg.Point3d(pt.X + i, pt.Y, pt.Z))\n    results.AddRange(moved, path)\na = results", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["datatree", "branches"]}
{"instruction": "Flatten a DataTree to a single list", "code": "import Grasshopper as gh\nimport Rhino.Geometry as rg\nflat = []\nfor i in range(tree.BranchCount):\n    for item in tree.Branch(i):\n        flat.append(item)\na = flat", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["datatree", "flatten"]}
{"instruction": "Graft a list into a DataTree with one item per branch", "code": "import Grasshopper as gh\nimport Rhino.Geometry as rg\ntree_out = gh.DataTree[object]()\nfor i, item in enumerate(items):\n    path = gh.Kernel.Data.GH_Path(i)\n    tree_out.Add(item, path)\na = tree_out", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["datatree", "graft"]}
{"instruction": "Create a DataTree where each branch holds a pair of points", "code": "import Grasshopper as gh\nimport Rhino.Geometry as rg\ntree = gh.DataTree[object]()\nfor i in range(count):\n    path = gh.Kernel.Data.GH_Path(i)\n    tree.Add(rg.Point3d(i, 0, 0), path)\n    tree.Add(rg.Point3d(i, 1, 0), path)\na = tree", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["datatree", "pairs"]}
{"instruction": "Partition a flat list into a DataTree with n items per branch", "code": "import Grasshopper as gh\nn = partition_size\ntree = gh.DataTree[object]()\nfor i in range(0, len(items), n):\n    path = gh.Kernel.Data.GH_Path(i // n)\n    for item in items[i:i+n]:\n        tree.Add(item, path)\na = tree", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["datatree", "partition"]}
{"instruction": "Merge two DataTrees into one", "code": "import Grasshopper as gh\nmerged = gh.DataTree[object]()\nfor i in range(tree_a.BranchCount):\n    merged.AddRange(list(tree_a.Branch(i)), tree_a.Path(i))\nfor i in range(tree_b.BranchCount):\n    merged.AddRange(list(tree_b.Branch(i)), tree_b.Path(i))\na = merged", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["datatree", "merge"]}
{"instruction": "Reverse each branch of a DataTree", "code": "import Grasshopper as gh\nresult = gh.DataTree[object]()\nfor i in range(tree.BranchCount):\n    branch = list(tree.Branch(i))\n    branch.reverse()\n    result.AddRange(branch, tree.Path(i))\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["datatree", "reverse"]}
{"instruction": "Get the path indices from a DataTree", "code": "import Grasshopper as gh\npaths = []\nfor i in range(tree.BranchCount):\n    p = tree.Path(i)\n    paths.append(str(p))\na = paths", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["datatree", "paths"]}
{"instruction": "Create a 2-level nested DataTree (matrix structure)", "code": "import Grasshopper as gh\nimport Rhino.Geometry as rg\ntree = gh.DataTree[object]()\nfor i in range(rows):\n    for j in range(cols):\n        path = gh.Kernel.Data.GH_Path(i, j)\n        tree.Add(rg.Point3d(j, i, 0), path)\na = tree", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["datatree", "nested"]}
{"instruction": "Use ghpythonlib to move geometry by a vector", "code": "import ghpythonlib.components as ghcomp\nimport Rhino.Geometry as rg\nvec = rg.Vector3d(dx, dy, dz)\na = ghcomp.Move(geometry, vec).geometry", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["ghpythonlib", "move"]}
{"instruction": "Use ghpythonlib to rotate geometry around Z axis", "code": "import ghpythonlib.components as ghcomp\nimport Rhino.Geometry as rg\nimport math\na = ghcomp.Rotate(geometry, math.radians(angle), rg.Plane.WorldXY).geometry", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["ghpythonlib", "rotate"]}
{"instruction": "Boolean difference using ghpythonlib", "code": "import ghpythonlib.components as ghcomp\na = ghcomp.SolidDifference(brep_a, brep_b)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["ghpythonlib", "boolean", "difference"]}
{"instruction": "Boolean union using ghpythonlib", "code": "import ghpythonlib.components as ghcomp\na = ghcomp.SolidUnion(breps)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["ghpythonlib", "boolean", "union"]}
{"instruction": "Loft curves using ghpythonlib", "code": "import ghpythonlib.components as ghcomp\na = ghcomp.Loft(curves, None, False)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["ghpythonlib", "loft"]}
{"instruction": "Offset a curve using ghpythonlib", "code": "import ghpythonlib.components as ghcomp\nimport Rhino.Geometry as rg\na = ghcomp.OffsetCurve(curve, distance, rg.Plane.WorldXY, 1)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["ghpythonlib", "offset"]}
{"instruction": "Explode a polysurface using ghpythonlib", "code": "import ghpythonlib.components as ghcomp\nresult = ghcomp.BrepComponents(brep)\na = result.faces", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["ghpythonlib", "explode"]}
{"instruction": "Project a point onto a surface using ghpythonlib", "code": "import ghpythonlib.components as ghcomp\nimport Rhino.Geometry as rg\na = ghcomp.ProjectPoint(point, rg.Vector3d(0,0,-1), surface)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["ghpythonlib", "project"]}
{"instruction": "Divide a curve by count using ghpythonlib", "code": "import ghpythonlib.components as ghcomp\nresult = ghcomp.DivideCurve(curve, count, False)\na = result.points", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["ghpythonlib", "divide"]}
{"instruction": "Create a pipe along a curve using ghpythonlib", "code": "import ghpythonlib.components as ghcomp\na = ghcomp.Pipe(curve, radius, 1)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["ghpythonlib", "pipe"]}
{"instruction": "Scale geometry from a center point using ghpythonlib", "code": "import ghpythonlib.components as ghcomp\nimport Rhino.Geometry as rg\na = ghcomp.Scale(geometry, rg.Plane(center, rg.Vector3d.ZAxis), factor).geometry", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["ghpythonlib", "scale"]}
{"instruction": "Mirror geometry across a plane using ghpythonlib", "code": "import ghpythonlib.components as ghcomp\nimport Rhino.Geometry as rg\na = ghcomp.Mirror(geometry, rg.Plane.WorldYZ).geometry", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["ghpythonlib", "mirror"]}
{"instruction": "Extrude a curve along a vector using ghpythonlib", "code": "import ghpythonlib.components as ghcomp\nimport Rhino.Geometry as rg\nvec = rg.Vector3d(0, 0, height)\na = ghcomp.Extrude(curve, vec)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["ghpythonlib", "extrude"]}
{"instruction": "Cap planar holes in a brep using ghpythonlib", "code": "import ghpythonlib.components as ghcomp\na = ghcomp.CapHoles(brep)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["ghpythonlib", "cap"]}
{"instruction": "Get the area of a surface using ghpythonlib", "code": "import ghpythonlib.components as ghcomp\nresult = ghcomp.Area(geometry)\na = result.area", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["ghpythonlib", "area"]}
{"instruction": "Evaluate a surface at UV coordinates using ghpythonlib", "code": "import ghpythonlib.components as ghcomp\nimport Rhino.Geometry as rg\nresult = ghcomp.EvaluateSurface(surface, rg.Point2d(u, v))\na = result.point", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["ghpythonlib", "evaluate", "surface"]}
{"instruction": "Mesh a brep using ghpythonlib", "code": "import ghpythonlib.components as ghcomp\na = ghcomp.MeshBrep(brep)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["ghpythonlib", "mesh"]}
{"instruction": "Contour a brep using ghpythonlib", "code": "import ghpythonlib.components as ghcomp\nimport Rhino.Geometry as rg\na = ghcomp.Contour(brep, rg.Point3d(0,0,0), rg.Point3d(0,0,1), spacing)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["ghpythonlib", "contour"]}
{"instruction": "GhPython: create circles of varying radius based on distance to attractor point", "code": "import Rhino.Geometry as rg\nimport math\nresult = []\nfor pt in pts:\n    d = pt.DistanceTo(attractor)\n    r = max(0.1, max_val - d * 0.2)\n    circle = rg.Circle(rg.Plane(pt, rg.Vector3d.ZAxis), r)\n    result.append(circle.ToNurbsCurve())\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["attractor", "circle", "radius"]}
{"instruction": "GhPython: create circles of varying radius based on distance to attractor point", "code": "import Rhino.Geometry as rg\nimport math\nresult = []\nfor pt in pts:\n    d = pt.DistanceTo(attractor)\n    h = max(0.1, max_val - d * 0.2)\n    box = rg.Box(rg.Plane(pt, rg.Vector3d.ZAxis), rg.Interval(-0.5,0.5), rg.Interval(-0.5,0.5), rg.Interval(0,h))\n    result.append(box)\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["attractor", "box", "radius"]}
{"instruction": "GhPython: create circles of varying radius based on distance to attractor point", "code": "import Rhino.Geometry as rg\nimport math\nresult = []\nfor pt in pts:\n    d = pt.DistanceTo(attractor)\n    r = max(0.1, max_val - d * 0.2)\n    result.append(rg.Sphere(pt, r))\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["attractor", "sphere", "radius"]}
{"instruction": "GhPython: create boxes of varying height based on distance to attractor point", "code": "import Rhino.Geometry as rg\nimport math\nresult = []\nfor pt in pts:\n    d = pt.DistanceTo(attractor)\n    r = max(0.1, max_val - d * 0.2)\n    circle = rg.Circle(rg.Plane(pt, rg.Vector3d.ZAxis), r)\n    result.append(circle.ToNurbsCurve())\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["attractor", "circle", "height"]}
{"instruction": "GhPython: create boxes of varying height based on distance to attractor point", "code": "import Rhino.Geometry as rg\nimport math\nresult = []\nfor pt in pts:\n    d = pt.DistanceTo(attractor)\n    h = max(0.1, max_val - d * 0.2)\n    box = rg.Box(rg.Plane(pt, rg.Vector3d.ZAxis), rg.Interval(-0.5,0.5), rg.Interval(-0.5,0.5), rg.Interval(0,h))\n    result.append(box)\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["attractor", "box", "height"]}
{"instruction": "GhPython: create boxes of varying height based on distance to attractor point", "code": "import Rhino.Geometry as rg\nimport math\nresult = []\nfor pt in pts:\n    d = pt.DistanceTo(attractor)\n    r = max(0.1, max_val - d * 0.2)\n    result.append(rg.Sphere(pt, r))\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["attractor", "sphere", "height"]}
{"instruction": "GhPython: create scaled copies based on distance to attractor point", "code": "import Rhino.Geometry as rg\nimport math\nresult = []\nfor pt in pts:\n    d = pt.DistanceTo(attractor)\n    r = max(0.1, max_val - d * 0.2)\n    circle = rg.Circle(rg.Plane(pt, rg.Vector3d.ZAxis), r)\n    result.append(circle.ToNurbsCurve())\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["attractor", "circle", "scale"]}
{"instruction": "GhPython: create scaled copies based on distance to attractor point", "code": "import Rhino.Geometry as rg\nimport math\nresult = []\nfor pt in pts:\n    d = pt.DistanceTo(attractor)\n    h = max(0.1, max_val - d * 0.2)\n    box = rg.Box(rg.Plane(pt, rg.Vector3d.ZAxis), rg.Interval(-0.5,0.5), rg.Interval(-0.5,0.5), rg.Interval(0,h))\n    result.append(box)\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["attractor", "box", "scale"]}
{"instruction": "GhPython: create scaled copies based on distance to attractor point", "code": "import Rhino.Geometry as rg\nimport math\nresult = []\nfor pt in pts:\n    d = pt.DistanceTo(attractor)\n    r = max(0.1, max_val - d * 0.2)\n    result.append(rg.Sphere(pt, r))\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["attractor", "sphere", "scale"]}
{"instruction": "GhPython: create points with varying spacing based on distance to attractor point", "code": "import Rhino.Geometry as rg\nimport math\nresult = []\nfor pt in pts:\n    d = pt.DistanceTo(attractor)\n    r = max(0.1, max_val - d * 0.2)\n    circle = rg.Circle(rg.Plane(pt, rg.Vector3d.ZAxis), r)\n    result.append(circle.ToNurbsCurve())\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["attractor", "circle", "spacing"]}
{"instruction": "GhPython: create points with varying spacing based on distance to attractor point", "code": "import Rhino.Geometry as rg\nimport math\nresult = []\nfor pt in pts:\n    d = pt.DistanceTo(attractor)\n    h = max(0.1, max_val - d * 0.2)\n    box = rg.Box(rg.Plane(pt, rg.Vector3d.ZAxis), rg.Interval(-0.5,0.5), rg.Interval(-0.5,0.5), rg.Interval(0,h))\n    result.append(box)\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["attractor", "box", "spacing"]}
{"instruction": "GhPython: create points with varying spacing based on distance to attractor point", "code": "import Rhino.Geometry as rg\nimport math\nresult = []\nfor pt in pts:\n    d = pt.DistanceTo(attractor)\n    r = max(0.1, max_val - d * 0.2)\n    result.append(rg.Sphere(pt, r))\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["attractor", "sphere", "spacing"]}
{"instruction": "Sort points by distance from a reference point", "code": "import Rhino.Geometry as rg\nsorted_pts = sorted(pts, key=lambda p: p.DistanceTo(ref_pt))\na = sorted_pts", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["sort", "distance"]}
{"instruction": "Remove duplicate points within a tolerance", "code": "import Rhino.Geometry as rg\nunique = []\ntol = 0.01\nfor pt in pts:\n    is_dup = False\n    for u in unique:\n        if pt.DistanceTo(u) < tol:\n            is_dup = True\n            break\n    if not is_dup:\n        unique.append(pt)\na = unique", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["deduplicate", "points"]}
{"instruction": "Find the centroid of a list of points", "code": "import Rhino.Geometry as rg\nsum_x = sum(pt.X for pt in pts)\nsum_y = sum(pt.Y for pt in pts)\nsum_z = sum(pt.Z for pt in pts)\nn = len(pts)\na = rg.Point3d(sum_x/n, sum_y/n, sum_z/n)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["centroid"]}
{"instruction": "Create a convex hull outline from 2D points", "code": "import Rhino.Geometry as rg\nimport math\ndef cross(o, a, b):\n    return (a.X-o.X)*(b.Y-o.Y) - (a.Y-o.Y)*(b.X-o.X)\nsorted_pts = sorted(pts, key=lambda p: (p.X, p.Y))\nlower = []\nfor p in sorted_pts:\n    while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n        lower.pop()\n    lower.append(p)\nupper = []\nfor p in reversed(sorted_pts):\n    while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n        upper.pop()\n    upper.append(p)\nhull = lower[:-1] + upper[:-1]\nhull.append(hull[0])\na = rg.Polyline(hull).ToNurbsCurve()", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["convexhull"]}
{"instruction": "Connect nearest points with lines", "code": "import Rhino.Geometry as rg\nlines = []\nfor i, pt in enumerate(pts):\n    min_d = float('inf')\n    nearest = None\n    for j, other in enumerate(pts):\n        if i != j:\n            d = pt.DistanceTo(other)\n            if d < min_d:\n                min_d = d\n                nearest = other\n    if nearest:\n        lines.append(rg.Line(pt, nearest))\na = lines", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["nearest", "lines"]}
{"instruction": "Offset each point along its associated curve normal", "code": "import Rhino.Geometry as rg\nresult = []\nfor i, pt in enumerate(pts):\n    t = crv.ClosestPoint(pt)[1]\n    frame = None\n    success, frame = crv.PerpendicularFrameAt(t)\n    if success:\n        normal = frame.YAxis\n        result.append(pt + normal * offset_dist)\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["offset", "normal"]}
{"instruction": "Interpolate between two lists of points (blend)", "code": "import Rhino.Geometry as rg\nresult = []\nfor a_pt, b_pt in zip(pts_a, pts_b):\n    x = a_pt.X * (1-t) + b_pt.X * t\n    y = a_pt.Y * (1-t) + b_pt.Y * t\n    z = a_pt.Z * (1-t) + b_pt.Z * t\n    result.append(rg.Point3d(x, y, z))\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["interpolate", "blend"]}
{"instruction": "Create circles at curve division points", "code": "import Rhino.Geometry as rg\nparams = crv.DivideByCount(count, True)\nresult = []\nfor t in params:\n    pt = crv.PointAt(t)\n    frame = None\n    success, frame = crv.PerpendicularFrameAt(t)\n    if success:\n        circle = rg.Circle(frame, radius)\n        result.append(circle.ToNurbsCurve())\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["circles", "divide"]}
{"instruction": "Create a curve through the centroids of each tree branch", "code": "import Rhino.Geometry as rg\nimport Grasshopper as gh\ncentroids = []\nfor i in range(tree.BranchCount):\n    branch = tree.Branch(i)\n    cx = sum(p.X for p in branch) / len(branch)\n    cy = sum(p.Y for p in branch) / len(branch)\n    cz = sum(p.Z for p in branch) / len(branch)\n    centroids.append(rg.Point3d(cx, cy, cz))\na = rg.Curve.CreateInterpolatedCurve(centroids, 3)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["centroid", "datatree", "curve"]}
{"instruction": "Create a mesh grid in GhPython", "code": "import Rhino.Geometry as rg\nmesh = rg.Mesh()\nfor i in range(rows+1):\n    for j in range(cols+1):\n        mesh.Vertices.Add(j*size, i*size, 0)\nfor i in range(rows):\n    for j in range(cols):\n        a = i*(cols+1)+j\n        mesh.Faces.AddFace(a, a+1, a+cols+2, a+cols+1)\nmesh.Normals.ComputeNormals()\na = mesh", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["mesh", "grid"]}
{"instruction": "Deform a mesh grid with a sine wave", "code": "import Rhino.Geometry as rg\nimport math\nmesh = rg.Mesh()\nfor i in range(n+1):\n    for j in range(n+1):\n        z = amp * math.sin(i*freq) * math.cos(j*freq)\n        mesh.Vertices.Add(j, i, z)\nfor i in range(n):\n    for j in range(n):\n        a = i*(n+1)+j\n        mesh.Faces.AddFace(a, a+1, a+n+2, a+n+1)\nmesh.Normals.ComputeNormals()\na = mesh", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["mesh", "sine", "deform"]}
{"instruction": "Color mesh vertices by height (Z value)", "code": "import Rhino.Geometry as rg\nimport System.Drawing as sd\nfor i in range(mesh.Vertices.Count):\n    z = mesh.Vertices[i].Z\n    t = max(0, min(1, (z - z_min) / (z_max - z_min)))\n    r = int(255 * t)\n    b = int(255 * (1-t))\n    mesh.VertexColors.Add(sd.Color.FromArgb(r, 0, b))\na = mesh", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["mesh", "color", "height"]}
{"instruction": "Create a mesh from a closed polyline (triangulated fan)", "code": "import Rhino.Geometry as rg\nmesh = rg.Mesh()\ncenter = rg.Point3d(0,0,0)\nfor pt in pts:\n    center += rg.Point3d(pt.X/len(pts), pt.Y/len(pts), pt.Z/len(pts))\nmesh.Vertices.Add(center)\nfor pt in pts:\n    mesh.Vertices.Add(pt)\nfor i in range(len(pts)):\n    mesh.Faces.AddFace(0, i+1, (i+1)%len(pts)+1)\nmesh.Normals.ComputeNormals()\na = mesh", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["mesh", "fan"]}
{"instruction": "Weld mesh vertices within a tolerance", "code": "import Rhino.Geometry as rg\nmesh.Weld(tolerance)\nmesh.Normals.ComputeNormals()\na = mesh", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["mesh", "weld"]}
{"instruction": "Smooth mesh vertices by averaging neighbors", "code": "import Rhino.Geometry as rg\nfor iteration in range(steps):\n    new_verts = []\n    for i in range(mesh.Vertices.Count):\n        neighbors = mesh.Vertices.GetConnectedVertices(i)\n        if neighbors:\n            avg = rg.Point3d(0,0,0)\n            for n in neighbors:\n                avg += rg.Point3d(mesh.Vertices[n].X/len(neighbors), mesh.Vertices[n].Y/len(neighbors), mesh.Vertices[n].Z/len(neighbors))\n            new_verts.append(avg)\n        else:\n            new_verts.append(rg.Point3d(mesh.Vertices[i]))\n    for i, v in enumerate(new_verts):\n        mesh.Vertices.SetVertex(i, v)\nmesh.Normals.ComputeNormals()\na = mesh", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["mesh", "smooth"]}
{"instruction": "Return both area and centroid from a curve", "code": "import Rhino.Geometry as rg\namp = rg.AreaMassProperties.Compute(crv)\nif amp:\n    a = amp.Area\n    b = amp.Centroid\nelse:\n    a = 0\n    b = rg.Point3d.Origin", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["area", "centroid", "multi-output"]}
{"instruction": "Return length and midpoint of a curve", "code": "import Rhino.Geometry as rg\na = crv.GetLength()\nt = crv.Domain.Mid\nb = crv.PointAt(t)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["length", "midpoint", "multi-output"]}
{"instruction": "Split a list of numbers into positive and negative", "code": "import Rhino.Geometry as rg\nfrom scriptcontext import sticky\npos = [x for x in values if x >= 0]\nneg = [x for x in values if x < 0]\na = pos\nb = neg", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["filter", "multi-output"]}
{"instruction": "Deconstruct a plane into origin, X, Y, Z axes", "code": "import Rhino.Geometry as rg\na = plane.Origin\nb = plane.XAxis\nc = plane.YAxis\nd = plane.Normal", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["plane", "deconstruct", "multi-output"]}
{"instruction": "Return both the closest point and distance to a curve", "code": "import Rhino.Geometry as rg\nsuccess, t = crv.ClosestPoint(pt)\nif success:\n    a = crv.PointAt(t)\n    b = pt.DistanceTo(a)\nelse:\n    a = pt\n    b = 0", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["closestpoint", "distance", "multi-output"]}
{"instruction": "Convert a nested Python list to a DataTree using treehelpers", "code": "import ghpythonlib.treehelpers as th\nimport Rhino.Geometry as rg\nnested = [[rg.Point3d(j, i, 0) for j in range(cols)] for i in range(rows)]\na = th.list_to_tree(nested)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["treehelpers", "list_to_tree"]}
{"instruction": "Convert a DataTree to a nested Python list", "code": "import ghpythonlib.treehelpers as th\nimport Rhino.Geometry as rg\nnested = th.tree_to_list(tree)\na = nested", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["treehelpers", "tree_to_list"]}
{"instruction": "Create a tree of circles from a nested list of radii", "code": "import ghpythonlib.treehelpers as th\nimport Rhino.Geometry as rg\ncircles = []\nfor row in radii_nested:\n    row_circles = []\n    for r in row:\n        c = rg.Circle(rg.Plane.WorldXY, r).ToNurbsCurve()\n        row_circles.append(c)\n    circles.append(row_circles)\na = th.list_to_tree(circles)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["treehelpers", "circles"]}
{"instruction": "Generate a hexagonal grid of points", "code": "import Rhino.Geometry as rg\nimport math\nresult = []\nfor i in range(rows):\n    for j in range(cols):\n        x = j * spacing + (i % 2) * spacing * 0.5\n        y = i * spacing * math.sqrt(3) / 2\n        result.append(rg.Point3d(x, y, 0))\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["pattern", "hexagonal", "grid"]}
{"instruction": "Generate a Fibonacci spiral of points", "code": "import Rhino.Geometry as rg\nimport math\nresult = []\nfor i in range(count):\n    theta = i * math.radians(137.508)\n    r = math.sqrt(i) * scale\n    result.append(rg.Point3d(r*math.cos(theta), r*math.sin(theta), 0))\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["pattern", "fibonacci", "spiral"]}
{"instruction": "Generate a random point cloud within a bounding box", "code": "import Rhino.Geometry as rg\nimport random\nrandom.seed(seed)\nresult = []\nfor i in range(count):\n    x = random.uniform(0, width)\n    y = random.uniform(0, depth)\n    z = random.uniform(0, height)\n    result.append(rg.Point3d(x, y, z))\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["pattern", "random", "pointcloud"]}
{"instruction": "Generate a grid of points with noise displacement", "code": "import Rhino.Geometry as rg\nimport random\nimport math\nrandom.seed(seed)\nresult = []\nfor i in range(rows):\n    for j in range(cols):\n        x = j * spacing + random.uniform(-noise, noise)\n        y = i * spacing + random.uniform(-noise, noise)\n        z = random.uniform(-noise, noise)\n        result.append(rg.Point3d(x, y, z))\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["pattern", "grid", "noise"]}
{"instruction": "Create concentric circles with varying radii", "code": "import Rhino.Geometry as rg\nresult = []\nfor i in range(count):\n    r = (i + 1) * spacing\n    circle = rg.Circle(rg.Plane(center, rg.Vector3d.ZAxis), r)\n    result.append(circle.ToNurbsCurve())\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["pattern", "concentric", "circles"]}
{"instruction": "Create a Voronoi-like nearest neighbor connectivity", "code": "import Rhino.Geometry as rg\nlines = []\nfor i, p1 in enumerate(pts):\n    dists = []\n    for j, p2 in enumerate(pts):\n        if i != j:\n            dists.append((p1.DistanceTo(p2), j))\n    dists.sort()\n    for d, j in dists[:neighbors]:\n        lines.append(rg.Line(p1, pts[j]))\na = lines", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["pattern", "voronoi", "connectivity"]}
{"instruction": "Create a diamond grid pattern of lines", "code": "import Rhino.Geometry as rg\nlines = []\nfor i in range(rows):\n    for j in range(cols):\n        cx = j * spacing + (i % 2) * spacing * 0.5\n        cy = i * spacing * 0.5\n        top = rg.Point3d(cx, cy + spacing*0.5, 0)\n        right = rg.Point3d(cx + spacing*0.5, cy, 0)\n        bottom = rg.Point3d(cx, cy - spacing*0.5, 0)\n        left = rg.Point3d(cx - spacing*0.5, cy, 0)\n        lines.extend([rg.Line(top,right), rg.Line(right,bottom), rg.Line(bottom,left), rg.Line(left,top)])\na = lines", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["pattern", "diamond", "grid"]}
{"instruction": "Evaluate surface at UV and get normal", "code": "import Rhino.Geometry as rg\npt = srf.PointAt(u, v)\nnml = srf.NormalAt(u, v)\na = pt\nb = nml", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["surface", "normal", "evaluate"]}
{"instruction": "Get surface curvature at a UV parameter", "code": "import Rhino.Geometry as rg\ncurvature = srf.CurvatureAt(u, v)\nif curvature:\n    a = curvature.Kappa(0)\n    b = curvature.Kappa(1)\nelse:\n    a = 0\n    b = 0", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["surface", "curvature"]}
{"instruction": "Map a flat grid of points onto a surface using UV coordinates", "code": "import Rhino.Geometry as rg\nresult = []\nu_dom = srf.Domain(0)\nv_dom = srf.Domain(1)\nfor i in range(u_count):\n    for j in range(v_count):\n        u = u_dom.T0 + (u_dom.T1-u_dom.T0) * i / (u_count-1)\n        v = v_dom.T0 + (v_dom.T1-v_dom.T0) * j / (v_count-1)\n        result.append(srf.PointAt(u, v))\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["surface", "map", "uv"]}
{"instruction": "Extract iso-curves from a surface at regular intervals", "code": "import Rhino.Geometry as rg\ncurves = []\nu_dom = srf.Domain(0)\nfor i in range(count):\n    u = u_dom.T0 + (u_dom.T1-u_dom.T0) * i / (count-1)\n    iso = srf.IsoCurve(1, u)\n    if iso:\n        curves.append(iso)\na = curves", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["surface", "isocurve"]}
{"instruction": "Remap a value from one domain to another", "code": "import Rhino.Geometry as rg\ndef remap(val, src_min, src_max, dst_min, dst_max):\n    t = (val - src_min) / (src_max - src_min)\n    return dst_min + t * (dst_max - dst_min)\na = remap(value, in_min, in_max, out_min, out_max)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["remap", "utility"]}
{"instruction": "Clamp a list of values between min and max", "code": "import Rhino.Geometry as rg\na = [max(lo, min(hi, v)) for v in values]", "source": "synthetic", "category": "grasshopper_python", "difficulty": "easy", "api": "grasshopper", "tags": ["clamp", "utility"]}
{"instruction": "Generate a color gradient between two colors based on parameter", "code": "import Rhino.Geometry as rg\nimport System.Drawing as sd\ndef lerp_color(c1, c2, t):\n    r = int(c1.R + (c2.R - c1.R) * t)\n    g = int(c1.G + (c2.G - c1.G) * t)\n    b = int(c1.B + (c2.B - c1.B) * t)\n    return sd.Color.FromArgb(r, g, b)\na = [lerp_color(color_a, color_b, i/(count-1)) for i in range(count)]", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["color", "gradient"]}
{"instruction": "Store and retrieve data using sticky dictionary", "code": "import scriptcontext as sc\nif 'my_data' not in sc.sticky:\n    sc.sticky['my_data'] = []\nsc.sticky['my_data'].append(new_value)\na = sc.sticky['my_data']", "source": "synthetic", "category": "grasshopper_python", "difficulty": "medium", "api": "grasshopper", "tags": ["sticky", "persistent"]}
{"instruction": "Timer-based animation: increment counter each solve", "code": "import scriptcontext as sc\nimport Rhino.Geometry as rg\nif 'counter' not in sc.sticky:\n    sc.sticky['counter'] = 0\nsc.sticky['counter'] += 1\nt = sc.sticky['counter'] * 0.1\na = rg.Point3d(10 * __import__('math').cos(t), 10 * __import__('math').sin(t), 0)", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["animation", "sticky"]}
{"instruction": "Place a circle at each point on a surface grid, oriented to the surface normal", "code": "import Rhino.Geometry as rg\nresult = []\nu_dom = srf.Domain(0)\nv_dom = srf.Domain(1)\nfor i in range(u_count):\n    for j in range(v_count):\n        u = u_dom.T0 + (u_dom.T1-u_dom.T0) * i / max(u_count-1,1)\n        v = v_dom.T0 + (v_dom.T1-v_dom.T0) * j / max(v_count-1,1)\n        pt = srf.PointAt(u, v)\n        nml = srf.NormalAt(u, v)\n        result.append(rg.Circle(rg.Plane(pt, nml), radius).ToNurbsCurve())\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["surface", "populate", "circle"]}
{"instruction": "Place a sphere at each point on a surface grid, oriented to the surface normal", "code": "import Rhino.Geometry as rg\nresult = []\nu_dom = srf.Domain(0)\nv_dom = srf.Domain(1)\nfor i in range(u_count):\n    for j in range(v_count):\n        u = u_dom.T0 + (u_dom.T1-u_dom.T0) * i / max(u_count-1,1)\n        v = v_dom.T0 + (v_dom.T1-v_dom.T0) * j / max(v_count-1,1)\n        pt = srf.PointAt(u, v)\n        nml = srf.NormalAt(u, v)\n        result.append(rg.Sphere(pt, radius))\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["surface", "populate", "sphere"]}
{"instruction": "Place a line along normal at each point on a surface grid, oriented to the surface normal", "code": "import Rhino.Geometry as rg\nresult = []\nu_dom = srf.Domain(0)\nv_dom = srf.Domain(1)\nfor i in range(u_count):\n    for j in range(v_count):\n        u = u_dom.T0 + (u_dom.T1-u_dom.T0) * i / max(u_count-1,1)\n        v = v_dom.T0 + (v_dom.T1-v_dom.T0) * j / max(v_count-1,1)\n        pt = srf.PointAt(u, v)\n        nml = srf.NormalAt(u, v)\n        result.append(rg.Line(pt, pt + nml * length))\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["surface", "populate", "line along normal"]}
{"instruction": "Place a box at each point on a surface grid, oriented to the surface normal", "code": "import Rhino.Geometry as rg\nresult = []\nu_dom = srf.Domain(0)\nv_dom = srf.Domain(1)\nfor i in range(u_count):\n    for j in range(v_count):\n        u = u_dom.T0 + (u_dom.T1-u_dom.T0) * i / max(u_count-1,1)\n        v = v_dom.T0 + (v_dom.T1-v_dom.T0) * j / max(v_count-1,1)\n        pt = srf.PointAt(u, v)\n        nml = srf.NormalAt(u, v)\n        result.append(rg.Box(rg.Plane(pt, nml), rg.Interval(-s/2,s/2), rg.Interval(-s/2,s/2), rg.Interval(0,s)))\na = result", "source": "synthetic", "category": "grasshopper_python", "difficulty": "hard", "api": "grasshopper", "tags": ["surface", "populate", "box"]}
