{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_shortEdges.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_shortEdges.py",
  "instruction": "Send any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums, https://discourse.mcneel.com/",
  "code": "\"\"\"\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums, https://discourse.mcneel.com/\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n221114: Created.\r\n221118: Bug fix: Added a View.Redraw.\r\n221119: Added option to dot edges.\r\n221204: Bug fix: Now dots are added to current layer.\r\n251001: Modified an option default value.\r\n\"\"\"\r\n\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System.Drawing import Color\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fMaxLength'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance #1e-4\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bShortestOnly'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'Mark'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'All', 'Shortest')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDupCrv'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddDot'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bIncludeIndex'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iDotHt'; keys.append(key)\r\n    values[key] = 11\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], setLowerLimit=True, limit=3)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fMaxLength':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.values[key] = cls.riOpts[key].InitialValue\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                return\r\n\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getAllNormalBreps():\r\n    oes = rd.ObjectEnumeratorSettings()\r\n    oes.NormalObjects = True\r\n    oes.LockedObjects = False # Default is True.\r\n    oes.IncludeLights = False\r\n    oes.IncludeGrips = False\r\n    oes.ObjectTypeFilter = rd.ObjectType.Brep\r\n    return list(sc.doc.Objects.GetObjectList(oes))\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select breps\")\r\n    go.SetCommandPromptDefault(\"All normal when none are selected\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Brep\r\n    go.SubObjectSelect = False\r\n\r\n    go.AcceptNothing(True)\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    idxs_Opt = {}\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n\r\n        addOption('fMaxLength')\r\n        addOption('bShortestOnly')\r\n        addOption('bDupCrv')\r\n        addOption('bAddDot')\r\n        if Opts.values['bAddDot']:\r\n            addOption('bIncludeIndex')\r\n            addOption('iDotHt')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            go.Dispose()\r\n            return getAllNormalBreps()\r\n\r\n        if res == ri.GetResult.Object:\r\n            rdObjs = [o.Object() for o in go.Objects()]\r\n            go.Dispose()\r\n            return rdObjs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fMaxLength'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef formatDistance(fDistance, iPrecision=None):\r\n    if iPrecision is None:\r\n        iPrecision = sc.doc.ModelDistanceDisplayPrecision\r\n    if fDistance is None:\r\n        return \"(No value provided)\"\r\n    if fDistance == 0.0:\r\n        return \"0\"\r\n    if fDistance < 0.01:\r\n        return \"{:.2e}\".format(fDistance)\r\n    return \"{:.{}g}\".format(fDistance, iPrecision)\r\n\r\n\r\ndef main():\r\n\r\n    rdBs_In = getInput()\r\n    if rdBs_In is None: return\r\n\r\n    fMaxLength = Opts.values['fMaxLength']\r\n    bShortestOnly = Opts.values['bShortestOnly']\r\n    bDupCrv = Opts.values['bDupCrv']\r\n    bAddDot = Opts.values['bAddDot']\r\n    bIncludeIndex = Opts.values['bIncludeIndex']\r\n    iDotHt = Opts.values['iDotHt']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n\r\n    fLengths_Short = []\r\n    gBs_WithShort = []\r\n    idxEs_Short = []\r\n\r\n    fMinLength_All = float(\"inf\")\r\n\r\n    bReportEveryBrep = False\r\n    if 1 <= len(rdBs_In) <= 10:\r\n        bReportEveryBrep = True\r\n    elif 10 < len(rdBs_In):\r\n        s  = \"More than 10 breps are selected,\"\r\n        s += \" so only maximum of all edge tolerances,\"\r\n        s += \" is reported.\"\r\n        print(s)\r\n    else:\r\n        return\r\n\r\n    gCrvs_Out = []\r\n    gDots_Out = []\r\n    if bAddDot:\r\n        attrib_Dot = rd.ObjectAttributes()\r\n        attrib_Dot.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n        attrib_Dot.ObjectColor = Color.Red\r\n        attrib_Dot.LayerIndex = sc.doc.Layers.CurrentLayerIndex\r\n\r\n\r\n    epsilon_Shortest = 0.5 * 10.0**-sc.doc.ModelDistanceDisplayPrecision\r\n    print(\"TODO: determine epsilon for shortest.  Now is {}.\".format(epsilon_Shortest))\r\n\r\n    for iB, rdB in enumerate(rdBs_In):\r\n        gB = rdB.Id\r\n        rgB = rdB.BrepGeometry\r\n\r\n        for rgE in rgB.Edges:\r\n            fLength = rgE.GetLength()\r\n            if fLength > fMaxLength: continue\r\n\r\n            fLengths_Short.append(fLength)\r\n            gBs_WithShort.append(gB)\r\n            idxEs_Short.append([rgE.EdgeIndex])\r\n\r\n            if fLength < fMinLength_All:\r\n                fMinLength_All = fLength\r\n\r\n            if bShortestOnly:\r\n                continue # Shortest will be marked after for loops.\r\n\r\n            if bDupCrv:\r\n                gCrvs_Out.append(sc.doc.Objects.AddCurve(rgE))\r\n\r\n            if bAddDot:\r\n                text = formatDistance(fLength)\r\n                if bIncludeIndex:\r\n                    text = \"e[{}]:\".format(rgE.EdgeIndex) + text\r\n                location = rgE.PointAt(rgE.Domain.Mid)\r\n                rgDot = rg.TextDot(text, location)\r\n                rgDot.FontHeight = iDotHt\r\n                gDots_Out.append(sc.doc.Objects.AddTextDot(rgDot, attrib_Dot))\r\n\r\n\r\n\r\n    if not fLengths_Short:\r\n        print(\"No edge lengths <= {} found.\".format(formatDistance(fMaxLength)))\r\n        return\r\n\r\n    print(\"Found {} edges in {} breps with lengths [{},{}].\".format(\r\n        len(idxEs_Short),\r\n        len(set(gBs_WithShort)),\r\n        formatDistance(min(fLengths_Short)),\r\n        formatDistance(max(fLengths_Short))))\r\n\r\n    if not bShortestOnly:\r\n        sc.doc.Views.Redraw()\r\n        return\r\n\r\n\r\n    # Find edges closest to maximum.\r\n    fLengths_Shortest = []\r\n    gBs_WithShortest = []\r\n    idxEs_Shortest = []\r\n\r\n    for fLength, gB, idxE in zip(fLengths_Short, gBs_WithShort, idxEs_Short):\r\n        if (fLength - fMinLength_All) < epsilon_Shortest:\r\n            fLengths_Shortest.append(fLength)\r\n            gBs_WithShortest.append(gBs_WithShortest)\r\n            idxEs_Shortest.append(idxEs_Shortest)\r\n\r\n            if bDupCrv:\r\n                gCrvs_Out.append(sc.doc.Objects.AddCurve(rgE))\r\n\r\n            if bAddDot:\r\n                text = formatDistance(fLength)\r\n                if bIncludeIndex:\r\n                    text = \"e[{}]:\".format(rgE.EdgeIndex) + text\r\n                location = rgE.PointAt(rgE.Domain.Mid)\r\n                rgDot = rg.TextDot(text, location)\r\n                rgDot.FontHeight = iDotHt\r\n                gDots_Out.append(sc.doc.Objects.AddTextDot(rgDot, attrib_Dot))\r\n\r\n\r\n    print(\"Found {} edges in {} breps within {} of {}.\".format(\r\n        len(idxEs_Shortest),\r\n        len(set(gBs_WithShortest)),\r\n        formatDistance(epsilon_Shortest),\r\n        formatDistance(fLengths_Shortest)))\r\n\r\n    if bDupCrv:\r\n        print(\"{} curves added.\".format(len(gDots_Out)))\r\n    if bAddDot:\r\n        print(\"{} dots added.\".format(len(gDots_Out)))\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}