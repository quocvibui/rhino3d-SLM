{
  "source_url": "https://github.com/969flash/DesignAutomationLecture/blob/4e85efcd91e11c0715f2ff7d7e1162cc84c942f1/stub/RhinoStub/ghpythonlib_components_inferred.pyi",
  "repo": "969flash/DesignAutomationLecture",
  "repo_stars": 0,
  "repo_description": "DesignAutomationLecture",
  "license": "unknown",
  "filepath": "stub/RhinoStub/ghpythonlib_components_inferred.pyi",
  "instruction": "Stub file for ghpythonlib.components",
  "code": "# Stub file for ghpythonlib.components\n\nfrom typing import Any, List, Union, Optional, Tuple\nimport Rhino.Geometry\nimport Rhino.DocObjects\nimport System.Drawing\n\ndef Addition(a: Union[float, int], b: Union[float, int]) -> Union[float, int]: ...\ndef AlignFaces(planea: Rhino.Geometry.Plane, planeb: Rhino.Geometry.Plane, facea: Any, faceb: Any) -> Any: ...\ndef AlignPlanes(master: Rhino.Geometry.Plane) -> Rhino.Geometry.Plane: ...\ndef AlignedDimension(aligned_dimension: Any, plane: Rhino.Geometry.Plane, point_a: Rhino.Geometry.Point3d, point_b: Rhino.Geometry.Point3d, offset: float, style: Any) -> Any: ...\ndef Anchor(point: Rhino.Geometry.Point3d, target: Rhino.Geometry.Point3d) -> Rhino.Geometry.Point3d: ...\ndef AnchorXYZ(point: Rhino.Geometry.Point3d) -> Rhino.Geometry.Point3d: ...\ndef Angle(linea: Union[Rhino.Geometry.Line, Rhino.Geometry.Vector3d], lineb: Union[Rhino.Geometry.Line, Rhino.Geometry.Vector3d], restangle: float) -> float: ...\ndef AngleDimensionArc(angle_dimension: Any, arc: Rhino.Geometry.Arc, offset: float, style: Any) -> Any: ...\ndef AngleDimensionLines(angle_dimension: Any, plane: Rhino.Geometry.Plane, line_a: Rhino.Geometry.Line, line_b: Rhino.Geometry.Line, dimension_location: Rhino.Geometry.Point3d, style: Any) -> Any: ...\ndef AngleDimensionPoints(angle_dimension: Any, center: Rhino.Geometry.Point3d, point_a: Rhino.Geometry.Point3d, point_b: Rhino.Geometry.Point3d, dimension_location: Rhino.Geometry.Point3d, style: Any) -> Any: ...\ndef AngleSnap(linea: Union[Rhino.Geometry.Line, Rhino.Geometry.Vector3d], lineb: Union[Rhino.Geometry.Line, Rhino.Geometry.Vector3d], factor: float) -> Union[Rhino.Geometry.Line, Rhino.Geometry.Vector3d]: ...\ndef AngularDimensionsMesh(minimum_angle: float, maximum_angle: float) -> Rhino.Geometry.Mesh: ...\ndef AnnotationArrowSettings(arrow_settings: Any, arrow_1: Any, arrow_2: Any, arrow_size: float, fit_arrow: bool, dimension_inline: bool, leader_arrow: Any, leader_arrow_size: float) -> Any: ...\ndef AnnotationDimensionSettings(dimension_settings: Any, view_oriented: bool, text_location: Any, text_rotation: Any, radial_view_oriented: bool, radial_text_location: Any, radial_text_rotation: Any, dimension_line_extension: float, extension_line_extension: float, extension_line_offset: float, fixed_extension: bool, fixed_extension_length: float, suppress_extension_1: bool, suppress_extension_2: bool, baseline_spacing: float, centermark_size: float, centermark_type: Any, decimal_separator: str) -> Any: ...\ndef AnnotationDot(annotation_dot: Any, location: Rhino.Geometry.Point3d, primary_text: str, text_height: float) -> Any: ...\ndef AnnotationLeaderSettings(leader_settings: Any, leader_curve_type: Any, has_landing: bool, landing_length: float, view_oriented: bool, horizontal_text_alignment: Any, vertical_text_alignment: Any) -> Any: ...\ndef AnnotationStyle(annotation_style: Any, name: str, model_scale: float, text_settings: Any, dimension_settings: Any, arrow_settings: Any, units_settings: Any, leader_settings: Any, tolerance_settings: Any) -> Any: ...\ndef AnnotationStyleOverrides(style: Any, model_scale: float, text_settings: Any, dimension_settings: Any, arrow_settings: Any, units_settings: Any, leader_settings: Any, tolerance_settings: Any) -> Any: ...\ndef AnnotationTextOverrides(text: str, view_oriented: bool) -> Any: ...\ndef AnnotationTextSettings(text_settings: Any, font: str, text_height: float, text_gap: float, mask: bool) -> Any: ...\ndef AnnotationToleranceSettings(tolerance_settings: Any, tolerance_format: Any) -> Any: ...\ndef AnnotationUnitsSettings(units_settings: Any, length_units_format: Any, length_factor: float, linear_resolution: Any, roundoff: float, prefix: str, suffix: str, zero_suppression: Any, fraction_format: Any, fraction_height_scale: float, angular_units_format: Any, angle_resolution: Any, angle_roundoff: float, angle_zero_suppression: Any) -> Any: ...\ndef Beam(startframe: Rhino.Geometry.Plane, endframe: Rhino.Geometry.Plane, startnode: Any, endnode: Any) -> Any: ...\ndef Bomb(location: Rhino.Geometry.Point3d, points: List[Rhino.Geometry.Point3d]) -> List[Rhino.Geometry.Point3d]: ...\ndef BouncySolver(goalobjects: List[Any]) -> Any: ...\ndef BoxArray(geometry: Any) -> List[Rhino.Geometry.Box]: ...\ndef BoxMapping(geometry: Any) -> Rhino.Geometry.Transform: ...\ndef CameraObscura(geometry: Any) -> Any: ...\ndef Centermark(centermark: Any, plane: Rhino.Geometry.Plane, curve: Rhino.Geometry.Curve, parameter: float, style: Any) -> Any: ...\ndef CharSequence(format: str) -> List[str]: ...\ndef ClampAngle(linea: Union[Rhino.Geometry.Line, Rhino.Geometry.Vector3d], lineb: Union[Rhino.Geometry.Line, Rhino.Geometry.Vector3d]) -> Union[Rhino.Geometry.Line, Rhino.Geometry.Vector3d]: ...\ndef ClampLength(line: Rhino.Geometry.Line, lowerlimit: float, upperlimit: float) -> Rhino.Geometry.Line: ...\ndef CloudDisplay(points: List[Rhino.Geometry.Point3d], colours: List[Any], size: float) -> Any: ...\ndef CoCircular(points: List[Rhino.Geometry.Point3d]) -> bool: ...\ndef CoLinear(points: List[Rhino.Geometry.Point3d]) -> bool: ...\ndef CoPlanar(points: List[Rhino.Geometry.Point3d]) -> bool: ...\ndef CoSpherical(points: List[Rhino.Geometry.Point3d]) -> bool: ...\ndef Coincident(point0: Rhino.Geometry.Point3d, point1: Rhino.Geometry.Point3d) -> bool: ...\ndef Collider(objects: List[Any], radii: List[float], ignorea: List[bool], ignoreb: List[bool]) -> Any: ...\ndef ColourGradient(gradient: Any, start_point: Rhino.Geometry.Point3d, end_point: Rhino.Geometry.Point3d, repeat: float, type: Any, colours: List[Any]) -> Any: ...\ndef CombineData(input_0: Any, input_1: Any) -> List[Any]: ...\ndef Concatenate(fragment_a: str, fragment_b: str) -> str: ...\ndef Concentric(planea: Rhino.Geometry.Plane, planeb: Rhino.Geometry.Plane) -> bool: ...\ndef ConstantTension(line: Rhino.Geometry.Line) -> Any: ...\ndef ConstructMatrix(values: List[float]) -> Rhino.Geometry.Transform: ...\ndef ConstructMesh(colours: List[Any]) -> Rhino.Geometry.Mesh: ...\ndef ContainsTextFilter(case: bool, culture: str) -> Any: ...\ndef ContentCache(content: Any) -> Any: ...\ndef ContentIdentity(path: str) -> Any: ...\ndef ContentInformation(parent: Any) -> str: ...\ndef Contourex(offsets: List[float], distances: List[float]) -> List[Rhino.Geometry.Curve]: ...\ndef ConvexHull(plane: Rhino.Geometry.Plane) -> Rhino.Geometry.Polyline: ...\ndef CurveArray(geometry: List[Rhino.Geometry.Curve]) -> List[Rhino.Geometry.Curve]: ...\ndef CurveCollide(frames: List[Rhino.Geometry.Plane], passivecurves: List[Rhino.Geometry.Curve]) -> Any: ...\ndef CurveDomain(domain: Rhino.Geometry.Interval) -> Rhino.Geometry.Interval: ...\ndef CurvePointCollide(points: List[Rhino.Geometry.Point3d], curve: Rhino.Geometry.Curve) -> Any: ...\ndef CurveSide(plane: Rhino.Geometry.Plane) -> int: ...\ndef CurveToPolyline(minedge: float, maxedge: float) -> Rhino.Geometry.Polyline: ...\ndef CustomCurvePreview(linetype: Any) -> Any: ...\ndef DataDam(data_a: Any) -> Any: ...\ndef DataOutput(data_input: Any) -> Any: ...\ndef DelaunayEdges(plane: Rhino.Geometry.Plane) -> List[Rhino.Geometry.Line]: ...\ndef DelaunayMesh(plane: Rhino.Geometry.Plane) -> Rhino.Geometry.Mesh: ...\ndef Direction(line: Rhino.Geometry.Line, direction: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Vector3d: ...\ndef DirectionalLight(directional_light: Any, location: Rhino.Geometry.Point3d, direction: Rhino.Geometry.Vector3d) -> Any: ...\ndef DisplayAttributes(display: Any, display_colour: Any, display_mode: str) -> Any: ...\ndef DisplayColour(display_colour: Any, source: Any, colour: Any) -> Any: ...\ndef DraftingAttributes(drafting: Any, linetype: Any, linetype_scale: float) -> Any: ...\ndef DraftingScale(annotation_model_scaling: float, annotation_layout_scaling: float, hatch_scaling: bool, hatch_scale: float, linetype_scale: float) -> Any: ...\ndef DuplicateContent(name: str) -> Any: ...\ndef DynamicWeight1d(line: Rhino.Geometry.Line) -> Any: ...\ndef EdgeSurface(curve_c: Rhino.Geometry.Curve, curve_d: Rhino.Geometry.Curve) -> Rhino.Geometry.Surface: ...\ndef EdgesfromPoints(tolerance: float) -> List[Rhino.Geometry.Line]: ...\ndef EqualAngle(linea: Union[Rhino.Geometry.Line, Rhino.Geometry.Vector3d], lineb: Union[Rhino.Geometry.Line, Rhino.Geometry.Vector3d]) -> bool: ...\ndef EqualLength(line: List[Rhino.Geometry.Line]) -> bool: ...\ndef Evaluate(x: float, y: float) -> float: ...\ndef ExplodeTree(data: Any) -> List[Any]: ...\ndef Exposure(obstructions: List[Any], energy: float) -> float: ...\ndef Expression(x: float, y: float) -> float: ...\ndef FacetDome(box: Rhino.Geometry.Box, radius: float) -> Rhino.Geometry.Mesh: ...\ndef FilletEdge(edges: List[Any], radii: List[float]) -> Any: ...\ndef FitCurve(degree: int, tolerance: float) -> Rhino.Geometry.Curve: ...\ndef Flip(guide: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Vector3d: ...\ndef FlipCurve(guide: Rhino.Geometry.Curve) -> Rhino.Geometry.Curve: ...\ndef Floor(strength: float) -> Any: ...\ndef FloorFriction(points: List[Rhino.Geometry.Point3d]) -> Any: ...\ndef Format(data_0: Any, data_1: Any) -> str: ...\ndef G2(points: List[Rhino.Geometry.Point3d]) -> Any: ...\ndef GateAnd(a: bool, b: bool) -> bool: ...\ndef GateOr(a: bool, b: bool) -> bool: ...\ndef GradientColourStop(color_stop: Any, colour: Any, position: float) -> Any: ...\ndef HideModelLayer(model: Any, new_detail: bool) -> Any: ...\ndef Hinge(foldstart: Rhino.Geometry.Point3d, foldend: Rhino.Geometry.Point3d, tip1: Rhino.Geometry.Point3d, tip2: Rhino.Geometry.Point3d, restangle: float) -> Any: ...\ndef ImageCircles(curves: List[Rhino.Geometry.Curve]) -> List[Rhino.Geometry.Circle]: ...\ndef ImportCoordinates(comment: str) -> List[Rhino.Geometry.Point3d]: ...\ndef ImportImage(rectangle: Rhino.Geometry.Rectangle3d, x_samples: int, y_samples: int) -> Any: ...\ndef ImportModelBlockDefinition(name: str) -> Any: ...\ndef InsertItems(item: Any) -> List[Any]: ...\ndef IronPython2Script(x: Any, y: Any) -> Any: ...\ndef Kaleidoscope(geometry: Any) -> List[Any]: ...\ndef Leader(leader: Any, plane: Rhino.Geometry.Plane, curve: Rhino.Geometry.Curve, text: str, style: Any) -> Any: ...\ndef Legend(colour: List[Any], tags: List[str], rectangle: Rhino.Geometry.Rectangle3d) -> Any: ...\ndef LengthLine(line: Rhino.Geometry.Line, length: float) -> Rhino.Geometry.Line: ...\ndef LengthRatio(linea: Rhino.Geometry.Line, lineb: Rhino.Geometry.Line, ratio: float) -> float: ...\ndef LengthSnap(line: Rhino.Geometry.Line, factor: float) -> Rhino.Geometry.Line: ...\ndef LightAttributes(enabled: bool, colour: Any, intensity: float, shadow_intensity: float, falloff: Any) -> Any: ...\ndef LineCharge(bounds: Rhino.Geometry.BoundingBox) -> Any: ...\ndef LinearArray(geometry: Any) -> List[Any]: ...\ndef LinearDimension(linear_dimension: Any, base_line: Rhino.Geometry.Line, point_a: Rhino.Geometry.Point3d, point_b: Rhino.Geometry.Point3d, style: Any) -> Any: ...\ndef LinearLight(linear_light: Any, line: Rhino.Geometry.Line) -> Any: ...\ndef Load(point: Rhino.Geometry.Point3d) -> Any: ...\ndef MagnetSnap(points: List[Rhino.Geometry.Point3d]) -> List[Rhino.Geometry.Point3d]: ...\ndef Make2D(clipping_planes: List[Rhino.Geometry.Plane]) -> List[Rhino.Geometry.Curve]: ...\ndef MatchText(pattern: str, regex: bool) -> bool: ...\ndef MatchTextFilter(case: bool, culture: str) -> Any: ...\ndef Merge(data_1: Any, data_2: Any) -> List[Any]: ...\ndef MetaBall(accuracy: float) -> Rhino.Geometry.Mesh: ...\ndef MetaBallt(accuracy: float) -> Rhino.Geometry.Mesh: ...\ndef MetaBalltCustom(accuracy: float) -> Rhino.Geometry.Mesh: ...\ndef Mirror(geometry: Any) -> Any: ...\ndef ModelBasicEnvironment(environment: Any, name: str, background_colour: Any, projection: Any) -> Any: ...\ndef ModelBlockDefinition(block_definition: Any, objects: List[Any], name: str) -> Any: ...\ndef ModelBlockInstance(block_instance: Any, transform: Rhino.Geometry.Transform, block_definition: Any) -> Any: ...\ndef ModelEarthLocation(location: Any, name: str, anchor: Rhino.Geometry.Point3d, latitude: float, longitude: float, elevation: float) -> Any: ...\ndef ModelFont(font: Any, font_family: str, font_weight: Any, font_style: Any) -> Any: ...\ndef ModelHatch(hatch: Any, boundary: List[Rhino.Geometry.Curve], plane: Rhino.Geometry.Plane, hatch_pattern: Any, base_point: Rhino.Geometry.Point3d, rotation: float, scale: float, show_boundary: bool, background: bool, fill_style: Any) -> Any: ...\ndef ModelHatchLine(hatch_line: Any, start: Rhino.Geometry.Point3d, direction: Rhino.Geometry.Vector3d, shift: float, offset: float, segments: List[float]) -> Any: ...\ndef ModelHatchPattern(hatch_pattern: Any, name: str, hatch_lines: List[Any]) -> Any: ...\ndef ModelLayer(layer: Any, name: str, hidden: bool, locked: bool, display_colour: Any, material: Any, linetype: Any) -> Any: ...\ndef ModelLinetype(linetype: Any, name: str, segments: List[float], cap_style: Any, join_style: Any, width: float, width_units: Any) -> Any: ...\ndef ModelMaterial(material: Any, name: str, shader: Any) -> Any: ...\ndef ModelObject(object: Any, geometry: Any, name: str, layer: Any, visibility: Any, display: Any, drafting: Any, render: Any) -> Any: ...\ndef ModelView(view: Any, title: str, perspective: bool, location: Rhino.Geometry.Point3d, target: Rhino.Geometry.Point3d, x_extents: float, y_extents: float) -> Any: ...\ndef ModelViewport(viewport: Any, name: str, view: Any, display_mode: str) -> Any: ...\ndef ModifiedArc(radius: float, angle: float) -> Rhino.Geometry.Arc: ...\ndef MorphToMesh(geometry: Any, mesh: Rhino.Geometry.Mesh) -> Any: ...\ndef Move(geometry: Any) -> Any: ...\ndef MultiPipe(sizepoints: List[Rhino.Geometry.Point3d], caps: List[bool]) -> List[Rhino.Geometry.Brep]: ...\ndef Multiplication(a: Union[float, int], b: Union[float, int]) -> Union[float, int]: ...\ndef NamedGroup(group: Any, geometry: List[Any], name: str) -> Any: ...\ndef NoFoldThrough(foldstart: Rhino.Geometry.Point3d, foldend: Rhino.Geometry.Point3d, tip1: Rhino.Geometry.Point3d, tip2: Rhino.Geometry.Point3d) -> Any: ...\ndef NullItem(item: Any) -> Optional[Any]: ...\ndef NurbsCurvePWK(weights: List[float]) -> Rhino.Geometry.NurbsCurve: ...\ndef ObjectLinetype(linetype: Any, source: Any, model_linetype: Any) -> Any: ...\ndef OffsetCurve(plane: Rhino.Geometry.Plane) -> Rhino.Geometry.Curve: ...\ndef OffsetCurveLoose(plane: Rhino.Geometry.Plane) -> Rhino.Geometry.Curve: ...\ndef OnCurve(points: List[Rhino.Geometry.Point3d], curve: Rhino.Geometry.Curve) -> List[Rhino.Geometry.Point3d]: ...\ndef OnMesh(points: List[Rhino.Geometry.Point3d], mesh: Rhino.Geometry.Mesh) -> List[Rhino.Geometry.Point3d]: ...\ndef OnPlane(points: List[Rhino.Geometry.Point3d], plane: Rhino.Geometry.Plane) -> List[Rhino.Geometry.Point3d]: ...\ndef OrdinateDimension(ordinate_dimension: Any, plane: Rhino.Geometry.Plane, direction: Rhino.Geometry.Vector3d) -> Any: ...\ndef Orient(geometry: Any) -> Any: ...\ndef OrientDirection(geometry: Any) -> Any: ...\ndef Patch(curves: List[Rhino.Geometry.Curve], points: List[Rhino.Geometry.Point3d]) -> Rhino.Geometry.Surface: ...\ndef PicknChoose(stream_0: Any, stream_1: Any) -> Any: ...\ndef PlasticAnchor(point: Rhino.Geometry.Point3d) -> Any: ...\ndef PlasticHinge(foldstart: Rhino.Geometry.Point3d, foldend: Rhino.Geometry.Point3d, tip1: Rhino.Geometry.Point3d, tip2: Rhino.Geometry.Point3d, restangle: float) -> Any: ...\ndef PlasticLength(line: Rhino.Geometry.Line) -> Any: ...\ndef PointCharge(bounds: Rhino.Geometry.BoundingBox) -> Any: ...\ndef PointCloudAttributes(cloud: List[Rhino.Geometry.Point3d], locations: List[Rhino.Geometry.Point3d], normals: List[Rhino.Geometry.Vector3d], colours: List[Any], extra: List[float], hidden: List[bool]) -> Any: ...\ndef PointCloudContour(start: Rhino.Geometry.Point3d, direction: Rhino.Geometry.Vector3d, distance: float, limit: int) -> List[Rhino.Geometry.Curve]: ...\ndef PointLight(point_light: Any, location: Rhino.Geometry.Point3d) -> Any: ...\ndef PointList(points: List[Rhino.Geometry.Point3d], size: float) -> Any: ...\ndef PointOrder(points: List[Rhino.Geometry.Point3d]) -> List[int]: ...\ndef PolarArray(geometry: Any) -> List[Any]: ...\ndef PolyArc(tangent: bool) -> Rhino.Geometry.PolylineCurve: ...\ndef PolygonArea(polyline: Rhino.Geometry.Polyline, area: float) -> Rhino.Geometry.Polyline: ...\ndef Populate2D(points: List[Rhino.Geometry.Point3d]) -> List[Rhino.Geometry.Point3d]: ...\ndef Populate3D(points: List[Rhino.Geometry.Point3d]) -> List[Rhino.Geometry.Point3d]: ...\ndef PopulateGeometry(points: List[Rhino.Geometry.Point3d]) -> List[Rhino.Geometry.Point3d]: ...\ndef PrintColour(print_colour: Any, source: Any, colour: Any) -> Any: ...\ndef PrintWidth(print_width: Any, source: Any, width: float) -> Any: ...\ndef Project(geometry: Any) -> Any: ...\ndef ProjectAlong(geometry: Any) -> Any: ...\ndef Proximity2D(min_radius: float, max_radius: float) -> Any: ...\ndef Proximity3D(min_radius: float, max_radius: float) -> Any: ...\ndef Python3Script(x: Any, y: Any) -> Any: ...\ndef QuadRemesh(guides: List[Rhino.Geometry.Curve]) -> Rhino.Geometry.Mesh: ...\ndef QuadRemeshSettings(target_edge_length: float) -> Any: ...\ndef QuadTree(plane: Rhino.Geometry.Plane) -> Any: ...\ndef QueryAnnotationStyles(name: str) -> List[Any]: ...\ndef QueryDirectory(max_depth: int, name: str) -> List[str]: ...\ndef QueryInstalledFonts(font_family: str, font_weight: Any, font_style: Any, font_stretch: Any, symbol: bool, single_stroke: bool, engraving: bool) -> List[str]: ...\ndef QueryLayouts(name: str) -> List[Any]: ...\ndef QueryModelBlockDefinitions(name: str) -> List[Any]: ...\ndef QueryModelEnvironments(name: str) -> List[Any]: ...\ndef QueryModelHatchPatterns(name: str) -> List[Any]: ...\ndef QueryModelLayers(name: str) -> List[Any]: ...\ndef QueryModelLights(name: str, layer: str) -> List[Any]: ...\ndef QueryModelLinetypes(name: str) -> List[Any]: ...\ndef QueryModelMaterials(name: str) -> List[Any]: ...\ndef QueryModelObjects(name: str, layer: str, group: str) -> List[Any]: ...\ndef QueryNamedViews(name: str) -> List[Any]: ...\ndef QueryViewports(name: str) -> List[Any]: ...\ndef RadialDimension(radial_dimension: Any, plane: Rhino.Geometry.Plane, curve: Rhino.Geometry.Curve, curve_point: Rhino.Geometry.Point3d, dimension_location: Rhino.Geometry.Point3d, dimension_type: Any, style: Any) -> Any: ...\ndef RebuildCurve(degree: int) -> Rhino.Geometry.Curve: ...\ndef RectangleMapping(geometry: Any) -> Rhino.Geometry.Transform: ...\ndef RectangularArray(geometry: Any) -> List[Any]: ...\ndef RectangularLight(rectangular_light: Any, plane: Rhino.Geometry.Plane, length: float, width: float) -> Any: ...\ndef RegionDifference(plane: Rhino.Geometry.Plane) -> List[Rhino.Geometry.Curve]: ...\ndef RegionIntersection(plane: Rhino.Geometry.Plane) -> List[Rhino.Geometry.Curve]: ...\ndef RegionUnion(plane: Rhino.Geometry.Plane) -> List[Rhino.Geometry.Curve]: ...\ndef RemeshByColour(fixcurves: List[Rhino.Geometry.Curve], fixvertices: List[Rhino.Geometry.Point3d]) -> Rhino.Geometry.Mesh: ...\ndef RenderAttributes(render: Any, object_material: Any, casts_shadows: bool, receives_shadows: bool) -> Any: ...\ndef RenderMaterial(object_material: Any, source: Any, material: Any) -> Any: ...\ndef ReplaceItems(item: Any, indices: List[int]) -> List[Any]: ...\ndef ReplaceMembers(replace: Any) -> Any: ...\ndef ReplaceText(find: str, replace: str) -> str: ...\ndef RightTrigonometry(alpha: float, beta: float, p_length: float, q_length: float, r_length: float) -> Tuple[float, float, float]: ...\ndef RigidBody(part: Any, plane: Rhino.Geometry.Plane, points: List[Rhino.Geometry.Point3d]) -> Any: ...\ndef RigidBodyCollide(mesha: Rhino.Geometry.Mesh, meshb: Rhino.Geometry.Mesh, planea: Rhino.Geometry.Plane, planeb: Rhino.Geometry.Plane) -> Any: ...\ndef RigidPointSet(plane: Rhino.Geometry.Plane) -> List[Rhino.Geometry.Point3d]: ...\ndef Rotate(geometry: Any) -> Any: ...\ndef Rotate3D(geometry: Any) -> Any: ...\ndef RotateAxis(geometry: Any) -> Any: ...\ndef RotateDirection(geometry: Any) -> Any: ...\ndef Scale(geometry: Any) -> Any: ...\ndef ScaleNU(geometry: Any) -> Any: ...\ndef Script(x: Any, y: Any) -> Any: ...\ndef SetIntersection(set_a: List[Any], set_b: List[Any]) -> List[Any]: ...\ndef SetUnion(set_a: List[Any], set_b: List[Any]) -> List[Any]: ...\ndef Shear(geometry: Any) -> Any: ...\ndef ShearAngle(geometry: Any) -> Any: ...\ndef Show(g: Any) -> Any: ...\ndef ShrinkWrap(edge_length: float) -> Rhino.Geometry.Mesh: ...\ndef SimplifyCurve(tolerance: float, angle_tolerance: float) -> Rhino.Geometry.Curve: ...\ndef Skylight(skylight: Any, enabled: bool, custom_environment: bool, environment: Any) -> Any: ...\ndef SmoothMesh(limit: float) -> Rhino.Geometry.Mesh: ...\ndef SmoothNumbers(numbers: List[float]) -> List[float]: ...\ndef SoftBodyCollide(meshes: List[Rhino.Geometry.Mesh]) -> Any: ...\ndef SoftHardSolver(softgoals: List[Any], hardgoals: List[Any]) -> Any: ...\ndef SolidPlaneCollide(solid: Rhino.Geometry.Brep, solidplane: Rhino.Geometry.Plane, collisionplane: Rhino.Geometry.Plane) -> Any: ...\ndef SolidPointCollide(points: List[Rhino.Geometry.Point3d], solid: Rhino.Geometry.Brep) -> Any: ...\ndef Solver(goalobjects: List[Any]) -> Any: ...\ndef SortList(values_a: List[Any]) -> Tuple[List[Any], List[int]]: ...\ndef SortText(values: List[str]) -> Tuple[List[str], List[int]]: ...\ndef SphereCollide(points: List[Rhino.Geometry.Point3d]) -> Any: ...\ndef SpinForce(bounds: Rhino.Geometry.BoundingBox) -> Any: ...\ndef SplitBrep(cutter: Rhino.Geometry.Brep) -> List[Rhino.Geometry.Brep]: ...\ndef SplitBrepMultiple(cutters: List[Rhino.Geometry.Brep]) -> List[Rhino.Geometry.Brep]: ...\ndef Sporph(base_uv: List[Rhino.Geometry.Point3d], target_uv: List[Rhino.Geometry.Point3d]) -> Any: ...\ndef Spotlight(spotlight: Any, location: Rhino.Geometry.Point3d, target: Rhino.Geometry.Point3d, spotlight_hardness: float, spotlight_angle: float) -> Any: ...\ndef StepSolver(goalobjects: List[Any]) -> Any: ...\ndef StreamFilter(stream_0: Any, stream_1: Any) -> Any: ...\ndef Subtraction(a: Union[float, int], b: Union[float, int]) -> Union[float, int]: ...\ndef Sun(sun: Any, enabled: bool, intensity: float, date_time: Any, latitude: float, longitude: float) -> Any: ...\ndef SunManualControl(sun: Any, enabled: bool, intensity: float, azimuth: float, altitude: float) -> Any: ...\ndef SunPreview(location: Rhino.Geometry.Point3d, distance: float, scale: float) -> Any: ...\ndef Support(frame: Rhino.Geometry.Plane, target: Rhino.Geometry.Point3d) -> Any: ...\ndef SurfaceSplit(curves: List[Rhino.Geometry.Curve]) -> List[Rhino.Geometry.Surface]: ...\ndef TangentIncircles(mesh: Rhino.Geometry.Mesh, boundary: List[Rhino.Geometry.Curve]) -> List[Rhino.Geometry.Circle]: ...\ndef TextEntity(text_entity: Any, plane: Rhino.Geometry.Plane, text: str, style: Any) -> Any: ...\ndef TextFragment(count: int) -> List[str]: ...\ndef TextJoin(join: str) -> str: ...\ndef TextOnSurface(base_surface: Rhino.Geometry.Surface) -> Any: ...\ndef TextTag(colour: Any) -> str: ...\ndef TextTag3D(text: str, colour: Any) -> Any: ...\ndef TriRemesh(target: float, sharp: bool, features: List[Rhino.Geometry.Curve], length: float) -> Rhino.Geometry.Mesh: ...\ndef TriangleMapping(geometry: Any) -> Rhino.Geometry.Transform: ...\ndef TriangleTrigonometry(alpha: float, beta: float, gamma: float, a_length: float, b_length: float, c_length: float) -> Tuple[float, float, float, float, float, float]: ...\ndef TrimwithRegion(plane: Rhino.Geometry.Plane) -> List[Rhino.Geometry.Curve]: ...\ndef TrimwithRegions(plane: Rhino.Geometry.Plane) -> List[Rhino.Geometry.Curve]: ...\ndef UnitSystem(name: str, factor: float) -> Any: ...\ndef UserText(keys: List[str], values: List[str]) -> Any: ...\ndef VBScript(x: Any, y: Any) -> Any: ...\ndef VectorDisplay(anchor: Rhino.Geometry.Point3d, vector: Rhino.Geometry.Vector3d) -> Any: ...\ndef VectorDisplayEx(point: Rhino.Geometry.Point3d, vector: Rhino.Geometry.Vector3d, colour: Any, width: float) -> Any: ...\ndef VectorForce(bounds: Rhino.Geometry.BoundingBox) -> Any: ...\ndef VisibilityAttributes(visibility: Any, hidden: bool, locked: bool) -> Any: ...\ndef Voronoi(radius: float, boundary: List[Rhino.Geometry.Curve], plane: Rhino.Geometry.Plane) -> List[Rhino.Geometry.Curve]: ...\ndef Voronoi3D(box: Rhino.Geometry.Box) -> List[Rhino.Geometry.Polyline]: ...\ndef VoronoiCell(box: Rhino.Geometry.Box) -> List[Rhino.Geometry.Polyline]: ...\ndef VoronoiGroups(generation_1: List[Rhino.Geometry.Point3d], generation_2: List[Rhino.Geometry.Point3d]) -> Tuple[List[Any], List[Any]]: ...\ndef ZombieSolver(goalobjects: List[Any]) -> Any: ...\ndef ZoomExtents(border: float) -> Any: ...\ndef removeDuplicateLines(tolerance: float) -> List[Rhino.Geometry.Line]: ...\ndef removeDuplicatePts(tolerance: float) -> List[Rhino.Geometry.Point3d]: ...\ndef x4PointSurface(corner_d: Rhino.Geometry.Point3d) -> Rhino.Geometry.Surface: ...\n\n# Additional commonly used functions from Grasshopper components\ndef Absolute(x: Union[float, int]) -> Union[float, int]: ...\ndef AdjustPlane(plane: Rhino.Geometry.Plane, origin: Rhino.Geometry.Point3d) -> Rhino.Geometry.Plane: ...\ndef AlignVertices(mesh: Rhino.Geometry.Mesh) -> Rhino.Geometry.Mesh: ...\ndef Arc(plane: Rhino.Geometry.Plane, radius: float, angle: float) -> Rhino.Geometry.Arc: ...\ndef Arc3Pt(start: Rhino.Geometry.Point3d, middle: Rhino.Geometry.Point3d, end: Rhino.Geometry.Point3d) -> Rhino.Geometry.Arc: ...\ndef ArcCosine(x: float) -> float: ...\ndef ArcSED(start: Rhino.Geometry.Point3d, end: Rhino.Geometry.Point3d, direction: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Arc: ...\ndef ArcSine(x: float) -> float: ...\ndef ArcTangent(x: float) -> float: ...\ndef Area(geometry: Any) -> float: ...\ndef AreaMoments(curves: List[Rhino.Geometry.Curve]) -> Tuple[float, Rhino.Geometry.Point3d, Rhino.Geometry.Point3d]: ...\ndef Average(values: List[Union[float, int]]) -> Union[float, int]: ...\ndef Barycentric(points: List[Rhino.Geometry.Point3d], weights: List[float]) -> Rhino.Geometry.Point3d: ...\ndef BezierSpan(degree: int, points: List[Rhino.Geometry.Point3d]) -> Rhino.Geometry.BezierCurve: ...\ndef BiArc(start: Rhino.Geometry.Point3d, tangent1: Rhino.Geometry.Vector3d, end: Rhino.Geometry.Point3d, tangent2: Rhino.Geometry.Vector3d) -> List[Rhino.Geometry.Arc]: ...\ndef BlendCurve(curve1: Rhino.Geometry.Curve, curve2: Rhino.Geometry.Curve, continuity: int) -> Rhino.Geometry.Curve: ...\ndef BoundarySurfaces(curves: List[Rhino.Geometry.Curve]) -> List[Rhino.Geometry.Surface]: ...\ndef BoundingBox(geometry: Any) -> Rhino.Geometry.BoundingBox: ...\ndef Box2Pt(point1: Rhino.Geometry.Point3d, point2: Rhino.Geometry.Point3d) -> Rhino.Geometry.Box: ...\ndef BoxCorners(box: Rhino.Geometry.Box) -> List[Rhino.Geometry.Point3d]: ...\ndef BrepClosestPoint(brep: Rhino.Geometry.Brep, point: Rhino.Geometry.Point3d) -> Rhino.Geometry.Point3d: ...\ndef BrepEdges(brep: Rhino.Geometry.Brep) -> List[Rhino.Geometry.Curve]: ...\ndef BrepJoin(breps: List[Rhino.Geometry.Brep]) -> List[Rhino.Geometry.Brep]: ...\ndef BrepXBrep(brep1: Rhino.Geometry.Brep, brep2: Rhino.Geometry.Brep) -> List[Rhino.Geometry.Curve]: ...\ndef BrepXCurve(brep: Rhino.Geometry.Brep, curve: Rhino.Geometry.Curve) -> List[Rhino.Geometry.Point3d]: ...\ndef BrepXLine(brep: Rhino.Geometry.Brep, line: Rhino.Geometry.Line) -> List[Rhino.Geometry.Point3d]: ...\ndef BrepXPlane(brep: Rhino.Geometry.Brep, plane: Rhino.Geometry.Plane) -> List[Rhino.Geometry.Curve]: ...\ndef Circle(plane: Rhino.Geometry.Plane, radius: float) -> Rhino.Geometry.Circle: ...\ndef Circle3Pt(point1: Rhino.Geometry.Point3d, point2: Rhino.Geometry.Point3d, point3: Rhino.Geometry.Point3d) -> Rhino.Geometry.Circle: ...\ndef CircleCNR(center: Rhino.Geometry.Point3d, normal: Rhino.Geometry.Vector3d, radius: float) -> Rhino.Geometry.Circle: ...\ndef CircleFit(points: List[Rhino.Geometry.Point3d]) -> Rhino.Geometry.Circle: ...\ndef ClosestPoint(point: Rhino.Geometry.Point3d, cloud: List[Rhino.Geometry.Point3d]) -> Rhino.Geometry.Point3d: ...\ndef ClosestPoints(cloud1: List[Rhino.Geometry.Point3d], cloud2: List[Rhino.Geometry.Point3d]) -> Tuple[List[Rhino.Geometry.Point3d], List[Rhino.Geometry.Point3d]]: ...\ndef Cone(plane: Rhino.Geometry.Plane, height: float, radius: float) -> Rhino.Geometry.Cone: ...\ndef ConstructDomain(start: float, end: float) -> Rhino.Geometry.Interval: ...\ndef ConstructPlane(origin: Rhino.Geometry.Point3d, x_axis: Rhino.Geometry.Vector3d, y_axis: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Plane: ...\ndef ConstructPoint(x: float, y: float, z: float) -> Rhino.Geometry.Point3d: ...\ndef Contour(geometry: Any, plane: Rhino.Geometry.Plane, distance: float) -> List[Rhino.Geometry.Curve]: ...\ndef ControlPoints(curve: Rhino.Geometry.Curve) -> List[Rhino.Geometry.Point3d]: ...\ndef CopyTrim(surface: Rhino.Geometry.Surface, curves: List[Rhino.Geometry.Curve]) -> Rhino.Geometry.Brep: ...\ndef Cosine(angle: float) -> float: ...\ndef CrossProduct(vector1: Rhino.Geometry.Vector3d, vector2: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Vector3d: ...\ndef Cube(plane: Rhino.Geometry.Plane, size: float) -> Rhino.Geometry.Box: ...\ndef CubeRoot(x: float) -> float: ...\ndef CullDuplicates(items: List[Any], tolerance: float) -> List[Any]: ...\ndef Curvature(curve: Rhino.Geometry.Curve, parameter: float) -> float: ...\ndef CurveClosestPoint(curve: Rhino.Geometry.Curve, point: Rhino.Geometry.Point3d) -> Rhino.Geometry.Point3d: ...\ndef CurveFrame(curve: Rhino.Geometry.Curve, parameter: float) -> Rhino.Geometry.Plane: ...\ndef CurveFrames(curve: Rhino.Geometry.Curve, parameters: List[float]) -> List[Rhino.Geometry.Plane]: ...\ndef CurveMiddle(curve: Rhino.Geometry.Curve) -> Rhino.Geometry.Point3d: ...\ndef CurveXCurve(curve1: Rhino.Geometry.Curve, curve2: Rhino.Geometry.Curve) -> List[Rhino.Geometry.Point3d]: ...\ndef CurveXLine(curve: Rhino.Geometry.Curve, line: Rhino.Geometry.Line) -> List[Rhino.Geometry.Point3d]: ...\ndef CurveXPlane(curve: Rhino.Geometry.Curve, plane: Rhino.Geometry.Plane) -> List[Rhino.Geometry.Point3d]: ...\ndef CurveXSelf(curve: Rhino.Geometry.Curve) -> List[Rhino.Geometry.Point3d]: ...\ndef Cylinder(plane: Rhino.Geometry.Plane, radius: float, height: float) -> Rhino.Geometry.Cylinder: ...\n\n# Additional functions continued\ndef DeconstructArc(arc: Rhino.Geometry.Arc) -> Tuple[Rhino.Geometry.Plane, float, float]: ...\ndef DeconstructBox(box: Rhino.Geometry.Box) -> Tuple[Rhino.Geometry.Plane, float, float, float]: ...\ndef DeconstructBrep(brep: Rhino.Geometry.Brep) -> Tuple[List[Rhino.Geometry.Surface], List[Rhino.Geometry.Curve], List[Rhino.Geometry.Point3d]]: ...\ndef DeconstructDomain(domain: Rhino.Geometry.Interval) -> Tuple[float, float]: ...\ndef DeconstructMesh(mesh: Rhino.Geometry.Mesh) -> Tuple[List[Rhino.Geometry.Point3d], List[Rhino.Geometry.MeshFace], List[Rhino.Geometry.Vector3d], List[Any]]: ...\ndef DeconstructPlane(plane: Rhino.Geometry.Plane) -> Tuple[Rhino.Geometry.Point3d, Rhino.Geometry.Vector3d, Rhino.Geometry.Vector3d]: ...\ndef DeconstructRectangle(rectangle: Rhino.Geometry.Rectangle3d) -> Tuple[Rhino.Geometry.Plane, float, float]: ...\ndef DeconstructVector(vector: Rhino.Geometry.Vector3d) -> Tuple[float, float, float]: ...\ndef Degrees(radians: float) -> float: ...\ndef Derivatives(curve: Rhino.Geometry.Curve, parameter: float, order: int) -> List[Rhino.Geometry.Vector3d]: ...\ndef Dimensions(geometry: Any) -> Tuple[float, float, float]: ...\ndef Discontinuity(curve: Rhino.Geometry.Curve, continuity: int) -> List[float]: ...\ndef Distance(point1: Rhino.Geometry.Point3d, point2: Rhino.Geometry.Point3d) -> float: ...\ndef DivideCurve(curve: Rhino.Geometry.Curve, count: int) -> List[Rhino.Geometry.Point3d]: ...\ndef DivideDistance(curve: Rhino.Geometry.Curve, distance: float) -> List[Rhino.Geometry.Point3d]: ...\ndef DivideLength(curve: Rhino.Geometry.Curve, length: float) -> List[Rhino.Geometry.Point3d]: ...\ndef DivideSurface(surface: Rhino.Geometry.Surface, u_count: int, v_count: int) -> List[Rhino.Geometry.Point3d]: ...\ndef Division(a: Union[float, int], b: Union[float, int]) -> Union[float, int]: ...\ndef DotProduct(vector1: Rhino.Geometry.Vector3d, vector2: Rhino.Geometry.Vector3d) -> float: ...\ndef Ellipse(plane: Rhino.Geometry.Plane, radius1: float, radius2: float) -> Rhino.Geometry.Ellipse: ...\ndef EndPoints(curve: Rhino.Geometry.Curve) -> Tuple[Rhino.Geometry.Point3d, Rhino.Geometry.Point3d]: ...\ndef Entwine(branches: List[List[Any]]) -> List[Any]: ...\ndef Equality(a: Any, b: Any) -> bool: ...\ndef EvaluateCurve(curve: Rhino.Geometry.Curve, parameter: float) -> Rhino.Geometry.Point3d: ...\ndef EvaluateLength(curve: Rhino.Geometry.Curve, parameter: float) -> float: ...\ndef EvaluateSurface(surface: Rhino.Geometry.Surface, u: float, v: float) -> Rhino.Geometry.Point3d: ...\ndef Explode(brep: Rhino.Geometry.Brep) -> List[Rhino.Geometry.Surface]: ...\ndef ExtendCurve(curve: Rhino.Geometry.Curve, start: float, end: float) -> Rhino.Geometry.Curve: ...\ndef Extrude(profile: Rhino.Geometry.Curve, vector: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Surface: ...\ndef ExtrudeAlong(profile: Rhino.Geometry.Curve, path: Rhino.Geometry.Curve) -> Rhino.Geometry.Surface: ...\ndef ExtrudeLinear(curves: List[Rhino.Geometry.Curve], direction: Rhino.Geometry.Vector3d) -> List[Rhino.Geometry.Surface]: ...\ndef ExtrudePoint(curves: List[Rhino.Geometry.Curve], point: Rhino.Geometry.Point3d) -> List[Rhino.Geometry.Surface]: ...\ndef FaceBoundaries(brep: Rhino.Geometry.Brep) -> List[List[Rhino.Geometry.Curve]]: ...\ndef FaceNormals(mesh: Rhino.Geometry.Mesh) -> List[Rhino.Geometry.Vector3d]: ...\ndef Factorial(n: int) -> int: ...\ndef Fibonacci(n: int) -> int: ...\ndef Fillet(curve1: Rhino.Geometry.Curve, curve2: Rhino.Geometry.Curve, radius: float) -> Rhino.Geometry.Curve: ...\ndef FindDomain(curve: Rhino.Geometry.Curve) -> Rhino.Geometry.Interval: ...\ndef FitLine(points: List[Rhino.Geometry.Point3d]) -> Rhino.Geometry.Line: ...\ndef FitLoft(curves: List[Rhino.Geometry.Curve]) -> Rhino.Geometry.Surface: ...\ndef FlattenTree(tree: Any) -> List[Any]: ...\ndef FlipMatrix(matrix: Rhino.Geometry.Transform) -> Rhino.Geometry.Transform: ...\ndef FlipMesh(mesh: Rhino.Geometry.Mesh) -> Rhino.Geometry.Mesh: ...\ndef FlipPlane(plane: Rhino.Geometry.Plane) -> Rhino.Geometry.Plane: ...\ndef Floor(x: float) -> int: ...\ndef Flow(geometry: Any, base_curve: Rhino.Geometry.Curve, target_curve: Rhino.Geometry.Curve) -> Any: ...\ndef GoldenRatio() -> float: ...\ndef Gradient(field: Any, point: Rhino.Geometry.Point3d) -> Rhino.Geometry.Vector3d: ...\ndef GraftTree(data: Any) -> Any: ...\ndef Group(objects: List[Any]) -> Any: ...\ndef Hexagonal(plane: Rhino.Geometry.Plane, size: float, extent_x: int, extent_y: int) -> List[Rhino.Geometry.Point3d]: ...\ndef HorizontalFrame(curve: Rhino.Geometry.Curve, parameter: float) -> Rhino.Geometry.Plane: ...\ndef HorizontalFrames(curve: Rhino.Geometry.Curve, parameters: List[float]) -> List[Rhino.Geometry.Plane]: ...\ndef InCircle(circle: Rhino.Geometry.Circle, point: Rhino.Geometry.Point3d) -> bool: ...\ndef Includes(list: List[Any], item: Any) -> bool: ...\ndef IntegerDivision(a: int, b: int) -> int: ...\ndef Interpolate(value1: float, value2: float, factor: float) -> float: ...\ndef IsPlanar(points: List[Rhino.Geometry.Point3d], tolerance: float) -> bool: ...\ndef IsoCurve(surface: Rhino.Geometry.Surface, direction: int, parameter: float) -> Rhino.Geometry.Curve: ...\ndef Isotrim(surface: Rhino.Geometry.Surface, domain_u: Rhino.Geometry.Interval, domain_v: Rhino.Geometry.Interval) -> Rhino.Geometry.Surface: ...\ndef ItemIndex(list: List[Any], item: Any) -> int: ...\ndef Jitter(points: List[Rhino.Geometry.Point3d], amount: float) -> List[Rhino.Geometry.Point3d]: ...\ndef JoinCurves(curves: List[Rhino.Geometry.Curve]) -> List[Rhino.Geometry.Curve]: ...\ndef KnotVector(curve: Rhino.Geometry.NurbsCurve) -> List[float]: ...\ndef LargerThan(a: Union[float, int], b: Union[float, int]) -> bool: ...\ndef Length(curve: Rhino.Geometry.Curve) -> float: ...\ndef LengthDomain(curve: Rhino.Geometry.Curve) -> Rhino.Geometry.Interval: ...\ndef LengthParameter(curve: Rhino.Geometry.Curve, length: float) -> float: ...\ndef Line(start: Rhino.Geometry.Point3d, end: Rhino.Geometry.Point3d) -> Rhino.Geometry.Line: ...\ndef Line2Plane(line: Rhino.Geometry.Line) -> Rhino.Geometry.Plane: ...\ndef Line4Pt(point1: Rhino.Geometry.Point3d, point2: Rhino.Geometry.Point3d, point3: Rhino.Geometry.Point3d, point4: Rhino.Geometry.Point3d) -> List[Rhino.Geometry.Line]: ...\ndef LineSDL(start: Rhino.Geometry.Point3d, direction: Rhino.Geometry.Vector3d, length: float) -> Rhino.Geometry.Line: ...\ndef LineXLine(line1: Rhino.Geometry.Line, line2: Rhino.Geometry.Line) -> Rhino.Geometry.Point3d: ...\ndef LineXPlane(line: Rhino.Geometry.Line, plane: Rhino.Geometry.Plane) -> Rhino.Geometry.Point3d: ...\ndef ListItem(list: List[Any], index: int) -> Any: ...\ndef ListLength(list: List[Any]) -> int: ...\ndef LogN(x: float, base: float) -> float: ...\ndef Logarithm(x: float) -> float: ...\ndef LongestList(lists: List[List[Any]]) -> List[Any]: ...\ndef Loft(curves: List[Rhino.Geometry.Curve]) -> Rhino.Geometry.Surface: ...\ndef Maximum(values: List[Union[float, int]]) -> Union[float, int]: ...\ndef MemberIndex(list: List[Any], item: Any) -> int: ...\ndef Minimum(values: List[Union[float, int]]) -> Union[float, int]: ...\ndef MirrorCurve(curve: Rhino.Geometry.Curve, plane: Rhino.Geometry.Plane) -> Rhino.Geometry.Curve: ...\ndef MirrorSurface(surface: Rhino.Geometry.Surface, plane: Rhino.Geometry.Plane) -> Rhino.Geometry.Surface: ...\ndef Modulus(a: Union[float, int], b: Union[float, int]) -> Union[float, int]: ...\ndef MoveAwayFrom(geometry: Any, attractor: Rhino.Geometry.Point3d, distance: float) -> Any: ...\ndef MoveToPlane(geometry: Any, plane: Rhino.Geometry.Plane) -> Any: ...\ndef MultipleCurves(curves: List[Rhino.Geometry.Curve]) -> List[Rhino.Geometry.Curve]: ...\ndef NakedVertices(mesh: Rhino.Geometry.Mesh) -> List[int]: ...\ndef Naturallogarithm(x: float) -> float: ...\ndef Negative(x: Union[float, int]) -> Union[float, int]: ...\ndef NetworkSurface(u_curves: List[Rhino.Geometry.Curve], v_curves: List[Rhino.Geometry.Curve]) -> Rhino.Geometry.Surface: ...\ndef NurbsCurve(points: List[Rhino.Geometry.Point3d], degree: int) -> Rhino.Geometry.NurbsCurve: ...\ndef OffsetSurface(surface: Rhino.Geometry.Surface, distance: float) -> Rhino.Geometry.Surface: ...\ndef OffsetSurfaceLoose(surface: Rhino.Geometry.Surface, distance: float) -> Rhino.Geometry.Surface: ...\ndef OffsetetonSrf(curve: Rhino.Geometry.Curve, surface: Rhino.Geometry.Surface, distance: float) -> Rhino.Geometry.Curve: ...\ndef OneOverX(x: float) -> float: ...\ndef OsculatingCircles(curve: Rhino.Geometry.Curve, parameters: List[float]) -> List[Rhino.Geometry.Circle]: ...\ndef PartitionList(list: List[Any], sizes: List[int]) -> List[List[Any]]: ...\ndef PerpFrame(curve: Rhino.Geometry.Curve, parameter: float) -> Rhino.Geometry.Plane: ...\ndef PerpFrames(curve: Rhino.Geometry.Curve, parameters: List[float]) -> List[Rhino.Geometry.Plane]: ...\ndef Pi() -> float: ...\ndef Pipe(curve: Rhino.Geometry.Curve, radius: float) -> Rhino.Geometry.Brep: ...\ndef PipeVariable(curve: Rhino.Geometry.Curve, radii: List[float]) -> Rhino.Geometry.Brep: ...\ndef Planar(curves: List[Rhino.Geometry.Curve], plane: Rhino.Geometry.Plane) -> List[Rhino.Geometry.Curve]: ...\ndef Planarize(mesh: Rhino.Geometry.Mesh) -> Rhino.Geometry.Mesh: ...\ndef Plane3Pt(point1: Rhino.Geometry.Point3d, point2: Rhino.Geometry.Point3d, point3: Rhino.Geometry.Point3d) -> Rhino.Geometry.Plane: ...\ndef PlaneClosestPoint(plane: Rhino.Geometry.Plane, point: Rhino.Geometry.Point3d) -> Rhino.Geometry.Point3d: ...\ndef PlaneCoordinates(plane: Rhino.Geometry.Plane, point: Rhino.Geometry.Point3d) -> Tuple[float, float, float]: ...\ndef PlaneFit(points: List[Rhino.Geometry.Point3d]) -> Rhino.Geometry.Plane: ...\ndef PlaneNormal(plane: Rhino.Geometry.Plane) -> Rhino.Geometry.Vector3d: ...\ndef PlaneOffset(plane: Rhino.Geometry.Plane, distance: float) -> Rhino.Geometry.Plane: ...\ndef PlaneOrigin(plane: Rhino.Geometry.Plane) -> Rhino.Geometry.Point3d: ...\ndef PlaneRegion(plane: Rhino.Geometry.Plane, boundary: List[Rhino.Geometry.Curve]) -> Rhino.Geometry.Brep: ...\ndef PlaneSurface(plane: Rhino.Geometry.Plane, x_extent: Rhino.Geometry.Interval, y_extent: Rhino.Geometry.Interval) -> Rhino.Geometry.Surface: ...\ndef PlaneThroughShape(shapes: List[Any]) -> Rhino.Geometry.Plane: ...\ndef PlaneXPlane(plane1: Rhino.Geometry.Plane, plane2: Rhino.Geometry.Plane) -> Rhino.Geometry.Line: ...\ndef PlaneXPlaneXPlane(plane1: Rhino.Geometry.Plane, plane2: Rhino.Geometry.Plane, plane3: Rhino.Geometry.Plane) -> Rhino.Geometry.Point3d: ...\ndef PointCylindrical(plane: Rhino.Geometry.Plane, radius: float, angle: float, height: float) -> Rhino.Geometry.Point3d: ...\ndef PointDeform(points: List[Rhino.Geometry.Point3d], base_points: List[Rhino.Geometry.Point3d], target_points: List[Rhino.Geometry.Point3d]) -> List[Rhino.Geometry.Point3d]: ...\ndef PointGroups(points: List[Rhino.Geometry.Point3d], distance: float) -> List[List[Rhino.Geometry.Point3d]]: ...\ndef PointInBrep(point: Rhino.Geometry.Point3d, brep: Rhino.Geometry.Brep) -> bool: ...\ndef PointInBreps(point: Rhino.Geometry.Point3d, breps: List[Rhino.Geometry.Brep]) -> List[bool]: ...\ndef PointInCurve(point: Rhino.Geometry.Point3d, curve: Rhino.Geometry.Curve, plane: Rhino.Geometry.Plane) -> int: ...\ndef PointInTrim(point: Rhino.Geometry.Point3d, trim: Any) -> bool: ...\ndef PointOriented(plane: Rhino.Geometry.Plane, x: float, y: float, z: float) -> Rhino.Geometry.Point3d: ...\ndef PointPolar(plane: Rhino.Geometry.Plane, radius: float, angle: float) -> Rhino.Geometry.Point3d: ...\ndef PointinCurves(point: Rhino.Geometry.Point3d, curves: List[Rhino.Geometry.Curve], plane: Rhino.Geometry.Plane) -> List[int]: ...\ndef PointstoNumbers(points: List[Rhino.Geometry.Point3d]) -> Tuple[List[float], List[float], List[float]]: ...\ndef PolyLine(points: List[Rhino.Geometry.Point3d]) -> Rhino.Geometry.Polyline: ...\ndef Polygon(plane: Rhino.Geometry.Plane, radius: float, sides: int) -> Rhino.Geometry.Polyline: ...\ndef PolygonCenter(polygon: Rhino.Geometry.Polyline) -> Rhino.Geometry.Point3d: ...\ndef PolygonEdge(plane: Rhino.Geometry.Plane, edge_length: float, sides: int) -> Rhino.Geometry.Polyline: ...\ndef PolylineCollapse(polyline: Rhino.Geometry.Polyline, tolerance: float) -> Rhino.Geometry.Polyline: ...\ndef Power(base: float, exponent: float) -> float: ...\ndef Powerof10(exponent: float) -> float: ...\ndef Powerof2(exponent: float) -> float: ...\ndef PowerofE(exponent: float) -> float: ...\ndef PrincipalCurvature(surface: Rhino.Geometry.Surface, u: float, v: float) -> Tuple[float, float, Rhino.Geometry.Vector3d, Rhino.Geometry.Vector3d]: ...\ndef ProjectCurve(curve: Rhino.Geometry.Curve, surface: Rhino.Geometry.Surface, direction: Rhino.Geometry.Vector3d) -> List[Rhino.Geometry.Curve]: ...\ndef ProjectPoint(point: Rhino.Geometry.Point3d, surface: Rhino.Geometry.Surface, direction: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Point3d: ...\ndef PruneTree(data: Any, paths_to_remove: List[str]) -> Any: ...\ndef PullCurve(curve: Rhino.Geometry.Curve, surface: Rhino.Geometry.Surface) -> Rhino.Geometry.Curve: ...\ndef PullPoint(point: Rhino.Geometry.Point3d, surface: Rhino.Geometry.Surface) -> Rhino.Geometry.Point3d: ...\ndef QuadSphere(center: Rhino.Geometry.Point3d, radius: float, subdivisions: int) -> Rhino.Geometry.Mesh: ...\ndef Quadrangulate(mesh: Rhino.Geometry.Mesh) -> Rhino.Geometry.Mesh: ...\ndef Radians(degrees: float) -> float: ...\ndef RailRevolution(profile: Rhino.Geometry.Curve, rail: Rhino.Geometry.Curve, axis: Rhino.Geometry.Line) -> Rhino.Geometry.Surface: ...\ndef Random(seed: int) -> float: ...\ndef RandomReduce(list: List[Any], ratio: float) -> List[Any]: ...\ndef Range(start: float, end: float, step: float) -> List[float]: ...\ndef ReadFile(path: str) -> str: ...\ndef Rectangle(plane: Rhino.Geometry.Plane, x_size: float, y_size: float) -> Rhino.Geometry.Rectangle3d: ...\ndef Rectangle2Pt(point1: Rhino.Geometry.Point3d, point2: Rhino.Geometry.Point3d) -> Rhino.Geometry.Rectangle3d: ...\ndef Rectangle3Pt(corner: Rhino.Geometry.Point3d, x_end: Rhino.Geometry.Point3d, y_end: Rhino.Geometry.Point3d) -> Rhino.Geometry.Rectangle3d: ...\ndef Rectangular(plane: Rhino.Geometry.Plane, x_size: float, y_size: float, x_count: int, y_count: int) -> List[Rhino.Geometry.Point3d]: ...\ndef Reduce(list: List[Any]) -> List[Any]: ...\ndef ReducePointCloud(cloud: List[Rhino.Geometry.Point3d], distance: float) -> List[Rhino.Geometry.Point3d]: ...\ndef Refine(mesh: Rhino.Geometry.Mesh) -> Rhino.Geometry.Mesh: ...\ndef RelativeDifferences(values: List[float]) -> List[float]: ...\ndef RelativeItem(list: List[Any], index: float) -> Any: ...\ndef RelativeItems(list: List[Any], indices: List[float]) -> List[Any]: ...\ndef RemapNumbers(values: List[float], source: Rhino.Geometry.Interval, target: Rhino.Geometry.Interval) -> List[float]: ...\ndef RepeatData(data: Any, count: int) -> List[Any]: ...\ndef ReplaceNulls(list: List[Any], replacement: Any) -> List[Any]: ...\ndef ReplacePaths(tree: Any, old_paths: List[str], new_paths: List[str]) -> Any: ...\ndef Retrim(surface: Rhino.Geometry.Surface, curves: List[Rhino.Geometry.Curve]) -> Rhino.Geometry.Brep: ...\ndef Reverse(curve: Rhino.Geometry.Curve) -> Rhino.Geometry.Curve: ...\ndef ReverseList(list: List[Any]) -> List[Any]: ...\ndef ReverseSurface(surface: Rhino.Geometry.Surface, direction: int) -> Rhino.Geometry.Surface: ...\ndef Revolution(profile: Rhino.Geometry.Curve, axis: Rhino.Geometry.Line, angle: float) -> Rhino.Geometry.Surface: ...\ndef RotatePlane(plane: Rhino.Geometry.Plane, angle: float) -> Rhino.Geometry.Plane: ...\ndef Round(x: float, decimals: int) -> float: ...\ndef RuledSurface(curve1: Rhino.Geometry.Curve, curve2: Rhino.Geometry.Curve) -> Rhino.Geometry.Surface: ...\ndef Seam(surface: Rhino.Geometry.Surface, seam: float) -> Rhino.Geometry.Surface: ...\ndef Secant(angle: float) -> float: ...\ndef SegmentLengths(polyline: Rhino.Geometry.Polyline) -> List[float]: ...\ndef Sequence(start: float, step: float, count: int) -> List[float]: ...\ndef Series(start: float, step: float, count: int) -> List[float]: ...\ndef SetDifference(set1: List[Any], set2: List[Any]) -> List[Any]: ...\ndef SetDifferenceS(set1: List[Any], set2: List[Any]) -> List[Any]: ...\ndef SetMajority(sets: List[List[Any]]) -> List[Any]: ...\ndef ShapeInBrep(shape: Any, brep: Rhino.Geometry.Brep) -> bool: ...\ndef Shatter(curve: Rhino.Geometry.Curve, parameters: List[float]) -> List[Rhino.Geometry.Curve]: ...\ndef ShiftList(list: List[Any], offset: int) -> List[Any]: ...\ndef ShiftPaths(tree: Any, offset: int) -> Any: ...\ndef ShortestList(lists: List[List[Any]]) -> List[Any]: ...\ndef SiftPattern(list: List[Any], pattern: List[bool]) -> List[Any]: ...\ndef Similarity(curve1: Rhino.Geometry.Curve, curve2: Rhino.Geometry.Curve) -> float: ...\ndef SimpleMesh(mesh: Rhino.Geometry.Mesh) -> Rhino.Geometry.Mesh: ...\ndef SimplifyTree(tree: Any) -> Any: ...\ndef Sinc(x: float) -> float: ...\ndef Sine(angle: float) -> float: ...\ndef SmallerThan(a: Union[float, int], b: Union[float, int]) -> bool: ...\ndef Smooth(curve: Rhino.Geometry.Curve, factor: float) -> Rhino.Geometry.Curve: ...\ndef SmoothPolyline(polyline: Rhino.Geometry.Polyline, factor: float) -> Rhino.Geometry.Polyline: ...\ndef SoapFilm(curves: List[Rhino.Geometry.Curve]) -> Rhino.Geometry.Mesh: ...\ndef SolidDifference(brep1: Rhino.Geometry.Brep, brep2: Rhino.Geometry.Brep) -> List[Rhino.Geometry.Brep]: ...\ndef SolidIntersection(brep1: Rhino.Geometry.Brep, brep2: Rhino.Geometry.Brep) -> List[Rhino.Geometry.Brep]: ...\ndef SolidUnion(breps: List[Rhino.Geometry.Brep]) -> List[Rhino.Geometry.Brep]: ...\ndef SortAlongCurve(points: List[Rhino.Geometry.Point3d], curve: Rhino.Geometry.Curve) -> Tuple[List[Rhino.Geometry.Point3d], List[int]]: ...\ndef SortPoints(points: List[Rhino.Geometry.Point3d], keys: List[float]) -> Tuple[List[Rhino.Geometry.Point3d], List[int]]: ...\ndef SpatialDeform(geometry: Any, reference_points: List[Rhino.Geometry.Point3d], sample_points: List[Rhino.Geometry.Point3d]) -> Any: ...\ndef Sphere(center: Rhino.Geometry.Point3d, radius: float) -> Rhino.Geometry.Sphere: ...\ndef Sphere4Pt(point1: Rhino.Geometry.Point3d, point2: Rhino.Geometry.Point3d, point3: Rhino.Geometry.Point3d, point4: Rhino.Geometry.Point3d) -> Rhino.Geometry.Sphere: ...\ndef SphereFit(points: List[Rhino.Geometry.Point3d]) -> Rhino.Geometry.Sphere: ...\ndef Split(curve: Rhino.Geometry.Curve, parameters: List[float]) -> List[Rhino.Geometry.Curve]: ...\ndef SplitList(list: List[Any], index: int) -> Tuple[List[Any], List[Any]]: ...\ndef SplitTree(tree: Any, masks: List[bool]) -> Tuple[Any, Any]: ...\ndef SplitwithBrep(curve: Rhino.Geometry.Curve, brep: Rhino.Geometry.Brep) -> List[Rhino.Geometry.Curve]: ...\ndef SplitwithBreps(curve: Rhino.Geometry.Curve, breps: List[Rhino.Geometry.Brep]) -> List[Rhino.Geometry.Curve]: ...\ndef Splop(geometry: Any, surface: Rhino.Geometry.Surface) -> Any: ...\ndef Square(x: Union[float, int]) -> Union[float, int]: ...\ndef SquareRoot(x: float) -> float: ...\ndef StackData(data: List[Any]) -> Any: ...\ndef Stretch(geometry: Any, plane: Rhino.Geometry.Plane, factor: float) -> Any: ...\ndef Stripper(data: Any) -> List[Any]: ...\ndef SubCurve(curve: Rhino.Geometry.Curve, domain: Rhino.Geometry.Interval) -> Rhino.Geometry.Curve: ...\ndef SubDControlPolygon(subd: Any) -> List[Rhino.Geometry.Polyline]: ...\ndef SurfaceXSurface(surface1: Rhino.Geometry.Surface, surface2: Rhino.Geometry.Surface) -> List[Rhino.Geometry.Curve]: ...\ndef SwapUV(surface: Rhino.Geometry.Surface) -> Rhino.Geometry.Surface: ...\ndef Tangent(angle: float) -> float: ...\ndef TangentLine(curve: Rhino.Geometry.Curve, parameter: float) -> Rhino.Geometry.Line: ...\ndef TangentLines(curve: Rhino.Geometry.Curve, parameters: List[float]) -> List[Rhino.Geometry.Line]: ...\ndef TrimSurface(surface: Rhino.Geometry.Surface, domain_u: Rhino.Geometry.Interval, domain_v: Rhino.Geometry.Interval) -> Rhino.Geometry.Surface: ...\ndef Unify(vectors: List[Rhino.Geometry.Vector3d]) -> List[Rhino.Geometry.Vector3d]: ...\ndef UnitVector(vector: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Vector3d: ...\ndef UnitX() -> Rhino.Geometry.Vector3d: ...\ndef UnitY() -> Rhino.Geometry.Vector3d: ...\ndef UnitZ() -> Rhino.Geometry.Vector3d: ...\ndef VectorAngle(vector1: Rhino.Geometry.Vector3d, vector2: Rhino.Geometry.Vector3d) -> float: ...\ndef VectorLength(vector: Rhino.Geometry.Vector3d) -> float: ...\ndef VectorReverse(vector: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Vector3d: ...\ndef VectorRotate(vector: Rhino.Geometry.Vector3d, axis: Rhino.Geometry.Vector3d, angle: float) -> Rhino.Geometry.Vector3d: ...\ndef VertexNormals(mesh: Rhino.Geometry.Mesh) -> List[Rhino.Geometry.Vector3d]: ...\ndef Weave(pattern: List[int], streams: List[List[Any]]) -> List[Any]: ...\ndef WeldVertices(mesh: Rhino.Geometry.Mesh, tolerance: float) -> Rhino.Geometry.Mesh: ...",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}