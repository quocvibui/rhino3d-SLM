{
  "source_url": "https://github.com/josehernandezvargas/Rhino_PyWorkshop/blob/e061b54b86ef8e5b118408d00081d26c723b2c28/libs/geometrylib.py",
  "repo": "josehernandezvargas/Rhino_PyWorkshop",
  "repo_stars": 1,
  "repo_description": "A personal collection of Python tools for Rhino / Grasshopper",
  "license": "AGPL-3.0",
  "filepath": "libs/geometrylib.py",
  "instruction": "Geometrylib",
  "code": "import math\nimport rhinoscriptsyntax as rs\n\n\ndef lerp(a, b, t):\n    \"\"\"\"\n    Creates a linear interpolation between two values\n    Returns the value for a parameter t in the range a - b\"\"\"\n    return((1 - t) * a + b * t)\n\n\ndef invlerp(a, b, v):\n    \"\"\"\n    Returns the parameter t for a given value v in the range a - b\"\"\"\n    return((v - a) / (b - a))\n\n\ndef remap(imin, imax, omin, omax, v):\n    \"\"\" remaps a parameter v from input domain imin to imax \n    to output domain omin to omax\n    \"\"\"\n    t = invlerp(imin, imax, v)\n    return(lerp(omin, omax, t))\n\ndef lerppts( a , b , t):\n    \"\"\"\"\n    Creates a linear interpolation between two points\n    Returns the value for a parameter t in the range a - b\"\"\"\n    ax, ay, az = a[0], a[1], a[2]\n    bx, by, bz = b[0], b[1], b[2]\n    x = ( 1 - t ) * ax + bx * t\n    y = ( 1 - t ) * ay + by * t\n    z = ( 1 - t ) * az + bz * t\n    return (rs.AddPoint(x,y,z))\n\ndef minmaxcaplist(lo, hi, t):\n    \"\"\"Clamps a value between two limits\"\"\"\n    results = []\n    for item in t:\n        newitem = min(hi, max(lo, t))\n        results.append(newitem)\n    return(results)\n\n\ndef minmaxcap(lo, hi, t):\n    \"\"\"Clamps a list between to limits\"\"\"\n    newitem = min(hi, max(lo, t))\n    return(newitem)\n\n\ndef flattenlist(list):\n    \"\"\"flattens a nested list into a simple list\"\"\"\n    flatlist = []\n    for i in list:\n        for j in i:\n            point = rs.CreatePoint(j)\n            flatlist.append(point)\n    return(flatlist)\n\ndef normalize_pattern(pattern):\n    if not pattern:\n        return [False]\n    normalized = []\n    for p in pattern:\n        if p in [0, False, '0', 'A', 'a']:\n            normalized.append(False)\n        elif p in [1, True, '1', 'B', 'b']:\n            normalized.append(True)\n        else:\n            raise ValueError(f\"Invalid pattern value: {p}\")\n    return normalized\n\n\ndef shortestangle(a1, a2):\n    \"\"\" \n    Returns the lowest angle between two points\n    the result is negative for angles > 180\n    Arguments\n        a1: first angle\n        a2: second angle\n    Returns\n        angle in degrees\n    \"\"\"\n    angle = ((a2 % 360) - (a1 % 360) + 360) % 360\n    if angle > 180:\n        angle = 360 - angle\n        return -angle\n    return (angle)\n\n\ndef absoluteangle(pt1, pt2):\n    \"\"\"\n    calculates the absolute angle for two points to the X axis\n    Arguments\n        pt1: first point\n        pt2: second point\n    Returns\n        the absolute angle in degrees\n    \"\"\"\n    dx = pt1[0] - pt2[0]\n    dy = pt1[1] - pt2[1]\n    a = math.atan2(dy, dx) * (180.0 / math.pi)\n    a = -a + 90\n    a = a % 360\n    if a == 360:\n        a = 0\n    angle = a\n    # angle = rs.Angle(pt,prevpt)\n    if angle:\n        return angle\n    else:\n        return 0\n\ndef timestamp(format=0):\n    \"\"\"\n    Returns a timestamp without having to import time in the header\n    \"\"\"\n    import time \n    timestamp = time.strftime(\"%Y%m%d\")  # adds a timestamp with the date\n    hourstamp = \" at \" + time.strftime(\"%X\")  # a timestamp with the hour\n    if format:\n        if format == 1:\n            return \"_\" + time.strftime(\"%Y%m%d\")\n        elif format == 2:\n            return timestamp + hourstamp\n        elif format == 3:\n            return time.strftime(\"%X\")\n    else:\n        return timestamp\n\ndef plane_to_abc(origin, x_vector, y_vector):\n    # Calculate the Z vector as the cross product of X and Y vectors\n    z_vector = (x_vector[1] * y_vector[2] - x_vector[2] * y_vector[1],\n                x_vector[2] * y_vector[0] - x_vector[0] * y_vector[2],\n                x_vector[0] * y_vector[1] - x_vector[1] * y_vector[0])\n\n    # Normalize the Z vector\n    z_length = math.sqrt(z_vector[0] ** 2 + z_vector[1] ** 2 + z_vector[2] ** 2)\n    z_vector = (z_vector[0] / z_length, z_vector[1] / z_length, z_vector[2] / z_length)\n\n    # Calculate the rotation matrix\n    rotation_matrix = [[x_vector[0], y_vector[0], z_vector[0]],\n                       [x_vector[1], y_vector[1], z_vector[1]],\n                       [x_vector[2], y_vector[2], z_vector[2]]]\n\n    # Extract the Euler angles\n    roll = math.atan2(rotation_matrix[2][1], rotation_matrix[2][2])\n    pitch = math.atan2(-rotation_matrix[2][0], math.sqrt(rotation_matrix[2][1] ** 2 + rotation_matrix[2][2] ** 2))\n    yaw = math.atan2(rotation_matrix[1][0], rotation_matrix[0][0])\n\n    # Convert angles to degrees\n    roll = math.degrees(roll)\n    pitch = math.degrees(pitch)\n    yaw = math.degrees(yaw)\n\n    # Adjust angle ranges\n    roll = roll % 360\n    pitch = pitch % 360\n    yaw = yaw % 360\n\n    if roll > 185:\n        roll -= 360\n    if pitch > 135:\n        pitch -= 360\n    if yaw > 350:\n        yaw -= 360\n\n    return yaw, pitch, roll",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}