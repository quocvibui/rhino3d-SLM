{
  "source_url": "https://github.com/fstwn/ghpyanimation/blob/380f8bcf304ed36d7d8ce466c293f748442cd6b8/usrobj_src/GhPyAnimation_ConsecutiveAnimationValues.py",
  "repo": "fstwn/ghpyanimation",
  "repo_stars": 2,
  "repo_description": "Simple animation toolkit for Grasshopper written using GhPython.",
  "license": "MIT",
  "filepath": "usrobj_src/GhPyAnimation_ConsecutiveAnimationValues.py",
  "instruction": "Computes animation values relative to a primary step value. This is done by\ninterpolating between the given stop values using the amount of frames defined\nby AnimationStart and AnimationEnd.\n   ...",
  "code": "\"\"\"\nComputes animation values relative to a primary step value. This is done by\ninterpolating between the given stop values using the amount of frames defined\nby AnimationStart and AnimationEnd.\n    Inputs:\n        ValueStops: The stop values to interpolate between.\n                    {list, float}\n        Frame: The frame/step value from the primary animation slider.\n               {item, int}\n        AnimationStart: The frame/step value at which the evaluation begins.\n        AnimationEnd: The frame/step value at which the evaluation ends.\n    Output:\n        Value: The animation value computed by evaluating the domain between\n               start and end of the animation using the position of the\n               step/frame value.\n    Remarks:\n        Author: Max Eschenbach\n        License: MIT License\n        Version: 200702\n\"\"\"\n\n# GHPYTHON STANDARD LIBRARY IMPORTS\nfrom __future__ import division\n\n# GHPYTHON SDK IMPORTS\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\n# GHENV COMPONENT SETTINGS\nghenv.Component.Name = \"ConsecutiveAnimationValues\"\nghenv.Component.NickName =\"CAV\"\nghenv.Component.Category = \"GhPyAnimation\"\nghenv.Component.SubCategory = \"02 Animation Values\"\n\nclass ConsecutiveAnimationValues(component):\n    \n    def slice_sequence(self, seq, numslices):\n        n = min(numslices, len(seq))\n        k, m = divmod(len(seq), numslices)\n        return (seq[i * k + min(i, m):(i + 1) * k + min(i + 1, m)]\n                for i in range(numslices))\n    \n    def remap_number(self, start, end, tstart, tend, val):\n        #range check\n        if start == end:\n            return start\n        if tstart == tend:\n            return tstart\n        remapped_number = ((val-start) * (tend-tstart) / (end-start)) + tstart\n        return remapped_number\n    \n    def RunScript(self, ValueStops, Frame, AnimationStart, AnimationEnd):\n        \n        # initialize output so it's never empty\n        Value = Grasshopper.DataTree[object]()\n        \n        # set defaults\n        if ValueStops == None:\n            ValueStops = [0, 1]\n        if AnimationStart == None:\n            AnimationStart = 0\n        if AnimationEnd == None:\n            AnimationEnd = 30\n        if AnimationEnd <= AnimationStart:\n            rml = self.RuntimeMessageLevel.Warning\n            err = (\"Slider animations cannot run in reverse. AnimationEnd has \"\n                   \"to be larger than AnimationStart!\")\n            self.AddRuntimeMessage(rml, err)\n                        \n            return Value\n        \n        # only do sth if frame value exists\n        if Frame != None:\n            \n            frame_sequence = range(AnimationStart, AnimationEnd+1)\n            if len(frame_sequence) < len(ValueStops):\n                rml = self.RuntimeMessageLevel.Warning\n                self.AddRuntimeMessage(rml,\n                    \"Number of ValueStops cannot exceed number of frames!\")\n                return Value\n            \n            if Frame < AnimationStart:\n                Value = ValueStops[0]\n            if (Frame >= AnimationStart) and (Frame < AnimationEnd):\n                chunks = list(self.slice_sequence(frame_sequence, len(ValueStops)-1))\n                for i, chunk in enumerate(chunks):\n                    if not Frame in chunk:\n                        continue\n                    if i < len(ValueStops)-1:\n                        j = i+1\n                    else:\n                        j = -1\n                    Value = self.remap_number(chunk[0],\n                                              chunk[-1],\n                                              ValueStops[i],\n                                              ValueStops[j],\n                                              Frame)\n                \n            elif Frame >= AnimationEnd:\n                Value = ValueStops[-1]\n        else:\n            rml = self.RuntimeMessageLevel.Warning\n            self.AddRuntimeMessage(rml,\n                        \"Input parameter Frame failed to collect data\")\n        \n        # return outputs if you have them; here I try it for you:\n        return Value\n",
  "language": "python",
  "imports": [
    "Rhino",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}