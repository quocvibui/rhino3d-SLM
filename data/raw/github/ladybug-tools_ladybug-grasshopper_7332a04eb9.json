{
  "source_url": "https://github.com/ladybug-tools/ladybug-grasshopper/blob/a10c14adff547d29bb4ee6715984e58ea4adfef9/ladybug_grasshopper/src/LB%20Create%20Legend.py",
  "repo": "ladybug-tools/ladybug-grasshopper",
  "repo_stars": 46,
  "repo_description": "üêû :green_book: Ladybug plugin for Grasshopper",
  "license": "AGPL-3.0",
  "filepath": "ladybug_grasshopper/src/LB Create Legend.py",
  "instruction": "Create a custom legend for any set of data or range. Creating a legend with this\ncomponent allows for a bit more flexibility than what can be achieved by working\nwith the legends automatically output...",
  "code": "# Ladybug: A Plugin for Environmental Analysis (GPL)\n# This file is part of Ladybug.\n#\n# Copyright (c) 2025, Ladybug Tools.\n# You should have received a copy of the GNU Affero General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license AGPL-3.0-or-later <https://spdx.org/licenses/AGPL-3.0-or-later>\n\n\n\"\"\"\nCreate a custom legend for any set of data or range. Creating a legend with this\ncomponent allows for a bit more flexibility than what can be achieved by working\nwith the legends automatically output from different studies.\n-\n\n    Args:\n        _values: A list of numerical values or data collections that the legend refers\n            to. This can also be the minimum and maximum numerical values of the\n            data. The legend's maximum and minimum values will be set by the max\n            and min of the data set.\n        _base_plane_: An optional plane or point to set the location of the\n            legend. (Default: Rhino origin - (0, 0, 0))\n        title_: A text string representing a legend title. Legends are usually\n            titled with the units of the data.\n        legend_par_: Optional legend parameters from the \"LB Legend Parameters\" component.\n        leg_par2d_: Optional 2D LegendParameters from the \"LB Legend Parameters 2D\"\n            component, which will be used to customize a legend in the plane\n            of the screen so that it functions like a head-up display (HUD).\n            If unspecified, the VisualizationSet will be rendered with 3D\n            legends in the Rhino scene much like the other native Ladybug\n            Tools components.\n        viewport_: Text for the name of the Rhino viewport to which the 2D legend will\n            be rendered. This input only has an effect when leg_par2d_ are\n            connected. Multiple viewports can be connected to have the legend\n            display in several viewports. If unspecified, the legend is rendered\n            in all viewports. Acceptable inputs include:\n                -\n                Perspective\n                Top\n                Bottom\n                Left\n                Right\n                Front\n                Back\n                any view name that has been saved within the Rhino file\n\n    Returns:\n        mesh: A colored mesh for the legend colors.\n        title_obj: A text object for the  legend title.\n        label_objs: An array of text objects for the label text.\n        label_text: An array of text strings for the label text.\n        colors: An array of colors that align with the input _values. This can\n            be used to color geometry that aligns with the values.\n\"\"\"\n\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\nclass MyComponent(component):\n    \n    def __init__(self):\n        super(MyComponent,self).__init__()\n        self.draw_2d_text = None\n        self.draw_sprite = None\n        self.colored_mesh = None\n        self.viewport = ()\n    \n    def RunScript(self, _values, _base_plane_, title_, legend_par_, leg_par2d_, viewport_):\n        ghenv.Component.Name = \"LB Create Legend\"\n        ghenv.Component.NickName = 'CreateLegend'\n        ghenv.Component.Message = '1.9.2'\n        ghenv.Component.Category = 'Ladybug'\n        ghenv.Component.SubCategory = '4 :: Extra'\n        ghenv.Component.AdditionalHelpFromDocStrings = '0'\n        \n        try:\n            from ladybug.legend import Legend, LegendParameters\n        except ImportError as e:\n            raise ImportError('\\nFailed to import ladybug:\\n\\t{}'.format(e))\n        \n        try:\n            from ladybug_rhino.togeometry import to_plane\n            from ladybug_rhino.fromobjects import legend_objects\n            from ladybug_rhino.color import color_to_color\n            from ladybug_rhino.preview import VisualizationSetConverter\n            from ladybug_rhino.grasshopper import all_required_inputs\n        except ImportError as e:\n            raise ImportError('\\nFailed to import ladybug_rhino:\\n\\t{}'.format(e))\n        \n        \n        if all_required_inputs(ghenv.Component):\n            # set default values\n            legend_par_ = legend_par_.duplicate() if legend_par_ is not None else \\\n                LegendParameters()\n            if _base_plane_:\n                legend_par_.base_plane = to_plane(_base_plane_)\n            legend_par_.title = title_\n            \n            # create the legend\n            values = []\n            for val in _values:\n                try:\n                    values.append(float(val))\n                except AttributeError:  # assume it's a data collection\n                    values.extend(val.values)\n            legend = Legend(values, legend_par_)\n            colors = [color_to_color(col) for col in legend.value_colors]\n            label_text = legend.segment_text\n            \n            if leg_par2d_ is None:  # output a 3D legend\n                self.draw_2d_text, self.draw_sprite = None, None\n                rhino_objs = legend_objects(legend)\n                mesh = rhino_objs[0]\n                title_obj = rhino_objs[1]\n                label_objs = rhino_objs[2:]\n            else:  # output a 2D legend that is oriented to the screen\n                mesh, title_obj, label_objs= None, None, None\n                legend.legend_parameters.properties_2d = leg_par2d_\n                d_sprite, self.draw_2d_text = \\\n                    VisualizationSetConverter.convert_legend2d(legend)\n                self.draw_sprite = [d_sprite]\n            self.viewport = tuple(vp.lower() for vp in viewport_)\n        else:\n            mesh, title_obj, label_objs, label_text, colors = \\\n                None, None, None, None, None\n            self.draw_2d_text, self.draw_sprite = None, None\n            self.viewport = ()\n        \n        # return outputs if you have them; here I try it for you\n        self.colored_mesh = mesh\n        return (mesh, title_obj, label_objs, label_text, colors)\n        \n    def DrawViewportMeshes(self, args):\n        try:\n            if ghenv.Component.Locked:\n                return\n            if len(self.viewport) == 0 or args.Viewport.Name.lower() in self.viewport:\n                # get the DisplayPipeline from the event arguments\n                display = args.Display\n                # draw the objects in the scene\n                if self.colored_mesh is not None:\n                    display.DrawMeshFalseColors(self.colored_mesh)\n                if self.draw_2d_text is not None:\n                    for draw_args in self.draw_2d_text:\n                        display.Draw2dText(*draw_args)\n                if self.draw_sprite is not None:\n                    for draw_args in self.draw_sprite:\n                        display.DrawSprite(*draw_args)\n        except Exception, e:\n            System.Windows.Forms.MessageBox.Show(str(e), \"script error\")\n    \n    def get_ClippingBox(self):\n        return Rhino.Geometry.BoundingBox()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}