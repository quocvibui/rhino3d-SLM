{
  "source_url": "https://discourse.mcneel.com/t/i-asked-chatgpt-to-scatter-geometry/211140",
  "topic_id": 211140,
  "title": "I asked ChatGPT to scatter geometry",
  "question": "This script was done in 2 parts:\n\nFirst, uniformly distrubute points. Avoid points too close together or too far apart.\n\nThen add more options:\n\n\n\n\nNumber of points.\n\n\nMaximum random angle of rotation.\n\n\nSeed\n\n\nUse Cplane Z direction instead of surface normal.\n\n\n\n\nTested on Surfaces, Polysurfaces and Subsurfaces.\n\nGrouped geometry is scattered as more groups.\n\nSimilar to PopGeo in Grasshopper.\n\n\n\n\n\n\n# UI-driven scatter & orient tool\n# Update: If input geometry is already grouped, DO NOT re-use those groups for the copies.\n#         New scattered copies are first removed from all inherited groups, then grouped per point.\n# - Step 1 supports preselect + grouped selection for faces\n# - Step 2 supports grouped selection for geometry\n# - Deterministic seed for scatter & rotation\n# - Preview points are always deleted on exit\n\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino\nimport Rhino.Geometry as rg\nimport random, math\n\n# ---------------- Sampling & helpers ----------------\n\ndef area_weighted_picker_with_index(faces, rnd):\n    areas = [rg.AreaMassProperties.Compute(f).Area for f in faces]\n    A = sum(areas)\n    cuml=[]; s=0.0\n    for a in areas:\n        s+=a; cuml.append(s)\n    def pick_idx_face():\n        t = rnd.random()*A\n        for i,c in enumerate(cuml):\n            if t<=c: return i, faces[i], A\n        return len(faces)-1, faces[-1], A\n    return pick_idx_face, A\n\ndef rand_uv(face, rnd, tries=200):\n    du,dv = face.Domain(0), face.Domain(1)\n    u0,u1 = min(du.T0,du.T1), max(du.T0,du.T1)\n    v0,v1 = min(dv.T0,dv.T1), max(dv.T0,dv.T1)\n    for _ in range(tries):\n        u = rnd.uniform(u0,u1); v = rnd.uniform(v0,v1)\n        if face.IsPointOnFace(u,v) != rg.PointFaceRelation.Exterior: return u,v\n    return None\n\ndef scatter_points_on_faces(faces, N, seed, boost=1.30, K=12):\n    \"\"\"Return (points, face_indices), deterministic w.r.t. seed.\"\"\"\n    if not faces or N<=0: return [], []\n    rnd = random.Random(seed)\n    pick, A = area_weighted_picker_...",
  "code_blocks": [
    {
      "code": "# UI-driven scatter & orient tool\n# Update: If input geometry is already grouped, DO NOT re-use those groups for the copies.\n#         New scattered copies are first removed from all inherited groups, then grouped per point.\n# - Step 1 supports preselect + grouped selection for faces\n# - Step 2 supports grouped selection for geometry\n# - Deterministic seed for scatter & rotation\n# - Preview points are always deleted on exit\n\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino\nimport Rhino.Geometry as rg\nimport random, math\n\n# ---------------- Sampling & helpers ----------------\n\ndef area_weighted_picker_with_index(faces, rnd):\n    areas = [rg.AreaMassProperties.Compute(f).Area for f in faces]\n    A = sum(areas)\n    cuml=[]; s=0.0\n    for a in areas:\n        s+=a; cuml.append(s)\n    def pick_idx_face():\n        t = rnd.random()*A\n        for i,c in enumerate(cuml):\n            if t<=c: return i, faces[i], A\n        return len(faces)-1, faces[-1], A\n    return pick_idx_face, A\n\ndef rand_uv(face, rnd, tries=200):\n    du,dv = face.Domain(0), face.Domain(1)\n    u0,u1 = min(du.T0,du.T1), max(du.T0,du.T1)\n    v0,v1 = min(dv.T0,dv.T1), max(dv.T0,dv.T1)\n    for _ in range(tries):\n        u = rnd.uniform(u0,u1); v = rnd.uniform(v0,v1)\n        if face.IsPointOnFace(u,v) != rg.PointFaceRelation.Exterior: return u,v\n    return None\n\ndef scatter_points_on_faces(faces, N, seed, boost=1.30, K=12):\n    \"\"\"Return (points, face_indices), deterministic w.r.t. seed.\"\"\"\n    if not faces or N<=0: return [], []\n    rnd = random.Random(seed)\n    pick, A = area_weighted_picker_with_index(faces, rnd)\n    r = math.sqrt(A/(float(N)*math.pi)) * boost\n    r2 = r*r\n    pts = []; face_indices = []\n    tries = 0; max_tries = 250*N\n    while len(pts) < N and tries < max_tries:\n        best = None  # (best_d2, point, face_idx)\n        for _ in range(K):\n            fi, f, _A = pick()\n            uv = rand_uv(f, rnd)\n            if not uv: continue\n            p = f.PointAt(uv[0], uv[1])\n            if not pts:\n                best = (1e9, p, fi); break\n            md2 = min((p - q).SquareLength for q in pts)\n            if (best is None) or (md2 > best[0]):\n                best = (md2, p, fi)\n        if best is None:\n            tries += 1; continue\n        if best[0] >= r2 or (tries % 40 == 0):\n            pts.append(best[1]); face_indices.append(best[2])\n        tries += 1\n    return pts, face_indices\n\ndef EvaluateSurfaceFromPoints(faces, points):\n    planes = []\n    for p in points:\n        best = None\n        bestd2 = 1e300\n        for f in faces:\n            rc, u, v = f.ClosestPoint(p)\n            if not rc: continue\n            q = f.PointAt(u, v)\n            d2 = (q - p).SquareLength\n            if d2 < bestd2:\n                bestd2 = d2\n                ok, pl = f.FrameAt(u, v)\n                if ok: best = pl\n        if best is None:\n            best = rg.Plane(p, rg.Vector3d.ZAxis)\n        planes.append(best)\n    return planes\n\ndef RandomRotatePlanes(planes, max_deg=0.0, seed=1):\n    if not planes: return []\n    rnd = random.Random(seed)\n    out = []\n    for pl in planes:\n        p = rg.Plane(pl)\n        if max_deg > 0.0:\n            ang = math.radians(rnd.uniform(0.0, max_deg))\n            rot = rg.Transform.Rotation(ang, p.ZAxis, p.Origin)\n            p.Transform(rot)\n        out.append(p)\n    return out\n\ndef CplaneZ(apply_cplane_z, planes):\n    if not planes: return []\n    if not apply_cplane_z: return planes\n    view = Rhino.RhinoDoc.ActiveDoc.Views.ActiveView\n    cplane = view.ActiveViewport.ConstructionPlane()\n    newplanes = []\n    for pl in planes:\n        p = rg.Plane(pl)\n        z = cplane.ZAxis\n        x = pl.XAxis\n        x -= rg.Vector3d.Multiply(x * z, z)\n        if x.IsTiny(): x = cplane.XAxis\n        x.Unitize()\n        y = rg.Vector3d.CrossProduct(z, x)\n        newplanes.append(rg.Plane(p.Origin, x, y))\n    return newplanes\n\ndef BoundingBoxBase(guids):\n    if not guids: return None\n    view = Rhino.RhinoDoc.ActiveDoc.Views.ActiveView\n    cplane = view.ActiveViewport.ConstructionPlane()\n    bb = None\n    for g in guids:\n        obj = sc.doc.Objects.Find(g)\n        if not obj: continue\n        geo = obj.Geometry\n        b = geo.GetBoundingBox(cplane)\n        if bb is None: bb = b\n        else: bb = rg.BoundingBox.Union(bb, b)\n    if bb is None or not bb.IsValid:\n        return cplane\n    box = rg.Box(cplane, bb)\n    base_pt = cplane.PointAt(box.X.Mid, box.Y.Mid, box.Z.T0)\n    return rg.Plane(base_pt, cplane.XAxis, cplane.YAxis)\n\n# ---------- Grouped output per target (one group per point), with inherited groups stripped ----------\n\ndef _next_group_name(prefix=\"Scatter\"):\n    existing = set(rs.GroupNames() or [])\n    i = 0\n    while True:\n        name = \"{}_{}\".format(prefix, i)\n        if name not in existing:\n            return name\n        i += 1\n\ndef OrientGeometry_GroupPerPoint(guids, base_plane, target_planes, group_prefix=\"Scatter\"):\n    \"\"\"\n    For each target plane:\n      - copy all 'guids' with PlaneToPlane transform\n      - remove any inherited group memberships from those copies (so originals' groups don't bind copies)\n      - create a unique group and add those copies into it\n    Returns flat list of all new object ids.\n    \"\"\"\n    if not guids or not target_planes or base_plane is None:\n        return []\n    all_ids = []\n    for _i, pl in enumerate(target_planes):\n        xform = rg.Transform.PlaneToPlane(base_plane, pl)\n        ids = rs.TransformObjects(guids, xform, copy=True)\n        if not ids:\n            continue\n        # Strip any inherited group memberships from the new copies\n        for oid in ids:\n            try:\n                rs.RemoveObjectFromAllGroups(oid)\n            except:\n                pass\n        # Now put just this set into its own group\n        grp = _next_group_name(group_prefix)\n        if not rs.IsGroup(grp):\n            rs.AddGroup(grp)\n        rs.AddObjectsToGroup(ids, grp)\n        all_ids.extend(ids)\n    return all_ids\n\n# ---------------- Selection helpers ----------------\n\ndef pick_faces():\n    \"\"\"\n    Step 1: allow preselection and group selection for surfaces/polysurfaces/sub-faces.\n    We clear selection AFTER capturing to avoid carry-over into step 2.\n    \"\"\"\n    go = Rhino.Input.Custom.GetObject()\n    go.SetCommandPrompt(\"1) Select surface(s), sub-face(s), or polysurface(s) to populate\")\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Surface | Rhino.DocObjects.ObjectType.Brep\n    go.SubObjectSelect = True\n    go.GroupSelect = True                  # accept grouped geometry\n    go.EnablePreSelect(True, True)         # allow preselect and keep it\n    if go.GetMultiple(1,0) != Rhino.Input.GetResult.Object:\n        return []\n    objrefs = [go.Object(i) for i in range(go.ObjectCount)]\n    faces = []\n    for ob in objrefs:\n        f = ob.Face()\n        if f:\n            faces.append(f)\n        else:\n            b = ob.Brep()\n            if not b:\n                geo = ob.Geometry()\n                if isinstance(geo, rg.Surface):\n                    b = geo.ToBrep()\n            if b:\n                for i in range(b.Faces.Count):\n                    faces.append(b.Faces[i])\n    # Clear selection to prevent step 2 from reusing it\n    Rhino.RhinoDoc.ActiveDoc.Objects.UnselectAll()\n    return faces\n\ndef pick_geometry_to_orient():\n    \"\"\"\n    Step 2: accept grouped geometry (fresh selection to avoid reusing step-1 selection).\n    \"\"\"\n    go = Rhino.Input.Custom.GetObject()\n    go.SetCommandPrompt(\"2) Select geometry to orient (BasePlane from current CPlane bbox)\")\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.AnyObject\n    go.SubObjectSelect = False\n    go.GroupSelect = True                  # accept grouped geometry\n    go.AcceptNothing(False)\n    go.EnablePreSelect(False, True)        # force a fresh pick for this step\n    go.DeselectAllBeforePostSelect = True  # clear selection first\n    if go.GetMultiple(1,0) != Rhino.Input.GetResult.Object:\n        return []\n    ids = [go.Object(i).ObjectId for i in range(go.ObjectCount)]\n    Rhino.RhinoDoc.ActiveDoc.Objects.UnselectAll()\n    return ids\n\n# ---------------- Preview run (uses seed for BOTH scatter and rotation) ----------------\n\ndef run_preview(faces, geom_to_orient, base_plane, N, max_deg, seed, use_cplane_z):\n    pts, _face_idx = scatter_points_on_faces(faces, N, seed=seed, boost=1.30, K=12)\n    pt_ids = [sc.doc.Objects.AddPoint(p) for p in pts]\n\n    planes = EvaluateSurfaceFromPoints(faces, pts)\n    planes = RandomRotatePlanes(planes, max_deg, seed)\n    planes = CplaneZ(use_cplane_z, planes)\n\n    # GROUPED: one group per plane/point, strip inherited groups from copies\n    oriented_ids = OrientGeometry_GroupPerPoint(geom_to_orient, base_plane, planes, group_prefix=\"Scatter\")\n\n    return pt_ids, oriented_ids\n\n# ---------------- Main UI loop ----------------\n\ndef main():\n    # 1) Surfaces to populate (preselect + group ok)\n    faces = pick_faces()\n    if not faces: return\n\n    # 2) Geometry to orient (group ok)\n    geom = pick_geometry_to_orient()\n    if not geom: return\n    base_plane = BoundingBoxBase(geom)\n    if base_plane is None: return\n\n    # Defaults\n    points = 20\n    max_angle = 360.0\n    seed = 1\n    use_cplane_z = False\n\n    # First preview run (automatic)\n    prev_pt_ids = []\n    prev_oriented_ids = []\n\n    def clear_prev():\n        if prev_oriented_ids:\n            try: rs.DeleteObjects(prev_oriented_ids)\n            except: pass\n            prev_oriented_ids[:] = []\n        if prev_pt_ids:\n            try: rs.DeleteObjects(prev_pt_ids)\n            except: pass\n            prev_pt_ids[:] = []\n\n    rs.EnableRedraw(False)\n    pt_ids, oriented_ids = run_preview(faces, geom, base_plane, points, max_angle, seed, use_cplane_z)\n    prev_pt_ids = pt_ids[:]\n    prev_oriented_ids = oriented_ids[:]\n    rs.EnableRedraw(True); sc.doc.Views.Redraw()\n\n    # Build option loop\n    go = Rhino.Input.Custom.GetOption()\n    go.SetCommandPrompt(\"3) Adjust scatter. Change options or choose KeepScatter to finish.\")\n\n    opt_points = Rhino.Input.Custom.OptionInteger(points, 1, 10**7)\n    opt_angle  = Rhino.Input.Custom.OptionDouble(max_angle, 0.0, 360.0)\n    opt_seed   = Rhino.Input.Custom.OptionInteger(seed, 0, 10**9)\n    opt_cpz    = Rhino.Input.Custom.OptionToggle(use_cplane_z, \"False\", \"True\")\n\n    idx_points = go.AddOptionInteger(\"Points\", opt_points)\n    idx_keep   = go.AddOption(\"KeepScatter\")\n    idx_angle  = go.AddOptionDouble(\"MaxAngle\", opt_angle)\n    idx_seed   = go.AddOptionInteger(\"Seed\", opt_seed)\n    idx_cpz    = go.AddOptionToggle(\"CplaneZ\", opt_cpz)\n\n    while True:\n        res = go.Get()\n\n        if res == Rhino.Input.GetResult.Option:\n            idx = go.OptionIndex()\n\n            new_points = opt_points.CurrentValue\n            new_angle  = float(opt_angle.CurrentValue)\n            new_seed   = opt_seed.CurrentValue\n            new_cpz    = opt_cpz.CurrentValue\n\n            # Exit ONLY if KeepScatter picked (and delete preview points before ending)\n            if idx == idx_keep:\n                rs.EnableRedraw(False)\n                if prev_pt_ids: rs.DeleteObjects(prev_pt_ids)\n                rs.EnableRedraw(True); sc.doc.Views.Redraw()\n                break\n\n            # Rerun preview if any option changed\n            changed = (\n                new_points != points or\n                abs(new_angle - max_angle) > 1e-9 or\n                new_seed != seed or\n                new_cpz != use_cplane_z\n            )\n            if changed:\n                points, max_angle, seed, use_cplane_z = new_points, new_angle, new_seed, new_cpz\n                rs.EnableRedraw(False)\n                clear_prev()\n                pt_ids, oriented_ids = run_preview(faces, geom, base_plane, points, max_angle, seed, use_cplane_z)\n                prev_pt_ids = pt_ids[:]\n                prev_oriented_ids = oriented_ids[:]\n                rs.EnableRedraw(True); sc.doc.Views.Redraw()\n            continue\n\n        elif res == Rhino.Input.GetResult.Nothing:\n            # Keep dialog open on Enter; do nothing\n            continue\n\n        elif res == Rhino.Input.GetResult.Cancel:\n            # Cancel: delete preview points before ending\n            rs.EnableRedraw(False)\n            if prev_pt_ids: rs.DeleteObjects(prev_pt_ids)\n            rs.EnableRedraw(True); sc.doc.Views.Redraw()\n            break\n\nif __name__ == \"__main__\":\n    main()",
      "language": "python",
      "author": "Bogdan_Chipara",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "grasshopper",
    "python",
    "rhinocommon",
    "rhinoscriptsyntax",
    "selection",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 11,
  "posts_count": 11,
  "views": 370
}