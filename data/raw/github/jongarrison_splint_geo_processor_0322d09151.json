{
  "source_url": "https://github.com/jongarrison/splint_geo_processor/blob/b4a410b94aa8ddd9dad7ee8d35d452964254ef41/generators/src/BrepGeneration.py",
  "repo": "jongarrison/splint_geo_processor",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "generators/src/BrepGeneration.py",
  "instruction": "Reusable geometry generation functions for Grasshopper/Rhino",
  "code": "\"\"\"\nReusable geometry generation functions for Grasshopper/Rhino\n\nThese functions create clean, validated brep geometry suitable for boolean operations.\nUses splintcommon.log for output.\n\"\"\"\n\nimport Rhino.Geometry as rg\nimport scriptcontext as sc\nimport math\nfrom splintcommon import log\n\ndef create_tapered_cylinder(center_line, radius_start, radius_end, tolerance=None):\n    \"\"\"\n    Create a clean tapered cylinder using surface of revolution.\n    More reliable than lofting - avoids seam misalignment and self-intersections.\n    \n    Args:\n        center_line: Line defining the cylinder axis\n        radius_start: Radius at start of line\n        radius_end: Radius at end of line\n        tolerance: Optional tolerance (uses doc tolerance if None)\n    \n    Returns:\n        Brep: Capped tapered cylinder, or None if creation fails\n    \"\"\"\n    try:\n        if tolerance is None or tolerance <= 0:\n            tolerance = sc.doc.ModelAbsoluteTolerance\n        \n        # Validate inputs\n        if not center_line or center_line.Length < tolerance:\n            log(\"ERROR: Invalid center line (too short or None)\")\n            return None\n        \n        if radius_start <= 0 or radius_end <= 0:\n            log(\"ERROR: Invalid radii (must be > 0)\")\n            return None\n        \n        # Get line endpoints\n        pt_start = center_line.From\n        pt_end = center_line.To\n        \n        # Create axis vector\n        axis_vector = rg.Vector3d(pt_end - pt_start)\n        axis_vector.Unitize()\n        \n        # Find a perpendicular vector to the axis\n        # Use a robust method that works for any axis orientation\n        if abs(axis_vector.Z) < 0.9:\n            # Axis is not vertical - use Z cross product\n            perp = rg.Vector3d.CrossProduct(axis_vector, rg.Vector3d.ZAxis)\n        else:\n            # Axis is vertical - use X cross product\n            perp = rg.Vector3d.CrossProduct(axis_vector, rg.Vector3d.XAxis)\n        \n        perp.Unitize()\n        \n        # Create profile line (outer edge of cone/cylinder)\n        profile_start = pt_start + perp * radius_start\n        profile_end = pt_end + perp * radius_end\n        profile_line = rg.Line(profile_start, profile_end)\n        \n        # Create revolution surface\n        rev_surface = rg.RevSurface.Create(\n            profile_line.ToNurbsCurve(),\n            center_line,\n            0.0,  # start angle\n            2.0 * math.pi  # end angle (full circle)\n        )\n        \n        if not rev_surface:\n            log(\"ERROR: Failed to create revolution surface\")\n            log(\"  Profile line: {} to {}\".format(profile_start, profile_end))\n            log(\"  Axis: {} to {}\".format(pt_start, pt_end))\n            log(\"  Radii: r1={:.3f}, r2={:.3f}\".format(radius_start, radius_end))\n            return None\n        \n        # Convert to brep\n        brep = rev_surface.ToBrep()\n        if not brep:\n            log(\"ERROR: Failed to convert revolution surface to brep\")\n            return None\n        \n        # Cap both ends to create solid\n        # Method 1: Try CapPlanarHoles\n        capped = brep.CapPlanarHoles(tolerance)\n        \n        # Method 2: If still not solid, try adding planar caps manually\n        if not brep.IsSolid:\n            log(\"  Trying manual planar caps...\")\n            # Create planar caps at each end\n            # Start cap - create plane at start with axis as normal\n            start_plane = rg.Plane(pt_start, axis_vector)\n            start_circle = rg.Circle(start_plane, radius_start)\n            start_curve = start_circle.ToNurbsCurve()\n            start_cap = rg.Brep.CreatePlanarBreps([start_curve], tolerance)\n            \n            # End cap - create plane at end with axis as normal\n            end_plane = rg.Plane(pt_end, axis_vector)\n            end_circle = rg.Circle(end_plane, radius_end)\n            end_curve = end_circle.ToNurbsCurve()\n            end_cap = rg.Brep.CreatePlanarBreps([end_curve], tolerance)\n            \n            if start_cap and len(start_cap) > 0 and end_cap and len(end_cap) > 0:\n                # Join all breps\n                all_breps = [brep, start_cap[0], end_cap[0]]\n                joined = rg.Brep.JoinBreps(all_breps, tolerance)\n                if joined and len(joined) > 0:\n                    brep = joined[0]\n                    log(\"  Joined revolution surface with planar caps\")\n        \n        # Final cleanup and validation\n        if brep.IsSolid:\n            # Clean up the brep\n            brep.Faces.SplitKinkyFaces(sc.doc.ModelAngleToleranceRadians, True)\n            brep.Compact()\n            \n            # Try to remove any micro-edges or degeneracies\n            brep.MergeCoplanarFaces(tolerance)\n            \n            # If not valid, try to repair\n            if not brep.IsValid:\n                log(\"  Attempting repair (IsValid=False)...\")\n                repaired = brep.Repair(tolerance)\n                if repaired:\n                    log(\"  Repair successful\")\n                else:\n                    log(\"  Repair failed, but continuing anyway\")\n            \n            # Final validation - accept if solid and manifold, even if repair needed\n            if brep.IsSolid and brep.IsManifold:\n                naked_edges = sum(1 for e in brep.Edges if e.Valence == rg.EdgeAdjacency.Naked)\n                log(\"Created tapered cylinder: r1={:.3f}, r2={:.3f}, length={:.3f}, faces={}, edges={}, naked={}, valid={}\".format(\n                    radius_start, radius_end, center_line.Length, brep.Faces.Count, brep.Edges.Count, naked_edges, brep.IsValid))\n                return brep\n            else:\n                log(\"ERROR: Tapered cylinder failed final validation\")\n                log(\"  IsValid: {}, IsSolid: {}, IsManifold: {}\".format(\n                    brep.IsValid, brep.IsSolid, brep.IsManifold))\n                return None\n        else:\n            log(\"ERROR: Tapered cylinder not solid after capping attempts\")\n            log(\"  IsValid: {}, IsSolid: {}, Faces: {}\".format(\n                brep.IsValid, brep.IsSolid, brep.Faces.Count))\n            return None\n            \n    except Exception as e:\n        log(\"ERROR creating tapered cylinder: {}\".format(str(e)))\n        return None\n\n\ndef create_sphere(center, radius, tolerance=None):\n    \"\"\"\n    Create a clean solid sphere.\n    \n    Args:\n        center: Point3d center of sphere\n        radius: Sphere radius\n        tolerance: Optional tolerance (uses doc tolerance if None)\n    \n    Returns:\n        Brep: Solid sphere, or None if creation fails\n    \"\"\"\n    try:\n        if tolerance is None or tolerance <= 0:\n            tolerance = sc.doc.ModelAbsoluteTolerance\n        \n        if radius <= 0:\n            log(\"ERROR: Invalid radius (must be > 0)\")\n            return None\n        \n        # Create sphere\n        sphere = rg.Sphere(center, radius)\n        brep = sphere.ToBrep()\n        \n        if brep and brep.IsValid and brep.IsSolid:\n            log(\"Created sphere: r={:.3f} at {}\".format(radius, center))\n            return brep\n        else:\n            log(\"ERROR: Failed to create valid sphere\")\n            return None\n            \n    except Exception as e:\n        log(\"ERROR creating sphere: {}\".format(str(e)))\n        return None\n\n\ndef create_cylinder(base_plane, radius, height, tolerance=None):\n    \"\"\"\n    Create a clean solid cylinder.\n    \n    Args:\n        base_plane: Plane defining base center and axis direction\n        radius: Cylinder radius\n        height: Cylinder height (can be negative for opposite direction)\n        tolerance: Optional tolerance (uses doc tolerance if None)\n    \n    Returns:\n        Brep: Solid cylinder, or None if creation fails\n    \"\"\"\n    try:\n        if tolerance is None or tolerance <= 0:\n            tolerance = sc.doc.ModelAbsoluteTolerance\n        \n        if radius <= 0:\n            log(\"ERROR: Invalid radius (must be > 0)\")\n            return None\n        \n        if abs(height) < tolerance:\n            log(\"ERROR: Invalid height (too small)\")\n            return None\n        \n        # Create base circle\n        circle = rg.Circle(base_plane, radius)\n        \n        # Create cylinder\n        cylinder = rg.Cylinder(circle, height)\n        brep = cylinder.ToBrep(True, True)  # cap both ends\n        \n        if brep and brep.IsValid and brep.IsSolid:\n            log(\"Created cylinder: r={:.3f}, h={:.3f}\".format(radius, height))\n            return brep\n        else:\n            log(\"ERROR: Failed to create valid cylinder\")\n            return None\n            \n    except Exception as e:\n        log(\"ERROR creating cylinder: {}\".format(str(e)))\n        return None\n\n\ndef create_bulged_cylinder(center_line, radius_start, radius_mid, radius_end, tolerance=None):\n    \"\"\"\n    Create a solid tube with a bulge (or waist) at the midpoint using surface of revolution.\n    \n    Uses a quadratic bezier curve as the profile, revolved around the axis.\n    This approach is more robust than lofting circles.\n    \n    The profile passes through three points:\n        - Start: (0, radius_start)\n        - Mid:   (length/2, radius_mid)  \n        - End:   (length, radius_end)\n    \n    Args:\n        center_line: Line defining the tube axis\n        radius_start: Radius at start of line\n        radius_mid: Radius at midpoint (can be larger or smaller than ends)\n        radius_end: Radius at end of line\n        tolerance: Optional tolerance (uses doc tolerance if None)\n    \n    Returns:\n        Brep: Capped tube, or None if creation fails\n    \"\"\"\n    try:\n        if tolerance is None or tolerance <= 0:\n            tolerance = sc.doc.ModelAbsoluteTolerance\n        \n        # Validate inputs\n        if not center_line or center_line.Length < tolerance:\n            log(\"ERROR: Invalid center line (too short or None)\")\n            return None\n        \n        if radius_start <= 0 or radius_mid <= 0 or radius_end <= 0:\n            log(\"ERROR: Invalid radii (must be > 0)\")\n            return None\n        \n        length = center_line.Length\n        \n        # Get line endpoints and direction\n        pt_start = center_line.From\n        pt_end = center_line.To\n        axis_vector = rg.Vector3d(pt_end - pt_start)\n        axis_vector.Unitize()\n        \n        # Find a perpendicular vector to the axis (same logic as tapered cylinder)\n        if abs(axis_vector.Z) < 0.9:\n            perp = rg.Vector3d.CrossProduct(axis_vector, rg.Vector3d.ZAxis)\n        else:\n            perp = rg.Vector3d.CrossProduct(axis_vector, rg.Vector3d.XAxis)\n        perp.Unitize()\n        \n        # Create profile points in the axis-perpendicular plane\n        # Points are: start (at radius_start), mid (at radius_mid), end (at radius_end)\n        profile_start = pt_start + perp * radius_start\n        profile_mid = pt_start + axis_vector * (length / 2.0) + perp * radius_mid\n        profile_end = pt_end + perp * radius_end\n        \n        # Create a quadratic bezier curve through the three points\n        # For a quadratic bezier passing through start, mid, end:\n        # We need to compute the control point\n        # B(0.5) = 0.25*P0 + 0.5*P1 + 0.25*P2 = mid_point\n        # So: P1 = 2*mid_point - 0.5*P0 - 0.5*P2\n        control_pt = rg.Point3d(\n            2.0 * profile_mid.X - 0.5 * profile_start.X - 0.5 * profile_end.X,\n            2.0 * profile_mid.Y - 0.5 * profile_start.Y - 0.5 * profile_end.Y,\n            2.0 * profile_mid.Z - 0.5 * profile_start.Z - 0.5 * profile_end.Z\n        )\n        \n        # Create the bezier curve (degree 2 = quadratic)\n        bezier_points = [profile_start, control_pt, profile_end]\n        profile_curve = rg.NurbsCurve.Create(False, 2, bezier_points)\n        \n        if not profile_curve:\n            log(\"ERROR: Failed to create bezier profile curve\")\n            return None\n        \n        # Create revolution surface around the center line\n        rev_surface = rg.RevSurface.Create(\n            profile_curve,\n            center_line,\n            0.0,\n            2.0 * math.pi\n        )\n        \n        if not rev_surface:\n            log(\"ERROR: Failed to create revolution surface for bulged cylinder\")\n            return None\n        \n        # Convert to brep\n        brep = rev_surface.ToBrep()\n        if not brep:\n            log(\"ERROR: Failed to convert revolution surface to brep\")\n            return None\n        \n        # Cap both ends\n        capped = brep.CapPlanarHoles(tolerance)\n        \n        if not brep.IsSolid:\n            # Try manual capping\n            log(\"  Bulged cylinder (rev): trying manual planar caps...\")\n            start_plane = rg.Plane(pt_start, axis_vector)\n            start_circle = rg.Circle(start_plane, radius_start)\n            start_cap = rg.Brep.CreatePlanarBreps([start_circle.ToNurbsCurve()], tolerance)\n            \n            end_plane = rg.Plane(pt_end, axis_vector)\n            end_circle = rg.Circle(end_plane, radius_end)\n            end_cap = rg.Brep.CreatePlanarBreps([end_circle.ToNurbsCurve()], tolerance)\n            \n            if start_cap and len(start_cap) > 0 and end_cap and len(end_cap) > 0:\n                all_breps = [brep, start_cap[0], end_cap[0]]\n                joined = rg.Brep.JoinBreps(all_breps, tolerance)\n                if joined and len(joined) > 0:\n                    brep = joined[0]\n                    log(\"  Joined revolution surface with planar caps\")\n        \n        # Final validation\n        if brep.IsSolid:\n            brep.Faces.SplitKinkyFaces(sc.doc.ModelAngleToleranceRadians, True)\n            brep.Compact()\n            brep.MergeCoplanarFaces(tolerance)\n            \n            if not brep.IsValid:\n                log(\"  Attempting repair (IsValid=False)...\")\n                brep.Repair(tolerance)\n            \n            if brep.IsSolid and brep.IsManifold:\n                naked_edges = sum(1 for e in brep.Edges if e.Valence == rg.EdgeAdjacency.Naked)\n                log(\"Created bulged cylinder (revolution): r1={:.3f}, r_mid={:.3f}, r2={:.3f}, length={:.3f}, faces={}, naked={}\".format(\n                    radius_start, radius_mid, radius_end, length, brep.Faces.Count, naked_edges))\n                return brep\n            else:\n                log(\"ERROR: Bulged cylinder failed final validation\")\n                log(\"  IsValid: {}, IsSolid: {}, IsManifold: {}\".format(\n                    brep.IsValid, brep.IsSolid, brep.IsManifold))\n                return None\n        else:\n            log(\"ERROR: Bulged cylinder not solid after capping\")\n            return None\n            \n    except Exception as e:\n        log(\"ERROR creating bulged cylinder: {}\".format(str(e)))\n        return None\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}