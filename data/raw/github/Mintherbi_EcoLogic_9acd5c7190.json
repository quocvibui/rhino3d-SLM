{
  "source_url": "https://github.com/Mintherbi/EcoLogic/blob/546c53d7732477b1d04e916bcd629ad492b605a6/bin/Release/net7.0/PythonFiles/Mycelium/01_Static_Mycelium.py",
  "repo": "Mintherbi/EcoLogic",
  "repo_stars": 1,
  "repo_description": null,
  "license": "unknown",
  "filepath": "bin/Release/net7.0/PythonFiles/Mycelium/01_Static_Mycelium.py",
  "instruction": "01 static mycelium",
  "code": "from Rhino.Geometry import Point3d, Line, RTree, BoundingBox\nimport math\nimport random\n\n# ---------- robust point reader ----------\ndef collect_points(data):\n    \"\"\"Recursively collect any Point3d-like things from GH input into a flat list.\"\"\"\n    pts = []\n\n    def add_item(item):\n        if isinstance(item, Point3d):\n            pts.append(item)\n            return\n        if hasattr(item, \"X\") and hasattr(item, \"Y\") and hasattr(item, \"Z\"):\n            pts.append(Point3d(item.X, item.Y, item.Z))\n            return\n        if hasattr(item, \"Location\"):\n            p = item.Location\n            pts.append(Point3d(p.X, p.Y, p.Z))\n            return\n        if hasattr(item, \"Value\"):\n            add_item(item.Value)\n            return\n        try:\n            for sub in item:\n                add_item(sub)\n        except TypeError:\n            pass\n\n    add_item(data)\n    return pts\n\n# ---------- RTree helpers ----------\ndef build_rtree(nodes):\n    tree = RTree()\n    for i, n in enumerate(nodes):\n        tree.Insert(n.pos, i)\n    return tree\n\ndef neighbors(tree, pt, radius):\n    \"\"\"Return indices of nodes within radius of pt using bounding box search.\"\"\"\n    ids = []\n\n    def cb(sender, e):\n        ids.append(e.Id)\n\n    r = radius\n    bb = BoundingBox(\n        Point3d(pt.X - r, pt.Y - r, pt.Z - r),\n        Point3d(pt.X + r, pt.Y + r, pt.Z + r)\n    )\n    tree.Search(bb, cb, None)\n    return ids\n\n# ---------- read inputs ----------\nstart_pts  = collect_points(StartPts)   # seeds (you probably have 1 in the middle)\nall_food   = collect_points(FoodPts)    # all potential nutrients in 3D\n\nSegments = []\n\nif not start_pts:\n    Segments = []\n    Tips = []\nelse:\n    Step    = float(Step)\n    SenseR  = float(SenseR)\n    KillR   = float(KillR)\n    MaxIter = int(max(0, MaxIter))\n    GrowR   = float(GrowR)\n\n    # ---------- filter nutrients by growth radius (3D sphere) ----------\n    attractors = []\n    if GrowR > 0:\n        growR2 = GrowR * GrowR\n        for a in all_food:\n            for s in start_pts:\n                if s.DistanceToSquared(a) <= growR2:\n                    attractors.append(a)\n                    break\n\n    if not attractors:\n        Segments = []\n        Tips = start_pts\n    else:\n        class Node(object):\n            def __init__(self, pos, parent_index=-1):\n                self.pos = Point3d(pos)\n                self.parent = parent_index\n\n        nodes = [Node(p, -1) for p in start_pts]\n\n        # ---------- main growth loop ----------\n        for it in range(MaxIter):\n            if not attractors:\n                break\n\n            node_tree = build_rtree(nodes)\n\n            influences = [[] for _ in nodes]\n            to_remove  = set()\n\n            SenseR2 = SenseR * SenseR\n            KillR2  = KillR * KillR\n\n            # 1) assign attractors to nearby nodes via RTree\n            for ai, a in enumerate(attractors):\n                near_ids = neighbors(node_tree, a, SenseR)\n                if not near_ids:\n                    continue\n\n                nearest_i = None\n                nearest_d2 = None\n\n                for ni in near_ids:\n                    n = nodes[ni]\n                    d2 = n.pos.DistanceToSquared(a)\n\n                    # eat food if very close\n                    if d2 <= KillR2:\n                        to_remove.add(ai)\n                        nearest_i = None\n                        break\n\n                    if d2 <= SenseR2 and (nearest_d2 is None or d2 < nearest_d2):\n                        nearest_d2 = d2\n                        nearest_i = ni\n\n                if nearest_i is not None:\n                    influences[nearest_i].append(a - nodes[nearest_i].pos)\n\n            # 2) remove consumed attractors\n            if to_remove:\n                attractors = [a for idx, a in enumerate(attractors) if idx not in to_remove]\n                if not attractors:\n                    break\n\n            # 3) grow new nodes from influenced nodes (3D)\n            new_nodes = []\n            for ni, n in enumerate(nodes):\n                dirs = influences[ni]\n                if not dirs:\n                    continue\n\n                # average influence\n                vx = vy = vz = 0.0\n                for v in dirs:\n                    vx += v.X\n                    vy += v.Y\n                    vz += v.Z\n\n                length = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if length == 0.0:\n                    continue\n\n                vx /= length\n                vy /= length\n                vz /= length\n\n                # --- 3D jitter for organic branching ---\n                j = 0.2  # try 0.1â€“0.3\n                vx += random.uniform(-j, j)\n                vy += random.uniform(-j, j)\n                vz += random.uniform(-j, j)\n\n                length2 = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if length2 == 0.0:\n                    continue\n\n                vx /= length2\n                vy /= length2\n                vz /= length2\n\n                new_pos = Point3d(\n                    n.pos.X + vx * Step,\n                    n.pos.Y + vy * Step,\n                    n.pos.Z + vz * Step\n                )\n\n                child_index = len(nodes) + len(new_nodes)\n                new_nodes.append(Node(new_pos, ni))\n                Segments.append(Line(n.pos, new_pos))\n\n            if not new_nodes:\n                break\n\n            nodes.extend(new_nodes)\n\n        # outputs\n        Segments = [ln.ToNurbsCurve() for ln in Segments]\n        parent_ids = set(n.parent for n in nodes if n.parent >= 0)\n        Tips = [n.pos for i, n in enumerate(nodes) if i not in parent_ids]",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}