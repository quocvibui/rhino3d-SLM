{
  "source_url": "https://github.com/ZacZhangzhuo/3d_printing_teamwork/blob/1ae8e701e83329eb292170fc8bc483fa912b639b/skinPattern/combine.py",
  "repo": "ZacZhangzhuo/3d_printing_teamwork",
  "repo_stars": 1,
  "repo_description": "This is the 3D Printing teamwork repository of team 4 of MAS dfab 2023",
  "license": "MIT",
  "filepath": "skinPattern/combine.py",
  "instruction": "Combine",
  "code": "import Rhino.Geometry as rg\nimport random as r\nimport ghpythonlib as ghc\nfrom ghpythonlib import treehelpers as th\nfrom copy import deepcopy\nimport math\n\n\ndef OrientPlane(plane, guide):\n    yPt = plane.Origin + rg.Vector3d(0, 0, 1)\n    project = rg.Transform.ProjectAlong(plane, plane.ZAxis)\n    yPt.Transform(project)\n    yAxis = rg.Vector3d(yPt - plane.Origin)\n\n    zAxis = plane.ZAxis\n    if zAxis * guide < 0:\n        zAxis = -zAxis\n\n    outPlane = rg.Plane(plane.Origin, -rg.Vector3d.CrossProduct(zAxis, yAxis), yAxis)\n    return outPlane\n\n\ndef Remap(old_value, old_min, old_max, new_min, new_max):\n    # print('x')\n    # print (old_value)\n    new_value = (old_value - old_min) * (new_max - new_min) / (old_max - old_min) + new_min\n    # else\n    # print('y')\n    # print (new_value)\n    return new_value\n\n\ndef get_pts(crvs):\n\n    # Make into loop for list of curves\n    all_pts = []\n\n    crv = curve.ToNurbsCurve(curve.Domain)\n    # params = crv.DivideByCount(divide_number, True)\n\n    params = crv.DivideByCount(divide_number, True)\n    # print(len(params))\n\n    for i in params:\n        pt = crv.PointAt(i)\n        all_pts.append(pt)\n\n    return all_pts\n\n\ndef make_planes(pts):\n\n    pts_planes = []\n\n    # Make into loop for list of curves\n\n    for k, pt in enumerate(pts):\n\n        point, uv_pt, distance = ghc.components.SurfaceClosestPoint(pt, srf)\n\n        pnt, normal, u, v, f = ghc.components.EvaluateSurface(srf, uv_pt)\n\n        plane = rg.Plane(pt, rg.Vector3d(u), rg.Vector3d(v))\n        rg.Plane.Rotate(plane, math.radians(-90), plane.ZAxis, plane.Origin)\n\n        # halfLength = len(pts)/2\n        # rotation2 = rg.Transform.Rotation((((abs(halfLength-k))/halfLength)*-math.pi*0.5), plane.Normal, plane.Origin)\n        # rotation2 = rg.Transform.Rotation(((len(pts)-k)*math.pi/len(pts) + -math.pi*0.5), plane.Normal, plane.Origin)\n        # plane.Transform(rotation2)\n        pts_planes.append(plane)\n    return pts_planes\n\n\ndef move_planes(plns, height_pt,dir_pt, min_layer_height, max_layer_height, layer_number):\n\n    min_dist = 1000000\n    max_dist = 0\n\n    for pln in plns:\n        if height_pt.DistanceTo(pln.Origin) < min_dist:\n            min_dist = height_pt.DistanceTo(pln.Origin)\n        if height_pt.DistanceTo(pln.Origin) > max_dist:\n            max_dist = height_pt.DistanceTo(pln.Origin)\n\n    heights = []\n\n    for pln in plns:\n        #        print(pt.DistanceTo(pln.Origin))\n        temp = Remap(\n            height_pt.DistanceTo(pln.Origin), max_dist, min_dist, min_layer_height, max_layer_height\n        )\n        heights.append(temp)\n\n    #    print(max_dist)\n\n    moved_plns = []\n\n    for i in range(layer_number):\n        temp = []\n        for k, value in enumerate(heights):\n            origin = plns[k].Clone()\n\n            # Trans1.0\n            # trans1 = rg.Transform.Translation(rg.Vector3d(plns[k].Normal*heights[k]*i))\n\n            # Trans1.1\n            dir = rg.Vector3d(plns[k].Origin - dir_pt)\n            xyz = rg.Vector3d(1,1,1)\n            xyz.Unitize()\n            dir.Unitize()\n            trans1 = rg.Transform.Translation(((ratio * dir+ (1-ratio) * xyz) * heights[k] * i * graphMapper[int(Remap(heights[k] , min_dist,max_dist,0,len(heights)))]))\n\n            origin.Transform(trans1)\n            temp.append(origin)\n        if i%2 == 0: temp.reverse()\n        moved_plns.extend(temp)\n        # print (max_layer_height)\n\n    return moved_plns\n\n\n# def make_layered_planes(plns):\n\n#     if flip_vect:\n#         for i in range(len(plns)):\n#             plns[i] = rg.Plane(\n#                 plns[i].Origin, -plns[i].XAxis, plns[i].YAxis)\n#         # print (new_layer_height)\n#         # new_layer_height = -new_layer_height\n#         # print (new_layer_height)\n#     layered_planes = [plns]\n\n#     for l in range(layer_nbr):\n#         temp = []\n#         for i, p in enumerate(layered_planes[l]):\n#             layer_1 = deepcopy(p)\n#             trans2 = rg.Transform.Translation(\n#                 rg.Vector3d(p.Normal*layer_height))\n#             layer_1.Transform(trans2)\n#             temp.append(layer_1)\n\n#         temp.reverse()\n#         layered_planes.append(temp)\n\n#     return layered_planes\n\n# list_pts = th.tree_to_list(list_pts)\n# print(layer_height)\n# pts_divisions = (get_pts(curve))\n\npts_planes = make_planes(list_pts)\n# print (pts_planes)\n\nmoved_planes = move_planes(pts_planes, plns_height_pt, plns_dir_pt,min_layer_height, max_layer_height, layer_nbr)\n\n# layered_planes = th.list_to_tree(make_layered_planes(pts_planes))",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}