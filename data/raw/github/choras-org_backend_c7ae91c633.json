{
  "source_url": "https://github.com/choras-org/backend/blob/83981cdf4fc703fdcefe1b8c57625423a98db039/app/services/geometry_service.py",
  "repo": "choras-org/backend",
  "repo_stars": 6,
  "repo_description": "CHORAS backend",
  "license": "unknown",
  "filepath": "app/services/geometry_service.py",
  "instruction": "Geometry service",
  "code": "import logging\nimport math\nimport os\nimport zipfile\nimport math\n\nimport rhino3dm\nfrom flask_smorest import abort\n\nimport config\nfrom app.db import db\nfrom app.factory.geometry_converter_factory.GeometryConversionFactory import (\n    GeometryConversionFactory,\n)\nfrom app.models import File, Geometry, Task\nfrom app.types import Status, TaskType\n\n# Create logger for this module\nlogger = logging.getLogger(__name__)\n\n\ndef get_geometry_by_id(geometry_id):\n    results = Geometry.query.filter_by(id=geometry_id).first()\n    return results\n\n\ndef start_geometry_check_task(file_upload_id):\n    \"\"\"\n    This function is a wrapper over 3dm mapper. It creates a task and geometry given a file upload id.\n    Then calls the map_to_3dm function to map the given geometry file format to a rhino model.\n\n    :param file_upload_id: represents an id related to the uploaded file\n    :return: Geometry: returns an object of Geometry model corresponding to the uploaded file\n    \"\"\"\n    try:\n        task = Task(taskType=TaskType.GeometryCheck, status=Status.Created)\n        db.session.add(task)\n        db.session.commit()\n        geometry = Geometry(inputModelUploadId=file_upload_id, taskId=task.id)\n\n        db.session.add(geometry)\n        db.session.commit()\n\n        result = map_to_3dm_and_geo(geometry.id)\n        if not result:\n            task.status = Status.Error\n            task.message = \"An error is encountered during the geometry processing!\"\n            db.session.commit()\n            abort(500, task.message)\n\n        task.status = Status.Completed\n\n        db.session.commit()\n\n    except Exception as ex:\n        db.session.rollback()\n        task.status = Status.Error\n        task.message = \"An error is encountered during the geometry processing!\"\n        db.session.commit()\n        logger.error(f\"{task.message}: {ex}\")\n        abort(400, message=f\"Can not start the geometry task! Error: {ex}\")\n\n    return geometry\n\n\ndef get_geometry_result(task_id):\n    return Geometry.query.filter_by(taskId=task_id).first()\n\n\ndef map_to_3dm_and_geo(geometry_id):\n    geometry = Geometry.query.filter_by(id=geometry_id).first()\n    file = File.query.filter_by(id=geometry.inputModelUploadId).first()\n    task = Task.query.filter_by(id=geometry.taskId).first()\n\n    directory = config.DefaultConfig.UPLOAD_FOLDER\n    file_name, file_extension = os.path.splitext(os.path.basename(file.fileName))\n\n    obj_path = os.path.join(directory, file.fileName)\n    rhino3dm_path = os.path.join(directory, f\"{file_name}.3dm\")\n    zip_file_path = os.path.join(directory, f\"{file_name}.zip\")\n    geo_path = os.path.join(directory, f\"{file_name}.geo\")\n\n    try:\n        task.status = Status.InProgress\n        db.session.commit()\n    except Exception as ex:\n        db.session.rollback()\n        logger.error(f\"Can not update task status! Error: {ex}\")\n\n    # Use the new process method to handle both cleaning and conversion\n    conversion_factory = GeometryConversionFactory()\n\n    conversion_strategy = conversion_factory.create_strategy(file_extension)\n\n    if not conversion_strategy.generate_3dm(obj_path, rhino3dm_path):\n        return False\n\n    if not os.path.exists(rhino3dm_path):\n        logger.error(\"Can not find created a rhino file\")\n        return False\n\n    try:\n        file3dm = File(fileName=f\"{file_name}.3dm\")\n        db.session.add(file3dm)\n        db.session.commit()\n\n        geometry.outputModelId = file3dm.id\n\n        # Create a zip file from 3dm\n        with zipfile.ZipFile(zip_file_path, \"w\") as zipf:\n            zipf.write(rhino3dm_path, arcname=f\"{file_name}.3dm\")\n\n        db.session.commit()\n    except Exception as ex:\n        db.session.rollback()\n        logger.error(f\"Can not create a rhino file: {ex}\")\n        return False\n\n    if config.FeatureToggle.is_enabled(\"enable_geo_conversion\"):\n        try:\n            if not obj_to_gmsh_geo_precise(obj_path, geo_path, rhino3dm_path):\n                logger.error(\"Can not generate a geo file\")\n                return False\n\n            file_geo = File(fileName=f\"{file_name}.geo\")\n            db.session.add(file_geo)\n            db.session.commit()\n\n        except Exception as ex:\n            db.session.rollback()\n            logger.error(f\"Can not attach a geo file: {ex}\")\n            return False\n\n    return True\n\n\ndef convert_3dm_to_geo(\n    rhino_file_path, geo_file_path, volume_name=\"RoomVolume\", map_materials=True\n):  # noqa: C901\n    \"\"\"\n    Converts a Rhino 3DM file to a Gmsh GEO file with proper material mapping.\n\n    Args:\n        rhino_file_path: Path to the Rhino 3dm file\n        geo_file_path: Path to output the geo file\n        volume_name: Name for the Physical Volume (default: \"RoomVolume\")\n        map_materials: Whether to map materials from the 3dm file (default: True)\n\n    Returns:\n        bool: True if successful, False otherwise\n    \"\"\"\n    \"\"\"\n    Converts a Rhino 3DM file to a Gmsh GEO file with proper material mapping.\n\n    Args:\n        rhino_file_path: Path to the Rhino 3dm file\n        geo_file_path: Path to output the geo file\n        volume_name: Name for the Physical Volume (default: \"RoomVolume\")\n        map_materials: Whether to map materials from the 3dm file (default: True)\n\n    Returns:\n        bool: True if successful, False otherwise\n    \"\"\"\n    model = rhino3dm.File3dm.Read(rhino_file_path)\n\n    # Structures to hold .geo elements\n    points = {}\n    edges = set()  # Just collect unique edges first\n    line_loops = {}\n    plane_surfaces = {}\n    physical_surfaces = {}\n\n    # Helper tracking\n    coord_to_point_index = {}\n    face_to_edges = {}  # Maps face index to its edges\n\n    # Material mapping for later use if map_materials is True\n    material_name_to_ids = {}\n    if map_materials:\n        material_to_id = {}\n        for obj in model.Objects:\n            if isinstance(obj.Geometry, rhino3dm.Mesh):\n                material_name = obj.Geometry.GetUserString(\"material_name\")\n                if material_name:\n                    material_to_id[f\"{obj.Attributes.Id}\"] = material_name\n\n        # Reverse the mapping to be from material name to list of IDs\n        for id, material_name in material_to_id.items():\n            if material_name not in material_name_to_ids:\n                material_name_to_ids[material_name] = []\n            material_name_to_ids[material_name].append(id)\n\n    point_index = 1\n    surface_index = 1\n\n    # Maps to store material/layer assignments\n    object_to_material = {}\n    material_to_surfaces = {}\n    obj_id_to_surfaces = {}  # Track surfaces by object ID for material mapping\n\n    # First pass: Identify materials/layers\n    for obj in model.Objects:\n        if not isinstance(obj.Geometry, rhino3dm.Mesh):\n            continue\n\n        # Material assignment logic - try to use these strategies in order:\n        # 1. Material index (if available)\n        # 2. Layer index (if available)\n        # 3. Default to M_1\n        if obj.Attributes.MaterialIndex > 0:\n            material_id = f\"M_{obj.Attributes.MaterialIndex}\"\n        elif obj.Attributes.LayerIndex > 0:\n            material_id = f\"M_{obj.Attributes.LayerIndex}\"\n        else:\n            material_id = \"M_1\"\n\n        object_to_material[obj.Attributes.Id] = material_id\n\n        if material_id not in material_to_surfaces:\n            material_to_surfaces[material_id] = []\n\n        # Initialize tracking for this object's surfaces\n        obj_id_to_surfaces[obj.Attributes.Id] = []\n\n    # Second pass: Process geometry\n    for obj in model.Objects:\n        if not isinstance(obj.Geometry, rhino3dm.Mesh):\n            continue\n\n        mesh = obj.Geometry\n        mesh.Faces.ConvertTrianglesToQuads(0.5, 0)\n        mesh.Vertices.CombineIdentical(True, True)\n        vertices = mesh.Vertices\n        faces = mesh.Faces\n\n        vertex_map = {}  # Maps mesh vertex index to Gmsh point index\n\n        for i, vertex in enumerate(vertices):\n\n            def format_coord(value):\n                return f\"{round(value, 6):.6f}\"\n\n            rounded_x = format_coord(vertex.X)\n            rounded_y = format_coord(vertex.Y)\n            rounded_z = format_coord(vertex.Z)\n\n            coord = (rounded_x, rounded_y, rounded_z)\n            if coord not in coord_to_point_index:\n                points[point_index] = (\n                    f\"Point({point_index}) = {{ {rounded_x}, {rounded_y}, {rounded_z}, 1.0 }};\\n\"\n                )\n                coord_to_point_index[coord] = point_index\n                point_index += 1\n            vertex_map[i] = coord_to_point_index[coord]\n\n        # Collect surfaces and edges per object\n        object_surface_indices = []\n\n        for i in range(faces.Count):\n            face = faces[i]\n\n            # Get face indices based on face type (triangle or quad)\n            face_indices = (\n                [face[0], face[1], face[2], face[3]]\n                if len(face) == 4\n                else [face[0], face[1], face[2]] if len(face) == 3 else None\n            )\n            if not face_indices:\n                continue  # Skip non-triangle/quad faces\n\n            # Collect the edges for this face\n            face_edges = []\n            face_vertices = []\n\n            # First collect all vertices in order\n            for j in range(len(face_indices)):\n                vertex_idx = vertex_map[face_indices[j]]\n                face_vertices.append(vertex_idx)\n\n            # Then create edges from consecutive vertices\n            for j in range(len(face_vertices)):\n                a = face_vertices[j]\n                b = face_vertices[(j + 1) % len(face_vertices)]\n\n                # Prevent self-referential edges\n                if a == b:\n                    continue\n\n                # Store the edge with direction for line loops\n                face_edges.append((a, b))\n\n                # Also store unique edges for line creation\n                edge = tuple(sorted([a, b]))\n                edges.add(edge)\n\n            # Store the face edges for later line loop creation\n            face_to_edges[surface_index] = face_edges\n\n            # Add to material surface list\n            material_id = object_to_material[obj.Attributes.Id]\n            material_to_surfaces[material_id].append(surface_index)\n\n            # Also track by object ID for material mapping\n            obj_id_to_surfaces[obj.Attributes.Id].append(surface_index)\n\n            object_surface_indices.append(surface_index)\n            surface_index += 1\n\n    # Create lines in a predictable order after collecting all edges\n    lines = {}\n    edge_to_line_index = {}\n    physical_lines = []\n\n    line_index = 1\n    for edge in sorted(edges):  # Sort edges for consistent ordering\n        a, b = edge\n        # Skip self-referential lines\n        if a == b:\n            continue\n        lines[line_index] = f\"Line({line_index}) = {{ {a}, {b} }};\\n\"\n        edge_to_line_index[edge] = line_index\n        physical_lines.append(line_index)\n        line_index += 1\n\n    # Now create line loops using the line indices\n    for face_idx, face_edges in face_to_edges.items():\n        # Skip faces with no edges or less than 3 edges\n        if not face_edges or len(face_edges) < 3:\n            continue\n\n        # Extract ordered vertices from face edges\n        edge_vertices = []\n        for a, b in face_edges:\n            if not edge_vertices:\n                edge_vertices.extend([a, b])\n            else:\n                # Ensure the next edge continues from the last vertex\n                if edge_vertices[-1] == a:\n                    edge_vertices.append(b)\n                elif edge_vertices[-1] == b:\n                    edge_vertices.append(a)\n                else:\n                    # If not connected, try to insert at the beginning\n                    if edge_vertices[0] == a:\n                        edge_vertices.insert(0, b)\n                    elif edge_vertices[0] == b:\n                        edge_vertices.insert(0, a)\n                    else:\n                        print(\n                            f\"Warning: Disconnected edge ({a},{b}) in face {face_idx}\"\n                        )\n\n        # Ensure the loop is closed\n        if len(edge_vertices) > 1 and edge_vertices[0] != edge_vertices[-1]:\n            face_edges.append((edge_vertices[-1], edge_vertices[0]))\n\n        # Create line loop with correct line directions\n        line_loop_indices = []\n        for i in range(len(edge_vertices) - 1):\n            a = edge_vertices[i]\n            b = edge_vertices[i + 1]\n\n            # Skip self-referential edges\n            if a == b:\n                continue\n\n            sorted_edge = tuple(sorted([a, b]))\n            if sorted_edge not in edge_to_line_index:\n                continue\n\n            line_idx = edge_to_line_index[sorted_edge]\n\n            # Check if direction matches\n            if (a, b) != sorted_edge:\n                line_idx = -line_idx  # Negative for reverse direction\n\n            line_loop_indices.append(line_idx)\n\n        # Skip if we don't have enough lines to form a loop\n        if len(line_loop_indices) < 3:\n            continue\n\n        # Format line loop with correct spacing to match example\n        line_loops[face_idx] = (\n            f\"Line Loop({face_idx}) = {{ {', '.join(map(str, line_loop_indices))} }};\\n\"\n        )\n        plane_surfaces[face_idx] = f\"Plane Surface({face_idx}) = {{ {face_idx} }};\\n\"\n\n    # Create physical surfaces groups\n    if map_materials and material_name_to_ids:\n        # If mapping materials, create physical surfaces based on material names\n        for obj_id, surfaces in obj_id_to_surfaces.items():\n            if surfaces:\n                physical_surfaces[obj_id] = (\n                    f\"Physical Surface(\\\"{obj_id}\\\") = {{ {', '.join(map(str, surfaces))} }};\\n\"\n                )\n    else:\n        # Otherwise use the material/layer based groups\n        for material_id, surface_list in material_to_surfaces.items():\n            if surface_list:\n                physical_surfaces[material_id] = (\n                    f\"Physical Surface(\\\"{material_id}\\\") = {{ {', '.join(map(str, surface_list))} }};\\n\"\n                )\n\n    # Write to .geo file\n    with open(geo_file_path, \"w\") as geo_file:\n        # Write points first\n        for idx in sorted(points):\n            geo_file.write(points[idx])\n        geo_file.write(\"\\n\")\n\n        # Write lines\n        for idx in sorted(lines):\n            geo_file.write(lines[idx])\n        geo_file.write(\"\\n\")\n\n        # Write line loops\n        for idx in sorted(line_loops):\n            geo_file.write(line_loops[idx])\n        geo_file.write(\"\\n\")\n\n        # Write plane surfaces\n        for idx in sorted(plane_surfaces):\n            geo_file.write(plane_surfaces[idx])\n        geo_file.write(\"\\n\")\n\n        # Write Surface Loop and Volume with custom volume name\n        surface_ids = sorted(plane_surfaces.keys())\n        geo_file.write(f\"Surface Loop(1) = {{ {', '.join(map(str, surface_ids))} }};\\n\")\n\n        # Write Physical Surface definitions\n        for ps in physical_surfaces.values():\n            geo_file.write(ps)\n\n        geo_file.write(\"Volume( 1 ) = { 1 };\\n\")\n        geo_file.write(f'Physical Volume(\"{volume_name}\") = {{ 1 }};\\n')\n\n        # Add Physical Line group\n        geo_file.write(\n            f'Physical Line (\"default\") = {{{\", \".join(map(str, physical_lines))}}};\\n'\n        )\n\n        # Write mesh parameters at the end\n        geo_file.write(\"Mesh.Algorithm = 6;\\n\")\n        geo_file.write(\n            \"Mesh.Algorithm3D = 1; // Delaunay3D, works for boundary layer insertion.\\n\"\n        )\n        geo_file.write(\n            \"Mesh.Optimize = 1; // Gmsh smoother, works with boundary layers (netgen version does not).\\n\"\n        )\n        geo_file.write(\"Mesh.CharacteristicLengthFromPoints = 1;\\n\")\n        geo_file.write('// Recombine Surface \"*\";\\n')\n        geo_file.write(\"Mesh.RemeshAlgorithm = 1; // automatic\\n\")\n\n    print(f\"Converted {rhino_file_path} to {geo_file_path}\")\n    return os.path.exists(geo_file_path)\n\ndef obj_to_gmsh_geo_precise(obj_file, geo_file, rhino3dm_path, volume_name=\"RoomVolume\", tol=1e-8):\n    \"\"\"\n    Parse OBJ preserving groups, deduplicate vertices, merge triangle pairs into quads,\n    create Lines with consistent orientation and Line Loops with signed line indices,\n    and write a Gmsh .geo with Physical Surface groups.\n    \"\"\"\n\n    # Obtain material indices from rhino\n    model = rhino3dm.File3dm.Read(rhino3dm_path)\n\n    # Material mapping for later use if map_materials is True\n    material_name_to_ids = {}\n    material_to_id = {}\n    for obj in model.Objects:\n        if isinstance(obj.Geometry, rhino3dm.Mesh):\n            material_name = obj.Geometry.GetUserString(\"material_name\")\n            if material_name:\n                material_to_id[f\"{obj.Attributes.Id}\"] = material_name\n\n    # Reverse the mapping to be from material name to list of IDs\n    for id, material_name in material_to_id.items():\n        if material_name not in material_name_to_ids:\n            material_name_to_ids[material_name] = []\n        material_name_to_ids[material_name].append(id)\n\n    # --- Parse OBJ ---\n    vertices = []          # original vertex coordinates (1-based in OBJ)\n    faces = []             # list of faces: list of vertex indices (1-based)\n    face_groups = []       # group name for each face\n    current_group = \"default\"\n\n    with open(obj_file, \"r\") as f:\n        for raw in f:\n            line = raw.strip()\n            if not line:\n                continue\n            if line.startswith('v '):\n                parts = line.split()\n                x, y, z = map(float, parts[1:4])\n                # Convert from SketchUp (Y-up, left-handed) to Gmsh (right-handed)\n                # Flip the Z axis to correct mirroring\n                coords = (x, -z, y)\n                #coords = (float(parts[1]), float(parts[2]), float(parts[3]))\n                vertices.append(coords)\n            elif line.startswith('g '):\n                parts = line.split()[1:]  # skip 'g'\n                # If first token starts with 'Mesh', skip it\n                parts = [p for p in parts if not p.startswith(\"Mesh\") and not p.startswith(\"Model\")]\n                current_group = parts[0] if parts else \"default\"\n            elif line.startswith('usemtl'):  # Material-based grouping\n                parts = line.split()[1:]\n                # Materials also act as groups\n                current_group = parts[0] if parts else \"default\"\n            elif line.startswith('f '):\n                parts = line.split()[1:]\n                # face vertex indices (OBJ format may include v/vt/vn)\n                idxs = [int(p.split('/')[0]) for p in parts]\n                faces.append(idxs)\n                face_groups.append(current_group)\n\n    # --- Deduplicate vertices (preserve order) ---\n    unique_vertices = []\n    orig_to_unique = {}  # map from original index (1-based) -> unique index (1-based)\n    for i, v in enumerate(vertices, start=1):\n        # find existing within tolerance\n        found = None\n        for j, uv in enumerate(unique_vertices, start=1):\n            if abs(uv[0] - v[0]) < tol and abs(uv[1] - v[1]) < tol and abs(uv[2] - v[2]) < tol:\n                found = j\n                break\n        if found is None:\n            unique_vertices.append(v)\n            orig_to_unique[i] = len(unique_vertices)\n        else:\n            orig_to_unique[i] = found\n            \n    # remap faces to unique vertex indices\n    faces_mapped = [[orig_to_unique[i] for i in face] for face in faces]\n    \n    # --- Sort vertices deterministically (like Meshkit) --- \n    unique_vertices_sorted = sorted(\n        enumerate(unique_vertices, start=1),\n        key=lambda kv: (round(kv[1][0], 8), \n                        round(kv[1][1], 8),\n                        round(kv[1][2], 8)) \n        ) \n    index_map = {old: new for new, (old, _) in enumerate(unique_vertices_sorted, start=1)} \n    unique_vertices = [v for _, v in unique_vertices_sorted] \n    faces_mapped = [[index_map[i] for i in face] for face in faces_mapped]\n\n\n    # --- Merge pairs of triangles within same group into quads when possible ---\n    nfaces = len(faces_mapped)\n    merged_flag = [False] * nfaces\n    merged_faces = []      # list of faces (each is 3 or 4 vertex indices, in CCW order)\n    merged_groups = []\n\n    # helper: get coords by unique index (1-based)\n    def coords(idx):\n        return unique_vertices[idx - 1]\n\n    for i in range(nfaces):\n        if merged_flag[i]:\n            continue\n        fi = faces_mapped[i]\n        gi = face_groups[i]\n        if len(fi) == 3:\n            # try to find a partner triangle in same group sharing 2 vertices\n            partner = None\n            for j in range(i + 1, nfaces):\n                if merged_flag[j]:\n                    continue\n                if face_groups[j] != gi:\n                    continue\n                fj = faces_mapped[j]\n                if len(fj) != 3:\n                    continue\n                shared = set(fi) & set(fj)\n                if len(shared) == 2:\n                    partner = j\n                    break\n            if partner is not None:\n                # build quad from union of vertices (4 vertices)\n                union = list(dict.fromkeys(fi + faces_mapped[partner]))  # preserve order somewhat\n                if len(union) == 4:\n                    # order the 4 vertices into a planar loop consistently\n                    pts = [coords(idx) for idx in union]\n                    # compute plane normal using first triangle\n                    v0 = pts[0]\n                    v1 = pts[1]\n                    v2 = pts[2]\n                    nx = (v1[1] - v0[1]) * (v2[2] - v0[2]) - (v1[2] - v0[2]) * (v2[1] - v0[1])\n                    ny = (v1[2] - v0[2]) * (v2[0] - v0[0]) - (v1[0] - v0[0]) * (v2[2] - v0[2])\n                    nz = (v1[0] - v0[0]) * (v2[1] - v0[1]) - (v1[1] - v0[1]) * (v2[0] - v0[0])\n                    an = (abs(nx), abs(ny), abs(nz))\n                    # choose projection plane by largest normal component\n                    if an[2] >= an[0] and an[2] >= an[1]:\n                        # project to XY\n                        proj = lambda p: (p[0], p[1])\n                    elif an[1] >= an[0] and an[1] >= an[2]:\n                        # project to XZ\n                        proj = lambda p: (p[0], p[2])\n                    else:\n                        # project to YZ\n                        proj = lambda p: (p[1], p[2])\n\n                    uv = [proj(coords(idx)) for idx in union]\n                    cx = sum(pt[0] for pt in uv) / 4.0\n                    cy = sum(pt[1] for pt in uv) / 4.0\n                    angles = [math.atan2(pt[1] - cy, pt[0] - cx) for pt in uv]\n                    # sort union vertices by angle\n                    union_ordered = [x for _, x in sorted(zip(angles, union))]\n                    merged_faces.append(union_ordered)\n                    merged_groups.append(gi)\n                    merged_flag[i] = True\n                    merged_flag[partner] = True\n                    continue\n                # if union not 4, fallthrough to keep triangle\n            # no partner found => keep triangle\n            merged_faces.append(fi)\n            merged_groups.append(gi)\n            merged_flag[i] = True\n        else:\n            # non-triangle face: keep as-is (maybe quad)\n            merged_faces.append(fi)\n            merged_groups.append(gi)\n            merged_flag[i] = True\n\n    # There may be faces leftover (if any not processed): ensure all covered\n    for k in range(nfaces):\n        if not merged_flag[k]:\n            merged_faces.append(faces_mapped[k])\n            merged_groups.append(face_groups[k])\n            \n    tag_to_surfaces = {}\n    for sid, tag in enumerate(merged_groups, start=1):\n        tag_to_surfaces.setdefault(tag, []).append(sid)\n \n    # # --- Orientation normalization (ensure CCW) --- \n    # def is_ccw(face): \n    #     pts = [unique_vertices[i - 1] for i in face] \n    #     v1, v2, v3 = pts[:3] \n    #     nx = (v2[1]-v1[1])*(v3[2]-v1[2]) - (v2[2]-v1[2])*(v3[1]-v1[1]) \n    #     ny = (v2[2]-v1[2])*(v3[0]-v1[0]) - (v2[0]-v1[0])*(v3[2]-v1[2]) \n    #     nz = (v2[0]-v1[0])*(v3[1]-v1[1]) - (v2[1]-v1[1])*(v3[0]-v1[0]) \n    #     return nz >= 0 \n    \n    # for face in merged_faces: \n    #     if not is_ccw(face): \n    #         face.reverse()\n    \n    room_center = tuple(\n        sum(v[i] for v in unique_vertices) / len(unique_vertices)\n        for i in range(3)\n    )\n\n    \n    def is_outward_facing(face):\n        pts = [unique_vertices[i - 1] for i in face]\n        v1, v2, v3 = pts[:3]\n        # Face normal\n        nx = (v2[1]-v1[1])*(v3[2]-v1[2]) - (v2[2]-v1[2])*(v3[1]-v1[1])\n        ny = (v2[2]-v1[2])*(v3[0]-v1[0]) - (v2[0]-v1[0])*(v3[2]-v1[2])\n        nz = (v2[0]-v1[0])*(v3[1]-v1[1]) - (v2[1]-v1[1])*(v3[0]-v1[0])\n        normal = (nx, ny, nz)\n        # Face centroid\n        cx, cy, cz = tuple(sum(p[i] for p in pts) / len(pts) for i in range(3))\n        # Vector from centroid to room center\n        to_center = (\n            room_center[0] - cx,\n            room_center[1] - cy,\n            room_center[2] - cz\n        )\n        # Dot product: if negative, normal points outward\n        dot = sum(normal[i] * to_center[i] for i in range(3))\n        return dot < 0\n    \n    for face in merged_faces:\n        if not is_outward_facing(face):\n            face.reverse()\n\n\n\n    # --- Build unique edges (lines) with stable orientation ---\n    edge_to_line = {}       # key = (min,max) -> line_id\n    line_orientation = {}   # line_id -> (a,b) orientation used when created\n    next_line_id = 1\n\n    # collect edges from merged faces in consistent order\n    face_line_loops = []  # list of lists of signed line indices (to write)\n    for face in merged_faces:\n        n = len(face)\n        loop_line_ids = []\n        for idx in range(n):\n            a = face[idx]\n            b = face[(idx + 1) % n]\n            key = (a, b) if a < b else (b, a)\n            if key not in edge_to_line:\n                edge_to_line[key] = next_line_id\n                # store orientation as the first encountered direction (a,b)\n                if key == (a, b):\n                    line_orientation[next_line_id] = (a, b)\n                else:\n                    line_orientation[next_line_id] = (b, a)\n                next_line_id += 1\n            lid = edge_to_line[key]\n            # determine sign: +if orientation matches (a,b), - otherwise\n            ori = line_orientation[lid]\n            if ori == (a, b):\n                loop_line_ids.append(lid)\n            else:\n                loop_line_ids.append(-lid)\n        face_line_loops.append(loop_line_ids)\n\n    # --- Now write the GEO file ---\n    with open(geo_file, \"w\") as g:\n        # Points\n        for i, v in enumerate(unique_vertices, start=1):\n            g.write(f\"Point({i}) = {{ {v[0]}, {v[1]}, {v[2]}, 1.0 }};\\n\")\n        g.write(\"\\n\")\n\n        # Lines (must write using stored orientation endpoints)\n        # We need to output unique edge list, using the stored orientation endpoints\n        # Build a mapping of line_id -> endpoints\n        line_id_to_endpoints = {}\n        for key, lid in edge_to_line.items():\n            # endpoints should be line_orientation[lid]\n            a, b = line_orientation[lid]\n            line_id_to_endpoints[lid] = (a, b)\n\n        # Write lines in increasing id order\n        for lid in range(1, next_line_id):\n            a, b = line_id_to_endpoints[lid]\n            g.write(f\"Line({lid}) = {{ {a}, {b} }};\\n\")\n        g.write(\"\\n\")\n\n        # Line Loops\n        for sid, loop in enumerate(face_line_loops, start=1):\n            loop_str = \", \".join(str(x) for x in loop)\n            g.write(f\"Line Loop({sid}) = {{ {loop_str} }};\\n\")\n        g.write(\"\\n\")\n\n        # Plane surfaces\n        for sid, loop in enumerate(face_line_loops, start=1):\n            g.write(f\"Plane Surface({sid}) = {{ {sid} }};\\n\")\n        g.write(\"\\n\")\n\n        # Surface Loop and Volume\n        total_surfaces = len(face_line_loops)\n        surf_list = \", \".join(str(i) for i in range(1, total_surfaces + 1))\n        g.write(f\"Surface Loop(1) = {{ {surf_list} }};\\n\")\n\n        # Physical Surface groups by OBJ group name\n        # unique_groups = []\n        # for grp in merged_groups:\n        #     if grp not in unique_groups:\n        #         unique_groups.append(grp)\n        # # for grp in unique_groups:\n        # #     surf_ids = [str(i + 1) for i, gname in enumerate(merged_groups) if gname == grp]\n        # #     if surf_ids:\n        # #         g.write(f'Physical Surface(\"{grp}\") = {{ {\", \".join(surf_ids)} }};\\n')\n\n        ii = 1\n        for grp in material_to_id:\n            g.write(f'Physical Surface(\"{grp}\") = {{ { str(ii) } }};\\n')\n            ii = ii + 1\n\n        g.write(\"Volume(1) = { 1 };\\n\")\n        g.write(f'Physical Volume(\"{volume_name}\") = {{ 1 }};\\n')\n\n        # Physical Line (all lines)\n        lines_all = \", \".join(str(i) for i in range(1, next_line_id))\n        g.write(f'Physical Line(\"default\") = {{ {lines_all} }};\\n')\n\n        g.write('Mesh.Algorithm = 6;\\n')\n        g.write('Mesh.Algorithm3D = 1; // Delaunay3D, works for boundary layer insertion.\\n')\n        g.write('Mesh.Optimize = 1; // Gmsh smoother, works with boundary layers (netgen version does not).\\n')\n        g.write('Mesh.CharacteristicLengthFromPoints = 1;\\n')\n        g.write('// Recombine Surface \"*\";\\n')\n\n    print(f\"Wrote {geo_file}: {len(unique_vertices)} points, {next_line_id-1} lines, {len(face_line_loops)} surfaces.\")\n    return True\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}