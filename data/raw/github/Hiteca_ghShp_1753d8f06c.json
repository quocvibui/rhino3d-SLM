{
  "source_url": "https://github.com/Hiteca/ghShp/blob/2ac0247af55139b7ed7b3e8d188ddedbf40b6590/source/ghshp_import.py",
  "repo": "Hiteca/ghShp",
  "repo_stars": 7,
  "repo_description": "Grasshopper component to read and write ESRI Shapefile :earth_asia:",
  "license": "unknown",
  "filepath": "source/ghshp_import.py",
  "instruction": "Component to import geometry and data from ESRI Shapefile.",
  "code": "# -*- coding: utf-8 -*-\n\n# Source code available at https://github.com/hiteca\n\n\"\"\"\nComponent to import geometry and data from ESRI Shapefile.\n\n    Args:\n        path: Path to .shp file\n        read_geometry: [bool, optional] Toggle to read geometry.\n                        Default - True.\n        read_records: [bool, optional] Toggle to read data.\n                        Default - True.\n        field_ids: List of data column to read. \n                    Default - read all columns.\n        enc: File encoding. \n                Default - utf-8\n    Returns:\n        shape_type: pyShp shape type (1 - point, 3 - polyline, 5 - polygon...). See full list at https://github.com/GeospatialPython/pyshp\n        geometry: Imported geometry from shp. Each shape is in own branch\n        fields: List of fields (format - \"name|type|length\")\n        field_names: List of field names\n        records: Data rows. Each row in own branch\n\"\"\"\nghenv.Component.Name = \"Shapefile Import\"\nghenv.Component.NickName = 'Shp Import'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.icon\nghenv.Component.Category = \"Extra\"\nghenv.Component.SubCategory = \"Hiteca\"\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"2\"\nexcept: pass\n\n\nimport System\nimport clr\nclr.AddReference(\"Grasshopper\")\nfrom Grasshopper.Kernel.Data import GH_Path\nfrom Grasshopper import DataTree\n\nimport Grasshopper.Kernel as gh\n\nwe = gh.GH_RuntimeMessageLevel.Error\nww = gh.GH_RuntimeMessageLevel.Warning\n\ntry:\n    import shapefile\nexcept:\n    message = \"Python module 'pyshp' not found. Please download it and install to Rhino IronPython folder using manual at https://github.com/hiteca/ghshp\"\n    ghenv.Component.AddRuntimeMessage(we, message)\n    message = \"https://github.com/hiteca/ghshp#install-pyshp\"\n    ghenv.Component.AddRuntimeMessage(we, message)\n\nimport Rhino as rc\n\ndef list2branch(source_tree,data,item_index,data_path):\n    _p = GH_Path(data_path).AppendElement(item_index)\n    for i in range(len(data)):\n        _data = data[i]\n        if type(_data) == list:\n            soruce_tree = v2branch(source_tree,_data,i,_p)\n        else:\n            source_tree.AddRange([_data],GH_Path(_p))\n    return source_tree\n    \n\ndef py_tree(source_tree, reverse=False, default=None):\n    if not reverse:\n        result = {}\n        for i in range(len(source_tree.Branches)):\n            d = source_tree.Branches[i]\n            p = GH_Path(source_tree.Paths[i])\n            \n            result[p] = list(d)\n        if len(result.keys())==0:\n            result[GH_Path(0)] = [default]\n    else:\n        result = DataTree[System.Object]()\n        for p in source_tree.keys():\n            d = source_tree[p]\n            _d = []\n            for j in range(len(d)):\n                data = d[j]\n                if type(data) == list:\n                    result = list2branch(result,data,j,p)\n                else:\n                    _d.append(data)\n            if len(_d) > 0:\n                result.AddRange(_d,p)\n                \n    return result\n\ndef repeat_latest(data,length):\n    if len(data) > length:\n        return data[:length]\n    else:\n        return data + ([data[-1]] * (length - len(data)))\n\ndef graft_tree(t):\n    r = {}\n    for k,v in t.items():\n        for i in range(len(v)):\n            r[GH_Path(k).AppendElement(i)] = [v[i]]\n    return r\n    \ndef longest_list(t_a,t_b):\n    r_b = {}\n    r_a = {}\n    prev_a = t_a.items()[0][1]\n    prev_b = t_b.items()[0][1]\n    \n    if len(t_a) >= len(t_b):\n        keys = t_a.keys()\n    else:\n        keys = t_b.keys()\n\n    keys = sorted(keys, key=lambda x: str(GH_Path(x)))\n\n    for k in keys:\n        try:\n            branch_a = t_a[k]\n            prev_a = t_a[k]\n        except:\n            branch_a = prev_a\n        try:\n            branch_b = t_b[k]\n            prev_b = t_b[k]\n        except:\n            branch_b = prev_b\n        max_len = max(len(branch_b),len(branch_a))\n        if len(branch_b) >= len(branch_a):\n            branch_a = repeat_latest(branch_a, len(branch_b))\n        else:\n            branch_b = repeat_latest(branch_b, len(branch_a))\n        r_a[k] = branch_a\n        r_b[k] = branch_b\n        \n    return(r_a,r_b)\n\n\nshape_types = {\n    \"point\" : [\n        1, #POINT\n        8, #MULTIPOINT\n        11, #POINTZ\n        18, #MULTIPOINTZ\n        21, #POINTM\n        28, #MULTIPOINTM\n    ],\n    \"polyline\": [\n        3, #POLYLINE\n        5, #POLYGON\n        13, #POLYLINEZ\n        15, #POLYGONZ\n        23, #POLYLINEM\n        25, #POLYGONM\n        31, #MULTIPATCH\n    ]\n}\n\ndef find_type(t):\n    for k in shape_types.keys():        \n        if t in shape_types[k]:\n            return k\n            \n\ndef list2point(pt):\n    pt = list(pt)\n    if len(pt)==2:\n        pt.append(0)\n    return rc.Geometry.Point3d(pt[0],pt[1],pt[2])\n    \ndef read_shapefile(file_path, read_data=True, read_geom=True, enc=\"utf-8\"):\n    result_geom = []\n    result_fields = []\n    result_field_names = []\n    result_records = []\n    if read_data or read_geom:\n        sf = shapefile.Reader(file_path)\n        sf_type = find_type(sf.shapeType)\n        # вывод полей\n        if read_data:\n            shpfields = sf.fields\n            shprecords = sf.records()\n            f = 0\n            if str(sf.fields[0][0]).startswith(\"DeletionFlag\"):\n                shpfields.pop(0) # remove DeletionFlag field\n\n            for i in range(len(shpfields)):\n                _shpfields = shpfields[i]\n                _field = _shpfields[0]\n                _field_type = _shpfields[1]\n                _field_len = _shpfields[2]\n                _field_len2 = _shpfields[3]\n                _field = _field.decode(enc, errors=\"replace\")\n                \n                result_field_names.append(_field)\n                field = \"%s;%s;%d;%d\" % (_field,_field_type,_field_len,_field_len2)\n                result_fields.append(field)\n                \n        #вывод полилиний и данных\n        shapes = sf.shapes()\n        \n\n        for i in range(len(shapes)):\n            path = GH_Path(i)\n\n            #считывание геометрии\n            if read_geom:\n                shape = shapes[i]\n                #разделение на части\n    \n                if sf_type == \"point\":\n                    parts = shape.points\n                    pt_list = []\n                    for p in range(len(parts)):\n                        pt = list(parts[p])\n                        pt_list.append(list2point(pt))\n                    result_geom.append(pt_list)\n                else:\n                    parts = shape.parts\n                    parts2 = parts[:] # copy\n                    parts2.append(len(shape.points))\n                    part = []\n                    for p in range(len(parts)):\n                        points = []\n                        _p = p + 1\n                        for n in range(len(shape.points)):\n                            if(n<parts2[_p] and n>=parts2[p]):\n                                pt = shape.points[n]\n                                points.append(list2point(pt))\n                        \n                        polylinecurve = rc.Geometry.PolylineCurve(points)\n                        part.append(polylinecurve)\n                    result_geom.append(part)\n            \n            if read_records:\n                rec = shprecords[i]\n                _result_records = []\n                for r in range(len(sf.fields)):\n                    if str(sf.fields[0][0]).startswith(\"DeletionFlag\") and r==0:\n                        continue\n                    record = rec[r]\n                    if(isinstance(record, str)):\n                        record = record.decode(enc, errors=\"replace\")\n                    _result_records.append(record)\n                result_records.append(_result_records)\n                    \n    return [sf.shapeType], result_geom, result_fields, result_field_names, result_records\n\n\npath =py_tree(path)\nif len(path.keys())==0:\n    message = \"Specify .shp file path\"\n    ghenv.Component.AddRuntimeMessage(ww, message)\nelse:\n    read_geometry =py_tree(read_geometry, default=True)\n    read_records =py_tree(read_records, default=True)\n    enc =py_tree(enc, default=\"utf-8\")\n    \n    _path, read_geometry = longest_list(path,read_geometry)\n    _path, read_records = longest_list(path,read_records)\n    _path, enc = longest_list(path,enc)\n    \n    path = graft_tree(path)\n    read_geometry = graft_tree(read_geometry)\n    read_records = graft_tree(read_records)\n    enc = graft_tree(enc)\n    \n    out_shapeType = {}\n    out_geometry = {}\n    out_fields = {}\n    out_field_names = {}\n    out_records = {}\n    \n    for p,file_path in path.items():\n    #    print(GH_Path(p), file_path[0],read_geometry[p][0],read_records[p][0],enc[p][0])\n        _sf_type, _geom, _fields, _field_names, _records = read_shapefile(file_path[0],\n                                                             read_geometry[p][0],\n                                                             read_records[p][0],\n                                                             enc[p][0])\n        out_shapeType[p] = _sf_type\n        out_geometry[p] = _geom\n        out_fields[p] = _fields\n        out_field_names[p] = _field_names\n        out_records[p] = _records\n    \n    shape_type = py_tree(out_shapeType, reverse = True)\n    geometry = py_tree(out_geometry, True)\n    fields = py_tree(out_fields, True)\n    field_names = py_tree(out_field_names, True)\n    records = py_tree(out_records, True)\n    \n",
  "language": "python",
  "imports": [
    "Rhino"
  ],
  "has_docstring": true
}