{
  "source_url": "https://github.com/josehernandezvargas/Rhino_PyWorkshop/blob/e061b54b86ef8e5b118408d00081d26c723b2c28/scripts/adaptive_slicing.py",
  "repo": "josehernandezvargas/Rhino_PyWorkshop",
  "repo_stars": 1,
  "repo_description": "A personal collection of Python tools for Rhino / Grasshopper",
  "license": "AGPL-3.0",
  "filepath": "scripts/adaptive_slicing.py",
  "instruction": "Adaptive layer height",
  "code": "#! python3\n\"\"\"Adaptive layer height\n\nInputs:\n    brep\n    samples\n    layer_height\n\"\"\"\n\n__author__ = \"joseh\"\n__version__ = \"2024.08.14\"\n\nimport rhinoscriptsyntax as rs\nimport math\nfrom ghpythonlib import treehelpers as th\n\nif brep == None:\n    msg = \"Connect a brep\"\n    ghenv.Component.AddRuntimeMessage(\n        gh.Kernel.GH_RuntimeMessageLevel.Warning, msg)\n\n\ndef interpolate(input_data, output_data, x):\n    # Ensure input is within the boundaries\n    # Check if input is below the minimum boundary\n    if x < input_data[0]:\n        print(f\"Warning: Input value {x} is below the minimum boundary. Returning the first output value.\")\n        return output_data[0]\n    \n    # Check if input is above the maximum boundary\n    if x > input_data[-1]:\n        print(f\"Warning: Input value {x} is above the maximum boundary. Returning the last output value.\")\n        return output_data[-1]\n\n\n    # Find the two nearest points\n    for i in range(len(input_data) - 1):\n        if input_data[i] <= x <= input_data[i + 1]:\n            x0, y0 = input_data[i], output_data[i]\n            x1, y1 = input_data[i + 1], output_data[i + 1]\n            break\n    else:\n        raise ValueError(\"Input value is not within the interpolation range.\")\n\n    # Perform linear interpolation\n    y = y0 + (y1 - y0) * ((x - x0) / (x1 - x0))\n    return y\n\n\npoints = []\nangles = []\ntarget_heights = []\nslice_planes = []\n\nbbox = rs.BoundingBox(brep)\nminx = bbox[0][0]\nminy = bbox[0][1]\nminz = bbox[0][2]\nmaxx = bbox[6][0]\nmaxy = bbox[6][1]\nmaxz = bbox[6][2]\n\nbrep_height = maxz - minz\ncontour_distance = brep_height / samples # height for contour crv\ncontour_heights = [contour_distance * i for i in range(int(samples))]\n\n# first contour operation to measure overhangs\ncurves = rs.AddSrfContourCrvs(brep, (bbox[0], bbox[4]), contour_distance)\n\n# Simply sampling the first point of each curve\n# for i, crv in enumerate(crvs):\n#     if i < len(crvs)-1:\n#         startpt = rs.CurveStartPoint(crvs[i])\n#         centroid = rs.CurveAreaCentroid(crv)[0]\n#         nextstartpt = rs.CurveStartPoint(crvs[i+1])\n#         vector = rs.VectorCreate(nextstartpt, startpt)\n#         zvect = rs.WorldXYPlane()[3] # world XY plane is OXYZ\n#         angle = rs.VectorAngle(zvect, vector)\n#         delta = math.sin(math.radians(angle)) # 0 to 90 deg > 0 to 1\n#         target_layer_height = max(10 - delta * 10, 3) # 0 to 90 deg > 10 to 0 layer height\n#         points.append(startpt)\n#         angles.append(angle)\n#         target_heights.append(target_layer_height)\n#         # deltas.append(delta)\n#         # offsets.append(offset)\n#         # vectors.append(vector)\n#         # offset_crvs.append(offset_crv)\n#         # widths.append(print_width + delta)\n#         # # widths.append(max(print_width, delta * 2))\n#         # deltas.append(delta)\n\nfor i, crv in enumerate(curves):\n    if i < len(curves)-1:\n        pts = rs.DivideCurve(crv, crv_samples)\n        crv_angles = []\n        # pts_next = cl.divide_crv_equal(crv[i+1], div_length)\n        for j, pt in enumerate(pts):\n            closest_param = rs.CurveClosestPoint(curves[i+1], pt)\n            closest_pt = rs.EvaluateCurve(curves[i+1], closest_param)\n            vector = -rs.VectorCreate(pt, closest_pt)\n            zvect = rs.WorldXYPlane()[3] # world XY plane is OXYZ\n            angle = abs(rs.VectorAngle(zvect, vector))\n            crv_angles.append(angle)\n        angle = max(crv_angles)\n        # startpt = rs.CurveStartPoint(crvs[i])\n        # centroid = rs.CurveAreaCentroid(crv)[0]\n        # nextstartpt = rs.CurveStartPoint(crvs[i+1])\n        # vector = rs.VectorCreate(nextstartpt, startpt)\n        # zvect = rs.WorldXYPlane()[3] # world XY plane is OXYZ\n        # angle = rs.VectorAngle(zvect, vector)\n        delta = math.sin(math.radians(angle)) # 0 to 90 deg > 0 to 1\n        target_layer_height = max(10 - delta * 10, 5) # 0 to 90 deg > 10 to 0 layer height\n        target_heights.append(target_layer_height)\n        # deltas.append(delta)\n        # offsets.append(offset)\n        # vectors.append(vector)\n        # offset_crvs.append(offset_crv)\n        # widths.append(print_width + delta)\n        # # widths.append(max(print_width, delta * 2))\n        # deltas.append(delta)\n\nprint(contour_heights)\nprint(target_heights)\n\n# for i, t in enumerate(target_heights):\n#     print(contour_heights[i], target_heights[i])\n\n# Define a safety limit for the maximum number of iterations\nmax_iterations = 1000  # Set an appropriate limit based on your use case\niteration_count = 0\nslice_heights = [0]\nslice_deltas = []\n\n# # Interpolate value at x = 1000.0\n# x = 200.0\n# result = interpolate(input_data, output_data, x)\n# print(f\"Interpolated value at {x} is {result}\")\n\n\n\nwhile slice_heights[-1] < brep_height:\n\n    current_height = slice_heights[-1]\n    \n    # Interpolate to find the appropriate layer height at the current height\n    layer_height = interpolate(contour_heights, target_heights, current_height)\n    # print(f\"Layer height at {current_height} mm: {layer_height} mm\")\n\n    next_height = current_height + layer_height\n    \n    if next_height > brep_height:\n        next_height = brep_height  # Ensure we don't exceed the Brep height\n    \n    slice_heights.append(next_height)\n    slice_deltas.append(layer_height)\n    \n    # Increment the iteration counter\n    iteration_count += 1\n    \n# Check if the iteration count exceeds the safety limit\n    if iteration_count >= max_iterations:\n        print(\"Warning: Exceeded maximum iterations.\")\n        break\n\n# slice again according to the adaptive layer heights\n\n# slicing_planes = [rs.PlaneFromFrame((0,0,h), (1,0,0), (0,1,0)) for h in slice_heights]\n# adaptive_contours = [rs.AddSrfContourCrvs(brep, slicing_planes[i]) for i in range(len(slicing_planes)-1)]\n# a = th.list_to_tree(adaptive_contours)\n\na = slice_heights\nb = slice_deltas",
  "language": "python",
  "imports": [
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}