{
  "source_url": "https://github.com/ar0551/Wasp/blob/66f63c018f2420d37aa451ade0178de260946b0c/src/ghComp/Wasp_Field-driven%20Aggregation.py",
  "repo": "ar0551/Wasp",
  "repo_stars": 67,
  "repo_description": "Combinatorial Design with Grasshopper plug-in (LGPL) initiated by Andrea Rossi",
  "license": "LGPL-3.0",
  "filepath": "src/ghComp/Wasp_Field-driven Aggregation.py",
  "instruction": "Aggregate the given parts according to a given scalar field. New parts are added following higher values in the field.\nThe component works additively, hence increasing the number of parts in an...",
  "code": "# Wasp: Discrete Design with Grasshopper plug-in (LGPL) initiated by Andrea Rossi\n# \n# This file is part of Wasp.\n# \n# Copyright (c) 2017-2023, Andrea Rossi <a.rossi.andrea@gmail.com>\n# Wasp is free software; you can redistribute it and/or modify \n# it under the terms of the GNU Lesser General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Wasp is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU Lesser General Public License for more details.\n# \n# You should have received a copy of the GNU Lesser General Public License\n# along with Wasp; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license LGPL-3.0 https://www.gnu.org/licenses/lgpl-3.0.html\n#\n# Early development of Wasp has been carried out by Andrea Rossi\n# as part of research on digital materials and discrete design at:\n# DDU Digital Design Unit - Prof. Oliver Tessmann\n# Technische Universitt Darmstadt\n\n\n#########################################################################\n##                            COMPONENT INFO                           ##\n#########################################################################\n\n\"\"\"\nAggregate the given parts according to a given scalar field. New parts are added following higher values in the field.\nThe component works additively, hence increasing the number of parts in an aggregation just adds new parts on the existing ones, without triggering recomputing of the previous element\n-\nProvided by Wasp 0.6\n    Args:\n        PART: Parts to be aggregated (can be more than one)\n        PREV: OPTIONAL // Previous aggregated parts. It is possible to input the results of a previous aggregation, or parts transformed with the TransformPart component\n        N: Number of parts to be aggregated (does not count parts provided in PREV)\n        RULES: Rules for the aggregation\n        FIELD: Scalar field to drive the aggregation (parts will be added following higher values in the field)\n        THRES: OPTIONAL // If set, used to define a threshold value above which the placement of next part is accepted. If not set, aggregation will look for part with highest value in the whole field. Setting a low threshold helds less accurate results, but highly speeds up calculations\n        COLL: OPTIONAL // Collision detection. By default is active and checks for collisions between the aggregated parts\n        CAT: OPTIONAL // Part Catalog (to specify fixed numbers or proportions between part types\n        MODE: OPTIONAL // Switches between aggregation modes: 0 = no constraints, 1 = local constraints, 2 = global constraints, 3 = local + global constraints\n        GC: OPTIONAL // Global constraints to apply to aggregation\n        ID: OPTIONAL // Aggregation ID\n        RESET: Recompute the whole aggregation\n    Returns:\n        AGGR: Aggregation object\n        PART_OUT: Aggregated parts (includes both PREV input and newly aggregated parts)\n\"\"\"\n\nghenv.Component.Name = \"Wasp_Field-driven Aggregation\"\nghenv.Component.NickName = 'FieldAggregation'\nghenv.Component.Message = \"v0.6.001\"\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"Wasp\"\nghenv.Component.SubCategory = \"6 | Aggregation\"\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"1\"\nexcept: pass\n\n\nimport sys\nimport Rhino.Geometry as rg\nimport Grasshopper as gh\n\n\n## add Wasp install directory to system path\nwasp_loaded = False\nghcompfolder = gh.Folders.DefaultAssemblyFolder\nif ghcompfolder not in sys.path:\n    sys.path.append(ghcompfolder)\ntry:\n    from wasp import __version__\n    wasp_loaded = True\nexcept:\n    msg = \"Cannot import Wasp. Is the wasp folder available in \" + ghcompfolder + \"?\"\n    ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Error, msg)\n\n## if Wasp is installed correctly, load the classes required by the component\nif wasp_loaded:\n    from wasp.core import Aggregation\n\n\n## Main code execution\ndef main(parts, previous_parts, num_parts, rules, catalog, aggregation_mode, global_constraints, aggregation_id, reset, fields, aggregation):\n    \n    check_data = True\n    ##check inputs\n    if len(parts) == 0:\n        check_data = False\n        msg = \"No parts provided\"\n        ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Warning, msg)\n    \n    if num_parts is None:\n        check_data = False\n        msg = \"Provide number of aggregation iterations\"\n        ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Warning, msg)\n    else:\n        if len(previous_parts) != 0:\n            num_parts += len(previous_parts)\n    \n    if len(rules) == 0:\n        check_data = False\n        msg = \"No rules provided\"\n        ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Warning, msg)\n    \n    use_catalog = False\n    if catalog is not None:\n        use_catalog = True\n    \n    if aggregation_mode is None:\n        aggregation_mode = 0\n    \n    if aggregation_id is None:\n        aggregation_id = 'myFieldAggregation'\n    \n    if reset is None:\n        reset = False\n    \n    if len(fields) == 0:\n        check_data = False\n        msg = \"Provide a valid scalar field\"\n        ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Warning, msg)\n    elif len(fields) > 1:\n        field_names = [f.name for f in fields]\n        for part in parts:\n            if part.field is None:\n                part.field = fields[0].name\n                \n            elif part.field not in field_names:\n                check_data = False\n                msg = \"Part \" + part.name + \" does not have a vaild field name assigned.\"\n                ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Warning, msg)\n    \n    if check_data:\n        \n        ## create aggregation in sticky dict\n        if aggregation is None or aggregation == -1 or reset:\n            \n            ## copy parts to avoid editing the original parts\n            parts_copy = []\n            for part in parts:\n                parts_copy.append(part.copy())\n            \n            if use_catalog:\n                aggregation = Aggregation(aggregation_id, parts_copy, rules, aggregation_mode, _prev = previous_parts, _global_constraints = global_constraints, _field = fields, _catalog = catalog.copy())\n            else:\n                aggregation = Aggregation(aggregation_id, parts_copy, rules, aggregation_mode, _prev = previous_parts, _global_constraints = global_constraints, _field = fields)\n        \n        ## handle parameters changes\n        part_rules_change = False\n        #### parts\n        if parts != aggregation.parts.values():\n            \n            ## copy parts to avoid editing the original parts\n            parts_copy = []\n            for part in parts:\n                parts_copy.append(part.copy())\n            \n            aggregation.reset_base_parts(new_parts = parts_copy)\n            aggregation.reset_rules(aggregation.rules)\n            part_rules_change = True\n        \n        #### rules\n        if rules != aggregation.rules:\n            aggregation.rules = rules\n            aggregation.reset_base_parts()\n            aggregation.reset_rules(aggregation.rules)\n            part_rules_change = True\n        \n        if part_rules_change:\n            aggregation.recompute_aggregation_queue()\n        \n        #### mode\n        if aggregation_mode != aggregation.mode:\n            aggregation.mode = aggregation_mode\n            aggregation.reset_rules(aggregation.rules)\n            aggregation.recompute_aggregation_queue()\n        \n        #### constraints\n        if global_constraints != aggregation.global_constraints:\n            aggregation.global_constraints = global_constraints\n            aggregation.reset_rules(aggregation.rules)\n            aggregation.recompute_aggregation_queue()\n        \n        ## field (TO DO)\n        ##################################\n        \n        ## add parts to aggregation\n        if num_parts > len(aggregation.aggregated_parts):\n            #sc.sticky[aggregation_id].aggregate_field(num_parts-sc.sticky[aggregation_id].p_count, field, threshold)\n            error_msg = aggregation.aggregate_field(num_parts-len(aggregation.aggregated_parts), use_catalog)\n            if error_msg is not None:\n                ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Warning, error_msg)\n        \n        ## remove parts from aggregation\n        elif num_parts < len(aggregation.aggregated_parts):\n            aggregation.remove_elements(num_parts)\n        \n        ## return result\n        return aggregation\n        \n    else:\n        return -1\n\n## create aggregation container in global variables dict\nif 'aggregation_container' not in globals():\n    aggregation_container = None\n\nresult = main(PART, PREV, N, RULES, CAT, MODE, GC, ID, RESET, FIELD, aggregation_container)\n\nif result != -1:\n    aggregation_container = result\n    \n    AGGR = aggregation_container\n    PART_OUT = aggregation_container.aggregated_parts",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}