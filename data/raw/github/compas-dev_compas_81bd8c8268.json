{
  "source_url": "https://github.com/compas-dev/compas/blob/HEAD/src/compas_ghpython/drawing.py",
  "repo": "compas-dev/compas",
  "repo_stars": 352,
  "repo_description": "Main library of the COMPAS framework and CAD integrations for Rhino/GH and Blender.",
  "license": "MIT",
  "filepath": "src/compas_ghpython/drawing.py",
  "instruction": "Drawing",
  "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nfrom Rhino.Geometry import Brep\nfrom Rhino.Geometry import Circle\nfrom Rhino.Geometry import Curve\nfrom Rhino.Geometry import Cylinder\nfrom Rhino.Geometry import Line\nfrom Rhino.Geometry import Mesh\nfrom Rhino.Geometry import PipeCapMode\nfrom Rhino.Geometry import Plane\nfrom Rhino.Geometry import Point2f\nfrom Rhino.Geometry import Point3d\nfrom Rhino.Geometry import PolylineCurve\nfrom Rhino.Geometry import Sphere\nfrom Rhino.Geometry import Vector3d\nfrom Rhino.Geometry import Vector3f\n\nfrom compas.geometry import centroid_points\nfrom compas.geometry import centroid_polygon\nfrom compas.itertools import pairwise\n\ntry:\n    from Rhino.Geometry import MeshNgon\nexcept ImportError:\n    MeshNgon = False\n\nTOL = sc.doc.ModelAbsoluteTolerance\n\n\ndef _face_to_max_quad(points, face):\n    faces = []\n    c = len(points)\n    points.append(centroid_polygon(points))\n    for i in range(-1, len(face) - 1):\n        a = face[i]\n        b = face[i + 1]\n        faces.append([c, a, b, b])\n    return faces\n\n\ndef draw_frame(frame):\n    \"\"\"Draw a frame.\"\"\"\n    pt = Point3d(*iter(frame.point))\n    xaxis = Vector3d(*iter(frame.xaxis))\n    yaxis = Vector3d(*iter(frame.yaxis))\n    return Plane(pt, xaxis, yaxis)\n\n\ndef draw_points(points):\n    \"\"\"Draw points.\n\n    Parameters\n    ----------\n    points : list of dict\n        The point definitions.\n\n    Returns\n    -------\n    list[:rhino:`Rhino.Geometry.Point3d`]\n\n    Notes\n    -----\n    .. code-block:: python\n\n        Schema({\n            'pos': lambda x: len(x) == 3)\n        })\n\n    \"\"\"\n    rg_points = []\n    for p in iter(points):\n        pos = p[\"pos\"]\n        rg_points.append(Point3d(*pos))\n    return rg_points\n\n\ndef draw_lines(lines):\n    \"\"\"Draw lines.\n\n    Parameters\n    ----------\n    lines : list of dict\n        The line definitions.\n\n    Returns\n    -------\n    list[:rhino:`Rhino.Geometry.Line`]\n\n    Notes\n    -----\n    .. code-block:: python\n\n        Schema({\n            'start': lambda x: len(x) == 3),\n            'end': lambda x: len(x) == 3),\n        })\n\n    \"\"\"\n    rg_lines = []\n    for line in iter(lines):\n        sp = line[\"start\"]\n        ep = line[\"end\"]\n        rg_lines.append(Line(Point3d(*sp), Point3d(*ep)))\n    return rg_lines\n\n\ndef draw_geodesics(geodesics):\n    \"\"\"Draw geodesic lines on specified surfaces.\n\n    Parameters\n    ----------\n    geodesics : list of dict\n        The geodesic definitions.\n\n    Returns\n    -------\n    list[:rhino:`Rhino.Geometry.Curve`]\n\n    Notes\n    -----\n    .. code-block:: python\n\n        Schema({\n            'start': lambda x: len(x) == 3),\n            'end': lambda x: len(x) == 3),\n            'srf': str\n        })\n\n    \"\"\"\n    rg_geodesics = []\n    for g in iter(geodesics):\n        sp = g[\"start\"]\n        ep = g[\"end\"]\n        srf = g[\"srf\"]\n        curve = srf.ShortPath(Point3d(*sp), Point3d(*ep), TOL)\n        rg_geodesics.append(curve)\n    return rg_geodesics\n\n\ndef draw_polylines(polylines):\n    \"\"\"Draw polylines.\n\n    Parameters\n    ----------\n    polylines : list of dict\n        The polyline definitions.\n\n    Returns\n    -------\n    list[:rhino:`Rhino.Geometry.PolylineCurve`]\n\n    Notes\n    -----\n    .. code-block:: python\n\n        Schema({\"points\": lambda x: all(len(y) == 3 for y in x)})\n\n    \"\"\"\n    rg_polylines = []\n    # We need to use PolylineCurve because of this:\n    # https://discourse.mcneel.com/t/polyline-output-wanted-but-got-a-list-of-points/77509\n    for p in iter(polylines):\n        points = p[\"points\"]\n        poly = PolylineCurve([Point3d(*xyz) for xyz in points])\n        rg_polylines.append(poly)\n    return rg_polylines\n\n\ndef draw_faces(faces):\n    \"\"\"Draw polygonal faces as Meshes.\n\n    Parameters\n    ----------\n    faces : list of dict\n        The face definitions.\n\n    Returns\n    -------\n    list[:rhino:`Rhino.Geometry.Mesh`]\n\n    Notes\n    -----\n    .. code-block:: python\n\n        Schema({\"points\": lambda x: all(len(y) == 3 for y in x), Optional(\"vertexcolors\", default=None): lambda x: all(len(y) == 3 for y in x)})\n\n    \"\"\"\n    meshes = []\n    for face in iter(faces):\n        points = face[\"points\"][:]\n        vertexcolors = face.get(\"vertexcolors\")\n        v = len(points)\n        if v < 3:\n            continue\n        if v == 3:\n            mfaces = [[0, 1, 2, 2]]\n        elif v == 4:\n            mfaces = [[0, 1, 2, 3]]\n        else:\n            mfaces = _face_to_max_quad(points, range(v))\n            if vertexcolors:\n                r, g, b = [sum(component) / v for component in zip(*vertexcolors)]\n                r = int(min(max(0, r), 255))\n                g = int(min(max(0, g), 255))\n                b = int(min(max(0, b), 255))\n                vertexcolors.append((r, g, b))\n        if vertexcolors:\n            mesh = draw_mesh(points, mfaces, color=vertexcolors)\n        else:\n            mesh = draw_mesh(points, mfaces)\n        meshes.append(mesh)\n    return meshes\n\n\ndef draw_cylinders(cylinders, cap=False):\n    \"\"\"Draw cylinders.\n\n    Parameters\n    ----------\n    cylinders : list of dict\n        The cylinder definitions.\n\n    Other Parameters\n    ----------------\n    cap : bool, optional\n        Default is False.\n\n    Returns\n    -------\n    list[:rhino:`Rhino.Geometry.Cylinder`]\n\n    Notes\n    -----\n    .. code-block:: python\n\n        Schema({\"start\": lambda x: len(x) == 3, \"end\": lambda x: len(x) == 3, \"radius\": And(Or(int, float), lambda x: x > 0)})\n\n    \"\"\"\n    rg_cylinders = []\n    for c in iter(cylinders):\n        start = c[\"start\"]\n        end = c[\"end\"]\n        radius = c[\"radius\"]\n        if radius < TOL:\n            continue\n        base = Point3d(*start)\n        normal = Point3d(*end) - base\n        height = normal.Length\n        if height < TOL:\n            continue\n        plane = Plane(base, normal)\n        circle = Circle(plane, radius)\n        cylinder = Cylinder(circle, height)\n        brep = cylinder.ToBrep(cap, cap)\n        if not brep:\n            continue\n        rg_cylinders.append(brep)\n    return rg_cylinders\n\n\ndef draw_pipes(pipes, cap=2, fit=1.0):\n    \"\"\"Draw pipes.\n\n    Parameters\n    ----------\n    pipes : list of dict\n        The pipe definitions.\n\n    Other Parameters\n    ----------------\n    cap : {0, 1, 2}, optional\n    fit : float, optional\n\n    Returns\n    -------\n    list[:rhino:`Rhino.Geometry.Brep`]\n\n    Notes\n    -----\n    .. code-block:: python\n\n        Schema({\"points\": lambda x: all(len(y) == 3 for y in x), \"radius\": And(Or(int, float), lambda x: x > 0)})\n\n    \"\"\"\n    abs_tol = TOL\n    ang_tol = sc.doc.ModelAngleToleranceRadians\n    for p in pipes:\n        points = p[\"points\"]\n        radius = p[\"radius\"]\n        params = [0.0, 1.0]\n        cap = PipeCapMode(cap)\n        if type(radius) in (int, float):\n            radius = [radius] * 2\n        radius = [float(r) for r in radius]\n\n        rail = Curve.CreateControlPointCurve([Point3d(*xyz) for xyz in points])\n        breps = Brep.CreatePipe(rail, params, radius, 1, cap, fit, abs_tol, ang_tol)\n        for brep in breps:\n            yield brep\n\n\ndef draw_spheres(spheres):\n    \"\"\"Draw spheres.\n\n    Parameters\n    ----------\n    spheres : list of dict\n        The sphere definitions.\n\n    Returns\n    -------\n    list[:rhino:`Rhino.Geometry.Sphere`]\n\n    Notes\n    -----\n    .. code-block:: python\n\n        Schema({\"pos\": lambda x: len(x) == 3, \"radius\": And(Or(int, float), lambda x: x > 0)})\n\n    \"\"\"\n    rg_sheres = []\n    for s in iter(spheres):\n        pos = s[\"pos\"]\n        radius = s[\"radius\"]\n        rg_sheres.append(Sphere(Point3d(*pos), radius))\n    return rg_sheres\n\n\ndef draw_mesh(vertices, faces, color=None, vertex_normals=None, texture_coordinates=None):\n    \"\"\"Draw mesh in Grasshopper.\n\n    Parameters\n    ----------\n    vertices : list of point\n        List of vertex locations.\n    faces : list of list of int\n        List of faces defined as lists of indices into the list of vertices.\n\n    Other Parameters\n    ----------------\n    color : tuple, list | :class:`System.Drawing.Color`, optional\n    vertex_normals : bool, optional\n    texture_coordinates\n\n    Returns\n    -------\n    list[:rhino:`Rhino.Geometry.Mesh`]\n\n    \"\"\"\n    mesh = Mesh()\n    for a, b, c in vertices:\n        mesh.Vertices.Add(a, b, c)\n    for face in faces:\n        f = len(face)\n        if f < 3:\n            continue\n        if f == 3:\n            mesh.Faces.AddFace(*face)\n        elif f == 4:\n            mesh.Faces.AddFace(*face)\n        else:\n            if MeshNgon:\n                centroid = centroid_points([vertices[index] for index in face])\n                c = mesh.Vertices.Add(*centroid)\n                facets = []\n                for i, j in pairwise(face + face[:1]):\n                    facets.append(mesh.Faces.AddFace(i, j, c))\n                ngon = MeshNgon.Create(face, facets)\n                mesh.Ngons.AddNgon(ngon)\n\n    if vertex_normals:\n        count = len(vertex_normals)\n        normals = [Vector3f(normal[0], normal[1], normal[2]) for normal in vertex_normals]\n        mesh.Normals.SetNormals(normals)\n\n    if texture_coordinates:\n        count = len(texture_coordinates)\n        tcs = [Point2f(tc[0], tc[1]) for tc in texture_coordinates]\n        mesh.TextureCoordinates.SetTextureCoordinates(tcs)\n\n    if color:\n        count = len(mesh.Vertices)\n        color = rs.CreateColor(color)\n\n        for i in range(count):\n            mesh.VertexColors.SetColor(i, color.R, color.G, color.B)\n\n    return mesh\n\n\ndef draw_graph(graph):\n    \"\"\"Draw a graph in Grasshopper.\n\n    Parameters\n    ----------\n    graph : :class:`compas.datastructures.Graph`\n\n    Returns\n    -------\n    tuple\n        A list[:rhino:`Rhino.Geometry.Point3d`].\n        A list[:rhino:`Rhino.Geometry.Line`].\n\n    \"\"\"\n    points = []\n    for key in graph.nodes():\n        points.append({\"pos\": graph.node_coordinates(key)})\n    lines = []\n    for u, v in graph.edges():\n        lines.append({\"start\": graph.node_coordinates(u), \"end\": graph.node_coordinates(v)})\n    points_rg = draw_points(points)\n    lines_rg = draw_lines(lines)\n\n    return points_rg, lines_rg\n\n\ndef draw_circles(circles):\n    \"\"\"Draw circles in Grasshopper.\n\n    Parameters\n    ----------\n    circles : list of dict\n        The circle definitions.\n\n    Returns\n    -------\n    list[:rhino:`Rhino.Geometry.Circle`]\n\n    Notes\n    -----\n    .. code-block:: python\n\n        Schema({\"plane\": lambda x: len(x[0]) == 3 and len(x[1]) == 3, \"radius\": And(Or(int, float), lambda x: x > 0)})\n\n    \"\"\"\n    rg_circles = []\n    for c in iter(circles):\n        point, normal = c[\"plane\"]\n        radius = c[\"radius\"]\n        rg_circles.append(Circle(Plane(Point3d(*point), Vector3d(*normal)), radius))\n    return rg_circles\n\n\ndef draw_brep(brep):\n    \"\"\"Draw a RhinoBrep in Grasshopper.\n\n    Parameters\n    ----------\n    brep : :class:`compas.geometry.RhinoBrep`\n        The Brep to draw.\n\n    Returns\n    -------\n    :rhino:`Rhino.Geometry.Brep`\n\n    \"\"\"\n    return brep.native_brep\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}