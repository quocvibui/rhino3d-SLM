{
  "source_url": "https://github.com/mattmonforte/DistanceParallel/blob/7b5cc2d3b81ecabd23377f95c09177d83dd6e4ed/dev/DistanceParallel_cmd.py",
  "repo": "mattmonforte/DistanceParallel",
  "repo_stars": 2,
  "repo_description": "A python command for Rhinoceros 3d CAD modeling software that measures the distance between two parallel planar surfaces.",
  "license": "LGPL-3.0",
  "filepath": "dev/DistanceParallel_cmd.py",
  "instruction": "DistanceParallel\ncreated 9/4/2020",
  "code": "'''\nDistanceParallel\ncreated 9/4/2020\n\nA python command for Rhinoceros 3d CAD modeling software that measures\nthe distance between two parallel planar surfaces.\n\nCopyright (c)2020 Matt Monforte\nmattmonforte@gmail.com\nClickWhirDing.com\nMonSalon.org\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\nany later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with this program. If not, see https://www.gnu.org/licenses.\n'''\n\nimport Rhino as rc\nimport rhinoscriptsyntax as rs\nfrom scriptcontext import doc\nimport scriptcontext as sc\nfrom DPutilities.UnLocker import UnLocker\n\nul = UnLocker()\n__commandname__ = \"DistanceParallel\"\n\ndef RunCommand( is_interactive ):\n    print(__commandname__ + \" v0.5.1\")\n\n    # ZERO_TOLERANCE = 1.0e-2\n    ZERO_TOLERANCE = rs.UnitAbsoluteTolerance()\n    myDebug = True\n    unlockLayersDefault = False\n    global plane\n    plane = []\n    selectedObjects = []\n    selectedCounter = 0\n\n    go = rc.Input.Custom.GetObject()\n    go.SetCommandPrompt(\"Select Two Parallel Planar Surfaces\")\n    go.AlreadySelectedObjectSelect = False\n    go.DeselectAllBeforePostSelect = False\n    go.EnableClearObjectsOnEntry(False)\n    # go.EnableUnselectObjectsOnExit(False)\n    go.OneByOnePostSelect = True\n    go.SubObjectSelect = True\n    go.EnablePreSelect(False, True)\n    # go.EnableClearObjectsOnEntry(False)\n\n    # Filter object type\n    geometryType = rc.DocObjects.ObjectType.Surface\n    go.GeometryFilter = geometryType\n\n    # Set up command option persistance memory\n    if sc.sticky.has_key(\"distance_parallel_unlock\"):\n        unlockLayersDefault = sc.sticky[\"distance_parallel_unlock\"]\n    else:\n        sc.sticky[\"distance_parallel_unlock\"] = False\n        unlockLayersDefault = sc.sticky[\"distance_parallel_unlock\"]\n\n    if sc.sticky.has_key(\"distance_parallel_msg_box\"):\n        messageBoxDefault = sc.sticky[\"distance_parallel_msg_box\"]\n    else:\n        sc.sticky[\"distance_parallel_msg_box\"] = False\n        messageBoxDefault = sc.sticky[\"distance_parallel_msg_box\"]\n\n    # set up command options\n    unlockLayers = rc.Input.Custom.OptionToggle(unlockLayersDefault, \"Off\", \"On\")\n    go.AddOptionToggle(\"UnlockLayersAndObjects\", unlockLayers)\n\n    messageBox = rc.Input.Custom.OptionToggle(messageBoxDefault, \"Off\", \"On\")\n    go.AddOptionToggle(\"ResultsInMessageBox\", messageBox)\n\n    unlockLayersPrevState = unlockLayers.CurrentValue\n    messageBoxPrevState = messageBox.CurrentValue\n\n    if unlockLayers.CurrentValue == 1:\n        ul.unlockLayersAndObjects()\n\n\n    while True:\n\n        getResult = go.GetMultiple(selectedCounter+1,selectedCounter+1)\n        # go.EnableClearObjectsOnEntry(False)\n        # go.DeselectAllBeforePostSelect = False\n        if getResult == rc.Input.GetResult.Cancel:\n            clean_up_cancel()\n            return rc.Commands.Result.Cancel\n        #     clean_up_success()\n        #     return go.CommandResult()\n        if getResult == rc.Input.GetResult.Object:\n            # Get the view that the point was picked in.\n            view = go.View()\n            selectedObjects = go.Objects()\n            selectedCounter = len(selectedObjects)\n            # get objects from selections\n            objref = go.Object(selectedCounter-1)\n            # get selected surface object\n            obj = objref.Object()\n            if not obj:\n                # Why do?\n                if myDebug :\n                    msgOut(\"Object not selected.\")\n                clean_up_fail()\n                return rc.Commands.Result.Failure\n            try:\n                surface = objref.Surface()\n            except:\n                msgOut(\"Surfaces within blocks are not always selectable. Polysurfaces can be selected, Extrusion cannot. Explode block for more selectability.\")\n                # try to continue and reselect\n                clean_up_fail()\n                return rc.Commands.Result.Failure\n            if not surface:\n                # why is this needed?\n                if myDebug :\n                    msgOut(\"No surface selected.\")\n                clean_up_fail()\n                return rc.Commands.Result.Failure\n\n            test, getPlane = surface.TryGetPlane(ZERO_TOLERANCE)\n            if not test:\n                msgOut(\"Surface is not planar.\")\n                # maybe continue or allow select of first surface again\n                clean_up_fail()\n                return rc.Commands.Result.Failure\n            plane.append(getPlane)\n            if selectedCounter == 2:\n                # view.Redraw()\n                break\n            # loop until second surface selected or cancel\n            continue\n        # Command Options\n        elif getResult == rc.Input.GetResult.Option:\n            if unlockLayers.CurrentValue != unlockLayersPrevState:\n                if unlockLayers.CurrentValue == 1:\n                    sc.sticky[\"distance_parallel_unlock\"] = True\n                    unlockLayersPrevState = True\n                    ul.unlockLayersAndObjects()\n                else:\n                    sc.sticky[\"distance_parallel_unlock\"] = False\n                    unlockLayersPrevState = False\n                    ul.relockLayersAndObjects()\n            elif messageBox.CurrentValue != messageBoxPrevState:\n                if messageBox.CurrentValue == 1:\n                    sc.sticky[\"distance_parallel_msg_box\"] = True\n                    messageBoxPrevState = True\n                else:\n                    sc.sticky[\"distance_parallel_msg_box\"] = False\n                    messageBoxPrevState = False\n    \t    go.EnablePreSelect(False, True)\n            continue\n        elif getResult == rc.Input.GetResult.Nothing:\n            # needed?\n            msgOut(\"Got nothing.\")\n            clean_up_fail()\n            return rc.Commands.Result.Failure\n            # break\n        # end While\n\n    clean_up_success()\n    # Are planes parallel\n    if ArePlanesParallel(plane[0], plane[1], ZERO_TOLERANCE) == False:\n        msgOut(\"Surfaces are not parallel to each other.\")\n        clean_up_fail()\n        return rc.Commands.Result.Failure\n    # measure distance between planes\n    # acually distance between plane[0] and point on plan[1]\n    ParallelDistance = abs(rs.DistanceToPlane(plane[0], plane[1][0]))\n    # output results\n    unitsName = doc.GetUnitSystemName(True, True, True, False)\n    ## fromating output decimal places not working for me\n    # decimalPlaces = doc.DistanceDisplayPrecision\n    # textOut = \"Parallel Distance = {:.\" + str(decimalPlaces) +\"f} \" + unitsName\n    rs.ClipboardText(ParallelDistance)\n    textOut = \"Parallel Distance = {:.4f} \" + unitsName\n    # msgOut(textOut.format(ParallelDistance))\n    print(textOut.format(ParallelDistance))\n    if sc.sticky[\"distance_parallel_msg_box\"]:\n        # view.Redraw()\n        rs.MessageBox(\"the value is saved to your clipboard\", 64, textOut.format(ParallelDistance))\n    else:\n        pass\n        #delay enough to see last selected highlighting before commend ends\n        #Doesn't always work. look for better way to do this\n        # rs.Sleep(400)\n    return rc.Commands.Result.Success\n\ndef msgOut(_msg):\n    print(_msg)\n    rs.MessageBox(_msg)\n    return\n\ndef ArePlanesParallel(_plane1, _plane2, tol):\n    cpvec = rs.VectorCrossProduct(_plane1.Normal, _plane2.Normal)\n    if abs(cpvec.X) < tol and abs(cpvec.Y) < tol and abs(cpvec.Z) < tol:\n        return True\n    return False\n\ndef clean_up_fail():\n    if ul.unlocked:\n        ul.relockLayersAndObjects()\n    return\n\ndef clean_up_success():\n    if ul.unlocked:\n        ul.relockLayersAndObjects()\n    return\n\ndef clean_up_cancel():\n    if ul.unlocked:\n        ul.relockLayersAndObjects()\n    return\n\nif( __name__ == \"__main__\" ):\n    RunCommand(True)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}