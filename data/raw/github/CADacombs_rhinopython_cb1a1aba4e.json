{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_findClosedCylindricalFeatureMismatches.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_findClosedCylindricalFeatureMismatches.py",
  "instruction": "Use this script to check for possible mismatches in closed cylindrical face sets\r\nbetween breps to find modeling errors between overlapping holes or holes with\r\ntheir respective...",
  "code": "\"\"\"\r\nUse this script to check for possible mismatches in closed cylindrical face sets\r\nbetween breps to find modeling errors between overlapping holes or holes with\r\ntheir respective fasteners.\r\n\r\n_ExplodeBlock all instances that should be checked. Remember to _UndoMultiple\r\nthe _ExplodeBlock later. It should respect the layer state, not process invisible objects.\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n250203-06: Created.\r\n\r\nTODO:\r\n    Add support for block instances so that _ExplodeBlock does not need to be\r\n    used before this script.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System.Drawing import Color\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fTol_IsCyl'; keys.append(key)\r\n    value = 1e-6 * Rhino.RhinoMath.UnitScale(\r\n        Rhino.UnitSystem.Millimeters,\r\n        sc.doc.ModelUnitSystem)\r\n    values[key] = float(format(value, '.0e'))\r\n    names[key] = 'IsCylTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'fTol_Dist'; keys.append(key)\r\n    value = 1e-3 * Rhino.RhinoMath.UnitScale(\r\n        Rhino.UnitSystem.Millimeters,\r\n        sc.doc.ModelUnitSystem)\r\n    values[key] = float(format(value, '.0e'))\r\n    names[key] = 'MaxMatchDistTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'fTol_Angle_Deg'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAngleToleranceDegrees\r\n    names[key] = 'MaxMatchAngleTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fTol_Dist_Ignore'; keys.append(key)\r\n    values[key] = 0.1 * Rhino.RhinoMath.UnitScale(\r\n        Rhino.UnitSystem.Inches,\r\n        sc.doc.ModelUnitSystem)\r\n    names[key] = 'DistToIgnore'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'fTol_Angle_Ignore_Deg'; keys.append(key)\r\n    values[key] = 46.0\r\n    names[key] = 'AngleToIgnore'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    #key = 'bDot'; keys.append(key)\r\n    #values[key] = True\r\n    #riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    #stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    #key = 'iDotHeight'; keys.append(key)\r\n    #values[key] = 11\r\n    #riOpts[key] = ri.Custom.OptionInteger(values[key], setLowerLimit=True, limit=3)\r\n    #stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        _debug = sc.sticky\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key in ('fTol_IsCyl', 'fTol_Dist', 'fTol_Angle_Deg', 'fTol_Angle_Ignore_Deg'):\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < Rhino.RhinoMath.ZeroTolerance:\r\n                cls.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key == 'fTol_Dist_Ignore':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.values[key] = cls.riOpts[key].InitialValue\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            if cls.riOpts[key].CurrentValue < cls.riOpts['fTol_Dist'].CurrentValue:\r\n                cls.riOpts[key].CurrentValue = cls.values[key]\r\n            else:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.listValues:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = idxList\r\n\r\n        print(\"Invalid key?\")\r\n\r\n\r\ndef _get_all_normal_breps():\r\n    oes = rd.ObjectEnumeratorSettings()\r\n    oes.LockedObjects = False # Default is True.\r\n    oes.ObjectTypeFilter = rd.ObjectType.Brep\r\n    return list(sc.doc.Objects.GetObjectList(oes))\r\n\r\n\r\ndef _getAllNormal_breps_and_instances():\r\n    oes = rd.ObjectEnumeratorSettings()\r\n    oes.LockedObjects = False # Default is True.\r\n    oes.ObjectTypeFilter = rd.ObjectType.Brep | rd.ObjectType.InstanceReference\r\n    return list(sc.doc.Objects.GetObjectList(oes))\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get Breps with optional input\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select breps\")\r\n    go.SetCommandPromptDefault(\"All normal when none are selected\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Brep\r\n    go.SubObjectSelect = False\r\n\r\n    go.AcceptNothing(True)\r\n\r\n    #sc.doc.Views.Redraw()\r\n\r\n    idxs_Opts = {}\r\n\r\n    def addOption(key): idxs_Opts[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opts.clear()\r\n\r\n        addOption('fTol_IsCyl')\r\n        addOption('fTol_Dist')\r\n        addOption('fTol_Angle_Deg')\r\n        addOption('fTol_Dist_Ignore')\r\n        addOption('fTol_Angle_Ignore_Deg')\r\n        #addOption('bDot')\r\n        #if Opts.values['bDot']:\r\n        #    addOption('iDotHeight')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n        # Not setting minimumNumber to 2 to avoid a result of GetResult.Nothing\r\n        # for selection of 1 object.\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            go.Dispose()\r\n            return _get_all_normal_breps()\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return [objref.Object() for objref in objrefs]\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opts:\r\n            if go.Option().Index == idxs_Opts[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef _collect_cylinders_per_face_index(rgBrep, fTol_IsCyl):\r\n    \"\"\"\r\n    Parameters:\r\n    Returns:\r\n    \"\"\"\r\n    cyls_perF = {}\r\n\r\n    for rgF in rgBrep.Faces:\r\n        #if rg.Surface.IsCylinder(\r\n        #    rgF,\r\n        #    tolerance=fTol_IsCyl)\r\n        bSuccess, cyl = rg.Surface.TryGetCylinder(\r\n            rgF,\r\n            tolerance=fTol_IsCyl)\r\n        if bSuccess:\r\n            cyls_perF[rgF.FaceIndex] = cyl\r\n            continue\r\n\r\n        if isinstance(rgF.UnderlyingSurface(), rg.NurbsSurface):\r\n            continue\r\n\r\n        # Due to bug in TryGetCylinder, try one more time with the NURBS-equivalent surface.\r\n        ns = rgF.ToNurbsSurface()\r\n        bSuccess, cyl = rg.Surface.TryGetCylinder(\r\n            ns,\r\n            tolerance=fTol_IsCyl)\r\n        if bSuccess:\r\n            cyls_perF[rgF.FaceIndex] = cyl\r\n\r\n    return cyls_perF\r\n\r\n\r\ndef _are_cylinders_colcylindrical(cylA, cylB, distanceTolerance, angleTolerance):\r\n    if abs(cylA.Radius - cylB.Radius) > distanceTolerance:\r\n        return False\r\n\r\n    if not cylA.Axis.EpsilonEquals(cylB.Axis, epsilon=distanceTolerance):\r\n        if not cylA.Axis.EpsilonEquals(-cylB.Axis, epsilon=distanceTolerance):\r\n            return False\r\n\r\n    isParallelTo = cylA.Axis.IsParallelTo(\r\n        cylB.Axis,\r\n        angleTolerance=angleTolerance)\r\n\r\n    if isParallelTo == 0:\r\n        sEval = \"cylA.Axis\"; print(sEval,'=',eval(sEval))\r\n        sEval = \"cylB.Axis\"; print(sEval,'=',eval(sEval))\r\n        angle = rg.Vector3d.VectorAngle(cylA.Axis, cylB.Axis)\r\n        #sEval = \"angle\"; print(sEval,'=',eval(sEval))\r\n        #sEval = \"Rhino.RhinoMath.ToDegrees(angle)\"; print(sEval,'=',eval(sEval))\r\n        #sEval = \"fTol_IsCyl\"; print(sEval,'=',eval(sEval))\r\n        sc.doc.Objects.AddCircle(cylA.CircleAt(linearParameter=0))\r\n        sc.doc.Objects.AddCircle(cylB.CircleAt(linearParameter=0))\r\n        raise Exception(\"isParallelTo of {} should not be so because EpsilonEquals of previous block passed.\".format(\r\n            isParallelTo))\r\n        return False\r\n\r\n    cirA = cylA.CircleAt(0.0)\r\n    planeA = cirA.Plane\r\n    cirB = cylB.CircleAt(0.0)\r\n    xf = rg.Transform.PlanarProjection(planeA)\r\n    ncB = cirB.ToNurbsCurve() # So that curve can deform as needed.\r\n    ncB.Transform(xf)\r\n    #sc.doc.Objects.AddCurve(ncB)\r\n    bSuccess, cirB = ncB.TryGetCircle(distanceTolerance)\r\n    if not bSuccess:\r\n        return False\r\n\r\n    if not cirA.Center.EpsilonEquals(cirB.Center, distanceTolerance):\r\n        return False\r\n\r\n    if not Rhino.RhinoMath.EpsilonEquals(cirA.Radius, cirB.Radius, distanceTolerance):\r\n        return False\r\n\r\n    return True\r\n\r\n\r\n    ac_A = rg.ArcCurve(cirA)\r\n    ac_B = rg.ArcCurve(cirB)\r\n    \r\n    if not cirA.EpsilonEquals(cirB, distanceTolerance):\r\n        rvs = rg.Curve.GetDistancesBetweenCurves(ac_A, ac_B, 0.1*distanceTolerance)\r\n        if not rvs[0]:\r\n            return False\r\n\r\n        if rvs[1] > distanceTolerance:\r\n            return False\r\n        \r\n        #sc.doc.Objects.AddCircle(rgCirA)\r\n        #sc.doc.Objects.AddCircle(rgCirB)\r\n\r\n    return True\r\n\r\n\r\ndef _findContiguousCocylindricFacesOf1Face(rgBrep, cyls_perF, idx_F_Start, idxs_Fs_Cocyl_In, idxs_Fs_Fails_In, fTol_IsCyl, fTol_Angle_Deg):\r\n\r\n    idxs_Fs_Cocyl_Out = idxs_Fs_Cocyl_In[:]\r\n    idxs_Fs_Fails_Out = idxs_Fs_Fails_In[:]\r\n\r\n    idxs_FAs = sorted(rgBrep.Faces[idx_F_Start].AdjacentFaces())\r\n    #sEval = \"idxs_FAs\"; print(sEval,'=',eval(sEval))\r\n\r\n    if len(idxs_FAs) == 0:\r\n        return idxs_Fs_Cocyl_Out, idxs_Fs_Fails_Out\r\n\r\n    cyl_This = cyls_perF[idx_F_Start]\r\n\r\n    for iF_Adj in idxs_FAs:\r\n        if iF_Adj not in cyls_perF:\r\n            continue\r\n\r\n        if iF_Adj in idxs_Fs_Cocyl_Out:\r\n            continue\r\n\r\n        if iF_Adj in idxs_Fs_Fails_In:\r\n            continue\r\n\r\n        #sEval = \"iF, iF_Adj\"; print(sEval,'=',eval(sEval))\r\n\r\n        #sEval = \"cyls_perF[iF].IsFinite\"; print(sEval,'=',eval(sEval))\r\n\r\n        cyl_Other = cyls_perF[iF_Adj]\r\n\r\n        if _are_cylinders_colcylindrical(\r\n            cylA=cyl_This,\r\n            cylB=cyl_Other,\r\n            distanceTolerance=fTol_IsCyl,\r\n            angleTolerance=fTol_Angle_Deg\r\n        ):\r\n            idxs_Fs_Cocyl_Out.append(iF_Adj)\r\n        else:\r\n            idxs_Fs_Fails_Out.append(iF_Adj)\r\n\r\n        #if not cyls_perF[iF].IsFinite and not cyls_perF[iF_Adj].IsFinite:\r\n        #    if cyls_perF[iF].Axis.EpsilonEquals(\r\n        #        cyls_perF[iF_Adj].Axis, epsilon=fTol_IsCyl\r\n        #    ):\r\n        #        if cyls_perF[iF].Center.EpsilonEquals(\r\n        #            cyls_perF[iF_Adj].Center, epsilon=fTol_IsCyl\r\n        #        ):\r\n        #            cyls_Out.append(cyls_perF[iF])\r\n        #            continue\r\n\r\n    return idxs_Fs_Cocyl_Out, idxs_Fs_Fails_Out\r\n\r\n\r\ndef _get_lists_of_face_indices_for_cocylindric_faces(rgBrep, cyls_perF, fTol_IsCyl, fTol_Angle_Deg):\r\n\r\n    idxs_Fs_perCyl_Out = [] # List of lists of int indices.\r\n\r\n    idxs_Fs_Processed = [] # Flat list.\r\n\r\n    for i, iF in enumerate(sorted(cyls_perF)):\r\n        #print(\"{} of {}\".format(i+1, len(cyls_perF)))\r\n        if i == 4:\r\n            pass\r\n\r\n        if iF in idxs_Fs_Processed:\r\n            continue\r\n\r\n        idxs_Fs_Cocyls = [iF]\r\n        idxs_Fs_Fails = idxs_Fs_Processed\r\n\r\n        i = 0\r\n\r\n        while True:\r\n            sc.escape_test()\r\n\r\n            iF_Start = idxs_Fs_Cocyls[i]\r\n\r\n            idxs_Fs_Cocyls_Res, idxs_Fs_Fails_Res = _findContiguousCocylindricFacesOf1Face(\r\n                rgBrep,\r\n                cyls_perF,\r\n                iF_Start,\r\n                idxs_Fs_Cocyls,\r\n                idxs_Fs_Fails,\r\n                fTol_IsCyl,\r\n                fTol_Angle_Deg=fTol_Angle_Deg)\r\n\r\n            idxs_Fs_Cocyls = idxs_Fs_Cocyls_Res\r\n            idxs_Fs_Fails = idxs_Fs_Fails_Res\r\n\r\n            i += 1\r\n\r\n            if i > (len(idxs_Fs_Cocyls) - 1):\r\n                break\r\n\r\n        idxs_Fs_perCyl_Out.append(idxs_Fs_Cocyls)\r\n        idxs_Fs_Processed.extend(idxs_Fs_Cocyls)\r\n\r\n    return idxs_Fs_perCyl_Out\r\n\r\n\r\ndef _find_closed_cylinders_per_face_sets(rgBrep, cyls_perF, idxFs_perCyl, fTol_IsCyl):\r\n    rgB_Dup = rgBrep.DuplicateBrep()\r\n    rgB_Dup.Faces.ShrinkFaces()\r\n\r\n    cyls_Out = []\r\n\r\n    for lst_idxF in idxFs_perCyl:\r\n        if len(lst_idxF) == 1:\r\n            iF = lst_idxF[0]\r\n            if rgB_Dup.Faces[iF].IsClosed(0) or rgB_Dup.Faces[iF].IsClosed(1):\r\n                cyls_Out.append(cyls_perF[iF])\r\n            continue\r\n\r\n        rgBs_DupFaces = [rgB_Dup.Faces[iF].DuplicateFace(duplicateMeshes=False) for iF in lst_idxF]\r\n\r\n        rgBs_Joined = rg.Brep.JoinBreps(\r\n            brepsToJoin=rgBs_DupFaces,\r\n            tolerance=2.0*sc.doc.ModelAbsoluteTolerance)\r\n\r\n        for _ in rgBs_DupFaces: _.Dispose()\r\n\r\n        if len(rgBs_Joined) != 1:\r\n            raise Exception(\"Number of breps: {}\".format(len(rgBs_Joined)))\r\n\r\n        rgB_Joined = rgBs_Joined[0]\r\n        #sc.doc.Objects.AddBrep(rgB_Joined)\r\n\r\n        cyl = cyls_perF[lst_idxF[0]]\r\n        #sEval = \"cyl.IsFinite\"; print(sEval,'=',eval(sEval))\r\n        cyl.Height1 = 1000.0\r\n        #sEval = \"cyl.IsFinite\"; print(sEval,'=',eval(sEval))\r\n        cyl.Height2 = -1000.0\r\n        #sEval = \"cyl.IsFinite\"; print(sEval,'=',eval(sEval))\r\n        srf_cyl = cyl.ToRevSurface()\r\n        #sc.doc.Objects.AddSurface(srf_cyl)\r\n\r\n        rgBs_CutUpSurface = rg.Brep.CutUpSurface(\r\n            surface=srf_cyl,\r\n            curves=[_ for _ in rgB_Joined.Edges if _.Valence == rg.EdgeAdjacency.Naked],\r\n            useEdgeCurves=True,\r\n            tolerance=sc.doc.ModelAbsoluteTolerance)\r\n\r\n        rgB_Joined.Dispose()\r\n\r\n        if len(rgBs_CutUpSurface) != 1:\r\n            raise Exception(\"Number of breps: {}\".format(len(rgBs_CutUpSurface)))\r\n\r\n        rgB_CutUpSurface = rgBs_CutUpSurface[0]\r\n\r\n        rgB_CutUpSurface.Faces.ShrinkFaces()\r\n\r\n        #sc.doc.Objects.AddBrep(rgB_CutUpSurface)\r\n\r\n        if rgB_CutUpSurface.Faces[0].IsClosed(0) or rgB_CutUpSurface.Faces[0].IsClosed(1):\r\n            cyls_Out.append(cyl)\r\n\r\n        rgB_CutUpSurface.Dispose()\r\n\r\n    rgB_Dup.Dispose()\r\n\r\n    return cyls_Out\r\n\r\n\r\ndef _areLinesParallel(lineA, lineB, angleTolerance):\r\n    isParallelTo = lineA.Direction.IsParallelTo(\r\n        lineB.Direction,\r\n        angleTolerance=angleTolerance)\r\n    return isParallelTo != 0\r\n\r\n\r\ndef _areLinesCollinear(lineA, lineB, distanceTolerance, angleTolerance):\r\n    isParallelTo = lineA.Direction.IsParallelTo(\r\n        lineB.Direction,\r\n        angleTolerance=angleTolerance)\r\n    if isParallelTo == 0:\r\n        return False\r\n\r\n    #bSuccess, tA, tB = rg.Intersect.Intersection.LineLine(lineA, lineB)\r\n    ## bSuccess will be False if lines are parallel.\r\n    #if bSuccess:\r\n    #    return False\r\n\r\n    ptB = lineB.From\r\n    ptA = lineA.ClosestPoint(ptB, limitToFiniteSegment=False)\r\n    dist = ptA.DistanceTo(ptB)\r\n    return dist <= distanceTolerance\r\n\r\n\r\ndef _create_geom_to_mark_possible_mismatches(cyls_Closed_perB, fTol_Dist, fTol_Angle_Deg, fTol_Dist_Ignore, fTol_Angle_Ignore_Deg):\r\n    fTol_Mismatch_Angle_Rad = Rhino.RhinoMath.ToRadians(fTol_Angle_Deg)\r\n    fAngleTol_Ignore_Rad = Rhino.RhinoMath.ToRadians(fTol_Angle_Ignore_Deg)\r\n\r\n    rgPts_Out = []\r\n    rgLines_Out = []\r\n\r\n    for iThisBrep in range(len(cyls_Closed_perB)-1):\r\n        Rhino.RhinoApp.SetCommandPromptMessage(\r\n            \"Comparing cylindrical features in brep {} of {} to others...\".format(\r\n                iThisBrep+1,\r\n                len(cyls_Closed_perB)))\r\n        for iOtherBrep in range(iThisBrep+1, len(cyls_Closed_perB)):\r\n            sc.escape_test()\r\n            cyls_This = cyls_Closed_perB[iThisBrep]\r\n            cyls_Other = cyls_Closed_perB[iOtherBrep]\r\n            for iCyl_This in range(len(cyls_This)):\r\n                cyl_This = cyls_This[iCyl_This]\r\n                center_This = cyl_This.Center\r\n                line_This = rg.Line(center_This, cyl_This.Axis)\r\n                for iCyl_Other in range(len(cyls_Other)):\r\n                    cyl_Other = cyls_Other[iCyl_Other]\r\n\r\n                    # WIP:\r\n\r\n                    #isParallelTo = cyl_This.Axis.IsParallelTo(\r\n                    #    cyl_Other.Axis,\r\n                    #    angleTolerance=angleTolerance)\r\n                    #sEval = \"isParallelTo\"; print(sEval,'=',eval(sEval))\r\n\r\n                    #if isParallelTo == 0:\r\n                    #    continue\r\n\r\n                    #angle_Rad = rg.Vector3d.VectorAngle(cyl_This.Axis, cyl_Other.Axis) # Values range from 0 to 180 degrees.\r\n                    #angle_Deg = Rhino.RhinoMath.ToDegrees(angle_Rad)\r\n                    #sEval = \"angle_Deg\"; print(sEval,'=',eval(sEval))\r\n                    #if angle_Rad > tol_Rad:\r\n                    #    continue\r\n\r\n                    center_Other = cyl_Other.Center\r\n                    line_Other = rg.Line(cyl_Other.Center, cyl_Other.Axis)\r\n\r\n                    if _areLinesParallel(\r\n                        line_This,\r\n                        line_Other,\r\n                        angleTolerance=fTol_Mismatch_Angle_Rad\r\n                    ):\r\n                        if _areLinesCollinear(\r\n                            line_This,\r\n                            line_Other,\r\n                            distanceTolerance=fTol_Dist,\r\n                            angleTolerance=fTol_Mismatch_Angle_Rad\r\n                        ):\r\n                            continue\r\n                        ptA = line_This.From\r\n                        ptB = line_Other.ClosestPoint(ptA, limitToFiniteSegment=False)\r\n                        bAreParallel = True\r\n                    else:\r\n                        bAreParallel = False\r\n                        if not _areLinesParallel(\r\n                            line_This,\r\n                            line_Other,\r\n                            angleTolerance=fAngleTol_Ignore_Rad\r\n                        ):\r\n                            continue\r\n\r\n                        bSuccess, tA, tB = rg.Intersect.Intersection.LineLine(line_This, line_Other)\r\n                        if not bSuccess:\r\n                            # Will be False if lines are parallel.\r\n                            raise Exception(\"Intersection.LineLine returned False.\")\r\n                            continue\r\n                        ptA = line_This.PointAt(tA)\r\n                        ptB = line_Other.PointAt(tB)\r\n\r\n                    dist = ptA.DistanceTo(ptB)\r\n\r\n                    if bAreParallel and (fTol_Dist < dist <= fTol_Dist_Ignore):\r\n                        pass\r\n                    elif not bAreParallel and (dist <= fTol_Dist_Ignore):\r\n                        pass\r\n                    else:\r\n                        continue\r\n\r\n                    rgPts_Out.extend((ptA, ptB))\r\n                    rgLines_Out.extend(())\r\n                    if ptA.DistanceTo(center_This) > 100.0 * fTol_Dist:\r\n                        rgLines_Out.append(rg.Line(center_This, ptA))\r\n                    else:\r\n                        rgLines_Out.append(line_This)\r\n                    if ptA.DistanceTo(center_Other) > 100.0 * fTol_Dist:\r\n                        rgLines_Out.append(rg.Line(center_Other, ptB))\r\n                    else:\r\n                        rgLines_Out.append(line_Other)\r\n\r\n    return rgPts_Out, rgLines_Out\r\n\r\n\r\ndef processBreps(rgBreps, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fTol_IsCyl = getOpt('fTol_IsCyl')\r\n    fTol_Dist = getOpt('fTol_Dist')\r\n    fTol_Angle_Deg = getOpt('fTol_Angle_Deg')\r\n    fTol_Dist_Ignore = getOpt('fTol_Dist_Ignore')\r\n    fTol_Angle_Ignore_Deg = getOpt('fTol_Angle_Ignore_Deg')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n    if len(rgBreps) == 0:\r\n        return\r\n\r\n    if len(rgBreps) == 1:\r\n        return\r\n\r\n    rgBs_withCyls = []\r\n    dicts_face_cyl_perB = []\r\n    Rhino.RhinoApp.SetCommandPromptMessage(\"Collecting cylinders in each brep...\")\r\n    for rgB in rgBreps:\r\n        dict_face_cyl = _collect_cylinders_per_face_index(\r\n            rgB,\r\n            fTol_IsCyl)\r\n        if dict_face_cyl:\r\n            rgBs_withCyls.append(rgB)\r\n            dicts_face_cyl_perB.append(dict_face_cyl)\r\n\r\n    idxFs_perCyl_perB = []\r\n    Rhino.RhinoApp.SetCommandPromptMessage(\"Finding cocylindric faces in each brep...\")\r\n    for iB, rgB in enumerate(rgBs_withCyls):\r\n        #Rhino.RhinoApp.SetCommandPromptMessage(\r\n        #    \"Processing cylinders from brep {} against brep {}, both out of {}\".format(\r\n        #        iThisBrep+1, iOtherBrep+1, len(cyls_Closed_perB)))\r\n\r\n        dict_face_cyl = dicts_face_cyl_perB[iB]\r\n        idxFs_perCyl = _get_lists_of_face_indices_for_cocylindric_faces(\r\n            rgB,\r\n            dict_face_cyl,\r\n            fTol_IsCyl,\r\n            fTol_Angle_Deg)\r\n        #sEval = \"idxFs_perCyl\"; print(sEval,'=',eval(sEval))\r\n        idxFs_perCyl_perB.append(idxFs_perCyl)\r\n\r\n    cyls_Closed_perB = []\r\n    #sCPM = \r\n    #Rhino.RhinoApp.SetCommandPromptMessage(\"Finding closed, cocylindric faces in each brep...\")\r\n\r\n    for iB, rgB in enumerate(rgBs_withCyls):\r\n        sc.escape_test()\r\n        Rhino.RhinoApp.SetCommandPromptMessage(\r\n            \"Finding closed, cocylindric faces in brep {} of {}\".format(\r\n                iB+1, len(rgBs_withCyls)))\r\n\r\n        dict_face_cyl = dicts_face_cyl_perB[iB]\r\n        idxFs_perCyl = idxFs_perCyl_perB[iB]\r\n        cyls_Closed = _find_closed_cylinders_per_face_sets(\r\n            rgB,\r\n            dict_face_cyl,\r\n            idxFs_perCyl,\r\n            fTol_IsCyl)\r\n        cyls_Closed_perB.append(cyls_Closed)\r\n\r\n    #sEval = \"len(rdBs_withCyls)\"; print(sEval,'=',eval(sEval))\r\n    #sEval = \"len(cyls_Closed_perB)\"; print(sEval,'=',eval(sEval))\r\n\r\n    Rhino.RhinoApp.SetCommandPromptMessage(\"Finding possible mismatches...\")\r\n\r\n    return _create_geom_to_mark_possible_mismatches(\r\n        cyls_Closed_perB,\r\n        fTol_Dist=fTol_Dist,\r\n        fTol_Angle_Deg=fTol_Angle_Deg,\r\n        fTol_Dist_Ignore=fTol_Dist_Ignore,\r\n        fTol_Angle_Ignore_Deg=fTol_Angle_Ignore_Deg)\r\n\r\n\r\ndef processBrepObjects(rdBreps, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fTol_IsCyl = getOpt('fTol_IsCyl')\r\n    fTol_Angle_Deg = getOpt('fTol_Angle_Deg')\r\n    fTol_Dist = getOpt('fTol_Dist')\r\n    fTol_Dist_Ignore = getOpt('fTol_Dist_Ignore')\r\n    fTol_Angle_Ignore_Deg = getOpt('fTol_Angle_Ignore_Deg')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    if len(rdBreps) == 0:\r\n        print(\"No breps.\")\r\n        return\r\n\r\n    if len(rdBreps) == 1:\r\n        print(\"Only 1 brep in input, so no mismatches can be evaluated.\")\r\n        return\r\n\r\n    rgBreps = []\r\n\r\n    for rdB in rdBreps:\r\n        try:\r\n            rgBreps.append(rdB.BrepGeometry)\r\n        except:\r\n            ss = [\r\n                \"Block instances found\",\r\n                \"_ExplodeBlock the instances and rerun this script.\",\r\n                \"(Remember to _UndoMultiple the _ExplodeBlock later.)\",\r\n                ]\r\n            raise Exception(\"\\n\".join(ss))\r\n\r\n    return processBreps(\r\n        rgBreps,\r\n        fTol_IsCyl=fTol_IsCyl,\r\n        fTol_Angle_Deg=fTol_Angle_Deg,\r\n        fTol_Dist=fTol_Dist,\r\n        fTol_Dist_Ignore=fTol_Dist_Ignore,\r\n        fTol_Angle_Ignore_Deg=fTol_Angle_Ignore_Deg,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n\r\ndef main():\r\n\r\n    rdBreps = getInput()\r\n    if not rdBreps: return\r\n\r\n    fTol_IsCyl = Opts.values['fTol_IsCyl']\r\n    fTol_Dist = Opts.values['fTol_Dist']\r\n    fTol_Angle_Deg = Opts.values['fTol_Angle_Deg']\r\n    fTol_Dist_Ignore = Opts.values['fTol_Dist_Ignore']\r\n    fTol_Angle_Ignore_Deg = Opts.values['fTol_Angle_Ignore_Deg']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled=False\r\n\r\n    #res, objrefs = ri.RhinoGet.GetMultipleObjects(\r\n    #    \"Select breps <All normal>\",\r\n    #    acceptNothing=True,\r\n    #    filter=rd.ObjectType.Brep)\r\n    #if res != Rhino.Commands.Result.Success: return\r\n\r\n\r\n    rv = processBrepObjects(\r\n        rdBreps,\r\n        fTol_IsCyl=fTol_IsCyl,\r\n        fTol_Angle_Deg=fTol_Angle_Deg,\r\n        fTol_Dist=fTol_Dist,\r\n        fTol_Dist_Ignore=fTol_Dist_Ignore,\r\n        fTol_Angle_Ignore_Deg=fTol_Angle_Ignore_Deg,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n    if not rv: return\r\n\r\n    rgPts_Res, rgLines_Res = rv\r\n\r\n    if not (rgPts_Res or rgLines_Res):\r\n        print(\"No possible mismatches found.\")\r\n        return\r\n\r\n    attrib_Red = rd.ObjectAttributes()\r\n    attrib_Red.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n    attrib_Red.ObjectColor = Color.Red\r\n\r\n    gPts_Out = []\r\n    gCrvs_Out = []\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    for pt in rgPts_Res:\r\n        gPt = sc.doc.Objects.AddPoint(pt, attrib_Red)\r\n        if gPt == Guid.Empty: raise Exception(\"Point could not be added.\")\r\n        gPts_Out.append(gPt)\r\n        sc.doc.Objects.Select(gPt)\r\n\r\n    for line in rgLines_Res:\r\n        gCrv = sc.doc.Objects.AddLine(line, attrib_Red)\r\n        if gCrv == Guid.Empty: raise Exception(\"Curve could not be added.\")\r\n        gCrvs_Out.append(gCrv)\r\n        sc.doc.Objects.Select(gCrv)\r\n\r\n    if bEcho:\r\n        print(\"Possible mismatches found. {} points and {} curves added.\".format(len(gPts_Out), len(gCrvs_Out)))\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}