{
  "source_url": "https://github.com/livestock3d/livestock/blob/28de793d47100f46814fd0f437b0b862802b1a02/archive/rain.py",
  "repo": "livestock3d/livestock",
  "repo_stars": 9,
  "repo_description": "Livestock is a package for Grasshopper providing components for modelling water movement and hydrothermal effects around buildings to enable and evaluate sustainable solutions, where those effects are incorporated.",
  "license": "GPL-3.0",
  "filepath": "archive/rain.py",
  "instruction": null,
  "code": "__author__ = \"Christian Kongsgaard\"\n__license__ = \"MIT\"\n__version__ = \"0.0.1\"\n\n# -------------------------------------------------------------------------------------------------------------------- #\n# Imports\n\n# Module imports\nimport threading\nimport queue\nimport pymesh as pm\nimport numpy as np\n\n# Livestock imports\nimport livestock_linux.geometry as ls_geo\n\n# -------------------------------------------------------------------------------------------------------------------- #\n# Livestock Rain and Flow Library\n\n\ndef drain_mesh_paths(files_path):\n    \"\"\" Estimates the trail of a drainage path on a mesh. \"\"\"\n\n    # Get files\n    mesh_path = files_path + '/drain_mesh.obj'\n    cpus = open(files_path + '/cpu.txt', 'r').readline()\n\n    # Load mesh\n    mesh = pm.load_mesh(mesh_path)\n    mesh.enable_connectivity()\n\n    # Result list\n    drain_points = []\n    drain_faces = []\n\n    # Initialize mesh data\n    mesh.add_attribute('face_centroid')\n    mesh.add_attribute('face_index')\n    start_pts = mesh.get_attribute('face_centroid')\n    center_z = []\n    face_index = mesh.get_attribute('face_index')\n    faces = mesh.faces\n    vertices = mesh.vertices\n    face_destination = []\n    ray_points = []\n\n    # Construct start point list\n    start_points = []\n    i = 0\n    while i < len(start_pts):\n        for j in range(0, len(face_index)):\n            start_points.append([face_index[j], np.array([start_pts[i], start_pts[i+1], start_pts[i+2]])])\n            center_z.append(start_pts[i + 2])\n            i += 3\n\n    # Helper functions\n    def face_vertices(face_index_):\n        face = faces[int(face_index_)]\n        v0 = vertices[face[0]]\n        v1 = vertices[face[1]]\n        v2 = vertices[face[2]]\n        return v0, v1, v2\n\n    def over_edge(point):\n        \"\"\"Handles when paths goes over the edge.\"\"\"\n\n        for k in range(0, len(face_index)):\n            if center_z[k] >= point[2]:\n                pass\n\n            elif center_z[k] <= point[2]:\n                # check to see if a similar point has already been processed\n\n                for j_ in range(0, len(ray_points)):\n                    if np.allclose(point, ray_points[j_]):\n                        return face_destination[j_]\n\n                # if not shoot ray\n                v = face_vertices(k)\n                intersect = ls_geo.ray_triangle_intersection(point, np.array([0, 0, -1]), v)\n\n                if intersect[0]:\n                    ray_points.append(point)\n                    face_destination.append(k)\n                    return k\n\n                else:\n                    pass\n\n            else:\n                print('Error in over_edge function!')\n                print('centerZ:', center_z[k])\n                print('point:', point)\n                return None\n\n    # Task function\n    def drain_path():\n\n        while 1:\n            # Get job from queue\n            job = q.get()\n            index = job[0]\n            pt = job[1]\n\n            particles = []\n            particles.append(pt)\n            face_indices = []\n            face_indices.append(int(index))\n            run = True\n            # print('index:',index)\n            # print('point:',pt)\n\n            while run:\n                # Get adjacent faces\n                adjacent_faces = mesh.get_face_adjacent_faces(int(index))\n\n                # Check if center points of adjacent faces have a lower Z-value\n                z = None\n\n                for ad in adjacent_faces:\n                    if not z:\n                        z = center_z[ad]\n                        i = ad\n\n                    elif z > center_z[ad]:\n                        z = center_z[ad]\n                        i = ad\n\n                if z > pt[2]:\n                    v0, v1, v2 = face_vertices(index)\n                    pt = ls_geo.lowest_face_vertex(v0, v1, v2)\n\n                    if len(adjacent_faces) < 3:\n                        over = over_edge(pt)\n\n                        if over:\n                            particles.append(pt)\n                            index = over\n                            pt = start_points[index][1]\n\n                        else:\n                            run = False\n\n                    else:\n                        run = False\n\n                else:\n                    index = start_points[i][0]\n                    pt = start_points[i][1]\n\n                particles.append(pt)\n                face_indices.append(int(index))\n            #print('particles:',particles)\n            #print(len(particles))\n\n            # End task\n            drain_points.append(particles)\n            drain_faces.append(face_indices)\n            q.task_done()\n\n    # Call task function\n    q = queue.Queue()\n\n    for i in range(int(cpus)):\n        t = threading.Thread(target=drain_path)\n        t.setDaemon(True)\n        t.start()\n\n    # Put jobs in queue\n    for pts in start_points:\n        q.put(pts)\n\n    # Wait until all tasks in the queue have been processed\n    q.join()\n\n    # Open file, which the points should be written to\n    pt_file = open('drain_points.txt', 'w')\n    face_file = open('drain_faces.txt', 'w')\n\n    # Write points to file\n    for particles in drain_points:\n        for pt in particles:\n            pt_file.write(str(pt[0]) + ',' + str(pt[1]) + ',' + str(pt[2]) + '\\t')\n        pt_file.write('\\n')\n\n    # Write face indices to file\n    for curves in drain_faces:\n        for index in curves:\n            face_file.write(str(index) + '\\t')\n        face_file.write('\\n')\n\n\n    #Close outfiles and save mesh\n    pt_file.close()\n    face_file.close()\n    pm.save_mesh('new_drain_mesh.obj', mesh)\n\n    return True\n\n\ndef drain_pools(path):\n    import pymesh as pm\n    from numpy import array, allclose\n    from numpy import sum as npsum\n    from scipy.optimize import newton\n\n    # Paths\n    meshFile = path + '/drainMesh.obj'\n    endPtsFile = path + '/EndPoints.txt'\n    volPtsFile = path + '/VolumePoints.txt'\n\n    # Initialize Mesh\n    mesh = pm.load_mesh(meshFile)\n    mesh.enable_connectivity()\n    mesh.add_attribute('face_centroid')\n    mesh.add_attribute('face_index')\n    mesh.add_attribute('face_area')\n    cenPts = mesh.get_attribute('face_centroid')\n    faceIndex = mesh.get_attribute('face_index')\n    faceArea = mesh.get_attribute('face_area')\n    faceVert = mesh.faces\n    vertices = mesh.vertices\n    #print(mesh.get_attribute_names())\n    boolWarning = None\n    poolWarning = None\n\n    # Construct face center list\n    faceCen = []\n    i = 0\n    while i < len(cenPts):\n        faceCen.append(array([float(cenPts[i]), float(cenPts[i + 1]), float(cenPts[i + 2])]))\n        i += 3\n\n    # Load points\n    ptsLine = open(endPtsFile, 'r').readlines()\n    endPts = []\n    for l in ptsLine:\n        l = l[:-1]\n        l = l.split(',')\n        endPts.append(array([float(l[0]), float(l[1]), float(l[2])]))\n    #print(len(endPts))\n\n    # Load volumes\n    volLine = open(volPtsFile, 'r').readlines()\n    vol = []\n    for v in volLine:\n        v = v[:-1]\n        vol.append(float(v))\n\n    pts = []\n    vols = []\n    fI = []\n\n    for i,pt in enumerate(endPts):\n\n        # Check if point is in list:\n        if i == 0:\n            pts.append(pt)\n            vols.append(vol[i])\n\n            # Find equivalent face center of points\n            for index, cen in enumerate(faceCen):\n                if allclose(cen,pt):\n                    fI.append(index)\n                    break\n\n        else:\n            found = False\n            j = 0\n            while j < len(pts):\n                # If it is in list: add volume\n                if allclose(pts[j], pt):\n                    vols[j] += vol[i]\n                    j = len(pts)\n                    found = True\n                j += 1\n\n            # Else: put point and volume in list\n            if not found:\n                pts.append(pt)\n                vols.append(vol[i])\n\n                # Find equivalent face center of points\n                for index, cen in enumerate(faceCen):\n                    if allclose(cen,pt):\n                        fI.append(index)\n                        break\n\n    # Pool function\n    def pool(faceIndex,point,volume):\n        found = False\n\n        # Compute first z-value\n        A = faceArea[faceIndex]\n        h = volume/A\n        Z = point[2]+h\n\n        # Initialize face index, z-values and areas\n        adjFace = [faceIndex, ]\n        faceZ = [point[2],]\n        faceA = [A,]\n\n        # Find adjacent faces\n        for faceIn in adjFace:\n\n            for af in mesh.get_face_adjacent_faces(faceIn):\n\n                # Get Z-value of face-centroid\n                fc = faceCen[af][2]\n\n                # Append them to list if their centroid is lower than the computed Z-value and are not already in list\n                if fc < Z:\n                    if af not in adjFace:\n\n                        # If current face holds a volume add that volume to the current volume\n                        if af in fI:\n                            #print('found in fI')\n                            queueIndex = fI.index(af)\n\n                            if queueIndex in notDoneList:\n                                #print('found in notDoneList')\n                                volume += vols[queueIndex]\n                                notDoneList.remove(queueIndex)\n                                doneList.append(queueIndex)\n\n                            elif queueIndex in doneList:\n                                #print('found in doneList')\n                                vols[queueIndex] += volume\n                                notDoneList.append(queueIndex)\n                                doneList.remove(queueIndex)\n                                return\n\n                            else:\n                                pass\n\n                        # Append Z-value, area and face-index\n                        faceZ.append(fc)\n                        faceA.append(faceArea[af])\n                        adjFace.append(int(af))\n\n                        # Convert to numpy array\n                        faZ = array(faceZ)\n                        faA = array(faceA)\n\n                        # Compute new z-value\n                        Z = (npsum(faZ*faA)+volume)/npsum(faA)\n\n        #print('Approx Z:',Z)\n\n        # Create approximate volume mesh\n        apxVert = []\n        apxFace = []\n        iApxVert = 0\n\n        for af in adjFace:\n            iApxVert = len(apxVert)\n            apxVert.append(vertices[faceVert[af][0]])\n            apxVert.append(vertices[faceVert[af][1]])\n            apxVert.append(vertices[faceVert[af][2]])\n            apxFace.append([iApxVert, iApxVert + 1, iApxVert + 2])\n\n        # Create boundary mesh\n        apxVert = array(apxVert)\n        apxFace = array(apxFace)\n        apxMesh = pm.form_mesh(apxVert, apxFace)\n\n        # Boundary Box\n        maxmin = apxMesh.bbox\n        x1, y1, z1 = maxmin[0]\n        x2, y2, z2 = maxmin[1]*1.1  # Increase Bbox with 10%\n        x1 = x1*0.9  # Decrease Bbox with 10%\n        y1 = y1*0.9  # Decrease Bbox with 10%\n\n        #print('apxMesh:',maxmin[0],'\\n\\t',maxmin[1])\n\n        zMax = mesh.bbox[1][2]\n        #print('zMax:',zMax)\n        #pm.save_mesh('apxmesh.obj', apxMesh)\n\n        # Findheight helper functions\n        def createBbox(z):\n            bVert = []\n            bFace = []\n            bVox = []\n\n            # Add vertices\n            bVert.append(array([x1, y1, z1]))  # 0\n            bVert.append(array([x1, y2, z1]))  # 1\n            bVert.append(array([x1, y2, z]))  # 2\n            bVert.append(array([x1, y1, z]))  # 3\n\n            bVert.append(array([x2, y2, z]))  # 4\n            bVert.append(array([x2, y2, z1]))  # 5\n            bVert.append(array([x2, y1, z1]))  # 6\n            bVert.append(array([x2, y1, z]))  # 7\n\n            # Add faces\n            bFace.append([0, 1, 3])  # side 1\n            bFace.append([1, 2, 3])  # side 1\n            bFace.append([0, 3, 7])  # side 2\n            bFace.append([0, 6, 7])  # side 2\n            bFace.append([7, 6, 5])  # side 3\n            bFace.append([5, 7, 4])  # side 3\n            bFace.append([4, 5, 1])  # side 4\n            bFace.append([4, 2, 1])  # side 4\n            bFace.append([0, 1, 6])  # side 5\n            bFace.append([1, 5, 6])  # side 5\n            bFace.append([3, 7, 2])  # side 6\n            bFace.append([2, 7, 4])  # side 6\n\n            # Add voxels\n            bVox.append([0, 2, 3, 7])\n            bVox.append([0, 1, 2, 7])\n            bVox.append([0, 1, 6, 7])\n            bVox.append([2, 4, 5, 7])\n            bVox.append([1, 2, 5, 6])\n            bVox.append([2, 4, 6, 7])\n\n            # Create boundary mesh\n            bVert = array(bVert)\n            bFace = array(bFace)\n            bVox = array(bVox)\n            bMesh = pm.form_mesh(bVert, bFace, bVox)\n            #pm.save_mesh('bMesh.obj', bMesh)\n\n            return bMesh\n\n        def getVolMesh(newMesh, bottomFaces, z):\n\n            # Prepare to create volume mesh\n            newMeshVert = newMesh.vertices\n            volVert = []\n            volFace = []\n            volVox = []\n\n            # Create volume mesh from bottom part of mesh\n            for f in bottomFaces:\n                iVer = len(volVert)\n\n                oldVerts = []\n                newVerts = []\n                for v in f:\n                    oldVerts.append(newMeshVert[v])\n                    newV = array([newMeshVert[v][0], newMeshVert[v][1], z])\n                    newVerts.append(newV)\n\n                # Append vertices\n                volVert += oldVerts\n                volVert += newVerts\n\n                # Append faces\n                volFace.append([iVer, iVer + 1, iVer + 2])\n                volFace.append([iVer + 3, iVer + 4, iVer + 5])\n\n                # Append voxels\n                volVox.append([iVer, iVer + 1, iVer + 2, iVer + 3])\n                volVox.append([iVer + 1, iVer + 3, iVer + 4, iVer + 5])\n                volVox.append([iVer + 1, iVer + 2, iVer + 3, iVer + 5])\n\n            # Create volume mesh\n            volVert = array(volVert)\n            volFace = array(volFace)\n            volVox = array(volVox)\n            volMesh = pm.form_mesh(volVert, volFace, volVox)\n\n            return volMesh\n\n        def intersectAndBottomFaces(bMesh, z):\n            warning = None\n\n            # Make intersection with auto boolean engine\n            newMesh = pm.boolean(mesh, bMesh, 'intersection')\n\n            if newMesh.num_faces == 0:\n                # Change boolean engine to Cork\n                warning = 'Changing Boolean Engine to Cork!'\n                print(warning)\n                newMesh = pm.boolean(bMesh, mesh, 'difference', engine='cork')\n\n            #pm.save_mesh('intMesh.obj', newMesh)\n\n            # Get bottom part of mesh\n            try:\n                newSource = newMesh.get_attribute('source')\n                newFace = newMesh.faces\n                bottomFaces = []\n\n                for i, s in enumerate(newSource):\n                    if int(s) == 1:\n                        bottomFaces.append(newFace[i])\n\n                return newMesh, bottomFaces, warning\n\n            except RuntimeError:\n                # Try different approach to getting bottom faces\n                newMesh.add_attribute('face_centroid')\n                newFace = newMesh.faces\n                # print('len newFace:',len(newFace))\n                # print('first newFace:',newFace[0])\n                newCen = newMesh.get_attribute('face_centroid')\n                bottomFaces = []\n\n                for newFaceIndex in range(len(newFace)):\n                    newCenZ = newCen[newFaceIndex * 3 + 2]\n                    if newCenZ < z:\n                        bottomFaces.append(newFace[newFaceIndex])\n\n                return newMesh, bottomFaces, warning\n\n        # Volume function to solve\n        def findHeight(z):\n            #print('current z:',z)\n\n            # Check if pools will overflow mesh\n            if z > zMax:\n                z = zMax\n\n            # Create Bbox\n            bMesh = createBbox(z)\n\n            # Make intersection\n            newMesh, bottomFaces, warning = intersectAndBottomFaces(bMesh, z)\n\n            # Create volume mesh\n            volMesh = getVolMesh(newMesh, bottomFaces, z)\n\n            if z == zMax:\n                return 0\n\n            else:\n                # Compute volume\n                volMesh.add_attribute('voxel_volume')\n                volVol = volMesh.get_attribute('voxel_volume')\n                volVol = sum(list((map(abs, volVol))))\n\n                #print('volume',volume)\n                #print('volVol1',volVol)\n\n                return volume - volVol\n\n        # Get final height\n        zFinal = newton(findHeight,Z)\n\n        # Create final mesh\n        def finalMesh(z):\n            poolWarning = None\n\n            # Check if pools will overflow mesh\n            if z > zMax:\n                z = zMax\n                poolWarning = 'The pool have a greater volume than the mesh can contain. Pool set to fill entire mesh.'\n\n            # Create Bbox\n            bMesh = createBbox(z)\n\n            # Make intersection\n            newMesh, bottomFaces, boolWarning = intersectAndBottomFaces(bMesh, z)\n\n            # Create volume mesh\n            volMesh = getVolMesh(newMesh, bottomFaces, z)\n\n            volMesh.add_attribute('voxel_volume')\n            volVol = volMesh.get_attribute('voxel_volume')\n            volVol = sum(list(map(abs, volVol)))\n\n            # Clean up mesh\n            volMesh, info = pm.remove_isolated_vertices(volMesh)\n            #print('num vertex removed', info[\"num_vertex_removed\"])\n            volMesh, info = pm.remove_duplicated_faces(volMesh)\n\n            return volMesh, volVol, poolWarning, poolWarning\n\n        # Save final mesh\n        #print('zFinal',zFinal,'type:',type(zFinal))\n        finalMesh, finalVol, poolWarning, boolWarning = finalMesh(zFinal)\n        meshName = \"poolMesh_\" + str(faceIndex) + \".obj\"\n        hullMesh = pm.compute_outer_hull(finalMesh)\n        pm.save_mesh(meshName, hullMesh)\n\n        print(' ')\n        print('volume',\"{0:.3f}\".format(volume))\n        print('computed volume',\"{0:.3f}\".format(finalVol))\n        print('closed?',finalMesh.is_closed())\n        print(' ')\n\n        return meshName\n\n\n    # Initialize pool-loop\n    Z = []\n    i = 0\n    doneList = []\n    notDoneList = list(range(0,len(pts)))\n    loopLength = len(notDoneList)\n    meshNames = []\n\n    # Use pool function on each set of points\n    while i < loopLength:\n        I = notDoneList.pop(i)\n        names = pool(fI[I],pts[I],vols[I])\n\n        # Put meshNames in name list\n        if names:\n            if not names in meshNames:\n                meshNames.append(names)\n            else:\n                pass\n\n        doneList.append(i)\n        loopLength = len(notDoneList)\n\n    # Open InData and edit last line\n    file_obj = open(\"InData.txt\",'r')\n    file = file_obj.readlines()\n    file_obj.close()\n\n    mNames = ''\n    for n in meshNames:\n        mNames += ',' + n\n\n    file[6] = 'meshNames.txt' + mNames\n\n    outfile_obj = open(\"InData.txt\", 'w')\n    outfile_obj.writelines(file)\n\n    # Write meshNames.txt\n    file_obj = open(\"meshNames.txt\", 'w')\n    file_obj.write(mNames)\n    file_obj.close()\n\n    #print('function warn', [boolWarning, poolWarning])\n    if boolWarning or poolWarning:\n        return [boolWarning, poolWarning]\n    else:\n        return None\n\n\nclass simple_rain():\n    def __init__(self, cpus, precipitation, windSpeed, windDirection, testPoints, testVectors, context, temperature, k):\n        self.prec = precipitation\n        self.windSpeed = windSpeed\n        self.windDir = windDirection\n        self.testPts = testPoints\n        self.testVecs = testVectors\n        self.context = context\n        self.temp = temperature\n        self.kMiss = k[0]\n        self.kHit = k[1]\n        self.dirVec = False\n        self.hourlyResult = False\n        self.wdr = False\n        self.xyAngles = []\n        self.yzAngles = []\n        self.cpus = int(cpus)\n\n    # Final function\n    def rainHits(self):\n        from math import degrees, exp, log, acos, sqrt, pi, cos, radians\n        from rhinoscriptsyntax import XformMultiply, VectorCreate, AddPoint, VectorTransform, XformRotation2\n        from Rhino.Geometry.Intersect.Intersection import RayShoot\n        from Rhino.Geometry import Ray3d\n        import threading\n        import Queue\n\n        # Helper functions\n\n        def rain_vector(Vw, regn):\n\n            # Rain drop radius:\n            A = 1.3\n            p = 0.232\n            n = 2.25\n\n            if regn == 0:\n                return 0\n\n            def f_a(I):\n                return A * I ** p\n\n            a = f_a(regn)\n            r = a * exp(log(-log(0.5)) / n) / 1000\n\n            # Angle:\n            # rho_L = 1.2\n            # rho_w = 1000\n            # g = 9.81\n            # c = 0.3\n            # alpha = 3*c*rho_L*Vw^2*r^2/sqrt(4*r^4*(9*Vw^2*c^2*rho_L^2+64*g^2*r^2*rho_w^2))\n            # Simplified it becomes:\n\n            a = (0.54 * Vw ** 2 * r ** 2) / sqrt(r ** 4 * (1.1664 * Vw ** 2 + 6.159110400 * 10 ** 9 * r ** 2))\n            if a > 1:\n                a = 1\n            alpha = acos(a)\n\n            return alpha\n\n        def rotate_yz(angle):\n            return XformRotation2(angle, [1, 0, 0], [0, 0, 0])\n\n        def rotate_xy(angle):\n            return XformRotation2(angle, [0, 0, 1], [0, 0, 0])\n\n        # Correction of wind direction\n        def B_wind(angle, direction):\n            c = 360 - (angle + 90)\n            # print(c)\n\n            a = abs(c - direction)\n            if a < 180:\n                b = a\n            else:\n                b = 360 - a\n\n            return radians(b)\n\n        def rayShoot():\n            \"\"\"Build on: Ladybug - RayTrace\"\"\"\n\n            # Initialize\n            while not q.empty():\n                numOfBounce = 1\n                startPt, xyAngle, yzAngle = q.get()\n\n                vector = direction_vector\n                ray = Ray3d(startPt, vector)\n                # Check the wind direction\n                B = B_wind(xyAngle, self.windDir[i])\n                # print(B)\n                if B > pi / 2:\n                    # print('more than 90')\n                    hourly_rain.append(0)\n                    hourly_result.append(False)\n\n                else:\n                    # print('less than 90')\n                    # Compute rain amount\n                    K_wind = cos(B) / sqrt(\n                        1 + 1142 * (sqrt(self.prec[i]) / self.windSpeed[i] ** 4)) * exp(\n                        -12 / (self.windSpeed[i] * 5 * self.prec[i] ** (0.25)))\n\n                    # Shoot ray\n                    intPt = RayShoot(ray, [self.context], numOfBounce)\n\n                    # Check for intersection\n                    if intPt:\n                        # print('Intersection!')\n                        hourly_result.append(True)\n                        kRain = self.kHit\n                        # verticalFactor = (1/(90*K_wind*kRain)-1/90)*yzAngle\n                        # print(verticalFactor)\n                        hourly_rain.append((K_wind * kRain * self.prec[i]))\n\n                    else:\n                        # print('No intersection!')\n                        hourly_result.append(False)\n                        kRain = self.kMiss\n                        # verticalFactor = (1 / (90 * K_wind * kRain) - 1 / 90) * yzAngle\n                        # print('vf',verticalFactor)\n                        hourly_rain.append((K_wind * kRain * self.prec[i]))\n\n                # print('done')\n                q.task_done()\n\n        result = []\n        dirVec_hourly = []\n        wdr = []\n\n        for i in range(0, len(self.prec)):\n\n            if self.temp[i] <= -2 or self.windSpeed[i] <= 0 or self.prec[i] <= 0:\n                dirVec_hourly.append(None)\n                result.append([False] * len(self.testPts))\n\n            else:\n\n                # Rotate vectors towards the sky\n                R_v = rain_vector(self.windSpeed[i], self.prec[i])\n                towards_sky = rotate_yz(degrees(R_v))\n\n                # Rotate vectors towards the wind\n                w_d = self.windDir[i]\n                towards_wind = rotate_xy(w_d)\n\n                # Combine:\n                transformation = XformMultiply(towards_wind, towards_sky)\n                north_vector = VectorCreate(AddPoint(0, 0, 0), AddPoint(0, -1, 0))\n                direction_vector = VectorTransform(north_vector, transformation)\n                hourly_result = []\n                hourly_rain = []\n\n                # Put jobs in queue\n                q = Queue.Queue()\n                for fi, pts in enumerate(self.testPts):\n                    q.put((pts, self.xyAngles[fi], self.yzAngles[fi]))\n                # Call task function\n\n                for c in range(self.cpus):\n                    t = threading.Thread(target=rayShoot)\n                    t.setDaemon(True)\n                    t.start()\n\n                # break\n                # Wait until all tasks in the queue have been processed\n                q.join()\n\n                dirVec_hourly.append(direction_vector)\n                result.append(hourly_result)\n                wdr.append(hourly_rain)\n\n        self.hourlyResult = result\n        self.dirVec = dirVec_hourly\n        self.wdr = wdr\n\n    def computeAngles(self):\n        import Rhino.Geometry as rc\n        from math import degrees\n\n        # Construct planes\n        zero = rc.Point3d(0, 0, 0)\n        z = rc.Vector3d(0, 0, 1)\n        x = rc.Vector3d(1, 0, 0)\n        y = rc.Vector3d(0, 1, 0)\n        xy = rc.Plane(zero, z).WorldXY\n        yz = rc.Plane(zero, x).WorldYZ\n\n        # Compute angles on the XY and YZ plane\n        for fn in self.testVecs:\n            self.xyAngles.append(degrees(rc.Vector3d.VectorAngle(fn, y, xy)))\n            yz_tmp = degrees(rc.Vector3d.VectorAngle(fn, z, yz))\n\n            # Correct angles\n            if yz_tmp > 90:\n                yz_tmp = 180 - yz_tmp\n            elif yz_tmp > 180:\n                yz_tmp = yz_tmp - 180\n            elif yz_tmp > 270:\n                yz_tmp = abs(yz_tmp - 360)\n            elif yz_tmp < 0:\n                yz_tmp = yz_tmp * (-1)\n\n            self.yzAngles.append(yz_tmp)\n\n\ndef topographic_index(meshPath, drainCurvesPath):\n    import numpy as np\n    import GeometryClasses as gc\n    import pymesh as pm\n\n    # Load mesh and curves\n    mesh = pm.load_mesh(meshPath)\n    drainCurves = []\n    file = open(drainCurvesPath, 'r')\n    lines = file.readlines()\n    for l in lines:\n        drainCurves.append(int(i) for i in l.split(',')[1:-1])\n\n    # Initilize mesh data\n    mesh.add_attribute('face_normal')\n    mesh.add_attribute('face_area')\n    faceArea = mesh.get_attribute('face_area')\n    fn = mesh.get_attribute('face_normal')\n    faceNormal = []\n    i = 0\n    while i < len(fn):\n        faceNormal.append(np.array([fn[i], fn[i+1], fn[i+2]]))\n        i += 3\n    drainArea = faceArea\n    TI = []\n\n    def topoIndex(a, beta):\n        return np.log(a / np.tan(beta))\n\n    def computeBeta(normal):\n        z = np.array([0,0,1])\n        return gc.angleBetweenVectors(z, normal, forceAngle='acute')[0]\n\n    def processDrainCurve(curveIndex):\n        \"\"\"Processes a single drain curve\"\"\"\n\n        A = 0\n\n        for face in drainCurves[curveIndex]:\n            a = faceArea[face]\n            drainArea[face] += a\n            A += a\n\n        return True\n\n    for curve in range(len(drainCurves)):\n        processDrainCurve(curve)\n\n    for face in range(mesh.num_faces):\n        a = drainArea[face]\n        b = computeBeta(faceNormal[face])\n        TI.append(topoIndex(a,b))\n\n    # Write topographic indices to file\n    topoFile = open('topographicIndex.txt', 'w')\n\n    for face in TI:\n        topoFile.write(str(face) + '\\n')\n    topoFile.write('\\n')\n\n    topoFile.close()\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}