{
  "source_url": "https://github.com/TheoArchi/EsquisSons/blob/00d1b02f7ce3e190b5c4c3429d3e84756c29bfdb/WIP_ESQUISSONS%20PYTHON%20FILES/VisualizeReflections.py",
  "repo": "TheoArchi/EsquisSons",
  "repo_stars": 3,
  "repo_description": "Esquissons is a grasshopper plugin which help you to design with sound ;)",
  "license": "NOASSERTION",
  "filepath": "WIP_ESQUISSONS PYTHON FILES/VisualizeReflections.py",
  "instruction": "Visualize Reflexion close to listener.\r\nUse Visualize Output of \"EsquisSons Main engine\" :)\r\n<WORKS ONLY WITH UNTRIMMED BREP OR SURFACES / You may encounter some bugs in semi-closed volumes>\r\n-\r\nAAU...",
  "code": "\"\"\"Visualize Reflexion close to listener.\r\nUse Visualize Output of \"EsquisSons Main engine\" :)\r\n<WORKS ONLY WITH UNTRIMMED BREP OR SURFACES / You may encounter some bugs in semi-closed volumes>\r\n-\r\nAAU / Theo Marchal / BETA VERSION / MARS2020\r\nWith the Contribution of Manon COUTIER & Domitille GRANDJEAN\"\"\"\r\n\r\nfrom ghpythonlib.componentbase import executingcomponent as component\r\nimport Grasshopper, GhPython\r\nimport System\r\nimport Rhino\r\nimport rhinoscriptsyntax as rs\r\nimport Grasshopper.Kernel as gh\r\n\r\n\r\nclass VisualizeReflections(component):\r\n\r\n    def RunScript(self, visualization, _nb_rays, _nb_reflections, _tolerance_dist):\r\n\r\n        # block init\r\n        __author__ = \"theomarchal\"\r\n        self.Params.Input[0].Description = \"Visualize (from esquissons main engine)\"\r\n        self.Params.Input[1].Description = \"Definition/number of ray (1-100)<default=10>\"\r\n        self.Params.Input[2].Description = \"Level of reflexion/number of bounces(1-10)<default=2>\"\r\n        self.Params.Input[3].Description = \"Ray Distance to listener tolerance (0.1-1.0)<default=0.5>\"\r\n        self.Params.Output[0].Description = \"Reflexion Rays\"\r\n        self.Name = \"Visualize Reflections\"\r\n        self.NickName = \"Visualize Rays\"\r\n        self.Message = \"EsquisSons V3\"\r\n        self.Category = \"EsquisSons\"\r\n        self.SubCategory = \"2/ Visualization\"\r\n\r\n        # set default values\r\n        if _nb_rays == None:\r\n            _nb_rays = 10\r\n        if _nb_reflections == None:\r\n            _nb_reflections = 2\r\n        if _tolerance_dist == None:\r\n            _tolerance_dist = 0.5\r\n\r\n        # check visualization and get environment, listener and sources back from visualization\r\n        try:\r\n            environment = visualization[0]\r\n            listener = visualization[1]\r\n            sources = visualization[2]\r\n        except:\r\n            self.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Error,\r\n                                   'A \"visualization\" ouptut from main engine must be connected !')\r\n            raise Exception('noInput')\r\n\r\n        # get listener_head and environment_geo back\r\n        # - listener_head : point representing the head of the listener\r\n        # - environment_geo : rhinoceros breps forming a listening environment\r\n        listener_head = listener[0][0]\r\n        environment_geo = []\r\n        for geometry in environment:\r\n            environment_geo.append(geometry[0])\r\n\r\n        # calculation of rays for every sound_source\r\n        # - rays : list of the reflection rays\r\n        rays = []\r\n\r\n        for sound_source in sources:\r\n            # creation of a sphere from source location and size\r\n            # - sphere_srf : sphere representing the sound_source\r\n            source_location = (sound_source[1])\r\n            sphere_srf = (rs.AddSphere(source_location, sound_source[2]))\r\n\r\n            for i in range(0, _nb_rays + 1, 1):\r\n                for j in range(0, _nb_rays + 1, 1):\r\n\r\n                    # divide sphere into a point_list\r\n                    # - pt : point created from _nb_rays, to later divide the sphere_srf\r\n                    # - sphere_parameter : parameter of the sphere_srf locating a point created from pt on the sphere_srf\r\n                    # - new_pt : point obtained from the previous sphere_parameter\r\n                    # - pt_ray : point used to form rays (point on the sphere_srf used to divide it into _nb_rays*nb_rays parts)\r\n                    pt = (i / _nb_rays, j / _nb_rays, 0)\r\n                    sphere_parameter = rs.SurfaceParameter(sphere_srf, pt)\r\n                    new_pt = rs.EvaluateSurface(sphere_srf, sphere_parameter[0], sphere_parameter[1])\r\n                    pt_ray = rs.AddPoint(new_pt)\r\n\r\n                    # creation of a vector used to guide the rays\r\n                    # - ray_vect : vector going from new_pt to source_location (radius of the source sphere)\r\n                    ray_vect = rs.VectorCreate(pt_ray, source_location)\r\n\r\n                    # calculation of the points where reflection occurs on environment_geo for ray_vect\r\n                    # the number of reflection calculated is _nb_reflections\r\n                    # - reflection_points : list of the reflection points calculated\r\n                    reflection_points = rs.ShootRay(environment_geo, source_location, ray_vect,\r\n                                                    reflections=_nb_reflections)\r\n\r\n                    # creation of a polyline representing the reflection ray (calculated from reflection_points)\r\n                    # - reflection_rays : polyline of reflection rays\r\n                    try:\r\n                        reflection_rays = rs.AddPolyline(reflection_points)\r\n                    except:\r\n                        pass\r\n\r\n                    # take into consideration tolerance_dist for each ray of reflection_rays\r\n                    # - closest_pt_listener_par : parameter locating the closest point from listener_head on the ray\r\n                    # - closest_pt_listener : point obtained from closest_pt_listener_par\r\n                    # - dist_rays_listener : distance between each ray and listener\r\n                    closest_pt_listener_par = rs.CurveClosestPoint(reflection_rays, listener_head)\r\n                    closest_pt_listener = rs.EvaluateCurve(reflection_rays, closest_pt_listener_par)\r\n                    dist_rays_listener = (rs.Distance(listener_head, closest_pt_listener))\r\n\r\n                    # if the distance between ray and listener is lower than listener_height*_tolerance_dist\r\n                    # the ray is added to rays\r\n                    # - rays : list of every ray respecting the _tolerance_dist criteria\r\n                    if dist_rays_listener <= ((listener[0])[3]) * _tolerance_dist:\r\n                        try:\r\n                            rays.append(reflection_rays)\r\n                        except:\r\n                            pass\r\n\r\n        # check rays and display warning if there is no ray\r\n        if len(rays) == 0:\r\n            self.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning,\r\n                                   'No ray, please be sure environment is connected to main engine and placed to create reflexions')\r\n            self.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, 'Change parameters to generate more rays')\r\n\r\n        return rays\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}