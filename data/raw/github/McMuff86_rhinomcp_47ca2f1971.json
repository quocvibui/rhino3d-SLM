{
  "source_url": "https://github.com/McMuff86/rhinomcp/blob/65db89d55c0a08af4dc19cd946bec19429db10cc/rhino_mcp_server/static/surface.py",
  "repo": "McMuff86/rhinomcp",
  "repo_stars": 0,
  "repo_description": null,
  "license": "Apache-2.0",
  "filepath": "rhino_mcp_server/static/surface.py",
  "instruction": "Surface",
  "code": "import math\n\nimport System\nfrom System.Collections.Generic import List\n\nimport Rhino\n\nimport scriptcontext\n\nimport rhinocompat as compat\nfrom rhinoscript import utility as rhutil\nfrom rhinoscript import object as rhobject\n\n\ndef AddBox(corners):\n    \"\"\"Adds a box shaped polysurface to the document\n    Parameters:\n      corners ([point, point, point ,point, point, point ,point,point]) 8 points that define the corners of the box. Points need to\n        be in counter-clockwise order starting with the bottom rectangle of the box\n    Returns:\n      guid: identifier of the new object on success\n    Example:\n      import rhinoscriptsyntax as rs\n      box = rs.GetBox()\n      if box: rs.AddBox(box)\n    See Also:\n      AddCone\n      AddCylinder\n      AddSphere\n      AddTorus\n    \"\"\"\n    box = rhutil.coerce3dpointlist(corners, True)\n    brep = Rhino.Geometry.Brep.CreateFromBox(box)\n    if not brep: raise ValueError(\"unable to create brep from box\")\n    rc = scriptcontext.doc.Objects.AddBrep(brep)\n    if rc==System.Guid.Empty: raise Exception(\"unable to add brep to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCone(base, height, radius, cap=True):\n    \"\"\"Adds a cone shaped polysurface to the document\n    Parameters:\n      base (point|plane): 3D origin point of the cone or a plane with an apex at the origin\n          and normal along the plane's z-axis\n      height (point|number): 3D height point of the cone if base is a 3D point. The height\n          point defines the height and direction of the cone. If base is a\n          plane, height is a numeric value\n      radius (number): the radius at the base of the cone\n      cap (bool, optional): cap base of the cone\n    Returns:\n      guid: identifier of the new object on success\n    Example:\n      import rhinoscriptsyntax as rs\n      radius = 5.0\n      base = rs.GetPoint(\"Base of cone\")\n      if base:\n          height = rs.GetPoint(\"Height of cone\", base)\n          if height: rs.AddCone(base, height, radius)\n    See Also:\n      AddBox\n      AddCylinder\n      AddSphere\n      AddTorus\n    \"\"\"\n    plane = None\n    height_point = rhutil.coerce3dpoint(height)\n    if height_point is None:\n        plane = rhutil.coerceplane(base, True)\n    else:\n        base_point = rhutil.coerce3dpoint(base, True)\n        normal = base_point - height_point\n        height = normal.Length\n        plane = Rhino.Geometry.Plane(height_point, normal)\n    cone = Rhino.Geometry.Cone(plane, height, radius)\n    brep = Rhino.Geometry.Brep.CreateFromCone(cone, cap)\n    rc = scriptcontext.doc.Objects.AddBrep(brep)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCutPlane(object_ids, start_point, end_point, normal=None):\n    \"\"\"Adds a planar surface through objects at a designated location. For more\n    information, see the Rhino help file for the CutPlane command\n    Parameters:\n      objects_ids ([guid, ...]): identifiers of objects that the cutting plane will\n          pass through\n      start_point, end_point (line): line that defines the cutting plane\n      normal (vector, optional): vector that will be contained in the returned planar\n          surface. In the case of Rhino's CutPlane command, this is the\n          normal to, or Z axis of, the active view's construction plane.\n          If omitted, the world Z axis is used\n    Returns:\n      guid: identifier of new object on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      objs = rs.GetObjects(\"Select objects for cut plane\")\n      if objs:\n          point0 = rs.GetPoint(\"Start of cut plane\")\n          if point0:\n              point1 = rs.GetPoint(\"End of cut plane\", point0)\n              if point1: rs.AddCutPlane( objs, point0, point1 )\n    See Also:\n      AddPlaneSurface\n    \"\"\"\n    objects = []\n    for id in object_ids:\n        rhobj = rhutil.coercerhinoobject(id, True, True)\n        objects.append(rhobj)\n\n    rc, bbox = Rhino.DocObjects.RhinoObject.GetTightBoundingBox(objects)\n    if not bbox.IsValid:\n        return scriptcontext.errorhandler()\n\n    bbox_min = bbox.Min\n    bbox_max = bbox.Max\n    for i in range(0, 3):\n        if (System.Math.Abs(bbox_min[i] - bbox_max[i]) < Rhino.RhinoMath.SqrtEpsilon):\n            bbox_min[i] = bbox_min[i] - 1.0\n            bbox_max[i] = bbox_max[i] + 1.0\n\n    v = bbox_max - bbox_min\n    v = v * 1.1\n    p = bbox_min + v\n    bbox_min = bbox_max - v\n    bbox_max = p\n    bbox = Rhino.Geometry.BoundingBox(bbox_min, bbox_max)\n\n    start_point = rhutil.coerce3dpoint(start_point, True)\n    end_point = rhutil.coerce3dpoint(end_point, True)\n    line = Rhino.Geometry.Line(start_point, end_point)\n    if normal:\n        normal = rhutil.coerce3dvector(normal, True)\n    else:\n        normal = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane().Normal\n\n    surface = Rhino.Geometry.PlaneSurface.CreateThroughBox(line, normal, bbox)\n    if surface is None: return scriptcontext.errorhandler()\n    id = scriptcontext.doc.Objects.AddSurface(surface)\n    if id==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return id\n\n\ndef AddCylinder(base, height, radius, cap=True):\n    \"\"\"Adds a cylinder-shaped polysurface to the document\n    Parameters:\n      base (point|plane): The 3D base point of the cylinder or the base plane of the cylinder\n      height (point|number): if base is a point, then height is a 3D height point of the\n        cylinder. The height point defines the height and direction of the\n        cylinder. If base is a plane, then height is the numeric height value\n        of the cylinder\n      radius (number): radius of the cylinder\n      cap (bool, optional): cap the cylinder\n    Returns:\n      guid: identifier of new object if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      radius = 5.0\n      base = rs.GetPoint(\"Base of cylinder\")\n      if base:\n          height = rs.GetPoint(\"Height of cylinder\", base)\n          if height: rs.AddCylinder( base, height, radius )\n    See Also:\n      AddBox\n      AddCone\n      AddSphere\n      AddTorus\n    \"\"\"\n    cylinder=None\n    height_point = rhutil.coerce3dpoint(height)\n    if height_point:\n        #base must be a point\n        base = rhutil.coerce3dpoint(base, True)\n        normal = height_point-base\n        plane = Rhino.Geometry.Plane(base, normal)\n        height = normal.Length\n        circle = Rhino.Geometry.Circle(plane, radius)\n        cylinder = Rhino.Geometry.Cylinder(circle, height)\n    else:\n        #base must be a plane\n        if type(base) is Rhino.Geometry.Point3d: base = [base.X, base.Y, base.Z]\n        base = rhutil.coerceplane(base, True)\n        circle = Rhino.Geometry.Circle(base, radius)\n        cylinder = Rhino.Geometry.Cylinder(circle, height)\n    brep = cylinder.ToBrep(cap, cap)\n    id = scriptcontext.doc.Objects.AddBrep(brep)\n    if id==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return id\n\n\ndef AddEdgeSrf(curve_ids):\n    \"\"\"Creates a surface from 2, 3, or 4 edge curves\n    Parameters:\n      curve_ids ([guid, ...]): list or tuple of curves\n    Returns:\n      guid: identifier of new object if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curves = rs.GetObjects(\"Select 2, 3, or 4 curves\", rs.filter.curve)\n      if curves and len(curves)>1 ): rs.AddEdgeSrf(curves)\n    See Also:\n      AddPlanarSrf\n      AddSrfControlPtGrid\n      AddSrfPt\n      AddSrfPtGrid\n    \"\"\"\n    curves = [rhutil.coercecurve(id, -1, True) for id in curve_ids]\n    brep = Rhino.Geometry.Brep.CreateEdgeSurface(curves)\n    if brep is None: return scriptcontext.errorhandler()\n    id = scriptcontext.doc.Objects.AddBrep(brep)\n    if id==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return id\n\n\ndef AddNetworkSrf(curves, continuity=1, edge_tolerance=0, interior_tolerance=0, angle_tolerance=0):\n    \"\"\"Creates a surface from a network of crossing curves\n    Parameters:\n      curves ([guid, ...]): curves from which to create the surface\n      continuity (number, optional): how the edges match the input geometry\n                 0 = loose\n                 1 = position\n                 2 = tangency\n                 3 = curvature\n    Returns:\n      guid: identifier of new object if successful\n    Example:\n      import rhinoscriptsyntax as  rs\n      curve_ids = rs.GetObjects(\"Select  curves in network\", 4, True, True)\n      if len(curve_ids) > 0:\n          rs.AddNetworkSrf(curve_ids)\n    See Also:\n      \n    \"\"\"\n    curves = [rhutil.coercecurve(curve, -1, True) for curve in curves]\n    surf, err = Rhino.Geometry.NurbsSurface.CreateNetworkSurface(curves, continuity, edge_tolerance, interior_tolerance, angle_tolerance)\n    if surf:\n        rc = scriptcontext.doc.Objects.AddSurface(surf)\n        scriptcontext.doc.Views.Redraw()\n        return rc\n\n\ndef AddNurbsSurface(point_count, points, knots_u, knots_v, degree, weights=None):\n    \"\"\"Adds a NURBS surface object to the document\n    Parameters:\n      point_count ([number, number]) number of control points in the u and v direction\n      points ({point, ...]): list of 3D points\n      knots_u ([number, ...]): knot values for the surface in the u direction.\n                Must contain point_count[0]+degree[0]-1 elements\n      knots_v ([number, ...]): knot values for the surface in the v direction.\n                Must contain point_count[1]+degree[1]-1 elements\n      degree ([number, number]): degree of the surface in the u and v directions.\n      weights [(number, ...]): weight values for the surface. The number of elements in\n        weights must equal the number of elements in points. Values must be\n        greater than zero.\n    Returns:\n      guid: identifier of new object if successful\n      None on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Pick a surface\", rs.filter.surface)\n      if obj:\n          point_count = rs.SurfacePointCount(obj)\n          points = rs.SurfacePoints(obj)\n          knots = rs.SurfaceKnots(obj)\n          degree = rs.SurfaceDegree(obj)\n          if rs.IsSurfaceRational(obj):\n              weights = rs.SurfaceWeights(obj)\n              obj = rs.AddNurbsSurface(point_count, points, knots[0], knots[1], degree, weights)\n          else:\n              obj = rs.AddNurbsSurface(point_count, points, knots[0], knots[1], degree)\n          if obj: rs.SelectObject(obj)\n    See Also:\n      IsSurfaceRational\n      SurfaceDegree\n      SurfaceKnotCount\n      SurfaceKnots\n      SurfacePointCount\n      SurfacePoints\n      SurfaceWeights\n    \"\"\"\n    if len(points)<(point_count[0]*point_count[1]):\n        return scriptcontext.errorhandler()\n    ns = Rhino.Geometry.NurbsSurface.Create(3, weights!=None, degree[0]+1, degree[1]+1, point_count[0], point_count[1])\n    #add the points and weights\n    controlpoints = ns.Points\n    index = 0\n    for i in range(point_count[0]):\n        for j in range(point_count[1]):\n            if weights:\n                cp = Rhino.Geometry.ControlPoint(points[index], weights[index])\n                controlpoints.SetControlPoint(i,j,cp)\n            else:\n                cp = Rhino.Geometry.ControlPoint(points[index])\n                controlpoints.SetControlPoint(i,j,cp)\n            index += 1\n    #add the knots\n    for i in range(ns.KnotsU.Count): ns.KnotsU[i] = knots_u[i]\n    for i in range(ns.KnotsV.Count): ns.KnotsV[i] = knots_v[i]\n    if not ns.IsValid: return scriptcontext.errorhandler()\n    id = scriptcontext.doc.Objects.AddSurface(ns)\n    if id==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return id\n\n\ndef AddPatch(object_ids, uv_spans_tuple_OR_surface_object_id, tolerance=None, trim=True, point_spacing=0.1, flexibility=1.0, surface_pull=1.0, fix_edges=False):\n    \"\"\"Fits a surface through curve, point, point cloud, and mesh objects.\n    Parameters:\n      object_ids ({guid, ...]): a list of object identifiers that indicate the objects to use for the patch fitting.\n          Acceptable object types include curves, points, point clouds, and meshes.\n      uv_spans_tuple_OR_surface_object_id ([number, number]|guid):  the U and V direction span counts for the automatically generated surface OR\n          The identifier of the starting surface.  It is best if you create a starting surface that is similar in shape \n          to the surface you are trying to create.\n      tolerance (number, optional): The tolerance used by input analysis functions. If omitted, Rhino's document absolute tolerance is used.\n      trim (bool, optional): Try to find an outside curve and trims the surface to it.  The default value is True.\n      point_spacing (number, optional): The basic distance between points sampled from input curves.  The default value is 0.1.\n      flexibility (number, optional): Determines the behavior of the surface in areas where its not otherwise controlled by the input.\n          Lower numbers make the surface behave more like a stiff material, higher, more like a flexible material.  \n          That is, each span is made to more closely match the spans adjacent to it if there is no input geometry \n          mapping to that area of the surface when the flexibility value is low.  The scale is logarithmic.  \n          For example, numbers around 0.001 or 0.1 make the patch pretty stiff and numbers around 10 or 100 \n          make the surface flexible.  The default value is 1.0.\n      surface_pull (number, optional): Similar to stiffness, but applies to the starting surface. The bigger the pull, the closer\n          the resulting surface shape will be to the starting surface.  The default value is 1.0.\n      fix_edges (bool, optional): Clamps the edges of the starting surface in place. This option is useful if you are using a\n          curve or points for deforming an existing surface, and you do not want the edges of the starting surface \n          to move.  The default if False.\n    Returns:\n      guid: Identifier of the new surface object if successful.\n      None: on error.\n    Example:\n    See Also:\n    \"\"\"\n    # System.Collections.List instead of Python list because IronPython is\n    # having problems converting a list to an IEnumerable<GeometryBase> which\n    # is the 1st argument for Brep.CreatePatch\n    geometry = List[Rhino.Geometry.GeometryBase]()\n    u_span = 10\n    v_span = 10\n    rc = None\n    id = rhutil.coerceguid(object_ids, False)\n    if id: object_ids = [id]\n    for object_id in object_ids:\n        rhobj = rhutil.coercerhinoobject(object_id, False, False)\n        if not rhobj: return None\n        geometry.Add( rhobj.Geometry )\n    if not geometry: return None\n    \n    surface = None\n    if uv_spans_tuple_OR_surface_object_id:\n      if type(uv_spans_tuple_OR_surface_object_id) is tuple:\n        u_span = uv_spans_tuple_OR_surface_object_id[0]\n        v_span = uv_spans_tuple_OR_surface_object_id[1]\n      else:\n        surface = rhutil.coercesurface(uv_spans_tuple_OR_surface_object_id, False)\n\n    if not tolerance: tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    b = System.Array.CreateInstance(bool, 4)\n    for i in range(4): b[i] = fix_edges\n    brep = Rhino.Geometry.Brep.CreatePatch(geometry, surface, u_span, v_span, trim, False, point_spacing, flexibility, surface_pull, b, tolerance)\n    if brep:\n      rc = scriptcontext.doc.Objects.AddBrep(brep)\n      scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddPipe(curve_id, parameters, radii, blend_type=0, cap=0, fit=False):\n    \"\"\"Creates a single walled surface with a circular profile around a curve\n    Parameters:\n      curve_id (guid): identifier of rail curve\n      parameters, radii ([number, ...]): list of radius values at normalized curve parameters\n      blend_type (number, optional): 0(local) or 1(global)\n      cap (number, optional): 0(none), 1(flat), 2(round)\n      fit (bool, optional): attempt to fit a single surface\n    Returns:\n      list(guid, ...): identifiers of new objects created\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select curve to create pipe around\", rs.filter.curve, True)\n      if curve:\n          domain = rs.CurveDomain(curve)\n          rs.AddPipe(curve, 0, 4)\n    See Also:\n      \n    \"\"\"\n    rail = rhutil.coercecurve(curve_id, -1, True)\n    abs_tol = scriptcontext.doc.ModelAbsoluteTolerance\n    ang_tol = scriptcontext.doc.ModelAngleToleranceRadians\n    if type(parameters) is int or type(parameters) is float: parameters = [parameters]\n    if type(radii) is int or type(radii) is float: radii = [radii]\n    parameters = compat.ITERATOR2LIST(map(float,parameters))\n    radii = compat.ITERATOR2LIST(map(float,radii))\n    cap = System.Enum.ToObject(Rhino.Geometry.PipeCapMode, cap)\n    breps = Rhino.Geometry.Brep.CreatePipe(rail, parameters, radii, blend_type==0, cap, fit, abs_tol, ang_tol)\n    rc = [scriptcontext.doc.Objects.AddBrep(brep) for brep in breps]\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddPlanarSrf(object_ids):\n    \"\"\"Creates one or more surfaces from planar curves\n    Parameters:\n      object_ids ({guid, ...]): curves to use for creating planar surfaces\n    Returns:\n      list(guid, ...): identifiers of surfaces created on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      objs = rs.GetObjects(\"Select planar curves to build surface\", rs.filter.curve)\n      if objs: rs.AddPlanarSrf(objs)\n    See Also:\n      AddEdgeSrf\n      AddSrfControlPtGrid\n      AddSrfPt\n      AddSrfPtGrid\n    \"\"\"\n    id = rhutil.coerceguid(object_ids, False)\n    if id: object_ids = [id]\n    curves = [rhutil.coercecurve(id,-1,True) for id in object_ids]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    breps = Rhino.Geometry.Brep.CreatePlanarBreps(curves, tolerance)\n    if breps:\n        rc = [scriptcontext.doc.Objects.AddBrep(brep) for brep in breps]\n        scriptcontext.doc.Views.Redraw()\n        return rc\n\n\ndef AddPlaneSurface(plane, u_dir, v_dir):\n    \"\"\"Create a plane surface and add it to the document.\n    Parameters:\n      plane (plane): The plane.\n      u_dir (number): The magnitude in the U direction.\n      v_dir (number): The magnitude in the V direction.\n    Returns:\n      guid: The identifier of the new object if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      rs.AddPlaneSurface( rs.WorldXYPlane(), 5.0, 3.0 )\n    See Also:\n      AddCutPlane\n      AddEdgeSrf\n      AddSrfControlPtGrid\n      AddSrfPt\n      AddSrfPtGrid\n      IsPlaneSurface\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    u_interval = Rhino.Geometry.Interval(0, u_dir)\n    v_interval = Rhino.Geometry.Interval(0, v_dir)\n    plane_surface = Rhino.Geometry.PlaneSurface(plane, u_interval, v_interval) \n    if plane_surface is None: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddSurface(plane_surface)\n    if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddLoftSrf(object_ids, start=None, end=None, loft_type=0, simplify_method=0, value=0, closed=False):\n    \"\"\"Adds a surface created by lofting curves to the document.\n    - no curve sorting performed. pass in curves in the order you want them sorted\n    - directions of open curves not adjusted. Use CurveDirectionsMatch and\n      ReverseCurve to adjust the directions of open curves\n    - seams of closed curves are not adjusted. Use CurveSeam to adjust the seam\n      of closed curves\n    Parameters:\n      object_ids ({guid, guid, ...]): ordered list of the curves to loft through\n      start (point, optional): starting point of the loft\n      end (point, optional): ending point of the loft\n      loft_type (number, optional): type of loft. Possible options are:\n        0 = Normal. Uses chord-length parameterization in the loft direction\n        1 = Loose. The surface is allowed to move away from the original curves\n            to make a smoother surface. The surface control points are created\n            at the same locations as the control points of the loft input curves.\n        2 = Straight. The sections between the curves are straight. This is\n            also known as a ruled surface.\n        3 = Tight. The surface sticks closely to the original curves. Uses square\n            root of chord-length parameterization in the loft direction\n        4 = Developable. Creates a separate developable surface or polysurface\n            from each pair of curves.\n      simplify_method (number, optional): Possible options are:\n        0 = None. Does not simplify.\n        1 = Rebuild. Rebuilds the shape curves before lofting. modified by `value` below\n        2 = Refit. Refits the shape curves to a specified tolerance. modified by `value` below\n      value (number, optional): Additional value based on the specified `simplify_method`:\n        Simplify  -   Description\n        Rebuild(1) - then value is the number of control point used to rebuild\n        Rebuild(1) - is specified and this argument is omitted, then curves will be\n                     rebuilt using 10 control points.\n        Refit(2) - then value is the tolerance used to rebuild.\n        Refit(2) - is specified and this argument is omitted, then the document's\n                     absolute tolerance us used for refitting.\n      closed (bool, optional): close the loft back to the first curve\n    Returns:\n      list(guid, ...):Array containing the identifiers of the new surface objects if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      objs = rs.GetObjects(\"Pick curves to loft\", rs.filter.curve)\n      if objs: rs.AddLoftSrf(objs)\n    See Also:\n      CurveDirectionsMatch\n      CurveSeam\n      ReverseCurve\n    \"\"\"\n    if loft_type<0 or loft_type>5: raise ValueError(\"loft_type must be 0-4\")\n    if simplify_method<0 or simplify_method>2: raise ValueError(\"simplify_method must be 0-2\")\n\n    # get set of curves from object_ids\n    curves = [rhutil.coercecurve(id,-1,True) for id in object_ids]\n    if len(curves)<2: return scriptcontext.errorhandler()\n    if start is None: start = Rhino.Geometry.Point3d.Unset\n    if end is None: end = Rhino.Geometry.Point3d.Unset\n    start = rhutil.coerce3dpoint(start, True)\n    end = rhutil.coerce3dpoint(end, True)\n    \n    lt = Rhino.Geometry.LoftType.Normal\n    if loft_type==1: lt = Rhino.Geometry.LoftType.Loose\n    elif loft_type==2: lt = Rhino.Geometry.LoftType.Straight\n    elif loft_type==3: lt = Rhino.Geometry.LoftType.Tight\n    elif loft_type==4: lt = Rhino.Geometry.LoftType.Developable\n\n    breps = None\n    if simplify_method==0:\n        breps = Rhino.Geometry.Brep.CreateFromLoft(curves, start, end, lt, closed)\n    elif simplify_method==1:\n        value = abs(value)\n        rebuild_count = int(value)\n        breps = Rhino.Geometry.Brep.CreateFromLoftRebuild(curves, start, end, lt, closed, rebuild_count)\n    elif simplify_method==2:\n        refit = abs(value)\n        if refit==0: refit = scriptcontext.doc.ModelAbsoluteTolerance\n        breps = Rhino.Geometry.Brep.CreateFromLoftRefit(curves, start, end, lt, closed, refit)\n    if not breps: return scriptcontext.errorhandler()\n\n    idlist = []\n    for brep in breps:\n        id = scriptcontext.doc.Objects.AddBrep(brep)\n        if id!=System.Guid.Empty: idlist.append(id)\n    if idlist: scriptcontext.doc.Views.Redraw()\n    return idlist\n\n\ndef AddRevSrf(curve_id, axis, start_angle=0.0, end_angle=360.0):\n    \"\"\"Create a surface by revolving a curve around an axis\n    Parameters:\n      curve_id (guid): identifier of profile curve\n      axis (line): line for the rail revolve axis\n      start_angle, end_angle (number, optional): start and end angles of revolve\n    Returns:\n      guid: identifier of new object if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.AddLine((5,0,0), (10,0,10))\n      rs.AddRevSrf( curve, ((0,0,0), (0,0,1)) )\n    See Also:\n      \n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    axis = rhutil.coerceline(axis, True)\n    start_angle = math.radians(start_angle)\n    end_angle = math.radians(end_angle)\n    srf = Rhino.Geometry.RevSurface.Create(curve, axis, start_angle, end_angle)\n    if not srf: return scriptcontext.errorhandler()\n    ns = srf.ToNurbsSurface()\n    if not ns: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddSurface(ns)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSphere(center_or_plane, radius):\n    \"\"\"Add a spherical surface to the document\n    Parameters:\n      center_or_plane (point|plane): center point of the sphere. If a plane is input,\n        the origin of the plane will be the center of the sphere\n      radius (number): radius of the sphere in the current model units\n    Returns:\n      guid: identifier of the new object on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      radius = 2\n      center = rs.GetPoint(\"Center of sphere\")\n      if center: rs.AddSphere(center, radius)\n    See Also:\n      AddBox\n      AddCone\n      AddCylinder\n      AddTorus\n    \"\"\"\n    c_or_p = rhutil.coerce3dpoint(center_or_plane)\n    if c_or_p is None:\n        c_or_p = rhutil.coerceplane(center_or_plane)\n    if c_or_p is None: return None\n    sphere = Rhino.Geometry.Sphere(c_or_p, radius)\n    rc = scriptcontext.doc.Objects.AddSphere(sphere)\n    if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSrfContourCrvs(object_id, points_or_plane, interval=None):\n    \"\"\"Adds a spaced series of planar curves resulting from the intersection of\n    defined cutting planes through a surface or polysurface. For more\n    information, see Rhino help for details on the Contour command\n    Parameters:\n      object_id (guid): object identifier to contour\n      points_or_plane ([point,point]|plane): either a list/tuple of two points or a plane\n        if two points, they define the start and end points of a center line\n        if a plane, the plane defines the cutting plane\n      interval (number, optional): distance between contour curves.\n    Returns:\n      guid: ids of new contour curves on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select object\", rs.filter.surface + rs.filter.polysurface)\n      startpoint = rs.GetPoint(\"Base point of center line\")\n      endpoint = rs.GetPoint(\"Endpoint of center line\", startpoint)\n      rs.AddSrfContourCrvs( obj, (startpoint, endpoint) )\n    See Also:\n      CurveContourPoints\n    \"\"\"\n    brep = rhutil.coercebrep(object_id)\n    plane = rhutil.coerceplane(points_or_plane)\n    curves = None\n    if plane:\n        curves = Rhino.Geometry.Brep.CreateContourCurves(brep, plane)\n    else:\n        start = rhutil.coerce3dpoint(points_or_plane[0], True)\n        end = rhutil.coerce3dpoint(points_or_plane[1], True)\n        if not interval:\n            bbox = brep.GetBoundingBox(True)\n            v = bbox.Max - bbox.Min\n            interval = v.Length / 50.0\n        curves = Rhino.Geometry.Brep.CreateContourCurves(brep, start, end, interval)\n    rc = []\n    for crv in curves:\n        id = scriptcontext.doc.Objects.AddCurve(crv)\n        if id!=System.Guid.Empty: rc.append(id)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSrfControlPtGrid(count, points, degree=(3,3)):\n    \"\"\"Creates a surface from a grid of points\n    Parameters:\n      count ([number, number])tuple of two numbers defining number of points in the u,v directions\n      points ([point, ...]): list of 3D points\n      degree ([number, number]): two numbers defining degree of the surface in the u,v directions\n    Returns:\n      guid: The identifier of the new object if successful.\n      None: if not successful, or on error.\n    Example:\n    See Also:\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    surf = Rhino.Geometry.NurbsSurface.CreateFromPoints(points, count[0], count[1], degree[0], degree[1])\n    if not surf: return scriptcontext.errorhandler()\n    id = scriptcontext.doc.Objects.AddSurface(surf)\n    if id!=System.Guid.Empty:\n        scriptcontext.doc.Views.Redraw()\n        return id\n\n\ndef AddSrfPt(points):\n    \"\"\"Creates a new surface from either 3 or 4 corner points.\n    Parameters:\n      points ([point, point, point, point]): list of either 3 or 4 corner points\n    Returns:\n      guid: The identifier of the new object if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      points = rs.GetPoints(True, message1=\"Pick 3 or 4 corner points\")\n      if points: rs.AddSrfPt(points)\n    See Also:\n      AddEdgeSrf\n      AddSrfControlPtGrid\n      AddSrfPtGrid\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    surface=None\n    if len(points)==3:\n        surface = Rhino.Geometry.NurbsSurface.CreateFromCorners(points[0], points[1], points[2])\n    elif len(points)==4:\n        surface = Rhino.Geometry.NurbsSurface.CreateFromCorners(points[0], points[1], points[2], points[3])\n    if surface is None: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddSurface(surface)\n    if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSrfPtGrid(count, points, degree=(3,3), closed=(False,False)):\n    \"\"\"Creates a surface from a grid of points\n    Parameters:\n      count ([number, number}): tuple of two numbers defining number of points in the u,v directions\n      points ([point, ...]): list of 3D points\n      degree ([number, number], optional): two numbers defining degree of the surface in the u,v directions\n      closed ([bool, bool], optional): two booleans defining if the surface is closed in the u,v directions\n    Returns:\n      guid: The identifier of the new object if successful.\n      None: if not successful, or on error.\n    Example:\n    See Also:\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    surf = Rhino.Geometry.NurbsSurface.CreateThroughPoints(points, count[0], count[1], degree[0], degree[1], closed[0], closed[1])\n    if not surf: return scriptcontext.errorhandler()\n    id = scriptcontext.doc.Objects.AddSurface(surf)\n    if id!=System.Guid.Empty:\n        scriptcontext.doc.Views.Redraw()\n        return id\n\n\ndef AddSweep1(rail, shapes, closed=False):\n    \"\"\"Adds a surface created through profile curves that define the surface\n    shape and one curve that defines a surface edge.\n    Parameters:\n      rail (guid): identifier of the rail curve\n      shapes ([guid, ...]): one or more cross section shape curves\n      closed (bool, optional): If True, then create a closed surface\n    Returns:\n      list(guid, ...): of new surface objects if successful\n      None: if not successful, or on error\n    Example:\n      import rhinoscriptsyntax as rs\n      rail = rs.GetObject(\"Select rail curve\", rs.filter.curve)\n      if rail:\n          shapes = rs.GetObjects(\"Select cross-section curves\", rs.filter.curve)\n          if shapes: rs.AddSweep1( rail, shapes )\n    See Also:\n      AddSweep2\n      CurveDirectionsMatch\n      ReverseCurve\n    \"\"\"\n    rail = rhutil.coercecurve(rail, -1, True)\n    shapes = [rhutil.coercecurve(shape, -1, True) for shape in shapes]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    breps = Rhino.Geometry.Brep.CreateFromSweep(rail, shapes, closed, tolerance)\n    if not breps: return scriptcontext.errorhandler()\n    rc = [scriptcontext.doc.Objects.AddBrep(brep) for brep in breps]\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSweep2(rails, shapes, closed=False):\n    \"\"\"Adds a surface created through profile curves that define the surface\n    shape and two curves that defines a surface edge.\n    Parameters:\n      rails ([guid, guid]): identifiers of the two rail curve\n      shapes ([guid, ...]): one or more cross section shape curves\n      closed (bool, optional): If True, then create a closed surface\n    Returns:\n      list(guid, ...): of new surface objects if successful\n      None: if not successful, or on error\n    Example:\n      import rhinoscriptsyntax as rs\n      rails = rs.GetObjects(\"Select two rail curve\", rs.filter.curve)\n      if rails and len(rails)==2:\n          shapes = rs.GetObjects(\"Select cross-section curves\", rs.filter.curve)\n          if shapes: rs.AddSweep2(rails, shapes)\n    See Also:\n      AddSweep1\n      CurveDirectionsMatch\n      ReverseCurve\n    \"\"\"\n    rail1 = rhutil.coercecurve(rails[0], -1, True)\n    rail2 = rhutil.coercecurve(rails[1], -1, True)\n    shapes = [rhutil.coercecurve(shape, -1, True) for shape in shapes]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    breps = Rhino.Geometry.Brep.CreateFromSweep(rail1, rail2, shapes, closed, tolerance)\n    if not breps: return scriptcontext.errorhandler()\n    rc = [scriptcontext.doc.Objects.AddBrep(brep) for brep in breps]\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddRailRevSrf(profile, rail, axis, scale_height=False):\n    \"\"\"Adds a surface created through profile curves that define the surface\n    shape and two curves that defines a surface edge.\n    Parameters:\n      profile (guid): identifier of the profile curve\n      rail (guid): identifier of the rail curve\n      axis ([point, point]): A list of two 3-D points identifying the start point and end point of the rail revolve axis, or a Line\n      scale_height (bool, optional): If True, surface will be locally scaled. Defaults to False\n    Returns:\n      guid: identifier of the new object if successful\n      None: if not successful, or on error\n    Example:\n      import rhinoscriptsyntax as rs\n      profile = rs.GetObject(\"Select a profile\", rs.filter.curve)\n      if profile:\n          rail = rs.GetObject(\"Select a rail\", rs.filter.curve)\n          if rail:\n              rs.AddRailRevSrf(profile, rail, ((0,0,0),(0,0,1)))\n    See Also:\n      AddSweep1\n      CurveDirectionsMatch\n      ReverseCurve\n    \"\"\"\n    profile_inst = rhutil.coercecurve(profile, -1, True)\n    rail_inst = rhutil.coercecurve(rail, -1, True)\n    axis_start = rhutil.coerce3dpoint(axis[0], True)\n    axis_end = rhutil.coerce3dpoint(axis[1], True)\n\n    line = Rhino.Geometry.Line(axis_start, axis_end)\n    surface = Rhino.Geometry.NurbsSurface.CreateRailRevolvedSurface(profile_inst, rail_inst, line, scale_height)\n\n    if not surface: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddSurface(surface)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddTorus(base, major_radius, minor_radius, direction=None):\n    \"\"\"Adds a torus shaped revolved surface to the document\n    Parameters:\n      base (point): 3D origin point of the torus or the base plane of the torus\n      major_radius, minor_radius (number): the two radii of the torus\n      directions (point):  A point that defines the direction of the torus when base is a point.\n        If omitted, a torus that is parallel to the world XY plane is created\n    Returns:\n      guid: The identifier of the new object if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      major_radius = 5.0\n      minor_radius = major_radius - 2.0\n      base = rs.GetPoint(\"Base of torus\")\n      if base:\n          direction = rs.GetPoint(\"Direction of torus\", base)\n          if direction:\n              rs.AddTorus( base, major_radius, minor_radius, direction )\n    See Also:\n      AddBox\n      AddCone\n      AddCylinder\n      AddSphere\n    \"\"\"\n    baseplane = None\n    basepoint = rhutil.coerce3dpoint(base)\n    if basepoint is None:\n        baseplane = rhutil.coerceplane(base, True)\n        if direction!=None: return scriptcontext.errorhandler()\n    if baseplane is None:\n        direction = rhutil.coerce3dpoint(direction, False)\n        if direction: direction = direction-basepoint\n        else: direction = Rhino.Geometry.Vector3d.ZAxis\n        baseplane = Rhino.Geometry.Plane(basepoint, direction)\n    torus = Rhino.Geometry.Torus(baseplane, major_radius, minor_radius)\n    revsurf = torus.ToRevSurface()\n    rc = scriptcontext.doc.Objects.AddSurface(revsurf)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef BooleanDifference(input0, input1, delete_input=True):\n    \"\"\"Performs a boolean difference operation on two sets of input surfaces\n    and polysurfaces. For more details, see the BooleanDifference command in\n    the Rhino help file\n    Parameters:\n        input0 ([guid, ...]): list of surfaces to subtract from\n        input1 ([guid, ...]): list of surfaces to be subtracted\n        delete_input (bool, optional): delete all input objects\n    Returns:\n        list(guid, ...): of identifiers of newly created objects on success\n        None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      filter = rs.filter.surface | rs.filter.polysurface\n      input0 = rs.GetObjects(\"Select first set of surfaces or polysurfaces\", filter)\n      if input0:\n          input1 = rs.GetObjects(\"Select second set of surfaces or polysurfaces\", filter)\n          if input1: rs.BooleanDifference(input0, input1)\n    See Also:\n      BooleanIntersection\n      BooleanUnion\n    \"\"\"\n    if type(input0) is list or type(input0) is tuple: pass\n    else: input0 = [input0]\n    \n    if type(input1) is list or type(input1) is tuple: pass\n    else: input1 = [input1]\n\n    breps0 = [rhutil.coercebrep(id, True) for id in input0]\n    breps1 = [rhutil.coercebrep(id, True) for id in input1]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newbreps = Rhino.Geometry.Brep.CreateBooleanDifference(breps0, breps1, tolerance)\n    if newbreps is None: return scriptcontext.errorhandler()\n    \n    rc = [scriptcontext.doc.Objects.AddBrep(brep) for brep in newbreps]\n    if delete_input:\n        for id in input0: scriptcontext.doc.Objects.Delete(id, True)\n        for id in input1: scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef BooleanIntersection(input0, input1, delete_input=True):\n    \"\"\"Performs a boolean intersection operation on two sets of input surfaces\n    and polysurfaces. For more details, see the BooleanIntersection command in\n    the Rhino help file\n    Parameters:\n        input0 ([guid, ...]): list of surfaces\n        input1 ([guid, ...]): list of surfaces\n        delete_input (bool, optional): delete all input objects\n    Returns:\n        list(guid, ...): of identifiers of newly created objects on success\n        None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      input0 = rs.GetObjects(\"Select first set of surfaces or polysurfaces\", rs.filter.surface | rs.filter.polysurface)\n      if input0:\n          input1 = rs.GetObjects(\"Select second set of surfaces or polysurfaces\", rs.filter.surface | rs.filter.polysurface)\n          if input1: rs.BooleanIntersection( input0, input1 )\n    See Also:\n      BooleanDifference\n      BooleanUnion\n    \"\"\"\n    if type(input0) is list or type(input0) is tuple: pass\n    else: input0 = [input0]\n    \n    if type(input1) is list or type(input1) is tuple: pass\n    else: input1 = [input1]\n\n    breps0 = [rhutil.coercebrep(id, True) for id in input0]\n    breps1 = [rhutil.coercebrep(id, True) for id in input1]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newbreps = Rhino.Geometry.Brep.CreateBooleanIntersection(breps0, breps1, tolerance)\n    if newbreps is None: return scriptcontext.errorhandler()\n    rc = [scriptcontext.doc.Objects.AddBrep(brep) for brep in newbreps]\n    if delete_input:\n        for id in input0: scriptcontext.doc.Objects.Delete(id, True)\n        for id in input1: scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef BooleanUnion(input, delete_input=True):\n    \"\"\"Performs a boolean union operation on a set of input surfaces and\n    polysurfaces. For more details, see the BooleanUnion command in the\n    Rhino help file\n    Parameters:\n        input ([guid, ...]): list of surfaces to union\n        delete_input (bool, optional):  delete all input objects\n    Returns:\n        list(guid, ...): of identifiers of newly created objects on success\n        None on error\n    Example:\n      import rhinoscriptsyntax as rs\n      input = rs.GetObjects(\"Select surfaces or polysurfaces to union\", rs.filter.surface | rs.filter.polysurface)\n      if input and len(input)>1: rs.BooleanUnion(input)\n    See Also:\n      BooleanDifference\n      BooleanUnion\n    \"\"\"\n    if len(input)<2: return scriptcontext.errorhandler()\n    breps = [rhutil.coercebrep(id, True) for id in input]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newbreps = Rhino.Geometry.Brep.CreateBooleanUnion(breps, tolerance)\n    if newbreps is None: return scriptcontext.errorhandler()\n    \n    rc = [scriptcontext.doc.Objects.AddBrep(brep) for brep in newbreps]\n    if delete_input:\n        for id in input: scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef BrepClosestPoint(object_id, point):\n    \"\"\"Returns the point on a surface or polysurface that is closest to a test\n    point. This function works on both untrimmed and trimmed surfaces.\n    Parameters:\n      object_id (guid): The object's identifier.\n      point (point): The test, or sampling point.\n    Returns:\n      tuple(point, [number, number], [number, number], vector): of closest point information if successful. The list will\n      contain the following information:\n      Element     Type             Description\n         0        Point3d          The 3-D point at the parameter value of the \n                                   closest point.\n         1        (U, V)           Parameter values of closest point. Note, V \n                                   is 0 if the component index type is brep_edge\n                                   or brep_vertex. \n         2        (type, index)    The type and index of the brep component that\n                                   contains the closest point. Possible types are\n                                   brep_face, brep_edge or brep_vertex.\n         3        Vector3d         The normal to the brep_face, or the tangent\n                                   to the brep_edge.  \n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if obj:\n          point = rs.GetPoint(\"Pick a test point\")\n          if point:\n              arrCP = rs.BrepClosestPoint(obj, point)\n              if arrCP:\n                  rs.AddPoint(point)\n                  rs.AddPoint( arrCP[0] )\n    See Also:\n      EvaluateSurface\n      IsSurface\n      SurfaceClosestPoint\n    \"\"\"\n    brep = rhutil.coercebrep(object_id, True)\n    point = rhutil.coerce3dpoint(point, True)\n    rc = brep.ClosestPoint(point, 0.0)\n    if rc[0]:\n        type = int(rc[2].ComponentIndexType)\n        index = rc[2].Index\n        return rc[1], (rc[3], rc[4]), (type, index), rc[5]\n\n\ndef CapPlanarHoles(surface_id):\n    \"\"\"Caps planar holes in a surface or polysurface\n    Parameters:\n      surface_id (guid): The identifier of the surface or polysurface to cap.\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      surface = rs.GetObject(\"Select surface or polysurface to cap\", rs.filter.surface | rs.filter.polysurface)\n      if surface: rs.CapPlanarHoles( surface )\n    See Also:\n      ExtrudeCurve\n      ExtrudeCurvePoint\n      ExtrudeCurveStraight\n      ExtrudeSurface\n    \"\"\"\n    brep = rhutil.coercebrep(surface_id, True)\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newbrep = brep.CapPlanarHoles(tolerance)\n    if newbrep:\n        if newbrep.SolidOrientation == Rhino.Geometry.BrepSolidOrientation.Inward:\n            newbrep.Flip()\n        surface_id = rhutil.coerceguid(surface_id)\n        if surface_id and scriptcontext.doc.Objects.Replace(surface_id, newbrep):\n            scriptcontext.doc.Views.Redraw()\n            return True\n    return False\n\n\ndef DuplicateEdgeCurves(object_id, select=False):\n    \"\"\"Duplicates the edge curves of a surface or polysurface. For more\n    information, see the Rhino help file for information on the DupEdge\n    command.\n    Parameters:\n      object_id (guid): The identifier of the surface or polysurface object.\n      select (bool, optional):  Select the duplicated edge curves. The default is not\n      to select (False).\n    Returns:\n      list(guid, ..): identifying the newly created curve objects if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select surface or polysurface\", rs.filter.surface | rs.filter.polysurface)\n      if obj:\n          rs.DuplicateEdgeCurves( obj, True )\n          rs.DeleteObject( obj )\n    See Also:\n      IsPolysurface\n      IsSurface\n    \"\"\"\n    brep = rhutil.coercebrep(object_id, True)\n    out_curves = brep.DuplicateEdgeCurves()\n    curves = []\n    for curve in out_curves:\n        if curve.IsValid:\n            rc = scriptcontext.doc.Objects.AddCurve(curve)\n            curve.Dispose()\n            if rc==System.Guid.Empty: return None\n            curves.append(rc)\n            if select: \n                rhobject = rhutil.coercerhinoobject(rc)\n                rhobject.Select(True)\n    if curves: scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef DuplicateSurfaceBorder(surface_id, type=0):\n    \"\"\"Create curves that duplicate a surface or polysurface border\n    Parameters:\n      surface_id (guid): identifier of a surface\n      type (number, optional): the border curves to return\n         0=both exterior and interior,\n         1=exterior\n         2=interior\n    Returns:\n      list(guid, ...): list of curve ids on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      surface = rs.GetObject(\"Select surface or polysurface\", rs.filter.surface | rs.filter.polysurface)\n      if surface: rs.DuplicateSurfaceBorder( surface )\n    See Also:\n      DuplicateEdgeCurves\n      DuplicateMeshBorder\n    \"\"\"\n    brep = rhutil.coercebrep(surface_id, True)\n    inner = type==0 or type==2\n    outer = type==0 or type==1\n    curves = brep.DuplicateNakedEdgeCurves(outer, inner)\n    if curves is None: return scriptcontext.errorhandler()\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance * 2.1\n    curves = Rhino.Geometry.Curve.JoinCurves(curves, tolerance)\n    if curves is None: return scriptcontext.errorhandler()\n    rc = [scriptcontext.doc.Objects.AddCurve(c) for c in curves]\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef EvaluateSurface(surface_id, u, v):\n    \"\"\"Evaluates a surface at a U,V parameter\n    Parameters:\n      surface_id (guid): the object's identifier.\n      u, v ({number, number]): u, v parameters to evaluate.\n    Returns:\n      point: a 3-D point if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      objectId = rs.GetObject(\"Select a surface\")\n      if rs.IsSurface(objectId):\n          domainU = rs.SurfaceDomain(objectId, 0)\n          domainV = rs.SurfaceDomain(objectId, 1)\n          u = domainU[1]/2.0\n          v = domainV[1]/2.0\n          point = rs.EvaluateSurface(objectId, u, v)\n          rs.AddPoint( point )\n    See Also:\n      IsSurface\n      SurfaceClosestPoint\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    rc = surface.PointAt(u,v)\n    if rc.IsValid: return rc\n    return scriptcontext.errorhandler()\n\n\ndef ExtendSurface(surface_id, parameter, length, smooth=True):\n    \"\"\"Lengthens an untrimmed surface object\n    Parameters:\n      surface_id (guid): identifier of a surface\n      parameter ([number, number}): tuple of two values definfing the U,V parameter to evaluate.\n        The surface edge closest to the U,V parameter will be the edge that is\n        extended\n      length (number): amount to extend to surface\n      smooth (bool, optional): If True, the surface is extended smoothly curving from the\n        edge. If False, the surface is extended in a straight line from the edge\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      pick = rs.GetObjectEx(\"Select surface to extend\", rs.filter.surface)\n      if pick:\n          parameter = rs.SurfaceClosestPoint(pick[0], pick[3])\n          rs.ExtendSurface(pick[0], parameter, 5.0)\n    See Also:\n      IsSurface\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    edge = surface.ClosestSide(parameter[0], parameter[1])\n    newsrf = surface.Extend(edge, length, smooth)\n    if newsrf:\n        surface_id = rhutil.coerceguid(surface_id)\n        if surface_id: scriptcontext.doc.Objects.Replace(surface_id, newsrf)\n        scriptcontext.doc.Views.Redraw()\n    return newsrf is not None\n\n\ndef ExplodePolysurfaces(object_ids, delete_input=False):\n    \"\"\"Explodes, or unjoins, one or more polysurface objects. Polysurfaces\n    will be exploded into separate surfaces\n    Parameters:\n      object_ids ([guid, ...]): identifiers of polysurfaces to explode\n      delete_input 9bool, optional): delete input objects after exploding\n    Returns:\n      list(guid, ...): of identifiers of exploded pieces on success\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select polysurface to explode\", rs.filter.polysurface)\n      if rs.IsPolysurface(obj):\n          rs.ExplodePolysurfaces( obj )\n    See Also:\n      IsPolysurface\n      IsSurface\n    \"\"\"\n    id = rhutil.coerceguid(object_ids, False)\n    if id: object_ids = [id]\n    ids = []\n    for id in object_ids:\n        brep = rhutil.coercebrep(id, True)\n        if brep.Faces.Count>1:\n            for i in range(brep.Faces.Count):\n                copyface = brep.Faces[i].DuplicateFace(False)\n                face_id = scriptcontext.doc.Objects.AddBrep(copyface)\n                if face_id!=System.Guid.Empty: ids.append(face_id)\n            if delete_input: scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef ExtractIsoCurve(surface_id, parameter, direction):\n    \"\"\"Extracts isoparametric curves from a surface\n    Parameters:\n      surface_id (guid): identifier of a surface\n      parameter ([number, number]): u,v parameter of the surface to evaluate\n      direction (number): Direction to evaluate\n        0 = u\n        1 = v\n        2 = both\n    Returns:\n      list(guid, ...): of curve ids on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select surface for isocurve extraction\", rs.filter.surface)\n      point = rs.GetPointOnSurface(obj, \"Select location for extraction\")\n      parameter = rs.SurfaceClosestPoint(obj, point)\n      rs.ExtractIsoCurve( obj, parameter, 2 )\n    See Also:\n      IsSurface\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    ids = []\n    if direction==0 or direction==2:\n        curves = None\n        if type(surface) is Rhino.Geometry.BrepFace:\n            curves = surface.TrimAwareIsoCurve(0, parameter[1])\n        else:\n            curves = [surface.IsoCurve(0,parameter[1])]\n        if curves:\n            for curve in curves:\n                id = scriptcontext.doc.Objects.AddCurve(curve)\n                if id!=System.Guid.Empty: ids.append(id)\n    if direction==1 or direction==2:\n        curves = None\n        if type(surface) is Rhino.Geometry.BrepFace:\n            curves = surface.TrimAwareIsoCurve(1, parameter[0])\n        else:\n            curves = [surface.IsoCurve(1,parameter[0])]\n        if curves:\n            for curve in curves:\n                id = scriptcontext.doc.Objects.AddCurve(curve)\n                if id!=System.Guid.Empty: ids.append(id)\n    scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef ExtractSurface(object_id, face_indices, copy=False):\n    \"\"\"Separates or copies a surface or a copy of a surface from a polysurface\n    Parameters:\n      object_id (guid): polysurface identifier\n      face_indices (number, ...): one or more numbers representing faces\n      copy (bool, optional): If True the faces are copied. If False, the faces are extracted\n    Returns:\n      list(guid, ...): identifiers of extracted surface objects on success\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select polysurface\", rs.filter.polysurface, True)\n      if obj: rs.ExtractSurface(obj, 0)\n    See Also:\n      BrepClosestPoint\n      IsSurface\n      IsPolysurface\n    \"\"\"\n    brep = rhutil.coercebrep(object_id, True)\n    if hasattr(face_indices, \"__getitem__\"): pass\n    else: face_indices = [face_indices]\n    rc = []\n    face_indices = sorted(face_indices, reverse=True)\n    for index in face_indices:\n        face = brep.Faces[index]\n        newbrep = face.DuplicateFace(True)\n        id = scriptcontext.doc.Objects.AddBrep(newbrep)\n        rc.append(id)\n    if not copy:\n        for index in face_indices: brep.Faces.RemoveAt(index)\n        id = rhutil.coerceguid(object_id)\n        scriptcontext.doc.Objects.Replace(id, brep)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ExtrudeCurve(curve_id, path_id):\n    \"\"\"Creates a surface by extruding a curve along a path\n    Parameters:\n      curve_id (guid): identifier of the curve to extrude\n      path_id (guid): identifier of the path curve\n    Returns:\n      guid: identifier of new surface on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.AddCircle(rs.WorldXYPlane(), 5)\n      path = rs.AddLine([5,0,0], [10,0,10])\n      rs.ExtrudeCurve( curve, path )\n    See Also:\n      ExtrudeCurvePoint\n      ExtrudeCurveStraight\n      ExtrudeSurface\n    \"\"\"\n    curve1 = rhutil.coercecurve(curve_id, -1, True)\n    curve2 = rhutil.coercecurve(path_id, -1, True)\n    srf = Rhino.Geometry.SumSurface.Create(curve1, curve2)\n    rc = scriptcontext.doc.Objects.AddSurface(srf)\n    if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ExtrudeCurvePoint(curve_id, point):\n    \"\"\"Creates a surface by extruding a curve to a point\n    Parameters:\n      curve_id (guid): identifier of the curve to extrude\n      point (point): 3D point\n    Returns:\n      guid: identifier of new surface on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.AddCircle(rs.WorldXYPlane(), 5)\n      point = (0,0,10)\n      rs.ExtrudeCurvePoint( curve, point )\n    See Also:\n      ExtrudeCurve\n      ExtrudeCurveStraight\n      ExtrudeSurface\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    point = rhutil.coerce3dpoint(point, True)\n    srf = Rhino.Geometry.Surface.CreateExtrusionToPoint(curve, point)\n    rc = scriptcontext.doc.Objects.AddSurface(srf)\n    if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ExtrudeCurveStraight(curve_id, start_point, end_point):\n    \"\"\"Create surface by extruding a curve along two points that define a line\n    Parameters:\n      curve_id (guid): identifier of the curve to extrude\n      start_point, end_point (point): 3D points that specify distance and direction\n    Returns:\n      guid: identifier of new surface on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.AddCircle(rs.WorldXYPlane(), 5)\n      rs.ExtrudeCurveStraight( curve, (0,0,0), (0, 10, 10) )\n    See Also:\n      ExtrudeCurve\n      ExtrudeCurvePoint\n      ExtrudeSurface\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    start_point = rhutil.coerce3dpoint(start_point, True)\n    end_point = rhutil.coerce3dpoint(end_point, True)\n    vec = end_point - start_point\n    srf = Rhino.Geometry.Surface.CreateExtrusion(curve, vec)\n    rc = scriptcontext.doc.Objects.AddSurface(srf)\n    if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ExtrudeSurface(surface, curve, cap=True):\n    \"\"\"Create surface by extruding along a path curve\n    Parameters:\n      surface (guid): identifier of the surface to extrude\n      curve (guid): identifier of the path curve\n      cap (bool, optional): extrusion is capped at both ends\n    Returns:\n      guid: identifier of new surface on success\n    Example:\n      import rhinoscriptsyntax as rs\n      surface = rs.AddSrfPt([(0,0,0), (5,0,0), (5,5,0), (0,5,0)])\n      curve = rs.AddLine((5,0,0), (10,0,10))\n      rs.ExtrudeSurface(surface, curve)\n    See Also:\n      ExtrudeCurve\n      ExtrudeCurvePoint\n      ExtrudeCurveStraight\n    \"\"\"\n    brep = rhutil.coercebrep(surface, True)\n    curve = rhutil.coercecurve(curve, -1, True)\n    newbrep = brep.Faces[0].CreateExtrusion(curve, cap)\n    if newbrep:\n        rc = scriptcontext.doc.Objects.AddBrep(newbrep)\n        scriptcontext.doc.Views.Redraw()\n        return rc\n\n\ndef FilletSurfaces(surface0, surface1, radius, uvparam0=None, uvparam1=None):\n    \"\"\"Create constant radius rolling ball fillets between two surfaces. Note,\n    this function does not trim the original surfaces of the fillets\n    Parameters:\n      surface0, surface1 (guid): identifiers of first and second surface\n      radius (number): a positive fillet radius\n      uvparam0 ([number, number], optional): a u,v surface parameter of surface0 near where the fillet\n        is expected to hit the surface\n      uvparam1([number, number], optional): same as uvparam0, but for surface1\n    Returns:\n      guid: ids of surfaces created on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      surface0 = rs.GetObject(\"First surface\", rs.filter.surface)\n      surface1 = rs.GetObject(\"Second surface\", rs.filter.surface)\n      rs.FilletSurfaces(surface0, surface1, 2.0)\n    See Also:\n      IsSurface\n    \"\"\"\n    surface0 = rhutil.coercesurface(surface0, True)\n    surface1 = rhutil.coercesurface(surface1, True)\n    if uvparam0 is not None and uvparam1 is not None:   #SR9 error: \"Could not convert None to a Point2d\"\n        uvparam0 = rhutil.coerce2dpoint(uvparam0, True)\n        uvparam1 = rhutil.coerce2dpoint(uvparam1, True)\n    surfaces = None\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    if uvparam0 and uvparam1:\n        surfaces = Rhino.Geometry.Surface.CreateRollingBallFillet(surface0, uvparam0, surface1, uvparam1, radius, tol)\n    else:\n        surfaces = Rhino.Geometry.Surface.CreateRollingBallFillet(surface0, surface1, radius, tol)\n    if not surfaces: return scriptcontext.errorhandler()\n    rc = []\n    for surf in surfaces:\n        rc.append( scriptcontext.doc.Objects.AddSurface(surf) )\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef FlipSurface(surface_id, flip=None):\n    \"\"\"Returns or changes the normal direction of a surface. This feature can\n    also be found in Rhino's Dir command\n    Parameters:\n      surface_id (guid): identifier of a surface object\n      flip (bool, optional) new normal orientation, either flipped(True) or not flipped (False).\n    Returns:\n      vector: if flipped is not specified, the current normal orientation\n      vector: if flipped is specified, the previous normal orientation\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      surf = rs.GetObject(\"Select object\", rs.filter.surface)\n      if surf:\n          flip = rs.FlipSurface(surf)\n          if flip: rs.FlipSurface(surf, False)\n    See Also:\n      IsSurface\n    \"\"\"\n    brep = rhutil.coercebrep(surface_id, True)\n    if brep.Faces.Count>1: return scriptcontext.errorhandler()\n    face = brep.Faces[0]\n    old_reverse = face.OrientationIsReversed\n    if flip!=None and brep.IsSolid==False and old_reverse!=flip:\n        brep.Flip()\n        surface_id = rhutil.coerceguid(surface_id)\n        if surface_id: scriptcontext.doc.Objects.Replace(surface_id, brep)\n        scriptcontext.doc.Views.Redraw()\n    return old_reverse\n\n\ndef IntersectBreps(brep1, brep2, tolerance=None):\n    \"\"\"Intersects a brep object with another brep object. Note, unlike the\n    SurfaceSurfaceIntersection function this function works on trimmed surfaces.\n    Parameters:\n      brep1 (guid): identifier of first brep object\n      brep2 (guid): identifier of second brep object\n      tolerance (number): Distance tolerance at segment midpoints. If omitted,\n                  the current absolute tolerance is used.\n    Returns:\n      list(guid, ...): identifying the newly created intersection curve and point objects if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      brep1 = rs.GetObject(\"Select the first brep\", rs.filter.surface | rs.filter.polysurface)\n      if brep1:\n          brep2 = rs.GetObject(\"Select the second\", rs.filter.surface | rs.filter.polysurface)\n          if brep2: rs.IntersectBreps( brep1, brep2)\n    See Also:\n      \n    \"\"\"\n    brep1 = rhutil.coercebrep(brep1, True)\n    brep2 = rhutil.coercebrep(brep2, True)\n    if tolerance is None or tolerance < 0.0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    rc = Rhino.Geometry.Intersect.Intersection.BrepBrep(brep1, brep2, tolerance)\n    if not rc[0]: return None\n    out_curves = rc[1]\n    out_points = rc[2]\n    merged_curves = Rhino.Geometry.Curve.JoinCurves(out_curves, 2.1 * tolerance)\n    \n    ids = []\n    if merged_curves:\n        for curve in merged_curves:\n            if curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n                curve.Dispose()\n                if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n                ids.append(rc)\n    else:\n        for curve in out_curves:\n            if curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n                curve.Dispose()\n                if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n                ids.append(rc)\n    for point in out_points:\n        rc = scriptcontext.doc.Objects.AddPoint(point)\n        if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n        ids.append(rc)\n    if ids:\n        scriptcontext.doc.Views.Redraw()\n        return ids\n\n\ndef IntersectSpheres(sphere_plane0, sphere_radius0, sphere_plane1, sphere_radius1):\n    \"\"\"Calculates intersections of two spheres\n    Parameters:\n      sphere_plane0 (plane): an equatorial plane of the first sphere. The origin of the\n        plane will be the center point of the sphere\n      sphere_radius0 (number): radius of the first sphere\n      sphere_plane1 (plane): plane for second sphere\n      sphere_radius1 (number): radius for second sphere\n    Returns:\n      list(number, point, number): of intersection results\n        [0] = type of intersection (0=point, 1=circle, 2=spheres are identical)\n        [1] = Point of intersection or plane of circle intersection\n        [2] = radius of circle if circle intersection\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      plane0 = rs.WorldXYPlane()\n      plane1 = rs.MovePlane(plane0, (10,0,0))\n      radius = 10\n      results = rs.IntersectSpheres(plane0, radius, plane1, radius)\n      if results:\n          if results[0] == 0: rs.AddPoint(results[1])\n          else: rs.AddCircle( results[1], results[2])\n    See Also:\n      IntersectBreps\n      IntersectPlanes\n    \"\"\"\n    plane0 = rhutil.coerceplane(sphere_plane0, True)\n    plane1 = rhutil.coerceplane(sphere_plane1, True)\n    sphere0 = Rhino.Geometry.Sphere(plane0, sphere_radius0)\n    sphere1 = Rhino.Geometry.Sphere(plane1, sphere_radius1)\n    rc, circle = Rhino.Geometry.Intersect.Intersection.SphereSphere(sphere0, sphere1)\n    if rc==Rhino.Geometry.Intersect.SphereSphereIntersection.Point:\n        return [0, circle.Center]\n    if rc==Rhino.Geometry.Intersect.SphereSphereIntersection.Circle:\n        return [1, circle.Plane, circle.Radius]\n    if rc==Rhino.Geometry.Intersect.SphereSphereIntersection.Overlap:\n        return [2]\n    return scriptcontext.errorhandler()\n\n\ndef IsBrep(object_id):\n    \"\"\"Verifies an object is a Brep, or a boundary representation model, object.\n    Parameters:\n      object_id (guid): The object's identifier.\n    Returns:\n      bool: True if successful, otherwise False.\n      None: on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a Brep\")\n      if rs.IsBrep(obj):\n          print(\"The object is a Brep.\")\n      else:\n          print(\"The object is not a Brep.\")\n    See Also:\n      IsPolysurface\n      IsPolysurfaceClosed\n      IsSurface\n    \"\"\"\n    return rhutil.coercebrep(object_id)!=None\n\n\ndef IsCone(object_id):\n    \"\"\"Determines if a surface is a portion of a cone\n    Parameters:\n      object_id (guid): the surface object's identifier\n    Returns:\n      bool: True if successful, otherwise False\n    Example:\n      import rhinoscriptsyntax as rs\n      surface = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if surface:\n          if rs.IsCone(surface):\n              print(\"The surface is a portion of a cone.\")\n          else:\n              print(\"The surface is not a portion of a cone.\")\n    See Also:\n      IsCylinder\n      IsSphere\n      IsSurface\n      IsTorus\n    \"\"\"\n    surface = rhutil.coercesurface(object_id, True)\n    return surface.IsCone()\n\n\ndef IsCylinder(object_id):\n    \"\"\"Determines if a surface is a portion of a cone\n    Parameters:\n      object_id (guid): the cylinder object's identifier\n    Returns:\n      bool: True if successful, otherwise False\n    Example:\n      import rhinoscriptsyntax as rs\n      surface = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if surface:\n          if rs.IsCylinder(surface):\n              print(\"The surface is a portion of a cylinder.\")\n          else:\n              print(\"The surface is not a portion of a cylinder.\")\n    See Also:\n      IsCone\n      IsSphere\n      IsSurface\n      IsTorus\n    \"\"\"\n    surface = rhutil.coercesurface(object_id, True)\n    return surface.IsCylinder()\n\n\ndef IsPlaneSurface(object_id):\n    \"\"\"Verifies an object is a plane surface. Plane surfaces can be created by\n    the Plane command. Note, a plane surface is not a planar NURBS surface\n    Parameters:\n      object_id (guid): the object's identifier\n    Returns:\n      bool: True if successful, otherwise False\n    Example:\n      import rhinoscriptsyntax as rs\n      surface = rs.GetObject(\"Select surface to trim\", rs.filter.surface)\n      if surface and rs.IsPlaneSurface(surface):\n          print(\"got a plane surface\")\n      else:\n          print(\"not a plane surface\")\n    See Also:\n      IsBrep\n      IsPolysurface\n      IsSurface\n    \"\"\"\n    face = rhutil.coercesurface(object_id, True)\n    if type(face) is Rhino.Geometry.BrepFace and face.IsSurface:\n        return type(face.UnderlyingSurface()) is Rhino.Geometry.PlaneSurface\n    return False\n    \n\ndef IsPointInSurface(object_id, point, strictly_in=False, tolerance=None):\n    \"\"\"Verifies that a point is inside a closed surface or polysurface\n    Parameters:\n      object_id (guid): the object's identifier\n      point (point): The test, or sampling point\n      strictly_in (bool, optional): If true, the test point must be inside by at least tolerance\n      tolerance (number, optional): distance tolerance used for intersection and determining\n        strict inclusion. If omitted, Rhino's internal tolerance is used\n    Returns:\n      bool: True if successful, otherwise False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polysurface\", rs.filter.polysurface)\n      if rs.IsPolysurfaceClosed(obj):\n          point = rs.GetPoint(\"Pick a test point\")\n          if point:\n              if rs.IsPointInSurface(obj, point):\n                  print(\"The point is inside the polysurface.\")\n              else:\n                  print(\"The point is not inside the polysurface.\")\n    See Also:\n      IsPointOnSurface\n    \"\"\"\n    object_id = rhutil.coerceguid(object_id, True)\n    point = rhutil.coerce3dpoint(point, True)\n    if object_id==None or point==None: return scriptcontext.errorhandler()\n    obj = scriptcontext.doc.Objects.Find(object_id)\n    if tolerance is None: tolerance = Rhino.RhinoMath.SqrtEpsilon\n    brep = None\n    if type(obj)==Rhino.DocObjects.ExtrusionObject:\n        brep = obj.ExtrusionGeometry.ToBrep(False)\n    elif type(obj)==Rhino.DocObjects.BrepObject:\n        brep = obj.BrepGeometry\n    elif hasattr(obj, \"Geometry\"):\n        brep = obj.Geometry\n    return brep.IsPointInside(point, tolerance, strictly_in)\n\n\ndef IsPointOnSurface(object_id, point):\n    \"\"\"Verifies that a point lies on a surface\n    Parameters:\n      object_id (guid): the object's identifier\n      point (point): The test, or sampling point\n    Returns:\n      bool: True if successful, otherwise False\n    Example:\n      import rhinoscriptsyntax as rs\n      surf = rs.GetObject(\"Select a surface\")\n      if rs.IsSurface(surf):\n          point = rs.GetPoint(\"Pick a test point\")\n          if point:\n              if rs.IsPointOnSurface(surf, point):\n                  print(\"The point is on the surface.\")\n              else:\n                  print(\"The point is not on the surface.\")\n    See Also:\n      IsPointInSurface\n    \"\"\"\n    surf = rhutil.coercesurface(object_id, True)\n    point = rhutil.coerce3dpoint(point, True)\n    rc, u, v = surf.ClosestPoint(point)\n    if rc:\n        srf_pt = surf.PointAt(u,v)\n        if srf_pt.DistanceTo(point)>scriptcontext.doc.ModelAbsoluteTolerance:\n            rc = False\n        else:\n            rc = surf.IsPointOnFace(u,v) != Rhino.Geometry.PointFaceRelation.Exterior\n    return rc\n\n\ndef IsPolysurface(object_id):\n    \"\"\"Verifies an object is a polysurface. Polysurfaces consist of two or more\n    surfaces joined together. If the polysurface fully encloses a volume, it is\n    considered a solid.\n    Parameters:\n      object_id (guid): the object's identifier\n    Returns:\n      bool: True is successful, otherwise False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polysurface\")\n      if rs.IsPolysurface(obj):\n          print(\"The object is a polysurface.\")\n      else:\n          print(\"The object is not a polysurface.\")\n    See Also:\n      IsBrep\n      IsPolysurfaceClosed\n    \"\"\"\n    brep = rhutil.coercebrep(object_id)\n    if brep is None: return False\n    return brep.Faces.Count>1\n\n\ndef IsPolysurfaceClosed(object_id):\n    \"\"\"Verifies a polysurface object is closed. If the polysurface fully encloses\n    a volume, it is considered a solid.\n    Parameters:\n      object_id (guid): the object's identifier\n    Returns:\n      bool: True is successful, otherwise False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polysurface\", rs.filter.polysurface)\n      if rs.IsPolysurfaceClosed(obj):\n          print(\"The polysurface is closed.\")\n      else:\n          print(\"The polysurface is not closed.\")\n    See Also:\n      IsBrep\n      IsPolysurface\n    \"\"\"\n    brep = rhutil.coercebrep(object_id, True)\n    return brep.IsSolid\n\n\ndef IsSphere(object_id):\n    \"\"\"Determines if a surface is a portion of a sphere\n    Parameters:\n      object_id (guid): the object's identifier\n    Returns:\n      bool: True if successful, otherwise False\n    Example:\n      import rhinoscriptsyntax as rs\n      surface = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if surface:\n          if rs.IsSphere(surface):\n              print(\"The surface is a portion of a sphere.\")\n          else:\n              print(\"The surface is not a portion of a sphere.\")\n    See Also:\n      IsCone\n      IsCylinder\n      IsSurface\n      IsTorus\n    \"\"\"\n    surface = rhutil.coercesurface(object_id, True)\n    return surface.IsSphere()\n\n\ndef IsSurface(object_id):\n    \"\"\"Verifies an object is a surface. Brep objects with only one face are\n    also considered surfaces.\n    Parameters:\n      object_id (guid): the object's identifier.\n    Returns:\n      bool: True if successful, otherwise False.\n    Example:\n      import rhinoscriptsyntax as rs\n      objectId = rs.GetObject(\"Select a surface\")\n      if rs.IsSurface(objectId):\n          print(\"The object is a surface.\")\n      else:\n          print(\"The object is not a surface.\")\n    See Also:\n      IsPointOnSurface\n      IsSurfaceClosed\n      IsSurfacePlanar\n      IsSurfaceSingular\n      IsSurfaceTrimmed\n    \"\"\"\n    brep = rhutil.coercebrep(object_id)\n    if brep and brep.Faces.Count==1: return True\n    surface = rhutil.coercesurface(object_id)\n    return (surface!=None)\n\n\ndef IsSurfaceClosed( surface_id, direction ):\n    \"\"\"Verifies a surface object is closed in the specified direction.  If the\n    surface fully encloses a volume, it is considered a solid\n    Parameters:\n      surface_id (guid): identifier of a surface\n      direction (number): 0=U direction check, 1=V direction check\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if rs.IsSurfaceClosed(obj, 0):\n          print(\"The surface is closed in the U direction.\")\n      else:\n          print(\"The surface is not closed in the U direction.\")\n    See Also:\n      IsSurface\n      IsSurfacePlanar\n      IsSurfaceSingular\n      IsSurfaceTrimmed\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    return surface.IsClosed(direction)\n\n\ndef IsSurfacePeriodic(surface_id, direction):\n    \"\"\"Verifies a surface object is periodic in the specified direction.\n    Parameters:\n      surface_id (guid): identifier of a surface\n      direction (number): 0=U direction check, 1=V direction check\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if rs.IsSurfacePeriodic(obj, 0):\n          print(\"The surface is periodic in the U direction.\")\n      else:\n          print(\"The surface is not periodic in the U direction.\")\n    See Also:\n      IsSurface\n      IsSurfaceClosed\n      IsSurfacePlanar\n      IsSurfaceSingular\n      IsSurfaceTrimmed\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    return surface.IsPeriodic(direction)\n\n\ndef IsSurfacePlanar(surface_id, tolerance=None):\n    \"\"\"Verifies a surface object is planar\n    Parameters:\n      surface_id (guid): identifier of a surface\n      tolerance (number): tolerance used when checked. If omitted, the current absolute\n        tolerance is used\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if rs.IsSurfacePlanar(obj):\n          print(\"The surface is planar.\")\n      else:\n          print(\"The surface is not planar.\")\n    See Also:\n      IsSurface\n      IsSurfaceClosed\n      IsSurfaceSingular\n      IsSurfaceTrimmed\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    if tolerance is None:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    return surface.IsPlanar(tolerance)\n\n\ndef IsSurfaceRational(surface_id):\n    \"\"\"Verifies a surface object is rational\n    Parameters:\n      surface_id (guid): the surface's identifier\n    Returns:\n      bool: True if successful, otherwise False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if rs.IsSurfaceRational(obj):\n          print(\"The surface is rational.\")\n      else:\n          print(\"The surface is not rational.\")\n    See Also:\n      IsSurface\n      IsSurfaceClosed\n      IsSurfacePlanar\n      IsSurfaceTrimmed\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    ns = surface.ToNurbsSurface()\n    if ns is None: return False\n    return ns.IsRational\n\n\ndef IsSurfaceSingular(surface_id, direction):\n    \"\"\"Verifies a surface object is singular in the specified direction.\n    Surfaces are considered singular if a side collapses to a point.\n    Parameters:\n      surface_id (guid): the surface's identifier\n      direction (number):\n        0=south\n        1=east\n        2=north\n        3=west\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if rs.IsSurfaceSingular(obj, 0):\n          print(\"The surface is singular.\")\n      else:\n          print(\"The surface is not singular.\")\n    See Also:\n      IsSurface\n      IsSurfaceClosed\n      IsSurfacePlanar\n      IsSurfaceTrimmed\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    return surface.IsSingular(direction)\n\n\ndef IsSurfaceTrimmed(surface_id):\n    \"\"\"Verifies a surface object has been trimmed\n    Parameters:\n      surface_id (guid): the surface's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if rs.IsSurfaceTrimmed(obj):\n          print(\"The surface is trimmed.\")\n      else:\n          print(\"The surface is not trimmed.\")\n    See Also:\n      IsSurface\n      IsSurfaceClosed\n      IsSurfacePlanar\n      IsSurfaceSingular\n    \"\"\"\n    brep = rhutil.coercebrep(surface_id, True)\n    return not brep.IsSurface\n\n\ndef IsTorus(surface_id):\n    \"\"\"Determines if a surface is a portion of a torus\n    Parameters:\n      surface_id (guid): the surface object's identifier\n    Returns:\n      bool: True if successful, otherwise False\n    Example:\n      import rhinoscriptsyntax as rs\n      surface = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if surface:\n          if rs.IsTorus(surface):\n              print(\"The surface is a portion of a torus.\")\n          else:\n              print(\"The surface is not a portion of a torus.\")\n    See Also:\n      IsCone\n      IsCylinder\n      IsSphere\n      IsSurface\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    return surface.IsTorus()\n\n\ndef SurfaceSphere(surface_id):\n    \"\"\"Gets the sphere definition from a surface, if possible.\n    Parameters:\n      surface_id (guid): the identifier of the surface object\n    Returns:\n      (plane, number): The equatorial plane of the sphere, and its radius.\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      surface = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if surface:\n          result = rs.SurfaceSphere(surface)\n          if result:\n              print(\"The sphere radius is: \" + str(result[1]))\n    See Also:\n      SurfaceCylinder\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    is_sphere, sphere = surface.TryGetSphere(tol)\n    rc = None\n    if is_sphere: rc = (sphere.EquatorialPlane, sphere.Radius)\n    return rc\n\n\ndef JoinSurfaces(object_ids, delete_input=False, return_all=False):\n    \"\"\"Joins two or more surface or polysurface objects together to form one\n    polysurface object\n    Parameters:\n      object_ids ([guid, ...]) list of object identifiers\n      delete_input (bool, optional): Delete the original surfaces\n      return_all (bool, optional): Return all surfaces in result\n    Returns:\n      guid or guid list: identifier, or list of identifiers if return_all == True, of newly created object(s) on success\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      objs = rs.GetObjects(\"Select surfaces in order\", rs.filter.surface)\n      if objs and len(objs)>1: rs.JoinSurfaces(objs)\n    See Also:\n      ExplodePolysurfaces\n      IsPolysurface\n      IsPolysurfaceClosed\n      IsSurface\n      IsSurfaceClosed\n    \"\"\"\n    breps = [rhutil.coercebrep(id, True) for id in object_ids]\n    if len(breps)<2: return scriptcontext.errorhandler()\n    tol = scriptcontext.doc.ModelAbsoluteTolerance * 2.1\n    joinedbreps = Rhino.Geometry.Brep.JoinBreps(breps, tol)\n    if joinedbreps is None or (len(joinedbreps)!=1 and return_all == False):\n        return scriptcontext.errorhandler()\n    rc = []\n    for brep in joinedbreps:\n        id = scriptcontext.doc.Objects.AddBrep(brep)\n        if id==System.Guid.Empty: return scriptcontext.errorhandler()\n        rc.append(id)\n    if delete_input:\n        for id in object_ids:\n            id = rhutil.coerceguid(id)\n            scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc if return_all else rc[0]\n\n\ndef MakeSurfacePeriodic(surface_id, direction, delete_input=False):\n    \"\"\"Makes an existing surface a periodic NURBS surface\n    Parameters:\n      surface_id (guid): the surface's identifier\n      direction (number): The direction to make periodic, either 0=U or 1=V\n      delete_input (bool, optional): delete the input surface\n    Returns:\n      guid: if delete_input is False, identifier of the new surface\n      guid: if delete_input is True, identifier of the modifier surface\n      None: on error\n    Example:\n      import rhinoscriptsyntax as  rs\n      obj = rs.GetObject(\"Select  a surface\", rs.filter.surface)\n      if not rs.IsSurfacePeriodic(obj,  0):\n          rs.MakeSurfacePeriodic(obj,  0)\n    See Also:\n      IsSurfacePeriodic\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    newsurf = Rhino.Geometry.Surface.CreatePeriodicSurface(surface, direction)\n    if newsurf is None: return scriptcontext.errorhandler()\n    id = rhutil.coerceguid(surface_id)\n    if delete_input:\n        scriptcontext.doc.Objects.Replace(id, newsurf)\n    else:\n        id = scriptcontext.doc.Objects.AddSurface(newsurf)\n    scriptcontext.doc.Views.Redraw()\n    return id\n\n\ndef OffsetSurface(surface_id, distance, tolerance=None, both_sides=False, create_solid=False):\n    \"\"\"Offsets a trimmed or untrimmed surface by a distance. The offset surface\n    will be added to Rhino.\n    Parameters:\n      surface_id (guid): the surface's identifier\n      distance (number): the distance to offset\n      tolerance (number, optional): The offset tolerance. Use 0.0 to make a loose offset. Otherwise, the\n        document's absolute tolerance is usually sufficient.\n      both_sides (bool, optional): Offset to both sides of the input surface\n      create_solid (bool, optional): Make a solid object\n    Returns:\n      guid: identifier of the new object if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      surface = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if rs.IsSurface(surface):\n          rs.OffsetSurface( surface, 10.0 )\n    See Also:\n      OffsetCurve\n    \"\"\"\n    brep = rhutil.coercebrep(surface_id, True)\n    face = None\n    if (1 == brep.Faces.Count): face = brep.Faces[0]\n    if face is None: return scriptcontext.errorhandler()\n    if tolerance is None: tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newbrep = Rhino.Geometry.Brep.CreateFromOffsetFace(face, distance, tolerance, both_sides, create_solid)\n    if newbrep is None: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddBrep(newbrep)\n    if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef PullCurve(surface, curve, delete_input=False):\n    \"\"\"Pulls a curve object to a surface object\n    Parameters:\n      surface (guid): the surface's identifier\n      curve (guid): the curve's identifier\n      delete_input (bool, optional) should the input items be deleted\n    Returns:\n      list(guid, ...): of new curves if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select curve to pull\", rs.filter.curve )\n      surface = rs.GetObject(\"Select surface that pulls\", rs.filter.surface )\n      rs.PullCurve(surface, curve)\n    See Also:\n      IsSurface\n    \"\"\"\n    crvobj = rhutil.coercerhinoobject(curve, True, True)\n    brep = rhutil.coercebrep(surface, True)\n    curve = rhutil.coercecurve(curve, -1, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    curves = Rhino.Geometry.Curve.PullToBrepFace(curve, brep.Faces[0], tol)\n    rc = [scriptcontext.doc.Objects.AddCurve(curve) for curve in curves]\n    if rc:\n        if delete_input and crvobj:\n            scriptcontext.doc.Objects.Delete(crvobj, True)\n        scriptcontext.doc.Views.Redraw()\n        return rc\n\n\ndef RebuildSurface(object_id, degree=(3,3), pointcount=(10,10)):\n    \"\"\"Rebuilds a surface to a given degree and control point count. For more\n    information see the Rhino help file for the Rebuild command\n    Parameters:\n      object_id (guid): the surface's identifier\n      degree ([number, number], optional): two numbers that identify surface degree in both U and V directions\n      pointcount ([number, number], optional): two numbers that identify the surface point count in both the U and V directions\n    Returns:\n      bool: True of False indicating success or failure\n    Example:\n    See Also:\n    \"\"\"\n    surface = rhutil.coercesurface(object_id, True)\n    newsurf = surface.Rebuild( degree[0], degree[1], pointcount[0], pointcount[1] )\n    if newsurf is None: return False\n    object_id = rhutil.coerceguid(object_id)\n    rc = scriptcontext.doc.Objects.Replace(object_id, newsurf)\n    if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef RemoveSurfaceKnot(surface, uv_parameter, v_direction):\n    \"\"\"Deletes a knot from a surface object.\n    Parameters:\n      surface (guid): The reference of the surface object\n      uv_parameter (list(number, number)): An indexable item containing a U,V parameter on the surface. List, tuples and UVIntervals will work.\n        Note, if the parameter is not equal to one of the existing knots, then the knot closest to the specified parameter will be removed.\n      v_direction (bool): if True, or 1, the V direction will be addressed. If False, or 0, the U direction.\n    Returns:\n      bool: True of False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n\n      srf_info = rs.GetSurfaceObject()\n      if srf_info:\n          srf_id = srf_info[0]\n          srf_param = srf_info[4]\n          rs.RemoveSurfaceKnot(srf_id, srf_param, 1)\n    See Also:\n      RemoveSurfaceKnot\n    \"\"\"\n    srf_inst = rhutil.coercesurface(surface, True)\n    u_param = uv_parameter[0]\n    v_param = uv_parameter[1]\n    success, n_u_param, n_v_param = srf_inst.GetSurfaceParameterFromNurbsFormParameter(u_param, v_param)\n    if not success: return False\n    n_srf = srf_inst.ToNurbsSurface()\n    if not n_srf: return False\n    knots = n_srf.KnotsV if v_direction else n_srf.KnotsU\n    success = knots.RemoveKnotsAt(n_u_param, n_v_param)\n    if not success: return False\n    scriptcontext.doc.Objects.Replace(surface, n_srf)\n    scriptcontext.doc.Views.Redraw()\n    return True\n\n\ndef ReverseSurface(surface_id, direction):\n    \"\"\"Reverses U or V directions of a surface, or swaps (transposes) U and V\n    directions.\n    Parameters:\n      surface_id (guid): identifier of a surface object\n      direction (number): as a bit coded flag to swap\n            1 = reverse U\n            2 = reverse V\n            4 = transpose U and V (values can be combined)\n    Returns:\n      bool: indicating success or failure\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface to reverse\")\n      if rs.IsSurface(obj):\n          rs.ReverseSurface( obj, 1 )\n    See Also:\n      FlipSurface\n      IsSurface\n    \"\"\"\n    brep = rhutil.coercebrep(surface_id, True)\n    if not brep.Faces.Count==1: return scriptcontext.errorhandler()\n    face = brep.Faces[0]\n    if direction & 1:\n        face.Reverse(0, True)\n    if direction & 2:\n        face.Reverse(1, True)\n    if direction & 4:\n        face.Transpose(True)\n    scriptcontext.doc.Objects.Replace(surface_id, brep)\n    scriptcontext.doc.Views.Redraw()\n    return True\n\n\ndef ShootRay(surface_ids, start_point, direction, reflections=10):\n    \"\"\"Shoots a ray at a collection of surfaces\n    Parameters:\n      surface_ids ([guid, ...]): one of more surface identifiers\n      start_point (point): starting point of the ray\n      direction (vector):  vector identifying the direction of the ray\n      reflections (number, optional): the maximum number of times the ray will be reflected\n    Returns:\n      list(point, ...): of reflection points on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      def TestRayShooter():\n          corners = []\n          corners.append((0,0,0))\n          corners.append((10,0,0))\n          corners.append((10,10,0))\n          corners.append((0,10,0))\n          corners.append((0,0,10))\n          corners.append((10,0,10))\n          corners.append((10,10,10))\n          corners.append((0,10,10))\n          box = rs.AddBox(corners)\n          dir = 10,7.5,7\n          reflections = rs.ShootRay(box, (0,0,0), dir)\n          rs.AddPolyline( reflections )\n          rs.AddPoints( reflections )\n      TestRayShooter()\n    See Also:\n      IsPolysurface\n      IsSurface\n    \"\"\"\n    start_point = rhutil.coerce3dpoint(start_point, True)\n    direction = rhutil.coerce3dvector(direction, True)\n    id = rhutil.coerceguid(surface_ids, False)\n    if id: surface_ids = [id]\n    ray = Rhino.Geometry.Ray3d(start_point, direction)\n    breps = []\n    for id in surface_ids:\n        brep = rhutil.coercebrep(id)\n        if brep: breps.append(brep)\n        else:\n            surface = rhutil.coercesurface(id, True)\n            breps.append(surface)\n    if not breps: return scriptcontext.errorhandler()\n    points = Rhino.Geometry.Intersect.Intersection.RayShoot(ray, breps, reflections)\n    if points:\n        rc = []\n        rc.append(start_point)\n        rc = rc + list(points)\n        return rc\n    return scriptcontext.errorhandler()\n\n\ndef ShortPath(surface_id, start_point, end_point):\n    \"\"\"Creates the shortest possible curve(geodesic) between two points on a\n    surface. For more details, see the ShortPath command in Rhino help\n    Parameters:\n      surface_id (guid): identifier of a surface\n      start_point, end_point (point): start/end points of the short curve\n    Returns:\n      guid: identifier of the new surface on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      surface = rs.GetObject(\"Select surface for short path\", rs.filter.surface + rs.filter.surface)\n      if surface:\n          start = rs.GetPointOnSurface(surface, \"First point\")\n          end = rs.GetPointOnSurface(surface, \"Second point\")\n          rs.ShortPath(surface, start, end)\n    See Also:\n      EvaluateSurface\n      SurfaceClosestPoint\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    start = rhutil.coerce3dpoint(start_point, True)\n    end = rhutil.coerce3dpoint(end_point, True)\n    rc_start, u_start, v_start = surface.ClosestPoint(start)\n    rc_end, u_end, v_end = surface.ClosestPoint(end)\n    if not rc_start or not rc_end: return scriptcontext.errorhandler()\n    start = Rhino.Geometry.Point2d(u_start, v_start)\n    end = Rhino.Geometry.Point2d(u_end, v_end)\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    curve = surface.ShortPath(start, end, tolerance)\n    if curve is None: return scriptcontext.errorhandler()\n    id = scriptcontext.doc.Objects.AddCurve(curve)\n    if id==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return id\n\n\ndef ShrinkTrimmedSurface(object_id, create_copy=False):\n    \"\"\"Shrinks the underlying untrimmed surfaces near to the trimming\n    boundaries. See the ShrinkTrimmedSrf command in the Rhino help.\n    Parameters:\n      object_id (guid): the surface's identifier\n      create_copy (bool, optional): If True, the original surface is not deleted\n    Returns:\n      bool: If create_copy is False, True or False indicating success or failure\n      bool: If create_copy is True, the identifier of the new surface\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      filter = rs.filter.surface | rs.filter.polysurface\n      surface = rs.GetObject(\"Select surface or polysurface to shrink\", filter )\n      if surface: rs.ShrinkTrimmedSurface( surface )\n    See Also:\n      IsSurfaceTrimmed\n    \"\"\"\n    brep = rhutil.coercebrep(object_id, True)\n    if not brep.Faces.ShrinkFaces(): return scriptcontext.errorhandler()\n    rc = None\n    object_id = rhutil.coerceguid(object_id)\n    if create_copy:\n        oldobj = scriptcontext.doc.Objects.Find(object_id)\n        attr = oldobj.Attributes\n        rc = scriptcontext.doc.Objects.AddBrep(brep, attr)\n    else:\n        rc = scriptcontext.doc.Objects.Replace(object_id, brep)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef __GetMassProperties(object_id, area):\n    surface = rhutil.coercebrep(object_id)\n    if surface is None:\n        surface = rhutil.coercesurface(object_id)\n        if surface is None: return None\n    if area==True: return Rhino.Geometry.AreaMassProperties.Compute(surface)\n    if not surface.IsSolid: return None\n    return Rhino.Geometry.VolumeMassProperties.Compute(surface)\n\n\ndef SplitBrep(brep_id, cutter_id, delete_input=False):\n    \"\"\"Splits a brep\n    Parameters:\n      brep (guid): identifier of the brep to split\n      cutter (guid): identifier of the brep to split with\n    Returns:\n      list(guid, ...): identifiers of split pieces on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      filter = rs.filter.surface + rs.filter.polysurface\n      brep = rs.GetObject(\"Select brep to split\", filter)\n      cutter = rs.GetObject(\"Select cutting brep\", filter)\n      rs.SplitBrep ( brep, cutter )\n    See Also:\n      IsBrep\n    \"\"\"\n    brep = rhutil.coercebrep(brep_id, True)\n    cutter = rhutil.coercebrep(cutter_id, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    pieces = brep.Split(cutter, tol)\n    if not pieces: return scriptcontext.errorhandler()\n    if delete_input:\n        brep_id = rhutil.coerceguid(brep_id)\n        scriptcontext.doc.Objects.Delete(brep_id, True)\n    rc = [scriptcontext.doc.Objects.AddBrep(piece) for piece in pieces]\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef SurfaceArea(object_id):\n    \"\"\"Calculate the area of a surface or polysurface object. The results are\n    based on the current drawing units\n    Parameters:\n      object_id (guid): the surface's identifier\n    Returns:\n      list(number, number): of area information on success (area, absolute error bound)\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if obj:\n          massprop = rs.SurfaceArea( obj )\n          if massprop:\n              print(\"The surface area is: {}\".format(massprop[0]))\n    See Also:\n      SurfaceAreaCentroid\n      SurfaceAreaMoments\n    \"\"\"\n    amp = __GetMassProperties(object_id, True)\n    if amp: return amp.Area, amp.AreaError\n\n\ndef SurfaceAreaCentroid(object_id):\n    \"\"\"Calculates the area centroid of a surface or polysurface\n    Parameters:\n      object_id (guid): the surface's identifier\n    Returns:\n      list(point, tuple(number, number, number)): Area centroid information (Area Centroid, Error bound in X, Y, Z)\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if obj:\n          massprop = rs.SurfaceAreaCentroid(obj)\n          if massprop: rs.AddPoint( massprop[0] )\n    See Also:\n      SurfaceArea\n      SurfaceAreaMoments\n    \"\"\"\n    amp = __GetMassProperties(object_id, True)\n    if amp is None: return scriptcontext.errorhandler()\n    return amp.Centroid, amp.CentroidError\n\n\ndef __AreaMomentsHelper(surface_id, area):\n    mp = __GetMassProperties(surface_id, area)\n    if mp is None: return scriptcontext.errorhandler()\n    a = (mp.WorldCoordinatesFirstMoments.X, mp.WorldCoordinatesFirstMoments.Y, mp.WorldCoordinatesFirstMoments.Z)\n    b = (mp.WorldCoordinatesFirstMomentsError.X, mp.WorldCoordinatesFirstMomentsError.Y, mp.WorldCoordinatesFirstMomentsError.Z)\n    c = (mp.WorldCoordinatesSecondMoments.X, mp.WorldCoordinatesSecondMoments.Y, mp.WorldCoordinatesSecondMoments.Z)\n    d = (mp.WorldCoordinatesSecondMomentsError.X, mp.WorldCoordinatesSecondMomentsError.Y, mp.WorldCoordinatesSecondMomentsError.Z)\n    e = (mp.WorldCoordinatesProductMoments.X, mp.WorldCoordinatesProductMoments.Y, mp.WorldCoordinatesProductMoments.Z)\n    f = (mp.WorldCoordinatesProductMomentsError.X, mp.WorldCoordinatesProductMomentsError.Y, mp.WorldCoordinatesProductMomentsError.Z)\n    g = (mp.WorldCoordinatesMomentsOfInertia.X, mp.WorldCoordinatesMomentsOfInertia.Y, mp.WorldCoordinatesMomentsOfInertia.Z)\n    h = (mp.WorldCoordinatesMomentsOfInertiaError.X, mp.WorldCoordinatesMomentsOfInertiaError.Y, mp.WorldCoordinatesMomentsOfInertiaError.Z)\n    i = (mp.WorldCoordinatesRadiiOfGyration.X, mp.WorldCoordinatesRadiiOfGyration.Y, mp.WorldCoordinatesRadiiOfGyration.Z)\n    j = (0,0,0) # need to add error calc to RhinoCommon\n    k = (mp.CentroidCoordinatesMomentsOfInertia.X, mp.CentroidCoordinatesMomentsOfInertia.Y, mp.CentroidCoordinatesMomentsOfInertia.Z)\n    l = (mp.CentroidCoordinatesMomentsOfInertiaError.X, mp.CentroidCoordinatesMomentsOfInertiaError.Y, mp.CentroidCoordinatesMomentsOfInertiaError.Z)\n    m = (mp.CentroidCoordinatesRadiiOfGyration.X, mp.CentroidCoordinatesRadiiOfGyration.Y, mp.CentroidCoordinatesRadiiOfGyration.Z)\n    n = (0,0,0) #need to add error calc to RhinoCommon\n    return (a,b,c,d,e,f,g,h,i,j,k,l,m,n)\n\n\ndef SurfaceAreaMoments(surface_id):\n    \"\"\"Calculates area moments of inertia of a surface or polysurface object.\n    See the Rhino help for \"Mass Properties calculation details\"\n    Parameters:\n      surface_id (guid): the surface's identifier\n    Returns:\n      list(tuple(number, number,number), ...): of moments and error bounds in tuple(X, Y, Z) - see help topic\n        Index   Description\n        [0]     First Moments.\n        [1]     The absolute (+/-) error bound for the First Moments.\n        [2]     Second Moments.\n        [3]     The absolute (+/-) error bound for the Second Moments.\n        [4]     Product Moments.\n        [5]     The absolute (+/-) error bound for the Product Moments.\n        [6]     Area Moments of Inertia about the World Coordinate Axes.\n        [7]     The absolute (+/-) error bound for the Area Moments of Inertia about World Coordinate Axes.\n        [8]     Area Radii of Gyration about the World Coordinate Axes.\n        [9]     The absolute (+/-) error bound for the Area Radii of Gyration about World Coordinate Axes.\n        [10]    Area Moments of Inertia about the Centroid Coordinate Axes.\n        [11]    The absolute (+/-) error bound for the Area Moments of Inertia about the Centroid Coordinate Axes.\n        [12]    Area Radii of Gyration about the Centroid Coordinate Axes.\n        [13]    The absolute (+/-) error bound for the Area Radii of Gyration about the Centroid Coordinate Axes.\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if obj:\n          massprop= rs.SurfaceAreaMoments(obj)\n          if massprop:\n              print(\"Area Moments of Inertia about the World Coordinate Axes: {}\".format(massprop[6]))\n    See Also:\n      SurfaceArea\n      SurfaceAreaCentroid\n    \"\"\"\n    return __AreaMomentsHelper(surface_id, True)\n\n\ndef SurfaceClosestPoint(surface_id, test_point):\n    \"\"\"Returns U,V parameters of point on a surface that is closest to a test point\n    Parameters:\n      surface_id (guid): identifier of a surface object\n      test_point (point): sampling point\n    Returns:\n      list(number, number): The U,V parameters of the closest point on the surface if successful.\n      None: on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if rs.IsSurface(obj):\n          point = rs.GetPointOnSurface(obj, \"Pick a test point\")\n          if point:\n              param = rs.SurfaceClosestPoint(obj, point)\n              if param:\n                  print(\"Surface U parameter: {}\".format(str(param[0])))\n                  print(\"Surface V parameter: {}\".format(str(param[1])))\n    See Also:\n      BrepClosestPoint\n      EvaluateSurface\n      IsSurface\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    point = rhutil.coerce3dpoint(test_point, True)\n    rc, u, v = surface.ClosestPoint(point)\n    if not rc: return None\n    return u,v\n\n\ndef SurfaceCone(surface_id):\n    \"\"\"Returns the definition of a surface cone\n    Parameters:\n      surface_id (guid): the surface's identifier\n    Returns:\n      tuple(plane, number, number): containing the definition of the cone if successful\n        [0]   the plane of the cone. The apex of the cone is at the\n              plane's origin and the axis of the cone is the plane's z-axis\n        [1]   the height of the cone\n        [2]   the radius of the cone\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      cone = rs.AddCone(rs.WorldXYPlane(), 6, 2, False)\n      if rs.IsCone(cone):\n          cone_def = rs.SurfaceCone(cone)\n          rs.AddCone( cone_def[0], cone_def[1], cone_def[2], False )\n    See Also:\n      \n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    rc, cone = surface.TryGetCone()\n    if not rc: return scriptcontext.errorhandler()\n    return cone.Plane, cone.Height, cone.Radius\n\n\ndef SurfaceCurvature(surface_id, parameter):\n    \"\"\"Returns the curvature of a surface at a U,V parameter. See Rhino help\n    for details of surface curvature\n    Parameters:\n      surface_id (guid): the surface's identifier\n      parameter (number, number): u,v parameter\n    Returns:\n      tuple(point, vector, number, number, number, number, number): of curvature information\n        [0]   point at specified U,V parameter\n        [1]   normal direction\n        [2]   maximum principal curvature\n        [3]   maximum principal curvature direction\n        [4]   minimum principal curvature\n        [5]   minimum principal curvature direction\n        [6]   gaussian curvature\n        [7]   mean curvature\n      None: if not successful, or on error\n    Example:\n      import rhinoscriptsyntax as rs\n      srf = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if rs.IsSurface(srf):\n          point = rs.GetPointOnSurface(srf, \"Pick a test point\")\n          if point:\n              param = rs.SurfaceClosestPoint(srf, point)\n              if param:\n                  data = rs.SurfaceCurvature(srf, param)\n                  if data:\n                      print(\"Surface curvature evaluation at parameter {}:\".format(param))\n                      print(\" 3-D Point:{}\".format(data[0]))\n                      print(\" 3-D Normal:{}\".format(data[1]))\n                      print(\" Maximum principal curvature: {} {}\".format(data[2], data[3]))\n                      print(\" Minimum principal curvature: {} {}\".format(data[4], data[5]))\n                      print(\" Gaussian curvature:{}\".format(data[6]))\n                      print(\" Mean curvature:{}\".format(data[7]))\n    See Also:\n      CurveCurvature\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    if len(parameter)<2: return scriptcontext.errorhandler()\n    c = surface.CurvatureAt(parameter[0], parameter[1])\n    if c is None: return scriptcontext.errorhandler()\n    return c.Point, c.Normal, c.Kappa(0), c.Direction(0), c.Kappa(1), c.Direction(1), c.Gaussian, c.Mean\n\n\ndef SurfaceCylinder(surface_id):\n    \"\"\"Returns the definition of a cylinder surface\n    Parameters:\n      surface_id (guid): the surface's identifier\n    Returns:\n      tuple(plane, number, number): of the cylinder plane, height, radius on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      cylinder = rs.AddCylinder(rs.WorldXYPlane(), 6, 2, False)\n      if rs.IsCylinder(cylinder):\n          plane, height, radius = rs.SurfaceCylinder(cylinder)\n          rs.AddCylinder(plane, height, radius, False)\n    See Also:\n      SurfaceSphere\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, cylinder = surface.TryGetFiniteCylinder(tol)\n    if rc:\n        return cylinder.BasePlane, cylinder.TotalHeight, cylinder.Radius\n\n\ndef SurfaceDegree(surface_id, direction=2):\n    \"\"\"Returns the degree of a surface object in the specified direction\n    Parameters:\n      surface_id (guid): the surface's identifier\n      direction (number, optional): The degree U, V direction\n                0 = U\n                1 = V\n                2 = both\n    Returns:\n      number: Single number if `direction` = 0 or 1\n      tuple(number, number): of two values if `direction` = 2\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if rs.IsSurface(obj):\n          print(\"Degree in U direction: {}\".format(rs.SurfaceDegree(obj, 0)))\n          print(\"Degree in V direction: {}\".format(rs.SurfaceDegree(obj, 1)))\n    See Also:\n      IsSurface\n      SurfaceDomain\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    if direction==0 or direction==1: return surface.Degree(direction)\n    if direction==2: return surface.Degree(0), surface.Degree(1)\n    return scriptcontext.errorhandler()\n\n\ndef SurfaceDomain(surface_id, direction):\n    \"\"\"Returns the domain of a surface object in the specified direction.\n    Parameters:\n      surface_id (guid): the surface's identifier\n      direction (number): domain direction 0 = U, or 1 = V\n    Returns:\n      list(number, number): containing the domain interval in the specified direction\n      None: if not successful, or on error\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if rs.IsSurface(object):\n          domainU = rs.SurfaceDomain(object, 0)\n          domainV = rs.SurfaceDomain(object, 1)\n          print(\"Domain in U direction: {}\".format(domainU))\n          print(\"Domain in V direction: {}\".format(domainV))\n    See Also:\n      IsSurface\n      SurfaceDegree\n    \"\"\"\n    if direction!=0 and direction!=1: return scriptcontext.errorhandler()\n    surface = rhutil.coercesurface(surface_id, True)\n    domain = surface.Domain(direction)\n    return domain.T0, domain.T1\n\n\ndef SurfaceEditPoints(surface_id, return_parameters=False, return_all=True):\n    \"\"\"Returns the edit, or Greville points of a surface object. For each\n    surface control point, there is a corresponding edit point\n    Parameters:\n      surface_id (guid): the surface's identifier\n      return_parameters (bool, optional): If False, edit points are returned as a list of\n        3D points. If True, edit points are returned as a list of U,V surface\n        parameters\n      return_all (bool, options): If True, all surface edit points are returned. If False,\n        the function will return surface edit points based on whether or not the\n        surface is closed or periodic\n    Returns:\n      list(point, ...): if return_parameters is False, a list of 3D points\n      list((number, number), ...): if return_parameters is True, a list of U,V parameters\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\")\n      if rs.IsSurface(obj):\n          points = rs.SurfaceEditPoints(obj)\n          if points: rs.AddPointCloud(points)\n    See Also:\n      IsSurface\n      SurfacePointCount\n      SurfacePoints\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    nurb = surface.ToNurbsSurface()\n    if not nurb: return scriptcontext.errorhandler()\n    ufirst = 0\n    ulast = nurb.Points.CountU\n    vfirst = 0\n    vlast = nurb.Points.CountV\n    if not return_all:\n        if nurb.IsClosed(0): ulast = nurb.Points.CountU-1\n        if nurb.IsPeriodic(0):\n            degree = nurb.Degree(0)\n            ufirst = degree/2\n            ulast = nurb.Points.CountU-degree+ufirst\n        if nurb.IsClosed(1): vlast = nurb.Points.CountV-1\n        if nurb.IsPeriodic(1):\n            degree = nurb.Degree(1)\n            vfirst = degree/2\n            vlast = nurb.Points.CountV-degree+vfirst\n    rc = []\n    for u in range(ufirst, ulast):\n        for v in range(vfirst, vlast):\n            pt = nurb.Points.GetGrevillePoint(u,v)\n            if not return_parameters: pt = nurb.PointAt(pt.X, pt.Y)\n            rc.append(pt)\n    return rc\n\n\ndef SurfaceEvaluate(surface_id, parameter, derivative):\n    \"\"\"A general purpose surface evaluator\n    Parameters:\n      surface_id (guid): the surface's identifier\n      parameter ([number, number]): u,v parameter to evaluate\n      derivative (number): number of derivatives to evaluate\n    Returns:\n      list((point, vector, ...), ...): list length (derivative+1)*(derivative+2)/2 if successful.  The elements are as follows:\n      Element  Description\n      [0]      The 3-D point.\n      [1]      The first derivative.\n      [2]      The first derivative.\n      [3]      The second derivative.\n      [4]      The second derivative.\n      [5]      The second derivative.\n      [6]      etc...\n    None: If not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      def TestSurfaceEvaluate():\n          srf = rs.GetObject(\"Select surface to evaluate\", rs.filter.surface, True)\n          if srf is None: return\n          point = rs.GetPointOnSurface(srf, \"Point to evaluate\")\n          if point is None: return\n          der = rs.GetInteger(\"Number of derivatives to evaluate\", 1, 1)\n          if der is None: return\n          uv = rs.SurfaceClosestPoint(srf, point)\n          res = rs.SurfaceEvaluate(srf, uv, der)\n          if res is None:\n              print(\"Failed to evaluate surface.\")\n              return\n          for i,r in enumerate(res):\n              print(\"{} = {}\".format(i, r))\n      TestSurfaceEvaluate()\n    See Also:\n      EvaluateSurface\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    success, point, der = surface.Evaluate(parameter[0], parameter[1], derivative)\n    if not success: return scriptcontext.errorhandler()\n    rc = [point]\n    if der:\n      for d in der: rc.append(d)\n    return rc\n\n\ndef SurfaceFrame(surface_id, uv_parameter):\n    \"\"\"Returns a plane based on the normal, u, and v directions at a surface\n    U,V parameter\n    Parameters:\n      surface_id (guid): the surface's identifier\n      uv_parameter ([number, number]): u,v parameter to evaluate\n    Returns:\n      plane: plane on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      surface = rs.GetSurfaceObject(\"Select a surface\")\n      if surface:\n          plane = rs.SurfaceFrame(surface[0], surface[4])\n          rs.ViewCPlane(None, plane)\n    See Also:\n      EvaluateSurface\n      SurfaceClosestPoint\n      SurfaceNormal\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    rc, frame = surface.FrameAt(uv_parameter[0], uv_parameter[1])\n    if rc: return frame\n\n\ndef SurfaceIsocurveDensity(surface_id, density=None):\n    \"\"\"Returns or sets the isocurve density of a surface or polysurface object.\n    An isoparametric curve is a curve of constant U or V value on a surface.\n    Rhino uses isocurves and surface edge curves to visualize the shape of a\n    NURBS surface\n    Parameters:\n      surface_id (guid): the surface's identifier\n      density (number, optional): the isocurve wireframe density. The possible values are\n          -1: Hides the surface isocurves\n           0: Display boundary and knot wires\n           1: Display boundary and knot wires and one interior wire if there\n              are no interior knots\n         >=2: Display boundary and knot wires and (N+1) interior wires\n    Returns:\n      number: If density is not specified, then the current isocurve density if successful\n      number: If density is specified, the the previous isocurve density if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\", rs.filter.surface | rs.filter.polysurface)\n      if obj: rs.SurfaceIsocurveDensity( obj, 8 )\n    See Also:\n      IsPolysurface\n      IsSurface\n    \"\"\"\n    rhino_object = rhutil.coercerhinoobject(surface_id, True, True)\n    if not isinstance(rhino_object, Rhino.DocObjects.BrepObject):\n        return scriptcontext.errorhandler()\n    rc = rhino_object.Attributes.WireDensity\n    if density is not None:\n        if density<0: density = -1\n        rhino_object.Attributes.WireDensity = density\n        rhino_object.CommitChanges()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef SurfaceKnotCount(surface_id):\n    \"\"\"Returns the control point count of a surface\n      surface_id = the surface's identifier\n    Parameters:\n      surface_id (guid): the surface object's identifier\n    Returns:\n      list(number, number): a list containing (U count, V count) on success\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\")\n      if rs.IsSurface(obj):\n          count = rs.SurfaceKnotCount(obj)\n          print(\"Knot count in U direction: {}\".format(count[0]))\n          print(\"Knot count in V direction: {}\".format(count[1]))\n    See Also:\n      IsSurface\n      SurfaceKnots\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    ns = surface.ToNurbsSurface()\n    return ns.KnotsU.Count, ns.KnotsV.Count\n\n\ndef SurfaceKnots(surface_id):\n    \"\"\"Returns the knots, or knot vector, of a surface object.\n    Parameters:\n      surface_id (guid): the surface's identifier\n    Returns:\n     list(number, number): knot values of the surface if successful. The list will\n      contain the following information:\n      Element   Description\n        [0]     Knot vector in U direction\n        [1]     Knot vector in V direction\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\")\n      if rs.IsSurface(obj):\n          knots = rs.SurfaceKnots(obj)\n          if knots:\n              vector = knots[0]\n              print(\"Knot vector in U direction\")\n              for item in vector: print(\"Surface knot value: {}\".format(item))\n              vector = knots[1]\n              print(\"Knot vector in V direction\")\n              for item in vector: print(\"Surface knot value: {}\".format(item))\n    See Also:\n      IsSurface\n      SurfaceKnotCount\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    nurb_surf = surface.ToNurbsSurface()\n    if nurb_surf is None: return scriptcontext.errorhandler()\n    s_knots = [knot for knot in nurb_surf.KnotsU]\n    t_knots = [knot for knot in nurb_surf.KnotsV]\n    if not s_knots or not t_knots: return scriptcontext.errorhandler()\n    return s_knots, t_knots\n\n\ndef SurfaceNormal(surface_id, uv_parameter):\n    \"\"\"Returns 3D vector that is the normal to a surface at a parameter\n    Parameters:\n      surface_id (guid): the surface's identifier\n      uv_parameter  ([number, number]): the uv parameter to evaluate\n    Returns:\n      vector: Normal vector on success\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\", rs.filter.surface)\n      if obj:\n          point = rs.GetPointOnSurface(obj)\n          if point:\n              param = rs.SurfaceClosestPoint(obj, point)\n              normal = rs.SurfaceNormal(obj, param)\n              rs.AddPoints( [point, point + normal] )\n    See Also:\n      SurfaceClosestPoint\n      SurfaceDomain\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    return surface.NormalAt(uv_parameter[0], uv_parameter[1])\n\n\ndef SurfaceNormalizedParameter(surface_id, parameter):\n    \"\"\"Converts surface parameter to a normalized surface parameter; one that\n    ranges between 0.0 and 1.0 in both the U and V directions\n    Parameters:\n      surface_id (guid) the surface's identifier\n      parameter ([number, number]): the surface parameter to convert\n    Returns:\n      list(number, number): normalized surface parameter if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select surface\")\n      if rs.IsSurface(obj):\n          domain_u = rs.SurfaceDomain(obj, 0)\n          domain_v = rs.SurfaceDomain(obj, 1)\n          parameter = (domain_u[1] + domain_u[0]) / 2.0, (domain_v[1] + domain_v[0]) / 2.0\n          print(\"Surface parameter: {}\".format(parameter))\n          normalized = rs.SurfaceNormalizedParameter(obj, parameter)\n          print(\"Normalized parameter: {}\".format(normalized))\n    See Also:\n      SurfaceDomain\n      SurfaceParameter\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    u_domain = surface.Domain(0)\n    v_domain = surface.Domain(1)\n    if parameter[0]<u_domain.Min or parameter[0]>u_domain.Max:\n        return scriptcontext.errorhandler()\n    if parameter[1]<v_domain.Min or parameter[1]>v_domain.Max:\n        return scriptcontext.errorhandler()\n    u = u_domain.NormalizedParameterAt(parameter[0])\n    v = v_domain.NormalizedParameterAt(parameter[1])\n    return u,v\n\n\ndef SurfaceParameter(surface_id, parameter):\n    \"\"\"Converts normalized surface parameter to a surface parameter; or\n    within the surface's domain\n    Parameters:\n      surface_id (guid): the surface's identifier\n      parameter ([number, number]): the normalized parameter to convert\n    Returns:\n      tuple(number, number): surface parameter on success\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select surface\")\n      if obj:\n          normalized = (0.5, 0.5)\n          print(\"Normalized parameter: {}\".format(normalized))\n          parameter = rs.SurfaceParameter(obj, normalized)\n          print(\"Surface parameter: {}\".format(parameter))\n    See Also:\n      SurfaceDomain\n      SurfaceNormalizedParameter\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    x = surface.Domain(0).ParameterAt(parameter[0])\n    y = surface.Domain(1).ParameterAt(parameter[1])\n    return x, y\n\n\ndef SurfacePointCount(surface_id):\n    \"\"\"Returns the control point count of a surface\n      surface_id = the surface's identifier\n    Parameters:\n      surface_id (guid): the surface object's identifier\n    Returns:\n      list(number, number): THe number of control points in UV direction. (U count, V count)\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\")\n      if rs.IsSurface(obj):\n          count = rs.SurfacePointCount(obj)\n          print(\"Point count in U direction: {}\".format(count[0]))\n          print(\"Point count in V direction: {}\".format(count[1]))\n    See Also:\n      IsSurface\n      SurfacePoints\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    ns = surface.ToNurbsSurface()\n    return ns.Points.CountU, ns.Points.CountV\n\n\ndef SurfacePoints(surface_id, return_all=True):\n    \"\"\"Returns the control points, or control vertices, of a surface object\n    Parameters:\n      surface_id (guid): the surface's identifier\n      return_all (bool, optional): If True all surface edit points are returned. If False,\n        the function will return surface edit points based on whether or not\n        the surface is closed or periodic\n    Returns:\n      list(point, ...): the control points if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      def PrintControlPoints():\n          surface = rs.GetObject(\"Select surface\", rs.filter.surface)\n          points = rs.SurfacePoints(surface)\n          if points is None: return\n          count = rs.SurfacePointCount(surface)\n          i = 0\n          for u in range(count[0]):\n              for v in range(count[1]):\n                  print(\"CV[{}\".format(u, \",\", v, \"] = \", points[i]))\n                  i += 1\n      PrintControlPoints()\n    See Also:\n      IsSurface\n      SurfacePointCount\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    ns = surface.ToNurbsSurface()\n    if ns is None: return scriptcontext.errorhandler()\n    rc = []\n    for u in range(ns.Points.CountU):\n        for v in range(ns.Points.CountV):\n            pt = ns.Points.GetControlPoint(u,v)\n            rc.append(pt.Location)\n    return rc\n\n\ndef SurfaceTorus(surface_id):\n    \"\"\"Returns the definition of a surface torus\n    Parameters:\n      surface_id (guid): the surface's identifier\n    Returns:\n      tuple(plane, number, number): containing the definition of the torus if successful\n        [0]   the base plane of the torus\n        [1]   the major radius of the torus\n        [2]   the minor radius of the torus\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      torus = rs.AddTorus(rs.WorldXYPlane(), 6, 2)\n      if rs.IsTorus(torus):\n          torus_def = rs.SurfaceTorus(torus)\n          rs.AddTorus( torus_def[0], torus_def[1], torus_def[2] )\n    See Also:\n      \n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    rc, torus = surface.TryGetTorus()\n    if rc: return torus.Plane, torus.MajorRadius, torus.MinorRadius\n\n\ndef SurfaceVolume(object_id):\n    \"\"\"Calculates volume of a closed surface or polysurface\n    Parameters:\n      object_id (guid): the surface's identifier\n    Returns:\n      list(number, tuple(X, Y, Z): volume data returned (Volume, Error bound) on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\", rs.filter.polysurface)\n      if rs.IsPolysurfaceClosed(obj):\n          massprop = rs.SurfaceVolume(obj)\n          if massprop:\n              print(\"The polysurface volume is: {}\".format(massprop[0]))\n    See Also:\n      SurfaceVolume\n      SurfaceVolumeCentroid\n      SurfaceVolumeMoments\n    \"\"\"\n    vmp = __GetMassProperties(object_id, False)\n    if vmp: return vmp.Volume, vmp.VolumeError\n\n\ndef SurfaceVolumeCentroid(object_id):\n    \"\"\"Calculates volume centroid of a closed surface or polysurface\n    Parameters:\n      object_id (guid): the surface's identifier\n    Returns:\n      list(point, tuple(X, Y, Z): volume data returned (Volume Centriod, Error bound) on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\", rs.filter.polysurface)\n      if rs.IsPolysurfaceClosed(obj):\n          massprop= rs.SurfaceVolumeCentroid(obj)\n          if massprop: rs.AddPoint( massprop[0] )\n    See Also:\n      SurfaceVolume\n      SurfaceVolumeMoments\n    \"\"\"\n    vmp = __GetMassProperties(object_id, False)\n    if vmp: return vmp.Centroid, vmp.CentroidError\n\n\ndef SurfaceVolumeMoments(surface_id):\n    \"\"\"Calculates volume moments of inertia of a surface or polysurface object.\n    For more information, see Rhino help for \"Mass Properties calculation details\"\n    Parameters:\n      surface_id (guid): the surface's identifier\n    Returns:\n      list(tuple(number, number,number), ...): of moments and error bounds in tuple(X, Y, Z) - see help topic\n        Index   Description\n        [0]     First Moments.\n        [1]     The absolute (+/-) error bound for the First Moments.\n        [2]     Second Moments.\n        [3]     The absolute (+/-) error bound for the Second Moments.\n        [4]     Product Moments.\n        [5]     The absolute (+/-) error bound for the Product Moments.\n        [6]     Area Moments of Inertia about the World Coordinate Axes.\n        [7]     The absolute (+/-) error bound for the Area Moments of Inertia about World Coordinate Axes.\n        [8]     Area Radii of Gyration about the World Coordinate Axes.\n        [9]     The absolute (+/-) error bound for the Area Radii of Gyration about World Coordinate Axes.\n        [10]    Area Moments of Inertia about the Centroid Coordinate Axes.\n        [11]    The absolute (+/-) error bound for the Area Moments of Inertia about the Centroid Coordinate Axes.\n        [12]    Area Radii of Gyration about the Centroid Coordinate Axes.\n        [13]    The absolute (+/-) error bound for the Area Radii of Gyration about the Centroid Coordinate Axes.\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a surface\", rs.filter.polysurface)\n      if rs.IsPolysurfaceClosed(obj):\n          massprop = rs.SurfaceVolumeMoments(obj)\n          if massprop:\n              print(\"Volume Moments of Inertia about the World Coordinate Axes: {}\".format(massprop[6]))\n    See Also:\n      SurfaceVolume\n      SurfaceVolumeCentroid\n    \"\"\"\n    return __AreaMomentsHelper(surface_id, False)\n\n\ndef SurfaceWeights(object_id):\n    \"\"\"Returns list of weight values assigned to the control points of a surface.\n    The number of weights returned will be equal to the number of control points\n    in the U and V directions.\n    Parameters:\n      object_id (guid): the surface's identifier\n    Returns:\n      list(number, ...): point weights.\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      surf = rs.GetObject(\"Select a surface\")\n      if rs.IsSurface(surf):\n          weights = rs.SurfaceWeights(surf)\n          if weights:\n              for w in weights:\n                  print(\"Surface control point weight value:{}\".format(w))\n    See Also:\n      IsSurface\n      SurfacePointCount\n      SurfacePoints\n    \"\"\"\n    surface = rhutil.coercesurface(object_id, True)\n    ns = surface.ToNurbsSurface()\n    if ns is None: return scriptcontext.errorhandler()\n    rc = []\n    for u in range(ns.Points.CountU):\n        for v in range(ns.Points.CountV):\n            pt = ns.Points.GetControlPoint(u,v)\n            rc.append(pt.Weight)\n    return rc\n\n\ndef TrimBrep(object_id, cutter, tolerance=None):\n    \"\"\"Trims a surface using an oriented cutter\n    Parameters:\n      object_id (guid): surface or polysurface identifier\n      cutter (guid|plane): surface, polysurface, or plane performing the trim\n      tolerance (number, optional): trimming tolerance. If omitted, the document's absolute\n        tolerance is used\n    Returns:\n      list(guid, ...): identifiers of retained components on success\n    Example:\n      import rhinoscriptsyntax as rs\n      filter = rs.filter.surface + rs.filter.polysurface\n      obj = rs.GetObject(\"Select surface or polysurface to trim\", filter)\n      if obj:\n          cutter = rs.GetObject(\"Select cutting surface or polysurface\", filter)\n          if cutter:\n              rs.TrimBrep(obj,cutter)\n    See Also:\n      TrimSurface\n    \"\"\"\n    brep = rhutil.coercebrep(object_id, True)\n    brep_cutter = rhutil.coercebrep(cutter, False)\n    if brep_cutter: cutter = brep_cutter\n    else: cutter = rhutil.coerceplane(cutter, True)\n    if tolerance is None: tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    breps = brep.Trim(cutter, tolerance)\n    rhid = rhutil.coerceguid(object_id, False)\n\n    attrs = None\n    if len(breps) > 1:\n      rho = rhutil.coercerhinoobject(object_id, False)\n      if rho: attrs = rho.Attributes\n\n    if rhid:\n        rc = []\n        for i in range(len(breps)):\n            if i==0:\n                scriptcontext.doc.Objects.Replace(rhid, breps[i])\n                rc.append(rhid)\n            else:\n                rc.append(scriptcontext.doc.Objects.AddBrep(breps[i], attrs))\n    else:\n        rc = [scriptcontext.doc.Objects.AddBrep(brep) for brep in breps]\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef TrimSurface( surface_id, direction, interval, delete_input=False):\n    \"\"\"Remove portions of the surface outside of the specified interval\n    Parameters:\n      surface_id (guid): surface identifier\n      direction (number, optional): 0(U), 1(V), or 2(U and V)\n      interval (interval): sub section of the surface to keep.\n        If both U and V then a list or tuple of 2 intervals\n      delete_input (bool, optional): should the input surface be deleted\n    Returns:\n      guid: new surface identifier on success\n    Example:\n      import rhinoscriptsyntax as rs\n      surface = rs.GetObject(\"Select surface to split\", rs.filter.surface)\n      if surface:\n          domain_u = rs.SurfaceDomain(surface, 0)\n          domain_u[0] = (domain_u[1] - domain_u[0]) * 0.25\n          rs.TrimSurface( surface, 0, domain_u, True )\n    See Also:\n      \n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    u = surface.Domain(0)\n    v = surface.Domain(1)\n    if direction==0:\n        u[0] = interval[0]\n        u[1] = interval[1]\n    elif direction==1:\n        v[0] = interval[0]\n        v[1] = interval[1]\n    else:\n        u[0] = interval[0][0]\n        u[1] = interval[0][1]\n        v[0] = interval[1][0]\n        v[1] = interval[1][1]\n    new_surface = surface.Trim(u,v)\n    if new_surface:\n        rc = scriptcontext.doc.Objects.AddSurface(new_surface)\n        if delete_input: scriptcontext.doc.Objects.Delete(rhutil.coerceguid(surface_id), True)\n        scriptcontext.doc.Views.Redraw()\n        return rc\n\n\ndef UnrollSurface(surface_id, explode=False, following_geometry=None, absolute_tolerance=None, relative_tolerance=None):\n    \"\"\"Flattens a developable surface or polysurface\n    Parameters:\n      surface_id (guid): the surface's identifier\n      explode (bool, optional): If True, the resulting surfaces ar not joined\n      following_geometry ({guid, ...]): List of curves, dots, and points which\n        should be unrolled with the surface\n    Returns:\n      list(guid, ...): of unrolled surface ids\n      tuple((guid, ...),(guid, ...)): if following_geometry is not None, a tuple\n        [1] is the list of unrolled surface ids\n        [2] is the list of unrolled following geometry\n    Example:\n      import rhinoscriptsyntax as rs\n      surface = rs.GetObject(\"Select surface or polysurface to unroll\", rs.filter.surface + rs.filter.polysurface)\n      if surface: rs.UnrollSurface(surface)\n    See Also:\n      \n    \"\"\"\n    brep = rhutil.coercebrep(surface_id, True)\n    unroll = Rhino.Geometry.Unroller(brep)\n    unroll.ExplodeOutput = explode\n    if relative_tolerance is None: relative_tolerance = scriptcontext.doc.ModelRelativeTolerance\n    if absolute_tolerance is None: absolute_tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    unroll.AbsoluteTolerance = absolute_tolerance\n    unroll.RelativeTolerance = relative_tolerance\n    if following_geometry:\n        for id in following_geometry:\n            geom = rhutil.coercegeometry(id)\n            unroll.AddFollowingGeometry(geom)\n    breps, curves, points, dots = unroll.PerformUnroll()\n    if not breps: return None\n    rc = [scriptcontext.doc.Objects.AddBrep(brep) for brep in breps]\n    new_following = []\n    for curve in curves:\n        id = scriptcontext.doc.Objects.AddCurve(curve)\n        new_following.append(id)\n    for point in points:\n        id = scriptcontext.doc.Objects.AddPoint(point)\n        new_following.append(id)\n    for dot in dots:\n        id = scriptcontext.doc.Objects.AddTextDot(dot)\n        new_following.append(id)\n    scriptcontext.doc.Views.Redraw()\n    if following_geometry: return rc, new_following\n    return rc\n\n\ndef ChangeSurfaceDegree(object_id, degree):\n  \"\"\"Changes the degree of a surface object.  For more information see the Rhino help file for the ChangeDegree command.\n  Parameters:\n    object_id (guid): the object's identifier.\n    degree ([number, number]) two integers, specifying the degrees for the U  V directions\n  Returns:\n    bool: True of False indicating success or failure.\n    None: on failure.\n  Example:\n    \n  See Also:\n    IsSurface\n  \"\"\"\n  object = rhutil.coercerhinoobject(object_id)\n  if not object: return None\n  obj_ref = Rhino.DocObjects.ObjRef(object)\n  \n  surface = obj_ref.Surface()\n  if not surface: return None\n\n  if not isinstance(surface, Rhino.Geometry.NurbsSurface):\n    surface = surface.ToNurbsSurface() # could be a Surface or BrepFace\n\n  max_nurbs_degree = 11\n  if degree[0] < 1 or degree[0] > max_nurbs_degree or \\\n      degree[1] < 1 or degree[1] > max_nurbs_degree or \\\n      (surface.Degree(0) == degree[0] and surface.Degree(1) == degree[1]):\n    return None\n\n  r = False\n  if surface.IncreaseDegreeU(degree[0]):\n    if surface.IncreaseDegreeV(degree[1]):\n      r = scriptcontext.doc.Objects.Replace(object_id, surface)\n  return r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}