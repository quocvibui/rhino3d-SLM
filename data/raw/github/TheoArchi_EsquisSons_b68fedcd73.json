{
  "source_url": "https://github.com/TheoArchi/EsquisSons/blob/00d1b02f7ce3e190b5c4c3429d3e84756c29bfdb/Components_Uncompiled_for%20ghpython/EsquisSons_MainEngine.py",
  "repo": "TheoArchi/EsquisSons",
  "repo_stars": 3,
  "repo_description": "Esquissons is a grasshopper plugin which help you to design with sound ;)",
  "license": "NOASSERTION",
  "filepath": "Components_Uncompiled_for ghpython/EsquisSons_MainEngine.py",
  "instruction": "EsquisSons Main Engine will calculate the auralisation.\nUse Listener, Sources and Geometry objects to connect them here :)\n-\nAAU / Theo Marchal / BETA VERSION / MARS2020",
  "code": "\"\"\"EsquisSons Main Engine will calculate the auralisation.\nUse Listener, Sources and Geometry objects to connect them here :)\n-\nAAU / Theo Marchal / BETA VERSION / MARS2020\"\"\"\n\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\nclass MyComponent(component):\n    \n    def RunScript(self, Listener, Sources, Geometry, Reverb_on, Lock, _Indoor):\n        \n        __author__ = \"theomarchal\"\n        self.Params.Input[0].Description = \"Listener Object (Use Esquissons_Listener component)\"\n        self.Params.Input[1].Description = \"Sources Objects (Use Esquissons_Source component)\"\n        self.Params.Input[2].Description = \"Built environment (Use Esquissons_Built Environment component)\"\n        self.Params.Input[3].Description = \"Set Reverb_On to True to activate Reverberation (Boolean input)(default is off)\"\n        self.Params.Input[4].Description = \"To Lock sources (and sound), set to True, then turn it back to False (Boolean input)(default is unlock)\"\n        self.Params.Input[4].Description = \"*optionnal* Set to 'True' if your scene is indoors, otherwise leave the field empty (Boolean input)(default is outdoor)\" \n        self.Params.Output[0].Description = \"Visualize output (plug it in visualize components to see rays)\"\n        self.Params.Output[1].Description = \"Reverberation time (in second / for each source)\"\n        self.Params.Output[2].Description = \"Reverberation Info (Time and mix / for each source)\"\n        \n        self.Name = \"EsquisSons Main engine\"\n        self.NickName = \"EsquisSons\" \n        self.Message = \"EsquisSons V3\"\n        self.Category = \"EsquisSons\"\n        self.SubCategory = \"0/ EsquisSons\"\n        \n        import rhinoscriptsyntax as rs\n        import math\n        import OSC\n        import Grasshopper.Kernel as gh\n        \n        rem = gh.GH_RuntimeMessageLevel.Remark\n        ero = gh.GH_RuntimeMessageLevel.Error\n        war = gh.GH_RuntimeMessageLevel.Warning\n        \n        try:\n            Lp = ((Listener[0])[0])\n            Lh = ((Listener[0])[3])\n        except:\n            self.AddRuntimeMessage(ero, 'You must connect a Listener component (EsquisSons) !')\n            raise Exception('nolistener')\n        \n        if len(Sources) <= 0:\n            self.AddRuntimeMessage(war, 'You must connect at least one Source component (EsquisSons)')\n            \n        if len(Geometry) <= 0:\n            self.AddRuntimeMessage(war, 'You must connect at least one Geometry component (EsquisSons)')\n        \n        So_dic = dict()\n        Si =[]\n        SDi =[]\n        SPa = []\n        SPan = []\n        Spl = []\n        Sint = []\n        Opa = 1\n        Srev1 = []\n        Srev2 = []\n        Str = []\n        Vi = []\n        MaVol = []\n        RTsource = []\n        Revinfo = []\n        Indoor = _Indoor\n        Vi.append(Geometry)\n        Vi.append(Listener)\n        Vi.append(Sources)\n        if Indoor is True :\n            Factor = 1.0\n        else :\n            Factor = 1.5\n        def pan(Li,So):\n            Tl = ((Li[0])[1])\n            Tr = ((Li[0])[2])\n            pano =(((rs.Distance(Tl,So))-(rs.Distance(Tr,So))+Lh)*(127/(2*Lh)))\n            return pano;\n        def DecDist(Ht,Dis):\n            Ds = (Dis*1.8)/(Ht)\n            dec = (10*math.log10(Ds))\n            filter = (1/Ds)*15000\n            return [-(dec),filter];\n        def inter_S_B(s,div,Lis,br): \n            udiv = div\n            vdiv = div\n            srf = rs.AddSphere((s[1]),((s[2])*2.5))\n            u = rs.SurfaceDomain(srf,0)\n            v = rs.SurfaceDomain(srf,1)\n            pts = []\n            for i in range(0, udiv+1, 1):\n                for j in range(0, vdiv+1, 1):\n                    pt = (i/udiv,j/vdiv,0)\n                    srfP = rs.SurfaceParameter(srf,pt)\n                    newpt = rs.EvaluateSurface(srf,srfP[0],srfP[1])\n                    pts.append(rs.AddPoint(newpt))\n            lig = []\n            lid = []\n            for p in pts :\n                lig.append(rs.AddLine((Lis[0])[1],p))\n                lid.append(rs.AddLine((Lis[0])[2],p))\n            ig = []\n            id = []\n            for i in lig :\n                for u in br :\n                    if type(rs.CurveBrepIntersect(i,(u[0]))) == tuple :\n                        ig.append((rs.CurveBrepIntersect(i,(u[0])))+(u[1],))\n                    else :\n                        ig.append((rs.CurveBrepIntersect(i,(u[0]))))\n            for i in lid :\n                for u in br:\n                    if type(rs.CurveBrepIntersect(i,(u[0]))) == tuple :\n                        id.append((rs.CurveBrepIntersect(i,(u[0])))+(u[1],))\n                    else :\n                        id.append((rs.CurveBrepIntersect(i,(u[0]))))\n            if len(id) == 0:\n                self.AddRuntimeMessage(war, \"it doesn't seem like there's any geometries connected\")\n                raise Exception('noGeo')\n            intg=0\n            for i in ig:\n                if type(i) is tuple :\n                    intg += (1*(i[-1]))\n            intd=0\n            for i in id:\n                if type(i) is tuple :\n                    intd += (1*(i[-1]))\n            difg = len(ig)-intg\n            if difg <= 0 :\n                difg = 0.1\n            difd = len(id)-intd\n            if difd <=0 :\n                difd =0.1\n            return [(((math.log10(difg*100/len(ig)))*35.3)-70.6),(((math.log10(difd*100/len(id)))*35.3)-70.6)];\n        \n        def volm(src) :\n            if src[3] == 0 or src[3] >=70 :\n                srcvlm = 0\n            else :\n                srcvlm = (src[3]-70)\n            return srcvlm\n        \n        def rev(Ge,Lis,Src,div): \n            udiv = div\n            vdiv = div\n            Pt_L = Lis [0][0]\n            srf = []\n            FirstRay = []\n            SecondRay = []\n            First_RefPoint = []\n            drawray =[]\n            Reverb = []\n            for i in Ge :\n                srf.append(i[0])\n            sph =(rs.AddSphere(Src[1],Src[2]))\n            Src_pt =(Src[1])\n            u = rs.SurfaceDomain(sph,0)\n            v = rs.SurfaceDomain(sph,1)\n            pts = []\n            for i in range(0, udiv+1, 1):\n                for j in range(0, vdiv+1, 1):\n                    pt = (i/udiv,j/vdiv,0)\n                    sphP = rs.SurfaceParameter(sph,pt)\n                    newpt = rs.EvaluateSurface(sph,sphP[0],sphP[1])\n                    pts.append(rs.AddPoint(newpt))\n            Dir = []\n            for p in pts:\n                Dir.append(rs.VectorCreate(p,Src_pt))\n            Reflexion = []\n            for d in Dir :\n                Reflexion.append(rs.ShootRay(srf,Src_pt,d,reflections=4))\n            Project = []\n            for v in Reflexion :\n                Cl_Pt = []\n                Ray_v = []\n                try :\n                    Project.append(v[1])\n                    Ray_v.append(rs.AddPolyline(v))\n                except :\n                    pass\n                for u in Ray_v :\n                    pt_on = rs.CurveClosestPoint (u,Pt_L)\n                    cl = rs.EvaluateCurve(u,pt_on)\n                    Dicl = (rs.Distance(Pt_L,cl))\n                    if Dicl <= ((Lis [0])[3]):\n                        try :\n                            First_RefPoint = rs.CurveClosestPoint (u,v[1])\n                            Second_RefPoint = rs.CurveClosestPoint (u,v[2])\n                            endc=((rs.CurveClosestPoint(u,(rs.CurveEndPoint(u)))))\n                            if pt_on > Second_RefPoint :\n                                SecondRay.append(pt_on/endc*(rs.CurveLength(u)))\n                                drawray.append(u)\n                            elif pt_on > First_RefPoint :\n                                FirstRay.append(pt_on/endc*(rs.CurveLength(u)))\n                        except :\n                            pass\n            box = rs.AddBox(rs.BoundingBox(Project))\n            boxarea = round((rs.SurfaceArea(box)[0]),2)\n            Cube = []\n            Cube.append(box)\n            surfacetorev = []\n            for s in srf :\n                ptons = []\n                for p in Project :\n                    if rs.Distance((rs.BrepClosestPoint(s,p)[0]),p) < 0.1 :\n                        ptons.append(p)\n                if len(ptons) > 0 :\n                    surfacetorev.append(s)\n            surfaceab = []\n            for x in Ge :\n                if x[0] in surfacetorev :\n                    surfaceab.append(x[2])\n            SrfandAb = [(surfacetorev[i], surfaceab[i]) for i in range(0, len(surfacetorev))] \n            bbox = box\n            box = round(((rs.SurfaceVolume(box))[0]),1)\n            srfvol = []\n            srfvolex = []\n            absvol = []\n            srfarea =[]\n            srfrev = []\n            areaabs = []\n            surfacecenter = []\n            absidx = []\n            absvoltot = []\n            for i in SrfandAb :\n                if rs.SurfaceVolume(i[0]) > 0 :\n                    srfvol.append(i[0])\n                    absvol.append(i[1])\n                else :\n                    srfarea.append((rs.SurfaceArea(i[0]))[0])\n                    absvoltot.append(i[1])\n            srfvolex = rs.ExplodePolysurfaces(srfvol)\n            for i in srfvolex :\n                ptonsrf = []\n                usefulsrf = []\n                for p in Project :\n                    if rs.Distance((rs.BrepClosestPoint(i,p)[0]),p) < 0.01 :\n                        ptonsrf.append(p)\n                        usefulsrf.append(i)\n                if len(ptonsrf) > 0 :\n                    srfarea.append(rs.SurfaceArea(i)[0])\n                    srfrev.append(i)\n            for i in srfrev : \n                surfacecenter.append(rs.SurfaceAreaCentroid(i)[0])\n            for b in srfvol :\n                for i in surfacecenter :\n                    if rs.Distance((rs.BrepClosestPoint(b,i)[0]),i) < 0.01 :\n                        absidx.append(srfvol.index(b))\n            for i in absidx :\n                absvoltot.append(absvol[i]) \n            try:\n                areaabs = [srfarea[i]*(absvoltot[i]) for i in range(0, len(absvoltot))]\n            except:\n                raise Exception('One source must be too deep inside a geometry, try to get it out or to move it a little bit !')\n            Builtareaabs = 0\n            for i in areaabs :\n                Builtareaabs += i\n            BuiltArea = 0\n            for i in srfarea :\n                BuiltArea += i\n            BuiltArea = round(BuiltArea,2)\n            EmptyArea = 2*(round(boxarea - BuiltArea,2))\n            if EmptyArea < 0 :\n                EmptyArea = 0\n            TR = 1000*(0.16*box)/(Builtareaabs + (EmptyArea*1))\n            FRValue = 0\n            for f in FirstRay :\n                FV = ((((Lis [0])[3])*15)/f)\n                FRValue += FV\n            if FRValue >=125 :\n                FRValue = 125\n            SRValue = 0\n            for s in SecondRay :\n                SV = ((((Lis [0])[3])*20)/s)\n                SRValue += SV\n            if SRValue > 125 :\n                SRValue = 125\n            Reverb.append(round(FRValue))\n            Reverb.append(round(SRValue))\n            Reverb.append(round(TR,2))\n            return Reverb\n\n        def main():\n            atr =[]\n            ManV = []\n            totrev = []\n            rdm = []\n            for iS in range(len(Sources)):\n                Closest_pt_on_sphere = (rs.BrepClosestPoint ((rs.AddSphere((Sources[iS])[1],(Sources[iS])[2])), Lp))\n                Si.append(\"S_{}\".format(iS+1))\n                Distance = (rs.Distance(Lp,(Closest_pt_on_sphere[0])))\n                SDi.append(DecDist(Lh,Distance))\n                spthi = (Sources[iS][0]).replace('\\\\','/')\n                PathList = (spthi).split()\n                PercentS = (\"\\ \").join(PathList)\n                SPa.append(PercentS)\n                if Lock == True :\n                    SPa[iS] = '/i/NoSource_LOCKED'  \n                    self.AddRuntimeMessage(rem,'Your Sketch is locked, no sound until you unlock ;)')\n                    self.Message = \"EsquisSons is locked\"\n                SPan.append(pan(Listener,(Sources[iS])[1]))\n                Sint.append(inter_S_B((Sources[iS]),3,Listener,Geometry))\n                if Reverb_on == True :\n                    Srev = (rev(Geometry,Listener,(Sources[iS]),50))\n                    Srev1.append((Srev)[0]*Factor)\n                    Srev2.append((Srev)[1]*Factor)\n                    Str.append((Srev)[2])\n                    atr.append((Srev)[2])\n                    totrev.append(Srev[0]+Srev[1])\n                ManV.append(volm(Sources[iS]))\n                rdm.append(Sources[iS][4])   \n            if Reverb_on is True :\n                for i in range(0,len(atr)) :\n                    RTsource.append(round(atr[i]/1000,1))\n                    Revinfo.append(str(round(atr[i]/1000,1))+'sec // mix : '+str(totrev[i]*Factor)+'%')\n            else :\n                RTsource.append('No RT: Reverb is disabled')\n                Revinfo.append('No infos: Reverb is disabled')\n            io = int((len(Sources)-1))\n            i_msg = []\n            iosc = []\n            for i in range(10):\n                try:\n                    pathold = oldpath[i]\n                except IndexError :\n                    oldpath.insert(i,[\"empty\"])\n                except NameError :\n                    oldpath = []\n                    oldpath.append([\"empty\"])\n                iport = (57100+i)\n                iosc.append(OSC.OSCClient())\n                iosc[i].connect((\"127.0.0.1\",iport))\n                i_msg.append(OSC.OSCMessage())\n                if i <= io :\n                    i_msg[i].append(SDi[i][0])\n                    i_msg[i].append(SDi[i][1])\n                    i_msg[i].append(SPa[i])\n                    i_msg[i].append(SPan[i])\n                    if Lock is True :\n                        i_msg[i].append(0)\n                    else :\n                        if ((i_msg[i])[2]) != (oldpath[i]) :\n                            i_msg[i].append(1)\n                        else :\n                            i_msg[i].append(2)\n                        i_msg[i].append(Sint[i])\n                    \n                    try :\n                        i_msg[i].append(Srev1[i])\n                        i_msg[i].append(Srev2[i])\n                        i_msg[i].append(Str[i])\n                    except :\n                        i_msg[i].append(0)\n                        i_msg[i].append(0)\n                        i_msg[i].append(0)\n                    i_msg[i].append(ManV[i])\n                    i_msg[i].append(rdm[i])\n                    iosc[i].send(i_msg[i])\n                    oldpath[i] = SPa[i]\n        \n                else :\n                    i_msg[i].append(-127)\n                    i_msg[i].append(0)\n                    i_msg[i].append('/i/NoSource')\n                    i_msg[i].append(0)\n                    i_msg[i].append(0)\n                    i_msg[i].append(0)\n                    i_msg[i].append(0)\n                    i_msg[i].append(0)\n                    i_msg[i].append(0)\n                    i_msg[i].append(0)\n                    i_msg[i].append(0)\n        \n                try :\n                    iosc[i].send(i_msg[i])\n                except :\n                    self.AddRuntimeMessage(ero, 'Connexion Failed, please ensure APP is open (use launcher) then reset the engine (with lock/unlock)')\n                    self.Message = 'Connexion Failure'\n                print \"message, source {} : {}\".format(i,i_msg[i])\n        if __name__ == \"__main__\":\n            main()\n            RT_bySource = RTsource\n            Revinfo_bySource = Revinfo\n        return (Vi, RT_bySource, Revinfo_bySource)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}