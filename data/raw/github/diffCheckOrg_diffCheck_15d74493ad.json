{
  "source_url": "https://github.com/diffCheckOrg/diffCheck/blob/8f668b1f273e8d81a282c6115ba3eae07eef9235/src/gh/components/DF_joint_segmentator/code.py",
  "repo": "diffCheckOrg/diffCheck",
  "repo_stars": 15,
  "repo_description": "diffCheck is a CAD-integrated tool for evaluating digital timber fabrication processes.",
  "license": "GPL-3.0",
  "filepath": "src/gh/components/DF_joint_segmentator/code.py",
  "instruction": "Extracts the joints from a point cloud.",
  "code": "\"\"\"Extracts the joints from a point cloud.\"\"\"\n#! python3\n\nimport System\nimport math\n\nimport Rhino\nimport ghpythonlib.treehelpers\n\nfrom diffCheck import diffcheck_bindings\nfrom diffCheck import df_cvt_bindings as df_cvt\n\nfrom ghpythonlib.componentbase import executingcomponent as component\n\n\nABSTOL = Rhino.RhinoDoc.ActiveDoc.ModelAbsoluteTolerance\n\nclass DFJointSegmentator(component):\n    def __init__(self):\n        super(DFJointSegmentator, self).__init__()\n    def RunScript(self,\n            i_clusters: System.Collections.Generic.List[Rhino.Geometry.PointCloud],\n            i_assembly,\n            i_angle_threshold: float,\n            i_distance_threshold: float,\n            i_correspondence_distance: float,\n            i_joint_displacement_tolerance: float):\n\n        if i_clusters is None or i_assembly is None:\n            return None\n        if i_angle_threshold is None:\n            i_angle_threshold = 0.1\n        if i_distance_threshold is None:\n            i_distance_threshold = 0.1\n        if i_correspondence_distance is None:\n            i_correspondence_distance = 0.005\n        if i_joint_displacement_tolerance is None:\n            i_joint_displacement_tolerance =0.05\n        if len(i_clusters) == 0:\n            raise ValueError(\"No clusters given.\")\n        if not isinstance(i_clusters[0], Rhino.Geometry.PointCloud):\n            raise ValueError(\"The input clusters must be PointClouds.\")\n\n        # get number of joints\n        n_joints = i_assembly.total_number_joints\n\n        # prepping the reference meshes\n        df_joints = [[] for _ in range(n_joints)]\n        rh_joints = [[] for _ in range(n_joints)]\n        for joint in i_assembly.all_joints:\n            for face in joint.faces:\n                face = face.to_mesh()\n                face.Subdivide()\n                face.Faces.ConvertQuadsToTriangles()\n                rh_joints[joint.id].append(face)\n                df_joints[joint.id].append(df_cvt.cvt_rhmesh_2_dfmesh(face))\n        o_reference_point_clouds = []\n        o_joint_faces_segments = []\n        df_cloud_clusters = [df_cvt.cvt_rhcloud_2_dfcloud(cluster) for cluster in i_clusters]\n        df_joint_clouds = []\n        o_joint_segments = []\n\n        # compute the center of the joints\n        rh_joint_centers = []\n        for rh_joint in rh_joints:\n            vertices = []\n            for face in rh_joint:\n                for vertice in face.Vertices:\n                    vertices.append(Rhino.Geometry.Point3d(vertice.X, vertice.Y, vertice.Z))\n            joint_center = Rhino.Geometry.BoundingBox(vertices).Center\n            rh_joint_centers.append([joint_center.X, joint_center.Y, joint_center.Z])\n\n        # for each joint, find the corresponding faces, store them as such but also merge them, generate a reference point cloud, and register the merged clusters to the reference point cloud\n        for i, df_joint in enumerate(df_joints):\n            rh_joint_faces_segments = []\n            reference_joint_center = rh_joint_centers[i]\n\n            # create the reference point cloud\n            ref_df_joint_cloud = diffcheck_bindings.dfb_geometry.DFPointCloud()\n            for face in df_joint:\n                ref_face_cloud = face.sample_points_uniformly(1000)\n                ref_df_joint_cloud.add_points(ref_face_cloud)\n            o_reference_point_clouds.append(df_cvt.cvt_dfcloud_2_rhcloud(ref_df_joint_cloud))\n\n            # find the corresponding clusters and merge them\n            df_joint_cloud = diffcheck_bindings.dfb_geometry.DFPointCloud()\n            df_joint_face_segments = diffcheck_bindings.dfb_segmentation.DFSegmentation.associate_clusters(False, df_joint, df_cloud_clusters, i_angle_threshold, i_distance_threshold)\n            for df_joint_face_segment in df_joint_face_segments:\n                df_joint_cloud.add_points(df_joint_face_segment)\n\n            # get the center of the segment\n            if len(df_joint_cloud.points)>0:\n                df_cloud_bb_points = df_joint_cloud.get_tight_bounding_box()\n                x, y, z = 0, 0, 0\n                for i in range(len(df_cloud_bb_points)):\n                    x += df_cloud_bb_points[i][0]\n                    y += df_cloud_bb_points[i][1]\n                    z += df_cloud_bb_points[i][2]\n                x = x/8 # because a bb has 8 corners\n                y = y/8\n                z = z/8\n                segment_center = [x, y, z]\n                segment_dist_to_ref = math.sqrt(math.pow(segment_center[0]-reference_joint_center[0], 2)\n                                                + math.pow(segment_center[1]-reference_joint_center[1], 2)\n                                                + math.pow(segment_center[2]-reference_joint_center[2], 2))\n                if segment_dist_to_ref > i_joint_displacement_tolerance:\n                    rh_joint_cloud = df_cvt.cvt_dfcloud_2_rhcloud(df_joint_cloud)\n                    rh_joint_cloud.SetUserString(\"df_sanity_scan_check\", \"1\")\n                    o_joint_segments.append(rh_joint_cloud)\n                else:\n                    rh_joint_cloud = df_cvt.cvt_dfcloud_2_rhcloud(df_joint_cloud)\n                    rh_joint_cloud.SetUserString(\"df_sanity_scan_check\", \"0\")\n                    o_joint_segments.append(rh_joint_cloud)\n            else:\n                rh_joint_cloud = df_cvt.cvt_dfcloud_2_rhcloud(df_joint_cloud)\n                rh_joint_cloud.SetUserString(\"df_sanity_scan_check\", \"2\")\n                o_joint_segments.append(rh_joint_cloud)\n\n            # register the joint faces to the reference point cloud\n            transform = diffcheck_bindings.dfb_registrations.DFRefinedRegistration.O3DICP(df_joint_cloud, ref_df_joint_cloud, max_correspondence_distance = i_correspondence_distance)\n            for df_joint_face_segment in df_joint_face_segments:\n                df_joint_face_segment.apply_transformation(transform)\n                rh_joint_faces_segments.append(df_cvt.cvt_dfcloud_2_rhcloud(df_joint_face_segment))\n            df_joint_clouds.append(df_joint_cloud)\n            o_joint_faces_segments.append(rh_joint_faces_segments)\n\n        for rh_joint_faces, rh_joint in zip(o_joint_faces_segments, o_joint_segments):\n            for joint_face in rh_joint_faces:\n                joint_face.SetUserString(\"df_sanity_scan_check\", rh_joint.GetUserString(\"df_sanity_scan_check\"))\n\n        o_gh_tree_joint_faces_segments = ghpythonlib.treehelpers.list_to_tree(o_joint_faces_segments)\n\n        return o_gh_tree_joint_faces_segments, o_joint_segments, o_reference_point_clouds\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}