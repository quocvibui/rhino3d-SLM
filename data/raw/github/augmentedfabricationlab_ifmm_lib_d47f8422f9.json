{
  "source_url": "https://github.com/augmentedfabricationlab/ifmm_lib/blob/1cc6e87f5b07e0d6bd144f8f24462cc0d0a70fdb/clients/arduino/communication/arduinoclient.py",
  "repo": "augmentedfabricationlab/ifmm_lib",
  "repo_stars": 0,
  "repo_description": "In situ Fabricatr & Mesh Mould @ EMPA Nest 2017",
  "license": "unknown",
  "filepath": "clients/arduino/communication/arduinoclient.py",
  "instruction": ". . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<      ><  <<      ><  <<  <<><><>   .\n.   < ><   ><<  < ><   ><<  <<  <<        .\n.   << >< > ><  << ><...",
  "code": "'''\n. . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<      ><  <<      ><  <<  <<><><>   .\n.   < ><   ><<  < ><   ><<  <<  <<        .\n.   << >< > ><  << >< > ><  <<  <<><><>   .  \n.   <<  ><  ><  <<  ><  ><  <<  <<        .\n.   <<      ><  <<      ><  <<  <<        .\n.   <<      ><  <<      ><  <<  <<        .\n.                                         .\n.             GKR 2016/17                 .\n. . . . . . . . . . . . . . . . . . . . . .\n\nCreated on 19.11.2016\n\n@author: kathrind\n'''\n\nfrom threading import *\n\nimport socket\nimport struct\nimport time\nimport math\n\nfrom ifmm_lib.clients.clientstates import states_dict, READY, BUSY\nfrom ifmm_lib.clients.arduino.communication.messagetypes import arduino_msg_type_dict, MSG_CMD_RECEIVED, MSG_CMD_EXECUTED, MSG_DIGITAL_OUT, MSG_INFO, MSG_STRING, \\\n                         MSG_FLOAT_LIST, MSG_CMD_ROTATE_MOTOR_ABS, MSG_CMD_ROTATE_MOTOR_REL, MSG_CMD_FEED_WIRE, MSG_CMD_ELECTRODES, \\\n                         MSG_CMD_NIPPERS, MSG_CMD_WELD, MSG_CMD_ROUTINE_FEED_CUT_WELD, MSG_CMD_BEND, MSG_CMD_RESET_ENCODER, MSG_CMD_GET_ENCODER_VAL\nfrom ifmm_lib.useful import map_range\n\n#import Rhino.Geometry as rg\n\nclass ArduinoClient(object):\n    def __init__(self, host = \"127.0.0.1\", port=30001):\n        self.host = host\n        self.port = port\n        self.byteorder = \"<\" # \"!\" network, \">\" big-endian, \"<\" for little-endian, see http://docs.python.org/2/library/struct.html\n        self.connected = False\n        \n        self.lock_counter = Lock()\n        self.lock_state = Lock()\n        \n        self.msg_counter = 0\n        self.msg_len_rcv = \"\"\n        self.msg_rcv = \"\"\n        \n        self.info_msg = \"\"\n        \n        self.wait_flag = True\n        \n        self.set_state(READY)\n        \n        self.connection_success = False\n        \n        #self.angle_per_step_m_front = (1.8/4)/8 # --> if motor is configured for micro steps\n        #self.angle_per_step_m_back = (1.8/4)/9 * 29./34. # --> if motor is configured for micro steps\n        self.angle_per_step_m_front = (1.8)/15\n        self.angle_per_step_m_back = (1.8)/9 * 29./34.\n        self.angle_per_step_m_feeder = (1.8/4)\n        \n    \n    #===========================================================================\n    def is_connected(self):\n        return self.connection_success & self.connected\n    \n    #===========================================================================    \n    def connect(self):\n        if self.connected == False:\n            try:\n                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                self.sock.settimeout(1) #self.socket.settimeout(1.0)\n                self.sock.connect((self.host, self.port))\n                print \"Connected to server %s on port %d\" % (self.host, self.port)\n                self.connected = True\n                return True\n            except:\n                print \"Connection to server %s on port %d not available\" % (self.host, self.port)\n                self.connected = False\n                return False\n                \n    #===========================================================================\n    def reset(self):\n        if self.connected:\n            self.close()\n        ok = self.connect()\n        \n        if ok:\n            msg_type, msg, success = self.send_get_arduino_info()\n            if success:\n                self.connection_success = True\n                self.connected = True\n                self.set_state(READY)\n            else:\n                self.connection_success = False\n                self.connected = False\n    \n    #===========================================================================\n    def reset_old(self):\n        if self.connected:\n            self.close()\n        self.connect()\n        \n        msg_type, msg, success = self.send_get_arduino_info()\n        if success:\n            self.connection_success = True\n            self.connected = True\n            self.set_state(READY)\n        else:\n            self.connection_success = False\n            self.connected = False\n        \n    #===========================================================================\n    def connect_old(self):\n        if self.connected == False:\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            self.sock.settimeout(1)\n            self.sock.connect((self.host, self.port))\n            print \"Connected to server %s on port %d\" % (self.host, self.port)\n            self.connected = True\n    \n    #===========================================================================    \n    def close(self):\n        self.sock.close()\n        self.connected = False\n    #===========================================================================\n    def set_msg_counter(self): \n        self.lock_counter.acquire()\n        self.msg_counter += 1\n        self.lock_counter.release()\n    #===========================================================================\n    def get_msg_counter(self):\n        self.lock_counter.acquire()\n        c = self.msg_counter\n        self.lock_counter.release()\n        return c\n    # =================================================================================\n    def set_state(self, state):\n        self.lock_state.acquire()\n        self.state = state\n        self.lock_state.release()\n    # =================================================================================\n    def get_state(self):\n        self.lock_state.acquire()\n        state = self.state\n        self.lock_state.release()\n        return state\n    # =================================================================================\n    def set_wait_flag(self, state):\n        self.wait_flag = state\n    \n    #===========================================================================\n    def __send(self, msg_type, msg = None, wait_for_response = True):\n        \"\"\" send message according to message type \"\"\"\n        \n        buf = None\n        #print msg_type\n        #print MSG_CMD_ELECTRODES\n        \n        if msg_type == MSG_INFO:\n            \"[msg_type, msg_counter]\"\n            msg_snd_len = 4 + 4 #+4bytes = wait_for_respons\n            params = [msg_snd_len, msg_type, self.get_msg_counter(), wait_for_response]\n            buf = struct.pack(self.byteorder + \"4i\", *params)\n        elif msg_type == MSG_CMD_WELD or msg_type == MSG_CMD_RESET_ENCODER or msg_type == MSG_CMD_GET_ENCODER_VAL: #empty message\n            \"[msg_type, msg_counter]\"\n            msg_snd_len = 4 + 4 #+4bytes = wait_for_respons\n            params = [msg_snd_len, msg_type, self.get_msg_counter(), wait_for_response]\n            buf = struct.pack(self.byteorder + \"4i\", *params)          \n        elif msg_type == MSG_DIGITAL_OUT:\n            \"[msg_type, msg_counter, int_do_num, int_do_state]\"\n            msg_snd_len = 4 + 8 + 4 #+4bytes = wait_for_respons\n            params = [msg_snd_len, msg_type, self.get_msg_counter(), wait_for_response] + msg\n            buf = struct.pack(self.byteorder + \"4i\" + \"2i\", *params)\n        elif msg_type == MSG_CMD_ROTATE_MOTOR_ABS or msg_type == MSG_CMD_ROTATE_MOTOR_REL or msg_type == MSG_CMD_BEND:\n            \"[msg_type, msg_counter, int_val1, int_val2]\"\n            msg_snd_len = 4 + 8 + 4 #+4bytes = wait_for_respons\n            params = [msg_snd_len, msg_type, self.get_msg_counter(), wait_for_response] + msg\n            buf = struct.pack(self.byteorder + \"4i\" + \"2i\", *params)\n        elif msg_type == MSG_CMD_FEED_WIRE or msg_type == MSG_CMD_ELECTRODES or msg_type == MSG_CMD_NIPPERS or msg_type == MSG_CMD_ROUTINE_FEED_CUT_WELD:\n            #print \"HERE\"\n            \"[msg_type, msg_counter, int_val1]\"\n            msg_snd_len = 4 + 4 + 4 #+4bytes = wait_for_respons\n            params = [msg_snd_len, msg_type, self.get_msg_counter(), wait_for_response] + msg\n            buf = struct.pack(self.byteorder + \"4i\" + \"i\", *params)\n        elif msg_type == MSG_STRING:\n            \"[msg_type, msg_counter, string]\"\n            msg_snd_len = len(msg) + 4 + 4 # + 4bytes = msg_counter +4bytes = wait_for_response            \n            params = [msg_snd_len, msg_type, self.get_msg_counter(), wait_for_response] + [msg]\n            buf = struct.pack(self.byteorder + \"4i\" + str(len(msg)) +  \"s\", *params)\n        elif msg_type == MSG_FLOAT_LIST:\n            \"[msg_type, msg_counter, float_values]\"\n            msg_snd_len = struct.calcsize(str(len(msg)) + \"f\") + 4 + 4 # + 4bytes = msg_counter   +4bytes = wait_for_respons\n            params = [msg_snd_len, msg_type, self.get_msg_counter(), wait_for_response] + msg\n            # print \"params\", params            \n            buf = struct.pack(self.byteorder + \"4i\" + str(len(msg)) + \"f\", *params)\n        else:\n            print \"Message identifier unknown:  %s = %d, message: %s\" % (arduino_msg_type_dict[msg_type], msg_type, msg)\n            return   \n           \n        if buf != None:\n            self.sock.send(buf)\n            print \"Sent message: %s to server \" % (arduino_msg_type_dict[msg_type])\n\n    #===========================================================================\n    def __read(self):\n        \"\"\" The transmission protocol for messages is:\n        4 byte [message length] (= 1 * Unsigned 4 byte integer) # The message length is the length of the message without the message length and message type.\n        4 byte [message type] (= 1 * Unsigned 4 byte integer)\n        x byte [message] (according to type)\n        \"\"\"\n        \n        \"1. read msg length\"\n        while len(self.msg_len_rcv) < 4:   \n            self.msg_len_rcv += self.sock.recv(1)\n         \n        msg_length = struct.unpack_from(self.byteorder + \"I\", self.msg_len_rcv, 0)[0]\n        #print \"MESSAGE LENGTH:\", msg_length\n        \n        \"2. read rest of msg according to msg_length\"\n        while len(self.msg_rcv) < (msg_length + 4):    \n            self.msg_rcv += self.sock.recv(1)\n\n        \"3. unpack message type\"\n        msg_type = struct.unpack_from(self.byteorder + \"I\", self.msg_rcv[:4], 0)[0]\n        #print \"MESSAGE TYPE:\", msg_type\n        \n        \"4. rest of the message will be passed on as raw message (if there is no message body, raw_message stays empty)\"\n        raw_msg = self.msg_rcv[4:]\n        \n        \"5. reset msg_rcv + msg_len_rcv\"\n        self.msg_rcv = \"\"\n        self.msg_len_rcv = \"\"\n        \n        \"6. pass message id and raw message to process method \"\n        msg_type, msg = self.__process(msg_type, raw_msg)\n        return msg_type, msg\n    \n    #===========================================================================\n    def __process(self, msg_type, raw_msg):\n        \"\"\" The transmission protocol for messages is \n        [length msg in bytes] [msg identifier] [other bytes which will be read out according to msg identifier] \"\"\"\n        \n        if msg_type == MSG_CMD_RECEIVED:\n            msg_counter = struct.unpack_from(self.byteorder + \"i\", raw_msg)[0]\n            return (msg_type, msg_counter)\n        elif msg_type == MSG_CMD_EXECUTED:\n            msg_counter = struct.unpack_from(self.byteorder + \"i\", raw_msg)[0]\n            return (msg_type, msg_counter) if msg_counter != -1 else (msg_type, None)\n        elif msg_type == MSG_INFO:\n            msg_counter = struct.unpack_from(self.byteorder + \"i\", raw_msg[:4])[0]\n            msg_string = raw_msg[4:]\n            return (msg_type, (msg_counter, msg_string))\n        elif msg_type == MSG_CMD_GET_ENCODER_VAL:\n            msg_counter = struct.unpack_from(self.byteorder + \"i\", raw_msg[:4])[0]\n            encoder_value = struct.unpack_from(self.byteorder + \"i\", raw_msg[4:])[0]\n            encoder_value_deg = self.calc_rel_enc_angle_degree(encoder_value)\n            return (msg_type, (msg_counter, encoder_value_deg))\n        else:\n            print \"%s: Message identifier unknown: %d, message: %s\" % (self.parent.identifier, msg_type, raw_msg)\n            return (False, False)\n    \n    #===========================================================================\n    def __get(self, msg_type, msg = None, wait_for_response = True):\n        self.set_msg_counter()\n        self.set_state(BUSY)\n        self.__send(msg_type, msg, wait_for_response)\n        \n        self.wait_flag = True # test, maybe this has to be changed\n        success = False\n        msg_received_by_arduino = False\n        if wait_for_response:\n            success = False\n            while not success:\n                \n                # try to get a callback ba arduino, if message was received or not...\n                if not msg_received_by_arduino:\n                    #time.sleep(0.1)\n                    try:\n                        msg_type, msg = self.__read()\n                        if msg_type == MSG_CMD_RECEIVED:\n                            msg_received_by_arduino = True\n                        else:\n                            return (msg_type, msg, success)\n                    except:\n                        return (msg_type, msg, success)\n                    \n                # after receiving the acknowledge message from the arduino, try receiving the cmd executed msg    \n                try:\n                    msg_type, msg = self.__read()\n                    success = True #if msg else False\n                except:\n                    print \"waiting for response\"\n                    time.sleep(0.01)\n                    \n                    if self.wait_flag == False: # ------> thread can be killed from outside event\n                        return (msg_type, msg, success)\n                    \n        else: # just try to receive the cmd_received_message\n            success = False\n            try:\n                msg_type, msg = self.__read()\n                if msg_type == MSG_CMD_RECEIVED:\n                    success = True\n                    self.set_state(READY)\n                    return (msg_type, msg, success)\n                else:\n                    return (msg_type, msg, success)\n            except:\n                return (msg_type, msg, success)\n        \n        self.set_state(READY)\n        return (msg_type, msg, success)\n    \n    #===========================================================================\n    def send_get_arduino_info(self):\n        return self.__get(msg_type = MSG_INFO, msg = None, wait_for_response = True)\n    \n    #===========================================================================\n    def send_get_encoder_values(self):\n        return self.__get(msg_type = MSG_CMD_GET_ENCODER_VAL, msg = None, wait_for_response = True)\n    \n    \n    # ===============================================================================================================================\n    # motor angle calculations\n    # ===============================================================================================================================\n    def get_motor_pos_value_from_angle(self, angle_degrees, angle_per_step):\n        '''returns the motor abs positions for an angle input\n        please check: maybe needs to include a shift, depending on the zero position.\n        '''\n        #mapped_value = 8 * map_range(angle_degrees, -180, 180, -0.5 * 360 / angle_per_step, 0.5 * 360 / angle_per_step)\n        mapped_value = map_range(angle_degrees, -180, 180, -0.5 * 360 / angle_per_step, 0.5 * 360 / angle_per_step)\n        return mapped_value #* 48./40. #* -1.0 # be careful with the ratio\n    #===========================================================================\n    def get_angle_from_feed_len(self, feed_len, r):\n        # feed len, r in mm\n        angle = feed_len / r\n        return math.degrees(angle)\n    #===========================================================================\n    def get_feed_len_from_angle(self, angle, r):\n        #angle in deg, r in mm\n        feed_len = r * math.radians(angle)\n        return feed_len\n    \n    #===========================================================================\n    def calc_rel_enc_angle_degree(self, encoder_pos):\n        ticks_per_revolution = 4000 # 3600 for the new one\n        return encoder_pos * 360. / (4. * ticks_per_revolution)\n    \n    #===========================================================================\n    def calc_rel_enc_angle_rad(self, encoder_pos):\n        ticks_per_revolution = 4000 # 3600 for the new one\n        return encoder_pos * 2. * math.pi / (4. * ticks_per_revolution)\n    \n    \"\"\"\n    #===========================================================================\n    def get_motor_pos_value_from_angle_old(self, angle_degrees):\n        '''returns the motor abs positions for an angle input\n        please check: maybe needs to include a shift, depending on the zero position.\n        '''\n        mapped_value = map_range(angle_degrees, -90, 90, -200, 200)\n        return mapped_value * 34./29. \"\"\"\n    \n    # ===============================================================================================================================\n    # communcation with Arduino\n    # ===============================================================================================================================\n    \n    #===========================================================================  \n    def send_set_do(self, do = 0, state = 0, wait_for_response = True):\n        \"\"\" command the arduino board to set a digital out to the given state. \"\"\"\n        return self.__get(msg_type = MSG_DIGITAL_OUT, msg = [do, state], wait_for_response = wait_for_response)\n    \n    #===========================================================================    \n    def send_cmd_rotate_motor_abs(self, angle, motor_num, angle_per_step, wait_for_response = True):\n        \"\"\" send a rotating command message to arduino with two int values. int1 = motortype, int2 = angle value \"\"\"\n        motor_pos = self.get_motor_pos_value_from_angle(angle, angle_per_step)\n        return self.__get(msg_type = MSG_CMD_ROTATE_MOTOR_ABS, msg = [int(motor_pos), int(motor_num)], wait_for_response = wait_for_response)\n    \n    #===========================================================================    \n    def send_cmd_rotate_motor_abs_pos(self, motor_pos, motor_num, wait_for_response = True):\n        \"\"\" send a rotating command message to arduino with two int values. int1 = motortype, int2 = angle value \"\"\"\n        return self.__get(msg_type = MSG_CMD_ROTATE_MOTOR_ABS, msg = [int(motor_pos), int(motor_num)], wait_for_response = wait_for_response)\n    \n    #===========================================================================\n    def send_cmd_rotate_motor_rel(self, angle, motor_num, angle_per_step, wait_for_response = True):\n        \"\"\" send a rotating command message to arduino with two int values. int1 = motortype, int2 = angle value \"\"\"\n        motor_steps = self.get_motor_pos_value_from_angle(angle, angle_per_step)\n        return self.__get(msg_type = MSG_CMD_ROTATE_MOTOR_REL, msg = [int(motor_steps), int(motor_num)], wait_for_response = wait_for_response)\n    \n    #===========================================================================\n    # specific commands\n    #===========================================================================\n    \n    #===========================================================================\n    def send_cmd_bend(self, angle, overbending_value, wait_for_response = True):\n        \"\"\" send a bend command message to arduino with two int values. int1 = motorsteps front, int2 = motorsteps back \"\"\"\n        angle_per_step_front = self.angle_per_step_m_front \n        motor_pos_front = self.get_motor_pos_value_from_angle(angle, angle_per_step_front)\n        overbending_value = self.get_motor_pos_value_from_angle(overbending_value, angle_per_step_front)\n        \n        return self.__get(msg_type = MSG_CMD_BEND, msg = [int(motor_pos_front), int(overbending_value)], wait_for_response = wait_for_response)\n    \n    #===========================================================================\n    def send_cmd_reset_encoder(self, wait_for_response = True):\n        return self.__get(msg_type = MSG_CMD_RESET_ENCODER, msg = None, wait_for_response = wait_for_response)\n    \n    #===========================================================================\n    def send_cmd_weld(self, wait_for_response = True):\n        return self.__get(msg_type = MSG_CMD_WELD, msg = None, wait_for_response = wait_for_response)\n    \n    #===========================================================================\n    def send_cmd_rotate_m_front_abs(self, angle, wait_for_response = True):\n        motor_num = 1\n        angle_per_step = self.angle_per_step_m_front\n        return self.send_cmd_rotate_motor_abs(angle, motor_num, angle_per_step, wait_for_response = wait_for_response)\n    \n    #===========================================================================\n    def send_cmd_rotate_m_front_rel(self, angle, wait_for_response = True):\n        motor_num = 1\n        angle_per_step = self.angle_per_step_m_front\n        return self.send_cmd_rotate_motor_rel(angle, motor_num, angle_per_step, wait_for_response = wait_for_response)\n    \n    #===========================================================================\n    def send_cmd_rotate_m_back_abs(self, angle, wait_for_response = True):\n        motor_num = 2\n        angle_per_step = self.angle_per_step_m_back\n        return self.send_cmd_rotate_motor_abs(angle, motor_num, angle_per_step, wait_for_response = wait_for_response)\n    \n    #===========================================================================\n    def send_cmd_rotate_m_back_rel(self, angle, wait_for_response = True):\n        motor_num = 2\n        angle_per_step = self.angle_per_step_m_back\n        return self.send_cmd_rotate_motor_rel(angle, motor_num, angle_per_step, wait_for_response = wait_for_response)        \n    \n    # ==========================================================================\n    def send_cmd_rotate_m_feeder_abs(self, angle, wait_for_response = True):\n        motor_num = 3\n        angle_per_step = self.angle_per_step_m_feeder\n        return self.send_cmd_rotate_motor_abs(angle, motor_num, angle_per_step, wait_for_response = wait_for_response)\n    \n    #===========================================================================\n    def send_cmd_rotate_m_feeder_rel(self, angle, wait_for_response = True):\n        motor_num = 3\n        angle_per_step = self.angle_per_step_m_feeder\n        return self.send_cmd_rotate_motor_rel(angle, motor_num, angle_per_step, wait_for_response = wait_for_response)\n    \n    #===========================================================================\n    def send_cmd_feed_wire_old(self, feed_len, wait_for_response = True):\n        r = 23\n        angle = self.get_angle_from_feed_len(feed_len, r)\n        return self.send_cmd_rotate_m_feeder_rel(angle, wait_for_response = wait_for_response)\n    \n    #===========================================================================\n    def send_cmd_feed_wire(self, feed_len, wait_for_response = True):\n        \n        r = 23\n        angle_per_step = self.angle_per_step_m_feeder\n        \n        angle = self.get_angle_from_feed_len(feed_len, r)\n        motor_steps = self.get_motor_pos_value_from_angle(angle, angle_per_step)\n        \n        return self.__get(msg_type = MSG_CMD_FEED_WIRE, msg = [motor_steps], wait_for_response = wait_for_response)\n    \n    #===========================================================================\n    def send_cmd_eject_wire(self, wait_for_response = True):\n        \n        feed_len = -500\n        \n        r = 23\n        angle_per_step = self.angle_per_step_m_feeder\n        \n        angle = self.get_angle_from_feed_len(feed_len, r)\n        motor_steps = self.get_motor_pos_value_from_angle(angle, angle_per_step)\n        \n        return self.__get(msg_type = MSG_CMD_FEED_WIRE, msg = [motor_steps], wait_for_response = wait_for_response)\n    \n    #===========================================================================\n    def send_cmd_load_wire(self, wait_for_response = True):\n        \n        feed_len = 500\n        \n        r = 23\n        angle_per_step = self.angle_per_step_m_feeder\n        \n        angle = self.get_angle_from_feed_len(feed_len, r)\n        motor_steps = self.get_motor_pos_value_from_angle(angle, angle_per_step)\n        \n        return self.__get(msg_type = MSG_CMD_FEED_WIRE, msg = [motor_steps], wait_for_response = wait_for_response)\n    \n    # int1 = 0: OPEN # int1 = 1: CLOSE # int1 = 1: STOP\n    #===========================================================================\n    def send_electrodes_open(self, wait_for_response = True):\n        return self.__get(msg_type = MSG_CMD_ELECTRODES, msg = [0], wait_for_response = wait_for_response)\n    \n    #===========================================================================\n    def send_electrodes_close(self, wait_for_response = True):\n        return self.__get(msg_type = MSG_CMD_ELECTRODES, msg = [1], wait_for_response = wait_for_response)\n    \n    #===========================================================================\n    def send_electrodes_stop(self, wait_for_response = True):\n        return self.__get(msg_type = MSG_CMD_ELECTRODES, msg = [2], wait_for_response = wait_for_response)\n    \n    \n    # int1 = 0: MOVE_TO_BACK, int1 = 1: MOVE_TO_FRONT, int1 = 2: CUT, int1 = 3: RELEASE\n    #===========================================================================\n    def send_nippers_move_to_back(self, wait_for_response = True):\n        return self.__get(msg_type = MSG_CMD_NIPPERS, msg = [0], wait_for_response = wait_for_response)\n    \n    #===========================================================================\n    def send_nippers_move_to_front(self, wait_for_response = True):\n        return self.__get(msg_type = MSG_CMD_NIPPERS, msg = [1], wait_for_response = wait_for_response)\n    \n    #===========================================================================\n    def send_nippers_cut(self, wait_for_response = True):\n        return self.__get(msg_type = MSG_CMD_NIPPERS, msg = [2], wait_for_response = wait_for_response)\n    \n    #===========================================================================\n    def send_nippers_release(self, wait_for_response = True):\n        return self.__get(msg_type = MSG_CMD_NIPPERS, msg = [3], wait_for_response = wait_for_response)\n    \n    \n    #===========================================================================\n    def send_cmd_feed_cut_weld(self, feed_len, wait_for_response = True):\n        \n        r = 23\n        angle_per_step = self.angle_per_step_m_feeder\n        \n        angle = self.get_angle_from_feed_len(feed_len, r)\n        motor_steps = self.get_motor_pos_value_from_angle(angle, angle_per_step)\n        \n        return self.__get(msg_type = MSG_CMD_ROUTINE_FEED_CUT_WELD, msg = [motor_steps], wait_for_response = wait_for_response)\n\n    \n         \n\nif __name__ == \"__main__\":\n    aclient = ArduinoClient(host = \"192.168.10.177\", port=30001)\n    time.sleep(0.5)\n    \n    aclient.connect()\n    time.sleep(2.5)\n    print \"Connection: \", aclient.connected\n    v1 = 0\n    v2 = 50\n    for i in range(1000):\n        \n        f = v1 if i%2==0 else v2\n        #msg_type, msg_counter, success = aclient.send_cmd_bending(f=f)\n        msg_type, msg, success = aclient.send_get_arduino_info()\n        print \"RECEIVED MSG FROM ARDUINO: \"\n        print \"MSG TYPE: \", arduino_msg_type_dict[msg_type]\n        print \"MSG: \", msg\n        \n        print \"SUCCESS\" if success==True else \"NO SUCCESS\"\n        \n        if not success:\n            aclient.close()\n            time.sleep(1)\n            aclient.connect()\n            \n        #print \"MSG COUNTER: \", msg_counter\n    \n        time.sleep(0.1)\n    aclient.close()\n    print \"Connection: \", aclient.connected\n    time.sleep(0.1)",
  "language": "python",
  "imports": [
    "Rhino.Geometry"
  ],
  "has_docstring": true
}