{
  "source_url": "https://github.com/Ennead-Architects-LLP/EA_Dist/blob/635520d89b8308b78eabf5b60bb80121d0fa3838/Apps/_revit/EnneaDuck.extension/EnneadTab.tab/Import%20Export.panel/Rhino.pulldown/revit2rhino.pushbutton/revit2rhino_action.py",
  "repo": "Ennead-Architects-LLP/EA_Dist",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Apps/_revit/EnneaDuck.extension/EnneadTab.tab/Import Export.panel/Rhino.pulldown/revit2rhino.pushbutton/revit2rhino_action.py",
  "instruction": "Action module for Revit2Rhino export tool.\r\nHandles the actual export functionality after user preferences are collected.",
  "code": "#!/usr/bin/python\r\n# -*- coding: utf-8 -*-\r\n\r\n\"\"\"\r\nAction module for Revit2Rhino export tool.\r\nHandles the actual export functionality after user preferences are collected.\r\n\"\"\"\r\n\r\nimport clr  # pyright: ignore\r\nimport os\r\nimport time\r\nimport logging\r\nimport traceback\r\nimport hashlib\r\nimport json\r\n# Configure logging\r\nlogger = logging.getLogger(\"Revit2Rhino\")\r\nlogger.setLevel(logging.INFO)\r\nconsole_handler = logging.StreamHandler()\r\nconsole_handler.setLevel(logging.INFO)\r\nformatter = logging.Formatter('%(levelname)s - %(message)s')\r\nconsole_handler.setFormatter(formatter)\r\nlogger.addHandler(console_handler)\r\n\r\ndef enable_debug_logging():\r\n    logger.setLevel(logging.DEBUG)\r\n    console_handler.setLevel(logging.DEBUG)\r\n    logger.debug(\"Debug logging enabled\")\r\n\r\ntry:\r\n    import System  # pyright: ignore\r\n    clr.AddReference('RhinoCommon')\r\n    import Rhino  # pyright: ignore\r\n    clr.AddReference('RhinoInside.Revit')\r\n    from RhinoInside.Revit.Convert.Geometry import GeometryDecoder as RIR_DECODER  # pyright: ignore\r\n    IMPORT_OK = True\r\nexcept:\r\n    IMPORT_OK = False\r\n\r\n\r\nfrom EnneadTab import ERROR_HANDLE, LOG, NOTIFICATION, UI, ENVIRONMENT, USER\r\nfrom EnneadTab.REVIT import REVIT_APPLICATION, REVIT_UNIT, REVIT_RHINO, REVIT_FORMS\r\nfrom Autodesk.Revit import DB  # pyright: ignore\r\n\r\n# Get the current document\r\nDOC = REVIT_APPLICATION.get_doc()\r\n\r\n\r\ndef export_elements_to_rhino(doc, selected_instances):\r\n    \"\"\"\r\n    Export selected elements to Rhino with options.\r\n    \r\n    Args:\r\n        doc (DB.Document): The Revit document.\r\n        selected_instances (list): List of Revit elements to export\r\n        \r\n    Returns:\r\n        str: Path to the exported Rhino file or None if failed\r\n    \"\"\"\r\n    # Track start time for performance measurement\r\n    start_time = time.time()\r\n    \r\n    # Initialize exporter with options\r\n    exporter = RevitToRhinoExporter(doc)\r\n    exporter.family_instances = selected_instances\r\n    exporter.preserve_family_layers = True  # Always preserve family layers\r\n    exporter.setup_document()\r\n    \r\n    # Process elements with progress bar\r\n    def process_element(element):\r\n        exporter.process_element(element)\r\n    \r\n    def label_func(element):\r\n        element_name = \"{} - {}\".format(\r\n            exporter._get_family_name(element), \r\n            element.Id.IntegerValue\r\n        )\r\n        return \"Exporting: {}\".format(element_name)\r\n    \r\n    # Process elements with progress bar\r\n    UI.progress_bar(\r\n        selected_instances,\r\n        process_element,\r\n        label_func=label_func,\r\n        title=\"Revit2Rhino: Exporting Elements\"\r\n    )\r\n    \r\n    # Complete export and save file\r\n    logger.info(\"Finalizing Rhino file...\")\r\n    export_result = exporter.finalize_export()\r\n    \r\n    # Calculate elapsed time\r\n    elapsed_time = time.time() - start_time\r\n    mins, secs = divmod(elapsed_time, 60)\r\n    hours, mins = divmod(mins, 60)\r\n    \r\n    time_str = \"\"\r\n    if hours > 0:\r\n        time_str += \"{:.0f} hours \".format(hours)\r\n    if mins > 0:\r\n        time_str += \"{:.0f} minutes \".format(mins)\r\n    time_str += \"{:.1f} seconds\".format(secs)\r\n    \r\n    if export_result:\r\n        success_message = \"Successfully exported to: {}\\nTotal time: {}\".format(export_result, time_str)\r\n        success_message += \"\\nYou new Rhino will start soon.\"\r\n        NOTIFICATION.messenger(success_message)\r\n        return export_result\r\n    else:\r\n        NOTIFICATION.messenger(\"Export failed. Check log for details.\\nTotal time: {}\".format(time_str))\r\n        return None\r\n\r\n\r\nclass RevitToRhinoExporter(object):\r\n    def __init__(self, revit_doc):\r\n        self.revit_doc = revit_doc\r\n        \r\n        # Generate timestamp for filename\r\n        timestamp = time.strftime(\"%Y%m%d_%H%M%S\", time.localtime())\r\n        self.output_file = os.path.join(ENVIRONMENT.DUMP_FOLDER, \"{}_Revit2Rhino_{}.3dm\".format(ENVIRONMENT.PLUGIN_NAME, timestamp))\r\n        \r\n        self.rhino_doc = None\r\n        self.family_instances = None\r\n        self.geom_options = None\r\n        \r\n        # New option for preserving family layers\r\n        self.preserve_family_layers = False\r\n        \r\n        # Statistics tracking\r\n        self.symbol_geo_count = 0\r\n        self.instance_geo_count = 0\r\n        self.failed_geo_count = 0\r\n        self.layer_dict = {}\r\n        \r\n        # Cache for block definitions\r\n        self.block_cache = {}\r\n        self.block_geo_source = {}\r\n        \r\n        # Get the current document unit\r\n        self.revit_unit = REVIT_UNIT.get_doc_length_unit_name(revit_doc)\r\n        \r\n        # Store the scale factor for unit conversion\r\n        # Revit internal unit is always feet, but display unit can be different\r\n        self.scale_factor = REVIT_UNIT.get_scale_factor(self.revit_unit)\r\n        logger.info(\"Revit document unit: {} (scale factor: {:.3f})\".format(self.revit_unit, self.scale_factor))\r\n\r\n\r\n    def setup_document(self):\r\n        \"\"\"Initialize Rhino document and geometry options\"\"\"\r\n        self.rhino_doc = REVIT_RHINO.setup_rhino_doc(self.revit_doc)\r\n        \r\n        # Create geometry options\r\n        opts = DB.Options()\r\n        opts.DetailLevel = DB.ViewDetailLevel.Fine\r\n        opts.IncludeNonVisibleObjects = True\r\n        self.geom_options = opts\r\n        \r\n        return True\r\n            \r\n    def process_element(self, element):\r\n        \"\"\"Process a single family instance\"\"\"\r\n        return self._process_element(element)\r\n    \r\n    def finalize_export(self):\r\n        \"\"\"Generate statistics and save the Rhino file\"\"\"\r\n        # Print statistics\r\n        logger.info(\"Geometry source statistics:\")\r\n        logger.info(\"  - Blocks using symbol geometry: {}\".format(self.symbol_geo_count))\r\n        logger.info(\"  - Blocks using instance geometry: {}\".format(self.instance_geo_count))\r\n        logger.info(\"  - Elements with no usable geometry: {}\".format(self.failed_geo_count))\r\n        \r\n        # Save the file\r\n        self._write_rhino_file()\r\n        return self.output_file\r\n        \r\n    def _get_family_name(self, element):\r\n        \"\"\"Get family name from an element with error handling\"\"\"\r\n        try:\r\n            # Handle system families\r\n            if hasattr(element, \"WallType\"):\r\n                return \"Wall\"\r\n            elif hasattr(element, \"FloorType\"):\r\n                return \"Floor\"\r\n            elif hasattr(element, \"RoofType\"):\r\n                return \"Roof\"\r\n            elif hasattr(element, \"StairsType\"):\r\n                return \"Stair\"\r\n            elif hasattr(element, \"RailingType\"):\r\n                return \"Railing\"\r\n            elif hasattr(element, \"CeilingType\"):\r\n                return \"Ceiling\"\r\n            elif hasattr(element, \"RampType\"):\r\n                return \"Ramp\"\r\n            elif hasattr(element, \"ModelTextType\"):\r\n                return \"ModelText\"\r\n            # Handle loadable families\r\n            elif hasattr(element, \"Symbol\") and hasattr(element.Symbol, \"FamilyName\"):\r\n                if hasattr(element, 'link_doc'):\r\n                    return element.Symbol.FamilyName + \" (Linked)\"\r\n                return element.Symbol.FamilyName\r\n            elif hasattr(element, \"FamilyName\"):\r\n                return element.FamilyName\r\n            elif hasattr(element, \"Name\"):\r\n                return element.Name\r\n        except Exception:\r\n            print(traceback.format_exc())\r\n        return \"Unknown\"\r\n\r\n    def _get_type_name(self, element):\r\n        \"\"\"Get type name from an element with error handling\"\"\"\r\n        try:\r\n            # Handle system families\r\n            if hasattr(element, \"WallType\"):\r\n                return element.WallType.LookupParameter(\"Type Name\").AsString()\r\n            elif hasattr(element, \"FloorType\"):\r\n                return element.FloorType.LookupParameter(\"Type Name\").AsString()\r\n            elif hasattr(element, \"RoofType\"):\r\n                return element.RoofType.LookupParameter(\"Type Name\").AsString()\r\n            elif hasattr(element, \"StairsType\"):\r\n                return element.StairsType.LookupParameter(\"Type Name\").AsString()\r\n            elif hasattr(element, \"RailingType\"):\r\n                return element.RailingType.LookupParameter(\"Type Name\").AsString()\r\n            elif hasattr(element, \"CeilingType\"):\r\n                return element.CeilingType.LookupParameter(\"Type Name\").AsString()\r\n            elif hasattr(element, \"RampType\"):\r\n                return element.RampType.LookupParameter(\"Type Name\").AsString()\r\n            elif hasattr(element, \"ModelTextType\"):\r\n                return element.ModelTextType.LookupParameter(\"Type Name\").AsString()\r\n            # Handle loadable families\r\n            elif hasattr(element, \"Symbol\") and hasattr(element.Symbol, \"Name\"):\r\n                return element.Symbol.Name\r\n            elif hasattr(element, \"Name\"):\r\n                return element.Name\r\n        except Exception:\r\n            pass\r\n        return \"NoType\"\r\n\r\n    def _geometry_signature(self, geometry_data):\r\n        \"\"\"Generate an 8-digit hash signature for all Rhino geometry in geometry_data using ToJSON.\"\"\"\r\n        jsons = []\r\n        for subcat, geo_list in geometry_data.items():\r\n            if subcat in (\"geometry_source\", \"category_name\") or not geo_list:\r\n                continue\r\n            for geo in geo_list:\r\n                if geo is not None and hasattr(geo, \"ToJSON\"):\r\n                    try:\r\n                        jsons.append(geo.ToJSON())\r\n                    except Exception:\r\n                        jsons.append(str(geo))\r\n        combined = ''.join(sorted(jsons))\r\n        return hashlib.sha256(combined.encode('utf-8')).hexdigest()[:8]\r\n\r\n    def _instance_parameter_signature(self, element):\r\n        \"\"\"\r\n        Generate a stable, order-independent signature for geometry-affecting instance parameters.\r\n        Only includes parameters that are not ElementId or String type.\r\n        Returns an 8-digit hash string.\r\n        \"\"\"\r\n        param_dict = {}\r\n        for param in element.Parameters:\r\n            # Skip ElementId and String types\r\n            if param.StorageType.ToString() in [\"ElementId\", \"String\"]:\r\n                continue\r\n            try:\r\n                # Get parameter value safely\r\n                if param.StorageType.ToString() == \"Double\":\r\n                    value = str(param.AsDouble())\r\n                elif param.StorageType.ToString() == \"Integer\":\r\n                    value = str(param.AsInteger())\r\n                elif param.StorageType.ToString() == \"None\":\r\n                    value = \"None\"\r\n                else:\r\n                    # For other types, try to get string representation\r\n                    try:\r\n                        value = param.AsValueString()\r\n                    except:\r\n                        try:\r\n                            value = param.AsString()\r\n                        except:\r\n                            value = str(param.AsInteger())\r\n                \r\n                # Clean the value string to ensure it's ASCII-safe\r\n                if value:\r\n                    # Replace common special characters with their ASCII equivalents\r\n                    value = value.replace(\"°\", \"deg\")\r\n                    value = value.replace(\"±\", \"+-\")\r\n                    value = value.replace(\"×\", \"x\")\r\n                    value = value.replace(\"÷\", \"/\")\r\n                    # Remove any remaining non-ASCII characters\r\n                    value = ''.join(char for char in value if ord(char) < 128)\r\n                \r\n                param_dict[param.Definition.Name] = value\r\n            except Exception:\r\n                continue\r\n                \r\n        # Sort and serialize for stable hashing\r\n        try:\r\n            param_json = json.dumps(param_dict, sort_keys=True, ensure_ascii=True)\r\n            return hashlib.sha256(param_json.encode('utf-8')).hexdigest()[:8]\r\n        except Exception:\r\n            # Fallback: if JSON serialization fails, use a simpler string representation\r\n            param_str = str(sorted(param_dict.items()))\r\n            return hashlib.sha256(param_str.encode('utf-8', errors='ignore')).hexdigest()[:8]\r\n\r\n    def _process_element(self, element):\r\n        \"\"\"Process a single family instance for export, using appropriate block caching strategy.\"\"\"\r\n        element_id = element.Id.IntegerValue\r\n        family_name = self._get_family_name(element)\r\n        type_name = self._get_type_name(element)\r\n\r\n        # Determine if this is a system family\r\n        is_system_family = any(hasattr(element, attr) for attr in [\r\n            \"WallType\", \"FloorType\", \"RoofType\", \"StairsType\", \r\n            \"RailingType\", \"CeilingType\", \"RampType\", \"ModelTextType\"\r\n        ])\r\n\r\n        # Extract geometry for this element\r\n        geometry_data = self._get_geometry(element)\r\n\r\n        # Generate block name based on family type\r\n        if is_system_family:\r\n            # For system families, use element ID to ensure uniqueness\r\n            block_name = \"{}_{}_{}\".format(family_name, type_name, element_id)\r\n        else:\r\n            # For loadable families, use parameter signature\r\n            param_signature = self._instance_parameter_signature(element)\r\n            block_name = \"{}_{}_{}\".format(family_name, type_name, param_signature)\r\n\r\n        # Check if we've already created a block for this signature\r\n        if block_name in self.block_cache:\r\n            block_idx = self.block_cache[block_name]\r\n            geo_source = self.block_geo_source.get(block_name, \"Unknown\")\r\n            logger.debug(\"  Using cached block for {}\".format(block_name))\r\n        else:\r\n            if not geometry_data or len(geometry_data) <= 1:\r\n                logger.warning(\"  WARNING: No valid geometry found for {}\".format(family_name))\r\n                self.failed_geo_count += 1\r\n                return\r\n\r\n            # Update statistics based on geometry source\r\n            geo_source = geometry_data.get(\"geometry_source\", \"Unknown\")\r\n            if geo_source == \"Symbol\":\r\n                self.symbol_geo_count += 1\r\n            elif geo_source.startswith(\"Instance\"):\r\n                self.instance_geo_count += 1\r\n\r\n            # For Instance geometry, untransform it to get it in symbol coordinates\r\n            if geo_source == \"Instance\" and hasattr(element, \"GetTransform\"):\r\n                transform = element.GetTransform()\r\n                if transform:\r\n                    geometry_data = self._untransform_geometry(geometry_data, transform)\r\n                    geo_source = geometry_data.get(\"geometry_source\", \"Unknown\")\r\n\r\n            # Create a block definition from the geometry\r\n            block_idx = self._create_block_definition(family_name, type_name, geometry_data)\r\n            if block_idx < 0:\r\n                logger.error(\"  ERROR: Failed to create block for {}\".format(family_name))\r\n                return\r\n\r\n            # Cache the block for future instances\r\n            self.block_cache[block_name] = block_idx\r\n            self.block_geo_source[block_name] = geo_source\r\n\r\n        # Place a block instance with the element's transformation\r\n        self._place_block_instance(block_idx, element, geo_source)\r\n\r\n    def _get_geometry(self, element):\r\n        \"\"\"Extract geometry from a family instance.\"\"\"\r\n        family_name = self._get_family_name(element)\r\n        category_name = self._get_category_name(element)\r\n\r\n        out_data = {\r\n            \"category_name\": category_name, \r\n            \"family_name\": family_name,\r\n            \"geometry_source\": \"None\"}\r\n        \r\n        # For system families, get geometry directly from the element\r\n        if any(hasattr(element, attr) for attr in [\"WallType\", \"FloorType\", \"RoofType\", \"StairsType\", \r\n                                                  \"RailingType\", \"CeilingType\", \"RampType\", \"ModelTextType\"]):\r\n            instance_geometry = self._get_instance_geometry(element)\r\n            if instance_geometry and len(instance_geometry) > 1:  # More than just metadata\r\n                instance_geometry[\"category_name\"] = category_name\r\n                return instance_geometry\r\n            return out_data\r\n        \r\n        # For loadable families, try symbol geometry first\r\n        if hasattr(element, \"Symbol\"):\r\n            symbol_geometry = self._get_symbol_geometry(element.Symbol)\r\n            if symbol_geometry and len(symbol_geometry) > 1:  # More than just metadata\r\n                symbol_geometry[\"category_name\"] = category_name\r\n                return symbol_geometry\r\n            \r\n            # If symbol geometry failed, try instance geometry\r\n            instance_geometry = self._get_instance_geometry(element)\r\n            if instance_geometry and len(instance_geometry) > 1:  # More than just metadata\r\n                instance_geometry[\"category_name\"] = category_name\r\n                return instance_geometry\r\n        \r\n        # If both approaches failed\r\n        return out_data\r\n\r\n    def _get_symbol_geometry(self, symbol):\r\n        \"\"\"Extract geometry directly from a family symbol (untransformed).\"\"\"\r\n        try:\r\n            # Initialize result dictionary with geometry source metadata\r\n            geometry_by_subcategory = {\"geometry_source\": \"Symbol\"}\r\n            total_objects = 0\r\n            \r\n            # Get the symbol's geometry\r\n            geom_elem = symbol.get_Geometry(self.geom_options)\r\n            if not geom_elem:\r\n                return geometry_by_subcategory\r\n                \r\n            # Process each geometry object\r\n            for geometry_object in geom_elem:\r\n                if isinstance(geometry_object, DB.GeometryInstance):\r\n                    # Handle nested family geometry recursively\r\n                    nested_symbol = geometry_object.Symbol\r\n                    nested_geo = self._get_symbol_geometry(nested_symbol)\r\n                    for subcat_name, geo_list in nested_geo.items():\r\n                        if subcat_name == \"geometry_source\":\r\n                            continue\r\n                        if subcat_name not in geometry_by_subcategory:\r\n                            geometry_by_subcategory[subcat_name] = []\r\n                        geometry_by_subcategory[subcat_name].extend(geo_list)\r\n                        total_objects += len(geo_list)\r\n                \r\n                elif isinstance(geometry_object, DB.Solid) or hasattr(geometry_object, 'Mesh'):\r\n                    # Direct geometry objects in symbol\r\n                    subcat_name = self._get_subcategory_name(geometry_object)\r\n                    \r\n                    converted = self._convert_revit_geometry(geometry_object)\r\n                    \r\n                    if converted:\r\n                        if subcat_name not in geometry_by_subcategory:\r\n                            geometry_by_subcategory[subcat_name] = []\r\n                        geometry_by_subcategory[subcat_name].extend(converted)\r\n                        total_objects += len(converted)\r\n            # Add category_name if available from symbol\r\n            if hasattr(symbol, 'Family') and hasattr(symbol.Family, 'FamilyCategory') and symbol.Family.FamilyCategory:\r\n                geometry_by_subcategory[\"category_name\"] = symbol.Family.FamilyCategory.Name\r\n            return geometry_by_subcategory\r\n            \r\n        except Exception as e:\r\n            logger.debug(\"  Error getting symbol geometry: {}\".format(str(e)))\r\n            return {\"geometry_source\": \"Symbol\"}\r\n\r\n    def _get_instance_geometry(self, element):\r\n        \"\"\"Extract geometry from a family instance (transformed to project coordinates).\"\"\"\r\n        try:\r\n            # Initialize result dictionary with geometry source metadata\r\n            geometry_by_subcategory = {\"geometry_source\": \"Instance\"}\r\n            total_objects = 0\r\n            \r\n            # Handle linked elements with their transforms\r\n            if hasattr(element, 'link_doc'):\r\n                # Get link transform and apply it to all geometry\r\n                link_transform = element.link_transform\r\n                \r\n                # Use the link document for the element's geometry\r\n                if hasattr(element, 'get_Geometry'):\r\n                    geom_elem = element.get_Geometry(self.geom_options)\r\n                    if geom_elem:\r\n                        # Process the linked geometry with transform\r\n                        for geometry_object in geom_elem:\r\n                            if isinstance(geometry_object, DB.GeometryInstance):\r\n                                # For linked elements, transform all geometry by the link transform\r\n                                inst_geo = geometry_object.GetInstanceGeometry()\r\n                                if not inst_geo:\r\n                                    continue\r\n                                \r\n                                for g_obj in inst_geo:\r\n                                    # Get subcategory\r\n                                    subcat_name = self._get_subcategory_name(g_obj)\r\n                                    \r\n                                    # Convert to Rhino\r\n                                    converted = self._convert_revit_geometry(g_obj)\r\n                                    if converted:\r\n                                        if subcat_name not in geometry_by_subcategory:\r\n                                            geometry_by_subcategory[subcat_name] = []\r\n                                        geometry_by_subcategory[subcat_name].extend(converted)\r\n                return geometry_by_subcategory\r\n            \r\n            # Normal case - get the instance's geometry\r\n            geom_elem = element.get_Geometry(self.geom_options)\r\n            if not geom_elem:\r\n                return geometry_by_subcategory\r\n                \r\n            # Process each geometry object\r\n            for geometry_object in geom_elem:\r\n                if isinstance(geometry_object, DB.GeometryInstance):\r\n                    # Handle nested family geometry recursively\r\n                    nested_symbol = geometry_object.Symbol\r\n                    nested_geo = self._get_symbol_geometry(nested_symbol)\r\n                    for subcat_name, geo_list in nested_geo.items():\r\n                        if subcat_name == \"geometry_source\":\r\n                            continue\r\n                        if subcat_name not in geometry_by_subcategory:\r\n                            geometry_by_subcategory[subcat_name] = []\r\n                        geometry_by_subcategory[subcat_name].extend(geo_list)\r\n                        total_objects += len(geo_list)\r\n                \r\n                elif isinstance(geometry_object, DB.Solid) or hasattr(geometry_object, 'Mesh'):\r\n                    # Direct geometry objects\r\n                    subcat_name = self._get_subcategory_name(geometry_object)\r\n                    \r\n                    converted = self._convert_revit_geometry(geometry_object)\r\n                    \r\n                    if converted:\r\n                        if subcat_name not in geometry_by_subcategory:\r\n                            geometry_by_subcategory[subcat_name] = []\r\n                        geometry_by_subcategory[subcat_name].extend(converted)\r\n                        total_objects += len(converted)\r\n            # Add category_name if available from element\r\n            if hasattr(element, 'Category') and element.Category:\r\n                geometry_by_subcategory[\"category_name\"] = element.Category.Name\r\n            return geometry_by_subcategory\r\n            \r\n        except Exception as e:\r\n            logger.debug(\"  Error getting instance geometry: {}\".format(str(e)))\r\n            return {\"geometry_source\": \"Instance\"}\r\n\r\n    def _get_subcategory_name(self, g_obj):\r\n        \"\"\"Get the subcategory name for a geometry object\"\"\"\r\n        try:\r\n            if g_obj.GraphicsStyleId and self.revit_doc.GetElement(g_obj.GraphicsStyleId):\r\n                style = self.revit_doc.GetElement(g_obj.GraphicsStyleId)\r\n                if hasattr(style, \"GraphicsStyleCategory\") and style.GraphicsStyleCategory:\r\n                    return style.GraphicsStyleCategory.Name\r\n        except:\r\n            pass\r\n        \r\n        return \"UnCategorized\"\r\n\r\n    def _convert_revit_geometry(self, g_obj):\r\n        \"\"\"Convert Revit geometry to Rhino geometry.\"\"\"\r\n        results = []\r\n        \r\n        # Handle Solids - convert to Breps if volume is significant\r\n        if isinstance(g_obj, DB.Solid):\r\n            if g_obj.Volume > 1e-6:\r\n                try:\r\n                    breps = RIR_DECODER.ToBrep(g_obj)\r\n                    if breps:\r\n                        if isinstance(breps, list):\r\n                            for b in breps:\r\n                                if b:\r\n                                    results.append(b)\r\n                        else:\r\n                            results.append(breps)\r\n                except:\r\n                    pass\r\n                    \r\n        # Handle Meshes\r\n        elif hasattr(g_obj, 'Mesh'):\r\n            revit_mesh = g_obj.Mesh\r\n            if revit_mesh and revit_mesh.NumTriangles > 0:\r\n                try:\r\n                    r_mesh = self._mesh_to_rhino(revit_mesh)\r\n                    results.append(r_mesh)\r\n                except:\r\n                    pass\r\n                \r\n        return results\r\n\r\n    def _mesh_to_rhino(self, revit_mesh):\r\n        \"\"\"Convert a Revit mesh to a Rhino mesh\"\"\"\r\n        rhino_mesh = Rhino.Geometry.Mesh()\r\n        \r\n        # Add vertices\r\n        for i in range(revit_mesh.NumVertices):\r\n            rv_vertex = revit_mesh.Vertices[i]\r\n            rhino_mesh.Vertices.Add(rv_vertex.X, rv_vertex.Y, rv_vertex.Z)\r\n            \r\n        # Add triangular faces\r\n        for i in range(revit_mesh.NumTriangles):\r\n            tri = revit_mesh.get_Triangle(i)\r\n            idx0 = tri.get_VertexIndex(0)\r\n            idx1 = tri.get_VertexIndex(1)\r\n            idx2 = tri.get_VertexIndex(2)\r\n            rhino_mesh.Faces.AddFace(idx0, idx1, idx2)\r\n            \r\n        return rhino_mesh\r\n\r\n    def _get_or_create_layer(self, subC_name, family_name, category_name):\r\n        \"\"\"Get or create a layer with the given name and return its index.\r\n        \r\n        Args:\r\n            subC_name (str): The subcategory name\r\n            family_name (str): The family name\r\n            category_name (str): The category name\r\n            \r\n        Returns:\r\n            int: Layer index in the Rhino document\r\n        \"\"\"\r\n        # Create parent layers first\r\n        category_layer = self._get_or_create_parent_layer(category_name)\r\n        family_layer = self._get_or_create_parent_layer(family_name, parent_index=category_layer)\r\n        \r\n        # Create the full layer path using the new format\r\n        full_layer_path = \"{}::{}::{}\".format(category_name, family_name, subC_name)\r\n        \r\n        # Check if layer already exists\r\n        layer_index = self.rhino_doc.Layers.FindByFullPath(full_layer_path, True)\r\n        if layer_index >= 0:\r\n            return layer_index\r\n            \r\n        # Create new layer\r\n        layer = Rhino.DocObjects.Layer()\r\n        layer.Name = subC_name\r\n        layer.ParentLayerId = self.rhino_doc.Layers[family_layer].Id\r\n        \r\n        # Generate a color based only on the subcategory name\r\n        name_hash = hash(subC_name) % 1000\r\n        r = (name_hash * 13) % 256\r\n        g = (name_hash * 17) % 256\r\n        b = (name_hash * 19) % 256\r\n        layer.Color = System.Drawing.Color.FromArgb(r, g, b)\r\n        \r\n        # Add the layer to the document\r\n        return self.rhino_doc.Layers.Add(layer)\r\n\r\n    def _get_or_create_parent_layer(self, layer_name, parent_index=None):\r\n        \"\"\"Create or get a parent layer.\r\n        \r\n        Args:\r\n            layer_name (str): The layer name\r\n            parent_index (int, optional): Index of the parent layer\r\n            \r\n        Returns:\r\n            int: Layer index in the Rhino document\r\n        \"\"\"\r\n        # Check if layer already exists\r\n        if parent_index is None:\r\n            # For top level layers, search through all layers\r\n            for i in range(self.rhino_doc.Layers.Count):\r\n                layer = self.rhino_doc.Layers[i]\r\n                if layer.Name == layer_name and layer.ParentLayerId == System.Guid.Empty:\r\n                    return i\r\n        else:\r\n            # For child layers, use the full path\r\n            parent_path = self.rhino_doc.Layers[parent_index].FullPath\r\n            full_path = \"{}::{}\".format(parent_path, layer_name)\r\n            for i in range(self.rhino_doc.Layers.Count):\r\n                layer = self.rhino_doc.Layers[i]\r\n                if layer.FullPath == full_path:\r\n                    return i\r\n            \r\n        # Create new layer\r\n        layer = Rhino.DocObjects.Layer()\r\n        layer.Name = layer_name\r\n        if parent_index is not None:\r\n            layer.ParentLayerId = self.rhino_doc.Layers[parent_index].Id\r\n            \r\n        # Add the layer to the document\r\n        return self.rhino_doc.Layers.Add(layer)\r\n\r\n    def _create_block_definition(self, family_name, type_name, geometry_data):\r\n        \"\"\"Create a Rhino block definition for a family symbol.\"\"\"\r\n        # Create a block name\r\n        if type_name == \"NoType\":\r\n            block_name = \"{}\".format(family_name)\r\n        else:\r\n            block_name = \"{}_{}\".format(family_name, type_name)\r\n        \r\n        # Remove invalid characters\r\n        block_name = block_name.replace(\":\", \"_\").replace(\"/\", \"_\").replace(\"\\\\\", \"_\").replace(\" \", \"_\")\r\n        \r\n        # Collect all geometry and create layers for subcategories\r\n        all_geometry = []\r\n        all_attributes = []\r\n        \r\n        # Check if there's any actual geometry\r\n        has_geometry = False\r\n        for subcat_name, geo_list in geometry_data.items():\r\n            if subcat_name in (\"geometry_source\", \"category_name\") or not geo_list:\r\n                continue\r\n            for geo in geo_list:\r\n                if geo is None:\r\n                    continue\r\n                # Only add if geo is a geometry object\r\n                if not hasattr(geo, \"IsValid\"):  # or use isinstance(geo, Rhino.Geometry.GeometryBase)\r\n                    continue\r\n                has_geometry = True\r\n                break\r\n                \r\n        if not has_geometry:\r\n            return -1\r\n        \r\n        # Use category_name from geometry_data\r\n        category_name = geometry_data.get(\"category_name\", \"Unknown\")\r\n        \r\n        # Process each subcategory\r\n        for subcat_name, geo_list in geometry_data.items():\r\n            if subcat_name in (\"geometry_source\", \"category_name\") or not geo_list:\r\n                continue\r\n                \r\n            # Create or get layer for this subcategory using the new format\r\n            layer_index = self._get_or_create_layer(subcat_name, family_name, category_name)\r\n            \r\n            for geo in geo_list:\r\n                if geo is None:\r\n                    continue\r\n                    \r\n                # Only add if geo is a geometry object\r\n                if not hasattr(geo, \"IsValid\"):  # or use isinstance(geo, Rhino.Geometry.GeometryBase)\r\n                    continue\r\n                all_geometry.append(geo)\r\n                \r\n                # Create attributes for this object that reference the layer\r\n                attrib = Rhino.DocObjects.ObjectAttributes()\r\n                attrib.LayerIndex = layer_index\r\n                all_attributes.append(attrib)\r\n                \r\n                # Keep track of geometry by layer for statistics\r\n                if subcat_name not in self.layer_dict:\r\n                    self.layer_dict[subcat_name] = []\r\n                self.layer_dict[subcat_name].append(geo)\r\n        \r\n        # Final validation\r\n        if not all_geometry:\r\n            return -1\r\n        \r\n        # Create the block definition\r\n        base_point = Rhino.Geometry.Point3d(0, 0, 0)\r\n        \r\n        block_idx = self.rhino_doc.InstanceDefinitions.Add(\r\n            block_name,\r\n            \"Created from Revit family\",\r\n            base_point,\r\n            all_geometry,\r\n            all_attributes\r\n        )\r\n            \r\n        return block_idx\r\n\r\n    def _get_category_name(self, element):\r\n        \"\"\"\r\n        Get the category name for a Revit element, with error handling.\r\n        Args:\r\n            element: The Revit element or symbol.\r\n        Returns:\r\n            str: The category name, or 'Unknown' if not available.\r\n        \"\"\"\r\n        try:\r\n            if hasattr(element, \"Category\") and element.Category is not None:\r\n                return element.Category.Name\r\n            # For symbols, try to get from FamilyCategory\r\n            if hasattr(element, \"FamilyCategory\") and element.FamilyCategory is not None:\r\n                return element.FamilyCategory.Name\r\n            # For symbols with Family, try to get from Family.FamilyCategory\r\n            if hasattr(element, \"Family\") and hasattr(element.Family, \"FamilyCategory\") and element.Family.FamilyCategory is not None:\r\n                return element.Family.FamilyCategory.Name\r\n        except Exception as e:\r\n            logger.debug(\"Error getting category name: {}\".format(str(e)))\r\n        return \"Unknown\"\r\n\r\n    def _revit_transform_to_rhino(self, revit_transform):\r\n        \"\"\"Convert a Revit transform to a Rhino transform\"\"\"\r\n        rhino_transform = Rhino.Geometry.Transform.Identity\r\n        \r\n        # Set basis vectors\r\n        rhino_transform.M00 = revit_transform.BasisX.X\r\n        rhino_transform.M10 = revit_transform.BasisX.Y\r\n        rhino_transform.M20 = revit_transform.BasisX.Z\r\n        \r\n        rhino_transform.M01 = revit_transform.BasisY.X\r\n        rhino_transform.M11 = revit_transform.BasisY.Y\r\n        rhino_transform.M21 = revit_transform.BasisY.Z\r\n        \r\n        rhino_transform.M02 = revit_transform.BasisZ.X\r\n        rhino_transform.M12 = revit_transform.BasisZ.Y\r\n        rhino_transform.M22 = revit_transform.BasisZ.Z\r\n        \r\n        # Set origin (no unit conversion here - we'll handle that separately)\r\n        rhino_transform.M03 = revit_transform.Origin.X\r\n        rhino_transform.M13 = revit_transform.Origin.Y\r\n        rhino_transform.M23 = revit_transform.Origin.Z\r\n        \r\n        return rhino_transform\r\n\r\n    def _untransform_geometry(self, geometry_data, transform):\r\n        \"\"\"Untransform geometry extracted with GetInstanceGeometry() to get it back to symbol space.\"\"\"\r\n        # Make a copy of the input data\r\n        result = dict(geometry_data)\r\n        \r\n        try:\r\n            # If there's no geometry other than metadata, return as is\r\n            if len(geometry_data) <= 1 and \"geometry_source\" in geometry_data:\r\n                return result\r\n                \r\n            # Create the inverse transform to get back to symbol space\r\n            inverse_transform = transform.Inverse\r\n            \r\n            # Convert the inverse transform to a Rhino transform\r\n            rhino_inverse = self._revit_transform_to_rhino(inverse_transform)\r\n            \r\n            # Process each subcategory\r\n            for subcat_name, geo_list in list(result.items()):\r\n                if subcat_name == \"geometry_source\":\r\n                    continue\r\n                    \r\n                # Create a new list for the untransformed geometry\r\n                untransformed_list = []\r\n                \r\n                # Apply inverse transform to each geometry object\r\n                for geo in geo_list:\r\n                    try:\r\n                        # Create a duplicate to avoid modifying the original\r\n                        geo_copy = geo.Duplicate()\r\n                        geo_copy.Transform(rhino_inverse)\r\n                        untransformed_list.append(geo_copy)\r\n                    except:\r\n                        untransformed_list.append(geo)  # Keep original if transform fails\r\n                \r\n                # Replace the original list with the untransformed one\r\n                result[subcat_name] = untransformed_list\r\n            \r\n            # Update the geometry source in the metadata\r\n            result[\"geometry_source\"] = \"Instance_Untransformed\"\r\n            \r\n            return result\r\n        except:\r\n            return geometry_data  # Return original data if anything fails\r\n\r\n    def _place_block_instance(self, block_idx, element, geo_source):\r\n        \"\"\"Place a block instance in the Rhino document with the element's transformation.\"\"\"\r\n        # Get the element's transformation\r\n        instance_transform = self._get_element_transform_no_scale(element)\r\n        \r\n        # Create a block instance with the transformation\r\n        instance_id = self.rhino_doc.Objects.AddInstanceObject(block_idx, instance_transform)\r\n        \r\n        # Add element metadata if successful\r\n        if instance_id:\r\n            inst_obj = self.rhino_doc.Objects.FindId(instance_id)\r\n            if inst_obj:\r\n                element_id = element.Id.IntegerValue\r\n                \r\n                # Add metadata as user strings\r\n                inst_obj.Attributes.SetUserString(\"RevitElementID\", str(element_id))\r\n                family_name = self._get_family_name(element)\r\n                type_name = self._get_type_name(element)\r\n                inst_obj.Attributes.SetUserString(\"FamilyName\", family_name)\r\n                inst_obj.Attributes.SetUserString(\"TypeName\", type_name)\r\n                \r\n                # Add source document info for linked elements\r\n                if hasattr(element, 'link_doc'):\r\n                    link_name = element.link_doc.Title\r\n                    inst_obj.Attributes.SetUserString(\"LinkedModel\", link_name)\r\n                \r\n                inst_obj.CommitChanges()\r\n\r\n    def _get_element_transform_no_scale(self, element):\r\n        \"\"\"Get a Rhino transform from a Revit family instance.\"\"\"\r\n        # For linked elements, combine the link transform with the element transform\r\n        if hasattr(element, 'link_transform') and hasattr(element, 'GetTransform'):\r\n            # Get element transform in the linked document\r\n            element_transform = element.GetTransform()\r\n            # Combine with link transform\r\n            link_transform = element.link_transform\r\n            # Revit can multiply transforms directly\r\n            combined_transform = link_transform.Multiply(element_transform)\r\n            revit_transform = combined_transform\r\n        else:\r\n            # Regular case - just use the element's transform\r\n            revit_transform = element.GetTransform() if hasattr(element, 'GetTransform') else None\r\n            \r\n        if revit_transform is None:\r\n            return Rhino.Geometry.Transform.Identity\r\n          \r\n        # Create a new Rhino transform\r\n        rhTrans = Rhino.Geometry.Transform.Identity\r\n\r\n        # Copy basis vectors from Revit transform\r\n        rhTrans.M00 = revit_transform.BasisX.X\r\n        rhTrans.M10 = revit_transform.BasisX.Y\r\n        rhTrans.M20 = revit_transform.BasisX.Z\r\n        rhTrans.M30 = 0.0\r\n\r\n        rhTrans.M01 = revit_transform.BasisY.X\r\n        rhTrans.M11 = revit_transform.BasisY.Y\r\n        rhTrans.M21 = revit_transform.BasisY.Z\r\n        rhTrans.M31 = 0.0\r\n\r\n        rhTrans.M02 = revit_transform.BasisZ.X\r\n        rhTrans.M12 = revit_transform.BasisZ.Y\r\n        rhTrans.M22 = revit_transform.BasisZ.Z\r\n        rhTrans.M32 = 0.0\r\n\r\n        # Convert origin coordinates to the proper units\r\n        origin_x = REVIT_UNIT.internal_to_unit(revit_transform.Origin.X, self.revit_unit)\r\n        origin_y = REVIT_UNIT.internal_to_unit(revit_transform.Origin.Y, self.revit_unit)\r\n        origin_z = REVIT_UNIT.internal_to_unit(revit_transform.Origin.Z, self.revit_unit)\r\n        \r\n        rhTrans.M03 = origin_x\r\n        rhTrans.M13 = origin_y\r\n        rhTrans.M23 = origin_z\r\n        rhTrans.M33 = 1.0\r\n        \r\n        return rhTrans\r\n\r\n    def _write_rhino_file(self):\r\n        \"\"\"Write the Rhino document to a 3DM file and open it\"\"\"\r\n        # Configure file write options\r\n        write_option = Rhino.FileIO.FileWriteOptions()\r\n        write_option.FileVersion = 7  # Save as Rhino 7 3dm\r\n        \r\n        # Zoom extents to all objects before saving\r\n        if self.rhino_doc.Objects.Count > 0:\r\n            # Get all objects' bounding box\r\n            bbox = Rhino.Geometry.BoundingBox.Empty\r\n            for obj in self.rhino_doc.Objects:\r\n                if obj.Geometry is not None:\r\n                    bbox.Union(obj.Geometry.GetBoundingBox(True))\r\n            \r\n            # Set all active views to this bounding box\r\n            if bbox.IsValid:\r\n                # Add some padding to the bounding box (10%)\r\n                pad = bbox.Diagonal.Length * 0.1\r\n                bbox.Inflate(pad, pad, pad)\r\n                \r\n                for view in self.rhino_doc.Views:\r\n                    view.ActiveViewport.ZoomBoundingBox(bbox)\r\n                    view.Redraw()\r\n        \r\n        # Write the file and dispose the document\r\n        self.rhino_doc.Write3dmFile(self.output_file, write_option)\r\n        self.rhino_doc.Dispose()\r\n        \r\n        # Open the file\r\n        os.startfile(self.output_file) \r\n\r\n\r\nif __name__ == \"__main__\":\r\n    pass\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}