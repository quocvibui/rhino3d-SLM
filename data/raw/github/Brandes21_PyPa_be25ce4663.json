{
  "source_url": "https://github.com/Brandes21/PyPa/blob/713d1e35bd5490521eab2d0efe869fff9692e351/Packages/Topo_Tracer/src/Topo_Tracer/Topo_Tracer_2.py",
  "repo": "Brandes21/PyPa",
  "repo_stars": 1,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Packages/Topo_Tracer/src/Topo_Tracer/Topo_Tracer_2.py",
  "instruction": "Topo tracer 2",
  "code": "def main(points, principal_vectors, seed_points, seed_vectors, boundary_curves, domain_surface,\n    k, h, num_steps, step_sign,boundary_tolerance,collision_threshold, n_back, seed_dist):\n    \n    \n    # Inputs:\n    #   points             - list of Point3d or [x,y,z]\n    #   principal_vectors  - list of Vector3d or [x,y,z]\n    #   seed_points        - list of Point3d or [x,y,z]\n    #   seed_vectors       - list of Vector3d or [x,y,z]\n    #   k                  - neighbors for interpolation\n    #   num_steps          - max steps per seed\n    #   step_sign          - +1 or -1 integration direction\n    #   boundary_curves    - list of domain edge Curves\n    #   domain_surface     - Brep or Surface to derive edges if curves not provided\n    #   boundary_tolerance - stop if closer than this to boundary\n    #   collision_threshold- merge if within this of existing line\n    # Outputs:\n    #   a - GH tree of (trajectory_pts, polylineCurve) per seed\n    #   b - GH tree of bridging segment curves\n    \n\n    import math\n    import rhinoscriptsyntax as rs\n    import Rhino\n    import Rhino.Geometry as rg\n    import scriptcontext as sc\n    import numpy as np\n    from scipy.spatial import KDTree\n    from ghpythonlib import treehelpers as tr\n\n\n    # --------------------\n    # Utility functions\n    # --------------------\n    def to_xyz(o):\n        if hasattr(o, \"X\"): return [o.X, o.Y, o.Z]\n        return list(o)\n\n    def normalize_3d(v):\n        m = math.sqrt(v[0]**2+v[1]**2+v[2]**2)\n        if m<1e-12: return [0.0,0.0,0.0]\n        return [v[i]/m for i in range(3)]\n\n    def find_closest_neighbors_kd_3d(pt, tree, k):\n        d, idxs = tree.query(pt, k=k)\n        return [idxs] if isinstance(idxs,int) else list(idxs)\n\n    def interpolate_vector_3d_consistent(pt, pts3, vecs3, nbrs, ref_dir):\n        wsum=[0,0,0]; wts=[]\n        for i in nbrs:\n            vx,vy,vz=vecs3[i]\n            if ref_dir is not None and (vx*ref_dir[0]+vy*ref_dir[1]+vz*ref_dir[2])<0:\n                vx,vy,vz=-vx,-vy,-vz\n            dx=pt[0]-pts3[i][0]; dy=pt[1]-pts3[i][1]; dz=pt[2]-pts3[i][2]\n            d=math.sqrt(dx*dx+dy*dy+dz*dz)\n            w=1.0/(d+1e-6); wts.append(w)\n            wsum[0]+=vx*w; wsum[1]+=vy*w; wsum[2]+=vz*w\n        sw=sum(wts)\n        if sw<1e-12: return [0,0,0]\n        wsum=[c/sw for c in wsum]\n        nm=math.sqrt(wsum[0]**2+wsum[1]**2+wsum[2]**2)\n        return [wsum[i]/nm if nm>1e-12 else 0 for i in range(3)]\n\n    def adjust_step_size_3d(pt, nbrs, pts3, sign):\n        return h*sign\n\n    def project_onto_surface(surface, pt3d):\n        P=rg.Point3d(*pt3d)\n        if isinstance(surface, rg.Brep): face=surface.Faces[0]\n        elif isinstance(surface, rg.Surface): face=surface\n        else: return None\n        rc,u,v=face.ClosestPoint(P)\n        return [pt.X for pt in [face.PointAt(u,v)]] if rc else None\n\n    def is_on_surface(surf,pt3d,tol):\n        p=project_onto_surface(surf,pt3d)\n        if p is None: return False\n        return math.dist(p,pt3d)<tol\n\n    def get_brep_edge_curves(surf):\n        if isinstance(surf, rg.Surface):\n            surf=rg.Brep.CreateFromSurface(surf)\n            if not surf: return []\n        return [e.ToNurbsCurve() for e in surf.Edges]\n\n    def distance_to_brep_edges(pt3d,curves):\n        P=rg.Point3d(*pt3d); md=float('inf'); cp=None\n        for c in curves:\n            rc,t=c.ClosestPoint(P)\n            if rc:\n                Q=c.PointAt(t); d=Q.DistanceTo(P)\n                if d<md: md,cp=d,Q\n        return md,cp\n\n    def runge_kutta_step_3d(curr_pt,curr_dir,h,k,vecs3,pts3,sign,tree,curves,tol):\n        nbrs=find_closest_neighbors_kd_3d(curr_pt,tree,k)\n        h=adjust_step_size_3d(curr_pt,nbrs,pts3,sign)\n        k1=interpolate_vector_3d_consistent(curr_pt,pts3,vecs3,nbrs,curr_dir)\n        m1=[curr_pt[i]+0.5*h*k1[i] for i in range(3)]\n        k2=interpolate_vector_3d_consistent(m1,pts3,vecs3,find_closest_neighbors_kd_3d(m1,tree,k),k1)\n        m2=[curr_pt[i]+0.5*h*k2[i] for i in range(3)]\n        k3=interpolate_vector_3d_consistent(m2,pts3,vecs3,find_closest_neighbors_kd_3d(m2,tree,k),k2)\n        end=[curr_pt[i]+h*k3[i] for i in range(3)]\n        k4=interpolate_vector_3d_consistent(end,pts3,vecs3,find_closest_neighbors_kd_3d(end,tree,k),k3)\n        np=[curr_pt[i]+h*(k1[i]+2*k2[i]+2*k3[i]+k4[i])/6.0 for i in range(3)]\n        return np,k4\n\n    def build_polyline_curve_3d(pts):\n        return rg.PolylineCurve([rg.Point3d(*p) for p in pts])\n\n    def closest_point_on_polyline_3d(pt,curve):\n        rc,t=curve.ClosestPoint(rg.Point3d(*pt))\n        if not rc: return None,float('inf')\n        Q=curve.PointAt(t); return [Q.X,Q.Y,Q.Z],Q.DistanceTo(rg.Point3d(*pt))\n\n    def find_closest_existing_line_3d(pt,existing,thresh):\n        md=float('inf'); idx=None; cp=None\n        for i,(pts,crv) in enumerate(existing):\n            cpt,d=closest_point_on_polyline_3d(pt,crv)\n            if d<md: md,idx,cp=d,i,cpt\n        return (idx,cp,md) if md<thresh else (None,None,float('inf'))\n\n    def distance_to_seedpt(pt,seed_pts):\n        md=float('inf'); sp=None\n        P=rg.Point3d(*pt)\n        for s in seed_pts:\n            d=P.DistanceTo(s)\n            if d<md: md,sp=d,s\n        return md,sp\n\n    def get_knn_adjacency(pts3,kAdj=6):\n        arr=np.array(pts3);T=KDTree(arr);adj=[]\n        for i in range(len(pts3)):\n            d,inds=T.query(arr[i],kAdj+1)\n            adj.append([j for j in inds if j!=i])\n        return adj\n\n    def unify_vector_field(pts3,vecs3,adj):\n        vis=[False]*len(pts3);queue=[0];vis[0]=True\n        while queue:\n            i=queue.pop(0)\n            for j in adj[i]:\n                if not vis[j]:\n                    if sum(vecs3[i][c]*vecs3[j][c] for c in range(3))<0:\n                        vecs3[j]=[-c for c in vecs3[j]]\n                    vis[j]=True;queue.append(j)\n        return vecs3\n\n    # --------------------\n    # Prepare inputs\n    # --------------------\n    pts3=[to_xyz(p) for p in points]\n    vecs3=[to_xyz(v) for v in principal_vectors]\n    # global consistency\n    adj=get_knn_adjacency(pts3,k)\n    vecs3=unify_vector_field(pts3,vecs3,adj)\n    seeds=[to_xyz(s) for s in seed_points]\n    sdirs=[to_xyz(sv) for sv in seed_vectors]\n    # boundary curves from surface\n    if boundary_curves is None and domain_surface:\n        boundary_curves=get_brep_edge_curves(domain_surface)\n    # KD-tree\n    tree=KDTree(np.array(pts3))\n\n    existing_trajectories=[]\n    bridging_lines_out=[]\n\n    # --------------------\n    # Trace seeds\n    # --------------------\n    for s_pt,s_dir in zip(seeds,sdirs):\n        cur_pt=list(s_pt); cur_dir=normalize_3d(s_dir)\n        traj=[rg.Point3d(*cur_pt)]; bridge=None;nn=0\n        for _ in range(num_steps):\n            nn+=1\n            nxt,ndir=runge_kutta_step_3d(cur_pt,cur_dir,step_sign,k,vecs3,pts3,step_sign,tree,boundary_curves,boundary_tolerance)\n            if boundary_curves:\n                d_e,cp=distance_to_brep_edges(nxt,boundary_curves)\n                if d_e<boundary_tolerance:\n                    bridge=[traj[-1],cp]; break\n            idx,cp,d=find_closest_existing_line_3d(nxt,existing_trajectories,collision_threshold)\n            if idx is not None:\n                # merge back 15 steps\n                back=n_back if len(traj)>n_back else len(traj)-1\n                bridge=[traj[-back],rg.Point3d(*cp)]; traj=traj[:-back+1]; break\n            if nn>20:\n                d_s,sp=distance_to_seedpt(nxt,[rg.Point3d(*pt) for pt in seeds])\n                if d_s<seed_dist:\n                    bridge=[traj[-1],sp]; break\n            traj.append(rg.Point3d(*nxt)); cur_pt=nxt; cur_dir=ndir\n        existing_trajectories.append((traj, build_polyline_curve_3d([[pt.X,pt.Y,pt.Z] for pt in traj])))\n        if bridge: bridging_lines_out.append(bridge)\n\n    # --------------------\n    # Output\n    # --------------------\n    a=tr.list_to_tree(existing_trajectories)\n    b=tr.list_to_tree(bridging_lines_out)\n    return a,b",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}