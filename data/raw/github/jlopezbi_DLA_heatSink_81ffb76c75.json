{
  "source_url": "https://github.com/jlopezbi/DLA_heatSink/blob/f082fb5c84ff5c72b0f1797b9d6370120bdfd9ad/branchingDLA_2Dv1.py",
  "repo": "jlopezbi/DLA_heatSink",
  "repo_stars": 5,
  "repo_description": "grow coral shapes",
  "license": "unknown",
  "filepath": "branchingDLA_2Dv1.py",
  "instruction": "DLA with branch thickening",
  "code": "#DLA with branch thickening\n\nimport rhinoscriptsyntax as rs\nimport random as rand\nimport math\nimport time\nimport Rhino\nimport scriptcontext\n\nclass node:\n    def __init__(self, posVec, parentID, radius):\n        self.posVec = posVec\n        self.parentID = parentID\n        self.radius = radius\n        self.n_divisions = 10\n        self.geom = []\n\n    def dispNodeInfo(self):\n        self.geom.append(rs.AddPoint(self.posVec))\n        #nodeInfoStr = str(self.parentID) + 'r:' + str(self.radius)\n        #self.geom.append(rs.AddTextDot(nodeInfoStr,self.posVec))\n\n    def points_along_edge(self,nodes):\n        p1 = self.posVec\n        p2 = nodes[self.parentID].posVec\n        temp_line = rs.AddLine(p1,p2)\n        points = rs.DivideCurve(temp_line,self.n_divisions,create_points=True)\n        rs.DeleteObject(temp_line)\n\n    def drawEdge(self,nodes):\n        p1 = self.posVec\n        p2 = nodes[self.parentID].posVec\n        self.geom.append(rs.AddLine(p1,p2))\n\n        pNormal = rs.VectorSubtract(p2,p1)\n        height = rs.VectorLength(pNormal)\n        plane = rs.PlaneFromNormal(p1,pNormal)\n        radius = self.radius\n        self.geom.append(rs.AddCylinder(plane,height,radius))\n\n    def drawCircle(self):\n        p1 = self.posVec\n        radius = self.radius\n        self.geom.append(rs.AddCircle(p1,radius))\n\n    def clearGeom(self):\n        for o in self.geom: rs.DeleteObject(o)\n        \n    def increaseRadius(self,sFactor, nodes):\n        self.clearGeom()\n        self.radius += sFactor\n            \n        if(self.parentID >= 0):\n            #self.drawCircle()\n            #self.drawEdge(nodes)          \n            #self.points_along_edge(nodes)\n            self.dispNodeInfo()\n            parentNode = nodes[self.parentID]\n            parentNode.increaseRadius(sFactor,nodes)\n        elif(self.parentID == -1):\n            rootNode = nodes[0]\n            rootNode.radius += sFactor\n            rootNode.clearGeom()\n            rootNode.drawCircle()   \n            rootNode.dispNodeInfo()\n\n        #recursively strengthen every node from current node to root\n\n\ndef branchingDLA_MAIN():\n    #create root node\n    nodes = [node([0,0,0],-1,.1)]\n    rNodes = [rs.AddPoint(nodes[0].posVec)]\n    speed = .8 #rhino units per iteration\n    sRange = [.1,.5]\n    nThrows = 800\n    boundRadius = (sRange[0]+sRange[1])*2\n    bGeom = rs.AddCircle([0,0,0],boundRadius)\n    sFactor = .5\n\n    passParams = [boundRadius,bGeom,sFactor]\n\n    \n\n    for i in range(nThrows):\n        resizeThreshold = .7\n        #stickRange = rand.uniform(sRange[0],sRange[1])\n        stickRange = 1\n        passParams = throwNode(nodes,speed,stickRange,passParams,resizeThreshold)\n        \n\ndef throwNode(nodes,speed,stickRange,passParams,resizeThreshold):\n    boundRadius = passParams[0]\n    bGeom = passParams[1]\n    #sFactor = passParams[2]\n    #print passParams[2]\n    #assumes time steps of 1\n    startPos = getBoundaryPos(boundRadius);\n    endPos = getBoundaryPos(boundRadius);\n    \n    direction = rs.VectorSubtract(endPos,startPos)\n    direction = rs.VectorUnitize(direction)\n    vel = rs.VectorScale(direction,speed);\n\n    currentPos = rs.VectorAdd(startPos,vel)\n\n    previewGeom = []\n\n    isTravelling = True\n    while(isTravelling):\n        scriptcontext.escape_test() #hit escape to quit NOT WORKING\n        time.sleep(0.01*10**-7)\n        for o in previewGeom: rs.DeleteObjects(o)\n        dist = rs.VectorLength(currentPos) #distance to origin\n        #check if particle went out of bounds\n        if(dist>boundRadius):\n            isTravelling = False\n       \n        else:\n            previewGeom.append(drawPos(currentPos,stickRange))\n            for i in range(len(nodes)):\n                n = nodes[i]\n                if(inStickRange(currentPos,n,stickRange)):\n                    #GOT STUCK! add a new node at that position\n                    newNode = node(currentPos,i,.08) #parent is idx of node stuck too\n                    newNode.increaseRadius(.01, nodes)\n                    nodes.append(newNode)\n                    #rNodes.append(rs.AddPoint(currentPos))\n                    if(math.fabs(boundRadius-dist) <= resizeThreshold):\n                        #print \"boundRadius should resize\"\n                        rs.DeleteObjects(bGeom)\n                        boundRadius += resizeThreshold/2 #arbitrary\n                        bGeom = rs.AddCircle([0,0,0],boundRadius)\n                        passParams[0] = boundRadius\n                        passParams[1] = bGeom\n\n                    isTravelling = False\n                    for o in previewGeom: rs.DeleteObjects(o)\n                    break\n            \n            currentPos = rs.VectorAdd(currentPos,vel)\n        Rhino.RhinoApp.Wait()\n        \n    return passParams\n\ndef drawPos(currentPos,stickRange):\n    tempGeom = []\n    tempGeom.append(rs.AddPoint(currentPos))\n    tempGeom.append(rs.AddCircle(currentPos,stickRange))\n    return tempGeom\n\ndef inStickRange(currentPos,node,stickRange):\n    assert(stickRange>0), \"stickRange must be greater than zero\"\n    nodePos = node.posVec\n    distVec = rs.VectorSubtract(nodePos,currentPos)\n    distance = rs.VectorLength(distVec)\n    return (distance <= stickRange)\n\ncurrentPos = rs.VectorCreate([1,0,0],[0,0,0])\nnode1 = node([0,0,0],0,10)\nassert (inStickRange(currentPos,node1,1) == True), \"inStickRange error\"\nassert (inStickRange(currentPos,node1,1.0000001) == True), \"inStickRange error\"\nassert (inStickRange(currentPos,node1,.999999) == False), \"inStickRange error\"\n    \ndef getBoundaryPos(radius):\n    angle = rand.uniform(0,2.0*math.pi)\n    x = radius*math.cos(angle)\n    y = radius*math.sin(angle)\n    z = 0;\n    \n    pos = rs.VectorCreate([0,0,0],[x,y,z])\n    return pos\n                                    \nif __name__==\"__main__\":\n    branchingDLA_MAIN()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}