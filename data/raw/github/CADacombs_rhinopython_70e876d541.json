{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_repairWizard.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_repairWizard.py",
  "instruction": "160705-160728: Created.\r\n...\r\n200130: Now maximum edge tolerance is used for finding matching bounding boxes from split.\r\n        Added routine to remove slits from faces.\r\n        Now rebuilds edges...",
  "code": "\"\"\"\r\n160705-160728: Created.\r\n...\r\n200130: Now maximum edge tolerance is used for finding matching bounding boxes from split.\r\n        Added routine to remove slits from faces.\r\n        Now rebuilds edges of remaining brep before extracting those to be rebuilt.\r\n200202-24: Further development.\r\n200313-14: Printed feedback change.\r\n200319, 0520,21, 26, 0619, 0701,29, 1211: Import-related update.\r\n210122: Bug fixes.\r\n210426, 220118, 220315\r\n220317: Imported a function.  Import-related update.\r\n220420: Repaired for Rhino 7+ due to a RhinoCommon 7.17 script-breaking change.\r\n220914-250515: Import-related updates.\r\n\r\nTODO:\r\nContinuing replacing xBrepFace_trimToNakedEdges with other modules.\r\n\r\nAdd variable for correctEdgeTols?\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System.Diagnostics import Stopwatch\r\nfrom System.Drawing import Color\r\n\r\nimport Eto.Drawing as drawing\r\nimport Eto.Forms as forms\r\n\r\nimport spb_Brep_correctEdgeTolerances\r\nimport spb_Brep_edgeFromTrimDeviations\r\nimport spb_Brep_Faces_withShortBorderLength\r\nimport spb_Brep_Faces_Sliver\r\nimport spb_Brep_findFaces_SmallArea\r\nimport spb_Brep_findFaceByBoundingBox\r\nimport spb_Brep_invalid\r\nimport spb_Brep_Join\r\nimport spb_Brep_nakedEdgeLoop\r\nimport spb_Brep_rebuildEdges\r\nimport xBrep_splitSurfaceWithCurves\r\nimport xBrepObject\r\nimport xCurve\r\nimport xSurface\r\n\r\n\r\nstopwatch = Stopwatch() # Will just use the same instance for all tests.\r\n\r\n\r\nclass Opts:\r\n\r\n    data = (\r\n        ('sBrepSelPool', 'Selection',\r\n            ('All normal srfs/polysrfs  ', 'Selection',)),\r\n        ('bRetrim_Bad', True, 'and retrim',),\r\n        ('bFind_SlowArea', True, 'Area compute time (seconds) > ',),\r\n        ('fSeconds_forArea', 1.0, ''),\r\n        ('bCorrectETols', True, 'Correct edge tol. error > (% of absolute tol.)'),\r\n        ('fPercent_EdgeTolMismatchTol', 100.0,''),\r\n        ('bRemoveSlits', True, 'Remove single-edged slits'),\r\n        ('bRebuildEs_perETol', True, 'Rebuild edges whose deviation > '),\r\n        ('fTol_EdgeForRebuild', 1.0*sc.doc.ModelAbsoluteTolerance,''),\r\n        ('bShrinkBeforeUntrim', True, 'Shrink surfaces before trimming',),\r\n        ('bDelSmall', True, 'Delete faces < ',),\r\n        ('fTol_Small', 2.0*sc.doc.ModelAbsoluteTolerance, ''),\r\n        ('bJoin', True, 'Join breps',),\r\n        ('fTol_EdgeForJoin', 2.0*sc.doc.ModelAbsoluteTolerance, 'Tolerance  '),\r\n        ('bRetrim_GoodMonoface', False, 'Retrim good monofaces remaining after initial join'),\r\n        ('bMergeEdges', True, 'Merge all edges if solid result',),\r\n        ('bDebug', False, 'Debug mode',),\r\n    )\r\n    # TODO: Add to list?\r\n    # 'All in document' to 'sBrepSelPool'\r\n    # ('bSlitEdge', True, 'Coincident non-seam edges (slits)'),\r\n\r\n    keys = []\r\n    values = {}\r\n    sDialogTexts = {}\r\n    stickyKeys = {}\r\n\r\n    for key, value, text in data:\r\n        if key[0] == 'b':\r\n            values[key] = value\r\n            sDialogTexts[key] = text\r\n            stickyKeys[key] = '{}({})'.format(key, __file__)\r\n        elif key[0] == 's':\r\n            values[key] = value\r\n            sDialogTexts[key] = text\r\n            stickyKeys[key] = '{}({})'.format(key, __file__)\r\n        elif key[0] == 'f':\r\n            values[key] = value\r\n            sDialogTexts[key] = text\r\n            stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n        else:\r\n            print \"{} not supported.\".format(key)\r\n            continue\r\n        keys.append(key)\r\n\r\n\r\nclass RepairBrepDialog(forms.Dialog[bool]):\r\n\r\n\r\n    def __init__(self):\r\n\r\n        # Load sticky.\r\n        for key in Opts.stickyKeys:\r\n            if Opts.stickyKeys[key] in sc.sticky:\r\n                Opts.values[key] = sc.sticky[Opts.stickyKeys[key]]\r\n\r\n        # Initialize dialog box\r\n        self.Title = 'Repair Brep (Surface and/or Polysurface)'\r\n        self.Padding = drawing.Padding(10)\r\n        self.Resizable = False\r\n\r\n        self.divider = forms.Label()\r\n        #self.divider.Text = ''\r\n        self.divider.Height = 2\r\n        self.divider.BackgroundColor = drawing.Colors.Gray\r\n\r\n\r\n        self.radioButtonList = {}\r\n        self.checkBoxes = {}\r\n        self.labels = {}\r\n        self.textBoxes = {}\r\n\r\n        for key in Opts.keys:\r\n            if key[0] == 'b':\r\n                self.checkBoxes[key] = forms.CheckBox(Text=Opts.sDialogTexts[key])\r\n                self.checkBoxes[key].Checked = Opts.values[key]\r\n            elif key[0] == 's':\r\n                self.radioButtonList[key] = forms.RadioButtonList()\r\n                self.radioButtonList[key].DataStore = Opts.sDialogTexts[key]\r\n                self.radioButtonList[key].SelectedIndex = Opts.sDialogTexts[key].index(Opts.values[key])\r\n            if key[0] == 'f':\r\n                self.labels[key] = forms.Label(Text=Opts.sDialogTexts[key])\r\n                self.textBoxes[key] = forms.TextBox(Text=str(Opts.values[key]))\r\n\r\n\r\n        self.checkBoxes['bFind_SlowArea'].CheckedChanged += self.onChange_bSlowArea\r\n        self.textBoxes['fSeconds_forArea'].TextChanged += self.onChange_fSeconds_forArea\r\n        self.checkBoxes['bRebuildEs_perETol'].CheckedChanged += self.onChange_bRebuildEs_perETol\r\n        self.textBoxes['fTol_EdgeForRebuild'].TextChanged += self.onChange_fTol_EdgeForRetrim\r\n        self.checkBoxes['bDelSmall'].CheckedChanged += self.onChange_bDelSmall\r\n        self.textBoxes['fTol_Small'].TextChanged += self.onChange_fTol_Small\r\n        self.checkBoxes['bJoin'].CheckedChanged += self.onChange_bJoin\r\n        self.textBoxes['fTol_EdgeForJoin'].TextChanged += self.onChange_fTol_EdgeForJoin\r\n\r\n        self.DefaultButton = forms.Button(Text = 'OK')\r\n        self.DefaultButton.Click += self.onOkButtonClick\r\n\r\n        self.AbortButton = forms.Button(Text = 'Cancel')\r\n        self.AbortButton.Click += self.onCancelButtonClick\r\n\r\n\r\n        layout = forms.DynamicLayout()\r\n        layout.Spacing = drawing.Size(5, 5)\r\n\r\n        #layout.AddSeparateRow()\r\n        key = 'sBrepSelPool'\r\n        self.radioButtonList[key].Orientation = forms.Orientation.Horizontal\r\n        layout.AddSeparateRow(\"Process:  \", self.radioButtonList[key])\r\n        layout.AddSeparateRow(\"\")\r\n\r\n        layout.AddSeparateRow(\"Extract    \", self.checkBoxes['bRetrim_Bad'], \":\")\r\n\r\n        dummyCB = forms.CheckBox(Text=\"Invalid\")\r\n        dummyCB.Checked = True\r\n        dummyCB.Enabled = False\r\n        layout.AddSeparateRow(dummyCB)\r\n        dummyCB = forms.CheckBox(Text=\"Whose area cannot be computed\")\r\n        dummyCB.Checked = True\r\n        dummyCB.Enabled = False\r\n        layout.AddSeparateRow(dummyCB)\r\n        layout.AddSeparateRow(self.checkBoxes['bFind_SlowArea'], None,\r\n                              self.textBoxes['fSeconds_forArea'])\r\n        layout.AddSeparateRow(\"\")\r\n\r\n        layout.AddSeparateRow(\"Additional actions:\")\r\n        layout.AddSeparateRow(self.checkBoxes['bCorrectETols'], None,\r\n                              self.textBoxes['fPercent_EdgeTolMismatchTol'])\r\n        layout.AddSeparateRow(self.checkBoxes['bRemoveSlits'])\r\n        layout.AddSeparateRow(self.checkBoxes['bRebuildEs_perETol'], None,\r\n                              self.textBoxes['fTol_EdgeForRebuild'])\r\n        #layout.AddRow(self.checkBoxes['bShrinkBeforeUntrim'])\r\n        layout.AddSeparateRow(self.checkBoxes['bDelSmall'], None,\r\n                              self.textBoxes['fTol_Small'])\r\n        layout.AddSeparateRow(self.checkBoxes['bJoin'], None,\r\n                              \"Tolerance: \",\r\n                              self.textBoxes['fTol_EdgeForJoin'])\r\n        layout.AddSeparateRow(None, self.checkBoxes['bRetrim_GoodMonoface'],None)\r\n        layout.AddSeparateRow(\"\")\r\n        layout.AddSeparateRow(self.checkBoxes['bDebug'])\r\n\r\n        layout.AddSeparateRow(None, self.DefaultButton, None, self.AbortButton, None)\r\n        #layout.AddRow(self.okButton, self.cancelButton)\r\n\r\n        # Set the dialog content\r\n        self.Content = layout\r\n\r\n\r\n    def onChange_bSlowArea(self, sender, e):\r\n        self.textBoxes['fSeconds_forArea'].Enabled = self.checkBoxes['bFind_SlowArea'].Checked\r\n\r\n\r\n    def onChange_fSeconds_forArea(self, sender, e):\r\n        try:\r\n            float(self.textBoxes['fSeconds_forArea'].Text)\r\n            self.textBoxes['fSeconds_forArea'].BackgroundColor = drawing.SystemColors.ControlBackground\r\n        except:\r\n            self.textBoxes['fSeconds_forArea'].BackgroundColor = drawing.Colors.Red\r\n\r\n\r\n\r\n    def onChange_bRebuildEs_perETol(self, sender, e):\r\n        self.textBoxes['fTol_EdgeForRebuild'].Enabled = self.checkBoxes['bRebuildEs_perETol'].Checked\r\n\r\n\r\n    def onChange_fTol_EdgeForRetrim(self, sender, e):\r\n        try:\r\n            float(self.textBoxes['fTol_EdgeForRebuild'].Text)\r\n            self.textBoxes['fTol_EdgeForRebuild'].BackgroundColor = drawing.SystemColors.ControlBackground\r\n        except:\r\n            self.textBoxes['fTol_EdgeForRebuild'].BackgroundColor = drawing.Colors.Red\r\n\r\n\r\n\r\n    def onChange_bDelSmall(self, sender, e):\r\n        self.textBoxes['fTol_Small'].Enabled = self.checkBoxes['bDelSmall'].Checked\r\n\r\n\r\n    def onChange_fTol_Small(self, sender, e):\r\n        try:\r\n            float(self.textBoxes['fTol_Small'].Text)\r\n            self.textBoxes['fTol_Small'].BackgroundColor = drawing.SystemColors.ControlBackground\r\n        except:\r\n            self.textBoxes['fTol_Small'].BackgroundColor = drawing.Colors.Red\r\n\r\n\r\n    def onChange_bJoin(self, sender, e):\r\n        self.textBoxes['fTol_EdgeForJoin'].Enabled = self.checkBoxes['bJoin'].Checked\r\n\r\n\r\n    def onChange_fTol_EdgeForJoin(self, sender, e):\r\n        try:\r\n            float(self.textBoxes['fTol_EdgeForJoin'].Text)\r\n            self.textBoxes['fTol_EdgeForJoin'].BackgroundColor = drawing.SystemColors.ControlBackground\r\n        except:\r\n            self.textBoxes['fTol_EdgeForJoin'].BackgroundColor = drawing.Colors.Red\r\n\r\n\r\n    def onCancelButtonClick(self, sender, e):\r\n        self.Close(False)\r\n\r\n\r\n    def onOkButtonClick(self, sender, e):\r\n        # Save values.\r\n        for key in Opts.keys:\r\n            if key in self.checkBoxes:\r\n                Opts.values[key] = self.checkBoxes[key].Checked\r\n            elif key in self.radioButtonList:\r\n                Opts.values[key] = (\r\n                    Opts.sDialogTexts[key][self.radioButtonList[key].SelectedIndex]\r\n                )\r\n            elif key in self.textBoxes:\r\n                try:\r\n                    Opts.values[key] = float(self.textBoxes[key].Text)\r\n                except:\r\n                    print \"Invalid input for tolerance.\" \\\r\n                        \"  {} will be used instead.\".format(Opts.values[key])\r\n\r\n\r\n        # Save sticky.\r\n        for key in Opts.keys:\r\n            if key in Opts.stickyKeys:\r\n                sc.sticky[Opts.stickyKeys[key]] = Opts.values[key]\r\n\r\n        self.Close(True)\r\n\r\n\r\ndef getInput():\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select breps\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Brep\r\n    #    optD_Overlap_MinAllowed = ri.Custom.OptionDouble(\r\n    #            fOverlap_MinAllowed, True, Rhino.RhinoMath.ZeroTolerance)\r\n    #    optT_AddDots = ri.Custom.OptionToggle(bAddDot, 'No', 'Yes')\r\n    #    optI_DotSize = ri.Custom.OptionInteger(iDotHeight, True, 3)\r\n    #    optT_Extract = ri.Custom.OptionToggle(bExtract, 'No', 'Yes')\r\n    #    go.AddOptionDouble('MinimumEdgeOverlapAllowed', optD_Overlap_MinAllowed)\r\n    #    go.AddOptionToggle('AddTextDots', optT_AddDots)\r\n    #    if optT_AddDots.CurrentValue:\r\n    #        go.AddOptionInteger('TextDotHeight', optI_DotSize)\r\n    #    go.AddOptionToggle('ExtractFaces', optT_Extract)\r\n    go.EnableClearObjectsOnEntry(False)\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False\r\n    go.EnableUnselectObjectsOnExit(False)\r\n    go.SubObjectSelect = False\r\n    #    go.AcceptNumber(True, False)\r\n\r\n    while True:\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n        elif res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n\r\ndef processBrepObjects(rdBreps, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    gBreps = {} # Placed here so it can be found more easily in debugger.\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bRetrim_Bad = getOpt('bRetrim_Bad')\r\n    bFind_SlowArea = getOpt('bFind_SlowArea')\r\n    fSeconds_forArea = getOpt('fSeconds_forArea')\r\n    bCorrectETols = getOpt('bCorrectETols')\r\n    fPercent_EdgeTolMismatchTol = getOpt('fPercent_EdgeTolMismatchTol')\r\n    bRemoveSlits = getOpt('bRemoveSlits')\r\n    bRebuildEs_perETol = getOpt('bRebuildEs_perETol')\r\n    fTol_EdgeForRebuild = getOpt('fTol_EdgeForRebuild')\r\n    fTol_EdgeForJoin = getOpt('fTol_EdgeForJoin')\r\n    bShrinkBeforeUntrim = getOpt('bShrinkBeforeUntrim')\r\n    bDelSmall = getOpt('bDelSmall')\r\n    fTol_Small = getOpt('fTol_Small')\r\n    bJoin = getOpt('bJoin')\r\n    bRetrim_GoodMonoface = getOpt('bRetrim_GoodMonoface')\r\n    bMergeEdges = getOpt('bMergeEdges')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n\r\n    def coerceList(obj):\r\n        try: out = list(set(obj))\r\n        except: out = [obj]\r\n        return out\r\n\r\n\r\n    def coerceSurface(rhObj):\r\n        if isinstance(rhObj, rg.Surface):\r\n            return rhObj\r\n        elif isinstance(rhObj, rg.GeometryBase):\r\n            geom = rhObj\r\n        elif isinstance(rhObj, rd.ObjRef):\r\n            #print rhObj.GeometryComponentIndex.ComponentIndexType\r\n            geom = rhObj.Geometry()\r\n        elif isinstance(rhObj, Guid):\r\n            rdObj = sc.doc.Objects.FindId(rhObj) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhObj)\r\n            geom = rdObj.Geometry\r\n        else:\r\n            return\r\n\r\n        srf = None\r\n        if isinstance(geom, rg.BrepFace):\r\n            srf = geom.UnderlyingSurface()\r\n        elif isinstance(geom, rg.Surface):\r\n            srf = geom\r\n        elif isinstance(geom, rg.Brep):\r\n            if geom.Faces.Count == 1:\r\n                srf = geom.Faces[0].UnderlyingSurface()\r\n\r\n        return srf\r\n\r\n\r\n    def getBrepGeom(rhObj):\r\n        if isinstance(rhObj, rg.GeometryBase):\r\n            geom = rhObj\r\n            guid = None\r\n        elif isinstance(rhObj, rd.ObjRef):\r\n            geom = rhObj.Geometry()\r\n            guid = rhObj.ObjectId\r\n        elif isinstance(rhObj, Guid):\r\n            rdObj = sc.doc.Objects.FindId(rhObj) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhObj)\r\n            if rdObj is None:\r\n                print rhObj\r\n                pass\r\n            geom = rdObj.Geometry\r\n            guid = rdObj.Id\r\n        elif isinstance(rhObj, rd.BrepObject):\r\n            rdObj = rhObj\r\n            geom = rdObj.Geometry\r\n            guid = rdObj.Id\r\n        else:\r\n            return\r\n\r\n        if not isinstance(geom, rg.Brep):\r\n            print \"Not a brep: {}\".format(guid)\r\n            return\r\n\r\n        return geom\r\n\r\n\r\n    def coerceRhinoObject(rhObj):\r\n        \"\"\"\r\n        'Deleted objects cannot be found by id.'\r\n        (https://developer.rhino3d.com/api/RhinoCommon/html/M_Rhino_DocObjects_Tables_ObjectTable_FindId.htm)\r\n        \"\"\"\r\n        rdObj = None\r\n        if isinstance(rhObj, rd.RhinoObject):\r\n            rdObj = rhObj\r\n        elif isinstance(rhObj, rd.ObjRef):\r\n            rdObj = rhObj.Object()\r\n        elif isinstance(rhObj, Guid):\r\n            rdObj = sc.doc.Objects.FindId(rhObj) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhObj)\r\n        return rdObj\r\n\r\n\r\n    def coerceBrepObject(rhObj):\r\n        rdObj = coerceRhinoObject(rhObj)\r\n        if rdObj and (rdObj.ObjectType == rd.ObjectType.Brep):\r\n            return rdObj\r\n\r\n\r\n    def cleanBrepList(toClean, alsoRemove=None):\r\n        \"\"\"\r\n        Recreates list of GUIDS with dict key of toClean\r\n        without duplicates, deleted breps, breps in dict key of alsoRemove.\r\n        \"\"\"\r\n\r\n        # Remove duplicates.\r\n        gBreps[toClean] = list(set(gBreps[toClean]))\r\n\r\n        # Remove GUIDs of deleted Breps.\r\n        # None from coerceBrepObject means that the Brep was deleted.\r\n        gBreps[toClean] = [gB for gB in gBreps[toClean] if coerceBrepObject(gB) is not None]\r\n\r\n        # Remove any GUIDs found in gBreps[alsoRemove].\r\n        if alsoRemove and gBreps[alsoRemove]:\r\n            gBreps[toClean] = [gB for gB in gBreps[toClean] if gB not in gBreps[alsoRemove]]\r\n\r\n\r\n    def getGuidsToProcess(rdBreps):\r\n        gBs = []\r\n        len_rhBs0 = len(rdBreps)\r\n        idxs_AtTenths = [int(round(0.1*i*len_rhBs0,0)) for i in range(10)]\r\n\r\n        for iB, rdObj_Brep in enumerate(rdBreps):\r\n            if sc.escape_test(False):\r\n                print \"Searching interrupted by user.\"\r\n                return\r\n\r\n            if len_rhBs0 > 10:\r\n               if iB in idxs_AtTenths:\r\n                    Rhino.RhinoApp.SetCommandPrompt(\r\n                        \"Processed {:d}% of {} breps ...\".format(\r\n                            int(100.0 * (iB+1) / len_rhBs0), len_rhBs0))\r\n            elif len_rhBs0 > 1:\r\n                Rhino.RhinoApp.SetCommandPrompt(\r\n                    \"Processing {} of {} breps ...\".format(\r\n                        iB+1, len_rhBs0))\r\n            else:\r\n                Rhino.RhinoApp.SetCommandPrompt(\"Processing single brep ...\")\r\n\r\n            rdBrep0 = coerceBrepObject(rdObj_Brep)\r\n            if not rdBrep0:\r\n                print \"Non-brep DocObject passed to processBrepObjects.\"\r\n                continue\r\n\r\n            gBs.append(rdBrep0.Id)\r\n\r\n        return gBs\r\n\r\n\r\n    def colorRed(gObjs):\r\n        gObjs = coerceList(gObjs)\r\n        for gObj in gObjs:\r\n            rdObj = coerceRhinoObject(gObj)\r\n            attr = rdObj.Attributes\r\n            attr.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n            attr.ObjectColor = Color.Red\r\n            rdObj.CommitChanges()\r\n\r\n\r\n    def formatDistance(fDistance):\r\n        if fDistance is None: return \"(No deviation provided)\"\r\n        if fDistance < 0.001:\r\n            return \"{:.2e}\".format(fDistance)\r\n        else:\r\n            return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\n    def removeMicroEdges(searchUs):\r\n        sc.escape_test()\r\n        if bEchoCmdPrompt:\r\n            sCmdPrompt0 = \"Removing micro edges ...\"\r\n            Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n        sc.doc.Views.RedrawEnabled = False\r\n        for gBrep in gBreps[searchUs] if isinstance(searchUs, str) else searchUs:\r\n            sc.doc.Objects.Select(gBrep)\r\n        Rhino.RhinoApp.RunScript(\"_NoEcho _RemoveAllNakedMicroEdges _Echo\", echo=False)\r\n        sc.doc.Objects.UnselectAll()\r\n        sc.doc.Views.RedrawEnabled = True\r\n        if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n\r\n\r\n    def extractInvalidFaces(keySearchUs, keyExtracted):\r\n\r\n        if bEchoCmdPrompt:\r\n            sCmdPrompt0 = \"Searching for invalid faces ...\"\r\n            Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        sc.escape_test()\r\n\r\n        if keyExtracted not in gBreps: gBreps[keyExtracted] = []\r\n\r\n        rc = spb_Brep_invalid.extractBadFaces(\r\n            gBreps[keySearchUs],\r\n            bEcho=bDebug,\r\n            bDebug=bDebug)\r\n\r\n        if not rc:\r\n            if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n            return\r\n\r\n        gBs_Bad, gBs_Good = rc\r\n\r\n        # In case a micro edge is the problem.\r\n        for gBrep in gBs_Bad:\r\n            removeMicroEdges(gBs_Bad)\r\n            for i in reversed(range(len(gBs_Bad))):\r\n                if spb_Brep_invalid.isValid(gBs_Bad[i]):\r\n                    gBs_Good.append(gBs_Bad[i])\r\n                    del gBs_Bad[i]\r\n                    print \"MicroEdge(s) found\" \\\r\n                        \" after extracting invalid faces.\" \\\r\n                        \"  Moved Good brep from Bad list to Good.\"\r\n                    if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        if bDebug:\r\n            print \"extractInvalidFaces:\" \\\r\n                  \" len(extracted) len(remaining): {}, {}\".format(\r\n                      len(gBs_Bad), len(gBs_Good))\r\n            if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n        if len(gBs_Bad) or bDebug:\r\n            print \"{} invalid faces found in {} {} breps.\".format(\r\n                len(gBs_Bad), len(gBreps[keySearchUs]), keySearchUs)\r\n            if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        if gBs_Bad:\r\n            gBreps[keyExtracted].extend(gBs_Bad)\r\n            gBreps[keySearchUs].extend(gBs_Good)\r\n            cleanBrepList(keyExtracted)\r\n            cleanBrepList(keySearchUs, keyExtracted)\r\n\r\n        if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n\r\n\r\n    def correctEdgeTols(keySearchUs):\r\n\r\n        if bEchoCmdPrompt:\r\n            sCmdPrompt0 = \"Searching for edges\" \\\r\n                \" whose tolerances don't match their actual edge deviations ...\"\r\n            Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        sc.escape_test()\r\n\r\n        iCt_Removed = 0\r\n\r\n        gCorrected = spb_Brep_correctEdgeTolerances.processBrepObjects(\r\n            gBreps[keySearchUs],\r\n            fPercentOfMAT=fPercent_EdgeTolMismatchTol,\r\n            bAddDot=False,\r\n            bEcho=False,\r\n            bDebug=bDebug,\r\n            )\r\n\r\n        if len(gCorrected) or bDebug:\r\n            s  = \"{} out of {} {} breps\".format(\r\n                len(gCorrected), len(gBreps[keySearchUs]), keySearchUs)\r\n            s += \" had some edge tolerances that were corrected.\"\r\n            print s\r\n            if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n\r\n\r\n    def removeSlitsFromFaces(keySearchUs):\r\n\r\n        if bEchoCmdPrompt:\r\n            sCmdPrompt0 = \"Searching for faces containing slit trims ...\"\r\n            Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        sc.escape_test()\r\n\r\n        iCt_Removed = 0\r\n\r\n        for gB in gBreps[keySearchUs]:\r\n            rgB = getBrepGeom(gB)\r\n\r\n            if rgB.Faces.RemoveSlits():\r\n                xBrepObject.replaceGeometry(gB, rgB)\r\n                iCt_Removed += 1\r\n\r\n            rgB.Dispose()\r\n\r\n        if iCt_Removed or bDebug:\r\n            print \"{} out of {} {} breps had slit trims removed.\".format(\r\n                iCt_Removed, len(gBreps[keySearchUs]), keySearchUs)\r\n            if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n\r\n\r\n    def extractFacesWithEdgeFromTrimTolError(keySearchUs, keyExtracted):\r\n\r\n        if bEchoCmdPrompt:\r\n            sCmdPrompt0 = \"Searching for faces with any \" \\\r\n                \"actual edge deviations not\" \\\r\n                \" matching BrepEdge.Tolerance values ...\"\r\n            Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        sc.escape_test()\r\n\r\n        if keyExtracted not in gBreps: gBreps[keyExtracted] = []\r\n\r\n        gBs_1Fs_Found = []\r\n        gBs_Remaining_Good = []\r\n        iCt_BrepsFound = 0\r\n\r\n        for gB in gBreps[keySearchUs]:\r\n            rgB = getBrepGeom(gB)\r\n            rgB.Compact()\r\n\r\n            devs = spb_Brep_edgeFromTrimDeviations.getDeviations(rgB)\r\n\r\n            idx_Fs_Found = []\r\n\r\n            for iE in range(rgB.Edges.Count):\r\n                if devs[iE] is None:\r\n                    # TODO: Better handling of None?\r\n                    idx_Fs_Found.extend(rgB.Edges[iE].AdjacentFaces())\r\n                elif (\r\n                    devs[iE] <= (0.01*fPercent_EdgeTolMismatchTol) * sc.doc.ModelAbsoluteTolerance and\r\n                    rgB.Edges[iE].Tolerance <= (0.01*fPercent_EdgeTolMismatchTol) * sc.doc.ModelAbsoluteTolerance\r\n                ):\r\n                    pass\r\n                elif (\r\n                    abs(devs[iE] - rgB.Edges[iE].Tolerance) >\r\n                    (0.01*fPercent_EdgeTolMismatchTol) * sc.doc.ModelAbsoluteTolerance\r\n                ):\r\n                    idx_Fs_Found.extend(rgB.Edges[iE].AdjacentFaces())\r\n\r\n            if not idx_Fs_Found:\r\n                rgB.Dispose()\r\n                continue\r\n\r\n            iCt_BrepsFound += 1\r\n\r\n            idx_Fs_Found = sorted(set(idx_Fs_Found))\r\n\r\n            rc = xBrepObject.extractFaces(\r\n                gB,\r\n                idx_Fs_Found,\r\n                bAddOnlyMonofaces=True,\r\n                bRetainLayer=True,\r\n                bRetainColor=True,\r\n                bEcho=False\r\n            )\r\n            if not rc:\r\n                rgB.Dispose()\r\n                continue\r\n\r\n            gBs_Bad_Extracted, gBs_Good_Remaining = rc\r\n\r\n            gBs_1Fs_Found.extend(gBs_Bad_Extracted)\r\n            gBs_Remaining_Good.extend(gBs_Good_Remaining)\r\n\r\n            rgB.Dispose()\r\n\r\n\r\n        if len(gBs_1Fs_Found) or bDebug:\r\n            s  = \"{} faces extracted in {} {} breps\".format(\r\n                len(gBs_1Fs_Found), iCt_BrepsFound, keySearchUs)\r\n            s += \" with at least one edge tolerance over\"\r\n            s += \" {:.1f}% of tolerance per BrepEdge.\".format(\r\n                fPercent_EdgeTolMismatchTol)\r\n            print s\r\n            if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        if gBs_1Fs_Found:\r\n            gBreps[keyExtracted].extend(gBs_1Fs_Found)\r\n            cleanBrepList(keyExtracted)\r\n            gBreps[keySearchUs].extend(gBs_Remaining_Good)\r\n            cleanBrepList(keySearchUs, keyExtracted)\r\n\r\n        if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n\r\n\r\n    def retrimFaceSrfsWithExistingEdges(keyRetrimUs):\r\n\r\n        if bEchoCmdPrompt:\r\n            sCmdPrompt0 = \"Retrimming face underlying surfaces with existing edges ...\"\r\n            Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        sc.escape_test()\r\n\r\n\r\n        iCt_Replaced = 0\r\n\r\n        gs_SingleBrepReturn = []\r\n        gs_MultiBrepReturn = []\r\n\r\n        for gB in gBreps[keyRetrimUs]:\r\n            NEs = rs.coercebrep(gB).DuplicateNakedEdgeCurves(True, True) # nakedOuter, nakedInner\r\n            rc = xBrep_splitSurfaceWithCurves.processBrepObjects(\r\n                [gB],\r\n                NEs,\r\n                bSplitUnderlyingSrf=False,\r\n                bOnlyUseCrvsOnSrf=False,\r\n                bSplitToCrvSegs=True,\r\n                fTolerance=sc.doc.ModelAbsoluteTolerance,\r\n                bTryOtherTolsOnFail=True,\r\n                bExplode=False,\r\n                bExtract=False,\r\n                bEcho=bDebug,\r\n                bDebug=bDebug)\r\n            if not rc: continue\r\n            gB_Split = rc[0]\r\n\r\n            rc = spb_Brep_findFaceByBoundingBox.processBrepObject(\r\n                gB_Split,\r\n                NEs,\r\n                fTolerance=sc.doc.ModelAbsoluteTolerance,\r\n                bDelOtherFacesNotExtract=True,\r\n                bEcho=bDebug,\r\n                bDebug=bDebug)\r\n            if not rc: continue\r\n\r\n            iCt_Replaced += 1\r\n\r\n            if isinstance(rc, Guid):\r\n                gs_SingleBrepReturn.append(rc)\r\n            elif isinstance(rc, list):\r\n                if len(rc) > 1:\r\n                    gs_MultiBrepReturn.extend(rc)\r\n\r\n\r\n            #rc = xBrepFace_trimToNakedEdges.processObjectsWithSrfs(\r\n            #    gB,\r\n            #    rhBreps_UseNakedEdges=NEs,\r\n            #    bSplitFullSurface=True,\r\n            #    fSplitTol=sc.doc.ModelAbsoluteTolerance,\r\n            #    bExtractModifiedFace=False,\r\n            #    bDelTrimmingBrep=False,\r\n            #    bEcho=bDebug,\r\n            #    bDebug=bDebug)\r\n            #if not rc: continue\r\n\r\n            #iCt_Replaced += 1\r\n\r\n            #if len(rc) > 1:\r\n            #    gs_MultiBrepReturn.extend(rc)\r\n\r\n        if gs_SingleBrepReturn:\r\n            gBreps[keyRetrimUs].extend(gs_SingleBrepReturn)\r\n        if gs_MultiBrepReturn:\r\n            gBreps[keyRetrimUs].extend(gs_MultiBrepReturn)\r\n\r\n        cleanBrepList(keyRetrimUs)\r\n\r\n        if iCt_Replaced or bDebug:\r\n            s  = \"{} monofaces replaced\".format(iCt_Replaced)\r\n            s += \" in {} breps\".format(keyRetrimUs)\r\n            print s\r\n            if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n\r\n\r\n    def rebuildFacesWithLargeEdgeTol(keySearchUs):\r\n\r\n        if bEchoCmdPrompt:\r\n            sCmdPrompt0 = \"Rebuilding faces with large edge tolerances ...\"\r\n            Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        sc.escape_test()\r\n\r\n\r\n        rc = spb_Brep_rebuildEdges.processBrepObjects(\r\n            gBreps[keySearchUs],\r\n            fRebuildNakedTol=fTol_EdgeForRebuild,\r\n            bEcho=bDebug if len(gBreps[keySearchUs]) <= 10 else False,\r\n            bDebug=bDebug,\r\n            )\r\n\r\n        if len(rc) or bDebug:\r\n            print \"{} out of {} {} breps had their edges rebuilt.\".format(\r\n                len(rc), len(gBreps[keySearchUs]), keySearchUs)\r\n            if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n\r\n\r\n    def extractBadAreaFaces(keySearchUs, keyExtracted):\r\n\r\n        if bEchoCmdPrompt:\r\n            sCmdPrompt0 = \"Searching for bad-area faces ...\"\r\n            Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        sc.escape_test()\r\n\r\n\r\n\r\n        def findBadAreaFaces(rgBrep, fTime_MaxTol, bDebug=False):\r\n            # Check whether brep is invalid.\r\n            #    if not rgBrep.IsValid:\r\n            #        print \"Brep is invalid and will be skipped.  \" \\\r\n            #                \"_ExtractBadSrf and repair the bad faces first.\"\r\n            #        if bDebug: sPrint = 'rgBrep.IsValid'; print sPrint + ':', eval(sPrint)\r\n            #        return [], []\r\n\r\n            idxFs_No = []\r\n            idxFs_Slow = []\r\n\r\n            for iF in range(rgBrep.Faces.Count):\r\n                rgBrep_1Face = rgBrep.Faces[iF].DuplicateFace(False)\r\n\r\n                stopwatch.Restart()\r\n\r\n                area = rgBrep_1Face.GetArea()\r\n\r\n                stopwatch.Stop()\r\n                timeElapsed = stopwatch.Elapsed.TotalSeconds\r\n\r\n                if area == 0: # Not None, for no area compute.\r\n                    idxFs_No.append(iF)\r\n                elif fTime_MaxTol and timeElapsed > fTime_MaxTol:\r\n                    idxFs_Slow.append(iF)\r\n\r\n                rgBrep_1Face.Dispose()\r\n\r\n            return idxFs_No + idxFs_Slow\r\n\r\n\r\n\r\n        gBs_Bad = []\r\n        gBs_Good = []\r\n\r\n        for gBrep in gBreps[keySearchUs]:\r\n            rgBrep = getBrepGeom(gBrep)\r\n            rgBrep.Compact()\r\n\r\n            rc = findBadAreaFaces(\r\n                    rgBrep=rgBrep,\r\n                    fTime_MaxTol=fSeconds_forArea if bFind_SlowArea else None,\r\n            )\r\n            rgBrep.Dispose()\r\n            if not rc: continue\r\n            idx_Faces = rc\r\n\r\n            rc = xBrepObject.extractFaces(\r\n                gBrep,\r\n                idx_Faces,\r\n                bAddOnlyMonofaces=True,\r\n                bRetainLayer=True,\r\n                bRetainColor=True,\r\n                bEcho=False\r\n            )\r\n            if not rc: continue\r\n\r\n            gBs_Bad, gBs_Good = rc\r\n\r\n            # In case a micro edge is the problem.\r\n            removeMicroEdges(gBs_Bad)\r\n\r\n            if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n            for i in reversed(range(len(gBs_Bad))):\r\n                rgBrep = getBrepGeom(gBs_Bad[i])\r\n                findBadAreaFaces(\r\n                    rgBrep=rgBrep,\r\n                    fTime_MaxTol=fSeconds_forArea if bFind_SlowArea else None,\r\n                )\r\n                rgBrep.Dispose()\r\n                if not rc:\r\n                    gBs_Good.append(gBs_Bad[i])\r\n                    del gBs_Bad[i]\r\n                    print \"Moved Good brep from Bad list to Good.\"\r\n                    if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        if len(gBs_Bad) or bDebug:\r\n            print \"{} bad area faces (that are otherwise valid) found in {} {} breps.\".format(\r\n                len(gBs_Bad), len(gBreps[keySearchUs]), keySearchUs)\r\n            if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        if gBs_Bad:\r\n            gBreps[keyExtracted].extend(gBs_Bad)\r\n            cleanBrepList(keyExtracted)\r\n            gBreps[keySearchUs].extend(gBs_Good)\r\n            cleanBrepList(keySearchUs, keyExtracted)\r\n\r\n        if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n\r\n\r\n    def deleteShortBorderFaces(keySearchUs):\r\n        if bEchoCmdPrompt:\r\n            sCmdPrompt0 = \"Searching for short-border faces ...\"\r\n            Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        sc.escape_test()\r\n\r\n        rc = spb_Brep_Faces_withShortBorderLength.processBrepObjects(\r\n                gBreps[keySearchUs],\r\n                fMaxLength=2.01*fTol_Small,\r\n                bExtract=True,\r\n                bEcho=False,\r\n                bDebug=False)\r\n        if not rc:\r\n            print \"spb_Brep_Faces_withShortBorderLength returned None.\"\r\n            if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n            return []\r\n\r\n        gBs_Short, gBs_RemainingFromExtract = rc\r\n\r\n        iCt_Deleted = 0\r\n\r\n        for gB in gBs_Short:\r\n            bSuccess = sc.doc.Objects.Delete(objectId=gB, quiet=False)\r\n            if bSuccess: iCt_Deleted += 1\r\n\r\n        if iCt_Deleted or bDebug:\r\n            print \"{} short border faces deleted in {} {} breps.\".format(\r\n                iCt_Deleted, len(gBreps[keySearchUs]), keySearchUs)\r\n            if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        # Why?\r\n        #gBs_RemainingFromExtract = [gB for gBs in gBs_RemainingFromExtract for gB in gBs]\r\n\r\n        if iCt_Deleted:\r\n            if gBs_RemainingFromExtract:\r\n                gBreps[keySearchUs].extend(gBs_RemainingFromExtract)\r\n\r\n            cleanBrepList(keySearchUs)\r\n\r\n        if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n\r\n\r\n    def deleteSliverFaces(keySearchUs):\r\n        if bEchoCmdPrompt:\r\n            sCmdPrompt0 = \"Searching for sliver faces ...\"\r\n            Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        sc.escape_test()\r\n\r\n        iCt_Deleted = 0\r\n        gBs_RemainingFromExtract = []\r\n\r\n        for gBrep in gBreps[keySearchUs]:\r\n            rgBrep = getBrepGeom(gBrep)\r\n            rc = spb_Brep_Faces_Sliver.getFaces(\r\n                rgBrep,\r\n                fMaxSliverWidth=fTol_Small,\r\n                bSkipFacesWithShortEdges=False,\r\n                bSkipSliverCheckOfShortEdges=True,\r\n                fMaxShortEdgeLength=fTol_EdgeForJoin,\r\n                bEntireFaceMustBeASliver=True\r\n                )\r\n            iCt_Faces = rgBrep.Faces.Count\r\n            rgBrep.Dispose()\r\n            idx_rgFaces_Found = rc[0]\r\n            if not idx_rgFaces_Found: continue\r\n            rc = xBrepObject.removeFaces(gBrep, idx_rgFaces_Found)\r\n            if rc is None:\r\n                print \"{} sliver faces could not be deleted.\".format(len(idx_rgFaces_Found))\r\n                if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n            else:\r\n                iCt_Deleted += len(idx_rgFaces_Found)\r\n                gBs_RemainingFromExtract.extend(rc)\r\n\r\n        if iCt_Deleted or bDebug:\r\n            print \"{} sliver faces deleted in {} {} breps.\".format(\r\n                iCt_Deleted, len(gBreps[keySearchUs]), keySearchUs)\r\n            if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        if iCt_Deleted:\r\n            if gBs_RemainingFromExtract:\r\n                gBreps[keySearchUs].extend(gBs_RemainingFromExtract)\r\n\r\n            cleanBrepList(keySearchUs)\r\n\r\n        if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n\r\n\r\n    def deleteSmallAreaFaces(keySearchUs):\r\n\r\n        if bEchoCmdPrompt:\r\n            sCmdPrompt0 = \"Searching for small area faces ...\"\r\n            Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        sc.escape_test()\r\n\r\n        iCt_Deleted = 0\r\n        gBs_RemainingFromExtract = []\r\n\r\n        for gBrep in gBreps[keySearchUs]:\r\n            rgBrep = getBrepGeom(gBrep)\r\n            rc = spb_Brep_findFaces_SmallArea.getFaces(\r\n                rgBrep,\r\n                fAreaMinTol=(1.01*fTol_Small)**2.0,\r\n                bEcho=False,\r\n                bDebug=False)\r\n            iCt_Faces = rgBrep.Faces.Count\r\n            rgBrep.Dispose()\r\n            idx_rgFaces_Found = rc[0]\r\n            if not idx_rgFaces_Found: continue\r\n            rc = xBrepObject.removeFaces(gBrep, idx_rgFaces_Found)\r\n            if rc is None:\r\n                print \"{} small area faces could not be deleted.\".format(len(idx_rgFaces_Found))\r\n                if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n            else:\r\n                iCt_Deleted += len(idx_rgFaces_Found)\r\n                gBs_RemainingFromExtract.extend(rc)\r\n\r\n        if iCt_Deleted or bDebug:\r\n            print \"{} small area faces deleted in {} {} breps.\".format(\r\n                iCt_Deleted, len(gBreps[keySearchUs]), keySearchUs)\r\n            if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        if iCt_Deleted:\r\n            if gBs_RemainingFromExtract:\r\n                gBreps[keySearchUs].extend(gBs_RemainingFromExtract)\r\n\r\n            cleanBrepList(keySearchUs)\r\n\r\n        if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n\r\n\r\n    def joinBrepNakedEdges(keySearchUs):\r\n        if bEchoCmdPrompt:\r\n            sCmdPrompt0 = \"Joining naked edges of breps ...\"\r\n            Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        sc.escape_test()\r\n\r\n        gBs_Remaining = []\r\n\r\n        iCt_Joined_Total = 0\r\n\r\n        for gBrep in gBreps[keySearchUs]:\r\n            rgBrep = getBrepGeom(gBrep)\r\n            if rgBrep.Faces.Count == 1:\r\n                rgBrep.Dispose()\r\n                continue\r\n            iCt_EdgesJoined = rgBrep.JoinNakedEdges(fTol_EdgeForJoin)\r\n\r\n            if not rgBrep.IsValid:\r\n                print \"  Joining naked edges of brep resulted in an invalid brep.\"\r\n                if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n                rgBrep.Dispose()\r\n                continue\r\n\r\n            if not iCt_EdgesJoined:\r\n                rgBrep.Dispose()\r\n                continue\r\n\r\n            iCt_Joined_Total += iCt_EdgesJoined\r\n\r\n            rc = xBrepObject.replaceGeometry(gBrep, rgBrep)\r\n            if rc is None:\r\n                print \"  Brep object's geometry could not be replaced.\".format(len(idx_rgFaces_Found))\r\n                if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n            rgBrep.Dispose()\r\n\r\n        if iCt_Joined_Total or bDebug:\r\n            print \"{} edge pairs joined in {} {} breps.\".format(\r\n                iCt_Joined_Total, len(gBreps[keySearchUs]), keySearchUs)\r\n\r\n        if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n\r\n\r\n    def filterPerSolidState(keySearchUs, keySolids, keyNotSolids=None):\r\n        for gB in gBreps[keySearchUs]:\r\n            rgB = getBrepGeom(gB)\r\n            if rgB.IsSolid:\r\n                gBreps[keySolids].append(gB)\r\n            else:\r\n                if keyNotSolids is not None: gBreps[keyNotSolids].append(gB)\r\n            rgB.Dispose()\r\n        cleanBrepList(keySearchUs, keySolids)\r\n        if keyNotSolids: cleanBrepList(keySearchUs, keyNotSolids)\r\n\r\n\r\n    def joinBreps(keysJoinUs, keySolids, keyNotSolids):\r\n\r\n        if bEchoCmdPrompt:\r\n            sCmdPrompt0 = \"Joining breps ...\"\r\n            Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        sc.escape_test()\r\n\r\n\r\n        if isinstance(keysJoinUs, str):\r\n            gBs = gBreps[keysJoinUs]\r\n            keysJoinUs = [keysJoinUs]\r\n        else:\r\n            gBs = []\r\n            for key in keysJoinUs:\r\n                gBs.extend(gBreps[key])\r\n\r\n\r\n        iCt_Joined = 0\r\n        rc = spb_Brep_Join.joinBrepObjects(\r\n            gBreps0=gBs,\r\n            fJoinTol=fTol_EdgeForJoin,\r\n            bByLayer=True,\r\n            bByColor=True,\r\n            bUseUiJoinCmd=False,\r\n            bEcho=False,\r\n            bDebug=False\r\n        )\r\n        # TODO: Add return GUIDs for bUseUiJoinCmd==True version of spb_Brep_Join.joinBrepObjects.\r\n        #if not rc:\r\n        #    # In case bUseUiJoinCmd == True can better handle the join.:\r\n        #        rc = spb_Brep_Join.joinBrepObjects(\r\n        #            gBreps0=gBs,\r\n        #            fJoinTol=fTol_EdgeForJoin,\r\n        #            bByLayer=True,\r\n        #            bByColor=True,\r\n        #            bUseUiJoinCmd=True,\r\n        #            bEcho=False,\r\n        #            bDebug=False\r\n        #        )\r\n\r\n        print \"{} breps resulted from join of {} {} breps.\".format(\r\n            len(rc), len(gBs), ' and '.join(keysJoinUs))\r\n        if not rc:\r\n            if bDebug: print \"No breps were joined.\"\r\n            if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n            return\r\n\r\n        if bDebug: print \"len(Output of joinBreps): {}\".format(len(rc))\r\n\r\n        gBreps['newly-joined'] = rc\r\n\r\n        for key in keysJoinUs:\r\n            cleanBrepList(key, 'newly-joined')\r\n\r\n        filterPerSolidState('newly-joined', keySolids, keyNotSolids)\r\n\r\n        for key in keysJoinUs:\r\n            if key == keyNotSolids: continue\r\n            gBreps[keyNotSolids].extend(gBreps[key])\r\n            gBreps[key] = []\r\n\r\n        if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n\r\n\r\n    def separateMonofaces(keysSearchUs, keyExtracted):\r\n        \"\"\"\r\n        Returns list of GUIDs of monoface breps.\r\n        \"\"\"\r\n\r\n        if bEchoCmdPrompt:\r\n            sCmdPrompt0 = \"Searching for monoface breps ...\"\r\n            Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        sc.escape_test()\r\n\r\n\r\n        if isinstance(keysSearchUs, str):\r\n            gBs = gBreps[keysSearchUs]\r\n            keysSearchUs = [keysSearchUs]\r\n        else:\r\n            gBs = []\r\n            for key in keysSearchUs:\r\n                gBs.extend(gBreps[key])\r\n\r\n\r\n        gBs_Mono_Out = []\r\n        iCt_Fs_All = 0\r\n\r\n        for gBrep in gBs:\r\n            rgBrep = getBrepGeom(gBrep)\r\n            rgBrep.Compact()\r\n\r\n            if rgBrep.Faces.Count == 1:\r\n                gBs_Mono_Out.append(gBrep)\r\n                iCt_Fs_All += 1\r\n            else:\r\n                iCt_Fs_All += rgBrep.Faces.Count\r\n\r\n            rgBrep.Dispose()\r\n\r\n        if not gBs_Mono_Out:\r\n            if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n            return\r\n        else:\r\n            s = \"{} out of {} {} breps are monoface.\".format(\r\n                len(gBs_Mono_Out), len(gBs), ' and '.join(keysSearchUs))\r\n            #            if len(gBs_Mono_Out) == 1 and len(gBs) > 1:\r\n            #                pass\r\n            #            elif len(gBs_Mono_Out) > 100 and len(gBs_Mono_Out) >= 0.1 * float(iCt_Fs_All):\r\n            #                if bDebug:\r\n            #                    print \"  Since this is {}% of all faces,\" \\\r\n            #                        \" they will not be retrimmed ONLY due to being monofaces\" \\\r\n            #                        \"  during this call to separateMonofaces.\".format(\r\n            #                            100.0 * float(len(gBs_Mono_Out)) / float(iCt_Fs_All))\r\n            #                print s + \"  They will not be retrimmed at this time.\"\r\n            #                return\r\n            print s\r\n\r\n        gBreps[keyExtracted].extend(gBs_Mono_Out)\r\n\r\n        cleanBrepList(keyExtracted)\r\n\r\n        for key in keysSearchUs:\r\n            cleanBrepList(key, keyExtracted)\r\n\r\n        if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n\r\n\r\n    def shrinkFaces(keyShrinkUs):\r\n        gBs_Shrunk = []\r\n        for gBrep in gBreps[keyShrinkUs]:\r\n            sc.escape_test()\r\n            rdBrep = coerceBrepObject(gBrep)\r\n            rgBrep = rdBrep.Geometry\r\n            rgBrep.Compact()\r\n            if rgBrep.Faces.ShrinkFaces():\r\n                if sc.doc.Objects.Replace(objectId=gBrep, brep=rgBrep):\r\n                    gBs_Shrunk.append(gBrep)\r\n            rgBrep.Dispose()\r\n        print \"  {} faces were shrunk.\".format(len(gBs_Shrunk))\r\n\r\n\r\n    def untrimFaces(keyUntrimUs, keyUntrimmed):\r\n\r\n        if bEchoCmdPrompt:\r\n            sCmdPrompt0 = \"Untrimming monoface breps ...\"\r\n            Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        sc.escape_test()\r\n\r\n        gBreps_Out = []\r\n\r\n        for gB in gBreps[keyUntrimUs]:\r\n            rdBrep = coerceBrepObject(gB)\r\n            rgBrep = rdBrep.Geometry\r\n            rgBrep.Compact()\r\n            bFail = False\r\n            for rgSrf in rgBrep.Surfaces:\r\n                brep = rgSrf.ToBrep()\r\n                gBrep1 = sc.doc.Objects.AddBrep(brep, attributes=rdBrep.Attributes)\r\n                if gBrep1 != Guid.Empty:\r\n                    gBreps_Out.append(gBrep1)\r\n                else:\r\n                    print \"Untrimmed Brep could not be added for {}.\" \\\r\n                        \"  Check this.\".format(gB)\r\n            if not bFail:\r\n                sc.doc.Objects.Delete(objectId=gB, quiet=False)\r\n            rgBrep.Dispose()\r\n        if bDebug: print \"len(Output of untrimFaces): {}\".format(len(gBreps_Out))\r\n        print \"{} faces of {} {} breps were untrimmed.\".format(\r\n            len(gBreps_Out), len(gBreps[keyUntrimUs]), keyUntrimUs)\r\n        if gBreps_Out:\r\n            gBreps[keyUntrimmed].extend(gBreps_Out)\r\n            cleanBrepList(keyUntrimUs, keyUntrimmed)\r\n\r\n        if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n\r\n\r\n    def deleteBreps(keyToDelete):\r\n        for gB in gBreps[keyToDelete]:\r\n            sc.escape_test()\r\n            sc.doc.Objects.Delete(objectId=gB, quiet=False)\r\n        cleanBrepList(keyToDelete)\r\n\r\n\r\n    def findMatchingBrep(breps, crvs, tolerance=None, bDebug=False):\r\n        \"\"\"\r\n        This function was copied from another script.\r\n        \r\n        Returns:\r\n            Index of brep in breps.\r\n    \r\n        This function is used by other scripts, so leave it at the root level.\r\n        \"\"\"\r\n    \r\n        if tolerance is None:\r\n            tolerance = 2.0 * sc.doc.ModelAbsoluteTolerance\r\n    \r\n    \r\n    \r\n        def createBB_ofGeometry(geoms):\r\n            try: geoms = list(geoms)\r\n            except: geoms = [geoms]\r\n            bbox = rg.BoundingBox.Empty\r\n            for geom in geoms: bbox.Union(geom.GetBoundingBox(True))\r\n            if bbox is None: raise ValueError(\"Bounding box not created.\")\r\n            return bbox\r\n    \r\n    \r\n        def findMatchingBoundingBox(bboxes, bbox_toMatch):\r\n            \"\"\"\r\n            bboxes: Iterable of BoundingBoxes from which to search.\r\n            bbox_toMatch: BoundingBox to match.\r\n            Returns: Index of single matching bounding box on success.\r\n            \"\"\"\r\n            \r\n            if bDebug: print 'findMatchingBoundingBox()...'\r\n            \r\n            #tolerance = (3.0 * (tol_Split**2.0))**0.5 # == Total distance of tol_Split for each component.\r\n            \r\n            idx_Found = None\r\n    \r\n            epsilon = tolerance\r\n    \r\n            for i in range(len(bboxes)):\r\n                if (\r\n                        bbox_toMatch.Min.EpsilonEquals(bboxes[i].Min, epsilon=epsilon) and\r\n                        bbox_toMatch.Max.EpsilonEquals(bboxes[i].Max, epsilon=epsilon)\r\n                ):\r\n                    if idx_Found is not None:\r\n                        print \"More than one match found.  Check results.\"\r\n                        return\r\n                    idx_Found = i\r\n            \r\n            if idx_Found is None:\r\n                if bDebug:\r\n                    print \"Matching bounding box NOT found.\"\r\n                    #sc.doc.Objects.AddBrep(bbox_toMatch.ToBrep())\r\n                    #for bb in bboxes:\r\n                        #sc.doc.Objects.AddBrep(bb.ToBrep())\r\n    \r\n            return idx_Found\r\n    \r\n    \r\n        crvs_Closed = []\r\n        segs_ofOpen = []\r\n        for crv in crvs:\r\n            if crv.IsClosed:\r\n                crvs_Closed.append(crv)\r\n            else:\r\n                segs_ofOpen.append(crv)\r\n    \r\n        segs_Joined = rg.Curve.JoinCurves(\r\n                segs_ofOpen, joinTolerance=sc.doc.ModelAbsoluteTolerance)\r\n        segs_Joined = list(segs_Joined) # Convert from Array.\r\n    \r\n        bbox_of_crvs = createBB_ofGeometry(crvs_Closed + segs_Joined)\r\n    \r\n        #sc.doc.Objects.AddBox(rg.Box(bbox_of_crvs)); #sc.doc.Views.Redraw(); 1/0\r\n    \r\n        bboxes_ofNEs = []\r\n        for brep in breps:\r\n            NEs = [edge for edge in brep.Edges\r\n                   if edge.Valence == rg.EdgeAdjacency.Naked]\r\n            bboxes_ofNEs.append(createBB_ofGeometry(NEs))\r\n    \r\n        #for bbox in bboxes_ofNEs:\r\n            #sc.doc.Objects.AddBox(rg.Box(bbox))\r\n        #sc.doc.Views.Redraw(); 1/0\r\n    \r\n        #bboxes_ofNEs = [\r\n        #        createBB_ofGeometry(\r\n        #            [edge\r\n        #                for edge in brep.Edges\r\n        #                if edge.Valence == rg.EdgeAdjacency.Naked]\r\n        #        )\r\n        #        for brep in breps]\r\n    \r\n        #map(sc.doc.Objects.AddBox, map(rg.Box, bboxes_ofNEs))\r\n    \r\n        return findMatchingBoundingBox(bboxes_ofNEs, bbox_of_crvs)\r\n\r\n\r\n    def trimUnderlyingSrfsToBrepNEs(keyToTrim, keysOfTrimming):\r\n        \"\"\"\r\n        Parameters:\r\n            keyToTrim: Breps of any rg.Surface, not just rg.BrepFace.\r\n            keyOfTrimming: Can be one or more GUIDs of Breps.\r\n        Returns:\r\n            4 lists of GUIDs of Breps on success:\r\n                New trimmed.\r\n                Old that were trimmed.\r\n                New split (trim fails).\r\n                Old that were split (trim fails).\r\n        \"\"\"\r\n\r\n        if bEchoCmdPrompt:\r\n            sCmdPrompt0 = \"Trimming surfaces to brep naked edges ...\"\r\n            Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n        sc.escape_test()\r\n\r\n\r\n\r\n        NBs_All = []\r\n        for gB0 in gBreps[keysOfTrimming]:\r\n            for border in (\r\n                spb_Brep_nakedEdgeLoop.createClosedCrvs_2EdgesPerVertexOnly(getBrepGeom(gB0))\r\n            ):\r\n                NBs_All.append(border)\r\n\r\n        #for NB in NBs_All:\r\n        #    sc.doc.Objects.AddCurve(NB)\r\n        #sc.doc.Views.Redraw(); 1/0\r\n\r\n        iCt_Trimmed = 0\r\n        rgBs_Trimmed_to1F = []\r\n        gBs_Trimmed_to1F = []\r\n        gBs_beforeTrim = []\r\n        gBs_Split = []\r\n        gBs_beforeSplit = []\r\n\r\n\r\n        for gB0 in gBreps[keyToTrim]:\r\n            rdBrep0 = coerceBrepObject(gB0)\r\n            rgBrep0 = rdBrep0.Geometry\r\n            rgBrep0.Compact()\r\n            rgSrf01 = rgBrep0.Surfaces[0]\r\n\r\n            rc = xCurve.filterCurvesOnSurface(\r\n                NBs_All,\r\n                coerceSurface(gB0),\r\n                bDebug=bDebug)\r\n            if not rc: continue\r\n            (\r\n                rgCrvs_CompletelyOnSrf,\r\n                rgCrvs_PartiallyOnSrf,\r\n                ) = rc\r\n\r\n\r\n            # TODO?: Add curve trimming here.\r\n\r\n\r\n            # Surface will be split only with segments, not joined curves.\r\n            segs_CompletelyOnSrf_Closed = []\r\n            rgCrvs_CompletelyOnSrf_Closed = []\r\n            for c in rgCrvs_CompletelyOnSrf:\r\n                if c.IsClosed:\r\n                    rgCrvs_CompletelyOnSrf_Closed.append(c)\r\n            segs_CompletelyOnSrf_Closed = xCurve.duplicateSegments(\r\n                rgCrvs_CompletelyOnSrf,\r\n                bExplodePolyCrvs=True)\r\n            #segs_CompletelyOnSrf_Open = xCurve.duplicateSegments(\r\n            #    rgCrvs_CompletelyOnSrf_Open,\r\n            #    bExplodePolyCrvs=True)\r\n            #segs_PartiallyOnSrf = xCurve.duplicateSegments(\r\n            #    rgCrvs_PartiallyOnSrf,\r\n            #    bExplodePolyCrvs=True)\r\n\r\n            rgCrvs_Splitters = segs_CompletelyOnSrf_Closed\r\n\r\n\r\n            # This uses a loop to try a few tolerances before giving up.\r\n            # bOnlyUseCrvsOnFace=False because curves were already analyzed.\r\n            rgB_fromSplit = xSurface.splitSurfaceIntoBrep(\r\n                rgSrf01,\r\n                rgCrvs_Splitters,\r\n                bOnlyUseCrvsOnFace=False,\r\n                fTolerance=sc.doc.ModelAbsoluteTolerance,\r\n                bTryOtherTolsOnFail=True,\r\n                bShrinkSplitMonofaces=False,\r\n                bDebug=bDebug)\r\n            if not rgB_fromSplit: continue\r\n\r\n\r\n            rgBs_fromSplit = []\r\n            for rgF in rgB_fromSplit.Faces:\r\n                rgB = rgF.DuplicateFace(False)\r\n                rgBs_fromSplit.append(rgB)\r\n            #sc.doc.Views.Redraw(); 1/0\r\n\r\n            # Get maximum edge tolerance.  TODO: Make this a function.\r\n            maximaEdgeTols = []\r\n            for brep in rgBs_fromSplit:\r\n                maximaEdgeTols.append(max([edge.Tolerance for edge in brep.Edges]))\r\n            maxEdgeTol = max(maximaEdgeTols)\r\n\r\n            idxBrep_Split_Match = findMatchingBrep(\r\n                rgBs_fromSplit,\r\n                segs_CompletelyOnSrf_Closed,\r\n                tolerance=max(1.1*maxEdgeTol, fTol_EdgeForJoin),\r\n                bDebug=bDebug)\r\n\r\n            for c in segs_CompletelyOnSrf_Closed: c.Dispose()\r\n\r\n            if idxBrep_Split_Match is None:\r\n                if rgB_fromSplit.Faces.Count > 1:\r\n                    bBrep_Split = sc.doc.Objects.AddBrep(\r\n                        rgB_fromSplit, attributes=rdBrep0.Attributes)\r\n                    if bBrep_Split == Guid.Empty:\r\n                        raise ValueError(\"Untrimmed Brep could not be added for {}.\" \\\r\n                            \"  Check this.\".format(gB0))\r\n                    gBs_Split.append(bBrep_Split)\r\n                    gBs_beforeSplit.append(gB0)\r\n            else:\r\n                rgB_fromTrim = rgBs_fromSplit[idxBrep_Split_Match]\r\n                gBrep_Trimmed = sc.doc.Objects.AddBrep(\r\n                    rgB_fromTrim, attributes=rdBrep0.Attributes)\r\n                if gBrep_Trimmed != Guid.Empty:\r\n                    gBs_Trimmed_to1F.append(gBrep_Trimmed)\r\n                    gBs_beforeTrim.append(gB0)\r\n                else:\r\n                    raise ValueError(\"Trimmed Brep could not be added for {}.\" \\\r\n                        \"  Check this.\".format(gB0))\r\n\r\n            rgB_fromSplit.Dispose()\r\n            for rgB in rgBs_fromSplit: rgB.Dispose()\r\n\r\n        if len(gBs_Trimmed_to1F) or bDebug:\r\n            print \"{} faces were trimmed to a single face from {} {} breps.\".format(\r\n                len(gBs_Trimmed_to1F), len(gBreps[keyToTrim]), keyToTrim)\r\n\r\n        if len(gBs_Split) or bDebug:\r\n            print \"{} other faces were split to polyface breps.\".format(\r\n                len(gBs_Split))\r\n\r\n        if gBs_Trimmed_to1F:\r\n            gBreps['retrimmed'].extend(gBs_Trimmed_to1F)\r\n            gBreps['before-trim'] = gBs_beforeTrim\r\n            cleanBrepList(keyToTrim, 'before-trim')\r\n            deleteBreps('before-trim')\r\n\r\n        if gBs_Split:\r\n            gBreps['split-only'].extend(gBs_Split)\r\n            gBreps['before-split'] = gBs_beforeSplit\r\n            # gBs_beforeSplit should == gBreps[keyToTrim].\r\n            pass\r\n\r\n        if bEchoCmdPrompt: Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0 + \" done.\")\r\n\r\n\r\n    def resultReport():\r\n        s  = \"Final result:\"\r\n        s += \" {} solid\".format(len(gBreps['solid']))\r\n        s += \",\"\r\n        s += \" {} good-but-open\".format(len(gBreps['good-but-open']))\r\n        s += \",\"\r\n        s += \" {} split-only\".format(len(gBreps['split-only']))\r\n        s += \", and\"\r\n        s += \" {} untrimmed\".format(len(gBreps['untrimmed']))\r\n        s += \" breps\"\r\n        return s\r\n\r\n\r\n    def resultReturn():\r\n        return (\r\n            gBreps['solid'],\r\n            gBreps['good-but-open'],\r\n            gBreps['split-only'],\r\n            gBreps['untrimmed'],\r\n            )\r\n\r\n\r\n\r\n    gBreps['initial'] = getGuidsToProcess(rdBreps)\r\n\r\n    bEcho = True\r\n\r\n    bEchoCmdPrompt = True\r\n\r\n    if bEchoCmdPrompt:\r\n        sCmdPrompt0 = \"Working ...\"\r\n        Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n    #bEchoCmdPrompt = len(gBreps['initial']) > 10\r\n\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n\r\n    # Remove micro edges before all other actions.\r\n    removeMicroEdges('initial')\r\n\r\n    # Monofaces are not added to 'monoface-to-retrim'\r\n    # at this time so that other breps can be joined,\r\n    # resulting in naked edge borders better suited for trimming other faces.\r\n\r\n    # Bad faces must be extracted now because\r\n    # RhinoCommon does not allow Objects.AddBrep of some invalid breps.\r\n    extractInvalidFaces('initial', 'monoface-to-retrim')\r\n\r\n    gBreps['remaining'] = gBreps['initial'][:]\r\n\r\n    if gBreps['monoface-to-retrim']:\r\n        removeMicroEdges('remaining')\r\n\r\n    if bCorrectETols:\r\n        correctEdgeTols('remaining')\r\n\r\n    if bRemoveSlits:\r\n        removeSlitsFromFaces('remaining')\r\n\r\n    if bCorrectETols:\r\n        extractFacesWithEdgeFromTrimTolError('remaining', 'monoface-to-retrim-to-itself')\r\n        retrimFaceSrfsWithExistingEdges('monoface-to-retrim-to-itself')\r\n        gBreps['remaining'].extend(gBreps['monoface-to-retrim-to-itself'])\r\n\r\n    if bRebuildEs_perETol:\r\n        rebuildFacesWithLargeEdgeTol('remaining')\r\n\r\n    # This is checked last since calculating area takes longer than preceding tests.\r\n    extractBadAreaFaces('remaining', 'monoface-to-retrim')\r\n\r\n\r\n    if bDelSmall:\r\n        if gBreps['remaining']:\r\n            deleteShortBorderFaces('remaining')\r\n            if gBreps['remaining']:\r\n                deleteSliverFaces('remaining')\r\n                if gBreps['remaining']:\r\n                    deleteSmallAreaFaces('remaining')\r\n\r\n        if gBreps['monoface-to-retrim']:\r\n            deleteShortBorderFaces('monoface-to-retrim')\r\n            if gBreps['monoface-to-retrim']:\r\n                deleteSliverFaces('monoface-to-retrim')\r\n                if gBreps['monoface-to-retrim']:\r\n                    deleteSmallAreaFaces('monoface-to-retrim')\r\n\r\n\r\n    # This can reduce connecting naked edge borders.\r\n    joinBrepNakedEdges('remaining')\r\n\r\n\r\n    gBreps['solid'] = []\r\n    gBreps['good-but-open'] = []\r\n    gBreps['split-only'] = []\r\n    gBreps['untrimmed'] = []\r\n    gBreps['retrimmed'] = []\r\n    gBreps['split-only'] = []\r\n    gBreps['before-split'] = []\r\n\r\n\r\n    filterPerSolidState('remaining', 'solid', 'good-but-open')\r\n\r\n    if not gBreps['good-but-open'] and gBreps['solid']:\r\n        s  = \"{} breps were already closed.\".format(len(gBreps['solid']))\r\n        s += \"  {} 'bad' extracted faces remain.\".format(len(gBreps['monoface-to-retrim']))\r\n        if not gBreps['monoface-to-retrim']:\r\n            s += \"  Model was not modified.\"\r\n        print s\r\n        print resultReport()\r\n        return resultReturn()\r\n\r\n\r\n    filterPerSolidState('good-but-open', 'solid')\r\n\r\n    if not gBreps['monoface-to-retrim']:\r\n        if not gBreps['good-but-open'] and gBreps['solid']:\r\n            print \"Only {} closed breps remain.\".format(len(gBreps['solid']))\r\n            print resultReport()\r\n            return resultReturn()\r\n        elif len(gBreps['good-but-open']) == 1:\r\n            print \"Only 1 open and {} closed breps remain.\".format(len(gBreps['solid']))\r\n            print resultReport()\r\n            return resultReturn()\r\n\r\n\r\n    # Initial Join.\r\n    # Join remaining good-but-open breps with each other only.\r\n    # The edge borders after the join will be more useful\r\n    # as trimming curves for the other faces.\r\n\r\n    if len(gBreps['good-but-open']) == 0:\r\n        print \"No good-but-open breps to join.\"\r\n    elif len(gBreps['good-but-open']) == 1:\r\n        print \"Not enough good-but-open breps to join.\"\r\n    else:\r\n        joinBreps('good-but-open', 'solid', 'good-but-open')\r\n        joinBrepNakedEdges('good-but-open')\r\n        filterPerSolidState('good-but-open', 'solid')\r\n\r\n        # If no monofaces need to be retrimmed, then the current result is final.\r\n        if not gBreps['monoface-to-retrim'] and not bRetrim_GoodMonoface:\r\n            if gBreps['good-but-open'] or gBreps['solid']:\r\n                print \"After a single iteration of joining,\" \\\r\n                    \" only {} open and {} closed breps remain.\".format(\r\n                        len(gBreps['good-but-open']), len(gBreps['solid']))\r\n                print resultReport()\r\n                return resultReturn()\r\n\r\n    if bRetrim_GoodMonoface:\r\n        if gBreps['monoface-to-retrim']:\r\n            print \"Since bad breps were\" \\\r\n                \" found,\" \\\r\n                \" good monoface breps will\" \\\r\n                \" not\" \\\r\n                \" be collected to be retrimmed at this time.\"\r\n        else:\r\n            print \"Since bad breps were\" \\\r\n                \" not\" \\\r\n                \" found,\" \\\r\n                \" good monoface breps will\" \\\r\n                \" be collected to be retrimmed at this time.\"\r\n            separateMonofaces('good-but-open', 'monoface-to-retrim')\r\n\r\n\r\n\r\n    print \"__Retrim and join:\"\r\n\r\n    if gBreps['monoface-to-retrim'] and gBreps['good-but-open']:\r\n        untrimFaces('monoface-to-retrim', 'untrimmed')\r\n\r\n        trimUnderlyingSrfsToBrepNEs('untrimmed', 'good-but-open')\r\n\r\n\r\n        if gBreps['retrimmed']:\r\n            deleteBreps('split-only') # Will not use splits at this time.\r\n\r\n            if len(gBreps['good-but-open'] + gBreps['retrimmed']) >= 2:\r\n                joinBreps(['good-but-open', 'retrimmed'], 'solid', 'good-but-open')\r\n                joinBrepNakedEdges('good-but-open')\r\n                filterPerSolidState('good-but-open', 'solid')\r\n\r\n                if not gBreps['untrimmed'] and not bRetrim_GoodMonoface:\r\n                    if gBreps['good-but-open'] or gBreps['solid']:\r\n                        print resultReport()\r\n                        return resultReturn()\r\n\r\n\r\n            if bRetrim_GoodMonoface and len(gBreps['good-but-open'] + gBreps['untrimmed']) >= 2:\r\n                print \"__Find monofaces to retrim:\"\r\n                separateMonofaces(['good-but-open', 'untrimmed'], 'monoface-to-retrim')\r\n\r\n            if gBreps['monoface-to-retrim'] and gBreps['good-but-open']:\r\n                untrimFaces('monoface-to-retrim', 'untrimmed')\r\n\r\n                trimUnderlyingSrfsToBrepNEs('untrimmed', 'good-but-open')\r\n\r\n                if gBreps['split-only']:\r\n                    # Leave split breps in model\r\n                    # for the user to decide what to do with them,\r\n                    # but delete untrimmed breps.\r\n                    deleteBreps('before-split')\r\n                    print \"{} breps that were split from {} are in model.\".format(\r\n                        len(gBreps['split-only']), len(gBreps['before-split']))\r\n\r\n                if gBreps['retrimmed']:\r\n                    if len(gBreps['good-but-open'] + gBreps['retrimmed']) >= 2:\r\n                        joinBreps(['good-but-open', 'retrimmed'], 'solid', 'good-but-open')\r\n                        joinBrepNakedEdges('good-but-open')\r\n                        filterPerSolidState('good-but-open', 'solid')\r\n\r\n                        if not gBreps['untrimmed'] and not bRetrim_GoodMonoface:\r\n                            if gBreps['good-but-open'] or gBreps['solid']:\r\n                                print resultReport()\r\n                                return resultReturn()\r\n\r\n\r\n    if len(gBreps['good-but-open'] + gBreps['retrimmed']) >= 2:\r\n        print \"__Join newly trimmed with each other and other good, open breps:\"\r\n        joinBreps(['good-but-open', 'retrimmed'], 'solid', 'good-but-open')\r\n        joinBrepNakedEdges('good-but-open')\r\n        filterPerSolidState('good-but-open', 'solid')\r\n\r\n    print resultReport()\r\n    return resultReturn()\r\n\r\n\r\ndef main():\r\n\r\n    dialog = RepairBrepDialog()\r\n    if not dialog.ShowModal(Rhino.UI.RhinoEtoApp.MainWindow): return\r\n\r\n\r\n    if Opts.values['sBrepSelPool'] == Opts.sDialogTexts['sBrepSelPool'][0]:\r\n        iter = rd.ObjectEnumeratorSettings()\r\n        iter.NormalObjects = True\r\n        iter.LockedObjects = False\r\n        iter.IncludeLights = False\r\n        iter.IncludeGrips = False\r\n\r\n        rdObjs = []\r\n        for rdObj in sc.doc.Objects.GetObjectList(iter):\r\n            if rdObj.ObjectType == rd.ObjectType.Brep:\r\n                rdObjs.append(rdObj)\r\n    elif Opts.values['sBrepSelPool'] == Opts.sDialogTexts['sBrepSelPool'][1]:\r\n        rc = getInput()\r\n        if rc is None: return\r\n        #oRefs, fOverlap_MinAllowed, bAddDot, iDotHeight, bExtract = ret\r\n        rdObjs = rc\r\n    else:\r\n        print \"Not supported yet.\"\r\n        return\r\n\r\n\r\n    if not Opts.values['bDebug']: sc.doc.Views.RedrawEnabled = False\r\n\r\n    processBrepObjects(rdObjs)\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}