{
  "source_url": "https://github.com/Avery320/hiwin_prc/blob/9353bee9d53d95b96bf354c28c79c89620e39885/robot/urdf_loader.py",
  "repo": "Avery320/hiwin_prc",
  "repo_stars": 0,
  "repo_description": null,
  "license": "BSD-3-Clause",
  "filepath": "robot/urdf_loader.py",
  "instruction": "urdf_loader.py - 電池02：URDF 運動學引擎",
  "code": "\"\"\"\nurdf_loader.py - 電池02：URDF 運動學引擎\n\n功能：\n    模擬 RViz 功能 - 解析 URDF visual geometry，計算前向運動學\n    支援六軸機器人的關節控制\n    自動處理 URDF 中的 xyz、rpy、scale 參數\n\n作者：Avery Tsai\n版本：2.0\n日期：2025-10-05\n\"\"\"\n\nimport os\nimport math\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ntry:\n    import scriptcontext as sc\n    from Rhino.Geometry import Transform, Mesh, Point3d, Vector3d, Plane\nexcept ImportError:\n    sc = None\n    Transform = Mesh = Point3d = Vector3d = Plane = None\n\nCACHE_KEY = 'GH_ROBOT_URDF_CACHE'\n\ndef _parse_floats(s):\n    \"\"\"解析浮點數字串\"\"\"\n    if not s:\n        return []\n    return [float(x) for x in s.strip().replace(',', ' ').split() if x]\n\n\ndef _rpy_to_transform(roll, pitch, yaw):\n    \"\"\"URDF RPY 轉換：固定軸旋轉 X(roll) -> Y(pitch) -> Z(yaw)\"\"\"\n    origin = Point3d(0, 0, 0)\n    Rx = Transform.Rotation(roll, Vector3d(1, 0, 0), origin)\n    Ry = Transform.Rotation(pitch, Vector3d(0, 1, 0), origin)\n    Rz = Transform.Rotation(yaw, Vector3d(0, 0, 1), origin)\n\n    T = Transform.Identity\n    T = Transform.Multiply(T, Rz)\n    T = Transform.Multiply(T, Ry)\n    T = Transform.Multiply(T, Rx)\n    return T\n\n\ndef _xyzrpy_to_transform(xyz, rpy):\n    \"\"\"xyz + rpy 轉換為 Transform\"\"\"\n    T_trans = Transform.Translation(Vector3d(*xyz)) if xyz else Transform.Identity\n    T_rot = _rpy_to_transform(*rpy) if rpy else Transform.Identity\n    return Transform.Multiply(T_trans, T_rot)\n\n\ndef _axis_angle_transform(axis, angle):\n    \"\"\"軸角旋轉轉換\"\"\"\n    ax = Vector3d(*axis)\n    if ax.IsZero:\n        return Transform.Identity\n    ax.Unitize()\n    return Transform.Rotation(angle, ax, Point3d(0, 0, 0))\n\n\ndef _normalize_path(path):\n    \"\"\"標準化路徑（用於比對）\"\"\"\n    if not path:\n        return ''\n    return os.path.normpath(os.path.abspath(path)).lower()\n\n\ndef _get_cache():\n    \"\"\"取得快取字典\"\"\"\n    if sc is None:\n        return {}\n    cache = sc.sticky.get(CACHE_KEY)\n    if cache is None:\n        cache = {}\n        sc.sticky[CACHE_KEY] = cache\n    return cache\n\n\ndef clear_cache():\n    \"\"\"清除所有快取\"\"\"\n    if sc:\n        sc.sticky.pop(CACHE_KEY, None)\n\nclass Visual(object):\n    \"\"\"URDF <visual> 元素\"\"\"\n    __slots__ = ('mesh_path', 'xyz', 'rpy', 'scale')\n\n    def __init__(self, mesh_path, xyz, rpy, scale):\n        self.mesh_path = mesh_path  # 網格檔案絕對路徑\n        self.xyz = xyz              # [x, y, z]\n        self.rpy = rpy              # [roll, pitch, yaw]\n        self.scale = scale          # [sx, sy, sz]\n\n\nclass Link(object):\n    \"\"\"URDF <link> 元素\"\"\"\n    __slots__ = ('name', 'visuals')\n\n    def __init__(self, name):\n        self.name = name\n        self.visuals = []\n\n\nclass Joint(object):\n    \"\"\"URDF <joint> 元素\"\"\"\n    __slots__ = ('name', 'type', 'parent', 'child', 'xyz', 'rpy', 'axis')\n\n    def __init__(self, name, jtype, parent, child, xyz, rpy, axis):\n        self.name = name\n        self.type = jtype           # revolute, continuous, prismatic, fixed\n        self.parent = parent        # parent link name\n        self.child = child          # child link name\n        self.xyz = xyz              # [x, y, z]\n        self.rpy = rpy              # [roll, pitch, yaw]\n        self.axis = axis or [0, 0, 1]  # [x, y, z]\n\n\nclass RobotModel(object):\n    \"\"\"URDF 機器人模型\"\"\"\n    __slots__ = ('links', 'joints', 'root', 'joint_order')\n\n    def __init__(self):\n        self.links = {}         # {name: Link}\n        self.joints = {}        # {name: Joint}\n        self.root = None        # root link name\n        self.joint_order = []   # 可動關節名稱列表（樹狀順序）\n\n    def resolve_root(self):\n        \"\"\"找出 root link（沒有 parent 的 link）\"\"\"\n        children = {j.child for j in self.joints.values()}\n        candidates = [name for name in self.links if name not in children]\n        self.root = candidates[0] if candidates else None\n\n    def build_order(self):\n        \"\"\"建立可動關節的順序（BFS 遍歷）\"\"\"\n        if not self.root:\n            self.resolve_root()\n\n        movable = []\n        queue = deque([self.root])\n        visited = set()\n\n        while queue:\n            link = queue.popleft()\n            if link in visited:\n                continue\n            visited.add(link)\n\n            for joint in self.joints.values():\n                if joint.parent == link:\n                    if joint.type in ('revolute', 'continuous', 'prismatic'):\n                        movable.append(joint.name)\n                    queue.append(joint.child)\n\n        self.joint_order = movable\n\ndef _resolve_mesh_path(filename, base_dir, urdf_root):\n    \"\"\"解析網格檔案路徑\n\n    支援：\n    - package:// 路徑\n    - 相對路徑（../meshes/...）\n    - 絕對路徑\n    \"\"\"\n    if not filename:\n        return None\n\n    fn = filename.strip()\n\n    # package:// 路徑\n    if fn.startswith('package://'):\n        rest = fn[10:]  # 移除 'package://'\n        sub_path = rest.split('/', 1)[1] if '/' in rest else ''\n        full_path = os.path.join(urdf_root, sub_path)\n        if os.path.exists(full_path):\n            return os.path.abspath(full_path)\n\n    # 相對路徑\n    rel_path = os.path.join(base_dir, fn)\n    if os.path.exists(rel_path):\n        return os.path.abspath(rel_path)\n\n    # 絕對路徑\n    if os.path.isabs(fn) and os.path.exists(fn):\n        return os.path.abspath(fn)\n\n    return None\n\n\ndef parse_urdf(urdf_path):\n    \"\"\"解析 URDF 檔案（只處理 <visual><geometry>）\"\"\"\n    cache = _get_cache()\n    cache_key = ('URDF', urdf_path)\n    if cache_key in cache:\n        return cache[cache_key]\n\n    tree = ET.parse(urdf_path)\n    root = tree.getroot()\n    robot = RobotModel()\n\n    base_dir = os.path.dirname(urdf_path)\n    urdf_root = os.path.abspath(os.path.join(base_dir, '..'))\n\n    # 解析 links（只處理 <visual>）\n    for link_elem in root.findall('link'):\n        link_name = link_elem.get('name')\n        link = Link(link_name)\n\n        for visual_elem in link_elem.findall('visual'):\n            # 解析 origin\n            origin_elem = visual_elem.find('origin')\n            xyz = _parse_floats(origin_elem.get('xyz')) if origin_elem is not None else [0, 0, 0]\n            rpy = _parse_floats(origin_elem.get('rpy')) if origin_elem is not None else [0, 0, 0]\n\n            # 解析 geometry/mesh\n            geom_elem = visual_elem.find('geometry')\n            mesh_elem = geom_elem.find('mesh') if geom_elem is not None else None\n\n            if mesh_elem is not None:\n                mesh_file = mesh_elem.get('filename')\n                mesh_path = _resolve_mesh_path(mesh_file, base_dir, urdf_root) if mesh_file else None\n\n                # 解析 scale（預設 [1, 1, 1]）\n                scale = _parse_floats(mesh_elem.get('scale')) or [1.0, 1.0, 1.0]\n                scale = (scale + [1.0, 1.0, 1.0])[:3]  # 確保長度為 3\n\n                link.visuals.append(Visual(mesh_path, xyz, rpy, scale))\n\n        robot.links[link_name] = link\n\n    # 解析 joints\n    for joint_elem in root.findall('joint'):\n        joint_name = joint_elem.get('name')\n        joint_type = joint_elem.get('type')\n        parent_link = joint_elem.find('parent').get('link')\n        child_link = joint_elem.find('child').get('link')\n\n        # 解析 origin\n        origin_elem = joint_elem.find('origin')\n        xyz = _parse_floats(origin_elem.get('xyz')) if origin_elem is not None else [0, 0, 0]\n        rpy = _parse_floats(origin_elem.get('rpy')) if origin_elem is not None else [0, 0, 0]\n\n        # 解析 axis\n        axis_elem = joint_elem.find('axis')\n        axis = _parse_floats(axis_elem.get('xyz')) if axis_elem is not None else [0, 0, 1]\n\n        joint = Joint(joint_name, joint_type, parent_link, child_link, xyz, rpy, axis)\n        robot.joints[joint_name] = joint\n\n    # 建立機器人樹結構\n    robot.resolve_root()\n    robot.build_order()\n\n    # 快取結果\n    cache[cache_key] = robot\n    return robot\n\n\n# ==================== 前向運動學 ====================\n\n\n# -------------------- Kinematics --------------------\n\ndef compute_link_transforms(robot, joint_values):\n    \"\"\"計算所有 link 的世界座標變換（前向運動學）\n\n    Args:\n        robot: RobotModel 實例\n        joint_values: dict {joint_name: value_in_radians}\n\n    Returns:\n        dict {link_name: Transform}\n    \"\"\"\n    T_world = {}\n    if not robot.root:\n        return T_world\n\n    # Root link 的變換為單位矩陣\n    T_world[robot.root] = Transform.Identity\n\n    # 建立 parent -> children joints 的映射\n    children_joints = {}\n    for joint in robot.joints.values():\n        children_joints.setdefault(joint.parent, []).append(joint)\n\n    def traverse(link_name):\n        \"\"\"遞迴遍歷機器人樹\"\"\"\n        for joint in children_joints.get(link_name, []):\n            # 取得 parent link 的變換\n            T_parent = T_world[link_name]\n\n            # 套用 joint origin 變換（xyz + rpy）\n            T_joint_origin = _xyzrpy_to_transform(joint.xyz, joint.rpy)\n            T = Transform.Multiply(T_parent, T_joint_origin)\n\n            # 套用關節運動（revolute/continuous/prismatic）\n            joint_value = joint_values.get(joint.name, 0.0)\n            if joint.type in ('revolute', 'continuous'):\n                # 旋轉關節：繞 axis 旋轉 joint_value 弧度\n                T_rotation = _axis_angle_transform(joint.axis, joint_value)\n                T = Transform.Multiply(T, T_rotation)\n            elif joint.type == 'prismatic':\n                # 平移關節：沿 axis 平移 joint_value 距離\n                axis_vec = Vector3d(*joint.axis)\n                axis_vec.Unitize()\n                T_translation = Transform.Translation(axis_vec * joint_value)\n                T = Transform.Multiply(T, T_translation)\n            # fixed joint 不需要額外變換\n\n            # 儲存 child link 的變換\n            T_world[joint.child] = T\n\n            # 遞迴處理子節點\n            traverse(joint.child)\n\n    traverse(robot.root)\n    return T_world\n\ndef normalize_path(p):\n    \"\"\"Normalize path for comparison\"\"\"\n    if not p:\n        return ''\n    return os.path.abspath(p).lower().replace('\\\\', '/')\n\n\ndef match_meshes(robot, input_meshes, input_paths):\n    \"\"\"將網格與 URDF visual geometry 配對\"\"\"\n    path_to_mesh = {}\n    for i, path in enumerate(input_paths or []):\n        if i < len(input_meshes):\n            path_to_mesh[normalize_path(path)] = input_meshes[i]\n\n    link_meshes = {}\n    for link_name, link in robot.links.items():\n        link_meshes[link_name] = []\n        for visual in link.visuals:\n            mesh = path_to_mesh.get(normalize_path(visual.mesh_path))\n            if mesh:\n                link_meshes[link_name].append((mesh, visual))\n\n    return link_meshes\n\n\ndef assemble_geometry(robot, T_links, link_meshes):\n    \"\"\"組裝機器人幾何（套用變換：scale → visual origin → link transform）\"\"\"\n    out_meshes = []\n    out_names = []\n\n    for link_name in robot.links.keys():\n        T_link = T_links.get(link_name, Transform.Identity)\n\n        for mesh, visual in link_meshes.get(link_name, []):\n            m = mesh.DuplicateMesh()\n\n            # 1. Scale\n            if visual.scale != [1.0, 1.0, 1.0]:\n                m.Transform(Transform.Scale(Plane.WorldXY, visual.scale[0], visual.scale[1], visual.scale[2]))\n\n            # 2. Visual origin\n            m.Transform(_xyzrpy_to_transform(visual.xyz, visual.rpy))\n\n            # 3. Link transform\n            m.Transform(T_link)\n\n            out_meshes.append(m)\n            out_names.append(link_name)\n\n    return out_meshes, out_names\n\ndef load(urdf_path, meshes, mesh_paths, joint_values=None, use_degrees=True, reload=False):\n    \"\"\"載入 URDF 並計算運動學\n\n    Args:\n        urdf_path: URDF 檔案路徑\n        meshes: 預載入的網格列表\n        mesh_paths: 對應的檔案路徑列表\n        joint_values: 六軸關節值 [J1..J6]（預設 [0,0,0,0,0,0]）\n        use_degrees: True=角度，False=弧度（預設 True）\n        reload: 強制重新載入，清除快取（預設 False）\n\n    Returns:\n        (meshes, names, joint_order): 變換後的網格、Link名稱、關節順序\n    \"\"\"\n    if reload:\n        clear_cache()\n\n    if not urdf_path or not os.path.exists(urdf_path):\n        return [], [], []\n\n    try:\n        robot = parse_urdf(urdf_path)\n    except:\n        return [], [], []\n\n    # 處理關節值\n    j_vals = list(joint_values) if joint_values else [0.0] * 6\n    j_vals = (j_vals + [0.0] * 6)[:6]\n\n    if use_degrees:\n        j_vals = [math.radians(v) for v in j_vals]\n\n    # 建立關節值字典\n    joint_dict = {}\n    for i, jname in enumerate(robot.joint_order):\n        joint_dict[jname] = j_vals[i] if i < 6 else 0.0\n\n    # 計算運動學\n    T_links = compute_link_transforms(robot, joint_dict)\n    link_meshes = match_meshes(robot, meshes or [], mesh_paths or [])\n    result_meshes, names = assemble_geometry(robot, T_links, link_meshes)\n\n    return result_meshes, names, robot.joint_order[:6]\n\n\n# 向後相容\ndef urdf_draw(URDFPath, Meshes, MeshPaths, J=None, Deg=True, Reload=False):\n    return load(URDFPath, Meshes, MeshPaths, J, Deg, Reload)\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}