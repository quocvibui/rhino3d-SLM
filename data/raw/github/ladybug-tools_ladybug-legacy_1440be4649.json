{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Psychrometric%20Chart.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Psychrometric Chart.py",
  "instruction": "Use this component to draw a psychrometric chart in the Rhino scene and evaluate a set of temperatures and humidity ratios in terms of indoor comfort.  Connected data can include either outdoor...",
  "code": "# Psychrometric Chart\n#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Chris Mackey <Chris@MackeyArchitecture.com> \n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to draw a psychrometric chart in the Rhino scene and evaluate a set of temperatures and humidity ratios in terms of indoor comfort.  Connected data can include either outdoor temperature and humidty ratios from imported EPW weather data, indoor temperature and humidity ratios from an energy simulation, or indivdual numerical inputs of temperature and humidity.  The input data will be plotted alongside polygons on the chart representing comfort as well as polygons representing the efects of passive building strategies on comfort.\n_\nThe specific human energy balance model used by the psychrometric chart is the Predicted Mean Vote (PMV) model developed by P.O. Fanger. PMV is a seven-point scale from cold (-3) to hot (+3) that is used in comfort surveys.  Each interger value of the scale indicates the following: -3:Cold, -2:Cool, -1:Slightly Cool, 0:Neutral, +1:Slightly Warm, +2:Warm, +3:Hot.  The range of comfort is generally accepted as a PMV between -1 and +1 and this is what defines the range of the comfort polygon on the psychrometric chart.\nAccordingly, this component will also output the PMV of the occupant for the input conditions as well as an estimated percentage of people dissatisfied (PPD) in the given conditions.\n_\nThe comfort models that make this component possible were translated to python from a series of validated javascript comfort models developed at the Berkely Center for the Built Environment (CBE).\nSpecific documentation on the comfort models can be found here: https://code.google.com/p/cbe-comfort-tool/wiki/ComfortModels\n_\nSpecial thanks goes to the authors of the online CBE Thermal Comfort Tool who first made the javascript models in order to power the tool:\nHoyt Tyler, Schiavon Stefano, Piccioli Alberto, Moon Dustin, and Steinfeld Kyle, 2013, CBE Thermal Comfort Tool. \nCenter for the Built Environment, University of California Berkeley, http://cbe.berkeley.edu/comforttool/\n_\nThe information for the polygons representing passive strategies comes from the climate consultant psychrometric chart.  Further information on how these polygons are calculated can be found here:\nhttp://apps1.eere.energy.gov/buildings/tools_directory/software.cfm/ID=123/pagename=alpha_list\n-\nProvided by Ladybug 0.0.69\n    \n    Args:\n        _dryBulbTemperature: A number representing the dry bulb temperature of the air in degrees Celcius.  This input can also accept a list of temperatures representing conditions at different times or the direct output of dryBulbTemperature from the Import EPW component.  Indoor temperatures from Honeybee energy simulations are also possible inputs.  Finally, this component can also acccept temperatures in Farenheit in order to draw a chart with IP units but, in order for this component to sense that the values are Farenheit, there must be at least one 'F' or 'F' in the stream of connected data.\n        _relativeHumidity: A number between 0 and 100 representing the relative humidity of the air in percentage.  This input can also accept a list of relative humidity values representing conditions at different times or the direct output of relativeHumidity from of the Import EPW component.\n        barometricPressure_: A number representing the barometric pressure in Pascals.  If no value is connected here, the default pressure will be 101325 Pa, which is air pressure at sea level.  It is recommended that you connect the barometric pressure from the Import epw component here as the air pressure at sea level can cause some misleading results for cities at higher elevations.\n        -------------------------: ...\n        meanRadTemperature_: A number representing the mean radiant temperature of the surrounding surfaces.  This value should be in degrees Celcius unless you have connected values in Farenheit to the dryBulbTemperature and you are seeing a chart in IP units.  If no value is plugged in here, this component will assume that the mean radiant temperature is the same as the connected dry bulb temperature (and the X-Axis of the Psychrometric Chart is for Operative Temperature instead of Dry Bulb Temperature).  This input can also accept a list of temperatures and this will produce several comfort polygons (one for each mean radiant temperature).\n        windSpeed_: A number representing the wind speed of the air in meters per second.  If no value is plugged in here, this component will assume a very low wind speed of 0.05 m/s, characteristic of most indoor conditions.  This input can also accept a list of wind speeds representing conditions and this will produce several comfort polygons (one for each wind speed).\n        metabolicRate_: A number representing the metabolic rate of the human subject in met.  This input can also accept text inputs for different activities.  Acceptable text inputs include Sleeping, Reclining, Sitting, Typing, Standing, Driving, Cooking, House Cleaning, Walking, Walking 2mph, Walking 3mph, Walking 4mph, Running 9mph, Lifting 10lbs, Lifting 100lbs, Shoveling, Dancing, and Basketball.  If no value is input here, the component will assume a metabolic rate of 1 met, which is the metabolic rate of a seated human being.  This input can also accept lists of metabolic rates and will produce multiple comfort polygons accordingly.\n        clothingLevel_: A number representing the clothing level of the human subject in clo.  If no value is input here, the component will assume a clothing level of 1 clo, which is roughly the insulation provided by a 3-piece suit. A person dressed in shorts and a T-shirt has a clothing level of roughly 0.5 clo and a person in a thick winter jacket can have a clothing level as high as 2 to 4 clo.  This input can also accept lists of clothing levels and will produce multiple comfort polygons accordingly.\n        -------------------------: ...\n        mergeComfPolygons_:  Set to \"True\" if you have connected multiple values for any of the four comfort variables in the section above and you wish to merge all of the computed comfort polygons into one.\n        comfortPar_: Optional comfort parameters from the \"Ladybug_PMV Comfort Parameters\" component.  Use this to adjust maximum and minimum acceptable humidity ratios.  These comfortPar can also change whether comfort is defined by eighty or ninety percent of people comfortable.\n        passiveStrategy_: An optional text input of passive strategies to be laid over the psychrometric chart as polygons.  It is recommended that you use the \"Ladybug_Passive Strategy List\" to select which polygons you would like to display.  Otherwise, acceptable text inputs include \"Evaporative Cooling\", \"Thermal Mass + Night Vent\", \"Occupant Use of Fans\", \"Internal Heat Gain\", and \"Dessicant Dehumidification\".\n        strategyPar_: Optional passive strategy parameters from the \"Ladybug_Passive Strategy Parameters\" component.  Use this to adjust the maximum comfortable wind speed, the building balance temperature, and the temperature limits for thermal mass and night flushing.\n        mollierHX_: Set to \"True\" to visualize the psychrometric chart as a mollier-hx diagram.  This is essentially a psychrometric chart where the axes have been switched, which is popular in Europe.\n        enthalpyOrWetBulb_: Set to \"True\" to have the psychrometric chart plot lines of constant enthalpy and set to \"False\" to have the chart plot linest of constant wet bulb temperature.  The default is set to \"True\" for enthalpy.\n        analysisPeriod_: An optional analysis period from the Ladybug_Analysis Period component.  If no Analysis period is given and epw data from the ImportEPW component has been connected, the analysis will be run for the enitre year.\n        annualHourlyData_: An optional list of hourly data from the Import epw component, which will be used to create hourPointColors that correspond to the hours of the data (e.g. windSpeed).  You can connect up several different annualHourly data here.\n        conditionalStatement_: This input allows users to remove data that does not fit specific conditions or criteria from the psychrometric chart. The conditional statement input here should be a valid condition statement in Python, such as \"a>25\" or \"b<80\" (without quotation marks).\n                              The current version of this component accepts \"and\" and \"or\" operators. To visualize the hourly data, only lowercase English letters should be used as variables, and each letter alphabetically corresponds to each of the lists (in their respective order): \"a\" always represents dryBulbtemperature, \"b\" always represents the relativeHumidity, \"c\" always represents the 1st list plugged into annualHourlyData_, \"d\" represents the 2nd list, etc.\n                              For example, if you want to plot the data for the time period when temperature is between 18C and 23C, and humidity is less than 80%, the conditional statement should be written as 18<a<23 and b<80 (without quotation marks).\n        basePoint_: An optional base point that will be used to place the Psychrometric Chart in the Rhino scene.  If no base point is provided, the base point will be the Rhino model origin.\n        scale_: An optional number to change the scale of the spychrometric chart in the Rhino scene.  By default, this value is set to 1.\n        legendPar_: Optional legend parameters from the Ladybug Legend Parameters component.\n        bakeIt_ : An integer that tells the component if/how to bake the bojects in the Rhino scene.  The default is set to 0.  Choose from the following options:\n            0 (or False) - No geometry will be baked into the Rhino scene (this is the default).\n            1 (or True) - The geometry will be baked into the Rhino scene as a colored hatch and Rhino text objects, which facilitates easy export to PDF or vector-editing programs. \n            2 - The geometry will be baked into the Rhino scene as colored meshes, which is useful for recording the results of paramteric runs as light Rhino geometry.\n        _runIt: Set to \"True\" to run the component and generate a psychrometric chart!\nReturns:\n        readMe!: ...\n        -------------------------: ...\n        totalComfortPercent: The percent of the input data that are  inside all comfort and passive strategy polygons.\n        totalComfortOrNot: A list of 0's and 1's indicating, for each hour of the input data, if the hour is inside a comfort or strategy polygon (1) or not(0).\n        strategyNames:  A list of names for the comfort polygons and strategeis that corresponds to the numbers in the following outputs.\n        strategyPercentOfTime: The percent of the input data that are in each of the comfort or passive strategy polygons.  Each number here corresponds to the names in the \"strategyNames\" output above.\n        strategyOrNot: A list of 0's and 1's indicating, for each hour of the input temperature and humidity ratio, if the hour is inside a given comfort or passive strategy polygon (1) or not(0).  If there are multiple comfort polyogns or passive strategies connected to the passiveStrategy_ input, this output will be a grafted list for each polygon.  Each list here corresponds to the names in the \"strategyNames\" output above.\n        -------------------------: ...\n        chartCurvesAndTxt: The chart curves and text labels of the psychrometric chart.\n        psychChartMesh: A colored mesh showing the number of input hours happen in each part of the psychrometric chart.\n        legend: A colored legend showing the number of hours that correspond to each color.\n        legendBasePt: The legend base point, which can be used to move the legend in relation to the chart with the grasshopper \"move\" component.\n        comfortPolygons: A brep representing the range of comfort for the input radiant temperature, wind speed, metabolic rate and clothing level.  IF multiple values have been hooked up for any of these inputs, multiple polygons will be output here.\n        strategyPolygons: A brep representing the area of the chart made comfortable by the passive strategies.  If multiple strategies have been hooked up to the passiveStrategy_ input, multiple polygons will be output here.\n        -------------------------: ...\n        chartHourPoints: Points representing each of the hours of input temperature and humidity ratio.  By default, this ouput is hidden and, to see it, you should connect it to a Grasshopper preview component.\n        hourPointColors: Colors that correspond to the chartHourPoints above and can be hooked up to the \"Swatch\" input of a Grasshopper Preview component that has the hour points above connected as geometry.  By default, points are colored red if they lie inside comfort or strategy polygons and are colored blue if they do not meet such comfort criteria.  In the event that you have hooked up annualHourlyData_ this output will be a grafted list of colors.  The first list corresponds to the comfort conditions while the second list colors points based on the annualHourlyData.\n        hourPointLegend: A legend that corresponds to the hour point colors above.  In the event that annualHourlyData_ is connected, this output will be a grafted list of legends that each correspond to the grafted lists of colors.\n\"\"\"\nghenv.Component.Name = \"Ladybug_Psychrometric Chart\"\nghenv.Component.NickName = 'PsychChart'\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"2 | VisualizeWeatherData\"\n#compatibleLBVersion = VER 0.0.59\\nAUG_30_2017\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"1\"\nexcept: pass\n\n\nimport Grasshopper.Kernel as gh\nimport math\nimport scriptcontext as sc\nimport Rhino as rc\nimport rhinoscriptsyntax as rs\nimport System\nfrom System import Object\nfrom clr import AddReference\nAddReference('Grasshopper')\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\nimport copy\n\n\ndef mollierHXTransform(geometry):\n    molTransRotat = rc.Geometry.Transform.Rotation(rc.Geometry.Vector3d.YAxis, rc.Geometry.Vector3d(-1,0,0), rc.Geometry.Point3d.Origin)\n    molTransReflect = rc.Geometry.Transform.Mirror(rc.Geometry.Plane.WorldYZ)\n    geometry.Transform(molTransRotat)\n    geometry.Transform(molTransReflect)\n    \n    return geometry\n\ndef C2F(temper):\n    newTemper = []\n    for num in temper: newTemper.append(num*9/5 + 32)\n    return newTemper\n\ndef F2C(temper):\n    newTemper = []\n    for num in temper: newTemper.append((num-32) * 5 / 9)\n    return newTemper\n\ndef BTUlb2kJkg(enthalpy):\n    newEnthalpy = []\n    for num in enthalpy: newEnthalpy.append(num/0.429922614)\n    return newEnthalpy\n\ndef kJkg2BTUlb(enthalpy):\n    newEnthalpy = []\n    for num in enthalpy: newEnthalpy.append(num*0.429922614)\n    return newEnthalpy\n\ndef checkTheInputs():\n    #Define a value that will indicate whether someone has hooked up epw data.\n    epwData = False\n    epwStr = []\n    IPTrigger = False\n    farenheitVals = []\n    \n    #Check lenth of the _dryBulbTemperature list and evaluate the contents.\n    checkData1 = True\n    epwDatFound = True\n    airTemp = []\n    airMultVal = False\n    if len(_dryBulbTemperature) != 0:\n        try:\n            if \"Temperature\" in _dryBulbTemperature[2]:\n                airTemp = _dryBulbTemperature[7:]\n                checkData1 = True\n                epwData = True\n                epwStr = _dryBulbTemperature[0:7]\n                if epwStr[3] == 'F' or epwStr[3] == 'F':\n                    IPTrigger = True\n        except:\n            epwDatFound = False\n        if epwDatFound == False:\n            for item in _dryBulbTemperature:\n                try:\n                    airTemp.append(float(item))\n                except:\n                    if item == 'F' or item == 'F': IPTrigger = True\n                    else: checkData1 = False\n        if IPTrigger == True:\n            farenheitVals = airTemp[:]\n            newAirTemp = F2C(airTemp)\n            airTemp = newAirTemp\n        if len(airTemp) > 1: airMultVal = True\n        if checkData1 == False:\n            warning = '_dryBulbTemperature input does not contain valid temperature values.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    else:\n        print 'Connect a temperature for _dryBulbTemperature'\n    \n    #Check lenth of the _relativeHumidity list and evaluate the contents.\n    checkData2 = False\n    relHumid = []\n    humidMultVal = False\n    nonValue = True\n    if len(_relativeHumidity) != 0:\n        try:\n            if \"Humidity\" in _relativeHumidity[2]:\n                relHumid = _relativeHumidity[7:]\n                checkData2 = True\n                epwData = True\n                epwStr = _relativeHumidity[0:7]\n        except: pass\n        if checkData2 == False:\n            for item in _relativeHumidity:\n                try:\n                    if 0 <= float(item) <= 100:\n                        relHumid.append(float(item))\n                        checkData2 = True\n                    else: nonValue = False\n                except:checkData2 = False\n        if nonValue == False: checkData2 = False\n        if len(relHumid) > 1: humidMultVal = True\n        if checkData2 == False:\n            warning = '_relativeHumidity input does not contain valid value.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    else:\n        print 'Connect a value for _relativeHumidity.'\n    \n    #Check lenth of the _relativeHumidity list and evaluate the contents.\n    checkData3 = False\n    barPress = []\n    pressMultVal = False\n    nonValue = True\n    if len(barometricPressure_) != 0:\n        try:\n            if \"Barometric Pressure\" in barometricPressure_[2]:\n                barPress = barometricPressure_[7:]\n                checkData3 = True\n                epwData = True\n                epwStr = barometricPressure_[0:7]\n        except: pass\n        if checkData3 == False:\n            for item in barometricPressure_:\n                try:\n                    barPress.append(float(item))\n                    checkData3 = True\n                except:checkData3 = False\n        if nonValue == False: checkData3 = False\n        if len(barPress) > 1: pressMultVal = True\n        if checkData3 == False:\n            warning = 'barometricPressure_ input does not contain valid value.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    else:\n        checkData3 = True\n        barPress = [101325]\n        print 'No value connected for barPress_.  It will be assumed that the barometric pressure is that at sea level: 101325 Pa.'\n    \n    \n    #Check to make sure that the temperature, barometric pressure and humidity ratio lists are the same length.\n    checkData4 = False\n    if checkData1 == True and checkData2 == True and checkData3 == True:\n        if airMultVal == True or humidMultVal == True or pressMultVal == True:\n            listLenCheck = []\n            if airMultVal == True: listLenCheck.append(len(airTemp))\n            if humidMultVal == True: listLenCheck.append(len(relHumid))\n            if pressMultVal == True: listLenCheck.append(len(barPress))\n            \n            if all(x == listLenCheck[0] for x in listLenCheck) == True:\n                checkData4 = True\n                calcLength = listLenCheck[0]\n                \n                def duplicateData(data, calcLength):\n                    dupData = []\n                    for count in range(calcLength):\n                        dupData.append(data[0])\n                    return dupData\n                \n                if airMultVal == False: airTemp = duplicateData(airTemp, calcLength)\n                if humidMultVal == False: relHumid = duplicateData(relHumid, calcLength)\n                if pressMultVal == False: barPress = duplicateData(barPress, calcLength)\n            else:\n                calcLength = None\n                warning = 'If you have put in lists with multiple values for temperature or humidity, the lengths of these lists must match between temperature and humidity or you have a single value for a given parameter to be applied to all values in the list.'\n                print warning\n                ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n        else:\n            checkData4 = True\n            calcLength = 1\n    else:\n        calcLength = 0\n    \n    \n    #Make sure that the lengths of the 4 other comfort parameters match and assign default values if nothing is connected.\n    #Check lenth of the meanRadTemperature_ list and evaluate the contents.\n    opTemp = False\n    checkData5 = False\n    radTemp = []\n    radMultVal = False\n    if len(meanRadTemperature_) != 0:\n        for item in meanRadTemperature_:\n            try:\n                radTemp.append(float(item))\n                checkData5 = True\n            except: checkData5 = False\n        if len(radTemp) > 1: radMultVal = True\n        if checkData5 == False:\n            warning = 'meanRadTemperature_ input does not contain valid temperature values in degrees Celcius.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n        if IPTrigger: radTemp = F2C(radTemp)\n    else:\n        checkData5 = True\n        radTemp = [23]\n        opTemp = True\n        print 'No value connected for meanRadTemperature_.  It will be assumed that the radiant temperature is equal to the air temperature.'\n    \n    \n    #Check lenth of the windSpeed_ list and evaluate the contents.\n    checkData6 = False\n    windSpeed = []\n    windMultVal = False\n    nonPositive = True\n    if len(windSpeed_) != 0:\n        for item in windSpeed_:\n            try:\n                if float(item) >= 0:\n                    windSpeed.append(float(item))\n                    checkData6 = True\n                else: nonPositive = False\n            except: checkData6 = False\n        if nonPositive == False: checkData6 = False\n        if len(windSpeed) > 1: windMultVal = True\n        if checkData6 == False:\n            warning = 'windSpeed_ input does not contain valid wind speed in meters per second.  Note that wind speed must be positive.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    else:\n        checkData6 = True\n        windSpeed = [0.05]\n        print 'No value connected for windSpeed_.  It will be assumed that the wind speed is a low 0.05 m/s.'\n    \n    #Check lenth of the metabolicRate_ list and evaluate the contents.\n    checkData7 = False\n    metRate = []\n    metMultVal = False\n    nonVal = True\n    if len(metabolicRate_) != 0:\n        for item in metabolicRate_:\n            try:\n                if 0.5 <= float(item) <= 10:\n                    metRate.append(float(item))\n                    checkData7 = True\n                else: nonVal = False\n            except: checkData7 = False\n        if checkData7 == False:\n            try:\n                if str(metabolicRate_[0]) == \"Sleeping\": metRate.append(0.7)\n                elif str(metabolicRate_[0]) == \"Reclining\": metRate.append(0.8)\n                elif str(metabolicRate_[0]) == \"Sitting\": metRate.append(1.0)\n                elif str(metabolicRate_[0]) == \"Typing\": metRate.append(1.1)\n                elif str(metabolicRate_[0]) == \"Standing\": metRate.append(1.2)\n                elif str(metabolicRate_[0]) == \"Driving\": metRate.append(1.5)\n                elif str(metabolicRate_[0]) == \"Cooking\": metRate.append(1.8)\n                elif str(metabolicRate_[0]) == \"House Cleaning\": metRate.append(2.7)\n                elif str(metabolicRate_[0]) == \"Walking\": metRate.append(1.7)\n                elif str(metabolicRate_[0]) == \"Walking 2mph\": metRate.append(2.0)\n                elif str(metabolicRate_[0]) == \"Walking 3mph\": metRate.append(2.6)\n                elif str(metabolicRate_[0]) == \"Walking 4mph\": metRate.append(3.8)\n                elif str(metabolicRate_[0]) == \"Running 9mph\": metRate.append(9.5)\n                elif str(metabolicRate_[0]) == \"Lifting 10lbs\": metRate.append(2.1)\n                elif str(metabolicRate_[0]) == \"Lifting 100lbs\": metRate.append(4.0)\n                elif str(metabolicRate_[0]) == \"Shoveling\": metRate.append(4.4)\n                elif str(metabolicRate_[0]) == \"Dancing\": metRate.append(3.4)\n                elif str(metabolicRate_[0]) == \"Basketball\": metRate.append(6.3)\n                else: pass\n            except: pass\n        if len(metRate) > 0: checkData7 = True\n        if nonVal == False: checkData7 = False\n        if len(metRate) > 1: metMultVal = True\n        if checkData7 == False:\n            warning = 'metabolicRate_ input does not contain valid value. Note that metabolicRate_ must be a value between 0.5 and 10. Any thing outside of that is frankly not human.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    else:\n        checkData7 = True\n        metRate = [1]\n        print 'No value connected for metabolicRate_.  It will be assumed that the metabolic rate is that of a seated person at 1 met.'\n    \n    #Check lenth of the clothingLevel_ list and evaluate the contents.\n    checkData8 = False\n    cloLevel = []\n    cloMultVal = False\n    noVal = True\n    if len(clothingLevel_) != 0:\n        for item in clothingLevel_:\n            try:\n                if 0 <= float(item) <= 5:\n                    cloLevel.append(float(item))\n                    checkData8 = True\n                else: noVal = False\n            except: checkData8 = False\n        if noVal == False: checkData8 = False\n        if len(cloLevel) > 1: cloMultVal = True\n        if checkData8 == False:\n            warning = 'clothingLevel_ input does not contain valid value. Note that clothingLevel_ must be a value between 0 and 5. Any thing outside of that is frankly not human.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    else:\n        checkData8 = True\n        cloLevel = [1]\n        print 'No value connected for clothingLevel_.  It will be assumed that the clothing level is that of a person wearing a 3-piece suit at 1 clo.'\n    \n    #Finally, for those lists of length greater than 1, check to make sure that they are all the same length.\n    checkData9 = False\n    if checkData5 == True and checkData6 == True and checkData7 == True and checkData8 == True:\n        if radMultVal == True or windMultVal == True or metMultVal == True or cloMultVal == True:\n            listLenCheck = []\n            if radMultVal == True: listLenCheck.append(len(radTemp))\n            if windMultVal == True: listLenCheck.append(len(windSpeed))\n            if metMultVal == True: listLenCheck.append(len(metRate))\n            if cloMultVal == True: listLenCheck.append(len(cloLevel))\n            \n            if all(x == listLenCheck[0] for x in listLenCheck) == True:\n                checkData9 = True\n                calcLength2 = listLenCheck[0]\n                \n                def duplicateData(data, calcLength2):\n                    dupData = []\n                    for count in range(calcLength2):\n                        dupData.append(data[0])\n                    return dupData\n                \n                if radMultVal == False: radTemp = duplicateData(radTemp, calcLength2)\n                if windMultVal == False: windSpeed = duplicateData(windSpeed, calcLength2)\n                if metMultVal == False: metRate = duplicateData(metRate, calcLength2)\n                if cloMultVal == False: cloLevel = duplicateData(cloLevel, calcLength2)\n                exWork = duplicateData([0], calcLength2)\n            else:\n                calcLength = None\n                warning = 'If you have put in lists with multiple values for meanRadTemperature, windSpeed, clothingLevel, or metabolicRate, the lengths of these lists must match across the parameters or you have a single value for a given parameter to be applied to all values in the list.'\n                print warning\n                ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n        else:\n            checkData9 = True\n            calcLength2 = 1\n            exWork = [0]\n    else:\n        calcLength2 = 0\n        exWork = []\n    \n    # Check the humidity ratio upper and lower bounds and assign defaults if none are connected.\n    checkData10 = True\n    if comfortPar_ != []:\n        try:\n            PPDComfortThresh = float(comfortPar_[0])\n            humidRatioUp = float(comfortPar_[1])\n            humidRatioLow = float(comfortPar_[2])\n        except:\n            PPDComfortThresh = 10.0\n            humidRatioUp = 0.030\n            humidRatioLow = 0.0\n            checkData10 = False\n            warning = 'The comfortPar_ are not valid comfort parameters from the Ladybug_Comfort Parameters component.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    else:\n        PPDComfortThresh = 10.0\n        humidRatioUp = 0.030\n        humidRatioLow = 0.0\n    \n    #Check the annualhourly data and conditional statement\n    checkData11 = True\n    listInfo = []\n    annualHourlyData = _dryBulbTemperature + _relativeHumidity + annualHourlyData_\n    if epwData == True and len(_dryBulbTemperature + _relativeHumidity) > 17533 and conditionalStatement_:\n        titleStatement, patternList, indexList, listInfo = checkConditionalStatement(annualHourlyData, conditionalStatement_)\n        \n        if titleStatement == -1 or patternList == -1:\n            checkData11 = False\n    else:\n        titleStatement = None\n        patternList = []\n    \n    # Check the passive strategy inputs to be sure that they are correct.\n    checkData12 = True\n    solarCheck = False\n    if len(passiveStrategy_) > 0:\n        for item in passiveStrategy_:\n            if item == \"Evaporative Cooling\" or item == \"Thermal Mass + Night Vent\"  or item == \"Occupant Use of Fans\" or item == \"Internal Heat Gain\" or item == \"Humidification Only\" or item == \"Dehumidification Only\" or item == \"Dessicant Dehumidification\":\n                pass\n            elif item == \"Passive Solar Heating\":\n                solarCheck = True\n            else:\n                checkData12 = False\n    if checkData12 == False:\n        warning = 'Input for passiveStrategy_ is not valid.'\n        print warning\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    \n    # If passive solar is connected as a strategy, make sure that globalHorizontalRadiation is connected for annualHourlyData.\n    globHorizRad = []\n    checkData15 = True\n    if solarCheck == True:\n        if annualHourlyData_ == []:\n            checkData15 = False\n        elif listInfo == []:\n            lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n            indexList, listInfo = lb_preparation.separateList(annualHourlyData_, lb_preparation.strToBeFound)\n        \n        if checkData15 == True:\n            checkData15 = False\n            for count, datList in enumerate(listInfo):\n                if 'Radiation' in datList[2] and ('Total' in datList[2] or 'Global' in datList[2]):\n                    checkData15 = True\n    if checkData15 == False:\n        warning = 'If \"Passive Solar Heating\" is requested on the passiveStrategy_ input, you must connect\\n' + \\\n        \"solar radiation values to the annualHourlyData_ input of this component.\\n\" + \\\n        \"These radiation values should be the total solar flux falling on a window surface.\\n\" +\\\n        \"So connecting an EPW's globalHorizontalRadiation will approximate passive solar heat through a skylight\\n\"+\\\n        \"and using the Ladybug_Surface Hourly Solar component will allow you to calculate this for a window facing any direction.\"\n        print warning\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    \n    #Check to be sure that epw data has been connected and the calculation length is 8760 if the user has connected an analysis period.\n    checkData13 = True\n    if analysisPeriod_ != []:\n        if epwData == True and calcLength == 8760: pass\n        else:\n            checkData13 = False\n            warning = 'Analysis periods can only be used with EPW or EnergyPlus simulation data that is hourly for the full year.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    \n    #Average all of the barometric pressures together (this is the pressure that will be used to construct the chart).\n    if len(barPress) > 1: avgBarPress = (sum(barPress)/len(barPress))\n    elif len(barPress) ==1: avgBarPress = barPress[0]\n    else: avgBarPress = None\n    \n    #If all of the checkDatas have been good to go, let's give a final go ahead.\n    if checkData1 == True and checkData2 == True and checkData3 == True and checkData4 == True and checkData5 == True and checkData6 == True and checkData7 == True and checkData8 == True and checkData9 == True and checkData10 == True and checkData11 == True and checkData12 == True and checkData13 == True:\n        checkData = True\n    else:\n        checkData = False\n    \n    \n    #Let's return everything we need.\n    return checkData, epwData, epwStr, calcLength, airTemp, relHumid, barPress, avgBarPress, radTemp, windSpeed, metRate, cloLevel, exWork, humidRatioUp, humidRatioLow, calcLength2, PPDComfortThresh, titleStatement, patternList, IPTrigger, farenheitVals, opTemp\n\n\ndef checkConditionalStatement(annualHourlyData, conditionalStatement):\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n        indexList, listInfo = lb_preparation.separateList(annualHourlyData, lb_preparation.strToBeFound)\n        \n        letters = [chr(i) for i in xrange(ord('a'), ord('z')+1)]\n        # remove 'and' and 'or' from conditional statements\n        csCleaned = conditionalStatement.replace('and', '',20000)\n        csCleaned = csCleaned.replace('or', '',20000).replace('not', '',20000)\n        \n        # find the number of the lists that have assigned conditional statements\n        listNum = []\n        for count, let in enumerate(letters):\n            if csCleaned.find(let)!= -1: listNum.append(count)\n        \n        # check if all the conditions are actually applicable\n        for num in listNum:\n            if num>len(listInfo) - 1:\n                warning = 'A conditional statement is assigned for list number ' + `num + 1` + '  which is not existed!\\n' + \\\n                          'Please remove the letter \"' + letters[num] + '\" from the statements to solve this problem!\\n' + \\\n                          'Number of lists are ' + `len(listInfo)` + '. Please fix this issue and try again.'\n                          \n                print warning\n                ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n                return -1, -1\n        \n        selList = [[]] * len(listInfo)\n        for i in range(len(listInfo)):\n            selList[i] = annualHourlyData[indexList[i]+7:indexList[i+1]]\n            if listInfo[i][4]!='Hourly' or listInfo[i][5]!=(1,1,1) or  listInfo[i][6]!=(12,31,24) or len(selList[i])!=8760:\n                warning = 'At least one of the input data lists is not a valis ladybug hourly data! Please fix this issue and try again!\\n List number = '+ `i+1`\n                print warning\n                ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n                return -1, -1\n        \n        # replace the right list in the conditional statement\n        statement = conditionalStatement.split(' ')\n        finalStatement = 'pattern = '\n        titleStatement = '...                         ...                         ...\\n' +\\\n                         'Conditional Selection Applied:\\n'\n        \n        for statemntPart in statement:\n            statementCopy = str.Copy(statemntPart)\n            if statemntPart!='and' and statemntPart!='or':\n                for num in listNum:\n                    toBeReplacedWith = 'selList[this][HOY]'.replace('this', `num`)\n                    titleToBeReplacedWith = listInfo[num][2]\n                    statemntPart = statemntPart.replace(letters[num], toBeReplacedWith, 20000)\n                    statementCopy = statementCopy.replace(letters[num], titleToBeReplacedWith, 20000)\n                    if statementCopy.find(letters[num])!=-1: break\n                    \n                titleStatement = titleStatement + ' ' + statementCopy\n            else:\n                titleStatement = titleStatement + '\\n' + statementCopy \n            finalStatement = finalStatement + ' ' + statemntPart\n        print titleStatement\n        \n        # check for the pattern\n        patternList = []\n        try:\n            for HOY in range(8760):\n                exec(finalStatement)\n                patternList.append(pattern)\n        except Exception,e:\n            warning = 'There is an error in the conditional statement:\\n' + `e`\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n            return -1, -1\n        \n        return titleStatement, patternList, indexList, listInfo\n\n\ndef drawPsychChart(avgBarPress, lb_comfortModels, legendFont, legendFontSize, legendBold, scaleFactor, epwData, epwStr, IPTrigger, opTemp, lb_visualization):\n    #Set a default text height if the user has not provided one.\n    if legendFontSize == None:\n        if IPTrigger: legendFontSize = 1\n        else: legendFontSize = 0.6\n    \n    #Generate a list of temperatures that will be used to make the relative humidity curves.\n    if IPTrigger:\n        tempChartVals = range(-5, 120, 5)\n        tempNum = F2C(tempChartVals)\n    else: tempChartVals = tempNum = range(-20, 55, 5)\n    relHumidNum = range(10, 110, 10)\n    \n    #Set up a list of lists to hold the humidity ratio values and make a list of the barometric pressure.\n    humidRatio = []\n    barPressList = []\n    for item in tempNum:\n        barPressList.append(avgBarPress)\n    \n    #Get humidity ratio values for each of the temperatures at the different relative humidity levels.\n    for relHumid in relHumidNum:\n        relHumidList = []\n        for item in tempNum:\n            relHumidList.append(relHumid)\n        HR, EN, vapPress, satPress = lb_comfortModels.calcHumidRatio(tempNum, relHumidList, barPressList)\n        \n        humidRatio.append(HR)\n    \n    #Put a scale factor on the humidty ratio to make it on the same scale as the temperature.\n    for listCount, list in enumerate(humidRatio):\n        for count, num in enumerate(list):\n            humidRatio[listCount][count] = num*scaleFactor\n    \n    #Use the humidity ratio and the dry bulb temperature to create coordinates for the lines.\n    humidLinePts = []\n    for list in humidRatio:\n        linePts = []\n        for count, item in enumerate(list):\n            linePts.append(rc.Geometry.Point3d(tempChartVals[count], item, 0))\n        humidLinePts.append(linePts)\n    \n    #Make the chart relative humidity lines.\n    humidCurves = []\n    humidCurves.append(rc.Geometry.LineCurve(rc.Geometry.Point3d(tempChartVals[0], 0, 0), rc.Geometry.Point3d(tempChartVals[-1], 0, 0)))\n    for pointList in humidLinePts:\n        humidCurves.append(rc.Geometry.Curve.CreateInterpolatedCurve(pointList, 3))\n    \n    #If the humidity ratio goes larger than 0.030, chop off the humidity line there.\n    maxLine = rc.Geometry.LineCurve(rc.Geometry.Point3d(tempChartVals[0], 0.03 * scaleFactor, 0), rc.Geometry.Point3d(tempChartVals[-1], 0.03 * scaleFactor, 0))\n    maxBrep = rc.Geometry.Brep.CreateFromSurface(rc.Geometry.Surface.CreateExtrusion(maxLine, rc.Geometry.Vector3d.ZAxis))\n    maxhumidCurves = []\n    for curve in humidCurves:\n        splitCrv = curve.Split(maxBrep, sc.doc.ModelAbsoluteTolerance)\n        if len(splitCrv) != 0:\n            maxhumidCurves.append(splitCrv[0])\n        else:\n            maxhumidCurves.append(curve)\n    \n    #Make the isothermal lines.\n    tempCurves = []\n    tempLabelBasePts = []\n    tempText = []\n    for count, temp in enumerate(tempChartVals):\n        tempCurves.append(rc.Geometry.LineCurve(rc.Geometry.Point3d(temp, 0, 0), rc.Geometry.Point3d(temp, humidRatio[-1][count], 0)))\n        tempLabelBasePts.append(rc.Geometry.Point3d(temp-0.75, -1.3*legendFontSize, 0))\n        tempText.append(str(temp))\n    if mollierHX_ == True:\n        for ptCount, point in enumerate(tempLabelBasePts):\n            mollierHXTransform(point)\n            tempLabelBasePts[ptCount] = rc.Geometry.Point3d(point.X-(1.5*legendFontSize), point.Y+(0.25/legendFontSize), 0)\n    \n    #Split the isothermal lines.\n    maxTempCurves = []\n    for curve in tempCurves:\n        splitCrv = curve.Split(maxBrep, sc.doc.ModelAbsoluteTolerance)\n        if len(splitCrv) != 0:\n            maxTempCurves.append(splitCrv[0])\n        else:\n            maxTempCurves.append(curve)\n    \n    #Make the lines of constant humidity ratio.\n    satBrep = rc.Geometry.Brep.CreateFromSurface(rc.Geometry.Surface.CreateExtrusion(humidCurves[-1], rc.Geometry.Vector3d.ZAxis))\n    hrLines = []\n    ratioList = []\n    ratioText = []\n    ratioBasePt = []\n    ratioStart = (0.03*scaleFactor)/6\n    for index in range(6):\n        ratioList.append(ratioStart)\n        ratioStart += (0.03*scaleFactor)/6\n    for ratio in ratioList:\n        hrLines.append(rc.Geometry.LineCurve(rc.Geometry.Point3d(tempChartVals[0], ratio, 0), rc.Geometry.Point3d(tempChartVals[-1], ratio, 0)))\n        ratioText.append(str(ratio/scaleFactor))\n        ratioBasePt.append(rc.Geometry.Point3d(tempChartVals[-1]+.5, ratio-.375, 0))\n    maxHrLines = []\n    for curve in hrLines:\n        splitCrv = curve.Split(satBrep, sc.doc.ModelAbsoluteTolerance)\n        if len(splitCrv) != 0:\n            maxHrLines.append(splitCrv[-1])\n        else:\n            maxHrLines.append(curve)\n    if mollierHX_ == True:\n        for ptCount, point in enumerate(ratioBasePt):\n            mollierHXTransform(point)\n            ratioBasePt[ptCount] = rc.Geometry.Point3d(point.X-(legendFontSize), point.Y, 0)\n    topBrep = rc.Geometry.Brep.CreateFromSurface(rc.Geometry.Surface.CreateExtrusion(maxHrLines[-1], rc.Geometry.Vector3d.ZAxis))\n    \n    #Make lines of constant enthalpy or wet bulb temperature.\n    if enthalpyOrWetBulb_ == True or enthalpyOrWetBulb_ == None:\n        if IPTrigger:\n            enthalpyForLines = range(0,55,5)\n            celciEnthalpyForLines = BTUlb2kJkg(enthalpyForLines)\n        else:\n            celciEnthalpyForLines = enthalpyForLines = range(-10,120,10)\n        enthalLines = []\n        enthText = []\n        \n        for ecount, enthl in enumerate(enthalpyForLines):\n            if IPTrigger: enthText.append(str(enthl)+\" BTU/lb\")\n            else: enthText.append(str(enthl)+\" kJ/kg\")\n            startVal = lb_comfortModels.calcTempFromEnthalpy(celciEnthalpyForLines[ecount], 0.0)\n            if IPTrigger: startVal = C2F([startVal])[0]\n            startPt = rc.Geometry.Point3d(startVal, 0.0, 0.0)\n            endVal = lb_comfortModels.calcTempFromEnthalpy(celciEnthalpyForLines[ecount], 0.03)\n            if IPTrigger: endVal = C2F([endVal])[0]\n            endPt = rc.Geometry.Point3d(endVal, 0.03*scaleFactor, 0.0)\n            enthLine = rc.Geometry.LineCurve(startPt, endPt)\n            enthalLines.append(enthLine)\n    else:\n        if IPTrigger:\n            wetBulbForLines = range(-5,95,5)\n            celciWetBulbForLines = F2C(wetBulbForLines)\n        else:\n            celciWetBulbForLines = wetBulbForLines = range(-20,36,2)\n        enthalLines = []\n        enthText = []\n        \n        for ecount, enthl in enumerate(wetBulbForLines):\n            if IPTrigger: enthText.append(str(enthl)+\" F\")\n            else: enthText.append(str(enthl)+\" C\")\n            startRH = 0\n            startVal, startHR = lb_comfortModels.calcTempFromWetBulb(celciWetBulbForLines[ecount], startRH, avgBarPress)\n            if IPTrigger: startVal = C2F([startVal])[0]\n            startPt = rc.Geometry.Point3d(startVal, startHR, 0.0)\n            endRH = 100\n            endVal, endHR = lb_comfortModels.calcTempFromWetBulb(celciWetBulbForLines[ecount], endRH, avgBarPress)\n            if IPTrigger: endVal = C2F([endVal])[0]\n            endPt = rc.Geometry.Point3d(endVal, endHR*scaleFactor, 0.0)\n            enthLine = rc.Geometry.LineCurve(startPt, endPt)\n            enthalLines.append(enthLine)\n    \n    #Split the enthalpy/wet bulb lines with the boundary of the chart.\n    for crvCount, curve in enumerate(enthalLines):\n        splitCrv = curve.Split(satBrep, sc.doc.ModelAbsoluteTolerance)\n        if len(splitCrv) != 0: enthalLines[crvCount] = splitCrv[0]\n    maxHRBrep = rc.Geometry.Brep.CreateFromSurface(rc.Geometry.Surface.CreateExtrusion(maxHrLines[-1], rc.Geometry.Vector3d.ZAxis))\n    for crvCount, curve in enumerate(enthalLines):\n        splitCrv = curve.Split(maxHRBrep, sc.doc.ModelAbsoluteTolerance)\n        if len(splitCrv) != 0: enthalLines[crvCount] = splitCrv[0]\n    maxTBrep = rc.Geometry.Brep.CreateFromSurface(rc.Geometry.Surface.CreateExtrusion(maxTempCurves[-1], rc.Geometry.Vector3d.ZAxis))\n    for crvCount, curve in enumerate(enthalLines):\n        splitCrv = curve.Split(maxTBrep, sc.doc.ModelAbsoluteTolerance)\n        if len(splitCrv) != 0: enthalLines[crvCount] = splitCrv[-1]\n    \n    #Make the text for the lines of constant enthalpy.\n    enthLabelBasePts = []\n    if enthalpyOrWetBulb_ == True or enthalpyOrWetBulb_ == None: textFactor = 5\n    else: textFactor = 3\n    if mollierHX_:\n        if enthalpyOrWetBulb_ == True or enthalpyOrWetBulb_ == None: vertTFactor = 1.26\n        else: vertTFactor = 0.75\n    else: vertTFactor = None\n    \n    for count, enth in enumerate(enthalLines):\n        enthLabelBasePts.append(rc.Geometry.Point3d(enth.PointAtEnd.X-(legendFontSize*textFactor), enth.PointAtEnd.Y+(legendFontSize*0.5), 0))\n    if mollierHX_ == True:\n        for ptCount, point in enumerate(enthLabelBasePts):\n            mollierHXTransform(point)\n            enthLabelBasePts[ptCount] = rc.Geometry.Point3d(point.X, point.Y+(vertTFactor/legendFontSize), 0)\n    \n    # Bring all of the curves into one list.\n    chartText = []\n    chartTextPt = []\n    chartCurves = []\n    chartCurves.extend(maxhumidCurves)\n    chartCurves.extend(maxTempCurves)\n    chartCurves.extend(maxHrLines)\n    chartCurves.extend(enthalLines)\n    \n    # Make the temperature text for the chart.\n    chartText.extend(tempText)\n    chartTextPt.extend(tempLabelBasePts)\n    tempLabels = []\n    for count, text in enumerate(tempText):\n        tempLabels.extend(lb_visualization.text2srf([text], [tempLabelBasePts[count]], legendFont, legendFontSize, legendBold)[0])\n    \n    # Make the humidity ratio text for the chart.\n    chartText.extend(ratioText)\n    chartTextPt.extend(ratioBasePt)\n    ratioLabels = []\n    for count, text in enumerate(ratioText):\n        ratioLabels.extend(lb_visualization.text2srf([text], [ratioBasePt[count]], legendFont, legendFontSize, legendBold)[0])\n    \n    # Make the relative humidity text for the chart.\n    relHumidBasePts = []\n    relHumidTxt = []\n    relHumidLabels = []\n    for curve in maxhumidCurves[1:]:\n        curvePt = curve.PointAtNormalizedLength(0.98)\n        relHumidBasePts.append(rc.Geometry.Point3d(curvePt.X-1.75, curvePt.Y, 0))\n    if mollierHX_ == True:\n        for ptCount, point in enumerate(relHumidBasePts):\n            mollierHXTransform(point)\n            relHumidBasePts[ptCount] = rc.Geometry.Point3d(point.X, point.Y+(0.5/legendFontSize), 0)\n    for humid in relHumidNum:\n        relHumidTxt.append(str(humid)+\"%\")\n    chartText.extend(relHumidTxt[:-1])\n    chartTextPt.extend(relHumidBasePts[:-1])\n    for count, text in enumerate(relHumidTxt[:-1]):\n        relHumidLabels.extend(lb_visualization.text2srf([text], [relHumidBasePts[count]], legendFont, legendFontSize*.75, legendBold)[0])\n    \n    #Make the enthalpy labels for the chart.\n    chartText.extend(enthText)\n    chartTextPt.extend(enthLabelBasePts)\n    enthLabels = []\n    for count, text in enumerate(enthText):\n        enthLabels.extend(lb_visualization.text2srf([text], [enthLabelBasePts[count]], legendFont, legendFontSize*0.75, legendBold)[0])\n    \n    #Make axis labels for the chart.\n    xAxisLabels = []\n    unitlLabel = ' [C]'\n    if IPTrigger:\n        unitlLabel = ' [F]'\n    if opTemp == True:\n        xAxisTxt = [\"Operative Temperature\" + unitlLabel]\n    else:\n        xAxisTxt = [\"Dry Bulb Temperature\" + unitlLabel]\n    if mollierHX_ == True: xAxisPt = [rc.Geometry.Point3d(-5*legendFontSize, 15, 0)]\n    else: xAxisPt = [rc.Geometry.Point3d(tempChartVals[0]-0.5, -4*legendFontSize, 0)]\n    xAxisLabels.extend(lb_visualization.text2srf(xAxisTxt, xAxisPt, legendFont, legendFontSize*1.25, legendBold)[0])\n    if mollierHX_ == True:\n        rotateTransf = rc.Geometry.Transform.Rotation(1.57079633, xAxisPt[0])\n        for geo in xAxisLabels:\n            geo.Transform(rotateTransf)\n    chartText.extend(xAxisTxt)\n    chartTextPt.extend(xAxisPt)\n    \n    unitlLabel = ' [kg water/ kg air]'\n    if IPTrigger:\n        unitlLabel = ' [lb water/ lb air]'\n    yAxisLabels = []\n    yAxisTxt = [\"Humidity Ratio\" + unitlLabel]\n    if mollierHX_ == True:\n        if IPTrigger: yAxisPt = [rc.Geometry.Point3d(40, 115+(4*legendFontSize), 0)]\n        else: yAxisPt = [rc.Geometry.Point3d(15, 50+(4*legendFontSize), 0)]\n        yAxisLabels.extend(lb_visualization.text2srf(yAxisTxt, yAxisPt, legendFont, legendFontSize*1.25, legendBold)[0])\n    else:\n        yAxisPt = [rc.Geometry.Point3d(tempChartVals[-1]+(7*legendFontSize), 0.018*scaleFactor, 0)]\n        yAxisLabels.extend(lb_visualization.text2srf(yAxisTxt, yAxisPt, legendFont, legendFontSize*1.25, legendBold)[0])\n        rotateTransf = rc.Geometry.Transform.Rotation(1.57079633, rc.Geometry.Point3d(tempChartVals[-1]+(7*legendFontSize), 0.018*scaleFactor, 0))\n        for geo in yAxisLabels:\n            geo.Transform(rotateTransf)\n    chartText.extend(yAxisTxt)\n    chartTextPt.extend(yAxisPt)\n    \n    #Make the chart title.\n    def getDateStr(start, end):\n        stMonth, stDay, stHour, endMonth, endDay, endHour = lb_visualization.readRunPeriod((start, end), False)\n        period = `stDay`+ ' ' + lb_visualization.monthList[stMonth-1] + ' ' + `stHour` + ':00' + \\\n                 \" - \" + `endDay`+ ' ' + lb_visualization.monthList[endMonth-1] + ' ' + `endHour` + ':00'\n        return period\n    \n    titleLabels = []\n    if epwData == True:\n        if mollierHX_ == True: titleTxt = [\"Mollier HX Diagram\", epwStr[1]]\n        else: titleTxt = [\"Psychrometric Chart\", epwStr[1]]\n        if analysisPeriod_ == []:\n            titleTxt.append(getDateStr(epwStr[5], epwStr[6]))\n        else:\n            titleTxt.append(getDateStr(analysisPeriod_[0], analysisPeriod_[1]))\n    else: titleTxt = [\"Psychrometric Chart\", \"Unkown Location\", \"Unknown Time Period\"]\n    if mollierHX_ == True: titlePt = [rc.Geometry.Point3d(20, -0.011*scaleFactor, 0), rc.Geometry.Point3d(20, (-0.011*scaleFactor)-(legendFontSize*2.5), 0),  rc.Geometry.Point3d(20, (-0.011*scaleFactor)-(legendFontSize*5), 0)]\n    else: titlePt = [rc.Geometry.Point3d(-19, 0.0295*scaleFactor, 0), rc.Geometry.Point3d(-19, (0.0295*scaleFactor)-(legendFontSize*2.5), 0),  rc.Geometry.Point3d(-19, (0.0295*scaleFactor)-(legendFontSize*5), 0)]\n    for count, text in enumerate(titleTxt):\n        titleLabels.extend(lb_visualization.text2srf([text], [titlePt[count]], legendFont, legendFontSize*1.5, legendBold)[0])\n    chartText.extend(titleTxt)\n    chartTextPt.extend(titlePt)\n    \n    #Bring all text and curves together in one list.\n    chartCrvAndText = []\n    for item in chartCurves: chartCrvAndText.append(item)\n    for item in tempLabels: chartCrvAndText.append(item)\n    for item in ratioLabels: chartCrvAndText.append(item)\n    for item in relHumidLabels:\n        chartCrvAndText.append(item)\n    for item in xAxisLabels:\n        chartCrvAndText.append(item)\n    for item in yAxisLabels:\n        chartCrvAndText.append(item)\n    for item in titleLabels:\n        chartCrvAndText.append(item)\n    for item in enthLabels:\n        chartCrvAndText.append(item)\n    \n    \n    return chartCrvAndText, humidCurves, chartText, chartTextPt\n\n\ndef colorMesh(airTemp, relHumid, barPress, lb_preparation, lb_comfortModels, lb_visualization, scaleFactor, lowB, highB, customColors, IPTrigger, farenheitVals):\n    # Make the full chart mesh\n    #Generate a list of temperatures that will be used to make the mesh.\n    if IPTrigger:\n        initVal = -5\n        tempNumMesh = []\n        for tempVal in range(73):\n            tempNumMesh.append(initVal)\n            initVal += (5/3)\n        #tempNumMesh = range(-5, 116, 1)\n        celNumMesh = F2C(tempNumMesh)\n    else: celNumMesh = tempNumMesh = range(-20, 51, 1)\n    relHumidNumMesh = range(0, 105, 5)\n    \n    #Get humidity ratio values for each of the temperatures at the different relative humidity levels.\n    humidRatioMesh = []\n    for relHum in relHumidNumMesh:\n        relHumidListMesh = []\n        for item in tempNumMesh:\n            relHumidListMesh.append(relHum)\n        pressList = []\n        for item in tempNumMesh:\n            pressList.append(avgBarPress)\n        HR, EN, vapPress, satPress = lb_comfortModels.calcHumidRatio(celNumMesh, relHumidListMesh, pressList)\n        for count, num in enumerate(HR):\n            HR[count] = num*scaleFactor\n        humidRatioMesh.append(HR)\n    \n    #Make the mesh faces.\n    chartMesh = rc.Geometry.Mesh()\n    meshFacePts = []\n    \n    for listCount, humilist in enumerate(humidRatioMesh[:-1]):\n        for tempCount, temp in enumerate(tempNumMesh[:-1]):\n            facePt1 = rc.Geometry.Point3d(temp, humilist[tempCount], 0)\n            facePt2 = rc.Geometry.Point3d(temp, humidRatioMesh[listCount+1][tempCount], 0)\n            facePt3 = rc.Geometry.Point3d(tempNumMesh[tempCount+1], humidRatioMesh[listCount+1][tempCount+1], 0)\n            facePt4 = rc.Geometry.Point3d(tempNumMesh[tempCount+1], humilist[tempCount+1], 0)\n            \n            meshFacePts.append([facePt1, facePt2, facePt3, facePt4])\n    \n    for ptlist in  meshFacePts:\n        mesh = rc.Geometry.Mesh()\n        for point in ptlist:\n            mesh.Vertices.Add(point)\n        \n        mesh.Faces.AddFace(0, 1, 2, 3)\n        chartMesh.Append(mesh)\n    uncoloredMesh = chartMesh\n    \n    #Calculate the humidity ratio for each of the hours of the year and use this to make points for the chart.\n    HR, EN, vapPress, satPress = lb_comfortModels.calcHumidRatio(airTemp, relHumid, barPress)\n    hourPts = []\n    for count, ratio in enumerate(HR):\n        if IPTrigger: hourPts.append(rc.Geometry.Point3d(farenheitVals[count], ratio*scaleFactor, 0))\n        else: hourPts.append(rc.Geometry.Point3d(airTemp[count], ratio*scaleFactor, 0))\n    \n    #Make a list to hold values for all of the mesh faces.\n    meshFrequency = []\n    for count, value in enumerate(range(0, 100, 5)):\n        meshFrequency.append([])\n        if IPTrigger:\n            for face in range(72): meshFrequency[count].append([])\n        else:\n            for face in range(-20, 50, 1): meshFrequency[count].append([])\n    \n    #Bin the input humidity and temperatures into categories that correspond to the mesh faces.\n    def getTempIndex(hour):\n        if airTemp[hour] > -20 and airTemp[hour] < 50:\n            index  = int(round(airTemp[hour] +19.5))\n        else: index = -1\n        return index\n    \n    def getTempIndexIP(hour):\n        if farenheitVals[hour] > -5 and farenheitVals[hour] < 115:\n            index  = int((farenheitVals[hour] +4.5)*(3/5))\n        else: index = -1\n        return index\n    \n    for hour, humid in enumerate(relHumid):\n        if IPTrigger: tempIndex = getTempIndexIP(hour)\n        else: tempIndex = getTempIndex(hour)\n        if tempIndex != -1:\n            if humid < 5: meshFrequency[0][tempIndex].append(1)\n            elif humid < 10: meshFrequency[1][tempIndex].append(1)\n            elif humid < 15:meshFrequency[2][tempIndex].append(1)\n            elif humid < 20:meshFrequency[3][tempIndex].append(1)\n            elif humid < 25:meshFrequency[4][tempIndex].append(1)\n            elif humid < 30:meshFrequency[5][tempIndex].append(1)\n            elif humid < 35:meshFrequency[6][tempIndex].append(1)\n            elif humid < 40:meshFrequency[7][tempIndex].append(1)\n            elif humid < 45:meshFrequency[8][tempIndex].append(1)\n            elif humid < 50:meshFrequency[9][tempIndex].append(1)\n            elif humid < 55:meshFrequency[10][tempIndex].append(1)\n            elif humid < 60:meshFrequency[11][tempIndex].append(1)\n            elif humid < 65:meshFrequency[12][tempIndex].append(1)\n            elif humid < 70:meshFrequency[13][tempIndex].append(1)\n            elif humid < 75:meshFrequency[14][tempIndex].append(1)\n            elif humid < 80:meshFrequency[15][tempIndex].append(1)\n            elif humid < 85:meshFrequency[16][tempIndex].append(1)\n            elif humid < 90:meshFrequency[17][tempIndex].append(1)\n            elif humid < 95:meshFrequency[18][tempIndex].append(1)\n            else: meshFrequency[19][tempIndex].append(1)\n    \n    #Sum all of the lists together to get the frequency.\n    finalMeshFrequency = []\n    for humidlist in meshFrequency:\n        for templist in humidlist:\n            finalMeshFrequency.append(sum(templist))\n    \n    #Get a list of colors\n    colors = lb_visualization.gradientColor(finalMeshFrequency, lowB, highB, customColors)\n    \n    # color the mesh faces.\n    uncoloredMesh.VertexColors.CreateMonotoneMesh(System.Drawing.Color.Gray)\n    \n    for srfNum in range (uncoloredMesh.Faces.Count):\n        uncoloredMesh.VertexColors[4 * srfNum + 0] = colors[srfNum]\n        uncoloredMesh.VertexColors[4 * srfNum + 1] = colors[srfNum]\n        uncoloredMesh.VertexColors[4 * srfNum + 3] = colors[srfNum]\n        uncoloredMesh.VertexColors[4 * srfNum + 2] = colors[srfNum]\n    \n    # Remove the mesh faces that do not have any hour associated with them.\n    cullFaceIndices = []\n    for count, freq in enumerate(finalMeshFrequency):\n        if freq == 0:\n            cullFaceIndices.append(count)\n    uncoloredMesh.Faces.DeleteFaces(cullFaceIndices)\n    \n    #Flip the mesh to be sure that it always displays correctly.\n    uncoloredMesh.Flip(True, True, True)\n    \n    #Return everything that's useful.\n    return hourPts, uncoloredMesh, finalMeshFrequency\n\n\ndef unionAllCurves(Curves):\n    res = []\n    \n    for curveCount in range(0, len(Curves), 2):\n        try:\n            sc.doc = rc.RhinoDoc.ActiveDoc #change target document\n            \n            rs.EnableRedraw(False)\n            \n            guid1 = sc.doc.Objects.AddCurve(Curves[curveCount])\n            guid2 = sc.doc.Objects.AddCurve(Curves[curveCount + 1])\n            all = rs.CurveBooleanUnion([guid1, guid2])\n            rs.DeleteObjects(guid1)\n            rs.DeleteObjects(guid2)\n            if all:\n                a = [rs.coercegeometry(a) for a in all]\n                for g in a: g.EnsurePrivateCopy() #must ensure copy if we delete from doc\n            \n            rs.DeleteObjects(all)\n            \n            sc.doc = ghdoc #put back document\n            rs.EnableRedraw()\n            \n            if a == None:\n                a = [Curves[curveCount], Curves[curveCount + 1]]\n        except:\n            rs.DeleteObjects(guid1)\n            sc.doc = ghdoc #put back document\n            rs.EnableRedraw()\n            a = [Curves[curveCount]]\n        \n        if a:\n            res.extend(a)\n    return res\n\n\ndef calcComfAndStrategyPolygons(radTemp, windSpeed, metRate, cloLevel, exWork, humidRatioUp, humidRatioLow, passiveStrategy, relHumidLines, calcLengthComf, lb_comfortModels, chartBoundary, scaleFactor, PPDComfortThresh, IPTrigger, opTemp, globHorizRad, airTemp, origAirTemp, origGlobHorizRad, origHrs):\n    #Take just the top middle and bottom lines for making the comofrt range in order to speed up the calculation.\n    relHumidLines = [relHumidLines[0], relHumidLines[5], relHumidLines[10]]\n    \n    #Define max/min temperatures.\n    if not IPTrigger:\n        maxTempe = 50\n        minTempe = -20\n    else:\n        maxTempe = C2F([50])[0]\n        minTempe = C2F([-20])[0]\n    \n    #Make a comfort polyline for each of the variables in the comfCalcLength.\n    #First get the points that represent the lower and upper bound of comfort at each relative humidty line.\n    comfPolyLinePts = []\n    for index in range(calcLengthComf):\n        upTemperPts = []\n        downTemperPts = []\n        for count, humidity in enumerate(range(0,150,50)):\n            upTemper, downTemper = lb_comfortModels.calcComfRange(radTemp[index], windSpeed[index], humidity, metRate[index], cloLevel[index], exWork[index], PPDComfortThresh, opTemp)\n            if IPTrigger == True: upTemper, downTemper = C2F([upTemper])[0], C2F([downTemper])[0]\n            \n            if upTemper < maxTempe:\n                if upTemper > minTempe:\n                    upIntersect = rc.Geometry.Intersect.Intersection.CurvePlane(relHumidLines[count], rc.Geometry.Plane(rc.Geometry.Point3d(upTemper, 0,0), rc.Geometry.Vector3d.XAxis), sc.doc.ModelAbsoluteTolerance)[0].PointA\n                else: upIntersect = relHumidLines[count].PointAtStart\n            else: upIntersect = relHumidLines[count].PointAtEnd\n            upTemperPts.append(upIntersect)\n            \n            if downTemper < maxTempe:\n                if downTemper > minTempe:\n                    downIntersect = rc.Geometry.Intersect.Intersection.CurvePlane(relHumidLines[count], rc.Geometry.Plane(rc.Geometry.Point3d(downTemper, 0,0), rc.Geometry.Vector3d.XAxis), sc.doc.ModelAbsoluteTolerance)[0].PointA\n                else: downIntersect = relHumidLines[count].PointAtStart\n            else: upIntersect = relHumidLines[count].PointAtEnd\n            downTemperPts.append(downIntersect)\n        comfPolyLinePts.append([upTemperPts, downTemperPts])\n    \n    #Use the collected points to define a boundary curve around the comfort zone.\n    chartBoundaryBrep = rc.Geometry.Surface.CreateExtrusion(chartBoundary, rc.Geometry.Vector3d.ZAxis)\n    comfortCurves = []\n    comfortCrvSegments = []\n    for futurePoly in comfPolyLinePts:\n        upperBoundary = rc.Geometry.Curve.CreateInterpolatedCurve(futurePoly[0], 3)\n        lowerBoundary = rc.Geometry.Curve.CreateInterpolatedCurve(futurePoly[1], 3)\n        try:\n            upperBoundary = upperBoundary.Split(chartBoundaryBrep, sc.doc.ModelAbsoluteTolerance)[0]\n            lowerBoundary = upperBoundary.Split(chartBoundaryBrep, sc.doc.ModelAbsoluteTolerance)[0]\n        except: pass\n        upperBrep = rc.Geometry.Brep.CreateFromSurface(rc.Geometry.Surface.CreateExtrusion(upperBoundary, rc.Geometry.Vector3d.ZAxis))\n        lowerBrep = rc.Geometry.Brep.CreateFromSurface(rc.Geometry.Surface.CreateExtrusion(lowerBoundary, rc.Geometry.Vector3d.ZAxis))\n        if str(rc.RhinoApp.Version).startswith('6'):\n            splitCurve = chartBoundary.Split(upperBrep, sc.doc.ModelAbsoluteTolerance)[-1]\n        else:\n            splitCurve = chartBoundary.Split(upperBrep, sc.doc.ModelAbsoluteTolerance)[0]\n        try:\n            bottomCurve = splitCurve.Split(lowerBrep, sc.doc.ModelAbsoluteTolerance)[0]\n            topCurve = splitCurve.Split(lowerBrep, sc.doc.ModelAbsoluteTolerance)[2]\n            joinedCurves = rc.Geometry.Curve.JoinCurves([upperBoundary, topCurve, lowerBoundary, bottomCurve])[0]\n            comfortCrvSegments.append([upperBoundary, lowerBoundary, topCurve, bottomCurve])\n            comfortCurves.append(joinedCurves)\n        except Exception as e:\n            print e\n            warning = 'Comfort polygon has fallen completely off of the psych chart.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    \n    # Default strategy parameters.\n    tempAboveComf = 12\n    tempBelowComf = 3\n    maxWindSpeed = 1\n    bldgBalPt = 12.8\n    solarHeatCap = 50\n    solarTimeConst = 8\n    polyStart = None\n    \n    if comfortCurves != []:\n        #If the user has speified a max or a min humidity ratio, use that to trim the comfort boundary.\n        if humidRatioUp != 0.03:\n            splittingLineUp = rc.Geometry.LineCurve(rc.Geometry.Point3d(-30, humidRatioUp*scaleFactor, 0), rc.Geometry.Point3d(120, humidRatioUp*scaleFactor, 0))\n            splittingBrepUp = rc.Geometry.Brep.CreateFromSurface(rc.Geometry.Surface.CreateExtrusion(splittingLineUp, rc.Geometry.Vector3d.ZAxis))\n            for count, curve in enumerate(comfortCurves):\n                try:\n                    splitCurves = curve.Split(splittingBrepUp, sc.doc.ModelAbsoluteTolerance)\n                    if len(splitCurves) > 1:\n                        joinedComfBound = rc.Geometry.Curve.JoinCurves([splitCurves[0], rc.Geometry.LineCurve(splitCurves[0].PointAtStart, splitCurves[0].PointAtEnd)])[0]\n                        comfortCurves[count] = joinedComfBound\n                    else: pass\n                except: pass\n        \n        if humidRatioLow != 0:\n            splittingLineLow = rc.Geometry.LineCurve(rc.Geometry.Point3d(-30, humidRatioLow*scaleFactor, 0), rc.Geometry.Point3d(120, humidRatioLow*scaleFactor, 0))\n            splittingBrepLow = rc.Geometry.Brep.CreateFromSurface(rc.Geometry.Surface.CreateExtrusion(splittingLineLow, rc.Geometry.Vector3d.ZAxis))\n            for count, curve in enumerate(comfortCurves):\n                try:\n                    splitCurves = curve.Split(splittingBrepLow, sc.doc.ModelAbsoluteTolerance)\n                    if len(splitCurves) > 1:\n                        joinedComfBound = rc.Geometry.Curve.JoinCurves([splitCurves[1], rc.Geometry.LineCurve(splitCurves[1].PointAtStart, splitCurves[1].PointAtEnd)])[0]\n                        comfortCurves[count] = joinedComfBound\n                    else: pass\n                except: pass\n        \n        #If the user has multiple comfort polygons and has selected to merge them, them merge them.\n        mergedCurvesFinal = comfortCurves\n        if len(comfortCurves) > 1 and mergeComfPolygons_ == True:\n            listLength = len(comfortCurves)\n            count  = 0\n            while len(mergedCurvesFinal) > 1 and count < int(listLength/2) + 1:\n                mergedCurvesFinal = unionAllCurves(mergedCurvesFinal)\n                count += 1\n            \n            if mergedCurvesFinal == None:\n                mergedCurvesFinal = comfortCurves\n                print \"Attempt to merge comfort curves failed.  Component will return multiple comfort boundaries.\"\n        \n        #Add the comfort polygons to the strategy list.\n        strategyListTest = []\n        if len(mergedCurvesFinal) == 1:\n            strategyListTest.append(\"Comfort\")\n        else:\n            for count, curve in enumerate(mergedCurvesFinal):\n                strategyListTest.append(\"Comfort \" + str(count))\n        \n        #Organize data to be used to construct the strategy curves\n        windSpeed.sort()\n        windSpeed[0] = windSpeed[-1]\n        cloLevel.sort()\n        cloLevel[0] = cloLevel[0]\n        upBoundXList = []\n        upBoundCrv = []\n        lowBoundXList = []\n        lowBoundCrv = []\n        for crvList in comfortCrvSegments:\n            upBoundXList.append(crvList[0].PointAtStart.X)\n            upBoundCrv.append(crvList[0])\n            lowBoundXList.append(crvList[1].PointAtEnd.X)\n            lowBoundCrv.append(crvList[1])\n        upBoundXList, upBoundCrv = zip(*sorted(zip(upBoundXList, upBoundCrv)))\n        comfortCrvSegments[0][0] = upBoundCrv[-1]\n        lowBoundXList, lowBoundCrv = zip(*sorted(zip(lowBoundXList, lowBoundCrv)))\n        comfortCrvSegments[0][1] = lowBoundCrv[0]\n        \n        # Calculate max and min temp.\n        maxComfortPolyTemp = comfortCrvSegments[0][0].PointAt(0.5).X\n        minComfortPolyTemp = comfortCrvSegments[0][1].PointAtEnd.X\n        \n        #Define a function to offset curves and return things that will stand out on the psychrometric chart.\n        def outlineCurve(curve):\n            try:\n                offsetCrv = curve.Offset(rc.Geometry.Plane.WorldXY, 0.15, sc.doc.ModelAbsoluteTolerance, rc.Geometry.CurveOffsetCornerStyle.Sharp)[0]\n                finalBrep = (rc.Geometry.Brep.CreatePlanarBreps([curve, offsetCrv])[0])\n                if finalBrep.Edges.Count < 3:\n                    finalBrep = curve\n            except:\n                finalBrep = curve\n                warning = \"Creating an outline of one of the comfort or strategy curves failed.  Component will return a solid brep.\"\n                print warning\n                w = gh.GH_RuntimeMessageLevel.Warning\n                ghenv.Component.AddRuntimeMessage(w, warning)\n            return finalBrep\n        \n        #Define a function that will extract the points from a polycurve line\n        def getCurvePoints(curve):\n            exploCurve = rc.Geometry.PolyCurve.DuplicateSegments(curve)\n            individPts = []\n            for line in exploCurve:\n                individPts.append(line.PointAtStart)\n            return individPts\n        \n        #Turn the comfort curve into a brep that will show up well on the chart.\n        finalComfortBreps = []\n        for curve in mergedCurvesFinal:\n            finalComfortBreps.append(outlineCurve(curve))\n        \n        #Evaluate each of the connected strategies and draw polygons for them on the chart.\n        passiveStrategyCurves = []\n        passiveStrategyBreps = []\n        \n        if len(passiveStrategy) != 0:\n            #If the user has connected strategy parameters, read them out.\n            if strategyPar_ != []:\n                if len(strategyPar_) == 6:\n                    tempAboveComf = strategyPar_[0]\n                    tempBelowComf = strategyPar_[1]\n                    maxWindSpeed = strategyPar_[2]\n                    bldgBalPt = strategyPar_[3]\n                    solarHeatCap = strategyPar_[4]\n                    solarTimeConst = strategyPar_[5]\n                else:\n                    warning = 'The strategyPar_ list does not contain valid data.  StrategyPar_ must come from the \"Ladybug_Passive Strategy Parameters\" component.'\n                    print warning\n                    w = gh.GH_RuntimeMessageLevel.Warning\n                    ghenv.Component.AddRuntimeMessage(w, warning)\n            \n            if IPTrigger:\n                tempAboveComf = C2F([tempAboveComf])[0]-32\n                tempBelowComf = C2F([tempBelowComf])[0]-32\n                bldgBalPt = C2F([bldgBalPt])[0]\n            \n            for comfCount, comfortCurve in enumerate([mergedCurvesFinal[0]]):\n                \n                #If the user has hooked up evaporative cooling, add an evaporative cooling curve to the chart.\n                if \"Evaporative Cooling\" in passiveStrategy:\n                    comfPolygonPts = getCurvePoints(comfortCurve)\n                    ptXYSum = []\n                    for point in comfPolygonPts:\n                        ptXYSum.append(point.X + point.Y)\n                    ptXYSum, comfPolygonPts = zip(*sorted(zip(ptXYSum, comfPolygonPts)))\n                    startPt = comfPolygonPts[-1]\n                    #Calculate the enthalpy at the start point.\n                    if IPTrigger:\n                        startTemp = F2C([startPt.X])[0]\n                        endTemp = F2C([115.5])[0]\n                    else:\n                        startTemp = startPt.X\n                        endTemp = 50.5\n                    enthalpy = (startTemp * (1.01 + 0.00189*((startPt.Y/scaleFactor)*1000))) + 2.5*((startPt.Y/scaleFactor)*1000)\n                    #If the temperature at the edge of the chart is 50C, use that to find another point of the line.\n                    newHR = (((enthalpy - endTemp) / 2.5945)/1000)* scaleFactor\n                    if IPTrigger: maxTempera = 115\n                    else: maxTempera = 50\n                    endPt = rc.Geometry.Point3d(maxTempera, newHR, 0)\n                    evapCoolLine = rc.Geometry.LineCurve(startPt, endPt)\n                    #If there is a minimum humidity ratio, use the comfort upper curve. otherwise, use the comfort bottom curve.\n                    if humidRatioLow == 0 and humidRatioUp*scaleFactor >= comfortCrvSegments[comfCount][0].PointAtEnd.Y:\n                        boundaryLine = comfortCrvSegments[comfCount][0]\n                        joinedEvapBound = rc.Geometry.Curve.JoinCurves([evapCoolLine, boundaryLine])[0]\n                    elif humidRatioLow == 0:\n                        boundaryLine = comfortCrvSegments[comfCount][0]\n                        boundaryLine = boundaryLine.Split(rc.Geometry.Brep.CreateFromSurface(rc.Geometry.Surface.CreateExtrusion(evapCoolLine, rc.Geometry.Vector3d.ZAxis)), sc.doc.ModelAbsoluteTolerance)[0]\n                        joinedEvapBound = rc.Geometry.Curve.JoinCurves([evapCoolLine, boundaryLine])[0]\n                    elif humidRatioUp*scaleFactor >= comfortCrvSegments[comfCount][0].PointAtEnd.Y:\n                        boundaryLine = comfortCrvSegments[comfCount][1]\n                        boundaryLine = boundaryLine.Split(splittingBrepLow, sc.doc.ModelAbsoluteTolerance)[0]\n                        transVector = rc.Geometry.Vector3d.Subtract(rc.Geometry.Vector3d(boundaryLine.PointAtEnd.X, boundaryLine.PointAtEnd.Y,boundaryLine.PointAtEnd.Z), rc.Geometry.Vector3d(evapCoolLine.PointAtStart.X, evapCoolLine.PointAtStart.Y,evapCoolLine.PointAtStart.Z))\n                        evapLine2 = evapCoolLine.DuplicateCurve()\n                        evapLine2.Translate(transVector)\n                        evapLine2 = evapLine2.Split(chartBoundaryBrep, sc.doc.ModelAbsoluteTolerance)[0]\n                        comfLine2 = comfortCrvSegments[comfCount][0].Split(splittingBrepLow, sc.doc.ModelAbsoluteTolerance)[1]\n                        comfLine1 = rc.Geometry.LineCurve(comfLine2.PointAtStart, boundaryLine.PointAtEnd)\n                        joinedEvapBound = rc.Geometry.Curve.JoinCurves([evapCoolLine, evapLine2, comfLine1, comfLine2])[0]\n                    else:\n                        boundaryLine = comfortCrvSegments[comfCount][1]\n                        boundaryLine = boundaryLine.Split(splittingBrepLow, sc.doc.ModelAbsoluteTolerance)[0]\n                        transVector = rc.Geometry.Vector3d.Subtract(rc.Geometry.Vector3d(boundaryLine.PointAtEnd.X, boundaryLine.PointAtEnd.Y,boundaryLine.PointAtEnd.Z), rc.Geometry.Vector3d(evapCoolLine.PointAtStart.X, evapCoolLine.PointAtStart.Y,evapCoolLine.PointAtStart.Z))\n                        evapLine2 = evapCoolLine.DuplicateCurve()\n                        evapLine2.Translate(transVector)\n                        evapLine2 = evapLine2.Split(chartBoundaryBrep, sc.doc.ModelAbsoluteTolerance)[0]\n                        comfLine2 = comfortCrvSegments[comfCount][0].Split(splittingBrepLow, sc.doc.ModelAbsoluteTolerance)[1]\n                        comfLine2 = comfLine2.Split(rc.Geometry.Brep.CreateFromSurface(rc.Geometry.Surface.CreateExtrusion(evapCoolLine, rc.Geometry.Vector3d.ZAxis)), sc.doc.ModelAbsoluteTolerance)[0]\n                        comfLine1 = rc.Geometry.LineCurve(comfLine2.PointAtStart, boundaryLine.PointAtEnd)\n                        joinedEvapBound = rc.Geometry.Curve.JoinCurves([evapCoolLine, evapLine2, comfLine1, comfLine2])[0]\n                    joinedEvapBrep = rc.Geometry.Brep.CreateFromSurface(rc.Geometry.Surface.CreateExtrusion(joinedEvapBound, rc.Geometry.Vector3d.ZAxis))\n                    chartBoundSegments = chartBoundary.Split(joinedEvapBrep, sc.doc.ModelAbsoluteTolerance)\n                    if len(chartBoundSegments) == 3:\n                        if str(rc.RhinoApp.Version).startswith('6'):\n                            segment = chartBoundSegments[1]\n                        else:\n                            segment = chartBoundSegments[2]\n                    else: \n                        if str(rc.RhinoApp.Version).startswith('6'):\n                            segment = chartBoundSegments[0]\n                        else:\n                            segment = chartBoundSegments[1]\n                    joinedEvapCoolBound = rc.Geometry.Curve.JoinCurves([joinedEvapBound, segment])[0]\n                    if humidRatioLow != 0 and str(rc.RhinoApp.Version).startswith('6'):\n                        joinedEvapCoolBound.Reverse()\n                    passiveStrategyCurves.append(joinedEvapCoolBound)\n                    passiveStrategyBreps.append(outlineCurve(joinedEvapCoolBound))\n                    strategyListTest.append(\"Evaporative Cooling\")\n                \n                #If the user has hooked up thermal mass and night flushing, add an thernal mass curve to the chart.\n                if \"Thermal Mass + Night Vent\" in passiveStrategy:\n                    #If there is a minimum humidity ratio, use the comfort upper curve. Otherwise, use the comfort bottom curve.\n                    ChartBoundCheck = 0\n                    if humidRatioLow == 0.0 and humidRatioUp*scaleFactor >= comfortCrvSegments[comfCount][0].PointAtEnd.Y:\n                        strategyLine = rc.Geometry.LineCurve(comfortCrvSegments[comfCount][0].PointAtEnd, rc.Geometry.Point3d(comfortCrvSegments[comfCount][0].PointAtEnd.X+tempAboveComf, comfortCrvSegments[comfCount][0].PointAtEnd.Y, 0))\n                        boundaryLine = comfortCrvSegments[comfCount][0]\n                        transformMass = rc.Geometry.Transform.Translation(tempAboveComf, 0, 0)\n                        boundaryLine2 = boundaryLine.DuplicateCurve()\n                        boundaryLine2.Transform(transformMass)\n                        splitCrv = boundaryLine2.Split(chartBoundaryBrep, sc.doc.ModelAbsoluteTolerance)\n                        if len(splitCrv) == 2:\n                            boundaryLine2 = splitCrv[1]\n                            ChartBoundCheck = 2\n                        else: ChartBoundCheck = 1\n                        joinedMassBound = rc.Geometry.Curve.JoinCurves([strategyLine, boundaryLine, boundaryLine2])[0]\n                    elif humidRatioLow == 0.0:\n                        cornerPt = rc.Geometry.Intersect.Intersection.CurveCurve(splittingLineUp, comfortCrvSegments[comfCount][0], sc.doc.ModelAbsoluteTolerance, sc.doc.ModelAbsoluteTolerance)[0].PointA\n                        strategyLine = rc.Geometry.LineCurve(cornerPt, rc.Geometry.Point3d(cornerPt.X+tempAboveComf, humidRatioUp*scaleFactor, 0))\n                        boundaryLine = comfortCrvSegments[comfCount][0].Split(splittingBrepUp, sc.doc.ModelAbsoluteTolerance)[0]\n                        transformMass = rc.Geometry.Transform.Translation(tempAboveComf, 0, 0)\n                        boundaryLine2 = boundaryLine.DuplicateCurve()\n                        boundaryLine2.Transform(transformMass)\n                        splitCrv = boundaryLine2.Split(chartBoundaryBrep, sc.doc.ModelAbsoluteTolerance)\n                        if len(splitCrv) == 2:\n                            boundaryLine2 = splitCrv[1]\n                            ChartBoundCheck = 2\n                        else: ChartBoundCheck = 1\n                        joinedMassBound = rc.Geometry.Curve.JoinCurves([strategyLine, boundaryLine, boundaryLine2])[0]\n                    elif humidRatioUp*scaleFactor >= comfortCrvSegments[comfCount][0].PointAtEnd.Y:\n                        strategyLine1 = rc.Geometry.LineCurve(comfortCrvSegments[comfCount][0].PointAtEnd, rc.Geometry.Point3d(comfortCrvSegments[comfCount][0].PointAtEnd.X+tempAboveComf, comfortCrvSegments[comfCount][0].PointAtEnd.Y, 0))\n                        cornerPt = rc.Geometry.Intersect.Intersection.CurveCurve(splittingLineLow, comfortCrvSegments[comfCount][0], sc.doc.ModelAbsoluteTolerance, sc.doc.ModelAbsoluteTolerance)[0].PointA\n                        strategyLine2 = rc.Geometry.LineCurve(cornerPt, rc.Geometry.Point3d(cornerPt.X+tempAboveComf, humidRatioLow*scaleFactor, 0))\n                        splitCrv1 = strategyLine2.Split(chartBoundaryBrep, sc.doc.ModelAbsoluteTolerance)\n                        if len(splitCrv1) == 2:\n                            strategyLine2 = splitCrv1[0]\n                        boundaryLine = comfortCrvSegments[comfCount][0]\n                        boundaryLine = boundaryLine.Split(splittingBrepLow, sc.doc.ModelAbsoluteTolerance)[-1]\n                        transformMass = rc.Geometry.Transform.Translation(tempAboveComf, 0, 0)\n                        boundaryLine2 = boundaryLine.DuplicateCurve()\n                        boundaryLine2.Transform(transformMass)\n                        splitCrv = boundaryLine2.Split(chartBoundaryBrep, sc.doc.ModelAbsoluteTolerance)\n                        if len(splitCrv) == 2:\n                            boundaryLine2 = splitCrv[1]\n                            ChartBoundCheck = 0\n                        else: ChartBoundCheck = 3\n                        joinedMassBound = rc.Geometry.Curve.JoinCurves([strategyLine1, boundaryLine, strategyLine2, boundaryLine2])[0]\n                    else:\n                        cornerPt1 = rc.Geometry.Intersect.Intersection.CurveCurve(splittingLineUp, comfortCrvSegments[comfCount][0], sc.doc.ModelAbsoluteTolerance, sc.doc.ModelAbsoluteTolerance)[0].PointA\n                        cornerPt2 = rc.Geometry.Intersect.Intersection.CurveCurve(splittingLineLow, comfortCrvSegments[comfCount][0], sc.doc.ModelAbsoluteTolerance, sc.doc.ModelAbsoluteTolerance)[0].PointA\n                        strategyLine1 = rc.Geometry.LineCurve(cornerPt1, rc.Geometry.Point3d(cornerPt1.X+tempAboveComf, humidRatioUp*scaleFactor, 0))\n                        strategyLine2 = rc.Geometry.LineCurve(cornerPt2, rc.Geometry.Point3d(cornerPt2.X+tempAboveComf, humidRatioLow*scaleFactor, 0))\n                        splitCrv1 = strategyLine2.Split(chartBoundaryBrep, sc.doc.ModelAbsoluteTolerance)\n                        if len(splitCrv1) == 2:\n                            strategyLine2 = splitCrv1[0]\n                        boundaryLine = comfortCrvSegments[comfCount][0]\n                        boundaryLine = boundaryLine.Split(splittingBrepLow, sc.doc.ModelAbsoluteTolerance)[-1]\n                        boundaryLine = boundaryLine.Split(splittingBrepUp, sc.doc.ModelAbsoluteTolerance)[0]\n                        transformMass = rc.Geometry.Transform.Translation(tempAboveComf, 0, 0)\n                        boundaryLine2 = boundaryLine.DuplicateCurve()\n                        boundaryLine2.Transform(transformMass)\n                        splitCrv = boundaryLine2.Split(chartBoundaryBrep, sc.doc.ModelAbsoluteTolerance)\n                        if len(splitCrv) == 2:\n                            boundaryLine2 = splitCrv[1]\n                            ChartBoundCheck = 0\n                        else: ChartBoundCheck = 3\n                        joinedMassBound = rc.Geometry.Curve.JoinCurves([strategyLine1, boundaryLine, strategyLine2, boundaryLine2])[0]\n                    \n                    joinedMassBrep = rc.Geometry.Brep.CreateFromSurface(rc.Geometry.Surface.CreateExtrusion(joinedMassBound, rc.Geometry.Vector3d.ZAxis))\n                    chartBoundSegments = chartBoundary.Split(joinedMassBrep, sc.doc.ModelAbsoluteTolerance)\n                    if ChartBoundCheck == 1:\n                        if str(rc.RhinoApp.Version).startswith('6') and humidRatioUp*scaleFactor >= comfortCrvSegments[comfCount][0].PointAtEnd.Y:\n                            segment = chartBoundSegments[1]\n                        else:\n                            segment = chartBoundSegments[0]\n                    elif ChartBoundCheck == 2:\n                        try: segment = chartBoundSegments[2]\n                        except: segment = chartBoundSegments[1]\n                    elif ChartBoundCheck == 0: segment = chartBoundSegments[1]\n                    if len(chartBoundSegments) != 0: joinedMassCoolBound = rc.Geometry.Curve.JoinCurves([joinedMassBound, segment])[0]\n                    else: joinedMassCoolBound = joinedMassBound\n                    passiveStrategyCurves.append(joinedMassCoolBound)\n                    passiveStrategyBreps.append(outlineCurve(joinedMassCoolBound))\n                    strategyListTest.append(\"Thermal Mass + Night Vent\")\n                    #passiveStrategyBreps.append(joinedMassCoolBound)\n                \n                #If the user has hooked up natural ventilation, add a natural ventilation curve to the chart.\n                if \"Occupant Use of Fans\" in passiveStrategy and windSpeed[comfCount] < maxWindSpeed:\n                    try:\n                        #Calculate the upper boundary of Natural ventilation.\n                        upTemperPts = []\n                        for count, humidity in enumerate(range(0,150,50)):\n                            upTemper, downTemper = lb_comfortModels.calcComfRange(radTemp[comfCount], maxWindSpeed, humidity, metRate[comfCount], cloLevel[comfCount], exWork[comfCount], PPDComfortThresh, opTemp)\n                            \n                            if IPTrigger: upTemperSpatial, downTemperSpatial = C2F([upTemper])[0], C2F([downTemper])[0]\n                            else: upTemperSpatial, downTemperSpatial = upTemper, downTemper\n                            \n                            if upTemperSpatial < maxTempe:\n                                if downTemperSpatial > minTempe:\n                                    upIntersect = rc.Geometry.Intersect.Intersection.CurvePlane(relHumidLines[count], rc.Geometry.Plane(rc.Geometry.Point3d(upTemperSpatial, 0,0), rc.Geometry.Vector3d.XAxis), sc.doc.ModelAbsoluteTolerance)[0].PointA\n                                else: upIntersect = relHumidLines[count].PointAtStart\n                            else: upIntersect = relHumidLines[count].PointAtEnd\n                            upTemperPts.append(upIntersect)\n                        \n                        natVentBoundary = rc.Geometry.Curve.CreateInterpolatedCurve(upTemperPts, 3)\n                        try: natVentBoundary = upperBoundary.Split(chartBoundaryBrep, sc.doc.ModelAbsoluteTolerance)[0]\n                        except: pass\n                        \n                        if humidRatioLow == 0 and humidRatioUp*scaleFactor >= comfortCrvSegments[comfCount][0].PointAtEnd.Y:\n                            strategyLine1 = rc.Geometry.LineCurve(comfortCrvSegments[comfCount][0].PointAtEnd, rc.Geometry.Intersect.Intersection.CurveCurve(natVentBoundary, rc.Geometry.LineCurve(comfortCrvSegments[comfCount][0].PointAtEnd, rc.Geometry.Point3d(maxTempe, comfortCrvSegments[comfCount][0].PointAtEnd.Y, 0)), sc.doc.ModelAbsoluteTolerance, sc.doc.ModelAbsoluteTolerance)[0].PointA)\n                            strategyLine2 = rc.Geometry.LineCurve(comfortCrvSegments[comfCount][0].PointAtStart, natVentBoundary.PointAtStart)\n                            boundaryLine = comfortCrvSegments[comfCount][0]\n                            natVentLine = natVentBoundary.Split(rc.Geometry.Surface.CreateExtrusion(rc.Geometry.LineCurve(comfortCrvSegments[comfCount][0].PointAtEnd, rc.Geometry.Point3d(maxTempe, comfortCrvSegments[comfCount][0].PointAtEnd.Y, 0)), rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[0]\n                            \n                        elif humidRatioLow == 0:\n                            strategyLine1 = rc.Geometry.LineCurve(comfortCrvSegments[comfCount][0].Split(splittingBrepUp, sc.doc.ModelAbsoluteTolerance)[0].PointAtEnd, natVentBoundary.Split(splittingBrepUp, sc.doc.ModelAbsoluteTolerance)[0].PointAtEnd)\n                            strategyLine2 = rc.Geometry.LineCurve(comfortCrvSegments[comfCount][0].PointAtStart, natVentBoundary.PointAtStart)\n                            boundaryLine = comfortCrvSegments[comfCount][0].Split(splittingBrepUp, sc.doc.ModelAbsoluteTolerance)[0]\n                            natVentLine = natVentBoundary.Split(splittingBrepUp, sc.doc.ModelAbsoluteTolerance)[0]\n                        elif humidRatioUp*scaleFactor >= comfortCrvSegments[comfCount][0].PointAtEnd.Y:\n                            strategyLine1 = rc.Geometry.LineCurve(comfortCrvSegments[comfCount][0].PointAtEnd, rc.Geometry.Intersect.Intersection.CurveCurve(natVentBoundary, rc.Geometry.LineCurve(comfortCrvSegments[comfCount][0].PointAtEnd, rc.Geometry.Point3d(maxTempe, comfortCrvSegments[comfCount][0].PointAtEnd.Y, 0)), sc.doc.ModelAbsoluteTolerance, sc.doc.ModelAbsoluteTolerance)[0].PointA)\n                            natVentLine = natVentBoundary.Split(rc.Geometry.Surface.CreateExtrusion(rc.Geometry.LineCurve(comfortCrvSegments[comfCount][0].PointAtEnd, rc.Geometry.Point3d(maxTempe, comfortCrvSegments[comfCount][0].PointAtEnd.Y, 0)), rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[0].Split(splittingBrepLow, sc.doc.ModelAbsoluteTolerance)[1]\n                            boundaryLine = comfortCrvSegments[comfCount][0].Split(splittingBrepLow, sc.doc.ModelAbsoluteTolerance)[1]\n                            strategyLine2 = rc.Geometry.LineCurve(boundaryLine.PointAtStart, natVentLine.PointAtStart)\n                        else:\n                            natVentLine = natVentBoundary.Split(splittingBrepUp, sc.doc.ModelAbsoluteTolerance)[0].Split(splittingBrepLow, sc.doc.ModelAbsoluteTolerance)[1]\n                            boundaryLine = comfortCrvSegments[comfCount][0].Split(splittingBrepUp, sc.doc.ModelAbsoluteTolerance)[0].Split(splittingBrepLow, sc.doc.ModelAbsoluteTolerance)[1]\n                            strategyLine1 = rc.Geometry.LineCurve(boundaryLine.PointAtStart, natVentLine.PointAtStart)\n                            strategyLine2 = rc.Geometry.LineCurve(boundaryLine.PointAtEnd, natVentLine.PointAtEnd)\n                        joinedNatVentBound = rc.Geometry.Curve.JoinCurves([strategyLine1, boundaryLine, strategyLine2, natVentLine])[0]\n                        passiveStrategyCurves.append(joinedNatVentBound)\n                        passiveStrategyBreps.append(outlineCurve(joinedNatVentBound))\n                        strategyListTest.append(\"Occupant Use of Fans\")\n                    except:\n                        print \"Use of fans is not helful to ouccupants when the desired air is so hot.\"\n                \n                #If the user has hooked up internal gain, add an internal gain curve to the chart.\n                if \"Internal Heat Gain\" in passiveStrategy:\n                    heatBoundary = rc.Geometry.LineCurve(rc.Geometry.Point3d(bldgBalPt, 0, 0), rc.Geometry.Point3d(bldgBalPt, scaleFactor*0.03, 0))\n                    heatBoundary = heatBoundary.Split(chartBoundaryBrep, sc.doc.ModelAbsoluteTolerance)[0]\n                    if humidRatioLow == 0:\n                        boundaryLine = comfortCrvSegments[comfCount][1]\n                        if str(rc.RhinoApp.Version).startswith('6'):\n                            strategyLine1 = chartBoundary.Split(rc.Geometry.Surface.CreateExtrusion(boundaryLine, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[-1].Split(rc.Geometry.Surface.CreateExtrusion(heatBoundary, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[0]\n                            strategyLine2 = chartBoundary.Split(rc.Geometry.Surface.CreateExtrusion(boundaryLine, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[-1].Split(rc.Geometry.Surface.CreateExtrusion(heatBoundary, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[2]\n                        else:\n                            strategyLine1 = chartBoundary.Split(rc.Geometry.Surface.CreateExtrusion(boundaryLine, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[0].Split(rc.Geometry.Surface.CreateExtrusion(heatBoundary, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[0]\n                            strategyLine2 = chartBoundary.Split(rc.Geometry.Surface.CreateExtrusion(boundaryLine, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[0].Split(rc.Geometry.Surface.CreateExtrusion(heatBoundary, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[2]\n                        joinedHeatBound = rc.Geometry.Curve.JoinCurves([strategyLine1, boundaryLine, strategyLine2, heatBoundary])[0]\n                    else:\n                        boundaryLine = comfortCrvSegments[comfCount][1].Split(splittingBrepLow, sc.doc.ModelAbsoluteTolerance)[1]\n                        heatBoundaryNew = heatBoundary.Split(splittingBrepLow, sc.doc.ModelAbsoluteTolerance)[1]\n                        if str(rc.RhinoApp.Version).startswith('6'):\n                            strategyLine1 = chartBoundary.Split(rc.Geometry.Surface.CreateExtrusion(comfortCrvSegments[comfCount][1], rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[-1].Split(rc.Geometry.Surface.CreateExtrusion(heatBoundary, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[2]\n                        else:\n                            strategyLine1 = chartBoundary.Split(rc.Geometry.Surface.CreateExtrusion(comfortCrvSegments[comfCount][1], rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[0].Split(rc.Geometry.Surface.CreateExtrusion(heatBoundary, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[2]\n                        strategyLine2 = rc.Geometry.LineCurve(boundaryLine.PointAtStart, heatBoundaryNew.PointAtStart)\n                        joinedHeatBound = rc.Geometry.Curve.JoinCurves([strategyLine1, boundaryLine, strategyLine2, heatBoundaryNew])[0]\n                    \n                    if humidRatioUp != 0.03:\n                        try:\n                            heatBoundaryNew = joinedHeatBound.Split(splittingBrepUp, sc.doc.ModelAbsoluteTolerance)[-1]\n                            if not heatBoundaryNew.IsClosed:\n                                heatBoundaryCloser = rc.Geometry.LineCurve(heatBoundaryNew.PointAtStart, heatBoundaryNew.PointAtEnd)\n                                joinedHeatBound2 = rc.Geometry.Curve.JoinCurves([heatBoundaryNew, heatBoundaryCloser])[0]\n                                if joinedHeatBound2 != None and joinedHeatBound2.IsClosed:\n                                    joinedHeatBound = joinedHeatBound2\n                        except:\n                            pass\n                    \n                    passiveStrategyCurves.append(joinedHeatBound)\n                    passiveStrategyBreps.append(outlineCurve(joinedHeatBound))\n                    strategyListTest.append(\"Internal Heat Gain\")\n                \n                # If the user has connected passive solar heating and radiation to be used for this, make a solar radiation polygon.\n                if \"Passive Solar Heating\" in passiveStrategy and globHorizRad != []:\n                    # calculate the maximum temperature delta.\n                    deltas = []\n                    maxDelta = 1\n                    if \"Internal Heat Gain\" in passiveStrategy:\n                        polyStart = bldgBalPt\n                    else:\n                        polyStart = minComfortPolyTemp\n                    polyStart = F2C([polyStart])[0] if IPTrigger else polyStart\n                    \n                    for hourCt, hourPt in enumerate(globHorizRad):\n                        if airTemp[hourCt] < polyStart:\n                            tempDelta = polyStart - airTemp[hourCt]\n                            comfFound = 0\n                            solarHeatContribs = []\n                            for pastRad in range(int(solarTimeConst)):\n                                heatContrib = ((int(solarTimeConst)-pastRad)/solarTimeConst)*origGlobHorizRad[int(origHrs[hourCt]-1-pastRad)]\n                                solarHeatContribs.append(heatContrib)\n                            if sum(solarHeatContribs) > solarHeatCap*tempDelta:\n                                deltas.append(tempDelta)\n                    if len(deltas) >0:\n                        deltas.sort()\n                        deltaDesignIndex = int(len(deltas)/100)\n                        maxDelta = deltas[-deltaDesignIndex]\n                        if polyStart - maxDelta < -20:\n                            maxDelta = 20 + polyStart\n                        elif maxDelta < 1:\n                            maxDelta = 1\n                    \n                    if IPTrigger:\n                        polyStart = C2F([polyStart])[0]\n                        maxDelta = maxDelta * (9 / 5)\n                    solarBoundary = rc.Geometry.LineCurve(rc.Geometry.Point3d(polyStart-maxDelta, 0, 0), rc.Geometry.Point3d(polyStart-maxDelta, scaleFactor*0.03, 0))\n                    solarBoundary = solarBoundary.Split(chartBoundaryBrep, sc.doc.ModelAbsoluteTolerance)[0]\n                    \n                    if \"Internal Heat Gain\" in passiveStrategy:\n                        heatBoundary = rc.Geometry.LineCurve(rc.Geometry.Point3d(polyStart, 0, 0), rc.Geometry.Point3d(polyStart, scaleFactor*0.03, 0))\n                        heatBoundary = heatBoundary.Split(chartBoundaryBrep, sc.doc.ModelAbsoluteTolerance)[0]\n                    else:\n                        heatBoundary = comfortCrvSegments[comfCount][1]\n                    \n                    if humidRatioLow == 0:\n                        if str(rc.RhinoApp.Version).startswith('6'):\n                            strategyLine1 = chartBoundary.Split(rc.Geometry.Surface.CreateExtrusion(heatBoundary, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[-1].Split(rc.Geometry.Surface.CreateExtrusion(solarBoundary, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[0]\n                            strategyLine2 = chartBoundary.Split(rc.Geometry.Surface.CreateExtrusion(heatBoundary, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[-1].Split(rc.Geometry.Surface.CreateExtrusion(solarBoundary, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[2]\n                        else:\n                            strategyLine1 = chartBoundary.Split(rc.Geometry.Surface.CreateExtrusion(heatBoundary, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[0].Split(rc.Geometry.Surface.CreateExtrusion(solarBoundary, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[0]\n                            strategyLine2 = chartBoundary.Split(rc.Geometry.Surface.CreateExtrusion(heatBoundary, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[0].Split(rc.Geometry.Surface.CreateExtrusion(solarBoundary, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[2]\n                        joinedSolarBound = rc.Geometry.Curve.JoinCurves([strategyLine1, heatBoundary, strategyLine2, solarBoundary])[0]\n                    else:\n                        heatBoundaryNew = heatBoundary.Split(splittingBrepLow, sc.doc.ModelAbsoluteTolerance)[1]\n                        try:\n                            solarBoundaryNew = solarBoundary.Split(splittingBrepLow, sc.doc.ModelAbsoluteTolerance)[1]\n                            strategyLine1 = chartBoundary.Split(rc.Geometry.Surface.CreateExtrusion(heatBoundary, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[0].Split(rc.Geometry.Surface.CreateExtrusion(solarBoundary, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[2]\n                            strategyLine2 = rc.Geometry.LineCurve(heatBoundaryNew.PointAtStart, solarBoundaryNew.PointAtStart)\n                            joinedSolarBound = rc.Geometry.Curve.JoinCurves([strategyLine1, heatBoundaryNew, strategyLine2, solarBoundaryNew])[0]\n                        except:\n                            strategyLine1 = chartBoundary.Split(rc.Geometry.Surface.CreateExtrusion(heatBoundary, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[0].Split(splittingBrepLow, sc.doc.ModelAbsoluteTolerance)[-1]\n                            closer = rc.Geometry.LineCurve(heatBoundaryNew.PointAtStart, strategyLine1.PointAtStart)\n                            joinedSolarBound = rc.Geometry.Curve.JoinCurves([strategyLine1, heatBoundaryNew, closer])[0]\n                    \n                    if humidRatioUp != 0.03:\n                        try:\n                            solarBoundaryNew = joinedSolarBound.Split(splittingBrepUp, sc.doc.ModelAbsoluteTolerance)[-1]\n                            if not solarBoundaryNew.IsClosed:\n                                solarBoundaryCloser = rc.Geometry.LineCurve(solarBoundaryNew.PointAtStart, solarBoundaryNew.PointAtEnd)\n                                joinedSolarBound2 = rc.Geometry.Curve.JoinCurves([solarBoundaryNew, solarBoundaryCloser])[0]\n                                if joinedSolarBound2 != None and joinedSolarBound2.IsClosed:\n                                    joinedSolarBound = joinedSolarBound2\n                        except:\n                            pass\n                    \n                    passiveStrategyCurves.append(joinedSolarBound)\n                    passiveStrategyBreps.append(outlineCurve(joinedSolarBound))\n                    strategyListTest.append(\"Passive Solar Heating\")\n                \n                # If the user has hooked up humidification only, add a humidification only curve to the chart.\n                if \"Humidification Only\" in passiveStrategy and humidRatioLow != 0:\n                    boundary1 = comfortCrvSegments[comfCount][1].Split(splittingBrepLow, sc.doc.ModelAbsoluteTolerance)[0]\n                    boundary2 = comfortCrvSegments[comfCount][0].Split(splittingBrepLow, sc.doc.ModelAbsoluteTolerance)[0]\n                    boundary3 = rc.Geometry.LineCurve(boundary1.PointAtStart, boundary2.PointAtStart)\n                    boundary4 = rc.Geometry.LineCurve(boundary1.PointAtEnd, boundary2.PointAtEnd)\n                    \n                    joinedHumidBound = rc.Geometry.Curve.JoinCurves([boundary1, boundary2, boundary3, boundary4])[0]\n                    \n                    passiveStrategyCurves.append(joinedHumidBound)\n                    passiveStrategyBreps.append(outlineCurve(joinedHumidBound))\n                    strategyListTest.append(\"Humidification Only\")\n                \n                #If the user has hooked up dehumidification only, add a dehumidification only curve to the chart.\n                if \"Dessicant Dehumidification\" in passiveStrategy and humidRatioUp*scaleFactor <= comfortCrvSegments[comfCount][0].PointAtEnd.Y:\n                    comfPolygonPts = getCurvePoints(comfortCurve)\n                    ptXYSum = []\n                    for point in comfPolygonPts:\n                        ptXYSum.append(point.X + point.Y)\n                    ptXYSum, comfPolygonPts = zip(*sorted(zip(ptXYSum, comfPolygonPts)))\n                    startPt = comfPolygonPts[-1]\n                    #Calculate the enthalpy at the start point.\n                    if IPTrigger:\n                        startTemp = F2C([startPt.X])[0]\n                        endTemp = F2C([-5])[0]\n                    else:\n                        startTemp = startPt.X\n                        endTemp = -20.2\n                    enthalpy = (startTemp * (1.01 + 0.00189*((startPt.Y/scaleFactor)*1000))) + 2.5*((startPt.Y/scaleFactor)*1000)\n                    #If the temperature at the edge of the chart is 50C, use that to find another point of the line.\n                    newHR = (((enthalpy - endTemp) / 2.4622)/1000)* scaleFactor\n                    endPt = rc.Geometry.Point3d(minTempe, newHR, 0)\n                    dessicantLine = rc.Geometry.LineCurve(startPt, endPt)\n                    boundary1 = dessicantLine.Split(chartBoundaryBrep, sc.doc.ModelAbsoluteTolerance)[0]\n                    try:\n                        if not \"Internal Heat Gain\" in passiveStrategy:\n                            boundary2 = comfortCrvSegments[comfCount][1].Split(splittingBrepUp, sc.doc.ModelAbsoluteTolerance)[1]\n                            boundary3 = rc.Geometry.LineCurve(boundary1.PointAtStart, boundary2.PointAtStart)\n                            boundary4 = rc.Geometry.LineCurve(boundary1.PointAtEnd, boundary2.PointAtEnd)\n                            if boundary1.PointAtEnd.X < boundary2.PointAtEnd.X:\n                                boundary12 = boundary1.Split(rc.Geometry.Surface.CreateExtrusion(boundary2, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[0]\n                                boundary22 = boundary2.Split(rc.Geometry.Surface.CreateExtrusion(boundary1, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[0]\n                                joinedHumidBound = rc.Geometry.Curve.JoinCurves([boundary12, boundary22, boundary3])[0]\n                            else:\n                                joinedHumidBound = rc.Geometry.Curve.JoinCurves([boundary1, boundary2, boundary3, boundary4])[0]\n                        else:\n                            boundary2 = chartBoundary.Split(splittingBrepUp, sc.doc.ModelAbsoluteTolerance)[0].Split(rc.Geometry.Surface.CreateExtrusion(boundary1, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[0]\n                            boundary3 = rc.Geometry.LineCurve(boundary1.PointAtStart, boundary2.PointAtStart)\n                            joinedHumidBound = rc.Geometry.Curve.JoinCurves([boundary1, boundary2, boundary3])[0]\n                    except:\n                        boundary2 = chartBoundary.Split(splittingBrepUp, sc.doc.ModelAbsoluteTolerance)[0].Split(rc.Geometry.Surface.CreateExtrusion(boundary1, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[0]\n                        boundary3 = rc.Geometry.LineCurve(boundary1.PointAtStart, boundary2.PointAtStart)\n                        joinedHumidBound = rc.Geometry.Curve.JoinCurves([boundary1, boundary2, boundary3])[0]\n                    \n                    passiveStrategyCurves.append(joinedHumidBound)\n                    passiveStrategyBreps.append(outlineCurve(joinedHumidBound))\n                    strategyListTest.append(\"Dessicant Dehumidification\")\n                elif \"Dessicant Dehumidification\" in passiveStrategy:\n                    passiveStrategyCurves.append(None)\n                    strategyListTest.append(\"Dessicant Dehumidification\")\n                    warning = 'Dessicant Dehumidification is only relevant when there is an upper bound of humidity ratio on the comfort polygon.  Use the \"PMV Comfort Parameters\" component to set this.'\n                    print warning\n                    ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n                \n                #If the user has hooked up dessicant dehumidification, add a dessicant dehumidification curve to the chart.\n                if \"Dehumidification Only\" in passiveStrategy and humidRatioUp*scaleFactor <= comfortCrvSegments[comfCount][0].PointAtEnd.Y:\n                    boundary1 = comfortCrvSegments[comfCount][0].Split(splittingBrepUp, sc.doc.ModelAbsoluteTolerance)[1]\n                    try:\n                        boundary2 = comfortCrvSegments[comfCount][1].Split(splittingBrepUp, sc.doc.ModelAbsoluteTolerance)[1]\n                        boundary3 = rc.Geometry.LineCurve(boundary1.PointAtStart, boundary2.PointAtStart)\n                        boundary4 = rc.Geometry.LineCurve(boundary1.PointAtEnd, boundary2.PointAtEnd)\n                        joinedHumidBound = rc.Geometry.Curve.JoinCurves([boundary1, boundary2, boundary3, boundary4])[0]\n                    except:\n                        boundary2 = chartBoundary.Split(splittingBrepUp, sc.doc.ModelAbsoluteTolerance)[0].Split(rc.Geometry.Surface.CreateExtrusion(boundary1, rc.Geometry.Vector3d.ZAxis), sc.doc.ModelAbsoluteTolerance)[0]\n                        boundary3 = rc.Geometry.LineCurve(boundary1.PointAtStart, boundary2.PointAtStart)\n                        joinedHumidBound = rc.Geometry.Curve.JoinCurves([boundary1, boundary2, boundary3])[0]\n                    if str(rc.RhinoApp.Version).startswith('6'):\n                        joinedHumidBound.Reverse()\n                    passiveStrategyCurves.append(joinedHumidBound)\n                    passiveStrategyBreps.append(outlineCurve(joinedHumidBound))\n                    strategyListTest.append(\"Dehumidification Only\")\n        else:\n            tempBelowComf = 2.8\n        \n        #Try to boolean all of the strategy and comfort curves together so that we can get a sense of comfort over the whole graph.\n        allCurves = []\n        for crv in mergedCurvesFinal:\n            allCurves.append(crv)\n        for crv in passiveStrategyCurves:\n            allCurves.append(crv)\n        \n        if len(allCurves) > 1:\n            listLength = len(allCurves)\n            count  = 0\n            while len(allCurves) > 1 and count < int(listLength/2) + 1:\n                allCurves = unionAllCurves(allCurves)\n                count += 1\n        \n        \n        #Move the strategy outlines up just a bit so that they can be seen over the mesh.\n        transformMatrix = rc.Geometry.Transform.Translation(0,0,sc.doc.ModelAbsoluteTolerance*5)\n        for brep in finalComfortBreps:\n            brep.Transform(transformMatrix)\n        for brep in passiveStrategyBreps:\n            brep.Transform(transformMatrix)\n        \n        \n        return mergedCurvesFinal, finalComfortBreps, passiveStrategyCurves, passiveStrategyBreps, strategyListTest, allCurves, tempBelowComf, maxComfortPolyTemp, solarHeatCap, solarTimeConst, bldgBalPt, polyStart\n    else:\n        return [], [], [], [], [], [], 3, 0, 30, 8, 12.8\n\ndef statisticallyAnalyzePolygons(hourPts, comfortPolyline, strategyPolylines, unionedCurves, epwData, epwStr, strategyTextNames, tempBelowComf, airTemp, maxComfortPolyTemp, globHorizRad, origAirTemp, origGlobHorizRad, origHrs, solarHeatCap, solarTimeConst, bldgBalPt, polyStart, patternList, IPTrigger):\n    #Define lists to be filled up with the data.\n    strategyPercent = []\n    strategyOrNot = []\n    if IPTrigger == False:\n        curveTolerance = sc.doc.ModelAbsoluteTolerance*5\n    else:\n        curveTolerance = 0.4\n    \n    #For each of the comfort polygons, determine how many of the hour points are inside of them and make a comfort or not list.\n    for countComf, comfortPolygon in enumerate(comfortPolyline):\n        comfBool = []\n        for hourPt in hourPts:\n            if str(comfortPolygon.Contains(hourPt, rc.Geometry.Plane.WorldXY, sc.doc.ModelAbsoluteTolerance)) == \"Inside\":\n                comfBool.append(1)\n            elif hourPt.DistanceTo(comfortPolygon.PointAt(comfortPolygon.ClosestPoint(hourPt)[1])) < curveTolerance:\n                comfBool.append(1)\n            else:\n                comfBool.append(0)\n        if len(comfBool) != 0:\n            comfPercent = (sum(comfBool)/len(comfBool))*100\n        else:\n            comfPercent =100\n        strategyPercent.append(comfPercent)\n        if epwData == True:\n            if analysisPeriod_:\n                comfBool.insert(0,analysisPeriod_[1])\n                comfBool.insert(0,analysisPeriod_[0])\n            else:\n                comfBool.insert(0, epwStr[6])\n                comfBool.insert(0, epwStr[5])\n            comfBool.insert(0, epwStr[4])\n            comfBool.insert(0, \"Boolean Value\")\n            comfBool.insert(0, \"Comfortable Hours in \" + strategyTextNames[countComf] + \" Polygon\")\n            comfBool.insert(0, epwStr[1])\n            comfBool.insert(0, epwStr[0])\n        strategyOrNot.append(comfBool)\n    \n    #For each of the strategy polygons, determine how many of the hour points are inside of them and make a comfort or not list.\n    for countStrat, comfortPolygon in enumerate(strategyPolylines):\n        comfBool = []\n        try:\n            if (strategyTextNames[countComf + countStrat + 1] != \"Thermal Mass + Night Vent\" and strategyTextNames[countComf + countStrat + 1] != \"Passive Solar Heating\") or epwData == False or patternList != []:\n                for hourPt in hourPts:\n                    if str(comfortPolygon.Contains(hourPt, rc.Geometry.Plane.WorldXY, sc.doc.ModelAbsoluteTolerance)) == \"Inside\":\n                        comfBool.append(1)\n                    elif hourPt.DistanceTo(comfortPolygon.PointAt(comfortPolygon.ClosestPoint(hourPt)[1])) < curveTolerance:\n                        comfBool.append(1)\n                    else:\n                        comfBool.append(0)\n            elif strategyTextNames[countComf + countStrat + 1] == \"Thermal Mass + Night Vent\":\n                for hourCt, hourPt in enumerate(hourPts):\n                    if str(comfortPolygon.Contains(hourPt, rc.Geometry.Plane.WorldXY, sc.doc.ModelAbsoluteTolerance)) == \"Inside\" or hourPt.DistanceTo(comfortPolygon.PointAt(comfortPolygon.ClosestPoint(hourPt)[1])) < curveTolerance:\n                        comfFound = 0\n                        for pastAir in range(int(solarTimeConst)):\n                            if origAirTemp[int(origHrs[hourCt]-1-pastAir)] < maxComfortPolyTemp-tempBelowComf:\n                                comfFound = 1\n                        comfBool.append(comfFound)\n                    else:\n                        comfBool.append(0)\n            else:\n                for hourCt, hourPt in enumerate(hourPts):\n                    if str(comfortPolygon.Contains(hourPt, rc.Geometry.Plane.WorldXY, sc.doc.ModelAbsoluteTolerance)) == \"Inside\" or hourPt.DistanceTo(comfortPolygon.PointAt(comfortPolygon.ClosestPoint(hourPt)[1])) < curveTolerance:\n                        if \"Internal Heat Gain\" in strategyTextNames:\n                            pStart = F2C([bldgBalPt])[0] if IPTrigger is True else bldgBalPt\n                        else:\n                            pStart = F2C([polyStart])[0] if IPTrigger is True else polyStart\n                        tempDelta = pStart - airTemp[hourCt]\n                        comfFound = 0\n                        solarHeatContribs = []\n                        for pastRad in range(int(solarTimeConst)):\n                            heatContrib = ((int(solarTimeConst)-pastRad)/solarTimeConst)*origGlobHorizRad[origHrs[hourCt]-1-pastRad]\n                            solarHeatContribs.append(heatContrib)\n                        if sum(solarHeatContribs) > solarHeatCap*tempDelta:\n                            comfFound = 1\n                        comfBool.append(comfFound)\n                    else:\n                        comfBool.append(0)\n            \n            comfPercent = (sum(comfBool)/len(comfBool))*100\n            strategyPercent.append(comfPercent)\n            if epwData == True:\n                if analysisPeriod_:\n                    comfBool.insert(0,analysisPeriod_[1])\n                    comfBool.insert(0,analysisPeriod_[0])\n                else:\n                    comfBool.insert(0, epwStr[6])\n                    comfBool.insert(0, epwStr[5])\n                comfBool.insert(0, epwStr[4])\n                comfBool.insert(0, \"Boolean Value\")\n                comfBool.insert(0, \"Comfortable Hours in \" + strategyTextNames[countComf + countStrat + 1] + \" Polygon\")\n                comfBool.insert(0, epwStr[1])\n                comfBool.insert(0, epwStr[0])\n            strategyOrNot.append(comfBool)\n        except Exception as e:\n            print e\n            strategyPercent.append(0)\n            for count in range(len(hourPts)):\n                comfBool.append(0)\n            \n            if epwData == True:\n                if analysisPeriod_:\n                    comfBool.insert(0,analysisPeriod_[1])\n                    comfBool.insert(0,analysisPeriod_[0])\n                else:\n                    comfBool.insert(0, epwStr[6])\n                    comfBool.insert(0, epwStr[5])\n                comfBool.insert(0, epwStr[4])\n                comfBool.insert(0, \"Boolean Value\")\n                comfBool.insert(0, \"Comfortable Hours in Dessicant Dehumidification Polygon\")\n                comfBool.insert(0, epwStr[1])\n                comfBool.insert(0, epwStr[0])\n            strategyOrNot.append(comfBool)\n    \n    #For the total comfort, determine how many of the hour points are inside of them and make a comfort or not list.\n    finalComfOrNot = [0 for x in range(len(hourPts))]\n    for polygon in strategyOrNot:\n        comfBool = []\n        for count, hourPt in enumerate(polygon[7:]):\n            if hourPt == 1:\n                finalComfOrNot[count] = 1\n    \n    #Build the final percent and comfort or not lists.\n    finalTotalPercent = sum(finalComfOrNot)/len(finalComfOrNot)*100\n    \n    if epwData == True:\n        if analysisPeriod_:\n            finalComfOrNot.insert(0,analysisPeriod_[1])\n            finalComfOrNot.insert(0,analysisPeriod_[0])\n        else:\n            finalComfOrNot.insert(0, epwStr[6])\n            finalComfOrNot.insert(0, epwStr[5])\n        finalComfOrNot.insert(0, epwStr[4])\n        finalComfOrNot.insert(0, \"Boolean Value\")\n        finalComfOrNot.insert(0, \"Comfortable Hours in All Polygons\")\n        finalComfOrNot.insert(0, epwStr[1])\n        finalComfOrNot.insert(0, epwStr[0])\n    \n    \n    return finalTotalPercent, finalComfOrNot, strategyPercent, strategyOrNot\n\n\ndef getPointColors(totalComfOrNot, annualHourlyDataSplit, annualDataStr, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan, lb_visualization):\n    #Define the lists.\n    pointColors = []\n    colorLegends = []\n    \n    #Get the colors for comfort.\n    if str(totalComfOrNot[0]) == \"key:location/dataType/units/frequency/startsAt/endsAt\":\n        totalComfOrNot = totalComfOrNot[7:]\n    pointColors.append(lb_visualization.gradientColor(totalComfOrNot, 0, 1, customColors))\n    \n    #Get the colors for annualHourly Data.\n    for datalist in annualHourlyDataSplit:\n        if len(datalist) != 0:\n            pointColors.append(lb_visualization.gradientColor(datalist, \"min\", \"max\", customColors))\n    \n    #Generate a legend for comfort.\n    legend = []\n    legendSrfs, legendText, legendTextCrv, textPt, textSize = lb_visualization.createLegend(totalComfOrNot, 0, 1, 2, \"Comfort\", lb_visualization.BoundingBoxPar, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan)\n    legendColors = lb_visualization.gradientColor(legendText[:-1], 0, 1, customColors)\n    legendSrfs = lb_visualization.colorMesh(legendColors, legendSrfs)\n    legend.append(legendSrfs)\n    for datalist in legendTextCrv:\n        for item in datalist:\n            legend.append(item)\n    colorLegends.append(legend)\n    \n    #Generate legends for annualHourly Data.\n    for listCount, datalist in enumerate(annualHourlyDataSplit):\n        if len(datalist) != 0:\n            legend = []\n            legendSrfs, legendText, legendTextCrv, textPt, textSize = lb_visualization.createLegend(datalist, \"min\", \"max\", numSeg, annualDataStr[listCount][3], lb_visualization.BoundingBoxPar, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan)\n            legendColors = lb_visualization.gradientColor(legendText[:-1], \"min\", \"max\", customColors)\n            legendSrfs = lb_visualization.colorMesh(legendColors, legendSrfs)\n            legend.append(legendSrfs)\n            for datalist in legendTextCrv:\n                for item in datalist:\n                    legend.append(item)\n            colorLegends.append(legend)\n    \n    \n    return pointColors, colorLegends\n\n\ndef main(epwData, epwStr, calcLength, airTemp, relHumid, barPress, avgBarPress, radTemp, windSpeed, metRate, cloLevel, exWork, humidRatioUp, humidRatioLow, calcLengthComf, PPDComfortThresh, titleStatement, patternList, IPTrigger, farenheitVals, opTemp):\n    #Import the classes.\n    if sc.sticky.has_key('ladybug_release'):\n        try:\n            if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): return -1\n            if sc.sticky['ladybug_release'].isInputMissing(ghenv.Component): return -1\n        except:\n            warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n            \"Use updateLadybug component to update userObjects.\\n\" + \\\n            \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n            \"into canvas and try again.\"\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n            return -1\n            \n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n        lb_comfortModels = sc.sticky[\"ladybug_ComfortModels\"]()\n        lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\n        \n        # Read the legend parameters.\n        lowB, highB, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan = lb_preparation.readLegendParameters(legendPar_, False)\n        \n        # Generate the chart curves.\n        if IPTrigger == True: scaleFactor = 1500*(9/5)\n        else: scaleFactor = 1500\n        chartCurves, humidityLines, chartText, chartTextPt = drawPsychChart(avgBarPress, lb_comfortModels, legendFont, legendFontSize, legendBold, scaleFactor, epwData, epwStr, IPTrigger, opTemp, lb_visualization)\n        \n        #If there is annual hourly data, split it up.\n        if annualHourlyData_ != []:\n            def chunks(l, n):\n                finalList = []\n                for i in range(0, len(l), n):\n                    finalList.append(l[i:i+n])\n                return finalList\n            annualHourlyDataSplit = chunks(annualHourlyData_, 8767)\n        else: annualHourlyDataSplit = [[]]\n        annualDataStr = []\n        if annualHourlyDataSplit != [[]]:\n            for list in annualHourlyDataSplit:\n                annualDataStr.append(list[:7])\n        \n        # Make copies of important lists.\n        origAirTemp = airTemp[:]\n        origGlobHorizRad = []\n        for count, datList in enumerate(annualDataStr):\n            if 'Radiation' in datList[2] and ('Total' in datList[2] or 'Global' in datList[2]):\n                origGlobHorizRad = annualHourlyDataSplit[count]\n        if len(origAirTemp) == 8767:\n            origAirTemp = origAirTemp[7:]\n        if len(origGlobHorizRad) == 8767:\n            origGlobHorizRad = origGlobHorizRad[7:]\n        \n        # If an analysis period is selected, use that to select out the data.\n        origHrs = range(1,8761)\n        if analysisPeriod_ != [] and epwData == True and calcLength == 8760:\n            airTemp = lb_preparation.selectHourlyData(_dryBulbTemperature, analysisPeriod_)[7:]\n            relHumid = lb_preparation.selectHourlyData(_relativeHumidity, analysisPeriod_)[7:]\n            if farenheitVals != []:\n                farenheitVals = lb_preparation.selectHourlyData(epwStr + farenheitVals, analysisPeriod_)[7:]\n            if len(barPress) == 8760:\n                barPress = lb_preparation.selectHourlyData(barPress, analysisPeriod_)[7:]\n            else:\n                barPress2 = []\n                for num in range(len(airTemp)):\n                    barPress2.append(barPress[0])\n                barPress = barPress2\n            origHrs, months, days = lb_preparation.getHOYsBasedOnPeriod(analysisPeriod_, 1)\n            if len(patternList) == 8760:\n                HOYS, months, days = lb_preparation.getHOYsBasedOnPeriod(analysisPeriod_, 1)\n                newPatternList = []\n                for hour in HOYS:\n                    newPatternList.append(patternList[hour-1])\n                patternList = newPatternList\n            if annualHourlyDataSplit != [[]]:\n                annualHourlyDataSplitNew = []\n                for list in annualHourlyDataSplit:\n                    annualHourlyDataSplitNew.append(lb_preparation.selectHourlyData(list, analysisPeriod_)[7:])\n                annualHourlyDataSplit = annualHourlyDataSplitNew\n        else:\n            annualHourlyDataSplitNew = []\n            for list in annualHourlyDataSplit:\n                annualHourlyDataSplitNew.append(lb_preparation.selectHourlyData(list, analysisPeriod_)[7:])\n            annualHourlyDataSplit = annualHourlyDataSplitNew\n        \n        #If a conditional statement is applied, use it to select out data.\n        if patternList != []:\n            newAirTemp = []\n            newRelHumid = []\n            newBarPress = []\n            newOrigHrs = []\n            newFarenheitVals = []\n            newAnnualHourlyDataSplit = []\n            for list in annualHourlyDataSplit:\n                newAnnualHourlyDataSplit.append([])\n            for count, bool in enumerate(patternList):\n                if bool == True:\n                    newAirTemp.append(airTemp[count])\n                    newRelHumid.append(relHumid[count])\n                    newBarPress.append(barPress[count])\n                    newOrigHrs.append(origHrs[count])\n                    if farenheitVals != []:\n                        newFarenheitVals.append(farenheitVals[count])\n                    if annualHourlyDataSplit != [[]]:\n                        for listCount in range(len(annualHourlyDataSplit)):\n                            newAnnualHourlyDataSplit[listCount].append(annualHourlyDataSplit[listCount][count])\n            airTemp = newAirTemp\n            relHumid = newRelHumid\n            barPress = newBarPress\n            origHrs = newOrigHrs\n            farenheitVals = newFarenheitVals\n            annualHourlyDataSplit = newAnnualHourlyDataSplit\n        \n        # Pull out solar radiation if it's needed for the passive solar heating polygon.\n        globHorizRad = []\n        for count, datList in enumerate(annualDataStr):\n            if 'Radiation' in datList[2] and ('Total' in datList[2] or 'Global' in datList[2]):\n                globHorizRad = annualHourlyDataSplit[count]\n        \n        #As long as the calculation length is more than 1, make a colored mesh and get chart points for the input data.\n        legend = []\n        legendSrfs = None\n        if legendFontSize != None: textSize = legendFontSize\n        else: textSize = 0.5\n        if calcLength > 1:\n            hourPts, coloredMesh, meshFaceValues = colorMesh(airTemp, relHumid, barPress, lb_preparation, lb_comfortModels, lb_visualization, scaleFactor, lowB, highB, customColors, IPTrigger, farenheitVals)\n            legendTitle = \"Hours\"\n            if mollierHX_ == True:\n                if IPTrigger: lb_visualization.calculateBB(chartCurves[:3], True)\n                else: lb_visualization.calculateBB(chartCurves[:3], True)\n            else:\n                if IPTrigger:\n                    if enthalpyOrWetBulb_ == True or enthalpyOrWetBulb_ == None: lb_visualization.calculateBB(chartCurves[:3]+chartCurves[100:110], True)\n                    else: lb_visualization.calculateBB(chartCurves[:3]+chartCurves[110:120], True)\n                else:\n                    if enthalpyOrWetBulb_ == True or enthalpyOrWetBulb_ == None: lb_visualization.calculateBB(chartCurves[75:83], True)\n                    else: lb_visualization.calculateBB(chartCurves[80:100], True)\n            legendSrfs, legendText, legendTextCrv, textPt, textSize = lb_visualization.createLegend(meshFaceValues, lowB, highB, numSeg, legendTitle, lb_visualization.BoundingBoxPar, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan)\n            legendColors = lb_visualization.gradientColor(legendText[:-1], lowB, highB, customColors)\n            legendSrfs = lb_visualization.colorMesh(legendColors, legendSrfs)\n            legend.append(legendSrfs)\n            for list in legendTextCrv:\n                for item in list:\n                    legend.append(item)\n            if legendBasePoint == None:\n                legendBasePoint = lb_visualization.BoundingBoxPar[0]\n            if mollierHX_ == True:\n                moveTrans = rc.Geometry.Transform.Translation(0,-20,0)\n                for geo in legend: geo.Transform(moveTrans)\n                legendBasePoint.Transform(moveTrans)\n            \n            #Compile all text into one list.\n            finalLegNum = []\n            formatString = \"%.\"+str(decimalPlaces)+\"f\"\n            for num in legendText:\n                try: finalLegNum.append(formatString % num)\n                except: finalLegNum.append(num)\n            if removeLessThan: pass\n            else:\n                finalLegNum[0] = \"<=\" + finalLegNum[0]\n                finalLegNum[-2] = finalLegNum[-2] + \"<=\"\n            chartText.extend(finalLegNum)\n            chartTextPt.extend(textPt)\n        else:\n            if IPTrigger: hourPts = [rc.Geometry.Point3d(farenheitVals[0], lb_comfortModels.calcHumidRatio(airTemp, relHumid, barPress)[0][0]*scaleFactor, 0)]\n            else: hourPts = [rc.Geometry.Point3d(airTemp[0], lb_comfortModels.calcHumidRatio(airTemp, relHumid, barPress)[0][0]*scaleFactor, 0)]\n            coloredMesh = None\n            meshFaceValues = []\n            legendBasePoint = None\n        \n        # Get a polycurve that represents the boundary of the chart.\n        if not IPTrigger: chartBoundary = rc.Geometry.Curve.JoinCurves([chartCurves[0], chartCurves[25], chartCurves[31], chartCurves[10], chartCurves[11]])[0]\n        else: chartBoundary = rc.Geometry.Curve.JoinCurves([chartCurves[0], chartCurves[35], chartCurves[41], chartCurves[10], chartCurves[11]])[0]\n        \n        # Calculate the comfort and strategy polygons.\n        try:\n            comfortPolyline, comfortPolygon, strategyPolylines, strategyPolygons, strategyTextNames, unionedCurves, tempBelowComf, maxComfortPolyTemp, solarHeatCap, solarTimeConst, bldgBalPt, polyStart = calcComfAndStrategyPolygons(radTemp, windSpeed, metRate, cloLevel, exWork, humidRatioUp, humidRatioLow, passiveStrategy_, humidityLines, calcLengthComf, lb_comfortModels, chartBoundary, scaleFactor, PPDComfortThresh, IPTrigger, opTemp, globHorizRad, airTemp, origAirTemp, origGlobHorizRad, origHrs)\n            #Calculate how many hours are in each comfort or strategy and comfort polygons.\n            totalComfPercent, totalComfOrNot, strategyPercent, strategyOrNot = statisticallyAnalyzePolygons(hourPts, comfortPolyline, strategyPolylines, unionedCurves, epwData, epwStr, strategyTextNames, tempBelowComf, airTemp, maxComfortPolyTemp, globHorizRad, origAirTemp, origGlobHorizRad, origHrs, solarHeatCap, solarTimeConst, bldgBalPt, polyStart, patternList, IPTrigger)\n        except Exception as e:\n            comfortPolyline, comfortPolygon, strategyPolylines, strategyPolygons, strategyTextNames, unionedCurves, tempBelowComf, maxComfortPolyTemp, solarHeatCap, solarTimeConst, bldgBalPt = None, None, [], [], [], [], None, None, None, None, None\n            totalComfPercent, totalComfOrNot, strategyPercent, strategyOrNot = None, [], None, []\n            warning = 'Comfort polygon has fallen completely off of the psych chart.'\n            print warning\n            print e\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n        \n        #Generate colors for the points.\n        if len(totalComfOrNot) > 1:\n            pointColors, pointLegends = getPointColors(totalComfOrNot, annualHourlyDataSplit, annualDataStr, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan, lb_visualization)\n        else:\n            pointColors = []\n            pointLegends = []\n        \n        \n        #If the molier transform is selected, apply it to the chart curves.\n        if mollierHX_ == True:\n            for item in chartCurves:\n                if str(item.ObjectType) == 'Curve': mollierHXTransform(item)\n            try:\n                mollierHXTransform(coloredMesh)\n            except: pass\n            for geo in comfortPolygon: mollierHXTransform(geo)\n            for geo in strategyPolygons: mollierHXTransform(geo)\n            for geo in hourPts: mollierHXTransform(geo)\n            for geo in chartTextPt: mollierHXTransform(geo)\n        \n        #If the user has selected to scale or move the geometry, scale it all and/or move it all.\n        if basePoint_ != None:\n            transformMtx = rc.Geometry.Transform.Translation(basePoint_.X, basePoint_.Y, basePoint_.Z)\n            for geo in chartCurves: geo.Transform(transformMtx)\n            try:\n                coloredMesh.Transform(transformMtx)\n            except: pass\n            for geo in legend: geo.Transform(transformMtx)\n            try:\n                legendBasePoint.Transform(transformMtx)\n            except: pass\n            for geo in comfortPolygon: geo.Transform(transformMtx)\n            for geo in strategyPolygons: geo.Transform(transformMtx)\n            for geo in hourPts: geo.Transform(transformMtx)\n            for list in pointLegends:\n                for geo in list:\n                    geo.Transform(transformMtx)\n            basePoint = basePoint_\n            for geo in chartTextPt: geo.Transform(transformMtx)\n        else: basePoint = rc.Geometry.Point3d(0,0,0)\n        \n        if scale_ != None:\n            transformMtx = rc.Geometry.Transform.Scale(basePoint, scale_)\n            for geo in chartCurves: geo.Transform(transformMtx)\n            try:\n                coloredMesh.Transform(transformMtx)\n            except: pass\n            for geo in legend: geo.Transform(transformMtx)\n            try:\n                legendBasePoint.Transform(transformMtx)\n            except: pass\n            for geo in comfortPolygon: geo.Transform(transformMtx)\n            for geo in strategyPolygons: geo.Transform(transformMtx)\n            for geo in hourPts: geo.Transform(transformMtx)\n            for geo in chartTextPt: geo.Transform(transformMtx)\n        \n        #If the user has set bakeIt to true, bake the geometry.\n        if bakeIt_ > 0:\n            #Make a list with all curves\n            allCurves = []\n            for geo in chartCurves:\n                try:\n                    geo.PointAtStart\n                    allCurves.append(geo)\n                except: pass\n            allCurves.extend(comfortPolygon)\n            allCurves.extend(strategyPolygons)\n            #Set up the new layer.\n            studyLayerName = 'PSYCHROMETRIC_CHARTS'\n            try:\n                if 'Temperature' in _dryBulbTemperature[2]: placeName = _dryBulbTemperature[1]\n                elif 'Humidity' in _relativeHumidity[2]: placeName = _relativeHumidity[1]\n                else: placeName = 'alternateLayerName'\n            except: placeName = 'alternateLayerName'\n            newLayerIndex, l = lb_visualization.setupLayers(None, 'LADYBUG', placeName, studyLayerName, False, False, 0, 0)\n            #Bake the objects.\n            if bakeIt_ == 1: lb_visualization.bakeObjects(newLayerIndex, coloredMesh, legendSrfs, chartText, chartTextPt, textSize, legendFont, allCurves, decimalPlaces, True)\n            else: lb_visualization.bakeObjects(newLayerIndex, coloredMesh, legendSrfs, chartText, chartTextPt, textSize, legendFont, allCurves, decimalPlaces, False)\n        \n        return totalComfPercent, totalComfOrNot, strategyTextNames, strategyPercent, strategyOrNot, chartCurves, coloredMesh, legend, legendBasePoint, comfortPolygon, strategyPolygons, hourPts, pointColors, pointLegends\n    else:\n        print \"You should first let the Ladybug fly...\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"You should first let the Ladybug fly...\")\n        return None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None\n\n\n\n\n#Check the inputs.\ncheckData = False\nif _runIt == True:\n    checkData, epwData, epwStr, calcLength, airTemp, relHumid, barPress, \\\n    avgBarPress, radTemp, windSpeed, metRate, cloLevel, exWork, humidRatioUp, \\\n    humidRatioLow, calcLengthComf, PPDComfortThresh, titleStatement, \\\n    patternList, IPTrigger, farenheitVals, opTemp = checkTheInputs()\n\n#If the inputs are good, run the function.\nif checkData == True:\n    \n    results = main(epwData, epwStr, calcLength, airTemp, relHumid, barPress, \\\n                   avgBarPress, radTemp, windSpeed, metRate, cloLevel, exWork, \\\n                   humidRatioUp, humidRatioLow, calcLengthComf, \\\n                   PPDComfortThresh, titleStatement, patternList, IPTrigger, farenheitVals, \\\n                   opTemp)\n                   \n    if results != -1:\n        totalComfortPercent, totalComfortOrNot, strategyNames, strategyPercentOfTime, \\\n        initStrategyOrNot, chartCurvesAndTxt, psychChartMesh, legend, legendBasePt, \\\n        comfortPolygons, strategyPolygons, chartHourPoints, pointColors, \\\n        pointLegends = results\n    \n        #Unpack the data tree of the strategyOrNot.\n        strategyOrNot = DataTree[Object]()\n        for listCount, list in enumerate(initStrategyOrNot):\n            for item in list:\n                strategyOrNot.Add(item, GH_Path(listCount))\n        #Unpack the data tree of point colors and their legends.\n        hourPointColors = DataTree[Object]()\n        for listCount, list in enumerate(pointColors):\n            for item in list:\n                hourPointColors.Add(item, GH_Path(listCount))\n        hourPointLegend = DataTree[Object]()\n        for listCount, list in enumerate(pointLegends):\n            for item in list:\n                hourPointLegend.Add(item, GH_Path(listCount))\n\n\n\n#Hide the points input.\nghenv.Component.Params.Output[11].Hidden = True\nghenv.Component.Params.Output[15].Hidden = True\nghenv.Component.Params.Output[17].Hidden = True",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}