{
  "source_url": "https://github.com/0000onoff/Projekt-HS24/blob/8a5cd818ae9ed6e0128f64dcd94d646e8e797503/projektmf/Lib/stubs.min/Rhino/DocObjects/Tables.py",
  "repo": "0000onoff/Projekt-HS24",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "projektmf/Lib/stubs.min/Rhino/DocObjects/Tables.py",
  "instruction": "NamespaceTracker represent a CLS namespace.",
  "code": "# encoding: utf-8\n# module Rhino.DocObjects.Tables calls itself Tables\n# from RhinoCommon,Version=5.1.30000.16,Culture=neutral,PublicKeyToken=552281e97c755530\n# by generator 1.145\n\"\"\" NamespaceTracker represent a CLS namespace. \"\"\"\n# no imports\n\n# no functions\n# classes\n\nclass BitmapTable(object,IEnumerable[BitmapEntry],IEnumerable,IRhinoTable[BitmapEntry]):\n \"\"\" Stores the list of bitmaps in a Rhino document. \"\"\"\n def AddBitmap(self,bitmapFilename,replaceExisting):\n  \"\"\"\n  AddBitmap(self: BitmapTable,bitmapFilename: str,replaceExisting: bool) -> int\n\n  \n\n   Adds a new bitmap with specified name to the bitmap table.\n\n  \n\n   bitmapFilename: If NULL or empty,then a unique name of the form \"Bitmap 01\" will be automatically created.\n\n   replaceExisting: If true and the there is alread a bitmap using the specified name,then that bitmap is replaced.\n\n\n    \n     If false and there is already a bitmap using the specified name,then -1 is \n\n    returned.\n\n  \n\n   Returns: index of new bitmap in table on success. -1 on error.\n  \"\"\"\n  pass\n def DeleteBitmap(self,bitmapFilename):\n  \"\"\"\n  DeleteBitmap(self: BitmapTable,bitmapFilename: str) -> bool\n\n  \n\n   Deletes a bitmap.\n\n  \n\n   bitmapFilename: The bitmap file name.\n\n   Returns: true if successful. false if the bitmap cannot be deleted because it\n\n     is the current \n\n    bitmap or because it bitmap contains active geometry.\n  \"\"\"\n  pass\n def ExportToFile(self,index,path):\n  \"\"\"\n  ExportToFile(self: BitmapTable,index: int,path: str) -> bool\n\n  \n\n   Writes a bitmap to a file.\n\n  \n\n   index: The index of the bitmap to be written.\n\n   path: The full path,including file name and extension,name of the file to write.\n\n   Returns: true if successful.\n  \"\"\"\n  pass\n def ExportToFiles(self,directoryPath,overwrite):\n  \"\"\"\n  ExportToFiles(self: BitmapTable,directoryPath: str,overwrite: int) -> int\n\n  \n\n   Exports all the bitmaps in the table to files.\n\n  \n\n   directoryPath: full path to the directory where the bitmaps should be saved.\n\n     If NULL,a dialog is \n\n    used to interactively get the directory name.\n\n  \n\n   overwrite: 0=no,1=yes,2=ask.\n\n   Returns: Number of bitmaps written.\n  \"\"\"\n  pass\n def Find(self,name,createFile,fileName):\n  \"\"\"\n  Find(self: BitmapTable,name: str,createFile: bool) -> (BitmapEntry,str)\n\n  \n\n   This function first attempts to find the file with \"name\" on the disk.\n\n     If it does \n\n    find it,\"fileName\" is set to the full path of the file and\n\n     the BitmapEntry \n\n    returned will be null,even if there was a BitmapEntry\n\n     with \"name\" in the bitmap \n\n    table.\n\n     If the function cannot find the file on the disk,it searches the bitmap\n\n     \n\n       table.  If it finds it,the returned BitmapEntry entry will be the entry\n\n     \n\n    in the table with that name.\n\n     Additionally,if \"createFile\" is true,and an entry is \n\n    found,the file\n\n     will be written to the disk and it's full path will be contained in \n\n    \"fileName\".\n\n  \n\n  \n\n   name: Name of the file to search for including file extension.\n\n   createFile: If this is true,and the file is not found on the disk but is found in\n\n     the \n\n    BitmapTable,then the BitmapEntry will get saved to the Rhino bitmap\n\n     file cache and \n\n    fileName will contain the full path to the cached file.\n\n  \n\n   Returns: Returns null if \"name\" was found on the disk.  If name was not found on the disk,\n\n     \n\n    returns the BitmapEntry with the specified name if it is found in the bitmap table\n\n     \n\n    and null if it was not found in the bitmap table.\n  \"\"\"\n  pass\n def GetEnumerator(self):\n  \"\"\"\n  GetEnumerator(self: BitmapTable) -> IEnumerator[BitmapEntry]\n\n  \n\n   BitmapTable enumerator\n  \"\"\"\n  pass\n def __contains__(self,*args):\n  \"\"\" __contains__[BitmapEntry](enumerable: IEnumerable[BitmapEntry],value: BitmapEntry) -> bool \"\"\"\n  pass\n def __getitem__(self,*args):\n  \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __iter__(self,*args):\n  \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the number of bitmaps in the table.\n\n\n\nGet: Count(self: BitmapTable) -> int\n\n\n\n\"\"\"\n\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the document that owns this bitmap table.\n\n\n\nGet: Document(self: BitmapTable) -> RhinoDoc\n\n\n\n\"\"\"\n\n\n\nclass DimStyleTable(object,IEnumerable[DimensionStyle],IEnumerable,IRhinoTable[DimensionStyle]):\n # no doc\n def Add(self,name,reference=None):\n  \"\"\"\n  Add(self: DimStyleTable,name: str,reference: bool) -> int\n\n  \n\n   Adds a new dimension style to the document. The new dimension style will be initialized\n\n    \n\n     with the current default dimension style properties.\n\n  \n\n  \n\n   name: Name of the new dimension style. If null or empty,Rhino automatically generates the name.\n\n   reference: if true the dimstyle will not be saved in files.\n\n   Returns: index of new dimension style.\n\n  Add(self: DimStyleTable,name: str) -> int\n\n  \n\n   Adds a new dimension style to the document. The new dimension style will be initialized\n\n    \n\n     with the current default dimension style properties.\n\n  \n\n  \n\n   name: Name of the new dimension style. If null or empty,Rhino automatically generates the name.\n\n   Returns: index of new dimension style.\n  \"\"\"\n  pass\n def DeleteDimensionStyle(self,index,quiet):\n  \"\"\" DeleteDimensionStyle(self: DimStyleTable,index: int,quiet: bool) -> bool \"\"\"\n  pass\n def Find(self,name,ignoreDeletedDimensionStyles):\n  \"\"\" Find(self: DimStyleTable,name: str,ignoreDeletedDimensionStyles: bool) -> DimensionStyle \"\"\"\n  pass\n def GetEnumerator(self):\n  \"\"\" GetEnumerator(self: DimStyleTable) -> IEnumerator[DimensionStyle] \"\"\"\n  pass\n def GetUnusedDimensionStyleName(self):\n  \"\"\" GetUnusedDimensionStyleName(self: DimStyleTable) -> str \"\"\"\n  pass\n def SetCurrentDimensionStyleIndex(self,index,quiet):\n  \"\"\" SetCurrentDimensionStyleIndex(self: DimStyleTable,index: int,quiet: bool) -> bool \"\"\"\n  pass\n def __add__(self,*args):\n  \"\"\" x.__add__(y) <==> x+yx.__add__(y) <==> x+y \"\"\"\n  pass\n def __contains__(self,*args):\n  \"\"\" __contains__[DimensionStyle](enumerable: IEnumerable[DimensionStyle],value: DimensionStyle) -> bool \"\"\"\n  pass\n def __getitem__(self,*args):\n  \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __iter__(self,*args):\n  \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Number of dimstyles in the table.\n\n\n\nGet: Count(self: DimStyleTable) -> int\n\n\n\n\"\"\"\n\n CurrentDimensionStyle=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: CurrentDimensionStyle(self: DimStyleTable) -> DimensionStyle\n\n\n\n\"\"\"\n\n CurrentDimensionStyleIndex=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: CurrentDimensionStyleIndex(self: DimStyleTable) -> int\n\n\n\n\"\"\"\n\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Document that owns this dimstyle table.\n\n\n\nGet: Document(self: DimStyleTable) -> RhinoDoc\n\n\n\n\"\"\"\n\n\n\nclass FontTable(object,IEnumerable[Font],IEnumerable,IRhinoTable[Font]):\n \"\"\" Font tables store the list of fonts in a Rhino document. \"\"\"\n def FindOrCreate(self,face,bold,italic):\n  \"\"\" FindOrCreate(self: FontTable,face: str,bold: bool,italic: bool) -> int \"\"\"\n  pass\n def GetEnumerator(self):\n  \"\"\" GetEnumerator(self: FontTable) -> IEnumerator[Font] \"\"\"\n  pass\n def __contains__(self,*args):\n  \"\"\" __contains__[Font](enumerable: IEnumerable[Font],value: Font) -> bool \"\"\"\n  pass\n def __getitem__(self,*args):\n  \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __iter__(self,*args):\n  \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Number of fonts in the table.\n\n\n\nGet: Count(self: FontTable) -> int\n\n\n\n\"\"\"\n\n CurrentIndex=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"At all times,there is a \"current\" font.  Unless otherwise specified,\n\n   new dimension objects are assigned to the current font. The current\n\n   font is never deleted.\n\n   Returns: Zero based font index of the current font.\n\n\n\nGet: CurrentIndex(self: FontTable) -> int\n\n\n\n\"\"\"\n\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Document that owns this table.\n\n\n\nGet: Document(self: FontTable) -> RhinoDoc\n\n\n\n\"\"\"\n\n\n\nclass GroupTable(object):\n \"\"\" Group tables store the list of groups in a Rhino document. \"\"\"\n def Add(self,*__args):\n  \"\"\"\n  Add(self: GroupTable,groupName: str,objectIds: IEnumerable[Guid]) -> int\n\n  Add(self: GroupTable,objectIds: IEnumerable[Guid]) -> int\n\n  Add(self: GroupTable,groupName: str) -> int\n\n  \n\n   Adds a new empty group to the group table.\n\n  \n\n   groupName: name of new group.\n\n   Returns: >=0 index of new group. \n\n     -1 group not added because a group with that name already \n\n    exists.\n\n  \n\n  Add(self: GroupTable) -> int\n\n  \n\n   Adds a new empty group to the group table.\n\n   Returns: >=0 index of new group. \n\n     -1 group not added because a group with that name already \n\n    exists.\n  \"\"\"\n  pass\n def AddToGroup(self,groupIndex,*__args):\n  \"\"\"\n  AddToGroup(self: GroupTable,groupIndex: int,objectIds: IEnumerable[Guid]) -> bool\n\n  AddToGroup(self: GroupTable,groupIndex: int,objectId: Guid) -> bool\n\n  \n\n   Adds an object to an existing group.\n\n  \n\n   groupIndex: The group index value.\n\n   objectId: An ID of an object.\n\n   Returns: true if the operation was successful.\n  \"\"\"\n  pass\n def ChangeGroupName(self,groupIndex,newName):\n  \"\"\" ChangeGroupName(self: GroupTable,groupIndex: int,newName: str) -> bool \"\"\"\n  pass\n def Delete(self,groupIndex):\n  \"\"\"\n  Delete(self: GroupTable,groupIndex: int) -> bool\n\n  \n\n   Deletes a group from this table.\n\n     Deleted groups are kept in the runtime group table \n\n    so that undo\n\n     will work with groups.  Call IsDeleted() to determine if a group is \n\n    deleted.\n\n  \n\n  \n\n   groupIndex: An group index to be deleted.\n\n   Returns: true if the operation was successful.\n  \"\"\"\n  pass\n def Find(self,groupName,ignoreDeletedGroups):\n  \"\"\"\n  Find(self: GroupTable,groupName: str,ignoreDeletedGroups: bool) -> int\n\n  \n\n   Finds a group with a given name.\n\n  \n\n   groupName: Name of group to search for. Ignores case.\n\n   ignoreDeletedGroups: true means don't search deleted groups.\n\n   Returns: >=0 index of the group with the given name.\n\n     -1 no group found with the given name.\n  \"\"\"\n  pass\n def GroupMembers(self,groupIndex):\n  \"\"\"\n  GroupMembers(self: GroupTable,groupIndex: int) -> Array[RhinoObject]\n\n  \n\n   Gets an array of all of the objects in a group.\n\n  \n\n   groupIndex: The index of the group in this table.\n\n   Returns: An array with all the objects in the specified group.\n  \"\"\"\n  pass\n def GroupName(self,groupIndex):\n  \"\"\" GroupName(self: GroupTable,groupIndex: int) -> str \"\"\"\n  pass\n def GroupNames(self,ignoreDeletedGroups):\n  \"\"\" GroupNames(self: GroupTable,ignoreDeletedGroups: bool) -> Array[str] \"\"\"\n  pass\n def GroupObjectCount(self,groupIndex):\n  \"\"\" GroupObjectCount(self: GroupTable,groupIndex: int) -> int \"\"\"\n  pass\n def Hide(self,groupIndex):\n  \"\"\" Hide(self: GroupTable,groupIndex: int) -> int \"\"\"\n  pass\n def IsDeleted(self,groupIndex):\n  \"\"\" IsDeleted(self: GroupTable,groupIndex: int) -> bool \"\"\"\n  pass\n def Lock(self,groupIndex):\n  \"\"\" Lock(self: GroupTable,groupIndex: int) -> int \"\"\"\n  pass\n def Show(self,groupIndex):\n  \"\"\" Show(self: GroupTable,groupIndex: int) -> int \"\"\"\n  pass\n def Undelete(self,groupIndex):\n  \"\"\" Undelete(self: GroupTable,groupIndex: int) -> bool \"\"\"\n  pass\n def Unlock(self,groupIndex):\n  \"\"\" Unlock(self: GroupTable,groupIndex: int) -> int \"\"\"\n  pass\n def __add__(self,*args):\n  \"\"\" x.__add__(y) <==> x+yx.__add__(y) <==> x+yx.__add__(y) <==> x+yx.__add__(y) <==> x+y \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Number of groups in the group table.\n\n\n\nGet: Count(self: GroupTable) -> int\n\n\n\n\"\"\"\n\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Document that owns this group table.\n\n\n\nGet: Document(self: GroupTable) -> RhinoDoc\n\n\n\n\"\"\"\n\n\n\nclass GroupTableEventArgs(EventArgs):\n # no doc\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: Document(self: GroupTableEventArgs) -> RhinoDoc\n\n\n\n\"\"\"\n\n EventType=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: EventType(self: GroupTableEventArgs) -> GroupTableEventType\n\n\n\n\"\"\"\n\n\n\nclass GroupTableEventType(Enum,IComparable,IFormattable,IConvertible):\n \"\"\" enum GroupTableEventType,values: Added (0),Deleted (1),Modified (3),Sorted (4),Undeleted (2) \"\"\"\n def __eq__(self,*args):\n  \"\"\" x.__eq__(y) <==> x==yx.__eq__(y) <==> x==yx.__eq__(y) <==> x==y \"\"\"\n  pass\n def __format__(self,*args):\n  \"\"\" __format__(formattable: IFormattable,format: str) -> str \"\"\"\n  pass\n def __ge__(self,*args):\n  pass\n def __gt__(self,*args):\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __le__(self,*args):\n  pass\n def __lt__(self,*args):\n  pass\n def __ne__(self,*args):\n  pass\n def __reduce_ex__(self,*args):\n  pass\n def __str__(self,*args):\n  pass\n Added=None\n Deleted=None\n Modified=None\n Sorted=None\n Undeleted=None\n value__=None\n\n\nclass HatchPatternTable(object,IEnumerable[HatchPattern],IEnumerable,IRhinoTable[HatchPattern]):\n \"\"\" All of the hatch pattern definitions contained in a rhino document. \"\"\"\n def Add(self,pattern):\n  \"\"\"\n  Add(self: HatchPatternTable,pattern: HatchPattern) -> int\n\n  \n\n   Adds a new hatch pattern with specified definition to the table.\n\n  \n\n   pattern: definition of new hatch pattern. The information in pattern is copied.\n\n     If \n\n    patern.Name is empty the a unique name of the form \"HatchPattern 01\"\n\n     will be \n\n    automatically created.\n\n  \n\n   Returns: >=0 index of new hatch pattern\n\n     -1  not added because a hatch pattern with that name \n\n    already exists or\n\n     some other problem occured.\n  \"\"\"\n  pass\n def Find(self,name,ignoreDeleted):\n  \"\"\"\n  Find(self: HatchPatternTable,name: str,ignoreDeleted: bool) -> int\n\n  \n\n   Finds the hatch pattern with a given name. Search ignores case.\n\n  \n\n   name: The name of the hatch patter to be found.\n\n   ignoreDeleted: true means don't search deleted hatch patterns.\n\n   Returns: Index of the hatch pattern with the given name. -1 if no hatch pattern found.\n  \"\"\"\n  pass\n def GetEnumerator(self):\n  \"\"\" GetEnumerator(self: HatchPatternTable) -> IEnumerator[HatchPattern] \"\"\"\n  pass\n def __add__(self,*args):\n  \"\"\" x.__add__(y) <==> x+y \"\"\"\n  pass\n def __contains__(self,*args):\n  \"\"\" __contains__[HatchPattern](enumerable: IEnumerable[HatchPattern],value: HatchPattern) -> bool \"\"\"\n  pass\n def __getitem__(self,*args):\n  \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __iter__(self,*args):\n  \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Number of patterns in the table.\n\n\n\nGet: Count(self: HatchPatternTable) -> int\n\n\n\n\"\"\"\n\n CurrentHatchPatternIndex=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"At all times,there is a \"current\" hatch pattern.  Unless otherwise\n\n   specified,new objects are assigned to the current hatch pattern.\n\n   The current hatch pattern is never locked,hidden,or deleted.\n\n\n\nGet: CurrentHatchPatternIndex(self: HatchPatternTable) -> int\n\n\n\nSet: CurrentHatchPatternIndex(self: HatchPatternTable)=value\n\n\"\"\"\n\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Document that owns this table.\n\n\n\nGet: Document(self: HatchPatternTable) -> RhinoDoc\n\n\n\n\"\"\"\n\n\n\nclass InstanceDefinitionTable(object,IEnumerable[InstanceDefinition],IEnumerable,IRhinoTable[InstanceDefinition]):\n # no doc\n def Add(self,name,description,basePoint,geometry,attributes=None):\n  \"\"\"\n  Add(self: InstanceDefinitionTable,name: str,description: str,basePoint: Point3d,geometry: GeometryBase,attributes: ObjectAttributes) -> int\n\n  \n\n   Adds an instance definition to the instance definition table.\n\n  \n\n   name: The definition name.\n\n   description: The definition description.\n\n   basePoint: A base point.\n\n   geometry: An element.\n\n   attributes: An attribute.\n\n   Returns: >=0  index of instance definition in the instance definition table. -1 on failure.\n\n  Add(self: InstanceDefinitionTable,name: str,description: str,basePoint: Point3d,geometry: IEnumerable[GeometryBase]) -> int\n\n  Add(self: InstanceDefinitionTable,name: str,description: str,basePoint: Point3d,geometry: IEnumerable[GeometryBase],attributes: IEnumerable[ObjectAttributes]) -> int\n  \"\"\"\n  pass\n def Compact(self,ignoreUndoReferences):\n  \"\"\"\n  Compact(self: InstanceDefinitionTable,ignoreUndoReferences: bool)\n\n   Purge deleted instance definition information that is not in use.\n\n     This function is \n\n    time consuming and should be used in a thoughtful manner.\n\n  \n\n  \n\n   ignoreUndoReferences: If false,then deleted instance definition information that could possibly\n\n     be \n\n    undeleted by the Undo command will not be deleted. If true,then all\n\n     deleted \n\n    instance definition information is deleted.\n  \"\"\"\n  pass\n def Delete(self,idefIndex,deleteReferences,quiet):\n  \"\"\"\n  Delete(self: InstanceDefinitionTable,idefIndex: int,deleteReferences: bool,quiet: bool) -> bool\n\n  \n\n   Deletes the instance definition.\n\n  \n\n   idefIndex: zero based index of instance definition to delete.\n\n     This must be in the range 0 <= \n\n    idefIndex < InstanceDefinitionTable.Count.\n\n  \n\n   deleteReferences: true to delete all references to this definition.\n\n     false to delete definition only \n\n    if there are no references.\n\n  \n\n   quiet: If true,no warning message box appears if an instance definition cannot be\n\n     deleted \n\n    because it is the current layer or it contains active geometry.\n\n  \n\n   Returns: true if successful. false if the instance definition has active references and bDeleteReferences \n\n    is false.\n  \"\"\"\n  pass\n def Find(self,*__args):\n  \"\"\"\n  Find(self: InstanceDefinitionTable,instanceId: Guid,ignoreDeletedInstanceDefinitions: bool) -> InstanceDefinition\n\n  \n\n   Finds the instance definition with a given id.\n\n  \n\n   instanceId: Unique id of the instance definition to search for.\n\n   ignoreDeletedInstanceDefinitions: true means don't search deleted instance definitions.\n\n   Returns: The specified instance definition,or null if nothing matching was found.\n\n  Find(self: InstanceDefinitionTable,instanceDefinitionName: str,ignoreDeletedInstanceDefinitions: bool) -> InstanceDefinition\n\n  \n\n   Finds the instance definition with a given name.\n\n  \n\n   instanceDefinitionName: name of instance definition to search for (ignores case)\n\n   ignoreDeletedInstanceDefinitions: true means don't search deleted instance definitions.\n\n   Returns: The specified instance definition,or null if nothing matching was found.\n  \"\"\"\n  pass\n def GetEnumerator(self):\n  \"\"\" GetEnumerator(self: InstanceDefinitionTable) -> IEnumerator[InstanceDefinition] \"\"\"\n  pass\n def GetList(self,ignoreDeleted):\n  \"\"\"\n  GetList(self: InstanceDefinitionTable,ignoreDeleted: bool) -> Array[InstanceDefinition]\n\n  \n\n   Gets an array of instance definitions.\n\n  \n\n   ignoreDeleted: If true then deleted idefs are filtered out.\n\n   Returns: An array of instance definitions. This can be empty,but not null.\n  \"\"\"\n  pass\n def GetUnusedInstanceDefinitionName(self,root=None,defaultSuffix=None):\n  \"\"\"\n  GetUnusedInstanceDefinitionName(self: InstanceDefinitionTable,root: str,defaultSuffix: UInt32) -> str\n\n  \n\n   Gets unsed instance definition name used as default when creating\n\n     new instance \n\n    definitions.\n\n  \n\n  \n\n   root: The returned name is 'root nn'  If root is empty,then 'Block' (localized) is used.\n\n   defaultSuffix: Unique names are created by appending a decimal number to the\n\n     localized term for \n\n    \"Block\" as in \"Block 01\",\"Block 02\",\n\n     and so on.  When defaultSuffix is supplied,\n\n    the search for an unused\n\n     name begins at \"Block suffix\".\n\n  \n\n   Returns: An unused instance definition name string.\n\n  GetUnusedInstanceDefinitionName(self: InstanceDefinitionTable,root: str) -> str\n\n  \n\n   Gets unsed instance definition name used as default when creating\n\n     new instance \n\n    definitions.\n\n  \n\n  \n\n   root: The returned name is 'root nn'  If root is empty,then 'Block' (localized) is used.\n\n   Returns: An unused instance definition name string.\n\n  GetUnusedInstanceDefinitionName(self: InstanceDefinitionTable) -> str\n\n  \n\n   Gets unsed instance definition name used as default when creating\n\n     new instance \n\n    definitions.\n\n  \n\n   Returns: An unused instance definition name string.\n  \"\"\"\n  pass\n def MakeSourcePathRelative(self,idef,relative,quiet):\n  \"\"\"\n  MakeSourcePathRelative(self: InstanceDefinitionTable,idef: InstanceDefinition,relative: bool,quiet: bool) -> bool\n\n  \n\n   Marks the source path for a linked instance definition as relative or absolute.\n\n  \n\n   idef: The instance definition to be marked.\n\n   relative: If true,the path should be considered as relative.If false,the path should be considered as \n\n    absolute.\n\n  \n\n   quiet: If true,then message boxes about erroneous parameters will not be shown.\n\n   Returns: true if the instance defintion could be modified.\n  \"\"\"\n  pass\n def Modify(self,*__args):\n  \"\"\"\n  Modify(self: InstanceDefinitionTable,idefIndex: int,newName: str,newDescription: str,quiet: bool) -> bool\n\n  \n\n   Modifies the instance definition name and description.\n\n     Does not change instance \n\n    definition ID or geometry.\n\n  \n\n  \n\n   idefIndex: The index of the instance definition to be modified.\n\n   newName: The new name.\n\n   newDescription: The new description string.\n\n   quiet: If true,information message boxes pop up when illegal changes are attempted.\n\n   Returns: true if successful.\n\n  Modify(self: InstanceDefinitionTable,idef: InstanceDefinition,newName: str,newDescription: str,quiet: bool) -> bool\n\n  \n\n   Modifies the instance definition name and description.\n\n     Does not change instance \n\n    definition ID or geometry.\n\n  \n\n  \n\n   idef: The instance definition to be modified.\n\n   newName: The new name.\n\n   newDescription: The new description string.\n\n   quiet: If true,information message boxes pop up when illegal changes are attempted.\n\n   Returns: true if successful.\n  \"\"\"\n  pass\n def ModifyGeometry(self,idefIndex,newGeometry,newAttributes=None):\n  \"\"\"\n  ModifyGeometry(self: InstanceDefinitionTable,idefIndex: int,newGeometry: GeometryBase,newAttributes: ObjectAttributes) -> bool\n\n  ModifyGeometry(self: InstanceDefinitionTable,idefIndex: int,newGeometry: IEnumerable[GeometryBase]) -> bool\n\n  ModifyGeometry(self: InstanceDefinitionTable,idefIndex: int,newGeometry: IEnumerable[GeometryBase],newAttributes: IEnumerable[ObjectAttributes]) -> bool\n  \"\"\"\n  pass\n def Purge(self,idefIndex):\n  \"\"\"\n  Purge(self: InstanceDefinitionTable,idefIndex: int) -> bool\n\n  \n\n   Purges an instance definition and its definition geometry.\n\n  \n\n   idefIndex: zero based index of instance definition to delete.\n\n     This must be in the range 0 <= \n\n    idefIndex < InstanceDefinitionTable.Count.\n\n  \n\n   Returns: True if successful. False if the instance definition cannot be purged\n\n     because it is \n\n    in use by reference objects or undo information.\n  \"\"\"\n  pass\n def Undelete(self,idefIndex):\n  \"\"\"\n  Undelete(self: InstanceDefinitionTable,idefIndex: int) -> bool\n\n  \n\n   Undeletes an instance definition that has been deleted by Delete()\n\n  \n\n   idefIndex: zero based index of instance definition to delete.\n\n     This must be in the range 0 <= \n\n    idefIndex < InstanceDefinitionTable.Count.\n\n  \n\n   Returns: true if successful\n  \"\"\"\n  pass\n def UndoModify(self,idefIndex):\n  \"\"\"\n  UndoModify(self: InstanceDefinitionTable,idefIndex: int) -> bool\n\n  \n\n   Restores the instance definition to its previous state,\n\n     if the instance definition \n\n    has been modified and the modification can be undone.\n\n  \n\n  \n\n   idefIndex: The index of the instance definition to be restored.\n\n   Returns: true if operation succeeded.\n  \"\"\"\n  pass\n def UpdateLinkedInstanceDefinition(self,idefIndex,filename,updateNestedLinks,quiet):\n  \"\"\"\n  UpdateLinkedInstanceDefinition(self: InstanceDefinitionTable,idefIndex: int,filename: str,updateNestedLinks: bool,quiet: bool) -> bool\n\n  \n\n   Read the objects from a file and use them as the instance's definition geometry.\n\n  \n\n   idefIndex: zero based index of instance definition to delete.\n\n     This must be in the range 0 <= \n\n    idefIndex < InstanceDefinitionTable.Count.\n\n  \n\n   filename: name of file (can be any type of file that Rhino or a plug-in can read)\n\n   updateNestedLinks: If true and the instance definition referes to a linked instance definition,\n\n     that \n\n    needs to be updated,then the nested defition is also updated. If\n\n     false,nested \n\n    updates are skipped.\n  \"\"\"\n  pass\n def __add__(self,*args):\n  \"\"\" x.__add__(y) <==> x+yx.__add__(y) <==> x+yx.__add__(y) <==> x+y \"\"\"\n  pass\n def __contains__(self,*args):\n  \"\"\" __contains__[InstanceDefinition](enumerable: IEnumerable[InstanceDefinition],value: InstanceDefinition) -> bool \"\"\"\n  pass\n def __getitem__(self,*args):\n  \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __iter__(self,*args):\n  \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n ActiveCount=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Number of items in the instance definitions table,excluding deleted definitions.\n\n\n\nGet: ActiveCount(self: InstanceDefinitionTable) -> int\n\n\n\n\"\"\"\n\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Number of items in the instance definitions table.\n\n\n\nGet: Count(self: InstanceDefinitionTable) -> int\n\n\n\n\"\"\"\n\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Document that owns this table.\n\n\n\nGet: Document(self: InstanceDefinitionTable) -> RhinoDoc\n\n\n\n\"\"\"\n\n\n\nclass InstanceDefinitionTableEventArgs(EventArgs):\n # no doc\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: Document(self: InstanceDefinitionTableEventArgs) -> RhinoDoc\n\n\n\n\"\"\"\n\n EventType=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: EventType(self: InstanceDefinitionTableEventArgs) -> InstanceDefinitionTableEventType\n\n\n\n\"\"\"\n\n InstanceDefinitionIndex=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: InstanceDefinitionIndex(self: InstanceDefinitionTableEventArgs) -> int\n\n\n\n\"\"\"\n\n NewState=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: NewState(self: InstanceDefinitionTableEventArgs) -> InstanceDefinition\n\n\n\n\"\"\"\n\n OldState=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: OldState(self: InstanceDefinitionTableEventArgs) -> InstanceDefinitionGeometry\n\n\n\n\"\"\"\n\n\n\nclass InstanceDefinitionTableEventType(Enum,IComparable,IFormattable,IConvertible):\n \"\"\" enum InstanceDefinitionTableEventType,values: Added (0),Deleted (1),Modified (3),Sorted (4),Undeleted (2) \"\"\"\n def __eq__(self,*args):\n  \"\"\" x.__eq__(y) <==> x==yx.__eq__(y) <==> x==yx.__eq__(y) <==> x==y \"\"\"\n  pass\n def __format__(self,*args):\n  \"\"\" __format__(formattable: IFormattable,format: str) -> str \"\"\"\n  pass\n def __ge__(self,*args):\n  pass\n def __gt__(self,*args):\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __le__(self,*args):\n  pass\n def __lt__(self,*args):\n  pass\n def __ne__(self,*args):\n  pass\n def __reduce_ex__(self,*args):\n  pass\n def __str__(self,*args):\n  pass\n Added=None\n Deleted=None\n Modified=None\n Sorted=None\n Undeleted=None\n value__=None\n\n\nclass LayerTable(object,IEnumerable[Layer],IEnumerable,IRhinoTable[Layer]):\n # no doc\n def Add(self,*__args):\n  \"\"\"\n  Add(self: LayerTable) -> int\n\n  \n\n   Adds a new layer with default definition to the layer table.\n\n   Returns: index of new layer.\n\n  Add(self: LayerTable,layerName: str,layerColor: Color) -> int\n\n  \n\n   Adds a new layer with specified definition to the layer table.\n\n  \n\n   layerName: Name for new layer. Cannot be a null or zero-length string.\n\n   layerColor: Color of new layer. Alpha components will be ignored.\n\n   Returns: >=0 index of new layer\n\n     -1  layer not added because a layer with that name already \n\n    exists.\n\n  \n\n  Add(self: LayerTable,layer: Layer) -> int\n\n  \n\n   Adds a new layer with specified definition to the layer table.\n\n  \n\n   layer: definition of new layer. The information in layer is copied. If layer.Name is empty\n\n     \n\n    the a unique name of the form \"Layer 01\" will be automatically created.\n\n  \n\n   Returns: >=0 index of new layer\n\n     -1  layer not added because a layer with that name already \n\n    exists.\n  \"\"\"\n  pass\n def AddReferenceLayer(self,layer=None):\n  \"\"\"\n  AddReferenceLayer(self: LayerTable) -> int\n\n  \n\n   Adds a new reference layer with default definition to the layer table.\n\n     Reference \n\n    layers are not saved in files.\n\n  \n\n   Returns: index of new layer.\n\n  AddReferenceLayer(self: LayerTable,layer: Layer) -> int\n\n  \n\n   Adds a new reference layer with specified definition to the layer table\n\n     Reference \n\n    layers are not saved in files.\n\n  \n\n  \n\n   layer: definition of new layer. The information in layer is copied. If layer.Name is empty\n\n     \n\n    the a unique name of the form \"Layer 01\" will be automatically created.\n\n  \n\n   Returns: >=0 index of new layer\n\n     -1  layer not added because a layer with that name already \n\n    exists.\n  \"\"\"\n  pass\n def Delete(self,layerIndex,quiet):\n  \"\"\"\n  Delete(self: LayerTable,layerIndex: int,quiet: bool) -> bool\n\n  \n\n   Deletes layer.\n\n  \n\n   layerIndex: zero based index of layer to delete. This must be in the range 0 <= layerIndex < \n\n    LayerTable.Count.\n\n  \n\n   quiet: If true,no warning message box appears if a layer the layer cannot be\n\n     deleted \n\n    because it is the current layer or it contains active geometry.\n\n  \n\n   Returns: true if successful. false if layerIndex is out of range or the the layer cannot be\n\n     \n\n    deleted because it is the current layer or because it layer contains active geometry.\n  \"\"\"\n  pass\n def Find(self,*__args):\n  \"\"\"\n  Find(self: LayerTable,layerId: Guid,ignoreDeletedLayers: bool) -> int\n\n  \n\n   Finds a layer with a matching ID.\n\n  \n\n   layerId: A valid layer ID.\n\n   ignoreDeletedLayers: If true,deleted layers are not checked.\n\n   Returns: >=0 index of the layer with the given name\n\n     -1  no layer has the given name.\n\n  Find(self: LayerTable,layerName: str,ignoreDeletedLayers: bool) -> int\n\n  \n\n   Finds the layer with a given name. If multiple layers exist that have the same name,the\n\n      \n\n      first match layer index will be returned.\n\n  \n\n  \n\n   layerName: name of layer to search for. The search ignores case.\n\n   ignoreDeletedLayers: true means don't search deleted layers.\n\n   Returns: >=0 index of the layer with the given name\n\n     -1  no layer has the given name.\n  \"\"\"\n  pass\n def FindByFullPath(self,layerPath,ignoreDeletedLayers):\n  \"\"\" FindByFullPath(self: LayerTable,layerPath: str,ignoreDeletedLayers: bool) -> int \"\"\"\n  pass\n def FindNext(self,index,layerName,ignoreDeletedLayers):\n  \"\"\" FindNext(self: LayerTable,index: int,layerName: str,ignoreDeletedLayers: bool) -> int \"\"\"\n  pass\n def ForceLayerVisible(self,*__args):\n  \"\"\"\n  ForceLayerVisible(self: LayerTable,layerIndex: int) -> bool\n\n  \n\n   Makes a layer and all of its parent layers visible.\n\n  \n\n   layerIndex: The layer index to be made visible.\n\n   Returns: true if the operation succeeded.\n\n  ForceLayerVisible(self: LayerTable,layerId: Guid) -> bool\n\n  \n\n   Makes a layer and all of its parent layers visible.\n\n  \n\n   layerId: The layer ID to be made visible.\n\n   Returns: true if the operation succeeded.\n  \"\"\"\n  pass\n def GetEnumerator(self):\n  \"\"\" GetEnumerator(self: LayerTable) -> IEnumerator[Layer] \"\"\"\n  pass\n def GetUnusedLayerName(self,ignoreDeleted):\n  \"\"\"\n  GetUnusedLayerName(self: LayerTable,ignoreDeleted: bool) -> str\n\n  \n\n   Gets the next unused layer name used as default when creating new layers.\n\n  \n\n   ignoreDeleted: If this is true then Rhino may use a name used by a deleted layer.\n\n   Returns: An unused layer name string.\n  \"\"\"\n  pass\n def Modify(self,newSettings,layerIndex,quiet):\n  \"\"\"\n  Modify(self: LayerTable,newSettings: Layer,layerIndex: int,quiet: bool) -> bool\n\n  \n\n   Modifies layer settings.\n\n  \n\n   newSettings: This information is copied.\n\n   layerIndex: zero based index of layer to set.  This must be in the range 0 <= layerIndex < LayerTable.Count.\n\n   quiet: if true,information message boxes pop up when illegal changes are attempted.\n\n   Returns: true if successful. false if layerIndex is out of range or the settings attempt\n\n     to \n\n    lock or hide the current layer.\n  \"\"\"\n  pass\n def Purge(self,layerIndex,quiet):\n  \"\"\"\n  Purge(self: LayerTable,layerIndex: int,quiet: bool) -> bool\n\n  \n\n   Delete layer and all geometry objects on a layer\n\n  \n\n   layerIndex: zero based index of layer to delete. This must be in the range 0 <= layerIndex < \n\n    LayerTable.Count.\n\n  \n\n   quiet: If true,no warning message box appears if a layer the layer cannot be\n\n     deleted \n\n    because it is the current layer.\n\n  \n\n   Returns: true if successful. false if layerIndex is out of range or the the layer cannot be\n\n     \n\n    deleted because it is the current layer.\n  \"\"\"\n  pass\n def SetCurrentLayerIndex(self,layerIndex,quiet):\n  \"\"\"\n  SetCurrentLayerIndex(self: LayerTable,layerIndex: int,quiet: bool) -> bool\n\n  \n\n   At all times,there is a \"current\" layer. Unless otherwise specified,new objects\n\n     \n\n    are assigned to the current layer. The current layer is never locked,hidden,or deleted.\n\n  \n\n  \n\n   layerIndex: Value for new current layer. 0 <= layerIndex < LayerTable.Count.\n\n     The layer's mode \n\n    is automatically set to NormalMode.\n\n  \n\n   quiet: if true,then no warning message box pops up if the current layer request can't be satisfied.\n\n   Returns: true if current layer index successfully set.\n  \"\"\"\n  pass\n def Undelete(self,layerIndex):\n  \"\"\"\n  Undelete(self: LayerTable,layerIndex: int) -> bool\n\n  \n\n   Undeletes a layer that has been deleted by DeleteLayer().\n\n  \n\n   layerIndex: zero based index of layer to undelete.\n\n     This must be in the range 0 <= layerIndex < \n\n    LayerTable.Count.\n\n  \n\n   Returns: true if successful.\n  \"\"\"\n  pass\n def UndoModify(self,layerIndex,undoRecordSerialNumber=None):\n  \"\"\"\n  UndoModify(self: LayerTable,layerIndex: int) -> bool\n\n  UndoModify(self: LayerTable,layerIndex: int,undoRecordSerialNumber: UInt32) -> bool\n\n  \n\n   Restores the layer to its previous state,\n\n     if the layer has been modified and the \n\n    modification can be undone.\n\n  \n\n  \n\n   layerIndex: The layer index to be used.\n\n   undoRecordSerialNumber: The undo record serial number. Pass 0 not to specify one.\n\n   Returns: true if this layer had been modified and the modifications were undone.\n  \"\"\"\n  pass\n def __add__(self,*args):\n  \"\"\" x.__add__(y) <==> x+yx.__add__(y) <==> x+yx.__add__(y) <==> x+y \"\"\"\n  pass\n def __contains__(self,*args):\n  \"\"\" __contains__[Layer](enumerable: IEnumerable[Layer],value: Layer) -> bool \"\"\"\n  pass\n def __getitem__(self,*args):\n  \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __iter__(self,*args):\n  \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n ActiveCount=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Returns number of layers in the layer table,excluding deleted layers.\n\n\n\nGet: ActiveCount(self: LayerTable) -> int\n\n\n\n\"\"\"\n\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Returns number of layers in the layer table,including deleted layers.\n\n\n\nGet: Count(self: LayerTable) -> int\n\n\n\n\"\"\"\n\n CurrentLayer=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"At all times,there is a \"current\" layer. Unless otherwise specified,\n\n   new objects are assigned to the current layer. The current layer is\n\n   never locked,hidden,or deleted.\n\n   \n\n   Returns reference to the current layer. Note that this reference may\n\n   become invalid after a call to AddLayer().\n\n\n\nGet: CurrentLayer(self: LayerTable) -> Layer\n\n\n\n\"\"\"\n\n CurrentLayerIndex=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"At all times,there is a \"current\" layer.  Unless otherwise specified,new objects\n\n   are assigned to the current layer. The current layer is never locked,hidden,or deleted.\n\n   Resturns: Zero based layer table index of the current layer.\n\n\n\nGet: CurrentLayerIndex(self: LayerTable) -> int\n\n\n\n\"\"\"\n\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Document that owns this table.\n\n\n\nGet: Document(self: LayerTable) -> RhinoDoc\n\n\n\n\"\"\"\n\n\n\nclass LayerTableEventArgs(EventArgs):\n # no doc\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: Document(self: LayerTableEventArgs) -> RhinoDoc\n\n\n\n\"\"\"\n\n EventType=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: EventType(self: LayerTableEventArgs) -> LayerTableEventType\n\n\n\n\"\"\"\n\n LayerIndex=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: LayerIndex(self: LayerTableEventArgs) -> int\n\n\n\n\"\"\"\n\n NewState=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: NewState(self: LayerTableEventArgs) -> Layer\n\n\n\n\"\"\"\n\n OldState=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: OldState(self: LayerTableEventArgs) -> Layer\n\n\n\n\"\"\"\n\n\n\nclass LayerTableEventType(Enum,IComparable,IFormattable,IConvertible):\n \"\"\" enum LayerTableEventType,values: Added (0),Current (5),Deleted (1),Modified (3),Sorted (4),Undeleted (2) \"\"\"\n def __eq__(self,*args):\n  \"\"\" x.__eq__(y) <==> x==yx.__eq__(y) <==> x==yx.__eq__(y) <==> x==y \"\"\"\n  pass\n def __format__(self,*args):\n  \"\"\" __format__(formattable: IFormattable,format: str) -> str \"\"\"\n  pass\n def __ge__(self,*args):\n  pass\n def __gt__(self,*args):\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __le__(self,*args):\n  pass\n def __lt__(self,*args):\n  pass\n def __ne__(self,*args):\n  pass\n def __reduce_ex__(self,*args):\n  pass\n def __str__(self,*args):\n  pass\n Added=None\n Current=None\n Deleted=None\n Modified=None\n Sorted=None\n Undeleted=None\n value__=None\n\n\nclass LightTable(object,IEnumerable[LightObject],IEnumerable,IRhinoTable[LightObject]):\n # no doc\n def Add(self,light,attributes=None):\n  \"\"\"\n  Add(self: LightTable,light: Light,attributes: ObjectAttributes) -> int\n\n  Add(self: LightTable,light: Light) -> int\n  \"\"\"\n  pass\n def Find(self,id,ignoreDeleted):\n  \"\"\" Find(self: LightTable,id: Guid,ignoreDeleted: bool) -> int \"\"\"\n  pass\n def GetEnumerator(self):\n  \"\"\" GetEnumerator(self: LightTable) -> IEnumerator[LightObject] \"\"\"\n  pass\n def Modify(self,*__args):\n  \"\"\"\n  Modify(self: LightTable,index: int,light: Light) -> bool\n\n  Modify(self: LightTable,id: Guid,light: Light) -> bool\n  \"\"\"\n  pass\n def __add__(self,*args):\n  \"\"\" x.__add__(y) <==> x+yx.__add__(y) <==> x+y \"\"\"\n  pass\n def __contains__(self,*args):\n  \"\"\" __contains__[LightObject](enumerable: IEnumerable[LightObject],value: LightObject) -> bool \"\"\"\n  pass\n def __getitem__(self,*args):\n  \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __iter__(self,*args):\n  \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Number of lights in the light table.  Does not include Sun or Skylight.\n\n\n\nGet: Count(self: LightTable) -> int\n\n\n\n\"\"\"\n\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Document that owns this light table.\n\n\n\nGet: Document(self: LightTable) -> RhinoDoc\n\n\n\n\"\"\"\n\n Sun=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the Sun instance that is applied to the document.\n\n   If the RDK is loaded,an instance is always returned.\n\n\n\nGet: Sun(self: LightTable) -> Sun\n\n\n\n\"\"\"\n\n\n\nclass LightTableEventArgs(EventArgs):\n # no doc\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: Document(self: LightTableEventArgs) -> RhinoDoc\n\n\n\n\"\"\"\n\n EventType=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: EventType(self: LightTableEventArgs) -> LightTableEventType\n\n\n\n\"\"\"\n\n LightIndex=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: LightIndex(self: LightTableEventArgs) -> int\n\n\n\n\"\"\"\n\n NewState=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: NewState(self: LightTableEventArgs) -> LightObject\n\n\n\n\"\"\"\n\n OldState=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: OldState(self: LightTableEventArgs) -> Light\n\n\n\n\"\"\"\n\n\n\nclass LightTableEventType(Enum,IComparable,IFormattable,IConvertible):\n \"\"\" enum LightTableEventType,values: Added (0),Deleted (1),Modified (3),Sorted (4),Undeleted (2) \"\"\"\n def __eq__(self,*args):\n  \"\"\" x.__eq__(y) <==> x==yx.__eq__(y) <==> x==yx.__eq__(y) <==> x==y \"\"\"\n  pass\n def __format__(self,*args):\n  \"\"\" __format__(formattable: IFormattable,format: str) -> str \"\"\"\n  pass\n def __ge__(self,*args):\n  pass\n def __gt__(self,*args):\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __le__(self,*args):\n  pass\n def __lt__(self,*args):\n  pass\n def __ne__(self,*args):\n  pass\n def __reduce_ex__(self,*args):\n  pass\n def __str__(self,*args):\n  pass\n Added=None\n Deleted=None\n Modified=None\n Sorted=None\n Undeleted=None\n value__=None\n\n\nclass LinetypeTable(object,IEnumerable[Linetype],IEnumerable,IRhinoTable[Linetype]):\n # no doc\n def Add(self,*__args):\n  \"\"\"\n  Add(self: LinetypeTable,name: str,segmentLengths: IEnumerable[float]) -> int\n\n  Add(self: LinetypeTable,linetype: Linetype) -> int\n\n  \n\n   Adds a new linetype with specified definition to the linetype table.\n\n  \n\n   linetype: Definition of new linetype.  The information in linetype is copied.\n\n     If \n\n    linetype.Name is empty then a unique name of the form \"Linetype 01\"\n\n     will be \n\n    automatically created.\n\n  \n\n   Returns: Index of newline type or -1 on error.\n  \"\"\"\n  pass\n def AddReferenceLinetype(self,linetype):\n  \"\"\"\n  AddReferenceLinetype(self: LinetypeTable,linetype: Linetype) -> int\n\n  \n\n   Adds a reference linetypes that will not be saved in files.\n\n  \n\n   linetype: Definition of new linetype.  The information in linetype is copied.\n\n     If \n\n    linetype.Name is empty then a unique name of the form \"Linetype 01\"\n\n     will be \n\n    automatically created.\n\n  \n\n   Returns: Index of new linetype or -1 on error.\n  \"\"\"\n  pass\n def Delete(self,*__args):\n  \"\"\"\n  Delete(self: LinetypeTable,indices: IEnumerable[int],quiet: bool) -> bool\n\n  Delete(self: LinetypeTable,index: int,quiet: bool) -> bool\n\n  \n\n   Deletes linetype.\n\n  \n\n   index: zero based index of linetype to delete.\n\n   quiet: If true,no warning message box appears if a linetype the\n\n     linetype cannot be \n\n    deleted because it is the current linetype\n\n     or it contains active geometry.\n\n  \n\n   Returns: true if successful. false if linetypeIndex is out of range or the\n\n     linetype cannot \n\n    be deleted because it is the current linetype or\n\n     because it linetype is referenced \n\n    by active geometry.\n  \"\"\"\n  pass\n def Find(self,*__args):\n  \"\"\"\n  Find(self: LinetypeTable,id: Guid,ignoreDeletedLinetypes: bool) -> int\n\n  \n\n   Finds a linetype with a matching ID.\n\n  \n\n   id: The ID of the line type to be found.\n\n   ignoreDeletedLinetypes: If true,deleted linetypes are not checked.\n\n   Returns: Zero or a positive value if the index of the linetype with the given ID is found.\n\n     \n\n    -1 if no linetype has the given ID.\n\n  \n\n  Find(self: LinetypeTable,name: str,ignoreDeletedLinetypes: bool) -> int\n\n  \n\n   Finds the linetype with a given name.\n\n  \n\n   name: search ignores case.\n\n   ignoreDeletedLinetypes: If true,deleted linetypes are not checked.\n\n   Returns: >=0 index of the linetype with the given name\n\n     -1  no linetype has the given name.\n  \"\"\"\n  pass\n def GetEnumerator(self):\n  \"\"\" GetEnumerator(self: LinetypeTable) -> IEnumerator[Linetype] \"\"\"\n  pass\n def GetUnusedLinetypeName(self,ignoreDeleted):\n  \"\"\"\n  GetUnusedLinetypeName(self: LinetypeTable,ignoreDeleted: bool) -> str\n\n  \n\n   Gets unused linetype name used as default when creating new linetypes.\n\n  \n\n   ignoreDeleted: If this is true then a name used by a deleted linetype is allowed.\n\n   Returns: The unused linetype name.\n  \"\"\"\n  pass\n def LinetypeIndexForObject(self,rhinoObject):\n  \"\"\"\n  LinetypeIndexForObject(self: LinetypeTable,rhinoObject: RhinoObject) -> int\n\n  \n\n   Returns the effective linetype index to be used to find the \n\n     linetype definition to \n\n    draw an object. If an object's linetype\n\n     source is LinetypeFromObject,the linetype \n\n    index in the object's\n\n     attributes is used. If an object's linetype source is \n\n    LinetypeFromLayer\n\n     the linetype index from the object's layer is used.\n\n  \n\n  \n\n   rhinoObject: The Rhino object to use in the query.\n\n   Returns: The effective linetype index.\n  \"\"\"\n  pass\n def Modify(self,linetype,index,quiet):\n  \"\"\"\n  Modify(self: LinetypeTable,linetype: Linetype,index: int,quiet: bool) -> bool\n\n  \n\n   Modify linetype settings.\n\n  \n\n   linetype: New linetype settings. This information is copied.\n\n   index: Zero based index of linetype to set.\n\n   quiet: if true,information message boxes pop up when illegal changes are attempted.\n\n   Returns: true if successful. false if linetype_index is out of range or the\n\n     settings attempt \n\n    to lock or hide the current linetype.\n  \"\"\"\n  pass\n def SetCurrentLinetypeIndex(self,linetypeIndex,quiet):\n  \"\"\"\n  SetCurrentLinetypeIndex(self: LinetypeTable,linetypeIndex: int,quiet: bool) -> bool\n\n  \n\n   At all times,there is a \"current\" linetype. Unless otherwise specified,new objects\n\n       \n\n     are assigned to the current linetype. The current linetype is never deleted.\n\n  \n\n  \n\n   linetypeIndex: Value for new current linetype. 0 <= linetypeIndex < LinetypeTable.Count.\n\n   quiet: if true,then no warning message box pops up if the current linetype request can't be satisfied.\n\n   Returns: true if current linetype index successfully set.\n  \"\"\"\n  pass\n def Undelete(self,index):\n  \"\"\"\n  Undelete(self: LinetypeTable,index: int) -> bool\n\n  \n\n   Restores a linetype that has been deleted.\n\n  \n\n   index: A linetype index to be undeleted.\n\n   Returns: true if successful.\n  \"\"\"\n  pass\n def UndoModify(self,index):\n  \"\"\"\n  UndoModify(self: LinetypeTable,index: int) -> bool\n\n  \n\n   If the linetype has been modified and the modifcation can be undone,\n\n     then \n\n    UndoModify() will restore the linetype to its previous state.\n\n  \n\n  \n\n   index: Zero based index of linetype for which to undo changes.\n\n   Returns: true if this linetype had been modified and the modifications were undone.\n  \"\"\"\n  pass\n def __add__(self,*args):\n  \"\"\" x.__add__(y) <==> x+yx.__add__(y) <==> x+y \"\"\"\n  pass\n def __contains__(self,*args):\n  \"\"\" __contains__[Linetype](enumerable: IEnumerable[Linetype],value: Linetype) -> bool \"\"\"\n  pass\n def __getitem__(self,*args):\n  \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __iter__(self,*args):\n  \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n ActiveCount=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Returns number of linetypes in the linetypes table,excluding deleted linetypes.\n\n\n\nGet: ActiveCount(self: LinetypeTable) -> int\n\n\n\n\"\"\"\n\n ByLayerLinetypeName=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Returns the text name of the bylayer linetype.\n\n\n\nGet: ByLayerLinetypeName(self: LinetypeTable) -> str\n\n\n\n\"\"\"\n\n ContinuousLinetypeName=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Returns the text name of the continuous linetype.\n\n\n\nGet: ContinuousLinetypeName(self: LinetypeTable) -> str\n\n\n\n\"\"\"\n\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Returns number of linetypes in the linetypes table,including deleted linetypes.\n\n\n\nGet: Count(self: LinetypeTable) -> int\n\n\n\n\"\"\"\n\n CurrentLinetype=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Returns reference to the current linetype. Note that this reference may\n\n   become invalid after a call to AddLinetype().\n\n\n\nGet: CurrentLinetype(self: LinetypeTable) -> Linetype\n\n\n\n\"\"\"\n\n CurrentLinetypeIndex=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"At all times,there is a \"current\" linetype.  Unless otherwise specified,\n\n   new objects are assigned to the current linetype. If the current linetype\n\n   source is LinetypeFromLayer the object's layer's linetype is used instead.\n\n\n\nGet: CurrentLinetypeIndex(self: LinetypeTable) -> int\n\n\n\n\"\"\"\n\n CurrentLinetypeSource=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Source used by an object to determine its current linetype to be used by new objects.\n\n\n\nGet: CurrentLinetypeSource(self: LinetypeTable) -> ObjectLinetypeSource\n\n\n\nSet: CurrentLinetypeSource(self: LinetypeTable)=value\n\n\"\"\"\n\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Document that owns this table.\n\n\n\nGet: Document(self: LinetypeTable) -> RhinoDoc\n\n\n\n\"\"\"\n\n LinetypeScale=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"For display in Rhino viewports,the linetypes are scaled by a single scale\n\n   factor for all viewports. This is not used for printing,where all linetype\n\n   patterns are scaled to print in their defined size 1:1 on the paper.\n\n\n\nGet: LinetypeScale(self: LinetypeTable) -> float\n\n\n\nSet: LinetypeScale(self: LinetypeTable)=value\n\n\"\"\"\n\n\n\nclass MaterialTable(object,IEnumerable[Material],IEnumerable,IRhinoTable[Material]):\n # no doc\n def Add(self,material=None,reference=None):\n  \"\"\"\n  Add(self: MaterialTable,material: Material,reference: bool) -> int\n\n  \n\n   Adds a new material to the table based on a given material.\n\n  \n\n   material: A model of the material to be added.\n\n   reference: true if this material is supposed to be a reference material.\n\n     Reference materials \n\n    are not saved in the file.\n\n  \n\n   Returns: The position of the new material in the table.\n\n  Add(self: MaterialTable,material: Material) -> int\n\n  \n\n   Adds a new material to the table based on a given material.\n\n  \n\n   material: A model of the material to be added.\n\n   Returns: The position of the new material in the table.\n\n  Add(self: MaterialTable) -> int\n\n  \n\n   Adds a new material to the table based on the default material.\n\n   Returns: The position of the new material in the table.\n  \"\"\"\n  pass\n def DeleteAt(self,materialIndex):\n  \"\"\"\n  DeleteAt(self: MaterialTable,materialIndex: int) -> bool\n\n  \n\n   Removes a material at a specific position from this material table.\n\n  \n\n   materialIndex: The position to be removed.\n\n   Returns: true if successful. false if materialIndex is out of range or the\n\n     material cannot \n\n    be deleted because it is the current material or because\n\n     it material contains \n\n    active geometry.\n  \"\"\"\n  pass\n def Find(self,*__args):\n  \"\"\"\n  Find(self: MaterialTable,materialId: Guid,ignoreDeletedMaterials: bool) -> int\n\n  \n\n   Finds a material with a matching id.\n\n  \n\n   materialId: A material ID to be found.\n\n   ignoreDeletedMaterials: If true,deleted materials are not checked.\n\n   Returns: >=0 index of the material with the given name\n\n     -1  no material has the given name.\n\n  Find(self: MaterialTable,materialName: str,ignoreDeletedMaterials: bool) -> int\n\n  \n\n   Finds a meterial with a given name.\n\n  \n\n   materialName: Name of the material to search for. The search ignores case.\n\n   ignoreDeletedMaterials: true means don't search deleted materials.\n\n   Returns: >=0 index of the material with the given name\n\n     -1  no material has the given name.\n  \"\"\"\n  pass\n def GetEnumerator(self):\n  \"\"\" GetEnumerator(self: MaterialTable) -> IEnumerator[Material] \"\"\"\n  pass\n def Modify(self,newSettings,materialIndex,quiet):\n  \"\"\"\n  Modify(self: MaterialTable,newSettings: Material,materialIndex: int,quiet: bool) -> bool\n\n  \n\n   Modify material settings.\n\n  \n\n   newSettings: This information is copied.\n\n   materialIndex: zero based index of material to set.  This must be in the range 0 <= layerIndex < \n\n    MaterialTable.Count.\n\n  \n\n   quiet: if true,information message boxes pop up when illegal changes are attempted.\n\n   Returns: true if successful. false if materialIndex is out of range or the settings attempt\n\n     \n\n    to lock or hide the current material.\n  \"\"\"\n  pass\n def ResetMaterial(self,materialIndex):\n  \"\"\" ResetMaterial(self: MaterialTable,materialIndex: int) -> bool \"\"\"\n  pass\n def __add__(self,*args):\n  \"\"\" x.__add__(y) <==> x+yx.__add__(y) <==> x+yx.__add__(y) <==> x+y \"\"\"\n  pass\n def __contains__(self,*args):\n  \"\"\" __contains__[Material](enumerable: IEnumerable[Material],value: Material) -> bool \"\"\"\n  pass\n def __getitem__(self,*args):\n  \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __iter__(self,*args):\n  \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Returns number of materials in the material table,including deleted materials.\n\n\n\nGet: Count(self: MaterialTable) -> int\n\n\n\n\"\"\"\n\n CurrentMaterialIndex=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"At all times,there is a \"current\" material.  Unless otherwise\n\n   specified,new objects are assigned to the current material.\n\n   The current material is never locked,hidden,or deleted.\n\n\n\nGet: CurrentMaterialIndex(self: MaterialTable) -> int\n\n\n\nSet: CurrentMaterialIndex(self: MaterialTable)=value\n\n\"\"\"\n\n CurrentMaterialSource=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets or sets the current material source.\n\n\n\nGet: CurrentMaterialSource(self: MaterialTable) -> ObjectMaterialSource\n\n\n\nSet: CurrentMaterialSource(self: MaterialTable)=value\n\n\"\"\"\n\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Document that owns this table.\n\n\n\nGet: Document(self: MaterialTable) -> RhinoDoc\n\n\n\n\"\"\"\n\n\n\nclass MaterialTableEventArgs(EventArgs):\n # no doc\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: Document(self: MaterialTableEventArgs) -> RhinoDoc\n\n\n\n\"\"\"\n\n EventType=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: EventType(self: MaterialTableEventArgs) -> MaterialTableEventType\n\n\n\n\"\"\"\n\n Index=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: Index(self: MaterialTableEventArgs) -> int\n\n\n\n\"\"\"\n\n OldSettings=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: OldSettings(self: MaterialTableEventArgs) -> Material\n\n\n\n\"\"\"\n\n\n\nclass MaterialTableEventType(Enum,IComparable,IFormattable,IConvertible):\n \"\"\" enum MaterialTableEventType,values: Added (0),Current (5),Deleted (1),Modified (3),Sorted (4),Undeleted (2) \"\"\"\n def __eq__(self,*args):\n  \"\"\" x.__eq__(y) <==> x==yx.__eq__(y) <==> x==yx.__eq__(y) <==> x==y \"\"\"\n  pass\n def __format__(self,*args):\n  \"\"\" __format__(formattable: IFormattable,format: str) -> str \"\"\"\n  pass\n def __ge__(self,*args):\n  pass\n def __gt__(self,*args):\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __le__(self,*args):\n  pass\n def __lt__(self,*args):\n  pass\n def __ne__(self,*args):\n  pass\n def __reduce_ex__(self,*args):\n  pass\n def __str__(self,*args):\n  pass\n Added=None\n Current=None\n Deleted=None\n Modified=None\n Sorted=None\n Undeleted=None\n value__=None\n\n\nclass NamedConstructionPlaneTable(object,IEnumerable[ConstructionPlane],IEnumerable,IRhinoTable[ConstructionPlane]):\n \"\"\"\n Contains all named construction planes in a rhino document.\n\n    This class cannot be inherited.\n \"\"\"\n def Add(self,name,plane):\n  \"\"\"\n  Add(self: NamedConstructionPlaneTable,name: str,plane: Plane) -> int\n\n  \n\n   Adds named construction plane to document.\n\n  \n\n   name: If name is empty,a unique name is automatically created.\n\n     If there is already a \n\n    named onstruction plane with the same name,that \n\n     construction plane is replaced.\n\n  \n\n   plane: The plane value.\n\n   Returns: 0 based index of named construction plane.\n\n     -1 on failure.\n  \"\"\"\n  pass\n def Delete(self,*__args):\n  \"\"\"\n  Delete(self: NamedConstructionPlaneTable,name: str) -> bool\n\n  \n\n   Remove named construction plane from the document.\n\n  \n\n   name: name of the construction plane.\n\n   Returns: true if successful.\n\n  Delete(self: NamedConstructionPlaneTable,index: int) -> bool\n\n  \n\n   Remove named construction plane from the document.\n\n  \n\n   index: zero based array index.\n\n   Returns: true if successful.\n  \"\"\"\n  pass\n def Find(self,name):\n  \"\"\"\n  Find(self: NamedConstructionPlaneTable,name: str) -> int\n\n  \n\n   Finds a named construction plane.\n\n  \n\n   name: Name of construction plane to search for.\n\n   Returns: >=0 index of the construction plane with the given name.\n\n     -1 no construction plane \n\n    found with the given name.\n  \"\"\"\n  pass\n def GetEnumerator(self):\n  \"\"\" GetEnumerator(self: NamedConstructionPlaneTable) -> IEnumerator[ConstructionPlane] \"\"\"\n  pass\n def __add__(self,*args):\n  \"\"\" x.__add__(y) <==> x+y \"\"\"\n  pass\n def __contains__(self,*args):\n  \"\"\" __contains__[ConstructionPlane](enumerable: IEnumerable[ConstructionPlane],value: ConstructionPlane) -> bool \"\"\"\n  pass\n def __getitem__(self,*args):\n  \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __iter__(self,*args):\n  \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Number of construction planes in the table.\n\n\n\nGet: Count(self: NamedConstructionPlaneTable) -> int\n\n\n\n\"\"\"\n\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the document that owns this table.\n\n\n\nGet: Document(self: NamedConstructionPlaneTable) -> RhinoDoc\n\n\n\n\"\"\"\n\n\n\nclass NamedViewTable(object,IEnumerable[ViewInfo],IEnumerable,IRhinoTable[ViewInfo]):\n \"\"\" All named views in a rhino document. \"\"\"\n def Add(self,*__args):\n  \"\"\"\n  Add(self: NamedViewTable,view: ViewInfo) -> int\n\n  Add(self: NamedViewTable,name: str,viewportId: Guid) -> int\n\n  \n\n   Adds named view to document which is based on an existing viewport.\n\n  \n\n   name: If name is empty,a unique name is automatically created.\n\n     If there is already a \n\n    named view with the same name,that view is replaced.\n\n  \n\n   viewportId: Id of an existing viewport in the document. View information is copied from this viewport.\n\n   Returns: 0 based index of named view.\n\n     -1 on failure.\n  \"\"\"\n  pass\n def Delete(self,*__args):\n  \"\"\"\n  Delete(self: NamedViewTable,name: str) -> bool\n\n  \n\n   Remove named view from the document.\n\n  \n\n   name: name of the view.\n\n   Returns: true if successful.\n\n  Delete(self: NamedViewTable,index: int) -> bool\n\n  \n\n   Remove named view from the document.\n\n  \n\n   index: index of the named view in the named view table.\n\n   Returns: true if successful.\n  \"\"\"\n  pass\n def FindByName(self,name):\n  \"\"\"\n  FindByName(self: NamedViewTable,name: str) -> int\n\n  \n\n   Finds a named view.\n\n  \n\n   name: name to search for.\n\n   Returns: >=0 index of the found named view\n\n     -1 no named view found.\n  \"\"\"\n  pass\n def GetEnumerator(self):\n  \"\"\" GetEnumerator(self: NamedViewTable) -> IEnumerator[ViewInfo] \"\"\"\n  pass\n def Restore(self,index,*__args):\n  \"\"\"\n  Restore(self: NamedViewTable,index: int,viewport: RhinoViewport,backgroundBitmap: bool) -> bool\n\n  Restore(self: NamedViewTable,index: int,view: RhinoView,backgroundBitmap: bool) -> bool\n\n  \n\n   Sets the MainViewport of a standard RhinoView to a named views settings\n  \"\"\"\n  pass\n def RestoreAnimated(self,index,*__args):\n  \"\"\"\n  RestoreAnimated(self: NamedViewTable,index: int,viewport: RhinoViewport,backgroundBitmap: bool) -> bool\n\n  RestoreAnimated(self: NamedViewTable,index: int,viewport: RhinoViewport,backgroundBitmap: bool,frames: int,frameRate: int) -> bool\n\n  RestoreAnimated(self: NamedViewTable,index: int,view: RhinoView,backgroundBitmap: bool) -> bool\n\n  RestoreAnimated(self: NamedViewTable,index: int,view: RhinoView,backgroundBitmap: bool,frames: int,frameRate: int) -> bool\n  \"\"\"\n  pass\n def __add__(self,*args):\n  \"\"\" x.__add__(y) <==> x+yx.__add__(y) <==> x+y \"\"\"\n  pass\n def __contains__(self,*args):\n  \"\"\" __contains__[ViewInfo](enumerable: IEnumerable[ViewInfo],value: ViewInfo) -> bool \"\"\"\n  pass\n def __getitem__(self,*args):\n  \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __iter__(self,*args):\n  \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Number of named views in the table.\n\n\n\nGet: Count(self: NamedViewTable) -> int\n\n\n\n\"\"\"\n\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Document that owns this table.\n\n\n\nGet: Document(self: NamedViewTable) -> RhinoDoc\n\n\n\n\"\"\"\n\n\n\nclass ObjectTable(object,IEnumerable[RhinoObject],IEnumerable):\n # no doc\n def Add(self,geometry,attributes=None):\n  \"\"\"\n  Add(self: ObjectTable,geometry: GeometryBase,attributes: ObjectAttributes) -> Guid\n\n  \n\n   Adds geometry that is not further specified.\n\n     This is meant,for example,to handle \n\n    addition of sets of different geometrical entities.\n\n  \n\n  \n\n   geometry: The base geometry. This cannot be null.\n\n   attributes: The object attributes. This can be null.\n\n   Returns: The new object ID on success.\n\n  Add(self: ObjectTable,geometry: GeometryBase) -> Guid\n\n  \n\n   Adds geometry that is not further specified.\n\n     This is meant,for example,to handle \n\n    addition of sets of different geometrical entities.\n\n  \n\n  \n\n   geometry: The base geometry. This cannot be null.\n\n   Returns: The new object ID on success.\n  \"\"\"\n  pass\n def AddAngularDimension(self,dimension,attributes=None,history=None,reference=None):\n  \"\"\"\n  AddAngularDimension(self: ObjectTable,dimension: AngularDimension,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddAngularDimension(self: ObjectTable,dimension: AngularDimension,attributes: ObjectAttributes) -> Guid\n\n  AddAngularDimension(self: ObjectTable,dimension: AngularDimension) -> Guid\n  \"\"\"\n  pass\n def AddArc(self,arc,attributes=None,history=None,reference=None):\n  \"\"\"\n  AddArc(self: ObjectTable,arc: Arc,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddArc(self: ObjectTable,arc: Arc,attributes: ObjectAttributes) -> Guid\n\n  \n\n   Adds a curve object to the document representing an arc.\n\n  \n\n   arc: An arc value.\n\n   attributes: Attributes to apply to arc.\n\n   Returns: A unique identifier for the object.\n\n  AddArc(self: ObjectTable,arc: Arc) -> Guid\n\n  \n\n   Adds a curve object to the document representing an arc.\n\n  \n\n   arc: An arc value.\n\n   Returns: A unique identifier for the object.\n  \"\"\"\n  pass\n def AddBrep(self,brep,attributes=None,history=None,reference=None,splitKinkySurfaces=None):\n  \"\"\"\n  AddBrep(self: ObjectTable,brep: Brep,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddBrep(self: ObjectTable,brep: Brep,attributes: ObjectAttributes,history: HistoryRecord,reference: bool,splitKinkySurfaces: bool) -> Guid\n\n  AddBrep(self: ObjectTable,brep: Brep) -> Guid\n\n  \n\n   Adds a brep object to Rhino.\n\n  \n\n   brep: A duplicate of this brep is added to Rhino.\n\n   Returns: A unique identifier for the object.\n\n  AddBrep(self: ObjectTable,brep: Brep,attributes: ObjectAttributes) -> Guid\n\n  \n\n   Adds a brep object to Rhino.\n\n  \n\n   brep: A duplicate of this brep is added to Rhino.\n\n   attributes: attributes to apply to brep.\n\n   Returns: A unique identifier for the object.\n  \"\"\"\n  pass\n def AddCircle(self,circle,attributes=None,history=None,reference=None):\n  \"\"\"\n  AddCircle(self: ObjectTable,circle: Circle,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddCircle(self: ObjectTable,circle: Circle,attributes: ObjectAttributes) -> Guid\n\n  \n\n   Adds a curve object to the document representing a circle.\n\n  \n\n   circle: A circle value.\n\n   attributes: Attributes to apply to circle.\n\n   Returns: A unique identifier for the object.\n\n  AddCircle(self: ObjectTable,circle: Circle) -> Guid\n\n  \n\n   Adds a curve object to the document representing a circle.\n\n  \n\n   circle: A circle value.\n\n   Returns: A unique identifier for the object.\n  \"\"\"\n  pass\n def AddClippingPlane(self,plane,uMagnitude,vMagnitude,*__args):\n  \"\"\"\n  AddClippingPlane(self: ObjectTable,plane: Plane,uMagnitude: float,vMagnitude: float,clippedViewportId: Guid,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddClippingPlane(self: ObjectTable,plane: Plane,uMagnitude: float,vMagnitude: float,clippedViewportIds: IEnumerable[Guid],attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddClippingPlane(self: ObjectTable,plane: Plane,uMagnitude: float,vMagnitude: float,clippedViewportIds: IEnumerable[Guid],attributes: ObjectAttributes) -> Guid\n\n  AddClippingPlane(self: ObjectTable,plane: Plane,uMagnitude: float,vMagnitude: float,clippedViewportId: Guid) -> Guid\n\n  \n\n   Adds a clipping plane object to Rhino.\n\n  \n\n   plane: The plane value.\n\n   uMagnitude: The size in the U direction.\n\n   vMagnitude: The size in the V direction.\n\n   clippedViewportId: Viewport ID that the new clipping plane will clip.\n\n   Returns: A unique identifier for the object.\n\n  AddClippingPlane(self: ObjectTable,plane: Plane,uMagnitude: float,vMagnitude: float,clippedViewportIds: IEnumerable[Guid]) -> Guid\n  \"\"\"\n  pass\n def AddCurve(self,curve,attributes=None,history=None,reference=None):\n  \"\"\"\n  AddCurve(self: ObjectTable,curve: Curve,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddCurve(self: ObjectTable,curve: Curve,attributes: ObjectAttributes) -> Guid\n\n  \n\n   Adds a curve object to Rhino.\n\n  \n\n   curve: A curve. A duplicate of this curve is added to Rhino.\n\n   attributes: Attributes to apply to curve.\n\n   Returns: A unique identifier for the object.\n\n  AddCurve(self: ObjectTable,curve: Curve) -> Guid\n\n  \n\n   Adds a curve object to Rhino.\n\n  \n\n   curve: A curve. A duplicate of this curve is added to Rhino.\n\n   Returns: A unique identifier for the object.\n  \"\"\"\n  pass\n def AddEllipse(self,ellipse,attributes=None,history=None,reference=None):\n  \"\"\"\n  AddEllipse(self: ObjectTable,ellipse: Ellipse,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddEllipse(self: ObjectTable,ellipse: Ellipse,attributes: ObjectAttributes) -> Guid\n\n  \n\n   Adds a curve object to the document representing an ellipse.\n\n  \n\n   ellipse: An ellipse value.\n\n   attributes: Attributes to apply to ellipse.\n\n   Returns: A unique identifier for the object.\n\n  AddEllipse(self: ObjectTable,ellipse: Ellipse) -> Guid\n\n  \n\n   Adds a curve object to the document representing an ellipse.\n\n  \n\n   ellipse: An ellipse value.\n\n   Returns: A unique identifier for the object.\n  \"\"\"\n  pass\n def AddExplodedInstancePieces(self,instance,explodeNestedInstances,deleteInstance):\n  \"\"\" AddExplodedInstancePieces(self: ObjectTable,instance: InstanceObject,explodeNestedInstances: bool,deleteInstance: bool) -> Array[Guid] \"\"\"\n  pass\n def AddExtrusion(self,extrusion,attributes=None,history=None,reference=None):\n  \"\"\"\n  AddExtrusion(self: ObjectTable,extrusion: Extrusion,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddExtrusion(self: ObjectTable,extrusion: Extrusion,attributes: ObjectAttributes) -> Guid\n\n  \n\n   Adds an extrusion object to Rhino.\n\n  \n\n   extrusion: A duplicate of this extrusion is added to Rhino.\n\n   attributes: Attributes that will be linked with the extrusion object.\n\n   Returns: A unique identifier for the object.\n\n  AddExtrusion(self: ObjectTable,extrusion: Extrusion) -> Guid\n\n  \n\n   Adds an extrusion object to Rhino.\n\n  \n\n   extrusion: A duplicate of this extrusion is added to Rhino.\n\n   Returns: A unique identifier for the object.\n  \"\"\"\n  pass\n def AddHatch(self,hatch,attributes=None,history=None,reference=None):\n  \"\"\"\n  AddHatch(self: ObjectTable,hatch: Hatch,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddHatch(self: ObjectTable,hatch: Hatch,attributes: ObjectAttributes) -> Guid\n\n  AddHatch(self: ObjectTable,hatch: Hatch) -> Guid\n  \"\"\"\n  pass\n def AddInstanceObject(self,instanceDefinitionIndex,instanceXform,attributes=None):\n  \"\"\"\n  AddInstanceObject(self: ObjectTable,instanceDefinitionIndex: int,instanceXform: Transform,attributes: ObjectAttributes) -> Guid\n\n  AddInstanceObject(self: ObjectTable,instanceDefinitionIndex: int,instanceXform: Transform) -> Guid\n  \"\"\"\n  pass\n def AddLeader(self,*__args):\n  \"\"\"\n  AddLeader(self: ObjectTable,text: str,plane: Plane,points: IEnumerable[Point2d]) -> Guid\n\n  AddLeader(self: ObjectTable,text: str,points: IEnumerable[Point3d]) -> Guid\n\n  AddLeader(self: ObjectTable,points: IEnumerable[Point3d]) -> Guid\n\n  AddLeader(self: ObjectTable,text: str,plane: Plane,points: IEnumerable[Point2d],attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddLeader(self: ObjectTable,plane: Plane,points: IEnumerable[Point2d]) -> Guid\n\n  AddLeader(self: ObjectTable,plane: Plane,points: IEnumerable[Point2d],attributes: ObjectAttributes) -> Guid\n\n  AddLeader(self: ObjectTable,text: str,plane: Plane,points: IEnumerable[Point2d],attributes: ObjectAttributes) -> Guid\n  \"\"\"\n  pass\n def AddLine(self,*__args):\n  \"\"\"\n  AddLine(self: ObjectTable,line: Line) -> Guid\n\n  \n\n   Adds a line object to Rhino.\n\n   Returns: A unique identifier for the object.\n\n  AddLine(self: ObjectTable,line: Line,attributes: ObjectAttributes) -> Guid\n\n  \n\n   Adds a line object to Rhino.\n\n  \n\n   line: The line value.\n\n   attributes: Attributes to apply to line.\n\n   Returns: A unique identifier for the object.\n\n  AddLine(self: ObjectTable,from: Point3d,to: Point3d,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddLine(self: ObjectTable,from: Point3d,to: Point3d) -> Guid\n\n  \n\n   Adds a line object to Rhino.\n\n  \n\n   from: The line origin.\n\n   to: The line end.\n\n   Returns: A unique identifier for the object.\n\n  AddLine(self: ObjectTable,from: Point3d,to: Point3d,attributes: ObjectAttributes) -> Guid\n\n  \n\n   Adds a line object to Rhino.\n\n  \n\n   from: The line origin.\n\n   to: The line end.\n\n   attributes: Attributes to apply to line.\n\n   Returns: A unique identifier for the object.\n  \"\"\"\n  pass\n def AddLinearDimension(self,dimension,attributes=None,history=None,reference=None):\n  \"\"\"\n  AddLinearDimension(self: ObjectTable,dimension: LinearDimension,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddLinearDimension(self: ObjectTable,dimension: LinearDimension,attributes: ObjectAttributes) -> Guid\n\n  AddLinearDimension(self: ObjectTable,dimension: LinearDimension) -> Guid\n  \"\"\"\n  pass\n def AddMesh(self,mesh,attributes=None,history=None,reference=None):\n  \"\"\"\n  AddMesh(self: ObjectTable,mesh: Mesh,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddMesh(self: ObjectTable,mesh: Mesh,attributes: ObjectAttributes) -> Guid\n\n  \n\n   Adds a mesh object to Rhino.\n\n  \n\n   mesh: A duplicate of this mesh is added to Rhino.\n\n   attributes: Attributes that will be linked with the mesh object.\n\n   Returns: A unique identifier for the object.\n\n  AddMesh(self: ObjectTable,mesh: Mesh) -> Guid\n\n  \n\n   Adds a mesh object to Rhino.\n\n  \n\n   mesh: A duplicate of this mesh is added to Rhino.\n\n   Returns: A unique identifier for the object.\n  \"\"\"\n  pass\n def AddMorphControl(self,morphControl,attributes=None):\n  \"\"\"\n  AddMorphControl(self: ObjectTable,morphControl: MorphControl,attributes: ObjectAttributes) -> Guid\n\n  AddMorphControl(self: ObjectTable,morphControl: MorphControl) -> Guid\n  \"\"\"\n  pass\n def AddPictureFrame(self,plane,texturePath,asMesh,width,height,selfIllumination,embedBitmap):\n  \"\"\"\n  AddPictureFrame(self: ObjectTable,plane: Plane,texturePath: str,asMesh: bool,width: float,height: float,selfIllumination: bool,embedBitmap: bool) -> Guid\n\n  \n\n   Creates a PictureFrame object from a plane and a path to an image file,\n\n     Note,a \n\n    PictureFrame object is just a Plane surface or mesh that has a\n\n     material with a \n\n    texture assigned to it that displays in all display\n\n     modes.\n\n  \n\n  \n\n   plane: Plane in which the PictureFrame will be created.  Bottom left corner of\n\n     picture \n\n    will be at plane's origin,width will be in the plane's x axis\n\n     direction,height \n\n    will be in the plane's y axis direction.\n\n  \n\n   texturePath: path to an image file\n\n   asMesh: If true,the function will make a MeshObject rather than a surface\n\n   width: Width of the resulting PictureFrame. If 0.0,the width of the pictureframe\n\n     is the \n\n    width of the image if height is also 0.0 or calculated from the\n\n     height and aspect \n\n    ratio of the image if height is not 0.0.\n\n  \n\n   height: Height of the resulting PictureFrame. If 0.0,the height of the pictureframe\n\n     is the \n\n    height of the image if width is also 0.0 or calculated from the width\n\n     and aspect \n\n    ratio of the image if width is not 0.0.\n\n  \n\n   selfIllumination: If true,the image mapped to the picture frame plane always displays at full\n\n     \n\n    intensity and is not affected by light or shadow.\n\n  \n\n   embedBitmap: If true,the funtion adds the the image to the bitmaptable of the document\n\n     to which \n\n    the PictureFrame will be added\n\n  \n\n   Returns: A unique identifier for the object\n  \"\"\"\n  pass\n def AddPoint(self,*__args):\n  \"\"\"\n  AddPoint(self: ObjectTable,point: Point3d,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  \n\n   Adds a point object to the document\n\n  \n\n   point: location of point\n\n   attributes: attributes to apply to point. null is acceptible\n\n   history: history associated with this point. null is acceptable\n\n   reference: true if the object is from a reference file.  Reference objects do\n\n     not persist in \n\n    archives\n\n  \n\n   Returns: A unique identifier for the object.\n\n  AddPoint(self: ObjectTable,point: Point3f) -> Guid\n\n  \n\n   Adds a point object to the document.\n\n  \n\n   point: location of point.\n\n   Returns: A unique identifier for the object.\n\n  AddPoint(self: ObjectTable,point: Point3f,attributes: ObjectAttributes) -> Guid\n\n  \n\n   Adds a point object to the document.\n\n  \n\n   point: location of point.\n\n   attributes: attributes to apply to point.\n\n   Returns: A unique identifier for the object.\n\n  AddPoint(self: ObjectTable,x: float,y: float,z: float) -> Guid\n\n  \n\n   Adds a point object to the document.\n\n  \n\n   x: X component of point coordinate.\n\n   y: Y component of point coordinate.\n\n   z: Z component of point coordinate.\n\n   Returns: A unique identifier for the object..\n\n  AddPoint(self: ObjectTable,point: Point3d) -> Guid\n\n  \n\n   Adds a point object to the document.\n\n  \n\n   point: location of point.\n\n   Returns: A unique identifier for the object.\n\n  AddPoint(self: ObjectTable,point: Point3d,attributes: ObjectAttributes) -> Guid\n\n  \n\n   Adds a point object to the document.\n\n  \n\n   point: location of point.\n\n   attributes: attributes to apply to point. null is acceptible\n\n   Returns: A unique identifier for the object.\n  \"\"\"\n  pass\n def AddPointCloud(self,*__args):\n  \"\"\"\n  AddPointCloud(self: ObjectTable,points: IEnumerable[Point3d]) -> Guid\n\n  AddPointCloud(self: ObjectTable,points: IEnumerable[Point3d],attributes: ObjectAttributes) -> Guid\n\n  AddPointCloud(self: ObjectTable,points: IEnumerable[Point3d],attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddPointCloud(self: ObjectTable,cloud: PointCloud) -> Guid\n\n  \n\n   Adds a point cloud object to the document.\n\n  \n\n   cloud: PointCloud to add.\n\n   Returns: A unique identifier for the object.\n\n  AddPointCloud(self: ObjectTable,cloud: PointCloud,attributes: ObjectAttributes) -> Guid\n\n  \n\n   Adds a point cloud object to the document.\n\n  \n\n   cloud: PointCloud to add.\n\n   attributes: Attributes to apply to point cloud.\n\n   Returns: A unique identifier for the object.\n\n  AddPointCloud(self: ObjectTable,cloud: PointCloud,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  \n\n   Adds a point cloud object to the document.\n\n  \n\n   cloud: PointCloud to add.\n\n   attributes: Attributes to apply to point cloud. null is acceptable\n\n   history: history associated with this pointcloud. null is acceptable\n\n   reference: true if the object is from a reference file.  Reference objects do\n\n     not persist in \n\n    archives\n\n  \n\n   Returns: A unique identifier for the object.\n  \"\"\"\n  pass\n def AddPoints(self,points,attributes=None):\n  \"\"\"\n  AddPoints(self: ObjectTable,points: IEnumerable[Point3f]) -> RhinoList[Guid]\n\n  AddPoints(self: ObjectTable,points: IEnumerable[Point3f],attributes: ObjectAttributes) -> RhinoList[Guid]\n\n  AddPoints(self: ObjectTable,points: IEnumerable[Point3d]) -> RhinoList[Guid]\n\n  AddPoints(self: ObjectTable,points: IEnumerable[Point3d],attributes: ObjectAttributes) -> RhinoList[Guid]\n  \"\"\"\n  pass\n def AddPolyline(self,points,attributes=None,history=None,reference=None):\n  \"\"\"\n  AddPolyline(self: ObjectTable,points: IEnumerable[Point3d],attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddPolyline(self: ObjectTable,points: IEnumerable[Point3d],attributes: ObjectAttributes) -> Guid\n\n  AddPolyline(self: ObjectTable,points: IEnumerable[Point3d]) -> Guid\n  \"\"\"\n  pass\n def AddRadialDimension(self,dimension,attributes=None,history=None,reference=None):\n  \"\"\"\n  AddRadialDimension(self: ObjectTable,dimension: RadialDimension,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddRadialDimension(self: ObjectTable,dimension: RadialDimension,attributes: ObjectAttributes) -> Guid\n\n  AddRadialDimension(self: ObjectTable,dimension: RadialDimension) -> Guid\n  \"\"\"\n  pass\n def AddRhinoObject(self,*__args):\n  \"\"\" AddRhinoObject(self: ObjectTable,pointObject: CustomPointObject)AddRhinoObject(self: ObjectTable,pointObject: PointObject,point: Point)AddRhinoObject(self: ObjectTable,curveObject: CurveObject,curve: Curve)AddRhinoObject(self: ObjectTable,brepObject: BrepObject,brep: Brep)AddRhinoObject(self: ObjectTable,meshObject: CustomMeshObject)AddRhinoObject(self: ObjectTable,meshObject: MeshObject,mesh: Mesh)AddRhinoObject(self: ObjectTable,brepObject: CustomBrepObject) \"\"\"\n  pass\n def AddSphere(self,sphere,attributes=None,history=None,reference=None):\n  \"\"\"\n  AddSphere(self: ObjectTable,sphere: Sphere,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddSphere(self: ObjectTable,sphere: Sphere,attributes: ObjectAttributes) -> Guid\n\n  AddSphere(self: ObjectTable,sphere: Sphere) -> Guid\n  \"\"\"\n  pass\n def AddSurface(self,surface,attributes=None,history=None,reference=None):\n  \"\"\"\n  AddSurface(self: ObjectTable,surface: Surface,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddSurface(self: ObjectTable,surface: Surface,attributes: ObjectAttributes) -> Guid\n\n  \n\n   Adds a surface object to Rhino.\n\n  \n\n   surface: A duplicate of this surface is added to Rhino.\n\n   attributes: Attributes that will be linked with the surface object.\n\n   Returns: A unique identifier for the object.\n\n  AddSurface(self: ObjectTable,surface: Surface) -> Guid\n\n  \n\n   Adds a surface object to Rhino.\n\n  \n\n   surface: A duplicate of this surface is added to Rhino.\n\n   Returns: A unique identifier for the object.\n  \"\"\"\n  pass\n def AddText(self,*__args):\n  \"\"\"\n  AddText(self: ObjectTable,text: str,plane: Plane,height: float,fontName: str,bold: bool,italic: bool,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddText(self: ObjectTable,text: str,plane: Plane,height: float,fontName: str,bold: bool,italic: bool,attributes: ObjectAttributes) -> Guid\n\n  \n\n   Adds an annotation text object to the document.\n\n  \n\n   text: Text string.\n\n   plane: Plane of text.\n\n   height: Height of text.\n\n   fontName: Name of FontFace.\n\n   bold: Bold flag.\n\n   italic: Italic flag.\n\n   attributes: Attributes that will be linked with the object.\n\n   Returns: The Guid of the newly added object or Guid.Empty on failure.\n\n  AddText(self: ObjectTable,text: TextEntity) -> Guid\n\n  AddText(self: ObjectTable,text: TextEntity,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddText(self: ObjectTable,text: TextEntity,attributes: ObjectAttributes) -> Guid\n\n  AddText(self: ObjectTable,text: str,plane: Plane,height: float,fontName: str,bold: bool,italic: bool,justification: TextJustification,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddText(self: ObjectTable,text3d: Text3d,attributes: ObjectAttributes) -> Guid\n\n  \n\n   Adds an annotation text object to the document.\n\n  \n\n   text3d: The text object to add.\n\n   attributes: Object Attributes.\n\n   Returns: The Guid of the newly added object or Guid.Empty on failure.\n\n  AddText(self: ObjectTable,text3d: Text3d) -> Guid\n\n  \n\n   Adds an annotation text object to the document.\n\n  \n\n   text3d: The text object to add.\n\n   Returns: The Guid of the newly added object or Guid.Empty on failure.\n\n  AddText(self: ObjectTable,text: str,plane: Plane,height: float,fontName: str,bold: bool,italic: bool) -> Guid\n\n  \n\n   Adds an annotation text object to the document.\n\n  \n\n   text: Text string.\n\n   plane: Plane of text.\n\n   height: Height of text.\n\n   fontName: Name of FontFace.\n\n   bold: Bold flag.\n\n   italic: Italic flag.\n\n   Returns: The Guid of the newly added object or Guid.Empty on failure.\n\n  AddText(self: ObjectTable,text: str,plane: Plane,height: float,fontName: str,bold: bool,italic: bool,justification: TextJustification,attributes: ObjectAttributes) -> Guid\n\n  AddText(self: ObjectTable,text: str,plane: Plane,height: float,fontName: str,bold: bool,italic: bool,justification: TextJustification) -> Guid\n  \"\"\"\n  pass\n def AddTextDot(self,*__args):\n  \"\"\"\n  AddTextDot(self: ObjectTable,dot: TextDot,attributes: ObjectAttributes) -> Guid\n\n  \n\n   Adds a text dot object to Rhino.\n\n  \n\n   dot: A text dot that will be copied.\n\n   attributes: Attributes to apply to text dot.\n\n   Returns: A unique identifier for the object.\n\n  AddTextDot(self: ObjectTable,dot: TextDot,attributes: ObjectAttributes,history: HistoryRecord,reference: bool) -> Guid\n\n  AddTextDot(self: ObjectTable,dot: TextDot) -> Guid\n\n  \n\n   Adds a text dot object to Rhino.\n\n  \n\n   dot: A text dot that will be copied.\n\n   Returns: A unique identifier for the object.\n\n  AddTextDot(self: ObjectTable,text: str,location: Point3d) -> Guid\n\n  \n\n   Adds a text dot object to Rhino.\n\n  \n\n   text: A text string.\n\n   location: A point position.\n\n   Returns: A unique identifier for the object.\n\n  AddTextDot(self: ObjectTable,text: str,location: Point3d,attributes: ObjectAttributes) -> Guid\n\n  \n\n   Adds a text dot object to Rhino.\n\n  \n\n   text: A text string.\n\n   location: A point position.\n\n   attributes: Attributes to apply to curve.\n\n   Returns: A unique identifier for the object.\n  \"\"\"\n  pass\n def AllObjectsSince(self,runtimeSerialNumber):\n  \"\"\"\n  AllObjectsSince(self: ObjectTable,runtimeSerialNumber: UInt32) -> Array[RhinoObject]\n\n  \n\n   Gets all the objects that have been added to the document since a given runtime serial number.\n\n  \n\n   runtimeSerialNumber: Runtime serial number of the last object not to include in the list.\n\n   Returns: An array of objects or null if no objects were added since the given runtime serial number.\n  \"\"\"\n  pass\n def Delete(self,*__args):\n  \"\"\"\n  Delete(self: ObjectTable,objectId: Guid,quiet: bool) -> bool\n\n  \n\n   Deletes object from document. The deletion can be undone by calling UndeleteObject().\n\n  \n\n   objectId: Id of the object to delete.\n\n   quiet: If false,a message box will appear when an object cannot be deleted.\n\n   Returns: true on success,false on failure.\n\n  Delete(self: ObjectTable,objectIds: IEnumerable[Guid],quiet: bool) -> int\n\n  Delete(self: ObjectTable,objref: ObjRef,quiet: bool) -> bool\n\n  \n\n   Deletes objref.Object(). The deletion can be undone by calling UndeleteObject().\n\n  \n\n   objref: objref.Object() will be deleted.\n\n   quiet: If false,a message box will appear when an object cannot be deleted.\n\n   Returns: true on success,false on failure.\n\n  Delete(self: ObjectTable,obj: RhinoObject,quiet: bool) -> bool\n\n  \n\n   Deletes object from document. The deletion can be undone by calling UndeleteObject().\n\n  \n\n   obj: The object to delete.\n\n   quiet: If false,a message box will appear when an object cannot be deleted.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def Duplicate(self,*__args):\n  \"\"\"\n  Duplicate(self: ObjectTable,objectId: Guid) -> Guid\n\n  \n\n   Same as TransformObject(objref,ON_Xform.Identity,false)\n\n  \n\n   objectId: An ID to an object in the document that needs to be duplicated.\n\n   Returns: The new object ID.\n\n  Duplicate(self: ObjectTable,obj: RhinoObject) -> Guid\n\n  \n\n   Duplicates the object that is referenced by obj.\n\n     Same as TransformObject(obj,\n\n    Rhino.Geometry.Transform.IdentityTransform.Identityy,false)\n\n  \n\n  \n\n   obj: A Rhino object to duplicate.\n\n   Returns: The new object ID.\n\n  Duplicate(self: ObjectTable,objref: ObjRef) -> Guid\n\n  \n\n   Duplicates the object that is referenced by objref.\n\n     Same as Transform(objref,\n\n    Rhino.Geometry.Transform.IdentityTransform.Identity,false)\n\n  \n\n  \n\n   objref: A Rhino object reference to follow for object duplication.\n\n   Returns: The new object ID.\n  \"\"\"\n  pass\n def Find(self,*__args):\n  \"\"\"\n  Find(self: ObjectTable,runtimeSerialNumber: UInt32) -> RhinoObject\n\n  \n\n   Use the object runtime serial number to find a rhino object in the document. This is the value \n\n    stored on\n\n     RhinoObject.RuntimeObjectSerialNumber. The RhinoObject constructor sets \n\n    the runtime serial number and every\n\n     instance of a RhinoObject class will have a \n\n    unique serial number for the duration of the Rhino application.\n\n     If an object is \n\n    replaced with a new object,then the new object will have a different runtime serial number.\n\n     \n\n       Deleted objects stored in the undo list maintain their runtime serial numbers and this \n\n    funtion will return\n\n     pointers to these objects. Call RhinoObject.IsDeleted if you \n\n    need to determine if the returned object is\n\n     active or deleted.  The runtime serial \n\n    number is not saved in files.\n\n  \n\n  \n\n   runtimeSerialNumber: Runtime serial number to search for.\n\n   Returns: Reference to the rhino object with the objectId or null if no such object could be found.\n\n  Find(self: ObjectTable,objectId: Guid) -> RhinoObject\n\n  \n\n   Uses the object guid to find a rhino object. Deleted objects cannot be found by id.\n\n     \n\n    The guid is the value that is stored on RhinoObject.Id\n\n     In a single document,no two \n\n    active objects have the same guid. If an object is\n\n     replaced with a new object,then \n\n    the guid  persists. For example,if the _Move command\n\n     moves an object,then the \n\n    moved object inherits it's guid from the starting object.\n\n     If the Copy command \n\n    copies an object,then the copy gets a new guid. This guid persists\n\n     through file \n\n    saving/openning operations. This function will not find grip objects.\n\n  \n\n  \n\n   objectId: ID of object to search for.\n\n   Returns: Reference to the rhino object with the objectId or null if no such object could be found.\n  \"\"\"\n  pass\n def FindByCrossingWindowRegion(self,viewport,*__args):\n  \"\"\"\n  FindByCrossingWindowRegion(self: ObjectTable,viewport: RhinoViewport,screen1: Point2d,screen2: Point2d,inside: bool,filter: ObjectType) -> Array[RhinoObject]\n\n  \n\n   Finds objects bounded by a region\n\n  \n\n   viewport: viewport to use for selection\n\n   screen1: first screen corner\n\n   screen2: second screen corner\n\n   inside: should objects returned be the ones inside of this region (or outside)\n\n   filter: filter down list by object type\n\n   Returns: An array of RhinoObjects that are inside of this region\n\n  FindByCrossingWindowRegion(self: ObjectTable,viewport: RhinoViewport,region: IEnumerable[Point3d],inside: bool,filter: ObjectType) -> Array[RhinoObject]\n  \"\"\"\n  pass\n def FindByDrawColor(self,drawColor,includeLights):\n  \"\"\"\n  FindByDrawColor(self: ObjectTable,drawColor: Color,includeLights: bool) -> Array[RhinoObject]\n\n  \n\n   Finds all objects whose draw color matches a given color.\n\n  \n\n   drawColor: The alpha value of this color is ignored.\n\n   includeLights: true if lights should be included.\n\n   Returns: An array of Rhino document objects. This array can be empty.\n  \"\"\"\n  pass\n def FindByFilter(self,filter):\n  \"\"\"\n  FindByFilter(self: ObjectTable,filter: ObjectEnumeratorSettings) -> Array[RhinoObject]\n\n  \n\n   Same as GetObjectList but converts the result to an array.\n\n  \n\n   filter: The object enumerator filter to customize inclusion requirements.\n\n   Returns: A Rhino object array. This array can be emptry but not null.\n  \"\"\"\n  pass\n def FindByGroup(self,groupIndex):\n  \"\"\"\n  FindByGroup(self: ObjectTable,groupIndex: int) -> Array[RhinoObject]\n\n  \n\n   Finds all RhinoObjects that are in a given group.\n\n  \n\n   groupIndex: Index of group to search for.\n\n   Returns: An array of objects that belong to the specified group or null if no objects could be found.\n  \"\"\"\n  pass\n def FindByLayer(self,*__args):\n  \"\"\"\n  FindByLayer(self: ObjectTable,layerName: str) -> Array[RhinoObject]\n\n  \n\n   Finds all RhinoObjects that are in a given layer.\n\n  \n\n   layerName: Name of layer to search.\n\n   Returns: Array of objects that belong to the specified group or null if no objects could be found.\n\n  FindByLayer(self: ObjectTable,layer: Layer) -> Array[RhinoObject]\n\n  \n\n   Finds all RhinoObjects that are in a given layer.\n\n  \n\n   layer: Layer to search.\n\n   Returns: Array of objects that belong to the specified group or null if no objects could be found.\n  \"\"\"\n  pass\n def FindByObjectType(self,typeFilter):\n  \"\"\" FindByObjectType(self: ObjectTable,typeFilter: ObjectType) -> Array[RhinoObject] \"\"\"\n  pass\n def FindByUserString(self,key,value,caseSensitive,searchGeometry=None,searchAttributes=None,filter=None):\n  \"\"\"\n  FindByUserString(self: ObjectTable,key: str,value: str,caseSensitive: bool,searchGeometry: bool,searchAttributes: bool,filter: ObjectEnumeratorSettings) -> Array[RhinoObject]\n\n  \n\n   Finds all objects whose UserString matches the search patterns.\n\n  \n\n   key: Search pattern for UserString keys (supported wildcards are: ?=any single character,*=any \n\n    sequence of characters).\n\n  \n\n   value: Search pattern for UserString values (supported wildcards are: ?=any single character,*=any \n\n    sequence of characters).\n\n  \n\n   caseSensitive: If true,string comparison will be case sensitive.\n\n   searchGeometry: If true,UserStrings attached to the geometry of an object will be searched.\n\n   searchAttributes: If true,UserStrings attached to the attributes of an object will be searched.\n\n   filter: Filter used to restrict the number of objects searched.\n\n   Returns: An array of all objects whose UserString matches with the search patterns or null when no such \n\n    objects could be found.\n\n  \n\n  FindByUserString(self: ObjectTable,key: str,value: str,caseSensitive: bool,searchGeometry: bool,searchAttributes: bool,filter: ObjectType) -> Array[RhinoObject]\n\n  \n\n   Finds all objects whose UserString matches the search patterns.\n\n  \n\n   key: Search pattern for UserString keys (supported wildcards are: ?=any single character,*=any \n\n    sequence of characters).\n\n  \n\n   value: Search pattern for UserString values (supported wildcards are: ?=any single character,*=any \n\n    sequence of characters).\n\n  \n\n   caseSensitive: If true,string comparison will be case sensitive.\n\n   searchGeometry: If true,UserStrings attached to the geometry of an object will be searched.\n\n   searchAttributes: If true,UserStrings attached to the attributes of an object will be searched.\n\n   filter: Object type filter.\n\n   Returns: An array of all objects whose UserString matches with the search patterns or null when no such \n\n    objects could be found.\n\n  \n\n  FindByUserString(self: ObjectTable,key: str,value: str,caseSensitive: bool) -> Array[RhinoObject]\n\n  \n\n   Finds all objects whose UserString matches the search patterns.\n\n  \n\n   key: Search pattern for UserString keys (supported wildcards are: ?=any single character,*=any \n\n    sequence of characters).\n\n  \n\n   value: Search pattern for UserString values (supported wildcards are: ?=any single character,*=any \n\n    sequence of characters).\n\n  \n\n   caseSensitive: If true,string comparison will be case sensitive.\n\n   Returns: An array of all objects whose UserString matches with the search patterns or null when no such \n\n    objects could be found.\n  \"\"\"\n  pass\n def FindByWindowRegion(self,viewport,*__args):\n  \"\"\"\n  FindByWindowRegion(self: ObjectTable,viewport: RhinoViewport,screen1: Point2d,screen2: Point2d,inside: bool,filter: ObjectType) -> Array[RhinoObject]\n\n  \n\n   Finds objects bounded by a polyline region\n\n  \n\n   viewport: viewport to use for selection\n\n   screen1: first screen corner\n\n   screen2: second screen corner\n\n   inside: should objects returned be the ones inside of this region (or outside)\n\n   filter: filter down list by object type\n\n   Returns: An array of RhinoObjects that are inside of this region\n\n  FindByWindowRegion(self: ObjectTable,viewport: RhinoViewport,region: IEnumerable[Point3d],inside: bool,filter: ObjectType) -> Array[RhinoObject]\n  \"\"\"\n  pass\n def FindClippingPlanesForViewport(self,viewport):\n  \"\"\"\n  FindClippingPlanesForViewport(self: ObjectTable,viewport: RhinoViewport) -> Array[ClippingPlaneObject]\n\n  \n\n   Finds all of the clipping plane objects that actively clip a viewport.\n\n  \n\n   viewport: The viewport in which clipping planes are searched.\n\n   Returns: An array of clipping plane objects. The array can be emptry but not null.\n  \"\"\"\n  pass\n def GetEnumerator(self):\n  \"\"\" GetEnumerator(self: ObjectTable) -> IEnumerator[RhinoObject] \"\"\"\n  pass\n def GetObjectList(self,*__args):\n  \"\"\"\n  GetObjectList(self: ObjectTable,typeFilter: ObjectType) -> IEnumerable[RhinoObject]\n\n  GetObjectList(self: ObjectTable,typeFilter: Type) -> IEnumerable[RhinoObject]\n\n  GetObjectList(self: ObjectTable,settings: ObjectEnumeratorSettings) -> IEnumerable[RhinoObject]\n  \"\"\"\n  pass\n def GetSelectedObjects(self,includeLights,includeGrips):\n  \"\"\" GetSelectedObjects(self: ObjectTable,includeLights: bool,includeGrips: bool) -> IEnumerable[RhinoObject] \"\"\"\n  pass\n def GripUpdate(self,obj,deleteOriginal):\n  \"\"\"\n  GripUpdate(self: ObjectTable,obj: RhinoObject,deleteOriginal: bool) -> RhinoObject\n\n  \n\n   Altered grip positions on a RhinoObject are used to calculate an updated object\n\n     \n\n    that is added to the document.\n\n  \n\n  \n\n   obj: object with modified grips to update.\n\n   deleteOriginal: if true,obj is deleted from the document.\n\n   Returns: new RhinoObject on success; otherwise null.\n  \"\"\"\n  pass\n def Hide(self,*__args):\n  \"\"\"\n  Hide(self: ObjectTable,objectId: Guid,ignoreLayerMode: bool) -> bool\n\n  \n\n   If Object().IsNormal() is true,then the object will be hidden.\n\n  \n\n   objectId: Id of object to hide.\n\n   ignoreLayerMode: if true,the object will be hidden even if it is on a layer that is locked or off.\n\n   Returns: true if the object was successfully hidden.\n\n  Hide(self: ObjectTable,obj: RhinoObject,ignoreLayerMode: bool) -> bool\n\n  \n\n   If obj.IsNormal() is true,then the object will be hidden.\n\n  \n\n   obj: object to hide.\n\n   ignoreLayerMode: if true,the object will be hidden even if it is on a layer that is locked or off.\n\n   Returns: true if the object was successfully hidden.\n\n  Hide(self: ObjectTable,objref: ObjRef,ignoreLayerMode: bool) -> bool\n\n  \n\n   If objref.Object().IsNormal() is true,then the object will be hidden.\n\n  \n\n   objref: reference to object to hide.\n\n   ignoreLayerMode: if true,the object will be hidden even if it is on a layer that is locked or off.\n\n   Returns: true if the object was successfully hidden.\n  \"\"\"\n  pass\n def Lock(self,*__args):\n  \"\"\"\n  Lock(self: ObjectTable,objectId: Guid,ignoreLayerMode: bool) -> bool\n\n  \n\n   If objref.Object().IsNormal() is true,then the object will be locked.\n\n  \n\n   objectId: Id of normal object to lock.\n\n   ignoreLayerMode: if true,the object will be locked even if it is on a layer that is locked or off.\n\n   Returns: true if the object was successfully locked.\n\n  Lock(self: ObjectTable,obj: RhinoObject,ignoreLayerMode: bool) -> bool\n\n  \n\n   If obj.IsNormal() is true,then the object will be locked.\n\n  \n\n   obj: normal object to lock.\n\n   ignoreLayerMode: if true,the object will be locked even if it is on a layer that is locked or off.\n\n   Returns: true if the object was successfully locked.\n\n  Lock(self: ObjectTable,objref: ObjRef,ignoreLayerMode: bool) -> bool\n\n  \n\n   If objref.Object().IsNormal() is true,then the object will be locked.\n\n  \n\n   objref: reference to normal object to lock.\n\n   ignoreLayerMode: if true,the object will be locked even if it is on a layer that is locked or off.\n\n   Returns: true if the object was successfully locked.\n  \"\"\"\n  pass\n def ModifyAttributes(self,*__args):\n  \"\"\"\n  ModifyAttributes(self: ObjectTable,objectId: Guid,newAttributes: ObjectAttributes,quiet: bool) -> bool\n\n  \n\n   Modifies an object's attributes.  Cannot be used to change object id.\n\n  \n\n   objectId: Id of object to modify.\n\n   newAttributes: new attributes.\n\n   quiet: if true,then warning message boxes are disabled.\n\n   Returns: true if successful.\n\n  ModifyAttributes(self: ObjectTable,obj: RhinoObject,newAttributes: ObjectAttributes,quiet: bool) -> bool\n\n  \n\n   Modifies an object's attributes.  Cannot be used to change object id.\n\n  \n\n   obj: object to modify.\n\n   newAttributes: new attributes.\n\n   quiet: if true,then warning message boxes are disabled.\n\n   Returns: true if successful.\n\n  ModifyAttributes(self: ObjectTable,objref: ObjRef,newAttributes: ObjectAttributes,quiet: bool) -> bool\n\n  \n\n   Modifies an object's attributes.  Cannot be used to change object id.\n\n  \n\n   objref: reference to object to modify.\n\n   newAttributes: new attributes.\n\n   quiet: if true,then warning message boxes are disabled.\n\n   Returns: true if successful.\n  \"\"\"\n  pass\n def ModifyRenderMaterial(self,*__args):\n  \"\"\"\n  ModifyRenderMaterial(self: ObjectTable,objectId: Guid,material: RenderMaterial) -> bool\n\n  \n\n   Modifies an object's render material assignment,this will set the\n\n     objects material \n\n    source to ObjectMaterialSource.MaterialFromObject.\n\n  \n\n  \n\n   objectId: Id of object to modify.\n\n   material: Material to assign to this object.\n\n   Returns: Returns true on success otherwise returns false.\n\n  ModifyRenderMaterial(self: ObjectTable,objRef: ObjRef,material: RenderMaterial) -> bool\n\n  \n\n   Modifies an object's render material assignment,this will set the\n\n     objects material \n\n    source to ObjectMaterialSource.MaterialFromObject.\n\n  \n\n  \n\n   objRef: Object to modify.\n\n   material: Material to assign to this object.\n\n   Returns: Returns true on success otherwise returns false.\n\n  ModifyRenderMaterial(self: ObjectTable,obj: RhinoObject,material: RenderMaterial) -> bool\n\n  \n\n   Modifies an object's render material assignment,this will set the\n\n     objects material \n\n    source to ObjectMaterialSource.MaterialFromObject.\n\n  \n\n  \n\n   obj: Object to modify.\n\n   material: Material to assign to this object.\n\n   Returns: Returns true on success otherwise returns false.\n  \"\"\"\n  pass\n def ModifyTextureMapping(self,*__args):\n  \"\"\"\n  ModifyTextureMapping(self: ObjectTable,obj: RhinoObject,channel: int,mapping: TextureMapping) -> bool\n\n  ModifyTextureMapping(self: ObjectTable,objId: Guid,channel: int,mapping: TextureMapping) -> bool\n\n  ModifyTextureMapping(self: ObjectTable,objRef: ObjRef,channel: int,mapping: TextureMapping) -> bool\n  \"\"\"\n  pass\n def MostRecentObject(self):\n  \"\"\"\n  MostRecentObject(self: ObjectTable) -> RhinoObject\n\n  \n\n   Gets the most recently added object that is still in the Document.\n\n   Returns: The most recent (non-deleted) object in the document,or null if no such object exists.\n  \"\"\"\n  pass\n def ObjectCount(self,filter):\n  \"\"\" ObjectCount(self: ObjectTable,filter: ObjectEnumeratorSettings) -> int \"\"\"\n  pass\n def Purge(self,*__args):\n  \"\"\"\n  Purge(self: ObjectTable,rhinoObject: RhinoObject) -> bool\n\n  \n\n   Removes object from document and deletes the pointer. Typically you will\n\n     want to \n\n    call Delete instead in order to keep the object on the undo list.\n\n  \n\n  \n\n   rhinoObject: A Rhino object that will be deleted.\n\n   Returns: true if the object was purged; otherwise false.\n\n  Purge(self: ObjectTable,runtimeSerialNumber: UInt32) -> bool\n\n  \n\n   Removes object from document and deletes the pointer. Typically you will\n\n     want to \n\n    call Delete instead in order to keep the object on the undo list.\n\n  \n\n  \n\n   runtimeSerialNumber: A runtime serial number of the object that will be deleted.\n\n   Returns: true if the object was purged; otherwise false.\n  \"\"\"\n  pass\n def Replace(self,*__args):\n  \"\"\"\n  Replace(self: ObjectTable,objref: ObjRef,pointcloud: PointCloud) -> bool\n\n  \n\n   Replaces one object with new pointcloud object.\n\n  \n\n   objref: reference to old object to be replaced. The objref.Object() will be deleted.\n\n   pointcloud: new pointcloud to be added\n\n     A duplicate of the pointcloud is added to the Rhino \n\n    model.\n\n  \n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objectId: Guid,pointcloud: PointCloud) -> bool\n\n  \n\n   Replaces one object with new pointcloud object.\n\n  \n\n   objectId: Id of object to be replaced.\n\n   pointcloud: new pointcloud to be added\n\n     A duplicate of the pointcloud is added to the Rhino \n\n    model.\n\n  \n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objref: ObjRef,newObject: RhinoObject) -> bool\n\n  \n\n   Replaces one object with another. Conceptually,this function is the same as calling\n\n       \n\n     Setting new_object attributes=old_object attributes\n\n     DeleteObject(old_object);\n\n    \n\n        AddObject(old_object);\n\n  \n\n  \n\n   objref: reference to old object to be replaced. The objref.Object() will be deleted.\n\n   newObject: new replacement object - must not be in document.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objectId: Guid,mesh: Mesh) -> bool\n\n  \n\n   Replaces one object with new mesh object.\n\n  \n\n   objectId: Id of object to be replaced.\n\n   mesh: new mesh to be added\n\n     A duplicate of the mesh is added to the Rhino model.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objref: ObjRef,text: TextEntity) -> bool\n\n  \n\n   Replaces one object with new text object.\n\n  \n\n   objref: reference to old object to be replaced. The objref.Object() will be deleted.\n\n   text: new text to be added\n\n     A duplicate of the text is added to the Rhino model.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objectId: Guid,text: TextEntity) -> bool\n\n  \n\n   Replaces one object with new text object.\n\n  \n\n   objectId: Id of object to be replaced.\n\n   text: new text to be added\n\n     A duplicate of the text is added to the Rhino model.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objectId: Guid,dot: TextDot) -> bool\n\n  \n\n   Replaces one object with new textdot object.\n\n  \n\n   objectId: Id of object to be replaced.\n\n   dot: new textdot to be added.  The textdot is copied.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objref: ObjRef,line: Line) -> bool\n\n  \n\n   Replaces one object with new line curve object.\n\n  \n\n   objref: Reference to old object to be replaced. The object objref.Object() will be deleted.\n\n   line: new line to be added.  The line is copied.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objectId: Guid,line: Line) -> bool\n\n  \n\n   Replaces one object with new line curve object.\n\n  \n\n   objectId: Id of object to be replaced.\n\n   line: new line to be added.  The line is copied.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objref: ObjRef,point: Point3d) -> bool\n\n  \n\n   Replaces one object with new point object.\n\n  \n\n   objref: Reference to old object to be replaced. The object objref.Object() will be deleted.\n\n   point: new point to be added.  The point is copied.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objectId: Guid,point: Point3d) -> bool\n\n  \n\n   Replaces one object with new point object.\n\n  \n\n   objectId: Id of object to be replaced.\n\n   point: new point to be added.  The point is copied.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objref: ObjRef,dot: TextDot) -> bool\n\n  \n\n   Replaces one object with new textdot object.\n\n  \n\n   objref: Reference to old object to be replaced. The object objref.Object() will be deleted.\n\n   dot: new textdot to be added.  The textdot is copied.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objref: ObjRef,mesh: Mesh) -> bool\n\n  \n\n   Replaces one object with new mesh object.\n\n  \n\n   objref: reference to old object to be replaced. The objref.Object() will be deleted.\n\n   mesh: new mesh to be added\n\n     A duplicate of the mesh is added to the Rhino model.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objectId: Guid,arc: Arc) -> bool\n\n  \n\n   Replaces one object with new curve object.\n\n  \n\n   objectId: Id of object to be replaced.\n\n   arc: new arc to be added.  The arc is copied.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objref: ObjRef,polyline: Polyline) -> bool\n\n  \n\n   Replaces one object with new curve object.\n\n  \n\n   objref: Reference to old object to be replaced. The object objref.Object() will be deleted.\n\n   polyline: new polyline to be added.  The polyline is copied.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objectId: Guid,polyline: Polyline) -> bool\n\n  \n\n   Replaces one object with new curve object.\n\n  \n\n   objectId: Id of object to be replaced.\n\n   polyline: new polyline to be added.  The polyline is copied.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objref: ObjRef,circle: Circle) -> bool\n\n  \n\n   Replaces one object with new curve object.\n\n  \n\n   objref: Reference to old object to be replaced. The object objref.Object() will be deleted.\n\n   circle: new circle to be added.  The circle is copied.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objectId: Guid,circle: Circle) -> bool\n\n  \n\n   Replaces one object with new curve object.\n\n  \n\n   objectId: Id of object to be replaced.\n\n   circle: new circle to be added.  The circle is copied.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objref: ObjRef,arc: Arc) -> bool\n\n  \n\n   Replaces one object with new curve object.\n\n  \n\n   objref: Reference to old object to be replaced. The object objref.Object() will be deleted.\n\n   arc: new arc to be added.  The arc is copied.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objectId: Guid,surface: Surface) -> bool\n\n  \n\n   Replaces one object with new surface object.\n\n  \n\n   objectId: Id of object to be replaced.\n\n   surface: new surface to be added\n\n     A duplicate of the surface is added to the Rhino model.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objref: ObjRef,brep: Brep) -> bool\n\n  \n\n   Replaces one object with new brep object.\n\n  \n\n   objref: reference to old object to be replaced. The objref.Object() will be deleted.\n\n   brep: new brep to be added\n\n     A duplicate of the brep is added to the Rhino model.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objectId: Guid,brep: Brep) -> bool\n\n  \n\n   Replaces one object with new brep object.\n\n  \n\n   objectId: Id of object to be replaced.\n\n   brep: new surface to be added\n\n     A duplicate of the brep is added to the Rhino model.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objref: ObjRef,curve: Curve) -> bool\n\n  \n\n   Replaces one object with new curve object.\n\n  \n\n   objref: reference to old object to be replaced. The objref.Object() will be deleted.\n\n   curve: New curve to be added. A duplicate of the curve is added to the Rhino model.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objectId: Guid,curve: Curve) -> bool\n\n  \n\n   Replaces one object with new curve object.\n\n  \n\n   objectId: Id of object to be replaced.\n\n   curve: New curve to be added. A duplicate of the curve is added to the Rhino model.\n\n   Returns: true if successful.\n\n  Replace(self: ObjectTable,objref: ObjRef,surface: Surface) -> bool\n\n  \n\n   Replaces one object with new surface object.\n\n  \n\n   objref: reference to old object to be replaced. The objref.Object() will be deleted.\n\n   surface: new surface to be added\n\n     A duplicate of the surface is added to the Rhino model.\n\n   Returns: true if successful.\n  \"\"\"\n  pass\n def Select(self,*__args):\n  \"\"\"\n  Select(self: ObjectTable,objectId: Guid,select: bool,syncHighlight: bool) -> bool\n\n  \n\n   Select or deselects a single object.\n\n  \n\n   objectId: Id of object to select.\n\n   select: If true,the object will be selected,if false,it will be deselected.\n\n   syncHighlight: If true,then the object is highlighted if it is selected \n\n     and unhighlighted if is \n\n    is not selected.\n\n  \n\n   Returns: true on success,false on failure.\n\n  Select(self: ObjectTable,objectId: Guid,select: bool) -> bool\n\n  \n\n   Select or deselects a single object.\n\n  \n\n   objectId: Id of object to select.\n\n   select: If true,the object will be selected,if false,it will be deselected.\n\n   Returns: true on success,false on failure.\n\n  Select(self: ObjectTable,objectId: Guid) -> bool\n\n  \n\n   Select a single object.\n\n  \n\n   objectId: Id of object to select.\n\n   Returns: true on success,false on failure.\n\n  Select(self: ObjectTable,objectId: Guid,select: bool,syncHighlight: bool,persistentSelect: bool) -> bool\n\n  \n\n   Select or deselects a single object.\n\n  \n\n   objectId: Id of object to select.\n\n   select: If true,the object will be selected,if false,it will be deselected.\n\n   syncHighlight: If true,then the object is highlighted if it is selected \n\n     and unhighlighted if is \n\n    is not selected.\n\n  \n\n   persistentSelect: Objects that are persistently selected stay selected when a command terminates.\n\n   Returns: true on success,false on failure.\n\n  Select(self: ObjectTable,objectIds: IEnumerable[Guid],select: bool) -> int\n\n  Select(self: ObjectTable,objectIds: IEnumerable[Guid]) -> int\n\n  Select(self: ObjectTable,objectId: Guid,select: bool,syncHighlight: bool,persistentSelect: bool,ignoreGripsState: bool,ignoreLayerLocking: bool,ignoreLayerVisibility: bool) -> bool\n\n  \n\n   Select or deselects a single object.\n\n  \n\n   objectId: Id of object to select.\n\n   select: If true,the object will be selected,if false,it will be deselected.\n\n   syncHighlight: If true,then the object is highlighted if it is selected \n\n     and unhighlighted if is \n\n    is not selected.\n\n  \n\n   persistentSelect: Objects that are persistently selected stay selected when a command terminates.\n\n   ignoreGripsState: If true,then objects with grips on can be selected.\n\n     If false,then the value \n\n    returned by the object's IsSelectableWithGripsOn() function\n\n     decides if the object \n\n    can be selected when it has grips turned on.\n\n  \n\n   ignoreLayerLocking: If true,then objects on locked layers can be selected.\n\n   ignoreLayerVisibility: If true,then objects on hidden layers can be selectable.\n\n   Returns: true on success,false on failure.\n\n  Select(self: ObjectTable,objref: ObjRef,select: bool,syncHighlight: bool) -> bool\n\n  \n\n   Select or deselects a single object.\n\n  \n\n   objref: Object represented by this ObjRef is selected.\n\n   select: If true,the object will be selected,if false,it will be deselected.\n\n   syncHighlight: If true,then the object is highlighted if it is selected \n\n     and unhighlighted if is \n\n    is not selected.\n\n  \n\n   Returns: true on success,false on failure.\n\n  Select(self: ObjectTable,objref: ObjRef,select: bool) -> bool\n\n  \n\n   Select or deselects a single object.\n\n  \n\n   objref: Object represented by this ObjRef is selected.\n\n   select: If true,the object will be selected,if false,it will be deselected.\n\n   Returns: true on success,false on failure.\n\n  Select(self: ObjectTable,objref: ObjRef) -> bool\n\n  \n\n   Select a single object.\n\n  \n\n   objref: Object represented by this ObjRef is selected.\n\n   Returns: true on success,false on failure.\n\n  Select(self: ObjectTable,objref: ObjRef,select: bool,syncHighlight: bool,persistentSelect: bool) -> bool\n\n  \n\n   Select or deselects a single object.\n\n  \n\n   objref: Object represented by this ObjRef is selected.\n\n   select: If true,the object will be selected,if false,it will be deselected.\n\n   syncHighlight: If true,then the object is highlighted if it is selected \n\n     and unhighlighted if is \n\n    is not selected.\n\n  \n\n   persistentSelect: Objects that are persistently selected stay selected when a command terminates.\n\n   Returns: true on success,false on failure.\n\n  Select(self: ObjectTable,objRefs: IEnumerable[ObjRef],select: bool) -> int\n\n  Select(self: ObjectTable,objRefs: IEnumerable[ObjRef]) -> int\n\n  Select(self: ObjectTable,objref: ObjRef,select: bool,syncHighlight: bool,persistentSelect: bool,ignoreGripsState: bool,ignoreLayerLocking: bool,ignoreLayerVisibility: bool) -> bool\n\n  \n\n   Select or deselects a single object.\n\n  \n\n   objref: Object represented by this ObjRef is selected.\n\n   select: If true,the object will be selected,if false,it will be deselected.\n\n   syncHighlight: If true,then the object is highlighted if it is selected \n\n     and unhighlighted if is \n\n    is not selected.\n\n  \n\n   persistentSelect: Objects that are persistently selected stay selected when a command terminates.\n\n   ignoreGripsState: If true,then objects with grips on can be selected.\n\n     If false,then the value \n\n    returned by the object's IsSelectableWithGripsOn() function\n\n     decides if the object \n\n    can be selected when it has grips turned on.\n\n  \n\n   ignoreLayerLocking: If true,then objects on locked layers can be selected.\n\n   ignoreLayerVisibility: If true,then objects on hidden layers can be selectable.\n\n   Returns: true on success,false on failure.\n  \"\"\"\n  pass\n def Show(self,*__args):\n  \"\"\"\n  Show(self: ObjectTable,objectId: Guid,ignoreLayerMode: bool) -> bool\n\n  \n\n   If Object().IsHidden() is true,then the object will be returned to normal (visible and \n\n    selectable) mode.\n\n  \n\n  \n\n   objectId: Id of the normal object to show.\n\n   ignoreLayerMode: if true,the object will be shown even if it is on a layer that is locked or off.\n\n   Returns: true if the object was successfully shown.\n\n  Show(self: ObjectTable,obj: RhinoObject,ignoreLayerMode: bool) -> bool\n\n  \n\n   If obj.IsHidden() is true,then the object will be returned to normal (visible and selectable) \n\n    mode.\n\n  \n\n  \n\n   obj: the normal object to show.\n\n   ignoreLayerMode: if true,the object will be shown even if it is on a layer that is locked or off.\n\n   Returns: true if the object was successfully shown.\n\n  Show(self: ObjectTable,objref: ObjRef,ignoreLayerMode: bool) -> bool\n\n  \n\n   If objref.Object().IsHidden() is true,then the object will be returned to normal (visible and \n\n    selectable) mode.\n\n  \n\n  \n\n   objref: reference to normal object to show.\n\n   ignoreLayerMode: if true,the object will be shown even if it is on a layer that is locked or off.\n\n   Returns: true if the object was successfully shown.\n  \"\"\"\n  pass\n def Transform(self,*__args):\n  \"\"\"\n  Transform(self: ObjectTable,objectId: Guid,xform: Transform,deleteOriginal: bool) -> Guid\n\n  \n\n   Constructs a new object that is the transformation of the existing object\n\n     and \n\n    deletes the existing object if deleteOriginal is true.\n\n  \n\n  \n\n   objectId: Id of rhino object to transform. This object will be deleted if deleteOriginal is true.\n\n   xform: transformation to apply.\n\n   deleteOriginal: if true,the original object is deleted\n\n     if false,the original object is not \n\n    deleted.\n\n  \n\n   Returns: Id of the new object that is the transformation of the existing_object.\n\n     The new \n\n    object has identical attributes.\n\n  \n\n  Transform(self: ObjectTable,obj: RhinoObject,xform: Transform,deleteOriginal: bool) -> Guid\n\n  \n\n   Constructs a new object that is the transformation of the existing object\n\n     and \n\n    deletes the existing object if deleteOriginal is true.\n\n  \n\n  \n\n   obj: Rhino object to transform. This object will be deleted if deleteOriginal is true.\n\n   xform: transformation to apply.\n\n   deleteOriginal: if true,the original object is deleted\n\n     if false,the original object is not \n\n    deleted.\n\n  \n\n   Returns: Id of the new object that is the transformation of the existing_object.\n\n     The new \n\n    object has identical attributes.\n\n  \n\n  Transform(self: ObjectTable,objref: ObjRef,xform: Transform,deleteOriginal: bool) -> Guid\n\n  \n\n   Constructs a new object that is the transformation of the existing object\n\n     and \n\n    deletes the existing object if deleteOriginal is true.\n\n  \n\n  \n\n   objref: reference to object to transform. The objref.Object() will be deleted if deleteOriginal is true.\n\n   xform: transformation to apply.\n\n   deleteOriginal: if true,the original object is deleted\n\n     if false,the original object is not \n\n    deleted.\n\n  \n\n   Returns: Id of the new object that is the transformation of the existing_object.\n\n     The new \n\n    object has identical attributes.\n  \"\"\"\n  pass\n def TransformWithHistory(self,*__args):\n  \"\"\"\n  TransformWithHistory(self: ObjectTable,objectId: Guid,xform: Transform) -> Guid\n\n  \n\n   Constructs a new object that is the transformation of the existing object\n\n     and \n\n    records history of the transformation if history recording is turned on.\n\n     If history \n\n    recording is not enabled,this function will act the same as\n\n     Transform(objectId,\n\n    xform,false)\n\n  \n\n  \n\n   objectId: Id of rhino object to transform.\n\n   xform: transformation to apply.\n\n   Returns: Id of the new object that is the transformation of the existing_object.\n\n     The new \n\n    object has identical attributes.\n\n  \n\n  TransformWithHistory(self: ObjectTable,obj: RhinoObject,xform: Transform) -> Guid\n\n  \n\n   Constructs a new object that is the transformation of the existing object\n\n     and \n\n    records history of the transformation if history recording is turned on.\n\n     If history \n\n    recording is not enabled,this function will act the same as\n\n     Transform(obj,xform,\n\n    false)\n\n  \n\n  \n\n   obj: Rhino object to transform.\n\n   xform: transformation to apply.\n\n   Returns: Id of the new object that is the transformation of the existing_object.\n\n     The new \n\n    object has identical attributes.\n\n  \n\n  TransformWithHistory(self: ObjectTable,objref: ObjRef,xform: Transform) -> Guid\n\n  \n\n   Constructs a new object that is the transformation of the existing object\n\n     and \n\n    records history of the transformation if history recording is turned on.\n\n     If history \n\n    recording is not enabled,this function will act the same as\n\n     Transform(objref,\n\n    xform,false)\n\n  \n\n  \n\n   objref: reference to object to transform.\n\n   xform: transformation to apply.\n\n   Returns: Id of the new object that is the transformation of the existing_object.\n\n     The new \n\n    object has identical attributes.\n  \"\"\"\n  pass\n def Undelete(self,*__args):\n  \"\"\"\n  Undelete(self: ObjectTable,rhinoObject: RhinoObject) -> bool\n\n  Undelete(self: ObjectTable,runtimeSerialNumber: UInt32) -> bool\n  \"\"\"\n  pass\n def Unlock(self,*__args):\n  \"\"\"\n  Unlock(self: ObjectTable,objectId: Guid,ignoreLayerMode: bool) -> bool\n\n  \n\n   If Object().IsLocked() is true,then the object will be returned to normal (visible and \n\n    selectable) mode.\n\n  \n\n  \n\n   objectId: Id of locked object to unlock.\n\n   ignoreLayerMode: if true,the object will be unlocked even if it is on a layer that is locked or off.\n\n   Returns: true if the object was successfully unlocked.\n\n  Unlock(self: ObjectTable,obj: RhinoObject,ignoreLayerMode: bool) -> bool\n\n  \n\n   If obj.IsLocked() is true,then the object will be returned to normal (visible and selectable) \n\n    mode.\n\n  \n\n  \n\n   obj: locked object to unlock.\n\n   ignoreLayerMode: if true,the object will be unlocked even if it is on a layer that is locked or off.\n\n   Returns: true if the object was successfully unlocked.\n\n  Unlock(self: ObjectTable,objref: ObjRef,ignoreLayerMode: bool) -> bool\n\n  \n\n   If objref.Object().IsLocked() is true,then the object will be returned to normal (visible and \n\n    selectable) mode.\n\n  \n\n  \n\n   objref: reference to locked object to unlock.\n\n   ignoreLayerMode: if true,the object will be unlocked even if it is on a layer that is locked or off.\n\n   Returns: true if the object was successfully unlocked.\n  \"\"\"\n  pass\n def UnselectAll(self,ignorePersistentSelections=None):\n  \"\"\"\n  UnselectAll(self: ObjectTable) -> int\n\n  \n\n   Unselect objects.\n\n   Returns: Number of object that were unselected.\n\n  UnselectAll(self: ObjectTable,ignorePersistentSelections: bool) -> int\n\n  \n\n   Unselect objects.\n\n  \n\n   ignorePersistentSelections: if true,then objects that are persistently selected will not be unselected.\n\n   Returns: Number of object that were unselected.\n  \"\"\"\n  pass\n def __add__(self,*args):\n  \"\"\" x.__add__(y) <==> x+yx.__add__(y) <==> x+y \"\"\"\n  pass\n def __contains__(self,*args):\n  \"\"\" __contains__[RhinoObject](enumerable: IEnumerable[RhinoObject],value: RhinoObject) -> bool \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __iter__(self,*args):\n  \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n BoundingBox=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the boundingbox for all objects (normal,locked and hidden) in this\n\n   document that exist in \"model\" space. This bounding box does not include\n\n   objects that exist in layout space.\n\n\n\nGet: BoundingBox(self: ObjectTable) -> BoundingBox\n\n\n\n\"\"\"\n\n BoundingBoxVisible=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the boundingbox for all visible objects (normal and locked) in this\n\n   document that exist in \"model\" space. This bounding box does not include\n\n   hidden objects or any objects that exist in layout space.\n\n\n\nGet: BoundingBoxVisible(self: ObjectTable) -> BoundingBox\n\n\n\n\"\"\"\n\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the document that owns this object table.\n\n\n\nGet: Document(self: ObjectTable) -> RhinoDoc\n\n\n\n\"\"\"\n\n\n\nclass StringTable(object):\n # no doc\n def Delete(self,*__args):\n  \"\"\"\n  Delete(self: StringTable,key: str)Delete(self: StringTable,section: str,entry: str)\n\n   Removes user data strings from the document.\n\n  \n\n   section: name of section to delete. If null,all sections will be deleted.\n\n   entry: name of entry to delete. If null,all entries will be deleted for a given section.\n  \"\"\"\n  pass\n def GetEntryNames(self,section):\n  \"\"\"\n  GetEntryNames(self: StringTable,section: str) -> Array[str]\n\n  \n\n   Return list of all entry names for a given section of user data strings in the document.\n\n  \n\n   section: The section from which to retrieve section names.\n\n   Returns: An array of section names. This can be empty,but not null.\n  \"\"\"\n  pass\n def GetKey(self,i):\n  \"\"\" GetKey(self: StringTable,i: int) -> str \"\"\"\n  pass\n def GetSectionNames(self):\n  \"\"\"\n  GetSectionNames(self: StringTable) -> Array[str]\n\n  \n\n   Returns a list of all the section names for user data strings in the document.\n\n     By \n\n    default a section name is a key that is prefixed with a string separated by a backslash.\n\n  \n\n   Returns: An array of section names. This can be empty,but not null.\n  \"\"\"\n  pass\n def GetValue(self,*__args):\n  \"\"\"\n  GetValue(self: StringTable,section: str,entry: str) -> str\n\n  \n\n   Gets a user data string from the document.\n\n  \n\n   section: The section at which to get the value.\n\n   entry: The entry to search for.\n\n   Returns: The user data.\n\n  GetValue(self: StringTable,key: str) -> str\n\n  GetValue(self: StringTable,i: int) -> str\n  \"\"\"\n  pass\n def SetString(self,*__args):\n  \"\"\"\n  SetString(self: StringTable,key: str,value: str) -> str\n\n  SetString(self: StringTable,section: str,entry: str,value: str) -> str\n\n  \n\n   Adds or sets a user data string to the document.\n\n  \n\n   section: The section.\n\n   entry: The entry name.\n\n   value: The entry value.\n\n   Returns: The previous value if successful and a previous value existed.\n  \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"The number of user data strings in the current document.\n\n\n\nGet: Count(self: StringTable) -> int\n\n\n\n\"\"\"\n\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Document that owns this object table.\n\n\n\nGet: Document(self: StringTable) -> RhinoDoc\n\n\n\n\"\"\"\n\n\n\nclass ViewTable(object,IEnumerable[RhinoView],IEnumerable):\n # no doc\n def Add(self,title,projection,position,floating):\n  \"\"\"\n  Add(self: ViewTable,title: str,projection: DefinedViewportProjection,position: Rectangle,floating: bool) -> RhinoView\n\n  \n\n   Constructs a new Rhino view and,at the same time,adds it to the list.\n\n  \n\n   title: The title of the new Rhino view.\n\n   projection: A basic projection type.\n\n   position: A position.\n\n   floating: true if the view floats; false if it is docked.\n\n   Returns: The newly constructed Rhino view; or null on error.\n  \"\"\"\n  pass\n def AddPageView(self,title,pageWidth=None,pageHeight=None):\n  \"\"\"\n  AddPageView(self: ViewTable,title: str,pageWidth: float,pageHeight: float) -> RhinoPageView\n\n  \n\n   Constructs a new page view with a given title and size and,at the same time,adds it to the \n\n    list.\n\n  \n\n  \n\n   title: If null or empty,a name will be generated as \"Page #\" where # is the largest page number.\n\n   pageWidth: The page total width.\n\n   pageHeight: The page total height.\n\n   Returns: The newly created page view on success; or null on error.\n\n  AddPageView(self: ViewTable,title: str) -> RhinoPageView\n\n  \n\n   Constructs a new page view with a given title and,at the same time,adds it to the list.\n\n  \n\n   title: If null or empty,a name will be generated as \"Page #\" where # is the largest page number.\n\n   Returns: The newly created page view on success; or null on error.\n  \"\"\"\n  pass\n def DefaultViewLayout(self):\n  \"\"\" DefaultViewLayout(self: ViewTable) \"\"\"\n  pass\n def Find(self,*__args):\n  \"\"\"\n  Find(self: ViewTable,mainViewportName: str,compareCase: bool) -> RhinoView\n\n  \n\n   Finds a view in this document with a main viewport that has a given name. Note that there\n\n     \n\n       may be multiple views in this document that have the same name. This function only returns\n\n\n    \n     the first view found. If you want to find all the views with a given name,use the \n\n    GetViewList\n\n     function and iterate through the views.\n\n  \n\n  \n\n   mainViewportName: The name of the main viewport.\n\n   compareCase: true if capitalization influences comparison; otherwise,false.\n\n   Returns: A Rhino view on success; null on error.\n\n  Find(self: ViewTable,mainViewportId: Guid) -> RhinoView\n\n  \n\n   Finds a view in this document with a given main viewport Id.\n\n  \n\n   mainViewportId: The ID of the main viewport looked for.\n\n   Returns: View on success. null if the view could not be found in this document.\n  \"\"\"\n  pass\n def FlashObjects(self,list,useSelectionColor):\n  \"\"\" FlashObjects(self: ViewTable,list: IEnumerable[RhinoObject],useSelectionColor: bool) \"\"\"\n  pass\n def FourViewLayout(self,useMatchingViews):\n  \"\"\" FourViewLayout(self: ViewTable,useMatchingViews: bool) \"\"\"\n  pass\n def GetEnumerator(self):\n  \"\"\" GetEnumerator(self: ViewTable) -> IEnumerator[RhinoView] \"\"\"\n  pass\n def GetPageViews(self):\n  \"\"\"\n  GetPageViews(self: ViewTable) -> Array[RhinoPageView]\n\n  \n\n   Gets all page views in the document.\n\n   Returns: An array with all page views. The return value can be an empty array but not null.\n  \"\"\"\n  pass\n def GetStandardRhinoViews(self):\n  \"\"\" GetStandardRhinoViews(self: ViewTable) -> Array[RhinoView] \"\"\"\n  pass\n def GetViewList(self,includeStandardViews,includePageViews):\n  \"\"\"\n  GetViewList(self: ViewTable,includeStandardViews: bool,includePageViews: bool) -> Array[RhinoView]\n\n  \n\n   Gets an array of all the views.\n\n  \n\n   includeStandardViews: true if \"Right\",\"Perspective\",etc.,view should be included; false otherwise.\n\n   includePageViews: true if page-related views should be included; false otherwise.\n\n   Returns: A array of Rhino views. This array can be emptry,but not null.\n  \"\"\"\n  pass\n def Redraw(self):\n  \"\"\"\n  Redraw(self: ViewTable)\n\n   Redraws all views.\n  \"\"\"\n  pass\n def ThreeViewLayout(self,useMatchingViews):\n  \"\"\" ThreeViewLayout(self: ViewTable,useMatchingViews: bool) \"\"\"\n  pass\n def __add__(self,*args):\n  \"\"\" x.__add__(y) <==> x+y \"\"\"\n  pass\n def __contains__(self,*args):\n  \"\"\" __contains__[RhinoView](enumerable: IEnumerable[RhinoView],value: RhinoView) -> bool \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __iter__(self,*args):\n  \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n ActiveView=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets or Sets the active view.\n\n\n\nGet: ActiveView(self: ViewTable) -> RhinoView\n\n\n\nSet: ActiveView(self: ViewTable)=value\n\n\"\"\"\n\n Document=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Document that owns this object table.\n\n\n\nGet: Document(self: ViewTable) -> RhinoDoc\n\n\n\n\"\"\"\n\n ModelSpaceIsActive=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: ModelSpaceIsActive(self: ViewTable) -> bool\n\n\n\n\"\"\"\n\n RedrawEnabled=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Returns or sets (enable or disables) screen redrawing.\n\n\n\nGet: RedrawEnabled(self: ViewTable) -> bool\n\n\n\nSet: RedrawEnabled(self: ViewTable)=value\n\n\"\"\"\n\n\n\n",
  "language": "python",
  "imports": [
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}