{
  "source_url": "https://github.com/bsamiee/Parametric_Arsenal/blob/54ec3f5a7fc2c671cb7bc4601772820e625a1904/rhino/plugins/DocsPlease/libs/command_framework.py",
  "repo": "bsamiee/Parametric_Arsenal",
  "repo_stars": 0,
  "repo_description": "Rhino 8 Plugins and Scripts - A comprehensive monorepo for architectural automation, parametric design, and creative workflows",
  "license": "MIT",
  "filepath": "rhino/plugins/DocsPlease/libs/command_framework.py",
  "instruction": "Title         : command_framework.py\nAuthor        : Bardia Samiee\nProject       : Parametric Forge\nLicense       : MIT\nPath          : rhino/plugins/DocsPlease/libs/command_framework.py",
  "code": "\"\"\"\nTitle         : command_framework.py\nAuthor        : Bardia Samiee\nProject       : Parametric Forge\nLicense       : MIT\nPath          : rhino/plugins/DocsPlease/libs/command_framework.py\n\nDescription\n----------------------------------------------------------------------------\nCentralized command framework with decorators for error handling and common operations.\nThe @rhino_command decorator that handles all cross-cutting concerns for Rhino commands.\n\nException Handling:\n    The decorator handles all exception types from the exceptions hierarchy:\n    - UserCancelledError: Silent exit (not treated as error)\n    - ValidationError subclasses: Alert user with error message\n    - CameraError, TransformError: Print error message\n    - Unexpected exceptions: Print error with stack trace\n\"\"\"\n\nfrom __future__ import annotations\n\nimport traceback\nfrom functools import wraps\nfrom typing import Any, Callable\n\nimport scriptcontext as sc\n\nfrom .common_utils import CommonUtils\nfrom .constants import Strings\nfrom .exceptions import (\n    CameraError,\n    DetailError,\n    DocsPluginError,\n    EnvironmentError,  # noqa: A004\n    LayoutError,\n    ScaleError,\n    TransformError,\n    UserCancelledError,\n    ValidationError,\n)\n\n\ndef rhino_command(\n    requires_layout: bool = True,\n    undo_description: str | None = None,\n    auto_redraw: bool = True,\n    print_start: bool = True,\n    print_end: bool = True,\n) -> Callable[[Callable[..., None]], Callable[..., int]]:\n    \"\"\"Decorator for Rhino commands with centralized error handling.\n\n    This decorator handles all cross-cutting concerns for Rhino commands:\n    - Pre-validates layout view requirement\n    - Manages undo records automatically\n    - Catches and handles all exception types appropriately\n    - Redraws views after successful completion\n    - Prints start/end messages\n\n    Args:\n        requires_layout: Whether command requires layout view to be active.\n                        If True, raises LayoutError if not in layout view.\n        undo_description: Description for undo record. If provided, wraps\n                         command execution in an undo block.\n        auto_redraw: Whether to automatically redraw all views after\n                    successful command completion.\n        print_start: Whether to print \"=== Command Started ===\" message.\n        print_end: Whether to print \"=== Script Completed ===\" message.\n\n    Returns:\n        Decorated function that returns int (0 for success, 1 for error).\n\n    Exception Handling:\n        - UserCancelledError: Prints \"Operation cancelled\" and returns 0\n        - ValidationError subclasses: Shows alert dialog and returns 1\n        - CameraError, TransformError: Prints error message and returns 1\n        - Other DocsPluginError: Shows alert with \"Plugin error:\" prefix\n        - Unexpected exceptions: Prints error with full stack trace\n\n    Example:\n        >>> @rhino_command(requires_layout=True, undo_description=\"Quick Detail\")\n        ... def quick_detail():\n        ...     # No try/except needed - decorator handles all errors\n        ...     rect = rs.GetRectangle()\n        ...     if not rect:\n        ...         raise UserCancelledError(\"No rectangle selected\")\n        ...     # ... business logic ...\n    \"\"\"\n\n    def decorator(func: Callable[..., None]) -> Callable[..., int]:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -> int:  # noqa: PLR0911, PLR0912\n            # Print start message\n            if print_start:\n                command_name = func.__name__.replace(\"_\", \" \").title()\n                print(f\"\\n=== {command_name} Script Started ===\")\n\n            # Pre-validation\n            try:\n                if requires_layout and not CommonUtils.is_layout_view_active():\n                    raise LayoutError(Strings.MSG_LAYOUT_VIEW_REQUIRED)\n\n            except DocsPluginError as e:\n                CommonUtils.alert_user(str(e))\n                return 1\n\n            # Undo record management\n            undo_record = None\n            if undo_description:\n                undo_record = sc.doc.BeginUndoRecord(undo_description)\n\n            try:\n                # Execute the command\n                func(*args, **kwargs)\n\n                # Print completion message\n                if print_end:\n                    print(\"=== Script Completed ===\\n\")\n                return 0  # Success # noqa: TRY300\n\n            except UserCancelledError:\n                print(\"Operation cancelled by user.\")\n                return 0  # User cancellation is not an error\n\n            except (ValidationError, DetailError, LayoutError, EnvironmentError, ScaleError) as e:\n                CommonUtils.alert_user(str(e))\n                return 1\n\n            except (CameraError, TransformError) as e:\n                print(f\"Operation failed: {e}\")\n                return 1\n\n            except DocsPluginError as e:\n                CommonUtils.alert_user(f\"Plugin error: {e}\")\n                return 1\n\n            except (RuntimeError, ValueError, TypeError, AttributeError, ImportError, OSError) as e:\n                print(f\"Unexpected error: {e}\")\n                print(\"Stack trace:\")\n                traceback.print_exc()\n                return 1\n\n            finally:\n                # Cleanup\n                if undo_record is not None:\n                    sc.doc.EndUndoRecord(undo_record)\n\n                if auto_redraw:\n                    sc.doc.Views.Redraw()\n\n        return wrapper\n\n    return decorator\n\n\ndef require_layout_view() -> None:\n    \"\"\"Validate that a layout view is active or raise LayoutError.\n\n    This helper function can be used within commands that need to check\n    for layout view at specific points in execution, rather than at the\n    start via the decorator's requires_layout parameter.\n\n    Raises:\n        LayoutError: If the active view is not a layout (page) view.\n\n    Example:\n        >>> def my_command():\n        ...     # Do some work in any view\n        ...     prepare_data()\n        ...     # Now require layout view for next operation\n        ...     require_layout_view()\n        ...     create_detail_view()\n    \"\"\"\n    if not CommonUtils.is_layout_view_active():\n        raise LayoutError(Strings.MSG_LAYOUT_VIEW_REQUIRED)\n\n\ndef safe_undo_block(description: str) -> Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"Decorator that wraps function execution in an undo block.\n\n    This decorator is useful for library functions that need undo management\n    but aren't full commands. For commands, use @rhino_command with\n    undo_description parameter instead.\n\n    Args:\n        description: Description for the undo record shown in Rhino's undo list.\n\n    Returns:\n        Decorated function with automatic undo block management.\n\n    Example:\n        >>> @safe_undo_block(\"Batch Update Details\")\n        ... def update_all_details(detail_ids):\n        ...     for detail_id in detail_ids:\n        ...         update_detail(detail_id)\n        ...     # All changes grouped in single undo operation\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -> Callable[..., Any]:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -> Any:\n            undo_record = sc.doc.BeginUndoRecord(description)\n            try:\n                return func(*args, **kwargs)\n            finally:\n                sc.doc.EndUndoRecord(undo_record)\n\n        return wrapper\n\n    return decorator\n",
  "language": "python",
  "imports": [
    "scriptcontext"
  ],
  "has_docstring": true
}