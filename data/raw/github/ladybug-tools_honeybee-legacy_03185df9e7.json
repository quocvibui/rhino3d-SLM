{
  "source_url": "https://github.com/ladybug-tools/honeybee-legacy/blob/bd62af4862fe022801fb87dbc8794fdf1dff73a9/src/Honeybee_gbXML%20to%20Honeybee.py",
  "repo": "ladybug-tools/honeybee-legacy",
  "repo_stars": 129,
  "repo_description": ":bee: Honeybee is a free and open source plugin to connect Grasshopper3D to EnergyPlus, Radiance, Daysim and OpenStudio for building energy and daylighting simulation",
  "license": "NOASSERTION",
  "filepath": "src/Honeybee_gbXML to Honeybee.py",
  "instruction": "Import gbXML files as Honeybee zones.",
  "code": "#\n# Honeybee: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Honeybee.\n# \n# Copyright (c) 2013-2020, Mostapha Sadeghipour Roudsari <mostapha@ladybug.tools>, Chris Mackey <Chris@MackeyArchitecture.com>, and Chien Si Harriman <charriman@terabuild.com>\n# Honeybee is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Honeybee is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Honeybee; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nImport gbXML files as Honeybee zones.\n\nThis component uses OpenStudio libraries to import all geometry, constrcuctions,\nand boundary conditions (including adjacencies).\n\nLoads, schedules, and HVAC systems are not currently imported by this component\nand must be reassigned using Honeybee components.\n-\n\nProvided by Honeybee 0.0.66\n    \n    Args:\n        _filepath: Full filepath to xml file.\n        _zoneNames: The list of names for thermal zones that you want to be loaded\n            from the file. By default the component will import all the zones.\n        _import: Set to True to import the model.\n    Returns:\n        readMe!:\n        model: OpenStudio model which is created from the gbXML file. This output\n            will only be useful for advanced users to develop custom scipts.\n        HBZones: List of honeybee zones.\n        shadings: List of shading surfaces if any.\n\"\"\"\n\nghenv.Component.Name = \"Honeybee_gbXML to Honeybee\"\nghenv.Component.NickName = 'XMLTOHB'\nghenv.Component.Message = 'VER 0.0.66\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"HB-Legacy\"\nghenv.Component.SubCategory = \"10 | Energy | Energy\"\n#compatibleHBVersion = VER 0.0.56\\nSEP_09_2016\n#compatibleLBVersion = VER 0.0.59\\nJUL_24_2015\nghenv.Component.AdditionalHelpFromDocStrings = \"0\"\n\nimport os\nimport scriptcontext as sc\nimport Rhino as rc\n\n# check the version of OpenStudio.\ntry:\n    openStudioLibFolder = sc.sticky[\"honeybee_folders\"][\"OSLibPath\"]\nexcept:\n    pass\ntry:\n    osVersion = openStudioLibFolder.split('-')[-1].split('/')[0]\n    vernum1, vernum2 = osVersion.split('.')[0], osVersion.split('.')[1]\nexcept:\n    vernum1, vernum2= '1', '0'\nvers = int(vernum1 + vernum2)\n\n\ndef getHBMaterial(m):\n    mat = {}\n    s = (o for o in str(m.idfObject()).split('\\n') if o.rstrip())\n    for c, i in enumerate(s):\n        if c == 0:\n            mat[0] = i[3:-1] # remove OS:\n        elif c < 3:\n            continue # name and handle\n        else:\n            v, cc = i.split('!')\n            mat[c - 2] = v.rstrip()[:-1], cc.rstrip()    \n    \n    return mat\n\n\ndef getHBConstruction(m, materials):\n    mat = {}\n    s = (o for o in str(m.idfObject()).split('\\n') if o.rstrip())\n    for c, i in enumerate(s):\n        if c == 0:\n            mat[0] = i[3:-1] # remove OS:\n        elif c < 4:\n            continue # name and handle\n        else:\n            v, cc = i.split('!')\n            mat[c - 3] = str(materials[v.strip()[:-1]].name()), cc.rstrip()    \n    return mat\n\n\ndef getGeometry(ossurface, minZ=None, maxZ=None, offset=0.01):\n    if minZ is not None and maxZ is not None:\n        pts = [rc.Geometry.Point3d(p.x(), p.y(), p.z() + offset) if p.z() == minZ\n               else rc.Geometry.Point3d(p.x(), p.y(), p.z() - offset) if p.z() == maxZ\n               else rc.Geometry.Point3d(p.x(), p.y(), p.z())\n               for p in ossurface.vertices()]\n    else:\n        pts = [rc.Geometry.Point3d(p.x(), p.y(), p.z())\n               for p in ossurface.vertices()]\n    \n    pts.append(pts[0])\n    polyline = rc.Geometry.Polyline(pts).ToNurbsCurve()\n    return rc.Geometry.Brep.CreatePlanarBreps(polyline)[0]\n\n\ndef getHBSrfType(ossurface):\n    \n    srfTypeDict = {0:'WALL',\n       1:'ROOF',\n       2:'FLOOR',\n       3:'CEILING',\n       4:'WALL',\n       5:'WINDOW',\n       6:'SHADING',\n       'WALL': 0,\n       'ROOF':1,\n       'ROOFCEILING': 1,\n       'FLOOR': 2,\n       'CEILING': 3,\n       'WINDOW':5,\n       'SHADING': 6}\n    \n    t = str(ossurface.surfaceType()).upper()\n    if t in srfTypeDict:\n        return srfTypeDict[t]\n\ndefaultConstructions = [\"Interior Ceiling\", \"Interior Floor\",\n                        \"Interior Wall\", \"Interior Window\",\n                        \"Exterior Floor\", \"Exterior Roof\", \"Exterior Wall\",\n                        \"Exterior Window\"]\n\ndef getOSSurfaceConstructionName(s, constructionCollection, missingConstrCount = 0):\n    construction = s.construction()\n    if construction.is_initialized and not construction.isNull():\n        construction = construction.get()\n    if not hasattr(construction, 'name'):\n        missingConstrCount += 1\n        #print 'Construction for {} is missing. Default construction will be used.'.format(s.name())\n        return None, missingConstrCount\n    else:\n        if vers < 27:\n            if str(construction.name()) in defaultConstructions:\n                return None, missingConstrCount\n            if not str(construction.name()).upper() in constructionCollection:\n                print 'Failed to find {} in constructions.'.format(construction.name())\n                return None, missingConstrCount\n            else:\n                return str(construction.name()).upper(), missingConstrCount\n        else:\n            if str(construction.nameString()) in defaultConstructions:\n                return None, missingConstrCount\n            if not str(construction.nameString()).upper() in constructionCollection:\n                print 'Failed to find {} in constructions.'.format(construction.nameString())\n                return None, missingConstrCount\n            else:\n                return str(construction.nameString()).upper(), missingConstrCount\n\ndef updateAdj(surface1, surface2):\n    # change roof to ceiling\n    # the same for ceiling on ground\n    if int(surface1.type) == 1: surface1.setType(3) # roof + adjacent surface = ceiling\n    elif int(surface2.type) == 1: surface2.setType(3)\n    \n    # Change different floor types to be floors between zones.\n    if int(surface1.type) == 2: surface1.setType(2)\n    if int(surface2.type) == 2:  surface2.setType(2)\n    \n    # change construction\n    if surface1.EPConstruction == None:\n        surface1.setEPConstruction(surface1.intCnstrSet[surface1.type])\n        surface2.setEPConstruction(surface1.intCnstrSet[surface2.type])\n    else:\n        hb_EPObjectsAux = sc.sticky[\"honeybee_EPObjectsAUX\"]()\n        hb_EPObjectsAux.assignEPConstruction(surface1, surface1.EPConstruction, ghenv.Component)\n        hb_EPObjectsAux.assignEPConstruction(surface2, surface1.EPConstruction, ghenv.Component)\n    \n    # change bc\n    surface1.setBC('SURFACE', True)\n    surface2.setBC('SURFACE', True)\n    # change bc.Obj\n    # used to be only a name but I changed it to an object so you can find the parent, etc.\n    surface1.setBCObject(surface2)\n    surface2.setBCObject(surface1)\n    \n    # set sun and wind exposure to no exposure\n    surface2.setSunExposure('NoSun')\n    surface1.setSunExposure('NoSun')\n    surface2.setWindExposure('NoWind')\n    surface1.setWindExposure('NoWind')\n    \n    # check for child objects\n    if (surface1.hasChild or surface2.hasChild) and (len(surface2.childSrfs)!= len(surface1.childSrfs)):\n        # give warning\n        warnMsg= \"Number of windows doesn't match between \" + surface1.name + \" and \" + surface2.name + \".\" + \\\n                 \" Make sure adjacent surfaces are divided correctly and have similar windows.\"\n        print warnMsg\n    \n    if surface1.hasChild and surface2.hasChild:\n        # find child surfaces that match the other one\n        for childSurface1 in surface1.childSrfs:\n            for childSurface2 in surface2.childSrfs:\n                if childSurface1.cenPt.DistanceTo(childSurface2.cenPt) <= sc.doc.ModelAbsoluteTolerance:\n                    childSurface1.BCObject.name = childSurface2.name\n                    childSurface2.BCObject.name = childSurface1.name\n                    # change construction\n                    if childSurface1.EPConstruction == None:\n                        childSurface1.setEPConstruction(surface1.intCnstrSet[5])\n                        childSurface2.setEPConstruction(surface1.intCnstrSet[5])\n                    else:\n                        hb_EPObjectsAux = sc.sticky[\"honeybee_EPObjectsAUX\"]()\n                        hb_EPObjectsAux.assignEPConstruction(childSurface1, childSurface1.EPConstruction, ghenv.Component)\n                        hb_EPObjectsAux.assignEPConstruction(childSurface2, childSurface1.EPConstruction, ghenv.Component)\n                    # change the boundary condition\n                    childSurface1.setBC('SURFACE', True)\n                    childSurface2.setBC('SURFACE', True)\n                    childSurface1.setBCObject(childSurface2)\n                    childSurface2.setBCObject(childSurface1)\n                    # set sun and wind exposure to no exposure\n                    childSurface2.setSunExposure('NoSun')\n                    childSurface1.setSunExposure('NoSun')\n                    childSurface2.setWindExposure('NoWind')\n                    childSurface1.setWindExposure('NoWind')\n\nif sc.sticky.has_key('honeybee_release'):\n\n    EPZone = sc.sticky[\"honeybee_EPZone\"]\n    EPSrf = sc.sticky[\"honeybee_EPSurface\"]\n    EPZoneSurface = sc.sticky[\"honeybee_EPZoneSurface\"]\n    EPFenSurface = sc.sticky[\"honeybee_EPFenSurface\"]\n    EPSHDSurface = sc.sticky[\"honeybee_EPShdSurface\"]\n\n    if sc.sticky[\"honeybee_folders\"][\"OSLibPath\"] != None:\n        # openstudio is there\n        openStudioLibFolder = sc.sticky[\"honeybee_folders\"][\"OSLibPath\"]\n        openStudioIsReady = True\n        import clr\n        clr.AddReferenceToFileAndPath(openStudioLibFolder + \"\\\\openStudio.dll\")\n        import sys\n        if openStudioLibFolder not in sys.path:\n            sys.path.append(openStudioLibFolder)\n        \n        import OpenStudio as ops\n    else:\n        openStudioIsReady = False\n        # let the user know that they need to download OpenStudio libraries\n        msg1 = \"You do not have OpenStudio installed on Your System.\\n\" + \\\n            \"You wont be able to use this component until you install it.\\n\" + \\\n            \"Download the latest OpenStudio for Windows from:\\n\"\n        msg2 = \"https://www.openstudio.net/downloads\"\n        print msg1\n        print msg2\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, msg1)\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, msg2)\nelse:\n    openStudioIsReady = False\n\nif openStudioIsReady and _import and _filepath:\n    \n    _filepath = _filepath.replace('\\\\\\\\', '/').replace('\\\\', '/')\n    assert os.path.isfile(_filepath), \\\n        'Failed to find the xml file at {}.'.format(_filepath)\n    assert _filepath.lower().endswith('.xml'), \\\n        '{} does not end with .xml. Not a valid xml file.'.format(_filepath)\n    translator = ops.GbXMLReverseTranslator()\n    try:\n        model = translator.loadModel(ops.Path(os.path.normpath(_filepath)))\n    except TypeError:\n        filepath = ops.OpenStudioUtilitiesCore.toPath(os.path.normpath(_filepath))\n        if vers < 27:\n            # OpenStudio 2.6.1\n            model = translator.loadModel(ops.Path(filepath))\n        else:\n            # OpenStudio 2.7.0\n            model = translator.loadModel(filepath)\n    errors = translator.errors()\n    warnings = translator.warnings()\n    if ''.join(errors):\n        raise Exception('\\n'.join(errors))\n    for warn in warnings:\n        print warn.logMessage()\n    print 'The model is imported from {}'.format(os.path.normpath(_filepath))\n    success = True\n    model = model.get()\n\n    # check materials and constructions and add them to honeybee\n    constructions = {str(c.handle()): c for c in model.getConstructions()}\n    materials = {str(m.handle()): m for m in model.getMaterials()}\n    constructionCollection = {}\n    materialCollection = {}\n    \n    for c in constructions.itervalues():\n        if str(c.name()) == 'Air Wall' or str(c.name()) in defaultConstructions:\n            continue\n        if vers < 27:\n            constructionCollection[str(c.name()).upper()] = getHBConstruction(c, materials)\n        else:\n            constructionCollection[str(c.nameString()).upper()] = getHBConstruction(c, materials)\n        for m in c.layers():\n            if vers < 27:\n                assert str(m.handle()) in materials, \\\n                    '\"{}\" material from \"{}\" construction is not in gbXML materials.' \\\n                    .format(m.name(), c.name())\n                materialCollection[str(m.name()).upper()] = getHBMaterial(m)\n            else:\n                assert str(m.handle()) in materials, \\\n                    '\"{}\" material from \"{}\" construction is not in gbXML materials.' \\\n                    .format(m.nameString(), c.nameString())\n                materialCollection[str(m.nameString()).upper()] = getHBMaterial(m)\n    \n    # list of final HBzones\n    zones = []\n    # dictionary to store boundary consition and adjacency information.\n    adjDict = {}\n    # number of surfaces with missing construcitons\n    missingCcount = 0\n    adjResetNeeded = False\n    \n    if not _zoneNames:\n        spaces = model.getSpaces()\n    else:\n        spaces = tuple(s for s in model.getSpaces() if str(s.name()) in _zoneNames)\n    \n    \n    for space in spaces:\n        # create thermal zone\n        zone = space.thermalZone()\n        if not zone.is_initialized():\n            continue\n        z = zone.get()\n        hbz = EPZone(None, 0, str(space.name()), program = [None, None], isConditioned = True)\n        for s in space.surfaces:\n            # create EP surface\n            minZ = min(p.z() for p in s.vertices())\n            maxZ = max(p.z() for p in s.vertices())\n            srf = EPZoneSurface(getGeometry(s), 1, str(s.name()), getHBSrfType(s))\n            construction, missingCcount = getOSSurfaceConstructionName(s, constructionCollection, missingCcount)\n            \n            if construction:\n                srf.construction = construction\n                srf.EPConstruction = construction\n            \n            # store adjacency information\n            HsrfName = srf.name\n            if str(s.outsideBoundaryCondition()) == 'Ground':\n                adjDict[HsrfName] = ['GROUND', None]\n                adjResetNeeded = True\n            elif str(s.outsideBoundaryCondition()) == 'Adiabatic':\n                adjDict[HsrfName] = ['ADIABATIC', None]\n                adjResetNeeded = True\n            elif str(s.outsideBoundaryCondition()) == 'Surface':\n                adjDict[HsrfName] = ['SURFACE', str(s.adjacentSurface().get().name())]\n                adjResetNeeded = True\n            else:\n                adjDict[HsrfName] = ['OUTDOORS', None]\n            \n            hbz.addSrf(srf)\n            for ss in s.subSurfaces():\n                #create the surface\n                fenSrf = EPFenSurface(getGeometry(ss, minZ, maxZ), 1, str(ss.name()), srf, 5)\n                construction, missingCcount = getOSSurfaceConstructionName(ss, constructionCollection, missingCcount)\n                if construction:\n                   fenSrf.construction = construction\n                srf.addChildSrf(fenSrf)\n        \n        zones.append(hbz)\n    \n    # create the zones\n    for zone in zones:\n        zone.createZoneFromSurfaces()\n    \n    # try to edit the zone adjacencies to reflect what is in the gbXML.\n    if adjResetNeeded == True:\n        for zone in zones:\n            for srf in zone.surfaces:\n                try:\n                    if adjDict[srf.name][0] == 'SURFACE':\n                        adjSrfName = adjDict[srf.name][1]\n                        aSrfFound = False\n                        if adjSrfName != None:\n                            # try to find the adjacent surface among the zones.\n                            for azone in zones:\n                                for asrf in azone.surfaces:\n                                    if asrf.name == adjSrfName:\n                                        aSrfFound = True\n                                        updateAdj(srf, asrf)\n                    elif adjDict[srf.name][0] != 'OUTDOORS':\n                        srf.BC = adjDict[srf.name][0]\n                        srf.setSunExposure('NoSun')\n                        srf.setSunExposure('NoSun')\n                except:\n                    print 'Cound not set the boundary conditions correctly for surface {}'.format(srf.name)\n    \n    # give warnings about missing constructions.\n    if missingCcount != 0:\n        print '{} surfaces have missing constructions. Default construction will be used.'.format(str(missingCcount))\n    \n    shadings = (EPSHDSurface(getGeometry(shd), 1, str(shd.name()))\n                for shd in model.getShadingSurfaces())\n    \n    # add construction to honeybee library\n    sc.sticky [\"honeybee_constructionLib\"].update(constructionCollection)\n    sc.sticky[\"honeybee_materialLib\"].update(materialCollection)\n    \n    hb_hive = sc.sticky[\"honeybee_Hive\"]()\n    HBZones = hb_hive.addToHoneybeeHive(zones, ghenv.Component)\n    \n    \n    \n    try:\n        shadings = hb_hive.addToHoneybeeHive(shadings, ghenv.Component, False)\n    except TypeError:\n        # old version of Honeybee\n        shadings = hb_hive.addToHoneybeeHive(shadings, ghenv.Component)",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}