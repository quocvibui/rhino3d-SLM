{
  "source_url": "https://github.com/ksobon/MantisShrimp/blob/9b3d1ef747a04f75f3542c38550c4e29b9d08c8f/Dynamo/src/Write%20GH%20File.py",
  "repo": "ksobon/MantisShrimp",
  "repo_stars": 39,
  "repo_description": "A interop project for bridging the gap between Rhino/Grasshopper and Revit/Dynamo",
  "license": "unknown",
  "filepath": "Dynamo/src/Write GH File.py",
  "instruction": "Copyright(c) 2015, Konrad Sobon @arch_laboratory, http://archi-lab.net",
  "code": "#Copyright(c) 2015, Konrad Sobon\n# @arch_laboratory, http://archi-lab.net\n\nimport clr\nimport sys\nclr.AddReference('ProtoGeometry')\n\npyt_path = r'C:\\Program Files (x86)\\IronPython 2.7\\Lib'\nsys.path.append(pyt_path)\n\nimport os\nappDataPath = os.getenv('APPDATA')\nmsPath = appDataPath + r\"\\Dynamo\\0.8\\packages\\Mantis Shrimp\\extra\"\nif msPath not in sys.path:\n\tsys.path.append(msPath)\ntxtFilePath = appDataPath + r\"\\Dynamo\\0.8\\packages\\Mantis Shrimp\\extra\\rhPath.txt\"\nif not os.path.isfile(txtFilePath):\n\tmessage = \"Provide valid RhinoCommon.dll path.\"\nelse:\n\tfile = open(txtFilePath, 'r+')\n\trhDllPath = file.readline()\n\tclr.AddReferenceToFileAndPath(rhDllPath)\n\tfile.close()\n\nfrom Autodesk.DesignScript.Geometry import *\nfrom System import Array\nfrom System.Collections.Generic import *\nimport Rhino as rc\nimport pickle\nfrom mantisshrimp import *\n\n#The inputs to this node will be stored as a list in the IN variable.\ndataEnteringNode = IN\n\ndsObjects = IN[0]\n_filePath = str(IN[1])\n_export = IN[2]\n\nclass SerializeObjects(object):\n    \n    def __init__(self, filePath, data = None):\n        folder, fileName = os.path.split(filePath)\n        if not os.path.isdir(folder):\n            os.mkdir(folder)\n        self.filePath = filePath\n        self.data = data     \n    def saveToFile(self):\n    \twith open(self.filePath, 'wb') as outf:\n\t\t\tpickle.dump(self.data, outf)         \n    def readFromFile(self):\n        with open(self.filePath, 'rb') as inf:\n            self.data = pickle.load(inf)\n\ndef process_list(_func, _list):\n    return map( lambda x: process_list(_func, x) if type(x)==list else _func(x), _list )\n\ndef toMSPoint(_point):\n\treturn MSPoint(_point.X, _point.Y, _point.Z)\n\ndef toMSLine(item):\n\tmsStartPt = MSPoint(item.StartPoint.X, item.StartPoint.Y, item.StartPoint.Z)\n\tmsEndPt = MSPoint(item.EndPoint.X, item.EndPoint.Y, item.EndPoint.Z)\n\treturn MSLine(msStartPt, msEndPt)\n\ndef toMSPoint(item):\n\treturn MSPoint(item.X, item.Y, item.Z)\n\ndef toMSArc(item):\n\tmsStartPt = toMSPoint(item.StartPoint)\n\tmsEndPt = toMSPoint(item.EndPoint)\n\tmsMidPoint = toMSPoint(item.PointAtParameter(0.5))\n\treturn MSArc(msStartPt, msMidPoint, msEndPt)\n\ndef toMSEllipse(item):\n\torigin = toMSPoint(item.CenterPoint)\n\tptX = toMSPoint(Point.Add(item.CenterPoint, item.MinorAxis))\n\tptY = toMSPoint(Point.Add(item.CenterPoint, item.MajorAxis))\n\treturn MSEllipse(origin, ptX, ptY, None, None, None)\n\ndef toMSCircle(item):\n\tmsOrigin = toMSPoint(item.CenterPoint)\n\tmsVector = MSVector(item.Normal.X, item.Normal.Y, item.Normal.Z)\n\tmsPlane = MSPlane(msOrigin, msVector)\n\treturn MSCircle(msPlane, item.Radius)\n\ndef toMSNurbsCurve(item):\n\tmsPoints4d = []\n\tfor pt, w in zip(item.ControlPoints(), item.Weights()):\n\t\tmsPoints4d.append(MSPoint4d(pt.X, pt.Y, pt.Z, w))\n\treturn MSNurbsCurve(msPoints4d, item.Weights(), item.Knots(), item.Degree)\n\ndef toMSNurbsCurve2(item):\n\tmsPoints4d = []\n\tfor pt in item.ControlPoints():\n\t\tmsPoints4d.append(MSPoint4d(pt.X, pt.Y, pt.Z, 1))\n\tweights = []\n\tfor i in range(0, len(item.ControlPoints()),1):\n\t\tweights.append(1)\n\treturn MSNurbsCurve(msPoints4d, weights, item.Knots(), item.Degree)\n\ndef tryGetArc(item):\n\tstartPoint = item.StartPoint\n\tendPoint = item.EndPoint\n\ttangent = item.TangentAtParameter(0)\n\tdsArc = Arc.ByStartPointEndPointStartTangent(startPoint, endPoint, tangent)\n\tif round(dsArc.Length, 4) == round(item.Length, 4):\n\t\treturn dsArc\n\telse:\n\t\treturn None\n\ndef tryGetLine(item):\n\tstartPoint = item.StartPoint\n\tendPoint = item.EndPoint\n\tdistance = startPoint.DistanceTo(endPoint)\n\tif round(item.Length, 4) == round(distance, 4):\n\t\treturn Line.ByStartPointEndPoint(startPoint, endPoint)\n\telse:\n\t\treturn None\n\ndef toMSPolyLine(item):\n\tsegments, msSegments = [], []\n\tfor crv in item.Curves():\n\t\tsegments.append(tryGetLine(crv))\n\tif all(type(x) == Line for x in segments):\n\t\tfor i in segments:\n\t\t\tmsSegments.append(toMSLine(i))\n\t\treturn MSPolyLine(msSegments)\n\telse:\n\t\treturn None\n\ndef toMSPolyCurve(item):\n\tsegments = []\n\tfor crv in item.Curves():\n\t\tif tryGetLine(crv) != None:\n\t\t\tsegments.append(toMSLine(tryGetLine(crv)))\n\t\telif tryGetArc(crv) != None:\n\t\t\tsegments.append(toMSArc(tryGetArc(crv)))\n\t\telse:\n\t\t\tsegments.append(toMSNurbsCurve2(crv.ToNurbsCurve()))\n\treturn MSPolyCurve(segments)\n\ndef toMSMesh(item):\n\tmsPoints = []\n\tfor pt in item.VertexPositions:\n\t\tmsPoints.append(MSPoint(pt.X, pt.Y, pt.Z))\n\tfaceTopology = []\n\tfor i in item.FaceIndices:\n\t\tif i.Count == 3:\n\t\t\tfaceTopology.append([i.A, i.B, i.C])\n\t\telse:\n\t\t\tfaceTopology.append([i.A, i.B, i.C, i.D])\n\treturn MSMesh(msPoints, faceTopology)\n\ndef toMSNurbsSurface(item):\n\trational = item.IsRational\n\tweights = item.Weights()\n\tcontrolPoints = list(item.ControlPoints())\n\tmsControlPoints = [[] for i in range(len(controlPoints))]\n\tfor index, (ptList, wtList) in enumerate(zip(controlPoints, weights)):\n\t\tfor pt, wt in zip(ptList, wtList):\n\t\t\tmsControlPoints[index].append(MSPoint4d(pt.X, pt.Y, pt.Z, wt))\n\treturn MSNurbsSurface(msControlPoints, weights, item.UKnots(), item.VKnots(), item.DegreeU, item.DegreeV, item.NumControlPointsU, item.NumControlPointsV, rational)\n\ndef toMSBrep(item):\n\tfaces = []\n\tsubSurf = item.Surfaces()\n\tfor i in subSurf:\n\t\tfaces.append(toMSNurbsSurface(i.ToNurbsSurface()))\n\treturn MSBrep(faces, None)\n\ndef toMSObject(item):\n\tif type(item) == Point:\n\t\treturn MSPoint(item.X, item.Y, item.Z)\n\telif type(item) == Line:\n\t\treturn toMSLine(item)\n\telif type(item) == PolyCurve:\n\t\tif toMSPolyLine(item) != None:\n\t\t\treturn toMSPolyLine(item)\n\t\telse:\n\t\t\treturn toMSPolyCurve(item)\n\telif type(item) == Circle:\n\t\treturn toMSCircle(item)\n\telif type(item) == Ellipse:\n\t\treturn toMSEllipse(item)\n\telif type(item) == Arc:\n\t\treturn toMSArc(item)\n\telif type(item) == NurbsCurve:\n\t\treturn toMSNurbsCurve(item)\n\telif type(item) == Mesh:\n\t\treturn toMSMesh(item)\n\telif type(item) == NurbsSurface:\n\t\treturn toMSNurbsSurface(item)\n\telif type(item) == PolySurface:\n\t\treturn toMSBrep(item)\n\telse:\n\t\treturn MSData(item)\n\nif _export:\n\tif isinstance(dsObjects, list):\n\t\toutGeometry = process_list(toMSObject, dsObjects)\n\telse:\n\t\toutGeometry = process_list(toMSObject, [dsObjects])\n\ttry:\n\t\tserializer = SerializeObjects(_filePath, outGeometry)\n\t\tserializer.saveToFile()\n\t\tmessage = \"File is exported to \\n\" + _filePath + \".\\n\" + \\\n\t\t\t\"Now you can use Grasshopper to import the file.\"\n\texcept:\n\t\tmessage = \"Export failed. Try again.\"\n\t\tpass\nelse:\n\tmessage = \"Export set to false.\"\n\n#Assign your output to the OUT variable\nOUT = '\\n'.join('{:^35}'.format(s) for s in message.split('\\n'))\n",
  "language": "python",
  "imports": [
    "Rhino",
    "RhinoCommon"
  ],
  "has_docstring": true
}