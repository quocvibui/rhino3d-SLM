{
  "source_url": "https://github.com/arijitaich/2dtocad/blob/f837c55a0c1597a488080ecdc9c5c11a0264d13e/mcp/mesh_to_cad_grid.py",
  "repo": "arijitaich/2dtocad",
  "repo_stars": 0,
  "repo_description": "A pipeline to create 2d to cad of each and every component required to manufacture an item provided as user input images.",
  "license": "unknown",
  "filepath": "mcp/mesh_to_cad_grid.py",
  "instruction": "Mesh Surface Tessellation to CAD Grid - Enhanced Edition",
  "code": "\"\"\"Mesh Surface Tessellation to CAD Grid - Enhanced Edition\n\nThis script:\n1. Loads a 3D mesh (GLB/OBJ) from image-to-3D generation\n2. Creates a CONNECTED parametric grid of quads covering the entire surface\n3. Exports to Rhino-compatible .3dm CAD file with:\n   - NURBS surface patches (not just curves)\n   - Shared vertices between adjacent quads\n   - Region-based grouping and layers\n   - Fully editable CAD geometry\n\nThe CAD designer can then:\n- Select and modify individual patches or regions\n- Adjust quad size/dimensions globally or locally\n- Move shared vertices to reshape multiple patches at once\n- Input client specifications and apply to grouped regions\n- Export clean geometry for mold manufacturing\n\nKey Enhancement: Squares share vertices, so editing one affects neighbors,\ncreating a true \"patchwork surface\" that behaves as unified CAD geometry.\n\"\"\"\n\nimport numpy as np\nimport trimesh\nimport os\nimport sys\nimport json\nimport argparse\nfrom pathlib import Path\nfrom typing import List, Tuple, Optional, Dict, Any\nfrom collections import defaultdict\n\n# Optional: scipy and sklearn for advanced grid operations\ntry:\n    from scipy.spatial import KDTree\n    HAS_SCIPY = True\nexcept ImportError:\n    HAS_SCIPY = False\n    print(\"Note: scipy not installed. Install with: pip install scipy\")\n\ntry:\n    from sklearn.cluster import KMeans\n    HAS_SKLEARN = True\nexcept ImportError:\n    HAS_SKLEARN = False\n    print(\"Note: sklearn not installed. Region detection disabled.\")\n    print(\"Install with: pip install scikit-learn\")\n\n# Optional: rhino3dm for native Rhino file export\ntry:\n    import rhino3dm\n    HAS_RHINO3DM = True\nexcept ImportError:\n    HAS_RHINO3DM = False\n    print(\"Note: rhino3dm not installed. Will export to OBJ/STEP instead of .3dm\")\n    print(\"Install with: pip install rhino3dm\")\n\n\nclass MeshGridTessellator:\n    \"\"\"\n    Tessellates a 3D mesh surface with a parametric grid of squares.\n    \"\"\"\n    \n    def __init__(self, mesh_path: str):\n        \"\"\"\n        Initialize with a mesh file.\n        \n        Args:\n            mesh_path: Path to GLB, OBJ, STL, or other mesh file\n        \"\"\"\n        self.mesh_path = mesh_path\n        self.mesh = None\n        self.grid_squares = []\n        self.grid_params = {}\n        \n        # Enhanced: Connected patch data\n        self.shared_vertices = {}  # vertex_id -> [x, y, z]\n        self.quad_patches = []     # Each patch references shared vertex IDs\n        self.vertex_to_quads = defaultdict(list)  # Which quads share each vertex\n        self.regions = {}          # region_id -> list of quad IDs\n        self.region_layers = {}    # region_id -> layer properties\n        \n        self._load_mesh()\n    \n    def _load_mesh(self):\n        \"\"\"Load the mesh file using trimesh.\"\"\"\n        print(f\"Loading mesh: {self.mesh_path}\")\n        \n        # Load the mesh\n        loaded = trimesh.load(self.mesh_path)\n        \n        # Handle scene vs single mesh\n        if isinstance(loaded, trimesh.Scene):\n            # Combine all meshes in scene\n            meshes = []\n            for name, geom in loaded.geometry.items():\n                if isinstance(geom, trimesh.Trimesh):\n                    meshes.append(geom)\n            if meshes:\n                self.mesh = trimesh.util.concatenate(meshes)\n            else:\n                raise ValueError(\"No valid meshes found in scene\")\n        elif isinstance(loaded, trimesh.Trimesh):\n            self.mesh = loaded\n        else:\n            raise ValueError(f\"Unsupported mesh type: {type(loaded)}\")\n        \n        print(f\"  Vertices: {len(self.mesh.vertices)}\")\n        print(f\"  Faces: {len(self.mesh.faces)}\")\n        print(f\"  Bounds: {self.mesh.bounds}\")\n        \n    def get_mesh_info(self) -> Dict[str, Any]:\n        \"\"\"Get information about the loaded mesh.\"\"\"\n        bounds = self.mesh.bounds\n        size = bounds[1] - bounds[0]\n        \n        return {\n            \"vertices\": len(self.mesh.vertices),\n            \"faces\": len(self.mesh.faces),\n            \"bounds_min\": bounds[0].tolist(),\n            \"bounds_max\": bounds[1].tolist(),\n            \"size\": size.tolist(),\n            \"surface_area\": float(self.mesh.area),\n            \"volume\": float(self.mesh.volume) if self.mesh.is_watertight else None,\n            \"is_watertight\": self.mesh.is_watertight\n        }\n    \n    def create_uv_grid(self, square_size: float = 1.0, \n                       uv_resolution: int = 100) -> List[Dict]:\n        \"\"\"\n        Create a grid of squares based on UV mapping of the mesh surface.\n        \n        This method:\n        1. Computes UV coordinates for the mesh\n        2. Creates a regular grid in UV space\n        3. Maps each grid cell back to 3D space\n        \n        Args:\n            square_size: Size of each square in mesh units\n            uv_resolution: Resolution of the UV grid\n            \n        Returns:\n            List of square dictionaries with vertices and properties\n        \"\"\"\n        print(f\"\\nCreating UV-based grid with square_size={square_size}\")\n        \n        # Get mesh bounds to determine grid dimensions\n        bounds = self.mesh.bounds\n        mesh_size = bounds[1] - bounds[0]\n        max_dim = max(mesh_size)\n        \n        # Calculate number of squares needed\n        num_squares_per_axis = int(max_dim / square_size) + 1\n        \n        print(f\"  Mesh size: {mesh_size}\")\n        print(f\"  Squares per axis: ~{num_squares_per_axis}\")\n        \n        # Sample points on the mesh surface\n        points, face_indices = trimesh.sample.sample_surface(\n            self.mesh, \n            count=uv_resolution * uv_resolution\n        )\n        \n        # Get face normals for sampled points\n        normals = self.mesh.face_normals[face_indices]\n        \n        # Create grid in the bounding box\n        self.grid_squares = []\n        \n        # Create a 3D grid aligned with principal axes\n        x_steps = np.arange(bounds[0][0], bounds[1][0] + square_size, square_size)\n        y_steps = np.arange(bounds[0][1], bounds[1][1] + square_size, square_size)\n        z_steps = np.arange(bounds[0][2], bounds[1][2] + square_size, square_size)\n        \n        square_id = 0\n        \n        # For each sampled point, create a square tangent to the surface\n        # We'll use a subset for performance\n        sample_step = max(1, len(points) // 1000)  # Limit to ~1000 squares\n        \n        for i in range(0, len(points), sample_step):\n            point = points[i]\n            normal = normals[i]\n            \n            # Create tangent vectors\n            tangent1 = self._get_tangent_vector(normal)\n            tangent2 = np.cross(normal, tangent1)\n            tangent2 = tangent2 / np.linalg.norm(tangent2)\n            \n            # Create square vertices\n            half_size = square_size / 2\n            v1 = point + half_size * tangent1 + half_size * tangent2\n            v2 = point - half_size * tangent1 + half_size * tangent2\n            v3 = point - half_size * tangent1 - half_size * tangent2\n            v4 = point + half_size * tangent1 - half_size * tangent2\n            \n            square = {\n                \"id\": square_id,\n                \"center\": point.tolist(),\n                \"normal\": normal.tolist(),\n                \"vertices\": [v1.tolist(), v2.tolist(), v3.tolist(), v4.tolist()],\n                \"size\": square_size,\n                \"area\": square_size * square_size\n            }\n            \n            self.grid_squares.append(square)\n            square_id += 1\n        \n        self.grid_params = {\n            \"square_size\": square_size,\n            \"total_squares\": len(self.grid_squares),\n            \"coverage_type\": \"surface_sampled\"\n        }\n        \n        print(f\"  Created {len(self.grid_squares)} surface squares\")\n        return self.grid_squares\n    \n    def create_projection_grid(self, square_size: float = 1.0,\n                                projection_axis: str = \"z\") -> List[Dict]:\n        \"\"\"\n        Create a grid by projecting squares onto the mesh surface.\n        \n        This method:\n        1. Creates a 2D grid above/below the mesh\n        2. Projects each square down onto the mesh surface\n        3. Conforms squares to the surface topology\n        \n        Args:\n            square_size: Size of each square in mesh units\n            projection_axis: Axis to project from ('x', 'y', or 'z')\n            \n        Returns:\n            List of square dictionaries\n        \"\"\"\n        print(f\"\\nCreating projection grid with square_size={square_size}\")\n        print(f\"  Projection axis: {projection_axis}\")\n        \n        bounds = self.mesh.bounds\n        \n        # Determine grid plane based on projection axis\n        axis_map = {'x': 0, 'y': 1, 'z': 2}\n        proj_axis = axis_map.get(projection_axis.lower(), 2)\n        \n        # Other two axes for the grid\n        axes = [i for i in range(3) if i != proj_axis]\n        \n        # Create 2D grid\n        axis1_steps = np.arange(bounds[0][axes[0]], bounds[1][axes[0]] + square_size, square_size)\n        axis2_steps = np.arange(bounds[0][axes[1]], bounds[1][axes[1]] + square_size, square_size)\n        \n        # Ray casting height (above the mesh)\n        ray_height = bounds[1][proj_axis] + 10\n        ray_direction = np.zeros(3)\n        ray_direction[proj_axis] = -1  # Pointing down\n        \n        self.grid_squares = []\n        square_id = 0\n        \n        print(f\"  Grid: {len(axis1_steps)} x {len(axis2_steps)} = {len(axis1_steps) * len(axis2_steps)} potential squares\")\n        \n        for a1 in axis1_steps:\n            for a2 in axis2_steps:\n                # Create ray origin\n                ray_origin = np.zeros(3)\n                ray_origin[axes[0]] = a1 + square_size / 2\n                ray_origin[axes[1]] = a2 + square_size / 2\n                ray_origin[proj_axis] = ray_height\n                \n                # Cast ray to find intersection\n                locations, index_ray, index_tri = self.mesh.ray.intersects_location(\n                    ray_origins=[ray_origin],\n                    ray_directions=[ray_direction]\n                )\n                \n                if len(locations) > 0:\n                    # Take closest intersection\n                    hit_point = locations[0]\n                    hit_normal = self.mesh.face_normals[index_tri[0]]\n                    \n                    # Create square tangent to surface\n                    tangent1 = self._get_tangent_vector(hit_normal)\n                    tangent2 = np.cross(hit_normal, tangent1)\n                    tangent2 = tangent2 / np.linalg.norm(tangent2)\n                    \n                    half_size = square_size / 2\n                    v1 = hit_point + half_size * tangent1 + half_size * tangent2\n                    v2 = hit_point - half_size * tangent1 + half_size * tangent2\n                    v3 = hit_point - half_size * tangent1 - half_size * tangent2\n                    v4 = hit_point + half_size * tangent1 - half_size * tangent2\n                    \n                    square = {\n                        \"id\": square_id,\n                        \"center\": hit_point.tolist(),\n                        \"normal\": hit_normal.tolist(),\n                        \"vertices\": [v1.tolist(), v2.tolist(), v3.tolist(), v4.tolist()],\n                        \"size\": square_size,\n                        \"area\": square_size * square_size,\n                        \"grid_position\": [a1, a2]\n                    }\n                    \n                    self.grid_squares.append(square)\n                    square_id += 1\n        \n        self.grid_params = {\n            \"square_size\": square_size,\n            \"total_squares\": len(self.grid_squares),\n            \"projection_axis\": projection_axis,\n            \"coverage_type\": \"projection\"\n        }\n        \n        print(f\"  Created {len(self.grid_squares)} projected squares\")\n        return self.grid_squares\n    \n    def create_face_subdivision_grid(self, subdivisions: int = 2) -> List[Dict]:\n        \"\"\"\n        Create a grid by subdividing each mesh face.\n        \n        This provides complete coverage of the mesh surface.\n        \n        Args:\n            subdivisions: Number of subdivisions per face edge\n            \n        Returns:\n            List of square/quad dictionaries\n        \"\"\"\n        print(f\"\\nCreating face subdivision grid with {subdivisions} subdivisions per edge\")\n        \n        self.grid_squares = []\n        square_id = 0\n        \n        for face_idx, face in enumerate(self.mesh.faces):\n            # Get face vertices\n            v0 = self.mesh.vertices[face[0]]\n            v1 = self.mesh.vertices[face[1]]\n            v2 = self.mesh.vertices[face[2]]\n            \n            # Face normal\n            normal = self.mesh.face_normals[face_idx]\n            \n            # Subdivide the triangle into smaller triangles/quads\n            for i in range(subdivisions):\n                for j in range(subdivisions - i):\n                    # Barycentric coordinates for subdivision\n                    u0 = i / subdivisions\n                    v0_coord = j / subdivisions\n                    \n                    u1 = (i + 1) / subdivisions\n                    v1_coord = j / subdivisions\n                    \n                    u2 = i / subdivisions\n                    v2_coord = (j + 1) / subdivisions\n                    \n                    # Calculate 3D positions\n                    p0 = (1 - u0 - v0_coord) * v0 + u0 * v1 + v0_coord * v2\n                    p1 = (1 - u1 - v1_coord) * v0 + u1 * v1 + v1_coord * v2\n                    p2 = (1 - u2 - v2_coord) * v0 + u2 * v1 + v2_coord * v2\n                    \n                    center = (p0 + p1 + p2) / 3\n                    \n                    # Create a quad approximation\n                    # This is a simplified approach - for true quads, more complex logic needed\n                    square = {\n                        \"id\": square_id,\n                        \"center\": center.tolist(),\n                        \"normal\": normal.tolist(),\n                        \"vertices\": [p0.tolist(), p1.tolist(), p2.tolist()],  # Triangle\n                        \"type\": \"triangle\",\n                        \"face_index\": face_idx\n                    }\n                    \n                    self.grid_squares.append(square)\n                    square_id += 1\n        \n        self.grid_params = {\n            \"subdivisions\": subdivisions,\n            \"total_elements\": len(self.grid_squares),\n            \"coverage_type\": \"face_subdivision\"\n        }\n        \n        print(f\"  Created {len(self.grid_squares)} subdivision elements\")\n        return self.grid_squares\n    \n    def _get_tangent_vector(self, normal: np.ndarray) -> np.ndarray:\n        \"\"\"Get a tangent vector perpendicular to the normal.\"\"\"\n        # Find a vector not parallel to normal\n        if abs(normal[0]) < 0.9:\n            ref = np.array([1, 0, 0])\n        else:\n            ref = np.array([0, 1, 0])\n        \n        tangent = np.cross(normal, ref)\n        return tangent / np.linalg.norm(tangent)\n    \n    # ========================================================================\n    # MATRIX SKIN: Complete Quad Mesh Wrapping Entire Surface\n    # ========================================================================\n    \n    def create_matrix_skin(self, subdivisions: int = 2, offset: float = 0.0) -> Dict:\n        \"\"\"\n        Create a COMPLETE quad-mesh skin that wraps the ENTIRE 3D surface.\n        \n        Like The Matrix - every part of the surface is covered with a connected\n        grid of squares. The skin follows the exact shape of the 3D object.\n        \n        This converts every triangle face into quads, creating a continuous\n        quad-mesh \"coating\" over the entire object.\n        \n        Args:\n            subdivisions: How many quads per original triangle edge (higher = denser grid)\n            offset: Offset the skin outward (positive) or inward (negative) from surface\n            \n        Returns:\n            Dictionary with complete skin data\n        \"\"\"\n        print(f\"\\n{'='*60}\")\n        print(\"CREATING MATRIX SKIN (Complete Surface Wrapper)\")\n        print(f\"{'='*60}\")\n        print(f\"  Subdivisions per edge: {subdivisions}\")\n        print(f\"  Surface offset: {offset}\")\n        print(f\"  Original mesh faces (before welding): {len(self.mesh.faces)}\")\n        \n        # CRITICAL: Weld duplicate vertices first!\n        # AI-generated meshes often have duplicate vertices at same positions\n        # This breaks adjacency detection since edges use vertex INDICES\n        print(f\"\\n  Welding duplicate vertices...\")\n        original_verts = len(self.mesh.vertices)\n        \n        # Merge vertices that are at the same position (within tolerance)\n        self.mesh.merge_vertices(merge_tex=True, merge_norm=True)\n        # Also fix up the mesh\n        self.mesh.fix_normals()\n        \n        new_verts = len(self.mesh.vertices)\n        print(f\"  Vertices: {original_verts:,} → {new_verts:,} (removed {original_verts - new_verts:,} duplicates)\")\n        print(f\"  Faces after cleanup: {len(self.mesh.faces):,}\")\n        \n        import sys\n        \n        # CONNECTED 2D SHEET: Vertices must be shared between adjacent quads\n        # We use the original mesh vertices + edge midpoints + face centers\n        # Key: adjacent triangles share edges, so they share edge midpoints\n        \n        faces = self.mesh.faces\n        vertices = self.mesh.vertices\n        normals = self.mesh.vertex_normals  # Use vertex normals for smooth offset\n        \n        num_faces = len(faces)\n        num_verts = len(vertices)\n        \n        print(f\"\\n  Creating CONNECTED 2D sheet (shared vertices)...\")\n        print(f\"  Original vertices: {num_verts:,}\")\n        print(f\"  Original faces: {num_faces:,}\")\n        sys.stdout.flush()\n        \n        # Step 1: Collect all unique edges and create edge midpoints\n        # Edge key = sorted tuple of vertex indices\n        print(f\"  Step 1: Finding unique edges...\")\n        sys.stdout.flush()\n        \n        edge_to_midpoint_idx = {}  # edge_key -> midpoint vertex index\n        midpoint_positions = []\n        \n        for face_idx, face in enumerate(faces):\n            if face_idx % 200000 == 0:\n                print(f\"    Face {face_idx:,}/{num_faces:,} ({100*face_idx/num_faces:.0f}%)\")\n                sys.stdout.flush()\n            \n            for i in range(3):\n                v_i = face[i]\n                v_j = face[(i + 1) % 3]\n                edge_key = tuple(sorted([v_i, v_j]))\n                \n                if edge_key not in edge_to_midpoint_idx:\n                    # Create midpoint for this edge\n                    midpoint = (vertices[v_i] + vertices[v_j]) / 2\n                    edge_to_midpoint_idx[edge_key] = len(midpoint_positions) + num_verts\n                    midpoint_positions.append(midpoint)\n        \n        num_midpoints = len(midpoint_positions)\n        print(f\"  Found {num_midpoints:,} unique edges (midpoints)\")\n        sys.stdout.flush()\n        \n        # Step 2: Create face centers\n        print(f\"  Step 2: Creating face centers...\")\n        sys.stdout.flush()\n        \n        v0 = vertices[faces[:, 0]]\n        v1 = vertices[faces[:, 1]]\n        v2 = vertices[faces[:, 2]]\n        face_centers = (v0 + v1 + v2) / 3  # (N, 3)\n        \n        # Step 3: Build final vertex array\n        # Layout: [original_vertices, edge_midpoints, face_centers]\n        print(f\"  Step 3: Building vertex array...\")\n        sys.stdout.flush()\n        \n        all_vertices = np.vstack([\n            vertices,                          # indices 0 to num_verts-1\n            np.array(midpoint_positions),      # indices num_verts to num_verts+num_midpoints-1\n            face_centers                       # indices num_verts+num_midpoints to end\n        ])\n        \n        # Apply offset if needed\n        if offset != 0:\n            # Compute vertex normals for all points\n            all_normals = np.zeros_like(all_vertices)\n            # Original vertices use mesh vertex normals\n            all_normals[:num_verts] = normals\n            # Midpoints and centers: interpolate from nearby vertices\n            for edge_key, mid_idx in edge_to_midpoint_idx.items():\n                v_i, v_j = edge_key\n                all_normals[mid_idx] = (normals[v_i] + normals[v_j]) / 2\n                n = np.linalg.norm(all_normals[mid_idx])\n                if n > 0:\n                    all_normals[mid_idx] /= n\n            # Face centers\n            for face_idx in range(num_faces):\n                center_idx = num_verts + num_midpoints + face_idx\n                face = faces[face_idx]\n                all_normals[center_idx] = (normals[face[0]] + normals[face[1]] + normals[face[2]]) / 3\n                n = np.linalg.norm(all_normals[center_idx])\n                if n > 0:\n                    all_normals[center_idx] /= n\n            \n            all_vertices = all_vertices + all_normals * offset\n        \n        # Step 4: Create quad faces (3 quads per original triangle)\n        print(f\"  Step 4: Creating connected quads...\")\n        sys.stdout.flush()\n        \n        all_quads = []\n        face_center_base = num_verts + num_midpoints\n        skipped_degenerate = 0\n        \n        for face_idx, face in enumerate(faces):\n            if face_idx % 200000 == 0:\n                print(f\"    Face {face_idx:,}/{num_faces:,} ({100*face_idx/num_faces:.0f}%)\")\n                sys.stdout.flush()\n            \n            v0_idx = face[0]\n            v1_idx = face[1]\n            v2_idx = face[2]\n            \n            # Skip degenerate triangles (triangles with duplicate vertices)\n            if v0_idx == v1_idx or v1_idx == v2_idx or v2_idx == v0_idx:\n                skipped_degenerate += 1\n                continue\n            \n            # Get midpoint indices (these are SHARED across adjacent triangles!)\n            edge01 = tuple(sorted([v0_idx, v1_idx]))\n            edge12 = tuple(sorted([v1_idx, v2_idx]))\n            edge20 = tuple(sorted([v2_idx, v0_idx]))\n            \n            m01_idx = edge_to_midpoint_idx[edge01]\n            m12_idx = edge_to_midpoint_idx[edge12]\n            m20_idx = edge_to_midpoint_idx[edge20]\n            \n            center_idx = face_center_base + face_idx\n            \n            # Create 3 quads for this triangle\n            # Quad 1: v0 -> m01 -> center -> m20\n            all_quads.append([v0_idx, m01_idx, center_idx, m20_idx])\n            # Quad 2: m01 -> v1 -> m12 -> center\n            all_quads.append([m01_idx, v1_idx, m12_idx, center_idx])\n            # Quad 3: m20 -> center -> m12 -> v2\n            all_quads.append([m20_idx, center_idx, m12_idx, v2_idx])\n        \n        # Store as class data\n        self.skin_vertices = all_vertices\n        self.skin_quads = all_quads\n        \n        # Also store in quad_patches format for compatibility\n        self.shared_vertices = {i: all_vertices[i] for i in range(len(all_vertices))}\n        self.quad_patches = [(q, list(q)) for q in all_quads]\n        \n        total_verts = len(all_vertices)\n        total_quads = len(all_quads)\n        \n        print(f\"\\n  ✓ CONNECTED Matrix skin created!\")\n        print(f\"    - Total unique vertices: {total_verts:,}\")\n        print(f\"    - Quad faces: {total_quads:,}\")\n        if skipped_degenerate > 0:\n            print(f\"    - Skipped {skipped_degenerate:,} degenerate triangles\")\n        print(f\"    - Adjacent quads now SHARE edges (truly connected 2D sheet)\")\n        sys.stdout.flush()\n        \n        return {\n            \"vertices\": total_verts,\n            \"faces\": total_quads,\n            \"quad_count\": total_quads,\n            \"tri_count\": 0,\n            \"num_quads\": total_quads  # Add this for compatibility\n        }\n    \n    # ========================================================================\n    # SOLIDIFY: Convert surface skin to watertight solid shell\n    # ========================================================================\n    \n    def solidify_skin(self, thickness: float = 0.5, direction: str = \"inward\") -> Dict:\n        \"\"\"\n        Convert the matrix skin (surface) into a watertight solid shell.\n        \n        This extrudes the surface by the specified thickness to create\n        actual 3D geometry that CAD software and 3D printers can use.\n        \n        The result is a proper manifold mesh with:\n        - Outer surface (original skin)\n        - Inner surface (offset by thickness)\n        - Side walls connecting the two at boundaries\n        \n        Args:\n            thickness: Shell wall thickness in mesh units (e.g., 0.8 mm)\n            direction: \"inward\" (shell goes inside), \"outward\" (shell goes outside),\n                      or \"both\" (half thickness each way)\n                      \n        Returns:\n            Dictionary with solidified mesh stats\n        \"\"\"\n        print(f\"\\n{'='*60}\")\n        print(\"SOLIDIFYING MATRIX SKIN (Creating Watertight Shell)\")\n        print(f\"{'='*60}\")\n        print(f\"  Shell thickness: {thickness}\")\n        print(f\"  Direction: {direction}\")\n        import sys\n        sys.stdout.flush()\n        \n        if not hasattr(self, 'skin_vertices') or not hasattr(self, 'skin_quads'):\n            print(\"  ERROR: No matrix skin. Run create_matrix_skin() first.\")\n            return None\n        \n        vertices = self.skin_vertices\n        quads = self.skin_quads\n        num_verts = len(vertices)\n        num_quads = len(quads)\n        \n        print(f\"  Input: {num_verts:,} vertices, {num_quads:,} quads\")\n        sys.stdout.flush()\n        \n        # Step 1: Calculate vertex normals for offset direction\n        print(f\"  Step 1: Computing vertex normals...\")\n        sys.stdout.flush()\n        \n        # Create trimesh from quads to compute normals\n        # First convert quads to triangles for trimesh\n        triangles = []\n        for q in quads:\n            # Quad [v0, v1, v2, v3] -> two triangles\n            triangles.append([q[0], q[1], q[2]])\n            triangles.append([q[0], q[2], q[3]])\n        \n        temp_mesh = trimesh.Trimesh(vertices=vertices, faces=triangles)\n        vertex_normals = temp_mesh.vertex_normals\n        \n        # Step 2: Create offset vertices (inner surface)\n        print(f\"  Step 2: Creating offset surface...\")\n        sys.stdout.flush()\n        \n        if direction == \"inward\":\n            offset_verts = vertices - vertex_normals * thickness\n            outer_verts = vertices.copy()\n        elif direction == \"outward\":\n            offset_verts = vertices + vertex_normals * thickness\n            outer_verts = vertices.copy()\n        else:  # both\n            half = thickness / 2\n            outer_verts = vertices + vertex_normals * half\n            offset_verts = vertices - vertex_normals * half\n        \n        # Step 3: Build solid mesh with both surfaces\n        print(f\"  Step 3: Building solid shell geometry...\")\n        sys.stdout.flush()\n        \n        # Combined vertices: [outer_surface, inner_surface]\n        solid_vertices = np.vstack([outer_verts, offset_verts])\n        \n        solid_faces = []\n        \n        # Outer surface faces (original orientation) - as triangles\n        for q in quads:\n            # Quad -> 2 triangles (CCW for outward normal)\n            solid_faces.append([q[0], q[1], q[2]])\n            solid_faces.append([q[0], q[2], q[3]])\n        \n        # Inner surface faces (reversed orientation - flipped winding)\n        # Inner vertices are at index + num_verts\n        for q in quads:\n            # Reversed winding for inward-facing normal\n            i0, i1, i2, i3 = q[0] + num_verts, q[1] + num_verts, q[2] + num_verts, q[3] + num_verts\n            solid_faces.append([i0, i2, i1])  # Reversed\n            solid_faces.append([i0, i3, i2])  # Reversed\n        \n        # Step 4: Find and seal boundary edges\n        print(f\"  Step 4: Finding boundary edges to seal...\")\n        sys.stdout.flush()\n        \n        # Count edge occurrences to find boundaries\n        edge_count = {}\n        for q in quads:\n            for i in range(4):\n                v1, v2 = q[i], q[(i + 1) % 4]\n                edge = tuple(sorted([v1, v2]))\n                edge_count[edge] = edge_count.get(edge, 0) + 1\n        \n        # Boundary edges appear only once\n        boundary_edges = [e for e, count in edge_count.items() if count == 1]\n        print(f\"    Found {len(boundary_edges):,} boundary edges\")\n        sys.stdout.flush()\n        \n        # Seal each boundary edge with a quad (connecting outer to inner)\n        for edge in boundary_edges:\n            v1_out, v2_out = edge\n            v1_in, v2_in = v1_out + num_verts, v2_out + num_verts\n            # Create quad to connect outer edge to inner edge\n            # Two triangles forming a quad wall\n            solid_faces.append([v1_out, v2_out, v2_in])\n            solid_faces.append([v1_out, v2_in, v1_in])\n        \n        # Step 5: Create final solid mesh\n        print(f\"  Step 5: Creating watertight mesh...\")\n        sys.stdout.flush()\n        \n        solid_mesh = trimesh.Trimesh(\n            vertices=solid_vertices,\n            faces=solid_faces\n        )\n        \n        # Clean up the mesh\n        solid_mesh.merge_vertices()\n        solid_mesh.fix_normals()\n        solid_mesh.fill_holes()\n        \n        # Store the solidified mesh\n        self.solid_mesh = solid_mesh\n        self.solid_thickness = thickness\n        \n        # Check if watertight\n        is_watertight = solid_mesh.is_watertight\n        volume = solid_mesh.volume if is_watertight else None\n        \n        print(f\"\\n  ✓ SOLIDIFIED SHELL CREATED!\")\n        print(f\"    - Vertices: {len(solid_mesh.vertices):,}\")\n        print(f\"    - Faces (triangles): {len(solid_mesh.faces):,}\")\n        print(f\"    - Watertight: {'✓ YES' if is_watertight else '✗ NO'}\")\n        if volume:\n            print(f\"    - Volume: {volume:.4f} cubic units\")\n        print(f\"    - Shell thickness: {thickness}\")\n        sys.stdout.flush()\n        \n        return {\n            \"vertices\": len(solid_mesh.vertices),\n            \"faces\": len(solid_mesh.faces),\n            \"watertight\": is_watertight,\n            \"volume\": volume,\n            \"thickness\": thickness,\n            \"boundary_edges_sealed\": len(boundary_edges)\n        }\n    \n    def export_solid_mesh(self, output_path: str) -> str:\n        \"\"\"\n        Export the solidified mesh to a file.\n        \n        Args:\n            output_path: Output file path (supports .obj, .stl, .glb, .ply)\n            \n        Returns:\n            Path to exported file\n        \"\"\"\n        if not hasattr(self, 'solid_mesh'):\n            print(\"ERROR: No solid mesh. Run solidify_skin() first.\")\n            return None\n        \n        output_path = Path(output_path)\n        \n        # Ensure directory exists\n        output_path.parent.mkdir(parents=True, exist_ok=True)\n        \n        # Export based on extension\n        ext = output_path.suffix.lower()\n        \n        self.solid_mesh.export(str(output_path))\n        \n        print(f\"✓ Exported solid mesh: {output_path}\")\n        print(f\"  Format: {ext}\")\n        print(f\"  Watertight: {self.solid_mesh.is_watertight}\")\n        \n        return str(output_path)\n    \n    # ========================================================================\n    # ANGULAR GROUPING: Group quads by surface continuity (180° threshold)\n    # ========================================================================\n    \n    def group_quads_by_angle(self, angle_threshold: float = 180.0) -> Dict:\n        \"\"\"\n        Group matrix skin quads based on angular relationship with neighbors.\n        \n        ALGORITHM:\n        1. Calculate normal vector for each quad\n        2. Build adjacency graph (quads sharing edges)\n        3. Flood-fill grouping: \n           - Start with ungrouped quad\n           - Add neighbors if angle between normals < threshold\n           - When neighbor exceeds threshold, it starts a new group\n        4. Repeat until all quads are grouped\n        \n        The 180° threshold means: if two adjacent quads face opposite directions\n        (like front vs back of object), they belong to different groups.\n        \n        Args:\n            angle_threshold: Maximum angle (degrees) between adjacent quad normals\n                            to be in same group. 180 = only split at sharp folds\n                            90 = split at perpendicular surfaces\n                            \n        Returns:\n            Dictionary with group info:\n            {\n                \"groups\": {group_id: [quad_indices]},\n                \"quad_to_group\": {quad_idx: group_id},\n                \"group_normals\": {group_id: average_normal},\n                \"group_colors\": {group_id: (r,g,b,a)}\n            }\n        \"\"\"\n        print(f\"\\n{'='*60}\")\n        print(\"GROUPING QUADS BY ANGULAR CONTINUITY\")\n        print(f\"{'='*60}\")\n        print(f\"  Angle threshold: {angle_threshold}°\")\n        print(f\"  (Neighbors within {angle_threshold}° stay in same group)\")\n        import sys\n        sys.stdout.flush()\n        \n        if not hasattr(self, 'skin_vertices') or not hasattr(self, 'skin_quads'):\n            print(\"  ERROR: No matrix skin. Run create_matrix_skin() first.\")\n            return None\n        \n        num_quads = len(self.skin_quads)\n        vertices = self.skin_vertices\n        quads = self.skin_quads\n        \n        # Step 1: Calculate normal for each quad\n        print(f\"  Step 1: Calculating normals for {num_quads:,} quads...\")\n        sys.stdout.flush()\n        \n        quad_normals = []\n        quad_centers = []\n        \n        for quad_idx, quad in enumerate(quads):\n            if quad_idx % 100000 == 0 and quad_idx > 0:\n                print(f\"    Processing {quad_idx:,}/{num_quads:,}\")\n                sys.stdout.flush()\n            \n            # Get quad vertices\n            v0 = vertices[quad[0]]\n            v1 = vertices[quad[1]]\n            v2 = vertices[quad[2]]\n            v3 = vertices[quad[3]] if len(quad) > 3 else vertices[quad[2]]\n            \n            # Calculate center\n            center = (v0 + v1 + v2 + v3) / 4\n            quad_centers.append(center)\n            \n            # Calculate normal using cross product of diagonals\n            diag1 = v2 - v0\n            diag2 = v3 - v1\n            normal = np.cross(diag1, diag2)\n            norm_length = np.linalg.norm(normal)\n            if norm_length > 1e-10:\n                normal = normal / norm_length\n            else:\n                normal = np.array([0, 0, 1])\n            \n            quad_normals.append(normal)\n        \n        quad_normals = np.array(quad_normals)\n        quad_centers = np.array(quad_centers)\n        \n        # Step 2: Build adjacency graph (quads sharing edges)\n        print(f\"  Step 2: Building adjacency graph...\")\n        sys.stdout.flush()\n        \n        # Create edge -> quads mapping\n        edge_to_quads = defaultdict(list)\n        \n        for quad_idx, quad in enumerate(quads):\n            if quad_idx % 100000 == 0 and quad_idx > 0:\n                print(f\"    Processing {quad_idx:,}/{num_quads:,}\")\n                sys.stdout.flush()\n            \n            num_verts = len(quad)\n            for i in range(num_verts):\n                j = (i + 1) % num_verts\n                edge = tuple(sorted([quad[i], quad[j]]))\n                edge_to_quads[edge].append(quad_idx)\n        \n        # Build adjacency list\n        quad_neighbors = defaultdict(set)\n        for edge, quad_list in edge_to_quads.items():\n            if len(quad_list) == 2:\n                q1, q2 = quad_list\n                quad_neighbors[q1].add(q2)\n                quad_neighbors[q2].add(q1)\n        \n        avg_neighbors = sum(len(n) for n in quad_neighbors.values()) / num_quads if num_quads > 0 else 0\n        print(f\"    Average neighbors per quad: {avg_neighbors:.1f}\")\n        \n        # Step 3: Flood-fill grouping based on angle threshold\n        print(f\"  Step 3: Flood-fill grouping (threshold={angle_threshold}°)...\")\n        sys.stdout.flush()\n        \n        # Convert angle to cosine threshold (cos(180°) = -1, cos(90°) = 0, cos(0°) = 1)\n        angle_rad = np.radians(angle_threshold)\n        cos_threshold = np.cos(angle_rad)\n        \n        groups = {}  # group_id -> list of quad indices\n        quad_to_group = {}  # quad_idx -> group_id\n        ungrouped = set(range(num_quads))\n        current_group = 0\n        \n        while ungrouped:\n            # Start new group with an ungrouped quad\n            seed_quad = next(iter(ungrouped))\n            groups[current_group] = []\n            \n            # BFS flood fill\n            queue = [seed_quad]\n            \n            while queue:\n                quad_idx = queue.pop(0)\n                \n                if quad_idx not in ungrouped:\n                    continue\n                \n                # Add to current group\n                groups[current_group].append(quad_idx)\n                quad_to_group[quad_idx] = current_group\n                ungrouped.remove(quad_idx)\n                \n                # Check neighbors\n                for neighbor_idx in quad_neighbors[quad_idx]:\n                    if neighbor_idx not in ungrouped:\n                        continue\n                    \n                    # Calculate angle between normals\n                    n1 = quad_normals[quad_idx]\n                    n2 = quad_normals[neighbor_idx]\n                    dot_product = np.dot(n1, n2)\n                    \n                    # Clamp to [-1, 1] for numerical stability\n                    dot_product = np.clip(dot_product, -1.0, 1.0)\n                    \n                    # If angle is within threshold, add to same group\n                    # dot > cos_threshold means angle < threshold\n                    if dot_product >= cos_threshold:\n                        queue.append(neighbor_idx)\n            \n            current_group += 1\n            \n            if current_group % 10 == 0:\n                print(f\"    Groups created: {current_group}, Remaining: {len(ungrouped):,}\")\n                sys.stdout.flush()\n        \n        # Step 4: Calculate group statistics\n        print(f\"\\n  Step 4: Calculating group statistics...\")\n        sys.stdout.flush()\n        \n        group_normals = {}\n        group_colors = {}\n        \n        # Generate distinct colors for groups\n        color_palette = [\n            (255, 100, 100, 255),   # Red\n            (100, 255, 100, 255),   # Green\n            (100, 100, 255, 255),   # Blue\n            (255, 255, 100, 255),   # Yellow\n            (255, 100, 255, 255),   # Magenta\n            (100, 255, 255, 255),   # Cyan\n            (255, 180, 100, 255),   # Orange\n            (180, 100, 255, 255),   # Purple\n            (100, 180, 100, 255),   # Dark Green\n            (180, 180, 255, 255),   # Light Blue\n            (255, 180, 180, 255),   # Pink\n            (180, 255, 180, 255),   # Light Green\n        ]\n        \n        for group_id, quad_list in groups.items():\n            # Average normal for group\n            group_normal = np.mean(quad_normals[quad_list], axis=0)\n            norm_len = np.linalg.norm(group_normal)\n            if norm_len > 0:\n                group_normal = group_normal / norm_len\n            group_normals[group_id] = group_normal.tolist()\n            \n            # Assign color\n            group_colors[group_id] = color_palette[group_id % len(color_palette)]\n        \n        # Store results\n        self.quad_groups = groups\n        self.quad_to_group = quad_to_group\n        self.group_normals = group_normals\n        self.group_colors = group_colors\n        self.quad_normals = quad_normals\n        self.quad_centers = quad_centers\n        \n        # Print summary\n        print(f\"\\n  ✓ ANGULAR GROUPING COMPLETE!\")\n        print(f\"    - Total groups created: {len(groups)}\")\n        print(f\"    - Angle threshold: {angle_threshold}°\")\n        print(f\"\\n    Group breakdown:\")\n        \n        sorted_groups = sorted(groups.items(), key=lambda x: len(x[1]), reverse=True)\n        for group_id, quad_list in sorted_groups[:10]:  # Show top 10\n            pct = 100 * len(quad_list) / num_quads\n            avg_normal = group_normals[group_id]\n            print(f\"      Group {group_id}: {len(quad_list):,} quads ({pct:.1f}%) - Normal: [{avg_normal[0]:.2f}, {avg_normal[1]:.2f}, {avg_normal[2]:.2f}]\")\n        \n        if len(groups) > 10:\n            print(f\"      ... and {len(groups) - 10} more groups\")\n        \n        sys.stdout.flush()\n        \n        return {\n            \"groups\": groups,\n            \"quad_to_group\": quad_to_group,\n            \"group_normals\": group_normals,\n            \"group_colors\": group_colors,\n            \"num_groups\": len(groups),\n            \"angle_threshold\": angle_threshold\n        }\n    \n    def group_quads_by_normal_direction(self, num_groups: int = 6) -> Dict:\n        \"\"\"\n        Group quads by their NORMAL DIRECTION using clustering.\n        \n        Unlike group_quads_by_angle (which only splits at sharp edges),\n        this method groups ALL quads facing similar directions together,\n        even if they're not adjacent.\n        \n        For a ring, this creates groups like:\n        - Quads facing UP (top of ring)\n        - Quads facing DOWN (bottom)\n        - Quads facing OUTWARD (outer surface)\n        - Quads facing INWARD (inner hole)\n        - Quads facing LEFT/RIGHT (sides)\n        \n        Args:\n            num_groups: Target number of direction groups (default 6 for +/- X,Y,Z)\n            \n        Returns:\n            Dictionary with group info\n        \"\"\"\n        print(f\"\\n{'='*60}\")\n        print(\"GROUPING QUADS BY NORMAL DIRECTION (Clustering)\")\n        print(f\"{'='*60}\")\n        print(f\"  Target groups: {num_groups}\")\n        import sys\n        sys.stdout.flush()\n        \n        if not hasattr(self, 'skin_vertices') or not hasattr(self, 'skin_quads'):\n            print(\"  ERROR: No matrix skin. Run create_matrix_skin() first.\")\n            return None\n        \n        num_quads = len(self.skin_quads)\n        vertices = self.skin_vertices\n        quads = self.skin_quads\n        \n        # Step 1: Calculate normal for each quad\n        print(f\"  Step 1: Calculating normals for {num_quads:,} quads...\")\n        sys.stdout.flush()\n        \n        quad_normals = []\n        for quad_idx, quad in enumerate(quads):\n            v0 = vertices[quad[0]]\n            v1 = vertices[quad[1]]\n            v2 = vertices[quad[2]]\n            v3 = vertices[quad[3]] if len(quad) > 3 else vertices[quad[2]]\n            \n            diag1 = v2 - v0\n            diag2 = v3 - v1\n            normal = np.cross(diag1, diag2)\n            norm_len = np.linalg.norm(normal)\n            if norm_len > 0:\n                normal = normal / norm_len\n            quad_normals.append(normal)\n        \n        quad_normals = np.array(quad_normals)\n        print(f\"    Calculated {len(quad_normals):,} normals\")\n        \n        # Step 2: Cluster normals using K-means\n        print(f\"  Step 2: Clustering into {num_groups} direction groups...\")\n        sys.stdout.flush()\n        \n        if HAS_SKLEARN:\n            from sklearn.cluster import KMeans\n            kmeans = KMeans(n_clusters=num_groups, random_state=42, n_init=10)\n            labels = kmeans.fit_predict(quad_normals)\n            cluster_centers = kmeans.cluster_centers_\n        else:\n            # Fallback: simple axis-based grouping\n            print(\"    (sklearn not available, using axis-based grouping)\")\n            labels = np.zeros(num_quads, dtype=int)\n            # Assign based on dominant axis\n            abs_normals = np.abs(quad_normals)\n            dominant_axis = np.argmax(abs_normals, axis=1)  # 0=X, 1=Y, 2=Z\n            signs = np.sign(quad_normals[np.arange(num_quads), dominant_axis])\n            labels = dominant_axis * 2 + (signs > 0).astype(int)  # 0-5 for +/-X, +/-Y, +/-Z\n            cluster_centers = np.array([\n                [1, 0, 0], [-1, 0, 0],  # +X, -X\n                [0, 1, 0], [0, -1, 0],  # +Y, -Y\n                [0, 0, 1], [0, 0, -1],  # +Z, -Z\n            ])\n        \n        # Step 3: Build groups from labels\n        print(f\"  Step 3: Building groups...\")\n        sys.stdout.flush()\n        \n        groups = {}\n        for quad_idx, label in enumerate(labels):\n            label = int(label)\n            if label not in groups:\n                groups[label] = []\n            groups[label].append(quad_idx)\n        \n        # Build quad_to_group mapping\n        quad_to_group = {i: int(labels[i]) for i in range(num_quads)}\n        \n        # Calculate group normals and colors\n        group_normals = {}\n        group_colors = {}\n        color_palette = [\n            (255, 100, 100, 255),   # Red (+X)\n            (100, 255, 100, 255),   # Green (-X)\n            (100, 100, 255, 255),   # Blue (+Y)\n            (255, 255, 100, 255),   # Yellow (-Y)\n            (255, 100, 255, 255),   # Magenta (+Z)\n            (100, 255, 255, 255),   # Cyan (-Z)\n            (255, 180, 100, 255),   # Orange\n            (180, 100, 255, 255),   # Purple\n        ]\n        \n        for group_id, quad_list in groups.items():\n            avg_normal = np.mean(quad_normals[quad_list], axis=0)\n            norm_len = np.linalg.norm(avg_normal)\n            if norm_len > 0:\n                avg_normal = avg_normal / norm_len\n            group_normals[group_id] = avg_normal.tolist()\n            group_colors[group_id] = color_palette[group_id % len(color_palette)]\n        \n        # Store results\n        self.quad_groups = groups\n        self.quad_to_group = quad_to_group\n        self.group_normals = group_normals\n        self.group_colors = group_colors\n        self.quad_normals = quad_normals\n        \n        # Print summary\n        print(f\"\\n  ✓ DIRECTION GROUPING COMPLETE!\")\n        print(f\"    - Total groups: {len(groups)}\")\n        \n        # Name the groups by direction\n        direction_names = {\n            0: \"+X (Right)\", 1: \"-X (Left)\",\n            2: \"+Y (Up)\", 3: \"-Y (Down)\",\n            4: \"+Z (Front)\", 5: \"-Z (Back)\"\n        }\n        \n        print(f\"\\n    Group breakdown:\")\n        sorted_groups = sorted(groups.items(), key=lambda x: len(x[1]), reverse=True)\n        for group_id, quad_list in sorted_groups:\n            pct = 100 * len(quad_list) / num_quads\n            avg_normal = group_normals[group_id]\n            name = direction_names.get(group_id, f\"Group {group_id}\")\n            print(f\"      {name}: {len(quad_list):,} quads ({pct:.1f}%) - Normal: [{avg_normal[0]:.2f}, {avg_normal[1]:.2f}, {avg_normal[2]:.2f}]\")\n        \n        sys.stdout.flush()\n        \n        return {\n            \"groups\": groups,\n            \"quad_to_group\": quad_to_group,\n            \"group_normals\": group_normals,\n            \"group_colors\": group_colors,\n            \"num_groups\": len(groups)\n        }\n    \n    def export_grouped_matrix_skin(self, output_path: str) -> Dict[str, str]:\n        \"\"\"\n        Export matrix skin as a SINGLE Rhino .3dm file with groups as LAYERS.\n        \n        Each angular group becomes a separate layer in the Rhino file,\n        allowing CAD designers to:\n        - Toggle visibility of surface regions\n        - Select entire regions by layer\n        - Apply different materials/colors per layer\n        - Edit regions independently\n        \n        Args:\n            output_path: Path for .3dm file (will change extension if needed)\n            \n        Returns:\n            Dictionary with file paths\n        \"\"\"\n        print(f\"\\n{'='*60}\")\n        print(\"EXPORTING GROUPED MATRIX SKIN TO RHINO (.3dm)\")\n        print(f\"{'='*60}\")\n        import sys\n        sys.stdout.flush()\n        \n        if not hasattr(self, 'quad_groups'):\n            print(\"  ERROR: No groups created. Run group_quads_by_angle() first.\")\n            return None\n        \n        vertices = self.skin_vertices\n        quads = self.skin_quads\n        groups = self.quad_groups\n        group_colors = self.group_colors\n        group_normals = self.group_normals\n        \n        output_files = {}\n        base_name = Path(output_path).stem\n        output_dir = Path(output_path).parent\n        \n        # Ensure .3dm extension\n        rhino_path = output_dir / f\"{base_name}_grouped.3dm\"\n        \n        if not HAS_RHINO3DM:\n            print(\"  WARNING: rhino3dm not installed. Falling back to single OBJ with groups.\")\n            print(\"  Install with: pip install rhino3dm\")\n            \n            # Fallback to OBJ with group markers\n            obj_path = output_dir / f\"{base_name}_grouped.obj\"\n            \n            with open(obj_path, 'w') as f:\n                f.write(\"# GROUPED MATRIX SKIN\\n\")\n                f.write(f\"# Groups: {len(groups)} (import as separate objects in Rhino)\\n\")\n                f.write(\"# Each 'o' command = separate layer when imported\\n\\n\")\n                \n                # Write all vertices\n                for v in vertices:\n                    f.write(f\"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}\\n\")\n                \n                # Write faces by group with object markers\n                for group_id, quad_indices in sorted(groups.items()):\n                    color = group_colors.get(group_id, (128, 128, 128, 255))\n                    normal = group_normals.get(group_id, [0, 0, 1])\n                    f.write(f\"\\n# Group {group_id}: {len(quad_indices)} quads\\n\")\n                    f.write(f\"# Average normal: [{normal[0]:.2f}, {normal[1]:.2f}, {normal[2]:.2f}]\\n\")\n                    f.write(f\"o Layer_{group_id}\\n\")\n                    \n                    for qi in quad_indices:\n                        face = quads[qi]\n                        indices = [str(vi + 1) for vi in face]\n                        f.write(f\"f {' '.join(indices)}\\n\")\n            \n            output_files['grouped_obj'] = str(obj_path)\n            print(f\"    ✓ Exported OBJ with groups: {obj_path}\")\n            print(f\"    → Import in Rhino: File > Import, check 'Map OBJ objects to layers'\")\n        \n        else:\n            # Create proper Rhino .3dm file with layers\n            print(f\"  Creating Rhino file with {len(groups)} layers...\")\n            \n            model = rhino3dm.File3dm()\n            \n            # Create parent layer for all groups\n            parent_layer = rhino3dm.Layer()\n            parent_layer.Name = \"Matrix_Skin_Groups\"\n            parent_layer.Color = (200, 200, 200, 255)\n            parent_layer_idx = model.Layers.Add(parent_layer)\n            parent_layer_id = model.Layers[parent_layer_idx].Id\n            \n            # Create a layer for each group\n            layer_indices = {}\n            \n            # Sort groups by size (largest first) for consistent naming\n            sorted_group_ids = sorted(groups.keys(), key=lambda g: len(groups[g]), reverse=True)\n            \n            # Name groups based on dominant normal direction\n            for rank, group_id in enumerate(sorted_group_ids):\n                normal = group_normals.get(group_id, [0, 0, 1])\n                color = group_colors.get(group_id, (128, 128, 128, 255))\n                quad_count = len(groups[group_id])\n                \n                # Auto-name based on normal direction\n                abs_n = [abs(n) for n in normal]\n                max_axis = abs_n.index(max(abs_n))\n                \n                if max_axis == 2:  # Z dominant\n                    name = \"Top\" if normal[2] > 0 else \"Bottom\"\n                elif max_axis == 1:  # Y dominant\n                    name = \"Front\" if normal[1] > 0 else \"Back\"\n                else:  # X dominant\n                    name = \"Right\" if normal[0] > 0 else \"Left\"\n                \n                layer_name = f\"{name}_{group_id}_{quad_count}quads\"\n                \n                layer = rhino3dm.Layer()\n                layer.Name = layer_name\n                layer.Color = color\n                layer.ParentLayerId = parent_layer_id\n                layer_idx = model.Layers.Add(layer)\n                layer_indices[group_id] = layer_idx\n                \n                print(f\"    Layer: {layer_name} - {quad_count:,} quads\")\n            \n            # Add mesh geometry to each layer\n            print(f\"\\n  Adding mesh geometry to layers...\")\n            sys.stdout.flush()\n            \n            for group_id, quad_indices in groups.items():\n                if not quad_indices:\n                    continue\n                \n                # Create a mesh for this group\n                group_mesh = rhino3dm.Mesh()\n                \n                # Collect vertices used by this group and create remapping\n                used_vertices = set()\n                for qi in quad_indices:\n                    for vi in quads[qi]:\n                        used_vertices.add(vi)\n                \n                # Add vertices with remapping\n                old_to_new = {}\n                for new_idx, old_idx in enumerate(sorted(used_vertices)):\n                    v = vertices[old_idx]\n                    group_mesh.Vertices.Add(float(v[0]), float(v[1]), float(v[2]))\n                    old_to_new[old_idx] = new_idx\n                \n                # Add faces (quads as two triangles or as quads if supported)\n                for qi in quad_indices:\n                    face = quads[qi]\n                    remapped = [old_to_new[vi] for vi in face]\n                    \n                    if len(remapped) == 4:\n                        # Add as quad\n                        group_mesh.Faces.AddFace(remapped[0], remapped[1], remapped[2], remapped[3])\n                    elif len(remapped) == 3:\n                        # Add as triangle\n                        group_mesh.Faces.AddFace(remapped[0], remapped[1], remapped[2])\n                \n                # Compute normals\n                group_mesh.Normals.ComputeNormals()\n                \n                # Add to model with layer assignment\n                attr = rhino3dm.ObjectAttributes()\n                attr.LayerIndex = layer_indices[group_id]\n                attr.Name = f\"Group_{group_id}\"\n                \n                model.Objects.AddMesh(group_mesh, attr)\n            \n            # Save the file\n            model.Write(str(rhino_path), version=7)\n            \n            output_files['grouped_3dm'] = str(rhino_path)\n            print(f\"\\n    ✓ Exported Rhino file: {rhino_path}\")\n            print(f\"    → Open in Rhino 7/8 to see layers panel\")\n        \n        # Also export group metadata as JSON\n        metadata_path = output_dir / f\"{base_name}_groups.json\"\n        metadata = {\n            \"total_groups\": len(groups),\n            \"angle_threshold\": getattr(self, 'angle_threshold', 180),\n            \"rhino_file\": str(rhino_path) if HAS_RHINO3DM else None,\n            \"groups\": {\n                str(gid): {\n                    \"quad_count\": len(qlist),\n                    \"average_normal\": group_normals.get(gid, [0, 0, 1]),\n                    \"color_rgba\": list(group_colors.get(gid, (128, 128, 128, 255))),\n                    \"layer_name\": f\"Group_{gid}\"\n                }\n                for gid, qlist in groups.items()\n            }\n        }\n        \n        with open(metadata_path, 'w') as f:\n            json.dump(metadata, f, indent=2)\n        \n        output_files['metadata'] = str(metadata_path)\n        print(f\"    ✓ Metadata: {metadata_path}\")\n        \n        sys.stdout.flush()\n        return output_files\n\n    def export_matrix_skin(self, output_path: str, shell_thickness: float = 0.01) -> str:\n        \"\"\"\n        Export the Matrix skin as a CONNECTED 2D SHEET of quads.\n        \n        This is a single-layer mesh where adjacent squares share edges,\n        creating a continuous surface like a fishing net or chain-link\n        pattern wrapped around the 3D object.\n        \n        Args:\n            output_path: Path for OBJ file\n            shell_thickness: NOT USED - kept for API compatibility\n            \n        Returns:\n            Path to saved file\n        \"\"\"\n        print(f\"\\n{'='*60}\")\n        print(\"EXPORTING MATRIX SKIN (Connected 2D Sheet)\")\n        print(f\"{'='*60}\")\n        import sys\n        sys.stdout.flush()\n        \n        if not hasattr(self, 'skin_vertices') or not hasattr(self, 'skin_quads'):\n            print(\"  ERROR: No matrix skin created. Run create_matrix_skin() first.\")\n            return None\n        \n        print(f\"  Output: {output_path}\")\n        print(f\"  Vertices: {len(self.skin_vertices):,}\")\n        print(f\"  Quad faces: {len(self.skin_quads):,}\")\n        print(f\"  Type: Single connected 2D sheet (no thickness)\")\n        sys.stdout.flush()\n        \n        print(f\"  Writing OBJ file...\")\n        sys.stdout.flush()\n        \n        with open(output_path, 'w') as f:\n            f.write(\"# MATRIX SKIN - Connected 2D Sheet\\n\")\n            f.write(f\"# Like The Matrix - grid of squares wrapping entire 3D surface\\n\")\n            f.write(f\"# This is a CONNECTED mesh - adjacent squares share edges\\n\")\n            f.write(f\"# Vertices: {len(self.skin_vertices):,}\\n\")\n            f.write(f\"# Quad faces: {len(self.skin_quads):,}\\n\\n\")\n            \n            # Write vertices\n            print(f\"    Writing {len(self.skin_vertices):,} vertices...\")\n            sys.stdout.flush()\n            for idx, v in enumerate(self.skin_vertices):\n                if idx % 500000 == 0 and idx > 0:\n                    print(f\"      {idx:,}/{len(self.skin_vertices):,} ({100*idx/len(self.skin_vertices):.0f}%)\")\n                    sys.stdout.flush()\n                f.write(f\"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}\\n\")\n            \n            # Write quad faces\n            print(f\"    Writing {len(self.skin_quads):,} quad faces...\")\n            sys.stdout.flush()\n            f.write(\"\\n# Quad faces (connected 2D sheet)\\n\")\n            f.write(\"g matrix_skin\\n\")\n            for idx, face in enumerate(self.skin_quads):\n                if idx % 500000 == 0 and idx > 0:\n                    print(f\"      {idx:,}/{len(self.skin_quads):,} ({100*idx/len(self.skin_quads):.0f}%)\")\n                    sys.stdout.flush()\n                # OBJ is 1-indexed\n                indices = [str(i + 1) for i in face]\n                f.write(f\"f {' '.join(indices)}\\n\")\n        \n        print(f\"\\n  ✓ Matrix skin exported!\")\n        print(f\"    - File: {output_path}\")\n        print(f\"    - This is a CONNECTED 2D sheet - squares share edges\")\n        print(f\"    - Open in CAD to see the continuous quad mesh\")\n        sys.stdout.flush()\n        \n        return output_path\n\n    def export_matrix_lattice(self, output_path: str, frame_width: float = 0.02, \n                               frame_thickness: float = 0.01) -> str:\n        \"\"\"\n        Export the Matrix skin as a LATTICE - only frame edges, holes in the squares.\n        \n        This creates a grid of connected frame edges where the CENTER of each\n        square is EMPTY (a hole). Only the edges/borders of the squares are solid.\n        \n        This is the TRUE Matrix look - you can see through the grid!\n        The original 3D object is NOT included - only the lattice remains.\n        \n        Args:\n            output_path: Path for OBJ file\n            frame_width: Width of each frame edge (how thick the bars are)\n            frame_thickness: Thickness/depth of the frame (extrusion from surface)\n            \n        Returns:\n            Path to saved file\n        \"\"\"\n        print(f\"\\n{'='*60}\")\n        print(\"EXPORTING MATRIX LATTICE (Hollow Frames - See Through!)\")\n        print(f\"{'='*60}\")\n        import sys\n        sys.stdout.flush()\n        \n        if not hasattr(self, 'skin_vertices') or not hasattr(self, 'skin_quads'):\n            print(\"  ERROR: No matrix skin created. Run create_matrix_skin() first.\")\n            return None\n        \n        print(f\"  Output: {output_path}\")\n        print(f\"  Frame width: {frame_width}\")\n        print(f\"  Frame thickness: {frame_thickness}\")\n        print(f\"  Original quads: {len(self.skin_quads):,}\")\n        print(f\"  → Converting each quad edge to a 3D bar\")\n        print(f\"  → Centers will be EMPTY (holes)\")\n        sys.stdout.flush()\n        \n        # Collect unique edges from all quads\n        print(f\"  Step 1: Collecting unique edges...\")\n        sys.stdout.flush()\n        \n        edges = set()\n        for idx, face in enumerate(self.skin_quads):\n            if idx % 500000 == 0:\n                print(f\"    Processing quad {idx:,}/{len(self.skin_quads):,}\")\n                sys.stdout.flush()\n            for i in range(len(face)):\n                j = (i + 1) % len(face)\n                edge = tuple(sorted([face[i], face[j]]))\n                edges.add(edge)\n        \n        num_edges = len(edges)\n        print(f\"  Found {num_edges:,} unique edges\")\n        sys.stdout.flush()\n        \n        # Create 3D bars for each edge\n        print(f\"  Step 2: Creating 3D frame bars...\")\n        sys.stdout.flush()\n        \n        all_vertices = []\n        all_faces = []\n        \n        # Pre-compute vertex normals for offset direction\n        vertex_normals = self.mesh.vertex_normals\n        num_orig_verts = len(self.mesh.vertices)\n        \n        for edge_idx, edge in enumerate(edges):\n            if edge_idx % 100000 == 0:\n                print(f\"    Edge {edge_idx:,}/{num_edges:,} ({100*edge_idx/num_edges:.0f}%)\")\n                sys.stdout.flush()\n            \n            # Get edge endpoints\n            v0 = self.skin_vertices[edge[0]]\n            v1 = self.skin_vertices[edge[1]]\n            \n            # Get normals for offset direction\n            if edge[0] < num_orig_verts:\n                n0 = vertex_normals[edge[0]]\n            else:\n                n0 = np.array([0, 0, 1])  # Default for midpoints/centers\n            if edge[1] < num_orig_verts:\n                n1 = vertex_normals[edge[1]]\n            else:\n                n1 = np.array([0, 0, 1])\n            \n            # Edge direction and perpendicular\n            edge_dir = v1 - v0\n            edge_len = np.linalg.norm(edge_dir)\n            if edge_len < 1e-10:\n                continue\n            edge_dir = edge_dir / edge_len\n            \n            # Get perpendicular direction (in surface plane)\n            normal = (n0 + n1) / 2\n            norm_len = np.linalg.norm(normal)\n            if norm_len > 0:\n                normal = normal / norm_len\n            else:\n                normal = np.array([0, 0, 1])\n            \n            # Perpendicular to edge, in surface plane\n            perp = np.cross(normal, edge_dir)\n            perp_len = np.linalg.norm(perp)\n            if perp_len > 0:\n                perp = perp / perp_len * (frame_width / 2)\n            else:\n                perp = np.array([frame_width/2, 0, 0])\n            \n            # Normal offset for thickness\n            offset = normal * frame_thickness\n            \n            # Create 8 vertices for this bar (box shape)\n            base_idx = len(all_vertices)\n            \n            # Bottom face (on surface)\n            all_vertices.append(v0 - perp)           # 0\n            all_vertices.append(v0 + perp)           # 1\n            all_vertices.append(v1 + perp)           # 2\n            all_vertices.append(v1 - perp)           # 3\n            \n            # Top face (offset from surface)\n            all_vertices.append(v0 - perp + offset)  # 4\n            all_vertices.append(v0 + perp + offset)  # 5\n            all_vertices.append(v1 + perp + offset)  # 6\n            all_vertices.append(v1 - perp + offset)  # 7\n            \n            # Create faces for this bar (6 faces of a box)\n            # Bottom\n            all_faces.append([base_idx+0, base_idx+3, base_idx+2, base_idx+1])\n            # Top\n            all_faces.append([base_idx+4, base_idx+5, base_idx+6, base_idx+7])\n            # Front\n            all_faces.append([base_idx+0, base_idx+1, base_idx+5, base_idx+4])\n            # Back\n            all_faces.append([base_idx+2, base_idx+3, base_idx+7, base_idx+6])\n            # Left\n            all_faces.append([base_idx+0, base_idx+4, base_idx+7, base_idx+3])\n            # Right\n            all_faces.append([base_idx+1, base_idx+2, base_idx+6, base_idx+5])\n        \n        print(f\"  Step 3: Writing OBJ file...\")\n        print(f\"    Total vertices: {len(all_vertices):,}\")\n        print(f\"    Total faces: {len(all_faces):,}\")\n        sys.stdout.flush()\n        \n        with open(output_path, 'w') as f:\n            f.write(\"# MATRIX LATTICE - Hollow Frame Grid\\n\")\n            f.write(\"# Only edges are solid - centers are EMPTY (holes)\\n\")\n            f.write(\"# You can see THROUGH this grid - no solid object inside\\n\")\n            f.write(f\"# Frame edges: {num_edges:,}\\n\")\n            f.write(f\"# Frame width: {frame_width}\\n\")\n            f.write(f\"# Frame thickness: {frame_thickness}\\n\")\n            f.write(f\"# Vertices: {len(all_vertices):,}\\n\")\n            f.write(f\"# Faces: {len(all_faces):,}\\n\\n\")\n            \n            # Write vertices\n            for idx, v in enumerate(all_vertices):\n                if idx % 500000 == 0 and idx > 0:\n                    print(f\"      Vertices: {idx:,}/{len(all_vertices):,}\")\n                    sys.stdout.flush()\n                f.write(f\"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}\\n\")\n            \n            # Write faces\n            f.write(\"\\ng matrix_lattice\\n\")\n            for idx, face in enumerate(all_faces):\n                if idx % 500000 == 0 and idx > 0:\n                    print(f\"      Faces: {idx:,}/{len(all_faces):,}\")\n                    sys.stdout.flush()\n                # OBJ is 1-indexed\n                indices = [str(i + 1) for i in face]\n                f.write(f\"f {' '.join(indices)}\\n\")\n        \n        print(f\"\\n  ✓ Matrix LATTICE exported!\")\n        print(f\"    - File: {output_path}\")\n        print(f\"    - ONLY frame edges are solid\")\n        print(f\"    - Centers are EMPTY - you can see through!\")\n        print(f\"    - Original 3D object is NOT included\")\n        sys.stdout.flush()\n        \n        return output_path\n\n    def export_wireframe_skin(self, output_path: str, wire_thickness: float = 0.005) -> str:\n        \"\"\"\n        Export the Matrix skin as a WIREFRAME - just the edges of the quads.\n        \n        This creates the true \"Matrix\" look - a grid of lines wrapping the surface.\n        Each edge is extruded into a thin tube for 3D printing/manufacturing.\n        \n        Args:\n            output_path: Path for OBJ file\n            wire_thickness: Thickness of each wire/edge\n            \n        Returns:\n            Path to saved file\n        \"\"\"\n        print(f\"\\n{'='*60}\")\n        print(\"EXPORTING WIREFRAME SKIN (Matrix Style)\")\n        print(f\"{'='*60}\")\n        import sys\n        sys.stdout.flush()\n        \n        if not hasattr(self, 'skin_vertices') or not hasattr(self, 'skin_quads'):\n            print(\"  ERROR: No matrix skin created. Run create_matrix_skin() first.\")\n            return None\n        \n        print(f\"  Wire thickness: {wire_thickness}\")\n        \n        # Collect unique edges\n        print(\"  Collecting unique edges...\")\n        sys.stdout.flush()\n        edges = set()\n        total_faces = len(self.skin_quads)\n        for idx, face in enumerate(self.skin_quads):\n            if idx % 100000 == 0:\n                print(f\"    Processing face {idx:,}/{total_faces:,} ({100*idx/total_faces:.1f}%)\")\n                sys.stdout.flush()\n            for i in range(len(face)):\n                j = (i + 1) % len(face)\n                edge = tuple(sorted([face[i], face[j]]))\n                edges.add(edge)\n        \n        print(f\"  Total edges: {len(edges):,}\")\n        \n        # For very large meshes, skip wireframe (too slow)\n        if len(edges) > 500000:\n            print(f\"  ⚠️ Too many edges ({len(edges):,}) - skipping wireframe export\")\n            print(f\"     Use the matrix_skin.obj or quad_skin.obj instead\")\n            # Write a simple placeholder file\n            with open(output_path, 'w') as f:\n                f.write(f\"# WIREFRAME SKIPPED - {len(edges):,} edges would take too long\\n\")\n                f.write(f\"# Use matrix_skin.obj or quad_skin.obj instead\\n\")\n            return output_path\n        \n        # Create tube geometry for each edge\n        all_vertices = []\n        all_faces = []\n        \n        segments = 4  # Square cross-section for wires\n        total_edges = len(edges)\n        \n        print(f\"  Creating tube geometry for {total_edges:,} edges...\")\n        sys.stdout.flush()\n        \n        for edge_idx, edge in enumerate(edges):\n            if edge_idx % 50000 == 0:\n                print(f\"    Edge {edge_idx:,}/{total_edges:,} ({100*edge_idx/total_edges:.1f}%)\")\n                sys.stdout.flush()\n            v0 = self.skin_vertices[edge[0]]\n            v1 = self.skin_vertices[edge[1]]\n            \n            # Edge direction\n            direction = v1 - v0\n            length = np.linalg.norm(direction)\n            if length < 1e-10:\n                continue\n            direction = direction / length\n            \n            # Create perpendicular vectors for tube cross-section\n            if abs(direction[0]) < 0.9:\n                perp1 = np.cross(direction, [1, 0, 0])\n            else:\n                perp1 = np.cross(direction, [0, 1, 0])\n            perp1 = perp1 / np.linalg.norm(perp1) * wire_thickness\n            perp2 = np.cross(direction, perp1)\n            perp2 = perp2 / np.linalg.norm(perp2) * wire_thickness\n            \n            # Create vertices for tube (square cross-section)\n            base_idx = len(all_vertices)\n            \n            # Start cap\n            all_vertices.append(v0 + perp1 + perp2)\n            all_vertices.append(v0 - perp1 + perp2)\n            all_vertices.append(v0 - perp1 - perp2)\n            all_vertices.append(v0 + perp1 - perp2)\n            \n            # End cap\n            all_vertices.append(v1 + perp1 + perp2)\n            all_vertices.append(v1 - perp1 + perp2)\n            all_vertices.append(v1 - perp1 - perp2)\n            all_vertices.append(v1 + perp1 - perp2)\n            \n            # Create faces (4 sides of tube)\n            for i in range(4):\n                j = (i + 1) % 4\n                # Side face\n                all_faces.append([\n                    base_idx + i + 1,      # OBJ is 1-indexed\n                    base_idx + j + 1,\n                    base_idx + j + 4 + 1,\n                    base_idx + i + 4 + 1\n                ])\n        \n        # Write OBJ\n        with open(output_path, 'w') as f:\n            f.write(\"# WIREFRAME MATRIX SKIN\\n\")\n            f.write(f\"# Wire edges: {len(edges)}\\n\")\n            f.write(f\"# Wire thickness: {wire_thickness}\\n\\n\")\n            \n            for v in all_vertices:\n                f.write(f\"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}\\n\")\n            \n            f.write(\"\\ng wireframe_skin\\n\")\n            for face in all_faces:\n                f.write(f\"f {face[0]} {face[1]} {face[2]} {face[3]}\\n\")\n        \n        print(f\"\\n  ✓ Wireframe skin exported!\")\n        print(f\"    - File: {output_path}\")\n        print(f\"    - Edges converted to tubes: {len(edges)}\")\n        \n        return output_path\n    \n    # ========================================================================\n    # ENHANCED: Connected Quad Patches with Shared Vertices\n    # ========================================================================\n    \n    def create_connected_quad_grid(self, square_size: float = 1.0,\n                                    merge_threshold: float = None) -> Dict:\n        \"\"\"\n        Create a grid of CONNECTED quads where adjacent patches share vertices.\n        \n        This is the key enhancement - instead of isolated squares, we create\n        a true patchwork surface where:\n        - Adjacent quads share edge vertices\n        - Moving one vertex affects all connected quads\n        - The result is a unified, editable CAD surface\n        \n        Args:\n            square_size: Size of each quad in mesh units\n            merge_threshold: Distance threshold for merging vertices (default: square_size/4)\n            \n        Returns:\n            Dictionary with patches, shared vertices, and connectivity info\n        \"\"\"\n        print(f\"\\n{'='*60}\")\n        print(\"CREATING CONNECTED QUAD GRID (Enhanced)\")\n        print(f\"{'='*60}\")\n        print(f\"  Square size: {square_size}\")\n        \n        if merge_threshold is None:\n            merge_threshold = square_size / 4\n        \n        # First, create the basic grid\n        self.create_uv_grid(square_size=square_size)\n        \n        if not self.grid_squares:\n            print(\"  ERROR: No grid squares created\")\n            return {}\n        \n        print(f\"\\n  Step 1: Merging nearby vertices...\")\n        \n        # Collect all vertices from all squares\n        all_vertices = []\n        vertex_sources = []  # (square_idx, corner_idx)\n        \n        for sq_idx, square in enumerate(self.grid_squares):\n            for corner_idx, vertex in enumerate(square['vertices']):\n                all_vertices.append(vertex)\n                vertex_sources.append((sq_idx, corner_idx))\n        \n        all_vertices = np.array(all_vertices)\n        print(f\"    Total vertices before merge: {len(all_vertices)}\")\n        \n        # Build KD-tree for efficient nearest neighbor search\n        tree = KDTree(all_vertices)\n        \n        # Find clusters of nearby vertices\n        self.shared_vertices = {}\n        vertex_to_shared_id = {}  # (sq_idx, corner_idx) -> shared_vertex_id\n        shared_id = 0\n        processed = set()\n        \n        for i, vertex in enumerate(all_vertices):\n            if i in processed:\n                continue\n            \n            # Find all vertices within merge threshold\n            nearby_indices = tree.query_ball_point(vertex, merge_threshold)\n            \n            # Average position of cluster\n            cluster_vertices = all_vertices[nearby_indices]\n            merged_position = np.mean(cluster_vertices, axis=0)\n            \n            # Create shared vertex\n            self.shared_vertices[shared_id] = merged_position.tolist()\n            \n            # Map all nearby vertices to this shared vertex\n            for idx in nearby_indices:\n                source = vertex_sources[idx]\n                vertex_to_shared_id[source] = shared_id\n                processed.add(idx)\n            \n            shared_id += 1\n        \n        print(f\"    Shared vertices after merge: {len(self.shared_vertices)}\")\n        print(f\"    Vertex reduction: {len(all_vertices) - len(self.shared_vertices)} vertices merged\")\n        \n        # Create quad patches referencing shared vertices\n        print(f\"\\n  Step 2: Building connected quad patches...\")\n        \n        self.quad_patches = []\n        self.vertex_to_quads = defaultdict(list)\n        \n        for sq_idx, square in enumerate(self.grid_squares):\n            # Get shared vertex IDs for this quad's corners\n            vertex_ids = []\n            for corner_idx in range(len(square['vertices'])):\n                v_id = vertex_to_shared_id.get((sq_idx, corner_idx), -1)\n                vertex_ids.append(v_id)\n                self.vertex_to_quads[v_id].append(sq_idx)\n            \n            patch = {\n                \"id\": sq_idx,\n                \"vertex_ids\": vertex_ids,  # References to shared vertices\n                \"center\": square['center'],\n                \"normal\": square['normal'],\n                \"size\": square['size'],\n                \"neighbors\": [],  # Will be populated next\n                \"region_id\": None\n            }\n            self.quad_patches.append(patch)\n        \n        # Find neighbors (quads sharing vertices)\n        print(f\"\\n  Step 3: Computing quad connectivity...\")\n        \n        neighbor_count = 0\n        for patch in self.quad_patches:\n            neighbor_set = set()\n            for v_id in patch['vertex_ids']:\n                for neighbor_quad_id in self.vertex_to_quads[v_id]:\n                    if neighbor_quad_id != patch['id']:\n                        neighbor_set.add(neighbor_quad_id)\n            patch['neighbors'] = list(neighbor_set)\n            neighbor_count += len(patch['neighbors'])\n        \n        avg_neighbors = neighbor_count / len(self.quad_patches) if self.quad_patches else 0\n        print(f\"    Average neighbors per quad: {avg_neighbors:.1f}\")\n        \n        # Update grid params\n        self.grid_params.update({\n            \"connected\": True,\n            \"shared_vertex_count\": len(self.shared_vertices),\n            \"merge_threshold\": merge_threshold,\n            \"average_neighbors\": avg_neighbors\n        })\n        \n        print(f\"\\n  ✓ Connected quad grid created successfully!\")\n        print(f\"    - {len(self.quad_patches)} quad patches\")\n        print(f\"    - {len(self.shared_vertices)} shared vertices\")\n        \n        return {\n            \"patches\": self.quad_patches,\n            \"shared_vertices\": self.shared_vertices,\n            \"vertex_to_quads\": dict(self.vertex_to_quads)\n        }\n    \n    def detect_surface_regions(self, num_regions: int = 6, \n                                method: str = \"normal\") -> Dict[int, List[int]]:\n        \"\"\"\n        Automatically detect and group quads into surface regions.\n        \n        Regions are grouped by:\n        - Normal direction (faces pointing same way)\n        - Spatial proximity\n        - Curvature similarity\n        \n        Args:\n            num_regions: Target number of regions\n            method: Grouping method ('normal', 'spatial', 'curvature')\n            \n        Returns:\n            Dictionary mapping region_id to list of quad IDs\n        \"\"\"\n        print(f\"\\n  Step 4: Detecting surface regions...\")\n        print(f\"    Method: {method}, Target regions: {num_regions}\")\n        \n        if not self.quad_patches:\n            print(\"    ERROR: No quad patches to group\")\n            return {}\n        \n        # Collect features for clustering\n        features = []\n        \n        for patch in self.quad_patches:\n            if method == \"normal\":\n                # Group by normal direction\n                features.append(patch['normal'])\n            elif method == \"spatial\":\n                # Group by position\n                features.append(patch['center'])\n            elif method == \"curvature\":\n                # Group by normal + position (combined)\n                features.append(patch['normal'] + patch['center'])\n            else:\n                features.append(patch['normal'])\n        \n        features = np.array(features)\n        \n        # Use K-means clustering\n        num_regions = min(num_regions, len(self.quad_patches))\n        kmeans = KMeans(n_clusters=num_regions, random_state=42, n_init=10)\n        labels = kmeans.fit_predict(features)\n        \n        # Build regions dictionary\n        self.regions = defaultdict(list)\n        for quad_idx, region_id in enumerate(labels):\n            self.regions[int(region_id)].append(quad_idx)\n            self.quad_patches[quad_idx]['region_id'] = int(region_id)\n        \n        # Assign region properties (colors, names)\n        region_colors = [\n            (255, 100, 100, 255),   # Red\n            (100, 255, 100, 255),   # Green\n            (100, 100, 255, 255),   # Blue\n            (255, 255, 100, 255),   # Yellow\n            (255, 100, 255, 255),   # Magenta\n            (100, 255, 255, 255),   # Cyan\n            (255, 180, 100, 255),   # Orange\n            (180, 100, 255, 255),   # Purple\n        ]\n        \n        region_names = [\"Top\", \"Bottom\", \"Front\", \"Back\", \"Left\", \"Right\", \n                       \"Region_7\", \"Region_8\", \"Region_9\", \"Region_10\"]\n        \n        self.region_layers = {}\n        for region_id in self.regions:\n            avg_normal = np.mean([self.quad_patches[q]['normal'] for q in self.regions[region_id]], axis=0)\n            \n            # Auto-name based on dominant normal direction\n            abs_normal = np.abs(avg_normal)\n            if abs_normal[2] > 0.7:  # Z-dominant\n                name = \"Top\" if avg_normal[2] > 0 else \"Bottom\"\n            elif abs_normal[1] > 0.7:  # Y-dominant\n                name = \"Front\" if avg_normal[1] > 0 else \"Back\"\n            elif abs_normal[0] > 0.7:  # X-dominant\n                name = \"Right\" if avg_normal[0] > 0 else \"Left\"\n            else:\n                name = f\"Region_{region_id}\"\n            \n            self.region_layers[region_id] = {\n                \"name\": f\"{name}_{region_id}\",\n                \"color\": region_colors[region_id % len(region_colors)],\n                \"quad_count\": len(self.regions[region_id]),\n                \"average_normal\": avg_normal.tolist()\n            }\n        \n        print(f\"    Created {len(self.regions)} regions:\")\n        for r_id, info in self.region_layers.items():\n            print(f\"      - {info['name']}: {info['quad_count']} quads\")\n        \n        return dict(self.regions)\n    \n    def create_nurbs_patches(self, degree: int = 3) -> List[Dict]:\n        \"\"\"\n        Convert quad patches to NURBS surface patches.\n        \n        NURBS surfaces are the native CAD representation,\n        allowing smooth editing and precise manufacturing.\n        \n        Args:\n            degree: NURBS surface degree (3 = cubic, smooth)\n            \n        Returns:\n            List of NURBS patch data\n        \"\"\"\n        print(f\"\\n  Creating NURBS surface patches (degree={degree})...\")\n        \n        nurbs_patches = []\n        \n        for patch in self.quad_patches:\n            # Get corner vertices\n            corners = [self.shared_vertices[v_id] for v_id in patch['vertex_ids']]\n            \n            if len(corners) < 4:\n                continue\n            \n            # Create bilinear NURBS patch data\n            # For true NURBS, we'd need control points beyond corners\n            nurbs_data = {\n                \"id\": patch['id'],\n                \"type\": \"nurbs_surface\",\n                \"degree_u\": min(degree, 1),  # Bilinear for quads\n                \"degree_v\": min(degree, 1),\n                \"control_points\": corners[:4],  # 2x2 grid\n                \"knots_u\": [0, 0, 1, 1],\n                \"knots_v\": [0, 0, 1, 1],\n                \"weights\": [1, 1, 1, 1],  # Rational weights\n                \"region_id\": patch['region_id'],\n                \"neighbors\": patch['neighbors']\n            }\n            nurbs_patches.append(nurbs_data)\n        \n        print(f\"    Created {len(nurbs_patches)} NURBS patches\")\n        return nurbs_patches\n    \n    def export_to_rhino(self, output_path: str, \n                        include_original_mesh: bool = True,\n                        layer_name: str = \"Grid_Squares\") -> str:\n        \"\"\"\n        Export the grid to Rhino .3dm format.\n        \n        Args:\n            output_path: Path for the .3dm file\n            include_original_mesh: Whether to include the original mesh\n            layer_name: Name for the grid layer\n            \n        Returns:\n            Path to the saved file\n        \"\"\"\n        if not HAS_RHINO3DM:\n            print(\"rhino3dm not available, falling back to OBJ export\")\n            return self.export_to_obj(output_path.replace('.3dm', '_grid.obj'))\n        \n        print(f\"\\nExporting to Rhino .3dm: {output_path}\")\n        \n        # Create new Rhino file\n        model = rhino3dm.File3dm()\n        \n        # Add layers\n        grid_layer = rhino3dm.Layer()\n        grid_layer.Name = layer_name\n        grid_layer.Color = (255, 100, 100, 255)  # Red-ish\n        grid_layer_index = model.Layers.Add(grid_layer)\n        \n        if include_original_mesh:\n            mesh_layer = rhino3dm.Layer()\n            mesh_layer.Name = \"Original_Mesh\"\n            mesh_layer.Color = (100, 100, 255, 255)  # Blue-ish\n            mesh_layer_index = model.Layers.Add(mesh_layer)\n        \n        # Add grid squares as polylines/surfaces\n        for square in self.grid_squares:\n            vertices = square.get(\"vertices\", [])\n            \n            if len(vertices) >= 3:\n                # Create polyline (closed)\n                points = [rhino3dm.Point3d(v[0], v[1], v[2]) for v in vertices]\n                points.append(points[0])  # Close the loop\n                \n                polyline = rhino3dm.Polyline(points)\n                curve = polyline.ToPolylineCurve()\n                \n                if curve:\n                    attr = rhino3dm.ObjectAttributes()\n                    attr.LayerIndex = grid_layer_index\n                    attr.Name = f\"Square_{square['id']}\"\n                    \n                    # Add user data for parametric control\n                    # Note: rhino3dm has limited user data support\n                    \n                    model.Objects.AddCurve(curve, attr)\n        \n        # Add original mesh if requested\n        if include_original_mesh and self.mesh is not None:\n            rhino_mesh = rhino3dm.Mesh()\n            \n            # Add vertices\n            for vertex in self.mesh.vertices:\n                rhino_mesh.Vertices.Add(vertex[0], vertex[1], vertex[2])\n            \n            # Add faces\n            for face in self.mesh.faces:\n                rhino_mesh.Faces.AddFace(face[0], face[1], face[2])\n            \n            rhino_mesh.Normals.ComputeNormals()\n            \n            attr = rhino3dm.ObjectAttributes()\n            attr.LayerIndex = mesh_layer_index\n            attr.Name = \"Original_Mesh\"\n            \n            model.Objects.AddMesh(rhino_mesh, attr)\n        \n        # Save the file\n        model.Write(output_path, version=7)  # Rhino 7 format\n        \n        print(f\"  ✓ Saved {len(self.grid_squares)} grid elements to {output_path}\")\n        return output_path\n    \n    def export_connected_to_rhino(self, output_path: str,\n                                   include_original_mesh: bool = True,\n                                   export_as_surfaces: bool = True,\n                                   export_shared_points: bool = True) -> str:\n        \"\"\"\n        Export CONNECTED quad grid to Rhino with region layers and shared vertices.\n        \n        This is the enhanced export that creates:\n        - Separate layers for each surface region\n        - NURBS surfaces (not just curves)\n        - Point cloud of shared vertices for editing\n        - Full connectivity information\n        \n        Args:\n            output_path: Path for the .3dm file\n            include_original_mesh: Include the source mesh\n            export_as_surfaces: Export as surfaces (True) or curves (False)\n            export_shared_points: Include shared vertex points for editing\n            \n        Returns:\n            Path to saved file\n        \"\"\"\n        if not HAS_RHINO3DM:\n            print(\"rhino3dm not available, using OBJ export\")\n            return self.export_connected_to_obj(output_path.replace('.3dm', '_connected.obj'))\n        \n        print(f\"\\n{'='*60}\")\n        print(\"EXPORTING CONNECTED CAD GEOMETRY\")\n        print(f\"{'='*60}\")\n        print(f\"  Output: {output_path}\")\n        \n        model = rhino3dm.File3dm()\n        \n        # ========== Create Layers ==========\n        layer_indices = {}\n        \n        # Parent layer for all grid geometry\n        parent_layer = rhino3dm.Layer()\n        parent_layer.Name = \"Surface_Grid\"\n        parent_layer_index = model.Layers.Add(parent_layer)\n        \n        # Region layers (children of Surface_Grid)\n        if self.region_layers:\n            for region_id, region_info in self.region_layers.items():\n                layer = rhino3dm.Layer()\n                layer.Name = region_info['name']\n                layer.Color = region_info['color']\n                layer.ParentLayerId = model.Layers[parent_layer_index].Id\n                layer_indices[region_id] = model.Layers.Add(layer)\n                print(f\"    Layer: {region_info['name']} ({region_info['quad_count']} patches)\")\n        else:\n            # Default single layer if no regions detected\n            default_layer = rhino3dm.Layer()\n            default_layer.Name = \"Quad_Patches\"\n            default_layer.Color = (255, 100, 100, 255)\n            layer_indices[-1] = model.Layers.Add(default_layer)\n        \n        # Shared vertices layer\n        if export_shared_points:\n            points_layer = rhino3dm.Layer()\n            points_layer.Name = \"Shared_Vertices\"\n            points_layer.Color = (255, 255, 0, 255)  # Yellow\n            points_layer_index = model.Layers.Add(points_layer)\n        \n        # Original mesh layer\n        if include_original_mesh:\n            mesh_layer = rhino3dm.Layer()\n            mesh_layer.Name = \"Original_Mesh\"\n            mesh_layer.Color = (100, 100, 100, 255)  # Gray\n            mesh_layer_index = model.Layers.Add(mesh_layer)\n        \n        # ========== Export Quad Patches ==========\n        print(f\"\\n  Exporting {len(self.quad_patches)} quad patches...\")\n        \n        surfaces_added = 0\n        curves_added = 0\n        \n        for patch in self.quad_patches:\n            # Get vertices for this patch\n            vertices = []\n            for v_id in patch['vertex_ids']:\n                if v_id in self.shared_vertices:\n                    vertices.append(self.shared_vertices[v_id])\n            \n            if len(vertices) < 3:\n                continue\n            \n            # Determine layer\n            region_id = patch.get('region_id', -1)\n            layer_idx = layer_indices.get(region_id, layer_indices.get(-1, 0))\n            \n            # Create attributes\n            attr = rhino3dm.ObjectAttributes()\n            attr.LayerIndex = layer_idx\n            attr.Name = f\"Patch_{patch['id']}\"\n            \n            if export_as_surfaces and len(vertices) >= 4:\n                # Create NURBS surface from 4 corners\n                try:\n                    # Create a simple bilinear surface\n                    pts = [rhino3dm.Point3d(v[0], v[1], v[2]) for v in vertices[:4]]\n                    \n                    # Create NurbsSurface - 2x2 control points, degree 1\n                    surface = rhino3dm.NurbsSurface.Create(\n                        3,  # dimension\n                        False,  # isRational\n                        2, 2,  # degree u, v (linear)\n                        2, 2   # control point count u, v\n                    )\n                    \n                    if surface:\n                        # Set control points (2x2 grid)\n                        surface.Points.SetPoint(0, 0, pts[0])\n                        surface.Points.SetPoint(1, 0, pts[1])\n                        surface.Points.SetPoint(0, 1, pts[3])\n                        surface.Points.SetPoint(1, 1, pts[2])\n                        \n                        model.Objects.AddSurface(surface, attr)\n                        surfaces_added += 1\n                except Exception as e:\n                    # Fallback to curve\n                    pass\n            \n            # Also/alternatively add as curve (polyline boundary)\n            points = [rhino3dm.Point3d(v[0], v[1], v[2]) for v in vertices]\n            points.append(points[0])  # Close loop\n            \n            polyline = rhino3dm.Polyline(points)\n            curve = polyline.ToPolylineCurve()\n            \n            if curve:\n                if not export_as_surfaces:\n                    model.Objects.AddCurve(curve, attr)\n                    curves_added += 1\n                else:\n                    # Add curve as edge reference\n                    edge_attr = rhino3dm.ObjectAttributes()\n                    edge_attr.LayerIndex = layer_idx\n                    edge_attr.Name = f\"Edge_{patch['id']}\"\n                    model.Objects.AddCurve(curve, edge_attr)\n        \n        print(f\"    Surfaces added: {surfaces_added}\")\n        print(f\"    Edge curves added: {len(self.quad_patches)}\")\n        \n        # ========== Export Shared Vertices as Points ==========\n        if export_shared_points and self.shared_vertices:\n            print(f\"\\n  Exporting {len(self.shared_vertices)} shared control points...\")\n            \n            for v_id, coords in self.shared_vertices.items():\n                point = rhino3dm.Point3d(coords[0], coords[1], coords[2])\n                \n                attr = rhino3dm.ObjectAttributes()\n                attr.LayerIndex = points_layer_index\n                attr.Name = f\"V_{v_id}\"\n                \n                # Store connectivity info in name (which quads use this vertex)\n                connected_quads = self.vertex_to_quads.get(v_id, [])\n                if connected_quads:\n                    attr.Name = f\"V_{v_id}_Q{len(connected_quads)}\"\n                \n                model.Objects.AddPoint(point, attr)\n        \n        # ========== Export Original Mesh ==========\n        if include_original_mesh and self.mesh is not None:\n            print(f\"\\n  Exporting original mesh (reference)...\")\n            \n            rhino_mesh = rhino3dm.Mesh()\n            \n            for vertex in self.mesh.vertices:\n                rhino_mesh.Vertices.Add(vertex[0], vertex[1], vertex[2])\n            \n            for face in self.mesh.faces:\n                rhino_mesh.Faces.AddFace(int(face[0]), int(face[1]), int(face[2]))\n            \n            rhino_mesh.Normals.ComputeNormals()\n            \n            attr = rhino3dm.ObjectAttributes()\n            attr.LayerIndex = mesh_layer_index\n            attr.Name = \"Source_Mesh\"\n            \n            model.Objects.AddMesh(rhino_mesh, attr)\n        \n        # Save\n        model.Write(output_path, version=7)\n        \n        print(f\"\\n  ✓ Saved connected CAD geometry to:\")\n        print(f\"    {output_path}\")\n        print(f\"\\n  In Rhino, you can now:\")\n        print(f\"    • Select patches by region (layer)\")\n        print(f\"    • Move shared vertices to reshape multiple patches\")\n        print(f\"    • Edit surfaces for manufacturing\")\n        \n        return output_path\n    \n    def export_connected_to_obj(self, output_path: str) -> str:\n        \"\"\"\n        Export connected grid as OBJ with shared vertices.\n        \n        Args:\n            output_path: Path for OBJ file\n            \n        Returns:\n            Path to saved file\n        \"\"\"\n        print(f\"\\nExporting connected grid to OBJ: {output_path}\")\n        \n        with open(output_path, 'w') as f:\n            f.write(\"# Connected Quad Grid Export (Enhanced)\\n\")\n            f.write(f\"# Quad patches: {len(self.quad_patches)}\\n\")\n            f.write(f\"# Shared vertices: {len(self.shared_vertices)}\\n\")\n            f.write(f\"# Regions: {len(self.regions)}\\n\\n\")\n            \n            # Write all shared vertices first\n            f.write(\"# Shared Vertices\\n\")\n            vertex_id_to_obj_idx = {}\n            obj_idx = 1  # OBJ is 1-indexed\n            \n            for v_id in sorted(self.shared_vertices.keys()):\n                coords = self.shared_vertices[v_id]\n                f.write(f\"v {coords[0]:.6f} {coords[1]:.6f} {coords[2]:.6f}\\n\")\n                vertex_id_to_obj_idx[v_id] = obj_idx\n                obj_idx += 1\n            \n            f.write(f\"\\n# Quad Patches by Region\\n\")\n            \n            # Group patches by region\n            for region_id in sorted(self.regions.keys()):\n                region_info = self.region_layers.get(region_id, {\"name\": f\"Region_{region_id}\"})\n                f.write(f\"\\ng {region_info['name']}\\n\")\n                \n                for quad_idx in self.regions[region_id]:\n                    patch = self.quad_patches[quad_idx]\n                    \n                    # Get OBJ vertex indices\n                    obj_indices = [vertex_id_to_obj_idx.get(v_id, 1) for v_id in patch['vertex_ids']]\n                    \n                    if len(obj_indices) >= 4:\n                        f.write(f\"f {obj_indices[0]} {obj_indices[1]} {obj_indices[2]} {obj_indices[3]}\\n\")\n                    elif len(obj_indices) == 3:\n                        f.write(f\"f {obj_indices[0]} {obj_indices[1]} {obj_indices[2]}\\n\")\n        \n        print(f\"  ✓ Saved connected grid to {output_path}\")\n        return output_path\n    \n    def export_hollow_shell(self, output_path: str, frame_thickness: float = 0.1,\n                            extrude_height: float = 0.05) -> str:\n        \"\"\"\n        Export HOLLOW FRAME structure - square frames without solid fill.\n        \n        This creates the carved-out shell structure where:\n        - Each square is just the FRAME (4 edges) with thickness\n        - NO solid interior - you can see through each square\n        - The frames wrap around the 3D surface\n        - Perfect for lattice/mesh-style jewelry designs\n        \n        Args:\n            output_path: Path for the OBJ file\n            frame_thickness: Width of each frame edge (default 0.1 = 10% of square)\n            extrude_height: Height to extrude frames outward from surface\n            \n        Returns:\n            Path to saved file\n        \"\"\"\n        print(f\"\\n{'='*60}\")\n        print(\"CREATING HOLLOW SHELL STRUCTURE (Carved-out frames)\")\n        print(f\"{'='*60}\")\n        print(f\"  Frame thickness: {frame_thickness}\")\n        print(f\"  Extrude height: {extrude_height}\")\n        print(f\"  Total squares: {len(self.quad_patches)}\")\n        \n        all_vertices = []\n        all_faces = []\n        vertex_offset = 0\n        \n        for patch in self.quad_patches:\n            # Get the 4 corner vertices of this square\n            corners = []\n            for v_id in patch['vertex_ids']:\n                if v_id in self.shared_vertices:\n                    corners.append(np.array(self.shared_vertices[v_id]))\n            \n            if len(corners) < 4:\n                continue\n            \n            # Get normal for extrusion direction\n            normal = np.array(patch['normal'])\n            normal = normal / (np.linalg.norm(normal) + 1e-8)\n            \n            # Create INNER corners (shrunk toward center) for the hollow part\n            center = np.mean(corners, axis=0)\n            \n            # Outer corners (original)\n            outer = corners\n            \n            # Inner corners (shrunk by frame_thickness ratio)\n            inner = []\n            for c in corners:\n                direction = center - c\n                dist = np.linalg.norm(direction)\n                if dist > 0:\n                    shrink = min(frame_thickness, dist * 0.4)  # Don't shrink more than 40%\n                    inner.append(c + (direction / dist) * shrink)\n                else:\n                    inner.append(c)\n            \n            # Create extruded versions (offset along normal)\n            outer_top = [c + normal * extrude_height for c in outer]\n            inner_top = [c + normal * extrude_height for c in inner]\n            outer_bot = [c - normal * extrude_height for c in outer]\n            inner_bot = [c - normal * extrude_height for c in inner]\n            \n            # Add all 16 vertices for this frame\n            # Bottom layer: outer[0-3], inner[0-3]\n            # Top layer: outer_top[0-3], inner_top[0-3]\n            frame_verts = outer_bot + inner_bot + outer_top + inner_top\n            \n            for v in frame_verts:\n                all_vertices.append(v)\n            \n            # Create faces for the 4 frame edges\n            # Each edge is a rectangular tube connecting outer to inner\n            base = vertex_offset\n            \n            # Vertex indices (1-indexed for OBJ)\n            # Bottom outer: 0,1,2,3 -> base+1 to base+4\n            # Bottom inner: 4,5,6,7 -> base+5 to base+8\n            # Top outer: 8,9,10,11 -> base+9 to base+12\n            # Top inner: 12,13,14,15 -> base+13 to base+16\n            \n            ob = [base+1, base+2, base+3, base+4]      # outer bottom\n            ib = [base+5, base+6, base+7, base+8]      # inner bottom\n            ot = [base+9, base+10, base+11, base+12]   # outer top\n            it = [base+13, base+14, base+15, base+16]  # inner top\n            \n            # Create 4 frame edges (each edge has 4 quad faces)\n            for i in range(4):\n                j = (i + 1) % 4\n                \n                # Outer face (facing outward)\n                all_faces.append([ob[i], ob[j], ot[j], ot[i]])\n                \n                # Inner face (facing inward toward hole)\n                all_faces.append([ib[j], ib[i], it[i], it[j]])\n                \n                # Top face (top of frame)\n                all_faces.append([ot[i], ot[j], it[j], it[i]])\n                \n                # Bottom face (bottom of frame)\n                all_faces.append([ob[j], ob[i], ib[i], ib[j]])\n            \n            # End caps for each frame segment\n            for i in range(4):\n                j = (i + 1) % 4\n                # Side cap 1\n                all_faces.append([ob[i], ib[i], it[i], ot[i]])\n                # Side cap 2\n                all_faces.append([ib[j], ob[j], ot[j], it[j]])\n            \n            vertex_offset += 16\n        \n        # Write OBJ file\n        print(f\"\\n  Writing hollow shell to: {output_path}\")\n        \n        with open(output_path, 'w') as f:\n            f.write(\"# HOLLOW SHELL STRUCTURE - Carved-out square frames\\n\")\n            f.write(f\"# Frame count: {len(self.quad_patches)}\\n\")\n            f.write(f\"# Frame thickness: {frame_thickness}\\n\")\n            f.write(f\"# Extrude height: {extrude_height}\\n\")\n            f.write(f\"# Total vertices: {len(all_vertices)}\\n\")\n            f.write(f\"# Total faces: {len(all_faces)}\\n\\n\")\n            \n            # Write vertices\n            for v in all_vertices:\n                f.write(f\"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}\\n\")\n            \n            f.write(\"\\n# Frame faces\\n\")\n            f.write(\"g hollow_shell_frames\\n\")\n            \n            # Write faces\n            for face in all_faces:\n                f.write(f\"f {face[0]} {face[1]} {face[2]} {face[3]}\\n\")\n        \n        print(f\"  ✓ Hollow shell created:\")\n        print(f\"    - {len(self.quad_patches)} square frames\")\n        print(f\"    - {len(all_vertices)} vertices\")\n        print(f\"    - {len(all_faces)} faces\")\n        print(f\"    - Saved to: {output_path}\")\n        \n        return output_path\n\n    def export_to_obj(self, output_path: str) -> str:\n        \"\"\"\n        Export grid as OBJ file (fallback if rhino3dm not available).\n        \n        Args:\n            output_path: Path for the OBJ file\n            \n        Returns:\n            Path to the saved file\n        \"\"\"\n        print(f\"\\nExporting grid to OBJ: {output_path}\")\n        \n        with open(output_path, 'w') as f:\n            f.write(\"# Grid Tessellation Export\\n\")\n            f.write(f\"# Total squares: {len(self.grid_squares)}\\n\")\n            f.write(f\"# Square size: {self.grid_params.get('square_size', 'N/A')}\\n\\n\")\n            \n            vertex_offset = 1  # OBJ is 1-indexed\n            \n            for square in self.grid_squares:\n                vertices = square.get(\"vertices\", [])\n                f.write(f\"# Square {square['id']}\\n\")\n                f.write(f\"g square_{square['id']}\\n\")\n                \n                # Write vertices\n                for v in vertices:\n                    f.write(f\"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}\\n\")\n                \n                # Write face\n                if len(vertices) == 4:\n                    f.write(f\"f {vertex_offset} {vertex_offset+1} {vertex_offset+2} {vertex_offset+3}\\n\")\n                elif len(vertices) == 3:\n                    f.write(f\"f {vertex_offset} {vertex_offset+1} {vertex_offset+2}\\n\")\n                \n                vertex_offset += len(vertices)\n                f.write(\"\\n\")\n        \n        print(f\"  ✓ Saved grid to {output_path}\")\n        return output_path\n    \n    def export_to_step(self, output_path: str) -> str:\n        \"\"\"\n        Export grid as STEP file for CAD compatibility.\n        Note: Requires additional libraries (OCC/cadquery)\n        \n        Args:\n            output_path: Path for the STEP file\n            \n        Returns:\n            Path to the saved file or None if not supported\n        \"\"\"\n        try:\n            import cadquery as cq\n            \n            print(f\"\\nExporting grid to STEP: {output_path}\")\n            \n            # Create workplane\n            result = cq.Workplane(\"XY\")\n            \n            for square in self.grid_squares:\n                vertices = square.get(\"vertices\", [])\n                if len(vertices) >= 3:\n                    # Create wire from vertices\n                    points = [(v[0], v[1], v[2]) for v in vertices]\n                    points.append(points[0])  # Close\n                    \n                    # Add as wire\n                    # Note: This is simplified - full implementation would create surfaces\n            \n            # Export\n            cq.exporters.export(result, output_path)\n            print(f\"  ✓ Saved to {output_path}\")\n            return output_path\n            \n        except ImportError:\n            print(\"cadquery not installed. STEP export not available.\")\n            print(\"Install with: pip install cadquery\")\n            return None\n    \n    def export_grid_data(self, output_path: str) -> str:\n        \"\"\"\n        Export grid data as JSON for programmatic access.\n        \n        Args:\n            output_path: Path for the JSON file\n            \n        Returns:\n            Path to the saved file\n        \"\"\"\n        print(f\"\\nExporting grid data to JSON: {output_path}\")\n        \n        data = {\n            \"mesh_info\": self.get_mesh_info(),\n            \"grid_params\": self.grid_params,\n            \"squares\": self.grid_squares\n        }\n        \n        with open(output_path, 'w') as f:\n            json.dump(data, f, indent=2)\n        \n        print(f\"  ✓ Saved grid data ({len(self.grid_squares)} squares)\")\n        return output_path\n    \n    def create_grasshopper_script(self, output_path: str) -> str:\n        \"\"\"\n        Generate a Grasshopper Python script that recreates the grid parametrically.\n        \n        This allows CAD designers to:\n        - Adjust square size with a slider\n        - Modify grid density\n        - Change square shapes\n        \n        Args:\n            output_path: Path for the .py Grasshopper script\n            \n        Returns:\n            Path to the saved file\n        \"\"\"\n        print(f\"\\nGenerating Grasshopper script: {output_path}\")\n        \n        script = '''\"\"\"\nGrasshopper Python Script - Parametric Surface Grid\nGenerated by mesh_to_cad_grid.py\n\nUsage in Grasshopper:\n1. Add a \"Python\" component\n2. Paste this script\n3. Connect inputs:\n   - mesh: The input mesh geometry\n   - square_size: Number slider (e.g., 0.1 to 10)\n   - density: Integer slider for sampling density\n4. Output: Grid curves ready for further manipulation\n\"\"\"\n\nimport Rhino.Geometry as rg\nimport rhinoscriptsyntax as rs\nimport math\n\n# Inputs from Grasshopper\n# mesh = input mesh\n# square_size = size of each square (float)\n# density = sampling density (int)\n\ndef get_tangent_vectors(normal):\n    \"\"\"Get two tangent vectors perpendicular to normal.\"\"\"\n    if abs(normal.X) < 0.9:\n        ref = rg.Vector3d(1, 0, 0)\n    else:\n        ref = rg.Vector3d(0, 1, 0)\n    \n    tangent1 = rg.Vector3d.CrossProduct(normal, ref)\n    tangent1.Unitize()\n    \n    tangent2 = rg.Vector3d.CrossProduct(normal, tangent1)\n    tangent2.Unitize()\n    \n    return tangent1, tangent2\n\ndef create_square_at_point(point, normal, size):\n    \"\"\"Create a square curve centered at point, tangent to surface.\"\"\"\n    t1, t2 = get_tangent_vectors(normal)\n    \n    half = size / 2.0\n    \n    v1 = point + half * t1 + half * t2\n    v2 = point - half * t1 + half * t2\n    v3 = point - half * t1 - half * t2\n    v4 = point + half * t1 - half * t2\n    \n    # Create closed polyline\n    pts = [rg.Point3d(v1), rg.Point3d(v2), rg.Point3d(v3), rg.Point3d(v4), rg.Point3d(v1)]\n    return rg.PolylineCurve([rg.Point3d(p) for p in pts])\n\n# Main execution\nsquares = []\n\nif mesh and square_size > 0:\n    # Get mesh faces and sample points\n    mesh_faces = mesh.Faces\n    mesh_normals = mesh.FaceNormals\n    \n    # Sample points on mesh surface\n    sample_count = density * density if density else 100\n    \n    # Use mesh face centers\n    for i in range(mesh_faces.Count):\n        if i % max(1, mesh_faces.Count // sample_count) == 0:\n            face = mesh_faces[i]\n            center = mesh_faces.GetFaceCenter(i)\n            normal = mesh_normals[i]\n            \n            sq = create_square_at_point(center, normal, square_size)\n            if sq:\n                squares.append(sq)\n\n# Output\na = squares  # Connect to Grasshopper output\n'''\n        \n        with open(output_path, 'w') as f:\n            f.write(script)\n        \n        print(f\"  ✓ Grasshopper script saved\")\n        print(f\"  Import into Grasshopper Python component for parametric control\")\n        return output_path\n\n\ndef process_mesh(mesh_path: str, output_dir: str, \n                 square_size: float = 1.0,\n                 method: str = \"matrix\",\n                 num_regions: int = 6,\n                 export_formats: List[str] = None,\n                 shell_thickness: float = 0.5,\n                 subdivisions: int = 2) -> Dict[str, str]:\n    \"\"\"\n    Process a mesh and export tessellated grid in multiple formats.\n    \n    Args:\n        mesh_path: Path to input mesh (GLB/OBJ/STL)\n        output_dir: Directory for output files\n        square_size: Size of grid squares\n        method: Tessellation method ('matrix', 'connected', 'uv', 'projection', 'subdivision')\n        num_regions: Number of surface regions to detect (for connected method)\n        export_formats: List of formats to export ('3dm', 'obj', 'json', 'gh')\n        shell_thickness: Thickness of Matrix skin shell (default 0.5)\n        subdivisions: Number of subdivisions per triangle for Matrix skin (default 2)\n        \n    Returns:\n        Dictionary of exported file paths\n    \"\"\"\n    if export_formats is None:\n        export_formats = ['3dm', 'obj', 'json', 'gh']\n    \n    # Create output directory\n    os.makedirs(output_dir, exist_ok=True)\n    \n    # Get base name\n    base_name = Path(mesh_path).stem\n    \n    # Initialize tessellator\n    tessellator = MeshGridTessellator(mesh_path)\n    \n    # Create grid based on method\n    if method == \"matrix\":\n        # MATRIX SKIN: Complete quad mesh wrapping the ENTIRE surface\n        print(\"\\n\" + \"=\"*60)\n        print(\"CREATING MATRIX SKIN - Complete Surface Wrapper\")\n        print(\"=\"*60)\n        print(f\"Subdivisions per triangle: {subdivisions}\")\n        print(f\"Shell thickness: {shell_thickness}\")\n        tessellator.create_matrix_skin(subdivisions=subdivisions, offset=0.0)\n    elif method == \"connected\":\n        # NEW: Create connected quad grid with shared vertices and regions\n        tessellator.create_connected_quad_grid(square_size=square_size)\n        tessellator.detect_surface_regions(num_regions=num_regions)\n    elif method == \"uv\":\n        tessellator.create_uv_grid(square_size=square_size)\n    elif method == \"projection\":\n        tessellator.create_projection_grid(square_size=square_size)\n    elif method == \"subdivision\":\n        subdivisions = max(1, int(5 / square_size))  # More subdivisions for smaller squares\n        tessellator.create_face_subdivision_grid(subdivisions=subdivisions)\n    else:\n        raise ValueError(f\"Unknown method: {method}\")\n    \n    # Export to requested formats\n    outputs = {}\n    \n    # MATRIX SKIN exports\n    if method == \"matrix\":\n        # Export Matrix skin (complete quad shell wrapping entire surface)\n        matrix_skin_path = os.path.join(output_dir, f\"{base_name}_matrix_skin.obj\")\n        outputs['matrix_skin'] = tessellator.export_matrix_skin(\n            matrix_skin_path, \n            shell_thickness=shell_thickness\n        )\n        \n        # SOLIDIFY: Create watertight solid shell for CAD/manufacturing\n        print(\"\\n\" + \"=\"*60)\n        print(\"CREATING WATERTIGHT SOLID FOR CAD DESIGNERS\")\n        print(\"=\"*60)\n        solid_result = tessellator.solidify_skin(thickness=shell_thickness, direction=\"inward\")\n        \n        if solid_result and tessellator.solid_mesh is not None:\n            solid_path = os.path.join(output_dir, f\"{base_name}_solid_shell.obj\")\n            outputs['solid_shell'] = tessellator.export_solid_mesh(solid_path)\n            \n            # Also export STL for 3D printing\n            stl_path = os.path.join(output_dir, f\"{base_name}_solid_shell.stl\")\n            tessellator.solid_mesh.export(stl_path)\n            outputs['solid_stl'] = stl_path\n            print(f\"✓ Exported STL for 3D printing: {stl_path}\")\n        \n        # Export wireframe version (tubes along edges)\n        wireframe_path = os.path.join(output_dir, f\"{base_name}_wireframe_skin.obj\")\n        wire_thickness = shell_thickness * 0.3  # Wire thickness proportional to shell\n        outputs['wireframe_skin'] = tessellator.export_wireframe_skin(\n            wireframe_path,\n            wire_thickness=wire_thickness\n        )\n        \n        # NOTE: Lattice export removed - matrix_skin is better for CAD editing\n        # The lattice creates massive files (10-15x more geometry) and is only\n        # useful for decorative see-through structures, not for editing designs.\n        # Use matrix_skin for adjusting prongs, settings, band thickness, etc.\n        \n        # Also export the raw quad skin as simple OBJ\n        raw_skin_path = os.path.join(output_dir, f\"{base_name}_quad_skin.obj\")\n        outputs['quad_skin'] = tessellator.export_connected_to_obj(raw_skin_path)\n        \n        print(f\"\\n✓ Matrix skin exported: {outputs.get('matrix_skin', 'N/A')}\")\n        print(f\"✓ Wireframe skin exported: {outputs.get('wireframe_skin', 'N/A')}\")\n        print(f\"✓ Raw quad skin exported: {outputs.get('quad_skin', 'N/A')}\")\n    \n    elif '3dm' in export_formats:\n        path = os.path.join(output_dir, f\"{base_name}_grid.3dm\")\n        if method == \"connected\":\n            # Use enhanced export for connected grid\n            outputs['3dm'] = tessellator.export_connected_to_rhino(path)\n        else:\n            outputs['3dm'] = tessellator.export_to_rhino(path)\n    \n    if 'obj' in export_formats:\n        path = os.path.join(output_dir, f\"{base_name}_grid.obj\")\n        if method == \"connected\":\n            outputs['obj'] = tessellator.export_connected_to_obj(path)\n        else:\n            outputs['obj'] = tessellator.export_to_obj(path)\n    \n    # NEW: Always export hollow shell for connected method\n    if method == \"connected\":\n        hollow_path = os.path.join(output_dir, f\"{base_name}_hollow_shell.obj\")\n        frame_thickness = square_size * 0.15  # 15% of square size\n        extrude_height = square_size * 0.08   # 8% of square size\n        outputs['hollow_shell'] = tessellator.export_hollow_shell(\n            hollow_path, \n            frame_thickness=frame_thickness,\n            extrude_height=extrude_height\n        )\n    \n    if 'json' in export_formats:\n        path = os.path.join(output_dir, f\"{base_name}_grid_data.json\")\n        outputs['json'] = tessellator.export_grid_data(path)\n    \n    if 'gh' in export_formats:\n        path = os.path.join(output_dir, f\"{base_name}_grasshopper.py\")\n        outputs['gh'] = tessellator.create_grasshopper_script(path)\n    \n    # Save parameters (enhanced with connectivity info)\n    params = {\n        \"input_mesh\": mesh_path,\n        \"square_size\": square_size,\n        \"method\": method,\n        \"mesh_info\": tessellator.get_mesh_info(),\n        \"grid_params\": tessellator.grid_params,\n        \"outputs\": outputs\n    }\n    \n    # Add connected grid info if available\n    if method == \"connected\":\n        params[\"connected_info\"] = {\n            \"shared_vertices\": len(tessellator.shared_vertices),\n            \"quad_patches\": len(tessellator.quad_patches),\n            \"regions\": {r_id: len(quads) for r_id, quads in tessellator.regions.items()},\n            \"region_layers\": tessellator.region_layers\n        }\n    \n    params_path = os.path.join(output_dir, f\"{base_name}_params.json\")\n    with open(params_path, 'w') as f:\n        json.dump(params, f, indent=2)\n    \n    return outputs\n\n\ndef main():\n    \"\"\"Command-line interface for mesh tessellation.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"Tessellate 3D mesh surface with parametric grid for CAD export\"\n    )\n    \n    parser.add_argument(\"mesh_path\", help=\"Path to input mesh (GLB/OBJ/STL)\")\n    parser.add_argument(\"-o\", \"--output\", default=\"./grid_output\",\n                        help=\"Output directory (default: ./grid_output)\")\n    parser.add_argument(\"-s\", \"--square-size\", type=float, default=1.0,\n                        help=\"Size of each grid square (default: 1.0)\")\n    parser.add_argument(\"-m\", \"--method\", \n                        choices=[\"matrix\", \"connected\", \"uv\", \"projection\", \"subdivision\"],\n                        default=\"matrix\", \n                        help=\"Tessellation method (default: matrix - complete surface wrapper)\")\n    parser.add_argument(\"-r\", \"--regions\", type=int, default=6,\n                        help=\"Number of surface regions to detect (default: 6)\")\n    parser.add_argument(\"-f\", \"--formats\", nargs=\"+\", \n                        default=[\"3dm\", \"obj\", \"json\", \"gh\"],\n                        help=\"Export formats (default: 3dm obj json gh)\")\n    parser.add_argument(\"-t\", \"--thickness\", type=float, default=0.5,\n                        help=\"Shell thickness for Matrix skin (default: 0.5)\")\n    parser.add_argument(\"--subdivisions\", type=int, default=2,\n                        help=\"Subdivisions per triangle for Matrix skin (default: 2)\")\n    \n    args = parser.parse_args()\n    \n    print(\"=\"*60)\n    print(\"MESH SURFACE TESSELLATION TO CAD GRID\")\n    print(\"=\"*60)\n    print(f\"Method: {args.method}\")\n    if args.method == \"matrix\":\n        print(\"  → MATRIX SKIN: Complete quad mesh wrapping ENTIRE surface\")\n        print(\"  → Like The Matrix - continuous grid covering everything\")\n        print(\"  → Hollow shell for CAD editing and mold manufacturing\")\n    elif args.method == \"connected\":\n        print(\"  → Connected quads with shared vertices\")\n        print(\"  → Auto-detected surface regions\")\n        print(\"  → NURBS surface patches\")\n    \n    outputs = process_mesh(\n        mesh_path=args.mesh_path,\n        output_dir=args.output,\n        square_size=args.square_size,\n        method=args.method,\n        num_regions=args.regions,\n        export_formats=args.formats,\n        shell_thickness=args.thickness,\n        subdivisions=args.subdivisions\n    )\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"EXPORT COMPLETE\")\n    print(\"=\"*60)\n    print(f\"Output directory: {args.output}\")\n    for fmt, path in outputs.items():\n        if path:\n            print(f\"  {fmt.upper()}: {path}\")\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"WHAT CAD DESIGNERS CAN DO NOW:\")\n    print(\"=\"*60)\n    if args.method == \"connected\":\n        print(\"✓ Patches share vertices - moving one affects neighbors\")\n        print(\"✓ Select entire regions (layers) for bulk editing\")\n        print(\"✓ Edit NURBS surfaces for smooth manufacturing\")\n        print(\"✓ Shared vertices appear as control points\")\n    print(\"\\nNext steps:\")\n    print(\"1. Open the .3dm file in Rhino\")\n    print(\"2. Toggle layers to see different surface regions\")\n    print(\"3. Select shared vertices (yellow points) to reshape multiple patches\")\n    print(\"4. Use the Grasshopper script for parametric control\")\n    print(\"5. Export clean geometry for mold manufacturing\")\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhino3dm",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}