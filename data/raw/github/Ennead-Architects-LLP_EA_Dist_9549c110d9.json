{
  "source_url": "https://github.com/Ennead-Architects-LLP/EA_Dist/blob/635520d89b8308b78eabf5b60bb80121d0fa3838/Apps/_rhino/Block.tab/simplify_blocks.button/simplify_blocks_left.py",
  "repo": "Ennead-Architects-LLP/EA_Dist",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Apps/_rhino/Block.tab/simplify_blocks.button/simplify_blocks_left.py",
  "instruction": "Simplify blocks left",
  "code": "\r\n__title__ = \"SimplifyBlocks\"\r\n__doc__ = \"This button does SimplifyBlocks when left click\"\r\n\r\n\r\nfrom EnneadTab import ERROR_HANDLE, LOG\r\nimport rhinoscriptsyntax as rs\r\nimport Rhino # pyright: ignore\r\nimport scriptcontext as sc\r\nimport Eto  # pyright: ignore\r\nimport time\r\nimport traceback\r\n\r\n@LOG.log(__file__, __title__)\r\n@ERROR_HANDLE.try_catch_error()\r\ndef simplify_blocks():\r\n    percent = get_reduction_percentage()\r\n    if percent is None:\r\n        return\r\n\r\n    # Allow user to select multiple block instances; keep one per unique definition\r\n    selected_ids = rs.GetObjects(message = \"Select block instances to simplify (one per definition will remain selected)\", \r\n                                 filter = rs.filter.instance, \r\n                                 select = True)\r\n\r\n    if not selected_ids:\r\n        return\r\n\r\n    # Map each definition name to the first encountered instance id for reselection\r\n    definition_name_to_instance = {}\r\n    for instance_id in selected_ids:\r\n        try:\r\n            definition_name = rs.BlockInstanceName(instance_id)\r\n        except Exception:\r\n            # Not a valid block instance; skip\r\n            continue\r\n\r\n        if not definition_name:\r\n            continue\r\n\r\n        if definition_name not in definition_name_to_instance:\r\n            definition_name_to_instance[definition_name] = instance_id\r\n\r\n    # For each unique definition name, simplify meshes in the definition itself\r\n    rs.EnableRedraw(False)\r\n    for def_name in list(definition_name_to_instance.keys()):\r\n        start_ts = time.time()\r\n        print(\"Simplifying block {}\".format(def_name))\r\n        before_mesh, before_faces, after_mesh, after_faces = simplify_definition_by_name(def_name, percent)\r\n        elapsed = time.time() - start_ts\r\n        print(\"Block {} simplified in {:.3f}s | meshes: {} -> {} | faces: {} -> {}\".format(def_name, elapsed, before_mesh, after_mesh, before_faces, after_faces))\r\n\r\n    # Update Rhino selection: one instance per unique block definition\r\n    rs.UnselectAllObjects()\r\n    rs.SelectObjects(list(definition_name_to_instance.values()))\r\n    if sc.doc:  # pyright: ignore[reportOptionalMemberAccess]\r\n        sc.doc.Views.Redraw()  # pyright: ignore[reportOptionalMemberAccess]\r\n\r\n\r\ndef simplify_definition_by_name(definition_name, percent):\r\n    \"\"\"Simplify meshes inside a block definition by its name using ModifyGeometry.\"\"\"\r\n    if not sc.doc:  # pyright: ignore[reportOptionalMemberAccess]\r\n        return 0, 0, 0, 0\r\n\r\n    idef = sc.doc.InstanceDefinitions.Find(definition_name, True)  # pyright: ignore[reportOptionalMemberAccess]\r\n    if not idef:\r\n        return 0, 0, 0, 0\r\n\r\n    members_arr = idef.GetObjects()\r\n    if not members_arr:\r\n        return 0, 0, 0, 0\r\n    members = [m for m in members_arr or []]  # pyright: ignore[reportGeneralTypeIssues]\r\n\r\n    # Compute baseline counts before modification\r\n    before_mesh_count = 0\r\n    before_face_count = 0\r\n    for m in members:\r\n        g0 = m.Geometry\r\n        if isinstance(g0, Rhino.Geometry.Mesh):\r\n            before_mesh_count += 1\r\n            if g0.Faces:\r\n                before_face_count += g0.Faces.Count\r\n\r\n    # Tolerances kept for potential future use; Reduction does not require them\r\n    _tol = sc.doc.ModelAbsoluteTolerance  # pyright: ignore[reportOptionalMemberAccess]\r\n    _ang_tol = sc.doc.ModelAngleToleranceRadians  # pyright: ignore[reportOptionalMemberAccess]\r\n\r\n    new_geometries = []\r\n    new_attributes = []\r\n    for member in members:\r\n        geometry = member.Geometry\r\n        if geometry is None:\r\n            continue\r\n        geometry = geometry.Duplicate()\r\n\r\n        # Reduce only if geometry is already a valid mesh with faces\r\n        if isinstance(geometry, Rhino.Geometry.Mesh):\r\n            # Work on a duplicated mesh object to avoid in-place state issues\r\n            mesh = geometry.DuplicateMesh() if hasattr(geometry, 'DuplicateMesh') else geometry.Duplicate()\r\n            if mesh and mesh.Faces and mesh.Faces.Count > 4 and mesh.IsValid:\r\n                before_faces = mesh.Faces.Count\r\n                # Parameterized reduction (compatible across Rhino versions)\r\n                target_faces = max(4, int(before_faces * max(0, min(100, percent)) / 100.0))\r\n                try:\r\n                    # Precondition mesh for reduction\r\n                    try:\r\n                        if hasattr(mesh, 'Ngons') and mesh.Ngons is not None:\r\n                            mesh.Ngons.Clear()\r\n                    except Exception:\r\n                        pass\r\n                    try:\r\n                        mesh.Faces.ConvertQuadsToTriangles(True, True)\r\n                    except Exception:\r\n                        pass\r\n                    try:\r\n                        mesh.Weld(Rhino.RhinoMath.ToRadians(180.0))\r\n                    except Exception:\r\n                        pass\r\n                    try:\r\n                        mesh.UnifyNormals()\r\n                    except Exception:\r\n                        pass\r\n                    mesh.Compact()\r\n\r\n                    if target_faces < before_faces:\r\n                        # Use stable overload: Reduce(target_count, normalize, accuracy, allow_distortion, threaded)\r\n                        ok = mesh.Reduce(target_faces, True, 8, False, True)  # pyright: ignore[reportGeneralTypeIssues]\r\n                        if (not ok) or (mesh.Faces and mesh.Faces.Count >= before_faces):\r\n                            ok = mesh.Reduce(target_faces, True, 10, False, True)  # pyright: ignore[reportGeneralTypeIssues]\r\n                            if (not ok) or (mesh.Faces and mesh.Faces.Count >= before_faces):\r\n                                aggressive_target = max(4, int(before_faces * 0.3))\r\n                                mesh.Reduce(aggressive_target, True, 10, False, True)  # pyright: ignore[reportGeneralTypeIssues]\r\n                    mesh.Compact()\r\n                except Exception:\r\n                    print (traceback.format_exc())\r\n                geometry = mesh\r\n\r\n        new_geometries.append(geometry)\r\n        new_attributes.append(member.Attributes.Duplicate())\r\n\r\n    # RhinoCommon expects the definition index (int), not the Guid Id\r\n    _ok = sc.doc.InstanceDefinitions.ModifyGeometry(idef.Index, new_geometries, new_attributes)  # pyright: ignore[reportOptionalMemberAccess]\r\n\r\n    # Re-read from definition to confirm persisted result\r\n    idef_after = sc.doc.InstanceDefinitions.Find(definition_name, True)  # pyright: ignore[reportOptionalMemberAccess]\r\n    after_mesh_count = 0\r\n    after_face_count = 0\r\n    if idef_after:\r\n        members_after_arr = idef_after.GetObjects()\r\n        members_after = [m for m in members_after_arr or []]  # pyright: ignore[reportGeneralTypeIssues]\r\n        for m in members_after:\r\n            g1 = m.Geometry\r\n            if isinstance(g1, Rhino.Geometry.Mesh):\r\n                after_mesh_count += 1\r\n                if g1.Faces:\r\n                    after_face_count += g1.Faces.Count\r\n\r\n    return before_mesh_count, before_face_count, after_mesh_count, after_face_count\r\n\r\n\r\nclass ReductionDialog(Eto.Forms.Dialog):  # pyright: ignore[reportUnknownVariableType]\r\n    def __init__(self):\r\n        self.Title = \"Block Mesh Reduction\"\r\n        self.Resizable = False\r\n        self.Padding = Eto.Drawing.Padding(10)\r\n        self.Spacing = Eto.Drawing.Size(6, 6)\r\n        self.result_value = 50.0\r\n\r\n        self.slider = Eto.Forms.Slider()\r\n        self.slider.MinValue = 1\r\n        self.slider.MaxValue = 100\r\n        self.slider.Value = 50\r\n\r\n        self.value_label = Eto.Forms.Label(Text = \"{}%\".format(self.slider.Value))\r\n        self.slider.ValueChanged += self.on_value_changed\r\n\r\n        ok_btn = Eto.Forms.Button(Text = \"OK\")\r\n        cancel_btn = Eto.Forms.Button(Text = \"Cancel\")\r\n        ok_btn.Click += self.on_ok\r\n        cancel_btn.Click += self.on_cancel\r\n\r\n        layout = Eto.Forms.DynamicLayout()\r\n        layout.Padding = Eto.Drawing.Padding(5)\r\n        layout.Spacing = Eto.Drawing.Size(6, 6)\r\n        layout.BeginVertical()\r\n        layout.AddRow(Eto.Forms.Label(Text = \"Target face percentage\"))\r\n        layout.AddRow(self.slider, self.value_label)\r\n        layout.AddRow(None)\r\n        layout.AddRow(None, ok_btn, cancel_btn)\r\n        layout.EndVertical()\r\n        self.Content = layout\r\n\r\n    def on_value_changed(self, sender, e):\r\n        self.value_label.Text = \"{}%\".format(self.slider.Value)\r\n\r\n    def on_ok(self, sender, e):\r\n        try:\r\n            self.result_value = float(self.slider.Value)\r\n        except Exception:\r\n            self.result_value = 50.0\r\n        self.Close()\r\n\r\n    def on_cancel(self, sender, e):\r\n        self.result_value = None\r\n        self.Close()\r\n\r\n\r\ndef get_reduction_percentage():\r\n    dlg = ReductionDialog()\r\n    dlg.ShowModal(Rhino.UI.RhinoEtoApp.MainWindow)  # pyright: ignore[reportUnknownArgumentType]\r\n    try:\r\n        return float(dlg.result_value) if dlg.result_value is not None else None\r\n    except Exception:\r\n        return None\r\n\r\nif __name__ == \"__main__\":\r\n    simplify_blocks()\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}