{
  "source_url": "https://github.com/KeithSloan/ladybug_freeCAD/blob/7b40cdc3178b4a1d533375b21132a82c2cc05fa2/ladybug_freeCAD/command.py",
  "repo": "KeithSloan/ladybug_freeCAD",
  "repo_stars": 0,
  "repo_description": "Ladybug FreeCAD",
  "license": "AGPL-3.0",
  "filepath": "ladybug_freeCAD/command.py",
  "instruction": "Functions for dealing assisting with Rhino plugin commands.",
  "code": "\"\"\"Functions for dealing assisting with Rhino plugin commands.\"\"\"\nfrom __future__ import division\nimport os\nimport sys\nimport json\n\ntry:\n    import clr\n    import System\nexcept ImportError as e:  # No .NET being used\n    print('Failed to import CLR. Cannot access Pollination DLLs.\\n{}'.format(e))\n\ntry:\n    import Rhino\nexcept ImportError as e:\n    raise ImportError(\"Failed to import Rhino.\\n{}\".format(e))\n\ntry:\n    import scriptcontext as sc\nexcept ImportError:  # No Rhino doc is available.\n    print('Failed to import Rhino scriptcontext. Unable to access sticky.')\n\ntry:\n    from ladybug_geometry.geometry3d import Mesh3D\n    from ladybug.futil import unzip_file\n    from ladybug.config import folders\n    from ladybug.ddy import DDY\n    from ladybug.wea import Wea\n    from ladybug.epw import EPW\n    from ladybug.stat import STAT\n    from ladybug_display.visualization import AnalysisGeometry\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import ladybug:\\n\\t{}'.format(e))\n\nfrom .config import rhino_version, conversion_to_meters\nfrom .download import download_file\nfrom .fromgeometry import from_mesh3d\nfrom .bakegeometry import _get_attributes\nfrom .bakeobjects import bake_analysis, bake_context\n\n\ndef _pollination_rhino_dll_dir():\n    \"\"\"Get the directory in which the DLLs are installed.\"\"\"\n    install_dir = os.path.dirname(folders.ladybug_tools_folder)\n    rh_ver = str(rhino_version[0]) + '.0'\n    dll_dir = os.path.join(install_dir, 'pollination', 'plugin', rh_ver, 'Pollination')\n    if not os.path.isdir:\n        msg = 'No Pollination installation could be found for Rhino {}.'.format(rh_ver)\n        print(msg)\n        return None\n    return dll_dir\n\n\ndef import_pollination_core():\n    \"\"\"Import Pollination.Core from the dll or give a message if it is not found.\"\"\"\n    try:\n        import Core\n    except ImportError:  # the dll has not yet been added\n        # add the Pollination.Core DLL to the Common Language Runtime (CLR)\n        dll_dir = _pollination_rhino_dll_dir()\n        if dll_dir is None:\n            return None\n        pol_dll = os.path.join(dll_dir, 'Pollination.Core.dll')\n        if pol_dll not in sys.path:\n            sys.path.append(pol_dll)\n        clr.AddReference(\"Pollination.Core\")\n        import Core\n    return Core\n\n\ndef import_ladybug_display_schema():\n    \"\"\"Import LadybugDisplaySchema from the dll or give a message if it is not found.\"\"\"\n    try:\n        import LadybugDisplaySchema\n    except ImportError:  # the dll has not yet been added\n        # add the LadybugDisplaySchema DLL to the Common Language Runtime (CLR)\n        dll_dir = _pollination_rhino_dll_dir()\n        if dll_dir is None:\n            return None\n        pol_dll = os.path.join(dll_dir, 'LadybugDisplaySchema.dll')\n        if pol_dll not in sys.path:\n            sys.path.append(pol_dll)\n        clr.AddReference(\"LadybugDisplaySchema\")\n        import LadybugDisplaySchema\n    return LadybugDisplaySchema\n\n\ndef import_honeybee_ui():\n    \"\"\"Import Honeybee.UI.Rhino from the dll or give a message if it is not found.\"\"\"\n    try:\n        import Honeybee\n    except ImportError:  # the dll has not yet been added\n        # add the Honeybee.UI.Rhino DLL to the Common Language Runtime (CLR)\n        dll_dir = _pollination_rhino_dll_dir()\n        if dll_dir is None:\n            return None\n        pol_dll = os.path.join(dll_dir, 'Honeybee.UI.Rhino.dll')\n        if pol_dll not in sys.path:\n            sys.path.append(pol_dll)\n        clr.AddReference(\"Honeybee.UI.Rhino\")\n        import Honeybee\n    return Honeybee\n\n\ndef is_pollination_licensed():\n    \"\"\"Check if the installation of Pollination has an active license.\"\"\"\n    Core = import_pollination_core()\n    if not Core:\n        return False\n    # use the utility to check whether there is an active license\n    is_licensed, msg = Core.Utility.CheckIfLicensed()\n    if not is_licensed:\n        print(msg)\n    return is_licensed\n\n\ndef project_information():\n    \"\"\"Check if the installation of Pollination has an active license.\"\"\"\n    Core = import_pollination_core()\n    if not Core:\n        return None\n    return Core.ModelEntity.CurrentModel.ProjectInfo\n\n\ndef current_units(lbt_data_type):\n    \"\"\"Get the currently-assigned units for a given data type.\"\"\"\n    Honeybee = import_honeybee_ui()\n    from Honeybee.UI import Units\n    unit_map = {\n        'm': Units.UnitType.Length,\n        'm2': Units.UnitType.Area,\n        'm3': Units.UnitType.Volume,\n        'C': Units.UnitType.Temperature,\n        'dC': Units.UnitType.TemperatureDelta,\n        'W': Units.UnitType.Power,\n        'W/m2': Units.UnitType.PowerDensity,\n        'kWh': Units.UnitType.Energy,\n        'kWh/m2': Units.UnitType.EnergyIntensity,\n        'm3/s': Units.UnitType.AirFlowRate,\n        'm3/s-m2': Units.UnitType.AirFlowRateArea,\n        'm/s': Units.UnitType.Speed,\n        'kg': Units.UnitType.Mass,\n        'kg/s': Units.UnitType.MassFlow,\n        'lux': Units.UnitType.Illuminance,\n        'cd/m2': Units.UnitType.Luminance,\n        'Pa': Units.UnitType.Pressure\n    }\n    try:\n        dot_net_units = unit_map[lbt_data_type.units[0]]\n    except KeyError:  # the data type does not exist in .NET\n        return lbt_data_type.units[0]\n    current_settings = Units.CustomUnitSettings\n    unit = Units.ToUnitsNetEnum(current_settings[dot_net_units])\n    unit_str = Units.GetAbbreviation(unit)\n    unit_str = _convert_unit_abbrev(unit_str)\n    return unit_str if unit_str in lbt_data_type.units else lbt_data_type.units[0]\n\n\ndef local_processor_count():\n    \"\"\"Get an integer for the number of processors on this machine.\n\n    If, for whatever reason, the number of processors could not be sensed,\n    None will be returned.\n    \"\"\"\n    return System.Environment.ProcessorCount\n\n\ndef recommended_processor_count():\n    \"\"\"Get an integer for the recommended number of processors for parallel calculation.\n\n    This should be one less than the number of processors available on this machine\n    unless the machine has only one processor, in which case 1 will be returned.\n    If, for whatever reason, the number of processors could not be sensed, a value\n    of 1 will be returned.\n    \"\"\"\n    cpu_count = local_processor_count()\n    return 1 if cpu_count is None or cpu_count <= 1 else cpu_count - 1\n\n\ndef _download_weather(weather_URL):\n    \"\"\"Download a weather URL with a check if it's already in the default folder.\"\"\"\n    # first check wether the url is actually a local path\n    if not weather_URL.lower().startswith('http'):\n        if weather_URL.lower().endswith('.epw') and os.path.isfile(weather_URL):\n            return weather_URL\n        assert os.path.isdir(weather_URL), 'Input weather URL is not a web ' \\\n            'address nor a local folder directory.'\n        for fp in os.listdir(weather_URL):\n            if fp.lower().endswith('.epw'):  # file type found\n                return os.path.join(weather_URL, fp)\n\n    _def_folder = folders.default_epw_folder\n    if weather_URL.lower().endswith('.zip'):  # one building URL type\n        _folder_name = weather_URL.split('/')[-1][:-4]\n    else:  # dept of energy URL type\n        _folder_name = weather_URL.split('/')[-2]\n    epw_path = os.path.join(_def_folder, _folder_name, _folder_name + '.epw')\n    if not os.path.isfile(epw_path):\n        zip_file_path = os.path.join(\n            _def_folder, _folder_name, _folder_name + '.zip')\n        download_file(weather_URL, zip_file_path, True)\n        unzip_file(zip_file_path)\n    return epw_path\n\n\ndef setup_epw_input():\n    \"\"\"Setup the request for an EPW input and check for any previously set EPW.\"\"\"\n    epw_input_request = Rhino.Input.Custom.GetString()\n    epw_input_request.SetCommandPrompt('Select an EPW file path or URL')\n    epw_input_request.AcceptNothing(True)\n    if 'lbt_epw' in sc.sticky:\n        epw_input_request.SetDefaultString(sc.sticky['lbt_epw'])\n    else:  # check if the project information has an EPW associated with it\n        proj_info = project_information()\n        if proj_info is not None and proj_info.WeatherUrls is not None \\\n                and len(proj_info.WeatherUrls) > 0:\n            epw_path = _download_weather(proj_info.WeatherUrls[0])\n            epw_input_request.SetDefaultString(os.path.basename(epw_path))\n    return epw_input_request\n\n\ndef retrieve_epw_input(epw_input_request, command_options, option_values):\n    \"\"\"Retrieve an EPW input from the command line.\n\n    Args:\n        epw_input_request: The Rhino.Input.Custom.GetString object that was used\n            to setup the EPW input request.\n        command_options: A list of Rhino.Input.Custom.Option objects for the\n            options that were included with the EPW request. The values for these\n            options will be retrieved along with the EPW.\n        option_values: A list of values for each option, which will be updated\n            based on the user input.\n\n    Returns:\n        The file path to the EPW as a text string.\n    \"\"\"\n    # separate the list options from the others\n    list_opt_indices = [i + 1 for i, opt in enumerate(command_options)\n                        if isinstance(opt, (tuple, list))]\n\n    # get the weather file and all options\n    epw_path = None\n    while True:\n        # This will prompt the user to input an EPW and visualization options\n        get_epw = epw_input_request.Get()\n        if get_epw == Rhino.Input.GetResult.String:\n            epw_path = epw_input_request.StringResult()\n            for i, opt in enumerate(command_options):\n                if not isinstance(opt, (tuple, list)):\n                    option_values[i] = opt.CurrentValue\n        elif get_epw == Rhino.Input.GetResult.Option:\n            opt_ind = epw_input_request.OptionIndex()\n            if opt_ind in list_opt_indices:\n                option_values[opt_ind - 1] = \\\n                    epw_input_request.Option().CurrentListOptionIndex\n            continue\n        elif get_epw == Rhino.Input.GetResult.Cancel:\n            return None\n        break\n\n    # process the EPW file path or URL\n    if not epw_path:\n        print('No EPW file was selected')\n        return None\n    _def_folder = folders.default_epw_folder\n    if epw_path.startswith('http'):  # download the EPW file\n        epw_path = _download_weather(epw_path)\n        sc.sticky['lbt_epw'] = os.path.basename(epw_path)\n    elif not os.path.isfile(epw_path):\n        possible_file = os.path.basename(epw_path)[:-4] \\\n                if epw_path.lower().endswith('.epw') else epw_path\n        proj_info = project_information()\n        if proj_info is not None and proj_info.WeatherUrls is not None \\\n                and len(proj_info.WeatherUrls) > 0:\n            epw_file_path = _download_weather(proj_info.WeatherUrls[0])\n            if possible_file in epw_file_path:\n                epw_path = epw_file_path\n        else:\n            epw_path = os.path.join(_def_folder, possible_file, possible_file + '.epw')\n        if not os.path.isfile(epw_path):\n            print('Selected EPW file at does not exist at: {}'.format(epw_path))\n            return\n        sc.sticky['lbt_epw'] = possible_file + '.epw'\n    else:\n        sc.sticky['lbt_epw'] = epw_path\n    return epw_path\n\n\ndef setup_design_day_input():\n    \"\"\"Setup the request for a DDY, STAT, or EPW to get a design day.\"\"\"\n    url_input_request = Rhino.Input.Custom.GetString()\n    url_input_request.SetCommandPrompt(\n        'Select a weather URL or DDY/STAT/EPW file path '\n        'from which a design day will be derived.')\n    url_input_request.AcceptNothing(True)\n    if 'lbt_url' in sc.sticky:\n        url_input_request.SetDefaultString(sc.sticky['lbt_url'])\n    else:  # check if the project information has an EPW associated with it\n        proj_info = project_information()\n        if proj_info is not None and proj_info.WeatherUrls is not None \\\n                and len(proj_info.WeatherUrls) > 0:\n            epw_path = _download_weather(proj_info.WeatherUrls[0])\n            url_input_request.SetDefaultString(\n                os.path.basename(epw_path).replace('.epw', ''))\n    return url_input_request\n\n\ndef retrieve_cooling_design_day_input(url_input_request, command_options, option_values):\n    \"\"\"Retrieve the best cooling design day from what is available from a URL.\n\n    Args:\n        url_input_request: The Rhino.Input.Custom.GetString object that was used\n            to setup the URL input request. This input can be the file path to\n            an DDY, STAT or EPW file in which case the design day is taken directly\n            from the file. When a URL is used, the STAT file will first be searched\n            as it typically contains values for the most accurate solar model.\n            If no values are found there, the design day will be pulled from the\n            DDY. If there is no clear best design day in the DDY, it will be\n            derived from the EPW data.\n        command_options: A list of Rhino.Input.Custom.Option objects for the\n            options that were included with the URL request. The values for these\n            options will be retrieved along with the design day.\n        option_values: A list of values for each option, which will be updated\n            based on the user input.\n\n    Returns:\n        A tuple with two values.\n\n        -   design_day: A ladybug DesignDay object for the best cooling design\n            day that was determined from the input.\n\n        -   wea: A Wea object with annual hourly data collection of clear sky\n            radiation that represents design days throughout the year.\n    \"\"\"\n    # separate the list options from the others\n    list_opt_indices = [i + 1 for i, opt in enumerate(command_options)\n                        if isinstance(opt, (tuple, list))]\n\n    # get the weather file and all options\n    url_path = None\n    while True:\n        # This will prompt the user to input an EPW and visualization options\n        get_url = url_input_request.Get()\n        if get_url == Rhino.Input.GetResult.String:\n            url_path = url_input_request.StringResult()\n            for i, opt in enumerate(command_options):\n                if not isinstance(opt, (tuple, list)):\n                    option_values[i] = opt.CurrentValue\n        elif get_url == Rhino.Input.GetResult.Option:\n            opt_ind = url_input_request.OptionIndex()\n            if opt_ind in list_opt_indices:\n                option_values[opt_ind - 1] = \\\n                    url_input_request.Option().CurrentListOptionIndex\n            continue\n        elif get_url == Rhino.Input.GetResult.Cancel:\n            return None, None\n        break\n\n    # process the file path or URL\n    if not url_path:\n        print('No URL or file was selected')\n        return None, None\n    epw_path, stat_path, ddy_path = None, None, None\n    _def_folder = folders.default_epw_folder\n    if url_path.startswith('http'):  # download the EPW file\n        epw_path = _download_weather(url_path)\n        stat_path = epw_path.replace('.epw', '.stat')\n        ddy_path = epw_path.replace('.epw', '.ddy')\n        sc.sticky['lbt_url'] = os.path.basename(epw_path.replace('.epw', ''))\n    elif not os.path.isfile(url_path):\n        possible_file = os.path.basename(url_path)[:-4] \\\n                if url_path.lower().endswith('.epw') else url_path\n        proj_info = project_information()\n        if proj_info is not None and proj_info.WeatherUrls is not None \\\n                and len(proj_info.WeatherUrls) > 0:\n            epw_file_path = _download_weather(proj_info.WeatherUrls[0])\n            if possible_file in epw_file_path:\n                epw_path = epw_file_path\n        else:\n            epw_path = os.path.join(_def_folder, possible_file, possible_file + '.epw')\n        stat_path = epw_path.replace('.epw', '.stat')\n        ddy_path = epw_path.replace('.epw', '.ddy')\n        if not os.path.isfile(epw_path):\n            print('Selected EPW file at does not exist at: {}'.format(epw_path))\n            return\n        sc.sticky['lbt_url'] = url_path\n    elif url_path.endswith('.ddy'):\n        ddy_path = url_path\n    elif url_path.endswith('.epw'):\n        epw_path = url_path\n    elif url_path.endswith('.stat'):\n        stat_path = url_path\n    else:\n        return None, None\n\n    # process the possible files into the best design day\n    if stat_path is not None:\n        stat_obj = STAT(stat_path)\n        des_day = stat_obj.annual_cooling_design_day_004\n        try:  # first see if we can get the values from monthly optical depths\n            wea = Wea.from_stat_file(stat_path)\n        except Exception:  # no optical data was found; use the original clear sky\n            wea = Wea.from_ashrae_clear_sky(stat_obj.location)\n        return des_day, wea\n    if ddy_path is not None:\n        ddy_obj = DDY.from_ddy_file(ddy_path)\n        des_days = []\n        for dday in ddy_obj:\n            if '.4%' in dday.name:\n                des_days.append(dday)\n        if len(des_days) != 0:\n            des_days.sort(key=lambda x: x.dry_bulb_condition, reverse=True)\n            des_day = des_days[0]\n            wea = Wea.from_ashrae_clear_sky(ddy_obj.location)\n            return des_day, wea\n    if epw_path is not None:\n        epw_obj = EPW(epw_path)\n        des_day = stat_obj.annual_cooling_design_day_004\n        if des_day is None:\n            des_day = epw_obj.approximate_design_day()\n        wea = Wea.from_ashrae_clear_sky(epw_obj.location)\n        return des_day, wea\n    return None, None\n\n\ndef add_north_option(input_request):\n    \"\"\"Add a North option to an input request.\n\n    Args:\n        input_request: A Rhino Command Input such as that obtained from the\n            setup_epw_input function or the Rhino.Input.Custom.GetString\n            constructor.\n\n    Returns:\n        A tuple with two values.\n\n        -   north_option: The Option object for the North input.\n\n        -   north_value: The value of the north.\n    \"\"\"\n    if 'lbt_north' in sc.sticky:\n        north_value = sc.sticky['lbt_north']\n    else:\n        proj_info = project_information()\n        if proj_info is not None and proj_info.North is not None:\n            north_value = float(proj_info.North)\n        else:\n            north_value = 0\n    north_option = Rhino.Input.Custom.OptionDouble(north_value, -360, 360)\n    description = 'North - the counterclockwise difference between true North and the ' \\\n        'Y-axis in degrees (90:West, -90:East)'\n    input_request.AddOptionDouble('North', north_option, description)\n    return north_option, north_value\n\n\ndef add_month_day_hour_options(\n        input_request, default_inputs=(12, 21, 0, 23), sticky_key=None):\n    \"\"\"Add a options for Month, Day, and Hour to an input request.\n\n    Args:\n        input_request: A Rhino Command Input such as that obtained from the\n            setup_epw_input function or the Rhino.Input.Custom.GetString\n            constructor.\n        default_inputs: The default input month, day, start_hour and end_hour.\n            A value of 0 for month or day denotes that all values of a given\n            month, day and hour are used. For the start_hour and end_hour,\n            the values should be between 0 and 23 where 0 denotes\n            midnight. (Default: (12, 21, 0, 23)).\n        sticky_key: An optional sticky key, which will be used to to pull\n            previously set values from sticky. (eg. direct_sun).\n\n    Returns:\n        A tuple with two values.\n\n        -   mdh_options: A tuple of the Option objects for the month, day and\n            hour inputs.\n\n        -   mdh_values: The value associated with each month, day and hour.\n    \"\"\"\n    if sticky_key is not None:\n        month_key = 'lbt_{}_month'.format(sticky_key)\n        month_i_ = sc.sticky[month_key] if month_key in sc.sticky else default_inputs[0]\n        day_key = 'lbt_{}_day'.format(sticky_key)\n        day_ = sc.sticky[day_key] if day_key in sc.sticky else default_inputs[1]\n        sthr_key = 'lbt_{}_start_hour'.format(sticky_key)\n        st_hr_ = sc.sticky[sthr_key] if sthr_key in sc.sticky else default_inputs[2]\n        endhr_key = 'lbt_{}_end_hour'.format(sticky_key)\n        end_hr_ = sc.sticky[endhr_key] if endhr_key in sc.sticky else default_inputs[3]\n    else:\n        month_i_, day_, st_hr_, end_hr_ = default_inputs\n\n    month_i_ = 0 if month_i_ < 0 else month_i_\n    month_option = ('All', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n                    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', 'DecMarJun')\n    input_request.AddOptionList('Month', month_option, month_i_)\n\n    day_option = Rhino.Input.Custom.OptionInteger(day_, 0, 31)\n    description = 'Day - day of the month [1-31]. Use 0 to specify all days'\n    input_request.AddOptionInteger('Day', day_option, description)\n\n    start_hr_option = Rhino.Input.Custom.OptionDouble(st_hr_, 0, 23)\n    description = 'StartHour - start hour of the day [0-23]. Decimals accepted.'\n    input_request.AddOptionDouble('StartHour', start_hr_option, description)\n\n    end_hr_option = Rhino.Input.Custom.OptionDouble(end_hr_, 0, 23)\n    description = 'EndHour - start hour of the day [0-23]. Decimals accepted.'\n    input_request.AddOptionDouble('EndHour', end_hr_option, description)\n\n    return [month_option, day_option, start_hr_option, end_hr_option], \\\n        [month_i_, day_, st_hr_, end_hr_]\n\n\ndef add_legend_min_max_options(input_request):\n    \"\"\"Add legend min and max outputs to an input request.\n\n    Args:\n        input_request: A Rhino Command Input such as that obtained from the\n            setup_epw_input function or the Rhino.Input.Custom.GetString\n            constructor.\n\n    Returns:\n        A tuple with two values.\n\n        -   options: The two Option objects for the legend min and max inputs.\n\n        -   values: The two values of the min and max.\n    \"\"\"\n    min_val, max_val = float('-inf'), float('+inf')\n    min_option = Rhino.Input.Custom.OptionDouble(min_val)\n    input_request.AddOptionDouble('MinLegend', min_option)\n    max_option = Rhino.Input.Custom.OptionDouble(max_val)\n    input_request.AddOptionDouble('MaxLegend', max_option)\n    return [min_option, max_option], [min_val, max_val]\n\n\ndef retrieve_geometry_input(geo_input_request, command_options, option_values):\n    \"\"\"Retrieve a geometry input from the command line.\n\n    Args:\n        geo_input_request: The Rhino.Input.Custom.GetObject object that was used\n            to setup the geometry input request. Note that this input does not\n            need any filters set on it as this method will assign them.\n        command_options: A list of Rhino.Input.Custom.Option objects for the\n            options that were included with the geometry request. The values for\n            these options will be retrieved along with the geometry.\n        option_values: A list of values for each option, which will be updated\n            based on the user input.\n\n    Returns:\n        A list of geometry objects. Will be None if the operation was canceled.\n    \"\"\"\n    # add the filters and  attributes related to geometry selection\n    geo_filter = Rhino.DocObjects.ObjectType.Surface | \\\n        Rhino.DocObjects.ObjectType.PolysrfFilter | \\\n        Rhino.DocObjects.ObjectType.Mesh\n    geo_input_request.GeometryFilter = geo_filter\n    geo_input_request.GroupSelect = True\n    geo_input_request.SubObjectSelect = False\n    geo_input_request.EnableClearObjectsOnEntry(False)\n    geo_input_request.EnableUnselectObjectsOnExit(False)\n    geo_input_request.DeselectAllBeforePostSelect = False\n    geo_input_request.AcceptNothing(True)\n\n    # request the analysis geometries from the user\n    have_preselected_objects = False\n    while True:\n        res = geo_input_request.GetMultiple(1, 0)\n        if res == Rhino.Input.GetResult.Option:\n            geo_input_request.EnablePreSelect(False, True)\n            continue\n        elif res != Rhino.Input.GetResult.Object:\n            if res == Rhino.Input.GetResult.Cancel:\n                return None\n            return []\n        if geo_input_request.ObjectsWerePreselected:\n            have_preselected_objects = True\n            geo_input_request.EnablePreSelect(False, True)\n            continue\n        for i, opt in enumerate(command_options):\n            option_values[i] = opt.CurrentValue\n        break\n\n    # process any preselected objects before the command ran\n    if have_preselected_objects:\n        # Normally, pre-selected objects will remain selected, when a\n        # command finishes, and post-selected objects will be unselected.\n        # This this way of picking, it is possible to have a combination\n        # of pre-selected and post-selected. So, to make sure everything\n        # \"looks the same\", lets unselect everything before finishing\n        # the command.\n        for i in range(0, geo_input_request.ObjectCount):\n            rhino_obj = geo_input_request.Object(i).Object()\n            if rhino_obj is not None:\n                rhino_obj.Select(False)\n        sc.doc.Views.Redraw()\n\n    # get the actual geometry from the selection\n    obj_table = Rhino.RhinoDoc.ActiveDoc.Objects\n    geometry = []\n    for get_obj in geo_input_request.Objects():\n        geometry.append(obj_table.Find(get_obj.ObjectId).Geometry)\n    return geometry\n\n\ndef study_geometry_request(study_name=None):\n    \"\"\"Prompt the user for study geometry that requires a grid size and offset.\n\n    Args:\n        study_name: An optional text string for the name of the study (eg. Direct Sun).\n\n    Returns:\n        A tuple with three values.\n\n        -   geometry: The Rhino Surfaces, Polysurfaces and/or Meshes that were selected.\n\n        -   grid_size: A number for the grid size that the user selected.\n\n        -   offset: A number for the offset that the user selected.\n    \"\"\"\n    # setup the request to get the analysis geometry from the scene\n    get_geo = Rhino.Input.Custom.GetObject()\n    base_msg = 'Select surfaces, polysurfaces, or meshes'\n    msg = '{} on which {} will be studied'.format(base_msg, study_name) \\\n        if study_name is not None else '{} to study.'.format(base_msg)\n    get_geo.SetCommandPrompt(msg)\n\n    # add the options for the geometry\n    grid_size = sc.sticky['lbt_study_grid_size'] if 'lbt_study_grid_size' in sc.sticky \\\n        else int(1 / conversion_to_meters())\n    gs_option = Rhino.Input.Custom.OptionDouble(grid_size, True, 0)\n    description = 'GridSize - distance value for the size of grid cells at which ' \\\n        ' geometry will be subdivided'\n    get_geo.AddOptionDouble('GridSize', gs_option, description)\n\n    offset_dist = sc.sticky['lbt_study_offset'] if 'lbt_study_offset' in sc.sticky \\\n        else round((0.1 / conversion_to_meters()), 2)\n    off_option = Rhino.Input.Custom.OptionDouble(offset_dist, True, 0)\n    description = 'Offset - distance value from the input geometry at which the ' \\\n        'analysis will occur'\n    get_geo.AddOptionDouble('Offset', off_option, description)\n\n    # request the geometry from the user\n    command_options = [gs_option, off_option]\n    option_values = [grid_size, offset_dist]\n    geometry = retrieve_geometry_input(get_geo, command_options, option_values)\n    grid_size, offset_dist = option_values\n\n    # update the sticky values for grid size and offset\n    sc.sticky['lbt_study_grid_size'] = grid_size\n    sc.sticky['lbt_study_offset'] = offset_dist\n\n    return geometry, grid_size, offset_dist\n\n\ndef add_to_document_request(geometry_name=None):\n    \"\"\"Prompt the user for whether geometry should be added to the Rhino document.\n\n    Returns:\n        A boolean value for whether the geometry should be added to the document (True)\n        or not (False).\n    \"\"\"\n    gres = Rhino.Input.Custom.GetString()\n    study_name = geometry_name if geometry_name is not None else 'Study'\n    msg = '{} complete! Hit ENTER when done. Add the ' \\\n        'geometry to the document?'.format(study_name)\n    gres.SetCommandPrompt(msg)\n    gres.SetDefaultString('Add?')\n    bake_result = False\n    result_option = Rhino.Input.Custom.OptionToggle(False, 'No', 'Yes')\n    gres.AddOptionToggle('AddToDoc', result_option)\n    while True:\n        get_res = gres.Get()\n        if get_res == Rhino.Input.GetResult.String:\n            bake_result = result_option.CurrentValue\n        elif get_res == Rhino.Input.GetResult.Cancel:\n            bake_result = False\n            break\n        else:\n            continue\n        break\n    return bake_result\n\n\ndef bake_pollination_vis_set(vis_set, bake_3d_legend=False):\n    \"\"\"Bake a VisualizationSet using Pollination Rhino libraries for an editable legend.\n    \"\"\"\n    Core = import_pollination_core()\n    LadybugDisplaySchema = import_ladybug_display_schema()\n    if not Core or not LadybugDisplaySchema:\n        return\n    for geo in vis_set.geometry:\n        if isinstance(geo, AnalysisGeometry):\n            amsh_typs = ('faces', 'vertices')\n            if isinstance(geo.geometry[0], Mesh3D) and geo.matching_method in amsh_typs:\n                layer_name = vis_set.display_name if len(vis_set.geometry) == 1 else \\\n                    '{}::{}'.format(vis_set.display_name, geo.display_name)\n                for data in geo.data_sets:\n                    # translate Mesh3D into Rhino Mesh\n                    if len(geo.geometry) == 1:\n                        mesh = from_mesh3d(geo.geometry[0])\n                    else:\n                        mesh = Rhino.Geometry.Mesh()\n                        for mesh_i in geo.geometry:\n                            mesh.Append(from_mesh3d(mesh_i))\n                    # translate visualization data into .NET VisualizationData\n                    data_json = json.dumps(data.to_dict())\n                    vis_data = LadybugDisplaySchema.VisualizationData.FromJson(data_json)\n                    a_mesh = Core.Objects.AnalysisMeshObject(mesh, vis_data)\n                    # add it to the Rhino document\n                    doc = Rhino.RhinoDoc.ActiveDoc\n                    sub_layer_name = layer_name \\\n                        if len(geo.data_sets) == 1 or data.data_type is None else \\\n                        '{}::{}'.format(layer_name, data.data_type.name)\n                    a_mesh.Id = doc.Objects.AddMesh(\n                        mesh, _get_attributes(sub_layer_name))\n                    current_model = Core.ModelEntity.CurrentModel\n\n                    def do_act():\n                        pass\n\n                    def undo_act():\n                        pass\n                    am_list = System.Array[Core.Objects.AnalysisMeshObject]([a_mesh])\n                    current_model.Add(doc, am_list, do_act, undo_act)\n            else:\n                bake_analysis(\n                    geo, vis_set.display_name, bake_3d_legend,\n                    vis_set.min_point, vis_set.max_point)\n        else:\n            bake_context(geo, vis_set.display_name)\n\n\ndef _convert_unit_abbrev(unit_str):\n    \"\"\"Replace all superscripts and other crud used in the .NET unit abbreviations.\"\"\"\n    clean_chars = []\n    for c in unit_str:\n        c_ord = ord(c)\n        if c_ord < 128:  # ASCII character\n            clean_chars.append(c)\n        elif c_ord == 178:  # superscript 2\n            clean_chars.append('2')\n        elif c_ord == 179:  # superscript 3\n            clean_chars.append('3')\n        elif c_ord == 183:  # multiplication dot\n            clean_chars.append('-')\n        elif c_ord == 176:  # unnecessary degree symbol\n            pass\n        elif c_ord == 8710:  # delta symbol\n            clean_chars.append('d')\n        else:\n            print('Character \"{}\" with ordinal {} was not decoded.'.format(c, c_ord))\n    unit_str = ''.join(clean_chars)\n    if unit_str == 'lx':\n        return 'lux'\n    return unit_str.replace(' ', '').replace('BTU', 'Btu')\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}