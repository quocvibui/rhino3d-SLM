{
  "source_url": "https://github.com/ksteinfe/decodes/blob/b876d6d01ea23ccbf4558182582a822b008cf2b8/src/decodes/io/rhinoscript/curve.py",
  "repo": "ksteinfe/decodes",
  "repo_stars": 43,
  "repo_description": "a platform agnostic generative design library for 3d designers",
  "license": "GPL-3.0",
  "filepath": "src/decodes/io/rhinoscript/curve.py",
  "instruction": null,
  "code": "import scriptcontext\nfrom . import utility as rhutil\nimport Rhino\nimport math\nimport System.Guid, System.Array, System.Enum\n\ndef AddArc(plane, radius, angle_degrees):\n    \"\"\"Adds an arc curve to the document\n    Parameters:\n      plane = plane on which the arc will lie. The origin of the plane will be\n        the center point of the arc. x-axis of the plane defines the 0 angle\n        direction.\n      radius = radius of the arc\n      angle_degrees = interval of arc\n    Returns:\n      id of the new curve object\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    radians = math.radians(angle_degrees)\n    arc = Rhino.Geometry.Arc(plane, radius, radians)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add arc to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddArc3Pt(start, end, point_on_arc):\n    \"\"\"Adds a 3-point arc curve to the document\n    Parameters:\n      start, end = endpoints of the arc\n      point_on_arc = a point on the arc\n    Returns:\n      id of the new curve object\n    \"\"\"\n    start = rhutil.coerce3dpoint(start, True)\n    end = rhutil.coerce3dpoint(end, True)\n    pton = rhutil.coerce3dpoint(point_on_arc, True)\n    arc = Rhino.Geometry.Arc(start, pton, end)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add arc to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddArcPtTanPt(start, direction, end):\n    \"\"\"Adds an arc curve, created from a start point, a start direction, and an\n    end point, to the document\n    Returns:\n      id of the new curve object\n    \"\"\"\n    start = rhutil.coerce3dpoint(start, True)\n    direction = rhutil.coerce3dvector(direction, True)\n    end = rhutil.coerce3dpoint(end, True)\n    arc = Rhino.Geometry.Arc(start, direction, end)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add arc to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCircle(plane_or_center, radius):\n    \"\"\"Adds a circle curve to the document\n    Parameters:\n      plane_or_center = plane on which the circle will lie. If a point is\n        passed, this will be the center of the circle on the active\n        construction plane\n      radius = the radius of the circle\n    Returns:\n      id of the new curve object\n    \"\"\"\n    rc = None\n    plane = rhutil.coerceplane(plane_or_center, False)\n    if plane:\n        circle = Rhino.Geometry.Circle(plane, radius)\n        rc = scriptcontext.doc.Objects.AddCircle(circle)\n    else:\n        center = rhutil.coerce3dpoint(plane_or_center, True)\n        view = scriptcontext.doc.Views.ActiveView\n        plane = view.ActiveViewport.ConstructionPlane()\n        plane.Origin = center\n        circle = Rhino.Geometry.Circle(plane, radius)\n        rc = scriptcontext.doc.Objects.AddCircle(circle)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add circle to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCircle3Pt(first, second, third):\n    \"\"\"Adds a 3-point circle curve to the document\n    Parameters:\n      first, second, third = points on the circle\n    Returns:\n      id of the new curve object\n    \"\"\"\n    start = rhutil.coerce3dpoint(first, True)\n    end = rhutil.coerce3dpoint(second, True)\n    third = rhutil.coerce3dpoint(third, True)\n    circle = Rhino.Geometry.Circle(start, end, third)\n    rc = scriptcontext.doc.Objects.AddCircle(circle)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add circle to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCurve(points, degree=3):\n    \"\"\"Adds a control points curve object to the document\n    Parameters:\n      points = a list of points\n      degree[opt] = degree of the curve\n    Returns:\n      id of the new curve object\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    curve = Rhino.Geometry.Curve.CreateControlPointCurve(points, degree)\n    if not curve: raise Exception(\"unable to create control point curve from given points\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddEllipse(plane, radiusX, radiusY):\n    \"\"\"Adds an elliptical curve to the document\n    Parameters:\n      plane = the plane on which the ellipse will lie. The origin of\n              the plane will be the center of the ellipse\n      radiusX, radiusY = radius in the X and Y axis directions\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    ellipse = Rhino.Geometry.Ellipse(plane, radiusX, radiusY)\n    rc = scriptcontext.doc.Objects.AddEllipse(ellipse)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddEllipse3Pt(center, second, third):\n    \"\"\"Adds a 3-point elliptical curve to the document\n    Parameters:\n      center = center point of the ellipse\n      second = end point of the x axis\n      third  = end point of the y axis\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n    center = rhutil.coerce3dpoint(center, True)\n    second = rhutil.coerce3dpoint(second, True)\n    third = rhutil.coerce3dpoint(third, True)\n    ellipse = Rhino.Geometry.Ellipse(center, second, third)\n    rc = scriptcontext.doc.Objects.AddEllipse(ellipse)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddFilletCurve(curve0id, curve1id, radius=1.0, base_point0=None, base_point1=None):\n    \"\"\"Adds a fillet curve between two curve objects\n    Parameters:\n      curve0id = identifier of the first curve object\n      curve1id = identifier of the second curve object\n      radius [opt] = fillet radius\n      base_point0 [opt] = base point of the first curve. If omitted,\n                          starting point of the curve is used\n      base_point1 [opt] = base point of the second curve. If omitted,\n                          starting point of the curve is used\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n    if base_point0: base_point0 = rhutil.coerce3dpoint(base_point0, True)\n    else: base_point0 = Rhino.Geometry.Point3d.Unset\n    if base_point1: base_point1 = rhutil.coerce3dpoint(base_point1, True)\n    else: base_point1 = Rhino.Geometry.Point3d.Unset\n    curve0 = rhutil.coercecurve(curve0id, -1, True)\n    curve1 = rhutil.coercecurve(curve1id, -1, True)\n    crv0_t = 0.0\n    if base_point0==Rhino.Geometry.Point3d.Unset:\n        crv0_t = curve0.Domain.Min\n    else:\n        rc, t = curve0.ClosestPoint(base_point0, 0.0)\n        if not rc: raise Exception(\"ClosestPoint failed\")\n        crv0_t = t\n    crv1_t = 0.0\n    if base_point1==Rhino.Geometry.Point3d.Unset:\n        crv1_t = curve1.Domain.Min\n    else:\n        rc, t = curve1.ClosestPoint(base_point1, 0.0)\n        if not rc: raise Exception(\"ClosestPoint failed\")\n        crv1_t = t\n    arc = Rhino.Geometry.Curve.CreateFillet(curve0, curve1, radius, crv0_t, crv1_t)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddInterpCrvOnSrf(surface_id, points):\n    \"\"\"Adds an interpolated curve object that lies on a specified\n    surface.  Note, this function will not create periodic curves,\n    but it will create closed curves.\n    Parameters:\n      surface_id = identifier of the surface to create the curve on\n      points = list of 3D points that lie on the specified surface.\n               The list must contain at least 2 points\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    points = rhutil.coerce3dpointlist(points, True)\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    curve = surface.InterpolatedCurveOnSurface(points, tolerance)\n    if not curve: raise Exception(\"unable to create InterpolatedCurveOnSurface\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddInterpCrvOnSrfUV(surface_id, points):\n    \"\"\"Adds an interpolated curve object based on surface parameters,\n    that lies on a specified surface. Note, this function will not\n    create periodic curves, but it will create closed curves.\n    Parameters:\n      surface_id = identifier of the surface to create the curve on\n      points = list of 2D surface parameters. The list must contain\n               at least 2 sets of parameters\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    points = rhutil.coerce2dpointlist(points, True)\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    curve = surface.InterpolatedCurveOnSurfaceUV(points, tolerance)\n    if not curve: raise Exception(\"unable to create InterpolatedCurveOnSurfaceUV\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddInterpCurve(points, degree=3, knotstyle=0, start_tangent=None, end_tangent=None):\n    \"\"\"Adds an interpolated curve object to the document. Options exist to make\n    a periodic curve or to specify the tangent at the endpoints. The resulting\n    curve is a non-rational NURBS curve of the specified degree.\n    Parameters:\n      points = list containing 3D points to interpolate. For periodic curves,\n          if the final point is a duplicate of the initial point, it is\n          ignored. The number of control points must be >= (degree+1).\n      degree[opt] = The degree of the curve (must be >=1).\n          Periodic curves must have a degree >= 2. For knotstyle = 1 or 2,\n          the degree must be 3. For knotstyle = 4 or 5, the degree must be odd\n      knotstyle[opt]\n          0 Uniform knots.  Parameter spacing between consecutive knots is 1.0.\n          1 Chord length spacing.  Requires degree = 3 with arrCV1 and arrCVn1 specified.\n          2 Sqrt (chord length).  Requires degree = 3 with arrCV1 and arrCVn1 specified.\n          3 Periodic with uniform spacing.\n          4 Periodic with chord length spacing.  Requires an odd degree value.\n          5 Periodic with sqrt (chord length) spacing.  Requires an odd degree value.\n      start_tangent [opt] = 3d vector that specifies a tangency condition at the\n          beginning of the curve. If the curve is periodic, this argument must be omitted.\n      end_tangent [opt] = 3d vector that specifies a tangency condition at the\n          end of the curve. If the curve is periodic, this argument must be omitted.\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    if not start_tangent: start_tangent = Rhino.Geometry.Vector3d.Unset\n    start_tangent = rhutil.coerce3dvector(start_tangent, True)\n    if not end_tangent: end_tangent = Rhino.Geometry.Vector3d.Unset\n    end_tangent = rhutil.coerce3dvector(end_tangent, True)\n    curve = Rhino.Geometry.Curve.CreateInterpolatedCurve(points, degree, knotstyle, start_tangent, end_tangent)\n    if not curve: raise Exception(\"unable to CreateInterpolatedCurve\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddLine(start, end):\n    \"\"\"Adds a line curve to the current model.\n    Parameters:\n      start, end = end points of the line\n    Returns:\n      id of the new curve object\n    \"\"\"\n    start = rhutil.coerce3dpoint(start, True)\n    end = rhutil.coerce3dpoint(end, True)\n    rc = scriptcontext.doc.Objects.AddLine(start, end)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add line to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddNurbsCurve(points, knots, degree, weights=None):\n    \"\"\"Adds a NURBS curve object to the document\n    Parameters:\n      points = list containing 3D control points\n      knots = Knot values for the curve. The number of elements in knots must\n          equal the number of elements in points plus degree minus 1\n      degree = degree of the curve. must be greater than of equal to 1\n      weights[opt] = weight values for the curve. Number of elements should\n          equal the number of elements in points. Values must be greater than 0\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    cvcount = len(points)\n    knotcount = cvcount + degree - 1\n    if len(knots)!=knotcount:\n        raise Exception(\"Number of elements in knots must equal the number of elements in points plus degree minus 1\")\n    if weights and len(weights)!=cvcount:\n        raise Exception(\"Number of elements in weights should equal the number of elements in points\")\n    rational = (weights!=None)\n    \n    nc = Rhino.Geometry.NurbsCurve(3,rational,degree+1,cvcount)\n    for i in range(cvcount):\n        cp = Rhino.Geometry.ControlPoint()\n        cp.Location = points[i]\n        if weights: cp.Weight = weights[i]\n        nc.Points[i] = cp\n    for i in range(knotcount): nc.Knots[i] = knots[i]\n    rc = scriptcontext.doc.Objects.AddCurve(nc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddPolyline(points, replace_id=None):\n    \"\"\"Adds a polyline curve to the current model\n    Parameters:\n      points = list of 3D points. Duplicate, consecutive points found in\n               the array will be removed. The array must contain at least\n               two points. If the array contains less than four points,\n               then the first point and the last point must be different.\n      replace_id[opt] = If set to the id of an existing object, the object\n               will be replaced by this polyline\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    if replace_id: replace_id = rhutil.coerceguid(replace_id, True)\n    rc = System.Guid.Empty\n    if replace_id:\n        pl = Rhino.Geometry.Polyline(points)\n        if scriptcontext.doc.Objects.Replace(replace_id, pl):\n            rc = replace_id\n    else:\n        rc = scriptcontext.doc.Objects.AddPolyline(points)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add polyline to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddRectangle(plane, width, height):\n    \"\"\"Adds a rectangular curve to the document\n    Paramters:\n      plane = plane on which the rectangle will lie\n      width, height = width and height of rectangle as measured along the plane's\n        x and y axes\n    Returns:\n      id of new rectangle\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    rect = Rhino.Geometry.Rectangle3d(plane, width, height)\n    poly = rect.ToPolyline()\n    rc = scriptcontext.doc.Objects.AddPolyline(poly)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add polyline to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSubCrv(curve_id, param0, param1):\n    \"\"\"Adds a curve object based on a portion, or interval of an existing curve\n    object. Similar in operation to Rhino's SubCrv command\n    Parameters:\n      curve_id = identifier of a closed planar curve object\n      param0, param1 = first and second parameters on the source curve\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    trimcurve = curve.Trim(param0, param1)\n    if not trimcurve: raise Exception(\"unable to trim curve\")\n    rc = scriptcontext.doc.Objects.AddCurve(trimcurve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ArcAngle(curve_id, segment_index=-1):\n    \"\"\"Returns the angle of an arc curve object.\n    Parameters:\n      curve_id = identifier of a curve object\n      segment_index [opt] = identifies the curve segment if \n      curve_id identifies a polycurve\n    Returns:\n      The angle in degrees if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.AngleDegrees\n\n\ndef ArcCenterPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the center point of an arc curve object\n    Parameters:\n      curve_id = identifier of a curve object\n      segment_index [opt] = identifies the curve segment if\n      curve_id identifies a polycurve\n    Returns:\n      The 3D center point of the arc if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.Center\n\n\ndef ArcMidPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the mid point of an arc curve object\n    Parameters:\n      curve_id = identifier of a curve object\n      segment_index [opt] = identifies the curve segment if\n      curve_id identifies a polycurve\n    Returns:\n      The 3D mid point of the arc if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.MidPoint\n\n\ndef ArcRadius(curve_id, segment_index=-1):\n    \"\"\"Returns the radius of an arc curve object\n    Parameters:\n      curve_id = identifier of a curve object\n      segment_index [opt] = identifies the curve segment if \n      curve_id identifies a polycurve\n    Returns:\n      The radius of the arc if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.Radius\n\n\ndef CircleCenterPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the center point of a circle curve object\n    Parameters:\n      curve_id = identifier of a curve object\n      segment_index [opt] = identifies the curve segment if\n      curve_id identifies a polycurve\n    Returns:\n      The 3D center point of the circle if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, circle = curve.TryGetCircle(Rhino.RhinoMath.ZeroTolerance)\n    if not rc: raise Exception(\"curve is not circle\")\n    return circle.Center\n\n\ndef CircleCircumference(curve_id, segment_index=-1):\n    \"\"\"Returns the circumference of a circle curve object\n    Parameters:\n      curve_id = identifier of a curve object\n      segment_index [opt] = identifies the curve segment if\n      curve_id identifies a polycurve\n    Returns:\n      The circumference of the circle if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, circle = curve.TryGetCircle( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not circle\")\n    return circle.Circumference\n\ndef CircleRadius(curve_id, segment_index=-1):\n    \"\"\"Returns the radius of a circle curve object\n    Parameters:\n      curve_id = identifier of a curve object\n      segment_index [opt] = identifies the curve segment if\n      curve_id identifies a polycurve\n    Returns:\n      The radius of the circle if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, circle = curve.TryGetCircle( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not circle\")\n    return circle.Radius\n\ndef CloseCurve(curve_id, tolerance=-1.0):\n    \"\"\"Closes an open curve object by making adjustments to the end points so\n    they meet at a point\n    Parameters:\n      curve_id = identifier of a curve object\n      tolerance[opt] = maximum allowable distance between start and end\n          point. If omitted, the current absolute tolerance is used\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if curve.IsClosed: return curve_id\n    if tolerance<0.0: tolerance = Rhino.RhinoMath.ZeroTolerance\n    if not curve.MakeClosed(tolerance): return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\ndef ClosedCurveOrientation(curve_id, direction=(0,0,1)):\n    \"\"\"Determine the orientation (counter-clockwise or clockwise) of a closed,\n    planar curve\n    Parameters:\n      curve_id = identifier of a curve object\n      direction[opt] = 3d vector that identifies up, or Z axs, direction of\n          the plane to test against\n    Returns:\n      1 if the curve's orientation is clockwise\n      -1 if the curve's orientation is counter-clockwise\n      0 if unable to compute the curve's orientation\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1 ,True)\n    direction = rhutil.coerce3dvector(direction, True)\n    if not curve.IsClosed: return 0\n    orientation = curve.ClosedCurveOrientation(direction)\n    return int(orientation)\n\n\ndef ConvertCurveToPolyline(curve_id, angle_tolerance=5.0, tolerance=0.01, delete_input=False):\n    \"\"\"Converts a curve to a polyline curve\n    Parameters:\n      curve_id = identifier of a curve object\n      angle_tolerance [opt] = The maximum angle between curve\n        tangents at line endpoints. If omitted, the angle tolerance is set to 5.0.\n      tolerance [opt] = The distance tolerance at segment midpoints.\n        If omitted, the tolerance is set to 0.01.\n      delete_input [opt] = Delete the curve object specified by curve_id.\n        If omitted, curve_id will not be deleted.\n    Returns:\n      The new curve if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if angle_tolerance<=0: angle_tolerance = 5.0\n    angle_tolerance = Rhino.RhinoMath.ToRadians(angle_tolerance)\n    if tolerance<=0.0: tolerance = 0.01;\n    polyline_curve = curve.ToPolyline( 0, 0, angle_tolerance, 0.0, 0.0, tolerance, 0.0, 0.0, True)\n    if not polyline_curve: return scriptcontext.errorhandler()\n    id = System.Guid.Empty\n    if delete_input:\n        if scriptcontext.doc.Objects.Replace( curve_id, polyline_curve): id = curve_id\n    else:\n        id = scriptcontext.doc.Objects.AddCurve( polyline_curve )\n    if System.Guid.Empty==id: return scriptcontext.errorhandler()\n    return id\n\n  \ndef CurveArcLengthPoint(curve_id, length, from_start=True):\n    \"\"\"Returns the point on the curve that is a specified arc length\n    from the start of the curve.\n    Parameters:\n      curve_id = identifier of a curve object\n      length = The arc length from the start of the curve to evaluate.\n      from_start[opt] = If not specified or True, then the arc length point is\n          calculated from the start of the curve. If False, the arc length\n          point is calculated from the end of the curve.\n    Returns:\n      Point3d if successful\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    curve_length = curve.GetLength()\n    if curve_length>=length:\n        s = 0.0\n        if length==0.0: s = 0.0\n        elif length==curve_length: s = 1.0\n        else: s = length / curve_length\n        dupe = curve.Duplicate()\n        if dupe:\n            if from_start==False: dupe.Reverse()\n            rc, t = dupe.NormalizedLengthParameter(s)\n            if rc: return dupe.PointAt(t)\n            dupe.Dispose()\n\n\ndef CurveArea(curve_id):\n    \"\"\"Returns area of closed planar curves. The results are based on the\n    current drawing units.\n    Parameters:\n      curve_id = The identifier of a closed, planar curve object.\n    Returns:\n      List of area information. The list will contain the following information:\n        Element  Description\n        0        The area. If more than one curve was specified, the\n                 value will be the cumulative area.\n        1        The absolute (+/-) error bound for the area.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    mp = Rhino.Geometry.AreaMassProperties.Compute(curve)\n    return mp.Area, mp.AreaError\n\n\ndef CurveAreaCentroid(curve_id):\n    \"\"\"Returns area centroid of closed, planar curves. The results are based\n    on the current drawing units.\n    Parameters:\n      curve_id = The identifier of a closed, planar curve object.\n    Returns:\n      Tuple of area centroid information containing the following information:\n        Element  Description\n        0        The 3d centroid point. If more than one curve was specified,\n                 the value will be the cumulative area.\n        1        A 3d vector with the absolute (+/-) error bound for the area\n                 centroid.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    mp = Rhino.Geometry.AreaMassProperties.Compute(curve)\n    return mp.Centroid, mp.CentroidError\n\n\ndef CurveArrows(curve_id, arrow_style=None):\n    \"\"\"Enables or disables a curve object's annotation arrows\n    Parameters:\n      curve_id = identifier of a curve\n      arrow_style[opt] = the style of annotation arrow to be displayed\n        0 = no arrows\n        1 = display arrow at start of curve\n        2 = display arrow at end of curve\n        3 = display arrow at both start and end of curve\n      Returns:\n        if arrow_style is not specified, the current annotation arrow style\n        if arrow_style is specified, the previos arrow style\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rhobj = rhutil.coercerhinoobject(curve_id, True, True)\n    attr = rhobj.Attributes\n    rc = attr.ObjectDecoration\n    if arrow_style is not None:\n        if arrow_style==0:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.None\n        elif arrow_style==1:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.StartArrowhead\n        elif arrow_style==2:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.EndArrowhead\n        elif arrow_style==3:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.BothArrowhead\n        id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.ModifyAttributes(id, attr, True)\n        scriptcontext.doc.Views.Redraw()\n    if rc==Rhino.DocObjects.ObjectDecoration.None: return 0\n    if rc==Rhino.DocObjects.ObjectDecoration.StartArrowhead: return 1\n    if rc==Rhino.DocObjects.ObjectDecoration.EndArrowhead: return 2\n    if rc==Rhino.DocObjects.ObjectDecoration.BothArrowhead: return 3\n\n\ndef CurveBooleanDifference(curve_id_0, curve_id_1):\n    \"\"\"Calculates the difference between two closed, planar curves and\n    adds the results to the document. Note, curves must be coplanar.\n    Parameters:\n      curve_id_0 = identifier of the first curve object.\n      curve_id_1 = identifier of the second curve object.\n    Returns:\n      The identifiers of the new objects if successful, None on error.\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    out_curves = Rhino.Geometry.Curve.CreateBooleanDifference(curve0, curve1)\n    curves = []\n    for curve in out_curves:\n        if curve and curve.IsValid:\n            rc = scriptcontext.doc.Objects.AddCurve(curve)\n            curve.Dispose()\n            if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n            curves.append(rc)\n    scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef CurveBooleanIntersection(curve_id_0, curve_id_1):\n    \"\"\"Calculates the intersection of two closed, planar curves and adds\n    the results to the document. Note, curves must be coplanar.\n    Parameters:\n      curve_id_0 = identifier of the first curve object.\n      curve_id_1 = identifier of the second curve object.\n    Returns:\n      The identifiers of the new objects.\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    \n    out_curves = Rhino.Geometry.Curve.CreateBooleanIntersection(curve0, curve1)\n    curves = []\n    for curve in out_curves:\n        if curve and curve.IsValid:\n            rc = scriptcontext.doc.Objects.AddCurve(curve)\n            curve.Dispose()\n            if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n            curves.append(rc)\n    scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef CurveBooleanUnion(curve_id):\n    \"\"\"Calculates the union of two or more closed, planar curves and\n    adds the results to the document. Note, curves must be coplanar.\n    Parameters:\n      curve_id = list of two or more close planar curves identifiers\n    Returns:\n      The identifiers of the new objects.\n    \"\"\"\n    in_curves = [rhutil.coercecurve(id,-1,True) for id in curve_id]\n    if len(in_curves)<2: raise ValueException(\"curve_id must have at least 2 curves\")\n    out_curves = Rhino.Geometry.Curve.CreateBooleanUnion(in_curves)\n    curves = []\n    for curve in out_curves:\n        if curve and curve.IsValid:\n            rc = scriptcontext.doc.Objects.AddCurve(curve)\n            curve.Dispose()\n            if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n            curves.append(rc)\n    scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef CurveBrepIntersect(curve_id, brep_id, tolerance=None):\n    \"\"\"Intersects a curve object with a brep object. Note, unlike the\n    CurveSurfaceIntersection function, this function works on trimmed surfaces.\n    Parameters:\n      curve_id = identifier of a curve object\n      brep_id = identifier of a brep object\n      tolerance [opt] = The distance tolerance at segment midpoints.\n                        If omitted, the current absolute tolerance is used.\n    Returns:\n      List of identifiers for the newly created intersection curve and\n      point objects if successful. None on error.            \n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    brep = rhutil.coercebrep(brep_id, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, out_curves, out_points = Rhino.Geometry.Intersect.Intersection.CurveBrep(curve, brep, tolerance)\n    if not rc: return scriptcontext.errorhandler()\n    \n    curves = []\n    points = []\n    for curve in out_curves:\n        if curve and curve.IsValid:\n            rc = scriptcontext.doc.Objects.AddCurve(curve)\n            curve.Dispose()\n            if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n            curves.append(rc)\n    for point in out_points:\n        if point and point.IsValid:\n            rc = scriptcontext.doc.Objects.AddPoint(point)\n            points.append(rc)\n    scriptcontext.doc.Views.Redraw()\n    return curves, points\n\n\ndef CurveClosestObject(curve_id, object_ids):\n    \"\"\"Returns the 3D point locations on two objects where they are closest to\n    each other. Note, this function provides similar functionality to that of\n    Rhino's ClosestPt command.\n    Parameters:\n      curve_id = identifier of a closed planar curve object\n      object_ids = list of identifiers of one or more closed, planar curves\n    Returns:\n      Tuple containing the results of the closest point calculation.\n      The elements are as follows:\n        0    The identifier of the closest object.\n        1    The 3-D point that is closest to the closest object. \n        2    The 3-D point that is closest to the test curve.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id,-1,True)\n    geometry = []\n    id = rhutil.coerceguid(object_ids, False)\n    if id: object_ids = [id]\n    for object_id in object_ids:\n        rhobj = rhutil.coercerhinoobject(object_id, True, True)\n        geometry.append( rhobj.Geometry )\n    if not geometry: raise ValueError(\"object_ids must contain at least one item\")\n    success, curve_point, geom_point, which_geom = curve.ClosestPoints(geometry, 0.0)\n    if success: return object_ids[which_geom], geom_point, curve_point\n\n    \ndef CurveClosestPoint(curve_id, test_point, segment_index=-1 ):\n    \"\"\"Returns parameter of the point on a curve that is closest to a test point.\n    Parameters:\n      curve_id = identifier of a curve object\n      point = sampling point\n      segment_index [opt] = curve segment if curve_id identifies a polycurve\n    Returns:\n      The parameter of the closest point on the curve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    point = rhutil.coerce3dpoint(test_point, True)\n    rc, t = curve.ClosestPoint(point, 0.0)\n    if not rc: raise Exception(\"ClosestPoint failed\")\n    return t\n\n\ndef CurveContourPoints(curve_id, start_point, end_point, interval=None):\n    \"\"\"Returns the 3D point locations calculated by contouring a curve object.\n    Parameters:\n      curve_id = identifier of a curve object.\n      start_point = 3D starting point of a center line.\n      end_point = 3D ending point of a center line.\n      interval [opt] = The distance between contour curves. If omitted, \n      the interval will be equal to the diagonal distance of the object's\n      bounding box divided by 50.\n    Returns:\n      A list of 3D points, one for each contour\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    start_point = rhutil.coerce3dpoint(start_point, True)\n    end_point = rhutil.coerce3dpoint(end_point, True)\n    if start_point.DistanceTo(end_point)<Rhino.RhinoMath.ZeroTolerance:\n        raise Exception(\"start and end point are too close to define a line\")\n    if not interval:\n        bbox = curve.GetBoundingBox(True)\n        diagonal = bbox.Max - bbox.Min\n        interval = diagonal.Length / 50.0\n    rc = curve.DivideAsContour( start_point, end_point, interval )\n    return list(rc)\n\n\ndef CurveCurvature(curve_id, parameter):\n    \"\"\"Returns the curvature of a curve at a parameter. See the Rhino help for\n    details on curve curvature\n    Parameters:\n      curve_id = identifier of the curve\n      parameter = parameter to evaluate\n    Returns:\n      Tuple of curvature information on success\n        element 0 = point at specified parameter\n        element 1 = tangent vector\n        element 2 = center of radius of curvature\n        element 3 = radius of curvature\n        element 4 = curvature vector\n      None on failure\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    point = curve.PointAt(parameter)\n    tangent = curve.TangentAt(parameter)\n    if tangent.IsTiny(0): return scriptcontext.errorhandler()\n    cv = curve.CurvatureAt(parameter)\n    k = cv.Length\n    if k<Rhino.RhinoMath.SqrtEpsilon: return scriptcontext.errorhandler()\n    rv = cv / (k*k)\n    circle = Rhino.Geometry.Circle(point, tangent, point + 2.0*rv)\n    center = point + rv\n    radius = circle.Radius\n    return point, tangent, center, radius, cv\n\n\ndef CurveCurveIntersection(curveA, curveB, tolerance=-1):\n    \"\"\"Calculates the intersection of two curve objects.\n    Parameters:\n      curveA = The identifier of the first curve object.\n      curveB = The identifier of the second curve object. If omitted, then a\n               self-intersection test will be performed on curveA.\n      tolerance [opt] = The absolute tolerance in drawing units. If omitted,\n                        the document's current absolute tolerance is used.\n    Returns:\n      A two-dimensional list of intersection information if successful.\n      The list will contain one or more of the following elements:\n        Element Type     Description\n        (n, 0)  Number   The intersection event type, either Point (1) or Overlap (2).\n        (n, 1)  Point3d  If the event type is Point (1), then the intersection point \n                         on the first curve. If the event type is Overlap (2), then\n                         intersection start point on the first curve.\n        (n, 2)  Point3d  If the event type is Point (1), then the intersection point\n                         on the first curve. If the event type is Overlap (2), then\n                         intersection end point on the first curve.\n        (n, 3)  Point3d  If the event type is Point (1), then the intersection point \n                         on the second curve. If the event type is Overlap (2), then\n                         intersection start point on the second curve.\n        (n, 4)  Point3d  If the event type is Point (1), then the intersection point\n                         on the second curve. If the event type is Overlap (2), then\n                         intersection end point on the second curve.\n        (n, 5)  Number   If the event type is Point (1), then the first curve parameter.\n                         If the event type is Overlap (2), then the start value of the\n                         first curve parameter range.\n        (n, 6)  Number   If the event type is Point (1), then the first curve parameter.\n                         If the event type is Overlap (2), then the end value of the\n                         first curve parameter range.\n        (n, 7)  Number   If the event type is Point (1), then the second curve parameter.\n                         If the event type is Overlap (2), then the start value of the\n                         second curve parameter range.\n        (n, 8)  Number   If the event type is Point (1), then the second curve parameter.\n                         If the event type is Overlap (2), then the end value of the \n                         second curve parameter range.\n    \"\"\"\n    curveA = rhutil.coercecurve(curveA, -1, True)\n    curveB = rhutil.coercecurve(curveB, -1, True)\n    if tolerance is None or tolerance<0.0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    rc = Rhino.Geometry.Intersect.Intersection.CurveCurve(curveA, curveB, tolerance, 0.0)\n    events = []\n    if rc:\n        for i in range(rc.Count):\n            event_type = 1\n            if( rc[i].IsOverlap ): event_type = 2\n            oa = rc[i].OverlapA\n            ob = rc[i].OverlapB\n            element = (event_type, rc[i].PointA, rc[i].PointA2, rc[i].PointB, rc[i].PointB2, oa[0], oa[1], ob[0], ob[1])\n            events.append(element)\n    return events\n\n\ndef CurveDegree(curve_id, segment_index=-1):\n    \"\"\"Returns the degree of a curve object.\n    Parameters:\n      curve_id = identifier of a curve object.\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve.\n    Returns:\n      The degree of the curve if successful. None on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.Degree\n\n\ndef CurveDeviation(curve_a, curve_b):\n    \"\"\"Returns the minimum and maximum deviation between two curve objects\n    Parameters:\n      curve_a, curve_b = identifiers of two curves\n    Returns:\n      tuple of deviation information on success\n        element 0 = curve_a parameter at maximum overlap distance point\n        element 1 = curve_b parameter at maximum overlap distance point\n        element 2 = maximum overlap distance\n        element 3 = curve_a parameter at minimum overlap distance point\n        element 4 = curve_b parameter at minimum overlap distance point\n        element 5 = minimum distance between curves\n      None on error\n    \"\"\"\n    curve_a = rhutil.coercecurve(curve_a, -1, True)\n    curve_b = rhutil.coercecurve(curve_b, -1, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc = Rhino.Geometry.Curve.GetDistancesBetweenCurves(curve_a, curve_b, tol)\n    if not rc[0]: return scriptcontext.errorhandler()\n    maxa = rc[2]\n    maxb = rc[3]\n    maxd = rc[1]\n    mina = rc[5]\n    minb = rc[6]\n    mind = rc[4]\n    return maxa, maxb, maxd, mina, minb, mind\n\n\ndef CurveDim(curve_id, segment_index=-1):\n    \"\"\"Returns the dimension of a curve object\n    Parameters:\n      curve_id = identifier of a curve object.\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve.\n    Returns:\n      The dimension of the curve if successful. None on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.Dimension\n\n\ndef CurveDirectionsMatch(curve_id_0, curve_id_1):\n    \"\"\"Tests if two curve objects are generally in the same direction or if they\n    would be more in the same direction if one of them were flipped. When testing\n    curve directions, both curves must be either open or closed - you cannot test\n    one open curve and one closed curve.\n    Parameters:\n      curve_id_0 = identifier of first curve object\n      curve_id_1 = identifier of second curve object\n    Returns:\n      True if the curve directions match, otherwise False. \n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    return Rhino.Geometry.Curve.DoDirectionsMatch(curve0, curve1)\n\n\ndef CurveDiscontinuity(curve_id, style):   \n    \"\"\"Search for a derivatitive, tangent, or curvature discontinuity in\n    a curve object.\n    Parameters:\n      curve_id = identifier of curve object\n      style = The type of continuity to test for. The types of\n          continuity are as follows:\n          Value    Description\n          1        C0 - Continuous function\n          2        C1 - Continuous first derivative\n          3        C2 - Continuous first and second derivative\n          4        G1 - Continuous unit tangent\n          5        G2 - Continuous unit tangent and curvature\n    Returns:\n      List 3D points where the curve is discontinuous\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    dom = curve.Domain\n    t0 = dom.Min\n    t1 = dom.Max\n    points = []\n    get_next = True\n    while get_next:\n        get_next, t = curve.GetNextDiscontinuity(System.Enum.ToObject(Rhino.Geometry.Continuity, style), t0, t1)\n        if get_next:\n            points.append(curve.PointAt(t))\n            t0 = t # Advance to the next parameter\n    return points\n\n\ndef CurveDomain(curve_id, segment_index=-1):\n    \"\"\"Returns the domain of a curve object.\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index[opt] = the curve segment if curve_id identifies a polycurve.\n    Returns:\n      The domain of the curve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    dom = curve.Domain\n    return dom.Min, dom.Max\n\n\ndef CurveEditPoints(curve_id, return_parameters=False, segment_index=-1):\n    \"\"\"Returns the edit, or Greville, points of a curve object. \n    For each curve control point, there is a corresponding edit point.\n    Parameters:\n      curve_id = identifier of the curve object\n      return_parameters[opt] = if True, return as a list of curve parameters.\n        If False, return as a list of 3d points\n      segment_index[opt] = the curve segment is curve_id identifies a polycurve\n    Returns:\n      a list of curve parameters of 3d points on success\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if not nc: return scriptcontext.errorhandler()\n    if return_parameters: return nc.GrevilleParameters()\n    return nc.GrevillePoints()\n\n\ndef CurveEndPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the end point of a curve object\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      The 3-D end point of the curve if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.PointAtEnd\n\n\ndef CurveFilletPoints(curve_id_0, curve_id_1, radius=1.0, base_point_0=None, base_point_1=None, return_points=True):\n    \"\"\"Find points at which to cut a pair of curves so that a fillet of a\n    specified radius fits. A fillet point is a pair of points (point0, point1)\n    such that there is a circle of radius tangent to curve curve0 at point0 and\n    tangent to curve curve1 at point1. Of all possible fillet points, this\n    function returns the one which is the closest to the base point base_point_0,\n    base_point_1. Distance from the base point is measured by the sum of arc\n    lengths along the two curves. \n    Parameters:\n      curve_id_0 = identifier of the first curve object.\n      curve_id_1 = identifier of the second curve object.\n      radius [opt] = The fillet radius. If omitted, a radius\n                     of 1.0 is specified.\n      base_point_0 [opt] = The base point on the first curve.\n                     If omitted, the starting point of the curve is used.\n      base_point_1 [opt] = The base point on the second curve. If omitted,\n                     the starting point of the curve is used.\n      return_points [opt] = If True (Default), then fillet points are\n                     returned. Otherwise, a fillet curve is created and\n                     it's identifier is returned.\n    Returns:\n      If return_points is True, then a list of point and vector values\n      if successful. The list elements are as follows:\n      \n      0    A point on the first curve at which to cut (arrPoint0).\n      1    A point on the second curve at which to cut (arrPoint1).\n      2    The fillet plane's origin (3-D point). This point is also\n           the center point of the fillet\n      3    The fillet plane's X axis (3-D vector).\n      4    The fillet plane's Y axis (3-D vector).\n      5    The fillet plane's Z axis (3-D vector).\n      \n      If return_points is False, then the identifier of the fillet curve\n      if successful.\n      None if not successful, or on error.                  \n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    t0_base = curve0.Domain.Min\n    \n    if base_point_0:\n        rc = curve0.ClosestPoint(base_point_0, t0_base)\n        if not rc[0]: return scriptcontext.errorhandler()\n    \n    t1_base = curve1.Domain.Min\n    if base_point_1:\n        rc = curve1.ClosestPoint(base_point_1, t1_base)\n        if not rc[0]: return scriptcontext.errorhandler()\n\n    r = radius if (radius and radius>0) else 1.0\n    rc = Rhino.Geometry.Curve.GetFilletPoints(curve0, curve1, r, t0_base, t1_base)\n    if rc[0]:\n        point_0 = curve0.PointAt(rc[1])\n        point_1 = curve1.PointAt(rc[2])\n        return point_0, point_1, rc[3].Origin, rc[3].XAxis, rc[3].YAxis, rc[3].ZAxis\n    return scriptcontext.errorhandler()\n\n\ndef CurveFrame(curve_id, parameter, segment_index=-1):\n    \"\"\"Returns the plane at a parameter of a curve. The plane is based on the\n    tangent and curvature vectors at a parameter.\n    Parameters:\n      curve_id = identifier of the curve object.\n      parameter = parameter to evaluate.\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      The plane at the specified parameter if successful. \n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    domain = curve.Domain\n    if not domain.IncludesParameter(parameter):\n        tol = scriptcontext.doc.ModelAbsoluteTolerance\n        if parameter>domain.Max and (parameter-domain.Max)<=tol:\n            parameter = domain.Max\n        elif parameter<domain.Min and (domain.Min-parameter)<=tol:\n            parameter = domain.Min\n        else:\n            return scriptcontext.errorhandler()\n    rc, frame = curve.FrameAt(parameter)\n    if rc and frame.IsValid: return frame\n    return scriptcontext.errorhandler()\n\n\ndef CurveKnotCount(curve_id, segment_index=-1):\n    \"\"\"Returns the knot count of a curve object.\n    Parameters:\n      curve_id = identifier of the curve object.\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve.\n    Returns:\n      The number of knots if successful.\n      None if not successful or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if not nc: return scriptcontext.errorhandler()\n    return nc.Knots.Count\n\n\ndef CurveKnots(curve_id, segment_index=-1):\n    \"\"\"Returns the knots, or knot vector, of a curve object\n    Parameters:\n      curve_id = identifier of the curve object.\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve.\n    Returns:\n      knot values if successful.\n      None if not successful or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if not nc: return scriptcontext.errorhandler()\n    rc = [nc.Knots[i] for i in range(nc.Knots.Count)]\n    return rc\n\n\ndef CurveLength(curve_id, segment_index=-1, sub_domain=None):\n    \"\"\"Returns the length of a curve object.\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n      sub_domain [opt] = list of two numbers identifing the sub-domain of the\n          curve on which the calculation will be performed. The two parameters\n          (sub-domain) must be non-decreasing. If omitted, the length of the\n          entire curve is returned.\n    Returns:\n      The length of the curve if successful.\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    if sub_domain:\n        if len(sub_domain)==2:\n            dom = Rhino.Geometry.Interval(sub_domain[0], sub_domain[1])\n            return curve.GetLength(dom)\n        return scriptcontext.errorhandler()\n    return curve.GetLength()\n\n\ndef CurveMidPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the mid point of a curve object.\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      The 3D mid point of the curve if successful.\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, t = curve.NormalizedLengthParameter(0.5)\n    if rc: return curve.PointAt(t)\n    return scriptcontext.errorhandler()\n\n\ndef CurveNormal(curve_id, segment_index=-1):\n    \"\"\"Returns the normal direction of the plane in which a planar curve object lies.\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      The 3D normal vector if sucessful.\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, plane = curve.TryGetPlane(tol)\n    if rc: return plane.Normal\n    return scriptcontext.errorhandler()\n\n\ndef CurveNormalizedParameter(curve_id, parameter):\n    \"\"\"Converts a curve parameter to a normalized curve parameter;\n    one that ranges between 0-1\n    Parameters:\n      curve_id = identifier of the curve object\n      parameter = the curve parameter to convert\n    Returns:\n      normalized curve parameter\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    return curve.Domain.NormalizedParameterAt(parameter)\n\n\ndef CurveParameter(curve_id, parameter):\n    \"\"\"Converts a normalized curve parameter to a curve parameter;\n    one within the curve's domain\n    Parameters:\n      curve_id = identifier of the curve object\n      parameter = the normalized curve parameter to convert\n    Returns:\n      curve parameter\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    return curve.Domain.ParameterAt(parameter)\n\n\ndef CurvePerpFrame(curve_id, parameter):\n    \"\"\"Returns the perpendicular plane at a parameter of a curve. The result\n    is relatively parallel (zero-twisting) plane\n    Parameters:\n      curve_id = identifier of the curve object\n      parameter = parameter to evaluate\n    Returns:\n      Plane on success\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    parameter = float(parameter)\n    params = (parameter, parameter+0.05)\n    if parameter>0.9: params = (parameter-0.05, parameter)\n    planes = curve.GetPerpendicularFrames(params)\n    if planes is None or len(planes)<2: return scriptcontext.errorhandler()\n    if parameter>0.9: return planes[1]\n    return planes[0]\n\n\ndef CurvePlane(curve_id, segment_index=-1):\n    \"\"\"Returns the plane in which a planar curve lies. Note, this function works\n    only on planar curves.\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index[opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      The plane in which the curve lies if successful.\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, plane = curve.TryGetPlane(tol)\n    if rc: return plane\n    return scriptcontext.errorhandler()\n\n\ndef CurvePointCount(curve_id, segment_index=-1):\n    \"\"\"Returns the control points count of a curve object.\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      Number of control points if successful.\n      None if not successful\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if nc: return nc.Points.Count\n    return scriptcontext.errorhandler()\n\n\ndef CurvePoints(curve_id, segment_index=-1):\n    \"\"\"Returns the control points, or control vertices, of a curve object.\n    If the curve is a rational NURBS curve, the euclidean control vertices\n    are returned.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if nc is None: return scriptcontext.errorhandler()\n    points = [nc.Points[i].Location for i in range(nc.Points.Count)]\n    return points\n\n\ndef CurveRadius(curve_id, test_point, segment_index=-1):\n    \"\"\"Returns the radius of curvature at a point on a curve.\n    Parameters:\n      curve_id = identifier of the curve object\n      test_point = sampling point\n      segment_index[opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      The radius of curvature at the point on the curve if successful.\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    point = rhutil.coerce3dpoint(test_point, True)\n    rc, t = curve.ClosestPoint(point, 0.0)\n    if not rc: return scriptcontext.errorhandler()\n    v = curve.CurvatureAt( t )\n    k = v.Length()\n    if k>Rhino.RhinoMath.ZeroTolerance: return 1/k\n    return scriptcontext.errorhandler()\n\n\ndef CurveSeam(curve_id, parameter):\n    \"\"\"Adjusts the seam, or start/end, point of a closed curve.\n    Parameters:\n      curve_id = identifier of the curve object\n      parameter = The parameter of the new start/end point. \n                  Note, if successful, the resulting curve's\n                  domain will start at dblParameter.\n    Returns:\n      True or False indicating success or failure.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if (not curve.IsClosed or not curve.Domain.IncludesParameter(parameter)):\n        return False\n    dupe = curve.Duplicate()\n    if dupe:\n        dupe.ChangeClosedCurveSeam(parameter)\n        curve_id = rhutil.coerceguid(curve_id)\n        dupe_obj = scriptcontext.doc.Objects.Replace(curve_id, dupe)\n        return dupe_obj is not None\n    return False\n\n\ndef CurveStartPoint(curve_id, segment_index=-1, point=None):\n    \"\"\"Returns the start point of a curve object\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n      point [opt] = new start point\n    Returns:\n      The 3D starting point of the curve if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc = curve.PointAtStart\n    if point:\n        point = rhutil.coerce3dpoint(point, True)\n        if point and curve.SetStartPoint(point):\n            curve_id = rhutil.coerceguid(curve_id, True)\n            scriptcontext.doc.Objects.Replace(curve_id, curve)\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef CurveSurfaceIntersection(curve_id, surface_id, tolerance=-1, angle_tolerance=-1):\n    \"\"\"Calculates the intersection of a curve object with a surface object.\n    Note, this function works on the untrimmed portion of the surface.\n    Parameters:\n      curve_id = The identifier of the first curve object.\n      surface_id = The identifier of the second curve object. If omitted,\n          the a self-intersection test will be performed on curve.\n      tolerance [opt] = The absolute tolerance in drawing units. If omitted, \n          the document's current absolute tolerance is used.\n      angle_tolerance [opt] = The angle tolerance in degrees. The angle\n          tolerance is used to determine when the curve is tangent to the\n          surface. If omitted, the document's current angle tolerance is used.\n    Returns:\n      A two-dimensional list of intersection information if successful.\n      The list will contain one or more of the following elements:\n        Element Type     Description\n        (n, 0)  Number   The intersection event type, either Point(1) or Overlap(2).\n        (n, 1)  Point3d  If the event type is Point(1), then the intersection point \n                         on the first curve. If the event type is Overlap(2), then\n                         intersection start point on the first curve.\n        (n, 2)  Point3d  If the event type is Point(1), then the intersection point\n                         on the first curve. If the event type is Overlap(2), then\n                         intersection end point on the first curve.\n        (n, 3)  Point3d  If the event type is Point(1), then the intersection point \n                         on the second curve. If the event type is Overlap(2), then\n                         intersection start point on the surface.\n        (n, 4)  Point3d  If the event type is Point(1), then the intersection point\n                         on the second curve. If the event type is Overlap(2), then\n                         intersection end point on the surface.\n        (n, 5)  Number   If the event type is Point(1), then the first curve parameter.\n                         If the event type is Overlap(2), then the start value of the\n                         first curve parameter range.\n        (n, 6)  Number   If the event type is Point(1), then the first curve parameter.\n                         If the event type is Overlap(2), then the end value of the\n                         curve parameter range.\n        (n, 7)  Number   If the event type is Point(1), then the U surface parameter.\n                         If the event type is Overlap(2), then the U surface parameter\n                         for curve at (n, 5).\n        (n, 8)  Number   If the event type is Point(1), then the V surface parameter.\n                         If the event type is Overlap(2), then the V surface parameter\n                         for curve at (n, 5).\n        (n, 9)  Number   If the event type is Point(1), then the U surface parameter.\n                         If the event type is Overlap(2), then the U surface parameter\n                         for curve at (n, 6).\n        (n, 10) Number   If the event type is Point(1), then the V surface parameter.\n                         If the event type is Overlap(2), then the V surface parameter\n                         for curve at (n, 6).\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    surface = rhutil.coercesurface(surface_id, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if angle_tolerance is None or angle_tolerance<0:\n        angle_tolerance = scriptcontext.doc.ModelAngleToleranceRadians\n    else:\n        angle_tolerance = math.radians(angle_tolerance)\n    rc = Rhino.Geometry.Intersect.Intersection.CurveSurface(curve, surface, tolerance, angle_tolerance)\n    events = []\n    if rc:\n      for i in range(rc.Count):\n          event_type = 2 if rc[i].IsOverlap else 1\n          item = rc[i]\n          oa = item.OverlapA\n          u,v = item.SurfaceOverlapParameter()\n          e = (event_type, item.PointA, item.PointA2, item.PointB, item.PointB2, oa[0], oa[1], u[0], u[1], v[0], v[1])\n          events.append(e)\n    return events\n\n\ndef CurveTangent(curve_id, parameter, segment_index=-1):\n    \"\"\"Returns a 3D vector that is the tangent to a curve at a parameter.\n    Parameters:\n      curve_id = identifier of the curve object\n      parameter = parameter to evaluate\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      A 3D vector if successful.\n      None on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc = Rhino.Geometry.Point3d.Unset\n    if curve.Domain.IncludesParameter(parameter):\n        return curve.TangentAt(parameter)\n    return scriptcontext.errorhandler()\n\n\ndef CurveWeights(curve_id, segment_index=-1):\n    \"\"\"Returns list of weights that are assigned to the control points of a curve\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index[opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      The weight values of the curve if successful.\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve\n    if type(curve) is not Rhino.Geometry.NurbsCurve:\n        nc = curve.ToNurbsCurve()\n    if nc is None: return scriptcontext.errorhandler()\n    return [pt.Weight for pt in nc.Points]\n\n\ndef DivideCurve(curve_id, segments, create_points=False, return_points=True):\n    \"\"\"Divides a curve object into a specified number of segments.\n    Parameters:\n      curve_id = identifier of the curve object\n      segments = The number of segments.\n      create_points [opt] = Create the division points. If omitted or False,\n          points are not created.\n      return_points [opt] = If omitted or True, points are returned.\n          If False, then a list of curve parameters are returned.\n    Returns:\n      If return_points is not specified or True, then a list containing 3D\n      division points.\n      If return_points is False, then an array containing division curve\n      parameters.\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc = curve.DivideByCount(segments, True)\n    if not rc: return scriptcontext.errorhandler()\n    if return_points or create_points:\n        outputpoints = [curve.PointAt(t) for t in rc]\n        if return_points: rc = outputpoints\n        if create_points:\n            for point in outputpoints:\n                if point.IsValid: scriptcontext.doc.Objects.AddPoint(point)\n    return rc\n\n\ndef DivideCurveEquidistant(curve_id, distance, create_points=False, return_points=True):\n    \"\"\"Divides a curve such that the linear distance between the points is equal.\n    Parameters:\n      curve_id = the object's identifier\n      distance = linear distance between division points\n      create_points[opt] = create the division points\n      return_points[opt] = If True, return a list of points.\n          If False, return a list of curve parameters\n    Returns:\n      A list of points or curve parameters based on the value of return_points\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    points = curve.DivideEquidistant(distance)\n    if not points: return scriptcontext.errorhandler()\n    if create_points:\n        for point in points: scriptcontext.doc.Objects.AddPoint(point)\n        scriptcontext.doc.Views.Redraw()\n    if return_points: return points\n    tvals = []\n    for point in points:\n        rc, t = curve.ClosestPoint(point)\n        tvals.append(t)\n    return tvals\n\n\ndef DivideCurveLength(curve_id, length, create_points=False, return_points=True):\n    \"\"\"Divides a curve object into segments of a specified length.\n    Parameters:\n      curve_id = identifier of the curve object\n      length = The length of each segment.\n      create_points [opt] = Create the division points. If omitted or False,\n          points are not created.\n      return_points [opt] = If omitted or True, points are returned.\n          If False, then a list of curve parameters are returned.\n    Returns:\n      If return_points is not specified or True, then a list containing 3D\n      division points if successful.\n      If return_points is False, then an array containing division curve\n      parameters if successful.\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc = curve.DivideByLength(length, True)\n    if not rc: return scriptcontext.errorhandler()\n    if return_points or create_points:\n        outputpoints = [curve.PointAt(t) for t in rc]\n        if create_points:\n            for point in outputpoints:\n                if (point.IsValid): scriptcontext.doc.Objects.AddPoint(point)\n        if return_points: rc = outputpoints\n    return rc\n\n\ndef EllipseCenterPoint(curve_id):\n    \"\"\"Returns the center point of an elliptical-shaped curve object.\n    Parameters:\n      curve_id = identifier of the curve object.    \n    Returns:\n      The 3D center point of the ellipse if successful.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc, ellipse = curve.TryGetEllipse()\n    if not rc: raise ValueError(\"curve is not an ellipse\")\n    return ellipse.Plane.Origin\n\n\ndef EllipseQuadPoints(curve_id):\n    \"\"\"Returns the quadrant points of an elliptical-shaped curve object.\n    Parameters:\n      curve_id = identifier of the curve object.\n    Returns:\n      Four 3D points identifying the quadrants of the ellipse\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc, ellipse = curve.TryGetEllipse()\n    if not rc: raise ValueError(\"curve is not an ellipse\")\n    origin = ellipse.Plane.Origin;\n    xaxis = ellipse.Radius1 * ellipse.Plane.XAxis;\n    yaxis = ellipse.Radius2 * ellipse.Plane.YAxis;\n    return (origin-xaxis, origin+xaxis, origin-yaxis, origin+yaxis)\n\n\ndef EvaluateCurve(curve_id, t, segment_index=-1):\n    \"\"\"Evaluates a curve at a parameter and returns a 3D point\n    Parameters:\n      curve_id = identifier of the curve object\n      t = the parameter to evaluate\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.PointAt(t)\n\n\ndef ExplodeCurves(curve_ids, delete_input=False):\n    \"\"\"Explodes, or un-joins, one curves. Polycurves will be exploded into curve\n    segments. Polylines will be exploded into line segments. ExplodeCurves will\n    return the curves in topological order. \n    Parameters:\n      curve_ids = the curve object(s) to explode.\n      delete_input[opt] = Delete input objects after exploding.\n    Returns:\n      List identifying the newly created curve objects\n    \"\"\"\n    if( type(curve_ids) is list or type(curve_ids) is tuple ): pass\n    else: curve_ids = [curve_ids]\n    rc = []\n    for id in curve_ids:\n        curve = rhutil.coercecurve(id, -1, True)\n        pieces = curve.DuplicateSegments()\n        if pieces:\n            for piece in pieces:\n                rc.append(scriptcontext.doc.Objects.AddCurve(piece))\n            if delete_input:\n                id = rhutil.coerceguid(id, True)\n                scriptcontext.doc.Objects.Delete(id, True)\n    if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ExtendCurve(curve_id, extension_type, side, boundary_object_ids):\n    \"\"\"Extends a non-closed curve object by a line, arc, or smooth extension\n    until it intersects a collection of objects.\n    Parameters:\n      curve_id: identifier of curve to extend\n      extension_type: 0 = line, 1 = arc, 2 = smooth\n      side: 0=extend from the start of the curve, 1=extend from the end of the curve\n      boundary_object_ids: curve, surface, and polysurface objects to extend to\n    Returns:\n      The identifier of the new object if successful.\n      None if not successful\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if extension_type==0: extension_type = Rhino.Geometry.CurveExtensionStyle.Line\n    elif extension_type==1: extension_type = Rhino.Geometry.CurveExtensionStyle.Arc\n    elif extension_type==2: extension_type = Rhino.Geometry.CurveExtensionStyle.Smooth\n    else: raise ValueError(\"extension_type must be 0, 1, or 2\")\n    \n    if side==0: side = Rhino.Geometry.CurveEnd.Start\n    elif side==1: side = Rhino.Geometry.CurveEnd.End\n    elif side==2: side = Rhino.Geometry.CurveEnd.Both\n    else: raise ValueError(\"side must be 0, 1, or 2\")\n    \n    rhobjs = [rhutil.coercerhinoobject(id) for id in boundary_object_ids]\n    if not rhobjs: raise ValueError(\"boundary_object_ids must contain at least one item\")\n    geometry = [obj.Geometry for obj in rhobjs]\n    newcurve = curve.Extend(side, extension_type, geometry)\n    if newcurve and newcurve.IsValid:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        if scriptcontext.doc.Objects.Replace(curve_id, newcurve):\n            scriptcontext.doc.Views.Redraw()\n            return curve_id\n    return scriptcontext.errorhandler()\n\n\ndef ExtendCurveLength(curve_id, extension_type, side, length):\n    \"\"\"Extends a non-closed curve object by a line, arc, or smooth extension\n    for a specified distance\n    Parameters:\n      curve_id: identifier of curve to extend\n      extension_type: 0 = line, 1 = arc, 2 = smooth\n      side: 0=extend from start of the curve, 1=extend from end of the curve\n      length: distance to extend\n    Returns:\n      The identifier of the new object\n      None if not successful\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if extension_type==0: extension_type = Rhino.Geometry.CurveExtensionStyle.Line\n    elif extension_type==1: extension_type = Rhino.Geometry.CurveExtensionStyle.Arc\n    elif extension_type==2: extension_type = Rhino.Geometry.CurveExtensionStyle.Smooth\n    else: raise ValueError(\"extension_type must be 0, 1, or 2\")\n    \n    if side==0: side = Rhino.Geometry.CurveEnd.Start\n    elif side==1: side = Rhino.Geometry.CurveEnd.End\n    elif side==2: side = Rhino.Geometry.CurveEnd.Both\n    else: raise ValueError(\"side must be 0, 1, or 2\")\n    \n    newcurve = curve.Extend(side, length, extension_type)\n    if newcurve and newcurve.IsValid:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        if scriptcontext.doc.Objects.Replace(curve_id, newcurve):\n            scriptcontext.doc.Views.Redraw()\n            return curve_id\n    return scriptcontext.errorhandler()\n\n\ndef ExtendCurvePoint(curve_id, side, point):\n    \"\"\"Extends a non-closed curve object by smooth extension to a point\n    Parameters:\n      curve_id: identifier of curve to extend\n      side: 0=extend from start of the curve, 1=extend from end of the curve\n      point: point to extend to\n    Returns:\n      The identifier of the new object if successful.\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    point = rhutil.coerce3dpoint(point, True)\n    \n    if side==0: side = Rhino.Geometry.CurveEnd.Start\n    elif side==1: side = Rhino.Geometry.CurveEnd.End\n    elif side==2: side = Rhino.Geometry.CurveEnd.Both\n    else: raise ValueError(\"side must be 0, 1, or 2\")\n    \n    extension_type = Rhino.Geometry.CurveExtensionStyle.Smooth\n    newcurve = curve.Extend(side, extension_type, point)\n    if newcurve and newcurve.IsValid:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        if scriptcontext.doc.Objects.Replace( curve_id, newcurve ):\n            scriptcontext.doc.Views.Redraw()\n            return curve_id\n    return scriptcontext.errorhandler()\n\n\ndef FairCurve(curve_id, tolerance=1.0):\n    \"\"\"Fairs a curve object. Fair works best on degree 3 (cubic) curves. Fair\n    attempts to remove large curvature variations while limiting the geometry\n    changes to be no more than the specified tolerance. Sometimes several\n    applications of this method are necessary to remove nasty curvature problems.\n    Parameters:\n      curve_id = identifier of the curve object\n      tolerance[opt] = fairing tolerance\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    angle_tol = 0.0\n    clamp = 0\n    if curve.IsPeriodic:\n        curve = curve.ToNurbsCurve()\n        clamp = 1\n    newcurve = curve.Fair(tolerance, angle_tol, clamp, clamp, 100)\n    if not newcurve: return False\n    curve_id = rhutil.coerceguid(curve_id, True)\n    if scriptcontext.doc.Objects.Replace(curve_id, newcurve):\n        scriptcontext.doc.Views.Redraw()\n        return True\n    return False\n\n\ndef FitCurve(curve_id, degree=3, distance_tolerance=-1, angle_tolerance=-1):\n    \"\"\"Reduces number of curve control points while maintaining the curve's same\n    general shape. Use this function for replacing curves with many control\n    points. For more information, see the Rhino help for the FitCrv command.\n    Parameters:\n      curve_id = Identifier of the curve object\n      degree [opt] = The curve degree, which must be greater than 1.\n                     The default is 3.\n      distance_tolerance [opt] = The fitting tolerance. If distance_tolerance\n          is not specified or <= 0.0, the document absolute tolerance is used.\n      angle_tolerance [opt] = The kink smoothing tolerance in degrees. If\n          angle_tolerance is 0.0, all kinks are smoothed. If angle_tolerance\n          is > 0.0, kinks smaller than angle_tolerance are smoothed. If\n          angle_tolerance is not specified or < 0.0, the document angle\n          tolerance is used for the kink smoothing.\n    Returns:\n      The identifier of the new object\n      None if not successful, or on error.\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if distance_tolerance is None or distance_tolerance<0:\n        distance_tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if angle_tolerance is None or angle_tolerance<0:\n        angle_tolerance = scriptcontext.doc.ModelAngleToleranceRadians\n    nc = curve.Fit(degree, distance_tolerance, angle_tolerance)\n    if nc:\n        rhobj = rhutil.coercerhinoobject(curve_id)\n        rc = None\n        if rhobj:\n            rc = scriptcontext.doc.Objects.AddCurve(curve, rhobj.Attributes)\n        else:\n            rc = scriptcontext.doc.Objects.AddCurve(curve)\n        if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n        scriptcontext.doc.Views.Redraw()\n        return rc\n    return scriptcontext.errorhandler()\n\n\ndef InsertCurveKnot(curve_id, parameter, symmetrical=False ):\n    \"\"\"Inserts a knot into a curve object\n    Parameters:\n      curve_id = identifier of the curve object\n      parameter = parameter on the curve\n      symmetrical[opt] = if True, then knots are added on both sides of\n          the center of the curve\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if not curve.Domain.IncludesParameter(parameter): return False\n    nc = curve.ToNurbsCurve()\n    if not nc: return False\n    rc, t = curve.GetNurbsFormParameterFromCurveParameter(parameter)\n    if rc:\n        rc = nc.Knots.InsertKnot(t,1)\n        if rc and symmetrical:\n            domain = nc.Domain\n            t_sym = domain.T1 - t + domain.T0\n            if abs(t_sym)>Rhino.RhinoMath.SqrtEpsilon:\n                rc = nc.Knots.InsertKnot(t_sym,1)\n        if rc:\n            curve_id = rhutil.coerceguid(curve_id)\n            rc = scriptcontext.doc.Objects.Replace(curve_id, nc)\n            if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef IsArc(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is an arc curve\n    Parameters:\n      curve_id = Identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.IsArc()\n\n\ndef IsCircle(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a circle curve\n    Parameters:\n      curve_id = Identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.IsCircle()\n\n\ndef IsCurve(object_id):\n    \"Verifies an object is a curve\"\n    curve = rhutil.coercecurve(object_id)\n    return curve is not None\n\n\ndef IsCurveClosable(curve_id, tolerance=None):\n    \"\"\"Decide if it makes sense to close off the curve by moving the end point\n    to the start point based on start-end gap size and length of curve as\n    approximated by chord defined by 6 points\n    Parameters:\n      curve_id = identifier of the curve object\n      tolerance[opt] = maximum allowable distance between start point and end\n        point. If omitted, the document's current absolute tolerance is used\n    Returns:\n      True or False\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if tolerance is None: tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    return curve.IsClosable(tolerance)\n\n\ndef IsCurveClosed(object_id):\n    curve = rhutil.coercecurve(object_id, -1, True)\n    return curve.IsClosed\n\n\ndef IsCurveInPlane(object_id, plane=None):\n    \"\"\"Test a curve to see if it lies in a specific plane\n    Parameters:\n      object_id = the object's identifier\n      plane[opt] = plane to test. If omitted, the active construction plane is used\n    Returns:\n      True or False\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, -1, True)\n    if not plane:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    else:\n        plane = rhutil.coerceplane(plane, True)\n    return curve.IsInPlane(plane, scriptcontext.doc.ModelAbsoluteTolerance)\n\n\ndef IsCurveLinear(object_id, segment_index=-1):\n    \"\"\"Verifies an object is a linear curve\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return curve.IsLinear()\n\n\ndef IsCurvePeriodic(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a periodic curve object\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.IsPeriodic\n\n\ndef IsCurvePlanar(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a planar curve\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    return curve.IsPlanar(tol)\n\n\ndef IsCurveRational(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a rational NURBS curve\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    if isinstance(curve, Rhino.Geometry.NurbsCurve): return curve.IsRational\n    return False\n\n\ndef IsEllipse(object_id):\n    \"\"\"Verifies an object is an elliptical-shaped curve\n    Parameters:\n      curve_id = identifier of the curve object\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return curve.IsEllipse()\n\n\ndef IsLine(object_id, segment_index=-1):\n    \"\"\"Verifies an object is a line curve\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return isinstance(curve, Rhino.Geometry.LineCurve)\n\n\ndef IsPointOnCurve(object_id, point, segment_index=-1):\n    \"\"\"Verifies that a point is on a curve\n    Parameters:\n      curve_id = identifier of the curve object\n      point = the test point\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    point = rhutil.coerce3dpoint(point, True)\n    rc, t = curve.ClosestPoint(point, Rhino.RhinoMath.SqrtEpsilon)\n    return rc\n\n\ndef IsPolyCurve(object_id, segment_index=-1):\n    \"\"\"Verifies an object is a PolyCurve curve\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return isinstance(curve, Rhino.Geometry.PolyCurve)\n\n\ndef IsPolyline( object_id, segment_index=-1 ):\n    \"\"\"Verifies an object is a Polyline curve object\n    Parameters:\n      curve_id = identifier of the curve object\n      segment_index [opt] = the curve segment if curve_id identifies a polycurve\n    Returns:\n      True or False\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return isinstance(curve, Rhino.Geometry.PolylineCurve)\n\n\ndef JoinCurves(object_ids, delete_input=False, tolerance=None):\n    \"\"\"Joins multiple curves together to form one or more curves or polycurves\n    Parameters:\n      object_ids = list of identifiers of multiple curve objects\n      delete_input[opt] = delete input objects after joining\n      tolerance[opt] = join tolerance. If omitted, 2.1 * document absolute\n          tolerance is used\n    Returns:\n      List of Guids representing the new curves\n    \"\"\"\n    if len(object_ids)<2: raise ValueError(\"object_ids must contain at least 2 items\")\n    curves = [rhutil.coercecurve(id, -1, True) for id in object_ids]\n    if tolerance is None:\n        tolerance = 2.1 * scriptcontext.doc.ModelAbsoluteTolerance\n    newcurves = Rhino.Geometry.Curve.JoinCurves(curves, tolerance)\n    rc = []\n    if newcurves:\n        rc = [scriptcontext.doc.Objects.AddCurve(crv) for crv in newcurves]\n    if rc and delete_input:\n        for id in object_ids:\n            id = rhutil.coerceguid(id, True)\n            scriptcontext.doc.Objects.Delete(id, False)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef LineFitFromPoints(points):\n    \"\"\"Returns a line that was fit through an array of 3D points\n    Parameters:\n      points = a list of at least two 3D points\n    Returns:\n      line on success\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    rc, line = Rhino.Geometry.Line.TryFitLineToPoints(points)\n    if rc: return line\n    return scriptcontext.errorhandler()\n\n\ndef MakeCurveNonPeriodic(curve_id, delete_input=False):\n    \"\"\"Makes a periodic curve non-periodic. Non-periodic curves can develop\n    kinks when deformed\n    Parameters:\n      curve_id = identifier of the curve object\n      delete_input[opt] = delete the input curve\n    Returns:\n      id of the new or modified curve if successful\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if not curve.IsPeriodic: return scriptcontext.errorhandler()\n    nc = curve.ToNurbsCurve()\n    if nc is None: return scriptcontext.errorhandler()\n    nc.Knots.ClampEnd( Rhino.Geometry.CurveEnd.Both )\n    rc = None\n    if delete_input:\n        if type(curve_id) is Rhino.DocObjects.ObjRef: pass\n        else: curve_id = rhutil.coerceguid(curve_id)\n        if curve_id:\n            rc = scriptcontext.doc.Objects.Replace(curve_id, nc)\n            if not rc: return scriptcontext.errorhandler()\n            rc = rhutil.coerceguid(curve_id)\n    else:\n        attrs = None\n        if type(scriptcontext.doc) is Rhino.RhinoDoc:\n            rhobj = rhutil.coercerhinoobject(curve_id)\n            if rhobj: attrs = rhobj.Attributes\n        rc = scriptcontext.doc.Objects.AddCurve(nc, attrs)\n        if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef MeshPolyline(polyline_id):\n    \"\"\"Creates a polygon mesh object based on a closed polyline curve object.\n    The newly created mesh object is added to the document\n    Parameters:\n      polyline_id = identifier of the polyline curve object\n    Returns:\n      identifier of the new mesh object\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(polyline_id, -1, True)\n    mesh = Rhino.Geometry.Mesh.CreateFromPlanarBoundary(curve)\n    if mesh is None: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddMesh(mesh)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef OffsetCurve(object_id, direction, distance, normal=None, style=1):\n    \"\"\"Offsets a curve by a distance. The offset curve will be added to Rhino\n    Parameters:\n      object_id = identifier of a curve object\n      direction = point describing direction of the offset\n      distance = distance of the offset\n      normal[opt] = normal of the plane in which the offset will occur.\n          If omitted, the normal of the active construction plane will be used\n      style[opt] = the corner style\n          0 = None\n          1 = Sharp\n          2 = Round\n          3 = Smooth\n          4 = Chamfer\n    Returns:\n      List of ids for the new curves on success\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, -1, True)\n    direction = rhutil.coerce3dpoint(direction, True)\n    if normal:\n        normal = rhutil.coerce3dvector(normal, True)\n    else:\n        normal = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane().Normal\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    style = System.Enum.ToObject(Rhino.Geometry.CurveOffsetCornerStyle, style)\n    curves = curve.Offset(direction, normal, distance, tolerance, style)\n    if curves is None: return scriptcontext.errorhandler()\n    rc = [scriptcontext.doc.Objects.AddCurve(curve) for curve in curves]\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef OffsetCurveOnSurface(curve_id, surface_id, distance_or_parameter):\n    \"\"\"Offset a curve on a surface. The source curve must lie on the surface.\n    The offset curve or curves will be added to Rhino\n    Parameters:\n      curve_id, surface_id = curve and surface identifiers\n      distance_or_parameter = If a single number is passed, then this is the\n        distance of the offset. Based on the curve's direction, a positive value\n        will offset to the left and a negative value will offset to the right.\n        If a tuple of two values is passed, this is interpreted as the surface\n        U,V parameter that the curve will be offset through\n    Returns:\n      Identifiers of the new curves if successful\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    surface = rhutil.coercesurface(surface_id, True)\n    x = None\n    if type(distance_or_parameter) is list or type(distance_or_parameter) is tuple:\n        x = Rhino.Geometry.Point2d( distance_or_parameter[0], distance_or_parameter[1] )\n    else:\n        x = float(distance_or_parameter)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    curves = curve.OffsetOnSurface(surface, x, tol)\n    if curves is None: return scriptcontext.errorhandler()\n    rc = [scriptcontext.doc.Objects.AddCurve(curve) for curve in curves]\n    if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef PlanarClosedCurveContainment(curve_a, curve_b, plane=None, tolerance=None):\n    \"\"\"Determines the relationship between the regions bounded by two coplanar\n    simple closed curves\n    Paramters:\n      curve_a, curve_b = identifiers of two planar, closed curves\n      plane[opt] = test plane. If omitted, the currently active construction\n        plane is used\n      tolerance[opt] = if omitted, the document absolute tolerance is used\n    Returns:\n      a number identifying the relationship if successful\n        0 = the regions bounded by the curves are disjoint\n        1 = the two curves intersect\n        2 = the region bounded by curve_a is inside of curve_b\n        3 = the region bounded by curve_b is inside of curve_a\n      None if not successful\n    \"\"\"\n    curve_a = rhutil.coercecurve(curve_a, -1, True)\n    curve_b = rhutil.coercecurve(curve_b, -1, True)\n    if tolerance is None or tolerance<=0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if plane:\n        plane = rhutil.coerceplane(plane)\n    else:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    rc = Rhino.Geometry.Curve.PlanarClosedCurveContainmentTest(curve_a, curve_b, plane, tolerance)\n    return rc\n\n\ndef PointInPlanarClosedCurve(point, curve, plane=None, tolerance=None):\n    \"\"\"Determines if a point is inside of a closed curve, on a closed curve, or\n    outside of a closed curve\n    Parameters:\n      point = text point\n      curve = identifier of a curve object\n      plane[opt] = plane containing the closed curve and point. If omitted,\n          the currently active construction plane is used\n      tolerance[opt] = it omitted, the document abosulte tolerance is used\n    Returns:\n      number identifying the result if successful\n          0 = point is outside of the curve\n          1 = point is inside of the curve\n          2 = point in on the curve\n    \"\"\"\n    point = rhutil.coerce3dpoint(point, True)\n    curve = rhutil.coercecurve(curve, -1, True)\n    if tolerance is None or tolerance<=0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if plane:\n        plane = rhutil.coerceplane(plane)\n    else:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    rc = curve.Contains(point, plane, tolerance)\n    if rc==Rhino.Geometry.PointContainment.Unset: raise Exception(\"Curve.Contains returned Unset\")\n    if rc==Rhino.Geometry.PointContainment.Outside: return 0\n    if rc==Rhino.Geometry.PointContainment.Inside: return 1\n    return 2\n\n\ndef PolyCurveCount(curve_id, segment_index=-1):\n    \"\"\"Returns the number of curve segments that make up a polycurve\"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    if isinstance(curve, Rhino.Geometry.PolyCurve): return curve.SegmentCount\n    raise ValueError(\"curve_id does not reference a polycurve\")\n\n\ndef PolylineVertices(curve_id, segment_index=-1):\n    \"Returns the vertices of a polyline curve on success\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, polyline = curve.TryGetPolyline()\n    if rc: return [pt for pt in polyline]\n    raise ValueError(\"curve_id does not reference a polyline\")\n\n\ndef ProjectCurveToMesh(curve_ids, mesh_ids, direction):\n    \"\"\"Projects one or more curves onto one or more surfaces or meshes\n    Parameters:\n      curve_ids = identifiers of curves to project\n      mesh_ids = identifiers of meshes to project onto\n      direction = projection direction\n    Returns:\n      list of identifiers\n    \"\"\"\n    curve_ids = rhutil.coerceguidlist(curve_ids)\n    mesh_ids = rhutil.coerceguidlist(mesh_ids)\n    direction = rhutil.coerce3dvector(direction, True)\n    curves = [rhutil.coercecurve(id, -1, True) for id in curve_ids]\n    meshes = [rhutil.coercemesh(id, True) for id in mesh_ids]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newcurves = Rhino.Geometry.Curve.ProjectToMesh(curves, meshes, direction, tolerance)\n    ids = [scriptcontext.doc.Objects.AddCurve(curve) for curve in newcurves]\n    if ids: scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef ProjectCurveToSurface(curve_ids, surface_ids, direction):\n    \"\"\"Projects one or more curves onto one or more surfaces or polysurfaces\n    Parameters:\n      curve_ids = identifiers of curves to project\n      surface_ids = identifiers of surfaces to project onto\n      direction = projection direction\n    Returns:\n      list of identifiers\n    \"\"\"\n    curve_ids = rhutil.coerceguidlist(curve_ids)\n    surface_ids = rhutil.coerceguidlist(surface_ids)\n    direction = rhutil.coerce3dvector(direction, True)\n    curves = [rhutil.coercecurve(id, -1, True) for id in curve_ids]\n    breps = [rhutil.coercebrep(id, True) for id in surface_ids]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newcurves = Rhino.Geometry.Curve.ProjectToBrep(curves, breps, direction, tolerance)\n    ids = [scriptcontext.doc.Objects.AddCurve(curve) for curve in newcurves]\n    if ids: scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef RebuildCurve(curve_id, degree=3, point_count=10):\n    \"\"\"Rebuilds a curve to a given degree and control point count. For more\n    information, see the Rhino help for the Rebuild command.\n    Parameters:\n      curve_id = identifier of the curve object\n      degree[opt] = new degree (must be greater than 0)\n      point_count [opt] = new point count, which must be bigger than degree.\n    Returns:\n      True of False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if degree<1: raise ValueError(\"degree must be greater than 0\")\n    newcurve = curve.Rebuild(point_count, degree, False)\n    if not newcurve: return False\n    scriptcontext.doc.Objects.Replace(curve_id, newcurve)\n    scriptcontext.doc.Views.Redraw()\n    return True\n\n\ndef ReverseCurve(curve_id):\n    \"\"\"Reverses the direction of a curve object. Same as Rhino's Dir command\n    Parameters:\n      curve_id = identifier of the curve object\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if curve.Reverse():\n        curve_id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Replace(curve_id, curve)\n        return True\n    return False\n\n\ndef SimplifyCurve(curve_id, flags=0):\n    \"Replace a curve with a geometrically equivalent polycurve\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    _flags = Rhino.Geometry.CurveSimplifyOptions.All\n    if( flags&1 ==1 ): _flags = _flags - Rhino.Geometry.CurveSimplifyOptions.SplitAtFullyMultipleKnots\n    if( flags&2 ==2 ): _flags = _flags - Rhino.Geometry.CurveSimplifyOptions.RebuildLines\n    if( flags&4 ==4 ): _flags = _flags - Rhino.Geometry.CurveSimplifyOptions.RebuildArcs\n    if( flags&8 ==8 ): _flags = _flags - Rhino.Geometry.CurveSimplifyOptions.RebuildRationals\n    if( flags&16==16 ): _flags = _flags - Rhino.Geometry.CurveSimplifyOptions.AdjustG1\n    if( flags&32==32 ): _flags = _flags - Rhino.Geometry.CurveSimplifyOptions.Merge\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    ang_tol = scriptcontext.doc.ModelAngleToleranceRadians\n    newcurve = curve.Simplify(_flags, tol, ang_tol)\n    if newcurve:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Replace(curve_id, newcurve)\n        scriptcontext.doc.Views.Redraw()\n        return True\n    return False\n\n\ndef SplitCurve(curve_id, parameter, delete_input=True):\n    \"\"\"Splits, or divides, a curve at a specified parameter. The parameter must\n    be in the interior of the curve's domain\n    Parameters:\n      curve_id = identifier of the curve object\n      parameter = one or more parameters to split the curve at\n      delete_input[opt] = delete the input curve\n    Returns:\n      list of new curve ids on success\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    newcurves = curve.Split(parameter)\n    if newcurves is None: return scriptcontext.errorhandler()\n    att = None\n    rhobj = rhutil.coercerhinoobject(curve_id)\n    if rhobj: att = rhobj.Attributes\n    rc = [scriptcontext.doc.Objects.AddCurve(crv, att) for crv in newcurves]\n    if rc and delete_input:\n        id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef TrimCurve(curve_id, interval, delete_input=True):\n    \"\"\"Trims a curve by removing portions of the curve outside a specified interval\n    Paramters:\n      curve_id = identifier of the curve object\n      interval = two numbers indentifying the interval to keep. Portions of\n        the curve before domain[0] and after domain[1] will be removed. If the\n        input curve is open, the interval must be increasing. If the input\n        curve is closed and the interval is decreasing, then the portion of\n        the curve across the start and end of the curve is returned\n      delete_input[opt] = delete the input curve\n    Reutrns:\n      identifier of the new curve on success\n      None on failure\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if interval[0]==interval[1]: raise ValueError(\"interval values are equal\")\n    newcurve = curve.Trim(interval[0], interval[1])\n    if not newcurve: return scriptcontext.errorhandler()\n    att = None\n    rhobj = rhutil.coercerhinoobject(curve_id)\n    if rhobj: att = rhobj.Attributes\n    rc = scriptcontext.doc.Objects.AddCurve(newcurve, att)\n    if delete_input:\n        id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}