{
  "source_url": "https://github.com/969flash/DesignAutomationLecture/blob/4e85efcd91e11c0715f2ff7d7e1162cc84c942f1/stub/RhinoStub/rhino3d-8.19.25132.1001/Rhino/Geometry/Intersect/__init__.pyi",
  "repo": "969flash/DesignAutomationLecture",
  "repo_stars": 0,
  "repo_description": "DesignAutomationLecture",
  "license": "unknown",
  "filepath": "stub/RhinoStub/rhino3d-8.19.25132.1001/Rhino/Geometry/Intersect/__init__.pyi",
  "instruction": "this file is auto-generated by rhinocode stubmaker. do not make changes",
  "code": "\"\"\"this file is auto-generated by rhinocode stubmaker. do not make changes\"\"\"\n\n# region: Exports\n__all__ = [\"Intersection\", \"PlaneCircleIntersection\", \"PlaneSphereIntersection\", \"LineCircleIntersection\", \"LineSphereIntersection\", \"LineCylinderIntersection\", \"SphereSphereIntersection\", \"ArcArcIntersection\", \"CircleCircleIntersection\", \"IntersectionEvent\", \"RayShootEvent\", \"CurveIntersections\", \"MeshIntersectionCache\", \"MeshInterference\", \"MeshClash\"]\n# endregion\n\n# region: Imports\nfrom Rhino import DocObjects\nfrom Rhino import FileIO\nfrom Rhino import Geometry\nfrom System import Threading\nfrom System.Collections import Generic\nfrom System.Runtime import CompilerServices\nfrom typing import overload\nimport enum\nimport System\n# endregion\n\n# region: RhinoCommon, Version=8.19.25132.1001\n\nclass Intersection(object):\n    \"\"\"Provides static methods for the computation of intersections, projections, sections and similar.\n\n    \"\"\"\n    @overload\n    @staticmethod\n    def ArcArc(arcA: Geometry.Arc, arcB: Geometry.Arc) -> (ArcArcIntersection, Geometry.Point3d, Geometry.Point3d): ...\n    @overload\n    @staticmethod\n    def BrepBrep(brepA: Geometry.Brep, brepB: Geometry.Brep, tolerance: float) -> (bool, Geometry.System.Array[Geometry.Curve], Geometry.System.Array[Geometry.Point3d]): ...\n    @overload\n    @staticmethod\n    def BrepBrep(brepA: Geometry.Brep, brepB: Geometry.Brep, tolerance: float, joinCurves: bool) -> (bool, Geometry.System.Array[Geometry.Curve], Geometry.System.Array[Geometry.Point3d]): ...\n    @overload\n    @staticmethod\n    def BrepPlane(brep: Geometry.Brep, plane: Geometry.Plane, tolerance: float) -> (bool, Geometry.System.Array[Geometry.Curve], Geometry.System.Array[Geometry.Point3d]): ...\n    @overload\n    @staticmethod\n    def BrepSurface(brep: Geometry.Brep, surface: Geometry.Surface, tolerance: float) -> (bool, Geometry.System.Array[Geometry.Curve], Geometry.System.Array[Geometry.Point3d]): ...\n    @overload\n    @staticmethod\n    def BrepSurface(brep: Geometry.Brep, surface: Geometry.Surface, tolerance: float, joinCurves: bool) -> (bool, Geometry.System.Array[Geometry.Curve], Geometry.System.Array[Geometry.Point3d]): ...\n    @overload\n    @staticmethod\n    def CircleCircle(circleA: Geometry.Circle, circleB: Geometry.Circle) -> (CircleCircleIntersection, Geometry.Point3d, Geometry.Point3d): ...\n    @overload\n    @staticmethod\n    def CurveBrep(curve: Geometry.Curve, brep: Geometry.Brep, tolerance: float, angleTolerance: float) -> (bool, System.System.Array[float]): ...\n    @overload\n    @staticmethod\n    def CurveBrep(curve: Geometry.Curve, brep: Geometry.Brep, tolerance: float) -> (bool, Geometry.System.Array[Geometry.Curve], Geometry.System.Array[Geometry.Point3d]): ...\n    @overload\n    @staticmethod\n    def CurveBrep(curve: Geometry.Curve, brep: Geometry.Brep, tolerance: float) -> (bool, Geometry.System.Array[Geometry.Curve], Geometry.System.Array[Geometry.Point3d], System.System.Array[float]): ...\n    @overload\n    @staticmethod\n    def CurveBrepFace(curve: Geometry.Curve, face: Geometry.BrepFace, tolerance: float) -> (bool, Geometry.System.Array[Geometry.Curve], Geometry.System.Array[Geometry.Point3d]): ...\n    @overload\n    @staticmethod\n    def CurveCurve(curveA: Geometry.Curve, curveB: Geometry.Curve, tolerance: float, overlapTolerance: float) -> CurveIntersections: ...\n    @overload\n    @staticmethod\n    def CurveCurveValidate(curveA: Geometry.Curve, curveB: Geometry.Curve, tolerance: float, overlapTolerance: float) -> (CurveIntersections, System.System.Array[int], FileIO.TextLog): ...\n    @overload\n    @staticmethod\n    def CurveLine(curve: Geometry.Curve, line: Geometry.Line, tolerance: float, overlapTolerance: float) -> CurveIntersections: ...\n    @overload\n    @staticmethod\n    def CurvePlane(curve: Geometry.Curve, plane: Geometry.Plane, tolerance: float) -> CurveIntersections: ...\n    @overload\n    @staticmethod\n    def CurveSelf(curve: Geometry.Curve, tolerance: float) -> CurveIntersections: ...\n    @overload\n    @staticmethod\n    def CurveSurface(curve: Geometry.Curve, surface: Geometry.Surface, tolerance: float, overlapTolerance: float) -> CurveIntersections: ...\n    @overload\n    @staticmethod\n    def CurveSurface(curve: Geometry.Curve, curveDomain: Geometry.Interval, surface: Geometry.Surface, tolerance: float, overlapTolerance: float) -> CurveIntersections: ...\n    @overload\n    @staticmethod\n    def CurveSurfaceValidate(curve: Geometry.Curve, surface: Geometry.Surface, tolerance: float, overlapTolerance: float) -> (CurveIntersections, System.System.Array[int], FileIO.TextLog): ...\n    @overload\n    @staticmethod\n    def CurveSurfaceValidate(curve: Geometry.Curve, curveDomain: Geometry.Interval, surface: Geometry.Surface, tolerance: float, overlapTolerance: float) -> (CurveIntersections, System.System.Array[int], FileIO.TextLog): ...\n    @property\n    def MeshIntersectionsTolerancesCoefficient(self) -> float: ...\n    @overload\n    @staticmethod\n    def LineBox(line: Geometry.Line, box: Geometry.Box, tolerance: float) -> (bool, Geometry.Interval): ...\n    @overload\n    @staticmethod\n    def LineBox(line: Geometry.Line, box: Geometry.BoundingBox, tolerance: float) -> (bool, Geometry.Interval): ...\n    @overload\n    @staticmethod\n    def LineCircle(line: Geometry.Line, circle: Geometry.Circle) -> (LineCircleIntersection, float, Geometry.Point3d, float, Geometry.Point3d): ...\n    @overload\n    @staticmethod\n    def LineCylinder(line: Geometry.Line, cylinder: Geometry.Cylinder) -> (LineCylinderIntersection, Geometry.Point3d, Geometry.Point3d): ...\n    @overload\n    @staticmethod\n    def LineLine(lineA: Geometry.Line, lineB: Geometry.Line) -> (bool, float, float): ...\n    @overload\n    @staticmethod\n    def LineLine(lineA: Geometry.Line, lineB: Geometry.Line, tolerance: float, finiteSegments: bool) -> (bool, float, float): ...\n    @overload\n    @staticmethod\n    def LinePlane(line: Geometry.Line, plane: Geometry.Plane) -> (bool, float): ...\n    @overload\n    @staticmethod\n    def LineSphere(line: Geometry.Line, sphere: Geometry.Sphere) -> (LineSphereIntersection, Geometry.Point3d, Geometry.Point3d): ...\n    @overload\n    @staticmethod\n    def MeshLine(mesh: Geometry.Mesh, line: Geometry.Line) -> Geometry.System.Array[Geometry.Point3d]: ...\n    @overload\n    @staticmethod\n    def MeshLine(mesh: Geometry.Mesh, line: Geometry.Line) -> (Geometry.System.Array[Geometry.Point3d], System.System.Array[int]): ...\n    @overload\n    @staticmethod\n    def MeshLineSorted(mesh: Geometry.Mesh, line: Geometry.Line) -> (Geometry.System.Array[Geometry.Point3d], System.System.Array[int]): ...\n    @overload\n    @staticmethod\n    def MeshMesh(meshes: Generic.IEnumerable, tolerance: float, overlapsPolylines: bool, overlapsMesh: bool, textLog: FileIO.TextLog, cancel: Threading.CancellationToken, progress: System.IProgress) -> (bool, Geometry.System.Array[Geometry.Polyline], Geometry.System.Array[Geometry.Polyline], Geometry.Mesh): ...\n    @overload\n    @staticmethod\n    def MeshMeshAccurate(meshA: Geometry.Mesh, meshB: Geometry.Mesh, tolerance: float) -> Geometry.System.Array[Geometry.Polyline]: ...\n    @overload\n    @staticmethod\n    def MeshMeshFast(meshA: Geometry.Mesh, meshB: Geometry.Mesh) -> Geometry.System.Array[Geometry.Line]: ...\n    @overload\n    @staticmethod\n    def MeshMeshPredicate(meshes: Generic.IEnumerable, tolerance: float, textLog: FileIO.TextLog) -> (bool, System.System.Array[int]): ...\n    @overload\n    @staticmethod\n    def MeshPlane(mesh: Geometry.Mesh, planes: Generic.IEnumerable) -> Geometry.System.Array[Geometry.Polyline]: ...\n    @overload\n    @staticmethod\n    def MeshPlane(mesh: Geometry.Mesh, plane: Geometry.Plane) -> Geometry.System.Array[Geometry.Polyline]: ...\n    @overload\n    @staticmethod\n    def MeshPlane(mesh: Geometry.Mesh, cache: MeshIntersectionCache, plane: Geometry.Plane, tolerance: float) -> Geometry.System.Array[Geometry.Polyline]: ...\n    @overload\n    @staticmethod\n    def MeshPlane(mesh: Geometry.Mesh, cache: MeshIntersectionCache, planes: Generic.IEnumerable, tolerance: float) -> Geometry.System.Array[Geometry.Polyline]: ...\n    @overload\n    @staticmethod\n    def MeshPolyline(mesh: Geometry.Mesh, curve: Geometry.PolylineCurve) -> (Geometry.System.Array[Geometry.Point3d], System.System.Array[int]): ...\n    @overload\n    @staticmethod\n    def MeshPolylineSorted(mesh: Geometry.Mesh, curve: Geometry.PolylineCurve) -> (Geometry.System.Array[Geometry.Point3d], System.System.Array[int]): ...\n    @overload\n    @staticmethod\n    def MeshRay(mesh: Geometry.Mesh, ray: Geometry.Ray3d) -> float: ...\n    @overload\n    @staticmethod\n    def MeshRay(mesh: Geometry.Mesh, ray: Geometry.Ray3d) -> (float, System.System.Array[int]): ...\n    @overload\n    @staticmethod\n    def PlaneBoundingBox(plane: Geometry.Plane, boundingBox: Geometry.BoundingBox) -> (bool, Geometry.Polyline): ...\n    @overload\n    @staticmethod\n    def PlaneCircle(plane: Geometry.Plane, circle: Geometry.Circle) -> (PlaneCircleIntersection, float, float): ...\n    @overload\n    @staticmethod\n    def PlanePlane(planeA: Geometry.Plane, planeB: Geometry.Plane) -> (bool, Geometry.Line): ...\n    @overload\n    @staticmethod\n    def PlanePlanePlane(planeA: Geometry.Plane, planeB: Geometry.Plane, planeC: Geometry.Plane) -> (bool, Geometry.Point3d): ...\n    @overload\n    @staticmethod\n    def PlaneSphere(plane: Geometry.Plane, sphere: Geometry.Sphere) -> (PlaneSphereIntersection, Geometry.Circle): ...\n    @overload\n    @staticmethod\n    def ProjectPointsToBreps(breps: Generic.IEnumerable, points: Generic.IEnumerable, direction: Geometry.Vector3d, tolerance: float) -> Geometry.System.Array[Geometry.Point3d]: ...\n    @overload\n    @staticmethod\n    def ProjectPointsToBrepsEx(breps: Generic.IEnumerable, points: Generic.IEnumerable, direction: Geometry.Vector3d, tolerance: float) -> (Geometry.System.Array[Geometry.Point3d], System.System.Array[int]): ...\n    @overload\n    @staticmethod\n    def ProjectPointsToMeshes(meshes: Generic.IEnumerable, points: Generic.IEnumerable, direction: Geometry.Vector3d, tolerance: float) -> Geometry.System.Array[Geometry.Point3d]: ...\n    @overload\n    @staticmethod\n    def ProjectPointsToMeshesEx(meshes: Generic.IEnumerable, points: Generic.IEnumerable, direction: Geometry.Vector3d, tolerance: float) -> (Geometry.System.Array[Geometry.Point3d], System.System.Array[int]): ...\n    @overload\n    @staticmethod\n    def RayShoot(ray: Geometry.Ray3d, geometry: Generic.IEnumerable, maxReflections: int) -> Geometry.System.Array[Geometry.Point3d]: ...\n    @overload\n    @staticmethod\n    def RayShoot(geometry: Generic.IEnumerable, ray: Geometry.Ray3d, maxReflections: int) -> System.Array[RayShootEvent]: ...\n    @overload\n    @staticmethod\n    def SphereSphere(sphereA: Geometry.Sphere, sphereB: Geometry.Sphere) -> (SphereSphereIntersection, Geometry.Circle): ...\n    @overload\n    @staticmethod\n    def SurfaceSurface(surfaceA: Geometry.Surface, surfaceB: Geometry.Surface, tolerance: float) -> (bool, Geometry.System.Array[Geometry.Curve], Geometry.System.Array[Geometry.Point3d]): ...\n\nclass PlaneCircleIntersection(enum.Enum):\n    None_ = 0\n    Tangent = 1\n    Secant = 2\n    Parallel = 3\n    Coincident = 4\n\nclass PlaneSphereIntersection(enum.Enum):\n    None_ = 0\n    Point = 1\n    Circle = 2\n\nclass LineCircleIntersection(enum.Enum):\n    None_ = 0\n    Single = 1\n    Multiple = 2\n\nclass LineSphereIntersection(enum.Enum):\n    None_ = 0\n    Single = 1\n    Multiple = 2\n\nclass LineCylinderIntersection(enum.Enum):\n    None_ = 0\n    Single = 1\n    Multiple = 2\n    Overlap = 3\n\nclass SphereSphereIntersection(enum.Enum):\n    None_ = 0\n    Point = 1\n    Circle = 2\n    Overlap = 3\n\nclass ArcArcIntersection(enum.Enum):\n    None_ = 0\n    Single = 1\n    Multiple = 2\n    Overlap = 3\n\nclass CircleCircleIntersection(enum.Enum):\n    None_ = 0\n    Single = 1\n    Multiple = 2\n    Overlap = 3\n\nclass IntersectionEvent(object):\n    \"\"\"Provides all the information for a single Curve Intersection event.\n\n    \"\"\"\n    def __init__(self): ...\n    @overload\n    @staticmethod\n    def CompareEquivalent(eventA: IntersectionEvent, eventB: IntersectionEvent, relativePointTolerance: float) -> bool: ...\n    @overload\n    @staticmethod\n    def CompareEquivalent(eventA: IntersectionEvent, eventB: IntersectionEvent, relativePointTolerance: float, log: FileIO.TextLog) -> bool: ...\n    @property\n    def IsOverlap(self) -> bool: ...\n    @property\n    def IsPoint(self) -> bool: ...\n    @property\n    def OverlapA(self) -> Geometry.Interval: ...\n    @property\n    def OverlapB(self) -> Geometry.Interval: ...\n    @property\n    def ParameterA(self) -> float: ...\n    @property\n    def ParameterB(self) -> float: ...\n    @property\n    def PointA(self) -> Geometry.Point3d: ...\n    @property\n    def PointA2(self) -> Geometry.Point3d: ...\n    @property\n    def PointB(self) -> Geometry.Point3d: ...\n    @property\n    def PointB2(self) -> Geometry.Point3d: ...\n    @overload\n    def SurfaceOverlapParameter() -> (Geometry.Interval, Geometry.Interval): ...\n    @overload\n    def SurfacePointParameter() -> (float, float): ...\n\nclass RayShootEvent(System.ValueType):\n    \"\"\"Represents an element which is part of a ray shoot.\n\n    \"\"\"\n    @property\n    def BrepFaceIndex(self) -> int: ...\n    @property\n    def GeometryIndex(self) -> int: ...\n    @property\n    def Point(self) -> Geometry.Point3d: ...\n    @BrepFaceIndex.setter\n    def BrepFaceIndex(self, value: System.Void): ...\n    @GeometryIndex.setter\n    def GeometryIndex(self, value: System.Void): ...\n    @Point.setter\n    def Point(self, value: System.Void): ...\n\nclass CurveIntersections(object):\n    \"\"\"Maintains an ordered list of Curve Intersection results.\n\n    \"\"\"\n    @overload\n    def CopyTo(self, array: System.Array[IntersectionEvent], arrayIndex: int) -> None: ...\n    @overload\n    def Dispose() -> None: ...\n    @property\n    def Count(self) -> int: ...\n    @property\n    def Item(self) -> IntersectionEvent: ...\n    @overload\n    def GetEnumerator() -> Generic.IEnumerator: ...\n\nclass MeshIntersectionCache(object):\n    \"\"\"Provides a mechanism for lazily evaluating mesh data.\n\n    \"\"\"\n    def __init__(self): ...\n    @overload\n    def Dispose() -> None: ...\n\nclass MeshInterference(System.ValueType):\n    \"\"\"Represents an element which is part of a clash or intersection between two meshes.\n\n    \"\"\"\n    @property\n    def HitPoints(self) -> Geometry.System.Array[Geometry.Point3d]: ...\n    @property\n    def IndexA(self) -> int: ...\n    @property\n    def IndexB(self) -> int: ...\n    @HitPoints.setter\n    def HitPoints(self, value: System.Void): ...\n    @IndexA.setter\n    def IndexA(self, value: System.Void): ...\n    @IndexB.setter\n    def IndexB(self, value: System.Void): ...\n\nclass MeshClash(object):\n    \"\"\"Represents a particular instance of a clash or intersection between two meshes.\n\n    \"\"\"\n    @overload\n    @staticmethod\n    def FindDetail(objA: DocObjects.RhinoObject, objB: DocObjects.RhinoObject, distance: float) -> Geometry.System.Array[Geometry.Mesh]: ...\n    @overload\n    @staticmethod\n    def FindDetail(objA: DocObjects.RhinoObject, objB: DocObjects.RhinoObject, distance: float, meshType: Geometry.MeshType, meshingParameters: Geometry.MeshingParameters) -> Geometry.System.Array[Geometry.Mesh]: ...\n    @property\n    def ClashPoint(self) -> Geometry.Point3d: ...\n    @property\n    def ClashRadius(self) -> float: ...\n    @property\n    def MeshA(self) -> Geometry.Mesh: ...\n    @property\n    def MeshB(self) -> Geometry.Mesh: ...\n    @overload\n    @staticmethod\n    def Search(setA: Generic.IEnumerable, setB: Generic.IEnumerable, distance: float) -> System.Array[MeshInterference]: ...\n    @overload\n    @staticmethod\n    def Search(setA: Generic.IEnumerable, setB: Generic.IEnumerable, distance: float, maxEventCount: int) -> System.Array[MeshClash]: ...\n    @overload\n    @staticmethod\n    def Search(meshA: Geometry.Mesh, setB: Generic.IEnumerable, distance: float, maxEventCount: int) -> System.Array[MeshClash]: ...\n    @overload\n    @staticmethod\n    def Search(meshA: Geometry.Mesh, meshB: Geometry.Mesh, distance: float, maxEventCount: int) -> System.Array[MeshClash]: ...\n    @overload\n    @staticmethod\n    def Search(setA: Generic.IEnumerable, setB: Generic.IEnumerable, distance: float, meshType: Geometry.MeshType, meshingParameters: Geometry.MeshingParameters) -> System.Array[MeshInterference]: ...\n\n# endregion\n",
  "language": "python",
  "imports": [
    "Rhino",
    "RhinoCommon"
  ],
  "has_docstring": true
}