{
  "source_url": "https://discourse.mcneel.com/t/i-asked-chatgpt-to-filter-sub-surfaces/210829",
  "topic_id": 210829,
  "title": "I asked ChatGPT to filter Sub-Surfaces",
  "question": "Do you know that in Rhino you can apply materials to Sub-Surfaces?\n\nFor this purpose and a few others I made this Sub-Surface filter.\n\nIt takes Polysurfaces and selects Sub-Surfaces:\n\n\n\n\nPlanar and parallel to CPlane\n\n\nNon parallel to CPlane\n\n\nCeilings\n\n\nFloors\n\n\nNon parallel and planar\n\n\nNon parallel and non planar\n\n\nPlanar and perpendicular to CPlane\n\n\nPlanar and not perpendicular to CPlane\n\n\n\n\n\n\n\n\nI started by asking ChatGPT to create a definition that selects subsurfaces and then i asked it to add more definitions one by one for the filters I needed. This way I could debug them one by one.\n\n\n# -*- coding: utf-8 -*-\n# Sort & Select SubSurfaces (Brep Faces) of Polysurfaces relative to current CPlane\n# 1) is_planar_and_parallel_to_CplaneXY\n# 2) SubSrf_selection\n# 3) Command_Line_Choice\n# + Copy_Lists_Of_planar_and_parallel\n# + Floor_or_Ceiling (Ceilings_lists / Floors_lists)\n# + auto-convert selected Extrusions → Breps (polysurfaces)\n# + NEW: Copy & filter non_parallel into four buckets:\n#        - Planar_Surfaces\n#        - NonPlanar_Surfaces\n#        - Planar_Perpendicular_to_CPlane\n#        - Planar_Not_Perpendicular_to_CPlane\n\n# Alias SF\n#-RunPythonScript (c:\\RhinoPythonScripts\\SortFaces.py)\n# Sort faces 251010\n\nimport Rhino\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport math\nfrom System import Guid\n\n# -------------------------------------------------\n# Core\n# -------------------------------------------------\ndef is_planar_and_parallel_to_CplaneXY(brep, abs_tol=None, ang_tol_deg=None):\n    if brep is None:\n        return [], []\n    if abs_tol is None:\n        abs_tol = sc.doc.ModelAbsoluteTolerance\n    if ang_tol_deg is None:\n        ang_tol_deg = sc.doc.ModelAngleToleranceDegrees\n\n    view = sc.doc.Views.ActiveView\n    if view is None:\n        return [], list(range(brep.Faces.Count))\n    zaxis = view.ActiveViewport.ConstructionPlane().ZAxis\n    ang_tol_rad = math.radians(ang_tol_deg)\n\n    planar_and_parallel, non_parallel = [], []\n    for fi,...",
  "code_blocks": [
    {
      "code": "# -*- coding: utf-8 -*-\n# Sort & Select SubSurfaces (Brep Faces) of Polysurfaces relative to current CPlane\n# 1) is_planar_and_parallel_to_CplaneXY\n# 2) SubSrf_selection\n# 3) Command_Line_Choice\n# + Copy_Lists_Of_planar_and_parallel\n# + Floor_or_Ceiling (Ceilings_lists / Floors_lists)\n# + auto-convert selected Extrusions → Breps (polysurfaces)\n# + NEW: Copy & filter non_parallel into four buckets:\n#        - Planar_Surfaces\n#        - NonPlanar_Surfaces\n#        - Planar_Perpendicular_to_CPlane\n#        - Planar_Not_Perpendicular_to_CPlane\n\n# Alias SF\n#-RunPythonScript (c:\\RhinoPythonScripts\\SortFaces.py)\n# Sort faces 251010\n\nimport Rhino\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport math\nfrom System import Guid\n\n# -------------------------------------------------\n# Core\n# -------------------------------------------------\ndef is_planar_and_parallel_to_CplaneXY(brep, abs_tol=None, ang_tol_deg=None):\n    if brep is None:\n        return [], []\n    if abs_tol is None:\n        abs_tol = sc.doc.ModelAbsoluteTolerance\n    if ang_tol_deg is None:\n        ang_tol_deg = sc.doc.ModelAngleToleranceDegrees\n\n    view = sc.doc.Views.ActiveView\n    if view is None:\n        return [], list(range(brep.Faces.Count))\n    zaxis = view.ActiveViewport.ConstructionPlane().ZAxis\n    ang_tol_rad = math.radians(ang_tol_deg)\n\n    planar_and_parallel, non_parallel = [], []\n    for fi, face in enumerate(brep.Faces):\n        if not face.IsPlanar(abs_tol):\n            non_parallel.append(fi)\n            continue\n        ok, pl = face.TryGetPlane(abs_tol)\n        if not ok:\n            non_parallel.append(fi)\n            continue\n        n = pl.Normal\n        ang = Rhino.Geometry.Vector3d.VectorAngle(n, zaxis)\n        if (ang <= ang_tol_rad) or (abs(ang - math.pi) <= ang_tol_rad):\n            planar_and_parallel.append(fi)\n        else:\n            non_parallel.append(fi)\n    return planar_and_parallel, non_parallel\n\n\ndef SubSrf_selection(obj_id, face_indices):\n    if not obj_id or not isinstance(obj_id, Guid):\n        return 0\n    rh_obj = sc.doc.Objects.Find(obj_id)\n    if rh_obj is None:\n        return 0\n\n    sel_count = 0\n    for fi in face_indices:\n        ci = Rhino.Geometry.ComponentIndex(Rhino.Geometry.ComponentIndexType.BrepFace, int(fi))\n        ok = False\n        try:\n            ok = rh_obj.SelectSubObject(ci, True, True, True, False)\n        except:\n            try:\n                # fallback with one more True as requested earlier\n                ok = rh_obj.SelectSubObject(ci, True, True, True)\n            except:\n                ok = False\n        if ok:\n            sel_count += 1\n    return sel_count\n\n\ndef build_index_maps(obj_ids, abs_tol=None, ang_tol_deg=None):\n    maps = {}\n    for oid in obj_ids:\n        rh_obj = sc.doc.Objects.Find(oid)\n        if rh_obj is None:\n            continue\n        brep = rh_obj.Geometry\n        if not isinstance(brep, Rhino.Geometry.Brep):\n            continue\n        p_and_p, non_p = is_planar_and_parallel_to_CplaneXY(brep, abs_tol, ang_tol_deg)\n        maps[oid] = {\"planar_and_parallel\": p_and_p, \"non_parallel\": non_p}\n    return maps\n\n\ndef preview_choice(obj_ids, maps, choice_key):\n    sc.doc.Objects.UnselectAll()\n    total = 0\n    for oid in obj_ids:\n        idxs = maps.get(oid, {}).get(choice_key, [])\n        if idxs:\n            total += SubSrf_selection(oid, idxs)\n    sc.doc.Views.Redraw()\n    return total\n\n# -------------------------------------------------\n# Copy + Floor/Ceiling classification\n# -------------------------------------------------\ndef Copy_Lists_Of_planar_and_parallel(maps):\n    copy_map = {}\n    for oid, d in maps.items():\n        copy_map[oid] = list(d.get(\"planar_and_parallel\", []))\n    return copy_map\n\n\ndef _bbox_union_for_faces(brep, face_indices, plane):\n    bbox = None\n    for fi in face_indices:\n        face = brep.Faces[int(fi)]\n        fb = face.GetBoundingBox(plane)\n        bbox = fb if bbox is None else Rhino.Geometry.BoundingBox.Union(bbox, fb)\n    return bbox\n\n\ndef _face_centroid_world(brep_face):\n    try:\n        dup = brep_face.DuplicateFace(True)\n        amp = Rhino.Geometry.AreaMassProperties.Compute(dup)\n        if amp:\n            return amp.Centroid\n    except:\n        pass\n    return brep_face.GetBoundingBox(True).Center\n\n\ndef Floor_or_Ceiling(planar_and_parallel_copy):\n    ceilings_map = {}\n    floors_map = {}\n\n    view = sc.doc.Views.ActiveView\n    if view is None:\n        return ceilings_map, floors_map\n    base_cplane = view.ActiveViewport.ConstructionPlane()\n\n    tol = sc.doc.ModelAbsoluteTolerance\n\n    for oid, face_list in planar_and_parallel_copy.items():\n        if not face_list:\n            continue\n\n        rh_obj = sc.doc.Objects.Find(oid)\n        if rh_obj is None:\n            continue\n        brep = rh_obj.Geometry\n        if not isinstance(brep, Rhino.Geometry.Brep):\n            continue\n\n        bbox = _bbox_union_for_faces(brep, face_list, base_cplane)\n        if bbox is None or not bbox.IsValid:\n            continue\n\n        centroid = bbox.Center\n        plane_at_ctr = Rhino.Geometry.Plane(base_cplane)\n        plane_at_ctr.Origin = centroid\n\n        above, below = [], []\n        for fi in face_list:\n            face = brep.Faces[int(fi)]\n            c = _face_centroid_world(face)\n            v = c - plane_at_ctr.Origin\n            dot = Rhino.Geometry.Vector3d.Multiply(v, plane_at_ctr.ZAxis)\n            if dot > tol:\n                above.append(int(fi))\n            else:\n                below.append(int(fi))\n\n        if above:\n            ceilings_map[oid] = above\n        if below:\n            floors_map[oid] = below\n\n    return ceilings_map, floors_map\n\n\ndef _preview_simple_map(simple_map):\n    sc.doc.Objects.UnselectAll()\n    total = 0\n    for oid, idxs in simple_map.items():\n        if idxs:\n            total += SubSrf_selection(oid, idxs)\n    sc.doc.Views.Redraw()\n    return total\n\n# -------------------------------------------------\n# NEW: Copy & filter non_parallel into 4 buckets\n# -------------------------------------------------\ndef Copy_Lists_Of_non_parallel(maps):\n    \"\"\"\n    Returns a copy of non_parallel indices per object.\n    { obj_id: [face_idx, ...], ... }\n    \"\"\"\n    out = {}\n    for oid, d in maps.items():\n        out[oid] = list(d.get(\"non_parallel\", []))\n    return out\n\n\ndef Filter_NonParallel_Subsets(non_parallel_copy):\n    \"\"\"\n    Split the copied non_parallel faces into:\n      - Planar_Surfaces\n      - NonPlanar_Surfaces\n      - Planar_Perpendicular_to_CPlane       (angle ~ 90° to CPlane Z)\n      - Planar_Not_Perpendicular_to_CPlane   (planar, but not ⟂ and not ∥)\n    Returns four dicts keyed by object id.\n    \"\"\"\n    view = sc.doc.Views.ActiveView\n    if view is None:\n        return {}, {}, {}, {}\n    zaxis = view.ActiveViewport.ConstructionPlane().ZAxis\n\n    abs_tol = sc.doc.ModelAbsoluteTolerance\n    ang_tol_rad = math.radians(sc.doc.ModelAngleToleranceDegrees)\n\n    planar_map = {}\n    nonplanar_map = {}\n    perp_map = {}\n    not_perp_map = {}\n\n    for oid, face_list in non_parallel_copy.items():\n        if not face_list:\n            continue\n        rh_obj = sc.doc.Objects.Find(oid)\n        if rh_obj is None:\n            continue\n        brep = rh_obj.Geometry\n        if not isinstance(brep, Rhino.Geometry.Brep):\n            continue\n\n        planar_idxs = []\n        nonplanar_idxs = []\n        perp_idxs = []\n        notperp_idxs = []\n\n        for fi in face_list:\n            face = brep.Faces[int(fi)]\n            if face.IsPlanar(abs_tol):\n                planar_idxs.append(int(fi))\n                ok, pl = face.TryGetPlane(abs_tol)\n                if ok and pl:\n                    n = pl.Normal\n                    ang = Rhino.Geometry.Vector3d.VectorAngle(n, zaxis)\n                    # Perpendicular if within tolerance of 90 degrees\n                    if abs(ang - (math.pi * 0.5)) <= ang_tol_rad:\n                        perp_idxs.append(int(fi))\n                    else:\n                        # These are planar but neither perpendicular nor parallel (since we started from non_parallel)\n                        notperp_idxs.append(int(fi))\n                else:\n                    # If we can't get a plane robustly, treat as planar-not-perp (still planar but unknown angle)\n                    notperp_idxs.append(int(fi))\n            else:\n                nonplanar_idxs.append(int(fi))\n\n        if planar_idxs:\n            planar_map[oid] = planar_idxs\n        if nonplanar_idxs:\n            nonplanar_map[oid] = nonplanar_idxs\n        if perp_idxs:\n            perp_map[oid] = perp_idxs\n        if notperp_idxs:\n            not_perp_map[oid] = notperp_idxs\n\n    return planar_map, nonplanar_map, perp_map, not_perp_map\n\n# -------------------------------------------------\n# Extrusion → Brep converter\n# -------------------------------------------------\ndef _ensure_polysurfaces(obj_ids):\n    out_ids = []\n    for oid in obj_ids:\n        rh_obj = sc.doc.Objects.Find(oid)\n        if rh_obj is None:\n            continue\n        geom = rh_obj.Geometry\n\n        if isinstance(geom, Rhino.Geometry.Extrusion):\n            brep = geom.ToBrep(True)\n            if brep:\n                if sc.doc.Objects.Replace(oid, brep):\n                    out_ids.append(oid)\n                else:\n                    nid = sc.doc.Objects.AddBrep(brep, rh_obj.Attributes)\n                    if nid:\n                        sc.doc.Objects.Delete(oid, True)\n                        out_ids.append(nid)\n                    else:\n                        out_ids.append(oid)\n            else:\n                out_ids.append(oid)\n        else:\n            out_ids.append(oid)\n\n    sc.doc.Views.Redraw()\n    return out_ids\n\n# -------------------------------------------------\n# UI\n# -------------------------------------------------\ndef Command_Line_Choice():\n    filt = rs.filter.polysurface | rs.filter.extrusion\n    # preselect = True (as you requested earlier)\n    obj_ids = rs.GetObjects(\"Select polysurfaces (extrusions allowed)\", filt, preselect=True, select=False)\n    if not obj_ids:\n        return\n\n    obj_ids = _ensure_polysurfaces(obj_ids)\n\n    maps = build_index_maps(obj_ids)\n    current_choice = \"planar_and_parallel\"\n    preview_choice(obj_ids, maps, current_choice)\n\n    # caches for existing features\n    planar_copy_cache = None\n    ceilings_cache = None\n    floors_cache = None\n    # caches for the new non-parallel subsets\n    nonpar_copy_cache = None\n    planar_map_cache = None\n    nonplanar_map_cache = None\n    perp_map_cache = None\n    notperp_map_cache = None\n\n    go = Rhino.Input.Custom.GetOption()\n    go.SetCommandPrompt(\"Choose SubSurface group. Press Enter to accept.\")\n    opt_planar  = go.AddOption(\"planar_and_parallel\")\n    opt_nonpar  = go.AddOption(\"non_parallel\")\n    opt_ceil    = go.AddOption(\"Ceilings_lists\")\n    opt_floor   = go.AddOption(\"Floors_lists\")\n    # NEW options\n    opt_np_planar     = go.AddOption(\"Planar_Surfaces\")\n    opt_np_nonplanar  = go.AddOption(\"NonPlanar_Surfaces\")\n    opt_np_perp       = go.AddOption(\"Planar_Perpendicular_to_CPlane\")\n    opt_np_notperp    = go.AddOption(\"Planar_Not_Perpendicular_to_CPlane\")\n\n    go.AcceptNothing(True)\n\n    while True:\n        res = go.Get()\n        if res == Rhino.Input.GetResult.Option:\n            idx = go.OptionIndex()\n\n            if idx == opt_planar:\n                current_choice = \"planar_and_parallel\"\n                count = preview_choice(obj_ids, maps, current_choice)\n                Rhino.RhinoApp.WriteLine(\"Preview: {0} faces selected.\".format(count))\n\n            elif idx == opt_nonpar:\n                current_choice = \"non_parallel\"\n                count = preview_choice(obj_ids, maps, current_choice)\n                Rhino.RhinoApp.WriteLine(\"Preview: {0} faces selected.\".format(count))\n\n            elif idx == opt_ceil:\n                current_choice = \"Ceilings_lists\"\n                if planar_copy_cache is None:\n                    planar_copy_cache = Copy_Lists_Of_planar_and_parallel(maps)\n                if ceilings_cache is None or floors_cache is None:\n                    ceilings_cache, floors_cache = Floor_or_Ceiling(planar_copy_cache)\n                count = _preview_simple_map(ceilings_cache if ceilings_cache else {})\n                Rhino.RhinoApp.WriteLine(\"Preview (Ceilings): {0} faces selected.\".format(count))\n\n            elif idx == opt_floor:\n                current_choice = \"Floors_lists\"\n                if planar_copy_cache is None:\n                    planar_copy_cache = Copy_Lists_Of_planar_and_parallel(maps)\n                if ceilings_cache is None or floors_cache is None:\n                    ceilings_cache, floors_cache = Floor_or_Ceiling(planar_copy_cache)\n                count = _preview_simple_map(floors_cache if floors_cache else {})\n                Rhino.RhinoApp.WriteLine(\"Preview (Floors): {0} faces selected.\".format(count))\n\n            # ------ NEW four subsets from non_parallel copy ------\n            elif idx == opt_np_planar:\n                current_choice = \"Planar_Surfaces\"\n                if nonpar_copy_cache is None:\n                    nonpar_copy_cache = Copy_Lists_Of_non_parallel(maps)\n                if planar_map_cache is None:\n                    (planar_map_cache,\n                     nonplanar_map_cache,\n                     perp_map_cache,\n                     notperp_map_cache) = Filter_NonParallel_Subsets(nonpar_copy_cache)\n                count = _preview_simple_map(planar_map_cache or {})\n                Rhino.RhinoApp.WriteLine(\"Preview (Planar from non_parallel): {0} faces selected.\".format(count))\n\n            elif idx == opt_np_nonplanar:\n                current_choice = \"NonPlanar_Surfaces\"\n                if nonpar_copy_cache is None:\n                    nonpar_copy_cache = Copy_Lists_Of_non_parallel(maps)\n                if nonplanar_map_cache is None:\n                    (planar_map_cache,\n                     nonplanar_map_cache,\n                     perp_map_cache,\n                     notperp_map_cache) = Filter_NonParallel_Subsets(nonpar_copy_cache)\n                count = _preview_simple_map(nonplanar_map_cache or {})\n                Rhino.RhinoApp.WriteLine(\"Preview (NonPlanar from non_parallel): {0} faces selected.\".format(count))\n\n            elif idx == opt_np_perp:\n                current_choice = \"Planar_Perpendicular_to_CPlane\"\n                if nonpar_copy_cache is None:\n                    nonpar_copy_cache = Copy_Lists_Of_non_parallel(maps)\n                if perp_map_cache is None:\n                    (planar_map_cache,\n                     nonplanar_map_cache,\n                     perp_map_cache,\n                     notperp_map_cache) = Filter_NonParallel_Subsets(nonpar_copy_cache)\n                count = _preview_simple_map(perp_map_cache or {})\n                Rhino.RhinoApp.WriteLine(\"Preview (Planar ⟂ CPlane): {0} faces selected.\".format(count))\n\n            elif idx == opt_np_notperp:\n                current_choice = \"Planar_Not_Perpendicular_to_CPlane\"\n                if nonpar_copy_cache is None:\n                    nonpar_copy_cache = Copy_Lists_Of_non_parallel(maps)\n                if notperp_map_cache is None:\n                    (planar_map_cache,\n                     nonplanar_map_cache,\n                     perp_map_cache,\n                     notperp_map_cache) = Filter_NonParallel_Subsets(nonpar_copy_cache)\n                count = _preview_simple_map(notperp_map_cache or {})\n                Rhino.RhinoApp.WriteLine(\"Preview (Planar not ⟂ CPlane): {0} faces selected.\".format(count))\n\n            continue\n\n        elif res == Rhino.Input.GetResult.Nothing:\n            sc.doc.Objects.UnselectAll()\n            total = 0\n\n            if current_choice in (\"planar_and_parallel\", \"non_parallel\"):\n                for oid in obj_ids:\n                    idxs = maps.get(oid, {}).get(current_choice, [])\n                    if idxs:\n                        total += SubSrf_selection(oid, idxs)\n\n            elif current_choice == \"Ceilings_lists\":\n                if planar_copy_cache is None:\n                    planar_copy_cache = Copy_Lists_Of_planar_and_parallel(maps)\n                if ceilings_cache is None:\n                    ceilings_cache, floors_cache = Floor_or_Ceiling(planar_copy_cache)\n                for oid, idxs in (ceilings_cache or {}).items():\n                    if idxs:\n                        total += SubSrf_selection(oid, idxs)\n\n            elif current_choice == \"Floors_lists\":\n                if planar_copy_cache is None:\n                    planar_copy_cache = Copy_Lists_Of_planar_and_parallel(maps)\n                if floors_cache is None:\n                    ceilings_cache, floors_cache = Floor_or_Ceiling(planar_copy_cache)\n                for oid, idxs in (floors_cache or {}).items():\n                    if idxs:\n                        total += SubSrf_selection(oid, idxs)\n\n            elif current_choice in (\"Planar_Surfaces\",\n                                    \"NonPlanar_Surfaces\",\n                                    \"Planar_Perpendicular_to_CPlane\",\n                                    \"Planar_Not_Perpendicular_to_CPlane\"):\n                if nonpar_copy_cache is None:\n                    nonpar_copy_cache = Copy_Lists_Of_non_parallel(maps)\n                if any(m is None for m in (planar_map_cache, nonplanar_map_cache, perp_map_cache, notperp_map_cache)):\n                    (planar_map_cache,\n                     nonplanar_map_cache,\n                     perp_map_cache,\n                     notperp_map_cache) = Filter_NonParallel_Subsets(nonpar_copy_cache)\n\n                sel_map = {}\n                if current_choice == \"Planar_Surfaces\":\n                    sel_map = planar_map_cache or {}\n                elif current_choice == \"NonPlanar_Surfaces\":\n                    sel_map = nonplanar_map_cache or {}\n                elif current_choice == \"Planar_Perpendicular_to_CPlane\":\n                    sel_map = perp_map_cache or {}\n                elif current_choice == \"Planar_Not_Perpendicular_to_CPlane\":\n                    sel_map = notperp_map_cache or {}\n\n                for oid, idxs in sel_map.items():\n                    if idxs:\n                        total += SubSrf_selection(oid, idxs)\n\n            sc.doc.Views.Redraw()\n            Rhino.RhinoApp.WriteLine(\"Selection validated for: {0} (faces: {1})\".format(current_choice, total))\n            break\n\n        elif res == Rhino.Input.GetResult.Cancel:\n            sc.doc.Objects.UnselectAll()\n            sc.doc.Views.Redraw()\n            Rhino.RhinoApp.WriteLine(\"Canceled.\")\n            return\n\n    sc.doc.Views.Redraw()\n\n\nif __name__ == \"__main__\":\n    Command_Line_Choice()",
      "language": "python",
      "author": "Bogdan_Chipara",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "materials",
    "python",
    "rhinocommon",
    "rhinoscriptsyntax",
    "selection"
  ],
  "has_accepted_answer": false,
  "category_id": 11,
  "posts_count": 3,
  "views": 138
}