{
  "source_url": "https://github.com/JaumeMonclus/Rhino-Grasshopper-Scripts/blob/ca6be60d1f0266c805ce4d76dfc277bd05070c87/AT-AP-Sessions/Session-1/MPDA25-Assignment1/A01_Jaume_Moncl%C3%BAs.py",
  "repo": "JaumeMonclus/Rhino-Grasshopper-Scripts",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "AT-AP-Sessions/Session-1/MPDA25-Assignment1/A01_Jaume_Monclús.py",
  "instruction": "A01 jaume monclús",
  "code": "import Rhino.Geometry as rg\nimport ghpythonlib.treehelpers as th\nimport math\nimport Rhino\n\n### Lists to Return ###\n\na_point_list = []\nb_point_list = []\nlines = []\ndivided_points = []\nmoved_divided_points = []\nz_values = []\nvectors = []\nsinusoidal_points = []\ninterpolated_curves = []\ninterpolated_curves_v = []\nuv_params = []\nevaluated_points = []\nmesh_faces = []\n\n# Initial Points\n\nfor p in range(x):\n\n    a = rg.Point3d(p, 0, 0)\n    a_point_list.append(a)\n\n    b = rg.Point3d(p, y, 0)\n    b_point_list.append(b)\n\n# Creation of the lines\n\nfor i in range(len(a_point_list)):\n\n    line = rg.LineCurve(a_point_list[i], b_point_list[i])\n    lines.append(line)\n\n# Ara el que fem és dividir les corves\n\nfor j in range(len(lines)):\n\n    params = lines[j].DivideByCount(10, True)\n    \n    point1 = [lines[j].PointAt(t) for t in params]\n    divided_points.append(point1)\n\n# Extraction of the vector and translation\n\nfor rows in divided_points: \n\n    # The first line covers the amplitude of the vector\n    vector_sine = [math.sin(rg.Vector3d(single_point.X, single_point.Y, single_point.Z).Length) for single_point in rows]\n\n    # The second line assigns said amplitude to the z comp of a new vector\n    moving_vector = [rg.Vector3d(0, 0, m) for m in vector_sine]\n\n    vectors.append(moving_vector)\n\n# Creation of the Points   \n\nnum_u = len(divided_points) \nnum_v = max(len(row) for row in divided_points)  \n\nfor u_coor in range(num_u):\n\n    for v_coor in range(num_v):\n\n        # Iterating through a nested loop to assign to each point its respective vector\n        divided_points[u_coor][v_coor] += vectors[u_coor][v_coor]\n\n    # We extract ourselves of the first loop to iterate through the rows in order to interpolate and create a NURBS from interpolation.\n    interpolated_curve = rg.Curve.CreateInterpolatedCurve(divided_points[u_coor], 3)\n    interpolated_curves.append(interpolated_curve)\n\nsinusoidal_points.extend(divided_points)\n\n# Finally we create a loft from the list of curves \n\nloft = rg.Brep.CreateFromLoft(interpolated_curves, rg.Point3d.Unset, rg.Point3d.Unset, rg.LoftType.Uniform, False)\n\n# Mesh from Loft ( resulting Mesh will be one Row and Column Larger than the grasshopper definition, Solution Covered After! )\n\nmesh_from_brep = rg.Mesh()\n\n# Es necessari entrar els punts a la malla abans de passar els seus index\n\nfor rows in divided_points:\n    for pt in rows:\n        mesh_from_brep.Vertices.Add(pt)\n\n# Declare each face index\n\nfor u in range(num_u - 1):\n\n    for v in range(num_v - 1):\n        \n        idx0 = u * num_v + v\n        idx1 = u * num_v + v + 1\n        idx2 = (u + 1) * num_v + v + 1  \n        idx3 = (u + 1) * num_v + v\n\n        f = rg.MeshFace(idx0, idx1, idx2, idx3)\n        mesh_from_brep.Faces.AddFace(f)\n\n\n#-----------------------------------------------------------------------------------------------#\n# Alternative, Create a Surface from points so we can regulate the amount of U & V Subdivisions\n#-----------------------------------------------------------------------------------------------#\n\n\n#Flattening the point structure\n\npoints_flat = []\n\nfor f_row in divided_points:\n    for f_pt in f_row:\n        points_flat.append(f_pt)\n\nnrbs_srf = rg.NurbsSurface.CreateThroughPoints(points_flat, num_u, num_v, 3, 3, False, False)\n\n#Extracting the domain of the surface \n\nU_dom = nrbs_srf.Domain(0)\nV_dom = nrbs_srf.Domain(1)\n\n# Creating 2 lists of values for U & V \n\nvalues_u = [U_dom.T0 + (idu * U_dom.Length)/(Uu-1)  for idu in range(Uu)]\nvalues_v = [V_dom.T0 + (idv *V_dom.Length)/(Vv-1) for idv in range (Vv)]\n\n# rebuilding the initial Point structure so that we have rows and columns\n\nfor paramu in values_u:\n    row_params = []\n    for paramv in values_v:\n        row_params.append([paramu, paramv])\n    uv_params.append(row_params)\n\n# Evaluating the surface at each [u,v] so we can extract a point in the same data structure\n\nfor row in uv_params:\n    row_points = []\n\n    for i_uv_params in row:\n        evaluated_point = nrbs_srf.PointAt(i_uv_params[0],i_uv_params[1])\n\n        row_points.append(evaluated_point)\n\n    evaluated_points.append(row_points)\n\n# Final Step, creating a quad mesh\n\nmesh_from_nurbs_surface = rg.Mesh()\n\n# Es necessari entrar els punts a la malla abans de passar els seus index\n\nfor rows in evaluated_points:\n    for pt in rows:\n        mesh_from_nurbs_surface.Vertices.Add(pt)\n\n# Declare each face index\n\nfor u in range(Uu - 1):\n\n    for v in range(Vv - 1):\n        \n        idx0 = u * Vv + v\n        idx1 = u * Vv + v + 1\n        idx2 = (u + 1) * Vv + v + 1  \n        idx3 = (u + 1) * Vv + v\n\n        f = rg.MeshFace(idx0, idx1, idx2, idx3)\n        mesh_from_nurbs_surface.Faces.AddFace(f)\n\n### OUTPUTS ###\n\n# Initial Points\n\nIpa = a_point_list\nIpb = b_point_list\n\n# Lines\n\nL = lines\n\n# Divided Points\n\nDvp = th.list_to_tree(divided_points)\n\n# Vectors\n\nMv = th.list_to_tree(vectors)\n\n# Sinusoidal Points\n\nSp = th.list_to_tree(sinusoidal_points)\n\n# Interpolated Curves\n\nCrvs = interpolated_curves\n\n# Resulting Loft\n\nLft = loft\n\nNrbs_srf = nrbs_srf\n\n# Resulting Mesh from brep\n\nMfb = mesh_from_brep\n\n# Resulting Mesh from surface\n\nMfs = mesh_from_nurbs_surface\n\n\na = th.list_to_tree(evaluated_points)\n\n\n\n\n# OTHER\n\n# b = th.list_to_tree(sinusoidal_moved_divided_points)\n# a = th.list_to_tree(interpolated_curves)\n\n# for crv in range(len(interpolated_curves)):\n#     loft = rg.Brep.CreateFromLoft(list(interpolated_curves), rg.LoftType.Normal, False)\n#     a = th.list_to_tree(divided_points)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}