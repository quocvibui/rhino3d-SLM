{
  "source_url": "https://github.com/Ornakala-T1/text-depth-point-to-cloud-3d-cad/blob/7ed52890bedd6e3928324046ddbf5d66dfcecabb/modules/exporter.py",
  "repo": "Ornakala-T1/text-depth-point-to-cloud-3d-cad",
  "repo_stars": 1,
  "repo_description": "A pipeline to create a 3d cad file from text to image to depth analysis, point to cloud to 3d",
  "license": "unknown",
  "filepath": "modules/exporter.py",
  "instruction": "Mesh Export Module\n===================\nExports meshes to various manufacturing-ready formats.",
  "code": "\"\"\"\nMesh Export Module\n===================\nExports meshes to various manufacturing-ready formats.\n\nSupported formats:\n- STL (Standard Triangle Language) - Universal 3D printing format\n- OBJ (Wavefront) - Common interchange format\n- PLY (Polygon File Format) - Point cloud and mesh format\n- STEP (Standard for Exchange of Product Data) - CAD interchange format\n- 3DM (Rhino) - Rhino/Grasshopper native format\n\"\"\"\n\nimport numpy as np\nfrom pathlib import Path\nimport struct\n\ntry:\n    import open3d as o3d\n    OPEN3D_AVAILABLE = True\nexcept ImportError:\n    OPEN3D_AVAILABLE = False\n\ntry:\n    import point_cloud_utils as pcu\n    PCU_AVAILABLE = True\nexcept ImportError:\n    PCU_AVAILABLE = False\n\ntry:\n    import trimesh\n    TRIMESH_AVAILABLE = True\nexcept ImportError:\n    TRIMESH_AVAILABLE = False\n\n\nclass MeshExporter:\n    \"\"\"\n    Exports meshes to various manufacturing formats.\n    Supports STL, OBJ, PLY, and optionally STEP and 3DM.\n    \"\"\"\n    \n    SUPPORTED_FORMATS = [\"stl\", \"obj\", \"ply\", \"off\", \"gltf\", \"glb\"]\n    CAD_FORMATS = [\"step\", \"stp\", \"iges\", \"igs\", \"3dm\"]\n    \n    def __init__(self, config):\n        \"\"\"\n        Initialize the exporter.\n        \n        Args:\n            config: PipelineConfig object with settings\n        \"\"\"\n        self.config = config\n        \n    def export(\n        self,\n        meshes: dict,\n        output_dir: str | Path,\n        formats: list[str] = None\n    ) -> dict:\n        \"\"\"\n        Export all meshes to specified formats.\n        \n        Args:\n            meshes: Dictionary of mesh data from mesh reconstruction\n            output_dir: Directory to save exported files\n            formats: List of formats to export to\n            \n        Returns:\n            Dictionary of exported file paths per mesh and format\n        \"\"\"\n        output_dir = Path(output_dir)\n        output_dir.mkdir(parents=True, exist_ok=True)\n        \n        if formats is None:\n            formats = [\"stl\", \"obj\", \"ply\"]\n        \n        exports = {}\n        \n        for name, mesh_data in meshes.items():\n            print(f\"  Exporting {name}...\")\n            exports[name] = {}\n            \n            mesh_path = mesh_data.get(\"path\")\n            mesh_obj = mesh_data.get(\"mesh\")\n            \n            if mesh_obj is None and mesh_path:\n                mesh_obj = self._load_mesh(mesh_path)\n            \n            if mesh_obj is None:\n                print(f\"    Could not load mesh for {name}\")\n                continue\n            \n            for fmt in formats:\n                try:\n                    export_path = output_dir / f\"{name}.{fmt}\"\n                    \n                    if fmt in self.SUPPORTED_FORMATS:\n                        self._export_standard(mesh_obj, export_path, fmt)\n                    elif fmt in self.CAD_FORMATS:\n                        self._export_cad(mesh_obj, export_path, fmt)\n                    else:\n                        print(f\"    Unsupported format: {fmt}\")\n                        continue\n                    \n                    exports[name][fmt] = str(export_path)\n                    print(f\"    Exported: {export_path.name}\")\n                    \n                except Exception as e:\n                    print(f\"    Error exporting {name} to {fmt}: {e}\")\n        \n        # Also export combined mesh (all components merged)\n        if len(meshes) > 1:\n            combined_path = self._export_combined(meshes, output_dir, formats)\n            exports[\"combined\"] = combined_path\n        \n        return exports\n    \n    def _load_mesh(self, path: str | Path):\n        \"\"\"Load mesh from file.\"\"\"\n        path = Path(path)\n        \n        if OPEN3D_AVAILABLE:\n            return o3d.io.read_triangle_mesh(str(path))\n        elif TRIMESH_AVAILABLE:\n            return trimesh.load(str(path))\n        elif PCU_AVAILABLE:\n            v, f = pcu.load_mesh_vf(str(path))\n            return {\"vertices\": v, \"faces\": f}\n        else:\n            return None\n    \n    def _export_standard(\n        self,\n        mesh,\n        output_path: Path,\n        fmt: str\n    ):\n        \"\"\"Export to standard 3D formats.\"\"\"\n        if OPEN3D_AVAILABLE and isinstance(mesh, o3d.geometry.TriangleMesh):\n            o3d.io.write_triangle_mesh(str(output_path), mesh)\n            \n        elif TRIMESH_AVAILABLE and isinstance(mesh, trimesh.Trimesh):\n            mesh.export(str(output_path), file_type=fmt)\n            \n        elif isinstance(mesh, dict):\n            # Raw vertices and faces\n            vertices = mesh[\"vertices\"]\n            faces = mesh[\"faces\"]\n            \n            if fmt == \"stl\":\n                self._write_stl(output_path, vertices, faces)\n            elif fmt == \"obj\":\n                self._write_obj(output_path, vertices, faces)\n            elif fmt == \"ply\":\n                self._write_ply(output_path, vertices, faces)\n            else:\n                raise ValueError(f\"Cannot export to {fmt} without proper library\")\n        else:\n            raise ValueError(f\"Unknown mesh type: {type(mesh)}\")\n    \n    def _export_cad(\n        self,\n        mesh,\n        output_path: Path,\n        fmt: str\n    ):\n        \"\"\"Export to CAD formats (requires additional libraries).\"\"\"\n        if fmt in [\"step\", \"stp\"]:\n            self._export_step(mesh, output_path)\n        elif fmt in [\"iges\", \"igs\"]:\n            self._export_iges(mesh, output_path)\n        elif fmt == \"3dm\":\n            self._export_3dm(mesh, output_path)\n        else:\n            raise ValueError(f\"Unsupported CAD format: {fmt}\")\n    \n    def _export_step(self, mesh, output_path: Path):\n        \"\"\"\n        Export to STEP format.\n        Requires pythonocc-core or FreeCAD.\n        \"\"\"\n        try:\n            from OCC.Core.STEPControl import STEPControl_Writer, STEPControl_AsIs\n            from OCC.Core.BRepBuilderAPI import BRepBuilderAPI_MakePolygon\n            from OCC.Core.TopoDS import TopoDS_Face\n            \n            # This is a simplified example - proper STEP export is complex\n            print(\"    Note: STEP export requires OpenCASCADE for proper CAD geometry\")\n            print(\"    Saving as STL instead (can be converted externally)\")\n            \n            stl_path = output_path.with_suffix('.stl')\n            self._export_standard(mesh, stl_path, 'stl')\n            \n        except ImportError:\n            print(\"    STEP export requires pythonocc-core library\")\n            print(\"    Install with: conda install -c conda-forge pythonocc-core\")\n            print(\"    Saving as STL instead\")\n            \n            stl_path = output_path.with_suffix('.stl')\n            self._export_standard(mesh, stl_path, 'stl')\n    \n    def _export_iges(self, mesh, output_path: Path):\n        \"\"\"Export to IGES format.\"\"\"\n        try:\n            from OCC.Core.IGESControl import IGESControl_Writer\n            \n            print(\"    IGES export requires OpenCASCADE\")\n            stl_path = output_path.with_suffix('.stl')\n            self._export_standard(mesh, stl_path, 'stl')\n            \n        except ImportError:\n            print(\"    IGES export requires pythonocc-core library\")\n            stl_path = output_path.with_suffix('.stl')\n            self._export_standard(mesh, stl_path, 'stl')\n    \n    def _export_3dm(self, mesh, output_path: Path):\n        \"\"\"\n        Export to Rhino 3DM format.\n        Requires rhino3dm library.\n        \"\"\"\n        try:\n            import rhino3dm\n            \n            # Create a new Rhino file\n            model = rhino3dm.File3dm()\n            \n            # Get vertices and faces\n            if OPEN3D_AVAILABLE and isinstance(mesh, o3d.geometry.TriangleMesh):\n                vertices = np.asarray(mesh.vertices)\n                faces = np.asarray(mesh.triangles)\n            elif isinstance(mesh, dict):\n                vertices = mesh[\"vertices\"]\n                faces = mesh[\"faces\"]\n            else:\n                raise ValueError(\"Cannot extract mesh data\")\n            \n            # Create Rhino mesh\n            rhino_mesh = rhino3dm.Mesh()\n            \n            for v in vertices:\n                rhino_mesh.Vertices.Add(float(v[0]), float(v[1]), float(v[2]))\n            \n            for f in faces:\n                rhino_mesh.Faces.AddFace(int(f[0]), int(f[1]), int(f[2]))\n            \n            rhino_mesh.Normals.ComputeNormals()\n            rhino_mesh.Compact()\n            \n            # Add to model\n            model.Objects.AddMesh(rhino_mesh)\n            \n            # Save\n            model.Write(str(output_path), version=7)\n            print(f\"    Exported to 3DM: {output_path}\")\n            \n        except ImportError:\n            print(\"    3DM export requires rhino3dm library\")\n            print(\"    Install with: pip install rhino3dm\")\n            stl_path = output_path.with_suffix('.stl')\n            self._export_standard(mesh, stl_path, 'stl')\n    \n    def _write_stl(\n        self,\n        path: Path,\n        vertices: np.ndarray,\n        faces: np.ndarray,\n        binary: bool = True\n    ):\n        \"\"\"Write mesh to STL format.\"\"\"\n        if binary:\n            self._write_stl_binary(path, vertices, faces)\n        else:\n            self._write_stl_ascii(path, vertices, faces)\n    \n    def _write_stl_binary(\n        self,\n        path: Path,\n        vertices: np.ndarray,\n        faces: np.ndarray\n    ):\n        \"\"\"Write binary STL file.\"\"\"\n        with open(path, 'wb') as f:\n            # Header (80 bytes)\n            header = b'Binary STL exported from Ring3D Pipeline' + b'\\0' * 40\n            f.write(header[:80])\n            \n            # Number of triangles\n            f.write(struct.pack('<I', len(faces)))\n            \n            # Write each triangle\n            for face in faces:\n                v0 = vertices[face[0]]\n                v1 = vertices[face[1]]\n                v2 = vertices[face[2]]\n                \n                # Calculate normal\n                edge1 = v1 - v0\n                edge2 = v2 - v0\n                normal = np.cross(edge1, edge2)\n                norm = np.linalg.norm(normal)\n                if norm > 0:\n                    normal = normal / norm\n                else:\n                    normal = np.array([0, 0, 1])\n                \n                # Normal vector\n                f.write(struct.pack('<fff', *normal))\n                \n                # Three vertices\n                f.write(struct.pack('<fff', *v0))\n                f.write(struct.pack('<fff', *v1))\n                f.write(struct.pack('<fff', *v2))\n                \n                # Attribute byte count\n                f.write(struct.pack('<H', 0))\n    \n    def _write_stl_ascii(\n        self,\n        path: Path,\n        vertices: np.ndarray,\n        faces: np.ndarray\n    ):\n        \"\"\"Write ASCII STL file.\"\"\"\n        with open(path, 'w') as f:\n            f.write(\"solid ring_mesh\\n\")\n            \n            for face in faces:\n                v0 = vertices[face[0]]\n                v1 = vertices[face[1]]\n                v2 = vertices[face[2]]\n                \n                # Calculate normal\n                edge1 = v1 - v0\n                edge2 = v2 - v0\n                normal = np.cross(edge1, edge2)\n                norm = np.linalg.norm(normal)\n                if norm > 0:\n                    normal = normal / norm\n                else:\n                    normal = np.array([0, 0, 1])\n                \n                f.write(f\"  facet normal {normal[0]:.6f} {normal[1]:.6f} {normal[2]:.6f}\\n\")\n                f.write(\"    outer loop\\n\")\n                f.write(f\"      vertex {v0[0]:.6f} {v0[1]:.6f} {v0[2]:.6f}\\n\")\n                f.write(f\"      vertex {v1[0]:.6f} {v1[1]:.6f} {v1[2]:.6f}\\n\")\n                f.write(f\"      vertex {v2[0]:.6f} {v2[1]:.6f} {v2[2]:.6f}\\n\")\n                f.write(\"    endloop\\n\")\n                f.write(\"  endfacet\\n\")\n            \n            f.write(\"endsolid ring_mesh\\n\")\n    \n    def _write_obj(\n        self,\n        path: Path,\n        vertices: np.ndarray,\n        faces: np.ndarray\n    ):\n        \"\"\"Write mesh to OBJ format.\"\"\"\n        with open(path, 'w') as f:\n            f.write(\"# Ring3D Pipeline OBJ Export\\n\")\n            f.write(f\"# Vertices: {len(vertices)}\\n\")\n            f.write(f\"# Faces: {len(faces)}\\n\\n\")\n            \n            # Write vertices\n            for v in vertices:\n                f.write(f\"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}\\n\")\n            \n            f.write(\"\\n\")\n            \n            # Write faces (OBJ uses 1-indexed faces)\n            for face in faces:\n                f.write(f\"f {face[0]+1} {face[1]+1} {face[2]+1}\\n\")\n    \n    def _write_ply(\n        self,\n        path: Path,\n        vertices: np.ndarray,\n        faces: np.ndarray\n    ):\n        \"\"\"Write mesh to PLY format.\"\"\"\n        with open(path, 'w') as f:\n            f.write(\"ply\\n\")\n            f.write(\"format ascii 1.0\\n\")\n            f.write(f\"element vertex {len(vertices)}\\n\")\n            f.write(\"property float x\\n\")\n            f.write(\"property float y\\n\")\n            f.write(\"property float z\\n\")\n            f.write(f\"element face {len(faces)}\\n\")\n            f.write(\"property list uchar int vertex_indices\\n\")\n            f.write(\"end_header\\n\")\n            \n            for v in vertices:\n                f.write(f\"{v[0]:.6f} {v[1]:.6f} {v[2]:.6f}\\n\")\n            \n            for face in faces:\n                f.write(f\"3 {face[0]} {face[1]} {face[2]}\\n\")\n    \n    def _export_combined(\n        self,\n        meshes: dict,\n        output_dir: Path,\n        formats: list[str]\n    ) -> dict:\n        \"\"\"Export all meshes combined into a single file.\"\"\"\n        print(\"  Exporting combined mesh...\")\n        \n        combined_exports = {}\n        \n        if OPEN3D_AVAILABLE:\n            combined = o3d.geometry.TriangleMesh()\n            \n            for name, mesh_data in meshes.items():\n                mesh_path = mesh_data.get(\"path\")\n                if mesh_path:\n                    mesh = o3d.io.read_triangle_mesh(mesh_path)\n                    combined += mesh\n            \n            for fmt in formats:\n                if fmt in self.SUPPORTED_FORMATS:\n                    export_path = output_dir / f\"combined_ring.{fmt}\"\n                    o3d.io.write_triangle_mesh(str(export_path), combined)\n                    combined_exports[fmt] = str(export_path)\n                    print(f\"    Combined exported: {export_path.name}\")\n        \n        elif TRIMESH_AVAILABLE:\n            mesh_list = []\n            for name, mesh_data in meshes.items():\n                mesh_path = mesh_data.get(\"path\")\n                if mesh_path:\n                    mesh_list.append(trimesh.load(mesh_path))\n            \n            if mesh_list:\n                combined = trimesh.util.concatenate(mesh_list)\n                for fmt in formats:\n                    export_path = output_dir / f\"combined_ring.{fmt}\"\n                    combined.export(str(export_path))\n                    combined_exports[fmt] = str(export_path)\n        \n        return combined_exports\n\n\nclass ManufacturingValidator:\n    \"\"\"\n    Validates meshes for manufacturing requirements.\n    Checks for common issues that could cause problems in 3D printing or CNC.\n    \"\"\"\n    \n    def validate(self, mesh_path: str | Path) -> dict:\n        \"\"\"\n        Validate a mesh for manufacturing.\n        \n        Args:\n            mesh_path: Path to mesh file\n            \n        Returns:\n            Dictionary of validation results\n        \"\"\"\n        mesh_path = Path(mesh_path)\n        results = {\n            \"path\": str(mesh_path),\n            \"valid\": True,\n            \"issues\": []\n        }\n        \n        if not OPEN3D_AVAILABLE and not TRIMESH_AVAILABLE:\n            results[\"valid\"] = False\n            results[\"issues\"].append(\"Cannot validate without Open3D or trimesh\")\n            return results\n        \n        if TRIMESH_AVAILABLE:\n            mesh = trimesh.load(str(mesh_path))\n            \n            # Check if watertight\n            if not mesh.is_watertight:\n                results[\"issues\"].append(\"Mesh is not watertight\")\n            \n            # Check for inverted normals\n            if mesh.is_empty:\n                results[\"issues\"].append(\"Mesh is empty\")\n                results[\"valid\"] = False\n            \n            # Check volume (should be positive)\n            if mesh.volume < 0:\n                results[\"issues\"].append(\"Mesh has inverted normals (negative volume)\")\n            \n            # Check for self-intersections (expensive check)\n            # This is commented out as it can be slow\n            # if mesh.ray.intersects_any(mesh.triangles_center, mesh.face_normals):\n            #     results[\"issues\"].append(\"Mesh has self-intersections\")\n            \n            # Get statistics\n            results[\"statistics\"] = {\n                \"vertices\": len(mesh.vertices),\n                \"faces\": len(mesh.faces),\n                \"volume\": float(mesh.volume),\n                \"surface_area\": float(mesh.area),\n                \"is_watertight\": mesh.is_watertight,\n                \"euler_number\": int(mesh.euler_number)\n            }\n        \n        elif OPEN3D_AVAILABLE:\n            mesh = o3d.io.read_triangle_mesh(str(mesh_path))\n            \n            # Check if mesh is empty\n            if len(mesh.vertices) == 0:\n                results[\"issues\"].append(\"Mesh is empty\")\n                results[\"valid\"] = False\n            \n            # Check if watertight\n            if not mesh.is_watertight():\n                results[\"issues\"].append(\"Mesh is not watertight\")\n            \n            # Check for self-intersections\n            if not mesh.is_self_intersecting():\n                pass  # Good\n            else:\n                results[\"issues\"].append(\"Mesh has self-intersections\")\n            \n            results[\"statistics\"] = {\n                \"vertices\": len(mesh.vertices),\n                \"faces\": len(mesh.triangles),\n                \"is_watertight\": mesh.is_watertight()\n            }\n        \n        if results[\"issues\"]:\n            results[\"valid\"] = len([i for i in results[\"issues\"] \n                                   if \"watertight\" not in i.lower()]) == 0\n        \n        return results\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}