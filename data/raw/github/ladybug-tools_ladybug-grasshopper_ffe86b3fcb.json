{
  "source_url": "https://github.com/ladybug-tools/ladybug-grasshopper/blob/a10c14adff547d29bb4ee6715984e58ea4adfef9/ladybug_grasshopper/src/LB%20Preview%20VisualizationSet.py",
  "repo": "ladybug-tools/ladybug-grasshopper",
  "repo_stars": 46,
  "repo_description": "üêû :green_book: Ladybug plugin for Grasshopper",
  "license": "AGPL-3.0",
  "filepath": "ladybug_grasshopper/src/LB Preview VisualizationSet.py",
  "instruction": "Preview a VisualizationSet from any component with a vis_set output.\n_\nThe VisualizationSet is often a much more detailed view of the geometry that\nthe component typically generates and includes...",
  "code": "# Ladybug: A Plugin for Environmental Analysis (GPL)\n# This file is part of Ladybug.\n#\n# Copyright (c) 2025, Ladybug Tools.\n# You should have received a copy of the GNU Affero General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license AGPL-3.0-or-later <https://spdx.org/licenses/AGPL-3.0-or-later>\n\n\"\"\"\nPreview a VisualizationSet from any component with a vis_set output.\n_\nThe VisualizationSet is often a much more detailed view of the geometry that\nthe component typically generates and includes features like recommended line\nweights/types, display modes (eg. wireframe vs. shaded), transparency, and more.\n-\n\n    Args:\n        _vis_set: VisualizationSet arguments from any Ladybug Tools component with a vis_set\n            output. This can also be the path to a .vsf file that exists on this\n            machine (these files are often written with the \"LB Dump VisualizationSet\"\n            component). Lastly, this input can be a custom VisualizationSet that\n            has been created with the Ladybug Tools SDK.\n        legend_par_: Optional legend parameters from the \"LB Legend Parameters\" component,\n            which will overwrite the existing legend parameters on the input\n            Visualization Set.\n        leg_par2d_: Optional 2D LegendParameters from the \"LB Legend Parameters 2D\"\n            component, which will be used to customize a legend in the plane\n            of the screen so that it functions like a head-up display (HUD).\n            If unspecified, the VisualizationSet will be rendered with 3D\n            legends in the Rhino scene much like the other native Ladybug\n            Tools components.\n        data_set_: Optional text or an integer to select a specific data set from analysis\n            geometries within the Visualization Set. Note that this input only has\n            meaning for Visualization Sets that contain multiple data sets assigned\n            to the same geometry. When using an integer, this will refer to the\n            index of the data set to be visualized (starting with 0). When using\n            text, this will refer to the name of the data type for the data set\n            to be displayed.\n        viewport_: Text for the name of the Rhino viewport in which the VisualizationSet\n            will be rendered. Multiple viewports can be connected to have the\n            VisualizationSet display in several viewports. If unspecified, the\n            VisualizationSet is rendered in all viewports. Acceptable inputs include:\n                -\n                Perspective\n                Top\n                Bottom\n                Left\n                Right\n                Front\n                Back\n                any view name that has been saved within the Rhino file\n\n    Returns:\n        vs: A VisualizationSet object that can be baked into the Rhino document by\n            running \"Bake\" on this component or written to a standalone file\n            using the \"LB Dump VisualizationSet\" component.\n\"\"\"\n\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\nclass MyComponent(component):\n    \n    def __init__(self):\n        super(MyComponent,self).__init__()\n        self.vis_con = None\n        self.vs_goo = None\n        self.viewport = ()\n    \n    def RunScript(self, _vis_set, legend_par_, leg_par2d_, data_set_, viewport_):\n        ghenv.Component.Name = 'LB Preview VisualizationSet'\n        ghenv.Component.NickName = 'VisSet'\n        ghenv.Component.Message = '1.9.5'\n        ghenv.Component.Category = 'Ladybug'\n        ghenv.Component.SubCategory = '4 :: Extra'\n        ghenv.Component.AdditionalHelpFromDocStrings = '1'\n        \n        try:\n            from ladybug_display.visualization import VisualizationSet, AnalysisGeometry\n        except ImportError as e:\n            raise ImportError('\\nFailed to import ladybug_display:\\n\\t{}'.format(e))\n        \n        try:\n            from ladybug_rhino.grasshopper import all_required_inputs, objectify_output\n            from ladybug_rhino.preview import VisualizationSetConverter\n            from ladybug_rhino.visset import VisSetGoo, process_vis_set\n        except ImportError as e:\n            raise ImportError('\\nFailed to import ladybug_rhino:\\n\\t{}'.format(e))\n        \n        \n        if all_required_inputs(ghenv.Component):\n            # process the input visualization set\n            if len(_vis_set) == 1:\n                vis_set = _vis_set[0]\n            else:\n                vis_objs = []\n                for vis_obj in _vis_set:\n                    if isinstance(vis_obj, VisualizationSet):\n                        vis_objs.append([vis_obj])\n                    elif hasattr(vis_obj, 'to_vis_set'):\n                        vis_objs.append([vis_obj.to_vis_set()])\n                    elif hasattr(vis_obj, 'data'):\n                        arr_type = (list, tuple)\n                        if isinstance(vis_obj.data, arr_type) and \\\n                                isinstance(vis_obj.data[0], arr_type):\n                            for v_obj in vis_obj.data:\n                                vis_objs.append(v_obj)\n                        else:\n                            vis_objs.append(vis_obj.data)\n                vis_set = objectify_output('Multiple Vis Sets', vis_objs)\n            vis_set_obj = process_vis_set(vis_set)\n            \n            # process the connected legend parameters\n            if legend_par_ is not None:\n                for geo in vis_set_obj:\n                    if isinstance(geo, AnalysisGeometry):\n                        for data in geo.data_sets:\n                            # override legend properties if they are specified\n                            if legend_par_.min is not None:\n                                data.legend_parameters.min = legend_par_.min\n                            if legend_par_.max is not None:\n                                data.legend_parameters.max = legend_par_.max\n                            if not legend_par_.are_colors_default:\n                                data.legend_parameters.colors = legend_par_.colors\n                            if not legend_par_.is_segment_count_default:\n                                data.legend_parameters.segment_count = \\\n                                    legend_par_.segment_count\n                            if data.data_type is not None:\n                                unit = data.unit if data.unit else data.data_type.units[0]\n                                data.legend_parameters.title = \\\n                                    '{} ({})'.format(data.data_type.name, unit) \\\n                                    if not legend_par_.vertical else unit\n                            # set the other genreic legend parameter properties\n                            data.legend_parameters.continuous_legend = \\\n                                legend_par_.continuous_legend\n                            data.legend_parameters.decimal_count = \\\n                                legend_par_.decimal_count\n                            data.legend_parameters.include_larger_smaller = \\\n                                legend_par_.include_larger_smaller\n                            data.legend_parameters.font = legend_par_.font\n                            data.legend_parameters.vertical = legend_par_.vertical\n                            # override any 3D geometry properties\n                            if not legend_par_.is_base_plane_default:\n                                data.legend_parameters.base_plane = \\\n                                    legend_par_.base_plane\n                            if not legend_par_.is_segment_height_default:\n                                data.legend_parameters.segment_height = \\\n                                    legend_par_.segment_height\n                            if not legend_par_.is_segment_width_default:\n                                data.legend_parameters.segment_width = \\\n                                    legend_par_.segment_width\n                            if not legend_par_.is_text_height_default:\n                                data.legend_parameters.text_height = \\\n                                    legend_par_.text_height\n            # process connected 2D legend parameters\n            if leg_par2d_ is None:\n                leg3d, leg2d = True, False\n            else:\n                leg3d, leg2d = False, True\n                for geo in vis_set_obj:\n                    if isinstance(geo, AnalysisGeometry):\n                        for data in geo.data_sets:\n                            data.legend_parameters.properties_2d = leg_par2d_\n            # process the active data_set_ if it is specified\n            if data_set_ is not None:\n                try:  # data set is an integer referring to an index\n                    data_set_ = int(data_set_)\n                except ValueError:\n                    pass  # data set is text referring to the data type\n                for geo in vis_set_obj:\n                    if isinstance(geo, AnalysisGeometry):\n                        if isinstance(data_set_, int):\n                            if data_set_ < len(geo.data_sets):\n                                geo.active_data = data_set_\n                        else:\n                            for i, dat in enumerate(geo.data_sets):\n                                if str(dat.data_type) == data_set_:\n                                    geo.active_data = i\n            self.vis_con = VisualizationSetConverter(vis_set_obj, leg3d, leg2d)\n            self.vs_goo = VisSetGoo(vis_set_obj)\n            self.viewport = tuple(vp.lower() for vp in viewport_)\n        else:\n            self.vis_con = None\n            self.vs_goo = None\n            self.viewport = ()\n        \n        # return the bake-able version of the visualization set \n        return self.vs_goo\n    \n    def DrawViewportWires(self, args):\n        try:\n            if ghenv.Component.Locked:\n                return\n            if self.vis_con is not None:\n                if len(self.viewport)== 0 or args.Viewport.Name.lower() in self.viewport:\n                    # get the DisplayPipeline from the event arguments\n                    display = args.Display\n                    \n                    # for each object to be rendered, pass the drawing arguments\n                    for draw_args in self.vis_con.draw_3d_text:\n                        display.Draw3dText(*draw_args)\n                    for draw_args in self.vis_con.draw_mesh_wires:\n                        display.DrawMeshWires(*draw_args)\n                    for draw_args in self.vis_con.draw_mesh_vertices:\n                        display.DrawMeshVertices(*draw_args)\n                    for draw_args in self.vis_con.draw_point:\n                        display.DrawPoint(*draw_args)\n                    for draw_args in self.vis_con.draw_arrow:\n                        display.DrawArrow(*draw_args)\n                    for draw_args in self.vis_con.draw_brep_wires:\n                        display.DrawBrepWires(*draw_args)\n                    for draw_args in self.vis_con.draw_line:\n                        display.DrawLine(*draw_args)\n                    for draw_args in self.vis_con.draw_patterned_line:\n                        display.DrawPatternedLine(*draw_args)\n                    for draw_args in self.vis_con.draw_patterned_polyline:\n                        display.DrawPatternedPolyline(*draw_args)\n                    for draw_args in self.vis_con.draw_curve:\n                        display.DrawCurve(*draw_args)\n                    for draw_args in self.vis_con.draw_circle:\n                        display.DrawCircle(*draw_args)\n                    for draw_args in self.vis_con.draw_arc:\n                        display.DrawArc(*draw_args)\n                    for draw_args in self.vis_con.draw_sphere:\n                        display.DrawSphere(*draw_args)\n                    for draw_args in self.vis_con.draw_cone:\n                        display.DrawCone(*draw_args)\n                    for draw_args in self.vis_con.draw_cylinder:\n                        display.DrawCylinder(*draw_args)\n                    for draw_args in self.vis_con.draw_2d_text:\n                        display.Draw2dText(*draw_args)\n                    for draw_args in self.vis_con.draw_sprite:\n                        display.DrawSprite(*draw_args)\n        except Exception, e:\n            System.Windows.Forms.MessageBox.Show(str(e), \"script error\")\n    \n    def DrawViewportMeshes(self, args):\n        try:\n            if self.vis_con is not None:\n                if len(self.viewport)== 0 or args.Viewport.Name.lower() in self.viewport:\n                    # get the DisplayPipeline from the event arguments\n                    display = args.Display\n                    \n                    # for each object to be rendered, pass the drawing arguments\n                    for draw_args in self.vis_con.draw_mesh_false_colors:\n                        display.DrawMeshFalseColors(draw_args)\n                    for draw_args in self.vis_con.draw_mesh_shaded:\n                        display.DrawMeshFalseColors(draw_args[0])\n                    for draw_args in self.vis_con.draw_brep_shaded:\n                        display.DrawBrepShaded(*draw_args)\n        except Exception, e:\n            System.Windows.Forms.MessageBox.Show(str(e), \"script error\")\n    \n    def get_ClippingBox(self):\n        if self.vis_con is not None:\n            return self.vis_con.bbox\n        else:\n            return Rhino.Geometry.BoundingBox()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}