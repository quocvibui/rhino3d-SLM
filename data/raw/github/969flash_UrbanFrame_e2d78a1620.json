{
  "source_url": "https://github.com/969flash/UrbanFrame/blob/0f253b7a73233f7217608b7815c1a99f71e14f35/network_analysis.py",
  "repo": "969flash/UrbanFrame",
  "repo_stars": 0,
  "repo_description": "Generate Urban Frame",
  "license": "unknown",
  "filepath": "network_analysis.py",
  "instruction": "r: python-louvain",
  "code": "# r: python-louvain\ntry:\n    from typing import List, Tuple\nexcept ImportError:\n    pass\nimport networkx as nx\nimport community as community_louvain\nimport Rhino.Geometry as geo\nimport ghpythonlib.components as ghcomp\nimport utils\nimport importlib\nimport scriptcontext as sc\nimport units\n\nfrom units import Node, Edge, Road, Junction, RoadNetwork\n\n\nclass RoadNetworkAnalyzer:\n    def __init__(self, road_network: RoadNetwork):\n        self.road_network = road_network\n        self.graph = road_network.graph\n\n    def total_road_length(self) -> float:\n        \"\"\"Calculate the total length of all roads in the network.\"\"\"\n        return sum(edge.curve.GetLength() for edge in self.road_network.edges)\n\n    def average_road_width(self) -> float:\n        \"\"\"Calculate the average width of all roads in the network.\"\"\"\n        if not self.road_network.edges:\n            return 0.0\n        return sum(edge.width for edge in self.road_network.edges) / len(\n            self.road_network.edges\n        )\n\n    def node_degree_distribution(self) -> dict:\n        \"\"\"Return a dictionary with node degrees as keys and their frequencies as values.\"\"\"\n        degree_count = {}\n        for node in self.road_network.nodes:\n            degree = len(node.edges)\n            if degree not in degree_count:\n                degree_count[degree] = 0\n            degree_count[degree] += 1\n        return degree_count\n\n    def betweenness_centrality(self) -> dict:\n        \"\"\"Calculate the betweenness centrality for each node in the network.\"\"\"\n        return nx.betweenness_centrality(self.graph)\n\n    def closeness_centrality(self) -> dict:\n        \"\"\"Calculate the closeness centrality for each node in the network.\"\"\"\n        return nx.closeness_centrality(self.graph)\n\n    def eighenvector_centrality(self) -> dict:\n        \"\"\"Calculate the eigenvector centrality for each node in the network.\"\"\"\n        return nx.eigenvector_centrality(self.graph, max_iter=1000)\n\n    def detect_communities(self) -> dict:\n        \"\"\"Detect communities in the road network using the Louvain method.\"\"\"\n        return community_louvain.best_partition(self.graph)\n\n\nclass ResultVisualizer:\n    \"\"\"Create color-coded preview data for road network analysis results.\n\n    Each visualize_* method returns a tuple: (curves, colors, widths)\n      - curves: list[geo.Curve]\n      - colors: list[System.Drawing.Color] (same length)\n      - widths: list[int] (constant 3 for preview thickness)\n    \"\"\"\n\n    def __init__(\n        self,\n        road_network: RoadNetwork,\n        start_color=(0, 255, 0),  # green\n        end_color=(255, 0, 0),  # red\n    ):\n        self.road_network = road_network\n        self.graph = road_network.graph\n        self.start_color = start_color\n        self.end_color = end_color\n\n    # ------------- internal helpers ------------- #\n    @staticmethod\n    def _interpolate_color(start_rgb, end_rgb, t: float):\n        import System\n\n        t = max(0.0, min(1.0, t))\n        r = int(round(start_rgb[0] + (end_rgb[0] - start_rgb[0]) * t))\n        g = int(round(start_rgb[1] + (end_rgb[1] - start_rgb[1]) * t))\n        b = int(round(start_rgb[2] + (end_rgb[2] - start_rgb[2]) * t))\n        return System.Drawing.Color.FromArgb(255, r, g, b)\n\n    @staticmethod\n    def _normalize(values):\n        if not values:\n            return []\n        vmin = min(values)\n        vmax = max(values)\n        if abs(vmax - vmin) < 1e-12:\n            return [0.5] * len(values)\n        k = 1.0 / (vmax - vmin)\n        return [(v - vmin) * k for v in values]\n\n    def _edges_with_metric(self, metric_dict):\n        # Builds parallel lists of curves and metric values\n        curves = []\n        values = []\n        # Edge mapping: we have Road objects referencing Edge w/ curve\n        # We'll iterate through road_network.edges (Edge objects) and try to locate metric.\n        # metric_dict keys are node-based (for centralities) or node indexes; so we map via graph edges.\n        if not metric_dict:\n            return curves, values\n        for u, v, data in self.graph.edges(data=True):\n            curve = data.get(\"curve\")\n            if not curve:\n                # fallback attempt: find matching edge in road_network.edges\n                pass\n            # For node-based metrics (centrality) we might have per-node values\n            # For edge-based we expect a (u,v) key\n            key_edge = metric_dict.get((u, v))\n            if key_edge is None:\n                key_edge = metric_dict.get((v, u))\n            if key_edge is None:\n                # attempt convert node metrics to edge by averaging\n                if u in metric_dict and v in metric_dict:\n                    key_edge = 0.5 * (metric_dict[u] + metric_dict[v])\n            if key_edge is None:\n                continue\n            if curve is None:\n                continue\n            curves.append(curve)\n            values.append(float(key_edge))\n        return curves, values\n\n    def _build(self, metric_dict):\n        curves, values = self._edges_with_metric(metric_dict)\n        if not curves:\n            return [], [], []\n        norm = self._normalize(values)\n        colors = [\n            self._interpolate_color(self.start_color, self.end_color, t) for t in norm\n        ]\n        widths = [3] * len(curves)\n        return curves, colors, widths\n\n    # ------------- public visualize methods ------------- #\n    def visualize_betweenness(self, betweenness: dict):\n        return self._build(betweenness)\n\n    def visualize_communities(self, communities: dict):\n        # communities: node -> community_id ; map to sequential ids then assign color scale\n        if not communities:\n            return [], [], []\n        # Convert community id to numeric range\n        comm_ids = list(set(communities.values()))\n        comm_ids.sort()\n        id_to_val = {cid: i for i, cid in enumerate(comm_ids)}\n        # Build a node->normalized value dict\n        max_val = float(len(comm_ids) - 1) if len(comm_ids) > 1 else 1.0\n        node_metric = {\n            n: (id_to_val[c] / max_val if max_val > 0 else 0.5)\n            for n, c in communities.items()\n        }\n        return self._build(node_metric)\n\n    def visualize_node_degrees(self, degree_distribution: dict):\n        # degree_distribution: degree -> frequency; we need per-node degrees instead.\n        # Recompute per-node degrees from graph then map to metric dict (node->degree)\n        node_deg = dict(self.graph.degree())\n        return self._build(node_deg)\n\n\nroad_network = globals().get(\"road_network\", None)  # type: RoadNetwork\n\nRoadNetworkAnalyzer(road_network)\nrna = RoadNetworkAnalyzer(road_network)\nbetweenness = rna.betweenness_centrality()\nvis = ResultVisualizer(road_network)\ncurves, colors, widths = vis.visualize_betweenness(betweenness)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": true
}