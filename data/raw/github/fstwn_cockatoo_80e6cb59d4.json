{
  "source_url": "https://github.com/fstwn/cockatoo/blob/d952ac5d2148ec29fba52e8eb75f0f43770c74ca/usrobj_src/Cockatoo_KnitContoursOnMesh.py",
  "repo": "fstwn/cockatoo",
  "repo_stars": 38,
  "repo_description": "Cockatoo is a prototypical open-source software toolkit for generating (3d-)knitting patterns from NURBS surface and mesh geometry directly inside Grasshopper.",
  "license": "MIT",
  "filepath": "usrobj_src/Cockatoo_KnitContoursOnMesh.py",
  "instruction": "Constructs contours for deriving a knitting pattern from a mesh. Use the\nGeodesicStrength and TweenStrength inputs to control the shape and distribution\nof the contour curves on the mesh.\n---\nBased...",
  "code": "\"\"\"\nConstructs contours for deriving a knitting pattern from a mesh. Use the\nGeodesicStrength and TweenStrength inputs to control the shape and distribution\nof the contour curves on the mesh.\n---\nBased on an approach for geodesics by Anders Holden Deleuran\nhttps://discourse.mcneel.com/t/geodesic-lines-on-a-mesh/58790/4\n    Inputs:\n        Run: Set to True to activate the component. Connect a boolean toggle\n             ideally.\n             {item, bool}\n        Mesh: The mesh to create the contours on.\n              {item, mesh}\n        KnitConstraints: The Cockatoo KnitConstraints defining the direction and\n                         limits of the contours.\n                         {item, float}\n        ContourDensity: The density (i.e. amount) of the contour curves.\n                        {item, int/float}\n        ContourMode: How to interpret the ContourDensity input.\n                     [0] = Relative - ContourDensity sets the total number of\n                           contour curves.\n                     [1] = Absolute - ContourDensity sets the target distance\n                         between the contour curves.\n                     {item, integer}\n        ContourDivisionDensity: The resolution (i.e. division count) of the\n                                contour curves.\n                                {item, int/float}\n        ContourDivisionMode: How to interpret the ContourDivisionDensity input.\n                             [0] = Relative - ContourDivisionDensity sets the\n                                 total num of divisions for the contour curves.\n                             [1] = Absolute - ContourDivisionDensity sets the\n                                 target segment length of the contour curves.\n                             {item, int/float}\n        GeodesicStrength: Strength of the internal Kangaroo2 goal minimizing the\n                          length of the contour curves. Defaults to 1000.\n                          {item, int}\n        TweenStrength: Strength of the internal Kangaroo2 goal controlling the\n                       distribution of the contours. Defaults to 2000.\n                       {item, int}\n        MaxIterations: The maximum number of iterations for the internal\n                       Kangaroo2 solver.\n                       {item, int}\n        Tolerance: The tolerance of the internal Kangaroo2 solver.\n                   Defaults to 1e-6.\n                   {item, int}\n        Threshold: The threshold for the internal Kangaroo2 solver.\n                   Defaults to 1e-14.\n                   {item, int}\n    Output:\n        KnitContours: The KnitContour curves on the mesh for initializing a\n                      KnitNetwork and deriving a knitting pattern.\n                      {item, polyline}\n    Remarks:\n        Author: Max Eschenbach\n        License: MIT License\n        Version: 200705\n\"\"\"\n\n# PYTHON STANDARD LIBRARY IMPORTS\nfrom __future__ import division\nimport clr\nimport os\n\n# .NET IMPORTS\nfrom System.Collections.Generic import List\n\n# GHPYTHON SDK IMPORTS\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\n# GHENV COMPONENT SETTINGS\nghenv.Component.Name = \"KnitContoursOnMesh\"\nghenv.Component.NickName =\"KCOM\"\nghenv.Component.Category = \"Cockatoo\"\nghenv.Component.SubCategory = \"05 Contouring\"\n\n# KANGAROO 2 IMPORT\nif \"KangarooSolver\" in str(clr.References):\n    import KangarooSolver as ks\nelse:\n    try:\n        rhino_version = Rhino.RhinoApp.ExeVersion\n        if os.name == \"nt\":\n            if rhino_version == 6:\n                k2ap = (\"C:/Program Files/Rhino 6/Plug-ins/Grasshopper/\"\n                        \"Components/KangarooSolver.dll\")\n                clr.AddReferenceToFileAndPath(os.path.normpath(k2ap))\n            elif rhino_version == 7:\n                k2ap = (\"C:/Program Files/Rhino 7/Plug-ins/Grasshopper/\"\n                        \"Components/KangarooSolver.dll\")\n                if not os.path.exists(k2ap):\n                    k2ap = (\"C:/Program Files/Rhino 7 WIP/Plug-ins/Grasshopper/\"\n                            \"Components/KangarooSolver.dll\")\n                clr.AddReferenceToFileAndPath(os.path.normpath(k2ap))\n        elif os.name == \"posix\":\n            k2ap = (r\"/Applications/Rhinoceros.app/Contents/Frameworks/\"\n                      \"RhCore.framework/Versions/A/Resources/ManagedPlugIns/\"\n                      \"GrasshopperPlugin.rhp/Components/KangarooSolver.dll\")\n            clr.AddReferenceToFileAndPath(os.path.normpath(k2ap))\n        import KangarooSolver as ks\n    except (IOError, ImportError):\n        try:\n            clr.AddReferenceToFile(\"KangarooSolver.dll\")\n            import KangarooSolver as ks\n        except (IOError, ImportError):\n            raise RuntimeError(\"KangarooSolver.dll was not found! \"\n                               \"please add the folder to your module \"\n                               \"search paths manually!\")\n\n# LOCAL MODULE IMPORTS\ntry:\n    import cockatoo\nexcept ImportError:\n    errMsg = \"The Cockatoo python module seems to be not correctly \" + \\\n             \"installed! Please make sure the module is in you search \" + \\\n             \"path, see README for instructions!.\"\n    raise ImportError(errMsg)\n\nclass KnitContoursOnMesh(component):\n    \n    def relax_contours_on_mesh(self, polylines, mesh, kLineLengthA, kLineLengthB, kEqualize, kOnMesh, thres, iMax, tol):\n        \"\"\"\n        Relax a bunch of contour lines on a mesh.\n        Based on an approach by Anders Holden Deleuran.\n        \"\"\"\n        \n        EQMODE = 0\n        \n        if iMax == 0:\n            return polylines, 0\n        else:\n            # create the list of goals\n            goals = []\n            if EQMODE == 0:\n                eqLines = List[Rhino.Geometry.Curve]()\n            elif EQMODE == 1:\n                eqLines = [List[Rhino.Geometry.Curve]() \\\n                           for x in range(len(polylines))]\n            for i, pl in enumerate(polylines):\n                # make show goal\n                ghc = Grasshopper.Kernel.Types.GH_Curve(pl.ToPolylineCurve())\n                gow = Grasshopper.Kernel.Types.GH_ObjectWrapper(ghc)\n                goals.append(ks.Goals.Locator(gow))\n                \n                # make anchor goals\n                plpts = pl.ToArray()\n                if i == 0 or i == (len(polylines) - 1):\n                    goals.extend([ks.Goals.Anchor(pt, 10000000) for pt in plpts])\n                else:\n                    goals.extend([ks.Goals.Anchor(a, 10000000) for a in [plpts[0],\n                                                                   plpts[-1]]])\n                \n                # make spring goals (line length)\n                segs = pl.GetSegments()\n                \n                # get next segments\n                y = i + 1\n                if y <= len(polylines) - 1:\n                    nextsegs = polylines[y].GetSegments()\n                else:\n                    nextsegs = None\n                \n                for j, seg in enumerate(segs):\n                    goals.append(ks.Goals.Spring(seg.From,\n                                                 seg.To,\n                                                 0.00,\n                                                 kLineLengthA))\n                    \n                    if nextsegs:\n                        goals.append(ks.Goals.Spring(seg.From,\n                                                     nextsegs[j].From,\n                                                     0.00,\n                                                     kLineLengthB))\n                        if kEqualize:\n                            # create the equal length line\n                            eqln = Rhino.Geometry.LineCurve(seg.From,\n                                                            nextsegs[j].From)\n                            if EQMODE == 0:\n                                eqLines.Add(eqln)\n                            elif EQMODE == 1:\n                                eqLines[0].Add(eqln)\n                \n                # make onmesh goal with all points\n                anchorList = List[Rhino.Geometry.Point3d]()\n                [anchorList.Add(pt) for pt in plpts]\n                goals.append(ks.Goals.OnMesh(anchorList, mesh, kOnMesh))\n            \n            # create equallength goal\n            if kEqualize:\n                if EQMODE == 0:\n                    goals.append(ks.Goals.EqualLength(eqLines, kEqualize))\n                elif EQMODE == 1:\n                    for eqLine in eqLines:\n                        goals.append(ks.Goals.EqualLength(eqLine, kEqualize))\n            \n            # create physical system and dotnet list for goals\n            ps = ks.PhysicalSystem()\n            goalsList = List[ks.IGoal]()\n            \n            # assign particle indices automagically\n            for g in goals:\n                ps.AssignPIndex(g, tol)\n                goalsList.Add(g)\n            \n            # solve the k2 physical system\n            iterations = 0\n            for i in range(iMax):\n                ps.Step(goalsList, True, 1000.0)\n                vs = ps.GetvSum()\n                iterations += 1\n                if vs <= thres:\n                    break\n            \n            # get relaxed polylines from output\n            contours = []\n            for o in ps.GetOutput(goalsList):\n                if type(o) is Rhino.Geometry.Polyline:\n                    contours.append(o)\n                    \n            return contours, iterations\n    \n    def get_segment_ratios(self, segments):\n        \"\"\"\n        Get the length ratios for the given segment relative to their overall\n        length.\n        \"\"\"\n        \n        overall_length = sum([seg.GetLength() for seg in segments])\n        \n        seg_ratios = [(seg.GetLength() / overall_length) for seg in segments]\n        \n        return overall_length, seg_ratios\n    \n    def create_contours(self, KMCList, ContourDensity, ContourDivisionDensity, ContourMode, ContourDivisionMode):\n        \n        # unpack the kmclist\n        StartCourse, EndCourse, LeftBoundary, RightBoundary = KMCList\n        \n        # GET SEGMENTATION RATIOS ----------------------------------------------\n        \n        stLen, sRat = self.get_segment_ratios([StartCourse])\n        etLen, eRat = self.get_segment_ratios([EndCourse])\n        ltLen, lbRat = self.get_segment_ratios(LeftBoundary)\n        rtLen, rbRat = self.get_segment_ratios(RightBoundary)\n        \n        # SET SAMPLING DENSITY -------------------------------------------------\n        \n        if ContourMode == 0:\n            ContourDensity = int(ContourDensity)\n        elif ContourMode == 1:\n            ContourDensity = int(round(max([stLen, etLen])/ContourDensity))\n        \n        if ContourDivisionMode == 0:\n            ContourDivisionDensity = int(ContourDivisionDensity)\n        elif ContourDivisionMode == 1:\n            ContourDivisionDensity = int(round(max([ltLen, rtLen])/ContourDivisionDensity))\n        \n        # COMPUTE DIVISIONS FOR LEFT AND RIGHT BOUNDARY SEGMENTS ---------------\n        \n        # get left boundary divisions\n        lbDiv = [int(round(rat*int(ContourDivisionDensity))) for rat in lbRat]\n        lbSum = sum(lbDiv)\n        if 0 in lbDiv:\n            for i, val in enumerate(lbDiv):\n                if val == 0:\n                    lbDiv[i] += 1\n                if val == max(lbDiv):\n                    lbDiv[i] -= 1\n        if lbSum != ContourDivisionDensity:\n            dlt = int(ContourDivisionDensity - lbSum)\n            for i, val in enumerate(lbDiv):\n                if val == max(lbDiv):\n                    lbDiv[i] += dlt\n                    break\n        \n        # get right boundary divisions\n        rbDiv = [int(round(rat*int(ContourDivisionDensity))) for rat in rbRat]\n        rbSum = sum(rbDiv)\n        if 0 in rbDiv:\n            for i, val in enumerate(rbDiv):\n                if val == 0:\n                    rbDiv[i] += 1\n                if val == max(rbDiv):\n                    rbDiv[i] -= 1\n        if rbSum != ContourDivisionDensity:\n            dlt = int(ContourDivisionDensity - rbSum)\n            for i, val in enumerate(rbDiv):\n                if val == max(rbDiv):\n                    rbDiv[i] += dlt\n                    break\n        \n        # raise errors if input is wrong\n        if not sum(lbDiv) == sum(rbDiv) == ContourDivisionDensity:\n            if ContourDivisionMode == 0:\n                raise ValueError(\"Sampling density for left and right is too \" +\n                                 \"low for number of left or right segments! \" +\n                                 \"Try increasing the density.\")\n            elif ContourDivisionMode == 1:\n                raise ValueError(\"Sampling distance for left and right is \" +\n                                 \"too high for number of left or right \" +\n                                 \"segments! Try decreasing the distance.\")\n        \n        # divide all left boundary segments with their matching segment count\n        lpt = []\n        for i, segment in enumerate(LeftBoundary):\n            segment.Domain = Rhino.Geometry.Interval(0, 1)\n            segT = segment.DivideByCount(lbDiv[i], True)\n            segPt = [segment.PointAt(t) for t in segT]\n            [lpt.append(p) for p in segPt if p not in lpt]\n        \n        # divide all right boundary segments with their matching segment count\n        rpt = []\n        for i, segment in enumerate(RightBoundary):\n            segment.Domain = Rhino.Geometry.Interval(0, 1)\n            segT = segment.DivideByCount(rbDiv[i], True)\n            segPt = [segment.PointAt(t) for t in segT]\n            [rpt.append(p) for p in segPt if p not in rpt]\n        \n        # GET SEGMENTATION RATIOS FOR START AND END BOUNDARY -------------------\n        \n        # get start boundary divisions\n        sDiv = [int(round(rat*int(ContourDensity))) for rat in sRat]\n        sSum = sum(sDiv)\n        if 0 in sDiv:\n            for i, val in enumerate(sDiv):\n                if val == 0:\n                    sDiv[i] += 1\n                if val == max(sDiv):\n                    sDiv[i] -= 1\n        if sSum != ContourDensity:\n            dlt = int(ContourDensity - sSum)\n            for i, val in enumerate(sDiv):\n                if val == max(sDiv):\n                    sDiv[i] += dlt\n                    break\n        \n        # get end boundary divisions\n        eDiv = [int(round(rat*int(ContourDensity))) for rat in eRat]\n        eSum = sum(eDiv)\n        if 0 in eDiv:\n            for i, val in enumerate(eDiv):\n                if val == 0:\n                    eDiv[i] += 1\n                if val == max(eDiv):\n                    eDiv[i] -= 1\n        if eSum != ContourDensity:\n            dlt = int(ContourDivisionDensity - eSum)\n            for i, val in enumerate(eDiv):\n                if val == max(eDiv):\n                    eDiv[i] += dlt\n                    break\n        \n        # raise errors if input is wrong\n        if not sum(sDiv) == sum(eDiv) == ContourDensity:\n            if ContourMode == 0:\n                raise ValueError(\"Sampling density for start and end is too \" +\n                                 \"low for number of start or end segments! \" +\n                                 \"Try increasing the density.\")\n            elif ContourMode == 1:\n                raise ValueError(\"Sampling distance for start and end is too \" +\n                                 \"high for number of start or end segments! \" +\n                                 \"Try decreasing the distance.\")\n        \n        # divide all start boundary segments with their matching segment count\n        spt = []\n        for i, segment in enumerate([StartCourse]):\n            segment.Domain = Rhino.Geometry.Interval(0, 1)\n            segT = segment.DivideByCount(sDiv[i], True)\n            segPt = [segment.PointAt(t) for t in segT]\n            [spt.append(p) for p in segPt if p not in spt]\n        spt = spt[1:-1]\n        \n        # divide all right boundary segments with their matching segment count\n        ept = []\n        for i, segment in enumerate([EndCourse]):\n            segment.Domain = Rhino.Geometry.Interval(0, 1)\n            segT = segment.DivideByCount(eDiv[i], True)\n            segPt = [segment.PointAt(t) for t in segT]\n            [ept.append(p) for p in segPt if p not in ept]\n        ept = ept[1:-1]\n        \n        # CREATE DESTIONATION LINES AND SAMPLE THEM ----------------------------\n        \n        # build destination lines\n        destinations = []\n        for i, pt in enumerate(spt):\n            ln = Rhino.Geometry.LineCurve(pt, ept[i])\n            destinations.append(ln)\n        \n        # sample destination lines\n        for i, d in enumerate(destinations):\n            d.Domain = Rhino.Geometry.Interval(0, 1)\n            dt = d.DivideByCount(ContourDivisionDensity, True)\n            dpts = [d.PointAt(t) for t in dt]\n            destinations[i] = Rhino.Geometry.PolylineCurve(dpts)\n        \n        # CREATE FINAL LIST OF CONTOURS ----------------------------------------\n        \n        Contours = [Rhino.Geometry.PolylineCurve(lpt)]\n        Contours.extend(destinations)\n        Contours.append(Rhino.Geometry.PolylineCurve(rpt))\n        for i, c in enumerate(Contours):\n            Contours[i] = c.TryGetPolyline()[1]\n        \n        return Contours\n    \n    def RunScript(self, Run, Mesh, KnitConstraint, ContourDensity, ContourMode, ContourDivisionDensity, ContourDivisionMode, GeodesicStrength, TweenStrength, MaxIterations, Tolerance, Threshold):\n        \n        # INITIALIZATION -------------------------------------------------------\n        \n        # sanitize ContourMode input\n        if ContourMode == None:\n            ContourMode = 0\n        elif ContourMode < 0:\n            ContourMode = 0\n        elif ContourMode > 1:\n            ContourMode = 1\n        \n        # sanitize ContourDivisionMode input\n        if ContourDivisionMode == None:\n            ContourDivisionMode = 0\n        elif ContourDivisionMode < 0:\n            ContourDivisionMode = 0\n        elif ContourDivisionMode > 1:\n            ContourDivisionMode = 1\n        \n        # set default for maximum iterations\n        if MaxIterations == None:\n            MaxIterations = 100\n        \n        # set default tolerance\n        if Tolerance == None:\n            Tolerance = 1e-6\n        \n        # set default Threshold\n        if not Threshold:\n            Threshold = 1e-14\n        \n        if GeodesicStrength == None:\n            GeodesicStrength = 1000\n        if TweenStrength == None:\n            TweenStrength = 2000\n        \n        EqualizeStrength = 0\n        OnMeshStrength = 100000\n        \n        NullTree = Grasshopper.DataTree[object]()\n        \n        # DEACTIVATED CONDITION ------------------------------------------------\n        \n        if not Run or not Mesh or not KnitConstraint:\n            self.Message = \"Deactivated\"\n            if not Mesh:\n                rml = self.RuntimeMessageLevel.Warning\n                self.AddRuntimeMessage(rml, \"No Mesh input!\")\n            if not KnitConstraint:\n                rml = self.RuntimeMessageLevel.Warning\n                self.AddRuntimeMessage(rml, \"No KnitConstraint input!\")\n            return NullTree\n        \n        # UNPACK CONSTRAINTS ---------------------------------------------------\n        \n        StartCourse = KnitConstraint.start_course\n        EndCourse = KnitConstraint.end_course\n        LeftBoundary = KnitConstraint.left_boundary\n        RightBoundary = KnitConstraint.right_boundary\n        \n        KMCList = [StartCourse, EndCourse, LeftBoundary, RightBoundary]\n        \n        # SAMPLE INPUT AND CREATE CONTOURS -------------------------------------\n        \n        Contours = self.create_contours(KMCList,\n                                       ContourDensity,\n                                       ContourDivisionDensity,\n                                       ContourMode,\n                                       ContourDivisionMode)\n        \n        # RELAX CONTOUR CURVES ON THE MESH -------------------------------------\n        \n        Contours, Iterations = self.relax_contours_on_mesh(Contours,\n                                                        Mesh,\n                                                        GeodesicStrength,\n                                                        TweenStrength,\n                                                        EqualizeStrength,\n                                                        OnMeshStrength,\n                                                        Threshold,\n                                                        MaxIterations, \n                                                        Tolerance)\n        \n        # SET COMPONENT MESSAGE ------------------------------------------------\n        \n        if Iterations < MaxIterations:\n            self.Message = \"Converged after {} iterations\".format(Iterations)\n        else:\n            self.Message = \"Stopped after {} iterations\".format(Iterations)\n        \n        # RETURN OUTPUTS -------------------------------------------------------\n        \n        return Contours\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}