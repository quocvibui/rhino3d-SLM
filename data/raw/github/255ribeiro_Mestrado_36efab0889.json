{
  "source_url": "https://github.com/255ribeiro/Mestrado/blob/07e9939e80a3217834a7cd6707bda1bf5fb46389/Latex/Disseracao%20-%20MCTI/agoritmoVolumes.py",
  "repo": "255ribeiro/Mestrado",
  "repo_stars": 0,
  "repo_description": "Arquivos da Dissertação de Mestrado",
  "license": "unknown",
  "filepath": "Latex/Disseracao - MCTI/agoritmoVolumes.py",
  "instruction": "Agoritmo volumes",
  "code": "﻿from __future__ import division\n#importando bibliotecas do Rhinoceros:\n#Rhino Common, rhinoscriptsintax e ghpythonlib\nfrom Rhino.Geometry import Point3d, Line, NurbsCurve\nimport rhinoscriptsyntax as rs\nimport ghpythonlib.components as gh\n\nTr_3D = []\nTr_copias = []\nteste=[]\nCargas = []\n\nif not Bz_l:\n    Bz_l=Diag_l\nif not Peso_esp_Tr:\n    Peso_esp_Tr = 7800 #Peso específico do aço Kg/m^3\nif not Peso_cobertura:\n     Peso_cobertura = 20 #Sobrecarga do telhado Kg/m^2\nif not Fator_de_conv:\n    Fator_de_conv = 10\nif not N_Tr:\n    N_Tr = 1\n\nif not Plano:\n    Plano = rs.WorldXYPlane()\n#decompoe o plano de trabalho nos componentes Origem e os eixos xyz\npOr, eX, eY, eZ = Plano\n\n\n#Separando os eixos em listas\n#conector\nConector = Eixos[-2:]\n#vigas\nv1 = Eixos[:3]\nv2 = Eixos[3:6]\nv3 =  Eixos[6:9]\n#invertendo sentido da viga v3\nrs.ReverseCurve(v3[0])\nrs.ReverseCurve(v3[1])\nrs.ReverseCurve(v3[2])\n#diagonais\nDiagonais = [v1[1],v2[1],v3[1]]\n#banzos\nBanzo_Sup = [v1[0],v2[0],v3[0]]\nBanzo_Inf = [v1[2],v2[2],v3[2]]\n#apoios\nApoios = [rs.CurveStartPoint(v1[2]),rs.CurveStartPoint(v2[2])]\n#Eixo de Simetria do conector\nEixoSimetria = Conector[0]\nEixoSimetria =  rs.coerceline(EixoSimetria)\n\n\n\ndef Volumetria(eixos, dist_e, dist_l, pto):\n\n    plAux = rs.CopyObject(eixos,-eZ*(dist_l))\n    \n    plAux2 = rs.CopyObject(eixos,eZ*(dist_l))\n    pl1 = rs.OffsetCurve(plAux,pto,dist_e,eZ)\n    pl1 = rs.coercegeometry(pl1)\n\n    pl2 =  rs.OffsetCurve(plAux,pto,-dist_e,eZ)\n    pl2 = rs.coercegeometry(pl2)\n  \n    pl3 = rs.AddLine(rs.CurveStartPoint(pl1),rs.CurveStartPoint(pl2))\n    pl4 = rs.AddLine(rs.CurveEndPoint(pl1),rs.CurveEndPoint(pl2))\n    eixos3D = rs.AddPlanarSrf((pl1,pl3,pl2,pl4))\n    lin = rs.AddLine(rs.CurveStartPoint(plAux),rs.CurveStartPoint(plAux2))\n    \n    eixos3D = rs.ExtrudeSurface (eixos3D, lin, True)\n\n    eixos3D = rs.coercegeometry(eixos3D)\n    return eixos3D\n\n\ndef Cargas_Vigas(viga, plD, plB , plC , cob, borda1, borda2, conv):\n    #\n    cob = rs.coercecurve(cob)\n    forces = []\n    #separando entrada viga em seus elementos (polilinhas)\n    #bs = banzo superior, diag = diagonais, bi = banzo inferior\n    bs, diag, bi = viga\n    #extraindo os nós do banzo superior\n    nos = rs.PolylineVertices(bs)\n    # explodindo polilinhas\n    bs = rs.ExplodeCurves(bs)\n    diag = rs.ExplodeCurves(diag)\n    bi = rs.ExplodeCurves(bi)\n    for i in range(len(nos)):\n        P=0\n        if 0<i<(len(nos)-1):\n            #banzo inferior\n            P = rs.CurveLength(bi[i])*plB\n            #banzo superior\n            P +=(rs.CurveLength(bs[i-1])+rs.CurveLength(bs[i])) /2 *plB\n            #diagonais\n            P +=( rs.CurveLength(diag[i*2])+rs.CurveLength(diag[(i*2)+1]) )*plD\n            #cobertura\n            bs1 = bs[i-1]\n            bs1 = rs.coerceline(bs1)\n            ptAux1 = bs1.PointAt(.5)\n            bs2 = bs[i]\n            bs2 = rs.coerceline(bs2)\n            ptAux2 = bs2.PointAt(.5)\n            param1 = rs.CurveClosestPoint(cob,ptAux1)\n            param2 = rs.CurveClosestPoint(cob,ptAux2)\n        \n        elif i == 0:\n            \n            #banzo inferior\n            P = rs.CurveLength(bi[i])*plB\n            #banzo superior\n            P += (rs.CurveLength(bs[i])/2)*plB\n            #diagonais\n            P +=( rs.CurveLength(diag[i*2])+rs.CurveLength(diag[(i*2)+1]) )*plD\n            #cobertura\n            param1 = 0\n            bs1 = bs[i]\n            bs1 = rs.coerceline(bs1)\n            ptAux = bs1.PointAt(.5)\n            #teste.append(ptAux)\n            param2 = rs.CurveClosestPoint(cob,ptAux)\n            \n        elif i == (len(nos)-1):\n            #banzo superior e conector\n            P = (rs.CurveLength(bs[i-1])+rs.CurveLength(borda1)) /2 *plB\n            #conector\n            P += rs.CurveLength(borda2) *plB\n            #cobertura\n            bs1 = bs[i-1]\n            bs1 = rs.coerceline(bs1)\n            ptAux1 = bs1.PointAt(.5)\n            borda1 = rs.coerceline(borda1)\n            ptAux2  = borda1.PointAt(.5)\n            param1 = rs.CurveClosestPoint(cob,ptAux1)\n            param2 = rs.CurveClosestPoint(cob,ptAux2)\n            if not len(diag)%2 == 0:\n                #banzo inferior\n                P += rs.CurveLength(bi[i])*plB\n                #diagonal\n                P += ( rs.CurveLength(diag[i*2]) )*plD\n        P_viga = P\n        if not param1 == param2:\n            cobAux = rs.TrimCurve(cob,[param1,param2],False)\n            P_cob = rs.CurveLength(cobAux)*plC\n            P += P_cob\n        P *= conv\n        forces.append(P)\n    return forces, P_viga, P_cob\n\ndef Cargas_Shed(viga, plD, plB , plC , cob, borda1, borda2, conv):\n    rs.ReverseCurve(cob)\n    cob = rs.coercecurve(cob)\n    \n    forces = []\n    #separando entrada viga em seus elementos (polilinhas)\n    #bs = banzo superior, diag = diagonais, bi = banzo inferior\n    bs, diag, bi = viga\n    #extraindo os nós do banzo superior\n    nos = rs.PolylineVertices(bs)\n    # explodindo polilinhas\n    bs = rs.ExplodeCurves(bs)\n    diag = rs.ExplodeCurves(diag)\n    bi = rs.ExplodeCurves(bi)\n    for i in range(len(nos)):\n        P=0\n        if 0<i<(len(nos)-1):\n            #banzo inferior\n            P = rs.CurveLength(bi[i-1])*plB\n            #banzo superior\n            P += (rs.CurveLength(bs[i-1])+rs.CurveLength(bs[i])) /2 *plB\n            #diagonais\n            P +=( rs.CurveLength(diag[i*2])+rs.CurveLength(diag[(i*2)-1]) )*plD\n            #cobertura\n            bs1 = bs[i-1]\n            bs1 = rs.coerceline(bs1)\n            ptAux1 = bs1.PointAt(.5)\n            bs2 = bs[i]\n            bs2 = rs.coerceline(bs2)\n            ptAux2 = bs2.PointAt(.5)\n            param1 = rs.CurveClosestPoint(cob,ptAux1)\n            param2 = rs.CurveClosestPoint(cob,ptAux2)\n        \n        elif i == 0:\n            \n            #banzo superior\n            P += (rs.CurveLength(bs[i])/2)*plB\n            #diagonal\n            P += ( rs.CurveLength(diag[i*2])) *plD\n            #cobertura\n            param1 = 0\n            bs1 = bs[i]\n            bs1 = rs.coerceline(bs1)\n            ptAux = bs1.PointAt(.5)\n\n            param2 = rs.CurveClosestPoint(cob,ptAux)\n            \n        elif i == (len(nos)-1):\n            #banzo superior e conector\n            P = ( rs.CurveLength(bs[-1])/2 +rs.CurveLength(borda1) )  *plB\n            #eixo do conector\n            P += rs.CurveLength(borda2) *plB\n            #cobertura\n            bs1 = bs[i-1]\n            bs1 = rs.coerceline(bs1)\n            ptAux1 = bs1.PointAt(.5)\n            borda1 = rs.coerceline(borda1)\n            ptAux2  = borda1.PointAt(.5)\n            param1 = rs.CurveClosestPoint(cob,ptAux1)\n            param2 = rs.CurveClosestPoint(cob,ptAux2)\n            if  len(diag)%2 == 0:\n                #banzo inferior\n                P += rs.CurveLength(bi[i-1])*plB\n                #diagonal\n                P += ( rs.CurveLength(diag[(i*2)-1]) )*plD\n        P_viga = P\n        if not param1 == param2:\n            cobAux = rs.TrimCurve(cob,[param1,param2],False)\n            P_cob = rs.CurveLength(cobAux)*plC\n            P += P_cob\n        P *= conv\n        forces.append(P)\n    return forces, P_viga, P_cob\n\n### - treliça 3D - ###\nif Mostrar_Volume == None:\n    Mostrar_Volume = True\nif Mostrar_Volume:\n# ponto de orientação dos offsets\n    ptX = EixoSimetria.PointAt(.5)\n# 3D das diagonais e eixo do conector\n    DiagEixo = Diagonais \n    for i in DiagEixo:\n        vol = Volumetria(i,Diag_e/2,Diag_l/2,ptX)\n        Tr_3D.append(vol)\n# 3D dos banzos e bordas do conector\n    BzEixo = Banzo_Sup + Banzo_Inf + Conector\n    for i in BzEixo:\n        vol = Volumetria(i,Bz_e/2,Bz_l/2,ptX)\n        Tr_3D.append(vol)\n# 3D da cobertura\n    for i in Cobertura:\n        vol = Volumetria(i,.01,Dist_entre_eixos/2,ptX)\n        Tr_3D.append(vol)\n# copiando treliças de acordo com a distancia entre os eixos\n    for i in range(1,N_Tr,1): \n        Tr_copias += gh.Move(Tr_3D,i*Dist_entre_eixos*eZ)[0]\n\n### - cargas - ###\n#area das diagonais\nAreaD = Diag_e * Diag_l\n#area do banzo\nAreaB = Bz_e * Bz_l\n#peso linear das diagonais\nplDiag =  AreaD * Peso_esp_Tr\n#peso linear do banzo\nplBz = AreaB * Peso_esp_Tr\n#peso linear da cobertura\nplCob = Peso_cobertura * Dist_entre_eixos\n\nConectBorda = Conector[1:]\nConectBorda = rs.ExplodeCurves(ConectBorda)\n\n#calculando as cargas na viga v1\n# P_v1 = lista de cargas nos nós superiores da viga v1\n# PP_v1 = peso próprio da viga v1\n# P_cob1 = peso da cobertura sobe da viga v1\nP_v1, PP_v1, P_cob1 = Cargas_Vigas(v1, plDiag, plBz, plCob, Cobertura[0], ConectBorda[0], ConectBorda[1], Fator_de_conv)\n#calculando as cargas na viga v2\n# P_v2 = lista de cargas nos nós superiores da viga v2\n# PP_v2 = peso próprio da viga v2\n# P_cob2 = peso da cobertura sobe da viga v2\nP_v2, PP_v2, P_cob2 = Cargas_Vigas(v2, plDiag, plBz, plCob, Cobertura[1], ConectBorda[3], ConectBorda[2], Fator_de_conv)\n#calculando as cargas no shed\n# P_v1 = lista de cargas nos nós superiores do shed\n# PP_v1 = peso próprio do shed\n# P_cob1 = peso da cobertura sobe do shed\nP_v3, PP_v3, P_cob3 = Cargas_Shed(v3, plDiag, plBz, plCob, Cobertura[0], ConectBorda[0],Conector[0], Fator_de_conv)\nP_v3.reverse()\n# lista dos modulos das cargas nos nós das vigas e shed\nCargas = [P_v1, P_v2, P_v3]\n# peso próprio total\nPP_total = PP_v1 + PP_v2 + PP_v3\nprint 'Peso próprio da viga = ', PP_total\n# sobrecarga da cobertura total\nPcob_total = P_cob1 + P_cob2 + P_cob3\nprint 'Sobrecarca da cobertura = ', Pcob_total\n# saida com as áreas das seções do banzoe  das diagonais\nAreas = [AreaB, AreaD]\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}