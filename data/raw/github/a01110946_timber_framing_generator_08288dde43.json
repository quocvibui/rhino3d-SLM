{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_junction_analyzer.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_junction_analyzer.py",
  "instruction": "Junction Analyzer for Grasshopper.",
  "code": "# File: scripts/gh_junction_analyzer.py\n\"\"\"Junction Analyzer for Grasshopper.\n\nAnalyzes wall junctions (L-corners, T-intersections, X-crossings) from wall\ngeometry data and outputs per-layer extension/trim adjustments. This component\nsits between the Wall Analyzer and downstream framing/sheathing generators,\nproviding each with the exact adjustment amounts needed at every wall end.\n\nAdditionally, computes ``framing_segments`` from core layer adjustments and\nemits an enriched ``walls_json`` so that all downstream components (Cell\nDecomposer, Panel Decomposer, Framing Generator, MEP Router) operate on\ncorrect junction-adjusted framing boundaries.\n\nKey Features:\n1. Junction Detection and Classification\n   - L-corners (two walls meeting at an angle)\n   - T-intersections (wall ending mid-span of another)\n   - X-crossings (two walls crossing through each other)\n   - Free ends and inline continuations\n\n2. Per-Layer Resolution\n   - Butt and miter join strategies\n   - Configurable priority: longer_wall, exterior_first, alternate\n   - Per-wall layer thickness overrides (exterior, core, interior)\n   - User overrides for individual junction resolutions\n\n3. Framing Segment Enrichment\n   - Reads core EXTEND / TRIM / midspan-split adjustments\n   - Computes ``framing_segments`` per wall (list of [u_start, u_end] pairs)\n   - Outputs enriched walls_json with segments for downstream consumption\n   - Original wall_length and base_curve data preserved untouched\n\n4. Debug Visualization\n   - Junction node points at intersection locations\n   - Wall edge lines from start to end point\n   - Uses RhinoCommonFactory for correct assembly output\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n\nDependencies:\n    - Rhino.Geometry: Point3d and LineCurve for debug visualization\n    - Grasshopper: Component framework and data structures\n    - json: Serialization of wall and junction data\n    - timber_framing_generator.wall_junctions: Junction analysis pipeline\n    - timber_framing_generator.wall_junctions.core_adjustment: Framing segments\n    - timber_framing_generator.utils.geometry_factory: RhinoCommonFactory\n\nPerformance Considerations:\n    - O(walls^2) for endpoint-matching during detection\n    - Typical residential models (< 50 walls) process in < 100ms\n    - JSON output size proportional to junction and adjustment count\n\nUsage:\n    1. Connect 'walls_json' from Wall Analyzer component\n    2. Optionally configure tolerance, join type, priority via 'config_json'\n    3. Set 'run' to True to execute\n    4. Connect 'junctions_json' to downstream framing/sheathing components\n    5. Connect 'walls_json_out' to Cell Decomposer (enriched with framing_segments)\n    6. View 'summary' for junction counts and resolution statistics\n\nInput Requirements:\n    Walls JSON (walls_json) - str:\n        JSON string from Wall Analyzer with wall geometry data.\n        Format: list of wall dicts with wall_id, wall_length, wall_thickness,\n        base_plane, base_curve_start, base_curve_end, is_exterior, etc.\n        Required: Yes\n        Access: Item\n        Type hint: str (set via GH UI)\n\n    Config JSON (config_json) - str:\n        Optional JSON configuration overrides:\n        - tolerance: float (default 0.1) endpoint matching tolerance in feet\n        - t_intersection_tolerance: float (default 0.15)\n        - default_join_type: \"butt\" or \"miter\" (default \"butt\")\n        - priority_strategy: \"longer_wall\", \"exterior_first\", \"alternate\"\n        - junction_overrides: dict of junction_id -> {join_type, primary_wall_id}\n        - layer_overrides: dict of wall_id -> {exterior_thickness, core_thickness, interior_thickness}\n        Required: No\n        Access: Item\n        Type hint: str (set via GH UI)\n\n    Run (run) - bool:\n        Boolean to trigger execution.\n        Required: Yes\n        Access: Item\n        Type hint: bool (set via GH UI)\n\nOutputs:\n    Junctions JSON (junctions_json) - str:\n        JSON string with junction graph, resolutions, and per-wall adjustments.\n\n    Graph Points (graph_pts) - List[Point3d]:\n        Junction node positions for debug visualization.\n\n    Graph Lines (graph_lines) - List[LineCurve]:\n        Wall edges (start to end) for debug visualization.\n\n    Walls JSON (walls_json_out) - str:\n        Enriched walls_json with ``framing_segments`` per wall. Each wall dict\n        gains a ``framing_segments`` key: a list of ``[u_start, u_end]`` pairs\n        defining effective framing runs. Original fields (wall_length,\n        base_curve_start/end) are preserved unchanged.\n\n    Summary (summary) - str:\n        Human-readable junction summary with counts and statistics.\n\n    Log (log) - str:\n        Processing log with debug information.\n\nTechnical Details:\n    - Junction detection uses endpoint proximity matching within tolerance\n    - T-intersections detected via perpendicular projection onto wall midspans\n    - Priority strategy determines which wall extends vs trims at butt joins\n    - All geometry output uses RhinoCommonFactory to avoid assembly mismatch\n    - Framing segments computed from core LayerAdjustments after junction resolution\n    - Default segment for walls with no core adjustments: [[0, wall_length]]\n\nError Handling:\n    - Invalid walls_json returns empty outputs with error in log\n    - Invalid config_json falls back to defaults with warning\n    - Individual wall processing failures do not halt the pipeline\n    - Empty wall list produces valid but empty junction graph\n    - Framing segment computation failure falls back to original walls_json\n\nAuthor: Fernando Maytorena\nVersion: 1.6.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\nimport time\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\n# Rhino / Grasshopper\nimport Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\n# =============================================================================\n# Project Setup\n# =============================================================================\n\n# Primary: worktree / feature-branch path (contains wall_junctions fixes, etc.)\n# Fallback: main repo path (for when this file is used from the main checkout)\n_WORKTREE_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\tfg-sheathing-junctions\"\n_MAIN_REPO_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator\"\n\n# =============================================================================\n# Force Module Reload (CPython 3 in Rhino 8)\n# =============================================================================\n\n# Clear timber_framing_generator modules AND the 'src' package itself.\n# Other GH components may have already imported 'src', caching its\n# __path__ to the main repo.  Clearing it forces Python to re-resolve\n# 'src' from the updated sys.path (worktree at index 0).\n_modules_to_clear = [k for k in sys.modules.keys()\n                     if 'timber_framing_generator' in k\n                     or k == 'src']\nfor mod in _modules_to_clear:\n    del sys.modules[mod]\n\n# Ensure worktree path has highest priority (index 0) in sys.path.\nfor _p in (_WORKTREE_PATH, _MAIN_REPO_PATH):\n    while _p in sys.path:\n        sys.path.remove(_p)\nsys.path.insert(0, _MAIN_REPO_PATH)\nsys.path.insert(0, _WORKTREE_PATH)\n\nfrom src.timber_framing_generator.wall_junctions import analyze_junctions\nfrom src.timber_framing_generator.wall_junctions.core_adjustment import (\n    compute_framing_segments,\n)\nfrom src.timber_framing_generator.utils.geometry_factory import get_factory\nfrom src.timber_framing_generator.config.assembly_resolver import (\n    resolve_all_walls,\n    summarize_resolutions,\n)\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Junction Analyzer\"\nCOMPONENT_NICKNAME = \"JnxAnl\"\nCOMPONENT_MESSAGE = \"v1.6-framing-seg\"\n\n# Version marker — confirms the updated script is running in GH\nprint(\"[JnxAnl] Script version v1.6-framing-seg loaded (worktree + assembly + framing_segments)\")\nCOMPONENT_CATEGORY = \"Timber Framing\"\nCOMPONENT_SUBCATEGORY = \"0-Analysis\"\n\nDEFAULT_CONFIG = {\n    \"tolerance\": 0.1,\n    \"t_intersection_tolerance\": 0.15,\n    \"default_join_type\": \"butt\",\n    \"priority_strategy\": \"longer_wall\",\n    \"junction_overrides\": {},\n    \"layer_overrides\": {},\n}\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message: str, level: str = \"info\") -> None:\n    \"\"\"Log to console and optionally add GH runtime message.\n\n    Args:\n        message: The message to log.\n        level: One of \"info\", \"debug\", \"warning\", \"error\", \"remark\".\n    \"\"\"\n    print(f\"[{level.upper()}] {message}\")\n\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n    elif level == \"remark\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Remark, message)\n\n\ndef log_debug(message: str) -> None:\n    \"\"\"Log debug message (console only).\"\"\"\n    print(f\"[DEBUG] {message}\")\n\n\ndef log_info(message: str) -> None:\n    \"\"\"Log info message (console only).\"\"\"\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message: str) -> None:\n    \"\"\"Log warning message (console + GH UI).\"\"\"\n    log_message(message, \"warning\")\n\n\ndef log_error(message: str) -> None:\n    \"\"\"Log error message (console + GH UI).\"\"\"\n    log_message(message, \"error\")\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component() -> None:\n    \"\"\"Initialize and configure the Grasshopper component.\n\n    Configures:\n    1. Component metadata (name, category, etc.)\n    2. Input parameter names, descriptions, and access\n    3. Output parameter names and descriptions\n\n    Note: Output[0] is reserved for GH's internal 'out' - start from Output[1]\n\n    IMPORTANT: Type Hints cannot be set programmatically in Rhino 8.\n    They must be configured via UI: Right-click input -> Type hint -> Select type.\n    Required type hints:\n        - walls_json: str\n        - config_json: str\n        - run: bool\n    \"\"\"\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs\n    # IMPORTANT: NickName becomes the Python variable name\n    inputs = ghenv.Component.Params.Input\n    input_config = [\n        (\"Walls JSON\", \"walls_json\",\n         \"JSON string from Wall Analyzer with wall geometry data\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Config JSON\", \"config_json\",\n         \"Optional JSON configuration (tolerance, join type, priority, overrides)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Run\", \"run\",\n         \"Boolean to trigger execution\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    # Configure outputs (start from index 1, as 0 is reserved for 'out')\n    outputs = ghenv.Component.Params.Output\n    output_config = [\n        (\"Junctions JSON\", \"junctions_json\",\n         \"JSON with junction graph, resolutions, and per-wall adjustments\"),\n        (\"Graph Points\", \"graph_pts\",\n         \"Junction node positions for debug visualization\"),\n        (\"Graph Lines\", \"graph_lines\",\n         \"Wall edges (start to end) for debug visualization\"),\n        (\"Walls JSON\", \"walls_json_out\",\n         \"Enriched walls_json with framing_segments per wall\"),\n        (\"Summary\", \"summary\",\n         \"Human-readable junction summary\"),\n        (\"Log\", \"log\",\n         \"Processing log with debug information\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1  # Skip Output[0]\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef validate_inputs(\n    walls_json_input: str,\n    run_input: bool,\n) -> tuple:\n    \"\"\"Validate component inputs.\n\n    Args:\n        walls_json_input: JSON string with wall data.\n        run_input: Boolean trigger.\n\n    Returns:\n        tuple: (is_valid, error_message)\n    \"\"\"\n    if not run_input:\n        return False, \"Component not running. Set 'run' to True.\"\n\n    if not walls_json_input or not isinstance(walls_json_input, str):\n        return False, \"walls_json is required\"\n\n    if not walls_json_input.strip():\n        return False, \"walls_json is empty\"\n\n    # Validate JSON is parsable\n    try:\n        data = json.loads(walls_json_input)\n    except json.JSONDecodeError as e:\n        return False, f\"Invalid JSON in walls_json: {e}\"\n\n    # Validate we have walls\n    if isinstance(data, dict):\n        walls = data.get(\"walls\", [])\n    elif isinstance(data, list):\n        walls = data\n    else:\n        return False, \"walls_json must be a dict or list\"\n\n    if not walls:\n        return False, \"walls_json contains no walls\"\n\n    return True, None\n\n\ndef parse_config(config_json_input: str) -> dict:\n    \"\"\"Parse configuration JSON with defaults.\n\n    Args:\n        config_json_input: Optional JSON string with config overrides.\n\n    Returns:\n        dict: Merged configuration with defaults.\n    \"\"\"\n    config = dict(DEFAULT_CONFIG)\n\n    if config_json_input and isinstance(config_json_input, str) and config_json_input.strip():\n        try:\n            user_config = json.loads(config_json_input)\n            if isinstance(user_config, dict):\n                config.update(user_config)\n                log_info(f\"Applied user config: {list(user_config.keys())}\")\n            else:\n                log_warning(\"config_json must be a JSON object, using defaults\")\n        except json.JSONDecodeError as e:\n            log_warning(f\"Invalid config_json, using defaults: {e}\")\n\n    # Validate join type\n    valid_join_types = (\"butt\", \"miter\")\n    if config[\"default_join_type\"] not in valid_join_types:\n        log_warning(\n            f\"Unknown default_join_type '{config['default_join_type']}', \"\n            f\"using 'butt'. Valid: {valid_join_types}\"\n        )\n        config[\"default_join_type\"] = \"butt\"\n\n    # Validate priority strategy\n    valid_strategies = (\"longer_wall\", \"exterior_first\", \"alternate\")\n    if config[\"priority_strategy\"] not in valid_strategies:\n        log_warning(\n            f\"Unknown priority_strategy '{config['priority_strategy']}', \"\n            f\"using 'longer_wall'. Valid: {valid_strategies}\"\n        )\n        config[\"priority_strategy\"] = \"longer_wall\"\n\n    # Validate tolerance values are positive\n    for key in (\"tolerance\", \"t_intersection_tolerance\"):\n        if not isinstance(config.get(key), (int, float)) or config[key] <= 0:\n            log_warning(f\"Invalid {key}={config.get(key)}, using default\")\n            config[key] = DEFAULT_CONFIG[key]\n\n    return config\n\n\ndef parse_walls(walls_json_str: str) -> list:\n    \"\"\"Parse walls from JSON string.\n\n    Handles both dict-with-key and bare-list formats.\n    The z_axis in walls_json is set by the Wall Analyzer using Revit's\n    ``wall.Orientation`` property — the geometric exterior normal that\n    does NOT change when the wall is flipped.  No flip correction is\n    needed here; +z_axis already = building-layout exterior direction.\n\n    Args:\n        walls_json_str: JSON string with wall data.\n\n    Returns:\n        List of wall dicts.\n    \"\"\"\n    data = json.loads(walls_json_str)\n    if isinstance(data, dict):\n        walls = data.get(\"walls\", [])\n    elif isinstance(data, list):\n        walls = data\n    else:\n        walls = []\n    return walls\n\n\ndef create_debug_geometry(graph, walls_data: list) -> tuple:\n    \"\"\"Create debug visualization geometry from junction graph and wall data.\n\n    For each junction node, creates a Point3d at the node position.\n    For each wall, creates a LineCurve from start to end point.\n\n    All geometry is created via RhinoCommonFactory to avoid assembly mismatch.\n\n    Args:\n        graph: JunctionGraph with nodes and resolutions.\n        walls_data: List of wall dicts for wall edge geometry.\n\n    Returns:\n        tuple: (graph_pts, graph_lines) - lists of Point3d and LineCurve.\n    \"\"\"\n    factory = get_factory()\n    graph_pts = []\n    graph_lines = []\n\n    # Junction node points\n    for node in graph.nodes.values():\n        try:\n            pos = node.position\n            pt = factory.create_point3d(\n                float(pos[0]), float(pos[1]), float(pos[2])\n            )\n            if pt is not None:\n                graph_pts.append(pt)\n        except Exception as e:\n            log_debug(f\"Failed to create point for junction {node.id}: {e}\")\n\n    # Wall edge lines (start to end)\n    for wall in walls_data:\n        try:\n            # Extract start/end points from wall data\n            start = _extract_point(wall, \"base_curve_start\")\n            end = _extract_point(wall, \"base_curve_end\")\n\n            if start is not None and end is not None:\n                line_curve = factory.create_line_curve(start, end)\n                if line_curve is not None:\n                    graph_lines.append(line_curve)\n        except Exception as e:\n            wall_id = wall.get(\"wall_id\", \"unknown\")\n            log_debug(f\"Failed to create line for wall {wall_id}: {e}\")\n\n    return graph_pts, graph_lines\n\n\ndef _extract_point(wall: dict, key: str) -> tuple:\n    \"\"\"Extract a (x, y, z) tuple from wall data for a given key.\n\n    Handles both flat dict format {\"x\": ..., \"y\": ..., \"z\": ...} and\n    the WallData schema format.\n\n    Args:\n        wall: Wall dict from walls_json.\n        key: Key name (e.g., \"base_curve_start\", \"base_curve_end\").\n\n    Returns:\n        (x, y, z) tuple of floats, or None if not found.\n    \"\"\"\n    pt_data = wall.get(key)\n    if pt_data is None:\n        return None\n\n    if isinstance(pt_data, dict):\n        x = float(pt_data.get(\"x\", 0))\n        y = float(pt_data.get(\"y\", 0))\n        z = float(pt_data.get(\"z\", 0))\n        return (x, y, z)\n\n    if isinstance(pt_data, (list, tuple)) and len(pt_data) >= 3:\n        return (float(pt_data[0]), float(pt_data[1]), float(pt_data[2]))\n\n    return None\n\n\ndef build_summary_text(graph, walls_data: list = None) -> str:\n    \"\"\"Build a human-readable summary string from the junction graph.\n\n    Includes detailed diagnostics for each junction: endpoint positions,\n    distances, assembly layers detected, and resulting adjustments.\n\n    Args:\n        graph: JunctionGraph with nodes, resolutions, and adjustments.\n        walls_data: Optional wall data list for assembly inspection.\n\n    Returns:\n        Formatted summary string.\n    \"\"\"\n    import math\n\n    stats = graph._build_summary()\n\n    ext_c = stats.get('exterior_corners', 0)\n    int_c = stats.get('interior_corners', 0)\n    l_detail = f\"  ({ext_c} exterior, {int_c} interior)\" if (ext_c + int_c) > 0 else \"\"\n\n    lines = [\n        \"=== Junction Analysis Summary (v1.2) ===\",\n        \"\",\n        f\"Total Junctions: {stats['total_junctions']}\",\n        f\"  L-Corners:        {stats['l_corners']}{l_detail}\",\n        f\"  T-Intersections:  {stats['t_intersections']}\",\n        f\"  X-Crossings:      {stats['x_crossings']}\",\n        f\"  Free Ends:        {stats['free_ends']}\",\n        f\"  Inline:           {stats['inline']}\",\n        f\"  Multi-Way:        {stats['multi_way']}\",\n        \"\",\n        f\"Resolutions: {stats['total_resolutions']}\",\n        f\"User Overrides Applied: {stats['user_overrides_applied']}\",\n        f\"Walls with Adjustments: {len(graph.wall_adjustments)}\",\n    ]\n\n    # Build wall assembly lookup for diagnostics\n    wall_assembly_map = {}\n    if walls_data:\n        for w in walls_data:\n            wid = w.get(\"wall_id\", \"\")\n            wall_assembly_map[wid] = w.get(\"wall_assembly\")\n\n    # Detailed junction diagnostics\n    lines.append(\"\")\n    lines.append(\"=== JUNCTION DETAILS ===\")\n    for node in graph.nodes.values():\n        pos = node.position\n        lines.append(\n            f\"\\n[{node.id}] type={node.junction_type.value} \"\n            f\"pos=({pos[0]:.4f}, {pos[1]:.4f}, {pos[2]:.4f})\"\n        )\n\n        # Show each connection\n        for i, conn in enumerate(node.connections):\n            lines.append(\n                f\"  conn[{i}]: wall={conn.wall_id} end={conn.end} \"\n                f\"thick={conn.wall_thickness:.4f} len={conn.wall_length:.4f} \"\n                f\"dir=({conn.direction[0]:.3f},{conn.direction[1]:.3f},{conn.direction[2]:.3f}) \"\n                f\"midspan={conn.is_midspan}\"\n            )\n\n        # Show pairwise endpoint distances\n        if len(node.connections) >= 2:\n            for i in range(len(node.connections)):\n                for j in range(i + 1, len(node.connections)):\n                    ci = node.connections[i]\n                    cj = node.connections[j]\n                    # Distance is not directly available; we log junction-level info\n                    lines.append(\n                        f\"  pair: {ci.wall_id}/{ci.end} <-> \"\n                        f\"{cj.wall_id}/{cj.end} \"\n                        f\"thick_sum/2={(ci.wall_thickness + cj.wall_thickness)/2:.4f}\"\n                    )\n\n        # Show assembly layers for each wall in this junction\n        for conn in node.connections:\n            assembly = wall_assembly_map.get(conn.wall_id)\n            if assembly and assembly.get(\"layers\"):\n                al_lines = []\n                for al in assembly[\"layers\"]:\n                    al_lines.append(\n                        f\"{al.get('name','?')} \"\n                        f\"[{al.get('side','?')}/{al.get('function','?')}] \"\n                        f\"t={al.get('thickness',0):.4f}\"\n                    )\n                lines.append(\n                    f\"  assembly({conn.wall_id}): {len(assembly['layers'])} layers\"\n                )\n                for al_line in al_lines:\n                    lines.append(f\"    {al_line}\")\n            else:\n                lines.append(\n                    f\"  assembly({conn.wall_id}): NONE (will use fallback)\"\n                )\n\n    # Detailed resolution diagnostics\n    lines.append(\"\")\n    lines.append(\"=== RESOLUTION DETAILS ===\")\n    for res in graph.resolutions:\n        lines.append(\n            f\"\\n[{res.junction_id}] join={res.join_type.value} \"\n            f\"primary={res.primary_wall_id} secondary={res.secondary_wall_id} \"\n            f\"conf={res.confidence:.2f}\"\n        )\n        lines.append(f\"  reason: {res.reason}\")\n        lines.append(f\"  adjustments ({len(res.layer_adjustments)}):\")\n        for adj in res.layer_adjustments:\n            lines.append(\n                f\"    wall={adj.wall_id} end={adj.end} \"\n                f\"layer={adj.layer_name} \"\n                f\"{adj.adjustment_type.value} amount={adj.amount:.6f} ft \"\n                f\"({adj.amount * 12:.4f} in) \"\n                f\"vs_wall={adj.connecting_wall_id}\"\n            )\n\n    # Per-wall adjustment summary\n    if graph.wall_adjustments:\n        lines.append(\"\")\n        lines.append(\"=== PER-WALL ADJUSTMENTS ===\")\n        for wall_id, adjs in sorted(graph.wall_adjustments.items()):\n            lines.append(f\"\\nWall {wall_id}: {len(adjs)} adjustments\")\n            for adj in adjs:\n                lines.append(\n                    f\"  {adj.layer_name}/{adj.end}: \"\n                    f\"{adj.adjustment_type.value} {adj.amount:.6f} ft \"\n                    f\"({adj.amount * 12:.4f} in)\"\n                )\n\n    # ==================================================================\n    # WALL GEOMETRY DIAGNOSTIC (in summary so it's always visible)\n    # ==================================================================\n    if walls_data:\n        lines.append(\"\")\n        lines.append(\"=== WALL GEOMETRY DIAGNOSTIC ===\")\n        lines.append(\"ASSUMPTIONS:\")\n        lines.append(\"  - base_curve_start/end = Revit centerline endpoints (wall.Location.Curve)\")\n        lines.append(\"  - z_axis = Revit wall.Orientation (geometric exterior normal, flip-independent)\")\n        lines.append(\"  - x_axis = wall U direction (start -> end)\")\n        lines.append(\"  - Walls with 'Disallow Join': endpoints manually placed\")\n        lines.append(\"  - Primary wall may extend past virtual corner\")\n        lines.append(\"  - Secondary wall may be trimmed back from virtual corner\")\n        lines.append(\"\")\n\n        for w in walls_data:\n            wid = w.get(\"wall_id\", \"?\")\n            wt = w.get(\"wall_thickness\", 0)\n            wl = w.get(\"wall_length\", 0)\n            is_flipped = w.get(\"is_flipped\", False)\n            s = w.get(\"base_curve_start\", {})\n            e = w.get(\"base_curve_end\", {})\n            sx, sy, sz = s.get(\"x\", 0), s.get(\"y\", 0), s.get(\"z\", 0)\n            ex, ey, ez = e.get(\"x\", 0), e.get(\"y\", 0), e.get(\"z\", 0)\n            bp = w.get(\"base_plane\", {})\n            xax = bp.get(\"x_axis\", {})\n            zax = bp.get(\"z_axis\", {})\n            wa = w.get(\"wall_assembly\")\n            has_asm = \"YES\" if (wa and wa.get(\"layers\")) else \"NO\"\n            asm_name = wa.get(\"name\", \"?\") if wa else \"NONE\"\n            asm_count = len(wa.get(\"layers\", [])) if wa else 0\n\n            lines.append(f\"  Wall {wid}: thick={wt:.4f} ft ({wt*12:.2f} in) len={wl:.4f} ft\")\n            lines.append(f\"    is_flipped={is_flipped}\")\n            lines.append(f\"    centerline_start=({sx:.6f}, {sy:.6f}, {sz:.6f})\")\n            lines.append(f\"    centerline_end  =({ex:.6f}, {ey:.6f}, {ez:.6f})\")\n            lines.append(\n                f\"    x_axis (U-dir)=({xax.get('x',0):.6f}, {xax.get('y',0):.6f}, {xax.get('z',0):.6f})\"\n            )\n            lines.append(\n                f\"    z_axis (wall.Orientation)=({zax.get('x',0):.6f}, {zax.get('y',0):.6f}, {zax.get('z',0):.6f})\"\n            )\n            lines.append(f\"    +z_axis direction = what code labels 'exterior' face\")\n            lines.append(f\"    -z_axis direction = what code labels 'interior' face\")\n            lines.append(f\"    assembly={has_asm} name='{asm_name}' ({asm_count} layers)\")\n            if wa and wa.get(\"layers\"):\n                for al in wa[\"layers\"]:\n                    lines.append(\n                        f\"      {al.get('name','?')} side={al.get('side','?')} \"\n                        f\"func={al.get('function','?')} \"\n                        f\"thick={al.get('thickness',0):.6f} ft ({al.get('thickness',0)*12:.4f} in)\"\n                    )\n            lines.append(\"\")\n\n        # Pairwise endpoint distances\n        lines.append(\"=== PAIRWISE ENDPOINT DISTANCES ===\")\n        for i in range(len(walls_data)):\n            for j in range(i + 1, len(walls_data)):\n                wi = walls_data[i]\n                wj = walls_data[j]\n                for ei_name in (\"start\", \"end\"):\n                    for ej_name in (\"start\", \"end\"):\n                        pi = wi.get(f\"base_curve_{ei_name}\", {})\n                        pj = wj.get(f\"base_curve_{ej_name}\", {})\n                        dx = pi.get(\"x\", 0) - pj.get(\"x\", 0)\n                        dy = pi.get(\"y\", 0) - pj.get(\"y\", 0)\n                        dz = pi.get(\"z\", 0) - pj.get(\"z\", 0)\n                        dist = math.sqrt(dx*dx + dy*dy + dz*dz)\n                        ti = wi.get(\"wall_thickness\", 0)\n                        tj = wj.get(\"wall_thickness\", 0)\n                        pair_tol = max(0.1, (ti + tj) / 2.0)\n                        match_str = \"MATCH\" if dist <= pair_tol else \"no match\"\n                        lines.append(\n                            f\"  {wi.get('wall_id','?')}/{ei_name} <-> \"\n                            f\"{wj.get('wall_id','?')}/{ej_name}: \"\n                            f\"dist={dist:.6f} ft ({dist*12:.4f} in) \"\n                            f\"tol={pair_tol:.4f} -> {match_str}\"\n                        )\n\n        # Virtual centerline intersection\n        lines.append(\"\")\n        lines.append(\"=== VIRTUAL CENTERLINE INTERSECTION ===\")\n        lines.append(\"Where wall centerlines would cross if extended infinitely\")\n        lines.append(\"This is the reference point adjustments SHOULD be measured from\")\n\n        for i in range(len(walls_data)):\n            for j in range(i + 1, len(walls_data)):\n                wi = walls_data[i]\n                wj = walls_data[j]\n                wid_i = wi.get(\"wall_id\", \"?\")\n                wid_j = wj.get(\"wall_id\", \"?\")\n\n                si = wi.get(\"base_curve_start\", {})\n                bp_i = wi.get(\"base_plane\", {})\n                xax_i = bp_i.get(\"x_axis\", {})\n                p_i = (si.get(\"x\", 0), si.get(\"y\", 0))\n                d_i = (xax_i.get(\"x\", 0), xax_i.get(\"y\", 0))\n\n                sj = wj.get(\"base_curve_start\", {})\n                bp_j = wj.get(\"base_plane\", {})\n                xax_j = bp_j.get(\"x_axis\", {})\n                p_j = (sj.get(\"x\", 0), sj.get(\"y\", 0))\n                d_j = (xax_j.get(\"x\", 0), xax_j.get(\"y\", 0))\n\n                det = d_i[0] * (-d_j[1]) - d_i[1] * (-d_j[0])\n                if abs(det) < 1e-10:\n                    lines.append(f\"  {wid_i} x {wid_j}: PARALLEL (no intersection)\")\n                    continue\n\n                rhs_x = p_j[0] - p_i[0]\n                rhs_y = p_j[1] - p_i[1]\n                t_i = (rhs_x * (-d_j[1]) - rhs_y * (-d_j[0])) / det\n                t_j = (d_i[0] * rhs_y - d_i[1] * rhs_x) / det\n\n                vx = p_i[0] + t_i * d_i[0]\n                vy = p_i[1] + t_i * d_i[1]\n\n                lines.append(f\"  {wid_i} x {wid_j}: virtual_corner=({vx:.6f}, {vy:.6f})\")\n                lines.append(f\"    t_i={t_i:.6f} ft along {wid_i} (U-param from start)\")\n                lines.append(f\"    t_j={t_j:.6f} ft along {wid_j} (U-param from start)\")\n\n                len_i = wi.get(\"wall_length\", 0)\n                len_j = wj.get(\"wall_length\", 0)\n\n                for ep_name in (\"start\", \"end\"):\n                    ep_u = 0.0 if ep_name == \"start\" else len_i\n                    offset = ep_u - t_i\n                    label = \"[PAST corner]\" if offset > 0.01 else \"[BEFORE corner]\" if offset < -0.01 else \"[AT corner]\"\n                    lines.append(\n                        f\"    {wid_i}/{ep_name}: ep_u={ep_u:.6f}, virtual_u={t_i:.6f}, \"\n                        f\"offset={offset:.6f} ft ({offset*12:.4f} in) {label}\"\n                    )\n\n                for ep_name in (\"start\", \"end\"):\n                    ep_u = 0.0 if ep_name == \"start\" else len_j\n                    offset = ep_u - t_j\n                    label = \"[PAST corner]\" if offset > 0.01 else \"[BEFORE corner]\" if offset < -0.01 else \"[AT corner]\"\n                    lines.append(\n                        f\"    {wid_j}/{ep_name}: ep_u={ep_u:.6f}, virtual_u={t_j:.6f}, \"\n                        f\"offset={offset:.6f} ft ({offset*12:.4f} in) {label}\"\n                    )\n\n    return \"\\n\".join(lines)\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main(\n    walls_json_input: str,\n    config_json_input: str,\n    run_input: bool,\n) -> tuple:\n    \"\"\"Main entry point for the component.\n\n    Coordinates the overall workflow:\n    1. Setup component metadata\n    2. Validate inputs\n    3. Parse configuration and walls\n    4. Run junction analysis pipeline\n    5. Create debug visualization geometry\n    6. Return results\n\n    Args:\n        walls_json_input: JSON string from Wall Analyzer.\n        config_json_input: Optional configuration JSON.\n        run_input: Boolean trigger.\n\n    Returns:\n        tuple: (junctions_json, graph_pts, graph_lines, walls_json_out, summary, log)\n    \"\"\"\n    setup_component()\n\n    # Initialize outputs with safe defaults\n    junctions_json = \"\"\n    graph_pts = []\n    graph_lines = []\n    summary_text = \"\"\n    log_lines = []\n    walls_json_out = \"\"\n\n    try:\n        # Validate inputs\n        is_valid, error_msg = validate_inputs(walls_json_input, run_input)\n        if not is_valid:\n            if error_msg and \"not running\" not in error_msg.lower():\n                log_warning(error_msg)\n            log_lines.append(error_msg or \"Validation failed\")\n            return junctions_json, graph_pts, graph_lines, walls_json_out, summary_text, \"\\n\".join(log_lines)\n\n        log_lines.append(\"Junction Analyzer v1.1-diag\")\n        log_lines.append(\"Inputs validated successfully\")\n\n        # Parse configuration\n        config = parse_config(config_json_input)\n        log_lines.append(\n            f\"Config: join_type={config['default_join_type']}, \"\n            f\"priority={config['priority_strategy']}, \"\n            f\"tolerance={config['tolerance']}\"\n        )\n\n        # Parse walls\n        start_time = time.time()\n        walls_data = parse_walls(walls_json_input)\n        log_lines.append(f\"Parsed {len(walls_data)} walls\")\n\n        # Resolve assemblies so analyze_junctions() has real layer\n        # thicknesses for per-layer cumulative adjustments.\n        try:\n            walls_data = resolve_all_walls(walls_data, mode=\"auto\")\n            res_summary = summarize_resolutions(walls_data)\n            log_lines.append(\n                f\"Assembly resolution: {res_summary['by_source']} \"\n                f\"(avg conf {res_summary['average_confidence']:.2f})\"\n            )\n        except Exception as e:\n            log_warning(f\"Assembly resolution failed: {e}\")\n            log_lines.append(f\"Assembly resolution failed: {e} (using raw wall data)\")\n\n        # ==================================================================\n        # DIAGNOSTIC: Wall geometry, z_axis, flip state, face assignment\n        # ==================================================================\n        log_lines.append(\"\")\n        log_lines.append(\"=== WALL GEOMETRY DIAGNOSTIC ===\")\n        log_lines.append(\"ASSUMPTIONS:\")\n        log_lines.append(\"  - base_curve_start/end are Revit centerline endpoints (wall.Location.Curve)\")\n        log_lines.append(\"  - z_axis = wall normal direction\")\n        log_lines.append(\"  - z_axis = Revit wall.Orientation (geometric exterior normal, flip-independent)\")\n        log_lines.append(\"  - x_axis = wall U direction (start → end)\")\n        log_lines.append(\"  - Walls may have 'Disallow Join' → endpoints manually placed\")\n        log_lines.append(\"  - Primary wall may already extend past virtual corner\")\n        log_lines.append(\"  - Secondary wall may already be trimmed back from virtual corner\")\n        log_lines.append(\"\")\n\n        for w in walls_data:\n            wid = w.get(\"wall_id\", \"?\")\n            wt = w.get(\"wall_thickness\", 0)\n            wl = w.get(\"wall_length\", 0)\n            is_flipped = w.get(\"is_flipped\", False)\n            s = w.get(\"base_curve_start\", {})\n            e = w.get(\"base_curve_end\", {})\n            sx, sy, sz = s.get(\"x\", 0), s.get(\"y\", 0), s.get(\"z\", 0)\n            ex, ey, ez = e.get(\"x\", 0), e.get(\"y\", 0), e.get(\"z\", 0)\n            bp = w.get(\"base_plane\", {})\n            xax = bp.get(\"x_axis\", {})\n            zax = bp.get(\"z_axis\", {})\n            wa = w.get(\"wall_assembly\")\n            has_asm = \"YES\" if (wa and wa.get(\"layers\")) else \"NO\"\n            asm_count = len(wa.get(\"layers\", [])) if wa else 0\n\n            log_lines.append(\n                f\"  Wall {wid}: thick={wt:.4f} ft ({wt*12:.2f} in) len={wl:.4f} ft\"\n            )\n            log_lines.append(\n                f\"    is_flipped={is_flipped}\"\n            )\n            log_lines.append(\n                f\"    centerline_start=({sx:.6f}, {sy:.6f}, {sz:.6f})\"\n            )\n            log_lines.append(\n                f\"    centerline_end  =({ex:.6f}, {ey:.6f}, {ez:.6f})\"\n            )\n            log_lines.append(\n                f\"    x_axis (U-dir)=({xax.get('x',0):.6f}, {xax.get('y',0):.6f}, {xax.get('z',0):.6f})\"\n            )\n            log_lines.append(\n                f\"    z_axis (wall.Orientation)=({zax.get('x',0):.6f}, {zax.get('y',0):.6f}, {zax.get('z',0):.6f})\"\n            )\n            # Determine what our code considers \"exterior\" vs \"interior\"\n            log_lines.append(\n                f\"    +z_axis direction = what code labels 'exterior' face\"\n            )\n            log_lines.append(\n                f\"    -z_axis direction = what code labels 'interior' face\"\n            )\n            log_lines.append(\n                f\"    assembly={has_asm} ({asm_count} layers)\"\n            )\n            if wa and wa.get(\"layers\"):\n                for al in wa[\"layers\"]:\n                    log_lines.append(\n                        f\"      layer: {al.get('name','?')} \"\n                        f\"side={al.get('side','?')} \"\n                        f\"func={al.get('function','?')} \"\n                        f\"thick={al.get('thickness',0):.6f} ft ({al.get('thickness',0)*12:.4f} in)\"\n                    )\n\n        # ==================================================================\n        # DIAGNOSTIC: Pairwise endpoint distances + virtual corner\n        # ==================================================================\n        import math as _math\n        log_lines.append(\"\")\n        log_lines.append(\"=== PAIRWISE ENDPOINT DISTANCES ===\")\n\n        for i in range(len(walls_data)):\n            for j in range(i + 1, len(walls_data)):\n                wi = walls_data[i]\n                wj = walls_data[j]\n                for ei_name in (\"start\", \"end\"):\n                    for ej_name in (\"start\", \"end\"):\n                        pi = wi.get(f\"base_curve_{ei_name}\", {})\n                        pj = wj.get(f\"base_curve_{ej_name}\", {})\n                        dx = pi.get(\"x\", 0) - pj.get(\"x\", 0)\n                        dy = pi.get(\"y\", 0) - pj.get(\"y\", 0)\n                        dz = pi.get(\"z\", 0) - pj.get(\"z\", 0)\n                        dist = _math.sqrt(dx*dx + dy*dy + dz*dz)\n                        ti = wi.get(\"wall_thickness\", 0)\n                        tj = wj.get(\"wall_thickness\", 0)\n                        pair_tol = max(config[\"tolerance\"], (ti + tj) / 2.0)\n                        match = \"MATCH\" if dist <= pair_tol else \"no match\"\n                        log_lines.append(\n                            f\"  dist {wi.get('wall_id','?')}/{ei_name} <-> \"\n                            f\"{wj.get('wall_id','?')}/{ej_name}: \"\n                            f\"{dist:.6f} ft ({dist*12:.4f} in) \"\n                            f\"pair_tol={pair_tol:.4f} -> {match}\"\n                        )\n\n        # Virtual centerline intersection computation\n        log_lines.append(\"\")\n        log_lines.append(\"=== VIRTUAL CENTERLINE INTERSECTION ===\")\n        log_lines.append(\"Computes where wall centerlines would cross if extended infinitely\")\n        log_lines.append(\"This is the reference point adjustments SHOULD be measured from\")\n\n        for i in range(len(walls_data)):\n            for j in range(i + 1, len(walls_data)):\n                wi = walls_data[i]\n                wj = walls_data[j]\n                wid_i = wi.get(\"wall_id\", \"?\")\n                wid_j = wj.get(\"wall_id\", \"?\")\n\n                # Wall i: line from start_i in direction x_axis_i\n                si = wi.get(\"base_curve_start\", {})\n                bp_i = wi.get(\"base_plane\", {})\n                xax_i = bp_i.get(\"x_axis\", {})\n                p_i = (si.get(\"x\", 0), si.get(\"y\", 0))\n                d_i = (xax_i.get(\"x\", 0), xax_i.get(\"y\", 0))\n\n                # Wall j: line from start_j in direction x_axis_j\n                sj = wj.get(\"base_curve_start\", {})\n                bp_j = wj.get(\"base_plane\", {})\n                xax_j = bp_j.get(\"x_axis\", {})\n                p_j = (sj.get(\"x\", 0), sj.get(\"y\", 0))\n                d_j = (xax_j.get(\"x\", 0), xax_j.get(\"y\", 0))\n\n                # 2D line-line intersection: p_i + t*d_i = p_j + s*d_j\n                # Solve: t*d_i.x - s*d_j.x = p_j.x - p_i.x\n                #        t*d_i.y - s*d_j.y = p_j.y - p_i.y\n                det = d_i[0] * (-d_j[1]) - d_i[1] * (-d_j[0])\n                if abs(det) < 1e-10:\n                    log_lines.append(\n                        f\"  {wid_i} x {wid_j}: PARALLEL (det={det:.10f}), no intersection\"\n                    )\n                    continue\n\n                rhs_x = p_j[0] - p_i[0]\n                rhs_y = p_j[1] - p_i[1]\n                t_i = (rhs_x * (-d_j[1]) - rhs_y * (-d_j[0])) / det\n                t_j = (d_i[0] * rhs_y - d_i[1] * rhs_x) / det\n\n                # Virtual intersection point\n                vx = p_i[0] + t_i * d_i[0]\n                vy = p_i[1] + t_i * d_i[1]\n\n                log_lines.append(\n                    f\"  {wid_i} x {wid_j}: virtual_corner=({vx:.6f}, {vy:.6f})\"\n                )\n                log_lines.append(\n                    f\"    t_i={t_i:.6f} ft along {wid_i} (U-param from start)\"\n                )\n                log_lines.append(\n                    f\"    t_j={t_j:.6f} ft along {wid_j} (U-param from start)\"\n                )\n\n                # Compare with wall lengths and endpoints\n                len_i = wi.get(\"wall_length\", 0)\n                len_j = wj.get(\"wall_length\", 0)\n\n                # Wall i: how far is each endpoint from virtual corner?\n                for ep_name in (\"start\", \"end\"):\n                    ep = wi.get(f\"base_curve_{ep_name}\", {})\n                    ep_u = 0.0 if ep_name == \"start\" else len_i\n                    offset = ep_u - t_i  # positive = endpoint past virtual corner\n                    log_lines.append(\n                        f\"    {wid_i}/{ep_name}: ep_u={ep_u:.6f}, virtual_u={t_i:.6f}, \"\n                        f\"offset={offset:.6f} ft ({offset*12:.4f} in) \"\n                        f\"{'[PAST corner]' if offset > 0.01 else '[BEFORE corner]' if offset < -0.01 else '[AT corner]'}\"\n                    )\n\n                # Wall j: how far is each endpoint from virtual corner?\n                for ep_name in (\"start\", \"end\"):\n                    ep = wj.get(f\"base_curve_{ep_name}\", {})\n                    ep_u = 0.0 if ep_name == \"start\" else len_j\n                    offset = ep_u - t_j\n                    log_lines.append(\n                        f\"    {wid_j}/{ep_name}: ep_u={ep_u:.6f}, virtual_u={t_j:.6f}, \"\n                        f\"offset={offset:.6f} ft ({offset*12:.4f} in) \"\n                        f\"{'[PAST corner]' if offset > 0.01 else '[BEFORE corner]' if offset < -0.01 else '[AT corner]'}\"\n                    )\n\n        # Run junction analysis pipeline\n        graph = analyze_junctions(\n            walls_data,\n            tolerance=config[\"tolerance\"],\n            t_intersection_tolerance=config[\"t_intersection_tolerance\"],\n            default_join_type=config[\"default_join_type\"],\n            priority_strategy=config[\"priority_strategy\"],\n            user_overrides=config.get(\"junction_overrides\") or None,\n            layer_overrides=config.get(\"layer_overrides\") or None,\n        )\n\n        elapsed_ms = (time.time() - start_time) * 1000\n        log_lines.append(f\"Analysis completed in {elapsed_ms:.1f}ms\")\n\n        # Serialize result to JSON\n        graph_dict = graph.to_dict()\n        junctions_json = json.dumps(graph_dict, indent=2)\n\n        # Enrich walls with framing_segments from core adjustments\n        try:\n            enriched_walls = compute_framing_segments(graph_dict, walls_data)\n            walls_json_out = json.dumps(enriched_walls, indent=2)\n            seg_count = sum(\n                len(w.get(\"framing_segments\", []))\n                for w in enriched_walls\n            )\n            multi_seg = sum(\n                1 for w in enriched_walls\n                if len(w.get(\"framing_segments\", [])) > 1\n            )\n            log_lines.append(\n                f\"Framing segments: {seg_count} segments across \"\n                f\"{len(enriched_walls)} walls ({multi_seg} multi-segment)\"\n            )\n        except Exception as e:\n            log_warning(f\"Framing segment computation failed: {e}\")\n            log_lines.append(f\"Framing segments FAILED: {e}\")\n            # Fallback: pass through original walls_json unchanged\n            walls_json_out = json.dumps(walls_data, indent=2)\n\n        # Build summary (pass walls_data for assembly inspection)\n        summary_text = build_summary_text(graph, walls_data)\n\n        # Create debug visualization geometry\n        graph_pts, graph_lines = create_debug_geometry(graph, walls_data)\n        log_lines.append(\n            f\"Debug geometry: {len(graph_pts)} junction points, \"\n            f\"{len(graph_lines)} wall lines\"\n        )\n\n        # Log summary stats\n        stats = graph_dict.get(\"summary\", {})\n        log_lines.append(\"\")\n        log_lines.append(\"=== RESULTS ===\")\n        log_lines.append(f\"Junctions found: {stats.get('total_junctions', 0)}\")\n        ext_c = stats.get('exterior_corners', 0)\n        int_c = stats.get('interior_corners', 0)\n        l_detail = f\" ({ext_c} exterior, {int_c} interior)\" if (ext_c + int_c) > 0 else \"\"\n        log_lines.append(f\"  L-Corners: {stats.get('l_corners', 0)}{l_detail}\")\n        log_lines.append(f\"  T-Intersections: {stats.get('t_intersections', 0)}\")\n        log_lines.append(f\"  X-Crossings: {stats.get('x_crossings', 0)}\")\n        log_lines.append(f\"  Free Ends: {stats.get('free_ends', 0)}\")\n        log_lines.append(f\"Resolutions: {stats.get('total_resolutions', 0)}\")\n        log_lines.append(f\"Walls with adjustments: {len(graph.wall_adjustments)}\")\n\n        total_adjustments = sum(\n            len(adjs) for adjs in graph.wall_adjustments.values()\n        )\n        log_lines.append(f\"Total layer adjustments: {total_adjustments}\")\n\n        if stats.get(\"user_overrides_applied\", 0) > 0:\n            log_lines.append(\n                f\"User overrides applied: {stats['user_overrides_applied']}\"\n            )\n\n    except ImportError as e:\n        log_error(f\"Import error: {e}\")\n        log_lines.append(f\"Import error: {e}\")\n        log_lines.append(\"Ensure timber_framing_generator is installed and on sys.path\")\n        log_lines.append(traceback.format_exc())\n    except json.JSONDecodeError as e:\n        log_error(f\"JSON parse error: {e}\")\n        log_lines.append(f\"JSON parse error: {e}\")\n    except Exception as e:\n        log_error(f\"Unexpected error: {str(e)}\")\n        log_lines.append(f\"Error: {type(e).__name__}: {e}\")\n        log_lines.append(traceback.format_exc())\n\n    return junctions_json, graph_pts, graph_lines, walls_json_out, summary_text, \"\\n\".join(log_lines)\n\n# =============================================================================\n# Execution\n# =============================================================================\n\n# Resolve GH global inputs with safe defaults.\n# In GHPython, input variables are injected as globals based on NickName.\n# NOTE: After pasting this script, you may need to:\n#   1. Set the correct number of inputs (3) and outputs (7, including 'out')\n#   2. Right-click each input and set type hints:\n#      Input 0 (walls_json): str\n#      Input 1 (config_json): str\n#      Input 2 (run): bool\n\ntry:\n    _walls_json = walls_json\nexcept NameError:\n    _walls_json = None\n\ntry:\n    _config_json = config_json\nexcept NameError:\n    _config_json = None\n\ntry:\n    _run = run\nexcept NameError:\n    _run = False\n\nif __name__ == \"__main__\":\n    junctions_json, graph_pts, graph_lines, walls_json_out, summary, log = main(\n        _walls_json, _config_json, _run\n    )\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}