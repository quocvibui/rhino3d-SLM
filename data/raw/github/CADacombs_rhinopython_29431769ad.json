{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_invalid.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_invalid.py",
  "instruction": "This script is an alternative to _SelBadObjects and _ExtractBadSrf.\r\nIn addtion to the breps in whoel, it optionally checks their components and geometry.\r\n\r\nSend any questions, comments, or script...",
  "code": "\"\"\"\r\nThis script is an alternative to _SelBadObjects and _ExtractBadSrf.\r\nIn addtion to the breps in whoel, it optionally checks their components and geometry.\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums, https://discourse.mcneel.com/\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n160819: Created.\r\n181020-21:  Moved a function from another script.\r\n            Added Opts class and more options.  Refactored.\r\n            Changed name from findInvalidFaces.py to invalidBreps.py.\r\n190505: History modification.\r\n191022: Bug fix.  More general input is now allowed for extractBadFaces.\r\n191024-25: Output of extractBadFaces changed from BrepObjects to GUIDS.\r\n        Improved command line output for bEcho value in extractBadFaces.\r\n191103: extractBadFaces can now be passed multiple breps.\r\n250325: Added check for breps created from brep's surfaces. Refactored.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System.Collections.Generic import List\r\nfrom System.Drawing import Color\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n    keys_Type = []\r\n\r\n\r\n    key = 'bFacesAsBreps'; keys.append(key)\r\n    keys_Type.append(key)\r\n    values[key] = True\r\n    names[key] = 'FacesAsTheirOwnBreps'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bSrfsAsBreps'; keys.append(key)\r\n    keys_Type.append(key)\r\n    values[key] = True\r\n    names[key] = 'SrfsAsTheirOwnBreps'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bCrvs2D'; keys.append(key)\r\n    keys_Type.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bCrvs3D'; keys.append(key)\r\n    keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bEdges'; keys.append(key)\r\n    keys_Type.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bFaces'; keys.append(key)\r\n    keys_Type.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bLoops'; keys.append(key)\r\n    keys_Type.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bSrfs'; keys.append(key)\r\n    keys_Type.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bTrims'; keys.append(key)\r\n    keys_Type.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bVertices'; keys.append(key)\r\n    keys_Type.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAnalyzePerFace'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'AnalysisMode'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Brep', 'Face')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bExtract'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bAddDot'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'DotFaces'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'iDotHeight'; keys.append(key)\r\n    values[key] = 10\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], setLowerLimit=True, limit=3)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        cls.stickyKeys[key]\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\n    @classmethod\r\n    def addOptions_BrepTypes(cls, getInput):\r\n        \r\n        def addOptionToggle(key):\r\n            getInput.AddOptionToggle(cls.names[key], cls.riOpts[key])\r\n        \r\n        addOptionToggle('bFacesAsBreps')\r\n        addOptionToggle('bCrvs2D')\r\n        addOptionToggle('bCrvs3D')\r\n        addOptionToggle('bEdges')\r\n        addOptionToggle('bFaces')\r\n        addOptionToggle('bLoops')\r\n        addOptionToggle('bSrfs')\r\n        addOptionToggle('bTrims')\r\n        addOptionToggle('bVertices')\r\n        getInput.AddOption('YesToAll')\r\n        getInput.AddOption('NoToAll')\r\n    \r\n    @classmethod\r\n    def chooseTypes(cls):\r\n        \r\n        getInputOpt = ri.Custom.GetOption()\r\n        getInputOpt.SetCommandPrompt(\"Brep type(s) to check\")\r\n        \r\n        cls.addOptions_BrepTypes(getInputOpt)\r\n        \r\n        while True:\r\n            if sc.escape_test(False): break\r\n            \r\n            res = getInputOpt.Get()\r\n            if res != ri.GetResult.Option:\r\n                return\r\n            \r\n            if getInputOpt.OptionIndex() == 10:\r\n                for key in cls.keys_Type:\r\n                    cls.values[key] = cls.riOpts[key].CurrentValue = True\r\n            elif getInputOpt.OptionIndex() == 11:\r\n                for key in cls.keys_Type:\r\n                    cls.values[key] = cls.riOpts[key].CurrentValue = False\r\n            else:\r\n                for key in cls.keys_Type:\r\n                    cls.values[key] = cls.riOpts[key].CurrentValue\r\n            \r\n            cls.saveSticky()\r\n            \r\n            getInputOpt.ClearCommandOptions()\r\n            cls.addOptions_BrepTypes(getInputOpt)\r\n    \r\n    @classmethod\r\n    def processInput(cls, go):\r\n        res = go.Result()\r\n        \r\n        if go.Option().Index == 1:\r\n            cls.chooseTypes()\r\n        \r\n        cls.setValues()\r\n        \r\n        cls.saveSticky()\r\n        \r\n        # Clear and add options regardless if a number was entered or options were modified in another way.\r\n        go.ClearCommandOptions()\r\n        Opts.addOptions(go)\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get breps with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n    go.SetCommandPrompt(\"Select breps\")\r\n    go.SetCommandPromptDefault(\"All normal when none are selected\")\r\n    go.GeometryFilter = rd.ObjectType.Brep\r\n\r\n    go.AcceptNothing(True)\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False\r\n    go.SubObjectSelect = False\r\n\r\n    go.EnableClearObjectsOnEntry(False)\r\n\r\n    idxs_Opt = {}\r\n    def addOption(ric, key): idxs_Opt[key] = Opts.addOption(ric, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        idxs_Opt['ObjectsToCheck'] = go.AddOption('ObjectsToCheck')\r\n        addOption(go, 'bAnalyzePerFace')\r\n        addOption(go, 'bExtract')\r\n        addOption(go, 'bAddDot')\r\n        if Opts.values['bAddDot']:\r\n            addOption(go, 'iDotHeight')\r\n        addOption(go, 'bEcho')\r\n        addOption(go, 'bDebug')\r\n\r\n        sTrue = []\r\n        sFalse = []\r\n        for key in Opts.keys_Type:\r\n            if Opts.values[key]:\r\n                sTrue.append(Opts.names[key])\r\n            else:\r\n                sFalse.append(Opts.names[key])\r\n        print(\"Brep components that will be checked: {}\".format(\r\n            \", \".join(sTrue) if sTrue else 'None'))\r\n        print(\"Not checked: {}\".format(\", \".join(sFalse) if sFalse else 'None'))\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n        \r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            oes = rd.ObjectEnumeratorSettings()\r\n            oes.LockedObjects = False\r\n            oes.ObjectTypeFilter = rd.ObjectType.Brep\r\n            rdBs = list(sc.doc.Objects.GetObjectList(oes))\r\n            go.Dispose()\r\n            return rdBs\r\n\r\n        if go.Option().Index == idxs_Opt['ObjectsToCheck']:\r\n            idxs_Opt.clear()\r\n\r\n            go_ObjFilter = ri.Custom.GetOption()\r\n            go_ObjFilter.SetCommandPrompt(\"Subobjects to check\")\r\n\r\n            while True:\r\n                go_ObjFilter.ClearCommandOptions()\r\n                idxs_Opt.clear()\r\n\r\n                for key in Opts.keys_Type:\r\n                    addOption(go_ObjFilter, key)\r\n                idxs_Opt['YesToAll'] = go_ObjFilter.AddOption('YesToAll')\r\n                idxs_Opt['NoToAll'] = go_ObjFilter.AddOption('NoToAll')\r\n\r\n                res = go_ObjFilter.Get()\r\n\r\n                if res != ri.GetResult.Option:\r\n                    break\r\n\r\n                if go_ObjFilter.OptionIndex() == idxs_Opt['YesToAll']:\r\n                    for key in Opts.keys_Type:\r\n                        Opts.riOpts[key].CurrentValue = True\r\n                        Opts.setValue(key)\r\n                    continue\r\n\r\n                if go_ObjFilter.OptionIndex() == idxs_Opt['NoToAll']:\r\n                    for key in Opts.keys_Type:\r\n                        Opts.riOpts[key].CurrentValue = False\r\n                        Opts.setValue(key)\r\n                    continue\r\n\r\n                for key in idxs_Opt:\r\n                    if go_ObjFilter.Option().Index == idxs_Opt[key]:\r\n                        Opts.setValue(key, go_ObjFilter.Option().CurrentListOptionIndex)\r\n                        break\r\n\r\n            go_ObjFilter.Dispose()\r\n\r\n            continue\r\n\r\n\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n        go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n\r\n\r\ndef coerceBrep(rhObj):\r\n    if isinstance(rhObj, rg.GeometryBase):\r\n        geom = rhObj\r\n        guid = None\r\n    elif isinstance(rhObj, rd.ObjRef):\r\n        geom = rhObj.Geometry()\r\n        guid = rhObj.ObjectId\r\n    elif isinstance(rhObj, Guid):\r\n        rdObj = sc.doc.Objects.FindId(rhObj) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhObj)\r\n        geom = rdObj.Geometry\r\n        guid = rdObj.Id\r\n    elif isinstance(rhObj, rd.BrepObject):\r\n        rdObj = rhObj\r\n        geom = rdObj.Geometry\r\n        guid = rdObj.Id\r\n    else:\r\n        return\r\n\r\n    if not isinstance(geom, rg.Brep):\r\n        print(\"Not a brep: {}\".format(guid))\r\n        return\r\n    \r\n    return geom\r\n\r\n\r\ndef coerceRhinoObject(rhObj):\r\n    rdObj = None\r\n    if isinstance(rhObj, rd.RhinoObject):\r\n        rdObj = rhObj\r\n    elif isinstance(rhObj, rd.ObjRef):\r\n        rdObj = rhObj.Object()\r\n    elif isinstance(rhObj, Guid):\r\n        rdObj = sc.doc.Objects.FindId(rhObj) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhObj)\r\n    return rdObj\r\n\r\n\r\ndef reportOfInvalidComponentCounts(rgBrep, bFacesAsBreps=True, bSrfsAsBreps=True, bCrvs2D=True, bCrvs3D=True, bEdges=True, bFaces=True, bLoops=True, bSrfs=True, bTrims=True, bVertices=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    ss = []\r\n\r\n    if bFacesAsBreps:\r\n        idxs = []\r\n        for iF in range(rgBrep.Faces.Count):\r\n            rgF = rgBrep.Faces[iF]\r\n            # Check duplicate brep from each face because face itself may show as being valid.\r\n            rgB_fromF = rgF.DuplicateFace(duplicateMeshes=False)\r\n            if not rgB_fromF.IsValid:\r\n                idxs.append(iF)\r\n            rgB_fromF.Dispose()\r\n        if not idxs:\r\n            ss.append(\"0 faces found that would be invalid breps.\")\r\n        elif len(idxs) > 10:\r\n            ss.append(\"{} faces found that would be invalid brep: {}, etc.\".format(len(idxs), idxs[:10]))\r\n        else:\r\n            ss.append(\"{} faces found that would be invalid breps: {}\".format(len(idxs), idxs[:len(idxs)]))\r\n\r\n    if bSrfsAsBreps:\r\n        idxs = []\r\n        for iF in range(rgBrep.Surfaces.Count):\r\n            rgS = rgBrep.Surfaces[iF]\r\n            # Check duplicate brep from each face because face itself may show as being valid.\r\n            rgB_fromS = rgS.ToBrep()\r\n            if not rgB_fromS.IsValid:\r\n                idxs.append(iF)\r\n        if not idxs:\r\n            ss.append(\"0 surfaces found that would be invalid breps.\")\r\n        elif len(idxs) > 10:\r\n            ss.append(\"{} surfaces found that would be invalid brep: {}, etc.\".format(len(idxs), idxs[:10]))\r\n        else:\r\n            ss.append(\"{} surfaces found that would be invalid breps: {}\".format(len(idxs), idxs[:len(idxs)]))\r\n\r\n    return \"\\n\".join(ss)\r\n\r\n\r\n\r\n    if bSrfsAsBreps and not rgB_fromS.IsValid:\r\n        idxsFs_InvalidFacesAsBreps.append(iF)\r\n    if bCrvs2D and any(not rgX.IsValid for rgX in rgB_fromF.Curves2D):\r\n        idxsFs_InvalidCrvs2d.append(iF)\r\n    if bCrvs3D and any(not rgX.IsValid for rgX in rgB_fromF.Curves3D):\r\n        idxsFs_InvalidCrvs3d.append(iF)\r\n    if bEdges and any(not rgX.IsValid for rgX in rgB_fromF.Edges):\r\n        idxsFs_InvalidEdges.append(iF)\r\n    if bFaces and any(not rgX.IsValid for rgX in rgB_fromF.Faces):\r\n        idxsFs_InvalidFaces.append(iF)\r\n    if bLoops and any(not rgX.IsValid for rgX in rgB_fromF.Loops):\r\n        idxsFs_InvalidLoops.append(iF)\r\n    if bSrfs and any(not rgX.IsValid for rgX in rgB_fromF.Surfaces):\r\n        idxsFs_InvalidSurfaces.append(iF)\r\n    if bTrims and any(not rgX.IsValid for rgX in rgB_fromF.Trims):\r\n        idxsFs_InvalidTrims.append(iF)\r\n    if bVertices and any(not rgX.IsValid for rgX in rgB_fromF.Vertices):\r\n        idxsFs_InvalidVertices.append(iF)\r\n\r\n    rgB_fromF.Dispose()\r\n    rgB_fromS.Dispose()\r\n\r\n\r\ndef indicesOfFacesOfInvalidBrepComponents(rgBrep, bFacesAsBreps=True, bSrfsAsBreps=True, bCrvs2D=True, bCrvs3D=True, bEdges=True, bFaces=True, bLoops=True, bSrfs=True, bTrims=True, bVertices=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    idxsFs_InvalidFacesAsBreps = []\r\n    idxsFs_InvalidSrfsAsBreps = []\r\n    idxsFs_InvalidCrvs2d = []\r\n    idxsFs_InvalidCrvs3d = []\r\n    idxsFs_InvalidEdges = []\r\n    idxsFs_InvalidFaces = []\r\n    idxsFs_InvalidLoops = []\r\n    idxsFs_InvalidSurfaces = []\r\n    idxsFs_InvalidTrims = []\r\n    idxsFs_InvalidVertices = []\r\n\r\n    for iF in range(rgBrep.Faces.Count):\r\n        rgF = rgBrep.Faces[iF]\r\n        # Check duplicate brep from each face because face itself may show as being valid.\r\n        rgB_fromF = rgF.DuplicateFace(duplicateMeshes=False)\r\n        rgB_fromS = rgF.UnderlyingSurface().ToBrep()\r\n\r\n        if bFacesAsBreps and not rgB_fromF.IsValid:\r\n            idxsFs_InvalidFacesAsBreps.append(iF)\r\n        if bSrfsAsBreps and not rgB_fromS.IsValid:\r\n            idxsFs_InvalidFacesAsBreps.append(iF)\r\n        if bCrvs2D and any(not rgX.IsValid for rgX in rgB_fromF.Curves2D):\r\n            idxsFs_InvalidCrvs2d.append(iF)\r\n        if bCrvs3D and any(not rgX.IsValid for rgX in rgB_fromF.Curves3D):\r\n            idxsFs_InvalidCrvs3d.append(iF)\r\n        if bEdges and any(not rgX.IsValid for rgX in rgB_fromF.Edges):\r\n            idxsFs_InvalidEdges.append(iF)\r\n        if bFaces and any(not rgX.IsValid for rgX in rgB_fromF.Faces):\r\n            idxsFs_InvalidFaces.append(iF)\r\n        if bLoops and any(not rgX.IsValid for rgX in rgB_fromF.Loops):\r\n            idxsFs_InvalidLoops.append(iF)\r\n        if bSrfs and any(not rgX.IsValid for rgX in rgB_fromF.Surfaces):\r\n            idxsFs_InvalidSurfaces.append(iF)\r\n        if bTrims and any(not rgX.IsValid for rgX in rgB_fromF.Trims):\r\n            idxsFs_InvalidTrims.append(iF)\r\n        if bVertices and any(not rgX.IsValid for rgX in rgB_fromF.Vertices):\r\n            idxsFs_InvalidVertices.append(iF)\r\n\r\n        rgB_fromF.Dispose()\r\n        rgB_fromS.Dispose()\r\n\r\n    return sorted(set(\r\n        idxsFs_InvalidFacesAsBreps +\r\n        idxsFs_InvalidSrfsAsBreps +\r\n        idxsFs_InvalidCrvs2d +\r\n        idxsFs_InvalidCrvs3d +\r\n        idxsFs_InvalidEdges +\r\n        idxsFs_InvalidFaces +\r\n        idxsFs_InvalidLoops +\r\n        idxsFs_InvalidSurfaces +\r\n        idxsFs_InvalidTrims +\r\n        idxsFs_InvalidVertices\r\n        ))\r\n\r\n\r\ndef isValid(rhBrep):\r\n    brep = coerceBrep(rhBrep)\r\n    bValid = brep.IsValid\r\n    brep.Dispose()\r\n    return bValid\r\n\r\n\r\ndef extractBadFaces(rhBreps, bEcho=False, bDebug=False):\r\n    \"\"\"\r\n    Returns: gBreps_NotValid, gBreps_Valid\r\n    \"\"\"\r\n\r\n    try: rhBreps = list(rhBreps)\r\n    except: rhBreps = [rhBreps]\r\n\r\n    gBs_notValid = []\r\n    gBs_Valid = []\r\n    gBs_toExtract = []\r\n\r\n    for rhBrep in rhBreps:\r\n        rdBrep = coerceRhinoObject(rhBrep)\r\n        rgBrep = rdBrep.BrepGeometry\r\n        if rgBrep.IsValid:\r\n            gBs_Valid.append(rdBrep.Id)\r\n        elif rgBrep.Faces.Count == 1:\r\n            gBs_notValid.append(rdBrep.Id)\r\n        else:\r\n            gBs_toExtract.append(rdBrep.Id)\r\n        rgBrep.Dispose() # Geometry won't be used for remainder of function.\r\n\r\n    if not gBs_toExtract:\r\n        return gBs_notValid, gBs_Valid\r\n\r\n\r\n    # Record first normal object (last created) that is not a brep passed to this function.\r\n    gFirstObj_Start = None\r\n    for rdObj in list(sc.doc.Objects.GetObjectList(rd.ObjectType.AnyObject)): # EnumeratorWrappe -> list\r\n        if rdObj.Id not in gBs_notValid + gBs_Valid + gBs_toExtract:\r\n            gFirstObj_Start = rdObj\r\n            break\r\n\r\n    if bDebug:\r\n        sPrint = 'gFirstObj_Start'; print(sPrint + ':', eval(sPrint))\r\n    else:\r\n        sc.doc.Views.RedrawEnabled = False\r\n\r\n    # Extract bad faces using UI command.\r\n    sc.doc.Objects.UnselectAll()\r\n    [sc.doc.Objects.Select(g) for g in gBs_toExtract]\r\n    if bEcho:\r\n        Rhino.RhinoApp.RunScript(\"_ExtractBadSrf\", echo=True)\r\n    else:\r\n        Rhino.RhinoApp.RunScript(\"_NoEcho _ExtractBadSrf _Echo\", echo=False)\r\n    # Only invalid monoface breps are selected:\r\n    rds_notValid_Extracted = list(sc.doc.Objects.GetSelectedObjects(False, False))\r\n    \r\n    # Create a list of remainder of breps.\r\n    rdObjs = sc.doc.Objects.GetObjectList(rd.ObjectType.AnyObject)\r\n    rdBs_Valid_fromExtr = []\r\n    for rdObj in rdObjs:\r\n        if (\r\n                (gFirstObj_Start is not None) and\r\n                (rdObj.Id == gFirstObj_Start)\r\n        ):\r\n            # Past modified brep.\r\n            break\r\n        if rdObj.IsSelected(False): continue # Brep is bad.  (False is for checkSubObjects.)\r\n        rdBs_Valid_fromExtr.append(rdObj)\r\n    \r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = True\r\n\r\n    return (\r\n        gBs_notValid + [br.Id for br in rds_notValid_Extracted],\r\n        gBs_Valid + [br.Id for br in rdBs_Valid_fromExtr]\r\n    )\r\n\r\n\r\ndef dotAtSurfaceCentroid(rgSrf, text='!', iDotHeight=14):\r\n    ptCentrdW = (\r\n            Rhino.Geometry.AreaMassProperties.Compute(rgSrf).Centroid)\r\n    getrc, u, v = rgSrf.ClosestPoint(ptCentrdW)\r\n    ptCentroid = rgSrf.PointAt(u, v)\r\n    rgDot = rg.TextDot(text, ptCentroid)\r\n    rgDot.FontHeight = iDotHeight\r\n    return rgDot\r\n\r\n\r\ndef processBrepObjects(rhBreps, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bFacesAsBreps = getOpt('bFacesAsBreps')\r\n    bSrfsAsBreps = getOpt('bSrfsAsBreps')\r\n    bCrvs2D = getOpt('bCrvs2D')\r\n    bCrvs3D = getOpt('bCrvs3D')\r\n    bEdges = getOpt('bEdges')\r\n    bFaces = getOpt('bFaces')\r\n    bLoops = getOpt('bLoops')\r\n    bSrfs = getOpt('bSrfs')\r\n    bTrims = getOpt('bTrims')\r\n    bVertices = getOpt('bVertices')\r\n    bAnalyzePerFace = getOpt('bAnalyzePerFace')\r\n    bExtract = getOpt('bExtract')\r\n    bAddDot = getOpt('bAddDot')\r\n    iDotHeight = getOpt('iDotHeight')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n    \r\n    rgDots = []\r\n    gBreps0_Pos = []\r\n    iCt_InvalidFaces_All = 0\r\n    gBreps_NotValid_perBrep0 = []\r\n    gBreps_Valid_perBrep0 = []\r\n    \r\n    Rhino.RhinoApp.CommandPrompt = \"Searching ...\"\r\n\r\n    if bAnalyzePerFace:\r\n        for rhBrep in rhBreps:\r\n            rdBrep0 = coerceRhinoObject(rhBrep)\r\n            rgBrep0 = coerceBrep(rdBrep0)\r\n            if rgBrep0 is None: continue\r\n        \r\n            # Get indices of invalid brep faces.\r\n            idx_rgFaces_Invalid = indicesOfFacesOfInvalidBrepComponents(rgBrep0)\r\n            if not idx_rgFaces_Invalid: continue\r\n        \r\n            iCt_InvalidFaces_All = len(idx_rgFaces_Invalid)\r\n            if iCt_InvalidFaces_All == 0:\r\n                # No matches in this brep\r\n                continue\r\n        \r\n            if bExtract:\r\n                if rgBrep0.Faces.Count == 1: # Single-face brep\r\n                    gBreps_NotValid_perBrep0.append([rdBrep0.Id])\r\n                    continue\r\n            \r\n                # Extract from brep with multiple faces.  Uses Rhino command.\r\n                rc = extractBadFaces(rdBrep0)\r\n                if rc is None: continue\r\n                gBreps_NotValid, gBreps_Valid = rc\r\n                gBreps_NotValid_perBrep0.append(gBreps_NotValid)\r\n                gBreps_Valid_perBrep0.append(gBreps_Valid)\r\n            else:\r\n                gBreps0_Pos.append(rdBrep0.Id)\r\n        \r\n            if bAddDot:\r\n                for f in idx_rgFaces_Invalid:\r\n                    rgFace = rgBrep0.Faces[f]\r\n                    rgDots.append(dotAtSurfaceCentroid(\r\n                        rgFace, iDotHeight=iDotHeight))\r\n                    rgFace.Dispose()\r\n        \r\n            # End of idBreps0 loop.\r\n    \r\n        if len(rgDots) > 0:\r\n            attr = rd.ObjectAttributes()\r\n            attr.LayerIndex = sc.doc.Layers.CurrentLayerIndex\r\n            attr.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n            attr.ObjectColor = Color.FromArgb(255,0,0)\r\n            for rgDot in rgDots:\r\n                sc.doc.Objects.AddTextDot(rgDot, attr)\r\n                rgDot.Dispose()\r\n    \r\n        if not iCt_InvalidFaces_All:\r\n            print(\"No faces with invalid content found.\")\r\n            return\r\n\r\n        print(\"{} faces with invalid content found.\".format(iCt_InvalidFaces_All))\r\n        if bExtract:\r\n            sc.doc.Objects.UnselectAll()\r\n            print(\"{} extracted face(s) are selected.\".format(\r\n                sc.doc.Objects.Select(List[Guid](\r\n                    [g for item in gBreps_NotValid_perBrep0 for g in item]))))\r\n            return gBreps_NotValid_perBrep0, gBreps_Valid_perBrep0\r\n        else:\r\n            gBreps0_Pos = List[Guid](gBreps0_Pos)\r\n            sc.doc.Objects.UnselectAll()\r\n            print(\"{} brep(s) are selected.\".format(\r\n                sc.doc.Objects.Select(gBreps0_Pos)))\r\n            return gBreps0_Pos\r\n    else:\r\n        for rhBrep in rhBreps:\r\n            rdBrep0 = coerceRhinoObject(rhBrep)\r\n            rgBrep0 = coerceBrep(rdBrep0)\r\n            if rgBrep0 is None: continue\r\n            sReport = reportOfInvalidComponentCounts(\r\n                rgBrep0,\r\n                bFacesAsBreps=bFacesAsBreps,\r\n                bSrfsAsBreps=bSrfsAsBreps,\r\n                bCrvs2D=bCrvs2D,\r\n                bCrvs3D=bCrvs3D,\r\n                bEdges=bEdges,\r\n                bFaces=bFaces,\r\n                bLoops=bLoops,\r\n                bSrfs=bSrfs,\r\n                bTrims=bTrims,\r\n                bVertices=bVertices,\r\n                bDebug=bDebug)\r\n            print(sReport)\r\n\r\n\r\ndef main():\r\n\r\n    rhBreps = getInput()\r\n    if not rhBreps: return\r\n\r\n    bFacesAsBreps = Opts.values['bFacesAsBreps']\r\n    bSrfsAsBreps = Opts.values['bSrfsAsBreps']\r\n    bCrvs2D = Opts.values['bCrvs2D']\r\n    bCrvs3D = Opts.values['bCrvs3D']\r\n    bEdges = Opts.values['bEdges']\r\n    bFaces = Opts.values['bFaces']\r\n    bLoops = Opts.values['bLoops']\r\n    bSrfs = Opts.values['bSrfs']\r\n    bTrims = Opts.values['bTrims']\r\n    bVertices = Opts.values['bVertices']\r\n    bAnalyzePerFace = Opts.values['bAnalyzePerFace']\r\n    bExtract = Opts.values['bExtract']\r\n    bAddDot = Opts.values['bAddDot']\r\n    iDotHeight = Opts.values['iDotHeight']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n\r\n    processBrepObjects(\r\n        rhBreps,\r\n        bFacesAsBreps=bFacesAsBreps,\r\n        bSrfsAsBreps=bSrfsAsBreps,\r\n        bCrvs2D=bCrvs2D,\r\n        bCrvs3D=bCrvs3D,\r\n        bEdges=bEdges,\r\n        bFaces=bFaces,\r\n        bLoops=bLoops,\r\n        bSrfs=bSrfs,\r\n        bTrims=bTrims,\r\n        bVertices=bVertices,\r\n        bAnalyzePerFace=bAnalyzePerFace,\r\n        bExtract=bExtract,\r\n        bAddDot=bAddDot,\r\n        iDotHeight=iDotHeight,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug)\r\n\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}