{
  "source_url": "https://github.com/Brandes21/PyPa/blob/713d1e35bd5490521eab2d0efe869fff9692e351/Packages/MIS_curves/src/Curve_Removal/MIS_curves.py",
  "repo": "Brandes21/PyPa",
  "repo_stars": 1,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Packages/MIS_curves/src/Curve_Removal/MIS_curves.py",
  "instruction": "Mis curves",
  "code": "def main(curve_ids, min_dist, forced_keep_curves):\n    import Rhino\n    import Grasshopper.Kernel as gh\n    from ghpythonlib import treehelpers as tr\n\n\n    # === GHPython Run ===\n    # inputs:\n    #   curve_ids          : List[Curves]\n    #   min_dist           : float\n    #   forced_keep_curves : List[Curves]         !Optional input!\n    # outputs:\n    #   kept curves\n    #   removed curves\n\n    def curve_min_distance(crvA, crvB):\n        success, ptA, ptB = crvA.ClosestPoints(crvB)\n        return ptA.DistanceTo(ptB) if success else float('inf')\n\n\n    def curves_equal_by_control_points(crvA, crvB, tol=1e-6):\n        \"\"\"True if A and B have identical NURBS control nets (within tol).\"\"\"\n        ncA = crvA.ToNurbsCurve()\n        ncB = crvB.ToNurbsCurve()\n\n        # quick rejects \n        if ncA.Degree     != ncB.Degree:     return False\n        if ncA.Points.Count != ncB.Points.Count: return False\n        if ncA.Knots.Count  != ncB.Knots.Count:  return False\n\n        # points & weights\n        for i in range(ncA.Points.Count):\n            pA = ncA.Points[i];  pB = ncB.Points[i]\n            if pA.Location.DistanceTo(pB.Location) > tol: return False\n            if abs(pA.Weight - pB.Weight)      > tol: return False\n\n        # knots\n        for i in range(ncA.Knots.Count):\n            if abs(ncA.Knots[i] - ncB.Knots[i]) > tol: return False\n\n        return True\n\n    def find_forced_indices(curves, forced_keep, tol=1e-6):\n        \"\"\"\n        Return set of indices in `curves` whose geometry matches any curve\n        in `forced_keep`, by control-point equality.\n        \"\"\"\n        forced_idx = set()\n        for fk in forced_keep:\n            # if user passed GH_Curve wrapper, unwrap it\n            raw_fk = fk.Value if hasattr(fk, \"Value\") else fk\n            matched = False\n            for i, c in enumerate(curves):\n                if curves_equal_by_control_points(c, raw_fk, tol):\n                    forced_idx.add(i)\n                    matched = True\n                    break\n            if not matched:\n                ghenv.Component.AddRuntimeMessage(\n                    gh.GH_RuntimeMessageLevel.Warning,\n                    \"Forced-keep curve #{} didnâ€™t match any input curve.\".format(\n                        forced_keep.index(fk)\n                    )\n                )\n        return forced_idx\n\n    def remove_curves_too_close(curves, min_dist, forced_keep):\n\n        n = len(curves)\n        # 0) find which indices are forced\n        if forced_keep:\n            forced_idx = find_forced_indices(curves, forced_keep, tol=1e-6)\n        else:\n            forced_idx = []\n\n        # 1) Build conflict adjacency list\n        conflicts = {i: [] for i in range(n)}\n        for i in range(n):\n            for j in range(i+1, n):\n                if curve_min_distance(curves[i], curves[j]) < min_dist:\n                    conflicts[i].append(j)\n                    conflicts[j].append(i)\n\n        # 2) Warn if two forced curves conflict\n        for i in forced_idx:\n            for j in conflicts[i]:\n                if j in forced_idx and i < j:\n                    ghenv.Component.AddRuntimeMessage(\n                        gh.GH_RuntimeMessageLevel.Warning,\n                        \"Forced-keep curves #{} and #{} are closer than {}.\"\n                        .format(i, j, min_dist)\n                    )\n\n        # 3) Start with everything, immediately drop non-forced that conflict with forced\n        keep = set(range(n))\n        for i in forced_idx:\n            for j in conflicts[i]:\n                if j not in forced_idx and j in keep:\n                    keep.remove(j)\n\n        # 4) Greedy MIS on the rest (never drop forced)\n        while True:\n            # find any remaining conflict\n            conflict_found = False\n            for i in keep:\n                for j in conflicts[i]:\n                    if j in keep and i < j:\n                        conflict_found = True\n                        break\n                if conflict_found:\n                    break\n            if not conflict_found:\n                break\n\n            # pick worst non-forced\n            worst, max_deg = None, -1\n            for i in keep:\n                if i in forced_idx:\n                    continue\n                deg = sum(1 for x in conflicts[i] if x in keep)\n                if deg > max_deg:\n                    worst, max_deg = i, deg\n\n            if worst is None:\n                # only forced-vs-forced remain; we already warned\n                break\n\n            keep.remove(worst)\n\n        kept   = [curves[i] for i in sorted(keep)]\n        removed = [curves[i] for i in range(n) if i not in keep]\n        return kept, removed\n\n\n  \n    #Output#\n    kept, removed = remove_curves_too_close(curve_ids, min_dist, forced_keep_curves)\n\n    kept = tr.list_to_tree(kept)\n    removed = tr.list_to_tree(removed)\n    return kept, removed\n\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "ghpythonlib"
  ],
  "has_docstring": false
}