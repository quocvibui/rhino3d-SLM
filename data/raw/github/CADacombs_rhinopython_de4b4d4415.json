{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Intersect_SrfSrf.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Intersect_SrfSrf.py",
  "instruction": "This script is an alternative to _Intersect, but for 2 BrepFaces only.\r\n\r\nUnique features to _Intersect:\r\n    The underlying surface can be intersected for either or both faces.\r\n    Results for...",
  "code": "\"\"\"\r\nThis script is an alternative to _Intersect, but for 2 BrepFaces only.\r\n\r\nUnique features to _Intersect:\r\n    The underlying surface can be intersected for either or both faces.\r\n    Results for various tolerances are calculated and the user can chose one from a dialog box.\r\n\r\nPoints are not output.\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n210914-21: Created.\r\n210929: Bug fixed and streamlined getInput.\r\n220820: Bug fix.\r\n231224: Added options to make the curves without the dialog.  In that case, only the input tolerance is used.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nimport Eto.Drawing as drawing\r\nimport Eto.Forms as forms\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bUseDialog'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fTol'; keys.append(key)\r\n    values[key] = sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'fMinTol'; keys.append(key)\r\n    values[key] = 1e-5\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'fMinCrvLength'; keys.append(key)\r\n    values[key] = 10.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bUnderlying1st'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bUnderlying2nd'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        if not idxOpt: print(\"Add option for {} failed.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key in ('fTol', 'fMinTol'):\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < Rhino.RhinoMath.ZeroTolerance:\r\n                cls.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            print(\"Error: {} was passed to setValue.\".format(key))\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Select 2 BrepFaces with options.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select 2 brep faces\")\r\n\r\n    go.GeometryFilter = go.GeometryFilter.Surface\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('bUseDialog')\r\n        Opts.names['fTol'] = 'MaxTol' if Opts.values['bUseDialog'] else 'Tol'\r\n        addOption('fTol')\r\n        if Opts.values['bUseDialog']:\r\n            addOption('fMinTol')\r\n        addOption('fMinCrvLength')\r\n        addOption('bUnderlying1st')\r\n        addOption('bUnderlying2nd')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=2, maximumNumber=2)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fTol'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\nclass DrawCurvesConduit(Rhino.Display.DisplayConduit):\r\n\r\n    def __init__(self):\r\n        #self.color = sc.doc.Layers.CurrentLayer.Color\r\n        self.color = Rhino.ApplicationSettings.AppearanceSettings.FeedbackColor\r\n        self.curves = None\r\n\r\n    #def CalculateBoundingBox(self, calculateBoundingBoxEventArgs):\r\n    #    if len(self.curves) > 0:\r\n    #        self.bbox = self.brep.GetBoundingBox(accurate=False)\r\n    #        calculateBoundingBoxEventArgs.IncludeBoundingBox(self.bbox)\r\n\r\n    def PreDrawObjects(self, drawEventArgs):\r\n\r\n        displayMode = Rhino.RhinoDoc.ActiveDoc.Views.ActiveView.ActiveViewport.DisplayMode\r\n        crv_thk = displayMode.DisplayAttributes.CurveThickness + 1\r\n\r\n        for c in self.curves:\r\n            drawEventArgs.Display.DrawCurve(\r\n                curve=c,\r\n                color=self.color,\r\n                thickness=crv_thk)\r\n\r\n\r\nclass EtoModelessForm(forms.Form):\r\n    \"\"\"\r\n    Started with\r\n    https://github.com/mcneel/rhino-developer-samples/blob/3179a8386a64602ee670cc832c77c561d1b0944b/rhinopython/SampleEtoModelessForm.py\r\n    \"\"\"\r\n\r\n\r\n    def __init__(self):\r\n        self.m_selecting = False\r\n        self.Initialize()\r\n        self.CreateFormControls()\r\n        self.conduit = DrawCurvesConduit()\r\n\r\n    def Initialize(self):\r\n        self.Title = 'Surface-Surface Intersection'\r\n        self.Padding = drawing.Padding(5)\r\n        self.Resizable = False\r\n        self.Maximizable = False\r\n        self.Minimizable = False\r\n        self.ShowInTaskbar = False\r\n        self.MinimumSize = drawing.Size(230, 150)\r\n        self.Closed += self.OnFormClosed\r\n\r\n    def addCurveSetListItem(self, cs, fTol):\r\n        item = forms.ListItem()\r\n        total_length = 0.0\r\n        span_count = 0\r\n        cp_count = 0\r\n        for c in cs:\r\n            total_length += c.GetLength()\r\n            nc = c.ToNurbsCurve()\r\n            span_count += nc.SpanCount\r\n            cp_count += nc.Points.Count\r\n            nc.Dispose()\r\n        iPrec = sc.doc.ModelDistanceDisplayPrecision + 1\r\n        item.Text = \"\"\r\n        item.Text += \"{:<10.6f}\".format(fTol)\r\n        item.Text += \"{:<{:}.{:}f}\".format(total_length, iPrec+8, iPrec)\r\n        item.Text += \"{:<11}\".format(len(cs))\r\n        item.Text += \"{:<11}\".format(span_count)\r\n        item.Text += \"{:<6}\".format(cp_count)\r\n        self.listbox.Items.Add(item)\r\n\r\n    def fillListBox(self):\r\n        for i in range(len(self.cs_nested)):\r\n            self.addCurveSetListItem(self.cs_nested[i], self.fTols[i])\r\n        self.listbox.SelectedIndex = 0\r\n\r\n    def addDataToForm(self, d4_cs, d4_fTols):\r\n        self.d4_cs = d4_cs\r\n        self.d4_fTols = d4_fTols\r\n        self.bUnder_A = self.bUnder_B = False\r\n        self.cs_nested = self.d4_cs[(self.bUnder_A, self.bUnder_B)]\r\n        self.fTols = self.d4_fTols[(self.bUnder_A, self.bUnder_B)]\r\n        self.fillListBox()\r\n\r\n    def CreateFormControls(self):\r\n        layout = forms.DynamicLayout()\r\n        layout.Padding = drawing.Padding(10)\r\n        layout.Spacing = drawing.Size(5, 5)\r\n\r\n        layout.Rows.Add(self.CreateCheckBoxListRow())\r\n\r\n        layout.AddRow(None)\r\n\r\n        iPrec = sc.doc.ModelDistanceDisplayPrecision + 1\r\n\r\n        sLabel = \"   {:<14}{:<12}{:<10}{:<8}{:<6}\".format(\r\n            'Tol', 'Length', 'Crvs', 'Spans', 'CPs')\r\n\r\n        layout.Rows.Add(forms.Label(Text=sLabel))\r\n        layout.Rows.Add(self.CreateListBoxRow())\r\n\r\n        ok_button = forms.Button(Text = 'OK')\r\n        ok_button.Click += self.OnOKButtonClick\r\n        self.AbortButton = forms.Button(Text = 'Cancel')\r\n        self.AbortButton.Click += self.OnCancelButtonClick\r\n\r\n        layout.BeginVertical()\r\n        layout.AddRow(None, ok_button, self.AbortButton, None)\r\n        layout.EndVertical()\r\n\r\n        self.Content = layout\r\n\r\n    def OnUnderlyingChange(self, sender, e):\r\n        #print('-'*10\r\n        #for x in self.checkBoxList.SelectedValues:\r\n        ss = [str(item) for item in self.checkBoxList.SelectedValues]\r\n        self.bUnder_A = self.sUnder_A in ss\r\n        self.bUnder_B = self.sUnder_B in ss\r\n        self.conduit.Enabled = False\r\n        sc.doc.Views.Redraw()\r\n        self.listbox.Items.Clear()\r\n        self.cs_nested = self.d4_cs[(self.bUnder_A, self.bUnder_B)]\r\n        self.fTols = self.d4_fTols[(self.bUnder_A, self.bUnder_B)]\r\n        self.fillListBox()\r\n\r\n    def CreateCheckBoxListRow(self):\r\n        self.checkBoxList = forms.CheckBoxList()\r\n        self.sUnder_A = \"Use face A's underlying surface\"\r\n        self.checkBoxList.Items.Add(self.sUnder_A)\r\n        self.sUnder_B = \"Use face B's underlying surface\"\r\n        self.checkBoxList.Items.Add(self.sUnder_B)\r\n        self.checkBoxList.Orientation = forms.Orientation.Vertical\r\n        self.checkBoxList.SelectedValuesChanged += self.OnUnderlyingChange\r\n        return self.checkBoxList\r\n\r\n    def OnSelectedIndexChanged(self, sender, e):\r\n        index = self.listbox.SelectedIndex\r\n        if index >= 0:\r\n            self.conduit.Enabled = False\r\n            self.m_selecting = True\r\n            item = self.listbox.Items[index]\r\n            self.conduit.curves = self.cs_nested[index]\r\n            self.conduit.Enabled = True\r\n            sc.doc.Views.Redraw()\r\n            self.m_selecting = False\r\n\r\n    def CreateListBoxRow(self):\r\n        self.listbox = forms.ListBox()\r\n        #self.m_listbox.Size = drawing.Size(200, 100)\r\n        self.listbox.SelectedIndexChanged += self.OnSelectedIndexChanged\r\n        d_row = forms.DynamicRow()\r\n        d_row.Add(self.listbox)\r\n        return d_row\r\n\r\n    def OnOKButtonClick(self, sender, e):\r\n        i = self.listbox.SelectedIndex\r\n        if i < 0:\r\n            self.Close()\r\n            print(\"No curve set was selected.\")\r\n            return\r\n\r\n        UInt32_Undo = sc.doc.BeginUndoRecord(\"Surface-Surface Intersect\")\r\n\r\n        for c in self.cs_nested[i]:\r\n            sc.doc.Objects.AddCurve(c)\r\n        sc.doc.Views.Redraw()\r\n\r\n        if not sc.doc.EndUndoRecord(UInt32_Undo):\r\n            print(\"Warning: EndUndoRecord==False\")\r\n\r\n        self.Close()\r\n\r\n    def OnCancelButtonClick(self, sender, e):\r\n        self.Close()\r\n\r\n    def OnFormClosed(self, sender, e):\r\n        self.conduit.Enabled = False\r\n        sc.doc.Views.Redraw()\r\n\r\n\r\ndef _getIntersectionMethod(rgObj_A, rgObj_B):\r\n    if isinstance(rgObj_A, rg.Brep):\r\n        if isinstance(rgObj_B, rg.Brep):\r\n            return rg.Intersect.Intersection.BrepBrep\r\n        elif isinstance(rgObj_B, rg.Surface):\r\n            return rg.Intersect.Intersection.BrepSurface\r\n    elif isinstance(rgObj_A, rg.Surface):\r\n        if isinstance(rgObj_B, rg.Brep):\r\n            return lambda b, a, tol: rg.Intersect.Intersection.BrepSurface(a, b, tol)\r\n        elif isinstance(rgObj_B, rg.Surface):\r\n            return rg.Intersect.Intersection.SurfaceSurface\r\n    raise ValueError(\"Intersection of {} and {} is not supported by this script.\".format(\r\n        rgObj_A.GetType().Name, rgObj_B.GetType().Name))\r\n\r\n\r\ndef createCurves_NoLoops(rgObj_A, rgObj_B, fTol, fMinCrvLength):\r\n    intersectionMethod = _getIntersectionMethod(rgObj_A, rgObj_B)\r\n\r\n    bSuccess, rgCrvs_SSX_WIP, rgPts_SSX = intersectionMethod(\r\n        rgObj_A,\r\n        rgObj_B,\r\n        fTol)\r\n\r\n    # At least in RhinoCommon of 7 SR10,\r\n    # even when no curves or points result, the result of\r\n    # Intersection.BrepBrep and\r\n    # Intersection.BrepSurface\r\n    # is / (may still be) True, but\r\n    # Intersection.SurfaceSurface is False.\r\n    if not bSuccess:\r\n        return\r\n\r\n    if len(rgPts_SSX) > 0:\r\n        print(\"{} points in intersection of tolerance {}.\".format(\r\n            rgPts_SSX,\r\n            fTol))\r\n\r\n    if len(rgCrvs_SSX_WIP) == 0:\r\n        return\r\n\r\n    rgCrvs_SSX = []\r\n    for c in rgCrvs_SSX_WIP:\r\n        length = c.GetLength()\r\n        if length > fMinCrvLength:\r\n            rgCrvs_SSX.append(c)\r\n\r\n    return rgCrvs_SSX\r\n\r\n\r\ndef _areCurvesAlreadyInList(cs, dss, fTol, bDebug):\r\n\r\n    # epsilon = max(0.1*fTol, 1e-6)\r\n\r\n    dss_Passing = dss\r\n\r\n    # Compare curves counts.\r\n    def getRefsWithSameCounts(es, fss):\r\n        out = []\r\n        for fs in fss:\r\n            if len(es) == len(fs):\r\n                out.append(fs)\r\n        return out\r\n\r\n    dss_Passing = getRefsWithSameCounts(cs, dss_Passing)\r\n    if not dss_Passing:\r\n        if bDebug: print(\"Curve count is new.\")\r\n        return False\r\n\r\n    if bDebug: print(\"Curve counts is already in list.\")\r\n\r\n    # Compare end points.\r\n    def getRefsWithSameEndPts(es, fss):\r\n        out = []\r\n        for fs in fss:\r\n            for e, f in zip(es, fs):\r\n                if e.PointAtStart.DistanceTo(f.PointAtStart) > fTol:\r\n                    break # to next fs.\r\n                if e.PointAtEnd.DistanceTo(f.PointAtEnd) > fTol:\r\n                    break # to next fs.\r\n            else:\r\n                # All ends match within fTol.\r\n                out.append(fs)\r\n        return out\r\n\r\n    dss_Passing = getRefsWithSameEndPts(cs, dss_Passing)\r\n    if not dss_Passing:\r\n        if bDebug: print(\"Curve end point(s) is/are new.\")\r\n        return False\r\n\r\n\r\n    if bDebug: print(\"Curve(s) with the same end point match are already in list.\")\r\n\r\n    # Compare point counts.\r\n    def getRefsWithSameCP_cts(es, fss):\r\n        out = []\r\n        for fs in fss:\r\n            for e, f in zip(es, fs):\r\n                if not isinstance(e, rg.NurbsCurve):\r\n                    if bDebug: print(\"{} found.\".format(e.GetType().Name))\r\n                    e = e.ToNurbsCurve()\r\n                if not isinstance(f, rg.NurbsCurve):\r\n                    if bDebug: print(\"{} found.\".format(f.GetType().Name))\r\n                    f = f.ToNurbsCurve()\r\n                if bDebug: print(e.Points.Count, f.Points.Count)\r\n                if e.Points.Count != f.Points.Count:\r\n                    break # to next fs.\r\n            else:\r\n                # All point counts match.\r\n                out.append(fs)\r\n        return out\r\n\r\n    dss_Passing = getRefsWithSameCP_cts(cs, dss_Passing)\r\n    if not dss_Passing:\r\n        if bDebug: print(\"Control point count is new.\")\r\n        return False\r\n\r\n\r\n    if bDebug: print(\"Control point count is already in list.\")\r\n\r\n\r\n    if bDebug: sEval = \"len(dss_Passing)\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n    return True\r\n\r\n\r\n    #Compare lengths\r\n    #for ds in dss:\r\n        #fLength_Cs = 0.0\r\n        #for c in cs:\r\n        #    f = c.GetLength()\r\n        #    fLength_Cs += f\r\n\r\n        #fLength_Ds = 0.0\r\n        #for d in ds:\r\n        #    f = d.GetLength()\r\n        #    fLength_Ds += f\r\n\r\n        #if abs(fLength_Cs - fLength_Ds) <= fTol:\r\n        #    return True\r\n\r\n\r\n        # Compare NurbsCurve forms by EpsilonEquals.\r\n        #for c, d in zip(cs, ds):\r\n        #    if c.GetType() != d.GetType():\r\n        #        break\r\n\r\n        #    nsC = c.ToNurbsCurve()\r\n        #    nsD = d.ToNurbsCurve()\r\n\r\n        #    epsEqual = nsC.EpsilonEquals(nsD, epsilon)\r\n\r\n        #    if epsEqual and (nsC.SpanCount != nsD.SpanCount):\r\n        #        raise Exception(\"NCs pass EpsilonEquals but have different span counts!\")\r\n\r\n        #    if epsEqual and (nsC.Points.Count != nsD.Points.Count):\r\n        #        raise Exception(\"NCs pass EpsilonEquals but have different control point counts!\")\r\n\r\n\r\n        #    nsC.Dispose()\r\n        #    nsD.Dispose()\r\n\r\n        #    if not epsEqual:\r\n        #        break\r\n        #else:\r\n        #    return True\r\n\r\n    return False\r\n\r\n\r\ndef _createCurves_1Set_VariousTols(rgObj_A, rgObj_B, fMaxTol, fMinTol, fMinCrvLength, bDebug):\r\n\r\n    intersectionMethod = _getIntersectionMethod(rgObj_A, rgObj_B)\r\n\r\n    fTol_Next = fMaxTol\r\n\r\n    rgCs_Res = []\r\n    fTols = []\r\n\r\n    while True:\r\n        sc.escape_test()\r\n\r\n        if not fTol_Next:\r\n            return rgCs_Res, fTols\r\n\r\n        fTol_WIP = fTol_Next\r\n        fTol_Next = fTol_WIP / 2.0\r\n\r\n        if fTol_WIP == fMinTol:\r\n            fTol_Next = None\r\n        elif fTol_Next < (fMinTol + 0.1*fMinTol):\r\n            fTol_Next = fMinTol\r\n\r\n        if bDebug: sEval = \"fTol_WIP\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n        bSuccess, rgCrvs_SSX_WIP, rgPts_SSX = intersectionMethod(\r\n            rgObj_A,\r\n            rgObj_B,\r\n            fTol_WIP)\r\n\r\n        # At least in RhinoCommon of 7 SR10,\r\n        # even when no curves or points result, the result of\r\n        # Intersection.BrepBrep and\r\n        # Intersection.BrepSurface\r\n        # is / (may still be) True, but\r\n        # Intersection.SurfaceSurface is False.\r\n        if not bSuccess:\r\n            continue\r\n            #return rgCs_Res, fTols\r\n\r\n        if len(rgPts_SSX) > 0:\r\n            print(\"{} points in intersection of tolerance {}.\".format(\r\n                rgPts_SSX,\r\n                fTol_WIP))\r\n        if len(rgCrvs_SSX_WIP) == 0:\r\n            continue\r\n\r\n\r\n        rgCrvs_SSX = []\r\n        for c in rgCrvs_SSX_WIP:\r\n            length = c.GetLength()\r\n            #if length < 1.0:\r\n            #    print(length\r\n            if length > fMinCrvLength:\r\n                rgCrvs_SSX.append(c)\r\n\r\n        #rgCrvs_SSX = rgCrvs_SSX_WIP\r\n\r\n        #for c in rgCrvs_SSX_WIP:\r\n        #    sc.doc.Objects.AddCurve(c)\r\n        #sc.doc.Views.Redraw(); 1/0\r\n\r\n        if not rgCs_Res or not _areCurvesAlreadyInList(rgCrvs_SSX, rgCs_Res, fMaxTol, bDebug):\r\n            rgCs_Res.append(rgCrvs_SSX)\r\n            fTols.append(fTol_WIP)\r\n\r\n\r\ndef _createCurves_4Sets(rgB_A, rgB_B, fMaxTol, fMinTol, fMinCrvLength, bDebug):\r\n\r\n    d_rgCs_Res = {}\r\n    d_fTols = {}\r\n\r\n    for iA, iB in (0, 0), (0, 1), (1, 0), (1, 1):\r\n\r\n        bUnder_A = bool(iA)\r\n        bUnder_B = bool(iB)\r\n\r\n        key = bool(iA), bool(iB)\r\n\r\n        rgObj_A = rgB_A.Faces[0].UnderlyingSurface() if bUnder_A else rgB_A\r\n        rgObj_B = rgB_B.Faces[0].UnderlyingSurface() if bUnder_B else rgB_B\r\n\r\n        rc = _createCurves_1Set_VariousTols(rgObj_A, rgObj_B, fMaxTol, fMinTol, fMinCrvLength, bDebug)\r\n\r\n        d_rgCs_Res[key] = rc[0]\r\n        d_fTols[key] = rc[1]\r\n\r\n    return (\r\n        d_rgCs_Res,\r\n        d_fTols)\r\n\r\n\r\ndef main():\r\n\r\n    objrefs_In = getInput()\r\n    if objrefs_In is None: return\r\n\r\n    bUseDialog = Opts.values['bUseDialog']\r\n    fTol = Opts.values['fTol']\r\n    fMinTol = Opts.values['fMinTol']\r\n    fMinCrvLength = Opts.values['fMinCrvLength']\r\n    bUnderlying1st = Opts.values['bUnderlying1st']\r\n    bUnderlying2nd = Opts.values['bUnderlying2nd']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n\r\n    if not bUseDialog:\r\n        srfA = objrefs_In[0].Face().UnderlyingSurface() if bUnderlying1st else objrefs_In[0].Face().DuplicateFace(duplicateMeshes=False)\r\n        srfB = objrefs_In[1].Face().UnderlyingSurface() if bUnderlying2nd else objrefs_In[1].Face().DuplicateFace(duplicateMeshes=False)\r\n        rgCs_Res = createCurves_NoLoops(\r\n            srfA,\r\n            srfB,\r\n            fTol,\r\n            fMinCrvLength)\r\n        if not rgCs_Res:\r\n            print(\"No valid solution.\")\r\n            return\r\n        for rgC_Res in rgCs_Res:\r\n            sc.doc.Objects.AddCurve(rgC_Res)\r\n        sc.doc.Views.Redraw()\r\n        return\r\n\r\n\r\n    rgB_ToX_A = objrefs_In[0].Face().DuplicateFace(duplicateMeshes=False)\r\n    rgB_ToX_B = objrefs_In[1].Face().DuplicateFace(duplicateMeshes=False)\r\n\r\n\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Calculating curves ...\")\r\n\r\n    rc = _createCurves_4Sets(rgB_ToX_A, rgB_ToX_B, fTol, fMinTol, fMinCrvLength, bDebug)\r\n\r\n    (\r\n        d_rgCs_Res,\r\n        d_fTols,\r\n        ) = rc\r\n\r\n\r\n    if not any(len(d_rgCs_Res[key]) for key in d_rgCs_Res):\r\n        print(\"No intersections were calculated.\")\r\n        return\r\n\r\n\r\n    form = EtoModelessForm()\r\n    form.addDataToForm(d_rgCs_Res, d_fTols)\r\n    form.Owner = Rhino.UI.RhinoEtoApp.MainWindow\r\n    form.Show()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": true
}