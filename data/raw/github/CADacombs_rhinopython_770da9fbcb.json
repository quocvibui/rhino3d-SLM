{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/xBrepFaces_createFilletSurface.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "xBrepFaces_createFilletSurface.py",
  "instruction": "180922-24: Created.\r\n190626, 1206, 200215: Modified an option default value.\r\n210218: Refactored getInput.  Removed the single-span, degree-3 bezier option.\r\n210224: Added an option.\r\n210327: Bug...",
  "code": "\"\"\"\r\n180922-24: Created.\r\n190626, 1206, 200215: Modified an option default value.\r\n210218: Refactored getInput.  Removed the single-span, degree-3 bezier option.\r\n210224: Added an option.\r\n210327: Bug fix.\r\n210411: Added bTryOtherTols.  Moved some of createBreps to the new createBrepObjects.\r\n210418: Added more printed feedback.  Modified an option default value.\r\n210923: Disabled option for bRebuildDeg5 since its code hasn't yet been implemented.\r\n210924: Added one-to-many selection option.\r\n\r\n_FilletSrf and Brep.CreateFilletSurface create surfaces that are degree 2 rational in one direction.\r\n\r\n\r\nTODO: Add code for bRebuildDeg5.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    riAddOpts = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fRadius'; keys.append(key)\r\n    values[key] = 1.0\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bMultiPickB'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    # No sticky for this since it should always default to False.\r\n\r\n    key = 'fTolerance'; keys.append(key)\r\n    values[key] = 1.0 * sc.doc.ModelAbsoluteTolerance\r\n    names[key] = \"Tol\"\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bTryOtherTols'; keys.append(key)\r\n    values[key] = False\r\n    #names[key] = \"IncludeUniquePlusMinusTols\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bRebuildDeg5'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'AcrossSrf'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Deg2Rat', 'Deg5NonRat')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bExtend'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bTrimFillets'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bUseUnderlyingSrf'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bTryOtherPickPts'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fRadius':\r\n            if cls.riOpts[key].CurrentValue < 1e-6:\r\n                Opts.riOpts[key].CurrentValue = Opts.riOpts[key].InitialValue\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key == 'fTolerance':\r\n            if cls.riOpts[key].CurrentValue < 1e-6:\r\n                Opts.riOpts[key].CurrentValue = Opts.riOpts[key].InitialValue\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        if key in cls.stickyKeys:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput_FaceA():\r\n    \"\"\"\r\n    Select BrepFace with options.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select face A\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Surface\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    while True:\r\n\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        addOption('fRadius')\r\n        addOption('bMultiPickB')\r\n        addOption('fTolerance')\r\n        addOption('bTryOtherTols')\r\n        #addOption('bRebuildDeg5')\r\n        addOption('bExtend')\r\n        addOption('bTrimFillets')\r\n        addOption('bUseUnderlyingSrf')\r\n        addOption('bTryOtherPickPts')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.Get()\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objref = go.Object(0)\r\n            go.Dispose()\r\n\r\n            sc.doc.Objects.UnselectAll()\r\n\r\n            return (\r\n                objref,\r\n                Opts.values['bMultiPickB'],\r\n                Opts.values['bEcho'],\r\n                Opts.values['bDebug'],\r\n                )\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fRadius'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef getInput_FaceB(objref_A):\r\n    \"\"\"\r\n    Select BrepFaces with options.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select face B\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Surface\r\n\r\n    rdObj_A = objref_A.Object()\r\n    compIdx_A = objref_A.GeometryComponentIndex\r\n    rdObj_A.HighlightSubObject(compIdx_A, highlight=True)\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    while True:\r\n\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        addOption('fRadius')\r\n        addOption('bMultiPickB')\r\n        addOption('fTolerance')\r\n        addOption('bTryOtherTols')\r\n        #addOption('bRebuildDeg5')\r\n        addOption('bExtend')\r\n        addOption('bTrimFillets')\r\n        addOption('bUseUnderlyingSrf')\r\n        addOption('bTryOtherPickPts')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.Get()\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            rdObj_A.HighlightSubObject(compIdx_A, highlight=False)\r\n            sc.doc.Views.Redraw()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objref_B = go.Object(0)\r\n\r\n            rdObj_B = objref_B.Object()\r\n            compIdx_B = objref_B.GeometryComponentIndex\r\n\r\n            sc.doc.Objects.UnselectAll()\r\n\r\n            if (\r\n                rdObj_B.Id == rdObj_A.Id and\r\n                compIdx_B.ComponentIndexType == compIdx_A.ComponentIndexType and\r\n                compIdx_B.Index == compIdx_A.Index\r\n            ):\r\n                rdObj_A.HighlightSubObject(compIdx_A, highlight=True)\r\n                sc.doc.Views.Redraw()\r\n                continue\r\n\r\n            go.Dispose()\r\n\r\n            rdObj_A.HighlightSubObject(compIdx_A, highlight=False)\r\n            sc.doc.Views.Redraw()\r\n\r\n            return (\r\n                objref_B,\r\n                Opts.values['fRadius'],\r\n                Opts.values['bMultiPickB'],\r\n                Opts.values['fTolerance'],\r\n                Opts.values['bTryOtherTols'],\r\n                Opts.values['bExtend'],\r\n                Opts.values['bTrimFillets'],\r\n                Opts.values['bUseUnderlyingSrf'],\r\n                Opts.values['bTryOtherPickPts'],\r\n                Opts.values['bEcho'],\r\n                Opts.values['bDebug'],\r\n                )\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fRadius'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef createBreps(rgFaceA, pt3d_A, rgFaceB, pt3d_B, fRadius, fTolerance=None, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bTryOtherTols = getOpt('bTryOtherTols')\r\n    #bRebuildDeg5 = getOpt('bRebuildDeg5')\r\n    bExtend = getOpt('bExtend')\r\n    bTrimFillets = getOpt('bTrimFillets')\r\n    bUseUnderlyingSrf = getOpt('bUseUnderlyingSrf')\r\n    bTryOtherPickPts = getOpt('bTryOtherPickPts')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n    if bUseUnderlyingSrf:\r\n        rgFaceA = rgFaceA.UnderlyingSurface().ToBrep().Faces[0] # UnderlyingSurface() is not needed.\r\n        rgFaceB = rgFaceB.UnderlyingSurface().ToBrep().Faces[0]\r\n    else:\r\n        # No change in rgFaceA or rgFaceB.\r\n        pass\r\n    \r\n    rgBs_PerCFS = []\r\n    # The following are in-sync with rgBs_PerCFS.\r\n    fTols_Out = []\r\n    areas = []\r\n    boundingBoxCenters = []\r\n\r\n    b, u, v = rgFaceA.ClosestPoint(pt3d_A)\r\n    pt2d_uvA = rg.Point2d(u, v)\r\n    b, u, v = rgFaceB.ClosestPoint(pt3d_B)\r\n    pt2d_uvB = rg.Point2d(u, v)\r\n\r\n\r\n    fTol_Nom = sc.doc.ModelAbsoluteTolerance if fTolerance is None else fTolerance\r\n\r\n\r\n    if bTryOtherTols:\r\n        fTols = fTol_Nom, 10.0*fTol_Nom, 0.1*fTol_Nom\r\n    else:\r\n        fTols = fTol_Nom,\r\n\r\n\r\n    for iT, fTol in enumerate(fTols):\r\n\r\n        rgBs_Fillet = rg.Brep.CreateFilletSurface(\r\n                face0=rgFaceA,\r\n                uv0=pt2d_uvA,\r\n                face1=rgFaceB,\r\n                uv1=pt2d_uvB,\r\n                radius=fRadius,\r\n                extend=bExtend,\r\n                tolerance=fTol\r\n                )\r\n        if not rgBs_Fillet:\r\n            if bEcho:\r\n                print \"Fillet was not created at {} tolerance using provided points.\".format(\r\n                    fTol)\r\n            continue\r\n\r\n\r\n        def getTotalArea():\r\n            total_area = 0.0\r\n            for brep in rgBs_Fillet:\r\n                a = brep.GetArea()\r\n                if not a:\r\n                    return None\r\n                total_area += a\r\n            return total_area\r\n\r\n        area_ThisTol = getTotalArea()\r\n\r\n        if area_ThisTol is None:\r\n            print \"Area could not be obtained.\"\r\n            rgBs_PerCFS.append(rgBs_Fillet)\r\n            fTols_Out.append(fTol)\r\n            areas.append(None)\r\n            boundingBoxCenters.append(None)\r\n            continue # to next tolerance.\r\n\r\n\r\n        def getBBoxCenter():\r\n            bbox_ThisTol = rg.BoundingBox.Empty\r\n            for rgB in rgBs_Fillet:\r\n                bbox = rgB.GetBoundingBox(accurate=True)\r\n                if not bbox:\r\n                    return None\r\n                bbox_ThisTol.Union(bbox)\r\n            center = bbox_ThisTol.Center\r\n            return center\r\n\r\n        center_ThisTol = getBBoxCenter()\r\n\r\n\r\n        if center_ThisTol is None:\r\n            print \"Bounding box could not be obtained.\"\r\n            rgBs_PerCFS.append(rgBs_Fillet)\r\n            fTols_Out.append(fTol)\r\n            areas.append(area_ThisTol)\r\n            boundingBoxCenters.append(None)\r\n            continue # to next tolerance.\r\n\r\n\r\n        if iT == 0:\r\n            rgBs_PerCFS.append(rgBs_Fillet)\r\n            fTols_Out.append(fTol)\r\n            areas.append(area_ThisTol)\r\n            boundingBoxCenters.append(center_ThisTol)\r\n        else:\r\n            if bDebug:\r\n                print \"Fillet with accumulative area of\" \\\r\n                    \" {} square units created at {} tolerance.\".format(\r\n                        area_ThisTol, fTol)\r\n\r\n\r\n            def matchFound():\r\n                for i in range(len(fTols_Out)):\r\n                    if abs(area_ThisTol - areas[i]) <= fTol_Nom**2:\r\n                        if center_ThisTol.DistanceTo(boundingBoxCenters[i]) <= fTol_Nom:\r\n                            return True\r\n                return False\r\n\r\n            if not matchFound():\r\n                rgBs_PerCFS.append(rgBs_Fillet)\r\n                fTols_Out.append(fTol)\r\n                areas.append(area_ThisTol)\r\n                boundingBoxCenters.append(center_ThisTol)\r\n\r\n\r\n        if not bTryOtherPickPts:\r\n            continue\r\n\r\n        # Create fillets based on using various locations of each surface.\r\n        \r\n        for pt2d_uvA in (\r\n                rg.Point2d(rgFaceA.Domain(0).Mid, rgFaceA.Domain(1).T0),\r\n                rg.Point2d(rgFaceA.Domain(0).T1, rgFaceA.Domain(1).Mid),\r\n                rg.Point2d(rgFaceA.Domain(0).Mid, rgFaceA.Domain(1).T1),\r\n                rg.Point2d(rgFaceA.Domain(0).T0, rgFaceA.Domain(1).Mid),\r\n        ):\r\n            for pt2d_uvB in (\r\n                    rg.Point2d(rgFaceB.Domain(0).Mid, rgFaceB.Domain(1).T0),\r\n                    rg.Point2d(rgFaceB.Domain(0).T1, rgFaceB.Domain(1).Mid),\r\n                    rg.Point2d(rgFaceB.Domain(0).Mid, rgFaceB.Domain(1).T1),\r\n                    rg.Point2d(rgFaceB.Domain(0).T0, rgFaceB.Domain(1).Mid),\r\n            ):\r\n                #print pt2d_uvA, pt2d_uvB\r\n                rgBs_Fillet = rg.Brep.CreateFilletSurface(\r\n                        face0=rgFaceA,\r\n                        uv0=pt2d_uvA,\r\n                        face1=rgFaceB,\r\n                        uv1=pt2d_uvB,\r\n                        radius=fRadius,\r\n                        extend=bExtend,\r\n                        tolerance=fTol\r\n                        )\r\n                if not rgBs_Fillet:\r\n                    continue\r\n\r\n                #sc.doc.Objects.AddPoint(rgFaceA.PointAt(pt2d_uvA.X, pt2d_uvA.Y))\r\n                #sc.doc.Objects.AddPoint(rgFaceB.PointAt(pt2d_uvB.X, pt2d_uvB.Y))\r\n\r\n\r\n                # Don't include any area matches.\r\n                for rgB in rgBs_Fillet:\r\n\r\n\r\n                    area = rgB.GetArea()\r\n                    if not area:\r\n                        print \"Area could not be obtained.\"\r\n                        continue\r\n\r\n                    bbox = rgB.GetBoundingBox(accurate=False)\r\n                    if not bbox:\r\n                        print \"Bounding box could not be obtained.\"\r\n                        continue\r\n                    center = bbox.Center\r\n\r\n\r\n                    def isFilletInList():\r\n                        for a in areas:\r\n                            if abs(area-a) <= sc.doc.ModelAbsoluteTolerance**2:\r\n                                # Also check the center of the bounding box before eliminating this surface.\r\n                                for c in boundingBoxCenters:\r\n                                    if center.DistanceTo(c) <= sc.doc.ModelAbsoluteTolerance:\r\n                                        return True\r\n\r\n                        return False\r\n\r\n                    if isFilletInList():\r\n                        rgB.Dispose()\r\n                        continue\r\n\r\n\r\n                    rgBs_PerCFS.append(rgBs_Fillet)\r\n                    fTols_Out.append(fTol)\r\n                    areas.append(area)\r\n                    boundingBoxCenters.append(center)\r\n        if not rgBs_PerCFS:\r\n            if bEcho: print \"No fillets were created.\"\r\n\r\n\r\n    return rgBs_PerCFS, fTols_Out\r\n\r\n\r\ndef createBrepObjects(objref_A, objref_B, fRadius, fTolerance=None, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bTryOtherTols = getOpt('bTryOtherTols')\r\n    #bRebuildDeg5 = getOpt('bRebuildDeg5')\r\n    bExtend = getOpt('bExtend')\r\n    bTrimFillets = getOpt('bTrimFillets')\r\n    bUseUnderlyingSrf = getOpt('bUseUnderlyingSrf')\r\n    bTryOtherPickPts = getOpt('bTryOtherPickPts')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\r\n\r\n    if bUseUnderlyingSrf:\r\n        # UnderlyingSurface() may not be needed.\r\n        fA = objref_A.Face().UnderlyingSurface().ToBrep().Faces[0] \r\n        fB = objref_B.Face().UnderlyingSurface().ToBrep().Faces[0]\r\n    else:\r\n        fA = objref_A.Face()\r\n        fB = objref_B.Face()\r\n\r\n    ptA = objref_A.SelectionPoint()\r\n    ptB = objref_B.SelectionPoint()\r\n\r\n    gBreps_Fillets = []\r\n\r\n\r\n    rc = createBreps(\r\n        fA,\r\n        ptA,\r\n        fB,\r\n        ptB,\r\n        fRadius=fRadius,\r\n        fTolerance=fTolerance,\r\n        bTryOtherTols=bTryOtherTols,\r\n        bExtend=bExtend,\r\n        bTrimFillets=bTrimFillets,\r\n        bUseUnderlyingSrf=bUseUnderlyingSrf,\r\n        bTryOtherPickPts=bTryOtherPickPts,\r\n        bDebug=bDebug,\r\n        )\r\n    if not rc:\r\n        print \"Fillets were not created using provided points.\"\r\n        return\r\n\r\n    rgBs_PerCFS, fTols_Ret = rc\r\n\r\n    for rgBs_ThisCFS, fTol in zip(rgBs_PerCFS, fTols_Ret):\r\n        if bDebug: print rgBs_ThisCFS, fTol\r\n\r\n        for rgB in rgBs_ThisCFS:\r\n            if bTrimFillets:\r\n                gBrep_Fillet = sc.doc.Objects.AddBrep(rgB)\r\n                if gBrep_Fillet != gBrep_Fillet.Empty:\r\n                    gBreps_Fillets.append(gBrep_Fillet)\r\n                else:\r\n                    if not bExtend and not rgB.IsSurface:\r\n                        print \"Non-extend fillet created that is trimmed.\"\r\n            else:\r\n                for f in rgB.Faces:\r\n                    gBrep_Fillet = sc.doc.Objects.AddBrep(f.ToBrep())\r\n                    if gBrep_Fillet != gBrep_Fillet.Empty:\r\n                        gBreps_Fillets.append(gBrep_Fillet)\r\n\r\n    if bEcho:\r\n        s = \"Added {} brep(s) to document\".format(len(gBreps_Fillets))\r\n\r\n        if bTryOtherTols:\r\n            s += \" of tolerance(s) [{}].\".format(','.join(str(f) for f in fTols_Ret))\r\n        else:\r\n            s += \".\"\r\n\r\n        print s\r\n\r\n    return gBreps_Fillets\r\n\r\n\r\ndef main():\r\n\r\n    if Rhino.RhinoApp.ExeVersion == 5:\r\n        print \"This script uses Brep.CreateFilletSurface that is missing from Rhino V5's RC.\"\r\n        return\r\n\r\n    rc = getInput_FaceA()\r\n    if rc is None: return\r\n    (\r\n        objref_A,\r\n        bMultiPickB,\r\n        bEcho,\r\n        bDebug,\r\n        ) = rc\r\n\r\n    while True:\r\n        sc.escape_test()\r\n\r\n        rc = getInput_FaceB(objref_A)\r\n        if rc is None: break\r\n\r\n        (\r\n            objref_B,\r\n            fRadius,\r\n            bMultiPickB,\r\n            fTolerance,\r\n            bTryOtherTols,\r\n            bExtend,\r\n            bTrimFillets,\r\n            bUseUnderlyingSrf,\r\n            bTryOtherPickPts,\r\n            bEcho,\r\n            bDebug,\r\n            ) = rc\r\n\r\n        gBreps_Fillets = createBrepObjects(\r\n            objref_A,\r\n            objref_B,\r\n            fRadius=fRadius,\r\n            fTolerance=fTolerance,\r\n            bTryOtherTols=bTryOtherTols,\r\n            bExtend=bExtend,\r\n            bTrimFillets=bTrimFillets,\r\n            bUseUnderlyingSrf=bUseUnderlyingSrf,\r\n            bTryOtherPickPts=bTryOtherPickPts,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug,\r\n            )\r\n\r\n        if not gBreps_Fillets and not bMultiPickB: return\r\n\r\n        if not bMultiPickB: break\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}