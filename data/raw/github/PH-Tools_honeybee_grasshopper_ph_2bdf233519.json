{
  "source_url": "https://github.com/PH-Tools/honeybee_grasshopper_ph/blob/c433bc8e66f3a51fd05ee4c485f4c54c03d2a569/honeybee_ph_rhino/gh_compo_io/shading/shade_solve_shading_dims.py",
  "repo": "PH-Tools/honeybee_grasshopper_ph",
  "repo_stars": 6,
  "repo_description": "Honeybe-PH plugin for Rhino / Grasshopper ",
  "license": "GPL-3.0",
  "filepath": "honeybee_ph_rhino/gh_compo_io/shading/shade_solve_shading_dims.py",
  "instruction": "GHCompo Interface: HBPH - Add Shading Dims.",
  "code": "# -*- coding: utf-8 -*-\n# -*- Python Version: 2.7 -*-\n\n\"\"\"GHCompo Interface: HBPH - Add Shading Dims.\"\"\"\n\nimport math\n\ntry:\n    from typing import Any, List, Optional, Sequence, Tuple\nexcept ImportError:\n    pass  # IronPython 2.7\n\ntry:\n    import Rhino.Geometry  # type: ignore\nexcept ImportError:\n    pass  # Outside Rhino\n\ntry:\n    from ladybug_rhino.config import angle_tolerance, tolerance\n    from ladybug_rhino.fromgeometry import from_linesegment3d, from_point3d, from_vector3d\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import ladybug_rhino:\\n\\t{}\".format(e))\ntry:\n    from ladybug_geometry.geometry3d import line, pointvector\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import ladybug_geometry:\\n\\t{}\".format(e))\n\ntry:\n    from honeybee import aperture, room\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee:\\n\\t{}\".format(e))\n\ntry:\n    from honeybee_ph.properties import aperture as hbph_aperture\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee_ph:\\n\\t{}\".format(e))\n\ntry:\n    from honeybee_ph_rhino import gh_io\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee_ph_rhino:\\n\\t{}\".format(e))\n\n\n# -----------------------------------------------------------------------------\nclass PhppShadingDims:\n    \"\"\"Dataclass for holding shading dimension info\"\"\"\n\n    def __init__(self):\n        # Horizon\n        self.h_hori = None  # type: Optional[float]\n        self.d_hori = None  # type: Optional[float]\n        self.checkline_hori = None  # type: Optional[Rhino.Geometry.Line]\n\n        # Side Reveal\n        self.o_reveal = None  # type: Optional[float]\n        self.d_reveal = None  # type: Optional[float]\n        self.checkline_r1 = None  # type: Optional[Rhino.Geometry.Line]\n        self.checkline_r2 = None  # type: Optional[Rhino.Geometry.Line]\n\n        # Overhangs\n        self.o_over = None  # type: Optional[float]\n        self.d_over = None  # type: Optional[float]\n        self.checkline_over = None  # type: Optional[Rhino.Geometry.Line]\n\n    def __str__(self):\n        return \"{}({})\".format(\n            str(self.__class__.__name__),\n            \", \".join([\"{}={}\".format(k, v) for k, v in vars(self).items()]),\n        )\n\n\ndef calc_shading_dims(_aperture, _shading_objs, _IGH, _limit=99):\n    # type: (aperture.Aperture, Sequence, gh_io.IGH, int) -> PhppShadingDims\n    \"\"\"Returns a PhppShadingDims object with all the shading dimensions found.\"\"\"\n\n    dims = PhppShadingDims()\n\n    if not _shading_objs:\n        return dims\n\n    # ----------------------------------------------------------------------\n    # Find the relevant geometry in the scene and figures out the critical dimensions from the window\n    dims.h_hori, dims.d_hori, dims.checkline_hori = find_horizon_shading(_aperture, _shading_objs, _IGH, _limit)\n    dims.d_over, dims.o_over, dims.checkline_over = find_overhang_shading(_aperture, _shading_objs, _IGH, _limit)\n    (\n        dims.o_reveal,\n        dims.d_reveal,\n        dims.checkline_r1,\n        dims.checkline_r2,\n    ) = find_reveal_shading(_aperture, _shading_objs, _IGH, _limit)\n\n    return dims\n\n\n# TODO: Refactor glazing edge finder as generic func\n\n\ndef _get_top_glazing_edge(_aperture):\n    # type (aperture.Aperture) -> Rhino.Geometry.LineCurve\n    \"\"\"Returns the center point of the top glazing edge of an HB-Aperture.\"\"\"\n\n    # -- Find the top edge of the HB-Aperture\n    edge = line.LineSegment3D.from_end_points(\n        _aperture.geometry.upper_right_corner, _aperture.geometry.upper_left_corner\n    )\n    vect_towards_center = _aperture.geometry.centroid - edge.midpoint\n    vect_towards_center = vect_towards_center.normalize()\n\n    # -- Try and get the bottom Ph-Frame, if there is one\n    # -- Move the bottom edge 'up' the width of the frame, or 0.1m if None\n    ph_frame = _aperture.properties.energy.construction.properties.ph.ph_frame\n    if ph_frame:\n        dist = ph_frame.top.width\n    else:\n        dist = 0.1\n    edge = edge.move(vect_towards_center * dist)\n\n    # -- move the bottom edge 'in' the inset distance as well\n    ap_prop_ph = _aperture.properties.ph  # type: hbph_aperture.AperturePhProperties\n    edge = edge.move(_aperture.normal.normalize() * ap_prop_ph.install_depth * -1)\n    return from_linesegment3d(edge)\n\n\ndef _get_bottom_glazing_edge(_aperture):\n    # type (aperture.Aperture) ->  Rhino.Geometry.LineCurve\n    \"\"\"Returns the center point of the bottom glazing edge of an HB-Aperture.\"\"\"\n\n    # -- Find the bottom edge of the HB-Aperture\n    edge = line.LineSegment3D.from_end_points(\n        _aperture.geometry.lower_left_corner, _aperture.geometry.lower_right_corner\n    )\n    vect_towards_center = _aperture.geometry.centroid - edge.midpoint\n    vect_towards_center = vect_towards_center.normalize()\n\n    # -- Try and get the bottom Ph-Frame, if there is one\n    # -- Move the bottom edge 'up' the width of the frame, or 0.1m if None\n    ph_frame = _aperture.properties.energy.construction.properties.ph.ph_frame\n    if ph_frame:\n        dist = ph_frame.bottom.width\n    else:\n        dist = 0.1\n    edge = edge.move(vect_towards_center * dist)\n\n    # -- move the bottom edge 'in' the inset distance as well\n    ap_prop_ph = _aperture.properties.ph  # type: hbph_aperture.AperturePhProperties\n    edge = edge.move(_aperture.normal.normalize() * ap_prop_ph.install_depth * -1)\n    return from_linesegment3d(edge)\n\n\ndef _get_left_glazing_edge(_aperture):\n    # type (aperture.Aperture) ->  Rhino.Geometry.LineCurve\n    \"\"\"Returns the center point of the left glazing edge of an HB-Aperture.\"\"\"\n\n    # -- Find the bottom edge of the HB-Aperture\n    edge = line.LineSegment3D.from_end_points(\n        _aperture.geometry.upper_left_corner, _aperture.geometry.lower_left_corner\n    )\n    vect_towards_center = _aperture.geometry.centroid - edge.midpoint\n    vect_towards_center = vect_towards_center.normalize()\n\n    # -- Try and get the bottom Ph-Frame, if there is one\n    # -- Move the bottom edge 'up' the width of the frame, or 0.1m if None\n    ph_frame = _aperture.properties.energy.construction.properties.ph.ph_frame\n    if ph_frame:\n        dist = ph_frame.left.width\n    else:\n        dist = 0.1\n    edge = edge.move(vect_towards_center * dist)\n\n    # -- move the bottom edge 'in' the inset distance as well\n    ap_prop_ph = _aperture.properties.ph  # type: hbph_aperture.AperturePhProperties\n    edge = edge.move(_aperture.normal.normalize() * ap_prop_ph.install_depth * -1)\n    return from_linesegment3d(edge)\n\n\ndef _get_right_glazing_edge(_aperture):\n    # type (aperture.Aperture) ->  Rhino.Geometry.LineCurve\n    \"\"\"Returns the center point of the right glazing edge of an HB-Aperture.\"\"\"\n\n    # -- Find the bottom edge of the HB-Aperture\n    edge = line.LineSegment3D.from_end_points(\n        _aperture.geometry.lower_right_corner, _aperture.geometry.upper_right_corner\n    )\n    vect_towards_center = _aperture.geometry.centroid - edge.midpoint\n    vect_towards_center = vect_towards_center.normalize()\n\n    # -- Try and get the bottom Ph-Frame, if there is one\n    # -- Move the bottom edge 'up' the width of the frame, or 0.1m if None\n    ph_frame = _aperture.properties.energy.construction.properties.ph.ph_frame\n    if ph_frame:\n        dist = ph_frame.right.width\n    else:\n        dist = 0.1\n    edge = edge.move(vect_towards_center * dist)\n\n    # -- move the bottom edge 'in' the inset distance as well\n    ap_prop_ph = _aperture.properties.ph  # type: hbph_aperture.AperturePhProperties\n    edge = edge.move(_aperture.normal.normalize() * ap_prop_ph.install_depth * -1)\n    return from_linesegment3d(edge)\n\n\ndef _get_glazing_center(_aperture):\n    # type (aperture.Aperture) -> Rhino.Geometry.Point3d\n    \"\"\"Return the center point of the glazing surface of an HB-Aperture.\n\n    This will be a point in the center, put pushed 'in' the \"install_depth\" amount.\n    \"\"\"\n    ap_prop_ph = _aperture.properties.ph  # type: hbph_aperture.AperturePhProperties\n    return from_point3d(_aperture.geometry.centroid.move(_aperture.normal.normalize() * ap_prop_ph.install_depth * -1))\n\n\ndef find_horizon_shading(_aperture, _shading_objs, _IGH, _limit=99):\n    # type: (aperture.Aperture, Sequence, gh_io.IGH, int) -> Tuple[Optional[float], Optional[float], Rhino.Geometry.LineCurve]\n    \"\"\"\n    Returns a tuple of the Horizon shading dims and the preview checkline.\n\n    Arguments:\n    ----------\n        _aperture: The HB Aperture object to determine the values for\n        _shading_objs: (list) A list of possible shading objects to test against\n        _IGH: (gh_io.IGH) The GH IO interface\n        _limit: (float) A number (m) to limit the shading search to. Default = 99m\n\n    Returns:\n    --------\n        Tuple\n            [0] h_hori: Distance (m) out from the glazing surface of any horizontal shading objects found\n            [1] d_hori: Distance (m) up from the base of the window to the top of any horizontal shading objects found\n            [2] check_line: (Rhino.Geometry.Line) Preview line for checking results.\n    \"\"\"\n    surface_normal = from_vector3d(_aperture.normal)\n\n    # -----------------------------------------------------------------------\n    # Find Starting Point (the bottom middle glazing-edge)\n    bottom_glazing_edge = _get_bottom_glazing_edge(_aperture)\n    shading_origin = _IGH.ghpythonlib_components.CurveMiddle(bottom_glazing_edge)\n    up_vector = _IGH.ghpythonlib_components.VectorXYZ(0, 0, 1).vector\n\n    # -----------------------------------------------------------------------\n    # Find if there are any intersection shading objects. If so, put them in a list\n    line_horizontal = _IGH.ghpythonlib_components.LineSDL(shading_origin, surface_normal, _limit)\n    horizon_shading_objs = [\n        shading_obj\n        for shading_obj in _shading_objs\n        if _IGH.ghpythonlib_components.BrepXCurve(shading_obj, line_horizontal).points != None\n    ]\n\n    # -----------------------------------------------------------------------\n    # Find any intersection Curves with the shading objects\n    line_vertical = _IGH.ghpythonlib_components.LineSDL(shading_origin, up_vector, _limit)\n    intersection_surface = _IGH.ghpythonlib_components.SumSurface(line_horizontal, line_vertical)\n    intersection_curve = []\n    intersection_points = []\n\n    for shading_obj in horizon_shading_objs:\n        if _IGH.ghpythonlib_components.BrepXBrep(shading_obj, intersection_surface).curves != None:\n            intersection_curve.append(_IGH.ghpythonlib_components.BrepXBrep(shading_obj, intersection_surface))\n    for pnt in intersection_curve:\n        pts = _IGH.ghpythonlib_components.ControlPoints(pnt).points\n        if pts:\n            intersection_points.append(pts)\n\n    # -----------------------------------------------------------------------\n    # Run the \"Top-Corner-Finder\" if there are any intersecting objects...\n    if intersection_points:\n        # Find the top/closets point for each of the objects that could possibly shade\n        key_points = []\n        for pnt in intersection_points:\n            rays = []\n            angles = []\n            if pnt:\n                for k in range(len(pnt)):\n                    rays.append(_IGH.ghpythonlib_components.Vector2Pt(shading_origin, pnt[k], False).vector)\n                    angles.append(_IGH.ghpythonlib_components.Angle(surface_normal, rays[k]).angle)\n                key_points.append(pnt[angles.index(max(angles))])\n\n        # Find the relevant highest / closest point\n        rays = []\n        angles = []\n        for i in range(len(key_points)):\n            rays.append(_IGH.ghpythonlib_components.Vector2Pt(surface_normal, key_points[i], False).vector)\n            angles.append(_IGH.ghpythonlib_components.Angle(surface_normal, rays[i]).angle)\n        key_point = key_points[angles.index(max(angles))]\n\n        # Use the point it finds to deliver the Height and Distance for the PHPP Shading Calculator\n        h_hori = key_point.Z - shading_origin.Z  # Vertical distance\n        hypotenuse = _IGH.ghpythonlib_components.Length(_IGH.ghpythonlib_components.Line(shading_origin, key_point))\n        d_hori = math.sqrt(hypotenuse**2 - h_hori**2)\n        check_line = _IGH.ghpythonlib_components.Line(shading_origin, key_point)\n    else:\n        h_hori = None\n        d_hori = None\n        check_line = line_horizontal\n\n    return h_hori, d_hori, check_line\n\n\ndef find_overhang_shading(_aperture, _shading_objs, _IGH, _limit=99):\n    # type: (aperture.Aperture, Sequence, gh_io.IGH, int) -> Tuple[Optional[float], Optional[float], Rhino.Geometry.LineCurve]\n\n    # Figure out the glass surface (inset a bit) and then\n    # find the origin point for all the subsequent shading calcs (top, middle)\n    top_glazing_edge = _get_top_glazing_edge(_aperture)\n    origin_point = _IGH.ghpythonlib_components.CurveMiddle(top_glazing_edge)\n\n    # In order to also work for windows which are not vertical, find the\n    # 'direction' from the glazing origin and the top/middle ege point\n    glazing_center = _get_glazing_center(_aperture)\n    UpVector = _IGH.ghpythonlib_components.Vector2Pt(glazing_center, origin_point, True).vector\n\n    # -----------------------------------------------------------------------\n    # First, need to filter the scene to find the objects that are 'above'\n    # the window. Create a 'test plane' that is _extents (99m) tall and 0.5m past the wall surface, test if\n    # any objects intersect that plane. If so, add them to the set of things\n    # test in the next step\n    ap_prop_ph = getattr(_aperture.properties, \"ph\")  # type: hbph_aperture.AperturePhProperties\n    depth = float(ap_prop_ph.install_depth) + 0.5\n    edge1 = _IGH.ghpythonlib_components.LineSDL(origin_point, UpVector, _limit)\n    edge2 = _IGH.ghpythonlib_components.LineSDL(origin_point, from_vector3d(_aperture.geometry.normal), depth)\n    intersectionTestPlane = _IGH.ghpythonlib_components.SumSurface(edge1, edge2)\n\n    OverhangShadingObjs = (\n        x for x in _shading_objs if _IGH.ghpythonlib_components.BrepXBrep(intersectionTestPlane, x).curves != None\n    )\n\n    # -----------------------------------------------------------------------\n    # Using the filtered set of shading objects, find the 'edges' of shading\n    # geom and then decide where the maximums shading point is\n    # Create a new 'test' plane coming off the origin (99m in both directions this time).\n    # Test to find any intersection shading objs and all their curves/points with this plane\n    HorizontalLine = _IGH.ghpythonlib_components.LineSDL(origin_point, from_vector3d(_aperture.geometry.normal), _limit)\n    VerticalLine = _IGH.ghpythonlib_components.LineSDL(origin_point, UpVector, _limit)\n\n    IntersectionSurface = _IGH.ghpythonlib_components.SumSurface(HorizontalLine, VerticalLine)\n    IntersectionCurves = (\n        _IGH.ghpythonlib_components.BrepXBrep(obj, IntersectionSurface).curves\n        for obj in OverhangShadingObjs\n        if _IGH.ghpythonlib_components.BrepXBrep(obj, IntersectionSurface).curves != None\n    )\n    IntersectionPointsList = (_IGH.ghpythonlib_components.ControlPoints(crv).points for crv in IntersectionCurves)\n    IntersectionPoints = (pt for list_of_pts in IntersectionPointsList for pt in list_of_pts)\n\n    # -----------------------------------------------------------------------\n    # If there are any intersection Points found, choose the right one to use to calc shading....\n    # Find the top/closets point for each of the objects that could possibly shade\n    smallest_angle_found = 2 * math.pi\n    key_point = None\n\n    for pt in IntersectionPoints:\n        if pt == None:\n            continue\n\n        # Protect against Zero-Length error\n\n        ray = _IGH.ghpythonlib_components.Vector2Pt(origin_point, pt, False).vector\n        if ray.Length < 0.001:\n            continue\n\n        this_ray_angle = _IGH.ghpythonlib_components.Angle(from_vector3d(_aperture.geometry.normal), ray).angle\n        if this_ray_angle < 0.001:\n            continue\n\n        if this_ray_angle <= smallest_angle_found:\n            smallest_angle_found = this_ray_angle\n            key_point = pt\n\n    # -----------------------------------------------------------------------\n    # Use the 'key point' found to deliver the Height and Distance for the PHPP Shading Calculator\n    if not key_point:\n        d_over = None\n        o_over = None\n        CheckLine = VerticalLine\n    else:\n        d_over = key_point.Z - origin_point.Z  # Vertical distance\n        Hypot = _IGH.ghpythonlib_components.Length(_IGH.ghpythonlib_components.Line(origin_point, key_point))\n        # Horizontal distance\n        o_over = math.sqrt(Hypot**2 - d_over**2)\n        CheckLine = _IGH.ghpythonlib_components.Line(origin_point, key_point)\n\n    return d_over, o_over, CheckLine\n\n\ndef find_reveal_shading(_aperture, _shading_objs, _IGH, _limit=99):\n    # type: (aperture.Aperture, Sequence, gh_io.IGH, int) -> Tuple[Optional[float], Optional[float], Rhino.Geometry.LineCurve, Rhino.Geometry.LineCurve]\n\n    # Get the starting reference points, edges\n    glazing_center = _get_glazing_center(_aperture)\n    glazing_edge_left = _get_left_glazing_edge(_aperture)\n    glazing_edge_right = _get_right_glazing_edge(_aperture)\n    aperture_normal_vector = from_vector3d(_aperture.geometry.normal)\n\n    # Create the Intersection Surface for each side\n    Side1_OriginPt = _IGH.ghpythonlib_components.CurveMiddle(glazing_edge_left)\n    Side1_NormalLine = _IGH.ghpythonlib_components.LineSDL(Side1_OriginPt, aperture_normal_vector, _limit)\n    Side1_Direction = _IGH.ghpythonlib_components.Vector2Pt(glazing_center, Side1_OriginPt, False).vector\n    Side1_HorizLine = _IGH.ghpythonlib_components.LineSDL(Side1_OriginPt, Side1_Direction, _limit)\n    Side1_IntersectionSurface = _IGH.ghpythonlib_components.SumSurface(Side1_NormalLine, Side1_HorizLine)\n\n    # Side2_OriginPt = SideMidPoints[1] #ghc.CurveMiddle(self.Edge_Left)\n    Side2_OriginPt = _IGH.ghpythonlib_components.CurveMiddle(glazing_edge_right)\n    Side2_NormalLine = _IGH.ghpythonlib_components.LineSDL(Side2_OriginPt, aperture_normal_vector, _limit)\n    Side2_Direction = _IGH.ghpythonlib_components.Vector2Pt(glazing_center, Side2_OriginPt, False).vector\n    Side2_HorizLine = _IGH.ghpythonlib_components.LineSDL(Side2_OriginPt, Side2_Direction, _limit)\n    Side2_IntersectionSurface = _IGH.ghpythonlib_components.SumSurface(Side2_NormalLine, Side2_HorizLine)\n\n    # Find any Shader Objects and put them all into a list\n    Side1_RevealShaderObjs = []\n    testStartPt = _IGH.ghpythonlib_components.Move(\n        glazing_center, _IGH.ghpythonlib_components.Amplitude(aperture_normal_vector, 0.1)\n    ).geometry  # Offsets the test line just a bit\n    # extend a line off to side 1\n    Side1_TesterLine = _IGH.ghpythonlib_components.LineSDL(testStartPt, Side1_Direction, _limit)\n    for i in range(len(_shading_objs)):\n        if _IGH.ghpythonlib_components.BrepXCurve(_shading_objs[i], Side1_TesterLine).points != None:\n            Side1_RevealShaderObjs.append(_shading_objs[i])\n\n    Side2_RevealShaderObjs = []\n    # extend a line off to side 2\n    Side2_TesterLine = _IGH.ghpythonlib_components.LineSDL(testStartPt, Side2_Direction, _limit)\n    for i in range(len(_shading_objs)):\n        if _IGH.ghpythonlib_components.BrepXCurve(_shading_objs[i], Side2_TesterLine).points != None:\n            Side2_RevealShaderObjs.append(_shading_objs[i])\n\n    # ---------------------------------------------------------------------------\n    # Calc Shading reveal dims\n    NumShadedSides = 0\n    if len(Side1_RevealShaderObjs) != 0:\n        Side1_o_reveal = CalcRevealDims(\n            _aperture,\n            Side1_RevealShaderObjs,\n            Side1_IntersectionSurface,\n            Side1_OriginPt,\n            Side1_Direction,\n            _IGH,\n        )[0]\n        Side1_d_reveal = CalcRevealDims(\n            _aperture,\n            Side1_RevealShaderObjs,\n            Side1_IntersectionSurface,\n            Side1_OriginPt,\n            Side1_Direction,\n            _IGH,\n        )[1]\n        Side1_CheckLine = CalcRevealDims(\n            _aperture,\n            Side1_RevealShaderObjs,\n            Side1_IntersectionSurface,\n            Side1_OriginPt,\n            Side1_Direction,\n            _IGH,\n        )[2]\n        NumShadedSides = NumShadedSides + 1\n    else:\n        Side1_o_reveal = None\n        Side1_d_reveal = None\n        Side1_CheckLine = Side1_HorizLine\n\n    if len(Side2_RevealShaderObjs) != 0:\n        Side2_o_reveal = CalcRevealDims(\n            _aperture,\n            Side2_RevealShaderObjs,\n            Side2_IntersectionSurface,\n            Side2_OriginPt,\n            Side2_Direction,\n            _IGH,\n        )[0]\n        Side2_d_reveal = CalcRevealDims(\n            _aperture,\n            Side2_RevealShaderObjs,\n            Side2_IntersectionSurface,\n            Side2_OriginPt,\n            Side2_Direction,\n            _IGH,\n        )[1]\n        Side2_CheckLine = CalcRevealDims(\n            _aperture,\n            Side2_RevealShaderObjs,\n            Side2_IntersectionSurface,\n            Side2_OriginPt,\n            Side2_Direction,\n            _IGH,\n        )[2]\n        NumShadedSides = NumShadedSides + 1\n    else:\n        Side2_o_reveal = None\n        Side2_d_reveal = None\n        Side2_CheckLine = Side2_HorizLine\n\n    #\n    #\n    #\n    # TODO: how to handel asymmetrical reveals????\n\n    # (Side1_o_reveal + Side2_o_reveal )/ max(1,NumShadedSides)\n    o_reveal = Side1_o_reveal\n    # (Side1_d_reveal + Side2_d_reveal )/ max(1,NumShadedSides)\n    d_reveal = Side1_d_reveal\n\n    #\n    #\n    #\n    #\n    #\n\n    return o_reveal, d_reveal, Side1_CheckLine, Side2_CheckLine\n\n\ndef CalcRevealDims(_aperture, _shader_objs, _intersection_surface, _reference_pt, _direction_vector, _IGH):\n    # type: (aperture.Aperture, Sequence, Any, Rhino.Geometry.Point3d, Rhino.Geometry.Vector3d, gh_io.IGH) -> Tuple[float, float, Rhino.Geometry.LineCurve]\n\n    # Test shading objects for their edge points\n    Side_IntersectionCurve = []\n    Side_IntersectionPoints = []\n    for i in range(len(_shader_objs)):  # This is the list of shading objects to filter\n        if _IGH.ghpythonlib_components.BrepXBrep(_shader_objs[i], _intersection_surface).curves != None:\n            Side_IntersectionCurve.append(\n                _IGH.ghpythonlib_components.BrepXBrep(_shader_objs[i], _intersection_surface).curves\n            )\n    for i in range(len(Side_IntersectionCurve)):\n        for k in range(len(_IGH.ghpythonlib_components.ControlPoints(Side_IntersectionCurve[i]).points)):\n            Side_IntersectionPoints.append(\n                _IGH.ghpythonlib_components.ControlPoints(Side_IntersectionCurve[i]).points[k]\n            )\n\n    # Find the top/closets point for each of the objects that could possibly shade\n    Side_KeyPoints = []\n    Side_Rays = []\n    Side_Angles = []\n    for i in range(len(Side_IntersectionPoints)):\n        if _reference_pt != Side_IntersectionPoints[i]:\n            Ray = _IGH.ghpythonlib_components.Vector2Pt(_reference_pt, Side_IntersectionPoints[i], False).vector\n            Angle = math.degrees(_IGH.ghpythonlib_components.Angle(from_vector3d(_aperture.geometry.normal), Ray).angle)\n            if Angle < 89.9:\n                Side_Rays.append(Ray)\n                Side_Angles.append(float(Angle))\n                Side_KeyPoints.append(Side_IntersectionPoints[i])\n    Side_KeyPoint = Side_KeyPoints[Side_Angles.index(min(Side_Angles))]\n    Side_KeyRay = Side_Rays[Side_Angles.index(min(Side_Angles))]\n\n    # use the Key point found to calculate the Distances for the PHPP Shading Calculator\n    Side_Hypot = _IGH.ghpythonlib_components.Length(_IGH.ghpythonlib_components.Line(_reference_pt, Side_KeyPoint))\n    Deg = _IGH.ghpythonlib_components.Angle(_direction_vector, Side_KeyRay).angle  # note this is in Radians\n    Side_o_reveal = math.sin(Deg) * Side_Hypot\n    Side_d_reveal = math.sqrt(Side_Hypot**2 - Side_o_reveal**2)\n    Side_CheckLine = _IGH.ghpythonlib_components.Line(_reference_pt, Side_KeyPoint)\n\n    return (Side_o_reveal, Side_d_reveal, Side_CheckLine)\n\n\n# -----------------------------------------------------------------------------\n# -- Component Interface\nclass GHCompo_SolveShadingDims(object):\n    def __init__(self, _IGH, _shading_surfaces, _hb_rooms, _run):\n        # type: (gh_io.IGH, List, List[room.Room], bool) -> None\n        self.IGH = _IGH\n        self.shading_surfaces = _shading_surfaces\n        self.hb_rooms = _hb_rooms\n        self.run_solver = _run\n\n    def run(self):\n        # type: () -> Tuple[List[Rhino.Geometry.Line], List[room.Room]]\n        # -- Find shading objects and dimensions\n        checklines_ = []\n        hb_rooms_ = [rm.duplicate() for rm in self.hb_rooms]\n        if self.run_solver:\n            for room in hb_rooms_:\n                for face in room.faces:\n                    for hb_aperture in face.apertures:\n                        shading_dims = calc_shading_dims(hb_aperture, self.shading_surfaces, self.IGH)\n\n                        # -- Create a new HBPH-Shading Dims and store all the info\n                        hbph_shading_dims_obj = hbph_aperture.ShadingDimensions()\n\n                        hbph_shading_dims_obj.d_hori = shading_dims.d_hori\n                        hbph_shading_dims_obj.h_hori = shading_dims.h_hori\n                        hbph_shading_dims_obj.d_reveal = shading_dims.d_reveal\n                        hbph_shading_dims_obj.o_reveal = shading_dims.o_reveal\n                        hbph_shading_dims_obj.d_over = shading_dims.d_over\n                        hbph_shading_dims_obj.o_over = shading_dims.o_over\n\n                        # -- Add the new shading into the HB-Ap properties.ph\n                        hb_aperture.properties.ph.shading_dimensions = hbph_shading_dims_obj\n\n                        # -- Also set the winter / summer factors None\n                        hb_aperture.properties.ph.winter_shading_factor = None\n                        hb_aperture.properties.ph.summer_shading_factor = None\n\n                        # -- Pull out the checklines for error-checking\n                        checklines_.append(shading_dims.checkline_hori)\n                        checklines_.append(shading_dims.checkline_over)\n                        checklines_.append(shading_dims.checkline_r1)\n                        checklines_.append(shading_dims.checkline_r2)\n\n        return (checklines_, hb_rooms_)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}