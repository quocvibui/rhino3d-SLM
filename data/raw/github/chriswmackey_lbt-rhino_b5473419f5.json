{
  "source_url": "https://github.com/chriswmackey/lbt-rhino/blob/d650b6631f4a5708f4472427d076c2343c569ac2/libraries/ladybug_rhino/bakeobjects.py",
  "repo": "chriswmackey/lbt-rhino",
  "repo_stars": 0,
  "repo_description": "A set of Rhino scripts that run Ladybug Tools as commands.",
  "license": "AGPL-3.0",
  "filepath": "libraries/ladybug_rhino/bakeobjects.py",
  "instruction": "Functions to bake entire Ladybug objects into the Rhino scene.",
  "code": "\"\"\"Functions to bake entire Ladybug objects into the Rhino scene.\n\nThe methods here are intended to help translate groups of geometry that are\ncommonly generated by several objects in Ladybug core (ie. legends, compasses,\nvisualization sets, etc.)\n\"\"\"\nimport json\n\nfrom ladybug_geometry.geometry2d import Vector2D, Point2D, Ray2D, LineSegment2D, \\\n    Arc2D, Polyline2D, Polygon2D, Mesh2D\nfrom ladybug_geometry.geometry3d import Vector3D, Point3D, Ray3D, LineSegment3D, \\\n    Arc3D, Polyline3D, Plane, Mesh3D, Face3D, Polyface3D, Sphere, Cone, Cylinder\nfrom ladybug.graphic import GraphicContainer\nfrom ladybug_display.geometry2d import DisplayVector2D, DisplayPoint2D, \\\n    DisplayRay2D, DisplayLineSegment2D, DisplayPolyline2D, DisplayArc2D, \\\n    DisplayPolygon2D, DisplayMesh2D\nfrom ladybug_display.geometry3d import DisplayVector3D, DisplayPoint3D, \\\n    DisplayRay3D, DisplayPlane, DisplayLineSegment3D, DisplayPolyline3D, DisplayArc3D, \\\n    DisplayFace3D, DisplayMesh3D, DisplayPolyface3D, DisplaySphere, DisplayCone, \\\n    DisplayCylinder, DisplayText3D\nfrom ladybug_display.visualization import AnalysisGeometry\n\nfrom .config import units_system\nfrom .color import color_to_color\nfrom .bakegeometry import bake_point2d, bake_vector2d, bake_ray2d, \\\n    bake_linesegment2d, bake_arc2d, bake_polygon2d, bake_polyline2d, bake_mesh2d, \\\n    bake_point3d, bake_vector3d, bake_ray3d, bake_linesegment3d, bake_plane, \\\n    bake_arc3d, bake_polyline3d, bake_mesh3d, bake_face3d, bake_polyface3d, \\\n    bake_sphere, bake_cone, bake_cylinder, _get_layer, _get_attributes\nfrom .bakedisplay import bake_display_point2d, bake_display_vector2d, \\\n    bake_display_ray2d, bake_display_linesegment2d, bake_display_arc2d, \\\n    bake_display_polygon2d, bake_display_polyline2d, bake_display_mesh2d, \\\n    bake_display_text3d, bake_display_vector3d, bake_display_point3d, \\\n    bake_display_ray3d, bake_display_linesegment3d, bake_display_arc3d, \\\n    bake_display_polyline3d, bake_display_plane, bake_display_mesh3d, \\\n    bake_display_face3d, bake_display_polyface3d, bake_display_sphere, \\\n    bake_display_cone, bake_display_cylinder\n\ntry:\n    import System\nexcept ImportError as e:\n    raise ImportError(\"Failed to import Windows/.NET libraries\\n{}\".format(e))\n\ntry:\n    import Rhino.DocObjects as docobj\n    from Rhino import RhinoDoc as rhdoc\nexcept ImportError as e:\n    raise ImportError(\"Failed to import Rhino document attributes.\\n{}\".format(e))\n\nBAKE_MAPPER = {\n    Vector2D: bake_vector2d,\n    Point2D: bake_point2d,\n    Ray2D: bake_ray2d,\n    LineSegment2D: bake_linesegment2d,\n    Arc2D: bake_arc2d,\n    Polyline2D: bake_polyline2d,\n    Polygon2D: bake_polygon2d,\n    Mesh2D: bake_mesh2d,\n    Vector3D: bake_vector3d,\n    Point3D: bake_point3d,\n    Ray3D: bake_ray3d,\n    LineSegment3D: bake_linesegment3d,\n    Arc3D: bake_arc3d,\n    Polyline3D: bake_polyline3d,\n    Plane: bake_plane,\n    Mesh3D: bake_mesh3d,\n    Face3D: bake_face3d,\n    Polyface3D: bake_polyface3d,\n    Sphere: bake_sphere,\n    Cone: bake_cone,\n    Cylinder: bake_cylinder,\n    DisplayVector2D: bake_display_vector2d,\n    DisplayPoint2D: bake_display_point2d,\n    DisplayRay2D: bake_display_ray2d,\n    DisplayLineSegment2D: bake_display_linesegment2d,\n    DisplayPolyline2D: bake_display_polyline2d,\n    DisplayArc2D: bake_display_arc2d,\n    DisplayPolygon2D: bake_display_polygon2d,\n    DisplayMesh2D: bake_display_mesh2d,\n    DisplayVector3D: bake_display_vector3d,\n    DisplayPoint3D: bake_display_point3d,\n    DisplayRay3D: bake_display_ray3d,\n    DisplayPlane: bake_display_plane,\n    DisplayLineSegment3D: bake_display_linesegment3d,\n    DisplayPolyline3D: bake_display_polyline3d,\n    DisplayArc3D: bake_display_arc3d,\n    DisplayFace3D: bake_display_face3d,\n    DisplayMesh3D: bake_display_mesh3d,\n    DisplayPolyface3D: bake_display_polyface3d,\n    DisplaySphere: bake_display_sphere,\n    DisplayCone: bake_display_cone,\n    DisplayCylinder: bake_display_cylinder,\n    DisplayText3D: bake_display_text3d\n}\n\n\ndef bake_legend(legend, layer_name=None):\n    \"\"\"Add a Ladybug Legend object to the Rhino scene.\n\n    Args:\n        legend: A Ladybug Legend object to be added to the Rhino scene.\n        layer_name: Optional text string for the layer name on which to place the\n            legend. If None, text will be added to the current layer.\n\n    Returns:\n        A list of IDs that point to the objects in the Rhino scene in the following\n        order:\n\n        -   legend_mesh -- A colored mesh for the legend.\n\n        -   legend_title -- A text object for the legend title.\n\n        -   legend_text -- Text objects for the rest of the legend text.\n    \"\"\"\n    # bake the legend mesh\n    legend_mesh = bake_mesh3d(legend.segment_mesh, layer_name)\n    # translate the legend text\n    _height = legend.legend_parameters.text_height\n    _font = legend.legend_parameters.font\n    if legend.legend_parameters.continuous_legend is False:\n        legend_text = [\n            DisplayText3D(txt, loc, _height, None, _font, 'Left', 'Bottom')\n            for txt, loc in zip(legend.segment_text, legend.segment_text_location)]\n    elif legend.legend_parameters.vertical is True:\n        legend_text = [\n            DisplayText3D(txt, loc, _height, None, _font, 'Left', 'Center')\n            for txt, loc in zip(legend.segment_text, legend.segment_text_location)]\n    else:\n        legend_text = [\n            DisplayText3D(txt, loc, _height, None, _font, 'Center', 'Bottom')\n            for txt, loc in zip(legend.segment_text, legend.segment_text_location)]\n    legend_title = DisplayText3D(\n        legend.title, legend.title_location, _height, None, _font)\n    legend_text.insert(0, legend_title)\n    # bake the text objects\n    legend_text_guids = []\n    for txt_obj in legend_text:\n        legend_text_guids.append(bake_display_text3d(txt_obj, layer_name))\n    return [legend_mesh] + legend_text_guids\n\n\ndef bake_analysis(analysis, layer_name=None, bake_3d_legend=False,\n                  min_point=None, max_point=None):\n    \"\"\"Add a Ladybug Display AnalysisGeometry object to the Rhino scene.\n\n    Args:\n        analysis: A Ladybug Display AnalysisGeometry object to be added to\n            the Rhino scene.\n        layer_name: Optional text string for the parent layer name on which to\n            place the AnalysisGeometry. The actual layer of the context will\n            always have a name that aligns with the AnalysisGeometry.display_name.\n        bake_3d_legend: A Boolean to note whether the AnalysisGeometry should\n            be baked with 3D legends for any AnalysisGeometries it\n            includes. (Default: False).\n        min_point: An optional Point3D to override the default min point\n            that are used to generate the legend. (Default: None).\n        max_point: An optional Point3D to override the default max point\n            that are used to generate the legend. (Default: None).\n\n    Returns:\n        A list of IDs that point to the objects in the Rhino scene.\n    \"\"\"\n    doc = rhdoc.ActiveDoc\n    # get attributes corresponding to the layer\n    layer_name = analysis.display_name if layer_name is None else \\\n        '{}::{}'.format(layer_name, analysis.display_name)\n    min_pt = analysis.min_point if min_point is None else min_point\n    max_pt = analysis.max_point if max_point is None else max_point\n    # generate the colors that correspond to the values\n    obj_ids = []\n    for i, data in enumerate(analysis.data_sets):\n        # get properties used for all analysis geometries\n        objs_to_group = []\n        graphic = GraphicContainer(\n            data.values, min_pt, max_pt,\n            data.legend_parameters, data.data_type, data.unit)\n        colors = graphic.value_colors\n        sub_layer_name = layer_name if data.data_type is None else \\\n            '{}::{}'.format(layer_name, data.data_type.name)\n        layer_index = _get_layer(sub_layer_name)\n        # translate the analysis geometry using the matching method\n        if analysis.matching_method == 'faces':\n            c_count = 0\n            for mesh in analysis.geometry:\n                mesh.colors = colors[c_count:c_count + len(mesh.faces)]\n                c_count += len(mesh.faces)\n                bake_func = bake_mesh3d if isinstance(mesh, Mesh3D) else bake_mesh2d\n                objs_to_group.append(bake_func(mesh, layer_name=layer_index))\n        elif analysis.matching_method == 'vertices':\n            c_count = 0\n            for mesh in analysis.geometry:\n                mesh.colors = colors[c_count:c_count + len(mesh.vertices)]\n                c_count += len(mesh.vertices)\n                bake_func = bake_mesh3d if isinstance(mesh, Mesh3D) else bake_mesh2d\n                objs_to_group.append(bake_func(mesh, layer_name=layer_index))\n        else:  # one color per geometry object\n            bake_func = BAKE_MAPPER[analysis.geometry[0].__class__]\n            for geo_obj, col in zip(analysis.geometry, colors):\n                attrib = _get_attributes(layer_index)\n                attrib.ColorSource = docobj.ObjectColorSource.ColorFromObject\n                attrib.ObjectColor = color_to_color(col)\n                objs_to_group.append(bake_func(geo_obj, attributes=attrib))\n        # group the objects, and add JSON of values to layer user data\n        group_table = doc.Groups  # group table\n        group_table.Add(sub_layer_name, objs_to_group)\n        layer_table = doc.Layers  # layer table\n        layer_obj = layer_table[layer_index]\n        layer_obj.UserDictionary.Set('vis_data', json.dumps(data.to_dict()))\n        layer_obj.UserDictionary.Set('guids', System.Array[System.Guid](objs_to_group))\n        if i != analysis.active_data:  # hide the inactive data layer\n            layer_obj.IsVisible = False\n        # add geometry to the global list and bake the legend if requested\n        obj_ids.extend(objs_to_group)\n        if bake_3d_legend:\n            obj_ids.extend(bake_legend(graphic.legend, layer_index))\n    # hide the layer if it is hidden\n    if analysis.hidden:\n        layer_table = doc.Layers  # layer table\n        layer_index = _get_layer(layer_name)\n        layer_obj = layer_table[layer_index]\n        layer_obj.IsVisible = False\n    return obj_ids\n\n\ndef bake_context(context, layer_name=None):\n    \"\"\"Add a Ladybug Display ContextGeometry object to the Rhino scene.\n\n    Args:\n        context: A Ladybug Display ContextGeometry object to be added to\n            the Rhino scene.\n        layer_name: Optional text string for the parent layer name on which to\n            place the ContextGeometry. The actual layer of the context will\n            always have a name that aligns with the ContextGeometry.display_name.\n\n    Returns:\n        A list of IDs that point to the objects in the Rhino scene.\n    \"\"\"\n    doc = rhdoc.ActiveDoc\n    # get attributes corresponding to the layer\n    layer_name = context.display_name if layer_name is None else \\\n        '{}::{}'.format(layer_name, context.display_name)\n    layer_index = _get_layer(layer_name)\n    # hide the layer if it is hidden\n    if context.hidden:\n        layer_table = doc.Layers  # layer table\n        layer_obj = layer_table[layer_index]\n        layer_obj.IsVisible = False\n    # loop through the objects and add them to the scene\n    obj_ids = []\n    for geo_obj in context.geometry:\n        bake_func = BAKE_MAPPER[geo_obj.__class__]\n        obj_ids.append(bake_func(geo_obj, layer_index))\n    return obj_ids\n\n\ndef bake_visualization_set(vis_set, bake_3d_legend=False):\n    \"\"\"Add a Ladybug Display VisualizationSet object to the Rhino scene.\n\n    Args:\n        context_geometry: A Ladybug VisualizationSet object to be added to\n            the Rhino scene.\n        bake_3d_legend: A Boolean to note whether the VisualizationSet should\n            be baked with 3D legends for any AnalysisGeometries it\n            includes. (Default: False).\n\n    Returns:\n        A list of IDs that point to the objects in the Rhino scene.\n    \"\"\"\n    # convert the visualization set to model units if necessary\n    units_sys = units_system()\n    if vis_set.units is not None and units_sys is not None \\\n            and vis_set.units != units_sys:\n        vis_set.convert_to_units(units_sys)\n    # bake all of the geometries\n    obj_ids = []\n    for geo in vis_set.geometry:\n        if isinstance(geo, AnalysisGeometry):  # translate it as AnalysisGeometry\n            a_objs = bake_analysis(\n                geo, vis_set.display_name, bake_3d_legend,\n                vis_set.min_point, vis_set.max_point)\n            obj_ids.extend(a_objs)\n        else:  # translate it as ContextGeometry\n            obj_ids.extend(bake_context(geo, vis_set.display_name))\n    return obj_ids\n",
  "language": "python",
  "imports": [
    "Rhino"
  ],
  "has_docstring": true
}