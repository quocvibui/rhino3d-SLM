{
  "source_url": "https://github.com/HathorNetwork/hathor-core/blob/23f26cadf706a0bd36d0f26e43d95d7ce6a8e26b/hathor/transaction/scripts/opcode.py",
  "repo": "HathorNetwork/hathor-core",
  "repo_stars": 91,
  "repo_description": "Hathor coreÂ is the official and reference client for operating a full node in Hathor Network.",
  "license": "Apache-2.0",
  "filepath": "hathor/transaction/scripts/opcode.py",
  "instruction": "Copyright 2023 Hathor Labs Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.",
  "code": "#  Copyright 2023 Hathor Labs\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\nimport datetime\nimport struct\nfrom enum import IntEnum\nfrom typing import Callable\n\nfrom cryptography.exceptions import InvalidSignature\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import ec\n\nfrom hathor.conf.get_settings import get_global_settings\nfrom hathor.crypto.util import (\n    get_address_b58_from_bytes,\n    get_hash160,\n    get_public_key_from_bytes_compressed,\n    is_pubkey_compressed,\n)\nfrom hathor.transaction.exceptions import (\n    EqualVerifyFailed,\n    InvalidScriptError,\n    InvalidStackData,\n    MissingStackItems,\n    OracleChecksigFailed,\n    ScriptError,\n    TimeLocked,\n    VerifyFailed,\n)\nfrom hathor.transaction.scripts.execute import (\n    Stack,\n    UtxoScriptExtras,\n    binary_to_int,\n    decode_opn,\n    get_data_value,\n    get_script_op,\n)\nfrom hathor.transaction.scripts.script_context import ScriptContext\n\n\nclass OpcodesVersion(IntEnum):\n    V1 = 1\n    V2 = 2\n\n\nclass Opcode(IntEnum):\n    OP_0 = 0x50\n    OP_1 = 0x51\n    OP_2 = 0x52\n    OP_3 = 0x53\n    OP_4 = 0x54\n    OP_5 = 0x55\n    OP_6 = 0x56\n    OP_7 = 0x57\n    OP_8 = 0x58\n    OP_9 = 0x59\n    OP_10 = 0x5a\n    OP_11 = 0x5b\n    OP_12 = 0x5c\n    OP_13 = 0x5d\n    OP_14 = 0x5e\n    OP_15 = 0x5f\n    OP_16 = 0x60\n    OP_DUP = 0x76\n    OP_EQUAL = 0x87\n    OP_EQUALVERIFY = 0x88\n    OP_CHECKSIG = 0xAC\n    OP_HASH160 = 0xA9\n    OP_PUSHDATA1 = 0x4C\n    OP_GREATERTHAN_TIMESTAMP = 0x6F\n    OP_CHECKMULTISIG = 0xAE\n    OP_CHECKDATASIG = 0xBA\n    OP_DATA_STREQUAL = 0xC0\n    OP_DATA_GREATERTHAN = 0xC1\n    OP_FIND_P2PKH = 0xD0\n    OP_DATA_MATCH_VALUE = 0xD1\n\n    @classmethod\n    def is_pushdata(cls, opcode: int) -> bool:\n        \"\"\" Check if `opcode` represents an operation of pushing data on stack\n        \"\"\"\n        if 1 <= opcode <= 75:\n            # case: push [1,75] bytes on stack (op_pushdata)\n            return True\n        elif cls.OP_0 <= opcode <= cls.OP_16:\n            # case: push integer on stack (op_integer)\n            return True\n        elif opcode == cls.OP_PUSHDATA1:\n            # case: op_pushdata1\n            return True\n        # ...Any other case\n        return False\n\n    @classmethod\n    def is_valid_opcode(cls, opcode: int) -> bool:\n        \"\"\" Check if `opcode` is valid\n            - check for pushdata first to validate unconventional opcodes for data\n            - check for conventional opcode\n        \"\"\"\n        if cls.is_pushdata(opcode):\n            return True\n        try:\n            cls(opcode)\n        except ValueError:\n            return False\n        else:\n            return True\n\n\ndef op_pushdata(position: int, full_data: bytes, stack: Stack) -> int:\n    \"\"\"Pushes to stack when data is up to 75 bytes\n\n    :param position: current position we're reading from full_data\n    :type input_data: int\n\n    :param full_data: input data + output script combined\n    :type full_data: bytes\n\n    :param stack: the stack used when evaluating the script\n    :type stack: list[]\n\n    :raises OutOfData: if data length to read is larger than what's available\n\n    :return: new position to be read from full_data\n    :rtype: int\n    \"\"\"\n\n    length, new_pos = get_script_op(position, full_data, stack)\n    assert length <= 75\n    return new_pos\n\n\ndef op_pushdata1(position: int, full_data: bytes, stack: Stack) -> int:\n    \"\"\"Pushes data to stack; next byte contains number of bytes to be pushed\n\n    :param position: current position we're reading from full_data\n    :type input_data: int\n\n    :param full_data: input data + output script combined\n    :type full_data: bytes\n\n    :param stack: the stack used when evaluating the script\n    :type stack: list[]\n\n    :raises OutOfData: if data length to read is larger than what's available\n\n    :return: new position to be read from full_data\n    :rtype: int\n    \"\"\"\n    opcode, new_pos = get_script_op(position, full_data, stack)\n    assert opcode == Opcode.OP_PUSHDATA1\n    return new_pos\n\n\ndef op_dup(context: ScriptContext) -> None:\n    \"\"\"Duplicates item on top of stack\n\n    :param stack: the stack used when evaluating the script\n    :type stack: list[]\n\n    :raises MissingStackItems: if there's no element on stack\n    \"\"\"\n    if not len(context.stack):\n        raise MissingStackItems('OP_DUP: empty stack')\n    context.stack.append(context.stack[-1])\n\n\ndef op_greaterthan_timestamp(context: ScriptContext) -> None:\n    \"\"\"Check whether transaction's timestamp is greater than the top of stack\n\n    The top of stack must be a big-endian u32int.\n\n    :param stack: the stack used when evaluating the script\n    :type stack: list[]\n\n    :raises MissingStackItems: if there's no element on stack\n    \"\"\"\n    if not len(context.stack):\n        raise MissingStackItems('OP_GREATERTHAN_TIMESTAMP: empty stack')\n    buf = context.stack.pop()\n    assert isinstance(buf, bytes)\n    (timelock,) = struct.unpack('!I', buf)\n    assert isinstance(context.extras, UtxoScriptExtras)\n    if context.extras.tx.timestamp <= timelock:\n        raise TimeLocked('The output is locked until {}'.format(\n            datetime.datetime.fromtimestamp(timelock).strftime(\"%m/%d/%Y %I:%M:%S %p\")))\n\n\ndef op_equalverify(context: ScriptContext) -> None:\n    \"\"\"Verifies top 2 elements from stack are equal\n\n    :param stack: the stack used when evaluating the script\n    :type stack: list[]\n\n    :raises MissingStackItems: if there aren't 2 element on stack\n    :raises EqualVerifyFailed: items don't match\n    \"\"\"\n    if len(context.stack) < 2:\n        raise MissingStackItems('OP_EQUALVERIFY: need 2 elements on stack, currently {}'.format(len(context.stack)))\n    op_equal(context)\n    is_equal = context.stack.pop()\n    if not is_equal:\n        raise EqualVerifyFailed('Failed to verify if elements are equal')\n\n\ndef op_equal(context: ScriptContext) -> None:\n    \"\"\"Verifies top 2 elements from stack are equal\n\n    In case they are the same, we push 1 to the stack and push 0 if they are different\n\n    :param stack: the stack used when evaluating the script\n    :type stack: list[]\n    \"\"\"\n    if len(context.stack) < 2:\n        raise MissingStackItems('OP_EQUAL: need 2 elements on stack, currently {}'.format(len(context.stack)))\n    elem1 = context.stack.pop()\n    elem2 = context.stack.pop()\n    assert isinstance(elem1, bytes)\n    assert isinstance(elem2, bytes)\n    if elem1 == elem2:\n        context.stack.append(1)\n    else:\n        context.stack.append(0)\n        context.logs.append('OP_EQUAL: failed. elements: {} {}'.format(elem1.hex(), elem2.hex()))\n\n\ndef op_checksig(context: ScriptContext) -> None:\n    \"\"\"Verifies public key and signature match. Expects public key to be on top of stack, followed\n    by signature. If they match, put 1 on stack (meaning True); otherwise, push 0 (False)\n\n    :param stack: the stack used when evaluating the script\n    :type stack: list[]\n\n    :raises MissingStackItems: if there aren't 2 element on stack\n    :raises ScriptError: if pubkey on stack is not a compressed public key\n\n    :return: if they don't match, return error message\n    :rtype: string\n    \"\"\"\n    if len(context.stack) < 2:\n        raise MissingStackItems('OP_CHECKSIG: need 2 elements on stack, currently {}'.format(len(context.stack)))\n    pubkey = context.stack.pop()\n    signature = context.stack.pop()\n    assert isinstance(pubkey, bytes)\n    assert isinstance(signature, bytes)\n\n    if not is_pubkey_compressed(pubkey):\n        raise ScriptError('OP_CHECKSIG: pubkey is not a compressed public key')\n    try:\n        public_key = get_public_key_from_bytes_compressed(pubkey)\n    except ValueError as e:\n        # pubkey is not compressed public key\n        raise ScriptError('OP_CHECKSIG: pubkey is not a public key') from e\n    try:\n        public_key.verify(signature, context.extras.tx.get_sighash_all_data(), ec.ECDSA(hashes.SHA256()))\n        # valid, push true to stack\n        context.stack.append(1)\n    except InvalidSignature:\n        # invalid, push false to stack\n        context.stack.append(0)\n        context.logs.append('OP_CHECKSIG: failed')\n\n\ndef op_hash160(context: ScriptContext) -> None:\n    \"\"\"Top stack item is hashed twice: first with SHA-256 and then with RIPEMD-160.\n    Result is pushed back to stack.\n\n    :param stack: the stack used when evaluating the script\n    :type stack: list[]\n\n    :raises MissingStackItems: if there's no element on stack\n    \"\"\"\n    if not len(context.stack):\n        raise MissingStackItems('OP_HASH160: empty stack')\n    elem1 = context.stack.pop()\n    assert isinstance(elem1, bytes)\n    new_elem = get_hash160(elem1)\n    context.stack.append(new_elem)\n\n\ndef op_checkdatasig(context: ScriptContext) -> None:\n    \"\"\"Verifies public key, signature and data match. Expects public key to be on top of stack, followed\n    by signature and data. If they match, put data on stack; otherwise, fail.\n\n    :param stack: the stack used when evaluating the script\n    :type stack: list[]\n\n    :raises MissingStackItems: if there aren't 3 element on stack\n    :raises OracleChecksigFailed: invalid signature, given data and public key\n    \"\"\"\n    if len(context.stack) < 3:\n        raise MissingStackItems('OP_CHECKDATASIG: need 3 elements on stack, currently {}'.format(len(context.stack)))\n    pubkey = context.stack.pop()\n    signature = context.stack.pop()\n    data = context.stack.pop()\n    assert isinstance(pubkey, bytes)\n    assert isinstance(signature, bytes)\n    assert isinstance(data, bytes)\n\n    if not is_pubkey_compressed(pubkey):\n        raise ScriptError('OP_CHECKDATASIG: pubkey is not a compressed public key')\n    try:\n        public_key = get_public_key_from_bytes_compressed(pubkey)\n    except ValueError as e:\n        # pubkey is not compressed public key\n        raise ScriptError('OP_CHECKDATASIG: pubkey is not a public key') from e\n    try:\n        public_key.verify(signature, data, ec.ECDSA(hashes.SHA256()))\n        # valid, push true to stack\n        context.stack.append(data)\n    except InvalidSignature as e:\n        raise OracleChecksigFailed from e\n\n\ndef op_data_strequal(context: ScriptContext) -> None:\n    \"\"\"Equivalent to an OP_GET_DATA_STR followed by an OP_EQUALVERIFY.\n\n    Consumes three parameters from stack: <data> <k> <value>. Gets the kth value\n    from <data> as a string and verifies it's equal to <value>. If so, puts <data>\n    back on the stack.\n\n    :param stack: the stack used when evaluating the script\n    :type stack: list[]\n\n    :raises MissingStackItems: if there aren't 3 element on stack\n    :raises VerifyFailed: verification failed\n    \"\"\"\n    if len(context.stack) < 3:\n        raise MissingStackItems('OP_DATA_STREQUAL: need 3 elements on stack, currently {}'.format(len(context.stack)))\n    value = context.stack.pop()\n    data_k = context.stack.pop()\n    data = context.stack.pop()\n    assert isinstance(value, bytes)\n    assert isinstance(data, bytes)\n\n    if not isinstance(data_k, int):\n        raise VerifyFailed('OP_DATA_STREQUAL: value on stack should be an integer ({!r})'.format(data_k))\n\n    data_value = get_data_value(data_k, data)\n    if data_value != value:\n        raise VerifyFailed('OP_DATA_STREQUAL: {} x {}'.format(data_value.decode('utf-8'), value.decode('utf-8')))\n\n    context.stack.append(data)\n\n\ndef op_data_greaterthan(context: ScriptContext) -> None:\n    \"\"\"Equivalent to an OP_GET_DATA_INT followed by an OP_GREATERTHAN.\n\n    Consumes three parameters from stack: <data> <k> <n>. Gets the kth value\n    from <data> as an integer and verifies it's greater than <n>.\n\n    :param stack: the stack used when evaluating the script\n    :type stack: list[]\n\n    :raises MissingStackItems: if there aren't 3 element on stack\n    :raises VerifyFailed: verification failed\n    \"\"\"\n    if len(context.stack) < 3:\n        raise MissingStackItems(f'OP_DATA_GREATERTHAN: need 3 elements on stack, currently {len(context.stack)}')\n    value = context.stack.pop()\n    data_k = context.stack.pop()\n    data = context.stack.pop()\n    assert isinstance(value, bytes)\n    assert isinstance(data, bytes)\n\n    if not isinstance(data_k, int):\n        raise VerifyFailed('OP_DATA_STREQUAL: value on stack should be an integer ({!r})'.format(data_k))\n\n    data_value = get_data_value(data_k, data)\n    try:\n        data_int = binary_to_int(data_value)\n        value_int = binary_to_int(value)\n    except (ValueError, struct.error) as e:\n        raise VerifyFailed from e\n\n    if data_int <= value_int:\n        raise VerifyFailed('op_data_greaterthan: {} x {}'.format(data_int, value_int))\n\n    context.stack.append(data)\n\n\ndef op_data_match_interval(stack: Stack) -> None:\n    \"\"\"Equivalent to an OP_GET_DATA_INT followed by an OP_MATCH_INTERVAL.\n\n    :param stack: the stack used when evaluating the script\n    :type stack: list[]\n\n    :raises MissingStackItems: if there aren't 3 element on stack\n    :raises VerifyFailed: verification failed\n    \"\"\"\n    if len(stack) < 1:\n        raise MissingStackItems('OP_DATA_MATCH_INTERVAL: stack is empty')\n\n    data_n_items = stack.pop()\n    assert isinstance(data_n_items, bytes)\n    # TODO test this can be transformed to integer\n    n_items = data_n_items[0]\n\n    # number of items in stack that will be used\n    will_use = 2 * n_items + 3  # n data_points, n + 1 pubkeys, k and data\n    if len(stack) < will_use:\n        raise MissingStackItems('OP_DATA_MATCH_INTERVAL: need {} elements on stack, currently {}'.format(\n            will_use, len(stack)))\n\n    items = []\n    try:\n        for _ in range(n_items):\n            pubkey = stack.pop()\n            buf = stack.pop()\n            assert isinstance(pubkey, (str, bytes))\n            assert isinstance(buf, bytes)\n            value = binary_to_int(buf)\n            items.append((value, pubkey))\n        # one pubkey is left on stack\n        last_pubkey = stack.pop()\n        # next two items are data index and data\n        data_k = stack.pop()\n        data = stack.pop()\n        assert isinstance(data_k, int)\n        assert isinstance(data, bytes)\n        data_value = get_data_value(data_k, data)\n        data_int = binary_to_int(data_value)\n    except (ValueError, struct.error) as e:\n        raise VerifyFailed from e\n\n    for (value_int, pubkey) in items:\n        if data_int > value_int:\n            stack.append(pubkey)\n            return\n    # if none of the values match, last pubkey on stack is winner\n    stack.append(last_pubkey)\n\n\ndef op_data_match_value(context: ScriptContext) -> None:\n    \"\"\"Equivalent to an OP_GET_DATA_STR followed by an OP_MATCH_VALUE.\n\n    :param stack: the stack used when evaluating the script\n    :type stack: list[]\n\n    :raises MissingStackItems: if there aren't 3 element on stack\n    :raises VerifyFailed: verification failed\n    \"\"\"\n    if len(context.stack) < 1:\n        raise MissingStackItems('OP_DATA_MATCH_VALUE: empty stack')\n\n    data_n_items = context.stack.pop()\n    assert isinstance(data_n_items, bytes)\n    # TODO test this can be transformed to integer\n    n_items = data_n_items[0]\n\n    # number of items in stack that will be used\n    will_use = 2 * n_items + 3  # n data_points, n + 1 keys, k and data\n    if len(context.stack) < will_use:\n        raise MissingStackItems('OP_DATA_MATCH_VALUE: need {} elements on stack, currently {}'.format(\n            will_use, len(context.stack)))\n\n    items = {}\n    try:\n        for _ in range(n_items):\n            pubkey = context.stack.pop()\n            buf = context.stack.pop()\n            assert isinstance(pubkey, (str, bytes))\n            assert isinstance(buf, bytes)\n            value = binary_to_int(buf)\n            items[value] = pubkey\n    except (ValueError, struct.error) as e:\n        raise VerifyFailed from e\n\n    # one pubkey is left on stack\n    last_pubkey = context.stack.pop()\n    # next two items are data index and data\n    data_k = context.stack.pop()\n    data = context.stack.pop()\n    assert isinstance(data_k, int)\n    assert isinstance(data, bytes)\n    data_value = get_data_value(data_k, data)\n    data_int = binary_to_int(data_value)\n    winner_pubkey = items.get(data_int, last_pubkey)\n    assert isinstance(winner_pubkey, (str, bytes))\n    context.stack.append(winner_pubkey)\n\n\ndef op_find_p2pkh(context: ScriptContext) -> None:\n    \"\"\"Checks whether the current transaction has an output with a P2PKH script with\n    the given public key hash and the same amount as the input.\n\n    :param stack: the stack used when evaluating the script\n    :type stack: list[]\n\n    :param tx: Transaction to be added\n    :type tx: :py:class:`hathor.transaction.BaseTransaction`\n\n    :param contract_value: amount available on the nano contract (on the original output)\n    :type contract_type: int\n\n    :raises MissingStackItems: if stack is empty\n    :raises VerifyFailed: verification failed\n    \"\"\"\n    if not len(context.stack):\n        raise MissingStackItems('OP_FIND_P2PKH: empty stack')\n\n    from hathor.transaction.scripts import P2PKH\n    assert isinstance(context.extras, UtxoScriptExtras)\n    spent_tx = context.extras.spent_tx\n    txin = context.extras.txin\n    tx = context.extras.tx\n    contract_value = spent_tx.outputs[txin.index].value\n\n    address = context.stack.pop()\n    address_b58 = get_address_b58_from_bytes(address)\n    for output in tx.outputs:\n        p2pkh_out = P2PKH.parse_script(output.script)\n        if p2pkh_out:\n            if p2pkh_out.address == address_b58 and output.value == contract_value:\n                context.stack.append(1)\n                return\n    # didn't find any match\n    raise VerifyFailed\n\n\ndef op_checkmultisig(context: ScriptContext) -> None:\n    \"\"\"Checks if it has the minimum signatures required and if all of them are valid\n\n    :param stack: the stack used when evaluating the script\n    :type stack: list[]\n\n    :raises MissingStackItems: if stack is empty or it has less signatures than the minimum required\n    :raises VerifyFailed: verification failed\n    \"\"\"\n    settings = get_global_settings()\n\n    if not len(context.stack):\n        raise MissingStackItems('OP_CHECKMULTISIG: empty stack')\n\n    # Pop the quantity of pubkeys\n    pubkey_count = context.stack.pop()\n\n    if not isinstance(pubkey_count, int):\n        raise InvalidStackData('OP_CHECKMULTISIG: pubkey count should be an integer')\n\n    if pubkey_count > settings.MAX_MULTISIG_PUBKEYS:\n        raise InvalidStackData('OP_CHECKMULTISIG: pubkey count ({}) exceeded the limit ({})'.format(\n                pubkey_count,\n                settings.MAX_MULTISIG_PUBKEYS,\n                )\n            )\n\n    if len(context.stack) < pubkey_count:\n        raise MissingStackItems('OP_CHECKMULTISIG: not enough public keys on the stack')\n\n    # Get all pubkeys\n    pubkeys = []\n    for _ in range(pubkey_count):\n        pubkey_bytes = context.stack.pop()\n        pubkeys.append(pubkey_bytes)\n\n    if not len(context.stack):\n        raise MissingStackItems('OP_CHECKMULTISIG: less elements than should on the stack')\n\n    # Pop the quantity of signatures required\n    signatures_count = context.stack.pop()\n\n    if not isinstance(signatures_count, int):\n        raise InvalidStackData('OP_CHECKMULTISIG: signatures count should be an integer')\n\n    if signatures_count > settings.MAX_MULTISIG_SIGNATURES:\n        raise InvalidStackData('OP_CHECKMULTISIG: signature count ({}) exceeded the limit ({})'.format(\n                signatures_count,\n                settings.MAX_MULTISIG_SIGNATURES,\n                )\n            )\n\n    # Error if we don't have the minimum quantity of signatures\n    if len(context.stack) < signatures_count:\n        raise MissingStackItems('OP_CHECKMULTISIG: not enough signatures on the stack')\n\n    # Get all signatures\n    signatures = []\n    for _ in range(signatures_count):\n        signature_bytes = context.stack.pop()\n        signatures.append(signature_bytes)\n\n    # For each signature we check if it's valid with one of the public keys\n    # Signatures must be in order (same as the public keys in the multi sig wallet)\n    pubkey_index = 0\n    for signature in signatures:\n        while pubkey_index < len(pubkeys):\n            pubkey = pubkeys[pubkey_index]\n            new_stack = [signature, pubkey]\n            op_checksig(ScriptContext(stack=new_stack, logs=context.logs, extras=context.extras))\n            result = new_stack.pop()\n            pubkey_index += 1\n            if result == 1:\n                break\n        else:\n            # finished all pubkeys and did not verify all signatures\n            context.stack.append(0)\n            return\n\n    # If all signatures are valids we push 1\n    context.stack.append(1)\n\n\ndef op_integer(opcode: int, stack: Stack) -> None:\n    \"\"\" Appends an integer to the stack\n        We get the opcode comparing to all integers opcodes\n\n        Example to append integer 4:\n        opcode will be equal to OP_4 (0x54)\n        Then we append the integer OP_4 - OP_0 = 4\n\n        :param opcode: the opcode to append to the stack\n        :type opcode: bytes\n\n        :param stack: the stack used when evaluating the script\n        :type stack: list[]\n    \"\"\"\n    try:\n        stack.append(decode_opn(opcode))\n    except InvalidScriptError as e:\n        raise ScriptError(e) from e\n\n\ndef execute_op_code(opcode: Opcode, context: ScriptContext, version: OpcodesVersion) -> None:\n    \"\"\"\n    Execute a function opcode.\n\n    Args:\n        opcode: the opcode to be executed.\n        context: the script context to be manipulated.\n    \"\"\"\n    context.logs.append(f'Executing function opcode {opcode.name} ({hex(opcode.value)})')\n    opcode_fns: dict[Opcode, Callable[[ScriptContext], None]] = {\n        Opcode.OP_DUP: op_dup,\n        Opcode.OP_EQUAL: op_equal,\n        Opcode.OP_EQUALVERIFY: op_equalverify,\n        Opcode.OP_CHECKSIG: op_checksig,\n        Opcode.OP_HASH160: op_hash160,\n        Opcode.OP_GREATERTHAN_TIMESTAMP: op_greaterthan_timestamp,\n        Opcode.OP_CHECKMULTISIG: op_checkmultisig,\n    }\n\n    if version == OpcodesVersion.V1:\n        opcode_fns.update({\n            Opcode.OP_DATA_STREQUAL: op_data_strequal,\n            Opcode.OP_DATA_GREATERTHAN: op_data_greaterthan,\n            Opcode.OP_DATA_MATCH_VALUE: op_data_match_value,\n            Opcode.OP_CHECKDATASIG: op_checkdatasig,\n            Opcode.OP_FIND_P2PKH: op_find_p2pkh,\n        })\n\n    opcode_fn = opcode_fns.get(opcode)\n    if opcode_fn is None:\n        raise ScriptError(f'unknown opcode: {opcode}')\n\n    opcode_fn(context)\n",
  "language": "python",
  "imports": [],
  "has_docstring": true
}