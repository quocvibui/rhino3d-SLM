{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Grips_linearize.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Grips_linearize.py",
  "instruction": "Spb grips linearize",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, print_function, unicode_literals\r\n\r\n\"\"\"\r\n181012-13: Created.\r\n201002: Added support for all other point input combinations.  Previously, only 2 special cases were supported.\r\n211112: With input of 2 CP's with a common u or v index, the CP's between will be made colinear.\r\n\r\nTODO:\r\n    Properly process periodic and other closed curves.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bFixedEnds'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fDistance':\r\n            if cls.riOpts[key].CurrentValue <= 1e-9:\r\n                print(\"Invalid input for Distance value.\")\r\n                cls.riOpts[key].CurrentValue = cls.values[key]\r\n                return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\" Get control point grips. \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select CPs\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Grip\r\n\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n\r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('bFixedEnds')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=2, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            grips = [o.Object() for o in objrefs]\r\n            return grips\r\n\r\n            #object_list = Rhino.Collections.TransformObjectList()\r\n            #object_list.AddObjects(go=go, allowGrips=True)\r\n\r\n            #gips_All = [] # List of (Tuples of Guid of grip's parent, index of grip, Point3d).  Used by rhinoscriptsyntax.\r\n            #for grip in object_list.GripArray():\r\n            #    gips_All.append((grip.OwnerId, grip.Index, grip.CurrentLocation))\r\n            #return gips_All\r\n\r\n        go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n        go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n        go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef sortNestListOfTuples(gips_to_sort, idxTuple):\r\n    \"\"\"\r\n    Parameters:\r\n        gips_to_sort: list(tuple(Guid of grip's parent, index of grip, Point3d)).  Used by rhinoscriptsyntax.\r\n        idxTuple: Index of tuple by which to sort.\r\n    \"\"\"\r\n    \r\n    idxList = []\r\n    nestedList = [] # 1-level nesting of (GUID, Grip index, Point3d) per GUID.\r\n\r\n    for gip in gips_to_sort:\r\n        if gip[0] in idxList:\r\n            nestedList[idxList.index(gip[idxTuple])].extend([(gip[0], gip[1], gip[2])])\r\n        else:\r\n            idxList.append(gip[idxTuple])\r\n            nestedList.append([(gip[0], gip[1], gip[2])])\r\n    \r\n    return nestedList\r\n\r\n\r\ndef _sortGripsByParentGuid(grips):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    nestedList = [] # 1-level nesting of grips per parent GUID.\r\n    gParents = []\r\n\r\n    for grip in grips:\r\n        if grip.OwnerId in gParents:\r\n            nestedList[gParents.index(grip.OwnerId)].append(grip)\r\n        else:\r\n            gParents.append(grip.OwnerId)\r\n            nestedList.append([grip])\r\n    \r\n    return nestedList\r\n\r\n\r\ndef getUvIdxFromNsPoint1dIdx(ns, idxFlat):\r\n    return idxFlat // ns.Points.CountV, idxFlat % ns.Points.CountV\r\n\r\n\r\ndef _get_iGrip_matches(grips_perOwnerGuid):\r\n    \r\n    pt_Matches = []\r\n    iGrip_per_Guid_matches = []\r\n    \r\n    # Find matches between first two GUID's.\r\n    for i0 in range(len(grips_perOwnerGuid[0])):\r\n        for i1 in range(len(grips_perOwnerGuid[1])):\r\n            dist = grips_perOwnerGuid[0][i0].CurrentLocation.DistanceTo(\r\n                grips_perOwnerGuid[1][i1].CurrentLocation)\r\n            if dist <= Rhino.RhinoMath.ZeroTolerance:\r\n                pt_Matches.append(grips_perOwnerGuid[0][i0].CurrentLocation)\r\n                iGrip_per_Guid_matches.append([i0, i1])\r\n    if not pt_Matches:\r\n        if bDebug: print(\"No matches found.\")\r\n        return\r\n        \r\n    for iMatch, pt_Match in enumerate(pt_Matches):\r\n        for iG in range(2, len(grips_perOwnerGuid)):\r\n            for i_gip, gip in enumerate(grips_perOwnerGuid[iG]):\r\n                if gip[2].EpsilonEquals(pt_Match, Rhino.RhinoMath.ZeroTolerance):\r\n                    iGrip_per_Guid_matches[iMatch].append(i_gip)\r\n                    break\r\n            else:\r\n                if bDebug: print(\"No matches found.\")\r\n                break # to pt_Matches loop.\r\n        if len(iGrip_per_Guid_matches[iMatch]) == len(grips_perOwnerGuid):\r\n            return tuple(iGrip_per_Guid_matches[iMatch])\r\n\r\n\r\ndef process2Objects_2GripsEach(grips_perOwnerGuid):\r\n    \"\"\"\r\n\r\n    \"\"\"\r\n\r\n    #            for iA in 0,1:\r\n    #                for iB in 0,1:\r\n    #                    if gips_perGuid[0][iA][2] == gips_perGuid[1][iB][2]:\r\n    #                        return iA, iB\r\n    i_gip_match = _get_iGrip_matches(grips_perOwnerGuid)\r\n    if not i_gip_match:\r\n        print(\"No match\")\r\n        return\r\n        \r\n    ptMatch = gips_perGuid[0][i_gip_match[0]][2]\r\n        \r\n    idxOtherA = int(not i_gip_match[0])\r\n    ptToMoveA = gips_perGuid[0][idxOtherA][2]\r\n    idxOtherB = int(not i_gip_match[1])\r\n    ptOtherB = gips_perGuid[1][idxOtherB][2]\r\n        \r\n    line = rg.Line(ptToMoveA, ptOtherB)\r\n    #sc.doc.Objects.AddLine(line)\r\n        \r\n    pt_on_line_closest_to_match = line.ClosestPoint(testPoint=ptMatch, limitToFiniteSegment=True)\r\n    #sc.doc.Objects.AddPoint(pt_on_line_closest_to_match)\r\n        \r\n    vect = ptMatch - pt_on_line_closest_to_match\r\n    if vect.IsTiny():\r\n        if bEcho: print(\"Grips are already linear.\")\r\n        return\r\n        \r\n    xform_moveLine = rg.Transform.Translation(vect)\r\n    ptToMoveA.Transform(xform_moveLine)\r\n    ptOtherB.Transform(xform_moveLine)\r\n        \r\n    print(gips_perGuid[0][i_gip_match[0]][1])\r\n        \r\n    print(rs.ObjectGripLocation(gips_perGuid[0][0][0], gips_perGuid[0][idxOtherA][1], ptToMoveA))\r\n    rs.ObjectGripLocation(gips_perGuid[1][0][0], gips_perGuid[1][idxOtherB][1], ptOtherB)\r\n\r\n\r\ndef processGrips(grips, **kwargs):\r\n    \"\"\"bDebug\r\n    # gip: Tuple of Guid of grip's parent, index of grip, Point3d.\r\n    \"\"\"\r\n\r\n    grips_In = grips # So 'grips' can be used in other routines.\r\n\r\n    for grip in grips_In:\r\n        if not isinstance(grip, rd.GripObject):\r\n            print(\"{} object passed to processGrips.  Must be GripObject.\")\r\n            return\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bFixedEnds = getOpt('bFixedEnds')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n\r\n\r\n    def minimumGipDistance():\r\n        dists = []\r\n        for iA in range(len(gips_perGuid)):\r\n            for gipA in gips_perGuid[iA]:\r\n                for iB in range(iA+1, len(gips_perGuid)):\r\n                    for gipB in gips_perGuid[iB]:\r\n                        dist = gipA[2].DistanceTo(gipB[2])\r\n                        if dist > sc.doc.ModelAbsoluteTolerance:\r\n                            dists.append(dist)\r\n        return min(dists)\r\n\r\n\r\n    def process8Of4():\r\n        \"\"\"\r\n        Corner of 4?\r\n        \"\"\"\r\n        \r\n        i_gip_match = _get_iGrip_matches(gips_perGuid)\r\n        if not i_gip_match:\r\n            print(\"No match.\")\r\n            return\r\n        \r\n        ptMatch = gips_perGuid[0][i_gip_match[0]][2]\r\n        \r\n        gip_ToMoveA = None\r\n        for i in range(len(gips_perGuid)):\r\n            if len(gips_perGuid[i]) == 2:\r\n                if gip_ToMoveA is None:\r\n                    gip_ToMoveA = gips_perGuid[int(not i_gip_match[0])]\r\n                    ptToMoveA = gip_ToMoveA[2]\r\n                else:\r\n                    gip_ToMoveB = gips_perGuid[int(not i_gip_match[0])]\r\n                    ptToMoveB = gip_ToMoveB[2]\r\n        \r\n        line = rg.Line(ptToMoveA, ptOtherB)\r\n        #sc.doc.Objects.AddLine(line)\r\n        \r\n        pt_on_line_closest_to_match = line.ClosestPoint(\r\n                testPoint=ptMatch, limitToFiniteSegment=True)\r\n        #sc.doc.Objects.AddPoint(pt_on_line_closest_to_match)\r\n        \r\n        vect = ptMatch - pt_on_line_closest_to_match\r\n        if vect.IsTiny():\r\n            if bEcho: print(\"Grips are already linear.\")\r\n            return\r\n        \r\n        xform_moveLine = rg.Transform.Translation(vect)\r\n        ptToMoveA.Transform(xform_moveLine)\r\n        ptOtherB.Transform(xform_moveLine)\r\n        \r\n        print(gips_perGuid[0][i_gip_match[0]][1])\r\n        \r\n        print(rs.ObjectGripLocation(gips_perGuid[0][0][0], gips_perGuid[0][idxOtherA][1], ptToMoveA))\r\n        rs.ObjectGripLocation(gips_perGuid[1][0][0], gips_perGuid[1][idxOtherB][1], ptOtherB)\r\n\r\n\r\n    def processOthers():\r\n        \r\n        #pts = [gips_All[i][2] for i in range(len(gips_All))]\r\n\r\n        if bFixedEnds:\r\n            pass\r\n\r\n\r\n            ## Look for co-U or c-V pattern.\r\n            #for gObj, ips in zip(gObjs, ips_per_Guid):\r\n            #    nc = rs.coercecurve(gObj)\r\n            #    face = rs.coercesurface(gObj)\r\n            #    if nc:\r\n            #        pass\r\n            #    elif face:\r\n            #        ns = face.UnderlyingSurface()\r\n            #        iUs = []\r\n            #        iVs = []\r\n            #        for idxPt, pt in ips:\r\n            #            iU,iV = getUvIdxFromNsPoint1dIdx(ns, idxPt)\r\n            #            iUs.append(iU)\r\n            #            iVs.append(iV)\r\n            #        print(iUs, iVs\r\n            #        iUs_toLinearize = []\r\n            #        iVs_toLinearize = []\r\n            #        for iU in set(iUs):\r\n            #            if iUs.count(iU) > 2:\r\n            #                iUs_toLinearize.append(iU)\r\n            #        for iV in set(iVs):\r\n            #            if iVs.count(iV) > 2:\r\n            #                iVs_toLinearize.append(iV)\r\n\r\n            #        print(iUs_toLinearize, iVs_toLinearize\r\n        \r\n        bSuccess, line = rg.Line.TryFitLineToPoints(\r\n            [gips_All[i][2] for i in range(len(gips_All))])\r\n        \r\n        #sc.doc.Objects.AddLine(line); #sc.doc.Views.Redraw()\r\n        \r\n        for i in range(len(gips_All)):\r\n            pt_projected_onto_line = line.ClosestPoint(\r\n                    testPoint=gips_All[i][2],\r\n                    limitToFiniteSegment=False)\r\n            rs.ObjectGripLocation(\r\n                gips_All[i][0],\r\n                gips_All[i][1],\r\n                pt_projected_onto_line)\r\n        \r\n        \r\n    \r\n    # Split gips_All into a list of (GUID, Grip index, Point3d) based on GUID order\r\n    # and a list of the sorted GUIDs.\r\n    #gips_perGuid = sortNestListOfTuples(gips_All, idxTuple=0)\r\n    #if gips_perGuid is None: return\r\n\r\n    grips_perParentGuid = _sortGripsByParentGuid(grips_In)\r\n    if grips_perParentGuid is None: return\r\n\r\n    if (len(grips_In) == 2) and (grips_In[0].OwnerId == grips_In[1].OwnerId):\r\n        import spb_Grips_linearizeBetween2\r\n        spb_Grips_linearizeBetween2.linearizeGripsBetween2(\r\n            grips_In[0],\r\n            grips_In[1],\r\n            bFixedEnds=bFixedEnds,\r\n            bDistributeEvenly=False,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug,\r\n            )\r\n        return\r\n\r\n    # Reject if not at least 3 grips.\r\n    if len(grips_In) < 3:\r\n        if bEcho: print(\"Only {} grips selected.  Nothing will be done.\".format(len(grips_In)))\r\n        return\r\n\r\n    # If there are 2 GUIDs with 2 grips each, they may span over edge.\r\n    if (\r\n        len(grips_perParentGuid) == 2 and\r\n        len(grips_perParentGuid[0]) == 2 and\r\n        len(grips_perParentGuid[1]) == 2\r\n    ):\r\n        process2Objects_2GripsEach(grips_perParentGuid)\r\n    elif (\r\n            len(gips_perGuid) == 4 and\r\n            all(len(gips_of_Guid) == 2 for gips_of_Guid in gips_perGuid)\r\n    ):\r\n       process8Of4()\r\n    else:\r\n        processOthers()\r\n\r\n\r\ndef main():\r\n\r\n    grips = getInput()\r\n    if grips is None: return\r\n\r\n    if not Opts.values['bDebug']: sc.doc.Views.RedrawEnabled = False\r\n\r\n    processGrips(grips)\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}