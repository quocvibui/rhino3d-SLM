{
  "source_url": "https://github.com/JobdeVogel/Solar-Irradiation-Prediction/blob/ce25b61727edaaaeb0e965bb821506de01cb0dcc/dataset/input_output/save.py",
  "repo": "JobdeVogel/Solar-Irradiation-Prediction",
  "repo_stars": 0,
  "repo_description": "Graduation repository for Master Building Technology",
  "license": "unknown",
  "filepath": "dataset/input_output/save.py",
  "instruction": null,
  "code": "import Rhino.Geometry as rg\nimport Rhino\nimport json\nimport time\n\nimport numpy as np\nfrom parameters.params import PICKLE_PROTOCOL\nimport datetime\n\n# Generate a meta data dict based on keys and values\ndef generate_meta(keys, values):\n    meta = {}\n    \n    for key, value in zip(keys, values):\n        if key.lower() == 'time':\n            meta[key] = str(datetime.datetime.now())\n        else:\n            meta[key] = value\n    \n    return meta\n\n# Save a mesh to a json file in base64 format\n# The json data is a base64 encoded string of the byte array representing the geometry.\ndef save_mesh_to_json(meshes, mesh_types, name, folder, meta_data=None, logger=False):\n    start = time.time()\n    path = folder + \"/\" + name + \".json\"\n    \n    options = Rhino.FileIO.SerializationOptions()\n    data = {}\n    \n    for i, mesh in enumerate(meshes):\n        if isinstance(mesh, list):\n            temp_mesh = rg.Mesh()\n            \n            for m in mesh:\n                temp_mesh.Append(m)\n            \n            data[mesh_types[i]] = temp_mesh.ToJSON(options)\n        else:\n            data[mesh_types[i]] = mesh.ToJSON(options)\n    \n    data['meta'] = meta_data\n\n    with open(path, \"w\") as file:\n        json.dump(data, file)\n    \n    if logger:\n        logger.info(f\"Mesh {name} saved in {round(time.time() - start)}s\")\n    \ndef save_outlines_to_json(outlines, name, folder, logger=False):\n    start = time.time()\n    path = folder + \"/\" + name + \".json\"\n    \n    options = Rhino.FileIO.SerializationOptions()\n    data = {}\n    \n    for i, outline in enumerate(outlines):\n        for j, polyline in enumerate(outline):\n            curve = polyline.ToNurbsCurve()\n            curve_name = f\"curve_{str(i)}_{str(j)}\"\n            data[curve_name] = curve.ToJSON(options)\n\n    with open(path, \"w\") as file:\n        json.dump(data, file)\n    \n    if logger:\n        logger.info(f\"Polyines {name} saved in {round(time.time() - start)}s\")\n\ndef save_array(array, name, folder, logger=False):\n    start = time.perf_counter()\n    path = folder + '\\\\' + name + '.npy'\n    \n    np.save(path, array)\n    \n    if logger:\n        logger.info(f\"Array saved in {round(time.perf_counter() - start)}s\")\n\ndef save_array_as_list(array, name, folder, logger=False):\n    start = time.time()\n    list_data = array.tolist()\n    \n    path = folder + \"/\" + name + \".json\"\n    \n    data = json.dumps(list_data)\n\n    with open(path, 'w') as file:\n        json.dump(data, file)\n    \n    if logger:\n        logger.info(f\"Array_list {name} saved in {round(time.time() - start)}s\")\n    \n    # with open('./data/list_data.pkl', 'wb') as file:\n    #     pickle.dump(list_data, file, protocol=PICKLE_PROTOCOL)\n\n# Save an HB model to a file as json file\ndef save_hbjson(model, name, folder, logger=False):\n    start = time.time()\n    model.to_hbjson(name=name, folder=folder)\n    \n    if logger:\n        logger.info(f\"HB_model {name} saved in {round(time.time() - start)}s\")",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}