{
  "source_url": "https://github.com/McMuff86/RhinoLeaderTool/blob/880966d9ae5c50786ba91882e3ffffcddcc64e1d/write_leaders_to_file_old.py",
  "repo": "McMuff86/RhinoLeaderTool",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "write_leaders_to_file_old.py",
  "instruction": "Write leaders to file old",
  "code": "#! python 3\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino\nimport os\nimport json\nfrom collections import defaultdict\n\ndef load_config():\n    user_dir = os.path.expanduser(\"~\")\n    base_path = os.path.join(user_dir, \"source\", \"repos\", \"work\", \"library\", \"RhinoLeaderTool\")\n    cfg_path = os.path.join(base_path, \"config.json\")\n    default = {\n        \"logging\": {\"mode\": \"xlsx\"},\n        \"export\": {\n            \"target_styles\": [\n                \"Standard 1:10 Rahmenbeschriftung\",\n                \"Standard 1:10 Rahmenbeschriftung WHG Eingang\",\n                \"Standard 1:10 Zargenbeschriftung\",\n                \"Standard 1:10 Schiebetürbeschriftung\",\n                \"Standard 1:10 Spez.Rahmenbeschriftung\"\n            ],\n            \"na_value\": \"NA\"\n        }\n    }\n    try:\n        if os.path.isfile(cfg_path):\n            with open(cfg_path, \"r\", encoding=\"utf-8\") as f:\n                file_cfg = json.load(f)\n            for k, v in file_cfg.items():\n                default[k] = v\n    except Exception:\n        pass\n    return default\n\ndef get_base_path(cfg):\n    user_dir = os.path.expanduser(\"~\")\n    default_base = os.path.join(user_dir, \"source\", \"repos\", \"work\", \"library\", \"RhinoLeaderTool\")\n    cfg_base = cfg.get(\"base_path\") if isinstance(cfg, dict) else None\n    return cfg_base if (cfg_base and os.path.isdir(cfg_base)) else default_base\n\ndef get_selected_csv_folder(cfg, prompt_if_missing=False):\n    try:\n        section = \"RhinoLeaderToolGlobals\"\n        key = \"CsvFolder\"\n        selected = None\n        try:\n            selected = rs.GetDocumentData(section, key)\n        except Exception:\n            selected = None\n        if selected and os.path.isdir(selected):\n            return selected\n        if not prompt_if_missing:\n            return None\n        # optional prompt (off by default for exporter)\n        try:\n            start_dir = (cfg.get(\"base_path\") or get_base_path(cfg))\n        except Exception:\n            start_dir = get_base_path(cfg)\n        try:\n            folder = rs.BrowseForFolder(folder=start_dir, message=\"Select CSV folder for this document\")\n        except Exception:\n            folder = None\n        if folder and os.path.isdir(folder):\n            try:\n                rs.SetDocumentData(section, key, folder)\n            except Exception:\n                pass\n            return folder\n    except Exception:\n        pass\n    return None\n\ndef find_csv_in_tree(base_dir, csv_name):\n    try:\n        if not base_dir or not os.path.isdir(base_dir) or not csv_name:\n            return None\n        direct = os.path.join(base_dir, csv_name)\n        if os.path.isfile(direct):\n            return direct\n        matches = []\n        target_basename = os.path.basename(csv_name)\n        for root, _dirs, files in os.walk(base_dir):\n            for fn in files:\n                if fn.lower() == target_basename.lower():\n                    matches.append(os.path.join(root, fn))\n        if not matches:\n            return direct\n        if len(matches) == 1:\n            return matches[0]\n        # pick shortest relative path\n        rels = [(m, os.path.relpath(m, base_dir)) for m in matches]\n        rels.sort(key=lambda x: (len(x[1]), x[1].lower()))\n        return rels[0][0]\n    except Exception:\n        return None\n\ndef read_csv_keys(csv_path):\n    keys = []\n    try:\n        with open(csv_path, mode=\"r\", encoding=\"utf-8\") as f:\n            for line in f:\n                line = line.strip()\n                if not line:\n                    continue\n                parts = line.split(\",\", 1)\n                if len(parts) >= 1:\n                    key = parts[0].strip()\n                    if key and key not in keys:\n                        keys.append(key)\n    except Exception:\n        pass\n    return keys\n\ndef compute_required_keys_from_config(cfg):\n    required = []\n    try:\n        base_path = get_selected_csv_folder(cfg, prompt_if_missing=False) or get_base_path(cfg)\n        types_cfg = (cfg or {}).get(\"types\", {})\n        seen = set()\n        for _typ, spec in types_cfg.items():\n            csv_name = spec.get(\"csv\")\n            if not csv_name:\n                continue\n            if os.path.isabs(csv_name):\n                csv_path = csv_name\n            else:\n                csv_path = find_csv_in_tree(base_path, csv_name) or os.path.join(base_path, csv_name)\n            for key in read_csv_keys(csv_path):\n                if key not in seen:\n                    seen.add(key)\n                    required.append(key)\n    except Exception:\n        pass\n    return required\n\ndef normalize_value_for_excel(value, na_value):\n    try:\n        if value is None:\n            return na_value\n        if isinstance(value, (int, float)):\n            return value\n        s = str(value).strip()\n        if s == \"\" or s.upper() == str(na_value).upper():\n            return na_value\n        # try int\n        if s.isdigit() or (s.startswith(\"-\") and s[1:].isdigit()):\n            return int(s)\n        # try float (dot or comma)\n        s2 = s.replace(\",\", \".\")\n        # must contain only one dot and digits otherwise leave text\n        import re\n        if re.fullmatch(r\"-?\\d+\\.\\d+\", s2):\n            return float(s2)\n        return value\n    except Exception:\n        return value\n\ndef export_leader_texts(mode=None):\n    cfg = load_config()\n    # Ziel-Bemaßungsstile\n    target_styles = cfg.get(\"export\", {}).get(\"target_styles\", [])\n    # Erforderliche Keys aus allen CSV-Dateien (Union)\n    required_keys = compute_required_keys_from_config(cfg)\n\n    def get_export_paths(active_mode, prompt_user=True):\n        desktop_path = os.path.join(os.path.expanduser(\"~\"), \"Desktop\")\n        use_standard = True\n        if prompt_user:\n            # True = Standard (Desktop), False = Dokument-Ordner\n            res = rs.GetBoolean(\"Export to standard Desktop path?\", (\"StandardPath\", \"No\", \"Yes\"), True)\n            if res is not None and len(res) > 0:\n                use_standard = bool(res[0])\n        if use_standard:\n            base_dir = desktop_path\n            base_name = \"leader\"\n        else:\n            # Dokumentpfad verwenden\n            doc_path = sc.doc.Path or \"\"\n            doc_name = sc.doc.Name or \"leader\"\n            if doc_path:\n                base_dir = os.path.dirname(doc_path)\n            else:\n                # Fallback auf Desktop, wenn Datei ungespeichert\n                base_dir = desktop_path\n            base_name = os.path.splitext(doc_name)[0] or \"leader\"\n\n        output_path_txt = os.path.join(base_dir, f\"{base_name}_leader_texts.txt\")\n        output_path_stats = os.path.join(base_dir, f\"{base_name}_leader_stats.txt\")\n        output_path_xlsx = os.path.join(base_dir, f\"{base_name}_leader_export.xlsx\")\n        return output_path_txt, output_path_stats, output_path_xlsx\n\n    # Sammellisten\n    export_lines_text = []\n    leaders = []  # strukturierte Liste für XLSX\n    all_user_keys = []  # zusätzlich entdeckte Keys (nicht in required)\n    style_counts = defaultdict(int)\n\n    for obj in sc.doc.Objects:\n        try:\n            geom = obj.Geometry\n        except Exception:\n            continue\n        # Robuste Erkennung eines Leaders über die Geometrie\n        if isinstance(geom, Rhino.Geometry.Leader):\n            leader = geom\n            dimstyle_id = leader.DimensionStyleId\n            dimstyle = sc.doc.DimStyles.FindId(dimstyle_id)\n\n            # Wenn keine Zielstile konfiguriert sind: alle akzeptieren\n            style_ok = True if not target_styles else (dimstyle is not None and dimstyle.Name in target_styles)\n            if style_ok:\n                # Basis-Text\n                text = leader.Text.replace('\\r\\n', ' ').replace('\\n', ' ')\n                \n                # UserText ermitteln (als Dict und Text)\n                user_text_pairs = []\n                user_dict = {}\n                keys = obj.Attributes.GetUserStrings()\n                if keys:\n                    for key in keys.AllKeys:\n                        value = keys[key]\n                        user_text_pairs.append(f\"{key}={value}\")\n                        if key not in user_dict:\n                            user_dict[key] = value\n                        if key not in all_user_keys:\n                            all_user_keys.append(key)\n\n                # LeaderGUID sicherstellen\n                leader_guid = str(obj.Id)\n                if \"LeaderGUID\" not in user_dict or not user_dict.get(\"LeaderGUID\"):\n                    user_dict[\"LeaderGUID\"] = leader_guid\n                # Stelle sicher, dass LeaderGUID am Ende in den Spalten ist (falls nicht in required)\n                if \"LeaderGUID\" not in required_keys and \"LeaderGUID\" not in all_user_keys:\n                    all_user_keys.append(\"LeaderGUID\")\n\n                # TXT-Zeile aufbauen\n                full_line = text\n                if user_text_pairs:\n                    full_line += \" | \" + \" | \".join(user_text_pairs)\n\n                export_lines_text.append(full_line)\n                leaders.append({\n                    \"text\": text,\n                    \"dimstyle\": dimstyle.Name,\n                    \"user\": user_dict\n                })\n                style_name = dimstyle.Name if dimstyle else \"Unknown\"\n                style_counts[style_name] += 1\n\n    # Ausgabe\n    if not leaders:\n        print(\"Keine passenden Leader gefunden.\")\n        return\n\n    # Zielformat bestimmen\n    if mode is None:\n        mode = (cfg.get(\"logging\", {}).get(\"mode\") or \"csv\").lower()\n    # Ausgabe-Dateipfade nach Nutzerwunsch bestimmen\n    output_path_txt, output_path_stats, output_path_xlsx = get_export_paths(mode, prompt_user=True)\n\n    # TXT (wie bisher)\n    if mode in (\"txt\", \"csv\"):\n        with open(output_path_txt, \"w\", encoding=\"utf-8\") as file:\n            for line in export_lines_text:\n                file.write(line + \"\\n\")\n        # Statistik\n        stats_lines = [\"--- Übersicht pro Bemaßungsstil ---\"]\n        # Gesamtsumme über alle gezählten Stile\n        total = sum(style_counts.values())\n        if target_styles:\n            # zuerst die konfigurierten Stile in der gewünschten Reihenfolge\n            for style in target_styles:\n                count = style_counts.get(style, 0)\n                stats_lines.append(f\"{style}: {count}\")\n            # anschließend alle übrigen Stile alphabetisch\n            extra_styles = [s for s in style_counts.keys() if s not in target_styles]\n            for style in sorted(extra_styles):\n                stats_lines.append(f\"{style}: {style_counts[style]}\")\n        else:\n            for style in sorted(style_counts.keys()):\n                stats_lines.append(f\"{style}: {style_counts[style]}\")\n        stats_lines.append(f\"Total: {total} Leader\")\n        with open(output_path_stats, \"w\", encoding=\"utf-8\") as stats_file:\n            for line in stats_lines:\n                stats_file.write(line + \"\\n\")\n        print(f\"{len(leaders)} Leader exportiert (TXT):\\n{output_path_txt}\")\n        print(f\"Statistik gespeichert in:\\n{output_path_stats}\")\n        return\n\n    # XLSX\n    if mode == \"xlsx\":\n        try:\n            from openpyxl import Workbook\n            wb = Workbook()\n            ws = wb.active\n            ws.title = \"leaders\"\n            # Header: text, dimstyle, dann alle Keys\n            na_value = cfg.get(\"export\", {}).get(\"na_value\", \"NA\")\n            # finale Keys: erst required aus CSVs, danach alle zusätzlich im Dokument gefundenen Keys\n            final_keys = list(required_keys)\n            for k in all_user_keys:\n                if k not in final_keys:\n                    final_keys.append(k)\n            header = [\"text\", \"dimstyle\"] + final_keys\n            ws.append(header)\n            # Rows\n            for item in leaders:\n                row = [item[\"text\"], item[\"dimstyle\"]]\n                user = item[\"user\"]\n                for key in final_keys:\n                    row.append(normalize_value_for_excel(user.get(key, na_value), na_value))\n                ws.append(row)\n\n            # Statistik-Blatt\n            ws2 = wb.create_sheet(\"stats\")\n            ws2.append([\"style\", \"count\"])\n            total = sum(style_counts.values())\n            if target_styles:\n                for style in target_styles:\n                    ws2.append([style, style_counts.get(style, 0)])\n                extra_styles = [s for s in style_counts.keys() if s not in target_styles]\n                for style in sorted(extra_styles):\n                    ws2.append([style, style_counts[style]])\n            else:\n                for style in sorted(style_counts.keys()):\n                    ws2.append([style, style_counts[style]])\n            ws2.append([\"Total\", total])\n            wb.save(output_path_xlsx)\n            print(f\"{len(leaders)} Leader exportiert (XLSX):\\n{output_path_xlsx}\")\n            return\n        except Exception as e:\n            print(\"Excel-Export fehlgeschlagen, schreibe TXT stattdessen:\", e)\n            with open(output_path_txt, \"w\", encoding=\"utf-8\") as file:\n                for line in export_lines_text:\n                    file.write(line + \"\\n\")\n            return\n\n# Aufruf\n# Aufruf; optional: export_leader_texts(\"xlsx\")\nexport_leader_texts()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}