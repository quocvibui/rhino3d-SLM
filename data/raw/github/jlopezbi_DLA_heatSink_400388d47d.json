{
  "source_url": "https://github.com/jlopezbi/DLA_heatSink/blob/f082fb5c84ff5c72b0f1797b9d6370120bdfd9ad/CCoral.py",
  "repo": "jlopezbi/DLA_heatSink",
  "repo_stars": 5,
  "repo_description": "grow coral shapes",
  "license": "unknown",
  "filepath": "CCoral.py",
  "instruction": "Ccoral",
  "code": "import Rhino\nimport scriptcontext\nimport System.Guid\n\nclass Coral:\n  def __init__(self,objRef,mesh,ratioMaxMin):\n    mesh.Normals.ComputeNormals()\n    mesh.Normals.UnitizeNormals()\n    mesh.Compact()\n    #mesh.Weld(math.pi)\n\n    self.objRef = objRef\n    self.mesh = mesh\n    self.groupIdx = scriptcontext.doc.Groups.Add()\n    if(self.groupIdx == -1): print \"lineage group failed to intialize\"\n\n    self.avgEdgeLen = self.getAvgEdgeLen()\n    self.maxEdgeLength = self.avgEdgeLen\n    self.minEdgeLen = self.avgEdgeLen*ratioMaxMin\n\n    arrNakedBool = self.mesh.GetNakedEdgePointStatus()\n    self.nakedVerts = set()\n    for i in range(arrNakedBool.Length):\n      if (arrNakedBool[i] == True):\n        self.nakedVerts.add(i)\n\n\n    self.subdivideLongEdges()\n    self.collapseShortEdges()\n\n    self.lineage = []\n    self.lineage.append(self.mesh.Duplicate())\n\n  def setNakedVerts(self):\n    arrNakedBool = self.mesh.GetNakedEdgePointStatus()\n    for i in range(arrNakedBool.Length):\n      if (arrNakedBool[i] == True):\n        self.nakedVerts.add(i)\n\n  def verticesThatAte(self, world, particles):\n    mesh = self.mesh\n    tree = Rhino.Geometry.RTree()\n\n    #populate Rtree with mesh vertices\n    for i,vertex in enumerate(mesh.Vertices):\n      tree.Insert(vertex, i)\n\n    #function that runs when a sphere intersects with a vert\n    def SearchCallback(sender, data):\n      sData = data.Tag\n      sData.vertices.add(data.Id)\n      sData.addedVert = True\n\n    class SearchData:\n      def __init__(self):\n        self.vertices = set()\n        self.addedVert = False\n\n    sData = SearchData()\n\n    for particle in particles:\n      sphere = particle.sphere\n      tree.Search(sphere, SearchCallback, sData)\n      if(sData.addedVert):\n        particle.setToSpawnLoc(world)\n      sData.addedVert = False\n\n    return sData.vertices\n\n  def get_neighbors(self,vertex,nLevels):\n      '''\n      Returns:\n          list[list[int]] where int is vertex index\n      '''\n      pass\n\n  def getGrowData(self,gKernel,centerVerts):\n    mesh = self.mesh\n    gStepSize = gKernel.gStepSize\n    kernelLen = len(gKernel.gaussKernel)\n\n    #tVertIdxRoot = mesh.TopologyVertices.TopologyVertexIndex(idxCenter)\n    #conVertsIdx = mesh.Vertices.GetConnectedVertices(idxCenter)\n    growVerts = []\n\n\n    def lenBetweenTVerts(tVertIdx1,tVertIdx2,mesh):\n      p1 = mesh.TopologyVertices[tVertIdx1]\n      p2 = mesh.TopologyVertices[tVertIdx2]\n      return p1.DistanceTo(p2)\n\n    centerColor = System.Drawing.Color.FromArgb(164,223,45)\n\n    for idxCenter in centerVerts:\n      tVertIdxRoot = mesh.TopologyVertices.TopologyVertexIndex(idxCenter)\n      conVertsIdx = mesh.Vertices.GetConnectedVertices(idxCenter)\n\n      for i in range(conVertsIdx.Length):\n        idxN = conVertsIdx[i]\n        if(idxN != idxCenter and idxN not in centerVerts):\n          tVertIdx = mesh.TopologyVertices.TopologyVertexIndex(idxN)\n          dist = lenBetweenTVerts(tVertIdxRoot,tVertIdx,mesh)\n          lookUpIdx = int(round(dist/gStepSize))\n\n          #distStr = \"d:%1.2f,i:%d\"%(dist,lookUpIdx)\n          #rs.AddTextDot(distStr, mesh.Vertices[idx])\n          if(lookUpIdx<kernelLen):\n            growLen = gKernel.gaussKernel[lookUpIdx]\n            growVerts.append([idxN,growLen])\n        elif(idxN == idxCenter):\n          #mesh.VertexColors.SetColor(idx,centerColor)\n          growVerts.append([idxCenter,gKernel.maxGrowLen])\n\n    return growVerts\n\n  def grow(self,growVerts):\n    mesh = self.mesh\n    nakedVerts = self.nakedVerts\n\n    for i in range(len(growVerts)):\n\n      vertIdx = growVerts[i][0]\n      growLen = growVerts[i][1]\n      if(vertIdx not in nakedVerts):\n        vert = mesh.Vertices[vertIdx]\n        vertNormal = mesh.Normals[vertIdx]\n        growVec = vertNormal.Multiply(vertNormal,growLen)\n        newLoc = Rhino.Geometry.Point3d.Add(vert,growVec)\n\n\n        mesh.Vertices.SetVertex(vertIdx,newLoc)\n\n  def colorVerts(self,growVerts,gKernel):\n    meshID = self.objRef.ObjectId\n\n    gaussMax = gKernel.maxGrowLen\n    gaussMin = gKernel.minGrowLen\n\n    rMax = 44\n    gMax = 255\n    bMax = 50\n\n    colors = [None]*self.mesh.Vertices.Count\n    for i in range(len(colors)):\n      colors[i] = [100,100,100]\n\n    if self.mesh.Vertices.Count != rs.MeshVertexCount(meshID):\n      print \"ERROR: mesh.vertices.Count != rs.meshVertesCount!\"\n    if growVerts:\n      for i in range(len(growVerts)):\n        vertIdx = growVerts[i][0]\n        kernelIdx = growVerts[i][1]\n        growLen = gKernel.gaussKernel[kernelIdx]\n        ratio = (growLen-gaussMin)/(gaussMax-gaussMin)\n        if(ratio >1):\n          print \"ratio: %1.2f\" % ratio\n\n        r = ratio*rMax\n        g = ratio*gMax\n        b = ratio*bMax\n\n        colors[i] = [r,g,b]\n\n\n\n    rs.MeshVertexColors( meshID, colors )\n\n  def collapseShortEdges(self):\n    mesh = self.mesh\n    minEdgeLen = self.minEdgeLen\n    collapsedAnEdge = False\n    for i in range(mesh.TopologyEdges.Count):\n      # edgeLine = mesh.TopologyEdges.EdgeLine(i)\n      # length = edgeLine.Length\n      length = self.getLenEdge(i)\n      if(length<minEdgeLen):\n        mesh.TopologyEdges.CollapseEdge(i)\n        collapsedAnEdge = True\n    # if collapsedAnEdge:\n    #   print \"collapsed and edge!\"\n    return collapsedAnEdge\n\n  def subdivideLongEdges(self):\n    #iterate through all vertices of mesh and subdivide if too long. slower than\n    #subdividLongNeighbors, but easier to write\n    mesh = self.mesh\n    maxEdgeLength = self.maxEdgeLength\n    edges = mesh.TopologyEdges\n    nEdges = mesh.TopologyEdges.Count\n    for i in range(nEdges):\n      tVerts = mesh.TopologyEdges.GetTopologyVertices(i)\n      p1 = mesh.TopologyVertices[tVerts.I]\n      p2 = mesh.TopologyVertices[tVerts.J]\n      lenEdge =  p1.DistanceTo(p2)\n      if(lenEdge >= maxEdgeLength):\n        mesh.TopologyEdges.SplitEdge(i,.5)\n\n  def subdivideLongNeighbors(self,idx,maxEdgeLength):\n    \"\"\"OLD CODE\"\"\"\n    mesh = self.mesh\n    #minLength = lengthRange[0]\n    #maxLength = lengthRange[1]\n\n    vert = mesh.Vertices[idx]\n    #rs.AddTextDot(\"v\",vert)\n    connectedVertsIdx = mesh.Vertices.GetConnectedVertices(idx)\n\n\n    tVertIdx = mesh.TopologyVertices.TopologyVertexIndex(idx)\n    tVert = mesh.TopologyVertices[tVertIdx]\n    assert (tVert==vert), \"topolgy vert and vert not the same!\"\n\n\n    for neighVertIdx in connectedVertsIdx:\n      if(neighVertIdx !=idx):\n\n\n        tCenterVertIdx = mesh.TopologyVertices.TopologyVertexIndex(idx)\n        tCenterVert = mesh.TopologyVertices[tCenterVertIdx]\n\n        tNeighVertIdx = mesh.TopologyVertices.TopologyVertexIndex(neighVertIdx)\n        tNeighVert = mesh.TopologyVertices[tNeighVertIdx]\n        #rs.AddSphere(tNeighVert,r)\n        dist = rs.Distance(tCenterVert,tNeighVert)\n        strDist = \"%.2f\" % dist\n\n        if(dist >= maxEdgeLength):\n\n          foundEdgeIdx = mesh.TopologyEdges.GetEdgeIndex(tCenterVertIdx,tNeighVertIdx)\n          mesh.TopologyEdges.SplitEdge(foundEdgeIdx,.5)\n\n  def getAvgEdgeLen(self):\n    mesh = self.mesh\n    totLen = 0\n    for i in range(mesh.TopologyEdges.Count):\n      totLen += self.getLenEdge(i)\n    self.avgEdgeLen = totLen/mesh.TopologyEdges.Count\n    return self.avgEdgeLen\n\n  def getLenEdge(self, edgeIdx):\n    mesh = self.mesh\n    edgeLine = mesh.TopologyEdges.EdgeLine(edgeIdx)\n    return edgeLine.Length\n\n  def displayGrowNormals(self,displayLength):\n    mesh = self.mesh\n    for i in range(mesh.Vertices.Count):\n      vertNormal = mesh.Normals[i]\n      feedVec = vertNormal.Multiply(vertNormal,displayLength)\n      vert = mesh.Vertices[i]\n      newLoc = rs.VectorAdd(vert,feedVec)\n      feedLine = rs.AddLine(vert,newLoc)\n\n  def displayVertices(self):\n    mesh = self.mesh\n    for i in range(mesh.Vertices.Count):\n      vert = mesh.Vertices[i]\n      rs.AddPoint(vert)\n\n  def reDraw(self):\n    scriptcontext.doc.Objects.Replace(self.objRef,self.mesh)\n\n  def updateNormals(self):\n    self.mesh.Normals.ComputeNormals()\n    self.mesh.Normals.UnitizeNormals()\n    self.mesh.Compact()\n\n  def saveToLineage(self,ts):\n    print \"saved copy at timeStep: %d\" %ts\n    #scriptcontext.doc.Groups.AddToGroup(self.groupIdx,)\n    self.lineage.append(self.objRef.Mesh().Duplicate())\n\n\n  def displayLineage(self):\n    \"\"\"OLD CODE\"\"\"\n    groupIdx = scriptcontext.doc.Groups.Add()\n\n    bboxMesh = self.mesh.GetBoundingBox(False)\n    spacing = max(bboxMesh.Max.X-bboxMesh.Min.X,bboxMesh.Max.Y-bboxMesh.Min.Y)\n    print \"nSaved: %d\" % len(self.lineage)\n\n    for i in range(len(self.lineage)):\n      tVec = Rhino.Geometry.Vector3d(0,i*spacing,0)\n      bloop = self.lineage[i]\n      print \"type of lineage[%d]:\" %i + str(type(bloop))\n      #if(i!=0):\n      bloop.Translate(tVec)\n      meshGuid = scriptcontext.doc.Objects.AddMesh(bloop)\n      if meshGuid == System.Guid.Empty:\n        print \"addMesh fail: %d\" %i\n      else:\n        scriptcontext.doc.Groups.AddToGroup(groupIdx,meshGuid)\n      #scriptcontext.doc.Objects.AddMesh(bloop)\n\n  def packLineage(self,paramStr):\n    groupIdx = scriptcontext.doc.Groups.Add()\n\n    bboxMesh = self.mesh.GetBoundingBox(False)\n    spacingVec = Rhino.Geometry.Vector3d(0,0,0)\n    for i, mesh in enumerate(self.lineage):\n      mesh.Translate(spacingVec)\n      meshGuid = scriptcontext.doc.Objects.AddMesh(mesh)\n      if meshGuid == System.Guid.Empty:\n        print \"addMesh failed: %d\" %i\n      else:\n        scriptcontext.doc.Groups.AddToGroup(groupIdx,meshGuid)\n      if(i!= len(self.lineage)-1):\n        bboxCurr = mesh.GetBoundingBox(True)\n        bboxNext = self.lineage[i+1].GetBoundingBox(True)\n        bboxCurrLen = bboxCurr.Max.Y-bboxCurr.Min.Y\n        bboxNextLen = bboxNext.Max.Y-bboxNext.Min.Y\n\n        spacingVec.Y += (bboxCurrLen+bboxNextLen)/2.0+.000\n      else:\n        if not rs.SetUserText(meshGuid,\"params\",paramStr,True):\n          print \"SetUserText failed\"\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}