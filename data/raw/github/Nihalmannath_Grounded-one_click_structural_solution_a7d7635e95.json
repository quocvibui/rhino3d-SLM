{
  "source_url": "https://github.com/Nihalmannath/Grounded-one_click_structural_solution/blob/94373d5c3a0ea210040d9de1195b23acb6fba0c2/Website_Development/Structure_generation.py",
  "repo": "Nihalmannath/Grounded-one_click_structural_solution",
  "repo_stars": 0,
  "repo_description": "Research studio/term_2",
  "license": "unknown",
  "filepath": "Website_Development/Structure_generation.py",
  "instruction": "Structure generation",
  "code": "# DONT TOUCH\r\n\r\n# 2. Imports\r\nimport rhino3dm\r\nimport numpy as np\r\nfrom shapely.geometry import Polygon, Point\r\nimport matplotlib.pyplot as plt\r\nfrom mpl_toolkits.mplot3d import Axes3D\r\nimport os\r\nimport pyvista as pv\r\n\r\n# File path\r\nrhino_path = r\"79edaed4-a719-4390-a485-519b68fa68ea\"\r\nif not os.path.exists(rhino_path):\r\n    raise FileNotFoundError(f\"File not found: {rhino_path}\")\r\n\r\n# Load model\r\nmodel = rhino3dm.File3dm.Read(rhino_path)\r\nlayers = {layer.Name.lower(): layer.Index for layer in model.Layers}\r\nif 'building' not in layers or ('column' not in layers and 'columns' not in layers):\r\n    raise RuntimeError(\"Missing required layers: 'building' and 'column' or 'columns'.\")\r\n\r\ncolumn_layer = 'columns' if 'columns' in layers else 'column'\r\n\r\n# Extract building volume & height\r\nbuilding_volumes = []\r\nimported_columns = []\r\nmax_z = 0.0\r\n\r\nwall_breps = []\r\n\r\nfor obj in model.Objects:\r\n    layer_idx = obj.Attributes.LayerIndex\r\n    geom = obj.Geometry\r\n\r\n    if layer_idx == layers['building'] and geom.ObjectType == rhino3dm.ObjectType.Brep:\r\n        bbox = geom.GetBoundingBox()\r\n        base_pts = [\r\n            [bbox.Min.X, bbox.Min.Y],\r\n            [bbox.Max.X, bbox.Min.Y],\r\n            [bbox.Max.X, bbox.Max.Y],\r\n            [bbox.Min.X, bbox.Max.Y]\r\n        ]\r\n        poly = Polygon(base_pts)\r\n        building_volumes.append(poly)\r\n        wall_breps.append({'polygon': poly, 'bbox': bbox})\r\n        max_z = max(max_z, bbox.Max.Z)\r\n\r\n    elif layer_idx == layers[column_layer] and geom.ObjectType == rhino3dm.ObjectType.Brep:\r\n        bbox = geom.GetBoundingBox()\r\n        center_x = (bbox.Min.X + bbox.Max.X) / 2\r\n        center_y = (bbox.Min.Y + bbox.Max.Y) / 2\r\n        imported_columns.append((center_x, center_y))\r\n\r\nif not building_volumes:\r\n    raise RuntimeError(\"No valid building geometry found on the 'building' layer.\")\r\n\r\n# Ask for number of floors\r\nwhile True:\r\n    try:\r\n        num_floors = int(input(\"How many floors does the building have? (e.g., 2): \"))\r\n        if num_floors < 1:\r\n            raise ValueError\r\n        break\r\n    except ValueError:\r\n        print(\"Please enter a valid positive integer for the number of floors.\")\r\n\r\n# Room sorting\r\ndetected_rooms = sorted([(poly, poly.area) for poly in building_volumes], key=lambda x: -x[1])\r\n\r\n# Structural logic\r\nMaxS = 6.0\r\nMinS = 3.0\r\n\r\ncolumns = []\r\ncorrected_columns = []\r\navailable_imported = imported_columns.copy()\r\nexisting_columns = imported_columns.copy()\r\nbeams = []\r\n\r\nfor room_poly, _ in detected_rooms:\r\n    minx, miny, maxx, maxy = room_poly.bounds\r\n    width, height = maxx - minx, maxy - miny\r\n    divisions_x = int(np.ceil(width / MaxS))\r\n    divisions_y = int(np.ceil(height / MaxS))\r\n    x_points = np.linspace(minx, maxx, divisions_x + 1)\r\n    y_points = np.linspace(miny, maxy, divisions_y + 1)\r\n    room_candidates = [(x, y) for x in x_points for y in y_points]\r\n\r\n    for col in room_candidates:\r\n        snap = False\r\n        for imp_col in available_imported:\r\n            if np.linalg.norm(np.array(col) - np.array(imp_col)) < MinS:\r\n                corrected_columns.append(col)\r\n                existing_columns.append(col)\r\n                available_imported.remove(imp_col)\r\n                snap = True\r\n                break\r\n        if not snap and all(np.linalg.norm(np.array(col) - np.array(exist_col)) >= MinS for exist_col in existing_columns):\r\n            columns.append(col)\r\n            existing_columns.append(col)\r\n\r\n    for x in x_points:\r\n        beams.append(((x, miny), (x, maxy)))\r\n    for y in y_points:\r\n        beams.append(((minx, y), (maxx, y)))\r\n\r\n    for corner in list(room_poly.exterior.coords):\r\n        if all(np.linalg.norm(np.array(corner) - np.array(exist_col)) >= MinS * 0.5 for exist_col in existing_columns):\r\n            columns.append(corner)\r\n            existing_columns.append(corner)\r\n\r\n# Combine all base columns\r\nall_base_columns = columns + corrected_columns\r\n\r\n# 8. 2D Visualization (same as before)\r\nfig, ax = plt.subplots(figsize=(10, 10))\r\n\r\n# Room outlines\r\nfor poly, _ in detected_rooms:\r\n    px, py = poly.exterior.xy\r\n    ax.plot(px, py, 'k-', linewidth=1)\r\n\r\n# Generated columns\r\nif columns:\r\n    gx, gy = zip(*columns)\r\n    ax.scatter(gx, gy, c='blue', s=80, label='Generated Columns', zorder=5)\r\n\r\n# Snapped imported columns\r\nif corrected_columns:\r\n    cx, cy = zip(*corrected_columns)\r\n    ax.scatter(cx, cy, c='purple', s=80, label='Snapped Imported Columns', zorder=7)\r\n\r\n# Original imported columns\r\nif imported_columns:\r\n    ix, iy = zip(*imported_columns)\r\n    ax.scatter(ix, iy, c='red', s=80, label='Original Imported Columns', zorder=10)\r\n\r\nintermediate_label_added = False\r\nroof_label_added = False\r\n\r\nfor (x1, y1), (x2, y2) in beams:\r\n    if num_floors > 1:\r\n        for floor in range(1, num_floors):  # intermediate floors\r\n            ax.plot([x1, x2], [y1, y2], color='orange', linestyle=':', linewidth=1,\r\n                    label='Intermediate Floor Beams' if not intermediate_label_added else \"\")\r\n            intermediate_label_added = True\r\n\r\n    ax.plot([x1, x2], [y1, y2], color='green', linestyle='--', linewidth=1.5,\r\n            label='Roof Beams' if not roof_label_added else \"\")\r\n    roof_label_added = True\r\n\r\nax.set_aspect('equal', 'box')\r\nax.legend()\r\nplt.title(\"2D Column and Beam Grid with Snapped Imported Columns\")\r\nax.grid(True)\r\nplt.show()\r\n\r\ndef get_wall_height(x, y, wall_data):\r\n    pt = np.array([x, y])\r\n    closest_wall = None\r\n    closest_dist = float('inf')\r\n\r\n    for wall in wall_data:\r\n        poly = wall['polygon']\r\n        dist = poly.exterior.distance(Point(x, y))\r\n        if dist < closest_dist:\r\n            closest_dist = dist\r\n            closest_wall = wall\r\n\r\n    if closest_wall:\r\n        return closest_wall['bbox'].Max.Z\r\n    else:\r\n        return max_z  # fallback\r\n\r\n\r\n# PyVista 3D visualization\r\nplotter = pv.Plotter(title=\"3D Structural System\")\r\n\r\n# Columns as vertical cylinders\r\nfor x, y in all_base_columns:\r\n    wall_height = get_wall_height(x, y, wall_breps)\r\n    cylinder = pv.Cylinder(center=(x, y, wall_height / 2), direction=(0, 0, 1),\r\n                       radius=0.1, height=wall_height)\r\n\r\n    plotter.add_mesh(cylinder, color='blue')\r\n\r\n# Beams as thinner cylinders\r\nbeam_radius = 0.04  # thinner than column radius 0.1\r\n\r\nfor (x1, y1), (x2, y2) in beams:\r\n    h1 = get_wall_height(x1, y1, wall_breps)\r\n    h2 = get_wall_height(x2, y2, wall_breps)\r\n    floor_height = min(h1, h2)\r\n\r\n    for floor in range(1, num_floors + 1):\r\n        z = floor_height / num_floors * floor\r\n\r\n        # Skip beams above wall height (important for cantilevers or partial-height volumes)\r\n        if z > h1 or z > h2:\r\n            continue\r\n\r\n        start = np.array([x1, y1, z])\r\n        end = np.array([x2, y2, z])\r\n\r\n        direction = end - start\r\n        length = np.linalg.norm(direction)\r\n        if length < 1e-6:\r\n            continue\r\n        direction = direction / length\r\n        center = (start + end) / 2\r\n        beam = pv.Cylinder(center=center, direction=direction, radius=beam_radius, height=length)\r\n\r\n        color = 'green' if floor == num_floors else 'orange'\r\n        plotter.add_mesh(beam, color=color)\r\n\r\n\r\n\r\n# Actual Brep-based walls visualization\r\ndef mesh_brep(brep, mesh_type=rhino3dm.MeshType.Any):\r\n    meshes = []\r\n    for face in brep.Faces:\r\n        try:\r\n            m = face.GetMesh(mesh_type)\r\n            if m: meshes.append(m)\r\n        except:\r\n            continue\r\n    return meshes\r\n\r\nfor obj in model.Objects:\r\n    geom = obj.Geometry\r\n    layer_idx = obj.Attributes.LayerIndex\r\n    if layer_idx == layers['building'] and isinstance(geom, rhino3dm.Brep):\r\n        meshes = mesh_brep(geom)\r\n        for mesh in meshes:\r\n            pts = [(v.X, v.Y, v.Z) for v in mesh.Vertices]\r\n            faces = []\r\n            for f in mesh.Faces:\r\n                if len(f) == 4:\r\n                    idxs = (f[0], f[1], f[2], f[3])\r\n                else:\r\n                    idxs = (f[0], f[1], f[2])\r\n                faces.append((len(idxs),) + idxs)\r\n            faces_flat = [i for face in faces for i in face]\r\n            pv_mesh = pv.PolyData(pts, faces_flat)\r\n            plotter.add_mesh(pv_mesh, color='lightgray', opacity=0.3)\r\n\r\n# Set up the camera and show\r\nplotter.show_grid()\r\nplotter.show()\r\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}