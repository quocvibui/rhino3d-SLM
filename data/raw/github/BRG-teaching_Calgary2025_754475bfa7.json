{
  "source_url": "https://github.com/BRG-teaching/Calgary2025/blob/05cb4f76aa7ff43a113f0f6ff494970d5c7756c4/000_model/013_index_and_pack.py",
  "repo": "BRG-teaching/Calgary2025",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "000_model/013_index_and_pack.py",
  "instruction": "venv: brg-csd",
  "code": "#! python3\n# venv: brg-csd\n\nimport pathlib\n\nimport compas\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Frame, Sphere, Brep, Transformation\nfrom compas_rhino.conversions import frame_to_rhino_plane\nfrom compas.scene import Scene\nimport rhinoscriptsyntax as rs\nimport Rhino.Geometry as rg\nimport scriptcontext as sc\n\n\nscene = Scene()\nscene.clear_context()\n\n# =============================================================================\n# Load data\n# =============================================================================\n\nIFILE = pathlib.Path(__file__).parent.parent / \"data\" / \"011_mesh.json\"\ndual: Mesh = compas.json_load(IFILE)\n\nblock_breps = {face: Brep.from_mesh(dual.face_attribute(face, \"block\")) for face in dual.faces()}\n\n\n# =============================================================================\n# Making Sphere Joinery\n# =============================================================================\n\nfor edge in dual.edges():\n    face1, face2 = dual.edge_faces(edge)\n    if face1 is not None and face2 is not None:\n        line = dual.edge_line(edge)\n        z_axis = line.direction\n        x_axis = dual.vertex_normal(edge[0]) + dual.vertex_normal(edge[1])\n        y_axis = x_axis.cross(z_axis)\n\n        # Create frames at 0.3 and 0.7 along the edge\n        p1 = line.point_at(0.3)\n        p2 = line.point_at(0.7)\n\n        sphere1a = Sphere(2.5, point=p1)\n        sphere1b = Sphere(2.5, point=p2)\n\n        sphere2a = Sphere(2.3, point=p1)\n        sphere2b = Sphere(2.3, point=p2)\n\n        block1 = block_breps[face1]\n        block2 = block_breps[face2]\n\n        # make two spheres along the edge\n        block1 = block1 - sphere1a.to_brep()\n        block1 = block1 - sphere1b.to_brep()\n        block2 = block2 + sphere2a.to_brep()\n        block2 = block2 + sphere2b.to_brep()\n\n        block_breps[face1] = block1\n        block_breps[face2] = block2\n\n# =============================================================================\n# Create Index Texts\n# =============================================================================\n\n\ndef create_3d_text(text, plane, group_name, height=8.0, extrusion_distance=0.5):\n    \"\"\"Create 3D text geometry in Rhino and add it to a group.\n\n    Args:\n        text (str): The text to create\n        plane: Rhino plane for text placement\n        group_name (str): Name of the group to add text objects to\n        height (float): Text height\n        extrusion_distance (float): Depth of the 3D text\n\n    Returns:\n        list: List of COMPAS Brep objects representing the 3D text\n    \"\"\"\n    # Create 2D text\n    text_obj = rs.AddText(text, plane, height, justification=2)\n\n    # Explode text into curves\n    text_curves = rs.ExplodeText(text_obj, True)\n\n    # Create surfaces from the curves\n    text_surfaces = rs.AddPlanarSrf(text_curves)\n\n    # Convert surfaces to Rhino geometry\n    rhino_surfaces = [rs.coercesurface(srf) for srf in text_surfaces]\n\n    # Create extruded 3D text\n    text_3d = []\n\n    for srf in rhino_surfaces:\n        brep = rg.Brep.CreateFromOffsetFace(srf, extrusion_distance, 0.01, True, True)\n        text_3d.append(sc.doc.Objects.AddBrep(brep))\n\n    # Clean up temporary objects\n    rs.DeleteObjects(text_curves + text_surfaces + [text_obj])\n\n    # Group the 3D text objects\n    rs.AddObjectsToGroup(text_3d, group_name)\n\n\nrs.AddGroup(\"index_in_place\")\nfor i, face in enumerate(dual.faces()):\n    top_frame = dual.face_attribute(face, \"top_frame\").copy()\n    top_frame.flip()\n    plane = frame_to_rhino_plane(top_frame)\n    create_3d_text(str(i), plane, \"index_in_place\")\n\n# =============================================================================\n# Packing\n# =============================================================================\n\n# Create a grid layout for the blocks\ngrid_size = 120  # spacing between blocks\nblocks_per_row = int(len(block_breps) ** 0.5) + 1  # approximate square grid\n\nrs.AddGroup(\"index_packed\")\n\nblocks_transformed = []\nfor i, face in enumerate(dual.faces()):\n\n    block = block_breps[face]\n\n    top_face_frame = dual.face_attribute(face, \"top_frame\")\n\n    # Calculate grid position\n    row = i // blocks_per_row\n    col = i % blocks_per_row\n\n    # Create target frame with Z pointing up (top face will be down)\n    target_point = [col * grid_size + 1200, row * grid_size, 0]\n    target_frame = Frame.worldXY()\n    target_frame.point = target_point\n\n    T = Transformation.from_frame_to_frame(top_face_frame, target_frame)\n    blocks_transformed.append(block.transformed(T))\n\n    # Add index text\n    bottom_frame = dual.face_attribute(face, \"bottom_frame\")\n    bottom_frame_packed = bottom_frame.transformed(T)\n    plane = frame_to_rhino_plane(bottom_frame_packed)\n    create_3d_text(str(i), plane, \"index_packed\")\n\n\n# =============================================================================\n# Visualisation\n# =============================================================================\n\nfor block in block_breps.values():\n    scene.add(block)\n\nfor block in blocks_transformed:\n    scene.add(block)\n\nscene.draw()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}