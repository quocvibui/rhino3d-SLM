{
  "source_url": "https://discourse.mcneel.com/t/meshface-set-how-does-it-work/133700",
  "topic_id": 133700,
  "title": "MeshFace.Set -- how does it work?",
  "question": "Greetings.\n\nFor example, if I need to change in a mesh quad face one vertex to another by swaping their indeces?\n\nIâ€™m trying to use this method \nMeshFace.Set Method (Int32, Int32, Int32, Int32)\n\nHeres my code:\n\n\nMesh_Faces_list = My_Mesh_Ref.Faces\n    \nthis_face = Mesh_Faces_list.GetFace(1)\nprint(\"Before:\")\nprint(this_face)\n\nprint(\"Trying:\")\nthis_face.Set(1, 2, 3, 4)\nprint(this_face)\n\nprint(\"After:\")\nMesh_Faces_list = My_Mesh_Ref.Faces\nthis_face = Mesh_Faces_list.GetFace(1)\nprint(this_face)\n\n\n\nBut I get this result:\n\n\nBefore:\nQ(5, 3, 2, 4)\nTrying:\nQ(1, 2, 3, 4)\nAfter:\nQ(5, 3, 2, 4)\n\n\n\nTheres also Item method which seems may do the same\n\n\n\n\n\n\ndeveloper.rhino3d.com\n\n\n\n\n\n\nMeshFace.Item Property\n\n\nGets or sets the vertex index associated with an entry in this face.\n\n\n\n\n\n\n\n\n\n\n\n\nprint(\"Trying:\")\nthis_face.Item[1] = 11\nprint(this_face)\n\n\n\nBut the result is the same",
  "code_blocks": [
    {
      "code": "import Rhino\n\nprint My_Mesh_Ref.Faces[1]\n\nMy_Mesh_Ref.Faces[1] = Rhino.Geometry.MeshFace(1, 2, 3, 4)\n\nprint My_Mesh_Ref.Faces[1]",
      "language": "python",
      "author": "diff-arch",
      "post_number": 2,
      "is_solution": true
    },
    {
      "code": "# SPIN EDGE V1\n\nimport Rhino\nimport Rhino.Geometry as rg\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\n\ndef SpinEdge():\n    \n    go = Rhino.Input.Custom.GetObject()\n    go.SetCommandPrompt(\"Select edge to orient\")\n    go.GeometryAttributeFilter = Rhino.Input.Custom.GeometryAttributeFilter.InnerLoop\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.EdgeFilter\n    #go.GeometryFilter = Rhino.DocObjects.ObjectType.MeshEdge\n    #go.GeometryAttributeFilter = Rhino.Input.Custom.GeometryAttributeFilter.EdgeCurve\n    go.Get()\n    objref = go.Object(0)\n    subd = rs.coercegeometry(objref.ObjectId) #coerce guid\n    geo = objref.Geometry()\n    picked_edge_id = objref.GeometryComponentIndex.Index\n    \n    picked_subd_edge = subd.Edges.Find(picked_edge_id)\n    if picked_subd_edge.FaceCount == 2:\n        face1 = picked_subd_edge.FaceAt(0)\n        face2 = picked_subd_edge.FaceAt(1)\n    else:\n        print \"Cannot spin Naked Edge.\"\n        return\n    \n    #cant handle triangles yet\n    #also appears to be an issue when two edges are a straight line\n    #this might be during subd creation or mesh?\n    # Manually Loop through subd quad faces (assuming they're quads not tris)\n    \n    subd_verts = [picked_subd_edge.VertexFrom.Id, picked_subd_edge.VertexTo.Id]\n    face1, face2 = subd.Faces.Find(face1.Id), subd.Faces.Find(face2.Id)\n    \n    mesh = rg.Mesh.CreateFromSubDControlNet(subd)\n    meshfaces, meshverts = mesh.Faces, mesh.Vertices\n    meshverts.UseDoublePrecisionVertices = True\n    p3d = meshverts.ToPoint3dArray()\n    \n    picked_mesh_edge_indices = []\n    face_verts = []\n    \n    # Get mesh vertices from subd vertices\n    for index, i in enumerate(p3d):\n        if i.DistanceTo(subd.Vertices.Find(subd_verts [0]).ControlNetPoint) == 0:\n            picked_mesh_edge_indices.append(index)\n    \n    for index, i in enumerate(p3d):\n        if i.DistanceTo(subd.Vertices.Find(subd_verts [1]).ControlNetPoint) == 0:\n            picked_mesh_edge_indices.append(index)\n    \n    # Determine the adjacent Mesh face indices and hence Corner Indices\n    all_faces =  [ meshverts.GetVertexFaces(i) for i in picked_mesh_edge_indices ]\n    for i in all_faces:\n        for vert in i:\n            face_verts.append(vert)\n    \n    face_verts_set = set(face_verts)\n    selected_faces = []\n    for i in face_verts_set:\n        if face_verts.count(i) > 1:\n            selected_faces.append(i)\n    \n    vert0, vert1 = picked_mesh_edge_indices[0], picked_mesh_edge_indices[1]\n    face1_corners_list = [ vert for vert in meshfaces.Item[selected_faces[0]] ]\n    face2_corners_list = [ vert for vert in meshfaces.Item[selected_faces[1]] ]\n    print \"Adjacent Mesh Face Indices are\", selected_faces\n    print \"Mesh Face 1 Corner Indices:\", meshfaces.Item[selected_faces[0]]\n    print \"Mesh Face 2 Corner Indices:\", meshfaces.Item[selected_faces[1]]\n    print \"Edge Indices:\", vert0, \";\", vert1\n    \n    #Worked through example:\n    # [14,30,16,2] [18,30,14,3] 14/30:30/14 relation, rplace second/last occurence\n    # becomes >>>\n    # [14,3,16,2] [18,30,16,3]\n    # if both lists order with 14,30 then 14,30; may be an issue with normals if adjacent (cw/ccw)\n    #clockwise next vert after edge verts, from 30 on face 1 >> 16\n    #clockwise next vert after edge verts, from 14 on face 2 >> 3\n    #in each face, the last edge vert is replaced by the next cw vert\n    #eg 30 would be replaced with 3; 14 would be replaced with 16\n    # get list index of edge vert index 1, get list index of edge vert index 2; see which is bigger\n    #in both lists, get the index of where each value is from those selected\n    #store as dict eg 14:0 30:1, 30:1 14:2\n    #if index position difference is greater than one, theyre at ends, use the smallest\n    \n    def FunctionifyTbd(picked_mesh_edge_indices, face1_corners_list):\n        for i in picked_mesh_indices:\n            if i in face1_corners_list:\n                mydict1[i] = face1_corners_list.index(i)\n        \n        dictionary = {}\n        \n        if abs(dictionary.get(vert0) - dictionary.get(vert1)) >1:\n            #if difference between dict values is > 1, use index of 0\n            # i.e. [0*,1,2,3*] <<< difference = 3, Tris [0*,1,2*]\n            face_index_to_edit = 0\n        else:\n            if dictionary.get(vert0) > dictionary.get(vert1):\n                face_index_to_edit = dictionary.get(vert0)\n            else:\n                face_index_to_edit = dictionary.get(vert1)\n        \n        next_index = face_index_to_edit+1\n        if next_index == 4:\n            next_index = 0\n\n\n    mydict1 = {}\n    mydict2 = {}\n    \n    #generate index locations of the picked vertices\n    #in respect to each faces makeup in terms of vertices\n    for i in picked_mesh_edge_indices:\n        if i in face1_corners_list:\n            mydict1[i] = face1_corners_list.index(i)\n        if i in face2_corners_list:\n            mydict2[i] = face2_corners_list.index(i)\n    if mydict1.get(vert0) == mydict1.get(vert0) | mydict2.get(vert0) == mydict2.get:\n        print \"Hmm, something's up\"\n    \n    print \"Dictionaries for Edge Vertex Location in Lists:\", mydict1, mydict2\n    \n    # checking difference, if the edges are at list ends, if difference is >1\n    if abs(mydict1.get(vert0) - mydict1.get(vert1)) >1:\n        #if difference between dict values is > 1, use index of 0\n        # i.e. [0*,1,2,3*] <<< difference = 3, Tris [0*,1,2*]\n        edit_face0_index = 0\n    else:\n        if mydict1.get(vert0) > mydict1.get(vert1):\n            edit_face0_index = mydict1.get(vert0)\n        else:\n            edit_face0_index = mydict1.get(vert1)\n    \n    if abs(mydict2.get(vert0) - mydict2.get(vert1)) >1:\n        edit_face1_index = 0\n    else:\n        if mydict2.get(vert0) > mydict2.get(vert1):\n            edit_face1_index = mydict2.get(vert0)\n        else:\n            edit_face1_index = mydict2.get(vert1)\n    \n    print \"Indices to edit:\", \"face0:\", edit_face0_index, \"face1:\", edit_face1_index\n    \n    next_index_0 = edit_face0_index+1 #need to not let it be 4, ie 3+1, if tris then 2+1\n    next_index_1 = edit_face1_index+1\n    if next_index_0 == 4:\n        next_index_0 = 0\n    if next_index_1 == 4:\n        next_index_1 = 0\n    \n    \"\"\"\n    if next_index_0 == 3:\n        next_index_0 = 0\n    if next_index_1 == 3:\n        next_index_1 = 0\n    \"\"\"\n    \n    new_face_0, new_face_1 = face1_corners_list, face2_corners_list\n    list0_extracted_value = face1_corners_list[ next_index_0 ]\n    list1_extracted_value = face2_corners_list[ next_index_1 ]\n    \n    #then swap\n    new_face_0[edit_face0_index] = list1_extracted_value\n    new_face_1[edit_face1_index] = list0_extracted_value\n    \n    print \"face 1:\", new_face_0, \"face 2:\", new_face_1\n    \n    # if the biggest dict value is 3, 0 index is the one to be swapped\n    # else dict value +1 is what is taken and used in other list\n    \n    #meshfaces.Item[selected_faces[0]] = rg.MeshFace(new_face_0[0],new_face_0[1],new_face_0[2], new_face_0[3])\n    #meshfaces.Item[selected_faces[1]] = rg.MeshFace(new_face_1[0],new_face_1[1],new_face_1[2], new_face_1[3])\n    \n    print \"face0 index to edit:\", edit_face0_index, \"face1 index to edit:\", edit_face1_index\n    print \"value in face0 to replace with:\", list1_extracted_value, \"value in face1 to replace with:\", list0_extracted_value\n    print meshfaces.Item[selected_faces[0]]\n    print meshfaces.Item[selected_faces[1]]\n    \n    meshfaces.Item[selected_faces[0]].Item[edit_face0_index] = list1_extracted_value\n    meshfaces.Item[selected_faces[1]].Item[edit_face1_index] = list0_extracted_value\n    \n    print meshfaces.Item[selected_faces[0]]\n    print meshfaces.Item[selected_faces[1]]\n    \n    #Add SubD\n    newsubd = rg.SubD.CreateFromMesh( mesh )\n    sc.doc.Objects.Replace(objref.ObjectId, newsubd) #use guid to replace\n\nif __name__ == \"__main__\":\n    SpinEdge()",
      "language": "python",
      "author": "Jonathan_Hutchinson",
      "post_number": 14,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "mesh",
    "python",
    "rhinocommon",
    "rhinoscriptsyntax",
    "selection",
    "transformation"
  ],
  "has_accepted_answer": true,
  "category_id": 11,
  "posts_count": 15,
  "views": 1124
}