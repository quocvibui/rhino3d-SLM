{
  "source_url": "https://github.com/ar0551/Wasp/blob/66f63c018f2420d37aa451ade0178de260946b0c/src/ghComp/Wasp_Aggregation%20Graph.py",
  "repo": "ar0551/Wasp",
  "repo_stars": 67,
  "repo_description": "Combinatorial Design with Grasshopper plug-in (LGPL) initiated by Andrea Rossi",
  "license": "LGPL-3.0",
  "filepath": "src/ghComp/Wasp_Aggregation Graph.py",
  "instruction": "Extract the aggregation graph.\n-\nProvided by Wasp 0.6\n    Args:\n        AGGR: Aggregation from which to extract the graph\n        FG: OPTIONAL // True to compute the full graph (including edges on...",
  "code": "# Wasp: Discrete Design with Grasshopper plug-in (LGPL) initiated by Andrea Rossi\n# \n# This file is part of Wasp.\n# \n# Copyright (c) 2017-2023, Andrea Rossi <a.rossi.andrea@gmail.com>\n# Wasp is free software; you can redistribute it and/or modify \n# it under the terms of the GNU Lesser General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Wasp is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU Lesser General Public License for more details.\n# \n# You should have received a copy of the GNU Lesser General Public License\n# along with Wasp; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license LGPL-3.0 https://www.gnu.org/licenses/lgpl-3.0.html\n#\n# Early development of Wasp has been carried out by Andrea Rossi\n# as part of research on digital materials and discrete design at:\n# DDU Digital Design Unit - Prof. Oliver Tessmann\n# Technische Universitt Darmstadt\n\n\n#########################################################################\n##                            COMPONENT INFO                           ##\n#########################################################################\n\n\"\"\"\nExtract the aggregation graph.\n-\nProvided by Wasp 0.6\n    Args:\n        AGGR: Aggregation from which to extract the graph\n        FG: OPTIONAL // True to compute the full graph (including edges on overlapping connections), False to create only the aggregation sequence graph (True by default)\n        TOL: OPTIONAL // Tolerance below which two connections will be considered connected (only for full graph mode - default is Wasp global tolerance)\n        FR: OPTIONAL // When computing the full graph, filter the found connections according to a custom rule set (False by default)\n        CR: OPTIONAL // When computing the full graph with FR set to True, rules to use as connection filter (default values are the Aggregation rules)\n        F: OPTIONAL // True to flatten the edges list, False to maintain edges grouped by node (True by default)\n    Returns:\n        G: Aggregation graph\n        N: Graph nodes (each placed at a part's center)\n        E: Graph edges as lines\n        ES_ID: part ID at edge start\n        EE_ID: part ID at edge end\n        CS_ID: connection ID at edge start\n        CE_ID: connection ID at edge end\n\"\"\"\n\nghenv.Component.Name = \"Wasp_Aggregation Graph\"\nghenv.Component.NickName = 'AggregationGraph'\nghenv.Component.Message = 'v0.6.001'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"Wasp\"\nghenv.Component.SubCategory = \"6 | Aggregation\"\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"2\"\nexcept: pass\n\nimport sys\nimport Rhino.Geometry as rg\nimport Grasshopper as gh\nimport ghpythonlib.treehelpers as th\n\n\n## add Wasp install directory to system path\nwasp_loaded = False\nghcompfolder = gh.Folders.DefaultAssemblyFolder\nif ghcompfolder not in sys.path:\n    sys.path.append(ghcompfolder)\ntry:\n    from wasp import __version__\n    wasp_loaded = True\nexcept:\n    msg = \"Cannot import Wasp. Is the wasp folder available in \" + ghcompfolder + \"?\"\n    ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Error, msg)\n\n## if Wasp is installed correctly, load the classes required by the component\nif wasp_loaded:\n    from wasp.core import Aggregation, Graph\n    from wasp import global_tolerance\n\n\ndef main(aggregation, full_graph, tolerance, filter_by_rules, custom_rules, flatten_edges):\n    \n    check_data = True\n    \n    ##check inputs\n    if aggregation is None:\n        check_data = False\n        msg = \"No aggregation provided\"\n        ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Warning, msg)\n    \n    if full_graph is None:\n        full_graph = True\n    \n    if tolerance is None:\n        tolerance = global_tolerance\n    \n    if filter_by_rules is None:\n        filter_by_rules = False\n    \n    if flatten_edges is None:\n        flatten_edges = True\n    \n    if check_data:\n        \n        ## compute aggregation graph\n        g = None\n        if full_graph:\n            g = Graph.from_aggregation(aggregation, full_graph, tolerance, filter_by_rules, custom_rules)\n        else:\n            g = aggregation.graph\n        \n        ## extract graph data\n        nodes = [int(n) for n in g.get_nodes()]\n        edges = g.get_edges(flatten = flatten_edges)\n        edges_attributes = g.get_edges_attributes(flatten = flatten_edges)\n        \n        ## generate geometric representation\n        nodes_pts = [aggregation.aggregated_parts[int(i)].center for i in sorted(nodes)]\n        \n        edges_lines = []\n        if flatten_edges:\n            for edge in edges:\n                start = aggregation.aggregated_parts[int(edge[0])].center\n                end = aggregation.aggregated_parts[int(edge[1])].center\n                edges_lines.append(rg.Line(start, end))\n        else:\n            for i in range(len(edges)):\n                edges_lines.append([])\n                for edge in edges[i]:\n                    start = aggregation.aggregated_parts[int(edge[0])].center\n                    end = aggregation.aggregated_parts[int(edge[1])].center\n                    edges_lines[i].append(rg.Line(start, end))\n                \n        \n        ## format data for GH outputs\n        edge_start_ids = []\n        edge_end_ids =[]\n        conn_start_ids =[]\n        conn_end_ids =[]\n        \n        if flatten_edges:\n            for edge_attr in edges_attributes:\n                edge_start_ids.append(edge_attr['start'])\n                edge_end_ids.append(edge_attr['end'])\n                conn_start_ids.append(edge_attr['conn_start'])\n                conn_end_ids.append(edge_attr['conn_end'])\n        else:\n            for i in range(len(edges_attributes)):\n                edge_start_ids.append([])\n                edge_end_ids.append([])\n                conn_start_ids.append([])\n                conn_end_ids.append([])\n                for edge_attr in edges_attributes[i]:\n                    edge_start_ids[i].append(edge_attr['start'])\n                    edge_end_ids[i].append(edge_attr['end'])\n                    conn_start_ids[i].append(edge_attr['conn_start'])\n                    conn_end_ids[i].append(edge_attr['conn_end'])\n        \n        \n        \"\"\"\n        for i in range(len(aggregation.aggregated_parts)):\n            p = aggregation.aggregated_parts[i]\n            \n            nodes.append(aggregation.aggregated_parts[i].center)\n            edges.append([])\n            \n            edge_start_ids.append([])\n            edge_end_ids.append([])\n            \n            conn_start_ids.append([])\n            conn_end_ids.append([])\n            \n            neighbours = []\n            for i2 in range(len(aggregation.aggregated_parts)):\n                if aggregation.aggregated_parts[i].id != aggregation.aggregated_parts[i2].id:\n                    p_dist = aggregation.aggregated_parts[i].center.DistanceTo(aggregation.aggregated_parts[i2].center)\n                    if p_dist < (aggregation.aggregated_parts[i].dim + aggregation.aggregated_parts[i2].dim)*1.5:\n                        neighbours.append(i2)\n            for i2 in range(len(p.connections)):\n                for i3 in neighbours:\n                    other_p = aggregation.aggregated_parts[i3]\n                    if aggregation.aggregated_parts[i3].id != p.id:\n                        for i4 in range(len(aggregation.aggregated_parts[i3].connections)):\n                            c_dist = p.connections[i2].pln.Origin.DistanceTo(aggregation.aggregated_parts[i3].connections[i4].pln.Origin)\n                            if c_dist < 0.01:\n                                \n                                edge = rg.Line(p.center, aggregation.aggregated_parts[i3].center)\n                                edges[i].append(edge)\n                                \n                                edge_start_ids[i].append(i)\n                                edge_end_ids[i].append(i3)\n                                \n                                conn_start_ids[i].append(i2)\n                                conn_end_ids[i].append(i4)\n        \"\"\"\n        \n        if flatten_edges:\n            return g, nodes_pts, edges_lines, edge_start_ids, edge_end_ids, conn_start_ids, conn_end_ids\n        else:\n            \n            edges_lines_dt = th.list_to_tree(edges_lines)\n            \n            edge_start_ids_dt = th.list_to_tree(edge_start_ids)\n            edge_end_ids_dt = th.list_to_tree(edge_end_ids)\n            conn_start_ids_dt = th.list_to_tree(conn_start_ids)\n            conn_end_ids_dt = th.list_to_tree(conn_end_ids)\n            \n            return g, nodes_pts, edges_lines_dt, edge_start_ids_dt, edge_end_ids_dt, conn_start_ids_dt, conn_end_ids_dt\n        \n    else:\n        return -1\n\nresult = main(AGGR, FG, TOL, FR, CR, F)\n\nif result != -1:\n    G = result[0]\n    N = result[1]\n    E = result[2]\n    \n    ES_ID = result[3]\n    EE_ID = result[4]\n    CS_ID = result[5]\n    CE_ID = result[6]\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}