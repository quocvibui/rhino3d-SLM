{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_multi_layer_sheathing.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_multi_layer_sheathing.py",
  "instruction": "Multi-Layer Sheathing Generator for Grasshopper.",
  "code": "# File: scripts/gh_multi_layer_sheathing.py\n\"\"\"Multi-Layer Sheathing Generator for Grasshopper.\n\nGenerates panels for ALL panelizable layers in a wall assembly (substrate,\nfinish, thermal) using the multi-layer generator. Each layer is positioned\nat its correct W offset and configured with per-layer material defaults,\npanel sizes, and optional user overrides.\n\nKey Features:\n1. Full Assembly Coverage\n   - Processes every panelizable layer (substrate, finish, thermal)\n   - Skips structural and membrane layers automatically\n   - Configurable layer function filtering via include_functions\n\n2. Per-Layer Configuration\n   - Each layer receives material and panel size defaults based on function\n   - Per-layer overrides via layer_configs in config_json\n   - Base config applied to all layers unless overridden\n\n3. Junction Integration\n   - Computes per-face U-axis bounds from Junction Analyzer adjustments\n   - Panels extend or trim at wall ends for proper junction coverage\n   - Handles flipped walls by swapping exterior/interior face labels\n\n4. JSON Pipeline\n   - Accepts walls_json from Wall Analyzer\n   - Outputs multi_layer_json for downstream geometry conversion\n   - Inspectable intermediate data with Panel or jSwan\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n\nDependencies:\n    - Grasshopper: Component framework\n    - json: Serialization\n    - timber_framing_generator.sheathing.multi_layer_generator: Core generation logic\n\nPerformance Considerations:\n    - Processing time scales with wall count and layer count per wall\n    - Each layer runs a full SheathingGenerator pass (panel layout + cutouts)\n    - Walls without wall_assembly are skipped with a warning\n\nUsage:\n    1. Connect 'walls_json' from Wall Analyzer component (input 0)\n    2. Optionally connect 'junctions_json' from Junction Analyzer (input 1)\n    3. Connect 'config_json' from Config Builder (or manual JSON) (input 2)\n    4. Optionally connect 'framing_json' from Framing Generator (input 3)\n    5. Optionally connect 'panels_json' from Panel Decomposer (input 4)\n    6. Set 'run' (input 5) to True to execute\n    7. Collect 'multi_layer_json' for downstream geometry conversion\n    8. View 'layer_summary' for per-layer panel counts\n\n    Note: Component requires 6 inputs. If fewer are present, add inputs\n    via ZUI (right-click component -> + icon) until you have 6.\n\nInput Requirements:\n    Index 0 - Walls JSON (walls_json) - str:\n        JSON string from Wall Analyzer with wall geometry data.\n        Must contain wall_assembly with layers list.\n        Required: Yes\n        Access: Item\n\n    Index 1 - Junctions JSON (junctions_json) - str:\n        Optional JSON from Junction Analyzer for per-layer adjustments.\n        When connected, panels are extended or trimmed at wall ends\n        to account for wall intersections (L-corners, T-junctions).\n        Required: No\n        Access: Item\n\n    Index 2 - Config JSON (config_json) - str:\n        Configuration JSON from Config Builder component. Contains:\n        - assembly_mode: \"auto\" or \"revit\" (default: \"auto\")\n        - framing_system: \"timber\" or \"cfs\" (default: \"timber\")\n        - assembly_overrides: Per-Wall-Type assembly mappings (optional)\n        - faces: List of faces to process (default [\"exterior\", \"interior\"])\n        - panel_size: Default panel size (default \"4x8\")\n        - include_functions: Layer function filter (optional)\n        - layer_configs: Per-layer config overrides (optional)\n        Required: No\n        Access: Item\n\n    Index 3 - Framing JSON (framing_json) - str:\n        Optional JSON from Framing Generator. When connected, extracts\n        per-wall stud profile depth to prevent sheathing overlap with\n        CFS or oversized framing.\n        Required: No\n        Access: Item\n\n    Index 4 - Panels JSON (panels_json) - str:\n        Optional JSON from Panel Decomposer. When connected, sheathing\n        is generated per framing panel so sheets don't cross panel joints.\n        Required: No\n        Access: Item\n\n    Index 5 - Run (run) - bool:\n        Boolean to trigger execution.\n        Required: Yes\n        Access: Item\n\nOutputs:\n    Multi-Layer JSON (multi_layer_json) - str:\n        JSON string with all layer results per wall, including panel positions,\n        W offsets, material summaries, and placement rules applied.\n\n    Layer Summary (layer_summary) - str:\n        Per-layer material summary showing panel counts per wall and layer.\n\n    Stats (stats) - str:\n        Quick stats: total panels, layers processed, walls processed.\n\n    Log (log) - str:\n        Processing log with debug information.\n\nTechnical Details:\n    - Uses generate_assembly_layers() from multi_layer_generator module\n    - Each layer is matched to a default material based on function + side\n    - W offsets computed from assembly layer stack for correct 3D placement\n    - Flipped walls swap exterior/interior face labels before processing\n\nError Handling:\n    - Invalid JSON returns empty results with error in log\n    - Walls without wall_assembly are skipped with warning\n    - Per-layer errors are caught and logged without stopping other layers\n    - Empty results return valid JSON structure with zero counts\n\nAuthor: Timber Framing Generator\nVersion: 0.2.9\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\n# Rhino / Grasshopper\nimport Grasshopper\n\n# =============================================================================\n# Project Setup\n# =============================================================================\n\n# Primary: worktree / feature-branch path (contains wall_junctions, etc.)\n# Fallback: main repo path (for when this file is used from the main checkout)\n_WORKTREE_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\tfg-sheathing-junctions\"\n_MAIN_REPO_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator\"\n\n# Ensure worktree path has highest priority (index 0) in sys.path.\n# Other GH components may have already added the main repo path, so we\n# remove both and re-insert in correct priority order.\nfor _p in (_WORKTREE_PATH, _MAIN_REPO_PATH):\n    while _p in sys.path:\n        sys.path.remove(_p)\nsys.path.insert(0, _MAIN_REPO_PATH)\nsys.path.insert(0, _WORKTREE_PATH)\n\n# =============================================================================\n# Module Reload (Development Only)\n# =============================================================================\n\n# Force reload of project modules during development\n# Set to False in production for better performance\nFORCE_RELOAD = True\n\nif FORCE_RELOAD:\n    # Clear timber_framing_generator modules AND the 'src' package itself.\n    # Other GH components may have already imported 'src', caching its\n    # __path__ to the main repo.  Clearing it forces Python to re-resolve\n    # 'src' from the updated sys.path (worktree at index 0).\n    modules_to_reload = [key for key in sys.modules.keys()\n                         if 'timber_framing_generator' in key\n                         or key == 'src']\n    for mod_name in modules_to_reload:\n        del sys.modules[mod_name]\n\n# =============================================================================\n# Project Imports (after reload)\n# =============================================================================\n\nfrom src.timber_framing_generator.sheathing.multi_layer_generator import (\n    generate_assembly_layers,\n    extract_max_framing_depth,\n)\nfrom src.timber_framing_generator.config.assembly import get_assembly_for_wall\nfrom src.timber_framing_generator.config.assembly_resolver import (\n    resolve_all_walls,\n    summarize_resolutions,\n)\nfrom src.timber_framing_generator.wall_junctions.junction_resolver import (\n    recompute_adjustments,\n)\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Multi-Layer Sheathing Generator\"\nCOMPONENT_NICKNAME = \"MLSheath\"\nCOMPONENT_MESSAGE = \"v2.9-panels-input\"\n\n# Version marker — confirms the updated script is running in GH\nprint(\"[MLSheath] Script version v2.9 loaded (panels_json as standard input)\")\nCOMPONENT_CATEGORY = \"Timber Framing\"\nCOMPONENT_SUBCATEGORY = \"4-Sheathing\"\n\n# Default configuration\nDEFAULT_CONFIG = {\n    \"panel_size\": \"4x8\",\n    \"faces\": [\"exterior\", \"interior\"],\n}\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message, level=\"info\"):\n    \"\"\"Log to console and optionally add GH runtime message.\"\"\"\n    print(f\"[{level.upper()}] {message}\")\n\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n\n\ndef log_info(message):\n    \"\"\"Log info message (console only).\"\"\"\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message):\n    \"\"\"Log warning message (console + GH UI).\"\"\"\n    log_message(message, \"warning\")\n\n\ndef log_error(message):\n    \"\"\"Log error message (console + GH UI).\"\"\"\n    log_message(message, \"error\")\n\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\n\n    Sets component metadata, input names/descriptions/access, and\n    output names/descriptions. Output[0] is reserved for GH's internal\n    'out' -- outputs start from index 1.\n\n    IMPORTANT: Type Hints cannot be set programmatically in Rhino 8.\n    They must be configured via UI: Right-click input -> Type hint -> Select type.\n    \"\"\"\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs — fixed 6-input layout (matches FrameGen pattern)\n    inputs = ghenv.Component.Params.Input\n\n    input_config = [\n        (\"Walls JSON\", \"walls_json\",\n         \"JSON string from Wall Analyzer (must contain wall_assembly)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Junctions JSON\", \"junctions_json\",\n         \"Optional JSON from Junction Analyzer for per-layer adjustments\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Config JSON\", \"config_json\",\n         \"Configuration JSON from Config Builder (assembly_mode, framing_system, \"\n         \"faces, panel_size, include_functions, assembly_overrides, layer_configs)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Framing JSON\", \"framing_json\",\n         \"Optional JSON from Framing Generator — auto-detects framing profile depth \"\n         \"to prevent sheathing overlap with CFS or oversized framing\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Panels JSON\", \"panels_json\",\n         \"Optional JSON from Panel Decomposer for panel-bounded sheathing\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Run\", \"run\", \"Boolean to trigger execution\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    # Guard: only set properties that actually differ from current values.\n    # Setting Access unconditionally can trigger GH parameter reconstruction\n    # which silently disconnects wires (even if the value doesn't change).\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            p = inputs[i]\n            if p.Name != name:\n                p.Name = name\n            if p.NickName != nick:\n                p.NickName = nick\n            if p.Description != desc:\n                p.Description = desc\n            if p.Access != access:\n                p.Access = access\n\n    # Configure outputs (start from index 1)\n    outputs = ghenv.Component.Params.Output\n\n    output_config = [\n        (\"Multi-Layer JSON\", \"multi_layer_json\",\n         \"JSON with all layer results per wall\"),\n        (\"Layer Summary\", \"layer_summary\",\n         \"Per-layer material summary\"),\n        (\"Stats\", \"stats\",\n         \"Quick stats: total panels, layers, walls\"),\n        (\"Log\", \"log\",\n         \"Processing log\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef validate_inputs(walls_json, run):\n    \"\"\"Validate component inputs.\n\n    Args:\n        walls_json: JSON string with wall data.\n        run: Boolean run trigger.\n\n    Returns:\n        tuple: (is_valid, error_message)\n    \"\"\"\n    if not run:\n        return False, \"Run is False - component disabled\"\n\n    if walls_json is None or not walls_json.strip():\n        return False, \"walls_json is required\"\n\n    return True, None\n\n\ndef parse_config(config_json):\n    \"\"\"Parse configuration JSON with defaults.\n\n    Extracts control keys (assembly_mode, framing_system, assembly_overrides,\n    include_functions, layer_configs, framing_depth) and passes remaining\n    keys through as base config for all layers.\n\n    Args:\n        config_json: Optional JSON string with config overrides.\n\n    Returns:\n        tuple: (base_config, layer_configs, include_functions, framing_depth,\n                assembly_mode, framing_system, assembly_overrides)\n            - base_config: Dict of settings applied to all layers.\n            - layer_configs: Dict of per-layer overrides keyed by layer name.\n            - include_functions: List of layer functions to generate, or None.\n            - framing_depth: Explicit framing profile depth in feet, or None.\n            - assembly_mode: \"auto\" or \"revit\" (default \"auto\").\n            - framing_system: \"timber\" or \"cfs\" (default \"timber\").\n            - assembly_overrides: Dict of per-Wall-Type mappings, or None.\n    \"\"\"\n    base_config = dict(DEFAULT_CONFIG)\n    layer_configs = {}\n    include_functions = None\n    framing_depth = None\n    assembly_mode = \"auto\"\n    framing_system = \"timber\"\n    assembly_overrides = None\n\n    if config_json and config_json.strip():\n        try:\n            user_config = json.loads(config_json)\n            log_info(f\"Applied user config: {list(user_config.keys())}\")\n\n            # Extract top-level control keys (not passed to base_config)\n            if \"include_functions\" in user_config:\n                include_functions = user_config.pop(\"include_functions\")\n                log_info(f\"Filtering to functions: {include_functions}\")\n\n            if \"layer_configs\" in user_config:\n                layer_configs = user_config.pop(\"layer_configs\")\n                log_info(f\"Per-layer overrides for: {list(layer_configs.keys())}\")\n\n            if \"framing_depth\" in user_config:\n                framing_depth = float(user_config.pop(\"framing_depth\"))\n                log_info(f\"Explicit framing_depth: {framing_depth:.4f} ft\")\n\n            if \"assembly_mode\" in user_config:\n                assembly_mode = str(user_config.pop(\"assembly_mode\")).strip().lower()\n                log_info(f\"Assembly mode: {assembly_mode}\")\n\n            if \"framing_system\" in user_config:\n                framing_system = str(user_config.pop(\"framing_system\")).strip().lower()\n                log_info(f\"Framing system: {framing_system}\")\n\n            if \"assembly_overrides\" in user_config:\n                assembly_overrides = user_config.pop(\"assembly_overrides\")\n                if assembly_overrides and isinstance(assembly_overrides, dict):\n                    log_info(f\"Assembly overrides: {len(assembly_overrides)} Wall Type mappings\")\n                else:\n                    assembly_overrides = None\n\n            # Remove stud_spacing — not used by MLSheath (consumed by Framing Generator)\n            user_config.pop(\"stud_spacing\", None)\n\n            # Remaining keys become the base config\n            base_config.update(user_config)\n\n        except json.JSONDecodeError as e:\n            log_warning(f\"Invalid config_json, using defaults: {e}\")\n\n    return (base_config, layer_configs, include_functions, framing_depth,\n            assembly_mode, framing_system, assembly_overrides)\n\n\ndef compute_sheathing_bounds(wall_id, wall_length, face, junctions_data, layer_side=None):\n    \"\"\"Compute U-axis panel bounds from junction adjustments.\n\n    Looks up the junction adjustments for a specific wall and face,\n    and returns a list of (u_start, u_end) segments. For walls with no\n    midspan gaps, returns a single segment. For walls with midspan gaps\n    (T-intersections, X-crossings), returns multiple segments.\n\n    ASSUMPTION: Adjustment 'amount' is measured from the wall's Revit\n    centerline endpoint along the U-axis.\n    ASSUMPTION: u=0 is the wall's centerline start, u=wall_length is\n    the wall's centerline end.\n\n    Args:\n        wall_id: Wall identifier.\n        wall_length: Original wall length in feet.\n        face: Layer side — \"exterior\", \"interior\", or \"core\".\n            Must match the ``layer_name`` values emitted by the\n            junction resolver.\n        junctions_data: Parsed junctions_json dict, or None.\n        layer_side: Optional layer side (\"exterior\", \"interior\", \"core\")\n            for disambiguating same-named layers on different sides.\n            When provided, adjustments that carry a ``layer_side`` field\n            must match this value in addition to ``layer_name``.\n\n    Returns:\n        list: List of (u_start, u_end) segment tuples in feet.\n            Usually a single segment; multiple when midspan gaps exist.\n    \"\"\"\n    u_start_bound = 0.0\n    u_end_bound = wall_length\n    midspan_gaps = []  # List of (gap_center_u, amount_pos, amount_neg)\n\n    if not junctions_data:\n        return [(u_start_bound, u_end_bound)]\n\n    # Use face directly as layer_name — the junction resolver emits\n    # adjustments keyed by individual layer names OR aggregate face names.\n    layer_name = face\n\n    # Get adjustments for this wall\n    wall_adjustments = junctions_data.get(\"wall_adjustments\", {}).get(wall_id, [])\n\n    matched_any = False\n    for adj in wall_adjustments:\n        if adj.get(\"layer_name\") != layer_name:\n            continue\n        # When both the adjustment and the query carry a layer_side,\n        # require them to match.  This disambiguates same-named layers\n        # on different sides (e.g., \"Gypsum Board\" on ext vs int).\n        adj_side = adj.get(\"layer_side\")\n        if layer_side and adj_side and adj_side != layer_side:\n            continue\n\n        matched_any = True\n        end = adj.get(\"end\")\n        adj_type = adj.get(\"adjustment_type\")\n        amount = adj.get(\"amount\", 0.0)\n\n        if end == \"midspan\":\n            # Midspan gap: asymmetric amounts for +U and -U edges.\n            # amount = positive-U edge, amount_neg = negative-U edge (defaults to amount).\n            gap_u = adj.get(\"midspan_u\", 0.0)\n            amount_neg = adj.get(\"amount_neg\")\n            if amount_neg is None:\n                amount_neg = amount\n            midspan_gaps.append((gap_u, amount, amount_neg))\n            log_info(\n                f\"    BOUNDS-APPLY wall={wall_id} layer='{layer_name}' \"\n                f\"end=midspan {adj_type} amount_pos={amount:.6f} amount_neg={amount_neg:.6f} ft \"\n                f\"midspan_u={gap_u:.6f} -> gap at [{gap_u - amount_neg:.6f}, {gap_u + amount:.6f}]\"\n            )\n        elif end == \"start\":\n            if adj_type == \"extend\":\n                u_start_bound = -amount  # Extend before wall start\n            elif adj_type == \"trim\":\n                u_start_bound = amount   # Trim after wall start\n            log_info(\n                f\"    BOUNDS-APPLY wall={wall_id} layer='{layer_name}' \"\n                f\"end={end} {adj_type} amount={amount:.6f} ft ({amount*12:.4f} in) \"\n                f\"-> u_start={u_start_bound:.6f} u_end={u_end_bound:.6f} \"\n                f\"(wall_length={wall_length:.6f})\"\n            )\n        elif end == \"end\":\n            if adj_type == \"extend\":\n                u_end_bound = wall_length + amount  # Extend past wall end\n            elif adj_type == \"trim\":\n                u_end_bound = wall_length - amount  # Trim before wall end\n            log_info(\n                f\"    BOUNDS-APPLY wall={wall_id} layer='{layer_name}' \"\n                f\"end={end} {adj_type} amount={amount:.6f} ft ({amount*12:.4f} in) \"\n                f\"-> u_start={u_start_bound:.6f} u_end={u_end_bound:.6f} \"\n                f\"(wall_length={wall_length:.6f})\"\n            )\n\n    if not matched_any and wall_adjustments:\n        log_info(\n            f\"    BOUNDS-APPLY wall={wall_id} layer='{layer_name}': \"\n            f\"NO matching adjustment found among {len(wall_adjustments)} adjustments. \"\n            f\"Available layer_names: {sorted(set(a.get('layer_name') for a in wall_adjustments))}\"\n        )\n\n    # If no midspan gaps, return the single segment\n    if not midspan_gaps:\n        return [(u_start_bound, u_end_bound)]\n\n    # Split the single segment into sub-segments around midspan gaps.\n    # Sort gaps by U-coordinate.\n    midspan_gaps.sort(key=lambda g: g[0])\n\n    segments = []\n    current_start = u_start_bound\n    for gap_u, gap_amount_pos, gap_amount_neg in midspan_gaps:\n        gap_left = gap_u - gap_amount_neg\n        gap_right = gap_u + gap_amount_pos\n        # Add segment from current_start to gap_left (if positive length)\n        if gap_left > current_start + 0.001:\n            segments.append((current_start, gap_left))\n        current_start = gap_right\n\n    # Add final segment from last gap to u_end_bound\n    if u_end_bound > current_start + 0.001:\n        segments.append((current_start, u_end_bound))\n\n    log_info(\n        f\"    BOUNDS-SPLIT wall={wall_id} layer='{layer_name}': \"\n        f\"{len(midspan_gaps)} midspan gaps -> {len(segments)} segments\"\n    )\n    for i, (seg_s, seg_e) in enumerate(segments):\n        log_info(\n            f\"      segment[{i}]: u=[{seg_s:.6f}, {seg_e:.6f}] \"\n            f\"length={seg_e - seg_s:.6f} ft\"\n        )\n\n    return segments if segments else [(u_start_bound, u_end_bound)]\n\n\ndef parse_panels_json(panels_json_str):\n    \"\"\"Parse panels JSON into wall_id -> panel list mapping.\n\n    Args:\n        panels_json_str: JSON string from Panel Decomposer.\n\n    Returns:\n        dict: {wall_id: [panel_dict, ...]} sorted by u_start, or empty dict.\n    \"\"\"\n    if not panels_json_str or not str(panels_json_str).strip():\n        return {}\n\n    try:\n        data = json.loads(str(panels_json_str))\n    except (json.JSONDecodeError, TypeError):\n        log_warning(\"Invalid panels_json, ignoring\")\n        return {}\n\n    if not isinstance(data, list):\n        return {}\n\n    result = {}\n    for wall_result in data:\n        if not isinstance(wall_result, dict):\n            continue\n        wall_id = str(wall_result.get(\"wall_id\", \"\"))\n        panels = wall_result.get(\"panels\", [])\n        if wall_id and panels:\n            result[wall_id] = sorted(\n                panels, key=lambda p: p.get(\"u_start\", 0)\n            )\n\n    return result\n\n\ndef _clip_face_bounds(face_bounds, panel_u_start, panel_u_end):\n    \"\"\"Clip face_bounds segments to panel boundaries.\n\n    Args:\n        face_bounds: Dict mapping face/layer key -> list of (u_start, u_end) segments.\n        panel_u_start: Panel start U coordinate.\n        panel_u_end: Panel end U coordinate.\n\n    Returns:\n        Clipped face_bounds dict, or None if empty after clipping.\n    \"\"\"\n    if not face_bounds:\n        return None\n\n    clipped = {}\n    for key, segments in face_bounds.items():\n        clipped_segs = []\n        for seg_start, seg_end in segments:\n            clip_start = max(seg_start, panel_u_start)\n            clip_end = min(seg_end, panel_u_end)\n            if clip_end > clip_start + 0.001:\n                clipped_segs.append((clip_start, clip_end))\n        if clipped_segs:\n            clipped[key] = clipped_segs\n\n    return clipped if clipped else None\n\n\ndef generate_panelized_assembly_layers(\n    wall_data, wall_panels, base_config, layer_configs, include_functions,\n    face_bounds, framing_depth,\n):\n    \"\"\"Generate multi-layer sheathing bounded to framing panel boundaries.\n\n    For each framing panel, calls generate_assembly_layers() with the\n    panel's u_start/u_end as bounds and the panel_id set on wall_data.\n    Results are merged per-layer so the output structure matches the\n    non-panelized path (one layer_result per layer, not per panel).\n\n    Args:\n        wall_data: Wall data dict (with wall_assembly).\n        wall_panels: List of panel dicts sorted by u_start.\n        base_config: Base config for all layers.\n        layer_configs: Per-layer config overrides.\n        include_functions: Layer function filter, or None.\n        face_bounds: Dict of face/layer key -> segments from junction analysis.\n        framing_depth: Framing profile depth in feet, or None.\n\n    Returns:\n        dict: Same format as generate_assembly_layers() output.\n    \"\"\"\n    wall_id = wall_data.get(\"wall_id\", \"unknown\")\n    wall_length = wall_data.get(\"wall_length\", 0)\n    num_panels = len(wall_panels)\n\n    # Merged layer_results keyed by \"layer_name|layer_side\"\n    merged = {}\n    total_panels = 0\n\n    for panel_idx, panel in enumerate(wall_panels):\n        panel_id = panel.get(\"id\", \"%s_panel_%d\" % (wall_id, panel_idx))\n        panel_u_start = panel.get(\"u_start\", 0)\n        panel_u_end = panel.get(\"u_end\", wall_length)\n        log_info(\n            \"    Panel %d/%d: id=%s, u=[%.3f, %.3f], length=%.3f ft\"\n            % (panel_idx + 1, num_panels, panel_id,\n               panel_u_start, panel_u_end, panel_u_end - panel_u_start)\n        )\n\n        is_first = (panel_idx == 0)\n        is_last = (panel_idx == num_panels - 1)\n\n        # Start with panel boundaries\n        effective_u_start = panel_u_start\n        effective_u_end = panel_u_end\n\n        # Apply junction extensions only at wall edges\n        if is_first and face_bounds:\n            for segs in face_bounds.values():\n                for seg_start, _ in segs:\n                    if seg_start < effective_u_start:\n                        effective_u_start = seg_start\n\n        if is_last and face_bounds:\n            for segs in face_bounds.values():\n                for _, seg_end in segs:\n                    if seg_end > effective_u_end:\n                        effective_u_end = seg_end\n\n        # Clip face_bounds to this panel's range\n        panel_face_bounds = _clip_face_bounds(\n            face_bounds, effective_u_start, effective_u_end\n        )\n\n        # Set panel_id on wall_data copy\n        panel_wall_data = dict(wall_data)\n        panel_wall_data[\"panel_id\"] = panel_id\n\n        try:\n            result = generate_assembly_layers(\n                panel_wall_data,\n                config=base_config,\n                layer_configs=layer_configs if layer_configs else None,\n                u_start_bound=effective_u_start,\n                u_end_bound=effective_u_end,\n                face_bounds=panel_face_bounds,\n                include_functions=include_functions,\n                framing_depth=framing_depth,\n            )\n        except TypeError as _te:\n            if \"framing_depth\" in str(_te):\n                result = generate_assembly_layers(\n                    panel_wall_data,\n                    config=base_config,\n                    layer_configs=layer_configs if layer_configs else None,\n                    u_start_bound=effective_u_start,\n                    u_end_bound=effective_u_end,\n                    face_bounds=panel_face_bounds,\n                    include_functions=include_functions,\n                )\n            else:\n                raise\n\n        # Merge layer_results: concatenate panels per layer\n        for lr in result.get(\"layer_results\", []):\n            layer_key = \"%s|%s\" % (\n                lr.get(\"layer_name\", \"unknown\"),\n                lr.get(\"layer_side\", \"unknown\"),\n            )\n            if layer_key not in merged:\n                merged[layer_key] = dict(lr)\n                merged[layer_key][\"panels\"] = list(lr.get(\"panels\", []))\n                merged[layer_key][\"panel_count\"] = lr.get(\"panel_count\", 0)\n            else:\n                merged[layer_key][\"panels\"].extend(lr.get(\"panels\", []))\n                merged[layer_key][\"panel_count\"] += lr.get(\"panel_count\", 0)\n\n        total_panels += result.get(\"total_panel_count\", 0)\n\n    log_info(\n        \"  Wall %s: panelized -> %d framing panels -> %d sheathing panels\"\n        % (wall_id, num_panels, total_panels)\n    )\n\n    out = {\n        \"wall_id\": wall_id,\n        \"layer_results\": list(merged.values()),\n        \"total_panel_count\": total_panels,\n        \"layers_processed\": len(merged),\n    }\n\n    # Copy assembly metadata from wall_data\n    for key in (\"assembly_source\", \"assembly_confidence\", \"assembly_notes\",\n                \"assembly_name\", \"wall_type\"):\n        if key in wall_data:\n            out[key] = wall_data[key]\n\n    return out\n\n\ndef process_walls(walls_json, base_config, layer_configs, include_functions,\n                  junctions_data=None, assembly_mode=\"auto\",\n                  assembly_overrides=None, framing_system=\"timber\",\n                  framing_depth=None, framing_data=None,\n                  custom_map=None, panels_by_wall=None):\n    \"\"\"Process walls and generate multi-layer sheathing panels.\n\n    For each wall, resolves the assembly (using the assembly resolver),\n    determines faces from config, computes junction bounds per face,\n    and calls generate_assembly_layers() to produce panels for all\n    panelizable layers.\n\n    Args:\n        walls_json: JSON string with wall data.\n        base_config: Base configuration dict for all layers.\n        layer_configs: Per-layer config overrides keyed by layer name.\n        include_functions: List of layer functions to generate, or None for all.\n        junctions_data: Optional parsed junctions_json dict.\n        assembly_mode: Assembly resolution mode (auto/revit/revit_only/catalog/custom).\n        assembly_overrides: Per-Wall-Type assembly mapping dict, applied in ALL modes.\n        framing_system: \"timber\" or \"cfs\" — determines thickness-to-depth mapping.\n        framing_depth: Optional explicit framing profile depth in feet.\n            When set, overrides per-wall detection and applies to ALL walls.\n        framing_data: Optional parsed framing_json for per-wall depth\n            extraction. When provided and framing_depth is None, each wall\n            gets its own framing depth from the framing elements matching\n            its wall_id.\n        custom_map: Deprecated — use assembly_overrides. Kept for backward compat.\n\n    Returns:\n        tuple: (all_results, summary_lines, stats_text, log_lines)\n    \"\"\"\n    log_lines = []\n    all_results = []\n    summary_lines = []\n\n    try:\n        walls_data = json.loads(walls_json)\n    except json.JSONDecodeError as e:\n        log_error(f\"Failed to parse walls_json: {e}\")\n        return [], [], \"Error: Invalid JSON\", [f\"JSON parse error: {e}\"]\n\n    # Handle single wall or list of walls\n    if isinstance(walls_data, dict):\n        walls_list = [walls_data]\n    elif isinstance(walls_data, list):\n        walls_list = walls_data\n    else:\n        log_error(\"walls_json must be a dict or list\")\n        return [], [], \"Error: Invalid format\", [\"Invalid walls_json format\"]\n\n    # Inject framing_hint into wall dicts for assembly resolution (Option B).\n    # When framing_json is connected, each wall gets a hint with its stud\n    # profile depth, enabling the resolver to pick the correct assembly\n    # (e.g., 2x6_exterior for a 6\" wall instead of defaulting to 2x4).\n    if framing_data is not None:\n        for wall in walls_list:\n            wid = str(wall.get(\"wall_id\", \"\"))\n            depth = extract_max_framing_depth(framing_data, wall_id=wid)\n            if depth:\n                wall[\"framing_hint\"] = {\"depth_ft\": depth}\n                log_info(f\"  Injected framing_hint for wall {wid}: depth_ft={depth:.4f}\")\n\n    # Resolve assemblies for all walls\n    walls_list = resolve_all_walls(\n        walls_list, mode=assembly_mode,\n        assembly_overrides=assembly_overrides,\n        custom_map=custom_map,\n        framing_system=framing_system,\n    )\n    resolution_summary = summarize_resolutions(walls_list)\n\n    log_info(f\"Processing {len(walls_list)} walls for multi-layer sheathing\")\n    log_info(f\"Assembly mode: {assembly_mode}\")\n    log_lines.append(f\"Processing {len(walls_list)} walls\")\n    log_lines.append(f\"Assembly mode: {assembly_mode}\")\n    log_lines.append(\n        f\"Assembly quality: {resolution_summary['by_source']} \"\n        f\"(avg conf {resolution_summary['average_confidence']:.2f})\"\n    )\n    log_lines.append(f\"Base config: panel_size={base_config.get('panel_size', '4x8')}\")\n    if include_functions:\n        log_lines.append(f\"Layer filter: {include_functions}\")\n    if layer_configs:\n        log_lines.append(f\"Per-layer overrides: {list(layer_configs.keys())}\")\n\n    total_panels = 0\n    total_layers_processed = 0\n    walls_processed = 0\n    panelized_count = 0\n    standard_count = 0\n\n    summary_lines.append(\"=== Multi-Layer Sheathing ===\")\n    summary_lines.append(\n        f\"Assembly mode: {assembly_mode} | \"\n        f\"Quality: {resolution_summary['by_source']}\"\n    )\n\n    for i, wall_data in enumerate(walls_list):\n        wall_id = wall_data.get(\"wall_id\", f\"wall_{i}\")\n\n        # Check if assembly was resolved (skipped walls have no assembly)\n        wall_assembly = wall_data.get(\"wall_assembly\")\n        assembly_source = wall_data.get(\"assembly_source\", \"unknown\")\n        if not wall_assembly:\n            if assembly_source == \"skipped\":\n                log_info(f\"Wall {wall_id}: skipped ({wall_data.get('assembly_notes', '')})\")\n            else:\n                log_warning(f\"Wall {wall_id}: no assembly resolved - skipping\")\n            log_lines.append(f\"  Wall {wall_id}: SKIPPED ({assembly_source})\")\n            continue\n\n        log_info(\n            f\"Processing wall {wall_id} \"\n            f\"(assembly: {wall_data.get('assembly_name', '?')}, \"\n            f\"source: {assembly_source}, \"\n            f\"conf: {wall_data.get('assembly_confidence', 0):.2f})\"\n        )\n\n        try:\n            # Log wall geometry diagnostic for all walls\n            bp = wall_data.get(\"base_plane\", {})\n            zax = bp.get(\"z_axis\", {})\n            xax = bp.get(\"x_axis\", {})\n            log_info(\n                f\"  base_plane x_axis=({xax.get('x',0):.3f}, \"\n                f\"{xax.get('y',0):.3f}, {xax.get('z',0):.3f}), \"\n                f\"z_axis=({zax.get('x',0):.3f}, \"\n                f\"{zax.get('y',0):.3f}, {zax.get('z',0):.3f})\"\n            )\n            log_info(\n                f\"  wall_thickness={wall_data.get('wall_thickness', '?')}, \"\n                f\"is_flipped={wall_data.get('is_flipped', '?')}, \"\n                f\"wall_type='{wall_data.get('wall_type', '?')}'\"\n            )\n            log_info(\n                f\"  +z_axis = 'exterior' face, -z_axis = 'interior' face\"\n            )\n\n            # Face labels from config. z_axis is set by the Wall Analyzer\n            # using Revit's wall.Orientation, so +z = exterior regardless\n            # of the wall's is_flipped state.\n            faces = base_config.get(\"faces\", [\"exterior\", \"interior\"])\n\n            wall_length = wall_data.get(\"wall_length\", 0)\n\n            # Compute junction bounds per individual layer name.\n            # The junction resolver now emits per-layer adjustments keyed\n            # by the actual layer name (e.g., \"OSB Sheathing\") when wall\n            # assemblies are available, with fallback \"exterior\"/\"core\"/\n            # \"interior\" for walls without assemblies.  We compute bounds\n            # for every individual layer name AND the aggregate face keys\n            # so that generate_assembly_layers() can look up by either.\n            face_bounds = {}\n\n            # Diagnostic: show what adjustments exist for this wall\n            wall_adjs = (junctions_data or {}).get(\n                \"wall_adjustments\", {}\n            ).get(wall_id, [])\n            adj_layer_names = set()\n            if wall_adjs:\n                adj_layer_names = set(a.get(\"layer_name\") for a in wall_adjs)\n                log_info(\n                    f\"  BOUNDS-DIAG wall {wall_id}: {len(wall_adjs)} adjustments, \"\n                    f\"layer_names={sorted(adj_layer_names)}\"\n                )\n            else:\n                log_info(f\"  BOUNDS-DIAG wall {wall_id}: NO adjustments found\")\n\n            # Per-individual-layer bounds (from assembly).\n            # Only add when the junction resolver emitted adjustments keyed\n            # by that specific layer name (per-layer cumulative path).\n            # If only aggregate names (exterior/core/interior) exist, skip\n            # individual names so generate_assembly_layers() falls through\n            # to the aggregate face keys instead of getting shadowed.\n            assembly_layers = (wall_assembly or {}).get(\"layers\", [])\n            log_info(\n                f\"  BOUNDS-DIAG assembly layers: \"\n                f\"{[al.get('name') for al in assembly_layers]}\"\n            )\n            for al in assembly_layers:\n                lname = al.get(\"name\")\n                lside = al.get(\"side\", \"exterior\")\n                lkey = f\"{lname}|{lside}\"\n                if lname and lname in adj_layer_names:\n                    segments = compute_sheathing_bounds(\n                        wall_id, wall_length, lname, junctions_data,\n                        layer_side=lside,\n                    )\n                    face_bounds[lkey] = segments\n                    log_info(\n                        f\"  layer '{lname}' (side={lside}, key='{lkey}') bounds: \"\n                        f\"{len(segments)} segment(s) \"\n                        f\"(ADJUSTED, wall_length={wall_length:.4f})\"\n                    )\n                elif lname:\n                    log_info(\n                        f\"  layer '{lname}' (side={lside}): no matching adjustment \"\n                        f\"(will use face fallback)\"\n                    )\n\n            # Aggregate face-level bounds (fallback for layers not matched by name)\n            for bf in set(faces) | {\"core\"}:\n                segments = compute_sheathing_bounds(\n                    wall_id, wall_length, bf, junctions_data\n                )\n                face_bounds[bf] = segments\n                seg0 = segments[0] if segments else (0.0, wall_length)\n                matched = \"ADJUSTED\" if (len(segments) != 1 or abs(seg0[0]) > 0.0001 or abs(seg0[1] - wall_length) > 0.0001) else \"unchanged\"\n                log_info(\n                    f\"  face '{bf}' bounds: {len(segments)} segment(s) \"\n                    f\"({matched}, wall_length={wall_length:.4f})\"\n                )\n\n            log_info(f\"  BOUNDS-DIAG final face_bounds keys: {sorted(face_bounds.keys())}\")\n            log_info(f\"  BOUNDS-DIAG final face_bounds values:\")\n            for bk, bv in sorted(face_bounds.items()):\n                for si, (u_s, u_e) in enumerate(bv):\n                    changed_start = \"ADJUSTED\" if abs(u_s) > 0.0001 else \"default\"\n                    changed_end = \"ADJUSTED\" if abs(u_e - wall_length) > 0.0001 else \"default\"\n                    seg_label = f\"[{si}]\" if len(bv) > 1 else \"\"\n                    log_info(\n                        f\"    '{bk}'{seg_label}: u_start={u_s:.6f} ({changed_start}), \"\n                        f\"u_end={u_e:.6f} ({changed_end}), \"\n                        f\"effective_length={u_e - u_s:.6f} ft ({(u_e - u_s)*12:.4f} in)\"\n                    )\n\n            # Resolve per-wall framing depth.\n            # Explicit framing_depth (from config) overrides per-wall detection.\n            # Otherwise, extract from framing_json filtered by this wall's ID.\n            wall_framing_depth = framing_depth\n            if wall_framing_depth is None and framing_data is not None:\n                wall_framing_depth = extract_max_framing_depth(\n                    framing_data, wall_id=wall_id,\n                )\n                if wall_framing_depth is not None:\n                    log_info(\n                        f\"  framing_depth={wall_framing_depth:.4f} ft \"\n                        f\"({wall_framing_depth * 12:.2f} in) for wall {wall_id}\"\n                    )\n\n            # Check if this wall has framing panels for panel-bounded sheathing\n            wall_panels = panels_by_wall.get(str(wall_id)) if panels_by_wall else None\n\n            if wall_panels:\n                # Panel-aware path: generate sheathing bounded to each\n                # framing panel so sheets don't cross panel joints.\n                panelized_count += 1\n                log_info(\n                    f\"  Wall {wall_id}: PANELIZED path \"\n                    f\"({len(wall_panels)} framing panels)\"\n                )\n                result = generate_panelized_assembly_layers(\n                    wall_data, wall_panels, base_config, layer_configs,\n                    include_functions, face_bounds, wall_framing_depth,\n                )\n            else:\n                standard_count += 1\n                if panels_by_wall:\n                    log_info(\n                        \"  Wall %s: STANDARD path (no panel match; \"\n                        \"available panel wall_ids: %s)\"\n                        % (wall_id, sorted(panels_by_wall.keys()))\n                    )\n                else:\n                    log_info(\"  Wall %s: STANDARD path (no panels data)\" % wall_id)\n                # Standard path: generate sheathing for the full wall\n                try:\n                    result = generate_assembly_layers(\n                        wall_data,\n                        config=base_config,\n                        layer_configs=layer_configs if layer_configs else None,\n                        face_bounds=face_bounds if face_bounds else None,\n                        include_functions=include_functions,\n                        framing_depth=wall_framing_depth,\n                    )\n                except TypeError as _te:\n                    # Fallback: if an older version of multi_layer_generator is\n                    # loaded (missing framing_depth param), retry without it.\n                    if \"framing_depth\" in str(_te):\n                        log_warning(\n                            f\"Wall {wall_id}: stale module lacks framing_depth \"\n                            f\"param -- falling back (restart Rhino to fix)\"\n                        )\n                        result = generate_assembly_layers(\n                            wall_data,\n                            config=base_config,\n                            layer_configs=layer_configs if layer_configs else None,\n                            face_bounds=face_bounds if face_bounds else None,\n                            include_functions=include_functions,\n                        )\n                    else:\n                        raise\n\n            all_results.append(result)\n            walls_processed += 1\n\n            # W offset diagnostic: log per-layer W positions for first 2 walls\n            if walls_processed <= 2:\n                layer_results_diag = result.get(\"layer_results\", [])\n                core_t = sum(\n                    l.get(\"thickness\", 0)\n                    for l in wall_assembly.get(\"layers\", [])\n                    if l.get(\"side\") == \"core\"\n                )\n                log_info(\n                    f\"  W-DIAG wall {wall_id}: core_t={core_t:.4f}, \"\n                    f\"core_half={core_t/2:.4f}\"\n                )\n                for lr in layer_results_diag:\n                    w_off = lr.get(\"w_offset\")\n                    panels_list = lr.get(\"panels\", [])\n                    first_u = panels_list[0].get(\"u_start\", \"?\") if panels_list else \"N/A\"\n                    last_u = panels_list[-1].get(\"u_end\", \"?\") if panels_list else \"N/A\"\n                    log_info(\n                        f\"    {lr.get('layer_name')}: w_offset={w_off}, \"\n                        f\"side={lr.get('layer_side')}, \"\n                        f\"panels={lr.get('panel_count', 0)}, \"\n                        f\"first_u_start={first_u}, last_u_end={last_u}\"\n                    )\n\n            # Accumulate stats\n            wall_panel_count = result.get(\"total_panel_count\", 0)\n            wall_layers_count = result.get(\"layers_processed\", 0)\n            total_panels += wall_panel_count\n            total_layers_processed += wall_layers_count\n\n            # Build per-wall summary\n            layer_results = result.get(\"layer_results\", [])\n            if layer_results:\n                summary_lines.append(f\"Wall {wall_id}:\")\n                for lr in layer_results:\n                    layer_name = lr.get(\"layer_name\", \"unknown\")\n                    layer_func = lr.get(\"layer_function\", \"\")\n                    layer_side = lr.get(\"layer_side\", \"\")\n                    panel_count = lr.get(\"panel_count\", 0)\n                    w_off = lr.get(\"w_offset\")\n                    w_str = f\"w={w_off:.4f}\" if w_off is not None else \"w=None\"\n                    summary_lines.append(\n                        f\"  {layer_name} ({layer_func}/{layer_side}): \"\n                        f\"{panel_count} panels, {w_str}\"\n                    )\n                log_lines.append(\n                    f\"  Wall {wall_id}: {wall_panel_count} panels \"\n                    f\"across {wall_layers_count} layers\"\n                )\n            else:\n                summary_lines.append(\n                    f\"Wall {wall_id}: no panelizable layers found\"\n                )\n                log_lines.append(\n                    f\"  Wall {wall_id}: 0 panels (no panelizable layers)\"\n                )\n\n        except Exception as e:\n            log_warning(f\"Error processing wall {wall_id}: {e}\")\n            log_lines.append(f\"  Wall {wall_id}: ERROR - {e}\")\n            continue\n\n    # Build stats text\n    unique_layers = set()\n    for result in all_results:\n        for lr in result.get(\"layer_results\", []):\n            unique_layers.add(lr.get(\"layer_name\", \"unknown\"))\n\n    stats_text = (\n        f\"Total Panels: {total_panels}\\n\"\n        f\"Layers Processed: {total_layers_processed} \"\n        f\"({len(unique_layers)} unique)\\n\"\n        f\"Walls Processed: {walls_processed}/{len(walls_list)}\\n\"\n        f\"Panelization: {panelized_count}/{walls_processed} walls panel-bounded, \"\n        f\"{standard_count} standard\"\n    )\n\n    # Append total to summary\n    summary_lines.append(\n        f\"Total: {total_panels} panels across \"\n        f\"{len(unique_layers)} layers, {walls_processed} walls\"\n    )\n\n    log_info(\n        f\"Total: {total_panels} panels, {total_layers_processed} layers, \"\n        f\"{walls_processed} walls\"\n    )\n\n    return all_results, summary_lines, stats_text, log_lines\n\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main(walls_json_in, junctions_json_in, config_json_in, run_in,\n         framing_json_in=None, panels_json_in=None):\n    \"\"\"Main entry point for the component.\n\n    Orchestrates the multi-layer sheathing generation workflow:\n    1. Sets up component metadata\n    2. Validates inputs\n    3. Parses configuration (assembly_mode, framing_system, assembly_overrides,\n       base config, layer overrides, function filter)\n    4. Parses optional junction data\n    5. Auto-detects framing depth from framing_json (if connected)\n    6. Parses optional panels_json for panel-bounded sheathing\n    7. Resolves assemblies for all walls\n    8. Processes all walls\n    9. Returns JSON results, summary, stats, and log\n\n    Args:\n        walls_json_in: JSON string from Wall Analyzer.\n        junctions_json_in: Optional JSON from Junction Analyzer.\n        config_json_in: Configuration JSON from Config Builder (or manual).\n            Contains assembly_mode, framing_system, assembly_overrides,\n            faces, panel_size, include_functions, layer_configs, etc.\n        run_in: Boolean to trigger execution.\n        framing_json_in: Optional JSON from Framing Generator. When\n            connected, the maximum profile depth is extracted and used\n            as framing_depth to prevent sheathing from overlapping\n            oversized framing (e.g., CFS profiles on a timber wall type).\n        panels_json_in: Optional JSON from Panel Decomposer. When\n            connected, sheathing is generated per framing panel so\n            sheets don't cross panel joints.\n\n    Returns:\n        tuple: (multi_layer_json, layer_summary, stats, log)\n    \"\"\"\n    # Set component metadata and NickNames (for display, after inputs are read)\n    setup_component()\n\n    try:\n        # Use inputs passed as arguments\n        walls_json_input = walls_json_in\n        junctions_json_input = junctions_json_in\n        config_json_input = config_json_in\n        run_input = run_in\n\n        # Validate inputs\n        is_valid, error_msg = validate_inputs(walls_json_input, run_input)\n        if not is_valid:\n            log_info(error_msg)\n            return \"\", error_msg, \"\", error_msg\n\n        # Parse configuration (now includes assembly_mode, framing_system, overrides)\n        (base_config, layer_configs, include_functions, framing_depth,\n         assembly_mode, framing_system, assembly_overrides) = parse_config(\n            config_json_input\n        )\n\n        # Parse framing_json for per-wall framing depth extraction.\n        # When an explicit framing_depth is set via config_json, it overrides\n        # per-wall detection and applies to ALL walls uniformly.\n        framing_data = None\n        if framing_json_in and str(framing_json_in).strip():\n            try:\n                framing_data = json.loads(framing_json_in)\n                if framing_depth is not None:\n                    log_info(\n                        f\"Explicit framing_depth={framing_depth:.4f} ft from config \"\n                        f\"(overrides per-wall detection from framing_json)\"\n                    )\n                else:\n                    # Quick log: show global max for reference\n                    global_max = extract_max_framing_depth(framing_data)\n                    log_info(\n                        f\"framing_json loaded — per-wall depth extraction active \"\n                        f\"(global max={global_max:.4f} ft / {global_max * 12:.2f} in)\"\n                        if global_max else \"framing_json loaded (no elements found)\"\n                    )\n            except (json.JSONDecodeError, TypeError) as e:\n                log_warning(f\"Invalid framing_json, ignoring: {e}\")\n\n        # Parse junctions data (optional)\n        junctions_data = None\n        if junctions_json_input and str(junctions_json_input).strip():\n            try:\n                junctions_data = json.loads(junctions_json_input)\n                junc_count = junctions_data.get(\"junction_count\", 0)\n                wall_adj_map = junctions_data.get(\"wall_adjustments\", {})\n                adj_count = sum(len(adjs) for adjs in wall_adj_map.values())\n                log_info(\n                    f\"Loaded junction data (Phase 1): {junc_count} junctions, \"\n                    f\"{adj_count} best-effort adjustments across {len(wall_adj_map)} walls\"\n                )\n            except (json.JSONDecodeError, TypeError) as e:\n                log_warning(f\"Invalid junctions_json, ignoring: {e}\")\n\n        # Phase 2: Recompute junction adjustments with resolved assemblies.\n        # The Junction Analyzer runs on raw Revit walls (Phase 1) and may\n        # only have single-core-layer data. After assembly resolution,\n        # we recompute adjustments with the real multi-layer assemblies.\n        phase2_log = []  # Captured for visible log output\n        if junctions_data and junctions_data.get(\"resolutions\"):\n            try:\n                # Parse walls for assembly resolution\n                walls_for_recompute = json.loads(walls_json_input)\n                if isinstance(walls_for_recompute, dict):\n                    walls_for_recompute = [walls_for_recompute]\n\n                # z_axis already set by Wall Analyzer (wall.Orientation),\n                # no flip correction needed for Phase 2 recompute.\n\n                # Inject framing_hint for correct assembly resolution\n                if framing_data is not None:\n                    for wall in walls_for_recompute:\n                        wid = str(wall.get(\"wall_id\", \"\"))\n                        depth = extract_max_framing_depth(framing_data, wall_id=wid)\n                        if depth:\n                            wall[\"framing_hint\"] = {\"depth_ft\": depth}\n\n                # Resolve assemblies on a copy for recompute\n                walls_for_recompute = resolve_all_walls(\n                    walls_for_recompute, mode=assembly_mode,\n                    assembly_overrides=assembly_overrides,\n                    framing_system=framing_system,\n                )\n\n                recomputed = recompute_adjustments(junctions_data, walls_for_recompute)\n\n                old_count = sum(\n                    len(v) for v in junctions_data.get(\"wall_adjustments\", {}).values()\n                )\n                new_count = sum(len(v) for v in recomputed.values())\n                junctions_data[\"wall_adjustments\"] = recomputed\n\n                phase2_msg = (\n                    f\"Phase 2 recompute: {old_count} -> {new_count} adjustments\"\n                )\n                log_info(phase2_msg)\n                phase2_log.append(f\"=== PHASE 2 RECOMPUTE (resolver v2.3-crossed-pattern) ===\")\n                phase2_log.append(phase2_msg)\n\n                # Diagnostic: dump recomputed adjustments (console + log)\n                for wid, adjs in recomputed.items():\n                    log_info(f\"  RECOMPUTED wall {wid}: {len(adjs)} adjustments\")\n                    phase2_log.append(f\"  Wall {wid}: {len(adjs)} adjustments\")\n                    for adj in adjs:\n                        adj_line = (\n                            f\"    {adj.get('layer_name')} \"\n                            f\"[{adj.get('end')}] \"\n                            f\"{adj.get('adjustment_type').upper()} \"\n                            f\"{adj.get('amount', 0):.6f} ft \"\n                            f\"({adj.get('amount', 0) * 12:.4f} in) \"\n                            f\"vs {adj.get('connecting_wall_id')}\"\n                        )\n                        log_info(adj_line)\n                        phase2_log.append(adj_line)\n            except Exception as e:\n                log_warning(\n                    f\"Phase 2 recompute failed, using Phase 1 adjustments: {e}\"\n                )\n                phase2_log.append(f\"Phase 2 FAILED: {e}\")\n                import traceback as _tb\n                print(_tb.format_exc())\n        elif junctions_data:\n            phase2_log.append(\n                \"No resolutions in junctions_json (old format?) — \"\n                \"using Phase 1 adjustments as-is\"\n            )\n            log_info(phase2_log[-1])\n\n        # Parse panels_json for panel-bounded sheathing (optional)\n        panels_by_wall = parse_panels_json(panels_json_in)\n        if panels_by_wall:\n            total_fpanels = sum(len(v) for v in panels_by_wall.values())\n            log_info(\n                f\"Panel-bounded mode: {total_fpanels} framing panels \"\n                f\"across {len(panels_by_wall)} walls\"\n            )\n            # Check wall_id match between panels_json and walls_json\n            try:\n                _walls_tmp = json.loads(walls_json_input)\n                if isinstance(_walls_tmp, dict):\n                    _walls_tmp = [_walls_tmp]\n                _wall_ids = set(str(w.get(\"wall_id\", \"\")) for w in _walls_tmp)\n                _panel_ids = set(panels_by_wall.keys())\n                _matched = _wall_ids & _panel_ids\n                log_info(\"  Panel wall_ids: %s\" % sorted(_panel_ids))\n                log_info(\"  Walls wall_ids: %s\" % sorted(_wall_ids))\n                log_info(\"  Matched: %d/%d walls\" % (len(_matched), len(_wall_ids)))\n                _unmatched = _panel_ids - _wall_ids\n                if _unmatched:\n                    log_warning(\n                        \"  panels_json has %d wall_ids not in walls_json: %s\"\n                        % (len(_unmatched), sorted(_unmatched)))\n            except Exception:\n                pass\n        elif panels_json_in and str(panels_json_in).strip():\n            log_info(\n                \"panels_json was provided but parse_panels_json returned empty \"\n                \"- check JSON format (expected list of {wall_id, panels: [...]})\")\n        else:\n            log_info(\"No panels_json provided - standard full-wall mode\")\n\n        # Process walls\n        results, summary_lines, stats_text, log_lines = process_walls(\n            walls_json_input, base_config, layer_configs, include_functions,\n            junctions_data, assembly_mode=assembly_mode,\n            assembly_overrides=assembly_overrides,\n            framing_system=framing_system,\n            framing_depth=framing_depth, framing_data=framing_data,\n            panels_by_wall=panels_by_wall if panels_by_wall else None,\n        )\n\n        # Prepend Phase 2 recompute log to visible output\n        if phase2_log:\n            log_lines = phase2_log + [\"\"] + log_lines\n\n        # Serialize results to JSON\n        multi_layer_json_output = json.dumps(results, indent=2)\n        layer_summary_output = \"\\n\".join(summary_lines)\n        log_output = \"\\n\".join(log_lines)\n\n        return multi_layer_json_output, layer_summary_output, stats_text, log_output\n\n    except Exception as e:\n        error_msg = f\"Unexpected error: {str(e)}\"\n        log_error(error_msg)\n        print(traceback.format_exc())\n        return \"\", error_msg, \"\", traceback.format_exc()\n\n\n# =============================================================================\n# Execution\n# =============================================================================\n\n# Read inputs by parameter index via VolatileData.AllData(True).\n# NickName-based global injection is unreliable in Rhino 8 CPython --\n# setup_component() renames NickNames but GH injects globals based on the\n# NickName at solve-start, causing mismatches. AllData(True) always works.\n\ndef _read_input(index, default=None):\n    \"\"\"Read a GH input value by parameter index via VolatileData.\"\"\"\n    inputs = ghenv.Component.Params.Input\n    if index >= inputs.Count:\n        return default\n    param = inputs[index]\n    if param.VolatileDataCount == 0:\n        return default\n    all_data = list(param.VolatileData.AllData(True))\n    if not all_data:\n        return default\n    goo = all_data[0]\n    if hasattr(goo, \"Value\"):\n        return goo.Value\n    if hasattr(goo, \"ScriptVariable\"):\n        return goo.ScriptVariable()\n    return default\n\n_input_count = ghenv.Component.Params.Input.Count\nif _input_count < 6:\n    _msg = (\n        \"ERROR: Component has %d inputs but needs 6. \"\n        \"Right-click component zoomable UI (ZUI) -> add inputs until \"\n        \"you have 6, then reconnect: walls_json (0), junctions_json (1), \"\n        \"config_json (2), framing_json (3), panels_json (4), run (5)\"\n        % _input_count\n    )\n    print(_msg)\n    multi_layer_json = \"\"\n    layer_summary = _msg\n    stats = \"\"\n    log = _msg\nelse:\n    # Fixed 6-input layout (matches FrameGen pattern)\n    _walls_json = _read_input(0)       # walls_json\n    _junctions_json = _read_input(1)   # junctions_json\n    _config_json = _read_input(2)      # config_json\n    _framing_json = _read_input(3)     # framing_json (optional)\n    _panels_json = _read_input(4)      # panels_json (optional)\n    _run = bool(_read_input(5, False)) # run\n\n    # Panelization diagnostics\n    print(\"[MLSheath] PANELIZATION DIAGNOSTICS:\")\n    print(\"  Input count: %d\" % _input_count)\n    print(\"  panels_json received: %s\" % (\"YES (%d chars)\" % len(str(_panels_json)) if _panels_json else \"NO\"))\n\n    multi_layer_json, layer_summary, stats, log = main(\n        _walls_json, _junctions_json, _config_json, _run,\n        _framing_json, _panels_json,\n    )\n",
  "language": "python",
  "imports": [
    "RhinoCommon"
  ],
  "has_docstring": true
}