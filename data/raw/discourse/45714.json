{
  "source_url": "https://discourse.mcneel.com/t/super-super-fast-point-inclusion-test-for-cylinder-breps/45714",
  "topic_id": 45714,
  "title": "Super-super fast Point Inclusion test for Cylinder/Breps?",
  "question": "The inbuilt PointInBrep is way too slow. So I will make my own.\n\n\nUsing \nVB.NET\n I’ve been struggling for a day to try to make the PointInclusion filter foc cylinders as fast as possible, but it seems it gets only slower the more I try to optimize (indicating my excellent .NET skills). Currently it takes about 20-30 seconds to filter 50’ points (something is seriously worng), and it should be possible to come down to say 500-300ms I’m sure (planar box test is less than 8 ms for 50.000 pts).\n\n\n\n\n\n\nEdit\n: Hm, removing pre-allocation of list.Capacity brought it down to 5-9 sek (pre-allocating list Capacity is an old Delphi-trick that obviously doesn’t work well in .NET…). But there’s still a bit of work to get down under 300 ms…\n\n\nEdit 2\n:  It also seems like the Solver keeps a cache of output values, because the output pointlist almost doubles its item count for each time the solver is run. Hm.\n\n\nAnyway, the following is the current scenario :\n\n\n\n\nThe filter typically processes some 50.000 mesh points.\n\n\nPoints inside the Brep Cylinder are listed in one list\n\n\nPoints outside the Brep Cylinder are listed in another list\n\n\nCylinder Brep can change Height between runs\n\n\nCylinder Brep can change Radius between runs\n\n\nCylinder Brep can change Inclination between runs\n\n\nCylinder Brep can change 3D Position between runs\n\n\n\n\nFig.1. This is an example result with a leaning cylinder.\n\n\n\n\nimage.png\n931×672 123 KB\n\n\n\n\nI’ve tried to transform the Cylinder and the POint Cloud to horizontal (which then can determine inclusion very super fast, testing points only for radius-distance and height) but the Transform took forever. Must have done something wrong.\n\n\nExample code which is so slow (I commented away the BoundingBox test because it didn’t run any faster . I also try to re-use lines etc, by only changing the start- and end-points instead of creating new instances. All those tricks, but still soo sloow :\n\n\n            For Each mesh_pt As Point3d In MeshPoints\n\n                '//...",
  "code_blocks": [
    {
      "code": "Imports System.Collections.Generic\n\nImports Grasshopper.Kernel\nImports Rhino.Geometry\nImports Rhino\n\nNamespace RIL.GH.Filters\n\n    Public Class RILGH_CylPtInclusionSolver_TMP\n        Inherits GH_Component\n\n        Private m_DA As IGH_DataAccess\n\n        ''' <summary>\n        ''' Initializes a new instance of the MyComponent1 class.\n        ''' </summary>\n        Public Sub New()\n            MyBase.New(\"Cylinder Point Inclusion Solver\", \"PtsInCylSolver\",\n                    \"Tilt or Resize while filtering points inside the bounds of a cylinder.\",\n                    \"RIL\", \"Filters\")\n        End Sub\n\n        ''' <summary>\n        ''' Registers all the input parameters for this component.\n        ''' </summary>\n        Protected Overrides Sub RegisterInputParams(pManager As GH_Component.GH_InputParamManager)\n            '// Make default XY plane\n            Dim XYPLane As Vector3d = New Point3d(0, 0, 10) - New Point3d(0, 0, 0)\n            '// Register In-ports\n            pManager.AddPointParameter(\"Rotation center\", \"C\", \"Rotation center.\", GH_ParamAccess.item, New Point3d(0, 0, 0))\n            pManager.AddPointParameter(\"Cylinder Height & Tilt\", \"H\", \"A 3D height-center Point determining the Height and the Inclination of the Cylinder.\", GH_ParamAccess.item, New Point3d(0, 0, 10))\n            pManager.AddNumberParameter(\"Radius\", \"R\", \"Radius of the inclusion Cylinder.\", GH_ParamAccess.item, 10)\n            pManager.AddPointParameter(\"Point Cloud\", \"Pts\", \"Points to test for inclusion.\", GH_ParamAccess.list)\n            pManager.AddNumberParameter(\"Tolerance\", \"T\", \"Tolerance for inclusion test.\", GH_ParamAccess.item, 0.01)\n            pManager.AddBooleanParameter(\"ON/OFF\", \"ON\", \"Activate execution by setting value to True.\", GH_ParamAccess.item, False)\n            pManager.AddGeometryParameter(\"CoGeo\", \"CoGeo\", \"Additional Geometry to be equally Transformed.\", GH_ParamAccess.list)\n        End Sub\n\n        ''' <summary>\n        ''' Registers all the output parameters for this component.\n        ''' </summary>\n        Protected Overrides Sub RegisterOutputParams(pManager As GH_Component.GH_OutputParamManager)\n            pManager.AddPointParameter(\"Points Inside Box\", \"BIn\", \"Points residing inside the Bounding Box.\", GH_ParamAccess.list)\n            pManager.AddPointParameter(\"Points Outside Box\", \"BOut\", \"Points residing outside the Bounding Box.\", GH_ParamAccess.list)\n            pManager.AddPointParameter(\"Cylinder Center\", \"CC\", \"Point in the center of the Cylinder Bounding Box.\", GH_ParamAccess.item)\n            pManager.AddTextParameter(\"Score\", \"Score\", \"Score after several attempts.\", GH_ParamAccess.item)\n            pManager.AddBrepParameter(\"Brep\", \"Brep\", \"Brep for debugging.\", GH_ParamAccess.item)\n            pManager.AddGeometryParameter(\"TxGeo\", \"TxGeo\", \"Co-Transformed geometries.\", GH_ParamAccess.list)\n        End Sub\n\n\n        Private Const IN_C = 0\n        Private Const IN_H = 1\n        Private Const IN_R = 2\n        Private Const IN_Pts = 3\n        Private Const IN_Tol = 4\n        Private Const IN_On = 5\n        Private Const IN_CoGeo = 6\n\n        Private Const OUT_BIn = 0\n        Private Const OUT_BOut = 1\n        Private Const OUT_CC = 2\n        Private Const OUT_Score = 3\n        Private Const OUT_Brep = 4\n        Private Const OUT_TxGeo = 5\n\n\n        ''' <summary>\n        ''' Provides the Inport value of C - Rotation center\n        ''' </summary>\n        Private Function GetInputC() As Point3d\n            Dim m_C As New Point3d\n            If Not m_DA.GetData(IN_C, m_C) Then\n                Print(\"# Error - Invalid Point input.\")\n            End If\n            Return m_C\n        End Function\n\n\n        ''' <summary>\n        ''' Provides the Inport value of C - Rotation center\n        ''' </summary>\n        Private m_H As New Point3d\n        Protected Property InH() As Point3d\n            Get\n                If Not m_DA.GetData(IN_H, m_H) Then\n                    Print(\"# Error - Invalid Point input.\")\n                End If\n                Return m_H\n            End Get\n            Set(ByVal value As Point3d)\n                m_H = value\n            End Set\n        End Property\n\n\n        ''' <summary>\n        ''' Provides the Inport value of R - Radius\n        ''' </summary>\n        Private m_R As Double\n        Protected ReadOnly Property InR() As Double\n            Get\n                If Not m_DA.GetData(IN_R, m_R) Then\n                    Print(\"# Error - Invalid Radius value.\")\n                End If\n                Return m_R\n            End Get\n        End Property\n\n\n        Dim m_Pts As New List(Of Point3d)\n        Protected ReadOnly Property InPts() As List(Of Point3d)\n            Get\n                If Not m_DA.GetDataList(IN_Pts, m_Pts) Then\n                    Print(\"# Error - Invalid Point cloud input.\")\n                End If\n                Return m_Pts\n            End Get\n        End Property\n\n\n        ''' <summary>\n        ''' Provides the Inport value of T - Tolerance\n        ''' </summary>\n        Private m_T As Single\n        Protected ReadOnly Property InT() As Single\n            Get\n                If Not m_DA.GetData(IN_Tol, m_T) Then\n                    Print(\"# Error - Invalid Tolerance value.\")\n                End If\n                Return m_T\n            End Get\n        End Property\n\n\n\n        ''' <summary>\n        ''' Disable or Enable Solver Execution\n        ''' </summary>\n        Dim m_On As Boolean\n        Protected ReadOnly Property InOn() As Boolean\n            Get\n                If Not m_DA.GetData(IN_On, m_On) Then\n                    Print(\"# Error - Invalid Point cloud input.\")\n                End If\n                Return m_On\n            End Get\n        End Property\n\n\n\n        ''' <summary>\n        ''' Provides the Inport value of CoBreps - A bunch of related breps meant to be equally Transformed\n        ''' </summary>\n        Private m_CoGeo As New List(Of GeometryBase)\n        Protected ReadOnly Property InCoGeo() As List(Of GeometryBase)\n            Get\n                If Not m_DA.GetDataList(IN_CoGeo, m_CoGeo) Then\n                    Print(\"# Error - Invalid breps input.\")\n                    Return Nothing\n                End If\n                Return m_CoGeo\n            End Get\n        End Property\n\n\n        ''' <summary>\n        ''' Derives an inclination vector (as well as height-) axis based on Center point (C) and Height point (H)\n        ''' </summary>\n        Private Function ZAxis(ByRef aCenterPt As Point3d, ByRef aHeightPt As Point3d) As Vector3d\n            Dim v As Vector3d = aHeightPt - aCenterPt\n            Return v\n        End Function\n\n\n        ''' <summary>\n        ''' Creates a Cylinder at last specified position InC and inclination Plane ( = ZAxis(InH-InC))\n        ''' </summary>\n        Private Function AsCylinder(ByRef aCenterPt As Point3d, ByRef aHeightPt As Point3d) As Cylinder\n            Dim zaxis_tmp As Vector3d = ZAxis(aCenterPt, aHeightPt)\n            Dim plane As New Plane(aCenterPt, zaxis_tmp)\n            Dim circle As New Circle(plane, InR)\n            Return New Cylinder(circle, zaxis_tmp.Length)\n        End Function\n\n        Private Function BrepCylinder(ByRef aCenterPt As Point3d, ByRef aHeightPt As Point3d) As Brep\n            Return AsCylinder(aCenterPt, aHeightPt).ToBrep(True, True)\n        End Function\n\n\n\n        ''' <summary>\n        ''' This is the method that actually does the work.\n        ''' </summary>\n        ''' <param name=\"DA\">The DA object is used to retrieve from inputs and store in outputs.</param>\n        Protected Overrides Sub SolveInstance(DA As IGH_DataAccess)\n            '//\n            '// Set class wide access to Data Accessor\n            '//\n\n            m_DA = DA\n            If Not InOn Then Return\n\n            '//\n            '// ANIMATE CYLINDER BREP\n            '//\n\n            Dim tolerance As Single = InT\n            Dim cp As New Point3d(GetInputC)\n            Dim hp As New Point3d(InH)\n            Dim insidePts As New List(Of Point3d)\n            Dim outsidePts As New List(Of Point3d)\n\n            '//\n            '// AUTO-FIT\n            '// \n\n            Dim cylC As New Point3d\n            Dim cyl_brep As Brep\n            Dim score(0 To 2) As Integer\n            Dim score_ix As Integer = 0\n\n            '// -1 to 1. But for now, run only one laps.\n            For i As Integer = -1 To -1\n                '/\n                '/ Clear lists if running multiple rounds\n                '/\n\n                insidePts.Clear()\n                outsidePts.Clear()\n\n                '/\n                '/ Attempt to Translate (Move) Cylinder\n                '/\n\n                cp.X += i\n                hp.X += i\n                cyl_brep = BrepCylinder(cp, hp)\n\n                '//\n                '// FILTER CYLINDER\n                '//\n\n                Dim BBox As New BoundingBox(cyl_brep.GetBoundingBox(True).GetCorners())\n                cylC = BBox.Center\n\n                DA.SetData(OUT_CC, cylC)\n\n                Dim cyl_tmp As Cylinder = AsCylinder(cp, hp)\n                'Dim line_tmp As New Line(cylC, hp)\n                'Dim isectPt1 As Point3d\n                'Dim isectPt2 As Point3d\n\n\n                Dim crv As New LineCurve(cp, hp)\n                Dim inside_cnt As Integer = 0\n                For Each mesh_pt As Point3d In InPts\n\n                    '//\n                    '// BOX INCLUSION (Raw test)\n                    '// \n\n                    If (mesh_pt.Z < BBox.Max.Z) And\n                       (mesh_pt.Z > BBox.Min.Z) And\n                       (mesh_pt.X > BBox.Min.X) And\n                       (mesh_pt.X < BBox.Max.X) And\n                       (mesh_pt.Y > BBox.Min.Y) And\n                       (mesh_pt.Y < BBox.Max.Y) Then\n\n                        ''// \n                        ''// CYLINDER INCLUSION\n                        ''// \n\n                        'line_tmp.To = mesh_pt\n\n                        crv.SetStartPoint(cylC)\n                        crv.SetEndPoint(mesh_pt)\n                        Dim overlapCurves As Curve()\n                        Dim intersectPoints As Point3d()\n\n\n                        If Intersect.Intersection.CurveBrep(crv, cyl_brep, tolerance, overlapCurves, intersectPoints) And (intersectPoints.GetUpperBound(0) < 0) Then\n                            'If Intersect.Intersection.LineCylinder(line_tmp, cyl_tmp, isectPt1, isectPt2).Multiple Then\n                            insidePts.Add(mesh_pt)\n                            inside_cnt += 1\n                        Else\n                            outsidePts.Add(mesh_pt)\n                        End If\n                        outsidePts.Add(mesh_pt)\n                    End If\n                Next\n                score(score_ix) = inside_cnt\n\n                'Threading.Thread.Sleep(200)\n                'Threading.Thread.Wait(200)\n            Next\n\n            '//\n            '// OUT-PORTS\n            '// \n\n            DA.SetDataList(OUT_BIn, insidePts)\n            DA.SetDataList(OUT_BOut, outsidePts)\n            DA.SetData(OUT_CC, cylC)\n            DA.SetData(OUT_Score, score(2).ToString())\n            DA.SetData(OUT_Brep, cyl_brep)\n            DA.SetDataList(OUT_TxGeo, Nothing)\n        End Sub\n\n\n        ''' <summary>\n        ''' Icons need to be 24x24 pixels.\n        ''' </summary>\n        Protected Overrides ReadOnly Property Icon() As System.Drawing.Bitmap\n            Get\n                Return My.Resources.Resource_Icon.ICO_Experimental\n            End Get\n        End Property\n\n        ''' <summary>\n        ''' Gets the unique ID for this component. Do not change this ID after release.\n        ''' </summary>\n        Public Overrides ReadOnly Property ComponentGuid() As Guid\n            Get\n                Return New Guid(\"EDACD053-B7CE-4A9D-B7E3-099067F03AAD\")\n\n            End Get\n        End Property\n    End Class\n\nEnd Namespace",
      "language": "csharp",
      "author": "RIL",
      "post_number": 7,
      "is_solution": false
    },
    {
      "code": "import Rhino\nimport scriptcontext\nimport System\n\ndef main():\n  gob = Rhino.Input.Custom.GetObject()\n  gob.AcceptNothing( True )\n  gob.SetCommandPrompt( 'Points (by Point3d) ?' )\n  gob.GetMultiple( 0, 0 )\n  res = gob.Result()\n  if res == Rhino.Input.GetResult.Object:\n    obrefs = gob.Objects()\n    pts = [ obref.Point().Location for obref in obrefs ]\n    pl0 = Rhino.Geometry.Plane(\n        Rhino.Geometry.Point3d( 23, 56, 77 ),\n        Rhino.Geometry.Point3d( 102, 44,  21 ),\n        Rhino.Geometry.Point3d( 7, 221, 66 ) )\n    pl1 = Rhino.Geometry.Plane(\n        Rhino.Geometry.Point3d( 10, 99, 22 ),\n        Rhino.Geometry.Point3d( 2, 101,33 ),\n        Rhino.Geometry.Point3d( 220, 12, 88 ) )\n    xf = Rhino.Geometry.Transform.PlaneToPlane( pl0, pl1 )\n    sw = System.Diagnostics.Stopwatch.StartNew()\n    for pt in pts:\n      pt.Transform( xf )\n    msec = sw.ElapsedMilliseconds\n    print( '%.0f ms' % msec )\n    for pt in pts:\n      scriptcontext.doc.Objects.AddPoint( pt )\n    scriptcontext.doc.Views.Redraw()\n \nmain()",
      "language": "python",
      "author": "emilio",
      "post_number": 27,
      "is_solution": false
    },
    {
      "code": "import rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino as R\n\nimport datetime\n\n\ndef mesh_inclusion():\n    mesh_guid = rs.GetObject('select mesh')\n    point_guids = rs.GetObjects('select points')\n    \n    mesh_geo = rs.coercegeometry(mesh_guid)\n    \n    included_count = 0\n    excluded_count = 0\n    start_time = datetime.datetime.now()\n    \n    for point_guid in point_guids:\n        point_geo = rs.coercegeometry(point_guid).Location\n        if mesh_geo.IsPointInside(point_geo, .01, True):\n            included_count += 1\n        else:\n            excluded_count += 1\n    \n    end_time = datetime.datetime.now()\n    total_time = (end_time - start_time).total_seconds()\n    print 'Mesh Inclusion time: {}s  |  included: {}, excluded: {}'.format(total_time, included_count, excluded_count)\n    \ndef brep_inclusion():\n    brep_guid = rs.GetObject('select brep')\n    point_guids = rs.GetObjects('select points')\n    \n    brep_geo = rs.coercegeometry(brep_guid)\n    \n    included_count = 0\n    excluded_count = 0\n    start_time = datetime.datetime.now()\n    \n    for point_guid in point_guids:\n        point_geo = rs.coercegeometry(point_guid).Location\n        if brep_geo.IsPointInside(point_geo, .01, True):\n            included_count += 1\n        else:\n            excluded_count += 1\n    \n    end_time = datetime.datetime.now()\n    total_time = (end_time - start_time).total_seconds()\n    print 'Brep Inclusion time: {}s  |  included: {}, excluded: {}'.format(total_time, included_count, excluded_count)\n    \n    \nmesh_inclusion()\nbrep_inclusion()",
      "language": "python",
      "author": "nathancoatney",
      "post_number": 32,
      "is_solution": false
    }
  ],
  "tags": [
    "boolean",
    "file-io",
    "geometry",
    "grasshopper",
    "mesh",
    "python",
    "rhinocommon",
    "rhinoscriptsyntax",
    "selection",
    "transformation"
  ],
  "has_accepted_answer": true,
  "category_id": 8,
  "posts_count": 71,
  "views": 9121
}