{
  "source_url": "https://github.com/ladybug-tools/honeybee-legacy/blob/bd62af4862fe022801fb87dbc8794fdf1dff73a9/src/Honeybee_Dump%20Honeybee%20Objects.py",
  "repo": "ladybug-tools/honeybee-legacy",
  "repo_stars": 129,
  "repo_description": ":bee: Honeybee is a free and open source plugin to connect Grasshopper3D to EnergyPlus, Radiance, Daysim and OpenStudio for building energy and daylighting simulation",
  "license": "NOASSERTION",
  "filepath": "src/Honeybee_Dump Honeybee Objects.py",
  "instruction": "Dump Honeybee Objects",
  "code": "#\n# Honeybee: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Honeybee.\n# \n# Copyright (c) 2013-2020, Mostapha Sadeghipour Roudsari <mostapha@ladybug.tools> \n# Honeybee is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Honeybee is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Honeybee; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nDump Honeybee Objects\n\nUse this component to dump Honeybee objects to a file on your system.\nYou can use load Honeybee objects to load the file to Grasshopper.\nWARNING: This component does not write custom schedules or materials within the file but it does write the names of the constructions and schedules.\nAccordingly, to properly load objects agian, you must connect the full strings of these objects to a \"Add to EnergyPlus Library\" component in any GH cript that loads the HBZones from the file.\n\n-\nProvided by Honeybee 0.0.66\n\n    Args:\n        _HBObjects: A list of Honeybee objects\n        _fileName: A name for the file to which HBObjects will be written (e.g. 20ZonesExample.HB).\n        _workingDir_: An optional working directory into which the HBZones will be written.  The default is set to C:\\ladybug.\n        _dump: Set to True to save the objects to file\n    Returns:\n        readMe!: ...\n        filePath: The location of the file where the HBZones have been saved.\n\"\"\"\n\nghenv.Component.Name = \"Honeybee_Dump Honeybee Objects\"\nghenv.Component.NickName = 'dumpHBObjects'\nghenv.Component.Message = 'VER 0.0.66\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"HB-Legacy\"\nghenv.Component.SubCategory = \"00 | Honeybee\"\n#compatibleHBVersion = VER 0.0.59\\nDEC_15_2017\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"6\"\nexcept: pass\n\n\nimport cPickle as pickle\nimport scriptcontext as sc\nimport Grasshopper.Kernel as gh\nimport os\nimport uuid\nimport Rhino as rc\n\ndef dumpHBObjects(HBObjects, fileName, workingDir=None):\n    hb_hive = sc.sticky[\"honeybee_Hive\"]()\n    hb_RADMaterialAUX = sc.sticky[\"honeybee_RADMaterialAUX\"]\n    hb_ConstrLib = sc.sticky [\"honeybee_constructionLib\"]\n    hb_EPScheduleAUX = sc.sticky[\"honeybee_EPScheduleAUX\"]()\n    hb_EPObjectsAux = sc.sticky[\"honeybee_EPObjectsAUX\"]()\n    if workingDir == None:\n        workingDir = sc.sticky[\"Honeybee_DefaultFolder\"] \n    if not fileName.upper().endswith('.HB.'):\n        fileName = fileName + '.HB'\n    defaultEPConstrSet = ['INTERIOR CEILING', 'INTERIOR DOOR', 'INTERIOR FLOOR', 'INTERIOR PARTITION', \\\n        'INTERIOR WALL', 'INTERIOR WINDOW', 'EXTERIOR DOOR', 'EXTERIOR FLOOR', 'EXTERIOR ROOF', \\\n        'EXTERIOR WALL', 'EXTERIOR WINDOW']\n    defaultRADmaterials = ['CONTEXT_MATERIAL', 'EXTERIOR_FLOOR', 'EXTERIOR_ROOF', 'EXTERIOR_WALL', \\\n        'EXTERIOR_WINDOW', 'INTERIOR_CEILING', 'INTERIOR_FLOOR', 'INTERIOR_WALL', 'INTERIOR_WINDOW']\n    \n    filePath = os.path.join(workingDir, fileName)\n    \n    if not os.path.isdir(os.path.split(filePath)[0]):\n        raise ValueError(\"Can't find %s\"%os.path.split(filePath)[0])\n    \n    HBObjects = hb_hive.callFromHoneybeeHive(HBObjects)\n    ids = [HBObject.ID for HBObject in HBObjects]\n    # a global dictonary to collect data\n    objs = {}\n    idsToBeChecked = {}\n    \n    # Objects to write back to the memory of the document.\n    constructions = []\n    EPmaterials = []\n    RADmaterials = []\n    scheduleCollection = []\n    shdCntrlCollection = []\n    hvacIDs = []\n    airIDs = []\n    heatIDs = []\n    coolIDs = []\n    \n    def dumpHBZone(HBZone):\n        if HBZone.objectType != 'HBZone': return\n        \n        # Scale everything if the units system is not meters.\n        if sc.sticky[\"honeybee_ConversionFactor\"] != 1:\n            fac = sc.sticky[\"honeybee_ConversionFactor\"]\n            NUscale = rc.Geometry.Transform.Scale(rc.Geometry.Plane(rc.Geometry.Plane.WorldXY),fac,fac,fac)\n            HBZone.transform(NUscale, \"\", False)\n        \n        # dump all surfaces and replace surfaces with ids.\n        surfaceIds = [srf.ID for srf in HBZone.surfaces]\n        for surface in HBZone.surfaces:\n            dumpHBSurface(surface)\n        HBZone.surfaces = surfaceIds\n        \n        # dump the HVAC system.\n        if HBZone.HVACSystem.ID not in hvacIDs:\n            dumpHBhvac(HBZone.HVACSystem)\n        HBZone.HVACSystem = HBZone.HVACSystem.ID\n        \n        # dump the schedules associated with the zone.\n        schedules = HBZone.getCurrentSchedules(True)\n        dumpAllSchedules(schedules)\n        \n        # dump any internal masses.\n        if HBZone.internalMassConstructions != []:\n            for massMat in HBZone.internalMassConstructions:\n                if massMat.upper() not in constructions and massMat.upper() not in defaultEPConstrSet:\n                    constructions.append(massMat.upper())\n                    materials = dumpHBConstr(massMat.upper())\n                    for mat in materials:\n                        if mat.upper() not in EPmaterials:\n                            EPmaterials.append(mat.upper())\n                            dumpHBMat(mat.upper())\n        \n        # dump any earth tube schedules.\n        if HBZone.earthtube == True:\n            if HBZone.ETschedule != \"Always On Discrete\" and HBZone.ETschedule.upper() not in scheduleCollection:\n                dumpAllSchedules([HBZone.ETschedule])\n        \n        # add the zone to the master dictionary.\n        objs[HBZone.ID] = HBZone.__dict__\n    \n    def dumpHBSurface(HBSurface, checkTransform=False):\n        # Scale everything if the units system is not meters.\n        if checkTransform == True and sc.sticky[\"honeybee_ConversionFactor\"] != 1:\n            fac = sc.sticky[\"honeybee_ConversionFactor\"]\n            NUscale = rc.Geometry.Transform.Scale(rc.Geometry.Plane(rc.Geometry.Plane.WorldXY),fac,fac,fac)\n            HBSurface.transform(NUscale, \"\", False)\n        \n        # replace parent object with it's ID\n        if HBSurface.parent != None:\n            # make sure parent object is also in the list\n            idsToBeChecked[HBSurface.parent.ID] = HBSurface.parent.name\n            # replace parent object with ID\n            HBSurface.parent = HBSurface.parent.ID\n        \n        # dump windows\n        if not HBSurface.isChild and HBSurface.hasChild:\n            childIds = [childSrf.ID for childSrf in HBSurface.childSrfs]\n            for childSrf in HBSurface.childSrfs:\n                dumpHBSurface(childSrf)\n            HBSurface.childSrfs = childIds\n        \n        # dump blinds and shading control.\n        if HBSurface.isChild and HBSurface.shadingControlName != []:\n            for shadingCount, windowShading in enumerate(HBSurface.shadingControlName):\n                if windowShading.upper() not in shdCntrlCollection:\n                    dumpHBShdCntrl(windowShading)\n                    shdCntrlCollection.append(windowShading.upper())\n        \n        # dump custom constructions.\n        if HBSurface.EPConstruction != None and HBSurface.EPConstruction.upper() not in constructions and HBSurface.EPConstruction.upper() not in defaultEPConstrSet:\n            constructions.append(HBSurface.EPConstruction.upper())\n            materials = dumpHBConstr(HBSurface.EPConstruction.upper())\n            for mat in materials:\n                if mat.upper() not in EPmaterials:\n                    EPmaterials.append(mat.upper())\n                    dumpHBMat(mat.upper())\n        \n        # dump custom RAD materials.\n        if HBSurface.RadMaterial != None and HBSurface.RadMaterial.upper() not in RADmaterials and HBSurface.RadMaterial.upper() not in defaultRADmaterials:\n            RADmaterials.append(HBSurface.RadMaterial.upper())\n            dumpHBRad(HBSurface.RadMaterial)\n        \n        # Shading surfaces.\n        if HBSurface.type == 6:\n            if HBSurface.TransmittanceSCH != '' and HBSurface.TransmittanceSCH.upper() not in scheduleCollection:\n                scheduleCollection.append(HBSurface.TransmittanceSCH.upper())\n                dumpAllSchedules([HBSurface.TransmittanceSCH])\n            HBSurface.childSrfs = [childSrf.ID for childSrf in HBSurface.childSrfs]\n        \n        # This needs to be set to outdoors at first but will be replaced by the correct object on loading\n        try:\n            if HBSurface.BC.lower() != 'surface':\n                HBSurface.BCObject = \"Outdoors\" #This will be replaced by the correct object on loading\n        except:\n            pass\n        \n        # in case the surface is adjacent to another surface\n        if hasattr(HBSurface.BCObject, \"ID\"):\n            idsToBeChecked[HBSurface.BCObject.ID] = HBSurface.BCObject.name\n            # replace parent object with ID\n            HBSurface.BCObject = HBSurface.BCObject.ID\n        \n        objs[HBSurface.ID] = HBSurface.__dict__\n    \n    def dumpHBhvac(HBhvac):\n        hvacID = HBhvac.ID\n        if HBhvac.airDetails != None:\n            airID = HBhvac.airDetails.ID\n            airDetailsDict = HBhvac.airDetails.__dict__\n            del airDetailsDict['sysProps']\n            HBhvac.airDetails = airID\n            if airID not in airIDs:\n                airIDs.append(airID)\n                objs[airID] = airDetailsDict\n        \n        if HBhvac.heatingDetails != None:\n            heatID = HBhvac.heatingDetails.ID\n            heatingDetailsDict = HBhvac.heatingDetails.__dict__\n            del heatingDetailsDict['sysProps']\n            HBhvac.heatingDetails = heatID\n            if heatID not in heatIDs:\n                heatIDs.append(heatID)\n                objs[heatID] = heatingDetailsDict\n        \n        if HBhvac.coolingDetails != None:\n            coolID = HBhvac.coolingDetails.ID\n            coolingDetailsDict = HBhvac.coolingDetails.__dict__\n            del coolingDetailsDict['sysProps']\n            HBhvac.coolingDetails = coolID\n            if coolID not in coolIDs:\n                coolIDs.append(coolID)\n                objs[coolID] = coolingDetailsDict\n        \n        if hvacID not in hvacIDs:\n            hvacIDs.append(hvacID)\n            objs[hvacID] = HBhvac.__dict__\n    \n    def dumpHBConstr(constructionName):\n        constructionData = hb_ConstrLib[constructionName]\n        constrMats = []\n        numberOfLayers = len(constructionData.keys())\n        constructionStr = constructionData[0] + \",\\n\"\n        constructionStr =  constructionStr + \"  \" + constructionName + \",   !- name\\n\"\n        for layer in range(1, numberOfLayers):\n            if layer < numberOfLayers-1:\n                constructionStr =  constructionStr + \"  \" + constructionData[layer][0] + \",   !- \" +  constructionData[layer][1] + \"\\n\"\n            else:\n                constructionStr =  constructionStr + \"  \" + constructionData[layer][0] + \";   !- \" +  constructionData[layer][1] + \"\\n\\n\"\n            constrMats.append(constructionData[layer][0])\n        constructionDict = {'objectType': 'HBConstr', 'name': constructionName, 'EPstr': constructionStr}\n        objs[constructionName] = constructionDict\n        return constrMats\n    \n    def dumpHBMat(materialName):\n        materialName = materialName.strip()\n        materialData = None\n        if materialName in sc.sticky [\"honeybee_windowMaterialLib\"].keys():\n            materialData = sc.sticky [\"honeybee_windowMaterialLib\"][materialName]\n        elif materialName in sc.sticky [\"honeybee_materialLib\"].keys():\n            materialData = sc.sticky [\"honeybee_materialLib\"][materialName]\n        if materialData!=None:\n            numberOfLayers = len(materialData.keys())\n            materialStr = materialData[0] + \",\\n\"\n            materialStr =  materialStr + \"  \" + materialName + \",   !- name\\n\"\n            for layer in range(1, numberOfLayers):\n                if layer < numberOfLayers-1:\n                    materialStr =  materialStr + \"  \" + str(materialData[layer][0]) + \",   !- \" +  materialData[layer][1] + \"\\n\"\n                else:\n                    materialStr =  materialStr + \"  \" + str(materialData[layer][0]) + \";   !- \" +  materialData[layer][1] + \"\\n\\n\"\n            materialDict = {'objectType': 'HBMat', 'name': materialName, 'EPstr': materialStr}\n            objs[materialName] = materialDict\n    \n    def dumpAllSchedules(schedules):\n        schedCollect = schedules.values()\n        for schedule in schedCollect:\n            if schedule.upper() not in scheduleCollection and schedule != '':\n                scheduleCollection.append(schedule.upper())\n                dumpHBSched(schedule)\n                scheduleValues, comments = hb_EPScheduleAUX.getScheduleDataByName(schedule, ghenv.Component)\n                \n                if scheduleValues[0].lower() == \"schedule:year\":\n                    numOfWeeklySchedules = int((len(scheduleValues)-2)/5)\n                    for i in range(numOfWeeklySchedules):\n                        weekDayScheduleName = scheduleValues[5 * i + 2]\n                        if weekDayScheduleName not in schedCollect and not weekDayScheduleName == '':\n                            schedCollect.append(weekDayScheduleName)\n                # collect all the schedule items inside the schedule\n                elif scheduleValues[0].lower() == \"schedule:week:daily\":\n                    for value in scheduleValues[1:]:\n                        if value not in schedCollect:\n                            schedCollect.append(value)\n    \n    def dumpHBSched(scheduleName):\n        scheduleData = None\n        scheduleName= scheduleName.upper()\n        if scheduleName.lower().endswith(\".csv\"):\n            warning = \"CSV schedule detected.  Make sure that the machine that\\n  loads the HBZones has the CSV schedule in the same location.\"\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n        \n        if scheduleName in sc.sticky [\"honeybee_ScheduleLib\"].keys():\n            scheduleData = sc.sticky [\"honeybee_ScheduleLib\"][scheduleName]\n        elif scheduleName in sc.sticky [\"honeybee_ScheduleTypeLimitsLib\"].keys():\n            scheduleData = sc.sticky[\"honeybee_ScheduleTypeLimitsLib\"][scheduleName]\n        \n        if scheduleData!=None:\n            numberOfLayers = len(scheduleData.keys())\n            scheduleStr = scheduleData[0] + \",\\n\"\n            if numberOfLayers == 1:\n                return scheduleStr  + \"  \" +  scheduleName + \";   !- name\\n\\n\"\n            # add the name\n            scheduleStr =  scheduleStr  + \"  \" +  scheduleName + \",   !- name\\n\"\n            \n            for layer in range(1, numberOfLayers):\n                if layer < numberOfLayers - 1:\n                    scheduleStr =  scheduleStr + \"  \" + scheduleData[layer][0] + \",   !- \" +  scheduleData[layer][1] + \"\\n\"\n                else:\n                    scheduleStr =  scheduleStr + \"  \" + str(scheduleData[layer][0]) + \";   !- \" +  scheduleData[layer][1] + \"\\n\\n\"\n            scheduleDict = {'objectType': 'HBsched', 'name': scheduleName, 'EPstr': scheduleStr}\n            objs[scheduleName] = scheduleDict\n    \n    def dumpHBShdCntrl(windowShading):\n        shdCntrlDict = {'objectType': 'HBShdCntrl', 'name': windowShading, 'EPstr': hb_EPObjectsAux.getEPObjectsStr(windowShading)}\n        objs[windowShading] = shdCntrlDict\n        \n        values = hb_EPObjectsAux.getEPObjectDataByName(windowShading)\n        if values[4][0] != '' and values[4][0].upper() not in scheduleCollection:\n            scheduleCollection.append([values[4][0]])\n        if values[2][0] != '':\n            # Iniitalize for construction (for switchable glazing).\n            constrName = values[2][0]\n            constructions.append(constrName.upper())\n            materials = dumpHBConstr(constrName.upper())\n            for mat in materials:\n                if mat.upper() not in EPmaterials:\n                    EPmaterials.append(mat.upper())\n                    dumpHBMat(mat.upper())\n        else:\n            # Iniitalize for material (for blinds and shades).\n            materialName = values[8][0]\n            EPmaterials.append(materialName.upper())\n            dumpHBMat(materialName.upper())\n    \n    def dumpHBRad(radMatName):\n        radStr =  hb_RADMaterialAUX.getRADMaterialString(radMatName)\n        radMaterialDict = {'objectType': 'HBRadMat', 'name': radMatName, 'RADstr': radStr}\n        objs[radMatName] = radMaterialDict\n    \n    def dumpHBViewFactor(viewFacInfo):\n        # add the view factor to the master dictionary.\n        objs[viewFacInfo.ID] = viewFacInfo.__dict__\n    \n    # cycle through the objects and dump everything.\n    for id, HBO in zip(ids, HBObjects):\n        if HBO.objectType == 'HBSurface':\n            dumpHBSurface(HBO, True)\n        elif HBO.objectType == 'HBZone':\n            dumpHBZone(HBO)\n        elif HBO.objectType == 'ViewFactorInfo':\n            dumpHBViewFactor(HBO)\n        else:\n            raise Exception(\"Unsupported object! Assure all objects are Honeybee objects\")\n    \n    # make sure all the parent objects and boundary condition objects are included\n    # in the file\n    keys = objs.keys()\n    for id, name in idsToBeChecked.iteritems():\n        assert id in keys,\\\n            \" InputError: Adjacent object %s is not in the list of HBObjects.\"%name\n    \n    HBData = {'ids':ids, 'objs': objs}\n    with open(filePath, \"wb\") as outf:\n        pickle.dump(HBData, outf)\n        print \"Saved file to %s\"%filePath\n    return filePath\n\n\n\n#Honeybee check.\ninitCheck = True\nif not sc.sticky.has_key('honeybee_release') == True:\n    initCheck = False\n    print \"You should first let Honeybee fly...\"\n    ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, \"You should first let Honeybee fly...\")\nelse:\n    try:\n        if not sc.sticky['honeybee_release'].isCompatible(ghenv.Component): initCheck = False\n        if sc.sticky['honeybee_release'].isInputMissing(ghenv.Component): initCheck = False\n    except:\n        initCheck = False\n        warning = \"You need a newer version of Honeybee to use this compoent.\" + \\\n        \"Use updateHoneybee component to update userObjects.\\n\" + \\\n        \"If you have already updated userObjects drag Honeybee_Honeybee component \" + \\\n        \"into canvas and try again.\"\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n\n\n\nif initCheck == True and _dump == True and _fileName != None:\n    filePath = dumpHBObjects(_HBObjects, _fileName, _workingDir_)",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}