{
  "source_url": "https://github.com/gtalarico/ironpython-stubs/blob/c7f6a6cb197e3949e40a4880a0b2a44e72d0a940/release/stubs/Rhino/Geometry/Intersect.py",
  "repo": "gtalarico/ironpython-stubs",
  "repo_stars": 261,
  "repo_description": "Autocomplete stubs for common IronPython/.NET libraries",
  "license": "NOASSERTION",
  "filepath": "release/stubs/Rhino/Geometry/Intersect.py",
  "instruction": "NamespaceTracker represent a CLS namespace.",
  "code": "# encoding: utf-8\r\n# module Rhino.Geometry.Intersect calls itself Intersect\r\n# from RhinoCommon, Version=5.1.30000.16, Culture=neutral, PublicKeyToken=552281e97c755530\r\n# by generator 1.145\r\n\"\"\" NamespaceTracker represent a CLS namespace. \"\"\"\r\n# no imports\r\n\r\n# no functions\r\n# classes\r\n\r\nclass CurveIntersections(object, IDisposable, IList[IntersectionEvent], ICollection[IntersectionEvent], IEnumerable[IntersectionEvent], IEnumerable):\r\n    \"\"\" Maintains an ordered list of Curve Intersection results. \"\"\"\r\n    def CopyTo(self, array, arrayIndex):\r\n        \"\"\"\r\n        CopyTo(self: CurveIntersections, array: Array[IntersectionEvent], arrayIndex: int)\r\r\n            Copies all intersection results into another array, departing at an index in the target array.\r\r\n        \r\r\n            array: The target array. This value cannot be null.\r\r\n            arrayIndex: Zero-based index in which to start the copy.\r\n        \"\"\"\r\n        pass\r\n\r\n    def Dispose(self):\r\n        \"\"\"\r\n        Dispose(self: CurveIntersections)\r\r\n            Actively reclaims unmanaged resources that this instance uses.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetEnumerator(self):\r\n        \"\"\"\r\n        GetEnumerator(self: CurveIntersections) -> IEnumerator[IntersectionEvent]\r\r\n        \r\r\n            Returns an enumerator that is capable of yielding all IntersectionEvents in the collection.\r\r\n            Returns: The constructed enumerator.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__(self: ICollection[IntersectionEvent], item: IntersectionEvent) -> bool \"\"\"\r\n        pass\r\n\r\n    def __enter__(self, *args): #cannot find CLR method\r\n        \"\"\"\r\n        __enter__(self: IDisposable) -> object\r\r\n        \r\r\n            Provides the implementation of __enter__ for objects which implement IDisposable.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __exit__(self, *args): #cannot find CLR method\r\n        \"\"\"\r\n        __exit__(self: IDisposable, exc_type: object, exc_value: object, exc_back: object)\r\r\n            Provides the implementation of __exit__ for objects which implement IDisposable.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __getitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __len__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__len__() <==> len(x) \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the number of recorded intersection events.\r\r\n\r\r\nGet: Count(self: CurveIntersections) -> int\r\r\n\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass Intersection(object):\r\n    \"\"\" Provides static methods for the computation of intersections, projections, sections and similar. \"\"\"\r\n    @staticmethod\r\n    def BrepBrep(brepA, brepB, tolerance, intersectionCurves, intersectionPoints):\r\n        \"\"\"\r\n        BrepBrep(brepA: Brep, brepB: Brep, tolerance: float) -> (bool, Array[Curve], Array[Point3d])\r\r\n        \r\r\n            Intersects two Breps.\r\r\n        \r\r\n            brepA: First Brep for intersection.\r\r\n            brepB: Second Brep for intersection.\r\r\n            tolerance: Intersection tolerance.\r\r\n            Returns: true on success; false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def BrepPlane(brep, plane, tolerance, intersectionCurves, intersectionPoints):\r\n        \"\"\"\r\n        BrepPlane(brep: Brep, plane: Plane, tolerance: float) -> (bool, Array[Curve], Array[Point3d])\r\r\n        \r\r\n            Intersects a Brep with an (infinite) plane.\r\r\n        \r\r\n            brep: Brep to intersect.\r\r\n            plane: Plane to intersect with.\r\r\n            tolerance: Tolerance to use for intersections.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def BrepSurface(brep, surface, tolerance, intersectionCurves, intersectionPoints):\r\n        \"\"\"\r\n        BrepSurface(brep: Brep, surface: Surface, tolerance: float) -> (bool, Array[Curve], Array[Point3d])\r\r\n        \r\r\n            Intersects a Brep and a Surface.\r\r\n        \r\r\n            brep: A brep to be intersected.\r\r\n            surface: A surface to be intersected.\r\r\n            tolerance: A tolerance value.\r\r\n            Returns: true on success; false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def CurveBrep(curve, brep, tolerance, overlapCurves, intersectionPoints):\r\n        \"\"\"\r\n        CurveBrep(curve: Curve, brep: Brep, tolerance: float) -> (bool, Array[Curve], Array[Point3d])\r\r\n        \r\r\n            Intersects a curve with a Brep. This function returns the 3D points of intersection\r\r\n                    \r\r\n             and 3D overlap curves. If an error occurs while processing overlap curves, this function \r\r\n              \r\r\n                   will return false, but it will still provide partial results.\r\r\n        \r\r\n        \r\r\n            curve: Curve for intersection.\r\r\n            brep: Brep for intersection.\r\r\n            tolerance: Fitting and near miss tolerance.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def CurveBrepFace(curve, face, tolerance, overlapCurves, intersectionPoints):\r\n        \"\"\"\r\n        CurveBrepFace(curve: Curve, face: BrepFace, tolerance: float) -> (bool, Array[Curve], Array[Point3d])\r\r\n        \r\r\n            Intersects a curve with a Brep face.\r\r\n        \r\r\n            curve: A curve.\r\r\n            face: A brep face.\r\r\n            tolerance: Fitting and near miss tolerance.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def CurveCurve(curveA, curveB, tolerance, overlapTolerance):\r\n        \"\"\"\r\n        CurveCurve(curveA: Curve, curveB: Curve, tolerance: float, overlapTolerance: float) -> CurveIntersections\r\r\n        \r\r\n            Finds the intersections between two curves.\r\r\n        \r\r\n            curveA: First curve for intersection.\r\r\n            curveB: Second curve for intersection.\r\r\n            tolerance: Intersection tolerance. If the curves approach each other to within tolerance, \r\r\n                    an \r\r\n             intersection is assumed.\r\r\n        \r\r\n            overlapTolerance: The tolerance with which the curves are tested.\r\r\n            Returns: A collection of intersection events.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def CurvePlane(curve, plane, tolerance):\r\n        \"\"\"\r\n        CurvePlane(curve: Curve, plane: Plane, tolerance: float) -> CurveIntersections\r\r\n        \r\r\n            Intersects a curve with an (infinite) plane.\r\r\n        \r\r\n            curve: Curve to intersect.\r\r\n            plane: Plane to intersect with.\r\r\n            tolerance: Tolerance to use during intersection.\r\r\n            Returns: A list of intersection events or null if no intersections were recorded.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def CurveSelf(curve, tolerance):\r\n        \"\"\"\r\n        CurveSelf(curve: Curve, tolerance: float) -> CurveIntersections\r\r\n        \r\r\n            Finds the places where a curve intersects itself.\r\r\n        \r\r\n            curve: Curve for self-intersections.\r\r\n            tolerance: Intersection tolerance. If the curve approaches itself to within tolerance, \r\r\n                    an \r\r\n             intersection is assumed.\r\r\n        \r\r\n            Returns: A collection of intersection events.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def CurveSurface(curve, *__args):\r\n        \"\"\"\r\n        CurveSurface(curve: Curve, curveDomain: Interval, surface: Surface, tolerance: float, overlapTolerance: float) -> CurveIntersections\r\r\n        \r\r\n            Intersects a (sub)curve and a surface.\r\r\n        \r\r\n            curve: Curve for intersection.\r\r\n            curveDomain: Domain of surbcurve to take into consideration for Intersections.\r\r\n            surface: Surface for intersection.\r\r\n            tolerance: Intersection tolerance. If the curve approaches the surface to within tolerance, \r\r\n                    \r\r\n             an intersection is assumed.\r\r\n        \r\r\n            overlapTolerance: The tolerance with which the curves are tested.\r\r\n            Returns: A collection of intersection events.\r\r\n        CurveSurface(curve: Curve, surface: Surface, tolerance: float, overlapTolerance: float) -> CurveIntersections\r\r\n        \r\r\n            Intersects a curve and a surface.\r\r\n        \r\r\n            curve: Curve for intersection.\r\r\n            surface: Surface for intersection.\r\r\n            tolerance: Intersection tolerance. If the curve approaches the surface to within tolerance, \r\r\n                    \r\r\n             an intersection is assumed.\r\r\n        \r\r\n            overlapTolerance: The tolerance with which the curves are tested.\r\r\n            Returns: A collection of intersection events.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def LineBox(line, box, tolerance, lineParameters):\r\n        \"\"\"\r\n        LineBox(line: Line, box: Box, tolerance: float) -> (bool, Interval)\r\r\n        \r\r\n            Intersects an infinite line with a box volume.\r\r\n        \r\r\n            line: Line for intersection.\r\r\n            box: Box to intersect.\r\r\n            tolerance: If tolerance > 0.0, then the intersection is performed against a box \r\r\n                    that has each \r\r\n             side moved out by tolerance.\r\r\n        \r\r\n            Returns: true if the line intersects the box, false if no intersection occurs.\r\r\n        LineBox(line: Line, box: BoundingBox, tolerance: float) -> (bool, Interval)\r\r\n        \r\r\n            Intersects an infinite line and an axis aligned bounding box.\r\r\n        \r\r\n            line: Line for intersection.\r\r\n            box: BoundingBox to intersect.\r\r\n            tolerance: If tolerance > 0.0, then the intersection is performed against a box \r\r\n                    that has each \r\r\n             side moved out by tolerance.\r\r\n        \r\r\n            Returns: true if the line intersects the box, false if no intersection occurs.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def LineCircle(line, circle, t1, point1, t2, point2):\r\n        \"\"\"\r\n        LineCircle(line: Line, circle: Circle) -> (LineCircleIntersection, float, Point3d, float, Point3d)\r\r\n        \r\r\n            Intersects a line with a circle using exact calculations.\r\r\n        \r\r\n            line: Line for intersection.\r\r\n            circle: Circle for intersection.\r\r\n            Returns: If Rhino.Geometry.Intersect.LineCircleIntersection.Single is returned, only t1 and point1 will \r\r\n             have valid values. \r\r\n                    If Rhino.Geometry.Intersect.LineCircleIntersection.Multiple is \r\r\n             returned, t2 and point2 will also be filled out.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def LineCylinder(line, cylinder, intersectionPoint1, intersectionPoint2):\r\n        \"\"\"\r\n        LineCylinder(line: Line, cylinder: Cylinder) -> (LineCylinderIntersection, Point3d, Point3d)\r\r\n        \r\r\n            Intersects a line with a cylinder using exact calculations.\r\r\n        \r\r\n            line: Line for intersection.\r\r\n            cylinder: Cylinder for intersection.\r\r\n            Returns: If None is returned, the first point is the point on the line closest\r\r\n                    to the \r\r\n             cylinder and the second point is the point on the cylinder closest to\r\r\n                    the line. \r\r\n          \r\r\n                       If Rhino.Geometry.Intersect.LineCylinderIntersection.Single is returned, the first \r\r\n             point\r\r\n                    is the point on the line and the second point is the  same point on the\r\r\n             \r\r\n                    cylinder.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def LineLine(lineA, lineB, a, b, tolerance=None, finiteSegments=None):\r\n        \"\"\"\r\n        LineLine(lineA: Line, lineB: Line) -> (bool, float, float)\r\r\n        \r\r\n            Finds the closest point between two infinite lines.\r\r\n        \r\r\n            lineA: First line.\r\r\n            lineB: Second line.\r\r\n            Returns: true if points are found and false if the lines are numerically parallel. \r\r\n                    \r\r\n             Numerically parallel means the 2x2 matrix:\r\r\n                    +AoA  -AoB-AoB  +BoB\r\r\n                    is \r\r\n             numerically singular, where A = (lineA.To - lineA.From) and B = (lineB.To-lineB.From)\r\r\n        \r\r\n        LineLine(lineA: Line, lineB: Line, tolerance: float, finiteSegments: bool) -> (bool, float, float)\r\r\n        \r\r\n            Intersects two lines.\r\r\n        \r\r\n            lineA: First line for intersection.\r\r\n            lineB: Second line for intersection.\r\r\n            tolerance: If tolerance > 0.0, then an intersection is reported only if the distance between the points is \r\r\n             <= tolerance. \r\r\n                    If tolerance <= 0.0, then the closest point between the lines is \r\r\n             reported.\r\r\n        \r\r\n            finiteSegments: If true, the input lines are treated as finite segments. \r\r\n                    If false, the input lines \r\r\n             are treated as infinite lines.\r\r\n        \r\r\n            Returns: true if a closest point can be calculated and the result passes the tolerance parameter test; \r\r\n             otherwise false.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def LinePlane(line, plane, lineParameter):\r\n        \"\"\"\r\n        LinePlane(line: Line, plane: Plane) -> (bool, float)\r\r\n        \r\r\n            Intersects a line and a plane. This function only returns true if the \r\r\n                    intersection \r\r\n             result is a single point (i.e. if the line is coincident with \r\r\n                    the plane then no \r\r\n             intersection is assumed).\r\r\n        \r\r\n        \r\r\n            line: Line for intersection.\r\r\n            plane: Plane to intersect.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def LineSphere(line, sphere, intersectionPoint1, intersectionPoint2):\r\n        \"\"\"\r\n        LineSphere(line: Line, sphere: Sphere) -> (LineSphereIntersection, Point3d, Point3d)\r\r\n        \r\r\n            Intersects a line with a sphere using exact calculations.\r\r\n        \r\r\n            line: Line for intersection.\r\r\n            sphere: Sphere for intersection.\r\r\n            Returns: If Rhino.Geometry.Intersect.LineSphereIntersection.None is returned, the first point is the \r\r\n             point on the line closest to the sphere and \r\r\n                    the second point is the point on the \r\r\n             sphere closest to the line. \r\r\n                    If \r\r\n             Rhino.Geometry.Intersect.LineSphereIntersection.Single is returned, the first point is the point \r\r\n             on the line and the second point is the \r\r\n                    same point on the sphere.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def MeshLine(mesh, line, faceIds):\r\n        \"\"\"\r\n        MeshLine(mesh: Mesh, line: Line) -> (Array[Point3d], Array[int])\r\r\n        \r\r\n            Finds the intersection of a mesh and a line\r\r\n        \r\r\n            mesh: A mesh to intersect\r\r\n            line: The line to intersect with the mesh\r\r\n            Returns: An array of points: one for each face that was passed by the faceIds out reference.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def MeshMeshAccurate(meshA, meshB, tolerance):\r\n        \"\"\"\r\n        MeshMeshAccurate(meshA: Mesh, meshB: Mesh, tolerance: float) -> Array[Polyline]\r\r\n        \r\r\n            Intersects two meshes. Overlaps and near misses are handled.\r\r\n        \r\r\n            meshA: First mesh for intersection.\r\r\n            meshB: Second mesh for intersection.\r\r\n            tolerance: Intersection tolerance.\r\r\n            Returns: An array of intersection polylines.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def MeshMeshFast(meshA, meshB):\r\n        \"\"\"\r\n        MeshMeshFast(meshA: Mesh, meshB: Mesh) -> Array[Line]\r\r\n        \r\r\n            Quickly intersects two meshes. Overlaps and near misses are ignored.\r\r\n        \r\r\n            meshA: First mesh for intersection.\r\r\n            meshB: Second mesh for intersection.\r\r\n            Returns: An array of intersection line segments.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def MeshPlane(mesh, *__args):\r\n        \"\"\"\r\n        MeshPlane(mesh: Mesh, planes: IEnumerable[Plane]) -> Array[Polyline]\r\r\n        MeshPlane(mesh: Mesh, plane: Plane) -> Array[Polyline]\r\r\n        \r\r\n            Intersects a mesh with an (infinite) plane.\r\r\n        \r\r\n            mesh: Mesh to intersect.\r\r\n            plane: Plane to intersect with.\r\r\n            Returns: An array of polylines describing the intersection loops or null (Nothing in Visual Basic) if no \r\r\n             intersections could be found.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def MeshPolyline(mesh, curve, faceIds):\r\n        \"\"\"\r\n        MeshPolyline(mesh: Mesh, curve: PolylineCurve) -> (Array[Point3d], Array[int])\r\r\n        \r\r\n            Finds the intersection of a mesh and a polyline.\r\r\n        \r\r\n            mesh: A mesh to intersect.\r\r\n            curve: A polyline curves to intersect.\r\r\n            Returns: An array of points: one for each face that was passed by the faceIds out reference.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def MeshRay(mesh, ray, meshFaceIndices=None):\r\n        \"\"\"\r\n        MeshRay(mesh: Mesh, ray: Ray3d) -> (float, Array[int])\r\r\n        \r\r\n            Finds the first intersection of a ray with a mesh.\r\r\n        \r\r\n            mesh: A mesh to intersect.\r\r\n            ray: A ray to be casted.\r\r\n            Returns: >= 0.0 parameter along ray if successful.\r\r\n                    < 0.0 if no intersection found.\r\r\n        MeshRay(mesh: Mesh, ray: Ray3d) -> float\r\r\n        \r\r\n            Finds the first intersection of a ray with a mesh.\r\r\n        \r\r\n            mesh: A mesh to intersect.\r\r\n            ray: A ray to be casted.\r\r\n            Returns: >= 0.0 parameter along ray if successful.\r\r\n                    < 0.0 if no intersection found.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def PlaneCircle(plane, circle, firstCircleParameter, secondCircleParameter):\r\n        \"\"\"\r\n        PlaneCircle(plane: Plane, circle: Circle) -> (PlaneCircleIntersection, float, float)\r\r\n        \r\r\n            Intersects a plane with a circle using exact calculations.\r\r\n        \r\r\n            plane: Plane to intersect.\r\r\n            circle: Circe to intersect.\r\r\n            Returns: The type of intersection that occured.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def PlanePlane(planeA, planeB, intersectionLine):\r\n        \"\"\"\r\n        PlanePlane(planeA: Plane, planeB: Plane) -> (bool, Line)\r\r\n        \r\r\n            Intersects two planes and return the intersection line. If the planes are \r\r\n                    parallel \r\r\n             or coincident, no intersection is assumed.\r\r\n        \r\r\n        \r\r\n            planeA: First plane for intersection.\r\r\n            planeB: Second plane for intersection.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def PlanePlanePlane(planeA, planeB, planeC, intersectionPoint):\r\n        \"\"\"\r\n        PlanePlanePlane(planeA: Plane, planeB: Plane, planeC: Plane) -> (bool, Point3d)\r\r\n        \r\r\n            Intersects three planes to find the single point they all share.\r\r\n        \r\r\n            planeA: First plane for intersection.\r\r\n            planeB: Second plane for intersection.\r\r\n            planeC: Third plane for intersection.\r\r\n            Returns: true on success, false on failure. If at least two out of the three planes \r\r\n                    are \r\r\n             parallel or coincident, failure is assumed.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def PlaneSphere(plane, sphere, intersectionCircle):\r\n        \"\"\"\r\n        PlaneSphere(plane: Plane, sphere: Sphere) -> (PlaneSphereIntersection, Circle)\r\r\n        \r\r\n            Intersects a plane with a sphere using exact calculations.\r\r\n        \r\r\n            plane: Plane to intersect.\r\r\n            sphere: Sphere to intersect.\r\r\n            Returns: If Rhino.Geometry.Intersect.PlaneSphereIntersection.None is returned, the intersectionCircle has \r\r\n             a radius of zero and the center point \r\r\n                    is the point on the plane closest to the \r\r\n             sphere.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def ProjectPointsToBreps(breps, points, direction, tolerance):\r\n        \"\"\" ProjectPointsToBreps(breps: IEnumerable[Brep], points: IEnumerable[Point3d], direction: Vector3d, tolerance: float) -> Array[Point3d] \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def ProjectPointsToBrepsEx(breps, points, direction, tolerance, indices):\r\n        \"\"\" ProjectPointsToBrepsEx(breps: IEnumerable[Brep], points: IEnumerable[Point3d], direction: Vector3d, tolerance: float) -> (Array[Point3d], Array[int]) \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def ProjectPointsToMeshes(meshes, points, direction, tolerance):\r\n        \"\"\" ProjectPointsToMeshes(meshes: IEnumerable[Mesh], points: IEnumerable[Point3d], direction: Vector3d, tolerance: float) -> Array[Point3d] \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def ProjectPointsToMeshesEx(meshes, points, direction, tolerance, indices):\r\n        \"\"\" ProjectPointsToMeshesEx(meshes: IEnumerable[Mesh], points: IEnumerable[Point3d], direction: Vector3d, tolerance: float) -> (Array[Point3d], Array[int]) \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def RayShoot(ray, geometry, maxReflections):\r\n        \"\"\" RayShoot(ray: Ray3d, geometry: IEnumerable[GeometryBase], maxReflections: int) -> Array[Point3d] \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def SphereSphere(sphereA, sphereB, intersectionCircle):\r\n        \"\"\"\r\n        SphereSphere(sphereA: Sphere, sphereB: Sphere) -> (SphereSphereIntersection, Circle)\r\r\n        \r\r\n            Intersects two spheres using exact calculations.\r\r\n        \r\r\n            sphereA: First sphere to intersect.\r\r\n            sphereB: Second sphere to intersect.\r\r\n            Returns: The intersection type.\r\n        \"\"\"\r\n        pass\r\n\r\n    @staticmethod\r\n    def SurfaceSurface(surfaceA, surfaceB, tolerance, intersectionCurves, intersectionPoints):\r\n        \"\"\"\r\n        SurfaceSurface(surfaceA: Surface, surfaceB: Surface, tolerance: float) -> (bool, Array[Curve], Array[Point3d])\r\r\n        \r\r\n            Intersects two Surfaces.\r\r\n        \r\r\n            surfaceA: First Surface for intersection.\r\r\n            surfaceB: Second Surface for intersection.\r\r\n            tolerance: Intersection tolerance.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    __all__ = [\r\n        'BrepBrep',\r\n        'BrepPlane',\r\n        'BrepSurface',\r\n        'CurveBrep',\r\n        'CurveBrepFace',\r\n        'CurveCurve',\r\n        'CurvePlane',\r\n        'CurveSelf',\r\n        'CurveSurface',\r\n        'LineBox',\r\n        'LineCircle',\r\n        'LineCylinder',\r\n        'LineLine',\r\n        'LinePlane',\r\n        'LineSphere',\r\n        'MeshLine',\r\n        'MeshMeshAccurate',\r\n        'MeshMeshFast',\r\n        'MeshPlane',\r\n        'MeshPolyline',\r\n        'MeshRay',\r\n        'PlaneCircle',\r\n        'PlanePlane',\r\n        'PlanePlanePlane',\r\n        'PlaneSphere',\r\n        'ProjectPointsToBreps',\r\n        'ProjectPointsToBrepsEx',\r\n        'ProjectPointsToMeshes',\r\n        'ProjectPointsToMeshesEx',\r\n        'RayShoot',\r\n        'SphereSphere',\r\n        'SurfaceSurface',\r\n    ]\r\n\r\n\r\nclass IntersectionEvent(object):\r\n    \"\"\"\r\n    Provides all the information for a single Curve Intersection event.\r\r\n    \r\r\n    IntersectionEvent()\r\n    \"\"\"\r\n    def SurfaceOverlapParameter(self, uDomain, vDomain):\r\n        \"\"\"\r\n        SurfaceOverlapParameter(self: IntersectionEvent) -> (Interval, Interval)\r\r\n        \r\r\n            If this instance records a Curve|Surface intersection event, \r\r\n                    and the intersection \r\r\n             type if overlap, then use this function \r\r\n                    to get the U and V domains on the surface \r\r\n             where the overlap occurs.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SurfacePointParameter(self, u, v):\r\n        \"\"\"\r\n        SurfacePointParameter(self: IntersectionEvent) -> (float, float)\r\r\n        \r\r\n            If this instance records a Curve|Surface intersection event, \r\r\n                    and the intersection \r\r\n             type is point, then use this function \r\r\n                    to get the U and V parameters on the surface \r\r\n             where the intersection occurs.\r\n        \"\"\"\r\n        pass\r\n\r\n    IsOverlap = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"All curve intersection events are either a single point or an overlap.\r\r\n\r\r\nGet: IsOverlap(self: IntersectionEvent) -> bool\r\r\n\r\r\n\"\"\"\r\n\r\n    IsPoint = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"All curve intersection events are either a single point or an overlap.\r\r\n\r\r\nGet: IsPoint(self: IntersectionEvent) -> bool\r\r\n\r\r\n\"\"\"\r\n\r\n    OverlapA = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the interval on curve A where the overlap occurs. \r\r\n            If the intersection type is not overlap, this value is meaningless.\r\r\n\r\r\nGet: OverlapA(self: IntersectionEvent) -> Interval\r\r\n\r\r\n\"\"\"\r\n\r\n    OverlapB = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the interval on curve B where the overlap occurs. \r\r\n            If the intersection type is not overlap, this value is meaningless.\r\r\n\r\r\nGet: OverlapB(self: IntersectionEvent) -> Interval\r\r\n\r\r\n\"\"\"\r\n\r\n    ParameterA = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the parameter on Curve A where the intersection occured. \r\r\n            If the intersection type is overlap, then this will return the \r\r\n            start of the overlap region.\r\r\n\r\r\nGet: ParameterA(self: IntersectionEvent) -> float\r\r\n\r\r\n\"\"\"\r\n\r\n    ParameterB = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the parameter on Curve A where the intersection occured. \r\r\n            If the intersection type is overlap, then this will return the \r\r\n            start of the overlap region.\r\r\n\r\r\nGet: ParameterB(self: IntersectionEvent) -> float\r\r\n\r\r\n\"\"\"\r\n\r\n    PointA = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the point on Curve A where the intersection occured. \r\r\n            If the intersection type is overlap, then this will return the \r\r\n            start of the overlap region.\r\r\n\r\r\nGet: PointA(self: IntersectionEvent) -> Point3d\r\r\n\r\r\n\"\"\"\r\n\r\n    PointA2 = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the end point of the overlap on Curve A. \r\r\n            If the intersection type is not overlap, this value is meaningless.\r\r\n\r\r\nGet: PointA2(self: IntersectionEvent) -> Point3d\r\r\n\r\r\n\"\"\"\r\n\r\n    PointB = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the point on Curve B (or Surface B) where the intersection occured. \r\r\n            If the intersection type is overlap, then this will return the \r\r\n            start of the overlap region.\r\r\n\r\r\nGet: PointB(self: IntersectionEvent) -> Point3d\r\r\n\r\r\n\"\"\"\r\n\r\n    PointB2 = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the end point of the overlap on Curve B (or Surface B). \r\r\n            If the intersection type is not overlap, this value is meaningless.\r\r\n\r\r\nGet: PointB2(self: IntersectionEvent) -> Point3d\r\r\n\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass LineCircleIntersection(Enum, IComparable, IFormattable, IConvertible):\r\n    \"\"\"\r\n    Represents all possible cases of a Line|Circle intersection event.\r\r\n    \r\r\n    enum LineCircleIntersection, values: Multiple (2), None (0), Single (1)\r\n    \"\"\"\r\n    def __eq__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__eq__(y) <==> x==yx.__eq__(y) <==> x==yx.__eq__(y) <==> x==y \"\"\"\r\n        pass\r\n\r\n    def __format__(self, *args): #cannot find CLR method\r\n        \"\"\" __format__(formattable: IFormattable, format: str) -> str \"\"\"\r\n        pass\r\n\r\n    def __ge__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __gt__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __le__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __lt__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __ne__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __reduce_ex__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __str__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    Multiple = None\r\n    None = None\r\n    Single = None\r\n    value__ = None\r\n\r\n\r\nclass LineCylinderIntersection(Enum, IComparable, IFormattable, IConvertible):\r\n    \"\"\"\r\n    Represents all possible cases of a Line|Cylinder intersection event.\r\r\n    \r\r\n    enum LineCylinderIntersection, values: Multiple (2), None (0), Overlap (3), Single (1)\r\n    \"\"\"\r\n    def __eq__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__eq__(y) <==> x==yx.__eq__(y) <==> x==yx.__eq__(y) <==> x==y \"\"\"\r\n        pass\r\n\r\n    def __format__(self, *args): #cannot find CLR method\r\n        \"\"\" __format__(formattable: IFormattable, format: str) -> str \"\"\"\r\n        pass\r\n\r\n    def __ge__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __gt__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __le__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __lt__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __ne__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __reduce_ex__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __str__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    Multiple = None\r\n    None = None\r\n    Overlap = None\r\n    Single = None\r\n    value__ = None\r\n\r\n\r\nclass LineSphereIntersection(Enum, IComparable, IFormattable, IConvertible):\r\n    \"\"\"\r\n    Represents all possible cases of a Line|Sphere intersection event.\r\r\n    \r\r\n    enum LineSphereIntersection, values: Multiple (2), None (0), Single (1)\r\n    \"\"\"\r\n    def __eq__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__eq__(y) <==> x==yx.__eq__(y) <==> x==yx.__eq__(y) <==> x==y \"\"\"\r\n        pass\r\n\r\n    def __format__(self, *args): #cannot find CLR method\r\n        \"\"\" __format__(formattable: IFormattable, format: str) -> str \"\"\"\r\n        pass\r\n\r\n    def __ge__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __gt__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __le__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __lt__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __ne__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __reduce_ex__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __str__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    Multiple = None\r\n    None = None\r\n    Single = None\r\n    value__ = None\r\n\r\n\r\nclass MeshClash(object):\r\n    \"\"\" Represents a particular instance of a clash or intersection between two meshes. \"\"\"\r\n    @staticmethod\r\n    def Search(*__args):\r\n        \"\"\"\r\n        Search(meshA: Mesh, meshB: Mesh, distance: float, maxEventCount: int) -> Array[MeshClash]\r\r\n        \r\r\n            Searches the locations where the distance from the first mesh to the second mesh\r\r\n                    is \r\r\n             less than the provided value.\r\r\n        \r\r\n        \r\r\n            meshA: The first mesh.\r\r\n            meshB: The second mesh.\r\r\n            distance: The largest distance at which there is a clash.\r\r\n                    All values smaller than this cause \r\r\n             a clash as well.\r\r\n        \r\r\n            maxEventCount: The maximum number of clash objects.\r\r\n            Returns: An array of clash objects.\r\r\n        Search(meshA: Mesh, setB: IEnumerable[Mesh], distance: float, maxEventCount: int) -> Array[MeshClash]\r\r\n        Search(setA: IEnumerable[Mesh], setB: IEnumerable[Mesh], distance: float, maxEventCount: int) -> Array[MeshClash]\r\n        \"\"\"\r\n        pass\r\n\r\n    ClashPoint = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"If valid, then the sphere centered at ClashPoint of ClashRadius\r\r\n            distance interesects the clashing meshes.\r\r\n\r\r\nGet: ClashPoint(self: MeshClash) -> Point3d\r\r\n\r\r\n\"\"\"\r\n\r\n    ClashRadius = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the clash, or intersection, radius.\r\r\n\r\r\nGet: ClashRadius(self: MeshClash) -> float\r\r\n\r\r\n\"\"\"\r\n\r\n    MeshA = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the first mesh.\r\r\n\r\r\nGet: MeshA(self: MeshClash) -> Mesh\r\r\n\r\r\n\"\"\"\r\n\r\n    MeshB = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the second mesh.\r\r\n\r\r\nGet: MeshB(self: MeshClash) -> Mesh\r\r\n\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass PlaneCircleIntersection(Enum, IComparable, IFormattable, IConvertible):\r\n    \"\"\"\r\n    Represents all possible cases of a Plane|Circle intersection event.\r\r\n    \r\r\n    enum PlaneCircleIntersection, values: Coincident (4), None (0), Parallel (3), Secant (2), Tangent (1)\r\n    \"\"\"\r\n    def __eq__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__eq__(y) <==> x==yx.__eq__(y) <==> x==yx.__eq__(y) <==> x==y \"\"\"\r\n        pass\r\n\r\n    def __format__(self, *args): #cannot find CLR method\r\n        \"\"\" __format__(formattable: IFormattable, format: str) -> str \"\"\"\r\n        pass\r\n\r\n    def __ge__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __gt__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __le__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __lt__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __ne__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __reduce_ex__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __str__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    Coincident = None\r\n    None = None\r\n    Parallel = None\r\n    Secant = None\r\n    Tangent = None\r\n    value__ = None\r\n\r\n\r\nclass PlaneSphereIntersection(Enum, IComparable, IFormattable, IConvertible):\r\n    \"\"\"\r\n    Represents all possible cases of a Plane|Sphere intersection event.\r\r\n    \r\r\n    enum PlaneSphereIntersection, values: Circle (2), None (0), Point (1)\r\n    \"\"\"\r\n    def __eq__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__eq__(y) <==> x==yx.__eq__(y) <==> x==yx.__eq__(y) <==> x==y \"\"\"\r\n        pass\r\n\r\n    def __format__(self, *args): #cannot find CLR method\r\n        \"\"\" __format__(formattable: IFormattable, format: str) -> str \"\"\"\r\n        pass\r\n\r\n    def __ge__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __gt__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __le__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __lt__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __ne__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __reduce_ex__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __str__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    Circle = None\r\n    None = None\r\n    Point = None\r\n    value__ = None\r\n\r\n\r\nclass SphereSphereIntersection(Enum, IComparable, IFormattable, IConvertible):\r\n    \"\"\"\r\n    Represents all possible cases of a Sphere|Sphere intersection event.\r\r\n    \r\r\n    enum SphereSphereIntersection, values: Circle (2), None (0), Overlap (3), Point (1)\r\n    \"\"\"\r\n    def __eq__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__eq__(y) <==> x==yx.__eq__(y) <==> x==yx.__eq__(y) <==> x==y \"\"\"\r\n        pass\r\n\r\n    def __format__(self, *args): #cannot find CLR method\r\n        \"\"\" __format__(formattable: IFormattable, format: str) -> str \"\"\"\r\n        pass\r\n\r\n    def __ge__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __gt__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __le__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __lt__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __ne__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __reduce_ex__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    def __str__(self, *args): #cannot find CLR method\r\n        pass\r\n\r\n    Circle = None\r\n    None = None\r\n    Overlap = None\r\n    Point = None\r\n    value__ = None\r\n\r\n\r\n",
  "language": "python",
  "imports": [
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}