{
  "source_url": "https://github.com/aerenyldrm/game/blob/898a36be75f309c9330f5def7b57778df0e78b89/game_speculative_architecture.py",
  "repo": "aerenyldrm/game",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "game_speculative_architecture.py",
  "instruction": "Game speculative architecture",
  "code": "import random\nimport math\nimport Rhino\nimport Rhino.Input as ri\nimport Rhino.Geometry as rg\n\nclass GetObject: # class to get object\n    def getBox(): # static method\n        return ri.RhinoGet.GetBox()[1]\n\nclass FormFinding: # parent class for formfinding\n    def __init__(self): pass\n\n    def __transferToRhinoceros__(self, geometry_to_transfer): # helper method for \"__transferToRhinocerosRecursive__\"\n        try: Rhino.RhinoDoc.ActiveDoc.Objects.AddBox(geometry_to_transfer)\n        except:\n            try: Rhino.RhinoDoc.ActiveDoc.Objects.AddBrep(geometry_to_transfer)\n            except:\n                try: Rhino.RhinoDoc.ActiveDoc.Objects.AddMesh(geometry_to_transfer)\n                except: None\n\n    def __transferToRhinocerosRecursive__(self, geometry_to_transfer): # helper method for \"transferToRhinoceros\"\n        if not isinstance(geometry_to_transfer, (dict, list, tuple)):\n            return self.__transferToRhinoceros__(geometry_to_transfer)\n        for child in geometry_to_transfer:\n            self.__transferToRhinocerosRecursive__(child)\n\n    def transferToRhinoceros(self):\n        return self.__transferToRhinocerosRecursive__(self.procedureToProduceForm())\n    \nclass FormFinding1(FormFinding): # first child class for formfinding\n    def __init__(self, origin, number, superposition, intricacy, intensity, iteration, variety, scale, subdivision, rarification, transparency):\n        FormFinding.__init__(self)\n        self.origin = origin # required data type is rg.Point3d e.g. rg.Point3d(0, 0, 0)\n        self.number = number # required data type is integer e.g. 2\n        self.superposition = superposition # required data type is integer or float e.g. 2.3\n        self.intricacy = intricacy # required data type is tuple e.g. (5, 7)\n        self.intensity = intensity # required data type is tuple with integer e.g. (7, 11)\n        self.iteration = iteration # required data type is integer e.g. 2\n        self.variety = variety # required data type is integer e.g. 5\n        self.scale = scale # required data type is integer or float e.g. (0.70)\n        self.subdivision = subdivision # required data type is tuple with 3 integers e.g. (2, 3, 5)\n        self.rarification = rarification # required data type is float between 0 and 1 e.g. 0.19\n        self.transparency = transparency # required data type is float between 0 and 1 e.g. 0.81\n    \n    def __populate3d__(self, point_count, box_to_populate): # a helper method for \"procedureToProduceForm\" method, rewrite of an existing grasshopper function for rhinoceros\n        x_domain = abs(box_to_populate.X.Length) / 2\n        y_domain = abs(box_to_populate.Y.Length) / 2\n        z_domain = abs(box_to_populate.Z.Length) / 2\n        return [\n            rg.Point3d(\n                box_to_populate.Center.X + random.uniform(- x_domain, x_domain),\n                box_to_populate.Center.Y + random.uniform(- y_domain, y_domain),\n                box_to_populate.Center.Z + random.uniform(- z_domain, z_domain)\n            ) for counter in range(point_count)\n        ]\n    \n    def __fraction__(self, an_interval): return random.uniform(an_interval[0], an_interval[1])\n\n    def __level__(self, an_interval): return int(random.uniform(an_interval[0], an_interval[1])) # a frequently utilized helper method for \"procedureToProduceForm\" method\n    \n    def __flatten__(self, data_structure, empty_list): # a frequently utilized helper method for \"procedureToProduceForm\" method\n        if not isinstance(data_structure, (dict, list, tuple)):\n            empty_list.append(data_structure)\n            return empty_list\n        for child in data_structure:\n            self.__flatten__(child, empty_list)\n        return empty_list\n    \n    def __doesBoxContainsPoint__(self, box_for_test): # a frequently utilized helper method for \"procedureToProduceForm\" method\n        valid_point_for_translation = self.__populate3d__(1, box_for_test)[0]\n        if box_for_test.Contains(valid_point_for_translation, True):\n            return valid_point_for_translation\n        return self.__doesBoxContainsPoint__(box_for_test)\n    \n    def __duplicateBox__(self, box_to_duplicate): # a frequently utilized helper method for \"procedureToProduceForm\" method\n        return rg.Box(box_to_duplicate.Plane, box_to_duplicate.X, box_to_duplicate.Y, box_to_duplicate.Z)\n    \n    def __subdivideBox__(self, box_to_subdivide, subdivision_count_for_xyz: tuple, reduction_percentage): # a frequently utilized helper method for \"procedureToProduceForm\" method\n        x_vector_for_subdivide = rg.Vector3d.Subtract(rg.Vector3d(box_to_subdivide.GetCorners()[1]), rg.Vector3d(box_to_subdivide.GetCorners()[0])) / subdivision_count_for_xyz[0]\n        y_vector_for_subdivide = rg.Vector3d.Subtract(rg.Vector3d(box_to_subdivide.GetCorners()[3]), rg.Vector3d(box_to_subdivide.GetCorners()[0])) / subdivision_count_for_xyz[1]\n        z_vector_for_subdivide = rg.Vector3d.Subtract(rg.Vector3d(box_to_subdivide.GetCorners()[4]), rg.Vector3d(box_to_subdivide.GetCorners()[0])) / subdivision_count_for_xyz[2]\n        starting_point = box_to_subdivide.GetCorners()[0]\n        points_towards_x = []\n        for x_count in range(subdivision_count_for_xyz[0]):\n            if random.uniform(0, 1) >= reduction_percentage ** 3:\n                points_towards_x.append(starting_point)\n            starting_point += x_vector_for_subdivide\n        points_towards_xy = []\n        initial_vector_for_x = rg.Vector3d(0, 0, 0)\n        for y_count in range(subdivision_count_for_xyz[1]):\n            for count_x in range(len(points_towards_x)):\n                if random.uniform(0, 1) >= reduction_percentage ** 3:\n                    points_towards_xy.append(points_towards_x[count_x] + initial_vector_for_x)\n            initial_vector_for_x = initial_vector_for_x + y_vector_for_subdivide\n        points_towards_xyz = []\n        initial_vector_for_xy = rg.Vector3d(0, 0, 0)\n        for z_count in range(subdivision_count_for_xyz[2]):\n            for count_xy in range(len(points_towards_xy)):\n                if random.uniform(0, 1) >= reduction_percentage ** 3:\n                    points_towards_xyz.append(points_towards_xy[count_xy] + initial_vector_for_xy)\n            initial_vector_for_xy = initial_vector_for_xy + z_vector_for_subdivide\n        subdivided_boxes = []\n        for point_count in range(len(points_towards_xyz)):\n            plane_for_subdivided_boxes = rg.Plane(points_towards_xyz[point_count], x_vector_for_subdivide, y_vector_for_subdivide)\n            subdivided_boxes.append(rg.Box(plane_for_subdivided_boxes, rg.Interval(0, x_vector_for_subdivide.Length), rg.Interval(0, y_vector_for_subdivide.Length), \\\n            rg.Interval(0, z_vector_for_subdivide.Length)))\n        return subdivided_boxes\n    \n    def __boxMapping__(self, geometry_to_map, source_box, target_boxes): # a frequently utilized helper method for \"procedureToProduceForm\" method\n        mapped_mesh_geometries = []\n        source_box_x_size, source_box_y_size, source_box_z_size = abs(source_box.X.Length), abs(source_box.Y.Length), abs(source_box.Z.Length)\n        for box in target_boxes:\n            duplicated_mesh_geometry = geometry_to_map.DuplicateMesh()\n            box_x_size, box_y_size, box_z_size = abs(box.X.Length), abs(box.Y.Length), abs(box.Z.Length)\n            duplicated_mesh_geometry.Transform(rg.Transform.PlaneToPlane(source_box.Plane, box.Plane))\n            duplicated_mesh_geometry.Transform(rg.Transform.Scale(box.Plane, box_x_size / source_box_x_size, box_y_size / source_box_y_size, box_z_size / source_box_z_size))\n            mapped_mesh_geometries.append(duplicated_mesh_geometry)\n        return mapped_mesh_geometries\n    \n    def __joinMesh__(self, mesh_list): # a helper method for \"steelFrameUnit\" method\n        joint_mesh = rg.Mesh()\n        for mesh in mesh_list:\n            joint_mesh.Append(mesh)\n        return joint_mesh\n    \n    def steelFrameUnit(self): # the method to produce steel frame unit that repeats throughout entire architecture\n        unit_box = rg.Box(rg.Plane(rg.Point3d(0, 0, 0), rg.Vector3d.ZAxis), rg.Interval(0, 1), rg.Interval(0, 1), rg.Interval(0, 1))\n        reference_plane_for_scale = rg.Plane(unit_box.Center, rg.Vector3d.ZAxis)\n        brep_from_box = rg.Brep.CreateFromBox(unit_box)\n        duplicated_brep_1, duplicated_brep_2, duplicated_brep_3 = brep_from_box.DuplicateBrep(), brep_from_box.DuplicateBrep(), brep_from_box.DuplicateBrep()\n        duplicated_brep_1.Transform(rg.Transform.Scale(reference_plane_for_scale, 2, self.transparency, self.transparency))\n        duplicated_brep_2.Transform(rg.Transform.Scale(reference_plane_for_scale, self.transparency, 2, self.transparency))\n        duplicated_brep_3.Transform(rg.Transform.Scale(reference_plane_for_scale, self.transparency, self.transparency, 2))\n        breps_to_subtract = [duplicated_brep_1, duplicated_brep_2, duplicated_brep_3]\n        steel_frame_unit_brep = rg.Brep.CreateBooleanDifference([brep_from_box], breps_to_subtract, 0.001)[0]\n        return self.__joinMesh__(rg.Mesh.CreateFromBrep(steel_frame_unit_brep, rg.MeshingParameters(0, 0))), unit_box\n    \n    def creatingSubspaces(self, subspace_count, superposition_level, materialization_universe): # the method to produce abstract subspaces where form finding happens\n        subspaces = []\n        centroids_of_subspaces = self.__populate3d__(subspace_count, materialization_universe)\n        for center in centroids_of_subspaces:\n            reference_plane = rg.Plane(center, rg.Vector3d.ZAxis)\n            x_size = random.uniform(materialization_universe.X.Min, materialization_universe.X.Max) / subspace_count * superposition_level\n            y_size = random.uniform(materialization_universe.Y.Min, materialization_universe.Y.Max) / subspace_count * superposition_level\n            z_size = random.uniform(materialization_universe.Z.Min, materialization_universe.Z.Max) / subspace_count * superposition_level\n            subspaces.append(rg.Box(reference_plane, rg.Interval(- x_size, x_size), rg.Interval(- y_size, y_size), rg.Interval(- z_size, z_size)))\n        return subspaces\n    \n    def mainInfrastructure(self, intricacy_interval, abstract_subspaces): # the method to produce infrastructure that surrounds entire structure\n        empty_for_flat_subspaces = []\n        self.__flatten__(abstract_subspaces, empty_for_flat_subspaces)\n        interpolation_curves, infrastructure = [], []\n        for subspace in empty_for_flat_subspaces:\n            points_to_interpolate = self.__populate3d__(self.__level__(intricacy_interval), subspace)\n            interpolation_curve = rg.Curve.CreateInterpolatedCurve(points_to_interpolate, 3, rg.CurveKnotStyle(1))\n            interpolation_curves.append(interpolation_curve)\n            radius = min(abs(subspace.X.Length), abs(subspace.Y.Length), abs(subspace.Z.Length)) / 100\n            pipe_cap_mode, absolute_tolerance, angle_tolerance_radians = rg.PipeCapMode(1), 0.001, math.pi / 180\n            infrastructure.append(rg.Brep.CreatePipe(interpolation_curve, radius, False, pipe_cap_mode, True, absolute_tolerance, angle_tolerance_radians)[0])\n        return infrastructure, interpolation_curves, empty_for_flat_subspaces\n    \n    def essentialBlock(self, block_count, block_size_variation, block_scale, infrastructure_curves, subspaces): # the method to produce iterative structure\n        empty_for_flat_iterative_subspaces, blocks_2_times_nested, iterative_subspaces_2_times_nested, steel_frame_units_2_times_nested, lofted_platforms = [], [], [], [], []\n        for a_counter in range(len(infrastructure_curves)):\n            blocks_1_time_nested, iterative_subspaces_1_time_nested, steel_frame_units_1_time_nested, loft_points, intepolation_curves = [], [], [], [], []\n            curve_parameter = infrastructure_curves[a_counter].DivideByCount(self.__level__(block_count), True)\n            for other_counter in range(len(curve_parameter)):\n                perpendicular_plane = infrastructure_curves[a_counter].PerpendicularFrameAt(curve_parameter[other_counter])[1]\n                mean = (abs(subspaces[a_counter].X.Length) + abs(subspaces[a_counter].Y.Length) + abs(subspaces[a_counter].Z.Length)) / 3\n                coefficient_x, coefficient_y, coefficient_z = self.__fraction__((mean / block_size_variation, mean)), self.__fraction__((mean / block_size_variation, mean)), \\\n                self.__fraction__((mean / block_size_variation, mean))\n                x_boundary, y_boundary, z_boundary = coefficient_x * block_scale, coefficient_y * block_scale, coefficient_z * block_scale\n                x_interval, y_interval, z_interval = rg.Interval(- x_boundary, x_boundary), rg.Interval(- y_boundary, y_boundary), rg.Interval(- z_boundary, z_boundary)\n                box_to_subtract = rg.Box(perpendicular_plane, x_interval, y_interval, z_interval)\n                point_3d_to_access = self.__doesBoxContainsPoint__(box_to_subtract)\n                translation_vector = rg.Vector3d(point_3d_to_access.X - box_to_subtract.Center.X, point_3d_to_access.Y - box_to_subtract.Center.Y, \\\n                point_3d_to_access.Z - box_to_subtract.Center.Z)\n                brep_to_subtract = rg.Brep.CreateFromBox(box_to_subtract)\n                subtraction_brep = brep_to_subtract.DuplicateBrep()\n                subtraction_box = self.__duplicateBox__(box_to_subtract)\n                loft_p3d = self.__populate3d__(2, subtraction_box)\n                subtraction_box.Transform(rg.Transform.Translation(translation_vector))\n                subtraction_brep.Translate(translation_vector)\n                blocks_1_time_nested.append(rg.Brep.CreateBooleanDifference(brep_to_subtract, subtraction_brep, 0.001)[0])\n                iterative_subspaces_1_time_nested.append(box_to_subtract)\n                steel_frame_units_1_time_nested.append(subtraction_box)\n                loft_points.append(loft_p3d)\n            loft_points = zip(*loft_points)\n            for curvelist in loft_points:\n                intepolation_curves.append(rg.Curve.CreateInterpolatedCurve(curvelist, 3, rg.CurveKnotStyle(1)))\n            loft_surface = rg.Brep.CreateFromLoft(intepolation_curves, rg.Point3d.Unset, rg.Point3d.Unset, rg.LoftType(0), False)[0]\n            offset_distance = (abs(subspaces[a_counter].X.Length) + abs(subspaces[a_counter].Y.Length) + abs(subspaces[a_counter].Z.Length)) / 500\n            lofted_platforms.append(rg.Brep.CreateOffsetBrep(loft_surface, offset_distance, True, True, 0.001)[0][0])\n            blocks_2_times_nested.append(blocks_1_time_nested), iterative_subspaces_2_times_nested.append(iterative_subspaces_1_time_nested), \\\n            steel_frame_units_2_times_nested.append(steel_frame_units_1_time_nested)\n        return blocks_2_times_nested, self.__flatten__(iterative_subspaces_2_times_nested, empty_for_flat_iterative_subspaces), steel_frame_units_2_times_nested, lofted_platforms\n    \n    def constructSteelFrames(self, boxes_for_steel_frame_areas, subdivision_properties, reduction_ratio): # the method to produce steel frame units througout structure\n        flat_subdivided_boxes, subdivided_boxes_2_times_nested = [], []\n        for boxes in boxes_for_steel_frame_areas:\n            subdivided_boxes_1_time_nested = [self.__subdivideBox__(box, subdivision_properties, reduction_ratio) for box in boxes]\n            subdivided_boxes_2_times_nested.append(subdivided_boxes_1_time_nested)\n        self.__flatten__(subdivided_boxes_2_times_nested, flat_subdivided_boxes)\n        return self.__boxMapping__(self.steelFrameUnit()[0], self.steelFrameUnit()[1], flat_subdivided_boxes)\n\n    def procedureToProduceForm(self): # the method for essential procedure\n        materialization_universe = GetObject.getBox()\n        subspaces = self.creatingSubspaces(self.number, self.superposition, materialization_universe)\n        infrastructure_2_times_nested_out, blocks_2_times_nested_out, steel_frames_2_times_nested, platform_2_times_nested_out = [], [], [], []\n        for counter in range(self.iteration):\n            infrastructure_1_time_nested_out, blocks_1_time_nested_out, steel_frames_1_time_nested, platform_1_time_nested_out = [], [], [], []\n            infrastructure = self.mainInfrastructure(self.intricacy, subspaces)\n            infrastructure_1_time_nested_out.append(infrastructure[0])\n            blocks = self.essentialBlock(self.intensity, self.variety, self.scale, infrastructure[1], infrastructure[2])\n            blocks_1_time_nested_out.append(blocks[0])\n            steel_frames = self.constructSteelFrames(blocks[2], self.subdivision, self.rarification)\n            steel_frames_1_time_nested.append(steel_frames)\n            platform_1_time_nested_out.append(blocks[3])\n            infrastructure_2_times_nested_out.append(infrastructure_1_time_nested_out), blocks_2_times_nested_out.append(blocks_1_time_nested_out), \\\n            steel_frames_2_times_nested.append(steel_frames_1_time_nested), platform_2_times_nested_out.append(platform_1_time_nested_out)\n            subspaces = blocks[1]\n        return infrastructure_2_times_nested_out, blocks_2_times_nested_out, steel_frames_2_times_nested, platform_2_times_nested_out\n    \nif __name__ == \"__main__\":\n    origin = rg.Point3d.Origin\n    number = 1\n    superposition = 1\n    intricacy = (7, 19)\n    intensity = (7, 19)\n    iteration = 2\n    variety = 7\n    scale = 0.17\n    subdivision = (3, 4, 5)\n    rarification = 0.67\n    transparency = 0.90\n    game_of_architecture = FormFinding1(origin, number, superposition, intricacy, intensity, iteration, variety, scale, subdivision, rarification, transparency)\n    game_of_architecture.transferToRhinoceros()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}