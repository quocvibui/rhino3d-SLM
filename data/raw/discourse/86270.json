{
  "source_url": "https://discourse.mcneel.com/t/pointcloud-addrange/86270",
  "topic_id": 86270,
  "title": "PointCloud AddRange",
  "question": "Hello,\n\n\nI am trying to import a pointcloud with a .txt/pts format with x,y,z,r,b,g values using a python script. I am currently using “pc.Add” for each individual point, but I am finding this takes a lot of time for large files (~8 gb) and tends to crash. I am looking to optimize my script by using pc.AddRange instead to bunch and append the points. I am stuck with the formatting of pc.AddRange.\n\n\nI have read this post:\n\n\n\n\n\n\n\n\n\n\nPointCloud.AddRange does not accept list of Point3d\n \nRhino Developer\n\n\n\n\n\n    Hi \n@dale\n, \ni am building a list of 3d points and colors using multiprocessing. To keep those pairs together i add them to a stack of tuples like this: \nstack = Sytem.Collections.Concurrent.ConcurrentStack[tuple]()\n\nnow i want to add the points with colors to a pointcloud. In Rhino 5 i iterate over each stack item and add the points and colors one by one: \nfor pt, color in stack.ToArray(): \n    cloud.Add(pt, color)\n\nUnfortunately, this takes very long in V6 compared to V5, so i tried to use the n…\n  \n\n\n\n\nI am still unfamiliar with how the points needs to formatted. Are they supposed to be in an array format, I.E., “[ x, y, z, r, b, g]”? Thanks for any help.",
  "code_blocks": [
    {
      "code": "from Rhino.Geometry import Point3d as P3d, PointCloud\nfrom Rhino.Collections import Point3dList\nfrom System.Collections.Generic import List\nfrom System.Drawing import Color\nfrom scriptcontext import doc\nimport rhinoscriptsyntax as rs\n\ndef ImportXYZRGB():\n\t#File open\n\tfiltr = 'Text Files (*.txt)|*.txt| XYZ Color files (*.xyz)|*.xyz||'\n\tstrPath=rs.OpenFileName(\"XYZRGB file to import\", filtr)\n\tif not strPath: return\n\tfile=open(strPath)\n\tif not file: return\n\tnum = 0\n\tpoints, colors = [], []\n\t# Read 3D point and RGB color from each line with XYZRGB format: 1.2345 2.5682 3.9832 155 200 225\n\tfor line in file:\n\t\tnum += 1\n\t\tif (num % 1000) == 0: print 'Reading line {} K'.format(num/1000)\n\t\td = line.split()\n\t\tpt = P3d(float(d[0]),float(d[1]),float(d[2]))\n\t\tcolor = Color.FromArgb(int(d[3]),int(d[4]),int(d[5]))\n\t\tpoints.append(pt)\n\t\tcolors.append(color)\n\tfile.close()\n\t# Define lists for points and colors.\n\tp3dlst = Point3dList(points)\n\tcolors = List[Color](colors)\n\t# Add point cloud.\n\tcloud = PointCloud()\n\tcloud.AddRange(p3dlst, colors)\n\tprint 'Done reading {} lines from file and adding point cloud.'.format(num)\n\t# Add visible point cloud to document.\n\tobj = doc.Objects.AddPointCloud(cloud)\n\tdoc.Views.Redraw()\n\nif __name__ == \"__main__\":\n\tImportXYZRGB()",
      "language": "python",
      "author": "Terry_Chappell",
      "post_number": 6,
      "is_solution": false
    },
    {
      "code": "from Rhino.Geometry import Point3d as P3d, PointCloud\nfrom Rhino.Collections import Point3dList\nfrom System.Collections.Generic import List\nfrom System.Drawing import Color\nfrom scriptcontext import doc\nimport rhinoscriptsyntax as rs\nfrom time import time\n\ndef ImportXYZRGB():\n\t#File open\n\tfiltr = 'Text Files (*.txt)|*.txt| XYZ Color files (*.xyz)|*.xyz||'\n\tstrPath = rs.OpenFileName(\"XYZRGB file to import\", filtr)\n\tif not strPath: return\n\ttstart = time()\n\ttimea = time()\n\tfile = open(strPath)\n\tif not file: return\n\tpoints, colors = [], []\n\t# Read 3D point and RGB color from each line with XYZRGB format: 1.2345 2.5682 3.9832 155 200 225\n\tfor line in file:\n\t\td = line.split()\n\t\tpt = P3d(float(d[0]),float(d[1]),float(d[2]))\n\t\tcolor = Color.FromArgb(int(d[3]),int(d[4]),int(d[5]))\n\t\tpoints.append(pt)\n\t\tcolors.append(color)\n\tfile.close()\n\ttimeb = time()\n\tprint '    Time to read {0:,} lines, split into pieces and create points and colors lists = {1:.4f} sec'.format(len(points), timeb - timea)\n\t# Define lists for points and colors.\n\ttimea = time()\n\tp3dlst = Point3dList(points)\n\tcolors = List[Color](colors)\n\ttimeb = time()\n\tprint '    Time to create Point3dList and List[Color] = {0:.4f} sec'.format(timeb - timea)\n\ttimea = time()\n\t# Add point cloud.\n\tcloud = PointCloud()\n\tcloud.AddRange(p3dlst, colors)\n\ttimeb = time()\n\tprint '    Time to AddRange to cloud = {0:.4f} sec'.format(timeb - timea)\n\t# Add visible point cloud to document.\n\ttimea = time()\n\t# Add visible point cloud to document.\n\tobj = doc.Objects.AddPointCloud(cloud)\n\ttimeb = time()\n\tprint '    Time to add point cloud to document = {0:.4f} sec'.format(timeb - timea)\n\tdoc.Views.Redraw()\n\tprint 'Read {0} lines from file and added point cloud in {1:.4f} sec.'.format(len(points), time() - tstart)\n\nif __name__ == \"__main__\":\n\tImportXYZRGB()",
      "language": "python",
      "author": "Terry_Chappell",
      "post_number": 12,
      "is_solution": false
    },
    {
      "code": "from Rhino.Geometry import Point3d as P3d, PointCloud\nfrom Rhino.Collections import Point3dList\nfrom System.Collections.Generic import List\nfrom System.Drawing import Color\nfrom scriptcontext import doc\nimport rhinoscriptsyntax as rs\nimport time\nfrom itertools import islice\nimport System.Threading.Tasks as tasks\nfrom System.Collections.Concurrent import ConcurrentBag\nimport clr\n\ndef lines_to_pc(slices):\n\t# slices are a bunch of file lines\n\tpc = PointCloud()\n\tpoints = Point3dList()  # going straight to these .net structures\n\tcolors = List[Color]()\n\tfor slice in slices:\n\t\tsplit = slice.strip().split(' ')  # slightly faster than considering all whitespace\n\t\tpoints.Add(float(split[0]), float(split[1]), float(split[2]))\n\t\tcolors.Add(Color.FromArgb(int(split[3]), int(split[4]), int(split[5])))\n\tpc.AddRange(points, colors)\n\treturn pc\n\t\t\ndef with_islice(file_path):\n\tpc = PointCloud()  # master point cloud\n\ttotal = 0  # tracking line count\n\tf = open(file_path)\n\twhile True:\n\t\tn_lines = list(islice(f, 1000))  # neat trick from stack overflow\n\t\tif not n_lines:\n\t\t\tbreak\n\t\ttotal += len(n_lines)\n\t\tsub_cloud = lines_to_pc(n_lines)\n\t\tpc.Merge(sub_cloud)  # merge time is insignificant\n\tf.close()\n\tprint(total)\n\tdoc.Objects.AddPointCloud(pc)",
      "language": "python",
      "author": "nathancoatney",
      "post_number": 19,
      "is_solution": false
    },
    {
      "code": "def islice_bag(file_path):\n\tf = open(file_path)\n\tpc_bag = ConcurrentBag[PointCloud]()  # to store clouds from //foreach\n\tslices = []  # need to hold slices of point lines in iterable for //foreach\n\twhile True:\n\t\tn_lines = list(islice(f, 1000))\n\t\tif not n_lines:\n\t\t\tbreak\n\t\tslices.append(n_lines)\n\tf.close()\n\t\n\tdef slices_to_pc(slices):\n\t\t# function for the //foreach\n\t\t# slices are a bunch of file lines\n\t\t# not sure why this doesn't scale...maybe local variables aren't safe?\n\t\tpc = PointCloud()\n\t\tpoints = Point3dList()\n\t\tcolors = List[Color]()\n\t\tfor slice in slices:\n\t\t\tsplit = slice.strip().split(' ')\n\t\t\tpoints.Add(float(split[0]), float(split[1]), float(split[2]))\n\t\t\tcolors.Add(Color.FromArgb(int(split[3]), int(split[4]), int(split[5])))\n\t\tpc.AddRange(points, colors)\n\t\tpc_bag.Add(pc)\n\t\t\n\ttask_option = tasks.ParallelOptions()\n\ttask_option.MaxDegreeOfParallelism = 2  # is best on my machine, but have 32 so something isn't very //\n\ttasks.Parallel.ForEach(slices, task_option, slices_to_pc)\n\t\n\tprint(pc_bag.Count)  # tracking\n\ttotal_pc = PointCloud()\n\tfor pc in pc_bag:\n\t\ttotal_pc.Merge(pc)\n\tdoc.Objects.AddPointCloud(total_pc)",
      "language": "python",
      "author": "nathancoatney",
      "post_number": 19,
      "is_solution": false
    },
    {
      "code": "from Rhino.Geometry import Point3d as P3d, PointCloud\nfrom Rhino.Collections import Point3dList\nfrom System.Collections.Generic import List\nfrom System.Drawing import Color\nfrom scriptcontext import doc\nimport rhinoscriptsyntax as rs\nfrom time import time\n\ndef ImportXYZRGB():\n\t#File open\n\tfiltr = 'Text Files (*.txt)|*.txt| XYZ Color files (*.xyz)|*.xyz||'\n\tstrPath = rs.OpenFileName(\"XYZRGB file to import\", filtr)\n\tif not strPath: return\n\ttstart = time()\n\ttimea = time()\n\tfile = open(strPath)\n\tif not file: return\n\tpoints, colors = [], []\n\t# Read 3D point and RGB color from each line with XYZRGB format: 1.2345 2.5682 3.9832 155 200 225\n\tfor line in file:\n\t\td = line.strip().split(' ')\n\t\tpt = P3d(float(d[0]),float(d[1]),float(d[2]))\n\t\tcolor = Color.FromArgb(int(d[3]),int(d[4]),int(d[5]))\n\t\tpoints.append(pt)\n\t\tcolors.append(color)\n\tfile.close()\n\ttimeb = time()\n\tprint '    Time to read {0:,} lines, split into pieces and create points and colors lists = {1:.4f} sec'.format(len(points), timeb - timea)\n\t# If too many points to load into Point3dList, break up into groups.\n\tmax_points = 60000000 # 60M is safe. 72M fails.\n\tlpts = len(points)\n\tif lpts > max_points:\n\t\ttimea = time()\n\t\t# Find number of groups.\n\t\tgroups = lpts // max_points + 1\n\t\t# Find number in each group.\n\t\tnpts = lpts // groups\n\t\t# Find any remainder.\n\t\trpts = lpts % groups\n\t\t# Make array of points.\n\t\tistart = 0; iend = npts\n\t\tgpts, gcol = [],[]\n\t\t# Collect points and colors for all but last group.\n\t\tfor i in range(groups - 1):\n\t\t\tgpts.append(points[istart:iend])\n\t\t\tgcol.append(colors[istart:iend])\n\t\t\tistart += npts \n\t\t\tiend += npts\n\t\t# Add last group with remainder.\n\t\tgpts.append(points[istart:iend+rpts])\n\t\tgcol.append(colors[istart:iend+rpts])\n\t\ttimeb = time()\n\t\tprint '    Time to divide {0:,} points into {1} groups = {2:.4f} sec'.format(len(points), groups, timeb - timea)\n\telse:\n\t\tgpts = [points]\n\t\tgcol = [colors]\n\t\tgroups = 1\n\t# Define lists for points and colors.\n\ttimea = time()\n\tp3dlsts, colorss = [],[]\n\tfor i in range(groups):\n\t\tp3dlsts.append(Point3dList(gpts[i]))\n\t\tcolorss.append(List[Color](gcol[i]))\n\ttimeb = time()\n\tprint '    Time to create Point3dList and List[Color] = {0:.4f} sec'.format(timeb - timea)\n\ttimea = time()\n\t# Add points to point cloud.\n\tcloud = PointCloud()\n\tfor i in range(groups):\n\t\tcloud.AddRange(p3dlsts[i], colorss[i])\n\ttimeb = time()\n\tprint '    Time to AddRange to cloud = {0:.4f} sec'.format(timeb - timea)\n\t# Add visible point cloud to document.\n\ttimea = time()\n\tobj = doc.Objects.AddPointCloud(cloud)\n\ttimeb = time()\n\tprint '    Time to add point cloud to document = {0:.4f} sec'.format(timeb - timea)\n\tdoc.Views.Redraw()\n\tprint 'Read {0} lines from file and added point cloud in {1:.4f} sec.'.format(len(points), time() - tstart)\n\nif __name__ == \"__main__\":\n\tImportXYZRGB()",
      "language": "python",
      "author": "Terry_Chappell",
      "post_number": 20,
      "is_solution": false
    },
    {
      "code": "from Rhino.Geometry import PointCloud\nfrom Rhino.Collections import Point3dList\nfrom System.Collections.Generic import List\nfrom System.Drawing import Color\nfrom scriptcontext import doc\nimport rhinoscriptsyntax as rs\nfrom time import time\nfrom itertools import islice\n\ndef ImportXYZRGB():\n\t#File open\n\tfiltr = 'Text Files (*.txt)|*.txt| XYZ Color files (*.xyz)|*.xyz||'\n\tstrPath = rs.OpenFileName(\"XYZRGB file to import\", filtr)\n\tif not strPath: return\n\ttimea = time()\n\tfile = open(strPath)\n\tif not file: return\n\t# Create point cloud object.\n\tcloud = PointCloud()\n\t# Keep count of lines read.\n\ttotal = 0\n\t# Format of 3D point and RGB color in each line is XYZRGB: 1.2345 2.5682 3.9832 155 200 225\n\twhile True:\n\t\t# Get group of lines to process.\n\t\tn_lines = list(islice(file, 1000))  # neat trick from stack overflow brought by nathancoatney of Rhino Forum.\n\t\tif not n_lines: break\n\t\ttotal += len(n_lines)\n\t\t# Define .NET structures for holding points and colors.\n\t\tpoints = Point3dList()\n\t\tcolors = List[Color]()\n\t\t# Load points and colors for point cloud.\n\t\tfor line in n_lines:\n\t\t\td = line.strip().split(' ')\n\t\t\tpoints.Add(float(d[0]),float(d[1]),float(d[2]))\n\t\t\tcolors.Add(Color.FromArgb(int(d[3]),int(d[4]),int(d[5])))\n\t\t# Add points & colors to point cloud.\n\t\tcloud.AddRange(points, colors)\n\tfile.close()\n\t# Add visible point cloud to document.\n\tobj = doc.Objects.AddPointCloud(cloud)\n\tdoc.Views.Redraw()\n\ttimeb = time()\n\tprint 'Read {0} lines from file and added point cloud in {1:.4f} sec.'.format(total, timeb - timea)\n\nif __name__ == \"__main__\":\n\tImportXYZRGB()",
      "language": "python",
      "author": "Terry_Chappell",
      "post_number": 22,
      "is_solution": false
    },
    {
      "code": "from Rhino.Geometry import PointCloud\nfrom Rhino.Collections import Point3dList\nfrom System.Collections.Generic import List\nfrom System.Drawing import Color\nfrom scriptcontext import doc\nimport rhinoscriptsyntax as rs\nfrom time import time\nfrom itertools import islice\n\ndef ImportXYZRGB():\n\t# Format of 3D point and RGB color in each line is XYZRGB: 1.2345 2.5682 3.9832 155 200 225\n\tfiltr = 'Text Files (*.txt)|*.txt| XYZ Color files (*.xyz)|*.xyz||'\n\tstrPath = rs.OpenFileName('XYZRGB file to import', filtr)\n\tif not strPath: return\n\ttimea = time()\n\tfile = open(strPath)\n\tif not file: return\n\ttotal = 0\n\tcloud = PointCloud()\n\twhile True:\n\t\t# Get group of 1000 lines to process.\n\t\tn_lines = list(islice(file, 1000))  # neat trick from stack overflow brought by nathancoatney of Rhino Forum.\n\t\tif not n_lines: break\n\t\ttotal += len(n_lines)\n\t\t# Define Rhino structure for holding points.\n\t\tpoints = Point3dList()\n\t\t# Create list for holding 32-bit representation of RGB color.\n\t\ttcolors = []\n\t\t# Load points and colors for point cloud.\n\t\tfor line in n_lines:\n\t\t\td1,d2,d3,d4,d5,d6 = map(float,line.strip().split(' '))\n\t\t\tpoints.Add(d1,d2,d3)\n\t\t\t# Convert R,G,B color to 32-bit color.\n\t\t\ttcolors.append(65536.*d4 + 256.*d5 + d6)\n\t\t# Convert 32-bit color to .NET Color.\n\t\tcolors = List[Color](map(Color.FromArgb,tcolors))\n\t\t# Add points & colors to point cloud.\n\t\tcloud.AddRange(points, colors)\n\tfile.close()\n\t# Add visible point cloud to document.\n\tobj = doc.Objects.AddPointCloud(cloud)\n\tdoc.Views.Redraw()\n\ttimeb = time()\n\tprint 'Read {0} lines from file and added point cloud in {1:.4f} sec.'.format(total, timeb - timea)\n\nif __name__ == \"__main__\":\n\tImportXYZRGB()",
      "language": "python",
      "author": "Terry_Chappell",
      "post_number": 25,
      "is_solution": false
    },
    {
      "code": "# If you want to use DLL for 5X faster cloud import, set its path in the next line.\ndll_name = r'C:\\Users\\Terry\\source\\repos\\ReadCloud\\x64\\Release\\ReadCloud.dll'\n\"\"\"\nThis Python script reads a colored point-cloud file with XYZRGB format and creates a colored point-cloud in Rhino 6 or 7 WIP.\nIt uses cloud.AddRange to provide an approximately 3X speedup over cloud.Add and it overcomes the 70M point limit of the\nRhino Point3dList structure used in AddRange by processing small groups of 2000 points at a time. For 5X faster execution time,\nit calls a DLL which reads a 100 KB block at a time and then parses the block into lines and the lines into the X,Y,Z coordinates\nand R,G,B color of a point. The 100KB block fits entirely within the L1-cache of the processer resulting in higher performance.\nThe coordinates and R,G,B colors, after conversion to 32-bit format, are passed back to Python where they are converted to\nPoint3d and .NET Color and then added to the point cloud using AddRange.\nThis script is 5X faster than an all Python version and 15X faster than Rhino's Import command. For example, it reads\na 4GB file and creates a 73.7M point cloud in 51 sec vs 256 sec (Python only) vs 790 sec or 13:10 min (Rhino Import).\nThus the script imports a colored point cloud at about 1.4M points/sec.\nBy Terry Chappell 7/30/2019.\n\"\"\"\nfrom Rhino.Geometry import PointCloud\nfrom Rhino.Collections import Point3dList\nfrom System.Collections.Generic import List\nfrom System.Drawing import Color\nfrom scriptcontext import doc\nimport rhinoscriptsyntax as rs\nfrom time import time\nimport os\nfrom ctypes import c_longlong, cdll as c_cdll, c_char, c_long, c_int, c_double, byref as c_byref, c_wchar_p\n\n# This is used when DLL is available.\ndef ImportXYZRGB_DLL():\n\t# Format of 3D point and RGB color in each line is XYZRGB: 1.2345 2.5682 3.9832 155 200 225\n\tfiltr = 'Text Files (*.txt)|*.txt| XYZ Color files (*.xyz)|*.xyz||'\n\tstrPath = rs.OpenFileName('XYZRGB file to import', filtr)\n\tif not strPath: return\n\ttimea = time()\n\t# Zero number of points read.\n\ttotal = 0\n\t# Get size of file in bytes.\n\tfile_size = os.path.getsize(strPath)\n\t# Read 100K bytes at a time.  This nicely fits in the L1 cache and results in few misses for best performance overall.\n\tblock_size = 100000\n\t# Estimate the number of points that are contained in the 100K bytes block.\n\test_points = block_size // 30 # 3 FP numbers + 3 Int numbers.\n\t# Set dimension of points and colors arrays based upon estimated number of points.\n\tnxyz = int(est_points)\n\tncolors = int(est_points)\n\tprint 'Reading file {0} with {1:,} bytes in {2:,}KB blocks and converting to point cloud . . .'.format(strPath, file_size, block_size // 1000)\n\t# Define c-types variables for interfacing to DLL.\n\tcx = (c_double * (nxyz))() # X-coordinant of point in cloud.\n\tcy = (c_double * (nxyz))() # Y-coordinant\n\tcz = (c_double * (nxyz))() # Z-coordinant\n\tccolors = (c_long * (ncolors))() # Color for each point\n\tcnum_points = (c_int * (4))() # Number of points read + room for 3 other values for debug.\n\tcmemblock = (c_char * (block_size))() # Working area for reading file.\n\tcoffset = (c_longlong * (1))(0) # Offset into file as each block is read.\n\t#coffset = c_longlong(0) # Offset into file as each block is read.\n\tcfile_length = (c_longlong * (1))(file_size) # File length for detecting when last block read occurs.\n\t# Initialize cloud for holding results of read.\n\tcloud = PointCloud()\n\toffset = 0\n\twhile offset < file_size:\n\t\t# Call DLL to open file, read block, parse block, return lists of points and colors.\n\t\tsoReadCloud.read_cloud(strPath, c_byref(cx),c_byref(cy),c_byref(cz), c_byref(ccolors), c_byref(cnum_points), c_byref(cmemblock), block_size, c_byref(coffset), c_byref(cfile_length))\n\t\t# Get number of points read from block.\n\t\tnum_points = cnum_points[0]\n\t\toffset = coffset[0]\n\t\t# Sum total number of points read.\n\t\ttotal += num_points\n\t\t# Create list for holding point3d.\n\t\tpoints = Point3dList()\n\t\t# Load points using coordinates returned by DLL.\n\t\tfor i in xrange(num_points): points.Add(cx[i],cy[i],cz[i])\n\t\t# Get active colors from ctypes colors list.\n\t\tcolors = ccolors[:num_points]\n\t\t# Convert 32-bit colors to .NET Colors.\n\t\tcolors = List[Color](map(Color.FromArgb,colors))\n\t\t# Add points & colors to point cloud.\n\t\tcloud.AddRange(points, colors)\n\t# Add visible point cloud to document.\n\tobj = doc.Objects.AddPointCloud(cloud)\n\tdoc.Views.Redraw()\n\ttimeb = time()\n\tprint 'Read {0:,} lines and added point cloud in {1:.4f} sec.'.format(total, timeb - timea)\n\n# This is used when DLL was not found.\ndef ImportXYZRGB_Python():\n\t# Select point cloud to import.\n\tfiltr = 'Text Files (*.txt)|*.txt| XYZ Color files (*.xyz)|*.xyz||'\n\t# Format of 3D point and RGB color in each line must be XYZRGB like this: 1.2345 2.5682 3.9832 155 200 225\n\tstrPath = rs.OpenFileName('XYZRGB file to import', filtr)\n\tif not strPath: return\n\ttimea = time()\n\t# Zero counter for number of points read.\n\ttotal = 0\n\t# Use 100K block size which easily fit in L1-cache for better performance.\n\tblock_size = 100000\n\t# Zero counter for number of bytes read so use in detecting end of file.\n\tbytes_read = 0\n\t# Get file size in bytes so end of file can be detected.\n\tfile_size = os.path.getsize(strPath)\n\t# Zero offset for aligning to line boundary.\n\toffset = 0\n\t# Reset done flag.\n\tdone = False\n\tprint 'Reading file {0} with {1:,} bytes in {2:,}KB blocks and converting to point cloud . . .'.format(strPath, file_size, block_size // 1000)\n\t# Initialize point cloud.\n\tcloud = PointCloud()\n\t# Read file, process lines into points and load points into cloud.\n\t# Binary read is 3X faster than reading lines.\n\twith open(strPath, 'rb',0) as file:\n\t\twhile not done:\n\t\t\tfile.seek(offset, 1) # Offset is relative to current position.\n\t\t\tblock = file.read(block_size)\n\t\t\tif not block: break\n\t\t\t# Split block into lines.\n\t\t\tlines = block.splitlines()\n\t\t\t# Remove last line as it is likely incomplete.\n\t\t\tlline = lines.pop()\n\t\t\t# Back up file pointer by length of last line.\n\t\t\toffset = -len(lline)\n\t\t\t# Sum number of bytes read so end can be detected.\n\t\t\tbytes_read += block_size + offset\n\t\t\t# If this is the last group, add back last line.\n\t\t\tif bytes_read >= file_size: lines.append(lline); done = True\n\t\t\t# Count number of points read.\n\t\t\ttotal += len(lines)\n\t\t\t# Create lists for holding point3d and 32-bit colors.\n\t\t\tpoints = Point3dList()\n\t\t\ttcolors = []\n\t\t\t# Parse each line to extract points and colors.\n\t\t\tfor line in lines:\n\t\t\t\t# Parse line into 6 float values.\n\t\t\t\td1,d2,d3,d4,d5,d6 = map(float,line.strip().split(' '))\n\t\t\t\t# Add X,Y,Z coordinates to Point3dList.\n\t\t\t\tpoints.Add(d1,d2,d3)\n\t\t\t\t# Convert R,G,B color to 32-bit color for faster Color.FromArgb.\n\t\t\t\ttcolors.append(65536.*d4 + 256.*d5 + d6)\n\t\t\t# Convert 32-bit colors to .NET Colors.\n\t\t\tcolors = List[Color](map(Color.FromArgb,tcolors))\n\t\t\t# Add points & colors to point cloud.\n\t\t\tcloud.AddRange(points, colors)\n\t# Add visible point cloud to document.\n\tobj = doc.Objects.AddPointCloud(cloud)\n\tdoc.Views.Redraw()\n\ttimeb = time()\n\tprint 'Read {0:,} lines and added point cloud in {1:.4f} sec.'.format(total, timeb - timea)\n\nif __name__ == \"__main__\":\n\t# Try to get DLL.\n\ttry:\n\t\tsoReadCloud = c_cdll.LoadLibrary(dll_name)\n\t\tuse_DLL = True\n\t# Use Python code when DLL not found.\n\texcept:\n\t\tprint 'WARNING: Did not find DLL at {}. A 5X slower all Python version will be used.'.format(dll_name)\n\t\tuse_DLL = False\n\tif use_DLL: ImportXYZRGB_DLL() \n\telse: ImportXYZRGB_Python()",
      "language": "python",
      "author": "Terry_Chappell",
      "post_number": 26,
      "is_solution": false
    },
    {
      "code": "// ReadCloud.cpp : Defines the exported functions for the DLL application.\n//\n\n#include \"stdafx.h\"\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>     // for _countof\n\nusing namespace std;\n\n#define DLLEXPORT extern \"C\" __declspec(dllexport)\n#define UCLASS()\n#define GENERATED_BODY()\n#define UFUNCTION()\n\n\n// This function parses a line into 3 double and 3 int. It is used in place of strtod: strtod(line, &pEnd); d2 = strtod(pEnd, &pEnd); d3 = strtod(pEnd, &pEnd);\nvoid block2xyzc(const char *p, int &i, int &loc, long long offset, long long file_length, double *x, double *y, double *z, long *colors) {\n\tstatic double pow10[17] = { 1., 10., 100., 1000., 10000., 100000., 1000000., 10000000., 100000000., 1000000000.,\n\t\t10000000000., 100000000000., 1000000000000., 10000000000000., 100000000000000., 1000000000000000., 10000000000000000. };\n\t// Define variables for 3 doubles.\n\tdouble r1, r2, r3;\n\t// Define variables for 3 integers and number of bytes read from block.\n\tint r4, r5, r6, bytes_read = 0;\n\t// Define variable for saving pointer location at start of parsing block.\n\tconst char *p_start;\n\t// Initialize flags for controlling continuing parsing, storing data and returning after last line read.\n\tbool next = true, second = false, last = false;\n\t// Parse each line of block.\n\twhile (next) {\n\t\t// If storage is enabled, save values from prior line.\n\t\tif (second) {\n\t\t\t// Store XYZ of prior line.\n\t\t\tx[i] = r1; y[i] = r2; z[i] = r3;\n\t\t\t// Store 32-bit color of prior line.\n\t\t\tcolors[i++] = (((r4 << 8) + r5) << 8) + r6;\n\t\t}\n\t\t// Toggle second to true to start storing results above.\n\t\tsecond = true;\n\t\t// If last line read, return.\n\t\tif (last) { return; }\n\t\t// Get pointer location at start.\n\t\tp_start = p;\n\t\t// Zero count of line length.\n\t\tloc = 0;\n\t\t// Zero 3 double and 3 integer values at start of parsing.\n\t\tr1 = 0.0, r2 = 0.0, r3 = 0.0; r4 = 0, r5 = 0, r6 = 0;\n\t\t// Zero variables used for adding digits after decimal point.\n\t\tdouble f = 0.0;\tint n = 0;\n\t\t// Reset negative flag at start.\n\t\tbool neg = false;\n\t\t// Skip any white space and convert first double at start of line.\n\t\twhile (*p == ' ') { ++p; }\n\t\t// Get possible minius sign at start.\n\t\tif (*p == '-') { neg = true; ++p;  }\n\t\t// Convert digits before decimal points.\n\t\twhile (*p >= '0' && *p <= '9') { r1 = (r1*10.0) + (*p - '0'); ++p; }\n\t\t// Get digits after decimal point.\n\t\tif (*p == '.') {\n\t\t\t// Zero digits after decimal point and power of ten and advance pointer to first digit.\n\t\t\tf = 0.0; n = 0; ++p;\n\t\t\t// Convert digits after decimal point.\n\t\t\twhile (*p >= '0' && *p <= '9') { f = (f*10.0) + (*p - '0');\t++p; ++n; }\n\t\t\t// Scale digits by power of 10 to make fraction.\n\t\t\tr1 += f / pow10[n];\n\t\t}\n\t\t// Create negative result if minus sign was present and reset minus flag.\n\t\tif (neg) { r1 = -r1; neg = false; }\n\t\t// Skip white space and convert second double.\n\t\twhile (*p == ' ') { ++p; }\n\t\tif (*p == '-') { neg = true; ++p; }\n\t\twhile (*p >= '0' && *p <= '9') { r2 = (r2*10.0) + (*p - '0'); ++p; }\n\t\tif (*p == '.') {\n\t\t\tf = 0.0; n = 0; ++p;\n\t\t\twhile (*p >= '0' && *p <= '9') { f = (f*10.0) + (*p - '0');\t++p; ++n; }\n\t\t\tr2 += f / pow10[n];\n\t\t}\n\t\tif (neg) { r2 = -r2; neg = false; }\n\t\t// Skip white space and convert third double.\n\t\twhile (*p == ' ') { ++p; }\n\t\tif (*p == '-') { neg = true; ++p; }\n\t\twhile (*p >= '0' && *p <= '9') { r3 = (r3*10.0) + (*p - '0'); ++p; }\n\t\tif (*p == '.') {\n\t\t\tf = 0.0; n = 0; ++p;\n\t\t\twhile (*p >= '0' && *p <= '9') { f = (f*10.0) + (*p - '0');\t++p; ++n; }\n\t\t\tr3 += f / pow10[n];\n\t\t}\n\t\tif (neg) { r3 = -r3; }\n\t\t// Skip white space and convert 3 integers towards end of line.\n\t\twhile (*p == ' ') { ++p; }\n\t\twhile (*p >= '0' && *p <= '9') { r4 = (r4 * 10) + (*p - '0'); ++p;}\n\t\twhile (*p == ' ') { ++p; }\n\t\twhile (*p >= '0' && *p <= '9') { r5 = (r5 * 10) + (*p - '0'); ++p;}\n\t\twhile (*p == ' ') { ++p; }\n\t\twhile (*p >= '0' && *p <= '9') { r6 = (r6 * 10) + (*p - '0'); ++p;}\n\t\t// Find length of line for partial-line case with no \\0 or \\n.\n\t\tloc = p - p_start;\n\t\t// Skip \\0 at end of line.\n\t\t++p;\n\t\t// If new-line character found here, continue parsing lines.\n\t\tif (*p == '\\n') { next = true; ++p; } else { next = false; }\n\t\t// Sum bytes read including \\0\\n at end.\n\t\tbytes_read += loc + 2;\n\t\t// When end-of-file reached, set last = true in order to return after storing last line of information.\n\t\tif ((offset + bytes_read + 2) > file_length) { last = true; }\n\t}\n}\n\nDLLEXPORT void read_cloud(wchar_t *file_name, double *x, double *y, double *z, long *colors,\n\tint *num_points, char *memblock, int block_size, long long *offset, long long *file_length)\n{\n\t// Set file_size as streampos type.\n\tstreampos size_of_block = block_size;\n\t// Set file offset to start of next block.\n\tstreampos file_offset = offset[0];\n\t// Create index for number of points.\n\tint i = 0;\n\t// Define integer variables for backing up offset to next memblock to align with line boundary,\n\tint loc = 0;\n\t//\n\t// Open file for binary read.\n\t//\n\tifstream in_file(file_name, ios::binary | ios::in);\n\t// Import point cloud.\n\tif (in_file.is_open()) {\n\t\t// Move file pointer to start of block.\n\t\tin_file.seekg(file_offset);\n\t\t// Read memblock of data into memory.\n\t\tin_file.read(memblock, size_of_block);\n\t\t// Parse memblock into X,Y,Z coordinates and 32-bit colors.\n\t\tblock2xyzc(memblock, i, loc, offset[0], file_length[0], x, y, z, colors);\n\t\t// Offset next read by block_size minus length of partial line so read will be aligned to start of line.\n\t\toffset[0] += block_size - loc;\n\t\t// Return number of points read.\n\t\tnum_points[0] = i;\n\t}\n}",
      "language": "csharp",
      "author": "Terry_Chappell",
      "post_number": 26,
      "is_solution": false
    },
    {
      "code": "##################################\n### Read TXT create pointcloud ###\n##################################\nimport System\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino\nimport time\nfrom System.Drawing import Color\n\n#import csv\nimport clr\n\nclr.AddReference(\"Microsoft.VisualBasic\")\n\nfrom Microsoft.VisualBasic.FileIO import TextFieldParser\n\n\ntol = sc.doc.ModelAbsoluteTolerance\n\ndef TST():\n    filtr = 'Text Files (*.txt)|*.txt| XYZ Color files (*.xyz)|*.xyz||'\n    strPath = rs.OpenFileName('XYZRGB file to import', filtr)\n    if not strPath: return\n    \n    ts = time.time()\n    cloud = Rhino.Geometry.PointCloud()\n    reader = TextFieldParser(strPath)\n    reader.SetDelimiters(\",\")\n    #fields = reader.ReadFields()\n    point_list = []\n    \n    color_list = []\n    while reader.EndOfData == False:\n        try:\n            fline = reader.ReadLine()\n            row = fline.split(\",\")\n            #point_list.append(Rhino.Geometry.Point3d(float(row[0]),float(row[1]),float(row[2])))\n            # Convert R,G,B color to 32-bit color.\n            #color_list.append(65536.*int(row[3]) + 256.*int(row[4]) + int(row[5]))\n            \n            #cloud_item = Rhino.Geometry.PointCloudItem()\n            cloud_item = Rhino.Geometry.PointCloud.AppendNew(cloud)\n            cloud_item.Location = Rhino.Geometry.Point3d(float(row[0]),float(row[1]),float(row[2]))\n            cloud_item.Color = Color.FromArgb(int(row[3]),int(row[4]),int(row[5]))\n            \n            \n            \n            #cloud.Add(Rhino.Geometry.Point3d(float(row[0]),float(row[1]),float(row[2])),Color.FromArgb(int(row[3]),int(row[4]),int(row[5])))\n            #print fline\n        except:\n            break\n    # Convert 32-bit color to .NET Color.\n    #colors = System.Collections.Generic.List[Color](map(Color.FromArgb,color_list))#map(Color.FromArgb,color_list)\n    \n    #cloud.AddRange(point_list,colors)\n    \n    rs.EnableRedraw(False)\n    \n    sc.doc.Objects.AddPointCloud(cloud)\n    \n    print \"Elapsed time is {:.2f}\".format(time.time()-ts)\n    print \"Boo!\"\n\nif __name__ == \"__main__\":\n    \n    rs.EnableRedraw(False)\n    \n    TST()",
      "language": "python",
      "author": "ivelin.peychev",
      "post_number": 27,
      "is_solution": false
    },
    {
      "code": "##################################\n### Read TXT create pointcloud ###\n##################################\nimport System\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino\nimport time\nfrom System.Drawing import Color\n\nimport csv\n\ntol = sc.doc.ModelAbsoluteTolerance\n\n\n\n\ndef TST():\n    filtr = 'Text Files (*.txt)|*.txt| XYZ Color files (*.xyz)|*.xyz||'\n    strPath = rs.OpenFileName('XYZRGB file to import', filtr)\n    if not strPath: return\n    \n    cloud = Rhino.Geometry.PointCloud()\n    ts = time.time()\n    with open(strPath,'r') as csvfile:\n        \n        dict_reader = csv.DictReader(csvfile, fieldnames=['x','y','z','r','g','b'], restkey=None, restval=None, dialect='excel',delimiter=',', quotechar=\"'\",quoting=csv.QUOTE_NONNUMERIC)\n        # csv.QUOTE_NONNUMERIC -> tells the reader to convert all non quoted data to floats\n        \n        for row in dict_reader:\n            cloud.Add(Rhino.Geometry.Point3d(row['x'],row['y'],row['z']),Color.FromArgb(row['r'],row['g'],row['b']))#\n            \n    \n    sc.doc.Objects.AddPointCloud(cloud)\n    print \"Elapsed time is {:.2f}\".format(time.time()-ts)\n    print \"Boo!\"\n\nif __name__ == \"__main__\":\n    \n    #rs.EnableRedraw(False)\n    \n    TST()",
      "language": "python",
      "author": "ivelin.peychev",
      "post_number": 27,
      "is_solution": false
    },
    {
      "code": "# First attempt to import point cloud from txt to 3dm\n# Currently creating 3dm file to the desktop containing the points\n\nimport rhino3dm\nimport os\nimport time\nimport csv\n\nfrom tkinter.filedialog import askopenfilename\n\ndef TST():\n    #filtr = 'Text Files (*.txt)|*.txt| XYZ Color files (*.xyz)|*.xyz||'\n    #strPath = rs.OpenFileName('XYZRGB file to import', filtr)\n    strPath = askopenfilename(initialdir = \"/\",title = \"Select file\",filetypes = ((\"TXT files\",\"*.txt\"),(\"all files\",\"*.*\")))\n    \n    \n    if not strPath: return\n    # Create a File3dm object\n    model = rhino3dm.File3dm()\n    \n    # create point cloud\n    cloud = rhino3dm.PointCloud()\n    #cloud = Rhino.Geometry.PointCloud()\n    ts = time.time()\n    \n    # I don't get the underscore ?\n    point_list = rhino3dm._rhino3dm.Point3dList\n    with open(strPath,'r') as csvfile:\n        \n        dict_reader = csv.DictReader(csvfile, fieldnames=['x','y','z','r','g','b'], restkey=None, restval=None, dialect='excel',delimiter=',', quotechar=\"'\",quoting=csv.QUOTE_NONNUMERIC)\n        # csv.QUOTE_NONNUMERIC -> tells the reader to convert all non quoted data to floats\n        \n        for row in dict_reader:\n            model.Objects.AddPoint(float(row['x']),float(row['y']),float(row['z']))\n            #cloud.Add(Rhino.Geometry.Point3d(row['x'],row['y'],row['z']),Color.FromArgb(row['r'],row['g'],row['b']))#\n            \n    \n    #model.Objects.AddPoint3dList(point_list)\n    #model.Objects.AddPointCloud(cloud)\n    #sc.doc.Objects.AddPointCloud(cloud)\n    \n    # Full path to 3dm file to save\n    desktop = os.path.join(os.path.join(os.environ['USERPROFILE']), 'Desktop') \n    filename = 'point_cloud.3dm'\n    path = os.path.join(desktop, filename)\n    \n    # Write model to disk\n    model.Write(path, 6)\n    \n    \n    print (\"Elapsed time is {:.2f}\".format(time.time()-ts))\n    \n\nif __name__ == \"__main__\":\n    \n    TST()",
      "language": "python",
      "author": "ivelin.peychev",
      "post_number": 29,
      "is_solution": false
    },
    {
      "code": "\"\"\"\nA script to import points and colors from txt file, then create a PointCloud\nand save the 3dm file to the desktop\n\nby Ivelin Peychev\n\nPrerequisites:\nI. DotNet libraries:\n    1. IronPython2.7.x (standalone installation)\n    2. Rhino3dmIO.dll\n    3. librhino3dmio_native.dll (this is included in the Rhino3dmIO nuget package\n    4. System namespace included in the \"mscorlib.dll\" should be in the system.\n    5. System.Drawing for the Color\n    6. System.Windows.Forms for the open file dialog\nII. Python modules:\n    1. csv - for reading the txt file in a friendlier manner.\n    2. time - for tracking the time needed for the task to complete\n    3. os - for saving the file\n\"\"\"\n\nimport clr\n\n\"\"\"\nusing just this one leads to error that librhino3dmio_native.dll cannot be found\nlibrhino3dmio_native.dll has to be in the same folder as Rhino3dmIO.dll\n\"\"\"\n\nclr.AddReferenceToFileAndPath(r\"Z:\\ipy2\\nuget_dlls\\McNeel\\Rhino3dmIO.Desktop\\lib\\net45\\Rhino3dmIO.dll\")\nclr.AddReference(\"System.Windows.Forms\")\nclr.AddReference(\"System.Drawing\")\nclr.AddReference(\"mscorlib\")\n\nimport os\nimport time\nimport csv\n\nimport System\nimport Rhino\nimport Rhino.FileIO\n\nfrom System.Windows.Forms import OpenFileDialog, DialogResult\nfrom System.Drawing import Color\n\ndef TST():\n    openFileDialog = OpenFileDialog()\n    openFileDialog.InitialDirectory = \"c:\\\\\"\n    openFileDialog.Filter = \"txt files (*.txt)|*.txt|All files (*.*)|*.*\"\n    openFileDialog.FilterIndex = 2\n    openFileDialog.RestoreDirectory = True\n    if (openFileDialog.ShowDialog() == DialogResult.OK):\n        #Get the path of specified file\n        strPath = openFileDialog.FileName\n        print strPath\n        \n    \n    if not strPath: return\n    \n    \"\"\" So far so good I can get the path to the txt containing points\"\"\"\n    \n    # Create a File3dm object\n    model = Rhino.FileIO.File3dm()\n    \n    # create point cloud\n    cloud = Rhino.Geometry.PointCloud()\n    ts = time.time()\n    \n    # I don't get the underscore ?\n    point_list = Rhino.Collections.Point3dList()\n    tcolors = System.Collections.Generic.List[Color]()\n    with open(strPath,'r') as csvfile:\n        \n        dict_reader = csv.DictReader(csvfile, fieldnames=['x','y','z','r','g','b'], restkey=None, restval=None, dialect='excel',delimiter=' ', quotechar=\"'\",quoting=csv.QUOTE_NONNUMERIC)\n        # csv.QUOTE_NONNUMERIC -> tells the reader to convert all non quoted data to floats\n        \n        for row in dict_reader:\n            #model.Objects.AddPoint(float(row['x']),float(row['y']),float(row['z']))\n            point_list.Add(row['x'],row['y'],row['z'])\n            tcolors.Add(Color.FromArgb(row['r'],row['g'],row['b']))\n            #cloud.Add(Rhino.Geometry.Point3d(row['x'],row['y'],row['z']),Color.FromArgb(row['r'],row['g'],row['b']))#\n            \n    \"\"\"rhino3dm.PointCloud does not have attribute AddRange\"\"\"\n    cloud.AddRange(point_list,tcolors)\n    \n    \n    model.Objects.AddPointCloud(cloud)\n    #sc.doc.Objects.AddPointCloud(cloud)\n    \n    # Full path to 3dm file to save\n    desktop = os.path.join(os.path.join(os.environ['USERPROFILE']), 'Desktop') \n    filename = 'point_cloud.3dm'\n    path = os.path.join(desktop, filename)\n    \n    # Write model to disk\n    model.Write(path, 6)\n    \n    \n    print (\"Elapsed time is {:.2f}\".format(time.time()-ts))\n    print (\"Done!\")\n\nif __name__ == \"__main__\":\n    \n    TST()",
      "language": "python",
      "author": "ivelin.peychev",
      "post_number": 30,
      "is_solution": false
    },
    {
      "code": "\"\"\"\nA script to import points and colors from txt file, then create a PointCloud\nand save the 3dm file to the desktop\n\nby Ivelin Peychev & Terry Chappell\n\nPrerequisites:\nI. DotNet libraries:\n    1. IronPython2.7.x (standalone installation)\n    2. Rhino3dmIO.dll\n    3. librhino3dmio_native.dll (this is included in the Rhino3dmIO nuget package\n    4. System namespace included in the \"mscorlib.dll\" should be in the system.\n    5. System.Drawing for the Color\n    6. System.Windows.Forms for the open file dialog\nII. Python modules:\n    1. csv - for reading the txt file in a friendlier manner.\n    2. time - for tracking the time needed for the task to complete\n    3. os - for saving the file\n    4. itertools - for islice\n\"\"\"\n\nimport clr\n\n\"\"\"\nusing just this one leads to error that librhino3dmio_native.dll cannot be found\nlibrhino3dmio_native.dll has to be in the same folder as Rhino3dmIO.dll\n\"\"\"\n\nclr.AddReferenceToFileAndPath(r\"Z:\\ipy2\\nuget_dlls\\McNeel\\Rhino3dmIO.Desktop\\lib\\net45\\Rhino3dmIO.dll\")\nclr.AddReference(\"System.Windows.Forms\")\nclr.AddReference(\"System.Drawing\")\nclr.AddReference(\"mscorlib\")\n\nimport os\nimport time\nimport csv\n\nimport System\nimport Rhino\nimport Rhino.FileIO\n\nfrom System.Windows.Forms import OpenFileDialog, DialogResult\nfrom System.Drawing import Color\n\nfrom itertools import islice\n\n\ndef TST():\n    openFileDialog = OpenFileDialog()\n    openFileDialog.InitialDirectory = \"c:\\\\\"\n    openFileDialog.Filter = \"txt files (*.txt)|*.txt|All files (*.*)|*.*\"\n    openFileDialog.FilterIndex = 2\n    openFileDialog.RestoreDirectory = True\n    if (openFileDialog.ShowDialog() == DialogResult.OK):\n        #Get the path of specified file\n        strPath = openFileDialog.FileName\n        print strPath\n        \n    \n    if not strPath: return\n    \n    \"\"\" So far so good I can get the path to the txt containing points\"\"\"\n    \n    # Create a File3dm object\n    model = Rhino.FileIO.File3dm()\n    ts = time.time()\n    \n    \"\"\" \"\"\"\n    \n    file = open(strPath)\n    if not file: return\n    total = 0\n    cloud = Rhino.Geometry.PointCloud()\n    while True:\n        # Get group of lines to process.\n        n_lines = list(islice(file, 1000))  # neat trick from stack overflow brought by nathancoatney of Rhino Forum.\n        if not n_lines: break\n        total += len(n_lines)\n        # Define .NET structures for holding points and colors.\n        points = Rhino.Collections.Point3dList()\n        # Create list for holding 32-bit representation of RGB color.\n        tcolors = []\n        # Load points and colors for point cloud.\n        for line in n_lines:\n            d1,d2,d3,d4,d5,d6 = map(float,line.strip().split(','))\n            points.Add(d1,d2,d3)\n            # Convert R,G,B color to 32-bit color.\n            tcolors.append(65536.*d4 + 256.*d5 + d6)\n        # Convert 32-bit color to .NET Color.\n        colors = System.Collections.Generic.List[Color](map(Color.FromArgb,tcolors))\n        # Add points & colors to point cloud.\n        cloud.AddRange(points, colors)\n    \"\"\"...\"\"\"\n    model.Objects.AddPointCloud(cloud)\n    #sc.doc.Objects.AddPointCloud(cloud)\n    \n    # Full path to 3dm file to save\n    desktop = os.path.join(os.path.join(os.environ['USERPROFILE']), 'Desktop') \n    filename = 'point_cloud.3dm'\n    path = os.path.join(desktop, filename)\n    \n    # Write model to disk\n    model.Write(path, 6)\n    \n    \n    print (\"Read {0} points in {1:.2f} seconds.\".format(total,time.time()-ts))\n    print (\"Done!\")\n\nif __name__ == \"__main__\":\n    \n    TST()",
      "language": "python",
      "author": "ivelin.peychev",
      "post_number": 31,
      "is_solution": false
    },
    {
      "code": "\"\"\"\nA script to import points and colors from txt file, then create a PointCloud\nand save the 3dm file to the desktop\n\nCleaning up some Python2 modules.\nThis allows now the script to be compiled into a single executable\n\nby Ivelin Peychev & Terry Chappell\n\nPrerequisites:\nI. DotNet libraries:\n    1. IronPython2.7.x (standalone installation)\n    2. Rhino3dmIO.dll\n    3. librhino3dmio_native.dll (this is included in the Rhino3dmIO nuget package\n    4. System namespace included in the \"mscorlib.dll\" should be in the system.\n    5. System.Drawing for the Color\n    6. System.Windows.Forms for the open file dialog\n    7. System.IO included in \"mscorlib.dll\"\n\"\"\"\n\nimport clr\n\n\"\"\"\nusing just this one leads to error that librhino3dmio_native.dll cannot be found\nlibrhino3dmio_native.dll has to be in the same folder as Rhino3dmIO.dll\n\"\"\"\n\nclr.AddReferenceToFileAndPath(r\"Z:\\ipy2\\nuget_dlls\\McNeel\\Rhino3dmIO.Desktop\\lib\\net45\\Rhino3dmIO.dll\")\nclr.AddReference(\"System.Windows.Forms\")\nclr.AddReference(\"System.Drawing\")\nclr.AddReference(\"mscorlib\")\n\n#import os\n#import time\n#import csv\n\n#import System\n#import Rhino\n#import Rhino.FileIO\n\nfrom time import time\nfrom System.IO import Path\nfrom Rhino.Geometry import PointCloud\nfrom Rhino.Collections import Point3dList\nfrom Rhino.FileIO import File3dm\nfrom System.Collections.Generic import List\nfrom System.Environment import ExpandEnvironmentVariables\nfrom System.Windows.Forms import OpenFileDialog, DialogResult\nfrom System.Drawing import Color\nfrom System.Windows.Forms import MessageBox, MessageBoxButtons, MessageBoxIcon\n\n\nfrom itertools import islice\n\n\ndef TST():\n    openFileDialog = OpenFileDialog()\n    openFileDialog.InitialDirectory = \"c:\\\\\"\n    openFileDialog.Filter = \"txt files (*.txt)|*.txt|All files (*.*)|*.*\"\n    openFileDialog.FilterIndex = 2\n    openFileDialog.RestoreDirectory = True\n    if (openFileDialog.ShowDialog() == DialogResult.OK):\n        #Get the path of specified file\n        strPath = openFileDialog.FileName\n        #print strPath\n        \n    \n    if not strPath: return\n    \n    \"\"\" So far so good I can get the path to the txt containing points\"\"\"\n    \n    # Create a File3dm object\n    model = File3dm()\n    ts = time()\n    \n    \"\"\" \"\"\"\n    \n    file = open(strPath)\n    if not file: return\n    total = 0\n    cloud = PointCloud()\n    while True:\n        # Get group of lines to process.\n        n_lines = list(islice(file, 1000))  # neat trick from stack overflow brought by nathancoatney of Rhino Forum.\n        if not n_lines: break\n        total += len(n_lines)\n        # Define .NET structures for holding points and colors.\n        points = Point3dList()\n        # Create list for holding 32-bit representation of RGB color.\n        tcolors = []\n        # Load points and colors for point cloud.\n        for line in n_lines:\n            d1,d2,d3,d4,d5,d6 = map(float,line.strip().split(','))\n            points.Add(d1,d2,d3)\n            # Convert R,G,B color to 32-bit color.\n            tcolors.append(65536.*d4 + 256.*d5 + d6)\n        # Convert 32-bit color to .NET Color.\n        colors = List[Color](map(Color.FromArgb,tcolors))\n        # Add points & colors to point cloud.\n        cloud.AddRange(points, colors)\n    \"\"\"...\"\"\"\n    model.Objects.AddPointCloud(cloud)\n    #sc.doc.Objects.AddPointCloud(cloud)\n    \n    # Full path to 3dm file to save\n    desktop = Path.Combine(ExpandEnvironmentVariables(r\"%USERPROFILE%\"), 'Desktop')\n    filename = 'point_cloud.3dm'\n    path = Path.Combine(desktop,filename)\n    \n    \n    # Write model to disk\n    model.Write(path, 6)\n    \n    \n    #print (\"Read {0} points in {1:.2f} seconds.\".format(total,time.time()-ts))\n    MessageBox.Show(\"Read {0} points in {1:.2f} seconds.\".format(total,time()-ts), \"Result\", MessageBoxButtons.OK, MessageBoxIcon.Exclamation)\n    #print (\"Done!\")\n\nif __name__ == \"__main__\":\n    \n    TST()",
      "language": "python",
      "author": "ivelin.peychev",
      "post_number": 31,
      "is_solution": false
    },
    {
      "code": "# If you want to use the DLL for 3X faster cloud import, set its path here:\ndll_name = r'C:\\Users\\Terry\\source\\repos\\ReadCloud\\x64\\Release\\ReadCloud.dll'\n\"\"\"\nPython script to import XYZRGB format colored point cloud into Rhino 6 or 7 WIP.\nIt uses cloud.AddRange to provide an approximately 3X speedup over cloud.Add and\navoids the 70M point limit of the Rhino Point3dList structure used in AddRange\nby processing groups of 2000 points at a time. For 3X faster execution, it calls\na DLL which reads a 100 KB block at a time and then parses the block into into\nthe X,Y,Z coordinates and R,G,B color of a point. The 100KB block fits entirely\nwithin the L1-cache of the processer resulting in higher performance.\nThe coordinates and R,G,B colors are passed back to Python where they are loaded\ninto Point3d and .NET Color lists and then added to the cloud using AddRange.\nThe script with DLL is 3X faster than the included all-Python version and 15X\nfaster than Rhino's Import command. For example, it reads a 4GB file and creates\na 73.7M point cloud in 51 sec vs 179 sec (Python only) vs 790 sec or 13:10 min\n(Rhino Import). The script imports a colored point cloud at about 1.4M pts/sec.\nIf the DLL is not installed, the script still runs using the included all-Python\nprocedure ImportXYZRGB_Python.\nBy Terry Chappell 8/2/2019.\n\"\"\"\nfrom Rhino.Geometry import PointCloud\nfrom Rhino.Collections import Point3dList\nfrom System.Collections.Generic import List\nfrom System.Drawing import Color\nfrom scriptcontext import doc\nimport rhinoscriptsyntax as rs\nimport Rhino as R\nfrom time import time\nfrom itertools import islice\nimport os\nfrom ctypes import c_longlong, cdll as c_cdll, c_char, c_long, c_int, c_double,\\\n\tbyref as c_byref, c_wchar_p\n\n# This is used when DLL is available.\ndef ImportXYZRGB_DLL():\n\t# Make Color local for faster performance.\n\tlColor = Color\n\t# Format of file should be XYZRGB: 1.2345 2.5682 3.9832 155 200 225\n\tfiltr = 'Text Files (*.txt)|*.txt| XYZ Color files (*.xyz)|*.xyz||'\n\tstrPath = rs.OpenFileName('XYZRGB file to import', filtr)\n\tif not strPath: return\n\ttimea = time()\n\t# Zero number of points read.\n\ttotal = 0\n\t# Get size of file in bytes.\n\tfile_size = os.path.getsize(strPath)\n\t# Read 100K bytes blocks. Fits in the L1 cache and for better performance.\n\tblock_size = 100000\n\t# Estimate the number of points that are contained in the block.\n\test_points = block_size // 30 # 3 FP numbers + 3 Int numbers.\n\t# Set size of points & colors arrays based upon estimated number of points.\n\tnxyz = int(est_points)\n\tncolors = int(est_points)\n\tprint 'Reading file {0} with {1:,} bytes in {2:,}KB blocks and converting to point cloud . . .'\\\n\t\t.format(strPath, file_size, block_size // 1000)\n\t# Define c-types variables for interfacing to DLL.\n\tcx = (c_double * (nxyz))() # X-coordinant of point in cloud.\n\tcy = (c_double * (nxyz))() # Y-coordinant\n\tcz = (c_double * (nxyz))() # Z-coordinant\n\tccolors = (c_long * (ncolors))() # Color for each point\n\tcnum_points = (c_int * (4))() # Number of points read + room 3 debug values.\n\tcmemblock = (c_char * (block_size))() # Working area for reading file.\n\tcoffset = (c_longlong * (1))(0) # Offset into file as each block is read.\n\tcfile_length = (c_longlong * (1))(file_size) # File size for detecting EOF.\n\t# Initialize cloud for holding results of read.\n\tcloud = PointCloud()\n\t# Zero offset for aligning to line boundary.\n\toffset = 0\n\t# Read file in blocks and process strings into points and colors for cloud.\n\twhile offset < file_size:\n\t\t# Call DLL to open file, read & parse block and return points & colors.\n\t\tsoReadCloud.read_cloud(strPath, c_byref(cx),c_byref(cy),c_byref(cz),\n\t\t\tc_byref(ccolors), c_byref(cnum_points), c_byref(cmemblock),\n\t\t\tblock_size, c_byref(coffset), c_byref(cfile_length))\n\t\t# Get number of points read from block.\n\t\tnum_points = cnum_points[0]\n\t\t# Get offset for next block read.\n\t\toffset = coffset[0]\n\t\t# Sum total number of points read.\n\t\ttotal += num_points\n\t\t# Define Rhino.Collections Point3dList for holding XYZ coordinates. \n\t\tpoints = Point3dList()\n\t\t# Load points using coordinates returned by DLL.\n\t\tfor i in xrange(num_points): points.Add(cx[i],cy[i],cz[i])\n\t\t# Get active colors from ctypes-colors list.\n\t\tcolors = ccolors[:num_points]\n\t\t# Convert 32-bit colors to .NET Colors.\n\t\tcolors = List[lColor](map(lColor.FromArgb,colors))\n\t\t# Add points & colors to point cloud.\n\t\tcloud.AddRange(points, colors)\n\t# Add visible point cloud to document.\n\tobj = doc.Objects.AddPointCloud(cloud)\n\tdoc.Views.Redraw()\n\ttimeb = time()\n\tprint 'Read {0:,} lines and added point cloud in {1:.4f} sec.'\\\n\t\t.format(total, timeb - timea)\n\n# This is used when DLL was not found.\ndef ImportXYZRGB_Python():\n\t# Local references for float, int, Color make them over 20% faster.\n\tlf = float # This saves 7 sec for 9M cloud import or 25%\n\tli = int # This saves 6.7 sec or 23%\n\tlColor = Color # This saves 1.7 sec off 20.2 sec or 8%\n\tpc = PointCloud() # No savings.\n\t# Select point cloud to import.\n\tfiltr = 'Text Files (*.txt)|*.txt| XYZ Color files (*.xyz)|*.xyz||'\n\t# Format of file should be XYZRGB: 1.2345 2.5682 3.9832 155 200 225\n\tstrPath = rs.OpenFileName('XYZRGB file to import', filtr)\n\tif not strPath: return\n\ttimea = time()\n\t# Zero counter for number of points read.\n\ttotal = 0\n\t# Use 25K block size which easily fit in L1-cache for better performance.\n\tblock_size = 25000\n\t# Zero counter for number of bytes read to use in detecting end of file.\n\tbytes_read = 0\n\t# Get file size in bytes so end of file can be detected.\n\tfile_size = os.path.getsize(strPath)\n\t# Zero offset for aligning to line boundary.\n\toffset = 0\n\t# Reset done flag.\n\tdone = False\n\tprint 'Reading file {0} with {1:,} bytes in {2:,}KB blocks and converting to point cloud . . .'\\\n\t\t.format(strPath, file_size, block_size // 1000)\n\t# Read file, process lines into points and load points into cloud.\n\t# Binary read is 2.7% faster than using itertools islice iterator.\n\t# Use next line with 'r' read option.\n\t#batch_size = 1000\n\twith open(strPath, 'rb') as file:\n\t\twhile not done:\n\t\t\t#Use next 13 lines with 'rb' read option.\n\t\t\tfile.seek(offset, 1) # Offset is relative to current position.\n\t\t\t# Read block of data.\n\t\t\tblock = file.read(block_size)\n\t\t\tif not block: break\n\t\t\t# Split block into lines.\n\t\t\tlines = block.splitlines()\n\t\t\t# Back up file pointer by length of last line.\n\t\t\toffset = -len(lines[-1])\n\t\t\t# Sum number of bytes read so end can be detected.\n\t\t\tbytes_read += block_size + offset\n\t\t\t# If not last group, remove last line as it is likely incomplete.\n\t\t\tif bytes_read < file_size: del lines[-1]\n\t\t\t# If this is the last group, set done flag.\n\t\t\telse: done = True\n\t\t\t# Use next 2 lines with 'r' read option.\n\t\t\t#lines = list(islice(file, batch_size))  # 2.7% slower (6 run ave.).\n\t\t\t#if not lines: break\n\t\t\t# Count number of points read.\n\t\t\ttotal += len(lines)\n\t\t\t# Create lists for holding point3d and 32-bit colors.\n\t\t\tpoints = Point3dList()\n\t\t\tcolors = List[lColor]()\n\t\t\t# Parse each line to extract points and colors.\n\t\t\t# Use lf, li and lColor for better performance.\n\t\t\tfor line in lines:\n\t\t\t\td1,d2,d3,d4,d5,d6 = line.split(' ')\n\t\t\t\tpoints.Add(lf(d1), lf(d2), lf(d3))\n\t\t\t\tcolors.Add(lColor.FromArgb(li(d4), li(d5), li(d6)))\n\t\t\t# Add points & colors to point cloud.\n\t\t\tpc.AddRange(points, colors)\n\t# Add visible point cloud to document.\n\tobj = doc.Objects.AddPointCloud(pc)\n\tdoc.Views.Redraw()\n\ttimeb = time()\n\tprint 'Read {0:,} lines and added point cloud in {1:.4f} sec.'\\\n\t\t.format(total, timeb - timea)\n\nif __name__ == \"__main__\":\n\t# Try to get DLL.\n\ttry:\n\t\tsoReadCloud = c_cdll.LoadLibrary(dll_name)\n\t\tImportXYZRGB_DLL()\n\t# Use Python code when DLL not found.\n\texcept:\n\t\tprint 'WARNING: Did not find DLL at {}. A 3X slower all Python version will be used.'\\\n\t\t\t.format(dll_name)\n\t\tImportXYZRGB_Python()",
      "language": "python",
      "author": "Terry_Chappell",
      "post_number": 38,
      "is_solution": false
    },
    {
      "code": "import rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino as R\nfrom itertools import islice\nimport System.Drawing.Color as Color\nimport System.Collections.Generic.List as List\n\n\ndef parse(path, batch_size=1000, separator=' '):\n    with open(path, 'r') as f:\n        lf = float  # local references to global functions might be faster\n        li = int\n        pc = R.Geometry.PointCloud()\n        while True:\n            n_lines = list(islice(f, batch_size))  # this gives us a batched iterator\n            if not n_lines:\n                break\n            points = R.Collections.Point3dList()  # this is faster than a python or .net list\n            # for some reason, PointCloud.AddRange() doesn't like colors in a python list,\n            # so using .net list here\n            colors = List[Color]()\n            for line in n_lines:\n                split = line.strip().split(separator)\n                points.Add(lf(split[0]), lf(split[1]), lf(split[2]))\n                colors.Add(Color.FromArgb(li(split[3]), li(split[4]), li(split[5])))\n            pc.AddRange(points, colors)\n        return pc\n\n\nif __name__ == '__main__':\n    import time\n    path = rs.OpenFileName('Select Point Cloud File', 'Text Files (*.txt)|*.txt| XYZ Color files (*.xyz)|*.xyz|any|*.*')\n    start = time.time()\n    pc = parse(path)\n    guid = sc.doc.Objects.AddPointCloud(pc)\n    print('parse time: {}'.format(time.time()-start))\n    print('point cloud with {} points added to doc at {}'.format(pc.Count, guid))",
      "language": "python",
      "author": "nathancoatney",
      "post_number": 37,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "python",
    "rhinocommon",
    "rhinoscriptsyntax",
    "transformation",
    "ui"
  ],
  "has_accepted_answer": false,
  "category_id": 11,
  "posts_count": 42,
  "views": 2833
}