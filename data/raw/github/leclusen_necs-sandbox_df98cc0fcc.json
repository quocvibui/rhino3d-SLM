{
  "source_url": "https://github.com/leclusen/necs-sandbox/blob/8d8006ae3c845c9f3e38154803caac6b03d298a9/structure-batiment/structure_aligner/transform/object_rules.py",
  "repo": "leclusen/necs-sandbox",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "structure-batiment/structure_aligner/transform/object_rules.py",
  "instruction": "Object-level transformation rules: removal operations.",
  "code": "\"\"\"Object-level transformation rules: removal operations.\n\nImplements Phase 4 of the V2 pipeline:\n- Dalle (slab) removal: remove all floor slabs except roof\n- Obsolete support removal: remove supports at removed axis positions\n- Multi-face voile removal: identify and remove multi-face wall Breps\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport sqlite3\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\n\nimport rhino3dm\n\nfrom structure_aligner.config import PipelineConfig\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass ObjectTransformResult:\n    \"\"\"Tracks object removal/addition counts.\"\"\"\n    dalles_removed: int = 0\n    dalles_kept: int = 0\n    supports_removed: int = 0\n    voiles_removed: int = 0\n    removed_voile_names: list[str] = field(default_factory=list)\n    errors: list[str] = field(default_factory=list)\n\n\ndef remove_dalles(\n    model: rhino3dm.File3dm,\n    db_path: Path,\n    config: PipelineConfig,\n) -> tuple[int, int]:\n    \"\"\"Remove all DALLE objects except roof (Z > roof_z_threshold).\n\n    Queries the structural DB for element names with type='DALLE', then\n    removes matching objects from the 3dm model unless their maximum Z\n    coordinate exceeds the roof threshold.\n\n    Args:\n        model: The rhino3dm model (modified in place).\n        db_path: Path to the structural database (geometrie_2.db).\n        config: Pipeline configuration with roof_z_threshold.\n\n    Returns:\n        Tuple of (removed_count, kept_count).\n    \"\"\"\n    dalle_names = _load_names_by_type(db_path, \"DALLE\")\n    if not dalle_names:\n        logger.warning(\"No DALLE entries found in database %s\", db_path)\n        return 0, 0\n\n    # Build index: name -> list of (object_index, max_z)\n    to_remove: list[int] = []\n    kept = 0\n\n    for i in range(len(model.Objects)):\n        obj = model.Objects[i]\n        name = obj.Attributes.Name\n        if name not in dalle_names:\n            continue\n\n        geom = obj.Geometry\n        max_z = _get_max_z(geom)\n\n        if max_z is None:\n            logger.warning(\"Dalle %s has unrecognized geometry; removing\", name)\n            to_remove.append(i)\n        elif max_z > config.roof_z_threshold:\n            kept += 1\n            logger.debug(\"Keeping roof dalle %s (max_z=%.2f)\", name, max_z)\n        else:\n            to_remove.append(i)\n\n    # Remove in reverse order to preserve indices\n    removed = _remove_objects_by_indices(model, to_remove)\n\n    logger.info(\n        \"Dalle removal: %d removed, %d kept (roof)\",\n        removed, kept,\n    )\n    return removed, kept\n\n\ndef remove_obsolete_supports(\n    model: rhino3dm.File3dm,\n    db_path: Path,\n    removed_axis_x: list[float] | None = None,\n    tolerance: float = 0.01,\n) -> int:\n    \"\"\"Remove support points at axis lines that no longer exist.\n\n    Research finding: 7 Appuis removed, all at X=-10.830, Z=-4.440.\n    This function removes support Point objects whose X coordinate matches\n    a removed axis line position.\n\n    Args:\n        model: The rhino3dm model (modified in place).\n        db_path: Path to the structural database.\n        removed_axis_x: List of removed X axis line positions. If None,\n            defaults to [-10.830] based on research findings.\n        tolerance: Position matching tolerance in meters.\n\n    Returns:\n        Number of supports removed.\n    \"\"\"\n    if removed_axis_x is None:\n        removed_axis_x = [-10.830]\n\n    support_names = _load_support_names(db_path)\n    if not support_names:\n        logger.warning(\"No support entries found in database %s\", db_path)\n        return 0\n\n    to_remove: list[int] = []\n\n    for i in range(len(model.Objects)):\n        obj = model.Objects[i]\n        name = obj.Attributes.Name\n        if name not in support_names:\n            continue\n\n        geom = obj.Geometry\n        if not isinstance(geom, rhino3dm.Point):\n            continue\n\n        x = geom.Location.X\n        for removed_x in removed_axis_x:\n            if abs(x - removed_x) <= tolerance:\n                to_remove.append(i)\n                logger.debug(\n                    \"Removing obsolete support %s at X=%.3f\",\n                    name, x,\n                )\n                break\n\n    removed = _remove_objects_by_indices(model, to_remove)\n    logger.info(\"Obsolete support removal: %d removed\", removed)\n    return removed\n\n\ndef remove_multiface_voiles(\n    model: rhino3dm.File3dm,\n    db_path: Path,\n    min_faces: int = 2,\n) -> list[str]:\n    \"\"\"Identify and remove multi-face voile Breps.\n\n    Multi-face voiles (walls with >1 Brep face) are geometric artifacts\n    that should be replaced with simplified single-face per-floor segments\n    (done in Phase 5).\n\n    Args:\n        model: The rhino3dm model (modified in place).\n        db_path: Path to the structural database.\n        min_faces: Minimum face count to consider as multi-face (default 2).\n\n    Returns:\n        List of removed voile names (for Phase 5 replacement).\n    \"\"\"\n    voile_names = _load_names_by_type(db_path, \"VOILE\")\n    if not voile_names:\n        logger.warning(\"No VOILE entries found in database %s\", db_path)\n        return []\n\n    to_remove: list[int] = []\n    removed_names: list[str] = []\n\n    for i in range(len(model.Objects)):\n        obj = model.Objects[i]\n        name = obj.Attributes.Name\n        if name not in voile_names:\n            continue\n\n        geom = obj.Geometry\n        if not isinstance(geom, rhino3dm.Brep):\n            continue\n\n        face_count = len(geom.Faces)\n        if face_count >= min_faces:\n            to_remove.append(i)\n            removed_names.append(name)\n            logger.debug(\n                \"Removing multi-face voile %s (%d faces)\",\n                name, face_count,\n            )\n\n    _remove_objects_by_indices(model, to_remove)\n    logger.info(\n        \"Multi-face voile removal: %d removed (min_faces=%d)\",\n        len(removed_names), min_faces,\n    )\n    return removed_names\n\n\n# =========================================================================\n# Internal helpers\n# =========================================================================\n\n\ndef _load_names_by_type(db_path: Path, element_type: str) -> set[str]:\n    \"\"\"Load element names of a given type from the shell table.\"\"\"\n    conn = sqlite3.connect(str(db_path))\n    try:\n        cursor = conn.cursor()\n        cursor.execute(\n            \"SELECT name FROM shell WHERE type = ?\",\n            (element_type,),\n        )\n        return {row[0] for row in cursor.fetchall()}\n    except sqlite3.OperationalError as e:\n        logger.warning(\"Could not query shell table: %s\", e)\n        return set()\n    finally:\n        conn.close()\n\n\ndef _load_support_names(db_path: Path) -> set[str]:\n    \"\"\"Load all support names from the support table.\"\"\"\n    conn = sqlite3.connect(str(db_path))\n    try:\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM support\")\n        return {row[0] for row in cursor.fetchall()}\n    except sqlite3.OperationalError as e:\n        logger.warning(\"Could not query support table: %s\", e)\n        return set()\n    finally:\n        conn.close()\n\n\ndef _get_max_z(geom: rhino3dm.GeometryBase) -> float | None:\n    \"\"\"Get the maximum Z coordinate from a geometry object.\"\"\"\n    if isinstance(geom, rhino3dm.Brep):\n        if len(geom.Vertices) == 0:\n            return None\n        return max(geom.Vertices[i].Location.Z for i in range(len(geom.Vertices)))\n    elif isinstance(geom, rhino3dm.Point):\n        return geom.Location.Z\n    elif isinstance(geom, rhino3dm.LineCurve):\n        return max(geom.PointAtStart.Z, geom.PointAtEnd.Z)\n    elif isinstance(geom, rhino3dm.PolylineCurve):\n        if geom.PointCount == 0:\n            return None\n        return max(geom.Point(i).Z for i in range(geom.PointCount))\n    return None\n\n\ndef _remove_objects_by_indices(model: rhino3dm.File3dm, indices: list[int]) -> int:\n    \"\"\"Remove objects from model by their indices (handles reverse ordering).\n\n    The rhino3dm library uses GUID-based deletion, not index-based.\n\n    Returns:\n        Number of objects actually removed.\n    \"\"\"\n    if not indices:\n        return 0\n\n    # Collect GUIDs for objects to remove\n    guids = []\n    for i in indices:\n        obj = model.Objects[i]\n        guids.append(obj.Attributes.Id)\n\n    count_before = len(model.Objects)\n    for guid in guids:\n        model.Objects.Delete(guid)\n\n    removed = count_before - len(model.Objects)\n    if removed != len(guids):\n        logger.warning(\n            \"Expected to delete %d objects but removed %d\",\n            len(guids), removed,\n        )\n\n    return removed\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}