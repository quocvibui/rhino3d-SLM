{
  "source_url": "https://github.com/jdvargas12/LDM-3DP-Grasshopper-Plugin/blob/3a1c30f8bfd4c52ba2b4cc7af3c615daefb3ca39/v241001/02_G_Code_Generation_FDM_241001.py",
  "repo": "jdvargas12/LDM-3DP-Grasshopper-Plugin",
  "repo_stars": 5,
  "repo_description": "This repository contains components and scripts for developing a Grasshopper plugin for 3D printing with LDM technologies like the WASP40100. The plugin facilitates G-code generation and path optimization for large-scale, clay-based, and viscous material printing.",
  "license": "unknown",
  "filepath": "v241001/02_G_Code_Generation_FDM_241001.py",
  "instruction": "02 g code generation fdm 241001",
  "code": "ghenv.Component.Name = \"Marvin Gcode - FDM\"\nghenv.Component.Message = \"240930\"\n\n#region COMPONENT DESCRIPTION\n\"\"\" COMPONENT DESCRIPTION\nGcode Generation FDM\n\nThis script generates G-code for FDM (Fused Deposition Modeling) 3D printers based on a set of 3D curves representing the toolpaths for each layer of a print. The script outputs a G-code file that directs the printer's movements, controls extrusion, and manages layer transitions. It supports both absolute (M82) and relative (M83) extrusion modes and allows for variable flux and printing speed along each curve.\n\nKey Features:\n- Supports variable flux modes (constant and linear).\n- Allows variable printing speeds (global, per layer, or per curve).\n- Adjusted for FDM printers with appropriate start and end G-code.\n- Validates printing speeds within the FDM-specific range (1000 to 10000 mm/min).\n- Calculates extrusion increments based on the filament diameter (1.75 mm for FDM).\n- Default nozzle diameter set to 0.4 mm, but can be changed by the user.\n- **Adjustable decimal precision for floating-point numbers in G-code output.**\n\nInputs:\n    printing_path (List of Curves):\n        A list of 3D curves that define the path the 3D printer head will follow for each layer of the print.\n\n    nozzle_diameter (Float):\n        The diameter of the 3D printer's nozzle, in millimeters. Defaults to 0.4 mm if not specified.\n\n    printing_speed (Float or List of Floats):\n        Printing speed(s) in mm/min. Can be a single value, a list per layer, or a list per curve.\n\n    m1_flux (Float or List of Floats):\n        Flux multiplier(s) for constant flux mode (flux_mode = 1). Can be a single value, a list per layer, or a list per curve.\n\n    layer_h (Float):\n        The height of each layer in the print, specified in millimeters.\n\n    e_absolute (Boolean):\n        Specifies whether to use absolute (M82) or relative (M83) extrusion mode.\n\n    flux_mode (Integer):\n        Specifies the mode of flux variation along the curves.\n        - 1: Constant flux mode with enhanced functionality.\n        - 2: Linear flux mode.\n\n    m2_flux_start (Float or List of Floats):\n        Starting flux multiplier(s) for linear flux variation in flux_mode 2.\n\n    m2_flux_end (Float or List of Floats):\n        Ending flux multiplier(s) for linear flux variation in flux_mode 2.\n\n    density_kg_m3 (Float):\n        The density of the printing material in kg/m^3.\n\nOutputs:\n    gcode (List of Strings):\n        The generated G-code commands.\n\n    printing_time (String):\n        The estimated time required to complete the print.\n\n    printing_points (List of Points):\n        The points generated along the curves in the toolpath.\n\n    printing_path_len (String):\n        The total length of the printing path in millimeters.\n\n    layers (Integer):\n        The total number of layers in the print.\n\"\"\"\n#endregion\n\nimport Rhino.Geometry as rg\nfrom collections import defaultdict\nimport math\n\nnozzle_div = 1.5\n\ndef flatten(lst):\n    \"\"\"Flatten a nested list into a flat list.\"\"\"\n    flat_list = []\n    for item in lst:\n        if isinstance(item, (list, tuple)):\n            flat_list.extend(flatten(item))\n        else:\n            flat_list.append(item)\n    return flat_list\n\ndef generate_gcode(printing_path, nozzle_diameter=0.4, printing_speed=None, m1_flux=None, layer_h=None,\n                   e_absolute=True, retract=True, flux_mode=1, m2_flux_start=None, m2_flux_end=None,\n                   density_kg_m3=None):\n    # ----------------------------\n    # Variable for decimal precision\n    decimal_places = 2  # You can change this value to adjust the number of decimal places\n    # ----------------------------\n\n    # Validate and set default nozzle_diameter\n    if nozzle_diameter is None or nozzle_diameter <= 0:\n        nozzle_diameter = 0.4  # Default nozzle diameter in mm\n\n    # Validate and process printing_speed\n    if printing_speed is None:\n        print(\"Error: Printing speed must be provided.\")\n        return None, None, None, None, None\n\n    if not isinstance(printing_speed, list):\n        printing_speed = [printing_speed]\n    else:\n        printing_speed = flatten(printing_speed)\n\n    # Prepare list of all valid curves\n    all_curves = [curve for curve in printing_path if curve.IsValid and curve.GetLength() > 0]\n    num_curves = len(all_curves)\n\n    if num_curves == 0:\n        print(\"Error: No valid curves provided in printing_path.\")\n        return None, None, None, None, None\n\n    # Calculate Z coordinates and number of layers\n    min_z = min(min(curve.PointAtStart.Z, curve.PointAtEnd.Z) for curve in all_curves)\n    max_z = max(max(curve.PointAtStart.Z, curve.PointAtEnd.Z) for curve in all_curves)\n    num_layers = int((max_z - min_z) / layer_h) + 1\n\n    # Determine printing speed mode\n    if len(printing_speed) == 1:\n        speed_mode_detail = \"global\"\n    elif len(printing_speed) == num_layers:\n        speed_mode_detail = \"per_layer\"\n    elif len(printing_speed) == num_curves:\n        speed_mode_detail = \"per_curve\"\n    else:\n        print(\"Warning: The number of printing speed values does not match the number of layers or curves.\")\n        return None, None, None, None, num_layers\n\n    # Validate printing speeds\n    for speed in printing_speed:\n        if speed < 1000 or speed > 10000:\n            print(\"Warning: Printing speeds must be between 1000 and 10000 mm/minute.\")\n            return None, None, None, None, None\n\n    # Handle flux_mode and flux values\n    if flux_mode == 1:\n        if m1_flux is None:\n            print(\"Error: m1_flux must be provided when flux_mode is set to 1.\")\n            return None, None, None, None, None\n        # Ensure m1_flux is a list\n        m1_flux = flatten([m1_flux]) if not isinstance(m1_flux, list) else flatten(m1_flux)\n        # Determine flux mode: global, per layer, or per curve\n        if len(m1_flux) == 1:\n            flux_mode_detail = \"global\"\n        elif len(m1_flux) == num_layers:\n            flux_mode_detail = \"per_layer\"\n        elif len(m1_flux) == num_curves:\n            flux_mode_detail = \"per_curve\"\n        else:\n            print(\"Warning: The number of flux values does not match the number of layers or curves.\")\n            return None, None, None, None, num_layers\n    elif flux_mode == 2:\n        if m2_flux_start is None or m2_flux_end is None:\n            print(\"Error: m2_flux_start and m2_flux_end must be provided when flux_mode is set to 2 (Linear).\")\n            return None, None, None, None, None\n\n        # Ensure m2_flux_start and m2_flux_end are lists\n        if not isinstance(m2_flux_start, list):\n            m2_flux_start = [m2_flux_start]\n        else:\n            m2_flux_start = flatten(m2_flux_start)\n\n        if not isinstance(m2_flux_end, list):\n            m2_flux_end = [m2_flux_end]\n        else:\n            m2_flux_end = flatten(m2_flux_end)\n\n        # If m2_flux_start and m2_flux_end have length 1, repeat them to match num_curves\n        if len(m2_flux_start) == 1:\n            m2_flux_start = m2_flux_start * num_curves\n        if len(m2_flux_end) == 1:\n            m2_flux_end = m2_flux_end * num_curves\n\n        # Check that m2_flux_start and m2_flux_end lists have the same length and match number of curves\n        if len(m2_flux_start) != len(m2_flux_end) or len(m2_flux_start) != num_curves:\n            print(\"Error: m2_flux_start and m2_flux_end must be lists of the same length as the number of curves.\")\n            return None, None, None, None, None\n\n    # Set default density if not provided or invalid\n    if density_kg_m3 is None or density_kg_m3 <= 0:\n        density_kg_m3 = 1200  # Typical density for PLA in kg/m^3\n        density_warning = \";Note: Invalid or missing density value. Using default density of 1200 kg/m^3.\"\n    else:\n        density_warning = \"\"\n\n    # Group curves by layer\n    curves_by_layer = defaultdict(list)\n    for idx, curve in enumerate(all_curves):\n        layer_index = int((curve.PointAtEnd.Z - min_z) / layer_h)\n        curves_by_layer[layer_index].append((curve, idx))\n\n    # Initialize variables\n    total_extruded_volume = 0.0  # in mm^3\n    total_printing_distance = 0.0  # in mm\n    previous_point = None\n    gcode = []\n    printing_points = []\n\n    # Preprocessing for estimation\n    for layer_index in sorted(curves_by_layer.keys()):\n        # Determine current printing speed\n        if speed_mode_detail == \"global\":\n            current_speed = printing_speed[0]\n        elif speed_mode_detail == \"per_layer\":\n            current_speed = printing_speed[layer_index]\n        # For 'per_curve', we'll handle it inside the curve loop\n\n        if flux_mode == 1:\n            if flux_mode_detail == \"global\":\n                current_flux = m1_flux[0]\n            elif flux_mode_detail == \"per_layer\":\n                current_flux = m1_flux[layer_index]\n            # For 'per_curve', we'll handle it inside the curve loop\n        elif flux_mode == 2:\n            # Not applicable here\n            pass\n\n        for curve, curve_index in curves_by_layer[layer_index]:\n            # Determine current printing speed for per_curve mode\n            if speed_mode_detail == \"per_curve\":\n                current_speed = printing_speed[curve_index]\n\n            if flux_mode == 1:\n                if flux_mode_detail == \"per_curve\":\n                    current_flux = m1_flux[curve_index]\n                # For 'global' and 'per_layer', current_flux is already set\n                start_flux = current_flux\n                end_flux = current_flux\n            elif flux_mode == 2:\n                start_flux = float(m2_flux_start[curve_index])\n                end_flux = float(m2_flux_end[curve_index])\n\n            curve_params = curve.DivideByLength(nozzle_diameter/nozzle_div, True)\n            if curve_params is None:\n                continue\n\n            points = [curve.PointAt(t) for t in curve_params]\n            points.insert(0, curve.PointAtStart)\n            points.append(curve.PointAtEnd)\n\n            cumulative_distances = [0.0]\n            for i in range(1, len(points)):\n                dist = points[i - 1].DistanceTo(points[i])\n                cumulative_distances.append(cumulative_distances[-1] + dist)\n\n            total_curve_length = cumulative_distances[-1]\n            normalized_distances = [d / total_curve_length if total_curve_length > 0 else 0.0 for d in cumulative_distances]\n\n            for i in range(1, len(points)):\n                segment_distance = points[i - 1].DistanceTo(points[i])\n\n                if flux_mode == 2:\n                    t_norm = normalized_distances[i]\n                    flux = start_flux + t_norm * (end_flux - start_flux)\n                else:\n                    flux = current_flux\n\n                cross_sectional_area = (nozzle_diameter * 1.1 * flux) * layer_h  # in mm^2\n                amount_per_segment = cross_sectional_area * segment_distance  # in mm^3\n                total_extruded_volume += amount_per_segment\n                total_printing_distance += segment_distance\n\n            if previous_point:\n                travel_distance = previous_point.DistanceTo(points[0])\n                total_printing_distance += travel_distance\n\n            previous_point = points[-1]\n\n    # Calculate total length and time\n    average_speed = sum(printing_speed) / len(printing_speed)\n    printing_time_minutes = total_printing_distance / average_speed if total_printing_distance else 0\n    printing_time = f\"{printing_time_minutes:.{decimal_places}f} minutes\"\n\n    # Calculate estimated volume and mass\n    volume_m3 = total_extruded_volume / 1e9  # Convert mm^3 to m^3\n    volume_liters = volume_m3 * 1000  # Convert m^3 to liters\n    mass_kg = volume_m3 * density_kg_m3\n    mass_g = mass_kg * 1000  # Convert kg to grams\n\n    # Start G-code with printing information\n    e_mode = \"M82 ;Absolute extrusion mode\" if e_absolute else \"M83 ;Relative extrusion mode\"\n    flux_mode_str = 'Constant' if flux_mode == 1 else 'Linear'\n    printing_info = [\n        \";PRINTING INFORMATION:\",\n        f\";Nozzle diameter: {nozzle_diameter} [mm]\",\n        f\";Number of layers: {num_layers}\",\n        f\";Layer height: {layer_h} [mm]\",\n        f\";Extrusion mode: {'Absolute' if e_absolute else 'Relative'}\",\n        f\";Flux mode: {flux_mode_str}\"\n    ]\n\n    # Add printing speed information\n    if speed_mode_detail == \"global\":\n        printing_info.append(f\";Printing speed (global): {printing_speed[0]} mm/min\")\n    elif speed_mode_detail == \"per_layer\":\n        min_speed = min(printing_speed)\n        max_speed = max(printing_speed)\n        printing_info.append(f\";Printing speed per layer: From {min_speed} to {max_speed} mm/min\")\n    elif speed_mode_detail == \"per_curve\":\n        min_speed = min(printing_speed)\n        max_speed = max(printing_speed)\n        printing_info.append(f\";Printing speed per curve: From {min_speed} to {max_speed} mm/min\")\n\n    # Add flux information\n    if flux_mode == 1:\n        if flux_mode_detail == \"global\":\n            printing_info.append(f\";Flux multiplier (global): {m1_flux[0]}\")\n        elif flux_mode_detail == \"per_layer\":\n            min_flux = min(m1_flux)\n            max_flux = max(m1_flux)\n            printing_info.append(f\";Flux multiplier per layer: From {min_flux} to {max_flux}\")\n        elif flux_mode_detail == \"per_curve\":\n            min_flux = min(m1_flux)\n            max_flux = max(m1_flux)\n            printing_info.append(f\";Flux multiplier per curve: From {min_flux} to {max_flux}\")\n    elif flux_mode == 2:\n        min_flux = min(flatten([m2_flux_start, m2_flux_end]))\n        max_flux = max(flatten([m2_flux_start, m2_flux_end]))\n        printing_info.append(f\";Flux multiplier: From {min_flux} to {max_flux}\")\n\n    # Add density, volume, and mass information\n    printing_info.append(f\";Material density: {density_kg_m3} kg/m^3\")\n    if density_warning:\n        printing_info.append(density_warning)\n    printing_info.append(f\";Estimated printing volume: {volume_liters:.{decimal_places}f}L\")\n    printing_info.append(f\";Estimated printing mass: {mass_g:.{decimal_places}f}g\")\n\n    # Start G-code\n    # Replace with FDM-specific start G-code\n    start_gcode = [\n        \"; -- START GCODE --\",\n        \"M140 S60\",\n        \"M105\",\n        \"M190 S60\",\n        \"M104 S205\",\n        e_mode,\n        \"M220 S100 ;Reset Feedrate\",\n        \"M221 S100 ;Reset Flowrate\",\n        \"G28 ;Home\",\n        \"M420 S1 ; Enable mesh leveling\",\n        \"M413 S0 ; Power Loss Off\",\n        \"G92 E0 ;Reset Extruder\",\n        \"G1 Z2.0 F3000 ;Move Z Axis up\",\n        \"G1 X-2.1 Y20 Z0.28 F5000.0 ;Move to start position\",\n        \"M109 S190.000000\",\n        \"G1 X-2.1 Y145.0 Z0.28 F1500.0 E15 ;Draw the first line\",\n        \"G1 X-2.4 Y145.0 Z0.28 F5000.0 ;Move to side a little\",\n        \"G1 X-2.4 Y20 Z0.28 F1500.0 E30 ;Draw the second line\",\n        \"G92 E0  ;Reset Extruder\",\n        \"G1 E-3.0000 F1800 ;Retract a bit\",\n        \"G1 Z2.0 F3000 ;Move Z Axis up\",\n        \"G1 E0.0000 F1800\",\n        \"G92 E0\",\n        \"G1 F6000 E-5\",\n        \";  -- END OF START GCODE --\"\n    ]\n    gcode.extend(printing_info)\n    gcode.extend(start_gcode)\n\n    # G-code generation\n    extrusion_amount = 0.0\n    previous_point = None\n\n    # Update constant_denominator for FDM filament diameter\n    constant_denominator = ((1.75 / 2) ** 2) * math.pi  # For 1.75 mm filament\n\n    for layer_index in sorted(curves_by_layer.keys()):\n        gcode.append(f\"; Start of layer {layer_index + 1}\")\n\n        # Determine current printing speed\n        if speed_mode_detail == \"global\":\n            current_speed = printing_speed[0]\n        elif speed_mode_detail == \"per_layer\":\n            current_speed = printing_speed[layer_index]\n\n        for curve, curve_index in curves_by_layer[layer_index]:\n            # Determine current printing speed for per_curve mode\n            if speed_mode_detail == \"per_curve\":\n                current_speed = printing_speed[curve_index]\n\n            if flux_mode == 1:\n                if flux_mode_detail == \"global\":\n                    current_flux = m1_flux[0]\n                elif flux_mode_detail == \"per_layer\":\n                    current_flux = m1_flux[layer_index]\n                elif flux_mode_detail == \"per_curve\":\n                    current_flux = m1_flux[curve_index]\n                start_flux = current_flux\n                end_flux = current_flux\n            elif flux_mode == 2:\n                start_flux = float(m2_flux_start[curve_index])\n                end_flux = float(m2_flux_end[curve_index])\n\n            curve_params = curve.DivideByLength(nozzle_diameter / nozzle_div, True) # Divide curves by a given length\n            if curve_params is None:\n                continue\n\n            points = [curve.PointAt(t) for t in curve_params]\n            points.insert(0, curve.PointAtStart)\n            points.append(curve.PointAtEnd)\n\n            cumulative_distances = [0.0]\n            for i in range(1, len(points)):\n                dist = points[i - 1].DistanceTo(points[i])\n                cumulative_distances.append(cumulative_distances[-1] + dist)\n\n            total_curve_length = cumulative_distances[-1]\n            normalized_distances = [d / total_curve_length if total_curve_length > 0 else 0.0 for d in cumulative_distances]\n\n            for i, pt in enumerate(points):\n                if i == 0:\n                    gcode_line = f\"G0 F{current_speed:.0f} X{pt.X:.{decimal_places}f} Y{pt.Y:.{decimal_places}f} Z{pt.Z:.{decimal_places}f}\"\n                    gcode.append(gcode_line)\n                    printing_points.append(pt)\n                else:\n                    segment_distance = points[i - 1].DistanceTo(pt)\n\n                    if flux_mode == 2:\n                        t_norm = normalized_distances[i]\n                        flux = start_flux + t_norm * (end_flux - start_flux)\n                    else:\n                        flux = current_flux\n\n                    # Calculate extrusion increment\n                    extrusion_increment = ((nozzle_diameter * layer_h) / constant_denominator) * flux * segment_distance\n\n                    if e_absolute:\n                        extrusion_amount += extrusion_increment\n                        e_value = extrusion_amount\n                    else:\n                        e_value = extrusion_increment\n\n                    gcode_line = f\"G1 F{current_speed:.0f} X{pt.X:.{decimal_places}f} Y{pt.Y:.{decimal_places}f} Z{pt.Z:.{decimal_places}f} E{e_value:.{decimal_places}f}\"\n                    gcode.append(gcode_line)\n                    printing_points.append(pt)\n\n            previous_point = points[-1]\n\n        if bool(retract):\n            last_point = previous_point\n            retract_gcode = f\"G1 F{current_speed:.0f} Z{(last_point.Z + layer_h):.{decimal_places}f} ; Retract to avoid pulling\"\n            gcode.append(retract_gcode)\n            previous_point.Z += layer_h\n\n        gcode.append(f\"; End of layer {layer_index + 1}\")\n\n    # End G-code\n    # Replace with FDM-specific end G-code\n    end_gcode = [\n        \"; -- END GCODE --\",\n        \"M104 S0\",\n        \"M140 S0\",\n        \"G91 ;Relative positioning\",\n        \"G1 E-1 F300 ;Retract the filament slightly\",\n        \"G1 Z+0.5 E-5 X-20 Y-20 F3000 ;Move Z up and retract filament more\",\n        \"G28 X0 Y0 ;Move X/Y to min endstops\",\n        \"M84 ;Disable motors\",\n        \"; -- END OF END GCODE --\"\n    ]\n    gcode.extend(end_gcode)\n\n    printing_path_len = f\"{total_printing_distance:.{decimal_places}f} mm\"\n    layers = num_layers\n\n    return gcode, printing_time, printing_points, printing_path_len, layers\n\n# Example usage\ng_code, printing_time, printing_points, printing_path_len, layers = generate_gcode(\n    printing_path=printing_path,   # Your list of curves\n    nozzle_diameter=nozzle_diameter,  # You can specify a different nozzle diameter here\n    printing_speed=printing_speed,\n    m1_flux=m1_flux,\n    layer_h=layer_h,\n    e_absolute=e_absolute,\n    flux_mode=flux_mode,\n    m2_flux_start=m2_flux_start,\n    m2_flux_end=m2_flux_end,\n    density_kg_m3=density_kg_m3\n)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}