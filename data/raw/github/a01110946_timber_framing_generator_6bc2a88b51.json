{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/src/timber_framing_generator/framing_elements/blocking_parameters.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "src/timber_framing_generator/framing_elements/blocking_parameters.py",
  "instruction": "Parameters for row blocking configurations in timber framing.",
  "code": "# File: timber_framing_generator/framing_elements/blocking_parameters.py\n\n\"\"\"\nParameters for row blocking configurations in timber framing.\n\nThis module contains dataclasses and parameter configurations for\nrow blocking elements, including positioning data and geometric\nspecifications.\n\"\"\"\n\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Any, Optional, Union, Tuple\nimport Rhino.Geometry as rg\n\nfrom src.timber_framing_generator.config.framing import (\n    FRAMING_PARAMS,\n    BlockingPattern,\n    PROFILES,\n)\n\n\n@dataclass\nclass BlockingLayerConfig:\n    \"\"\"\n    Defines positioning and configuration for a row of blocking.\n    \n    Attributes:\n        height: Height from bottom plate to this row of blocking (in feet)\n        pattern: BlockingPattern enum indicating the pattern to use\n        profile_override: Optional override for the profile to use (default is wall profile)\n    \"\"\"\n    height: float\n    pattern: BlockingPattern = BlockingPattern.INLINE\n    profile_override: Optional[str] = None\n\n\nclass BlockingParameters:\n    \"\"\"\n    Parameters for row blocking configuration.\n    \n    Attributes:\n        include_blocking: Whether to include blocking\n        block_spacing: Vertical spacing between blocks in feet\n        first_block_height: Height of first row of blocking from bottom of wall in feet\n        pattern: Pattern of blocking arrangement (inline or staggered)\n    \"\"\"\n    \n    def __init__(\n        self,\n        include_blocking: bool = FRAMING_PARAMS.get(\"include_blocking\", True),\n        block_spacing: float = FRAMING_PARAMS.get(\"block_spacing\", 48.0/12.0),  # 4ft default\n        first_block_height: float = FRAMING_PARAMS.get(\"first_block_height\", 24.0/12.0),  # 2ft default\n        pattern: Union[BlockingPattern, str] = None\n    ):\n        \"\"\"\n        Initialize blocking parameters.\n        \n        Args:\n            include_blocking: Whether to include blocking in the wall\n            block_spacing: Vertical spacing between rows of blocking in feet\n            first_block_height: Height of first row of blocking in feet from wall base\n            pattern: Block pattern arrangement (inline or staggered)\n        \"\"\"\n        self.include_blocking = include_blocking\n        self.block_spacing = block_spacing\n        self.first_block_height = first_block_height\n        \n        # Handle string or enum pattern value\n        if pattern is None:\n            pattern_value = FRAMING_PARAMS.get(\"blocking_pattern\", \"inline\")\n            if isinstance(pattern_value, str):\n                pattern_str = pattern_value.lower().strip()\n                if pattern_str == \"staggered\":\n                    self.pattern = BlockingPattern.STAGGERED\n                else:\n                    self.pattern = BlockingPattern.INLINE\n            else:\n                self.pattern = pattern_value\n        elif isinstance(pattern, str):\n            pattern_str = pattern.lower().strip()\n            if pattern_str == \"staggered\":\n                self.pattern = BlockingPattern.STAGGERED\n            else:\n                self.pattern = BlockingPattern.INLINE\n        else:\n            self.pattern = pattern\n    \n    def get_block_profile(self, wall_profile_name: str) -> str:\n        \"\"\"\n        Get the block profile name based on the wall profile.\n        \n        Args:\n            wall_profile_name: Name of the wall profile\n            \n        Returns:\n            Name of profile to use for blocking elements\n        \"\"\"\n        # For most wall types, blocks use the same profile as the wall\n        return wall_profile_name\n    \n    def calculate_block_heights(self, wall_height: float) -> List[float]:\n        \"\"\"\n        Calculate blocking heights for a wall of a given height.\n        \n        Args:\n            wall_height: Total height of the wall in feet\n            \n        Returns:\n            List of heights from wall base to blocking center\n        \"\"\"\n        # Validate input\n        if wall_height <= 0:\n            return []\n            \n        # If blocking is disabled, return empty list\n        if not self.include_blocking:\n            return []\n            \n        # Start with the first block height\n        heights = [self.first_block_height]\n        \n        # Add additional heights based on spacing\n        current_height = self.first_block_height\n        \n        # Keep adding heights until we exceed the wall height\n        while current_height + self.block_spacing < wall_height:\n            current_height += self.block_spacing\n            heights.append(current_height)\n            \n        return heights\n        \n    def __str__(self) -> str:\n        \"\"\"Return string representation of blocking parameters.\"\"\"\n        return (f\"BlockingParameters(include={self.include_blocking}, \"\n                f\"spacing={self.block_spacing}, \"\n                f\"first_height={self.first_block_height}, \"\n                f\"pattern={self.pattern})\")\n                \n    def __repr__(self) -> str:\n        \"\"\"Return representation of blocking parameters.\"\"\"\n        return self.__str__()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}