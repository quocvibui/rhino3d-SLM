{
  "source_url": "https://github.com/0000onoff/Projekt-HS24/blob/8a5cd818ae9ed6e0128f64dcd94d646e8e797503/ironpython-stubs-master/release/stubs.min/Rhino/Runtime/InteropWrappers.py",
  "repo": "0000onoff/Projekt-HS24",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "ironpython-stubs-master/release/stubs.min/Rhino/Runtime/InteropWrappers.py",
  "instruction": "NamespaceTracker represent a CLS namespace.",
  "code": "# encoding: utf-8\n# module Rhino.Runtime.InteropWrappers calls itself InteropWrappers\n# from RhinoCommon,Version=5.1.30000.16,Culture=neutral,PublicKeyToken=552281e97c755530\n# by generator 1.145\n\"\"\" NamespaceTracker represent a CLS namespace. \"\"\"\n# no imports\n\n# no functions\n# classes\n\nclass ClassArrayObjRef(object,IDisposable):\n \"\"\"\n Represents a wrapper to an unmanaged \"array\" (list) of CRhinoObjRef instances.\n\n    Wrapper for a C++ ON_ClassArray of CRhinoObjRef\n\n \n\n ClassArrayObjRef()\n\n ClassArrayObjRef(objrefs: IEnumerable[ObjRef])\n \"\"\"\n def Add(self,objref):\n  \"\"\"\n  Add(self: ClassArrayObjRef,objref: ObjRef)\n\n   Adds an ObjRef to the list.\n\n  \n\n   objref: An ObjRef to add.\n  \"\"\"\n  pass\n def ConstPointer(self):\n  \"\"\"\n  ConstPointer(self: ClassArrayObjRef) -> IntPtr\n\n  \n\n   Gets the const (immutable) pointer of this array.\n\n   Returns: The const pointer.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\"\n  Dispose(self: ClassArrayObjRef)\n\n   Actively reclaims unmanaged resources that this instance uses.\n  \"\"\"\n  pass\n def NonConstPointer(self):\n  \"\"\"\n  NonConstPointer(self: ClassArrayObjRef) -> IntPtr\n\n  \n\n   Gets the non-const pointer (for modification) of this array.\n\n   Returns: The non-const pointer.\n  \"\"\"\n  pass\n def ToNonConstArray(self):\n  \"\"\"\n  ToNonConstArray(self: ClassArrayObjRef) -> Array[ObjRef]\n\n  \n\n   Copies the unmanaged array to a managed counterpart.\n\n   Returns: The managed array.\n  \"\"\"\n  pass\n def __add__(self,*args):\n  \"\"\" x.__add__(y) <==> x+y \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n @staticmethod\n def __new__(self,objrefs=None):\n  \"\"\"\n  __new__(cls: type)\n\n  __new__(cls: type,objrefs: IEnumerable[ObjRef])\n  \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the number of CRhinoObjRef instances in this array.\n\n\n\nGet: Count(self: ClassArrayObjRef) -> int\n\n\n\n\"\"\"\n\n\n\nclass ClassArrayOnObjRef(object,IDisposable):\n \"\"\"\n Represents a wrapper to an unmanaged \"array\" (list) of ON_ObjRef instances.\n\n    Wrapper for a C++ ON_ClassArray of ON_ObjRef\n\n \n\n ClassArrayOnObjRef()\n\n ClassArrayOnObjRef(objrefs: IEnumerable[ObjRef])\n \"\"\"\n def Add(self,objref):\n  \"\"\"\n  Add(self: ClassArrayOnObjRef,objref: ObjRef)\n\n   Adds an ObjRef to the list.\n\n  \n\n   objref: An ObjRef to add.\n  \"\"\"\n  pass\n def ConstPointer(self):\n  \"\"\"\n  ConstPointer(self: ClassArrayOnObjRef) -> IntPtr\n\n  \n\n   Gets the const (immutable) pointer of this array.\n\n   Returns: The const pointer.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\"\n  Dispose(self: ClassArrayOnObjRef)\n\n   Actively reclaims unmanaged resources that this instance uses.\n  \"\"\"\n  pass\n def NonConstPointer(self):\n  \"\"\"\n  NonConstPointer(self: ClassArrayOnObjRef) -> IntPtr\n\n  \n\n   Gets the non-const pointer (for modification) of this array.\n\n   Returns: The non-const pointer.\n  \"\"\"\n  pass\n def ToNonConstArray(self):\n  \"\"\"\n  ToNonConstArray(self: ClassArrayOnObjRef) -> Array[ObjRef]\n\n  \n\n   Copies the unmanaged array to a managed counterpart.\n\n   Returns: The managed array.\n  \"\"\"\n  pass\n def __add__(self,*args):\n  \"\"\" x.__add__(y) <==> x+y \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n @staticmethod\n def __new__(self,objrefs=None):\n  \"\"\"\n  __new__(cls: type)\n\n  __new__(cls: type,objrefs: IEnumerable[ObjRef])\n  \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the number of ObjRef instances in this array.\n\n\n\nGet: Count(self: ClassArrayOnObjRef) -> int\n\n\n\n\"\"\"\n\n\n\nclass MeshPointDataStruct(object):\n \"\"\"\n This is only needed when passing values to the Rhino C++ core,ignore\n\n    for .NET plug-ins.\n \"\"\"\n m_ci_index=None\n m_ci_type=None\n m_edge_index=None\n m_et=None\n m_face_index=None\n m_Px=None\n m_Py=None\n m_Pz=None\n m_t0=None\n m_t1=None\n m_t2=None\n m_t3=None\n m_Triangle=None\n\n\nclass SimpleArrayBrepPointer(object,IDisposable):\n \"\"\"\n Wrapper for a C++ ON_SimpleArray<ON_Brep*> or ON_SimpleArray<const ON_Brep*>\n\n    If you are not writing C++ code then this class is not for you.\n\n \n\n SimpleArrayBrepPointer()\n \"\"\"\n def Add(self,brep,asConst):\n  \"\"\"\n  Add(self: SimpleArrayBrepPointer,brep: Brep,asConst: bool)\n\n   Adds a brep to the list.\n\n  \n\n   brep: A brep to add.\n\n   asConst: Whether this brep should be treated as non-modifiable.\n  \"\"\"\n  pass\n def ConstPointer(self):\n  \"\"\"\n  ConstPointer(self: SimpleArrayBrepPointer) -> IntPtr\n\n  \n\n   Gets the const (immutable) pointer of this array.\n\n   Returns: The const pointer.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\"\n  Dispose(self: SimpleArrayBrepPointer)\n\n   Actively reclaims unmanaged resources that this instance uses.\n  \"\"\"\n  pass\n def NonConstPointer(self):\n  \"\"\"\n  NonConstPointer(self: SimpleArrayBrepPointer) -> IntPtr\n\n  \n\n   Gets the non-const pointer (for modification) of this array.\n\n   Returns: The non-const pointer.\n  \"\"\"\n  pass\n def ToNonConstArray(self):\n  \"\"\"\n  ToNonConstArray(self: SimpleArrayBrepPointer) -> Array[Brep]\n\n  \n\n   Copies the unmanaged array to a managed counterpart.\n\n   Returns: The managed array.\n  \"\"\"\n  pass\n def __add__(self,*args):\n  \"\"\" x.__add__(y) <==> x+y \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the amount of breps in this array.\n\n\n\nGet: Count(self: SimpleArrayBrepPointer) -> int\n\n\n\n\"\"\"\n\n\n\nclass SimpleArrayCurvePointer(object,IDisposable):\n \"\"\"\n Wrapper for a C++ ON_SimpleArray of ON_Curve* or const ON_Curve*.  If you are not\n\n    writing C++ code,then you can ignore this class.\n\n \n\n SimpleArrayCurvePointer()\n\n SimpleArrayCurvePointer(curves: IEnumerable[Curve])\n \"\"\"\n def ConstPointer(self):\n  \"\"\"\n  ConstPointer(self: SimpleArrayCurvePointer) -> IntPtr\n\n  \n\n   Gets the const (immutable) pointer of this array.\n\n   Returns: The const pointer.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\"\n  Dispose(self: SimpleArrayCurvePointer)\n\n   Actively reclaims unmanaged resources that this instance uses.\n  \"\"\"\n  pass\n def NonConstPointer(self):\n  \"\"\"\n  NonConstPointer(self: SimpleArrayCurvePointer) -> IntPtr\n\n  \n\n   Gets the non-const pointer (for modification) of this array.\n\n   Returns: The non-const pointer.\n  \"\"\"\n  pass\n def ToNonConstArray(self):\n  \"\"\"\n  ToNonConstArray(self: SimpleArrayCurvePointer) -> Array[Curve]\n\n  \n\n   Copies the unmanaged array to a managed counterpart.\n\n   Returns: The managed array.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n @staticmethod\n def __new__(self,curves=None):\n  \"\"\"\n  __new__(cls: type)\n\n  __new__(cls: type,curves: IEnumerable[Curve])\n  \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n\nclass SimpleArrayDouble(object,IDisposable):\n \"\"\"\n Wrapper for ON_SimpleArray<double>. If you are not writing C++ code,\n\n    then this class is not for you.\n\n \n\n SimpleArrayDouble()\n\n SimpleArrayDouble(items: IEnumerable[float])\n \"\"\"\n def ConstPointer(self):\n  \"\"\"\n  ConstPointer(self: SimpleArrayDouble) -> IntPtr\n\n  \n\n   Gets the const (immutable) pointer of this array.\n\n   Returns: The const pointer.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\"\n  Dispose(self: SimpleArrayDouble)\n\n   Actively reclaims unmanaged resources that this instance uses.\n  \"\"\"\n  pass\n def NonConstPointer(self):\n  \"\"\"\n  NonConstPointer(self: SimpleArrayDouble) -> IntPtr\n\n  \n\n   Gets the non-const pointer (for modification) of this array.\n\n   Returns: The non-const pointer.\n  \"\"\"\n  pass\n def ToArray(self):\n  \"\"\"\n  ToArray(self: SimpleArrayDouble) -> Array[float]\n\n  \n\n   Returns the managed counterpart of the unmanaged array.\n\n   Returns: The managed array.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n @staticmethod\n def __new__(self,items=None):\n  \"\"\"\n  __new__(cls: type)\n\n  __new__(cls: type,items: IEnumerable[float])\n  \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the amount of elements in this array.\n\n\n\nGet: Count(self: SimpleArrayDouble) -> int\n\n\n\n\"\"\"\n\n\n\nclass SimpleArrayGeometryPointer(object,IDisposable):\n \"\"\"\n Wrapper for a C++ ON_SimpleArray<ON_Geometry*>* or ON_SimpleArray<const ON_Geometry*>.\n\n    If you are not writing C++ code,then this class is not for you.\n\n \n\n SimpleArrayGeometryPointer()\n\n SimpleArrayGeometryPointer(geometry: IEnumerable[GeometryBase])\n\n SimpleArrayGeometryPointer(geometry: IEnumerable)\n \"\"\"\n def ConstPointer(self):\n  \"\"\"\n  ConstPointer(self: SimpleArrayGeometryPointer) -> IntPtr\n\n  \n\n   Gets the const (immutable) pointer of this array.\n\n   Returns: The const pointer.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\"\n  Dispose(self: SimpleArrayGeometryPointer)\n\n   Actively reclaims unmanaged resources that this instance uses.\n  \"\"\"\n  pass\n def NonConstPointer(self):\n  \"\"\"\n  NonConstPointer(self: SimpleArrayGeometryPointer) -> IntPtr\n\n  \n\n   Gets the non-const pointer (for modification) of this array.\n\n   Returns: The non-const pointer.\n  \"\"\"\n  pass\n def ToNonConstArray(self):\n  \"\"\"\n  ToNonConstArray(self: SimpleArrayGeometryPointer) -> Array[GeometryBase]\n\n  \n\n   Copies the unmanaged array to a managed counterpart.\n\n   Returns: The managed array.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n @staticmethod\n def __new__(self,geometry=None):\n  \"\"\"\n  __new__(cls: type)\n\n  __new__(cls: type,geometry: IEnumerable[GeometryBase])\n\n  __new__(cls: type,geometry: IEnumerable)\n  \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n\nclass SimpleArrayGuid(object,IDisposable):\n \"\"\"\n Wrapper for ON_SimpleArray<ON_UUID>. If you are not writing C++ code\n\n    then this class is not for you.\n\n \n\n SimpleArrayGuid()\n \"\"\"\n def ConstPointer(self):\n  \"\"\"\n  ConstPointer(self: SimpleArrayGuid) -> IntPtr\n\n  \n\n   Gets the const (immutable) pointer of this array.\n\n   Returns: The const pointer.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\"\n  Dispose(self: SimpleArrayGuid)\n\n   Actively reclaims unmanaged resources that this instance uses.\n  \"\"\"\n  pass\n def NonConstPointer(self):\n  \"\"\"\n  NonConstPointer(self: SimpleArrayGuid) -> IntPtr\n\n  \n\n   Gets the non-const pointer (for modification) of this array.\n\n   Returns: The non-const pointer.\n  \"\"\"\n  pass\n def ToArray(self):\n  \"\"\"\n  ToArray(self: SimpleArrayGuid) -> Array[Guid]\n\n  \n\n   Returns the managed counterpart of the unmanaged array.\n\n   Returns: The managed array.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the amount of elements in this array.\n\n\n\nGet: Count(self: SimpleArrayGuid) -> int\n\n\n\n\"\"\"\n\n\n\nclass SimpleArrayInt(object,IDisposable):\n \"\"\"\n Wrapper for ON_SimpleArray<int>. If you are not writing C++ code\n\n    then this class is not for you.\n\n \n\n SimpleArrayInt()\n\n SimpleArrayInt(values: IEnumerable[int])\n \"\"\"\n def ConstPointer(self):\n  \"\"\"\n  ConstPointer(self: SimpleArrayInt) -> IntPtr\n\n  \n\n   Gets the const (immutable) pointer of this array.\n\n   Returns: The const pointer.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\"\n  Dispose(self: SimpleArrayInt)\n\n   Actively reclaims unmanaged resources that this instance uses.\n  \"\"\"\n  pass\n def NonConstPointer(self):\n  \"\"\"\n  NonConstPointer(self: SimpleArrayInt) -> IntPtr\n\n  \n\n   Gets the non-const pointer (for modification) of this array.\n\n   Returns: The non-const pointer.\n  \"\"\"\n  pass\n def ToArray(self):\n  \"\"\"\n  ToArray(self: SimpleArrayInt) -> Array[int]\n\n  \n\n   Returns the managed counterpart of the unmanaged array.\n\n   Returns: The managed array.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n @staticmethod\n def __new__(self,values=None):\n  \"\"\"\n  __new__(cls: type)\n\n  __new__(cls: type,values: IEnumerable[int])\n  \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the amount of elements in this array.\n\n\n\nGet: Count(self: SimpleArrayInt) -> int\n\n\n\n\"\"\"\n\n\n\nclass SimpleArrayInterval(object,IDisposable):\n \"\"\"\n Wrapper for ON_SimpleArray<ON_Imterval>. If you are not writing C++ code\n\n    then this class is not for you.\n\n \n\n SimpleArrayInterval()\n \"\"\"\n def ConstPointer(self):\n  \"\"\"\n  ConstPointer(self: SimpleArrayInterval) -> IntPtr\n\n  \n\n   Gets the const (immutable) pointer of this array.\n\n   Returns: The const pointer.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\"\n  Dispose(self: SimpleArrayInterval)\n\n   Actively reclaims unmanaged resources that this instance uses.\n  \"\"\"\n  pass\n def NonConstPointer(self):\n  \"\"\"\n  NonConstPointer(self: SimpleArrayInterval) -> IntPtr\n\n  \n\n   Gets the non-const pointer (for modification) of this array.\n\n   Returns: The non-const pointer.\n  \"\"\"\n  pass\n def ToArray(self):\n  \"\"\"\n  ToArray(self: SimpleArrayInterval) -> Array[Interval]\n\n  \n\n   Returns the managed counterpart of the unmanaged array.\n\n   Returns: The managed array.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the amount of elements in this array.\n\n\n\nGet: Count(self: SimpleArrayInterval) -> int\n\n\n\n\"\"\"\n\n\n\nclass SimpleArrayLine(object,IDisposable):\n \"\"\"\n Wrapper for ON_SimpleArray<ON_Line>. If you are not writing C++ code\n\n    then this class is not for you.\n\n \n\n SimpleArrayLine()\n \"\"\"\n def ConstPointer(self):\n  \"\"\"\n  ConstPointer(self: SimpleArrayLine) -> IntPtr\n\n  \n\n   Gets the const (immutable) pointer of this array.\n\n   Returns: The const pointer.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\"\n  Dispose(self: SimpleArrayLine)\n\n   Actively reclaims unmanaged resources that this instance uses.\n  \"\"\"\n  pass\n def NonConstPointer(self):\n  \"\"\"\n  NonConstPointer(self: SimpleArrayLine) -> IntPtr\n\n  \n\n   Gets the non-const pointer (for modification) of this array.\n\n   Returns: The non-const pointer.\n  \"\"\"\n  pass\n def ToArray(self):\n  \"\"\"\n  ToArray(self: SimpleArrayLine) -> Array[Line]\n\n  \n\n   Copies the unmanaged array to a managed counterpart.\n\n   Returns: The managed array.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the amount of lines in this array.\n\n\n\nGet: Count(self: SimpleArrayLine) -> int\n\n\n\n\"\"\"\n\n\n\nclass SimpleArrayMeshPointer(object,IDisposable):\n \"\"\"\n Represents a wrapper to an unmanaged array of mesh pointers.\n\n    Wrapper for a C++ ON_SimpleArray of ON_Mesh* or const ON_Mesh*. If you are not\n\n    writing C++ code then this class is not for you.\n\n \n\n SimpleArrayMeshPointer()\n \"\"\"\n def Add(self,mesh,asConst):\n  \"\"\"\n  Add(self: SimpleArrayMeshPointer,mesh: Mesh,asConst: bool)\n\n   Adds a mesh to the list.\n\n  \n\n   mesh: A mesh to add.\n\n   asConst: Whether this mesh should be treated as non-modifiable.\n  \"\"\"\n  pass\n def ConstPointer(self):\n  \"\"\"\n  ConstPointer(self: SimpleArrayMeshPointer) -> IntPtr\n\n  \n\n   Gets the const (immutable) pointer of this array.\n\n   Returns: The const pointer.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\"\n  Dispose(self: SimpleArrayMeshPointer)\n\n   Actively reclaims unmanaged resources that this instance uses.\n  \"\"\"\n  pass\n def NonConstPointer(self):\n  \"\"\"\n  NonConstPointer(self: SimpleArrayMeshPointer) -> IntPtr\n\n  \n\n   Gets the non-const pointer (for modification) of this array.\n\n   Returns: The non-const pointer.\n  \"\"\"\n  pass\n def ToNonConstArray(self):\n  \"\"\"\n  ToNonConstArray(self: SimpleArrayMeshPointer) -> Array[Mesh]\n\n  \n\n   Copies the unmanaged array to a managed counterpart.\n\n   Returns: The managed array.\n  \"\"\"\n  pass\n def __add__(self,*args):\n  \"\"\" x.__add__(y) <==> x+y \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the amount of meshes in this array.\n\n\n\nGet: Count(self: SimpleArrayMeshPointer) -> int\n\n\n\n\"\"\"\n\n\n\nclass SimpleArrayPoint2d(object,IDisposable):\n \"\"\"\n ON_SimpleArray<ON_2dPoint> class wrapper.  If you are not writing\n\n    C++ code then this class is not for you.\n\n \n\n SimpleArrayPoint2d()\n \"\"\"\n def ConstPointer(self):\n  \"\"\"\n  ConstPointer(self: SimpleArrayPoint2d) -> IntPtr\n\n  \n\n   Gets the const (immutable) pointer of this array.\n\n   Returns: The const pointer.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\"\n  Dispose(self: SimpleArrayPoint2d)\n\n   Actively reclaims unmanaged resources that this instance uses.\n  \"\"\"\n  pass\n def NonConstPointer(self):\n  \"\"\"\n  NonConstPointer(self: SimpleArrayPoint2d) -> IntPtr\n\n  \n\n   Gets the non-const pointer (for modification) of this array.\n\n   Returns: The non-const pointer.\n  \"\"\"\n  pass\n def ToArray(self):\n  \"\"\"\n  ToArray(self: SimpleArrayPoint2d) -> Array[Point2d]\n\n  \n\n   Copies the unmanaged array to a managed counterpart.\n\n   Returns: The managed array.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the amount of points in this array.\n\n\n\nGet: Count(self: SimpleArrayPoint2d) -> int\n\n\n\n\"\"\"\n\n\n\nclass SimpleArrayPoint3d(object,IDisposable):\n \"\"\"\n ON_SimpleArray<ON_3dPoint>,ON_3dPointArray,ON_PolyLine all have the same size\n\n    This class wraps all of these C++ versions.  If you are not writing C++ code then this\n\n    class is not for you.\n\n \n\n SimpleArrayPoint3d()\n \"\"\"\n def ConstPointer(self):\n  \"\"\"\n  ConstPointer(self: SimpleArrayPoint3d) -> IntPtr\n\n  \n\n   Gets the const (immutable) pointer of this array.\n\n   Returns: The const pointer.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\"\n  Dispose(self: SimpleArrayPoint3d)\n\n   Actively reclaims unmanaged resources that this instance uses.\n  \"\"\"\n  pass\n def NonConstPointer(self):\n  \"\"\"\n  NonConstPointer(self: SimpleArrayPoint3d) -> IntPtr\n\n  \n\n   Gets the non-const pointer (for modification) of this array.\n\n   Returns: The non-const pointer.\n  \"\"\"\n  pass\n def ToArray(self):\n  \"\"\"\n  ToArray(self: SimpleArrayPoint3d) -> Array[Point3d]\n\n  \n\n   Copies the unmanaged array to a managed counterpart.\n\n   Returns: The managed array.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n Count=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the amount of points in this array.\n\n\n\nGet: Count(self: SimpleArrayPoint3d) -> int\n\n\n\n\"\"\"\n\n\n\nclass SimpleArraySurfacePointer(object,IDisposable):\n \"\"\"\n Wrapper for a C++ ON_SimpleArray of ON_Surface* or const ON_Surface*.  If\n\n    you are not writing C++ code then this class is not for you.\n\n \n\n SimpleArraySurfacePointer()\n \"\"\"\n def ConstPointer(self):\n  \"\"\"\n  ConstPointer(self: SimpleArraySurfacePointer) -> IntPtr\n\n  \n\n   Gets the const (immutable) pointer of this array.\n\n   Returns: The const pointer.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\"\n  Dispose(self: SimpleArraySurfacePointer)\n\n   Actively reclaims unmanaged resources that this instance uses.\n  \"\"\"\n  pass\n def NonConstPointer(self):\n  \"\"\"\n  NonConstPointer(self: SimpleArraySurfacePointer) -> IntPtr\n\n  \n\n   Gets the non-const pointer (for modification) of this array.\n\n   Returns: The non-const pointer.\n  \"\"\"\n  pass\n def ToNonConstArray(self):\n  \"\"\"\n  ToNonConstArray(self: SimpleArraySurfacePointer) -> Array[Surface]\n\n  \n\n   Copies the unmanaged array to a managed counterpart.\n\n     Elements are made non-const.\n\n   Returns: The managed array.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n\nclass StringHolder(object,IDisposable):\n \"\"\"\n This class is used to pass strings back and forth between managed\n\n    and unmanaged code.  This should not be be needed by plug-ins.\n\n \n\n StringHolder()\n \"\"\"\n def ConstPointer(self):\n  \"\"\"\n  ConstPointer(self: StringHolder) -> IntPtr\n\n  \n\n   C++ pointer used to access the ON_wString,managed plug-ins should\n\n     never need this.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\"\n  Dispose(self: StringHolder)\n\n   IDispose implementation\n  \"\"\"\n  pass\n @staticmethod\n def GetString(pStringHolder):\n  \"\"\"\n  GetString(pStringHolder: IntPtr) -> str\n\n  \n\n   Get managed string from unmanaged ON_wString pointer.\n  \"\"\"\n  pass\n def NonConstPointer(self):\n  \"\"\"\n  NonConstPointer(self: StringHolder) -> IntPtr\n\n  \n\n   C++ pointer used to access the ON_wString,managed plug-ins should\n\n     never need this.\n  \"\"\"\n  pass\n def ToString(self):\n  \"\"\"\n  ToString(self: StringHolder) -> str\n\n  \n\n   Marshal unmanaged ON_wString to a managed .NET string\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n def __str__(self,*args):\n  pass\n\nclass StringWrapper(object,IDisposable):\n \"\"\"\n Represents a wrapper to an unmanaged OpenNurbs string.\n\n    Wraps a C++ ON_wString*.\n\n \n\n StringWrapper()\n\n StringWrapper(s: str)\n \"\"\"\n def Dispose(self):\n  \"\"\"\n  Dispose(self: StringWrapper)\n\n   Actively reclaims unmanaged resources that this instance uses.\n  \"\"\"\n  pass\n @staticmethod\n def GetStringFromPointer(pConstON_wString):\n  \"\"\"\n  GetStringFromPointer(pConstON_wString: IntPtr) -> str\n\n  \n\n   Get string from an ON_wString*\n  \"\"\"\n  pass\n def SetString(self,s):\n  \"\"\"\n  SetString(self: StringWrapper,s: str)\n\n   Set contents of this string.\n\n  \n\n   s: The new string.\n  \"\"\"\n  pass\n @staticmethod\n def SetStringOnPointer(pON_wString,s):\n  \"\"\"\n  SetStringOnPointer(pON_wString: IntPtr,s: str)\n\n   Set contents of an ON_wString*\n  \"\"\"\n  pass\n def ToString(self):\n  \"\"\"\n  ToString(self: StringWrapper) -> str\n\n  \n\n   Returns the string contents of this wrapper.\n\n   Returns: A managed string.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n @staticmethod\n def __new__(self,s=None):\n  \"\"\"\n  __new__(cls: type)\n\n  __new__(cls: type,s: str)\n  \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n def __str__(self,*args):\n  pass\n ConstPointer=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the const pointer (const ON_wString*).\n\n\n\nGet: ConstPointer(self: StringWrapper) -> IntPtr\n\n\n\n\"\"\"\n\n NonConstPointer=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the non-const pointer (ON_wString*).\n\n\n\nGet: NonConstPointer(self: StringWrapper) -> IntPtr\n\n\n\n\"\"\"\n\n\n\n",
  "language": "python",
  "imports": [
    "RhinoCommon"
  ],
  "has_docstring": true
}