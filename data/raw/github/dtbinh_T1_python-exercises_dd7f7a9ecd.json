{
  "source_url": "https://github.com/dtbinh/T1_python-exercises/blob/f4710c3dc2ba8ddb3e3e9069ab8d65df674463ab/07_ur_online/shifted_frames_setup/compas/src/compas_rhino/helpers/mesh.py",
  "repo": "dtbinh/T1_python-exercises",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "07_ur_online/shifted_frames_setup/compas/src/compas_rhino/helpers/mesh.py",
  "instruction": null,
  "code": "from __future__ import print_function\n\nimport ast\n\nfrom compas.utilities import geometric_key\nfrom compas.utilities import color_to_colordict\n\nfrom compas_rhino.geometry.surface import RhinoSurface\n\nimport compas_rhino\n\ntry:\n    import Rhino\n    from Rhino.Geometry import Point3d\n    import scriptcontext as sc\n    import rhinoscriptsyntax as rs\nexcept ImportError:\n    import platform\n    if platform.python_implementation() == 'IronPython':\n        raise\n\n\n__author__    = ['Tom Van Mele', ]\n__copyright__ = 'Copyright 2016 - Block Research Group, ETH Zurich'\n__license__   = 'MIT License'\n__email__     = 'vanmelet@ethz.ch'\n\n\n__all__ = [\n    'mesh_from_guid',\n    'mesh_from_surface',\n    'mesh_from_surface_uv',\n    'mesh_from_surface_heightfield',\n    'draw_mesh',\n    'draw_mesh_as_faces',\n    'select_mesh_vertices',\n    'select_mesh_vertex',\n    'select_mesh_edges',\n    'select_mesh_edge',\n    'select_mesh_faces',\n    'select_mesh_face',\n    'update_mesh_vertex_attributes',\n    'update_mesh_edge_attributes',\n    'update_mesh_face_attributes',\n    'display_mesh_vertex_labels',\n    'display_mesh_edge_labels',\n    'display_mesh_face_labels',\n    'move_mesh_vertex',\n]\n\n\n# ==============================================================================\n# constructors\n# ==============================================================================\n\n\ndef mesh_from_guid(cls, guid, **kwargs):\n    vertices, faces = compas_rhino.get_mesh_vertices_and_faces(guid)\n    faces = [face[:-1] if face[-2] == face[-1] else face for face in faces]\n    mesh  = cls.from_vertices_and_faces(vertices, faces)\n    mesh.attributes.update(kwargs)\n    return mesh\n\n\ndef mesh_from_surface(cls, guid, **kwargs):\n    gkey_xyz = {}\n    faces = []\n    obj = sc.doc.Objects.Find(guid)\n\n    if not obj.Geometry.HasBrepForm:\n        return\n\n    brep = Rhino.Geometry.Brep.TryConvertBrep(obj.Geometry)\n\n    for loop in brep.Loops:\n        curve = loop.To3dCurve()\n        segments = curve.Explode()\n        face = []\n        sp = segments[0].PointAtStart\n        ep = segments[0].PointAtEnd\n        sp_gkey = geometric_key(sp)\n        ep_gkey = geometric_key(ep)\n        gkey_xyz[sp_gkey] = sp\n        gkey_xyz[ep_gkey] = ep\n        face.append(sp_gkey)\n        face.append(ep_gkey)\n\n        for segment in segments[1:-1]:\n            ep = segment.PointAtEnd\n            ep_gkey = geometric_key(ep)\n            face.append(ep_gkey)\n            gkey_xyz[ep_gkey] = ep\n\n        faces.append(face)\n\n    gkey_index = {gkey: index for index, gkey in enumerate(gkey_xyz)}\n    vertices = [list(xyz) for gkey, xyz in gkey_xyz.items()]\n    faces = [[gkey_index[gkey] for gkey in f] for f in faces]\n    mesh = cls.from_vertices_and_faces(vertices, faces)\n    mesh.attributes.update(kwargs)\n\n    return mesh\n\n\ndef mesh_from_surface_uv(cls, guid, density=(10, 10), **kwargs):\n    return mesh_from_surface_heightfield(cls, guid, density=density, **kwargs)\n\n\ndef mesh_from_surface_heightfield(cls, guid, density=(10, 10), **kwargs):\n    \"\"\"Create a mesh data structure from a point grid aligned with the uv space of a Rhino NURBS surface.\n\n    Parameters:\n        cls (compas.datastructures.mesh.Mesh): The class of mesh that will be created.\n        guid (str): The GUID of the Rhino surface.\n        density (tuple): Optional. The density of the grid in the direction of u and v.\n        kwargs (dict): Optional. Mesh attributes in the form of keyword arguments.\n\n    Returns:\n        compas.datastructures.mesh.Mesh: The mesh that was created.\n\n    \"\"\"\n    try:\n        u, v = density\n    except Exception:\n        u, v = density, density\n\n    surface = RhinoSurface(guid)\n\n    mesh = cls()\n    mesh.attributes.update(kwargs)\n\n    vertices = surface.heightfield(density=(u, v), over_space=True)\n\n    for x, y, z in vertices:\n        mesh.add_vertex(x=x, y=y, z=z)\n\n    for i in range(u - 1):\n        for j in range(v - 1):\n            face = ((i + 0) * v + j,\n                    (i + 0) * v + j + 1,\n                    (i + 1) * v + j + 1,\n                    (i + 1) * v + j)\n            mesh.add_face(face)\n\n    return mesh\n\n\n# ==============================================================================\n# drawing\n# ==============================================================================\n\n# change clear to clearlayer\n# remove redraw?\n# process color spec into color dict\n\ndef draw_mesh(mesh,\n              layer=None,\n              clear_layer=False,\n              show_faces=True,\n              show_vertices=False,\n              show_edges=False,\n              show_wireframe=False,\n              vertexcolor=None,\n              edgecolor=None,\n              wireframecolor=None,\n              facecolor=None,\n              ):\n    \"\"\"\n    Draw a mesh object in Rhino.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        layer (str): Optional. The layer to draw in. Default is ``None``.\n        clear_layer (bool): Optional. Clear the drawing layer. Default is ``True``.\n        show_faces (bool): Optional. Show the faces. Default is ``True``.\n        show_vertices (bool): Optional. Show the vertices. Default is ``True``.\n        show_edges (bool): Optional. Show the edges. Default is ``True``.\n        vertexcolor (str, tuple, list, dict): Optional. The vertex color specification. Default is ``None``.\n        edgecolor (str, tuple, list, dict): Optional. The edge color specification. Default is ``None``.\n        facecolor (str, tuple, list, dict): Optional. The face color specification. Default is ``None``.\n        redraw (bool): Optional. Redraw instructions. Default is ``True``.\n\n    Note:\n        Colors can be specifiedin different ways:\n\n        * str: A hexadecimal color that will be applied to all elements subject to the specification.\n        * tuple, list: RGB color that will be applied to all elements subject to the specification.\n        * dict: RGB or hex color dict with a specification for some or all of the related elements.\n\n    Important:\n        RGB colors should specify color values between 0 and 255.\n\n    \"\"\"\n\n    vertexcolor = color_to_colordict(vertexcolor,\n                                     mesh.vertices(),\n                                     default=mesh.attributes['color.vertex'],\n                                     colorformat='rgb',\n                                     normalize=False)\n\n    edgecolor = color_to_colordict(edgecolor,\n                                   mesh.edges(),\n                                   default=mesh.attributes['color.edge'],\n                                   colorformat='rgb',\n                                   normalize=False)\n\n    # facecolor = color_to_colordict(facecolor,\n    #                                mesh.faces(),\n    #                                default=mesh.attributes['color.face'],\n    #                                colorformat='rgb',\n    #                                normalize=False)\n\n    guids = compas_rhino.get_objects(name='{0}.*'.format(mesh.attributes['name']))\n    compas_rhino.delete_objects(guids)\n\n    if clear_layer:\n        if not layer:\n            compas_rhino.clear_current_layer()\n        else:\n            compas_rhino.clear_layer(layer)\n\n    if show_faces:\n        key_index = {key: index for index, key in enumerate(mesh.vertices())}\n        xyz       = [mesh.vertex_coordinates(key) for key in mesh.vertices()]\n        faces     = []\n        color     = mesh.attributes['color.face']\n\n        for fkey in mesh.face:\n            face = mesh.face_vertices(fkey, ordered=True)\n            v = len(face)\n\n            if v < 3:\n                print('Degenerate face: {0} => {1}'.format(fkey, face))\n            elif v == 3:\n                faces.append([key_index[k] for k in face + [face[-1]]])\n            elif v == 4:\n                faces.append([key_index[k] for k in face])\n            else:\n                c = len(xyz)\n                xyz.append(mesh.face_center(fkey))\n                for i in range(-1, len(face) - 1):\n                    key = face[i]\n                    nbr = face[i + 1]\n                    vertices = [c, key_index[key], key_index[nbr], key_index[nbr]]\n                    faces.append(vertices)\n\n        compas_rhino.xdraw_mesh(xyz,\n                                faces,\n                                color,\n                                '{0}.mesh'.format(mesh.attributes['name']),\n                                layer=layer,\n                                clear=False,\n                                redraw=False)\n\n    if show_edges:\n        lines = []\n        color = mesh.attributes['color.edge']\n        for u, v in mesh.edges():\n            lines.append({\n                'start': mesh.vertex_coordinates(u),\n                'end'  : mesh.vertex_coordinates(v),\n                'name' : '{0}.edge.{1}-{2}'.format(mesh.attributes['name'], repr(u), repr(v)),\n                'color': edgecolor.get((u, v), color),\n            })\n        compas_rhino.xdraw_lines(lines, layer=layer, clear=False, redraw=False)\n\n    if show_wireframe:\n        lines = []\n        color = mesh.attributes['color.edge']\n        for u, v in mesh.wireframe():\n            lines.append({\n                'start': mesh.vertex_coordinates(u),\n                'end'  : mesh.vertex_coordinates(v),\n                'name' : '{0}.edge.{1}-{2}'.format(mesh.attributes['name'], repr(u), repr(v)),\n                'color': edgecolor.get((u, v), color),\n            })\n        compas_rhino.xdraw_lines(lines, layer=layer, clear=False, redraw=False)\n\n    if show_vertices:\n        points = []\n        color  = mesh.attributes['color.vertex']\n        for key in mesh.vertices():\n            points.append({\n                'pos'  : mesh.vertex_coordinates(key),\n                'name' : '{0}.vertex.{1}'.format(mesh.attributes['name'], repr(key)),\n                'color': vertexcolor.get(key, color),\n            })\n        compas_rhino.xdraw_points(points, layer=layer, clear=False, redraw=False)\n\n    rs.EnableRedraw()\n    rs.Redraw()\n\n\ndef draw_mesh_as_faces(mesh,\n                       layer=None,\n                       clear_layer=False,\n                       facecolor=None,\n                       redraw=True):\n\n    guids = compas_rhino.get_objects(name='{0}.*'.format(mesh.attributes['name']))\n    compas_rhino.delete_objects(guids)\n\n    if clear_layer:\n        if not layer:\n            compas_rhino.clear_current_layer()\n        else:\n            compas_rhino.clear_layer(layer)\n\n    facecolor = facecolor or {}\n\n    meshes = []\n\n    for fkey in mesh.faces():\n        vertices = mesh.face_coordinates(fkey)\n        faces = [range(len(vertices))]\n        color = facecolor.get(fkey, (255, 255, 255))\n        guid = compas_rhino.xdraw_mesh(vertices,\n                                       faces,\n                                       None,\n                                       '{0}.face.{1}'.format(mesh.attributes['name'], fkey),\n                                       layer=layer,\n                                       clear=False,\n                                       redraw=False)\n        compas_rhino.set_mesh_vertex_colors(guid, [color for i in range(len(vertices))])\n        meshes.append(guid)\n\n    if layer:\n        previous = rs.CurrentLayer(layer)\n\n    guid = rs.JoinMeshes(meshes, delete_input=True)\n\n    if layer:\n        rs.CurrentLayer(previous)\n\n    rs.ObjectName(guid, '{0}'.format(mesh.attributes['name']))\n\n    rs.EnableRedraw()\n    rs.Redraw()\n\n\n# ==============================================================================\n# selection\n# ==============================================================================\n\n\ndef select_mesh_vertices(mesh, message=\"Select mesh vertices.\"):\n    \"\"\"Select vertices of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        message (str): Optional. The message to display to the user.\n            Default is ``\"Select mesh vertices.\"``\n\n    Returns:\n        list: The keys of the selected vertices.\n\n    Note:\n        Selection is based on naming conventions.\n        When a mesh is drawn using the function :func:`draw_mesh`,\n        the point objects representing the vertices get assigned a name that\n        has the following pattern::\n\n            '{0}.vertex.{1}'.format(mesh.attributes['name'], key)\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino as rhino\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            keys = compas_rhino.select_mesh_vertices(mesh)\n\n            print(keys)\n\n\n    See Also:\n        * :func:`select_mesh_edges`\n        * :func:`select_mesh_faces`\n\n    \"\"\"\n    keys = []\n    guids = rs.GetObjects(message, preselect=True, filter=rs.filter.point | rs.filter.textdot)\n    if guids:\n        prefix = mesh.attributes['name']\n        seen = set()\n        for guid in guids:\n            name = rs.ObjectName(guid).split('.')\n            if 'vertex' in name:\n                if not prefix or prefix in name:\n                    key = name[-1]\n                    if not seen.add(key):\n                        key = ast.literal_eval(key)\n                        keys.append(key)\n    return keys\n\n\ndef select_mesh_vertex(mesh, message=\"Select a mesh vertex\"):\n    \"\"\"Select one vertex of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        message (str): Optional. The message to display to the user.\n            Default is ``\"Select mesh vertex.\"``\n\n    Returns:\n        * str: The key of the selected vertex.\n        * None: If no vertex was selected.\n\n    See Also:\n        * :func:`select_mesh_vertices`\n\n    \"\"\"\n    guid = rs.GetObject(message, preselect=True, filter=rs.filter.point | rs.filter.textdot)\n    if guid:\n        prefix = mesh.attributes['name']\n        name = rs.ObjectName(guid).split('.')\n        if 'vertex' in name:\n            if not prefix or prefix in name:\n                key = name[-1]\n                key = ast.literal_eval(key)\n                return key\n    return None\n\n\ndef select_mesh_edges(mesh, message=\"Select mesh edges\"):\n    \"\"\"Select edges of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        message (str): Optional. The message to display to the user.\n            Default is ``\"Select mesh edges.\"``\n\n    Returns:\n        list: The keys of the selected edges. Each key is a *uv* pair.\n\n    Note:\n        Selection is based on naming conventions.\n        When a mesh is drawn using the function :func:`draw_mesh`,\n        the curve objects representing the edges get assigned a name that\n        has the following pattern::\n\n            '{0}.edge.{1}-{2}'.format(mesh.attributes['name'], u, v)\n\n    See Also:\n        * :func:`select_mesh_vertices`\n        * :func:`select_mesh_faces`\n\n    \"\"\"\n    keys = []\n    guids = rs.GetObjects(message, preselect=True, filter=rs.filter.curve | rs.filter.textdot)\n    if guids:\n        prefix = mesh.attributes['name']\n        seen = set()\n        for guid in guids:\n            name = rs.ObjectName(guid).split('.')\n            if 'edge' in name:\n                if not prefix or prefix in name:\n                    key = name[-1]\n                    if not seen.add(key):\n                        u, v = key.split('-')\n                        u = ast.literal_eval(u)\n                        v = ast.literal_eval(v)\n                        keys.append((u, v))\n    return keys\n\n\ndef select_mesh_edge(mesh, message=\"Select a mesh edge\"):\n    \"\"\"Select one edge of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        message (str): Optional. The message to display to the user.\n            Default is ``\"Select mesh edges.\"``\n\n    Returns:\n        tuple: The key of the selected edge.\n        None: If no edge was selected.\n\n    See Also:\n        * :func:`select_mesh_edges`\n\n    \"\"\"\n    guid = rs.GetObject(message, preselect=True, filter=rs.filter.curve | rs.filter.textdot)\n    if guid:\n        prefix = mesh.attributes['name']\n        name = rs.ObjectName(guid).split('.')\n        if 'edge' in name:\n            if not prefix or prefix in name:\n                key = name[-1]\n                u, v = key.split('-')\n                u = ast.literal_eval(u)\n                v = ast.literal_eval(v)\n                return u, v\n    return None\n\n\ndef select_mesh_faces(mesh, message='Select mesh faces.'):\n    \"\"\"Select faces of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        message (str): Optional. The message to display to the user.\n            Default is ``\"Select mesh edges.\"``\n\n    Returns:\n        list: The keys of the selected faces.\n\n    Note:\n        Selection of faces is based on naming conventions.\n        When a mesh is drawn using the function :func:`draw_mesh`,\n        the curve objects representing the edges get assigned a name that\n        has the following pattern::\n\n            '{0}.edge.{1}-{2}'.format(mesh.attributes['name'], u, v)\n\n    Example:\n\n        .. code-block:: python\n            :emphasize-lines: 14\n\n            import compas\n            import compas_rhino as rhino as rhino\n\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            find_mesh_faces(mesh, mesh.leaves())\n\n            compas_rhino.draw_mesh(mesh)\n            compas_rhino.display_mesh_face_labels(mesh)\n\n            fkeys = compas_rhino.select_mesh_faces(mesh)\n\n            print(fkeys)\n\n\n    See Also:\n        * :func:`select_mesh_vertices`\n        * :func:`select_mesh_edges`\n\n    \"\"\"\n    keys = []\n    guids = rs.GetObjects(message, preselect=True, filter=rs.filter.textdot)\n    if guids:\n        prefix = mesh.attributes['name']\n        seen = set()\n        for guid in guids:\n            name = rs.ObjectName(guid).split('.')\n            if 'face' in name:\n                if not prefix or prefix in name:\n                    key = name[-1]\n                    if not seen.add(key):\n                        key = ast.literal_eval(key)\n                        keys.append(key)\n    return keys\n\n\ndef select_mesh_face(mesh, message='Select face.'):\n    \"\"\"Select one face of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        message (str): Optional. The message to display to the user.\n            Default is ``\"Select mesh edges.\"``\n\n    Returns:\n        tuple: The key of the selected face.\n        None: If no face was selected.\n\n    See Also:\n        * :func:`select_mesh_faces`\n\n    \"\"\"\n    guid = rs.GetObjects(message, preselect=True, filter=rs.filter.textdot)\n    if guid:\n        prefix = mesh.attributes['name']\n        name = rs.ObjectName(guid).split('.')\n        if 'face' in name:\n            if not prefix or prefix in name:\n                key = name[-1]\n                key = ast.literal_eval(key)\n                return key\n    return None\n\n\n# ==============================================================================\n# attributes\n# ==============================================================================\n\n\ndef update_mesh_attributes(mesh):\n    \"\"\"Update the attributes of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n\n    Returns:\n        bool: ``True`` if the update was successful, and ``False`` otherwise.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            if compas_rhino.update_mesh_attributes(mesh):\n                print('mesh attributes updated')\n            else:\n                print('mesh attributres not updated')\n\n\n    See Also:\n        * :func:`update_mesh_vertex_attributes`\n        * :func:`update_mesh_edge_attributes`\n        * :func:`update_mesh_face_attributes`\n\n    \"\"\"\n    names  = sorted(mesh.attributes.keys())\n    values = [str(mesh.attributes[name]) for name in names]\n    values = compas_rhino.update_named_values(names, values)\n    if values:\n        for name, value in zip(names, values):\n            try:\n                mesh.attributes[name] = ast.literal_eval(value)\n            except (TypeError, ValueError):\n                mesh.attributes[name] = value\n        return True\n    return False\n\n\ndef update_mesh_vertex_attributes(mesh, keys, names=None):\n    \"\"\"Update the attributes of the vertices of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        keys (tuple, list): The keys of the vertices to update.\n        names (tuple, list): Optional. The names of the atrtibutes to update.\n            Defaults to ``None``. If ``None``, all attributes are included in the\n            update.\n\n    Returns:\n        bool: ``True`` if the update was successful, and ``False`` otherwise.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino\n\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            keys = mesh.vertices()\n\n            if compas_rhino.update_mesh_vertex_attributes(mesh, keys):\n                print('mesh vertex attributes updated')\n            else:\n                print('mesh vertex attributes not updated')\n\n\n    See Also:\n        * :func:`update_mesh_attributes`\n        * :func:`update_mesh_edge_attributes`\n        * :func:`update_mesh_face_attributes`\n\n    \"\"\"\n    if not names:\n        names = mesh.default_vertex_attributes.keys()\n    names = sorted(names)\n    values = [mesh.vertex[keys[0]][name] for name in names]\n    if len(keys) > 1:\n        for i, name in enumerate(names):\n            for key in keys[1:]:\n                if values[i] != mesh.vertex[key][name]:\n                    values[i] = '-'\n                    break\n    values = map(str, values)\n    values = compas_rhino.update_named_values(names, values)\n    if values:\n        for name, value in zip(names, values):\n            if value != '-':\n                for key in keys:\n                    try:\n                        mesh.vertex[key][name] = ast.literal_eval(value)\n                    except (TypeError, ValueError):\n                        mesh.vertex[key][name] = value\n        return True\n    return False\n\n\ndef update_mesh_edge_attributes(mesh, keys, names=None):\n    \"\"\"Update the attributes of the edges of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        keys (tuple, list): The keys of the edges to update. Note that the keys\n            should be pairs of vertex keys.\n        names (tuple, list): Optional. The names of the atrtibutes to update.\n            Defaults to ``None``. If ``None``, all attributes are included in the\n            update.\n\n    Returns:\n        bool: ``True`` if the update was successful, and ``False`` otherwise.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino\n\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            keys = mesh.edges()\n\n            if compas_rhino.update_mesh_edge_attributes(mesh, keys):\n                print('mesh edge attributes updated')\n            else:\n                print('mesh edge attributes not updated')\n\n\n    See Also:\n        * :func:`update_mesh_attributes`\n        * :func:`update_mesh_vertex_attributes`\n        * :func:`update_mesh_face_attributes`\n\n    \"\"\"\n    if not names:\n        names = mesh.default_edge_attributes.keys()\n\n    names = sorted(names)\n\n    u, v = keys[0]\n    values = [mesh.edge[u][v][name] for name in names]\n\n    if len(keys) > 1:\n        for i, name in enumerate(names):\n            for u, v in keys[1:]:\n                if values[i] != mesh.edge[u][v][name]:\n                    values[i] = '-'\n                    break\n\n    values = map(str, values)\n    values = compas_rhino.update_named_values(names, values)\n\n    if values:\n        for name, value in zip(names, values):\n            if value != '-':\n                for u, v in keys:\n                    try:\n                        mesh.edge[u][v][name] = ast.literal_eval(value)\n                    except (TypeError, ValueError):\n                        mesh.edge[u][v][name] = value\n\n        return True\n\n    return False\n\n\ndef update_mesh_face_attributes(mesh, fkeys, names=None):\n    \"\"\"Update the attributes of the faces of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        keys (tuple, list): The keys of the faces to update.\n        names (tuple, list): Optional. The names of the atrtibutes to update.\n            Defaults to ``None``. If ``None``, all attributes are included in the\n            update.\n\n    Returns:\n        bool: ``True`` if the update was successful, and ``False`` otherwise.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino\n\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            keys = mesh.faces()\n\n            if compas_rhino.update_mesh_face_attributes(mesh, keys):\n                print('mesh face attributes updated')\n            else:\n                print('mesh face attributes not updated')\n\n\n    See Also:\n        * :func:`update_mesh_attributes`\n        * :func:`update_mesh_vertex_attributes`\n        * :func:`update_mesh_edge_attributes`\n\n    \"\"\"\n    if not mesh.facedata:\n        return\n    if not names:\n        names = sorted(mesh.default_face_attributes.keys())\n    values = [mesh.facedata[fkeys[0]][name] for name in names]\n    if len(fkeys) > 1:\n        for i, name in enumerate(names):\n            for fkey in fkeys[1:]:\n                if values[i] != mesh.facedata[fkey][name]:\n                    values[i] = '-'\n                    break\n    values = map(str, values)\n    values = compas_rhino.update_attributes(names, values)\n    if values:\n        for name, value in zip(names, values):\n            if value != '-':\n                for fkey in fkeys:\n                    try:\n                        mesh.facedata[fkey][name] = ast.literal_eval(value)\n                    except (TypeError, ValueError):\n                        mesh.facedata[fkey][name] = value\n        return True\n    return False\n\n\n# ==============================================================================\n# labels\n# ==============================================================================\n\n\ndef display_mesh_vertex_labels(mesh, attr_name=None, layer=None, color=None, formatter=None):\n    \"\"\"Display labels for the vertices of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        attr_name (str): Optional. The name of the attribute value to display in the label.\n            Default is ``None``. If ``None``, the key of the vertex is displayed.\n        layer (str): Optional. The layer to draw in. Default is ``None``.\n        color (str, tuple, list, dict): Optional. The color specification. Default is ``None``.\n            The following values are supported:\n\n                * str: A HEX color. For example, ``'#ff0000'``.\n                * tuple, list: RGB color. For example, ``(255, 0, 0)``.\n                * dict: A dictionary of RGB and/or HEX colors.\n\n            If ``None``, the default vertex color of the mesh will be used.\n        formatter (callable): Optional. A formatting function. Default is ``None``.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino\n\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            compas_rhino.display_mesh_vertex_labels(mesh)\n\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino\n\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            def formatter(value):\n                return '{0:.3f}'.format(value)\n\n            compas_rhino.display_mesh_vertex_labels(mesh, attr_name='x' formatter=formatter)\n\n\n    See Also:\n        * :func:`display_mesh_edge_labels`\n        * :func:`display_mesh_face_labels`\n\n    \"\"\"\n    compas_rhino.delete_objects(compas_rhino.get_objects(name=\"{0}.vertex.label.*\".format(mesh.attributes['name'])))\n\n    if not attr_name:\n        attr_name = 'key'\n\n    colordict = color_to_colordict(color,\n                                   mesh.vertices(),\n                                   default=mesh.attributes['color.vertex'],\n                                   colorformat='rgb',\n                                   normalize=False)\n    if formatter:\n        if not callable(formatter):\n            raise Exception('The provided formatter is not callable.')\n    else:\n        formatter = str\n\n    labels = []\n\n    for index, (key, attr) in enumerate(mesh.vertices(True)):\n        if 'key' == attr_name:\n            value = key\n        elif 'index' == attr_name:\n            value = index\n        else:\n            value = attr[attr_name]\n\n        labels.append({'pos'  : mesh.vertex_coordinates(key),\n                       'text' : formatter(value),\n                       'name' : '{0}.vertex.label.{1}'.format(mesh.attributes['name'], key),\n                       'color': colordict[key], })\n\n    compas_rhino.xdraw_labels(\n        labels,\n        layer=layer,\n        clear=False,\n        redraw=True\n    )\n\n\ndef display_mesh_edge_labels(mesh, attr_name=None, layer=None, color=None, formatter=None):\n    \"\"\"Display labels for the edges of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        attr_name (str): Optional. The name of the attribute value to display in the label.\n            Default is ``None``. If ``None``, the key of the edge is displayed.\n        layer (str): Optional. The layer to draw in. Default is ``None``.\n        color (str, tuple, list, dict): Optional. The color specification. Default is ``None``.\n            The following values are supported:\n\n                * str: A HEX color. For example, ``'#ff0000'``.\n                * tuple, list: RGB color. For example, ``(255, 0, 0)``.\n                * dict: A dictionary of RGB and/or HEX colors.\n\n            If ``None``, the default edge color of the mesh will be used.\n        formatter (callable): Optional. A formatting function. Default is ``None``.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino\n\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            compas_rhino.display_mesh_edge_labels(mesh)\n\n\n    See Also:\n        * :func:`display_mesh_vertex_labels`\n        * :func:`display_mesh_face_labels`\n\n    \"\"\"\n    compas_rhino.delete_objects(compas_rhino.get_objects(name=\"{0}.edge.label.*\".format(mesh.attributes['name'])))\n\n    if not attr_name:\n        attr_name = 'key'\n\n    colordict = color_to_colordict(color,\n                                   mesh.edges(),\n                                   default=mesh.attributes['color.edge'],\n                                   colorformat='rgb',\n                                   normalize=False)\n    if formatter:\n        if not callable(formatter):\n            raise Exception('The provided formatter is not callable.')\n    else:\n        formatter = str\n\n    labels = []\n\n    for index, (u, v, attr) in enumerate(mesh.edges(True)):\n\n        if attr_name == 'key':\n            value = '{0}-{1}'.format(u, v)\n        elif attr_name == 'index':\n            value = index\n        else:\n            value = attr[attr_name]\n\n        labels.append({'pos'  : mesh.edge_midpoint(u, v),\n                       'text' : formatter(value),\n                       'name' : '{0}.edge.label.{1}-{2}'.format(mesh.attributes['name'], u, v),\n                       'color': colordict[(u, v)], })\n\n    compas_rhino.xdraw_labels(\n        labels,\n        layer=layer,\n        clear=False,\n        redraw=True\n    )\n\n\ndef display_mesh_face_labels(mesh, attr_name=None, layer=None, color=None, formatter=None):\n    \"\"\"Display labels for the faces of a mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Mesh): The mesh object.\n        attr_name (str): Optional. The name of the attribute value to display in the label.\n            Default is ``None``. If ``None``, the key of the face is displayed.\n        layer (str): Optional. The layer to draw in. Default is ``None``.\n        color (str, tuple, list, dict): Optional. The color specification. Default is ``None``.\n            The following values are supported:\n\n                * str: A HEX color. For example, ``'#ff0000'``.\n                * tuple, list: RGB color. For example, ``(255, 0, 0)``.\n                * dict: A dictionary of RGB and/or HEX colors.\n\n            If ``None``, the default face color of the mesh will be used.\n        formatter (callable): Optional. A formatting function. Default is ``None``.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino\n\n            from compas.datastructures.mesh import Mesh\n\n            mesh = Mesh.from_obj(compas.get_data('faces.obj'))\n\n            compas_rhino.display_mesh_face_labels(mesh)\n\n\n    See Also:\n        * :func:`display_mesh_vertex_labels`\n        * :func:`display_mesh_edge_labels`\n\n    \"\"\"\n    compas_rhino.delete_objects(compas_rhino.get_objects(name=\"{0}.face.label.*\".format(mesh.attributes['name'])))\n\n    if not attr_name:\n        attr_name = 'key'\n\n    colordict = color_to_colordict(color,\n                                   mesh.faces(),\n                                   default=mesh.attributes['color.face'],\n                                   colorformat='rgb',\n                                   normalize=False)\n\n    if formatter:\n        if not callable(formatter):\n            raise Exception('The provided formatter is not callable.')\n    else:\n        formatter = str\n\n    labels = []\n\n    for index, fkey in enumerate(mesh.faces()):\n        if attr_name == 'key':\n            value = fkey\n        elif attr_name == 'index':\n            value = index\n        else:\n            value = mesh.facedata[fkey][attr_name]\n\n        labels.append({\n            'pos'  : mesh.face_centroid(fkey),\n            'text' : formatter(value),\n            'name' : '{0}.face.label.{1}'.format(mesh.attributes['name'], fkey),\n            'color': colordict[fkey]\n        })\n\n    compas_rhino.xdraw_labels(\n        labels,\n        layer=layer,\n        clear=False,\n        redraw=True\n    )\n\n\n# ==============================================================================\n# geometry\n# ==============================================================================\n\n\ndef display_mesh_vertex_normals(mesh,\n                                display=True,\n                                layer=None,\n                                scale=1.0,\n                                color=(0, 0, 255)):\n\n    guids = compas_rhino.get_objects(name='{0}.vertex.normal.*'.format(mesh.attributes['name']))\n    compas_rhino.delete_objects(guids)\n\n    if not display:\n        return\n\n    lines = []\n\n    for key in mesh.vertices():\n        normal = mesh.vertex_normal(key)\n        start  = mesh.vertex_coordinates(key)\n        end    = [start[axis] + normal[axis] for axis in range(3)]\n        name   = '{0}.vertex.normal.{1}'.format(mesh.attributes['name'], key)\n\n        lines.append({\n            'start': start,\n            'end'  : end,\n            'name' : name,\n            'color': color,\n            'arrow': 'end',\n        })\n\n    compas_rhino.xdraw_lines(lines, layer=layer, clear=False, redraw=True)\n\n\ndef display_mesh_face_normals(mesh,\n                              display=True,\n                              layer=None,\n                              scale=1.0,\n                              color=(0, 0, 255)):\n\n    guids = compas_rhino.get_objects(name='{0}.face.normal.*'.format(mesh.attributes['name']))\n    compas_rhino.delete_objects(guids)\n\n    if not display:\n        return\n\n    lines = []\n\n    for fkey in mesh.faces():\n        normal = mesh.face_normal(fkey)\n        start  = mesh.face_center(fkey)\n        end    = [start[axis] + normal[axis] for axis in range(3)]\n        name   = '{0}.face.normal.{1}'.format(mesh.attributes['name'], fkey)\n\n        lines.append({\n            'start' : start,\n            'end'   : end,\n            'name'  : name,\n            'color' : color,\n            'arrow' : 'end',\n        })\n\n    compas_rhino.xdraw_lines(lines, layer=layer, clear=False, redraw=True)\n\n\n# ==============================================================================\n# geometry\n# ==============================================================================\n\n\ndef move_mesh_vertex(mesh, key, constraint=None, allow_off=None, redraw=True):\n    \"\"\"Move on vertex of the mesh.\n\n    Parameters:\n        mesh (compas.datastructures.mesh.Network): The mesh object.\n        key (str): The vertex to move.\n        constraint (Rhino.Geometry): Optional. A ``Rhino.Geometry`` object to\n            constrain the movement to. Default is ``None``.\n        allow_off (bool): Optional. Allow the vertex to move off the constraint.\n            Default is ``None``.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as rhino\n\n            from compas.datastructures.mesh import Network\n\n            mesh = Mesh.from_obj(compas.get_data('lines.obj'))\n\n            key = compas_rhino.select_mesh_vertex(mesh)\n\n            if key:\n                compas_rhino.move_mesh_vertex(mesh, key)\n\n    \"\"\"\n    color = Rhino.ApplicationSettings.AppearanceSettings.FeedbackColor\n    nbrs  = [mesh.vertex_coordinates(nbr) for nbr in mesh.halfedge[key]]\n    nbrs  = [Point3d(*xyz) for xyz in nbrs]\n\n    def OnDynamicDraw(sender, e):\n        for ep in nbrs:\n            sp = e.CurrentPoint\n            e.Display.DrawDottedLine(sp, ep, color)\n\n    gp = Rhino.Input.Custom.GetPoint()\n    gp.SetCommandPrompt('Point to move to?')\n    gp.DynamicDraw += OnDynamicDraw\n\n    if constraint:\n        if allow_off is not None:\n            gp.Constrain(constraint, allow_off)\n        else:\n            gp.Constrain(constraint)\n\n    gp.Get()\n\n    if gp.CommandResult() == Rhino.Commands.Result.Success:\n        pos = list(gp.Point())\n        mesh.vertex[key]['x'] = pos[0]\n        mesh.vertex[key]['y'] = pos[1]\n        mesh.vertex[key]['z'] = pos[2]\n\n    if redraw:\n        try:\n            mesh.draw()\n        except AttributeError:\n            # this may result in the mesh being drawn in a different layer then before\n            draw_mesh(mesh)\n\n\n# ==============================================================================\n# Debugging\n# ==============================================================================\n\nif __name__ == \"__main__\":\n\n    pass\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}