{
  "source_url": "https://github.com/TTM-KK/TimberFormOptimization/blob/a728057ff3bfbfb7995b309e835a6278a6e86fcc/GA/Method.py",
  "repo": "TTM-KK/TimberFormOptimization",
  "repo_stars": 0,
  "repo_description": "This is a Form Generate Project, using non preform timber.",
  "license": "unknown",
  "filepath": "GA/Method.py",
  "instruction": "Method",
  "code": "# -*- coding: UTF-8 -*-\n\nimport random as rnd\nimport copy\nimport rhinoscriptsyntax as rs\nimport Rhino\nimport Rhino.Geometry\nimport scriptcontext\n\n\ndef copy_timber_objects(timber_instance, list_srf_temp, list_center_line_temp):\n    \"\"\"\n    サーフェスと軸線をリストに保存するためにdeepcopyする\n    :param timber_instance: Timberインスタンス\n    :param list_srf_temp: コピーするリスと\n    :param list_center_line_temp: コピーするリスト\n    :return: なし。\n    \"\"\"\n    # center_line = rs.CopyObject(timber_instance.center_line)\n    # srf = rs.CopyObject(timber_instance.surface)\n    center_line = copy.deepcopy(timber_instance.center_line)\n    # center_line = timber_instance.center_line\n    srf = copy.deepcopy(timber_instance.surface)\n    # srf = timber_instance.surface\n    # mark_line1 = rs.CopyObject(timber_instance.two_mark_line[0])\n    # mark_line2 = rs.CopyObject(timber_instance.two_mark_line[1])\n    # rs.CopyObject(timber_1.drill_line_list, vector_move)\n    list_srf_temp.append(srf)\n    list_center_line_temp.append(center_line)\n\n\ndef confirm_pop_divide(num_timber, pop_instance1):\n    \"\"\"\n    個体がバラけていないかどうかを判定するアルゴリズム\n    :param num_timber: 一個体を構成する木材の数\n    :param pop_instance1: 個体のインスタンス\n    :return: もし木材同士がバラけていないのならば、Trueを返す。\n    \"\"\"\n    # temp_partner_list  = []\n    # for i in range(len(pop_instance1.used_list)):\n    #     temp_partner_list.append(pop_instance1.used_list[i].partner_tim)\n\n    counter_list = [i - i for i in range(num_timber)]  # [0,0,0,0.....]\n    confirm_list = [i for i in range(num_timber)]  # [0,1,2,3,4]\n    emerge_list = []\n    loop = True\n    counter = -1\n\n    # print('counter_list', counter_list)\n    # print('confirm_list', confirm_list)\n    # print('emerge_list', emerge_list)\n\n    partner = pop_instance1.used_list[0].partner_tim\n    tim_name = pop_instance1.used_list[0].id\n\n    if tim_name not in emerge_list:\n        emerge_list.append(tim_name)\n\n    counter_list[tim_name] = 1\n\n    if tim_name in confirm_list:\n        del confirm_list[confirm_list.index(tim_name)]\n\n    for i in range(len(partner)):\n        tim_id = partner[i]\n        if tim_id not in emerge_list:\n            emerge_list.append(tim_id)\n\n        counter_list[tim_id] = 1\n\n        # if tim_id in confirm_list:\n        #     del confirm_list[confirm_list.index(tim_id)]\n\n    # この時点で分裂していること確定。\n    if len(partner) == 0:\n        # print('partner is 0')\n        # print('counter_list', counter_list)\n        # print('confirm_list', confirm_list)\n        # print('emerge_list', emerge_list)\n        return False\n\n    for i in range(len(partner)):\n        if partner[i] in confirm_list:\n            tim_name = copy.deepcopy(partner[i])\n            break\n\n    while loop:\n        counter += 1\n        if counter > 500:\n            raise ValueError('infinite loop')\n\n        re_loop = False\n\n        for i in range(num_timber):\n            if pop_instance1.used_list[i].id == tim_name:\n                partner = pop_instance1.used_list[i].partner_tim\n\n                # 3つのリストを更新する\n                if tim_name not in emerge_list:\n                    emerge_list.append(tim_name)\n                counter_list[tim_name] = 1\n                if tim_name in confirm_list:\n                    del confirm_list[confirm_list.index(tim_name)]\n\n                for j in range(len(partner)):\n                    tim_id = partner[j]\n\n                    # 2つのリストを更新する\n                    if tim_id not in emerge_list:\n                        emerge_list.append(tim_id)\n                    counter_list[tim_id] = 1\n                    # if tim_id in confirm_list:\n                    #     del confirm_list[confirm_list.index(tim_id)]\n\n                counter_partner = 0\n                for j in range(len(partner)):\n                    if partner[j] in confirm_list:\n                        tim_name = copy.deepcopy(partner[j])\n                        break\n                    else:\n                        counter_partner += 1\n\n                if counter_partner == len(partner):\n                    # まだpartnerを確認していない部材があればtim_nameとしwhileを継続\n                    for j in range(len(emerge_list)):\n                        if emerge_list[j] in confirm_list:\n                            tim_name = copy.deepcopy(emerge_list[j])\n                            re_loop = True\n                            break\n\n                    if re_loop:\n                        break\n\n                    # すべての部材IDがリスト内に現れているならばcounter_list内はすべて１になっているはず。\n                    if 0 not in counter_list:\n                        # print('counter_list', counter_list)\n                        # print('confirm_list', confirm_list)\n                        # print('emerge_list', emerge_list)\n                        return True\n                    else:\n                        # print('counter_list', counter_list)\n                        # print('confirm_list', confirm_list)\n                        # print('emerge_list', emerge_list)\n                        return False\n\n                break\n\n            else:\n                pass\n\n        if re_loop:\n            continue\n\n        # この時点で分裂していること確定。\n        if len(partner) == 0:\n            # print('partner is 0')\n            # print('counter_list', counter_list)\n            # print('confirm_list', confirm_list)\n            # print('emerge_list', emerge_list)\n            return False\n\n\ndef decide_inheritance_timber(pop_instance1, pop_instance2, already_regenerate_list, generate_range):\n    \"\"\"\n    pop_2の中で継承する材を決定し、材の個体番号をreturnする。\n    :param pop_instance1:\n    :param pop_instance2:\n    :param already_regenerate_list:\n    :param generate_range:\n    :return: 1; pop2の継承する材のID　2: 継承する材の内pop1に接合している材のIDと接合相手のID --> [接合している材のID, 接合している相手の材のID]\n    \"\"\"\n\n    inherit_timber_id_list = []\n    connect_list = []\n    move_pop2_num_list = []\n\n    pop_num_1 = pop_instance1.population_id  # ttm change pop_index -> population_id\n    pop_num_2 = pop_instance2.population_id\n    num_range = pop_num_1 - pop_num_2\n\n    move_from_p = Rhino.Geometry.Point3d(0,0,0)\n    move_to_p = Rhino.Geometry.Point3d(num_range*generate_range*2,0,0)\n    vec_move = move_to_p - move_from_p\n    xf = Rhino.Geometry.Transform.Translation(vec_move)\n\n    for i in range(len(pop_instance2.used_list)):\n        if pop_instance2.used_list[i].id not in already_regenerate_list:\n            move_pop2_num_list.append(pop_instance2.used_list[i].id)\n        else:\n            continue\n\n    list_srf = []\n    list_axis = []\n    list_section_length = []\n    list_timber_num = []\n    for i in range(len(move_pop2_num_list)):\n        move_index = move_pop2_num_list[i]\n        for j in range(len(pop_instance2.used_list)):\n            if move_index == pop_instance2.used_list[j].id:\n                srf = copy.deepcopy(pop_instance2.used_list[j].surface)\n                axis = copy.deepcopy(pop_instance2.used_list[j].center_line)\n                srf.Transform(xf)\n                axis.Transform(xf)\n\n                list_srf.append(srf)\n                list_axis.append(axis)\n                list_section_length.append(pop_instance2.used_list[j].section_length)\n                list_timber_num.append(pop_instance2.used_list[j].id)\n\n    # 接触判定を行う。 TODO セグメントを増やすなどして精度を向上させる必要あり。\n    for i in range(len(list_srf)):\n        tim = list_axis[i]\n        tim_end_1 = tim.PointAtEnd\n        tim_start_1 = tim.PointAtStart\n        tim_line = Rhino.Geometry.Line(tim_end_1, tim_start_1)\n\n        intersection_flag = False\n        connect_flag = False\n        for j in range(len(already_regenerate_list)):\n            for k in range(len(pop_instance1.used_list)):\n                if already_regenerate_list[j] == pop_instance1.used_list[k].id:\n                    tim_other = pop_instance1.used_list[k].center_line\n                    tim_end = tim_other.PointAtEnd\n                    tim_start = tim_other.PointAtStart\n                    tim_other_line = Rhino.Geometry.Line(tim_end, tim_start)\n                    distance = tim_line.MinimumDistanceTo(tim_other_line)\n                    # print(\"distance\", distance)\n                    # if distance < list_section_length[i]/ 2 + pop_instance1.used_list[k].section_length:\n                    if distance < 200:\n                        intersection_flag = True\n                        # print(\"intersection_distance\", distance)\n\n                        if 80 < distance < 150:\n                            connect_flag = True\n                            intersection_flag = False\n                            partner_tim_name = already_regenerate_list[j]\n                        break\n                    else:\n                        break\n\n            if intersection_flag:\n                break\n        if intersection_flag:\n            pass\n        else:\n            inherit_timber_id_list.append(list_timber_num[i])\n            if connect_flag:\n                connect_list.append([list_timber_num[i], partner_tim_name])\n\n    return inherit_timber_id_list, connect_list\n\n\ndef decide_inheritance_tim_connected(pop_instance1, pop_instance2, already_regenerate_list, generate_range):\n    \"\"\"\n    pop_2の中で継承する材を決定し、材の個体番号をreturnする。\n    :param pop_instance1:\n    :param pop_instance2:\n    :param already_regenerate_list:\n    :param generate_range:\n    :return: 1; pop2の継承する材のID　2: 継承する材の内pop1に接合している材のIDと接合相手のID --> [接合している材のID, 接合している相手の材のID]\n    \"\"\"\n\n    segment_num = 20\n\n    inherit_timber_id_list = []\n    connect_list = []\n\n    # pop2をpop1の位置に動かすことで接触判定を行えるようにしている。\n    move_pop2_num_list = []\n\n    pop_num_1 = pop_instance1.population_id  # ttm change pop_index -> population_id\n    pop_num_2 = pop_instance2.population_id\n    num_range = pop_num_1 - pop_num_2\n\n    move_from_p = Rhino.Geometry.Point3d(0, 0, 0)\n    move_to_p = Rhino.Geometry.Point3d(num_range*generate_range*2, 0, 0)\n    vec_move = move_to_p - move_from_p\n    xf = Rhino.Geometry.Transform.Translation(vec_move)\n\n    # すでに生成されている部材をのぞく部材IDを一旦リスト内に格納する。\n    for i in range(len(pop_instance2.used_list)):\n        if pop_instance2.used_list[i].id not in already_regenerate_list:\n            move_pop2_num_list.append(pop_instance2.used_list[i].id)\n        else:\n            continue\n\n    list_srf = []\n    # list_axis = []\n    list_section_length = []\n    list_tim_id = []\n    for i in range(len(move_pop2_num_list)):\n        move_index = move_pop2_num_list[i]\n        for j in range(len(pop_instance2.used_list)):\n            if move_index == pop_instance2.used_list[j].id:\n                srf = copy.deepcopy(pop_instance2.used_list[j].surface)\n                # axis = copy.deepcopy(pop_instance2.used_list[j].center_line)\n                srf.Transform(xf)\n                # axis.Transform(xf)\n\n                list_srf.append(srf)\n                # list_axis.append(axis)\n                # list_section_length.append(pop_instance2.used_list[j].section_length)\n                list_tim_id.append(pop_instance2.used_list[j].id)\n\n    # surfaceを用いた接触判定をおこなう。\n    for i in range(len(list_srf)):\n        srf = list_srf[i]\n        tim1_segment_points, tim1_diameter = calculate_srf_segment_points(srf, segment_num)\n\n        intersection_flag = False\n        for j in range(len(already_regenerate_list)):\n            for k in range(len(pop_instance1.used_list)):\n                if already_regenerate_list[j] == pop_instance1.used_list[k].id:\n                    srf_other = pop_instance1.used_list[k].surface\n                    tim2_segment_points, tim2_diameter = calculate_srf_segment_points(srf_other, segment_num)\n\n                    tim1_index, tim2_index = calculate_connect_part_indices(tim1_segment_points, tim2_segment_points,\n                                                                            segment_num)\n\n                    tim1_min_p = tim1_segment_points[tim1_index]\n                    tim2_min_p = tim2_segment_points[tim2_index]\n                    vec = tim1_min_p - tim2_min_p\n                    length = vec.Length\n\n                    judge_value = (tim1_diameter[tim1_index] / 2) + (tim2_diameter[tim2_index] / 2)\n\n                    if length <= judge_value:\n                        intersection_flag = True\n                        partner_tim_name = already_regenerate_list[j]\n                    else:\n                        pass\n\n                    break\n\n            if intersection_flag:\n                break\n            else:\n                continue\n\n        if intersection_flag:\n            inherit_timber_id_list.append(list_tim_id[i])\n            connect_list.append([list_tim_id[i], partner_tim_name])\n        else:\n            pass\n\n    return inherit_timber_id_list, connect_list\n\n\ndef move_and_pop_update_for_already(already_regenerate, pop_instance, generate_range, generation_num,\n                         between_draw_rhino, main_loop, loop, list_temp_partner_tim):\n    \"\"\"\n    そのまま継承する材をコピーする。\n    :param already_regenerate: 次世代に継承する材がはいったリスト\n    :param pop_instance: Generateインスタンス\n    :param generate_range: 生成可能範囲\n    :param generation_num: 現在の世代数\n    :param between_draw_rhino: 描画する間隔\n    :param main_loop: メインループの現在のカウント\n    :param loop: 小ループの現在のカウント\n    :param list_temp_partner_tim: パートナーが格納されているリスト\n    :return: なし。\n    \"\"\"\n\n    for i in range(len(already_regenerate)):\n        success_flag = False\n        for j in range(len(pop_instance.used_list)):\n            if already_regenerate[i] == pop_instance.used_list[j].id:\n                tim_move = pop_instance.used_list[j]\n\n                pop_index = pop_instance.population_id\n                move_from = Rhino.Geometry.Point3d(pop_index * 2 * generate_range, 0, 0)\n                move_to = Rhino.Geometry.Point3d(loop * generate_range * 2, -2 * generate_range, 0)\n                # vec_move = rs.VectorCreate(move_to, move_from)\n                vec_move = move_to - move_from\n                SingleTimberMoveObjects(tim_move, vec_move, generation_num, main_loop, between_draw_rhino)\n\n                success_flag = True\n                break\n            else:\n                continue\n\n        if not success_flag:\n            input(\"in GA Method MovePopulationUpdate\")\n\n    # そのまま継承した材の接合関係をtemp_partner_timに入れる。\n    # ------------------------------------------------------------------------------------------------------------------\n    for i in range(len(already_regenerate)):\n        tim_num = already_regenerate[i]\n        for j in range(len(pop_instance.used_list)):\n            if pop_instance.used_list[j].id == tim_num:\n                tim_index = j\n                break\n\n        for j in range(len(pop_instance.used_list[tim_index].partner_tim)):\n            if pop_instance.used_list[tim_index].partner_tim[j] in already_regenerate:\n                list_temp_partner_tim[loop][tim_num].append(\n                    pop_instance.used_list[tim_index].partner_tim[j])\n\n\ndef move_and_pop_update_for_inheritance(decide_inheritance_num_list, pop_instance1, pop_instance2, generate_range, generation_num,\n                         between_draw_rhino, main_loop, loop, list_temp_partner_tim):\n\n    for i in range(len(decide_inheritance_num_list)):\n        success_flag = False\n        for j in range(len(pop_instance1.used_list)):\n            if decide_inheritance_num_list[i] == pop_instance1.used_list[j].id:\n                tim_move = pop_instance1.used_list[j]\n\n                pop_index1 = pop_instance1.population_id\n                pop_index2 = pop_instance2.population_id\n\n                move_from = Rhino.Geometry.Point3d(pop_index2 * 2 * generate_range, 0, 0)\n                move_to = Rhino.Geometry.Point3d(loop * generate_range * 2, -2 * generate_range, 0)\n                # vec_move = rs.VectorCreate(move_to, move_from)\n                vec_move = move_to - move_from\n                SingleTimberMoveObjects(tim_move, vec_move, generation_num, main_loop, between_draw_rhino)\n\n                success_flag = True\n                break\n            else:\n                continue\n\n        if not success_flag:\n            input(\"in GA Method MovePopulationUpdate\")\n\n    # そのまま継承した材の接合関係をtemp_partner_timに入れる。\n    # ------------------------------------------------------------------------------------------------------------------\n    for i in range(len(decide_inheritance_num_list)):\n        tim_num = decide_inheritance_num_list[i]\n        for j in range(len(pop_instance1.used_list)):\n            if pop_instance2.used_list[j].id == tim_num:\n                tim_index = j\n                break\n\n        for j in range(len(pop_instance2.used_list[tim_index].partner_tim)):\n            if pop_instance2.used_list[tim_index].partner_tim[j] in decide_inheritance_num_list:\n                list_temp_partner_tim[loop][tim_num].append(\n                    pop_instance2.used_list[tim_index].partner_tim[j])\n\n\ndef RenewalInstanceInformationSameGeneration(pop_instance, temp_save_list_srf, temp_save_list_line, temp_save_list_domain,\n                                             list_srf_temp, list_center_line_temp, list_select_domain_temp, loop):\n\n    \"\"\"\n    同世代において、インスタンス情報を保存するためのメソッド\n    :param pop_instance: Generateインスタンス\n    :param temp_save_list_srf: 一時的に保存するために使用していたリスト\n    :param temp_save_list_line: 一時的に使用するために使用していたリスト\n    :param temp_save_list_domain: 一時的に使用するために使用していたリスト\n    :param list_srf_temp: 同世代全体の情報を一時的に格納しておくためのリスト\n    :param list_center_line_temp: 同世代全体の情報を一時的に格納しておくためのリスト\n    :param list_select_domain_temp: 同世代全体の情報を一時的に格納しておくためのリスト\n    :param loop: 少ループ\n    :return:\n    \"\"\"\n    for i in range(len(pop_instance.used_list)):\n        name_tim = pop_instance.used_list[i].id\n\n        temp_save_list_srf[loop][name_tim] = pop_instance.used_list[i].surface\n        pop_instance.used_list[i].surface = None\n        pop_instance.used_list[i].surface = list_srf_temp[i]\n        list_srf_temp[i] = None\n\n        temp_save_list_line[loop][name_tim] = pop_instance.used_list[i].center_line\n        pop_instance.used_list[i].center_line = None\n        pop_instance.used_list[i].center_line = list_center_line_temp[i]\n        list_center_line_temp[i] = None\n\n        temp_save_list_domain[loop][name_tim].extend(\n            pop_instance.used_list[i].select_domain_list)  # ttm add list_select\n        pop_instance.used_list[i].select_domain_list = []\n        pop_instance.used_list[i].select_domain_list.extend(list_select_domain_temp[i])\n\n\n\ndef RenewalPop2(pop_instance1, pop_instance2, pop_2_inheritance_num):\n    for i in range(len(pop_2_inheritance_num)):\n        inheritance_num = pop_2_inheritance_num[i]\n        for j in range(len(pop_instance1.used_list)):\n            if pop_instance1.used_list[j].id == inheritance_num:\n                for k in range(len(pop_instance2.used_list)):\n                    if pop_instance2.used_list[k].id == inheritance_num:\n                        pop_instance1.used_list[j].surface = copy.deepcopy(pop_instance2.used_list[k].surface)\n                        pop_instance1.used_list[j].center_line = copy.deepcopy(pop_instance2.used_list[k].center_line)\n                        pop_instance1.used_list[j].select_domain_list = copy.deepcopy(pop_instance2.used_list[k].select_domain_list)\n\n                        # pop_instance1.used_list[j].partner_tim = []\n                        # for l in range(len(pop_2_inheritance_num)):\n                        #     if pop_2_inheritance_num[l] in pop_instance2.used_list[k].partner_tim:\n                        #         pop_instance1.used_list[j].partner_tim.append(pop_2_inheritance_num[l])\n\n\ndef saveInstanceInformation(num_timber, pop_instance, list_srf_temp, list_center_line_temp, list_select_domain_temp):\n    \"\"\"\n    指定された個体のサーフェス、軸線、接合に使用されているドメインを引数のリストに保存する。\n    :param num_timber: 木材の本数\n    :param pop_instance: Generateインスタンス\n    :param list_srf_temp: 保存に使用するリスト\n    :param list_center_line_temp: 保存に使用するリスト\n    :param list_select_domain_temp: 保存に使用するリスト\n    :return: なし。\n    \"\"\"\n    for i in range(num_timber):\n        timber_instance = pop_instance.used_list[i]\n        copy_timber_objects(timber_instance, list_srf_temp, list_center_line_temp)\n\n    # select_domain_listの保存。　　使用されているドメインの一覧のこと\n    for i in range(num_timber):\n        list_select_domain_temp.append(pop_instance.used_list[i].select_domain_list)\n\n    # return list_srf_temp, list_center_line_temp, list_select_domain_temp\n\n\ndef selectDomainRenewal(already_regenerate, num_timber, pop_instance):\n    \"\"\"\n     select_domain_listの更新。　形態を引き継いでいる材の接合ドメインの更新を行う。前世代では使用していたが、空席になるドメインが生じるはずなので\n    :param already_regenerate:\n    :param num_timber:\n    :param pop_instance:\n    :return:\n    \"\"\"\n    for i in range(len(already_regenerate)):\n        for j in range(num_timber):\n            if already_regenerate[i] == pop_instance.used_list[j].id:\n                count_domain_loop = -1\n                for _ in range(len(pop_instance.used_list[j].select_domain_list)):\n                    count_domain_loop = count_domain_loop + 1\n                    tim_name_domain = pop_instance.used_list[j].select_domain_list[count_domain_loop][1]\n                    if tim_name_domain not in already_regenerate:\n                        pop_instance.used_list[j].select_domain_list.pop(count_domain_loop)  # 削除する。\n                        count_domain_loop = count_domain_loop - 1  # 次のループでも同じインデックスを使用するために\n\n\ndef selectDomainRenewal2(inheritance_num_list, num_timber, pop_instance1):\n    # for i in range(len(inheritance_num_list)):\n    #     inheritance_number = inheritance_num_list[i]\n    #     for j in range(len(pop_instance2.used_list)):\n    #         if pop_instance2.used_list[j].name == inheritance_number:\n    #             for k in range(len(pop_instance2.used_list[j].select_domain_list)):\n    #                 if pop_instance2.used_list[j].name == pop_instance2.used_list[j].select_domain_list[k][1]:\n    #                     print()\n\n    for i in range(len(inheritance_num_list)):\n        for j in range(num_timber):\n            if inheritance_num_list[i] == pop_instance1.used_list[j].id:\n                count_domain_loop = -1\n                for _ in range(len(pop_instance1.used_list[j].select_domain_list)):\n                    count_domain_loop = count_domain_loop + 1\n                    tim_name_domain = pop_instance1.used_list[j].select_domain_list[count_domain_loop][1]\n                    if tim_name_domain not in inheritance_num_list:\n                        pop_instance1.used_list[j].select_domain_list.pop(count_domain_loop)  # 削除する。\n                        count_domain_loop = count_domain_loop - 1  # 次のループでも同じインデックスを使用するために\n\n\n\ndef SingleTimberMoveObjects(timber_instance, vector_move, generation_count, pop_count, between_draw_num):\n    \"\"\"\n    オブジェクトをRhionCommonを使用して移動させるメソッド\n    :param timber_instance: timberのインスタンス\n    :param vector_move: 移動するためのベクトル\n    :param generation_count: 現在の世代数\n    :param pop_count: 小ループの数\n    :param between_draw_num: 描画する間隔\n    :return: なし。\n    \"\"\"\n    # rs.MoveObject(timber_instance.center_line, vector_move)\n    # rs.MoveObject(timber_instance.surface, vector_move)\n\n    xf = Rhino.Geometry.Transform.Translation(vector_move)\n    # print(\"timber_instance\", timber_instance.center_line)\n    # print(\"timber_instance\", timber_instance.surface)\n    if type(timber_instance.center_line) is list:\n        timber_instance.center_line = timber_instance.center_line[0]\n        timber_instance.center_line.Transform(xf)\n    else:\n        timber_instance.center_line.Transform(xf)\n\n    if type(timber_instance.surface) is list:\n        timber_instance.surface = timber_instance.surface[0]\n        timber_instance.surface.Transform(xf)\n    else:\n        timber_instance.surface.Transform(xf)\n\n    if generation_count - 1 == pop_count:\n        scriptcontext.doc.Objects.AddBrep(timber_instance.surface)\n        scriptcontext.doc.Objects.AddCurve(timber_instance.center_line)\n\n\ndef calculate_srf_segment_points(srf, segment_num):\n    srf_domain_u = srf.Faces[0].Domain(0)\n    srf_domain_v = srf.Faces[0].Domain(1)\n\n    srf_domain_u_segment = (srf_domain_u[1] - srf_domain_u[0]) / segment_num\n    srf_domain_v_segment = (srf_domain_v[1] - srf_domain_v[0]) / 10\n\n    segment_points_list = []\n    diameter_list = []\n    for i in range(segment_num + 1):\n        p1_u = srf_domain_u[0] + (srf_domain_u_segment * i)\n        p1_v = srf_domain_v[0] + (srf_domain_v_segment * 0)\n\n        p2_u = srf_domain_u[0] + (srf_domain_u_segment * i)\n        p2_v = srf_domain_v[0] + (srf_domain_v_segment * 5)\n\n        srf_point1 = srf.Faces[0].PointAt(p1_u, p1_v)\n        srf_point2 = srf.Faces[0].PointAt(p2_u, p2_v)\n\n        line = Rhino.Geometry.Line(srf_point2, srf_point1)\n        diameter = line.Length\n\n        center_p = line.PointAt(0.5)\n        segment_points_list.append(center_p)\n        diameter_list.append(diameter)\n\n    return segment_points_list, diameter_list\n\n\ndef calculate_connect_part_indices(tim1_segment_points, tim2_segment_points, segment_num):\n    between_length_list = []\n    for i in range(len(tim1_segment_points)):\n        tim1_p = tim1_segment_points[i]\n        for j in range(len(tim2_segment_points)):\n            tim2_p = tim2_segment_points[j]\n\n            between_vec = tim2_p - tim1_p\n            length = between_vec.Length\n            between_length_list.append(length)\n\n    length_min = min(between_length_list)\n    index = between_length_list.index(length_min)\n\n    tim1_index = index // (segment_num + 1)\n    tim2_index = index % (segment_num + 1)\n\n    return tim1_index, tim2_index\n\n\ndef transform_object_rhinocommon(object, vec_move):\n    xf = Rhino.Geometry.Transform.Translation(vec_move)\n    object.Transform(xf)\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}