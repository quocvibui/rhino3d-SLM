{
  "source_url": "https://github.com/Mufasa58/TNA/blob/49dfff99579f489c3179470ce8507bbb849e1226/thrust_grid.py",
  "repo": "Mufasa58/TNA",
  "repo_stars": 0,
  "repo_description": "Compas_TNA and Rhino Models and Scripts",
  "license": "unknown",
  "filepath": "thrust_grid.py",
  "instruction": "venv: rvdev",
  "code": "#! python3\n# venv: rvdev\n\nimport math\nimport Rhino\nimport scriptcontext as sc\nimport System\nfrom System.Drawing import Color\n\nfrom compas_tna.diagrams import FormDiagram\nfrom compas_tna.equilibrium import vertical_from_zmax\n\n\n# -----------------------------\n# PARAMETERS (edit these)\n# -----------------------------\nBAY = 7.0\nNBAYS = 3\nL = BAY * NBAYS            # 21m\nNX = 24                    # mesh resolution in x (increase for smoother)\nNY = 24                    # mesh resolution in y\nZMAX = 3.0                 # target rise (m) -> bigger = “deeper” funicular\nDENSITY = 1.0              # load density proxy (relative)\nKMAX = 200\nXTOL = 0.01\nRTOL = 0.001\n\nDRAW_LAYER = \"TNA::Form\"\nREACTION_LAYER = \"TNA::Reactions\"\n\n\n# -----------------------------\n# RHINO helpers\n# -----------------------------\ndef ensure_layer(name, color):\n    idx = sc.doc.Layers.FindByFullPath(name, True)\n    if idx >= 0:\n        return idx\n    layer = Rhino.DocObjects.Layer()\n    layer.Name = name\n    layer.Color = color\n    return sc.doc.Layers.Add(layer)\n\ndef draw_lines(lines, layer_name, color):\n    layer_idx = ensure_layer(layer_name, color)\n    attr = Rhino.DocObjects.ObjectAttributes()\n    attr.LayerIndex = layer_idx\n    ids = []\n    for a, b in lines:\n        ids.append(sc.doc.Objects.AddLine(a, b, attr))\n    return ids\n\ndef draw_arrows(arrows, layer_name, color):\n    layer_idx = ensure_layer(layer_name, color)\n    attr = Rhino.DocObjects.ObjectAttributes()\n    attr.LayerIndex = layer_idx\n    ids = []\n    for a, b in arrows:\n        ids.append(sc.doc.Objects.AddLine(a, b, attr))\n    return ids\n\n\n# -----------------------------\n# 1) Build form diagram mesh\n# -----------------------------\n# Meshgrid uses dx, dy, nx, ny as step sizes + counts; easiest is:\ndx = L / NX\ndy = L / NY\n\nform = FormDiagram.from_meshgrid(dx=dx, nx=NX, dy=dy, ny=NY)\n\n# Move to world coords so it spans [0..L] in x and y\n# (meshgrid already starts at origin, so nothing else needed)\n\n\n# -----------------------------\n# 2) Define supports (4x4 columns)\n# -----------------------------\ncol_coords = set()\nfor i in range(NBAYS + 1):\n    for j in range(NBAYS + 1):\n        col_coords.add((round(i * BAY, 6), round(j * BAY, 6)))\n\nsupport_count = 0\nfor v in form.vertices():\n    x, y, z = form.vertex_coordinates(v)\n    key = (round(x, 6), round(y, 6))\n    if key in col_coords:\n        form.vertex_attribute(v, \"is_support\", True)\n        support_count += 1\n\nprint(\"Supports set:\", support_count, \"(expected 16)\")\n\n# -----------------------------\n# 3) Solve funicular form (vertical)\n# -----------------------------\n# This computes a funicular shape under uniform density with target rise ZMAX\nform, scale = vertical_from_zmax(\n    form=form,\n    zmax=ZMAX,\n    kmax=KMAX,\n    xtol=XTOL,\n    rtol=RTOL,\n    density=DENSITY,\n    display=False\n)\n\nprint(\"Solved. scale:\", scale)\n\n\n# -----------------------------\n# 4) Compute support reactions (proxy) + objective\n# -----------------------------\n# COMPAS-TNA stores loads implicitly; a simple robust proxy is:\n# reaction = -sum(edge forces * unit vectors) for edges incident at support\n# We'll compute from force densities if available; otherwise use geometry-only proxy.\n#\n# In vertical_from_zmax results, edges usually have 'q' force density.\n# Force in edge ~ q * length. Direction is along edge.\n\ndef vec(p, q):\n    return (q.X - p.X, q.Y - p.Y, q.Z - p.Z)\n\ndef length(v):\n    return math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n\ndef unit(v):\n    l = length(v)\n    if l < 1e-12:\n        return (0.0, 0.0, 0.0)\n    return (v[0]/l, v[1]/l, v[2]/l)\n\nreactions = {}\nJ = 0.0\n\nfor v in form.vertices():\n    if not form.vertex_attribute(v, \"is_support\"):\n        continue\n\n    px, py, pz = form.vertex_coordinates(v)\n    P = Rhino.Geometry.Point3d(px, py, pz)\n\n    Rx = Ry = Rz = 0.0\n\n    for nbr in form.vertex_neighbors(v):\n        q = form.edge_attribute((v, nbr), \"q\")\n        if q is None:\n            q = form.edge_attribute((nbr, v), \"q\")\n        if q is None:\n            q = 0.0\n\n        nx, ny, nz = form.vertex_coordinates(nbr)\n        Q = Rhino.Geometry.Point3d(nx, ny, nz)\n\n        d = vec(P, Q)\n        Lij = length(d)\n        u = unit(d)\n\n        # axial force magnitude proxy\n        N = q * Lij\n\n        # contribution to node equilibrium\n        Rx += N * u[0]\n        Ry += N * u[1]\n        Rz += N * u[2]\n\n    # Reaction is opposite of internal edge resultants\n    Rx, Ry, Rz = -Rx, -Ry, -Rz\n\n    reactions[v] = (Rx, Ry, Rz)\n    J += math.sqrt(Rx*Rx + Ry*Ry)\n\nprint(\"Objective J (sum horizontal reactions):\", J)\nprint(\"supports:\", sum(1 for v in form.vertices() if form.vertex_attribute(v, \"is_support\")))\nprint(\"bbox:\", form.bounding_box())\n\n\n# -----------------------------\n# 5) Draw in Rhino\n# -----------------------------\n# draw form edges\nlines = []\nfor u, v in form.edges():\n    ax, ay, az = form.vertex_coordinates(u)\n    bx, by, bz = form.vertex_coordinates(v)\n    A = Rhino.Geometry.Point3d(ax, ay, az)\n    B = Rhino.Geometry.Point3d(bx, by, bz)\n    lines.append((A, B))\n\ndraw_lines(lines, DRAW_LAYER, Color.White)\n\n# draw reaction arrows at supports (scaled)\narrows = []\narrow_scale = 0.15  # tweak\nfor v, (Rx, Ry, Rz) in reactions.items():\n    x, y, z = form.vertex_coordinates(v)\n    A = Rhino.Geometry.Point3d(x, y, z)\n    B = Rhino.Geometry.Point3d(x + Rx * arrow_scale, y + Ry * arrow_scale, z + Rz * arrow_scale)\n    arrows.append((A, B))\n\ndraw_arrows(arrows, REACTION_LAYER, Color.Cyan)\n\nsc.doc.Views.Redraw()\nprint(\"Done.\")\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}