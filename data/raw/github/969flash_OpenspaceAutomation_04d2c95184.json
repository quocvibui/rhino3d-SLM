{
  "source_url": "https://github.com/969flash/OpenspaceAutomation/blob/f5e2574cae25af33c915c7077c954863d1413f6e/utils.py",
  "repo": "969flash/OpenspaceAutomation",
  "repo_stars": 0,
  "repo_description": "OpenspaceAutomation Example",
  "license": "MIT",
  "filepath": "utils.py",
  "instruction": null,
  "code": "# -*- coding:utf-8 -*-\ntry:\n    from typing import List, Tuple, Dict, Any, Optional, Union\nexcept ImportError:\n    pass\nimport functools\n\nimport Rhino\nimport Rhino.Geometry as geo  # ignore\nimport ghpythonlib.components as ghcomp  # ignore\n\nBIGNUM = 10000000\n\nTOL = 0.001\nDIST_TOL = 0.01\nAREA_TOL = 0.1\nOP_TOL = 0.00001\nCLIPPER_TOL = 0.0000000001\n\n\ndef get_overlap_crv(crv_a: geo.Curve, crv_b: geo.Curve) -> List[geo.Curve]:\n    \"\"\"두 커브의 겹치는 구간을 구한다.\n    Args:\n        crv_a : crv_b과 겹치는 부분을 구할 커브\n        crv_b : crv_a과 겹치짐을 테스트할 커브\n\n    Returns:\n        crv_a를 기준으로 crv_b와 겹치는 부분 커브\n    \"\"\"\n    # 두 커브가 교차조차 없으면 겹치는 부분이 없다.\n    if not geo.Curve.PlanarCurveCollision(crv_a, crv_b, geo.Plane.WorldXY, TOL):\n        return []\n\n    # crv_a와 crv_b의 교차점 + crv_a의 꼭짓점들로 crv_a를 자른다.\n    pts_to_split = (\n        ghcomp.Explode(crv_a, True).vertices + ghcomp.CurveXCurve(crv_a, crv_b).points\n    )\n    if not pts_to_split:\n        return []\n\n    parameters = [ghcomp.CurveClosestPoint(pt, crv_a).parameter for pt in pts_to_split]\n\n    segments = ghcomp.Shatter(crv_a, parameters)\n\n    overlaped_segments = [\n        seg\n        for seg in segments\n        if geo.Curve.PlanarCurveCollision(seg, crv_b, geo.Plane.WorldXY, TOL)\n    ]\n\n    if not overlaped_segments:\n        return []\n\n    return geo.Curve.JoinCurves(overlaped_segments)\n\n\ndef get_overlap_length(crv_a: geo.Curve, crv_b: geo.Curve) -> float:\n    \"\"\"두 커브의 겹치는 길이를 구한다.\n    Args:\n        crv_a : crv_b과 겹치는 부분을 구할 커브\n        crv_b : crv_a과 겹치짐을 테스트할 커브\n\n    Returns:\n        crv_a를 기준으로 crv_b와 겹치는 부분 길이\n    \"\"\"\n    overlap_crvs = get_overlap_crv(crv_a, crv_b)\n    if not overlap_crvs:\n        return 0.0\n\n    length = 0.0\n    for crv in overlap_crvs:\n        length += crv.GetLength()\n    return length\n\n\ndef is_intersection_with_other_crvs(crv: geo.Curve, crvs: List[geo.Curve]) -> bool:\n    return any(\n        geo.Curve.PlanarCurveCollision(crv, other_crv, geo.Plane.WorldXY, OP_TOL)\n        for other_crv in crvs\n    )\n\n\ndef has_region_intersection(\n    region: geo.Curve, other_region: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"영역 커브와 다른 영역 커브가 교차하는지 확인한다.\n    Args:\n        region: 영역 커브\n        other_regions: 다른 영역 커브 리스트\n        tol: tolerance\n\n    Returns:\n        bool: 교차 여부\n    \"\"\"\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        region, other_region, geo.Plane.WorldXY, tol\n    )\n    # 완전히 떨어져 있는 경우. 닿은 부분 없이.\n    if relationship == geo.RegionContainment.Disjoint:\n        return False\n    return True\n\n\ndef offset_regions_inward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"영역 커브를 안쪽으로 offset 한다.\n    단일커브나 커브리스트 관계없이 커브 리스트로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n\n    Returns:\n        offset 후 커브\n    \"\"\"\n\n    if not dist:\n        return regions\n    return Offset().polyline_offset(regions, dist, miter).holes\n\n\ndef offset_regions_outward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"영역 커브를 바깥쪽으로 offset 한다.\n    단일커브나 커브리스트 관계없이 커브 리스트로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n    returns:\n        offset 후 커브\n    \"\"\"\n    if isinstance(regions, geo.Curve):\n        regions = [regions]\n\n    return [offset_region_outward(region, dist, miter) for region in regions]\n\n\ndef offset_region_outward(\n    region: geo.Curve, dist: float, miter: float = BIGNUM\n) -> geo.Curve:\n    \"\"\"영역 커브를 바깥쪽으로 offset 한다.\n    단일 커브를 받아서 단일 커브로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n\n    Returns:\n        offset 후 커브\n    \"\"\"\n\n    if not dist:\n        return region\n    if not isinstance(region, geo.Curve):\n        raise ValueError(\"region must be curve\")\n    return Offset().polyline_offset(region, dist, miter).contour[0]\n\n\ndef convert_io_to_list(func):\n    \"\"\"인풋과 아웃풋을 리스트로 만들어주는 데코레이터\"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        new_args = []\n        for arg in args:\n            if isinstance(arg, geo.Curve):\n                arg = [arg]\n            new_args.append(arg)\n\n        result = func(*new_args, **kwargs)\n        if isinstance(result, geo.Curve):\n            result = [result]\n\n        if hasattr(result, \"__dict__\"):\n            for key, values in result.__dict__.items():\n                if isinstance(values, geo.Curve):\n                    setattr(result, key, [values])\n        return result\n\n    return wrapper\n\n\nclass Offset:\n    class _PolylineOffsetResult:\n        def __init__(self):\n            self.contour: Optional[List[geo.Curve]] = None\n            self.holes: Optional[List[geo.Curve]] = None\n\n    @convert_io_to_list\n    def polyline_offset(\n        self,\n        crvs: List[geo.Curve],\n        dists: List[float],\n        miter: int = BIGNUM,\n        closed_fillet: int = 2,\n        open_fillet: int = 2,\n        tol: float = Rhino.RhinoMath.ZeroTolerance,\n    ) -> _PolylineOffsetResult:\n        \"\"\"\n        Args:\n            crv (_type_): _description_\n            dists (_type_): _description_\n            miter : miter\n            closed_fillet : 0 = round, 1 = square, 2 = miter\n            open_fillet : 0 = round, 1 = square, 2 = butt\n\n        Returns:\n            _type_: _PolylineOffsetResult\n        \"\"\"\n        if not crvs:\n            raise ValueError(\"No Curves to offset\")\n\n        plane = geo.Plane(geo.Point3d(0, 0, crvs[0].PointAtEnd.Z), geo.Vector3d.ZAxis)\n        result = ghcomp.ClipperComponents.PolylineOffset(\n            crvs,\n            dists,\n            plane,\n            tol,\n            closed_fillet,\n            open_fillet,\n            miter,\n        )\n\n        polyline_offset_result = Offset._PolylineOffsetResult()\n        for name in (\"contour\", \"holes\"):\n            setattr(polyline_offset_result, name, result[name])\n        return polyline_offset_result\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}