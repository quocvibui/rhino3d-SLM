{
  "source_url": "https://github.com/fstwn/cockatoo/blob/d952ac5d2148ec29fba52e8eb75f0f43770c74ca/usrobj_src/Cockatoo_RenderKnitNetwork.py",
  "repo": "fstwn/cockatoo",
  "repo_stars": 38,
  "repo_description": "Cockatoo is a prototypical open-source software toolkit for generating (3d-)knitting patterns from NURBS surface and mesh geometry directly inside Grasshopper.",
  "license": "MIT",
  "filepath": "usrobj_src/Cockatoo_RenderKnitNetwork.py",
  "instruction": "Renders the nodes and edges of a given KnitNetwork to the Rhino viewport\naccording to the following rules:\n[NODES]\n'LEAF' : Cyan\n'START' : Green\n'END' : Blue\n'INCREASE' : Red\n'DECREASE' : Dark...",
  "code": "\"\"\"\nRenders the nodes and edges of a given KnitNetwork to the Rhino viewport\naccording to the following rules:\n[NODES]\n'LEAF' : Cyan\n'START' : Green\n'END' : Blue\n'INCREASE' : Red\n'DECREASE' : Dark Red\n'LEAF' + 'START' : Sea Green\n'LEAF' + 'END' : Magenta\n'LEAF' + 'START' + 'END' : Orange\n'START' + 'END' : DarkGreen\n'INCREASE' + 'END' : Purple\n'DECREASE' + 'END' : Dark Violet\nREGULAR NODES : Node Color or Black/White if no 'color' attribute is set.\n---\n[EDGES]\n'WEFT' : Blue\n'WARP' : Red\nNEITHER 'WARP' NOR 'WEFT' : Gray\n---\n[WARNING] Rendering the associated data (attributes) as text or the directions\nof the edges (DirectionalDisplay) can be **VERY** computation-intensive,\nespecially on large networks, and freeze Grasshopper & Rhino for a\nsubstantial amount of time!\n    Inputs:\n        Toggle: {item, bool}\n        KnitNetwork: A network of type KnitNetworkBase, this can be a\n                     KnitNetwork, KnitMappingNetwork, KnitDiNetwork .\n                     {item, KnitNetwork}\n        RenderNodes: If True, colored nodes will be rendered to the viewport.\n                     Defaults to False. {item, bool}\n        RenderNodeIndices: If True, the identifiers of the nodes in the network\n                           will be rendered to the viewport as text.\n                           Defaults to False. {item, bool}\n        RenderNodeData: If True, the associated data (attributes) of the nodes\n                        will be rendered to the viewport as text. {item, bool}\n        NodeTextPlane: The plane for orientation of the node identifiers and \n                       data text.\n                       Defaults to World XZ. {item, plane}\n        NodeTextHeight: The text size for the node identifiers and data in\n                        model units.\n                        Defaults to 0.1 . {item, float}\n        RenderContourEdges: If True, the contour edges of the network will be\n                            rendered to the viewport.\n                            Defaults to False. {item, bool}\n        RenderContourEdgeData: If True, the identifiers and associated data\n                               (attributes) of contour edges will be rendered\n                               to the viewport as text.\n                               Defaults to False. {item, bool}\n        RenderWeftEdges: If True, the 'weft' edges of the network will be\n                         rendered to the viewport in blue.\n                         Defaults to True. {item, bool}\n        RenderWeftEdgeData: If True, the identifiers and associated data\n                            (attributes) of 'weft' edges will be rendered\n                            to the viewport as text.\n                            Defaults to False. {item, bool}\n        RenderWarpEdges: If True, the 'warp' edges of the network will be\n                         rendered to the viewport in blue.\n                         Defaults to True. {item, bool}\n        RenderWarpEdgeData: If True, the identifiers and associated data\n                            (attributes) of 'warp' edges will be rendered\n                            to the viewport as text.\n                            Defaults to False. {item, bool}\n        DirectionalDisplay: If True, edges will be rendered as vectors instead\n                            of using their associated line/polyline geometry.\n                            Defaults to False. {item, bool}\n        EdgeTextPlane: The plane for orientation of the edge identifiers and\n                       data text.\n                       Defaults to World XZ. {item, plane}\n        EdgeTextHeight: The text size for the edge identifiers and data in\n                        model units.\n                        Defaults to 0.1 . {item, float}\n    Remarks:\n        Author: Max Eschenbach\n        License: MIT License\n        Version: 200705\n\"\"\"\n\n# PYTHON STANDARD LIBRARY IMPORTS\nfrom __future__ import division\n\n# GHPYTHON SDK IMPORTS\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\n# GHENV COMPONENT SETTINGS\nghenv.Component.Name = \"RenderKnitNetwork\"\nghenv.Component.NickName =\"RKN\"\nghenv.Component.Category = \"Cockatoo\"\nghenv.Component.SubCategory = \"08 Visualisation\"\n\n# LOCAL MODULE IMPORTS\ntry:\n    from cockatoo import KnitNetwork\n    from cockatoo import KnitMappingNetwork\nexcept ImportError:\n    errMsg = \"The Cockatoo python module seems to be not correctly \" + \\\n             \"installed! Please make sure the module is in you search \" + \\\n             \"path, see README for instructions!.\"\n    raise ImportError(errMsg)\n\nclass RenderKnitNetwork(component):\n    \n    def __init__(self):\n        super(RenderKnitNetwork, self).__init__()\n        \n        self.drawing_nodes = []\n        self.drawing_edges = []\n        self.drawing_data = []\n        self.draw_directional = False\n    \n    def get_ClippingBox(self):\n        return Rhino.Geometry.BoundingBox()\n    \n    def DrawViewportWires(self, args):\n        try:\n            \n            # get display from args\n            display = args.Display\n            \n            # draw all catalogued nodes\n            for node in self.drawing_nodes:\n                display.DrawPoint(node[0], node[1], node[2], node[3])\n            \n            # draw all catalogued edges\n            if self.draw_directional:\n                for edge in self.drawing_edges:\n                    display.DrawArrow(edge[0], edge[1])\n            else:\n                for edge in self.drawing_edges:\n                    display.DrawLine(edge[0], edge[1], 2)\n            \n            # draw all catalogued data text tags\n            for txtag in self.drawing_data:\n                if display.IsVisible(txtag[0].TextPlane.Origin):\n                    display.Draw3dText(txtag[0], txtag[1])\n            \n        except Exception, e:\n            System.Windows.Forms.MessageBox.Show(str(e),\n                                                 \"Error while drawing preview!\")\n    \n    def RunScript(self, KN, RenderNodes=False, RenderNodeIndices=False, RenderNodeData=False, NodeTextPlane=None, NodeTextHeight=0.1, RenderContourEdges=False, RenderContourEdgeData=False, RenderWeftEdges=True, RenderWeftEdgeData=False, RenderWarpEdges=True, RenderWarpEdgeData=False, DirectionalDisplay=False, EdgeTextPlane=None, EdgeTextHeight=0.1):\n        \n        # SET DEFAULTS ---------------------------------------------------------\n        \n        if NodeTextPlane is None:\n            NodeTextPlane = Rhino.Geometry.Plane.WorldZX\n            NodeTextPlane.Flip()\n        \n        if EdgeTextPlane is None:\n            EdgeTextPlane = Rhino.Geometry.Plane.WorldZX\n            EdgeTextPlane.Flip()\n        \n        if DirectionalDisplay is None:\n            DirectionalDisplay = False\n        \n        # set directional drawing attribute for drawing method\n        self.draw_directional = DirectionalDisplay\n        \n        # SET FONT FACES FOR DISPLAY -------------------------------------------\n        \n        nodeFontFace = \"Helvetica\"\n        contourFontFace = \"Helvetica\"\n        weftFontFace = \"Helvetica\"\n        warpFontFace = \"Helvetica\"\n        \n        # RENDER ACCORDING TO SET PARAMETERS -----------------------------------\n        \n        node_drawing_list = []\n        edge_drawing_list = []\n        data_drawing_list = []\n        \n        if KN and (RenderNodes or \\\n                   RenderContourEdges or \\\n                   RenderWeftEdges or \\\n                   RenderWarpEdges):\n            \n            # RENDERING OF CONTOUR EDGES ---------------------------------------\n            \n            if RenderContourEdges:\n                contourcol = System.Drawing.Color.Gray\n                contour_edges = KN.contour_edges\n                \n                for ce in contour_edges:\n                    egeo = ce[2][\"geo\"]\n                    if isinstance(egeo, Rhino.Geometry.Polyline):\n                        for seg in egeo.GetSegments():\n                            edge_drawing_list.append((seg, contourcol))\n                    else:\n                        edge_drawing_list.append((egeo, contourcol))\n                    \n                    # RENDERING OF CONTOUR EDGE DATA ---------------------------\n                    if RenderContourEdgeData:\n                        EdgeTextPlane.Origin = egeo.PointAt(0.5)\n                        edgeLabel = [(k, ce[2][k]) for k \\\n                                     in ce[2] if k != \"geo\"]\n                        edgeLabel = [\"{}: {}\".format(t[0], t[1]) for t \\\n                                     in edgeLabel]\n                        edgeLabel.sort()\n                        edgeLabel = [str(ce[0]) + \"-\" + \\\n                                     str(ce[1])] + edgeLabel\n                        edgeLabel = \"\\n\".join(edgeLabel)\n                        tagTxt = Rhino.Display.Text3d(str(edgeLabel),\n                                                      EdgeTextPlane,\n                                                      EdgeTextHeight)\n                        tagTxt.FontFace = contourFontFace\n                        \n                        data_drawing_list.append((tagTxt, contourcol))\n            \n            # RENDERING OF WEFT EDGES ------------------------------------------\n            \n            if RenderWeftEdges:\n                weftcol = System.Drawing.Color.Blue\n                weft_edges = KN.weft_edges\n                for weft in weft_edges:\n                    egeo = weft[2][\"geo\"]\n                    edge_drawing_list.append((egeo, weftcol))\n                    \n                    # RENDERING OF WEFT DGE DATA -------------------------------\n                    \n                    if RenderWeftEdgeData:\n                        EdgeTextPlane.Origin = egeo.PointAt(0.5)\n                        edgeLabel = [(k, weft[2][k]) for k \\\n                                     in weft[2] if k != \"geo\"]\n                        edgeLabel = [\"{}: {}\".format(t[0], t[1]) for t \\\n                                     in edgeLabel]\n                        edgeLabel.sort()\n                        edgeLabel = [str(weft[0]) + \"-\" + \\\n                                     str(weft[1])] + edgeLabel\n                        edgeLabel = \"\\n\".join(edgeLabel)\n                        tagTxt = Rhino.Display.Text3d(str(edgeLabel),\n                                                      EdgeTextPlane,\n                                                      EdgeTextHeight)\n                        tagTxt.FontFace = weftFontFace\n                        data_drawing_list.append((tagTxt, weftcol))\n            \n            # RENDERING OF WARP EDGES ------------------------------------------\n            \n            if RenderWarpEdges:\n                warpcol = System.Drawing.Color.Red\n                warp_edges = KN.warp_edges\n                for warp in warp_edges:\n                    egeo = warp[2][\"geo\"]\n                    edge_drawing_list.append((egeo, warpcol))\n                    \n                    # RENDERING OF WARP EDGE DATA ------------------------------\n                    \n                    if RenderWarpEdgeData:\n                        EdgeTextPlane.Origin = egeo.PointAt(0.5)\n                        edgeLabel = [(k, warp[2][k]) for k \\\n                                     in warp[2] if k != \"geo\"]\n                        edgeLabel = [\"{}: {}\".format(t[0], t[1]) for t \\\n                                     in edgeLabel]\n                        edgeLabel.sort()\n                        edgeLabel = [str(warp[0]) + \"-\" + \\\n                                     str(warp[1])] + edgeLabel\n                        edgeLabel = \"\\n\".join(edgeLabel)\n                        tagTxt = Rhino.Display.Text3d(str(edgeLabel),\n                                                      EdgeTextPlane,\n                                                      EdgeTextHeight)\n                        tagTxt.FontFace = warpFontFace\n                        data_drawing_list.append((tagTxt, warpcol))\n            \n            # RENDERING OF NODES -----------------------------------------------\n            \n            # define point styles for nodes\n            psEnd = Rhino.Display.PointStyle.Circle\n            psLeaf = Rhino.Display.PointStyle.Circle\n            psRegular = Rhino.Display.PointStyle.RoundControlPoint\n            \n            # define colours for nodes and node texts\n            colStart = System.Drawing.Color.Green\n            colStartLeaf = System.Drawing.Color.SeaGreen\n            colStartLeafEnd = System.Drawing.Color.Orange\n            colStartEnd = System.Drawing.Color.DarkGreen\n            colEnd = System.Drawing.Color.Blue\n            colLeaf = System.Drawing.Color.Cyan\n            colEndLeaf = System.Drawing.Color.Magenta\n            colRegular = System.Drawing.Color.Black\n            colIncreaseEnd = System.Drawing.Color.Purple\n            colDecreaseEnd = System.Drawing.Color.DarkViolet\n            colIncrease = System.Drawing.Color.Red\n            colDecrease = System.Drawing.Color.DarkRed\n            \n            if RenderNodes or RenderNodeIndices or RenderNodeData:\n                nodes = KN.nodes(data=True)\n                for i, node in enumerate(nodes):\n                    data = node[1]\n                    \n                    # END BUT NOT LEAF\n                    if data[\"end\"] and not data[\"leaf\"]:\n                        if not data[\"increase\"] and not data[\"decrease\"]:\n                            if data[\"start\"]:\n                                nodecol = colStartEnd\n                            else:\n                                nodecol = colEnd\n                            pStyle = psEnd\n                            pSize = 3\n                        elif data[\"increase\"] and not data[\"decrease\"]:\n                            nodecol = colIncreaseEnd\n                            pStyle = psEnd\n                            pSize = 3\n                        elif not data[\"increase\"] and data[\"decrease\"]:\n                            nodecol = colDecreaseEnd\n                            pStyle = psEnd\n                            pSize = 3\n                    # END AND LEAF\n                    elif data[\"end\"] and data[\"leaf\"]:\n                        if data[\"start\"]:\n                            nodecol = colStartLeafEnd\n                        else:\n                            nodecol = colEndLeaf\n                        pStyle = psLeaf\n                        pSize = 3\n                    # NO END BUT LEAF\n                    elif not data[\"end\"] and data[\"leaf\"]:\n                        if data[\"start\"]:\n                            nodecol = colStartLeaf\n                        else:\n                            nodecol = colLeaf\n                        pStyle = psLeaf\n                        pSize = 3\n                    # NO END NO LEAF\n                    elif not data[\"end\"] and not data[\"leaf\"]:\n                        if data[\"increase\"] and not data[\"decrease\"]:\n                            nodecol = colIncrease\n                            pStyle = psEnd\n                            pSize = 3\n                        elif not data[\"increase\"] and data[\"decrease\"]:\n                            nodecol = colDecrease\n                            pStyle = psEnd\n                            pSize = 3\n                        else:\n                            if data[\"color\"]:\n                                nodecol = System.Drawing.Color.FromArgb(\n                                                            *data[\"color\"])\n                            else:\n                                nodecol = colRegular\n                            pStyle = psRegular\n                            pSize = 2\n                    \n                    \n                    \n                    if RenderNodes:\n                        node_drawing_list.append((data[\"geo\"], pStyle, pSize, nodecol))\n                    \n                    # RENDER NODE DATA AND INDICES -----------------------------\n                    \n                    if RenderNodeIndices or RenderNodeData:\n                        NodeTextPlane.Origin = data[\"geo\"]\n                        tagTxt = Rhino.Display.Text3d(str(node[0]),\n                                                          NodeTextPlane,\n                                                          NodeTextHeight)\n                        tagTxt.FontFace = nodeFontFace\n                        if data[\"end\"] == True:\n                            nodecol = colEnd\n                        elif data[\"leaf\"] == True:\n                            nodecol = colLeaf\n                        elif data[\"leaf\"] == False and data[\"end\"] == False:\n                            nodecol = colRegular\n                        data_drawing_list.append((tagTxt, nodecol))\n                        \n                        if RenderNodeData:\n                            nodeLabel = [(k, data[k]) for k in data \\\n                                         if k != \"geo\" and \\\n                                            k != \"x\" and \\\n                                            k != \"y\" and \\\n                                            k != \"z\"]\n                            nodeLabel = [\"{}: {}\".format(t[0], t[1]) \\\n                                         for t in nodeLabel]\n                            nodeLabel.sort()\n                            nodeLabel = [\"\"] + nodeLabel\n                            nodeLabel = \"\\n\".join(nodeLabel)\n                            nodeTxt = Rhino.Display.Text3d(str(nodeLabel),\n                                                          NodeTextPlane,\n                                                          NodeTextHeight*0.3)\n                            nodeTxt.FontFace = nodeFontFace\n                            data_drawing_list.append((nodeTxt, nodecol))\n            \n            # set attributes and draw\n            self.drawing_nodes = node_drawing_list\n            self.drawing_edges = edge_drawing_list\n            self.drawing_data = data_drawing_list\n            \n        else:\n            if not KN:\n                self.drawing_nodes = []\n                self.drawing_edges = []\n                self.drawing_data = []\n                rml = self.RuntimeMessageLevel.Warning\n                self.AddRuntimeMessage(rml, \"No KnitNetwork input!\")\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}