{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_Patch_in_FreeCAD.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_Patch_in_FreeCAD.py",
  "instruction": "Complement to _Patch by using Surface::Filling in FreeCAD.\r\n\r\nAlthough Surface::Filling is supposed to support G2 matching, tested results\r\nshow that setting G2 produces G0 results.  Also, G1 knots...",
  "code": "\"\"\"\r\nComplement to _Patch by using Surface::Filling in FreeCAD.\r\n\r\nAlthough Surface::Filling is supposed to support G2 matching, tested results\r\nshow that setting G2 produces G0 results.  Also, G1 knots exist within the new\r\nsurface, making the G2 goal moot in some ways.\r\n\r\n\r\nThis script uses headless FreeCAD ( https://wiki.freecadweb.org/Headless_FreeCAD )\r\n\r\nThis script been tested on\r\nRhino 7, 7.13.21348.13001 & TBD on Windows\r\nFreeCAD 0.019.3 (0.019.24267) on Windows\r\n\r\n\r\nRequirements to run:\r\n1. Rhino 7.  Other versions have not been tested.  If you try doing so,\r\n    please inform me (see below) the results.\r\n\r\n2. FreeCAD, preferrably the same version as stated above,\r\n    https://www.freecadweb.org/downloads.php\r\n    installed where Rhino running the script can access it.\r\n\r\n3. Modification of the code in the \"Variables to modify per OS\"... section\r\n    below as needed.  Notice that as provided, .stp and .py communication files\r\n    are created on the current user's Desktop.\r\n\r\n\r\nTODO:\r\nDo not export redundant breps, as when multiple edges are selected on a face.\r\nFor previous input option, should the input be merged with any current input?\r\n\r\n\r\nSend any questions, comments, or script development service needs to @spb on\r\nthe McNeel Forums ( https://discourse.mcneel.com/ )\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, print_function, unicode_literals\r\n\r\n\"\"\"\r\n220112-17: Created, starting with \"FilletEdge\"-in-FreeCAD script.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System.Drawing import Color\r\n\r\nimport os\r\nfrom subprocess import Popen, PIPE\r\nfrom threading import Timer\r\n\r\n\r\n\r\n# Variables to modify per OS, installation paths, and desired placement of\r\n# .stp and .py files for communication between Rhino and FreeCAD.\r\n\r\nsFCcmd_Path = '\"{}\"'.format(r\"C:\\Program Files\\FreeCAD 0.19\\bin\\FreeCADcmd.exe\")\r\n\r\ndesktop = os.path.join(os.path.join(os.environ['USERPROFILE']), 'Desktop')\r\n\r\nsPath_Script_for_FC = desktop + r\"\\to_FC.py\"\r\n\r\nsPath_STEP_to_FC = desktop + r\"\\to_FC.stp\"\r\n\r\nsPath_STEP_from_FC = desktop + r\"\\from_FC.stp\"\r\n\r\n#\r\n\r\n\r\n\r\ns_FC = []\r\n\r\ndef fc(s=''): s_FC.append(s)\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bAutoCompleteLoop'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iFilter'; keys.append(key)\r\n    values[key] = 0\r\n    names[key] = 'Filter'\r\n    listValues[key] = 'EdgesAndWires', 'EdgesOnly', 'WiresOnly'\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bG1_NotG0'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'Continuity'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'G0', 'G1')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fFreeCADTimeoutSecs'; keys.append(key)\r\n    values[key] = 10.0\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key], setLowerLimit=True, limit=0.0)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef ptsAreClose(ptA, ptB):\r\n    return ptA.DistanceTo(ptB) <= sc.doc.ModelAbsoluteTolerance\r\n\r\n\r\ndef sort_crvs_to_closed_loop(crvs_In):\r\n    \"\"\"\r\n    First curve in crvs_In will be the starting curve.\r\n    \"\"\"\r\n\r\n    def matches(pt, idxC_Skip):\r\n        idxs_Matches = []\r\n        bT1s = [] # False for PointAtStart, True for PointAtEnd\r\n        for i, crv in enumerate(crvs_In):\r\n\r\n            if i in idxC_Skip: continue\r\n\r\n            if ptsAreClose(pt, crv.PointAtStart):\r\n                idxs_Matches.append(i)\r\n                bT1s.append(False)\r\n                continue\r\n\r\n            if ptsAreClose(pt, crv.PointAtEnd):\r\n                idxs_Matches.append(i)\r\n                bT1s.append(True)\r\n\r\n        return idxs_Matches, bT1s\r\n\r\n\r\n    idxCs_Ordered = [0] # Indices of crvs_In.\r\n    pt = crvs_In[0].PointAtEnd\r\n\r\n    while True:\r\n        sc.escape_test()\r\n\r\n        for idxC, crv in enumerate(crvs_In):\r\n            if (idxC != 0) and (idxC in idxCs_Ordered): continue\r\n        \r\n            idx_Matches, bT1s = matches(pt, [idxC]+idxCs_Ordered)\r\n        \r\n            if len(idx_Matches) == 0:\r\n                if not ptsAreClose(pt, crvs_In[0].PointAtStart):\r\n                    print(\r\n                        \"Loop doesn't close with start curve.\")\r\n                    return\r\n\r\n                # Success.\r\n                return idxCs_Ordered\r\n\r\n\r\n            if len(idx_Matches) == 1:\r\n                idx_Match = idx_Matches[0]\r\n                idxCs_Ordered.extend(idx_Matches)\r\n                if bT1s[0]:\r\n                    pt = crvs_In[idx_Match].PointAtStart\r\n                else:\r\n                    pt = crvs_In[idx_Match].PointAtEnd\r\n                #sc.doc.Objects.AddCurve(crvs_In[idx_Match]); sc.doc.Views.Redraw()\r\n                break # to while loop.\r\n        \r\n            if len(idx_Matches) > 1:\r\n                print(\r\n                    \"More than one branch detected.\",\r\n                    \"Giving up finding single closed loop.\")\r\n                return\r\n\r\n\r\ndef midPt(crv):\r\n    t = list(crv.DivideByCount(2, includeEnds=False))[0]\r\n    return crv.PointAt(t)\r\n\r\n\r\ndef autoSearchForOnlyClosedBoundaryLoop(objref):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    crv_Start = objref.Edge()\r\n    if crv_Start is None:\r\n        crv_Start = objref.Curve()\r\n        bWire = True\r\n    else:\r\n        bWire = False\r\n\r\n\r\n    def closestPt(crv, pt):\r\n        return crv.PointAt(crv.ClosestPoint(pt)[1])\r\n\r\n\r\n\r\n\r\n    oes = rd.ObjectEnumeratorSettings()\r\n    oes.NormalObjects = True\r\n    oes.LockedObjects = False\r\n    oes.IncludeLights = False\r\n    oes.IncludeGrips = False\r\n\r\n    if Opts.values['iFilter'] == 0:\r\n        oes.ObjectTypeFilter = rd.ObjectType.Brep | rd.ObjectType.Curve\r\n    elif Opts.values['iFilter'] == 1:\r\n        oes.ObjectTypeFilter = rd.ObjectType.Brep\r\n    elif Opts.values['iFilter'] == 2:\r\n        oes.ObjectTypeFilter = rd.ObjectType.Curve\r\n\r\n    crvs_Filtered = []\r\n    gCrvs_Filtered = []\r\n\r\n    for rdO in sc.doc.Objects.GetObjectList(oes):\r\n        if rdO.ObjectType == rd.ObjectType.Curve:\r\n            if bWire and rdO.Id == objref.ObjectId: continue\r\n            wire = rdO.Geometry\r\n            if wire.IsClosed: continue\r\n            crvs_Filtered.append(wire)\r\n            gCrvs_Filtered.append(rdO.Id)\r\n            continue\r\n\r\n        brep = rdO.Geometry\r\n\r\n        for iE, edge in enumerate(brep.Edges):\r\n            if edge.Valence != rg.EdgeAdjacency.Naked: continue\r\n            if not bWire and (rdO.Id == objref.ObjectId) and (iE == crv_Start.EdgeIndex):\r\n                continue\r\n            crvs_Filtered.append(edge)\r\n            gCrvs_Filtered.append(rdO.Id)\r\n\r\n\r\n    #print(len(crvs_Filtered))\r\n\r\n\r\n    def crvsOverlap(crvA, crvB):\r\n        if ptsAreClose(crvA.PointAtStart, crvB.PointAtStart):\r\n            if ptsAreClose(crvA.PointAtEnd, crvB.PointAtEnd):\r\n                if ptsAreClose(midPt(crvA), closestPt(crvB, midPt(crvA))):\r\n                    return True\r\n        elif ptsAreClose(crvA.PointAtStart, crvB.PointAtEnd):\r\n            if ptsAreClose(crvA.PointAtEnd, crvB.PointAtStart):\r\n                if ptsAreClose(midPt(crvA), closestPt(crvB, midPt(crvA))):\r\n                    return True\r\n\r\n\r\n    def overlaps(crvs):\r\n        idxOverlaps = []\r\n        for i in range(len(crvs) - 1):\r\n            if i in idxOverlaps: continue\r\n            for j in range(i+1, len(crvs)):\r\n                if j in idxOverlaps: continue\r\n                if crvsOverlap(crvs[i], crvs[j]):\r\n                    idxOverlaps.extend([i, j])\r\n        return idxOverlaps\r\n\r\n    idxs_Overlaps = overlaps(crvs_Filtered)\r\n    #print(idxs_Overlaps)\r\n\r\n    for i in sorted(set(idxs_Overlaps), reverse=True):\r\n        del crvs_Filtered[i]\r\n        del gCrvs_Filtered[i]\r\n    #print(len(crvs_Filtered))\r\n\r\n\r\n    #print(*crvs_Filtered, sep='\\n')\r\n\r\n    crvs_to_Sort = [crv_Start] + crvs_Filtered\r\n    gCrvs_to_Sort = [objref.ObjectId] + gCrvs_Filtered\r\n\r\n\r\n    idxCs_Ordered = sort_crvs_to_closed_loop(crvs_to_Sort)\r\n    if idxCs_Ordered is None: return\r\n\r\n    #print(idxCs_Ordered)\r\n\r\n    return (\r\n        [crvs_Filtered[i] for i in idxCs_Ordered],\r\n        [gCrvs_Filtered[i] for i in idxCs_Ordered])\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get Curves, including BrepEdges, with optional input.\r\n    \"\"\"\r\n\r\n    sk_PrevSel = 'UsePrevSelection({})({})'.format(__file__, sc.doc.Name)\r\n\r\n\r\n    def getClosedLoopFromObjRefs(objrefs):\r\n\r\n        rgCs = []\r\n        gCs = []\r\n\r\n        for objref in objrefs:\r\n            crv = objref.Edge()\r\n            if crv is None:\r\n                crv = objref.Curve()\r\n            rgCs.append(crv)\r\n            gCs.append(objref.ObjectId)\r\n        idxs_Sorted = sort_crvs_to_closed_loop(rgCs)\r\n        if idxs_Sorted is None:\r\n            print(\"AInput curves do not form a single closed loop.\")\r\n            return\r\n\r\n        if len(idxs_Sorted) < objrefs.Count:\r\n            print(\"BInput curves do not form a single closed loop.\")\r\n            return\r\n\r\n        return (\r\n            [gCs[idx] for idx in idxs_Sorted],\r\n            [rgCs[idx] for idx in idxs_Sorted])\r\n\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve # Curve is also used for brep edges.\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go_Main on repeats of While loop.\r\n    go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n\r\n    go.AcceptNumber(enable=True, acceptZero=True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        addOption('iFilter')\r\n        addOption('bG1_NotG0')\r\n        addOption('bAutoCompleteLoop')\r\n        if not Opts.values['bAutoCompleteLoop']:\r\n            if (sk_PrevSel in sc.sticky) and sc.sticky[sk_PrevSel]:\r\n                key = 'UsePrevSelection'; idxs_Opt[key] = go.AddOption(key)\r\n        addOption('fFreeCADTimeoutSecs')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        if Opts.values['bAutoCompleteLoop']:\r\n            go.SetCommandPrompt(\"Select curve/edge of boundary\")\r\n            res = go.Get()\r\n        else:\r\n            go.SetCommandPrompt(\"Select curves/edges for boundary\")\r\n            res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n\r\n        if Opts.values['iFilter'] == 0:\r\n            go.GeometryAttributeFilter = (\r\n                    ri.Custom.GeometryAttributeFilter.BoundaryEdge |\r\n                    ri.Custom.GeometryAttributeFilter.EdgeCurve |\r\n                    ri.Custom.GeometryAttributeFilter.OpenCurve |\r\n                    ri.Custom.GeometryAttributeFilter.WireCurve)\r\n        if Opts.values['iFilter'] == 1:\r\n            go.GeometryAttributeFilter = (\r\n                    ri.Custom.GeometryAttributeFilter.BoundaryEdge |\r\n                    ri.Custom.GeometryAttributeFilter.EdgeCurve |\r\n                    ri.Custom.GeometryAttributeFilter.OpenCurve)\r\n\r\n        if Opts.values['iFilter'] == 2:\r\n            go.GeometryAttributeFilter = (\r\n                    ri.Custom.GeometryAttributeFilter.OpenCurve |\r\n                    ri.Custom.GeometryAttributeFilter.WireCurve)\r\n\r\n\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n\r\n            if Opts.values['bAutoCompleteLoop']:\r\n                rc = autoSearchForOnlyClosedBoundaryLoop(objrefs[0])\r\n\r\n                if rc is None:\r\n                    sc.doc.Objects.UnselectAll()\r\n                    print(\"AutoCompleteLoop failed.  Option disabled.\")\r\n                    key = 'bAutoCompleteLoop'\r\n                    Opts.riOpts[key].CurrentValue = False\r\n                    Opts.setValue(key)\r\n                    continue\r\n\r\n                go.Dispose()\r\n\r\n                sc.sticky[sk_PrevSel] = None\r\n\r\n                return rc\r\n\r\n            rc = getClosedLoopFromObjRefs(objrefs)\r\n            if not rc: continue\r\n\r\n            go.Dispose()\r\n\r\n            sc.sticky[sk_PrevSel] = objrefs\r\n\r\n            return rc\r\n\r\n\r\n        if res == ri.GetResult.Number:\r\n            num_In = int(go.Number())\r\n            if num_In not in (0,1):\r\n                print(\"Numeric input is invalid.\")\r\n                continue\r\n            key = 'bG1_NotG0'\r\n            Opts.riOpts[key].CurrentValue = bool(num_In)\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n\r\n        # An option was selected.\r\n        if (\r\n            'UsePrevSelection' in idxs_Opt and\r\n            go.Option().Index == idxs_Opt['UsePrevSelection']\r\n        ):\r\n            objrefs = sc.sticky[sk_PrevSel]\r\n            #print(len(objrefs))\r\n            #for objref in objrefs:\r\n            #    go.AppendToPickList(objref)\r\n            #    sc.doc.Views.Redraw()\r\n            rc = getClosedLoopFromObjRefs(objrefs)\r\n            if not rc: continue\r\n\r\n            go.Dispose()\r\n\r\n            sc.sticky[sk_PrevSel] = objrefs\r\n\r\n            return rc\r\n\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\nclass DrawRadiusDotsConduit(Rhino.Display.DisplayConduit):\r\n\r\n    def __init__(self):\r\n        print(\"in __init__\")\r\n        self.prs = None\r\n        displayMode = Rhino.RhinoDoc.ActiveDoc.Views.ActiveView.ActiveViewport.DisplayMode\r\n\r\n    def PostDrawObjects(self, drawEventArgs):\r\n        if not self.prs: return\r\n\r\n        for pt, rad in self.prs:\r\n\r\n            if rad == 0.0:\r\n                continue\r\n\r\n            rc = drawEventArgs.Display.DrawDot(\r\n                worldPosition=pt,\r\n                text=\"{:.{}f}\".format(rad, sc.doc.ModelDistanceDisplayPrecision),\r\n                dotColor=sc.doc.Layers.CurrentLayer.Color,\r\n                textColor=Color.Black if sc.doc.Layers.CurrentLayer.Color != Color.Black else Color.White)\r\n\r\n\r\ndef create_rgs_for_FC(rgCrvs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    rgObjs_Out = []\r\n\r\n    for rgC in rgCrvs:\r\n        if not isinstance(rgC, rg.BrepEdge):\r\n            rgObjs_Out.append(rgC)\r\n            continue\r\n\r\n        # BrepEdge\r\n        edge = rgC\r\n\r\n        if False:\r\n            rg.BrepEdge.Brep\r\n            rg.BrepEdge.AdjacentFaces()\r\n\r\n        for iF in edge.AdjacentFaces():\r\n            face = edge.Brep.Faces[iF]\r\n            rgB_Out = face.DuplicateFace(False)\r\n            if not rgB_Out.IsValid:\r\n                print(\"New monoface brep is not valid.  Script canceled.\")\r\n                return\r\n            rgObjs_Out.append(rgB_Out)\r\n\r\n    return rgObjs_Out\r\n\r\n\r\ndef create_FC_code_Point3Ds_to_Vectors(pts_Mids):\r\n    fc('V=FreeCAD.Vector')\r\n    fc('midVs = []')\r\n    for pt in pts_Mids:\r\n        fc('midVs.append(V({}, {}, {}))'.format(pt.X, pt.Y, pt.Z))\r\n    fc('')\r\n    return True\r\n\r\n\r\ndef export_to_STEP(rgObjs, bDebug=False):\r\n    \"\"\"\r\n    rgObjs: list(Rhino.Geometry.Brep and/or Rhino.Geometry.Curve)\r\n    \"\"\"\r\n\r\n    rdObj_MostRecent = sc.doc.Objects.MostRecentObject()\r\n    uInt32_MostRecent = rdObj_MostRecent.RuntimeSerialNumber\r\n\r\n    gObjs_for_STEP = []\r\n\r\n    for rgObj in rgObjs:\r\n        if isinstance(rgObj, rg.Brep):\r\n            gObj_for_STEP = sc.doc.Objects.AddBrep(rgObj)\r\n        else:\r\n            gObj_for_STEP = sc.doc.Objects.AddCurve(rgObj)\r\n\r\n        if gObj_for_STEP == gObj_for_STEP.Empty:\r\n            print(\"Could not add object for a {} to document.\".format(\r\n                rgObj.GetType().Name))\r\n            sc.doc.Objects.Delete(objectIds=gObjs_for_STEP, quiet=False)\r\n            return\r\n\r\n    rdObjs_toFC = sc.doc.Objects.AllObjectsSince(uInt32_MostRecent)\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n    rc = [sc.doc.Objects.Select(objectId=rdObj.Id) for rdObj in rdObjs_toFC]\r\n\r\n    scriptToExportStp = \" \".join([\r\n        \"_-Export\",\r\n        '\"{}\"'.format(sPath_STEP_to_FC),\r\n        \"_Schema=AP214AutomotiveDesign\",\r\n        \"_ExportParameterSpaceCurves=No\",\r\n        \"_SplitClosedSurfaces=No\",\r\n        \"_Enter\"])\r\n\r\n    if not Rhino.RhinoApp.RunScript(scriptToExportStp, echo=bDebug): return\r\n    rc = [sc.doc.Objects.Delete(objectId=rdObj.Id, quiet=False) for rdObj in rdObjs_toFC]\r\n    if None in rc: return\r\n\r\n    return True\r\n\r\n\r\ndef import_STEP_into_Rhino(bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n    rdObj_MostRecent = sc.doc.Objects.MostRecentObject()\r\n    uInt32_MostRecent = rdObj_MostRecent.RuntimeSerialNumber\r\n\r\n    scriptToImportStp = \" \".join([\r\n        \"_-Import\",\r\n        '\"{}\"'.format(sPath_STEP_from_FC),\r\n        \"_JoinSurfaces=Yes\",\r\n        \"_LimitFaces=No\",\r\n        \"_SkipInvisibles=Yes\",\r\n        \"_ShowBadObjectWarning=Yes\",\r\n        \"_ShowNestedBlockWarning=No\",\r\n        \"_EnterEnd\"])\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Importing STEP ...\")\r\n\r\n    Rhino.RhinoApp.RunScript(scriptToImportStp, echo=bDebug)\r\n\r\n    return sc.doc.Objects.AllObjectsSince(uInt32_MostRecent)\r\n\r\n\r\ndef create_FC_code_Determine_curves_for_border():\r\n\r\n\r\n    #fc('for i, face in enumerate(shape.Faces):')\r\n\r\n\r\n    fc('def index_input_mid_match(edge):')\r\n    fc('    try:')\r\n    fc('        midE=edge.valueAt(edge.Curve.parameterAtDistance(edge.Length/2.0, edge.FirstParameter))')\r\n    fc('    except:')\r\n    fc('        print(edge.Curve)')\r\n    fc('        Part.show(edge)')\r\n    fc('        Part.Vertex(edge.Curve.parameterAtDistance(0.0))')\r\n    fc('        1/0')\r\n    fc('    for i, v in enumerate(midVs):')\r\n    fc('        if midE.distanceToPoint(v) < 0.01:')\r\n    fc('            return i')\r\n    fc()\r\n    fc()\r\n    fc('edges_Border = []')\r\n    fc('idx_edges_to_fillet = []')\r\n    fc('conts_per_edge = []')\r\n    fc()\r\n    fc('for iE, edge in enumerate(shape.Edges):')\r\n    #fc('    print(edge.Length)')\r\n    fc('    if edge.Degenerated:')\r\n    fc('        print(\"Degenerated Edge skipped.\".format(edge.Length))')\r\n    fc('        continue')\r\n    fc('    if edge.Length < 1e-6:')\r\n    fc('        print(\"Edge with length {} skipped.\".format(edge.Length))')\r\n    fc('        continue')\r\n    fc('    if edge.Length < 0.01:')\r\n    fc('        print(\"Edge with length {} skipped.\".format(edge.Length))')\r\n    fc('        continue')\r\n    fc('    idxMid = index_input_mid_match(edge)')\r\n    fc('    if idxMid is None:')\r\n    fc('        continue')\r\n    fc('    edges_Border.append(edge)')\r\n    fc('    idx_edges_to_fillet.append(iE+1)') # Part Edge indices are base 1 in FreeCAD.\r\n    fc('    conts_per_edge.append(iConts_at_pts[idxMid])')\r\n    fc('    if len(edges_Border) == len(midVs):')\r\n    fc('        break')\r\n    fc('else:')\r\n    fc('    raise Exception(\"Not all the input edges were matched to the edges in FreeCAD.\")')\r\n    fc()\r\n    fc()\r\n\r\n\r\ndef subprocess_FC(sArgs, fFreeCADTimeoutSecs=5.0, bEcho=True):\r\n    \"\"\"\r\n    Parameters:\r\n        sArgs: str(Although Popen also accepts a list, trying this when calling FreeCADcmd.exe has so far been unnsuccesful.)\r\n    Returns on success: True\r\n    Returns on fail: False\r\n\r\n    References:\r\n    https://web.archive.org/web/20160709205942/http://www.ironpython.info/index.php?title=Launching_Sub-Processes\r\n    https://www.blog.pythonlibrary.org/2016/05/17/python-101-how-to-timeout-a-subprocess/\r\n    \"\"\"\r\n\r\n    kill = lambda process: process.kill()\r\n\r\n    p = Popen(sArgs, stdin=PIPE, stdout=PIPE, stderr=PIPE, shell=True) # shell=True hides console window.\r\n\r\n    my_timer = Timer(fFreeCADTimeoutSecs, kill, [p])\r\n\r\n\r\n    bSuccess = False\r\n\r\n    try:\r\n        my_timer.start()\r\n        stdout, stderr = p.communicate()\r\n    except:\r\n        pass\r\n    else:\r\n        if stderr or p.returncode:\r\n            if bEcho:\r\n                print(\"Failed to get FreeCAD to complete the filleting.\")\r\n                print(\"stderr from FreeCAD: {}\".format(stderr if stderr else \"None\"))\r\n                if p.returncode:\r\n                    print(\"returncode: {}\".format(p.returncode))\r\n        else:\r\n            bSuccess = True\r\n    finally:\r\n        my_timer.cancel()\r\n\r\n    return bSuccess\r\n\r\n\r\ndef createBrep(rgCrvs_In, iContinuities, fFreeCADTimeoutSecs=10.0, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rgBrep_In: ObjRef or tuple(rd.BrepObject or GUID, float(edge index))\r\n        idxs_Edges: list(int(EdgeIndex))\r\n        fFreeCADTimeoutSecs: float\r\n        bEcho: bool\r\n        bDebug: bool\r\n    \"\"\"\r\n\r\n    sCmdPrompt_In = Rhino.RhinoApp.CommandPrompt\r\n\r\n    #if not rgBrep_In.IsValid:\r\n    #    if bEcho:\r\n    #        print(\"{}-face brep is invalid.  Fix first.  Brep is skipped.\".format(\r\n    #            rgBrep_In.Faces.Count))\r\n    #    return False, None\r\n\r\n\r\n    rgObjs_ToPatch = create_rgs_for_FC(rgCrvs_In)\r\n\r\n    if not rgObjs_ToPatch:\r\n        return\r\n\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Exporting STEP ...\")\r\n    if not export_to_STEP(rgObjs_ToPatch, bDebug): return\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt_In)\r\n\r\n\r\n    pts_Mids = [midPt(rgC_In) for rgC_In in rgCrvs_In]\r\n\r\n\r\n    # Internal distance unit of FreeCAD is the millimeter.\r\n    if sc.doc.ModelUnitSystem != Rhino.UnitSystem.Millimeters:\r\n        fScaleUnit = Rhino.RhinoMath.UnitScale(\r\n            sc.doc.ModelUnitSystem,\r\n            Rhino.UnitSystem.Millimeters) # from, to\r\n\r\n        # Breps sent to FC via STEP do not need to be scaled.\r\n\r\n        for iP, pt in enumerate(pts_Mids):\r\n            pts_Mids[iP].X = pt.X * fScaleUnit\r\n            pts_Mids[iP].Y = pt.Y * fScaleUnit\r\n            pts_Mids[iP].Z = pt.Z * fScaleUnit\r\n\r\n\r\n    fc('import FreeCAD as App')\r\n    fc('import Part')\r\n    fc()\r\n    fc()\r\n\r\n\r\n    if not create_FC_code_Point3Ds_to_Vectors(pts_Mids):\r\n        raise Exception(\"Could not create_FC_code_Point3Ds_to_Vectors.\") \r\n\r\n    fc('iConts_at_pts = []')\r\n    for iCont in iContinuities:\r\n        fc('iConts_at_pts.append({})'.format(iCont))\r\n    fc()\r\n\r\n\r\n    fc('shape = Part.Shape()')\r\n    fc('shape.read(r\"{}\")'.format(sPath_STEP_to_FC))\r\n\r\n    fc('Part.show(shape)')\r\n\r\n    fc('doc = FreeCAD.ActiveDocument')\r\n    fc('doc.recompute()')\r\n\r\n\r\n\r\n    # For debugging.\r\n    #fc()\r\n    #script_FC = \"\\n\".join(s_FC)\r\n    #with open(sPath_Script_for_FC, \"w\") as f: \r\n    #    f.write(script_FC) \r\n    #return True, None\r\n    #\r\n\r\n\r\n    fc()\r\n    fc()\r\n\r\n\r\n    #create_FC_code_Determine_curves_for_border()\r\n\r\n\r\n    #fc('shapes_Es = [e.Curve.toShape() for e in edges_Border]')\r\n\r\n    # Add Part::PartFeatures.\r\n    fc('face_objs = []')\r\n    fc('edge_objs = []')\r\n    fc('fevs = [] # PartFeature Face, Edge.Name, Vector (midpoint)')\r\n    fc('for i, face in enumerate(shape.Faces):')\r\n    fc('    face_obj = doc.addObject(\"Part::Feature\",\"Face{}\".format(i))')\r\n    fc('    face_obj.Shape = face')\r\n    fc('    face_objs.append(face_obj)')\r\n    fc('    for j, edge in enumerate(face_obj.Shape.Edges):')\r\n    fc('        midE=edge.valueAt(edge.Curve.parameterAtDistance(edge.Length/2.0, edge.FirstParameter))')\r\n    fc('        fevs.append((face_obj, j+1, midE))')\r\n    #fc('        edge_obj = doc.addObject(\"Part::Feature\",\"Edge{} {}\".format(i, j))')\r\n    #fc('        edge_obj.Shape = edge')\r\n    #fc('        edge_objs.append(edge_obj)')\r\n    fc()\r\n    fc('doc.recompute()')\r\n    fc()\r\n\r\n    fc('fevs_ordered = []')\r\n    fc('for i, v in enumerate(midVs):')\r\n    fc('    for j, fev in enumerate(fevs):')\r\n    fc('        if fev[2].distanceToPoint(v) < 0.01:')\r\n    fc('            fevs_ordered.append(fev)')\r\n    fc()\r\n    fc()\r\n\r\n\r\n    fc('# Patch')\r\n    #fc('edge_objs = []')\r\n    #fc('for i, edge in enumerate(edges_Border):')\r\n    #fc('    edge_obj = doc.addObject(\"Part::Feature\",\"Edge{}\".format(i))')\r\n    #fc('    edge_obj.Shape = edge')\r\n    #fc('    edge_objs.append(edge_obj)')\r\n    #fc()\r\n    #fc('doc.recompute()')\r\n    fc()\r\n    #fc('data_for_featFilling = []')\r\n    #fc('for i, eo in enumerate(edges_Border):')\r\n    #fc('    data_for_featFilling.append((eo, (\"Edge1\".format(i))))')\r\n    #fc()\r\n    fc('patch = doc.addObject(\"Surface::Filling\",\"Patch\")')\r\n    fc()\r\n    #fc('doc.Patch.Base = doc.Shape')\r\n    #fc('patch.BoundaryEdges = edge_objs')\r\n    #fc('patch.BoundaryEdges = [(face_objs[i], \"Edge1\".format(i)) for i in range(len(edge_objs))]')\r\n    fc('patch.BoundaryEdges = [(fevs_ordered[i][0], \"Edge{}\".format(fevs_ordered[i][1])) for i in range(len(fevs_ordered))]')\r\n    #fc('    (edge_objs[0], \"Edge1\"),')\r\n    #fc('    (edge_objs[1], \"Edge1\"),')\r\n    #fc('    (edge_objs[2], \"Edge1\"),')\r\n    #fc('    (edge_objs[3], \"Edge1\"),')\r\n    #fc('    (edge_objs[4], \"Edge1\"),')\r\n    #fc('    (edge_objs[5], \"Edge1\"),')\r\n    #fc('    ]')\r\n    fc()\r\n    #fc('patch.BoundaryEdges = [(edges_Border[0], \"Edge1\"), (edges_Border[1], \"Edge1\")]')\r\n    #fc('patch.BoundaryFaces = [face_objs[i].Label for i in range(len(face_objs))]')\r\n    #fc('patch.BoundaryFaces = [')\r\n    #fc('    face_objs[0].Label,')\r\n    #fc('    face_objs[1].Label,')\r\n    #fc('    face_objs[2].Label,')\r\n    #fc('    face_objs[3].Label,')\r\n    #fc('    face_objs[4].Label,')\r\n    #fc('    face_objs[5].Label,')\r\n    #fc('    ]')\r\n    fc('patch.BoundaryFaces = [\"Face1\" for i in range(len(face_objs))]')\r\n    fc()\r\n    fc('patch.BoundaryOrder = iConts_at_pts')\r\n    fc()\r\n    fc('doc.recompute()')\r\n    fc('doc.Shape.Visibility = False')\r\n    fc()\r\n    fc()\r\n\r\n\r\n    # Create STEP file for Rhino.\r\n    fc('import Import')\r\n    fc('Import.export([doc.Patch], r\"{}\")'.format(sPath_STEP_from_FC))\r\n    fc()\r\n    fc()\r\n\r\n\r\n    # Create script file.\r\n    fc()\r\n    script_FC = \"\\n\".join(s_FC)\r\n\r\n    with open(sPath_Script_for_FC, \"w\") as f: \r\n        f.write(script_FC) \r\n\r\n\r\n    # Send script to headless FreeCAD (FreeCADcmd.exe) via subprocess.\r\n    sForConsole = sFCcmd_Path + \" RunMode=Script \" + '\"{}\"'.format(sPath_Script_for_FC)\r\n\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Running FreeCAD ...\")\r\n\r\n    rc = subprocess_FC(sForConsole, fFreeCADTimeoutSecs=fFreeCADTimeoutSecs, bEcho=bEcho)\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt_In)\r\n\r\n    return bool(rc)\r\n\r\n\r\ndef createBrepObject(rhCrvs_In, iContinuities, fFreeCADTimeoutSecs=10.0, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rhCrvs_In: list(ObjRef or rg.Curves)\r\n        iContinuities: list(int(Geometric continuity order))\r\n        fFreeCADTimeoutSecs: float\r\n        bEcho: bool\r\n        bDebug: bool\r\n    \"\"\"\r\n\r\n    sCmdPrompt_In = Rhino.RhinoApp.CommandPrompt\r\n\r\n\r\n    rgObjs_For_FC = []\r\n\r\n    #for rgC in rhCrvs_In:\r\n    #    if isinstance(rgC, rg.BrepEdge):\r\n            \r\n    #    if not rgC.IsValid:\r\n\r\n    #if not rdB_In: return\r\n\r\n\r\n    #if not rgB_In.IsValid:\r\n    #    print(\"Brep {} is invalid.  Fix first.  Brep is skipped.\".format(gB_In))\r\n    #    return\r\n\r\n    if not createBrep(\r\n        rhCrvs_In,\r\n        iContinuities=iContinuities,\r\n        fFreeCADTimeoutSecs=fFreeCADTimeoutSecs,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug\r\n    ):\r\n        return\r\n\r\n    rdB_from_FC = import_STEP_into_Rhino(bDebug)\r\n    if not rdB_from_FC:\r\n        if bEcho:\r\n            print(\"Patch was not imported.\")\r\n        return\r\n\r\n    return rdB_from_FC\r\n\r\n\r\ndef main():\r\n\r\n\r\n    gBs_In = [] # This is used as the index for the brep in the following routine.\r\n    idx_rgEdges_PerBrep = []\r\n    rads_for_idxEs_PerBrep = []\r\n\r\n\r\n    prevSels_Present = []\r\n\r\n    #skey_conduit = 'conduit({})'.format(__file__)\r\n    #if (skey_conduit in sc.sticky) and sc.sticky[skey_conduit]:\r\n    #    conduit = sc.sticky[skey_conduit]\r\n    #else:\r\n    #    conduit = DrawRadiusDotsConduit()\r\n    #    sc.sticky[skey_conduit] = conduit\r\n\r\n    #conduit.Enabled = False # Turns off the conduit if left on from a previous execution of this script.\r\n    #sc.doc.Views.Redraw()\r\n\r\n\r\n    def getEdgeIndex_MatchingMidPoint(rgBrep, midpt):\r\n        for edge in rgBrep.Edges:\r\n            ts = list(edge.DivideByCount(2, includeEnds=False))\r\n            if not ts:\r\n                print(\"Midpoint of edge[{}] not found.\".format(edge.EdgeIndex))\r\n                return\r\n            if edge.PointAt(ts[0]).DistanceTo(midpt) < 0.1 * sc.doc.ModelAbsoluteTolerance:\r\n                return edge.EdgeIndex\r\n\r\n\r\n    def prepareDataForPreviewAndSticky():\r\n        zipped = zip(gBs_In, idx_rgEdges_PerBrep, rads_for_idxEs_PerBrep)\r\n\r\n\r\n        rgBs = []\r\n        pts_Mids_All = [] # Won't include matching radius of 0.0.\r\n        rads_All = [] # Won't include radius of 0.0.\r\n        \r\n        bprs = [] # list of tuples of (GUID, pts, radii) for saving input for future use of script.\r\n\r\n        for gB_In, idxs_Es, rads_for_idxEs in zipped:\r\n            rdB = sc.doc.Objects.FindId(gB_In)\r\n            rgB = rdB.Geometry\r\n            rgBs.append(rgB)\r\n            pts_Mids_ThisB = [] # Won't include matching radius of 0.0.\r\n            rads_ThisB = [] # Won't include radius of 0.0.\r\n\r\n            for i, rad in enumerate(rads_for_idxEs):\r\n                if rad == 0.0:\r\n                    continue\r\n                iE = idxs_Es[i]\r\n                ts = list(rgB.Edges[iE].DivideByCount(2, includeEnds=False))\r\n                if not ts:\r\n                    print(\"Midpoint of edge[{}] not found.\".format(iE))\r\n                    return\r\n                pt = rgB.Edges[iE].PointAt(ts[0])\r\n                pts_Mids_ThisB.append(pt)\r\n                rads_ThisB.append(rad)\r\n\r\n            if not pts_Mids_ThisB: continue\r\n            bprs.append((rdB.Id, pts_Mids_ThisB, rads_ThisB))\r\n            pts_Mids_All.extend(pts_Mids_ThisB)\r\n            rads_All.extend(rads_ThisB)\r\n\r\n        sc.sticky[skey_prevSels] = bprs\r\n\r\n        if not rgBs: return\r\n\r\n        return pts_Mids_All, rads_All\r\n\r\n\r\n    rc = getInput()\r\n    if rc is None: return\r\n    print(*rc, sep='\\n')\r\n    gBs, rgCs = rc\r\n\r\n\r\n    #while True:\r\n\r\n    #    if rc is None:\r\n    #        conduit.Enabled = False\r\n    #        del conduit\r\n    #        del sc.sticky[skey_conduit]\r\n    #        sc.sticky[skey_conduit] = None\r\n    #        return\r\n\r\n    #    fRadius = Opts.values['fRadius']\r\n    #    fFreeCADTimeoutSecs = Opts.values['fFreeCADTimeoutSecs']\r\n    #    bEcho = Opts.values['bEcho']\r\n    #    bDebug = Opts.values['bDebug']\r\n\r\n    #    sc.doc.Objects.UnselectAll()\r\n    #    sc.doc.Views.Redraw()\r\n\r\n    #    if not rc:\r\n    #        print(\"Proceeding to create fillets.\")\r\n    #        conduit.Enabled = False\r\n    #        del conduit\r\n    #        break\r\n\r\n    #    objrefs = rc\r\n\r\n    #    rc = prepareDataForPreviewAndSticky()\r\n    #    if not rc: continue\r\n    #    pts_Mids_All, rads_All = rc\r\n\r\n    #    conduit.prs = zip(pts_Mids_All, rads_All)\r\n\r\n    #    conduit.Enabled = True\r\n    #    sc.doc.Views.Redraw()\r\n\r\n\r\n    #if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\r\n\r\n    rc = createBrepObject(\r\n        rgCs,\r\n        iContinuities=[int(Opts.values['bG1_NotG0']) for i in range(len(rgCs))],\r\n        fFreeCADTimeoutSecs=Opts.values['fFreeCADTimeoutSecs'],\r\n        bEcho=Opts.values['bEcho'],\r\n        bDebug=Opts.values['bDebug'])\r\n\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}