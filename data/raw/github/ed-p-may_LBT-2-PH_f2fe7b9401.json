{
  "source_url": "https://github.com/ed-p-may/LBT-2-PH/blob/3c2bbdf0cb26deb92d36b870aeb920cbc31d8da2/scripts/LBT2PH/ventilation.py",
  "repo": "ed-p-may/LBT-2-PH",
  "repo_stars": 12,
  "repo_description": "LBT2PH is a free toolkit for creating PHPP energy models from Ladybug Tools v1.0+ definitions.",
  "license": "GPL-3.0",
  "filepath": "scripts/LBT2PH/ventilation.py",
  "instruction": "Ventilation",
  "code": "from collections import namedtuple\nimport re\nimport random\n\nimport rhinoscriptsyntax as rs\nimport ghpythonlib.components as ghc\nimport Rhino\nimport Grasshopper.Kernel as ghK\nfrom System import Object\n\nfrom honeybee_energy.schedule.ruleset import ScheduleRuleset\nfrom honeybee_energy.lib.schedules import schedule_by_identifier\nfrom ladybug.dt import Date\n\nimport LBT2PH\nimport LBT2PH.helpers\n\nreload(LBT2PH)\nreload(LBT2PH.helpers)\n\n\nclass duct_input_handler:\n    \"\"\"Manages the varous types of inputs that the user might give for the ducts\"\"\"\n\n    def __init__(self, _ghdoc, _ghenv):\n        self.ghdoc = _ghdoc\n        self.ghenv = _ghenv\n\n    def is_gh_geometry(self, _in):\n        \"\"\"Geom that is generated 'in' Grasshopper has a 0 GUID\"\"\"\n\n        if _in == \"00000000-0000-0000-0000-000000000000\":\n            return True\n        else:\n            return False\n\n    def get_input_GUID(self, i, index_num):\n        \"\"\"Find the actual GUID of the input object from its input node\n        Args:\n            i (int): The index of the input list to look at\n            index_num (int): The index number of the input-node to look at\n        \"\"\"\n\n        guid = (\n            self.ghenv.Component.Params.Input[index_num]\n            .VolatileData[0][i]\n            .ReferenceID.ToString()\n        )\n\n        return guid\n\n    def get_params_from_rhino(self, _in):\n        \"\"\"Got and find any param values in the geometry in the RH Scene\n        Args:\n            _in (Rhino.Geometry.Curve): The Rhino Curve object to look at\n        Returns:\n            (tuple) length, width, thickness, lambda\n        \"\"\"\n\n        with LBT2PH.helpers.context_rh_doc(self.ghdoc):\n            try:\n                l = float(ghc.Length(_in))\n                w = float(rs.GetUserText(_in, \"ductWidth\"))\n                t = float(rs.GetUserText(_in, \"insulThickness\"))\n                c = float(rs.GetUserText(_in, \"insulConductivity\"))\n            except Exception as e:\n                print(\"Error getting values from Rhino Scene\\n{}\".format(e))\n                return None, None, None, None\n\n        return l, w, t, c\n\n    def get_segment(self, i, _in, _input_node_index_num):\n        \"\"\"Sorts out and gets the params of the input (number | curve | line)\n        Args:\n            i (int): The index of the segment to be analysed\n            _in (number | curve | line): The input item to be analysed\n        Returns:\n            (namedtuple) Segment(length='', width='', i_thickness='', i_lambda='')\n        \"\"\"\n\n        Segment = namedtuple(\"Segment\", [\"length\", \"width\", \"i_thickness\", \"i_lambda\"])\n\n        try:\n            # If its just a regular number input\n            length = float(LBT2PH.helpers.convert_value_to_metric(_in, \"M\"))\n            return Segment(length, None, None, None)\n        except AttributeError as e:\n            # OK, so its not a regular number, try and sort out what geometry it is...\n            seg_GUID = self.get_input_GUID(i, _input_node_index_num)\n\n            if isinstance(_in, Rhino.Geometry.Curve):\n                if self.is_gh_geometry(seg_GUID):\n                    crv = rs.coercecurve(_in)\n                    crv_length = crv.GetLength()\n                    return Segment(crv_length, None, None, None)\n                else:\n                    return Segment(*self.get_params_from_rhino(seg_GUID))\n\n            elif isinstance(_in, Rhino.Geometry.Line):\n                if self.is_gh_geometry(seg_GUID):\n                    line = rs.coerceline(_in)\n                    line_len = line.Length\n                    return Segment(line_len, None, None, None)\n                else:\n                    return Segment(*self.get_params_from_rhino(seg_GUID))\n\n            else:\n                msg = (\n                    \" Sorry, I do not understand the input for _duct_length?\\n\"\n                    \"Please input either: a list of Rhino Curves, Lines or numbers representing\\n\"\n                    \"the lengths of the duct segments.\\n\\n{}\".format(e)\n                )\n                raise Exception(msg)\n\n\nclass PHPP_Sys_Duct_Segment(Object):\n    def __init__(self, _len=1, _width=104, _i_thick=52, _i_lambda=0.04):\n        \"\"\"An individual duct segment. A duct is made of 1 or more segments.\n\n        Args:\n            _len (float): The length of the segment in Meters\n            _width (float): The width of the segment in MM\n            _i_thick (float): The thickness of the segment's insualtion, in MM\n            _i_lambda (float): The lambda condictivity of the segment's insualtion in W/mk\n        \"\"\"\n\n        self.id = random.randint(1000, 9999)\n        self.length = _len\n        self.width = _width\n        self.insul_thick = _i_thick\n        self.insul_lambda = _i_lambda\n\n    def to_dict(self):\n        d = {}\n        d.update({\"id\": self.id})\n        d.update({\"length\": self.length})\n        d.update({\"width\": self.width})\n        d.update({\"insulation_thickness\": self.insul_thick})\n        d.update({\"insulation_lambda\": self.insul_lambda})\n\n        return d\n\n    @classmethod\n    def from_dict(cls, _dict):\n        new_segment = cls()\n        new_segment.id = _dict.get(\"id\")\n        new_segment.length = _dict.get(\"length\")\n        new_segment.width = _dict.get(\"width\")\n        new_segment.insul_thick = _dict.get(\"insulation_thickness\")\n        new_segment.insul_lambda = _dict.get(\"insulation_lambda\")\n\n        return new_segment\n\n    def __unicode__(self):\n        return u\"PHPP Ventilation Duct-Segment Object\"\n\n    def __str__(self):\n        return unicode(self).encode(\"utf-8\")\n\n    def __repr__(self):\n        return \"{}( _len={!r}, _width={!r}, _i_thick={!r}, _i_lambda={!r})\".format(\n            self.__class__.__name__,\n            self.length,\n            self.width,\n            self.insul_thick,\n            self.insul_lambda,\n        )\n\n    def ToString(self):\n        return str(self)\n\n\nclass PHPP_Sys_Duct(Object):\n    def __init__(self, _segments=[PHPP_Sys_Duct_Segment()]):\n        \"\"\"A Single Duct Object representing a collection of Duct-Segments\n\n        Args: _segments (list): A list of 'PHPP_Sys_Duct_Segment' objects\n        \"\"\"\n        self.id = random.randint(1000, 9999)\n        self._segments = _segments\n\n    def _len_weighted_avg(self, _attr):\n        \"\"\"Returns length-weighted average duct attr\"\"\"\n\n        weighted_total = sum(seg.length * getattr(seg, _attr) for seg in self._segments)\n\n        try:\n            return weighted_total / self.duct_length\n        except ZeroDivisionError:\n            msg = \" Can't calculate the weighted average. Duct segment has a 0m length?\"\n            raise ZeroDivisionError(msg)\n\n    @property\n    def segments(self):\n        return self._segments\n\n    @segments.setter\n    def segments(self, _in):\n        if isinstance(_in, list):\n            self._segments = _in\n        else:\n            msg = 'Error: input for {} \"segments\" must be a list.'.format(\n                self.__class__.__name__\n            )\n            raise Exception(msg)\n\n    @property\n    def duct_length(self):\n        return sum(segment.length for segment in self._segments)\n\n    @property\n    def duct_width(self):\n        return self._len_weighted_avg(\"width\")\n\n    @property\n    def insulation_thickness(self):\n        return self._len_weighted_avg(\"insul_thick\")\n\n    @property\n    def insulation_lambda(self):\n        return self._len_weighted_avg(\"insul_lambda\")\n\n    def to_dict(self):\n        d = {}\n\n        d.update({\"id\": self.id})\n\n        seg_d = {}\n        for segment in self._segments:\n            seg_d.update({segment.id: segment.to_dict()})\n        d.update({\"segments\": seg_d})\n\n        return d\n\n    @classmethod\n    def from_dict(cls, _dict):\n        new_obj = cls()\n        new_obj.id = _dict.get(\"id\")\n\n        segments = []\n        for segment in _dict.get(\"segments\", {}).values():\n            seg = PHPP_Sys_Duct_Segment.from_dict(segment)\n            segments.append(seg)\n        new_obj.segments = segments\n\n        return new_obj\n\n    def __unicode__(self):\n        return u\"PHPP Ventilation Duct Object\"\n\n    def __str__(self):\n        return unicode(self).encode(\"utf-8\")\n\n    def __repr__(self):\n        return \"{}( _segments={!r})\".format(self.__class__.__name__, self.segments)\n\n    def ToString(self):\n        return str(self)\n\n\nclass PHPP_Sys_VentUnit(Object):\n    def __init__(\n        self,\n        _nm=\"97ud-Default HRV unit\",\n        _hr=0.75,\n        _mr=0,\n        _elec=0.45,\n        _frsotT=-5,\n        _ext=False,\n    ):\n        self.id = random.randint(1000, 9999)\n        self._name = _nm\n        self._HR_eff = _hr\n        self._MR_eff = _mr\n        self._elec_eff = _elec\n        self._frost_temp = _frsotT\n        self._exterior = _ext\n\n    @property\n    def name(self):\n        try:\n            return str(self._name)\n        except:\n            return \"Default Name\"\n\n    @name.setter\n    def name(self, _in):\n        try:\n            self._name = str(_in)\n        except Exception as e:\n            print(e)\n            pass\n\n    @property\n    def HR_eff(self):\n        try:\n            return float(self._HR_eff)\n        except:\n            return 0.75\n\n    @HR_eff.setter\n    def HR_eff(self, _in):\n        try:\n            self._HR_eff = float(_in)\n        except Exception as e:\n            print(e)\n            pass\n\n    @property\n    def MR_eff(self):\n        try:\n            return float(self._MR_eff)\n        except:\n            return 0.0\n\n    @MR_eff.setter\n    def MR_eff(self, _in):\n        try:\n            self._MR_eff = float(_in)\n        except Exception as e:\n            print(e)\n            pass\n\n    @property\n    def elec_eff(self):\n        try:\n            return float(self._elec_eff)\n        except:\n            return 0.45\n\n    @MR_eff.setter\n    def elec_eff(self, _in):\n        try:\n            self._elec_eff = float(_in)\n        except Exception as e:\n            print(e)\n            pass\n\n    @property\n    def frost_temp(self):\n        try:\n            return float(self._frost_temp)\n        except:\n            return -5\n\n    @frost_temp.setter\n    def frost_temp(self, _in):\n        try:\n            self._frost_temp = float(_in)\n        except Exception as e:\n            print(e)\n            pass\n\n    @property\n    def exterior(self):\n        try:\n            return \"x\" if self._exterior else \"\"\n        except:\n            return \"\"\n\n    @exterior.setter\n    def exterior(self, _in):\n        try:\n            self._exterior = \"x\" if _in else \"\"\n        except Exception as e:\n            print(e)\n            pass\n\n    def to_dict(self):\n        d = {}\n        d.update({\"id\": self.id})\n        d.update({\"_name\": self.name})\n        d.update({\"_HR_eff\": self.HR_eff})\n        d.update({\"_MR_eff\": self.MR_eff})\n        d.update({\"_elec_eff\": self.elec_eff})\n        d.update({\"_frost_temp\": self.frost_temp})\n        d.update({\"_exterior\": self.exterior})\n\n        return d\n\n    @classmethod\n    def from_dict(cls, _dict):\n        id = _dict[\"id\"]\n        name = _dict[\"_name\"]\n        hr = _dict[\"_HR_eff\"]\n        mr = _dict[\"_MR_eff\"]\n        elec = _dict[\"_elec_eff\"]\n        frost_temp = _dict[\"_frost_temp\"]\n        ext = _dict[\"_exterior\"]\n\n        new_vent_unit = cls(name, hr, mr, elec, frost_temp, ext)\n        new_vent_unit.id = id\n\n        return new_vent_unit\n\n    def __unicode__(self):\n        return u\"PHPP Ventilation Unit (ERV/HRV) Object: <{self.name}>\".format(\n            self=self\n        )\n\n    def __str__(self):\n        return unicode(self).encode(\"utf-8\")\n\n    def __repr__(self):\n        return \"{}( _nm={!r}, _hr={!r}, _mr={!r}, _elec={!r}, _frsot={!r}, _ext={!r}\".format(\n            self.__class__.__name__,\n            self.name,\n            self.HR_eff,\n            self.MR_eff,\n            self.elec_eff,\n            self.frost_temp,\n            self.exterior,\n        )\n\n    def ToString(self):\n        return str(self)\n\n\nclass PHPP_Sys_ExhaustVent(Object):\n    def __init__(\n        self,\n        nm=\"Default_Exhaust_Vent\",\n        airFlowRate_On=450,\n        airFlowRate_Off=25,\n        hrsPerDay_On=0.5,\n        daysPerWeek_On=7,\n        default_duct=PHPP_Sys_Duct(),\n    ):\n\n        self.id = random.randint(1000, 9999)\n        self._name = nm\n        self.vent_floor_area = 10\n        self.vent_area_height = 2.5\n        self._phpp_ud_name = None\n\n        self.flow_rate_on = self._evaluateInputUnits(airFlowRate_On)\n        self.flow_rate_off = self._evaluateInputUnits(airFlowRate_Off)\n        self.hours_per_day_on = hrsPerDay_On\n        self.days_per_week_on = daysPerWeek_On\n        self.holidays = 0\n\n        self.duct_01 = default_duct\n        self.duct_02 = default_duct\n\n    @property\n    def name(self):\n        try:\n            return str(self._name)\n        except:\n            return \"Exhaust_Unit\"\n\n    @name.setter\n    def name(self, _in):\n        self._name = str(_in)\n\n    def _evaluateInputUnits(self, _in):\n        \"\"\"If values are passed including a 'cfm' string, will\n        set the return value to the m3/h equivalent\"\"\"\n\n        if _in is None:\n            return None\n\n        outputVal = 0\n\n        try:\n            outputVal = float(_in)\n        except:\n            # Pull out just the decimal characters\n            inputVal = _in.replace(\" \", \"\")\n            for each in re.split(r\"[^\\d\\.]\", inputVal):\n                if len(each) > 0:\n                    outputVal = each\n\n            # Convert to m3/h if necessary\n            if \"cfm\" in inputVal:\n                outputVal = float(outputVal) * 1.699010796  # cfm--->m3/h\n\n        return float(outputVal)\n\n    @property\n    def phpp_ud_name(self):\n        try:\n            return str(self._phpp_ud_name)\n        except Exception as e:\n            print(e)\n            return None\n\n    @phpp_ud_name.setter\n    def phpp_ud_name(self, _in):\n        try:\n            self._phpp_ud_name = str(_in)\n        except Exception as e:\n            print(e)\n            pass\n\n    def to_dict(self):\n        d = {}\n\n        d.update({\"id\": self.id})\n        d.update({\"_name\": self.name})\n        d.update({\"vent_floor_area\": self.vent_floor_area})\n        d.update({\"vent_area_height\": self.vent_area_height})\n        d.update({\"flow_rate_on\": self.flow_rate_on})\n        d.update({\"flow_rate_off\": self.flow_rate_off})\n        d.update({\"hours_per_day_on\": self.hours_per_day_on})\n        d.update({\"days_per_week_on\": self.days_per_week_on})\n        d.update({\"holidays\": self.holidays})\n        d.update({\"duct_01\": self.duct_01.to_dict()})\n        d.update({\"duct_02\": self.duct_02.to_dict()})\n\n        return d\n\n    @classmethod\n    def from_dict(cls, _dict):\n        nm = _dict[\"_name\"]\n        airFlowRate_On = _dict[\"flow_rate_on\"]\n        airFlowRate_Off = _dict[\"flow_rate_off\"]\n        hrsPerDay_On = _dict[\"hours_per_day_on\"]\n        daysPerWeek_On = _dict[\"days_per_week_on\"]\n        default_duct = _dict[\"duct_01\"]\n\n        new_exhaust_obj = cls(\n            nm,\n            airFlowRate_On,\n            airFlowRate_Off,\n            hrsPerDay_On,\n            daysPerWeek_On,\n            default_duct,\n        )\n        new_exhaust_obj.id = _dict[\"id\"]\n        new_exhaust_obj.duct_01 = PHPP_Sys_Duct.from_dict(_dict[\"duct_01\"])\n        new_exhaust_obj.duct_02 = PHPP_Sys_Duct.from_dict(_dict[\"duct_02\"])\n        new_exhaust_obj.holidays = _dict[\"holidays\"]\n\n        return new_exhaust_obj\n\n    def __str__(self):\n        return unicode(self).encode(\"utf-8\")\n\n    def __unicode__(self):\n        return u\"A PHPP Exhaust-Air Object: < {self.name} >\".format(self=self)\n\n    def __repr__(self):\n        return (\n            \"{}( nm={!r}, airFlowRate_On={!r}, airFlowRate_Off={!r},\"\n            \"hrsPerDay_On={!r},daysPerWeek_On={!r},\"\n            \"default_duct={!r} )\".format(\n                self.__class__.__name__,\n                self.name,\n                self.flow_rate_on,\n                self.flow_rate_off,\n                self.hours_per_day_on,\n                self.days_per_week_on,\n                self.duct_01,\n            )\n        )\n\n    def ToString(self):\n        return str(self)\n\n\nclass PHPP_Sys_VentSchedule(Object):\n    def __init__(self, s_h=1.0, t_h=1.0, s_m=0.77, t_m=0.0, s_l=0.4, t_l=0.0):\n        self.id = random.randint(1000, 9999)\n        self.speed_high = s_h\n        self.time_high = t_h\n        self.speed_med = s_m\n        self.time_med = t_m\n        self.speed_low = s_l\n        self.time_low = t_l\n\n    def to_dict(self):\n        d = {}\n        d.update({\"id\": self.id})\n        d.update({\"speed_high\": self.speed_high})\n        d.update({\"time_high\": self.time_high})\n        d.update({\"speed_med\": self.speed_med})\n        d.update({\"time_med\": self.time_med})\n        d.update({\"speed_low\": self.speed_low})\n        d.update({\"time_low\": self.time_low})\n\n        return d\n\n    @classmethod\n    def from_dict(cls, _dict):\n        new_sched = cls()\n        new_sched.id = _dict[\"id\"]\n        new_sched.speed_high = _dict[\"speed_high\"]\n        new_sched.time_high = _dict[\"time_high\"]\n        new_sched.speed_med = _dict[\"speed_med\"]\n        new_sched.time_med = _dict[\"time_med\"]\n        new_sched.speed_low = _dict[\"speed_low\"]\n        new_sched.time_low = _dict[\"time_low\"]\n\n        return new_sched\n\n    def check_total(self):\n        total_time = self.time_high + self.time_med + self.time_low\n        if total_time > 1.001 or total_time < 0.999:\n            msg = \"Error. The Operation times don't add up to 100%? Please correct the inputs.\"\n            return msg\n        else:\n            return None\n\n    def __str__(self):\n        return unicode(self).encode(\"utf-8\")\n\n    def __unicode__(self):\n        return u\"A PHPP Ventilation Schedule Object: <{self.id}>\".format(self=self)\n\n    def __repr__(self):\n        return \"{}( s_h={!r}, t_h={!r}, s_m={!r}, t_m={!r}, s_l={!r}, t_l={!r})\".format(\n            self.__class__.__name__,\n            self.speed_high,\n            self.time_high,\n            self.speed_med,\n            self.time_med,\n            self.speed_low,\n            self.time_low,\n        )\n\n    def ToString(self):\n        return str(self)\n\n\nclass PHPP_Sys_Ventilation(Object):\n    def __init__(\n        self,\n        _ghenv=None,\n        _system_type=\"1-Balanced PH ventilation with HR\",\n        _systemName=\"Vent-1\",\n        _unit=PHPP_Sys_VentUnit(),\n        _d01=PHPP_Sys_Duct(),\n        _d02=PHPP_Sys_Duct(),\n        _exhaustObjs=[],\n    ):\n\n        self.system_id = random.randint(1000, 9999)\n        self.ghenv = _ghenv\n        self.system_type = _system_type\n        self.system_name = _systemName\n        self.vent_unit = _unit\n        self.duct_01 = _d01\n        self.duct_02 = _d02\n        self.exhaust_vent_objs = _exhaustObjs\n        self._phpp_ud_name = None\n\n        self.setVentSystemType(_ghenv)\n\n    @property\n    def phpp_ud_name(self):\n        try:\n            return str(self._phpp_ud_name)\n        except Exception as e:\n            print(e)\n            return None\n\n    @phpp_ud_name.setter\n    def phpp_ud_name(self, _in):\n        try:\n            self._phpp_ud_name = str(_in)\n        except Exception as e:\n            print(e)\n            pass\n\n    def __eq__(self, other):\n        return self.system_id == other.system_id\n\n    def __hash__(self):\n        return hash(str(self.system_id))\n\n    def setVentSystemType(self, _ghenv):\n        if \"1\" in self.system_type:\n            self.system_type = \"1-Balanced PH ventilation with HR\"\n        elif \"2\" in self.system_type:\n            self.system_type = \"2-Extract air unit\"\n        elif \"3\" in self.system_type:\n            self.system_type = \"3-Only window ventilation\"\n        else:\n            warning = \"Error setting Ventilation System Type? Input only Type 1, 2, or 3. Setting to Type 1 (HRV) as default\"\n            try:\n                _ghenv.Component.AddRuntimeMessage(\n                    ghK.GH_RuntimeMessageLevel.Warning, warning\n                )\n            except:\n                pass\n            self.system_type = \"1-Balanced PH ventilation with HR\"\n\n    def to_dict(self):\n        d = {}\n        d.update({\"system_id\": self.system_id})\n        d.update({\"system_type\": self.system_type})\n        d.update({\"system_name\": self.system_name})\n        d.update({\"vent_unit\": self.vent_unit.to_dict()})\n        d.update({\"duct_01\": self.duct_01.to_dict()})\n        d.update({\"duct_02\": self.duct_02.to_dict()})\n        if self.exhaust_vent_objs:\n            d.update(\n                {\n                    \"exhaust_vent_objs\": [\n                        exhaust_obj.to_dict() for exhaust_obj in self.exhaust_vent_objs\n                    ]\n                }\n            )\n\n        return d\n\n    @classmethod\n    def from_dict(cls, _dict, _ghenv=None):\n\n        exhaust_objs = []\n        for exhaust_system_dict in _dict.get(\"exhaust_vent_objs\", []):\n            exhaust_objs.append(PHPP_Sys_ExhaustVent.from_dict(exhaust_system_dict))\n\n        new_obj = cls()\n        new_obj.ghenv = _ghenv\n        new_obj.system_id = _dict.get(\"system_id\")\n        new_obj.system_type = _dict.get(\"system_type\")\n        new_obj.system_name = _dict.get(\"system_name\")\n        new_obj.vent_unit = PHPP_Sys_VentUnit.from_dict(_dict.get(\"vent_unit\"))\n        new_obj.duct_01 = PHPP_Sys_Duct.from_dict(_dict.get(\"duct_01\"))\n        new_obj.duct_02 = PHPP_Sys_Duct.from_dict(_dict.get(\"duct_02\"))\n        new_obj.exhaust_vent_objs = exhaust_objs\n\n        return new_obj\n\n    def __str__(self):\n        return unicode(self).encode(\"utf-8\")\n\n    def __unicode__(self):\n        return u\"A PHPP Ventilation System Object: <{self.system_name}>\".format(\n            self=self\n        )\n\n    def __repr__(self):\n        return (\n            \"{}( _ghenv=None, _systemType={!r}, _systemName={!r}, \"\n            \"_unit={!r}, _d01={!r},\"\n            \"_d02={!r}, _exhaustObjs={!r})\".format(\n                self.__class__.__name__,\n                self.system_type,\n                self.system_name,\n                self.vent_unit,\n                self.duct_01,\n                self.duct_02,\n                self.exhaust_vent_objs,\n            )\n        )\n\n    def ToString(self):\n        return str(self)\n\n\ndef calc_room_vent_rates_from_HB(_hb_room, _ghenv):\n    \"\"\"Uses the EP Loads and Schedules to calc the HB Room's annual flowrate\"\"\"\n\n    # Guard\n    # ---------------------------------------------------------------------------\n    if _hb_room.floor_area == 0:\n        warning = (\n            \"Something wrong with the floor area - are you sure\\n\"\n            \"there is at least one 'Floor' surface making up the Room?\"\n        )\n        _ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\n        return None\n\n    # Pull the Loads from HB Room\n    # ---------------------------------------------------------------------------\n    vent_flow_per_area = _hb_room.properties.energy.ventilation.flow_per_area\n    vent_flow_per_person = _hb_room.properties.energy.ventilation.flow_per_person\n    vent_flow_per_zone = _hb_room.properties.energy.ventilation.flow_per_zone\n    vent_flow_ach = _hb_room.properties.energy.ventilation.air_changes_per_hour\n    people_per_area = _hb_room.properties.energy.people.people_per_area\n\n    # Pull the Schedules from HB Room\n    # ---------------------------------------------------------------------------\n    week_start_day = \"Sunday\"\n    holidays = None\n    start_date, end_date, timestep = Date(1, 1), Date(12, 31), 1\n\n    hb_sched_occ = _hb_room.properties.energy.people.occupancy_schedule\n    hb_sched_vent = _hb_room.properties.energy.ventilation.schedule\n\n    if hb_sched_occ is not None:\n        if isinstance(hb_sched_occ, ScheduleRuleset):\n            data_occ = hb_sched_occ.data_collection(\n                timestep,\n                start_date,\n                end_date,\n                week_start_day,\n                holidays,\n                leap_year=False,\n            )\n        else:\n            data_occ = (1 for i in range(8760))\n    else:\n        data_occ = (1 for i in range(8760))\n\n    if hb_sched_vent:\n        if isinstance(hb_sched_vent, ScheduleRuleset):\n            data_vent = hb_sched_vent.data_collection(\n                timestep,\n                start_date,\n                end_date,\n                week_start_day,\n                holidays,\n                leap_year=False,\n            )\n    else:\n        data_vent = (1 for i in range(8760))\n\n    # ---------------------------------------------------------------------------\n    # Nominal (peak) flow rates (m3/h) based on the HB/EP Load values\n    # m3/s---> m3/h\n\n    nom_vent_flow_per_area = vent_flow_per_area * _hb_room.floor_area * 60.0 * 60.0\n    nom_vent_flow_per_zone = vent_flow_per_zone * 60.0 * 60.0\n    nom_vent_flow_ach = vent_flow_ach * _hb_room.volume\n    nom_vent_flow_per_person = (\n        people_per_area * _hb_room.floor_area * vent_flow_per_person * 60.0 * 60.0\n    )\n\n    nom_vent_flow_total = (\n        nom_vent_flow_per_area\n        + nom_vent_flow_per_person\n        + nom_vent_flow_per_zone\n        + nom_vent_flow_ach\n    )\n\n    # ---------------------------------------------------------------------------\n    # Preview results\n    print(\n        \"The HB Room: '{}' has an average annual airflow of: {:.2f} \"\n        \"m3/h\".format(_hb_room.display_name, nom_vent_flow_total)\n    )\n    print(\">Looking at the Honeybee Program parameters:\")\n    print(\n        \"   *Note: These are the values BEFORE any occupany / activity schedule\"\n        \"is applied to reduce this (demand control)\"\n    )\n    print(\n        \"   *Note: These are the values takes into account the airflow for 'areas', for people, per zone and by ACH.\"\n    )\n    print(\"   Details:\")\n    print(\n        \"      >Reference HB-Room Floor Area used is: {:.2f} m2\".format(\n            float(_hb_room.floor_area)\n        )\n    )\n    print(\n        \"      >Reference HB-Room Volume used is: {:.2f} m3\".format(\n            float(_hb_room.volume)\n        )\n    )\n    print(\n        \"      >[Ventilation Per Pers: {:.6f} m3/s-prs] x [Floor Area: {:.2f} m2] x [{:.3f} ppl/m2] \"\n        \"x 3600 s/hr = {:.2f} m3/hr\".format(\n            vent_flow_per_person,\n            _hb_room.floor_area,\n            people_per_area,\n            nom_vent_flow_per_person,\n        )\n    )\n    print(\n        \"      >[Ventilation Per Area: {:.6f} m3/s-m2] x [Floor Area: {:.2f} m2] \"\n        \"x 3600 s/hr = {:.2f} m3/hr\".format(\n            float(vent_flow_per_area),\n            float(_hb_room.floor_area),\n            float(nom_vent_flow_per_area),\n        )\n    )\n    print(\n        \"      >[Ventilation per Zone: {:.6f} m3/s] x 3600 s/hr = \"\n        \"{:.2f} m3/h\".format(\n            vent_flow_per_zone,\n            nom_vent_flow_per_zone,\n        )\n    )\n    print(\n        \"      >[Ventilation by ACH: {:.2f} ACH] x [Volume: {:.2f} m3]\"\n        \" = {:.2f} m3/h \".format(vent_flow_ach, _hb_room.volume, nom_vent_flow_ach)\n    )\n    print(\n        \"      >[Vent For Area: {:.2f} m3/h] + [Vent For PPL: {:.2f} m3/h]\"\n        \" + [Vent For Zone: {:.2f} m3/h] + [Vent For ACH: {:.2f} m3/h]\"\n        \" = {:.2f} m3/h\".format(\n            nom_vent_flow_per_area,\n            vent_flow_per_person,\n            nom_vent_flow_per_zone,\n            nom_vent_flow_ach,\n            nom_vent_flow_total,\n        )\n    )\n    print(\"- \" * 100)\n\n    # Annual Average flow rates taking schedules into account\n    # ---------------------------------------------------------------------------\n    total_nom_vent_flow = (\n        nom_vent_flow_per_area + nom_vent_flow_per_zone + nom_vent_flow_ach\n    )\n    annual_vent_flow_space = sum(total_nom_vent_flow * val for val in data_vent) / 8760\n    annual_vent_flow_ppl = (\n        sum(nom_vent_flow_per_person * val for val in data_occ) / 8760\n    )\n    annual_vent_flow_total = annual_vent_flow_space + annual_vent_flow_ppl\n\n    Output = namedtuple(\"Output\", [\"nominal\", \"annual_avg\"])\n    output = Output(nom_vent_flow_total, annual_vent_flow_total)\n\n    return output\n\n\ndef hb_schedule_to_data(_schedule):\n    if isinstance(_schedule, str):\n        _schedule = schedule_by_identifier(_schedule_name)\n\n    week_start_day = \"Sunday\"\n    start_date, end_date, timestep = Date(1, 1), Date(12, 31), 1\n    holidays = None\n\n    data = _schedule.data_collection(\n        timestep, start_date, end_date, week_start_day, holidays, leap_year=False\n    )\n\n    return data\n\n\ndef calc_space_vent_rates(\n    _space, _hb_room, _hb_room_tfa, _hb_room_peak_vent_rate, _ghenv\n):\n    \"\"\"Determine the Vent flowrate (m3/h) for each PHPP Room based on the EP/HB Values\"\"\"\n\n    # ---------------------------------------------------------------------------\n    # Guard\n\n    if _hb_room.floor_area == 0:\n        warning = (\n            \"Something wrong with the floor area - are you sure\\n\"\n            \"there is at least one 'Floor' surface making up the Room?\"\n        )\n        _ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\n        return None\n\n    if _hb_room_tfa == 0:\n        warning = (\n            \"Got TFA of 0 - are you sure\\n\"\n            \"there is at least one 'TFA' surface in the Room?\"\n        )\n        _ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\n        return None\n\n    # ---------------------------------------------------------------------------\n    percent_of_total_zone_TFA = _space.space_tfa / _hb_room_tfa\n    room_air_flow = percent_of_total_zone_TFA * _hb_room_peak_vent_rate\n    room_air_flow = (\n        room_air_flow / 2\n    )  # Div by 2 cus' half goes to supply, half to extract?\n\n    return {\"V_sup\": room_air_flow, \"V_eta\": room_air_flow, \"V_trans\": room_air_flow}\n\n\ndef generate_histogram(_data, _nbins):\n    # Creates a dictionary Histogram of some data in n-bins\n\n    min_val = min(_data)\n    max_val = max(_data)\n    hist_bins = {}  # The number of items in each bin\n    hist_vals = {}  # The avg value for each bin\n    total = 0\n\n    # Initialize the dict\n    for k in range(_nbins + 1):\n        hist_bins[k] = 0\n        hist_vals[k] = 0\n\n    # Create the Histogram\n    val_range = (max_val - min_val) or 1.0\n    for d in _data:\n        bin_number = int(_nbins * ((d - min_val) / val_range))\n\n        hist_bins[bin_number] += 1\n        hist_vals[bin_number] += d\n        total += 1\n\n    # Clean up / fix the data for output\n    for n in hist_vals.keys():\n        hist_vals[n] = hist_vals[n] / (hist_bins[n] or 1)\n\n    for h in hist_bins.keys():\n        hist_bins[h] = float(hist_bins[h]) / total\n\n    # The number of items in each bin, the avg value of the items in the bin\n    return hist_bins, hist_vals\n\n\ndef calc_space_vent_schedule(_space, _hb_room, _hb_room_tfa):\n    if _hb_room_tfa == 0:\n        return None\n\n    # Try and get the Schedule data\n    hb_schedule_obj = hb_schedule_to_data(\n        _hb_room.properties.energy.people.occupancy_schedule\n    )\n\n    # Create a PHPP-Style 3-part sched from the EP data\n    bins, vals = generate_histogram(hb_schedule_obj.values, 2)\n    room_sched_from_hb = PHPP_Sys_VentSchedule(\n        vals[2], bins[2], vals[1], bins[1], vals[0], bins[0]\n    )\n\n    # Compute the Room % of Total TFA and Room's Ventilation Airflows\n    percentZoneTotalTFA = _space.space_tfa / _hb_room_tfa\n    numOfPeoplePerArea = _hb_room.properties.energy.people.people_per_area\n    vent_flow_per_person = _hb_room.properties.energy.ventilation.flow_per_person\n    vent_flow_per_area = _hb_room.properties.energy.ventilation.flow_per_area\n    roomFlowrate_People_Peak = (\n        numOfPeoplePerArea\n        * _hb_room.floor_area\n        * vent_flow_per_person\n        * 60\n        * 60\n        * percentZoneTotalTFA\n    )\n\n    # Calc total airflow for People\n    # Calc the flow rates for people based on the HB Schedule values\n    roomFlowrate_People_High = room_sched_from_hb.speed_high * roomFlowrate_People_Peak\n    roomFlowrate_People_Med = room_sched_from_hb.speed_med * roomFlowrate_People_Peak\n    roomFlowrate_People_Low = room_sched_from_hb.speed_low * roomFlowrate_People_Peak\n\n    roomVentilationPerArea = (\n        vent_flow_per_area * _hb_room.floor_area * 60 * 60 * percentZoneTotalTFA\n    )\n\n    if roomVentilationPerArea != 0 and roomFlowrate_People_Peak != 0:\n        roomFlowrate_Total_High = (\n            roomFlowrate_People_High + roomVentilationPerArea\n        ) / (roomFlowrate_People_Peak + roomVentilationPerArea)\n        roomFlowrate_Total_Med = (roomFlowrate_People_Med + roomVentilationPerArea) / (\n            roomFlowrate_People_Peak + roomVentilationPerArea\n        )\n        roomFlowrate_Total_Low = (roomFlowrate_People_Low + roomVentilationPerArea) / (\n            roomFlowrate_People_Peak + roomVentilationPerArea\n        )\n\n        # Re-set the Room's Vent Schedule Fan-Speeds based on the calculated rates\n        # taking into account both Floor Area and People\n        phppRoomVentSched = PHPP_Sys_VentSchedule(\n            roomFlowrate_Total_High,\n            bins[2],\n            roomFlowrate_Total_Med,\n            bins[1],\n            roomFlowrate_Total_Low,\n            bins[0],\n        )\n    else:\n        phppRoomVentSched = PHPP_Sys_VentSchedule()\n\n    return phppRoomVentSched\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}