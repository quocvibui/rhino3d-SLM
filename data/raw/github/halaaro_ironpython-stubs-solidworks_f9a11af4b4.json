{
  "source_url": "https://github.com/halaaro/ironpython-stubs-solidworks/blob/049d6e8ad0392db80ace54d15be4c3ff840292d2/release/stubs.min/Rhino/Geometry/__init___parts/Surface.py",
  "repo": "halaaro/ironpython-stubs-solidworks",
  "repo_stars": 2,
  "repo_description": null,
  "license": "NOASSERTION",
  "filepath": "release/stubs.min/Rhino/Geometry/__init___parts/Surface.py",
  "instruction": "Surface",
  "code": "class Surface(GeometryBase,IDisposable,ISerializable):\r\n \"\"\"\r\n Represents a base class that is common to most RhinoCommon surface types.\r\n\r\n    A surface represents an entity that can be all visited by providing\r\n\r\n    two independent parameters,usually called (u,v),or sometimes (s,t).\r\n \"\"\"\r\n def ClosestPoint(self,testPoint,u,v):\r\n  \"\"\"\r\n  ClosestPoint(self: Surface,testPoint: Point3d) -> (bool,float,float)\r\n\r\n  \r\n\r\n   Input the parameters of the point on the surface that is closest to testPoint.\r\n\r\n  \r\n\r\n   testPoint: A point to test against.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def ClosestSide(self,u,v):\r\n  \"\"\"\r\n  ClosestSide(self: Surface,u: float,v: float) -> IsoStatus\r\n\r\n  \r\n\r\n   Gets the side that is closest,in terms of 3D-distance,to a U and V parameter.\r\n\r\n  \r\n\r\n   u: A u parameter.\r\n\r\n   v: A v parameter.\r\n\r\n   Returns: A side.\r\n  \"\"\"\r\n  pass\r\n def ConstructConstObject(self,*args):\r\n  \"\"\"\r\n  ConstructConstObject(self: CommonObject,parentObject: object,subobject_index: int)\r\n\r\n   Assigns a parent object and a subobject index to this.\r\n\r\n  \r\n\r\n   parentObject: The parent object.\r\n\r\n   subobject_index: The subobject index.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateExtrusion(profile,direction):\r\n  \"\"\"\r\n  CreateExtrusion(profile: Curve,direction: Vector3d) -> Surface\r\n\r\n  \r\n\r\n   Constructs a surface by extruding a curve along a vector.\r\n\r\n  \r\n\r\n   profile: Profile curve to extrude.\r\n\r\n   direction: Direction and length of extrusion.\r\n\r\n   Returns: A surface on success or null on failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateExtrusionToPoint(profile,apexPoint):\r\n  \"\"\"\r\n  CreateExtrusionToPoint(profile: Curve,apexPoint: Point3d) -> Surface\r\n\r\n  \r\n\r\n   Constructs a surface by extruding a curve to a point.\r\n\r\n  \r\n\r\n   profile: Profile curve to extrude.\r\n\r\n   apexPoint: Apex point of extrusion.\r\n\r\n   Returns: A Surface on success or null on failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreatePeriodicSurface(baseSurface,direction):\r\n  \"\"\"\r\n  CreatePeriodicSurface(baseSurface: Surface,direction: int) -> Surface\r\n\r\n  \r\n\r\n   Constructs a periodic surface from a base surface and a direction.\r\n\r\n  \r\n\r\n   baseSurface: A base surface.\r\n\r\n   direction: 0 is first parameter,1 is second parameter.\r\n\r\n   Returns: A new surface; or null on error.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateRollingBallFillet(surfaceA,*__args):\r\n  \"\"\"\r\n  CreateRollingBallFillet(surfaceA: Surface,uvA: Point2d,surfaceB: Surface,uvB: Point2d,radius: float,tolerance: float) -> Array[Surface]\r\n\r\n  \r\n\r\n   Constructs a rolling ball fillet between two surfaces.\r\n\r\n  \r\n\r\n   surfaceA: A first surface.\r\n\r\n   uvA: A point in the parameter space of FaceA near where the fillet is expected to hit the surface.\r\n\r\n   surfaceB: A second surface.\r\n\r\n   uvB: A point in the parameter space of FaceB near where the fillet is expected to hit the surface.\r\n\r\n   radius: A radius value.\r\n\r\n   tolerance: A tolerance value used for approximating and intersecting offset surfaces.\r\n\r\n   Returns: A new array of rolling ball fillet surfaces; this array can be empty on failure.\r\n\r\n  CreateRollingBallFillet(surfaceA: Surface,flipA: bool,surfaceB: Surface,flipB: bool,radius: float,tolerance: float) -> Array[Surface]\r\n\r\n  \r\n\r\n   Constructs a rolling ball fillet between two surfaces.\r\n\r\n  \r\n\r\n   surfaceA: A first surface.\r\n\r\n   flipA: A value that indicates whether A should be used in flipped mode.\r\n\r\n   surfaceB: A second surface.\r\n\r\n   flipB: A value that indicates whether B should be used in flipped mode.\r\n\r\n   radius: A radius value.\r\n\r\n   tolerance: A tolerance value.\r\n\r\n   Returns: A new array of rolling ball fillet surfaces; this array can be empty on failure.\r\n\r\n  CreateRollingBallFillet(surfaceA: Surface,surfaceB: Surface,radius: float,tolerance: float) -> Array[Surface]\r\n\r\n  \r\n\r\n   Constructs a rolling ball fillet between two surfaces.\r\n\r\n  \r\n\r\n   surfaceA: A first surface.\r\n\r\n   surfaceB: A second surface.\r\n\r\n   radius: A radius value.\r\n\r\n   tolerance: A tolerance value.\r\n\r\n   Returns: A new array of rolling ball fillet surfaces; this array can be empty on failure.\r\n  \"\"\"\r\n  pass\r\n def CurvatureAt(self,u,v):\r\n  \"\"\"\r\n  CurvatureAt(self: Surface,u: float,v: float) -> SurfaceCurvature\r\n\r\n  \r\n\r\n   Computes the curvature at the given UV coordinate.\r\n\r\n  \r\n\r\n   u: U parameter for evaluation.\r\n\r\n   v: V parameter for evaluation.\r\n\r\n   Returns: Surface Curvature data for the point at uv or null on failure.\r\n  \"\"\"\r\n  pass\r\n def Degree(self,direction):\r\n  \"\"\"\r\n  Degree(self: Surface,direction: int) -> int\r\n\r\n  \r\n\r\n   Returns the maximum algebraic degree of any span\r\n\r\n     (or a good estimate if curve spans \r\n\r\n    are not algebraic).\r\n\r\n  \r\n\r\n  \r\n\r\n   direction: 0 gets first parameter's domain,1 gets second parameter's domain.\r\n\r\n   Returns: The maximum degree.\r\n  \"\"\"\r\n  pass\r\n def Dispose(self):\r\n  \"\"\"\r\n  Dispose(self: CommonObject,disposing: bool)\r\n\r\n   For derived class implementers.\r\n\r\n     This method is called with argument true when class \r\n\r\n    user calls Dispose(),while with argument false when\r\n\r\n     the Garbage Collector invokes \r\n\r\n    the finalizer,or Finalize() method.You must reclaim all used unmanaged resources in both cases,\r\n\r\n    and can use this chance to call Dispose on disposable fields if the argument is true.Also,you \r\n\r\n    must call the base virtual method within your overriding method.\r\n\r\n  \r\n\r\n  \r\n\r\n   disposing: true if the call comes from the Dispose() method; false if it comes from the Garbage Collector \r\n\r\n    finalizer.\r\n  \"\"\"\r\n  pass\r\n def Domain(self,direction):\r\n  \"\"\"\r\n  Domain(self: Surface,direction: int) -> Interval\r\n\r\n  \r\n\r\n   Gets the domain in a direction.\r\n\r\n  \r\n\r\n   direction: 0 gets first parameter,1 gets second parameter.\r\n\r\n   Returns: An interval value.\r\n  \"\"\"\r\n  pass\r\n def Evaluate(self,u,v,numberDerivatives,point,derivatives):\r\n  \"\"\"\r\n  Evaluate(self: Surface,u: float,v: float,numberDerivatives: int) -> (bool,Point3d,Array[Vector3d])\r\n\r\n  \r\n\r\n   Evaluates a surface mathematically.\r\n\r\n  \r\n\r\n   u: A U parameter.\r\n\r\n   v: A V parameter.\r\n\r\n   numberDerivatives: The number of derivatives.\r\n\r\n   Returns: true if the operation succeeded; false otherwise.\r\n  \"\"\"\r\n  pass\r\n def Extend(self,edge,extensionLength,smooth):\r\n  \"\"\"\r\n  Extend(self: Surface,edge: IsoStatus,extensionLength: float,smooth: bool) -> Surface\r\n\r\n  \r\n\r\n   Extends an untrimmed surface along one edge.\r\n\r\n  \r\n\r\n   edge: Edge to extend.  Must be North,South,East,or West.\r\n\r\n   extensionLength: distance to extend.\r\n\r\n   smooth: true for smooth (C-infinity) extension. \r\n\r\n     false for a C1- ruled extension.\r\n\r\n   Returns: New extended surface on success.\r\n  \"\"\"\r\n  pass\r\n def Fit(self,uDegree,vDegree,fitTolerance):\r\n  \"\"\"\r\n  Fit(self: Surface,uDegree: int,vDegree: int,fitTolerance: float) -> Surface\r\n\r\n  \r\n\r\n   Fits a new surface through an existing surface.\r\n\r\n  \r\n\r\n   uDegree: the output surface U degree. Must be bigger than 1.\r\n\r\n   vDegree: the output surface V degree. Must be bigger than 1.\r\n\r\n   fitTolerance: The fitting tolerance.\r\n\r\n   Returns: A surface,or null on error.\r\n  \"\"\"\r\n  pass\r\n def FrameAt(self,u,v,frame):\r\n  \"\"\"\r\n  FrameAt(self: Surface,u: float,v: float) -> (bool,Plane)\r\n\r\n  \r\n\r\n   Computes the orient plane on a surface given a U and V parameter.\r\n\r\n     This is the \r\n\r\n    simple evaluation call with no error handling.\r\n\r\n  \r\n\r\n  \r\n\r\n   u: A first parameter.\r\n\r\n   v: A second parameter.\r\n\r\n   Returns: true if this operation succeeded; otherwise false.\r\n  \"\"\"\r\n  pass\r\n def GetNextDiscontinuity(self,direction,continuityType,t0,t1,t):\r\n  \"\"\"\r\n  GetNextDiscontinuity(self: Surface,direction: int,continuityType: Continuity,t0: float,t1: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Searches for a derivative,tangent,or curvature discontinuity.\r\n\r\n  \r\n\r\n   direction: If 0,then \"u\" parameter is checked. If 1,then the \"v\" parameter is checked.\r\n\r\n   continuityType: The desired continuity.\r\n\r\n   t0: Search begins at t0. If there is a discontinuity at t0,it will be ignored. \r\n\r\n     This \r\n\r\n    makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.\r\n\r\n  \r\n\r\n   t1: (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is a locus \r\n\r\n    discontinuity\r\n\r\n     type and t1 is at the start or end of the curve.\r\n\r\n  \r\n\r\n   Returns: Parametric continuity tests c=(C0_continuous,...,G2_continuous):\r\n\r\n     TRUE if a \r\n\r\n    parametric discontinuity was found strictly between t0 and t1.\r\n\r\n     Note well that all \r\n\r\n    curves are parametrically continuous at the ends of their domains.\r\n\r\n     \r\n\r\n     \r\n\r\n    Locus continuity tests c=(C0_locus_continuous,...,G2_locus_continuous):\r\n\r\n     TRUE if \r\n\r\n    a locus discontinuity was found strictly between t0 and t1 or at t1 is the\r\n\r\n     at the \r\n\r\n    end of a curve. Note well that all open curves (IsClosed()=false) are locus\r\n\r\n     \r\n\r\n    discontinuous at the ends of their domains.  All closed curves (IsClosed()=true) are\r\n\r\n       \r\n\r\n     at least C0_locus_continuous at the ends of their domains.\r\n  \"\"\"\r\n  pass\r\n def GetSpanVector(self,direction):\r\n  \"\"\"\r\n  GetSpanVector(self: Surface,direction: int) -> Array[float]\r\n\r\n  \r\n\r\n   Gets array of span \"knots\".\r\n\r\n  \r\n\r\n   direction: 0 gets first parameter's domain,1 gets second parameter's domain.\r\n\r\n   Returns: An array with span vectors; or null on error.\r\n  \"\"\"\r\n  pass\r\n def GetSurfaceSize(self,width,height):\r\n  \"\"\"\r\n  GetSurfaceSize(self: Surface) -> (bool,float,float)\r\n\r\n  \r\n\r\n   Gets an estimate of the size of the rectangle that would be created\r\n\r\n     if the 3d \r\n\r\n    surface where flattened into a rectangle.\r\n\r\n  \r\n\r\n   Returns: true if successful.\r\n  \"\"\"\r\n  pass\r\n def HasNurbsForm(self):\r\n  \"\"\"\r\n  HasNurbsForm(self: Surface) -> int\r\n\r\n  \r\n\r\n   Is there a NURBS surface representation of this surface.\r\n\r\n   Returns: 0 unable to create NURBS representation with desired accuracy.\r\n\r\n     1 success - NURBS \r\n\r\n    parameterization matches the surface's\r\n\r\n     2 success - NURBS point locus matches the \r\n\r\n    surface's and the\r\n\r\n     domain of the NURBS surface is correct. However,This surface's\r\n\r\n   \r\n\r\n      parameterization and the NURBS surface parameterization may not\r\n\r\n     match.  \r\n\r\n    This situation happens when getting NURBS representations\r\n\r\n     of surfaces that have a \r\n\r\n    transendental parameterization like spheres,\r\n\r\n     cylinders,and cones.\r\n  \"\"\"\r\n  pass\r\n def InterpolatedCurveOnSurface(self,points,tolerance):\r\n  \"\"\" InterpolatedCurveOnSurface(self: Surface,points: IEnumerable[Point3d],tolerance: float) -> NurbsCurve \"\"\"\r\n  pass\r\n def InterpolatedCurveOnSurfaceUV(self,points,tolerance):\r\n  \"\"\" InterpolatedCurveOnSurfaceUV(self: Surface,points: IEnumerable[Point2d],tolerance: float) -> NurbsCurve \"\"\"\r\n  pass\r\n def IsAtSeam(self,u,v):\r\n  \"\"\"\r\n  IsAtSeam(self: Surface,u: float,v: float) -> int\r\n\r\n  \r\n\r\n   Tests if a surface parameter value is at a seam.\r\n\r\n  \r\n\r\n   u: Surface u parameter to test.\r\n\r\n   v: Surface v parameter to test.\r\n\r\n   Returns: 0 if not a seam,\r\n\r\n     1 if u == Domain(0)[i] and srf(u,v) == srf(Domain(0)[1-i],v)\r\n\r\n     \r\n\r\n       2 if v == Domain(1)[i] and srf(u,v) == srf(u,Domain(1)[1-i])\r\n\r\n     3 if 1 and \r\n\r\n    2 are true.\r\n  \"\"\"\r\n  pass\r\n def IsAtSingularity(self,u,v,exact):\r\n  \"\"\"\r\n  IsAtSingularity(self: Surface,u: float,v: float,exact: bool) -> bool\r\n\r\n  \r\n\r\n   Tests if a surface parameter value is at a singularity.\r\n\r\n  \r\n\r\n   u: Surface u parameter to test.\r\n\r\n   v: Surface v parameter to test.\r\n\r\n   exact: If true,test if (u,v) is exactly at a singularity.\r\n\r\n     If false,test if close enough \r\n\r\n    to cause numerical problems.\r\n\r\n  \r\n\r\n   Returns: true if surface is singular at (s,t)\r\n  \"\"\"\r\n  pass\r\n def IsClosed(self,direction):\r\n  \"\"\"\r\n  IsClosed(self: Surface,direction: int) -> bool\r\n\r\n  \r\n\r\n   Gets a value indicating if the surface is closed in a direction.\r\n\r\n  \r\n\r\n   direction: 0=U,1=V.\r\n\r\n   Returns: The indicating boolean value.\r\n  \"\"\"\r\n  pass\r\n def IsCone(self,tolerance=None):\r\n  \"\"\"\r\n  IsCone(self: Surface,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Determines if the surface is a portion of a cone within a given tolerance.\r\n\r\n  \r\n\r\n   tolerance: tolerance to use when checking.\r\n\r\n   Returns: true if the surface is a portion of a cone.\r\n\r\n  IsCone(self: Surface) -> bool\r\n\r\n  \r\n\r\n   Determines if the surface is a portion of a cone within RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the surface is a portion of a cone.\r\n  \"\"\"\r\n  pass\r\n def IsContinuous(self,continuityType,u,v):\r\n  \"\"\"\r\n  IsContinuous(self: Surface,continuityType: Continuity,u: float,v: float) -> bool\r\n\r\n  \r\n\r\n   Tests continuity at a surface parameter value.\r\n\r\n  \r\n\r\n   continuityType: The continuity type to sample.\r\n\r\n   u: Surface u parameter to test.\r\n\r\n   v: Surface v parameter to test.\r\n\r\n   Returns: true if the surface has at least the specified continuity at the (u,v) parameter.\r\n  \"\"\"\r\n  pass\r\n def IsCylinder(self,tolerance=None):\r\n  \"\"\"\r\n  IsCylinder(self: Surface,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Determines if the surface is a portion of a cylinder within a given tolerance.\r\n\r\n  \r\n\r\n   tolerance: tolerance to use when checking.\r\n\r\n   Returns: true if the surface is a portion of a cylinder.\r\n\r\n  IsCylinder(self: Surface) -> bool\r\n\r\n  \r\n\r\n   Determines if the surface is a portion of a cylinder within RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the surface is a portion of a cylinder.\r\n  \"\"\"\r\n  pass\r\n def IsIsoparametric(self,*__args):\r\n  \"\"\"\r\n  IsIsoparametric(self: Surface,bbox: BoundingBox) -> IsoStatus\r\n\r\n  \r\n\r\n   Determines if a 2d bounding box is iso-parameteric in the parameter space of this surface.\r\n\r\n  \r\n\r\n   bbox: Bounding box to test.\r\n\r\n   Returns: IsoStatus flag describing the iso-parametric relationship between the surface and the bounding \r\n\r\n    box.\r\n\r\n  \r\n\r\n  IsIsoparametric(self: Surface,curve: Curve) -> IsoStatus\r\n\r\n  \r\n\r\n   Determines if a 2d curve is iso-parameteric in the parameter space of this surface.\r\n\r\n  \r\n\r\n   curve: Curve to test.\r\n\r\n   Returns: IsoStatus flag describing the iso-parametric relationship between the surface and the curve.\r\n\r\n  IsIsoparametric(self: Surface,curve: Curve,curveDomain: Interval) -> IsoStatus\r\n\r\n  \r\n\r\n   Determines if a 2D curve is iso-parameteric in the parameter space of this surface.\r\n\r\n  \r\n\r\n   curve: Curve to test.\r\n\r\n   curveDomain: Sub domain of the curve.\r\n\r\n   Returns: IsoStatus flag describing the iso-parametric relationship between the surface and the curve.\r\n  \"\"\"\r\n  pass\r\n def IsoCurve(self,direction,constantParameter):\r\n  \"\"\"\r\n  IsoCurve(self: Surface,direction: int,constantParameter: float) -> Curve\r\n\r\n  \r\n\r\n   Gets isoparametric curve.\r\n\r\n  \r\n\r\n   direction: 0 first parameter varies and second parameter is constant\r\n\r\n     e.g.,point on \r\n\r\n    IsoCurve(0,c) at t is srf(t,c)\r\n\r\n     This is a horizontal line from left to right\r\n\r\n      \r\n\r\n      \r\n\r\n     1 first parameter is constant and second parameter varies\r\n\r\n     e.g.,\r\n\r\n    point on IsoCurve(1,c) at t is srf(c,t\r\n\r\n     This is a vertical line from bottom to top.\r\n\r\n  \r\n\r\n   constantParameter: The parameter that was constant on the original surface.\r\n\r\n   Returns: An isoparametric curve or null on error.\r\n  \"\"\"\r\n  pass\r\n def IsPeriodic(self,direction):\r\n  \"\"\"\r\n  IsPeriodic(self: Surface,direction: int) -> bool\r\n\r\n  \r\n\r\n   Gets a value indicating if thr surface is periodic in a direction (default is false).\r\n\r\n  \r\n\r\n   direction: 0=U,1=V.\r\n\r\n   Returns: The indicating boolean value.\r\n  \"\"\"\r\n  pass\r\n def IsPlanar(self,tolerance=None):\r\n  \"\"\"\r\n  IsPlanar(self: Surface,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Tests a surface to see if it is planar to a given tolerance.\r\n\r\n  \r\n\r\n   tolerance: tolerance to use when checking.\r\n\r\n   Returns: true if there is a plane such that the maximum distance from\r\n\r\n     the surface to the \r\n\r\n    plane is <= tolerance.\r\n\r\n  \r\n\r\n  IsPlanar(self: Surface) -> bool\r\n\r\n  \r\n\r\n   Tests a surface to see if it is planar to zero tolerance.\r\n\r\n   Returns: true if the surface is planar (flat) to within RhinoMath.ZeroTolerance units (1e-12).\r\n  \"\"\"\r\n  pass\r\n def IsSingular(self,side):\r\n  \"\"\"\r\n  IsSingular(self: Surface,side: int) -> bool\r\n\r\n  \r\n\r\n   true if surface side is collapsed to a point.\r\n\r\n  \r\n\r\n   side: side of parameter space to test\r\n\r\n     0=south,1=east,2=north,3=west.\r\n\r\n   Returns: True if this specific side of the surface is singular; otherwise,false.\r\n  \"\"\"\r\n  pass\r\n def IsSphere(self,tolerance=None):\r\n  \"\"\"\r\n  IsSphere(self: Surface,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Determines if the surface is a portion of a sphere within a given tolerance.\r\n\r\n  \r\n\r\n   tolerance: tolerance to use when checking.\r\n\r\n   Returns: true if the surface is a portion of a sphere.\r\n\r\n  IsSphere(self: Surface) -> bool\r\n\r\n  \r\n\r\n   Determines if the surface is a portion of a sphere within RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the surface is a portion of a sphere.\r\n  \"\"\"\r\n  pass\r\n def IsTorus(self,tolerance=None):\r\n  \"\"\"\r\n  IsTorus(self: Surface,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Determines if the surface is a portion of a torus within a given tolerance.\r\n\r\n  \r\n\r\n   tolerance: tolerance to use when checking.\r\n\r\n   Returns: true if the surface is a portion of a torus.\r\n\r\n  IsTorus(self: Surface) -> bool\r\n\r\n  \r\n\r\n   Determines if the surface is a portion of a torus within RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the surface is a portion of a torus.\r\n  \"\"\"\r\n  pass\r\n def NonConstOperation(self,*args):\r\n  \"\"\"\r\n  NonConstOperation(self: CommonObject)\r\n\r\n   For derived classes implementers.\r\n\r\n     Defines the necessary implementation to free the \r\n\r\n    instance from being const.\r\n  \"\"\"\r\n  pass\r\n def NormalAt(self,u,v):\r\n  \"\"\"\r\n  NormalAt(self: Surface,u: float,v: float) -> Vector3d\r\n\r\n  \r\n\r\n   Computes the surface normal at a point.\r\n\r\n     This is the simple evaluation call - it \r\n\r\n    does not support error handling.\r\n\r\n  \r\n\r\n  \r\n\r\n   u: A U parameter.\r\n\r\n   v: A V parameter.\r\n\r\n   Returns: The normal.\r\n  \"\"\"\r\n  pass\r\n def Offset(self,distance,tolerance):\r\n  \"\"\"\r\n  Offset(self: Surface,distance: float,tolerance: float) -> Surface\r\n\r\n  \r\n\r\n   Constructs a new surface which is offset from the current surface.\r\n\r\n  \r\n\r\n   distance: Distance (along surface normal) to offset.\r\n\r\n   tolerance: Offset accuracy.\r\n\r\n   Returns: The offsetted surface or null on failure.\r\n  \"\"\"\r\n  pass\r\n def OnSwitchToNonConst(self,*args):\r\n  \"\"\"\r\n  OnSwitchToNonConst(self: GeometryBase)\r\n\r\n   Is called when a non-const operation occurs.\r\n  \"\"\"\r\n  pass\r\n def PointAt(self,u,v):\r\n  \"\"\"\r\n  PointAt(self: Surface,u: float,v: float) -> Point3d\r\n\r\n  \r\n\r\n   Evaluates a point at a given parameter.\r\n\r\n  \r\n\r\n   u: evaluation parameters.\r\n\r\n   v: evaluation parameters.\r\n\r\n   Returns: Point3d.Unset on failure.\r\n  \"\"\"\r\n  pass\r\n def Pullback(self,curve3d,tolerance,curve3dSubdomain=None):\r\n  \"\"\"\r\n  Pullback(self: Surface,curve3d: Curve,tolerance: float,curve3dSubdomain: Interval) -> Curve\r\n\r\n  \r\n\r\n   Pulls a 3d curve back to the surface's parameter space.\r\n\r\n  \r\n\r\n   curve3d: A curve.\r\n\r\n   tolerance: the maximum acceptable 3d distance between from surface(curve_2d(t))\r\n\r\n     to the locus \r\n\r\n    of points on the surface that are closest to curve_3d.\r\n\r\n  \r\n\r\n   curve3dSubdomain: A subdomain of the curve to sample.\r\n\r\n   Returns: 2d curve.\r\n\r\n  Pullback(self: Surface,curve3d: Curve,tolerance: float) -> Curve\r\n\r\n  \r\n\r\n   Pulls a 3d curve back to the surface's parameter space.\r\n\r\n  \r\n\r\n   curve3d: The curve to pull.\r\n\r\n   tolerance: the maximum acceptable 3d distance between from surface(curve_2d(t))\r\n\r\n     to the locus \r\n\r\n    of points on the surface that are closest to curve_3d.\r\n\r\n  \r\n\r\n   Returns: 2d curve.\r\n  \"\"\"\r\n  pass\r\n def Pushup(self,curve2d,tolerance,curve2dSubdomain=None):\r\n  \"\"\"\r\n  Pushup(self: Surface,curve2d: Curve,tolerance: float) -> Curve\r\n\r\n  \r\n\r\n   Computes a 3d curve that is the composite of a 2d curve and the surface map.\r\n\r\n  \r\n\r\n   curve2d: a 2d curve whose image is in the surface's domain.\r\n\r\n   tolerance: the maximum acceptable distance from the returned 3d curve to the image of curve_2d on the \r\n\r\n    surface.\r\n\r\n  \r\n\r\n   Returns: 3d curve.\r\n\r\n  Pushup(self: Surface,curve2d: Curve,tolerance: float,curve2dSubdomain: Interval) -> Curve\r\n\r\n  \r\n\r\n   Computes a 3d curve that is the composite of a 2d curve and the surface map.\r\n\r\n  \r\n\r\n   curve2d: a 2d curve whose image is in the surface's domain.\r\n\r\n   tolerance: the maximum acceptable distance from the returned 3d curve to the image of curve_2d on the \r\n\r\n    surface.\r\n\r\n  \r\n\r\n   curve2dSubdomain: The curve interval (a sub-domain of the original curve) to use.\r\n\r\n   Returns: 3d curve.\r\n  \"\"\"\r\n  pass\r\n def Rebuild(self,uDegree,vDegree,uPointCount,vPointCount):\r\n  \"\"\"\r\n  Rebuild(self: Surface,uDegree: int,vDegree: int,uPointCount: int,vPointCount: int) -> NurbsSurface\r\n\r\n  \r\n\r\n   Rebuilds an existing surface to a given degree and point count.\r\n\r\n  \r\n\r\n   uDegree: the output surface u degree.\r\n\r\n   vDegree: the output surface u degree.\r\n\r\n   uPointCount: The number of points in the output surface u direction. Must be bigger\r\n\r\n     than uDegree \r\n\r\n    (maximum value is 1000)\r\n\r\n  \r\n\r\n   vPointCount: The number of points in the output surface v direction. Must be bigger\r\n\r\n     than vDegree \r\n\r\n    (maximum value is 1000)\r\n\r\n  \r\n\r\n   Returns: new rebuilt surface on success. null on failure.\r\n  \"\"\"\r\n  pass\r\n def Reverse(self,direction,inPlace=None):\r\n  \"\"\"\r\n  Reverse(self: Surface,direction: int,inPlace: bool) -> Surface\r\n\r\n  \r\n\r\n   Same as Reverse,but if inPlace is set to true this Surface is modified\r\n\r\n     instead of \r\n\r\n    a new copy being created.\r\n\r\n  \r\n\r\n  \r\n\r\n   direction: 0 for first parameter's domain,1 for second parameter's domain.\r\n\r\n   Returns: If inPlace is False,a new reversed surface on success. If inPlace is\r\n\r\n     true,this \r\n\r\n    surface instance is returned on success.\r\n\r\n  \r\n\r\n  Reverse(self: Surface,direction: int) -> Surface\r\n\r\n  \r\n\r\n   Reverses parameterization Domain changes from [a,b] to [-b,-a]\r\n\r\n  \r\n\r\n   direction: 0 for first parameter's domain,1 for second parameter's domain.\r\n\r\n   Returns: a new reversed surface on success.\r\n  \"\"\"\r\n  pass\r\n def SetDomain(self,direction,domain):\r\n  \"\"\"\r\n  SetDomain(self: Surface,direction: int,domain: Interval) -> bool\r\n\r\n  \r\n\r\n   Sets the domain in a direction.\r\n\r\n  \r\n\r\n   direction: 0 sets first parameter's domain,1 sets second parameter's domain.\r\n\r\n   domain: A new domain to be assigned.\r\n\r\n   Returns: true if setting succeeded,otherwise false.\r\n  \"\"\"\r\n  pass\r\n def ShortPath(self,start,end,tolerance):\r\n  \"\"\"\r\n  ShortPath(self: Surface,start: Point2d,end: Point2d,tolerance: float) -> Curve\r\n\r\n  \r\n\r\n   Constructs a geodesic between 2 points,used by ShortPath command in Rhino.\r\n\r\n  \r\n\r\n   start: start point of curve in parameter space. Points must be distinct in the domain of thie surface.\r\n\r\n   end: end point of curve in parameter space. Points must be distinct in the domain of thie surface.\r\n\r\n   tolerance: tolerance used in fitting discrete solution.\r\n\r\n   Returns: a geodesic curve on the surface on success. null on failure.\r\n  \"\"\"\r\n  pass\r\n def SpanCount(self,direction):\r\n  \"\"\"\r\n  SpanCount(self: Surface,direction: int) -> int\r\n\r\n  \r\n\r\n   Gets number of smooth nonempty spans in the parameter direction.\r\n\r\n  \r\n\r\n   direction: 0 gets first parameter's domain,1 gets second parameter's domain.\r\n\r\n   Returns: The span count.\r\n  \"\"\"\r\n  pass\r\n def Split(self,direction,parameter):\r\n  \"\"\"\r\n  Split(self: Surface,direction: int,parameter: float) -> Array[Surface]\r\n\r\n  \r\n\r\n   Splits (divides) the surface into two parts at the specified parameter\r\n\r\n  \r\n\r\n   direction: 0=The surface is split vertically. The \"west\" side is returned as the first\r\n\r\n     \r\n\r\n    surface in the array and the \"east\" side is returned as the second surface in\r\n\r\n     the \r\n\r\n    array.\r\n\r\n     1=The surface is split horizontally. The \"south\" side is returned as the \r\n\r\n    first surface in the array and the \"north\"\r\n\r\n     side is returned as the second surfae in \r\n\r\n    the array\r\n\r\n  \r\n\r\n   parameter: value of constant parameter in interval returned by Domain(direction)\r\n\r\n   Returns: Array of two surfaces on success\r\n  \"\"\"\r\n  pass\r\n def ToBrep(self):\r\n  \"\"\"\r\n  ToBrep(self: Surface) -> Brep\r\n\r\n  \r\n\r\n   Converts the surface into a Brep.\r\n\r\n   Returns: A Brep with a similar shape like this surface or null.\r\n  \"\"\"\r\n  pass\r\n def ToNurbsSurface(self,tolerance=None,accuracy=None):\r\n  \"\"\"\r\n  ToNurbsSurface(self: Surface,tolerance: float) -> (NurbsSurface,int)\r\n\r\n  \r\n\r\n   Gets a NURBS surface representation of this surface.\r\n\r\n  \r\n\r\n   tolerance: tolerance to use when creating NURBS representation.\r\n\r\n   Returns: NurbsSurface on success,null on failure.\r\n\r\n  ToNurbsSurface(self: Surface) -> NurbsSurface\r\n\r\n  \r\n\r\n   Gets a NURBS surface representation of this surface. Default \r\n\r\n     tolerance of 0.0 is \r\n\r\n    used.\r\n\r\n  \r\n\r\n   Returns: NurbsSurface on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def Transpose(self,inPlace=None):\r\n  \"\"\"\r\n  Transpose(self: Surface,inPlace: bool) -> Surface\r\n\r\n  \r\n\r\n   Transposes surface parameterization (swap U and V)\r\n\r\n   Returns: New transposed surface on success,null on failure.\r\n\r\n  Transpose(self: Surface) -> Surface\r\n\r\n  \r\n\r\n   Transposes surface parameterization (swap U and V)\r\n\r\n   Returns: New transposed surface on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def Trim(self,u,v):\r\n  \"\"\"\r\n  Trim(self: Surface,u: Interval,v: Interval) -> Surface\r\n\r\n  \r\n\r\n   Constructs a sub-surface that covers the specified UV trimming domain.\r\n\r\n  \r\n\r\n   u: Domain of surface along U direction to include in the subsurface.\r\n\r\n   v: Domain of surface along V direction to include in the subsurface.\r\n\r\n   Returns: SubSurface on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def TryGetCone(self,cone,tolerance=None):\r\n  \"\"\"\r\n  TryGetCone(self: Surface,tolerance: float) -> (bool,Cone)\r\n\r\n  \r\n\r\n   Tests a surface to see if it is a portion of a cone and returns the cone.\r\n\r\n  \r\n\r\n   tolerance: tolerance to use when checking.\r\n\r\n   Returns: true if the surface is a portion of a cone.\r\n\r\n  TryGetCone(self: Surface) -> (bool,Cone)\r\n\r\n  \r\n\r\n   Tests a surface to see if it is a portion of a cone within RhinoMath.ZeroTolerance and return \r\n\r\n    the cone.\r\n\r\n  \r\n\r\n   Returns: true if the surface is a portion of a cone.\r\n  \"\"\"\r\n  pass\r\n def TryGetCylinder(self,cylinder,tolerance=None):\r\n  \"\"\"\r\n  TryGetCylinder(self: Surface,tolerance: float) -> (bool,Cylinder)\r\n\r\n  \r\n\r\n   Tests a surface to see if it is a portion of a cylinder and return the cylinder.\r\n\r\n  \r\n\r\n   tolerance: tolerance to use when checking.\r\n\r\n   Returns: true if the surface is a portion of a cylinder.\r\n\r\n  TryGetCylinder(self: Surface) -> (bool,Cylinder)\r\n\r\n  \r\n\r\n   Tests a surface to see if it is a portion of a cylinder within RhinoMath.ZeroTolerance and \r\n\r\n    return the cylinder.\r\n\r\n  \r\n\r\n   Returns: true if the surface is a portion of a cylinder.\r\n  \"\"\"\r\n  pass\r\n def TryGetPlane(self,plane,tolerance=None):\r\n  \"\"\"\r\n  TryGetPlane(self: Surface,tolerance: float) -> (bool,Plane)\r\n\r\n  \r\n\r\n   Tests a surface for planarity and return the plane.\r\n\r\n  \r\n\r\n   tolerance: tolerance to use when checking.\r\n\r\n   Returns: true if there is a plane such that the maximum distance from the surface to the plane is <= \r\n\r\n    tolerance.\r\n\r\n  \r\n\r\n  TryGetPlane(self: Surface) -> (bool,Plane)\r\n\r\n  \r\n\r\n   Tests a surface for planarity and return the plane.\r\n\r\n   Returns: true if there is a plane such that the maximum distance from the surface to the plane is <= \r\n\r\n    RhinoMath.ZeroTolerance.\r\n  \"\"\"\r\n  pass\r\n def TryGetSphere(self,sphere,tolerance=None):\r\n  \"\"\"\r\n  TryGetSphere(self: Surface,tolerance: float) -> (bool,Sphere)\r\n\r\n  \r\n\r\n   Test a surface to see if it is a portion of a sphere and return the sphere.\r\n\r\n  \r\n\r\n   tolerance: tolerance to use when checking.\r\n\r\n   Returns: true if the surface is a portion of a sphere.\r\n\r\n  TryGetSphere(self: Surface) -> (bool,Sphere)\r\n\r\n  \r\n\r\n   Test a surface to see if it is a portion of a sphere and return the sphere.\r\n\r\n   Returns: true if the surface is a portion of a sphere.\r\n  \"\"\"\r\n  pass\r\n def TryGetTorus(self,torus,tolerance=None):\r\n  \"\"\"\r\n  TryGetTorus(self: Surface,tolerance: float) -> (bool,Torus)\r\n\r\n  \r\n\r\n   Tests a surface to see if it is a portion of a torus and returns the torus.\r\n\r\n  \r\n\r\n   tolerance: tolerance to use when checking.\r\n\r\n   Returns: true if the surface is a portion of a torus.\r\n\r\n  TryGetTorus(self: Surface) -> (bool,Torus)\r\n\r\n  \r\n\r\n   Tests a surface to see if it is a portion of a torus within RhinoMath.ZeroTolerance and returns \r\n\r\n    the torus.\r\n\r\n  \r\n\r\n   Returns: true if the surface is a portion of a torus.\r\n  \"\"\"\r\n  pass\r\n def __enter__(self,*args):\r\n  \"\"\"\r\n  __enter__(self: IDisposable) -> object\r\n\r\n  \r\n\r\n   Provides the implementation of __enter__ for objects which implement IDisposable.\r\n  \"\"\"\r\n  pass\r\n def __exit__(self,*args):\r\n  \"\"\"\r\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\r\n\r\n   Provides the implementation of __exit__ for objects which implement IDisposable.\r\n  \"\"\"\r\n  pass\r\n def __init__(self,*args):\r\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n  pass\r\n @staticmethod\r\n def __new__(self,*args): #cannot find CLR constructor\r\n  \"\"\"\r\n  __new__(cls: type)\r\n\r\n  __new__(cls: type,info: SerializationInfo,context: StreamingContext)\r\n  \"\"\"\r\n  pass\r\n def __reduce_ex__(self,*args):\r\n  pass\r\n IsSolid=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets a values indicating whether a surface is solid.\r\n\r\n\r\n\r\nGet: IsSolid(self: Surface) -> bool\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n\r\n",
  "language": "python",
  "imports": [
    "RhinoCommon"
  ],
  "has_docstring": false
}