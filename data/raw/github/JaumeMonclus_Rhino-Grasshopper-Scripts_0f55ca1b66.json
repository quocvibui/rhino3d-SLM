{
  "source_url": "https://github.com/JaumeMonclus/Rhino-Grasshopper-Scripts/blob/ca6be60d1f0266c805ce4d76dfc277bd05070c87/AT-AP-Sessions/Session-05/function.py",
  "repo": "JaumeMonclus/Rhino-Grasshopper-Scripts",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "AT-AP-Sessions/Session-05/function.py",
  "instruction": "MUST READ\r\n\r\n# inputs must be named (m, s, p) in order to work with the component.\r\n\r\n# m: mesh\r\n# s: paths (tree of paths)\r\n# p: points (tree of points)\r\n\r\n# Also, the s and p inputs must be trees...",
  "code": "\r\n\r\n''' MUST READ\r\n\r\n# inputs must be named (m, s, p) in order to work with the component.\r\n\r\n# m: mesh\r\n# s: paths (tree of paths)\r\n# p: points (tree of points)\r\n\r\n# Also, the s and p inputs must be trees of points Change to TREE ACCESS!\r\n# m is left as item acceSs!'''\r\n\r\n\r\n\r\n#r: networkx\r\n#r: matplotlib\r\n\r\n# from ast import pattern\r\nfrom os import path, remove\r\nimport re\r\nfrom typing import cast, Any\r\nfrom unittest.mock import seal\r\nimport networkx as nx # type: ignore\r\nimport matplotlib.pyplot as plt # type: ignore\r\nimport Rhino.Geometry as rg\r\nimport numpy as np\r\nfrom numpy import true_divide\r\nfrom System.Collections.Generic import List\r\nimport ghpythonlib.treehelpers as th # type: ignore\r\nimport ghpythonlib.components as comps # type: ignore\r\nimport graph_helpers as graph \r\n# from Grasshopper.Kernel.Data import DataTree, GH_Path\r\n\r\n\r\n\r\nm = cast(rg.Mesh, m)  # type: ignore\r\np = cast(rg.Point3d, p)\r\n\r\nclass PathStripper:\r\n\r\n    def __init__(self, mesh, paths, points):\r\n\r\n        '''Initializes the PathStripper class with a mesh, paths, and points.'''\r\n\r\n        self.mesh = mesh\r\n        self.paths_tree   = paths\r\n        self.indexes = []\r\n        self.Polylines = []\r\n        self.points = points\r\n        self.cull_pattern = []\r\n\r\n    def compute_indexes(self):             \r\n\r\n        '''Computes the indexes of the paths in the mesh and a Culling pattern.'''\r\n        \r\n        self.indexes      = []\r\n        self.cull_pattern = []\r\n\r\n        for path in self.paths_tree.Paths:\r\n            branch = self.paths_tree.Branch(path)\r\n            if len(branch) >= 8:\r\n                self.indexes.append(branch)\r\n                self.cull_pattern.append(True)\r\n            else:\r\n                self.cull_pattern.append(False)\r\n\r\n        return self.indexes\r\n\r\n\r\n\r\n    def get_filtered_lists(self):\r\n            \r\n            '''Filters the paths based on the culling pattern.'''\r\n\r\n            filtered = []\r\n            for keep, path in zip(self.cull_pattern, self.points.Paths):\r\n                if not keep:\r\n                    continue\r\n                branch = self.points.Branch(path)\r\n                if branch:\r\n                    filtered.append(branch)\r\n\r\n            return filtered\r\n\r\n\r\n    def compute_polylines(self):\r\n            \r\n            '''Computes the polylines from the filtered paths.'''\r\n        \r\n            self.polylines = []\r\n            for raw_branch in self.get_filtered_lists():\r\n                pts = [pt for pt in raw_branch if isinstance(pt, rg.Point3d)]\r\n                if pts:\r\n                    self.polylines.append(rg.Polyline(pts))\r\n            return self.polylines\r\n    \r\n    def compute_distances(self):\r\n\r\n        '''Computes many things, but we keep the \"Checked_distances\" of the polylines and their endpoints.'''\r\n        '''Checked_distances are the distances of the polylines minus the distances of their endpoints.'''\r\n\r\n        self.distances = []\r\n        self.endpoint_distances = []\r\n        self.checked_distances = []\r\n\r\n\r\n        for polyline in self.polylines:\r\n            length = polyline.Length\r\n            self.distances.append(length)\r\n\r\n        for polyline in self.polylines:\r\n            start, end = comps.EndPoints(polyline)\r\n            line = rg.Line(start, end)\r\n            distance = line.Length\r\n            self.endpoint_distances.append(distance)\r\n        \r\n        for i in range(len(self.distances)):\r\n            self.checked_distances.append(self.distances[i] - self.endpoint_distances[i])\r\n            \r\n        return self.checked_distances\r\n    \r\n    def compute_sorting(self):\r\n\r\n        '''Sorts the ordred indexes based on the checked distances.'''\r\n\r\n        paired = list(zip(self.checked_distances, self.indexes))\r\n        paired_sorted = sorted(paired, key=lambda x: x[0])\r\n\r\n        sorted_distances, sorted_polylines = zip(*paired_sorted) if paired_sorted else ([], [])\r\n\r\n        self.checked_distances = list(sorted_distances)\r\n        self.ordered_indexes   = list(sorted_polylines)\r\n\r\n        return self.distances\r\n    \r\n    def unpack_first_branch(self):\r\n\r\n        '''Anf finally, unpacks the first branch of the ordered indexes.'''\r\n\r\n        self.list_lengths   = [len(branch) for branch in self.ordered_indexes]\r\n        self.flattened_indexes = [item for branch in self.ordered_indexes for item in branch]\r\n\r\n        first_len = self.list_lengths[0]\r\n        first_branch = self.flattened_indexes[:first_len]\r\n\r\n        return first_branch\r\n    \r\n\r\n    \r\n                        ###############   \r\n                        ### OUTPUTS ###\r\n                        ###############   \r\n\r\n\r\na                        = PathStripper(m, s, p)\r\ncompute_indexes          = a.compute_indexes()\r\nget_filtered_lists       = a.get_filtered_lists()\r\ncompute_polylines        = a.compute_polylines()\r\ncompute_distances        = a.compute_distances()\r\ncompute_sorting          = a.compute_sorting()\r\nunpack_branches_to_lists = a.unpack_first_branch()\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}