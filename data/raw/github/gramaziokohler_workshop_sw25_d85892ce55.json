{
  "source_url": "https://github.com/gramaziokohler/workshop_sw25/blob/25ad14b7757819816815fd4b299ae3859ee2da54/examples/timber_toolpaths.py",
  "repo": "gramaziokohler/workshop_sw25",
  "repo_stars": 2,
  "repo_description": "Material for the workshop \"The syntax of Wood\", October 2025",
  "license": "unknown",
  "filepath": "examples/timber_toolpaths.py",
  "instruction": "Timber toolpaths",
  "code": "import math\n\nfrom compas.geometry import Frame, Transformation, Translation, Point, Line, Vector, Plane, Brep, Curve, NurbsCurve\nfrom compas.geometry import intersection_line_line, Polyline, offset_polyline\nfrom compas.itertools import linspace\n\nfrom compas_timber.elements import Beam\nfrom compas_timber.fabrication import JackRafterCut, JackRafterCutProxy, StepJoint, StepJointNotch\nfrom compas_timber.fabrication import Lap, LapProxy\nfrom compas_timber.fabrication import Drilling, FreeContour\nfrom compas_timber.fabrication import BTLxProcessing\nfrom compas_timber.utils import correct_polyline_direction\n\nfrom compas_rhino.conversions import frame_to_rhino_plane\nfrom compas_rhino.geometry import RhinoNurbsSurface\n\nfrom Rhino.Geometry import CurveOffsetCornerStyle # type: ignore\n\n\n# Spiral paths start out from the center of the slice and move outwards if this is enabled\nUSE_CENTER_OUT_CUTTING = False\nZ_FIGHTING_OFFSET = 0.0001\nCURVE_OFFSET_STYLE = CurveOffsetCornerStyle.NONE\nADD_SAFE_FRAMES = True\n\n\ndef get_toolpath_from_lap_processing(beam: Beam, \n                                     processing: BTLxProcessing,\n                                     machining_transformation: Transformation = None,\n                                     machining_frame: Frame = None,\n                                     tool_radius: float = 0.2,\n                                     stepdown: float = 0.05,\n                                     min_step: float = None,\n                                     approach_height: float = 0.5,\n                                     tolerance : float = 1e-3,\n                                     **kwargs):\n    volume = processing.volume_from_params_and_beam(beam)\n    volume_at_origin = volume.transformed(machining_transformation)\n\n    brep = Brep.from_mesh(volume_at_origin.to_mesh())\n    \n    path, flat_spirals, slicing_frames = slice_volume_offset_spiral_toolpath(\n        brep,\n        beam,\n        machining_frame,\n        tool_radius,\n        stepdown,\n        min_step,\n        approach_height,\n        tolerance,\n    )\n\n    return \"subtraction\", path, volume_at_origin, flat_spirals, slicing_frames\n\ndef slice_volume_offset_spiral_toolpath(brep: Brep,\n                                        beam: Beam, \n                                        machining_frame: Frame,\n                                        tool_radius: float,\n                                        stepdown: float,\n                                        min_step: float,\n                                        approach_height: float,\n                                        tolerance: float):\n    \n    slices = []\n    slicing_frames = []\n\n    levels = int(beam.height / stepdown) + 1\n\n    for i in range(levels):\n        frame = machining_frame.copy()\n        frame.point += frame.zaxis * ((stepdown * i) + Z_FIGHTING_OFFSET)\n        slicing_frames.append(frame)\n        slices += brep.slice(frame)\n\n    radius = tool_radius / 2\n    offset_step = radius * -1\n\n    flat_spirals = []\n    spirals = []\n    \n    for current_slice, slicing_frame in zip(slices, slicing_frames):\n        num_offsets = int((beam.width / 2) / radius) - 1\n        current_offset = current_slice\n        slice_offsets = [current_offset]\n\n        for i in range(num_offsets):\n            slicing_plane = frame_to_rhino_plane(slicing_frame)\n            native_offset = current_offset.native_curve.Offset(slicing_plane, offset_step, tolerance, CURVE_OFFSET_STYLE)\n            current_offset = Curve.from_native(native_offset[0])\n            \n            slice_offsets.append(current_offset)\n            flat_spirals.append(current_offset)\n        \n        spirals.append(slice_offsets)\n\n    path = []\n\n    for slice_offsets, slicing_frame in zip(spirals, slicing_frames):\n        next_slice_start_point = None\n\n        # Spiral paths can start from the center and move outwards or vice versa\n        if USE_CENTER_OUT_CUTTING:\n            arranged_offset_spirals = slice_offsets\n        else:\n            arranged_offset_spirals = reversed(slice_offsets)\n\n        for slice_offset in arranged_offset_spirals:\n            for subcurve in slice_offset.native_curve.GetSubCurves():\n                segment = NurbsCurve.from_native(subcurve)\n\n                max_divisions = max(1, int(segment.length() / min_step))\n                _params, points = segment.divide_by_count(max_divisions, return_points=True)\n\n                if next_slice_start_point is None:\n                    next_slice_start_point = points[0]\n                for point in points:\n                    frame = slicing_frame.copy()\n                    frame.point = point\n                    path.append(frame)\n\n        # Move in the same frame to the start of the next slice\n        if next_slice_start_point:\n            frame = slicing_frame.copy()\n            frame.point = next_slice_start_point\n            path.append(frame)\n\n    if ADD_SAFE_FRAMES:\n        # We negate the approach height to have the approach vector point outwards\n        # from the beam because Z axis points inwards\n        approach_vector = path[0].zaxis * -approach_height\n        path = add_safe_frames(path, approach_vector)\n\n    return path, flat_spirals, slicing_frames\n\ndef get_toolpath_for_plane_cut(beam: Beam, \n                               blank_brep_at_origin: Brep, \n                               frame: Frame,\n                               machining_frame: Frame = None,\n                               tool_radius: float = 0.2,\n                               min_step: float = None,\n                               approach_height: float = 0.5,\n                               flip_direction: bool = False) -> list[Frame]:\n    slices = blank_brep_at_origin.slice(frame)\n    if len(slices) != 1:\n        raise ValueError(\"Expected exactly one slice from the blank at the machining plane.\")\n    \n    slice_surface = RhinoNurbsSurface.from_corners(slices[0].points[0:4])\n\n    path = []\n    radius = tool_radius / 2\n    num_steps = int((beam.height / 2) / radius) - 1\n    isocurves = []\n\n    # Determine the U/V curve direction (most aligned with world X axis)\n    p1 = slice_surface.isocurve_u(0).point_at(0)\n    p2 = slice_surface.isocurve_u(0).point_at(1)\n    isocurve_u_vector = (p2 - p1).unitized()\n    dot_u = abs(isocurve_u_vector.dot(Vector(1, 0, 0)))\n\n    p1 = slice_surface.isocurve_v(0).point_at(0)\n    p2 = slice_surface.isocurve_v(0).point_at(1)\n    isocurve_v_vector = (p2 - p1).unitized()\n    dot_v = abs(isocurve_v_vector.dot(Vector(1, 0, 0)))\n\n    direction = dot_u > dot_v\n    if flip_direction:\n        direction = not direction\n\n    if direction:\n        linear_spacer = slice_surface.space_u\n        isocurve_selector = slice_surface.isocurve_u\n    else:\n        linear_spacer = slice_surface.space_v\n        isocurve_selector = slice_surface.isocurve_v\n\n    params = linear_spacer(num_steps)\n\n    for i, param in enumerate(params):\n        isocurve = isocurve_selector(param)\n\n        max_divisions = max(1, int(isocurve.length() / min_step))\n        _params, points = isocurve.divide_by_count(max_divisions, return_points=True)\n        if i % 2 == 1:\n            points.reverse()\n\n        for point in points:\n            frame = machining_frame.copy()\n            frame.point = point\n            path.append(frame)\n\n        isocurves.append(isocurve)\n\n    if ADD_SAFE_FRAMES:\n        start_end_vector = isocurves[0].point_at(0) - isocurves[-1].point_at(0)\n        start_end_vector.unitize()\n        approach_vector = start_end_vector * approach_height\n        path = add_safe_frames(path, approach_vector)\n\n    return path, slice_surface, isocurves\n\n\ndef get_toolpath_from_jackraftercut_processing(beam: Beam, \n                                               processing: BTLxProcessing,\n                                               machining_transformation: Transformation = None,\n                                               machining_frame: Frame = None,\n                                               tool_radius: float = 0.2,\n                                               stepdown: float = 0.05,\n                                               min_step: float = None,\n                                               approach_height: float = 0.5,\n                                               flip_direction: bool = False,\n                                               tolerance : float = 1e-3,\n                                               **kwargs):\n    plane = processing.plane_from_params_and_beam(beam)\n    plane_at_origin = plane.transformed(machining_transformation)\n    blank_brep_at_origin = beam.blank.to_brep().transformed(machining_transformation)\n\n    frame = Frame.from_plane(plane_at_origin)\n    slices = blank_brep_at_origin.slice(frame)\n    if len(slices) != 1:\n        raise ValueError(\"Expected exactly one slice from the blank at the machining plane.\")\n\n    path, slice_surface, isocurves = get_toolpath_for_plane_cut(beam, blank_brep_at_origin, frame, machining_frame=machining_frame, tool_radius=tool_radius, min_step=min_step, approach_height=approach_height, flip_direction=flip_direction)\n\n    return \"cut\", path, slice_surface, isocurves\n\n\ndef get_toolpath_for_drilling_processing(beam: Beam, \n                                         processing: Drilling,\n                                         machining_transformation: Transformation = None,\n                                         machining_frame: Frame = None,\n                                         tool_radius: float = 0.2,\n                                         stepdown: float = 0.05,\n                                         min_step: float = None,\n                                         approach_height: float = 0.5,\n                                         flip_direction: bool = False,\n                                         tolerance : float = 1e-3,\n                                         **kwargs):\n    cylinder = processing.cylinder_from_params_and_element(beam)\n    cylinder_at_origin = cylinder.transformed(machining_transformation)\n    center_line = cylinder_at_origin.axis.copy()\n    center_line.transform(Translation.from_vector(center_line.direction * -cylinder.height / 2))\n\n    plane = Plane(center_line.start, center_line.direction)\n    entry_frame = Frame.from_plane(plane)\n\n    # We negate the approach height to have the approach vector point outwards\n    # from the beam because Z axis points inwards\n    approach_vector = entry_frame.zaxis * -approach_height\n\n    path = []\n\n    safe_approach = machining_frame.copy()\n    safe_approach.point = entry_frame.point\n    safe_approach.point += approach_vector\n    \n    approach_path = interpolate_frames(safe_approach, entry_frame, min_step)\n    path.extend(approach_path)\n\n    # TODO: support depth / depth_limited\n    drill_path = []\n    for point in divide_line(center_line, min_step):\n        frame = entry_frame.copy()\n        frame.point = point\n        drill_path.append(frame)\n    path.extend(drill_path)\n\n    # Start retracting\n    path.extend(reversed(drill_path))\n    path.extend(reversed(approach_path))\n\n    return \"subtraction\", path, center_line, [], []\n\n\ndef get_toolpath_for_free_contour_processing(beam: Beam,\n                                             processing: Drilling,\n                                             machining_transformation: Transformation = None,\n                                             machining_frame: Frame = None,\n                                             tool_radius: float = 0.2,\n                                             stepdown: float = 0.05,\n                                             min_step: float = None,\n                                             approach_height: float = 0.5,\n                                             flip_direction: bool = False,\n                                             tolerance : float = 1e-3,\n                                             **kwargs):\n\n    ref_side = beam.ref_sides[processing.ref_side_index]\n    xform = Transformation.from_frame_to_frame(Frame.worldXY(), ref_side)\n    pts = [pt.transformed(xform) for pt in processing.contour_param_object.polyline]\n    pts = correct_polyline_direction(pts, -ref_side.normal, clockwise=True)\n    pln = Polyline(offset_polyline(Polyline(pts), 0.001, normal=-ref_side.normal))\n    pt = intersection_line_line(pln.lines[0], pln.lines[-1])\n    pln[0] = pt[0]\n    pln[-1] = pt[0]\n    volume = Brep.from_extrusion(NurbsCurve.from_points(pln, degree=1), -ref_side.normal * processing.contour_param_object.depth)\n    volume_at_origin = volume.transformed(machining_transformation)\n\n    path, flat_spirals, slicing_frames = slice_volume_offset_spiral_toolpath(\n        volume_at_origin,\n        beam,\n        machining_frame,\n        tool_radius,\n        stepdown,\n        min_step,\n        approach_height,\n        tolerance,\n    )\n\n    return \"subtraction\", path, volume_at_origin, flat_spirals, slicing_frames\n\ndef add_safe_frames(path: list[Frame], approach_vector: Vector) -> list[Frame]:\n    # Add safe approach and retract frames to the toolpath\n    safe_approach = path[0].copy()\n    safe_approach.point += approach_vector\n    path.insert(0, safe_approach)\n\n    safe_retract = path[-1].copy()\n    safe_retract.point += approach_vector\n    path.append(safe_retract)\n\n    return path\n\n\ndef interpolate_frames(start_frame: Frame, end_frame: Frame, min_step: float) -> list[Frame]:\n    line = Line(start_frame.point, end_frame.point)\n    max_divisions = max(1, int(line.length / min_step))\n    return start_frame.interpolate_frames(end_frame, max_divisions)\n\n\ndef divide_line(line: Line, step_length: float) -> list[Point]:\n    max_divisions = max(1, int(line.length / step_length))\n    params = linspace(0, 1, max_divisions)\n    return [line.point_at(t) for t in params]\n\n\ndef get_toolpath_from_processing(beam: Beam, processing: BTLxProcessing, machining_transformation: Transformation, machining_side: int, **kwargs):\n    # Automatically pick machining side if not specified (-1)\n    machining_side = machining_side if machining_side != -1 else processing.ref_side_index\n    machining_frame = beam.ref_sides[machining_side].transformed(machining_transformation)\n\n    # We flip the machining frame to point Z axis inwards into the beam\n    # matching what would likely be the TCP frame of the machine\n    machining_frame.yaxis *= -1\n\n    toolpath_function = None\n\n    if isinstance(processing, (Lap, LapProxy)):\n        toolpath_function = get_toolpath_from_lap_processing\n    elif isinstance(processing, (JackRafterCut, JackRafterCutProxy)):\n        toolpath_function = get_toolpath_from_jackraftercut_processing\n    elif isinstance(processing, FreeContour):\n        toolpath_function = get_toolpath_for_free_contour_processing\n    elif isinstance(processing, Drilling):\n        toolpath_function = get_toolpath_for_drilling_processing\n\n    if toolpath_function:\n        return toolpath_function(beam, processing, machining_transformation, machining_frame=machining_frame, **kwargs)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}