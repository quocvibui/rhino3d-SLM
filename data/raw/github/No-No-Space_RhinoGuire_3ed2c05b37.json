{
  "source_url": "https://github.com/No-No-Space/RhinoGuire/blob/548bce9235e3fe48babd81460cc88bfbbf6c1f0b/DataVisualization/Chivito.py",
  "repo": "No-No-Space/RhinoGuire",
  "repo_stars": 1,
  "repo_description": "A collection of Python 3 tools for managing object metadata (User Keys/Values) in Rhino 8.",
  "license": "MIT",
  "filepath": "DataVisualization/Chivito.py",
  "instruction": "# -*- coding: utf-8 -*- __title__ = \"Chivito\"                           # Name of the button displayed in Revit UI __doc__ = \"\"\"Version = 0.5 Date    = 2026-02-14 Author: Aquelon - aquelon@pm.me _____________________________________________________________________ Description: Data Visualization Tool - Unified Interface (Python 3 / Excel Version) A single GUI for the complete metadata visualization workflow using Excel files. FULLY SELF-CONTAINED - No external script dependencies _____________________________________________________________________ How-to: -> Run the script in Rhino 8 (RunPythonScript), a modeless window opens -> Step 1: Click \"Select Excel & Apply Keys\", pick an Excel template, select objects -> Step 2: Click \"Scan & Generate Excel\", select objects, save the color mapping file -> Open the exported Excel in a spreadsheet editor and fill in the R, G, B, A columns -> Step 3: Click \"Open Color Manager\", select objects, pick the color Excel file -> In the Color Manager: select a key from the dropdown, click \"Update Colors\" -> Use \"Export Legend as PNG\" or \"Capture Viewport as PNG\" for presentations -> The window is non-blocking, you can interact with Rhino while it is open _____________________________________________________________________ Last update: - [14.02.2026] - 0.5 RELEASE _____________________________________________________________________ To-Do: - UI needs improvement, it is functional at the moment, but default look. - Default folder locations need to be updated to neutral locations (desktop or documents) instead of script folder. - Add a button to create an Excel template, before it was a separate script, but it may be more intuitive to have it integrated in the workflow, this way the user can create the template and fill it with colors before applying it to the objects. The script window needs to be closed before editing the Excel file exported. Correct this, so the file is freed after export. - Correct that the ViewCaptureToFile allows for interaction with the menu from Rhino, so the user cna define the settings of the capture. _____________________________________________________________________ r: openpyxl",
  "code": "#! python3\n# # -*- coding: utf-8 -*-\n# __title__ = \"Chivito\"                           # Name of the button displayed in Revit UI\n# __doc__ = \"\"\"Version = 0.5\n# Date    = 2026-02-14\n# Author: Aquelon - aquelon@pm.me \n# _____________________________________________________________________\n# Description:\n# Data Visualization Tool - Unified Interface (Python 3 / Excel Version)\n# A single GUI for the complete metadata visualization workflow using Excel files.\n# FULLY SELF-CONTAINED - No external script dependencies\n# _____________________________________________________________________\n# How-to:\n# -> Run the script in Rhino 8 (RunPythonScript), a modeless window opens\n# -> Step 1: Click \"Select Excel & Apply Keys\", pick an Excel template, select objects\n# -> Step 2: Click \"Scan & Generate Excel\", select objects, save the color mapping file\n# -> Open the exported Excel in a spreadsheet editor and fill in the R, G, B, A columns\n# -> Step 3: Click \"Open Color Manager\", select objects, pick the color Excel file\n# -> In the Color Manager: select a key from the dropdown, click \"Update Colors\"\n# -> Use \"Export Legend as PNG\" or \"Capture Viewport as PNG\" for presentations\n# -> The window is non-blocking, you can interact with Rhino while it is open\n# _____________________________________________________________________\n# Last update:\n# - [14.02.2026] - 0.5 RELEASE\n# _____________________________________________________________________\n# To-Do:\n# - UI needs improvement, it is functional at the moment, but default look.\n# - Default folder locations need to be updated to neutral locations (desktop or documents) instead of script folder.\n# - Add a button to create an Excel template, before it was a separate script, but it may be more intuitive to have it integrated in the workflow, this way the user can create the template and fill it with colors before applying it to the objects.\n# The script window needs to be closed before editing the Excel file exported. Correct this, so the file is freed after export.\n# - Correct that the ViewCaptureToFile allows for interaction with the menu from Rhino, so the user cna define the settings of the capture.\n# _____________________________________________________________________\n# r: openpyxl\n\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino\nimport os\nfrom collections import defaultdict\n\n# Import openpyxl for Excel operations\ntry:\n    from openpyxl import Workbook, load_workbook\n    from openpyxl.styles import PatternFill, Font as ExcelFont\n    EXCEL_AVAILABLE = True\nexcept ImportError:\n    EXCEL_AVAILABLE = False\n    print(\"Warning: openpyxl not available. Please install it using: pip install openpyxl\")\n\n# Import Eto forms\nimport Eto.Drawing as drawing\nimport Eto.Forms as forms\n\n# Import System.Drawing for PNG export\nimport System.Drawing as sdrawing\n\n\n# ============================================================================\n# SCRIPT 01 FUNCTIONS - Read keys from Excel and apply to objects\n# ============================================================================\n\ndef read_keys_from_excel(excel_path):\n    \"\"\"Read key definitions from Excel file\n\n    Expected format:\n    Column A: Key Name\n    Column B: Default Value\n    \"\"\"\n    try:\n        wb = load_workbook(excel_path)\n        ws = wb.active\n\n        keys = {}\n        # Skip header row, start from row 2\n        for row in ws.iter_rows(min_row=2, values_only=True):\n            if row[0]:  # If key name exists\n                key_name = str(row[0]).strip()\n                default_value = str(row[1]).strip() if len(row) > 1 and row[1] else ''\n                if key_name:\n                    keys[key_name] = default_value\n\n        wb.close()\n        return keys\n    except Exception as e:\n        print(f\"Error reading Excel: {e}\")\n        return None\n\n\ndef apply_keys_to_objects(objects, keys):\n    \"\"\"Apply keys to objects without overwriting\"\"\"\n    stats = {'objects_processed': 0, 'keys_added': 0, 'keys_skipped': 0}\n    for obj in objects:\n        stats['objects_processed'] += 1\n        for key_name, default_value in keys.items():\n            if rs.GetUserText(obj, key_name) is None:\n                rs.SetUserText(obj, key_name, default_value)\n                stats['keys_added'] += 1\n            else:\n                stats['keys_skipped'] += 1\n    return stats\n\n\n# ============================================================================\n# SCRIPT 02 FUNCTIONS - Collect unique values and generate Excel\n# ============================================================================\n\ndef collect_unique_values(objects):\n    \"\"\"Scan objects for unique key-value pairs\"\"\"\n    key_values = defaultdict(set)\n    for obj in objects:\n        keys = rs.GetUserText(obj)\n        if keys:\n            for key in keys:\n                value = rs.GetUserText(obj, key)\n                if value is not None and value != '':\n                    key_values[key].add(value)\n    return {key: sorted(list(values)) for key, values in key_values.items()}\n\n\ndef write_color_map_excel(excel_path, key_value_dict):\n    \"\"\"Write color mapping Excel file, preserving existing color values.\n\n    If the target file already exists, existing RGB/A values are preserved\n    for key-value pairs that still exist. Only entries no longer present\n    in the scan are removed.\n\n    Format:\n    Columns: Key | Value | R | G | B | A\n    \"\"\"\n    # Read existing color values if the file already exists\n    existing_colors = {}\n    if os.path.exists(excel_path):\n        try:\n            old_wb = load_workbook(excel_path)\n            old_ws = old_wb.active\n            for row in old_ws.iter_rows(min_row=2, values_only=True):\n                if row and len(row) >= 6 and row[0] and row[1]:\n                    old_key = str(row[0]).strip()\n                    old_value = str(row[1]).strip()\n                    old_r = row[2] if row[2] is not None else ''\n                    old_g = row[3] if row[3] is not None else ''\n                    old_b = row[4] if row[4] is not None else ''\n                    old_a = row[5] if row[5] is not None else ''\n                    existing_colors[(old_key, old_value)] = (old_r, old_g, old_b, old_a)\n            old_wb.close()\n            print(f\"Found {len(existing_colors)} existing color definitions to preserve.\")\n        except Exception as e:\n            print(f\"Could not read existing file, creating new: {e}\")\n\n    try:\n        wb = Workbook()\n        ws = wb.active\n        ws.title = \"Color Mapping\"\n\n        # Write headers\n        headers = ['Key', 'Value', 'R', 'G', 'B', 'A']\n        for col_idx, header in enumerate(headers, start=1):\n            cell = ws.cell(row=1, column=col_idx, value=header)\n            cell.font = ExcelFont(bold=True)\n            cell.fill = PatternFill(start_color=\"CCCCCC\", end_color=\"CCCCCC\", fill_type=\"solid\")\n\n        # Write data rows, preserving existing colors\n        row_idx = 2\n        preserved = 0\n        for key_name in sorted(key_value_dict.keys()):\n            for value in key_value_dict[key_name]:\n                ws.cell(row=row_idx, column=1, value=key_name)\n                ws.cell(row=row_idx, column=2, value=value)\n\n                # Check if color values exist for this key-value pair\n                old_rgba = existing_colors.get((key_name, value))\n                if old_rgba:\n                    ws.cell(row=row_idx, column=3, value=old_rgba[0])\n                    ws.cell(row=row_idx, column=4, value=old_rgba[1])\n                    ws.cell(row=row_idx, column=5, value=old_rgba[2])\n                    ws.cell(row=row_idx, column=6, value=old_rgba[3])\n                    preserved += 1\n                else:\n                    ws.cell(row=row_idx, column=3, value='')\n                    ws.cell(row=row_idx, column=4, value='')\n                    ws.cell(row=row_idx, column=5, value='')\n                    ws.cell(row=row_idx, column=6, value='')\n\n                row_idx += 1\n\n        # Auto-adjust column widths\n        for col in ws.columns:\n            max_length = 0\n            column = col[0].column_letter\n            for cell in col:\n                try:\n                    if len(str(cell.value)) > max_length:\n                        max_length = len(str(cell.value))\n                except:\n                    pass\n            adjusted_width = min(max_length + 2, 50)\n            ws.column_dimensions[column].width = adjusted_width\n\n        wb.save(excel_path)\n        wb.close()\n\n        total_rows = row_idx - 2\n        if preserved > 0:\n            print(f\"Preserved {preserved} existing color definitions out of {total_rows} entries.\")\n        return total_rows\n    except Exception as e:\n        print(f\"Error writing Excel: {e}\")\n        return 0\n\n\n# ============================================================================\n# SCRIPT 03 FUNCTIONS - Apply colors from Excel mapping\n# ============================================================================\n\ndef read_color_map_from_excel(excel_path):\n    \"\"\"Read color mappings from Excel file\n\n    Expected format:\n    Columns: Key | Value | R | G | B | A\n    \"\"\"\n    color_map = {}\n    try:\n        wb = load_workbook(excel_path)\n        ws = wb.active\n\n        # Read data rows (skip header)\n        for row in ws.iter_rows(min_row=2, values_only=True):\n            if len(row) >= 6:\n                key = str(row[0]).strip() if row[0] else ''\n                value = str(row[1]).strip() if row[1] else ''\n                r = row[2]\n                g = row[3]\n                b = row[4]\n                a = row[5]\n\n                if key and value:\n                    try:\n                        r_val = max(0, min(255, int(r) if r else 0))\n                        g_val = max(0, min(255, int(g) if g else 0))\n                        b_val = max(0, min(255, int(b) if b else 0))\n                        a_val = max(0, min(255, int(a) if a else 255))\n\n                        if key not in color_map:\n                            color_map[key] = {}\n                        color_map[key][value] = (r_val, g_val, b_val, a_val)\n                    except ValueError:\n                        continue\n\n        wb.close()\n        return color_map\n    except Exception as e:\n        print(f\"Error reading color Excel: {e}\")\n        return None\n\n\ndef analyze_objects_for_key(objects, active_key):\n    \"\"\"Analyze objects for unique values\"\"\"\n    value_objects = {}\n    objects_without_key = []\n    for obj in objects:\n        value = rs.GetUserText(obj, active_key)\n        if value is None or value == '':\n            objects_without_key.append(obj)\n        else:\n            if value not in value_objects:\n                value_objects[value] = []\n            value_objects[value].append(obj)\n    return {'value_objects': value_objects, 'objects_without_key': objects_without_key}\n\n\ndef apply_colors_to_objects(objects, active_key, color_map, default_color):\n    \"\"\"Apply colors based on metadata - optimized with RhinoCommon direct access.\n\n    Key optimizations over rhinoscriptsyntax:\n    - Single pass: reads user text and applies color in one loop\n    - Redraw suppressed during batch operation\n    - Pre-computed System.Drawing.Color objects\n    - Direct attribute modification (bypasses rs.ObjectColor overhead)\n    \"\"\"\n    stats = {\n        'colored': 0,\n        'default': 0,\n        'missing_color_definition': [],\n        'unused_color_definitions': []\n    }\n\n    key_color_map = color_map.get(active_key, {})\n\n    # Pre-compute System.Drawing.Color for each value\n    color_cache = {}\n    for value, rgba in key_color_map.items():\n        color_cache[value] = sdrawing.Color.FromArgb(rgba[0], rgba[1], rgba[2])\n    default_sys_color = sdrawing.Color.FromArgb(\n        default_color[0], default_color[1], default_color[2])\n    color_from_obj = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n\n    used_values = set()\n    missing_by_value = {}\n\n    # Disable viewport redraws during batch operation\n    sc.doc.Views.RedrawEnabled = False\n    try:\n        for obj_id in objects:\n            rhino_obj = sc.doc.Objects.FindId(rs.coerceguid(obj_id))\n            if not rhino_obj:\n                continue\n\n            value = rhino_obj.Attributes.GetUserString(active_key)\n            attrs = rhino_obj.Attributes.Duplicate()\n            attrs.ColorSource = color_from_obj\n\n            if not value:\n                attrs.ObjectColor = default_sys_color\n                sc.doc.Objects.ModifyAttributes(rhino_obj.Id, attrs, True)\n                stats['default'] += 1\n            else:\n                used_values.add(value)\n                sys_color = color_cache.get(value)\n                if sys_color:\n                    attrs.ObjectColor = sys_color\n                    sc.doc.Objects.ModifyAttributes(rhino_obj.Id, attrs, True)\n                    stats['colored'] += 1\n                else:\n                    attrs.ObjectColor = default_sys_color\n                    sc.doc.Objects.ModifyAttributes(rhino_obj.Id, attrs, True)\n                    if value not in missing_by_value:\n                        missing_by_value[value] = []\n                    missing_by_value[value].append(obj_id)\n    finally:\n        sc.doc.Views.RedrawEnabled = True\n\n    stats['missing_color_definition'] = [\n        (v, objs) for v, objs in missing_by_value.items()]\n\n    excel_values = set(key_color_map.keys())\n    unused = excel_values - used_values\n    stats['unused_color_definitions'] = sorted(list(unused))\n\n    return stats\n\n\n# ============================================================================\n# COLOR MANAGER DIALOG (SCRIPT 03)\n# ============================================================================\n\nclass ColorManagerDialog(forms.Form):\n    \"\"\"Color Manager GUI (modeless - allows Rhino interaction)\"\"\"\n\n    def __init__(self, excel_path, objects):\n        super(ColorManagerDialog, self).__init__()\n\n        self.excel_path = excel_path\n        self.objects = objects\n        self.color_map = None\n        self.active_key = None\n        self.default_color = (128, 128, 128)\n        self.problem_objects = []\n\n        self.load_color_map()\n\n        self.Title = \"Color Manager\"\n        self.Padding = drawing.Padding(10)\n        self.Resizable = True\n        self.Size = drawing.Size(500, 600)\n        self.Topmost = True  # Keep on top\n\n        self.create_controls()\n        self.create_layout()\n\n    def load_color_map(self):\n        self.color_map = read_color_map_from_excel(self.excel_path)\n        if not self.color_map:\n            self.color_map = {}\n            forms.MessageBox.Show(\"Error loading Excel file\", \"Error\")\n\n    def create_controls(self):\n        self.key_label = forms.Label()\n        self.key_label.Text = \"Select Metadata Key:\"\n\n        self.key_dropdown = forms.DropDown()\n        available_keys = sorted(self.color_map.keys())\n        for key in available_keys:\n            self.key_dropdown.Items.Add(key)\n        if available_keys:\n            self.key_dropdown.SelectedIndex = 0\n            self.active_key = available_keys[0]\n        self.key_dropdown.SelectedIndexChanged += self.on_key_changed\n\n        self.default_color_label = forms.Label()\n        self.default_color_label.Text = \"Default Color:\"\n\n        self.default_color_picker = forms.ColorPicker()\n        self.default_color_picker.Value = drawing.Color.FromArgb(128, 128, 128)\n        self.default_color_picker.ValueChanged += self.on_default_color_changed\n\n        self.legend_label = forms.Label()\n        self.legend_label.Text = \"Color Legend:\"\n\n        self.legend_panel = forms.Panel()\n        self.legend_panel.Size = drawing.Size(450, 200)\n        self.legend_panel.BackgroundColor = drawing.Colors.White\n        self.update_legend()\n\n        self.warnings_label = forms.Label()\n        self.warnings_label.Text = \"Warnings & Errors:\"\n\n        self.warnings_text = forms.TextArea()\n        self.warnings_text.ReadOnly = True\n        self.warnings_text.Size = drawing.Size(450, 100)\n        self.warnings_text.Text = \"Click 'Update Colors' to analyze...\"\n\n        self.update_button = forms.Button()\n        self.update_button.Text = \"Update Colors\"\n        self.update_button.Click += self.on_update_clicked\n\n        self.select_button = forms.Button()\n        self.select_button.Text = \"Select Problem Objects\"\n        self.select_button.Click += self.on_select_clicked\n        self.select_button.Enabled = False\n\n        self.export_legend_button = forms.Button()\n        self.export_legend_button.Text = \"Export Legend as PNG\"\n        self.export_legend_button.Click += self.on_export_legend_clicked\n\n        self.capture_viewport_button = forms.Button()\n        self.capture_viewport_button.Text = \"Capture Viewport as PNG\"\n        self.capture_viewport_button.Click += self.on_capture_viewport_clicked\n\n        self.close_button = forms.Button()\n        self.close_button.Text = \"Close\"\n        self.close_button.Click += self.on_close_clicked\n\n        self.status_label = forms.Label()\n        self.status_label.Text = f\"Ready - {len(self.objects)} objects\"\n\n    def create_layout(self):\n        layout = forms.DynamicLayout()\n        layout.Spacing = drawing.Size(5, 5)\n        layout.AddRow(self.key_label)\n        layout.AddRow(self.key_dropdown)\n        layout.AddRow(None)\n        layout.AddRow(self.default_color_label)\n        layout.AddRow(self.default_color_picker)\n        layout.AddRow(None)\n        layout.AddRow(self.legend_label)\n        layout.AddRow(self.legend_panel)\n        layout.AddRow(None)\n        layout.AddRow(self.warnings_label)\n        layout.AddRow(self.warnings_text)\n        layout.AddRow(None)\n\n        button_layout = forms.DynamicLayout()\n        button_layout.Spacing = drawing.Size(5, 5)\n        button_layout.AddRow(self.update_button, self.select_button)\n        button_layout.AddRow(self.export_legend_button, self.capture_viewport_button, self.close_button)\n        layout.AddRow(button_layout)\n        layout.AddRow(self.status_label)\n\n        self.Content = layout\n\n    def update_legend(self):\n        if not self.active_key:\n            return\n        legend_layout = forms.DynamicLayout()\n        legend_layout.Spacing = drawing.Size(5, 5)\n        legend_layout.Padding = drawing.Padding(10)\n\n        title = forms.Label()\n        title.Text = self.active_key\n        title.Font = drawing.Font(drawing.SystemFont.Bold, 12)\n        legend_layout.AddRow(title)\n        legend_layout.AddRow(None)\n\n        key_colors = self.color_map.get(self.active_key, {})\n        for value in sorted(key_colors.keys()):\n            color_rgb = key_colors[value]\n\n            color_panel = forms.Panel()\n            color_panel.Size = drawing.Size(30, 20)\n            color_panel.BackgroundColor = drawing.Color.FromArgb(color_rgb[0], color_rgb[1], color_rgb[2])\n\n            value_label = forms.Label()\n            value_label.Text = value\n\n            rgb_text = f\"RGB: {color_rgb[0]},{color_rgb[1]},{color_rgb[2]}\"\n            rgb_label = forms.Label()\n            rgb_label.Text = rgb_text\n            rgb_label.Font = drawing.Font(drawing.SystemFont.Default, 9)\n            rgb_label.TextColor = drawing.Colors.Gray\n\n            row_layout = forms.DynamicLayout()\n            row_layout.Spacing = drawing.Size(5, 5)\n            row_layout.AddRow(color_panel, value_label, rgb_label)\n            legend_layout.AddRow(row_layout)\n\n        self.legend_panel.Content = legend_layout\n\n    def update_warnings(self, stats):\n        warnings = []\n        self.problem_objects = []\n\n        if stats['missing_color_definition']:\n            warnings.append(\"ERROR: Values in objects but missing from Excel:\")\n            warnings.append(\"=\" * 50)\n            for value, obj_list in stats['missing_color_definition']:\n                warnings.append(f\"  '{value}' ({len(obj_list)} objects)\")\n                self.problem_objects.extend(obj_list)\n            warnings.append(\"\")\n\n        if stats['unused_color_definitions']:\n            warnings.append(\"WARNING: Values in Excel but not in selection:\")\n            warnings.append(\"=\" * 50)\n            for value in stats['unused_color_definitions']:\n                warnings.append(f\"  '{value}'\")\n            warnings.append(\"\")\n\n        if stats['default'] > 0:\n            warnings.append(f\"INFO: {stats['default']} objects without '{self.active_key}' key\")\n            warnings.append(\"\")\n\n        if not warnings:\n            warnings.append(\"SUCCESS: All objects colored correctly!\")\n            warnings.append(f\"  {stats['colored']} objects colored\")\n\n        self.warnings_text.Text = \"\\n\".join(warnings)\n        self.select_button.Enabled = len(self.problem_objects) > 0\n\n    def on_key_changed(self, sender, e):\n        selected = self.key_dropdown.SelectedValue\n        if selected:\n            self.active_key = str(selected)\n            self.update_legend()\n            self.warnings_text.Text = \"Click 'Update Colors' to analyze...\"\n            self.select_button.Enabled = False\n\n    def on_default_color_changed(self, sender, e):\n        color = self.default_color_picker.Value\n        self.default_color = (color.R, color.G, color.B)\n\n    def on_update_clicked(self, sender, e):\n        if not self.active_key:\n            return\n\n        self.status_label.Text = \"Applying colors...\"\n        self.load_color_map()\n        self.update_legend()\n\n        stats = apply_colors_to_objects(self.objects, self.active_key, self.color_map, self.default_color)\n        sc.doc.Views.Redraw()\n\n        self.update_warnings(stats)\n        self.status_label.Text = f\"Updated! Colored: {stats['colored']}, Default: {stats['default']}\"\n\n    def on_select_clicked(self, sender, e):\n        if self.problem_objects:\n            rs.UnselectAllObjects()\n            rs.SelectObjects(self.problem_objects)\n            forms.MessageBox.Show(f\"Selected {len(self.problem_objects)} objects with missing colors\", \"Objects Selected\")\n\n    def on_export_legend_clicked(self, sender, e):\n        \"\"\"Export the current legend as a PNG image\"\"\"\n        if not self.active_key or not self.color_map:\n            forms.MessageBox.Show(\"No legend to export. Select a key first.\", \"Export Legend\")\n            return\n\n        key_colors = self.color_map.get(self.active_key, {})\n        if not key_colors:\n            forms.MessageBox.Show(f\"No color definitions for key '{self.active_key}'.\", \"Export Legend\")\n            return\n\n        # Ask for save location\n        png_path = rs.SaveFileName(\"Save Legend as PNG\", \"PNG Files (*.png)|*.png||\",\n                                   filename=f\"Legend_{self.active_key}.png\")\n        if not png_path:\n            return\n\n        try:\n            # Layout constants\n            padding = 20\n            swatch_size = 24\n            swatch_gap = 10\n            row_height = 30\n            title_height = 35\n            sorted_values = sorted(key_colors.keys())\n\n            # Measure text to determine image width\n            measure_bmp = sdrawing.Bitmap(1, 1)\n            measure_gfx = sdrawing.Graphics.FromImage(measure_bmp)\n            title_font = sdrawing.Font(\"Arial\", 14, sdrawing.FontStyle.Bold)\n            value_font = sdrawing.Font(\"Arial\", 10)\n            rgb_font = sdrawing.Font(\"Arial\", 9)\n\n            max_text_width = 0\n            for value in sorted_values:\n                color_rgb = key_colors[value]\n                value_text = value\n                rgb_text = f\"  RGB({color_rgb[0]}, {color_rgb[1]}, {color_rgb[2]})\"\n                full_text = value_text + rgb_text\n                text_size = measure_gfx.MeasureString(full_text, value_font)\n                if text_size.Width > max_text_width:\n                    max_text_width = text_size.Width\n\n            measure_gfx.Dispose()\n            measure_bmp.Dispose()\n\n            # Calculate image dimensions\n            img_width = int(padding + swatch_size + swatch_gap + max_text_width + padding + 20)\n            img_width = max(img_width, 300)\n            img_height = padding + title_height + len(sorted_values) * row_height + padding\n\n            # Create bitmap and draw\n            bmp = sdrawing.Bitmap(img_width, img_height)\n            gfx = sdrawing.Graphics.FromImage(bmp)\n            gfx.SmoothingMode = sdrawing.Drawing2D.SmoothingMode.AntiAlias\n            gfx.TextRenderingHint = sdrawing.Text.TextRenderingHint.AntiAlias\n\n            # White background\n            gfx.Clear(sdrawing.Color.White)\n\n            # Draw title\n            gfx.DrawString(self.active_key, title_font,\n                           sdrawing.Brushes.Black,\n                           sdrawing.PointF(padding, padding))\n\n            # Draw each legend entry\n            y = padding + title_height\n            for value in sorted_values:\n                color_rgb = key_colors[value]\n\n                # Color swatch\n                brush = sdrawing.SolidBrush(\n                    sdrawing.Color.FromArgb(color_rgb[0], color_rgb[1], color_rgb[2])\n                )\n                gfx.FillRectangle(brush,\n                                  padding, int(y), swatch_size, swatch_size)\n                # Swatch border\n                gfx.DrawRectangle(sdrawing.Pens.Gray,\n                                  padding, int(y), swatch_size, swatch_size)\n                brush.Dispose()\n\n                # Value text\n                text_x = padding + swatch_size + swatch_gap\n                gfx.DrawString(value, value_font,\n                               sdrawing.Brushes.Black,\n                               sdrawing.PointF(text_x, y))\n\n                # RGB text\n                rgb_text = f\"  RGB({color_rgb[0]}, {color_rgb[1]}, {color_rgb[2]})\"\n                value_size = gfx.MeasureString(value, value_font)\n                gfx.DrawString(rgb_text, rgb_font,\n                               sdrawing.Brushes.Gray,\n                               sdrawing.PointF(text_x + value_size.Width, y + 2))\n\n                y += row_height\n\n            # Save\n            bmp.Save(png_path, sdrawing.Imaging.ImageFormat.Png)\n\n            # Cleanup\n            title_font.Dispose()\n            value_font.Dispose()\n            rgb_font.Dispose()\n            gfx.Dispose()\n            bmp.Dispose()\n\n            self.status_label.Text = \"Legend exported as PNG\"\n            forms.MessageBox.Show(f\"Legend exported!\\n\\n{os.path.basename(png_path)}\", \"Export Complete\")\n\n        except Exception as ex:\n            print(f\"Error exporting legend: {ex}\")\n            forms.MessageBox.Show(f\"Error exporting legend:\\n{ex}\", \"Export Error\")\n\n    def on_capture_viewport_clicked(self, sender, e):\n        \"\"\"Open Rhino's ViewCaptureToFile dialog for viewport capture.\"\"\"\n        self.status_label.Text = \"Opening viewport capture settings...\"\n        Rhino.RhinoApp.RunScript(\"ViewCaptureToFile\", False)\n        self.status_label.Text = \"Viewport capture complete\"\n\n    def on_close_clicked(self, sender, e):\n        self.Close()\n\n\n# ============================================================================\n# MAIN UNIFIED INTERFACE\n# ============================================================================\n\nclass DataVisualizationTool(forms.Form):\n    \"\"\"Main unified interface - modeless, allows Rhino interaction\"\"\"\n\n    def __init__(self):\n        super(DataVisualizationTool, self).__init__()\n\n        self.script_dir = os.path.dirname(os.path.abspath(__file__))\n        self.excel_folder = os.path.join(self.script_dir, \"_ExcelOutput\")\n\n        # Create output folder if it doesn't exist\n        if not os.path.exists(self.excel_folder):\n            try:\n                os.makedirs(self.excel_folder)\n            except:\n                pass\n\n        self.Title = \"Data Visualization Tool (Excel)\"\n        self.Padding = drawing.Padding(15)\n        self.Resizable = False\n        self.Size = drawing.Size(450, 420)\n        self.Topmost = True  # KEEP ON TOP\n\n        self.create_controls()\n        self.create_layout()\n\n    def create_controls(self):\n        self.header = forms.Label()\n        self.header.Text = \"Rhino Metadata Visualization\"\n        self.header.Font = drawing.Font(drawing.SystemFont.Bold, 12)\n\n        self.step1_label = forms.Label()\n        self.step1_label.Text = \"Step 1: Initialize Keys\"\n        self.step1_label.Font = drawing.Font(drawing.SystemFont.Bold, 10)\n\n        self.step1_desc = forms.Label()\n        self.step1_desc.Text = \"Apply metadata keys from Excel to objects\"\n        self.step1_desc.TextColor = drawing.Colors.Gray\n\n        self.step1_button = forms.Button()\n        self.step1_button.Text = \"Select Excel & Apply Keys\"\n        self.step1_button.Click += self.on_step1\n\n        self.step2_label = forms.Label()\n        self.step2_label.Text = \"Step 2: Extract Unique Values\"\n        self.step2_label.Font = drawing.Font(drawing.SystemFont.Bold, 10)\n\n        self.step2_desc = forms.Label()\n        self.step2_desc.Text = \"Scan objects and generate color Excel\"\n        self.step2_desc.TextColor = drawing.Colors.Gray\n\n        self.step2_button = forms.Button()\n        self.step2_button.Text = \"Scan & Generate Excel\"\n        self.step2_button.Click += self.on_step2\n\n        self.step3_label = forms.Label()\n        self.step3_label.Text = \"Step 3: Visualize with Colors\"\n        self.step3_label.Font = drawing.Font(drawing.SystemFont.Bold, 10)\n\n        self.step3_desc = forms.Label()\n        self.step3_desc.Text = \"Interactive color visualization\"\n        self.step3_desc.TextColor = drawing.Colors.Gray\n\n        self.step3_button = forms.Button()\n        self.step3_button.Text = \"Open Color Manager\"\n        self.step3_button.Click += self.on_step3\n\n        self.status = forms.Label()\n        self.status.Text = \"Ready\"\n        self.status.TextColor = drawing.Colors.Blue\n\n        self.close_button = forms.Button()\n        self.close_button.Text = \"Close\"\n        self.close_button.Click += self.on_close\n\n    def create_layout(self):\n        layout = forms.DynamicLayout()\n        layout.Spacing = drawing.Size(8, 8)\n        layout.AddRow(self.header)\n        layout.AddRow(None)\n        layout.AddRow(self.step1_label)\n        layout.AddRow(self.step1_desc)\n        layout.AddRow(self.step1_button)\n        layout.AddRow(None)\n        layout.AddRow(self.step2_label)\n        layout.AddRow(self.step2_desc)\n        layout.AddRow(self.step2_button)\n        layout.AddRow(None)\n        layout.AddRow(self.step3_label)\n        layout.AddRow(self.step3_desc)\n        layout.AddRow(self.step3_button)\n        layout.AddRow(None)\n        layout.AddRow(self.status)\n        layout.AddRow(self.close_button)\n        self.Content = layout\n\n    def on_step1(self, sender, e):\n        excel_path = rs.OpenFileName(\"Select Excel File\", \"Excel Files (*.xlsx)|*.xlsx||\",\n                                     folder=self.excel_folder if os.path.exists(self.excel_folder) else None)\n        if not excel_path:\n            return\n        objects = rs.GetObjects(\"Select objects\", preselect=True)\n        if not objects:\n            return\n        keys = read_keys_from_excel(excel_path)\n        if not keys:\n            forms.MessageBox.Show(\"No keys found in Excel file\", \"Error\")\n            return\n        stats = apply_keys_to_objects(objects, keys)\n        self.status.Text = f\"Step 1: {stats['keys_added']} keys added\"\n        forms.MessageBox.Show(f\"Keys applied!\\n\\nObjects: {stats['objects_processed']}\\nKeys added: {stats['keys_added']}\\nSkipped: {stats['keys_skipped']}\", \"Complete\")\n        self.BringToFront()  # Return focus\n\n    def on_step2(self, sender, e):\n        objects = rs.GetObjects(\"Select objects\", preselect=True)\n        if not objects:\n            return\n        kvd = collect_unique_values(objects)\n        if not kvd:\n            forms.MessageBox.Show(\"No metadata found\", \"Error\")\n            return\n        excel_path = rs.SaveFileName(\"Save Excel File\", \"Excel Files (*.xlsx)|*.xlsx||\",\n                                     folder=self.excel_folder if os.path.exists(self.excel_folder) else None,\n                                     filename=\"UniqueValuesColorSettings.xlsx\")\n        if not excel_path:\n            return\n        file_existed = os.path.exists(excel_path)\n        rows = write_color_map_excel(excel_path, kvd)\n        self.status.Text = f\"Step 2: {rows} values exported\"\n        msg = f\"Excel generated!\\n\\nKeys: {len(kvd)}\\nValues: {rows}\"\n        if file_existed:\n            msg += \"\\n\\nExisting color definitions were preserved.\"\n        msg += \"\\n\\nNext: Fill RGB colors in Excel\"\n        forms.MessageBox.Show(msg, \"Complete\")\n        self.BringToFront()  # Return focus\n\n    def on_step3(self, sender, e):\n        objects = rs.GetObjects(\"Select objects\", preselect=True)\n        if not objects:\n            return\n        excel_path = rs.OpenFileName(\"Select color Excel file\", \"Excel Files (*.xlsx)|*.xlsx||\",\n                                     folder=self.excel_folder if os.path.exists(self.excel_folder) else None)\n        if not excel_path:\n            return\n        # Launch Color Manager as modeless form\n        color_dlg = ColorManagerDialog(excel_path, objects)\n        color_dlg.Owner = Rhino.UI.RhinoEtoApp.MainWindow\n        color_dlg.Show()\n        self.status.Text = \"Step 3: Color Manager opened\"\n\n    def on_close(self, sender, e):\n        self.Close()\n\n\ndef main():\n    \"\"\"Main entry point\"\"\"\n    if not EXCEL_AVAILABLE:\n        print(\"=\"*60)\n        print(\"ERROR: openpyxl library is not installed\")\n        print(\"=\"*60)\n        print(\"\\nThis script requires the openpyxl library to work with Excel files.\")\n        print(\"Please install it using the following command:\\n\")\n        print(\"  pip install openpyxl\\n\")\n        print(\"If you're using Rhino 8's Python 3, you may need to:\")\n        print(\"  1. Open Windows Command Prompt (cmd)\")\n        print(\"  2. Navigate to Rhino's Python directory\")\n        print(\"  3. Run: python -m pip install openpyxl\")\n        print(\"=\"*60)\n        return\n\n    dialog = DataVisualizationTool()\n    dialog.Owner = Rhino.UI.RhinoEtoApp.MainWindow\n    dialog.Show()\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}