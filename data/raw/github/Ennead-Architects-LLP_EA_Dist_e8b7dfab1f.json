{
  "source_url": "https://github.com/Ennead-Architects-LLP/EA_Dist/blob/635520d89b8308b78eabf5b60bb80121d0fa3838/Apps/_rhino/View.tab/toggle_GFA.button/toggle_GFA_left.py",
  "repo": "Ennead-Architects-LLP/EA_Dist",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Apps/_rhino/View.tab/toggle_GFA.button/toggle_GFA_left.py",
  "instruction": "Toggle gfa left",
  "code": "# -*- coding: utf-8 -*-\r\n__title__ = \"ToggleGFA\"\r\n__doc__ = r\"\"\"Toggles Gross Floor Area (GFA) visualization and calculation.\r\n\r\nFeatures:\r\n- Processes layers marked with [GFA] to calculate and display area information\r\n- Real-time updates as geometry changes\r\n- Supports area factor multipliers using \\{factor\\} syntax in layer names\r\n- Excel data export capabilities\r\n- Automatic unit conversion (mm/m -> SQM, inch/ft -> SQFT)\r\n- Dynamic merging of coplanar surfaces at same elevation\r\n- Support for single surfaces and polysurfaces\r\n- Live comparison of how much is off from target.\r\n\r\nUsage:\r\n- Add [GFA] to layer names to include in calculation\r\n- Optional \\{factor\\} at end of layer name for area multipliers (e.g. \\{0.5\\})\r\n- Right-click to export to Excel or generate checking surfaces or set target area for each keyword.\r\n\"\"\"\r\n__is_popular__ = True\r\n\r\n\r\nimport re\r\nimport Rhino # pyright: ignore\r\nimport System # pyright: ignore\r\nimport scriptcontext as sc # pyright: ignore\r\nimport rhinoscriptsyntax as rs # pyright: ignore\r\nimport sys\r\nsys.path.append(\"..\\lib\")\r\n\r\nimport time\r\nimport random\r\n\r\n\r\nfrom EnneadTab import ERROR_HANDLE, LOG, NOTIFICATION, TIME, EXCEL\r\n\r\nfrom EnneadTab.RHINO import RHINO_LAYER, RHINO_OBJ_DATA, RHINO_PROJ_DATA\r\n\r\ndef try_catch_error(func):\r\n    \r\n    def wrapper(*args, **kwargs):\r\n\r\n        try:\r\n            out = func(*args, **kwargs)\r\n            return out\r\n        except Exception as e:\r\n            print ( str(e))\r\n            error = ERROR_HANDLE.get_alternative_traceback()\r\n            print (error)\r\n            if random.random() < 0.1:\r\n                NOTIFICATION.messenger(error)\r\n    return wrapper\r\n\r\n\r\nclass EA_GFA_Conduit(Rhino.Display.DisplayConduit):\r\n    \"\"\"Display conduit for real-time GFA visualization and calculation.\r\n    \r\n    Monitors document changes and updates area calculations automatically.\r\n    Handles layer changes, object modifications, additions and deletions.\r\n    \"\"\"\r\n    \r\n    def __init__(self):\r\n        self.data = []\r\n        self.cached_data = []\r\n        sc.sticky[\"EA_GFA_IS_BAKING\"] = False\r\n        sc.sticky[\"reset_timestamp\"] = time.time()\r\n        self.current_objs = get_current_objs()\r\n        \r\n        data = RHINO_PROJ_DATA.get_plugin_data()\r\n        self.target_dict = data.get(RHINO_PROJ_DATA.DocKeys.GFA_TARGET_DICT, {})\r\n\r\n\r\n\r\n       \r\n    @ERROR_HANDLE.try_catch_error()\r\n    def check_doc_update_after_adding(self,sender, e):\r\n        layer = sc.doc.Layers.FindIndex(e.TheObject.Attributes.LayerIndex)\r\n        if layer and layer.FullPath:\r\n            if \"[GFA]\" not in layer.FullPath:\r\n                return\r\n\r\n        # print(\"added\")\r\n        # This is added because a single action to any object will trigger\r\n        # replace-geo method, which is equal to delete and add in a very fast sequence.\r\n        # So to ensure cached data is cleared after, need to add this.\r\n        # If in future there is another hook that monitors direct modification or replace-geo event, use that instead.\r\n        self.cached_data = [] \r\n        self.reset_conduit_data(\"Document content changed, recalculating...\")\r\n  \r\n    @ERROR_HANDLE.try_catch_error()\r\n    def check_doc_updated_after_deleting(self,sender, e):\r\n        layer = sc.doc.Layers.FindIndex(e.TheObject.Attributes.LayerIndex)\r\n        if layer and layer.FullPath:\r\n            if \"[GFA]\" not in layer.FullPath:\r\n                return\r\n        \r\n        self.reset_conduit_data(\"Document content changed, recalculating...\")\r\n\r\n    @ERROR_HANDLE.try_catch_error()\r\n    def check_doc_updated_after_layertable_changed(self,sender, e):\r\n        layer = sc.doc.Layers.FindIndex(e.LayerIndex)\r\n        if layer and layer.FullPath:\r\n            if \"[GFA]\" not in layer.FullPath:\r\n                return\r\n        self.reset_conduit_data(\"Layer table changed, recalculating...\")\r\n\r\n    @ERROR_HANDLE.try_catch_error()\r\n    def check_doc_update_after_modifying(self,sender, e):\r\n        layer = sc.doc.Layers.FindIndex(e.NewAttributes.LayerIndex)\r\n        if layer and layer.FullPath:\r\n            if \"[GFA]\" not in layer.FullPath:\r\n                return\r\n        self.reset_conduit_data(\"Obj attribute modified, recalculating...\")\r\n    \r\n    \r\n    def reset_conduit_data(self, note=None):\r\n        \r\n        if time.time() - sc.sticky[\"reset_timestamp\"] < 2:\r\n            return\r\n        if note:\r\n            NOTIFICATION.messenger(note)\r\n        self.cached_data = []\r\n        self.current_objs = get_current_objs()\r\n        sc.sticky[\"reset_timestamp\"] = time.time()\r\n        # print (\"cached data is now empty\")\r\n        # self.is_reseted = True\r\n        self.target_dict = RHINO_PROJ_DATA.get_plugin_data().get(RHINO_PROJ_DATA.DocKeys.GFA_TARGET_DICT, {})   \r\n\r\n    \r\n    def add_hook(self):\r\n        Rhino.RhinoDoc.AddRhinoObject  += self.check_doc_update_after_adding\r\n        Rhino.RhinoDoc.DeleteRhinoObject  += self.check_doc_updated_after_deleting\r\n        Rhino.RhinoDoc.UndeleteRhinoObject   += self.check_doc_update_after_adding\r\n        Rhino.RhinoDoc.ModifyObjectAttributes  += self.check_doc_update_after_modifying\r\n        Rhino.RhinoDoc.LayerTableEvent   += self.check_doc_updated_after_layertable_changed\r\n        \r\n    def remove_hook(self):\r\n        Rhino.RhinoDoc.AddRhinoObject  -= self.check_doc_update_after_adding\r\n        Rhino.RhinoDoc.DeleteRhinoObject  -= self.check_doc_updated_after_deleting\r\n        Rhino.RhinoDoc.UndeleteRhinoObject   -= self.check_doc_update_after_adding\r\n        Rhino.RhinoDoc.ModifyObjectAttributes  -= self.check_doc_update_after_modifying\r\n        Rhino.RhinoDoc.LayerTableEvent   -= self.check_doc_updated_after_layertable_changed\r\n\r\n        \r\n    def get_layer_target(self, layer):\r\n        return next((value for key, value in self.target_dict.items() if key in layer), None)\r\n\r\n    @try_catch_error\r\n    def PostDrawObjects(self, e):\r\n        # Additional safety check for display object\r\n        if e is None or e.Display is None:\r\n            return\r\n            \r\n        if self.current_objs != get_current_objs():\r\n            self.reset_conduit_data(None)\r\n\r\n        if not self.cached_data:\r\n            try:\r\n                self.data = [(x, get_area_and_crv_geo_from_layer(x))   for x in get_schedule_layers()]\r\n                self.cached_data = self.data[:]\r\n            except Exception as ex:\r\n                print(\"Error getting schedule layers data: {}\".format(str(ex)))\r\n                return\r\n        else:\r\n            self.data = self.cached_data\r\n\r\n        for data in self.data:\r\n            layer, values = data\r\n            total_area, edges, faces, note = values\r\n\r\n            if not rs.IsLayer(layer):\r\n                print (\"!!!!!!!!!!!!!!!!!! This layer is no longer existing ....{}\".format(layer))\r\n                self.data.remove(data)\r\n                continue\r\n\r\n            color = rs.LayerColor(layer)\r\n            thickness = 10\r\n\r\n            for edge in edges:\r\n                try:\r\n                    if edge is not None:\r\n                        e.Display.DrawCurve(edge, color, thickness)\r\n                except Exception as ex:\r\n                    print(\"Error drawing edge in layer {}: {}\".format(layer, str(ex)))\r\n                    continue\r\n\r\n            for face in faces:\r\n                try:\r\n                    abstract_face = Rhino.Geometry.AreaMassProperties.Compute(face)\r\n                    if abstract_face:\r\n                        area = abstract_face.Area\r\n                        text = convert_area_to_good_unit(area)\r\n                        \r\n                        factor =  self.layer_factor(layer)\r\n                        if factor != 1:\r\n                            text = text + \" x {} = {}\".format(factor, convert_area_to_good_unit(area * factor))\r\n                        \r\n                        pt3D = abstract_face.Centroid\r\n                        e.Display.DrawDot(pt3D, text, color, System.Drawing.Color.White)\r\n                    else:\r\n                        print (\"!!! Check for geo cleanness in layer: \" + layer)\r\n                except Exception as ex:\r\n                    print (\"!!! Error processing face in layer {}: {}\".format(layer, str(ex)))\r\n                    continue\r\n\r\n    def layer_factor(self, layer):\r\n        # if layer name contain syntax such as 'abcd{0.5}' or 'xyz{0}', extract 0.5 and 0 as the factor.\r\n        # if no curly bracket is found, return 1.\r\n        pattern = re.compile(r\".*{(.*)}\")\r\n        match = pattern.search(layer)\r\n        if match:\r\n            try:\r\n                return float(match.group(1))\r\n            except:\r\n                return 1\r\n        return 1\r\n    \r\n    @try_catch_error\r\n    def DrawForeground(self, e):\r\n        # Additional safety check for display object\r\n        if e is None or e.Display is None:\r\n            return\r\n\r\n        \r\n        color = rs.CreateColor([87, 85, 83])\r\n        color_hightlight = rs.CreateColor([150, 85, 83])\r\n        backgroud_color = rs.CreateColor([240, 240, 240])\r\n        #color = System.Drawing.Color.Red\r\n        position_X_offset = 20\r\n        position_Y_offset = 40\r\n        size = 40\r\n        \r\n        # Check if viewport exists and has bounds\r\n        if e.Viewport is None or e.Viewport.Bounds is None:\r\n            return\r\n            \r\n        bounds = e.Viewport.Bounds\r\n        pt = Rhino.Geometry.Point2d(bounds.Left + position_X_offset, bounds.Top + position_Y_offset)\r\n\r\n\r\n        # background_rec = e.Display.DrawRoundedRectangle(Rhino.Geometry.Point2d(pt[0] + 50, pt[1] + 50),\r\n        #                                                 200,\r\n        #                                                 200,\r\n        #                                                 50,\r\n        #                                                 color_hightlight,\r\n        #                                                 3,\r\n        #                                                 backgroud_color)\r\n\r\n        \r\n        text = \"Ennead GFA Schedule Mode\"\r\n        e.Display.Draw2dText(text, color, pt, False, size)\r\n        \r\n        # Safe access to sticky data\r\n        reset_timestamp = sc.sticky.get(\"reset_timestamp\", time.time())\r\n        recent_time_text = TIME.get_formatted_time(reset_timestamp)\r\n        recent_time_text = \"Last data cache update: \" + recent_time_text\r\n        pt = Rhino.Geometry.Point2d(pt[0], pt[1] + 35)\r\n        e.Display.Draw2dText(recent_time_text, color, pt, False, 10)\r\n        pt = Rhino.Geometry.Point2d(pt[0], pt[1] + 15)\r\n        e.Display.Draw2dText(\"Including bracket [GFA] in layer name to allow scheduling.(Do not begin layer name with '[' bracket.)\", color, pt, False, 10)\r\n        pt = Rhino.Geometry.Point2d(pt[0], pt[1] + 10)\r\n        e.Display.Draw2dText(\"Including curly bracket {factor} at end of layer name to allow factor multiply, such as {0.5} or {0} or whatever.\", color_hightlight, pt, False, 10)\r\n        pt = Rhino.Geometry.Point2d(pt[0], pt[1] + 10)\r\n        e.Display.Draw2dText(\"Right-click the toggle button to bake data to Excel and/or generate checking srf.\", color, pt, False, 10)\r\n        pt = Rhino.Geometry.Point2d(pt[0], pt[1] + 10)\r\n        e.Display.Draw2dText(\"The generated checking srf will also show area text dot but will not be exported to Excel.\", color, pt, False, 10)\r\n        pt = Rhino.Geometry.Point2d(pt[0], pt[1] + 10)\r\n        e.Display.Draw2dText(\"For clarity, the generated checking srf layer will be purged.\", color, pt, False, 10)\r\n        pt = Rhino.Geometry.Point2d(pt[0], pt[1] + 15)\r\n        e.Display.Draw2dText(\"Area unit auto-mapped from your Rhino unit: mm--> m\" + u\"\\u00B2\" + \", m--> m\" + u\"\\u00B2\" + \", inch--> ft\" + u\"\\u00B2\" + \", ft--> ft\" + u\"\\u00B2\" + \"\", color_hightlight, pt, False, 10)\r\n        pt = Rhino.Geometry.Point2d(pt[0], pt[1] + 10)\r\n        e.Display.Draw2dText(\"Areas from same layer will try to merge dynamically if on same elevation.\", color_hightlight, pt, False, 10)\r\n        pt = Rhino.Geometry.Point2d(pt[0], pt[1] + 10)\r\n        e.Display.Draw2dText(\"Accepting single surface(Z+ or Z- normal) and polysurface(open or enclosed, only check the face with Z- normal). \", color, pt, False, 10)\r\n        pt = Rhino.Geometry.Point2d(pt[0], pt[1] + 10)\r\n        e.Display.Draw2dText(\"Target area can be set for each keyword in the right toggle button.\", color_hightlight, pt, False, 10)\r\n\r\n\r\n        pt = Rhino.Geometry.Point2d(pt[0], pt[1] + 10)\r\n        size = 20\r\n        offset = 20\r\n\r\n        grand_total = 0\r\n        #sub_title = \"X\" * 10\r\n        #sub_total = 0\r\n        \r\n        layer_used = []\r\n        for data in self.data:\r\n\r\n            layer, values = data\r\n            if not rs.IsLayer(layer):\r\n                print (\"!!!!!!!!!!!!!!!!!! This layer is no longer existing ....{}\".format(layer))\r\n                self.data.remove(data)\r\n                continue\r\n            \r\n\r\n\r\n            layer_tatal_area = values[0]\r\n            note = values[3]\r\n            #print note\r\n            if layer_tatal_area == 0:\r\n                continue\r\n            \r\n            factor =  self.layer_factor(layer)\r\n            if factor != 1:\r\n                layer_tatal_area *= factor\r\n\r\n            grand_total += layer_tatal_area\r\n            #sub_total += area\r\n            text = \"{}: {}\".format(RHINO_LAYER.rhino_layer_to_user_layer(layer), convert_area_to_good_unit(layer_tatal_area))\r\n            if note:\r\n                text += note\r\n            target = self.get_layer_target(layer)\r\n            diff = 0\r\n            if target:\r\n                area_num, area_unit = convert_area_to_good_unit(layer_tatal_area, use_commas = False).split(\" \", maxsplit = 1)\r\n                diff = float(target) - float(area_num)\r\n                text += \" (Target: {:,.2f}{})\".format(float(target), area_unit)\r\n                if diff != 0:\r\n                    text += \" [{:,.2f}{} {}]\".format(abs(diff), area_unit, \"over\" if diff < 0 else \"under\")\r\n            pt = Rhino.Geometry.Point2d(pt[0], pt[1] + offset)\r\n            color = rs.LayerColor(layer)\r\n            e.Display.Draw2dText(text, color, pt, False, size)\r\n            layer_used.append(layer)\r\n            \r\n            if diff:  # Only process if there's a difference\r\n                # Pre-calculate common values\r\n                temp_pt = Rhino.Geometry.Point2d(pt[0]-20, pt[1])\r\n                \r\n                if diff > 0:\r\n                    e.Display.Draw2dText(u\"\\u25BC\", \r\n                                       System.Drawing.Color.FromArgb(255, 145, 145),  # Soft red\r\n                                       temp_pt, \r\n                                       False, \r\n                                       size)\r\n                else:\r\n                    e.Display.Draw2dText(u\"\\u25B2\", \r\n                                       System.Drawing.Color.FromArgb(145, 255, 145),  # Soft green\r\n                                       temp_pt, \r\n                                       False, \r\n                                       size)\r\n \r\n\r\n            # draw curve from crv geo\r\n\r\n        for keyword in self.target_dict.keys():\r\n            for layer in layer_used:\r\n                if keyword in layer:\r\n                    break\r\n            else:   \r\n                pt = Rhino.Geometry.Point2d(pt[0], pt[1] + offset)\r\n                color = rs.CreateColor([250, 10, 10])\r\n                text = \"OOps! Missing keyworded area [{}], target: {}\".format(keyword, convert_area_to_good_unit(self.target_dict[keyword]))\r\n                e.Display.Draw2dText(text, color, pt, False, size)\r\n\r\n        pt = Rhino.Geometry.Point2d(pt[0], pt[1] + 25)\r\n        color = rs.CreateColor([87, 85, 83])\r\n        #print \"C\"\r\n        pt0 = System.Drawing.Point(pt[0], pt[1] )\r\n        pt1 = System.Drawing.Point(pt[0] + 500, pt[1] )\r\n        #print \"A\"\r\n        e.Display.Draw2dLine(pt0, pt1, color, 5)\r\n        #print \"B\"\r\n        pt = Rhino.Geometry.Point2d(pt[0], pt[1] + 10)\r\n        text = \"Grand Total Area: {}\".format(convert_area_to_good_unit(grand_total))\r\n        e.Display.Draw2dText(text, color, pt, False, 30)\r\n        #print \"drawingsssss finish\"\r\n\r\n\r\n\r\n\r\n        #print \"Done\"\r\n        # True = text centered around the defined pt, False = lower-left\r\n\r\n        root_layer = \"GFA Internal Check Srfs\"\r\n\r\n        if \"EA_GFA_IS_BAKING_EXCEL\" not in sc.sticky:\r\n            sc.sticky[\"EA_GFA_IS_BAKING_EXCEL\"] = False\r\n        \r\n        if sc.sticky[\"EA_GFA_IS_BAKING_EXCEL\"]:\r\n            import toggle_GFA_right\r\n            data_collection = []\r\n            row = 0\r\n            data_collection.append(EXCEL.ExcelDataItem(\"Layer\", row, \"A\", is_bold = True, text_alignment = EXCEL.TextAlignment.Center, cell_color = (200, 200, 200), \r\n                                                        top_border_style = EXCEL.BorderStyle.Thick,\r\n                                                        bottom_border_style = EXCEL.BorderStyle.Thick,\r\n                                                        side_border_style = EXCEL.BorderStyle.Thick))\r\n            data_collection.append(EXCEL.ExcelDataItem(\"Area\", row, \"B\", is_bold = True, text_alignment = EXCEL.TextAlignment.Center, cell_color = (200, 200, 200),\r\n                                                        top_border_style = EXCEL.BorderStyle.Thick,\r\n                                                        bottom_border_style = EXCEL.BorderStyle.Thick,\r\n                                                        side_border_style = EXCEL.BorderStyle.Thick,))\r\n            data_collection.append(EXCEL.ExcelDataItem(\"Unit\", row, \"C\", is_bold = True, text_alignment = EXCEL.TextAlignment.Center, cell_color = (200, 200, 200),\r\n                                                        top_border_style = EXCEL.BorderStyle.Thick,\r\n                                                        bottom_border_style = EXCEL.BorderStyle.Thick,\r\n                                                        side_border_style = EXCEL.BorderStyle.Thick))\r\n            row += 1\r\n\r\n            for data in self.data:\r\n                layer, values = data\r\n                if root_layer in layer:\r\n                    continue\r\n                area = values[0]\r\n                if area == 0:\r\n                    continue\r\n\r\n                factor =  self.layer_factor(layer)\r\n                if factor != 1:\r\n                    area *= factor\r\n                area = convert_area_to_good_unit(area, use_commas = False)\r\n                #print area\r\n                area_num, area_unit = area.split(\" \", maxsplit = 1)\r\n                #print area_num\r\n                layer = RHINO_LAYER.rhino_layer_to_user_layer(layer)\r\n                \r\n                cell_layer = EXCEL.ExcelDataItem(layer, row, \"A\", is_bold = True, bottom_border_style=EXCEL.BorderStyle.Thin)\r\n                cell_area = EXCEL.ExcelDataItem(float(area_num), row, \"B\", bottom_border_style=EXCEL.BorderStyle.Thin)\r\n                cell_unit = EXCEL.ExcelDataItem(area_unit, row, \"C\", bottom_border_style=EXCEL.BorderStyle.Thin)\r\n                data_collection.append(cell_layer)\r\n                data_collection.append(cell_area)\r\n                data_collection.append(cell_unit)\r\n                row += 1\r\n\r\n            toggle_GFA_right.bake_action(data_collection)\r\n            sc.sticky[\"EA_GFA_IS_BAKING_EXCEL\"] = False\r\n            \r\n\r\n        if \"EA_GFA_IS_BAKING_CRV\" not in sc.sticky:\r\n            sc.sticky[\"EA_GFA_IS_BAKING_CRV\"] = False\r\n        if sc.sticky[\"EA_GFA_IS_BAKING_CRV\"]:\r\n            if rs.IsLayer(root_layer):\r\n                purge_layer_and_sub_layers(root_layer)\r\n            for data in self.data:\r\n                layer, values = data\r\n                if root_layer in layer:\r\n                    continue\r\n                if values[0] == 0:\r\n                    continue\r\n\r\n\r\n                area, edges, faces, note = values\r\n                color = rs.LayerColor(layer)\r\n            \r\n                #attr = sc.doc.ObjectAttributes()\r\n                #attr.LayerIndex\r\n\r\n                \r\n                \r\n                data_layer = secure_layer(\"{}::{}\".format(root_layer, layer))\r\n\r\n                rs.LayerColor(data_layer, color)\r\n                #rs.DeleteObjects(rs.ObjectsByLayer(data_layer))\r\n                shapes = [sc.doc.Objects.AddBrep(face) for face in faces]\r\n                rs.ObjectLayer(shapes, data_layer)\r\n\r\n\r\n\r\n            sc.sticky[\"EA_GFA_IS_BAKING_CRV\"] = False\r\n            sc.doc.Views.Redraw()\r\n\r\n\r\n\r\n\r\n\r\ndef secure_layer(layer):\r\n    if not rs.IsLayer(layer):\r\n        rs.AddLayer(layer)\r\n    return layer\r\n\r\n\r\ndef purge_layer_and_sub_layers(root_layer):\r\n    if 0 != rs.LayerChildCount(root_layer):\r\n\r\n        for layer in rs.LayerChildren(root_layer):\r\n            purge_layer_and_sub_layers(layer)\r\n\r\n\r\n    rs.PurgeLayer(root_layer)\r\n    return\r\n    \r\n\r\n\r\ndef merge_as_crv_bool_union(breps):\r\n    try:\r\n        crvs = []\r\n        for x in breps:\r\n            try:\r\n                if x.Loops.Count > 0:\r\n                    crv = x.Loops[0].To3dCurve()\r\n                    if crv:\r\n                        crvs.append(crv)\r\n            except Exception as ex:\r\n                print(\"Error getting curve from brep: {}\".format(str(ex)))\r\n                continue\r\n                \r\n        if not crvs:\r\n            return None\r\n            \r\n        factors = [1, 1.5]\r\n        for factor in factors:\r\n            try:\r\n                union_crvs = Rhino.Geometry.Curve.CreateBooleanUnion(crvs, sc.doc.ModelAbsoluteTolerance * factor)\r\n                if union_crvs:\r\n                    union_breps = Rhino.Geometry.Brep.CreatePlanarBreps (union_crvs)\r\n                    return union_breps\r\n            except Exception as ex:\r\n                print(\"Error in curve boolean union with factor {}: {}\".format(factor, str(ex)))\r\n                continue\r\n        # print (\"Failed to boolean union as Curve. Returning original breps.\")\r\n        return None\r\n    except Exception as ex:\r\n        print(\"Error in merge_as_crv_bool_union: {}\".format(str(ex)))\r\n        return None\r\n\r\ndef merge_coplaner_srf(breps):\r\n    try:\r\n        for brep in breps:\r\n            try:\r\n                param = rs.SurfaceClosestPoint(brep, RHINO_OBJ_DATA.get_center(brep))\r\n                normal = rs.SurfaceNormal(brep, param)\r\n                if normal[2] < 0:\r\n                    brep.Flip()\r\n            except Exception as ex:\r\n                print(\"Error processing brep in merge_coplaner_srf: {}\".format(str(ex)))\r\n                continue\r\n\r\n        # print (\"original breps: \", breps)\r\n        factors = [1, 1.5]\r\n        for factor in factors:\r\n            try:\r\n                union_breps = Rhino.Geometry.Brep.CreateBooleanUnion(breps, sc.doc.ModelAbsoluteTolerance * factor, False)\r\n                if union_breps:\r\n                    # print (\"unioined breps: \", union_breps)\r\n                    break\r\n            except Exception as ex:\r\n                print(\"Error in boolean union with factor {}: {}\".format(factor, str(ex)))\r\n                continue\r\n        else:\r\n            # print (\"Failed to boolean union as Brep. Trying as Curve.\")\r\n            try:\r\n                union_breps = merge_as_crv_bool_union(breps)\r\n                if not union_breps:\r\n                    note = \" #Warning! Cannot merge coplanar faces. Check your geometry cleanness.\"\r\n                    return breps, note\r\n            except Exception as ex:\r\n                print(\"Error in merge_as_crv_bool_union: {}\".format(str(ex)))\r\n                note = \" #Warning! Cannot merge coplanar faces. Check your geometry cleanness.\"\r\n                return breps, note\r\n        #print breps\r\n        for brep in union_breps:\r\n            try:\r\n                success = brep.MergeCoplanarFaces(sc.doc.ModelAbsoluteTolerance, sc.doc.ModelAngleToleranceRadians * 1.5)\r\n                if not success:\r\n                    success = brep.MergeCoplanarFaces(sc.doc.ModelAbsoluteTolerance * 1.5, sc.doc.ModelAngleToleranceRadians * 3)\r\n            except Exception as ex:\r\n                print(\"Error merging coplanar faces: {}\".format(str(ex)))\r\n                continue\r\n\r\n        return union_breps, None\r\n    except Exception as ex:\r\n        print(\"Error in merge_coplaner_srf: {}\".format(str(ex)))\r\n        return breps, \" #Warning! Error in merge_coplaner_srf.\"\r\n\r\n# @lru_cache(maxsize=None)\r\ndef get_merged_data(faces):\r\n    height_dict = dict()\r\n    for face in faces:\r\n        try:\r\n            face = face.DuplicateFace (False)# this step turn brepface to brep\r\n            centroid_data = rs.SurfaceAreaCentroid(face)\r\n            if not centroid_data or not centroid_data[0]:\r\n                print(\"Warning: Could not get centroid for face\")\r\n                continue\r\n            z = centroid_data[0][2]\r\n\r\n            \"\"\"\r\n            need to put all 'similar' height to same key\r\n            \"\"\"\r\n            for h_key in height_dict.keys():\r\n                if abs(h_key - z) < sc.doc.ModelAbsoluteTolerance * 1.5:\r\n                    height_dict[h_key].append(face)\r\n                    break\r\n            else:\r\n                h_key = z\r\n                height_dict[h_key] = [face]\r\n        except Exception as ex:\r\n            print(\"Error processing face in get_merged_data: {}\".format(str(ex)))\r\n            continue\r\n\r\n        \"\"\"\r\n        if height_dict.has_key(h_key):\r\n            height_dict[h_key].append(face)\r\n        else:\r\n            height_dict[h_key] = [face]\r\n        \"\"\"\r\n    main_note = None\r\n    for h_key, faces in height_dict.items():\r\n        try:\r\n            #faces = [brepface_to_brep(x) for x in faces]\r\n            #height_dict[h_key] = merge_coplaner_srf(rs.BooleanUnion(faces, delete_input = False))\r\n            faces, note = merge_coplaner_srf(faces)\r\n            if note:\r\n                main_note = note\r\n            height_dict[h_key] = faces\r\n        except Exception as ex:\r\n            print(\"Error merging faces at height {}: {}\".format(h_key, str(ex)))\r\n            continue\r\n\r\n    out_faces = []\r\n    for faces in height_dict.values():\r\n        out_faces.extend(faces)\r\n    sum = 0\r\n    out_crvs = []\r\n    for face in out_faces:\r\n        try:\r\n            abstract_face = Rhino.Geometry.AreaMassProperties.Compute(face)\r\n            if abstract_face:\r\n                sum += abstract_face.Area\r\n            else:\r\n                main_note = \" #Warning!! Check your geometry cleanness.\"\r\n            out_crvs.extend(face.Edges )\r\n        except Exception as ex:\r\n            print(\"Error computing area for face: {}\".format(str(ex)))\r\n            continue\r\n\r\n\r\n    return sum, out_crvs, out_faces, main_note\r\n\r\n\r\ndef get_schedule_layers():\r\n    def is_good_layer(x):\r\n        if not \"[GFA]\" in x:\r\n            return False\r\n        if not rs.IsLayer(x):\r\n            return False\r\n        if not rs.IsLayerVisible(x):\r\n            return False\r\n        return True\r\n\r\n\r\n    try:\r\n        good_layers = filter(is_good_layer, RHINO_LAYER.get_layers_in_order())\r\n    except Exception as e:\r\n        good_layers = filter(is_good_layer, rs.LayerNames())\r\n\r\n    return good_layers\r\n\r\n\r\n\r\n\r\n#\"{:,}\".format(total_amount)\r\n# \"Total cost is: ${:,.2f}\".format(total_amount)\r\n# Total cost is: $10,000.00\r\ndef convert_area_to_good_unit(area, use_commas = True):\r\n    # only provide sqm or sqft, depeding on which system it is using. mm and m -->sqm, in, ft -->sqft\r\n\r\n    unit = rs.UnitSystemName(capitalize=False, singular=True, abbreviate=False, model_units=True)\r\n\r\n    def get_factor(unit):\r\n        if unit == \"millimeter\":\r\n            return 1.0/(1000**2), \"m\" + u\"\\u00B2\"\r\n        if unit == \"meter\":\r\n            return 1.0, \"m\" + u\"\\u00B2\"\r\n        if unit == \"inch\":\r\n            return 1.0/(12 * 12), \"ft\" + u\"\\u00B2\"\r\n        if unit == \"foot\":\r\n            return 1.0, \"ft\" + u\"\\u00B2\"\r\n        return 1.0, \"{0} x {0}\".format(unit)\r\n    factor, unit_text = get_factor(unit)\r\n\r\n    area *= factor\r\n    if use_commas:\r\n        return \"{:,.2f} {}\".format(area, unit_text)\r\n    else:\r\n        return \"{:.2f} {}\".format(area, unit_text)\r\n    pass\r\n\r\n\r\n\r\ndef get_current_objs():\r\n    temp = set()\r\n    layers = get_schedule_layers()\r\n    for layer in layers:\r\n        temp.update(get_objs_from_layer(layer))\r\n    return temp\r\n\r\n\r\ndef get_objs_from_layer(layer):\r\n    def is_good_obj(x):\r\n        if not (rs.IsPolysurface(x) or rs.IsSurface(x)):\r\n            return False\r\n        if rs.IsObjectHidden(x):\r\n            return False\r\n        return True\r\n    objs = rs.ObjectsByLayer(layer)\r\n    objs = filter(is_good_obj , objs)\r\n    \r\n    return objs\r\n\r\n\r\ndef get_area_and_crv_geo_from_layer(layer):\r\n\r\n    \r\n    objs = get_objs_from_layer(layer)\r\n\r\n    #print objs\r\n    sum_area = 0\r\n    crvs = []\r\n    out_faces = []\r\n    for obj in objs:\r\n\r\n\r\n        #print \"is polysurf\"\r\n        #prepare for the 2nd version to be faster\r\n        brep = rs.coercebrep(obj)\r\n        if not brep:\r\n            print (\"This layer [{}] has a non-brep object\".format(layer))\r\n            print (rs.ObjectType(obj))\r\n            key = \"EA_GFA_display_conduit\"\r\n            if sc.sticky.has_key(key):\r\n                conduit = sc.sticky[key]\r\n                conduit.reset_conduit_data()\r\n            continue\r\n        faces = brep.Faces\r\n\r\n        is_single_face = False\r\n        if faces.Count == 1:\r\n            is_single_face = True\r\n\r\n        for face in faces:\r\n            #print face\r\n            try:\r\n                if is_facing_down(face, allow_facing_up = is_single_face):\r\n                    #print \"get down face\"\r\n\r\n                    area_props = Rhino.Geometry.AreaMassProperties.Compute(face)\r\n                    if area_props:\r\n                        sum_area += area_props.Area\r\n\r\n                    #get crv geo but not add to doc\r\n                    crv_geo = get_crv_geo_from_surface(brep, face)\r\n\r\n                    crvs.extend(crv_geo)\r\n\r\n                    #face_geo = get_face_geo_from_face(brep, face)\r\n                    #print 123\r\n                    #print face\r\n                    #print face_geo\r\n                    #print 321\r\n                    out_faces.append(face)\r\n            except Exception as ex:\r\n                print(\"Error processing face in layer {}: {}\".format(layer, str(ex)))\r\n                continue\r\n\r\n\r\n\r\n\r\n    sum_area, edges, faces, note = get_merged_data(out_faces)\r\n\r\n    return sum_area, edges, faces, note\r\n\r\n\r\ndef brepface_to_brep(face):\r\n    face_id = face.SurfaceIndex\r\n    #print face_id\r\n    brep = face.Brep\r\n    surf = brep.Faces.ExtractFace(face_id)\r\n    #print surf\r\n    return surf\r\n\r\ndef get_face_geo_from_face(brep, face):\r\n    face_id = face.SurfaceIndex\r\n    #print face_id\r\n    surf = brep.Faces.ExtractFace(face_id)\r\n    #print surf\r\n    return surf\r\n\r\n\r\ndef get_crv_geo_from_surface(brep, face):\r\n    try:\r\n        edge_ids = face.AdjacentEdges()\r\n        #print edge_ids\r\n        #print brep.Edges\r\n        edges = [brep.Edges[x].EdgeCurve for x in list(edge_ids)]\r\n        #print edges\r\n        tolerance = sc.doc.ModelAbsoluteTolerance * 2.1\r\n        joined_crvs = Rhino.Geometry.Curve.JoinCurves(edges, tolerance)\r\n        return joined_crvs if joined_crvs else []\r\n    except Exception as ex:\r\n        print(\"Error getting curve geometry from surface: {}\".format(str(ex)))\r\n        return []\r\n\r\ndef is_facing_down(face, allow_facing_up = False):\r\n    try:\r\n        param = rs.SurfaceClosestPoint(face, RHINO_OBJ_DATA.get_center(face))\r\n        normal = rs.SurfaceNormal(face, param)\r\n        #print normal\r\n        Z_down = [0,0,-1]\r\n        #print rs.VectorAngle(normal, Z_down)\r\n        #print rs.VectorCrossProduct(normal, Z_down)\r\n        t = 0.001\r\n\r\n        # make quick check for upfacing single surface\r\n        if allow_facing_up:\r\n            Z_up = [0,0,1]\r\n            if -t < rs.VectorAngle(normal, Z_up) < t:\r\n                return True\r\n\r\n        if -t < rs.VectorAngle(normal, Z_down) < t:\r\n            return True\r\n        #if rs.VectorCrossProduct(normal, Z_down) < 0:\r\n            #return False\r\n        return False\r\n    except Exception as ex:\r\n        print(\"Error checking face orientation: {}\".format(str(ex)))\r\n        return False\r\n\r\n\r\n\r\n\r\n\r\n\r\n@LOG.log(__file__, __title__)\r\n@ERROR_HANDLE.try_catch_error()\r\ndef toggle_GFA():\r\n    conduit = None\r\n    key = \"EA_GFA_display_conduit\"\r\n    if sc.sticky.has_key(key):\r\n        conduit = sc.sticky[key]\r\n    else:\r\n        # create a conduit and place it in sticky\r\n        conduit = EA_GFA_Conduit()\r\n        sc.sticky[key] = conduit\r\n\r\n    # Toggle enabled state for conduit. Every time this script is\r\n    # run, it will turn the conduit on and off\r\n    conduit.Enabled = not conduit.Enabled\r\n    if conduit.Enabled: \r\n        conduit.add_hook()\r\n        try: # this is helpful so user resume conduit will trigger refresh, becasue user might be modifying the doc while the conduit is off.\r\n            conduit.reset_conduit_data()\r\n        except Exception as e:\r\n            print (e)\r\n        print (\"conduit enabled\")\r\n    else: \r\n        conduit.remove_hook()\r\n        print (\"conduit disabled\")\r\n    sc.doc.Views.Redraw()\r\n\r\n    print( \"Tool Finished\")\r\n\r\n\r\n\r\n    \r\nif __name__ == \"__main__\":\r\n    toggle_GFA()\r\n\r\n\r\n\r\n\r\n\r\n    \"\"\"\r\n    to-do:\r\n    right click to set desired GFA to each layer name, save to rhino doc data. and live compare how much is off from target.\r\n    \"\"\"\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}