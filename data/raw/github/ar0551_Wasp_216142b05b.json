{
  "source_url": "https://github.com/ar0551/Wasp/blob/66f63c018f2420d37aa451ade0178de260946b0c/src/ghComp/Wasp_Rules%20from%20Aggregation.py",
  "repo": "ar0551/Wasp",
  "repo_stars": 67,
  "repo_description": "Combinatorial Design with Grasshopper plug-in (LGPL) initiated by Andrea Rossi",
  "license": "LGPL-3.0",
  "filepath": "src/ghComp/Wasp_Rules from Aggregation.py",
  "instruction": "Extract aggregation rules from an aggregation. These can be used to recreate the aggregation using the Graph-Grammar Aggregation component, as well as to replace parts in an aggregation.\n-\nProvided...",
  "code": "# Wasp: Discrete Design with Grasshopper plug-in (LGPL) initiated by Andrea Rossi\n# \n# This file is part of Wasp.\n# \n# Copyright (c) 2017-2023, Andrea Rossi <a.rossi.andrea@gmail.com>\n# Wasp is free software; you can redistribute it and/or modify \n# it under the terms of the GNU Lesser General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Wasp is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU Lesser General Public License for more details.\n# \n# You should have received a copy of the GNU Lesser General Public License\n# along with Wasp; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license LGPL-3.0 https://www.gnu.org/licenses/lgpl-3.0.html\n#\n# Early development of Wasp has been carried out by Andrea Rossi\n# as part of research on digital materials and discrete design at:\n# DDU Digital Design Unit - Prof. Oliver Tessmann\n# Technische Universitt Darmstadt\n\n\n#########################################################################\n##                            COMPONENT INFO                           ##\n#########################################################################\n\n\"\"\"\nExtract aggregation rules from an aggregation. These can be used to recreate the aggregation using the Graph-Grammar Aggregation component, as well as to replace parts in an aggregation.\n-\nProvided by Wasp 0.6\n    Args:\n        AGGR: Aggregation from which to extract the rules\n        ON: OPTIONAL // If replacing parts, old names of the existing parts in the aggregation\n        NN: OPTIONAL // If replacing parts, new names of the parts to replace with. Order should match the order provided in ON\n    Returns:\n        GR: Graph rules to recreate the aggregation\n        PREV: If the provided aggregation contained parts assigned before the aggregation algorithm (in the PREV input), those parts are returned here. WARNING: when using a Graph Grammar Aggregation to replace parts, these parts will not be replaced.\n\"\"\"\n\nghenv.Component.Name = \"Wasp_Rules from Aggregation\"\nghenv.Component.NickName = 'GraphRules'\nghenv.Component.Message = 'v0.6.001'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"Wasp\"\nghenv.Component.SubCategory = \"3 | Rules\"\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"2\"\nexcept: pass\n\nimport sys\nimport Rhino.Geometry as rg\nimport Grasshopper as gh\nimport ghpythonlib.treehelpers as th\n\n\n## add Wasp install directory to system path\nwasp_loaded = False\nghcompfolder = gh.Folders.DefaultAssemblyFolder\nif ghcompfolder not in sys.path:\n    sys.path.append(ghcompfolder)\ntry:\n    from wasp import __version__\n    wasp_loaded = True\nexcept:\n    msg = \"Cannot import Wasp. Is the wasp folder available in \" + ghcompfolder + \"?\"\n    ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Error, msg)\n\n## if Wasp is installed correctly, load the classes required by the component\nif wasp_loaded:\n    from wasp.core import Aggregation, Graph\n\n\ndef main(aggregation, old_names, new_names):\n    \n    check_data = True\n    \n    ##check inputs\n    if aggregation is None:\n        check_data = False\n        msg = \"No aggregation provided\"\n        ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Warning, msg)\n    \n    if len(old_names) > 0:\n        if len(old_names) != len(new_names):\n            check_data = False\n            msg = \"Different number of old and new names provided\"\n            ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Error, msg)\n    \n    if check_data:\n        graph_rules = []\n        \n        replace_names = False\n        n_dict = {}\n        if len(old_names) > 0 and len(old_names) == len(new_names):\n            replace_names = True\n            for i in range(len(old_names)):\n                n_dict[old_names[i]] = new_names[i]\n        \n        ################################### if replacing parts, PREV input is currently not working\n        prev_parts = []\n        if aggregation.prev_num > 0:\n            prev_parts = aggregation.aggregated_parts[:aggregation.prev_num]\n        \n        graph_edges = aggregation.graph.get_edges_attributes()\n        \n        for edge in graph_edges:\n            start_p = aggregation.aggregated_parts[int(edge['start'])].name\n            end_p = aggregation.aggregated_parts[int(edge['end'])].name\n            start_conn = edge['conn_start']\n            end_conn = edge['conn_end']\n            \n            if replace_names:\n                start_p = n_dict[start_p]\n                end_p = n_dict[end_p]\n            \n            if len(graph_rules) == 0 and aggregation.prev_num == 0:\n                rule = \"{}|{}_{}|{}>{}_{}\".format(start_p, start_conn, end_p, end_conn, edge['start'], edge['end'])\n            else:\n                rule = \"{}|{}_{}|{}>{}_{}\".format(edge['start'], start_conn, end_p, end_conn, edge['start'], edge['end'])\n            \n            graph_rules.append(rule)\n            \n        return graph_rules, prev_parts\n        \n    else:\n        return -1\n\n\nresult = main(AGGR, ON, NN)\n\nif result != -1:\n    GR = result[0]\n    PREV = result[1]\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}