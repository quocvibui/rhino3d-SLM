{
  "source_url": "https://discourse.mcneel.com/t/search-results-with-best-result-score-sorting/182342",
  "topic_id": 182342,
  "title": "Search Results With \"Best Result\" Score Sorting?",
  "question": "Hello everyone!\n\n\nI’m working on a script in which I’m trying to search the Render Materials in the Rhino Document and return the Render Material names matching the search result and organize the results in order of “best match”\n\n\nIn example if the Rhino doc contains render materials named:\n\n“Oak redwood”, “Red Oak”, “Red Oak Polished”, “Polished Dark Oak”, “Red Tile Polished”, “Red Metal Polished”, “Red Corrugated Metal Polished”\n\n\nAnd I input search result:\n\n“oak”\n\n\nI expect Oak Redwood first as that is the “closest match”. This would be followed by Red Oak, then Red Oak Polished, and then lastly Polished Dark Oak.\n\n\nIf I input search result:\n\nRed Polished\n\n\nI would expect Red Oak Polished, Red Tile Polished, and Red Metal Polished to be equally weighted score wise and would probably sort alphabetically for “tie breakers”.\n\nI would expect Red Metal Polished to come before Red Corrugated Metal Polished.\n\n\nIf I input search result:\n\npolished oak\n\n\nI would expect Polished Dark Oak before Red Oak Polished.\n\n\nHere’s my code thus far, I tried to setup a scoring method based on the summation of “found words” but a bit stuck at the moment and curious if I am “overthinking” all of this and there is a method that already handles this kind of “best match” sorting?\n\n\nCode:\n\n\nimport scriptcontext\n\nsearch_text = \"oak polished\"\nsearch_limit = 3\n\n# Finds materials that are actively in the model and match the search text partially and case-insensitively\ndef FindMaterialsByPartialName(mat_name, limit):\n    mat_table = scriptcontext.doc.Materials\n    render_mat_table = scriptcontext.doc.RenderMaterials\n    matched_materials = {}\n    matched_render_materials = {}\n\n    search_words = mat_name.lower().split()  # Split search text into individual words\n\n    # Search for regular materials\n    for i in range(mat_table.Count):\n        mat = mat_table[i]\n        # Check if the material is in use by any objects\n        in_use = False\n        for obj in scriptcontext.doc.Objects:\n            ...",
  "code_blocks": [
    {
      "code": "import scriptcontext\n\nsearch_text = \"oak polished\"\nsearch_limit = 3\n\n# Finds materials that are actively in the model and match the search text partially and case-insensitively\ndef FindMaterialsByPartialName(mat_name, limit):\n    mat_table = scriptcontext.doc.Materials\n    render_mat_table = scriptcontext.doc.RenderMaterials\n    matched_materials = {}\n    matched_render_materials = {}\n\n    search_words = mat_name.lower().split()  # Split search text into individual words\n\n    # Search for regular materials\n    for i in range(mat_table.Count):\n        mat = mat_table[i]\n        # Check if the material is in use by any objects\n        in_use = False\n        for obj in scriptcontext.doc.Objects:\n            if obj.Attributes.MaterialIndex == i:\n                in_use = True\n                break\n        if not in_use:\n            continue\n\n        # Calculate the score based on the number of matched words\n        score = sum(word in mat.Name.lower() for word in search_words)\n\n        # Check for partial and case-insensitive match with any of the search words\n        if score > 0:\n            if mat.Name in matched_materials:\n                matched_materials[mat.Name].append((i, score))\n            else:\n                matched_materials[mat.Name] = [(i, score)]\n\n    # Search for render materials\n    for i in range(render_mat_table.Count):\n        render_mat = render_mat_table[i]\n        # Calculate the score based on the number of matched words\n        score = sum(word in render_mat.Name.lower() for word in search_words)\n\n        # Check for partial and case-insensitive match with any of the search words\n        if score > 0:\n            render_mat_name = f\"{render_mat.Name}\"\n            if render_mat_name in matched_render_materials:\n                matched_render_materials[render_mat_name].append((i, score))\n            else:\n                matched_render_materials[render_mat_name] = [(i, score)]\n\n    # Print render materials found\n    if matched_render_materials:\n        print(\"RENDER MATERIALS:\")\n        count = 0\n        # Sort render materials based on score before printing\n        for mat_name, indices in sorted(matched_render_materials.items(), key=lambda x: max(x[1], key=lambda y: y[1]), reverse=True):\n            if count >= limit:\n                break\n            indices_str = ','.join(str(index[0]) for index in indices)\n            print(\"{0} found at Render Mat List[{1}]\".format(mat_name, indices_str))\n            count += 1\n    else:\n        print(\"No render materials matching '{}' found\".format(mat_name))\n\nif __name__ == \"__main__\":\n    FindMaterialsByPartialName(search_text, search_limit)",
      "language": "python",
      "author": "michaelvollrath",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "materials",
    "python"
  ],
  "has_accepted_answer": true,
  "category_id": 3,
  "posts_count": 5,
  "views": 186
}