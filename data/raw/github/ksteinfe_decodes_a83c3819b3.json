{
  "source_url": "https://github.com/ksteinfe/decodes/blob/b876d6d01ea23ccbf4558182582a822b008cf2b8/src/decodes/io/rhinoscript/surface.py",
  "repo": "ksteinfe/decodes",
  "repo_stars": 43,
  "repo_description": "a platform agnostic generative design library for 3d designers",
  "license": "GPL-3.0",
  "filepath": "src/decodes/io/rhinoscript/surface.py",
  "instruction": "Surface",
  "code": "import scriptcontext\nimport math\nimport Rhino\nimport System.Guid\nfrom . import utility as rhutil\nfrom . import object as rhobject\n\ndef AddBox(corners):\n    \"\"\"Adds a new box shaped polysurface to the document\n    Parameters:\n      corners = 8 3D points that define the corners of the box. Points need to\n        be in counter-clockwise order starting with the bottom rectangle of the box\n    Returns:\n      identifier of the new object on success\n    \"\"\"\n    box = rhutil.coerce3dpointlist(corners, True)\n    brep = Rhino.Geometry.Brep.CreateFromBox(box)\n    if brep is None: raise ValueError(\"unable to create brep from box\")\n    rc = scriptcontext.doc.Objects.AddBrep(brep)\n    if rc==System.Guid.Empty: raise Exception(\"unable to add brep to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCone(base, height, radius, cap=True):\n    \"\"\"Adds a cone shaped polysurface to the document\n    Parameters:\n      base = 3D origin point of the cone or a plane with an apex at the origin\n          and normal along the plane's z-axis\n      height = 3D height point of the cone if base is a 3D point. The height\n          point defines the height and direction of the cone. If base is a\n          plane, height is a numeric value\n      radius = the radius at the base of the cone\n      cap [opt] = cap base of the cone\n    Returns:\n      identifier of the new object on success\n    \"\"\"\n    plane = None\n    height_point = rhutil.coerce3dpoint(height)\n    if height_point is None:\n        plane = rhutil.coerceplane(base, True)\n    else:\n        base_point = rhutil.coerce3dpoint(base, True)\n        normal = base_point - height_point\n        height = normal.Length\n        plane = Rhino.Geometry.Plane(height_point, normal)\n    cone = Rhino.Geometry.Cone(plane, height, radius)\n    brep = Rhino.Geometry.Brep.CreateFromCone(cone, cap)\n    rc = scriptcontext.doc.Objects.AddBrep(brep)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCutPlane(object_ids, start_point, end_point, normal=None):\n    \"\"\"Adds a planar surface through objects at a designated location. For more\n    information, see the Rhino help file for the CutPlane command\n    Parameters:\n      objects_ids = identifiers of objects that the cutting plane will\n          pass through\n      start_point, end_point = line that defines the cutting plane\n      normal[opt] = vector that will be contained in the returned planar\n          surface. In the case of Rhino's CutPlane command, this is the\n          normal to, or Z axis of, the active view's construction plane.\n          If omitted, the world Z axis is used\n    Returns:\n      identifier of new object on success\n      None on error\n    \"\"\"\n    objects = []\n    bbox = Rhino.Geometry.BoundingBox.Unset\n    for id in object_ids:\n        rhobj = rhutil.coercerhinoobject(id, True, True)\n        geometry = rhobj.Geometry\n        bbox.Union( geometry.GetBoundingBox(True) )\n    start_point = rhutil.coerce3dpoint(start_point, True)\n    end_point = rhutil.coerce3dpoint(end_point, True)\n    if not bbox.IsValid: return scriptcontext.errorhandler()\n    line = Rhino.Geometry.Line(start_point, end_point)\n    if normal: normal = rhutil.coerce3dvector(normal, True)\n    else: normal = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane().Normal\n    surface = Rhino.Geometry.PlaneSurface.CreateThroughBox(line, normal, bbox)\n    if surface is None: return scriptcontext.errorhandler()\n    id = scriptcontext.doc.Objects.AddSurface(surface)\n    if id==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return id\n\n\ndef AddCylinder(base, height, radius, cap=True):\n    \"\"\"Adds a cylinder-shaped polysurface to the document\n    Parameters:\n      base = The 3D base point of the cylinder or the base plane of the cylinder\n      height = if base is a point, then height is a 3D height point of the\n        cylinder. The height point defines the height and direction of the\n        cylinder. If base is a plane, then height is the numeric height value\n        of the cylinder\n      radius = radius of the cylinder\n      cap[opt] = cap the cylinder\n    Returns:\n      identifier of new object if successful\n      None on error\n    \"\"\"\n    cylinder=None\n    height_point = rhutil.coerce3dpoint(height)\n    if height_point:\n        #base must be a point\n        base = rhutil.coerce3dpoint(base, True)\n        normal = height_point-base\n        plane = Rhino.Geometry.Plane(base, normal)\n        height = normal.Length\n        circle = Rhino.Geometry.Circle(plane, radius)\n        cylinder = Rhino.Geometry.Cylinder(circle, height)\n    else:\n        #base must be a plane\n        if type(base) is Rhino.Geometry.Point3d: base = [base.X, base.Y, base.Z]\n        base = rhutil.coerceplane(base, True)\n        circle = Rhino.Geometry.Circle(base, radius)\n        cylinder = Rhino.Geometry.Cylinder(circle, height)\n    brep = cylinder.ToBrep(cap, cap)\n    id = scriptcontext.doc.Objects.AddBrep(brep)\n    if id==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return id\n\n\ndef AddEdgeSrf(curve_ids):\n    \"\"\"Creates a surface from 2, 3, or 4 edge curves\n    Parameters:\n      curve_ids = list or tuple of curves\n    Returns:\n      identifier of new object if successful\n      None on error\n    \"\"\"\n    curves = [rhutil.coercecurve(id, -1, True) for id in curve_ids]\n    brep = Rhino.Geometry.Brep.CreateEdgeSurface(curves)\n    if brep is None: return scriptcontext.errorhandler()\n    id = scriptcontext.doc.Objects.AddBrep(brep)\n    if id==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return id\n\n\ndef AddNurbsSurface(point_count, points, knots_u, knots_v, degree, weights=None):\n    \"\"\"Adds a NURBS surface object to the document\n    Parameters:\n      point_count = number of control points in the u and v direction\n      points = list of 3D points\n      knots_u = knot values for the surface in the u direction.\n                Must contain point_count[0]+degree[0]-1 elements\n      knots_v = knot values for the surface in the v direction.\n                Must contain point_count[1]+degree[1]-1 elements\n      degree = degree of the surface in the u and v directions.\n      weights[opt] = weight values for the surface. The number of elements in\n        weights must equal the number of elements in points. Values must be\n        greater than zero.\n    Returns:\n      identifier of new object if successful\n      None on error\n    \"\"\"\n    if len(points)<(point_count[0]*point_count[1]):\n        return scriptcontext.errorhandler()\n    ns = Rhino.Geometry.NurbsSurface.Create(3, weights!=None, degree[0]+1, degree[1]+1, point_count[0], point_count[1])\n    #add the points and weights\n    controlpoints = ns.Points\n    index = 0\n    for i in range(point_count[0]):\n        for j in range(point_count[1]):\n            if weights:\n                cp = Rhino.Geometry.ControlPoint(points[index], weights[index])\n                controlpoints.SetControlPoint(i,j,cp)\n            else:\n                cp = Rhino.Geometry.ControlPoint(points[index])\n                controlpoints.SetControlPoint(i,j,cp)\n            index += 1\n    #add the knots\n    for i in range(ns.KnotsU.Count): ns.KnotsU[i] = knots_u[i]\n    for i in range(ns.KnotsV.Count): ns.KnotsV[i] = knots_v[i]\n    if not ns.IsValid: return scriptcontext.errorhandler()\n    id = scriptcontext.doc.Objects.AddSurface(ns)\n    if id==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return id\n\n\ndef AddPlanarSrf(object_ids):\n    \"\"\"Creates one or more surfaces from planar curves\n    Parameters:\n      object_ids = identifiers of curves to use for creating planar surfaces\n    Returns:\n      list of surfaces created on success\n      None on error\n    \"\"\"\n    id = rhutil.coerceguid(object_ids, False)\n    if id: object_ids = [id]\n    curves = [rhutil.coercecurve(id,-1,True) for id in object_ids]\n    breps = Rhino.Geometry.Brep.CreatePlanarBreps(curves)\n    rc = [scriptcontext.doc.Objects.AddBrep(brep) for brep in breps]\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddPlaneSurface(plane, u_dir, v_dir):\n    \"\"\"Creates a plane surface and adds it to the document.\n    Parameters:\n      plane = The plane.\n      u_dir = The magnitude in the U direction.\n      v_dir = The magnitude in the V direction.\n    Returns:\n      The identifier of the new object if successful.\n      None if not successful, or on error.\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    u_interval = Rhino.Geometry.Interval(0, u_dir)\n    v_interval = Rhino.Geometry.Interval(0, v_dir)\n    plane_surface = Rhino.Geometry.PlaneSurface(plane, u_interval, v_interval) \n    if plane_surface is None: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddSurface(plane_surface)\n    if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddLoftSrf(object_ids, start=None, end=None, loft_type=0, simplify_method=0, value=0, closed=False):\n    \"\"\"Adds a surface created by lofting curves to the document.\n    - no curve sorting performed. pass in curves in the order you want them sorted\n    - directions of open curves not adjusted. Use CurveDirectionsMatch and\n      ReverseCurve to adjust the directions of open curves\n    - seams of closed curves are not adjusted. Use CurveSeam to adjust the seam\n      of closed curves\n    Parameters:\n      object_ids = ordered list of object identifiers for the curves to loft through\n      start [opt] = starting point of the loft\n      end [opt] = ending point of the loft\n      loft_type [opt] = type of loft. Possible options are:\n        0 = Normal. Uses chord-length parameterization in the loft direction\n        1 = Loose. The surface is allowed to move away from the original curves\n            to make a smoother surface. The surface control points are created\n            at the same locations as the control points of the loft input curves.\n        2 = Straight. The sections between the curves are straight. This is\n            also known as a ruled surface.\n        3 = Tight. The surface sticks closely to the original curves. Uses square\n            root of chord-length parameterization in the loft direction\n        4 = Developable. Creates a separate developable surface or polysurface\n            from each pair of curves.\n      simplify_method [opt] = Possible options are:\n        0 = None. Does not simplify.\n        1 = Rebuild. Rebuilds the shape curves before lofting.\n        2 = Refit. Refits the shape curves to a specified tolerance\n      value [opt] = A value based on the specified style.\n        style=1 (Rebuild), then value is the number of control point used to rebuild\n        style=1 is specified and this argument is omitted, then curves will be\n        rebuilt using 10 control points.\n        style=2 (Refit), then value is the tolerance used to rebuild.\n        style=2 is specified and this argument is omitted, then the document's\n        absolute tolerance us used for refitting.\n    Returns:\n      An array containing the identifiers of the new surface objects if successful\n      None on error\n    \"\"\"\n    if loft_type<0 or loft_type>5: raise ValueError(\"loft_type must be 0-4\")\n    if simplify_method<0 or simplify_method>2: raise ValueError(\"simplify_method must be 0-2\")\n\n    # get set of curves from object_ids\n    curves = [rhutil.coercecurve(id,-1,True) for id in object_ids]\n    if len(curves)<2: return scriptcontext.errorhandler()\n    if start is None: start = Rhino.Geometry.Point3d.Unset\n    if end is None: end = Rhino.Geometry.Point3d.Unset\n    start = rhutil.coerce3dpoint(start, True)\n    end = rhutil.coerce3dpoint(end, True)\n    \n    lt = Rhino.Geometry.LoftType.Normal\n    if loft_type==1: lt = Rhino.Geometry.LoftType.Loose\n    elif loft_type==2: lt = Rhino.Geometry.LoftType.Straight\n    elif loft_type==3: lt = Rhino.Geometry.LoftType.Tight\n    elif loft_type==4: lt = Rhino.Geometry.LoftType.Developable\n\n    breps = None\n    if simplify_method==0:\n        breps = Rhino.Geometry.Brep.CreateFromLoft(curves, start, end, lt, closed)\n    elif simplify_method==1:\n        value = abs(value)\n        rebuild_count = int(value)\n        breps = Rhino.Geometry.Brep.CreateFromLoftRebuild(curves, start, end, lt, closed, rebuild_count)\n    elif simplify_method==2:\n        refit = abs(value)\n        if refit==0: refit = scriptcontext.doc.ModelAbsoluteTolerance\n        breps = Rhino.Geometry.Brep.CreateFromLoftRefit(curves, start, end, lt, closed, refit)\n    if not breps: return scriptcontext.errorhandler()\n\n    idlist = []\n    for brep in breps:\n        id = scriptcontext.doc.Objects.AddBrep(brep)\n        if id!=System.Guid.Empty: idlist.append(id)\n    if idlist: scriptcontext.doc.Views.Redraw()\n    return idlist\n\n\ndef AddRevSrf(curve_id, axis, start_angle=0.0, end_angle=360.0):\n    \"\"\"Creates a surface by revolving a curve around an axis\n    Parameters:\n      curve_id = identifier of profile curve\n      axis = line for the rail revolve axis\n      start_angle[opt], end_angle[opt] = start and end angles of revolve\n    Returns:\n      identifier of new object if successful\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    axis = rhutil.coerceline(axis, True)\n    start_angle = math.radians(start_angle)\n    end_angle = math.radians(end_angle)\n    srf = Rhino.Geometry.RevSurface.Create(curve, axis, start_angle, end_angle)\n    if not srf: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddSurface(srf)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSphere(center_or_plane, radius):\n    \"\"\"Adds a spherical surface to the document\n    Parameters:\n      center_or_plane = center point of the sphere. If a plane is input,\n        the origin of the plane will be the center of the sphere\n      radius = radius of the sphere in the current model units\n    Returns:\n      intentifier of the new object on success\n      None on error\n    \"\"\"\n    center = rhutil.coerce3dpoint(center_or_plane)\n    if center is None:\n        plane = rhutil.coerceplane(center_or_plane, True)\n        center = plane.Origin\n    sphere = Rhino.Geometry.Sphere(center, radius)\n    rc = scriptcontext.doc.Objects.AddSphere(sphere)\n    if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSrfContourCrvs(object_id, points_or_plane, interval=None):\n    \"\"\"Adds a spaced series of planar curves resulting from the intersection of\n    defined cutting planes through a surface or polysurface. For more\n    information, see Rhino help for details on the Contour command\n    Parameters:\n      object_id = object identifier\n      points_or_plane = either a list/tuple of two points or a plane\n        if two points, they define the start and end points of a center line\n        if a plane, the plane defines the cutting plane\n      interval[opt] = distance beween contour curves.\n    Returns:\n      ids of new curves on success\n      None on error\n    \"\"\"\n    brep = rhutil.coercebrep(object_id)\n    plane = rhutil.coerceplane(points_or_plane)\n    curves = None\n    if plane:\n        curves = Rhino.Geometry.Brep.CreateContourCurves(brep, plane)\n    else:\n        start = rhutil.coerce3dpoint(points_or_plane[0], True)\n        end = rhutil.coerce3dpoint(points_or_plane[1], True)\n        if not interval:\n            bbox = brep.GetBoundingBox(True)\n            v = bbox.Max - bbox.Min\n            interval = v.Length / 50.0\n        curves = Rhino.Geometry.Brep.CreateContourCurves(brep, start, end, interval)\n    rc = []\n    for crv in curves:\n        id = scriptcontext.doc.Objects.AddCurve(crv)\n        if id!=System.Guid.Empty: rc.append(id)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSrfControlPtGrid(count, points, degree=(3,3)):\n    \"\"\"Creates a surface from a grid of points\n    Parameters:\n      count = tuple of two numbers defining number of points in the u,v directions\n      points = list of 3D points\n      degree[opt] = two numbers defining degree of the surface in the u,v directions\n    Returns:\n      The identifier of the new object if successful.\n      None if not successful, or on error.\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    surf = Rhino.Geometry.NurbsSurface.CreateFromPoints(points, count[0], count[1], degree[0], degree[1])\n    if surf is None: return scritpcontext.errorhandler()\n    id = scriptcontext.doc.Objects.AddSurface(surf)\n    if id!=System.Guid.Empty:\n        scriptcontext.doc.Views.Redraw()\n        return id\n    return scriptcontext.errorhandler()\n\n\ndef AddSrfPt(points):\n    \"\"\"Creates a new surface from either 3 or 4 control points.\n    Parameters:\n      points = list of either 3 or 4 control points\n    Returns\n      The identifier of the new object if successful.\n      None if not successful, or on error.\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    surface=None\n    if len(points)==3:\n        surface = Rhino.Geometry.NurbsSurface.CreateFromCorners(points[0], points[1], points[2])\n    elif len(points)==4:\n        surface = Rhino.Geometry.NurbsSurface.CreateFromCorners(points[0], points[1], points[2], points[3])\n    if surface is None: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddSurface(surface)\n    if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddTorus(base, major_radius, minor_radius, direction=None):\n    \"\"\"Adds a torus shaped revolved surface to the document\n    Parameters:\n      base = 3D origin point of the torus or the base plane of the torus\n      major_radius, minor_radius = the two radii of the torus\n      directions[opt] = A point that defines the direction of the torus when base is a point.\n        If omitted, a torus that is parallel to the world XY plane is created\n    Returns:\n      The identifier of the new object if successful.\n      None if not successful, or on error.\n    \"\"\"\n    baseplane = None\n    basepoint = rhutil.coerce3dpoint(base)\n    if basepoint is None:\n        baseplane = rhutil.coerceplane(base, True)\n        if direction!=None: return scriptcontext.errorhandler()\n    if baseplane is None:\n        direction = rhutil.coerce3dpoint(direction, True)\n        if direction: direction = direction-basepoint\n        else: direction = Rhino.Geometry.Vector3d.ZAxis\n        baseplane = Rhino.Geometry.Plane(basepoint, direction)\n    torus = Rhino.Geometry.Torus(baseplane, major_radius, minor_radius)\n    revsurf = torus.ToRevSurface()\n    rc = scriptcontext.doc.Objects.AddSurface(revsurf)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef BooleanDifference(input0, input1, delete_input=True):\n    \"\"\"Performs a boolean difference operation on two sets of input surfaces\n    and polysurfaces. For more details, see the BooleanDifference command in\n    the Rhino help file\n    Parameters:\n        input0 = list of surfaces to subtract from\n        input1 = list of surfaces to be subtracted\n        delete_input[opt] = delete all input objects\n    Returns:\n        list of identifiers of newly created objects on success\n        None on error\n    \"\"\"\n    if type(input0) is list or type(input0) is tuple: pass\n    else: input0 = [input0]\n    \n    if type(input1) is list or type(input1) is tuple: pass\n    else: input1 = [input1]\n\n    breps0 = [rhutil.coercebrep(id, True) for id in input0]\n    breps1 = [rhutil.coercebrep(id, True) for id in input1]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newbreps = Rhino.Geometry.Brep.CreateBooleanDifference(breps0, breps1, tolerance)\n    if newbreps is None: return scriptcontext.errorhandler()\n    \n    rc = [scriptcontext.doc.Objects.AddBrep(brep) for brep in newbreps]\n    if delete_input:\n        for id in input0: scriptcontext.doc.Objects.Delete(id, True)\n        for id in input1: scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef BooleanIntersection(input0, input1, delete_input=True):\n    \"\"\"Performs a boolean intersection operation on two sets of input surfaces\n    and polysurfaces. For more details, see the BooleanIntersection command in\n    the Rhino help file\n    Parameters:\n        input0 = list of surfaces\n        input1 = list of surfaces\n        delete_input[opt] = delete all input objects\n    Returns:\n        list of identifiers of newly created objects on success\n        None on error\n    \"\"\"\n    if type(input0) is list or type(input0) is tuple: pass\n    else: input0 = [input0]\n    \n    if type(input1) is list or type(input1) is tuple: pass\n    else: input1 = [input1]\n\n    breps0 = [rhutil.coercebrep(id, True) for id in input0]\n    breps1 = [rhutil.coercebrep(id, True) for id in input1]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newbreps = Rhino.Geometry.Brep.CreateBooleanIntersection(breps0, breps1, tolerance)\n    if newbreps is None: return scriptcontext.errorhandler()\n    rc = [scriptcontext.doc.Objects.AddBrep(brep) for brep in newbreps]\n    if delete_input:\n        for id in input0: scriptcontext.doc.Objects.Delete(id, True)\n        for id in input1: scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef BooleanUnion(input, delete_input=True):\n    \"\"\"Performs a boolean union operation on a set of input surfaces and\n    polysurfaces. For more details, see the BooleanUnion command in the\n    Rhino help file\n    Parameters:\n        input = list of surfaces to union\n        delete_input[opt] = delete all input objects\n    Returns:\n        list of identifiers of newly created objects on success\n        None on error\n    \"\"\"\n    if len(input)<2: return scriptcontext.errorhandler()\n    breps = [rhutil.coercebrep(id, True) for id in input]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newbreps = Rhino.Geometry.Brep.CreateBooleanUnion(breps, tolerance)\n    if newbreps is None: return scriptcontext.errorhandler()\n    \n    rc = [scriptcontext.doc.Objects.AddBrep(brep) for brep in newbreps]\n    if delete_input:\n        for id in input: scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef BrepClosestPoint(object_id, point):\n    \"\"\"Returns the point on a surface or polysurface that is closest to a test\n    point. This function works on both untrimmed and trimmed surfaces.\n    Parameters:\n      object_id = The object's identifier.\n      point = The test, or sampling point.\n    Returns:\n      A tuple of closest point information if successful. The list will\n      contain the following information:\n      Element     Type             Description\n         0        Point3d          The 3-D point at the parameter value of the \n                                   closest point.\n         1        (U, V)           Parameter values of closest point. Note, V \n                                   is 0 if the component index type is brep_edge\n                                   or brep_vertex. \n         2        (type, index)    The type and index of the brep component that\n                                   contains the closest point. Possible types are\n                                   brep_face, brep_edge or brep_vertex.\n         3        Vector3d         The normal to the brep_face, or the tangent\n                                   to the brep_edge.  \n      None if not successful, or on error.\n    \"\"\"\n    brep = rhutil.coercebrep(object_id, True)\n    point = rhutil.coerce3dpoint(point, True)\n    rc = brep.ClosestPoint(point, 0.0)\n    if rc[0]:\n        type = int(rc[2].ComponentIndexType)\n        index = rc[2].Index\n        return rc[1], (rc[3], rc[4]), (type, index), rc[5]\n\n\ndef CapPlanarHoles(surface_id):\n    \"\"\"Caps planar holes in a surface or polysurface\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    brep = rhutil.coercebrep(surface_id, True)\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newbrep = brep.CapPlanarHoles(tolerance)\n    if newbrep:\n        surface_id = rhutil.coerceguid(surface_id)\n        if surface_id and scriptcontext.doc.Objects.Replace(surface_id, newbrep):\n            scriptcontext.doc.Views.Redraw()\n            return True\n    return False\n\n\ndef DuplicateEdgeCurves(object_id, select=False):\n    \"\"\"Duplicates the edge curves of a surface or polysurface. For more\n    information, see the Rhino help file for information on the DupEdge\n    command.\n    Parameters:\n      object_id = The identifier of the surface or polysurface object.\n      select [opt] = Select the duplicated edge curves. The default is not\n      to select (False).\n    Returns:\n      A list of Guids identifying the newly created curve objects if successful.\n      None if not successful, or on error.\n    \"\"\"\n    brep = rhutil.coercebrep(object_id, True)\n    out_curves = brep.DuplicateEdgeCurves()\n    curves = []\n    for curve in out_curves:\n        if curve.IsValid:\n            rc = scriptcontext.doc.Objects.AddCurve(curve)\n            curve.Dispose()\n            if rc==System.Guid.Empty: return None\n            curves.append(rc)\n            if select: rhobject.SelectObject(rc)\n    if curves: scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef DuplicateSurfaceBorder(surface_id):\n    \"\"\"Creates a curve that duplicates a surface or polysurface border\n    Parameters:\n      surface_id = identifier of a surface\n    Returns:\n      list of curve ids on success\n      None on error\n    \"\"\"\n    brep = rhutil.coercebrep(surface_id, True)\n    curves = brep.DuplicateEdgeCurves(True)\n    if curves is None: return scriptcontext.errorhandler()\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance * 2.1\n    curves = Rhino.Geometry.Curve.JoinCurves(curves, tolerance)\n    if curves is None: return scriptcontext.errorhandler()\n    rc = [scriptcontext.doc.Objects.AddCurve(c) for c in curves]\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef EvaluateSurface(surface_id, u, v):\n    \"Evaluates a surface at a U,V parameter\"\n    surface = rhutil.coercesurface(surface_id, True)\n    rc = surface.PointAt(u,v)\n    if rc.IsValid: return rc\n    return scriptcontext.errorhandler()\n\n\ndef ExtendSurface(surface_id, parameter, length, smooth=True):\n    \"\"\"Lengthens an untrimmed surface object\n    Parameters:\n      surface_id = identifier of a surface\n      parameter = tuple of two values definfing the U,V parameter to evaluate.\n        The surface edge closest to the U,V parameter will be the edge that is\n        extended\n      length = amount to extend to surface\n      smooth[opt] = If True, the surface is extended smoothly curving from the\n        edge. If False, the surface is extended in a straight line from the edge\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    edge = surface.ClosestSide(parameter[0], parameter[1])\n    newsrf = surface.Extend(edge, length, smooth)\n    if newsrf:\n        surface_id = rhutil.coerceguid(surface_id)\n        if surface_id: scriptcontext.doc.Objects.Replace(surface_id, newsrf)\n        scriptcontext.doc.Views.Redraw()\n    return newsrf is not None\n\n\ndef ExplodePolysurfaces(object_ids, delete_input=False):\n    \"\"\"Explodes, or unjoins, one or more polysurface objects. Polysurfaces\n    will be exploded into separate surfaces\n    Parameters:\n      object_ids = identifiers of polysurfaces to explode\n      delete_input[opt] = delete input objects after exploding\n    Returns:\n      List of identifiers of exploded pieces on success\n    \"\"\"\n    id = rhutil.coerceguid(object_ids, False)\n    if id: object_ids = [id]\n    ids = []\n    for id in object_ids:\n        brep = rhutil.coercebrep(id, True)\n        if brep.Faces.Count>1:\n            for i in range(brep.Faces.Count):\n                copyface = brep.Faces[i].DuplicateFace(False)\n                face_id = scriptcontext.doc.Objects.AddBrep(copyface)\n                if face_id!=System.Guid.Empty: ids.append(face_id)\n            if delete_input: scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef ExtractIsoCurve(surface_id, parameter, direction):\n    \"\"\"Extracts isoparametric curves from a surface\n    Parameters:\n      surface_id = identifier of a surface\n      parameter = u,v parameter of the surface to evaluate\n      direction\n        0 = u, 1 = v, 2 = both\n    Returns:\n      list of curve ids on success\n      None on error\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    ids = []\n    if direction==0 or direction==2:\n        curves = None\n        if type(surface) is Rhino.Geometry.BrepFace:\n            curves = surface.TrimAwareIsoCurve(0, parameter[1])\n        else:\n            curves = [surface.IsoCurve(0,parameter[1])]\n        if curves:\n            for curve in curves:\n                id = scriptcontext.doc.Objects.AddCurve(curve)\n                if id!=System.Guid.Empty: ids.append(id)\n    if direction==1 or direction==2:\n        curves = None\n        if type(surface) is Rhino.Geometry.BrepFace:\n            curves = surface.TrimAwareIsoCurve(1, parameter[0])\n        else:\n            curves = [surface.IsoCurve(1,parameter[0])]\n        if curves:\n            for curve in curves:\n                id = scriptcontext.doc.Objects.AddCurve(curve)\n                if id!=System.Guid.Empty: ids.append(id)\n    scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef ExtractSurface(object_id, face_indices, copy=False):\n    \"\"\"Separates or copies a surface or a copy of a surface from a polysurface\n    Paramters:\n      object_id: polysurface identifier\n      face_indices: one or more numbers representing faces\n      copy[opt]: If True the faces are copied. If False, the faces are extracted\n    Returns:\n      identifiers of extracted surface objects on success\n    \"\"\"\n    brep = rhutil.coercebrep(object_id, True)\n    if hasattr(face_indices, \"__getitem__\"): pass\n    else: face_indices = [face_indices]\n    rc = []\n    face_indices = sorted(face_indices, reverse=True)\n    for index in face_indices:\n        face = brep.Faces[index]\n        newbrep = face.DuplicateFace(True)\n        id = scriptcontext.doc.Objects.AddBrep(newbrep)\n        rc.append(id)\n    if not copy:\n        for index in face_indices: brep.Faces.RemoveAt(index)\n        id = rhutil.coerceguid(object_id)\n        scriptcontext.doc.Objects.Replace(id, brep)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ExtrudeCurve(curve_id, path_id):\n    \"\"\"Creates a surface by extruding a curve along a path\n    Parameters:\n      curve_id = identifier of the curve to extrude\n      path_id = identifier of the path curve\n    Returns:\n      identifier of new surface on success\n      None on error\n    \"\"\"\n    curve1 = rhutil.coercecurve(curve_id, True)\n    curve2 = rhutil.coercecurve(path_id, True)\n    srf = Rhino.Geometry.SumSurface.Create(curve1, curve2)\n    rc = scriptcontext.doc.Objects.AddSurface(srf)\n    if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ExtrudeCurvePoint(curve_id, point):\n    \"\"\"Creates a surface by extruding a curve to a point\n    Parameters:\n      curve_id = identifier of the curve to extrude\n      point = 3D point\n    Returns:\n      identifier of new surface on success\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, True)\n    point = rhutil.coerce3dpoint(point, True)\n    srf = Rhino.Geometry.Surface.CreateExtrusionToPoint(curve, point)\n    rc = scriptcontext.doc.Objects.AddSurface(srf)\n    if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ExtrudeCurveStraight(curve_id, start_point, end_point):\n    \"\"\"Creates a surface by extruding a curve along two points that define a line\n    Parameters:\n      curve_id = identifier of the curve to extrude\n      start_point, end_point = 3D points\n    Returns:\n      identifier of new surface on success\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    start_point = rhutil.coerce3dpoint(start_point, True)\n    end_point = rhutil.coerce3dpoint(end_point, True)\n    vec = end_point - start_point\n    srf = Rhino.Geometry.Surface.CreateExtrusion(curve, vec)\n    rc = scriptcontext.doc.Objects.AddSurface(srf)\n    if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef FilletSurfaces(surface0, surface1, radius, uvparam0=None, uvparam1=None):\n    \"\"\"Create constant radius rolling ball fillets between two surfaces. Note,\n    this function does not trim the original surfaces of the fillets\n    Parameters:\n      surface0, surface1 = identifiers of first and second surface\n      radius = a positive fillet radius\n      uvparam0[opt] = a u,v surface parameter of surface0 near where the fillet\n        is expected to hit the surface\n      uvparam1[opt] = same as uvparam0, but for surface1\n    Returns:\n      ids of surfaces created on success\n      None on error\n    \"\"\"\n    surface0 = rhutil.coercesurface(surface0, True)\n    surface1 = rhutil.coercesurface(surface1, True)\n    uvparam0 = rhutil.coerce2dpoint(uvparam0, True)\n    uvparam1 = rhutil.coerce2dpoint(uvparam1, True)\n    surfaces = None\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    if uvparam0 and uvparam1:\n        surfaces = Rhino.Geometry.Surface.CreateRollingBallFillet(surface0, uvparam0, surface1, uvparam1, radius, tol)\n    else:\n        surfaces = Rhino.Geometry.Surface.CreateRollingBallFillet(surface0, surface1, radius, tol)\n    if not surfaces: return scriptcontext.errorhandler()\n    rc = []\n    for surf in surfaces:\n        rc.append( scriptcontext.doc.Objects.AddSurface(surf) )\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef FlipSurface(surface_id, flip=None):\n    \"\"\"Returns or changes the normal direction of a surface. This feature can\n    also be found in Rhino's Dir command\n    Parameters:\n      surface_id = identifier of a surface object\n      flip[opt] = new normal orientation, either flipped(True) or not flipped (False).\n    Returns:\n      if flipped is not specified, the current normal orientation\n      if flipped is specified, the previous normal orientation\n      None on error\n    \"\"\"\n    brep = rhutil.coercebrep(surface_id, True)\n    if brep.Faces.Count>1: return scriptcontext.errorhandler()\n    face = brep.Faces[0]\n    old_reverse = face.OrientationIsReversed\n    if flip!=None and brep.IsSolid==False and old_reverse!=flip:\n        brep.Flip()\n        surface_id = rhutil.coerceguid(surface_id)\n        if surface_id: scriptcontext.doc.Objects.Replace(surface_id, brep)\n        scriptcontext.doc.Views.Redraw()\n    return old_reverse\n\n\ndef IntersectBreps(brep1, brep2, tolerance=None):\n    \"\"\"Intersects a brep object with another brep object. Note, unlike the\n    SurfaceSurfaceIntersection function this function works on trimmed surfaces.\n    Parameters:\n      brep1 = The first brep object's identifier.\n      brep2 = The second  brep object's identifier.\n      tolerance = The distance tolerance at segment midpoints. If omitted,\n                  the current absolute tolerance is used.\n    Returns:\n      A list of Guids identifying the newly created intersection curve and\n      point objects if successful.\n      None if not successful, or on error.\n    \"\"\"\n    brep1 = rhutil.coercebrep(brep1, True)\n    brep2 = rhutil.coercebrep(brep2, True)\n    if tolerance is None or tolerance < 0.0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    rc = Rhino.Geometry.Intersect.Intersection.BrepBrep(brep1, brep2, tolerance)\n    if not rc[0]: return None\n    out_curves = rc[1]\n    out_points = rc[2]\n    merged_curves = Rhino.Geometry.Curve.JoinCurves(out_curves, 2.1 * tolerance)\n    \n    ids = []\n    if merged_curves:\n        for curve in merged_curves:\n            if curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n                curve.Dispose()\n                if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n                ids.append(rc)\n    else:\n        for curve in out_curves:\n            if curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n                curve.Dispose()\n                if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n                ids.append(rc)\n    for point in out_points:\n        rc = scriptcontext.doc.Objects.AddPoint(point)\n        if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n        ids.append(rc)\n    if ids: scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef IntersectSpheres(sphere_plane0, sphere_radius0, sphere_plane1, sphere_radius1):\n    \"\"\"Calculates intersections of two spheres\n    Parameters:\n      sphere_plane0 = an equatorial plane of the first sphere. The origin of the\n        plane will be the center point of the sphere\n      sphere_radius0 = radius of the first sphere\n      sphere_plane1 = plane for second sphere\n      sphere_radius1 = radius for second sphere\n    Returns:\n      List of intersection results\n        element 0 = type of intersection (0=point, 1=circle, 2=spheres are identical)\n        element 1 = Point of intersection or plane of circle intersection\n        element 2 = radius of circle if circle intersection\n      None on error\n    \"\"\"\n    plane0 = rhutil.coerceplane(sphere_plane0, True)\n    plane1 = rhutil.coerceplane(sphere_plane1, True)\n    sphere0 = Rhino.Geometry.Sphere(plane0, sphere_radius0)\n    sphere1 = Rhino.Geometry.Sphere(plane1, sphere_radius1)\n    rc, circle = Rhino.Geometry.Intersect.Intersection.SphereSphere(sphere0, sphere1)\n    if rc==Rhino.Geometry.Intersect.SphereSphereIntersection.Point:\n        return [0, circle.Center]\n    if rc==Rhino.Geometry.Intersect.SphereSphereIntersection.Circle:\n        return [1, circle.Plane, circle.Radius]\n    if rc==Rhino.Geometry.Intersect.SphereSphereIntersection.Overlap:\n        return [2]\n    return scriptcontext.errorhandler()\n\n\ndef IsBrep(object_id):\n    \"\"\"Verifies an object is a Brep, or a boundary representation model, object.\n    Parameters:\n      object_id = The object's identifier.\n    Returns:\n      True if successful, otherwise False.\n      None on error.\n    \"\"\"\n    return rhutil.coercebrep(object_id)!=None\n\n\ndef IsCone(object_id):\n    \"Determines if a surface is a portion of a cone\"\n    surface = rhutil.coercesurface(object_id, True)\n    return surface.IsCone()\n\n\ndef IsCylinder(object_id):\n    \"Determines if a surface is a portion of a cone\"\n    surface = rhutil.coercesurface(object_id, True)\n    return surface.IsCylinder()\n\n\ndef IsPlaneSurface(object_id):\n    \"\"\"Verifies an object is a plane surface. Plane surfaces can be created by\n    the Plane command. Note, a plane surface is not a planar NURBS surface\n    \"\"\"\n    face = rhutil.coercesurface(object_id, True)\n    if type(face) is Rhino.Geometry.BrepFace and face.IsSurface:\n        return type(face.UnderlyingSurface()) is Rhino.Geometry.PlaneSurface\n    return False\n    \n\ndef IsPointInSurface(object_id, point):\n    \"\"\"Verifies that a point is inside a closed surface or polysurface\n    Parameters:\n      object_id: the object's identifier\n      point: list of three numbers or Point3d. The test, or sampling point\n    Returns:\n      True if successful, otherwise False\n    \"\"\"\n    object_id = rhutil.coerceguid(object_id, True)\n    point = rhutil.coerce3dpoint(point, True)\n    if object_id==None or point==None: return scriptcontext.errorhandler()\n    obj = scriptcontext.doc.Objects.Find(object_id)\n    if type(obj)!=Rhino.DocObjects.BrepObject:\n        return scriptcontext.errorhandler()\n    tolerance = Rhino.RhinoMath.SqrtEpsilon\n    return obj.BrepGeometry.IsPointInside(point, tolerance, False)\n\n\ndef IsPointOnSurface(object_id, point):\n    \"\"\"Verifies that a point lies on a surface\n    Parameters:\n      object_id: the object's identifier\n      point: list of three numbers or Point3d. The test, or sampling point\n    Returns:\n      True if successful, otherwise False\n    \"\"\"\n    surf = rhutil.coercesurface(object_id, True)\n    point = rhutil.coerce3dpoint(point, True)\n    rc, u, v = surf.ClosestPoint(point)\n    if rc:\n        srf_pt = surf.PointAt(u,v)\n        if srf_pt.DistanceTo(point)>Rhino.RhinoMath.SqrtEpsilon:\n            rc = False\n        else:\n            rc = surf.IsPointOnFace(u,v) != Rhino.Geometry.PointFaceRelation.Exterior\n    return rc\n\n\ndef IsPolysurface(object_id):\n    \"\"\"Verifies an object is a polysurface. Polysurfaces consist of two or more\n    surfaces joined together. If the polysurface fully encloses a volume, it is\n    considered a solid.\n    Parameters:\n      object_id: the object's identifier\n    Returns:\n      True is successful, otherwise False\n    \"\"\"\n    brep = rhutil.coercebrep(object_id)\n    if brep is None: return False\n    return brep.Faces.Count>1\n\n\ndef IsPolysurfaceClosed(object_id):\n    \"\"\"Verifies a polysurface object is closed. If the polysurface fully encloses\n    a volume, it is considered a solid.\n    Parameters:\n      object_id: the object's identifier\n    Returns:\n      True is successful, otherwise False\n    \"\"\"\n    brep = rhutil.coercebrep(object_id, True)\n    return brep.IsSolid\n\n\ndef IsSphere(object_id):\n    \"Determines if a surface is a portion of a sphere\"\n    surface = rhutil.coercesurface(object_id, True)\n    return surface.IsSphere()\n\n\ndef IsSurface(object_id):\n    \"\"\"Verifies an object is a surface. Brep objects with only one face are\n    also considered surfaces.\n    Parameters:\n      object_id = the object's identifier.\n    Returns:\n      True if successful, otherwise False.\n    \"\"\"\n    brep = rhutil.coercebrep(object_id)\n    if brep and brep.Faces.Count==1: return True\n    surface = rhutil.coercesurface(object_id)\n    return (surface!=None)\n\n\ndef IsSurfaceClosed( surface_id, direction ):\n    \"\"\"Verifies a surface object is closed in the specified direction.  If the\n    surface fully encloses a volume, it is considered a solid\n    Parameters:\n      surface_id = identifier of a surface\n      direction = 0=U, 1=V\n    Returns:\n      True or False\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    return surface.IsClosed(direction)\n\n\ndef IsSurfacePeriodic(surface_id, direction):\n    \"\"\"Verifies a surface object is periodic in the specified direction.\n    Parameters:\n      surface_id = identifier of a surface\n      direction = 0=U, 1=V\n    Returns:\n      True or False\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    return surface.IsPeriodic(direction)\n\n\ndef IsSurfacePlanar(surface_id, tolerance=None):\n    \"\"\"Verifies a surface object is planar\n    Parameters:\n      surface_id = identifier of a surface\n      tolerance[opt] = tolerance used when checked. If omitted, the current absolute\n        tolerance is used\n    Returns:\n      True or False\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    if tolerance is None:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    return surface.IsPlanar(tolerance)\n\n\ndef IsSurfaceRational(surface_id):\n    \"\"\"Verifies a surface object is rational\n    Parameters:\n      surface_id = the surface's identifier\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    ns = surface.ToNurbsSurface()\n    if ns is None: return False\n    return ns.IsRational\n\n\ndef IsSurfaceSingular(surface_id, direction):\n    \"\"\"Verifies a surface object is singular in the specified direction.\n    Surfaces are considered singular if a side collapses to a point.\n    Parameters:\n      surface_id = the surface's identifier\n      direction: 0=south, 1=east, 2=north, 3=west\n    Returns:\n      True or False\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    return surface.IsSingular(direction)\n\n\ndef IsSurfaceTrimmed(surface_id):\n    \"\"\"Verifies a surface object has been trimmed\n    Parameters:\n      surface_id = the surface's identifier\n    Returns:\n      True or False\n    \"\"\"\n    brep = rhutil.coercebrep(surface_id, True)\n    return not brep.IsSurface\n\n\ndef IsTorus(surface_id):\n    \"Determines if a surface is a portion of a torus\"\n    surface = rhutil.coercesurface(surface_id, True)\n    return surface.IsTorus()\n\n\ndef JoinSurfaces(object_ids, delete_input=False):\n    \"\"\"Joins two or more surface or polysurface objects together to form one\n    polysurface object\n    Parameters:\n      object_ids = list of object identifiers\n    Returns:\n      identifier of newly created object on success\n      None on failure\n    \"\"\"\n    breps = [rhutil.coercebrep(id, True) for id in object_ids]\n    if len(breps)<2: return scriptcontext.errorhandler()\n    tol = scriptcontext.doc.ModelAbsoluteTolerance * 2.1\n    joinedbreps = Rhino.Geometry.Brep.JoinBreps(breps, tol)\n    if joinedbreps is None or len(joinedbreps)!=1:\n        return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddBrep(joinedbreps[0])\n    if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    if delete_input:\n        for id in object_ids:\n            id = rhutil.coerceguid(id)\n            scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef MakeSurfacePeriodic(surface_id, direction, delete_input=False):\n    \"\"\"Makes an existing surface a periodic NURBS surface\n    Paramters:\n      surface_id = the surface's identifier\n      direction = The direction to make periodic, either 0=U or 1=V\n      delete_input[opt] = delete the input surface\n    Returns:\n      if delete_input is False, identifier of the new surface\n      if delete_input is True, identifer of the modifier surface\n      None on error\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    newsurf = Rhino.Geometry.Surface.CreatePeriodicSurface(surface, direction)\n    if newsurf is None: return scriptcontext.errorhandler()\n    id = rhutil.coerceguid(surface_id)\n    if delete_input:\n        scriptcontext.doc.Objects.Replace(id, newsurf)\n    else:\n        id = scriptcontext.doc.Objects.AddSurface(newsurf)\n    scriptcontext.doc.Views.Redraw()\n    return id\n\n\ndef OffsetSurface(surface_id, distance, tolerance=None):\n    \"\"\"Offsets a trimmed or untrimmed surface by a distance. The offset surface\n    will be added to Rhino.\n    Parameters:\n      surface_id = the surface's identifier\n      distance = the distance to offset\n      tolerance [opt] = The offset tolerance. Use 0.0 to make a loose offset. Otherwise, the\n        document's absolute tolerance is usually sufficient.\n    Returns:\n      identifier of the new object if successful\n      None on error\n    \"\"\"\n    brep = rhutil.coercebrep(surface_id, True)\n    face = None\n    if brep.IsSurface: face = brep.Faces[0]\n    if face is None: return scriptcontext.errorhandler()\n    if tolerance is None: tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newbrep = Rhino.Geometry.Brep.CreateFromOffsetFace(face, distance, tolerance, False, False)\n    if newbrep is None: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddBrep(newbrep)\n    if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef RebuildSurface(object_id, degree=(3,3), pointcount=(10,10)):\n    \"\"\"Rebuilds a surface to a given degree and control point count. For more\n    information see the Rhino help file for the Rebuild command\n    Parameters:\n      object_id = the surface's identifier\n      degree[opt] = two numbers that identify surface degree in both U and V directions\n      pointcount[opt] = two numbers that identify the surface point count in both the U and V directions\n    Returns:\n      True of False indicating success or failure\n    \"\"\"\n    surface = rhutil.coercesurface(object_id, True)\n    newsurf = surface.Rebuild( degree[0], degree[1], pointcount[0], pointcount[1] )\n    if newsurf is None: return False\n    object_id = rhutil.coerceguid(object_id)\n    rc = scriptcontext.doc.Objects.Replace(object_id, newsurf)\n    if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ShootRay(surface_ids, start_point, direction, reflections=10):\n    \"\"\"Shoots a ray at a collection of surfaces\n    Parameters:\n      surface_ids = one of more surface identifiers\n      start_point = starting point of the ray\n      direction = vector identifying the direction of the ray\n      reflections[opt] = the maximum number of times the ray will be reflected\n    Returns:\n      list of reflection points on success\n      None on error\n    \"\"\"\n    start_point = rhutil.coerce3dpoint(start_point, True)\n    direction = rhutil.coerce3dvector(direction, True)\n    id = rhutil.coerceguid(surface_ids, False)\n    if id: surface_ids = [id]\n    ray = Rhino.Geometry.Ray3d(start_point, direction)\n    breps = []\n    for id in surface_ids:\n        brep = rhutil.coercebrep(id)\n        if brep: breps.append(brep)\n        else:\n            surface = rhutil.coercesurface(id, True)\n            breps.append(surface)\n    if not breps: return scriptcontext.errorhandler()\n    points = Rhino.Geometry.Intersect.Intersection.RayShoot(ray, breps, reflections)\n    if points:\n        rc = []\n        rc.append(start_point)\n        rc = rc + list(points)\n        return rc\n    return scriptcontext.errorhandler()\n\n\ndef ShortPath(surface_id, start_point, end_point):\n    \"\"\"Creates the shortest possible curve(geodesic) between two points on a\n    surface. For more details, see the ShortPath command in Rhino help\n    Parameters:\n      surface_id = identifier of a surface\n      start_point, end_point = start/end points of the short curve\n    Returns:\n      identifier of the new surface on success\n      None on error\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    start = rhutil.coerce3dpoint(start_point, True)\n    end = rhutil.coerce3dpoint(end_point, True)\n    rc_start, u_start, v_start = surface.ClosestPoint(start)\n    rc_end, u_end, v_end = surface.ClosestPoint(end)\n    if not rc_start or not rc_end: return scriptcontext.errorhandler()\n    start = Rhino.Geometry.Point2d(u_start, v_start)\n    end = Rhino.Geometry.Point2d(u_end, v_end)\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    curve = surface.ShortPath(start, end, tolerance)\n    if curve is None: return scriptcontext.errorhandler()\n    id = scriptcontext.doc.Objects.AddCurve(curve)\n    if id==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return id\n\n\ndef ShrinkTrimmedSurface(object_id, create_copy=False):\n    \"\"\"Shrinks the underlying untrimmed surfaces near to the trimming\n    boundaries. See the ShrinkTrimmedSrf command in the Rhino help.\n    Parameters:\n      object_id = the surface's identifier\n      create_copy[opt] = If True, the original surface is not deleted\n    Returns:\n      If create_copy is False, True or False indifating success or failure\n      If create_copy is True, the identifier of the new surface\n      None on error\n    \"\"\"\n    brep = rhutil.coercebrep(object_id, True)\n    if not brep.Faces.ShrinkFaces(): return scriptcontext.errorhandler()\n    rc = None\n    object_id = rhutil.coerceguid(object_id)\n    if create_copy:\n        oldobj = scriptcontext.doc.Objects.Find(object_id)\n        attr = oldobj.Attributes\n        rc = scriptcontext.doc.Objects.AddBrep(brep, attr)\n    else:\n        rc = scriptcontext.doc.Objects.Replace(object_id, brep)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef __GetMassProperties(object_id, area):\n    surface = rhutil.coercebrep(object_id)\n    if surface is None:\n        surface = rhutil.coercesurface(object_id)\n        if surface is None: return None\n    if area==True: return Rhino.Geometry.AreaMassProperties.Compute(surface)\n    if not surface.IsSolid: return None\n    return Rhino.Geometry.VolumeMassProperties.Compute(surface)\n\n\ndef SplitBrep(brep_id, cutter_id, delete_input=False):\n    \"\"\"Splits a brep\n    Parameters:\n      brep = identifier of the brep to split\n      cutter = identifier of the brep to split with\n    Returns:\n      identifiers of split pieces on success\n      None on error\n    \"\"\"\n    brep = rhutil.coercebrep(brep_id, True)\n    cutter = rhutil.coercebrep(cutter_id, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    pieces = brep.Split(cutter, tol)\n    if not pieces: return scriptcontext.errorhandler()\n    if delete_input:\n        brep_id = rhutil.coerceguid(brep_id)\n        scriptcontext.doc.Objects.Delete(brep_id, True)\n    rc = [scriptcontext.doc.Objects.AddBrep(piece) for piece in pieces]\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef SurfaceArea(object_id):\n    \"\"\"Calculates the area of a surface or polysurface object. The results are\n    based on the current drawing units\n    Parameters:\n      object_id = the surface's identifier\n    Returns:\n      list of area inforation on success (area, absolute error bound)\n      None on error\n    \"\"\"\n    amp = __GetMassProperties(object_id, True)\n    if amp is None: return scriptcontext.errorhandler()\n    return amp.Area, amp.AreaError\n\n\ndef SurfaceAreaCentroid(object_id):\n    \"\"\"Calculates the area centroid of a surface or polysurface\n    Parameters:\n      object_id = the surface's identifier\n    Returns:\n      (Area Centriod, Error bound) on success\n      None on error\n    \"\"\"\n    amp = __GetMassProperties(object_id, True)\n    if amp is None: return scriptcontext.errorhandler()\n    return amp.Centroid, amp.CentroidError\n\n\ndef __AreaMomentsHelper(surface_id, area):\n    mp = __GetMassProperties(surface_id, area)\n    if mp is None: return scriptcontext.errorhandler()\n    a = (mp.WorldCoordinatesFirstMoments.X, mp.WorldCoordinatesFirstMoments.Y, mp.WorldCoordinatesFirstMoments.Z)\n    b = (mp.WorldCoordinatesFirstMomentsError.X, mp.WorldCoordinatesFirstMomentsError.Y, mp.WorldCoordinatesFirstMomentsError.Z)\n    c = (mp.WorldCoordinatesSecondMoments.X, mp.WorldCoordinatesSecondMoments.Y, mp.WorldCoordinatesSecondMoments.Z)\n    d = (mp.WorldCoordinatesSecondMomentsError.X, mp.WorldCoordinatesSecondMomentsError.Y, mp.WorldCoordinatesSecondMomentsError.Z)\n    e = (mp.WorldCoordinatesProductMoments.X, mp.WorldCoordinatesProductMoments.Y, mp.WorldCoordinatesProductMoments.Z)\n    f = (mp.WorldCoordinatesProductMomentsError.X, mp.WorldCoordinatesProductMomentsError.Y, mp.WorldCoordinatesProductMomentsError.Z)\n    g = (mp.WorldCoordinatesMomentsOfInertia.X, mp.WorldCoordinatesMomentsOfInertia.Y, mp.WorldCoordinatesMomentsOfInertia.Z)\n    h = (mp.WorldCoordinatesMomentsOfInertiaError.X, mp.WorldCoordinatesMomentsOfInertiaError.Y, mp.WorldCoordinatesMomentsOfInertiaError.Z)\n    i = (mp.WorldCoordinatesRadiiOfGyration.X, mp.WorldCoordinatesRadiiOfGyration.Y, mp.WorldCoordinatesRadiiOfGyration.Z)\n    j = (0,0,0) # need to add error calc to RhinoCommon\n    k = (mp.CentroidCoordinatesMomentsOfInertia.X, mp.CentroidCoordinatesMomentsOfInertia.Y, mp.CentroidCoordinatesMomentsOfInertia.Z)\n    l = (mp.CentroidCoordinatesMomentsOfInertiaError.X, mp.CentroidCoordinatesMomentsOfInertiaError.Y, mp.CentroidCoordinatesMomentsOfInertiaError.Z)\n    m = (mp.CentroidCoordinatesRadiiOfGyration.X, mp.CentroidCoordinatesRadiiOfGyration.Y, mp.CentroidCoordinatesRadiiOfGyration.Z)\n    n = (0,0,0) #need to add error calc to RhinoCommon\n    return (a,b,c,d,e,f,g,h,i,j,k,l,m,n)\n\n\ndef SurfaceAreaMoments(surface_id):\n    \"\"\"Calculates area moments of inertia of a surface or polysurface object.\n    See the Rhino help for \"Mass Properties calculation details\"\n    Parameters:\n      surface_id = the surface's identifier\n    Returns:\n      list of moments and error bounds - see help topic\n      None on error\n    \"\"\"\n    return __AreaMomentsHelper(surface_id, True)\n\n\ndef SurfaceClosestPoint(surface_id, test_point):\n    \"\"\"Returns U,V parameters of point on a surface that is closest to a test point\n    Parameters:\n      surface_id = identifier of a surface object\n      test_point = sampling point\n    Returns:\n      The U,V parameters of the closest point on the surface if successful.\n      None on error.\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    point = rhutil.coerce3dpoint(test_point, True)\n    rc, u, v = surface.ClosestPoint(point)\n    if not rc: return None\n    return u,v\n\n\ndef SurfaceCone(surface_id):\n    \"\"\"Returns the definition of a surface cone\n    Parameters:\n      surface_id = the surface's identifier\n    Returns:\n      tuple containing the definition of the cone if successful\n        element 0 = the plane of the cone. The apex of the cone is at the\n            plane's origin and the axis of the cone is the plane's z-axis\n        element 1 = the height of the cone\n        element 2 = the radius of the cone\n      None on error\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    rc, cone = surface.TryGetCone()\n    if not rc: return scriptcontext.errorhandler()\n    return cone.Plane, cone.Height, cone.Radius\n\n\ndef SurfaceCurvature(surface_id, parameter):\n    \"\"\"Returns the curvature of a surface at a U,V parameter. See Rhino help\n    for details of surface curvature\n    Parameters:\n      surface_id = the surface's identifier\n      parameter = u,v parameter\n    Returns:\n      tuple of curvature information\n        element 0 = point at specified U,V parameter\n        element 1 = normal direction\n        element 2 = maximum principal curvature\n        element 3 = maximum principal curvature direction\n        element 4 = minimum principal curvature\n        element 5 = minimum principal curvature direction\n        element 6 = gaussian curvature\n        element 7 = mean curvature\n      None if not successful, or on error\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    if len(parameter)<2: return scriptcontext.errorhandler()\n    c = surface.CurvatureAt(parameter[0], parameter[1])\n    if c is None: return scriptcontext.errorhandler()\n    return c.Point, c.Normal, c.Kappa(0), c.Direction(0), c.Kappa(1), c.Direction(1), c.Gaussian, c.Mean\n\n\ndef SurfaceDegree(surface_id, direction=2):\n    \"\"\"Returns the degree of a surface object in the specified direction\n    Parameters:\n      surface_id = the surface's identifier\n      direction[opt]\n        0 = U, 1 = v, 2 = both\n    Returns:\n      Tuple of two values if direction = 2\n      Single number if direction = 0 or 1\n      None on error\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    if direction==0 or direction==1: return surface.Degree(direction)\n    if direction==2: return surface.Degree(0), surface.Degree(1)\n    return scriptcontext.errorhandler()\n\n\ndef SurfaceDomain(surface_id, direction):\n    \"\"\"Returns the domain of a surface object in the specified direction.\n    Parameters:\n      surface_id = the surface's identifier\n      direction = either 0 = U, or 1 = V\n    Returns:\n      list containing the domain interval in the specified direction\n      None if not successful, or on error\n    \"\"\"\n    if direction!=0 and direction!=1: return scriptcontext.errorhandler()\n    surface = rhutil.coercesurface(surface_id, True)\n    domain = surface.Domain(direction)\n    return domain.T0, domain.T1\n\n\ndef SurfaceEditPoints(surface_id, return_parameters=False, return_all=True):\n    \"\"\"Returns the edit, or Greville points of a surface object. For each\n    surface control point, there is a corresponding edit point\n    Parameters:\n      surface_id = the surface's identifier\n      return_parameters[opt] = If False, edit points are returned as a list of\n        3D points. If True, edit points are returned as a list of U,V surface\n        parameters\n      return_all[opt] = If True, all surface edit points are returned. If False,\n        the function will return surface edit points based on whether or not the\n        surface is closed or periodic\n    Returns:\n      if return_parameters is False, a list of 3D points\n      if return_parameters is True, a list of U,V parameters\n      None on error\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    nurb = surface.ToNurbsSurface()\n    if not nurb: return scriptcontext.errorhandler()\n    ufirst = 0\n    ulast = nurb.Points.CountU\n    vfirst = 0\n    vlast = nurb.Points.CountV\n    if not return_all:\n        if nurb.IsClosed(0): ulast = nurb.Points.CountU-1\n        if nurbs.IsPeriodic(0):\n            degree = nurb.Degree(0)\n            ufirst = degree/2\n            ulast = nurb.Points.CountU-degree+ufirst\n        if nurb.IsClosed(1): vlast = nurb.Points.CountV-1\n        if nurbs.IsPeriodic(1):\n            degree = nurb.Degree(1)\n            vfirst = degree/2\n            vlast = nurb.Points.CountV-degree+vfirst\n    rc = []\n    for u in range(ufirst, ulast):\n        for v in range(vfirst, vlast):\n            pt = nurb.Points.GetGrevillePoint(u,v)\n            if not return_parameters: pt = nurb.PointAt(pt.X, pt.Y)\n            rc.append(pt)\n    return rc\n\n\ndef SurfaceEvaluate(surface_id, parameter, derivative):\n    \"\"\"A general purpose surface evaluator\n    Parameters:\n      surface_id = the surface's identifier\n      parameter = u,v parameter to evaluate\n      derivative = number of derivatives to evaluate\n    Returns:\n      list of derivatives on success\n      None on error\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    success, point, der = surface.Evaluate(parameter[0], parameter[1], derivative)\n    if not success: return scriptcontext.errorhandler()\n    rc = [point]\n    for d in der: rc.append(d)\n    return rc\n\n\ndef SurfaceFrame(surface_id, uv_parameter):\n    \"\"\"Returns a plane based on the normal, u, and v directions at a surface\n    U,V parameter\n    Parameters:\n      surface_id = the surface's identifier\n      uv_parameter = u,v parameter to evaluate\n    Returns:\n      plane on success\n      None on error\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    rc, frame = surface.FrameAt(uv_parameter[0], uv_parameter[1])\n    if rc: return frame\n\n\ndef SurfaceIsocurveDensity(surface_id, density=None):\n    \"\"\"Returns or sets the isocurve density of a surface or polysurface object.\n    An isoparametric curve is a curve of constant U or V value on a surface.\n    Rhino uses isocurves and surface edge curves to visualize the shape of a\n    NURBS surface\n    Parameters:\n      surface_id = the surface's identifier\n      density[opt] = the isocurve wireframe density. The possible values are\n          -1: Hides the surface isocurves\n           0: Display boundary and knot wires\n           1: Display boundary and knot wires and one interior wire if there\n              are no interior knots\n         >=2: Display boundary and knot wires and (N+1) interior wires\n    Returns:\n      If density is not specified, then the current isocurve density if successful\n      If density is specified, the the previous isocurve density if successful\n      None on error\n    \"\"\"\n    rhino_object = rhutil.coercerhinoobject(surface_id, True, True)\n    if not isinstance(rhino_object, Rhino.DocObjects.BrepObject):\n        return scriptcontext.errorhandler()\n    rc = rhino_object.Attributes.WireDensity\n    if density is not None:\n        if density<0: density = -1\n        rhino_object.Attributes.WireDensity = density\n        rhino_object.CommitChanges()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef SurfaceKnotCount(surface_id):\n    \"\"\"Returns the control point count of a surface\n      surface_id = the surface's identifier\n    Returns:\n      (U count, V count) on success\n      None on error\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    ns = surface.ToNurbsSurface()\n    if ns is None: return scriptcontext.errorhandler()\n    return ns.KnotsU.Count, ns.KnotsV.Count\n\n\ndef SurfaceKnots(surface_id):\n    \"\"\"Returns the knots, or knot vector, of a surface object.\n    Parameters:\n      surface_id = the surface's identifier\n    Returns:\n      The list of knot values of the surface if successful. The list will\n      contain the following information:\n      Element     Description\n        0         Knot vector in U direction\n        1         Knot vector in V direction\n      None if not successful, or on error.\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    nurb_surf = surface.ToNurbsSurface()\n    if nurb_surf is None: return scriptcontext.errorhandler()\n    s_knots = [knot for knot in nurb_surf.KnotsU]\n    t_knots = [knot for knot in nurb_surf.KnotsV]\n    if not s_knots or not t_knots: return scriptcontext.errorhandler()\n    return s_knots, t_knots\n\n\ndef SurfaceNormal(surface_id, uv_parameter):\n    \"\"\"Returns 3D vector that is the normal to a surface at a parameter\n    Parameters:\n      surface_id = the surface's identifier\n      uv_parameter = the uv parameter to evaluate\n    Returns:\n      Normal vector on success\n      None on error\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    normal = surface.NormalAt(uv_parameter[0], uv_parameter[1])\n    return normal\n\n\ndef SurfaceNormalizedParameter(surface_id, parameter):\n    \"\"\"Converts surface parameter to a normalized surface parameter; one that\n    ranges between 0.0 and 1.0 in both the U and V directions\n    Parameters:\n      surface_id = the surface's identifier\n      parameter = the surface parameter to convert\n    Returns:\n      normalized surface parameter if successful\n      None on error\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    u_domain = surface.Domain(0)\n    v_domain = surface.Domain(1)\n    if parameter[0]<u_domain.Min or parameter[0]>u_domain.Max:\n        return scriptcontext.errorhandler()\n    if parameter[1]<v_domain.Min or parameter[1]>v_domain.Max:\n        return scriptcontext.errorhandler()\n    u = u_domain.NormalizedParameterAt(parameter[0])\n    v = v_domain.NormalizedParameterAt(parameter[1])\n    return u,v\n\n\ndef SurfaceParameter(surface_id, parameter):\n    \"\"\"Converts normalized surface parameter to a surface parameter; or\n    within the surface's domain\n    Parameters:\n      surface_id = the surface's identifier\n      parameter = the normalized parameter to convert\n    Returns:\n      surface parameter as tuple on success\n      None on error\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    x = surface.Domain(0).ParameterAt(parameter[0])\n    y = surface.Domain(1).ParameterAt(parameter[1])\n    return x, y\n\n\ndef SurfacePointCount(surface_id):\n    \"\"\"Returns the control point count of a surface\n      surface_id = the surface's identifier\n    Returns:\n      (U count, V count) on success\n      None on error\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    ns = surface.ToNurbsSurface()\n    if ns is None: return scriptcontext.errorhandler()\n    return ns.Points.CountU, ns.Points.CountV\n\n\ndef SurfacePoints(surface_id, return_all=True):\n    \"\"\"Returns the control points, or control vertices, of a surface object\n    Parameters:\n      surface_id = the surface's identifier\n      return_all[opt] = If True all surface edit points are returned. If False,\n        the function will return surface edit points based on whether or not\n        the surface is closed or periodic\n    Returns:\n      the control points if successful\n      None on error\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    ns = surface.ToNurbsSurface()\n    if ns is None: return scriptcontext.errorhandler()\n    ucount = ns.Points.CountU\n    vcount = ns.Points.CountV\n    rc = []\n    for u in range(ucount):\n        for v in range(vcount):\n            pt = ns.Points.GetControlPoint(u,v)\n            rc.append(pt.Location)\n    return rc\n\n\ndef SurfaceTorus(surface_id):\n    \"\"\"Returns the definition of a surface torus\n    Parameters:\n      surface_id = the surface's identifier\n    Returns:\n      tuple containing the definition of the torus if successful\n        element 0 = the base plane of the torus\n        element 1 = the major radius of the torus\n        element 2 = the minor radius of the torus\n      None on error\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    rc, torus = surface.TryGetTorus()\n    if not rc: return scriptcontext.errorhandler()\n    return torus.Plane, torus.MajorRadius, torus.MinorRadius\n\n\ndef SurfaceVolume(object_id):\n    \"\"\"Calculates the volume of a closed surface or polysurface\n    Parameters:\n      object_id = the surface's identifier\n    Returns:\n      (Volume, Error bound) on success\n      None on error\n    \"\"\"\n    vmp = __GetMassProperties(object_id, False)\n    if vmp is None: return scriptcontext.errorhandler()\n    return vmp.Volume, vmp.VolumeError\n\n\ndef SurfaceVolumeCentroid(object_id):\n    \"\"\"Calculates the volume centroid of a closed surface or polysurface\n    Parameters:\n      object_id = the surface's identifier\n    Returns:\n      (Volume Centriod, Error bound) on success\n      None on error\n    \"\"\"\n    vmp = __GetMassProperties(object_id, False)\n    if vmp is None: return scriptcontext.errorhandler()\n    return vmp.Centroid, vmp.CentroidError\n\n\ndef SurfaceVolumeMoments(surface_id):\n    \"\"\"Calculates the volume moments of inertia of a surface or polysurface object.\n    For more information, see Rhino help for \"Mass Properties calculation details\"\n    Parameters:\n      surface_id = the surface's identifier\n    Returns:\n      list of moments and error bounds - see help topic\n      None on error\n    \"\"\"\n    return __AreaMomentsHelper(surface_id, False)\n\n\ndef SurfaceWeights(object_id):\n    \"\"\"Returns list of weight values that are assigned to the control points of\n    a surface. The number of weights returned will be equal to the number of\n    control points in the U and V directions.\n    Parameters:\n      object_id = the surface's identifier\n    Returns:\n      list of weights\n      None on error\n    \"\"\"\n    surface = rhutil.coercesurface(object_id, True)\n    ns = surface.ToNurbsSurface()\n    if ns is None: return scriptcontext.errorhandler()\n    ucount = ns.Points.CountU\n    vcount = ns.Points.CountV\n    rc = []\n    for u in range(ucount):\n        for v in range(vcount):\n            pt = ns.Points.GetControlPoint(u,v)\n            rc.append(pt.Weight)\n    return rc\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": false
}