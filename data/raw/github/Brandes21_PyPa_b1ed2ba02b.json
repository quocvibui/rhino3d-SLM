{
  "source_url": "https://github.com/Brandes21/PyPa/blob/713d1e35bd5490521eab2d0efe869fff9692e351/Packages/Topo_Tracer/src/Topo_Tracer/Topo_Tracer_1.py",
  "repo": "Brandes21/PyPa",
  "repo_stars": 1,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Packages/Topo_Tracer/src/Topo_Tracer/Topo_Tracer_1.py",
  "instruction": "Topo tracer 1",
  "code": "def main(surface, points, sigma1_list, p1_list, sigma2_list, p2_list,tol_deg, offset_eps,neighbors, cluster_threshold, seed_amplitude,index_radius, n_sep_merged):\n\n    # -- Prerequisites ------------------------------------------------------------\n    import math\n    from typing import List, Optional, Tuple\n    import numpy as np\n    from scipy.spatial import KDTree\n    import Rhino.Geometry as rg\n    from ghpythonlib import treehelpers as tr\n    import ghpythonlib.components as ghcomp\n\n    def measure_unoriented_angles(\n        x0,\n        y0,\n        slope,\n        eps,\n        pts,\n        Tlist,\n        kdtree,\n        tol=0.15\n    ):\n        \n        # 1) Offsets from (x0,y0) by eps in direction (1, slope).\n        # 2) Gets local p1, p2 from nearest non-degenerate neighbor.\n        # 3) Computes the *unoriented* angles angle1, angle2 of (1,slope)\n        # vs. p1 and p2, respectively.\n\n        # Returns (label, angle1, angle2):\n        # label: '1' if angle1 <= angle2, '2' otherwise\n        # angle1, angle2: the actual angles in [0, π/2].\n\n        # If something fails (degenerate region, zero dir, etc.), returns (None, None, None).\n        \n        dir_vec = np.array([1.0, slope], dtype=float)\n        norm = np.linalg.norm(dir_vec)\n        if norm < 1e-14:\n            return None, None, None\n        dir_vec_n = dir_vec / norm\n\n        x_eps = x0 + eps * dir_vec_n[0]\n        y_eps = y0 + eps * dir_vec_n[1]\n\n        # Re-use existing local-eigens code\n        p1, p2 = get_local_eigenvectors(x_eps, y_eps, pts, Tlist, kdtree, sigma1_list, sigma2_list, tol=tol)\n        if p1 is None or p2 is None:\n            return None, None, None\n\n\n\n\n\n        p1_n = p1 / np.linalg.norm(p1)\n        p2_n = p2 / np.linalg.norm(p2)\n\n        # Compute angles via arccos(|dot|)\n        dot1 = abs(np.dot(dir_vec_n, p1_n))\n        dot2 = abs(np.dot(dir_vec_n, p2_n))\n\n        angle1 = math.acos(np.clip(dot1, 0, 1))\n        angle2 = math.acos(np.clip(dot2, 0, 1))\n\n        # Decide ownership\n        if angle1 <= angle2:\n            return '1', angle1, angle2\n        else:\n            return '2', angle1, angle2\n    # -- Basic 2D Stress Tensor ---------------------------------------------------\n\n    def stress_tensor_2d(\n        sigma1: float,\n        p1: Tuple[float, float, float],\n        sigma2: float,\n        p2: Tuple[float, float, float]) -> np.ndarray:\n        \"\"\"\n        Construct the 2D stress tensor:\n            T = sigma1 * (p1 p1^T) + sigma2 * (p2 p2^T)\n        Only the x and y components of p1, p2 are used.\n        \"\"\"\n        x1, y1, _ = p1\n        x2, y2, _ = p2\n        T1 = np.array([[x1*x1, x1*y1], [y1*x1, y1*y1]])\n        T2 = np.array([[x2*x2, x2*y2], [y2*x2, y2*y2]])\n        return sigma1 * T1 + sigma2 * T2\n\n\n\n    def sample_directions_around_merged_point(\n        x0, y0,\n        pts,\n        Tlist,\n        kdtree,\n        n_samples=16,\n        offset_eps=0.02,\n        deg_tol=0.01\n    ):\n        \n        # 1) Sample n_samples directions around the circle.\n        # 2) For each, measure unoriented angles to both fields.\n        # 3) Collect candidates in two groups (label '1' or '2').\n        # 4) Sort each by fit angle and keep best four.\n        # Returns p1_vecs, p2_vecs, p1_candidates.\n        \n        angles = np.linspace(0, 2*np.pi, n_samples, endpoint=False)\n        p1_candidates, p2_candidates = [], []\n\n        for theta in angles:\n            dx, dy = math.cos(theta), math.sin(theta)\n            # slope fallback\n            slope = dy/dx if abs(dx)>1e-14 else np.sign(dy)*1e14\n            label, angle1, angle2 = measure_unoriented_angles(\n                x0, y0, slope, offset_eps, pts, Tlist, kdtree, tol=deg_tol\n            )\n            if label is None:\n                continue\n            vec = np.array([dx, dy], float)\n            if np.linalg.norm(vec)<1e-14:\n                continue\n            vec /= np.linalg.norm(vec)\n            fit = angle1 if label=='1' else angle2\n            (p1_candidates if label=='1' else p2_candidates).append((vec, fit))\n\n        # keep best n_sep_merged of each\n        p1_candidates.sort(key=lambda x: x[1]); p2_candidates.sort(key=lambda x: x[1])\n        p1_vecs = [v for v,_ in p1_candidates[:n_sep_merged]]\n        p2_vecs = [v for v,_ in p2_candidates[:n_sep_merged]]\n        return p1_vecs, p2_vecs, p1_candidates\n\n\n\n\n    # -- Cubic Solver for Separatrices --------------------------------------------\n\n    def separatrix_slopes(\n        a: float,\n        b: float,\n        c: float,\n        d: float,\n        imag_tol: float = 1e-7) -> List[float]:\n        \n        # Solve cubic: d x^3 + (c+2b) x^2 + (2a-d) x - c = 0\n        # Return all real roots (slope values).\n        \n        coeffs = [d, c + 2*b, 2*a - d, -c]\n        roots = np.roots(coeffs)\n        return [r.real for r in roots if abs(r.imag) < imag_tol]\n\n    # -- Classification of Degenerate Type ---------------------------------------\n\n    def classify_degenerate(\n        x0: float,\n        y0: float,\n        points: list[rg.Point3d],\n        tensors: list[np.ndarray],\n        kdtree: KDTree,\n        radius: float,\n        a: float,\n        b: float,\n        c: float,\n        d: float,\n        tol: float = 1e-15,\n        n_samples: int = 50,\n        which_field: str = 'major'\n    ) -> str:\n        \n        # Compute delta = a*d - b*c and Delmarcelle index, then choose the index-based\n        # classification if it differs from delta-based.\n\n        # Delta-based:\n        # delta>tol  -> 'wedge'\n        # delta<-tol -> 'trisector'\n        # else       -> 'merged'\n\n        # Index-based (from compute_index_delmarcelle):\n        # index ≈ +0.5 -> 'wedge'\n        # index ≈ -0.5 -> 'trisector'\n        # index ≈ -1.0 -> 'saddle'\n        # else         -> 'merged'\n        \n        # delta classification\n        delta = a*d - b*c\n        if delta > 1e-15:\n            delta_class = 'wedge'\n        elif delta < -1e-15:\n            delta_class = 'trisector'\n        else:\n            delta_class = 'merged'\n\n        # index classification\n        idx_value, _ = compute_index_delmarcelle(\n            x0, y0, points, tensors, kdtree,\n            radius, n_samples, which_field\n        )\n\n        print(f\"index new = {idx_value}\")\n        # map index to type\n        if abs(idx_value - 0.5) <= 0.1:\n            index_class = 'wedge'\n        elif abs(idx_value + 0.5) <= 0.1:\n            index_class = 'trisector'\n        elif abs(idx_value + 1.0) <= 0.1:\n            index_class = 'saddle'\n        else:\n            index_class = 'merged'\n\n        # if they differ, trust index\n        if index_class != delta_class:\n            return index_class\n        return delta_class\n\n    # -- Approximate Partial Derivatives via Local Regression --------------------\n\n    def approximate_partials(\n        center_idx: int,\n        points: List[rg.Point3d],\n        tensors: List[np.ndarray],\n        kdtree: KDTree,\n        neighbors) -> Optional[Tuple[float, float, float, float]]:\n        \n        # Fit local plane to f=T11-T22 and g=T12 via least squares over nearest neighbors.\n        # For idx_center, take up to `neighbors` nearest points (excluding center).\n        # Returns (a, b, c, d) where:\n        # a=0.5*df/dx, b=0.5*df/dy, c=dg/dx, d=dg/dy.\n        \n        # center coordinates\n        x0, y0 = points[center_idx].X, points[center_idx].Y\n        #print(x0)\n        # query neighbors+1 (including self)\n        dists, idxs = kdtree.query((x0, y0), k=neighbors+1)\n        #print(idxs)\n        # flatten and exclude center\n        all_idxs = list(np.atleast_1d(idxs))\n        neighbor_idxs = [i for i in all_idxs if i != center_idx][:neighbors]\n        print(neighbor_idxs)\n        \n        if not neighbor_idxs:\n            return None\n\n        # build design matrix X = [1, x, y]\n        X = []\n        f_vals = []\n        g_vals = []\n        for j in neighbor_idxs:\n            xj, yj = points[j].X, points[j].Y\n            X.append([1.0, xj, yj])\n            T = tensors[j]\n            f_vals.append(T[0, 0] - T[1, 1])\n            g_vals.append(T[0, 1])\n        X = np.array(X)\n        f_vals = np.array(f_vals)\n        g_vals = np.array(g_vals)\n\n        # solve least squares: f ~ A0 + A1 x + A2 y\n        sol_f, *_ = np.linalg.lstsq(X, f_vals, rcond=None)\n        sol_g, *_ = np.linalg.lstsq(X, g_vals, rcond=None)\n\n        # partials\n        df_dx, df_dy = sol_f[1], sol_f[2]\n        dg_dx, dg_dy = sol_g[1], sol_g[2]\n        return 0.5 * df_dx, 0.5 * df_dy, dg_dx, dg_dy\n\n    # -- Local Eigenvector Retrieval ---------------------------------------------\n\n    def get_local_eigenvectors(\n        x: float,\n        y: float,\n        points: List[rg.Point3d],\n        tensors: List[np.ndarray],\n        kdtree: KDTree,\n        sigma1_vals: List[float],\n        sigma2_vals: List[float],\n        tol: float = 1e-2) -> Tuple[Optional[np.ndarray], Optional[np.ndarray]]:\n        \n        # Find nearest non-degenerate point, return its eigenvectors (p1,p2) sorted by eigenvalue descending.\n        \n        dists, idxs = kdtree.query((x, y), k=5)\n        for dist, idx in zip(np.atleast_1d(dists), np.atleast_1d(idxs)):\n            if abs(sigma1_vals[idx] - sigma2_vals[idx]) > tol:\n                eigvals, eigvecs = np.linalg.eig(tensors[idx])\n                order = np.argsort(eigvals)[::-1]\n                return eigvecs[:,order[0]], eigvecs[:,order[1]]\n        return None, None\n\n    # -- Assign Field Ownership by Slope -----------------------------------------\n\n    def which_field_owns(\n        x0: float,\n        y0: float,\n        slope: float,\n        eps: float,\n        points: List[rg.Point3d],\n        tensors: List[np.ndarray],\n        kdtree: KDTree,\n        sigma1_vals: List[float],\n        sigma2_vals: List[float],\n        tol: float = 1e-2) -> Optional[str]:\n    \n        vec = np.array([1.0, slope])\n        vec /= np.linalg.norm(vec)\n        x_eps, y_eps = x0 + eps*vec[0], y0 + eps*vec[1]\n        p1, p2 = get_local_eigenvectors(x_eps, y_eps, points, tensors, kdtree, sigma1_vals, sigma2_vals, tol)\n        if p1 is None or p2 is None:\n            return None\n        ang1 = math.acos(np.clip(abs(np.dot(vec, p1/np.linalg.norm(p1))), 0, 1))\n        ang2 = math.acos(np.clip(abs(np.dot(vec, p2/np.linalg.norm(p2))), 0, 1))\n        return '1' if ang1 <= ang2 else '2'\n\n    # -- Compute Delmarcelle-Hesselink Index -------------------------------------\n    def compute_index_delmarcelle(\n        x0: float,\n        y0: float,\n        points: List[rg.Point3d],\n        tensors: List[np.ndarray],\n        kdtree: KDTree,\n        radius: float,\n        n_samples: int = 50,\n        which_field: str = 'major') -> Tuple[float, List[Tuple[float,float]]]:\n        \n        # Sample the chosen eigenvector field around a circle and compute its net rotation index.\n        # Returns (index_value, circle_samples).\n        \n        thetas = np.linspace(0, 2*np.pi, n_samples, endpoint=False)\n        alpha = np.zeros(n_samples)\n        pts_circle: List[Tuple[float,float]] = []\n        v_prev = None\n        lam_tol = 1e-10\n        nominal = 0 if which_field.lower().startswith('major') else 1\n\n        for i, th in enumerate(thetas):\n            x_s = x0 + radius*math.cos(th)\n            y_s = y0 + radius*math.sin(th)\n            pts_circle.append((x_s, y_s))\n            _, idx = kdtree.query((x_s, y_s), k=1)\n            vals, vecs = np.linalg.eig(tensors[idx])\n            vals, vecs = np.real(vals), np.real(vecs)\n            order = np.argsort(vals)[::-1]\n            vec = vecs[:, order[nominal]]\n            # branch tracking\n            if abs(vals[0] - vals[1]) < lam_tol and v_prev is not None:\n                d0 = abs(np.dot(v_prev, vecs[:,order[0]]))\n                d1 = abs(np.dot(v_prev, vecs[:,order[1]]))\n                vec = vecs[:, order[1 if d1>d0 else 0]]\n            if v_prev is not None and np.dot(vec, v_prev) < 0:\n                vec = -vec\n            v_prev = vec\n            alpha[i] = math.atan2(vec[1], vec[0])\n\n        # unwrap\n        alpha_u = alpha.copy()\n        for i in range(1, n_samples):\n            diff = alpha[i] - alpha_u[i-1]\n            if diff > math.pi:\n                diff -= 2*math.pi\n            elif diff < -math.pi:\n                diff += 2*math.pi\n            alpha_u[i] = alpha_u[i-1] + diff\n\n        total = alpha_u[-1] - alpha_u[0]\n        return total/(2*math.pi), pts_circle\n\n\n    # -- Main Analysis Function --------------------------------------------------\n    def find_degenerate_points(\n        points: list[rg.Point3d],\n        sigma1_vals: list[float],\n        p1_dirs: list[tuple[float,float,float]],\n        sigma2_vals: list[float],\n        p2_dirs: list[tuple[float,float,float]],\n        tol_deg,\n        offset_eps,\n        slope_tol: float = 0.3,\n        index_radius: float = 0.1\n    ) -> tuple[\n        list[rg.Point2d],\n        list[str],\n        list[list[str]],\n        list[list[tuple[float,float]]],\n        list[float]\n    ]:\n        \n        # Detect degeneracies, classify, extract separatrices, and compute index.\n        # Returns pts2d, types, field_labels, directions, indices\n        \n        assert len(points)==len(sigma1_vals)==len(sigma2_vals)==len(p1_dirs)==len(p2_dirs)\n        # build tensors and tree\n        tensors = [stress_tensor_2d(s1,p1,s2,p2)\n                for s1,p1,s2,p2 in zip(sigma1_vals,p1_dirs,sigma2_vals,p2_dirs)]\n        coords = np.array([(pt.X,pt.Y) for pt in points])\n        kdtree = KDTree(coords)\n\n        pts2d, types, fields_sublists, dirs_sublists, indices = [], [], [], [], []\n        for i, pt in enumerate(points):\n            # skip non-degenerate by eigenvalue gap\n            if abs(sigma1_vals[i]-sigma2_vals[i])>tol_deg:\n                continue\n            derivs = approximate_partials(i, points, tensors, kdtree, neighbors)\n\n            if derivs is None:\n                pts2d.append(rg.Point2d(pt.X, pt.Y)); types.append('uncertain')\n                fields_sublists.append([]); dirs_sublists.append([]); indices.append(0.0)\n                continue\n            a,b,c,d = derivs\n            kind = classify_degenerate(\n                pt.X, pt.Y, points, tensors, kdtree,\n                index_radius, a, b, c, d\n            )\n            # separatrix slopes or sampling\n            slopes = []\n            local_fields, local_dirs = [], []\n            print(kind)\n            if kind in ['wedge','trisector']:\n                slopes = separatrix_slopes(a,b,c,d, imag_tol=slope_tol)\n                for m in slopes:\n                    L = math.hypot(1,m)\n                    for sgn in (1,-1):\n                        sl = sgn*m\n                        label = which_field_owns(\n                            pt.X,pt.Y,sl,offset_eps,\n                            points,tensors,kdtree,\n                            sigma1_vals,sigma2_vals,tol_deg\n                        )\n                        if label:\n                            vec = (sgn/L, sgn*m/L)\n                            local_fields.append(label); local_dirs.append(vec)\n            else:\n                # merged or saddle: fallback sampling\n                p1_vecs, p2_vecs, _ = sample_directions_around_merged_point(\n                    pt.X, pt.Y, points, tensors, kdtree,\n                    n_samples=16, offset_eps=offset_eps, deg_tol=tol_deg\n                )\n                for v in p1_vecs:\n                    local_fields.append('1'); local_dirs.append((v[0],v[1]))\n                for v in p2_vecs:\n                    local_fields.append('2'); local_dirs.append((v[0],v[1]))\n\n            # compute index always\n            idx_val, _ = compute_index_delmarcelle(\n                pt.X, pt.Y, points, tensors, kdtree,\n                radius=index_radius, n_samples=50, which_field='major'\n            )\n            pts2d.append(rg.Point2d(pt.X, pt.Y))\n            types.append(kind)\n            fields_sublists.append(local_fields)\n            dirs_sublists.append(local_dirs)\n            indices.append(idx_val)\n\n        return pts2d, types, fields_sublists, dirs_sublists, indices\n\n\n    def cluster_representatives(\n        pts2d: List[rg.Point2d],\n        types: List[str],\n        fields: List[List[str]],\n        dirs: List[List[Tuple[float,float]]],\n        indices: List[float],\n        threshold: float) -> Tuple[\n        List[rg.Point2d], List[str], List[List[str]], List[List[Tuple[float,float]]], List[float]]:\n        \n        # Group degenerate points within `threshold` distance, then for each cluster\n        # pick the point closest to the cluster mean as representative.\n        \n        coords = np.array([(p.X,p.Y) for p in pts2d])\n        kdtree = KDTree(coords)\n        visited = set()\n        reps_pts, reps_types, reps_fields, reps_dirs, reps_idxs = [], [], [], [], []\n\n        for i in range(len(coords)):\n            if i in visited:\n                continue\n            # build cluster via BFS of neighbors within threshold\n            cluster, queue = [], [i]\n            visited.add(i)\n            while queue:\n                j = queue.pop()\n                cluster.append(j)\n                nbrs = kdtree.query_ball_point(coords[j], r=threshold)\n                for nb in nbrs:\n                    if nb not in visited:\n                        visited.add(nb)\n                        queue.append(nb)\n            # find centroid and closest index\n            pts_arr = coords[cluster]\n            centroid = pts_arr.mean(axis=0)\n            dists = np.linalg.norm(pts_arr - centroid, axis=1)\n            sel = cluster[int(np.argmin(dists))]\n            reps_pts.append(pts2d[sel])\n            reps_types.append(types[sel])\n            reps_fields.append(fields[sel])\n            reps_dirs.append(dirs[sel])\n            reps_idxs.append(indices[sel])\n\n        return reps_pts, reps_types, reps_fields, reps_dirs, reps_idxs\n\n\n\n\n    # 1) Run script\n    pts2d, typs, fl, dl, idxs = find_degenerate_points(\n        points, sigma1_list, p1_list, sigma2_list, p2_list,tol_deg, offset_eps\n    )\n    print(fl)\n\n\n    # 2) cluster degenerate points\n    reps_pts, reps_typs, reps_fl, reps_dl, reps_idx = cluster_representatives(\n        pts2d, typs, fl, dl, idxs, cluster_threshold\n    )\n\n\n    # 3) Sort out vectors for mean degenerate point\n\n    field1_vecs = [\n        [rg.Vector3d(dx, dy, 0) for lbl, (dx, dy) in zip(fl_sub, dl_sub) if lbl == '1']\n        for fl_sub, dl_sub in zip(reps_fl, reps_dl)\n    ]\n    field2_vecs = [\n        [rg.Vector3d(dx, dy, 0) for lbl, (dx, dy) in zip(fl_sub, dl_sub) if lbl == '2']\n        for fl_sub, dl_sub in zip(reps_fl, reps_dl)\n    ]\n\n\n\n    # 3) Set seed amplitude\n    seed_points_field_1 = []\n    for base_pt, vec_list in zip(reps_pts, field1_vecs):\n        sub_list_1 = []\n        for vec in vec_list:\n            if isinstance(base_pt, rg.Point2d):\n                base_pt = rg.Point3d(base_pt.X, base_pt.Y, 0)\n            # convert tuple→Vector3d if needed\n            if isinstance(vec, tuple):\n                v = rg.Vector3d(vec[0], vec[1], 0)\n            else:\n                v = vec\n            # normalize & scale\n            if v.Length > 1e-9:\n                v.Unitize()\n                v *= seed_amplitude\n            # build line\n\n            sub_list_1.append(base_pt + v)\n        seed_points_field_1.append(sub_list_1)\n    print(seed_points_field_1)\n\n\n    seed_points_field_2 = []\n    for base_pt, vec_list in zip(reps_pts, field2_vecs):\n        sub_list_2 = []\n        for vec in vec_list:\n            if isinstance(base_pt, rg.Point2d):\n                base_pt = rg.Point3d(base_pt.X, base_pt.Y, 0)\n            # convert tuple→Vector3d if needed\n            if isinstance(vec, tuple):\n                v = rg.Vector3d(vec[0], vec[1], 0)\n            else:\n                v = vec\n            # normalize & scale\n            if v.Length > 1e-9:\n                v.Unitize()\n                v *= seed_amplitude\n            # build line\n\n            sub_list_2.append(base_pt + v)\n        seed_points_field_2.append(sub_list_2)\n    print(seed_points_field_2)\n\n\n    def project_onto_surface(surface, pt3d):\n            \n            # Projects a point vertically onto a Brep or Surface using Grasshopper's Project component.\n            # Assumes a vertical direction of +Z.\n            \n            # convert inputs\n            gh_pt = rg.Point3d(pt3d[0], pt3d[1], pt3d[2])\n            direction = rg.Vector3d(0, 0, 1)\n            # use GH Project component\n            projected = ghcomp.ProjectPoint(gh_pt, direction, surface)\n        \n            # Project returns a list of projected points; take first\n            if projected and len(projected)>0:\n                return projected[0]\n            return None\n\n    \n    # Map all points on the surface and reconstruct guiding vectors\n    reps_pts = [project_onto_surface(surface,rg.Point3d(p.X, p.Y, -0.01)) for p in reps_pts]\n\n    seed_points_field_1 = [[project_onto_surface(surface,rg.Point3d(p.X, p.Y, -0.01)) for p in sub] for sub in seed_points_field_1]\n    seed_points_field_2 = [[project_onto_surface(surface,rg.Point3d(p.X, p.Y, -0.01)) for p in sub] for sub in seed_points_field_2]\n  \n    field1_vecs = [\n        [\n            rg.Vector3d(\n                seed.X - base_pt.X,\n                seed.Y - base_pt.Y,\n                seed.Z - base_pt.Z\n            )\n            for seed in seed_list\n        ]\n        for base_pt, seed_list in zip(reps_pts, seed_points_field_1)\n    ]\n\n    field2_vecs = [\n        [\n            rg.Vector3d(\n                seed.X - base_pt.X,\n                seed.Y - base_pt.Y,\n                seed.Z - base_pt.Z\n            )\n            for seed in seed_list\n        ]\n        for base_pt, seed_list in zip(reps_pts, seed_points_field_2)\n    ]\n\n\n\n\n\n\n\n    # 3) Output to Grasshopper trees:\n    singularities = reps_pts                                # final degenerate points \n    field_1 = tr.list_to_tree(field1_vecs)                  # direction vectors for field 1\n    field_2 = tr.list_to_tree(field2_vecs)                  # direction vectord for field 2\n    new_seeds_1 = tr.list_to_tree(seed_points_field_1)      # Seeds for field 1\n    new_seeds_2 = tr.list_to_tree(seed_points_field_2)      # Seeds for field 2\n    dege_index = reps_idx                                   # Delmarcelle index\n    dege_type = tr.list_to_tree(reps_typs)                  # Degenerate type\n\n    \n    return singularities, field_1, field_2, new_seeds_1, new_seeds_2, dege_index, dege_type",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}