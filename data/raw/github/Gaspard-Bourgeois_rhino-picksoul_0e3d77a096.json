{
  "source_url": "https://github.com/Gaspard-Bourgeois/rhino-picksoul/blob/9431b8335b62d43ec3539852d1a1af603f0ce1c5/dev/material/getMass.py",
  "repo": "Gaspard-Bourgeois/rhino-picksoul",
  "repo_stars": 1,
  "repo_description": "Generic plugin to manage blocs, materials and trajectories in rhino.",
  "license": "Apache-2.0",
  "filepath": "dev/material/getMass.py",
  "instruction": "Author: Gaspard BOURGEOIS <gaspard.github.io@free.fr>\nVersion: 1.0\nDate: 05/01/26",
  "code": "\"\"\"\nAuthor: Gaspard BOURGEOIS <gaspard.github.io@free.fr>\nVersion: 1.0\nDate: 05/01/26\n\nScript calcul Masse Totale + Sous-totaux par matériau\nCompatible avec la structure de données 'VolumicMass' (kg/m3)\nGère les blocs et les unités du document.\n\"\"\"\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino\nimport math\n\nKEY_NAME = \"VolumicMass\"\n\ndef get_doc_unit_scale_to_meter():\n    \"\"\"\n    Renvoie le facteur pour convertir l'unité du fichier vers le Mètre.\n    Ex: si fichier en mm, renvoie 0.001\n    \"\"\"\n    us = sc.doc.ModelUnitSystem\n    return Rhino.RhinoMath.UnitScale(us, Rhino.UnitSystem.Meters)\n\ndef get_material_density_by_name_logic(mat_name):\n    \"\"\"\n    Retrouve la densité en cherchant le PREMIER matériau portant ce nom,\n    pour rester cohérent avec le script d'entrée.\n    \"\"\"\n    if not mat_name: return 0.0\n    \n    # On cherche le premier matériau qui porte ce nom dans la table\n    for mat in sc.doc.Materials:\n        if mat.Name == mat_name:\n            s_val = mat.GetUserString(KEY_NAME)\n            if s_val:\n                try:\n                    return float(s_val)\n                except:\n                    pass\n            break # On arrête au premier trouvé comme dans le script d'entrée\n    return 0.0\n\ndef get_obj_density(obj_id):\n    \"\"\"\n    Récupère la densité (kg/m3) et le nom du matériau d'un objet\n    en vérifiant Objet > Calque.\n    \"\"\"\n    mat_name = None\n    \n    # 1. Matériau de l'objet\n    mat_index = rs.ObjectMaterialIndex(obj_id)\n    if mat_index > -1:\n        temp_mat = sc.doc.Materials[mat_index]\n        if temp_mat: mat_name = temp_mat.Name\n    \n    # 2. Sinon Matériau du calque\n    if not mat_name:\n        layer_name = rs.ObjectLayer(obj_id)\n        layer_mat_index = rs.LayerMaterialIndex(layer_name)\n        if layer_mat_index > -1:\n            temp_mat = sc.doc.Materials[layer_mat_index]\n            if temp_mat: mat_name = temp_mat.Name\n            \n    if not mat_name:\n        return 0.0, \"Non Defini\"\n\n    density = get_material_density_by_name_logic(mat_name)\n    return density, mat_name\n\ndef calculate_mass_recursive(obj_id, xform, stats_dict, scale_factor):\n    \"\"\"\n    Parcourt récursivement les objets et blocs.\n    xform : matrice de transformation accumulée (pour les blocs imbriqués)\n    scale_factor : conversion unité rhino vers mètre\n    \"\"\"\n    # Si c'est un bloc\n    if rs.IsBlockInstance(obj_id):\n        # Matrice de l'instance\n        inst_xform = rs.BlockInstanceXform(obj_id)\n        # Combinaison avec la transformation parente\n        total_xform = xform * inst_xform\n        \n        block_name = rs.BlockInstanceName(obj_id)\n        block_objs = rs.BlockObjects(block_name)\n        \n        if block_objs:\n            for child in block_objs:\n                calculate_mass_recursive(child, total_xform, stats_dict, scale_factor)\n        return\n\n    # Si c'est une géométrie valide pour le volume\n    if rs.IsPolysurfaceClosed(obj_id) or rs.IsSurfaceClosed(obj_id) or rs.IsMeshClosed(obj_id):\n        \n        # Récupération densité\n        rho, mat_name = get_obj_density(obj_id)\n        \n        if rho <= 0:\n            return # Pas de masse si pas de densité\n\n        # Calcul du volume géométrique brut\n        # On utilise RhinoCommon pour appliquer la transformation (mise à l'échelle du bloc)\n        geo = rs.coercegeometry(obj_id)\n        if not geo: return\n        \n        # On ne transforme pas la géométrie 'physiquement', on calcule le volume\n        # et on applique le déterminant de la matrice pour le scale\n        mp = Rhino.Geometry.VolumeMassProperties.Compute(geo)\n        if not mp: return\n        \n        raw_vol = mp.Volume\n        \n        # Facteur d'échelle du bloc (déterminant de la matrice)\n        # Cela gère si le bloc a été agrandi x2, le volume est x8\n        # On prend la valeur absolue car un miroir rendrait le déterminant négatif\n        det = xform.Determinant\n        final_vol_rhino_units = raw_vol * abs(det)\n        \n        # Conversion en mètres cubes\n        # Si unité = mm, facteur = 0.001. Volume facteur = 0.001^3\n        vol_m3 = final_vol_rhino_units * math.pow(scale_factor, 3)\n        \n        mass = vol_m3 * rho\n\n        # Stockage dans le dictionnaire\n        if mat_name not in stats_dict:\n            stats_dict[mat_name] = 0.0\n        stats_dict[mat_name] += mass\n\ndef main():\n    ids = rs.GetObjects(\"Sélectionnez les objets pour le calcul de masse\", preselect=True)\n    if not ids: return\n\n    # Dictionnaire { \"NomMateriau\": Masse_Totale }\n    stats = {}\n    \n    # Facteur de conversion (ex: 0.001 pour mm)\n    scale_to_meter = get_doc_unit_scale_to_meter()\n    \n    print(\"Calcul en cours...\")\n    rs.EnableRedraw(False)\n    \n    identity = Rhino.Geometry.Transform.Identity\n    \n    for guid in ids:\n        calculate_mass_recursive(guid, identity, stats, scale_to_meter)\n        \n    rs.EnableRedraw(True)\n\n    if not stats:\n        rs.MessageBox(\"Aucun objet valide avec un matériau défini n'a été trouvé.\", 48)\n        return\n\n    total_mass = sum(stats.values())\n    \n    # Construction du message\n    msg = \"MASSE TOTALE : {:.3f} kg\\n\".format(total_mass)\n    msg += \"-\" * 10 + \"Par matériaux\" + \"-\" * 10 + \"\\n\"\n    \n    for name, mass in stats.items():\n        msg += \"{}: {:.3f} kg\\n\".format(name, mass)\n\n    # rs.MessageBox(msg, 64, \"Résultats Masse\")\n    print(msg)\n\nif __name__ == \"__main__\":\n    main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}