{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_extractSelectedFaces.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_extractSelectedFaces.py",
  "instruction": "180612: Created, starting with extractFilletFacesByRadius.py.\r\n181109: Added Opts.  Added bRetainColor option.\r\n181127: Enabled bCopy functionality.\r\n181202, 190325: Updated an import name.\r\n190330:...",
  "code": "\"\"\"\r\n180612: Created, starting with extractFilletFacesByRadius.py.\r\n181109: Added Opts.  Added bRetainColor option.\r\n181127: Enabled bCopy functionality.\r\n181202, 190325: Updated an import name.\r\n190330: Fixed bug concerning single extracted face not being selected.\r\n190429: Added function to handle preselected faces.\r\n191010: Import-related update.\r\n191022: Feedback change.\r\n191101: Import-related update.\r\n250604: Modified a printed feedback.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System.Collections.Generic import List\r\n\r\nimport xBrepObject\r\n\r\n\r\nsOpts = (\r\n        'bAddOnlyMonofaces',\r\n        'bRetainLayer',\r\n        'bRetainColor',\r\n        'bCopy',\r\n        'bEcho',\r\n        'bDebug',\r\n)\r\n\r\n\r\nclass Opts:\r\n    \r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    stickyKeys = {}\r\n    \r\n    @classmethod\r\n    def init(cls):\r\n        \r\n        for key in sOpts:\r\n            cls.keys.append(key)\r\n            cls.names[key] = key[1:] # Overwrite as wanted in the following.\r\n            \r\n        key = 'bAddOnlyMonofaces'\r\n        cls.keys.append(key)\r\n        cls.values[key] = False\r\n        cls.names[key] = key[1:]\r\n        cls.riOpts[key] = ri.Custom.OptionToggle(cls.values[key], 'No', 'Yes')\r\n        cls.stickyKeys[key] = '{}({})'.format(key, __file__)\r\n        \r\n        key = 'bRetainLayer'\r\n        cls.keys.append(key)\r\n        cls.values[key] = True\r\n        cls.names[key] = key[1:]\r\n        cls.riOpts[key] = ri.Custom.OptionToggle(cls.values[key], 'No', 'Yes')\r\n        cls.stickyKeys[key] = '{}({})'.format(key, __file__)\r\n        \r\n        key = 'bRetainColor'\r\n        cls.keys.append(key)\r\n        cls.values[key] = True\r\n        cls.names[key] = key[1:]\r\n        cls.riOpts[key] = ri.Custom.OptionToggle(cls.values[key], 'No', 'Yes')\r\n        cls.stickyKeys[key] = '{}({})'.format(key, __file__)\r\n        \r\n        key = 'bCopy'\r\n        cls.keys.append(key)\r\n        cls.values[key] = False\r\n        cls.names[key] = 'Copy'\r\n        cls.riOpts[key] = ri.Custom.OptionToggle(cls.values[key], 'No', 'Yes')\r\n        cls.stickyKeys[key] = '{}({})'.format(key, __file__)\r\n        \r\n        key = 'bEcho'\r\n        cls.keys.append(key)\r\n        cls.values[key] = True\r\n        cls.names[key] = 'Echo'\r\n        cls.riOpts[key] = ri.Custom.OptionToggle(cls.values[key], 'No', 'Yes')\r\n        cls.stickyKeys[key] = '{}({})'.format(key, __file__)\r\n        \r\n        key = 'bDebug'\r\n        cls.keys.append(key)\r\n        cls.values[key] = False\r\n        cls.names[key] = 'Debug'\r\n        cls.riOpts[key] = ri.Custom.OptionToggle(cls.values[key], 'No', 'Yes')\r\n        cls.stickyKeys[key] = '{}({})'.format(key, __file__)\r\n        \r\n        # Load sticky.\r\n        for key in cls.stickyKeys:\r\n            if sc.sticky.has_key(cls.stickyKeys[key]):\r\n                if cls.riOpts[key]:\r\n                    cls.values[key] = cls.riOpts[key].CurrentValue = sc.sticky[cls.stickyKeys[key]]\r\n                else:\r\n                    # For OptionList.\r\n                    cls.values[key] = sc.sticky[cls.stickyKeys[key]]\r\n    \r\n    @classmethod\r\n    def addOptions(cls, go, sInclude=None):\r\n        if sInclude is None:\r\n            sInclude = cls.keys[:]\r\n        if not sInclude: return\r\n        \r\n        def addOptionDouble(key, lower=None, upper=None):\r\n            if key in sInclude:\r\n                go.AddOptionDouble(cls.names[key], cls.riOpts[key])\r\n        \r\n        def addOptionInteger(key):\r\n            if key in sInclude:\r\n                go.AddOptionInteger(cls.names[key], cls.riOpts[key])\r\n        \r\n        def addOptionToggle(key):\r\n            if key in sInclude:\r\n                go.AddOptionToggle(cls.names[key], cls.riOpts[key])\r\n        \r\n        addOptionToggle('bAddOnlyMonofaces')\r\n        addOptionToggle('bRetainLayer')\r\n        addOptionToggle('bRetainColor')\r\n        addOptionToggle('bCopy')\r\n        addOptionToggle('bEcho')\r\n        addOptionToggle('bDebug')\r\n    \r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.stickyKeys:\r\n            if cls.riOpts[key]:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                # For OptionList.\r\n                pass\r\n    \r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if cls.riOpts[key]:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                # For OptionList.\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n    \r\n    @classmethod\r\n    def processInput(cls, go):\r\n        res = go.Result()\r\n        \r\n        cls.setValues()\r\n        cls.saveSticky()\r\n        \r\n        # Clear and add options regardless if a number was entered or options were modified in another way.\r\n        go.ClearCommandOptions()\r\n        Opts.addOptions(go)\r\nOpts.init()\r\n\r\n\r\ndef getPreselectedFaceInput():\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    go = ri.Custom.GetObject()\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Surface\r\n    go.EnablePreSelect(enable=True, ignoreUnacceptablePreselectedObjects=False)\r\n    go.EnablePostSelect(enable=False)\r\n    res = go.GetMultiple(1,0)\r\n    \r\n    if res != ri.GetResult.Object: return\r\n    \r\n    gBreps = []\r\n    idx_Faces_AllBreps = []\r\n    \r\n    # Prepare lists of brep GUIDs and face indices.\r\n    for objref in go.Objects():\r\n        gBrep = objref.ObjectId\r\n        if gBrep in gBreps:\r\n            idx_Faces_AllBreps[gBreps.index(gBrep)].append(objref.Face().FaceIndex)\r\n        else:\r\n            gBreps.append(gBrep)\r\n            idx_Faces_AllBreps.append([objref.Face().FaceIndex])\r\n            rdBrep = sc.doc.Objects.Find(gBrep)\r\n    \r\n    sc.doc.Objects.UnselectAll()\r\n    \r\n    gopt = ri.Custom.GetOption()\r\n    gopt.SetCommandPrompt(\"Set options for preselected faces\")\r\n    \r\n    gopt.AcceptNothing(enable=True)\r\n    \r\n    Opts.addOptions(gopt)\r\n    \r\n    while True:\r\n        res = gopt.Get()\r\n        \r\n        if res == ri.GetResult.Nothing:\r\n            break\r\n        elif res == ri.GetResult.Cancel:\r\n            return\r\n        else:\r\n            # An option was selected or a number was entered.\r\n            Opts.processInput(gopt)\r\n    \r\n    return (\r\n            gBreps,\r\n            idx_Faces_AllBreps,\r\n            Opts.values['bAddOnlyMonofaces'],\r\n            Opts.values['bRetainLayer'],\r\n            Opts.values['bRetainColor'],\r\n            Opts.values['bCopy'],\r\n            Opts.values['bEcho'],\r\n            Opts.values['bDebug'])\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    # Get breps with optional input\r\n    \r\n    go = ri.Custom.GetObject()\r\n    go.SetCommandPrompt(\"Select faces to extract\")\r\n    \r\n    go.GeometryFilter = rd.ObjectType.Surface\r\n    \r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Keep objects in go on repeats of While loop.\r\n    #go.EnableUnselectObjectsOnExit(False)\r\n    \r\n    #sc.doc.Objects.UnselectAll()\r\n    sc.doc.Views.Redraw()\r\n    \r\n    Opts.addOptions(go)\r\n    \r\n    while True:\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n        \r\n        if res == ri.GetResult.Object:\r\n            break\r\n        elif res == ri.GetResult.Cancel:\r\n            return\r\n        else:\r\n            # An option was selected or a number was entered.\r\n            Opts.processInput(go)\r\n        \r\n        # Rehighlight faces already selected.\r\n        for objref in go.Objects():\r\n            objref.Object().HighlightSubObject(\r\n                    componentIndex=objref.GeometryComponentIndex,\r\n                    highlight=True)\r\n        sc.doc.Views.Redraw()\r\n    \r\n    gBreps = []\r\n    idx_Faces_AllBreps = []\r\n    \r\n    # Prepare lists of brep GUIDs and face indices.\r\n    for objref in go.Objects():\r\n        gBrep = objref.ObjectId\r\n        if gBrep in gBreps:\r\n            idx_Faces_AllBreps[gBreps.index(gBrep)].append(objref.Face().FaceIndex)\r\n        else:\r\n            gBreps.append(gBrep)\r\n            idx_Faces_AllBreps.append([objref.Face().FaceIndex])\r\n            rdBrep = sc.doc.Objects.Find(gBrep)\r\n            #rdBrep.Highlight(enable=False)\r\n    \r\n    # Unselect any non-surface preselections.\r\n    sc.doc.Objects.UnselectAll()\r\n    sc.doc.Views.Redraw()\r\n    \r\n    return (\r\n            gBreps,\r\n            idx_Faces_AllBreps,\r\n            Opts.values['bAddOnlyMonofaces'],\r\n            Opts.values['bRetainLayer'],\r\n            Opts.values['bRetainColor'],\r\n            Opts.values['bCopy'],\r\n            Opts.values['bEcho'],\r\n            Opts.values['bDebug'])\r\n\r\n\r\ndef processBrepObjects(gBreps0, idx_Faces_AllBreps, bAddOnlyMonofaces=None, bRetainLayer=None, bRetainColor=None, bCopy=None, bEcho=None, bDebug=None):\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    if bAddOnlyMonofaces is None: bAddOnlyMonofaces = Opts.values['bAddOnlyMonofaces']\r\n    if bRetainLayer is None: bRetainLayer = Opts.values['bRetainLayer']\r\n    if bRetainColor is None: bRetainColor = Opts.values['bRetainColor']\r\n    if bCopy is None: bCopy = Opts.values['bCopy']\r\n    if bEcho is None: bEcho = Opts.values['bEcho']\r\n    if bDebug is None: bDebug = Opts.values['bDebug']\r\n    \r\n    try:\r\n        gBreps0 = list(gBreps0)\r\n        try:\r\n            dummy = list(idx_Faces_AllBreps[0])\r\n            idx_Faces_AllBreps = list(idx_Faces_AllBreps)\r\n        except:\r\n            idx_Faces_AllBreps = [idx_Faces_AllBreps]\r\n    except:\r\n        gBreps0 = [gBreps0]\r\n        idx_Faces_AllBreps = [idx_Faces_AllBreps] # Based on an assumption.  (Not fail-safe.)\r\n    \r\n    gExtracted_All = [] # Accumulation of duplicated faces (breps)\r\n    \r\n    for gBrep0, idx_rgFaces in zip(gBreps0, idx_Faces_AllBreps):\r\n        if bCopy:\r\n            gExtracted = xBrepObject.addFromSubsetOfFaces(\r\n                    gBrep0,\r\n                    idx_rgFaces,\r\n                    bAddOnlyMonofaces=bAddOnlyMonofaces,\r\n                    bRetainLayer=bRetainLayer,\r\n                    bRetainColor=bRetainColor,\r\n            )\r\n            if gExtracted is None:\r\n                print \"Faces could not be duplicated.\"\r\n                gExtracted = []\r\n        else:\r\n            # Extract faces.\r\n            rc = xBrepObject.extractFaces(\r\n                    gBrep0,\r\n                    idx_rgFaces,\r\n                    bAddOnlyMonofaces=bAddOnlyMonofaces,\r\n                    bRetainLayer=bRetainLayer,\r\n                    bRetainColor=bRetainColor,\r\n            )\r\n            if rc is None:\r\n                print \"Faces could not be extracted.\"\r\n                gExtracted = []\r\n            else: gExtracted = rc[0]\r\n                \r\n        \r\n        if gExtracted is not None:\r\n            gExtracted_All.extend(gExtracted)\r\n    \r\n    count_Selected = sc.doc.Objects.Select(List[Guid](gExtracted_All))\r\n    \r\n    if not count_Selected:\r\n        print \"Face(s) could not be extracted.  Is the polyfaced brep invalid?\"\r\n    else:\r\n        print \"{} brep(s) are selected.\".format(count_Selected)\r\n    \r\n    return gExtracted_All\r\n\r\n\r\ndef main(bEcho=True, bDebug=False):\r\n    \r\n    rc = getPreselectedFaceInput() if Rhino.RhinoApp.ExeVersion >= 6 else None\r\n    if rc is not None:\r\n        (\r\n                gBreps0,\r\n                idx_Faces_AllBreps,\r\n                bAddOnlyMonofaces,\r\n                bRetainLayer,\r\n                bRetainColor,\r\n                bCopy,\r\n                bEcho,\r\n                bDebug) = rc\r\n    else:\r\n        rc = getInput()\r\n        if rc is None: return\r\n        (\r\n                gBreps0,\r\n                idx_Faces_AllBreps,\r\n                bAddOnlyMonofaces,\r\n                bRetainLayer,\r\n                bRetainColor,\r\n                bCopy,\r\n                bEcho,\r\n                bDebug) = rc\r\n    \r\n    if bDebug:\r\n        reload(xBrepObject)\r\n    \r\n    processBrepObjects(\r\n            gBreps0=gBreps0,\r\n            idx_Faces_AllBreps=idx_Faces_AllBreps)\r\n    \r\n    sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main(bEcho=bool(1), bDebug=bool(0))",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}