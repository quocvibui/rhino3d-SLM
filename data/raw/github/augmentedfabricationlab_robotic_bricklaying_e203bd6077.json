{
  "source_url": "https://github.com/augmentedfabricationlab/robotic_bricklaying/blob/c06382f839cba10598d416651b1e0051bac0d300/src/robotic_bricklaying/assembly/reference_model.py",
  "repo": "augmentedfabricationlab/robotic_bricklaying",
  "repo_stars": 0,
  "repo_description": null,
  "license": "MIT",
  "filepath": "src/robotic_bricklaying/assembly/reference_model.py",
  "instruction": "Reference model",
  "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport json\nimport math as m\n\n#from compas_fab.robots import JointTrajectoryPoint\n\nfrom compas.datastructures import CellNetwork, Mesh\nfrom compas.geometry import Frame, Vector\nfrom compas_rhino.conversions import mesh_to_compas, point_to_rhino, mesh_to_rhino, vector_to_rhino\nimport Rhino.Geometry as rg\n\nclass CAEReferenceModel(CellNetwork):\n    \"\"\"A data structure for the climate active envelopes' cellnetwork \n    containing the information of building components.\n\n    The reference model is essentially a cellnetwork consisting of a \n    set of cells that contain the information of building component, \n    i.e., outer walls, inner walls, slabs.\n    Each building component is represented by a face of the cellnetwork.\n    Each interface or connection between components is represented by an edge of the cellnetwork.\n\n    Attributes\n    ----------\n\n\n    Examples\n    --------\n\n    \"\"\"\n\n    def __init__(self, frame=None):\n        self.frame = frame #origin frame\n        CellNetwork.__init__(self)\n\n    def initialize_network(self):\n        \"\"\"Initialize the cell network by sorting faces and edges by type.\"\"\"\n        self.sort_faces_by_type()\n        self.sort_edges_by_type()\n\n    def find_or_add_vertex(self, x, y, z):\n        for vkey in self.vertices():\n            vx, vy, vz = self.vertex_coordinates(vkey)\n            if vx == x and vy == y and vz == z:\n                return vkey\n        return self.add_vertex(x=x, y=y, z=z)\n\n    def create_cell_network(self, meshes):\n        \"\"\"Create a cell network from a list of meshes.\n        \n        Parameters\n        ----------\n        meshes : list\n            A list of meshes to create the cell network.\n        \n        Returns\n        -------\n        object\n            The cell network data structure.        \n        \"\"\"\n\n        for mesh in meshes:\n            face_keys = []\n            for fkey in mesh.faces():\n                face_vertices = []\n                for vkey in mesh.face_vertices(fkey):\n                    x, y, z = mesh.vertex_coordinates(vkey)\n                    vertex = self.find_or_add_vertex(x, y, z) \n                    face_vertices.append(vertex)\n                \n                face_exists = False\n                for existing_face in self.faces(): \n                    existing_face_vertices = self.face_vertices(existing_face) \n                    if set(face_vertices) == set(existing_face_vertices):\n                        face_key = existing_face\n                        face_exists = True\n                \n                if not face_exists:\n                    face_key = self.add_face(face_vertices) \n                \n                face_keys.append(face_key)\n            self.add_cell(face_keys) \n\n        return self \n    \n    def create_face_cell_dict(self):\n        \"\"\"Sort faces to corresponding cells.\n\n        Parameters:\n        ----------\n        cell_network : :class:`CellNetwork`\n            The cell network data structure.\n        \n        Returns\n        -------\n        dict\n            A dictionary with faces and corresponding cells.\n        \"\"\"\n        #List of the faces in the corresponding cells\n        sort_faces_in_cells = []\n        for cell in self.cells():\n            for face in self.cell_faces(cell):\n                sort_faces_in_cells.append((face, cell))\n\n        # Store faces with its corresponding cell\n        faces_to_cell_dict = {}\n        for face, cell in sort_faces_in_cells:\n            if face not in faces_to_cell_dict:\n                faces_to_cell_dict[face] = []\n            faces_to_cell_dict[face].append(cell)\n             \n        return faces_to_cell_dict\n    \n    def sort_faces_by_type(self):\n        \"\"\"Sort faces by building type.\n\n        Parameters\n        ----------\n        cell_network : :class:`CellNetwork`\n            The cell network data structure.\n        \n        Returns\n        -------\n        list\n            A list of faces sorted by type.\n        \"\"\"\n\n        face_types = {'walls': [], 'slabs': []}\n\n        # Create a dictionary mapping faces to cells\n        faces_to_cells_dict = self.create_face_cell_dict()\n\n        # Classify faces as 'outer walls' or 'slabs'\n        for face, cell in faces_to_cells_dict.items():\n            normal = self.face_normal(face)\n            #face between minimum two cells and within the vertical faces\n            if len(cell) >= 2 and (normal[1] in [-1, 1] or normal[0] in [-1, 1]): \n                face_type = 'inner wall'\n                face_types['walls'].append((face, face_type))\n\n            # within vertical faces and not between two cells    \n            elif normal[1] in [-1, 1] or normal[0] in [-1, 1]:  \n                face_type = 'outer wall'\n                face_types['walls'].append((face, face_type))\n\n            # all horizontal faces\n            else: #normal[2] in [-1, 1] as horizontal faces\n                face_type = 'slab'\n                face_types['slabs'].append((face, face_type))\n\n            self.face_attribute(face, 'face_type', face_type)\n\n        self.face_types = face_types\n\n        return face_types\n    \n\n    def get_face_types(self):\n        \"\"\"Get the face types from the cell network.\n\n        Parameters\n        ----------\n        cell_network : :class:`CellNetwork`\n            The cell network data structure.\n        \n        Returns\n        -------\n        dict\n            A dictionary with face types.\n        \"\"\"\n        return getattr(self, 'edge_types', {'walls': [], 'slabs': []})\n    \n    \n    def create_edge_cell_dict(self):\n        \"\"\"Sort faces to corresponding cells.\n\n        Parameters:\n        ----------\n        cell_network : :class:`CellNetwork`\n            The cell network data structure.\n        \n        Returns\n        -------\n        dict\n            A dictionary with faces and corresponding cells.\n        \"\"\"\n        sort_edges_in_cells = []\n        for cell in self.cells():\n            cell_edges = []\n            for edge in self.cell_edges(cell):\n                u, v = edge\n                if (u, v) not in cell_edges and (v, u) not in cell_edges:\n                    cell_edges.append((u, v))\n                    sort_edges_in_cells.append((edge, cell))\n\n        edges_to_cell_dict = {}\n        for edge, cell in sort_edges_in_cells:\n            if edge not in edges_to_cell_dict and (edge[1], edge[0]) not in edges_to_cell_dict:\n                edges_to_cell_dict[edge] = []\n            if edge in edges_to_cell_dict:\n                edges_to_cell_dict[edge].append(cell)\n            elif (edge[1], edge[0]) in edges_to_cell_dict:\n                edges_to_cell_dict[(edge[1], edge[0])].append(cell)\n             \n        return edges_to_cell_dict\n    \n    def sort_edges_by_type(self):\n        \"\"\"Sort edges by type.\n\n        Parameters\n        ----------\n        cell_network : :class:`CellNetwork`\n            The cell network data structure.\n        \n        Returns\n        -------\n        list\n            A list of edges sorted by type.\n        \"\"\"\n\n        edge_types = {'vertical_edges': [], 'horizontal_edges': []}\n\n        # Create a dictionary mapping faces to cells\n        edges_to_cells_dict = self.create_edge_cell_dict()\n\n        # Classify faces as 'outer walls' or 'slabs'\n        for edge, cell in edges_to_cells_dict.items():\n            direction_vector = self.edge_vector(edge)\n            direction_vector.unitize()\n\n            if len(cell) >= 2 and (direction_vector[2] in [-1, 1]):\n                edge_type = 'joint'\n                edge_types['vertical_edges'].append((edge, edge_type))\n\n            elif direction_vector[2] in [-1, 1]:\n                edge_type = 'corner'\n                edge_types['vertical_edges'].append((edge, edge_type))\n            else:\n                edge_type = 'beam'\n                edge_types['horizontal_edges'].append((edge, edge_type))\n\n            self.edge_attribute(edge, 'edge_type', edge_type)\n\n        self.edge_types = edge_types\n\n        return edge_types\n    \n\n    def get_edge_types(self):\n        \"\"\"Get the edge types from the cell network.\n\n        Parameters\n        ----------\n        cell_network : :class:`CellNetwork`\n            The cell network data structure.\n        \n        Returns\n        -------\n        dict\n            A dictionary with edge types.\n        \"\"\"\n        return getattr('edge_types', {'vertical_edges': [], 'horizontal_edges': []})\n\n\n\n    def select_face_by_fkey(self, face_key):\n        \"\"\"Select the face by key from the cell network.\n\n        Parameters\n        ----------\n        cell_network : :class:`CellNetwork`\n            The cell network data structure.  \n        face_key : int\n            The key of the face to select.\n\n        Returns\n        -------\n        object\n            The selected face.\n        \"\"\"\n\n        for key, face in enumerate(self.faces()):\n            if key == face_key:\n                selected_face = face\n                face_type = self.face_attribute(face, 'face_type')\n\n        return selected_face, face_type\n    \n\n    def select_edge_by_ekey(self, edge_key):\n        \"\"\"Select the edge by key from the cell network.\n\n        Parameters\n        ----------\n        cell_network : :class:`CellNetwork`\n            The cell network data structure.\n        edge_key : int\n            The key of the edge to select.\n\n        Returns\n        -------\n        object\n            The selected edge.\n        \"\"\"\n\n        for key, edge in enumerate(self.edges()):\n            if key == edge_key:\n                selected_edge = edge\n                edge_type = self.edge_attribute(edge, 'edge_type')\n\n        return selected_edge, edge_type\n\n\n    def select_edge_and_get_adjacent_faces(self, edge_key):\n        \"\"\"Select adjacent faces by the selected edge and sort them by type.\n\n        Parameters\n        ----------\n        cell_network : :class:`CellNetwork`\n            The cell network data structure.\n        edge_key : int\n            The key of the edge to select.\n\n        Returns\n        -------\n        dict\n            A dictionary with sorted faces and edges by type.\n        \"\"\"\n        \n        selected_edge, edge_type = self.select_edge_by_ekey(edge_key)\n        selected_edge_faces = self.edge_faces(selected_edge)\n\n        # Create a dictionary to store the selected edge and its adjacent faces\n        edge_and_faces = {\n            'selected_edge': selected_edge,\n            'edge_type': edge_type,\n            'selected_edge_faces': []\n        }\n\n        # Add edge_type for each selected_edge_face\n        for face in selected_edge_faces:\n            face_type = self.face_attribute(face, 'face_type')\n            edge_and_faces['selected_edge_faces'].append({\n                'face': face,\n                'face_type': face_type\n            })\n\n        return edge_and_faces\n\n\n    def select_face_and_get_adjacent_edges(self, face_key):\n        \"\"\"Select adjacent edges by the selected face and sort them by type.\n\n        Parameters\n        ----------\n        cell_network : :class:`CellNetwork`\n            The cell network data structure.\n        face_key : int\n            The key of the face to select.\n        \n        Returns\n        -------\n        dict\n            A dictionary with sorted edges and faces by type.\n        \"\"\"\n        # Select the face by key\n        current_face, face_type = self.select_face_by_fkey(face_key)\n\n        # Get the edges of the selected face\n        face_edges = self.face_edges(current_face)\n\n        #edge_types = self.get_edge_types()\n\n        face_and_edges = {\n            'selected_face': current_face,\n            'face_type': face_type,\n            #'face_edges': [],\n            'vertical_edges': [],\n            'horizontal_edges': []\n        }\n\n        # Add edge_type for each face_edge and classify them as vertical or horizontal\n        for edge in face_edges:\n            edge_type = self.edge_attribute(edge, 'edge_type')\n            # face_and_edges['face_edges'].append({\n            #     'edge': edge,\n            #     'edge_type': edge_type\n            # })\n            if edge_type in ['joint', 'corner']:  # Assuming 'joint' and 'corner' are vertical\n                face_and_edges['vertical_edges'].append({\n                    'edge': edge,\n                    'edge_type': edge_type\n                })\n            else:  # Assuming other types are horizontal\n                face_and_edges['horizontal_edges'].append({\n                    'edge': edge,\n                    'edge_type': edge_type\n                })\n\n        return face_and_edges\n\n    def select_face_neighbors(self, face_key):\n        \"\"\"Select the face neighbors of a face in the cell.\n        \n        Parameters\n        ----------\n        cell_network : :class:`CellNetwork`\n            The cell network data structure.\n            \n        Returns\n        -------\n        dict\n            A dictionary of face neighbors.\n        \"\"\"\n        current_face, face_type = self.select_face_by_fkey(face_key)\n        \n        neighbor_face_types = []\n        neighbors = []\n\n        # Find all neighboring faces of the current_face through its edges\n        for edge in self.face_edges(current_face):\n            edge_faces = self.edge_faces(edge)\n            for neighbor in edge_faces:\n                if neighbor != current_face: # and neighbor not in all_neighbors\n                    neighbors.append(neighbor)\n                    face_type = self.face_attribute(neighbor, 'face_type')\n                    neighbor_face_types.append((neighbor, face_type))\n\n        return neighbors, neighbor_face_types\n    \n    def get_shared_edge(self, current_face, face_neighbors, edge_key):\n        \"\"\"Get the shared edge of two neighboring faces in the cell network.\n\n        Parameters\n        ----------\n        cell_network : :class:`CellNetwork`\n            The cell network data structure.\n        edge_key : int\n            The key of the edge to select.\n\n        Returns\n        -------\n        int\n            The key and edge type of the shared edge.\n        \"\"\"\n\n        for i, face in enumerate(face_neighbors): \n            if i < edge_key: #if the face is before the current face\n                neighbor_face = face \n\n        neighbor_face_edges = self.face_edges(neighbor_face)\n        current_face_edges = self.face_edges(current_face)\n\n        for u, v in neighbor_face_edges:\n            if (u, v) in current_face_edges or (v, u) in current_face_edges:\n                shared_edge = (u, v)\n\n                edge_type = self.edge_attribute(shared_edge, 'edge_type')\n\n        return shared_edge, edge_type\n\n\n    def outer_wall_attributes(self, cell_network, window_curve=None):\n        \"\"\"Assign attributes to outer walls.\n        \n        Parameters\n        ----------\n        cell_network : :class:`CellNetwork`\n            The cell network data structure.\n        window_curve : :class:`Curve`\n            The curve representing the window.\n        Returns\n        -------\n        dict\n            A dictionary of outer walls with attributes.\n        \"\"\"\n\n        pass\n\n    def generate_assembly_data(self, mesh, course_height, input_type):\n\n        \"\"\"Calculate the properties of the wall faces in the cell network or COMPAS mesh.\n\n        Parameters\n        ----------\n        input_data : :class:`CellNetwork` or :class:`Mesh`\n            The cell network or COMPAS mesh data structure.\n        course_height : float\n            The height of the course.\n        input_type : str, optional\n            The type of input data, either 'reference_model' or 'mesh'.\n        \n        Returns\n        -------\n        dict\n            A dictionary of wall face edges.\n        \"\"\"\n\n        if input_type == 'reference_model':\n            face = self.current_face\n            face_normal = vector_to_rhino(self.face_normal(face))\n            face_edges_data = self.select_face_and_get_adjacent_edges(face)\n            \n            vertical_edges = [edge['edge'] for edge in face_edges_data['vertical_edges']]\n            edge_height = abs(self.edge_length(vertical_edges[0]))\n\n            start_edge = vertical_edges[-1]\n            end_edge = vertical_edges[0]\n            start_edge_type = self.edge_attribute(start_edge, 'edge_type')\n            end_edge_type = self.edge_attribute(end_edge, 'edge_type')\n\n            horizontal_edges = [edge['edge'] for edge in face_edges_data['horizontal_edges']]\n            edge_length = abs(self.edge_length(horizontal_edges[0]))\n\n            horizontal_edge_vector = self.edge_vector(horizontal_edges[0])\n            horizontal_edge_vector.unitize()\n\n            direction_vector = vector_to_rhino(horizontal_edge_vector)\n\n            curve_start_point = self.edge_start(horizontal_edges[0])\n            curve_end_point = self.edge_end(horizontal_edges[0])\n\n        elif input_type == 'mesh':\n            face = 0\n            face_normal = vector_to_rhino(mesh.face_normal(face))\n            face_edges = mesh.face_halfedges(face)\n\n            vertical_edges = [edge for edge in face_edges if abs(mesh.edge_vector(edge)[2]) > 0]\n            edge_height = abs(mesh.edge_length(vertical_edges[0]))\n\n            start_edge = vertical_edges[-1]\n            end_edge = vertical_edges[0]\n\n            # Set edge_type to \"nothing attaching\"\n            mesh.edge_attribute(start_edge, 'edge_type', 'nothing attaching')\n            mesh.edge_attribute(end_edge, 'edge_type', 'nothing attaching')\n\n            start_edge_type = mesh.edge_attribute(start_edge, 'edge_type')\n            end_edge_type = mesh.edge_attribute(end_edge, 'edge_type')\n\n            # Set face_type to \"outer wall\"\n            mesh.face_attribute(face, 'face_type', 'outer wall')\n\n            horizontal_edges = [edge for edge in face_edges if abs(mesh.edge_vector(edge)[2]) == 0]\n            edge_length = abs(mesh.edge_length(horizontal_edges[0]))\n\n            horizontal_edge_vector = mesh.edge_vector(horizontal_edges[0])\n            horizontal_edge_vector.unitize()\n\n            direction_vector = vector_to_rhino(horizontal_edge_vector)\n\n            curve_start_point = mesh.vertex_coordinates(horizontal_edges[0][0])\n            curve_end_point = mesh.vertex_coordinates(horizontal_edges[0][1])\n\n        else:\n            raise ValueError(\"Invalid input_type. Must be 'reference_model' or 'mesh'.\")\n\n        num_courses = abs(edge_height / course_height)\n\n        if input_type == 'reference_model':\n            self.face_attribute(face, 'start_edge', start_edge)\n            self.face_attribute(face, 'start_edge_type', start_edge_type)\n            self.face_attribute(face, 'end_edge', end_edge)\n            self.face_attribute(face, 'end_edge_type', end_edge_type)\n            self.face_attribute(face, 'direction_vector', direction_vector)\n        elif input_type == 'mesh':\n            mesh.face_attribute(face, 'start_edge', start_edge)\n            mesh.face_attribute(face, 'start_edge_type', start_edge_type)\n            mesh.face_attribute(face, 'end_edge', end_edge)\n            mesh.face_attribute(face, 'end_edge_type', end_edge_type)\n            mesh.face_attribute(face, 'direction_vector', direction_vector)\n\n        return {\n            'face': face,\n            'face_type': self.face_attribute(face, 'face_type'),\n            'start_edge': start_edge,\n            'start_edge_type': start_edge_type,\n            'end_edge': end_edge,\n            'end_edge_type': end_edge_type,\n            'direction_vector': direction_vector,\n            'edge_height': edge_height,\n            'edge_length': edge_length,\n            'num_courses': num_courses,\n            'curve_start_point': curve_start_point,\n            'curve_end_point': curve_end_point,\n            'face_normal': face_normal\n        }\n    # def generate_assembly_data_from_cellnetwork(self, cell_network, course_height):\n    #     \"\"\"Calculate the properties of the wall faces in the cell network.\n\n    #     Parameters\n    #     ----------\n    #     cell_network : :class:`CellNetwork`\n    #         The cell network data structure.\n    #     face : int\n    #         The current_face to select.\n    #     course_height : float\n    #         The height of the course.\n        \n    #     Returns\n    #     -------\n    #     dict\n    #         A dictionary of wall face edges.\n    #     \"\"\"\n    #     face = cell_network.current_face\n    #     face_normal = vector_to_rhino(cell_network.face_normal(face))\n\n    #     face_edges_data = self.select_face_and_get_adjacent_edges(cell_network, face)\n        \n    #     # Get the height of the vertical edge\n    #     vertical_edges = [edge['edge'] for edge in face_edges_data['vertical_edges']]\n    #     edge_height = abs(cell_network.edge_length(vertical_edges[0]))\n\n    #     # Identify the starting and ending edges\n    #     start_edge = vertical_edges[-1]\n    #     end_edge = vertical_edges[0]\n    #     start_edge_type = cell_network.edge_attribute(start_edge, 'edge_type')\n    #     end_edge_type = cell_network.edge_attribute(end_edge, 'edge_type')\n\n    #     # Get the length of the horizontal edge\n    #     horizontal_edges = [edge['edge'] for edge in face_edges_data['horizontal_edges']]\n    #     edge_length = abs(cell_network.edge_length(horizontal_edges[0]))\n\n    #     # Get the direction vector of the first horizontal edge\n    #     horizontal_edge_vector = cell_network.edge_vector(horizontal_edges[0])\n    #     horizontal_edge_vector.unitize()\n\n    #     # Handle different orientations explicitly\n    #     direction_vector = vector_to_rhino(horizontal_edge_vector)\n\n    #     curve_start_point = cell_network.edge_start(horizontal_edges[0])\n    #     curve_end_point = cell_network.edge_end(horizontal_edges[0])\n\n    #     print(f\"Initial curve_start_point: {edge_length}\")\n    #     print(f\"Initial curve_end_point: {edge_height}\")\n\n    #     num_courses = abs(edge_height / course_height)\n\n    #     # Add starting and ending edges and their types as attributes to the current face\n    #     cell_network.face_attribute(face, 'start_edge', start_edge)\n    #     cell_network.face_attribute(face, 'start_edge_type', start_edge_type)\n    #     cell_network.face_attribute(face, 'end_edge', end_edge)\n    #     cell_network.face_attribute(face, 'end_edge_type', end_edge_type)\n    #     cell_network.face_attribute(face, 'direction_vector', direction_vector)\n\n    #     return {\n    #         'face': face_edges_data['selected_face'],\n    #         'face_type': face_edges_data['face_type'],\n    #         'start_edge': start_edge,\n    #         'start_edge_type': start_edge_type,\n    #         'end_edge': end_edge,\n    #         'end_edge_type': end_edge_type,\n    #         'direction_vector': direction_vector,\n    #         'edge_height': edge_height,\n    #         'edge_length': edge_length,\n    #         'num_courses': num_courses,\n    #         'curve_start_point': curve_start_point,\n    #         'curve_end_point': curve_end_point,\n    #         'face_normal': face_normal\n    #     } \n    \n    # def generate_assembly_data_from_mesh_face(self, mesh, course_height):\n        \"\"\"Calculate the properties of the wall faces in the COMPAS mesh.\n\n        Parameters\n        ----------\n        mesh : :class:`Mesh`\n            The COMPAS mesh data structure.\n        face_key : int\n            The key of the face to select.\n        course_height : float\n            The height of the course.\n        \n        Returns\n        -------\n        dict\n            A dictionary of wall face edges.\n        \"\"\"\n        face_normal = vector_to_rhino(mesh.face_normal(0))\n        face_edges = mesh.face_halfedges(0)\n\n        # Get the height of the vertical edge\n        vertical_edges = [edge for edge in face_edges if abs(mesh.edge_vector(edge)[2]) > 0]\n        edge_height = abs(mesh.edge_length(vertical_edges[0]))\n\n        # Identify the starting and ending edges\n        start_edge = vertical_edges[-1]\n        end_edge = vertical_edges[0]\n\n        start_edge_type = mesh.edge_attribute(start_edge, 'edge_type')\n        end_edge_type = mesh.edge_attribute(end_edge, 'edge_type')\n\n        # Get the length of the horizontal edge\n        horizontal_edges = [edge for edge in face_edges if abs(mesh.edge_vector(edge)[2]) == 0]\n        edge_length = abs(mesh.edge_length(horizontal_edges[0]))\n\n\n        # Get the direction vector of the first horizontal edge\n        horizontal_edge_vector = mesh.edge_vector(horizontal_edges[0])\n        horizontal_edge_vector.unitize()\n\n        # Handle different orientations explicitly\n        direction_vector = vector_to_rhino(horizontal_edge_vector)\n\n        curve_start_point = mesh.vertex_coordinates(horizontal_edges[0][0])\n        curve_end_point = mesh.vertex_coordinates(horizontal_edges[0][1])\n\n        print(f\"Initial curve_start_point: {edge_length}\")\n        print(f\"Initial curve_end_point: {edge_height}\")\n\n        num_courses = abs(edge_height / course_height)\n\n        # Add starting and ending edges and their types as attributes to the current face\n        mesh.face_attribute(0, 'start_edge', start_edge)\n        mesh.face_attribute(0, 'start_edge_type', start_edge_type)\n        mesh.face_attribute(0, 'end_edge', end_edge)\n        mesh.face_attribute(0, 'end_edge_type', end_edge_type)\n        mesh.face_attribute(0, 'direction_vector', direction_vector)\n\n        return {\n            'face': 0,\n            'face_type': mesh.face_attribute(0, 'face_type'),\n            'start_edge': start_edge,\n            'start_edge_type': start_edge_type,\n            'end_edge': end_edge,\n            'end_edge_type': end_edge_type,\n            'direction_vector': direction_vector,\n            'edge_height': edge_height,\n            'edge_length': edge_length,\n            'num_courses': num_courses,\n            'curve_start_point': curve_start_point,\n            'curve_end_point': curve_end_point,\n            'face_normal': face_normal\n        }",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}