{
  "source_url": "https://github.com/JanMeow/BFH_Reuse24/blob/8ee5b5647d3500e8ac32686766bd46658e59ac11/Kevin/demoSeries/demo_wallSystem_02032024/py/alignSystem.py",
  "repo": "JanMeow/BFH_Reuse24",
  "repo_stars": 0,
  "repo_description": "BFH 24 Spring Studio Scripts Development",
  "license": "MIT",
  "filepath": "Kevin/demoSeries/demo_wallSystem_02032024/py/alignSystem.py",
  "instruction": "Align system",
  "code": "import Rhino.Geometry as rg\nfrom ghpythonlib.components import Explode, LineSDL, CurveXCurve\nfrom copy import deepcopy\n\ndef alignSystem(windowGeo, grid, toler, basePlane):\n\n    def findMoveDist(points, checkLinesDict, basePlane, direction):\n        dir = {\"verti\":True, \"hori\":False}\n        moveDir = dir[direction]\n        checkLines = checkLinesDict[direction]\n\n        xform = rg.Transform.ChangeBasis(rg.Plane.WorldXY, basePlane)\n        newPts = []\n        for pt in points:\n            newPt = deepcopy(pt)\n            newPt.Transform(xform)\n            newPts.append(newPt)\n        \n        if moveDir:\n            newPts = sorted(newPts, key=lambda pt: pt.Y)\n        else:\n            newPts = sorted(newPts, key=lambda pt: pt.X)\n\n        xform_back = rg.Transform.ChangeBasis(basePlane, rg.Plane.WorldXY)\n        for pt in newPts:\n            pt.Transform(xform_back)\n\n        # firPts: upper & right\n        # secPt: button & left\n        firPts, secPts = newPts[2:], newPts[:2]\n\n        crvDir = basePlane.YAxis if moveDir else basePlane.XAxis\n        see = []\n        wholePair_facade = []\n        for pt in newPts:\n            firMoveTrace = LineSDL(pt, crvDir, toler).ToNurbsCurve()\n            secMoveTrace = LineSDL(pt, -crvDir, toler).ToNurbsCurve()\n            see.append(firMoveTrace)\n\n            for crv in checkLines['facade']:\n                firCutPt = CurveXCurve(crv.ToNurbsCurve(), firMoveTrace)[0]\n                secCutPt = CurveXCurve(crv.ToNurbsCurve(), secMoveTrace)[0]\n                if firCutPt:\n                    wholePair_facade.append((pt,firCutPt))\n                if secCutPt:\n                    wholePair_facade.append((pt,secCutPt))\n        \n        if len(wholePair_facade)!=0:\n            wholePair_facade = sorted(wholePair_facade, key=lambda pair: pair[0].DistanceTo(pair[1]))\n            closestPair = wholePair_facade[0]\n            \n            return (rg.Vector3d(closestPair[1]-closestPair[0]), True)\n\n        else:\n            return (rg.Vector3d(0,0,0), True)\n            # wholePair_opening = []\n            # for pt in newPts:\n            #     firMoveTrace = LineSDL(pt, crvDir, toler).ToNurbsCurve()\n            #     secMoveTrace = LineSDL(pt, -crvDir, toler).ToNurbsCurve()\n\n            #     for crvKey in checkLines['opening']:\n            #         crv = checkLines['opening'][crvKey]\n            #         firCutPt = CurveXCurve(crv.ToNurbsCurve(), firMoveTrace)[0]\n            #         secCutPt = CurveXCurve(crv.ToNurbsCurve(), secMoveTrace)[0]\n            #         if firCutPt and firCutPt != pt:\n            #             wholePair_opening.append((pt,firCutPt))\n            #         if secCutPt and secCutPt != pt:\n            #             wholePair_opening.append((pt,secCutPt))\n            #             print(pt,secCutPt)\n            \n            \n            # if len(wholePair_opening)!=0:\n            #     wholePair_opening = sorted(wholePair_opening, key=lambda pair: pair[0].DistanceTo(pair[1]))\n            #     closestPair = wholePair_opening[0]\n\n            #     if not closestPair[1].DistanceTo(closestPair[0])<0.1:\n            #         print(\"hiiii\")\n            #         resultVec = rg.Vector3d(closestPair[1]-closestPair[0])\n            #         resultVec.Unitize()\n            #         resultVec *= 0.1\n            #         matrix = rg.Transform.Translation(resultVec)\n            #         checkLines['opening'][crvKey].Transform(matrix)\n            #         return (resultVec, True)\n            #     else:\n            #         return (rg.Vector3d(0,0,0), True)\n            \n            # else:\n            #     return (rg.Vector3d(0,0,0), True)\n\n\n    # Whole lines involved in this system, having opening lines and grid lines\n    checkLinesFacade = grid\n    checkLinesOpening = []\n\n    pt_rect = []\n    for geo in windowGeo:\n        if isinstance(geo, rg.Rectangle3d):\n            lines, vertics = Explode(geo, True)\n            pt_rect.append((vertics[:-1], geo))\n            checkLinesOpening.extend(lines)\n    \n    horiVec, vertiVec = basePlane.XAxis, basePlane.YAxis\n    horiLinesFacade = []\n    vertiLinesFacade = []\n    for crv in checkLinesFacade:\n        vecCrv = crv.PointAtEnd - crv.PointAtStart\n        if rg.Vector3d.CrossProduct(horiVec,vecCrv).IsZero:\n            horiLinesFacade.append(crv)\n        else:\n            vertiLinesFacade.append(crv)\n\n    horiLinesOpening = {}\n    vertiLinesOpening = {}\n    for openId, crv in enumerate(checkLinesOpening):\n        vecCrv = crv.PointAtEnd - crv.PointAtStart\n        if rg.Vector3d.CrossProduct(horiVec,vecCrv).IsZero:\n            horiLinesOpening[openId] = crv\n        else:\n            vertiLinesOpening[openId] = crv\n\n    wholeLinesDict = {\"hori\":{\"facade\":vertiLinesFacade, \"opening\":vertiLinesOpening}, \"verti\":{\"facade\":horiLinesFacade, \"opening\":horiLinesOpening}}\n    \n    see = []\n    for pts, geo in pt_rect:\n        horiVec, fixedBool = findMoveDist(pts, wholeLinesDict, basePlane, 'hori')\n        vertiVec, fixedBool = findMoveDist(pts, wholeLinesDict, basePlane, 'verti')\n        crossVec = rg.Vector3d.Add(horiVec, vertiVec)\n\n        see.append(crossVec)\n\n\n    return see\n\n\n\n\na= alignSystem(windowGeo, grid, toler, basePlane)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}