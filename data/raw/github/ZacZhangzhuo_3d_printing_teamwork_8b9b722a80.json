{
  "source_url": "https://github.com/ZacZhangzhuo/3d_printing_teamwork/blob/1ae8e701e83329eb292170fc8bc483fa912b639b/Design_Substructure/Reference_files/221212_Substructure_khara.py",
  "repo": "ZacZhangzhuo/3d_printing_teamwork",
  "repo_stars": 1,
  "repo_description": "This is the 3D Printing teamwork repository of team 4 of MAS dfab 2023",
  "license": "MIT",
  "filepath": "Design_Substructure/Reference_files/221212_Substructure_khara.py",
  "instruction": "221212 substructure khara",
  "code": "import Rhino.Geometry as rg\nimport ghpythonlib.treehelpers as th\n\ntolerance = 0.001\n\n#this class is focused on the properties and methods of each instance MAS (multi agent system)\nclass Environment(object):\n    \n    def __init__(self, u_div, v_div, surface, agents_list = []):\n        #self.num_agents = 0    #total number of agents\n        self.u_div = u_div\n        self.v_div = v_div\n        self.surface = surface\n        self.agents = []\n        if len(agents_list) > 0:\n            self.agents = agents_list\n\n    #this function takes the u values and transform them into agents\n    def populate_agents(self, u_vals, target_factors):\n        # instantiatie all agents\n        for u, t_fac in zip(u_vals,target_factors) :\n            self.agents.append(Agent(u, 0, 0, t_fac / self.v_div, self.surface)) \n\n    def update_agents_pos (self, coherence_rad, coherence_fac):\n\n        # generate the new position of each agent by calculating their new direction and velocity\n        #for each agent apply all the functions on it given the required factors for each parameter\n        #if the agent arrives we pop out this agent from the list and add it to the finished list \n        # add a function that if everything is arrived just stop \n        #list of all effects so as not to change the behaviour of the agents during update\n        effects_list = []\n        for agent in self.agents:\n            effects_vector = rg.Vector2d(0,0)\n            coherence_vector = agent.Coherence(coherence_rad, self.agents, self.u_div, self.v_div, coherence_fac)\n            effects_vector += coherence_vector\n            #sum all of the vectors + the actual du and dv of the agent + unitize --> do nothing but add them to the effects_list\n            effects_list.append(agent.AddTotalEffect(self.u_div, self.v_div, effects_vector))\n        for agent, effect in zip(self.agents, effects_list):\n            agent.AgentStep(effect)\n\n    #function that ensures the agent has reached the final destination\n\nclass Agent(object):\n\n#the main parameters are poisiton on the surface, velocity in both directions \n    def __init__(self, u, v, du, dv, surface):\n        self.u = u\n        self.v = v\n        self.surface = surface\n        pos_3d = self.surface.PointAt(self.u, self.v)\n        self.position = rg.Point2d(self.u, self.v) ##for the surface\n\n        self.du = du\n        self.dv = dv\n        self.pts = []\n        self.pts.append(self.surface.PointAt(self.u, self.v))\n        self.arrived = False\n        \n\n    def Coherence(self, radius, agents, u_div, v_div, coh_fac):\n        # agents : list of agents in the environment\n        # fx for Coherence\n        \"\"\" \n        --- within the specified radius we need to iterate over each agent apart from ours and do the following:\n        -> calculate the center (u,v) of the surrounding by 2 getting the average over all of the points \n        -> this shall be the point to aim at from the agent position \n        -> unitize the produced vector \n        \"\"\"\n        #coherence_distance = ra\n        centerU= 0\n        centerV= 0\n        num_neighbors = 0\n        for agent in agents:\n            if not agent == self:\n                dist = self.surface.ShortPath(self.position, agent.position, tolerance).GetLength()\n                if dist<= radius:\n                    num_neighbors +=1\n                    centerU += agent.u\n                    centerV += agent.v\n\n        #get the average vector\n        if  num_neighbors > 0:\n            centerU /= num_neighbors\n            centerV /= num_neighbors\n\n            #unitize the product vector of the coherence  \n            cohesion_unit_vect = rg.Vector2d(centerU-self.u, centerV-self.v)\n            cohesion_unit_vect = self.UnitizeEffect(u_div, v_div,cohesion_unit_vect) * coh_fac\n\n            return cohesion_unit_vect\n\n        else:\n            return rg.Vector2d(0,0)\n\n\n    # pending: fx for limiting speed?\n\n    # helper fxs:7\n\n    # add the effect to the new veloctity vector of the agent that will be added later to its current velocity\n    # as an input is the vector of a certain effect, the function does the following\n    # --> unitize the vector\n    # --> multiply by the effect value \n    # --> add this value to sum of new velocity vector \n    # --> this fx is called in each effect fx \n    def UnitizeEffect(self, u_div, v_div, vector_2b_unitised):           \n        vector_2b_unitised.Unitize()\n        vector_2b_unitised = rg.Vector2d(vector_2b_unitised.X/u_div, vector_2b_unitised.Y/v_div)\n        return vector_2b_unitised\n\n    # adds the new velocty vector to the current velocity vector and unitizes it \n    def AddTotalEffect(self, u_div, v_div, effects_vector):\n        effects_vector += rg.Vector2d(self.du, self.dv)\n        return self.UnitizeEffect(u_div, v_div, effects_vector)\n\n    # update the agent's params and move it one step forward\n    def AgentStep(self, effects_vector):\n        self.du = effects_vector.X\n        self.dv = effects_vector.Y\n        self.u += self.du\n        self.v += self.dv\n        self.pts.append(self.surface.PointAt(self.u, self.v))\n\n    #hello Eleniiiii\n    #hello Ahmed\n######################################################################################################################################\n# the execution function:\n# given the list of different points to initiate the agents do:\n# a for loop iterating over the lists, instantiating each agent in the list then instantaiting an environment given all these agents\n# afterwards, for each environment do some action till a certain time t\n# afterwards instantiate a bigger environment containing all agents and giving it a certain value for all parameters.\n\ninitial_env_list = []\nu_lists = th.tree_to_list(u_lists)\ntarget_factors = th.tree_to_list(target_factors)\nfor u_list, t_factor in zip(u_lists, target_factors):\n    #instantiate an instance of the environment:\n    new_env = Environment(u_div, v_div, surface)\n    new_env.populate_agents(u_list, t_factor)\n    initial_env_list.append(new_env)\n\n#depending on the input timestep we update the agents\nfor t in range(time_1):\n    for env in initial_env_list:\n        env.update_agents_pos(coherence_rad, coherence_fac)\n\nlist_pts = []\nfor env in initial_env_list:\n    list_pts.append([agent.pts for agent in env.agents])\n    \n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}