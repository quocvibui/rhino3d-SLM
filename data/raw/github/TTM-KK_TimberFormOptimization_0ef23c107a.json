{
  "source_url": "https://github.com/TTM-KK/TimberFormOptimization/blob/a728057ff3bfbfb7995b309e835a6278a6e86fcc/GA/Crossover.py",
  "repo": "TTM-KK/TimberFormOptimization",
  "repo_stars": 0,
  "repo_description": "This is a Form Generate Project, using non preform timber.",
  "license": "unknown",
  "filepath": "GA/Crossover.py",
  "instruction": "Crossover",
  "code": "# -*- coding: UTF-8 -*-\n\nimport random as rnd\nimport copy\nimport rhinoscriptsyntax as rs\n\n\ndef selectDividePoints(num_timber, divide_range):\n    divide_point1 = None\n    divide_point2 = None\n\n    flag_divide_point = True\n    avoid_infinite_loop = 0\n    while flag_divide_point:\n        avoid_infinite_loop = avoid_infinite_loop + 1\n        if avoid_infinite_loop > 100:\n            print(\"This is infinite loop in generate divide point\")\n            input(\"This is infinite loop in generate divide point near 330, please press ESC key\")\n            break\n\n        divide_point1 = rnd.randint(0, num_timber - 1)\n        divide_point2 = rnd.randint(0, num_timber - 1)\n\n        if divide_point1 == divide_point2:\n            continue\n        # 次世代に継承する木材の最低本数を予め設定する\n        # --------------------------------------------------------\n\n        if not abs(divide_point1 - divide_point2) >= divide_range:\n            continue\n        else:\n            break\n\n    return divide_point1, divide_point2\n\n\ndef select2Poplation(selected_list):\n    flag_select_index = True\n    avoid_infinite_loop = 0\n    while flag_select_index:\n        avoid_infinite_loop = avoid_infinite_loop + 1\n        select_pop_index1 = rnd.randint(0, len(selected_list) - 1)\n        select_pop_index2 = rnd.randint(0, len(selected_list) - 1)\n        if select_pop_index1 != select_pop_index2:\n            flag_select_index = False\n        if avoid_infinite_loop > 30:\n            print(\"This is infinite loop in select index\")\n            input(\"This is infinite loop in select index near 348, please press ESC key\")\n            break\n\n    pop_1 = selected_list[select_pop_index1]  # 評価のプロセスで選択された個体から交叉に使用する個体を選択する\n    pop_2 = selected_list[select_pop_index2]  # 評価のプロセスで選択された個体から交叉に使用する個体を選択する\n\n    return pop_1, pop_2\n\n\ndef two_point_crossover(num_timber, divide_range, pop1_instance, pop2_instance, list_temp_gene):\n    divide_point1 = None\n    divide_point2 = None\n\n    flag_divide_point = True\n    avoid_infinite_loop = 0\n    while flag_divide_point:\n        avoid_infinite_loop = avoid_infinite_loop + 1\n        if avoid_infinite_loop > 100:\n            print(\"This is infinite loop in generate divide point\")\n            input(\"This is infinite loop in generate divide point near 330, please press ESC key\")\n            break\n\n        divide_point1 = rnd.randint(0, num_timber - 1)\n        divide_point2 = rnd.randint(0, num_timber - 1)\n\n        if divide_point1 == divide_point2:\n            continue\n        # 次世代に継承する木材の最低本数を予め設定する\n        # --------------------------------------------------------\n\n        if not abs(divide_point1 - divide_point2) >= divide_range:\n            continue\n        else:\n            break\n\n    gene_info_temp = []\n    gene_info_center_temp = []\n    gene_info_front_temp = []\n    gene_info_back_temp = []\n    if divide_point1 < divide_point2:\n        a = divide_point1\n        b = divide_point2\n    else:\n        a = divide_point2\n        b = divide_point1\n    c = b - a\n\n    pop1_gene_info = copy.deepcopy(pop1_instance.gene_info)\n    gene_index = a\n    for i in range(c):\n        gene_index = gene_index + 1\n        gene_info_center_temp.append(pop1_gene_info[gene_index])\n\n    # まずfrontの方に値を入れる。\n    if a == 0:\n        pass\n    else:\n        pop2_gene_info = copy.deepcopy(pop2_instance.gene_info)\n        for i in range(a):\n            for j in range(num_timber):\n                # check_gene_index = copy.deepcopy(pop_2.gene_info[j])\n                if pop2_gene_info[j] not in gene_info_center_temp and pop2_gene_info[j] not in gene_info_front_temp:\n                    gene_info_front_temp.append(pop2_gene_info[j])\n                    break\n                else:\n                    continue\n\n    for i in range(num_timber - b):\n        for j in range(num_timber):\n            # check_gene_index = copy.deepcopy(pop_2.gene_info[j])\n            pop2_gene_info = copy.deepcopy(pop2_instance.gene_info)\n            if pop2_gene_info[j] not in gene_info_center_temp and pop2_gene_info[j] not in gene_info_front_temp and \\\n                    pop2_gene_info[j] not in gene_info_back_temp:\n                gene_info_back_temp.append(pop2_gene_info[j])\n                break\n            else:\n                continue\n\n    # 次の世代の遺伝子情報を作成する。後にGenerateクラスのgene_infoクラス変数を更新する。\n    gene_info_temp.extend(gene_info_front_temp)\n    gene_info_temp.extend(gene_info_center_temp)\n    gene_info_temp.extend(gene_info_back_temp)\n\n    list_temp_gene.append(gene_info_temp)  # 次世代の遺伝子更新用リスト\n\n    pop1_instance.temp_used_list = []  # 一度初期化\n    # print(\"gene_info_center_temp\", gene_info_center_temp)\n    pop1_instance.temp_used_list.extend(gene_info_center_temp)\n    # print(\"pop_1.temp_used_list\", pop_1.temp_used_list)\n    pop1_instance.temp_yet_regenerate = []\n    pop1_instance.temp_yet_regenerate.extend(gene_info_front_temp)\n    pop1_instance.temp_yet_regenerate.extend(gene_info_back_temp)\n\n    already_regenerate = []\n    already_regenerate.extend(pop1_instance.temp_used_list)\n\n    return already_regenerate\n\n\ndef random_chunk_crossover(num_timber, divide_range, pop1):\n    '''\n    ランダムに次世代に引き継ぐ部材数を決定する。接合部材関係をたどることで、\n    塊として次世代に継承することを可能にしている。\n    :param num_timber:\n    :param divide_range:\n    :param pop1:\n    :return:\n    '''\n\n    # 次世代への継承部材数を決定する。\n    inheritance_num = rnd.randint(divide_range - 1, num_timber - 1)\n\n    select_tim_ids = []\n    flag = True\n    avoid_infinite_loop = -1\n    while flag:\n        avoid_infinite_loop += 1\n        if avoid_infinite_loop > 1000:\n            # raise Exception('random_chunk_crossover is gone')\n            print(\"random_chunk_crossover break cuz init or not work well\")\n            break\n\n        if avoid_infinite_loop == 0:\n            loop = True\n            while loop:\n                index = rnd.randint(0, num_timber - 1)\n                partner_sum = len(pop1.used_list[index].partner_tim)\n                if partner_sum == 0:\n                    continue\n                else:\n                    break\n        else:\n            partner_sum = len(pop1.used_list[index].partner_tim)\n\n        for j in range(partner_sum):\n            select_tim_id = pop1.used_list[index].partner_tim[j]\n\n            if select_tim_id not in select_tim_ids:\n                select_tim_ids.append(select_tim_id)\n\n                if len(select_tim_ids) >= inheritance_num:\n                    flag = False\n                    break\n            else:\n                pass\n\n        if not flag:\n            break\n\n        if len(pop1.used_list[index].partner_tim) >= 1:\n            choice_id = rnd.choice(pop1.used_list[index].partner_tim)\n        else:\n            pass\n            # print(\"partner_tim\", pop1.used_list[index].partner_tim)\n\n        for k in range(num_timber):\n            if pop1.used_list[k].id == choice_id:\n                index = k\n                break\n            else:\n                pass\n\n    return select_tim_ids\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}