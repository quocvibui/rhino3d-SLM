{
  "source_url": "https://github.com/Arastookhajehee/collaborative-bonsai-ironpython-backend-test-01/blob/51d4b7fbee6d81bf75935e0ed84669429cc7e7db/branch_script.py",
  "repo": "Arastookhajehee/collaborative-bonsai-ironpython-backend-test-01",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "branch_script.py",
  "instruction": "Branch script",
  "code": "import Rhino.Geometry as rg\nimport math\n\ndef plane_from_csv(csv):\n    parts = csv.split(',')\n    pnt = rg.Point3d(float(parts[0]),float(parts[1]),float(parts[2]))\n    vec1 = rg.Vector3d(float(parts[3]),float(parts[4]),float(parts[5]))\n    vec2 = rg.Vector3d(float(parts[6]),float(parts[7]),float(parts[8]))\n\n    return rg.Plane(pnt,vec1,vec2)\n\ndef PlaneToStick(placementPlane):\n    width = 18;\n    length = 300;\n    thickness = 18;\n    xInterval = rg.Interval(-width / 2, width / 2);\n    yInterval = rg.Interval(-length / 2, length / 2);\n    zInterval = rg.Interval(-thickness / 2, thickness / 2);\n    stick = rg.Box(placementPlane, xInterval, yInterval, zInterval).ToBrep();\n    return stick\n\ndef StickToPlane(stick):\n    sorted_faces = SortStickFaces(stick)\n    sides = GetSides(sorted_faces)\n    tips = GetTips(sorted_faces)\n    stick_plane = GetStickPlane(sides, tips)\n    rotated_stick_plane = rg.Plane(stick_plane.Origin, stick_plane.XAxis, stick_plane.ZAxis)\n    return rotated_stick_plane\n\ndef ScaleLine(line, factor):\n    linevec = rg.Vector3d(line[1]-line[0])\n    linemid = (line[0]+line[1])/2\n    lineplane = rg.Plane(linemid,rg.Plane.WorldXY.ZAxis)\n    line.Transform(rg.Transform.Scale(lineplane,factor,factor,factor))\n\ndef SortStickFaces(stick):\n    faces = stick.Faces\n    areas=[rg.AreaMassProperties.Compute(face).Area for face in faces]\n    faces_and_areas = zip(faces,areas)\n    sorted_faces = sorted(faces_and_areas, key=lambda x: x[1])\n    return sorted_faces\n\ndef GetSides(sorted_faces):\n    sides = [face[0] for face in sorted_faces[2:]]\n    return sides\n\ndef GetTips(sorted_faces):\n    tips = [face[0] for face in sorted_faces[:2]]\n    return tips\n\ndef GetThickness(tips):\n    area = rg.AreaMassProperties.Compute(tips[0]).Area\n    thickness = math.sqrt(area)\n    return thickness\n\ndef GetLength(tips):\n    top = rg.AreaMassProperties.Compute(tips[0]).Centroid\n    bottom = rg.AreaMassProperties.Compute(tips[1]).Centroid\n    length = top.DistanceTo(bottom)\n    return length\n\ndef GetStickPlane(sides, tips):\n    top = rg.AreaMassProperties.Compute(tips[0]).Centroid\n    bottom = rg.AreaMassProperties.Compute(tips[1]).Centroid\n    center = (top+bottom)/2\n    z_axis = rg.Vector3d(top-bottom)\n    x_axis = sides[0].NormalAt(0,0)\n    y_axis = rg.Vector3d.CrossProduct(z_axis, x_axis)\n    plane = rg.Plane(center,x_axis,y_axis)\n    return plane\n\ndef GetSidePlane(sides, side_id, stick_plane):\n    side = sides[side_id]\n    center = rg.AreaMassProperties.Compute(side).Centroid\n    x_axis = stick_plane.ZAxis\n    z_axis = side.NormalAt(0,0)\n    y_axis = rg.Vector3d.CrossProduct(z_axis, x_axis)\n    plane = rg.Plane(center,x_axis,y_axis)\n    return plane\n\ndef GetSharedPlane(side_plane_a, side_plane_b, shift_ab):\n    shared_line = rg.Intersect.Intersection.PlanePlane(side_plane_a,side_plane_b)[1]\n    ScaleLine(shared_line,100)\n    shared_vector = rg.Vector3d(shared_line[1]-shared_line[0])\n    shared_vector.Unitize()\n    shared_line = shared_line.ToNurbsCurve()\n    shared_line.Domain = rg.Interval(0,1)\n    shared_plane = rg.Plane(shared_line.PointAt(shift_ab),shared_vector)\n    return shared_plane\n    \ndef GetSharedLine(side_plane_a, side_plane_b, shift_ab):\n    shared_line = rg.Intersect.Intersection.PlanePlane(side_plane_a,side_plane_b)[1]\n    ScaleLine(shared_line,100)\n    shared_vector = rg.Vector3d(shared_line[1]-shared_line[0])\n    shared_vector.Unitize()\n    shared_line = shared_line.ToNurbsCurve()\n    shared_line.Domain = rg.Interval(0,1)\n    return shared_line\n\ndef CreateNewStick(stick, stick_plane, side_plane, shared_plane, shared_line, thickness, length, flip, shift):\n    line = rg.Intersect.Intersection.PlanePlane(shared_plane,side_plane)[1]\n    ScaleLine(line,100)\n    overlap = rg.Intersect.Intersection.CurveBrep(line.ToNurbsCurve(),stick,0.0001)[1]\n    if len(overlap)>0:\n        point = (overlap[0].PointAtStart+overlap[0].PointAtEnd)/2\n    else: point = (line[0]+line[1])/2\n    point = (point+shared_plane.Origin)/2\n    vector = rg.Vector3d(shared_line.PointAtEnd-shared_line.PointAtStart)\n    new_stick_plane = rg.Plane(point,vector,side_plane.ZAxis)\n    new_stick = stick.Duplicate()\n    new_stick.Transform(rg.Transform.PlaneToPlane(stick_plane,new_stick_plane))\n    new_stick.Transform(rg.Transform.Translation(thickness/2*new_stick_plane.YAxis))\n    new_stick.Transform(rg.Transform.Translation(flip*thickness/2*shared_plane.ZAxis))\n    new_stick.Transform(rg.Transform.Translation(length*shift*new_stick_plane.ZAxis))\n    return new_stick\n\ndef AdjustP1(sides,side_id,shared_plane):\n    face = sides[side_id]\n    edge = face.OuterLoop.To3dCurve()\n    segments = edge.DuplicateSegments()\n    vertices = [segment.PointAtStart for segment in segments]\n    distances = [vertice.DistanceTo(rg.Plane.ClosestPoint(shared_plane, vertice)) for vertice in vertices]\n    return (min(distances), max(distances))\n\ndef GenerateLink(stick_a,stick_b,side_id_a,side_id_b, shift_ab, flip, shift_a, shift_b):\n\n    # Get Planes\n    sorted_faces_a = SortStickFaces(stick_a)\n    sides_a = GetSides(sorted_faces_a)\n    tips_a = GetTips(sorted_faces_a)\n    sorted_faces_b = SortStickFaces(stick_b)\n    sides_b = GetSides(sorted_faces_b)\n    tips_b = GetTips(sorted_faces_b)\n    thickness_a = GetThickness(tips_a)\n    length_a = GetLength(tips_a)\n    thickness_b = GetThickness(tips_b)\n    length_b = GetLength(tips_b)\n    stick_plane_a = GetStickPlane(sides_a, tips_a)\n    center_a = stick_plane_a.Origin\n    stick_plane_b = GetStickPlane(sides_b, tips_b)\n    center_b = stick_plane_b.Origin\n    side_plane_a = GetSidePlane(sides_a, side_id_a, stick_plane_a)\n    side_plane_b = GetSidePlane(sides_b, side_id_b, stick_plane_b)\n    temp=(side_plane_a,side_plane_b)\n    \n    shared_plane = GetSharedPlane(side_plane_a, side_plane_b, 0)\n    shared_line = GetSharedLine(side_plane_a, side_plane_b, 0)\n\n    # Adjust P1\n    min_distance_a = AdjustP1(sides_a,side_id_a,shared_plane)[0]\n    max_distance_a = AdjustP1(sides_a,side_id_a,shared_plane)[1]\n    min_distance_b = AdjustP1(sides_b,side_id_b,shared_plane)[0]\n    max_distance_b = AdjustP1(sides_b,side_id_b,shared_plane)[1]\n    min_distance = max((min_distance_a, min_distance_b))\n    max_distance = min((max_distance_a, max_distance_b))\n    translation = shift_ab*min_distance+(1-shift_ab)*max_distance\n    shared_plane.Translate(translation*shared_plane.ZAxis)\n\n    # Create sticks\n    if flip is True: flip = 1\n    else: flip = -1\n    stick_c = CreateNewStick(stick_a, stick_plane_a, side_plane_a, shared_plane, shared_line, thickness_a, length_a, flip, shift_a)\n    stick_d = CreateNewStick(stick_b, stick_plane_b, side_plane_b, shared_plane, shared_line, thickness_b, length_b, -flip, shift_b)\n    #return stick_c, stick_d, shared_line, stick_line_c, stick_line_d\n    return (stick_c, stick_d)\n\ndef process_planes(branch_a, branch_b, shift_ab, shift_a, shift_b):\n    vec1 = branch_a.ZAxis\n    vec2 = branch_b.ZAxis\n    errors_txt = []\n    #print vec1.IsParallelTo(vec2, 0.01)\n    #print vec1.IsPerpendicularTo(vec2, 0.01)\n    #if vec1.IsParallelTo(vec2, 0.01) == 0 or vec1.IsPerpendicularTo(vec2, 0.01) is False:\n    stick_a = PlaneToStick(branch_a)\n    stick_b = PlaneToStick(branch_b)\n    sorted_faces_a = SortStickFaces(stick_a)\n    sides_a = GetSides(sorted_faces_a)\n    tips_a = GetTips(sorted_faces_a)\n    thickness_a = GetThickness(tips_a)\n    length_a = GetLength(tips_a)\n    min_glue_area = thickness_a**2\n    configurations = []\n    for i in range(4): # 4 sides_a\n        for j in range(4): # 4 sides_b\n            for k in [True, False]: # flip = True or False\n                try:\n                    configurations.append(GenerateLink(stick_a,stick_b,i,j, shift_ab, k, shift_a, shift_b))\n                except:\n                    configurations.append(None)\n    valid_configurations = []\n    other_configurations = []\n    valid_ids = []\n    n=0\n    for configuration in configurations:\n        if configuration != None:\n            stick_c, stick_d = configuration[0:2]\n            temp = stick_c, stick_d\n            flag = False\n            if len(rg.Intersect.Intersection.BrepBrep(stick_a, stick_d, 0.001)[1]) == 0:\n                if len(rg.Intersect.Intersection.BrepBrep(stick_b, stick_c, 0.001)[1]) == 0:\n                    if len(rg.Intersect.Intersection.BrepBrep(stick_c, stick_d, 0.001)[1]) > 0:\n                        if len(rg.Intersect.Intersection.BrepBrep(stick_a, stick_c, 0.001)[1]) > 0:\n                            if len(rg.Intersect.Intersection.BrepBrep(stick_b, stick_d, 0.001)[1]) > 0:\n                                cd = rg.Brep.CreatePlanarBreps(rg.Curve.JoinCurves(rg.Intersect.Intersection.BrepBrep(stick_c, stick_d, 0.001)[1]))\n                                ac = rg.Brep.CreatePlanarBreps(rg.Curve.JoinCurves(rg.Intersect.Intersection.BrepBrep(stick_a, stick_c, 0.001)[1]))\n                                bd = rg.Brep.CreatePlanarBreps(rg.Curve.JoinCurves(rg.Intersect.Intersection.BrepBrep(stick_b, stick_d, 0.001)[1]))\n                                if cd is not None and ac is not None and bd is not None:\n                                    if rg.AreaMassProperties.Compute(cd).Area > min_glue_area and rg.AreaMassProperties.Compute(ac).Area > min_glue_area and rg.AreaMassProperties.Compute(bd).Area > min_glue_area:\n                                            valid_configurations.append(configuration)\n                                            valid_ids.append(n)\n                                            flag = True\n                                            errors_txt.append(None)\n                                    else: errors_txt.append(\"insufficient contact\")\n                                else: errors_txt.append(\"insufficient contact\")\n                            else: errors_txt.append(\"no contact\")\n                        else: errors_txt.append(\"no contact\")\n                    else: errors_txt.append(\"no contact\")\n                else: errors_txt.append(\"collision\")\n            else: errors_txt.append(\"collision\")\n            if flag is False:\n                other_configurations.append(configuration)\n        n+=1\n    #else: errors_txt.append(\"Coplanar sticks...\")\n    return valid_configurations, configurations, valid_ids, errors_txt\n\ndef StickToPlane(stick):\n    sorted_faces = SortStickFaces(stick)\n    sides = GetSides(sorted_faces)\n    tips = GetTips(sorted_faces)\n    stick_plane = GetStickPlane(sides, tips)\n    rotated_stick_plane = rg.Plane(stick_plane.Origin, stick_plane.XAxis, stick_plane.ZAxis)\n    return rotated_stick_plane\n\ndef SortStickFaces(stick):\n    faces = stick.Faces\n    areas=[rg.AreaMassProperties.Compute(face).Area for face in faces]\n    faces_and_areas = zip(faces,areas)\n    sorted_faces = sorted(faces_and_areas, key=lambda x: x[1])\n    return sorted_faces\n\ndef GetSides(sorted_faces):\n    sides = [face[0] for face in sorted_faces[2:]]\n    return sides\n\ndef GetTips(sorted_faces):\n    tips = [face[0] for face in sorted_faces[:2]]\n    return tips\n\ndef GetStickPlane(sides, tips):\n    top = rg.AreaMassProperties.Compute(tips[0]).Centroid\n    bottom = rg.AreaMassProperties.Compute(tips[1]).Centroid\n    center = (top+bottom)/2\n    z_axis = rg.Vector3d(top-bottom)\n    x_axis = sides[0].NormalAt(0,0)\n    y_axis = rg.Vector3d.CrossProduct(z_axis, x_axis)\n    plane = rg.Plane(center,x_axis,y_axis)\n    return plane\n\ndef process_sticks(run, only_valid, valid_configurations, configurations,valid_ids,errors_txt, browse):\n    if run:\n        #if errors_txt[0] != \"Coplanar sticks...\":\n        if only_valid:\n            if len(valid_configurations) > 0:\n                browse = browse%len(valid_configurations)\n                stick_c, stick_d = valid_configurations[browse]\n                plane_c = StickToPlane(stick_c)\n                plane_d = StickToPlane(stick_d)\n                conf_id = \"configuration number: \"+ str(valid_ids[browse])\n                return plane_c, plane_d\n            else:\n                conf_id = \"no valid configurations\"\n                return None, None\n        \n        else:\n            stick_c, stick_d = configurations[browse]\n            plane_c = StickToPlane(stick_c)\n            plane_d = StickToPlane(stick_d)\n            return plane_c, plane_d\n            print(errors_txt[browse])\n        #else:\n            #print(errors_txt[0])\n            #plane_c=branch_a.placementPlane\n            #plane_d=branch_b.placementPlane\n    else:\n        conf_id = \"please select two sticks\"\n\ndef csv_from_plane(plane01):\n    plane01csv = str.format(\n        \"{},{},{},{},{},{},{},{},{}\",\n        plane01.Origin.X, \n        plane01.Origin.Y, \n        plane01.Origin.Z, \n        plane01.XAxis.X, \n        plane01.XAxis.Y, \n        plane01.XAxis.Z, \n        plane01.YAxis.X, \n        plane01.YAxis.Y, \n        plane01.YAxis.Z, \n    )\n    return plane01csv\n\ndef process_bridge(branch_a_csv, branch_b_csv, shift_ab= -4.95, shift_a = 0.146, shift_b= -0.186,browse = 2,only_valid = False)\n    branch_a = plane_from_csv(branch_a_csv)\n    branch_b = plane_from_csv(branch_b_csv)\n    valid_configurations, configurations, valid_ids, errors_txt = process_planes(branch_a, branch_b, shift_ab, shift_a, shift_b)\n    plane_c, plane_d = process_sticks(True, only_valid, valid_configurations, configurations,valid_ids,errors_txt, browse)\n    \n    return csv_from_plane(plane_c), csv_from_plane(plane_d)",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}