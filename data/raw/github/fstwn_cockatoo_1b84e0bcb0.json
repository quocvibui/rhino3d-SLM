{
  "source_url": "https://github.com/fstwn/cockatoo/blob/d952ac5d2148ec29fba52e8eb75f0f43770c74ca/usrobj_src/Cockatoo_NodesByPointProximity.py",
  "repo": "fstwn/cockatoo",
  "repo_stars": 38,
  "repo_description": "Cockatoo is a prototypical open-source software toolkit for generating (3d-)knitting patterns from NURBS surface and mesh geometry directly inside Grasshopper.",
  "license": "MIT",
  "filepath": "usrobj_src/Cockatoo_NodesByPointProximity.py",
  "instruction": "Select KnitNetwork Nodes by proximity by selecting all nodes that are closer\nthan the specified Tolerance to the given SamplePoints.\n    Inputs:\n        KnitNetwork: The KnitNetwork to select nodes...",
  "code": "\"\"\"\nSelect KnitNetwork Nodes by proximity by selecting all nodes that are closer\nthan the specified Tolerance to the given SamplePoints.\n    Inputs:\n        KnitNetwork: The KnitNetwork to select nodes from.\n                     {item, KnitNetworkBase}\n        SamplePoint: Point to sample for proximity search.\n                     {list, point3d}\n        Tolerance: All nodes closer to the samplepoints than this value will\n                   be selected by the component.\n                   Defaults to [0.01] units.\n                   {item, float}\n        Precise: If True, the more precise but slower DistanceTo() function will\n                 be used instead of DistanceToSquared().\n                 Defaults to False.\n                 {item, bool}\n    Outputs:\n        NodeIndices: The indices (identifiers) of the found nodes within the\n                     network.\n                     {list, int}\n        Nodes: The found nodes as node-2-tuples consisting of (index, data).\n               {list, nodes}\n        NodePoints: The Point3d geometry of the selected nodes within the\n                    network.\n                    {list, point3d}\n    Remarks:\n        Author: Max Eschenbach\n        License: MIT License\n        Version: 200705\n\"\"\"\n\n# PYTHON STANDARD LIBRARY IMPORTS\nfrom __future__ import division\nfrom collections import OrderedDict\n\n# GHPYTHON SDK IMPORTS\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\n# GHENV COMPONENT SETTINGS\nghenv.Component.Name = \"NodesByPointProximity\"\nghenv.Component.NickName =\"NBPP\"\nghenv.Component.Category = \"Cockatoo\"\nghenv.Component.SubCategory = \"07 KnitNetwork Editing\"\n\n# LOCAL MODULE IMPORTS\ntry:\n    import cockatoo\nexcept ImportError:\n    errMsg = \"The Cockatoo python module seems to be not correctly \" + \\\n             \"installed! Please make sure the module is in you search \" + \\\n             \"path, see README for instructions!.\"\n    raise ImportError(errMsg)\n\nclass NodesByPointProximity(component):\n    \n    def __init__(self):\n        super(NodesByPointProximity, self).__init__()\n        \n        self.drawing_nodes = []\n        self.skip_invalid = False\n    \n    def compare_points(self, data_tuple):\n        node, samplepoints, tol = data_tuple\n        for j, samplept in enumerate(samplepoints):\n            if samplept == None:\n                continue\n            if not node[1][\"geo\"] == samplept:\n                dist = samplept.DistanceTo(node[1][\"geo\"])\n                if dist < tol:\n                    return True\n                continue\n            return True\n        return False\n    \n    def compare_points_squared(self, data_tuple):\n        node, samplepoints, tol = data_tuple\n        for j, samplept in enumerate(samplepoints):\n            if samplept == None:\n                continue\n            if not node[1][\"geo\"] == samplept:\n                dist = samplept.DistanceToSquared(node[1][\"geo\"])\n                if dist < tol ** 2:\n                    return True\n                continue\n            return True\n        return False\n    \n    def RunScript(self, KnitNetwork, SamplePoints, Tolerance=0.01, Precise=False):\n        \n        # set defaults and catch None values\n        if Tolerance == None:\n            Tolerance = 0.01\n        if Precise == None:\n            Precise = False\n        \n        # initialize outputs\n        NodeIndices = Grasshopper.DataTree[object]()\n        Nodes = Grasshopper.DataTree[object]()\n        NodePoints = Grasshopper.DataTree[object]()\n        \n        # filter nodes according to input\n        if KnitNetwork and SamplePoints:\n            \n            # get all the nodes of the network\n            network_nodes = KnitNetwork.nodes(data=True)\n            \n            # initialize list of data for parallel computation\n            data_list = []\n            \n            for i, node in enumerate(network_nodes):\n                data_tuple = (node, SamplePoints, Tolerance)\n                data_list.append(data_tuple)\n            \n            # on precise option\n            if Precise:\n                results = list(GhPython.ScriptHelpers.Parallel.Run(\n                                                self.compare_points,\n                                                data_list,\n                                                False))\n            # standard case\n            else:\n                results = list(GhPython.ScriptHelpers.Parallel.Run(\n                                                self.compare_points_squared,\n                                                data_list,\n                                                False))\n            \n            # collect results\n            Nodes = [network_nodes[i] for i, val in enumerate(results) if val]\n            NodeIndices = [n[0] for n in Nodes]\n            NodePoints = [n[1][\"geo\"] for n in Nodes]\n            \n        # catch missing inputs\n        if not KnitNetwork:\n            errMsg = \"No KnitNetwork input!\"\n            rml = self.RuntimeMessageLevel.Warning\n            self.AddRuntimeMessage(rml, errMsg)\n        if not SamplePoints:\n            errMsg = \"No SamplePoints input!\"\n            rml = self.RuntimeMessageLevel.Warning\n            self.AddRuntimeMessage(rml, errMsg)\n        \n        # return results\n        return NodeIndices, Nodes, NodePoints\n",
  "language": "python",
  "imports": [
    "Rhino",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}