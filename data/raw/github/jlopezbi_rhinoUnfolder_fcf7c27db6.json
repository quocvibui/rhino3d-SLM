{
  "source_url": "https://github.com/jlopezbi/rhinoUnfolder/blob/37abb2c4d2a464e62dbdbb0bde72491dcbfd7343/rhino_unwrapper/Net.py",
  "repo": "jlopezbi/rhinoUnfolder",
  "repo_stars": 8,
  "repo_description": "unwrap meshes in rhino!",
  "license": "GPL-3.0",
  "filepath": "rhino_unwrapper/Net.py",
  "instruction": null,
  "code": "\nimport Rhino\nimport Rhino.Geometry as geom\nimport rhinoscriptsyntax as rs\nimport math\nimport transformations as trans\nfrom UnionFind import UnionFind\n\nreload(trans)\n\n\nclass Net():\n    \"\"\" \n    What does a net do?, slash know about?\n        => it stores the mesh that is the net. In fact perhaps should just use rhino's mesh! but lets save that for later\n    Right now the net does this:\n        * Segmentation <= this is the main thing!\n            * Selection\n        * Display\n\n    Queries: (this will help determine best Data structure)\n        * for a given edge its parent face and its otherParnet face (assuming a manifold edge)\n        * for a given cut edge, its corresponding edge\n        * for a given edge, the two sets of edges/faces/verts on either side, or for a given edge, the set of edges/faces/verts on the side indicated by the user (faster)\n        non essential:\n        * for a given edge, the corrseponding edge in the 3d mesh\n    \"\"\"\n#myMesh.mesh.Faces.Count\n\n    def __init__(self, myMesh=None, holeRadius=10):\n        #NOTE: I do not see why net needs to hold onto myMesh\n        self.holeRadius = holeRadius\n        self.angleThresh = math.radians(3.3)\n        self.myMesh = myMesh\n        self.islands = []\n        self.group_island_dict = {}\n        #self.groups,self.leaders = segmentIsland(self.flatFaces,[])\n\n    def get_island_list(self):\n        return self.islands\n\n    def add_island(self,island):\n        self.islands.append(island)\n        index = len(self.islands) - 1\n        self.group_island_dict[island.group_name] = index\n\n    def get_island(self,index):\n        return self.islands[index]\n\n    def display(self):\n        for island in self.islands:\n            island.display()\n\n    def get_island_for_line(self,line_guid):\n        '''\n        CURRENTLY NOT FUNCTIONING: fix this when this becomes necessary. At the moment this function is not useful.\n        Assumes each element of the island has a group with geometry in it, and each geometry member has group0-> element level, group1 -> island level structure\n        '''\n        groups = rs.ObjectGroups(line_guid)\n        # group should be the second one\n        group_name = groups[1]\n        index = self.group_island_dict[group_name]\n        return self.islands[index]\n\n\n    '''SEGMENTATION, seems like should be a seperate thing!'''\n    #Now when segmentation happens a two new islands should be created\n    #A new challenge is finding the island that owns the line or meshEdge that the user selected!\n    #it seems like union find is not necessary when using island idea! whoa! but keep this code in case wrong\n    def segment_island(self):\n        pass\n\n    def segmentIsland(flatFaces, island):\n        sets = UnionFind(True)\n        if len(island) == 0:\n            island = range(len(flatFaces))\n        for face in island:\n            if face not in sets.leader.keys():\n                sets.makeSet([face])\n            neighbor = flatFaces[face].fromFace\n            if neighbor is not None:\n                if neighbor not in sets.leader.keys():\n                    sets.makeSet([neighbor])\n                sets.union(face, neighbor)\n        return sets.group, sets.leader\n\n    def findInitalSegments(self):\n        group, leader = self.segmentIsland(self.flatFaces, [])\n        self.groups = group\n        self.leaders = leader\n\n    def findSegment(self, flatEdgeCut, face):\n        island = self.getGroupForMember(face)\n        self.removeFaceConnection(flatEdgeCut)\n        group, leader = self.segmentIsland(self.flatFaces, island)\n        self.updateIslands(group, leader, face)\n        return group[leader[face]]\n\n    def getGroupForMember(self, member):\n        if member not in self.leaders.keys():\n            print \"face not in leaders: \",\n            print member\n            return\n        leader = self.leaders[member]\n        return self.groups[leader]\n\n    def updateIslands(self, newGroups, newLeaders, face):\n        # get rid of old island\n        leader = self.leaders[face]\n        del self.groups[leader]\n\n        for group in newGroups.items():\n            self.groups[group[0]] = group[1]\n        for leader in newLeaders.items():\n            self.leaders[leader[0]] = leader[1]\n\n    def copyAndReasign(self, dataMap, flatEdge, idx, segment, face):\n        # TODO: this must change because of change to cut/fold edge types\n        # GOT TO REWORK THIS ONE\n        newEdgeIdx = len(self.flatEdges)\n        resetEdge = fe.change_to_cut_edge(flatEdge,newEdgeIdx)\n        resetEdge.resetFromFace(face)\n        changedVertPairs = self.makeNewNetVerts(dataMap, flatEdge)\n        newEdge = self.makeNewEdge(\n            dataMap,\n            changedVertPairs,\n            flatEdge.meshEdgeIdx,\n            idx,\n            face,flatEdge.getOtherFace(face))\n        flatEdge.pair = newEdge\n        flatEdge.show_line(self.flatVerts)\n        # flatEdge.drawHoles(self,connectorDist,safetyRadius,holeRadius)\n        self.resetSegment(dataMap, changedVertPairs, segment)\n\n    def translateSegment(self, segment, xForm):\n        # TODO: make a more efficent version of this, would be easier if half-edge or\n        # winged edge mesh. H-E: could traverse edges recursively, first going to sibling h-edge\n        # Sstopping when the edge points to no other edge(naked),or to a face not in the segment,or\n        # if the h-edge is part of the user-selected edge to be cut\n        group = rs.AddGroup()\n        collection = []\n        movedNetVerts = []\n        for netEdge in self.flatEdges:\n            if netEdge.fromFace in segment:\n                collection.append(netEdge)\n                netEdge.clearAllGeom()\n                netEdge.translateGeom(movedNetVerts, self.flatVerts, xForm)\n        return collection\n\n    def redrawSegment(self, translatedEdges):\n        geom = []\n        for netEdge in translatedEdges:\n            netEdge.show_line(self.flatVerts)\n\n    def removeFaceConnection(self, flatEdgeCut):\n        faceA = flatEdgeCut.fromFace\n        faceB = flatEdgeCut.toFace\n        netFaceA = self.flatFaces[faceA]\n        netFaceB = self.flatFaces[faceB]\n        if netFaceB.fromFace == faceA:\n            netFaceB.fromFace = None\n        elif netFaceA.fromFace == faceB:\n            netFaceA.fromFace = None\n\n    def makeNewEdge(self, dataMap, changedVertPairs, meshEdge, otherEdge, fromFace,toFace):\n        newVertI = changedVertPairs[0][0]\n        newVertJ = changedVertPairs[1][0]\n        newFlatEdge = fe.CutEdge(meshEdgeIdx=meshEdge,\n                                 vertAidx=newVertI,\n                                 vertBidx=newVertJ,\n                                 fromFace=fromFace,\n                                 toFace=toFace,\n                                 sibling=otherEdge)\n        newFlatEdge.hasTab = True\n        newFlatEdge.tabFaceCenter = self.flatFaces[toFace].getCenterPoint(self.flatVerts)\n        \n        # This is where need to add a tabFaceCenter thing that will find the otherFace\n        # of the edge and find its center\n        # TODO: need to set tab angles or something. NOTE: .fromFace and\n        # .toFace of flatEdge referes to a MESH face!!\n        netEdge = self.addEdge(newFlatEdge)\n        dataMap.updateEdgeMap(meshEdge, netEdge)\n        return netEdge\n\n    def makeNewNetVerts(self, dataMap, flatEdgeCut):\n        oldNetI, oldNetJ = flatEdgeCut.getNetVerts()\n        flatI, flatJ = flatEdgeCut.getFlatVerts(self.flatVerts)\n        pointI = Rhino.Geometry.Point3d(flatI.point)  # important copy vert\n        pointJ = Rhino.Geometry.Point3d(flatJ.point)\n        newI = FlatVert(flatI.tVertIdx, pointI)\n        newJ = FlatVert(flatJ.tVertIdx, pointJ)\n        newNetI = self.addVert(newI)\n        newNetJ = self.addVert(newJ)\n        dataMap.updateVertMap(flatI.tVertIdx, newNetI)\n        dataMap.updateVertMap(flatJ.tVertIdx, newNetJ)\n        return [(newNetI, oldNetI), (newNetJ, oldNetJ)]\n\n    def resetSegment(self, dataMap, changedVertPairs, segment):\n        self.resetFaces(changedVertPairs, segment)\n        self.resetEdges(dataMap, changedVertPairs, segment)\n\n    def resetFaces(self, changedVertPairs, segment):\n        # REPLACE: this is slow hack\n        newVertI, oldVertI = changedVertPairs[0]\n        newVertJ, oldVertJ = changedVertPairs[1]\n        for face in segment:\n            verts = self.flatFaces[face].vertices\n            if oldVertI in verts:\n                index = verts.index(oldVertI)\n                verts.insert(index, newVertI)  # does order matter? yes\n                verts.pop(index + 1)\n            if oldVertJ in verts:\n                index = verts.index(oldVertJ)\n                verts.insert(index, newVertJ)  # does order matter? yes\n                verts.pop(index + 1)\n\n    def resetEdges(self, dataMap, changedVertPairs, segment):\n        '''\n        reset all edges touching the newely added vertices\n        '''\n        # REPLACE: if using he-mesh then this will be unnecessary\n        for pair in changedVertPairs:\n            newVert, oldVert = pair\n            tVert = self.flatVerts[newVert].tVertIdx\n            print \"Tvert:\",\n            print tVert\n            # in original mesh,eventually use he-mesh\n            edges = self.myMesh.getEdgesForVert(tVert)\n            for edge in edges:\n                netEdges = dataMap.getNetEdges(edge)\n                for netEdge in netEdges:\n                    flatEdge = self.getFlatEdge(netEdge)\n                    netPair = flatEdge.getNetVerts()\n                    if oldVert in netPair and flatEdge.fromFace in segment:\n                        #assert(flatEdge.fromFace in segment), \"flatEdge not in segment\"\n                        flatEdge.reset(oldVert, newVert) \n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}