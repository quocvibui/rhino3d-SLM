{
  "source_url": "https://github.com/Ennead-Architects-LLP/EA_Dist/blob/635520d89b8308b78eabf5b60bb80121d0fa3838/Apps/_revit/EnneaDuck.extension/EnneadTab%20Tailor.tab/archive/Proj.%202135.panel/A.stack/Proj%202135B.pulldown/40_floor%20to%20filled%20region.pushbutton/floor%20to%20filled%20region_script.py",
  "repo": "Ennead-Architects-LLP/EA_Dist",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Apps/_revit/EnneaDuck.extension/EnneadTab Tailor.tab/archive/Proj. 2135.panel/A.stack/Proj 2135B.pulldown/40_floor to filled region.pushbutton/floor to filled region_script.py",
  "instruction": "Floor to filled region script",
  "code": "#!/usr/bin/python\r\n# -*- coding: utf-8 -*-\r\n\r\n\r\n\r\n__doc__ = \"Recreate a filled region using the same shape as the floor.\"\r\n__title__ = \"40_Floor to Filled region\"\r\n__youtube__ = \"https://youtu.be/ieGPe-3ACw4\"\r\nimport time\r\nfrom pyrevit import forms #\r\nfrom pyrevit import script #\r\n# from pyrevit import revit #\r\n\r\nimport proDUCKtion # pyright: ignore \r\nproDUCKtion.validify()\r\nfrom Autodesk.Revit import DB # pyright: ignore \r\n# from Autodesk.Revit import UI # pyright: ignore\r\ndoc = __revit__.ActiveUIDocument.Document # pyright: ignore\r\nuidoc = __revit__.ActiveUIDocument\r\nfrom pyrevit.framework import List\r\n\r\n\r\n\r\ndef OLD_sort_crv(crvs):#work only with single loop-like, if double loop then it ewill fail\r\n    current_crv = crvs[0]\r\n    end_pt = current_crv.GetEndPoint(1)\r\n    sorted_crv = [current_crv]\r\n    i = 0#safety count\r\n    while len(sorted_crv) < len(crvs):\r\n    #for i, crv in enumerate(crvs):\r\n\r\n        for other_crv in crvs:\r\n            if current_crv == other_crv:#skip itself\r\n                #print \"self\"\r\n                continue\r\n            elif end_pt.IsAlmostEqualTo( other_crv.GetEndPoint(0) ):#this is the next curve\r\n                #print \"found\"\r\n                sorted_crv.append(other_crv)\r\n                current_crv = other_crv\r\n                end_pt = current_crv.GetEndPoint(1)\r\n                #print sorted_crv\r\n                break\r\n            else:#not the next crv\r\n                #print \"not this one\"\r\n                pass\r\n\r\n        i += 1\r\n        if i > 500:\r\n            break\r\n    return sorted_crv\r\n\r\n\r\ndef create_filled_region_from_floor(floor, filled_region_type, view_id):\r\n    \"\"\"\r\n    make temp copy and reset copy shape, main prolblem is the copy does not know the other hole cut\r\n    \"\"\"\r\n\r\n\r\n    def get_curveloop_method1():\r\n        slab_editor = floor.SlabShapeEditor\r\n        creases = slab_editor.SlabShapeCreases\r\n        # print creases\r\n        crvs = []\r\n        for crease in creases:\r\n            # print crease\r\n            if crease.CreaseType == DB.SlabShapeCreaseType.Boundary:\r\n                # print \"add boundary\"\r\n                crvs.append(crease.Curve)\r\n\r\n        crvs = sort_crv(crvs)\r\n        curveloop = DB.CurveLoop.Create(ARCHI_UTILITY.list_to_system_list(crvs, type = \"Curve\"))\r\n        # return ARCHI_UTILITY.list_to_system_list([crvs], type = \"CurveLoop\")\r\n        return List[DB.CurveLoop]([curveloop]) #feed filled region as List objectr\r\n\r\n    def get_curveloop_method2():\r\n        def get_top_face(solid):\r\n            faces = solid.Faces\r\n            for face in faces.GetEnumerator():\r\n                # print str(face.GetType())\r\n                face_normal = face.ComputeNormal(DB.UV())\r\n                # print face_normal\r\n                if face_normal.DotProduct(DB.XYZ(0,0,1)) - 1 < 0.001:\r\n                    # print \"top face = {}\".format(face)\r\n                    return face\r\n            pass\r\n\r\n\r\n        t = DB.Transaction(doc, \"copy floor and reset shape\")\r\n        t.Start()\r\n        copy_floor_id = DB.ElementTransformUtils.CopyElement (doc, floor.Id, DB.XYZ(0,0,-100))[0]\r\n        copy_floor = doc.GetElement(copy_floor_id)\r\n        slab_editor = copy_floor.SlabShapeEditor\r\n        slab_editor.ResetSlabShape()\r\n        t.Commit()\r\n\r\n        opt = DB.Options()\r\n        opt.IncludeNonVisibleObjects = True\r\n        opt.ComputeReferences = True\r\n        floor_geo = copy_floor.get_Geometry(opt)\r\n        geo_objs = floor_geo.GetEnumerator()\r\n        for geo_obj in geo_objs:\r\n            # print geo_obj\r\n            if \"Solid\" in str(geo_obj.GetType()):\r\n                break\r\n        top_face = get_top_face(geo_obj)\r\n\r\n        t = DB.Transaction(doc, \"delete copy floor\")\r\n        t.Start()\r\n        doc.Delete(copy_floor.Id)\r\n        t.Commit()\r\n\r\n        curveloop = top_face.GetEdgesAsCurveLoops ()\r\n        return curveloop\r\n\r\n\r\n    # curveloop = get_curveloop_method1()\r\n    curveloop = get_curveloop_method2()\r\n    # print curveloop\r\n    t = DB.Transaction(doc, \"make new filled region\")\r\n    t.Start()\r\n\r\n    new_filled_region = DB.FilledRegion.Create(doc,\r\n                                                filled_region_type.Id,\r\n                                                view_id,\r\n                                                curveloop)\r\n\r\n    new_filled_region.SetLineStyleId (get_invisible_style().Id)\r\n\r\n    setting = DB.OverrideGraphicSettings ()\r\n    setting.SetSurfaceForegroundPatternVisible (False)\r\n    setting.SetSurfaceBackgroundPatternVisible (False)\r\n    view = doc.GetElement(view_id)\r\n    view.SetElementOverrides (floor.Id, setting)\r\n\r\n    t.Commit()\r\n    global new_filled_region_data\r\n    new_filled_region_data.append([floor, new_filled_region, view_id])\r\n    # append_new_link(floor, new_filled_region, view_id)\r\n    return\r\n\r\ndef try_create_filled_region_from_floor(floor, filled_region_type, view_id):\r\n\r\n\r\n\r\n    def get_curveloop_method1():\r\n        slab_editor = floor.SlabShapeEditor\r\n        creases = slab_editor.SlabShapeCreases\r\n        # print creases\r\n        crvs = []\r\n        for crease in creases:\r\n            # print crease\r\n            if crease.CreaseType == DB.SlabShapeCreaseType.Boundary:\r\n                # print \"add boundary\"\r\n                crvs.append(crease.Curve)\r\n\r\n        crvs = sort_crv(crvs)\r\n        curveloop = DB.CurveLoop.Create(ARCHI_UTILITY.list_to_system_list(crvs, type = \"Curve\"))\r\n        # return ARCHI_UTILITY.list_to_system_list([crvs], type = \"CurveLoop\")\r\n        return List[DB.CurveLoop]([curveloop]) #feed filled region as List objectr\r\n\r\n    def get_curveloop_method2():\r\n        def get_top_face(solid):\r\n            faces = solid.Faces\r\n            for face in faces.GetEnumerator():\r\n                # print str(face.GetType())\r\n                face_normal = face.ComputeNormal(DB.UV())\r\n                # print face_normal\r\n                if face_normal.DotProduct(DB.XYZ(0,0,1)) - 1 < 0.001:\r\n                    # print \"top face = {}\".format(face)\r\n                    return face\r\n            pass\r\n\r\n\r\n        t = DB.Transaction(doc, \"temp reset shape\")\r\n        t.Start()\r\n\r\n        slab_editor = floor.SlabShapeEditor\r\n        slab_editor.ResetSlabShape()\r\n\r\n\r\n        opt = DB.Options()\r\n        opt.IncludeNonVisibleObjects = False\r\n        opt.ComputeReferences = False\r\n        floor_geo = floor.get_Geometry(opt)\r\n        geo_objs = floor_geo.GetEnumerator()\r\n        for geo_obj in geo_objs:\r\n            # print geo_obj\r\n            if \"Solid\" in str(geo_obj.GetType()):\r\n                break\r\n        top_face = get_top_face(geo_obj)\r\n\r\n\r\n\r\n\r\n        curveloop = top_face.GetEdgesAsCurveLoops ()\r\n        t.RollBack()\r\n        print(curveloop)\r\n        return curveloop\r\n\r\n\r\n    # curveloop = get_curveloop_method1()\r\n    curveloop = get_curveloop_method2()\r\n    # print curveloop\r\n    t = DB.Transaction(doc, \"make new filled region\")\r\n    t.Start()\r\n\r\n    new_filled_region = DB.FilledRegion.Create(doc,\r\n                                                filled_region_type.Id,\r\n                                                view_id,\r\n                                                curveloop)\r\n\r\n    new_filled_region.SetLineStyleId (get_invisible_style().Id)\r\n    t.Commit()\r\n    global new_filled_region_data\r\n    new_filled_region_data.append([floor, new_filled_region, view_id])\r\n    # append_new_link(floor, new_filled_region, view_id)\r\n    return\r\n\r\ndef get_element_link_file():\r\n    file = r\"I:\\2135\\0_BIM\\10_BIM Management\\Filled Region_Floor Links\\Filled Region_Floor_Link_{}.txt\".format(doc.Title.split(\"HQ_\")[1])\r\n    return file\r\n\r\ndef OLD_append_new_link(floor, filled_region, view_id):\r\n    filepath = get_element_link_file()\r\n\r\n    data = \"{}|{}|{}|{}\".format(floor.UniqueId,\r\n                                filled_region.UniqueId,\r\n                                doc.GetElement(filled_region.GetTypeId()).UniqueId,\r\n                                doc.GetElement(view_id).UniqueId)\r\n    with open(filepath, \"a\") as f:\r\n        f.write(data)\r\n        f.write(\"\\n\")\r\n    time.sleep(0.1)\r\n\r\ndef write_new_data(new_filled_region_data):\r\n    filepath = get_element_link_file()\r\n\r\n    with open(filepath, \"a\") as f:\r\n        for data in new_filled_region_data:\r\n            floor, filled_region, view_id = data\r\n            line = \"{}|{}|{}|{}\".format(floor.UniqueId,\r\n                                        filled_region.UniqueId,\r\n                                        doc.GetElement(filled_region.GetTypeId()).UniqueId,\r\n                                        doc.GetElement(view_id).UniqueId)\r\n            f.write(line)\r\n            f.write(\"\\n\")\r\n\r\n    pass\r\n\r\ndef update_existing_filled_regions():\r\n    tg = DB.TransactionGroup(doc, \"update filled regions by record\")\r\n    tg.Start()\r\n    if len(uidoc.Selection.GetElementIds ()) != 0:\r\n        ARCHI_UTILITY.dialogue(main_text = \"No preslection needed to update.\", sub_text = \"Selection will be ignored.\")\r\n\r\n    file_path = get_element_link_file()\r\n    datas = ARCHI_UTILITY.read_txt_as_list(file_path)\r\n\r\n\r\n    # make empty file becasue i will regenerate all-------> too dangerous to empty list directly maybe memberize the content and once no error in final step to remove front end\r\n    # ARCHI_UTILITY.save_list_to_txt([], get_element_link_file())\r\n\r\n\r\n    \"\"\"\r\n    note:  one floor can have multiple filled region..\r\n\r\n    case 1:     floor yes, filled region yes ---> delete filled region, regenerate filled region in original view---->no user wanring\r\n    case 2:     floor no, filled region yes ---> delete filled region, do not regenerate ---> tell user it will delete filled region in which view\r\n    case 3:     floor yes, filled region no ---> regenerate filled region ---> tell user it will re-make filled region in original view\r\n    case 4:     floor no, filled region no ---> do nothing ----> tell user both are gone\r\n\r\n    conclusion:\r\n    # delete filled region no matter what\r\n    # generate filled region as long as there is floor, use recorded view\r\n    \"\"\"\r\n    for data in datas:\r\n        floor_id, filled_region_id, filled_region_type_id,  view_id = data.split(\"|\")\r\n\r\n        floor = doc.GetElement(floor_id)\r\n        filled_region = doc.GetElement(filled_region_id)\r\n        filled_region_type = doc.GetElement(filled_region_type_id)\r\n        view = doc.GetElement(view_id)\r\n        exist_floor = floor is not None\r\n        exist_filled_region = filled_region is not None\r\n\r\n        try:\r\n            t = DB.Transaction(doc, \"delete old filled region\")\r\n            t.Start()\r\n            doc.Delete(filled_region.Id)\r\n\r\n        except Exception as e:\r\n            ARCHI_UTILITY.print_note(e)\r\n        finally:\r\n            t.Commit()\r\n\r\n\r\n        if exist_floor and exist_filled_region:\r\n            ARCHI_UTILITY.print_note( \"floor and filled region both exist, will just regenerate filled_region\")\r\n            create_filled_region_from_floor(floor, filled_region_type, view.Id)\r\n\r\n        elif not exist_floor and exist_filled_region:\r\n            print(\"Floor '{}' is no longer in the file. Associated filled region will be removed\".format(floor_id))\r\n\r\n        elif exist_floor and not exist_filled_region:\r\n            print(\"Filled Region '{}' is no longer in the file, but source floor exist, will regenerate.\".format(filled_region_id))\r\n            create_filled_region_from_floor(floor, filled_region_type, view.Id)\r\n\r\n        elif not exist_floor and not exist_filled_region:\r\n            print(\"Both floor and associateed filled region is gone.\")\r\n\r\n        else:\r\n            print(\"Things go wrong\")\r\n\r\n    write_new_data(new_filled_region_data)\r\n    current_datas = ARCHI_UTILITY.read_txt_as_list(file_path)\r\n    # ARCHI_UTILITY.print_note( current_datas)\r\n    # ARCHI_UTILITY.print_note( current_datas[len(datas):])\r\n    new_data = list(set(current_datas) - set(datas))\r\n    ARCHI_UTILITY.save_list_to_txt(new_data, file_path, end_with_new_line = True)\r\n    tg.Commit()\r\n\r\n\r\ndef make_new_filled_regions():\r\n    # get floor in selection, check is_floor\r\n    selection_ids = uidoc.Selection.GetElementIds ()\r\n    selection = [doc.GetElement(x) for x in selection_ids]\r\n    for item in selection:\r\n        if item.GetType() != DB.Floor:\r\n            ARCHI_UTILITY.dialogue(main_text = \"Only accepting floors in selection.\")\r\n            script.exit()\r\n    floors = selection\r\n\r\n\r\n\r\n    class MyOption(forms.TemplateListItem):\r\n        @property\r\n        def name(self):\r\n            return \"{}\".format(self.LookupParameter('Type Name').AsString())\r\n    filled_region_types = list(DB.FilteredElementCollector(doc).OfClass(DB.FilledRegionType).WhereElementIsElementType().ToElements())\r\n    filled_region_types.sort(key = lambda x: x.LookupParameter('Type Name').AsString())\r\n\r\n    filled_region_type = forms.SelectFromList.show([MyOption(x) for x in filled_region_types],\r\n                                                    title = \"Pick the filled region type to use.\")\r\n\r\n\r\n\r\n\r\n\r\n    tg = DB.TransactionGroup(doc, \"Make filled region from floor\")\r\n    tg.Start()\r\n    \"\"\"\r\n    for floor in floors:\r\n\r\n        try:\r\n            create_filled_region_from_floor(floor)\r\n        except Exception as e:\r\n            print(\"Skip filled region creation on one floor element\")\r\n            print (e)\r\n    \"\"\"\r\n    map(lambda x: create_filled_region_from_floor(x, filled_region_type, doc.ActiveView.Id), floors)\r\n    write_new_data(new_filled_region_data)\r\n    tg.Commit()\r\n\r\ndef get_invisible_style():\r\n    graphic_styles = DB.FilteredElementCollector(doc).OfClass(DB.GraphicsStyle ).ToElements()\r\n    for style in graphic_styles:\r\n        if \"Invisible\" in style.Name:\r\n            return style\r\n\r\n\r\n\r\n################## main code below #####################\r\noutput = script.get_output()\r\noutput.close_others()\r\nnew_filled_region_data = []\r\n# tool 1 create: if not created, floor will make a filled region and link the stable ID between,\r\n# tool 2 update: for all floor in file, find the linked filled region, update them\r\nres = ARCHI_UTILITY.dialogue(main_text = \"I want to [...] filled regions\", options = [[\"create\", \"based on selected floor\"], [\"update previously generated\",\"will try to update all filled region generated by this tool.(beta)\"]])\r\n\r\n\r\n\"\"\"\r\n------------add third functyion to remove selecvted filled region from list\r\n\"\"\"\r\nif res == \"create\":\r\n    make_new_filled_regions()\r\nelse:\r\n    update_existing_filled_regions()\r\n\r\n\r\n#ideas:\r\n\"\"\"\r\nIDEAS\r\n    - wall to room seperation line or area boubnary line\r\n    - copy material defination, object style definiation, object style material assignment, template defination across open docs or from link\r\n    - net bound for complex curtain panel inside\r\n    -rename family/type in multiple open doc\r\n    -report dim that is not whole number\r\n\r\n    - deep purge sub family\r\n\r\n\r\n\r\n\r\n    - what is my view direvtion vector, what is this line vector\r\n    - override graphic for all user keynote as blue color,\r\n\r\n    - ceiling family alway use ceiling line but switch head up and down becasue usally you dim to the ceiling dash\r\n\r\n    - annotater family add lines for eng and CN as interger to control the left align location\r\n\r\n    - RENAME GROUP BY CURRENT VIEW---- group usage report\r\n\r\n    - flusing , bolt, fire stoper, plate, hanger, angle, tubes\r\n\r\n    - MATCH SLAB BOUDARY PINK LINES\r\n\r\n    - INUSLATED BACK PAN , OPTION TO USE CL AND SIDE Line\r\n    - TUBE OPTION TO US CL AND EDGE\r\n\r\n\r\n\r\n    - add section, elevation, to temp vision tool\r\n\r\n    - extract CAD lines by layer and assign to object style\r\n\r\n    - ANNOTATION MODE -- ONLY ABLE TO SELECT 2D ELEMENTS\r\n\r\n    - GUI recent used family type, drag and drop\r\n\r\n    - IF FAMILY NAME = TYPE NAME, THAT IS NOT GOOD, RENAME THE TYPE NAME TO \"DD\"\r\n\r\n    - PERMITION TO DELEETE ELEMENT\r\n\r\n    - mark element as non-editable, soyou dont accidentally go inside a family_doc\r\n\r\n\r\n    - detauil item object style:\r\n        insulation, water proof, profil extieor, interior, cut but not important, center, slab cut, see but not important....\r\n\r\n    - proejct line style\r\n        $$ predefined profile, ceiling, waterproffing, slab_cut, column cut, CL line, ceiling\r\n\r\n    - label unused legend and schedule\r\n\r\n    - CHANGE  $LINE STYLE TO INVISIBLE(USFUL FOR FILLED REGION)\r\n    AND CHANGE ALL INVISUABELT O T$$ea LINE SO YOU CAN CHECK THE BOUDNARY\r\n\r\n    - SHORT LIST LOCAL OVERRIDE\r\n\r\n\r\n\r\nbip = BuiltInParameter.ALL_MODEL_INSTANCE_COMMENTS\r\nprovider = ParameterValueProvider(ElementId(bip))\r\nevaluator = FilterStringEquals();\r\nrule = FilterStringRule(provider, evaluator, \"aaa\", False);\r\nfilter = ElementParameterFilter(rule);\r\nwalls = FilteredElementCollector(doc).OfClass(Wall).WherePasses(filter).ToElements()\r\n\r\nt = DB.Transaction(doc , \"action\")\r\nt.Start()\r\n#do work\r\nt.Commit()\r\n\r\n__all__ = ('pick_element', 'pick_element_by_category',\r\n           'pick_elements', 'pick_elements_by_category',\r\n           'get_picked_elements', 'get_picked_elements_by_category',\r\n           'pick_edge', 'pick_edges',\r\n           'pick_face', 'pick_faces',\r\n           'pick_linked', 'pick_linkeds',\r\n           'pick_elementpoint', 'pick_elementpoints',\r\n           'pick_point', 'pick_rectangle', 'get_selection_category_set',\r\n           'get_selection')\r\n\r\ndoc = __revit__.ActiveUIDocument.Document # pyright: ignore\r\nuidoc = __revit__.ActiveUIDocument\r\ndoc = revit.doc\r\nuidoc = revit.uidoc\r\n\r\n\r\n\r\n\r\nglobal\r\n\r\n########note to self to research\r\n#GUI window?\r\n#how did select from para window show extra icon  instance/type by list?\r\n#try to search from directory the name used for revit tab manager?\r\n\r\n\r\nfake delete Transaction\r\n    with revit.DryTransaction(\"Search for linked elements\"):\r\n        linked_elements_list = revit.doc.Delete(selection.first.Id)\r\n\r\nfrom playsound import playsound\r\nplaysound('/path/to/a/sound/file/you/want/to/play.mp3')\r\n\r\nFREQUENTLY_SELECTED_CATEGORIES = [\r\n    DB.BuiltInCategory.OST_Areas,\r\n    DB.BuiltInCategory.OST_AreaTags,\r\n    DB.BuiltInCategory.OST_AreaSchemeLines,\r\n    DB.BuiltInCategory.OST_Columns,\r\n    DB.BuiltInCategory.OST_StructuralColumns,\r\n    DB.BuiltInCategory.OST_Dimensions,\r\n    DB.BuiltInCategory.OST_Doors,\r\n    DB.BuiltInCategory.OST_Floors,\r\n    DB.BuiltInCategory.OST_StructuralFraming,\r\n    DB.BuiltInCategory.OST_Furniture,\r\n    DB.BuiltInCategory.OST_Grids,\r\n    DB.BuiltInCategory.OST_Rooms,\r\n    DB.BuiltInCategory.OST_RoomTags,\r\n    DB.BuiltInCategory.OST_CurtainWallPanels,\r\n    DB.BuiltInCategory.OST_Walls,\r\n    DB.BuiltInCategory.OST_Windows,\r\n    DB.BuiltInCategory.OST_Ceilings,\r\n    DB.BuiltInCategory.OST_SectionBox,\r\n    DB.BuiltInCategory.OST_ElevationMarks,\r\n    DB.BuiltInCategory.OST_Parking,\r\n    DB.BuiltInCategory.OST_GenericModel\r\n    OST_Sheets\r\n    OST_TextNotes\r\n    OST_GenericLines\r\n    OST_Lines\r\n]\r\n\r\n\r\nremove duplicate from list:\r\nlist({x for x in list_raw})\r\n\r\nfilter(function, sequence)\r\nParameters:\r\nfunction: function that tests if each element of a\r\nsequence true or not.\r\nsequence: sequence which needs to be filtered, it can\r\nbe sets, lists, tuples, or containers of any iterators.\r\nReturns:\r\nreturns an iterator that is already filtered.\r\n\r\n\r\n\r\nfrom datetime import date\r\nprint(date.today())\r\n\r\n\r\nkeynotes = DB.FilteredElementCollector(revit.doc,revit.active_view.Id)\\\r\n              .OfCategory(DB.BuiltInCategory.OST_KeynoteTags)\\\r\n              .WhereElementIsNotElementType()\\\r\n              .ToElements()\r\n\r\nWhereElementIsElementType()\r\n#to get element type name\r\ntype.LookupParameter(\"Type Name\").AsString()\r\n\r\n\r\n# ICollections format: System.Collections.Generic.List[DB.date type]([list data])\r\n    shapes = [shapes list]\r\n    shape_collection = System.Collections.Generic.List[DB.ElementId]([x.Id for x in shapes])\r\n    revit.active_view.IsolateElementsTemporary(shape_collection)\r\n\r\n\r\n##Rhino - Rhino3dmIO\r\n\r\nRhino3dmIO is a subset of RhinoCommon and it gives you access to openNurbs, allowing you to, amongst other things, read and write 3dm files.\r\n>>> from rpw.extras.rhino import Rhino as rc\r\n>>> pt1 = rc.Geometry.Point3d(0,0,0)\r\n>>> pt2 = rc.Geometry.Point3d(10,10,0)\r\n>>> line1 = rc.Geometry.Line(pt1, pt2)\r\n>>> line1.Length\r\n14.142135623730951\r\n>>>\r\n>>> pt1 = rc.Geometry.Point3d(10,0,0)\r\n>>> pt2 = rc.Geometry.Point3d(0,10,0)\r\n>>> line2 = rc.Geometry.Line(pt1, pt2)\r\n>>>\r\n>>> rc.Geometry.Intersect.Intersection.LineLine(line1, line2)\r\n(True, 0.5, 0.5)\r\n>>>\r\n>>> file3dm = f = rc.FileIO.File3dm()\r\n>>> file3md_options = rc.FileIO.File3dmWriteOptions()\r\n>>> file3dm.Objects.AddLine(line1)\r\n>>> filepath = 'c:/folder/test.3dm'\r\n>>> file3dm.Write(filepath, file3md_options)\r\n\r\n\r\nforms.WPFWindow(xaml_source, literal_string=False, handle_esc=True, set_owner=True)\r\n>>> from pyrevit import forms\r\n>>> layout = '<Window ' \\\r\n>>>          'xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" ' \\\r\n>>>          'xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" ' \\\r\n>>>          'ShowInTaskbar=\"False\" ResizeMode=\"NoResize\" ' \\\r\n>>>          'WindowStartupLocation=\"CenterScreen\" ' \\\r\n>>>          'HorizontalContentAlignment=\"Center\">' \\\r\n>>>          '</Window>'\r\n>>> w = forms.WPFWindow(layout, literal_string=True)\r\n>>> w.show()\r\n\r\n\r\n>>> with ErrorSwallower() as swallower:\r\n>>>     for fam in families:\r\n>>>         revit.doc.EditFamily(fam)\r\n>>>         if swallower.get_swallowed():\r\n>>>             logger.warn(\"Warnings swallowed\")\r\n\r\nforms.alert(msg, title=None, sub_msg=None, expanded=None, footer='', ok=True, cancel=False, yes=False, no=False, retry=False, warn_icon=True, options=None, exitscript=False)\r\nforms.ask_for_color(default=None)\r\nforms.ask_for_one_item(items, default=None, prompt=None, title=None, **kwargs)\r\nforms.ask_for_string(default=None, prompt=None, title=None, **kwargs)\r\nforms.select_family_parameters(family_doc, title='Select Parameters', button_name='Select', multiple=True, filterfunc=None, include_instance=True, include_type=True, include_builtin=True, include_labeled=True)\r\nforms.select_image(images, title='Select Image', button_name='Select')\r\nforms.select_parameters(src_element, title='Select Parameters', button_name='Select', multiple=True, filterfunc=None, include_instance=True, include_type=True, exclude_readonly=True)\r\nforms.select_swatch(title='Select Color Swatch', button_name='Select')\r\nforms.select_views(title='Select Views', button_name='Select', width=500, multiple=True, filterfunc=None, doc=None, use_selection=False)\r\nforms.select_viewtemplates(title='Select View Templates', button_name='Select', width=500, multiple=True, filterfunc=None, doc=None)\r\nforms.toast(message, title='pyRevit', appid='pyRevit', icon=None, click=None, actions=None)\r\n\r\noutput = pyrevit.output.get_output()\r\noutput.print_image(r'C:\\image.gif')\r\nprint(script.get_script_path())\r\nprint(script.get_bundle_files())\r\nprint(script.get_bundle_file('triangle.png'))\r\noutput.set_width(1500)\r\noutput.set_height(900)\r\noutput.center()\r\noutput.close_others()\r\n#output.open_url(\"http://dict.cn/\")\r\noutput.show()\r\noutput.print_md(str)----->    https://www.markdownguide.org/basic-syntax/\r\n        bold ====   **text**\r\n        italic ====   *text*\r\n        bold and italic ======   ***text***\r\n        heading =======   ## text   (# biggest, ##### smallest)\r\n\r\n\r\n\r\n\r\n\r\nno_sheet_views.sort(key = lambda x: x.ViewType, reverse = True)\r\n\r\n\r\n\r\n\r\nwith forms.WarningBar(title='Pick title corner point'):\r\n    ref_pt = revit.pick_point()\r\n\r\n\r\n\r\n\r\nsel_sheets = forms.select_sheets(title='Select Sheets That contain views that you want to do temperory template')\r\n\r\n\r\n\r\nres = forms.alert(options = [\"mark title corners at sheets\", \"remove existing marks from sheets.\"], msg = \"I want to [.....]\")\r\n\r\nif \"remove\" in res:\r\n    option = False\r\nelif \"mark\" in res:\r\n    option = True\r\nelse:\r\n    script.exit()\r\n\r\n\r\n\r\nforms.alert(msg = '{0} FILES RENAMED.'.format(sheetcount), sub_msg = fail_text)\r\n\r\n\r\n\r\n\r\n\r\nfrom pyrevit import forms\r\nitems = ['item1', 'item2', 'item3']\r\nres = forms.SelectFromList.show(context = items, button_name='Select Item')\r\nif res == 'item1':\r\n    do_stuff()\r\n~~~~~\r\nops = [viewsheet1, viewsheet2, viewsheet3]\r\nres = forms.SelectFromList.show(ops,\r\n                                multiselect=False,\r\n                                name_attr='Name',\r\n                                button_name='Select Sheet')\r\nif res.Id == viewsheet1.Id:\r\n    do_stuff()\r\n~~~\r\nforms.SelectFromList.show(\r\n        {'All': '1 2 3 4 5 6 7 8 9 0'.split(),\r\n         'Odd': '1 3 5 7 9'.split(),\r\n         'Even': '2 4 6 8 0'.split()},\r\n        title='MultiGroup List',\r\n        group_selector_title='Select Integer Range:',\r\n        multiselect=True\r\n    )\r\n~~~\r\nops = {'Sheet Set A': [viewsheet1, viewsheet2, viewsheet3],\r\n       'Sheet Set B': [viewsheet4, viewsheet5, viewsheet6]}\r\nres = forms.SelectFromList.show(ops,\r\n                                multiselect=True,\r\n                                name_attr='Name',\r\n                                group_selector_title='Sheet Sets',\r\n                                button_name='Select Sheets')\r\nif res.Id == viewsheet1.Id:\r\n    do_stuff()\r\n~~~\r\nfrom pyrevit import forms\r\n\r\nclass MyOption(forms.TemplateListItem):\r\n    @property\r\n    def name(self):\r\n        return \"Option: {}\".format(self.item)\r\n\r\nops = [MyOption('op1'), MyOption('op2', checked=True), MyOption('op3')]\r\nres = forms.SelectFromList.show(ops,\r\n                                multiselect=True,\r\n                                button_name='Select Item')\r\n~~~\r\n\r\nselected_views = forms.SelectFromList.show(no_sheet_views,\r\n                                multiselect=True,\r\n                                name_attr='Name',\r\n                                title = \"Those views are not on sheet\",\r\n                                button_name= \"Mark them with 'NoSheet-' prefix\",\r\n                                filterfunc=lambda x: x.ViewType not in [DB.ViewType.Legend, DB.ViewType.Schedule])\r\n\r\n\r\n\r\n\r\nDB.FilteredElementCollector(revit.doc).OfClass(DB.RevitLinkInstance).WhereElementIsNotElementType().ToElements()\r\n\r\n.OfCategory(DB.BuiltInCategory.OST_Massing)\r\n\r\n\r\n\r\n\r\n\r\nwith revit.Transaction(\"Mark NoSheet Views\"):\r\n    for view in selected_views:\r\n        new_name = \"NoSheet-\" + view.Name\r\n        view.Parameter[DB.BuiltInParameter.VIEW_NAME].Set(new_name)\r\n\r\n\r\n\r\n\r\n\r\ndef final_print_table():\r\n    table_data = []\r\n    for item in view_item_collection:\r\n        if item.view_name in view_item_collection_selected:\r\n            #temp_list = [item.critical_level_text, item.view_name, item.line_count]\r\n            temp_list = [ item.critical_level_text, item.view_name, item.line_count, output.linkify(item.id, title = \"Go To View\")]\r\n            table_data.append(temp_list)\r\n    output.print_table(table_data=table_data,title=\"Bad Views by Line Count \",columns=[ \"Critical Level\", \"View Name\", \"Line Count\", \"View Link\"],formats=['', '{}', '{} Lines', '{}'])\r\n\r\n\r\n\r\noutput.freeze()\r\noutput.unfreeze()\r\noutput.self_destruct()\r\noutput.set_title()\r\noutput.update_progress(cur_value, max_value)\r\noutput.add_style('body { color: blue; }')\r\n\r\n\r\n\r\n\r\n\r\nwith forms.ProgressBar(title = \"Checking Families, Hold On...({value} of {max_value})\", step = pb_step, cancellable = True) as pb:\r\n# initiate the class collection.\r\n    for family in all_families:\r\n\r\n        family_item_collection.append(family_item(family))\r\n\r\n\r\n\r\n        global_counter += 1\r\n        if global_counter > limit:\r\n            break\r\n\r\n        if pb.cancelled:\r\n            script.exit()\r\n        pb.update_progress(global_counter, limit)\r\n\r\n\r\n>>> for count, value in enumerate(values):\r\n...     print(count, value)\r\n\r\n\r\nselection = revit.get_selection()\r\n\r\nif len(selection) > 1:\r\n    forms.alert(\"Please select 1 tags only.\")\r\n    script.exit()\r\n\r\nif \"Tags\" not in selection[0].Category.Name:\r\n    forms.alert(\"This is not a tag.\")\r\n    script.exit()\r\n\r\n\r\nref_tag = revit.doc.GetElement(get_ref_tag_id())\r\n\r\n\"\"\"\r\n",
  "language": "python",
  "imports": [
    "RhinoCommon"
  ],
  "has_docstring": false
}