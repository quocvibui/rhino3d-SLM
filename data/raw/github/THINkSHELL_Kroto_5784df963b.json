{
  "source_url": "https://github.com/THINkSHELL/Kroto/blob/2599fe8763055955f43fb79a7b924bcac4337c05/src/meshminimizehelpers.py",
  "repo": "THINkSHELL/Kroto",
  "repo_stars": 0,
  "repo_description": "Tools implementing the surface density method in Rhinoceros3D, with Grasshopper integration. Python version",
  "license": "AGPL-3.0",
  "filepath": "src/meshminimizehelpers.py",
  "instruction": "Defines some helper functions for the meshminimize module",
  "code": "# -*- coding: utf-8 -*-\n#\n#  Kroto Membrane Form-finding.\n#  Copyright Â© 2015, Thinkshell & Laboratoire Navier, ENPC.\n#\n#  This file is part of Kroto.\n#\n#  Kroto is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU Affero General Public License as\n#  published by the Free Software Foundation, either version 3 of\n#  the License, or (at your option) any later version.\n#\n#  Kroto is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n#  GNU Affero General Public License for more details.\n#\n#  You should have received a copy of the GNU Affero General Public License\n#  along with Kroto. If not, see http://www.gnu.org/licenses/.\n#\n\n\"\"\"Defines some helper functions for the meshminimize module\n\"\"\"\n\nimport rhinoscriptsyntax as rs\nimport vectorworks as vw\nimport meshminimize as mm\n\n\ndef redraw_off(func, *args, **kargs):\n    \"\"\"Decorator function turning off Redraw in Rhino.\n\n    Parameters:\n      func = function to be decorated\n      *args, **kargs = arguments\n    Returns:\n      wrapper = decorated function\n    \"\"\"\n    def wrapper(*args, **kargs):\n        prev = rs.EnableRedraw(False)\n        result = func(*args, **kargs)\n        if not prev:\n            # Already off, do not redraw\n            return result\n        rs.EnableRedraw(True)\n        rs.Redraw()\n        return result\n    return wrapper\n\n\ndef upward_face(n, x1, x2, x3):\n    \"\"\"Returns True if the face orientation defined by the order of the\n    passed in points (screw rule) is the same as that of the mesh,\n    passed by the normal n.\n\n    Parameters:\n        n = Vector normal of the face\n            n would normally be taken from rs.MeshFaceNormals(mesh)\n            which gives a consistent orientation to the mesh over all\n            faces, if normals have unified.\n        x1, x2, x3 = 3D Points representing the triangular face\n    Returns:\n        True or False\n    \"\"\"\n\n    v2 = vw.vecminus3(x2, x1)\n    v3 = vw.vecminus3(x3, x1)\n\n    # Using rs's method for vector computation is slower than vw's, but\n    # it takes into account nasty tolerance things.\n    vv = vw.crossproduct3(v2, v3)\n    a = vw.dotproduct3(vv, n)\n    return a > 0\n\n\n@redraw_off  # noqa\ndef define_cables(cables, q_cables, vertices, naked, fixed):\n    \"\"\"Defines the cables list structure from the Rhino geometry.\n    Connects the mesh vertices lying on a polyline together. The\n    polyline vertices are not considered as ends for the\n    mm.FIXED_CABLE_ENDS option.\n\n    Arguments:\n      cables = list of Rhino polylines representing the cables\n      q_cables = list of force density coefficients for each cable\n      vertices = list of mesh vertices\n      naked = list of naked mesh vertices, from rs.MeshNakedVertice(mesh)\n      fixed = list of fixed vertices\n    Returns:\n      ql = list of list of force density coef for each cable segment\n           connected to the vertices\n      n_cable = number of cable segments connected to each vertices\n      fixed = updated list of fixed vertices\n    \"\"\"\n\n    # Make sure we know what \"point on cable\" means\n    tol = rs.UnitAbsoluteTolerance()\n\n    # Initialize\n    # vcab = list of list of vertices on each cable\n    # ql = list of list of the connected cables force densities,\n    #      for each vertex\n    # n_cable = connectivity matrix of the cables\n    #         = list of list of connected vertices to each vertex\n    vcab = [[] for i in cables]\n    ql = [[] for i in vertices]\n    n_cable = [[] for i in vertices]\n\n    for v, vertex in enumerate(vertices):\n        # Only consider naked edge vertices, if a cable is in the middle\n        #  of a mesh then these edges have to be split\n        if naked[v]:\n            for i, cable in enumerate(cables):\n                v_proj_cab = rs.EvaluateCurve(\n                    cable,\n                    rs.CurveClosestPoint(cable, vertex)\n                )\n                dis_v_to_cab = rs.Distance(v_proj_cab, vertex)\n\n                if dis_v_to_cab < tol:\n                    # Vertex is on cable i, save it to vcab[i]\n                    vcab[i].append(v)\n                    dis_v_to_ends = min(\n                        rs.Distance(rs.CurveEndPoint(cable), vertex),\n                        rs.Distance(rs.CurveStartPoint(cable), vertex)\n                    )\n                    if mm.FIXED_CABLE_ENDS and dis_v_to_ends < tol:\n                        # Vertex is on a cable end, fix it if needed\n                        if mm.DEBUG:\n                            rs.AddPoint(vertex)\n                        fixed[v] = True\n\n    for i, cable in enumerate(cables):\n        if vcab[i] == []:\n            raise ValueError(\n                'Cable #%i appears to be too far off the mesh' % i\n            )\n        # Sort vertices along cable, successive vertices will be linked\n        vcab[i].sort(key=lambda v: rs.CurveClosestPoint(cable, vertices[v]))\n        # If cable is closed, re-add first vertex at the end\n        if rs.Distance(rs.CurveStartPoint(cable),\n                       rs.CurveEndPoint(cable)) < tol:\n            vcab[i].append(vcab[i][0])\n\n        # Construct connectivity matrix for current cable\n        for j in range(len(vcab[i])):\n            if not fixed[vcab[i][j]]:\n                if j:\n                    n_cable[vcab[i][j]].append(vcab[i][j - 1])\n                    ql[vcab[i][j]].append(q_cables[i])\n                if j - len(vcab[i]) + 1:\n                    n_cable[vcab[i][j]].append(vcab[i][j + 1])\n                    ql[vcab[i][j]].append(q_cables[i])\n\n    return ql, n_cable, fixed\n\n\n@redraw_off\ndef orient_mesh_faces(mesh):\n    \"\"\"Orients faces around the nodes in a mesh to a consistent order\n    and normal direction. Roughly equivalent to rs.MeshFaceVertices, but\n    we control the list order.\n\n    Arguments:\n      mesh = the mesh in RhinoCommon type\n    Returns:\n      vertex_faces list of faces adjacent to a node\n    \"\"\"\n\n    normals = rs.MeshFaceNormals(mesh)\n    vertices = rs.MeshVertices(mesh)\n    connec = rs.MeshFaceVertices(mesh)\n    vertex_faces = {}\n    for i, vertex in enumerate(vertices):\n        for j, face in enumerate(rs.MeshVertexFaces(mesh, i)):\n            # Find the three distinct points, 4th is redundant in\n            # triangular meshes and remove current point from the set.\n            # Might break the original ordering, but we will take care\n            # of that our own way afterwards.\n            others = list(set(connec[face]) - {i, })\n            [x2, x3] = [vertices[n] for n in others]\n            if upward_face(normals[face], vertex, x2, x3):\n                vertex_faces[(i, j)] = [i, others[0], others[1]]\n                if mm.DEBUG:\n                    print 'not flip'\n            else:\n                vertex_faces[(i, j)] = [i, others[1], others[0]]\n                if mm.DEBUG:\n                    print 'flip'\n    return vertex_faces\n\n\n@redraw_off\ndef mesh_distance(vertices, objective):\n    \"\"\"Evaluates the distance between two set of vertices representing\n    the same mesh in different positions.  The distance is just a max of\n    the squared length between the two vertices at corresponding indices\n    in the list, so the meshes should look similar from the beginning if\n    we want this to mean something.\n\n    Arguments:\n      vertices, objectives = list of vertices, from rs.MeshVertices(mesh)\n    Returns:\n      max squared distance between two vertices at the same index\n    \"\"\"\n\n    distance = 0\n    for i in range(len(vertices)):\n        temp = vw.dist3(objective[i], vertices[i])\n        if temp > distance:\n            distance = temp\n    return distance\n\n\n@redraw_off\ndef mesh_closest_vertices(mesh, points):\n    \"\"\"Finds the vertices of a mesh that are within the document's tolerance\n    of one of the points in the list.\n    Arguments:\n        mesh = a Rhino mesh\n        points = a list of Rhino points\n    Returns:\n        fixed = a list of boolean, True if the vertex is close to one of\n                the points\n    \"\"\"\n\n    import rhinoscriptsyntax as rs\n\n    tol = rs.UnitAbsoluteTolerance()\n    vertices = rs.MeshVertices(mesh)\n    fixed = [False for i in vertices]\n\n    for i, vertex in enumerate(vertices):\n        for point in points:\n            if rs.Distance(point, vertex) < tol:\n                fixed[i] = True\n                break\n    return fixed\n\n\ndef update_qs(mesh, vertices, qs):\n    \"\"\"Updates the surface stress density coefficients to reach a more\n    uniform stress over the surface. Computes surface stresses at the\n    same time.\n    Arguments:\n      mesh = the Rhino mesh\n      vertices = the current position of the mesh vertices\n      qs = the list current values of qs for each face\n    Returns:\n      dev_sigma = maximum deviation to mean-value of the surface stress\n      qs = updated qs list\n      sigma = surface stresses\n    \"\"\"\n\n    faces = rs.MeshFaceVertices(mesh)\n    mean_sigma = 0\n    dev_sigma = 0\n    sigma = [0 for i in faces]\n    n_faces = len(sigma)\n\n    # Compute mean stress value\n    for i, face in enumerate(faces):\n        x1 = vertices[face[0]]  # = X_1j, 3D point, [3x1] vector\n        x2 = vertices[face[1]]  # = X_2j, 3D point, [3x1] vector\n        x3 = vertices[face[2]]  # = X_3j, 3D point, [3x1] vector\n        x12 = vw.vecminus3(x2, x1)\n        x23 = vw.vecminus3(x3, x1)\n        face_area = .5 * vw.norm3(vw.crossproduct3(x12, x23))\n        sigma[i] = qs[i] * face_area\n        mean_sigma += sigma[i] / n_faces\n\n    # Find the maximum deviation to the mean value\n    dev_sigma = max([abs(sig - mean_sigma) for sig in sigma])\n\n    # If above tolerance, update\n    if dev_sigma > mm.MAX_DEV_SIGMA:\n        for i, sigma_i in enumerate(sigma):\n            qs[i] = qs[i] * mean_sigma / sigma_i\n\n    return dev_sigma, qs, sigma\n",
  "language": "python",
  "imports": [
    "RhinoCommon",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}