{
  "source_url": "https://github.com/gtalarico/ironpython-stubs/blob/c7f6a6cb197e3949e40a4880a0b2a44e72d0a940/release/stubs.min/Rhino/Geometry/__init___parts/Quaternion.py",
  "repo": "gtalarico/ironpython-stubs",
  "repo_stars": 261,
  "repo_description": "Autocomplete stubs for common IronPython/.NET libraries",
  "license": "NOASSERTION",
  "filepath": "release/stubs.min/Rhino/Geometry/__init___parts/Quaternion.py",
  "instruction": "Quaternion",
  "code": "class Quaternion(object,IEquatable[Quaternion],IEpsilonComparable[Quaternion]):\r\n \"\"\"\r\n Represents the four coefficient values in a quaternion.\r\n\r\n    The first value a is the real part,\r\n\r\n    while the rest multipies i,j and k,that are imaginary.quaternion=a + bi + cj + dk\r\n\r\n \r\n\r\n Quaternion(a: float,b: float,c: float,d: float)\r\n \"\"\"\r\n @staticmethod\r\n def CrossProduct(p,q):\r\n  \"\"\"\r\n  CrossProduct(p: Quaternion,q: Quaternion) -> Quaternion\r\n\r\n  \r\n\r\n   Computes the vector cross product of p and q=(0,x,y,z),\r\n\r\n     where (x,y,z)=\r\n\r\n    Rhino.Geometry.Vector3d.CrossProduct(Rhino.Geometry.Vector3d,Rhino.Geometry.Vector3d)CrossProduct\r\n\r\n    (p.Rhino.Geometry.Quaternion.VectorVector,q.Rhino.Geometry.Quaternion.VectorVector).This is not \r\n\r\n    the same as the quaternion product p*q.\r\n\r\n  \r\n\r\n  \r\n\r\n   p: A quaternion.\r\n\r\n   q: Another quaternion.\r\n\r\n   Returns: A new quaternion.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def Distance(p,q):\r\n  \"\"\"\r\n  Distance(p: Quaternion,q: Quaternion) -> float\r\n\r\n  \r\n\r\n   Returns the distance or norm of the difference between two quaternions.\r\n\r\n  \r\n\r\n   p: A quaternion.\r\n\r\n   q: Another quaternion.\r\n\r\n   Returns: (p - q).Length()\r\n  \"\"\"\r\n  pass\r\n def DistanceTo(self,q):\r\n  \"\"\"\r\n  DistanceTo(self: Quaternion,q: Quaternion) -> float\r\n\r\n  \r\n\r\n   Computes the distance or norm of the difference between this and another quaternion.\r\n\r\n  \r\n\r\n   q: Another quaternion.\r\n\r\n   Returns: (this - q).Length.\r\n  \"\"\"\r\n  pass\r\n def EpsilonEquals(self,other,epsilon):\r\n  \"\"\"\r\n  EpsilonEquals(self: Quaternion,other: Quaternion,epsilon: float) -> bool\r\n\r\n  \r\n\r\n   Check that all values in other are within epsilon of the values in this\r\n  \"\"\"\r\n  pass\r\n def Equals(self,*__args):\r\n  \"\"\"\r\n  Equals(self: Quaternion,obj: object) -> bool\r\n\r\n  \r\n\r\n   Determines whether an object is a quaternion and has the same value of this quaternion.\r\n\r\n  \r\n\r\n   obj: Another object to compare.\r\n\r\n   Returns: true if obj is a quaternion and has exactly equal coefficients; otherwise false.\r\n\r\n  Equals(self: Quaternion,other: Quaternion) -> bool\r\n\r\n  \r\n\r\n   Determines whether this quaternion has the same value of another quaternion.\r\n\r\n  \r\n\r\n   other: Another quaternion to compare.\r\n\r\n   Returns: true if the quaternions have exactly equal coefficients; otherwise false.\r\n  \"\"\"\r\n  pass\r\n def GetHashCode(self):\r\n  \"\"\"\r\n  GetHashCode(self: Quaternion) -> int\r\n\r\n  \r\n\r\n   Gets a non-unique but repeatable hashing code for this quaternion.\r\n\r\n   Returns: A signed number.\r\n  \"\"\"\r\n  pass\r\n def GetRotation(self,*__args):\r\n  \"\"\"\r\n  GetRotation(self: Quaternion) -> (bool,Plane)\r\n\r\n  \r\n\r\n   Returns the frame created by applying the quaternion's rotation\r\n\r\n     to the canonical \r\n\r\n    world frame (1,0,0),(0,1,0),(0,0,1).\r\n\r\n  \r\n\r\n   Returns: true if the operation succeeded; otherwise,false.\r\n\r\n  GetRotation(self: Quaternion) -> (bool,float,Vector3d)\r\n\r\n  \r\n\r\n   Returns the rotation defined by the quaternion.\r\n\r\n   Returns: True if the operation succeeded; otherwise,false.\r\n  \"\"\"\r\n  pass\r\n def Invert(self):\r\n  \"\"\"\r\n  Invert(self: Quaternion) -> bool\r\n\r\n  \r\n\r\n   Modifies this quaternion to become\r\n\r\n     (a/L2,-b/L2,-c/L2,-d/L2),where L2=length \r\n\r\n    squared=(a*a + b*b + c*c + d*d).This is the multiplicative inverse,i.e.,\r\n\r\n     \r\n\r\n    (a,b,c,d)*(a/L2,-b/L2,-c/L2,-d/L2)=(1,0,0,0).\r\n\r\n  \r\n\r\n   Returns: true if successful. false if the quaternion is zero and cannot be inverted.\r\n  \"\"\"\r\n  pass\r\n def MatrixForm(self):\r\n  \"\"\"\r\n  MatrixForm(self: Quaternion) -> Transform\r\n\r\n  \r\n\r\n   Returns 4x4 real valued matrix form of the quaternion\r\n\r\n     a  b  c  d\r\n\r\n     -b  a \r\n\r\n    -d  c\r\n\r\n     -c  d  a -b\r\n\r\n     -d -c  b  a\r\n\r\n     which has the same \r\n\r\n    arithmetic properties as the quaternion.\r\n\r\n  \r\n\r\n   Returns: A transform value.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def Product(p,q):\r\n  \"\"\"\r\n  Product(p: Quaternion,q: Quaternion) -> Quaternion\r\n\r\n  \r\n\r\n   The quaternion product of p and q.  This is the same value as p*q.\r\n\r\n  \r\n\r\n   p: The first trasform.\r\n\r\n   q: The second trasform.\r\n\r\n   Returns: A transform value.\r\n  \"\"\"\r\n  pass\r\n def Rotate(self,v):\r\n  \"\"\"\r\n  Rotate(self: Quaternion,v: Vector3d) -> Vector3d\r\n\r\n  \r\n\r\n   Rotates a 3d vector. This operation is also called conjugation,\r\n\r\n     because the result \r\n\r\n    is the same as\r\n\r\n     (q.Conjugate()*(0,x,y,x)*q/q.LengthSquared).Vector.\r\n\r\n  \r\n\r\n  \r\n\r\n   v: The vector to be rotated.\r\n\r\n   Returns: R*v,where R is the rotation defined by the unit quaternion.\r\n\r\n     This is mathematically \r\n\r\n    the same as the values\r\n\r\n     (Inverse(q)*(0,x,y,z)*q).Vector\r\n\r\n     and\r\n\r\n       \r\n\r\n     (q.Conjugate()*(0,x,y,x)*q/q.LengthSquared).Vector.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def Rotation(*__args):\r\n  \"\"\"\r\n  Rotation(plane0: Plane,plane1: Plane) -> Quaternion\r\n\r\n  \r\n\r\n   Returns the unit quaternion that represents the the rotation that maps\r\n\r\n     plane0.xaxis \r\n\r\n    to plane1.xaxis,plane0.yaxis to plane1.yaxis,and \r\n\r\n     plane0.zaxis to plane1.zaxis.\r\n\r\n  \r\n\r\n  \r\n\r\n   plane0: The first plane.\r\n\r\n   plane1: The second plane.\r\n\r\n   Returns: A quaternion value.\r\n\r\n  Rotation(angle: float,axisOfRotation: Vector3d) -> Quaternion\r\n\r\n  \r\n\r\n   Returns the unit quaternion\r\n\r\n     cos(angle/2),sin(angle/2)*x,sin(angle/2)*y,\r\n\r\n    sin(angle/2)*z\r\n\r\n     where (x,y,z) is the unit vector parallel to axis.  This is the\r\n\r\n   \r\n\r\n      unit quaternion that represents the rotation of angle about axis.\r\n\r\n  \r\n\r\n  \r\n\r\n   angle: An angle in radians.\r\n\r\n   axisOfRotation: The axis of rotation.\r\n\r\n   Returns: A new quaternion.\r\n  \"\"\"\r\n  pass\r\n def Set(self,a,b,c,d):\r\n  \"\"\"\r\n  Set(self: Quaternion,a: float,b: float,c: float,d: float)\r\n\r\n   Sets all coefficients of the quaternion.\r\n  \"\"\"\r\n  pass\r\n def SetRotation(self,*__args):\r\n  \"\"\"\r\n  SetRotation(self: Quaternion,plane0: Plane,plane1: Plane)\r\n\r\n   Sets the quaternion to the unit quaternion which rotates\r\n\r\n     plane0.xaxis to \r\n\r\n    plane1.xaxis,plane0.yaxis to plane1.yaxis,\r\n\r\n     and plane0.zaxis to plane1.zaxis.\r\n\r\n  \r\n\r\n  \r\n\r\n   plane0: The \"from\" rotation plane. Origin point is ignored.\r\n\r\n   plane1: The \"to\" rotation plane. Origin point is ignored.\r\n\r\n  SetRotation(self: Quaternion,angle: float,axisOfRotation: Vector3d)\r\n\r\n   Sets the quaternion to cos(angle/2),sin(angle/2)*x,sin(angle/2)*y,sin(angle/2)*z\r\n\r\n     \r\n\r\n    where (x,y,z) is the unit vector parallel to axis.  This is the unit quaternion\r\n\r\n     \r\n\r\n    that represents the rotation of angle about axis.\r\n\r\n  \r\n\r\n  \r\n\r\n   angle: in radians.\r\n\r\n   axisOfRotation: The direction of the axis of rotation.\r\n  \"\"\"\r\n  pass\r\n def Unitize(self):\r\n  \"\"\"\r\n  Unitize(self: Quaternion) -> bool\r\n\r\n  \r\n\r\n   Scales the quaternion's coordinates so that a*a + b*b + c*c + d*d=1.\r\n\r\n   Returns: true if successful.  false if the quaternion is zero and cannot be unitized.\r\n  \"\"\"\r\n  pass\r\n def __add__(self,*args):\r\n  \"\"\" x.__add__(y) <==> x+y \"\"\"\r\n  pass\r\n def __div__(self,*args):\r\n  \"\"\" x.__div__(y) <==> x/y \"\"\"\r\n  pass\r\n def __eq__(self,*args):\r\n  \"\"\" x.__eq__(y) <==> x==y \"\"\"\r\n  pass\r\n def __init__(self,*args):\r\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n  pass\r\n def __mul__(self,*args):\r\n  \"\"\" x.__mul__(y) <==> x*yx.__mul__(y) <==> x*yx.__mul__(y) <==> x*yx.__mul__(y) <==> x*y \"\"\"\r\n  pass\r\n @staticmethod\r\n def __new__(self,a,b,c,d):\r\n  \"\"\"\r\n  __new__[Quaternion]() -> Quaternion\r\n\r\n  \r\n\r\n  __new__(cls: type,a: float,b: float,c: float,d: float)\r\n  \"\"\"\r\n  pass\r\n def __ne__(self,*args):\r\n  pass\r\n def __radd__(self,*args):\r\n  \"\"\"\r\n  __radd__(a: Quaternion,b: Quaternion) -> Quaternion\r\n\r\n  \r\n\r\n   Adds two quaternions.\r\n\r\n     This sums each quaternion coefficient with its correspondant \r\n\r\n    and returns\r\n\r\n     a new result quaternion.\r\n\r\n  \r\n\r\n  \r\n\r\n   a: A quaternion.\r\n\r\n   b: Another quaternion.\r\n\r\n   Returns: A new quaternion.\r\n  \"\"\"\r\n  pass\r\n def __reduce_ex__(self,*args):\r\n  pass\r\n def __repr__(self,*args):\r\n  \"\"\" __repr__(self: object) -> str \"\"\"\r\n  pass\r\n def __rmul__(self,*args):\r\n  \"\"\"\r\n  __rmul__(a: Quaternion,b: Quaternion) -> Quaternion\r\n\r\n  \r\n\r\n   Multiplies a quaternion with another one.\r\n\r\n     Quaternion multiplication (Hamilton \r\n\r\n    product) is not commutative.\r\n\r\n  \r\n\r\n  \r\n\r\n   a: The first term.\r\n\r\n   b: The second term.\r\n\r\n   Returns: A new quaternion.\r\n  \"\"\"\r\n  pass\r\n def __rsub__(self,*args):\r\n  \"\"\"\r\n  __rsub__(a: Quaternion,b: Quaternion) -> Quaternion\r\n\r\n  \r\n\r\n   Subtracts a quaternion from another one.\r\n\r\n     This computes the difference of each \r\n\r\n    quaternion coefficient with its\r\n\r\n     correspondant and returns a new result quaternion.\r\n\r\n  \r\n\r\n  \r\n\r\n   a: A quaternion.\r\n\r\n   b: Another quaternion.\r\n\r\n   Returns: A new quaternion.\r\n  \"\"\"\r\n  pass\r\n def __str__(self,*args):\r\n  pass\r\n def __sub__(self,*args):\r\n  \"\"\" x.__sub__(y) <==> x-y \"\"\"\r\n  pass\r\n A=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets or sets the real part of the quaternion.\r\n\r\n\r\n\r\nGet: A(self: Quaternion) -> float\r\n\r\n\r\n\r\nSet: A(self: Quaternion)=value\r\n\r\n\"\"\"\r\n\r\n B=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets or sets the first imaginary coefficient of the quaternion.\r\n\r\n\r\n\r\nGet: B(self: Quaternion) -> float\r\n\r\n\r\n\r\nSet: B(self: Quaternion)=value\r\n\r\n\"\"\"\r\n\r\n C=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets or sets the second imaginary coefficient of the quaternion.\r\n\r\n\r\n\r\nGet: C(self: Quaternion) -> float\r\n\r\n\r\n\r\nSet: C(self: Quaternion)=value\r\n\r\n\"\"\"\r\n\r\n Conjugate=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets a new quaternion that is the conjugate of this quaternion.\r\n\r\n   This is (a,-b,-c,-d)\r\n\r\n\r\n\r\nGet: Conjugate(self: Quaternion) -> Quaternion\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n D=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets or sets the third imaginary coefficient of the quaternion.\r\n\r\n\r\n\r\nGet: D(self: Quaternion) -> float\r\n\r\n\r\n\r\nSet: D(self: Quaternion)=value\r\n\r\n\"\"\"\r\n\r\n Inverse=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Computes a new inverted quaternion,\r\n\r\n   (a/L2,-b/L2,-c/L2,-d/L2),where L2=length squared=(a*a + b*b + c*c + d*d).\r\n\r\n   This is the multiplicative inverse,i.e.,\r\n\r\n   (a,b,c,d)*(a/L2,-b/L2,-c/L2,-d/L2)=(1,0,0,0).\r\n\r\n   If this is the zero quaternion,then the zero quaternion is returned.\r\n\r\n\r\n\r\nGet: Inverse(self: Quaternion) -> Quaternion\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n IsScalar=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"true if b,c,and d are all zero.\r\n\r\n\r\n\r\nGet: IsScalar(self: Quaternion) -> bool\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n IsValid=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Determines if the four coefficients are valid numbers within RhinoCommon.\r\n\r\n   See Rhino.RhinoMath.IsValidDouble(System.Double).\r\n\r\n\r\n\r\nGet: IsValid(self: Quaternion) -> bool\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n IsVector=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"true if a=0 and at least one of b,c,or d is not zero.\r\n\r\n\r\n\r\nGet: IsVector(self: Quaternion) -> bool\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n IsZero=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"true if a,b,c,and d are all zero.\r\n\r\n\r\n\r\nGet: IsZero(self: Quaternion) -> bool\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n Length=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Returns the length or norm of the quaternion.\r\n\r\n\r\n\r\nGet: Length(self: Quaternion) -> float\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n LengthSquared=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets the result of (a^2 + b^2 + c^2 + d^2).\r\n\r\n\r\n\r\nGet: LengthSquared(self: Quaternion) -> float\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n Scalar=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"The real (scalar) part of the quaternion\r\n\r\n   This is Rhino.Geometry.Quaternion.A.\r\n\r\n\r\n\r\nGet: Scalar(self: Quaternion) -> float\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n Vector=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"The imaginary part of the quaternion\r\n\r\n   (B,C,D)\r\n\r\n\r\n\r\nGet: Vector(self: Quaternion) -> Vector3d\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n\r\n I=None\r\n Identity=None\r\n J=None\r\n K=None\r\n Zero=None\r\n\r\n",
  "language": "python",
  "imports": [
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": false
}