{
  "source_url": "https://github.com/ahmedelmaraghy/BrickMaze-Project/blob/8a437fc40f4de420a0e35d2d72eb6112d1fe7395/20221111_Brick_Maze_full_pack/utils.py",
  "repo": "ahmedelmaraghy/BrickMaze-Project",
  "repo_stars": 0,
  "repo_description": null,
  "license": "MIT",
  "filepath": "20221111_Brick_Maze_full_pack/utils.py",
  "instruction": "This module contains utility functions:\r\n    1) Transformation functions\r\n    2) Useful geometry functions e.g. Intersections",
  "code": "\"\"\"\r\nThis module contains utility functions:\r\n    1) Transformation functions\r\n    2) Useful geometry functions e.g. Intersections\r\n\"\"\"\r\n\r\nimport Rhino.Geometry as rg\r\nimport math\r\n\r\n# ----- Coordinate System conversions -----\r\n\r\ndef rhino_to_robotbase(ref_plane, model_base):\r\n    \"\"\"\r\n    Function that transforms a reference plane from Rhino coordinate system to the robot's base coordinate system\r\n    TODO (Jason): maybe change this whole method? maybe not model but robot base\r\n    \r\n    Args:\r\n        ref_plane: Rhino.Geometry plane object. The reference plane to transform\r\n        model_base: Rhino.Geometry plane object. The base plane for building on. Given in robot's base coordinate system.\r\n    \r\n    Returns:\r\n        ref_plane: Reference plane transformed to robot space\r\n    \"\"\"\r\n    \r\n    # Transform the orientation plane based on model_base coordinate system\r\n    _matrix = rg.Transform.PlaneToPlane(rg.Plane.WorldXY,model_base)\r\n    #_matrix = rg.Transform.PlaneToPlane(model_base,rg.Plane.WorldXY,)\r\n    ref_plane.Transform(_matrix)\r\n    return ref_plane\r\n\r\ndef matrix_to_axis_angle(m):\r\n    \"\"\"\r\n    Function that transforms a 4x4 matrix to axis-angle format\r\n    referenced from Martin Baker's www.euclideanspace.com\r\n    \r\n    Args:\r\n        m: Rhino.Geometry Transform structure  - 4x4 matrix\r\n    \r\n    Returns:\r\n        axis: Rhino.Geometry Vector3d object - axis-angle notation\r\n    \"\"\"\r\n    \r\n    epsilon = 0.01\r\n    epsilon2 = 0.01\r\n    \r\n    if (math.fabs(m.M01 - m.M10) < epsilon) & (math.fabs(m.M02 - m.M20) < epsilon) & (math.fabs(m.M12 - m.M21) < epsilon):\r\n    #singularity found\r\n    #first check for identity matrix which must have +1 for all terms\r\n    #in leading diagonal and zero in other terms\r\n        if (math.fabs(m.M01 + m.M10) < epsilon2) & (math.fabs(m.M02 + m.M20) < epsilon2) & (math.fabs(m.M12 + m.M21) < epsilon2) & (math.fabs(m.M00 + m.M11 + m.M22 - 3) < epsilon2):\r\n            #this singularity is identity matrix so angle = 0   make zero angle, arbitrary axis\r\n            angle = 0\r\n            x = 1\r\n            y = z = 0\r\n        else:\r\n            # otherwise this singularity is angle = 180\r\n            angle = math.pi;\r\n            xx = (m.M00 + 1) / 2\r\n            yy = (m.M11 + 1) / 2\r\n            zz = (m.M22 + 1) / 2\r\n            xy = (m.M01 + m.M10) / 4\r\n            xz = (m.M02 + m.M20) / 4\r\n            yz = (m.M12 + m.M21) / 4\r\n            if ((xx > yy) & (xx > zz)):\r\n                # m.M00 is the largest diagonal term\r\n                if (xx < epsilon):\r\n                    x = 0\r\n                    y = z = 0.7071\r\n                else:\r\n                    x = math.sqrt(xx)\r\n                    y = xy / x\r\n                    z = xz / x\r\n            elif (yy > zz): \r\n                # m.M11 is the largest diagonal term\r\n                if (yy < epsilon):\r\n                    x = z = 0.7071\r\n                    y = 0\r\n                else: \r\n                    y = math.sqrt(yy)\r\n                    x = xy / y\r\n                    z = yz / y\r\n            else: \r\n                # m.M22 is the largest diagonal term so base result on this\r\n                if (zz < epsilon):\r\n                    x = y = 0.7071\r\n                    z = 0\r\n                else:\r\n                    z = math.sqrt(zz)\r\n                    x = xz / z\r\n                    y = yz / z\r\n    else:\r\n        s = math.sqrt((m.M21 - m.M12) * (m.M21 - m.M12)+ (m.M02 - m.M20) * (m.M02 - m.M20)+ (m.M10 - m.M01) * (m.M10 - m.M01)); # used to normalise\r\n        if (math.fabs(s) < 0.001):\r\n            #prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n            s = 1\r\n        angle = math.acos((m.M00 + m.M11 + m.M22 - 1) / 2)\r\n        x = (m.M21 - m.M12) / s\r\n        y = (m.M02 - m.M20) / s\r\n        z = (m.M10 - m.M01) / s\r\n    angleRad = angle\r\n    axis = rg.Vector3d(x,y,z)\r\n    axis = axis*angleRad\r\n    \r\n    return axis\r\n\r\ndef matrix_to_euler(m):\r\n    \"\"\"\r\n    Gets the Euler rotation angles from a transformation matrix\r\n    from http://forums.codeguru.com/archive/index.php/t-329530.html\r\n    \r\n    Args:\r\n        m = Transform object\r\n    Returns:\r\n        tuple of euler angles in radians\r\n    \"\"\"\r\n    \r\n    rotz = math.atan2(m.M10, m.M00)\r\n    roty = -math.asin(m.M20)\r\n    rotx = math.atan2(m.M21, m.M22)\r\n    return (rotx, roty, rotz)\r\n\r\n# ----- Matrix related helper functions\r\n\r\ndef dh_matrix((d, theta, a, alpha)):\r\n    \"\"\"\r\n    This function creates the Denavit Hartenberg transformation matrix between adjacent frames\r\n    \r\n    Arguments:\r\n        d: Joint distance. in mm\r\n        theta: joint angle. in radians\r\n        a: link length. in mm\r\n        alpha: twist angle. in radians\r\n    \r\n    Returns:\r\n        m: Denavit Hartenberg transformation matrix\r\n    \"\"\"\r\n    \r\n    _matrix = [\r\n    (math.cos(theta), -math.sin(theta) * math.cos(alpha),math.sin(theta) * math.sin(alpha),a * math.cos(theta)),\r\n    (math.sin(theta), math.cos(theta) * math.cos(alpha), -math.cos(theta) * math.sin(alpha), a * math.sin(theta)),\r\n    (0, math.sin(alpha),math.cos(alpha),d),\r\n    (0,0,0,1)\r\n    ]\r\n    \r\n    m = rg.Transform()\r\n    for i in range(4):\r\n        for j in range(4):\r\n            m[i,j] = _matrix[i][j]\r\n            \r\n    return m\r\n\r\ndef concatenate_matrices(matrices):\r\n    \"\"\"\r\n    This function creates a concatenated matrix from a list of matrices\r\n    \r\n    Arguments:\r\n        matrices: A list of tranformation matrices\r\n    \r\n    Returns:\r\n        _transform: Concatenated matrix\r\n    \"\"\"\r\n    _transform = matrices[0]\r\n    for i in range(1,len(matrices)):\r\n        _transform *= matrices[i]\r\n    return _transform\r\n\r\n\r\n# ----- Miscellaneous geometry helper functions\r\ndef signed_angle(v1,v2,v_normal):\r\n    \"\"\"\r\n    This function gets the angle between 2 vectors -pi < theta< pi\r\n    \r\n    Arguments:\r\n        v1: Vector3d. First unitized vector\r\n        v2: Vector3d. Second unitized vector\r\n        v_normal: Vector3d. Normal to 2 vectors that determines what is positive/negative\r\n    \r\n    Returns:\r\n        theta: float. signed angle between -pi and pi\r\n    \"\"\"\r\n    # from 0 to pi\r\n    c = rg.Vector3d.Multiply(v1,v2)\r\n    n = rg.Vector3d.CrossProduct(v1,v2)\r\n    s= n.Length\r\n    \r\n    theta  = math.atan2(s,c)\r\n    \r\n    if (rg.Vector3d.Multiply(n, v_normal) < 0):\r\n        theta *= -1\r\n    return theta\r\n\r\ndef cir_cir_intersection(cir1,cir2):\r\n    \"\"\"\r\n    Funtion that returns the intersection points between two circles\r\n    \r\n    Arguments:\r\n        1) cir1: First circle\r\n        2) cir2: Second Circle\r\n    \r\n    Returns:\r\n        xpts: list of 2 Point3d objectts\r\n        \r\n    Note that there is no error checking\r\n    \"\"\"\r\n    r1 = cir1.Radius\r\n    r2 = cir2.Radius\r\n    d = cir1.Center.DistanceTo(cir2.Center)\r\n    \r\n    a = (r1 **2 - r2**2 + d**2)/(2*d)\r\n    h = math.sqrt(r1 **2 - a **2 )\r\n    \r\n    v_c1 = rg.Vector3d(cir1.Center)\r\n    v_c2 = rg.Vector3d(cir2.Center)\r\n    \r\n    v_c1c2 = v_c2 - v_c1\r\n    v_c1c2.Unitize()\r\n    v_c1c2 *= a\r\n    \r\n    v_pt0 = v_c1 + v_c1c2\r\n    \r\n    v_pt0ptX = rg.Vector3d.CrossProduct(cir1.Normal,v_c1c2)\r\n    v_pt0ptX.Unitize()\r\n    v_pt0ptX *= h\r\n    \r\n    xpt1 = rg.Point3d(v_pt0 + v_pt0ptX)\r\n    v_pt0ptX.Reverse()\r\n    xpt2 = rg.Point3d(v_pt0 + v_pt0ptX)\r\n\r\n    return [xpt1,xpt2]\r\n    \r\ndef check_arguments(function):\r\n    def decorated(*args):\r\n        if None in args:\r\n            raise TypeError(\"Invalid Argument\")\r\n        return function(*args)\r\n    return decorated\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}