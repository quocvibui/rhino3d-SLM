{
  "source_url": "https://github.com/hiroyeah/fabrix/blob/1c0226b63d203b81ef47f6199060c2b4119d949d/Rhino_Python_AAM/AAM_cmd.py",
  "repo": "hiroyeah/fabrix",
  "repo_stars": 9,
  "repo_description": "fabrix scripts for direct g-code editing",
  "license": "MIT",
  "filepath": "Rhino_Python_AAM/AAM_cmd.py",
  "instruction": "Aam cmd",
  "code": "import rhinoscriptsyntax as rs\r\nimport Rhino as rhino\r\nfrom System.Drawing import Color\r\nimport math\r\n#import gcodeGenerater\r\n\r\n__commandname__ = \"AAM_Planar\"\r\n\r\n\"\"\"\r\nTo do\r\n\r\n#important\r\n\r\n#important\r\nadapt to curved surface\r\n\r\n#important\r\nmiddle surface\r\n\r\nmove to first point safely\r\n\r\n\r\n\r\n\r\nwarning for angle of baseSurface\r\n\r\nPrinting Speed!!!!\r\n\r\nget variables of print setting\r\n3d printing setting file by xml\r\n\r\n\"\"\"\r\n\r\nclass AAM_Planar():\r\n\r\n    #def __init__(self, _gcoder, _printSetter):\r\n    def __init__(self, _gcoder):\r\n\r\n        self.gcoder = _gcoder\r\n        #self.printSetter = _printSetter\r\n\r\n\r\n        self.normalVec = None\r\n        self.addtiveObj = None\r\n        self.baseSurface = None\r\n        self.layerHeight = None\r\n\r\n        #sliceSurface is used for slicing addtiveObj\r\n        self.sliceSurface = None\r\n        self.fixedLayerHeight = None\r\n\r\n        self.prePoint = None\r\n        self.angleOfBaseSurface = None\r\n\r\n        self.basePointForPlane = None\r\n\r\n\r\n        self.paralellIntersectedCurves = []\r\n        self.indexParalellSurfaces = []\r\n\r\n        self.EValue = 0\r\n\r\n\r\n        self.infillRatio = 0.05\r\n\r\n        return\r\n\r\n    def main(self):\r\n        print(\"####### AAM Starts #######\")\r\n        #this code is for only planar surface\r\n        if not self.setNormalVec():\r\n            return\r\n        if not self.setAdditiveObj():\r\n            return\r\n\r\n        self.setSurfaceForSlicing()\r\n\r\n\r\n        #setter\r\n        self.setPrintingSetting()\r\n\r\n\r\n        self.detectParalellSurface()\r\n\r\n        #set layer for sliced lines\r\n        '''\r\n        if rs.IsLayer(\"gcode_line\"):\r\n            pass\r\n        else:\r\n            rs.AddLayer(\"gcode_line\", Color.Red, True, False, None)\r\n        '''\r\n\r\n        #self.setLayerFill()\r\n        self.slice()\r\n        print('slicing done')\r\n\r\n        self.clean()\r\n\r\n\r\n\r\n    def setAngleOfBaseSurface(self):\r\n\r\n        tmpVector = (0,0,1)\r\n        self.angleOfSurface = rs.VectorAngle(tmpVector,self.normalVec)\r\n\r\n        #for debug\r\n        if self.angleOfSurface < 0 or self.angleOfSurface > 90:\r\n            print('self.angleOfSurface is wseird')\r\n\r\n\r\n\r\n    def setNormalVec(self):\r\n        #set normal vector from selected base surface\r\n        #if selected base surface isn't planar, return False\r\n\r\n        self.baseSurface = rs.GetSurfaceObject(\"Select surface to be addded object\")\r\n        if self.baseSurface == None:\r\n            return False\r\n\r\n        rs.SelectObject(self.baseSurface[0])\r\n\r\n        if not rs.IsSurfacePlanar(self.baseSurface[0]):\r\n            print(\"Selected Surface is not planar\\nPlease select planar surface\")\r\n            return False\r\n\r\n        print(\"Confirm direction to add object\")\r\n        rs.Command(\"Dir\")\r\n\r\n        self.normalVec = rs.SurfaceNormal(self.baseSurface[0], [0,0])\r\n\r\n        rs.UnselectAllObjects()\r\n\r\n        self.setAngleOfBaseSurface()\r\n\r\n        return True\r\n\r\n\r\n    def setAdditiveObj(self):\r\n        #set object to be additived\r\n        #if selected obj isnt closed, return False\r\n\r\n        tmp = rs.GetObject(\"Select object which you want additive\")\r\n\r\n        #adapt to unclosed polysurface\r\n        if rs.IsMesh(tmp):\r\n            self.addtiveObj = rs.MeshToNurb(tmp)\r\n\r\n        elif rs.IsPolysurface(tmp):\r\n            self.addtiveObj = tmp\r\n\r\n        else:\r\n            print(\"please select \\\"mesh\\\" or \\\"polysurface\\\"\")\r\n\r\n        return True\r\n\r\n\r\n\r\n    #calculate distance from bottom to top\r\n    def calcDistance(self, plane, editPoints):\r\n        forDistance = []\r\n\r\n        for i in range(len(editPoints)):\r\n            if i == 0:\r\n                forDistance.append(editPoints[0])\r\n                forDistance.append(rs.DistanceToPlane(plane, editPoints[0]))\r\n            else:\r\n                tmpDistance = rs.DistanceToPlane(plane, editPoints[i])\r\n                if tmpDistance > forDistance[1]:\r\n                    forDistance[0] = editPoints[i]\r\n                    forDistance[1] = tmpDistance\r\n\r\n        self.distancePrinting = rs.DistanceToPlane(plane, forDistance[0])\r\n\r\n        #adapt to Z Axis\r\n        self.distancePrinting *= (1.0 / math.cos(math.radians(self.angleOfSurface)))\r\n\r\n        if self.distancePrinting < 0:\r\n            self.distancePrinting *= -1\r\n\r\n        return\r\n\r\n    def setSurfaceForSlicing(self):\r\n\r\n\r\n        explodedSurfaces = rs.ExplodePolysurfaces(self.addtiveObj)\r\n        editPoint = []\r\n\r\n        #get editPoint from polysurfaces\r\n        if len(explodedSurfaces) == 0:\r\n            #use obj\r\n            meshed = rhino.Geometry.Mesh.CreateFromBrep(rs.coercebrep(self.addtiveObj))\r\n            editPoint = rs.MeshVertices(meshed[0])\r\n\r\n        else:\r\n            for i in explodedSurfaces:\r\n                meshed = rhino.Geometry.Mesh.CreateFromBrep(rs.coercebrep(i))\r\n                vertices = rs.MeshVertices(meshed[0])\r\n                editPoint.extend(vertices)\r\n\r\n        rs.DeleteObjects(explodedSurfaces)\r\n\r\n\r\n\r\n        minValue = []\r\n        maxValue = []\r\n        basePointForPlane = None\r\n        basePointForDistance = None\r\n\r\n        for i in range(len(editPoint)):\r\n            if i == 0:\r\n                basePointForPlane = editPoint[0]\r\n                basePointForDistance = editPoint[0]\r\n\r\n                for j in range(3):\r\n                    minValue.append(editPoint[0][j])\r\n                    maxValue.append(editPoint[0][j])\r\n                continue\r\n\r\n            else:\r\n                if basePointForPlane[2] > editPoint[i][2]:\r\n                    basePointForPlane = editPoint[i]\r\n                if basePointForDistance[2] < editPoint[i][2]:\r\n                    basePointForDistance = editPoint[i]\r\n\r\n                for j in range(3):\r\n                    if minValue[j] > editPoint[i][j]:\r\n                        minValue[j] = editPoint[i][j]\r\n                    elif maxValue[j] < editPoint[i][j]:\r\n                        maxValue[j] = editPoint[i][j]\r\n\r\n        #why?\r\n        self.basePointForPlane = basePointForPlane\r\n\r\n        plane = rs.PlaneFromNormal(basePointForPlane, self.normalVec)\r\n\r\n\r\n        #calculating distance printing\r\n        self.calcDistance(plane, editPoint)\r\n\r\n        #make base surface\r\n        pntForSur = []\r\n        line = (minValue[0], minValue[1], minValue[2]), (minValue[0], minValue[1], maxValue[2])\r\n        pntForSur.append(rs.LinePlaneIntersection(line, plane))\r\n        line = (minValue[0], maxValue[1], minValue[2]), (minValue[0], maxValue[1], maxValue[2])\r\n        pntForSur.append(rs.LinePlaneIntersection(line, plane))\r\n        line = (maxValue[0], maxValue[1], minValue[2]), (maxValue[0], maxValue[1], maxValue[2])\r\n        pntForSur.append(rs.LinePlaneIntersection(line, plane))\r\n        line = (maxValue[0], minValue[1], minValue[2]), (maxValue[0], minValue[1], maxValue[2])\r\n        pntForSur.append(rs.LinePlaneIntersection(line, plane))\r\n\r\n        lineForSur = []\r\n\r\n        for i in range(4):\r\n            lineForSur.append(rs.AddLine(pntForSur[i], pntForSur[(i+1)%4]))\r\n\r\n\r\n\r\n        joinedCurve = rs.JoinCurves(lineForSur)\r\n        rs.DeleteObjects(lineForSur)\r\n\r\n        curveForSur = rs.OffsetCurve(joinedCurve, rs.CurveNormal(joinedCurve), 30)\r\n\r\n\r\n\r\n        self.sliceSurface = rs.AddPlanarSrf(curveForSur)\r\n\r\n        if len(curveForSur) > 1 or rs.IsPointOnSurface(self.sliceSurface, rs.CurveStartPoint(joinedCurve)) is False:\r\n\r\n            rs.DeleteObjects(curveForSur)\r\n            if self.sliceSurface is not None:\r\n                rs.DeleteObject(self.sliceSurface)\r\n\r\n            curveForSur = rs.OffsetCurve(joinedCurve, rs.CurveNormal(joinedCurve), -30)\r\n            self.sliceSurface = rs.AddPlanarSrf(curveForSur)\r\n        rs.DeleteObjects(joinedCurve)\r\n        rs.DeleteObjects(curveForSur)\r\n\r\n\r\n\r\n\r\n        self.fixedLayerHeight = float(self.gcoder.getLayerHeight() * (1.0 / math.cos(math.radians(self.angleOfSurface))))\r\n\r\n        self.addtiveObj = rs.CopyObject(self.addtiveObj, (0, 0, self.fixedLayerHeight*0.9))\r\n        self.sliceSurface = rs.MoveObject(self.sliceSurface, (0, 0, self.fixedLayerHeight*0.9))\r\n\r\n\r\n\r\n        #Delete lines used for making sliceSurface\r\n\r\n\r\n\r\n    def detectParalellSurface(self):\r\n        #fix layer height\r\n\r\n\r\n        #self.paralellIntersectedCurve\r\n        #self.indexParalellSurfaces\r\n\r\n        explodedSurfaces = rs.ExplodePolysurfaces(self.addtiveObj)\r\n\r\n        for surface in explodedSurfaces:\r\n            #normals.append(rs.SurfaceNormal(surface))\r\n            tmpNormal = rs.SurfaceNormal(surface, [0,0])\r\n\r\n            gotAngle = rs.VectorAngle(tmpNormal, self.normalVec)\r\n            if gotAngle == 0 or gotAngle == 180:\r\n\r\n                tmpPoints = rs.SurfaceEditPoints(surface)\r\n                tmpPlane = rs.PlaneFromNormal(tmpPoints[0], self.normalVec)\r\n\r\n                distance = rs.DistanceToPlane(tmpPlane, self.basePointForPlane)\r\n\r\n\r\n                distance *= (1.0 / math.cos(math.radians(self.angleOfSurface)))\r\n                print(\"distance\")\r\n                print(distance)\r\n\r\n                paralellLayer = int(distance / self.fixedLayerHeight)\r\n                if paralellLayer < 0:\r\n                    paralellLayer *= -1\r\n\r\n                if paralellLayer == int(self.distancePrinting/self.fixedLayerHeight) or int(distance) == 0:\r\n                    continue\r\n\r\n                self.indexParalellSurfaces.append(int(paralellLayer))\r\n                print(\"paralellLayer\")\r\n                print(paralellLayer)\r\n                print(\"layer num\")\r\n                print(self.distancePrinting/self.fixedLayerHeight)\r\n                #there is object to delete\r\n                self.paralellIntersectedCurves.append(rs.JoinCurves(rs.DuplicateEdgeCurves(surface)))\r\n\r\n        rs.DeleteObjects(explodedSurfaces)\r\n\r\n        \"\"\"\r\n        #debug\r\n        rs.UnselectAllObjects()\r\n        for i in self.paralellIntersectedCurves:\r\n            rs.SelectObject(i)\r\n\r\n        rs.Command(\"Move\")\r\n        \"\"\"\r\n\r\n\r\n    '''\r\n    filter 1 => cut outside of cutter\r\n    filter 2 => cut inside of cutter\r\n    '''\r\n    def trim(self, curve, cutter, filter = 1):\r\n        resultLines = []\r\n\r\n        intersectedPoints = rs.CurveCurveIntersection(curve, cutter)\r\n        if intersectedPoints == None:\r\n            return None\r\n        tmpSurface = rs.AddPlanarSrf(cutter)\r\n\r\n        intersectedPoints = [n[1] for n in intersectedPoints]\r\n\r\n        intersectedPoints.insert(0, rs.CurveStartPoint(curve))\r\n        intersectedPoints.insert(len(intersectedPoints), rs.CurveEndPoint(curve))\r\n\r\n        for i in range(len(intersectedPoints)-1):\r\n\r\n            x = intersectedPoints[i][0] + intersectedPoints[i+1][0]\r\n            y = intersectedPoints[i][1] + intersectedPoints[i+1][1]\r\n            z = intersectedPoints[i][2] + intersectedPoints[i+1][2]\r\n\r\n            mid = (x/2.0, y/2.0, z/2.0)\r\n\r\n            if tmpSurface is None:\r\n                continue\r\n            if rs.IsPointOnSurface(tmpSurface, mid):\r\n                if filter == 1:\r\n                    resultLines.append(rs.AddLine(intersectedPoints[i], intersectedPoints[i+1]))\r\n                elif filter == 2:\r\n                    continue\r\n\r\n            else:\r\n                if filter == 1:\r\n                    continue\r\n                elif filter == 2:\r\n                    resultLines.append(rs.AddLine(intersectedPoints[i], intersectedPoints[i+1]))\r\n\r\n\r\n        rs.DeleteObject(curve)\r\n        if tmpSurface is not None:\r\n            rs.DeleteObject(tmpSurface)\r\n\r\n        return resultLines\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    def slice(self):\r\n\r\n        print(\"Slicing starts\")\r\n        print(\"It may take a long time\")\r\n        deleteItem = []\r\n\r\n        fileN = rs.SaveFileName(\"Output file\", \"G-Code Files (*.gcode)|*.gcode|All Files (*.*)|*.*|\")\r\n\r\n        self.gcoder.initGcode(fileN)\r\n\r\n        tmpText = \"\"\r\n\r\n        #layer by layer\r\n        layer = 0\r\n\r\n        for layer in range(int(self.distancePrinting/self.fixedLayerHeight)+1):\r\n\r\n\r\n            tmpText = \"; layer \" + str(layer) + \"\\n\"\r\n            #init evalue\r\n            tmpText += \"G92 E0\\n\"\r\n            self.gcoder.addGcode(tmpText)\r\n            self.gcoder.initEValue()\r\n\r\n            nextVec = (0, 0, float(self.fixedLayerHeight*layer))\r\n            slicer = rs.CopyObject(self.sliceSurface, nextVec)\r\n\r\n            slicedCurves = rs.IntersectBreps(self.addtiveObj, slicer)\r\n            #deleteItem.append(slicedCurves)\r\n\r\n            rs.DeleteObject(slicer)\r\n            if slicedCurves == None:\r\n                continue\r\n\r\n            '''\r\n            if slicedCurves == None:\r\n                print('slicing done')\r\n                self.gcoder.finishGcode()\r\n                fileN = rs.SaveFileName(\"Output file\", \"G-Code Files (*.gcode)|*.gcode|All Files (*.*)|*.*|\", None, None)\r\n                self.gcoder.outputFile(fileN)\r\n\r\n                return\r\n            '''\r\n\r\n\r\n            #slicedCurve one by one\r\n            for slicedCurve in slicedCurves:\r\n\r\n                if rs.IsCurve(slicedCurve) is False:\r\n                    continue\r\n                if slicedCurve is None:\r\n                    break\r\n\r\n                self.makeGcodeFromSlicedCurve(slicedCurve, layer)\r\n\r\n\r\n            rs.DeleteObjects(slicedCurves)\r\n\r\n\r\n        print('slicing done')\r\n        self.gcoder.finishGcode()\r\n        #fileN = rs.SaveFileName(\"Output file\", \"G-Code Files (*.gcode)|*.gcode|All Files (*.*)|*.*|\")\r\n        self.gcoder.outputFile()\r\n\r\n        return True\r\n\r\n\r\n\r\n\r\n\r\n    def makeGcodeFromSlicedCurve(self, slicedCurve, layer):\r\n        deleteItem = []\r\n\r\n        tmpText = \"\"\r\n\r\n        #it may shit\r\n        if rs.IsCurveClosed(slicedCurve) is False:\r\n\r\n            #slicedCurve = rs.CloseCurve(slicedCurve)\r\n            startPoint = rs.CurveStartPoint(slicedCurve)\r\n            endPoint = rs.CurveEndPoint(slicedCurve)\r\n\r\n            curveForFix = rs.AddCurve([startPoint, endPoint])\r\n\r\n            curves = []\r\n            curves.append(slicedCurve)\r\n            curves.append(curveForFix)\r\n            slicedCurve = rs.JoinCurves(curves)\r\n\r\n\r\n        #dirVec = rs.CurveNormal(slicedCurve)\r\n        dirVec = self.normalVec\r\n\r\n\r\n        #shell by shell\r\n        #shell inside to outside\r\n        for shell in range(self.gcoder.getNumShellOutline()):\r\n\r\n            nozzleDia = self.gcoder.getExtruderDiameter()\r\n\r\n            '''\r\n            if shell == 0:\r\n                offsetCurve = rs.OffsetCurve(slicedCurve, tuple(dirVec), nozzleDia/2.0)\r\n            else:\r\n                #offsetCurve = rs.OffsetCurve(slicedCurve, tuple(dirVec), self.gcoder.getLayerHeight() * shell)\r\n                offsetCurve = rs.OffsetCurve(slicedCurve, tuple(dirVec), nozzleDia/2.0 + nozzleDia*shell)\r\n            '''\r\n\r\n            if shell == self.gcoder.getNumShellOutline()-1:\r\n                ##offsetCurve = rs.OffsetCurve(slicedCurve, dirVec, -nozzleDia/2.0)\r\n                offsetCurve = rs.OffsetCurve(slicedCurve, dirVec, nozzleDia/2.0)\r\n\r\n            else:\r\n                try:\r\n                    ##offsetCurve = rs.OffsetCurve(slicedCurve, dirVec, -(nozzleDia/2.0 + nozzleDia*(self.gcoder.getNumShellOutline()-shell-1)))\r\n                    offsetCurve = rs.OffsetCurve(slicedCurve, dirVec, (nozzleDia/2.0 + nozzleDia*(self.gcoder.getNumShellOutline()-shell-1)))\r\n                except:\r\n                    print('offset failed\\nslicedCurve')\r\n                    print(slicedCurve)\r\n                    print('dirVec')\r\n                    print(dirVec)\r\n\r\n            #skip, when offset fail\r\n            if offsetCurve == None:\r\n                #print('failed to offset curve')\r\n                continue\r\n\r\n            if isinstance(offsetCurve, list) and len(offsetCurve) > 1:\r\n                rs.DeleteObjects(offsetCurve)\r\n                continue\r\n\r\n\r\n            #explodedCurve = rs.ExplodeCurves(offsetCurve)\r\n\r\n\r\n            #lines from explodedCurve\r\n            #from outline to gcode\r\n\r\n            #explodCurve is not enough\r\n            #you need to convert curve to polyline\r\n            #and then get point from editPoint\r\n\r\n            prePoint = None\r\n            currentPoint = None\r\n            convertedPolyline = rs.ConvertCurveToPolyline(offsetCurve)\r\n            vertices = rs.CurveEditPoints(convertedPolyline)\r\n            rs.DeleteObject(convertedPolyline)\r\n\r\n            flag = True\r\n\r\n            for ver in vertices:\r\n\r\n                currentPoint = ver\r\n                if flag:\r\n                    tmpText = \"G1 X{0} Y{1} Z{2} F{3}\\n\".format(currentPoint[0], currentPoint[1], currentPoint[2], 3600)\r\n                    flag = False\r\n                else:\r\n                    self.gcoder.calcEValue(rs.Distance(currentPoint, prePoint))\r\n                    tmpText = \"G1 X{0} Y{1} Z{2} E{3} F{4}\\n\".format(currentPoint[0], currentPoint[1], currentPoint[2], self.gcoder.getEValue(), 1800)\r\n\r\n                prePoint = currentPoint\r\n\r\n                self.gcoder.addGcode(tmpText)\r\n\r\n\r\n            #rs.DeleteObjects(explodedCurve)\r\n\r\n            #from outline to fill gocde\r\n            #if shell is last one, it needs to fill layer or infill\r\n\r\n            #inside to outside\r\n            if shell == (self.gcoder.getNumShellOutline()-1):\r\n                rs.DeleteObject(offsetCurve)\r\n                ##offsetCurveForFill = rs.OffsetCurve(slicedCurve, dirVec, -(nozzleDia/2.0 + nozzleDia*(self.gcoder.getNumShellOutline())))\r\n                offsetCurveForFill = rs.OffsetCurve(slicedCurve, dirVec, (nozzleDia/2.0 + nozzleDia*(self.gcoder.getNumShellOutline())))\r\n\r\n                #newOffsetCurve = rs.OffsetCurve(offsetCurve, tuple(dirVec), self.gcoder.getLayerHeight())\r\n                if offsetCurveForFill == None:\r\n                    #print('failed to offset curve')\r\n                    break\r\n\r\n                if isinstance(offsetCurveForFill, list) and len(offsetCurveForFill) > 1:\r\n                    rs.DeleteObjects(offsetCurveForFill)\r\n                    break\r\n\r\n                '''\r\n                offsetCurveForFill = rs.OffsetCurve(offsetCurve, tuple(dirVec), nozzleDia)\r\n\r\n                #detect failed to offset\r\n                if isinstance(offsetCurveForFill, list) and len(offsetCurveForFill) > 1:\r\n                    continue\r\n                '''\r\n\r\n                #fill for middle paralell layer\r\n\r\n                for paralellLayer in range(len(self.paralellIntersectedCurves)):\r\n                    if layer >= self.indexParalellSurfaces[paralellLayer] and abs(layer-self.indexParalellSurfaces[paralellLayer]) < self.gcoder.getNumTopLayer():\r\n                        '''\r\n                        dirVecForParalell = rs.CurveAreaCentroid(self.paralellIntersectedCurves[paralellLayer])\r\n                        dirVecForParalell = dirVecForParalell[0]\r\n                        '''\r\n                        dirVecForParalell = rs.CurveNormal(self.paralellIntersectedCurves[paralellLayer])\r\n\r\n\r\n                        offsetParalell = rs.OffsetCurve(self.paralellIntersectedCurves[paralellLayer], dirVecForParalell, -(nozzleDia/2.0 + nozzleDia*(self.gcoder.getNumShellOutline())))\r\n                        #debug\r\n\r\n                        '''\r\n                        #print('layer')\r\n                        #print(layer)\r\n                        rs.UnselectAllObjects()\r\n                        rs.SelectObject(offsetParalell)\r\n                        rs.Command('Move')\r\n                        '''\r\n\r\n\r\n                        #it needs to debug, it's close\r\n                        self.setLayerFill(offsetParalell, layer)\r\n                        continue\r\n\r\n                        #self.setInfill(vec, newOffsetCurve, offsetParalell)\r\n\r\n\r\n\r\n\r\n                if layer < (self.gcoder.getNumBottomLayer()):\r\n                    self.setLayerFill(offsetCurveForFill, layer)\r\n                    rs.DeleteObject(offsetCurveForFill)\r\n\r\n                elif layer > (int(self.distancePrinting/self.fixedLayerHeight) - self.gcoder.getNumTopLayer()):\r\n\r\n                    self.setLayerFill(offsetCurveForFill, layer)\r\n                    rs.DeleteObject(offsetCurveForFill)\r\n\r\n                else:\r\n                    self.setInfill(offsetCurveForFill, layer)\r\n                    if offsetCurveForFill is not None:\r\n                        rs.DeleteObject(offsetCurveForFill)\r\n\r\n\r\n\r\n                #rs.DeleteObjects(newOffsetCurve)\r\n\r\n            #DEBUG\r\n            rs.DeleteObjects(offsetCurve)\r\n        rs.DeleteObject(slicedCurve)\r\n\r\n\r\n    def setLayerFill(self, intersectCurve, index):\r\n\r\n        #set baseline, baseVec, dist\r\n\r\n        newSliceSurface = rs.CopyObject(self.sliceSurface, (0, 0, float(self.fixedLayerHeight*index)))\r\n        editPoints = rs.SurfaceEditPoints(newSliceSurface)\r\n\r\n        #vertical\r\n        if index%2 == 0:\r\n\r\n            baseLine = rs.AddLine(editPoints[0], editPoints[1])\r\n            baseVec = (editPoints[2][0]-editPoints[0][0], editPoints[2][1]-editPoints[0][1], editPoints[2][2]-editPoints[0][2])\r\n            dist = rs.Distance(editPoints[0], editPoints[2])\r\n\r\n        #horizontal\r\n        elif index%2 == 1:\r\n\r\n            baseLine = rs.AddLine(editPoints[0], editPoints[2])\r\n            baseVec = (editPoints[1][0]-editPoints[0][0], editPoints[1][1]-editPoints[0][1], editPoints[1][2]-editPoints[0][2])\r\n            dist = rs.Distance(editPoints[0], editPoints[1])\r\n\r\n\r\n        #normalize baseVec\r\n        forNormal = math.sqrt(baseVec[0]**2 + baseVec[1]**2 + baseVec[2]**2)\r\n        baseVec = [i/forNormal for i in baseVec]\r\n\r\n        #end set baseLine, baseVec, dist\r\n\r\n        self.gcoder.addGcode(\"; layer filling\\n\")\r\n\r\n        flag = False\r\n        for i in range(int(dist/self.gcoder.getExtruderDiameter())+1):\r\n            lines = []\r\n\r\n            nextVec = [v*self.gcoder.getExtruderDiameter()*i for v in baseVec]\r\n\r\n            #vertical\r\n            if index%2 == 0:\r\n                nextStartPoint = (editPoints[0][0]+nextVec[0], editPoints[0][1]+nextVec[1], editPoints[0][2]+nextVec[2])\r\n                nextEndPoint = (editPoints[1][0]+nextVec[0], editPoints[1][1]+nextVec[1], editPoints[1][2]+nextVec[2])\r\n\r\n            if index%2 == 1:\r\n                nextStartPoint = (editPoints[0][0]+nextVec[0], editPoints[0][1]+nextVec[1], editPoints[0][2]+nextVec[2])\r\n                nextEndPoint = (editPoints[2][0]+nextVec[0], editPoints[2][1]+nextVec[1], editPoints[2][2]+nextVec[2])\r\n\r\n            nextLine = rs.AddLine(nextStartPoint, nextEndPoint)\r\n\r\n            lines = self.trim(nextLine, intersectCurve[0], 1)\r\n\r\n            rs.DeleteObject(nextLine)\r\n\r\n\r\n            if lines is None:\r\n                continue\r\n\r\n            if i%2 == 1:\r\n                lines.reverse()\r\n\r\n            for j in lines:\r\n                startPoint = rs.CurveStartPoint(j)\r\n                endPoint = rs.CurveEndPoint(j)\r\n\r\n                if i%2 == 0:\r\n                    if flag:\r\n                        self.gcoder.calcEValue(rs.Distance(prePoint, startPoint))\r\n                        #tmpText = \"G1 X{0} Y{1} Z{2} E{3} F{4}\\n\".format(startPoint[0], startPoint[1], startPoint[2], self.gcoder.getEValue(), 1800)\r\n                        tmpText = \"G1 X{0} Y{1} Z{2} F{3}\\n\".format(startPoint[0], startPoint[1], startPoint[2], 1800)\r\n\r\n                    else:\r\n                        tmpText = \"G1 X{0} Y{1} Z{2} F{3}\\n\".format(startPoint[0], startPoint[1], startPoint[2], 3600)\r\n                        flag = True\r\n\r\n                    self.gcoder.calcEValue(rs.Distance(startPoint, endPoint))\r\n                    tmpText += \"G1 X{0} Y{1} Z{2} E{3} F{4}\\n\".format(endPoint[0], endPoint[1], endPoint[2], self.gcoder.getEValue(), 1800)\r\n\r\n                    prePoint = endPoint\r\n\r\n                elif i%2 == 1:\r\n\r\n                    if flag:\r\n                        self.gcoder.calcEValue(rs.Distance(prePoint, endPoint))\r\n\r\n                        #tmpText = \"G1 X{0} Y{1} Z{2} E{3} F{4}\\n\".format(endPoint[0], endPoint[1], endPoint[2], self.gcoder.getEValue(), 1800)\r\n                        tmpText = \"G1 X{0} Y{1} Z{2} F{3}\\n\".format(endPoint[0], endPoint[1], endPoint[2], 1800)\r\n                    else:\r\n\r\n                        tmpText = \"G1 X{0} Y{1} Z{2} F{3}\\n\".format(endPoint[0], endPoint[1], endPoint[2], 3600)\r\n                        flag = True\r\n\r\n                    self.gcoder.calcEValue(rs.Distance(startPoint, endPoint))\r\n                    tmpText += \"G1 X{0} Y{1} Z{2} E{3} F{4}\\n\".format(startPoint[0], startPoint[1], startPoint[2], self.gcoder.getEValue(), 1800)\r\n                    prePoint = startPoint\r\n\r\n\r\n                self.gcoder.addGcode(tmpText)\r\n\r\n\r\n\r\n            rs.DeleteObjects(lines)\r\n        rs.DeleteObject(baseLine)\r\n        rs.DeleteObject(newSliceSurface)\r\n\r\n    def deleteAlonePoint(self, points, intersectCurve):\r\n        editPoint = rs.CurveEditPoints(intersectCurve)\r\n\r\n        for i in editPoint:\r\n\r\n            for j in range(len(points)):\r\n\r\n                if rs.Distance(i,points[j]) == 0.0:\r\n                    points.pop(j)\r\n\r\n        return points\r\n\r\n\r\n    def setInfill(self, intersectCurve, index, paralellOffset = None):\r\n        if self.gcoder.getInfillRatio() == 0:\r\n            return\r\n\r\n\r\n\r\n        self.gcoder.addGcode(\"; layer infill\\n\")\r\n\r\n\r\n        newSliceSurface = rs.CopyObject(self.sliceSurface, (0, 0, float(self.fixedLayerHeight*index)))\r\n        editPoints = rs.SurfaceEditPoints(newSliceSurface)\r\n\r\n        rs.DeleteObject(newSliceSurface)\r\n\r\n        #horizontal\r\n        baseLine = rs.AddLine(editPoints[0], editPoints[1])\r\n        baseVec = (editPoints[2][0]-editPoints[0][0], editPoints[2][1]-editPoints[0][1], editPoints[2][2]-editPoints[0][2])\r\n        forNormalize = math.sqrt(baseVec[0]**2 + baseVec[1]**2 + baseVec[2]**2)\r\n        baseVec = [i/forNormalize for i in baseVec]\r\n\r\n        dist = rs.Distance(editPoints[0], editPoints[2])\r\n\r\n\r\n        lines = []\r\n\r\n        interval = self.gcoder.getExtruderDiameter() * (1.0 / (self.gcoder.getInfillRatio() / 100.0))\r\n        #It needs to DEBUG\r\n        #interval = self.gcoder.getLayerHeight() * 30\r\n\r\n        #prepare horizontal lines\r\n\r\n        flag = False\r\n\r\n        for i in range(int(dist/interval + 1)):\r\n            nextVec = [j*(interval*i) for j in baseVec]\r\n\r\n            nextStartPoint = (editPoints[0][0]+nextVec[0], editPoints[0][1]+nextVec[1], editPoints[0][2]+nextVec[2])\r\n            nextEndPoint = (editPoints[1][0]+nextVec[0], editPoints[1][1]+nextVec[1], editPoints[1][2]+nextVec[2])\r\n\r\n            nextLine = rs.AddLine(nextStartPoint, nextEndPoint)\r\n\r\n            if nextLine == None or intersectCurve == None:\r\n                rs.DeleteObject(nextLine)\r\n                rs.DeleteObject(baseLine)\r\n\r\n                continue\r\n\r\n\r\n            lines = (self.trim(nextLine, intersectCurve, 1))\r\n            rs.DeleteObject(nextLine)\r\n\r\n            if lines is None:\r\n                continue\r\n\r\n            if i%2 == 1:\r\n                lines.reverse()\r\n\r\n\r\n            for j in lines:\r\n                startPoint = rs.CurveStartPoint(j)\r\n                endPoint = rs.CurveEndPoint(j)\r\n\r\n\r\n                if i%2 == 0:\r\n                    if flag:\r\n                        self.gcoder.calcEValue(rs.Distance(prePoint, startPoint))\r\n\r\n                        #tmpText = \"G1 X{0} Y{1} Z{2} E{3} F{4}\\n\".format(startPoint[0], startPoint[1], startPoint[2], self.gcoder.getEValue(), 1800)\r\n                        tmpText = \"G1 X{0} Y{1} Z{2} F{3}\\n\".format(startPoint[0], startPoint[1], startPoint[2], 1800)\r\n                    else:\r\n                        tmpText = \"G1 X{0} Y{1} Z{2} F{3}\\n\".format(startPoint[0], startPoint[1], startPoint[2], 3600)\r\n                        flag = True\r\n\r\n                    self.gcoder.calcEValue(rs.Distance(startPoint, endPoint))\r\n                    #tmpText += \"G1 X\" + str(endPoint[0]) + \" Y\" + str(endPoint[1]) + \" Z\" + str(endPoint[2]) + \" E\" + str(self.gcoder.getEValue()) + \" F1800\\n\"\r\n                    tmpText += \"G1 X{0} Y{1} Z{2} E{3} F{4}\\n\".format(endPoint[0], endPoint[1], endPoint[2], self.gcoder.getEValue(), 1800)\r\n                    prePoint = endPoint\r\n\r\n\r\n\r\n                elif i%2 == 1:\r\n                    if flag:\r\n                        self.gcoder.calcEValue(rs.Distance(prePoint, endPoint))\r\n\r\n                        #tmpText = \"G1 X{0} Y{1} Z{2} E{3} F{4}\\n\".format(endPoint[0], endPoint[1], endPoint[2], self.gcoder.getEValue(), 1800)\r\n                        tmpText = \"G1 X{0} Y{1} Z{2} F{3}\\n\".format(endPoint[0], endPoint[1], endPoint[2], 3600)\r\n                    else:\r\n                        tmpText = \"G1 X{0} Y{1} Z{2} F{3}\\n\".format(endPoint[0], endPoint[1], endPoint[2], 3600)\r\n                        flag = True\r\n\r\n                    self.gcoder.calcEValue(rs.Distance(endPoint, startPoint))\r\n                    #tmpText += \"G1 X\" + str(startPoint[0]) + \" Y\" + str(startPoint[1]) + \" Z\" + str(startPoint[2]) + \" E\" + str(self.gcoder.getEValue()) + \" F1800\\n\"\r\n                    tmpText += \"G1 X{0} Y{1} Z{2} E{3} F{4}\\n\".format(startPoint[0], startPoint[1], startPoint[2], self.gcoder.getEValue(), 1800)\r\n\r\n                    prePoint = startPoint\r\n\r\n\r\n\r\n                self.gcoder.addGcode(tmpText)\r\n\r\n            rs.DeleteObjects(lines)\r\n        rs.DeleteObject(baseLine)\r\n\r\n\r\n\r\n\r\n        \"\"\"\r\n        '''\r\n        in case there is paralell curve\r\n        '''\r\n        if paralellOffset is not None:\r\n            newLines  = []\r\n\r\n            for toTrim in lines:\r\n                trimedLines = self.trim(toTrim, paralellOffset, 2)\r\n                if trimedLines == None:\r\n                    continue\r\n                for hoge in trimedLines:\r\n                    newLines.append(hoge)\r\n\r\n            lines = newLines\r\n        \"\"\"\r\n\r\n\r\n        \"\"\"\r\n\r\n        for i in range(len(lines)):\r\n            startPoint = rs.CurveStartPoint(lines[i])\r\n            endPoint = rs.CurveEndPoint(lines[i])\r\n\r\n            self.gcoder.calcEValue(rs.Distance(startPoint, endPoint))\r\n\r\n            if i%2 == 0:\r\n                tmpText = \"G1 X\" + str(startPoint[0]) + \" Y\" + str(startPoint[1]) + \" Z\" + str(startPoint[2]) + \" F3600\\n\"\r\n                tmpText += \"G1 X\" + str(endPoint[0]) + \" Y\" + str(endPoint[1]) + \" Z\" + str(endPoint[2]) + \" E\" + str(self.gcoder.getEValue()) + \" F1800\\n\"\r\n\r\n            elif i%2 == 1:\r\n                tmpText = \"G1 X\" + str(endPoint[0]) + \" Y\" + str(endPoint[1]) + \" Z\" + str(endPoint[2]) + \" F3600\\n\"\r\n                tmpText += \"G1 X\" + str(startPoint[0]) + \" Y\" + str(startPoint[1]) + \" Z\" + str(startPoint[2]) + \" E\" + str(self.gcoder.getEValue()) + \" F1800\\n\"\r\n\r\n\r\n\r\n            self.gcoder.addGcode(tmpText)\r\n        \"\"\"\r\n\r\n\r\n\r\n\r\n        #vertical\r\n\r\n        baseLine = rs.AddLine(editPoints[0], editPoints[2])\r\n        baseVec = (editPoints[1][0]-editPoints[0][0], editPoints[1][1]-editPoints[0][1], editPoints[1][2]-editPoints[0][2])\r\n        forNormalize = math.sqrt(baseVec[0]**2 + baseVec[1]**2 + baseVec[2]**2)\r\n        baseVec = [i/forNormalize for i in baseVec]\r\n\r\n        dist = rs.Distance(editPoints[0], editPoints[1])\r\n\r\n\r\n        lines = []\r\n\r\n        #interval = self.gcoder.getLayerHeight() * (1.0 / self.gcoder.getInfillRatio())\r\n\r\n        flag = False\r\n        #prepare horizontal lines\r\n        for i in range(int(dist/interval + 1)):\r\n            nextVec = [j*(interval*i) for j in baseVec]\r\n\r\n            nextStartPoint = (editPoints[0][0]+nextVec[0], editPoints[0][1]+nextVec[1], editPoints[0][2]+nextVec[2])\r\n            nextEndPoint = (editPoints[2][0]+nextVec[0], editPoints[2][1]+nextVec[1], editPoints[2][2]+nextVec[2])\r\n\r\n            nextLine = rs.AddLine(nextStartPoint, nextEndPoint)\r\n\r\n            if nextLine == None or intersectCurve == None:\r\n                #print(\"hogehoge\")\r\n                rs.DeleteObject(baseLine)\r\n                rs.DeleteObject(nextLine)\r\n                continue\r\n\r\n\r\n            lines = (self.trim(nextLine, intersectCurve, 1))\r\n            rs.DeleteObject(nextLine)\r\n\r\n            if lines is None:\r\n                continue\r\n\r\n            if i%2 == 1:\r\n                lines.reverse()\r\n\r\n\r\n\r\n            for j in lines:\r\n                startPoint = rs.CurveStartPoint(j)\r\n                endPoint = rs.CurveEndPoint(j)\r\n\r\n                if i%2 == 0:\r\n                    if flag:\r\n                        self.gcoder.calcEValue(rs.Distance(prePoint, startPoint))\r\n                        tmpText = \"G1 X{0} Y{1} Z{2} F{3}\\n\".format(startPoint[0], startPoint[1], startPoint[2], 3600)\r\n                    else:\r\n                        tmpText = \"G1 X{0} Y{1} Z{2} F{3}\\n\".format(startPoint[0], startPoint[1], startPoint[2], 3600)\r\n\r\n                    self.gcoder.calcEValue(rs.Distance(startPoint, endPoint))\r\n                    tmpText += \"G1 X{0} Y{1} Z{2} E{3} F{4}\\n\".format(endPoint[0], endPoint[1], endPoint[2], self.gcoder.getEValue(), 1800)\r\n                    prePoint = endPoint\r\n\r\n                    flag = True\r\n\r\n\r\n                elif i%2 == 1:\r\n                    if flag:\r\n                        self.gcoder.calcEValue(rs.Distance(prePoint, endPoint))\r\n\r\n                        tmpText = \"G1 X{0} Y{1} Z{2} F{3}\\n\".format(endPoint[0], endPoint[1], endPoint[2], 1800)\r\n                    else:\r\n                        tmpText = \"G1 X{0} Y{1} Z{2} F{3}\\n\".format(endPoint[0], endPoint[1], endPoint[2], 1800)\r\n\r\n                    self.gcoder.calcEValue(rs.Distance(endPoint, startPoint))\r\n                    tmpText += \"G1 X{0} Y{1} Z{2} E{3} F{4}\\n\".format(startPoint[0], startPoint[1], startPoint[2], self.gcoder.getEValue(), 1800)\r\n\r\n                    prePoint = startPoint\r\n\r\n                    flag = True\r\n\r\n\r\n                self.gcoder.addGcode(tmpText)\r\n\r\n            rs.DeleteObjects(lines)\r\n\r\n\r\n        rs.DeleteObject(baseLine)\r\n\r\n\r\n        return\r\n\r\n\r\n\r\n    def clean(self):\r\n\r\n        rs.DeleteObject(self.sliceSurface)\r\n        rs.DeleteObject(self.addtiveObj)\r\n        return\r\n\r\n    #setter orgnizer\r\n    \"\"\"\r\n    def setPrintingSetting(self):\r\n\r\n        #you wannt to import xml file or not?\r\n\r\n        result = rs.MessageBox(\"Do you wish to import 'Print Setting File'?\", 4, title=\"Import Print Setting\")\r\n\r\n        if result == 1:\r\n            xmlFile = rs.OpenFileName(\"Select Print Setting File\", \"XML Files (*.xml)|*.xmx|All Files (*.*)|*.*||\")\r\n            self.printSetter.setFileName(xmlFile)\r\n            self.printSetter.importPrintSetting()\r\n\r\n        else:\r\n\r\n            self.setExtruderDiameter()\r\n            self.setFilamentDiameter()\r\n            self.setExtrudeTemperture()\r\n\r\n            self.setLayerHeight()\r\n            self.setNumShellOutline()\r\n            self.setNumTopLayer()\r\n            self.setNumBottomLayer()\r\n            self.setInfillRatio()\r\n\r\n            exportOrNot = rs.MessageBox(\"Do you wish to export 'Print Setting File'?\", 4, title=\"Export Print Setting\")\r\n            if result == 1:\r\n                _fileName = rs.SaveFileName(\"Export Print Setting File\", \"XML Files (*.xml)|*.xml|All Files (*.*)|*.*||\")\r\n                self.printSetter.setFileName(_fileName)\r\n                self.printSetter.exportPrintSetting()\r\n    \"\"\"\r\n\r\n    def setPrintingSetting(self):\r\n        self.setExtruderDiameter()\r\n        self.setFilamentDiameter()\r\n        self.setExtrudeTemperture()\r\n\r\n        self.setLayerHeight()\r\n        self.setNumShellOutline()\r\n        self.setNumTopLayer()\r\n        self.setNumBottomLayer()\r\n        self.setInfillRatio()\r\n\r\n\r\n    #setter\r\n\r\n    def setExtruderDiameter(self):\r\n        self.gcoder.setExtruderDiameter(rs.GetReal(\"Extruder Diameter\", 0.4))\r\n\r\n    def setFilamentDiameter(self):\r\n        self.gcoder.setFilamentDiameter(rs.GetReal(\"Filament Diameter\", 1.75))\r\n\r\n    def setExtrudeTemperture(self):\r\n        self.gcoder.setExtrudeTemperture(rs.GetReal(\"Extrude Temperture\", 195))\r\n\r\n    def setLayerHeight(self):\r\n        self.gcoder.setLayerHeight(rs.GetReal(\"Layer Height\", 0.15))\r\n\r\n    def setNumShellOutline(self):\r\n        self.gcoder.setNumShellOutline(int(rs.GetReal(\"Num of Shell Outline\", 2)))\r\n\r\n\r\n    def setNumTopLayer(self):\r\n        self.gcoder.setNumTopLayer(int(rs.GetReal(\"Num of Top Layer\", 2)))\r\n\r\n    def setNumBottomLayer(self):\r\n        self.gcoder.setNumBottomLayer(int(rs.GetReal(\"Num of Bottom Layer\", 2)))\r\n\r\n    def setInfillRatio(self):\r\n        self.gcoder.setInfillRatio(rs.GetReal(\"Infill Ratio\", 5))\r\n\r\n\r\n\"\"\"\r\n\r\n\r\nclass printSettingOrganizer():\r\n\r\n    def __init__(self, _gcoder):\r\n        self.gcoder = _gcoder\r\n\r\n\r\n    def setFileName(_fileName):\r\n        self.fileName = _fileName\r\n\r\n    def exportPrintSetting(self):\r\n        tmpText = '<?xml version=\"1.0\"?>'\r\n        tmpText += \"<printSetting>\\n\"\r\n\r\n        tmpText += \"\\t<printerSetting>\\n\"\r\n        tmpText += \"\\t\\t<extruderTemperture>\" + str(self.gcoder.getExtrudeTemperture()) + \"</extrudeTemperture>\\n\"\r\n        tmpText += \"\\t\\t<filamentDiameter>\" + str(self.gcoder.getFilamentDiameter()) + \"</filamentDiameter>\\n\"\r\n        tmpText += \"\\t\\t<extruderDiameter>\" + str(self.gcoder.getExtruderDiameter()) + \"</extruderDiameter>\\n\"\r\n        tmpText += \"\\t</printerSetting>\\n\"\r\n\r\n        tmpText += \"\\t<sliceSetting>\\n\"\r\n        tmpText += \"\\t\\t<layerHeight>\" + str(self.gcoder.getLayerHeight()) + \"</layerHeight>\\n\"\r\n        tmpText += \"\\t\\t<shellOutline>\" + str(self.gcdoer.getNumShellOutline()) + \"</shellOutline>\\n\"\r\n        tmpText += \"\\t\\t<bottomLayer>\" + str(self.gcoder.getNumBottomLayer()) + \"</bottomLayer>\\n\"\r\n        tmpText += \"\\t\\t<topLayer>\" + str(self.gcoder.getNumTopLayer()) + \"</topLayer>\\n\"\r\n        tmptext += \"\\t\\t<infillRatio>\" + str(self.gcoder.getInfillRatio()) + \"</infillRatio>\\n\"\r\n        tmpText += \"\\t</sliceSetting>\\n\"\r\n\r\n        tmpText += \"</printSetting>\\n\"\r\n\r\n\r\n        with open(self.fileName, 'w') as w:\r\n            w.writelines(tmpText)\r\n            w.close()\r\n\r\n        print(\"Print setting file is exported\")\r\n\r\n        return\r\n\r\n    def importPrintSetting(self):\r\n        tree = ET.parse(self.fileName)\r\n\r\n        self.gcoder.setExtruderDiameter(int(tree.find('./printerSetting/extruderDiameter').text))\r\n        self.gcoder.setFilamentDiameter(int(tree.find('./printerSetting/filamentDiameter').text))\r\n        self.gcoder.setExtrudeTemperture(int(tree.find('./printerSetting/extrudeTemperture').text))\r\n\r\n        self.gcoder.setLayerHeight(int(tree.find('./sliceSetting/layerHeight').text))\r\n        self.gcoder.setInfillRatio(int(tree.find('./sliceSetting/infillRatio').text))\r\n        self.gcoder.setNumShellOutline(int(tree.find('./sliceSetting/shellOutline').text))\r\n        self.gcoder.setNumTopLayer(int(tree.find('./sliceSetting/topLayer').text))\r\n        self.gcoder.setNumBottomLayer(int(tree.find('./sliceSetting/bottomLayer').text))\r\n\r\n        print(\"Print Setting is imported\")\r\n\r\n        return\r\n\"\"\"\r\n\r\nclass gcodeGenerater():\r\n\r\n    def __init__(self):\r\n\r\n        self.fileName = \"testGcode.gcode\"\r\n        self.textGcode = \"\"\r\n\r\n        self.layerHeight = 0.2\r\n        self.extruderDiameter = 0.4\r\n        self.filamentDiameter = 1.75\r\n        self.extrudeTemperture = 210\r\n        self.infillRatio = 0.02\r\n\r\n        self.numBottomLayer = 2\r\n        self.numTopLayer = 4\r\n        self.numShellOutline = 3\r\n\r\n        self.EValue = 0\r\n\r\n        self.f = None\r\n\r\n\r\n\r\n    def initGcode(self, fileN):\r\n        self.textGcode = \"\"\r\n\r\n        self.textGcode += \"G90\\n\" # set to absolute positioning\r\n        self.textGcode += \"M82\\n\" # set extruder to absolute mode\r\n        self.textGcode += \"M106 S255\\n\" # fan on\r\n        self.textGcode += \"M104 S\" + str(self.extrudeTemperture) + \" T0\\n\" # set extruder temperture\r\n        self.textGcode += \"M109 S\" + str(self.extrudeTemperture) + \" T0\\n\" # set extruder temperture and wait\r\n        self.textGcode += \"G28\\n\" #go home\r\n\r\n        self.textGcode += \"G92 E0\\n\" # set position: E -> new extruder position\r\n        self.textGcode += \"G1 E-1.0000 F1800\\n\" # retract\r\n\r\n        self.f = open(fileN, \"w\")\r\n        self.f.writelines(self.textGcode)\r\n\r\n    def addGcode(self, code):\r\n        #self.textGcode += code\r\n        self.f.writelines(code)\r\n\r\n    def finishGcode(self):\r\n        self.textGcode = \"G92 E0\\n\"\r\n        self.textGcode += \"G1 E-1.0000 F18000\\n\"\r\n        self.textGcode += \"M104 S0\\n\"\r\n        self.textGcode += \"M140 S0\\n\"\r\n        self.textGcode += \"G28\\n\"\r\n        self.textGcode += \"M84\\n\"\r\n\r\n        self.f.writelines(self.textGcode)\r\n\r\n    def outputFile(self):\r\n        '''\r\n        with open(fileN, \"w\") as f:\r\n            f.writelines(self.textGcode)\r\n            f.close()\r\n        '''\r\n\r\n        self.f.close()\r\n        print(\"Successfly gcode file is output\")\r\n\r\n\r\n    def calcEValue(self, dist):\r\n        self.EValue += float(dist * self.getLayerHeight() * self.getExtruderDiameter()) / \\\r\n                        float(math.pi * (float(self.getFilamentDiameter()/2.0) ** 2))\r\n\r\n    #setter\r\n    def setFileName(self, _fileName):\r\n        self.fileName = _fileName\r\n\r\n    def setLayerHeight(self, _layerHeight):\r\n        self.layerHeight = _layerHeight\r\n\r\n    def setExtruderDiameter(self, _extruderDiameter):\r\n        self.extruderDiameter = _extruderDiameter\r\n\r\n    def setFilamentDiameter(self, _filamentDiameter):\r\n        self.filamentDiameter = _filamentDiameter\r\n\r\n    def setInfillRatio(self, _infillRatio):\r\n        self.infillRatio = _infillRatio\r\n\r\n    def setNumShellOutline(self, _numShellOutline):\r\n        self.numShellOutline = _numShellOutline\r\n\r\n    def setNumTopLayer(self, _numTopLayer):\r\n        self.numTopLayer = _numTopLayer\r\n\r\n    def setNumBottomLayer(self, _numBottomLayer):\r\n        self.numBottomLayer = _numBottomLayer\r\n\r\n    def initEValue(self):\r\n        self.EValue = 0\r\n\r\n    def setExtrudeTemperture(self, _extrudeTemperture):\r\n        self.extrudeTemperture = _extrudeTemperture\r\n\r\n\r\n\r\n\r\n    #getter\r\n    def getLayerHeight(self):\r\n        return self.layerHeight\r\n\r\n    def getExtruderDiameter(self):\r\n        return self.extruderDiameter\r\n\r\n    def getFilamentDiameter(self):\r\n        return self.filamentDiameter\r\n\r\n    def getInfillRatio(self):\r\n        return self.infillRatio\r\n\r\n    def getNumShellOutline(self):\r\n        return self.numShellOutline\r\n\r\n    def getNumTopLayer(self):\r\n        return self.numTopLayer\r\n\r\n    def getNumBottomLayer(self):\r\n        return self.numBottomLayer\r\n\r\n    def getEValue(self):\r\n        return self.EValue\r\n    def getExtrudeTemperture(self):\r\n        return self.extrudeTemperture\r\n\r\n    def getFilamentDiameter(self):\r\n        return self.filamentDiameter\r\n\r\n    def getExtruderDiameter(self):\r\n        return self.extruderDiameter\r\n\r\n\r\n'''\r\nmain\r\n'''\r\n\r\ndef main():\r\n\r\n    gcoder = gcodeGenerater()\r\n    #printSetter = printSettingOrganizer(gcoder)\r\n    #aam = AAM_Planar(gcoder, printSetter)\r\n\r\n    aam = AAM_Planar(gcoder)\r\n    aam.main()\r\n\r\ndef RunCommand(is_interactive):\r\n    main()\r\n\r\n'''\r\nif __name__ == \"__main__\":\r\n    main()\r\n'''\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}