{
  "source_url": "https://github.com/SHLFab/shl-toolbox/blob/268349a38b254c507c73a5a12f81f05d8af3acfc/lib/util.py",
  "repo": "SHLFab/shl-toolbox",
  "repo_stars": 1,
  "repo_description": "SHL Fabrication tools",
  "license": "AGPL-3.0",
  "filepath": "lib/util.py",
  "instruction": "help docstring",
  "code": "\"\"\"help docstring\"\"\"\n#workshop_lib\n#rhino utilities\n\n#SHL Architects\n#Sean Lamb 2018-09-26\n#TODO: define an __all__\n\nimport math\nfrom itertools import count, takewhile\nimport colorsys\nimport rhinoscriptsyntax as rs\n\n\ndef equidistant_hsv_color(num,saturation):\n\t\"\"\"returns tuple of colours with equidistantly spaced hue\"\"\"\n\tcolors = []\n\tfor k in xrange(num):\n\t\tcolor = colorsys.hsv_to_rgb((1/float(num))*k,saturation,1.0)\n\t\tcolors.append(tuple([int(255*i) for i in color]))\n\treturn colors\n\ndef frange(start,stop,step):\n\t\"\"\"floating point range. output vals will not exceed the stop param.\n\t\tparams:\n\t\tstart: start of range\n\t\tstop: end of range\n\t\tstep: increment\n\treturns:\n\t\tlist of floats\"\"\"\n\treturn list( takewhile(lambda x: x <= stop, (start + i * step for i in count())) )\n\n\ndef num_div(num,divisor):\n\t\"\"\"number of divisors. posibly not necessary w/ divmod\"\"\"\n\tdivs = -1\n\tif num < divisor:\n\t\treturn -1\n\tif num == divisor:\n\t\treturn 0\n\twhile num>0:\n\t\tdivs += 1\n\t\tnum = num - divisor\n\treturn divs-1\n\n\ndef number_to_letter(num,start=0,upper=True,append=True):\n\t\"\"\"convert int to uppercase letter. ***will wrap if out of alphabet bounds***\n\tparams:\n\t\tnum: int\n\t\tstart=0: base number corresponding to 'a'\n\t\tupper=True: convert to upper\n\t\tappend=True: append when wrapping.\n\treturns:\n\t\tletter: character corresponding to number\n\tDEV NOTES: still a bug in here\"\"\"\n\n\tdivs = num_div(num,26)\n\tnum = num % 26\n\t#print divs\n\tshifted = num + 97 - start\n\tletters = chr(shifted)\n\n\tif divs > -1:\n\t\tletters = str( chr(divs + 97) ) + str(letters)\n\t#print letters\n\tif upper==True: letters=letters.upper()\n\n\treturn letters\n\n\ndef dotprod(a,b):\n\tdprod = 0\n\tfor i,j in zip(a,b):\n\t\t#print i,j\n\t\tdprod += i*j\n\treturn dprod\n\n\ndef xprod(a,b):\n\txprod = a[0]*b[1] - a[1]*b[0]\n\treturn xprod\n\n\ndef innerangle(a,b,radians=False):\n\tdp = dotprod(a,b)\n\tlen_1 = rs.VectorLength(a)\n\tlen_2 = rs.VectorLength(b)\n\t#print len_1\n\t#print len_2\n\tinnerangle = math.acos(dp/(len_1*len_2))\n\tif radians == False:\n\t\tinnerangle = math.degrees(innerangle)\n\n\treturn innerangle\n\n\ndef partition_objects_by_attr(objects,attribute,reverse_bool=False):\n\t\"\"\"params:\n\t\tobjects: list of objects\n\t\tattribute: str of attribute to partition by.\n\t\treverse: reverse the sorting order for the partition\n\treturns:\n\t\tobject[][]: list of lists of objects partitioned by the attribute.\n\t\"\"\"\n\tobjects.sort(key=lambda x:getattr(x,attribute), reverse=reverse_bool)\n\n\tset_sorter = sorted(set([getattr(x,attribute) for x in objects])) #sorted set of possible heights\n\tprint set_sorter\n\n\tpartitioned_list = []\n\tfor i,item in enumerate(set_sorter):\n\t\tpartitioned_list.append(filter(lambda x: getattr(x,attribute) == item, objects))\n\n\treturn partitioned_list\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}