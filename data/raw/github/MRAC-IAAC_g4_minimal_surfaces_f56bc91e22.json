{
  "source_url": "https://github.com/MRAC-IAAC/g4_minimal_surfaces/blob/5f2eae73e17570e76f3e917c85e18f97ce57de33/voxel_growth.py",
  "repo": "MRAC-IAAC/g4_minimal_surfaces",
  "repo_stars": 2,
  "repo_description": null,
  "license": "unknown",
  "filepath": "voxel_growth.py",
  "instruction": "encoding: utf-8",
  "code": "# encoding: utf-8\n\n##################################################\n# Software 1 Group 04\n##################################################\n#\n##################################################\n# Author: Matt Gordon / Jun Lee / Amit Pattar\n# Copyright: Copyright 2019, IAAC\n# Credits: [Institute for Advanced Architecture of Catalonia - IAAC, MRAC group]\n# License:  Apache License Version 2.0\n# Version: 1.0.0\n# Maintainer: Matt Gordon\n# Email: matthew.gordon@students.iaac.net\n# Status: development\n##################################################\n\nimport math\nimport random\n\nimport rhinoscriptsyntax as rs\nimport ghpythonlib.components as gh\n\n# === GLOBAL VARIABLES ===\n\n# World Geometry\nworld_xy = gh.XYPlane(gh.ConstructPoint(0,0,0))\nworld_xz = gh.XZPlane(gh.ConstructPoint(0,0,0))\nworld_yz = gh.YZPlane(gh.ConstructPoint(0,0,0))\n\nworld_planes = [world_xy , world_xz, world_yz]\n\n# World Sizes\nslice_size = grid_size * grid_size\nvlength = slice_size * grid_size\n\nmax_dist = 6928\n\n# Deltas in Voxel Space: (+z, +y, +x, -y, -x, -z)  \ndxv = (0,0,1,0,-1,0)\ndyv = (0,1,0,-1,0,0)\ndzv = (1,0,0,0,0,-1)\n\n# Gen variables\nmax_cells =  2000\ncell_count = 0\n\nfactor_attractor = 0.9\n\nfactor_void = 1\nfactor_perlin = 0.8\nscore_crowding = 50\n\ngrowth_per_cell = 2\n\nuse_points = True\nuse_volumes = True\nuse_crowding = False\nuse_first = False\nuse_age = True\nuse_perlin = True\n\n\nlive_cells = []\nattempts = []\nattempt_scores = []\n\n\"\"\" Iteration in which a cell was activated \"\"\"\ncell_age = [] \n\n# Precomputed Score Values\nvolume_void_inclusion = []\nattract_point_distances = []\n\n\n# === DEFINITIONS ===\ndef loc_to_cart(loc):\n    \"\"\" Converts a 1d cell to a 3d cell\"\"\"\n    return (loc % grid_size, loc % slice_size // grid_size, loc // slice_size)\n    \ndef cart_to_loc(cart):\n    \"\"\" Converts a 3d cell to a 1d cell\"\"\"\n    return (cart[2] * slice_size) + (cart[1] * grid_size) + cart[0]\n    \ndef get_cart_neighbor(cart,id):\n    \"\"\" Returns a 3d cell given a direction from an existing 3d cell\"\"\"\n    return (cart[0] + dxv[id],cart[1] + dyv[id],cart[2] + dzv[id])\n    \ndef check_cart(cart):\n    \"\"\" Returns True if the cell is within the voxel domain\"\"\"\n    return 0 <= cart[0] < grid_size and 0 <= cart[1] < grid_size and 0 <= cart[2] < grid_size\n   \ndef get_neighbor_live_count(cart):\n    \"\"\" Returns the number of live neighbors surrounding a 3d cell\"\"\"\n    count = 0\n    for i in range(6):\n        cart2 = (cart[0] + dxv[i],cart[1] + dyv[i],cart[2] + dzv[i])\n        if check_cart(cart2) and voxel_data[cart_to_loc(cart2)] == 1:\n            count += 1\n    return count\n    \ndef lerp(val,s1,e1,s2,e2):\n    range1 = e1 - s1\n    range2 = e2 - s2\n    \n    normal = (val - s1) / range1\n    \n    return (normal * range2) + s2\n    \ndef clamp(val,min_val,max_val):\n    return(max(min(val, max_val), min_val))\n\ndef check_dead(cart):\n    \"\"\" Returns True if the cell is not alive\"\"\"\n    id = cart_to_loc(cart)\n    return voxel_data[id] == 0\n    \ndef precompute_scoring():\n    \"\"\" Run gh volume inclusion and attractor distance calculations for every voxel point in the domain\"\"\"\n    global volume_void_inclusion\n    global attract_point_distances\n    global perlin_values\n    \n    volume_void_inclusion = []\n    for i,void in enumerate(volumes_void):\n        inclusion = gh.PointInBrep(void,points_input,False)\n        volume_void_inclusion.append(inclusion)\n        \n    attract_point_distances = []\n    for i,point in enumerate(points_attractor):\n        distances = gh.Division(gh.Distance(point,points_input),max_dist)\n        attract_point_distances.append(distances)\n    \n\ndef strategy_attractors(cart):\n    global attempts\n    global attempt_scores\n\n    del attempts[:]\n    del attempt_scores[:]\n    \n    neighbors = [get_cart_neighbor(cart,i) for i in range(6)]\n    neighbors = [c for c in neighbors if check_cart(c)]\n    scores = [get_cart_score(c) for c in neighbors]\n    \n    neighbors = [x for _,x in sorted(zip(scores,neighbors))]\n    neighbors.reverse()\n    scores = sorted(scores)\n    scores.reverse()\n    \n    attempts = attempts + neighbors\n    attempt_scores = attempt_scores + scores\n    \ndef get_cart_score(cart):\n    global factor_attractor\n    global factor_void\n    global score_volume\n    global factor_perlin\n    \n    loc = cart_to_loc(cart)\n    score = 0\n    \n    fa_local = factor_attractor\n    \n    if use_age:\n        fa_local *= (1- (1.00 * cell_count / max_cells))\n    if use_points:\n        for i,pa in enumerate(points_attractor):\n            d = attract_point_distances[i][loc]\n            score += (1 - d) * fa_local\n    if use_volumes:\n        for i,vv in enumerate(volumes_void):\n            if volume_void_inclusion[i][loc]:\n                score -= factor_void\n    if use_crowding:\n        neighbor_count = get_neighbor_live_count(cart)\n        score -= (score_crowding * neighbor_count)\n    if use_perlin:\n        score += perlin_values[cart_to_loc(cart)] * factor_perlin\n    # if use_age:\n        # age_score = 0\n        # neighbors = [get_cart_neighbor(cart,i) for i in range(6)]\n        # for n in neighbors:\n            # if check_cart(n) and not check_dead(n):\n                # age_score += cell_age[cart_to_loc(n)]\n        # age_score /= 100.0\n        # score -= age_score\n    \n    return score\n    \ndef mesh_strategy_neighbors(cart):\n    neighbors = get_neighbor_live_count(cart)\n    id = 0\n    if neighbors <= 2:\n        id = 0\n    elif neighbors <= 4:\n        id = 1\n    else:\n        id = 2\n    return id\n    \ndef mesh_strategy_vertical(cart):\n    id = 1\n    \n    cart_up = get_cart_neighbor(cart,0)\n    cart_down = get_cart_neighbor(cart,5)\n    \n    up_good = check_cart(cart_up) and not check_dead(cart_up)\n    down_good = check_cart(cart_down) and not check_dead(cart_down)\n    \n    if up_good == down_good:\n        id = 1\n    elif up_good:\n        id = 0\n    elif down_good:\n        id = 2\n    \n    return id\n\ndef copy_modules():\n    global meshes_a,meshes_b,meshes_c\n    # Copying Modules\n    meshes_a = []\n    meshes_b = []\n    meshes_c = []\n    totals = [0,0,0]\n    for i,p in enumerate(points_input):\n        d = voxel_data[i]\n        if d == 0:\n            continue\n        cart = loc_to_cart(i)\n\n        mesh_id = mesh_strategy_neighbors(cart)\n        \n        translation = gh.Vector2Pt(world_xy,p,False)[0]\n        \n        add = clamp(int((gh.Deconstruct(p)[2] / 4000 * 4) + (perlin_values[i] - 0.5)),0,3)\n        \n        \n        if mesh_id == 0:\n            meshes_a.append(gh.Move(mesh_input[16 + add],translation)[0])\n        elif mesh_id == 1:\n            meshes_a.append(gh.Move(mesh_input[12 + add],translation)[0])\n            meshes_b.append(gh.Move(mesh_input[8 + add],translation)[0])\n        elif mesh_id == 2:\n            meshes_b.append(gh.Move(mesh_input[4 + add],translation)[0])\n            meshes_c.append(gh.Move(mesh_input[0 + add],translation)[0])\n            \n        \n        totals[mesh_id] += 1\n        \n        \n        \n        #new_plane = gh.PlaneOrigin(random.choose\n        \n        \n        \n    print totals\n\ndef run_pass():\n    global live_cells\n    global cell_count\n    global attempts\n    \n    live_cells_next = []\n    for i,cell in enumerate(live_cells):\n        if cell_count >= max_cells:\n            break\n        if use_first:\n            id = 0\n        else:\n            id = random.randint(0,len(live_cells) - 1)\n\n        voxel_data[cart_to_loc(cell)] = 1\n            \n        strategy_attractors(cell)\n\n        cells_added = 0\n        for i,n in enumerate(attempts):\n            if check_cart(n) and check_dead(n) and not n in live_cells_next:\n                if cells_added == 0:\n                    live_cells_next.insert(0,n)\n                else:\n                    live_cells_next.append(n)\n                    \n                cells_added += 1\n                cell_count += 1\n                \n                attempt_loc = cart_to_loc(n)\n                \n                if perlin_values[attempt_loc] > perlin_cutoff:\n                    break\n\n                \n                if cells_added == growth_per_cell:\n                    break\n                    \n    del live_cells[:]\n    live_cells = live_cells + live_cells_next\n\ndef run_pass_2():\n    \"\"\" Every cell is live, combine cell and neighbor choosing\"\"\"\n    global live_cells\n    global cell_count\n    global attempts\n    global cell_age\n    \n    print(\"Live Cells : \" + str(len(live_cells)))\n    \n    live_cell_scores = [get_cart_score(c) for c in live_cells]\n    live_cells_sorted = [x for _,x in sorted(zip(live_cell_scores,live_cells))]\n    del live_cells[:]\n    live_cells = live_cells + live_cells_sorted\n    \n    cell = live_cells.pop(0)\n    if check_cart(c) and check_dead(c):\n        voxel_data[cart_to_loc(cell)] = 1\n        \n        cell_age[cart_to_loc(c)] = cell_count\n        \n        \n        cell_count += 1\n            \n        neighbors = [get_cart_neighbor(c,i) for i in range(6)]\n            \n        for n in neighbors:\n            if check_cart(n) and check_dead(c) and not n in live_cells:\n                live_cells.append(n)\n\n    \ndef main():\n    global mesh_result\n    global live_cells\n    global attempts\n    global cell_age\n\n    # Initialize random seed\n\n    precompute_scoring()\n\n\n    cell_age = [0] * len(points_input)\n\n    # Initial Seed Cells\n    live_cells = []\n    \n    for sp in seed_points:\n        cart = [ int(n / voxel_size) for n in gh.Deconstruct(sp)]\n        live_cells.append(cart)\n\n    while len(live_cells) > 0 and cell_count <= max_cells:\n        run_pass()\n            \n    print(\"Live Cells Left : \" + str(len(live_cells)))\n    print(\"Cell Count : \" + str(cell_count))\n        \n    copy_modules()\n\n    \n\n\nmain()",
  "language": "python",
  "imports": [
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}