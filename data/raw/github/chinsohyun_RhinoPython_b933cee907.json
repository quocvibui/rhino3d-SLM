{
  "source_url": "https://github.com/chinsohyun/RhinoPython/blob/20488c293c36fb1b113471a48bf79190097ad447/Digital_dessin/recursive%20vector.py",
  "repo": "chinsohyun/RhinoPython",
  "repo_stars": 0,
  "repo_description": "Individual Projects in Scripting and Parametric Design Fall 2024",
  "license": "unknown",
  "filepath": "Digital_dessin/recursive vector.py",
  "instruction": "Recursive vector",
  "code": "import rhinoscriptsyntax as rs\nimport random\n\nrs.EnableRedraw(False)\n\n\ndef vector_field(pt, attractor, length):\n    vecSum = [0,0,0]\n    polyline_pts = []\n    midpoints = []\n    vectors = []\n    max_dis = 20\n    min_dis = 2\n    new_vec = attractor[0]\n    \n    for line in attractor:\n        start_pt = rs.CurveStartPoint(line)\n        mid_pt = rs.CurveMidPoint(line)\n        end_pt = rs.CurveEndPoint(line)\n        vec = rs.VectorCreate(end_pt, start_pt)\n        midpoints.append(mid_pt)\n        vectors.append(vec)\n    for n in range(10):\n        for k in range(len(attractor)):\n            dis = rs.Distance(pt, midpoints[k])\n            \n            if dis > 0:\n                if dis < min_dis:\n                    dis = min_dis\n\n                vecSum = rs.VectorAdd(vecSum, rs.VectorScale(vectors[k], 1/(dis)))\n                new_vec = rs.VectorAdd(pt, vecSum)\n                polyline_pts.append(new_vec)\n                grid_pt = new_vec\n    line = rs.AddCurve(polyline_pts, 3)\n    return line\n\n#subsurface \ndef find_UV(srf, u_num, v_num, scale, mode, lines, l, modes, scales,):\n    if l > 6 or scale > 15:\n        print(\"iteration\", l, \"mode\", modes, \"scales\", scales)\n        return \n    pt_dict = {}\n    normal_vec = {}\n    vec = {}\n    zAxis = [0, 0, 1]\n    line = None\n    print(\"(u,v)\", u_num, v_num)\n    if len(lines) != 0:\n        attractor = random.sample(lines, 3)\n        lines = []\n    else:\n        attractor = []\n        for k in range(3):\n            attractor.append(rs.AddLine((10,k*10, 1), (k*10, 0, 20)))\n        rs.HideObjects(attractor)\n    \n    attractor_pt = []\n    for line in attractor:\n         mid_pt = rs.CurveMidPoint(line)\n         attractor_pt.append(mid_pt)\n    \n        \n    u_domain = rs.SurfaceDomain(srf, 1) #3.0, range of width length\n    v_domain = rs.SurfaceDomain(srf, 0) #3.3,\n    \n    u_spacing = u_domain[1]/u_num\n    v_spacing = v_domain[1]/v_num\n    \n    color = (u_num**4 % 255, v_num**2 % 255, u_num**2 % 255)\n#    color = (0, 0, 0)\n    for j in range(u_num):\n        for i in range(v_num):\n            u = v_spacing * i\n            v = u_spacing * j\n            \n            point = rs.EvaluateSurface(srf, u,v) #point3d\n\n            pt_dict[(i, j)] = point #lower points\n            normal = rs.SurfaceNormal(srf, [u,v]) #SurfaceClosestPoint or UV param\n            \n            index = rs.PointArrayClosestPoint(attractor_pt, point)\n            dis = rs.Distance(attractor_pt[index], point)\n\n            if mode == 0: #normal\n                vec[(i, j)] = rs.VectorAdd(point, normal*scale*5/dis)\n                if rs.Distance(vec[(i, j)], point) > 0.001:\n                    line = rs.AddLine(point, vec[(i, j)])\n                    \n            if mode == 1: #cross\n                cross = rs.VectorCrossProduct(normal, zAxis)\n                axis = rs.VectorAdd(point, normal)\n                pt = rs.VectorAdd(point, cross*scale*10) \n                pt = rs.VectorRotate(pt, dis%90, axis)\n                if rs.Distance(pt, point) > 0.001 and rs.Distance(pt, point) < 30:\n                    line = rs.AddLine(point, pt)\n                    \n            if mode == 2: #diagonal\n                if i != 0 and j != 0:\n                    diagonal = rs.VectorSubtract(point, pt_dict[(i - 1, j - 1)])\n                    vec[(i, j)] = rs.VectorAdd(point, diagonal*scale*10/dis) \n                    if rs.Distance(vec[(i, j)], point) > 0.001  and rs.Distance(vec[(i, j)], point) < 30:\n                        line = rs.AddLine(point, vec[(i, j)])\n                    \n            if mode == 3: #horizontal\n                if i != 0:\n                    horizon = rs.VectorSubtract(point, pt_dict[(i - 1, j)])\n                    vec[(i, j)] = rs.VectorAdd(point, horizon*scale*10/dis) \n                    if rs.Distance(vec[(i, j)], point) > 0.001 and rs.Distance(vec[(i, j)], point) < 30:\n                        line = rs.AddLine(point, vec[(i, j)])\n                    \n            if mode == 4: #vertical\n                if j != 0:\n                    vertical = rs.VectorSubtract(point, pt_dict[(i, j - 1)])\n                    vec[(i, j)] = rs.VectorAdd(point, vertical*scale*10/dis)\n                    if rs.Distance(vec[(i, j)], point) > 0.001  and rs.Distance(vec[(i, j)], point) < 30:\n                        line = rs.AddLine(point, vec[(i, j)])\n                    \n            if mode > 4:\n                line = vector_field(point, attractor, dis)\n                \n                    \n            if line:\n                lines.append(line)\n                rs.ObjectColor(line, color)\n                \n    u_num = u_num **3 % 223\n    v_num = u_num **3 % 317\n    modes[l] = 4 #recordds dw  old modes\n    scales[l] = scale\n    mode = random.choice([i for i in range(0, 6) if i != mode])\n    scale = random.uniform(0.7, 3)\n\n    return find_UV(srf, u_num, v_num, scale, mode, lines, l + 1, modes, scales)\n\n#srf = rs.AddSphere((0,0,0), 100)\nsrf = rs.GetObject(\"click the surface\")\nu = 146\nv = 157\nscale = 1.2\nmode = random.randint(0, 5)\nfind_UV(srf, u, v, scale, mode, [], 0, {}, {})\n\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}