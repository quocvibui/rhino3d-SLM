{
  "source_url": "https://github.com/adequin/adequin.github.io/blob/801c4e19687ffa809d85c15382323368751da686/Cells_models/python/UROP_create_cell.py",
  "repo": "adequin/adequin.github.io",
  "repo_stars": 0,
  "repo_description": "personal website",
  "license": "NOASSERTION",
  "filepath": "Cells_models/python/UROP_create_cell.py",
  "instruction": "Urop create cell",
  "code": "import rhinoscriptsyntax as rs\nimport Rhino.Geometry as rg\nimport math\nimport copy\n\n############################################################\n################ CREATING CELL VERTICES #################### \n############################################################\n\n#input parameters\ncap_len = 10 #dimension of base square\narm_len = 10 #length of \"arms\" extending from base square\narm_width = 10 #width of the arms\narm_angle = math.pi/3 #fold angle of the arm\n\n# final dictionary cell_coords = {\"1\", \"2\", \"3\", \"4\", \"1A\", \"1B\", \"1F\", \"2A\", \"2B\", \"2F\", \"3A\", \"3C\", \"3F\", \"4A\", \"4B\", \"4F\", \"5\", \"6\", \"7\", \"8\"}\n# \"F\" is for fold, the vertices folded in the corners\n# \"A\" and \"B\" is for each vertex at the edges extending from the base square\n# \"1\" - \"8\" is the bottom 4 and top 4 vertices\n    \ncell_coords = {} #main vertex dictionary\nheight = math.sin(arm_angle)*arm_len\ndist = math.cos(arm_angle)*arm_len\nmid = cap_len/2\n#constraint: domain of fold angle ends when coords of \"1A\" = \"4A\"\n#this happens when mid - arm_width/2\nif (mid-arm_width/2 <= -dist):\n    arm_angle = math.acos((arm_width - cap_len)/(2*arm_len)) \nheight = math.sin(arm_angle)*arm_len\ndist = math.cos(arm_angle)*arm_len\n############### create 4 base points in bottom level #################\nvert_bot = {\"1\":[0,0,0], \n            \"2\":[cap_len, 0, 0], \n            \"3\":[cap_len, cap_len, 0], \n            \"4\":[0, cap_len, 0]}\ncell_coords.update(vert_bot)\n\n############### create 8 points in middle level ######################\n#gets midpoints of caps to use arm_width\nmidpoints = {\"12\":[mid, -dist, height],\n            \"23\":[cap_len+dist, mid, height],\n            \"34\":[mid, cap_len+dist, height],\n            \"41\":[-dist, mid, height]}\n\n\n#create the 8 edge points by offsetting the midpoints\nvert_arm = {}\nfor idx in range(1,5):\n    midcoord = (midpoints[str(idx)+str(idx%4+1)]) #creates copy so it doesnt point to same address?\n    vert_arm[str(idx)+\"A\"] = copy.deepcopy(midcoord) #sets value as midpoint coordinates temporarily\n    vert_arm[str(idx)+\"B\"] = copy.deepcopy(midcoord) #sets value as midpoint coordinates temporarily\n\n    if idx%2:\n        vert_arm[str(idx)+\"A\"][0] = vert_arm[str(idx)+\"A\"][0] - arm_width/2 #offsets norm1 value by width parameter\n        vert_arm[str(idx)+\"B\"][0] = vert_arm[str(idx)+\"B\"][0] + arm_width/2 #offsets norm1 value by width parameter the other way\n    else:\n        vert_arm[str(idx)+\"A\"][1] = vert_arm[str(idx)+\"A\"][1] - arm_width/2 #offsets y value by width parameter \n        vert_arm[str(idx)+\"B\"][1] = vert_arm[str(idx)+\"B\"][1] + arm_width/2 #offsets y value by width parameter the other way #offsets y value by width parameter the other way\ncell_coords.update(vert_arm)\n\n################## create fold intersections points ################\n#get axis vectors starting at midpoints of arm verts ending at midpoints of bottom verts\naxis1 = [0,0,0]\naxis2 = [0,0,0]\nfor i in range(3):\n    axis1[i] = [mid,0,0][i] - midpoints[\"12\"][i] \n    axis2[i] = [0,mid,0][i] - midpoints[\"41\"][i]\n\n\n#normalize by finding norm\ndef distance(coord, origin):\n    \"\"\"returns the distance between 2 points given as coordinate lists [x,y,z]\"\"\"\n    distance = ((coord[0]-origin[0])**2 + (coord[1]-origin[1])**2  + (coord[2]-origin[2])**2 )**(0.5)\n    return distance\nnorm = distance(axis1, [0,0,0]) #calculate norm\n\nfor i in range(3): \n    axis1[i] = axis1[i]/norm #normalize\n    axis2[i] = axis2[i]/norm\n\nc1 = cell_coords[\"1A\"] #circle 1 origin\nc2 = cell_coords[\"4A\"] #circle 2 origin\n\n# implement cross product to find orthogonal vectors\ndef cross(v1,v2):\n    a = (v1[1]*v2[2]-v1[2]*v2[1])\n    b = (v1[0]*v2[2]-v1[2]*v2[0])\n    c = (v1[0]*v2[1]-v1[1]*v2[0])\n    return [a,-b,c]\n    \na1 = [1,0,0] # first vector normal to axis1\nb1 = cross(a1,axis1) # get second normal vector\na2 = [0,1,0] # first vector normal to axis2\nb2 = cross(axis2,a2) # get second normal vector \n \n#using define variables\nr = (cap_len - arm_width)/2 + arm_len # circle radius \nc = (c1[0]-c2[0])/r \na = a1[0]-a2[0] \nb = b1[0]-b2[0]\n\n#solve for parameter using x equations for circle1 and circle2\nt1 = math.acos((c*a+b*(a**2+b**2-c**2)**(1/2))/(a**2+b**2)) #parameter for intersection 1 (upper)\nt2 = math.acos((c*a-b*(a**2+b**2-c**2)**(1/2))/(a**2+b**2)) #parameter for intersection 2 (lower)\n\n#circle parametric equation\ndef coords(t,a,b,r,c):\n    \"\"\"returns coordinates of a point on a circle defined by \n    angle parameter t\n    plane vectors a \n    plane vectorb\n    radius r\n    origin c\"\"\"\n    return [c[0] + r*math.cos(t)*a[0] + r*math.sin(t)*b[0],\n            c[1] + r*math.cos(t)*a[1] + r*math.sin(t)*b[1],\n            c[2] + r*math.cos(t)*a[2] + r*math.sin(t)*b[2]]\n\n#plug in parameter for circle 1 to find intersection coordinates\nintsec = coords(math.pi-t1,a1,b1,r,c1)\nintsec2 = coords(math.pi+t2,a1,b1,r,c1) # add pi because acos is only 0<t<pi\n\n#using rhino methods for circle intersection\n# plane1 = rg.Plane(rs.coerce3dpoint(cell_coords[\"1A\"]), rs.coerce3dvector(axis1))                     \n# circle1 = rg.Circle(plane1, r) #creates 1A circle\n\n# plane2 = rg.Plane(rs.coerce3dpoint(cell_coords[\"4A\"]), rs.coerce3dvector(axis2)) \n# circle2 = rg.Circle(plane2, r) #create 4A circle\n\n# intsec = rg.Intersect.Intersection.CircleCircle(circle1, circle2)[1] # takes top intersection point\n\n\n#create 4 fold points\nfold_vert = {}\n\nif (arm_angle==0): #if angle is flat\n    xf = intsec[0]\n    yf = intsec[1]\n    zf = intsec[2]\n    shift = cap_len-2*xf #same for norm1 and y shifts\n    fold_vert[\"1F\"] = [xf, yf, zf]\n    fold_vert[\"2F\"] = [xf+shift, yf, zf]\n    fold_vert[\"3F\"] = [xf+shift, yf+shift, zf]\n    fold_vert[\"4F\"] = [xf, yf+shift, zf]\nelse:\n    #use \"intsec\" to \"1\" line equation set equal to height\n    coef = [0,0,0]\n    for i in range(3): #calculate coef vector\n        coef[i] = intsec[i] - cell_coords[\"1\"][i]\n    t = (height - cell_coords[\"1\"][2])/coef[2] #calculate parameter using z\n    xf = coef[0]*t\n    yf = coef[1]*t\n    zf = coef[2]*t\n    shift = cap_len-2*xf #same for norm1 and y shifts\n    fold_vert[\"1F\"] = [xf, yf, zf]\n    fold_vert[\"2F\"] = [xf+shift, yf, zf]\n    fold_vert[\"3F\"] = [xf+shift, yf+shift, zf]\n    fold_vert[\"4F\"] = [xf, yf+shift, zf]\n    \ncell_coords.update(fold_vert)\n\n\n############### create 4 points in top level #################\nvert_top = {\"5\":[0,0,2*height], \n            \"6\":[cap_len, 0, 2*height], \n            \"7\":[cap_len, cap_len, 2*height], \n            \"8\":[0, cap_len, 2*height]}\ncell_coords.update(vert_top)\n\n############################################################\n################ CREATING RHINO OBJECTS #################### \n############################################################\n\n############### create point objects in rhino #################\ndef addvert(point_dict, coord_dict):\n    \"\"\"adds points to dictionary 1 using vertex coordinates from dictionary 2\"\"\"\n    for key, pt in coord_dict.items():\n        point_dict[key] = rs.CreatePoint(pt)\ncell_points={}\naddvert(cell_points, cell_coords)\n\n# ############### create surface objects in rhino #################  \ndef addfaces(face_dict, vert_dict):\n    \"\"\"adds surfaces to dictionary 1 using vertices from dictionary 2\"\"\"\n    face_dict[\"bot\"] = rg.NurbsSurface.CreateFromCorners(   vert_dict[\"1\"], vert_dict[\"2\"], vert_dict[\"3\"], vert_dict[\"4\"])\n    face_dict[\"top\"] = rg.NurbsSurface.CreateFromCorners(   vert_dict[\"5\"], vert_dict[\"6\"], vert_dict[\"7\"], vert_dict[\"8\"])  \n\n    #create 4 bottom arm face_dict                                                                                                      \n    face_dict[\"arm12\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"1\"], vert_dict[\"2\"], vert_dict[\"1B\"], vert_dict[\"1A\"])                                                                                                                                            \n    face_dict[\"arm23\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"2\"], vert_dict[\"3\"], vert_dict[\"2B\"], vert_dict[\"2A\"])\n    face_dict[\"arm34\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"3\"], vert_dict[\"4\"], vert_dict[\"3A\"], vert_dict[\"3B\"])\n    face_dict[\"arm41\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"4\"], vert_dict[\"1\"], vert_dict[\"4A\"], vert_dict[\"4B\"])\n                                                        \n    #create 4 top arm face_dict                                                    \n    face_dict[\"arm56\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"5\"], vert_dict[\"6\"], vert_dict[\"1B\"], vert_dict[\"1A\"])\n    face_dict[\"arm67\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"6\"], vert_dict[\"7\"], vert_dict[\"2B\"], vert_dict[\"2A\"])\n    face_dict[\"arm78\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"7\"], vert_dict[\"8\"], vert_dict[\"3A\"], vert_dict[\"3B\"])\n    face_dict[\"arm85\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"8\"], vert_dict[\"5\"], vert_dict[\"4A\"], vert_dict[\"4B\"])\n                                                        \n    #create 8 bottom fold face_dict\n    face_dict[\"bot1A\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"1\"], vert_dict[\"1A\"], vert_dict[\"1F\"])\n    face_dict[\"bot1B\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"2\"], vert_dict[\"1B\"], vert_dict[\"2F\"])\n    face_dict[\"bot2A\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"2\"], vert_dict[\"2A\"], vert_dict[\"2F\"])\n    face_dict[\"bot2B\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"3\"], vert_dict[\"2B\"], vert_dict[\"3F\"])\n    face_dict[\"bot3A\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"3\"], vert_dict[\"3B\"], vert_dict[\"3F\"])\n    face_dict[\"bot3B\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"4\"], vert_dict[\"3A\"], vert_dict[\"4F\"])\n    face_dict[\"bot4A\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"4\"], vert_dict[\"4B\"], vert_dict[\"4F\"])\n    face_dict[\"bot4B\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"1\"], vert_dict[\"4A\"], vert_dict[\"1F\"])\n\n    #create 8 top fold face_dict\n    face_dict[\"top1A\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"5\"], vert_dict[\"1A\"], vert_dict[\"1F\"])\n    face_dict[\"top1B\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"6\"], vert_dict[\"1B\"], vert_dict[\"2F\"])\n    face_dict[\"top2A\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"6\"], vert_dict[\"2A\"], vert_dict[\"2F\"])\n    face_dict[\"top2B\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"7\"], vert_dict[\"2B\"], vert_dict[\"3F\"])\n    face_dict[\"top3A\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"7\"], vert_dict[\"3B\"], vert_dict[\"3F\"])\n    face_dict[\"top3B\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"8\"], vert_dict[\"3A\"], vert_dict[\"4F\"])\n    face_dict[\"top4A\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"8\"], vert_dict[\"4B\"], vert_dict[\"4F\"])\n    face_dict[\"top4B\"] = rg.NurbsSurface.CreateFromCorners( vert_dict[\"5\"], vert_dict[\"4A\"], vert_dict[\"1F\"])\n\ncell_faces = {}\naddfaces(cell_faces,cell_points)\nfacelist=[]\nfor face in cell_faces.values():\n    facelist.append(face)\n\n\n\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}