{
  "source_url": "https://github.com/969flash/urban_design_tool/blob/0a891333039b4d06213c16f2d4b6bb12b02f2ad1/src/pedestrian_generator_easy.py",
  "repo": "969flash/urban_design_tool",
  "repo_stars": 0,
  "repo_description": "urban_design_tool",
  "license": "unknown",
  "filepath": "src/pedestrian_generator_easy.py",
  "instruction": "pedestrian_generator main entry for Grasshopper (Rhino 8 / Python 3).",
  "code": "# -*- coding: utf-8 -*-\n\"\"\"pedestrian_generator main entry for Grasshopper (Rhino 8 / Python 3).\n\n본 스크립트는 landuse_calculator의 결과물인 Block을 읽어 보행로영역과 보행로에 들어갈 디테일 요소\n(가로등, 가로수, 보행로가구)를 생성합니다. utils.py의 컨벤션(타입 힌트,\nGoogle 스타일 Docstring, snake_case, geo 별칭)을 따릅니다.\n\n주의:\n- Grasshopper Python 3 컴포넌트에서 실행을 가정합니다.\n\"\"\"\n\nfrom typing import List, Tuple, Optional, Union, Any\nimport math\n\nimport Rhino\nimport Rhino.Geometry as geo\nimport scriptcontext as sc\nimport ghpythonlib.components as ghcomp\nimport System\n\n# constants.py의 모든 상수 임포트 (단일 소스 관리)\nimport constants as CONST  # use module reference for reloading and direct access\nimport importlib\n\ntry:\n    # Reload to pick up edits during GH iterations\n    CONST = importlib.reload(CONST)\nexcept Exception:\n    # Safe to proceed with whatever was already loaded\n    pass\n\n# 프로젝트 유틸 전부 임포트\nfrom utils import *  # noqa: F401,F403\n\n# from landuse_calculator import Block\n\n\n# =============================\n# GH inputs and driver\n# =============================\ndoc = Rhino.RhinoDoc.ActiveDoc\n\n# Grasshopper inputs (with defaults)\nRUN = bool(globals().get(\"Run\", False))\nBAKE = bool(globals().get(\"Bake\", False))\nBLOCKS = list(globals().get(\"blocks\", []) or [])  # List[geo.Brep]\nEXCLUDE_LANDUSES = list(globals().get(\"exclude_landuses\", [\"Green\"]) or [\"Green\"])  # type: ignore\n\n# Constants are referenced directly via CONST after reload\n\n\ndef _dprint(*args):\n    try:\n        print(*args)\n    except Exception:\n        pass\n\n\ndef _outer_boundary_from_region(brep):\n    \"\"\"Try to get a single closed outer boundary curve from a planar region Brep.\"\"\"\n    if not isinstance(brep, geo.Brep):\n        return None\n    # Prefer planar face outer loop\n    try:\n        for f in brep.Faces:\n            if f.IsPlanar():\n                crv = f.OuterLoop.To3dCurve()\n                if crv and crv.IsClosed:\n                    return crv\n    except Exception:\n        pass\n    # Fallback: join naked edge curves\n    try:\n        edges = brep.DuplicateNakedEdgeCurves(True, False)\n        joined = geo.Curve.JoinCurves(edges, TOL)\n        if joined:\n            for c in joined:\n                if c and c.IsClosed:\n                    return c\n    except Exception:\n        pass\n    return None\n\n\ndef _planar_of_curve(crv):\n    pl = geo.Plane.WorldXY\n    try:\n        ok, pl = crv.TryGetPlane()\n        if ok:\n            return pl\n    except Exception:\n        pass\n    return pl\n\n\ndef _curve_area(crv):\n    try:\n        mp = geo.AreaMassProperties.Compute(crv)\n        return float(mp.Area) if mp else 0.0\n    except Exception:\n        return 0.0\n\n\ndef _offset_inward(curv, dist):\n    if not curv or dist <= 0:\n        return None\n    pl = _planar_of_curve(curv)\n    tol = getattr(Rhino.RhinoDoc.ActiveDoc, \"ModelAbsoluteTolerance\", TOL)\n    a0 = _curve_area(curv)\n    try:\n        cands = curv.Offset(pl, -abs(dist), tol, geo.CurveOffsetCornerStyle.Sharp)\n        if not cands or len(cands) == 0:\n            cands = curv.Offset(pl, abs(dist), tol, geo.CurveOffsetCornerStyle.Sharp)\n        if not cands:\n            return None\n        # choose candidate with smallest area relative to original (inner)\n        best = None\n        best_area = None\n        for c in cands:\n            if not c or not c.IsClosed:\n                continue\n            a = _curve_area(c)\n            if a <= 0:\n                continue\n            score = abs(a0 - a)\n            if (best is None) or (score < best_area):\n                best = c\n                best_area = score\n        return best\n    except Exception:\n        return None\n\n\ndef _create_planar_ring(outer_crv, inner_crv):\n    \"\"\"Create a planar donut-shaped Brep between outer and inner (hole).\"\"\"\n    if not outer_crv or not inner_crv:\n        return None\n    tol = getattr(Rhino.RhinoDoc.ActiveDoc, \"ModelAbsoluteTolerance\", TOL)\n    crvs = [outer_crv.DuplicateCurve(), inner_crv.DuplicateCurve()]\n    try:\n        breps = geo.Brep.CreatePlanarBreps(crvs, tol)\n        if breps and len(breps) > 0:\n            # CreatePlanarBreps may produce two surfaces; prefer one with hole\n            # Pick the one with area close to outer - inner\n            tgt_area = max(0.0, _curve_area(outer_crv) - _curve_area(inner_crv))\n            best = None\n            best_delta = None\n            for b in breps:\n                try:\n                    mp = geo.AreaMassProperties.Compute(b)\n                    if not mp:\n                        continue\n                    delta = abs(mp.Area - tgt_area)\n                    if best is None or delta < best_delta:\n                        best = b\n                        best_delta = delta\n                except Exception:\n                    pass\n            return best\n    except Exception:\n        pass\n    # Fallback: boolean difference of regions\n    try:\n        outer_b = geo.Brep.CreatePlanarBreps([outer_crv], tol)\n        inner_b = geo.Brep.CreatePlanarBreps([inner_crv], tol)\n        if outer_b and inner_b:\n            diff = geo.Brep.CreateBooleanDifference(outer_b[0], inner_b[0], tol)\n            if diff and len(diff) > 0:\n                return diff[0]\n    except Exception:\n        pass\n    return None\n\n\ndef _make_box_brep(width, depth, height):\n    \"\"\"Make a box Brep centered in X/Y and starting at Z=0 (bottom at 0).\"\"\"\n    try:\n        x = float(width)\n        y = float(depth)\n        z = float(height)\n        base = geo.Plane.WorldXY\n        x_interval = Rhino.Geometry.Interval(-x * 0.5, x * 0.5)\n        y_interval = Rhino.Geometry.Interval(-y * 0.5, y * 0.5)\n        z_interval = Rhino.Geometry.Interval(0.0, z)\n        box = geo.Box(base, x_interval, y_interval, z_interval)\n        return box.ToBrep()\n    except Exception:\n        return None\n\n\ndef _ensure_block_def(doc, name, size_tuple):\n    \"\"\"Ensure a block (instance definition) exists, or create from box size.\n\n    Base point is (0,0,0) which is bottom center of the box.\n    \"\"\"\n    idefs = doc.InstanceDefinitions\n    existing = idefs.Find(name, True)\n    # If definition exists, return its index\n    try:\n        if existing is not None and getattr(existing, \"Index\", -1) >= 0:\n            return int(existing.Index)\n    except Exception:\n        pass\n    geom = []\n    attr = []\n    # Create box brep\n    box = _make_box_brep(*size_tuple)\n    if box:\n        geom.append(box)\n        attr.append(Rhino.DocObjects.ObjectAttributes())\n    base_pt = geo.Point3d(0, 0, 0)\n    try:\n        new_idx = idefs.Add(name, \"auto-generated block\", base_pt, geom, attr)\n        if new_idx is None:\n            return -1\n        return int(new_idx)\n    except Exception:\n        return -1\n\n\ndef _plane_on_curve(crv, t):\n    # Use curve tangent for X axis and World Z as up\n    try:\n        pt = crv.PointAt(t)\n        tan = crv.TangentAt(t)\n        xaxis = tan\n        zaxis = geo.Vector3d(0, 0, 1)\n        # handle degenerate\n        if xaxis.IsZero:\n            xaxis = geo.Vector3d(1, 0, 0)\n        yaxis = geo.Vector3d.CrossProduct(zaxis, xaxis)\n        if yaxis.IsZero:\n            yaxis = geo.Vector3d(0, 1, 0)\n        plane = geo.Plane(pt, xaxis, yaxis)\n        return plane\n    except Exception:\n        return geo.Plane.WorldXY\n\n\ndef _place_instances(doc, def_name, size_tuple, rail_crv, gap, layer_fullpath):\n    \"\"\"Place block instances along rail curve at regular gap.\n\n    Returns list of created object ids (System.Guid)\n    \"\"\"\n    ids = []\n    if rail_crv is None:\n        return ids\n    def_index = _ensure_block_def(doc, def_name, size_tuple)\n    if not isinstance(def_index, int) or def_index < 0:\n        return ids\n\n    # ensure layer\n    try:\n        # ensure top-level parent \"Pedestrian\" exists implicitly via split\n        parts = layer_fullpath.split(\"::\")\n        parent_id = None\n        for i, part in enumerate(parts):\n            lyr = (\n                ensure_layer(doc, part, parent_id=parent_id)\n                if i > 0\n                else ensure_layer(doc, part)\n            )\n            parent_id = lyr.Id if lyr else parent_id\n        target_layer = find_layer_by_fullpath(doc, layer_fullpath)\n    except Exception:\n        target_layer = None\n\n    attr = Rhino.DocObjects.ObjectAttributes()\n    if target_layer:\n        attr.LayerIndex = target_layer.Index\n\n    # place points along curve\n    length = rail_crv.GetLength()\n    if length <= 0 or gap <= 0:\n        return ids\n    n = int(math.floor(length / gap)) + 1\n    for i in range(n):\n        s = min(i * gap, length)\n        ok, t = rail_crv.LengthParameter(s)\n        if not ok:\n            t = rail_crv.Domain.ParameterAt(min(1.0, max(0.0, s / length)))\n        plane = _plane_on_curve(rail_crv, t)\n        xform = Rhino.Geometry.Transform.PlaneToPlane(geo.Plane.WorldXY, plane)\n        try:\n            obj_id = doc.Objects.AddInstanceObject(def_index, xform)\n            if obj_id and target_layer:\n                try:\n                    obj = doc.Objects.FindId(obj_id)\n                    if obj:\n                        obj.Attributes.LayerIndex = target_layer.Index\n                        doc.Objects.ModifyAttributes(obj, obj.Attributes, True)\n                except Exception:\n                    pass\n            if obj_id:\n                ids.append(obj_id)\n        except Exception:\n            pass\n    return ids\n\n\nif not RUN:\n    raise Exception(\"Run이 False입니다. 실행하려면 True로 설정하세요.\")\n\n# Output containers for GH preview\nwalkways = []  # List[Brep]\ntree_ids = []  # List[Guid]\nlight_ids = []\nfurniture_ids = []\n\n\nfor blk in BLOCKS:\n    try:\n        region_brep = blk\n        if not isinstance(region_brep, geo.Brep):\n            continue\n        outer = _outer_boundary_from_region(region_brep)\n        if not outer:\n            continue\n        inner = _offset_inward(outer, CONST.PEDESTRIAN_DEPTH)\n        if inner:\n            ring = _create_planar_ring(outer, inner)\n            if ring:\n                walkways.append(ring)\n\n        # Rails for placements (use offsets from outer boundary inward)\n        # Fallback: if offset fails, use inner curve if available, else outer\n        def _rail(outer_crv, dist, inner_crv=None):\n            r = _offset_inward(outer_crv, dist)\n            if r is None and inner_crv is not None:\n                r = inner_crv\n            if r is None:\n                r = outer_crv\n            return r\n\n        tree_rail = _rail(outer, CONST.TREE_OFFSET, inner)\n        light_rail = _rail(outer, CONST.LIGHT_OFFSET, inner)\n        furn_rail = _rail(outer, CONST.FURNITURE_OFFSET, inner)\n\n        if BAKE:\n            # Bake this block's walkway ring\n            if \"ring\" in locals() and ring:\n                lyr = ensure_layer(doc, CONST.LAYER_PEDESTRIAN_WALKWAY)\n                attrs = Rhino.DocObjects.ObjectAttributes()\n                if lyr:\n                    attrs.LayerIndex = lyr.Index\n                try:\n                    doc.Objects.AddBrep(ring, attrs)\n                except Exception:\n                    pass\n\n            # Trees / Lights / Furniture as block instances\n            tree_ids.extend(\n                _place_instances(\n                    doc,\n                    def_name=\"Tree_Block\",\n                    size_tuple=CONST.TREE_BOX_SIZE,\n                    rail_crv=tree_rail,\n                    gap=CONST.TREE_GAP,\n                    layer_fullpath=CONST.LAYER_PEDESTRIAN_TREES,\n                )\n            )\n            light_ids.extend(\n                _place_instances(\n                    doc,\n                    def_name=\"Light_Block\",\n                    size_tuple=CONST.LIGHT_BOX_SIZE,\n                    rail_crv=light_rail,\n                    gap=CONST.LIGHT_GAP,\n                    layer_fullpath=CONST.LAYER_PEDESTRIAN_LIGHTS,\n                )\n            )\n            furniture_ids.extend(\n                _place_instances(\n                    doc,\n                    def_name=\"Furniture_Block\",\n                    size_tuple=CONST.FURNITURE_BOX_SIZE,\n                    rail_crv=furn_rail,\n                    gap=CONST.FURNITURE_GAP,\n                    layer_fullpath=CONST.LAYER_PEDESTRIAN_FURNITURE,\n                )\n            )\n    except Exception as e:\n        _dprint(\"Block failed:\", blk, e)\n\ntry:\n    if BAKE:\n        doc.Views.Redraw()\nexcept Exception:\n    pass\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": true
}