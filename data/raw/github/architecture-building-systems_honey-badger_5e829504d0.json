{
  "source_url": "https://github.com/architecture-building-systems/honey-badger/blob/c59d21e7836616785492ac82cef6d8f5ae6f7b0a/honey-badger.py",
  "repo": "architecture-building-systems/honey-badger",
  "repo_stars": 8,
  "repo_description": "honey-badger is a build system for Python based Rhino/Grasshopper plugins",
  "license": "MIT",
  "filepath": "honey-badger.py",
  "instruction": "honey-badger - a build system for Rhino/Grasshopper components written in Python.",
  "code": "\"\"\"\nhoney-badger - a build system for Rhino/Grasshopper components written in Python.\n\nUSAGE:\n------\n\nhoney-badger [-e] [-i] [-v RHINO_VERSION] [-s] [-f BADGERFILE]\n\n    reads in the BADGERFILE (defaults to \"honey-badger.json\" in the current directory) and\n    compiles it into a single *.ghpy file containing the classes necessary.\n\n    The -e switch makes the tool editable - the python files are not included in the *.ghpy file, instead, the\n    component will source it on each run from disk (using reload()). Use this only for developer purposes as the\n    path to the scripts are hard-coded into the *.ghpy file.\n\n    The -i switch installs the honey-badger kit after building to the user's Grasshopper Library folder.\n    \n    The -v parameter defines the Rhino version to find / add RhinoCommon and Grasshopper DLLs from.\n    \n    The -s switch skips a compatibility check to see that IronPython version matches the Rhino version desired (note: Rhino plugins are, for now, forward but not backward compatible!)\n\"\"\"\n\nimport sys\nimport os\nimport platform\nimport clr\nimport json\nimport argparse\nimport string\nimport shutil\nimport traceback\n\nclr.AddReference(\"System\")\nclr.AddReference(\"System.IO\")\nimport System\nimport System.IO\n\nimport parameter_compiler\n\ndef main(badger_file, editable, install, rhino_version, skip_compatibility_check):\n    \n    if not skip_compatibility_check:\n        # Asserts rhino version is installed and compatible with IronPython used.\n        \n        rhino_to_ipy_version = {\n            '6': ['2.7.8'],\n            '7': ['2.7.8', '2.7.9']\n        }\n        \n        ipy_version_actual = '{}.{}.{}'.format(sys.version_info.major, sys.version_info.minor, sys.version_info.micro)\n        ipy_version_allowed = rhino_to_ipy_version[rhino_version]\n        # Checks that IronPython is being used\n        assert platform.python_implementation() == 'IronPython', \"You need to use IronPython to badger your components. Currently using {}\".format(platform.python_implementation())\n        assert ipy_version_actual in ipy_version_allowed, \\\n            \"IronPython version does not match for Rhino {rhino_version}. Must be {version_target} but was {version_actual}\".format(\n                rhino_version=rhino_version,\n                version_target=' or '.join(ipy_version_allowed),\n                version_actual=ipy_version_actual\n                )\n        \n        assert os.path.exists(\n            os.path.join(os.path.expandvars(\"${PROGRAMFILES}\"),\n                         \"Rhino {v}\".format(v=rhino_version),\n                         \"Plug-ins\", \"Grasshopper\", \"Grasshopper.dll\")), \\\n            \"Could not find Grasshopper.dll. Is Rhino {v} installed?\".format(v=rhino_version)\n        \n        assert os.path.exists(\n            os.path.join(os.path.expandvars(\"${PROGRAMFILES}\"),\n                         \"Rhino {v}\".format(v=rhino_version),\n                         \"System\", \"RhinoCommon.dll\")), \\\n            \"Could not find RhinoCommon.dll. Is Rhino {v} installed?\".format(v=rhino_version)\n    \n    parameter_compiler.setup(rhino_version)\n    \n    try:\n        # temporary create the helloworld dll adding the honey-badger.json to it\n        with open(badger_file, mode='r') as bf:\n            badger_file_contents = bf.read()\n            badger_config = json.loads(badger_file_contents)\n\n        badger_dir = os.path.abspath(os.path.dirname(badger_file))\n        build_dir = os.path.join(badger_dir, '_build')\n        if not os.path.exists(build_dir):\n            os.makedirs(build_dir)\n\n        badger_config = check_badger_config(badger_config, badger_dir)\n\n        template = string.Template(TEMPLATE)\n        guid = badger_config[\"id\"].replace('-', '_')\n        hb_main_py = 'honey_badger_{guid}.py'.format(guid=guid)\n        with open(os.path.join(build_dir, hb_main_py), 'w') as hb_main:\n            json_badger_config = json.dumps(badger_config, indent=4)\n            assert not \"'''\" in json_badger_config, \"Tripple single quotes not allowed in badger-file!\"\n            json_badger_config = json_badger_config.replace(\"\\\\\", \"\\\\\\\\\")  # make sure we escape backslashes\n            hb_main.write(template.substitute(badger_config=json_badger_config, guid=guid))\n\n        # copy hblib.py to build dir\n        src_hblib_py = os.path.join(os.path.dirname(os.path.normpath(os.path.abspath(__file__))), 'hblib.py')\n        dst_hblib_py = os.path.join(build_dir, \"hblib_{guid}.py\".format(guid=guid))\n        # print(\"Copying hblib.py from {src} to {dst}\".format(src=src_hblib_py, dst=dst_hblib_py))\n        shutil.copy(src_hblib_py, dst_hblib_py)\n\n        # compile to .ghpy file\n        ghpy_path = os.path.join(build_dir, \"{}.ghpy\".format(badger_config['name']))\n        clr.CompileModules(ghpy_path,\n                           os.path.join(build_dir, hb_main_py),\n                           dst_hblib_py,\n                           *[os.path.join(badger_dir, f) for f in badger_config['include-files']])\n\n        gha_path = os.path.join(build_dir, \"{}.gha\".format(badger_config['name']))\n        if \"parameters\" in badger_config:\n            parameter_compiler.compile_parameters(\n                badger_config, badger_dir, os.path.join(build_dir, gha_path))\n\n        if install:\n            destination = os.path.join(os.path.expandvars(\"${APPDATA}\"), \"Grasshopper\", \"Libraries\")\n            print('installing {ghpy_name} to {destination}'.format(\n                ghpy_name=os.path.basename(ghpy_path), destination=destination))\n            shutil.copy(ghpy_path, destination)\n\n            if \"parameters\" in badger_config:\n                print(\"installing {gha_name} to {destination}\".format(\n                    gha_name=os.path.basename(gha_path), destination=destination))\n                shutil.copy(gha_path, destination)\n                hbrt_path = os.path.join(os.path.dirname(os.path.normpath(os.path.abspath(__file__))),\n                                         \"honey-badger-runtime\", \"bin\", \"honey-badger-runtime.dll\")\n                print(\"installing {hbrt_name} to {destination}\".format(\n                    hbrt_name=os.path.basename(hbrt_path), destination=destination))\n                shutil.copy(hbrt_path, destination)\n\n            # copy additional files (from \"include-install\")\n            for file_name in badger_config[\"include-install\"]:\n                if os.path.isabs(file_name):\n                    file_path = file_name\n                else:\n                    # relative paths are relative to the folder containing the badger-file\n                    file_path = os.path.join(badger_dir, file_name)\n                assert os.path.exists(file_path), \"Could not locate file: {}\".format(file_path)\n                print(\"copying {file_path} to {destination}\".format(**locals()))\n                shutil.copy(file_path, destination)\n\n        print('done.')\n    except:\n        print traceback.print_exc()\n\n\ndef check_badger_config(badger_config, badger_dir):\n    \"\"\"\n    Make sure the badger file contains all the required info. Fill in default values if they don't exist yet.\n\n    nick-names and defaults for inputs/outputs are added automatically.\n\n    FIXME: this could also be done with some kind of json schema thing. For now, this provides enough info.\n    \"\"\"\n    assert \"name\" in badger_config, \"Badger file needs a name\"\n    assert \"description\" in badger_config, \"Badger file needs a description\"\n    assert \"version\" in badger_config, \"Badger file needs a version\"\n    assert \"author\" in badger_config, \"Badger file needs an author\"\n    assert \"id\" in badger_config, \"Badger file needs an id\"\n    assert \"include-files\" in badger_config, \"Badger file needs to specify include-files\"\n    if not \"include-install\" in badger_config:\n        badger_config[\"include-install\"] = []\n    assert \"components\" in badger_config, \"Badger file needs to specify at least one component\"\n    for component in badger_config[\"components\"]:\n        assert \"class-name\" in component, \"Component needs a class name\"\n        assert \"name\" in component, \"Component needs a name\"\n        assert \"abbreviation\" in component, \"Component needs an abbreviation\"\n        assert \"description\" in component, \"Component needs a description\"\n        assert \"category\" in component, \"Component needs a category\"\n        assert \"subcategory\" in component, \"Component needs a subcategory\"\n        assert \"id\" in component, \"Component needs an id\"\n        assert \"main-module\" in component, \"Component needs a main-module\"\n        assert \"inputs\" in component, \"Component needs inputs\"\n        assert \"outputs\" in component, \"Component needs outputs\"\n        for input in component[\"inputs\"]:\n            assert \"type\" in input, \"Input needs a type\"\n            assert \"name\" in input, \"Input needs a name\"\n            assert \"description\" in input, \"Input needs a description\"\n            if not \"nick-name\" in input:\n                input[\"nick-name\"] = input[\"name\"]\n            if not \"default\" in input:\n                input[\"default\"] = None\n            if not \"access\" in input:\n                input[\"access\"] = \"item\"\n            assert input[\"access\"] in {\"item\", \"list\", \"tree\"}, \"Input Access needs to be either 'item', 'list' or 'tree'\"\n        for output in component[\"outputs\"]:\n            assert \"type\" in output, \"Input needs a type\"\n            assert \"name\" in output, \"Input needs a name\"\n            assert \"description\" in output, \"Input needs a description\"\n            if not \"nick-name\" in output:\n                output[\"nick-name\"] = output[\"name\"]\n        if \"icon\" in component:\n            # convert icon (a path) to a base64 string\n            icon_path = os.path.join(badger_dir, component[\"icon\"])\n            assert os.path.exists(icon_path), \"Could not find icon file: {}\".format(icon_path)\n            bytes = System.IO.File.ReadAllBytes(icon_path)\n            icon_base64 = System.Convert.ToBase64String(bytes)\n            component[\"icon\"] = icon_base64\n    return badger_config\n\n\n# This is the code that gets used to create the classes required for GrassHopper Components / Assemblies\nTEMPLATE = u\"\"\"\nimport json\nimport GhPython\nimport System\nimport hblib_${guid} as hblib\nimport Grasshopper\n\nBADGER_CONFIG = json.loads('''${badger_config}''')\n\nfor component in BADGER_CONFIG['components']:\n    # dynamically create subclasses of ``component`` for each component in the badger file\n    globals()[component['class-name']] = type(component['class-name'], (hblib.get_base_class(component),), {})\n\n\nclass AssemblyInfo(GhPython.Assemblies.PythonAssemblyInfo):\n    def get_AssemblyName(self):\n        return BADGER_CONFIG['name']\n\n    def get_AssemblyDescription(self):\n        return BADGER_CONFIG['description']\n\n    def get_AssemblyVersion(self):\n        return BADGER_CONFIG['version']\n\n    def get_AuthorName(self):\n        return BADGER_CONFIG['author']\n\n    def get_Id(self):\n        return System.Guid(BADGER_CONFIG['id'])\n\n\"\"\"\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description=\"honey-badger - make for .ghpy\")\n    parser.add_argument('-e', '--editable', action=\"store_true\", default=False)\n    parser.add_argument('-i', '--install', action=\"store_true\", default=False)\n    parser.add_argument('-v', '--rhino-version', choices=['6','7'], default='6', help='Specifies which Rhino SDK version to badger to (only 6 or 7 supported)')\n    parser.add_argument('-s', '--skip-compatibility-check', action='store_true', default=False, help='Skips checking IronPython and Rhino compatibility.')\n    parser.add_argument('file', action=\"store\")\n    args = parser.parse_args(sys.argv[1:])\n    main(badger_file=args.file, \n         editable=args.editable, \n         install=args.install, \n         rhino_version=args.rhino_version,\n         skip_compatibility_check=args.skip_compatibility_check)\n",
  "language": "python",
  "imports": [
    "RhinoCommon"
  ],
  "has_docstring": true
}