{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Crv_createArcLineArcBlend.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Crv_createArcLineArcBlend.py",
  "instruction": "https://mcneel.myjetbrains.com/youtrack/issue/RH-64854\r\n\r\nPer https://developer.rhino3d.com/api/RhinoCommon/html/M_Rhino_Geometry_Curve_CreateArcLineArcBlend.htm :\r\n\r\nCreateArcLineArcBlend(...)\r\n    ...",
  "code": "\"\"\"\r\nhttps://mcneel.myjetbrains.com/youtrack/issue/RH-64854\r\n\r\nPer https://developer.rhino3d.com/api/RhinoCommon/html/M_Rhino_Geometry_Curve_CreateArcLineArcBlend.htm :\r\n\r\nCreateArcLineArcBlend(...)\r\n        CreateArcLineArcBlend(startPt: Point3d, startDir: Vector3d, endPt: Point3d, endDir: Vector3d, radius: float) -> Curve\r\n        \r\n            Creates an arc-line-arc blend curve between two curves.\r\n                    The output \r\n             is generally a PolyCurve with three segments: arc, line, arc.\r\n                    In \r\n             some cases, one or more of those segments will be absent because they would \r\n             have 0 length. \r\n                    If there is only a single segment, the result will \r\n             either be an ArcCurve or a LineCurve.\r\n        \r\n        \r\n            startPt: Start of the blend curve.\r\n            startDir: Start direction of the blend curve.\r\n            endPt: End of the blend curve.\r\n            endDir: End direction of the arc blend curve.\r\n            radius: The radius of the arc segments.\r\n            Returns: The blend curve if successful, false otherwise.\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, print_function, unicode_literals\r\n\r\n\"\"\"\r\n220121: Created.\r\n220201: Bug fix.\r\n220501: Cleaned.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Opts():\r\n    \r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fRadius'; keys.append(key)\r\n    values[key] = 1.0\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fRadius':\r\n            if cls.riOpts[key].CurrentValue < 2.0*sc.doc.ModelAbsoluteTolerance:\r\n                cls.riOpts[key].CurrentValue = 0.0\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get curves with optional input.\r\n    \"\"\"\r\n    \r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select first curve near end\")\r\n\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\r\n\r\n    go.DisablePreSelect()\r\n    go.OneByOnePostSelect = True\r\n\r\n    idxs_Opts = {}\r\n\r\n    def addOption(key): idxs_Opts[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opts.clear()\r\n\r\n        addOption('fRadius')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=2, maximumNumber=2)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fRadius'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n\r\n        for key in idxs_Opts:\r\n            if go.Option().Index == idxs_Opts[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef createCurve(rgCrv_A, rgCrv_B, bT1WorkEnd_A, bT1WorkEnd_B, fRadius, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    Returns:\r\n        Single PolyCurve on success.\r\n        None on fail.\r\n    \"\"\"\r\n\r\n    rgC_A = rgCrv_A\r\n    rgC_B = rgCrv_B\r\n\r\n    t_WorkEnd_A = rgCrv_A.Domain.T1 if bT1WorkEnd_A else rgCrv_A.Domain.T0\r\n    t_WorkEnd_B = rgCrv_B.Domain.T1 if bT1WorkEnd_B else rgCrv_B.Domain.T0\r\n\r\n\r\n    ptA = rgC_A.PointAt(t_WorkEnd_A)\r\n    ptB = rgC_B.PointAt(t_WorkEnd_B)\r\n\r\n\r\n    def doCurveEndsMeet():\r\n        dist = ptA.DistanceTo(ptB)\r\n        if dist < 100.0 * sc.doc.ModelAbsoluteTolerance:\r\n            return True\r\n        return False\r\n\r\n    if doCurveEndsMeet():\r\n        if bEcho:\r\n            print(\"Ends are too close to one another for a meaningful result.\"\r\n                  \"Script canceled.\")\r\n        return\r\n\r\n\r\n    dirA = rgCrv_A.TangentAt(t_WorkEnd_A)\r\n    dirB = rgCrv_B.TangentAt(t_WorkEnd_B)\r\n\r\n    if not bT1WorkEnd_A: dirA = -dirA \r\n    if bT1WorkEnd_B: dirB = -dirB \r\n\r\n\r\n    ####\r\n\r\n    return rg.Curve.CreateArcLineArcBlend(\r\n        startPt=ptA,\r\n        startDir=dirA,\r\n        endPt=ptB,\r\n        endDir=dirB,\r\n        radius=fRadius)\r\n\r\n    ####\r\n\r\n\r\ndef createCurveObject(objrefA, objrefB, fRadius, bEcho=True, bDebug=False):\r\n\r\n    rgC_A = objrefA.Curve()\r\n\r\n    bSuccess, tA = rgC_A.ClosestPoint(objrefA.SelectionPoint())\r\n    if not bSuccess:\r\n        rgC_A.Dispose()\r\n        return\r\n\r\n\r\n    rgC_B = objrefB.Curve()\r\n    bSuccess, tB = rgC_B.ClosestPoint(objrefB.SelectionPoint())\r\n    if not bSuccess:\r\n        rgC_A.Dispose()\r\n        rgC_B.Dispose()\r\n        return\r\n\r\n    bT1WorkEnd_A = tA > rgC_A.Domain.Mid\r\n    bT1WorkEnd_B = tB > rgC_B.Domain.Mid\r\n\r\n    rc = createCurve(\r\n            rgCrv_A=rgC_A,\r\n            rgCrv_B=rgC_B,\r\n            bT1WorkEnd_A=bT1WorkEnd_A,\r\n            bT1WorkEnd_B=bT1WorkEnd_B,\r\n            fRadius=fRadius,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug,\r\n    )\r\n    if rc is None:\r\n        print(\"Curve was not created.\")\r\n        return\r\n\r\n    rgC_Res = rc\r\n\r\n    gCrv_Out = sc.doc.Objects.AddCurve(rgC_Res)\r\n    if gCrv_Out == gCrv_Out.Empty:\r\n        if bEcho:\r\n            print(\"Curve could not be added.\")\r\n        return\r\n\r\n    if bEcho: print(\"{} was added.\".format(rgC_Res.GetType().Name))\r\n    sc.doc.Views.Redraw()\r\n\r\n    return gCrv_Out\r\n\r\n\r\ndef main():\r\n    \r\n    rc = getInput()\r\n    if rc is None: return\r\n    objrefA, objrefB = rc\r\n\r\n    fRadius = Opts.values['fRadius']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    createCurveObject(\r\n        objrefA,\r\n        objrefB,\r\n        fRadius=fRadius,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": true
}