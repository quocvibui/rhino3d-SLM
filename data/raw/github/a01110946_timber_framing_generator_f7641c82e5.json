{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/src/timber_framing_generator/framing_elements/trimmers.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "src/timber_framing_generator/framing_elements/trimmers.py",
  "instruction": "File: timber_framing_generator/framing_elements/trimmers.py",
  "code": "# File: timber_framing_generator/framing_elements/trimmers.py\n\nfrom typing import Dict, List, Any, Tuple, Optional\nimport Rhino.Geometry as rg\nfrom src.timber_framing_generator.utils.safe_rhino import safe_get_length, safe_create_extrusion\nfrom src.timber_framing_generator.config.framing import FRAMING_PARAMS, get_framing_param\n\n# Import our custom logging module\nfrom ..utils.logging_config import get_logger\n\n# Initialize logger for this module\nlogger = get_logger(__name__)\n\n\nclass TrimmerGenerator:\n    \"\"\"\n    Generates trimmer studs for wall openings.\n\n    Trimmer studs are vertical framing members placed directly alongside door and\n    window openings. They support the header above the opening and transfer loads\n    from the header to the bottom plate. Trimmers typically run from the bottom plate\n    to the underside of the header, working in tandem with king studs that run the\n    full height of the wall.\n    \"\"\"\n\n    def __init__(self, wall_data: Dict[str, Any]):\n        \"\"\"\n        Initialize the trimmer generator with wall data.\n\n        Args:\n            wall_data: Dictionary containing wall information including:\n                - base_plane: Reference plane for wall coordinate system\n                - wall_base_elevation: Base elevation of the wall\n                - wall_top_elevation: Top elevation of the wall\n        \"\"\"\n        logger.debug(\"Initializing TrimmerGenerator\")\n        logger.debug(f\"Wall data: {wall_data}\")\n        \n        # Store the wall data for use throughout the generation process\n        self.wall_data = wall_data\n\n        # Initialize storage for debug geometry\n        self.debug_geometry = {\"points\": [], \"planes\": [], \"profiles\": [], \"paths\": []}\n        logger.debug(\"TrimmerGenerator initialized successfully\")\n\n    def generate_trimmers(\n        self,\n        opening_data: Dict[str, Any],\n        plate_data: Dict[str, float],\n        header_bottom_elevation: Optional[float] = None,\n    ) -> List[rg.Brep]:\n        \"\"\"\n        Generate trimmer studs for a wall opening.\n\n        This method creates a pair of trimmer studs at the sides of an opening.\n        Trimmers run from the bottom plate to the underside of the header,\n        providing support for the header and transferring loads around the opening.\n\n        Args:\n            opening_data: Dictionary with opening information including:\n                - start_u_coordinate: Position along wall where opening starts\n                - rough_width: Width of the rough opening\n                - base_elevation_relative_to_wall_base: Height from wall base to opening bottom\n            plate_data: Dictionary containing plate boundary data from get_boundary_data()\n            header_bottom_elevation: Optional elevation for the bottom of the header\n                If not provided, calculated from opening height\n\n        Returns:\n            List of trimmer stud Brep geometries (typically two - left and right)\n        \"\"\"\n        logger.debug(\"Generating trimmer studs for wall opening\")\n        logger.debug(f\"Opening data: {opening_data}\")\n        logger.debug(f\"Plate data: {plate_data}\")\n        logger.debug(f\"Header bottom elevation: {header_bottom_elevation}\")\n        \n        try:\n            # Extract opening information\n            opening_u_start = opening_data.get(\"start_u_coordinate\")\n            opening_width = opening_data.get(\"rough_width\")\n            opening_height = opening_data.get(\"rough_height\")\n            opening_v_start = opening_data.get(\"base_elevation_relative_to_wall_base\")\n\n            logger.debug(f\"Opening parameters - u_start: {opening_u_start}, width: {opening_width}, height: {opening_height}, v_start: {opening_v_start}\")\n\n            if None in (\n                opening_u_start,\n                opening_width,\n                opening_height,\n                opening_v_start,\n            ):\n                logger.warning(\"Missing required opening data for trimmer generation\")\n                return []\n\n            # Get essential wall parameters\n            base_plane = self.wall_data.get(\"base_plane\")\n\n            # Get bottom elevation from plate boundary data\n            # BUG FIX: Convert from absolute Z to relative (above base plane origin)\n            # boundary_elevation is absolute, but PointAt/Add adds it to origin.Z\n            base_z = base_plane.Origin.Z if base_plane else 0.0\n            bottom_elevation_absolute = plate_data.get(\"boundary_elevation\", 0.0)\n            bottom_elevation = bottom_elevation_absolute - base_z\n            logger.debug(f\"Using bottom plate elevation: {bottom_elevation} (relative), absolute was {bottom_elevation_absolute}\")\n\n            if base_plane is None:\n                logger.warning(\"No base plane available for trimmer generation\")\n                return []\n\n            # Calculate trimmer dimensions from framing parameters\n            # Uses wall_data config if available (for material-specific dimensions)\n            trimmer_width = get_framing_param(\n                \"trimmer_width\", self.wall_data, 1.5 / 12\n            )  # Typically 1.5 inches for timber\n            trimmer_depth = get_framing_param(\n                \"trimmer_depth\", self.wall_data, 3.5 / 12\n            )  # Typically 3.5 inches for timber\n            \n            logger.debug(f\"Trimmer dimensions - width: {trimmer_width}, depth: {trimmer_depth}\")\n\n            # Calculate header bottom elevation if not provided\n            opening_v_end = opening_v_start + opening_height\n            header_bottom = (\n                header_bottom_elevation\n                if header_bottom_elevation is not None\n                else opening_v_end\n            )\n            logger.debug(f\"Calculated header bottom elevation: {header_bottom}\")\n\n            # Calculate trimmer vertical extent\n            bottom_v = bottom_elevation  # Start at bottom plate\n            top_v = header_bottom  # End at underside of header\n            logger.debug(f\"Trimmer vertical extent - bottom: {bottom_v}, top: {top_v}\")\n\n            # Calculate horizontal positions with offset from opening edges\n            # Typically trimmers are centered at the rough opening edges\n            trimmer_offset = trimmer_width / 2  # Center the trimmer at the opening edge\n\n            # Calculate actual u-coordinates for left and right trimmers\n            u_left = opening_u_start - trimmer_offset\n            u_right = opening_u_start + opening_width + trimmer_offset\n            \n            logger.debug(f\"Trimmer horizontal positions - left: {u_left}, right: {u_right}\")\n\n            # Store trimmer studs\n            trimmer_studs = []\n\n            # Generate both left and right trimmers\n            for u_position in [u_left, u_right]:\n                logger.debug(f\"Creating trimmer at u-coordinate: {u_position}\")\n                try:\n                    # Create the trimmer stud\n                    trimmer = self._create_trimmer_geometry(\n                        base_plane,\n                        u_position,\n                        bottom_v,\n                        top_v,\n                        trimmer_width,\n                        trimmer_depth,\n                    )\n\n                    if trimmer is not None:\n                        trimmer_studs.append(trimmer)\n                        logger.debug(f\"Successfully created trimmer at u={u_position}\")\n                    else:\n                        logger.warning(f\"Failed to create trimmer at u={u_position}\")\n                except Exception as e:\n                    logger.error(f\"Error creating trimmer at u={u_position}: {str(e)}\")\n\n            logger.debug(f\"Generated {len(trimmer_studs)} trimmer studs\")\n            return trimmer_studs\n\n        except Exception as e:\n            logger.error(f\"Error generating trimmers: {str(e)}\")\n            import traceback\n            logger.error(traceback.format_exc())\n            return []\n\n    def _create_trimmer_geometry(\n        self,\n        base_plane: rg.Plane,\n        u_coordinate: float,\n        bottom_v: float,\n        top_v: float,\n        width: float,\n        depth: float,\n    ) -> Optional[rg.Brep]:\n        \"\"\"\n        Create the geometry for a single trimmer stud.\n\n        This method creates a trimmer stud by:\n        1. Creating start and end points in the wall's coordinate system\n        2. Creating a profile perpendicular to the stud's centerline\n        3. Extruding the profile along the centerline\n\n        Args:\n            base_plane: Wall's base plane for coordinate system\n            u_coordinate: Position along wall (horizontal)\n            bottom_v: Bottom elevation of trimmer\n            top_v: Top elevation of trimmer\n            width: Width of trimmer (perpendicular to wall face)\n            depth: Depth of trimmer (parallel to wall length)\n\n        Returns:\n            Brep geometry for the trimmer stud, or None if creation fails\n        \"\"\"\n        try:\n            # 1. Create the centerline endpoints in world coordinates\n            start_point = rg.Point3d.Add(\n                base_plane.Origin,\n                rg.Vector3d.Add(\n                    rg.Vector3d.Multiply(base_plane.XAxis, u_coordinate),\n                    rg.Vector3d.Multiply(base_plane.YAxis, bottom_v),\n                ),\n            )\n\n            end_point = rg.Point3d.Add(\n                base_plane.Origin,\n                rg.Vector3d.Add(\n                    rg.Vector3d.Multiply(base_plane.XAxis, u_coordinate),\n                    rg.Vector3d.Multiply(base_plane.YAxis, top_v),\n                ),\n            )\n            self.debug_geometry[\"points\"].extend([start_point, end_point])\n            logger.debug(f\"Created trimmer centerline from {start_point} to {end_point}\")\n\n            # 2. Create a profile plane at the start point\n            # Profile plane is perpendicular to the centerline\n            # X axis goes across wall thickness (for width)\n            profile_x_axis = base_plane.ZAxis\n            # Y axis goes along wall length (for depth)\n            profile_y_axis = base_plane.XAxis\n\n            profile_plane = rg.Plane(start_point, profile_x_axis, profile_y_axis)\n            self.debug_geometry[\"planes\"].append(profile_plane)\n            logger.debug(\"Created profile plane for trimmer cross-section\")\n\n            # 3. Create a rectangle for the profile\n            half_width = width / 2\n            half_depth = depth / 2\n            rect_corners = [\n                rg.Point3d(-half_width, -half_depth, 0),  # lower left\n                rg.Point3d(half_width, -half_depth, 0),   # lower right\n                rg.Point3d(half_width, half_depth, 0),    # upper right\n                rg.Point3d(-half_width, half_depth, 0),   # upper left\n            ]\n            logger.debug(\"Created rectangle corners for trimmer cross-section\")\n\n            # Transform corners to profile plane\n            transform = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, profile_plane)\n            for i, corner in enumerate(rect_corners):\n                corner.Transform(transform)\n                self.debug_geometry[\"points\"].append(corner)\n\n            # Create polygon from corners\n            profile_poly = rg.Polyline([*rect_corners, rect_corners[0]])  # Close the loop\n            profile_curve = profile_poly.ToNurbsCurve()\n            self.debug_geometry[\"profiles\"].append(profile_curve)\n            logger.debug(\"Transformed rectangle to profile plane\")\n\n            # 4. Extrude the profile along the centerline\n            # Calculate direction vector from start to end point\n            direction_vector = rg.Vector3d(end_point - start_point)\n            logger.debug(f\"Extrusion vector: ({direction_vector.X}, {direction_vector.Y}, {direction_vector.Z})\")\n\n            try:\n                # Primary method: extrusion\n                brep = safe_create_extrusion(profile_curve, direction_vector)\n                \n                if brep is not None and hasattr(brep, 'IsValid') and brep.IsValid:\n                    logger.debug(\"Successfully created trimmer Brep using extrusion\")\n                    # Check if we need to convert to Brep\n                    if hasattr(brep, 'ToBrep'):\n                        return brep.ToBrep()\n                    else:\n                        return brep\n                else:\n                    logger.warning(\"Failed to create trimmer Brep from extrusion operation\")\n            except Exception as extrusion_error:\n                logger.warning(f\"Extrusion error: {str(extrusion_error)}\")\n            \n            # Fallback method 1: Try creating a box\n            try:\n                logger.debug(\"Attempting box creation for trimmer\")\n                # Create a box for the trimmer using the dimensions\n                height = safe_get_length(direction_vector)\n                \n                # Handle None or invalid height\n                if height is None or height <= 0:\n                    logger.warning(\"Could not calculate curve length, using default\")\n                    if start_point is not None and end_point is not None:\n                        height = start_point.DistanceTo(end_point)\n                    else:\n                        # Default value as last resort\n                        height = 8.0 / 12.0  # 8 inches in feet\n                        \n                # Ensure we have valid dimensions for the box\n                if half_width is None or half_width <= 0:\n                    half_width = 0.75 / 12.0  # Default 1.5 inches / 2\n                    logger.warning(f\"Invalid half_width, using default: {half_width}\")\n                \n                if half_depth is None or half_depth <= 0:\n                    half_depth = 1.75 / 12.0  # Default 3.5 inches / 2\n                    logger.warning(f\"Invalid half_depth, using default: {half_depth}\")\n                \n                # Create a plane at the start point with proper orientation\n                box_plane = rg.Plane(start_point, profile_x_axis, profile_y_axis)\n                \n                # Create box\n                box = rg.Box(\n                    box_plane,\n                    rg.Interval(-half_width, half_width),\n                    rg.Interval(-half_depth, half_depth),\n                    rg.Interval(0, height)\n                )\n                \n                if box and hasattr(box, 'IsValid') and box.IsValid:\n                    logger.debug(\"Successfully created trimmer using box\")\n                    trimmer_brep = box.ToBrep()\n                    return trimmer_brep\n                else:\n                    logger.warning(\"Box creation error: Invalid box geometry\")\n            except Exception as box_error:\n                logger.warning(f\"Box creation error: {str(box_error)}\")\n            \n            # Fallback method 2: Try creating a sweep\n            try:\n                logger.debug(\"Attempting sweep creation for trimmer\")\n                \n                # Create line for path\n                if start_point is None or end_point is None:\n                    raise ValueError(\"Invalid start or end point for sweep\")\n                    \n                path_line = rg.Line(start_point, end_point)\n                path_curve = path_line.ToNurbsCurve()\n                \n                if path_curve is None:\n                    raise ValueError(\"Failed to create path curve\")\n                \n                # Create new profile\n                new_profile_plane = rg.Plane(start_point, profile_x_axis, profile_y_axis)\n                new_profile = rg.Rectangle3d(\n                    new_profile_plane,\n                    rg.Interval(-half_width, half_width),\n                    rg.Interval(-half_depth, half_depth)\n                )\n                \n                if new_profile is None or not new_profile.IsValid:\n                    raise ValueError(\"Failed to create profile rectangle\")\n                    \n                new_profile_curve = new_profile.ToNurbsCurve()\n                if new_profile_curve is None:\n                    raise ValueError(\"Failed to convert profile to curve\")\n                \n                # Perform sweep\n                sweep = rg.SweepOneRail()\n                sweep.AngleToleranceRadians = 0.1\n                sweep.ClosedSweep = False\n                sweep.SweepTolerance = 0.01\n                \n                breps = sweep.PerformSweep(path_curve, new_profile_curve)\n                \n                if breps and len(breps) > 0 and breps[0].IsValid:\n                    logger.debug(\"Successfully created trimmer using sweep\")\n                    return breps[0]\n                else:\n                    logger.warning(\"Sweep creation error: Failed to create valid sweep\")\n            except Exception as sweep_error:\n                logger.warning(f\"Sweep creation error: {str(sweep_error)}\")\n            \n            # Final fallback method: Create an emergency box at origin and transform\n            try:\n                logger.debug(\"Creating emergency fallback for trimmer\")\n                \n                # Ensure we have valid values for the dimensions\n                emergency_height = 8.0 / 12.0  # 8 inches in feet\n                if start_point is not None and end_point is not None:\n                    emergency_height = start_point.DistanceTo(end_point)\n                    if emergency_height <= 0:\n                        emergency_height = 8.0 / 12.0\n                        \n                emergency_width = 1.5 / 12.0  # 1.5 inches in feet\n                emergency_depth = 3.5 / 12.0  # 3.5 inches in feet\n                \n                # Create box at origin\n                emergency_box = rg.Box(\n                    rg.Plane.WorldXY,\n                    rg.Interval(-emergency_width/2, emergency_width/2),\n                    rg.Interval(-emergency_depth/2, emergency_depth/2),\n                    rg.Interval(0, emergency_height)\n                )\n                \n                # Transform to correct position if we have start point\n                if start_point is not None:\n                    transform = rg.Transform.Translation(\n                        start_point.X,\n                        start_point.Y,\n                        start_point.Z\n                    )\n                    emergency_box.Transform(transform)\n                \n                emergency_brep = emergency_box.ToBrep()\n                if emergency_brep and hasattr(emergency_brep, 'IsValid') and emergency_brep.IsValid:\n                    logger.warning(\"Using emergency fallback geometry for trimmer\")\n                    return emergency_brep\n                else:\n                    logger.error(\"Emergency fallback failed: Invalid emergency box\")\n            except Exception as emergency_error:\n                logger.error(f\"Emergency fallback failed: {str(emergency_error)}\")\n            \n            logger.error(\"All trimmer creation methods failed\")\n            return None\n            \n        except Exception as e:\n            # Main try/except block for the entire function\n            logger.error(f\"Error creating trimmer geometry: {str(e)}\")\n            import traceback\n            logger.error(traceback.format_exc())\n            return None\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}