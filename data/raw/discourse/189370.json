{
  "source_url": "https://discourse.mcneel.com/t/can-anyone-help-to-look-my-c-code-of-simulating-point-descent/189370",
  "topic_id": 189370,
  "title": "Can anyone help to look my C# code of simulating point descent?",
  "question": "I am new to C#, I am trying to simulating drainage path on mesh. but I keep getting same points. There is something wrong in the code. Can any one help me to have a look! Appreciate!\n\n\nimage\n1422Ã—632 90.9 KB\n\n\npublic class Script_Instance : GH_ScriptInstance\n{\n    #region Notes\n    /* \n      Members:\n        RhinoDoc RhinoDocument\n        GH_Document GrasshopperDocument\n        IGH_Component Component\n        int Iteration\n\n      Methods (Virtual & overridable):\n        Print(string text)\n        Print(string format, params object[] args)\n        Reflect(object obj)\n        Reflect(object obj, string method_name)\n    */\n\n    public List<Point3d> pts;\n    public List<GradientDescent> descents;\n\n    public class GradientDescent\n    {\n        // properties\n\n        // Positions\n        // NextDirection\n        public Mesh m {get;set;}\n        public Point3d Pos {get;set;}\n        public Vector3d Dir {get;set; } = new Vector3d(0,0,1);\n        public double MaxSpeed{get;set;} = 50;\n        public List<Point3d> PosList {get;set;} = new List<Point3d>();\n        public int Time {get;set;} = 50;\n\n        private int recursionDepth = 0;\n        \n\n\n        \n\n        \n\n        // --------------------\n        // construcotr\n        public GradientDescent(Mesh myMesh, Point3d position, Vector3d gravityDirection, double maxSpeed, int runTimes)\n        {\n            this.m = myMesh;\n            MeshPoint mp = m.ClosestMeshPoint(position,10);\n            Vector3d mpNormal = m.NormalAt(mp);\n            this.Pos = mp.Point;\n            \n            gravityDirection.Unitize();\n            this.Dir = Vector3d.CrossProduct(gravityDirection, mpNormal);\n            \n            this.MaxSpeed = maxSpeed;\n            this.Time =  runTimes;\n            \n        }\n\n\n        // ---------------------\n        // methods\n\n\n        // Directions of NEXT Movement\n        public Vector3d NextDirection()\n        {\n            this.Dir.Unitize();\n            Vector3d NextDirection = this.Dir * MaxSpeed...",
  "code_blocks": [
    {
      "code": "public class Script_Instance : GH_ScriptInstance\n{\n    #region Notes\n    /* \n      Members:\n        RhinoDoc RhinoDocument\n        GH_Document GrasshopperDocument\n        IGH_Component Component\n        int Iteration\n\n      Methods (Virtual & overridable):\n        Print(string text)\n        Print(string format, params object[] args)\n        Reflect(object obj)\n        Reflect(object obj, string method_name)\n    */\n\n    public List<Point3d> pts;\n    public List<GradientDescent> descents;\n\n    public class GradientDescent\n    {\n        // properties\n\n        // Positions\n        // NextDirection\n        public Mesh m {get;set;}\n        public Point3d Pos {get;set;}\n        public Vector3d Dir {get;set; } = new Vector3d(0,0,1);\n        public double MaxSpeed{get;set;} = 50;\n        public List<Point3d> PosList {get;set;} = new List<Point3d>();\n        public int Time {get;set;} = 50;\n\n        private int recursionDepth = 0;\n        \n\n\n        \n\n        \n\n        // --------------------\n        // construcotr\n        public GradientDescent(Mesh myMesh, Point3d position, Vector3d gravityDirection, double maxSpeed, int runTimes)\n        {\n            this.m = myMesh;\n            MeshPoint mp = m.ClosestMeshPoint(position,10);\n            Vector3d mpNormal = m.NormalAt(mp);\n            this.Pos = mp.Point;\n            \n            gravityDirection.Unitize();\n            this.Dir = Vector3d.CrossProduct(gravityDirection, mpNormal);\n            \n            this.MaxSpeed = maxSpeed;\n            this.Time =  runTimes;\n            \n        }\n\n\n        // ---------------------\n        // methods\n\n\n        // Directions of NEXT Movement\n        public Vector3d NextDirection()\n        {\n            this.Dir.Unitize();\n            Vector3d NextDirection = this.Dir * MaxSpeed;\n            \n            return NextDirection;\n\n\n\n\n        }\n\n        \n\n        // RUN Movement\n        public void Move()\n        {   \n            if (recursionDepth >= this.Time)\n            {\n                return;\n            }\n\n            Point3d posPrev = this.Pos;\n            Vector3d NextDir = NextDirection();\n            Point3d posNext = Point3d.Add(this.Pos, NextDir);\n\n            posNext = m.ClosestMeshPoint(posNext, 10).Point;\n            this.Pos = posNext;\n\n            if (posNext.Z < posPrev.Z && Math.Abs(posPrev.Z - posNext.Z) > (MaxSpeed / 100))\n            {\n                PosList.Add(this.Pos);\n                recursionDepth ++;\n                Move(); // Recursive call to continue moving\n                recursionDepth --;\n            }\n        \n        \n\n        }\n\n\n\n\n    }\n\n\n\n    #endregion\n\n    private void RunScript(\n\tbool iRest,\n\tMesh iMesh,\n\tList<Point3d> iPoints,\n\tVector3d gravityDir,\n\tref object a)\n    {\n        // Initilize Instance\n        // Initialize Instance only if needed\n        if (pts == null || iRest)\n        {\n            pts = new List<Point3d>();\n        }\n\n        if (descents == null || iRest)\n        {\n            descents = new List<GradientDescent>();\n        }\n\n\n\n        //  Initialize Instance\n        // descents = new List<GradientDescent>();\n        // pts = new List<Point3d>(); // Initialize list to store updated points\n        \n        foreach (Point3d pt in iPoints)\n        {   \n            \n            GradientDescent myDescent = new GradientDescent(iMesh,pt, gravityDir, 10,60);\n            \n            descents.Add(myDescent);\n            myDescent.Move();\n            Console.Write($\"Next direction is {myDescent.Dir}\");\n            Console.Write($\"Next direction is {myDescent.NextDirection()}\");\n\n        }\n        \n        foreach (GradientDescent descent in descents)\n        {\n            pts.Add(descent.Pos);\n        }\n     \n        a = pts;\n\n\n        \n        \n        // Collect trail points\n\n        // add polyline\n\n        // colorize the ployline\n        \n    }\n}",
      "language": "csharp",
      "author": "Daxler",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "csharp",
    "geometry",
    "grasshopper",
    "mesh",
    "transformation"
  ],
  "has_accepted_answer": true,
  "category_id": 8,
  "posts_count": 5,
  "views": 241
}