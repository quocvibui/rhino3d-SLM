{
  "source_url": "https://github.com/gramaziokohler/tolerance_analysis/blob/b44750676e3422a0d6938daad691728e3a78e2a3/beam.py",
  "repo": "gramaziokohler/tolerance_analysis",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "beam.py",
  "instruction": null,
  "code": "import spatial_timber_assemblies.geometry_generation.helper_functions as hp\r\nimport compas.geometry.spatial as spatial\r\nimport Rhino.Geometry as rg\r\nimport scriptcontext\r\n\r\n__author__ = 'Arash Adel'\r\n__email__ = '<adel@arch.ethz.ch>'\r\n__copyright__ = 'Copyright 2017, Gramazio Kohler Research - ETH Zurich'\r\n\r\n\r\n\"\"\"\r\n**********************************************************************************\r\nIn this module, Beam Class and its Methods for the generation of the structural\r\nelements (horizontal, verticals and diagonal beams) are defined.\r\n**********************************************************************************\r\n\"\"\"\r\n\r\n\r\nclass Beam(object):\r\n\r\n    def __init__(self, beam_attr_dict):\r\n        '''\r\n        TODO: change all lists to tuples for better performance\r\n        The Beam class is initialized with an attribute dictionary.\r\n        attr_dict = {\"init_end_pts\": initial_end_pts, \"end_planes\": end_planes,\r\n        \"dim\": beam_dim = [thickness, height],\r\n        \"xAxis\":beam_x_axis,  \"yAxis\": beam_y_axis}\r\n        The Beam class is initialized with following inputs:\r\n        end_planes: list of two planes to define the short cuts of the beam.\r\n        dim: dimensions of the beam profile in y and z direction of the frame.\r\n\r\n        It has methods for generating the geometry of the beam.\r\n        It should keep track of the neighboring elements.\r\n        It should have the fabrication data associated with it\r\n        # direction of the deepest thickness (Rhino.Geometry.Vector3d)\r\n        self.orinetation   = Rhino.Geometry.Vector3d(_orinetation)\r\n        self.orientation: orientation of the beam (frame.zAxis without the z.val)\r\n        z value of self.orientation (orientation.Z) should be 0 for verticals/diagonals/chords or -1 for rafters\r\n        # Profile thickness in direction of z\r\n        self.height = _height\r\n        # Profile thickness in direction of y\r\n        self.width  = _width\r\n        Type of beam (0 = bottom chord, 1 = top chord, 2 = verticals and diagonals, 3 = wall rafter, 4= slab rafter)\r\n        '''\r\n        # setting beam attributes\r\n        self._set_beam_attributes(beam_attr_dict)\r\n        # weight of the beam in KG\r\n        self.weight = 0\r\n        # center of the mass for the beam\r\n        self.center_mass = None\r\n        # list of neighboring beams\r\n        self.neigbors = []  # TODO: include this information\r\n        # list of the beam necessary fabrication data\r\n        self.fab_data = []\r\n        # Suggested Gripping Plane(s)\r\n        self.gripping_planes = []\r\n        # TODO: include the following attribute for the beam\r\n        self.governing_neighbours = None\r\n        # each module has an interior center point to be used for defining\r\n        # beam in/ex vertices and other necessary info\r\n        # information after measuring the fabricated beam and define its tolerance\r\n        self.fabricated_tolerance = None\r\n        # structural bar instance key that gets filled after structural analysis\r\n        self.structure_bar_key = None\r\n        # Loads for structural analysis\r\n        self.loads = []\r\n        # Screw Information\r\n        # self.screws = (screws_bot, screws_top)\r\n        # screws_bot = ((screw_0_point, screw_0_vec), (screw_1_point, screw_1_vec),...)\r\n        self.screws = []\r\n        self.is_saw_blade_shifted = None  # If shifted, the vector of the shift is passed!\r\n        # TODO: Add milling info for the facade on the bottom and top cord\r\n        self.facade_milling_info = None\r\n        self.steel_plate_milling_info = None\r\n        self.high_tension_connection_milling_info = None\r\n        self.high_tension_connection_screws = None  # Two points (anchor point and end point)\r\n        self.high_tension_connection_screws_vertical_beam = None\r\n        # High Tension beam attribute\r\n        self.is_high_tension_beam = (False, None)\r\n        self.has_high_tension_screws = {\r\n            \"bot\": False, \"top\": False}\r\n        self.is_sharing_axis_point_with_other = (False, None)\r\n\r\n        # If a high-tension beam, set the attribute to True\r\n        # Note: need to run this after all the beams of the modules are generated\r\n        # from the building class\r\n\r\n    @classmethod\r\n    def from_side_edge(cls, beam_side_edge, offset_dir, beam_attr_dict):\r\n        \"\"\"\r\n        Initialize a beam instance from its edge as input (not axis).\r\n        \"\"\"\r\n\r\n        # Calculate the beam axis points.\r\n        z_axis = rg.Vector3d(beam_attr_dict.get(\"zAxis\"))\r\n        z_axis.Unitize()\r\n        axis_vec = beam_side_edge.UnitTangent\r\n        if rg.Vector3d.Multiply(offset_dir, z_axis) < 0:\r\n            z_axis.Reverse()\r\n            x_axis = rg.Vector3d.CrossProduct(axis_vec, z_axis)\r\n            x_axis.Reverse()\r\n        else:\r\n            x_axis = rg.Vector3d.CrossProduct(axis_vec, z_axis)\r\n\r\n        beam_dim = beam_attr_dict.get(\"dim\")\r\n        beam_thickness = beam_dim[0]\r\n        half_thickness = beam_thickness / 2.0\r\n        beam_height = beam_dim[1]\r\n        half_height = beam_height / 2.0\r\n        translation_vec_x = rg.Vector3d.Multiply(x_axis, half_thickness)\r\n        translation_vec_z = rg.Vector3d.Multiply(z_axis, half_height)\r\n        translation_vec = rg.Vector3d.Add(translation_vec_x, translation_vec_z)\r\n        # Find beam init axis sp (using the profile info)\r\n        beam_axis_sp = rg.Point3d.Add(beam_side_edge.From, translation_vec)\r\n\r\n        # Find beam init axis ep (use the edge info and add it to the beam init sp)\r\n        beam_axis_ep = rg.Point3d.Add(beam_side_edge.To, translation_vec)\r\n\r\n        init_axis_pts = [beam_axis_sp, beam_axis_ep]\r\n        beam_attr_dict[\"init_end_pts\"] = init_axis_pts\r\n        beam_attr_dict[\"ref_side_edge\"] = beam_side_edge\r\n        beam = cls(beam_attr_dict)\r\n        return beam\r\n\r\n    def _set_beam_attributes (self, beam_attr_dict):\r\n        \"\"\"\r\n        finds and sets the attributes for the beam.\r\n        \"\"\"\r\n        self.tolerance = scriptcontext.doc.ModelAbsoluteTolerance\r\n        self.attr_dict = {\"init_end_pts\": None, \"end_planes\": None,\r\n                          \"dim\": None, \"zAxis\": None, \"type\": None,\r\n                          \"parent_bar\": None, \"parent_building\": None,\r\n                          \"is_corner_vertical\": False, \"is_corner_diagonal\": False,\r\n                          \"corner_diagonal_aligned_edge\": None,\r\n                          \"is_opening_beam\": False,\r\n                          \"parent_floor\": None,\r\n                          \"parent_walls\": [], \"parent_slabs\": [],\r\n                          \"is_window_main_beam\": False,\r\n                          \"is_window_cross_beam\": False,\r\n                          \"parent_module\": None,\r\n                          \"ref_side_edge\": None, \"mesh\":None, \"beam_vertices\": None}\r\n\r\n        self.attr_dict.update(beam_attr_dict)\r\n        self.ref_side_edge = self.attr_dict[\"ref_side_edge\"]  # if initialized from side edge\r\n        self.is_window_main_beam = self.attr_dict.get(\"is_window_main_beam\")\r\n        self.is_window_cross_beam = self.attr_dict.get(\"is_window_cross_beam\")\r\n        self.initial_end_pts = self.attr_dict.get(\"init_end_pts\")\r\n        self.beam_vertices = self.attr_dict.get(\"beam_vertices\")\r\n        # TODO: make zAxis consistent for all beam and change it to beam.orientation\r\n        # TODO: get rid of zAxis\r\n        self.zAxis = rg.Vector3d(self.attr_dict.get(\"zAxis\"))\r\n        self.zAxis.Unitize()\r\n        self.type = self.attr_dict.get(\"type\")\r\n        if self.type == 0 or self.type == 1:\r\n            self.zAxis.Z = 0.0\r\n        self.parent_bar = self.attr_dict.get(\"parent_bar\")\r\n        self.parent_building = self.attr_dict.get(\"parent_building\")\r\n        self.parent_floor = self.attr_dict.get(\"parent_floor\")\r\n        self.parent_walls = self.attr_dict.get(\"parent_walls\")\r\n        self.parent_slabs = self.attr_dict.get(\"parent_slabs\")\r\n        self.end_planes = self.attr_dict.get(\"end_planes\")\r\n        self.dim = self.attr_dict.get(\"dim\")\r\n        self.thickness = self.dim[0]\r\n        self.half_thickness = self.thickness / 2.0\r\n        self.height = self.dim[1]\r\n        self.half_height = self.height / 2.0\r\n        self.is_corner_diagonal = self.attr_dict.get(\"is_corner_diagonal\")\r\n        self.corner_diagonal_aligned_edge = self.attr_dict.get(\"corner_diagonal_aligned_edge\")\r\n        self.is_corner_vertical = self.attr_dict.get(\"is_corner_vertical\")\r\n        self.parent_module = self.attr_dict.get(\"parent_module\")\r\n\r\n        # Generate the axis unit vector\r\n        self.axis_vec = self.gen_axis_unit_vec(self.initial_end_pts)\r\n        # List of the start and end point of bar axis\r\n        self.axis_end_points = self.gen_axis_end_points(self.end_planes)\r\n        # Regenerating the end planes\r\n        self.end_planes = self.re_gen_end_planes()\r\n        # Generating the beam frame\r\n        self.frame = self.gen_frame(self.axis_end_points)\r\n        # Generating beam vertices\r\n        beam_vertices_info = self.gen_beam_vertices(self.frame, self.axis_vec, self.end_planes)\r\n        self.vertices = beam_vertices_info[0]\r\n        self.vertices_tuple = beam_vertices_info[1]\r\n        # Generating beam faces and side planes\r\n        beam_faces_info = self.gen_beam_faces(self.vertices)\r\n        self.faces = beam_faces_info[0]\r\n        self.side_planes = beam_faces_info[1]\r\n        self.side_frames = beam_faces_info[2]\r\n        self.mesh=self.attr_dict.get(\"mesh\")\r\n        # Generating the beam geometry\r\n\r\n        # beam_vol_info = self.gen_beam_vol(self.faces, self.vertices, self.tolerance)\r\n        # self.polysurface = beam_vol_info[0]\r\n        # self.mesh = beam_vol_info[1]\r\n\r\n        # Replace zAxis with self.orientation\r\n        self.orientation = self.re_gen_beam_orientation(self.vertices)\r\n        # tuple of four long side edges of the beam\r\n        self.side_edges = self.gen_beam_side_edges(self.vertices)\r\n\r\n    def reset_attributes(self, new_beam_attr_dict):\r\n        \"\"\"\r\n        Reset the attribute of the beam.\r\n        new_beam_attr_dict = {\"init_end_pts\": initial_end_pts, \"end_planes\": end_planes,\r\n                  \"dim\": [80.0,120.0], \"zAxis\": z_axis}\r\n        \"init_end_pts\": List of start and end point of the beam axis\r\n        \"end_planes\": List of the start and end cut planes of the beam\r\n        \"dim\": beam_dim = [thickness, height]\r\n        \"zAxis\": rg vector\r\n        \"\"\"\r\n        self.attr_dict.update(new_beam_attr_dict)\r\n        self.initial_end_pts = self.attr_dict.get(\"init_end_pts\")\r\n        self.zAxis = rg.Vector3d(self.attr_dict.get(\"zAxis\"))\r\n        self.zAxis.Unitize()\r\n        if self.type == 0 or self.type == 1:\r\n            self.zAxis.Z = 0.0\r\n        self.end_planes = self.attr_dict.get(\"end_planes\")\r\n        self.dim = self.attr_dict.get(\"dim\")\r\n        self.thickness = self.dim[0]\r\n        self.half_thickness = self.thickness / 2.0\r\n        self.height = self.dim[1]\r\n        self.half_height = self.height / 2.0\r\n\r\n        # Generate the axis unit vector\r\n        self.axis_vec = self.gen_axis_unit_vec(self.initial_end_pts)\r\n        # List of the start and end point of bar axis\r\n        self.axis_end_points = self.gen_axis_end_points(self.end_planes)\r\n        # Regenerating the end planes\r\n        self.end_planes = self.re_gen_end_planes()\r\n        # Generating the beam frame\r\n        self.frame = self.gen_frame(self.axis_end_points)\r\n        # Generating beam vertices\r\n        beam_vertices_info = self.gen_beam_vertices(self.frame, self.axis_vec, self.end_planes)\r\n        self.vertices = beam_vertices_info[0]\r\n        self.vertices_tuple = beam_vertices_info[1]\r\n        # Generating beam faces and side planes\r\n        beam_faces_info = self.gen_beam_faces(self.vertices)\r\n        self.faces = beam_faces_info[0]\r\n        self.side_planes = beam_faces_info[1]\r\n        self.side_frames = beam_faces_info[2]\r\n        # Generating the beam geometry\r\n        beam_vol_info = self.gen_beam_vol(self.faces, self.vertices, self.tolerance)\r\n        self.polysurface = beam_vol_info[0]\r\n        self.mesh = beam_vol_info[1]\r\n        self.orientation = self.re_gen_beam_orientation(self.vertices)\r\n        # tuple of four long side edges of the beam\r\n        self.side_edges = self.gen_beam_side_edges(self.vertices)\r\n\r\n    def get_attribute(self, beam_attr):\r\n        \"\"\"\r\n        Return a specific beam attribute.\r\n        TODO: double check that this function is properly written.\r\n        \"\"\"\r\n        try:\r\n            return self.__dict__[beam_attr]\r\n        except KeyError:\r\n            print \"beam does not have the input attribute!\"\r\n            # return None\r\n\r\n    def get_corner_vertical_neighbor_diagonals(self):\r\n        \"\"\"\r\n        Check if the beam is a corner diagonal and return its attached diagonals.\r\n        \"\"\"\r\n        pass\r\n\r\n    # -----------------------------------------------------------------------\r\n    # Methods to update beam attributes\r\n    # -----------------------------------------------------------------------\r\n\r\n    def set_structure_bar_key(self, new_structure_bar_key):\r\n        \"\"\"\r\n        Sets a new structure bar key for the beam.\r\n        \"\"\"\r\n        self.structure_bar_key = new_structure_bar_key\r\n\r\n    # -----------------------------------------------------------------------\r\n    # Methods to generate beam geometry data\r\n    # -----------------------------------------------------------------------\r\n\r\n    def gen_axis_unit_vec(self, initial_end_pts):\r\n        \"\"\"\r\n        Generates the unit axis vector of the beam.\r\n        \"\"\"\r\n        return hp.create_line_unit_vec(initial_end_pts[0], initial_end_pts[1])\r\n\r\n    def gen_axis_end_points(self, end_planes):\r\n        \"\"\"\r\n        Generate the list of start and end point of bar axis.\r\n        This is used for structural calculations.\r\n        change to rg point3d\r\n        TODO: calculate initi_mid_pt with rg\r\n        \"\"\"\r\n        init_mid_pt_xyz = spatial.midpoint_line(self.initial_end_pts[0], self.initial_end_pts[1])\r\n        init_mid_pt = rg.Point3d(init_mid_pt_xyz[0], init_mid_pt_xyz[1], init_mid_pt_xyz[2])\r\n        infin_axis_line = hp.infinite_line(init_mid_pt, self.axis_vec)\r\n        axis_st_pt = hp.intersect_line_plane(infin_axis_line, end_planes[0])\r\n        axis_en_pt = hp.intersect_line_plane(infin_axis_line, end_planes[1])\r\n        return (axis_st_pt, axis_en_pt)\r\n\r\n    def re_gen_end_planes(self):\r\n        \"\"\"\r\n        Regenerates the beam cut_planes at the axis end points.\r\n        \"\"\"\r\n        end_plane_0 = rg.Plane(self.axis_end_points[0], self.end_planes[0].XAxis, self.end_planes[0].YAxis)\r\n        end_plane_1 = rg.Plane(self.axis_end_points[1], self.end_planes[1].XAxis, self.end_planes[1].YAxis)\r\n        return (end_plane_0, end_plane_1)\r\n\r\n    def gen_frame(self, axis_end_points):\r\n        \"\"\"\r\n        Generates and sets the frame for the beam on the middle of axis line.\r\n        TODO: maybe better to have frame_zAxis and xaxis as inputs (double check)\r\n        \"\"\"\r\n        axis_mid_point = rg.Point3d((axis_end_points[0] + axis_end_points[1]) / 2.0)\r\n        frame_zAxis = self.zAxis\r\n        xaxis = self.axis_vec\r\n        yaxis = rg.Vector3d.CrossProduct(frame_zAxis, xaxis)\r\n        return rg.Plane(axis_mid_point, xaxis, yaxis)\r\n\r\n    def gen_rect_corners(self, beam_frame):\r\n        \"\"\"\r\n        Returns corners of a rectangle on the frame plane of the beam\r\n        rectangle width = beam thickness\r\n        rectangle length = beam height\r\n        Output: list of four corners\r\n                pt_3----------pt_0\r\n                    |        |\r\n                    |        |\r\n                    |   cp   |\r\n                    |        |\r\n                    |        |\r\n                pt_2----------pt_1\r\n        \"\"\"\r\n        cen_pt = beam_frame.Origin\r\n        translation_vec_y = rg.Vector3d.Multiply(beam_frame.YAxis, self.half_thickness)\r\n        translation_vec_z = rg.Vector3d.Multiply(beam_frame.ZAxis, self.half_height)\r\n        translation_vec_1 = rg.Vector3d.Add(translation_vec_y, translation_vec_z)\r\n        translation_vec_2 = rg.Vector3d.Add(translation_vec_y, rg.Vector3d.Negate(translation_vec_z))\r\n        translation_vec_3 = rg.Vector3d.Add(rg.Vector3d.Negate(translation_vec_y), rg.Vector3d.Negate(translation_vec_z))\r\n        translation_vec_4 = rg.Vector3d.Add(rg.Vector3d.Negate(translation_vec_y), translation_vec_z)\r\n        corner_0 = rg.Point3d.Add(cen_pt, translation_vec_1)\r\n        corner_1 = rg.Point3d.Add(cen_pt, translation_vec_2)\r\n        corner_2 = rg.Point3d.Add(cen_pt, translation_vec_3)\r\n        corner_3 = rg.Point3d.Add(cen_pt, translation_vec_4)\r\n        corners = [corner_0, corner_1, corner_2, corner_3]\r\n        return corners\r\n\r\n    def gen_beam_vertices(self, beam_frame, beam_axis_vec, beam_end_planes):\r\n        \"\"\"\r\n        Returns points of the structural element volume\r\n        \"\"\"\r\n        vertices_bot = []\r\n        vertices_bot_tuple = []\r\n        vertices_top_tuple = []\r\n        vertices_top = []\r\n        profile_corners = self.gen_rect_corners(beam_frame)\r\n        for corner in profile_corners:\r\n            infin_line = hp.infinite_line(corner, beam_axis_vec)\r\n            sp_ep_line = hp.intersect_line_planes(infin_line, beam_end_planes)\r\n            vertex_bot = sp_ep_line.From\r\n            vertex_top = sp_ep_line.To\r\n            vertices_bot.append(vertex_bot)\r\n            vertices_top.append(vertex_top)\r\n            vertices_bot_tuple.append((vertex_bot.X, vertex_bot.Y, vertex_bot.Z))\r\n            vertices_top_tuple.append((vertex_top.X, vertex_top.Y, vertex_top.Z))\r\n        vertices_bot = tuple(vertices_bot)\r\n        vertices_top = tuple(vertices_top)\r\n        vertices_bot_tuple = tuple(vertices_bot_tuple)\r\n        vertices_top_tuple = tuple(vertices_top_tuple)\r\n        return (vertices_bot, vertices_top), (vertices_bot_tuple, vertices_top_tuple)\r\n\r\n    def gen_beam_faces(self, beam_vertices):\r\n        \"\"\"\r\n        Generates the faces of the beam out of two sets of 4 points (8 vertices)\r\n        Inputs: 2 lists of points (4 each) for the bottom and top face\r\n        pts_bot: list of four corner points for the bottom face\r\n        pts_top: list of four points for the top face\r\n        self.faces = a list of the six breps of the beam volume\r\n        \"\"\"\r\n        faces = []\r\n        side_frames = []  # list of six frames (one on each beam face) facing outwards\r\n        # vertices_bot = beam_vertices[0:4]\r\n        vertices_bot = beam_vertices[0]\r\n        # vertices_top = beam_vertices[4:]\r\n        vertices_top = beam_vertices[1]\r\n        prof_bot_pts = [vertices_bot[0], vertices_bot[1], vertices_bot[2], vertices_bot[3]]\r\n        bot_frame = rg.Plane(vertices_bot[0], vertices_bot[3], vertices_bot[1])\r\n        prof_top_pts = [vertices_top[0], vertices_top[1], vertices_top[2], vertices_top[3]]\r\n        top_frame = rg.Plane(vertices_top[0], vertices_top[1], vertices_top[3])\r\n        prof_sd_01_pts = [vertices_bot[0], vertices_top[0], vertices_top[1], vertices_bot[1]]\r\n        plane_sd_01 = rg.Plane(vertices_bot[0], vertices_bot[1], vertices_top[0])\r\n        prof_sd_02_pts = [vertices_bot[1], vertices_top[1], vertices_top[2], vertices_bot[2]]\r\n        plane_sd_02 = rg.Plane(vertices_bot[1], vertices_bot[2], vertices_top[1])\r\n        prof_sd_03_pts = [vertices_bot[2], vertices_top[2], vertices_top[3], vertices_bot[3]]\r\n        plane_sd_03 = rg.Plane(vertices_bot[2], vertices_bot[3], vertices_top[2])\r\n        prof_sd_04_pts = [vertices_bot[3], vertices_top[3], vertices_top[0], vertices_bot[0]]\r\n        plane_sd_04 = rg.Plane(vertices_bot[3], vertices_bot[0], vertices_top[3])\r\n        profiles_pts = [prof_bot_pts, prof_top_pts, prof_sd_01_pts, prof_sd_02_pts, prof_sd_03_pts, prof_sd_04_pts]\r\n        side_frames = [bot_frame, top_frame, plane_sd_01, plane_sd_02, plane_sd_03, plane_sd_04]\r\n        # drawing faces and add them to the list of faces\r\n        for profile_pts in profiles_pts:\r\n            beam_face = rg.Brep.CreateFromCornerPoints(\r\n                profile_pts[0], profile_pts[1], profile_pts[2], profile_pts[3], 0)\r\n            faces.append(beam_face)\r\n\r\n        faces = tuple(faces)\r\n        return faces, (plane_sd_01, plane_sd_02, plane_sd_03, plane_sd_04), side_frames\r\n\r\n    def gen_beam_side_edges(self, beam_vertices):\r\n        \"\"\"\r\n        Generates the four side long edges of the beam geometry out of two sets of 4 points (8 vertices)\r\n        Inputs: 2 lists of points (4 each) for the bottom and top face\r\n        pts_bot: list of four corner points for the bottom face\r\n        pts_top: list of four points for the top face\r\n        \"\"\"\r\n        side_edges = []\r\n\r\n        vertices_bot = beam_vertices[0]\r\n        vertices_top = beam_vertices[1]\r\n        for bot_index, bot_vert in enumerate(vertices_bot):\r\n            top_vert = vertices_top[bot_index]\r\n            edge_line = rg.Line(bot_vert, top_vert)\r\n            side_edges.append(edge_line)\r\n        side_edges = tuple(side_edges)\r\n        return side_edges\r\n\r\n    def re_gen_beam_orientation(self, beam_vertices):\r\n        \"\"\"\r\n        Regenerates the orientation unit vector of the beam.\r\n        orientation_vec.z = 0.0\r\n        \"\"\"\r\n        bot_vertices = beam_vertices[0]\r\n        line_0 = rg.Line(bot_vertices[0], bot_vertices[3])\r\n        line_1 = rg.Line(bot_vertices[1], bot_vertices[2])\r\n        sp = line_0.PointAt(0.50)\r\n        ep = line_1.PointAt(0.50)\r\n        orientation_vec = rg.Vector3d(ep - sp)\r\n        orientation_vec.Unitize()\r\n        return orientation_vec\r\n\r\n    # -----------------------------------------------------------------------\r\n    # Methods to add screws information to the beam\r\n    # -----------------------------------------------------------------------\r\n    def check_is_beam_high_tension(self):\r\n        \"\"\"\r\n        Checks if the beam is a high tension beam and\r\n        add necessary information.\r\n        NOTE: this method is called in the building class after\r\n        all beams are generated.\r\n        \"\"\"\r\n        is_high_tension_bar = self.parent_building.get_bar_attribute(\r\n            self.parent_bar, \"is_high_tension_bar\")\r\n        if is_high_tension_bar[0] == False:\r\n            self.is_high_tension_beam = (False, None)\r\n        else:\r\n            bot_top_neigh_bar_dict = is_high_tension_bar[1]\r\n            bot_neighbor_bar = bot_top_neigh_bar_dict[\"bot_neighbor\"]\r\n            top_neighbor_bar = bot_top_neigh_bar_dict[\"top_neighbor\"]\r\n            # print \"beam bar: \", self.parent_bar\r\n            # print bot_neighbor_bar, top_neighbor_bar\r\n            if bot_neighbor_bar is not None:\r\n                bot_neighbor_beam = self.parent_building._find_bar_beam_in_module(\r\n                    bot_neighbor_bar, self.parent_module, 2)\r\n            else:\r\n                bot_neighbor_beam = None\r\n            if top_neighbor_bar is not None:\r\n                top_neighbor_beam = self.parent_building._find_bar_beam_in_module(\r\n                    top_neighbor_bar, self.parent_module, 2)\r\n            else:\r\n                top_neighbor_beam = None\r\n            bot_top_neigh_dict = {\r\n                \"bot_neighbor\": bot_neighbor_beam,\r\n                \"top_neighbor\": top_neighbor_beam}\r\n            # Add has_high_tension_screws attr to neighbor beams\r\n            if bot_neighbor_beam is not None:\r\n                bot_neighbor_beam.has_high_tension_screws[\"bot\"] = True\r\n            if top_neighbor_beam is not None:\r\n                top_neighbor_beam.has_high_tension_screws[\"top\"] = True\r\n            self.is_high_tension_beam = (True, bot_top_neigh_dict)\r\n            # Add has_high_tension_screws attr to beam\r\n            self.has_high_tension_screws = {\r\n                \"bot\": True, \"top\": True}\r\n\r\n    def add_screws_information(self, screws_information):\r\n        \"\"\"\r\n        Adds the screws information to the beam class.\r\n        Screws information are generated after the FEM analysis is performed, in\r\n        the analysis package.\r\n        # self.screws = (screws_bot, screws_top)\r\n        # screws_bot = ((screw_0_point, screw_0_vec), (screw_1_point, screw_1_vec),...)\r\n        # screws_top = ((screw_0_point, screw_0_vec), (screw_1_point, screw_1_vec),...)\r\n        \"\"\"\r\n        # TODO: define bottom and top screws\r\n        self.screws = screws_information\r\n\r\n    def add_screw_to_beam_screws(self, new_screw_information, screw_side=\"bottom\"):\r\n        \"\"\"\r\n        Adds the screws information to the beam class. This function used\r\n        for the screws at the either end of the beam.\r\n        Screws information are generated after the FEM analysis is performed, in\r\n        the analysis package.\r\n        # self.screws = (screws_bot, screws_top)\r\n        # screws_bot = ((screw_0_point, screw_0_vec), (screw_1_point, screw_1_vec),...)\r\n        # screws_top = ((screw_0_point, screw_0_vec), (screw_1_point, screw_1_vec),...)\r\n        \"\"\"\r\n        # TODO: define bottom and top screws\r\n        beam_screws = self.screws[:]\r\n        if beam_screws == []:\r\n            beam_screws = [[], []]\r\n        if screw_side == \"bottom\":\r\n            beam_screws[0].append(new_screw_information)\r\n        elif screw_side == \"top\":\r\n            beam_screws[1].append(new_screw_information)\r\n        else:\r\n            raise Exception(\"Side is not defined correctly!\")\r\n\r\n        self.screws = beam_screws\r\n\r\n    def add_screw_to_horizontal_beam_screws(self, new_screw_information):\r\n        \"\"\"\r\n        Adds the screws information to the beam class, this function is not used for\r\n        the screws that are at the either end of the beam.\r\n        Screws information are generated after the FEM analysis is performed, in\r\n        the analysis package.\r\n        # self.screws = (screws_bot, screws_top)\r\n        # screws[0] = screws_bot = ((screw_0_point, screw_0_vec), (screw_1_point, screw_1_vec),...)\r\n        # screws[1] = screws_top = ((screw_0_point, screw_0_vec), (screw_1_point, screw_1_vec),...)\r\n        # screws[2] = all the screws that belong to the cross bar and are a result of the main bars.\r\n        \"\"\"\r\n        beam_screws = self.screws[:]\r\n        if beam_screws == []:\r\n            beam_screws = [[], [], []]\r\n        elif len(beam_screws) == 2:\r\n            beam_screws.append([])\r\n        beam_screws[2].append(new_screw_information)\r\n        self.screws = beam_screws\r\n\r\n    # -----------------------------------------------------------------------\r\n    # Methods to work with fabrication tolerances and sensors data\r\n    # -----------------------------------------------------------------------\r\n\r\n    def get_outside_vertices(self):\r\n        \"\"\"\r\n        Returns four vertices of the beam that face outside of the parent module.\r\n        output:\r\n        a list of four vertices [bot_left, bot_right, top_left, top_right]\r\n\r\n        TODO: for interior beams there needs to be a logic based on\r\n              maybe where the structure is exposed!\r\n        \"\"\"\r\n        raise(\"Not implemented!\")\r\n\r\n    def get_inside_vertices(self):\r\n        \"\"\"\r\n        Returns four vertices of the beam that face inside of the parent module.\r\n        output:\r\n        a list of four vertices [bot_left, bot_right, top_left, top_right]\r\n\r\n        TODO: for interior beams there needs to be a logic based on\r\n              maybe where the structure is exposed!\r\n        \"\"\"\r\n        raise(\"Not implemented!\")\r\n\r\n    def is_fabricated(self):\r\n        \"\"\"\r\n        Returns True if beam is fabricated (check the self.fabricated_tolerance).\r\n        \"\"\"\r\n        if self.fabricated_tolerance is None:\r\n            return False\r\n        else:\r\n            return True\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}