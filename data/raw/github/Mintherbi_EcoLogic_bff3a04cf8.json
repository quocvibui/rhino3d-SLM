{
  "source_url": "https://github.com/Mintherbi/EcoLogic/blob/546c53d7732477b1d04e916bcd629ad492b605a6/PythonFiles/Birdbond/01_Static_Birdbone.py",
  "repo": "Mintherbi/EcoLogic",
  "repo_stars": 1,
  "repo_description": null,
  "license": "unknown",
  "filepath": "PythonFiles/Birdbond/01_Static_Birdbone.py",
  "instruction": "TRABECULAR STRUCTURE PROTOTYPE - REFINED VERSION\nMore porous, thinner members, irregular floors",
  "code": "\"\"\"\nTRABECULAR STRUCTURE PROTOTYPE - REFINED VERSION\nMore porous, thinner members, irregular floors\n\"\"\"\n\nimport Rhino.Geometry as rg\nimport math\nimport random\nfrom collections import defaultdict\n\nclass TrabeculaGenerator:\n    \n    def __init__(self, boundary, floor_count, floor_height, voxel_size):\n        self.boundary = boundary\n        self.floor_count = floor_count\n        self.floor_height = floor_height\n        self.voxel_size = voxel_size\n        \n        self.bbox = boundary.GetBoundingBox(True)\n        self.voxels = {}\n        self.stress_field = {}\n        self.load_points = []\n        \n    def generate_voxel_grid(self):\n        \"\"\"Create 3D voxel grid within boundary\"\"\"\n        print(\"Generating voxel grid...\")\n        \n        voxels = []\n        x_min, y_min, z_min = self.bbox.Min.X, self.bbox.Min.Y, self.bbox.Min.Z\n        x_max, y_max, z_max = self.bbox.Max.X, self.bbox.Max.Y, self.bbox.Max.Z\n        \n        x = x_min\n        while x <= x_max:\n            y = y_min\n            while y <= y_max:\n                z = z_min\n                while z <= z_max:\n                    pt = rg.Point3d(x, y, z)\n                    \n                    if self.boundary.IsPointInside(pt, 0.01, True):\n                        voxel_key = self._get_voxel_key(pt)\n                        self.voxels[voxel_key] = {\n                            'center': pt,\n                            'stress': 0.0,\n                            'density': 0.0,\n                            'is_floor': False,\n                            'is_column': False\n                        }\n                    \n                    z += self.voxel_size\n                y += self.voxel_size\n            x += self.voxel_size\n        \n        print(\"Created {} voxels\".format(len(self.voxels)))\n        return self.voxels\n    \n    def _get_voxel_key(self, point):\n        \"\"\"Convert point to discrete voxel coordinate\"\"\"\n        x = int(round(point.X / self.voxel_size))\n        y = int(round(point.Y / self.voxel_size))\n        z = int(round(point.Z / self.voxel_size))\n        return (x, y, z)\n    \n    def _key_to_point(self, key):\n        \"\"\"Convert voxel key back to point\"\"\"\n        x = key[0] * self.voxel_size\n        y = key[1] * self.voxel_size\n        z = key[2] * self.voxel_size\n        return rg.Point3d(x, y, z)\n    \n    def define_load_points(self):\n        \"\"\"Generate load points at each floor level\"\"\"\n        print(\"Defining load points...\")\n        \n        self.load_points = []\n        \n        for floor in range(self.floor_count):\n            z_height = self.bbox.Min.Z + (floor + 1) * self.floor_height\n            \n            x_samples = int((self.bbox.Max.X - self.bbox.Min.X) / (self.voxel_size * 3)) + 1\n            y_samples = int((self.bbox.Max.Y - self.bbox.Min.Y) / (self.voxel_size * 3)) + 1\n            \n            for i in range(x_samples):\n                for j in range(y_samples):\n                    x = self.bbox.Min.X + i * (self.bbox.Max.X - self.bbox.Min.X) / max(1, x_samples - 1)\n                    y = self.bbox.Min.Y + j * (self.bbox.Max.Y - self.bbox.Min.Y) / max(1, y_samples - 1)\n                    \n                    load_pt = rg.Point3d(x, y, z_height)\n                    \n                    if self.boundary.IsPointInside(load_pt, 0.01, True):\n                        load_magnitude = 5.0\n                        self.load_points.append({\n                            'point': load_pt,\n                            'magnitude': load_magnitude,\n                            'floor': floor\n                        })\n        \n        print(\"Created {} load points\".format(len(self.load_points)))\n        return self.load_points\n    \n    def calculate_stress_field(self, wind_vector=None):\n        \"\"\"Calculate stress field using distance-based load diffusion\"\"\"\n        print(\"Calculating stress field...\")\n        \n        for key in self.voxels:\n            self.voxels[key]['stress'] = 0.0\n        \n        ground_z = self.bbox.Min.Z\n        \n        for load in self.load_points:\n            load_pt = load['point']\n            load_mag = load['magnitude']\n            \n            for voxel_key, voxel_data in self.voxels.items():\n                voxel_pt = voxel_data['center']\n                \n                if voxel_pt.Z <= load_pt.Z:\n                    distance = voxel_pt.DistanceTo(load_pt)\n                    vertical_dist = abs(load_pt.Z - voxel_pt.Z)\n                    horizontal_dist = math.sqrt(\n                        (load_pt.X - voxel_pt.X)**2 + \n                        (load_pt.Y - voxel_pt.Y)**2\n                    )\n                    \n                    if distance > 0:\n                        vertical_factor = math.exp(-horizontal_dist / (self.voxel_size * 5))\n                        stress_contribution = (load_mag / (vertical_dist + 1.0)) * vertical_factor\n                        ground_factor = 1.0 + (1.0 - (voxel_pt.Z - ground_z) / (self.bbox.Max.Z - ground_z)) * 0.5\n                        voxel_data['stress'] += stress_contribution * ground_factor\n        \n        if wind_vector and wind_vector.Length > 0:\n            self._add_wind_stress(wind_vector)\n        \n        max_stress = max([v['stress'] for v in self.voxels.values()] + [0.001])\n        for voxel_data in self.voxels.values():\n            voxel_data['stress'] /= max_stress\n        \n        print(\"Stress field calculated\")\n    \n    def _add_wind_stress(self, wind_vector):\n        \"\"\"Add lateral wind loads to stress field\"\"\"\n        wind_dir = rg.Vector3d(wind_vector)\n        wind_dir.Unitize()\n        \n        for voxel_key, voxel_data in self.voxels.items():\n            voxel_pt = voxel_data['center']\n            height_ratio = (voxel_pt.Z - self.bbox.Min.Z) / (self.bbox.Max.Z - self.bbox.Min.Z)\n            exposure = max(0, wind_dir.X * (voxel_pt.X - self.bbox.Min.X) + \n                              wind_dir.Y * (voxel_pt.Y - self.bbox.Min.Y))\n            wind_stress = height_ratio * exposure * 0.3\n            voxel_data['stress'] += wind_stress\n    \n    def generate_density_map(self, threshold=0.1):\n        \"\"\"Convert stress field to material density\"\"\"\n        print(\"Generating density map...\")\n        \n        for voxel_key, voxel_data in self.voxels.items():\n            stress = voxel_data['stress']\n            \n            if stress > threshold:\n                # More aggressive power law for sparser result\n                density = stress ** 1.2  # Changed from 0.7 to 1.2\n                voxel_data['density'] = min(1.0, density)\n            else:\n                voxel_data['density'] = 0.0\n        \n        print(\"Density map generated\")\n    \n    def identify_floors_and_columns(self):\n        \"\"\"Identify which voxels should be floors or columns\"\"\"\n        print(\"Identifying architectural elements...\")\n        \n        floor_tolerance = self.voxel_size * 0.6\n        \n        for floor_idx in range(self.floor_count):\n            target_z = self.bbox.Min.Z + (floor_idx + 1) * self.floor_height\n            \n            for voxel_key, voxel_data in self.voxels.items():\n                voxel_pt = voxel_data['center']\n                \n                # Lower threshold for floor identification\n                if abs(voxel_pt.Z - target_z) < floor_tolerance and voxel_data['density'] > 0.05:\n                    voxel_data['is_floor'] = True\n        \n        self._identify_columns()\n        print(\"Architectural elements identified\")\n    \n    def _identify_columns(self):\n        \"\"\"Identify vertical load paths as columns\"\"\"\n        xy_columns = defaultdict(list)\n        \n        for voxel_key, voxel_data in self.voxels.items():\n            if voxel_data['density'] > 0.4:  # Higher threshold for columns\n                xy_key = (voxel_key[0], voxel_key[1])\n                xy_columns[xy_key].append((voxel_key[2], voxel_key))\n        \n        for xy_key, z_list in xy_columns.items():\n            z_list.sort()\n            \n            if len(z_list) >= self.floor_count * 0.5:\n                for z_coord, voxel_key in z_list:\n                    if self.voxels[voxel_key]['stress'] > 0.5:  # Higher threshold\n                        self.voxels[voxel_key]['is_column'] = True\n    \n    def generate_lattice(self):\n        \"\"\"Create structural lattice connecting high-density voxels\"\"\"\n        print(\"Generating trabecular lattice...\")\n        \n        lattice_lines = []\n        \n        for voxel_key, voxel_data in self.voxels.items():\n            # Higher minimum density threshold\n            if voxel_data['density'] < 0.3:  # Changed from 0.2 to 0.3\n                continue\n            \n            center = voxel_data['center']\n            \n            for dx in [-1, 0, 1]:\n                for dy in [-1, 0, 1]:\n                    for dz in [-1, 0, 1]:\n                        if dx == 0 and dy == 0 and dz == 0:\n                            continue\n                        \n                        neighbor_key = (voxel_key[0] + dx, \n                                      voxel_key[1] + dy, \n                                      voxel_key[2] + dz)\n                        \n                        if neighbor_key in self.voxels:\n                            neighbor_data = self.voxels[neighbor_key]\n                            \n                            # Higher threshold for connections\n                            if neighbor_data['density'] >= 0.3:  # Changed from 0.2\n                                neighbor_center = neighbor_data['center']\n                                avg_density = (voxel_data['density'] + neighbor_data['density']) / 2.0\n                                line = rg.Line(center, neighbor_center)\n                                \n                                if self._should_add_line(line, avg_density):\n                                    lattice_lines.append({\n                                        'line': line.ToNurbsCurve(),\n                                        'density': avg_density,\n                                        'is_column': voxel_data['is_column'] or neighbor_data['is_column']\n                                    })\n        \n        print(\"Generated {} lattice members\".format(len(lattice_lines)))\n        return lattice_lines\n    \n    def _should_add_line(self, line, density):\n        \"\"\"Stochastic filtering - MORE AGGRESSIVE\"\"\"\n        # Higher power means fewer weak connections\n        probability = density ** 3  # Changed from 2 to 3\n        return random.random() < probability\n    \n    def generate_floor_slabs(self):\n        \"\"\"Create IRREGULAR floor slab surfaces from floor-level voxels\"\"\"\n        print(\"Generating irregular floor slabs...\")\n        \n        floor_slabs = []\n        \n        for floor_idx in range(self.floor_count):\n            floor_points = []\n            \n            for voxel_key, voxel_data in self.voxels.items():\n                if voxel_data['is_floor']:\n                    target_z = self.bbox.Min.Z + (floor_idx + 1) * self.floor_height\n                    \n                    if abs(voxel_data['center'].Z - target_z) < self.voxel_size:\n                        floor_points.append(voxel_data['center'])\n            \n            if len(floor_points) > 3:\n                target_z = self.bbox.Min.Z + (floor_idx + 1) * self.floor_height\n                floor_points_2d = [rg.Point3d(pt.X, pt.Y, target_z) for pt in floor_points]\n                \n                if len(floor_points_2d) >= 4:\n                    # Use actual convex hull for irregular shape\n                    perimeter_pts = self._get_convex_hull(floor_points_2d)\n                    \n                    if len(perimeter_pts) >= 3:\n                        perimeter_pts.append(perimeter_pts[0])  # Close curve\n                        floor_curve = rg.Curve.CreateControlPointCurve(perimeter_pts, 1)\n                        \n                        if floor_curve and floor_curve.IsClosed:\n                            floor_brep = rg.Brep.CreatePlanarBreps(floor_curve, 0.01)\n                            if floor_brep:\n                                floor_slabs.append({\n                                    'brep': floor_brep[0],\n                                    'level': floor_idx,\n                                    'height': target_z\n                                })\n        \n        print(\"Generated {} irregular floor slabs\".format(len(floor_slabs)))\n        return floor_slabs\n    \n    def _get_convex_hull(self, points):\n        \"\"\"\n        Get actual convex hull for irregular floor boundary\n        Graham scan algorithm\n        \"\"\"\n        if len(points) < 3:\n            return points\n        \n        # Find the point with lowest Y (and leftmost if tie)\n        start = min(points, key=lambda p: (p.Y, p.X))\n        \n        # Sort points by polar angle with respect to start point\n        def polar_angle(p):\n            dx = p.X - start.X\n            dy = p.Y - start.Y\n            return math.atan2(dy, dx)\n        \n        sorted_points = sorted([p for p in points if p != start], key=polar_angle)\n        \n        # Build convex hull\n        hull = [start]\n        \n        for p in sorted_points:\n            # Remove points that make a right turn\n            while len(hull) > 1:\n                # Cross product to determine turn direction\n                v1_x = hull[-1].X - hull[-2].X\n                v1_y = hull[-1].Y - hull[-2].Y\n                v2_x = p.X - hull[-1].X\n                v2_y = p.Y - hull[-1].Y\n                cross = v1_x * v2_y - v1_y * v2_x\n                \n                if cross > 0:  # Left turn - keep going\n                    break\n                else:  # Right turn - remove last point\n                    hull.pop()\n            \n            hull.append(p)\n        \n        return hull\n    \n    def _get_perimeter_points(self, points):\n        \"\"\"Fallback: simplified perimeter\"\"\"\n        if len(points) < 3:\n            return points\n        \n        center = rg.Point3d(\n            sum(pt.X for pt in points) / len(points),\n            sum(pt.Y for pt in points) / len(points),\n            points[0].Z\n        )\n        \n        def angle_from_center(pt):\n            return math.atan2(pt.Y - center.Y, pt.X - center.X)\n        \n        sorted_points = sorted(points, key=angle_from_center)\n        step = max(1, len(sorted_points) // 12)\n        return sorted_points[::step]\n    \n    def extract_columns(self):\n        \"\"\"Extract primary column lines from lattice\"\"\"\n        print(\"Extracting columns...\")\n        \n        columns = []\n        xy_groups = defaultdict(list)\n        \n        for voxel_key, voxel_data in self.voxels.items():\n            if voxel_data['is_column']:\n                xy_key = (voxel_key[0], voxel_key[1])\n                xy_groups[xy_key].append(voxel_data['center'])\n        \n        for xy_key, points in xy_groups.items():\n            if len(points) >= 2:\n                points.sort(key=lambda p: p.Z)\n                column_line = rg.Line(points[0], points[-1])\n                columns.append({\n                    'line': column_line.ToNurbsCurve(),\n                    'base': points[0],\n                    'top': points[-1],\n                    'height': points[-1].Z - points[0].Z\n                })\n        \n        print(\"Extracted {} primary columns\".format(len(columns)))\n        return columns\n    \n    def get_stress_visualization(self):\n        \"\"\"Create colored points for stress visualization\"\"\"\n        stress_viz = []\n        \n        for voxel_key, voxel_data in self.voxels.items():\n            if voxel_data['density'] > 0.1:\n                stress_viz.append({\n                    'point': voxel_data['center'],\n                    'stress': voxel_data['stress'],\n                    'density': voxel_data['density']\n                })\n        \n        return stress_viz\n    \n    # ====== THICKNESS METHODS ======\n    \n    def thicken_lattice(self, min_radius=0.03, max_radius=0.15):\n        \"\"\"\n        Create THINNER pipes with variable thickness based on stress\n        \"\"\"\n        print(\"Thickening lattice members...\")\n        \n        thick_lattice = []\n        lattice_data = self.generate_lattice()\n        \n        for item in lattice_data:\n            line = item['line']\n            density = item['density']\n            is_column = item['is_column']\n            \n            # Calculate radius - now much thinner\n            base_radius = min_radius + (density ** 0.5) * (max_radius - min_radius)\n            \n            # Columns get boost but not too much\n            if is_column:\n                radius = base_radius * 1.5  # Changed from 1.8\n            else:\n                radius = base_radius\n            \n            # Create pipe\n            try:\n                pipes = rg.Brep.CreatePipe(\n                    line, \n                    radius, \n                    False,\n                    rg.PipeCapMode.Round,\n                    True,\n                    0.01,\n                    0.01\n                )\n                \n                if pipes:\n                    for pipe in pipes:\n                        thick_lattice.append({\n                            'brep': pipe,\n                            'radius': radius,\n                            'density': density,\n                            'is_column': is_column\n                        })\n            except:\n                pass\n        \n        print(\"Created {} thick lattice members\".format(len(thick_lattice)))\n        return thick_lattice\n    \n    def create_thick_floors_irregular(self, slab_thickness=0.2):\n        \"\"\"\n        Create thick IRREGULAR floor slabs by extruding the irregular shapes\n        \"\"\"\n        print(\"Creating thick irregular floor slabs...\")\n        \n        thick_slabs = []\n        floor_data = self.generate_floor_slabs()\n        \n        for floor_item in floor_data:\n            base_brep = floor_item['brep']\n            floor_level = floor_item['level']\n            height = floor_item['height']\n            \n            # Extrude the irregular surface downward\n            extrusion_vector = rg.Vector3d(0, 0, -slab_thickness)\n            \n            # Get all faces and extrude them\n            extruded_surfaces = []\n            for face in base_brep.Faces:\n                # Get the outer edge curve\n                edge_curves = []\n                for edge in face.Edges:\n                    edge_curves.append(edge.DuplicateCurve())\n                \n                if edge_curves:\n                    # Join curves to get boundary\n                    joined = rg.Curve.JoinCurves(edge_curves, 0.01)\n                    if joined and len(joined) > 0:\n                        boundary = joined[0]\n                        \n                        # Extrude to create solid\n                        extrusion = rg.Surface.CreateExtrusion(boundary, extrusion_vector)\n                        if extrusion:\n                            thick_brep = extrusion.ToBrep()\n                            if thick_brep:\n                                # Cap the brep to make it solid\n                                thick_brep.Cap(rg.BrepCapDirection.Both)\n                                \n                                thick_slabs.append({\n                                    'brep': thick_brep,\n                                    'level': floor_level,\n                                    'height': height,\n                                    'thickness': slab_thickness\n                                })\n        \n        print(\"Created {} thick irregular floor slabs\".format(len(thick_slabs)))\n        return thick_slabs\n\n\n# ============================================\n# MAIN EXECUTION\n# ============================================\n\n# Initialize all outputs\nlattice_lines = []\nfloor_slabs = []\ncolumns = []\nstress_field = []\ndensity_map = []\nthick_lattice = []\nthick_floors = []\n\nprint(\"=\"*50)\nprint(\"TRABECULAR STRUCTURE GENERATOR - REFINED\")\nprint(\"=\"*50)\n\n# CREATE DEFAULT BOUNDARY\nif not boundary_brep or boundary_brep is None:\n    print(\"No boundary provided - creating default 20x20x30 box\")\n    box = rg.Box(\n        rg.Plane.WorldXY,\n        rg.Interval(0, 20),\n        rg.Interval(0, 20),\n        rg.Interval(0, 30)\n    )\n    _boundary = box.ToBrep()\nelse:\n    _boundary = boundary_brep\n    print(\"Using provided boundary\")\n\n# Adjusted defaults for THINNER, MORE POROUS result\n_floor_count = 5\n_floor_height = 4.0\n_voxel_size = 1.5\n_threshold = 0.25  # INCREASED from 0.15 - removes more weak material\n_wind_dir = None\n_min_thickness = 0.03  # REDUCED from 0.08 - thinner members\n_max_thickness = 0.15  # REDUCED from 0.35 - thinner members\n_slab_thickness = 0.2  # REDUCED from 0.25 - thinner slabs\n\n# Override with inputs\nif 'floor_count' in dir() and floor_count is not None and floor_count > 0:\n    _floor_count = int(floor_count)\n\nif 'floor_height' in dir() and floor_height is not None and floor_height > 0:\n    _floor_height = float(floor_height)\n\nif 'voxel_size' in dir() and voxel_size is not None and voxel_size > 0:\n    _voxel_size = float(voxel_size)\n\nif 'lattice_threshold' in dir() and lattice_threshold is not None:\n    _threshold = float(lattice_threshold)\n\nif 'wind_direction' in dir() and wind_direction is not None:\n    _wind_dir = wind_direction\n\nprint(\"Floor count: {}\".format(_floor_count))\nprint(\"Floor height: {}\".format(_floor_height))\nprint(\"Voxel size: {}\".format(_voxel_size))\nprint(\"Threshold: {} (HIGHER = more porous)\".format(_threshold))\nprint(\"Min/Max lattice radius: {}/{}\".format(_min_thickness, _max_thickness))\nprint(\"Slab thickness: {}\".format(_slab_thickness))\nprint(\"=\"*50)\n\ntry:\n    # Initialize generator\n    generator = TrabeculaGenerator(\n        _boundary, \n        _floor_count, \n        _floor_height, \n        _voxel_size\n    )\n    \n    # Generate structure\n    generator.generate_voxel_grid()\n    generator.define_load_points()\n    generator.calculate_stress_field(_wind_dir)\n    generator.generate_density_map(_threshold)\n    generator.identify_floors_and_columns()\n    \n    # Generate line-based outputs\n    lattice_data = generator.generate_lattice()\n    floor_data = generator.generate_floor_slabs()\n    column_data = generator.extract_columns()\n    stress_viz_data = generator.get_stress_visualization()\n    \n    lattice_lines = [item['line'] for item in lattice_data]\n    floor_slabs = [item['brep'] for item in floor_data]\n    columns = [item['line'] for item in column_data]\n    stress_field = [item['point'] for item in stress_viz_data]\n    density_map = [item['point'] for item in stress_viz_data]\n    \n    print(\"\\n\" + \"=\"*50)\n    print(\"CREATING REFINED SOLID GEOMETRY...\")\n    print(\"=\"*50)\n    \n    # Generate THINNER solid geometry\n    thick_lattice_data = generator.thicken_lattice(_min_thickness, _max_thickness)\n    thick_lattice = [item['brep'] for item in thick_lattice_data]\n    \n    # Generate IRREGULAR thick floors\n    thick_floor_data = generator.create_thick_floors_irregular(_slab_thickness)\n    thick_floors = [item['brep'] for item in thick_floor_data]\n    \n    print(\"=\"*50)\n    print(\"GENERATION COMPLETE!\")\n    print(\"=\"*50)\n    print(\"Lattice lines: {}\".format(len(lattice_lines)))\n    print(\"THIN lattice members: {}\".format(len(thick_lattice)))\n    print(\"Irregular floor surfaces: {}\".format(len(floor_slabs)))\n    print(\"THICK irregular floors: {}\".format(len(thick_floors)))\n    print(\"Columns: {}\".format(len(columns)))\n    print(\"=\"*50)\n\nexcept Exception as e:\n    print(\"ERROR: {}\".format(str(e)))\n    import traceback\n    print(traceback.format_exc())",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}