{
  "source_url": "https://github.com/maxcollombin/rhino3dm-gltf/blob/99c024d44323eaede67c6c09845ac8ddb9318981/scripts/export_secteurs_geojson.py",
  "repo": "maxcollombin/rhino3dm-gltf",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "scripts/export_secteurs_geojson.py",
  "instruction": "Export secteurs geojson",
  "code": "import os\nimport json\nimport rhino3dm\nimport numpy as np\n\n# ------------------------------\n# Configuration\n# ------------------------------\ninput_file = \"./R21_3d.3dm\"\noutput_geojson = \"./output/secteurs.geojson\"\n\n# Secteurs √† extraire (bas√© sur votre liste)\nsecteurs_to_extract = [\n    \"S-SECTEURS\",\n    \"R21.1\", \"R21.2\", \"R21.3\", \"R21.4\", \"R21.5\", \"R21.6\", \"R21.7\", \"R21.8\", \"R21.9\",\n    \"R21.10\", \"R21.11\", \"R21.12\", \"R21.13\", \"R21.14\", \"R21.15\", \"R21.16\", \"R21.17\", \n    \"R21.18\", \"R21.19\", \"R21.20\", \"R21.21\"\n]\n\n# ------------------------------\n# Chargement du mod√®le\n# ------------------------------\nmodel = rhino3dm.File3dm.Read(input_file)\nif not model:\n    raise ValueError(f\"Erreur : Impossible de charger {input_file}\")\nprint(f\"Mod√®le charg√© : {input_file}\")\n\n# ------------------------------\n# Configuration transformation (m√™me que CityJSON)\n# ------------------------------\nSCALE = [1.0, 1.0, 1.0]\nTRANSLATE = [2592980.685, 1119281.703, 0.0]\n\n# ------------------------------\n# Fonctions utilitaires\n# ------------------------------\ndef rhino_point_to_coords(point):\n    \"\"\"Convertit un point Rhino3D en coordonn√©es [x, y] avec transformation\"\"\"\n    # Appliquer la transformation comme pour CityJSON\n    x_transformed = point.X * SCALE[0] + TRANSLATE[0]\n    y_transformed = point.Y * SCALE[1] + TRANSLATE[1]\n    return [x_transformed, y_transformed]\n\ndef extract_curve_coordinates(geometry):\n    \"\"\"Extrait les coordonn√©es d'une courbe Rhino3D\"\"\"\n    coordinates = []\n    \n    try:\n        # Essayer d'obtenir une polyligne\n        if hasattr(geometry, 'TryGetPolyline'):\n            try:\n                result = geometry.TryGetPolyline()\n                if isinstance(result, tuple) and len(result) >= 2:\n                    success, polyline = result[0], result[1]\n                    if success and polyline:\n                        coordinates = [rhino_point_to_coords(pt) for pt in polyline]\n                        # Fermer le polygone si n√©cessaire\n                        if len(coordinates) > 2 and coordinates[0] != coordinates[-1]:\n                            coordinates.append(coordinates[0])\n                        return [coordinates]  # GeoJSON Polygon format\n                elif hasattr(result, '__len__') and len(result) > 0:\n                    # R√©sultat direct de polyline\n                    coordinates = [rhino_point_to_coords(pt) for pt in result]\n                    if len(coordinates) > 2 and coordinates[0] != coordinates[-1]:\n                        coordinates.append(coordinates[0])\n                    return [coordinates]\n            except:\n                pass\n        \n        # Pour les courbes complexes, √©chantillonner des points\n        if hasattr(geometry, 'DivideByCount'):\n            try:\n                # Diviser la courbe en segments\n                points = geometry.DivideByCount(50, True)  # 50 points\n                if points:\n                    coordinates = [rhino_point_to_coords(pt) for pt in points]\n                    # Fermer le polygone si n√©cessaire\n                    if len(coordinates) > 2 and coordinates[0] != coordinates[-1]:\n                        coordinates.append(coordinates[0])\n                    return [coordinates]  # GeoJSON Polygon format\n            except:\n                pass\n        \n        # Fallback: essayer d'obtenir des points de contr√¥le\n        if hasattr(geometry, 'PointAtStart') and hasattr(geometry, 'PointAtEnd'):\n            try:\n                start = geometry.PointAtStart\n                end = geometry.PointAtEnd\n                # √âchantillonner la courbe\n                t_values = [i/20.0 for i in range(21)]  # 21 points\n                points = []\n                for t in t_values:\n                    pt = geometry.PointAt(t)\n                    points.append(rhino_point_to_coords(pt))\n                \n                if len(points) > 2:\n                    # Fermer si n√©cessaire\n                    if points[0] != points[-1]:\n                        points.append(points[0])\n                    return [points]\n            except:\n                pass\n    \n    except Exception as e:\n        print(f\"  Erreur extraction courbe: {e}\")\n    \n    return None\n\ndef convert_geometry_to_geojson(geometry, layer_name):\n    \"\"\"Convertit une g√©om√©trie Rhino3D en feature GeoJSON\"\"\"\n    feature = {\n        \"type\": \"Feature\",\n        \"properties\": {\n            \"layer\": layer_name,\n            \"type\": \"Secteur\"\n        },\n        \"geometry\": None\n    }\n    \n    # Traitement selon le type de g√©om√©trie\n    if isinstance(geometry, rhino3dm.Curve):\n        coordinates = extract_curve_coordinates(geometry)\n        if coordinates:\n            feature[\"geometry\"] = {\n                \"type\": \"Polygon\",\n                \"coordinates\": coordinates\n            }\n    \n    elif isinstance(geometry, rhino3dm.Point):\n        feature[\"geometry\"] = {\n            \"type\": \"Point\",\n            \"coordinates\": rhino_point_to_coords(geometry.Location)\n        }\n    \n    elif isinstance(geometry, rhino3dm.Mesh):\n        # Pour les mesh, cr√©er un polygone √† partir des vertices\n        vertices = []\n        for vertex in geometry.Vertices:\n            vertices.append(rhino_point_to_coords(vertex))\n        \n        if len(vertices) >= 3:\n            # Fermer le polygone\n            if vertices[0] != vertices[-1]:\n                vertices.append(vertices[0])\n            \n            feature[\"geometry\"] = {\n                \"type\": \"Polygon\",\n                \"coordinates\": [vertices]\n            }\n    \n    elif isinstance(geometry, rhino3dm.Brep):\n        # Pour les Brep, essayer d'extraire les contours\n        try:\n            # Obtenir les courbes de bordure\n            edges = geometry.Edges\n            if edges:\n                all_coords = []\n                for edge in edges:\n                    curve = edge.DuplicateCurve()\n                    if curve:\n                        coords = extract_curve_coordinates(curve)\n                        if coords:\n                            all_coords.extend(coords[0])\n                \n                if all_coords:\n                    # Fermer le polygone\n                    if all_coords[0] != all_coords[-1]:\n                        all_coords.append(all_coords[0])\n                    \n                    feature[\"geometry\"] = {\n                        \"type\": \"Polygon\",\n                        \"coordinates\": [all_coords]\n                    }\n        except:\n            pass\n    \n    return feature if feature[\"geometry\"] else None\n\n# ------------------------------\n# Extraction des secteurs\n# ------------------------------\nfeatures = []\nsecteurs_trouves = set()\n\nprint(\"üîç Recherche des secteurs...\")\n\nfor obj in model.Objects:\n    layer = model.Layers[obj.Attributes.LayerIndex]\n    layer_name = layer.Name\n    full_path = layer.FullPath\n    \n    # V√©rifier si ce calque correspond √† un secteur recherch√©\n    secteur_match = None\n    for secteur in secteurs_to_extract:\n        if layer_name == secteur or full_path.endswith(secteur) or secteur in full_path:\n            secteur_match = secteur\n            break\n    \n    if secteur_match:\n        secteurs_trouves.add(secteur_match)\n        \n        # Convertir la g√©om√©trie en feature GeoJSON\n        feature = convert_geometry_to_geojson(obj.Geometry, secteur_match)\n        \n        if feature:\n            # Ajouter des propri√©t√©s suppl√©mentaires\n            feature[\"properties\"].update({\n                \"secteur_id\": secteur_match,\n                \"full_path\": full_path,\n                \"layer_name\": layer_name\n            })\n            \n            features.append(feature)\n            print(f\"   {secteur_match}: {len(features)} g√©om√©tries trouv√©es\")\n\n# ------------------------------\n# Cr√©ation du GeoJSON\n# ------------------------------\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"crs\": {\n        \"type\": \"name\",\n        \"properties\": {\n            \"name\": \"urn:ogc:def:crs:EPSG::2056\"\n        }\n    },\n    \"features\": features,\n    \"metadata\": {\n        \"title\": \"Secteurs R21 - Extraction depuis Rhino3dm\",\n        \"description\": \"Secteurs extraits du mod√®le R21_3d.3dm avec transformation EPSG:2056\",\n        \"source\": input_file,\n        \"coordinate_system\": \"EPSG:2056 - CH1903+ / LV95\",\n        \"transformation\": {\n            \"scale\": SCALE,\n            \"translate\": TRANSLATE,\n            \"description\": \"Coordonn√©es transform√©es depuis le syst√®me local Rhino vers EPSG:2056\"\n        },\n        \"secteurs_recherches\": secteurs_to_extract,\n        \"secteurs_trouves\": list(secteurs_trouves),\n        \"secteurs_manquants\": list(set(secteurs_to_extract) - secteurs_trouves),\n        \"total_features\": len(features)\n    }\n}\n\n# ------------------------------\n# Sauvegarde\n# ------------------------------\nos.makedirs(os.path.dirname(output_geojson), exist_ok=True)\n\nwith open(output_geojson, \"w\", encoding=\"utf-8\") as f:\n    json.dump(geojson, f, indent=2, ensure_ascii=False)\n\n# ------------------------------\n# Rapport final\n# ------------------------------\nprint(f\"\\ Extraction termin√©e !\")\nprint(f\" Fichier cr√©√© : {output_geojson}\")\nprint(f\" Syst√®me de coordonn√©es : EPSG:2056 (CH1903+ / LV95)\")\nprint(f\" Transformation appliqu√©e : translate={TRANSLATE}\")\nprint(f\" Statistiques :\")\nprint(f\"  ‚Ä¢ Features cr√©√©es : {len(features)}\")\nprint(f\"  ‚Ä¢ Secteurs trouv√©s : {len(secteurs_trouves)}/{len(secteurs_to_extract)}\")\nprint(f\"  ‚Ä¢ Secteurs trouv√©s : {', '.join(sorted(secteurs_trouves))}\")\n\nif secteurs_trouves != set(secteurs_to_extract):\n    manquants = set(secteurs_to_extract) - secteurs_trouves\n    print(f\"   Secteurs non trouv√©s : {', '.join(sorted(manquants))}\")\n\nprint(f\"\\n GeoJSON cr√©√© avec succ√®s avec coordonn√©es EPSG:2056 !\")\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}