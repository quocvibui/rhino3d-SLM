{
  "source_url": "https://github.com/KeithSloan/ImportExport_3DM/blob/c63ae55e24aeeef6c1ff31316977cae779b9a6ce/freecad/importExport3DM/import3DM.py",
  "repo": "KeithSloan/ImportExport_3DM",
  "repo_stars": 3,
  "repo_description": null,
  "license": "NOASSERTION",
  "filepath": "freecad/importExport3DM/import3DM.py",
  "instruction": "************************************************************************** *                                                                        * *   Copyright (c) 2020 Keith Sloan <keith@sloan-home.co.uk>              * *                                                                        * *   This program is free software; you can redistribute it and/or modify * *   it under the terms of the GNU Lesser General Public License (LGPL)   * *   as published by the Free Software Foundation; either version 2 of    * *   the License, or (at your option) any later version.                  * *   for detail see the LICENCE text file.                                * *                                                                        * *   This program is distributed in the hope that it will be useful,      * *   but WITHOUT ANY WARRANTY; without even the implied warranty of       * *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        * *   GNU Library General Public License for more details.                 * *                                                                        * *   You should have received a copy of the GNU Library General Public    * *   License along with this program; if not, write to the Free Software  * *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 * *   USA                                                                  * *                                                                        * *   Acknowledgements :                                                   * *                                                                        * *                                                                        * **************************************************************************",
  "code": "# **************************************************************************\n# *                                                                        *\n# *   Copyright (c) 2020 Keith Sloan <keith@sloan-home.co.uk>              *\n# *                                                                        *\n# *   This program is free software; you can redistribute it and/or modify *\n# *   it under the terms of the GNU Lesser General Public License (LGPL)   *\n# *   as published by the Free Software Foundation; either version 2 of    *\n# *   the License, or (at your option) any later version.                  *\n# *   for detail see the LICENCE text file.                                *\n# *                                                                        *\n# *   This program is distributed in the hope that it will be useful,      *\n# *   but WITHOUT ANY WARRANTY; without even the implied warranty of       *\n# *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        *\n# *   GNU Library General Public License for more details.                 *\n# *                                                                        *\n# *   You should have received a copy of the GNU Library General Public    *\n# *   License along with this program; if not, write to the Free Software  *\n# *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 *\n# *   USA                                                                  *\n# *                                                                        *\n# *   Acknowledgements :                                                   *\n# *                                                                        *\n# *                                                                        *\n# **************************************************************************\n\nimport FreeCAD \nimport os, io, sys\nimport FreeCADGui\nimport Part, Draft, math\n\nfrom freecad.importExport3DM.objects3DM import ViewProvider\n\n# try:\n#  import rhino3dm as r3\n#\n# except:\n#  FreeCAD.Console.PrintError(\"You must install rhino3dm first !\")\n#  exit(0)\n\nimport rhino3dm as r3\n\nif open.__module__ == \"__builtin__\":\n    pythonopen = (\n        open  # to distinguish python built-in open function from the one declared here\n    )\n\n\ndef open(filename):\n    \"called when freecad opens a file.\"\n    global doc\n    docname = os.path.splitext(os.path.basename(filename))[0]\n    doc = FreeCAD.newDocument(docname)\n    if filename.lower().endswith(\".3dm\"):\n        process3DM(doc, filename)\n    return doc\n\n\ndef insert(filename, docname):\n    \"called when freecad imports a file\"\n    global doc\n    groupname = os.path.splitext(os.path.basename(filename))[0]\n    try:\n        doc = FreeCAD.getDocument(docname)\n    except NameError:\n        doc = FreeCAD.newDocument(docname)\n    if filename.lower().endswith(\".3dm\"):\n        process3DM(doc, filename)\n\n\ndef toFCvec(r3Dpnt):\n    return FreeCAD.Vector(r3Dpnt.X, r3Dpnt.Y, r3Dpnt.Z)\n\n\ndef toFCangle(center, start):\n    return math.atan((start.Y - center.Y) / (start.X - center.Y)) * math.pi / 180\n\n\nclass File3dm:\n    def __init__(self, path):\n        self.f3dm = r3.File3dm.Read(path)\n\n    def parse_objects(self, doc=None):\n        if not doc:\n            doc = FreeCAD.newDocument(\"3dm import\")\n        part = doc.addObject(\"App::Part\", \"Part\")\n        for i in range(len(self.f3dm.Objects)):\n            obj_fullname = \"{}\".format(self.f3dm.Objects[i].Geometry)\n            first_split = obj_fullname.split(\".\")\n            second_split = first_split[-1].split(\" \")\n            print(\"-----------------\\n{}\".format(second_split[0]))\n            obj = self.import_geometry(doc, self.f3dm.Objects[i].Geometry)\n            if obj:\n                part.addObject(obj)\n\n    def import_geometry(self, doc, geo):\n        print(\"Geometry type\")\n        print(type(geo))\n        #################################################\n        # Check instances and create FC object\n        # Some return obj others not?\n        # Think they should all return obj\n        # Need create_surface\n        #################################################\n        if isinstance(geo, r3.Brep):  # str(geo.ObjectType) == \"ObjectType.Brep\":\n            # Boundary Representation. A surface or polysurface along with trim curve informatio\n            print(\"Brep object\")\n            print(\"is solid : {}\".format(geo.IsSolid))\n            print(\"is manifold : {}\".format(geo.IsManifold))\n            print(\"is surface : {}\".format(geo.IsSurface))\n            print(\"has {} faces\".format(len(geo.Faces)))\n            print(\"has {} surfaces\".format(len(geo.Surfaces)))\n            print(\"has {} edges\".format(len(geo.Edges)))\n            print(dir(r3))\n            print(dir(geo))\n            print(geo.ObjectType)\n            if geo.IsSurface:\n                print(f\"Single surface : {len(geo.Surfaces)}\")\n                obj = doc.addObject(\"Part::Feature\", \"Brep Surface\")\n                obj.Shape = self.create_surface(geo.Surfaces[0]).toShape()\n            else:    \n                shapes = []\n                #for i in range(len(geo.Faces)):\n                #    print(geo.Faces[i])\n                #    s = self.create_surface(geo.Faces[i])\n                #    print(s)\n                #    shapes.append(s.toShape())\n                #    # print(\"Face {} has {} edges\".format(i,len(geo.Faces[i].Edges)))\n                #print(dir(geo.Surfaces[0]))\n                #for i in range(len(geo.Surfaces)):\n                #    print(geo.Surfaces[i])\n                #    s = self.create_surface(geo.Surfaces[i])\n                #    print(s)\n                #    shapes.append(s.toShape())\n                for i in range(len(geo.Edges)):\n                    print(geo.Edges[i])\n                    s = self.create_curve(geo.Edges[i])\n                    print(s)\n                    shapes.append(s.toShape())\n                com = Part.Compound(shapes)\n                obj = doc.addObject(\"Part::Feature\", \"Edges\")\n                obj.Shape = com\n                # \t        \tshapes = []\n                # \t\t\tfor i in range(len(geo.Edges)):\n                # \t\t\t\t#print(geo.Faces[i])\n                # \t\t\t\tc = self.create_curve(geo.Edges[i])\n                # \t\t\t\tshapes.append(c.toShape())\n                # \t\t\tcom = Part.Compound(shapes)\n                # \t\t\tobj = doc.addObject(\"Part::Feature\",\"Edges\")\n                # \t\t\tobj.Shape = com\n            return obj\n\n        if isinstance(geo, r3.LineCurve):  # Must be before Curve\n            print(\"Line Curve\")\n            # print(dir(geo))\n            obj = doc.addObject(\"Part::Line\", \"Line Curve?\")\n            # print(dir(obj))\n            obj.X1 = geo.PointAtStart.X\n            obj.Y1 = geo.PointAtStart.Y\n            obj.Z1 = geo.PointAtStart.Z\n            obj.X2 = geo.PointAtEnd.X\n            obj.Y2 = geo.PointAtEnd.Y\n            obj.Z2 = geo.PointAtEnd.Z\n            obj.recompute()\n            return\n\n        if isinstance(geo, r3.NurbsCurve):  # Must be before Curve\n            print(\"NurbsCurve Object\")\n            # print(dir(geo))\n            obj = doc.addObject(\"Part::FeaturePython\", \"NurbsCurve\")\n            #obj = doc.addObject(\"Part::BSplineCurve\", \"NurbsCurve\")\n            obj.Shape = self.create_curve(geo).toShape()\n            #ViewProvider(obj.ViewObject)\n            ViewProvider(obj)\n            print(obj.Shape.TypeId)\n            print(obj.Shape.ShapeType)\n            print(dir(obj.Shape))\n            obj.recompute()\n            return obj\n\n        if isinstance(geo, r3.ArcCurve):\n            print(\"Arc Curve Object\")\n            obj = doc.addObject(\"Part::Circle\", \"Arc\")\n            # print(type(geo.Arc.Center))\n            obj.Placement.Base = toFCvec(geo.Arc.Center)\n            obj.Radius = geo.Radius\n            if int(FreeCAD.Version()[3].split()[0]) > 29603:\n                obj.Angle1 = startAngle = toFCangle(geo.Arc.Center, geo.PointAtStart)\n                obj.Angle2 = startAngle + geo.Arc.AngleDegree\n            else:\n                obj.Angle0 = startAngle = toFCangle(geo.Arc.Center, geo.PointAtStart)\n                obj.Angle1 = startAngle + geo.Arc.AngleDegrees\n            # print(dir(geo))\n            obj.recompute()\n            return obj\n\n        if isinstance(geo, r3.BezierCurve):\n            print(\"Bezier Curve Object\")\n            print(dir(geo))\n            obj = doc.addObject(\"Part::Feature\", \"Bezier\")\n            obj.Shape = self.create_curve(geo).toShape()\n            obj.recompute()\n            return\n\n        if isinstance(geo, r3.PolylineCurve):\n            print(\"PolyLineCurve Object\")\n            print(\"Polgon Line?\")\n            # print(dir(geo))\n            print(\"Is Polyline : \" + str(geo.IsPolyline()))\n            print(\"Point Count : \" + str(geo.PointCount))\n            # pl = geo.ToPolyline()\n            # print(pl)\n            # print(dir(pl))\n            obj = doc.addObject(\"Part::Polygon\", \"PolyLine Curve?\")\n            # print(dir(obj))\n            pList = []\n            for i in range(geo.PointCount):\n                p = geo.Point(i)\n                # print(p.X)\n                # print(p.Y)\n                # print(p.Z)\n                pList.append(FreeCAD.Vector(p.X, p.Y, p.Z))\n            # print(pList)\n            # obj.Shape = Part.makePolygon(pList)\n            obj.Nodes = pList\n            obj.recompute()\n            return\n\n        if isinstance(geo, r3.PolyCurve):\n            print(\"PolyCurve Object\")\n            # self.printCurveInfo(geo)\n            obj = doc.addObject(\"Part::Feature\", \"PolyCurve\")\n            obj.Shape = self.create_curve(geo).toShape()\n            obj.recompute()\n            # print(dir(geo))\n            return\n\n        if isinstance(geo, r3.Ellipse):\n            print(\"Ellipse Object\")\n            print(dir(geo))\n            return\n\n        if isinstance(geo, r3.Bitmap):\n            print(\"Bitmap Object\")\n            print(dir(geo))\n            return\n\n        if isinstance(geo, r3.Box):\n            print(\"Box Object\")\n            print(dir(geo))\n            return\n\n        if isinstance(geo, r3.Circle):\n            print(\"Circle Object\")\n            print(dir(geo))\n            return\n\n        if isinstance(geo, r3.Cone):\n            print(\"Cone Object\")\n            print(dir(geo))\n            return\n\n        if isinstance(geo, r3.Curve):\n            print(\"Curve object\")\n            self.printCurveInfo(geo)\n            print(geo.ToNurbsCurve())\n            # nc = geo.ToNurbsCurve()\n            # print(nc)\n            # print(dir(nc))\n            # print(nc.Degree)\n            cpc = geo.CreateControlPointCurve()\n            print(dir(cpc))\n            # obj = doc.addObject(\"Part::Feature\",\"Curve\")\n            # obj.Shape = Part.makeself.create_curve(geo).toShape()\n            # print(inspect.getargspec(nc.CreateControlPointCurve))\n            # print(dir(nc.CreateControlPointCurve))\n            return\n\n        if isinstance(geo, r3.Cylinder):\n            print(\"Cylinder Object\")\n            print(dir(geo))\n            return\n\n        if isinstance(geo, r3.Extrusion):\n           print(\"Extrusion\")\n           print(dir(geo))\n           print('Is Cylinder : '+str(geo.IsCylinder()))\n           print(geo.NormalAt)\n           print(geo.PathStart)\n           print(geo.PathEnd)\n           print(geo.PathTangent)\n           print(geo.PointAt)\n           print(geo.GetPathPlane)\n           print('Profile Count : '+str(geo.ProfileCount))\n           # Create Part ToShape from profile\n           # Create new Shape from Extrude of ToShape\n           # Create Part::PythonFeature & Return\n           height = geo.PathStart.Z - geo.PathEnd.Z\n           print(f'Height : {height}')\n           for i in range(geo.ProfileCount) :\n               print(i)\n               c = geo.Profile3d(i,0.0)\n               print(f'Object type : {c.ObjectType}')\n               print(c)\n               print(c.ObjectType)\n               if isinstance(c, r3.Curve):\n                  self.printCurveInfo(c)\n               # Need to create FreeCAD TopoShape depending on type\n               print('Tests')\n               if c.IsArc() == True :\n                  print('Arc')\n                  print('Not yet Handled')\n               elif c.IsCircle() == True :\n                  print('Circle')\n                  print(c.Radius)\n                  print('Not yet Handled')\n               elif c.IsEllipse() == True :\n                  print('Ellipse')\n                  print('Not yet Handled')\n               elif c.IsPolyline() == True :\n                  # Call ToLine and create FreeCAD TopoShape from Line\n                  print('Polyline')\n                  print(dir(c))\n                  l = c.ToPolyline()\n                  print(dir(l))\n                  print(l.SegmentCount)\n                  points = []\n                  for i in range(0,l.SegmentCount):\n                      print(l.PointAt(i))\n                      print(dir(l.PointAt(i)))\n                      p = l.PointAt(i)\n                      points.append((p.X, p.Y, p.Z))\n                  points.append(points[0])\n                  #wire = Draft.make_wire(points, closed=True, placement=None, \\\n                  #       face=True, support=None)\n                  \n                  obj = doc.addObject(\"Part::FeaturePython\",\"Extrusion\")\n                  poly = Part.makePolygon(points)\n                  obj.Shape = poly\n                  #face = Part.Face(Part.Wire(poly))\n                  #obj.Shape = face.extrude(FreeCAD.Vector(0.0, 0.0, height))\n                  return\n                 \n           print(geo.Profile3d)\n           if geo.IsCylinder() == True :\n              height = geo.PathStart.Z - geo.PathEnd.Z\n              print('Height : '+str(height))\n              c = geo.Profile3d(0,0.0)\n              radius = c.Radius\n              print('Radius : '+str(radius))\n              obj = doc.addObject(\"Part::Cylinder\",\"Extruded Cylinder\")\n              obj.Height = height\n              obj.Radius = radius\n              obj.recompute()\n           #print(dir(geo))\n           return\n\n        if isinstance(geo, r3.Mesh):\n            print(\"Mesh Object\")\n            return self.create_mesh(doc, geo)\n\n        if isinstance(geo, r3.NurbsSurface):\n            print(\"NurbsSurface Object\")\n            print(dir(geo))\n            obj = doc.addObject(\"Part::Feature\", \"NurbsSurface\")\n            obj.Shape = self.create_nurbs_surface(geo).toShape()\n            return obj\n\n        if isinstance(geo, r3.PointCloud):\n            print(\"PointCloud Object\")\n            print(dir(geo))\n            return\n\n        if isinstance(geo, r3.Surface):\n            print(\"Surface Object\")\n            print(geo.IsCylinder)\n            print(geo.IsSolid)\n            print(dir(geo))\n            return\n\n        print(\"Not yet handled\")\n        print(dir(geo))\n\n    def printCurveInfo(self, geo):\n        print(\"Curve Info\")\n        print(dir(geo))\n        print('IsArc     : ',geo.IsArc())\n        print('IsCircle  : ',geo.IsCircle())\n        print('IsEllipse : ',geo.IsEllipse())\n        print('IsPolyline : ',geo.IsPolyline())\n        print(geo.CurvatureAt)\n        print(dir(geo.CurvatureAt))\n        if hasattr(geo,'SegmentCount') :\n           print(geo.SegmentCount)\n           print(geo.SegmentCurve)\n           print(dir(geo.SegmentCurve))\n           print(geo.SegmentCurveParameter)\n           print(dir(geo.SegmentCurveParameter))\n           print(geo.SegmentIndex)\n           print(dir(geo.SegmentIndex))\n        #cpc = geo.CreateControlPointCurve()\n        #print(dir(cpc))\n        nc = geo.ToNurbsCurve()\n        print(dir(nc))\n\n    ##########################################\n    #\n    # Create functions return a Part Shape\n    #\n    ###########################################    \n    def create_curve(self, edge):\n        # Curve in Rhino\n        #\n        # Abstraxt - circles, arcs, ellipses, etc\n        #\n        # curves - NurbsCurve  LineCurve, a PolylineCurve, an ArcCurve\n        #\n        print(dir(edge))\n        print(f\"edge type = {edge.ObjectType}  IsPolyline = {edge.IsPolyline()}\")\n        if hasattr(edge,\"Points\"):\n            print(f\"Points {edge.Points}\")\n        #print(f\"Control Points List\")\n        #cpl = edge.CreateControlPointCurve()\n        #print(dir(cpl))\n        #print(dir(edge.CreateControlPointCurve))\n        #cpc = edge.CreateControlPointCurve(edge.Points)\n        #print(f\"Control Point Curve\")\n        #print(dir(cpc))\n        print(\"Create Curve\")\n        nc = edge.ToNurbsCurve()\n        #nc = edge\n        print(dir(nc))\n        print(f\"nc hasattr(Polyline) {hasattr(nc, 'IsPolyline')}\")\n        pts = []\n        weights = []\n        for u in range(len(nc.Points)):\n            p = nc.Points[u]\n            # print(FreeCAD.Vector(p.X,p.Y,p.Z))\n            pts.append(FreeCAD.Vector(p.X / p.W, p.Y / p.W, p.Z / p.W))\n            weights.append(p.W)\n        ku, mu = self.getFCKnots(nc.Knots)\n        print(f\"FreeCAD knots {ku} {mu}\")\n        periodic = False  # mu[0] <= nu.Degree(0)\n        bs = Part.BSplineCurve()\n        bs.buildFromPolesMultsKnots(pts, mu, ku, periodic, nc.Degree, weights)\n        if mu[0] < (nc.Degree + 1):\n            bs.setPeriodic()\n        return bs\n\n    def create_surface(self, surf):\n        # Surface could be a Plane \n        print(f\"Create Surface {surf.ObjectType}\")\n        print(dir(surf))\n        nu = surf.ToNurbsSurface()\n        print(\"{} x {}\".format(nu.Degree(0), nu.Degree(1)))\n        pts = []\n        weights = []\n        print(\"Control Points\")\n        print(\"CountU : \" + str(nu.Points.CountU))\n        print(\"CountV : \" + str(nu.Points.CountV))\n        for u in range(nu.Points.CountU):\n            row = []\n            wrow = []\n            for v in range(nu.Points.CountV):\n                p = nu.Points[u, v]\n                print(FreeCAD.Vector(p.X, p.Y, p.Z))\n                row.append(FreeCAD.Vector(p.X / p.W, p.Y / p.W, p.Z / p.W))\n                wrow.append(p.W)\n            pts.append(row)\n            weights.append(wrow)\n            print(\"Knots\")\n        ku, mu = self.getFCKnots(nu.KnotsU)\n        kv, mv = self.getFCKnots(nu.KnotsV)\n        uperiodic = False  # mu[0] <= nu.Degree(0)\n        vperiodic = False  # mv[0] <= nu.Degree(1)\n        print(list(nu.KnotsU))\n        print(\"ku mu\")\n        print(ku, mu)\n        print(\"kv mv\")\n        print(kv, mv)\n        print(\"Flat knots\")\n        vflatknots = list(nu.KnotsV)\n        print(\"{}\\n{}\".format(vflatknots, vflatknots))\n        bs = Part.BSplineSurface()\n        bs.buildFromPolesMultsKnots(\n            pts,\n            mu,\n            mv,\n            ku,\n            kv,\n            uperiodic,\n            vperiodic,\n            nu.Degree(0),\n            nu.Degree(1),\n            weights,\n        )\n        if mu[0] < (nu.Degree(0) + 1):\n            bs.setUPeriodic()\n        if mv[0] < (nu.Degree(1) + 1):\n            bs.setVPeriodic()\n        return bs\n\n    def create_nurbs_surface(self, nurbSurf):\n        #print(dir(nurbSurf))\n        # Already a surface ? change tu being passed nu abd\n        # change create_surface to call ??\n        #nu = surf.ToNurbsSurface()\n        nu = nurbSurf\n        print(\"{} x {}\".format(nu.Degree(0), nu.Degree(1)))\n        pts = []\n        weights = []\n        print(\"Control Points\")\n        print(\"CountU : \" + str(nu.Points.CountU))\n        print(\"CountV : \" + str(nu.Points.CountV))\n        for u in range(nu.Points.CountU):\n            row = []\n            wrow = []\n            for v in range(nu.Points.CountV):\n                p = nu.Points[u, v]\n                print(FreeCAD.Vector(p.X, p.Y, p.Z))\n                row.append(FreeCAD.Vector(p.X / p.W, p.Y / p.W, p.Z / p.W))\n                wrow.append(p.W)\n            pts.append(row)\n            weights.append(wrow)\n        print(\"Knots\")\n        ku, mu = self.getFCKnots(nu.KnotsU)\n        kv, mv = self.getFCKnots(nu.KnotsV)\n        uperiodic = False  # mu[0] <= nu.Degree(0)\n        vperiodic = False  # mv[0] <= nu.Degree(1)\n        print(list(nu.KnotsU))\n        print(\"ku mu\")\n        print(ku, mu)\n        print(\"kv mv\")\n        print(kv, mv)\n        print(\"Flat knots\")\n        vflatknots = list(nu.KnotsV)\n        print(\"{}\\n{}\".format(vflatknots, vflatknots))\n        bs = Part.BSplineSurface()\n        bs.buildFromPolesMultsKnots(\n            pts,\n            mu,\n            mv,\n            ku,\n            kv,\n            uperiodic,\n            vperiodic,\n            nu.Degree(0),\n            nu.Degree(1),\n            weights,\n        )\n        if mu[0] < (nu.Degree(0) + 1):\n            bs.setUPeriodic()\n        if mv[0] < (nu.Degree(1) + 1):\n            bs.setVPeriodic()\n        return bs\n\n    def getFCKnots(self, fknots):\n        print(f\"Knots {fknots}\")\n        k = list(fknots)\n        mults = []\n        knots = list(set(k))\n        knots.sort()\n        for kn in knots:\n            mults.append(k.count(kn))\n        mults[0] += 1\n        mults[-1] += 1\n        return knots, mults\n\n    def create_mesh(self, doc, r3mesh):\n        # Return Object Mesh\n        import Mesh\n\n        fcMesh = Mesh.Mesh()\n        obj = doc.addObject(\"Mesh::Feature\")\n        obj.Mesh = Mesh.Mesh()\n        print(\"Quad Count : \" + str(r3mesh.Faces.QuadCount))\n        print(\"Triangle Count : \" + str(r3mesh.Faces.TriangleCount))\n        # FreeCAD only supports Triangles\n        print(r3mesh.Faces.ConvertQuadsToTriangles())\n        print(len(r3mesh.Faces))\n        print(\"Count : \" + str(r3mesh.Faces.Count))\n        print(\"Quad Count : \" + str(r3mesh.Faces.QuadCount))\n        print(\"Vertices Count : \" + str(len(r3mesh.Vertices)))\n        # print(type(r3mesh.Faces))\n        for m in range(r3mesh.Faces.TriangleCount):\n            # print('Face')\n            mf = r3mesh.Faces[m]\n            # print(type(mf))\n            # print(dir(mf))\n            fval = ()\n            # 3dm files always have 4 vertex values even for triangles\n            for r in range(0, 3):\n                f = mf[r]\n                # print('X : '+str(r3mesh.Vertices[f].X)+ \\\n                #     ' Y : '+str(r3mesh.Vertices[f].Y)+ \\\n                #     ' Z : '+str(r3mesh.Vertices[f].Z))\n                fval = fval + (\n                    float(r3mesh.Vertices[f].X),\n                    float(r3mesh.Vertices[f].Y),\n                    float(r3mesh.Vertices[f].Z),\n                )\n            fcMesh.addFacet(*fval)\n        obj.Mesh = fcMesh\n\n\ndef process3DM(doc, filename):\n    FreeCAD.Console.PrintMessage(\"Import 3DM file : \" + filename + \"\\n\")\n    FreeCAD.Console.PrintMessage(\"Import3DM Version 0.01\\n\")\n\n    att = [\n        \"ApplicationName\",\n        \"ApplicationUrl\",\n        \"ApplicationDetails\",\n        \"CreatedBy\",\n        \"LastEditedBy\",\n        \"Revision\",\n    ]\n\n    fi = File3dm(filename)\n    fi.parse_objects(doc)\n    FreeCADGui.SendMsgToActiveView(\"ViewFit\")\n\n    # pathName = os.path.dirname(os.path.normpath(filename))\n\n    FreeCAD.Console.PrintMessage(\"3DM File Imported\\n\")\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}