{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_ProjectCrvsOntoBreps.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_ProjectCrvsOntoBreps.py",
  "instruction": "This script is an alternative to _Project.\r\nSegments of polycurves can be projected individually, avoiding merges through joints.\r\nProjection of curves onto planar surfaces of polyface breps is more...",
  "code": "\"\"\"\r\nThis script is an alternative to _Project.\r\nSegments of polycurves can be projected individually, avoiding merges through joints.\r\nProjection of curves onto planar surfaces of polyface breps is more similar to loose projection.\r\nFor increased accuracy, all curves projected to planar faces are projected loose\r\nto the TryGetPlane plane, then split at the intersections with the monoface brep's edges.\r\nWith AttemptRebuild enabled, curve will be projected at half the tolerance,\r\nand a rebuild (to uniform) of the projected curve will be attempted at half tolerance.\r\nIf not successful, the projection at full tolerance will be used.\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums, https://discourse.mcneel.com/\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n191124-25: Created.\r\n...\r\n220821: Modified an option default value.\r\n230720: Now passes fTol_Proj to a method instead of ModelAbsoluteTolerance.\r\n231106: Improved selection routine for faces.\r\n240712-15: Refactored and modified behavior of simplification routines.\r\n241107, 241225: Fixed bugs created during 240712-15 refactoring.\r\n241226-28: Fixed bugs, added another tolerance option, and refactored.\r\n250101: Bug fix. Modified some hard-coded tolerance values.\r\n250105: Removed wait after preselection (was only for objects to project).\r\n\r\nTODO:\r\n    Reviewing tolerance values passed to:\r\n        rg.Intersect.Intersection.CurveCurve\r\n        rg.Curve.ProjectToBrep\r\n        removeShortCrvsInList\r\n        convertLinearNurbsToLinesInList\r\n        rg.Intersect.Intersection.ProjectPointsToBreps\r\n\r\n    Determine solution for when a loose projected curve doesn't lie within\r\n    the projection boundary of the brep.\r\n    Possible solutions:\r\n        1. Keep brep-missing Greville points at their non-projected locations.\r\n        2. Trim the curve before projection.\r\n    \r\n    Add support for projections of curves in overlapping directions, e.g., projecting a circle parallel to its plane.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\n\r\n\r\nclass Opts:\r\n    \r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bProjectCrvSegs'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = \"Project\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'WholeCrv', 'CrvSegs')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fTol_Proj'; keys.append(key)\r\n    values[key] = 0.25 * sc.doc.ModelAbsoluteTolerance\r\n    names[key] = 'ProjTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.ModelUnitSystem)\r\n\r\n    key = 'bLoose'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bPostProcess'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fTol_MinLength'; keys.append(key)\r\n    values[key] = sc.doc.ModelAbsoluteTolerance\r\n    names[key] = 'MinLenTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.ModelUnitSystem)\r\n\r\n    key = 'bOnlyLinesAndCubicNurbs'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bTryGetArcs'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAcceptRational'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bTryRebuildOthersUniform'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bJoinPerInputCrv'; keys.append(key)\r\n    values[key] = True\r\n    #names[key] = 'Join'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDeleteInput'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iOutputLayer'; keys.append(key)\r\n    values[key] = 1\r\n    listValues[key] = (\r\n        'Input',\r\n        'Current',\r\n        'TargetObject',\r\n        )\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iDirection'; keys.append(key)\r\n    values[key] = 2\r\n    listValues[key] = (\r\n        'CPlaneX',\r\n        'CPlaneY',\r\n        'CPlaneZ',\r\n        'WorldX',\r\n        'WorldY',\r\n        'WorldZ',\r\n        'View',\r\n        'Custom',\r\n        )\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'vectCustom'; keys.append(key)\r\n    values[key] = sc.doc.Views.ActiveView.ActiveViewport.ConstructionPlane().ZAxis\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fTol_Proj':\r\n            # Rhino.RhinoMath.ZeroTolerance == 2**-32 in RC >= V7. It is 1.0e-12 in previous versions.\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                return\r\n\r\n            if cls.riOpts[key].CurrentValue <= 2**-32:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = 2**-32\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                return\r\n\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n\r\n        if key == 'fTol_MinLength':\r\n            # Rhino.RhinoMath.ZeroTolerance == 2**-32 in RC >= V7. It is 1.0e-12 in previous versions.\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                return\r\n\r\n            if cls.riOpts[key].CurrentValue <= 2**-32:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = 2**-32\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                return\r\n\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput(rdObjs_toHighlight, sPrompt, rdGeomFilter):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n    go.SetCommandPrompt(prompt=sPrompt)\r\n\r\n    go.GeometryFilter = rdGeomFilter\r\n\r\n    #go.AlreadySelectedObjectSelect = True # Default is False\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n\r\n    idxs_Opt = {}\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    #bPreselectedObjsChecked = False\r\n    go.EnablePreSelect(True, ignoreUnacceptablePreselectedObjects=True)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('bProjectCrvSegs')\r\n        addOption('fTol_Proj')\r\n        addOption('bLoose')\r\n        if not Opts.values['bLoose']:\r\n            addOption('bPostProcess')\r\n            if Opts.values['bPostProcess']:\r\n                addOption('fTol_MinLength')\r\n                addOption('bOnlyLinesAndCubicNurbs')\r\n                if not Opts.values['bOnlyLinesAndCubicNurbs']:\r\n                    addOption('bTryGetArcs')\r\n                    addOption('bAcceptRational')\r\n                    addOption('bTryRebuildOthersUniform')\r\n        addOption('bJoinPerInputCrv')\r\n        addOption('bDeleteInput')\r\n        addOption('iOutputLayer')\r\n        addOption('iDirection')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        #if not bPreselectedObjsChecked:\r\n        #    go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n        #    bPreselectedObjsChecked = True\r\n        #    if go.ObjectsWerePreselected:\r\n        #        continue\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        # An option was selected or a number was entered.\r\n        if res == ri.GetResult.Number:\r\n            key = 'fTol_Proj'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        if go.Option().Index == idxs_Opt['iOutputLayer']:\r\n            Opts.values['iOutputLayer'] = (\r\n                    go.Option().CurrentListOptionIndex)\r\n        elif go.Option().Index == idxs_Opt['iDirection']:\r\n            Opts.values['iDirection'] = (\r\n                    go.Option().CurrentListOptionIndex)\r\n\r\n            if Opts.listValues['iDirection'][go.Option().CurrentListOptionIndex] == 'Custom':\r\n                rc = rs.GetLine(\r\n                    mode=1, point=None,\r\n                    message1='Projection direction',\r\n                    message3='Second direction point',\r\n                    )\r\n                if not rc:\r\n                    Opts.values['iDirection'] = 0\r\n                else:\r\n                    Opts.values['vectCustom'] = rg.Vector3d(rc[1] - rc[0])\r\n                    Opts.values['vectCustom'].Unitize()\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef coerceBrep(rhObj):\r\n    if isinstance(rhObj, rg.Brep):\r\n        return rhObj\r\n    elif isinstance(rhObj, rg.GeometryBase):\r\n        geom = rhObj\r\n    elif isinstance(rhObj, rd.ObjRef):\r\n        geom = rhObj.Geometry()\r\n        if rhObj.GeometryComponentIndex.ComponentIndexType == rg.ComponentIndexType.BrepFace:\r\n            geom = geom.DuplicateFace(duplicateMeshes=False)\r\n    elif isinstance(rhObj, Guid):\r\n        rdObj = sc.doc.Objects.FindId(rhObj) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhObj)\r\n        geom = rdObj.Geometry\r\n    else:\r\n        return\r\n\r\n    if isinstance(geom, rg.Brep):\r\n        return geom\r\n\r\n\r\ndef formatDistance(fDistance):\r\n    try:\r\n        fDistance = float(fDistance)\r\n    except:\r\n        return \"(No deviation provided)\"\r\n\r\n    if fDistance < 0.001:\r\n        return \"{:.2e}\".format(fDistance)\r\n    else:\r\n        return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\ndef projectCurve_Loose(rgCrv_In, rgB, vectDir, fTol_Proj=None, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rgC0\r\n        rgB\r\n        vectDir\r\n        fTol_Proj: float = Tolerance of projected control points, not the maximum\r\n                           deviation of curves to surfaces.\r\n        bDebug: bool\r\n    \"\"\"\r\n\r\n    #TODOif fTol_Proj is None: fTol_Proj = 1e-6#0.1 * sc.doc.ModelAbsoluteTolerance\r\n\r\n\r\n    rgCs_Out = []\r\n\r\n    # Duplicate curve and translate Greville points to projected locations.\r\n    nc_toProj = rgCrv_In.ToNurbsCurve()\r\n\r\n    grPts1 = []\r\n    for gr in nc_toProj.GrevillePoints(all=False):\r\n        pts_Proj = rg.Intersect.Intersection.ProjectPointsToBreps(\r\n            breps=[rgB],\r\n            points=[gr],\r\n            direction=vectDir,\r\n            tolerance=fTol_Proj)\r\n        if pts_Proj:\r\n            grPts1.append(pts_Proj[0])\r\n        else:\r\n            grPts1.append(gr)\r\n            \r\n        #sc.doc.Objects.AddPoint(pts_Proj[0])\r\n    #sc.doc.Views.Redraw(); 1/0\r\n\r\n    nc_toProj.SetGrevillePoints(grPts1)\r\n\r\n    rgCs_Out.append(nc_toProj)\r\n\r\n\r\n    return rgCs_Out\r\n\r\n    # TODO: Move the following elsewhere.\r\n\r\n\r\n\r\n    # This will clean up any short segments that had passed the previous\r\n    # checks, but have been deformed to short segments after JoinCurves.\r\n    # _Project doesn't address this problem.\r\n    removeShortSegmentsInEachCrv_inList(rgCs_Proj_Joined_ThisC0, fTol_MinLength)\r\n\r\n    return rgCs_Proj_Joined_ThisC0\r\n\r\n\r\ndef removeShortCrvsInList(rgCrvs, tolerance):\r\n    bFound = False\r\n    i = len(rgCrvs) - 1\r\n    while i >= 0:\r\n        sc.escape_test()\r\n\r\n        rgC = rgCrvs[i]\r\n\r\n        length = rgC.GetLength()\r\n\r\n        if length < tolerance:\r\n            bFound = True\r\n            del rgCrvs[i]\r\n            rgC.Dispose()\r\n            #print(\"{}-long curve created at {} tolerance ignored.\".format(\r\n            #    formatDistance(length),\r\n            #    formatDistance(tolerance)))\r\n\r\n        i -= 1\r\n\r\n    return bFound\r\n\r\n\r\ndef explodePolyCrv(pc):\r\n    pc.RemoveNesting()\r\n    rv = pc.Explode()\r\n    if not rv:\r\n        raise Exception(\"{} resulted from rg.PolyCurve.Explode.\".format(rv))\r\n    return rv\r\n\r\n\r\ndef explodePolyCrvsInList(rgCrvs):\r\n    bFound = False\r\n    i = len(rgCrvs) - 1\r\n    while i >= 0:\r\n        sc.escape_test()\r\n\r\n        rgC = rgCrvs[i]\r\n\r\n        if isinstance(rgC, rg.PolyCurve):\r\n            rv = explodePolyCrv(rgC)\r\n            if not rv:\r\n                1/0\r\n            else:\r\n                bFound = True\r\n                rgCrvs[i:i+1] = rv\r\n                rgC.Dispose()\r\n\r\n        i -= 1\r\n\r\n    return bFound\r\n\r\n\r\ndef convertCrvsForPeriodicInList(rgCrvs):\r\n    bFound = False\r\n    for i, rgC in enumerate(rgCrvs):\r\n        if rgC.IsArc():\r\n            print(rgC.GetType().Name)\r\n            1/0\r\n            bFound = True\r\n        elif isinstance(rgC, rg.NurbsCurve):\r\n            continue\r\n        else:\r\n            print(rgC.GetType().Name)\r\n            1/0\r\n            rgCrvs[i] = rgC.ToNurbsCurve()\r\n            rgC.Dispose()\r\n            bFound = True\r\n\r\n    return bFound\r\n\r\n\r\ndef convertLinearNurbsToLinesInList(rgCrvs, tolerance=1e-6):\r\n    bFound = False\r\n    for i, c in enumerate(rgCrvs):\r\n        if isinstance(c, rg.NurbsCurve):\r\n            if not c.IsClosed:\r\n                if c.IsLinear(tolerance):\r\n                    rgCrvs[i] = rg.LineCurve(\r\n                        c.PointAtStart,\r\n                        c.PointAtEnd)\r\n                    #sEval = \"c.IsDocumentControlled\"; print(sEval,'=',eval(sEval))\r\n                    c.Dispose()\r\n                    bFound = True\r\n    return bFound\r\n\r\n\r\ndef removeShortSegmentsInEachCrv_inList(rgCrvs, tolerance):\r\n    # rgCrvs: list or array\r\n    bFound = False\r\n    for i, c in enumerate(rgCrvs):\r\n        if c.RemoveShortSegments(tolerance):\r\n            bFound = True\r\n    return bFound\r\n\r\n\r\ndef projectCurve_Greville_pts_to_plane(rgC_In, rgPlane, vectDir):\r\n    rgC_Working = rgC_In.ToNurbsCurve()\r\n\r\n    grPts1 = []\r\n\r\n    for gr0 in rgC_Working.GrevillePoints(all=False):\r\n\r\n        rgLine = rg.Line(gr0, vectDir)\r\n        bSuccess, tLine = Rhino.Geometry.Intersect.Intersection.LinePlane(\r\n            rgLine, rgPlane);\r\n        if not bSuccess:\r\n            s  = \"Point missed the plane when projecting loose to a plane.\"\r\n            s += \"  Check results for accuracy.\"\r\n            print(s)\r\n            sEval = \"rgC_Working.IsDocumentControlled\"; print(sEval,'=',eval(sEval))\r\n            rgC_Working.Dispose()\r\n            return\r\n\r\n        gr1 = rgLine.PointAt(tLine);\r\n\r\n        grPts1.append(gr1)\r\n\r\n    rgC_Working.SetGrevillePoints(grPts1)\r\n    \r\n    return rgC_Working\r\n\r\n\r\ndef trimCurves_to_brep_edges(rgC_fromProjectLoose, rgB, fTol_Proj):\r\n    \"\"\"\r\n    Returns list(rg.Curve)\r\n    \"\"\"\r\n\r\n    ts_atSplits = []\r\n\r\n    for rgEdge in rgB.Edges:\r\n        crvinters = rg.Intersect.Intersection.CurveCurve(\r\n            rgC_fromProjectLoose,\r\n            rgEdge,\r\n            tolerance=fTol_Proj,\r\n            overlapTolerance=0.0)\r\n        if crvinters.Count == 0: continue # to next curve.\r\n        for crvinter in crvinters:\r\n            ts_atSplits.append(crvinter.ParameterA)\r\n\r\n    if not ts_atSplits: \r\n        # Presuming projected curve lies completely on the face.\r\n        return [rgC_fromProjectLoose]\r\n\r\n    segs2_PostSplit = rgC_fromProjectLoose.Split(ts_atSplits)\r\n\r\n    # Determine which of the split project-to-plane curves should be kept.\r\n\r\n    rgCs_Out = []\r\n\r\n    for rgC in segs2_PostSplit:\r\n        midDomainPt = rgC.PointAt(rgC.Domain.Mid)\r\n        closestPt = rgB.ClosestPoint(midDomainPt)\r\n\r\n        dist = midDomainPt.DistanceTo(closestPt)\r\n        #print(dist)\r\n\r\n        if dist <= 1e-5:\r\n            rgCs_Out.append(rgC)\r\n\r\n    return rgCs_Out\r\n\r\n\r\n\r\n    # Old method. Need curves projected to brep of face.\r\n\r\n    pts_toDetermineTrims = []\r\n    for rgC in rgCs_Proj_This_face_or_plane:\r\n        pts_toDetermineTrims.append(rgC.PointAt(rgC.Domain.Mid))\r\n        rgC.Dispose()\r\n\r\n    for rgC in segs2_PostSplit:\r\n        for pt in pts_toDetermineTrims:\r\n            bSuccess, t = rgC.ClosestPoint(pt)\r\n            if not bSuccess: continue # To next point.\r\n            if rgC.PointAt(t).DistanceTo(pt) <= 0.1 * tolerance:\r\n                # Tight tolerance above is to avoid grabbing segments\r\n                # adjacent to correct results that also happen to be short.\r\n                rgCs_Out.append(rgC)\r\n                break # To next curve from split.\r\n\r\n\r\n    #for rgC in rgCs_Proj_ThisSeg:\r\n    #    sc.doc.Objects.AddCurve(rgC)\r\n    #sc.doc.Views.Redraw(); 1/0\r\n\r\n    removeShortSegmentsInEachCrv_inList(rgCs_Out, tolerance=fTol_MinLength)\r\n\r\n    return rgCs_Out\r\n\r\n\r\ndef projectCurve_to_plane_and_trim_to_face(rgC_In, rgPlane, rgB, vectDir, fTol_Proj):\r\n    \"\"\"\r\n    Returns list(rg.Curve)\r\n    \"\"\"\r\n\r\n    rgCs_Out = []\r\n\r\n    rgC_fromProjectLoose = projectCurve_Greville_pts_to_plane(rgC_In, rgPlane, vectDir)\r\n    if rgC_fromProjectLoose is None:\r\n        return\r\n\r\n    return(trimCurves_to_brep_edges(\r\n        rgC_fromProjectLoose,\r\n        rgB=rgB,\r\n        fTol_Proj=fTol_Proj,\r\n        ))\r\n\r\n\r\ndef cleanProjectedCrvs_inList(rgCs_toMod, fTol_MinLength, bDebug=False):\r\n    \"\"\"\r\n    rgCs_Out: list, not array\r\n    Returns list(list(rg.Curve))\r\n    \"\"\"\r\n\r\n    #rgCs_Out = list(rgCs_Out) # Need to convert from Array to allow list slicing.\r\n\r\n    bModified = False\r\n\r\n    lenList = len(rgCs_toMod)\r\n\r\n    if removeShortCrvsInList(rgCs_toMod, tolerance=1e-5):\r\n        bModified = True\r\n        lenList = len(rgCs_toMod)\r\n    if removeShortSegmentsInEachCrv_inList(rgCs_toMod, tolerance=1e-5):\r\n        bModified = True\r\n        if bDebug: print(\"Short segments removed before exploding polycurves.\")\r\n    if explodePolyCrvsInList(rgCs_toMod):\r\n        bModified = True\r\n        lenList = len(rgCs_toMod)\r\n    if removeShortCrvsInList(rgCs_toMod, tolerance=fTol_MinLength):\r\n        bModified = True\r\n        lenList = len(rgCs_toMod)\r\n    if convertLinearNurbsToLinesInList(rgCs_toMod, 1e-6):\r\n        bModified = True\r\n        lenList = len(rgCs_toMod)\r\n    if removeShortSegmentsInEachCrv_inList(rgCs_toMod, tolerance=fTol_MinLength):\r\n        bModified = True\r\n        if bDebug: print(\"Short segments removed at end of routine.\")\r\n\r\n    return bModified\r\n\r\n\r\ndef shouldCrvBeProjectedToPlaneInsteadOfFace(crv):\r\n    \"\"\"\r\n    It's been found that while LineCurves, PolylineCurves, and 2-point NurbsCurves\r\n    are projected accurately to planar faces,\r\n    ArcCurves and NurbCurves with more than 2 points are often not.\r\n    \"\"\"\r\n\r\n    #print(crv.GetType().Name)\r\n\r\n    if isinstance(crv, rg.ArcCurve):\r\n        return True\r\n    if isinstance(crv, rg.NurbsCurve):\r\n        if crv.Points.Count > 2:\r\n            return True\r\n\r\n    return False\r\n\r\n\r\ndef projectCrv_to_1faceBreps_and_planes(rgCrv_In, rgBs_1Face, rgPlanes, vectDir, fTol_Proj):\r\n    \"\"\"\r\n    Returns list(list(rg.Curve))\r\n    \"\"\"\r\n\r\n    rgCs_Out = []\r\n\r\n    rgPlanes_ = rgPlanes # For debugging.\r\n\r\n    for rgB_1F, rgPlane in zip(rgBs_1Face, rgPlanes_):\r\n\r\n        rgCs_Proj_to_1FB = rg.Curve.ProjectToBrep(\r\n            curve=rgCrv_In,\r\n            brep=rgB_1F,\r\n            direction=vectDir,\r\n            tolerance=fTol_Proj)\r\n\r\n        if not rgCs_Proj_to_1FB:\r\n            continue\r\n\r\n        if not rgPlane:\r\n            rgCs_Out.extend(rgCs_Proj_to_1FB)\r\n            #sc.doc.Objects.AddBrep(rgB_1F)\r\n            continue\r\n\r\n        # Since rgCs_Proj_to_1FB exists, project to the current rgPlane.\r\n\r\n        if shouldCrvBeProjectedToPlaneInsteadOfFace(rgCrv_In):\r\n            rgCs_Proj_to_plane = projectCurve_to_plane_and_trim_to_face(\r\n                rgCrv_In,\r\n                rgPlane,\r\n                rgB_1F,\r\n                vectDir,\r\n                fTol_Proj=fTol_Proj)\r\n            if rgCs_Proj_to_plane:\r\n                rgCs_Out.extend(rgCs_Proj_to_plane)\r\n                for _ in rgCs_Proj_to_1FB: _.Dispose()\r\n                continue\r\n\r\n        rgCs_Out.extend(rgCs_Proj_to_1FB)\r\n\r\n    return rgCs_Out\r\n\r\n\r\ndef isUniformNurbsCurve(nc):\r\n    if not isinstance(nc, rg.NurbsCurve): return\r\n\r\n\r\n    # Bezier?\r\n    if nc.Points.Count == nc.Degree + 1:\r\n        return True\r\n\r\n\r\n    # Any internal polyknots?\r\n    start = 0 if nc.IsPeriodic else nc.Degree\r\n    end = nc.Knots.Count - (0 if nc.IsPeriodic else nc.Degree) - 1\r\n\r\n    for i in range(start, end):\r\n        if nc.Knots.KnotMultiplicity(i) > 1:\r\n            return False\r\n\r\n\r\n    # Any non-uniform knot spans?\r\n    start = 0 if nc.IsPeriodic else nc.Degree - 1\r\n    end = nc.Knots.Count - (0 if nc.IsPeriodic else nc.Degree - 1) - 1\r\n\r\n    span0 = nc.Knots[start+1] - nc.Knots[start]\r\n\r\n    def areEpsilonEqual(a, b, epsilon):\r\n        # This is a relative comparison.\r\n        delta = abs(a - b)\r\n        fRelComp = delta / max(abs(a), abs(b))\r\n        return fRelComp < epsilon\r\n\r\n\r\n    for i in range(start+1, end):\r\n        if nc.Knots.KnotMultiplicity(i) > 1:\r\n            return False\r\n        if not areEpsilonEqual(\r\n            span0, nc.Knots[i+1] - nc.Knots[i],\r\n            epsilon=2**-32):\r\n                return False\r\n\r\n    return True\r\n\r\n\r\ndef are_all_crvs_lines_or_uniformNonrationalCubic(rgCrvs):\r\n    for c in rgCrvs:\r\n        if isinstance(c, rg.LineCurve):\r\n            continue\r\n        if not isinstance(c, (rg.NurbsCurve)):\r\n            # Is Arc, Polyline?, PolyCurve?\r\n            return False\r\n        if c.IsRational:\r\n            return False\r\n        if not c.Degree == 3:\r\n            return False\r\n        if not isUniformNurbsCurve(c):\r\n            return False\r\n    return True\r\n\r\n\r\ndef rebuildUniformNonrationalCubic(rgCrv, tolerance, bDebug=False):\r\n\r\n    # Try rebuilding as a Bezier.\r\n    rebuilt = rgCrv.Rebuild(\r\n        pointCount=4,\r\n        degree=3,\r\n        preserveTangents=True)\r\n\r\n    bSuccess, fDistMax = rg.Curve.GetDistancesBetweenCurves(\r\n        rgCrv, rebuilt, tolerance=0.1*tolerance)[:2]\r\n\r\n    if bSuccess and fDistMax <= tolerance:\r\n        return rebuilt\r\n\r\n    rebuilt.Dispose()\r\n\r\n\r\n    iCt_MaxCp = round(rgCrv.GetLength() / (100.0 * sc.doc.ModelAbsoluteTolerance))\r\n    if bDebug: sEval='iCt_MaxCp';  print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n\r\n    # Try rebuilding at maximum allowed control point count.\r\n\r\n    rebuilt = rgCrv.Rebuild(\r\n        pointCount=iCt_MaxCp,\r\n        degree=3,\r\n        preserveTangents=True)\r\n\r\n    bSuccess, fDistMax = rg.Curve.GetDistancesBetweenCurves(\r\n        rgCrv, rebuilt, tolerance=0.1*tolerance)[:2]\r\n\r\n    if not bSuccess or fDistMax > tolerance:\r\n        # Fail at maximum control point count, so quit searching.\r\n        rebuilt.Dispose()\r\n        return\r\n\r\n\r\n    # Binary search to find least control point count.\r\n    rebuilt_LastSuccess = rebuilt\r\n    iCts_Cps_Tried = [4, iCt_MaxCp]\r\n\r\n    iCt_Cp_Try = (iCt_MaxCp + 4) // 2\r\n\r\n    if bDebug: sEval='iCt_Cp_Try';  print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n    while iCt_Cp_Try not in iCts_Cps_Tried:\r\n        sc.escape_test()\r\n\r\n\r\n        rebuilt = rgCrv.Rebuild(\r\n            pointCount=iCt_Cp_Try,\r\n            degree=3,\r\n            preserveTangents=True)\r\n\r\n        bSuccess, fDistMax = rg.Curve.GetDistancesBetweenCurves(\r\n            rgCrv, rebuilt, tolerance=0.1*tolerance)[:2]\r\n\r\n\r\n        iCts_Cps_Tried.append(iCt_Cp_Try)\r\n        iCts_Cps_Tried.sort()\r\n\r\n        if bSuccess and fDistMax <= tolerance:\r\n            rebuilt_LastSuccess.Dispose()\r\n            rebuilt_LastSuccess = rebuilt\r\n            # Bisect left.\r\n            iCt_Cp_Try = (\r\n                (iCt_Cp_Try +\r\n                    iCts_Cps_Tried[iCts_Cps_Tried.index(iCt_Cp_Try)-1]) // 2)\r\n        else:\r\n            rebuilt.Dispose()\r\n            # Bisect right.\r\n            iCt_Cp_Try = (\r\n                (iCt_Cp_Try +\r\n                    iCts_Cps_Tried[iCts_Cps_Tried.index(iCt_Cp_Try)+1]) // 2)\r\n\r\n        if bDebug: sEval='iCt_Cp_Try';  print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n    return rebuilt_LastSuccess\r\n\r\n\r\ndef reportCrvTypes(rgCrvs):\r\n    sTypes = [c.GetType().Name for c in rgCrvs]\r\n    for sType in set(sTypes):\r\n        print(\"[{}] {}\".format(sTypes.count(sType), sType))\r\n\r\n\r\ndef tryConvertNurbsToArcs_inList(rgCrvs_toMod, tol):\r\n    \"\"\"\r\n    rgCrvs_toMod is modified.\r\n    Returns: None\r\n    \"\"\"\r\n    fTol_MaxRad = 1e3\r\n        \r\n    for i, c in enumerate(rgCrvs_toMod):\r\n        if isinstance(c, rg.NurbsCurve):\r\n            if c.IsClosed:\r\n                b, circle = c.TryGetCircle(tol)\r\n                if b:\r\n                    if circle.Radius <= fTol_MaxRad:\r\n                        rgCrvs_toMod[i] = rg.ArcCurve(circle)\r\n                        c.Dispose()\r\n            else:\r\n                b, arc = c.TryGetArc(tol)\r\n                if b:\r\n                    if arc.Radius <= fTol_MaxRad:\r\n                        rgCrvs_toMod[i] = rg.ArcCurve(arc)\r\n                        c.Dispose()\r\n\r\n\r\ndef rebuild(nc, tolerance, bDebug=False):\r\n\r\n    # Try rebuilding as a Bezier.\r\n    for iDeg in 2, 3, 5:\r\n        rebuilt = nc.Rebuild(\r\n            pointCount=iDeg + 1,\r\n            degree=iDeg,\r\n            preserveTangents=True)\r\n\r\n        bSuccess, fDistMax = rg.Curve.GetDistancesBetweenCurves(\r\n            nc, rebuilt, tolerance=0.1*tolerance)[:2]\r\n\r\n        if bSuccess and fDistMax <= tolerance:\r\n            return rebuilt\r\n\r\n        rebuilt.Dispose()\r\n\r\n\r\n    iCt_MaxCp = round(nc.GetLength() / (100.0 * sc.doc.ModelAbsoluteTolerance))\r\n\r\n\r\n    # Try rebuilding at Degree 5 and maximum allowed control point count.\r\n    rebuilt = nc.Rebuild(\r\n        pointCount=iCt_MaxCp,\r\n        degree=5,\r\n        preserveTangents=True)\r\n\r\n    bSuccess, fDistMax = rg.Curve.GetDistancesBetweenCurves(\r\n        nc, rebuilt, tolerance=0.1*tolerance)[:2]\r\n\r\n    if not bSuccess or fDistMax > tolerance:\r\n        # Fail at maximum control point count, so quit searching.\r\n        rebuilt.Dispose()\r\n        return\r\n\r\n\r\n    # Binary search.\r\n    rebuilt_LastSuccess = rebuilt\r\n    iCts_Cps_Tried = [4, iCt_MaxCp]\r\n\r\n    iCt_Cp_Try = (iCt_MaxCp + 4) // 2\r\n\r\n    if bDebug: sEval='iCt_Cp_Try';  print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n    while iCt_Cp_Try not in iCts_Cps_Tried:\r\n        sc.escape_test()\r\n\r\n\r\n        for iDeg in 3, 5:\r\n\r\n            if iCt_Cp_Try < iDeg+1:\r\n                pass\r\n\r\n            rebuilt = nc.Rebuild(\r\n                pointCount=iCt_Cp_Try,\r\n                degree=iDeg,\r\n                preserveTangents=True)\r\n\r\n            bSuccess, fDistMax = rg.Curve.GetDistancesBetweenCurves(\r\n                nc, rebuilt, tolerance=0.1*tolerance)[:2]\r\n\r\n            if bSuccess and fDistMax <= tolerance:\r\n                break\r\n\r\n\r\n        iCts_Cps_Tried.append(iCt_Cp_Try)\r\n        iCts_Cps_Tried.sort()\r\n\r\n        if bSuccess and fDistMax <= tolerance:\r\n            rebuilt_LastSuccess.Dispose()\r\n            rebuilt_LastSuccess = rebuilt\r\n            # Bisect left.\r\n            iCt_Cp_Try = (\r\n                (iCt_Cp_Try +\r\n                    iCts_Cps_Tried[iCts_Cps_Tried.index(iCt_Cp_Try)-1]) // 2)\r\n        else:\r\n            rebuilt.Dispose()\r\n            # Bisect right.\r\n            iCt_Cp_Try = (\r\n                (iCt_Cp_Try +\r\n                    iCts_Cps_Tried[iCts_Cps_Tried.index(iCt_Cp_Try)+1]) // 2)\r\n\r\n        if bDebug: sEval='iCt_Cp_Try';  print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n    return rebuilt_LastSuccess\r\n\r\n\r\ndef convertPolysToNurbs(rgCrvs_toMod):\r\n    for i, c in enumerate(rgCrvs_toMod):\r\n        if isinstance(c, rg.PolyCurve):\r\n            rgCrvs_toMod[i] = c.ToNurbsCurve()\r\n            c.Dispose()\r\n\r\n\r\ndef projectCrv_Try_to_output_only_lines_and_cubicNurbs(fTol_Proj_Total, projectCrvToGeom_wrapped, bDebug=False):\r\n\r\n    projs_FullTol = projectCrvToGeom_wrapped(tolerance=fTol_Proj_Total)\r\n    if not projs_FullTol:\r\n        return\r\n\r\n    if bDebug:\r\n        print('-'*20)\r\n        reportCrvTypes(projs_FullTol)\r\n\r\n    if are_all_crvs_lines_or_uniformNonrationalCubic(projs_FullTol):\r\n        return projs_FullTol\r\n\r\n    # Project to a different tolerance and rebuild.\r\n\r\n    for fTol_Proj_WIP in (0.5*fTol_Proj_Total, 0.1*fTol_Proj_Total):\r\n\r\n        projs_atTrialTol = projectCrvToGeom_wrapped(tolerance=fTol_Proj_WIP)\r\n\r\n        if are_all_crvs_lines_or_uniformNonrationalCubic(projs_atTrialTol):\r\n            for proj in projs_FullTol: proj.Dispose()\r\n            return projs_atTrialTol\r\n\r\n        for i, proj in enumerate(projs_atTrialTol):\r\n            if are_all_crvs_lines_or_uniformNonrationalCubic([proj]):\r\n                continue\r\n            rebuilt = rebuildUniformNonrationalCubic(\r\n                proj,\r\n                tolerance=fTol_Proj_Total-fTol_Proj_WIP, \r\n                bDebug=bDebug)\r\n\r\n            if rebuilt:\r\n                projs_atTrialTol[i] = rebuilt\r\n                proj.Dispose()\r\n                continue\r\n            else:\r\n                for c in projs_atTrialTol: c.Dispose()\r\n                break # out of loop of projs_atTrialTol to next tolerance for rebuild.\r\n\r\n        else:\r\n            for proj in projs_FullTol: proj.Dispose()\r\n            return projs_atTrialTol\r\n    else:\r\n        if bDebug:\r\n            print(\"All rebuild tolerances failed for segment.\")\r\n        return projs_FullTol\r\n\r\n\r\ndef projectCrv_Try_to_output_per_arguments(fTol_Proj, projectCrvToGeom_wrapped, fTol_MinLength, bTryGetArcs, bAcceptRational, bTryRebuildOthersUniform, bDebug=False):\r\n    \"\"\"\r\n    If necessary, reproject through various tolerances.\r\n    \"\"\"\r\n\r\n    projs_FullTol = projectCrvToGeom_wrapped(tolerance=fTol_Proj)\r\n    if not projs_FullTol:\r\n        return\r\n\r\n    if bDebug:\r\n        print('-'*20)\r\n        reportCrvTypes(projs_FullTol)\r\n\r\n\r\n    if bTryGetArcs:\r\n        tryConvertNurbsToArcs_inList(projs_FullTol, 1e-6)\r\n\r\n    if cleanProjectedCrvs_inList(projs_FullTol, fTol_MinLength, bDebug=bDebug):\r\n        if bDebug: print(\"Curve was cleaned.\")\r\n\r\n    if bTryGetArcs:\r\n        tryConvertNurbsToArcs_inList(projs_FullTol, 1e-6)\r\n\r\n\r\n    def areAllCurvesSimplified(rgCrvs, bTryRebuildOthersUniform):\r\n        for c in rgCrvs:\r\n            if isinstance(c, rg.LineCurve):\r\n                pass\r\n            elif isinstance(c, rg.ArcCurve):\r\n                if not bTryGetArcs:\r\n                    return False\r\n            elif isinstance(c, rg.NurbsCurve):\r\n                if c.IsRational:\r\n                    if not bAcceptRational:\r\n                        return False\r\n                if bTryRebuildOthersUniform and not isUniformNurbsCurve(c):\r\n                    return False\r\n            else:\r\n                raise ValueError(\"{} in areAllCurvesSimplified.\".format(c.GetType().Name))\r\n    \r\n        return True\r\n\r\n\r\n    if areAllCurvesSimplified(projs_FullTol, bTryRebuildOthersUniform):\r\n        return projs_FullTol\r\n\r\n    # Project to a different tolerance and rebuild.\r\n\r\n    for fTol_Proj_WIP in (0.5*fTol_Proj, 0.1*fTol_Proj):\r\n\r\n        projs_atTrialTol = projectCrvToGeom_wrapped(tolerance=fTol_Proj_WIP)\r\n\r\n        if bTryGetArcs:\r\n            tryConvertNurbsToArcs_inList(projs_atTrialTol, fTol_Proj-1e-6)\r\n\r\n        if cleanProjectedCrvs_inList(projs_atTrialTol, fTol_MinLength, bDebug=bDebug):\r\n            if bDebug: print(\"Curve was cleaned.\")\r\n\r\n        if bTryGetArcs:\r\n            tryConvertNurbsToArcs_inList(projs_atTrialTol, 1e-6)\r\n\r\n        if areAllCurvesSimplified(projs_atTrialTol, bTryRebuildOthersUniform):\r\n            for proj in projs_FullTol: proj.Dispose()\r\n            return projs_atTrialTol\r\n\r\n        potentials = []\r\n        for proj in projs_atTrialTol:\r\n            if isinstance(proj, (rg.LineCurve, rg.ArcCurve)):\r\n                potentials.append(proj)\r\n                continue\r\n            \r\n            if not isinstance(proj, rg.NurbsCurve):\r\n                raise ValueError(\"{}, not a NurbsCurve!\".format(proj.GetType().Name))\r\n\r\n            if proj.IsRational and rg.Curve.IsEllipse(proj, tolerance=fTol_Proj-fTol_Proj_WIP):\r\n                potentials.append(proj)\r\n            elif not bTryRebuildOthersUniform and proj.IsRational and isUniformNurbsCurve(proj):\r\n                potentials.append(proj)\r\n            elif isUniformNurbsCurve(proj):\r\n                potentials.append(proj)\r\n            else:\r\n                # Rebuild to complement of projection tolerance.\r\n                rebuilt = rebuild(\r\n                    proj,\r\n                    tolerance=fTol_Proj-fTol_Proj_WIP,\r\n                    bDebug=bDebug)\r\n                if rebuilt:\r\n                    potentials.append(rebuilt)\r\n                    continue\r\n                else:\r\n                    for rgC in potentials: rgC.Dispose()\r\n                    break # out of for loop to next tolerance for rebuild.\r\n\r\n        else:\r\n            # Successful simplification.\r\n            for proj in projs_FullTol: proj.Dispose()\r\n            return potentials\r\n    else:\r\n        if bDebug: print(\"All rebuild tolerances failed for segment.\")\r\n        return projs_FullTol\r\n\r\n\r\ndef getJoints(rgCs_In, joinTolerance):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    joined = rg.Curve.JoinCurves(rgCs_In, joinTolerance=joinTolerance)\r\n\r\n    joints = []\r\n    for rgC in joined:\r\n        if not isinstance(rgC, rg.PolyCurve): continue\r\n\r\n        if rgC.IsClosed:\r\n            joints.append(rgC.PointAtStart)\r\n\r\n        for iSeg in range(1, rgC.SegmentCount):\r\n            seg = rgC.SegmentCurve(iSeg)\r\n            joints.append(seg.PointAtStart)\r\n            seg.Dispose()\r\n\r\n        rgC.Dispose()\r\n\r\n    return joints\r\n\r\n\r\ndef joinCurves(rgCs_In, tolerance, bDebug=False):\r\n    \"\"\"\r\n    Since JoinCurves, as well as _Join, can skew the knot vector,\r\n    join the curves by only moving control points as needed.\r\n    \"\"\"\r\n\r\n    joints = getJoints(rgCs_In, tolerance)\r\n    if bDebug:\r\n        for _ in joints: sc.doc.Objects.AddPoint(_)\r\n    sc.doc.Views.Redraw()\r\n\r\n    rgCrvs_toJoin = [rgC.DuplicateCurve() for rgC in rgCs_In]\r\n\r\n    iJ = 0\r\n\r\n    # Before JoinCurves, adjust ends of NurbsCurves.\r\n\r\n    for joint in joints:\r\n        sc.escape_test()\r\n\r\n        iCt_EndsProcessed = 0\r\n\r\n        for rgCrv in rgCrvs_toJoin:\r\n                \r\n            # Only NurbsCurves should have their control points translated when needed.\r\n            if not isinstance(rgCrv, rg.NurbsCurve):\r\n                #print(\"Curve is a {}.\".format(rgCrv.GetType().Name)\r\n                #sc.doc.Objects.AddCurve(rgCrv)\r\n                #sc.doc.Views.Redraw(); 1/0\r\n                continue # to next curve to include in JoinCurves.\r\n\r\n            if rgCrv.PointAtStart.DistanceTo(joint) < tolerance:\r\n                rgCrv.Points.SetPoint(\r\n                    index=0,\r\n                    point=joint,\r\n                    weight=rgCrv.Points[0].Weight)\r\n                #sc.doc.Objects.AddCurve(rgCrv); sc.doc.Views.Redraw(); #1/0\r\n                iCt_EndsProcessed += 1\r\n            elif rgCrv.PointAtEnd.DistanceTo(joint) < tolerance:\r\n                rgCrv.Points.SetPoint(\r\n                    index=rgCrv.Points.Count-1,\r\n                    point=joint,\r\n                    weight=rgCrv.Points[0].Weight)\r\n                #sc.doc.Objects.AddCurve(rgCrv); sc.doc.Views.Redraw(); #1/0\r\n                iCt_EndsProcessed += 1\r\n\r\n            if iCt_EndsProcessed == 2:\r\n                break # for loop to next joint.\r\n\r\n    return list(rg.Curve.JoinCurves(rgCrvs_toJoin, joinTolerance=1e-5))\r\n\r\n\r\ndef projectCurve_NotLoose(rgC_In, rgBs_1Face, rgPlanes, vectDir, **kwargs):\r\n    \"\"\"\r\n    Parameters:\r\n        fTol_Proj\r\n        bPostProcess\r\n        fTol_MinLength\r\n        bOnlyLinesAndCubicNurbs\r\n        bTryGetArcs\r\n        bAcceptRational\r\n        bTryRebuildOthersUniform\r\n\r\n\r\n    Projecting to breps of individual faces results in simpler curves for any\r\n    planar (not only PlaneSurface) faces.\r\n    For more accurate results, the curves's control points should be projected to\r\n    the Plane themselves.\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fTol_Proj = getOpt('fTol_Proj')\r\n    bPostProcess = getOpt('bPostProcess')\r\n    fTol_MinLength = getOpt('fTol_MinLength')\r\n    bOnlyLinesAndCubicNurbs = getOpt('bOnlyLinesAndCubicNurbs')\r\n    bTryGetArcs = getOpt('bTryGetArcs')\r\n    bAcceptRational = getOpt('bAcceptRational')\r\n    bTryRebuildOthersUniform = getOpt('bTryRebuildOthersUniform')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    sc.doc.Objects.UnselectAll() # For debug.\r\n\r\n\r\n    #TODO\r\n    #fTol_Proj_Total = 0.1*sc.doc.ModelAbsoluteTolerance if fTol_Proj is None else fTol_Proj\r\n    fTol_Proj_Total = fTol_Proj\r\n\r\n\r\n    if not bPostProcess:\r\n        return projectCrv_to_1faceBreps_and_planes(\r\n            rgC_In,\r\n            rgBs_1Face,\r\n            rgPlanes,\r\n            vectDir,\r\n            fTol_Proj=fTol_Proj)\r\n\r\n\r\n    # Wrapping the function since only the tolerance argument will change.\r\n    def projectCrvToGeom_wrapped(tolerance):\r\n        return projectCrv_to_1faceBreps_and_planes(\r\n            rgC_In,\r\n            rgBs_1Face,\r\n            rgPlanes,\r\n            vectDir,\r\n            fTol_Proj=fTol_Proj,\r\n            )\r\n\r\n\r\n    if bOnlyLinesAndCubicNurbs:\r\n        return projectCrv_Try_to_output_only_lines_and_cubicNurbs(\r\n            fTol_Proj_Total=fTol_Proj,\r\n            projectCrvToGeom_wrapped=projectCrvToGeom_wrapped,\r\n            bDebug=bDebug)\r\n\r\n\r\n    return projectCrv_Try_to_output_per_arguments(\r\n        fTol_Proj=fTol_Proj,\r\n        projectCrvToGeom_wrapped=projectCrvToGeom_wrapped,\r\n        fTol_MinLength=fTol_MinLength,\r\n        bTryGetArcs=bTryGetArcs,\r\n        bAcceptRational=bAcceptRational,\r\n        bTryRebuildOthersUniform=bTryRebuildOthersUniform,\r\n        bDebug=bDebug)\r\n\r\n\r\ndef duplicateSegments(rgC_In):\r\n    rgCs_Segs = rgC_In.DuplicateSegments()\r\n    if not rgCs_Segs:\r\n        1/0\r\n        rgCs_Segs = [rgC_In.DuplicateCurve()]\r\n    return rgCs_Segs\r\n\r\n\r\ndef processDocObjects(rhObjs_toProj, rhBreps, vect, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bProjectCrvSegs = getOpt('bProjectCrvSegs')\r\n    fTol_Proj = getOpt('fTol_Proj')\r\n    bLoose = getOpt('bLoose')\r\n    bPostProcess = getOpt('bPostProcess')\r\n    fTol_MinLength = getOpt('fTol_MinLength')\r\n    bOnlyLinesAndCubicNurbs = getOpt('bOnlyLinesAndCubicNurbs')\r\n    bTryGetArcs = getOpt('bTryGetArcs')\r\n    bAcceptRational = getOpt('bAcceptRational')\r\n    bTryRebuildOthersUniform = getOpt('bTryRebuildOthersUniform')\r\n    bJoinPerInputCrv = getOpt('bJoinPerInputCrv')\r\n    bDeleteInput = getOpt('bDeleteInput')\r\n    iOutputLayer = getOpt('iOutputLayer')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    def coerceBrepObject(rhObj):\r\n        rdObj = rs.coercerhinoobject(rhObj)\r\n        if rdObj and (rdObj.ObjectType == rd.ObjectType.Brep):\r\n            return rdObj\r\n\r\n\r\n\r\n    rdBs_In = [] # Flat list.\r\n    rgBs_In = [] # Flat list. May be breps of individual faces if the latter were subobject selected.\r\n    rgB1s_1F_PerB_In = [] # Nested lists.\r\n    rgPlanes_PerB_In = [] # Nested lists.\r\n\r\n\r\n    def collectTargetBrepData(rhBreps, rdBs_In, rgBs_In, rgB1s_1F_PerB_In, rgPlanes_PerB_In):\r\n        for rhB in rhBreps:\r\n            rgB = coerceBrep(rhB)\r\n            if not rgB.IsValid:\r\n                print(\"Invalid Brep in input, but projection to it\" \\\r\n                    \" will still be attempted.\" \\\r\n                    \"  Check results!\")\r\n\r\n            rdBs_In.append(coerceBrepObject(rhB))\r\n            rgBs_In.append(rgB)\r\n\r\n            if not bLoose:\r\n                rgB1s_1F_PerB_In.append([])\r\n                rgPlanes_PerB_In.append([])\r\n\r\n                for rgF in rgB.Faces:\r\n                    rgB_1F = rgF.DuplicateFace(duplicateMeshes=False)\r\n\r\n                    # Shrink face, otherwise Curve.ProjectToBrep\r\n                    # for some toroidal RevSurfaces may return None.\r\n                    # If this doesn't work, conversion from RevSurface\r\n                    # to NurbsSurface may be a solution.\r\n                    rgB_1F.Faces.ShrinkFaces()\r\n\r\n                    rgB1s_1F_PerB_In[-1].append(rgB_1F)\r\n                    rgSrf = rgF.UnderlyingSurface()\r\n                    bSuccess, rgPlane = rgSrf.TryGetPlane(tolerance=2**-32)\r\n                    if bSuccess:\r\n                        rgPlanes_PerB_In[-1].append(rgPlane)\r\n                    else:\r\n                        rgPlanes_PerB_In[-1].append(None)\r\n\r\n    collectTargetBrepData(rhBreps, rdBs_In, rgBs_In, rgB1s_1F_PerB_In, rgPlanes_PerB_In)\r\n\r\n    rgCs_Proj_All = []\r\n\r\n    attr_Out = rd.ObjectAttributes()\r\n\r\n    g_Out_All = []\r\n\r\n    if iOutputLayer == Opts.listValues['iOutputLayer'].index('Current'):\r\n        attr_Out.LayerIndex = sc.doc.Layers.CurrentLayerIndex\r\n\r\n    len_rhObjs0 = len(rhObjs_toProj)\r\n    idxs_AtTenths = [int(round(0.1*i*len(rhObjs_toProj),0)) for i in range(10)]\r\n\r\n    for iO, rhObj_toProj in enumerate(rhObjs_toProj):\r\n        if sc.escape_test(False):\r\n            print(\"Projecting interrupted by user.\")\r\n            return\r\n\r\n        if len_rhObjs0 > 10:\r\n            if iO in idxs_AtTenths:\r\n                Rhino.RhinoApp.SetCommandPrompt(\"Processing at {:d}% of {} object ...\".format(\r\n                    int(100.0 * (iO+1) / len_rhObjs0), len_rhObjs0))\r\n        elif len_rhObjs0 > 1:\r\n            Rhino.RhinoApp.SetCommandPrompt(\r\n                \"Projecting {} of {} objects ({})\".format(\r\n                    iO+1, len_rhObjs0, rs.coerceguid(rhObj_toProj)))\r\n        else:\r\n            Rhino.RhinoApp.SetCommandPrompt(\"Projecting object ...\")\r\n\r\n\r\n        rdObj_In = rs.coercerhinoobject(rhObj_toProj)\r\n\r\n        if iOutputLayer == Opts.listValues['iOutputLayer'].index('Input'):\r\n            attr_Out.LayerIndex = rdObj_In.Attributes.LayerIndex\r\n\r\n\r\n        # PointObjects.\r\n        if rdObj_In.ObjectType == rd.ObjectType.Point:\r\n            rgPt0 = rdObj_In.Geometry\r\n\r\n            gPts_from1Pt_Out = []\r\n\r\n            for rdB, rgB in zip(rdBs_In, rgBs_In):\r\n                if iOutputLayer == Opts.listValues['iOutputLayer'].index('TargetObject'):\r\n                    attr_Out.LayerIndex = rdB.Attributes.LayerIndex\r\n\r\n                pts_Proj = rg.Intersect.Intersection.ProjectPointsToBreps(\r\n                    breps=[rgB],\r\n                    points=[rgPt0.Location],\r\n                    direction=vect,\r\n                    tolerance=fTol_Proj)\r\n                if not pts_Proj: continue\r\n\r\n                for pt in pts_Proj:\r\n                    gPt_Out = sc.doc.Objects.AddPoint(pt, attributes=attr_Out)\r\n                    if gPt_Out != Guid.Empty:\r\n                        gPts_from1Pt_Out.append(gPt_Out)\r\n\r\n            if gPts_from1Pt_Out:\r\n                g_Out_All.extend(gPts_from1Pt_Out)\r\n            if bDeleteInput:\r\n                sc.doc.Objects.Delete(item=rdObj_In)\r\n\r\n            continue\r\n\r\n        if rdObj_In.ObjectType not in (rd.ObjectType.Curve, rd.ObjectType.Brep):\r\n            raise Exception(\"{} is not allowed as input to project.\".format(rdObj_In.GetType().Name))\r\n\r\n\r\n        # CurveObjects and BrepEdges.\r\n        if rdObj_In.ObjectType == rd.ObjectType.Curve:\r\n            rgC_In = rdObj_In.Geometry\r\n        elif rdObj_In.ObjectType == rd.ObjectType.Brep:\r\n            # For edges.\r\n            rgC_In = rs.coercecurve(rhObj_toProj)\r\n\r\n\r\n        # Prepd = Preprocessed\r\n        rgCs_Prepd_perC_In = duplicateSegments(rgC_In) if bProjectCrvSegs else [rgC_In.DuplicateCurve()]\r\n\r\n        rgCs_Res_perC_In = []\r\n\r\n        for rgC_Prepd_perC_In in rgCs_Prepd_perC_In:\r\n            if bLoose:\r\n                for rdB_In, rgB_In in zip(rdBs_In, rgBs_In):\r\n                    if iOutputLayer == Opts.listValues['iOutputLayer'].index('TargetObject'):\r\n                        attr_Out.LayerIndex = rdB_In.Attributes.LayerIndex\r\n\r\n                    rgCs_Projctd_from1Prepd_1B = projectCurve_Loose(\r\n                        rgC_Prepd_perC_In,\r\n                        rgB_In,\r\n                        vect,\r\n                        fTol_Proj=fTol_Proj,\r\n                        bDebug=bDebug)\r\n\r\n                    if rgCs_Projctd_from1Prepd_1B:\r\n                        rgCs_Res_perC_In.extend(rgCs_Projctd_from1Prepd_1B)\r\n            else:\r\n                for rdB_In, rgBs_1Face, rgPlanes in zip(rdBs_In, rgB1s_1F_PerB_In, rgPlanes_PerB_In):\r\n                    if iOutputLayer == Opts.listValues['iOutputLayer'].index('TargetObject'):\r\n                        attr_Out.LayerIndex = rdB_In.Attributes.LayerIndex\r\n\r\n                    rgCs_Projctd_from1Prepd_1B = projectCurve_NotLoose(\r\n                        rgC_Prepd_perC_In,\r\n                        rgBs_1Face,\r\n                        rgPlanes,\r\n                        vect,\r\n                        fTol_Proj=fTol_Proj,\r\n                        bPostProcess=bPostProcess,\r\n                        fTol_MinLength=fTol_MinLength,\r\n                        bOnlyLinesAndCubicNurbs=bOnlyLinesAndCubicNurbs,\r\n                        bTryGetArcs=bTryGetArcs,\r\n                        bAcceptRational=bAcceptRational,\r\n                        bTryRebuildOthersUniform=bTryRebuildOthersUniform,\r\n                        bDebug=bDebug)\r\n\r\n                    if rgCs_Projctd_from1Prepd_1B:\r\n                        rgCs_Res_perC_In.extend(rgCs_Projctd_from1Prepd_1B)\r\n\r\n\r\n        if not rgCs_Res_perC_In:\r\n            continue\r\n\r\n        if bJoinPerInputCrv and len(rgCs_Res_perC_In) > 1:\r\n            rgCs_Out = joinCurves(\r\n                rgCs_Res_perC_In,\r\n                tolerance=fTol_MinLength,\r\n                bDebug=bDebug)\r\n            #map(sc.doc.Objects.AddCurve, rgCs_Out); sc.doc.Views.Redraw(); 1/0\r\n            if bPostProcess:\r\n                # TODO: WIP\r\n                if rgC_In.IsPeriodic:\r\n                    print(\"Periodic input curve found.\")\r\n                #    if convertCrvsForPeriodicInList(rgCs_toMod):\r\n                #        bModified = True\r\n                #        lenList = len(rgCs_toMod)\r\n\r\n                # Even if removeShortSegmentsInEachCrv_inList was previously run,\r\n                # new short segments may have been produced by JoinCurves.\r\n                # This problem also occurs using _Project.\r\n                if removeShortSegmentsInEachCrv_inList(rgCs_Out, fTol_MinLength):\r\n                    if bDebug:\r\n                        print(\"Short segment(s) removed.\")\r\n        else:\r\n            rgCs_Out = rgCs_Res_perC_In\r\n\r\n        gCs_Res_fromC_In = []\r\n\r\n        for rgC in rgCs_Out:\r\n            gC_Out = sc.doc.Objects.AddCurve(rgC, attributes=attr_Out)\r\n            if gC_Out != Guid.Empty:\r\n                gCs_Res_fromC_In.append(gC_Out)\r\n\r\n        g_Out_All.extend(gCs_Res_fromC_In)\r\n\r\n        if bDeleteInput and (rdObj_In.ObjectType == rd.ObjectType.Curve):\r\n            # Skips deleting BreObjects.\r\n            sc.doc.Objects.Delete(item=rdObj_In)\r\n\r\n        # End of loop through rhObjs_toProj.\r\n\r\n\r\n    for rgB in rgBs_In:\r\n        if not rgB.IsDocumentControlled:\r\n            # Brep was created from a subobject-selected face.\r\n            rgB.Dispose()\r\n\r\n    if rgB1s_1F_PerB_In:\r\n        for rgB1s_1F in rgB1s_1F_PerB_In:\r\n            for rgB in rgB1s_1F:\r\n                rgB.Dispose()\r\n\r\n\r\n    return g_Out_All\r\n\r\n\r\ndef getDirectionVector(iDirection):\r\n    if Opts.listValues['iDirection'][iDirection] == 'CPlaneX':\r\n        return sc.doc.Views.ActiveView.ActiveViewport.ConstructionPlane().XAxis\r\n    if Opts.listValues['iDirection'][iDirection] == 'CPlaneY':\r\n        return sc.doc.Views.ActiveView.ActiveViewport.ConstructionPlane().YAxis\r\n    if Opts.listValues['iDirection'][iDirection] == 'CPlaneZ':\r\n        return sc.doc.Views.ActiveView.ActiveViewport.ConstructionPlane().ZAxis\r\n    elif Opts.listValues['iDirection'][iDirection] == 'WorldX':\r\n        return rg.Vector3d.XAxis\r\n    elif Opts.listValues['iDirection'][iDirection] == 'WorldY':\r\n        return rg.Vector3d.YAxis\r\n    elif Opts.listValues['iDirection'][iDirection] == 'WorldZ':\r\n        return rg.Vector3d.ZAxis\r\n    elif Opts.listValues['iDirection'][iDirection] == 'View':\r\n        return sc.doc.Views.ActiveView.ActiveViewport.GetCameraFrame()[1].ZAxis\r\n    elif Opts.listValues['iDirection'][iDirection] == 'Custom':\r\n        return Opts.values['vectCustom']\r\n\r\n\r\ndef main():\r\n    \r\n    objrefs_Crvs_Pts = getInput(\r\n        rdObjs_toHighlight=[],\r\n        sPrompt=\"Select curves and points to project\",\r\n        rdGeomFilter = (rd.ObjectType.Curve | rd.ObjectType.Point),\r\n        )\r\n    if objrefs_Crvs_Pts is None: return\r\n\r\n    #bProjectCrvSegs = Opts.values['bProjectCrvSegs']\r\n    #fTol_MinLength = Opts.values['fTol_MinLength']\r\n    #bLoose = Opts.values['bLoose']\r\n    #fTol_Proj = Opts.values['fTol_Proj']\r\n    #bPostProcess = Opts.values['bPostProcess']\r\n    #bOnlyLinesAndCubicNurbs = Opts.values['bOnlyLinesAndCubicNurbs']\r\n    #bTryGetArcs = Opts.values['bTryGetArcs']\r\n    #bAcceptRational = Opts.values['bAcceptRational']\r\n    #bTryRebuildOthersUniform = Opts.values['bTryRebuildOthersUniform']\r\n    #bDeleteInput = Opts.values['bDeleteInput']\r\n    #iOutputLayer = Opts.values['iOutputLayer']\r\n    #iDirection = Opts.values['iDirection']\r\n    #bEcho = Opts.values['bEcho']\r\n    #bDebug = Opts.values['bDebug']\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    rdCrvs_toHighlight = [o.Object() for o in objrefs_Crvs_Pts]\r\n\r\n    print(\"Now, select breps and faces ...\")\r\n\r\n    objrefs_Breps = getInput(\r\n        rdObjs_toHighlight=rdCrvs_toHighlight,\r\n        sPrompt=\"Select surfaces and polysurfaces to project onto\",\r\n        rdGeomFilter=rd.ObjectType.Brep,\r\n        )\r\n    if objrefs_Breps is None: return\r\n\r\n    # Determine vector before main routine.\r\n    vect = getDirectionVector(Opts.values['iDirection'])\r\n    #if Opts.listValues['iDirection'][iDirection] == 'CPlaneZ':\r\n    #    vect = sc.doc.Views.ActiveView.ActiveViewport.ConstructionPlane().ZAxis\r\n    #elif Opts.listValues['iDirection'][iDirection] == 'WorldZ':\r\n    #    vect = rg.Vector3d.ZAxis\r\n    #elif Opts.listValues['iDirection'][iDirection] == 'View':\r\n    #    rc = sc.doc.Views.ActiveView.ActiveViewport.GetCameraFrame()\r\n    #    if not rc[0]: return\r\n    #    vect = rc[1].ZAxis\r\n    #elif Opts.listValues['iDirection'][iDirection] == 'Custom':\r\n    #    rc = rs.GetLine(\r\n    #        mode=1, point=None,\r\n    #        message1='Projection direction',\r\n    #        message3='Second direction point',\r\n    #        )\r\n    #    if not rc: return\r\n    #    vect = rg.Vector3d(rc[1] - rc[0])\r\n\r\n\r\n    bProjectCrvSegs = Opts.values['bProjectCrvSegs']\r\n    iDirection = Opts.values['iDirection']\r\n    fTol_Proj = Opts.values['fTol_Proj']\r\n    bLoose = Opts.values['bLoose']\r\n    bPostProcess = Opts.values['bPostProcess']\r\n    fTol_MinLength = Opts.values['fTol_MinLength']\r\n    bOnlyLinesAndCubicNurbs = Opts.values['bOnlyLinesAndCubicNurbs']\r\n    bTryGetArcs = Opts.values['bTryGetArcs']\r\n    bAcceptRational = Opts.values['bAcceptRational']\r\n    bTryRebuildOthersUniform = Opts.values['bTryRebuildOthersUniform']\r\n    bJoinPerInputCrv = Opts.values['bJoinPerInputCrv']\r\n    bDeleteInput = Opts.values['bDeleteInput']\r\n    iOutputLayer = Opts.values['iOutputLayer']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n\r\n    if not Opts.values['bDebug']:\r\n        sc.doc.Views.RedrawEnabled = False\r\n\r\n    gs_Res = processDocObjects(\r\n        objrefs_Crvs_Pts,\r\n        objrefs_Breps,\r\n        vect,\r\n        bProjectCrvSegs=bProjectCrvSegs,\r\n        fTol_Proj=fTol_Proj,\r\n        bLoose=bLoose,\r\n        bPostProcess=bPostProcess,\r\n        fTol_MinLength=fTol_MinLength,\r\n        bOnlyLinesAndCubicNurbs=bOnlyLinesAndCubicNurbs,\r\n        bTryGetArcs=bTryGetArcs,\r\n        bAcceptRational=bAcceptRational,\r\n        bTryRebuildOthersUniform=bTryRebuildOthersUniform,\r\n        bJoinPerInputCrv=bJoinPerInputCrv,\r\n        bDeleteInput=bDeleteInput,\r\n        iOutputLayer=iOutputLayer,\r\n        iDirection=iDirection,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n    if Opts.values['bEcho']:\r\n        if len(objrefs_Crvs_Pts) == len(gs_Res) == 1:\r\n            print(\"Object projected to one object.\".format(\r\n                len(objrefs_Crvs_Pts)))\r\n        elif len(objrefs_Crvs_Pts) == len(gs_Res):\r\n            print(\"{} objects projected to same number of objects.\".format(\r\n                len(objrefs_Crvs_Pts)))\r\n        elif len(gs_Res) == 0:\r\n            print(\"The projection missed the selected objects.\".format(\r\n                len(objrefs_Crvs_Pts), len(gs_Res)))\r\n        else:\r\n            print(\"{} objects projected to {} objects.\".format(\r\n                len(objrefs_Crvs_Pts), len(gs_Res)))\r\n\r\n        iCt_Crvs = 0\r\n        iCt_Closed = 0\r\n\r\n        for gRes in gs_Res:\r\n            if rs.IsCurve(gRes):\r\n                iCt_Crvs += 1\r\n                if rs.IsCurveClosed(gRes):\r\n                    iCt_Closed += 1\r\n\r\n        if iCt_Crvs:\r\n            if iCt_Closed == iCt_Crvs:\r\n                print(\"All curves are closed.\")\r\n            elif iCt_Closed == 0:\r\n                print(\"All curves are open.\")\r\n            else:\r\n                print(\"{} curves are open. {} are closed.\".format(iCt_Crvs-iCt_Closed, iCt_Closed))\r\n\r\n\r\n    if gs_Res:\r\n        sc.doc.Objects.UnselectAll()\r\n        sc.doc.Objects.Select(objectIds=gs_Res)\r\n        sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}