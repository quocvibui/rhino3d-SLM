{
  "source_url": "https://github.com/Kyungho0511/3d-scan-with-spatial-analysis/blob/ae047ace35223fc021ac1c65d7b8d5c17f0043f4/scripts/run.py",
  "repo": "Kyungho0511/3d-scan-with-spatial-analysis",
  "repo_stars": 3,
  "repo_description": null,
  "license": "unknown",
  "filepath": "scripts/run.py",
  "instruction": null,
  "code": "import pyarrow.parquet as pq\nimport os\nimport pandas as pd\nimport numpy as np\nimport open3d as o3d\nimport ghhops_server as hs\nimport rhino3dm\nfrom flask import Flask\nimport open3d as o3d\nimport cv2\nimport outline\n\n\n\n\ndef o3d_to_rhino3dm(o3d_mesh):\n    \"\"\"\n    Converts an Open3D mesh into a Rhino3dm mesh.\n\n    Parameters:\n        o3d_mesh (o3d.geometry.TriangleMesh): The Open3D mesh to convert.\n\n    Returns:\n        rhino3dm.Mesh: The converted Rhino3dm mesh.\n    \"\"\"\n\n    \n    # Create a new Rhino3dm mesh\n    rhino_mesh = rhino3dm.Mesh()\n\n    # Add vertices to the Rhino mesh\n    for vertex in o3d_mesh.vertices:\n        rhino_mesh.Vertices.Add(vertex[0], vertex[1], vertex[2])\n        \n\n    for colour in o3d_mesh.vertex_colors:\n        rhino_mesh.VertexColors.Add(int(colour[0]*255),int(colour[1]*255), int(colour[2]*255))\n    # Add faces to the Rhino mesh\n    for triangle in o3d_mesh.triangles:\n        rhino_mesh.Faces.AddFace(triangle[0], triangle[1], triangle[2])\n\n    return rhino_mesh\n\ndef aabb_to_mesh(aabb):\n    \"\"\"\n    Converts an Open3D AxisAlignedBoundingBox into a TriangleMesh.\n\n    Parameters:\n        aabb (o3d.geometry.AxisAlignedBoundingBox): The bounding box to convert.\n\n    Returns:\n        o3d.geometry.TriangleMesh: The mesh representation of the AABB.\n    \"\"\"\n    # Get the eight corners of the AABB\n    corners = np.asarray(aabb.get_box_points())\n    \n    # Define the 12 triangles (faces) of the box using the corners\n    faces = [\n        [0, 1, 2], [0, 2, 3],  # bottom face\n        [4, 5, 6], [4, 6, 7],  # top face\n        [0, 1, 5], [0, 5, 4],  # front face\n        [2, 3, 7], [2, 7, 6],  # back face\n        [1, 2, 6], [1, 6, 5],  # right face\n        [0, 3, 7], [0, 7, 4]   # left face\n    ]\n    \n    # Create a TriangleMesh from the corners and faces\n    mesh = o3d.geometry.TriangleMesh()\n    mesh.vertices = o3d.utility.Vector3dVector(corners)\n    mesh.triangles = o3d.utility.Vector3iVector(faces)\n    \n    # Optionally, compute normals for better visualization\n    mesh.compute_vertex_normals()\n    \n    return mesh\n\n\ndef create_bounding_box(point_cloud):\n    \"\"\"\n    Create a simplified bounding box around the point cloud.\n\n    Parameters:\n        point_cloud (o3d.geometry.PointCloud): The point cloud to wrap.\n\n    Returns:\n        o3d.geometry.TriangleMesh: The bounding box mesh.\n    \"\"\"\n    # Get the axis-aligned bounding box (AABB)\n    aabb = point_cloud.get_axis_aligned_bounding_box()\n    \n    bounding_box_mesh = aabb_to_mesh(aabb)\n    # Create a mesh from the bounding bo\n    # bounding_box_mesh = o3d.geometry.TriangleMesh.create_from_axis_aligned_bounding_box(aabb)\n    \n    # Optionally, we can apply a scaling factor to make the box larger\n    scale_factor = 1.05  # Scale to make the box slightly larger\n    bounding_box_mesh.scale(scale_factor, center=aabb.get_center())\n    \n    return bounding_box_mesh\n\n\ndef dfToPC(df):\n    # Convert DataFrame to NumPy array\n    points = df[['x', 'y', 'z']].to_numpy()\n    # Create an Open3D point cloud object\n    pcd = o3d.geometry.PointCloud()\n\n    # Extract XYZ coordinates\n    points = df[['x', 'y', 'z']].values\n    pcd.points = o3d.utility.Vector3dVector(points)\n\n    # Normalize RGB values to the range [0, 1]\n    colors = df[['r', 'g', 'b']].values / 255.0\n    pcd.colors = o3d.utility.Vector3dVector(colors)\n    return pcd\n\n\ndef dfToBB(df):\n    return create_bounding_box(dfToPC(df))\n\ndef wallsMesh(pline, height):\n    pts = pline\n    meshList = []\n    holder = []\n    for i, pt in enumerate(pline):\n        mesh = rhino3dm.Mesh()\n        ptA = pt\n        if i == len(pline) - 1:\n            ptB1 = pline[0]\n        else:\n            ptB1 = pline[i+1]\n        ptB = rhino3dm.Point3d(pt.X, pt.Y, height[1])\n        ptA1 = rhino3dm.Point3d(ptB1.X, ptB1.Y, height[1])\n        \n        mesh.Vertices.Add(ptA.X, ptA.Y, ptA.Z)\n        mesh.Vertices.Add(ptB.X, ptB.Y, ptB.Z)\n        mesh.Vertices.Add(ptA1.X, ptA1.Y, ptA1.Z)\n        mesh.Vertices.Add(ptB1.X, ptB1.Y, ptB1.Z)\n        \n        mesh.Faces.AddFace(0,1,2,3)\n        # Optionally: Compute the normals\n        mesh.Normals.ComputeNormals()\n        meshList.append(mesh)\n    meshHolder = rhino3dm.Mesh()\n    for mesh in meshList:\n        meshHolder.Append(mesh)\n    return meshHolder\n\n\n\n\ndef windowMesh(line, zBounds):\n    mesh = rhino3dm.Mesh()\n    ptA = rhino3dm.Point3d(line[0][0], line[0][1], zBounds[0])\n    ptB1 = rhino3dm.Point3d(line[1][0], line[1][1], zBounds[0])\n    ptB = rhino3dm.Point3d(line[0][0], line[0][1], zBounds[1])\n    ptA1 = rhino3dm.Point3d(line[1][0], line[1][1], zBounds[1])\n    \n    mesh.Vertices.Add(ptA.X, ptA.Y, ptA.Z)\n    mesh.Vertices.Add(ptB.X, ptB.Y, ptB.Z)\n    mesh.Vertices.Add(ptA1.X, ptA1.Y, ptA1.Z)\n    mesh.Vertices.Add(ptB1.X, ptB1.Y, ptB1.Z)\n    \n    mesh.Faces.AddFace(0,1,2,3)\n    # Optionally: Compute the normals\n    mesh.Normals.ComputeNormals()\n    \n\n    return mesh\n\n\ndef dfToMesh(df):\n    \n    # Create an open3d PointCloud object\n    pcd = o3d.geometry.PointCloud()\n    points = df[['x', 'y', 'z']].values\n    pcd.points = o3d.utility.Vector3dVector(points)\n\n    \n\n    # Normalize RGB values to [0, 1] range and assign them to the point cloud\n    colors = df[['r', 'g', 'b']].values / 255.0\n    pcd.colors = o3d.utility.Vector3dVector(colors)\n\n    o3d.io.write_point_cloud(\"colored_pts.ply\", pcd)\n\n\n \n    # Estimate normals for Poisson reconstruction\n    pcd.estimate_normals(search_param=o3d.geometry.KDTreeSearchParamHybrid(radius=0.1, max_nn=30))\n\n    # with o3d.utility.VerbosityContextManager(\n    #         o3d.utility.VerbosityLevel.Debug) as cm:\n    mesh, densities = o3d.geometry.TriangleMesh.create_from_point_cloud_poisson(\n        pcd, depth=9)\n\n    # Define a threshold to remove low-density vertices\n    vertices = np.asarray(mesh.vertices)\n    density_threshold = np.percentile(densities, 5)  # Remove the bottom 5% of densities\n    vertices_to_remove = densities < density_threshold\n\n    # Filter vertices based on the density threshold\n    mesh.remove_vertices_by_mask(vertices_to_remove)\n    # # Create a mesh using Poisson reconstruction\n    # mesh, densities = o3d.geometry.TriangleMesh.create_from_point_cloud_poisson(pcd, depth=9)\n\n    # # Map the colors from the point cloud to the mesh vertices\n    # mesh.vertex_colors = pcd.colors\n\n    # Save the mesh to a .ply file, preserving vertex colors\n    return mesh\n\n\ndef getPlanarMesh(pLine):\n    rhino3dm.NurbsSurface.Create()\n\n\ndef getPolyline(ptList, bottomBound):\n    pts = []\n    if(len(ptList) > 3):\n        ptList = np.append(ptList, [ptList[0]], axis=0)\n        \n    for pt in ptList:\n        pts.append(rhino3dm.Point3d(pt[0],pt[1],bottomBound))\n    return rhino3dm.Polyline(pts)\n\ndef dfToRhinoMesh(df):\n    return o3d_to_rhino3dm(dfToMesh(df))\n\ndef dfToRhinoBBMesh(df):\n    return o3d_to_rhino3dm(dfToBB(df))\n# def add_numbers(a: str, b: float) -> rhino3dm.Mesh:\n\n\ndef runAll():\n    from os import listdir\n    from os.path import isfile, join\n    onlyfiles = [f for f in listdir(\"C:/Users/mskepasts/Documents/GitHub/3d-scan-with-spatial-analysis/data/\") if isfile(join(\"C:/Users/mskepasts/Documents/GitHub/3d-scan-with-spatial-analysis/data/\", f))]\n\n    for file in onlyfiles:\n        fileName = os.path.basename(file).split('/')[-1]\n        run(fileName)\n\n\ndef getHeight(walldf):\n    return walldf['Z'].max() - walldf['Z'].min()\n\n\ndef run(name):\n    try:\n        a = dir_path = \"C:/Users/mskepasts/Documents/GitHub/3d-scan-with-spatial-analysis/\" + \"/data/\" + name\n        table = pq.read_table(a)\n\n    except:\n        exit(\"File does not exist...\")\n\n\n    model = rhino3dm.File3dm()\n    final_fp,room_height,final_endpoint_lst,z_bound = outline.main(a)\n    pLine = getPolyline(final_fp, room_height[0])\n    for i, points in enumerate(final_endpoint_lst):\n        model.Objects.AddMesh(windowMesh(points, z_bound[i]))\n        model.Objects.AddPolyline(getPolyline(points, z_bound[i][0]))\n    \n    \n    model.Objects.AddMesh(wallsMesh(pLine, room_height))\n    # Convert to a pandas DataFrame if needed\n    df = table.to_pandas()\n    dfWalls = df[df['cat'] == 2]\n    dfFloor = df[df['cat'] == 1]\n    dfCeiling = df[df['cat'] == 0]\n    dfWindow =df[df['cat'] == 10]\n\n    if(len(dfWindow) == 0):\n        fileName = os.path.basename(a).split('/')[-1]\n        print(str(fileName) + \" has no windows!!\")\n        return\n        \n    print(\"Number of points in the walls: \" + str(len(dfWalls)))\n    print(\"Number of points in the floor: \" + str(len(dfFloor)))\n    print(\"Number of points in the ceiling: \" + str(len(dfCeiling)))\n\n\n\n    df_sampleWalls = dfWalls.sample(n=40000, random_state=1)\n    df_sampleFloor = dfFloor\n    df_sampleCeiling = dfCeiling\n    # df_sampleWalls = dfWalls.sample(n=40000, random_state=1)\n    df_sampleFloor = dfFloor.sample(n=40000, random_state=1)\n    df_sampleCeiling = dfCeiling.sample(n=40000, random_state=1)\n\n\n    df_sampleWindow = df[df['cat'] == 10]\n\n    walls = dfToRhinoMesh(df_sampleWalls)\n    floor = dfToRhinoMesh(df_sampleFloor)\n    ceiling = dfToRhinoMesh(df_sampleCeiling)\n    window = dfToRhinoMesh(df_sampleWindow)\n    # Create a 3dm file\n    # o3d.io.write_triangle_mesh(\"colored_mesh.ply\", dfToMesh(df_sampleWalls))\n\n\n   \n    model.Objects.AddMesh(walls)\n    model.Objects.AddMesh(floor)\n    model.Objects.AddMesh(ceiling)\n    model.Objects.AddMesh(window)\n    model.Objects.AddPolyline(pLine)\n\n    fileName = os.path.basename(a).split('/')[-1]\n    num = fileName[fileName.index(\"_\")+1 : fileName.index(\".\")]\n\n    # Write the model to a file\n    model.Write(\"C:/Users/mskepasts/Documents/GitHub/3d-scan-with-spatial-analysis/models/\" + \"setup_\" + str(num)+ \".3dm\", 6) \n\n    print(\"Rhino Model: \" + \"setup_\" + str(num)+ \" saved!\")\n    print(\"\\n\")\n\n# Defining main function\ndef main():\n    \n    num = input(\"What file number?: \")\n    \n    if num.capitalize() == \"All\":\n        print(\"yes\")\n        runAll()\n    else:\n        run(\"setup_\" + num + \".parquet\")\n\n\n# Using the special variable \n# __name__\nif __name__==\"__main__\":\n    main()\n\n\n\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}