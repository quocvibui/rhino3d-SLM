{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/xBrep_trimSurfaceWithCurves.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "xBrep_trimSurfaceWithCurves.py",
  "instruction": "190530: Created.\r\n191112: Added a function.\r\n191113: Made input of some function more BrepFace focused.\r\n191115: Added more tolerance multipliers.\r\n200130, 0202: Modified output of a...",
  "code": "\"\"\"\r\n190530: Created.\r\n191112: Added a function.\r\n191113: Made input of some function more BrepFace focused.\r\n191115: Added more tolerance multipliers.\r\n200130, 0202: Modified output of a function.\r\n200209, 14: Modified debug output.\r\n200303: Now accepts curves with length < resolution and >= ModelAbsoluteTolerance.\r\n200422: Refactored Opts.  Added some options.  Modified an option default value.\r\n200430: Added bOnlyUseCrvsOnFace and option to use all normal wires and brep edges.\r\n200505: Bug fix.\r\n200519-23, 0619,24,25, 0701,29: Refactored.  Exported a function to its own script.  Import-related update.\r\n210223: Modified an option default.\r\n220317: Import-related update.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\n\r\nimport xBrep_splitSurfaceWithCurves\r\nimport xBrepObject\r\nimport xSurface\r\n\r\n\r\nclass Opts():\r\n    \r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    riAddOpts = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    def addOptionDouble(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionDouble(\r\n            getObj, englishName=names[key], numberValue=riOpts[key])\r\n\r\n\r\n    def addOptionInteger(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionInteger(\r\n            getObj, englishName=names[key], intValue=riOpts[key])\r\n\r\n\r\n    def addOptionList(key, names, listValues, values):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionList(\r\n            getObj,\r\n            englishOptionName=names[key],\r\n            listValues=listValues,\r\n            listCurrentIndex=values[key])\r\n\r\n\r\n    def addOptionToggle(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionToggle(\r\n            getObj, englishName=names[key], toggleValue=riOpts[key])\r\n\r\n\r\n    #key = 'bSelBrep'; keys.append(key)\r\n    #values[key] = True\r\n    #names[key] = 'BrepSelMode'\r\n    #riOpts[key] = ri.Custom.OptionToggle(values[key], 'Edge', 'Brep')\r\n    #riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    #stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bScanForNakedEdges'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Off', 'On')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bPickPtForKeepNotRemove'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'AtPointPicked'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Remove', 'Keep')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bOnlyUseCrvsOnFace'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bSplitToCrvSegs'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'fTolerance'; keys.append(key)\r\n    values[key] = 1.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    riAddOpts[key] = addOptionDouble(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bTryOtherTolsOnFail'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bExtract'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n\r\n\r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if key in cls.riOpts:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput_TrimmingObjects():\r\n    \"\"\"\r\n    Get curves or edges with optional input.\r\n    \"\"\"\r\n\r\n\r\n    def getBrep(rhBrep):\r\n        if isinstance(rhBrep, rg.Brep):\r\n            return None, rhBrep\r\n        elif isinstance(rhBrep, rg.GeometryBase):\r\n            rdObj = None\r\n            rgObj = rhBrep\r\n        elif isinstance(rhBrep, rd.ObjRef):\r\n            rdObj = rhBrep.Object()\r\n            rgObj = rhBrep.Geometry()\r\n        elif isinstance(rhBrep, Guid):\r\n            rdObj = sc.doc.Objects.FindId(rhBrep) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhBrep)\r\n            rgObj = rdObj.Geometry\r\n        else:\r\n            return\r\n\r\n        if isinstance(rgObj, (rg.Brep, rg.BrepFace)):\r\n            return rdObj, rgObj\r\n\r\n\r\n    #idxs_EdgesOfFaceToSplit = []\r\n    #rdBrep_withFaceToSplit, rgBrep_withFaceToSplit = getBrep(objref_Face)\r\n    #gBrep_withFaceToSplit = rdBrep_withFaceToSplit.Id\r\n    #idxs_EdgesOfFaceToSplit.extend(objref_Face.Face().AdjacentEdges())\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    #def notEdgeOfFaceToSplit(rdObj, geom, compIdx):\r\n    #    print rdObj, geom, compIdx\r\n    #    if isinstance(rdObj, rd.BrepObject) and rdObj.Id == gBrep_withFaceToSplit:\r\n    #        if compIdx.ComponentIndexType == rg.ComponentIndexType.BrepEdge:\r\n    #            if geom.EdgeIndex in idxs_EdgesOfFaceToSplit:\r\n    #                print \"An edge of a face to split was picked and will not be used.\"\r\n    #                return False\r\n    #    return True\r\n    #go.SetCustomGeometryFilter(notEdgeOfFaceToSplit)\r\n    \r\n    \r\n    go.AcceptNothing(True)\r\n    \r\n    go.AcceptNumber(enable=True, acceptZero=True)\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False)\r\n    go.EnableUnselectObjectsOnExit(False)\r\n    \r\n    idxs_Opts = {}\r\n\r\n    while True:\r\n        if Opts.values['bScanForNakedEdges']:\r\n            go.SetCommandPromptDefault(\"Enter for all normal wires and brep naked edges\")\r\n        else:\r\n            go.SetCommandPromptDefault(\"Enter for all normal wires\")\r\n\r\n        key = 'bScanForNakedEdges'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bEcho'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bDebug'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n\r\n        go.GeometryFilter = rd.ObjectType.Curve | rd.ObjectType.Brep\r\n        go.SubObjectSelect = False\r\n        go.SetCommandPrompt(\"Select curves or breps\")\r\n        #if Opts.values['bSelBrep']:\r\n        #    go.GeometryFilter = rd.ObjectType.Curve | rd.ObjectType.Brep\r\n        #    go.SubObjectSelect = False\r\n        #    go.SetCommandPrompt(\"Select curves or breps\")\r\n        #else:\r\n        #    go.GeometryFilter = rd.ObjectType.Curve\r\n        #    go.SubObjectSelect = True\r\n        #    go.SetCommandPrompt(\"Select curves or edges\")\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n        \r\n        if res == ri.GetResult.Cancel:\r\n            return\r\n        elif res == ri.GetResult.Nothing:\r\n            return (\r\n                [],\r\n                Opts.values['bScanForNakedEdges'],\r\n                Opts.values['bEcho'],\r\n                Opts.values['bDebug'],\r\n                )\r\n        elif res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return (\r\n                objrefs,\r\n                Opts.values['bScanForNakedEdges'],\r\n                Opts.values['bEcho'],\r\n                Opts.values['bDebug'],\r\n                )\r\n        \r\n        # An option was selected or a number was entered.\r\n        \r\n        if res == ri.GetResult.Number:\r\n            Opts.riOpts['fTolerance'].CurrentValue = go.Number()\r\n        \r\n        if Opts.riOpts['fTolerance'].CurrentValue < 0.0:\r\n            Opts.riOpts['fTolerance'].CurrentValue = Opts.riOpts['fTolerance'].InitialValue\r\n        \r\n        Opts.setValues()\r\n        Opts.saveSticky()\r\n        go.ClearCommandOptions()\r\n\r\n\r\ndef getAllNormalObjs(bScanForNakedEdges=True):\r\n    rdObjs = []\r\n    settings = rd.ObjectEnumeratorSettings()\r\n    settings.NormalObjects = True\r\n    settings.LockedObjects = False\r\n    for rdObj in sc.doc.Objects.GetObjectList(settings):\r\n        if rdObj.ObjectType == rd.ObjectType.Curve:\r\n            rdObjs.append(rdObj)\r\n        elif rdObj.ObjectType == rd.ObjectType.Brep:\r\n            if bScanForNakedEdges:\r\n                rdObjs.append(rdObj)\r\n    return rdObjs\r\n\r\n\r\ndef getInput_Face():\r\n    \"\"\"Get Brepface with optional input.\"\"\"\r\n    \r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select face to trim\")\r\n    \r\n    go.GeometryFilter = rd.ObjectType.Surface\r\n    \r\n    go.AcceptNumber(enable=True, acceptZero=True)\r\n    \r\n    idxs_Opts = {}\r\n\r\n    while True:\r\n        key = 'bPickPtForKeepNotRemove'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bOnlyUseCrvsOnFace'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bSplitToCrvSegs'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'fTolerance'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bTryOtherTolsOnFail'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        #key = 'bExtract'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bEcho'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bDebug'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        \r\n        res = go.Get()\r\n        \r\n        if res == ri.GetResult.Object:\r\n            objref = go.Object(0)\r\n            go.Dispose()\r\n            sc.doc.Objects.UnselectAll()\r\n            return tuple([objref] + [Opts.values[key] for key in Opts.keys])\r\n        elif res == ri.GetResult.Cancel:\r\n            return\r\n        \r\n        # An option was selected or a number was entered.\r\n        \r\n        if res == ri.GetResult.Number:\r\n            Opts.riOpts['fTolerance'].CurrentValue = go.Number()\r\n        \r\n        if Opts.riOpts['fTolerance'].CurrentValue < 0.0:\r\n            Opts.riOpts['fTolerance'].CurrentValue = Opts.riOpts['fTolerance'].InitialValue\r\n        \r\n        Opts.setValues()\r\n        Opts.saveSticky()\r\n        go.ClearCommandOptions()\r\n\r\n\r\ndef trimSurfaceIntoFace(rgSrf_In, rhObjects_CurveOrEdge, pt_Input=None, **kwargs):\r\n    \"\"\"\r\n    WIP: This is a Rhino.Geometry function verses the already working Rhino.DocObjects function below.\r\n    TODO: Complete this function.\r\n\r\n    Parameters:\r\n        rgSrf_In: Can be rg.BrepFace or other rg.Surface.\r\n        rhObjects_CurveOrEdge\r\n        pt_Input: None or (rg.Point3d, bPickPtForKeepNotRemove)\r\n        bUseCrvsBBoxIfNoPt\r\n        bOnlyUseCrvsOnFace\r\n        bSplitToCrvSegs\r\n        fTolerance\r\n        bTryOtherTolsOnFail\r\n        bDebug\r\n    Returns on success:\r\n        rg.Brep (Monoface)\r\n    Returns on fail: None\r\n    \"\"\"\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bOnlyUseCrvsOnFace = getOpt('bOnlyUseCrvsOnFace')\r\n    bSplitToCrvSegs = getOpt('bSplitToCrvSegs')\r\n    fTolerance = getOpt('fTolerance')\r\n    bTryOtherTolsOnFail = getOpt('bTryOtherTolsOnFail')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    rgB_fromSplit = xSurface.splitSurfaceIntoBrep(\r\n            rgSrf_toSplit=srf_toSplit,\r\n            rhObjects_CurveOrEdge=rhObjects_CurveOrEdge,\r\n            fTolerance=fTolerance,\r\n            bTryOtherTolsOnFail=bTryOtherTolsOnFail,\r\n            bDebug=bDebug)\r\n    if not rgB_fromSplit: return\r\n\r\n\r\n    if pt_Input and isinstance(pt_Input[0], rg.Point3d):\r\n        if pt_Input[1] == True:\r\n            for rgF in rgB_fromSplit.Faces:\r\n                b, u, v = rgF.ClosestPoint(pt_Input)\r\n                if b:\r\n                    if rgF.IsPointOnFace(u, v) == rg.PointFaceRelation.Interior:\r\n                        rgB_Out = rgB_fromSplit.Faces[rgF.FaceIndex].DuplicateFace(False)\r\n                        rgB_fromSplit.Dispose()\r\n                        return rgB_Out\r\n            else:\r\n                rgB_fromSplit.Dispose()\r\n                return\r\n        elif pt_Input[1] == False:\r\n            if rgB_fromSplit.Faces.Count > 2:\r\n                print \"More than 2 faces for point trim!\"\r\n                rgB_fromSplit.Dispose()\r\n                return\r\n\r\n            for rgF in rgB_fromSplit.Faces:\r\n                b, u, v = rgF.ClosestPoint(pt_Input)\r\n                if b:\r\n                    if rgF.IsPointOnFace(u, v) == rg.PointFaceRelation.Interior:\r\n                        rgB_Out = rgB_fromSplit.Faces[(rgF.FaceIndex+1)%2].DuplicateFace(False)\r\n                        rgB_fromSplit.Dispose()\r\n                        return rgB_Out\r\n            else:\r\n                rgB_fromSplit.Dispose()\r\n                return\r\n\r\n\r\n    # Use bounding box.\r\n\r\n    def createBrepFromMatchingFace(breps, crvs, tolerance=None, bDebug=False):\r\n        \"\"\"\r\n        Returns:\r\n            Index of brep in breps.\r\n\r\n        This function is used by other scripts, so leave it at the root level.\r\n        \"\"\"\r\n\r\n        if tolerance is None:\r\n            tolerance = 2.0 * sc.doc.ModelAbsoluteTolerance\r\n\r\n\r\n\r\n        def createBB_ofGeometry(geoms):\r\n            try: geoms = list(geoms)\r\n            except: geoms = [geoms]\r\n            bbox = rg.BoundingBox.Empty\r\n            for geom in geoms: bbox.Union(geom.GetBoundingBox(True))\r\n            if bbox is None: raise ValueError(\"Bounding box not created.\")\r\n            return bbox\r\n\r\n\r\n        def findMatchingBoundingBox(bboxes, bbox_toMatch):\r\n            \"\"\"\r\n            bboxes: Iterable of BoundingBoxes from which to search.\r\n            bbox_toMatch: BoundingBox to match.\r\n            Returns: Index of single matching bounding box on success.\r\n            \"\"\"\r\n        \r\n            if bDebug: print 'findMatchingBoundingBox()...'\r\n        \r\n            #tolerance = (3.0 * (tol_Split**2.0))**0.5 # == Total distance of tol_Split for each component.\r\n        \r\n            idx_Found = None\r\n\r\n            epsilon = tolerance\r\n\r\n            for i in range(len(bboxes)):\r\n                if (\r\n                        bbox_toMatch.Min.EpsilonEquals(bboxes[i].Min, epsilon=epsilon) and\r\n                        bbox_toMatch.Max.EpsilonEquals(bboxes[i].Max, epsilon=epsilon)\r\n                ):\r\n                    if idx_Found is not None:\r\n                        print \"More than one match found.  Check results.\"\r\n                        return\r\n                    idx_Found = i\r\n        \r\n            if idx_Found is None:\r\n                if bDebug:\r\n                    print \"Matching bounding box NOT found.\"\r\n                    #sc.doc.Objects.AddBrep(bbox_toMatch.ToBrep())\r\n                    #for bb in bboxes:\r\n                        #sc.doc.Objects.AddBrep(bb.ToBrep())\r\n\r\n            return idx_Found\r\n\r\n\r\n        rgBs_fromSplit = [rgF.DuplicateFace(False) for rgF in rgB_fromSplit.Faces]\r\n\r\n\r\n        crvs_Closed = []\r\n        segs_ofOpen = []\r\n        for crv in crvs:\r\n            if crv.IsClosed:\r\n                crvs_Closed.append(crv)\r\n            else:\r\n                segs_ofOpen.append(crv)\r\n\r\n        segs_Joined = rg.Curve.JoinCurves(\r\n                segs_ofOpen, joinTolerance=sc.doc.ModelAbsoluteTolerance)\r\n        segs_Joined = list(segs_Joined) # Convert from Array.\r\n\r\n        bbox_of_crvs = createBB_ofGeometry(crvs_Closed + segs_Joined)\r\n\r\n        #sc.doc.Objects.AddBox(rg.Box(bbox_of_crvs)); #sc.doc.Views.Redraw(); 1/0\r\n\r\n        bboxes_ofNEs = []\r\n        for brep in breps:\r\n            NEs = [edge for edge in brep.Edges\r\n                   if edge.Valence == rg.EdgeAdjacency.Naked]\r\n            bboxes_ofNEs.append(createBB_ofGeometry(NEs))\r\n\r\n        #for bbox in bboxes_ofNEs:\r\n            #sc.doc.Objects.AddBox(rg.Box(bbox))\r\n        #sc.doc.Views.Redraw(); 1/0\r\n\r\n        #bboxes_ofNEs = [\r\n        #        createBB_ofGeometry(\r\n        #            [edge\r\n        #                for edge in brep.Edges\r\n        #                if edge.Valence == rg.EdgeAdjacency.Naked]\r\n        #        )\r\n        #        for brep in breps]\r\n\r\n        #map(sc.doc.Objects.AddBox, map(rg.Box, bboxes_ofNEs))\r\n\r\n        idx = findMatchingBoundingBox(bboxes_ofNEs, bbox_of_crvs)\r\n\r\n        if idx is None:\r\n            for rgB in rgBs_fromSplit: rgB.Dispose()\r\n            return\r\n\r\n        rgB_Found = rgBs_fromSplit[idx]\r\n\r\n        for i, rgB in enumerate(rgBs_fromSplit):\r\n            if i != idx:\r\n                rgB.Dispose()\r\n\r\n        return rgB_Found\r\n\r\n\r\n\r\n    rgB_Found = createBrepFromMatchingFace(\r\n        rgB_fromSplit,\r\n        rhObjects_CurveOrEdge,\r\n        tolerance=sc.doc.ModelAbsoluteTolerance,\r\n        bDebug=bDebug)\r\n\r\n    rgB_fromSplit.Dispose()\r\n\r\n    return rgB_Found\r\n\r\n\r\ndef getRhinoObjsOfSplitters(rhObjs, rhObj_withBrepFace):\r\n    rdObj_withFace = rs.coercerhinoobject(rhObj_withBrepFace)\r\n\r\n    rdObjs = []\r\n    for rhObj in rhObjs:\r\n        rdObj = rs.coercerhinoobject(rhObj)\r\n        if isinstance(rdObj, (rd.BrepObject, rd.CurveObject)):\r\n            if rdObj.Id == rdObj_withFace.Id:\r\n                #print \"Object to trim ({}) removed from trimming objects.\".format(rdObj)\r\n                continue\r\n            rdObjs.append(rdObj)\r\n    return rdObjs\r\n\r\n\r\ndef processBrepObject(rhObj_BrepFace, rhObjs_Splitters, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n\r\n    def setOpt(key, value=None):\r\n        if key in kwargs:\r\n            return kwargs[key]\r\n        elif key in Opts.riOpts:\r\n            return Opts.riOpts[key].InitialValue\r\n        else:\r\n            return value\r\n\r\n    bPickPtForKeepNotRemove = setOpt('bPickPtForKeepNotRemove')\r\n    bOnlyUseCrvsOnFace = setOpt('bOnlyUseCrvsOnFace')\r\n    bSplitToCrvSegs = setOpt('bSplitToCrvSegs')\r\n    fTolerance = setOpt('fTolerance')\r\n    bTryOtherTolsOnFail = setOpt('bTryOtherTolsOnFail')\r\n    bExtract = setOpt('bExtract')\r\n    bEcho = setOpt('bEcho')\r\n    bDebug = setOpt('bDebug')\r\n\r\n\r\n    rdObjs_Splitters = getRhinoObjsOfSplitters(rhObjs_Splitters, rhObj_BrepFace)\r\n\r\n    if not rdObjs_Splitters:\r\n        print \"No splitter objects.\"\r\n        return\r\n\r\n\r\n    pt_Picked = rhObj_BrepFace.SelectionPoint()\r\n\r\n\r\n    gBs_Split = xBrep_splitSurfaceWithCurves.processBrepObjects(\r\n        [rhObj_BrepFace],\r\n        rdObjs_Splitters,\r\n        bSplitUnderlyingSrf=False,\r\n        bOnlyUseCrvsOnSrf=bOnlyUseCrvsOnFace,\r\n        bSplitToCrvSegs=bSplitToCrvSegs,\r\n        fTolerance=fTolerance,\r\n        bTryOtherTolsOnFail=bTryOtherTolsOnFail,\r\n        bExplode=False,\r\n        bExtract=True,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug)\r\n\r\n    if not gBs_Split:\r\n        print \"Face was not split.\"\r\n        return\r\n\r\n    if len(gBs_Split) > 1:\r\n        print \"More than 1 brep resulted in split.\"\r\n        return\r\n\r\n    gB_Split = gBs_Split[0]\r\n\r\n    rgB_Split = rs.coercebrep(gB_Split)\r\n\r\n\r\n    def faceAtPoint(rgBrep, pt_onFace, bDebug=False):\r\n        \"\"\"\r\n        Returns face index.\r\n        \"\"\"\r\n\r\n\r\n        # Do not use the following because sometimes the face edges are\r\n        # stretched beyond the underlying surface (object of ClosestPoint).\r\n        #for idxF, rgF in enumerate(rgBrep.Faces):\r\n        #    b, u, v = rgF.ClosestPoint(pt_onFace)\r\n        #    if not b: raise ValueError(\"ClosestPoint returned None.\")\r\n        #    ptFaceRel = rgF.IsPointOnFace(u, v)\r\n        #    if ptFaceRel != rg.PointFaceRelation.Exterior:\r\n        #        return idxF\r\n\r\n\r\n        # The following is more exact, although also probably more expensive.\r\n        # Point may be slightly outside of face.\r\n        # Find point closest to each face.\r\n        fDists = []\r\n        for idxF, rgF in enumerate(rgBrep.Faces):\r\n            rgB = rgF.DuplicateFace(duplicateMeshes=False)\r\n            pt_Closest = rgB.ClosestPoint(pt_onFace)\r\n            rgB.Dispose()\r\n            fDist = pt_Closest.DistanceTo(pt_onFace)\r\n            fDists.append(fDist)\r\n\r\n        fMinDist = min(fDists)\r\n\r\n        if fDists.count(fMinDist) > 1:\r\n            raise ValueError(\"Face with point not on its exterior not found.\")\r\n\r\n        idxF = fDists.index(fMinDist)\r\n\r\n        return idxF\r\n\r\n\r\n    idxF_atPick = faceAtPoint(rgB_Split, pt_Picked)\r\n    if idxF_atPick is None:\r\n        if bOutputSplitOnFail: sc.doc.Objects.AddBrep(rgB_Split)\r\n        rgB_Split.Dispose()\r\n        return\r\n\r\n\r\n    def sortFacesByIslands(rgBrep, idxF_Start):\r\n        \"\"\"\r\n        Returns:\r\n            list(int(Index of start face and islands))\r\n            list(int(Index of remaining faces))\r\n        \"\"\"\r\n        rgB = rgBrep\r\n        if 1 <= rgB.Faces.Count <= 2:\r\n            return [idxF_Start], [0 if idxF_Start else 1]\r\n        \r\n        idxFs_Keep = []\r\n        idxFs_Skip = []\r\n\r\n        idxFs_toAddToSkip = []\r\n\r\n\r\n        idxFs_Adj_toNewSkip = [idxF_Start]\r\n\r\n        while True:\r\n            sc.escape_test()\r\n\r\n            # Add to keep.\r\n            idxFs_toAddToKeep = []\r\n            for idxF in idxFs_Adj_toNewSkip:\r\n                if idxF not in idxFs_Keep and idxF not in idxFs_Skip:\r\n                    idxFs_toAddToKeep.append(idxF)\r\n\r\n            if not idxFs_toAddToKeep:\r\n                # All faces have been tested.\r\n                return idxFs_Keep, idxFs_Skip\r\n\r\n            idxFs_Keep.extend(idxFs_toAddToKeep)\r\n\r\n            idxFs_Adj_toNewKeep = []\r\n            for idxF in idxFs_toAddToKeep:\r\n                idxFs_Adj_toNewKeep.extend(rgB.Faces[idxF].AdjacentFaces())\r\n\r\n            idxFs_Adj_toNewKeep = list(set(idxFs_Adj_toNewKeep))\r\n\r\n            idxFs_toAddToSkip = []\r\n            for idxF in idxFs_Adj_toNewKeep:\r\n                if idxF not in idxFs_Skip and idxF not in idxFs_Keep:\r\n                    idxFs_toAddToSkip.append(idxF)\r\n\r\n            if not idxFs_toAddToSkip:\r\n                # All faces have been tested.\r\n                return idxFs_Keep, idxFs_Skip\r\n\r\n            idxFs_Skip.extend(idxFs_toAddToSkip)\r\n\r\n            idxFs_Adj_toNewSkip = []\r\n            for idxF in idxFs_toAddToSkip:\r\n                idxFs_Adj_toNewSkip.extend(rgB.Faces[idxF].AdjacentFaces())\r\n\r\n            idxFs_Adj_toNewSkip = list(set(idxFs_Adj_toNewSkip))\r\n\r\n\r\n    idxFs_withStart, idxFs_notWithStart = sortFacesByIslands(rgB_Split, idxF_atPick)\r\n\r\n    if bPickPtForKeepNotRemove:\r\n        gBs_fromTrim = xBrepObject.removeFaces(gB_Split, idxFs_notWithStart)\r\n    else:\r\n        gBs_fromTrim = xBrepObject.removeFaces(gB_Split, idxFs_withStart)\r\n\r\n    if not gBs_fromTrim:\r\n        if bEcho:\r\n            print \"Trim failed.\"\r\n\r\n    gBs_1F = []\r\n\r\n    for gB in gBs_fromTrim:\r\n        gBs_Extracted, gBs_Remaining = xBrepObject.extractFaces(gB, None, bEcho=False)\r\n        gBs_1F.extend(gBs_Extracted)\r\n        if len(gBs_Extracted) > 1:\r\n            if bEcho:\r\n                print \"Adjacent faces in result.  This may be due to some ambiguity in the input.\"\r\n\r\n    if bEcho:\r\n        print \"Face was trimmed into {} faces.\".format(len(gBs_1F))\r\n\r\n    return gBs_fromTrim\r\n\r\n\r\ndef main():\r\n\r\n    rc = getInput_TrimmingObjects()\r\n    if rc is None: return\r\n    (\r\n        rhObjs_Splitters,\r\n        bScanForNakedEdges,\r\n        bEcho,\r\n        bDebug,\r\n        ) = rc\r\n    #print len(rc)\r\n\r\n    if not rhObjs_Splitters:\r\n        # Get all Normal objects now so before any layer, etc., changes occur during next input.\r\n        rhObjs_Splitters = getAllNormalObjs(bScanForNakedEdges)\r\n\r\n    if not rhObjs_Splitters:\r\n        print \"No splitters.\"\r\n        return\r\n\r\n    while True:\r\n        sc.escape_test()\r\n        rc = getInput_Face()\r\n        if rc is None: return\r\n\r\n        (\r\n            objref_Face,\r\n            bScanForNakedEdges,\r\n            bPickPtForKeepNotRemove,\r\n            bOnlyUseCrvsOnFace,\r\n            bSplitToCrvSegs,\r\n            fTolerance,\r\n            bTryOtherTolsOnFail,\r\n            bExtract,\r\n            bEcho,\r\n            bDebug,\r\n            ) = rc\r\n        #print len(rc)\r\n\r\n        sc.doc.Objects.UnselectAll()\r\n\r\n        Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\r\n\r\n        if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n        gBs_fromTrim = processBrepObject(\r\n            objref_Face,\r\n            rhObjs_Splitters,\r\n            bPickPtForKeepNotRemove=bPickPtForKeepNotRemove,\r\n            bOnlyUseCrvsOnFace=bOnlyUseCrvsOnFace,\r\n            bSplitToCrvSegs=bSplitToCrvSegs,\r\n            fTolerance=fTolerance,\r\n            bTryOtherTolsOnFail=bTryOtherTolsOnFail,\r\n            bExtract=bExtract,\r\n            bEcho=bEcho,\r\n            )\r\n\r\n        sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}