{
  "source_url": "https://github.com/fstwn/cockatoo/blob/d952ac5d2148ec29fba52e8eb75f0f43770c74ca/usrobj_src/Cockatoo_RelaxMeshIntoPlane.py",
  "repo": "fstwn/cockatoo",
  "repo_stars": 38,
  "repo_description": "Cockatoo is a prototypical open-source software toolkit for generating (3d-)knitting patterns from NURBS surface and mesh geometry directly inside Grasshopper.",
  "license": "MIT",
  "filepath": "usrobj_src/Cockatoo_RelaxMeshIntoPlane.py",
  "instruction": "Attempts to relax a mesh into a plane to make it planar. The best fit plane\nis used for reference and updated at every iteration\n    Inputs:\n        Run: If set to true, the relaxation process will...",
  "code": "\"\"\"\nAttempts to relax a mesh into a plane to make it planar. The best fit plane\nis used for reference and updated at every iteration\n    Inputs:\n        Run: If set to true, the relaxation process will run, if False it will\n             Pause.\n             {item, bool}\n        Reset: Will reset the relaxation if set to true. Connect a button here,\n               ideally.\n               {item, bool}\n        Threshold: Stop when average movement is less than this\n                   Defaults to [1e-3].\n                   {item, float}\n        Mesh: The mesh to attempt planarization for.\n              {item, mesh}\n        GlobalPlaneStrength: Strength of the movement towards the global plane\n                             {list, point}\n        LocalPlaneStrength: Strength of the movement towards the local planes.\n                            {item, float}\n        EdgeLengthStrength: Strength with which edgelengths are preserved.\n                            {item, float}\n    Output:\n        Iterations: The current number of iterations.\n                    {item, integer}\n        RelaxedMesh: The relaxed mesh for every iteration.\n                     {list, points}\n        GlobalFitPlane: The best fit plane of the mesh.\n                        {item, plane}\n        LocalFitPlanes: All the local planes used in the planarization attempt.\n                        {list, plane}\n        AveragePlaneDeviation: Average deviation between the vertices of the\n                               mesh and the globally fit plane.\n                               {item, float}\n    Remarks:\n        Author: Max Eschenbach\n        License: MIT License\n        Version: 200705\n\"\"\"\n\n# PYTHON STANDARD LIBRARY IMPORTS\nfrom __future__ import division\nimport clr\nimport math\n\n# GHPYTHON SDK IMPORTS\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\n# CUSTOM RHINO IMPORTS\nfrom ghpythonlib import treehelpers as th\nfrom scriptcontext import escape_test\nfrom scriptcontext import sticky as st\n\n# GHENV COMPONENT SETTINGS\nghenv.Component.Name = \"RelaxMeshIntoPlane\"\nghenv.Component.NickName =\"RMIP\"\nghenv.Component.Category = \"Cockatoo\"\nghenv.Component.SubCategory = \"10 Utilities\"\n\nclass RelaxMeshIntoPlane(component):\n    \n    def updateComponent(self):\n        \"\"\"Updates this component in a safe way.\"\"\"\n        # define callback action\n        def callBack(e):\n            self.ExpireSolution(False)\n        # get ghDoc\n        ghDoc = self.OnPingDocument()\n        # schedule new solution\n        ghDoc.ScheduleSolution(1, \n                   Grasshopper.Kernel.GH_Document.GH_ScheduleDelegate(callBack))\n    \n    def TweenPlanes(self, P1, P2, t):\n        \"\"\"Tweens between two planes using quaternion rotation.\"\"\"\n        Q = Rhino.Geometry.Quaternion.Rotation(P1, P2)\n        \n        # prepare out parameters\n        qAngle = clr.Reference[System.Double]()\n        qAxis = clr.Reference[Rhino.Geometry.Vector3d]()\n        \n        # get the rotation of the quaternion\n        Q.GetRotation(qAngle, qAxis)\n        \n        axis = Rhino.Geometry.Vector3d(qAxis.X, qAxis.Y, qAxis.Z)\n        angle = float(qAngle) - 2 * math.pi if float(qAngle) > math.pi else float(qAngle)\n        \n        OutputPlane = P1.Clone()\n        OutputPlane.Rotate(t * angle, axis, OutputPlane.Origin)\n        Translation = Rhino.Geometry.Vector3d(P2.Origin - P1.Origin)\n        OutputPlane.Translate(Translation * t)\n        \n        return OutputPlane\n    \n    def _compute_local_plane_indices(self, TopologyVertexList, vIndex, Depth):\n        \"\"\"\n        Computes the vertex indices for local plane interpolation up to\n        a given depth.\n        \"\"\"\n        \n        if Depth < 1:\n            return None\n        vertices = list(TopologyVertexList)\n        next = [vIndex]\n        ci = []\n        for i in range(Depth):\n            for vi in next[:]:\n                this = list(TopologyVertexList.ConnectedTopologyVertices(vi))\n                ci.extend(this)\n                next = this\n        ci.append(vIndex)\n        return ci\n    \n    def ComputeLocalPlanes(self, Mesh, Depth=1):\n        vertices = list(Mesh.Vertices.ToPoint3dArray())\n        LocalPlanes = []\n        for i, vertex in enumerate(vertices):\n            # get indices for vertices included in local plane\n            lpi = self._compute_local_plane_indices(Mesh.TopologyVertices,\n                                                   i,\n                                                   Depth)\n            # get thee points from the vertexlist\n            lpts = [vertices[x] for x in lpi]\n            \n            # fit plane to set of points\n            suc, lfp = Rhino.Geometry.Plane.FitPlaneToPoints(lpts)\n            if suc != Rhino.Geometry.PlaneFitResult.Success:\n                rml = self.RuntimeMessageLevel.Error\n                self.AddRuntimeMessage(rml,\n                              \"Could not fit local plane through meshpoints...\")\n                return None\n            \n            # compute average vertex for plane translation\n            avgVx = lpts[0]\n            for j, v in enumerate(lpts[1:]):\n                avgVx += v\n            avgVx = avgVx / len(lpts)\n            avgPCP = lfp.ClosestPoint(vertices[i])\n            lfp.Origin = avgPCP\n            \n            # align local plane with mesh normal\n            dp = lfp.Normal * Rhino.Geometry.Vector3d(Mesh.Normals[i])\n            if dp < 0:\n                lfp.Flip()\n            \n            # append to list of local planes\n            LocalPlanes.append(lfp)\n        return LocalPlanes\n    \n    def ComputeMoves(self, Mesh, vertices, GlobalFitPlane, GlobalPlaneStrength, LocalPlaneStrength, EdgeLengthStrength, lKey, eKey):\n        \"\"\"\n        Compute the moves and collision counts for a given set of vertices.\n        \"\"\"\n        \n        # define lists for storage of moves and collisions\n        totalMoves = []\n        collisionCounts = []\n        \n        # fill moves and collision list with empty values\n        for i, vertex in enumerate(vertices):\n            totalMoves.append(Rhino.Geometry.Vector3d(0, 0, 0))\n            collisionCounts.append(0.0)\n        \n        # loop through all vertices\n        for i, vertex in enumerate(vertices):\n            # get all the connected vertices\n            ci = list(Mesh.TopologyVertices.ConnectedTopologyVertices(i))\n            connectedpts = [vertices[idx] for idx in ci]\n            \n            # COMPUTE MOVE FOR GLOBAL PLANE FITTING ----------------------------\n            gpd = GlobalFitPlane.DistanceTo(vertices[i])\n            if abs(gpd) > 0:\n                gplnmove = GlobalFitPlane.Normal\n                gplnmove.Unitize()\n                # implementation detail: vector has to be reversed to move point\n                # in the direction of the plane\n                gplnmove.Reverse()\n                gplnmove = gplnmove * gpd * GlobalPlaneStrength\n                totalMoves[i] += gplnmove\n                collisionCounts[i] += 1.0\n            \n            # COMPUTE MOVE FOR LOCAL PLANE FITTING\n            LocalFitPlane = st[lKey][i]\n            lpd = LocalFitPlane.DistanceTo(vertices[i])\n            if abs(lpd) > 0:\n                lplnmove = LocalFitPlane.Normal\n                lplnmove.Unitize()\n                # implementation detail: vector has to be reversed to move point\n                # in the direction of the plane\n                lplnmove.Reverse()\n                lplnmove = lplnmove * lpd * LocalPlaneStrength\n                totalMoves[i] += lplnmove\n                collisionCounts[i] += 1.0\n            \n            # COMPUTE MOVE FOR EDGELENGTH PRESERVATION -------------------------\n            for j, cpt in enumerate(connectedpts):\n                # distance to connected point\n                cd = vertices[i].DistanceTo(cpt)\n                od = st[eKey][i][j]\n                \n                # compute delta\n                delta = od - cd\n                if abs(delta) > 0:\n                    # define moves, collisions and add them to lists\n                    move = vertices[i] - cpt\n                    move.Unitize()\n                    move = move * delta * EdgeLengthStrength\n                    totalMoves[i] += move\n                    totalMoves[ci[j]] -= move\n                    collisionCounts[i] += 1.0\n                    collisionCounts[ci[j]] += 1.0\n        \n        return totalMoves, collisionCounts\n    \n    def ComputeQuaternionMoves(self, Mesh, vertices, GlobalFitPlane, GlobalPlaneStrength, LocalPlaneStrength, EdgeLengthStrength, lKey, eKey):\n        \"\"\"Computes the move susing quaternion rotation augmentation\"\"\"\n        \n        # define lists for storage of moves and collisions\n        totalMoves = []\n        collisionCounts = []\n        \n        # fill moves and collision list with empty values\n        for i, vertex in enumerate(vertices):\n            totalMoves.append(Rhino.Geometry.Vector3d(0, 0, 0))\n            collisionCounts.append(0.0)\n        \n        # loop through all vertices\n        for i, vertex in enumerate(vertices):\n            # get all the connected vertices\n            ci = list(Mesh.TopologyVertices.ConnectedTopologyVertices(i))\n            connectedpts = [vertices[idx] for idx in ci]\n            \n            # COMPUTE MOVE FOR GLOBAL PLANE FITTING ----------------------------\n            gpd = GlobalFitPlane.DistanceTo(vertices[i])\n            gplnmove = GlobalFitPlane.Normal\n            gplnmove.Unitize()\n            # implementation detail: vector has to be reversed to move point\n            # in the direction of the plane\n            gplnmove.Reverse()\n            gplnmove = gplnmove * gpd * GlobalPlaneStrength\n            \n            # COMPUTE MOVE FOR LOCAL PLANE FITTING -----------------------------\n            LocalFitPlane = st[lKey][i]\n            lpd = LocalFitPlane.DistanceTo(vertices[i])\n            lplnmove = LocalFitPlane.Normal\n            lplnmove.Unitize()\n            # implmentation detail: vector has to be reversed to move point\n            # in the direction of the plane\n            lplnmove.Reverse()\n            lplnmove = lplnmove * lpd * LocalPlaneStrength\n            \n            # COMPUTE TWEENED PLANE FROM GLOBAL AND LOCAL PLANE ----------------\n            QuaternionPlane = self.TweenPlanes(GlobalFitPlane, st[lKey][i], 0.5)\n            \n            qpd = QuaternionPlane.DistanceTo(vertices[i])\n            qplnmove = QuaternionPlane.Normal\n            qplnmove.Unitize()\n            qplnmove.Reverse()\n            qplnmove = qplnmove * lpd * LocalPlaneStrength\n            \n            # ADD MOVE TO MOVESLIST FOR BOTH PLANE MOVES -----------------------\n            totalMoves[i] += gplnmove + lplnmove + qplnmove\n            collisionCounts[i] += 1.0\n            \n            # COMPUTE MOVE FOR EDGELENGTH PRESERVATION -------------------------\n            for j, cpt in enumerate(connectedpts):\n                # distance to connected point\n                cd = vertices[i].DistanceTo(cpt)\n                od = st[eKey][i][j]\n                \n                # compute delta\n                delta = od - cd\n                \n                # define moves, collisions and add them to lists\n                move = vertices[i] - cpt\n                move.Unitize()\n                move = move * delta * EdgeLengthStrength\n                totalMoves[i] += move\n                totalMoves[ci[j]] -= move\n                collisionCounts[i] += 1.0\n                collisionCounts[ci[j]] += 1.0\n        \n        return totalMoves, collisionCounts\n    \n    def RunScript(self, Run, Reset, Threshold, Mesh, LocalPlaneDepth, GlobalPlaneStrength, LocalPlaneStrength, EdgeLengthStrength):\n        \n        PLANEMODE = 0\n        \n        # DEFINE STICKY KEYS FOR STORAGE OF PERISTENT DATA BETWEEN ITERATIONS --\n        ig = str(self.InstanceGuid)\n        vKey = ig + \"___VERTICES\"\n        eKey = ig + \"___ORIGINALEDGELENGTHS\"\n        lKey = ig + \"___LOCALVIEWPLANES\"\n        cKey = ig + \"___CONVERGED\"\n        iKey = ig + \"___ITERATIONS\"\n        \n        # MESH INPUT CHECKING --------------------------------------------------\n        if not Mesh:\n            rml = Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning\n            self.AddRuntimeMessage(rml, \"Missing Mesh input...\")\n            return None\n        elif Mesh.IsClosed:\n            rml = Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning\n            self.AddRuntimeMessage(rml, \"Boundary is \" +\n                \"closed! This operation only makes sense \" + \n                \"with open meshes....\")\n            return None\n        \n        # DEFAULT VALUES -------------------------------------------------------\n        # set default value for threshold\n        if not Threshold:\n            Threshold = 1e-3\n        \n        # define global plane strength default\n        if GlobalPlaneStrength == None:\n            GlobalPlaneStrength = 0.25\n        \n        # define local plane strength default\n        if LocalPlaneStrength == None:\n            LocalPlaneStrength = 0.75\n        \n        # strength for edgelength preservation\n        if EdgeLengthStrength == None:\n            EdgeLengthStrength = 0.5\n        \n        # RESET HANDLING AND INITIALIZATION ------------------------------------\n        if Reset or (not vKey in st or\n                     not eKey in st or\n                     not lKey in st or\n                     not cKey in st or\n                     not iKey in st) or st[iKey] == 0:\n            self.Message = \"Reset\"\n            st[vKey] = None\n            st[eKey] = None\n            st[lKey] = None\n            st[cKey] = None\n            st[iKey] = 0\n            \n            # initialize vertices\n            st[vKey] = list(Mesh.Vertices.ToPoint3dArray())\n            \n            # initialize original edgelengths\n            originaledgelengths = []\n            for i, v in enumerate(st[vKey]):\n                ci = list(Mesh.TopologyVertices.ConnectedTopologyVertices(i))\n                cd = [v.DistanceTo(cv) for cv in [st[vKey][j] for j in ci]]\n                originaledgelengths.append(cd)\n            if originaledgelengths:\n                st[eKey] = originaledgelengths\n            \n        # PAUSED CONDITION -----------------------------------------------------\n        elif not Run and cKey in st and st[cKey] == False:\n            ghenv.Component.Message = \"Paused\"\n        # CONVERGED CONDITION\n        elif cKey in st and st[cKey] == True:\n            ghenv.Component.Message = \"Converged\"\n        \n        vertices = st[vKey]\n        EdgeLengths = st[eKey]\n        Iterations = st[iKey]\n        \n        # CREATE RELAXED MESH OUTPUT -------------------------------------------\n        RelaxedMesh = Mesh.Duplicate()\n        for i, vertex in enumerate(st[vKey]):\n            RelaxedMesh.Vertices.SetVertex(i, vertex)\n        \n        # COMPUTE AVERAGE MESH NORMAL ------------------------------------------\n        meshnormals = RelaxedMesh.Normals\n        avgNormal = Rhino.Geometry.Vector3d(meshnormals[0])\n        for i, normal in enumerate(meshnormals):\n            if i == 0:\n                continue\n            avgNormal += Rhino.Geometry.Vector3d(normal)\n        avgNormal = avgNormal / len(meshnormals)\n        avgNormal.Unitize\n        \n        # COMPUTE AVERAGE MESH VERTEX ------------------------------------------\n        avgMvx = vertices[0]\n        for i, v in enumerate(vertices[1:]):\n            avgMvx += v\n        avgMvx = avgMvx / len(vertices)\n        \n        # BUILD GLOBAL PLANE FROM AVERAGE MESH NORMAL AND VERTEX ---------------\n        GlobalFitPlane = Rhino.Geometry.Plane(avgMvx, avgNormal)\n        \n        # BUILD LOCALFITPLANES -------------------------------------------------\n        if lKey in st and st[lKey] != None and st[iKey] > 0:\n            LocalFitPlanes = st[lKey]\n        elif lKey in st and st[lKey] == None:\n            LocalFitPlanes = self.ComputeLocalPlanes(Mesh, LocalPlaneDepth)\n            st[lKey] = LocalFitPlanes\n        \n        # RUN CONDITION --------------------------------------------------------\n        if Run and not st[cKey]:\n            # set message to component\n            self.Message = \"Running\"\n            \n            LocalFitPlanes = self.ComputeLocalPlanes(RelaxedMesh,\n                                                     LocalPlaneDepth)\n            st[lKey] = LocalFitPlanes\n            \n            # COMPUTATION OF MOVES ---------------------------------------------\n            if PLANEMODE == 0:\n                totalMoves, collisionCounts = self.ComputeMoves(RelaxedMesh,\n                                                                vertices,\n                                                                GlobalFitPlane,\n                                                                GlobalPlaneStrength,\n                                                                LocalPlaneStrength,\n                                                                EdgeLengthStrength,\n                                                                lKey,\n                                                                eKey)\n            elif PLANEMODE == 1:\n                totalMoves, collisionCounts = self.ComputeQuaternionMoves(RelaxedMesh,\n                                                                vertices,\n                                                                GlobalFitPlane,\n                                                                GlobalPlaneStrength,\n                                                                LocalPlaneStrength,\n                                                                EdgeLengthStrength,\n                                                                lKey,\n                                                                eKey)\n            \n            # EXECTUTION OF MOVES ----------------------------------------------\n            for i, c in enumerate(vertices):\n                if collisionCounts[i] != 0.0:\n                    st[vKey][i] += totalMoves[i] / collisionCounts[i]\n                    RelaxedMesh.Vertices.SetVertex(i, st[vKey][i])\n            \n            # PARTICLE VELOCITY ------------------------------------------------\n            totalvelocity = 0\n            for i, v in enumerate(totalMoves):\n                totalvelocity += v.Length\n            if totalvelocity <= Threshold:\n                st[cKey] = True\n            else:\n                st[cKey] = False\n            \n            # set iteration counter in sticky\n            st[iKey] += 1\n            \n            # update the component\n            self.updateComponent()\n        \n        # DEFINE OUTPUTS -------------------------------------------------------\n        \n        # LocalFitPlanes\n        LocalFitPlanes = th.list_to_tree(st[lKey])\n        \n        # AveragePlaneDeviation\n        AveragePlaneDeviation = 0\n        for i, vertex in enumerate(st[vKey]):\n            AveragePlaneDeviation += abs(GlobalFitPlane.DistanceTo(vertex))\n        AveragePlaneDeviation = AveragePlaneDeviation / len(st[vKey])\n        \n        # return outputs if you have them; here I try it for you:\n        return (Iterations,\n                RelaxedMesh,\n                GlobalFitPlane,\n                LocalFitPlanes,\n                AveragePlaneDeviation)",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}