{
  "source_url": "https://github.com/choras-org/backend/blob/83981cdf4fc703fdcefe1b8c57625423a98db039/app/services/mesh_service.py",
  "repo": "choras-org/backend",
  "repo_stars": 6,
  "repo_description": "CHORAS backend",
  "license": "unknown",
  "filepath": "app/services/mesh_service.py",
  "instruction": "Mesh service",
  "code": "import logging\nimport os\nimport re\n\nimport gmsh\nimport rhino3dm\nfrom acousticDE.FiniteVolumeMethod.CreateMeshFVM import generate_mesh\nfrom flask_smorest import abort\n\nimport config\nfrom app.db import db\nfrom app.models import File, Mesh, Simulation, Task\nfrom app.services import file_service, model_service\nfrom app.types import Status, TaskType\n\nfrom app.services.geometry_service import convert_3dm_to_geo\n\n# Create logger for this module\nlogger = logging.getLogger(__name__)\n\n\ndef get_meshes_by_model_id(model_id):\n    model = model_service.get_model(model_id)\n    if model.mesh and (model.mesh.task.status == Status.Error):\n        return []\n    return [model.mesh] if model.mesh else []\n\n\ndef get_mesh_by_id(mesh_id):\n    mesh = Mesh.query.filter_by(id=mesh_id).first()\n    if not mesh:\n        logger.error(\"Mesh with id \" + str(mesh_id) + \"does not exists!\")\n        abort(404, message=\"Mesh does not exist\")\n    return mesh\n\n\ndef attach_geo_file(model_id, file_input_id):\n    model_Model = model_service.get_model(model_id)\n    directory = config.DefaultConfig.UPLOAD_FOLDER\n    geo_file = file_service.get_file_by_id(file_input_id)\n    model_file = file_service.get_file_by_id(model_Model.outputFileId)\n    file_name, file_extension = os.path.splitext(os.path.basename(model_file.fileName))\n    file3dm = rhino3dm.File3dm()\n    model = file3dm.Read(os.path.join(directory, model_file.fileName))\n\n    rhino_file_name = os.path.join(directory, model_file.fileName)\n    geo_file_name = os.path.join(directory, file_name) + \".geo\"\n    try:\n        if not convert_3dm_to_geo(rhino_file_name, geo_file_name):\n            logger.error(\"Can not generate a geo file\")\n            return False\n\n        file_geo = File(fileName=f\"{file_name}.geo\")\n        db.session.add(file_geo)\n        db.session.commit()\n\n    except Exception as ex:\n        db.session.rollback()\n        logger.error(f\"Can not attach a geo file: {ex}\")\n        return False\n\n    try:\n        model_Model.hasGeo = True\n        db.session.commit()\n    except Exception as ex:\n        db.session.rollback()\n        logger.error(f\"Can not attach the geo file to the model! Error: {ex}\")\n        abort(400, message=f\"Can not attach the geo file to the model! Error: {ex}\")\n\n    return {\"status\": True, \"message\": \"geo file added to the model successfully!\"}\n\n    ## old code for importing .geo file\n    # with open(os.path.join(directory, geo_file.fileName), \"r\") as file:\n    #     geo_content = file.readlines()\n\n    # # Create a mapping of material_name to obj.Attributes.Id\n    # material_to_id = {}\n    # for obj in model.Objects:\n    #     if isinstance(obj.Geometry, rhino3dm.Mesh):\n    #         material_name = obj.Geometry.GetUserString(\"material_name\")\n    #         if material_name:\n    #             material_to_id[f\"{obj.Attributes.Id}\"] = material_name\n\n    # # Reverse the mapping to be from material name to list of IDs\n    # material_name_to_ids = {}\n    # for id, material_name in material_to_id.items():\n    #     if material_name not in material_name_to_ids:\n    #         material_name_to_ids[material_name] = []\n    #     material_name_to_ids[material_name].append(id)\n\n    # def pop_and_update_braces(content):\n    #     pattern = re.compile(r\"{\\s*(\\d+(?:\\s*,\\s*\\d+)*)\\s*}\")\n    #     match = pattern.search(content)\n    #     if match:\n    #         numbers = match.group(1).split(\",\")\n    #         numbers = [num.strip() for num in numbers]\n    #         if numbers:\n    #             return numbers\n    #     return []\n\n    # # Replace physical surface keys in the geo file content\n    # new_geo_content = []\n    # try:\n    #     for line in geo_content:\n    #         if line.strip().startswith(\"Physical Surface\"):\n    #             parts = line.split('\"')\n    #             if len(parts) > 1:\n    #                 material_name = parts[1].strip()\n    #                 if material_name in material_name_to_ids:\n    #                     ids = material_name_to_ids[material_name]\n    #                     numbers = pop_and_update_braces(line)\n    #                     for i, number in enumerate(numbers):\n    #                         new_geo_content.append(f'Physical Surface(\"{ids.pop(0)}\") = {{ {number} }};\\n')\n    #                 else:\n    #                     return {\n    #                         \"status\": False,\n    #                         \"message\": f\"Mismatch between name of the material and the boundary name {material_name}\",\n    #                     }\n    #                     new_geo_content.append(line)\n    #             else:\n    #                 new_geo_content.append(line)\n    #         else:\n    #             new_geo_content.append(line)\n    # except Exception as ex:\n    #     print(f\"Geo import error: {ex}\")\n    #     return {\n    #         \"status\": False,\n    #         \"message\": f\"Geo import error: {ex}\",\n    #     }\n\n    # with open(os.path.join(directory, f\"{file_name}.geo\"), \"w\") as file:\n    #     file.writelines(new_geo_content)\n\n    # try:\n    #     model_Model.hasGeo = True\n    #     db.session.commit()\n    # except Exception as ex:\n    #     db.session.rollback()\n    #     logger.error(f\"Can not attach the geo file to the model! Error: {ex}\")\n    #     abort(400, message=f\"Can not attach the geo file to the model! Error: {ex}\")\n\n    # return {\"status\": True, \"message\": \"geo file added to the model successfully!\"}\n\n\ngmsh.initialize()\n\n\ndef start_mesh_task(model_id):\n    model_db = model_service.get_model(model_id)\n    file = file_service.get_file_by_id(model_db.outputFileId)\n\n    directory = config.DefaultConfig.UPLOAD_FOLDER\n    file_name, file_extension = os.path.splitext(os.path.basename(file.fileName))\n    geo_path = os.path.join(directory, f\"{file_name}.geo\")\n    msh_path = os.path.join(directory, f\"{file_name}.msh\")\n    try:\n        if model_db.meshId:\n            Mesh.query.filter_by(id=model_db.meshId).delete()\n        task = Task(\n            taskType=TaskType.Mesh,\n        )\n        db.session.add(task)\n        db.session.commit()\n        mesh = Mesh(taskId=task.id)\n\n        db.session.add(mesh)\n        db.session.commit()\n        model_db.meshId = mesh.id\n        db.session.commit()\n    except Exception as ex:\n        db.session.rollback()\n        logger.error(f\"Error in mesh generation (db)! Error: {ex}\")\n        abort(400, message=f\"Error in mesh generation (db)! Error: {ex}\")\n\n    try:\n        generate_mesh(geo_path, msh_path, 1)\n    except Exception as ex:\n        logger.error(f\"Error in mesh generation (msh)! Error: {ex}\")\n        abort(400, message=f\"Error in mesh generation (msh)! Error: {ex}\")\n\n    if os.path.exists(msh_path):\n        try:\n            task.status = Status.Completed\n            db.session.commit()\n        except Exception as ex:\n            db.session.rollback()\n            logger.error(f\"Error in mesh generation (db)! Error: {ex}\")\n            abort(400, message=f\"Error in mesh generation (db)! Error: {ex}\")\n    else:\n        try:\n            task.status = Status.Error\n            message = \"Possibly you don't have Gmsh installed on your device,\"\n            message += \"or Gmsh has not been initialized!\"\n            task.message = message\n            logger.error(\"Someone is trying to create mesh but they can't!\")\n            db.session.commit()\n        except Exception as ex:\n            db.session.rollback()\n            logger.error(f\"Error in mesh generation (db)! Error: {ex}\")\n            abort(400, message=f\"Error in mesh generation (db)! Error: {ex}\")\n\n    return mesh\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}