{
  "source_url": "https://github.com/969flash/DesignAutomationLecture/blob/4e85efcd91e11c0715f2ff7d7e1162cc84c942f1/stub/RhinoStub/rhino3d-8.19.25132.1001/Rhino/Runtime/Notifications/__init__.pyi",
  "repo": "969flash/DesignAutomationLecture",
  "repo_stars": 0,
  "repo_description": "DesignAutomationLecture",
  "license": "unknown",
  "filepath": "stub/RhinoStub/rhino3d-8.19.25132.1001/Rhino/Runtime/Notifications/__init__.pyi",
  "instruction": "this file is auto-generated by rhinocode stubmaker. do not make changes",
  "code": "\"\"\"this file is auto-generated by rhinocode stubmaker. do not make changes\"\"\"\n\n# region: Exports\n__all__ = [\"IAssemblyRestrictedObject\", \"Notification\", \"ButtonType\", \"NotificationButtonClickedArgs\", \"NotificationCenter\", \"TrulyObservableOrderedSet\", \"Severity\"]\n# endregion\n\n# region: Imports\nfrom System.Collections import Generic\nfrom System.Runtime import CompilerServices\nfrom typing import overload\nimport enum\nimport System\n# endregion\n\n# region: RhinoCommon, Version=8.19.25132.1001\n\nclass IAssemblyRestrictedObject:\n    \"\"\"A class that implements this interface signals its clients that its instances can only be modified by certain assemblies. This is useful in cases where only certain assemblies should be able to modify an object. The actual members of an instance that are restricted are left to the discretion of the instance's class, and should be documented.\n\n    \"\"\"\n    @overload\n    def Editable() -> bool: ...\n\nclass Notification(object):\n    \"\"\"A Notification instance can be used to inform the user about various events. For a Notification instance to be displayed in Rhino, it must be added to the\n. When added, it will be displayed in the Notifications panel in Rhino. A Notification contains 1 to 3 buttons that are automatically wired to its\nAction if it is not null. The buttons are displayed when the Notification is shown modally by either the user clicking on a particular notification in the Notifications panel, or by programatically showing it using\n. Currently, only process-wide notifications are supported; document specific notifications are not possible. Notification instances contain metadata that can be added, modified, or removed during its life. The metadata is important for LINQ queries and other patterns. For example, a particular action may require that multiple notifications be modified. Thus, a LINQ query can be performed on the\nusing metadata to retrieve related Notification objects and modify them as a batch. Notification objects implement\n. By default, a Notification can be editedby any assembly, but explicitly specifing allowed assemblies in the constructor changes this behavior. Notification objects are not thread-safe and should only be manipulated in UI thread.\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, allowedAssemblies: Generic.IEnumerable): ...\n    @overload\n    def Editable() -> bool: ...\n    @overload\n    @staticmethod\n    def ExecuteAssemblyProtectedCode(func: System.Func) -> TResult: ...\n    @overload\n    @staticmethod\n    def ExecuteAssemblyProtectedCode(action: System.Action) -> None: ...\n    @property\n    def AllowedAssemblies(self) -> Generic.ICollection: ...\n    @property\n    def AlternateButtonTitle(self) -> str: ...\n    @property\n    def ButtonClicked(self) -> System.Action: ...\n    @property\n    def CancelButtonTitle(self) -> str: ...\n    @property\n    def ConfirmButtonTitle(self) -> str: ...\n    @property\n    def DateUpdated(self) -> System.DateTime: ...\n    @property\n    def Description(self) -> str: ...\n    @property\n    def Item(self) -> str: ...\n    @property\n    def Message(self) -> str: ...\n    @property\n    def MetadataCopy(self) -> Generic.IDictionary: ...\n    @property\n    def SeverityLevel(self) -> Severity: ...\n    @property\n    def ShowEventId(self) -> System.Nullable: ...\n    @property\n    def Title(self) -> str: ...\n    @overload\n    def HideModal() -> None: ...\n    @overload\n    def RemoveMetadata(self, key: str) -> bool: ...\n    @AlternateButtonTitle.setter\n    def AlternateButtonTitle(self, value: System.Void): ...\n    @ButtonClicked.setter\n    def ButtonClicked(self, value: System.Void): ...\n    @CancelButtonTitle.setter\n    def CancelButtonTitle(self, value: System.Void): ...\n    @ConfirmButtonTitle.setter\n    def ConfirmButtonTitle(self, value: System.Void): ...\n    @Description.setter\n    def Description(self, value: System.Void): ...\n    @Item.setter\n    def Item(self, value: System.Void): ...\n    @Message.setter\n    def Message(self, value: System.Void): ...\n    @SeverityLevel.setter\n    def SeverityLevel(self, value: System.Void): ...\n    @Title.setter\n    def Title(self, value: System.Void): ...\n    @overload\n    def ShowModal() -> None: ...\n    @overload\n    def ToString() -> str: ...\n    @property\n    def PropertyChanged(self): ...\n\nclass ButtonType(enum.Enum):\n    CancelOrClose = 0\n    Confirm = 1\n    Alternate = 2\n\nclass NotificationButtonClickedArgs(System.EventArgs):\n    \"\"\"Used when a button is clicked for a notification.\n\n    \"\"\"\n    def __init__(self, notification: Notification, buttonClicked: ButtonType): ...\n    @property\n    def ButtonClicked(self) -> ButtonType: ...\n    @property\n    def Notification(self) -> Notification: ...\n\nclass NotificationCenter(object):\n    \"\"\"The NotificationCenter holds all\nobjects that are displayed in the Notifications panel by Rhino. The NotificationCenter is not thread-safe and should only be used in the UI thread.\n\n    \"\"\"\n    @property\n    def Notifications(self) -> TrulyObservableOrderedSet: ...\n\nclass TrulyObservableOrderedSet(object):\n    \"\"\"An ordered set that notifies its subscribers whenever one of its INotifyPropertyChanged elements raises its PropertyChanged event.\n\n    TrulyObservableOrderedSet[T]\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, items: Generic.IEnumerable): ...\n    @overload\n    def Add(self, item: T) -> None: ...\n    @overload\n    def Clear() -> None: ...\n    @overload\n    def Contains(self, item: T) -> bool: ...\n    @overload\n    def CopyTo(self, array: System.Array[T], arrayIndex: int) -> None: ...\n    @property\n    def Count(self) -> int: ...\n    @property\n    def IsReadOnly(self) -> bool: ...\n    @property\n    def Item(self) -> T: ...\n    @overload\n    def GetEnumerator() -> Generic.IEnumerator: ...\n    @overload\n    def IndexOf(self, item: T) -> int: ...\n    @overload\n    def Insert(self, index: int, item: T) -> None: ...\n    @overload\n    def Remove(self, item: T) -> bool: ...\n    @overload\n    def RemoveAt(self, index: int) -> None: ...\n    @Item.setter\n    def Item(self, value: System.Void): ...\n    @overload\n    def Sort(self, keySelector: System.Func, descending: bool) -> None: ...\n    @property\n    def CollectionChanged(self): ...\n\nclass Severity(enum.Enum):\n    Debug = 0\n    Info = 1\n    Warning = 2\n    Serious = 3\n    Critical = 4\n\n# endregion\n",
  "language": "python",
  "imports": [
    "RhinoCommon"
  ],
  "has_docstring": true
}