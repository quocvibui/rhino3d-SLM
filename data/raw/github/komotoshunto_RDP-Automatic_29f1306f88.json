{
  "source_url": "https://github.com/komotoshunto/RDP-Automatic/blob/680b2cc9081582547d1b37440ec7ea97a94a14ea/%E9%96%A2%E6%95%B0/%E9%9B%A8%E3%81%8C%E5%BD%93%E3%81%9F%E3%82%8B%E5%A0%B4%E6%89%80%E3%81%AE%E6%8A%BD%E5%87%BA/%E9%9B%A8%E3%81%8C%E5%BD%93%E3%81%9F%E3%82%8B%E8%A7%92%E5%BA%A6%E3%81%AE%E6%8A%BD%E5%87%BA_%E4%B8%80%E4%BD%93%E5%9E%8B.py",
  "repo": "komotoshunto/RDP-Automatic",
  "repo_stars": 0,
  "repo_description": "雨水排水計画を自動化するツール",
  "license": "unknown",
  "filepath": "関数/雨が当たる場所の抽出/雨が当たる角度の抽出_一体型.py",
  "instruction": "Input Roof_list, List Access, Mesh rain_angle, Item Access, int barrier, List Access, Geometry Base",
  "code": "#Input\n#Roof_list, List Access, Mesh\n#rain_angle, Item Access, int\n#barrier, List Access, Geometry Base\n\n#Output\n#centroid_list, meshの各重心\n#vec, \n#bool_list, 雨が当たるかの判定(True:当たる, False:当たらない)\n\n\nimport rhinoscriptsyntax as rs\nimport Rhino.Geometry as rg\nimport ghpythonlib.components as ghcomp\nimport math\n\n\n#各角度を定義する\nmax_angle = rain_angle\nmin_angel = 0\nvec_list = []\nstep = 10\naxis1 = rg.Vector3d(0.0, 1.0, 0.0)\naxis2 = rg.Vector3d(0.0, 0.0, 1.0)\nfor i in range(min_angel, max_angle + 1, step):\n    for k in range(0, 360, 30):\n        if i == 0:\n            vec = rg.Vector3d(0.0, 0.0, 1.0)\n            vec_list.append(vec)\n            break\n        else:\n            angleRad1 = math.radians(i)\n            angleRad2 = math.radians(k)\n            vec = rg.Vector3d(0.0, 0.0, 1.0)\n            re_vec1 = rg.Vector3d.Rotate(vec, angleRad1, axis1)\n            re_vec2 = rg.Vector3d.Rotate(vec, angleRad2, axis2)\n            vec_list.append(vec)\n\n\n#Meshの中心点を求める関数\ndef Mesh_center(mesh):\n    centroid = []\n    meshfacelist = mesh.Faces\n    for num, val in enumerate(meshfacelist):\n        center = rg.Collections.MeshFaceList.GetFaceCenter(meshfacelist, num)\n        centroid.append(center)\n    return centroid\n\n#照射点をmeshから法線方向にずらす\ndef MovePoint(normal_unit, length, point):\n    normal = normal_unit * length\n    transform = rg.Transform.Translation(normal)\n    rg.Point3d.Transform(point, transform)\n    return point\n#ずらす長さ\nlength = 0.1\ndef NormalOffset_FromMesh(mesh):\n    point_list = []\n    result = ghcomp.FaceNormals(mesh)\n    points = result[0]\n    if isinstance(points, list):\n        for num in range(len(points)):\n            point = points[num]\n            normal_unit = result[1][num]\n            point = MovePoint(normal_unit, length, point)\n            point_list.append(point)\n    else:\n        point = points\n        normal_unit = result[1]\n        point = MovePoint(normal_unit, length, point)\n        point_list.append(point)\n    return point_list\n\n\n#点群から最も雨の当たる角度を求める\ndef max_RainAngle(centroid_list, barrier):\n    ans_cou = float(\"inf\")\n    bool_list = []    \n    ans_collision = []\n    for vec in vec_list:\n        projectpoint = ghcomp.ProjectPoint(centroid_list, vec, barrier)\n        #ぶつかるものがなかった場合\n        if projectpoint[0] == None:\n            ans_vec = vec\n            print(\"error\")\n            if isinstance(projectpoint[1], list):\n                ans_collision = projectpoint[1]\n            else:\n                ans_collision = [projectpoint[1]]\n            break\n        #ぶつかるものがあった場合\n        else:\n            cou = len(projectpoint[0])\n            if ans_cou > cou:\n                ans_cou = cou\n                ans_vec = vec\n                ans_collision = projectpoint[1]\n    \n    \n    #ぶつかったインデックスのリストをBoolのリストに変換する\n    for i in ans_collision:\n        if i == -1:\n            bool_list.append(True)\n        else:\n            bool_list.append(False)\n    return ans_vec, bool_list\n\n\n#\ncentroid_list = []\nfor i in Roof_list:\n    centroid = NormalOffset_FromMesh(i)\n    for k in centroid:\n        centroid_list.append(k)\n\n\n\nvec, bool_list = max_RainAngle(centroid_list, barrier)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}