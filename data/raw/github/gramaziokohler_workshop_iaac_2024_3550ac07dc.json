{
  "source_url": "https://github.com/gramaziokohler/workshop_iaac_2024/blob/d430620ba0f41e0bdc69a569d3154d3cd9f9c97e/design_tool/src/compas_urt/design/generative.py",
  "repo": "gramaziokohler/workshop_iaac_2024",
  "repo_stars": 1,
  "repo_description": "Workshop: Designing Robotic Pixels with COMPAS",
  "license": "MIT",
  "filepath": "design_tool/src/compas_urt/design/generative.py",
  "instruction": "Generative",
  "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport math as m\nimport random\nimport time\n\nimport Rhino.Geometry as rg\nfrom compas.colors import Color\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Circle\nfrom compas.geometry import Frame\nfrom compas.geometry import Plane\nfrom compas.geometry import Vector\nfrom compas.geometry import distance_point_point\nfrom compas.utilities import flatten\nfrom compas_rhino.conversions import RhinoCurve\nfrom compas_rhino.conversions import frame_to_rhino\n\nfrom compas_urt.design import DesignLayer\nfrom compas_urt.design import RoundTile\nfrom compas_urt.design.ellipse_with_frame import EllipseFrame\n\n\nclass GenLayer(DesignLayer):\n    def generate(self):\n        pass\n\n\nclass GridLayer(GenLayer):\n    def __init__(self, rhino_brep, tile_diameter, tile_thickness, tile_joint, **kwargs):\n        super(GridLayer, self).__init__(rhino_brep, **kwargs)\n        # self.curve_type = curve_type\n        self.tile_diameter = tile_diameter\n        self.tile_joint = tile_joint\n        self.tile_thickness = tile_thickness\n\n    def generate(self):\n        uniform = self.options[\"uniform\"]\n        pack_type = self.options[\"pack_type\"]\n        param_density = self.options[\"param_density\"]\n        flip_curves = self.options[\"flip_curves\"]\n        flip_frame = self.options[\"flip_frame\"]\n        curve_type = self.options.get(\"curve_type\")\n        reverse_curve_params = self.options.get(\"reverse_curve_params\")\n\n        unit_size = self.tile_diameter + self.tile_joint\n        equilateral_height = unit_size * m.sqrt(3) / 2\n\n        brepface = self.rhino_brep.Faces[0]\n\n        frames = []\n        uv_params = []\n\n        # TODO: check which edge isocurve has the biggest length! otherwise you might not cover the whole surface with isocurves\n\n        if pack_type == \"hexagonal\":\n            unit = equilateral_height\n            division_mode = \"by_length\"\n        else:\n            unit = unit_size\n            division_mode = \"by_count\"\n\n        min_u_edge = None\n        min_v_edge = None\n\n        for i in range(50):\n            temp_u = self.compas_surface.u_isocurve(i / 50)\n            temp_v = self.compas_surface.v_isocurve(i / 50)\n\n            if temp_u.length() > 0:\n                if min_u_edge is None or temp_u.length() < min_u_edge.length():\n                    min_u_edge = temp_u\n            if temp_v.length() > 0:\n                if min_v_edge is None or temp_v.length() < min_v_edge.length():\n                    min_v_edge = temp_v\n        if min_u_edge is None or min_v_edge is None:\n            raise Exception(\"The isocurve length in either u or v direction cannot be None\")\n\n        if curve_type == \"isocurves\":\n            if flip_curves:\n                # self.edge_isocurve = self.compas_surface.u_isocurve(0.5)\n                self.edge_isocurve = min_u_edge\n            else:\n                # self.edge_isocurve = self.compas_surface.v_isocurve(0.5)\n                self.edge_isocurve = min_v_edge\n\n            edge_params = self.generate_params_on_curve(\n                self.edge_isocurve,\n                unit_size=unit,\n                uniform=uniform,\n                param_density=param_density,\n                division_mode=division_mode,\n            )\n\n            self.isocurves = self.generate_isocurves(edge_params, flip_curves)\n\n            for i, (edge_param, isocurve) in enumerate(zip(edge_params, self.isocurves)):\n                if isocurve.length() < unit:\n                    continue\n                unit_reparam = unit_size / isocurve.length()\n                parameters = self.generate_params_on_curve(isocurve, unit_size=unit_size, uniform=True, param_density=1)\n\n                for isocurve_param in parameters:\n                    if pack_type == \"hexagonal\":\n                        if i % 2:\n                            isocurve_param += unit_reparam / 2\n\n                    if not flip_curves:\n                        u = edge_param\n                        v = isocurve_param\n                    else:\n                        v = edge_param\n                        u = isocurve_param\n\n                    pointBrepFaceRelationship = brepface.IsPointOnFace(u, v)\n                    if pointBrepFaceRelationship == rg.PointFaceRelation.Exterior:\n                        continue\n\n                    point = isocurve.point_at(isocurve_param)\n                    frame, uv_param = self.generate_tile_frame_on_surface(point, flip_frame)\n                    frames.append(frame)\n                    uv_params.append(uv_param)\n\n        elif curve_type == \"contours\":\n            if \"input_curves\" not in self.options:\n                raise Exception(\"Please specify input curves.\")\n\n            input_curves = self.options[\"input_curves\"]\n\n            # for input_curve in input_curves:\n\n            # edge_params = self.generate_params_on_curve(input_curve, unit, uniform, param_density)\n\n            compas_contours_nested, self.contour_frames = self.generate_contours(\n                input_curves, unit, uniform, param_density, reverse_curve_params\n            )\n\n            for i, contour_segments in enumerate(compas_contours_nested):\n                for contour_segment in contour_segments:\n                    params = self.generate_params_on_curve(\n                        contour_segment, unit_size=unit, uniform=True, param_density=0.5\n                    )\n\n                    points = []\n                    if params is None:\n                        continue\n                    for param in params:\n                        point = contour_segment.point_at(param)\n                        points.append(point)\n\n                    for j, point in enumerate(points):\n                        frame = None  # reset your frame, previously stored frame creates a fuckup\n\n                        if pack_type == \"hexagonal\":\n                            if (j % 2 == 0 and i % 2 == 0) or (j % 2 == 1 and i % 2 == 1):\n                                frame, uv_param = self.generate_tile_frame_on_surface(point, flip_frame)\n                        elif pack_type == \"aligned\":\n                            if j % 2 == 0:\n                                frame, uv_param = self.generate_tile_frame_on_surface(point, flip_frame)\n\n                        if frame is not None:\n                            uv_params.append(uv_param)\n                            frames.append(frame)\n\n            self.compas_contours = list(flatten(compas_contours_nested))\n\n        for f, uv_param in zip(frames, uv_params):\n            round_tile = RoundTile(\n                base_frame=f, diameter=self.tile_diameter, thickness=self.tile_thickness, uv_param=uv_param\n            )\n            self.tiles.append(round_tile)\n\n\nclass BubblesFromCurveLayer(GenLayer):\n    def __init__(\n        self,\n        rhino_brep,\n        input_curve,\n        division_num,\n        tile_joint,\n        effect_factor=0,\n        xsize_domain=None,\n        ysize_domain=None,\n        **kwargs\n    ):\n        super(BubblesFromCurveLayer, self).__init__(rhino_brep, **kwargs)\n        self.input_curve = input_curve\n        self.division_num = division_num\n        self.xsize_domain = xsize_domain\n        self.ysize_domain = ysize_domain\n        self.tile_joint = tile_joint\n        self.effect_factor = effect_factor\n        self.bubbles = []\n        self.points_on_curve = []  # TODO: remove\n\n    def generate(self):\n        bubble_frames = self.generate_bubble_frames()\n        for frame in bubble_frames:\n            bubble_xsize = Bubble.assign_size_from_domain(self.xsize_domain)\n            bubble_ysize = Bubble.assign_size_from_domain(self.ysize_domain)\n            bubble = Bubble(frame, bubble_xsize, bubble_ysize)\n            self.bubbles.append(bubble)\n\n        self.relax_bubbles()\n\n    def generate_bubble_frames(self):\n        ## Generate initial ellipses\n        ##------------------------------------------------------------------------------\n        self.tiles = []\n\n        bubble_frames = []\n\n        if self.division_num == 0:\n            raise Exception(\"Division points cannot be zero.\")\n        _, points = self.input_curve.divide_by_count(self.division_num, return_points=True)\n\n        for point in points:\n            _, uv_param = self.compas_surface.closest_point(point, return_parameters=True)\n            frame = self.compas_surface.frame_at(uv_param[0], uv_param[1])\n            bubble_frames.append(frame)\n\n        return bubble_frames\n\n    def relax_bubbles(self):\n        TOLERANCE = 0.001\n        TIMEOUT_IN_SECONDS = 60\n        start_time = time.time()\n        while True:\n            self.push_bubbles()\n            now_time = time.time()\n            if self.sum_of_moves < TOLERANCE or (now_time - start_time > TIMEOUT_IN_SECONDS):\n                break\n\n        # Randomize the shape\n        ##------------------------------------------------------------------------------\n\n        # Project bubbles on compas_surface\n        ##------------------------------------------------------------------------------\n\n        for bubble in self.bubbles:\n            bubble_shape = bubble.ellipse\n\n            rhino_frame = frame_to_rhino(bubble.frame)\n\n            rhino_bubble_shape = rg.Ellipse(rhino_frame, bubble_shape.major, bubble_shape.minor)\n            rhino_nurbs_curve = rhino_bubble_shape.ToNurbsCurve()\n\n            projected_curves = rg.Curve.ProjectToBrep(rhino_nurbs_curve, self.rhino_brep, rhino_frame.ZAxis, 0.01)\n\n            for projected_curve in projected_curves:\n                compas_nurbs_curve = RhinoCurve.from_geometry(projected_curve).to_compas()\n                bubble.projected_curves.append(compas_nurbs_curve)\n\n    def get_motion_vectors(self):\n        collisions_count = []\n        total_moves = []\n\n        # initial values for total_moves and collisions_count\n        ##------------------------------------------------------------------------------\n        for i in range(len(self.bubbles)):\n            total_moves.append(Vector(0.0, 0.0, 0.0))\n            collisions_count.append(0)\n\n        # double loop for accessing 2 tiles at the same time\n        ##------------------------------------------------------------------------------\n        self.circles = []\n        for i in range(len(self.bubbles)):\n            for j in range(i + 1, len(self.bubbles)):\n                # get distance between 2 bubble centers\n                ##------------------------------------------------------------------------------\n                center_i = self.bubbles[i].frame.point\n                center_j = self.bubbles[j].frame.point\n                distance = distance_point_point(center_i, center_j)\n\n                # get the radius of circumscribed circle, from the ellipse of each bubble\n                ##------------------------------------------------------------------------------\n                xsize_i = self.bubbles[i].xsize\n                ysize_i = self.bubbles[i].ysize\n                xsize_j = self.bubbles[j].xsize\n                ysize_j = self.bubbles[j].ysize\n\n                self.radius_i = max(xsize_i, ysize_i)\n                self.radius_j = max(xsize_j, ysize_j)\n\n                # create circumscribed circles\n                ##------------------------------------------------------------------------------\n                plane = Plane.from_frame(self.bubbles[j].frame)\n                self.circles.append(Circle(plane, self.radius_j))\n\n                # collision distance is the sum of the 2 radii, of the corresponding tiles\n                ##------------------------------------------------------------------------------\n                collision_distance = self.radius_i + self.radius_j\n\n                # push distance is the collision_distance * effect_factor\n                ##------------------------------------------------------------------------------\n                push_distance = collision_distance * self.effect_factor\n\n                # push vector pointing from j point to i point\n                ##------------------------------------------------------------------------------\n                if distance > push_distance:\n                    continue\n\n                push_vector_dir = center_i - center_j\n\n                if not push_vector_dir.length == 0:\n                    push_vector_dir.unitize()\n\n                push_vector = push_vector_dir * (push_distance - distance) / 2\n                # push_vector_j = push_vector_dir * (push_distance - distance) / 2\n\n                # note: signs according to order of subtraction: push_vector_dir = center_i - center_j\n                ##------------------------------------------------------------------------------\n                total_moves[i] += push_vector\n                collisions_count[i] += 1\n\n                total_moves[j] -= push_vector\n                collisions_count[j] += 1\n\n        return total_moves, collisions_count\n\n    def push_bubbles(self):\n        total_moves, collisions_count = self.get_motion_vectors()\n        self.sum_of_moves = sum([move.length for move in total_moves])\n\n        for i in range(len(self.bubbles)):\n            if collisions_count[i] == 0:\n                continue\n            # average -> sum of values / amount of values\n            ##------------------------------------------------------------------------------\n            average_move = total_moves[i] / collisions_count[i]\n            self.bubbles[i].frame.point += average_move\n\n            # project on the compas_surface (replace position with projected one)\n            point = self.bubbles[i].frame.point\n            frame, _ = self.generate_tile_frame_on_surface(point, flip_frame=False)\n            self.bubbles[i].frame = frame\n\n\nclass Bubble(object):\n    def __init__(self, frame, xsize, ysize):\n        self.frame = frame\n        self.xsize = xsize\n        self.ysize = ysize\n        if xsize == ysize:\n            self.radius = xsize\n        else:\n            self.radius = None\n        self.projected_curves = []\n\n    @classmethod\n    def assign_size_from_domain(cls, domain):\n        size = random.uniform(domain[0], domain[1])\n        size /= 2  # ellipse is instantiated with radius, not diameter!\n        return size\n\n    @classmethod\n    def assign_size_discrete(cls, dimensions):\n        diameter, thickness = random.choice(dimensions)\n        radius = diameter / 2\n        return radius, thickness\n\n    @property\n    def ellipse(self):\n        shape = EllipseFrame(self.frame, self.ysize, self.xsize)\n        return shape\n\n\nclass TileBrushLayer(BubblesFromCurveLayer):\n    def __init__(\n        self,\n        rhino_brep,\n        input_curve,\n        division_num,\n        tile_joint,\n        tile_diameters,\n        tile_thicknesses,\n        effect_factor=0,\n        **kwargs\n    ):\n        super(TileBrushLayer, self).__init__(\n            rhino_brep, input_curve, division_num, tile_joint, effect_factor=effect_factor, **kwargs\n        )\n        self.tile_diameters = tile_diameters\n        self.tile_thicknesses = tile_thicknesses\n\n        self.tile_dimensions = zip(self.tile_diameters, self.tile_thicknesses)\n\n    def generate(self):\n        bubble_frames = self.generate_bubble_frames()\n        tile_thicknesses = []\n        self.tiles = []\n\n        for frame in bubble_frames:\n            bubble_radius, tile_thickness = Bubble.assign_size_discrete(self.tile_dimensions)\n            bubble = Bubble(frame, bubble_radius, bubble_radius)\n            tile_thicknesses.append(tile_thickness)\n            self.bubbles.append(bubble)\n\n        # Spread the bubbles in the area of the effect\n        ##------------------------------------------------------------------------------\n        self.relax_bubbles()\n\n        brepface = self.rhino_brep.Faces[0]\n\n        for bubble, tile_thickness in zip(self.bubbles, tile_thicknesses):\n            _, uv_param = self.compas_surface.closest_point(bubble.frame.point, return_parameters=True)\n            pointBrepFaceRelationship = brepface.IsPointOnFace(*uv_param)\n            if pointBrepFaceRelationship == rg.PointFaceRelation.Exterior:\n                continue\n\n            round_tile = RoundTile(bubble.frame, bubble.radius * 2, thickness=tile_thickness, uv_param=uv_param)\n\n            self.tiles.append(round_tile)\n\n\nclass AddTileLayer(GenLayer):\n    def __init__(self, rhino_brep, points, tile_diameter, tile_thickness, **kwargs):\n        super(AddTileLayer, self).__init__(rhino_brep, **kwargs)\n        self.points = points\n        self.tile_diameter = tile_diameter\n        self.tile_thickness = tile_thickness\n        self.tiles = []\n\n    def generate(self):\n        flip_frame = self.options[\"flip_frame\"]\n        for point in self.points:\n            frame, uv_param = self.generate_tile_frame_on_surface(point, flip_frame)\n            round_tile = RoundTile(frame, self.tile_diameter, self.tile_thickness, uv_param=uv_param)\n            self.tiles.append(round_tile)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}