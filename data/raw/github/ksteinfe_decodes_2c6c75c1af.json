{
  "source_url": "https://github.com/ksteinfe/decodes/blob/b876d6d01ea23ccbf4558182582a822b008cf2b8/src/decodes/io/rhinoscript/utility.py",
  "repo": "ksteinfe/decodes",
  "repo_stars": 43,
  "repo_description": "a platform agnostic generative design library for 3d designers",
  "license": "GPL-3.0",
  "filepath": "src/decodes/io/rhinoscript/utility.py",
  "instruction": "Utility",
  "code": "import Rhino\nimport System.Drawing.Color, System.Array, System.Guid\nimport time\nimport System.Windows.Forms.Clipboard\nimport scriptcontext\nimport math\nimport string\n\n\ndef ContextIsRhino():\n    \"\"\"Returns True if the script is currently being executed in the context\n    of a normal script in Rhino\n    \"\"\"\n    return scriptcontext.id == 1\n\n\ndef ContextIsGrasshopper():\n    \"\"\"Returns True if the script is currently being executed in a grasshopper\n    component\n    \"\"\"\n    return scriptcontext.id == 2\n\n\n#should work all of the time unless we can't find the standard lib\n__cfparse = None\ntry:\n    import configparser\nexcept ImportError:\n    __cfparse = None\nelse:\n    __cfparse = ConfigParser\n\ndef Angle(point1, point2, plane=True):\n    \"\"\"Measures the angle between two points\n    Parameters:\n      point1, point2: the input points\n      plane[opt] = Boolean or Plane\n        If True, angle calculation is based on the world coordinate system.\n        If False, angle calculation is based on the active construction plane\n        If a plane is provided, angle calculation is with respect to this plane\n    Returns:\n      tuple containing the following elements if successful\n        element 0 = the X,Y angle in degrees\n        element 1 = the elevation\n        element 2 = delta in the X direction\n        element 3 = delta in the Y direction\n        element 4 = delta in the Z direction\n      None if not successful\n    \"\"\"\n    pt1 = coerce3dpoint(point1)\n    if pt1 is None:\n        pt1 = coercerhinoobject(point1)\n        if isinstance(pt1, Rhino.DocObjects.PointObject): pt1 = pt1.Geometry.Location\n        else: pt1=None\n    pt2 = coerce3dpoint(point2)\n    if pt2 is None:\n        pt2 = coercerhinoobject(point2)\n        if isinstance(pt2, Rhino.DocObjects.PointObject): pt2 = pt2.Geometry.Location\n        else: pt2=None\n    point1 = pt1\n    point2 = pt2\n    if point1 is None or point2 is None: return scriptcontext.errorhandler()\n    vector = point2 - point1\n    x = vector.X\n    y = vector.Y\n    z = vector.Z\n    if plane!=True:\n        plane = coerceplane(plane)\n        if plane is None:\n            plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n        vfrom = point1 - plane.Origin\n        vto = point2 - plane.Origin\n        x = vto * plane.XAxis - vfrom * plane.XAxis\n        y = vto * plane.YAxis - vfrom * plane.YAxis\n        z = vto * plane.ZAxis - vfrom * plane.ZAxis\n    h = math.sqrt( x * x + y * y)\n    angle_xy = math.degrees( math.atan2( y, x ) )\n    elevation = math.degrees( math.atan2( z, h ) )\n    return angle_xy, elevation, x, y, z\n\n\ndef Angle2(line1, line2):\n    \"\"\"Measures the angle between two lines\"\"\"\n    line1 = coerceline(line1, True)\n    line2 = coerceline(line2, True)\n    vec0 = line1.To - line1.From\n    vec1 = line2.To - line2.From\n    if not vec0.Unitize() or not vec1.Unitize(): return scriptcontext.errorhandler()\n    dot = vec0 * vec1\n    dot = clamp(-1,1,dot)\n    angle = math.acos(dot)\n    reflex_angle = 2.0*math.pi - angle\n    angle = math.degrees(angle)\n    reflex_angle = math.degrees(reflex_angle)\n    return angle, reflex_angle\n\n\ndef ClipboardText(text=None):\n    \"\"\"Returns or sets a text string to the Windows clipboard\n    Parameters:\n      text: [opt] text to set\n    Returns:\n      if text is not specified, the current text in the clipboard\n      if text is specified, the previous text in the clipboard\n      None if not successful, or on error\n    \"\"\"\n    rc = None\n    if System.Windows.Forms.Clipboard.ContainsText():\n        rc = System.Windows.Forms.Clipboard.GetText()\n    if text:\n        if not isinstance(text, str): text = str(text)\n        System.Windows.Forms.Clipboard.SetText(text)\n    return rc\n\n\ndef ColorAdjustLuma(rgb, luma, scale=False):\n    \"\"\"Changes the luminance of a red-green-blue value. Hue and saturation are\n    not affected\n    Parameters:\n      rgb = initial rgb value\n      luma = The luminance in units of 0.1 percent of the total range. A\n          value of luma = 50 corresponds to 5 percent of the maximum luminance\n      scale[opt] = if True, luma specifies how much to increment or decrement the\n          current luminance. If False, luma specified the absolute luminance.\n    Returns:\n      modified rgb value if successful\n      None on error\n    \"\"\"\n    rgb = coercecolor(rgb, True)\n    hsl = Rhino.Display.ColorHSL(rgb)\n    luma = luma / 1000.0\n    if scale: luma = hsl.L + luma\n    hsl.L = luma\n    rgb = hsl.ToArgbColor()\n    return rgb.ToArgb()\n\n\ndef ColorBlueValue(rgb):\n    \"Retrieves intensity value for the blue component of an RGB color\"\n    rgb = coercecolor(rgb, True)\n    return rgb.B\n\n\ndef ColorGreenValue(rgb):\n    \"Retrieves intensity value for the green component of an RGB color\"\n    rgb = coercecolor(rgb, True)\n    return rgb.G\n\n\ndef ColorHLSToRGB(hls):\n    \"Converts colors from hue-lumanence-saturation to RGB\"\n    if len(hls)==3:\n        hls = Rhino.Display.ColorHSL(hls[0]/240.0, hls[2]/240.0, hls[1]/240.0)\n    elif len(hls)==4:\n        hls = Rhino.Display.ColorHSL(hls[3]/240.0, hls[0]/240.0, hls[2]/240.0, hls[1]/240.0)\n    else:\n        return scriptcontext.errorhandler()\n    rgb = hls.ToArgbColor()\n    return rgb.ToArgb()\n\n\ndef ColorRedValue(rgb):\n    \"Retrieves intensity value for the red component of an RGB color\"\n    rgb = coercecolor(rgb, True)\n    return rgb.R\n\n\ndef ColorRGBToHLS(rgb):\n    \"Converts colors from RGB to HLS\"\n    rgb = coercecolor(rgb, True)\n    hls = Rhino.Display.ColorHSL(rgb)\n    return (hls.H, hls.S, hls.L, hls.A)\n\n\ndef CullDuplicatePoints(points, tolerance=-1):\n    \"\"\"Removes duplicates from a list of 3D points.\n    Parameters:\n      points = A list of 3D points.\n      tolerance [opt] = Minimum distance between points. Points within this\n        tolerance will be discarded. If omitted, Rhino's internal zero tolerance\n        is used.\n    Returns:\n      list of 3D points with duplicates removed if successful.\n      None if not successful or on error.\n    \"\"\"\n    points = coerce3dpointlist(points, True)\n    if tolerance is None or tolerance < 0:\n        tolerance = Rhino.RhinoMath.ZeroTolerance\n    return Rhino.Geometry.Point3d.CullDuplicates(points, tolerance)\n\n\ndef Distance(point1, point2):\n    \"\"\"Measures the distance between two 3D points, or between a 3D point and\n    an array of 3-D points.\n    Parameters:\n      point1 = The first 3D point.\n      point2 = The second 3D point or list of 3-D points.\n    Returns:\n      If point2 is a 3D point then the distance if successful.\n      If point2 is a list of points, then an list of distances if successful.\n      None if not successful, or on error.\n    \"\"\"\n    from_pt = coerce3dpoint(point1, True)\n    to_pt = coerce3dpoint(point2)\n    if to_pt:\n        vec = to_pt - from_pt\n        return vec.Length\n    # check if we have a list of points\n    to_pt = coerce3dpointlist(point2, True)\n    distances = []\n    for point in to_pt:\n        vec = point - from_pt\n        distances.append(vec.Length)\n    if len(distances)==0: return scriptcontext.errorhandler()\n    return distances\n\n\ndef GetSettings(filename, section=None, entry=None):\n    \"\"\"Returns string from a specified section in a initialization file.\n    Parameters:\n      filename = name of the initialization file\n      section[opt] = section containing the entry\n      entry[opt] = entry whose associated string is to be returned\n    Returns:\n      If section is not specified, a list containing all section names\n      If entry is not specified, a list containing all entry names for a given section\n      If section and entry are specied, a value for entry\n      None if not successful or on error\n    \"\"\"\n    if __cfparse is None: return scriptcontext.errorhandler()\n    try:\n        cp = configparser.ConfigParser()\n        cp.read(filename)\n        if not section: return cp.sections()\n        section = string.lower(section)\n        if not entry: return cp.options(section)\n        entry = string.lower(entry)\n        return cp.get(section, entry)\n    except IOError:\n        return scriptcontext.errorhander()\n    return scriptcontext.errorhandler()\n\n\ndef Polar(point, angle_degrees, distance, plane=None):\n    \"\"\"Returns 3D point that is a specified angle and distance from a 3D point\n    Parameters:\n      point = the point to transform\n      plane[opt] = plane to base the transformation. If omitted, the world\n        x-y plane is used\n    Returns:\n      resulting point is successful\n      None on error\n    \"\"\"\n    point = coerce3dpoint(point, True)\n    angle = math.radians(angle_degrees)\n    if plane: plane = coerceplane(plane)\n    else: plane = Rhino.Geometry.Plane.WorldXY\n    offset = plane.XAxis\n    offset.Unitize()\n    offset *= distance\n    rc = point+offset\n    xform = Rhino.Geometry.Transform.Rotation(angle, plane.ZAxis, point)\n    rc.Transform(xform)\n    return rc\n\n\ndef Sleep(milliseconds):\n    \"Suspends execution of a running script for the specified interval\"\n    sec = milliseconds / 1000.0\n    time.sleep(sec)\n    Rhino.RhinoApp.Wait() #keep the message pump alive\n    \n\ndef SortPointList(points, tolerance=None):\n    \"\"\"Sorts list of points so they will be connected in a \"reasonable\" polyline order\n    Parameters:\n      points = the points to sort\n      tolerance[opt] = minimum distance between points. Points that fall within this tolerance\n        will be discarded. If omitted, Rhino's internal zero tolerance is used.\n    Returns:\n      a list of sorted 3D points if successful\n      None on error\n    \"\"\"\n    points = coerce3dpointlist(points, True)\n    if tolerance is None: tolerance = Rhino.RhinoMath.ZeroTolerance\n    return Rhino.Geometry.Point3d.SortAndCullPointList(points, tolerance)\n\n\ndef SortPoints(points, ascending=True, order=0):\n    \"Sorts an array of 3D points\"\n    def __cmpXYZ( a, b ):\n        rc = cmp(a.X, b.X)\n        if rc==0: rc = cmp(a.Y, b.Y)\n        if rc==0: rc = cmp(a.Z, b.Z)\n        return rc\n    def __cmpXZY( a, b ):\n        rc = cmp(a.X, b.X)\n        if rc==0: rc = cmp(a.Z, b.Z)\n        if rc==0: rc = cmp(a.Y, b.Y)\n        return rc\n    def __cmpYXZ( a, b ):\n        rc = cmp(a.Y, b.Y)\n        if rc==0: rc = cmp(a.X, b.X)\n        if rc==0: rc = cmp(a.Z, b.Z)\n        return rc\n    def __cmpYZX( a, b ):\n        rc = cmp(a.Y, b.Y)\n        if rc==0: rc = cmp(a.Z, b.Z)\n        if rc==0: rc = cmp(a.X, b.X)\n        return rc\n    def __cmpZXY( a, b ):\n        rc = cmp(a.Z, b.Z)\n        if rc==0: rc = cmp(a.X, b.X)\n        if rc==0: rc = cmp(a.Y, b.Y)\n        return rc\n    def __cmpZYX( a, b ):\n        rc = cmp(a.Z, b.Z)\n        if rc==0: rc = cmp(a.Y, b.Y)\n        if rc==0: rc = cmp(a.X, b.X)\n        return rc\n    \n    sortfunc = __cmpXYZ\n    if order==1: sortfunc = __cmpXZY\n    elif order==2: sortfunc = __cmpYXZ\n    elif order==3: sortfunc = __cmpYZX\n    elif order==4: sortfunc = __cmpZXY\n    elif order==5: sortfunc = __cmpZYX\n    reverse = not ascending\n    return sorted(points, sortfunc, None, reverse)\n\n\ndef Str2Pt(point):\n    \"converts a formatted string value into a 3-D point value\"\n    return coerce3dpoint(point, True)\n\n\ndef clamp(lowvalue, highvalue, value):\n    if lowvalue>=highvalue: raise Exception(\"lowvalue must be less than highvalue\")\n    if value<lowvalue: return lowvalue\n    if value>highvalue: return highvalue\n    return value\n\n\ndef fxrange(start, stop, step):\n    \"a float version of the xrange function\"\n    if step==0: raise ValueError(\"step must not equal 0\")\n    x = start\n    if start<stop:\n        if step<0: raise ValueError(\"step must be greater than 0\")\n        while x<=stop:\n            yield x\n            x+=step\n    else:\n        if step>0: raise ValueError(\"step must be less than 0\")\n        while x>=stop:\n            yield x\n            x+=step\n\n\ndef frange(start, stop, step):\n    \"a float version of the range function\"\n    return [x for x in fxrange(start, stop, step)]\n\n\ndef coerce3dpoint(point, raise_on_error=False):\n    \"Convert input into a Rhino.Geometry.Point3d if possible.\"\n    if type(point) is Rhino.Geometry.Point3d: return point\n    if hasattr(point, \"__len__\") and len(point)==3 and hasattr(point, \"__getitem__\"):\n        return Rhino.Geometry.Point3d(float(point[0]), float(point[1]), float(point[2]))\n    if type(point) is Rhino.Geometry.Vector3d or type(point) is Rhino.Geometry.Point3f or type(point) is Rhino.Geometry.Vector3f:\n        return Rhino.Geometry.Point3d(point.X, point.Y, point.Z)\n    if type(point) is str:\n        point = point.split(',')\n        return Rhino.Geometry.Point3d( float(point[0]), float(point[1]), float(point[2]) )\n    if type(point) is System.Guid:\n        rhobj = coercerhinoobject(point, raise_on_error)\n        if rhobj:\n            geom = rhobj.Geometry\n            if isinstance(geom, Rhino.Geometry.Point): return geom.Location\n    if raise_on_error: raise ValueError(\"Could not convert %s to a Point3d\" % point)\n\n\ndef coerce2dpoint(point, raise_on_error=False):\n    \"Convert input into a Rhino.Geometry.Point2d if possible.\"\n    if type(point) is Rhino.Geometry.Point2d: return point\n    if type(point) is list or type(point) is tuple:\n        length = len(point)\n        if length==2 and type(point[0]) is not list and type(point[0]) is not Rhino.Geometry.Point2d:\n            return Rhino.Geometry.Point2d(point[0], point[1])\n    if type(point) is Rhino.Geometry.Vector3d or type(point) is Rhino.Geometry.Point3d:\n        return Rhino.Geometry.Point2d(point.X, point.Y)\n    if type(point) is str:\n        point = point.split(',')\n        return Rhino.Geometry.Point2d( float(point[0]), float(point[1]) )\n    if raise_on_error: raise ValueError(\"Could not convert %s to a Point2d\" % point)\n\n\ndef coerce3dvector(vector, raise_on_error=False):\n    \"Convert input into a Rhino.Geometry.Vector3d if possible.\"\n    if type(vector) is Rhino.Geometry.Vector3d: return vector\n    point = coerce3dpoint(vector, False)\n    if point: return Rhino.Geometry.Vector3d(point.X, point.Y, point.Z)\n    if raise_on_error: raise ValueError(\"Could not convert %s to a Vector3d\" % vector)\n\n\ndef coerce3dpointlist(points, raise_on_error=False):\n    if isinstance(points, System.Array[Rhino.Geometry.Point3d]):\n        return list(points)\n    if isinstance(points, Rhino.Collections.Point3dList): return list(points)\n    if type(points) is list or type(points) is tuple:\n        count = len(points)\n        if count>0 and (coerce3dpoint(points[0]) is not None):\n            return [coerce3dpoint(points[i], raise_on_error) for i in range(count)]\n        elif count>2 and type(points[0]) is not list:\n            point_count = count/3\n            rc = []\n            for i in range(point_count):\n                pt = Rhino.Geometry.Point3d(points[i*3], points[i*3+1], points[i*3+2])\n                rc.append(pt)\n            return rc\n    if raise_on_error: raise ValueError(\"Could not convert %s to a list of points\" % points)\n\n\ndef coerce2dpointlist(points):\n    if points is None or isinstance(points, System.Array[Rhino.Geometry.Point2d]):\n        return points\n    if type(points) is list or type(points) is tuple:\n        count = len(points)\n        if count>0 and type(points[0]) is Rhino.Geometry.Point2d:\n            rc = System.Array.CreateInstance(Rhino.Geometry.Point2d, count)\n            for i in range(count): rc[i] = points[i]\n            return rc\n        elif count>1 and type(points[0]) is not list:\n            point_count = count/2\n            rc = System.Array.CreateInstance(Rhino.Geometry.Point2d,point_count)\n            for i in range(point_count):\n                rc[i] = Rhino.Geometry.Point2d(points[i*2], points[i*2+1])\n            return rc\n        elif count>0 and type(points[0]) is list:\n            point_count = count\n            rc = System.Array.CreateInstance(Rhino.Geometry.Point2d,point_count)\n            for i in range(point_count):\n                pt = points[i]\n                rc[i] = Rhino.Geometry.Point2d(pt[0],pt[1])\n            return rc\n        return None\n    return None\n\n\ndef coerceplane(plane, raise_on_bad_input=False):\n    \"Convert input into a Rhino.Geometry.Plane if possible.\"\n    if type(plane) is Rhino.Geometry.Plane: return plane\n    if type(plane) is list or type(plane) is tuple:\n        length = len(plane)\n        if length==3 and type(plane[0]) is not list:\n            rc = Rhino.Geometry.Plane.WorldXY\n            rc.Origin = Rhino.Geometry.Point3d(plane[0],plane[1],plane[2])\n            return rc\n        if length==9 and type(plane[0]) is not list:\n            origin = Rhino.Geometry.Point3d(plane[0],plane[1],plane[2])\n            xpoint = Rhino.Geometry.Point3d(plane[3],plane[4],plane[5])\n            ypoint = Rhino.Geometry.Point3d(plane[6],plane[7],plane[8])\n            rc     = Rhino.Geometry.Plane(origin, xpoint, ypoint)\n            return rc\n        if length==3 and (type(plane[0]) is list or type(plane[0]) is tuple):\n            origin = Rhino.Geometry.Point3d(plane[0][0],plane[0][1],plane[0][2])\n            xpoint = Rhino.Geometry.Point3d(plane[1][0],plane[1][1],plane[1][2])\n            ypoint = Rhino.Geometry.Point3d(plane[2][0],plane[2][1],plane[2][2])\n            rc     = Rhino.Geometry.Plane(origin, xpoint, ypoint)\n            return rc\n    if raise_on_bad_input: raise TypeError(\"%s can not be converted to a Plane\"%plane)\n\n\ndef coercexform(xform, raise_on_bad_input=False):\n    \"Convert input into a Rhino.Transform if possible.\"\n    t = type(xform)\n    if t is Rhino.Geometry.Transform: return xform\n    if( (t is list or t is tuple) and len(xform)==4 and len(xform[0])==4):\n        xf = Rhino.Geometry.Transform()\n        for i in range(4):\n            for j in range(4):\n                xf[i,j] = xform[i][j]\n        return xf\n    if raise_on_bad_input: raise TypeError(\"%s can not be converted to a Transform\"%xform)\n\n\ndef coerceguid(id, raise_exception=False):\n    if type(id) is System.Guid: return id\n    if type(id) is str and len(id)>30:\n        try:\n            id = System.Guid(id)\n            return id\n        except:\n            pass\n    if (type(id) is list or type(id) is tuple) and len(id)==1:\n        return coerceguid(id[0], raise_exception)\n    if raise_exception: raise TypeError(\"Parameter must be a Guid or string representing a Guid\")\n\n\ndef coerceguidlist(ids):\n    if ids is None: return None\n    rc = []\n    if( type(ids) is list or type(ids) is tuple ): pass\n    else: ids = [ids]\n    for id in ids:\n        id = coerceguid(id)\n        if id: rc.append(id)\n    if len(rc)==0: return None\n    return rc\n\n\ndef coerceboundingbox(bbox, raise_on_bad_input=False):\n    if type(bbox) is Rhino.Geometry.BoundingBox: return bbox\n    points = coerce3dpointlist(bbox)\n    if points: return Rhino.Geometry.BoundingBox(points)\n    if raise_on_bad_input: raise TypeError(\"%s can not be converted to a BoundingBox\"%bbox)\n\n\ndef coercecolor(c, raise_if_bad_input=False):\n    if type(c) is System.Drawing.Color: return c\n    if type(c) is list or type(c) is tuple:\n        if len(c)==3: return System.Drawing.Color.FromArgb(c[0], c[1], c[2])\n        elif len(c)==4: return System.Drawing.Color.FromArgb(c[0], c[1], c[2], c[3])\n    if type(c)==type(1): return System.Drawing.Color.FromArgb(c)\n    if raise_if_bad_input: raise TypeError(\"%s can not be converted to a Color\"%c)\n\n\ndef coerceline(line, raise_if_bad_input=False):\n    if type(line) is Rhino.Geometry.Line: return line\n    points = coerce3dpointlist(line, raise_if_bad_input)\n    if points and len(points)>1: return Rhino.Geometry.Line(points[0], points[1])\n    if raise_if_bad_input: raise TypeError(\"%s can not be converted to a Line\"%line)\n\n\ndef coercebrep(id, raise_if_missing=False):\n    \"attempt to get polysurface geometry from the document with a given id\"\n    if isinstance(id, Rhino.Geometry.Brep): return id\n    if type(id) is Rhino.DocObjects.ObjRef: return id.Brep()\n    id = coerceguid(id, True)\n    brepObj = scriptcontext.doc.Objects.Find(id)\n    if brepObj:\n        brep = brepObj.Geometry\n        if isinstance(brep, Rhino.Geometry.Brep): return brep\n        if isinstance(brep, Rhino.Geometry.Extrusion): return brep.ToBrep(True)\n    if raise_if_missing: raise ValueError(\"unable to convert %s into Brep geometry\"%id)\n\n\ndef coercegeometry(id, raise_if_missing=False):\n    \"attempt to get GeometryBase class from given input\"\n    if isinstance(id, Rhino.Geometry.GeometryBase): return id\n    if type(id) is Rhino.DocObjects.ObjRef: return id.Geometry()\n    if isinstance(id, Rhino.DocObjects.RhinoObject): return id.Geometry\n    id = coerceguid(id, True)\n    rhobj = scriptcontext.doc.Objects.Find(id)\n    if rhobj: return rhobj.Geometry\n    if raise_if_missing: raise ValueError(\"unable to convert %s into geometry\"%id)\n\n\ndef coercecurve(id, segment_index=-1, raise_if_missing=False):\n    \"attempt to get curve geometry from the document with a given id\"\n    if isinstance(id, Rhino.Geometry.Curve): return id\n    if type(id) is Rhino.DocObjects.ObjRef: return id.Curve()\n    id = coerceguid(id, True)\n    crvObj = scriptcontext.doc.Objects.Find(id)\n    if crvObj:\n        curve = crvObj.Geometry\n        if curve and segment_index>=0 and type(curve) is Rhino.Geometry.PolyCurve:\n            curve = curve.SegmentCurve(segment_index)\n        if isinstance(curve, Rhino.Geometry.Curve): return curve\n    if raise_if_missing: raise ValueError(\"unable to convert %s into Curve geometry\"%id)\n\n\ndef coercesurface(object_id, raise_if_missing=False):\n    \"attempt to get surface geometry from the document with a given id\"\n    if isinstance(object_id, Rhino.Geometry.Surface): return object_id\n    if type(object_id) is Rhino.DocObjects.ObjRef: return object_id.Face()\n    object_id = coerceguid(object_id, True)\n    srfObj = scriptcontext.doc.Objects.Find(object_id)\n    if srfObj:\n        srf = srfObj.Geometry\n        if isinstance(srf, Rhino.Geometry.Surface): return srf\n        #single face breps are considered surfaces in the context of scripts\n        if isinstance(srf, Rhino.Geometry.Brep) and srf.Faces.Count==1:\n            return srf.Faces[0]\n    if raise_if_missing: raise ValueError(\"unable to convert %s into Surface geometry\"%object_id)\n\n\ndef coercemesh(object_id, raise_if_missing=False):\n    \"attempt to get mesh geometry from the document with a given id\"\n    if type(object_id) is Rhino.DocObjects.ObjRef: return object_id.Mesh()\n    if isinstance(object_id, Rhino.Geometry.Mesh): return object_id\n    object_id = coerceguid(object_id, True)\n    meshObj = scriptcontext.doc.Objects.Find(object_id)\n    if meshObj:\n        mesh = meshObj.Geometry\n        if isinstance(mesh, Rhino.Geometry.Mesh): return mesh\n    if raise_if_missing: raise ValueError(\"unable to convert %s into Mesh geometry\"%object_id)\n\n\ndef coercerhinoobject(object_id, raise_if_bad_input=False, raise_if_missing=False):\n    \"attempt to get RhinoObject from the document with a given id\"\n    object_id = coerceguid(object_id, raise_if_bad_input)\n    if object_id is None: return None\n    rc = scriptcontext.doc.Objects.Find(object_id)\n    if not rc and raise_if_missing: raise ValueError(\"%s does not exist in ObjectTable\" % object_id)\n    return rc\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}