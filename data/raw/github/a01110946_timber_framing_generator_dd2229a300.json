{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_family_resolver.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_family_resolver.py",
  "instruction": "Family Resolver for Grasshopper.",
  "code": "# File: scripts/gh_family_resolver.py\n\"\"\"Family Resolver for Grasshopper.\n\nResolves Revit family references for framing elements before the bake step.\nThis component sits between the Framing Generator and Revit Baker in the\npipeline: it fetches a family manifest, downloads missing .rfa files,\nloads them into the Revit document, and enriches the framing JSON with\nrevit_family and revit_type fields.\n\nKey Features:\n1. Manifest-Driven Resolution\n   - Fetches family manifest from GitHub (or custom URL)\n   - Determines which families are needed from framing_json profiles\n   - Downloads missing .rfa files to local cache\n\n2. Local Cache with Offline Support\n   - Caches .rfa files in %APPDATA%/TimberFramingGenerator/families/\n   - SHA256 integrity verification\n   - Graceful offline fallback using cached families\n\n3. Revit Integration\n   - Loads .rfa families into the active Revit document\n   - Activates FamilySymbols for placement\n   - Reports already-loaded families to skip redundant work\n\n4. Enriched JSON Output\n   - Adds revit_family and revit_type fields to each framing element\n   - Pass-through compatible: downstream components receive richer data\n   - Missing families listed separately for user action\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n\nDependencies:\n    - Grasshopper: Component framework and runtime messages\n    - RhinoCommon: CLR reference for .NET interop\n    - RhinoInside.Revit: Revit document access (conditional)\n    - timber_framing_generator.families.resolver: FamilyResolver orchestrator\n    - timber_framing_generator.families.providers: GitHubProvider for manifest\n    - timber_framing_generator.families.cache: FamilyCache for local storage\n\nPerformance Considerations:\n    - First run downloads families (network-dependent, ~5-30s)\n    - Subsequent runs serve from cache (<1s)\n    - Revit LoadFamily calls require transactions (~0.5s per family)\n    - For large projects, pre-cache families to avoid network delays\n\nUsage:\n    1. Connect 'framing_json' from Framing Generator component\n    2. Optionally set 'manifest_url' for custom manifest location\n    3. Optionally set 'cache_dir' for custom cache directory\n    4. Set 'run' to True to trigger resolution\n    5. Connect 'resolved_json' to Revit Baker component\n    6. Check 'missing' output for unresolved families\n\nInput Requirements:\n    Framing JSON (framing_json) - str:\n        JSON string from Framing Generator with all framing elements.\n        Must contain \"elements\" array with \"profile.name\" fields.\n        Required: Yes\n        Access: Item\n        Type hint: str (set via GH UI)\n\n    Manifest URL (manifest_url) - str:\n        Full URL to manifest.json file. If not provided, defaults to\n        the project's GitHub repository raw URL.\n        Required: No (defaults to GitHub URL)\n        Access: Item\n        Type hint: str (set via GH UI)\n\n    Cache Dir (cache_dir) - str:\n        Local directory path for caching .rfa files. If not provided,\n        defaults to %APPDATA%/TimberFramingGenerator/families/.\n        Required: No (defaults to %APPDATA%)\n        Access: Item\n        Type hint: str (set via GH UI)\n\n    Run (run) - bool:\n        Boolean toggle to trigger execution. When False, component\n        outputs empty defaults without processing.\n        Required: Yes\n        Access: Item\n        Type hint: bool (set via GH UI)\n\nOutputs:\n    Resolved JSON (resolved_json) - str:\n        Framing JSON enriched with revit_family and revit_type fields\n        on each element. Pass directly to Revit Baker.\n\n    Missing (missing) - list of str:\n        List of family keys that could not be resolved. Empty list\n        means all families are available.\n\n    Status (status) - str:\n        Resolution status: \"all_resolved\", \"partial\", \"failed\", or \"offline\".\n        - all_resolved: every needed family is available\n        - partial: some families resolved, some missing\n        - failed: no families could be resolved\n        - offline: network unavailable, using cached families only\n\n    Info (info) - list of str:\n        Diagnostic log with step-by-step resolution details.\n        Useful for debugging manifest, network, or Revit loading issues.\n\nTechnical Details:\n    - Uses FamilyResolver orchestrator for the full resolution pipeline\n    - GitHubProvider fetches manifest and .rfa files from GitHub raw URLs\n    - FamilyCache stores files with SHA256 integrity verification\n    - Revit API calls (LoadFamily, Activate) are isolated in revit_loader.py\n    - RhinoInside.Revit import is conditional (component works without Revit)\n\nError Handling:\n    - Invalid/missing framing_json: returns empty output with warning\n    - Network errors: falls back to offline/cache-only mode\n    - Revit unavailable: resolves and caches families without loading\n    - Invalid manifest: logs error, returns failed status\n    - All errors reported via dual logging (console + GH runtime messages)\n\nAuthor: Fernando Maytorena\nVersion: 1.0.0\n\"\"\"\n\nimport sys\nimport json\nimport traceback\n\n# =============================================================================\n# Force Module Reload (CPython 3 in Rhino 8)\n# =============================================================================\n# Clear cached modules to ensure fresh imports when script changes.\n# IMPORTANT: Must also clear 'src' package — other GH components may have\n# loaded it from a different PROJECT_PATH, and its __path__ would point there.\n_modules_to_clear = [k for k in sys.modules.keys()\n                     if 'timber_framing_generator' in k or k == 'src']\nfor _mod in _modules_to_clear:\n    del sys.modules[_mod]\nprint(f\"[RELOAD] Cleared {len(_modules_to_clear)} cached modules\")\n\n# =============================================================================\n# .NET / CLR\n# =============================================================================\n\nimport clr\n\nclr.AddReference('RhinoCommon')\nclr.AddReference('Grasshopper')\n\n# Conditional RhinoInside.Revit import\nREVIT_AVAILABLE = False\nREVIT_DOC = None\n\ntry:\n    clr.AddReference('RhinoInside.Revit')\n    from RhinoInside.Revit import Revit\n    REVIT_DOC = Revit.ActiveDBDocument\n    if REVIT_DOC is not None:\n        REVIT_AVAILABLE = True\nexcept Exception as _revit_err:\n    print(f\"[INFO] RhinoInside.Revit not available: {_revit_err}\")\n\n# =============================================================================\n# Rhino / Grasshopper\n# =============================================================================\n\nimport Grasshopper\n\n# =============================================================================\n# Project Setup\n# =============================================================================\n\nPROJECT_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator\"\nif PROJECT_PATH not in sys.path:\n    sys.path.insert(0, PROJECT_PATH)\n\nfrom src.timber_framing_generator.families.resolver import FamilyResolver, ResolutionResult\nfrom src.timber_framing_generator.families.providers import GitHubProvider\nfrom src.timber_framing_generator.families.cache import FamilyCache\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Family Resolver\"\nCOMPONENT_NICKNAME = \"FamRes\"\nCOMPONENT_MESSAGE = \"v1.0\"\nCOMPONENT_CATEGORY = \"TFG\"\nCOMPONENT_SUBCATEGORY = \"4-Resolve\"\n\nDEFAULT_MANIFEST_URL = (\n    \"https://raw.githubusercontent.com/a01110946/timber_framing_generator/main/families/manifest.json\"\n)\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message: str, level: str = \"info\") -> None:\n    \"\"\"Log to console and optionally add GH runtime message.\n\n    Args:\n        message: The message to log\n        level: One of \"info\", \"debug\", \"warning\", \"error\", \"remark\"\n    \"\"\"\n    print(f\"[{level.upper()}] {message}\")\n\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n    elif level == \"remark\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Remark, message)\n\n\ndef log_debug(message: str) -> None:\n    \"\"\"Log debug message (console only).\"\"\"\n    print(f\"[DEBUG] {message}\")\n\n\ndef log_info(message: str) -> None:\n    \"\"\"Log info message (console only).\"\"\"\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message: str) -> None:\n    \"\"\"Log warning message (console + GH UI).\"\"\"\n    log_message(message, \"warning\")\n\n\ndef log_error(message: str) -> None:\n    \"\"\"Log error message (console + GH UI).\"\"\"\n    log_message(message, \"error\")\n\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component() -> None:\n    \"\"\"Initialize and configure the Grasshopper component.\n\n    Sets component metadata, input parameters, and output parameters.\n\n    Note: Output[0] is reserved for GH's internal 'out' - start from Output[1].\n\n    IMPORTANT: Type Hints cannot be set programmatically in Rhino 8.\n    They must be configured via UI: Right-click input -> Type hint -> Select type.\n    Required type hints:\n        framing_json: str\n        manifest_url: str\n        cache_dir: str\n        run: bool\n    \"\"\"\n    # Component metadata\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs\n    # IMPORTANT: NickName becomes the Python variable name\n    # Format: (DisplayName, variable_name, Description, Access)\n    inputs = ghenv.Component.Params.Input\n\n    input_config = [\n        (\"Framing JSON\", \"framing_json\", \"JSON string from Framing Generator\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Manifest URL\", \"manifest_url\", \"URL to manifest.json (optional, uses default GitHub URL)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Cache Dir\", \"cache_dir\", \"Local cache directory (optional, defaults to %APPDATA%)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Run\", \"run\", \"Boolean to trigger execution\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    # Configure outputs (start from index 1, as 0 is reserved for 'out')\n    outputs = ghenv.Component.Params.Output\n\n    output_config = [\n        (\"Resolved JSON\", \"resolved_json\", \"Framing JSON enriched with Revit family references\"),\n        (\"Missing\", \"missing\", \"List of families that could not be resolved\"),\n        (\"Status\", \"status\", \"Resolution status (all_resolved / partial / failed / offline)\"),\n        (\"Info\", \"info\", \"Diagnostic log\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1  # Skip Output[0]\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef _unwrap_gh_input(value):\n    \"\"\"Unwrap Grasshopper list wrapping from a single-item input.\n\n    Grasshopper sometimes wraps item-access inputs in a list.\n    This function extracts the first element if wrapped.\n\n    Args:\n        value: Input value that may be a list\n\n    Returns:\n        Unwrapped value, or None if empty\n    \"\"\"\n    if isinstance(value, (list, tuple)):\n        return value[0] if value else None\n    return value\n\n\ndef validate_inputs(framing_json_raw, run_raw):\n    \"\"\"Validate component inputs.\n\n    Args:\n        framing_json_raw: Raw framing_json input (may be list-wrapped)\n        run_raw: Raw run input (may be list-wrapped)\n\n    Returns:\n        tuple: (is_valid, framing_json_str, should_run, error_message)\n    \"\"\"\n    # Unwrap run toggle\n    should_run = _unwrap_gh_input(run_raw)\n    if should_run is None:\n        should_run = False\n    should_run = bool(should_run)\n\n    if not should_run:\n        return False, None, False, \"Set 'run' to True to execute\"\n\n    # Unwrap framing_json\n    framing_json_str = _unwrap_gh_input(framing_json_raw)\n\n    if framing_json_str is None or (isinstance(framing_json_str, str) and not framing_json_str.strip()):\n        return False, None, True, \"No framing_json input provided\"\n\n    # Basic JSON validation\n    try:\n        data = json.loads(framing_json_str)\n        if not isinstance(data, dict):\n            return False, None, True, \"framing_json must be a JSON object (dict)\"\n        elements = data.get(\"elements\", [])\n        if not elements:\n            return False, framing_json_str, True, None  # Valid but empty — still allow resolution\n    except json.JSONDecodeError as e:\n        return False, None, True, f\"Invalid JSON in framing_json: {e}\"\n\n    return True, framing_json_str, True, None\n\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main():\n    \"\"\"Main entry point for the Family Resolver component.\n\n    Coordinates the overall workflow:\n    1. Setup component metadata\n    2. Validate inputs\n    3. Create provider and cache from optional inputs\n    4. Run FamilyResolver.resolve() pipeline\n    5. Enrich framing_json with resolved family references\n    6. Return results\n\n    Returns:\n        tuple: (resolved_json, missing, status, info)\n    \"\"\"\n    # Default outputs\n    default_outputs = (\"\", [], \"pending\", [])\n\n    # Setup component\n    setup_component()\n\n    try:\n        # Validate inputs\n        is_valid, framing_json_str, should_run, error_msg = validate_inputs(\n            framing_json, run\n        )\n\n        if not should_run:\n            log_info(error_msg or \"Component disabled (run=False)\")\n            return (\"\", [], \"pending\", [error_msg or \"Set 'run' to True\"])\n\n        if not is_valid:\n            if error_msg:\n                log_warning(error_msg)\n                return (\"\", [], \"failed\", [error_msg])\n            return default_outputs\n\n        # Build diagnostic info list\n        info_lines = [\n            \"Family Resolver v1.0\",\n            \"=\" * 40,\n        ]\n\n        # -----------------------------------------------------------------\n        # Configure provider\n        # -----------------------------------------------------------------\n        manifest_url_str = _unwrap_gh_input(manifest_url) if 'manifest_url' in dir() else None\n        if not manifest_url_str or not isinstance(manifest_url_str, str) or not manifest_url_str.strip():\n            manifest_url_str = DEFAULT_MANIFEST_URL\n\n        info_lines.append(f\"Manifest URL: {manifest_url_str}\")\n\n        provider = GitHubProvider(manifest_url=manifest_url_str)\n\n        # -----------------------------------------------------------------\n        # Configure cache\n        # -----------------------------------------------------------------\n        cache_dir_str = _unwrap_gh_input(cache_dir) if 'cache_dir' in dir() else None\n        if cache_dir_str and isinstance(cache_dir_str, str) and cache_dir_str.strip():\n            cache = FamilyCache(cache_dir=cache_dir_str.strip())\n            info_lines.append(f\"Cache Dir: {cache_dir_str.strip()}\")\n        else:\n            cache = FamilyCache()\n            info_lines.append(f\"Cache Dir: {cache.cache_dir} (default)\")\n\n        # -----------------------------------------------------------------\n        # Revit document\n        # -----------------------------------------------------------------\n        doc = REVIT_DOC\n        if doc is not None:\n            info_lines.append(f\"Revit Document: {doc.Title}\")\n        else:\n            info_lines.append(\"Revit Document: NOT AVAILABLE (cache-only mode)\")\n            log_message(\"No Revit document — families will be cached but not loaded\", \"remark\")\n\n        # -----------------------------------------------------------------\n        # Count profiles needed from framing_json\n        # -----------------------------------------------------------------\n        try:\n            data = json.loads(framing_json_str)\n            elements = data.get(\"elements\", [])\n            profiles = set()\n            element_types = {}\n            for elem in elements:\n                profile = elem.get(\"profile\", {})\n                name = profile.get(\"name\", \"\")\n                if name:\n                    profiles.add(name)\n                elem_type = elem.get(\"element_type\", \"unknown\")\n                element_types[elem_type] = element_types.get(elem_type, 0) + 1\n\n            info_lines.append(f\"Total Elements: {len(elements)}\")\n            info_lines.append(f\"Unique Profiles: {sorted(profiles)}\")\n            info_lines.append(f\"Element Types: {dict(sorted(element_types.items()))}\")\n        except Exception as e:\n            info_lines.append(f\"Framing JSON parse note: {e}\")\n\n        info_lines.append(\"\")\n\n        # -----------------------------------------------------------------\n        # Run resolver\n        # -----------------------------------------------------------------\n        log_info(\"Starting family resolution...\")\n        resolver = FamilyResolver(provider=provider, cache=cache)\n        result = resolver.resolve(doc=doc, framing_json=framing_json_str)\n\n        # Append resolver's log to our info\n        info_lines.append(\"Resolution Log:\")\n        for line in result.log:\n            info_lines.append(f\"  {line}\")\n        info_lines.append(\"\")\n\n        # -----------------------------------------------------------------\n        # Enrich JSON\n        # -----------------------------------------------------------------\n        if result.status in (\"all_resolved\", \"partial\", \"offline\"):\n            enriched_json = resolver.enrich_framing_json(framing_json_str, result)\n            log_info(f\"Enriched framing JSON ({result.status})\")\n        else:\n            enriched_json = framing_json_str\n            log_warning(f\"Resolution {result.status} — returning original framing JSON\")\n\n        # -----------------------------------------------------------------\n        # Build summary\n        # -----------------------------------------------------------------\n        info_lines.append(\"Summary:\")\n        info_lines.append(f\"  Status: {result.status}\")\n        info_lines.append(f\"  Resolved: {len(result.resolved)}\")\n        info_lines.append(f\"  Already Loaded: {len(result.already_loaded)}\")\n        info_lines.append(f\"  Newly Loaded: {len(result.loaded)}\")\n        info_lines.append(f\"  Cached: {len(result.cached)}\")\n        info_lines.append(f\"  Missing: {len(result.missing)}\")\n\n        if result.missing:\n            info_lines.append(\"\")\n            info_lines.append(\"Missing Families:\")\n            for fam_key in result.missing:\n                info_lines.append(f\"  - {fam_key}\")\n\n        # Status message for GH UI\n        if result.status == \"all_resolved\":\n            log_message(\n                f\"All {len(result.resolved)} families resolved\", \"remark\"\n            )\n        elif result.status == \"partial\":\n            log_warning(\n                f\"Partial resolution: {len(result.resolved)} resolved, \"\n                f\"{len(result.missing)} missing\"\n            )\n        elif result.status == \"offline\":\n            log_warning(\n                f\"Offline mode: {len(result.cached)} families from cache\"\n            )\n        elif result.status == \"failed\":\n            log_error(\n                f\"Resolution failed — {len(result.missing)} families missing\"\n            )\n\n        return (enriched_json, result.missing, result.status, info_lines)\n\n    except Exception as e:\n        error_msg = f\"Unexpected error: {str(e)}\"\n        log_error(error_msg)\n        log_debug(traceback.format_exc())\n        return (\"\", [], \"failed\", [error_msg, traceback.format_exc()])\n\n\n# =============================================================================\n# Default Input Handling\n# =============================================================================\n# Set defaults for optional inputs that may not be wired in Grasshopper.\n# This ensures variables exist in global scope before main() references them.\n\ntry:\n    framing_json\nexcept NameError:\n    framing_json = None\n\ntry:\n    manifest_url\nexcept NameError:\n    manifest_url = None\n\ntry:\n    cache_dir\nexcept NameError:\n    cache_dir = None\n\ntry:\n    run\nexcept NameError:\n    run = False\n\n# =============================================================================\n# Execution\n# =============================================================================\n\nif __name__ == \"__main__\":\n    # Debug: show what globals GH actually injected\n    print(\"[DEBUG] run=%r, framing_json type=%s\" % (run, type(framing_json).__name__))\n    try:\n        resolved_json, missing, status, info = main()\n    except Exception as _main_err:\n        import traceback\n        print(\"[FATAL] main() crashed: %s\" % _main_err)\n        print(traceback.format_exc())\n        resolved_json, missing, status, info = \"\", [], \"failed\", [str(_main_err)]\n    # Print info to console so it's always visible regardless of output binding\n    if info:\n        if isinstance(info, list):\n            print(\"\\n\".join(str(x) for x in info))\n        else:\n            print(info)\n",
  "language": "python",
  "imports": [
    "RhinoCommon"
  ],
  "has_docstring": true
}