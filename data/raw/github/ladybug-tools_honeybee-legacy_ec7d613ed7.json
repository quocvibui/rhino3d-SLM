{
  "source_url": "https://github.com/ladybug-tools/honeybee-legacy/blob/bd62af4862fe022801fb87dbc8794fdf1dff73a9/src/Honeybee_Masses2Zones.py",
  "repo": "ladybug-tools/honeybee-legacy",
  "repo_stars": 129,
  "repo_description": ":bee: Honeybee is a free and open source plugin to connect Grasshopper3D to EnergyPlus, Radiance, Daysim and OpenStudio for building energy and daylighting simulation",
  "license": "NOASSERTION",
  "filepath": "src/Honeybee_Masses2Zones.py",
  "instruction": "Use this component to take any list of closed breps and turn them into Honeybee Zones with all of the properties needed to run them through an energy simulation.\n_\nThis includes constructions of the...",
  "code": "#\n# Honeybee: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n#\n# This file is part of Honeybee.\n#\n# Copyright (c) 2013-2020, Mostapha Sadeghipour Roudsari <mostapha@ladybug.tools>\n# Honeybee is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published\n# by the Free Software Foundation; either version 3 of the License,\n# or (at your option) any later version.\n#\n# Honeybee is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Honeybee; If not, see <http://www.gnu.org/licenses/>.\n#\n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to take any list of closed breps and turn them into Honeybee Zones with all of the properties needed to run them through an energy simulation.\n_\nThis includes constructions of the surfaces, boundary condtions of all of the surfaces (ie ground, exterior, etc), schedules+ loads for occupancy/internal electronics, and settings for an HVAC system if isContitioned_ is set to True.\n-\nProvided by Honeybee 0.0.66\n\n    Args:\n        _zoneMasses: A list of closed breps or a  single closed brep that represents the geometry of the zone(s) that will be output from this component.\n        zoneNames_: A list of names for the zones that will be output from this component. Default names will be applied to zones based on their order in the list if this value is left empty.\n        zonePrograms_: A list of zone programs from the Honeybee_ListZonePrograms component that matches the number of breps in the _zoneMasses list.  These zone programs will be applied to the zones that are output from this component and will be used to set the shcedules and loads of these programs. This input can also be a single zoneProgram to be applied to all of the coneected zones.  If no value is connected here, the zone program Office::OpenOffice will be applied to the zones.\n        isConditioned_: A list of True/False values that matches the number of breps in the _zoneMasses list. These True/False values will be applied to the ouput zones to either condition them with an Ideal Air Loads System (True) or not condition them at all (False).  This input can also be a single True/False value that can be applied to all of the connected zones.  If no value is connected here, all zones will be conditioned with an Ideal Air Loads System by default.\n        maximumRoofAngle_: A maximum angle from the z vector in degrees that will be used to decide whether a given surface in the connected _zoneMasses is assigned as a roof or a wall. The default is 30 degrees but you may want to increase this if you have a roof that is at a steeper slope (ie. 45 degrees).\n        _createHBZones: Set to True to generate the zones and assign energy simulation properties to your connected _zoneMasses.\n    Returns:\n        readMe!: ...\n        HBZones: Honeybee zones that have all of the properties necessary for an energy simulation assigned to them.  Connect these to a \"Honeybee_Label Zones\" component to see some of these properties.\n\"\"\"\n\nimport rhinoscriptsyntax as rs\nimport Rhino as rc\nimport scriptcontext as sc\nimport os\nimport sys\nimport System\nimport Grasshopper.Kernel as gh\nimport uuid\nimport copy\n\nghenv.Component.Name = 'Honeybee_Masses2Zones'\nghenv.Component.NickName = 'Mass2Zone'\nghenv.Component.Message = 'VER 0.0.66\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"HB-Legacy\"\nghenv.Component.SubCategory = \"00 | Honeybee\"\n#compatibleHBVersion = VER 0.0.56\\nNOV_04_2016\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"3\"\nexcept: pass\n\n\ntolerance = sc.doc.ModelAbsoluteTolerance\nimport math\n\n################################################################################\n\ndef main(maximumRoofAngle, zoneMasses, zoneNames, zonePrograms, isConditioned):\n\n    # check for Honeybee\n    if not sc.sticky.has_key('honeybee_release'):\n        msg = \"You should first let Honeybee fly...\"\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, msg)\n        return -1\n\n    try:\n        if not sc.sticky['honeybee_release'].isCompatible(ghenv.Component): return -1\n        if sc.sticky['honeybee_release'].isInputMissing(ghenv.Component): return -1\n    except:\n        warning = \"You need a newer version of Honeybee to use this compoent.\" + \\\n        \"Use updateHoneybee component to update userObjects.\\n\" + \\\n        \"If you have already updated userObjects drag Honeybee_Honeybee component \" + \\\n        \"into canvas and try again.\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n        return -1\n\n    # import the classes\n    # don't customize this part\n    hb_EPZone = sc.sticky[\"honeybee_EPZone\"]\n    hb_EPSrf = sc.sticky[\"honeybee_EPSurface\"]\n    hb_EPZoneSurface = sc.sticky[\"honeybee_EPZoneSurface\"]\n\n    #Have a function to duplicate data.\n    def duplicateData(data, calcLength):\n        dupData = []\n        for count in range(calcLength):\n            dupData.append(data[0])\n        return dupData\n\n    zoneNumber = len(zoneMasses)\n    zoneMasses = copy.deepcopy(zoneMasses) # Duplicate the breps so that we don't have same memory access\n\n    #If the length of the zonePrograms_ is 1, duplicate it to apply it to all zones.  Give a warning if the length of the list does not match the number of zones.\n    if len(zonePrograms) == 1:\n        zonePrograms = duplicateData(zonePrograms, zoneNumber)\n        print \"Zone program \" + str(zonePrograms[0]) + \" has been applied to all \" + str(zoneNumber) + \" connected zones.\"\n    elif len(zonePrograms) == 0:\n        print \"No value connected for zoneProgram_.  Office::OpenOffice has been assigned by default.\"\n    elif len(zonePrograms) != zoneNumber:\n        warning = \"The number of items in the connected zonePrograms_ list does not match the number of connected _zoneMasses. Office::OpenOffice will be assigned by default to zones that have no program in the list.\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n    else:\n        print \"Zones will be assigned a zone program based on the list of connected zonePrograms_.\"\n\n    #If the length of the isConditioned_ is 1, duplicate it to apply it to all zones.  Give a warning if the length of the list does not match the number of zones.\n    if len(isConditioned) == 1:\n        isConditioned = duplicateData(isConditioned, zoneNumber)\n        print \"An IsConditioned value of \" + str(isConditioned[0]) + \" has been applied to all \" + str(zoneNumber) + \" connected zones.\"\n    elif len(isConditioned) == 0:\n        print \"No value is connected for isConditioned_.  All zones will be conditioned by default.\"\n    elif len(isConditioned) != zoneNumber:\n        warning = \"The number of items in the connected isConditioned_ list does not match the number of connected _zoneMasses. Zones will be conditioned by default to if there is not isConditioned_ value for them in the list.\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n    else:\n        print \"Zones will be assigned an isConditioned value based on the list of connected isConditioned_ list.\"\n\n    #Give a warning if the length of the zoneNames_ list does not match the number of zones.\n    if len(zoneNames) == 0:\n        print \"No value connected for zoneNames_.  All zones will be assigned a default name based on their order in the list.\"\n    elif len(zoneNames) == 1:\n        newZoneNames = []\n        for count, mass in enumerate(zoneMasses):\n            newZoneNames.append(zoneNames[0] + \"_\" + str(count))\n        zoneNames = newZoneNames\n    elif len(zoneNames) != zoneNumber:\n        warning = \"The number of items in the connected zoneNames_ list does not match the number of connected _zoneMasses. Zones without a name in the list will be be assigned a default name based on their order in the list.\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n    else:\n        print \"Zones will be assigned a zoneName based on the list of connected zoneName_ list.\"\n\n    HBZones = []\n    # create zones out of masses\n    for zoneKey, zone in enumerate(zoneMasses):\n        # zone name\n        try: zoneName = zoneNames[zoneKey].strip().replace(\" \",\"_\").replace(\":\",\"-\")\n        except:\n            zoneName = \"zone_\" + str(sc.sticky[\"hBZoneCount\"])\n            sc.sticky[\"hBZoneCount\"] += 1\n\n        # zone programs\n        try: thisZoneProgram = zonePrograms[zoneKey].split(\"::\")\n        except: thisZoneProgram = 'Office', 'OpenOffice'\n\n        try: isZoneConditioned = isConditioned[zoneKey]\n        except: isZoneConditioned = True\n\n        thisZone = hb_EPZone(zone, zoneKey, zoneName, thisZoneProgram, isZoneConditioned)\n\n        # assign surface types and construction based on type\n        thisZone.decomposeZone(maximumRoofAngle)\n\n        # append this zone to other zones\n        HBZones.append(thisZone)\n\n    return HBZones\n\n        ################################################################################################\n\n\nif _createHBZones == True and len(_zoneMasses)!=0 and _zoneMasses[0]!=None:\n\n    try:  maximumRoofAngle = float(maxRoofAngle_)\n    except: maximumRoofAngle = 30\n\n    result= main(maximumRoofAngle, _zoneMasses, zoneNames_, zonePrograms_,isConditioned_)\n\n    if result!=-1:\n        zoneClasses = result\n        hb_hive = sc.sticky[\"honeybee_Hive\"]()\n        HBZones  = hb_hive.addToHoneybeeHive(zoneClasses, ghenv.Component)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}