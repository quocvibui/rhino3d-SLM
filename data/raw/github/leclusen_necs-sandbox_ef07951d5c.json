{
  "source_url": "https://github.com/leclusen/necs-sandbox/blob/8d8006ae3c845c9f3e38154803caac6b03d298a9/structure-batiment/structure_aligner/transform/support_placer.py",
  "repo": "leclusen/necs-sandbox",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "structure-batiment/structure_aligner/transform/support_placer.py",
  "instruction": "Support point placement at structural grid intersections.",
  "code": "\"\"\"Support point placement at structural grid intersections.\n\nPhase 5.3 - Places Appuis (Point and LineCurve) at axis line\nintersections where column elements exist.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom collections import defaultdict\n\nimport rhino3dm\n\nfrom structure_aligner.config import AxisLine\n\nlogger = logging.getLogger(__name__)\n\n# Default support floor levels (from research)\nSUPPORT_Z_LEVELS = (2.12, -4.44)\n\n\ndef place_support_points(\n    model: rhino3dm.File3dm,\n    axis_lines_x: list[AxisLine],\n    axis_lines_y: list[AxisLine],\n    support_z_levels: tuple[float, ...] = SUPPORT_Z_LEVELS,\n    existing_columns: dict[tuple[float, float], bool] | None = None,\n    column_tolerance: float = 0.5,\n    layer_index: int = 0,\n    start_id: int | None = None,\n) -> tuple[int, list[tuple[float, float, float]]]:\n    \"\"\"Place Appuis at grid intersections where columns exist.\n\n    Args:\n        model: The rhino3dm model to add objects to.\n        axis_lines_x: Sorted X axis lines.\n        axis_lines_y: Sorted Y axis lines.\n        support_z_levels: Floor Z-levels where supports are placed.\n        existing_columns: Optional dict mapping (x, y) -> bool for column\n            positions. If None, places supports at ALL intersections.\n        column_tolerance: Tolerance for matching column positions.\n        layer_index: Layer index for new objects.\n        start_id: Starting ID for Appuis naming. If None, auto-detect.\n\n    Returns:\n        Tuple of (count_added, positions_list) where positions_list\n        contains (x, y, z) for each support placed.\n    \"\"\"\n    if start_id is None:\n        start_id = _get_max_appui_id(model) + 1\n\n    if existing_columns is None:\n        logger.warning(\n            \"No column filter provided â€” supports placed at ALL %d grid \"\n            \"intersections. Provide existing_columns to filter.\",\n            len(axis_lines_x) * len(axis_lines_y) * len(support_z_levels),\n        )\n\n    # Build spatial index for O(1) column lookup\n    bucket_size = max(column_tolerance, 0.01)\n    column_index: set[tuple[int, int]] | None = None\n    if existing_columns is not None:\n        column_index = _build_column_index(existing_columns, column_tolerance)\n\n    next_id = start_id\n    added = 0\n    positions: list[tuple[float, float, float]] = []\n\n    for z in support_z_levels:\n        for ax in axis_lines_x:\n            for ay in axis_lines_y:\n                x, y = ax.position, ay.position\n\n                # Filter by column positions if provided\n                if column_index is not None:\n                    if not _has_nearby_column_indexed(\n                        x, y, column_index, bucket_size\n                    ):\n                        continue\n\n                name = f\"Appuis_{next_id}\"\n                next_id += 1\n\n                attr = rhino3dm.ObjectAttributes()\n                attr.Name = name\n                attr.LayerIndex = layer_index\n\n                model.Objects.AddPoint(\n                    rhino3dm.Point3d(x, y, z), attr\n                )\n                positions.append((x, y, z))\n                added += 1\n\n    logger.info(\n        \"Support placement: %d Appuis added at %d Z-levels\",\n        added, len(support_z_levels),\n    )\n    return added, positions\n\n\ndef place_support_points_at_columns(\n    model: rhino3dm.File3dm,\n    column_positions: dict[tuple[float, float], bool],\n    axis_lines_x: list[AxisLine],\n    axis_lines_y: list[AxisLine],\n    support_z_levels: tuple[float, ...] = SUPPORT_Z_LEVELS,\n    snap_tolerance: float = 0.75,\n    layer_index: int = 0,\n    start_id: int | None = None,\n) -> tuple[int, list[tuple[float, float, float]]]:\n    \"\"\"Place supports at column positions snapped to nearest axis intersection.\n\n    Instead of scanning all grid intersections, this iterates column centers\n    and snaps each to the nearest (axis_x, axis_y) intersection within\n    snap_tolerance. This produces O(C) supports where C = number of columns.\n\n    Args:\n        model: The rhino3dm model.\n        column_positions: Dict of (x, y) -> True for column centers.\n        axis_lines_x: X axis lines.\n        axis_lines_y: Y axis lines.\n        support_z_levels: Z-levels for support placement.\n        snap_tolerance: Max distance to snap a column to an axis intersection.\n        layer_index: Layer index for new objects.\n        start_id: Starting Appuis ID.\n\n    Returns:\n        Tuple of (count_added, positions_list).\n    \"\"\"\n    if start_id is None:\n        start_id = _get_max_appui_id(model) + 1\n\n    # Sort axis positions for binary search\n    import bisect\n    x_positions = sorted(al.position for al in axis_lines_x)\n    y_positions = sorted(al.position for al in axis_lines_y)\n\n    next_id = start_id\n    added = 0\n    positions: list[tuple[float, float, float]] = []\n    seen: set[tuple[float, float]] = set()\n\n    for (cx, cy) in column_positions:\n        # Find nearest X axis line\n        snap_x = _find_nearest_sorted(cx, x_positions, snap_tolerance)\n        snap_y = _find_nearest_sorted(cy, y_positions, snap_tolerance)\n        if snap_x is None or snap_y is None:\n            continue\n\n        key = (round(snap_x, 4), round(snap_y, 4))\n        if key in seen:\n            continue\n        seen.add(key)\n\n        for z in support_z_levels:\n            name = f\"Appuis_{next_id}\"\n            next_id += 1\n            attr = rhino3dm.ObjectAttributes()\n            attr.Name = name\n            attr.LayerIndex = layer_index\n            model.Objects.AddPoint(rhino3dm.Point3d(snap_x, snap_y, z), attr)\n            positions.append((snap_x, snap_y, z))\n            added += 1\n\n    logger.info(\n        \"Support placement (column-based): %d Appuis at %d unique positions, %d Z-levels\",\n        added, len(seen), len(support_z_levels),\n    )\n    return added, positions\n\n\ndef _find_nearest_sorted(\n    value: float, sorted_positions: list[float], tolerance: float,\n) -> float | None:\n    \"\"\"Find nearest position in sorted list within tolerance using binary search.\"\"\"\n    import bisect\n    idx = bisect.bisect_left(sorted_positions, value)\n    best = None\n    best_dist = tolerance + 1\n    for i in (idx - 1, idx):\n        if 0 <= i < len(sorted_positions):\n            d = abs(sorted_positions[i] - value)\n            if d < best_dist:\n                best_dist = d\n                best = sorted_positions[i]\n    return best if best_dist <= tolerance else None\n\n\ndef place_line_supports(\n    model: rhino3dm.File3dm,\n    axis_lines_x: list[AxisLine],\n    edge_y_positions: list[float],\n    z_level: float = -4.44,\n    line_length: float = 1.0,\n    layer_index: int = 0,\n    start_id: int | None = None,\n) -> int:\n    \"\"\"Place LineCurve supports along building edges.\n\n    Args:\n        model: The rhino3dm model to add objects to.\n        axis_lines_x: X axis lines for positioning.\n        edge_y_positions: Y positions at building edges.\n        z_level: Z position for line supports.\n        line_length: Length of each line support.\n        layer_index: Layer index for new objects.\n        start_id: Starting ID for naming.\n\n    Returns:\n        Number of line supports added.\n    \"\"\"\n    if start_id is None:\n        start_id = _get_max_appui_id(model) + 1\n\n    next_id = start_id\n    added = 0\n\n    for ax in axis_lines_x:\n        for y in edge_y_positions:\n            p1 = rhino3dm.Point3d(ax.position, y, z_level)\n            p2 = rhino3dm.Point3d(ax.position, y + line_length, z_level)\n            line = rhino3dm.LineCurve(p1, p2)\n\n            name = f\"Appuis_{next_id}\"\n            next_id += 1\n\n            attr = rhino3dm.ObjectAttributes()\n            attr.Name = name\n            attr.LayerIndex = layer_index\n            model.Objects.AddCurve(line, attr)\n            added += 1\n\n    logger.info(\"Line support placement: %d LineCurve supports added\", added)\n    return added\n\n\ndef _build_column_index(\n    existing_columns: dict[tuple[float, float], bool],\n    tolerance: float,\n) -> set[tuple[int, int]]:\n    \"\"\"Build spatial index with rounded keys for O(1) column lookup.\"\"\"\n    index: set[tuple[int, int]] = set()\n    bucket_size = max(tolerance, 0.01)\n    for (cx, cy) in existing_columns:\n        # Add to all neighboring buckets for tolerance matching\n        bx = int(cx / bucket_size)\n        by = int(cy / bucket_size)\n        for dx in (-1, 0, 1):\n            for dy in (-1, 0, 1):\n                index.add((bx + dx, by + dy))\n    return index\n\n\ndef _has_nearby_column_indexed(\n    x: float,\n    y: float,\n    column_index: set[tuple[int, int]],\n    bucket_size: float,\n) -> bool:\n    \"\"\"O(1) column proximity check using spatial index.\"\"\"\n    bx = int(x / bucket_size)\n    by = int(y / bucket_size)\n    return (bx, by) in column_index\n\n\ndef _get_max_appui_id(model: rhino3dm.File3dm) -> int:\n    \"\"\"Find the highest Appuis_NNNN id in the model.\"\"\"\n    max_id = 0\n    for obj in model.Objects:\n        name = obj.Attributes.Name\n        if name and name.startswith(\"Appuis_\"):\n            try:\n                num = int(name.split(\"_\")[1])\n                if num > max_id:\n                    max_id = num\n            except (ValueError, IndexError):\n                pass\n    return max_id\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}