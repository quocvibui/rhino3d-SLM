{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_wall_corner_adjuster.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_wall_corner_adjuster.py",
  "instruction": "Wall Corner Adjuster for Grasshopper (Rhino.Inside.Revit).",
  "code": "# File: scripts/gh_wall_corner_adjuster.py\n\"\"\"Wall Corner Adjuster for Grasshopper (Rhino.Inside.Revit).\n\nModifies Revit wall geometry at corners to convert from centerline joins to\nface-to-face dimensions for accurate panel manufacturing. This component\napplies the corner adjustments calculated by the Panel Decomposer to the\nactual Revit wall elements.\n\nKey Features:\n1. Wall Corner Unjoining\n   - Disallows wall joins at specified ends using WallUtils\n   - Prevents Revit from automatically re-joining walls\n\n2. Wall Location Curve Modification\n   - Extends or shortens wall location curves\n   - Maintains wall properties while adjusting geometry\n\n3. Transaction Management\n   - All modifications wrapped in Revit transaction\n   - Supports dry-run mode for preview without changes\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Rhino.Inside.Revit\n    Python component (CPython 3)\n\nDependencies:\n    - Autodesk.Revit.DB: Wall manipulation, transactions\n    - RhinoInside.Revit: Revit document access\n    - timber_framing_generator.panels: Corner adjustment data\n\nPerformance Considerations:\n    - Transaction overhead ~50ms per wall\n    - Batch processing recommended for many walls\n    - Undo available via Revit's undo stack\n\nUsage:\n    1. Connect 'panels_json' from Panel Decomposer (contains corner_adjustments)\n    2. Or connect 'adjustments_json' directly with adjustment data\n    3. Set 'dry_run' to True to preview without changes\n    4. Set 'run' to True to execute\n\nInput Requirements:\n    panels_json (panels_json) - str:\n        JSON string from Panel Decomposer containing corner_adjustments\n        Required: Yes (or adjustments_json)\n        Access: Item\n\n    adjustments_json (adj_json) - str:\n        Direct corner adjustments JSON (alternative to panels_json)\n        Required: No\n        Access: Item\n\n    dry_run (dry_run) - bool:\n        Preview mode - calculates but doesn't modify Revit\n        Required: No (defaults to True for safety)\n        Access: Item\n\n    run (run) - bool:\n        Boolean to trigger execution\n        Required: Yes\n        Access: Item\n\nOutputs:\n    modified_walls (modified) - list:\n        List of modified wall element IDs\n\n    preview_lines (preview) - DataTree[Line]:\n        Preview lines showing original and adjusted wall extents\n\n    debug_info (debug_info) - str:\n        Debug information and status messages\n\nTechnical Details:\n    - Uses WallUtils.DisallowWallJoinAtEnd to prevent auto-rejoining\n    - Modifies Wall.Location.Curve to extend/shorten walls\n    - All changes in single transaction for undo support\n\nError Handling:\n    - Invalid wall IDs logged and skipped\n    - Failed modifications don't halt other walls\n    - Dry run mode prevents accidental changes\n\nAuthor: Timber Framing Generator\nVersion: 1.0.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\n# Rhino / Grasshopper\nimport Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\n# =============================================================================\n# Revit API Setup (Rhino.Inside.Revit)\n# =============================================================================\n\ntry:\n    clr.AddReference(\"RevitAPI\")\n    clr.AddReference(\"RevitAPIUI\")\n    clr.AddReference(\"RhinoInside.Revit\")\n\n    from Autodesk.Revit.DB import (\n        Transaction,\n        Wall,\n        WallUtils,\n        Line as RevitLine,\n        XYZ,\n        ElementId,\n        BuiltInParameter,\n    )\n    from RhinoInside.Revit import Revit\n\n    REVIT_AVAILABLE = True\nexcept ImportError as e:\n    REVIT_AVAILABLE = False\n    REVIT_IMPORT_ERROR = str(e)\n\n# =============================================================================\n# Force Module Reload (CPython 3 in Rhino 8)\n# =============================================================================\n\n_modules_to_clear = [k for k in sys.modules.keys() if 'timber_framing_generator' in k]\nfor mod in _modules_to_clear:\n    del sys.modules[mod]\n\n# =============================================================================\n# Project Setup\n# =============================================================================\n\nPROJECT_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator\"\nif PROJECT_PATH not in sys.path:\n    sys.path.insert(0, PROJECT_PATH)\n\nfrom src.timber_framing_generator.utils.geometry_factory import get_factory\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Wall Corner Adjuster\"\nCOMPONENT_NICKNAME = \"CornerAdj\"\nCOMPONENT_MESSAGE = \"v1.0\"\nCOMPONENT_CATEGORY = \"Timber Framing\"\nCOMPONENT_SUBCATEGORY = \"Panels\"\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message, level=\"info\"):\n    \"\"\"Log to console and optionally add GH runtime message.\"\"\"\n    print(f\"[{level.upper()}] {message}\")\n\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n    elif level == \"remark\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Remark, message)\n\n\ndef log_debug(message):\n    print(f\"[DEBUG] {message}\")\n\n\ndef log_info(message):\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message):\n    log_message(message, \"warning\")\n\n\ndef log_error(message):\n    log_message(message, \"error\")\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\"\"\"\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    inputs = ghenv.Component.Params.Input\n    input_config = [\n        (\"Panels JSON\", \"panels_json\", \"JSON from Panel Decomposer with corner_adjustments\", Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Adjustments JSON\", \"adj_json\", \"Direct adjustments JSON (alternative)\", Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Dry Run\", \"dry_run\", \"Preview mode - no Revit changes (default True)\", Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Run\", \"run\", \"Boolean to trigger execution\", Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    outputs = ghenv.Component.Params.Output\n    output_config = [\n        (\"Modified Walls\", \"modified\", \"List of modified wall element IDs\"),\n        (\"Preview Lines\", \"preview\", \"Original and adjusted wall extent lines\"),\n        (\"Debug Info\", \"debug_info\", \"Debug information and status\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef validate_inputs(panels_json, adj_json, run):\n    \"\"\"Validate component inputs.\"\"\"\n    if not run:\n        return False, \"Component not running. Set 'run' to True.\"\n\n    if not panels_json and not adj_json:\n        return False, \"No panels_json or adj_json input provided\"\n\n    if not REVIT_AVAILABLE:\n        return False, f\"Revit API not available: {REVIT_IMPORT_ERROR}\"\n\n    return True, None\n\n\ndef extract_adjustments(panels_json, adj_json):\n    \"\"\"Extract corner adjustments from inputs.\n\n    Args:\n        panels_json: JSON from Panel Decomposer\n        adj_json: Direct adjustments JSON\n\n    Returns:\n        List of adjustment dictionaries\n    \"\"\"\n    all_adjustments = []\n\n    # From panels_json (Panel Decomposer output)\n    if panels_json:\n        data = json.loads(panels_json)\n        panels_list = data if isinstance(data, list) else [data]\n\n        for panel_result in panels_list:\n            adjustments = panel_result.get(\"corner_adjustments\", [])\n            all_adjustments.extend(adjustments)\n\n    # From direct adjustments\n    if adj_json:\n        adj_data = json.loads(adj_json)\n        adj_list = adj_data if isinstance(adj_data, list) else [adj_data]\n        all_adjustments.extend(adj_list)\n\n    return all_adjustments\n\n\ndef get_wall_by_id(doc, wall_id):\n    \"\"\"Get Revit wall element by ID string.\n\n    Args:\n        doc: Revit document\n        wall_id: Wall ID as string (may include prefix like \"wall_\")\n\n    Returns:\n        Wall element or None\n    \"\"\"\n    try:\n        # Extract numeric ID if prefixed\n        if isinstance(wall_id, str):\n            # Handle formats like \"wall_12345\" or just \"12345\"\n            numeric_part = ''.join(filter(str.isdigit, wall_id))\n            if numeric_part:\n                element_id = ElementId(int(numeric_part))\n            else:\n                log_warning(f\"Could not parse wall ID: {wall_id}\")\n                return None\n        else:\n            element_id = ElementId(int(wall_id))\n\n        element = doc.GetElement(element_id)\n        if isinstance(element, Wall):\n            return element\n        else:\n            log_warning(f\"Element {wall_id} is not a Wall\")\n            return None\n\n    except Exception as e:\n        log_warning(f\"Error getting wall {wall_id}: {e}\")\n        return None\n\n\ndef adjust_wall_at_corner(doc, wall, corner_type, adjustment_type, amount, dry_run):\n    \"\"\"Adjust a wall's location curve at one end.\n\n    Args:\n        doc: Revit document\n        wall: Wall element\n        corner_type: \"start\" or \"end\"\n        adjustment_type: \"extend\" or \"recede\"\n        amount: Adjustment amount in feet\n        dry_run: If True, don't modify\n\n    Returns:\n        tuple: (success, original_line, new_line)\n    \"\"\"\n    try:\n        location = wall.Location\n        if not hasattr(location, 'Curve'):\n            log_warning(f\"Wall {wall.Id.IntegerValue} has no location curve\")\n            return False, None, None\n\n        curve = location.Curve\n        if not isinstance(curve, RevitLine):\n            log_warning(f\"Wall {wall.Id.IntegerValue} curve is not a line\")\n            return False, None, None\n\n        # Get current endpoints\n        start_pt = curve.GetEndPoint(0)\n        end_pt = curve.GetEndPoint(1)\n\n        # Calculate direction\n        direction = (end_pt - start_pt).Normalize()\n\n        # Calculate new endpoints\n        new_start = start_pt\n        new_end = end_pt\n\n        if corner_type == \"start\":\n            if adjustment_type == \"extend\":\n                # Extend start backwards (opposite direction)\n                new_start = start_pt - direction * amount\n            else:  # recede\n                # Recede start forwards\n                new_start = start_pt + direction * amount\n        else:  # \"end\"\n            if adjustment_type == \"extend\":\n                # Extend end forwards\n                new_end = end_pt + direction * amount\n            else:  # recede\n                # Recede end backwards\n                new_end = end_pt - direction * amount\n\n        # Create preview lines\n        factory = get_factory()\n        original_line = factory.create_line(\n            (start_pt.X, start_pt.Y, start_pt.Z),\n            (end_pt.X, end_pt.Y, end_pt.Z)\n        )\n        new_line = factory.create_line(\n            (new_start.X, new_start.Y, new_start.Z),\n            (new_end.X, new_end.Y, new_end.Z)\n        )\n\n        if dry_run:\n            log_info(f\"  [DRY RUN] Would {adjustment_type} wall at {corner_type} by {amount:.3f}ft\")\n            return True, original_line, new_line\n\n        # Actually modify the wall\n        # First, disallow wall join at this end\n        end_index = 0 if corner_type == \"start\" else 1\n        WallUtils.DisallowWallJoinAtEnd(wall, end_index)\n\n        # Create new line and set it\n        new_curve = RevitLine.CreateBound(new_start, new_end)\n        location.Curve = new_curve\n\n        log_info(f\"  Modified wall at {corner_type}: {adjustment_type} by {amount:.3f}ft\")\n        return True, original_line, new_line\n\n    except Exception as e:\n        log_error(f\"Error adjusting wall: {e}\")\n        return False, None, None\n\n\ndef process_adjustments(doc, adjustments, dry_run):\n    \"\"\"Process all corner adjustments.\n\n    Args:\n        doc: Revit document\n        adjustments: List of adjustment dictionaries\n        dry_run: If True, preview only\n\n    Returns:\n        tuple: (modified_ids, preview_lines, info_lines)\n    \"\"\"\n    modified_ids = []\n    preview_lines = DataTree[object]()\n    info_lines = []\n\n    # Group adjustments by wall\n    adjustments_by_wall = {}\n    for adj in adjustments:\n        wall_id = adj.get(\"wall_id\", \"\")\n        if wall_id not in adjustments_by_wall:\n            adjustments_by_wall[wall_id] = []\n        adjustments_by_wall[wall_id].append(adj)\n\n    log_info(f\"Processing {len(adjustments)} adjustments for {len(adjustments_by_wall)} walls\")\n    info_lines.append(f\"Processing {len(adjustments)} adjustments\")\n\n    wall_idx = 0\n    for wall_id, wall_adjs in adjustments_by_wall.items():\n        wall = get_wall_by_id(doc, wall_id)\n        if wall is None:\n            info_lines.append(f\"  Wall {wall_id}: NOT FOUND\")\n            continue\n\n        info_lines.append(f\"  Wall {wall_id} (Revit ID: {wall.Id.IntegerValue}):\")\n\n        for adj in wall_adjs:\n            corner_type = adj.get(\"corner_type\", \"end\")\n            adjustment_type = adj.get(\"adjustment_type\", \"extend\")\n            amount = adj.get(\"adjustment_amount\", 0)\n            connecting_wall = adj.get(\"connecting_wall_id\", \"?\")\n\n            info_lines.append(f\"    {corner_type}: {adjustment_type} by {amount:.3f}ft (connects to {connecting_wall})\")\n\n            success, orig_line, new_line = adjust_wall_at_corner(\n                doc, wall, corner_type, adjustment_type, amount, dry_run\n            )\n\n            if success:\n                if orig_line:\n                    preview_lines.Add(orig_line, GH_Path(wall_idx, 0))  # Original\n                if new_line:\n                    preview_lines.Add(new_line, GH_Path(wall_idx, 1))  # Adjusted\n\n        if not dry_run:\n            modified_ids.append(wall.Id.IntegerValue)\n\n        wall_idx += 1\n\n    return modified_ids, preview_lines, info_lines\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main():\n    \"\"\"Main entry point for the component.\"\"\"\n    setup_component()\n\n    # Initialize outputs\n    modified_walls = []\n    preview_lines = DataTree[object]()\n    debug_lines = []\n\n    try:\n        # Validate inputs\n        is_valid, error_msg = validate_inputs(panels_json, adj_json, run)\n        if not is_valid:\n            if error_msg and \"not running\" not in error_msg.lower():\n                log_warning(error_msg)\n            debug_lines.append(error_msg)\n            return modified_walls, preview_lines, \"\\n\".join(debug_lines)\n\n        # Get Revit document\n        doc = Revit.ActiveDBDocument\n        if doc is None:\n            log_error(\"No active Revit document\")\n            debug_lines.append(\"ERROR: No active Revit document\")\n            return modified_walls, preview_lines, \"\\n\".join(debug_lines)\n\n        # Extract adjustments\n        adjustments = extract_adjustments(panels_json, adj_json)\n        debug_lines.append(f\"Found {len(adjustments)} corner adjustments\")\n\n        if not adjustments:\n            debug_lines.append(\"No adjustments to apply\")\n            return modified_walls, preview_lines, \"\\n\".join(debug_lines)\n\n        # Check dry_run mode\n        is_dry_run = dry_run if dry_run is not None else True\n        debug_lines.append(f\"Mode: {'DRY RUN (preview only)' if is_dry_run else 'LIVE (modifying Revit)'}\")\n\n        if is_dry_run:\n            # Process without transaction\n            modified_walls, preview_lines, info_lines = process_adjustments(\n                doc, adjustments, dry_run=True\n            )\n            debug_lines.extend(info_lines)\n        else:\n            # Process within transaction\n            with Transaction(doc, \"Adjust Wall Corners for Panelization\") as t:\n                t.Start()\n                try:\n                    modified_walls, preview_lines, info_lines = process_adjustments(\n                        doc, adjustments, dry_run=False\n                    )\n                    debug_lines.extend(info_lines)\n                    t.Commit()\n                    debug_lines.append(f\"Transaction committed: {len(modified_walls)} walls modified\")\n                except Exception as e:\n                    t.RollBack()\n                    log_error(f\"Transaction rolled back: {e}\")\n                    debug_lines.append(f\"ERROR: Transaction rolled back - {e}\")\n\n    except Exception as e:\n        log_error(f\"Unexpected error: {str(e)}\")\n        debug_lines.append(f\"ERROR: {str(e)}\")\n        debug_lines.append(traceback.format_exc())\n\n    return modified_walls, preview_lines, \"\\n\".join(debug_lines)\n\n# =============================================================================\n# Execution\n# =============================================================================\n\n# Set default values for optional inputs\ntry:\n    panels_json\nexcept NameError:\n    panels_json = None\n\ntry:\n    adj_json\nexcept NameError:\n    adj_json = None\n\ntry:\n    dry_run\nexcept NameError:\n    dry_run = True  # Safe default\n\ntry:\n    run\nexcept NameError:\n    run = False\n\n# Execute main\nif __name__ == \"__main__\":\n    modified, preview, debug_info = main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}