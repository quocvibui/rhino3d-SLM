{
  "source_url": "https://discourse.mcneel.com/t/issues-regarding-the-surface-extension-code-in-c/208048",
  "topic_id": 208048,
  "title": "Issues regarding the surface extension code in C#",
  "question": "image\n1247×390 26.4 KB\n\nI used AI to write a code for surface extension, which is currently functional. However, it doesn’t work correctly for non-quadrilateral surfaces. What I need is to extend all three edges of a triangular surface as shown in the image, rather than untrimming the triangle into a quadrilateral.\n\nSo, how should the code be modified to correctly extend a triangular surface?\n\n\nexsurface.gh\n (6.2 KB)\n\n\nExtend Surface.cs\n (6.7 KB)",
  "code_blocks": [
    {
      "code": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Linq;\nusing Grasshopper.Kernel;\nusing Grasshopper.Kernel.Types;\nusing Rhino.Geometry;\nusing YatChun.Properties;\n\nnamespace Yatchun.Surface\n{\n    public class Yc_exsurface : GH_Component\n    {\n        public Yc_exsurface()\n          : base(\"Extend Surface\", \"ExtendSrf\",\n                \"Extend surface from edge (preserves trim state)\",\n                \"Yatchun\", \"Surface\")\n        {\n        }\n\n        public override Guid ComponentGuid => new Guid(\"A3B4C5D6-E7F8-495A-B2C3-D4E5F6A7B8C9\");\n        protected override Bitmap Icon => Resources.Yc_Extend_Srf;\n\n        protected override void RegisterInputParams(GH_InputParamManager pManager)\n        {\n            pManager.AddSurfaceParameter(\"Surface\", \"S\", \"Surface to extend\", GH_ParamAccess.item);\n            pManager.AddNumberParameter(\"West Edge\", \"W\", \"Length to extend west edge (0 for no extension)\", GH_ParamAccess.item, 0);\n            pManager.AddNumberParameter(\"South Edge\", \"S\", \"Length to extend south edge (0 for no extension)\", GH_ParamAccess.item, 0);\n            pManager.AddNumberParameter(\"East Edge\", \"E\", \"Length to extend east edge (0 for no extension)\", GH_ParamAccess.item, 0);\n            pManager.AddNumberParameter(\"North Edge\", \"N\", \"Length to extend north edge (0 for no extension)\", GH_ParamAccess.item, 0);\n            pManager.AddBooleanParameter(\"Extension Type\", \"T\", \"Set True for smooth extension, False for ruled\", GH_ParamAccess.item, true);\n        }\n\n        protected override void RegisterOutputParams(GH_OutputParamManager pManager)\n        {\n            pManager.AddSurfaceParameter(\"Surface\", \"S\", \"Extended surface\", GH_ParamAccess.item);\n        }\n\n        protected override void SolveInstance(IGH_DataAccess DA)\n        {\n            // 1. Get input surface\n            GH_Surface ghSrf = null;\n            if (!DA.GetData(0, ref ghSrf) || ghSrf == null)\n            {\n                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, \"Invalid surface input\");\n                return;\n            }\n\n            // 2. Get underlying Brep\n            var brep = ghSrf.Value as Brep;\n            if (brep == null)\n            {\n                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, \"Input is not a valid Brep\");\n                return;\n            }\n\n            // 3. Check if trimmed\n            bool isTrimmed = !brep.IsSurface;\n            if (isTrimmed)\n            {\n                AddRuntimeMessage(GH_RuntimeMessageLevel.Warning,\n                    \"Note: Extended surface will be untrimmed. Original trim boundaries will be lost.\");\n            }\n\n            var firstSurface = brep.Surfaces.First();\n            Rhino.Geometry.Surface srf = firstSurface as Rhino.Geometry.Surface;\n            if (srf == null)\n            {\n                AddRuntimeMessage(GH_RuntimeMessageLevel.Error,\n                    \"Input surface is not a valid NURBS surface\");\n                return;\n            }\n\n            // 4. Check if triangle surface\n            bool isTriangle = false;\n            if (srf is NurbsSurface nurbsSrf)\n            {\n                isTriangle = (nurbsSrf.Points.CountU == 3 || nurbsSrf.Points.CountV == 3);\n                if (isTriangle)\n                {\n                    AddRuntimeMessage(GH_RuntimeMessageLevel.Remark,\n                        \"Input is a triangle surface - only south edge can be extended\");\n                }\n            }\n\n            // 5. Duplicate surface (safe way)\n            var duplicated = srf.Duplicate() as Rhino.Geometry.Surface;\n            if (duplicated == null)\n            {\n                AddRuntimeMessage(GH_RuntimeMessageLevel.Error,\n                    \"Surface duplication failed\");\n                return;\n            }\n            srf = duplicated;\n\n            // 6. Get extension parameters\n            double wEdge = 0, sEdge = 0, eEdge = 0, nEdge = 0;\n            bool smooth = true;\n\n            if (!DA.GetData(1, ref wEdge)) wEdge = 0;\n            if (!DA.GetData(2, ref sEdge)) sEdge = 0;\n            if (!DA.GetData(3, ref eEdge)) eEdge = 0;\n            if (!DA.GetData(4, ref nEdge)) nEdge = 0;\n            if (!DA.GetData(5, ref smooth)) smooth = true;\n\n            // 7. For triangle surfaces, only allow south edge extension\n            if (isTriangle)\n            {\n                if (wEdge > 0 || eEdge > 0 || nEdge > 0)\n                {\n                    AddRuntimeMessage(GH_RuntimeMessageLevel.Warning,\n                        \"Triangle surfaces can only be extended from the south edge. Other edges ignored.\");\n                    wEdge = eEdge = nEdge = 0;\n                }\n            }\n\n            // 8. Perform extension\n            try\n            {\n                if (wEdge > 0) srf = srf.Extend(IsoStatus.West, wEdge, smooth);\n                if (sEdge > 0) srf = srf.Extend(IsoStatus.South, sEdge, smooth);\n                if (eEdge > 0) srf = srf.Extend(IsoStatus.East, eEdge, smooth);\n                if (nEdge > 0) srf = srf.Extend(IsoStatus.North, nEdge, smooth);\n\n                // 9. Output extended surface\n                DA.SetData(0, new GH_Surface(srf));\n            }\n            catch (Exception ex)\n            {\n                AddRuntimeMessage(GH_RuntimeMessageLevel.Error,\n                    $\"Extension failed: {ex.Message}\");\n            }\n        }\n\n        // Helper method to determine edge type (from ext.txt)\n        private IsoStatus DetermineEdgeType(Rhino.Geometry.Surface surface, Rhino.Geometry.Curve curve)\n        {\n            // Set surface domains to 0-1 for consistent evaluation\n            surface.SetDomain(0, new Interval(0, 1));\n            surface.SetDomain(1, new Interval(0, 1));\n\n            // Get start and end points of the curve\n            Point3d startPt = curve.PointAtStart;\n            Point3d endPt = curve.PointAtEnd;\n\n            // Find closest points on surface\n            double u1, v1, u2, v2;\n            surface.ClosestPoint(startPt, out u1, out v1);\n            surface.ClosestPoint(endPt, out u2, out v2);\n\n            // Determine if edge is along U or V direction\n            const double tolerance = 0.0001;\n            bool isUEdge = Math.Abs(v1 - v2) < tolerance;\n            bool isVEdge = Math.Abs(u1 - u2) < tolerance;\n\n            if (isUEdge)\n            {\n                if (v1 < tolerance) return IsoStatus.South;\n                if (v1 > 1.0 - tolerance) return IsoStatus.North;\n            }\n            else if (isVEdge)\n            {\n                if (u1 < tolerance) return IsoStatus.West;\n                if (u1 > 1.0 - tolerance) return IsoStatus.East;\n            }\n\n            return IsoStatus.None;\n        }\n    }\n}",
      "language": "csharp",
      "author": "Yatchun",
      "post_number": 7,
      "is_solution": false
    }
  ],
  "tags": [
    "boolean",
    "csharp",
    "geometry",
    "grasshopper",
    "nurbs",
    "rhinocommon"
  ],
  "has_accepted_answer": false,
  "category_id": 11,
  "posts_count": 8,
  "views": 159
}