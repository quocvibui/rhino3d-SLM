{
  "source_url": "https://github.com/augmentedfabricationlab/ifmm_lib/blob/1cc6e87f5b07e0d6bd144f8f24462cc0d0a70fdb/clients/arduino/communication_old/arduinoclient.py",
  "repo": "augmentedfabricationlab/ifmm_lib",
  "repo_stars": 0,
  "repo_description": "In situ Fabricatr & Mesh Mould @ EMPA Nest 2017",
  "license": "unknown",
  "filepath": "clients/arduino/communication_old/arduinoclient.py",
  "instruction": ". . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<      ><  <<      ><  <<  <<><><>   .\n.   < ><   ><<  < ><   ><<  <<  <<        .\n.   << >< > ><  << ><...",
  "code": "'''\n. . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<      ><  <<      ><  <<  <<><><>   .\n.   < ><   ><<  < ><   ><<  <<  <<        .\n.   << >< > ><  << >< > ><  <<  <<><><>   .  \n.   <<  ><  ><  <<  ><  ><  <<  <<        .\n.   <<      ><  <<      ><  <<  <<        .\n.   <<      ><  <<      ><  <<  <<        .\n.                                         .\n.             GKR 2016/17                 .\n. . . . . . . . . . . . . . . . . . . . . .\n\nCreated on 19.11.2016\n\n@author: kathrind\n'''\n\nfrom threading import *\n\nimport socket\nimport struct\nimport time\nimport math\n\nfrom clientstates import client_states_str_array, READY, BUSY\nfrom messagetypes import msg_types_str_array, MSG_CMD_BEND, MSG_CMD_INSERT_VERTICAL, MSG_CMD_RETRACT, \\\n                         MSG_CMD_RECEIVED, MSG_CMD_EXECUTED, MSG_DIGITAL_OUT, MSG_INFO, MSG_STRING, \\\n                         MSG_FLOAT_LIST, MSG_CMD_INSERT_AND_BEND, MSG_CMD_ROTATE_MOTOR_ABS, MSG_CMD_ROTATE_MOTOR_REL, \\\n                         MSG_CMD_INSERT_VERTICAL_BEF_TILT, MSG_CMD_BEND_AFTER_TILT\n\n\n#import Rhino.Geometry as rg\n\nclass ArduinoClient(object):\n    def __init__(self, host = \"127.0.0.1\", port=30001):\n        self.host = host\n        self.port = port\n        self.byteorder = \"<\" # \"!\" network, \">\" big-endian, \"<\" for little-endian, see http://docs.python.org/2/library/struct.html\n        self.connected = False\n        \n        self.lock_counter = Lock()\n        self.lock_state = Lock()\n        \n        self.msg_counter = 0\n        self.msg_len_rcv = \"\"\n        self.msg_rcv = \"\"\n        \n        self.info_msg = \"\"\n        \n        self.kill_wait_thread_flag = False\n        \n        self.set_state(READY)\n        \n        self.connection_success = False\n        \n        self.current_angle_val = 0\n    #===========================================================================\n    def connect(self):\n        if self.connected == False:\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            self.sock.settimeout(1)\n            self.sock.connect((self.host, self.port))\n            print \"Connected to server %s on port %d\" % (self.host, self.port)\n            self.connected = True   \n    #===========================================================================    \n    def close(self):\n        self.sock.close()\n        self.connected = False\n    #===========================================================================\n    def set_msg_counter(self): \n        self.lock_counter.acquire()\n        self.msg_counter += 1\n        self.lock_counter.release()\n    #===========================================================================\n    def get_msg_counter(self):\n        self.lock_counter.acquire()\n        c = self.msg_counter\n        self.lock_counter.release()\n        return c\n    # =================================================================================\n    def set_state(self, state):\n        self.lock_state.acquire()\n        self.state = state\n        self.lock_state.release()\n    # =================================================================================\n    def get_state(self, state):\n        self.lock_state.acquire()\n        state = self.state\n        self.lock_state.release()\n        return state\n    \n    #===========================================================================\n    def __send(self, msg_type, msg = None, wait_for_response = True):\n        \"\"\" send message according to message type \"\"\"\n        \n        buf = None\n\n        if msg_type == MSG_INFO:\n            \"[msg_type, msg_counter]\"\n            msg_snd_len = 4 + 4 #+4bytes = wait_for_respons\n            params = [msg_snd_len, msg_type, self.get_msg_counter(), wait_for_response]\n            buf = struct.pack(self.byteorder + \"4i\", *params)\n        elif msg_type == MSG_DIGITAL_OUT:\n            \"[msg_type, msg_counter, int_do_num, int_do_state]\"\n            msg_snd_len = 4 + 8 + 4 #+4bytes = wait_for_respons\n            params = [msg_snd_len, msg_type, self.get_msg_counter(), wait_for_response] + msg\n            buf = struct.pack(self.byteorder + \"4i\" + \"2i\", *params)\n        elif msg_type == MSG_CMD_INSERT_AND_BEND or msg_type == MSG_CMD_ROTATE_MOTOR_ABS or msg_type == MSG_CMD_ROTATE_MOTOR_REL:\n            \"[msg_type, msg_counter, int_val1, int_val2]\"\n            msg_snd_len = 4 + 8 + 4 #+4bytes = wait_for_respons\n            params = [msg_snd_len, msg_type, self.get_msg_counter(), wait_for_response] + msg\n            buf = struct.pack(self.byteorder + \"4i\" + \"2i\", *params)\n        elif msg_type == MSG_STRING:\n            \"[msg_type, msg_counter, string]\"\n            msg_snd_len = len(msg) + 4 + 4 # + 4bytes = msg_counter +4bytes = wait_for_response            \n            params = [msg_snd_len, msg_type, self.get_msg_counter(), wait_for_response] + [msg]\n            buf = struct.pack(self.byteorder + \"4i\" + str(len(msg)) +  \"s\", *params)\n        elif msg_type == MSG_CMD_BEND or msg_type == MSG_CMD_INSERT_VERTICAL or msg_type == MSG_CMD_RETRACT or msg_type == MSG_FLOAT_LIST or msg_type == MSG_CMD_INSERT_VERTICAL_BEF_TILT  or msg_type == MSG_CMD_BEND_AFTER_TILT:\n            \"[msg_type, msg_counter, float_values]\"\n            msg_snd_len = struct.calcsize(str(len(msg)) + \"f\") + 4 + 4 # + 4bytes = msg_counter   +4bytes = wait_for_respons\n            params = [msg_snd_len, msg_type, self.get_msg_counter(), wait_for_response] + msg\n            # print \"params\", params            \n            buf = struct.pack(self.byteorder + \"4i\" + str(len(msg)) + \"f\", *params)     \n        else:\n            print \"Message identifier unknown:  %s = %d, message: %s\" % (msg_types_str_array[msg_type], msg_type, msg)\n            return   \n           \n        if buf != None:\n            self.sock.send(buf)\n            print \"Sent message: %s to server \" % (msg_types_str_array[msg_type])\n\n    #===========================================================================\n    def __read(self):\n        \"\"\" The transmission protocol for messages is:\n        4 byte [message length] (= 1 * Unsigned 4 byte integer) # The message length is the length of the message without the message length and message type.\n        4 byte [message type] (= 1 * Unsigned 4 byte integer)\n        x byte [message] (according to type)\n        \"\"\"\n        \n        \"1. read msg length\"\n        while len(self.msg_len_rcv) < 4:   \n            self.msg_len_rcv += self.sock.recv(1)\n         \n        msg_length = struct.unpack_from(self.byteorder + \"I\", self.msg_len_rcv, 0)[0]\n        #print \"MESSAGE LENGTH:\", msg_length\n        \n        \"2. read rest of msg according to msg_length\"\n        while len(self.msg_rcv) < (msg_length + 4):    \n            self.msg_rcv += self.sock.recv(1)\n\n        \"3. unpack message type\"\n        msg_type = struct.unpack_from(self.byteorder + \"I\", self.msg_rcv[:4], 0)[0]\n        #print \"MESSAGE TYPE:\", msg_type\n        \n        \"4. rest of the message will be passed on as raw message (if there is no message body, raw_message stays empty)\"\n        raw_msg = self.msg_rcv[4:]\n        \n        \"5. reset msg_rcv + msg_len_rcv\"\n        self.msg_rcv = \"\"\n        self.msg_len_rcv = \"\"\n        \n        \"6. pass message id and raw message to process method \"\n        msg_type, msg = self.__process(msg_type, raw_msg)\n        return msg_type, msg\n    \n    #===========================================================================\n    def __process(self, msg_type, raw_msg):\n        \"\"\" The transmission protocol for messages is \n        [length msg in bytes] [msg identifier] [other bytes which will be read out according to msg identifier] \"\"\"\n        \n        if msg_type == MSG_CMD_RECEIVED:\n            msg_counter = struct.unpack_from(self.byteorder + \"i\", raw_msg)[0]\n            return (msg_type, msg_counter)\n        elif msg_type == MSG_CMD_EXECUTED:\n            msg_counter = struct.unpack_from(self.byteorder + \"i\", raw_msg)[0]\n            return (msg_type, msg_counter)\n        elif msg_type == MSG_INFO:\n            msg_counter = struct.unpack_from(self.byteorder + \"i\", raw_msg[:4])[0]\n            msg_string = raw_msg[4:]\n            return (msg_type, (msg_counter,msg_string))\n        else:\n            print \"%s: Message identifier unknown: %d, message: %s\" % (self.parent.identifier, msg_type, raw_msg)\n            return (False, False)\n\n    def __get(self, msg_type, msg = None, wait_for_response = True):\n        self.set_msg_counter()\n        self.set_state(BUSY)\n        self.__send(msg_type, msg, wait_for_response)\n        \n        success = False\n        msg_received_by_arduino = False\n        if wait_for_response:\n            success = False\n            while not success:\n                \n                # try to get a callback ba arduino, if message was received or not...\n                if not msg_received_by_arduino:\n                    #time.sleep(0.1)\n                    try:\n                        msg_type, msg = self.__read()\n                        if msg_type == MSG_CMD_RECEIVED:\n                            msg_received_by_arduino = True\n                        else:\n                            return (msg_type, msg, success)\n                    except:\n                        return (msg_type, msg, success)\n                    \n                # after receiving the acknowledge message from the arduino, try receiving the cmd executed msg    \n                try:\n                    msg_type, msg = self.__read()\n                    success = True\n                except:\n                    print \"waiting for response\"\n                    time.sleep(0.01)\n                    \n                    if self.kill_wait_thread_flag == True: # ------> thread can be killed from outside event\n                        return (msg_type, msg, success)\n                    \n        else: # just try to receive the cmd_received_message\n            success = False\n            try:\n                msg_type, msg = self.__read()\n                if msg_type == MSG_CMD_RECEIVED:\n                    success = True\n                    return (msg_type, msg, success)\n                else:\n                    return (msg_type, msg, success)\n            except:\n                return (msg_type, msg, success)\n        \n        self.set_state(READY)\n        return (msg_type, msg, success)\n    \n    def send_get_arduino_info(self):\n        return self.__get(msg_type = MSG_INFO, msg = None, wait_for_response = True)\n    \n    \n    # ===============================================================================================================================\n    # motor angle calculations\n    # ===============================================================================================================================\n    def map_range(self, value,fromMin,fromMax,toMin,toMax):\n        fromSpan = fromMax - fromMin\n        toSpan = toMax - toMin\n        valueScaled = float(value-fromMin)/float(fromSpan)\n        return toMin + (valueScaled * toSpan)\n\n    def get_motor_pos_value_from_angle(self, angle_degrees):\n        '''returns the motor abs positions for an angle input\n        please check: maybe needs to include a shift, depending on the zero position.\n        '''\n        mapped_value = self.map_range(angle_degrees, -90, 90, -200, 200)\n        return mapped_value * 48./40. * -1.0\n    \n    def get_motor_steps_value_from_angle(self, angle_degrees):\n        mapped_value = self.map_range(angle_degrees, -360, 360, -800, 800)\n        return mapped_value\n    \n    # ===============================================================================================================================\n    # communcation with Arduino\n    # ===============================================================================================================================   \n    def send_set_do(self, do = 0, state = 0, wait_for_response = True):\n        \"\"\" command the arduino board to set a digital out to the given state. \"\"\"\n        return self.__get(msg_type = MSG_DIGITAL_OUT, msg = [do, state], wait_for_response = wait_for_response)\n    \n    def send_cmd_bend(self, angle, wait_for_response = True):\n        \"\"\" send a bending command message to arduino with one float value. \"\"\"\n        motor_pos = self.get_motor_pos_value_from_angle(angle)\n        return self.__get(msg_type = MSG_CMD_BEND, msg = [motor_pos], wait_for_response = wait_for_response)\n    \n    def send_cmd_rotate_motor_abs(self, angle, motor_type, wait_for_response = True):\n        \"\"\" send a rotating command message to arduino with two int values. int1 = motortype, int2 = angle value \"\"\"\n        motor_pos = self.get_motor_pos_value_from_angle(angle)\n        motor_type = 1 if motor_type == \"front\" else 2\n        return self.__get(msg_type = MSG_CMD_ROTATE_MOTOR_ABS, msg = [int(motor_pos), int(motor_type)], wait_for_response = wait_for_response)\n    \n    def send_cmd_rotate_motor_rel(self, angle, motor_type, wait_for_response = True):\n        \"\"\" send a rotating command message to arduino with two int values. int1 = motortype, int2 = angle value \"\"\"\n        motor_steps = self.get_motor_steps_value_from_angle(angle)\n        motor_type = 1 if motor_type == \"front\" else 2\n        return self.__get(msg_type = MSG_CMD_ROTATE_MOTOR_REL, msg = [int(motor_steps), int(motor_type)], wait_for_response = wait_for_response)\n    \n    def send_cmd_insert_vertical(self, f, wait_for_response = True):\n        \"\"\" send a welding command message to arduino with one float value. \n        float value idetnifies a short or a long vertical wire to be inserted. \"\"\"\n        return self.__get(msg_type = MSG_CMD_INSERT_VERTICAL, msg = [f], wait_for_response = wait_for_response)\n    \n    def send_cmd_insert_vertical_bef_tilt(self, f, wait_for_response = True):\n        \"\"\" send a welding command message to arduino with one float value. \n        float value idetnifies a short or a long vertical wire to be inserted. \"\"\"\n        return self.__get(msg_type = MSG_CMD_INSERT_VERTICAL_BEF_TILT, msg = [f], wait_for_response = wait_for_response)\n    \n    def send_cmd_bend_after_tilt(self, angle, wait_for_response = True):\n        \"\"\" send a welding command message to arduino with one float value. \n        float value idetnifies a short or a long vertical wire to be inserted. \"\"\"\n        motor_pos = self.get_motor_pos_value_from_angle(angle)\n        return self.__get(msg_type = MSG_CMD_BEND_AFTER_TILT, msg = [motor_pos], wait_for_response = wait_for_response)\n \n    \n    def send_cmd_retract(self, f, wait_for_response = True):\n        \"\"\" send a bending command message to arduino with one float value. \"\"\"\n        return self.__get(msg_type = MSG_CMD_RETRACT, msg = [f], wait_for_response = wait_for_response)\n    \n    def send_cmd_insert_and_bend(self, vertical_type = 0, angle = 0, wait_for_response = True):\n        \"\"\" command the arduino board to insert a vertical and bend afterwards \"\"\"\n        motor_pos = self.get_motor_pos_value_from_angle(angle)\n        return self.__get(msg_type = MSG_CMD_INSERT_AND_BEND, msg = [vertical_type, motor_pos], wait_for_response = wait_for_response)\n\n    def set_pneu_feeder(self, do_state):\n        relay_pneu_feeder = 8\n        msg_type, msg_counter, success = self.send_set_do(do = relay_pneu_feeder, state = do_state, wait_for_response = True)\n        return success\n        \n    def set_pneu_welder(self, do_state):\n        relay_pneu_welder = 9\n        msg_type, msg_counter, success = self.send_set_do(do = relay_pneu_welder, state = do_state, wait_for_response = True)\n        return success\n        \n    def set_pneu_cutter(self, do_state):\n        relay_pneu_cutter = 12\n        msg_type, msg_counter, success = self.send_set_do(do = relay_pneu_cutter, state = do_state, wait_for_response = True)\n        return success\n    \n    def set_trigger_weld(self):\n        relay_trigger_weld = 11\n        msg_type, msg_counter, success = self.send_set_do(do = relay_trigger_weld, state = 1, wait_for_response = True)\n        #time.sleep(0.1)\n        time.sleep(0.1)\n        msg_type, msg_counter, success = self.send_set_do(do = relay_trigger_weld, state = 0, wait_for_response = True)\n        return success\n    \n    # =========================================================================================\n    \n    \"\"\"\n    # =================================================================================\n    def wait_for_state_ready_old(self, delay = None):\n        time.sleep(0.05)\n        \n        timeout = 0\n        state = self.state\n        while state != READY and timeout < 12000:\n            state = self.state\n            #print \"state:\", state\n            time.sleep(0.05)\n            timeout += 1\n\n            if self.kill_wait_thread_flag == True:\n                return False\n        \n        if state == READY:\n            if delay:\n                time.sleep(delay)\n            return True\n        else:\n            return False\"\"\"\n            \n    # =================================================================================\n    def wait_for_state_ready(self, delay = None):\n        time.sleep(0.05)\n        \n        state = self.state\n        while state != READY:\n            state = self.state\n            #print \"state:\", state\n            time.sleep(0.05)\n\n            if self.kill_wait_thread_flag == True:\n                return False\n        \n        if state == READY:\n            if delay:\n                time.sleep(delay)\n            return True\n        else:\n            return False\n    \n         \n\nif __name__ == \"__main__\":\n    aclient = ArduinoClient(host = \"192.168.10.177\", port=30001)\n    time.sleep(0.5)\n    \n    aclient.connect()\n    time.sleep(0.5)\n    print \"Connection: \", aclient.connected\n    v1 = 0\n    v2 = 50\n    for i in range(1000):\n        \n        f = v1 if i%2==0 else v2\n        #msg_type, msg_counter, success = aclient.send_cmd_bending(f=f)\n        msg_type, msg, success = aclient.send_get_arduino_info()\n        print \"RECEIVED MSG FROM ARDUINO: \"\n        print \"MSG TYPE: \", msg_types_str_array[msg_type]\n        print \"MSG: \", msg\n        print \"SUCCESS\" if success==True else \"NO SUCCESS\"\n        \n        if not success:\n            aclient.close()\n            time.sleep(1)\n            aclient.connect()\n            \n        #print \"MSG COUNTER: \", msg_counter\n    \n        time.sleep(0.1)\n    aclient.close()\n    print \"Connection: \", aclient.connected\n    time.sleep(0.1)\n    \n    \"\"\"\n    for i in range(3):\n        \n        aclient.connect()\n        time.sleep(0.5)\n        print \"Connection: \", aclient.connected\n        \n        msg_type, msg_counter = aclient.send_cmd(f=500)\n        \n        print \"RECEIVED MSG FROM ARDUINO: \"\n        print \"MSG TYPE: \", msg_types_str_array[msg_type]\n        print \"MSG COUNTER: \", msg_counter\n        \n        for i in range(3):\n            time.sleep(0.5)\n            msg_type, msg = aclient.send_get_arduino_info()\n            print \"RECEIVED MSG FROM ARDUINO: \"\n            print \"MSG TYPE: \", msg_types_str_array[msg_type]\n            print \"MSG COUNTER: \", msg[0]\n            print \"MSG: \", msg[1]\n            \n            \n            msg_type, msg_counter = aclient.send_set_do(do = 13, state = 0)\n            print \"RECEIVED MSG FROM ARDUINO: \"\n            print \"MSG TYPE: \", msg_types_str_array[msg_type]\n            print \"MSG COUNTER: \", msg_counter\n            \n            msg_type, msg_counter = aclient.send_cmd(f=399.5)\n            print \"RECEIVED MSG FROM ARDUINO: \"\n            print \"MSG TYPE: \", msg_types_str_array[msg_type]\n            print \"MSG COUNTER: \", msg_counter\n            \n        time.sleep(0.1)\n        aclient.close()\n        print \"Connection: \", aclient.connected\n        time.sleep(0.1)\"\"\"",
  "language": "python",
  "imports": [
    "Rhino.Geometry"
  ],
  "has_docstring": true
}