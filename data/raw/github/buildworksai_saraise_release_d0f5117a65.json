{
  "source_url": "https://github.com/buildworksai/saraise.release/blob/762245fecae7ddbab3882adcda604993ce4c7a5b/backend/src/customization/services/hook_service.py",
  "repo": "buildworksai/saraise.release",
  "repo_stars": 1,
  "repo_description": "SARAISE is a modern, enterprise-grade ERP platform that combines intelligent automation with flexible customization. Built for the cloud era, SARAISE empowers businesses to streamline operations, boost productivity, and scale effortlesslyâ€”all while maintaining complete control over their data and processes.",
  "license": "NOASSERTION",
  "filepath": "backend/src/customization/services/hook_service.py",
  "instruction": "Hook service for event-driven script execution",
  "code": "# SPDX-License-Identifier: Apache-2.0\n\n\"\"\"Hook service for event-driven script execution\n\nPer Phase 0.2 Task 12: Implement HookService to trigger scripts on document events\nPer SARAISE-31002: Server Script Execution\n\"\"\"\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select\nfrom typing import Dict, Any, List, Optional\nfrom src.customization.models import ServerScript, ServerScriptLog\nfrom src.customization.services.script_execution_service import ScriptExecutionService\nfrom src.customization.script_context import ScriptContext\nfrom datetime import datetime\nimport asyncio\n\n\nclass HookService:\n    \"\"\"Trigger server scripts on document events per Phase 0.2 Task 12\"\"\"\n    \n    def __init__(self, db: AsyncSession):\n        self.db = db\n        self.script_executor = ScriptExecutionService()\n    \n    async def trigger_hooks(\n        self,\n        tenant_id: str,\n        doctype: str,\n        hook_name: str,\n        doc: Dict[str, Any],\n        user_id: Optional[str] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Trigger all hooks for a specific event per Phase 0.2 Task 12\n        \n        Args:\n            tenant_id: Tenant ID\n            doctype: DocType name (e.g., \"Invoice\")\n            hook_name: Event name (e.g., \"before_insert\")\n            doc: Document data (mutable - scripts can modify)\n            user_id: Current user ID\n            \n        Returns:\n            Modified document after all hooks execute\n        \"\"\"\n        # Load all enabled scripts for this doctype and hook\n        scripts = await self._get_scripts_for_hook(tenant_id, doctype, hook_name)\n        \n        if not scripts:\n            return doc\n        \n        # Create script context (after rollback to ensure clean state)\n        script_context = ScriptContext(self.db, tenant_id, user_id)\n        \n        # Execute scripts in priority order\n        modified_doc = doc.copy()\n        \n        for script in scripts:\n            try:\n                # Prepare context for script - create a safe wrapper that doesn't expose async session\n                # Create a minimal context object that only exposes safe methods\n                # Extract safe values from context to avoid any async access\n                from datetime import datetime\n                from src.customization.script_context import ScriptUtils\n                \n                class SafeScriptContext:\n                    \"\"\"Safe wrapper for ScriptContext that doesn't expose async operations\"\"\"\n                    def __init__(self, context: ScriptContext):\n                        # Store only safe values, not the full context object\n                        self._logs = []\n                        self._tenant_id = context.tenant_id\n                        self._user_id = context.user_id\n                        self._utils = ScriptUtils()  # Create new instance, don't reference original\n                    \n                    def log(self, message: str, level: str = \"info\"):\n                        \"\"\"Log a message\"\"\"\n                        self._logs.append({\n                            \"message\": message,\n                            \"level\": level,\n                            \"timestamp\": datetime.now().isoformat()\n                        })\n                    \n                    def throw(self, message: str):\n                        \"\"\"Throw an error\"\"\"\n                        raise ValueError(message)\n                    \n                    def new_doc(self, doctype: str):\n                        \"\"\"Create a new document template\"\"\"\n                        return {\n                            \"doctype\": doctype,\n                            \"tenant_id\": self._tenant_id,\n                            \"created_at\": datetime.now().isoformat(),\n                            \"created_by\": self._user_id,\n                        }\n                    \n                    @property\n                    def utils(self):\n                        \"\"\"Get utility functions\"\"\"\n                        return self._utils\n                    \n                    def __getattr__(self, name):\n                        \"\"\"Prevent access to any other attributes\"\"\"\n                        raise AttributeError(f\"'{self.__class__.__name__}' object has no attribute '{name}'\")\n                \n                safe_context = SafeScriptContext(script_context)\n                \n                # Prepare context for script\n                context_vars = {\n                    'doc': modified_doc,\n                    'context': safe_context,\n                    'user_id': user_id,\n                    'tenant_id': tenant_id,\n                    'doctype': doctype,\n                    'hook_name': hook_name,\n                }\n                \n                # Execute script\n                result = await self.script_executor.execute_script(\n                    script_code=script.script,\n                    context=context_vars,\n                    timeout=5\n                )\n                \n                # Log execution (non-blocking - failures won't abort transaction)\n                try:\n                    await self._log_script_execution(\n                        script_id=script.id,\n                        tenant_id=tenant_id,\n                        doctype=doctype,\n                        doc_id=modified_doc.get('id'),\n                        event=hook_name,\n                        user_id=user_id,\n                        success=result['success'],\n                        execution_time=result.get('execution_time'),\n                        result=result.get('result'),\n                        error_message=result.get('error'),\n                        traceback=result.get('traceback')\n                    )\n                except Exception:\n                    # Logging failure shouldn't stop the main operation\n                    pass\n                \n                # If script failed, raise error to rollback transaction\n                if not result['success']:\n                    raise ValueError(f\"Script {script.name} failed: {result.get('error')}\")\n                \n                # Update document with modifications from script\n                # Scripts modify 'doc' in place, so we use the modified version\n                modified_doc = context_vars.get('doc', modified_doc)\n                \n            except Exception as e:\n                # Log error (non-blocking)\n                try:\n                    await self._log_script_execution(\n                        script_id=script.id,\n                        tenant_id=tenant_id,\n                        doctype=doctype,\n                        doc_id=modified_doc.get('id'),\n                        event=hook_name,\n                        user_id=user_id,\n                        success=False,\n                        execution_time=None,\n                        result=None,\n                        error_message=str(e),\n                        traceback=None\n                    )\n                except Exception:\n                    # Logging failure shouldn't stop error propagation\n                    pass\n                # Re-raise to rollback transaction\n                raise\n        \n        return modified_doc\n    \n    async def _get_scripts_for_hook(\n        self,\n        tenant_id: str,\n        doctype: str,\n        hook_name: str\n    ) -> List[ServerScript]:\n        \"\"\"Get all enabled scripts for a specific hook\"\"\"\n        query = select(ServerScript).where(\n            ServerScript.tenant_id == tenant_id,\n            ServerScript.doctype == doctype,\n            ServerScript.event == hook_name,\n            ServerScript.enabled == True,\n            ServerScript.script_type == \"DocType\"\n        ).order_by(ServerScript.priority.asc(), ServerScript.created_at.asc())\n        \n        result = await self.db.execute(query)\n        return result.scalars().all()\n    \n    async def _log_script_execution(\n        self,\n        script_id: str,\n        tenant_id: str,\n        doctype: Optional[str],\n        doc_id: Optional[str],\n        event: Optional[str],\n        user_id: Optional[str],\n        success: bool,\n        execution_time: Optional[float],\n        result: Optional[Any],\n        error_message: Optional[str],\n        traceback: Optional[str]\n    ) -> None:\n        \"\"\"Log script execution to database\"\"\"\n        try:\n            log = ServerScriptLog(\n                tenant_id=tenant_id,\n                script_id=script_id,\n                doctype=doctype,\n                doc_id=doc_id,\n                event=event,\n                user_id=user_id,\n                success=success,\n                execution_time=execution_time,\n                result=result if isinstance(result, dict) else {\"value\": result},\n                error_message=error_message,\n                traceback=traceback\n            )\n            \n            self.db.add(log)\n            await self.db.commit()\n        except Exception as e:\n            # Logging failure shouldn't stop the main operation\n            # In production, you might want to log this to a separate error log\n            pass\n\n",
  "language": "python",
  "imports": [],
  "has_docstring": true
}