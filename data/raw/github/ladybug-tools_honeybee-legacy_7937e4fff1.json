{
  "source_url": "https://github.com/ladybug-tools/honeybee-legacy/blob/bd62af4862fe022801fb87dbc8794fdf1dff73a9/src/Honeybee_Adaptive%20Comfort%20Analysis%20Recipe.py",
  "repo": "ladybug-tools/honeybee-legacy",
  "repo_stars": 129,
  "repo_description": ":bee: Honeybee is a free and open source plugin to connect Grasshopper3D to EnergyPlus, Radiance, Daysim and OpenStudio for building energy and daylighting simulation",
  "license": "NOASSERTION",
  "filepath": "src/Honeybee_Adaptive Comfort Analysis Recipe.py",
  "instruction": "Use this component to assemble an adaptive comfort recipe for the \"Honeybee_Annual Indoor Comfort Analysis\" component.\n-\nProvided by Honeybee 0.0.66\n    \n    Args:\n        _viewFactorMesh: The data...",
  "code": "# This component assembles an analysis recipe for the annual adaptive comfort component\n#\n# Honeybee: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Honeybee.\n# \n# Copyright (c) 2013-2020, Chris Mackey <Chris@MackeyArchitecture.com> \n# Honeybee is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Honeybee is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Honeybee; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to assemble an adaptive comfort recipe for the \"Honeybee_Annual Indoor Comfort Analysis\" component.\n-\nProvided by Honeybee 0.0.66\n    \n    Args:\n        _viewFactorMesh: The data tree of view factor meshes that comes out of the  \"Honeybee_Indoor View Factor Calculator\".\n        _viewFactorInfo: The python list that comes out of the  \"Honeybee_Indoor View Factor Calculator\".\n        _epwFile: The epw file that was used to run the EnergyPlus model.  This will be used to generate sun vectors and get radiation data for estimating the temperature delta for sun falling on occupants.\n        ===============: ...\n        _srfIndoorTemp: A list surfaceIndoorTemp data out of the \"Honeybee_Read EP Surface Result\" component.\n        srfOutdoorTemp_: A list surfaceOutdoorTemp data out of the \"Honeybee_Read EP Surface Result\" component.\n        _zoneAirTemp: The airTemperature output of the \"Honeybee_Read EP Result\" component.\n        _zoneAirFlowVol: The airFlowVolume output of the \"Honeybee_Read EP Result\" component.\n        _zoneAirHeatGain: The airHeatGainRate output of the \"Honeybee_Read EP Result\" component.\n        ===============: ...\n        eightyPercentComf_: Set to \"True\" to have the comfort standard be 80 percent of occupants comfortable and set to \"False\" to have the comfort standard be 90 percent of all occupants comfortable.  The default is set to \"False\" for 90 percent, which is what most members of the building industry aim for.  However some projects will occasionally use 90%.\n        wellMixedAirOverride_: Set to \"True\" if you know that your building will have a forced air system with diffusers meant to mix the air as well as possilbe.  This will prevent the calculation from running the air stratification function and instead assume well mixed conditions.  This input can also be a list of 8760 boolean values that represent the hours of the year when a forced air system or ceiling fans are run to mix the air.  The default is set to 'False' to run the stratification calculation for every hour of the year, assuming no forced air heating/cooling system.\n        inletHeightOverride_: An optional list of float values that match the data tree of view factor meshes and represent the height, in meters, from the bottom of the view factor mesh to the window inlet height.  This will override the default value used in the air stratification calculation, which sets the inlet height in the bottom half of the average glazing height.\n        windowShadeTransmiss_: A decimal value between 0 and 1 that represents the transmissivity of the shades on the windows of a zone (1 is no shade and 0 is fully shaded).  This input can also be a list of 8760 values between 0 and 1 that represents a list of hourly window shade transmissivities to be applied to all windows of the model. Finally and most importantly, this can be the 'windowTransmissivity' output of the 'Read EP Surface Result' component for an energy model that has been run with window shades.  This final option ensures that the energy model and the confort map results are always aligned although it is the most computationally expensive of the options.  The default is set to 0, which assumes no additional shading to windows.\n        cloAbsorptivity_: An optional decimal value between 0 and 1 that represents the fraction of solar radiation absorbed by the human body. The default is set to 0.7 for (average/brown) skin and average clothing.  You may want to increase this value for darker skin or darker clothing.\n        windSpeed_: A value in m/s to set the wind speed of the comfort calculation. Use this input to account for objects like ceiling fans that might increase the interior wind speed or input custom wind speed values from a CFD simulation.\n            _\n            This input can also be a list of 8760 additional wind speed values that represent the hours of the year.\n            Alternatively, this input can be a data tree of values with branches that are each 8760 values long and correspond to the branches of the input viewFactorMesh_.\n            This can also be a data tree of values with one branch for each point in the input viewFactorMesh_.\n            Finally, this input can be the file path to a .csv file that is organized with 8760 values in each column and a number of columns that correspond to the number of test points.  This last option is recommended if trying to synchronize CFD results with the microclimate maps.\n            _\n            If no value is input here, the comfort map components will compute a minimum indoor air speed from the zone volume and hourly flow volume and will use the EPW wind speed for outdoor conditions.\n        outdoorTerrain_: An interger or text string that sets the terrain class associated with the wind speed used in outdoor wind calculations. Interger values represent the following terrain classes:\n            0 = City: large city centres, 50% of buildings above 21m over a distance of at least 2000m upwind.\n            1 = Suburban: suburbs, wooded areas.\n            2 = Country: open, with scattered objects generally less than 10m high.\n            3 = Water: Flat, unobstructed areas exposed to wind flowing over a large water body (no more than 500m inland).\n        north_: Input a vector to be used as a true North direction for the comfort analysis or a number between 0 and 360 that represents the degrees off from the y-axis to make North.  The default North direction is set to the Y-axis (0 degrees).\n    Returns:\n        readMe!: ...\n        comfRecipe: An analysis recipe for the \"Honeybee_Annual Indoor Comfort Analysis\" component.\n\"\"\"\n\nghenv.Component.Name = \"Honeybee_Adaptive Comfort Analysis Recipe\"\nghenv.Component.NickName = 'AdaptComfRecipe'\nghenv.Component.Message = 'VER 0.0.66\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"HB-Legacy\"\nghenv.Component.SubCategory = \"10 | Energy | Energy\"\n#compatibleHBVersion = VER 0.0.56\\nJUL_24_2017\n#compatibleLBVersion = VER 0.0.59\\nJUN_07_2016\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"6\"\nexcept: pass\n\n\nfrom System import Object\nfrom System import Drawing\nimport System\nimport Grasshopper.Kernel as gh\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\nimport Rhino as rc\nimport scriptcontext as sc\nimport math\nimport os\n\n\nw = gh.GH_RuntimeMessageLevel.Warning\ntol = sc.doc.ModelAbsoluteTolerance\n\ndef checkTheInputs():\n    w = gh.GH_RuntimeMessageLevel.Warning\n    \n    #Unpack the viewFactorInfo.\n    checkData25 = True\n    try:\n        viewFacInfoFromHive = hb_hive.visualizeFromHoneybeeHive(_viewFactorInfo)[0]\n        testPtViewFactor, zoneSrfNames, testPtSkyView, testPtBlockedVec, testPtZoneWeights, \\\n        testPtZoneNames, ptHeightWeights, zoneInletInfo, zoneHasWindows, outdoorIsThere, \\\n        outdoorNonSrfViewFac, outdoorPtHeightWeights, testPtBlockName, zoneWindowTransmiss, \\\n        zoneWindowNames, zoneFloorReflectivity, constantTransmis, finalAddShdTransmiss = viewFacInfoFromHive.recallAllProps()\n    except:\n        testPtViewFactor, zoneSrfNames, testPtSkyView, testPtBlockedVec, testPtZoneWeights, testPtZoneNames, ptHeightWeights, zoneInletInfo, zoneHasWindows, outdoorIsThere, outdoorNonSrfViewFac, outdoorPtHeightWeights, testPtBlockName, zoneWindowTransmiss, zoneWindowNames, zoneFloorReflectivity, constantTransmis, finalAddShdTransmiss = [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], True, []\n        checkData25 = False\n        warning = \"_viewFactorInfo is not valid.\"\n        print warning\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n    \n    #Convert the data tree of _viewFactorMesh to py data.\n    viewFactorMesh = []\n    checkData13 = True\n    pathCheck = 0\n    finalCheck = len(testPtViewFactor)\n    if _viewFactorMesh.BranchCount != 0:\n        if _viewFactorMesh.Branch(0)[0] != None:\n            treePaths = _viewFactorMesh.Paths\n            for path in treePaths:\n                i = path.Indices[0]\n                if i == pathCheck:\n                    branchList = _viewFactorMesh.Branch(path)\n                    dataVal = []\n                    for item in branchList:\n                        dataVal.append(item)\n                    viewFactorMesh.append(dataVal)\n                    pathCheck += 1\n                else:\n                    while pathCheck < i:\n                        viewFactorMesh.append([])\n                        pathCheck += 1\n                    if i == pathCheck:\n                        branchList = _viewFactorMesh.Branch(path)\n                        dataVal = []\n                        for item in branchList:\n                            dataVal.append(item)\n                        viewFactorMesh.append(dataVal)\n                        pathCheck += 1\n            if len(viewFactorMesh) < finalCheck:\n                while len(viewFactorMesh) < finalCheck:\n                    viewFactorMesh.append([])\n        else:\n            checkData13 = False\n            print \"Connect a data tree of view factor meshes from the 'Honeybee_Indoor View Factor Calculator' component.\"\n    else:\n        checkData13 = False\n        print \"Connect a data tree of view factor meshes from the 'Honeybee_Indoor View Factor Calculator' component.\"\n    \n    #Create a function to check and create a Python list from a datatree\n    def checkCreateDataTree(dataTree, dataName, dataType):\n        dataPyList = []\n        for i in range(dataTree.BranchCount):\n            branchList = dataTree.Branch(i)\n            dataVal = []\n            for item in branchList:\n                try: dataVal.append(float(item))\n                except: dataVal.append(item)\n            dataPyList.append(dataVal)\n        \n        #Test to see if the data has a header on it, which is necessary to know if it is the right data type.  If there's no header, the data should not be vizualized with this component.\n        checkHeader = []\n        dataHeaders = []\n        dataNumbers = []\n        for list in dataPyList:\n            if str(list[0]) == \"key:location/dataType/units/frequency/startsAt/endsAt\":\n                checkHeader.append(1)\n                dataHeaders.append(list[:7])\n                dataNumbers.append(list[7:])\n            else:\n                dataNumbers.append(list)\n        \n        if sum(checkHeader) == len(dataPyList):\n            dataCheck2 = True\n        else:\n            dataCheck2 = False\n            warning = \"Not all of the connected \" + dataName + \" has a Ladybug/Honeybee header on it.  This header is necessary to generate an indoor temperture map with this component.\"\n            print warning\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n        \n        #Check to be sure that the lengths of data in in the dataTree branches are all the same.\n        dataLength = len(dataNumbers[0])\n        dataLenCheck = []\n        for list in dataNumbers:\n            if len(list) == dataLength:\n                dataLenCheck.append(1)\n            else: pass\n        if sum(dataLenCheck) == len(dataNumbers) and dataLength <8761:\n            dataCheck4 = True\n        else:\n            dataCheck4 = False\n            warning = \"Not all of the connected \" + dataName + \" branches are of the same length or there are more than 8760 values in the list.\"\n            print warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n        \n        if dataCheck2 == True:\n            #Check to be sure that all of the data headers say that they are of the same type.\n            header = dataHeaders[0]\n            \n            headerUnits =  header[3]\n            headerStart = header[5]\n            headerEnd = header[6]\n            simStep = str(header[4])\n            headUnitCheck = []\n            headPeriodCheck = []\n            for head in dataHeaders:\n                if dataType in head[2]:\n                    headUnitCheck.append(1)\n                if head[3] == headerUnits and str(head[4]) == simStep and head[5] == headerStart and head[6] == headerEnd:\n                    headPeriodCheck.append(1)\n                else: pass\n            \n            if sum(headPeriodCheck) == len(dataHeaders):\n                dataCheck5 = True\n            else:\n                dataCheck5 = False\n                warning = \"Not all of the connected \" + dataName + \" branches are of the same timestep or same analysis period.\"\n                print warning\n                ghenv.Component.AddRuntimeMessage(w, warning)\n            \n            if sum(headUnitCheck) == len(dataHeaders):\n                dataCheck6 = True\n            else:\n                dataCheck6 = False\n                warning = \"Not all of the connected \" + dataName + \" data is for the correct data type.\"\n                print warning\n                ghenv.Component.AddRuntimeMessage(w, warning)\n        else:\n            dataCheck5 = False\n            dataCheck6 = False\n            if dataLength == 8760: annualData = True\n            else: annualData = False\n            simStep = 'unknown timestep'\n            headerUnits = 'unknown units'\n            dataHeaders = []\n            header = [None, None, None, None, None, None, None]\n        \n        return dataCheck5, dataCheck6, headerUnits, dataHeaders, dataNumbers, [header[5], header[6]]\n    \n    #Run all of the EnergyPlus data through the check function.\n    checkData1, checkData2, airTempUnits, airTempDataHeaders, airTempDataNumbers, analysisPeriod = checkCreateDataTree(_zoneAirTemp, \"_zoneAirTemp\", \"Air Temperature\")\n    checkData3, checkData4, srfTempUnits, srfTempHeaders, srfTempNumbers, analysisPeriod = checkCreateDataTree(_srfIndoorTemp, \"_srfIndoorTemp\", \"Inner Surface Temperature\")\n    checkData21, checkData22, flowVolUnits, flowVolDataHeaders, flowVolDataNumbers, analysisPeriod = checkCreateDataTree(_zoneAirFlowVol, \"_zoneAirFlowVol\", \"Air Flow Volume\")\n    checkData23, checkData24, heatGainUnits, heatGainDataHeaders, heatGainDataNumbers, analysisPeriod = checkCreateDataTree(_zoneAirHeatGain, \"_zoneAirHeatGain\", \"Air Heat Gain Rate\")\n    \n    #Try to bring in the outdoor surface temperatures.\n    outdoorClac = False\n    try:\n        checkData26, checkData27, outSrfTempUnits, outSrfTempHeaders, outSrfTempNumbers, analysisPeriod = checkCreateDataTree(srfOutdoorTemp_, \"_srfOutdoorTemp_\", \"Outer Surface Temperature\")\n        if outdoorIsThere == True: outdoorClac = True\n    except:\n        outdoorClac = False\n        checkData26, checkData27, outSrfTempUnits, outSrfTempHeaders, outSrfTempNumbers = True, True, 'C', [], []\n    \n    #Check the windowShadeTransmiss_.\n    checkData14 = True\n    checkData30 = True\n    winStatusNumbers = []\n    winStatusHeaders = []\n    allWindowShadesSame = True\n    try:\n        if windowShadeTransmiss_.BranchCount == 1 and len(windowShadeTransmiss_.Branch(0)) != 8767:\n            windowShadeTransmiss = []\n            for shadeValue in windowShadeTransmiss_.Branch(0):\n                windowShadeTransmiss.append(shadeValue)\n            if len(windowShadeTransmiss) == 8760:\n                allGood = True\n                for transVal in windowShadeTransmiss:\n                    transFloat = float(transVal)\n                    if transFloat <= 1.0 and transFloat >= 0.0: winStatusNumbers.append(transFloat)\n                    else: allGood = False\n                if allGood == False:\n                    checkData14 = False\n                    warning = 'windowShadeTransmiss_ must be a value between 0 and 1.'\n                    print warning\n                    ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n            elif len(windowShadeTransmiss) == 1:\n                if float(windowShadeTransmiss[0]) <= 1.0 and float(windowShadeTransmiss[0]) >= 0.0:\n                    for count in range(8760):\n                        winStatusNumbers.append(float(windowShadeTransmiss[0]))\n                else:\n                    checkData14 = False\n                    warning = 'windowShadeTransmiss_ must be a value between 0 and 1.'\n                    print warning\n                    ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n        elif windowShadeTransmiss_.BranchCount > 1 or len(windowShadeTransmiss_.Branch(0)) == 8767:\n            allWindowShadesSame = False\n            checkData14, checkData30, winStatusUnits, winStatusHeaders, winStatusNumbers, analysisPeriod = checkCreateDataTree(windowShadeTransmiss_, \"windowShadeTransmiss_\", \"Surface Window System Solar Transmittance\")\n            #Convert all of the numbers in shade status data tree to window transmissivities.\n            for winBCount, windowBranchList in enumerate(winStatusNumbers):\n                for shadHrCt, shadVal in enumerate(windowBranchList):\n                    winStatusNumbers[winBCount][shadHrCt] = float(shadVal)\n        elif constantTransmis == True:\n            for count in range(8760):\n                winStatusNumbers.append(1)\n            print 'No value found for windowShadeTransmiss_.  The window shade status will be set to 1 assuming no additional shading beyond the window glass transmissivity.'\n    except:\n        for count in range(8760):\n            winStatusNumbers.append(1)\n        print 'No value found for windowShadeTransmiss_.  The window shade status will be set to 1 assuming no additional shading beyond the window glass transmissivity.'\n    \n    \n    #Check to see if there are hourly transmissivities for the additional shading.\n    if constantTransmis == False:\n        allWindowShadesSame = False\n        for transmisslistCount, transmissList in enumerate(finalAddShdTransmiss):\n            winStatusNumbers.append(transmissList)\n            srfName = 'AddShd' + str(transmisslistCount)\n            shdHeader = ['key:location/dataType/units/frequency/startsAt/endsAt', 'Location', 'Surface Window System Solar Transmittance for ' + srfName + ': Window', 'Fraction', 'Hourly', analysisPeriod[0], analysisPeriod[1]]\n            winStatusHeaders.append(shdHeader)\n    \n    #Check the windSpeed_.\n    checkData31 = True\n    winSpeedNumbers = []\n    pathCheck = 0\n    allWindSpeedsSame = 1\n    if windSpeed_.BranchCount == 1:\n        additionalWindSpeed = []\n        for windValue in windSpeed_.Branch(0):\n            additionalWindSpeed.append(windValue)\n        if len(additionalWindSpeed) == 1:\n            try:\n                for count in range(8760):\n                    winSpeedNumbers.append(float(additionalWindSpeed[0]))\n            except:\n                try:\n                    if additionalWindSpeed[0].upper().endswith('.CSV'):\n                        allWindSpeedsSame = -1\n                        result = open(additionalWindSpeed[0], 'r')\n                        for lineCount, line in enumerate(result):\n                            winSpeedNumbers.append([])\n                            for column in line.split(','):\n                                winSpeedNumbers[lineCount].append(float(column))\n                        result.close()\n                    else:\n                        checkData31 = False\n                        warning = 'windSpeed_ values not recognized.'\n                        print warning\n                        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n                except:\n                    checkData31 = False\n                    warning = 'windSpeed_ values not recognized.'\n                    print warning\n                    ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n        elif len(additionalWindSpeed) == 8760:\n            allGood = True\n            for winSp in additionalWindSpeed:\n                windFloat = float(winSp)\n                if windFloat >= 0.0: winSpeedNumbers.append(windFloat)\n                else: allGood = False\n            if allGood == False:\n                checkData31 = False\n                warning = 'windSpeed_ must be a value greater than 0.'\n                print warning\n                ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n        else:\n            checkData31 = False\n            warning = 'windSpeed_ must be either a list of 8760 values that correspond to hourly changing wind speeds over the year or a single constant value for the whole year.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    elif windSpeed_.BranchCount > 1:\n        \n        if windSpeed_.BranchCount == testPtNum:\n            #Wind speed values for each point in the analysis.\n            allWindSpeedsSame = -1\n            winSpeedNumInit = []\n            for i in range(windSpeed_.BranchCount):\n                branchList = windSpeed_.Branch(i)\n                dataVal = []\n                for item in branchList:\n                    dataVal.append(float(item))\n                winSpeedNumInit.append(dataVal)\n            winSpeedNumbers = zip(*winSpeedNumInit)\n            \n        elif windSpeed_.BranchCount == _viewFactorMesh.BranchCount:\n            #Wind speed for each zone in the analysis.\n            allWindSpeedsSame = 0\n            treePaths = windSpeed_.Paths\n            for path in treePaths:\n                i = path.Indices[0]\n                if i == pathCheck:\n                    branchList = windSpeed_.Branch(path)\n                    dataVal = []\n                    for item in branchList:\n                        dataVal.append(float(item))\n                    winSpeedNumbers.append(dataVal)\n                    pathCheck += 1\n                else:\n                    while pathCheck < i:\n                        winSpeedNumbers.append([])\n                        pathCheck += 1\n                    if i == pathCheck:\n                        branchList = windSpeed_.Branch(path)\n                        dataVal = []\n                        for item in branchList:\n                            dataVal.append(float(item))\n                        winSpeedNumbers.append(dataVal)\n                        pathCheck += 1\n            if len(winSpeedNumbers) < finalCheck:\n                while len(winSpeedNumbers) < finalCheck:\n                    winSpeedNumbers.append([])\n        else:\n            checkData31 = False\n            warning = 'windSpeed_ data tree branches do not match those of the viewFactorMesh or the number of testPts.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    else:\n        print 'No value found for windSpeed_. The components will use an indoor wind speed from the air flow volume or outdoor EPW wind speed.'\n    \n    #Check to be sure that the units of flowVol and heat gain are correct.\n    checkData9 = True\n    if flowVolUnits == \"m3/s\": pass\n    else:\n        checkData9 = False\n        warning = \"_zoneFlowVol must be in m3/s.\"\n        print warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n    \n    checkData10 = True\n    if heatGainUnits == \"W\": pass\n    else:\n        checkData10 = False\n        warning = \"_zoneHeatGain must be in W.\"\n        print warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n    \n    checkData11 = True\n    if airTempUnits == srfTempUnits == \"C\": pass\n    else:\n        checkData11 = False\n        warning = \"_zoneAirTemp and _srfIndoorTemp must be in degrees C.\"\n        print warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n    \n    checkData28 = True\n    if outSrfTempUnits == \"C\": pass\n    else:\n        checkData28 = False\n        warning = \"_srfOutdoorTemp must be in degrees C.\"\n        print warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n    \n    #Try to parse the weather file in order to get direct rad, diffuse rad, and location data.\n    checkData5 = True\n    if not os.path.isfile(_epwFile):\n        checkData5 = False\n        warningM = \"Failed to find the file: \" + str(_epwFile)\n        print warningM\n        ghenv.Component.AddRuntimeMessage(w, warningM)\n    else:\n        locationData = lb_preparation.epwLocation(_epwFile)\n        location = locationData[-1]\n        weatherData = lb_preparation.epwDataReader(_epwFile, locationData[0])\n        directNormalRadiation = weatherData[5]\n        diffuseHorizontalRadiation = weatherData[6]\n        globalHorizontalRadiation = weatherData[7]\n        dryBulbTemp = weatherData[0]\n        outWindSpeed = weatherData[3]\n        outHorizInfrared = weatherData[12]\n    \n    #Separate out the _dirNormRad, the diffuse Horizontal rad, and the location  data.\n    directSolarRad = []\n    diffSolarRad = []\n    prevailingOutdoorTemp = []\n    latitude = None\n    longitude = None\n    timeZone = None\n    if checkData5 == True:\n        directSolarRad = directNormalRadiation[7:]\n        diffSolarRad = diffuseHorizontalRadiation[7:]\n        globHorizRad = globalHorizontalRadiation[7:]\n        outHorizInfrared = outHorizInfrared[7:]\n        prevailingOutdoorTemp = dryBulbTemp\n        locList = location.split('\\n')\n        for line in locList:\n            if \"Latitude\" in line: latitude = float(line.split(',')[0])\n            elif \"Longitude\" in line: longitude = float(line.split(',')[0])\n            elif \"Time Zone\" in line: timeZone = float(line.split(',')[0])\n    \n    \n    #Check to be sure that the number of mesh faces and test points match.\n    checkData8 = True\n    if checkData25 == True:\n        for zoneCount, zone in enumerate(viewFactorMesh):\n            if len(zone) != 1:\n                totalFaces = 0\n                for meshCount, mesh in enumerate(zone):\n                    totalFaces = totalFaces +mesh.Faces.Count\n                if totalFaces == len(testPtViewFactor[zoneCount]): pass\n                else:\n                    totalVertices = 0\n                    for meshCount, mesh in enumerate(zone):\n                        totalVertices = totalVertices +mesh.Vertices.Count\n                    \n                    if totalVertices == len(testPtViewFactor[zoneCount]): pass\n                    else:\n                        checkData8 = False\n                        warning = \"For one of the meshes in the _viewFactorMesh, the number of faces in the mesh and test points in the _testPtViewFactor do not match.\\n\" + \\\n                        \"This can sometimes happen when you have geometry created with one Rhino model tolerance and you generate a mesh off of it with a different tolerance.\\n\"+ \\\n                        \"Try changing your Rhino model tolerance and seeing if it works.\"\n                        print warning\n                        ghenv.Component.AddRuntimeMessage(w, warning)\n            else:\n                if zone[0].Faces.Count == len(testPtViewFactor[zoneCount]): pass\n                else:\n                    if zone[0].Vertices.Count == len(testPtViewFactor[zoneCount]): pass\n                    else:\n                        checkData8 = False\n                        warning = \"For one of the meshes in the _viewFactorMesh, the number of faces in the mesh and test points in the _testPtViewFactor do not match.\\n\" + \\\n                        \"This can sometimes happen when you have geometry created with one Rhino model tolerance and you generate a mesh off of it with a different tolerance.\\n\"+ \\\n                        \"Try changing your Rhino model tolerance and seeing if it works.\"\n                        print warning\n                        ghenv.Component.AddRuntimeMessage(w, warning)\n    \n    #If there are no outdoor surface temperatures and there are outdoor view factors, remove it from the mesh.\n    if outdoorClac == False and outdoorIsThere == True:\n        zoneSrfNames = zoneSrfNames[:-1]\n        testPtViewFactor = testPtViewFactor[:-1]\n        viewFactorMesh = viewFactorMesh[:-1]\n        testPtSkyView = testPtSkyView[:-1]\n        testPtBlockedVec = testPtBlockedVec[:-1]\n        zoneFloorReflectivity = zoneFloorReflectivity[:-1]\n    \n    #Figure out the number of times to divide the sky based on the length of the blockedVec list.\n    numSkyPatchDivs = 0\n    checkData12 = True\n    if checkData25 == True:\n        for blockList in testPtBlockedVec:\n            if blockList != []:\n                if len(blockList[0]) == 145: numSkyPatchDivs = 0\n                elif len(blockList[0]) == 577: numSkyPatchDivs = 1\n                elif len(blockList[0]) == 1297: numSkyPatchDivs = 2\n                elif len(blockList[0]) == 2305: numSkyPatchDivs = 3\n                else:\n                    checkData12 = False\n                    warning = \"You have an absurdly high number of view vectors from the 'Indoor View Factor' component such that it is not supported by the current component.\"\n                    print warning\n                    ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    \n    #Check the clothing absorptivity.\n    checkData7 = True\n    cloA = 0.7\n    if cloAbsorptivity_ != None:\n        if cloAbsorptivity_ <= 1.0 and cloAbsorptivity_ >= 0.0: cloA = cloAbsorptivity_\n        else:\n            checkData7 = False\n            warning = 'cloAbsorptivity_ must be a value between 0 and 1.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    else:\n        print 'No value found for cloAbsorptivity_.  The absorptivity will be set to 0.7 for average brown skin and typical clothing.'\n    \n    \n    #Check the outdoor terrain.\n    checkData29, terrainType, d, a = lb_wind.readTerrainType(outdoorTerrain_)\n    if checkData29 == False:\n        warning = \"Invalid input for terrainType_.\"\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    else:\n        print \"Terrain set to \" + terrainType + \".\"\n    \n    #Check the inletHeightOverride_.\n    inletHeightOverride = []\n    checkData15 = True\n    if checkData25 == True and len(inletHeightOverride_) > 0:\n        if len(inletHeightOverride_) == len(viewFactorMesh): inletHeightOverride = inletHeightOverride_\n        else:\n            checkData15 = False\n            warning = 'The length of data in the inletHeightOverride_ does not match the number of branches in the data tree of the _viewFactorMesh.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    \n    #Check the wellMixedAirOverride_.\n    checkData16 = True\n    mixedAirOverride = []\n    if wellMixedAirOverride_ != []:\n        if len(wellMixedAirOverride_) == 8760:\n            for val in wellMixedAirOverride_:\n                mixedAirOverride.append(int(val))\n        elif len(wellMixedAirOverride_) == 1:\n            for count in range(8760):\n                mixedAirOverride.append(int(wellMixedAirOverride_[0]))\n        else:\n            checkData16 = False\n            warning = 'wellMixedAirOverride_ must be either a list of 8760 values that correspond to hourly air mixing over the year or a single constant value for the whole year.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    else:\n        for count in range(8760):\n            mixedAirOverride.append(0)\n        print 'No value found for wellMixedAirOverride_.  The stratification calculation will be run for every hour of the year.'\n    \n    #Check to see if there are any comfortPar connected and, if not, set the defaults to ASHRAE.\n    checkData6 = True\n    ASHRAEorEN = True\n    comfClass = False\n    avgMonthOrRunMean = True\n    levelOfConditioning = 0\n    if comfortPar_ != []:\n        try:\n            ASHRAEorEN = comfortPar_[0]\n            comfClass = comfortPar_[1]\n            avgMonthOrRunMean = comfortPar_[2]\n            levelOfConditioning = comfortPar_[3]\n        except:\n            checkData6 = False\n            warning = 'The connected comfortPar_ are not valid comfort parameters from the \"Ladybug_Adaptive Comfort Parameters\" component.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    \n    #Check the north direction.\n    northAngle, northVector = lb_preparation.angle2north(north_)\n    \n    #Do a final check of everything.\n    if checkData1 == True and checkData2 == True and checkData3 == True and checkData4 == True and checkData5 == True and checkData7 == True and checkData8 == True and checkData9 == True and checkData10 == True and checkData11 == True and checkData12 == True and checkData13 == True and checkData14 == True and checkData15 == True and checkData16 == True and checkData21 == True and checkData22 == True and checkData23 == True and checkData24 == True and checkData25 == True and checkData26 == True and checkData27 == True and checkData28 == True and checkData29 == True and checkData30 == True and checkData31 == True:\n        checkData = True\n    else:\n        return -1\n    \n    return \"Adaptive\", srfTempNumbers, srfTempHeaders, airTempDataNumbers, airTempDataHeaders, flowVolDataHeaders, flowVolDataNumbers, heatGainDataHeaders, heatGainDataNumbers, zoneSrfNames, testPtViewFactor, viewFactorMesh, latitude, longitude, timeZone, diffSolarRad, directSolarRad, globHorizRad, testPtSkyView, testPtBlockedVec, numSkyPatchDivs, winStatusNumbers, cloA, zoneFloorReflectivity, testPtZoneNames, testPtZoneWeights, ptHeightWeights, zoneInletInfo, inletHeightOverride, prevailingOutdoorTemp, ASHRAEorEN, comfClass, avgMonthOrRunMean, levelOfConditioning, mixedAirOverride, zoneHasWindows, outdoorClac, outSrfTempHeaders, outSrfTempNumbers, outdoorNonSrfViewFac, analysisPeriod, outWindSpeed, d, a, outdoorPtHeightWeights, allWindowShadesSame, winStatusHeaders, testPtBlockName, zoneWindowTransmiss, zoneWindowNames, allWindSpeedsSame, winSpeedNumbers, outHorizInfrared, northAngle\n\n\n\n#Check to be sure that LB+HB are flying.\ninitCheck = False\nif sc.sticky.has_key('honeybee_release') == False and sc.sticky.has_key('ladybug_release') == False:\n    print \"You should first let Ladybug and Honeybee fly...\"\n    ghenv.Component.AddRuntimeMessage(w, \"You should first let Ladybug and Honeybee fly...\")\nelse:\n    initCheck = True\n    lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n    lb_wind = sc.sticky[\"ladybug_WindSpeed\"]()\n    hb_hive = sc.sticky[\"honeybee_Hive\"]()\n\n\n#Check the data input.\ncheckData = False\nif _viewFactorMesh.BranchCount > 0 and len(_viewFactorInfo) > 0 and _epwFile != None and _srfIndoorTemp.BranchCount > 0 and _zoneAirTemp.BranchCount > 0  and _zoneAirFlowVol.BranchCount > 0 and _zoneAirHeatGain.BranchCount > 0 and initCheck == True:\n    if _viewFactorInfo[0] != None:\n        recipe = checkTheInputs()\n        if recipe != -1:\n            comfRecipe = recipe",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}