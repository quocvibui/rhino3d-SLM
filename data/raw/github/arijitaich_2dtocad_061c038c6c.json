{
  "source_url": "https://github.com/arijitaich/2dtocad/blob/f837c55a0c1597a488080ecdc9c5c11a0264d13e/mcp/rhino_mcp/grasshopper_tools.py",
  "repo": "arijitaich/2dtocad",
  "repo_stars": 0,
  "repo_description": "A pipeline to create 2d to cad of each and every component required to manufacture an item provided as user input images.",
  "license": "unknown",
  "filepath": "mcp/rhino_mcp/grasshopper_tools.py",
  "instruction": "Tools for interacting with Grasshopper through socket connection.",
  "code": "\"\"\"Tools for interacting with Grasshopper through socket connection.\"\"\"\nfrom mcp.server.fastmcp import FastMCP, Context, Image\nimport logging\nfrom typing import Dict, Any, List, Optional, Union\nimport json\nimport socket\nimport time\nimport base64\nimport io\nfrom PIL import Image as PILImage\nimport requests\nimport re\nfrom urllib3.exceptions import InsecureRequestWarning\nimport urllib3\n\n# Disable insecure HTTPS warnings\nurllib3.disable_warnings(InsecureRequestWarning)\n\n# Configure logging\nlogger = logging.getLogger(\"GrasshopperTools\")\n\n# Add a preprocessing function for LLM inputs\ndef preprocess_llm_input(input_str: str) -> str:\n    \"\"\"\n    Preprocess a potentially malformed JSON string from an LLM.\n    This handles common issues before attempting JSON parsing.\n\n    Args:\n        input_str: Raw string from LLM that may contain malformed JSON\n\n    Returns:\n        Preprocessed string that should be easier to parse\n    \"\"\"\n    if not isinstance(input_str, str):\n        return input_str\n\n    # Replace backtick delimiters with proper double quotes for the entire JSON object\n    if input_str.strip().startswith('`{') and input_str.strip().endswith('}`'):\n        input_str = input_str.strip()[1:-1]  # Remove the outer backticks\n\n    # Handle backtick-delimited field names and string values\n    # This is a basic approach - first convert all standalone backtick pairs to double quotes\n    result = \"\"\n    in_string = False\n    last_char = None\n    i = 0\n    \n    while i < len(input_str):\n        char = input_str[i]\n        \n        # Handle backtick as quote\n        if char == '`' and (last_char is None or last_char != '\\\\'):\n            in_string = not in_string\n            result += '\"'\n        else:\n            result += char\n            \n        last_char = char\n        i += 1\n\n    # Fix boolean values\n    result = re.sub(r':\\s*True\\b', ': true', result)\n    result = re.sub(r':\\s*False\\b', ': false', result)\n    result = re.sub(r':\\s*None\\b', ': null', result)\n    \n    return result\n\ndef extract_payload_fields(raw_input: str) -> Dict[str, Any]:\n    \"\"\"\n    Extract fields from a payload that might be malformed.\n    Works with raw LLM output directly.\n    \n    Args:\n        raw_input: Raw string input from LLM\n        \n    Returns:\n        Dictionary of extracted fields\n    \"\"\"\n    if not isinstance(raw_input, str):\n        return {}\n    \n    # First attempt: try the standard JSON sanitizer\n    payload = sanitize_json(raw_input)\n    if payload:\n        return payload\n    \n    # Second attempt: special handling for backtick-delimited code\n    if '`code`' in raw_input or '\"code\"' in raw_input:\n        # Find the code section\n        code_match = re.search(r'[`\"]code[`\"]\\s*:\\s*[`\"](.*?)[`\"](?=\\s*,|\\s*\\})', raw_input, re.DOTALL)\n        instance_guid_match = re.search(r'[`\"]instance_guid[`\"]\\s*:\\s*[`\"](.*?)[`\"]', raw_input)\n        message_match = re.search(r'[`\"]message_to_user[`\"]\\s*:\\s*[`\"](.*?)[`\"]', raw_input)\n        \n        result = {}\n        \n        if instance_guid_match:\n            result[\"instance_guid\"] = instance_guid_match.group(1)\n            \n        if code_match:\n            result[\"code\"] = code_match.group(1)\n            \n        if message_match:\n            result[\"message_to_user\"] = message_match.group(1)\n            \n        return result\n        \n    return {}\n\n# Update the sanitize_json function to use the preprocessor\ndef sanitize_json(json_str_or_dict: Union[str, Dict]) -> Dict[str, Any]:\n    \"\"\"\n    Sanitize and validate JSON input, which might come from an LLM.\n    \n    Args:\n        json_str_or_dict: Either a JSON string or dictionary that might need sanitizing\n        \n    Returns:\n        A properly formatted dictionary\n    \"\"\"\n    # If it's already a dictionary, return it\n    if isinstance(json_str_or_dict, dict):\n        return json_str_or_dict.copy()\n    \n    # If it's a string, try to fix common issues\n    if isinstance(json_str_or_dict, str):\n        # Apply preprocessing for LLM input\n        json_str = preprocess_llm_input(json_str_or_dict)\n        \n        # Remove markdown JSON code block markers if present\n        json_str = re.sub(r'^```json\\s*', '', json_str)\n        json_str = re.sub(r'\\s*```$', '', json_str)\n        \n        # Try to parse the JSON\n        try:\n            return json.loads(json_str)\n        except json.JSONDecodeError as e:\n            logger.error(f\"Failed to parse JSON after preprocessing: {e}\")\n            logger.error(f\"Preprocessed JSON string: {json_str}\")\n            \n            # Try another approach - remove all newlines from outside code sections\n            try:\n                # Find code sections\n                if '\"code\"' in json_str:\n                    parts = []\n                    last_end = 0\n                    \n                    # Find all code sections\n                    for match in re.finditer(r'\"code\"\\s*:\\s*\"(.*?)\"(?=\\s*,|\\s*\\})', json_str, re.DOTALL):\n                        # Add the part before code with newlines removed\n                        before_code = json_str[last_end:match.start()]\n                        before_code = re.sub(r'\\s+', ' ', before_code)\n                        parts.append(before_code)\n                        \n                        # Add the code section as is\n                        code_section = match.group(0)\n                        parts.append(code_section)\n                        \n                        last_end = match.end()\n                    \n                    # Add the remaining part\n                    remaining = json_str[last_end:]\n                    remaining = re.sub(r'\\s+', ' ', remaining)\n                    parts.append(remaining)\n                    \n                    # Combine all parts\n                    json_str = ''.join(parts)\n                    \n                    return json.loads(json_str)\n            except json.JSONDecodeError:\n                logger.error(f\"Failed to parse JSON with alternative method\")\n            \n            # Return empty dict as fallback\n            return {}\n    \n    # If it's neither a dict nor string, return empty dict\n    return {}\n\nclass GrasshopperConnection:\n    def __init__(self, host='localhost', port=9999):  # Using port 9999 to match gh_socket_server.py\n        self.host = host\n        self.port = port\n        self.base_url = f\"http://{host}:{port}\"\n        self.timeout = 30.0  # 30 second timeout\n    \n    def check_server_available(self) -> bool:\n        \"\"\"Check if the Grasshopper server is running and available.\n        \n        Returns:\n            bool: True if the server is available, False otherwise\n        \"\"\"\n        try:\n            response = requests.get(self.base_url, timeout=2.0)\n            response.raise_for_status()\n            logger.info(\"Grasshopper server is available at {0}\".format(self.base_url))\n            return True\n        except Exception as e:\n            logger.warning(\"Grasshopper server is not available: {0}\".format(str(e)))\n            return False\n    \n    def connect(self):\n        \"\"\"Connect to the Grasshopper script's HTTP server\"\"\"\n        # Check if server is available\n        if not self.check_server_available():\n            raise Exception(\"Grasshopper server not available at {0}. Make sure the GHPython component is running and the toggle is set to True.\".format(self.base_url))\n        logger.info(\"Connected to Grasshopper server\")\n    \n    def disconnect(self):\n        \"\"\"No need to disconnect for HTTP connections\"\"\"\n        pass\n    \n    def send_command(self, command_type: str, params: Dict[str, Any] = None) -> Dict[str, Any]:\n        \"\"\"Send a command to the Grasshopper script and wait for response\"\"\"\n        try:\n            data = {\n                \"type\": command_type,\n                **(params or {})\n            }\n\n            logger.info(f\"Sending command to Grasshopper server: type={command_type}\")\n            \n            # Use a session to handle connection properly\n            with requests.Session() as session:\n                response = session.post(\n                    self.base_url,\n                    json=data,\n                    timeout=self.timeout,\n                    headers={'Content-Type': 'application/json'},\n                    stream=True\n                )\n                response.raise_for_status()\n                \n                # Read the response content and return it directly\n                return response.json()\n                    \n        except requests.exceptions.RequestException as req_err:\n            error_content = \"\"\n            if hasattr(req_err, 'response') and req_err.response is not None:\n                try:\n                    error_content = req_err.response.text\n                except:\n                    pass\n                \n            error_msg = f\"HTTP request error: {str(req_err)}. Response: {error_content}\"\n            logger.error(error_msg)\n            return {\"status\": \"error\", \"result\": error_msg}\n            \n        except Exception as e:\n            error_msg = f\"Error communicating with Grasshopper script: {str(e)}\"\n            logger.error(error_msg)\n            return {\"status\": \"error\", \"result\": error_msg}\n\n# Global connection instance\n_grasshopper_connection = None\n\ndef get_grasshopper_connection() -> GrasshopperConnection:\n    \"\"\"Get or create the Grasshopper connection\"\"\"\n    global _grasshopper_connection\n    if _grasshopper_connection is None:\n        _grasshopper_connection = GrasshopperConnection()\n    return _grasshopper_connection\n\nclass GrasshopperTools:\n    \"\"\"Collection of tools for interacting with Grasshopper.\"\"\"\n    \n    def __init__(self, app):\n        self.app = app\n        self._register_tools()\n    \n    def _register_tools(self):\n        \"\"\"Register all Grasshopper tools with the MCP server.\"\"\"\n        self.app.tool()(self.is_server_available)\n        self.app.tool()(self.execute_code_in_gh)\n        self.app.tool()(self.get_gh_context)\n        self.app.tool()(self.get_objects)\n        self.app.tool()(self.get_selected)\n        self.app.tool()(self.update_script)\n        self.app.tool()(self.update_script_with_code_reference)\n        self.app.tool()(self.expire_and_get_info)\n    \n    def is_server_available(self, ctx: Context) -> bool:\n        \"\"\"Grasshopper: Check if the Grasshopper server is available.\n        \n        This is a quick check to see if the Grasshopper socket server is running\n        and available for connections.\n        \n        Returns:\n            bool: True if the server is available, False otherwise\n        \"\"\"\n        try:\n            connection = get_grasshopper_connection()\n            return connection.check_server_available()\n        except Exception as e:\n            logger.error(\"Error checking Grasshopper server availability: {0}\".format(str(e)))\n            return False\n    \n    def execute_code_in_gh(self, ctx: Context, code: str) -> str:\n        \"\"\"Grasshopper: Execute arbitrary Python code in Grasshopper.\n        \n        IMPORTANT: \n        - Uses IronPython 2.7 - no f-strings or modern Python features\n        - Always include ALL required imports in your code\n        - Use 'result = value' to return data (don't use return statements)\n\n        Example - Adding components to canvas:\n        ```python\n        import scriptcontext as sc\n        import clr\n        import Rhino\n        import System.Drawing as sd\n        import Grasshopper\n        import Grasshopper.Kernel.Special as GHSpecial\n\n        doc = ghenv.Component.OnPingDocument()\n        \n        # Create and position a Pipeline\n        pipe = GHSpecial.GH_GeometryPipeline()\n        if pipe.Attributes is None: pipe.CreateAttributes()\n        pipe.Attributes.Pivot = sd.PointF(100, 100)\n        doc.AddObject(pipe, False)\n\n        # Create and connect a Panel\n        pan = GHSpecial.GH_Panel()\n        if pan.Attributes is None: pan.CreateAttributes()\n        pan.Attributes.Pivot = sd.PointF(300, 100)\n        doc.AddObject(pan, False)\n        pan.AddSource(pipe)\n        \n        result = \"Components created successfully\"\n        ```\n        \n        You can also provide the code as part of a JSON object with a \"code\" field.\n        \n        Args:\n            code: The Python code to execute, or a JSON object with a \"code\" field\n        \n        Returns:\n            The result of the code execution\n        \"\"\"\n        try:\n            # Check if the input might be a JSON payload\n            if isinstance(code, str) and (\n                code.strip().startswith('{') or \n                code.strip().startswith('`{') or\n                '`code`' in code or \n                '\"code\"' in code\n            ):\n                # Try direct extraction for speed and reliability\n                payload = extract_payload_fields(code)\n                if payload and \"code\" in payload:\n                    code = payload[\"code\"]\n            \n            # Validate that we have code to execute\n            if not code or not isinstance(code, str):\n                return \"Error: No valid code provided. Please provide Python code to execute.\"\n            \n            # Make sure code ends with a result variable if it doesn't have one\n            if \"result =\" not in code and \"result=\" not in code:\n                # Extract the last line if it starts with \"return\"\n                lines = code.strip().split(\"\\n\")\n                if lines and lines[-1].strip().startswith(\"return \"):\n                    return_value = lines[-1].strip()[7:].strip() # Remove \"return \" prefix\n                    # Replace the return with a result assignment\n                    lines[-1] = \"result = \" + return_value\n                    code = \"\\n\".join(lines)\n                else:\n                    # Append a default result if no return or result is present\n                    code += \"\\n\\n# Auto-added result assignment\\nresult = \\\"Code executed successfully\\\"\"\n            \n            logger.info(f\"Sending code execution request to Grasshopper\")\n            connection = get_grasshopper_connection()\n            \n            result = connection.send_command(\"execute_code\", {\n                \"code\": code\n            })\n            \n            # Simply return result info with error prefix if needed\n            if result.get(\"status\") == \"error\":\n                return f\"Error: {result.get('result', 'Unknown error')}\"\n            return result.get(\"result\", \"Code executed successfully\")\n                \n        except Exception as e:\n            return f\"Error executing code: {str(e)}\"\n\n    def get_gh_context(self, ctx: Context, simplified: bool = False) -> str:\n        \"\"\"Grasshopper: Get current Grasshopper document state and definition graph, sorted by execution order.\n        \n        Returns a JSON string containing:\n        - Component graph (connections between components)\n        - Component info (guid, name, type)\n        - Component properties and parameters\n        \n        Args:\n            simplified: When true, returns minimal component info without detailed properties\n        \n        Returns:\n            JSON string with grasshopper definition graph\n        \"\"\"\n        try:\n            logger.info(\"Getting Grasshopper context with simplified={0}\".format(simplified))\n            connection = get_grasshopper_connection()\n            result = connection.send_command(\"get_context\", {\n                \"simplified\": simplified\n            })\n            \n            if result.get(\"status\") == \"error\":\n                return f\"Error: {result.get('result', 'Unknown error')}\"\n            return json.dumps(result.get(\"result\", {}), indent=2)\n                \n        except Exception as e:\n            return f\"Error getting context: {str(e)}\"\n\n    def get_objects(self, ctx: Context, instance_guids: List[str], simplified: bool = False, context_depth: int = 0) -> str:\n        \"\"\"Grasshopper: Get information about specific components by their GUIDs.\n        \n        Args:\n            instance_guids: List of component GUIDs to retrieve\n            simplified: When true, returns minimal component info\n            context_depth: How many levels of connected components to include (0-3), try to keep it small\n        \n        Returns:\n            JSON string with component information and optional context\n        \"\"\"\n        try:\n            logger.info(\"Getting objects with GUIDs: {0}\".format(instance_guids))\n            connection = get_grasshopper_connection()\n            result = connection.send_command(\"get_objects\", {\n                \"instance_guids\": instance_guids,\n                \"simplified\": simplified,\n                \"context_depth\": context_depth\n            })\n            \n            if result.get(\"status\") == \"error\":\n                return f\"Error: {result.get('result', 'Unknown error')}\"\n            return json.dumps(result.get(\"result\", {}), indent=2)\n                \n        except Exception as e:\n            return f\"Error getting objects: {str(e)}\"\n\n    def get_selected(self, ctx: Context, simplified: bool = False, context_depth: int = 0) -> str:\n        \"\"\"Grasshopper: Get information about currently selected components.\n        \n        Args:\n            simplified: When true, returns minimal component info\n            context_depth: How many levels of connected components to include (0-3)\n        \n        Returns:\n            JSON string with selected component information and optional context\n        \"\"\"\n        try:\n            logger.info(\"Getting selected components\")\n            connection = get_grasshopper_connection()\n            result = connection.send_command(\"get_selected\", {\n                \"simplified\": simplified,\n                \"context_depth\": context_depth\n            })\n            \n            if result.get(\"status\") == \"error\":\n                return f\"Error: {result.get('result', 'Unknown error')}\"\n            return json.dumps(result.get(\"result\", {}), indent=2)\n                \n        except Exception as e:\n            return f\"Error getting selected components: {str(e)}\"\n\n    def update_script(self, ctx: Context, instance_guid: str = None, code: str = None, description: str = None, \n                     message_to_user: str = None, param_definitions: List[Dict[str, Any]] = None) -> str:\n        \"\"\"Grasshopper: Update a script component with new code, description, user feedback message, and optionally redefine its parameters.\n        \n        IMPORTANT NOTES:\n        0. the output param \"output\" is reserved for the \"message_to_user\", name output params with a meaningful name if you create new ones\n        1. The code must be valid Python 2.7 / IronPython code (no f-strings!)\n        2. When updating existing code:\n           - If NOT changing parameters, ensure to keep the same input/output variable names!\n           - Know their datatypes and access methods (list, datatree, item) before modifying\n           - The script may be part of a larger definition - maintain input/output structure\n        3. When changing input and outputparameters:\n           - You must provide ALL input/output parameters, even existing ones you want to keep\n           - The component will be completely reconfigured with the new parameter set\n           - Existing connections may be lost if parameter names change\n        \n        Example:\n        ```json\n        {\n            \"instance_guid\": \"a1b2c3d4-e5f6-4a5b-9c8d-7e6f5d4c3b2a\",\n            \"code\": \"import Rhino.Geometry as rg\\\\n\\\\n# Create circle from radius\\\\norigin = rg.Point3d(0, 0, 0)\\\\ncircle = rg.Circle(origin, radius)\\\\n\\\\n# Set outputs\\\\nresult = circle\\\\ncircle_center = circle.Center\\\\ncircle_area = circle.Area\",\n            \"description\": \"Creates a circle and outputs its geometry, center point, and area\",\n            \"message_to_user\": \"Circle component updated with new outputs for center point and area calculation\",\n            \"param_definitions\": [\n                {\n                    \"type\": \"input\",\n                    \"name\": \"radius\",\n                    \"access\": \"item\",\n                    \"typehint\": \"float\",\n                    \"description\": \"Circle radius\",\n                    \"optional\": false,\n                    \"default\": 1.0\n                },\n                {\n                    \"type\": \"output\",\n                    \"name\": \"circle\",\n                    \"description\": \"Generated circle geometry\"\n                },\n                {\n                    \"type\": \"output\",\n                    \"name\": \"center\",\n                    \"description\": \"Center point of the circle\"\n                },\n                {\n                    \"type\": \"output\",\n                    \"name\": \"output\",\n                    \"description\": \"Used to display messages to the user\"\n                }\n            ]\n        }\n        ```\n        \n        Args:\n            instance_guid: The GUID of the script component to update\n            code: Optional new Python code for the component\n            description: Optional new description for the component\n            message_to_user: Optional feedback message that should include a change summary and/or suggestions\n            param_definitions: Optional list of parameter definitions. If provided, ALL parameters will be redefined.\n                Each definition must be a dictionary with:\n                Required keys:\n                    - \"type\": \"input\" or \"output\"\n                    - \"name\": Parameter name (string)\n                Optional keys for inputs:\n                    - \"access\": \"item\", \"list\", or \"tree\" (default \"list\")\n                    - \"typehint\": e.g. \"str\", \"int\", \"float\", \"bool\" (determines parameter type)\n                    - \"description\": Parameter description\n                    - \"optional\": bool, default True\n                    - \"default\": Default value (not persistent)\n        \n        Returns:\n            Success status with summary of which elements were updated\n        \"\"\"\n        try:\n            # Log initial input for debugging\n            if isinstance(instance_guid, str) and len(instance_guid) > 200:\n                logger.info(f\"Received long payload as instance_guid parameter: first 100 chars: {instance_guid[:100]}...\")\n            else:\n                logger.info(f\"Initial parameters: instance_guid={instance_guid}, code length={len(code) if code else 0}, \"\n                          f\"description={'provided' if description else 'None'}, \"\n                          f\"message_to_user={'provided' if message_to_user else 'None'}, \"\n                          f\"param_definitions={'provided' if param_definitions else 'None'}\")\n            \n            # Check if the first argument is a string that looks like a JSON payload\n            if isinstance(instance_guid, str) and (\n                instance_guid.strip().startswith('{') or \n                instance_guid.strip().startswith('`{') or \n                '`instance_guid`' in instance_guid or \n                '\"instance_guid\"' in instance_guid\n            ):\n                logger.info(\"Detected JSON-like payload in instance_guid parameter, extracting fields\")\n                # More robust extraction for complex payloads\n                payload = extract_payload_fields(instance_guid)\n                if payload and \"instance_guid\" in payload:\n                    # Log what was extracted\n                    logger.info(f\"Extracted fields from payload: {sorted(payload.keys())}\")\n                    \n                    instance_guid = payload.get(\"instance_guid\")\n                    code = payload.get(\"code\", code)\n                    description = payload.get(\"description\", description)\n                    message_to_user = payload.get(\"message_to_user\", message_to_user)\n                    param_definitions = payload.get(\"param_definitions\", param_definitions)\n                    \n                    logger.info(f\"After extraction: instance_guid={instance_guid}, code length={len(code) if code else 0}\")\n                else:\n                    logger.warning(\"Failed to extract instance_guid from payload\")\n            \n            # Ensure we have a valid instance_guid\n            if not instance_guid:\n                logger.error(\"No instance_guid provided\")\n                return \"Error: No instance_guid provided. Please specify the GUID of the script component to update.\"\n            \n            logger.info(f\"Updating script component {instance_guid}\")\n            logger.info(f\"Parameter details: code={bool(code)}, description={bool(description)}, \"\n                      f\"message_to_user={bool(message_to_user)}, param_definitions type={type(param_definitions) if param_definitions else None}\")\n                      \n            connection = get_grasshopper_connection()\n            \n            # Sanitize param_definitions if provided\n            if param_definitions is not None and isinstance(param_definitions, list):\n                # Create new sanitized list\n                sanitized_params = []\n                for param in param_definitions:\n                    if isinstance(param, dict):\n                        sanitized_params.append(param.copy())\n                    else:\n                        # Try to parse if it's a string\n                        try:\n                            if isinstance(param, str):\n                                param_dict = json.loads(preprocess_llm_input(param))\n                                sanitized_params.append(param_dict)\n                        except:\n                            logger.warning(f\"Could not parse parameter definition: {param}\")\n                \n                param_definitions = sanitized_params\n            \n            # Prepare the command payload - log it before sending\n            command_payload = {\n                \"instance_guid\": instance_guid,\n                \"code\": code,\n                \"description\": description,\n                \"message_to_user\": message_to_user,\n                \"param_definitions\": param_definitions\n            }\n            \n            logger.info(f\"Sending command with payload keys: {sorted(command_payload.keys())}\")\n            if code:\n                logger.info(f\"Code snippet (first 50 chars): {code[:50]}...\")\n            \n            # Always use \"update_script\" as the command type\n            result = connection.send_command(\"update_script\", command_payload)\n            \n            if result.get(\"status\") == \"error\":\n                return f\"Error: {result.get('result', 'Unknown error')}\"\n            return json.dumps(result.get(\"result\", {}), indent=2)\n                \n        except Exception as e:\n            return f\"Error updating script: {str(e)}\"\n\n    def update_script_with_code_reference(self, ctx: Context, instance_guid: str = None, file_path: str = None, \n                                        param_definitions: List[Dict[str, Any]] = None, description: str = None, \n                                        name: str = None, force_code_reference: bool = False) -> str:\n        \"\"\"Grasshopper: Update a script component to use code from an external Python file.\n        This tool allows you to modify a GHPython script component to use code from an external Python file \n        instead of embedded code. This enables better code organization, version control, and reuse across \n        multiple components. Moreove, you can add and remove input/ output paramters.\n        \n        important notes:\n        1. Only use when working in/with curser or another IDE\n        2. First, check the grasshopper script component using  \"get_objects\" tool\n        3. Second, check if a python file is already referenced by the component AND if it exists in the cursor project\n            ALWAYS add the component instance_guid to the file name (e.g. cirler_creator_a1b2c3d4-e5f6-4a5b-9c8d-7e6f5d4c3b2a.py)\n        4. write code im the file and save it, update the file path with this tool\n        5. Once referenced, future updates on the code file will automatically be reflected in the component (no need to use this tool)\n        6. you can use get_objects tool to get potential error messages from the component for debugging (runtimeMessages)\n\n        Args:\n            instance_guid: The GUID of the target GHPython component to modify.\n            file_path: Path to the external Python file that contains the code.\n            param_definitions: List of dictionaries defining input/output parameters.\n            description: New description for the component.\n            name: New nickname for the component.\n            force_code_reference: When True, converts/sets a component to use referenced code mode.\n\n        Returns:\n            Success status with summary of which elements were updated and component instance_guid\n        \n        Example:\n        ```json\n        {\n            \"instance_guid\": \"a1b2c3d4-e5f6-4a5b-9c8d-7e6f5d4c3b2a\",\n            \"file_path\": \"/scripts/cirler_creator_a1b2c3d4-e5f6-4a5b-9c8d-7e6f5d4c3b2a.py\"\n            \"name\":\"CircleTool\"\n            \"description\": \"Creates a circle and outputs its geometry, center point, and area\",\n            \"message_to_user\": \"Circle, add one radius slider as input\",\n            force_code_reference = True, \n            \"param_definitions\": [\n                {\n                    \"type\": \"input\",\n                    \"name\": \"radius\",\n                    \"access\": \"item\",\n                    \"typehint\": \"float\",\n                    \"description\": \"Circle radius\",\n                    \"optional\": false,\n                    \"default\": 1.0\n                },\n                {\n                    \"type\": \"output\",\n                    \"name\": \"circle\",\n                    \"description\": \"Generated circle geometry\"\n                }\n            ]\n        }\n        ```\n        \"\"\"\n        try:\n            # Ensure we have a valid instance_guid\n            if not instance_guid:\n                return \"Error: No instance_guid provided. Please specify the GUID of the script component to update.\"\n            \n            connection = get_grasshopper_connection()\n            \n            # Prepare the command payload\n            command_payload = {\n                \"instance_guid\": instance_guid,\n                \"file_path\": file_path,\n                \"param_definitions\": param_definitions,\n                \"description\": description,\n                \"name\": name,\n                \"force_code_reference\": force_code_reference\n            }\n            \n            # Send command and get result\n            result = connection.send_command(\"update_script_with_code_reference\", command_payload)\n            \n            if result.get(\"status\") == \"error\":\n                return f\"Error: {result.get('result', 'Unknown error')}\"\n            return json.dumps(result.get(\"result\", {}), indent=2)\n                \n        except Exception as e:\n            return f\"Error updating script with code reference: {str(e)}\"\n\n    def expire_and_get_info(self, ctx: Context, instance_guid: str) -> str:\n        \"\"\"Grasshopper: Expire a specific component and get its updated information.\n\n        This is useful after updating a component's code, especially via a referenced file,\n        to force a recompute and retrieve the latest state, including potential errors or messages.\n\n        Args:\n            instance_guid: The GUID of the component to expire and query.\n\n        Returns:\n            JSON string with the component's updated information after expiration.\n        \"\"\"\n        try:\n            if not instance_guid:\n                return \"Error: No instance_guid provided. Please specify the GUID of the component to expire.\"\n\n            logger.info(f\"Expiring component and getting info for GUID: {instance_guid}\")\n            connection = get_grasshopper_connection()\n            result = connection.send_command(\"expire_component\", {\n                \"instance_guid\": instance_guid\n            })\n\n            if result.get(\"status\") == \"error\":\n                return f\"Error: {result.get('result', 'Unknown error')}\"\n            # The server side already returns component info after expiring\n            return json.dumps(result.get(\"result\", {}), indent=2)\n\n        except Exception as e:\n            return f\"Error expiring component: {str(e)}\"\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}