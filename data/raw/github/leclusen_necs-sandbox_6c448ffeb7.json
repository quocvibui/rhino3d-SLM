{
  "source_url": "https://github.com/leclusen/necs-sandbox/blob/8d8006ae3c845c9f3e38154803caac6b03d298a9/structure-batiment/structure_aligner/pipeline_v2.py",
  "repo": "leclusen/necs-sandbox",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "structure-batiment/structure_aligner/pipeline_v2.py",
  "instruction": "V2 Pipeline: end-to-end structural alignment with object-level transformations.",
  "code": "\"\"\"V2 Pipeline: end-to-end structural alignment with object-level transformations.\n\nOrchestrates all phases:\n1. Load 3dm model + DB vertices/elements\n2. Discover axis lines (Phase 2)\n3. Per-element snap alignment (Phase 3)\n4. Extract dalle/voile info before removal\n5. Object removal (Phase 4)\n6. Object addition (Phase 5)\n7. Write output 3dm\n8. Generate report\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nimport time\nfrom dataclasses import asdict, dataclass, field\nfrom datetime import datetime, timezone\nfrom pathlib import Path\n\nimport rhino3dm\n\nfrom structure_aligner.config import AlignedVertex, AxisLine, ElementInfo, PipelineConfig\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass PipelineV2Report:\n    \"\"\"Comprehensive report from a V2 pipeline run.\"\"\"\n    # Input\n    input_3dm: str = \"\"\n    input_db: str = \"\"\n    output_3dm: str = \"\"\n    timestamp: str = \"\"\n    execution_time_s: float = 0.0\n\n    # Axis lines\n    axis_lines_x_count: int = 0\n    axis_lines_y_count: int = 0\n\n    # Alignment\n    total_vertices: int = 0\n    aligned_vertices: int = 0\n    alignment_rate_pct: float = 0.0\n    max_displacement_m: float = 0.0\n\n    # Object removal\n    dalles_removed: int = 0\n    dalles_kept: int = 0\n    supports_removed: int = 0\n    voiles_removed: int = 0\n\n    # Object addition\n    dalles_consolidated: int = 0\n    voiles_simplified: int = 0\n    supports_added: int = 0\n    filaire_added: int = 0\n    grid_lines_added: int = 0\n\n    # Final model\n    final_object_count: int = 0\n\n    errors: list[str] = field(default_factory=list)\n\n\ndef run_pipeline_v2(\n    input_3dm: Path,\n    input_db: Path,\n    output_dir: Path,\n    config: PipelineConfig | None = None,\n    reference_3dm: Path | None = None,\n) -> PipelineV2Report:\n    \"\"\"Run the complete V2 pipeline.\n\n    Args:\n        input_3dm: Path to the before .3dm file.\n        input_db: Path to the structural database (.db).\n        output_dir: Output directory for results.\n        config: Pipeline configuration. Uses defaults if None.\n        reference_3dm: Optional reference .3dm for comparison.\n\n    Returns:\n        PipelineV2Report with all metrics.\n    \"\"\"\n    if config is None:\n        config = PipelineConfig()\n\n    start_time = time.time()\n    report = PipelineV2Report(\n        input_3dm=str(input_3dm),\n        input_db=str(input_db),\n        timestamp=datetime.now(timezone.utc).isoformat(),\n    )\n\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    # --- Step 1: Load model and data ---\n    logger.info(\"Step 1/8: Loading 3dm model and database\")\n    model = rhino3dm.File3dm.Read(str(input_3dm))\n    if model is None:\n        report.errors.append(f\"Failed to read 3dm file: {input_3dm}\")\n        return report\n\n    logger.info(\"  Model loaded: %d objects\", len(model.Objects))\n\n    # Load PRD database (need vertices + elements for alignment)\n    prd_db = _find_prd_db(input_db, input_3dm)\n    if prd_db is None:\n        report.errors.append(\"No PRD database found. Run ETL first.\")\n        return report\n\n    from structure_aligner.db.reader import load_vertices_with_elements\n    vertices, elements = load_vertices_with_elements(prd_db)\n    report.total_vertices = len(vertices)\n    logger.info(\"  Loaded %d vertices, %d elements\", len(vertices), len(elements))\n\n    # --- Step 2: Discover axis lines ---\n    logger.info(\"Step 2/8: Discovering axis lines\")\n    from structure_aligner.analysis.axis_selector import discover_axis_lines\n    axis_x, axis_y = discover_axis_lines(vertices, config)\n    report.axis_lines_x_count = len(axis_x)\n    report.axis_lines_y_count = len(axis_y)\n    logger.info(\"  Discovered %d X and %d Y axis lines\", len(axis_x), len(axis_y))\n\n    # --- Step 3: Per-element snap alignment ---\n    logger.info(\"Step 3/8: Aligning elements\")\n    from structure_aligner.alignment.element_aligner import align_elements\n    aligned = align_elements(vertices, elements, axis_x, axis_y, config)\n\n    aligned_count = sum(1 for av in aligned if av.aligned_axis != \"none\")\n    report.aligned_vertices = aligned_count\n    report.alignment_rate_pct = round(\n        aligned_count / len(aligned) * 100, 1\n    ) if aligned else 0.0\n    report.max_displacement_m = round(\n        max((av.displacement_total for av in aligned), default=0.0), 4\n    )\n    logger.info(\n        \"  Aligned %d/%d vertices (%.1f%%)\",\n        aligned_count, len(aligned), report.alignment_rate_pct,\n    )\n\n    # --- Step 4: Extract info before removal ---\n    logger.info(\"Step 4/8: Extracting info for object transformations\")\n    dalle_names = _load_names_by_type(input_db, \"DALLE\")\n    voile_names_set = _load_names_by_type(input_db, \"VOILE\")\n\n    from structure_aligner.transform.dalle_consolidator import extract_dalle_info\n    dalle_infos = extract_dalle_info(model, dalle_names)\n    non_roof_dalles = [d for d in dalle_infos if d.z < config.roof_z_threshold]\n\n    from structure_aligner.transform.voile_simplifier import extract_voile_extents\n    # We'll identify multi-face voiles first\n    multiface_voile_names = _identify_multiface_voiles(model, voile_names_set)\n    voile_extents = extract_voile_extents(model, multiface_voile_names)\n\n    logger.info(\n        \"  Extracted %d dalle infos, %d voile extents\",\n        len(dalle_infos), len(voile_extents),\n    )\n\n    # --- Step 5: Object removal ---\n    logger.info(\"Step 5/8: Removing objects\")\n    from structure_aligner.transform.object_rules import (\n        remove_dalles,\n        remove_multiface_voiles,\n        remove_obsolete_supports,\n    )\n\n    dalles_removed, dalles_kept = remove_dalles(model, input_db, config)\n    report.dalles_removed = dalles_removed\n    report.dalles_kept = dalles_kept\n\n    supports_removed = remove_obsolete_supports(model, input_db)\n    report.supports_removed = supports_removed\n\n    removed_voiles = remove_multiface_voiles(model, input_db)\n    report.voiles_removed = len(removed_voiles)\n\n    logger.info(\n        \"  Removed: %d dalles, %d supports, %d voiles\",\n        dalles_removed, supports_removed, len(removed_voiles),\n    )\n\n    # --- Step 6: Object addition ---\n    logger.info(\"Step 6/8: Adding objects\")\n    from structure_aligner.transform.dalle_consolidator import consolidate_dalles\n    dalles_consolidated = consolidate_dalles(\n        model, non_roof_dalles, config.floor_z_levels\n    )\n    report.dalles_consolidated = dalles_consolidated\n\n    from structure_aligner.transform.voile_simplifier import simplify_voiles\n    voiles_simplified = simplify_voiles(model, voile_extents, config.floor_z_levels)\n    report.voiles_simplified = voiles_simplified\n\n    from structure_aligner.transform.support_placer import (\n        place_support_points_at_columns,\n    )\n    # Place supports at column center positions snapped to nearest axis\n    # intersection, avoiding the O(X*Y) grid scan with over-discovered axes.\n    existing_columns = _build_column_positions(vertices, elements)\n    logger.info(\"  Column centers: %d unique positions\", len(existing_columns))\n    supports_added, support_positions = place_support_points_at_columns(\n        model, existing_columns, axis_x, axis_y,\n        support_z_levels=(2.12, -4.44),\n    )\n    report.supports_added = supports_added\n\n    from structure_aligner.transform.filaire_generator import generate_filaire\n    filaire_added = generate_filaire(model, support_positions, config.floor_z_levels)\n    report.filaire_added = filaire_added\n\n    from structure_aligner.transform.grid_lines import generate_grid_lines\n\n    # Compute X extent from axis lines\n    if axis_x:\n        x_min = min(al.position for al in axis_x)\n        x_max = max(al.position for al in axis_x)\n    else:\n        x_min, x_max = -75.0, 5.0  # fallback\n\n    grid_added = generate_grid_lines(model, axis_y, x_extent=(x_min, x_max))\n    report.grid_lines_added = grid_added\n\n    logger.info(\n        \"  Added: %d dalles, %d voiles, %d supports, %d filaire, %d grid lines\",\n        dalles_consolidated, voiles_simplified, supports_added,\n        filaire_added, grid_added,\n    )\n\n    # --- Step 7: Apply vertex alignment to 3dm model ---\n    # Safe ordering: Phase 4/5 only remove/add whole objects, never modify\n    # surviving objects. So vertex indices from Phase 3 alignment remain valid.\n    logger.info(\"Step 7/8: Applying vertex alignment to 3dm model\")\n    vertices_updated = _apply_alignment_to_model(model, aligned, elements)\n    logger.info(\"  Updated %d vertices in 3dm model\", vertices_updated)\n\n    # --- Step 8: Write output ---\n    logger.info(\"Step 8/8: Writing output\")\n    output_3dm = output_dir / \"aligned_v2.3dm\"\n    model.Write(str(output_3dm), version=7)\n    report.output_3dm = str(output_3dm)\n    report.final_object_count = len(model.Objects)\n\n    # Write report\n    report.execution_time_s = round(time.time() - start_time, 2)\n    report_path = output_dir / \"pipeline_v2_report.json\"\n    _write_report(report, report_path)\n\n    logger.info(\"Pipeline V2 complete in %.1fs\", report.execution_time_s)\n    logger.info(\"  Output: %s\", output_3dm)\n    logger.info(\"  Report: %s\", report_path)\n    logger.info(\"  Final model: %d objects\", report.final_object_count)\n\n    return report\n\n\n# =========================================================================\n# Internal helpers\n# =========================================================================\n\n\ndef _build_column_positions(\n    vertices: list,\n    elements: dict[int, ElementInfo],\n) -> dict[tuple[float, float], bool]:\n    \"\"\"Build column (x, y) center positions from poteau/appui elements.\n\n    Computes the centroid of each column/appui element's vertices,\n    returning one (x, y) position per element.\n    \"\"\"\n    from collections import defaultdict\n\n    column_types = {\"poteau\", \"appui\"}\n    column_element_ids = {\n        eid for eid, elem in elements.items() if elem.type in column_types\n    }\n    # Group vertices by element\n    by_elem: dict[int, list[tuple[float, float]]] = defaultdict(list)\n    for v in vertices:\n        if v.element_id in column_element_ids:\n            by_elem[v.element_id].append((v.x, v.y))\n\n    # Use centroid of each element\n    positions: dict[tuple[float, float], bool] = {}\n    for eid, coords in by_elem.items():\n        cx = round(sum(c[0] for c in coords) / len(coords), 2)\n        cy = round(sum(c[1] for c in coords) / len(coords), 2)\n        positions[(cx, cy)] = True\n    return positions\n\n\ndef _find_prd_db(input_db: Path, input_3dm: Path) -> Path | None:\n    \"\"\"Find the PRD database, either alongside input_db or generated by ETL.\"\"\"\n    # Check for *_prd.db alongside the structural DB\n    prd_path = input_db.with_name(f\"{input_db.stem}_prd.db\")\n    if prd_path.exists():\n        return prd_path\n\n    # Check in data/input/ â€” pick most recently modified if multiple exist\n    data_dir = input_3dm.parent\n    candidates = sorted(data_dir.glob(\"*_prd.db\"), key=lambda p: p.stat().st_mtime, reverse=True)\n    if candidates:\n        return candidates[0]\n\n    return None\n\n\ndef _load_names_by_type(db_path: Path, element_type: str) -> set[str]:\n    \"\"\"Load element names from the shell table.\n\n    Delegates to object_rules._load_names_by_type which includes\n    OperationalError handling for missing tables.\n    \"\"\"\n    from structure_aligner.transform.object_rules import (\n        _load_names_by_type as _load_impl,\n    )\n    return _load_impl(db_path, element_type)\n\n\ndef _identify_multiface_voiles(\n    model: rhino3dm.File3dm,\n    voile_names: set[str],\n    min_faces: int = 2,\n) -> list[str]:\n    \"\"\"Find multi-face voile names without removing them.\"\"\"\n    result = []\n    for obj in model.Objects:\n        name = obj.Attributes.Name\n        if name not in voile_names:\n            continue\n        geom = obj.Geometry\n        if isinstance(geom, rhino3dm.Brep) and len(geom.Faces) >= min_faces:\n            result.append(name)\n    return result\n\n\ndef _apply_alignment_to_model(\n    model: rhino3dm.File3dm,\n    aligned_vertices: list[AlignedVertex],\n    elements: dict[int, ElementInfo],\n) -> int:\n    \"\"\"Apply aligned vertex coordinates back to the 3dm model objects.\n\n    Maps aligned vertices back to named objects by element_id -> element name,\n    then updates the Brep/curve/point vertex positions in-place.\n\n    Note: For Breps, modifying Vertices[i].Location updates the control point\n    but does not automatically recompute edges/faces/trims. This is acceptable\n    for the small displacements typical of structural alignment (<1m). For\n    large displacements, Brep topology may become invalid.\n    \"\"\"\n    from collections import defaultdict\n    by_name: dict[str, list] = defaultdict(list)\n    for av in aligned_vertices:\n        elem = elements.get(av.element_id)\n        if elem:\n            by_name[elem.name].append(av)\n\n    updated = 0\n    for obj in model.Objects:\n        name = obj.Attributes.Name\n        if not name or name not in by_name:\n            continue\n\n        verts = sorted(by_name[name], key=lambda v: v.vertex_index)\n        geom = obj.Geometry\n\n        if isinstance(geom, rhino3dm.Brep):\n            for av in verts:\n                if av.vertex_index < len(geom.Vertices):\n                    geom.Vertices[av.vertex_index].Location = rhino3dm.Point3d(\n                        av.x, av.y, av.z\n                    )\n                    updated += 1\n        elif isinstance(geom, rhino3dm.LineCurve):\n            for av in verts:\n                if av.vertex_index == 0:\n                    geom.SetStartPoint(rhino3dm.Point3d(av.x, av.y, av.z))\n                    updated += 1\n                elif av.vertex_index == 1:\n                    geom.SetEndPoint(rhino3dm.Point3d(av.x, av.y, av.z))\n                    updated += 1\n        elif isinstance(geom, rhino3dm.PolylineCurve):\n            for av in verts:\n                if av.vertex_index < geom.PointCount:\n                    geom.SetPoint(av.vertex_index, rhino3dm.Point3d(av.x, av.y, av.z))\n                    updated += 1\n        elif isinstance(geom, rhino3dm.NurbsCurve):\n            for av in verts:\n                if av.vertex_index < len(geom.Points):\n                    geom.Points[av.vertex_index] = rhino3dm.Point4d(\n                        av.x, av.y, av.z, 1.0\n                    )\n                    updated += 1\n        elif isinstance(geom, rhino3dm.Point):\n            for av in verts:\n                if av.vertex_index == 0:\n                    geom.Location = rhino3dm.Point3d(av.x, av.y, av.z)\n                    updated += 1\n\n    return updated\n\n\ndef _write_report(report: PipelineV2Report, path: Path) -> None:\n    \"\"\"Write pipeline report as JSON.\"\"\"\n    data = asdict(report)\n    with open(path, \"w\") as f:\n        json.dump(data, f, indent=2)\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}