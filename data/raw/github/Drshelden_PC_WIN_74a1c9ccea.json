{
  "source_url": "https://github.com/Drshelden/PC_WIN/blob/970475e6bbc3f0d6248ce4ad1fc323157dd4195e/tests/pcl_hybrid/rhino_client.py",
  "repo": "Drshelden/PC_WIN",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "tests/pcl_hybrid/rhino_client.py",
  "instruction": "Rhino 3D Point Cloud Processing Client\nIntegrates with PCL+CGAL headless processor via WSL",
  "code": "#!/usr/bin/env python3\n# r: numpy\n\"\"\"\nRhino 3D Point Cloud Processing Client\nIntegrates with PCL+CGAL headless processor via WSL\n\nThis script runs inside Rhinoceros 3D and allows users to:\n1. Select point cloud objects from the Rhino scene\n2. Process them using competitive shape detection (planes, cylinders, cones, torus)\n3. Display results back in Rhino as geometry and annotations\n\nRequirements:\n- Rhinoceros 3D with Python scripting\n- WSL Ubuntu with PCL headless processor built\n- Point cloud objects in Rhino scene\n\"\"\"\n\nimport rhinoscriptsyntax as rs\nimport Rhino\nimport Rhino.Geometry as rg\nfrom Rhino.Geometry import Point3d, Vector3d, PointCloud, Plane, Circle, LineCurve, PlaneSurface, Cylinder, Cone, NurbsSurface, PolylineCurve, BoundingBox\nimport System\nimport json\nimport os\nimport subprocess\nimport time\nimport tempfile\nimport shutil\nimport random\nfrom System.Drawing import Color\nimport scriptcontext\ntry:\n    import numpy as np\nexcept Exception:\n    np = None\n\nmin_points_for_shape = 100  # Minimum points required to visualize a shape\n\n# Ensure Release build folder and vcpkg bin are on PATH and sys.path at import time\ntry:\n    import sys\n    _br = os.path.abspath(os.path.join(os.path.dirname(__file__), 'build_py39', 'Release'))\n    _vcpkg_bin = r'C:\\vcpkg\\installed\\x64-windows\\bin'\n    if os.path.isdir(_br):\n        os.environ['PATH'] = _br + os.pathsep + _vcpkg_bin + os.pathsep + os.environ.get('PATH', '')\n        if _br not in sys.path:\n            sys.path.insert(0, _br)\n    else:\n        # try older build location\n        _alt = os.path.abspath(os.path.join(os.path.dirname(__file__), 'build', 'Debug'))\n        if os.path.isdir(_alt) and _alt not in sys.path:\n            sys.path.insert(0, _alt)\n            \n    # Initialize logging and settings for PCL hybrid processing\n    try:\n        import pcl_hybrid_py as ph\n        \n        # Initialize logging\n        if hasattr(ph, 'initialize_logging'):\n            script_dir = os.path.dirname(os.path.abspath(__file__))\n            log_path = os.path.join(script_dir, 'data', 'log.txt')\n            os.makedirs(os.path.dirname(log_path), exist_ok=True)\n            success = ph.initialize_logging(log_path)\n            if success and hasattr(ph, 'log_message'):\n                ph.log_message(\"Rhino client initialized\")\n        \n        # Load settings\n        if hasattr(ph, 'load_settings_from_file'):\n            settings_path = r\"C:\\Temp\\pcl_processing\\settings.json\"\n            success = ph.load_settings_from_file(settings_path)\n            if success and hasattr(ph, 'log_message'):\n                ph.log_message(f\"Settings loaded from {settings_path}\")\n                \n    except Exception as e:\n        # Don't prevent module loading if PCL hybrid is not available\n        print(f\"PCL hybrid initialization failed: {e}\")\n        \nexcept Exception:\n    # Do not prevent Rhino from importing this module if PATH tweak fails\n    pass\n\nclass RhinoPointCloudProcessor:\n\n    def __init__(self, wsl_script_path=\"/mnt/c/_LOCAL/GitHub/PC_WIN/tests/pcl_hybrid/process_wsl.sh\"):\n        self.wsl_script_path = wsl_script_path\n        # Use Windows temp directory for communication with WSL\n        self.windows_input_dir = r\"C:\\temp\\pcl_processing\"\n        # Expect the WSL processor to write ./data/ws_output.json under the WSL project folder\n        # Map that to the Windows-accessible path via the WSL UNC share\n        self.windows_output_dir = \"\\\\\\\\wsl.localhost\\\\Ubuntu\\\\home\\\\sheldd\\\\pcl\\\\pcl_win\\\\data\"\n        self.input_file = os.path.join(self.windows_input_dir, \"ws_input.xyz\")  # Changed to XYZ\n        self.output_file = os.path.join(self.windows_output_dir, \"ws_output.json\")\n        \n        # Create input directory if it doesn't exist\n        if not os.path.exists(self.windows_input_dir):\n            os.makedirs(self.windows_input_dir)\n    \n    def select_point_cloud(self):\n        \"\"\"Allow user to select a point cloud object in Rhino\"\"\"\n        print(\"Please select a point cloud object...\")\n        \n        # Filter for point cloud objects\n        filter = Rhino.DocObjects.ObjectType.PointSet\n        rc, objref = Rhino.Input.RhinoGet.GetOneObject(\"Select point cloud\", False, filter)\n        \n        if rc != Rhino.Commands.Result.Success:\n            print(\"No point cloud selected or operation cancelled.\")\n            return None\n            \n        # Get the point cloud geometry\n        pointcloud = objref.Geometry()\n        if not isinstance(pointcloud, rg.PointCloud):\n            print(\"Selected object is not a point cloud.\")\n            return None\n\n        print(\"Selected point cloud with \" + str(pointcloud.Count) + \" points\")\n        return pointcloud, objref.ObjectId\n    \n    def pointcloud_to_list(self, pointcloud):\n        \"\"\"Convert Rhino PointCloud to list of [x,y,z] coordinates\"\"\"\n        points = []\n        for i in range(pointcloud.Count):\n            pt = pointcloud[i].Location\n            points.append([float(pt.X), float(pt.Y), float(pt.Z)])\n        return points\n    \n    def process_pointcloud(self, points, solver_type=\"BEST\"):\n        \"\"\"\n        Process the point cloud using the built Windows Release Python bindings directly\n        (pcl_hybrid_py). This avoids calling a WSL script and runs ShapeFinder in-process.\n        Returns the same dict format as `extract_shapes_from_points` used elsewhere.\n        \"\"\"\n        print(\"Processing \" + str(len(points)) + \" points via local bindings...\")\n        # Ensure Release build and vcpkg bins are on PATH and sys.path so imports and DLL loading succeed\n        try:\n            import sys\n            import glob\n            import importlib\n            # Guarded imports: some embedded Pythons (Rhino) lack importlib.util or importlib.machinery\n            try:\n                import importlib.util as _importlib_util\n            except Exception:\n                _importlib_util = None\n            try:\n                import importlib.machinery as _importlib_machinery\n            except Exception:\n                _importlib_machinery = None\n\n            br = os.path.abspath(os.path.join(os.path.dirname(__file__), 'build_py39', 'Release'))\n            vcpkg_bin = r'C:\\vcpkg\\installed\\x64-windows\\bin'\n\n            # Candidate directories to probe for the compiled extension\n            candidate_dirs = [\n                br,\n                os.path.abspath(os.path.join(os.path.dirname(__file__), 'build_py39', 'Debug')),\n                os.path.abspath(os.path.join(os.path.dirname(__file__), 'build', 'Debug')),\n                os.path.abspath(os.path.join(os.path.dirname(__file__), 'build', 'Release')),\n            ]\n\n            for d in candidate_dirs:\n                if os.path.isdir(d):\n                    os.environ['PATH'] = d + os.pathsep + vcpkg_bin + os.pathsep + os.environ.get('PATH', '')\n                    if d not in sys.path:\n                        sys.path.insert(0, d)\n\n            # Try normal import first\n            try:\n                import pcl_hybrid_py as ph\n            except Exception:\n                # If normal import failed, try to find a matching .pyd and load it directly\n                pyd_paths = []\n                for d in candidate_dirs:\n                    try:\n                        pyd_paths.extend(glob.glob(os.path.join(d, 'pcl_hybrid_py*.pyd')))\n                    except Exception:\n                        pass\n\n                # fallback: recursive search inside the module folder\n                if not pyd_paths:\n                    pyd_paths = glob.glob(os.path.join(os.path.dirname(__file__), '**', 'pcl_hybrid_py*.pyd'), recursive=True)\n\n                if pyd_paths:\n                    pyd = pyd_paths[0]\n                    try:\n                        # Try using importlib.machinery.ExtensionFileLoader where available\n                        loader = None\n                        if _importlib_machinery is not None:\n                            loader = _importlib_machinery.ExtensionFileLoader('pcl_hybrid_py', pyd)\n                        # Some embedded Python runtimes (older Rhino/Python) may not expose importlib.util\n                        if loader is not None and _importlib_util is not None:\n                            spec = _importlib_util.spec_from_loader(loader.name, loader)\n                            ph = _importlib_util.module_from_spec(spec)\n                            loader.exec_module(ph)\n                            sys.modules['pcl_hybrid_py'] = ph\n                        else:\n                            # Fallback for older runtimes: try imp.load_dynamic\n                            try:\n                                import imp\n                                ph = imp.load_dynamic('pcl_hybrid_py', pyd)\n                                sys.modules['pcl_hybrid_py'] = ph\n                            except Exception:\n                                # Last resort: insert directory to sys.path and use normal import\n                                ddir = os.path.dirname(pyd)\n                                if ddir not in sys.path:\n                                    sys.path.insert(0, ddir)\n                                ph = __import__('pcl_hybrid_py')\n                    except Exception as e:\n                        raise ImportError('Failed to load pcl_hybrid_py from \"' + pyd + '\": ' + str(e))\n                else:\n                    raise ImportError('pcl_hybrid_py compiled extension not found in candidate build directories')\n        except Exception as e:\n            error_msg = 'Failed to import Release bindings (pcl_hybrid_py): ' + str(e)\n            print(error_msg)\n            return {\"error\": error_msg}\n\n        # create a PCWin_PointCloud and import points from an in-memory float32 buffer (x,y,z...)\n        try:\n            pc = ph.PCWin_PointCloud()\n\n            # Try to use numpy for efficient buffer construction; fall back to array\n            buf = None\n            try:\n                import numpy as np\n                arr = np.asarray(points, dtype=np.float32)\n                if arr.ndim == 2 and arr.shape[1] >= 3:\n                    flat = arr[:, :3].reshape(-1)\n                else:\n                    flat = arr.reshape(-1)\n                buf = flat\n            except Exception:\n                # fallback: use array('f')\n                from array import array\n                a = array('f')\n                for p in points:\n                    a.append(float(p[0])); a.append(float(p[1])); a.append(float(p[2]))\n                buf = memoryview(a)\n\n            # pybind11 binding expects a single buffer argument; the C++ side determines point count\n            rc = pc.importPointsFromBuffer(buf)\n            if rc != 0:\n                return {\"error\": \"importPointsFromBuffer failed with code \" + str(rc)}\n        except Exception as e:\n            return {\"error\": \"Failed to import points into PCWin_PointCloud: \" + str(e)}\n\n        # run shape finding\n        try:\n            sf = ph.ShapeFinder()\n            print(\"Calling ShapeFinder.findShapes(pc)...\")\n            sf.findShapes(pc)\n        except Exception as e:\n            error_msg = \"ShapeFinder failed: \" + str(e)\n            print(error_msg)\n            return {\"error\": error_msg}\n\n        # First try: traverse the Shape tree directly via the ShapeFinder bindings\n        try:\n            get_root_shape = getattr(sf, 'get_root_shape', None)\n            if callable(get_root_shape):\n                root = get_root_shape()\n                if root is not None:\n                    results_from_shapes = {'planes': [], 'cylinders': []}\n\n                    def walk_shape(node):\n                        try:\n                            ntype = node.get_type().lower()\n                        except Exception:\n                            ntype = ''\n\n                        # coefficients (if available)\n                        coeffs = None\n                        try:\n                            if hasattr(node, 'get_coefficients'):\n                                coeffs = node.get_coefficients()\n                        except Exception:\n                            coeffs = None\n\n                        # critical points (numpy array or list)\n                        cps = []\n                        try:\n                            if hasattr(node, 'get_critical_points_array'):\n                                cp = node.get_critical_points_array()\n                                if np is not None and hasattr(cp, 'tolist'):\n                                    cps = cp.tolist()\n                                else:\n                                    # fallback: attempt list conversion\n                                    try:\n                                        cps = list(map(list, cp))\n                                    except Exception:\n                                        cps = []\n                        except Exception:\n                            cps = []\n\n                        # shape points (prefer numpy array when available)\n                        pts = []\n                        try:\n                            if hasattr(node, 'get_points_array'):\n                                pa = node.get_points_array()\n                                if np is not None and hasattr(pa, 'tolist'):\n                                    # keep numpy array available for downstream use, but also\n                                    # produce a Python list for Rhino geometry creation\n                                    pts = pa.tolist()\n                                else:\n                                    try:\n                                        pts = list(map(list, pa))\n                                    except Exception:\n                                        pts = []\n                        except Exception:\n                            pts = []\n\n                        entry = {\n                            'coefficients': coeffs,\n                            'critical_points': cps,\n                            'shape_points': pts,\n                            'cluster_id': None\n                        }\n\n                        if 'plane' in ntype:\n                            results_from_shapes['planes'].append(entry)\n                        elif 'cylinder' in ntype:\n                            results_from_shapes['cylinders'].append(entry)\n\n                        # recurse children\n                        try:\n                            children = node.get_children() or []\n                            for c in children:\n                                walk_shape(c)\n                        except Exception:\n                            pass\n\n                    walk_shape(root)\n                    return results_from_shapes\n        except Exception:\n            # If anything fails, fall back to the JSON path below\n            pass\n\n        # Fallback: use get_root_json() as the single source of truth for shapes\n        try:\n            get_root_json = getattr(sf, 'get_root_json', None)\n            if not callable(get_root_json):\n                return {'planes': [], 'cylinders': []}\n\n            raw = get_root_json()\n            if isinstance(raw, bytes):\n                raw = raw.decode('utf-8', errors='replace')\n            parsed = json.loads(raw)\n\n            # convert parsed GenericShape tree into flat results dict\n            results_from_json = {'planes': [], 'cylinders': []}\n\n            def walk_json(node):\n                if not isinstance(node, dict):\n                    return\n                typ = node.get('type', '').lower()\n                coeffs = node.get('coefficients') or node.get('coeff') or node.get('coefs') or None\n                cps = node.get('critical_points') or node.get('criticalPoints') or node.get('critical') or []\n                pts = node.get('points') or node.get('shape_points') or node.get('shapePoints') or []\n                entry = {\n                    'coefficients': coeffs,\n                    'critical_points': cps,\n                    'shape_points': pts,\n                    'cluster_id': node.get('cluster_id') or node.get('cluster') or None\n                }\n                if 'plane' in typ:\n                    results_from_json['planes'].append(entry)\n                elif 'cylinder' in typ:\n                    results_from_json['cylinders'].append(entry)\n                for c in node.get('children', []) or []:\n                    walk_json(c)\n\n            if isinstance(parsed, dict) and 'children' in parsed:\n                for c in parsed.get('children', []) or []:\n                    walk_json(c)\n            else:\n                walk_json(parsed)\n\n            return results_from_json\n        except Exception:\n            return {'planes': [], 'cylinders': []}\n    \n    def visualize_plane(self, coefficients, critical_points, shape_points, cluster_id, i):\n        if len(shape_points) < min_points_for_shape:\n            print(\"  Skipping plane visualization due to insufficient points (\" + str(len(shape_points)) + \" < \" + str(min_points_for_shape) + \")\")\n            return\n        shape_type=\"plane\"\n        created = []\n        if len(shape_points) > 0:\n            # color will be assigned by caller based on plane_label\n            point_cloud_guid = self.add_pointcloud_to_rhino(shape_points, \"plane\", cluster_id, i)\n            if point_cloud_guid:\n                created.append(point_cloud_guid)\n                #print(\"  Added \" + str(shape_type) + \" point cloud to Rhino (\" + str(len(shape_points)) + \" points)\")\n\n        \"\"\"Create transparent plane surface and yellow boundary polygon from critical points\"\"\"\n        if not critical_points or len(critical_points) < 3:\n            print(\"Error: Not enough critical points for plane\")\n            return \n            \n        # Handle both old array format and new named dictionary format for coefficients\n        if isinstance(coefficients, dict):\n            if not all(key in coefficients for key in [\"nx\", \"ny\", \"nz\", \"d\"]):\n                print(\"Error: Missing required plane coefficients (nx, ny, nz, d)\")\n                return \n            nx, ny, nz, d = coefficients[\"nx\"], coefficients[\"ny\"], coefficients[\"nz\"], coefficients[\"d\"]\n        elif isinstance(coefficients, (list, tuple)) and len(coefficients) >= 4:\n            nx, ny, nz, d = coefficients[:4]\n        else:\n            print(\"Error: Invalid plane coefficients format\")\n            return \n            \n        # Create points from critical points\n        rhino_points = []\n        for pt in critical_points:\n            rhino_points.append(rg.Point3d(pt[0], pt[1], pt[2]))\n        \n        # Create boundary polyline (convex hull boundary)\n        if len(rhino_points) >= 3:\n            # Close the polygon by adding the first point at the end\n            closed_points = rhino_points + [rhino_points[0]]\n            boundary_polyline = rg.Polyline(closed_points)\n            boundary_curve = boundary_polyline.ToNurbsCurve()\n            \n            # Create plane surface by extruding the boundary slightly\n            normal = rg.Vector3d(nx, ny, nz)\n            normal.Unitize()\n            \n            # Create planar surface from the boundary curve\n            breps = rg.Brep.CreatePlanarBreps([boundary_curve], 0.001)\n            if breps and len(breps) > 0:\n                plane_surface = breps[0]\n                if plane_surface:\n                    # Add transparent white plane surface\n                    surface_guid = scriptcontext.doc.Objects.AddBrep(plane_surface)\n                    if surface_guid:\n                        created.append(surface_guid)\n                        rs.ObjectColor(surface_guid, Color.White)\n                        rs.ObjectMaterialIndex(surface_guid, -1)  # Use default material\n                        # Make transparent (this might need to be done differently in Rhino)\n                        cluster_str = str(cluster_id)\n                        count_str = str(i)\n                        rs.ObjectName(surface_guid, \"Plane_Cluster\" + cluster_str + \"_Shape\" + count_str + \"_Surface\")\n                        #print(\"  Added plane surface\")\n            \n                if boundary_curve:\n                    # Add boundary curve colored according to plane label (caller will recolor the point cloud)\n                    boundary_guid = scriptcontext.doc.Objects.AddCurve(boundary_curve)\n                    if boundary_guid:\n                        created.append(boundary_guid)\n                        # default yellow if caller doesn't change it\n                        rs.ObjectColor(boundary_guid, Color.Yellow)\n                        rs.ObjectPrintWidth(boundary_guid, 0.01)  # 1px width\n                        cluster_str = str(cluster_id)\n                        count_str = str(i)\n                        rs.ObjectName(boundary_guid, \"Plane_Cluster\" + cluster_str + \"_Shape\" + count_str + \"_Boundary\")\n                        #print(\"  Added plane boundary\")\n\n        return created\n    \n    def visualize_cylinder(self, coefficients, critical_points, shape_points, cluster_id, i):\n        if len(shape_points) < min_points_for_shape:\n            print(\"  Skipping cylinder visualization due to insufficient points (\" + str(len(shape_points)) + \" < \" + str(min_points_for_shape) + \")\")\n            return\n        shape_type=\"cylider\"\n        created = []\n        if len(shape_points) > 0:\n            # color will be assigned by caller based on cylinder_label\n            point_cloud_guid = self.add_pointcloud_to_rhino(shape_points, \"cylinder\", cluster_id, i)\n            if point_cloud_guid:\n                created.append(point_cloud_guid)\n                #print(\"  Added \" + str(shape_type) + \" point cloud to Rhino (\" + str(len(shape_points)) + \" points)\")\n\n        \"\"\"Create transparent cylinder surface and red axis line from critical points\"\"\"\n        if not critical_points or len(critical_points) != 2:\n            print(\"Error: Need exactly 2 critical points for cylinder\")\n            return None, None\n            \n        # Handle both old array format and new named dictionary format for coefficients\n        if isinstance(coefficients, dict):\n            required_keys = [\"px\", \"py\", \"pz\", \"dx\", \"dy\", \"dz\", \"radius\"]\n            if not all(key in coefficients for key in required_keys):\n                print(\"Error: Missing required cylinder coefficients\")\n                return None, None\n            radius = coefficients[\"radius\"]\n        elif isinstance(coefficients, (list, tuple)) and len(coefficients) >= 7:\n            radius = coefficients[6]\n        else:\n            print(\"Error: Invalid cylinder coefficients format\")\n            return None, None\n            \n        # Critical points are P1 and P2 (cylinder ends)\n        p1 = rg.Point3d(critical_points[0][0], critical_points[0][1], critical_points[0][2])\n        p2 = rg.Point3d(critical_points[1][0], critical_points[1][1], critical_points[1][2])\n        \n        # Create axis line\n        axis_line = rg.Line(p1, p2)\n        axis_curve = axis_line.ToNurbsCurve()\n        \n        # Create cylinder surface\n        axis_vector = p2 - p1\n        axis_vector.Unitize()\n        \n        # Create plane at P1 perpendicular to axis\n        base_plane = rg.Plane(p1, axis_vector)\n        circle = rg.Circle(base_plane, radius)\n        \n        # Create cylinder by extruding circle\n        height = p1.DistanceTo(p2)\n        cylinder = rg.Cylinder(circle, height)\n        cylinder_surface = cylinder.ToBrep(True, True)\n           \n        if cylinder_surface:\n            # Add transparent white cylinder surface\n            surface_guid = scriptcontext.doc.Objects.AddBrep(cylinder_surface)\n            if surface_guid:\n                created.append(surface_guid)\n                rs.ObjectColor(surface_guid, Color.White)\n                cluster_str = str(cluster_id)\n                count_str = str(i)\n                rs.ObjectName(surface_guid, \"Cylinder_Cluster\" + cluster_str + \"_Shape\" + count_str + \"_Surface\")\n                #print(\"  Added cylinder surface\")\n        \n        if axis_curve:\n            # Add thick red axis line\n            axis_guid = scriptcontext.doc.Objects.AddCurve(axis_curve)\n            if axis_guid:\n                created.append(axis_guid)\n                rs.ObjectColor(axis_guid, Color.Red)\n                rs.ObjectPrintWidth(axis_guid, 2.0)  # Thick line\n                cluster_str = str(cluster_id)\n                count_str = str(i)\n                rs.ObjectName(axis_guid, \"Cylinder_Cluster\" + cluster_str + \"_Shape\" + count_str + \"_Axis\")\n                #print(\"  Added cylinder axis\")\n\n        return created\n    \n    def visualize_cone(self, coefficients, critical_points, shape_points, cluster_id, i):\n        shape_type=\"cone\"\n        if len(shape_points) > 0:\n            point_cloud_guid = self.add_pointcloud_to_rhino(shape_points, \"cone\", cluster_id, i)\n            #if point_cloud_guid:\n                # created_objects.append(guid)\n                #print(\"  Added \" + str(shape_type) + \" point cloud to Rhino (\" + str(len(shape_points)) + \" points)\")\n\n        \"\"\"Create transparent cone surface and red axis line from critical points\"\"\"\n        if not critical_points or len(critical_points) != 2:\n            print(\"Error: Need exactly 2 critical points for cone\")\n            return None, None\n            \n        # Handle both old array format and new named dictionary format for coefficients  \n        if isinstance(coefficients, dict):\n            required_keys = [\"apex_x\", \"apex_y\", \"apex_z\", \"dx\", \"dy\", \"dz\", \"angle\"]\n            if not all(key in coefficients for key in required_keys):\n                print(\"Error: Missing required cone coefficients\")\n                return None, None\n            apex_x, apex_y, apex_z = coefficients[\"apex_x\"], coefficients[\"apex_y\"], coefficients[\"apex_z\"]\n            dx, dy, dz = coefficients[\"dx\"], coefficients[\"dy\"], coefficients[\"dz\"]\n            angle = coefficients[\"angle\"]\n        elif isinstance(coefficients, (list, tuple)) and len(coefficients) >= 7:\n            apex_x, apex_y, apex_z, dx, dy, dz, angle = coefficients[:7]\n        else:\n            print(\"Error: Invalid cone coefficients format\")\n            return None, None\n            \n        # Critical points are P1 and P2 (cone ends along axis)\n        p1 = rg.Point3d(critical_points[0][0], critical_points[0][1], critical_points[0][2])\n        p2 = rg.Point3d(critical_points[1][0], critical_points[1][1], critical_points[1][2])\n        \n        # Create axis line\n        axis_line = rg.Line(p1, p2)\n        axis_curve = axis_line.ToNurbsCurve()\n        \n        # Create cone surface\n        apex = rg.Point3d(apex_x, apex_y, apex_z)\n        axis_vector = rg.Vector3d(dx, dy, dz)\n        axis_vector.Unitize()\n        \n        # Find which critical point is farther from apex to use as base\n        dist1 = apex.DistanceTo(p1)\n        dist2 = apex.DistanceTo(p2)\n        \n        if dist1 > dist2:\n            base_center = p1\n            height = dist1\n        else:\n            base_center = p2  \n            height = dist2\n            \n        # Calculate base radius using cone angle and height\n        base_radius = height * abs(rg.RhinoMath.Tan(angle))\n        \n        # Create cone\n        base_plane = rg.Plane(base_center, axis_vector)\n        cone = rg.Cone(base_plane, height, base_radius)\n        cone_surface = cone.ToBrep(True)\n        \n        if cone_surface:\n            # Add transparent white cone surface\n            surface_guid = scriptcontext.doc.Objects.AddBrep(cone_surface)\n            if surface_guid:\n                rs.ObjectColor(surface_guid, Color.White)\n                rs.ObjectName(surface_guid, \"Cone_Cluster\" + str(cluster_id) + \"_Shape\" + str(i+1) + \"_Surface\")\n                # created_objects.append(surface_guid)\n                print(\"  Added cone surface\")\n        \n        if axis_curve:\n            # Add thick red axis line\n            axis_guid = scriptcontext.doc.Objects.AddCurve(axis_curve)\n            if axis_guid:\n                rs.ObjectColor(axis_guid, Color.Red)\n                rs.ObjectPrintWidth(axis_guid, 2.0)  # Thick line\n                rs.ObjectName(axis_guid, \"Cone_Cluster\" + str(cluster_id) + \"_Shape\" + str(i+1) + \"_Axis\")\n                # created_objects.append(axis_guid)\n                print(\"  Added cone axis\")\n\n    def visualize_torus(self, coefficients, critical_points, shape_points, cluster_id, i):\n        shape_type=\"torus\"\n        if len(shape_points) > 0:\n            point_cloud_guid = self.add_pointcloud_to_rhino(shape_points, \"torus\", cluster_id, i)\n            #if point_cloud_guid:\n                # created_objects.append(guid)\n                #print(\"  Added \" + str(shape_type) + \" point cloud to Rhino (\" + str(len(shape_points)) + \" points)\")\n\n        try:\n            # Get torus parameters using create_torus_geometry logic\n            if isinstance(coefficients, dict):\n                center_x, center_y, center_z = coefficients[\"center_x\"], coefficients[\"center_y\"], coefficients[\"center_z\"]\n                nx, ny, nz = coefficients[\"nx\"], coefficients[\"ny\"], coefficients[\"nz\"]\n                major_radius = coefficients[\"major_radius\"]\n            elif isinstance(coefficients, (list, tuple)) and len(coefficients) >= 8:\n                center_x, center_y, center_z, nx, ny, nz, major_radius, _ = coefficients[:8]\n            else:\n                raise Exception(\"Invalid torus coefficients format\")\n            center = rg.Point3d(center_x, center_y, center_z)\n            normal = rg.Vector3d(nx, ny, nz)\n            normal.Unitize()\n            torus_plane = rg.Plane(center, normal)\n            # Loop through all torus fitted points\n            # Assign the three critical points to pt1, pt2, pt3\n            if len(critical_points) == 3:\n                pt1 = rg.Point3d(*critical_points[0])\n                pt2 = rg.Point3d(*critical_points[1])\n                pt3 = rg.Point3d(*critical_points[2])\n\n            arc = rg.Arc(pt1, pt2, pt3)\n            # Draw the arc spine as a red arc geometric object\n            arc_guid = scriptcontext.doc.Objects.AddArc(arc)\n            if arc_guid:\n                rs.ObjectColor(arc_guid, Color.Red)\n                rs.ObjectPrintWidth(arc_guid, 2.0)\n                rs.ObjectName(arc_guid, \"Torus_Cluster\" + str(cluster_id) + \"_Shape\" + str(i+1) + \"_ArcSpine\")\n                # created_objects.append(arc_guid)\n                #print(\"  Added torus arc spine as geometric arc object\")\n\n                minor_radius = coefficients[\"minor_radius\"]\n                # Create a circle at the start of the arc\n                arc_start = pt1\n                arc_curve = arc.ToNurbsCurve()\n                # arc_tangent = arc_curve.TangentAtStart\n                # arc_plane = rg.Plane(arc_start, arc_tangent)\n                # profile_circle = rg.Circle(arc_plane, minor_radius)\n\n                # Sweep the circle along the arc\n                pipe_breps = rg.Brep.CreatePipe(arc_curve, minor_radius, False, rg.PipeCapMode.Flat, True, 0.01, 0.01)\n                if pipe_breps and len(pipe_breps) > 0:\n                    pipe_guid = scriptcontext.doc.Objects.AddBrep(pipe_breps[0])\n                    if pipe_guid:\n                        rs.ObjectColor(pipe_guid, Color.White)\n                        rs.ObjectName(pipe_guid, \"Torus_Cluster\" + str(cluster_id) + \"_Shape\" + str(i+1) + \"_PipeSweep\")\n                        # created_objects.append(pipe_guid)\n                        #print(\"  Added torus pipe sweep on arc with radius\", minor_radius)\n        except Exception as e:\n            print(\"  Error creating torus: \" + str(e))\n\n    def add_pointcloud_to_rhino(self, points, shape_type, cluster_id, shape_id, color=None):\n        \"\"\"Add point cloud to Rhino document with attributes\"\"\"\n        if not points or len(points) == 0:\n            return None\n            \n        # Set colors by shape type\n        if color is None:\n            if shape_type == \"plane\":\n                color = Color.Yellow\n            elif shape_type == \"cylinder\":\n                # Random shade of blue for pipes/cylinders\n                blue_intensity = random.randint(100, 255)\n                color = Color.FromArgb(0, 0, blue_intensity)\n            elif shape_type == \"cone\":\n                color = Color.Green\n            elif shape_type == \"torus\":\n                color = Color.Purple\n            else:\n                color = Color.Gray\n        \n        # Efficient bulk insertion using RhinoCommon PointCloud\n        pc = rg.PointCloud()\n\n        # If points is a NumPy array, handle bulk copy without building Python lists\n        try:\n            if np is not None and hasattr(points, 'ndim') and points.ndim == 2 and points.shape[1] >= 3:\n                n = points.shape[0]\n                # Try using PointCloud.Add for each point but avoid Python list allocations\n                for i in range(n):\n                    x = float(points[i, 0]); y = float(points[i, 1]); z = float(points[i, 2])\n                    pt = rg.Point3d(x, y, z)\n                    pc.Add(pt)\n\n                # If normals are present (Nx6), set per-point normals\n                try:\n                    if points.shape[1] >= 6:\n                        # interpret as x,y,z,nx,ny,nz\n                        for i in range(n):\n                            nx = float(points[i, 3]); ny = float(points[i, 4]); nz = float(points[i, 5])\n                            # Rhino PointCloud stores normals per point as Vector3d when supported\n                            try:\n                                pc.SetPointNormal(i, rg.Vector3d(nx, ny, nz))\n                            except Exception:\n                                # older RhinoCommon may not expose SetPointNormal; ignore\n                                pass\n                except Exception:\n                    pass\n            else:\n                # Generic iterable fallback\n                count = 0\n                for pt in points:\n                    try:\n                        if isinstance(pt, (list, tuple)) and len(pt) >= 3:\n                            p = rg.Point3d(float(pt[0]), float(pt[1]), float(pt[2]))\n                            pc.Add(p)\n                            count += 1\n                        else:\n                            # skip invalid entries\n                            continue\n                    except Exception:\n                        continue\n                if count == 0:\n                    print(\"  Warning: No valid points for \" + str(shape_type) + \" shape\")\n                    return None\n        except Exception as e:\n            print(\"  Warning: Failed to add points to Rhino PointCloud: \" + str(e))\n            return None\n        \n\n\n        # Add the constructed PointCloud to the Rhino document in one call\n        try:\n            guid = scriptcontext.doc.Objects.AddPointCloud(pc)\n        except Exception as e:\n            print(\"  Error adding PointCloud to Rhino document: \" + str(e))\n            return None\n\n        if guid:\n            # Set object attributes\n            try:\n                rs.ObjectColor(guid, color)\n            except Exception:\n                pass\n            try:\n                rs.ObjectName(guid, shape_type.title() + \"_Cluster\" + str(cluster_id) + \"_Shape\" + str(shape_id) + \"_Points\")\n            except Exception:\n                pass\n\n        return guid\n    \n    def visualize_results(self, results):\n        \"\"\"Visualize processing results in Rhino as point clouds\"\"\"\n        if \"error\" in results:\n            print(\"Error in results: \" + str(results.get('error')))\n            return []\n        #cgal_results = results.get(\"cgal_results\", {})\n\n        # Expect the new processor to write a root GenericShape JSON string under cgal_results.root (or top-level 'root')\n        # Try multiple fallbacks for compatibility\n        root = results\n\n        created_objects = []\n\n        # If results are in flat format with 'planes'/'cylinders', iterate directly\n        if isinstance(results, dict) and (\"planes\" in results or \"cylinders\" in results):\n            for i, p in enumerate(results.get('planes', [])):\n                coeffs = p.get('coefficients')\n                cps = p.get('critical_points', [])\n                pts = p.get('shape_points', [])\n                cid = p.get('cluster_id', 0)\n                guids = self.visualize_plane(coeffs, cps, pts, cid, i)\n                if guids:\n                    created_objects.extend(guids)\n\n            for i, c in enumerate(results.get('cylinders', [])):\n                coeffs = c.get('coefficients')\n                cps = c.get('critical_points', [])\n                pts = c.get('shape_points', [])\n                cid = c.get('cluster_id', 0)\n                guids = self.visualize_cylinder(coeffs, cps, pts, cid, i)\n                if guids:\n                    created_objects.extend(guids)\n\n            return created_objects\n\n\n\n        # Color mapping helpers consistent with main.cpp\n        def plane_color_for_label(label):\n            # label: 0 -> yellow (r=255,g=255,b=0), 1 -> cyan (0,255,255), 2 -> magenta (255,0,255)\n            if label == 0:\n                return Color.FromArgb(255, 255, 0)\n            elif label == 1:\n                return Color.FromArgb(0, 255, 255)\n            elif label == 2:\n                return Color.FromArgb(255, 0, 255)\n            else:\n                return Color.Yellow\n\n        def cylinder_color_for_label(label):\n            # label: 0 -> red, 1 -> green, 2 -> blue\n            if label == 0:\n                return Color.FromArgb(255, 0, 0)\n            elif label == 1:\n                return Color.FromArgb(0, 255, 0)\n            elif label == 2:\n                return Color.FromArgb(0, 0, 255)\n            else:\n                return Color.FromArgb(200, 200, 200)\n\n        # Recursive traversal\n        def traverse_node(node, cluster_id=0, depth=0, idx_prefix=\"\", created_objects=None):\n            if node is None:\n                return\n            ntype = node.get(\"type\", \"generic\")\n            pts = node.get(\"points\", [])\n            coeffs = node.get(\"coefficients\", [])\n            cps = node.get(\"critical_points\", [])\n            plane_label = node.get(\"plane_label\", -1)\n            cyl_label = node.get(\"cylinder_label\", -1)\n\n            id_str = idx_prefix if idx_prefix else str(depth)\n\n            if ntype == \"plane\":\n                color = plane_color_for_label(plane_label)\n                # visualize plane (this will add point cloud, surface, and boundary)\n                guids = self.visualize_plane(coeffs, cps, pts, cluster_id, id_str)\n                if guids and created_objects is not None:\n                    created_objects.extend(guids)\n                # recolor boundary appropriately\n                # recolor logic happens inside visualize_plane's boundary creation\n            elif ntype == \"cylinder\":\n                color = cylinder_color_for_label(cyl_label)\n                guids = self.visualize_cylinder(coeffs, cps, pts, cluster_id, id_str)\n                if guids and created_objects is not None:\n                    created_objects.extend(guids)\n            else:\n                # generic: add points in gray\n                if pts:\n                    guid = self.add_pointcloud_to_rhino(pts, \"generic\", cluster_id, id_str, color=Color.FromArgb(128,128,128))\n                    if guid and created_objects is not None:\n                        created_objects.append(guid)\n\n            # recurse into children\n            children = node.get(\"children\", [])\n            for i, c in enumerate(children):\n                traverse_node(c, cluster_id, depth+1, id_str + \".\" + str(i), created_objects)\n        traverse_node(root, 0, 0, \"0\", created_objects)\n\n        return created_objects\n\n\ndef run_pcl_processing(solver_type):\n    \"\"\"Main function for Rhino point cloud processing\"\"\"\n    print(\"=== Rhino PCL Point Cloud Processor ===\")\n    print(\"This tool processes point clouds using PCL+CGAL via WSL\")\n    print()\n    \n    # Ask user if they want to run test mode\n    # test_mode = rs.GetString(\"Run in test mode? (y/N)\", \"N\")\n    # if test_mode and test_mode.lower() in ['y', 'yes']:\n    #     test_pointcloud_visualization()\n    #     return\n    \n    # Create processor\n    processor = RhinoPointCloudProcessor()\n    \n    # Step 1: Select point cloud\n    print(\"Step 1: Select Point Cloud\")\n    selection = processor.select_point_cloud()\n    if not selection:\n        print(\"No point cloud selected. Exiting.\")\n        return\n    \n    pointcloud, object_id = selection\n    \n    # Step 2: Get processing parameters\n    print(\"\\nStep 2: Processing Parameters\")\n    \n\n    \n    # Step 3: Convert and process\n    print(\"\\nStep 3: Processing \" + str(pointcloud.Count) + \" points...\")\n    \n    # Convert to point list\n    points = processor.pointcloud_to_list(pointcloud)\n    print(\"Converted \" + str(len(points)) + \" points to processing format\")\n    \n    # Process via WSL\n    print(\"Sending for PCL processing...\")\n    results = processor.process_pointcloud(\n        points, \n        solver_type=solver_type\n    )\n    \n    # Step 4: Visualize results\n    print(\"\\nStep 4: Visualizing Results\")\n    if \"error\" not in results:\n        created_objects = processor.visualize_results(results)\n    # print(\"\\nProcessing complete! Created \" + str(len(created_objects)) + \" geometry objects.\")\n        print(\"Check the Rhino viewport for detected shapes.\")\n        return True\n    # , \"Successfully processed \" + str(len(points)) + \" points and created \" + str(len(created_objects)) + \" objects\"\n\n    else:\n        error_msg = \"Processing failed: \" + str(results.get('error'))\n        print(error_msg)\n        return False, error_msg\n    \n\n\n# Run the main function\nif __name__ == \"__main__\":\n    run_pcl_processing(\"BEST\")\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}