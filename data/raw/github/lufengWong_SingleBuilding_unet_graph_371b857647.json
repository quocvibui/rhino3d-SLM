{
  "source_url": "https://github.com/lufengWong/SingleBuilding_unet_graph/blob/d3009288da3a2ca11f8de68fa851718213321b95/Part_4_Rhino_data_gererate/rhino_generate_4.py",
  "repo": "lufengWong/SingleBuilding_unet_graph",
  "repo_stars": 4,
  "repo_description": "Automated building layout using deep learning and graph",
  "license": "unknown",
  "filepath": "Part_4_Rhino_data_gererate/rhino_generate_4.py",
  "instruction": "Rhino generate 4",
  "code": "# -*- coding: utf-8 -*-\n\nimport copy\nimport os\n\n#\n# import utils\n\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\n\n\ndef get_seg_rect_line_list(path_boundary, path_segment):\n    # draw boundary ############################################\n\n    # 打开文件\n    fileHandler = open(path_boundary, \"r\")\n    # 获取文件中所有行的列表\n    listOfLines = fileHandler.readlines()\n    # 关闭文件\n    fileHandler.close()\n    # 遍历列表中的每一行\n\n    list_outline = []\n\n    count = -1\n    point_this = [0, 0, 0]\n    for line in listOfLines:\n        count += 1\n        value = int(line.strip())\n        if count % 2 == 0:\n            point_this[1] = value\n        else:\n            point_this[0] = value\n            list_outline.append(point_this)\n            point_this = [0, 0, 0]\n\n    # draw segment ############################################\n    # 打开文件\n    fileHandler = open(path_segment, \"r\")\n    # 获取文件中所有行的列表\n    listOfLines = fileHandler.readlines()\n    # 关闭文件\n    fileHandler.close()\n    # 遍历列表中的每一行\n\n    list_boundary = []\n    list_rects = []\n    list_lines = []\n\n    mark_type = None\n    list_points = []\n\n    for line in listOfLines:\n        print(line.strip())\n        if line.strip() == 'Boundary':\n            if mark_type == 0:\n                list_boundary.append(list_points)\n            elif mark_type == 1:\n                list_rects.append(list_points)\n            else:\n                list_lines.append(list_points)\n\n            mark_type = 0\n            list_points = []\n\n        elif line.strip() == 'Rect':\n            if mark_type == 0:\n                list_boundary.append(list_points)\n            elif mark_type == 1:\n                list_rects.append(list_points)\n            else:\n                list_lines.append(list_points)\n\n            mark_type = 1\n            list_points = []\n\n        elif line.strip() == 'Line':\n            if mark_type == 0:\n                list_boundary.append(list_points)\n            elif mark_type == 1:\n                list_rects.append(list_points)\n            else:\n                list_lines.append(list_points)\n\n            mark_type = 2\n            list_points = []\n\n        elif line.strip() == 'over':\n            if mark_type == 0:\n                list_boundary.append(list_points)\n            elif mark_type == 1:\n                list_rects.append(list_points)\n            else:\n                list_lines.append(list_points)\n\n        else:\n            value = int(line.strip())\n            print(value)\n            list_points.append(value)\n\n    # print('debut')\n\n    ####################################\n    # boundary - segment\n    list_segment_points = []\n    for seg in list_boundary:  # 遍历每一个线\n        list_seg_this = []\n        point_this = [0, 0, 0]\n        for index, value in enumerate(seg):\n            value = value\n            if index % 2 == 0:\n                point_this[0] = value\n            else:\n                point_this[1] = value\n                list_seg_this.append(point_this)\n                point_this = [0, 0, 0]\n        list_segment_points.append(list_seg_this)\n\n    # rect\n    list_rect_points = []\n    for seg in list_rects:  # 遍历每一个线\n        list_seg_this = []\n        point_this = [0, 0, 0]\n        for index, value in enumerate(seg):\n            value = value\n            if index % 2 == 0:\n                point_this[0] = value\n            else:\n                point_this[1] = value\n                list_seg_this.append(point_this)\n                point_this = [0, 0, 0]\n        list_rect_points.append(list_seg_this)\n\n    # line\n    list_line_points = []\n    for seg in list_lines:  # 遍历每一个线\n        list_seg_this = []\n        point_this = [0, 0, 0]\n        for index, value in enumerate(seg):\n            value = value\n            if index % 2 == 0:\n                point_this[0] = value\n            else:\n                point_this[1] = value\n                list_seg_this.append(point_this)\n                point_this = [0, 0, 0]\n        list_line_points.append(list_seg_this)\n\n    list_outline = list(filter(None, list_outline))\n    list_segment_points = list(filter(None, list_segment_points))\n    list_rect_points = list(filter(None, list_rect_points))\n    list_line_points = list(filter(None, list_line_points))\n\n    print(list_outline)\n    print(list_segment_points)\n    print(list_rect_points)\n    print(list_line_points)\n\n    return list_outline, list_segment_points, list_rect_points, list_line_points\n\n\ndef get_mark_loc(path_mark):\n    list_marks_all = []\n    with open(path_mark, 'r') as file:\n        line = file.readline()\n        count = -1\n        point = [0, 0, 0]\n        while line:\n            # 处理每一行的数据\n            count += 1\n            print(line.strip())  # 去掉每行末尾的换行符\n            line = line.strip()\n            if count % 3 == 0:\n                point[0] = int(line)\n            elif count % 3 == 1:\n                point[1] = int(line)\n            else:\n                point[2] = int(line)\n                list_marks_all.append(point)\n                point = [0, 0, 0]\n\n            line = file.readline()\n    return list_marks_all\n\n\nif __name__ == \"__main__\":\n    \n    # path inout\n    path_data_save = r'C:\\Users\\Administrator\\Desktop\\singleBuilding_unet_graph\\Data_temp'\n    name_project = 'typical-2'\n    ID_layout = 1\n    \n    # path save\n    path_save=r'C:\\Users\\Administrator\\Desktop\\rhino-moedl'\n    name_save= name_project+'-'+str(ID_layout+1)+'.3dm'\n    path_save= os.path.join(path_save, name_save)\n    \n    rs.Command('_SaveAs '+path_save+ \" _Enter\")\n    \n\n    # 文件地址\n    path_data_save = os.path.join(path_data_save, name_project)\n    path_boundary_1 = os.path.join(os.path.join(path_data_save, 'Boundary'), 'boundary.txt')\n    path_mark_1 = os.path.join(os.path.join(path_data_save, 'Marks_txt'), 'mark_'+str(ID_layout)+'.txt')\n    path_segLine_1 = os.path.join(os.path.join(path_data_save, 'Lines'), str(ID_layout)+'.txt')\n\n\n    list_outline, list_segment_points, list_rect_points, list_line_points = \\\n        get_seg_rect_line_list(path_boundary_1, path_segLine_1 )\n\n    # print(12)\n\n    # 获取场景中的所有对象\n    objects = rs.AllObjects()\n    # 删除所有对象\n    rs.DeleteObjects(objects)\n    # 将单位设置为毫米\n    rs.UnitSystem(2)\n\n    # 绘制边界轮廓 ##########################\n    print(list_outline)\n    # 添加多边形\n    polyline = rs.AddPolyline(list_outline)\n    # 闭合多边形\n    rs.CloseCurve(polyline)\n    # 创建多边形表面并添加到场景中\n    srf = rs.AddPlanarSrf(polyline)\n    #    rs.AddSurface(srf)\n\n    # 向上拉伸多线段\n    height = 1000  # 拉伸高度\n    extrude_srf = rs.ExtrudeCurveStraight(polyline, (0, 0, 0), (0, 0, height))\n\n    # 绘制大分割线 ##########################\n    print(list_segment_points)\n    for seg in list_segment_points:\n        if len(seg)>100:\n            slice = len(seg)//2\n            seg= seg[::2]\n        elif len(seg) == 1:\n            continue\n        # 添加多边形\n        polyline = rs.AddPolyline(seg)\n\n    # 绘制小分割线 ##########################\n    print(list_line_points)\n   \n    for seg in list_line_points:\n        print('999999999999999')\n        print(seg)\n        # 添加多边形\n        if len(seg)>100:\n            slice = len(seg)//2\n            seg= seg[::2]\n        elif len(seg) == 1:\n            continue\n        print('1111111111')\n        print(seg)\n        polyline = rs.AddPolyline(seg)\n\n    # # 绘制筒 ##########################\n    print(list_rect_points)\n    for seg in list_rect_points:\n        # 添加多边形\n        polyline = rs.AddPolyline(seg)\n        # 闭合多边形\n        rs.CloseCurve(polyline)\n\n        # 向上拉伸多线段\n        height = 3000  # 拉伸高度\n        extrude_srf = rs.ExtrudeCurveStraight(polyline, (0, 0, 0), (0, 0, height))\n        # 获取封闭线段的边界框\n        bbox = rs.BoundingBox(extrude_srf)\n\n        # 添加边界框\n        rs.AddBox(bbox)\n\n    # 悬空字 #####################################\n    list_marks = get_mark_loc(path_mark_1)\n    room_label = [\n        (0, 'Flat'),\n        (1, 'Elevator'),\n        (2, 'Ladder'),\n        (3, 'Public'),\n\n        (4, 'External'),\n        (5, 'ExteriorWall'),\n        (6, 'InteriorWall'),\n    ]\n    height = 4000\n    for mark in list_marks:\n        type = room_label[mark[0] // 100][1]\n        point = (mark[2], mark[1], height)\n        height_font = 800\n        font = \"Arial\"\n        style = 0  # 普通样式\n        rs.AddText(type, point, height_font, font,style)\n        \n#    print(path_save)\n\n    \n    \n    print('Save sucessfully')\n    \n\n\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}