{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/src/timber_framing_generator/framing_elements/holddowns.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "src/timber_framing_generator/framing_elements/holddowns.py",
  "instruction": "Holddown location generation for shear walls.",
  "code": "# File: src/timber_framing_generator/framing_elements/holddowns.py\n\"\"\"\nHolddown location generation for shear walls.\n\nGenerates point locations where holddown anchors should be placed at shear\nwall ends and panel splice points. Holddowns resist overturning forces by\nconnecting the wall framing to the foundation or floor structure below.\n\nHolddown placement rules:\n- Required at both ends of every shear wall\n- Required at panel splice points (for panelized walls)\n- Centered on end studs (typically offset by half stud width from wall end)\n\nUsage:\n    from src.timber_framing_generator.framing_elements.holddowns import (\n        generate_holddown_locations,\n        HolddownLocation,\n    )\n\n    # Generate holddown locations for a wall\n    holddowns = generate_holddown_locations(wall_data, config)\n\"\"\"\n\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Any, Optional\nfrom enum import Enum\n\n# Handle Rhino import\ntry:\n    import Rhino.Geometry as rg\n    RHINO_AVAILABLE = True\nexcept ImportError:\n    RHINO_AVAILABLE = False\n    rg = None\n\n\nclass HolddownPosition(Enum):\n    \"\"\"Position of holddown relative to wall or panel.\"\"\"\n    LEFT = \"left\"           # Left end of wall/panel\n    RIGHT = \"right\"         # Right end of wall/panel\n    SPLICE = \"splice\"       # Panel splice point (interior connection)\n\n\n@dataclass\nclass HolddownLocation:\n    \"\"\"\n    Represents a holddown anchor location.\n\n    Attributes:\n        id: Unique identifier for this holddown\n        wall_id: Parent wall ID\n        panel_id: Panel ID (if panelized wall)\n        position: Position type (left, right, splice)\n        point: 3D point location for the holddown\n        u_coordinate: Position along wall in U-coordinate (feet)\n        elevation: Vertical position (typically at bottom plate)\n        stud_width: Width of associated end stud (for centerline offset)\n        is_load_bearing: Whether this is on a load-bearing wall\n        capacity_required: Optional capacity requirement (lbs)\n    \"\"\"\n    id: str\n    wall_id: str\n    panel_id: Optional[str]\n    position: HolddownPosition\n    point: Any  # rg.Point3d when Rhino available\n    u_coordinate: float\n    elevation: float\n    stud_width: float = 0.125  # Default 1.5\" = 0.125 ft\n    is_load_bearing: bool = False\n    capacity_required: Optional[float] = None\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n        point_dict = None\n        if self.point is not None:\n            if hasattr(self.point, 'X'):\n                point_dict = {\n                    \"x\": float(self.point.X),\n                    \"y\": float(self.point.Y),\n                    \"z\": float(self.point.Z),\n                }\n            elif isinstance(self.point, (list, tuple)) and len(self.point) >= 3:\n                point_dict = {\n                    \"x\": float(self.point[0]),\n                    \"y\": float(self.point[1]),\n                    \"z\": float(self.point[2]),\n                }\n\n        return {\n            \"id\": self.id,\n            \"wall_id\": self.wall_id,\n            \"panel_id\": self.panel_id,\n            \"position\": self.position.value,\n            \"point\": point_dict,\n            \"u_coordinate\": self.u_coordinate,\n            \"elevation\": self.elevation,\n            \"stud_width\": self.stud_width,\n            \"is_load_bearing\": self.is_load_bearing,\n            \"capacity_required\": self.capacity_required,\n        }\n\n\ndef generate_holddown_locations(\n    wall_data: Dict[str, Any],\n    config: Dict[str, Any] = None,\n    panels_data: List[Dict[str, Any]] = None\n) -> List[HolddownLocation]:\n    \"\"\"\n    Generate holddown locations for a wall.\n\n    For non-panelized walls: generates holddowns at wall ends.\n    For panelized walls: generates holddowns at panel ends and splice points.\n\n    Args:\n        wall_data: Wall geometry and properties including:\n            - wall_id: Wall identifier\n            - wall_length: Length in feet\n            - wall_base_elevation: Base elevation\n            - base_plane: Wall's base plane for positioning\n            - is_load_bearing: Whether wall is structural\n            - framing_config: Optional framing dimensions\n        config: Optional configuration with:\n            - stud_width: End stud width (default 0.125 ft = 1.5\")\n            - offset_from_end: Distance from wall end to holddown (default half stud)\n            - include_splices: Whether to add holddowns at panel splices (default True)\n        panels_data: Optional list of panel dictionaries for panelized walls\n\n    Returns:\n        List of HolddownLocation objects\n    \"\"\"\n    config = config or {}\n    holddowns = []\n\n    # Get wall properties\n    wall_id = str(wall_data.get(\"wall_id\", \"unknown\"))\n    wall_length = wall_data.get(\"wall_length\", 0)\n    base_elevation = wall_data.get(\"wall_base_elevation\", 0)\n    base_plane = wall_data.get(\"base_plane\")\n    is_load_bearing = wall_data.get(\"is_load_bearing\", False)\n\n    # Get configuration\n    framing_config = wall_data.get(\"framing_config\", {})\n    stud_width = config.get(\"stud_width\", framing_config.get(\"stud_width\", 0.125))\n    offset_from_end = config.get(\"offset_from_end\", stud_width / 2)\n    include_splices = config.get(\"include_splices\", True)\n\n    if wall_length <= 0:\n        return holddowns\n\n    # Generate holddowns based on whether wall is panelized\n    if panels_data and len(panels_data) > 0:\n        # Panelized wall: holddowns at panel boundaries\n        holddowns = _generate_panelized_holddowns(\n            wall_id=wall_id,\n            wall_length=wall_length,\n            base_elevation=base_elevation,\n            base_plane=base_plane,\n            is_load_bearing=is_load_bearing,\n            stud_width=stud_width,\n            offset_from_end=offset_from_end,\n            include_splices=include_splices,\n            panels_data=panels_data,\n        )\n    else:\n        # Non-panelized wall: holddowns at wall ends only\n        holddowns = _generate_wall_end_holddowns(\n            wall_id=wall_id,\n            wall_length=wall_length,\n            base_elevation=base_elevation,\n            base_plane=base_plane,\n            is_load_bearing=is_load_bearing,\n            stud_width=stud_width,\n            offset_from_end=offset_from_end,\n        )\n\n    return holddowns\n\n\ndef _generate_wall_end_holddowns(\n    wall_id: str,\n    wall_length: float,\n    base_elevation: float,\n    base_plane: Any,\n    is_load_bearing: bool,\n    stud_width: float,\n    offset_from_end: float,\n) -> List[HolddownLocation]:\n    \"\"\"Generate holddowns at wall ends.\"\"\"\n    holddowns = []\n\n    # Left end holddown (at u = offset_from_end)\n    left_u = offset_from_end\n    left_point = _calculate_point(base_plane, left_u, base_elevation)\n    holddowns.append(HolddownLocation(\n        id=f\"{wall_id}_holddown_left\",\n        wall_id=wall_id,\n        panel_id=None,\n        position=HolddownPosition.LEFT,\n        point=left_point,\n        u_coordinate=left_u,\n        elevation=base_elevation,\n        stud_width=stud_width,\n        is_load_bearing=is_load_bearing,\n    ))\n\n    # Right end holddown (at u = wall_length - offset_from_end)\n    right_u = wall_length - offset_from_end\n    right_point = _calculate_point(base_plane, right_u, base_elevation)\n    holddowns.append(HolddownLocation(\n        id=f\"{wall_id}_holddown_right\",\n        wall_id=wall_id,\n        panel_id=None,\n        position=HolddownPosition.RIGHT,\n        point=right_point,\n        u_coordinate=right_u,\n        elevation=base_elevation,\n        stud_width=stud_width,\n        is_load_bearing=is_load_bearing,\n    ))\n\n    return holddowns\n\n\ndef _generate_panelized_holddowns(\n    wall_id: str,\n    wall_length: float,\n    base_elevation: float,\n    base_plane: Any,\n    is_load_bearing: bool,\n    stud_width: float,\n    offset_from_end: float,\n    include_splices: bool,\n    panels_data: List[Dict[str, Any]],\n) -> List[HolddownLocation]:\n    \"\"\"Generate holddowns at panel boundaries.\"\"\"\n    holddowns = []\n\n    # Sort panels by u_start position\n    sorted_panels = sorted(panels_data, key=lambda p: p.get(\"u_start\", 0))\n\n    for i, panel in enumerate(sorted_panels):\n        panel_id = panel.get(\"panel_id\", f\"panel_{i}\")\n        panel_u_start = panel.get(\"u_start\", 0)\n        panel_u_end = panel.get(\"u_end\", wall_length)\n\n        # Left holddown for this panel\n        if i == 0:\n            # First panel: left end of wall\n            left_u = panel_u_start + offset_from_end\n            position = HolddownPosition.LEFT\n        else:\n            # Interior panel: splice point\n            if not include_splices:\n                continue\n            left_u = panel_u_start + offset_from_end\n            position = HolddownPosition.SPLICE\n\n        left_point = _calculate_point(base_plane, left_u, base_elevation)\n        holddowns.append(HolddownLocation(\n            id=f\"{wall_id}_{panel_id}_holddown_left\",\n            wall_id=wall_id,\n            panel_id=panel_id,\n            position=position,\n            point=left_point,\n            u_coordinate=left_u,\n            elevation=base_elevation,\n            stud_width=stud_width,\n            is_load_bearing=is_load_bearing,\n        ))\n\n        # Right holddown for last panel only (to avoid duplicates at splices)\n        if i == len(sorted_panels) - 1:\n            right_u = panel_u_end - offset_from_end\n            right_point = _calculate_point(base_plane, right_u, base_elevation)\n            holddowns.append(HolddownLocation(\n                id=f\"{wall_id}_{panel_id}_holddown_right\",\n                wall_id=wall_id,\n                panel_id=panel_id,\n                position=HolddownPosition.RIGHT,\n                point=right_point,\n                u_coordinate=right_u,\n                elevation=base_elevation,\n                stud_width=stud_width,\n                is_load_bearing=is_load_bearing,\n            ))\n\n    return holddowns\n\n\ndef _calculate_point(base_plane: Any, u_coordinate: float, elevation: float) -> Any:\n    \"\"\"\n    Calculate 3D point from base plane and coordinates.\n\n    Args:\n        base_plane: Wall's base plane\n        u_coordinate: Position along wall (feet)\n        elevation: Vertical position (feet)\n\n    Returns:\n        Point3d if Rhino available, tuple otherwise\n    \"\"\"\n    if base_plane is None:\n        # No plane available, return simple tuple\n        return (u_coordinate, 0, elevation)\n\n    if RHINO_AVAILABLE and hasattr(base_plane, 'PointAt'):\n        # Use Plane.PointAt(u, v, w) where:\n        # u = along wall (XAxis)\n        # v = vertical (YAxis = World Z in our convention)\n        # w = through wall (ZAxis = wall normal)\n        # For holddowns, we want the point at wall centerline (w=0)\n        # and at the bottom plate level (v from elevation)\n\n        # Note: elevation is absolute, origin.Z is also absolute\n        # We need v relative to the origin\n        v_relative = elevation - base_plane.Origin.Z\n        return base_plane.PointAt(u_coordinate, v_relative, 0)\n    else:\n        # Fallback for non-Rhino environment\n        return (u_coordinate, 0, elevation)\n\n\ndef get_holddown_summary(holddowns: List[HolddownLocation]) -> Dict[str, Any]:\n    \"\"\"\n    Generate summary statistics for holddown locations.\n\n    Args:\n        holddowns: List of HolddownLocation objects\n\n    Returns:\n        Dictionary with summary statistics\n    \"\"\"\n    if not holddowns:\n        return {\n            \"total_holddowns\": 0,\n            \"wall_end_holddowns\": 0,\n            \"splice_holddowns\": 0,\n            \"load_bearing_count\": 0,\n        }\n\n    wall_end_count = sum(\n        1 for h in holddowns\n        if h.position in (HolddownPosition.LEFT, HolddownPosition.RIGHT)\n    )\n    splice_count = sum(1 for h in holddowns if h.position == HolddownPosition.SPLICE)\n    load_bearing_count = sum(1 for h in holddowns if h.is_load_bearing)\n\n    return {\n        \"total_holddowns\": len(holddowns),\n        \"wall_end_holddowns\": wall_end_count,\n        \"splice_holddowns\": splice_count,\n        \"load_bearing_count\": load_bearing_count,\n        \"walls_with_holddowns\": len(set(h.wall_id for h in holddowns)),\n    }\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}