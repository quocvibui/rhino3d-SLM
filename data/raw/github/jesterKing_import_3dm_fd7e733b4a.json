{
  "source_url": "https://github.com/jesterKing/import_3dm/blob/b3c680c3fe049bae8e421fac9da7f13c6c9cd927/import_3dm/converters/material.py",
  "repo": "jesterKing/import_3dm",
  "repo_stars": 372,
  "repo_description": "Blender importer script for Rhinoceros 3D files",
  "license": "MIT",
  "filepath": "import_3dm/converters/material.py",
  "instruction": "MIT License",
  "code": "# MIT License\n\n# Copyright (c) 2018-2024 Nathan Letwory, Joel Putnam, Tom Svilans, Lukas Fertig\n\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nimport binascii\nimport struct\nimport bpy\nimport rhino3dm as r3d\nfrom bpy_extras.node_shader_utils import ShaderWrapper, PrincipledBSDFWrapper\nfrom bpy_extras.node_shader_utils import rgba_to_rgb, rgb_to_rgba\nfrom . import utils\nfrom . import rdk_manager\nfrom pathlib import Path, PureWindowsPath, PurePosixPath\nimport base64\nimport tempfile\nimport uuid\n\nfrom typing import Any, Tuple\n\n### default Rhino material name\nDEFAULT_RHINO_MATERIAL = \"Rhino Default Material\"\nDEFAULT_TEXT_MATERIAL = \"Rhino Default Text\"\nDEFAULT_RHINO_MATERIAL_ID = uuid.UUID(\"00000000-ABCD-EF01-2345-000000000000\")\nDEFAULT_RHINO_TEXT_MATERIAL_ID = uuid.UUID(\"00000000-ABCD-EF01-6789-000000000000\")\n\n#### material hashing functions\n\n_black = (0, 0, 0, 1.0)\n_white = (0.2, 1.0, 0.6, 1.0)\n\n\ndef Bbytes(b):\n    \"\"\"\n    Return bytes representation of boolean\n    \"\"\"\n    return struct.pack(\"?\", b)\n\n\ndef Fbytes(f):\n    \"\"\"\n    Return bytes representation of float\n    \"\"\"\n    return struct.pack(\"f\", f)\n\n\ndef Cbytes(c):\n    \"\"\"\n    Return bytes representation of Color, a 4-tuple containing integers\n    \"\"\"\n    return struct.pack(\"IIII\", *c)\n\n\ndef tobytes(d):\n    t = type(d)\n    if t is bool:\n        return Bbytes(d)\n    if t is float:\n        return Fbytes(d)\n    if t is tuple and len(d) == 4:\n        return Cbytes(d)\n\n\ndef hash_color(C, crc):\n    \"\"\"\n    return crc from color C\n    \"\"\"\n    crc = binascii.crc32(tobytes(C), crc)\n    return crc\n\n\ndef hash_material(M):\n    \"\"\"\n    Hash a rhino3dm.Material. A CRC32 is calculated using the\n    material name and data that affects render results\n    \"\"\"\n    crc = 13\n    crc = binascii.crc32(bytes(M.Name, \"utf-8\"))\n    crc = hash_color(M.DiffuseColor, crc)\n    crc = hash_color(M.EmissionColor, crc)\n    crc = hash_color(M.ReflectionColor, crc)\n    crc = hash_color(M.SpecularColor, crc)\n    crc = hash_color(M.TransparentColor, crc)\n    crc = binascii.crc32(tobytes(M.DisableLighting), crc)\n    crc = binascii.crc32(tobytes(M.FresnelIndexOfRefraction), crc)\n    crc = binascii.crc32(tobytes(M.FresnelReflections), crc)\n    crc = binascii.crc32(tobytes(M.IndexOfRefraction), crc)\n    crc = binascii.crc32(tobytes(M.ReflectionGlossiness), crc)\n    crc = binascii.crc32(tobytes(M.Reflectivity), crc)\n    crc = binascii.crc32(tobytes(M.RefractionGlossiness), crc)\n    crc = binascii.crc32(tobytes(M.Shine), crc)\n    crc = binascii.crc32(tobytes(M.Transparency), crc)\n    return crc\n\n\ndef srgb_eotf(srgb_color: Tuple[float, float, float, float]) -> Tuple[float, float, float, float]:\n    # sRGB piece-wise electro optical transfer function\n    # also known as \"sRGB to linear\"\n    # assuming Rhino uses this instead of pure 2.2 gamma function\n    def cc(value):\n        if value <= 0.04045:\n            return value / 12.92\n        else:\n            return ((value + 0.055) / 1.055) ** 2.4\n\n    linear_color = tuple(cc(x) for x in srgb_color)\n    return linear_color\n\n\ndef get_color_field(rm : r3d.RenderMaterial, field_name : str) -> Tuple[float, float, float, float]:\n    \"\"\"\n    Get a color field from a rhino3dm.RenderMaterial\n    \"\"\"\n    colstr = rm.GetParameter(field_name)\n    if not colstr:\n        return _white\n    coltup = tuple(float(f) for f in colstr.split(\",\"))  # convert to tuple of floats\n    return srgb_eotf(coltup)\n\n\ndef get_float_field(rm : r3d.RenderMaterial, field_name : str) -> float:\n    \"\"\"\n    Get a float field from a rhino3dm.RenderMaterial\n    \"\"\"\n    fl = rm.GetParameter(field_name)\n    if not fl:\n        #print(f\"No float field found {field_name}\")\n        return 0.0\n    return float(fl)\n\ndef get_bool_field(rm : r3d.RenderMaterial, field_name : str) -> bool:\n    \"\"\"\n    Get a boolean field from a rhino3dm.RenderMaterial\n    \"\"\"\n    b = rm.GetParameter(field_name)\n    if not b:\n        #print(f\"No bool field found {field_name}\")\n        return False\n    return bool(b)\n\ndef hash_rendermaterial(M : r3d.RenderMaterial):\n    \"\"\"\n    Hash a rhino3dm.Material. A CRC32 is calculated using the\n    material name and data that affects render results\n    \"\"\"\n    crc = 13\n    crc = binascii.crc32(bytes(M.Name, \"utf-8\"))\n    crc = binascii.crc32(bytes(M.GetParameter(\"pbr-base-color\"), \"utf-8\"), crc)\n    crc = binascii.crc32(bytes(M.GetParameter(\"pbr-emission\"), \"utf-8\"), crc)\n    crc = binascii.crc32(bytes(M.GetParameter(\"pbr-subsurface_scattering-color\"), \"utf-8\"), crc)\n    crc = binascii.crc32(tobytes(get_float_field(M, \"pbr-opacity\")), crc)\n    crc = binascii.crc32(tobytes(get_float_field(M, \"pbr-opacity-ior\")), crc)\n    crc = binascii.crc32(tobytes(get_float_field(M, \"pbr-opacity-roughness\")), crc)\n    crc = binascii.crc32(tobytes(get_float_field(M, \"pbr-roughness\")), crc)\n    crc = binascii.crc32(tobytes(get_float_field(M, \"pbr-metallic\")), crc)\n    return crc\n\n\n\ndef material_name(m):\n    h = hash_material(m)\n    return m.Name # + \"~\" + str(h)\n\ndef rendermaterial_name(m):\n    h = hash_rendermaterial(m)\n    return m.Name  #+ \"~\" + str(h)\n\n\nclass PlasterWrapper(ShaderWrapper):\n    NODES_LIST = (\n        \"node_out\",\n        \"node_diffuse_bsdf\",\n\n        \"_node_texcoords\",\n    )\n\n    __slots__ = (\n        \"material\",\n        *NODES_LIST\n    )\n\n    NODES_LIST = ShaderWrapper.NODES_LIST + NODES_LIST\n\n    def __init__(self, material):\n        super(PlasterWrapper, self).__init__(material, is_readonly=False, use_nodes=True)\n\n    def update(self):\n        super(PlasterWrapper, self).update()\n\n        tree = self.material.node_tree\n        nodes = tree.nodes\n        links = tree.links\n\n        node_out = None\n        node_diffuse_bsdf = None\n        for n in nodes:\n            if n.bl_idname == 'ShaderNodeOutputMaterial' and n.inputs[0].is_linked:\n                node_out = n\n                node_diffuse_bsdf = n.inputs[0].links[0].from_node\n            elif n.bl_idname == 'ShaderNodeBsdfDiffuse' and n.outputs[0].is_linked:\n                node_diffuse_bsdf = n\n                for lnk in n.outputs[0].links:\n                    node_out = lnk.to_node\n                    if node_out.bl_idname == 'ShaderNodeOutputMaterial':\n                        break\n            if (\n                node_out is not None and node_diffuse_bsdf is not None and\n                node_out.bl_idname == 'ShaderNodeOutputMaterial' and\n                node_diffuse_bsdf.bl_idname == 'ShaderNodeBsdfDiffuse'\n            ):\n                break\n            node_out = node_diffuse_bsdf = None\n\n        if node_out is not None:\n            self._grid_to_location(0, 0, ref_node=node_out)\n        else:\n            node_out = nodes.new('ShaderNodeOutputMaterial')\n            node_out.label = \"Material Out\"\n            node_out.target = 'ALL'\n            self._grid_to_location(1, 1, ref_node=node_out)\n        self.node_out = node_out\n\n        if node_diffuse_bsdf is not None:\n            self._grid_to_location(0, 0, ref_node=node_diffuse_bsdf)\n        else:\n            node_diffuse_bsdf = nodes.new('ShaderNodeBsdfDiffuse')\n            node_diffuse_bsdf.label = \"Diffuse BSDF\"\n            self._grid_to_location(0, 1, ref_node=node_diffuse_bsdf)\n            links.new(node_diffuse_bsdf.outputs[\"BSDF\"], self.node_out.inputs[\"Surface\"])\n        self.node_diffuse_bsdf = node_diffuse_bsdf\n\n    def base_color_get(self):\n        if self.node_diffuse_bsdf is None:\n            return self.material.diffuse_color\n        return self.node_diffuse_bsdf.inputs[\"Color\"].default_value\n\n    def base_color_set(self, color):\n        #color = rgb_to_rgba(color)\n        self.material.diffuse_color = color\n        if self.node_diffuse_bsdf is not None:\n            self.node_diffuse_bsdf.inputs[\"Color\"].default_value = color\n\n    base_color = property(base_color_get, base_color_set)\n\n\ndef paint_material(rhino_material : r3d.RenderMaterial, blender_material : bpy.types.Material):\n    paint = PrincipledBSDFWrapper(blender_material, is_readonly = False)\n    col = get_color_field(rhino_material, \"color\")[0:3]\n    roughness = 1.0 - get_float_field(rhino_material, \"reflectivity\")\n    paint.base_color = col\n    paint.specular = 0.5\n    paint.roughness = roughness\n\ndef plaster_material(rhino_material : r3d.RenderMaterial, blender_material : bpy.types.Material):\n    plaster = PlasterWrapper(blender_material)\n    col = get_color_field(rhino_material, \"color\")\n    plaster.base_color = col\n\ndef default_material(blender_material : bpy.types.Material):\n    plaster = PlasterWrapper(blender_material)\n    plaster.base_color = (0.9, 0.9, 0.9, 1.0)\n\ndef default_text_material(blender_material : bpy.types.Material):\n    plaster = PlasterWrapper(blender_material)\n    plaster.base_color = (0.05, 0.05, 0.05, 1.0)\n\ndef metal_material(rhino_material : r3d.RenderMaterial, blender_material : bpy.types.Material):\n    metal = PrincipledBSDFWrapper(blender_material, is_readonly=False)\n    col = get_color_field(rhino_material, \"color\")[0:3]\n    roughness = get_float_field(rhino_material, \"polish-amount\")\n    metal.base_color = col\n    metal.metallic = 1.0\n    metal.roughness = roughness\n    metal.transmission = 0.0\n\ndef glass_material(rhino_material : r3d.RenderMaterial, blender_material : bpy.types.Material):\n    glass = PrincipledBSDFWrapper(blender_material, is_readonly=False)\n    col = get_color_field(rhino_material, \"color\")[0:3]\n    roughness = 1.0 - get_float_field(rhino_material, \"clarity-amount\")\n    ior = get_float_field(rhino_material, \"ior\")\n    glass.base_color = col\n    glass.transmission = 1.0\n    glass.roughness = roughness\n    glass.metallic = 0.0\n    glass.ior= ior\n\ndef plastic_material(rhino_material : r3d.RenderMaterial, blender_material : bpy.types.Material):\n    plastic = PrincipledBSDFWrapper(blender_material, is_readonly=False)\n    col = get_color_field(rhino_material, \"color\")[0:3]\n    roughness = 1.0 - get_float_field(rhino_material, \"polish-amount\")\n    #roughness = 1.0 - get_float_field(rhino_material, \"reflectivity\")\n    transparency = get_float_field(rhino_material, \"transparency\")\n    plastic.base_color = col\n    plastic.transmission = transparency\n    plastic.roughness = roughness\n    plastic.metallic = 0.0\n    plastic.ior= 1.5\n\n\ndef _get_blender_pbr_texture(pbr : PrincipledBSDFWrapper, field_name : str):\n    if field_name == \"pbr-base-color\":\n        return pbr.base_color_texture\n    elif field_name == \"pbr-roughness\":\n        return pbr.roughness_texture\n    elif field_name == \"pbr-metallic\":\n        return pbr.metallic_texture\n    elif field_name == \"pbr-specular\":\n        return pbr.specular_texture\n    elif field_name == \"pbr-opacity\":\n        return pbr.transmission_texture\n    elif field_name == \"pbr-alpha\":\n        return pbr.alpha_texture\n    elif field_name == \"pbr-emission\":\n        return pbr.emission_color_texture\n    elif field_name == \"pbr-emission-double-amount\":\n        return pbr.emission_strength_texture\n    else:\n        raise ValueError(f\"Unknown field name {field_name}\")\n\n\ndef _get_blender_basic_texture(pbr : PrincipledBSDFWrapper, field_name : str):\n    if field_name == \"bitmap-texture\":\n        return pbr.base_color_texture\n    else:\n        raise ValueError(f\"Unknown field name {field_name}\")\n\ndef handle_pbr_texture(rhino_material : r3d.RenderMaterial, pbr : PrincipledBSDFWrapper, field_name : str):\n    rhino_tex = rhino_material.FindChild(field_name)\n    if rhino_tex:\n        fp = _name_from_embedded_filepath(rhino_tex.FileName)\n        use_alpha = get_bool_field(rhino_tex, \"use-alpha-channel\")\n        if fp in _efps.keys():\n            pbr_tex = _get_blender_pbr_texture(pbr, field_name)\n            img = _efps[fp]\n            pbr_tex.node_image.image = img\n            if use_alpha and field_name in (\"pbr-base-color\", \"diffuse\"):\n                pbr.material.node_tree.links.new(pbr_tex.node_image.outputs['Alpha'], pbr.node_principled_bsdf.inputs['Alpha'])\n        else:\n            print(f\"Image {fp} not found in Blender\")\n\n\ndef handle_basic_texture(rhino_material : r3d.RenderMaterial, pbr : PrincipledBSDFWrapper, field_name : str):\n    rhino_tex = rhino_material.FindChild(field_name)\n    if rhino_tex:\n        fp = _name_from_embedded_filepath(rhino_tex.FileName)\n        if fp in _efps.keys():\n            pbr_tex = _get_blender_basic_texture(pbr, field_name)\n            img = _efps[fp]\n            pbr_tex.node_image.image = img\n        else:\n            print(f\"Image {fp} not found in Blender\")\n\ndef pbr_material(rhino_material : r3d.RenderMaterial, blender_material : bpy.types.Material):\n    pbr = PrincipledBSDFWrapper(blender_material, is_readonly=False)\n\n    refl = get_float_field(rhino_material, \"pbr-metallic\")\n    transp = 1.0 - get_float_field(rhino_material, \"pbr-opacity\")\n    ior = get_float_field(rhino_material, \"pbr-opacity-ior\")\n    roughness = get_float_field(rhino_material, \"pbr-roughness\")\n    transrough = get_float_field(rhino_material, \"pbr-opacity-roughness\")\n    spec = get_float_field(rhino_material, \"pbr-specular\")\n    alpha = get_float_field(rhino_material, \"pbr-alpha\")\n    basecol = get_color_field(rhino_material, \"pbr-base-color\")\n    emission_color = get_color_field(rhino_material, \"pbr-emission\")\n    emission_amount = get_float_field(rhino_material, \"emission-multiplier\")\n\n    pbr.base_color = basecol[0:3]\n    pbr.metallic = refl\n    pbr.transmission = transp\n    pbr.ior = ior\n    pbr.roughness = roughness\n    pbr.specular = spec\n    pbr.emission_color = emission_color[0:3]\n    pbr.emission_strength = emission_amount\n    pbr.alpha = alpha\n    if bpy.app.version[0] < 4:\n        pbr.node_principled_bsdf.inputs[16].default_value = transrough\n\n    handle_pbr_texture(rhino_material, pbr, \"pbr-base-color\")\n    handle_pbr_texture(rhino_material, pbr, \"pbr-metallic\")\n    handle_pbr_texture(rhino_material, pbr, \"pbr-roughness\")\n    handle_pbr_texture(rhino_material, pbr, \"pbr-specular\")\n    handle_pbr_texture(rhino_material, pbr, \"pbr-opacity\")\n    handle_pbr_texture(rhino_material, pbr, \"pbr-alpha\")\n    handle_pbr_texture(rhino_material, pbr, \"pbr-emission\")\n    handle_pbr_texture(rhino_material, pbr, \"emission-multiplier\")\n\ndef rcm_basic_material(rhino_material : r3d.RenderMaterial, blender_material : bpy.types.Material):\n    # first version with just simple pbr node. Can do something more elaborate later\n    pbr = PrincipledBSDFWrapper(blender_material, is_readonly=False)\n\n    base_color = get_color_field(rhino_material, \"diffuse\")\n    trans_color = get_color_field(rhino_material, \"transparency-color\")\n    trans_color = get_color_field(rhino_material, \"reflectivity-color\")\n\n    fresnel_enabled = get_bool_field(rhino_material, \"fresnel-enabled\")\n\n    transparency = get_float_field(rhino_material, \"transparency\")\n    reflectivity = get_float_field(rhino_material, \"reflectivity\")\n    ior = get_float_field(rhino_material, \"ior\")\n    roughness = 1.0 - get_float_field(rhino_material, \"polish-amount\")\n\n    pbr.specular = 0.5\n\n    if transparency > 0.0:\n        base_color = trans_color\n    else:\n        pbr.base_color = base_color[0:3]\n\n    pbr.roughness = roughness\n\n    if reflectivity > 0.0 and fresnel_enabled:\n        pbr.metallic = reflectivity\n\n    pbr.transmission = transparency\n    pbr.ior = ior\n\n    handle_basic_texture(rhino_material, pbr, \"bitmap-texture\")\n\n\n\ndef not_yet_implemented(rhino_material : r3d.RenderMaterial, blender_material : bpy.types.Material):\n    paint = PlasterWrapper(blender_material)\n    paint.base_color = (1.0, 0.0, 1.0, 1.0)\n\nmaterial_handlers = {\n    'rdk-paint-material': paint_material,\n    'rdk-metal-material': metal_material,\n    'rdk-plaster-material': plaster_material,\n    'rdk-glass-material': glass_material,\n    'rdk-plastic-material': plastic_material,\n    'rcm-basic-material': rcm_basic_material,\n    '5a8d7b9b-cdc9-49de-8c16-2ef64fb097ab': pbr_material,\n}\n\ndef harvest_from_rendercontent(model : r3d.File3dm, mat : r3d.RenderMaterial, blender_material : bpy.types.Material):\n    blender_material.use_nodes = True\n    typeName = mat.TypeName\n\n    material_handler = material_handlers.get(typeName, not_yet_implemented)\n    material_handler(mat, blender_material)\n\n\n_model = None\n_efps = None\n\ndef _name_from_embedded_filepath(efp : str) -> str:\n    efpath = PureWindowsPath(efp)\n    if not efpath.drive:\n        efpath = PurePosixPath(efp)\n    return efpath.name\n\ndef handle_embedded_files(model : r3d.File3dm):\n    global _model, _efps\n    _model = model\n    _efps = dict()\n\n    for rhino_embedded_filename in _model.EmbeddedFilePaths():\n\n        if rhino_embedded_filename in _efps.keys():\n            continue\n\n        encoded_img = _model.GetEmbeddedFileAsBase64(rhino_embedded_filename)\n        decoded_img = base64.b64decode(encoded_img)\n\n        ef_name = _name_from_embedded_filepath(rhino_embedded_filename)\n\n        with tempfile.NamedTemporaryFile(delete=False) as tmpf:\n            tmpf.write(decoded_img)\n\n        blender_image = bpy.context.blend_data.images.load(tmpf.name, check_existing=True)\n        blender_image.name = ef_name\n        blender_image.pack()\n        _efps[ef_name] = blender_image\n\n        tmpfpath = tmpf.name\n        try:\n            tmpfpath.unlink()\n        except:\n            pass\n\n\n\ndef handle_materials(context, model : r3d.File3dm, materials, update):\n    \"\"\"\n    \"\"\"\n    handle_embedded_files(model)\n\n    if DEFAULT_RHINO_MATERIAL not in materials:\n        tags = utils.create_tag_dict(DEFAULT_RHINO_MATERIAL_ID, DEFAULT_RHINO_MATERIAL)\n        blmat = utils.get_or_create_iddata(context.blend_data.materials, tags, None)\n        default_material(blmat)\n        materials[DEFAULT_RHINO_MATERIAL] = blmat\n\n    if DEFAULT_TEXT_MATERIAL not in materials:\n        tags = utils.create_tag_dict(DEFAULT_RHINO_TEXT_MATERIAL_ID, DEFAULT_TEXT_MATERIAL)\n        blmat = utils.get_or_create_iddata(context.blend_data.materials, tags, None)\n        default_text_material(blmat)\n        materials[DEFAULT_TEXT_MATERIAL] = blmat\n\n    for mat in model.Materials:\n        if not mat.PhysicallyBased:\n            mat.ToPhysicallyBased()\n        m = model.RenderContent.FindId(mat.RenderMaterialInstanceId)\n\n        if not m:\n            continue\n\n        matname = rendermaterial_name(m)\n        if matname not in materials:\n            tags = utils.create_tag_dict(m.Id, m.Name)\n            blmat = utils.get_or_create_iddata(context.blend_data.materials, tags, None)\n            if update:\n                harvest_from_rendercontent(model, m, blmat)\n            materials[matname] = blmat\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}