{
  "source_url": "https://github.com/ladybug-tools/honeybee-legacy/blob/bd62af4862fe022801fb87dbc8794fdf1dff73a9/src/Honeybee_Import%20THERM%20XML.py",
  "repo": "ladybug-tools/honeybee-legacy",
  "repo_stars": 129,
  "repo_description": ":bee: Honeybee is a free and open source plugin to connect Grasshopper3D to EnergyPlus, Radiance, Daysim and OpenStudio for building energy and daylighting simulation",
  "license": "NOASSERTION",
  "filepath": "src/Honeybee_Import THERM XML.py",
  "instruction": "Use this component to read the content of a THERM XML file into Grasshopper.  The component will extract both THERM polygons and boundary conditions along with all of their properties.\n_\nAt this...",
  "code": "#\n# Honeybee: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Honeybee.\n# \n# Copyright (c) 2013-2020, Chris Mackey <Chris@MackeyArchitecture.com.com> \n# Honeybee is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Honeybee is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Honeybee; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to read the content of a THERM XML file into Grasshopper.  The component will extract both THERM polygons and boundary conditions along with all of their properties.\n_\nAt this point in time, U-Factor tags are not supported but all other features should be imported.\n-\nProvided by Honeybee 0.0.66\n\n    Args:\n        _thermXMLFile: A filepath to a therm XML file on your machine.\n        basePlane_: An optional plane or point to set the location and orientation of the THERM file geometry in the Rhino scene.  The default will seatch for location information within the THERM file and, if none is found, geomtry is brought into the World XY plane.\n    Returns:\n        readMe!:...\n        thermPolygons: The therm polygons within the therm XML file.\n        thermBCs: The therm boundary conditions within the therm XML file.\n\"\"\"\n\n\nimport Rhino as rc\nimport scriptcontext as sc\nimport Grasshopper.Kernel as gh\nimport os\nimport copy\nimport uuid\n\nghenv.Component.Name = 'Honeybee_Import THERM XML'\nghenv.Component.NickName = 'importTHERM'\nghenv.Component.Message = 'VER 0.0.66\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"HB-Legacy\"\nghenv.Component.SubCategory = \"11 | THERM\"\n#compatibleHBVersion = VER 0.0.56\\nMAY_26_201\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"4\"\nexcept: pass\n\n\nw = gh.GH_RuntimeMessageLevel.Warning\ne = gh.GH_RuntimeMessageLevel.Error\n\n\ndef main(thermXMLFile):\n    #Call the relevant classes\n    lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n    hb_thermPolygon = sc.sticky[\"honeybee_ThermPolygon\"]\n    hb_thermBC = sc.sticky[\"honeybee_ThermBC\"]\n    hb_hive = sc.sticky[\"honeybee_Hive\"]()\n    thermDefault = sc.sticky[\"honeybee_ThermDefault\"]()\n    \n    #Make a series of lists to be filled.\n    thermPolygonsFinal = []\n    thermBCs = []\n    \n    #Check if the result file exists.\n    if not os.path.isfile(thermXMLFile):\n        warning = \"Cannot find the result file. Check the location of the file on your machine. \\n If it is not there, make sure that you have opened THERM and run your .thmx file before using this component. \\n Also, before you run the file in THERM, make sure that you go to Options > Preferences > Simulation and check 'Save Conrad results file (.O).'\"\n        print warning\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n        return -1\n    \n    #Define some parameters to be changes while the file is open.\n    materialsTrigger = False\n    polygonTrigger = False\n    newPolygonTrigger = False\n    polygonVertices = []\n    polygonMaterials = []\n    thermPolygons = []\n    BCTypes = []\n    BCTypeTrigger = False\n    BCTypeNames = []\n    BCSegments = []\n    BCSegmentsTrigger = False\n    BCindex = 0\n    grabPtData = False\n    x1 = 0\n    y1 = 0\n    x2 = 0\n    y2 = 0\n    \n    #Establish some default information about the translations\n    plane = rc.Geometry.Plane.WorldXY\n    planeReorientation = None\n    rhinoOrig = None\n    conversionFactor = lb_preparation.checkUnits()\n    conversionFactor = 1/(conversionFactor*1000)\n    unitsScale = rc.Geometry.Transform.Scale(rc.Geometry.Plane.WorldXY, conversionFactor, conversionFactor, conversionFactor)\n    \n    #Open the file and begin extracting the relevant bits of information.\n    BCDict = {'radTemp':None, 'envEmiss':None, 'Viewfactor':None, 'HeatFlux':None}\n    bcTrigger = False\n    thermFi = open(thermXMLFile, 'r')\n    for lineCount, line in enumerate(thermFi):\n        if '<Materials>' in line: materialsTrigger = True\n        elif '</Materials>' in line: materialsTrigger = False\n        elif '<BoundaryConditions>' in line: BCTypeTrigger = True\n        elif '</BoundaryConditions>' in line:\n            BCTypeTrigger = False\n            if BCDict != {'radTemp':None, 'envEmiss':None, 'Viewfactor':None, 'HeatFlux':None}:\n                BCTypeNames.append(BCDict['Name'])\n                BCTypes.append(BCDict)\n                BCSegments.append([])\n        elif '<Polygons>' in line: polygonTrigger = True\n        elif '</Polygons>' in line: polygonTrigger = False\n        elif '<Boundaries>' in line: BCSegmentsTrigger = True\n        elif '</Boundaries>' in line: BCSegmentsTrigger = False\n        #Try to extract the transformations from the file header.\n        elif '<Notes>' in line and '</Notes>' in line:\n            if 'RhinoUnits-' in line and 'RhinoOrigin-' in line and 'RhinoXAxis-' in line:\n                origRhinoUnits = line.split(',')[0].split('RhinoUnits-')[-1]\n                origRhinoOrigin = line.split('),')[0].split('RhinoOrigin-(')[-1].split(',')\n                origRhinoXaxis = line.split('),')[1].split('RhinoXAxis-(')[-1].split(',')\n                origRhinoYaxis = line.split('),')[2].split('RhinoYAxis-(')[-1].split(',')\n                origRhinoZaxis = line.split(')</Notes>')[0].split('RhinoZAxis-(')[-1].split(',')\n                \n                rhinoOrig = rc.Geometry.Point3d(float(origRhinoOrigin[0]), float(origRhinoOrigin[1]), float(origRhinoOrigin[2]))\n                thermPlane = rc.Geometry.Plane(rhinoOrig, rc.Geometry.Plane.WorldXY.XAxis, rc.Geometry.Plane.WorldXY.YAxis)\n                basePlane = rc.Geometry.Plane(rhinoOrig, rc.Geometry.Vector3d(float(origRhinoXaxis[0]), float(origRhinoXaxis[1]), float(origRhinoXaxis[2])), rc.Geometry.Vector3d(float(origRhinoYaxis[0]), float(origRhinoYaxis[1]), float(origRhinoYaxis[2])))\n                basePlaneNormal = rc.Geometry.Vector3d(float(origRhinoZaxis[0]), float(origRhinoZaxis[1]), float(origRhinoZaxis[2]))\n                planeReorientation = rc.Geometry.Transform.ChangeBasis(basePlane, thermPlane)\n                plane = basePlane\n            elif basePlane_ == None:\n                warning = \"Cannot find any transformation data in the header of the THERM file. \\n Result geometry will be imported to the Rhino model origin.\"\n                print warning\n        \n        #Extract the materials from the file header.\n        elif materialsTrigger == True and not '<Property' in line and not '\t</Material>' in line:\n            materialStr = line.strip().replace('\"', '')\n            materialName = copy.copy(materialStr).split('Material Name=')[-1].split(' Type=')[0]\n            if materialName.upper() not in sc.sticky[\"honeybee_thermMaterialLib\"].keys():\n                material = thermDefault.addThermMatToLib(materialStr)\n        \n        #Try to extract the types of Boundary Conditions.\n        if BCTypeTrigger == True:\n            if 'Adiabatic' in line or 'Frame Cavity Surface' in line:\n                bcTrigger = False\n                if BCDict != {'radTemp':None, 'envEmiss':None, 'Viewfactor':None, 'HeatFlux':None}:\n                    BCTypeNames.append(BCDict['Name'])\n                    BCTypes.append(BCDict)\n                    BCSegments.append([])\n            elif '<BoundaryCondition Name' in line:\n                bcTrigger = True\n                if BCDict != {'radTemp':None, 'envEmiss':None, 'Viewfactor':None, 'HeatFlux':None}:\n                    BCTypeNames.append(BCDict['Name'])\n                    BCTypes.append(BCDict)\n                    BCSegments.append([])\n                BCDict = {'radTemp':None, 'envEmiss':None, 'Viewfactor':None, 'HeatFlux':None}\n                BCDict['Name'] = line.split('Name=\"')[-1].split('\" Type')[0]\n                BCDict['Temperature'] = float(line.split('Temperature=\"')[-1].split('\" ')[0])\n                BCDict['filmCoefficient'] = float(line.split('H=\"')[-1].split('\" ')[0])\n                if 'HeatFlux=\"' in line:\n                    BCDict['HeatFlux'] = float(line.split('HeatFlux=\"')[-1].split('\" ')[0])\n                    if BCDict['HeatFlux'] == 0:\n                        BCDict['HeatFlux'] = None\n            elif bcTrigger == True:\n                if 'Tr=\"' in line:\n                    BCDict['radTemp'] = float(line.split('Tr=\"')[-1].split('\"')[0])\n                    if BCDict['radTemp'] == BCDict['Temperature']:\n                        BCDict['radTemp'] = None\n                if 'Ei=\"' in line:\n                    BCDict['envEmiss'] = float(line.split('Ei=\"')[-1].split('\"')[0])\n                    if BCDict['envEmiss'] == 1:\n                        BCDict['envEmiss'] = None\n                if 'RadiationModel=\"' in line:\n                    radModel = float(line.split('RadiationModel=\"')[-1].split('\"')[0])\n                    if radModel == 3:\n                        BCDict['Viewfactor'] = None\n                    else:\n                        BCDict['Viewfactor'] = float(line.split('Viewfactor=\"')[-1].split('\"')[0])\n        \n        #Try to extract the polygons from the file.\n        if polygonTrigger == True:\n            if '<Polygon ID' in line:\n                newPolygonTrigger = True\n                polygonVertices = []\n                polygonMaterials.append(line.split('Material=\"')[-1].split('\" ')[0].upper())\n            elif '</Polygon>' in line:\n                newPolygonTrigger = False\n                #Make the vertices into a brep and append it to the list.\n                polygonLineGeo = rc.Geometry.PolylineCurve(polygonVertices)\n                closingLine = rc.Geometry.PolylineCurve([polygonLineGeo.PointAtStart, polygonLineGeo.PointAtEnd])\n                allPolygonLine = rc.Geometry.PolylineCurve.JoinCurves([polygonLineGeo, closingLine], sc.doc.ModelAbsoluteTolerance)[0]\n                finalPolygonGeo = rc.Geometry.Brep.CreatePlanarBreps(allPolygonLine)[0]\n                thermPolygons.append(finalPolygonGeo)\n            elif '<Point index=' in line:\n                xCoord = float(line.split('x=\"')[-1].split('\"')[0])\n                yCoord = float(line.split('y=\"')[-1].split('\"')[0])\n                polygonVertex = rc.Geometry.Point3d(xCoord, yCoord, 0)\n                polygonVertices.append(polygonVertex)\n        \n        #Try to extract the BC segments.\n        if BCSegmentsTrigger == True:\n            if 'Adiabatic' in line or 'Frame Cavity Surface' in line: grabPtData = False\n            elif '<BCPolygon ID' in line:\n                grabPtData = True\n                BCTypeName = line.split('BC=\"')[-1].split('\" units=')[0]\n                for count, BCTpy in enumerate(BCTypeNames):\n                    if BCTpy == BCTypeName: BCindex = count\n            elif grabPtData == True and '<Point index=\"0\"' in line:\n                x1 = float(line.split('x=\"')[-1].split('\" ')[0])\n                y1 = float(line.split('y=\"')[-1].split('\" />')[0])\n            elif grabPtData == True and '<Point index=\"1\"' in line:\n                x2 = float(line.split('x=\"')[-1].split('\" ')[0])\n                y2 = float(line.split('y=\"')[-1].split('\" />')[0])\n                BCSegments[BCindex].append(rc.Geometry.LineCurve(rc.Geometry.Point3d(x1,y1,0), rc.Geometry.Point3d(x2,y2,0)))\n        \n    thermFi.close()\n    \n    #Check to see if there is a base plane override connected to the component.\n    if basePlane_ != None:\n        planeReorientation = rc.Geometry.Transform.ChangeBasis(rc.Geometry.Plane.WorldXY, rc.Geometry.Plane(rc.Geometry.Point3d.Origin, basePlane_.XAxis, basePlane_.YAxis))\n        rhinoOrig = basePlane_.Origin\n        plane = basePlane_\n    \n    #Transform the geometry to be at the correct scale in the Rhino scene.\n    for geo in thermPolygons: geo.Transform(unitsScale)\n    for geoList in BCSegments:\n        for geo in geoList: geo.Transform(unitsScale)\n    if planeReorientation != None:\n        for geo in thermPolygons: geo.Transform(planeReorientation)\n        for geoList in BCSegments:\n            for geo in geoList: geo.Transform(planeReorientation)\n        joinedPolygons = rc.Geometry.Brep.JoinBreps(thermPolygons, sc.doc.ModelAbsoluteTolerance)[0]\n        thermBB = joinedPolygons.GetBoundingBox(rc.Geometry.Plane.WorldXY)\n        thermOrigin = rc.Geometry.BoundingBox.Corner(thermBB, True, True, True)\n        vecDiff = rc.Geometry.Point3d.Subtract(rhinoOrig, thermOrigin)\n        planeTransl = rc.Geometry.Transform.Translation(vecDiff.X, vecDiff.Y, vecDiff.Z)\n        for geo in thermPolygons: geo.Transform(planeTransl)\n        for geoList in BCSegments:\n            for geo in geoList: geo.Transform(planeTransl)\n    \n    #Create the THERM Polygons.\n    for count, geo in enumerate(thermPolygons):\n        guid = str(uuid.uuid4())\n        polyName = \"\".join(guid.split(\"-\")[:-1])\n        HBThermPolygon = hb_thermPolygon(geo.Faces[0].DuplicateFace(False), polygonMaterials[count], polyName, plane, None)\n        if HBThermPolygon.warning != None:\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, HBThermPolygon.warning)\n        else:\n            thermPolygonsFinal.append(HBThermPolygon)\n    #Add All THERM Polygons to the hive.\n    thermPolygonsFin = hb_hive.addToHoneybeeHive(thermPolygonsFinal, ghenv.Component)\n    \n    #Create the THERM BCs.\n    for bcCount, segList in enumerate(BCSegments):\n        allSeg = rc.Geometry.PolylineCurve.JoinCurves(segList)\n        for seg in allSeg:\n            try:\n                partsOfSeg = seg.DuplicateSegments()\n                segPts =[partsOfSeg[0].PointAtStart]\n                for part in partsOfSeg: segPts.append(part.PointAtEnd)\n            except:\n                segPts = [seg.PointAtStart, seg.PointAtEnd]\n            finalGeo = rc.Geometry.PolylineCurve(segPts)\n            HBThermBC = hb_thermBC(finalGeo, BCTypes[bcCount]['Name'].title(), BCTypes[bcCount]['Temperature'], BCTypes[bcCount]['filmCoefficient'], plane, BCTypes[bcCount]['radTemp'], None, None, None, None, BCTypes[bcCount]['Viewfactor'], BCTypes[bcCount]['envEmiss'], BCTypes[bcCount]['HeatFlux'])\n            thermBound  = hb_hive.addToHoneybeeHive([HBThermBC], ghenv.Component, False)\n            thermBCs.extend(thermBound)\n            \n    \n    return thermPolygonsFin, thermBCs\n\n\n#If Honeybee or Ladybug is not flying or is an older version, give a warning.\ninitCheck = True\n\n#Ladybug check.\nif not sc.sticky.has_key('ladybug_release') == True:\n    initCheck = False\n    print \"You should first let Ladybug fly...\"\n    ghenv.Component.AddRuntimeMessage(w, \"You should first let Ladybug fly...\")\nelse:\n    try:\n        if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): initCheck = False\n    except:\n        initCheck = False\n        warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n        \"Use updateLadybug component to update userObjects.\\n\" + \\\n        \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n        \"into canvas and try again.\"\n        ghenv.Component.AddRuntimeMessage(w, warning)\n#Honeybee check.\nif not sc.sticky.has_key('honeybee_release') == True:\n    initCheck = False\n    print \"You should first let Honeybee fly...\"\n    ghenv.Component.AddRuntimeMessage(w, \"You should first let Honeybee fly...\")\nelse:\n    try:\n        if not sc.sticky['honeybee_release'].isCompatible(ghenv.Component): initCheck = False\n        if sc.sticky['honeybee_release'].isInputMissing(ghenv.Component): initCheck = False\n    except:\n        initCheck = False\n        warning = \"You need a newer version of Honeybee to use this compoent.\" + \\\n        \"Use updateHoneybee component to update userObjects.\\n\" + \\\n        \"If you have already updated userObjects drag Honeybee_Honeybee component \" + \\\n        \"into canvas and try again.\"\n        ghenv.Component.AddRuntimeMessage(w, warning)\n\n\n#If the intital check is good, run the component.\nif initCheck and _thermXMLFile:\n    result = main(_thermXMLFile)\n    if result != -1:\n        thermPolygons, thermBCs = result\n",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}