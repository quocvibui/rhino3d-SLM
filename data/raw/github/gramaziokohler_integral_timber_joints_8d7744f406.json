{
  "source_url": "https://github.com/gramaziokohler/integral_timber_joints/blob/d543a28ccfaeb8a56ff692a29d5510c3e649477f/src/integral_timber_joints/ghpython/utilities.py",
  "repo": "gramaziokohler/integral_timber_joints",
  "repo_stars": 11,
  "repo_description": "Robotic Assembled Timber Structures with Integral Timber Joints",
  "license": "MIT",
  "filepath": "src/integral_timber_joints/ghpython/utilities.py",
  "instruction": "Utilities",
  "code": "import errno\nimport os\nimport sys\n\nimport compas.geometry as cg\nimport ghpythonlib.components as ghcomp\nimport Rhino\nimport Rhino.Geometry as rg\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nfrom compas.datastructures.mesh import Mesh\nfrom compas.geometry import Frame\nfrom Grasshopper import DataTree as Tree\nfrom Grasshopper.Kernel.Data import GH_Path as Path\nfrom System import Array\n\n# --------------------------------------------------\n\n# Rhino.Geometry <> list\n\n\ndef list2rPt(a):\n    return rg.Point3d(a[0], a[1], a[2])\n\n\ndef list2rVec(a):\n    return rg.Vector3d(a[0], a[1], a[2])\n\n\ndef rVec2list(v):\n    return [v.X, v.Y, v.Z]\n\n\ndef rPt2list(p):\n    return [p.X, p.Y, p.Z]\n\n\ndef list2rLine(a):\n    # tuple or list of two tuples/lists with 3 coordinates each\n    return rg.Line(list2rPt(a[0]), list2rPt(a[1]))\n\n\ndef cVec2list(v):\n    return [v.x, v.y, v.z]\n\n\ndef cPt2list(p):\n    return [p.x, p.y, p.z]\n\n# Rhino.Geometry <> compas.geometry\n\n\ndef cLine2rLine(L):\n    return rg.Line(list2rPt(L[0]), list2rPt(L[1]))\n\n\ndef cFrame2rPlane(frame):\n    return rg.Plane(list2rPt(frame.point), list2rVec(frame.xaxis), list2rVec(frame.yaxis))\n\n\ndef cPln2rPln(pln):\n    return rg.Plane(list2rPt(pln.point), list2rVec(pln.normal))\n\n\ndef cPt2rPt(cPt):\n    # return rg.Point3d(cPt['x'], cPt['y'], cPt['z']) #old version?\n    return rg.Point3d(cPt.x, cPt.y, cPt.z)\n\n\ndef rPt2cPt(rPt):\n    return cg.Point(rPt.X, rPt.Y, rPt.Z)\n\n\ndef cVec2rVec(v):\n    return rg.Vector3d(v.x, v.y, v.z)\n\n\ndef rVec2cVec(v):\n    return cg.Vector(v.X, v.Y, v.Z)\n\n\ndef rPlane2cFrame(plane):\n    return Frame(plane.Origin, plane.XAxis, plane.YAxis)\n\n\n# other\ndef rMesh_from8points(pts):\n    M = rg.Mesh()\n    for pt in pts:\n        M.Vertices.Add(pt)\n\n    M.Faces.AddFace(0, 4, 7, 3)\n    M.Faces.AddFace(1, 5, 6, 2)\n    M.Faces.AddFace(2, 6, 7, 3)\n    M.Faces.AddFace(3, 7, 4, 0)\n    M.Faces.AddFace(0, 1, 2, 3)\n    M.Faces.AddFace(4, 5, 6, 7)\n    return M\n\n\ndef rMesh_fromBeam(beam):\n    pts = [list2rPt(p) for p in beam.corners]\n    return rMesh_from8points(pts)\n\n\ndef rBrep_fromBeam(beam):\n    pts = [list2rPt(p) for p in beam.corners]\n    B = rg.Brep.CreateFromBox(pts)\n    # B.Flip()\n    return B\n\n\ndef cMesh2rMesh(mesh):\n    # convert compas mesh to rhino mesh\n    # TODO: not handling quad meshes yet!\n\n    vertices, faces = mesh.to_vertices_and_faces()\n    rhino_mesh = rg.Mesh()\n    for v in vertices:\n        rhino_mesh.Vertices.Add(list2rPt(v))\n    for f in faces:\n        rhino_mesh.Faces.AddFace(f[0], f[1], f[2])\n    return rhino_mesh\n\n\ndef rMesh2cMesh(rg_mesh):\n    if isinstance(rg_mesh, rg.Mesh):\n        # single mesh\n        compas_mesh_vertices = rg_mesh.Vertices.ToPoint3dArray()\n        compas_mesh_faces = rg_mesh.Faces.ToIntArray(True)\n        compas_mesh_faces = [compas_mesh_faces[i:i + 3] for i in range(0, len(compas_mesh_faces), 3)]\n        return Mesh.from_vertices_and_faces(compas_mesh_vertices, compas_mesh_faces)\n    else:\n        # array of meshes\n        meshes = []\n        for m in rg_mesh:\n            compas_mesh_vertices = m.Vertices.ToPoint3dArray()\n            compas_mesh_faces = m.Faces.ToIntArray(True)\n            compas_mesh_faces = [compas_mesh_faces[i:i + 3] for i in range(0, len(compas_mesh_faces), 3)]\n            meshes.append(Mesh.from_vertices_and_faces(compas_mesh_vertices, compas_mesh_faces))\n        return meshes\n\n# network functions\n\n\ndef get_network_rhino_axes(net):\n    new_axes = []\n    for edge in net.edges():\n        v1, v2 = net.edge_coordinates(edge[0], edge[1])\n        v1 = rs.coerce3dpoint(v1)\n        v2 = rs.coerce3dpoint(v2)\n        new_axes.append(rg.Line(v1, v2))\n    return new_axes\n\n\n# GH tree <-> lists\n\ndef tree_to_list(input, retrieve_base=lambda x: x[0]):\n    \"\"\"Returns a list representation of a Grasshopper DataTree\"\"\"\n    def extend_at(path, index, simple_input, rest_list):\n        target = path[index]\n        if len(rest_list) <= target:\n            rest_list.extend([None] * (target - len(rest_list) + 1))\n        if index == path.Length - 1:\n            rest_list[target] = list(simple_input)\n        else:\n            if rest_list[target] is None:\n                rest_list[target] = []\n            extend_at(path, index + 1, simple_input, rest_list[target])\n    all = []\n    for i in range(input.BranchCount):\n        path = input.Path(i)\n        extend_at(path, 0, input.Branch(path), all)\n    return retrieve_base(all)\n\n\ndef simple_tree_to_list(tree_input):\n    lst = []\n    for i in range(tree_input.BranchCount):\n        branchList = tree_input.Branch(i)\n        # branchPath = tree_input.Path(i)\n        b = []\n        for j in range(branchList.Count):\n            b.append(branchList[j])\n        lst.append(b)\n    return lst\n\n\ndef list_to_tree(alist, none_and_holes=False, base_path=[0]):\n    \"\"\"\n    Transforms nestings of lists or tuples to a Grasshopper DataTree\n    Usage:\n    mytree = [ [1,2], 3, [],[ 4,[5]] ]\n    a = list_to_tree(mytree)\n    b = list_to_tree(mytree, none_and_holes=True, base_path=[7,1])\n    \"\"\"\n    def process_one_item(alist, tree, track):\n        path = Path(Array[int](track))\n        if len(alist) == 0 and none_and_holes:\n            tree.EnsurePath(path)\n            return\n        for i, item in enumerate(alist):\n            if hasattr(item, '__iter__'):  # if list or tuple\n                track.append(i)\n                process_one_item(item, tree, track)\n                track.pop()\n            else:\n                if none_and_holes:\n                    tree.Insert(item, path, i)\n                elif item is not None:\n                    tree.Add(item, path)\n\n    tree = Tree[object]()\n    if alist is not None:\n        process_one_item(alist, tree, base_path[:])\n    return tree\n\n\ndef two_points_vector(p1, p2, unit):\n    vect = rg.Vector3d(p2.X - p1.X, p2.Y - p1.Y, p2.Z - p1.Z)\n    if unit:\n        vect.Unitize()\n    return vect\n\n\ndef pt_xyz_to_zyx(p):\n    return rg.Point3d(p.Z, p.Y, p.X)\n\n\ndef pt_zyx_to_xyz(p):\n    return rg.Point3d(p.Z, p.Y, p.X)\n\n\ndef sorted_zyx(pts_list):\n    temp_reversed_pts = [pt_xyz_to_zyx(p) for p in pts_list]\n    sorted_pts = ghcomp.SortPoints(temp_reversed_pts)[0]\n    return [pt_zyx_to_xyz(p) for p in sorted_pts]\n\n\ndef unify_beam_axis_orientation(a):\n    if isinstance(a, rg.Line):\n        start_pt = a.From\n        end_pt = a.To\n    else:\n        start_pt = a.PointAtStart\n        end_pt = a.PointAtEnd\n\n    pts_list = [start_pt, end_pt]\n    temp_reversed_pts = [pt_xyz_to_zyx(p) for p in pts_list]\n    sorted_pts = ghcomp.SortPoints(temp_reversed_pts)[0]\n    re_reversed_sorted_pts = [pt_zyx_to_xyz(p) for p in sorted_pts]\n\n    \"\"\"\n    if re_reversed_sorted_pts[0].Z < re_reversed_sorted_pts[1].Z:\n        pass\n    else:\n        print(\"SORTING ERROR\")\n    \"\"\"\n\n    return rg.Line(re_reversed_sorted_pts[0], re_reversed_sorted_pts[1])\n\n\n# Rhino export\n\ndef is_path_creatable(pathname=None):\n    \"\"\"\n    `True` if the current user has sufficient permissions to create the passed\n    pathname; `False` otherwise.\n    \"\"\"\n    # Parent directory of the passed path. If empty, we substitute the current\n    # working directory (CWD) instead.\n    dirname = os.path.dirname(pathname) or os.getcwd()\n    return os.access(dirname, os.W_OK)\n\n\ndef is_pathname_valid(pathname=None):\n    \"\"\"\n    `True` if the passed pathname is a valid pathname for the current OS;\n    `False` otherwise.\n    \"\"\"\n    # If this pathname is either not a string or is but is empty, this pathname\n    # is invalid.\n\n    ERROR_INVALID_NAME = 123\n\n    try:\n        if not isinstance(pathname, str) or not pathname:\n            return False\n\n        # Strip this pathname's Windows-specific drive specifier (e.g., `C:\\`)\n        # if any. Since Windows prohibits path components from containing `:`\n        # characters, failing to strip this `:`-suffixed prefix would\n        # erroneously invalidate all valid absolute Windows pathnames.\n        _, pathname = os.path.splitdrive(pathname)\n\n        # Directory guaranteed to exist. If the current OS is Windows, this is\n        # the drive to which Windows was installed (e.g., the \"%HOMEDRIVE%\"\n        # environment variable); else, the typical root directory.\n        root_dirname = os.environ.get('HOMEDRIVE', 'C:') \\\n            if sys.platform == 'win32' else os.path.sep\n        assert os.path.isdir(root_dirname)   # ...Murphy and her ironclad Law\n\n        # Append a path separator to this directory if needed.\n        root_dirname = root_dirname.rstrip(os.path.sep) + os.path.sep\n\n        # Test whether each path component split from this pathname is valid or\n        # not, ignoring non-existent and non-readable path components.\n        for pathname_part in pathname.split(os.path.sep):\n            try:\n                os.lstat(root_dirname + pathname_part)\n            # If an OS-specific exception is raised, its error code\n            # indicates whether this pathname is valid or not. Unless this\n            # is the case, this exception implies an ignorable kernel or\n            # filesystem complaint (e.g., path not found or inaccessible).\n            #\n            # Only the following exceptions indicate invalid pathnames:\n            #\n            # * Instances of the Windows-specific \"WindowsError\" class\n            #   defining the \"winerror\" attribute whose value is\n            #   \"ERROR_INVALID_NAME\". Under Windows, \"winerror\" is more\n            #   fine-grained and hence useful than the generic \"errno\"\n            #   attribute. When a too-long pathname is passed, for example,\n            #   \"errno\" is \"ENOENT\" (i.e., no such file or directory) rather\n            #   than \"ENAMETOOLONG\" (i.e., file name too long).\n            # * Instances of the cross-platform \"OSError\" class defining the\n            #   generic \"errno\" attribute whose value is either:\n            #   * Under most POSIX-compatible OSes, \"ENAMETOOLONG\".\n            #   * Under some edge-case OSes (e.g., SunOS, *BSD), \"ERANGE\".\n            except OSError as exc:\n                if hasattr(exc, 'winerror'):\n                    if exc.winerror == ERROR_INVALID_NAME:\n                        return False\n                elif exc.errno in {errno.ENAMETOOLONG, errno.ERANGE}:\n                    return False\n    # If a \"TypeError\" exception was raised, it almost certainly has the\n    # error message \"embedded NUL character\" indicating an invalid pathname.\n    except TypeError as exc:\n        return False, exc\n    # If no exception was raised, all path components and hence this\n    # pathname itself are valid. (Praise be to the curmudgeonly python.)\n    else:\n        return True\n    # If any other exception was raised, this is an unrelated fatal issue\n    # (e.g., a bug). Permit this exception to unwind the call stack.\n    #\n    # Did we mention this should be shipped with Python already?\n\n\ndef is_path_exists_or_creatable(pathname=None):\n    \"\"\"\n    `True` if the passed pathname is a valid pathname for the current OS _and_\n    either currently exists or is hypothetically creatable; `False` otherwise.\n\n    This function is guaranteed to _never_ raise exceptions.\n    \"\"\"\n    try:\n        # To prevent \"os\" module calls from raising undesirable exceptions on\n        # invalid pathnames, is_pathname_valid() is explicitly called first.\n        return is_pathname_valid(pathname) and (os.path.exists(pathname) or is_path_creatable(pathname))\n    # Report failure on non-fatal filesystem complaints (e.g., connection\n    # timeouts, permissions issues) implying this path to be inaccessible. All\n    # other exceptions are unrelated fatal issues and should not be caught here.\n    except OSError:\n        return False\n\n\ndef exportByLayer(fileName, fileFolderPath, layerNames, ghdoc):\n\n    if not os.path.isdir(fileFolderPath):\n        os.mkdir(fileFolderPath)\n    fileNameFolderPath = os.path.join(fileFolderPath, fileName)\n\n    sc.doc = Rhino.RhinoDoc.ActiveDoc\n    selectTheObjects = True\n    for layerName in layerNames:\n        # 'objIds_perLayer' is assigned to but never used\n        objIds_perLayer = rs.ObjectsByLayer(layerName, selectTheObjects)  # select the geometires for export\n\n    fileNameFolderPath2 = chr(34) + fileNameFolderPath + chr(34)\n    commandString = \"_-Export \" + fileNameFolderPath2 + \" _Enter _Enter _Enter\"\n\n    echo = False\n    done = rs.Command(commandString, echo)\n    if done:\n        print(\"Geometry successfully exported from the following layers %s\\nto: %s\" % (layerNames, fileNameFolderPath))\n    else:\n        print(\"Something went wrong. Export terminated\")\n\n    rs.UnselectAllObjects()\n\n    sc.doc = ghdoc\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}