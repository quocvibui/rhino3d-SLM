{
  "source_url": "https://github.com/dbt-ethz/Axolotl_Python/blob/0938046ecc5e50645d241a330b57734767958b07/_old_axolotl-1.0/code/object_combinations/combination_operators.py",
  "repo": "dbt-ethz/Axolotl_Python",
  "repo_stars": 59,
  "repo_description": "Volumetric Modelling components for Rhino Grasshopper.",
  "license": "unknown",
  "filepath": "_old_axolotl-1.0/code/object_combinations/combination_operators.py",
  "instruction": "returns various alternative combinations between A and B",
  "code": "#!/usr/bin/env python2\n# -*- coding: utf-8 -*-\n\n\"\"\"\nreturns various alternative combinations between A and B\n\"\"\"\n__author__     = ['Mathias Bernhard']\n__copyright__  = 'Copyright 2018 / Digital Building Technologies DBT / ETH Zurich'\n__license__    = 'MIT License'\n__email__      = '<bernhard@arch.ethz.ch>'\n\n\"\"\"\noriginal GLSL implementation by MERCURY http://mercury.sexy/hg_sdf\nJava port by W:Blut (Frederik Vanhoutte): https://github.com/wblut/HE_Mesh/blob/master/src/math/wblut/math/WB_SDF.java\n\"\"\"\n\n\"\"\"\noriginal copyright note:\n\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2016-01-10\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n//\n// How to use this:\n//\n// 1. Build some system to #include glsl files in each other.\n//   Include this one at the very start. Or just paste everywhere.\n// 2. Build a sphere tracer. See those papers:\n//   * \"Sphere Tracing\" http://graphics.cs.illinois.edu/sites/default/files/zeno.pdf\n//   * \"Enhanced Sphere Tracing\" http://lgdv.cs.fau.de/get/2234\n//   The Raymnarching Toolbox Thread on pouet can be helpful as well\n//   http://www.pouet.net/topic.php?which=7931&page=1\n//   and contains links to many more resources.\n// 3. Use the tools in this library to build your distance bound f().\n// 4. ???\n// 5. Win a compo.\n//\n// (6. Buy us a beer or a good vodka or something, if you like.)\n//\n////////////////////////////////////////////////////////////////\n//\n// Table of Contents:\n//\n// * Helper functions and macros\n// * Collection of some primitive objects\n// * Domain Manipulation operators\n// * Object combination operators\n//\n////////////////////////////////////////////////////////////////\n//\n// Why use this?\n//\n// The point of this lib is that everything is structured according\n// to patterns that we ended up using when building geometry.\n// It makes it more easy to write code that is reusable and that somebody\n// else can actually understand. Especially code on Shadertoy (which seems\n// to be what everybody else is looking at for \"inspiration\") tends to be\n// really ugly. So we were forced to do something about the situation and\n// release this lib ;)\n//\n// Everything in here can probably be done in some better way.\n// Please experiment. We'd love some feedback, especially if you\n// use it in a scene production.\n//\n// The main patterns for building geometry this way are:\n// * Stay Lipschitz continuous. That means: don't have any distance\n//   gradient larger than 1. Try to be as close to 1 as possible -\n//   Distances are euclidean distances, don't fudge around.\n//   Underestimating distances will happen. That's why calling\n//   it a \"distance bound\" is more correct. Don't ever multiply\n//   distances by some value to \"fix\" a Lipschitz continuity\n//   violation. The invariant is: each fSomething() function returns\n//   a correct distance bound.\n// * Use very few primitives and combine them as building blocks\n//   using combine opertors that preserve the invariant.\n// * Multiply objects by repeating the domain (space).\n//   If you are using a loop inside your distance function, you are\n//   probably doing it wrong (or you are building boring fractals).\n// * At right-angle intersections between objects, build a new local\n//   coordinate system from the two distances to combine them in\n//   interesting ways.\n// * As usual, there are always times when it is best to not follow\n//   specific patterns.\n//\n////////////////////////////////////////////////////////////////\n//\n// FAQ\n//\n// Q: Why is there no sphere tracing code in this lib?\n// A: Because our system is way too complex and always changing.\n//    This is the constant part. Also we'd like everyone to\n//    explore for themselves.\n//\n// Q: This does not work when I paste it into Shadertoy!!!!\n// A: Yes. It is GLSL, not GLSL ES. We like real OpenGL\n//    because it has way more features and is more likely\n//    to work compared to browser-based WebGL. We recommend\n//    you consider using OpenGL for your productions. Most\n//    of this can be ported easily though.\n//\n// Q: How do I material?\n// A: We recommend something like this:\n//    Write a material ID, the distance and the local coordinate\n//    p into some global variables whenever an object's distance is\n//    smaller than the stored distance. Then, at the end, evaluate\n//    the material to get color, roughness, etc., and do the shading.\n//\n// Q: I found an error. Or I made some function that would fit in\n//    in this lib. Or I have some suggestion.\n// A: Awesome! Drop us a mail at spheretracing@mercury.sexy.\n//\n// Q: Why is this not on github?\n// A: Because we were too lazy. If we get bugged about it enough,\n//    we'll do it.\n//\n// Q: Your license sucks for me.\n// A: Oh. What should we change it to?\n//\n// Q: I have trouble understanding what is going on with my distances.\n// A: Some visualization of the distance field helps. Try drawing a\n//    plane that you can sweep through your scene with some color\n//    representation of the distance field at each point and/or iso\n//    lines at regular intervals. Visualizing the length of the\n//    gradient (or better: how much it deviates from being equal to 1)\n//    is immensely helpful for understanding which parts of the\n//    distance field are broken.\n//\n////////////////////////////////////////////////////////////////\n\n\"\"\"\n\nimport rhinoscriptsyntax as rs\nimport math\nimport Rhino.Geometry as rg\n\n\"\"\"\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\"\"\"\ndef get_groove(a,b):\n    return max(a, min(a + ra, rb - abs(b)))\n\ndef get_addition_chamfer(a,b):\n    return min(min(a, b), (a - ra + b) * math.sqrt(0.5))\n\ndef get_intersection_chamfer(a,b):\n    return max(max(a, b), (a + ra + b) * math.sqrt(0.5))\n\ndef get_subtraction_chamfer(a,b):\n    return get_intersection_chamfer(a,-b)\n\ndef get_addition_stairs(a,b):\n    s = ra / n;\n    u = b - ra;\n    return min(min(a, b), 0.5 * (u + a + abs((u - a + s) % (2 * s) - s)))\n\ndef get_intersection_stairs(a,b):\n    return -get_addition_stairs(-a,-b)\n\ndef get_subtraction_stairs(a,b):\n    return -get_addition_stairs(-a,b)\n\ndef get_tongue(a,b):\n    return min(a, max(a - ra, abs(b) - rb))\ndef get_v_engrave(a,b):\n    return max(a, (a + ra - abs(b)) * math.sqrt(0.5))\ndef get_pipe(a,b):\n    l = math.sqrt(a*a+b*b)\n    return l - ra\n\ndef get_addition_round(a,b):\n    v1 = rg.Vector2d(ra-a,ra-b)\n    v2 = rg.Vector2d(0,0)\n    u = max2D(v1,v2)\n    return max(ra, min(a, b)) - u.Length\n\ndef get_intersection_round(a,b):\n    u = max2D(rg.Vector2d(ra + a, ra + b), rg.Vector2d(0, 0))\n    return min(-ra, max(a, b)) + u.Length\n\ndef get_subtraction_round(a,b):\n    return get_intersect_round(a,-b)\n\ndef get_addition_columns(a,b):\n    sq2 = math.sqrt(2.0)\n    if a<ra and b<ra:\n        p = rg.Vector2d(a,b)\n        columnradius = ra * sq2 / ((n-1) * 2 + sq2)\n        p = rot45(p)\n        p = rs.VectorSubtract(p,rg.Vector3d(sq2 / 2 * ra,0,0))\n        p = rs.VectorAdd(p,rg.Vector3d(columnradius*sq2,columnradius*sq2,0))\n        if n%2==1:\n            p = rs.VectorAdd(p,rg.Vector3d(0,columnradius,0))\n        p.Y = mod1(p.Y, columnradius*2)\n        result = p.Length-columnradius\n        result = min(result, p.X)\n        result = min(result, a)\n        return min(result, b)\n    else:\n        return min(a,b)\n\ndef get_subtraction_columns(a,b):\n    sq2 = math.sqrt(2.0)\n    a = -a\n    m = min(a,b)\n    if a<ra and b<ra:\n        p = rg.Vector2d(a,b)\n        columnradius = ra * sq2 / ((n-1) * 2 + sq2)\n        p = rot45(p)\n        p = rs.VectorAdd(p,rg.Vector3d(0,columnradius,0))\n        p = rs.VectorSubtract(p,rg.Vector3d(sq2 / 2 * ra,sq2 / 2 * ra, 0))\n        p = rs.VectorAdd(p,rg.Vector3d(-columnradius*sq2/2,-columnradius*sq2/2,0))\n        if n%2==1:\n            p = rs.VectorAdd(p,rg.Vector3d(0,columnradius,0))\n        p.Y = mod1(p.Y, columnradius*2)\n        result = -p.Length+columnradius\n        result = max(result,p.X)\n        result = min(result,a)\n        return -min(result,b)\n    else:\n        return -m\n\ndef get_intersection_columns(a,b):\n    return get_subtraction_columns(a,-b)\n\n\"\"\"\nHELPER FUNCTIONS\n\"\"\"\ndef rot45(v):\n    f = math.sqrt(0.5)\n    vo = rg.Vector3d((v.X+v.Y)*f, (v.Y-v.X)*f,0)\n    return vo\n\ndef mod1(p,size):\n    halfsize = size * 0.5\n    p = (p + halfsize) % size - halfsize\n    return p\n\ndef max2D(v,w):\n    return rg.Vector2d(max(v.X, w.X), max(v.Y, w.Y))\n\n# input check\nif not ra:\n    ra = 2.0\nif not rb:\n    rb = ra\nif not n:\n    n = 3\nif not mode:\n    mode = 0\nif mode > 15:\n    mode = 0\n\n# switch mode\nvals = [9999.9 for _ in A]\nif mode==0:\n    vals = [get_addition_chamfer(u,v) for u,v in zip(A,B)]\nelif mode==1:\n    vals = [get_intersection_chamfer(u,v) for u,v in zip(A,B)]\nelif mode==2:\n    vals = [get_subtraction_chamfer(u,v) for u,v in zip(A,B)]\nelif mode==3:\n    vals = [get_addition_round(u,v) for u,v in zip(A,B)]\nelif mode==4:\n    vals = [get_intersection_round(u,v) for u,v in zip(A,B)]\nelif mode==5:\n    vals = [get_subtraction_round(u,v) for u,v in zip(A,B)]\nelif mode==6:\n    vals = [get_addition_columns(u,v) for u,v in zip(A,B)]\nelif mode==7:\n    vals = [get_intersection_columns(u,v) for u,v in zip(A,B)]\nelif mode==8:\n    vals = [get_subtraction_columns(u,v) for u,v in zip(A,B)]\nelif mode==9:\n    vals = [get_addition_stairs(u,v) for u,v in zip(A,B)]\nelif mode==10:\n    vals = [get_intersection_stairs(u,v) for u,v in zip(A,B)]\nelif mode==11:\n    vals = [get_subtraction_stairs(u,v) for u,v in zip(A,B)]\nelif mode==12:\n    vals = [get_groove(u,v) for u,v in zip(A,B)]\nelif mode==13:\n    vals = [get_tongue(u,v) for u,v in zip(A,B)]\nelif mode==14:\n    vals = [get_v_engrave(u,v) for u,v in zip(A,B)]\nelif mode==15:\n    vals = [get_pipe(u,v) for u,v in zip(A,B)]\n\n# return list\na = vals\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}