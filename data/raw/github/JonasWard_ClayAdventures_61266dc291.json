{
  "source_url": "https://github.com/JonasWard/ClayAdventures/blob/70e453eab058ddb92ad4ee34f3148155e4c1cf31/src/ghPython/PatternBrickLibrary/base_mesh.py",
  "repo": "JonasWard/ClayAdventures",
  "repo_stars": 3,
  "repo_description": "A width range of different tests and experiments for fdm clay printing",
  "license": "MIT",
  "filepath": "src/ghPython/PatternBrickLibrary/base_mesh.py",
  "instruction": "Base mesh",
  "code": "import Rhino.Geometry as rg\nimport vertexClass_v1 as vc\n\nclass MeshObject:\n    TRI = True\n\n    def __init__(self, plane, width, height, spacing):\n        self.pln = plane\n        self.w = width\n        self.h = height\n        self.s = spacing\n\n        self.x = int(width / spacing)\n        self.y = int(height / spacing)\n\n        self.front_pts = []\n        self._front_init = False\n        self.back_pts = []\n\n    def construct_pts(self):\n        b_pt = self.pln.Origin\n        x_a = self.pln.XAxis\n        y_a = self.pln.YAxis\n        z_a = self.pln.ZAxis\n\n        for i in range(self.x + 1):\n            for j in range(self.y + 1):\n                self.front_pts.append(b_pt + x_a * (i - .5 * self.x) * self.s + y_a * j * self.s )\n\n        for i in range(self.x + 1):\n            for j in range(self.y + 1):\n                self.back_pts.append(b_pt + x_a * (i - .5 * self.x) * self.s + y_a * j * self.s + z_a * self.s )\n\n\n    def add_front_pts(self, pts, inverse = False):\n        if inverse:\n            self.front_pts = self._invert_points(pts)\n        else:\n            self.front_pts = pts\n        \n        self._front_init = True\n\n    def adjusting_front_pts(self):\n        # adjusting the front points based on their distance to the base plane\n        if self._front_init:\n\n            distances = []\n            b_pts = []\n\n            for pt in self.front_pts:\n                c_pt = self.pln.ClosestPoint(pt)\n                b_pts.append(c_pt)\n                distances.append(rg.Vector3d.Multiply(rg.Vector3d(pt - c_pt),self.pln.ZAxis))\n            \n            self.front_pts = []\n            min_val = min(distances)\n            print(min_val)\n            for i, b_pt in enumerate(b_pts):\n                self.front_pts.append(b_pt + (distances[i] - min_val) * self.pln.ZAxis)\n        else:\n            print(\"Front has not been set\")\n\n    def construct_layers(self):\n        layer_set = []\n        m = self.x + 1\n        n = self.y + 1\n\n        for i in range(self.y + 1):\n            y_val = i * self.s\n\n            local_layer = []\n\n            for j in range(self.x + 1):\n                x_val = j * self.s\n                    \n                loc_pt = self.front_pts[i + j * n]\n                \n                loc_vertex = vc.Vertex(loc_pt, -self.pln.ZAxis, x_val, y_val)\n                \n                local_layer.append(loc_vertex)\n            layer_set.append(local_layer)\n                \n        return layer_set\n\n    def _invert_points(self, pt_list):\n        m = self.x + 1\n\n        inverse_pt_list = [[] for i in range(m)]\n\n        for idx, pt in enumerate(pt_list):\n            m_val = idx % m\n            n_val = int ( (idx - m_val) / m )\n            \n            inverse_pt_list[m_val].append(pt)\n            \n        n_pt_list = []\n\n        for pt_set in inverse_pt_list:\n            n_pt_list.extend(pt_set)\n            \n        return n_pt_list\n\n    def construct_graph(self):\n        cnt = len(self.back_pts)\n\n        face_list = []\n\n        if MeshObject.TRI:\n            for i in range(self.x):\n                id_x_a = i * (self.y + 1)\n                id_x_b = (i + 1) * (self.y + 1)\n                for j in range(self.y):\n                    print(id_x_a + j, id_x_a + j + 1, id_x_b + j + 1, id_x_b + j )\n                    face_list.append([id_x_a + j, id_x_a + j + 1, id_x_b + j + 1])\n                    face_list.append([id_x_a + j, id_x_b + j + 1, id_x_b + j])\n                    face_list.append([id_x_b + j + cnt, id_x_b + j + 1 + cnt, id_x_a + j + 1 + cnt, id_x_a + j + cnt])\n\n        else:\n            for i in range(self.x):\n                id_x_a = i * (self.y + 1)\n                id_x_b = (i + 1) * (self.y + 1)\n                for j in range(self.y):\n                    print(id_x_a + j, id_x_a + j + 1, id_x_b + j + 1, id_x_b + j )\n                    face_list.append([id_x_a + j, id_x_a + j + 1, id_x_b + j + 1, id_x_b + j])\n                    face_list.append([id_x_b + j + cnt, id_x_b + j + 1 + cnt, id_x_a + j + 1 + cnt, id_x_a + j + cnt])\n\n        for i in range(self.x):\n            id_x_a = i * (self.y + 1)\n            id_x_b = (i + 1) * (self.y + 1)\n\n            face_list.append([id_x_a, id_x_b, cnt + id_x_b, cnt + id_x_a])\n            face_list.append([cnt + id_x_a + self.y, cnt + id_x_b + self.y, id_x_b + self.y, id_x_a + self.y])\n                \n        for i in range(self.y):\n            face_list.append([cnt + i, cnt + i + 1, i + 1, i])\n            face_list.append([(self.y + 1) * self.x + i, (self.y + 1) * self.x + i + 1, (self.y + 1) * self.x + cnt + i + 1, (self.y + 1) * self.x + cnt + i])\n\n        return face_list\n\n    def construct_mesh(self):\n        msh = rg.Mesh()\n        if self._front_init:\n            # initializing the points\n            for pt in self.front_pts + self.back_pts:\n                msh.Vertices.Add(pt)\n\n            for f in self.construct_graph():\n                if len(f) == 4:\n                    msh.Faces.AddFace(f[0], f[1], f[2], f[3])\n                elif len(f) == 3:\n                    msh.Faces.AddFace(f[0], f[1], f[2])\n\n            return msh\n        else:\n            print(\"Front has not been set\")\n            return msh",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}