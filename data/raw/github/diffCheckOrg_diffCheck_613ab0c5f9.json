{
  "source_url": "https://github.com/diffCheckOrg/diffCheck/blob/8f668b1f273e8d81a282c6115ba3eae07eef9235/src/gh/diffCheck/diffCheck/df_visualization.py",
  "repo": "diffCheckOrg/diffCheck",
  "repo_stars": 15,
  "repo_description": "diffCheck is a CAD-integrated tool for evaluating digital timber fabrication processes.",
  "license": "GPL-3.0",
  "filepath": "src/gh/diffCheck/diffCheck/df_visualization.py",
  "instruction": "This module contains the utility functions to visualize differences",
  "code": "#! python3\n\"\"\"\n    This module contains the utility functions to visualize differences\n\"\"\"\nimport Rhino\nimport scriptcontext as sc\nimport Rhino.Geometry as rg\nfrom System.Drawing import Color\nfrom diffCheck import df_visualization\nimport numpy as np\n\n\nclass DFVizSettings:\n    \"\"\"\n    This class compiles the settings for the visualization into one object\n    \"\"\"\n\n    def __init__(self,\n        valueType,\n        palette,\n        upper_threshold,\n        lower_threshold,\n        legend_height,\n        legend_width,\n        legend_plane,\n        histogram_scale_factor,\n        one_histogram_per_item):\n\n        self.valueType = valueType\n        self.palette = df_visualization.DFColorMap(palette)\n        self.upper_threshold = upper_threshold\n        self.lower_threshold = lower_threshold\n        self.legend_height = legend_height\n        self.legend_width = legend_width\n        self.legend_plane = legend_plane\n        self.histogram_scale_factor = histogram_scale_factor\n        self.one_histogram_per_item = one_histogram_per_item\n\n        self.str_repr = f\"DFVizSettings: \\n\\t- Value type: {self.valueType}\\n\\t- Palette: {self.palette}\\n\\t- Upper threshold: {self.upper_threshold}\\n\\t- Lower threshold: {self.lower_threshold}\\n\\t- Legend height: {self.legend_height}\\n\\t- Legend width: {self.legend_width}\\n\\t- Legend plane: {self.legend_plane}\\n\\t- Histogram scale factor: {self.histogram_scale_factor}\"\n\n    def __repr__(self):\n        return self.str_repr\n    def __str__(self):\n        return self.str_repr\n\nclass DFColorMap:\n    \"\"\"\n    This class defines different colormaps for visualization purposes\n    It allows selection of a colormap by name and initializes the corresponding color values.\n    \"\"\"\n\n    def __init__(self, name):\n        self.name = name\n        if self.name == \"Jet\":\n            self.colors = [\n                Color.FromArgb(0, 0, 255),  # Blue\n                Color.FromArgb(0, 255, 255),  # Cyan\n                Color.FromArgb(0, 255, 0),  # Green\n                Color.FromArgb(255, 255, 0),  # Yellow\n                Color.FromArgb(255, 0, 0),  # Red\n            ]\n        elif self.name == \"Rainbow\":\n            self.colors = [\n                Color.FromArgb(127, 0, 255),\n                Color.FromArgb(0, 180, 235),\n                Color.FromArgb(128, 254, 179),\n                Color.FromArgb(255, 178, 96),\n                Color.FromArgb(255, 6, 3)\n            ]\n        elif self.name == \"RdPu\":\n            self.colors = [\n                Color.FromArgb(254, 246, 242),\n                Color.FromArgb(251, 196, 191),\n                Color.FromArgb(246, 103, 160),\n                Color.FromArgb(172, 1, 125),\n                Color.FromArgb(76, 0, 106)\n            ]\n        elif self.name == \"Viridis\":\n            self.colors = [\n                Color.FromArgb(68, 3, 87),\n                Color.FromArgb(58, 82, 139),\n                Color.FromArgb(32, 144, 140),\n                Color.FromArgb(94, 201, 97),\n                Color.FromArgb(248, 230, 33)\n            ]\n\n    def interpolate_color(self, color1, color2, t):\n        \"\"\"\n        Interpolate between two colors.\n        \"\"\"\n\n        r = int(color1.R + (color2.R - color1.R) * t)\n        g = int(color1.G + (color2.G - color1.G) * t)\n        b = int(color1.B + (color2.B - color1.B) * t)\n\n        return Color.FromArgb(r, g, b)\n\n    def value_to_color(self, value, min_value, max_value):\n        \"\"\"\n        Map a value to a color based on a colormap.\n        \"\"\"\n\n        if value < min_value:\n            value = min_value\n        elif value > max_value:\n            value = max_value\n\n        colormap = self.colors\n\n        # Normalize the value within the range\n        if min_value == max_value:\n            t = 0.5\n        else:\n            t = (value - min_value) / (max_value - min_value)\n\n        # Determine the segment in the colormap\n        n = len(colormap) - 1\n        idx = int(t * n)\n        if idx >= n:\n            idx = n - 1\n        t = (t * n) - idx\n\n        # Interpolate between the two colors\n        color1 = colormap[idx]\n        color2 = colormap[idx + 1]\n\n        return self.interpolate_color(color1, color2, t)\n\n\ndef color_rh_pcd(pcd, values, min_value, max_value, palette):\n    \"\"\"\n    Colors a point cloud data based on given values and palette.\n    \"\"\"\n\n    for i, p in enumerate(pcd):\n        # check if values is a list\n        if isinstance(values, list):\n            mapped_color = palette.value_to_color(values[i], min_value, max_value)\n        else:\n            mapped_color = palette.value_to_color(values, min_value, max_value)\n\n        p.Color = mapped_color\n\n    return pcd\n\n\ndef color_rh_mesh(mesh, values, min_value, max_value, palette):\n    \"\"\"\n    Colors a mesh based on given values and palette.\n    \"\"\"\n\n    mesh.VertexColors.Clear()\n\n    for i, vertex in enumerate(mesh.Vertices):\n        # check if values is a list\n\n        if isinstance(values, np.ndarray) and values.size == 0:\n            mapped_color = Color.FromArgb(255, 255, 255)  # Color it white\n        elif isinstance(values, list):\n             # If values is a non-empty list\n            mapped_color = palette.value_to_color(values[i], min_value, max_value)\n        elif values is None:\n            # If values is not None and not empty (assuming it's a single value)\n            mapped_color = Color.FromArgb(255, 255, 255)\n        else:\n            mapped_color = palette.value_to_color(values, min_value, max_value)\n\n        mesh.VertexColors.Add(mapped_color.R, mapped_color.G, mapped_color.B)\n\n    return mesh\n\n\ndef create_legend(min_value, max_value, palette, steps=10, plane=rg.Plane.WorldXY,\n                  width=0.5, total_height=10, spacing=0):\n    \"\"\"\n    Create a legend in Rhino with colored hatches and text labels.\n    \"\"\"\n\n    height = total_height/steps\n\n    legend_geometry = []\n    rect_pts = []\n    previous_color = None\n\n    RhinoDoc = sc.doc\n    if RhinoDoc.ModelUnitSystem == Rhino.UnitSystem.Meters:\n        unit_str = \"[m]\"\n    elif RhinoDoc.ModelUnitSystem == Rhino.UnitSystem.Centimeters:\n        unit_str = \"[cm]\"\n    elif RhinoDoc.ModelUnitSystem == Rhino.UnitSystem.Millimeters:\n        unit_str = \"[mm]\"\n    elif RhinoDoc.ModelUnitSystem == Rhino.UnitSystem.Inches:\n        unit_str = \"[in]\"\n    elif RhinoDoc.ModelUnitSystem == Rhino.UnitSystem.Feet:\n        unit_str = \"[ft]\"\n    else:\n        unit_str = \"[yd]\"\n\n    # Add the unit label at the top of the legend\n    units_pt = rg.Point3d(0.5 * width , (steps + 1) * (height + spacing) - 0.5*height, 0)\n    units_text_entity = rg.TextEntity()\n    units_text_entity.Plane = rg.Plane(units_pt, rg.Vector3d.ZAxis)\n    units_text_entity.Text = unit_str\n    units_text_entity.TextHeight = height / 5\n    units_text_entity.Justification = rg.TextJustification.MiddleCenter\n    units_text_entity.DimensionLengthDisplay = Rhino.DocObjects.DimensionStyle.LengthDisplay.Millmeters\n    legend_geometry.append(units_text_entity)\n\n    for i in range(steps+1):\n\n        value = min_value + (max_value - min_value) * i / steps\n        color = palette.value_to_color(value, min_value, max_value)\n\n        if i > 0:\n            mesh = rg.Mesh()\n            for pt in rect_pts:\n                mesh.Vertices.Add(pt)\n\n            mesh.Faces.AddFace(0, 1, 2, 3)\n            # color mesh\n            mesh.VertexColors.Add(previous_color.R, previous_color.G, previous_color.B)\n            mesh.VertexColors.Add(previous_color.R, previous_color.G, previous_color.B)\n            mesh.VertexColors.Add(color.R, color.G, color.B)\n            mesh.VertexColors.Add(color.R, color.G, color.B)\n\n            polyline = rg.Polyline(rect_pts)\n\n            legend_geometry.append(mesh)\n            legend_geometry.append(polyline.ToPolylineCurve())\n\n        text_pt = rg.Point3d(1.25 * width + spacing, i * (height + spacing) + height / 10, 0)\n        text_entity = rg.TextEntity()\n        text_entity.Plane = rg.Plane(text_pt, rg.Vector3d.ZAxis)\n        # decide on resolution based on document units\n        if RhinoDoc.ModelUnitSystem == Rhino.UnitSystem.Meters:\n            text_entity.Text = f\"{value:.4f}\"\n        elif RhinoDoc.ModelUnitSystem == Rhino.UnitSystem.Centimeters:\n            text_entity.Text = f\"{value:.3f}\"\n        elif RhinoDoc.ModelUnitSystem == Rhino.UnitSystem.Millimeters:\n            text_entity.Text = f\"{value:.2f}\"\n        elif RhinoDoc.ModelUnitSystem == Rhino.UnitSystem.Inches:\n            text_entity.Text = f\"{value:.2f}\"\n        elif RhinoDoc.ModelUnitSystem == Rhino.UnitSystem.Feet:\n            text_entity.Text = f\"{value:.2f}\"\n        elif RhinoDoc.ModelUnitSystem == Rhino.UnitSystem.Yards:\n            text_entity.Text = f\"{value:.2f}\"\n\n        text_entity.TextHeight = height / 5\n        # match grasshopper display to default\n        text_entity.DimensionLengthDisplay = Rhino.DocObjects.DimensionStyle.LengthDisplay.Millmeters\n        legend_geometry.append(text_entity)\n\n        rect_pts = [\n            rg.Point3d(0, i * (height + spacing), 0),\n            rg.Point3d(0 + width, i * (height + spacing), 0),\n            rg.Point3d(0 + width, (i + 1) * height + i * spacing, 0),\n            rg.Point3d(0, (i + 1) * height + i * spacing, 0),\n        ]\n\n        previous_color = color\n\n    if plane != rg.Plane.WorldXY:\n        trans = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, plane)\n        for geo in legend_geometry:\n            geo.Transform(trans)\n\n    return legend_geometry\n\n\ndef create_histogram_curve(values, min_value, max_value, res=100, bin_size=1,\n                           height=1, scaling_factor=0.01, spacing=0):\n    # Initialize the frequency counts for each bin\n    frequencies = [0] * (res + 1)\n\n    if isinstance(values, list):\n        # Check if the list is non-empty and the first element is a list\n        if len(values) > 0 and isinstance(values[0], list):\n            # Flatten the nested list\n            values = [item for sublist in values for item in sublist]\n    else:\n        # If values is a scalar, wrap it in a list\n        values = [values]\n\n    # Count the frequencies of values in each bin\n    for value in values:\n        if value is None:\n            continue\n        if value < min_value:\n            value = min_value\n        elif value > max_value:\n            value = max_value\n        bin_index = (value - min_value) // bin_size\n        bin_index = int(bin_index)\n        frequencies[bin_index] += 1\n\n    # Normalize frequencies to percentages\n    total_values = len(values)\n    for i in range(res + 1):\n        frequencies[i] = round((frequencies[i] / total_values) * 100, 2)\n\n    # Create points for the polyline representing the histogram\n    points = []\n    max_frequency = max(frequencies)\n\n    for i in range(res+1):\n\n        bar_height = frequencies[i] * scaling_factor\n        points.append(rg.Point3d(- bar_height, i * (spacing + height), 0))\n\n    # Create the polyline and add it to the histogram geometry\n    polyline = rg.Curve.CreateInterpolatedCurve(points, 1)\n\n    return polyline, max_frequency\n\n\ndef create_histogram(values, min_value, max_value, res=100, steps=10,\n                     plane=rg.Plane.WorldXY, total_height=10,\n                     scaling_factor=0.01, multiple_curves=False, spacing=0):\n    \"\"\"\n    Create a histogram in Rhino with a polyline representing value frequencies.\n    \"\"\"\n    print(multiple_curves)\n    print(\"test\")\n\n    height = total_height/res\n\n    histogram_geometry = []\n\n    # Calculate the size of each bin\n    bin_size = (max_value - min_value) / res\n\n    max_frequency = 0\n\n    if multiple_curves:\n        for v in values:\n            if v is None:\n                continue\n            polyline, max_freq = create_histogram_curve(v, min_value, max_value, res,\n                                   bin_size, height,scaling_factor, spacing)\n\n            histogram_geometry.append(polyline)\n            if max_freq > max_frequency:\n                max_frequency = max_freq\n\n    else:\n        if values is None:\n            return None\n\n        polyline, max_frequency = create_histogram_curve(values, min_value, max_value, res,\n                                bin_size, height,scaling_factor, spacing)\n\n        histogram_geometry.append(polyline)\n\n    # Create rectangles to extend the value axis for better visualization\n    for i in range(steps):\n        rect_pts = [\n            rg.Point3d(0, i * (total_height/steps + spacing), 0),\n            rg.Point3d(-max_frequency*scaling_factor, i * (total_height/steps + spacing), 0),\n            rg.Point3d(-max_frequency*scaling_factor, (i + 1) * total_height/steps + i * spacing, 0),\n            rg.Point3d(0, (i + 1) * total_height/steps + i * spacing, 0),\n        ]\n        polyline = rg.Polyline(rect_pts)\n        histogram_geometry.append(polyline.ToPolylineCurve())\n\n    # Create the x-axis label only for the highest value (100%)\n    highest_value_pt = rg.Point3d(-max_frequency*scaling_factor - (total_height/steps)/5, -total_height/steps, 0)\n    highest_value_text = rg.TextEntity()\n    highest_value_text.Plane = rg.Plane(highest_value_pt, rg.Vector3d.YAxis, -rg.Vector3d.XAxis)  # Align text along Y-axis\n    highest_value_text.Text = str(max_frequency) + \"%\"\n    highest_value_text.TextHeight = (total_height/steps) / 5\n    highest_value_text.DimensionLengthDisplay = Rhino.DocObjects.DimensionStyle.LengthDisplay.Millmeters\n    histogram_geometry.append(highest_value_text)\n\n    if plane != rg.Plane.WorldXY:\n        trans = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, plane)\n        for geo in histogram_geometry:\n            geo.Transform(trans)\n\n    return histogram_geometry\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}