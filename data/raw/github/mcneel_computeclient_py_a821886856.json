{
  "source_url": "https://github.com/mcneel/computeclient_py/blob/7bd95bed576dd9cf523b0a456977e727d63bb109/compute_rhino3d/Curve.py",
  "repo": "mcneel/computeclient_py",
  "repo_stars": 4,
  "repo_description": "compute_rhino3d python client for compute.rhino3d.com",
  "license": "MIT",
  "filepath": "compute_rhino3d/Curve.py",
  "instruction": null,
  "code": "from . import Util\ntry:\n    from itertools import izip as zip # python 2\nexcept ImportError:\n    pass # python 3\n\n\ndef GetConicSectionType(thisCurve, multiple=False):\n    \"\"\"\n    Returns the type of conic section based on the curve's shape.\n    \"\"\"\n    url = \"rhino/geometry/curve/getconicsectiontype-curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve]\n    if multiple: args = [[item] for item in thisCurve]\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CreateInterpolatedCurve(points, degree, multiple=False):\n    \"\"\"\n    Interpolates a sequence of points. Used by InterpCurve Command\n    This routine works best when degree=3.\n\n    Args:\n        degree (int): The degree of the curve >=1.  Degree must be odd.\n        points (IEnumerable<Point3d>): Points to interpolate (Count must be >= 2)\n\n    Returns:\n        Curve: interpolated curve on success. None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createinterpolatedcurve-point3darray_int\"\n    if multiple: url += \"?multiple=true\"\n    args = [points, degree]\n    if multiple: args = list(zip(points, degree))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateInterpolatedCurve1(points, degree, knots, multiple=False):\n    \"\"\"\n    Interpolates a sequence of points. Used by InterpCurve Command\n    This routine works best when degree=3.\n\n    Args:\n        degree (int): The degree of the curve >=1.  Degree must be odd.\n        points (IEnumerable<Point3d>): Points to interpolate. For periodic curves if the final point is a\n            duplicate of the initial point it is  ignored. (Count must be >=2)\n        knots (CurveKnotStyle): Knot-style to use  and specifies if the curve should be periodic.\n\n    Returns:\n        Curve: interpolated curve on success. None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createinterpolatedcurve-point3darray_int_curveknotstyle\"\n    if multiple: url += \"?multiple=true\"\n    args = [points, degree, knots]\n    if multiple: args = list(zip(points, degree, knots))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateInterpolatedCurve2(points, degree, knots, startTangent, endTangent, multiple=False):\n    \"\"\"\n    Interpolates a sequence of points. Used by InterpCurve Command\n    This routine works best when degree=3.\n\n    Args:\n        degree (int): The degree of the curve >=1.  Degree must be odd.\n        points (IEnumerable<Point3d>): Points to interpolate. For periodic curves if the final point is a\n            duplicate of the initial point it is  ignored. (Count must be >=2)\n        knots (CurveKnotStyle): Knot-style to use  and specifies if the curve should be periodic.\n        startTangent (Vector3d): A starting tangent.\n        endTangent (Vector3d): An ending tangent.\n\n    Returns:\n        Curve: interpolated curve on success. None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createinterpolatedcurve-point3darray_int_curveknotstyle_vector3d_vector3d\"\n    if multiple: url += \"?multiple=true\"\n    args = [points, degree, knots, startTangent, endTangent]\n    if multiple: args = list(zip(points, degree, knots, startTangent, endTangent))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateSoftEditCurve(curve, t, delta, length, fixEnds, multiple=False):\n    \"\"\"\n    Creates a soft edited curve from an existing curve using a smooth field of influence.\n\n    Args:\n        curve (Curve): The curve to soft edit.\n        t (double): A parameter on the curve to move from. This location on the curve is moved, and the move\n            is smoothly tapered off with increasing distance along the curve from this parameter.\n        delta (Vector3d): The direction and magnitude, or maximum distance, of the move.\n        length (double): The distance along the curve from the editing point over which the strength\n            of the editing falls off smoothly.\n\n    Returns:\n        Curve: The soft edited curve if successful. None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createsofteditcurve-curve_double_vector3d_double_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, t, delta, length, fixEnds]\n    if multiple: args = list(zip(curve, t, delta, length, fixEnds))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateFilletCornersCurve(curve, radius, tolerance, angleTolerance, multiple=False):\n    \"\"\"\n    Rounds the corners of a kinked curve with arcs of a single, specified radius.\n\n    Args:\n        curve (Curve): The curve to fillet.\n        radius (double): The fillet radius.\n        tolerance (double): The tolerance. When in doubt, use the document's model space absolute tolerance.\n        angleTolerance (double): The angle tolerance in radians. When in doubt, use the document's model space angle tolerance.\n\n    Returns:\n        Curve: The filleted curve if successful. None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createfilletcornerscurve-curve_double_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, radius, tolerance, angleTolerance]\n    if multiple: args = list(zip(curve, radius, tolerance, angleTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef JoinCurves(inputCurves, joinTolerance, preserveDirection, multiple=False):\n    \"\"\"\n    Joins a collection of curve segments together.\n\n    Args:\n        inputCurves (IEnumerable<Curve>): An array, a list or any enumerable set of curve segments to join.\n        joinTolerance (double): Joining tolerance,\n            i.e. the distance between segment end-points that is allowed.\n        preserveDirection (bool): If true, curve endpoints will be compared to curve start points.If false, all start and endpoints will be compared and copies of input curves may be reversed in output.\n\n    Returns:\n        Curve[]: An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/joincurves-curvearray_double_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [inputCurves, joinTolerance, preserveDirection]\n    if multiple: args = list(zip(inputCurves, joinTolerance, preserveDirection))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateArcLineArcBlend(startPt, startDir, endPt, endDir, radius, multiple=False):\n    \"\"\"\n    Creates an arc-line-arc blend curve between two curves.\n    The output is generally a PolyCurve with three segments: arc, line, arc.\n    In some cases, one or more of those segments will be absent because they would have 0 length.\n    If there is only a single segment, the result will either be an ArcCurve or a LineCurve.\n\n    Args:\n        startPt (Point3d): Start of the blend curve.\n        startDir (Vector3d): Start direction of the blend curve.\n        endPt (Point3d): End of the blend curve.\n        endDir (Vector3d): End direction of the arc blend curve.\n        radius (double): The radius of the arc segments.\n\n    Returns:\n        Curve: The blend curve if successful, False otherwise.\n    \"\"\"\n    url = \"rhino/geometry/curve/createarclinearcblend-point3d_vector3d_point3d_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [startPt, startDir, endPt, endDir, radius]\n    if multiple: args = list(zip(startPt, startDir, endPt, endDir, radius))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateArcBlend(startPt, startDir, endPt, endDir, controlPointLengthRatio, multiple=False):\n    \"\"\"\n    Creates a polycurve consisting of two tangent arc segments that connect two points and two directions.\n\n    Args:\n        startPt (Point3d): Start of the arc blend curve.\n        startDir (Vector3d): Start direction of the arc blend curve.\n        endPt (Point3d): End of the arc blend curve.\n        endDir (Vector3d): End direction of the arc blend curve.\n        controlPointLengthRatio (double): The ratio of the control polygon lengths of the two arcs. Note, a value of 1.0\n            means the control polygon lengths for both arcs will be the same.\n\n    Returns:\n        Curve: The arc blend curve, or None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/createarcblend-point3d_vector3d_point3d_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [startPt, startDir, endPt, endDir, controlPointLengthRatio]\n    if multiple: args = list(zip(startPt, startDir, endPt, endDir, controlPointLengthRatio))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateMeanCurve(curveA, curveB, angleToleranceRadians, multiple=False):\n    \"\"\"\n    Constructs a mean, or average, curve from two curves.\n\n    Args:\n        curveA (Curve): A first curve.\n        curveB (Curve): A second curve.\n        angleToleranceRadians (double): The angle tolerance, in radians, used to match kinks between curves.\n            If you are unsure how to set this parameter, then either use the\n            document's angle tolerance RhinoDoc.AngleToleranceRadians,\n            or the default value (RhinoMath.UnsetValue)\n\n    Returns:\n        Curve: The average curve, or None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/createmeancurve-curve_curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, angleToleranceRadians]\n    if multiple: args = list(zip(curveA, curveB, angleToleranceRadians))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateMeanCurve1(curveA, curveB, multiple=False):\n    \"\"\"\n    Constructs a mean, or average, curve from two curves.\n\n    Args:\n        curveA (Curve): A first curve.\n        curveB (Curve): A second curve.\n\n    Returns:\n        Curve: The average curve, or None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/createmeancurve-curve_curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB]\n    if multiple: args = list(zip(curveA, curveB))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBlendCurve(curveA, curveB, continuity, multiple=False):\n    \"\"\"\n    Create a Blend curve between two existing curves.\n\n    Args:\n        curveA (Curve): Curve to blend from (blending will occur at curve end point).\n        curveB (Curve): Curve to blend to (blending will occur at curve start point).\n        continuity (BlendContinuity): Continuity of blend.\n\n    Returns:\n        Curve: A curve representing the blend between A and B or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createblendcurve-curve_curve_blendcontinuity\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, continuity]\n    if multiple: args = list(zip(curveA, curveB, continuity))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBlendCurve1(curveA, curveB, continuity, bulgeA, bulgeB, multiple=False):\n    \"\"\"\n    Create a Blend curve between two existing curves.\n\n    Args:\n        curveA (Curve): Curve to blend from (blending will occur at curve end point).\n        curveB (Curve): Curve to blend to (blending will occur at curve start point).\n        continuity (BlendContinuity): Continuity of blend.\n        bulgeA (double): Bulge factor at curveA end of blend. Values near 1.0 work best.\n        bulgeB (double): Bulge factor at curveB end of blend. Values near 1.0 work best.\n\n    Returns:\n        Curve: A curve representing the blend between A and B or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createblendcurve-curve_curve_blendcontinuity_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, continuity, bulgeA, bulgeB]\n    if multiple: args = list(zip(curveA, curveB, continuity, bulgeA, bulgeB))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBlendCurve2(curve0, t0, reverse0, continuity0, curve1, t1, reverse1, continuity1, multiple=False):\n    \"\"\"\n    Makes a curve blend between 2 curves at the parameters specified\n    with the directions and continuities specified\n\n    Args:\n        curve0 (Curve): First curve to blend from\n        t0 (double): Parameter on first curve for blend endpoint\n        reverse0 (bool): If false, the blend will go in the natural direction of the curve.\n            If true, the blend will go in the opposite direction to the curve\n        continuity0 (BlendContinuity): Continuity for the blend at the start\n        curve1 (Curve): Second curve to blend from\n        t1 (double): Parameter on second curve for blend endpoint\n        reverse1 (bool): If false, the blend will go in the natural direction of the curve.\n            If true, the blend will go in the opposite direction to the curve\n        continuity1 (BlendContinuity): Continuity for the blend at the end\n\n    Returns:\n        Curve: The blend curve on success. None on failure\n    \"\"\"\n    url = \"rhino/geometry/curve/createblendcurve-curve_double_bool_blendcontinuity_curve_double_bool_blendcontinuity\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, t0, reverse0, continuity0, curve1, t1, reverse1, continuity1]\n    if multiple: args = list(zip(curve0, t0, reverse0, continuity0, curve1, t1, reverse1, continuity1))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateMatchCurve(curve0, reverse0, continuity, curve1, reverse1, preserve, average, multiple=False):\n    \"\"\"\n    Changes a curve end to meet a specified curve with a specified continuity.\n\n    Args:\n        curve0 (Curve): The open curve to change.\n        reverse0 (bool): Reverse the directon of the curve to change before matching.\n        continuity (BlendContinuity): The continuity at the curve end.\n        curve1 (Curve): The open curve to match.\n        reverse1 (bool): Reverse the directon of the curve to match before matching.\n        preserve (PreserveEnd): Prevent modification of the curvature at the end opposite the match for curves with fewer than six control points.\n        average (bool): Adjust both curves to match each other.\n\n    Returns:\n        Curve[]: The results of the curve matching, if successful, otherwise an empty array.\n    \"\"\"\n    url = \"rhino/geometry/curve/creatematchcurve-curve_bool_blendcontinuity_curve_bool_preserveend_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, reverse0, continuity, curve1, reverse1, preserve, average]\n    if multiple: args = list(zip(curve0, reverse0, continuity, curve1, reverse1, preserve, average))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateTweenCurves(curve0, curve1, numCurves, multiple=False):\n    \"\"\"\n    Creates curves between two open or closed input curves. Uses the control points of the curves for finding tween curves.\n    That means the first control point of first curve is matched to first control point of the second curve and so on.\n    There is no matching of curves direction. Caller must match input curves direction before calling the function.\n\n    Args:\n        curve0 (Curve): The first, or starting, curve.\n        curve1 (Curve): The second, or ending, curve.\n        numCurves (int): Number of tween curves to create.\n\n    Returns:\n        Curve[]: An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtweencurves-curve_curve_int\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, numCurves]\n    if multiple: args = list(zip(curve0, curve1, numCurves))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateTweenCurves1(curve0, curve1, numCurves, tolerance, multiple=False):\n    \"\"\"\n    Creates curves between two open or closed input curves. Uses the control points of the curves for finding tween curves.\n    That means the first control point of first curve is matched to first control point of the second curve and so on.\n    There is no matching of curves direction. Caller must match input curves direction before calling the function.\n\n    Args:\n        curve0 (Curve): The first, or starting, curve.\n        curve1 (Curve): The second, or ending, curve.\n        numCurves (int): Number of tween curves to create.\n\n    Returns:\n        Curve[]: An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtweencurves-curve_curve_int_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, numCurves, tolerance]\n    if multiple: args = list(zip(curve0, curve1, numCurves, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateTweenCurvesWithMatching(curve0, curve1, numCurves, multiple=False):\n    \"\"\"\n    Creates curves between two open or closed input curves. Make the structure of input curves compatible if needed.\n    Refits the input curves to have the same structure. The resulting curves are usually more complex than input unless\n    input curves are compatible and no refit is needed. There is no matching of curves direction.\n    Caller must match input curves direction before calling the function.\n\n    Args:\n        curve0 (Curve): The first, or starting, curve.\n        curve1 (Curve): The second, or ending, curve.\n        numCurves (int): Number of tween curves to create.\n\n    Returns:\n        Curve[]: An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtweencurveswithmatching-curve_curve_int\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, numCurves]\n    if multiple: args = list(zip(curve0, curve1, numCurves))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateTweenCurvesWithMatching1(curve0, curve1, numCurves, tolerance, multiple=False):\n    \"\"\"\n    Creates curves between two open or closed input curves. Make the structure of input curves compatible if needed.\n    Refits the input curves to have the same structure. The resulting curves are usually more complex than input unless\n    input curves are compatible and no refit is needed. There is no matching of curves direction.\n    Caller must match input curves direction before calling the function.\n\n    Args:\n        curve0 (Curve): The first, or starting, curve.\n        curve1 (Curve): The second, or ending, curve.\n        numCurves (int): Number of tween curves to create.\n\n    Returns:\n        Curve[]: An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtweencurveswithmatching-curve_curve_int_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, numCurves, tolerance]\n    if multiple: args = list(zip(curve0, curve1, numCurves, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateTweenCurvesWithSampling(curve0, curve1, numCurves, numSamples, multiple=False):\n    \"\"\"\n    Creates curves between two open or closed input curves. Use sample points method to make curves compatible.\n    This is how the algorithm works: Divides the two curves into an equal number of points, finds the midpoint between the\n    corresponding points on the curves and interpolates the tween curve through those points. There is no matching of curves\n    direction. Caller must match input curves direction before calling the function.\n\n    Args:\n        curve0 (Curve): The first, or starting, curve.\n        curve1 (Curve): The second, or ending, curve.\n        numCurves (int): Number of tween curves to create.\n        numSamples (int): Number of sample points along input curves.\n\n    Returns:\n        Curve[]: >An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtweencurveswithsampling-curve_curve_int_int\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, numCurves, numSamples]\n    if multiple: args = list(zip(curve0, curve1, numCurves, numSamples))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateTweenCurvesWithSampling1(curve0, curve1, numCurves, numSamples, tolerance, multiple=False):\n    \"\"\"\n    Creates curves between two open or closed input curves. Use sample points method to make curves compatible.\n    This is how the algorithm works: Divides the two curves into an equal number of points, finds the midpoint between the\n    corresponding points on the curves and interpolates the tween curve through those points. There is no matching of curves\n    direction. Caller must match input curves direction before calling the function.\n\n    Args:\n        curve0 (Curve): The first, or starting, curve.\n        curve1 (Curve): The second, or ending, curve.\n        numCurves (int): Number of tween curves to create.\n        numSamples (int): Number of sample points along input curves.\n\n    Returns:\n        Curve[]: >An array of joint curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtweencurveswithsampling-curve_curve_int_int_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, numCurves, numSamples, tolerance]\n    if multiple: args = list(zip(curve0, curve1, numCurves, numSamples, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef MakeEndsMeet(curveA, adjustStartCurveA, curveB, adjustStartCurveB, multiple=False):\n    \"\"\"\n    Makes adjustments to the ends of one or both input curves so that they meet at a point.\n\n    Args:\n        curveA (Curve): 1st curve to adjust.\n        adjustStartCurveA (bool): Which end of the 1st curve to adjust: True is start, False is end.\n        curveB (Curve): 2nd curve to adjust.\n        adjustStartCurveB (bool): which end of the 2nd curve to adjust true==start, false==end.\n\n    Returns:\n        bool: True on success.\n    \"\"\"\n    url = \"rhino/geometry/curve/makeendsmeet-curve_bool_curve_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, adjustStartCurveA, curveB, adjustStartCurveB]\n    if multiple: args = list(zip(curveA, adjustStartCurveA, curveB, adjustStartCurveB))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CreateFillet(curve0, curve1, radius, t0Base, t1Base, multiple=False):\n    \"\"\"\n    Computes the fillet arc for a curve filleting operation.\n\n    Args:\n        curve0 (Curve): First curve to fillet.\n        curve1 (Curve): Second curve to fillet.\n        radius (double): Fillet radius.\n        t0Base (double): Parameter on curve0 where the fillet ought to start (approximately).\n        t1Base (double): Parameter on curve1 where the fillet ought to end (approximately).\n\n    Returns:\n        Arc: The fillet arc on success, or Arc.Unset on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/createfillet-curve_curve_double_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, curve1, radius, t0Base, t1Base]\n    if multiple: args = list(zip(curve0, curve1, radius, t0Base, t1Base))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CreateFilletCurves(curve0, point0, curve1, point1, radius, join, trim, arcExtension, tolerance, angleTolerance, multiple=False):\n    \"\"\"\n    Creates a tangent arc between two curves and trims or extends the curves to the arc.\n\n    Args:\n        curve0 (Curve): The first curve to fillet.\n        point0 (Point3d): A point on the first curve that is near the end where the fillet will\n            be created.\n        curve1 (Curve): The second curve to fillet.\n        point1 (Point3d): A point on the second curve that is near the end where the fillet will\n            be created.\n        radius (double): The radius of the fillet.\n        join (bool): Join the output curves.\n        trim (bool): Trim copies of the input curves to the output fillet curve.\n        arcExtension (bool): Applies when arcs are filleted but need to be extended to meet the\n            fillet curve or chamfer line. If true, then the arc is extended\n            maintaining its validity. If false, then the arc is extended with a\n            line segment, which is joined to the arc converting it to a polycurve.\n        tolerance (double): The tolerance, generally the document's absolute tolerance.\n\n    Returns:\n        Curve[]: The results of the fillet operation. The number of output curves depends\n        on the input curves and the values of the parameters that were used\n        during the fillet operation. In most cases, the output array will contain\n        either one or three curves, although two curves can be returned if the\n        radius is zero and join = false.\n        For example, if both join and trim = true, then the output curve\n        will be a polycurve containing the fillet curve joined with trimmed copies\n        of the input curves. If join = False and trim = true, then three curves,\n        the fillet curve and trimmed copies of the input curves, will be returned.\n        If both join and trim = false, then just the fillet curve is returned.\n    \"\"\"\n    url = \"rhino/geometry/curve/createfilletcurves-curve_point3d_curve_point3d_double_bool_bool_bool_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve0, point0, curve1, point1, radius, join, trim, arcExtension, tolerance, angleTolerance]\n    if multiple: args = list(zip(curve0, point0, curve1, point1, radius, join, trim, arcExtension, tolerance, angleTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanUnion(curves, multiple=False):\n    \"\"\"\n    Calculates the boolean union of two or more closed, planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curves (IEnumerable<Curve>): The co-planar curves to union.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no union could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleanunion-curvearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves]\n    if multiple: args = [[item] for item in curves]\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanUnion1(curves, tolerance, multiple=False):\n    \"\"\"\n    Calculates the boolean union of two or more closed, planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curves (IEnumerable<Curve>): The co-planar curves to union.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no union could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleanunion-curvearray_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves, tolerance]\n    if multiple: args = list(zip(curves, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanIntersection(curveA, curveB, multiple=False):\n    \"\"\"\n    Calculates the boolean intersection of two closed, planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curveA (Curve): The first closed, planar curve.\n        curveB (Curve): The second closed, planar curve.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no intersection could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleanintersection-curve_curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB]\n    if multiple: args = list(zip(curveA, curveB))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanIntersection1(curveA, curveB, tolerance, multiple=False):\n    \"\"\"\n    Calculates the boolean intersection of two closed, planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curveA (Curve): The first closed, planar curve.\n        curveB (Curve): The second closed, planar curve.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no intersection could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleanintersection-curve_curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, tolerance]\n    if multiple: args = list(zip(curveA, curveB, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanDifference(curveA, curveB, multiple=False):\n    \"\"\"\n    Calculates the boolean difference between two closed, planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curveA (Curve): The first closed, planar curve.\n        curveB (Curve): The second closed, planar curve.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no difference could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleandifference-curve_curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB]\n    if multiple: args = list(zip(curveA, curveB))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanDifference1(curveA, curveB, tolerance, multiple=False):\n    \"\"\"\n    Calculates the boolean difference between two closed, planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curveA (Curve): The first closed, planar curve.\n        curveB (Curve): The second closed, planar curve.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no difference could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleandifference-curve_curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, tolerance]\n    if multiple: args = list(zip(curveA, curveB, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanDifference2(curveA, subtractors, multiple=False):\n    \"\"\"\n    Calculates the boolean difference between a closed planar curve, and a list of closed planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curveA (Curve): The first closed, planar curve.\n        subtractors (IEnumerable<Curve>): curves to subtract from the first closed curve.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no difference could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleandifference-curve_curvearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, subtractors]\n    if multiple: args = list(zip(curveA, subtractors))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanDifference3(curveA, subtractors, tolerance, multiple=False):\n    \"\"\"\n    Calculates the boolean difference between a closed planar curve, and a list of closed planar curves.\n    Note, curves must be co-planar.\n\n    Args:\n        curveA (Curve): The first closed, planar curve.\n        subtractors (IEnumerable<Curve>): curves to subtract from the first closed curve.\n\n    Returns:\n        Curve[]: Result curves on success, empty array if no difference could be calculated.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleandifference-curve_curvearray_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, subtractors, tolerance]\n    if multiple: args = list(zip(curveA, subtractors, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateBooleanRegions(curves, plane, points, combineRegions, tolerance, multiple=False):\n    \"\"\"\n    Curve Boolean method, which trims and splits curves based on their overlapping regions.\n\n    Args:\n        curves (IEnumerable<Curve>): The input curves.\n        plane (Plane): Regions will be found in the projection of the curves to this plane.\n        points (IEnumerable<Point3d>): These points will be projected to plane. All regions that contain at least one of these points will be found.\n        combineRegions (bool): If true, then adjacent regions will be combined.\n        tolerance (double): Function tolerance. When in doubt, use the document's model absolute tolerance.\n\n    Returns:\n        CurveBooleanRegions: The curve Boolean regions if successful, None of no successful.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleanregions-curvearray_plane_point3darray_bool_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves, plane, points, combineRegions, tolerance]\n    if multiple: args = list(zip(curves, plane, points, combineRegions, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CreateBooleanRegions1(curves, plane, combineRegions, tolerance, multiple=False):\n    \"\"\"\n    Calculates curve Boolean regions, which trims and splits curves based on their overlapping regions.\n\n    Args:\n        curves (IEnumerable<Curve>): The input curves.\n        plane (Plane): Regions will be found in the projection of the curves to this plane.\n        combineRegions (bool): If true, then adjacent regions will be combined.\n        tolerance (double): Function tolerance. When in doubt, use the document's model absolute tolerance.\n\n    Returns:\n        CurveBooleanRegions: The curve Boolean regions if successful, None of no successful.\n    \"\"\"\n    url = \"rhino/geometry/curve/createbooleanregions-curvearray_plane_bool_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves, plane, combineRegions, tolerance]\n    if multiple: args = list(zip(curves, plane, combineRegions, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CreateTextOutlines(text, font, textHeight, textStyle, closeLoops, plane, smallCapsScale, tolerance, multiple=False):\n    \"\"\"\n    Creates outline curves created from a text string. The functionality is similar to what you find in Rhino's TextObject command or TextEntity.Explode() in RhinoCommon.\n\n    Args:\n        text (string): The text from which to create outline curves.\n        font (string): The text font.\n        textHeight (double): The text height.\n        textStyle (int): The font style. The font style can be any number of the following: 0 - Normal, 1 - Bold, 2 - Italic\n        closeLoops (bool): Set this value to True when dealing with normal fonts and when you expect closed loops. You may want to set this to False when specifying a single-stroke font where you don't want closed loops.\n        plane (Plane): The plane on which the outline curves will lie.\n        smallCapsScale (double): Displays lower-case letters as small caps. Set the relative text size to a percentage of the normal text.\n        tolerance (double): The tolerance for the operation.\n\n    Returns:\n        Curve[]: An array containing one or more curves if successful.\n    \"\"\"\n    url = \"rhino/geometry/curve/createtextoutlines-string_string_double_int_bool_plane_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [text, font, textHeight, textStyle, closeLoops, plane, smallCapsScale, tolerance]\n    if multiple: args = list(zip(text, font, textHeight, textStyle, closeLoops, plane, smallCapsScale, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreateCurve2View(curveA, curveB, vectorA, vectorB, tolerance, angleTolerance, multiple=False):\n    \"\"\"\n    Creates a third curve from two curves that are planar in different construction planes.\n    The new curve looks the same as each of the original curves when viewed in each plane.\n\n    Args:\n        curveA (Curve): The first curve.\n        curveB (Curve): The second curve.\n        vectorA (Vector3d): A vector defining the normal direction of the plane which the first curve is drawn upon.\n        vectorB (Vector3d): A vector defining the normal direction of the plane which the second curve is drawn upon.\n        tolerance (double): The tolerance for the operation.\n        angleTolerance (double): The angle tolerance for the operation.\n\n    Returns:\n        Curve[]: An array containing one or more curves if successful.\n    \"\"\"\n    url = \"rhino/geometry/curve/createcurve2view-curve_curve_vector3d_vector3d_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, vectorA, vectorB, tolerance, angleTolerance]\n    if multiple: args = list(zip(curveA, curveB, vectorA, vectorB, tolerance, angleTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef DoDirectionsMatch(curveA, curveB, multiple=False):\n    \"\"\"\n    Determines whether two curves travel more or less in the same direction.\n\n    Args:\n        curveA (Curve): First curve to test.\n        curveB (Curve): Second curve to test.\n\n    Returns:\n        bool: True if both curves more or less point in the same direction,\n        False if they point in the opposite directions.\n    \"\"\"\n    url = \"rhino/geometry/curve/dodirectionsmatch-curve_curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB]\n    if multiple: args = list(zip(curveA, curveB))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ProjectToMesh(curve, mesh, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a curve to a mesh using a direction and tolerance.\n\n    Args:\n        curve (Curve): A curve.\n        mesh (Mesh): A mesh.\n        direction (Vector3d): A direction vector.\n        tolerance (double): A tolerance value.\n\n    Returns:\n        Curve[]: A curve array.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttomesh-curve_mesh_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, mesh, direction, tolerance]\n    if multiple: args = list(zip(curve, mesh, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ProjectToMesh1(curve, meshes, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a curve to a set of meshes using a direction and tolerance.\n\n    Args:\n        curve (Curve): A curve.\n        meshes (IEnumerable<Mesh>): A list, an array or any enumerable of meshes.\n        direction (Vector3d): A direction vector.\n        tolerance (double): A tolerance value.\n\n    Returns:\n        Curve[]: A curve array.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttomesh-curve_mesharray_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, meshes, direction, tolerance]\n    if multiple: args = list(zip(curve, meshes, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ProjectToMesh2(curves, meshes, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a curve to a set of meshes using a direction and tolerance.\n\n    Args:\n        curves (IEnumerable<Curve>): A list, an array or any enumerable of curves.\n        meshes (IEnumerable<Mesh>): A list, an array or any enumerable of meshes.\n        direction (Vector3d): A direction vector.\n        tolerance (double): A tolerance value.\n\n    Returns:\n        Curve[]: A curve array.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttomesh-curvearray_mesharray_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves, meshes, direction, tolerance]\n    if multiple: args = list(zip(curves, meshes, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ProjectToBrep(curve, brep, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a Curve onto a Brep along a given direction.\n\n    Args:\n        curve (Curve): Curve to project.\n        brep (Brep): Brep to project onto.\n        direction (Vector3d): Direction of projection.\n        tolerance (double): Tolerance to use for projection.\n\n    Returns:\n        Curve[]: An array of projected curves or empty array if the projection set is empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttobrep-curve_brep_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, brep, direction, tolerance]\n    if multiple: args = list(zip(curve, brep, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ProjectToBrep1(curve, breps, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a Curve onto a collection of Breps along a given direction.\n\n    Args:\n        curve (Curve): Curve to project.\n        breps (IEnumerable<Brep>): Breps to project onto.\n        direction (Vector3d): Direction of projection.\n        tolerance (double): Tolerance to use for projection.\n\n    Returns:\n        Curve[]: An array of projected curves or empty array if the projection set is empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttobrep-curve_breparray_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, breps, direction, tolerance]\n    if multiple: args = list(zip(curve, breps, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ProjectToBrep2(curve, breps, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a Curve onto a collection of Breps along a given direction.\n\n    Args:\n        curve (Curve): Curve to project.\n        breps (IEnumerable<Brep>): Breps to project onto.\n        direction (Vector3d): Direction of projection.\n        tolerance (double): Tolerance to use for projection.\n\n    Returns:\n        Curve[]: An array of projected curves or None if the projection set is empty.\n        brepIndices (int[]): (out) Integers that identify for each resulting curve which Brep it was projected onto.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttobrep-curve_breparray_vector3d_double_intarray\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, breps, direction, tolerance]\n    if multiple: args = list(zip(curve, breps, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ProjectToBrep3(curves, breps, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a collection of Curves onto a collection of Breps along a given direction.\n\n    Args:\n        curves (IEnumerable<Curve>): Curves to project.\n        breps (IEnumerable<Brep>): Breps to project onto.\n        direction (Vector3d): Direction of projection.\n        tolerance (double): Tolerance to use for projection.\n\n    Returns:\n        Curve[]: An array of projected curves or empty array if the projection set is empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttobrep-curvearray_breparray_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves, breps, direction, tolerance]\n    if multiple: args = list(zip(curves, breps, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ProjectToBrep4(curves, breps, direction, tolerance, multiple=False):\n    \"\"\"\n    Projects a collection of Curves onto a collection of Breps along a given direction.\n\n    Args:\n        curves (IEnumerable<Curve>): Curves to project.\n        breps (IEnumerable<Brep>): Breps to project onto.\n        direction (Vector3d): Direction of projection.\n        tolerance (double): Tolerance to use for projection.\n\n    Returns:\n        Curve[]: An array of projected curves. Array is empty if the projection set is empty.\n        curveIndices (int[]): Index of which curve in the input list was the source for a curve in the return array.\n        brepIndices (int[]): Index of which brep was used to generate a curve in the return array.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttobrep-curvearray_breparray_vector3d_double_intarray_intarray\"\n    if multiple: url += \"?multiple=true\"\n    args = [curves, breps, direction, tolerance]\n    if multiple: args = list(zip(curves, breps, direction, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ProjectToPlane(curve, plane, multiple=False):\n    \"\"\"\n    Constructs a curve by projecting an existing curve to a plane.\n\n    Args:\n        curve (Curve): A curve.\n        plane (Plane): A plane.\n\n    Returns:\n        Curve: The projected curve on success; None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/projecttoplane-curve_plane\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, plane]\n    if multiple: args = list(zip(curve, plane))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef PullToBrepFace(curve, face, tolerance, multiple=False):\n    \"\"\"\n    Pull a curve to a BrepFace using closest point projection.\n\n    Args:\n        curve (Curve): Curve to pull.\n        face (BrepFace): Brep face that pulls.\n        tolerance (double): Tolerance to use for pulling.\n\n    Returns:\n        Curve[]: An array of pulled curves, or an empty array on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/pulltobrepface-curve_brepface_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, face, tolerance]\n    if multiple: args = list(zip(curve, face, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef PlanarClosedCurveRelationship(curveA, curveB, testPlane, tolerance, multiple=False):\n    \"\"\"\n    Determines whether two coplanar simple closed curves are disjoint or intersect;\n    otherwise, if the regions have a containment relationship, discovers\n    which curve encloses the other.\n\n    Args:\n        curveA (Curve): A first curve.\n        curveB (Curve): A second curve.\n        testPlane (Plane): A plane.\n        tolerance (double): A tolerance value.\n\n    Returns:\n        RegionContainment: A value indicating the relationship between the first and the second curve.\n    \"\"\"\n    url = \"rhino/geometry/curve/planarclosedcurverelationship-curve_curve_plane_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, testPlane, tolerance]\n    if multiple: args = list(zip(curveA, curveB, testPlane, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef PlanarCurveCollision(curveA, curveB, testPlane, tolerance, multiple=False):\n    \"\"\"\n    Determines if two coplanar curves collide (intersect).\n\n    Args:\n        curveA (Curve): A curve.\n        curveB (Curve): Another curve.\n        testPlane (Plane): A valid plane containing the curves.\n        tolerance (double): A tolerance value for intersection.\n\n    Returns:\n        bool: True if the curves intersect, otherwise false\n    \"\"\"\n    url = \"rhino/geometry/curve/planarcurvecollision-curve_curve_plane_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [curveA, curveB, testPlane, tolerance]\n    if multiple: args = list(zip(curveA, curveB, testPlane, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DuplicateSegments(thisCurve, multiple=False):\n    \"\"\"\n    Duplicates curve segments.\n    Explodes polylines, polycurves and G1 discontinuous NURBS curves.\n    Single segment curves, such as lines, arcs, unkinked NURBS curves, are duplicated.\n\n    Returns:\n        Curve[]: An array of all the segments that make up this curve.\n    \"\"\"\n    url = \"rhino/geometry/curve/duplicatesegments-curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve]\n    if multiple: args = [[item] for item in thisCurve]\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Smooth(thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem, multiple=False):\n    \"\"\"\n    Smooths a curve by averaging the positions of control points in a specified region.\n\n    Args:\n        smoothFactor (double): The smoothing factor, which controls how much control points move towards the average of the neighboring control points.\n        bXSmooth (bool): When True control points move in X axis direction.\n        bYSmooth (bool): When True control points move in Y axis direction.\n        bZSmooth (bool): When True control points move in Z axis direction.\n        bFixBoundaries (bool): When True the curve ends don't move.\n        coordinateSystem (SmoothingCoordinateSystem): The coordinates to determine the direction of the smoothing.\n\n    Returns:\n        Curve: The smoothed curve if successful, None otherwise.\n    \"\"\"\n    url = \"rhino/geometry/curve/smooth-curve_double_bool_bool_bool_bool_smoothingcoordinatesystem\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem]\n    if multiple: args = list(zip(thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Smooth1(thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem, plane, multiple=False):\n    \"\"\"\n    Smooths a curve by averaging the positions of control points in a specified region.\n\n    Args:\n        smoothFactor (double): The smoothing factor, which controls how much control points move towards the average of the neighboring control points.\n        bXSmooth (bool): When True control points move in X axis direction.\n        bYSmooth (bool): When True control points move in Y axis direction.\n        bZSmooth (bool): When True control points move in Z axis direction.\n        bFixBoundaries (bool): When True the curve ends don't move.\n        coordinateSystem (SmoothingCoordinateSystem): The coordinates to determine the direction of the smoothing.\n        plane (Plane): If SmoothingCoordinateSystem.CPlane specified, then the construction plane.\n\n    Returns:\n        Curve: The smoothed curve if successful, None otherwise.\n    \"\"\"\n    url = \"rhino/geometry/curve/smooth-curve_double_bool_bool_bool_bool_smoothingcoordinatesystem_plane\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem, plane]\n    if multiple: args = list(zip(thisCurve, smoothFactor, bXSmooth, bYSmooth, bZSmooth, bFixBoundaries, coordinateSystem, plane))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef GetLocalPerpPoint(thisCurve, testPoint, seedParmameter, multiple=False):\n    \"\"\"\n    Search for a location on the curve, near seedParmameter, that is perpendicular to a test point.\n\n    Args:\n        testPoint (Point3d): The test point.\n        seedParmameter (double): A \"seed\" parameter on the curve.\n\n    Returns:\n        bool: True if a solution is found, False otherwise.\n        curveParameter (double): The parameter value at the perpendicular point\n    \"\"\"\n    url = \"rhino/geometry/curve/getlocalperppoint-curve_point3d_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, seedParmameter]\n    if multiple: args = list(zip(thisCurve, testPoint, seedParmameter))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLocalPerpPoint1(thisCurve, testPoint, seedParmameter, subDomain, multiple=False):\n    \"\"\"\n    Search for a location on the curve, near seedParmameter, that is perpendicular to a test point.\n\n    Args:\n        testPoint (Point3d): The test point.\n        seedParmameter (double): A \"seed\" parameter on the curve.\n        subDomain (Interval): The sub-domain of the curve to search.\n\n    Returns:\n        bool: True if a solution is found, False otherwise.\n        curveParameter (double): The parameter value at the perpendicular point\n    \"\"\"\n    url = \"rhino/geometry/curve/getlocalperppoint-curve_point3d_double_interval_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, seedParmameter, subDomain]\n    if multiple: args = list(zip(thisCurve, testPoint, seedParmameter, subDomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLocalTangentPoint(thisCurve, testPoint, seedParmameter, multiple=False):\n    \"\"\"\n    Search for a location on the curve, near seedParmameter, that is tangent to a test point.\n\n    Args:\n        testPoint (Point3d): The test point.\n        seedParmameter (double): A \"seed\" parameter on the curve.\n\n    Returns:\n        bool: True if a solution is found, False otherwise.\n        curveParameter (double): The parameter value at the tangent point\n    \"\"\"\n    url = \"rhino/geometry/curve/getlocaltangentpoint-curve_point3d_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, seedParmameter]\n    if multiple: args = list(zip(thisCurve, testPoint, seedParmameter))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLocalTangentPoint1(thisCurve, testPoint, seedParmameter, subDomain, multiple=False):\n    \"\"\"\n    Search for a location on the curve, near seedParmameter, that is tangent to a test point.\n\n    Args:\n        testPoint (Point3d): The test point.\n        seedParmameter (double): A \"seed\" parameter on the curve.\n        subDomain (Interval): The sub-domain of the curve to search.\n\n    Returns:\n        bool: True if a solution is found, False otherwise.\n        curveParameter (double): The parameter value at the tangent point\n    \"\"\"\n    url = \"rhino/geometry/curve/getlocaltangentpoint-curve_point3d_double_interval_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, seedParmameter, subDomain]\n    if multiple: args = list(zip(thisCurve, testPoint, seedParmameter, subDomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef InflectionPoints(thisCurve, multiple=False):\n    \"\"\"\n    Returns a curve's inflection points. An inflection point is a location on\n    a curve at which the sign of the curvature (i.e., the concavity) changes.\n    The curvature at these locations is always 0.\n\n    Returns:\n        Point3d[]: An array of points if successful, None if not successful or on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/inflectionpoints-curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve]\n    if multiple: args = [[item] for item in thisCurve]\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToPoint3d(response)\n    return response\n\n\ndef MaxCurvaturePoints(thisCurve, multiple=False):\n    \"\"\"\n    Returns a curve's maximum curvature points. The maximum curvature points identify\n    where the curvature starts to decrease in both directions from the points.\n\n    Returns:\n        Point3d[]: An array of points if successful, None if not successful or on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/maxcurvaturepoints-curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve]\n    if multiple: args = [[item] for item in thisCurve]\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToPoint3d(response)\n    return response\n\n\ndef MakeClosed(thisCurve, tolerance, multiple=False):\n    \"\"\"\n    If IsClosed, just return true. Otherwise, decide if curve can be closed as\n    follows: Linear curves polylinear curves with 2 segments, NURBS with 3 or less\n    control points cannot be made closed. Also, if tolerance > 0 and the gap between\n    start and end is larger than tolerance, curve cannot be made closed.\n    Adjust the curve's endpoint to match its start point.\n\n    Args:\n        tolerance (double): If nonzero, and the gap is more than tolerance, curve cannot be made closed.\n\n    Returns:\n        bool: True on success, False on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/makeclosed-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance]\n    if multiple: args = list(zip(thisCurve, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CombineShortSegments(thisCurve, tolerance, multiple=False):\n    \"\"\"\n    Looks for segments that are shorter than tolerance that can be combined.\n    For NURBS of degree greater than 1, spans are combined by removing\n    knots. Similarly for NURBS segments of polycurves. Otherwise,\n    RemoveShortSegments() is called. Does not change the domain, but it will\n    change the relative parameterization.\n\n    Returns:\n        bool: True if short segments were combined or removed. False otherwise.\n    \"\"\"\n    url = \"rhino/geometry/curve/combineshortsegments-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance]\n    if multiple: args = list(zip(thisCurve, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef LcoalClosestPoint(thisCurve, testPoint, seed, multiple=False):\n    \"\"\"\n    Find parameter of the point on a curve that is locally closest to\n    the testPoint.  The search for a local close point starts at\n    a seed parameter.\n\n    Args:\n        testPoint (Point3d): A point to test against.\n        seed (double): The seed parameter.\n\n    Returns:\n        bool: True if the search is successful, False if the search fails.\n        t (double): >Parameter of the curve that is closest to testPoint.\n    \"\"\"\n    url = \"rhino/geometry/curve/lcoalclosestpoint-curve_point3d_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, seed]\n    if multiple: args = list(zip(thisCurve, testPoint, seed))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef LocalClosestPoint(thisCurve, testPoint, seed, multiple=False):\n    \"\"\"\n    Find parameter of the point on a curve that is locally closest to\n    the testPoint.  The search for a local close point starts at\n    a seed parameter.\n\n    Args:\n        testPoint (Point3d): A point to test against.\n        seed (double): The seed parameter.\n\n    Returns:\n        bool: True if the search is successful, False if the search fails.\n        t (double): >Parameter of the curve that is closest to testPoint.\n    \"\"\"\n    url = \"rhino/geometry/curve/localclosestpoint-curve_point3d_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, seed]\n    if multiple: args = list(zip(thisCurve, testPoint, seed))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ClosestPoint(thisCurve, testPoint, multiple=False):\n    \"\"\"\n    Finds parameter of the point on a curve that is closest to testPoint.\n    If the maximumDistance parameter is > 0, then only points whose distance\n    to the given point is <= maximumDistance will be returned.  Using a\n    positive value of maximumDistance can substantially speed up the search.\n\n    Args:\n        testPoint (Point3d): Point to search from.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter of local closest point.\n    \"\"\"\n    url = \"rhino/geometry/curve/closestpoint-curve_point3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint]\n    if multiple: args = list(zip(thisCurve, testPoint))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ClosestPoint1(thisCurve, testPoint, maximumDistance, multiple=False):\n    \"\"\"\n    Finds the parameter of the point on a curve that is closest to testPoint.\n    If the maximumDistance parameter is > 0, then only points whose distance\n    to the given point is <= maximumDistance will be returned.  Using a\n    positive value of maximumDistance can substantially speed up the search.\n\n    Args:\n        testPoint (Point3d): Point to project.\n        maximumDistance (double): The maximum allowed distance.\n            Past this distance, the search is given up and False is returned.Use 0 to turn off this parameter.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): parameter of local closest point returned here.\n    \"\"\"\n    url = \"rhino/geometry/curve/closestpoint-curve_point3d_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, maximumDistance]\n    if multiple: args = list(zip(thisCurve, testPoint, maximumDistance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ClosestPoints(thisCurve, otherCurve, multiple=False):\n    \"\"\"\n    Gets closest points between this and another curves.\n\n    Args:\n        otherCurve (Curve): The other curve.\n\n    Returns:\n        bool: True on success; False on error.\n        pointOnThisCurve (Point3d): The point on this curve. This out parameter is assigned during this call.\n        pointOnOtherCurve (Point3d): The point on other curve. This out parameter is assigned during this call.\n    \"\"\"\n    url = \"rhino/geometry/curve/closestpoints-curve_curve_point3d_point3d\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, otherCurve]\n    if multiple: args = list(zip(thisCurve, otherCurve))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef Contains(thisCurve, testPoint, multiple=False):\n    \"\"\"\n    Computes the relationship between a point and a closed curve region.\n    This curve must be closed or the return value will be Unset.\n    Both curve and point are projected to the World XY plane.\n\n    Args:\n        testPoint (Point3d): Point to test.\n\n    Returns:\n        PointContainment: Relationship between point and curve region.\n    \"\"\"\n    url = \"rhino/geometry/curve/contains-curve_point3d\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint]\n    if multiple: args = list(zip(thisCurve, testPoint))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef Contains1(thisCurve, testPoint, plane, multiple=False):\n    \"\"\"\n    Computes the relationship between a point and a closed curve region.\n    This curve must be closed or the return value will be Unset.\n\n    Args:\n        testPoint (Point3d): Point to test.\n        plane (Plane): Plane in which to compare point and region.\n\n    Returns:\n        PointContainment: Relationship between point and curve region.\n    \"\"\"\n    url = \"rhino/geometry/curve/contains-curve_point3d_plane\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, plane]\n    if multiple: args = list(zip(thisCurve, testPoint, plane))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef Contains2(thisCurve, testPoint, plane, tolerance, multiple=False):\n    \"\"\"\n    Computes the relationship between a point and a closed curve region.\n    This curve must be closed or the return value will be Unset.\n\n    Args:\n        testPoint (Point3d): Point to test.\n        plane (Plane): Plane in which to compare point and region.\n        tolerance (double): Tolerance to use during comparison.\n\n    Returns:\n        PointContainment: Relationship between point and curve region.\n    \"\"\"\n    url = \"rhino/geometry/curve/contains-curve_point3d_plane_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, testPoint, plane, tolerance]\n    if multiple: args = list(zip(thisCurve, testPoint, plane, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ExtremeParameters(thisCurve, direction, multiple=False):\n    \"\"\"\n    Returns the parameter values of all local extrema.\n    Parameter values are in increasing order so consecutive extrema\n    define an interval on which each component of the curve is monotone.\n    Note, non-periodic curves always return the end points.\n\n    Args:\n        direction (Vector3d): The direction in which to perform the calculation.\n\n    Returns:\n        double[]: The parameter values of all local extrema.\n    \"\"\"\n    url = \"rhino/geometry/curve/extremeparameters-curve_vector3d\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, direction]\n    if multiple: args = list(zip(thisCurve, direction))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef CreatePeriodicCurve(curve, multiple=False):\n    \"\"\"\n    Removes kinks from a curve. Periodic curves deform smoothly without kinks.\n\n    Args:\n        curve (Curve): The curve to make periodic. Curve must have degree >= 2.\n\n    Returns:\n        Curve: The resulting curve if successful, None otherwise.\n    \"\"\"\n    url = \"rhino/geometry/curve/createperiodiccurve-curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve]\n    if multiple: args = [[item] for item in curve]\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef CreatePeriodicCurve1(curve, smooth, multiple=False):\n    \"\"\"\n    Removes kinks from a curve. Periodic curves deform smoothly without kinks.\n\n    Args:\n        curve (Curve): The curve to make periodic. Curve must have degree >= 2.\n        smooth (bool): If true, smooths any kinks in the curve and moves control points to make a smooth curve.\n            If false, control point locations are not changed or changed minimally (only one point may move) and only the knot vector is altered.\n\n    Returns:\n        Curve: The resulting curve if successful, None otherwise.\n    \"\"\"\n    url = \"rhino/geometry/curve/createperiodiccurve-curve_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [curve, smooth]\n    if multiple: args = list(zip(curve, smooth))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef PointAtLength(thisCurve, length, multiple=False):\n    \"\"\"\n    Gets a point at a certain length along the curve. The length must be\n    non-negative and less than or equal to the length of the curve.\n    Lengths will not be wrapped when the curve is closed or periodic.\n\n    Args:\n        length (double): Length along the curve between the start point and the returned point.\n\n    Returns:\n        Point3d: Point on the curve at the specified length from the start point or Poin3d.Unset on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/pointatlength-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, length]\n    if multiple: args = list(zip(thisCurve, length))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToPoint3d(response)\n    return response\n\n\ndef PointAtNormalizedLength(thisCurve, length, multiple=False):\n    \"\"\"\n    Gets a point at a certain normalized length along the curve. The length must be\n    between or including 0.0 and 1.0, where 0.0 equals the start of the curve and\n    1.0 equals the end of the curve.\n\n    Args:\n        length (double): Normalized length along the curve between the start point and the returned point.\n\n    Returns:\n        Point3d: Point on the curve at the specified normalized length from the start point or Poin3d.Unset on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/pointatnormalizedlength-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, length]\n    if multiple: args = list(zip(thisCurve, length))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToPoint3d(response)\n    return response\n\n\ndef PerpendicularFrameAt(thisCurve, t, multiple=False):\n    \"\"\"\n    Return a 3d frame at a parameter. This is slightly different than FrameAt in\n    that the frame is computed in a way so there is minimal rotation from one\n    frame to the next.\n\n    Args:\n        t (double): Evaluation parameter.\n\n    Returns:\n        bool: True on success, False on failure.\n        plane (Plane): The frame is returned here.\n    \"\"\"\n    url = \"rhino/geometry/curve/perpendicularframeat-curve_double_plane\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, t]\n    if multiple: args = list(zip(thisCurve, t))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetPerpendicularFrames(thisCurve, parameters, multiple=False):\n    \"\"\"\n    Gets a collection of perpendicular frames along the curve. Perpendicular frames\n    are also known as 'Zero-twisting frames' and they minimize rotation from one frame to the next.\n\n    Args:\n        parameters (IEnumerable<double>): A collection of strictly increasing curve parameters to place perpendicular frames on.\n\n    Returns:\n        Plane[]: An array of perpendicular frames on success or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/getperpendicularframes-curve_doublearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, parameters]\n    if multiple: args = list(zip(thisCurve, parameters))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLength(thisCurve, multiple=False):\n    \"\"\"\n    Gets the length of the curve with a fractional tolerance of 1.0e-8.\n\n    Returns:\n        double: The length of the curve on success, or zero on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/getlength-curve\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve]\n    if multiple: args = [[item] for item in thisCurve]\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLength1(thisCurve, fractionalTolerance, multiple=False):\n    \"\"\"\n    Get the length of the curve.\n\n    Args:\n        fractionalTolerance (double): Desired fractional precision.\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\n\n    Returns:\n        double: The length of the curve on success, or zero on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/getlength-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, fractionalTolerance]\n    if multiple: args = list(zip(thisCurve, fractionalTolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLength2(thisCurve, subdomain, multiple=False):\n    \"\"\"\n    Get the length of a sub-section of the curve with a fractional tolerance of 1e-8.\n\n    Args:\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).\n\n    Returns:\n        double: The length of the sub-curve on success, or zero on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/getlength-curve_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, subdomain]\n    if multiple: args = list(zip(thisCurve, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef GetLength3(thisCurve, fractionalTolerance, subdomain, multiple=False):\n    \"\"\"\n    Get the length of a sub-section of the curve.\n\n    Args:\n        fractionalTolerance (double): Desired fractional precision.\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).\n\n    Returns:\n        double: The length of the sub-curve on success, or zero on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/getlength-curve_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, fractionalTolerance, subdomain]\n    if multiple: args = list(zip(thisCurve, fractionalTolerance, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef IsShort(thisCurve, tolerance, multiple=False):\n    \"\"\"\n    Used to quickly find short curves.\n\n    Args:\n        tolerance (double): Length threshold value for \"shortness\".\n\n    Returns:\n        bool: True if the length of the curve is <= tolerance.\n    \"\"\"\n    url = \"rhino/geometry/curve/isshort-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance]\n    if multiple: args = list(zip(thisCurve, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef IsShort1(thisCurve, tolerance, subdomain, multiple=False):\n    \"\"\"\n    Used to quickly find short curves.\n\n    Args:\n        tolerance (double): Length threshold value for \"shortness\".\n        subdomain (Interval): The test is performed on the interval that is the intersection of sub-domain with Domain()\n\n    Returns:\n        bool: True if the length of the curve is <= tolerance.\n    \"\"\"\n    url = \"rhino/geometry/curve/isshort-curve_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance, subdomain]\n    if multiple: args = list(zip(thisCurve, tolerance, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef RemoveShortSegments(thisCurve, tolerance, multiple=False):\n    \"\"\"\n    Looks for segments that are shorter than tolerance that can be removed.\n    Does not change the domain, but it will change the relative parameterization.\n\n    Args:\n        tolerance (double): Tolerance which defines \"short\" segments.\n\n    Returns:\n        bool: True if removable short segments were found.\n        False if no removable short segments were found.\n    \"\"\"\n    url = \"rhino/geometry/curve/removeshortsegments-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance]\n    if multiple: args = list(zip(thisCurve, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef LengthParameter(thisCurve, segmentLength, multiple=False):\n    \"\"\"\n    Gets the parameter along the curve which coincides with a given length along the curve.\n    A fractional tolerance of 1e-8 is used in this version of the function.\n\n    Args:\n        segmentLength (double): Length of segment to measure. Must be less than or equal to the length of the curve.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from the curve start point to t equals length.\n    \"\"\"\n    url = \"rhino/geometry/curve/lengthparameter-curve_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength]\n    if multiple: args = list(zip(thisCurve, segmentLength))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef LengthParameter1(thisCurve, segmentLength, fractionalTolerance, multiple=False):\n    \"\"\"\n    Gets the parameter along the curve which coincides with a given length along the curve.\n\n    Args:\n        segmentLength (double): Length of segment to measure. Must be less than or equal to the length of the curve.\n        fractionalTolerance (double): Desired fractional precision.\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from the curve start point to t equals s.\n    \"\"\"\n    url = \"rhino/geometry/curve/lengthparameter-curve_double_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, fractionalTolerance]\n    if multiple: args = list(zip(thisCurve, segmentLength, fractionalTolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef LengthParameter2(thisCurve, segmentLength, subdomain, multiple=False):\n    \"\"\"\n    Gets the parameter along the curve which coincides with a given length along the curve.\n    A fractional tolerance of 1e-8 is used in this version of the function.\n\n    Args:\n        segmentLength (double): Length of segment to measure. Must be less than or equal to the length of the sub-domain.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve rather than the whole curve.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from the start of the sub-domain to t is s.\n    \"\"\"\n    url = \"rhino/geometry/curve/lengthparameter-curve_double_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, subdomain]\n    if multiple: args = list(zip(thisCurve, segmentLength, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef LengthParameter3(thisCurve, segmentLength, fractionalTolerance, subdomain, multiple=False):\n    \"\"\"\n    Gets the parameter along the curve which coincides with a given length along the curve.\n\n    Args:\n        segmentLength (double): Length of segment to measure. Must be less than or equal to the length of the sub-domain.\n        fractionalTolerance (double): Desired fractional precision.\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve rather than the whole curve.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from the start of the sub-domain to t is s.\n    \"\"\"\n    url = \"rhino/geometry/curve/lengthparameter-curve_double_double_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, fractionalTolerance, subdomain]\n    if multiple: args = list(zip(thisCurve, segmentLength, fractionalTolerance, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameter(thisCurve, s, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n    A fractional tolerance of 1e-8 is used in this version of the function.\n\n    Args:\n        s (double): Normalized arc length parameter.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from its start to t is arc_length.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameter-curve_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s]\n    if multiple: args = list(zip(thisCurve, s))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameter1(thisCurve, s, fractionalTolerance, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n\n    Args:\n        s (double): Normalized arc length parameter.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        fractionalTolerance (double): Desired fractional precision.\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from its start to t is arc_length.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameter-curve_double_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, fractionalTolerance]\n    if multiple: args = list(zip(thisCurve, s, fractionalTolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameter2(thisCurve, s, subdomain, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n    A fractional tolerance of 1e-8 is used in this version of the function.\n\n    Args:\n        s (double): Normalized arc length parameter.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from its start to t is arc_length.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameter-curve_double_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, subdomain]\n    if multiple: args = list(zip(thisCurve, s, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameter3(thisCurve, s, fractionalTolerance, subdomain, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n\n    Args:\n        s (double): Normalized arc length parameter.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        fractionalTolerance (double): Desired fractional precision.\n            fabs((\"exact\" length from start to t) - arc_length)/arc_length <= fractionalTolerance.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve.\n\n    Returns:\n        bool: True on success, False on failure.\n        t (double): Parameter such that the length of the curve from its start to t is arc_length.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameter-curve_double_double_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, fractionalTolerance, subdomain]\n    if multiple: args = list(zip(thisCurve, s, fractionalTolerance, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameters(thisCurve, s, absoluteTolerance, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n    A fractional tolerance of 1e-8 is used in this version of the function.\n\n    Args:\n        s (double[]): Array of normalized arc length parameters.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        absoluteTolerance (double): If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length\n            and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n\n    Returns:\n        double[]: If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length.\n        Null on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameters-curve_doublearray_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, absoluteTolerance]\n    if multiple: args = list(zip(thisCurve, s, absoluteTolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameters1(thisCurve, s, absoluteTolerance, fractionalTolerance, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n\n    Args:\n        s (double[]): Array of normalized arc length parameters.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        absoluteTolerance (double): If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length\n            and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n        fractionalTolerance (double): Desired fractional precision for each segment.\n            fabs(\"true\" length - actual length)/(actual length) <= fractionalTolerance.\n\n    Returns:\n        double[]: If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length.\n        Null on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameters-curve_doublearray_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, absoluteTolerance, fractionalTolerance]\n    if multiple: args = list(zip(thisCurve, s, absoluteTolerance, fractionalTolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameters2(thisCurve, s, absoluteTolerance, subdomain, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n    A fractional tolerance of 1e-8 is used in this version of the function.\n\n    Args:\n        s (double[]): Array of normalized arc length parameters.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        absoluteTolerance (double): If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length\n            and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve.\n            A 0.0 s value corresponds to sub-domain->Min() and a 1.0 s value corresponds to sub-domain->Max().\n\n    Returns:\n        double[]: If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length.\n        Null on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameters-curve_doublearray_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, absoluteTolerance, subdomain]\n    if multiple: args = list(zip(thisCurve, s, absoluteTolerance, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef NormalizedLengthParameters3(thisCurve, s, absoluteTolerance, fractionalTolerance, subdomain, multiple=False):\n    \"\"\"\n    Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.\n\n    Args:\n        s (double[]): Array of normalized arc length parameters.\n            E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.\n        absoluteTolerance (double): If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length\n            and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\n        fractionalTolerance (double): Desired fractional precision for each segment.\n            fabs(\"true\" length - actual length)/(actual length) <= fractionalTolerance.\n        subdomain (Interval): The calculation is performed on the specified sub-domain of the curve.\n            A 0.0 s value corresponds to sub-domain->Min() and a 1.0 s value corresponds to sub-domain->Max().\n\n    Returns:\n        double[]: If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length.\n        Null on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/normalizedlengthparameters-curve_doublearray_double_double_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, s, absoluteTolerance, fractionalTolerance, subdomain]\n    if multiple: args = list(zip(thisCurve, s, absoluteTolerance, fractionalTolerance, subdomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideByCount(thisCurve, segmentCount, includeEnds, multiple=False):\n    \"\"\"\n    Divide the curve into a number of equal-length segments.\n\n    Args:\n        segmentCount (int): Segment count. Note that the number of division points may differ from the segment count.\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\n\n    Returns:\n        double[]: List of curve parameters at the division points on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/dividebycount-curve_int_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentCount, includeEnds]\n    if multiple: args = list(zip(thisCurve, segmentCount, includeEnds))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideByCount1(thisCurve, segmentCount, includeEnds, multiple=False):\n    \"\"\"\n    Divide the curve into a number of equal-length segments.\n\n    Args:\n        segmentCount (int): Segment count. Note that the number of division points may differ from the segment count.\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\n\n    Returns:\n        double[]: Array containing division curve parameters on success, None on failure.\n        points (Point3d[]): A list of division points. If the function returns successfully, this point-array will be filled in.\n    \"\"\"\n    url = \"rhino/geometry/curve/dividebycount-curve_int_bool_point3darray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentCount, includeEnds]\n    if multiple: args = list(zip(thisCurve, segmentCount, includeEnds))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideByLength(thisCurve, segmentLength, includeEnds, multiple=False):\n    \"\"\"\n    Divide the curve into specific length segments.\n\n    Args:\n        segmentLength (double): The length of each and every segment (except potentially the last one).\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\n\n    Returns:\n        double[]: Array containing division curve parameters if successful, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/dividebylength-curve_double_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, includeEnds]\n    if multiple: args = list(zip(thisCurve, segmentLength, includeEnds))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideByLength1(thisCurve, segmentLength, includeEnds, reverse, multiple=False):\n    \"\"\"\n    Divide the curve into specific length segments.\n\n    Args:\n        segmentLength (double): The length of each and every segment (except potentially the last one).\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\n        reverse (bool): If true, then the divisions start from the end of the curve.\n\n    Returns:\n        double[]: Array containing division curve parameters if successful, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/dividebylength-curve_double_bool_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, includeEnds, reverse]\n    if multiple: args = list(zip(thisCurve, segmentLength, includeEnds, reverse))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideByLength2(thisCurve, segmentLength, includeEnds, multiple=False):\n    \"\"\"\n    Divide the curve into specific length segments.\n\n    Args:\n        segmentLength (double): The length of each and every segment (except potentially the last one).\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\n\n    Returns:\n        double[]: Array containing division curve parameters if successful, None on failure.\n        points (Point3d[]): If function is successful, points at each parameter value are returned in points.\n    \"\"\"\n    url = \"rhino/geometry/curve/dividebylength-curve_double_bool_point3darray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, includeEnds]\n    if multiple: args = list(zip(thisCurve, segmentLength, includeEnds))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideByLength3(thisCurve, segmentLength, includeEnds, reverse, multiple=False):\n    \"\"\"\n    Divide the curve into specific length segments.\n\n    Args:\n        segmentLength (double): The length of each and every segment (except potentially the last one).\n        includeEnds (bool): If true, then the point at the start of the first division segment is returned.\n        reverse (bool): If true, then the divisions start from the end of the curve.\n\n    Returns:\n        double[]: Array containing division curve parameters if successful, None on failure.\n        points (Point3d[]): If function is successful, points at each parameter value are returned in points.\n    \"\"\"\n    url = \"rhino/geometry/curve/dividebylength-curve_double_bool_bool_point3darray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, segmentLength, includeEnds, reverse]\n    if multiple: args = list(zip(thisCurve, segmentLength, includeEnds, reverse))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef DivideEquidistant(thisCurve, distance, multiple=False):\n    \"\"\"\n    Calculates 3d points on a curve where the linear distance between the points is equal.\n\n    Args:\n        distance (double): The distance between division points.\n\n    Returns:\n        Point3d[]: An array of equidistant points, or None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/divideequidistant-curve_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, distance]\n    if multiple: args = list(zip(thisCurve, distance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToPoint3d(response)\n    return response\n\n\ndef DivideAsContour(thisCurve, contourStart, contourEnd, interval, multiple=False):\n    \"\"\"\n    Divides this curve at fixed steps along a defined contour line.\n\n    Args:\n        contourStart (Point3d): The start of the contouring line.\n        contourEnd (Point3d): The end of the contouring line.\n        interval (double): A distance to measure on the contouring axis.\n\n    Returns:\n        Point3d[]: An array of points; or None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/divideascontour-curve_point3d_point3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, contourStart, contourEnd, interval]\n    if multiple: args = list(zip(thisCurve, contourStart, contourEnd, interval))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToPoint3d(response)\n    return response\n\n\ndef Trim(thisCurve, side, length, multiple=False):\n    \"\"\"\n    Shortens a curve by a given length\n\n    Returns:\n        Curve: Trimmed curve if successful, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/trim-curve_curveend_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, length]\n    if multiple: args = list(zip(thisCurve, side, length))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Split(thisCurve, cutter, tolerance, multiple=False):\n    \"\"\"\n    Splits a curve into pieces using a polysurface.\n\n    Args:\n        cutter (Brep): A cutting surface or polysurface.\n        tolerance (double): A tolerance for computing intersections.\n\n    Returns:\n        Curve[]: An array of curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/split-curve_brep_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, cutter, tolerance]\n    if multiple: args = list(zip(thisCurve, cutter, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Split1(thisCurve, cutter, tolerance, angleToleranceRadians, multiple=False):\n    \"\"\"\n    Splits a curve into pieces using a polysurface.\n\n    Args:\n        cutter (Brep): A cutting surface or polysurface.\n        tolerance (double): A tolerance for computing intersections.\n\n    Returns:\n        Curve[]: An array of curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/split-curve_brep_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, cutter, tolerance, angleToleranceRadians]\n    if multiple: args = list(zip(thisCurve, cutter, tolerance, angleToleranceRadians))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Split2(thisCurve, cutter, tolerance, multiple=False):\n    \"\"\"\n    Splits a curve into pieces using a surface.\n\n    Args:\n        cutter (Surface): A cutting surface or polysurface.\n        tolerance (double): A tolerance for computing intersections.\n\n    Returns:\n        Curve[]: An array of curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/split-curve_surface_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, cutter, tolerance]\n    if multiple: args = list(zip(thisCurve, cutter, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Split3(thisCurve, cutter, tolerance, angleToleranceRadians, multiple=False):\n    \"\"\"\n    Splits a curve into pieces using a surface.\n\n    Args:\n        cutter (Surface): A cutting surface or polysurface.\n        tolerance (double): A tolerance for computing intersections.\n\n    Returns:\n        Curve[]: An array of curves. This array can be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/split-curve_surface_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, cutter, tolerance, angleToleranceRadians]\n    if multiple: args = list(zip(thisCurve, cutter, tolerance, angleToleranceRadians))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Extend(thisCurve, t0, t1, multiple=False):\n    \"\"\"\n    Where possible, analytically extends curve to include the given domain.\n    This will not work on closed curves. The original curve will be identical to the\n    restriction of the resulting curve to the original curve domain.\n\n    Args:\n        t0 (double): Start of extension domain, if the start is not inside the\n            Domain of this curve, an attempt will be made to extend the curve.\n        t1 (double): End of extension domain, if the end is not inside the\n            Domain of this curve, an attempt will be made to extend the curve.\n\n    Returns:\n        Curve: Extended curve on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extend-curve_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, t0, t1]\n    if multiple: args = list(zip(thisCurve, t0, t1))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Extend1(thisCurve, domain, multiple=False):\n    \"\"\"\n    Where possible, analytically extends curve to include the given domain.\n    This will not work on closed curves. The original curve will be identical to the\n    restriction of the resulting curve to the original curve domain.\n\n    Args:\n        domain (Interval): Extension domain.\n\n    Returns:\n        Curve: Extended curve on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extend-curve_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, domain]\n    if multiple: args = list(zip(thisCurve, domain))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Extend2(thisCurve, side, length, style, multiple=False):\n    \"\"\"\n    Extends a curve by a specific length.\n\n    Args:\n        side (CurveEnd): Curve end to extend.\n        length (double): Length to add to the curve end.\n        style (CurveExtensionStyle): Extension style.\n\n    Returns:\n        Curve: A curve with extended ends or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extend-curve_curveend_double_curveextensionstyle\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, length, style]\n    if multiple: args = list(zip(thisCurve, side, length, style))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Extend3(thisCurve, side, style, geometry, multiple=False):\n    \"\"\"\n    Extends a curve until it intersects a collection of objects.\n\n    Args:\n        side (CurveEnd): The end of the curve to extend.\n        style (CurveExtensionStyle): The style or type of extension to use.\n        geometry (System.Collections.Generic.IEnumerable<GeometryBase>): A collection of objects. Allowable object types are Curve, Surface, Brep.\n\n    Returns:\n        Curve: New extended curve result on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extend-curve_curveend_curveextensionstyle_geometrybasearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, style, geometry]\n    if multiple: args = list(zip(thisCurve, side, style, geometry))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Extend4(thisCurve, side, style, endPoint, multiple=False):\n    \"\"\"\n    Extends a curve to a point.\n\n    Args:\n        side (CurveEnd): The end of the curve to extend.\n        style (CurveExtensionStyle): The style or type of extension to use.\n        endPoint (Point3d): A new end point.\n\n    Returns:\n        Curve: New extended curve result on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extend-curve_curveend_curveextensionstyle_point3d\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, style, endPoint]\n    if multiple: args = list(zip(thisCurve, side, style, endPoint))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ExtendOnSurface(thisCurve, side, surface, multiple=False):\n    \"\"\"\n    Extends a curve on a surface.\n\n    Args:\n        side (CurveEnd): The end of the curve to extend.\n        surface (Surface): Surface that contains the curve.\n\n    Returns:\n        Curve: New extended curve result on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extendonsurface-curve_curveend_surface\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, surface]\n    if multiple: args = list(zip(thisCurve, side, surface))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ExtendOnSurface1(thisCurve, side, face, multiple=False):\n    \"\"\"\n    Extends a curve on a surface.\n\n    Args:\n        side (CurveEnd): The end of the curve to extend.\n        face (BrepFace): BrepFace that contains the curve.\n\n    Returns:\n        Curve: New extended curve result on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extendonsurface-curve_curveend_brepface\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, face]\n    if multiple: args = list(zip(thisCurve, side, face))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ExtendByLine(thisCurve, side, geometry, multiple=False):\n    \"\"\"\n    Extends a curve by a line until it intersects a collection of objects.\n\n    Args:\n        side (CurveEnd): The end of the curve to extend.\n        geometry (System.Collections.Generic.IEnumerable<GeometryBase>): A collection of objects. Allowable object types are Curve, Surface, Brep.\n\n    Returns:\n        Curve: New extended curve result on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extendbyline-curve_curveend_geometrybasearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, geometry]\n    if multiple: args = list(zip(thisCurve, side, geometry))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ExtendByArc(thisCurve, side, geometry, multiple=False):\n    \"\"\"\n    Extends a curve by an Arc until it intersects a collection of objects.\n\n    Args:\n        side (CurveEnd): The end of the curve to extend.\n        geometry (System.Collections.Generic.IEnumerable<GeometryBase>): A collection of objects. Allowable object types are Curve, Surface, Brep.\n\n    Returns:\n        Curve: New extended curve result on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/extendbyarc-curve_curveend_geometrybasearray\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, side, geometry]\n    if multiple: args = list(zip(thisCurve, side, geometry))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Simplify(thisCurve, options, distanceTolerance, angleToleranceRadians, multiple=False):\n    \"\"\"\n    Returns a geometrically equivalent PolyCurve.\n    The PolyCurve has the following properties\n    1. All the PolyCurve segments are LineCurve, PolylineCurve, ArcCurve, or NurbsCurve.\n    \n    2. The NURBS Curves segments do not have fully multiple interior knots.\n    \n    3. Rational NURBS curves do not have constant weights.\n    \n    4. Any segment for which IsLinear() or IsArc() is True is a Line,\n    Polyline segment, or an Arc.\n    \n    5. Adjacent co-linear or co-circular segments are combined.\n    \n    6. Segments that meet with G1-continuity have there ends tuned up so\n    that they meet with G1-continuity to within machine precision.\n\n    Args:\n        options (CurveSimplifyOptions): Simplification options.\n        distanceTolerance (double): A distance tolerance for the simplification.\n        angleToleranceRadians (double): An angle tolerance for the simplification.\n\n    Returns:\n        Curve: New simplified curve on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/simplify-curve_curvesimplifyoptions_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, options, distanceTolerance, angleToleranceRadians]\n    if multiple: args = list(zip(thisCurve, options, distanceTolerance, angleToleranceRadians))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef SimplifyEnd(thisCurve, end, options, distanceTolerance, angleToleranceRadians, multiple=False):\n    \"\"\"\n    Same as SimplifyCurve, but simplifies only the last two segments at \"side\" end.\n\n    Args:\n        end (CurveEnd): If CurveEnd.Start the function simplifies the last two start\n            side segments, otherwise if CurveEnd.End the last two end side segments are simplified.\n        options (CurveSimplifyOptions): Simplification options.\n        distanceTolerance (double): A distance tolerance for the simplification.\n        angleToleranceRadians (double): An angle tolerance for the simplification.\n\n    Returns:\n        Curve: New simplified curve on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/simplifyend-curve_curveend_curvesimplifyoptions_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, end, options, distanceTolerance, angleToleranceRadians]\n    if multiple: args = list(zip(thisCurve, end, options, distanceTolerance, angleToleranceRadians))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Fair(thisCurve, distanceTolerance, angleTolerance, clampStart, clampEnd, iterations, multiple=False):\n    \"\"\"\n    Fairs a curve object. Fair works best on degree 3 (cubic) curves. Attempts to\n    remove large curvature variations while limiting the geometry changes to be no\n    more than the specified tolerance.\n\n    Args:\n        distanceTolerance (double): Maximum allowed distance the faired curve is allowed to deviate from the input.\n        angleTolerance (double): (in radians) kinks with angles <= angleTolerance are smoothed out 0.05 is a good default.\n        clampStart (int): The number of (control vertices-1) to preserve at start.\n            0 = preserve start point1 = preserve start point and 1st derivative2 = preserve start point, 1st and 2nd derivative\n        clampEnd (int): Same as clampStart.\n        iterations (int): The number of iterations to use in adjusting the curve.\n\n    Returns:\n        Curve: Returns new faired Curve on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/fair-curve_double_double_int_int_int\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, distanceTolerance, angleTolerance, clampStart, clampEnd, iterations]\n    if multiple: args = list(zip(thisCurve, distanceTolerance, angleTolerance, clampStart, clampEnd, iterations))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Fit(thisCurve, degree, fitTolerance, angleTolerance, multiple=False):\n    \"\"\"\n    Fits a new curve through an existing curve.\n\n    Args:\n        degree (int): The degree of the returned Curve. Must be bigger than 1.\n        fitTolerance (double): The fitting tolerance. If fitTolerance is RhinoMath.UnsetValue or <=0.0,\n            the document absolute tolerance is used.\n        angleTolerance (double): The kink smoothing tolerance in radians.\n            If angleTolerance is 0.0, all kinks are smoothedIf angleTolerance is >0.0, kinks smaller than angleTolerance are smoothedIf angleTolerance is RhinoMath.UnsetValue or <0.0, the document angle tolerance is used for the kink smoothing\n\n    Returns:\n        Curve: Returns a new fitted Curve if successful, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/fit-curve_int_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, degree, fitTolerance, angleTolerance]\n    if multiple: args = list(zip(thisCurve, degree, fitTolerance, angleTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Rebuild(thisCurve, pointCount, degree, preserveTangents, multiple=False):\n    \"\"\"\n    Rebuild a curve with a specific point count.\n\n    Args:\n        pointCount (int): Number of control points in the rebuild curve.\n        degree (int): Degree of curve. Valid values are between and including 1 and 11.\n        preserveTangents (bool): If true, the end tangents of the input curve will be preserved.\n\n    Returns:\n        NurbsCurve: A NURBS curve on success or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/rebuild-curve_int_int_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, pointCount, degree, preserveTangents]\n    if multiple: args = list(zip(thisCurve, pointCount, degree, preserveTangents))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef ToPolyline(thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint, multiple=False):\n    \"\"\"\n    Gets a polyline approximation of a curve.\n\n    Args:\n        mainSegmentCount (int): If mainSegmentCount <= 0, then both subSegmentCount and mainSegmentCount are ignored.\n            If mainSegmentCount > 0, then subSegmentCount must be >= 1. In this\n            case the NURBS will be broken into mainSegmentCount equally spaced\n            chords. If needed, each of these chords can be split into as many\n            subSegmentCount sub-parts if the subdivision is necessary for the\n            mesh to meet the other meshing constraints. In particular, if\n            subSegmentCount = 0, then the curve is broken into mainSegmentCount\n            pieces and no further testing is performed.\n        subSegmentCount (int): An amount of subsegments.\n        maxAngleRadians (double): ( 0 to pi ) Maximum angle (in radians) between unit tangents at\n            adjacent vertices.\n        maxChordLengthRatio (double): Maximum permitted value of\n            (distance chord midpoint to curve) / (length of chord).\n        maxAspectRatio (double): If maxAspectRatio < 1.0, the parameter is ignored.\n            If 1 <= maxAspectRatio < sqrt(2), it is treated as if maxAspectRatio = sqrt(2).\n            This parameter controls the maximum permitted value of\n            (length of longest chord) / (length of shortest chord).\n        tolerance (double): If tolerance = 0, the parameter is ignored.\n            This parameter controls the maximum permitted value of the\n            distance from the curve to the polyline.\n        minEdgeLength (double): The minimum permitted edge length.\n        maxEdgeLength (double): If maxEdgeLength = 0, the parameter\n            is ignored. This parameter controls the maximum permitted edge length.\n        keepStartPoint (bool): If True the starting point of the curve\n            is added to the polyline. If False the starting point of the curve is\n            not added to the polyline.\n\n    Returns:\n        PolylineCurve: PolylineCurve on success, None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/topolyline-curve_int_int_double_double_double_double_double_double_bool\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint]\n    if multiple: args = list(zip(thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ToPolyline1(thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint, curveDomain, multiple=False):\n    \"\"\"\n    Gets a polyline approximation of a curve.\n\n    Args:\n        mainSegmentCount (int): If mainSegmentCount <= 0, then both subSegmentCount and mainSegmentCount are ignored.\n            If mainSegmentCount > 0, then subSegmentCount must be >= 1. In this\n            case the NURBS will be broken into mainSegmentCount equally spaced\n            chords. If needed, each of these chords can be split into as many\n            subSegmentCount sub-parts if the subdivision is necessary for the\n            mesh to meet the other meshing constraints. In particular, if\n            subSegmentCount = 0, then the curve is broken into mainSegmentCount\n            pieces and no further testing is performed.\n        subSegmentCount (int): An amount of subsegments.\n        maxAngleRadians (double): ( 0 to pi ) Maximum angle (in radians) between unit tangents at\n            adjacent vertices.\n        maxChordLengthRatio (double): Maximum permitted value of\n            (distance chord midpoint to curve) / (length of chord).\n        maxAspectRatio (double): If maxAspectRatio < 1.0, the parameter is ignored.\n            If 1 <= maxAspectRatio < sqrt(2), it is treated as if maxAspectRatio = sqrt(2).\n            This parameter controls the maximum permitted value of\n            (length of longest chord) / (length of shortest chord).\n        tolerance (double): If tolerance = 0, the parameter is ignored.\n            This parameter controls the maximum permitted value of the\n            distance from the curve to the polyline.\n        minEdgeLength (double): The minimum permitted edge length.\n        maxEdgeLength (double): If maxEdgeLength = 0, the parameter\n            is ignored. This parameter controls the maximum permitted edge length.\n        keepStartPoint (bool): If True the starting point of the curve\n            is added to the polyline. If False the starting point of the curve is\n            not added to the polyline.\n        curveDomain (Interval): This sub-domain of the NURBS curve is approximated.\n\n    Returns:\n        PolylineCurve: PolylineCurve on success, None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/topolyline-curve_int_int_double_double_double_double_double_double_bool_interval\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint, curveDomain]\n    if multiple: args = list(zip(thisCurve, mainSegmentCount, subSegmentCount, maxAngleRadians, maxChordLengthRatio, maxAspectRatio, tolerance, minEdgeLength, maxEdgeLength, keepStartPoint, curveDomain))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ToPolyline2(thisCurve, tolerance, angleTolerance, minimumLength, maximumLength, multiple=False):\n    \"\"\"\n    Gets a polyline approximation of a curve.\n\n    Args:\n        tolerance (double): The tolerance. This is the maximum deviation from line midpoints to the curve. When in doubt, use the document's model space absolute tolerance.\n        angleTolerance (double): The angle tolerance in radians. This is the maximum deviation of the line directions. When in doubt, use the document's model space angle tolerance.\n        minimumLength (double): The minimum segment length.\n        maximumLength (double): The maximum segment length.\n\n    Returns:\n        PolylineCurve: PolyCurve on success, None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/topolyline-curve_double_double_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance, angleTolerance, minimumLength, maximumLength]\n    if multiple: args = list(zip(thisCurve, tolerance, angleTolerance, minimumLength, maximumLength))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef ToArcsAndLines(thisCurve, tolerance, angleTolerance, minimumLength, maximumLength, multiple=False):\n    \"\"\"\n    Converts a curve into polycurve consisting of arc segments. Sections of the input curves that are nearly straight are converted to straight-line segments.\n\n    Args:\n        tolerance (double): The tolerance. This is the maximum deviation from arc midpoints to the curve. When in doubt, use the document's model space absolute tolerance.\n        angleTolerance (double): The angle tolerance in radians. This is the maximum deviation of the arc end directions from the curve direction. When in doubt, use the document's model space angle tolerance.\n        minimumLength (double): The minimum segment length.\n        maximumLength (double): The maximum segment length.\n\n    Returns:\n        PolyCurve: PolyCurve on success, None on error.\n    \"\"\"\n    url = \"rhino/geometry/curve/toarcsandlines-curve_double_double_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, tolerance, angleTolerance, minimumLength, maximumLength]\n    if multiple: args = list(zip(thisCurve, tolerance, angleTolerance, minimumLength, maximumLength))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef PullToMesh(thisCurve, mesh, tolerance, multiple=False):\n    \"\"\"\n    Makes a polyline approximation of the curve and gets the closest point on the mesh for each point on the curve.\n    Then it \"connects the points\" so that you have a polyline on the mesh.\n\n    Args:\n        mesh (Mesh): Mesh to project onto.\n        tolerance (double): Input tolerance (RhinoDoc.ModelAbsoluteTolerance is a good default)\n\n    Returns:\n        PolylineCurve: A polyline curve on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/pulltomesh-curve_mesh_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, mesh, tolerance]\n    if multiple: args = list(zip(thisCurve, mesh, tolerance))\n    response = Util.ComputeFetch(url, args)\n    return response\n\n\ndef Offset(thisCurve, plane, distance, tolerance, cornerStyle, multiple=False):\n    \"\"\"\n    Offsets this curve. If you have a nice offset, then there will be one entry in\n    the array. If the original curve had kinks or the offset curve had self\n    intersections, you will get multiple segments in the output array.\n\n    Args:\n        plane (Plane): Offset solution plane.\n        distance (double): The positive or negative distance to offset.\n        tolerance (double): The offset or fitting tolerance.\n        cornerStyle (CurveOffsetCornerStyle): Corner style for offset kinks.\n\n    Returns:\n        Curve[]: Offset curves on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offset-curve_plane_double_double_curveoffsetcornerstyle\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, plane, distance, tolerance, cornerStyle]\n    if multiple: args = list(zip(thisCurve, plane, distance, tolerance, cornerStyle))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Offset1(thisCurve, directionPoint, normal, distance, tolerance, cornerStyle, multiple=False):\n    \"\"\"\n    Offsets this curve. If you have a nice offset, then there will be one entry in\n    the array. If the original curve had kinks or the offset curve had self\n    intersections, you will get multiple segments in the output array.\n\n    Args:\n        directionPoint (Point3d): A point that indicates the direction of the offset.\n        normal (Vector3d): The normal to the offset plane.\n        distance (double): The positive or negative distance to offset.\n        tolerance (double): The offset or fitting tolerance.\n        cornerStyle (CurveOffsetCornerStyle): Corner style for offset kinks.\n\n    Returns:\n        Curve[]: Offset curves on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offset-curve_point3d_vector3d_double_double_curveoffsetcornerstyle\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, directionPoint, normal, distance, tolerance, cornerStyle]\n    if multiple: args = list(zip(thisCurve, directionPoint, normal, distance, tolerance, cornerStyle))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef Offset2(thisCurve, directionPoint, normal, distance, tolerance, angleTolerance, loose, cornerStyle, endStyle, multiple=False):\n    \"\"\"\n    Offsets this curve. If you have a nice offset, then there will be one entry in\n    the array. If the original curve had kinks or the offset curve had self\n    intersections, you will get multiple segments in the output array.\n\n    Args:\n        directionPoint (Point3d): A point that indicates the direction of the offset.\n        normal (Vector3d): The normal to the offset plane.\n        distance (double): The positive or negative distance to offset.\n        tolerance (double): The offset or fitting tolerance.\n        angleTolerance (double): The angle tolerance, in radians, used to decide whether to split at kinks.\n        loose (bool): If false, offset within tolerance. If true, offset by moving edit points.\n        cornerStyle (CurveOffsetCornerStyle): Corner style for offset kinks.\n        endStyle (CurveOffsetEndStyle): End style for non-loose, non-closed curve offsets.\n\n    Returns:\n        Curve[]: Offset curves on success, None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offset-curve_point3d_vector3d_double_double_double_bool_curveoffsetcornerstyle_curveoffsetendstyle\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, directionPoint, normal, distance, tolerance, angleTolerance, loose, cornerStyle, endStyle]\n    if multiple: args = list(zip(thisCurve, directionPoint, normal, distance, tolerance, angleTolerance, loose, cornerStyle, endStyle))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef RibbonOffset(thisCurve, distance, blendRadius, directionPoint, normal, tolerance, multiple=False):\n    \"\"\"\n    Offsets a closed curve in the following way: pProject the curve to a plane with given normal.\n    Then, loose Offset the projection by distance + blend_radius and trim off self-intersection.\n    THen, Offset the remaining curve back in the opposite direction by blend_radius, filling gaps with blends.\n    Finally, use the elevations of the input curve to get the correct elevations of the result.\n\n    Args:\n        distance (double): The positive distance to offset the curve.\n        blendRadius (double): Positive, typically the same as distance. When the offset results in a self-intersection\n            that gets trimmed off at a kink, the kink will be blended out using this radius.\n        directionPoint (Point3d): A point that indicates the direction of the offset. If the offset is inward,\n            the point's projection to the plane should be well within the curve.\n            It will be used to decide which part of the offset to keep if there are self-intersections.\n        normal (Vector3d): A vector that indicates the normal of the plane in which the offset will occur.\n        tolerance (double): Used to determine self-intersections, not offset error.\n\n    Returns:\n        Curve: The offset curve if successful.\n    \"\"\"\n    url = \"rhino/geometry/curve/ribbonoffset-curve_double_double_point3d_vector3d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, distance, blendRadius, directionPoint, normal, tolerance]\n    if multiple: args = list(zip(thisCurve, distance, blendRadius, directionPoint, normal, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetOnSurface(thisCurve, face, distance, fittingTolerance, multiple=False):\n    \"\"\"\n    Offset this curve on a brep face surface. This curve must lie on the surface.\n\n    Args:\n        face (BrepFace): The brep face on which to offset.\n        distance (double): A distance to offset (+)left, (-)right.\n        fittingTolerance (double): A fitting tolerance.\n\n    Returns:\n        Curve[]: Offset curves on success, or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetonsurface-curve_brepface_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, face, distance, fittingTolerance]\n    if multiple: args = list(zip(thisCurve, face, distance, fittingTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetOnSurface1(thisCurve, face, throughPoint, fittingTolerance, multiple=False):\n    \"\"\"\n    Offset a curve on a brep face surface. This curve must lie on the surface.\n    This overload allows to specify a surface point at which the offset will pass.\n\n    Args:\n        face (BrepFace): The brep face on which to offset.\n        throughPoint (Point2d): 2d point on the brep face to offset through.\n        fittingTolerance (double): A fitting tolerance.\n\n    Returns:\n        Curve[]: Offset curves on success, or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetonsurface-curve_brepface_point2d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, face, throughPoint, fittingTolerance]\n    if multiple: args = list(zip(thisCurve, face, throughPoint, fittingTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetOnSurface2(thisCurve, face, curveParameters, offsetDistances, fittingTolerance, multiple=False):\n    \"\"\"\n    Offset a curve on a brep face surface. This curve must lie on the surface.\n    This overload allows to specify different offsets for different curve parameters.\n\n    Args:\n        face (BrepFace): The brep face on which to offset.\n        curveParameters (double[]): Curve parameters corresponding to the offset distances.\n        offsetDistances (double[]): distances to offset (+)left, (-)right.\n        fittingTolerance (double): A fitting tolerance.\n\n    Returns:\n        Curve[]: Offset curves on success, or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetonsurface-curve_brepface_doublearray_doublearray_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, face, curveParameters, offsetDistances, fittingTolerance]\n    if multiple: args = list(zip(thisCurve, face, curveParameters, offsetDistances, fittingTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetOnSurface3(thisCurve, surface, distance, fittingTolerance, multiple=False):\n    \"\"\"\n    Offset a curve on a surface. This curve must lie on the surface.\n\n    Args:\n        surface (Surface): A surface on which to offset.\n        distance (double): A distance to offset (+)left, (-)right.\n        fittingTolerance (double): A fitting tolerance.\n\n    Returns:\n        Curve[]: Offset curves on success, or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetonsurface-curve_surface_double_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, surface, distance, fittingTolerance]\n    if multiple: args = list(zip(thisCurve, surface, distance, fittingTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetOnSurface4(thisCurve, surface, throughPoint, fittingTolerance, multiple=False):\n    \"\"\"\n    Offset a curve on a surface. This curve must lie on the surface.\n    This overload allows to specify a surface point at which the offset will pass.\n\n    Args:\n        surface (Surface): A surface on which to offset.\n        throughPoint (Point2d): 2d point on the brep face to offset through.\n        fittingTolerance (double): A fitting tolerance.\n\n    Returns:\n        Curve[]: Offset curves on success, or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetonsurface-curve_surface_point2d_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, surface, throughPoint, fittingTolerance]\n    if multiple: args = list(zip(thisCurve, surface, throughPoint, fittingTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetOnSurface5(thisCurve, surface, curveParameters, offsetDistances, fittingTolerance, multiple=False):\n    \"\"\"\n    Offset this curve on a surface. This curve must lie on the surface.\n    This overload allows to specify different offsets for different curve parameters.\n\n    Args:\n        surface (Surface): A surface on which to offset.\n        curveParameters (double[]): Curve parameters corresponding to the offset distances.\n        offsetDistances (double[]): Distances to offset (+)left, (-)right.\n        fittingTolerance (double): A fitting tolerance.\n\n    Returns:\n        Curve[]: Offset curves on success, or None on failure.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetonsurface-curve_surface_doublearray_doublearray_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, surface, curveParameters, offsetDistances, fittingTolerance]\n    if multiple: args = list(zip(thisCurve, surface, curveParameters, offsetDistances, fittingTolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef PullToBrepFace1(thisCurve, face, tolerance, multiple=False):\n    \"\"\"\n    Pulls this curve to a brep face and returns the result of that operation.\n\n    Args:\n        face (BrepFace): A brep face.\n        tolerance (double): A tolerance value.\n\n    Returns:\n        Curve[]: An array containing the resulting curves after pulling. This array could be empty.\n    \"\"\"\n    url = \"rhino/geometry/curve/pulltobrepface-curve_brepface_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, face, tolerance]\n    if multiple: args = list(zip(thisCurve, face, tolerance))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n\ndef OffsetNormalToSurface(thisCurve, surface, height, multiple=False):\n    \"\"\"\n    Finds a curve by offsetting an existing curve normal to a surface.\n    The caller is responsible for ensuring that the curve lies on the input surface.\n\n    Args:\n        surface (Surface): Surface from which normals are calculated.\n        height (double): offset distance (distance from surface to result curve)\n\n    Returns:\n        Curve: Offset curve at distance height from the surface.  The offset curve is\n        interpolated through a small number of points so if the surface is irregular\n        or complicated, the result will not be a very accurate offset.\n    \"\"\"\n    url = \"rhino/geometry/curve/offsetnormaltosurface-curve_surface_double\"\n    if multiple: url += \"?multiple=true\"\n    args = [thisCurve, surface, height]\n    if multiple: args = list(zip(thisCurve, surface, height))\n    response = Util.ComputeFetch(url, args)\n    response = Util.DecodeToCommonObject(response)\n    return response\n\n",
  "language": "python",
  "imports": [
    "RhinoCommon"
  ],
  "has_docstring": false
}