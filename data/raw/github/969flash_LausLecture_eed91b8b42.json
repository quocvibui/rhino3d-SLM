{
  "source_url": "https://github.com/969flash/LausLecture/blob/004c0a8938bf805b8d70c744ddf5eb911fd4277f/Lecture3/utils.py",
  "repo": "969flash/LausLecture",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Lecture3/utils.py",
  "instruction": null,
  "code": "# r: pyshp\n\nimport Rhino.Geometry as geo\nimport shapefile\nimport os\nimport zipfile\nfrom typing import List, Tuple, Any, Optional\nimport ghpythonlib.components as ghcomp\n\n\nclass Parcel:\n    \"\"\"기본 필지 클래스\"\"\"\n\n    def __init__(\n        self,\n        curve_crv: geo.Curve,\n        pnu: str,\n        jimok: str,\n        record: List[Any],\n        hole_regions: List[geo.Curve],\n    ):\n        self.region = curve_crv  # 외부 경계 커브\n        self.hole_regions = (\n            hole_regions if hole_regions is not None else []\n        )  # 내부 구멍들\n        self.pnu = pnu\n        self.jimok = jimok\n        self.record = record\n\n    def preprocess_curve(self) -> bool:\n        \"\"\"커브 전처리 (invalid 제거, 자체교차 제거, 단순화)\"\"\"\n        if not self.region or not self.region.IsValid:\n            return False\n\n        # 자체교차 확인\n        intersection_events = geo.Intersect.Intersection.CurveSelf(self.region, 0.001)\n        if intersection_events:\n            simplified = self.region.Simplify(geo.CurveSimplifyOptions.All, 0.1, 1.0)\n            if simplified:\n                self.region = simplified\n            else:\n                return False\n\n        # 일반 단순화\n        simplified = self.region.Simplify(geo.CurveSimplifyOptions.All, 0.1, 1.0)\n        if simplified:\n            self.region = simplified\n\n        # 내부 구멍들도 처리\n        valid_holes = []\n        for hole in self.hole_regions:\n            if hole and hole.IsValid:\n                simplified_hole = hole.Simplify(geo.CurveSimplifyOptions.All, 0.1, 1.0)\n                if simplified_hole:\n                    valid_holes.append(simplified_hole)\n                else:\n                    valid_holes.append(hole)\n        self.hole_regions = valid_holes\n\n        return True\n\n\nclass Road(Parcel):\n    \"\"\"도로 클래스\"\"\"\n\n    pass\n\n\nclass Lot(Parcel):\n    \"\"\"대지 클래스\"\"\"\n\n    def __init__(\n        self,\n        curve_crv: geo.Curve,\n        pnu: str,\n        jimok: str,\n        record: List[Any],\n        hole_regions: List[geo.Curve] = None,\n    ):\n        super().__init__(curve_crv, pnu, jimok, record, hole_regions)\n        self.is_flag_lot = False  # 자루형 토지 여부\n        self.has_road_access = False  # 도로 접근 여부\n\n\ndef read_shp_file(file_path: str) -> Tuple[List[Any], List[Any], List[str]]:\n    \"\"\"shapefile을 읽어서 shapes와 records를 반환\"\"\"\n    try:\n        sf = shapefile.Reader(file_path, encoding=\"utf-8\")\n    except:\n        try:\n            sf = shapefile.Reader(file_path, encoding=\"cp949\")\n        except:\n            sf = shapefile.Reader(file_path)\n\n    shapes = sf.shapes()\n    records = sf.records()\n    fields = [field[0] for field in sf.fields[1:]]\n    return shapes, records, fields\n\n\ndef get_curve_from_points(\n    points: List[Tuple[float, float]], start_idx: int, end_idx: int\n) -> Optional[geo.PolylineCurve]:\n    \"\"\"점 리스트에서 특정 구간의 커브를 생성\"\"\"\n    # 최소 3개의 점이 필요\n    if end_idx - start_idx < 3:\n        return None\n\n    # 시작과 끝 점이 동일하지 않으면(닫혀있지 않으면) None 반환\n    first_pt = points[start_idx]\n    last_pt = points[end_idx - 1]\n    if first_pt[0] != last_pt[0] or first_pt[1] != last_pt[1]:\n        return None\n\n    curve_points = [\n        geo.Point3d(points[i][0], points[i][1], 0) for i in range(start_idx, end_idx)\n    ]\n\n    curve_crv = geo.PolylineCurve(curve_points)\n    return curve_crv if curve_crv and curve_crv.IsValid else None\n\n\ndef get_part_indices(shape: Any) -> List[Tuple[int, int]]:\n    \"\"\"shape의 각 파트의 시작과 끝 인덱스를 반환\"\"\"\n    if not hasattr(shape, \"parts\") or len(shape.parts) <= 1:\n        return [(0, len(shape.points))]\n\n    parts = list(shape.parts) + [len(shape.points)]\n    return [(parts[i], parts[i + 1]) for i in range(len(shape.parts))]\n\n\ndef get_curves_from_shape(\n    shape: Any,\n) -> Tuple[Optional[geo.PolylineCurve], List[geo.PolylineCurve]]:\n    \"\"\"shape에서 외부 경계와 내부 구멍 커브들을 추출\"\"\"\n    boundary_region = None\n    hole_regions = []\n\n    part_indices = get_part_indices(shape)\n\n    for i, (start_idx, end_idx) in enumerate(part_indices):\n        curve_crv = get_curve_from_points(shape.points, start_idx, end_idx)\n        if curve_crv:\n            if i == 0:\n                boundary_region = curve_crv\n            else:\n                hole_regions.append(curve_crv)\n\n    # 단일 폴리곤이고 닫혀있지 않은 경우 처리\n    if boundary_region is None and len(part_indices) == 1:\n        points = [geo.Point3d(pt[0], pt[1], 0) for pt in shape.points]\n        if len(points) >= 3:\n            if points[0].DistanceTo(points[-1]) > 0.001:\n                points.append(points[0])\n            curve_crv = geo.PolylineCurve(points)\n            if curve_crv and curve_crv.IsValid:\n                boundary_region = curve_crv\n\n    return boundary_region, hole_regions\n\n\ndef get_field_value(\n    record: List[Any], fields: List[str], field_name: str, default: str = \"Unknown\"\n) -> str:\n    \"\"\"레코드에서 특정 필드값을 안전하게 추출\"\"\"\n    try:\n        index = fields.index(field_name)\n        return record[index]\n    except (ValueError, IndexError):\n        return default\n\n\ndef create_parcel_from_shape(\n    shape: Any, record: List[Any], fields: List[str]\n) -> Optional[Parcel]:\n    \"\"\"shape에서 Parcel 객체 생성\"\"\"\n    boundary_region, hole_regions = get_curves_from_shape(shape)\n\n    if not boundary_region or not boundary_region.IsValid:\n        return None\n\n    pnu = get_field_value(record, fields, \"A1\")  # 구 PNU\n    jimok = get_field_value(record, fields, \"A11\")  # 구 JIMOK\n\n    if jimok == \"도로\":\n        parcel = Road(boundary_region, pnu, jimok, record, hole_regions)\n    else:\n        parcel = Lot(boundary_region, pnu, jimok, record, hole_regions)\n\n    return parcel if parcel.preprocess_curve() else None\n\n\ndef get_parcels_from_shapes(\n    shapes: List[Any], records: List[Any], fields: List[str]\n) -> List[Parcel]:\n    \"\"\"모든 shape에서 Parcel 객체들을 생성\"\"\"\n    parcels = []\n\n    for shape, record in zip(shapes, records):\n        parcel = create_parcel_from_shape(shape, record, fields)\n        if parcel:\n            parcels.append(parcel)\n\n    return parcels\n\n\ndef classify_parcels(parcels: List[Parcel]) -> Tuple[List[Lot], List[Road]]:\n    \"\"\"Parcel 리스트를 Lot과 Road로 분류\"\"\"\n    lots = []\n    roads = []\n\n    for parcel in parcels:\n        if isinstance(parcel, Road):\n            roads.append(parcel)\n        else:\n            lots.append(parcel)\n\n    return lots, roads\n\n\n# ================ GeometryUtils 함수들 ================\n\n\ndef get_point_from_shape(pts: List) -> geo.Point3d:\n    \"\"\"단일 포인트 정보만 갖고있는 리스트를 Point3d로 변환\"\"\"\n    pts = list(pts)\n    if len(pts) == 2:\n        pts.append(0)\n    return geo.Point3d(*pts)\n\n\ndef get_vertices(curve: geo.Curve) -> List[geo.Point3d]:\n    \"\"\"커브의 정점들을 추출\"\"\"\n    vertices = [curve.PointAt(curve.SpanDomain(i)[0]) for i in range(curve.SpanCount)]\n    if not curve.IsClosed:\n        vertices.append(curve.PointAtEnd)\n    return vertices\n\n\ndef get_projected_pt_on_mesh(pt: geo.Point3d, mesh: geo.Mesh) -> Optional[geo.Point3d]:\n    \"\"\"점을 메시에 투영\"\"\"\n    for direction in [geo.Vector3d(0, 0, -1), geo.Vector3d(0, 0, 1)]:\n        ray = geo.Ray3d(pt, direction)\n        t = geo.Intersect.Intersection.MeshRay(mesh, ray)\n        if t >= 0:\n            return ray.PointAt(t)\n    return None\n\n\n# ================ Shape type mapping ================\n\nSHAPE_TYPES = {\n    \"point\": [\n        1,  # POINT\n        8,  # MULTIPOINT\n        11,  # POINTS\n        18,  # MULTIPOINTZ\n        21,  # POINTM\n        28,  # MULTIPOINTM\n    ],\n    \"polyline\": [\n        3,  # POLYLINE\n        5,  # POLYGON\n        13,  # POLYLINES\n        15,  # POLYGONZ\n        23,  # POLYLINEM\n        25,  # POLYGONM\n        31,  # MULTIPATCH\n    ],\n}\n\n\ndef find_shape_type(shape_type_id: int) -> Optional[str]:\n    \"\"\"Shape type ID로부터 type 이름을 찾기\"\"\"\n    for key, values in SHAPE_TYPES.items():\n        if shape_type_id in values:\n            return key\n    return None\n\n\n# ================ Shapefile 파싱 함수들 ================\n\n\ndef parse_geometry(shape: Any, shape_type: str) -> List[Any]:\n    \"\"\"shape 객체를 geometry로 파싱\"\"\"\n    if shape_type == \"point\":\n        return [get_point_from_shape(pt) for pt in shape.points]\n    elif shape_type == \"polyline\":\n        parts = [\n            shape.points[\n                shape.parts[i] : (\n                    shape.parts[i + 1] if i + 1 < len(shape.parts) else None\n                )\n            ]\n            for i in range(len(shape.parts))\n        ]\n        return [\n            geo.PolylineCurve([get_point_from_shape(pt) for pt in part])\n            for part in parts\n        ]\n    return []\n\n\ndef read_shapefile_from_reader(sf: shapefile.Reader, encoding: str = \"utf-8\") -> Tuple:\n    \"\"\"shapefile.Reader 객체에서 데이터 읽기\"\"\"\n    result_geom = []\n    result_fields = []\n    result_field_names = []\n    result_records = []\n\n    shape_type = find_shape_type(sf.shapeType)\n\n    # Extract field names\n    for field in sf.fields:\n        if field[0] != \"DeletionFlag\":\n            _field = field[0]\n            if isinstance(_field, bytes):\n                _field = _field.decode(encoding, errors=\"replace\")\n            result_field_names.append(_field)\n            result_fields.append(field)\n\n    # Extract geometry and records\n    for shape, record in zip(sf.shapes(), sf.records()):\n        geom = parse_geometry(shape, shape_type)\n        result_geom.append(geom)\n        _record = []\n        for rec in record:\n            if isinstance(rec, bytes):\n                _record.append(rec.decode(encoding, errors=\"replace\"))\n            else:\n                _record.append(rec)\n        result_records.append(_record)\n\n    return (\n        shape_type,\n        result_geom,\n        result_fields,\n        result_field_names,\n        result_records,\n    )\n\n\n# ================ Contour 처리 함수들 ================\n\n\ndef create_contour_curves(\n    contour_geometry_records: List[Tuple],\n) -> List[geo.PolylineCurve]:\n    \"\"\"contour geometry와 record로부터 3D 커브 생성\"\"\"\n    contour_crvs = []\n    for contour_geom, contour_record in contour_geometry_records:\n        contour_crvs.append(\n            geo.PolylineCurve(\n                [\n                    geo.Point3d(\n                        contour_geom[0].Point(pt_count).X,\n                        contour_geom[0].Point(pt_count).Y,\n                        contour_record[1],\n                    )\n                    for pt_count in range(contour_geom[0].SpanCount)\n                ]\n            )\n        )\n    return contour_crvs\n\n\ndef create_points_for_mesh(\n    contour_curves: List[geo.Curve], resolution: float\n) -> List[geo.Point3d]:\n    \"\"\"contour 커브들로부터 메시 생성용 점들 생성\"\"\"\n    points = []\n    for curve in contour_curves:\n        params = curve.DivideByLength(resolution, True)\n        if params:\n            points.extend([curve.PointAt(param) for param in params])\n\n    return points\n\n\n# ================ Building 처리 함수들 ================\n\n\ndef create_building_breps(\n    building_geometry_records: List[Tuple], mesh_terrain: geo.Mesh\n) -> List[geo.Brep]:\n    \"\"\"건물 geometry와 record로부터 Brep 생성\"\"\"\n    breps = []\n    for geom, record in building_geometry_records:\n        base_curve = geom[0]\n        height = record[5] * 3.5\n        vertices = get_vertices(base_curve)\n\n        projected_pts = [get_projected_pt_on_mesh(pt, mesh_terrain) for pt in vertices]\n        projected_pts = list(filter(None, projected_pts))\n\n        if projected_pts:\n            min_z = min(pt.Z for pt in projected_pts)\n            base_curve.Translate(geo.Vector3d(0, 0, min_z - vertices[0].Z))\n            breps.append(geo.Extrusion.Create(base_curve, -height, True))\n    return breps\n\n\n# ================ ZIP/Shapefile 처리 함수들 ================\n\n\ndef read_shapefiles_from_zip(\n    zip_paths: List[str], file_prefixes: List[str]\n) -> List[shapefile.Reader]:\n    \"\"\"ZIP 파일들에서 shapefile 읽기\"\"\"\n    readers = []\n    zip_files = [zipfile.ZipFile(zip_path, \"r\") for zip_path in zip_paths]\n\n    for zip_file in zip_files:\n        for prefix in file_prefixes:\n            try:\n                # 먼저 UTF-8로 시도\n                try:\n                    readers.append(\n                        shapefile.Reader(\n                            shp=zip_file.open(f\"{prefix}.shp\"),\n                            shx=zip_file.open(f\"{prefix}.shx\"),\n                            dbf=zip_file.open(f\"{prefix}.dbf\"),\n                            prj=zip_file.open(f\"{prefix}.prj\"),\n                            encoding=\"utf-8\",\n                        )\n                    )\n                except UnicodeDecodeError:\n                    # UTF-8 실패시 CP949로 시도\n                    readers.append(\n                        shapefile.Reader(\n                            shp=zip_file.open(f\"{prefix}.shp\"),\n                            shx=zip_file.open(f\"{prefix}.shx\"),\n                            dbf=zip_file.open(f\"{prefix}.dbf\"),\n                            prj=zip_file.open(f\"{prefix}.prj\"),\n                            encoding=\"cp949\",\n                        )\n                    )\n            except KeyError:\n                continue\n\n    # Close zip files\n    for zip_file in zip_files:\n        zip_file.close()\n\n    return readers\n\n\n# ================ ShpData 클래스 ================\n\n\nclass ShpData:\n    \"\"\"Shapefile 데이터를 저장하는 클래스\"\"\"\n\n    def __init__(\n        self,\n        shape_type: str,\n        geometry: List,\n        fields: List,\n        field_names: List[str],\n        records: List,\n    ):\n        self.shape_type = shape_type\n        self.geometry = geometry\n        self.fields = fields\n        self.field_names = field_names\n        self.records = records\n\n\ndef extract_data_from_shapefiles(shapefiles: List[shapefile.Reader]) -> ShpData:\n    \"\"\"여러 shapefile에서 데이터 추출하여 ShpData로 통합\"\"\"\n    all_geometry = []\n    all_fields = []\n    all_field_names = []\n    all_records = []\n    shape_type = None\n\n    for sf in shapefiles:\n        result = read_shapefile_from_reader(sf)\n        if shape_type is None:\n            shape_type = result[0]\n        all_geometry.extend(result[1])\n        all_fields.extend(result[2])\n        all_field_names.extend(result[3])\n        all_records.extend(result[4])\n\n    return ShpData(shape_type, all_geometry, all_fields, all_field_names, all_records)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}