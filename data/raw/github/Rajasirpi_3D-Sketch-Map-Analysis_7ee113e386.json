{
  "source_url": "https://github.com/Rajasirpi/3D-Sketch-Map-Analysis/blob/9e54a8c7bdb9e9ac1e46984715d186f54262eced/Analysis_Scripts/Connection_info.py",
  "repo": "Rajasirpi/3D-Sketch-Map-Analysis",
  "repo_stars": 0,
  "repo_description": null,
  "license": "MIT",
  "filepath": "Analysis_Scripts/Connection_info.py",
  "instruction": "Connection info",
  "code": "import json\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino\nimport itertools\nimport Rhino.Geometry as rg\n\ndef generate_result():\n    \n    def find_connections(layer_name):\n        # Get all objects on the specified layer\n        objects = rs.ObjectsByLayer(layer_name)\n    \n        # Initialize dictionaries to store points\n        coor = {}\n    \n        # Iterate over each object\n        for obj in objects:\n            # Check if the object has a user text 'ID'\n            if rs.GetUserText(obj, 'ID'):\n                # Get the ID value\n                object_id = rs.GetUserText(obj, 'ID')\n                \n                # Get the object's geometry as a RhinoCommon object\n                geometry = rs.coercegeometry(obj)\n    \n                # Check if the geometry is an extrusion\n                if isinstance(geometry, Rhino.Geometry.Extrusion) or isinstance(geometry, Rhino.Geometry.Brep):\n                    # Get the eight corner points\n                    if isinstance(geometry, Rhino.Geometry.Extrusion):\n                        corner_points = geometry.GetBoundingBox(True).GetCorners()\n                    else:  # Handle polysurfaces\n                        brep = Rhino.Geometry.Brep.TryConvertBrep(geometry)\n                        if brep:\n                            corner_points = brep.GetBoundingBox(True).GetCorners()\n                        else:\n                            continue \n \n                    # Convert the points to a list of coordinates\n                    corner_points = [[round(point.X, 6), round(point.Y, 6), round(point.Z, 6)] for point in corner_points]\n                    \n                    # Store the corner points in the dictionary\n                    coor[object_id] = corner_points\n                    \n                # Check if the geometry is a surface using rs.IsSurface()\n                elif rs.IsSurface(obj):\n                    # Get the surface points\n                    surface_pts = rs.SurfacePoints(obj)\n    \n                    if surface_pts:\n                        # Convert the points to a list of coordinates\n                        surface_pts = [[round(point.X, 6), round(point.Y, 6), round(point.Z, 6)] for point in surface_pts]\n                        \n                        # Store the surface points in the dictionary\n                        coor[object_id] = surface_pts\n    \n        # Create a dictionary to store the final result\n        result = {\n            \"coordinates\": coor\n        }\n    \n        # Convert the result to JSON format\n        data = json.dumps(result, indent=4)\n    \n        #Parse the JSON data into a dictionary\n        data_dict = json.loads(data)\n    \n        # Extract the extrusion points from the data dictionary\n        points = data_dict[\"coordinates\"]\n\n        #Get the IDs of the extrusion points\n        ids = list(points.keys())\n    \n        connections = [] \n        \n        for original_id in ids:\n            target_connections = []\n            \n            for target_id in ids:\n                if original_id != target_id:  # Skip comparing with the same ID\n                    num_matching_points = sum(1 for x, y in itertools.product(points[original_id], points[target_id]) if x == y)\n                    \n                    if num_matching_points == 4:\n                        target_connections.append({\n                            \"id\": target_id,\n                            \"Connection Type\": \"surface\"\n                        })\n                    elif num_matching_points == 2:\n                        target_connections.append({\n                            \"id\": target_id,\n                            \"Connection Type\": \"edge or partial surface\"\n                        })\n                    elif num_matching_points == 1:\n                        target_connections.append({\n                            \"id\": target_id,\n                            \"Connection Type\": \"point\"\n                        })\n                        \n            if target_connections:  # Check if any target IDs found\n                connections.append({\n                    \"Original id\": original_id,\n                    \"Target ids\": target_connections\n                })\n                \n        return connections\n\n    def find_point_intersection(layer_name):\n        objects = rs.ObjectsByLayer(layer_name)\n    \n        # Get the IDs of point objects in the layer\n        point_ids = [obj for obj in objects if rs.IsPoint(obj)]\n    \n        # Create dictionaries to store extrusion information\n        extrusion_ids = {}\n        extrusion_types = {}\n    \n        # Find extrusions associated with the points and retrieve ID and type values\n        for point_id in point_ids:\n            point_coords = rs.PointCoordinates(point_id)\n            extrusions = []\n            for obj in objects:\n                if rs.ObjectType(obj) == rs.filter.extrusion or rs.ObjectType(obj) == rs.filter.polysurface:\n                    if rs.IsPolysurface(obj):\n                        extrusion = rs.coercebrep(obj)\n                        is_inside = extrusion.IsPointInside(point_coords, rs.UnitAbsoluteTolerance(), False)\n                        if is_inside:\n                            extrusions.append(obj)\n                    else:\n                        extrusion = rs.coercegeometry(obj)\n                        brep = extrusion.ToBrep()\n                        is_inside = brep.IsPointInside(point_coords, rs.UnitAbsoluteTolerance(), False)\n                        if is_inside:\n                            extrusions.append(obj)\n                    \n    \n            if extrusions:\n                # Get the ID from the user attribute text of the point\n                point_id_attr = rs.GetUserText(point_id, 'ID')\n                if point_id_attr:\n                    extrusion_ids[point_id_attr] = extrusions\n    \n                    # Get the 'type' attribute value\n                    extrusion_type = rs.GetUserText(point_id, 'type')\n                    if extrusion_type:\n                        extrusion_types[point_id_attr] = extrusion_type\n    \n        # Create a result dictionary\n        result_dict = {}\n        for point_id, extrusions in extrusion_ids.items():\n            extrusion_data = []\n            for extrusion in extrusions:\n                extrusion_id = rs.GetUserText(extrusion, 'ID')\n                extrusion_type = extrusion_types.get(point_id, \"No type available\")\n                extrusion_data.append({\"Extrusion ID\": extrusion_id, \"Type\": extrusion_type})\n            result_dict[point_id] = extrusion_data\n    \n        return result_dict\n    \n    def is_surface_inside_polysurface(layer_name):\n        # Get all objects on the specified layer\n        objects = rs.ObjectsByLayer(layer_name)\n        \n        # Get all surface objects in the model\n        surface_objects = rs.ObjectsByType(rs.filter.surface)\n        \n        # Initialize dictionaries to store surface and polysurface IDs\n        surface_ids = {}\n        polysurface_ids = {}\n    \n        # Find surface and polysurface IDs based on user attribute text\n        for obj in objects:\n            # Check if the object has a user attribute text 'ID'\n            if rs.GetUserText(obj, 'ID'):\n                # Get the ID value\n                object_id = rs.GetUserText(obj, 'ID')\n    \n                # Check if the object is a surface and in the surface_objects list\n                if obj in surface_objects:\n                    surface_ids[object_id] = obj\n    \n                # Check if the object is a polysurface using rs.IsObjectSolid()\n                if rs.IsPolysurface(obj):\n                    polysurface_ids[object_id] = obj\n    \n    #     Create a dictionary to store the connections\n        connections = {}\n    \n        def find_inside_relationship(surface_id, polysurface_id):\n            if surface_id not in connections:\n                connections[surface_id] = {\"Connection\": []}\n    \n            connections[surface_id][\"Connection\"].append(\"ID {} is inside ID {}\".format(surface_id, polysurface_id))\n    \n            if polysurface_id in surface_inside_polysurface:\n                new_polysurface_id = surface_inside_polysurface[polysurface_id]\n                find_inside_relationship(surface_id, new_polysurface_id)\n                \n    \n        # Iterate over each surface and check if it is inside any of the polysurfaces\n        surface_inside_polysurface = {}\n        \n        for surface_id, surface_obj in surface_ids.items():\n            surface = rs.coercesurface(surface_obj)\n            inside_polysurfaces = []\n    \n            for polysurface_id, polysurface_obj in polysurface_ids.items():\n                polysurface = rs.coercebrep(polysurface_obj)\n    \n                # Create a Brep from the surface\n                brep = rg.Brep.CreateFromSurface(surface)\n    \n                # Check if any of the BrepFaces are inside the polysurface\n                for face in brep.Faces:\n                    mid_u = face.Domain(0).Mid\n                    mid_v = face.Domain(1).Mid\n                    point = face.PointAt(mid_u, mid_v)\n    \n                    result = polysurface.IsPointInside(point, sc.doc.ModelAbsoluteTolerance, False)\n                    if result:\n                        inside_polysurfaces.append(polysurface_id)\n                        break\n    \n            if inside_polysurfaces:\n                surface_inside_polysurface[surface_id] = inside_polysurfaces\n    \n        # Find all hierarchical relationships using the recursive function\n        for surface_id, polysurface_ids_list in surface_inside_polysurface.items():\n            for polysurface_id in polysurface_ids_list:\n                find_inside_relationship(surface_id, polysurface_id)\n                \n        stair_connections = {}\n        for surface_id, connection_data in connections.items():\n            stair_connections[surface_id] = {\"Connection\": connection_data[\"Connection\"]}\n    \n        return stair_connections\n    \n    def check_surface_connection(layer_name):\n        layer_id = rs.LayerName(layer_name)\n        if layer_id is None:\n            return {\"Connection\": \"Layer not found.\"}\n    \n        objects = rs.ObjectsByLayer(layer_id)\n        surface_ids = []\n        for obj in objects:\n            if rs.ObjectType(obj) == 8:  # Check if object type is not extrusion (8).\n                surface_ids.append(obj)\n    \n        if len(surface_ids) < 2:\n            return {\"Connection\": \"Not enough surfaces in the layer.\"}\n    \n        connection_info = {\"Connection\": []}\n    \n        # Find connected surfaces based on proximity of corner points\n        for i in range(len(surface_ids)):\n            surface_id_1 = surface_ids[i]\n            surface_1_corners = rs.SurfaceEditPoints(surface_id_1)\n    \n            for j in range(i + 1, len(surface_ids)):\n                surface_id_2 = surface_ids[j]\n                surface_2_corners = rs.SurfaceEditPoints(surface_id_2)\n    \n                # Check if any corner points of surface 1 are within a distance threshold to any corner points of surface 2\n                connection_found = False\n                for corner_1 in surface_1_corners:\n                    for corner_2 in surface_2_corners:\n                        if corner_1.DistanceTo(corner_2) < rs.UnitAbsoluteTolerance():\n                            connection_found = True\n                            break\n                    if connection_found:\n                        break\n    \n                if connection_found:\n                    attr_id_1 = rs.GetUserText(surface_id_1, \"ID\")\n                    attr_id_2 = rs.GetUserText(surface_id_2, \"ID\")\n                    connection_info[\"Connection\"].append(\"ID {} is connected to ID {}\".format(attr_id_1, attr_id_2))\n    \n        if not connection_info[\"Connection\"]:\n            connection_info[\"Connection\"].append(\"No connections found between surfaces in the layer.\")\n    \n        return connection_info\n  \n    def check_cubevscube_connection(layer_name):\n        def are_corners_inside(cube, big_cube):\n            tol = rs.UnitAbsoluteTolerance()\n            cube_corners = cube.GetBoundingBox(True).GetCorners()\n            for corner in cube_corners:\n                if not big_cube.IsPointInside(corner, tol, False):\n                    return False\n            return True\n    \n        layer_id = rs.LayerName(layer_name)\n        if layer_id is None:\n            return {\"Connection\": \"Layer not found.\"}\n    \n        objects = rs.ObjectsByLayer(layer_id)\n        polysurface_ids = {}\n    \n        # Find surface and polysurface IDs based on user attribute text\n        for obj in objects:\n            # Check if the object has a user attribute text 'ID'\n            if rs.GetUserText(obj, 'ID'):\n                # Get the ID value\n                object_id = rs.GetUserText(obj, 'ID')\n    \n                # Check if the object is a polysurface using rs.IsObjectSolid()\n                if rs.IsPolysurface(obj) or rs.ObjectType(obj) == 1073741824:\n                    polysurface_ids[object_id] = obj\n\n        if len(polysurface_ids) < 2:\n            return {\"Connection\": \"Not enough polysurfaces in the layer.\"}\n    \n        connection_info = []\n        checked_connections = set()\n    \n        for id1, obj1 in polysurface_ids.items():\n            for id2, obj2 in polysurface_ids.items():\n                if id1 != id2 and (id1, id2) not in checked_connections and (id2, id1) not in checked_connections:\n                    # Coerce the Brep objects\n                    cube1 = rs.coercebrep(obj1)\n                    cube2 = rs.coercebrep(obj2)\n    \n                    # Check if cube1 is inside cube2 or vice versa\n                    if are_corners_inside(cube1, cube2):\n                        connection = {\n                            \"Inside ID\": id1,\n                            \"Connection Type\": \"inside\",\n                            \"Outside ID\": id2,\n                            \"Description\": \"ID {} is inside ID {}\".format(id1, id2)\n                        }\n                        connection_info.append(connection)\n                        checked_connections.add((id1, id2))\n                    elif are_corners_inside(cube2, cube1):\n                        connection = {\n                            \"Inside ID\": id2,\n                            \"Connection Type\": \"inside\",\n                            \"Outside ID\": id1,\n                            \"Description\": \"ID {} is inside ID {}\".format(id2, id1)\n                        }\n                        connection_info.append(connection)\n                        checked_connections.add((id2, id1))\n    \n        if not connection_info:\n            return {\"Connection\": \"No connection found between polysurfaces.\"}\n    \n        return {\"inside_connections\": connection_info}\n    \n    # Example usage:\n    layer_name = rs.GetString(\"Enter layer name\")\n    connections_types = find_connections(layer_name)\n    point_connections = find_point_intersection(layer_name)\n    stair_connections = is_surface_inside_polysurface(layer_name)\n    surface_connections = check_surface_connection(layer_name)\n    inside_connections = check_cubevscube_connection(layer_name)\n    # Create a dictionary to combine the results\n    combined_result = {\n        \"connections_types\": connections_types,\n        \"point_connections\": point_connections,\n        \"stair_connections\": stair_connections,\n        \"surface_connections\": surface_connections,\n        \"inside_connections\": inside_connections\n    }\n    \n    # Convert the combined result to JSON format\n    json_result = json.dumps(combined_result, indent=4)\n    \n    # Print or return the JSON result\n    print(json_result)\n    \n    \n    # Save the JSON data to a file\n    output_file = \"{}.json\".format(layer_name)\n    with open(output_file, 'w') as file:\n        file.write(json_result)\n    \ngenerate_result()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}