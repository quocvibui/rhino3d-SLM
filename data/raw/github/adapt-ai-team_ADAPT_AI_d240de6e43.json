{
  "source_url": "https://github.com/adapt-ai-team/ADAPT_AI/blob/5de8b42c4f4d4ad35cbd8e79588fc6e869398bc4/spz_analysis2/solar_new_3.py",
  "repo": "adapt-ai-team/ADAPT_AI",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "spz_analysis2/solar_new_3.py",
  "instruction": "Solar new 3",
  "code": "import rhino3dm\nimport numpy as np\nimport trimesh\nimport matplotlib.pyplot as plt\nimport math  # Add this import\nfrom ladybug.epw import EPW\nfrom ladybug.sunpath import Sunpath\nfrom ladybug.analysisperiod import AnalysisPeriod\nfrom ladybug.dt import DateTime\nfrom ladybug_geometry.geometry3d.mesh import Mesh3D\nfrom ladybug_geometry.geometry3d.pointvector import Point3D\nfrom ladybug_geometry.geometry3d.arc import Arc3D\nfrom ladybug_geometry.geometry3d.line import LineSegment3D\nimport os\nimport multiprocessing as mp\nfrom tqdm import tqdm  # Also make sure tqdm is imported for the progress bar\n\n# Add path resolver helper at the top after imports\ndef resolve_path(relative_path):\n    \"\"\"Convert relative path to absolute path based on script location\"\"\"\n    script_dir = os.path.dirname(os.path.abspath(__file__))\n    return os.path.join(script_dir, relative_path)\n\n# --- Configuration ---\nepw_file = resolve_path(\"newyork.epw\")  # EPW file in same directory\nmesh_file = resolve_path(\"../spz_pipeline/pipeline_outputs/merged_model.3dm\")\noutput_glb = resolve_path(\"../spz_pipeline/pipeline_outputs/solar_radiation_example_image.glb\")\noffset_dist = 0.1  # Offset for analysis points\n\n# Move this function outside main(), at the module level\ndef calculate_radiation(args):\n    i, center, normal, sun_positions, solar_data = args\n    total_radiation = 0\n    for j, sun_pos in enumerate(sun_positions):\n        # Fix the vector direction by negating sun_vector_reversed\n        sun_vector = -1 * sun_pos.sun_vector_reversed\n        # Alternative: use correct property if available\n        # sun_vector = sun_pos.sun_vector  # Try this if available\n        \n        angle_factor = max(0, normal.dot(sun_vector))\n        radiation_value = solar_data[j % len(solar_data)] * angle_factor\n        total_radiation += radiation_value\n    return total_radiation\n\ndef validate_solar_analysis(radiation_values, lb_mesh):\n    # 1. Check for physical plausibility\n    print(\"\\n=== VALIDATION CHECKS ===\")\n    \n    \n    # North/South facing surfaces check (Northern Hemisphere)\n    north_facing = []\n    south_facing = []\n    \n    for i, normal in enumerate(lb_mesh.face_normals):\n        # Simple check - if y component is strongly negative, it's north-facing\n        if normal.y < -0.7:\n            north_facing.append(radiation_values[i])\n        elif normal.y > 0.7:\n            south_facing.append(radiation_values[i])\n    \n    if north_facing and south_facing:\n        north_avg = sum(north_facing) / len(north_facing)\n        south_avg = sum(south_facing) / len(south_facing)\n        north_south_ratio = north_avg / south_avg if south_avg > 0 else 0\n        \n        print(f\"North-facing surfaces avg radiation: {north_avg:.1f}\")\n        print(f\"South-facing surfaces avg radiation: {south_avg:.1f}\")\n        print(f\"North/South ratio: {north_south_ratio:.2f} (should be < 1.0)\")\n        print(f\"Plausibility: {'✅ GOOD' if north_south_ratio < 0.8 else '❌ SUSPICIOUS'}\")\n    \n    # Check radiation range\n    print(f\"Radiation range: {min(radiation_values):.1f} - {max(radiation_values):.1f} kWh/m²\")\n    expected_min = 100  # Adjust based on your climate\n    expected_max = 2000  # Adjust based on your climate\n    print(f\"Range check: {'✅ GOOD' if min(radiation_values) > expected_min and max(radiation_values) < expected_max else '❌ SUSPICIOUS'}\")\n    \n    # Check for outliers (standard deviation)\n    std_dev = np.std(radiation_values)\n    mean_val = np.mean(radiation_values)\n    cv = std_dev / mean_val  # Coefficient of variation\n    print(f\"Statistical variation (CV): {cv:.2f}\")\n    print(f\"Variation check: {'✅ GOOD' if cv < 0.8 else '❌ HIGH VARIATION'}\")\n    \n    return north_south_ratio, cv\n\ndef add_color_legend(mesh, min_val, max_val, colors, position=None):\n    \"\"\"Add a color legend to the 3D scene\"\"\"\n    # Default position (adjust based on your model bounds)\n    if position is None:\n        bounds = mesh.bounds\n        position = [bounds[1][0] + 100, bounds[0][1], bounds[0][2]]  # Right side of model\n    \n    # Create legend dimensions\n    legend_height = 50\n    legend_width = 10\n    legend_depth = 1\n    text_height = 10\n    \n    # Create legend base geometry\n    legend_vertices = []\n    legend_faces = []\n    legend_colors = []\n    \n    # Create the color bar with gradient\n    segments = 20\n    for i in range(segments):\n        # Calculate corners of this segment\n        z_bottom = i * (legend_height / segments)\n        z_top = (i + 1) * (legend_height / segments)\n        \n        # Add vertices\n        base_idx = len(legend_vertices)\n        legend_vertices.extend([\n            [position[0], position[1], position[2] + z_bottom],              # front bottom left\n            [position[0] + legend_width, position[1], position[2] + z_bottom], # front bottom right\n            [position[0] + legend_width, position[1], position[2] + z_top],    # front top right\n            [position[0], position[1], position[2] + z_top]                  # front top left\n        ])\n        \n        # Add face\n        legend_faces.append([base_idx, base_idx + 1, base_idx + 2, base_idx + 3])\n        \n        # Add color (reverse order to have high values at top)\n        color_idx = segments - i - 1\n        color = colors[int(color_idx / segments * (len(colors)-1))]\n        legend_colors.append(color)\n    \n    # Create text labels (in separate rendering step)\n    # For GLB, we can't easily add text, so we'll create markers at min, mid, max\n    \n    # Create a trimesh for the legend\n    legend_mesh = trimesh.Trimesh(\n        vertices=np.array(legend_vertices),\n        faces=np.array(legend_faces),\n        face_colors=legend_colors,\n        process=False\n    )\n    \n    # Combine with main mesh\n    combined = trimesh.util.concatenate([mesh, legend_mesh])\n    \n    # Create text values for separate display\n    text_values = {\n        \"min\": f\"{min_val:.1f} kWh/m²\",\n        \"max\": f\"{max_val:.1f} kWh/m²\",\n        \"position\": [position[0] + legend_width + 5, position[1], position[2]]\n    }\n    \n    return combined, text_values\n\ndef create_color_legend(min_val, max_val, cmap_name=\"jet\", size=None):\n    \"\"\"Create a standalone color legend mesh\"\"\"\n    if size is None:\n        size = (10, 50, 1)  # width, height, depth\n    \n    # Position at origin\n    position = [0, 0, 0]\n    \n    # Create legend dimensions\n    legend_width, legend_height, legend_depth = size\n    \n    # Create legend base geometry\n    vertices = []\n    faces = []\n    colors = []\n    \n    # Get colormap\n    cmap = plt.get_cmap(cmap_name)\n    \n    # Create the color bar with gradient\n    segments = 20\n    for i in range(segments):\n        # Calculate corners of this segment\n        z_bottom = i * (legend_height / segments)\n        z_top = (i + 1) * (legend_height / segments)\n        \n        # Add vertices\n        base_idx = len(vertices)\n        vertices.extend([\n            [position[0], position[1], position[2] + z_bottom],\n            [position[0] + legend_width, position[1], position[2] + z_bottom],\n            [position[0] + legend_width, position[1], position[2] + z_top],\n            [position[0], position[1], position[2] + z_top]\n        ])\n        \n        # Add face\n        faces.append([base_idx, base_idx + 1, base_idx + 2, base_idx + 3])\n        \n        # Add color (reverse order to have high values at top)\n        color_idx = segments - i - 1\n        color_value = color_idx / (segments - 1)\n        color_rgb = cmap(color_value)[:3]  # Get RGB (ignore alpha)\n        color_rgba = [int(c * 255) for c in color_rgb] + [255]  # Add alpha channel\n        colors.append(color_rgba)\n    \n    # Create a trimesh for the legend\n    legend_mesh = trimesh.Trimesh(\n        vertices=np.array(vertices),\n        faces=np.array(faces),\n        face_colors=np.array(colors)\n    )\n    \n    return legend_mesh, min_val, max_val\n\ndef triangulate_and_color_mesh(mesh, colors):\n    \"\"\"Triangulate a mesh and apply colors to each face\"\"\"\n    vertices_np = np.array([[v.x, v.y, v.z] for v in mesh.vertices])\n    \n    # Triangulate the mesh - convert quads to triangles\n    triangulated_faces = []\n    adjusted_colors = []\n    \n    for i, face in enumerate(mesh.faces):\n        if len(face) == 3:\n            triangulated_faces.append(list(face))\n            adjusted_colors.append(colors[i])\n        elif len(face) == 4:\n            # Convert quad to two triangles\n            triangulated_faces.append([face[0], face[1], face[2]])\n            triangulated_faces.append([face[0], face[2], face[3]])\n            # Duplicate this face's color for both triangles\n            adjusted_colors.append(colors[i])\n            adjusted_colors.append(colors[i])\n    \n    faces_np = np.array(triangulated_faces)\n    \n    # Create trimesh with colors\n    tri_mesh = trimesh.Trimesh(vertices=vertices_np, faces=faces_np)\n    tri_mesh.visual.face_colors = adjusted_colors\n    \n    return tri_mesh\n\ndef process_meshes(meshes):\n    \"\"\"Process a list of Rhino meshes into vertices and faces\"\"\"\n    all_vertices = []\n    all_faces = []\n    vertex_offset = 0\n    \n    for rhino_mesh in meshes:\n        vertices = [(pt.X, pt.Y, pt.Z) for pt in rhino_mesh.Vertices]\n        \n        mesh_faces = []\n        for face in rhino_mesh.Faces:\n            if len(face) == 4:  # Quad\n                mesh_faces.append([face[0] + vertex_offset, \n                                 face[1] + vertex_offset, \n                                 face[2] + vertex_offset, \n                                 face[3] + vertex_offset])\n            else:  # Triangle\n                mesh_faces.append([face[0] + vertex_offset, \n                                 face[1] + vertex_offset, \n                                 face[2] + vertex_offset])\n        \n        all_vertices.extend(vertices)\n        all_faces.extend(mesh_faces)\n        vertex_offset += len(vertices)\n    \n    return all_vertices, all_faces\n\ndef create_ladybug_mesh(vertices, faces):\n    \"\"\"Convert vertices and faces to a Ladybug mesh\"\"\"\n    lb_vertices = [Point3D(*vertex) for vertex in vertices]\n    lb_faces = []\n    \n    for face in faces:\n        if len(face) == 4 and face[2] != face[3]:  # Valid quad\n            lb_faces.append([lb_vertices[face[0]], lb_vertices[face[1]], \n                           lb_vertices[face[2]], lb_vertices[face[3]]])\n        else:  # Triangle or degenerate quad\n            lb_faces.append([lb_vertices[face[0]], lb_vertices[face[1]], \n                           lb_vertices[face[2]]])\n    \n    return Mesh3D.from_face_vertices(lb_faces)\n\ndef create_context_mesh(vertices_np, lb_mesh):\n    \"\"\"Create a plain gray mesh for context buildings\"\"\"\n    # Triangulate the mesh for context\n    triangulated_faces = []\n    \n    for face in lb_mesh.faces:\n        if len(face) == 3:\n            triangulated_faces.append(list(face))\n        elif len(face) == 4:\n            # Convert quad to two triangles\n            triangulated_faces.append([face[0], face[1], face[2]])\n            triangulated_faces.append([face[0], face[2], face[3]])\n    \n    faces_np = np.array(triangulated_faces)\n    \n    # Create gray context mesh\n    context_mesh = trimesh.Trimesh(vertices=vertices_np, faces=faces_np)\n    # Set all faces to light gray with some transparency\n    gray_color = [180, 180, 180, 200]  # Light gray with some transparency\n    context_mesh.visual.face_colors = np.tile(gray_color, (len(context_mesh.faces), 1))\n    \n    return context_mesh\n\ndef create_solar_path_visualization(sunpath, scale=500):\n    \"\"\"Create visualization geometry for annual solar paths\"\"\"\n    paths = []\n    \n    # Key dates for solar path visualization\n    dates = [\n        (6, 21),  # Summer solstice (orange)\n        (12, 21), # Winter solstice (blue)\n        (3, 21),  # Spring equinox (green)\n        (9, 21)   # Fall equinox (yellow)\n    ]\n    \n    path_colors = [\n        [255, 128, 0, 255],  # Orange\n        [0, 128, 255, 255],  # Blue\n        [0, 255, 0, 255],    # Green\n        [255, 255, 0, 255]   # Yellow\n    ]\n    \n    for (month, day), color in zip(dates, path_colors):\n        day_points = []\n        # Sample sun positions throughout the day\n        for hour in range(24):\n            for minute in [0, 30]:\n                dt = DateTime(month, day, hour, minute)\n                sun = sunpath.calculate_sun_from_date_time(dt)\n                if sun.altitude > 0:  # Only include daytime positions\n                    # Convert altitude/azimuth to 3D position\n                    alt_rad = math.radians(sun.altitude)\n                    azm_rad = math.radians(sun.azimuth - 180)  # Align with south\n                    \n                    # Coordinate system aligned with solar analysis:\n                    # X is East(+) to West(-)\n                    # Y is South(+) to North(-)\n                    # Z is Up(+)\n                    x = scale * math.cos(alt_rad) * math.sin(azm_rad)\n                    y = scale * math.cos(alt_rad) * math.cos(azm_rad)\n                    z = scale * math.sin(alt_rad)\n                    day_points.append([x, y, z])\n        \n        # Create path segments\n        for i in range(len(day_points) - 1):\n            # Create cylinder along path segment\n            direction = np.array(day_points[i+1]) - np.array(day_points[i])\n            length = np.linalg.norm(direction)\n            \n            # Create cylinder mesh\n            cylinder = trimesh.creation.cylinder(\n                radius=2.0,  # Increased radius from 0.5 to 2.0 for better visibility\n                height=length,\n                sections=8\n            )\n            \n            # Orient cylinder along path\n            direction = direction / length\n            rot = trimesh.geometry.align_vectors([0, 0, 1], direction)\n            cylinder.apply_transform(rot)\n            \n            # Position cylinder\n            trans = trimesh.transformations.translation_matrix(day_points[i])\n            cylinder.apply_transform(trans)\n            \n            # Apply color\n            cylinder.visual.face_colors = color\n            paths.append(cylinder)\n    \n    return paths\n\ndef main():\n    # --- 1. Load Climate Data ---\n    epw = EPW(epw_file)\n    location = epw.location\n    # Adjust direct_normal_radiation to annual values\n    # Current values are hourly, multiply by hours or average\n    solar_data = [val * 0.1 for val in epw.direct_normal_radiation]  # Scale down values\n\n    # Alternative: Use global horizontal radiation\n    solar_data = epw.global_horizontal_radiation\n\n    # --- 2. Compute Solar Position ---\n    sunpath = Sunpath(location.latitude, location.longitude, location.time_zone)\n\n    # Get sun positions for each hour of the year (only when sun is up)\n    solar_positions = []\n    for month in range(6, 13):\n        for day in [7, 14, 21]:  # Sample days throughout the month\n            for hour in range(6, 19):  # Daylight hours\n                for minute in [0, 30]:  # Half-hour samples\n                    dt = DateTime(month, day, hour, minute)\n                    sun = sunpath.calculate_sun_from_date_time(dt)\n                    if sun.altitude > 0:  # Only include daytime positions\n                        solar_positions.append(sun)\n\n    print(f\"Generated {len(solar_positions)} sun positions for analysis\")\n\n    # Add this debug check\n    if hasattr(solar_positions[0], 'sun_vector_reversed'):\n        print(\"Using sun_vector_reversed\")\n    else:\n        print(\"WARNING: sun_vector_reversed not found, using altitude/azimuth\")\n        # Alternative approach if needed\n\n    # Add a check for data length\n    print(f\"Sun positions: {len(solar_positions)}, Solar data points: {len(solar_data)}\")\n\n    # --- 3. Load Mesh Geometry ---\n    model = rhino3dm.File3dm.Read(mesh_file)\n    if not model:\n        raise RuntimeError(f\"Failed to read 3DM file: {mesh_file}\")\n\n    # Get all meshes from the model\n    all_meshes = []\n    for obj in model.Objects:\n        geom = obj.Geometry\n        if isinstance(geom, rhino3dm.Mesh):\n            name = obj.Attributes.Name if obj.Attributes.Name else \"unnamed\"\n            all_meshes.append((geom, name))\n    \n    if not all_meshes:\n        raise RuntimeError(\"No meshes found in the model file\")\n    \n    # Process the LAST mesh as the target (example_image) and the rest as context\n    target_meshes = [all_meshes[-1][0]]  # Get the last mesh\n    context_meshes = [mesh[0] for mesh in all_meshes[:-1]]  # All except the last mesh\n    \n    print(f\"Using the last mesh '{all_meshes[-1][1]}' as target, and {len(context_meshes)} other meshes as context\")\n    print(f\"Found {len(target_meshes)} target meshes and {len(context_meshes)} context meshes\")\n    \n    # Process target meshes for analysis\n    target_vertices, target_faces = process_meshes(target_meshes)\n    \n    # Process context meshes (only needed for shadow casting)\n    context_vertices, context_faces = process_meshes(context_meshes)\n    \n    # Create Ladybug meshes for analysis\n    target_lb_mesh = create_ladybug_mesh(target_vertices, target_faces)\n    context_lb_mesh = create_ladybug_mesh(context_vertices, context_faces)\n    \n    # --- 4. Compute Solar Radiation (with multiprocessing) ---\n    # Calculate face centroids and normals for target mesh\n    face_centroids = target_lb_mesh.face_centroids\n    face_normals = target_lb_mesh.face_normals\n    \n    # Prepare arguments for parallel processing\n    args_list = [(i, face_centroids[i], face_normals[i], solar_positions, solar_data) \n                for i in range(len(target_lb_mesh.faces))]\n    \n    # Calculate radiation for target mesh only\n    with mp.Pool(processes=max(1, mp.cpu_count()-1)) as pool:\n        radiation_values = list(tqdm(\n            pool.imap(calculate_radiation, args_list),\n            total=len(args_list),\n            desc=\"Processing target faces\"\n        ))\n    \n    # After calculating radiation values for target mesh\n    validation_results = validate_solar_analysis(radiation_values, target_lb_mesh)\n    \n    # Generate colors for target mesh\n    min_radiation, max_radiation = min(radiation_values), max(radiation_values)\n    norm_radiation = [(val - min_radiation) / (max_radiation - min_radiation) \n                     if max_radiation > min_radiation else 0 for val in radiation_values]\n    \n    cmap = plt.get_cmap(\"jet\")\n    target_colors = [(int(r * 255), int(g * 255), int(b * 255), 255) \n                    for r, g, b in [cmap(val)[:3] for val in norm_radiation]]\n    \n    # --- After calculating radiation values, BEFORE creating meshes ---\n    # Find the faces with high radiation (top 10%)\n    sorted_radiation = sorted(radiation_values, reverse=True)\n    high_threshold = sorted_radiation[int(len(sorted_radiation) * 0.1)]  # Top 10% threshold\n    \n    # Find average position and normal of high-radiation faces\n    high_rad_positions = []\n    high_rad_normals = []\n    for i, rad in enumerate(radiation_values):\n        if rad >= high_threshold:\n            high_rad_positions.append([face_centroids[i].x, face_centroids[i].y, face_centroids[i].z])\n            high_rad_normals.append([face_normals[i].x, face_normals[i].y, face_normals[i].z])\n    \n    # --- NOW create colored target mesh and context mesh ---\n    target_trimesh = triangulate_and_color_mesh(target_lb_mesh, target_colors)\n    context_vertices_np = np.array([[v.x, v.y, v.z] for v in context_lb_mesh.vertices])\n    context_trimesh = create_context_mesh(context_vertices_np, context_lb_mesh)\n    \n    # --- Now you can use target_trimesh.bounds ---\n    bounds = target_trimesh.bounds\n    model_center = np.mean(bounds, axis=0)\n    model_height = bounds[1][2]  # Highest Z coordinate\n    clearance = 20  # Add some space above model\n\n    # Calculate average position and normal of high radiation faces\n    high_rad_center = np.mean(high_rad_positions, axis=0) if high_rad_positions else model_center\n    high_rad_normal = np.mean(high_rad_normals, axis=0) if high_rad_normals else [0, 1, 0]\n    high_rad_normal = high_rad_normal / np.linalg.norm(high_rad_normal)  # Normalize\n\n    # Position for solar path above the high radiation area\n    high_rad_point = [\n        high_rad_center[0],      # X at high radiation center\n        high_rad_center[1],      # Y at high radiation center\n        model_height + clearance # Z above the model\n    ]\n    \n    # Mirror the high radiation center across the model center\n    # opposite_point = [\n    #     2 * model_center[0] - high_rad_center[0],\n    #     2 * model_center[1] - high_rad_center[1],\n    #     model_height + clearance\n    # ]\n    \n    # Vector from model center to high radiation center\n    vec = np.array(high_rad_center[:2]) - np.array(model_center[:2])\n\n    # Move to the other side by adding this vector to the model center\n    other_side_point = [\n        model_center[0] - vec[0],\n        model_center[1] - vec[1],\n        model_height + clearance\n    ]\n    \n    # Generate solar paths\n    print(\"Generating solar path visualization...\")\n    solar_paths = create_solar_path_visualization(sunpath, scale=500)\n    \n    # First, position paths on opposite side of the model from high radiation area\n    for path in solar_paths:\n        # Use other_side_point instead of high_rad_point\n        translation = trimesh.transformations.translation_matrix(other_side_point)\n        path.apply_transform(translation)\n\n    # Then, rotate all paths 180 degrees around the Z-axis at model center\n    rotation_matrix = trimesh.transformations.rotation_matrix(\n        angle=np.pi,  # 180 degrees in radians\n        direction=[0, 1, 0],  # Z-axis\n        point=model_center  # Rotate around model center\n    )\n\n    # Apply rotation to all paths\n    for path in solar_paths:\n        path.apply_transform(rotation_matrix)\n    \n    # Now combine all meshes with correctly positioned solar paths\n    all_meshes = [target_trimesh, context_trimesh]\n    all_meshes.extend(solar_paths)\n    combined_mesh = trimesh.util.concatenate(all_meshes)\n    \n    # Export combined model\n    combined_mesh.export(output_glb)\n    print(f\"✅ Model with solar paths saved as {output_glb}\")\n    \n    # --- 5. Export Legend Image ---\n    # Create a 2D legend image using matplotlib\n    print(\"Generating 2D legend image...\")\n    \n    # Generate a color legend image using matplotlib\n    fig, ax = plt.subplots(figsize=(2, 6))\n    ax.set_visible(False)  # Hide the main axes, we just want the colorbar\n    \n    norm = plt.Normalize(min_radiation, max_radiation)\n    sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)\n    sm.set_array([])\n    \n    # Pass the axes to the colorbar\n    cbar = plt.colorbar(sm, ax=ax)  \n    cbar.set_label('Radiation (kWh/m²)')\n    \n    # Add more ticks for better readability\n    cbar.set_ticks(np.linspace(min_radiation, max_radiation, 10))\n    cbar.set_ticklabels([f\"{val:.0f}\" for val in np.linspace(min_radiation, max_radiation, 10)])\n    \n    # Add a title with statistics\n    plt.title('Solar Radiation\\n(kWh/m²)')\n    plt.figtext(0.1, 0.01, f\"N/S ratio: {validation_results[0]:.2f}\\nCV: {validation_results[1]:.2f}\", fontsize=8)\n    \n    # Add solar path legend\n    plt.figtext(0.1, 0.2, 'Solar Paths:', fontsize=8)\n    plt.figtext(0.1, 0.17, '■ Summer Solstice', color='orange', fontsize=8)\n    plt.figtext(0.1, 0.14, '■ Winter Solstice', color='blue', fontsize=8)\n    plt.figtext(0.1, 0.11, '■ Spring Equinox', color='green', fontsize=8)\n    plt.figtext(0.1, 0.08, '■ Fall Equinox', color='yellow', fontsize=8)\n    \n    # Save the image with better resolution\n    legend_image = output_glb.replace('.glb', '_legend.png')\n    plt.savefig(legend_image, bbox_inches='tight', dpi=300)\n    print(f\"✅ Legend image saved as {legend_image}\")\n\nif __name__ == \"__main__\":\n    main()",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}