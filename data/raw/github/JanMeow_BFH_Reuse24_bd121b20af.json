{
  "source_url": "https://github.com/JanMeow/BFH_Reuse24/blob/8ee5b5647d3500e8ac32686766bd46658e59ac11/Kevin/demoSeries/demo_wallSystem_02032024/py/normalFacade.py",
  "repo": "JanMeow/BFH_Reuse24",
  "repo_stars": 0,
  "repo_description": "BFH 24 Spring Studio Scripts Development",
  "license": "MIT",
  "filepath": "Kevin/demoSeries/demo_wallSystem_02032024/py/normalFacade.py",
  "instruction": "Normal facade",
  "code": "import Rhino.Geometry as rg\nfrom ghpythonlib.components import Area, SurfaceClosestPoint, EvaluateSurface, SurfaceSplit, Extrude, OffsetCurve, BoundarySurfaces, TrimwithRegions, JoinCurves, RegionDifference, AlignPlane, EvaluateLength, LineSDL, Project, RegionUnion, ProjectPoint, PullPoint, BrepEdges, Explode, CurveXCurve\nimport ghpythonlib.treehelpers as th\nimport math\nfrom copy import copy, deepcopy\nfrom Grasshopper.Kernel.Data import GH_Path\nfrom Grasshopper import DataTree\nimport System.Array as array\nfrom itertools import chain\nimport random\nfrom collections import Counter\n\nimport sys\nimport os\n\n\npath = os.path.abspath(__file__)\nparentdir = os.path.dirname(path)\ngrandparentdir = os.path.dirname(parentdir)\ndire = os.path.join(grandparentdir, 'py')\nif dire not in sys.path:\n    sys.path.append(dire)\n\nimport innerMaterialGenerate\nimport compoundMaterial\nreload(innerMaterialGenerate)\nreload(compoundMaterial)\nfrom innerMaterialGenerate import InnerMaterialGenerate\nfrom compoundMaterial import CompoundMaterial\n\n\ndbList = [\"bauteil_obergruppe\", \"bauteil_gruner\", \"uuid\", \"kosten\", \"zustand\", \"material\", \"ref_gebauede_geschoss\", \"breite\", \"hoehe\", \"tiefe\", \"flaeche\", \"masse\", \"anzahl\", \"foto1\", \"foto2\", \"co2\", \"url\"]\n\nclass NormalFacade:\n    \"\"\"\n    A class to generate cladding layouts based on various parameters such as window and wall geometries,\n    cladding dimensions, and overlap specifications.\n\n    Attributes:\n        windowDB: Database of window.\n        claddingDB: Database of cladding.\n        wallGeo: Geometry of the wall to be clad.\n        windowGeo: Geometry of the windows in the wall.\n        claddingWidth: The width of the cladding material that users input.\n        claddingLength: The length of the cladding material that users input.\n        kindNum: How many cldding type users want.\n        wWeight: Weight parameter for width consideration.\n        lWeight: Weight parameter for length consideration.\n        horizontalOverlap: Overlap between claddings horizontally.\n        verticalOverlap: Overlap between claddings vertically.\n        horizontalAngle: The angle of the cladding orientation horizontally.\n        verticalAngle: The angle of the cladding orientation vertically.\n    \"\"\"\n\n    def __init__(self, DB, wallGeo, windowGeo, doorGeo, claddingDirection=True, offsetDist=0, claddingMaterial = None):\n        \"\"\"\n        Initializes the GenerateCladding class with all the necessary attributes for cladding generation.\n        \"\"\"\n        print(\"class of generateCladding is running\")\n        global initial_data\n        self.DB = DB\n        self.windowDB = DB[\"windowDB\"]\n        self.doorDB = DB[\"doorDB\"]\n        self.claddingDB = DB[\"tileDB\"]\n        self.wallGeo = wallGeo\n        self.windowGeo = windowGeo\n        self.doorGeo = doorGeo\n        self.offsetDist = offsetDist\n        self.claddingDirection = claddingDirection\n        self.claddingMaterial = claddingMaterial\n\n        # NormalFacade don't need tile grid system, thus I set width and length as 1\n        width = [1]\n        length = [1]\n\n        # build mapping for width and length\n        self.number_mapping = {}\n        for w, l in zip(width, length):\n            self.number_mapping[l] = w\n\n        # Decide grid distance based on the minimum width of the tile\n        paired_list = zip(length, width)\n        sorted_list = sorted(paired_list, key=lambda x: x[1])\n        self.minTileWidth = sorted_list[0][1]\n        self.minTileLength = sorted_list[0][0]\n        self.gridDist = self.minTileWidth\n        #print(self.minTileWidth)\n        #print(self.minTileLength)\n\n        self.claddingGeo = self.offset_brep(self.wallGeo, [self.offsetDist], self.wallGeo.Faces[0].FrameAt(0.5, 0.5)[1])[0]\n\n        # Generate the column line, wall frame, and cut direction for the cladding\n        self.columnLine, self.wallFrame, self.cutDirect = self.generateTileColumn(self.claddingGeo, self.gridDist)\n\n\n##################################################################################\n        compoundMaterialObj = CompoundMaterial(self.claddingMaterial, self.DB)\n        materialList = compoundMaterialObj.new_materialList\n        material_thickness = compoundMaterialObj.thicknessList\n\n        offsetList = []\n        total = 0\n        for num in material_thickness:\n            total += num\n            offsetList.append(total)\n\n        self.normalOffsetDist = sum(material_thickness)\n        offsetList = offsetList[:-1]\n        offsetList.insert(0,0)\n\n        outterMaterial = materialList[len(materialList)-1]\n\n        self.ruler = self.createRuler(self.claddingGeo, self.wallFrame, outterMaterial.length, outterMaterial.width, outterMaterial.direction, outterMaterial.pt)\n    \n##################################################################################\n\n        self.chosenWindowGeo, self.chosenWindowAttr = [], []\n        self.chosenDoorGeo, self.chosenDoorAttr = [], []\n        if len(self.windowGeo)!=0:\n            for wGeo in self.windowGeo:\n                if isinstance(wGeo, rg.Brep):\n                    _, oneChosenWindowGeo, oneChosenWindowAttr = self.findWindow(self.windowDB, [wGeo], self.gridDist)\n                    self.chosenWindowGeo.extend(oneChosenWindowGeo)\n                    self.chosenWindowAttr.extend(oneChosenWindowAttr)\n                else:\n                    oneChosenWindowGeo, oneChosenWindowAttr = self.buildWindow([wGeo])\n                    self.chosenWindowGeo.extend(oneChosenWindowGeo)\n                    self.chosenWindowAttr.extend(oneChosenWindowAttr)\n        \n        if len(self.doorGeo)!=0:\n            for dGeo in self.doorGeo:\n                if isinstance(dGeo, rg.Brep):\n                    _, oneChosenDoorGeo, oneChosenDoorAttr = self.findDoor(self.doorDB, [dGeo], self.gridDist)\n                    self.chosenDoorGeo.extend(oneChosenDoorGeo)\n                    self.chosenDoorAttr.extend(oneChosenDoorAttr)\n                else:\n                    oneChosenDoorGeo, oneChosenDoorAttr = self.buildDoor([dGeo])\n                    self.chosenDoorGeo.extend(oneChosenDoorGeo)\n                    self.chosenDoorAttr.extend(oneChosenDoorAttr)\n            \n\n        # Orient window and door onto grid system\n        self.orientedWindowGeoList, self.finalWindowPlaneList, self.windowForFinalList = self.orientWindow(self.columnLine, self.windowGeo, self.chosenWindowGeo, self.claddingGeo)\n        # Orient window and door onto grid system\n        self.orientedDoorGeoList, self.finalDoorPlaneList, self.doorForFinalList = self.orientDoor(self.columnLine, self.doorGeo, self.chosenDoorGeo, self.claddingGeo)\n\n\n        # Generate basic wall geometry for inner material\n        self.wallForInnerGeo = self.calculateInnerGeo(self.windowForFinalList, self.doorForFinalList)\n\n        self.wallForFacadeGeo = self.calculateFacadeGeo(self.windowForFinalList, self.doorForFinalList)\n\n        # Calculate innerMaterial Part\n        offsetted_surface = self.offset_brep(self.wallForFacadeGeo, offsetList, self.wallFrame)\n\n        moduleDistance = 200\n        moduleCurve = []\n        facadeObj = InnerMaterialGenerate(DB, offsetted_surface, materialList, material_thickness, moduleDistance, self.wallFrame, claddingDirection, moduleCurve, 10, False)\n        self.facadeMaterial = facadeObj.allTypeMaterial\n        self.claddingInfo = facadeObj.materialInfoDict\n        # checkGeo = wallObj.checkGeo\n        # allTypeMaterialModule = facadeObj.allTypeMaterialModule\n\n\n    def createRuler(self, surface, base_plane, length, width, direction, oriPt):\n        if direction:\n            firDirPlane = copy(base_plane)\n            secDirPlane = copy(base_plane)\n            secDirPlane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n        else:\n            base_plane = copy(base_plane)\n            base_plane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n            firDirPlane = copy(base_plane)\n            secDirPlane = copy(base_plane)\n            secDirPlane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n        \n        crvLength, _ = InnerMaterialGenerate.create_contours(surface, firDirPlane, length, oriPt)\n        crvWidth, _ = InnerMaterialGenerate.create_contours(surface, secDirPlane, width, oriPt)\n        crvLength = [crv.ToNurbsCurve() for crv in crvLength]\n        crvWidth = [crv.ToNurbsCurve() for crv in crvWidth]\n\n        crvList = BrepEdges(surface)[0]\n        crvList = [crv.ToNurbsCurve() for crv in crvList]\n\n        crvCombine = []\n        crvCombine.extend(crvLength)\n        crvCombine.extend(crvWidth)\n        crvCombine.extend(crvList)\n\n        return crvCombine\n\n\n    def alignSystem(self, windowGeo, grid, toler, basePlane):\n        def findMoveDist(points, checkLinesDict, basePlane, direction):\n            dir = {\"verti\":True, \"hori\":False}\n            moveDir = dir[direction]\n            checkLines = checkLinesDict[direction]\n\n            xform = rg.Transform.ChangeBasis(rg.Plane.WorldXY, basePlane)\n            newPts = []\n            for pt in points:\n                newPt = deepcopy(pt)\n                newPt.Transform(xform)\n                newPts.append(newPt)\n            \n            if moveDir:\n                newPts = sorted(newPts, key=lambda pt: pt.Y)\n            else:\n                newPts = sorted(newPts, key=lambda pt: pt.X)\n\n            xform_back = rg.Transform.ChangeBasis(basePlane, rg.Plane.WorldXY)\n            for pt in newPts:\n                pt.Transform(xform_back)\n\n            # firPts: upper & right\n            # secPt: button & left\n            firPts, secPts = newPts[2:], newPts[:2]\n\n            crvDir = basePlane.YAxis if moveDir else basePlane.XAxis\n            see = []\n            wholePair_facade = []\n            for pt in newPts:\n                firMoveTrace = LineSDL(pt, crvDir, toler).ToNurbsCurve()\n                secMoveTrace = LineSDL(pt, -crvDir, toler).ToNurbsCurve()\n                see.append(firMoveTrace)\n\n                for crv in checkLines['facade']:\n                    firCutPt = CurveXCurve(crv.ToNurbsCurve(), firMoveTrace)[0]\n                    secCutPt = CurveXCurve(crv.ToNurbsCurve(), secMoveTrace)[0]\n                    if firCutPt:\n                        wholePair_facade.append((pt,firCutPt))\n                    if secCutPt:\n                        wholePair_facade.append((pt,secCutPt))\n            \n            if len(wholePair_facade)!=0:\n                wholePair_facade = sorted(wholePair_facade, key=lambda pair: pair[0].DistanceTo(pair[1]))\n                closestPair = wholePair_facade[0]\n                \n                return (rg.Vector3d(closestPair[1]-closestPair[0]), True)\n\n            else:\n                return (rg.Vector3d(0,0,0), True)\n\n        # Whole lines involved in this system, having opening lines and grid lines\n        checkLinesFacade = grid\n        checkLinesOpening = []\n\n        pt_rect = []\n        for geo in windowGeo:\n            if isinstance(geo, rg.Rectangle3d):\n                lines, vertics = Explode(geo, True)\n                pt_rect.append((vertics[:-1], geo))\n                checkLinesOpening.extend(lines)\n            elif isinstance(geo, rg.Brep):\n                lines = BrepEdges(geo)[0]\n                checkLinesOpening.extend(lines)\n                pt_rect.append(([vertex.Location for vertex in geo.Vertices], geo))\n\n        horiVec, vertiVec = basePlane.XAxis, basePlane.YAxis\n        # print(\"horiVec\", horiVec)\n        horiLinesFacade = []\n        vertiLinesFacade = []\n        for crv in checkLinesFacade:\n            vecCrv = crv.PointAtEnd - crv.PointAtStart\n            if sum(rg.Vector3d.CrossProduct(horiVec,vecCrv))<1:\n                horiLinesFacade.append(crv)\n            else:\n                vertiLinesFacade.append(crv)\n\n        horiLinesOpening = {}\n        vertiLinesOpening = {}\n        for openId, crv in enumerate(checkLinesOpening):\n            vecCrv = crv.PointAtEnd - crv.PointAtStart\n            if rg.Vector3d.CrossProduct(horiVec,vecCrv).IsZero:\n                horiLinesOpening[openId] = crv\n            else:\n                vertiLinesOpening[openId] = crv\n\n        wholeLinesDict = {\"hori\":{\"facade\":vertiLinesFacade, \"opening\":vertiLinesOpening}, \"verti\":{\"facade\":horiLinesFacade, \"opening\":horiLinesOpening}}\n        \n        finalVec = []\n        for pts, _ in pt_rect:\n            horiVec, fixedBool = findMoveDist(pts, wholeLinesDict, basePlane, 'hori')\n            vertiVec, fixedBool = findMoveDist(pts, wholeLinesDict, basePlane, 'verti')\n            crossVec = rg.Vector3d.Add(horiVec, vertiVec)\n\n            finalVec.append(crossVec)\n\n        return finalVec\n\n\n        \n    def compare(self, name, data):\n        if not isinstance(data, list):\n            data = [data]\n\n        if name not in initial_data:\n            initial_data[name] = data\n            return True\n        else:\n            if Counter(initial_data[name]) == Counter(data):\n                return False\n            else:\n                initial_data[name] = data\n                return True\n\n\n    def alignToZ(self, targetPlane):\n        finalPlane = copy(targetPlane)\n        finalPlane = AlignPlane(finalPlane, rg.Vector3d.ZAxis)[0]\n        finalPlane.Rotate(-math.pi/2, finalPlane.ZAxis, finalPlane.Origin)\n\n        return finalPlane\n\n\n    def offset_brep(self, brep, distances, plane, tolerance=0.01):\n        if isinstance(brep, list):\n            brep = brep[0]\n\n        all_offset_breps = []\n        \n        if brep.Faces.Count > 0:\n            face_normal = brep.Faces[0].NormalAt(0.5, 0.5)\n            dot_product = plane.ZAxis * face_normal\n            \n            for distance in distances:\n                # If the dot product is negative, reverse the distance to align with the plane's Z-axis\n                if dot_product >= 0:\n                    adjusted_distance = distance\n                else:\n                    adjusted_distance = -distance\n                \n                # adjusted_distance = distance\n                \n                offset_breps = rg.Brep.CreateOffsetBrep(brep, adjusted_distance, solid=False, extend=False, tolerance=tolerance)\n                if offset_breps[0]:  # Check if the offset operation was successful\n                    all_offset_breps.append(offset_breps[0][0])\n                else:\n                    print(\"Offset operation failed for distance.\")\n                    all_offset_breps.append(None)\n        else:\n            print(\"Brep has no faces to determine normal.\")\n        \n        return all_offset_breps\n\n\n    def replace_with_zeros(self, nested_list):\n        # Check if the current element is a list\n        if isinstance(nested_list, list):\n            # If it is, recursively apply the function to each element of the list\n            return [self.replace_with_zeros(item) for item in nested_list]\n        else:\n            # If the current element is not a list, replace it with zero\n            return []\n\n\n    def customizedCladding(self, tile_list):\n        width = []\n        length = []\n        longList = []\n        for tileClass in tile_list:\n            w, l, q = tileClass.tileData.width, tileClass.tileData.height, int(tileClass.tileData.quantity)\n            width.append(w)\n            length.append(l)\n            longList.extend([l]*q)\n        \n        return (width, length, longList)\n\n\n    def findWindow(self, windowDB, userWindowGeoList, gridWidth):\n        \"\"\"\n        Identifies the best matching window dimensions from a database based on user-specified geometries,\n        considering a given tolerance and grid width.\n\n        Parameters:\n            windowDB: A database or list of window objects with width and height attributes.\n            userWindowGeoList: A list of user-specified window geometries to match against the database.\n            gridWidth: The width of the grid to consider for matching.\n            tolerance: The tolerance within which a match is considered acceptable.\n\n        Returns:\n            A list of indices corresponding to the chosen windows from the database.\n            A list of geometries of window.\n        \"\"\"\n\n        def _sortPoints(points, surf):\n            \"\"\"\n            Sorts points based on their spatial relation to a reference surface, categorizing them into quadrants\n            relative to the surface's frame and returning them in a specific order along with the surface frame.\n\n            Parameters:\n                points: A list of points to sort.\n                surf: The reference surface or brep for sorting points.\n\n            Returns:\n                A tuple containing the sorted points in specific quadrants and the updated surface frame.\n            \"\"\"\n\n            if isinstance(surf, rg.Surface) or isinstance(surf, rg.Brep):\n                # Ensure surf is a Surface for the operations (if Brep, use its faces)\n                if isinstance(surf, rg.Brep):\n                    surf = surf.Faces[0]\n\n                # 1. Calculate the Area Centroid of the Surface\n                area_properties = rg.AreaMassProperties.Compute(surf)\n                if area_properties is not None:\n                    centroid = area_properties.Centroid\n\n                    # 2. Find the Closest Point on the Surface to the Centroid\n                    success, uvPU, uvPV = surf.ClosestPoint(centroid)\n                    if success:\n                        # 3. Evaluate the Surface at the UV Parameters\n                        success, surf_Frame = surf.FrameAt(uvPU, uvPV)\n                        surf_Frame = self.alignToZ(surf_Frame)\n                        # if success:\n                            # surf_Frame now contains the frame (plane) at the closest point\n                            # Do something with surf_Frame, e.g., access its origin or its normal\n                            # frame_origin = surf_Frame.Origin\n                            # frame_normal = surf_Frame.Normal\n                            # You can now use frame_origin and frame_normal as needed\n                        # else:\n                        #     print(\"Failed to evaluate the surface frame.\")\n                    else:\n                        print(\"Failed to find the closest point on the surface.\")\n                else:\n                    print(\"Failed to compute area properties.\")\n            else:\n                print(\"The input 'surf' is not a valid surface or brep.\")\n\n\n            rTo = rg.Transform.ChangeBasis(rg.Plane.WorldXY, surf_Frame)\n            rFro = rg.Transform.ChangeBasis(surf_Frame, rg.Plane.WorldXY)\n            \n            for pt in points:\n                pt.Transform(rTo)\n                if pt.X>0 and pt.Y>0:\n                    pt.Transform(rFro)\n                    pointHighFirst = pt\n                elif pt.X<0 and pt.Y>0:\n                    pt.Transform(rFro)\n                    pointHighSecond = pt\n                elif pt.X>0 and pt.Y<0:\n                    pt.Transform(rFro)\n                    pointLowFirst = pt\n                elif pt.X<0 and pt.Y<0:\n                    pt.Transform(rFro)\n                    pointLowSecond = pt\n            surf_Frame.Rotate(math.pi/2, surf_Frame.ZAxis)\n            return (pointLowSecond, pointHighSecond, pointLowFirst, pointHighFirst, surf_Frame)\n        \n        DBwidthList = [win.geometry.Width for win in windowDB]\n        DBheightList = [win.geometry.Height for win in windowDB]\n        uList = []\n        vList = []\n        for windowGeo in userWindowGeoList:\n            ptList = [vertex.Location for vertex in windowGeo.Vertices]\n            ptList = _sortPoints(ptList, windowGeo)\n            width = ptList[0].DistanceTo(ptList[1])\n            height = ptList[0].DistanceTo(ptList[2])\n            u, v = height, width\n            uList.append(u)\n            vList.append(v)\n\n        chosenId = []\n        chosenWindowGeo = []\n        chosenWindowAttr = []\n        for u,v in zip(uList, vList):\n            minId = None\n            minDist = float('inf')\n            for id, (width, height) in enumerate(zip(DBwidthList, DBheightList)):\n                if self.claddingDirection:\n                    euclideanDist = (width-u)**2 + (height-v)**2 + ((width)%gridWidth)**3\n                else:\n                    euclideanDist = (width-u)**2 + (height-v)**2 + ((height)%gridWidth)**3\n                if euclideanDist < minDist:\n                    minId = id\n                    minDist = euclideanDist\n            chosenId.append(minId)\n            chosenWindowGeo.append(windowDB[minId].geometry)\n            chosenWindowAttr.append(windowDB[minId].attr)\n        \n        return (chosenId, chosenWindowGeo, chosenWindowAttr)\n\n\n    def buildWindow(self, geoList):\n        windowGeoList = []\n        windowAttrList = []\n        for geo in geoList:\n            windowGeoList.append(rg.Rectangle3d(rg.Plane.WorldXY, float(geo.breite), float(geo.hoehe)))\n\n            windowAttrList.append(geo.attr)\n        \n        return (windowGeoList, windowAttrList)\n\n\n    def buildDoor(self, geoList):\n        doorGeoList = []\n        doorAttrList = []\n        for geo in geoList:\n            doorGeoList.append(rg.Rectangle3d(rg.Plane.WorldXY, float(geo.breite), float(geo.hoehe)))\n\n            doorAttrList.append(geo.attr)\n\n        return (doorGeoList, doorAttrList)\n    \n\n    def findDoor(self, doorDB, userDoorGeoList, gridWidth):\n        \"\"\"\n        Identifies the best matching window dimensions from a database based on user-specified geometries,\n        considering a given tolerance and grid width.\n\n        Parameters:\n            windowDB: A database or list of window objects with width and height attributes.\n            userWindowGeoList: A list of user-specified window geometries to match against the database.\n            gridWidth: The width of the grid to consider for matching.\n            tolerance: The tolerance within which a match is considered acceptable.\n\n        Returns:\n            A list of indices corresponding to the chosen windows from the database.\n            A list of geometries of window.\n        \"\"\"\n\n        def _sortPoints(points, surf):\n            \"\"\"\n            Sorts points based on their spatial relation to a reference surface, categorizing them into quadrants\n            relative to the surface's frame and returning them in a specific order along with the surface frame.\n\n            Parameters:\n                points: A list of points to sort.\n                surf: The reference surface or brep for sorting points.\n\n            Returns:\n                A tuple containing the sorted points in specific quadrants and the updated surface frame.\n            \"\"\"\n\n            if isinstance(surf, rg.Surface) or isinstance(surf, rg.Brep):\n                # Ensure surf is a Surface for the operations (if Brep, use its faces)\n                if isinstance(surf, rg.Brep):\n                    surf = surf.Faces[0]\n\n                # 1. Calculate the Area Centroid of the Surface\n                area_properties = rg.AreaMassProperties.Compute(surf)\n                if area_properties is not None:\n                    centroid = area_properties.Centroid\n\n                    # 2. Find the Closest Point on the Surface to the Centroid\n                    success, uvPU, uvPV = surf.ClosestPoint(centroid)\n                    if success:\n                        # 3. Evaluate the Surface at the UV Parameters\n                        success, surf_Frame = surf.FrameAt(uvPU, uvPV)\n                        surf_Frame = self.alignToZ(surf_Frame)\n                        # if success:\n                            # surf_Frame now contains the frame (plane) at the closest point\n                            # Do something with surf_Frame, e.g., access its origin or its normal\n                            # frame_origin = surf_Frame.Origin\n                            # frame_normal = surf_Frame.Normal\n                            # You can now use frame_origin and frame_normal as needed\n                        # else:\n                        #     print(\"Failed to evaluate the surface frame.\")\n                    else:\n                        print(\"Failed to find the closest point on the surface.\")\n                else:\n                    print(\"Failed to compute area properties.\")\n            else:\n                print(\"The input 'surf' is not a valid surface or brep.\")\n\n\n            rTo = rg.Transform.ChangeBasis(rg.Plane.WorldXY, surf_Frame)\n            rFro = rg.Transform.ChangeBasis(surf_Frame, rg.Plane.WorldXY)\n            \n            for pt in points:\n                pt.Transform(rTo)\n                if pt.X>0 and pt.Y>0:\n                    pt.Transform(rFro)\n                    pointHighFirst = pt\n                elif pt.X<0 and pt.Y>0:\n                    pt.Transform(rFro)\n                    pointHighSecond = pt\n                elif pt.X>0 and pt.Y<0:\n                    pt.Transform(rFro)\n                    pointLowFirst = pt\n                elif pt.X<0 and pt.Y<0:\n                    pt.Transform(rFro)\n                    pointLowSecond = pt\n            surf_Frame.Rotate(math.pi/2, surf_Frame.ZAxis)\n            return (pointLowSecond, pointHighSecond, pointLowFirst, pointHighFirst, surf_Frame)\n        \n        DBwidthList = [door.geometry.Width for door in doorDB]\n        DBheightList = [door.geometry.Height for door in doorDB]\n        uList = []\n        vList = []\n        for doorGeo in userDoorGeoList:\n            ptList = [vertex.Location for vertex in doorGeo.Vertices]\n            ptList = _sortPoints(ptList, doorGeo)\n            width = ptList[0].DistanceTo(ptList[1])\n            height = ptList[0].DistanceTo(ptList[2])\n            u, v = height, width\n            uList.append(u)\n            vList.append(v)\n\n        chosenId = []\n        chosenDoorGeo = []\n        chosenDoorAttr = []\n        for u,v in zip(uList, vList):\n            minId = None\n            minDist = float('inf')\n            for id, (width, height) in enumerate(zip(DBwidthList, DBheightList)):\n                if self.claddingDirection:\n                    euclideanDist = (width-u)**2 + (height-v)**2 + ((width)%gridWidth)**3\n                else:\n                    euclideanDist = (width-u)**2 + (height-v)**2 + ((height)%gridWidth)**3\n                if euclideanDist < minDist:\n                    minId = id\n                    minDist = euclideanDist\n            chosenId.append(minId)\n            chosenDoorGeo.append(doorDB[minId].geometry)\n            chosenDoorAttr.append(doorDB[minId].attr)\n        \n        return (chosenId, chosenDoorGeo, chosenDoorAttr)\n\n\n    def findCladding(self, claddingDB, searchWidth, searchLength, kindNum, wWeight, lWeight):\n        widthDB = []\n        lengthDB = []\n        quantityDB = []\n        for cladding in claddingDB.Branches:\n            w, l = cladding[0].Width, cladding[0].Height\n            widthDB.append(w)\n            lengthDB.append(l)\n            quantityDB.append(cladding[1])\n\n        tileList = []\n        for id, (w, l, q) in enumerate(zip(widthDB, lengthDB, quantityDB)):\n            idName = \"tile_\" + str(id)\n            tileList.append((w,l,q,idName))\n\n        euclideanDistList = []\n        for w, l, q, id in tileList:\n            euclideanDist = abs((searchWidth-w)**wWeight) + abs((searchLength-l)**lWeight)\n            euclideanDistList.append(euclideanDist)\n\n        # Pair each element of first_list with the corresponding element in second_list\n        paired_list = zip(tileList, euclideanDistList)\n\n        # Sort the pairs based on the elements of second_list\n        sorted_pairs = sorted(paired_list, key=lambda x: x[1])\n\n        # Extract the sorted elements of first_list\n        sorted_list = [element for element, _ in sorted_pairs]\n\n        tileData = sorted_list[:kindNum]\n\n        id = []\n        width = []\n        length = []\n        quantity = []\n        longList = [] # This one will be input to algorithm ============================\n\n        for w, l, q, i in tileData:\n            width.append(w)\n            length.append(l)\n            quantity.append(q)\n            id.append(i)\n            longList.extend([l]*q)\n\n        return (id, width, length, quantity, longList)\n\n\n    def _create_contours(self, surface, base_point, direct, interval):\n        if isinstance(surface, rg.BrepFace):\n            print(\"This is surface not brep\")\n            surface = surface.ToBrep()\n\n        base_plane = rg.Plane(base_point, direct)\n        \n        contours = []\n\n        # Get the bounding box of the surface in the plane's coordinate system\n        bbox = surface.GetBoundingBox(base_plane)\n\n        # Start and end values for contouring in the direction of the plane's normal\n        start = bbox.Min.Z\n        end = bbox.Max.Z\n\n        # Generate contours\n        z = start\n        while z <= end:\n            # Create a plane parallel to the base plane at height z\n            contour_plane = rg.Plane(base_plane)\n            contour_plane.Translate(base_plane.Normal * z + base_plane.Normal)\n\n            # Generate the contour\n            contour_curves = rg.Brep.CreateContourCurves(surface, contour_plane)\n            contours.extend(contour_curves)\n\n            z += interval\n\n\n        return contours\n\n\n    def generateTileColumn(self, wallGeo, gridDist):\n        colBasePt = wallGeo.Vertices[0].Location\n        self.seePt = colBasePt\n        # if isinstance(wallGeo, rg.Brep):\n        #     wallGeo = wallGeo.Faces[0]\n        area_properties = rg.AreaMassProperties.Compute(wallGeo)\n        if area_properties is not None:\n            centroid = area_properties.Centroid\n            success, uvPU, uvPV = wallGeo.ClosestPoint(centroid)\n            if success:\n                # 3. Evaluate the Surface at the UV Parameters\n                success, wallGeo_Frame = wallGeo.Faces[0].FrameAt(uvPU, uvPV)\n                if success:\n                    frame_origin = wallGeo_Frame.Origin\n                    frame_normal = wallGeo_Frame.Normal\n                else:\n                    print(\"Failed to evaluate the surface frame.\")\n            else:\n                print(\"Failed to find the closest point on the surface.\")\n        else:\n            print(\"Failed to compute area properties.\")\n        \n        # # Align wallFrame's YAxis to global ZAxis\n        # global_z_axis = rg.Vector3d.ZAxis\n        # angle = rg.Vector3d.VectorAngle(wallGeo_Frame.YAxis, global_z_axis)\n        \n        # # Determine the direction of rotation (clockwise or counter-clockwise)\n        # cross_product = rg.Vector3d.CrossProduct(wallGeo_Frame.YAxis, global_z_axis)\n        # if cross_product * wallGeo_Frame.ZAxis < 0:  # If cross product is in opposite direction to frame's Z-axis\n        #     angle = -angle\n        \n        # # Rotate the frame around its Z-axis\n        # wallGeo_Frame.Rotate(angle, wallGeo_Frame.ZAxis, wallGeo_Frame.Origin)\n        \n        wallGeo_Frame = self.alignToZ(wallGeo_Frame)\n        \n        \n        if wallGeo_Frame is not None:\n            cutDirect = -AlignPlane(wallGeo_Frame, rg.Vector3d.ZAxis)[0].YAxis\n\n            if not self.claddingDirection:\n                wallGeo_Frame.Rotate(math.pi/2, wallGeo_Frame.ZAxis, wallGeo_Frame.Origin)\n                cutDirect = AlignPlane(wallGeo_Frame, rg.Vector3d.ZAxis)[0].XAxis\n\n\n            # if self.claddingDirection:\n            #     cutDirect = -AlignPlane(wallGeo_Frame, rg.Vector3d.ZAxis)[0].YAxis\n            # else:\n            #     cutDirect = -AlignPlane(wallGeo_Frame, rg.Vector3d.ZAxis)[0].XAxis\n\n            columnLine = self._create_contours(wallGeo, colBasePt, cutDirect, gridDist)\n            return (columnLine, wallGeo_Frame, cutDirect)\n        else:\n            print(\"Failed to contour.\")\n\n\n    def orientWindow(self, claddingLine, userWindowGeo, chosenWindowGeo, wallGeo):\n        def find_closest_point_on_lines(point, lines):\n            closest_point = None\n            min_distance = float('inf')  # Initialize with a very large number\n\n            for curve in lines:\n                success, t = curve.ClosestPoint(point)\n                if success:\n                    # Use the parameter 't' to get the actual closest point on the curve\n                    temp_closest_point = curve.PointAt(t)\n                    \n                    # Now calculate the distance from 'point' to 'temp_closest_point'\n                    distance = point.DistanceTo(temp_closest_point)\n\n                    # Update the closest point if this curve is closer than previous ones\n                    if distance < min_distance:\n                        min_distance = distance\n                        closest_point = temp_closest_point\n\n            return closest_point\n\n\n        orientedWindowGeoList = []\n        finalWindowPlaneList = []\n        windowForFinalList = []\n        for windowGeo, chosenGeo in zip(userWindowGeo, chosenWindowGeo):\n            if isinstance(windowGeo, rg.Brep):\n                windowGeo = windowGeo.Faces[0]\n            else:\n                windowGeo = windowGeo.geo.Faces[0]\n            if isinstance(wallGeo, rg.Brep):\n                wallGeo = wallGeo.Faces[0]\n            \n            if isinstance(chosenGeo, rg.Rectangle3d):\n                geo_curve = chosenGeo.ToNurbsCurve()\n                planar_surf = rg.Brep.CreatePlanarBreps(geo_curve)\n                chosenGeo = planar_surf[0]\n\n            # Get user's geometry's centroid and frame\n            area_properties = rg.AreaMassProperties.Compute(windowGeo)\n            if area_properties is not None:\n                centroid = area_properties.Centroid\n\n            success, uvPU, uvPV = windowGeo.ClosestPoint(centroid)\n            if success:\n                success, windowFrame = windowGeo.FrameAt(uvPU, uvPV)\n                windowFrame = self.alignToZ(windowFrame)\n                windowFrameOrigin = windowFrame.Origin\n            \n            # Get frame that closest to user's geometry's centroid\n            success, uvPU, uvPV = wallGeo.ClosestPoint(windowFrameOrigin)\n            if success:\n                success, windowFrameOnWall = wallGeo.FrameAt(uvPU, uvPV)\n                windowFrameOnWall = self.alignToZ(windowFrameOnWall)\n            \n            area_properties = rg.AreaMassProperties.Compute(chosenGeo)\n            if area_properties is not None:\n                centroid = area_properties.Centroid\n                orientPlane = rg.Plane(centroid, rg.Vector3d.ZAxis)\n\n\n            # Orient chosenWindow from DB default plane to user's geometry central plane\n            trans1 = rg.Transform.PlaneToPlane(orientPlane, windowFrame)\n            chosenGeoOnUserGeo = copy(chosenGeo)\n            chosenGeoOnUserGeo.Transform(trans1)\n\n            # Orient chosenGeoOnUserGeo from user's geometry central plane to wall\n            trans2 = rg.Transform.PlaneToPlane(windowFrame, windowFrameOnWall)\n            chosenGeoOnWallGeo = copy(chosenGeoOnUserGeo)\n            chosenGeoOnWallGeo.Transform(trans2)  # chosen Opening is placed onto the wall\n\n            #######################\n            vec = self.alignSystem([chosenGeoOnWallGeo], self.ruler, 10, self.wallFrame)\n            transOnRuler = rg.Transform.Translation(vec[0])\n            chosenGeoOnWallGeoOnRuler = copy(chosenGeoOnWallGeo)\n            chosenGeoOnWallGeoOnRuler.Transform(transOnRuler)#################################################\n\n\n            # Orient XYPlane, which is DB default plane, onto the wall and align to grid\n            XYPlaneOnUserGeo = copy(rg.Plane.WorldXY)\n            XYPlaneOnUserGeo.Transform(trans1)\n            XYPlaneOnWallGeo = copy(XYPlaneOnUserGeo)\n            XYPlaneOnWallGeo.Transform(trans2)\n            closestPoint = find_closest_point_on_lines(XYPlaneOnWallGeo.Origin, claddingLine)\n            finalWindowPlane = rg.Plane(closestPoint, XYPlaneOnWallGeo.XAxis, XYPlaneOnWallGeo.YAxis)\n\n            # Orient chosenWindowGeo to final position\n            finalWindowGeo = copy(chosenGeoOnWallGeo)\n            trans3 = rg.Transform.PlaneToPlane(XYPlaneOnWallGeo, finalWindowPlane)\n            finalWindowGeo.Transform(trans3)\n\n            # trans4 = rg.Transform.Translation(self.wallFrame.XAxis*self.horizontalOverlap)\n            windowForFinal = copy(finalWindowGeo)\n            # windowForFinal.Transform(trans4)\n\n            orientedWindowGeoList.append(finalWindowGeo)\n            finalWindowPlaneList.append(finalWindowPlane)\n            # windowForFinalList.append(windowForFinal) ################# original\n            windowForFinalList.append(chosenGeoOnWallGeoOnRuler) ################# original\n\n        return (orientedWindowGeoList, finalWindowPlaneList, windowForFinalList)\n\n\n    def orientDoor(self, claddingLine, userDoorGeo, chosenDoorGeo, wallGeo):\n        def find_closest_point_on_lines(point, lines):\n            closest_point = None\n            min_distance = float('inf')  # Initialize with a very large number\n\n            for curve in lines:\n                success, t = curve.ClosestPoint(point)\n                if success:\n                    # Use the parameter 't' to get the actual closest point on the curve\n                    temp_closest_point = curve.PointAt(t)\n                    \n                    # Now calculate the distance from 'point' to 'temp_closest_point'\n                    distance = point.DistanceTo(temp_closest_point)\n\n                    # Update the closest point if this curve is closer than previous ones\n                    if distance < min_distance:\n                        min_distance = distance\n                        closest_point = temp_closest_point\n\n            return closest_point\n        \n        def find_door_point_on_edge(plane, brep_face):\n            # Define a small tolerance value for intersection calculations\n            tolerance = 0.001  # Example tolerance, adjust based on your precision requirements\n            \n            # Step 1: Extract the Y-axis from the plane\n            yAxisLine = rg.Line(plane.Origin, plane.Origin + plane.YAxis * 1000) # Creating a long line along the Y-axis\n            \n            # Initialize a list to collect intersection points\n            intersection_points = []\n\n            # Step 2: Get the parent Brep of the BrepFace\n            brep = brep_face.Brep\n\n            # Get indices of edges adjacent to the BrepFace\n            edge_indices = brep_face.AdjacentEdges()\n\n            # Step 3: Extract the edge curves from the Brep using the indices\n            edges = [brep.Edges[edge_index].ToNurbsCurve() for edge_index in edge_indices]\n\n            # Step 4: Find the intersection points\n            for edge in edges:\n                intersection_events = rg.Intersect.Intersection.CurveLine(edge, yAxisLine, tolerance, tolerance)\n                for event in intersection_events:\n                    point = event.PointA  # Intersection point on the curve\n                    intersection_points.append(point)\n\n            # Step 5: Select the appropriate intersection point\n            if intersection_points:\n                closest_point = min(intersection_points, key=lambda pt: pt.DistanceTo(plane.Origin))\n                return closest_point\n            else:\n                print(\"No intersection found.\")\n                return None\n\n\n\n        orientedDoorGeoList = []\n        finalDoorPlaneList = []\n        doorForFinalList = []\n        for doorGeo, chosenGeo in zip(userDoorGeo, chosenDoorGeo):\n            if isinstance(doorGeo, rg.Brep):\n                doorGeo = doorGeo.Faces[0]\n            else:\n                doorGeo = doorGeo.geo.Faces[0]\n            \n            if isinstance(wallGeo, rg.Brep):\n                wallGeo = wallGeo.Faces[0]\n            \n            if isinstance(chosenGeo, rg.Rectangle3d):\n                geo_curve = chosenGeo.ToNurbsCurve()\n                planar_surf = rg.Brep.CreatePlanarBreps(geo_curve)\n                chosenGeo = planar_surf[0]\n\n            # Get user's geometry's centroid and frame\n            area_properties = rg.AreaMassProperties.Compute(doorGeo)\n            if area_properties is not None:\n                centroid = area_properties.Centroid\n\n            success, uvPU, uvPV = doorGeo.ClosestPoint(centroid)\n            if success:\n                success, doorFrame = doorGeo.FrameAt(uvPU, uvPV)\n                doorFrame = self.alignToZ(doorFrame)\n                doorFrameOrigin = doorFrame.Origin\n            \n            # Get frame that closest to user's geometry's centroid\n            success, uvPU, uvPV = wallGeo.ClosestPoint(doorFrameOrigin)\n            if success:\n                success, doorFrameOnWall = wallGeo.FrameAt(uvPU, uvPV)\n                doorFrameOnWall = self.alignToZ(doorFrameOnWall)\n            \n            area_properties = rg.AreaMassProperties.Compute(chosenGeo)\n            if area_properties is not None:\n                centroid = area_properties.Centroid\n                orientPlane = rg.Plane(centroid, rg.Vector3d.ZAxis)\n\n\n            # Orient chosenWindow from DB default plane to user's geometry central plane\n            trans1 = rg.Transform.PlaneToPlane(orientPlane, doorFrame)\n            chosenGeoOnUserGeo = copy(chosenGeo)\n            chosenGeoOnUserGeo.Transform(trans1)\n\n            # Orient chosenGeoOnUserGeo from user's geometry central plane to wall\n            trans2 = rg.Transform.PlaneToPlane(doorFrame, doorFrameOnWall)\n            chosenGeoOnWallGeo = copy(chosenGeoOnUserGeo)\n            chosenGeoOnWallGeo.Transform(trans2)\n\n            vec = self.alignSystem([chosenGeoOnWallGeo], self.ruler, 10, self.wallFrame)\n            transOnRuler = rg.Transform.Translation(vec[0])\n            chosenGeoOnWallGeoOnRuler = copy(chosenGeoOnWallGeo)\n            chosenGeoOnWallGeoOnRuler.Transform(transOnRuler)#################################################\n\n\n            # Orient XYPlane, which is DB default plane, onto the wall and align to grid\n            XYPlaneOnUserGeo = copy(rg.Plane.WorldXY)\n            XYPlaneOnUserGeo.Transform(trans1)\n            XYPlaneOnWallGeo = copy(XYPlaneOnUserGeo)\n            XYPlaneOnWallGeo.Transform(trans2)\n            closestPoint = find_closest_point_on_lines(XYPlaneOnWallGeo.Origin, claddingLine)\n            # closestPoint = find_door_point_on_edge(self.alignToZ(self.wallFrame), wallGeo) #==========================================================================================\n            finalDoorPlane = rg.Plane(closestPoint, XYPlaneOnWallGeo.XAxis, XYPlaneOnWallGeo.YAxis)\n\n            # Orient chosenWindowGeo to final position\n            finalDoorGeo = copy(chosenGeoOnWallGeo)\n            trans3 = rg.Transform.PlaneToPlane(XYPlaneOnWallGeo, finalDoorPlane)\n            finalDoorGeo.Transform(trans3)\n\n            # trans4 = rg.Transform.Translation(self.wallFrame.XAxis*self.horizontalOverlap)\n            doorForFinal = copy(finalDoorGeo)\n            # doorForFinal.Transform(trans4)\n\n\n            orientedDoorGeoList.append(finalDoorGeo)\n            finalDoorPlaneList.append(finalDoorPlane)\n            # doorForFinalList.append(doorForFinal) ############################### original\n            doorForFinalList.append(chosenGeoOnWallGeoOnRuler) ##################################\n\n        return (orientedDoorGeoList, finalDoorPlaneList, doorForFinalList)\n     \n\n    def getMidCurve(self, claddingLine):\n        firstCurves = claddingLine[:-1]\n        secondCurves = claddingLine[1:]\n        pairedCurves = zip(firstCurves, secondCurves)\n\n        midLine = []\n        for pair in pairedCurves:\n            fir, sec = pair\n            firStartPt = fir.PointAtStart\n            firEndPt = fir.PointAtEnd\n            secStartPt = sec.PointAtStart\n            secEndPt = sec.PointAtEnd\n            midStartPt = (firStartPt + secStartPt)/2\n            midEndPt = (firEndPt + secEndPt)/2\n            midLine.append(rg.Line(midStartPt, midEndPt))\n\n        return midLine\n\n\n    def calculateInnerGeo(self, windowList, doorList):\n        # Generate basic wall geometry for inner material\n        allGeo = []\n        allGeo.extend(windowList)\n        allGeo.extend(doorList)\n        reAllGeo = RegionUnion(allGeo, self.wallFrame)\n        innerGeo = RegionDifference(self.claddingGeo, reAllGeo, self.wallFrame)\n        wallForInnerGeo = self.offset_brep(BoundarySurfaces(innerGeo), [-self.offsetDist], self.wallFrame)[0]\n\n        return wallForInnerGeo\n    \n\n    def calculateFacadeGeo(self, windowList, doorList):\n        # Generate basic wall geometry for inner material\n        allGeo = []\n        allGeo.extend(windowList)\n        allGeo.extend(doorList)\n        reAllGeo = RegionUnion(allGeo, self.wallFrame)\n        innerGeo = RegionDifference(self.claddingGeo, reAllGeo, self.wallFrame)\n        wallForInnerGeo = self.offset_brep(BoundarySurfaces(innerGeo), [0], self.wallFrame)[0]\n\n        return wallForInnerGeo\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}