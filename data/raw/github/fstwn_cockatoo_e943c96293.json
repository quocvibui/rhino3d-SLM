{
  "source_url": "https://github.com/fstwn/cockatoo/blob/d952ac5d2148ec29fba52e8eb75f0f43770c74ca/usrobj_src/Cockatoo_FindApproximateGeodesicsOnMesh.py",
  "repo": "fstwn/cockatoo",
  "repo_stars": 38,
  "repo_description": "Cockatoo is a prototypical open-source software toolkit for generating (3d-)knitting patterns from NURBS surface and mesh geometry directly inside Grasshopper.",
  "license": "MIT",
  "filepath": "usrobj_src/Cockatoo_FindApproximateGeodesicsOnMesh.py",
  "instruction": "Finds approximate geodesics on a mesh by relaxing a polyline between two\ndestinations points on the mesh using the Kangaroo2 solver.\n---\nBased on an approach by Anders Holden...",
  "code": "\"\"\"\nFinds approximate geodesics on a mesh by relaxing a polyline between two\ndestinations points on the mesh using the Kangaroo2 solver.\n---\nBased on an approach by Anders Holden Deleuran\nhttps://discourse.mcneel.com/t/geodesic-lines-on-a-mesh/58790/4\n    Inputs:\n        Run: Activate the component, if False the input will pass through.\n             {item, bool}\n        Destinations: Lines which define the start and end point of the\n                      geodesic.\n                      {list, line}\n        Mesh: The mesh to find geodesics on.\n              {item, mesh}\n        ProjectDestinations: Will find the closest points on the mesh for the\n                             input destinations before approximating the\n                             geodesics.\n                             {item, bool}\n        Resolution: The resolution for discretizing the geodesic\n                    polyline.\n                    {item, float/integer)\n        Mode: The mode for discretizing the geodesic polyline.\n              [0] = Relative. the polyline will have ne number of segments\n              specified by the Resolution parameter.\n              [1] = Absolute. The segments of the geodesic will have the length\n              specified by the Resolution Parameter.\n              {item, integer}\n        Threshold: The threshold for relaxing the geodesic polyline.\n                   Defaults to 1e-14.\n                   {item, float}\n        MaxIterations: The maximum number of iterations for the relaxation.\n                       Defaults to 1000.\n                       {item, integer}\n        LineStrength: The strength of the internal k2 LineLength goal.\n                      Defaults to 10.\n                      {item, integer}\n        OnMeshStrength: The strength of the internal k2 OnMesh goal.\n                        Defaults to 100.\n                        {item, integer}\n    Outputs:\n        Geodesics: The found approximate geodesics on the mesh.\n                   {list, polyline}\n    Remarks:\n        Author: Max Eschenbach, based on an approach by Anders Holden Deleuran\n        License: MIT License\n        Version: 200705\n\"\"\"\n\n# PYTHON STANDARD LIBRARY IMPORTS\nfrom __future__ import division\nimport clr\nimport math\nimport os\n\n# .NET IMPORTS\nfrom System.Collections.Generic import List\n\n# GHPYTHON SDK IMPORTS\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\n# CUSTOM RHINO IMPORTS\nimport scriptcontext as sc\n\n# GHENV COMPONENT SETTINGS\nghenv.Component.Name = \"FindApproximateGeodesicsOnMesh\"\nghenv.Component.NickName =\"FAGOM\"\nghenv.Component.Category = \"Cockatoo\"\nghenv.Component.SubCategory = \"10 Utilities\"\n\n# KANGAROO 2 IMPORT\nif \"KangarooSolver\" in str(clr.References):\n    import KangarooSolver as ks\nelse:\n    try:\n        rhino_version = Rhino.RhinoApp.ExeVersion\n        if os.name == \"nt\":\n            if rhino_version == 6:\n                k2ap = (\"C:/Program Files/Rhino 6/Plug-ins/Grasshopper/\"\n                        \"Components/KangarooSolver.dll\")\n                clr.AddReferenceToFileAndPath(os.path.normpath(k2ap))\n            elif rhino_version == 7:\n                k2ap = (\"C:/Program Files/Rhino 7/Plug-ins/Grasshopper/\"\n                        \"Components/KangarooSolver.dll\")\n                if not os.path.exists(k2ap):\n                    k2ap = (\"C:/Program Files/Rhino 7 WIP/Plug-ins/Grasshopper/\"\n                            \"Components/KangarooSolver.dll\")\n                clr.AddReferenceToFileAndPath(os.path.normpath(k2ap))\n        elif os.name == \"posix\":\n            k2ap = (r\"/Applications/Rhinoceros.app/Contents/Frameworks/\"\n                      \"RhCore.framework/Versions/A/Resources/ManagedPlugIns/\"\n                      \"GrasshopperPlugin.rhp/Components/KangarooSolver.dll\")\n            clr.AddReferenceToFileAndPath(os.path.normpath(k2ap))\n        import KangarooSolver as ks\n    except (IOError, ImportError):\n        try:\n            clr.AddReferenceToFile(\"KangarooSolver.dll\")\n            import KangarooSolver as ks\n        except (IOError, ImportError):\n            raise RuntimeError(\"KangarooSolver.dll was not found! \"\n                               \"please add the folder to your module \"\n                               \"search paths manually!\")\n\nclass ConstructGeodesicsOnMesh(component):\n    \n    def relax_polylines_on_mesh(self, polylines, mesh, kLineLength, kOnMesh, thres, iMax, tol):\n        \"\"\"Relax a bunch of polylines on a mesh as an approach to finding\n        approximate geodesics on meshes.\n        Based on an approach by Anders Holden Deleuran.\"\"\"\n        \n        if iMax == 0:\n            return polylines, 0\n        else:\n            # create the list of goals\n            goals = []\n            for i, pl in enumerate(polylines):\n                # make show goal\n                ghc = Grasshopper.Kernel.Types.GH_Curve(pl.ToPolylineCurve())\n                gow = Grasshopper.Kernel.Types.GH_ObjectWrapper(ghc)\n                goals.append(ks.Goals.Locator(gow))\n                # make anchor goals\n                plpts = pl.ToArray()\n                goals.extend([ks.Goals.Anchor(a, 100000) for a in [plpts[0],\n                                                                   plpts[-1]]])\n                # make spring goals (line length)\n                segs = pl.GetSegments()\n                if len(segs) <= 10:\n                    rml = Grasshopper.Kernel.GH_RuntimeMessageLevel.Remark\n                    self.AddRuntimeMessage(rml, \"Segment count is quite low! \" +\n                            \"You might want to incerease this to find useful \" +\n                            \"geodesics on the mesh.\")\n                for j, seg in enumerate(segs):\n                    goals.append(ks.Goals.Spring(seg.From,\n                                                 seg.To,\n                                                 0.00,\n                                                 kLineLength))\n                # make onmesh goal with all points\n                anchorList = List[Rhino.Geometry.Point3d]()\n                [anchorList.Add(pt) for pt in plpts]\n                goals.append(ks.Goals.OnMesh(anchorList, mesh, kOnMesh))\n            \n            # create physical system and dotnet list for goals\n            ps = ks.PhysicalSystem()\n            goalsList = List[ks.IGoal]()\n            \n            # assign particle indices automagically\n            for g in goals:\n                ps.AssignPIndex(g, tol)\n                goalsList.Add(g)\n            \n            # solve the k2 physical system\n            iterations = 0\n            for i in range(iMax):\n                ps.Step(goalsList, True, 1000)\n                vs = ps.GetvSum()\n                iterations += 1\n                if vs <= thres:\n                    break\n            \n            # get relaxed polylines from output\n            geodesics = []\n            for o in ps.GetOutput(goalsList):\n                if type(o) is Rhino.Geometry.Polyline:\n                    geodesics.append(o)\n                    \n            return geodesics, iterations\n    \n    def discretize_destination_line(self, line, mode, resolution):\n        \"\"\"Discretizes a destination line into a polyline with\n        equally sized segments.\"\"\"\n        \n        if mode == 0:\n            division = round(resolution)\n            if division == 0:\n                division = 1\n        elif mode == 1:\n            division = math.ceil(line.Length / resolution)\n            if division == 0:\n                division = 1\n        \n        line = line.ToNurbsCurve()\n        divT = list(line.DivideByCount(division, True))\n        dPts = [line.PointAt(t) for t in divT]\n        pl = Rhino.Geometry.Polyline(dPts)\n        \n        return pl\n    \n    def RunScript(self, Run, Destinations, Mesh, ProjectDestinations, Resolution, Mode, Threshold, MaxIterations, LineStrength, OnMeshStrength):\n        \n        # initialize abort marker\n        _abort = False\n        \n        # abort if there's no mesh to begin with\n        if not Mesh:\n            rml = Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning\n            self.AddRuntimeMessage(rml, \"Need a mesh for approximation \" + \n                                        \"of geodesics!\")\n            _abort = True\n        \n        # abort if there are no destinations specified\n        if not Destinations:\n            rml = Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning\n            self.AddRuntimeMessage(rml, \"Need destinations for approximation \" + \n                                        \"of geodesics!\")\n            _abort = True\n        \n        # abort if one of the above is the case\n        if _abort:\n            return None\n        \n        # define mode for resolution - 0 = Relative, 1 = Absolute\n        if not Mode:\n            Mode = 0\n        elif Mode < 0:\n            Mode = 0\n        elif Mode > 1:\n            Mode = 1\n        \n        # define resolution\n        if not Resolution:\n            Resolution = 100\n        \n        # set default Threshold\n        if not Threshold:\n            Threshold = 1e-14\n        \n        # set default for maximum iterations\n        if not MaxIterations:\n            MaxIterations = 1000\n        \n        # set default strength for line length goal\n        if not LineStrength:\n            LineStrength = 10\n        \n        # set default strength for onmesh goal\n        if not OnMeshStrength:\n            OnMeshStrength = 100\n        \n        # set tolerance to models tolerance\n        Tolerance = Rhino.RhinoDoc.ActiveDoc.ModelAbsoluteTolerance\n        \n        # handle projection case\n        if ProjectDestinations:\n            for i, d in enumerate(Destinations):\n                sCP = Mesh.ClosestPoint(d.From)\n                eCP = Mesh.ClosestPoint(d.To)\n                Destinations[i] = Rhino.Geometry.Line(sCP, eCP)\n        \n        # discretize the destination lines\n        Polylines = [self.discretize_destination_line(d,\n                                                    Mode,\n                                                    Resolution)\n                                                    for d in Destinations]\n        \n        if Run:\n            Geodesics, Iterations = self.relax_polylines_on_mesh(Polylines,\n                                                              Mesh,\n                                                              LineStrength,\n                                                              OnMeshStrength,\n                                                              Threshold,\n                                                              MaxIterations,\n                                                              Tolerance)\n            if Iterations < MaxIterations:\n                self.Message = \"Converged after {} iterations\".format(\n                                                                Iterations)\n            else:\n                self.Message = \"Stopped after {} iterations\".format(\n                                                                MaxIterations)\n        else:\n            Geodesics = Polylines\n            self.Message = \"Deactivated\"\n        \n        # return outputs if you have them; here I try it for you:\n        return Geodesics\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}