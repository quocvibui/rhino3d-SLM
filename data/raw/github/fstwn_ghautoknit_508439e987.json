{
  "source_url": "https://github.com/fstwn/ghautoknit/blob/5ca6d07df601d34be5a67fe6c76a942daef50a85/modules/ghautoknit/Model.py",
  "repo": "fstwn/ghautoknit",
  "repo_stars": 3,
  "repo_description": "A prototypical bridge between Grasshopper and Autoknit.",
  "license": "MIT",
  "filepath": "modules/ghautoknit/Model.py",
  "instruction": "PYTHON STANDARD LIBRARY IMPORTS ----------------------------------------------",
  "code": "# PYTHON STANDARD LIBRARY IMPORTS ----------------------------------------------\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\n# RHINO IMPORTS ----------------------------------------------------------------\nfrom Rhino.Geometry import Mesh as RhinoMesh\n\n# LOCAL MODULE IMPORTS ---------------------------------------------------------\nfrom ghautoknit.EmbeddedConstraint import EmbeddedConstraint\nfrom ghautoknit.StoredConstraint import StoredConstraint\nfrom ghautoknit.Constraint import Constraint\nfrom ghautoknit.FileIO import LoadConstraints, SaveConstraints, SaveObj, LoadObj\nfrom ghautoknit.Utility import AttributeList, make_kd_tree, get_nearest\n\n# ALL LIST ---------------------------------------------------------------------\n__all__ = [\n    \"Model\"\n]\n\n# ACTUAL CLASS -----------------------------------------------------------------\nclass Model(object):\n    \"\"\"Class for representing a constrained Model.\"\"\"\n\n    # INITIALIZATION -----------------------------------------------------------\n\n    def __init__(self, mesh, constraints = None):\n        \"\"\"Initializes a new constrained model.\"\"\"\n        self._set_mesh(mesh)\n        if not constraints or len(constraints) == 0:\n            self._constraints = []\n        else:\n            self._set_constraints(constraints)\n\n    def ToString(self):\n        name = \"Autoknit Model\"\n        mv = self.Mesh.Vertices.Count\n        mf = self.Mesh.Faces.Count\n        mesh = \"Mesh (V:{} F:{})\".format(mv, mf)\n        cons = \"{} Constraints\".format(str(len(self.Constraints)))\n        return name + \"({}, {})\".format(mesh, cons)\n\n    # BASIC PROPERTIES ---------------------------------------------------------\n\n    # MESH ---------------------------------------------------------------------\n    def _get_mesh(self):\n        return self._mesh\n\n    def _set_mesh(self, mesh):\n        if type(mesh) != RhinoMesh:\n            raise ValueError(\"Expected a Rhino Mesh!\")\n        self._mesh = mesh\n\n    Mesh = property(_get_mesh, _set_mesh, None,\n                    \"The underlying mesh of the constrained model.\")\n\n    # CONSTRAINTS --------------------------------------------------------------\n\n    def _get_constraints(self):\n        \"\"\"Gets the constraints stored within this model.\"\"\"\n        return self._constraints\n\n    def _set_constraints(self, constraints):\n        \"\"\"Set the constraints for this model.\"\"\"\n        newcons = []\n        noid = []\n        try:\n            constraints = sorted(constraints, key=lambda x: x.Id)\n        except:\n            raise ValueError(\"Could not set the constraints. \\\n                              Check if all supplied constraints are valid \\\n                              Constraint instances.\")\n        for i, cons in enumerate(constraints):\n            if cons.Id == -1:\n                noid.append(cons)\n            else:\n                newcons.append(cons)\n        if len(newcons) > 0:\n            nextid = newcons[-1].Id + 1\n        else:\n            nextid = 0\n        for i, addcons in enumerate(noid):\n            if len(newcons) > 0:\n                addcons.Id = newcons[-1].Id + 1\n            else:\n                addcons.Id = nextid\n            newcons.append(addcons)\n        embcons = [self._embed_constraint(c, 0.0001) for c in newcons]\n        self._constraints = self._sort_constraints(embcons)\n\n    Constraints = property(_get_constraints, None, None,\n                           \"The constraints of this constrained model.\")\n\n    # CONSTRAINT COORDINATES ---------------------------------------------------\n\n    def _get_constraint_coordinates(self):\n        \"\"\"Gets the coordinates of all embedded constraints.\"\"\"\n        vertices = list(self.Mesh.Vertices.ToPoint3dArray())\n        coordinates = []\n        for cons in self.Constraints:\n            points = []\n            for vidx in cons.Chain:\n                points.append((vertices[vidx].X, vertices[vidx].Y, vertices[vidx].Z))\n            coordinates.append(points)\n        return coordinates\n\n    ConstraintCoordinates = property(_get_constraint_coordinates, None, None,\n                            \"The coodinates of all the model's constraints.\")\n\n    # EMBEDDING OF CONSTRAINTS -------------------------------------------------\n\n    def _embed_constraint(self, constraint, tolerance):\n        \"\"\"Embeds a constraint within the model and returns an\n        Autoknit EmbeddedConstraint object\"\"\"\n        # get all the vertices of the mesh embedded within the model\n        mv = [AttributeList([p.X, p.Y, p.Z], idx=i) for i, p in \\\n                        enumerate(list(self.Mesh.Vertices.ToPoint3dArray()))]\n\n        # make kdtree from mesh vertices for looking up constraint coordinates\n        kd_tree = make_kd_tree(mv, 3)\n        # define euclidean distance function\n        euc_dist = lambda a, b: sum((a[i] - b[i]) ** 2 for i in xrange(3))\n\n        # get the vertices of the constraint and lookup nearest node in the tree\n        chain = []\n        for v in constraint.Vertices:\n            dist, nv = get_nearest(kd_tree, list(v), 3, euc_dist, True)\n            if dist > tolerance:\n\n                #TODO: implement better handling if point is not within tol\n                print(\"too high!\")\n                continue\n            chain.append(nv)\n\n        # get the indices of the found chain points\n        chain_indices = [v.idx for v in chain]\n\n        # build an embedded constraint from the indices, value and radius\n        value = constraint.Value\n        radius = constraint.Radius\n        ec = EmbeddedConstraint(chain_indices, value, radius)\n        return ec\n\n    # ORDERING OF CONSTRAINTS BASED ON TIME VALUES -----------------------------\n\n    def _sort_constraints(self, constraints):\n        \"\"\"Sorts a bunch of constraints based on their time value\"\"\"\n        return sorted(constraints, key=lambda x: x.Value)\n\n    # ADDING OF NEW CONSTRAINTS ------------------------------------------------\n\n    def AddConstraint(self, constraint):\n        \"\"\"Adds a constraint to the model. Returns true on success, false otherwise.\"\"\"\n        cons = self.Constraints\n        try:\n            cons.append(self._embed_constraint(constraint))\n            self._set_constraints(constraint)\n            return True\n        except:\n            return False\n\n# MAIN -------------------------------------------------------------------------\nif __name__ == '__main__':\n    pass\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}