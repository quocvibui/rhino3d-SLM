{
  "source_url": "https://github.com/RWTH-E3D/carbonfly/blob/1b1001000e4cc0277af5eb359b9172a24b53acfd/carbonfly/geo.py",
  "repo": "RWTH-E3D/carbonfly",
  "repo_stars": 19,
  "repo_description": "An easy-to-use Python library and Grasshopper toolbox for indoor CO2 CFD simulation",
  "license": "LGPL-3.0",
  "filepath": "carbonfly/geo.py",
  "instruction": "Geometry data models and RhinoCommon helpers for carbonfly.",
  "code": "\"\"\"\nGeometry data models and RhinoCommon helpers for carbonfly.\n\nThis module defines the core geometry container used by carbonfly's case builder:\n- `CFGeo`: a single CFD region/surface entity (name + Brep + Boundary + refinement)\n- `Refine`: snappyHexMesh surface refinement levels (min_level, max_level)\n\n.. note::\n   This module depends on the RhinoCommon API and can only be used\n   inside Rhino / Grasshopper. The ``Rhino`` module is provided by Rhino.\n\"\"\"\n\nfrom __future__ import annotations\n\n# carbonfly/geo.py\nfrom dataclasses import dataclass\nfrom typing import Any, Optional\n\ntry:\n    import Rhino\nexcept ImportError:\n    Rhino = None\n\nfrom .boundary import Boundary\n\n\ndef _require_rhino() -> None:\n    \"\"\"Raise a clear error if RhinoCommon is not available.\"\"\"\n    if Rhino is None:\n        raise RuntimeError(\"Rhino is required for geometry operations.\")\n\n# Data models\n@dataclass\nclass Refine:\n    \"\"\"Surface refinement levels for snappyHexMesh: (min, max).\"\"\"\n    min_level: int = 0\n    max_level: int = 0\n\n\n@dataclass\nclass CFGeo:\n    \"\"\"\n    A single CFD surface entity.\n\n    Attributes:\n        name (str): Region/solid name written into STL and used in snappy regions{}.\n        brep (Rhino.Geometry.Brep): Normalized Brep geometry.\n        boundary (Boundary): Boundary description bound to this region.\n        refine (Refine): Surface refinement levels (min_level, max_level).\n    \"\"\"\n    name: str\n    brep: Rhino.Geometry.Brep\n    boundary: Boundary\n    refine: Refine\n\n\n# Helpers\ndef _to_brep(obj) -> Optional[Rhino.Geometry.Brep]:\n    \"\"\"Normalize input geometry to a Rhino Brep.\n\n    Supports Brep, BrepFace, and Surface. Returns None if unsupported.\n\n    Args:\n        obj: Rhino geometry input.\n\n    Returns:\n        Rhino.Geometry.Brep | None: Normalized Brep.\n    \"\"\"\n    _require_rhino()\n    if obj is None:\n        return None\n    if isinstance(obj, Rhino.Geometry.Brep):\n        return obj\n    if isinstance(obj, Rhino.Geometry.BrepFace):\n        # Duplicate trimmed face as a Brep\n        return obj.DuplicateFace(True)\n    if isinstance(obj, Rhino.Geometry.Surface):\n        return Rhino.Geometry.Brep.CreateFromSurface(obj)\n\n    return None\n\n\ndef _norm_refine(refine: Any) -> Refine:\n    \"\"\"\n    Normalize refine input to Refine(min_level, max_level).\n\n    Supported forms:\n        - int -> (i, i)\n        - (min, max) / [min, max]\n        - dict {\"min\": 3, \"max\": 5} or {\"levels\": (3, 5)}\n        - Rhino.Geometry.Interval -> (int(T0), int(T1))\n        - None / unsupported -> (0, 0)\n\n    Args:\n        refine (Any): Refinement specification.\n\n    Returns:\n        Refine: Normalized refinement levels.\n    \"\"\"\n    _require_rhino()\n    # int -> (i,i)\n    if isinstance(refine, int):\n        i = int(refine)\n        return Refine(i, i)\n\n    # tuple/list -> (min,max)\n    if isinstance(refine, (tuple, list)) and len(refine) == 2:\n        mn, mx = int(refine[0]), int(refine[1])\n        if mn > mx:\n            mn, mx = mx, mn\n        return Refine(mn, mx)\n\n    # dict\n    if isinstance(refine, dict):\n        if \"levels\" in refine and isinstance(refine[\"levels\"], (tuple, list)) and len(refine[\"levels\"]) == 2:\n            mn, mx = int(refine[\"levels\"][0]), int(refine[\"levels\"][1])\n            if mn > mx:\n                mn, mx = mx, mn\n            return Refine(mn, mx)\n        if \"min\" in refine or \"max\" in refine:\n            mn = int(refine.get(\"min\", 0))\n            mx = int(refine.get(\"max\", mn))\n            if mn > mx:\n                mn, mx = mx, mn\n            return Refine(mn, mx)\n\n\n    # Rhino Interval\n    if isinstance(refine, Rhino.Geometry.Interval):\n        mn, mx = int(refine.T0), int(refine.T1)\n        if mn > mx:\n            mn, mx = mx, mn\n        return Refine(mn, mx)\n\n    # Default\n    return Refine(0, 0)\n\ndef make_cfgeo(name: str, geometry, boundary: Boundary, refine_levels: Any = None) -> CFGeo:\n    \"\"\"\n    Create a CFGeo from Rhino geometry and bind the region name to the Boundary.\n\n    Args:\n        name (str): Region/solid name.\n        geometry: Rhino Surface/BrepFace/Brep.\n        boundary (Boundary): Boundary specification.\n        refine_levels (Any, optional): Refinement levels (see `_norm_refine`).\n\n    Returns:\n        CFGeo: Constructed CFGeo object.\n\n    Raises:\n        ValueError: If name/boundary/geometry is invalid.\n    \"\"\"\n    if not isinstance(name, str) or not name.strip():\n        raise ValueError(\"name must be a non-empty string\")\n    if boundary is None:\n        raise ValueError(\"boundary is required\")\n    br = _to_brep(geometry)\n    if br is None:\n        raise ValueError(\"geometry must be a Rhino Surface/BrepFace/Brep\")\n    rf = _norm_refine(refine_levels)\n    # bind region name for later use\n    boundary.region_name = name.strip()\n\n    return CFGeo(name=name.strip(), brep=br, boundary=boundary, refine=rf)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}