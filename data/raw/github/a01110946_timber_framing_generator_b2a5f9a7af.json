{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/src/timber_framing_generator/cell_decomposition/cell_visualizer.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "src/timber_framing_generator/cell_decomposition/cell_visualizer.py",
  "instruction": "File: timber_framing_generator/cell_decomposition/cell_visualizer.py",
  "code": "# File: timber_framing_generator/cell_decomposition/cell_visualizer.py\n\nimport Rhino.Geometry as rg\nimport System.Drawing\n\n\ndef create_rectangles_from_cell_data(cells, base_plane):\n    \"\"\"\n    Creates visualization geometry for cells, including opening locations.\n\n    This function generates visual elements to help understand the cell decomposition:\n    - Rectangles representing different cell types (SC, SCC, HCC)\n    - Opening location points to verify cell positioning\n    - Cell boundaries to confirm proper spacing\n\n    Args:\n        cells: A list of cell dictionaries from decompose_wall_to_cells()\n        base_plane: The Rhino.Geometry.Plane representing the wall's base plane.\n\n    Returns:\n        A tuple containing:\n        - List[rg.Rectangle3d]: Cell boundary rectangles\n        - List[System.Drawing.Color]: Colors for the rectangles\n        - List[rg.Point3d]: Opening location points\n\n    Note:\n        Cells of type 'WBC' (Wall Boundary Cell) are skipped to avoid overlaying duplicate geometry.\n        For walls without cells, a basic wall outline is created for visualization.\n    \"\"\"\n    rectangles = []\n    colors = []\n    opening_points = []\n\n    # First, let's understand what cells we're receiving\n    print(\"\\nCell Visualization Analysis:\")\n    print(f\"Total cells received: {len(cells)}\")\n\n    # For better debugging, print a warning if we receive no cells\n    if not cells:\n        print(\n            \"WARNING: No cells provided for visualization - creating basic wall outline instead\"\n        )\n\n        # Create a basic wall outline if we have a valid base_plane\n        if base_plane:\n            try:\n                # Use reasonable defaults for wall dimensions\n                wall_width = 10.0  # Default width in feet\n                wall_height = 8.0  # Default height in feet\n\n                print(\n                    f\"Creating wall outline with dimensions {wall_width}' x {wall_height}'\"\n                )\n\n                # Create rectangle for wall outline using intervals\n                try:\n                    wall_rect = rg.Rectangle3d(\n                        base_plane,\n                        rg.Interval(0, wall_width),\n                        rg.Interval(0, wall_height),\n                    )\n\n                    rectangles.append(wall_rect)\n                    colors.append(\n                        System.Drawing.Color.FromArgb(80, 150, 150, 150)\n                    )  # Semi-transparent gray\n\n                    print(f\"Successfully created wall outline rectangle\")\n                except Exception as e:\n                    print(f\"Error creating rectangle: {str(e)}\")\n            except Exception as e:\n                print(f\"Error creating wall outline: {str(e)}\")\n        else:\n            print(\"Cannot create wall outline: base_plane is None\")\n\n        return rectangles, colors, opening_points\n\n    # Count each cell type and log cell structure details\n    cell_types = {}\n    for i, cell in enumerate(cells):\n        cell_type = cell.get(\"cell_type\")\n        cell_types[cell_type] = cell_types.get(cell_type, 0) + 1\n\n        # For opening cells, print more details\n        if cell_type == \"OC\":  # Opening Cell\n            print(\n                f\"  Opening cell {i+1}: u={cell.get('u_start'):.3f}-{cell.get('u_end'):.3f}, v={cell.get('v_start'):.3f}-{cell.get('v_end'):.3f}\"\n            )\n            if \"corner_points\" in cell:\n                print(\n                    f\"  Has corner points: {len(cell['corner_points']) if cell['corner_points'] else 0}\"\n                )\n            else:\n                print(\"  No corner points found!\")\n\n    print(\"Cell type breakdown:\")\n    for cell_type, count in cell_types.items():\n        print(f\"  {cell_type}: {count} cells\")\n\n    # Define visualization colors\n    color_map = {\n        \"SC\": System.Drawing.Color.FromArgb(150, 80, 175, 200),  # Blue for studs\n        \"SCC\": System.Drawing.Color.FromArgb(\n            150, 220, 150, 200\n        ),  # Green for sill cripples\n        \"HCC\": System.Drawing.Color.FromArgb(\n            150, 210, 210, 100\n        ),  # Yellow for header cripples\n        \"OC\": System.Drawing.Color.FromArgb(150, 255, 100, 100),  # Red for openings\n    }\n\n    for cell in cells:\n        cell_type = cell.get(\"cell_type\")\n\n        # Skip WBC cells\n        if cell_type == \"WBC\":\n            continue\n\n        print(f\"\\nProcessing {cell_type} cell:\")\n\n        # Process opening cells for points\n        if cell_type == \"OC\":\n            u_start = cell.get(\"u_start\")\n            v_start = cell.get(\"v_start\")\n            u_end = cell.get(\"u_end\")\n            v_end = cell.get(\"v_end\")\n            print(\n                f\"  Opening location: u={u_start:.3f}-{u_end:.3f}, v={v_start:.3f}-{v_end:.3f}\"\n            )\n            print(\n                f\"  Opening dimensions: width={u_end-u_start:.3f}, height={v_end-v_start:.3f}\"\n            )\n\n            # Create opening point at the bottom-left corner\n            if base_plane:\n                opening_point = base_plane.PointAt(u_start, v_start, 0)\n                opening_points.append(opening_point)\n                print(\n                    f\"  Added opening point at ({opening_point.X:.3f}, {opening_point.Y:.3f}, {opening_point.Z:.3f})\"\n                )\n            else:\n                print(\"  Warning: base_plane is None, cannot create opening point\")\n\n        # Create rectangle for visualization\n        cp = cell.get(\"corner_points\")\n        if cp is not None and isinstance(cp, list) and len(cp) == 4:\n            try:\n                # Print corner point coordinates for debugging\n                print(\"  Corner points:\")\n                for i, point in enumerate(cp):\n                    print(\n                        f\"    Point {i}: ({point.X:.3f}, {point.Y:.3f}, {point.Z:.3f})\"\n                    )\n\n                # Create rectangle only if base_plane is valid\n                if base_plane:\n                    rect = rg.Rectangle3d(base_plane, cp[0], cp[2])\n                    rectangles.append(rect)\n                    colors.append(color_map.get(cell_type, System.Drawing.Color.Gray))\n                    print(\"  Added rectangle and color\")\n                else:\n                    print(\"  Warning: base_plane is None, cannot create rectangle\")\n            except Exception as e:\n                print(f\"  Error creating rectangle: {str(e)}\")\n        else:\n            print(f\"  Warning: Invalid corner points: {cp}\")\n            if cp is None:\n                print(\"  corner_points is None\")\n            elif not isinstance(cp, list):\n                print(f\"  corner_points is not a list, but a {type(cp)}\")\n            elif len(cp) != 4:\n                print(f\"  corner_points has {len(cp)} points instead of 4\")\n\n    print(\"\\nVisualization Results:\")\n    print(f\"Created {len(rectangles)} rectangles\")\n    print(f\"Created {len(colors)} colors\")\n    print(f\"Created {len(opening_points)} opening points\")\n\n    return rectangles, colors, opening_points\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}