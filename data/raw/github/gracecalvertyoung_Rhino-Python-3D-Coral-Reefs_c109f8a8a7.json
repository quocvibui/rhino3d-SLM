{
  "source_url": "https://github.com/gracecalvertyoung/Rhino-Python-3D-Coral-Reefs/blob/422c83eae3393b182a5694e2d964ae76033966e3/Fractal_Dimension/FD_Windows.py",
  "repo": "gracecalvertyoung/Rhino-Python-3D-Coral-Reefs",
  "repo_stars": 7,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Fractal_Dimension/FD_Windows.py",
  "instruction": "Fd windows",
  "code": "import Rhino \nimport rhinoscriptsyntax as rs\nimport math\n\n# -----  Initialize Variables -----\n# ASSUMPTION: corner ptA of quadrat is sitting at origin\n# ASSUMPTION: All of model is in positive z coordinate quadrant I \n# ASSUMPTION: \"Top\" plane is selected\n# ASSUMPTION: Document units are METERS\n\n# change this line depending on quadrat size\n# each number should be divisible by the smaller numbers\n# e.g., [1.2, .6, .3, .15] and [1, .5, .25] are okay\n# but [1.2, .5, .2] and [.8, .5, .3] are not okay\narray_N2 = [1.2, .6, .3, .15, .05] # units meters\n\npt_origin = [0, 0, 10]\nstart = [pt_origin[0] + .05, pt_origin[1] + .05, pt_origin[2]]\nend_x = start[0] + array_N2[0] \nend_y = start[1] + array_N2[0] \n\n# ----- Function Definitions -----\n\ndef selPts(pts_input, ptA, ptB, ptC, ptD):\n    # choose only the highest points \n    \n    ptA_candidates = []\n    ptB_candidates = []\n    ptC_candidates = []\n    ptD_candidates = []\n    \n    for pt in pts_input:\n        if pt[0] == ptA[0] and pt[1] == ptA[1]: \n            ptA_candidates.append(pt)\n        elif pt[0] == ptB[0] and pt[1] == ptB[1]:\n            ptB_candidates.append(pt)\n        elif pt[0] == ptC[0] and pt[1] == ptC[1]:\n            ptC_candidates.append(pt)\n        else:\n            ptD_candidates.append(pt)\n\n    ptA_max = ptA_candidates[0]\n    for pt in ptA_candidates:\n        if pt[2] > ptA_max[2]:\n            ptA_max = pt\n\n    ptB_max = ptB_candidates[0]\n    for pt in ptB_candidates:\n        if pt[2] > ptB_max[2]:\n            ptB_max = pt\n\n    ptC_max = ptC_candidates[0]\n    for pt in ptC_candidates:\n        if pt[2] > ptC_max[2]:\n            ptC_max = pt\n\n    ptD_max = ptD_candidates[0]\n    for pt in ptD_candidates:\n        if pt[2] > ptD_max[2]:\n            ptD_max = pt\n\n    pts_output = [ptA_max, ptB_max, ptC_max, ptD_max]       \n\n    return pts_output\n\ndef flipBowtie(srf_id, pts_for_srf, N2):\n    # corrects for Rhino bug by flipping \"bow tie\" surfaces \n    # I know there is a more consise way to code this,\n    # but this is easy \n\n    rs.SelectObject(srf_id) # select surface \n    rs.Command(\"-_projecttocplane \" + \"Yes \" + \"-_Enter \")\n    proj_id = rs.GetObject(preselect=True)\n\n    return pts_for_srf\n\n# -----        Main          -----\n\n# ensure that there are enough layers\nrs.AddLayer(name=\"Default\")\nfor n in range(0, len(array_N2)+1): \n    rs.AddLayer(name=\"Layer 0\" + str(n))\n\n# ensure that \"top\" is the CPlane\n# planeXY = rs.WorldXYPlane()\n# rs.ViewCPlane(view = None, plane = planeXY)\n\n# get mesh ID from user \nmesh_id = rs.GetObject(message=\"Select the reef mesh. Remember to select from TOP viewport.\",\n                           filter = 32, # mesh\n                           preselect = False, \n                           select = False)\n\n# initialize values \npt_start = start\nsrfArea = 0\nlist_srfArea = []\n\nfor N2 in array_N2:\n\n    # lay out points\n    # the rounding gets rid of some floating-pt errors\n    while round(pt_start[1], 2) < round(end_y, 2):\n\n        # define four corners points of surface\n        # explained more clearly in seperate document\n        ptA = pt_start\n        ptB = [pt_start[0] + N2, pt_start[1], pt_start[2]]\n        ptC = [pt_start[0] + N2, pt_start[1] + N2, pt_start[2]]\n        ptD = [pt_start[0], pt_start[1] + N2, pt_start[2]]\n        pts_for_srf = [ptA, ptB, ptC, ptD]\n\n        # drop the points to the reef mesh\n        # note that rs.PullPoints(mesh_id, pts_for_srf) isn't right\n        pts_for_srf = rs.ProjectPointToMesh(pts_for_srf, mesh_id, [0, 0, -1])\n        \n        # select only the (four) highest points\n        pts_for_srf = selPts(pts_for_srf, ptA, ptB, ptC, ptD)\n\n        # set layer to draw stuff in\n        l = \"Layer 0\" + str(array_N2.index(N2) + 1)\n        rs.CurrentLayer(layer=l)\n\n        # draw a surface between four points, counterclockwise\n        srf_id = rs.AddSrfPt(pts_for_srf)\n\n        # flip \"bowtie\" surfaces\n        # ASSUMES \"Top\" CPlane!\n        pts_for_srf = flipBowtie(srf_id, pts_for_srf, N2)  \n\n        # redraw surface\n        rs.AddSrfPt(pts_for_srf)\n        srf_id = rs.AddSrfPt(pts_for_srf)\n        \n        # compute area of surface, add to total area\n        srfArea = srfArea + rs.SurfaceArea(srf_id)[0]\n\n        # delete surface\n        rs.DeleteObject(srf_id)\n\n        # reset layer\n        rs.CurrentLayer(layer=\"Default\")\n\n        # move pt_start to ptB until ptB[0] = end_x,\n        # at which point move pt_start to [start[0], start[1] + row * N2, start[2]],\n        if round(ptB[0], 2) < round(end_x, 2):\n            pt_start = ptB\n        else:\n            pt_start = [start[0], pt_start[1] + N2, start[2]]\n\n    # save surface area\n    list_srfArea.append(srfArea)\n\n    # reset values\n    pt_start = start\n    srfArea = 0\n\n# at end of script... \n# print ln(srfArea) for each scale\n# print in one line, seperated by a comma\nprint(\"ln(S(delta)) for deltas \" + str(array_N2) + \" (m) resp.:\")\nstr_areas = \"\" \nfor i in range(0, len(list_srfArea)):\n    ln_area = math.log(list_srfArea[i])\n    str_areas = str_areas + str(ln_area)\n    if not i == len(list_srfArea) - 1:\n        str_areas = str_areas + \", \"\nprint(str_areas + \"\\n\")\n\n# print D for each area group\n# e.g., for 1.60--0.80, 0.80--0.40, 0.40--0.20, 0.20--0.10, 0.10--0.05\n#   if array_N2 = [1.6, .8, .4, .2, .1, .05]\nprint(\"D for for deltas \" + str(array_N2) + \" (m) resp.: \") \t\t\t\nstr_D = \"\" \nfor i in range(0, len(array_N2) - 1):\n    num = math.log(list_srfArea[i]) - math.log(list_srfArea[i + 1])\n    den = math.log(array_N2[i]) - math.log(array_N2[i + 1])\n    D = 2 - num / den\n    str_D = str_D + str(D)\n    if not i == len(array_N2) - 2:\n        str_D = str_D + \", \"\nprint(str_D) \n    \n          \n\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}