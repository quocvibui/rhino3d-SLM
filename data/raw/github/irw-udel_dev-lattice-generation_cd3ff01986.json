{
  "source_url": "https://github.com/irw-udel/dev-lattice-generation/blob/6f71e27d2ac6638d6d12643e0040cd4c26a21b29/sdk-scripts/populate_lattice_uniform.py",
  "repo": "irw-udel/dev-lattice-generation",
  "repo_stars": 0,
  "repo_description": null,
  "license": "MIT",
  "filepath": "sdk-scripts/populate_lattice_uniform.py",
  "instruction": "Population for a uniform strut lattice\n    Inputs:\n        core_voxels: Voxels to populate with unit cell only\n        boundary_voxels: Voxels to populate with unit cell and get connectivity\n       ...",
  "code": "\"\"\"Population for a uniform strut lattice\n    Inputs:\n        core_voxels: Voxels to populate with unit cell only\n        boundary_voxels: Voxels to populate with unit cell and get connectivity\n        unit_cell: Lines and curves making up the repeat unit\n        connectivity: Unit cell connectivity\n        primitive: Trimming boundary\n    Output:\n        lattice_core: Core voxels populated with unit cells\n        lattice_boundary: Boundary voxels populated with unit cells\n        lattice_trimmed: Trimmed lattice within primitive\n        lattice_boundary_connect: Boundary voxels populated with connectivity\n        lattice_skin: Net skin of the lattice\"\"\"\n\n__author__ = \"irw\"\n__version__ = \"2022.01.31\"\n\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\nimport ghpythonlib.components as ghcomp\nimport ghpythonlib.parallel\nimport ghpythonlib.treehelpers as th\n\ndef get_bounding_box(unit_cell):\n        precise_box = False\n        unit_cell_bounds = unit_cell[0].GetBoundingBox(precise_box)\n        for line in unit_cell:\n            box = line.GetBoundingBox(precise_box)\n            unit_cell_bounds = Rhino.Geometry.BoundingBox.Union(unit_cell_bounds, box)\n        return unit_cell_bounds\n\ndef check_inclusion(lattice_curve, mesh):\n    lattice_curve.Domain = Rhino.Geometry.Interval(0,1)\n    midpoint = lattice_curve.PointAt(0.5)\n    keep = mesh.IsPointInside(midpoint, 0.001, True)\n    return keep\n\ndef check_curve_parallel(curve):\n    curve = Rhino.Geometry.Curve.TryGetPolyline(curve)[1]\n    curve = Rhino.Geometry.PolylineCurve(curve)\n    intersection_points = Rhino.Geometry.Intersect.Intersection.MeshPolyline(primitive_global, curve)[0]\n    if intersection_points:\n        curve_params = []\n        for point in intersection_points:\n            curve_params.append(curve.ClosestPoint(point)[1])\n        split_curve = curve.Split(curve_params)\n        for section in split_curve:\n            if (check_inclusion(section, primitive_global)):\n                lattice_trimmed.append(section)\n    else:\n        if (check_inclusion(curve, primitive_global)):\n            lattice_trimmed.append(curve)\n\ndef populate_lattice_parallel(voxels):\n    lattice_structure = []\n    for curve in unit_cell_global:\n        mapped = ghcomp.BoxMapping(curve, unit_cell_bounds, voxels)[0]\n        lattice_structure.append(mapped)\n    return lattice_structure\n\ndef populate_connectivity_parallel(voxels):\n    connect = ghcomp.BoxMapping(connectivity_global, unit_cell_bounds, voxels)[0]\n    return connect\n\ndef populate_skin_parallel(voxels):\n    connect = ghcomp.BoxMapping(connectivity_global, unit_cell_bounds, voxels)[0]\n    # curves = Rhino.Geometry.Intersect.Intersection.MeshMeshAccurate(connect, primitive,  Rhino.RhinoMath.SqrtEpsilon*10)\n    curves = ghcomp.MeshXMesh(primitive_global, connect)\n    return curves\n\n\nclass UniformLattice(component):\n    def RunScript(self, core_voxels, boundary_voxels, unit_cell, connectivity, primitive):\n        global unit_cell_bounds\n        global unit_cell_global\n        global connectivity_global\n        global primitive_global\n        global lattice_trimmed\n\n        unit_cell_global = unit_cell\n        connectivity_global = connectivity\n        primitive_global = primitive\n        unit_cell_bounds = get_bounding_box(unit_cell)\n        unit_cell = Rhino.Geometry.Curve.JoinCurves(unit_cell)\n        if core_voxels:\n            lattice_core = ghpythonlib.parallel.run(populate_lattice_parallel, core_voxels, True)\n        else:\n            lattice_core = []\n        if boundary_voxels:\n            lattice_boundary = ghpythonlib.parallel.run(populate_lattice_parallel, boundary_voxels, True)\n            lattice_boundary_connect = ghpythonlib.parallel.run(populate_connectivity_parallel, boundary_voxels, True)\n            lattice_skin = ghpythonlib.parallel.run(populate_skin_parallel, boundary_voxels, True)\n        else:\n            lattice_boundary = []\n            lattice_boundary_connect = []\n            lattice_skin = []\n\n        lattice_trimmed = []\n        lattice_combined = list(lattice_core) + list(lattice_boundary)\n        valid_curves = list(filter(None, lattice_combined))\n        ghpythonlib.parallel.run(check_curve_parallel, valid_curves, False)\n\n        return lattice_core, lattice_boundary, lattice_trimmed, lattice_boundary_connect, lattice_skin",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}