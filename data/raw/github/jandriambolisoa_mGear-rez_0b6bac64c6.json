{
  "source_url": "https://github.com/jandriambolisoa/mGear-rez/blob/bde07a32330949b8f0044fa2c587d17ae42ecee8/mGear/scripts/mgear/rigbits/facial_rigger/brow_rigger.py",
  "repo": "jandriambolisoa/mGear-rez",
  "repo_stars": 0,
  "repo_description": null,
  "license": "MIT",
  "filepath": "mGear/scripts/mgear/rigbits/facial_rigger/brow_rigger.py",
  "instruction": "Original design Krzysztof Marcinowski",
  "code": "# Original design Krzysztof Marcinowski\nimport json\nfrom functools import partial\nfrom mgear.core.six import string_types\n\n\nimport mgear.core.pyqt as gqt\nimport mgear.pymaya as pm\nfrom maya.app.general.mayaMixin import MayaQWidgetDockableMixin\nfrom mgear.vendor.Qt import QtCore, QtWidgets\nfrom mgear.pymaya import datatypes\n\nfrom mgear import rigbits\nfrom mgear.core import meshNavigation, curve, applyop, primitive, icon\nfrom mgear.core import transform, attribute, skin, pickWalk, vector\nfrom mgear.core import node\n\nfrom mgear.rigbits.facial_rigger import lib\nfrom mgear.rigbits.facial_rigger import helpers\nfrom mgear.rigbits.facial_rigger import constraints\n\n\ndef rig(edge_loop,\n        name_prefix,\n        thickness,\n        main_div,\n        sec_div,\n        do_skin,\n        secondary_ctl_check,\n        symmetry_mode,\n        side,\n        rigid_loops,\n        falloff_loops,\n        brow_jnt_C=None,\n        brow_jnt_L=None,\n        brow_jnt_R=None,\n        ctl_parent_C=None,\n        ctl_parent_L=None,\n        ctl_parent_R=None,\n        parent_node=None,\n        ctl_name=\"ctl\"):\n\n    ######\n    # Var\n    ######\n    FRONT_OFFSET = .02\n    NB_ROPE = 10\n    midDivisions = 3\n\n    ####################\n    # Validate Data\n    # ##################\n    edge_loops = {}  # collect edge loops and it's sides in DICT\n    controls_collect = []  # collect parent controls\n    joints_collect = []  # collect parent joints\n\n    # divisions\n    main_div = int(main_div)\n    sec_div = int(sec_div)\n    # Edges\n\n    if edge_loop:\n        try:\n            edge_loop = [pm.PyNode(e) for e in edge_loop.split(\",\")]\n        except RuntimeError:\n            pm.displayWarning(\n                \"Some of the edges listed in edge loop can not be found\")\n            return\n    # Geo\n        geo = pm.listRelatives(edge_loop[0], parent=True)[0]\n        geoTransform = pm.listRelatives(geo, fullPath=False, parent=True)[0]\n\n    else:\n        pm.displayWarning(\"Please set the edge loop first\")\n        return\n\n    # symmetry mode\n    # 0 => ON  1 = > OFF\n    if symmetry_mode == 0:\n        # symmetry is on, collect required data\n        # mirror edge loop\n        mLoop = []\n        for edge in edge_loop:\n            mEdge = meshNavigation.find_mirror_edge(geoTransform,\n                                                    edge.indices()[0])\n            mLoop.append(mEdge)\n\n        if len(mLoop) != len(edge_loop):\n            pm.displayWarning(\n                \"Mesh is not symmetrical, please fix it or create temp GEO\")\n            return\n\n        # set side\n        if edge_loop[0].getPoint(0, space='world')[0] > 0:\n            # left\n            side = \"L\"\n            l_Loop = edge_loop\n            r_Loop = mLoop\n        else:\n            # right\n            side = \"R\"\n            l_Loop = mLoop\n            r_Loop = edge_loop\n\n        # get edges for center module\n        p1 = l_Loop[0].getPoint(0, space='world')\n        p2 = l_Loop[-1].getPoint(0, space='world')\n        if p1[0] < p2[0]:\n            l_inner = l_Loop[0]\n        else:\n            l_inner = l_Loop[-1]\n        p1 = r_Loop[0].getPoint(0, space='world')\n        p2 = r_Loop[-1].getPoint(0, space='world')\n\n        if p1[0] > p2[0]:\n            r_inner = r_Loop[0]\n        else:\n            r_inner = r_Loop[-1]\n\n        # center segment\n        # TODO: this does not always work depending geometry\n        mid_loop = pm.polySelect(\n            geoTransform,\n            edgeLoopPath=(l_inner.indices()[0],\n                          r_inner.indices()[0]),\n            ass=True,\n            ns=True)\n        if not mid_loop:\n            pm.displayError(\n                \"Mid loop can't be traced. Probably the topology\"\n                \" have a vertex with 5 edges or more in the loop\")\n            return\n        mid_loop_len = len(mid_loop)\n        c_Loop = [pm.PyNode(e) for e in mid_loop\n                  if pm.PyNode(e) not in l_Loop and pm.PyNode(e) not in r_Loop]\n        edge_loops = dict(zip([\"L\", \"R\", \"C\"], [l_Loop, r_Loop, c_Loop]))\n\n    else:\n        # symmetry is off\n        sideOptions = {0: \"C\",\n                       1: \"L\",\n                       2: \"R\"}\n        if side:\n            side = sideOptions[side]\n        else:\n            side = \"C\"\n        # set\n        c_Loop = edge_loop\n        edge_loops = dict(zip([side], [c_Loop]))\n    positions = meshNavigation.getExtremeVertexFromLoop(edge_loop)\n    p1 = positions[2].getPosition(space='world')\n    p2 = positions[3].getPosition(space='world')\n    self_size = vector.getDistance(p1, p2) / sec_div\n\n    # parent node\n    if parent_node:\n        try:\n            parent_node = pm.PyNode(parent_node)\n        except RuntimeError:\n            pm.displayWarning(\n                \"Static rig parent: %s can not be found\" % parent_node)\n            return\n\n    if brow_jnt_C:\n        try:\n            brow_jnt_C = pm.PyNode(brow_jnt_C)\n            joints_collect.append(brow_jnt_C)\n        except RuntimeError:\n            pm.displayWarning(\n                \"Mid parent joint: %s can not be found\" % brow_jnt_C)\n            return\n    else:\n        pm.displayWarning(\"Main parent joints is required. It would be used\"\n                          \" as main parent if side parents are not set.\")\n        return\n\n    if symmetry_mode == 0:\n        if brow_jnt_L:\n            try:\n                brow_jnt_L = pm.PyNode(brow_jnt_L)\n                joints_collect.append(brow_jnt_L)\n            except RuntimeError:\n                pm.displayWarning(\n                    \"Left parent joint: %s can not be found\" % brow_jnt_L)\n                return\n        else:\n            pm.displayWarning(\n                \"With symmetry mode you need to set the left parent joint.\")\n            return\n\n        if brow_jnt_R:\n            try:\n                brow_jnt_R = pm.PyNode(brow_jnt_R)\n                joints_collect.append(brow_jnt_R)\n            except RuntimeError:\n                pm.displayWarning(\n                    \"Right parent joint: %s can not be found.\" % brow_jnt_R)\n                return\n        else:\n            try:\n                brow_jnt_R = pickWalk.getMirror(brow_jnt_L)[0]\n                joints_collect.append(brow_jnt_R)\n            except RuntimeError:\n                pm.displayWarning(\n                    \"Right parent joint: \"\n                    \"%s can't be found. Please set it manually.\" % brow_jnt_R)\n                return\n\n    ##################\n    # Helper functions\n    # ##################\n\n    def setName(name, side=\"C\", idx=None):\n        namesList = [name_prefix, side, name]\n        if idx is not None:\n            namesList[1] = side + str(idx)\n        name = \"_\".join(namesList)\n        return name\n\n    def getSide(name):\n        # name = name.strip(name_prefix)\n\n        if name_prefix + \"_L_\" in name.name():\n            side = \"L\"\n        elif name_prefix + \"_R_\" in name.name():\n            side = \"R\"\n        else:\n            side = \"C\"\n        return side\n\n    # check if the rig already exist in the current scene\n    if pm.ls(setName(\"root\", side)):\n        pm.displayWarning(\"The object %s already exist in the scene. Please \"\n                          \"choose another name prefix\" % setName(\"root\"))\n        return\n\n    ###################\n    # Root creation\n    ###################\n    if symmetry_mode == 0:\n        rootSide = \"C\"\n    else:\n        rootSide = side\n    brows_root = primitive.addTransform(None,\n                                        setName(\"root\", rootSide))\n    browsCrv_root = primitive.addTransform(brows_root,\n                                           setName(\"crvs\", \"main\"))\n    browsHooks_root = primitive.addTransform(brows_root,\n                                             setName(\"hooks\", rootSide))\n    browsRope_root = primitive.addTransform(brows_root,\n                                            setName(\"rope\", rootSide))\n    browsControl_root = primitive.addTransform(brows_root,\n                                               setName(\"controls\", rootSide))\n\n    # parent controls\n    if ctl_parent_L:\n        try:\n            ctl_parent_L = pm.PyNode(ctl_parent_L)\n            controls_collect.append(ctl_parent_L)\n            parent_tag_L = ctl_parent_L\n        except RuntimeError:\n            pm.displayWarning(\n                \"Right (Left) ctl: %s can not be found\" % ctl_parent_L)\n            return\n    else:\n        # ctl_parent_L = brow_jnt_L\n        ctl_parent_L = brows_root\n        parent_tag_L = None\n\n    if ctl_parent_R:\n        try:\n            ctl_parent_R = pm.PyNode(ctl_parent_R)\n            controls_collect.append(ctl_parent_R)\n            parent_tag_R = ctl_parent_R\n        except RuntimeError:\n            pm.displayWarning(\n                \"Right ctl: %s can not be found\" % ctl_parent_R)\n            return\n    else:\n        # ctl_parent_R = brow_jnt_R\n        ctl_parent_R = brows_root\n        parent_tag_R = None\n\n    if ctl_parent_C:\n        try:\n            ctl_parent_C = pm.PyNode(ctl_parent_C)\n            controls_collect.append(ctl_parent_C)\n            parent_tag_C = ctl_parent_C\n        except RuntimeError:\n            pm.displayWarning(\n                \"Main ctl: %s can not be found\" % ctl_parent_R)\n            return\n    else:\n        # ctl_parent_R = brow_jnt_R\n        ctl_parent_C = brows_root\n        parent_tag_C = None\n\n    if symmetry_mode == 0:\n        if ctl_parent_R:\n            try:\n                ctl_parent_R = pm.PyNode(ctl_parent_R)\n                controls_collect.append(ctl_parent_R)\n                parent_tag_R = ctl_parent_R\n            except RuntimeError:\n                pm.displayWarning(\n                    \"Right ctl: %s can not be found\" % ctl_parent_R)\n                return\n        else:\n            # ctl_parent_R = brow_jnt_R\n            ctl_parent_R = brows_root\n            parent_tag_R = None\n\n    #####################\n    # Groups\n    #####################\n    # TODO: the set name should not be hardcoded to \"rig\" name\n    try:\n        ctlSet = pm.PyNode(\"rig_controllers_grp\")\n    except RuntimeError:\n        pm.sets(n=\"rig_controllers_grp\", em=True)\n        ctlSet = pm.PyNode(\"rig_controllers_grp\")\n    try:\n        defset = pm.PyNode(\"rig_deformers_grp\")\n    except RuntimeError:\n        pm.sets(n=\"rig_deformers_grp\", em=True)\n        defset = pm.PyNode(\"rig_deformers_grp\")\n\n    # ###################\n    # Collect data\n    #####################\n    # store the closest vertex by curv cv index. To be use fo the auto skining\n    # browsMainCrv_closestVtxList = []\n\n    # temp parent memory\n    # parentsMemory = []\n    l_hookMem = []\n    r_hookMem = []\n    c_hookMem = []\n\n    # collect curves\n    rigCurves = []\n    mainCtlCurves = []\n    mainCtlUpvs = []\n    secondaryCurves = []\n    mainRopes = []\n    mainRopeUpvs = []\n    mainCurveUpvs = []\n    mainCurves = []\n\n    # collect objects\n    mainControls = []\n    mainUpvs = []\n    secondaryControls = []\n    secondaryUpvs = []\n    allJoints = []\n    closestVtxsList = []\n\n    # ###############################\n    # Create curves and controls\n    #################################\n    for side, loop in edge_loops.items():\n\n        browsCrv_side_root = primitive.addTransform(browsCrv_root,\n                                                    setName(\"crvs\", side))\n\n        # create poly based curve for each part\n        mainCurve = curve.createCuveFromEdges(loop,\n                                              setName(\"main_crv\", side),\n                                              parent=browsCrv_side_root)\n        # collect main poly based curve\n        mainCurves.append(mainCurve)\n        rigCurves.append(mainCurve)\n\n        # offset main brow curve\n        # NOTE Miquel: we dont need to offset here. The offset was for the lips\n        # because have thickness. Here  is not needed\n        cvs = mainCurve.getCVs(space='world')\n        for i, cv in enumerate(cvs):\n            closestVtx = meshNavigation.getClosestVertexFromTransform(geo, cv)\n            closestVtxsList.append(closestVtx)\n\n        # ###################\n        # Get control positions\n        #####################\n        if symmetry_mode == 0:  # 0 means ON\n            if side == \"C\":  # middle segment should be divided into 3 points.\n                mainCtrlPos = helpers.divideSegment(mainCurve, midDivisions)\n                # since the central part is process first we usen the main list\n                # to slice repeted vertex\n                closestVtxsList = closestVtxsList[1:mid_loop_len - 1]\n            else:\n                mainCtrlPos = helpers.divideSegment(mainCurve, main_div)\n            if secondary_ctl_check and side != \"C\":\n                # get secondary controls position\n                secCtrlPos = helpers.divideSegment(mainCurve, sec_div)\n\n        else:\n\n            mainCtrlPos = helpers.divideSegment(mainCurve, main_div)\n            if secondary_ctl_check:\n                # get secondary controls position\n\n                secCtrlPos = helpers.divideSegment(mainCurve, sec_div)\n        # ###################\n        # Set control options\n        #####################\n        # points are sorted from X+, based on this set required options\n        mainCtrlOptions = []\n        secCtrlOptions = []\n\n        # main control options\n        for i, ctlPos in enumerate(mainCtrlPos):\n            controlType = \"square\"\n\n            if i == 0:\n                if side == \"L\":\n                    posPrefix = \"in\"\n                if side == \"R\":\n                    posPrefix = \"out\"\n                if side == \"C\":\n                    posPrefix = \"out_R\"\n                    if symmetry_mode == 0:\n                        controlType = \"npo\"\n\n            elif i == (len(mainCtrlPos) - 1):\n                if side == \"L\":\n                    posPrefix = \"out\"\n                if side == \"R\":\n                    posPrefix = \"in\"\n                if side == \"C\":\n                    posPrefix = \"out_L\"\n                    if symmetry_mode == 0:\n                        controlType = \"npo\"\n            else:\n                posPrefix = \"mid_0\" + str(i)\n                if side == \"R\":\n                    posPrefix = \"mid_0\" + str(len(mainCtrlPos) - (i + 1))\n            set_options = False  # when mirror is set we need to avoid the\n            # tanget controls on the central part\n\n            if posPrefix == \"in\" or posPrefix == \"out_R\":\n                if side == \"L\":\n                    tPrefix = [posPrefix + \"_tangent\", posPrefix]\n                    tControlType = [\"sphere\", controlType]\n                    tControlSize = [0.8, 1.0]\n                    set_options = True\n                if side == \"C\" and symmetry_mode:\n                    tPrefix = [\"out_R_tangent\", posPrefix]\n                    tControlType = [\"sphere\", controlType]\n                    tControlSize = [0.8, 1.0]\n                    set_options = True\n                if side == \"R\":\n                    tPrefix = [posPrefix, posPrefix + \"_tangent\"]\n                    tControlType = [controlType, \"sphere\"]\n                    tControlSize = [1.0, 0.8]\n                    set_options = True\n                if set_options:\n                    options = [tPrefix[1],\n                               side,\n                               tControlType[1],\n                               6,\n                               tControlSize[1],\n                               [],\n                               ctlPos]\n                    mainCtrlOptions.append(options)\n\n                    options = [tPrefix[0],\n                               side,\n                               tControlType[0],\n                               6,\n                               tControlSize[0],\n                               [],\n                               ctlPos]\n                    mainCtrlOptions.append(options)\n\n            elif posPrefix == \"out\" or posPrefix == \"out_L\":\n                if side == \"L\":\n                    tPrefix = [posPrefix + \"_tangent\", posPrefix]\n                    tControlType = [\"sphere\", controlType]\n                    tControlSize = [0.8, 1.0]\n                    set_options = True\n                if side == \"C\" and symmetry_mode:\n                    tPrefix = [\"out_L_tangent\", posPrefix]\n                    tControlType = [\"sphere\", controlType]\n                    tControlSize = [0.8, 1.0]\n                    set_options = True\n                if side == \"R\":\n                    tPrefix = [posPrefix, posPrefix + \"_tangent\"]\n                    tControlType = [controlType, \"sphere\"]\n                    tControlSize = [1.0, 0.8]\n                    set_options = True\n                if set_options:\n                    options = [tPrefix[0],\n                               side,\n                               tControlType[0],\n                               6,\n                               tControlSize[0],\n                               [],\n                               ctlPos]\n                    mainCtrlOptions.append(options)\n                    options = [tPrefix[1],\n                               side,\n                               tControlType[1],\n                               6,\n                               tControlSize[1],\n                               [],\n                               ctlPos]\n                    mainCtrlOptions.append(options)\n\n            else:\n                options = [posPrefix,\n                           side,\n                           controlType,\n                           6,\n                           1.0,\n                           [],\n                           ctlPos]\n                mainCtrlOptions.append(options)\n\n            if controlType == \"npo\":\n                options = [posPrefix,\n                           side,\n                           controlType,\n                           6,\n                           1.0,\n                           [],\n                           ctlPos]\n                mainCtrlOptions.append(options)\n\n        # secondary control options\n        if secondary_ctl_check:\n            if symmetry_mode == 0:  # 0 means ON\n                secSideRange = \"LR\"\n            else:\n                secSideRange = \"CLR\"\n\n            if side in secSideRange:\n                sec_number_index = len(secCtrlPos) - 1\n                controlType = \"circle\"\n                for i, ctlPos in enumerate(secCtrlPos):\n                    # invert the index naming only.\n                    # if the full list is inver we generate another issues\n                    if side == \"R\":\n                        i_name = sec_number_index - i\n                    else:\n                        i_name = i\n                    posPrefix = \"sec_\" + str(i_name).zfill(2)\n                    options = [posPrefix,\n                               side,\n                               controlType,\n                               13,\n                               0.55,\n                               [],\n                               ctlPos]\n                    secCtrlOptions.append(options)\n\n        params = [\"tx\", \"ty\", \"tz\"]\n        # TODO: Is this a constant? Magic number ??\n        distSize = 1\n        if secondary_ctl_check:\n            controlOptionList = [mainCtrlOptions, secCtrlOptions]\n        else:\n            controlOptionList = [mainCtrlOptions]\n\n        # ###################\n        # Create controls from option lists.\n        #####################\n        localCtlList = []\n        localSecCtlList = []\n        # TODO: why is using test name for parent controls?\n        for j, ctlOptions in enumerate(controlOptionList):\n            # set status for main controllers\n            if j == 0:\n                testName = setName(\"mainControls\")\n                controlStatus = 0  # main controls\n                try:\n                    controlParentGrp = pm.PyNode(testName)\n                except:\n                    controlParentGrp = primitive.addTransform(\n                        browsControl_root, setName(\"mainControls\"))\n            # set status for secondary controllers\n            else:\n                testName = setName(\"secondaryControls\")\n                controlStatus = 1  # secondary controls\n                try:\n                    controlParentGrp = pm.PyNode(testName)\n                except:\n                    controlParentGrp = primitive.addTransform(\n                        browsControl_root, setName(\"secondaryControls\"))\n\n            # Create controls for each point position.\n            for i, point in enumerate(ctlOptions):\n                pm.progressWindow(e=True,\n                                  step=1,\n                                  status='\\nCreating control for%s' % point)\n                oName = ctlOptions[i][0]\n                oSide = ctlOptions[i][1]\n                o_icon = ctlOptions[i][2]\n                color = ctlOptions[i][3]\n                wd = ctlOptions[i][4]\n                oPar = ctlOptions[i][5]\n                point = ctlOptions[i][6]\n\n                position = transform.getTransformFromPos(point)\n                npo = primitive.addTransform(controlParentGrp,\n                                             setName(\"%s_npo\" % oName, oSide),\n                                             position)\n\n                npoBuffer = primitive.addTransform(\n                    npo,\n                    setName(\"%s_bufferNpo\" % oName, oSide),\n                    position)\n                # Create casual control\n                if o_icon != \"npo\":\n                    if o_icon == \"sphere\":\n                        rot_offset = None\n                    else:\n                        rot_offset = datatypes.Vector(1.57079633, 0, 0)\n\n                    ctl = icon.create(\n                        npoBuffer,\n                        setName(\"%s_%s\" % (oName, ctl_name), oSide),\n                        position,\n                        icon=o_icon,\n                        w=wd * self_size,\n                        d=wd * self_size,\n                        ro=rot_offset,\n                        po=datatypes.Vector(0, 0, .07 * distSize),\n                        color=color)\n                    attribute.addAttribute(ctl, \"isCtl\", \"bool\", keyable=False)\n                # Create buffer node instead\n                else:\n                    ctl = primitive.addTransform(\n                        npoBuffer,\n                        setName(\"%s_HookNpo\" % oName, oSide),\n                        position)\n\n                cname_split = ctl_name.split(\"_\")\n                if len(cname_split) == 2 and cname_split[-1] == \"ghost\":\n                    pass\n                else:\n                    pm.sets(ctlSet, add=ctl)\n                attribute.setKeyableAttributes(ctl, params + oPar)\n\n                # Create up vectors for each control\n                upv = primitive.addTransform(ctl,\n                                             setName(\"%s_upv\" % oName, oSide),\n                                             position)\n                upv.attr(\"tz\").set(FRONT_OFFSET)\n\n                # Collect local (per curve) and global controllers list\n                if controlStatus == 0:\n                    mainControls.append(ctl)\n                    mainUpvs.append(upv)\n                    localCtlList.append(ctl)\n\n                if controlStatus == 1:\n                    secondaryControls.append(ctl)\n                    secondaryUpvs.append(upv)\n                    localSecCtlList.append(ctl)\n\n                if oSide == \"R\":\n                    npo.attr(\"sx\").set(-1)\n\n                # collect hook npos'\n                if side == \"L\" and \"in\" in oName:\n                    l_hookMem.append(ctl)\n                if side == \"R\" and \"in\" in oName:\n                    r_hookMem.append(ctl)\n                if side == \"C\":\n                    c_hookMem.append(ctl)\n\n            pm.progressWindow(e=True, endProgress=True)\n\n            #####################\n            # Curves creation\n            #####################\n            crv_degree = 2\n\n            if controlStatus == 0:  # main controls\n                mainCtlCurve = helpers.addCnsCurve(\n                    browsCrv_side_root,\n                    setName(\"mainCtl_crv\", side),\n                    localCtlList,\n                    crv_degree)\n                rigCurves.append(mainCtlCurve[0])\n                mainCtlCurves.append(mainCtlCurve[0])\n\n                # create upvector curve to drive secondary control\n                if secondary_ctl_check:\n                    if side in secSideRange:\n                        mainCtlUpv = helpers.addCurve(\n                            browsCrv_side_root,\n                            setName(\"mainCtl_upv\", side),\n                            localCtlList,\n                            crv_degree)\n                        # connect upv curve to mainCrv_ctl driver node.\n                        pm.connectAttr(\n                            mainCtlCurve[1].attr(\"outputGeometry[0]\"),\n                            mainCtlUpv.getShape().attr(\"create\"))\n\n                        # offset upv curve\n                        cvs = mainCtlUpv.getCVs(space=\"world\")\n                        for i, cv in enumerate(cvs):\n                            offset = [cv[0], cv[1], cv[2] + FRONT_OFFSET]\n                            mainCtlUpv.setCV(i, offset, space='world')\n                        # collect mainCrv upv\n                        rigCurves.append(mainCtlUpv)\n                        mainCtlUpvs.append(mainCtlUpv)\n\n            # create secondary control curve.\n            if controlStatus == 1:\n                if side in secSideRange:\n                    secondaryCtlCurve = helpers.addCnsCurve(\n                        browsCrv_side_root,\n                        setName(\"secCtl_crv\", side),\n                        localSecCtlList,\n                        crv_degree)\n                    secondaryCurves.append(secondaryCtlCurve[0])\n                    rigCurves.append(secondaryCtlCurve[0])\n\n        # Constrain curves roots\n        ctl_parent = None\n        if side == \"C\":\n            ctl_parent = ctl_parent_C\n        elif side == \"L\":\n            ctl_parent = ctl_parent_L\n        elif side == \"R\":\n            ctl_parent = ctl_parent_R\n\n        if ctl_parent:\n            constraints.matrixConstraint(ctl_parent,\n                                         browsCrv_side_root,\n                                         'srt',\n                                         True)\n\n        # create upvector / rope curves\n        mainRope = curve.createCurveFromCurve(\n            mainCurve,\n            setName(\"mainRope\", side),\n            nbPoints=NB_ROPE,\n            parent=browsCrv_side_root)\n\n        rigCurves.append(mainRope)\n        mainRopes.append(mainRope)\n        ###\n        mainRope_upv = curve.createCurveFromCurve(\n            mainCurve,\n            setName(\"mainRope_upv\", side),\n            nbPoints=NB_ROPE,\n            parent=browsCrv_side_root)\n\n        rigCurves.append(mainRope_upv)\n        mainRopeUpvs.append(mainRope_upv)\n        ###\n        mainCrv_upv = curve.createCurveFromCurve(\n            mainCurve,\n            setName(\"mainCrv_upv\", side),\n            nbPoints=7,\n            parent=browsCrv_side_root)\n\n        rigCurves.append(mainCrv_upv)\n        mainCurveUpvs.append(mainCrv_upv)\n\n    # offset upv curves\n        for crv in [mainRope_upv, mainCrv_upv]:\n            cvs = crv.getCVs(space=\"world\")\n            for i, cv in enumerate(cvs):\n                # we populate the closest vertext list here to skipt the first\n                # and latest point\n                offset = [cv[0], cv[1], cv[2] + FRONT_OFFSET]\n                crv.setCV(i, offset, space='world')\n\n    # hide curves\n    for crv in rigCurves:\n        crv.attr(\"visibility\").set(False)\n\n    ###########################################\n    # Connecting controls\n    ###########################################\n    if parent_node:\n        try:\n            if isinstance(parent_node, string_types):\n                parent_node = pm.PyNode(parent_node)\n            parent_node.addChild(brows_root)\n        except RuntimeError:\n            pm.displayWarning(\"The brow rig can not be parent to: %s. Maybe \"\n                              \"this object doesn't exist.\" % parent_node)\n\n    # Reparent controls\n    # TODO: this can be more simple an easy to read\n    for ctl in mainControls:\n        tag_parent = None\n        ctl_side = getSide(ctl)\n\n        if ctl_side == \"L\":\n            if \"in_tangent_ctl\" in ctl.name():\n                t_inL = ctl\n            if \"in_ctl\" in ctl.name():\n                c_inL = ctl\n            if \"out_tangent\" in ctl.name():\n                t_outL = ctl\n            if \"out_ctl\" in ctl.name():\n                c_outL = ctl\n            tag_parent = parent_tag_L\n\n        if ctl_side == \"R\":\n            if \"in_tangent_ctl\" in ctl.name():\n                t_inR = ctl\n            if \"in_ctl\" in ctl.name():\n                c_inR = ctl\n            if \"out_tangent\" in ctl.name():\n                t_outR = ctl\n            if \"out_ctl\" in ctl.name():\n                c_outR = ctl\n            tag_parent = parent_tag_R\n\n        if symmetry_mode == 0:  # 0 means ON\n            if ctl_side == \"C\":\n                if \"R_HookNpo\" in ctl.name():\n                    h_outR = ctl\n                if \"L_HookNpo\" in ctl.name():\n                    h_outL = ctl\n                if \"mid_\" in ctl.name():\n                    c_mid = ctl\n                tag_parent = parent_tag_L\n        else:\n            if ctl_side == \"C\":\n                if \"out_R_ctl\" in ctl.name():\n                    c_outR = ctl\n                if \"out_L_ctl\" in ctl.name():\n                    c_outL = ctl\n\n                if \"out_R_tangent\" in ctl.name():\n                    t_outR = ctl\n                if \"out_L_tangent\" in ctl.name():\n                    t_outL = ctl\n\n                tag_parent = parent_tag_L\n        # controls tags\n        node.add_controller_tag(ctl, tagParent=tag_parent)\n\n    # parent controls\n    if symmetry_mode == 0:\n        # inside parents\n        pm.parent(t_inL.getParent(2), c_inL)\n        pm.parent(t_inR.getParent(2), c_inR)\n\n        pm.parent(t_outL.getParent(2), c_outL)\n        pm.parent(t_outR.getParent(2), c_outR)\n        constraints.matrixBlendConstraint([c_inR, c_inL],\n                                          c_mid.getParent(2),\n                                          [0.5, 0.5],\n                                          't',\n                                          True,\n                                          c_mid)\n\n        constraints.matrixConstraint(c_inR,\n                                     h_outR.getParent(2),\n                                     'srt',\n                                     True)\n        constraints.matrixConstraint(c_inL,\n                                     h_outL.getParent(2),\n                                     'srt',\n                                     True)\n        constraints.matrixConstraint(ctl_parent_C,\n                                     c_mid.getParent(2),\n                                     'rs',\n                                     True)\n        # TODO: we don't need matrix constrains in Main controls. This should\n        # be replace by simple parenting to the eyebrow main control\n        for ctl in mainControls:\n            ctl_side = getSide(ctl)\n\n            if ctl_side == \"L\" and \"_tangent\" not in ctl.name():\n                pm.parent(ctl.getParent(2), ctl_parent_L)\n\n            if ctl_side == \"R\" and \"_tangent\" not in ctl.name():\n                pm.parent(ctl.getParent(2), ctl_parent_R)\n\n    else:\n        ctl_side = getSide(mainControls[0])\n\n        if ctl_side == \"L\":\n            pm.parent(t_inL.getParent(2), c_inL)\n            pm.parent(t_outL.getParent(2), c_outL)\n            ctl_parent = ctl_parent_L\n        if ctl_side == \"R\":\n            pm.parent(t_inR.getParent(2), c_inR)\n            pm.parent(t_outR.getParent(2), c_outR)\n            ctl_parent = ctl_parent_R\n        if ctl_side == \"C\":\n            pm.parent(t_outR.getParent(2), c_outR)\n            pm.parent(t_outL.getParent(2), c_outL)\n            ctl_parent = ctl_parent_C\n        for ctl in mainControls:\n            if \"_tangent\" not in ctl.name():\n                pm.parent(ctl.getParent(2), ctl_parent)\n\n    # Attach secondary controls to main curve\n    if secondary_ctl_check:\n        secControlsMerged = []\n        if symmetry_mode == 0:  # 0 means ON\n            tempMainCtlCurves = [crv for crv in mainCtlCurves\n                                 if getSide(crv) in \"LR\"]\n            tempMainUpvCurves = [crv for crv in mainCtlUpvs\n                                 if getSide(crv) in \"LR\"]\n            leftSec = []\n            rightSec = []\n            for secCtl in secondaryControls:\n                # tag_parent = None\n                if getSide(secCtl) == \"L\":\n                    # connect secondary controla rotate/scale to ctl_parent_L.\n                    constraints.matrixConstraint(ctl_parent_L,\n                                                 secCtl.getParent(2),\n                                                 'rs',\n                                                 True)\n                    leftSec.append(secCtl)\n                    tag_parent = parent_tag_L\n\n                if getSide(secCtl) == \"R\":\n                    # connect secondary controla rotate/scale to ctl_parent_L.\n                    constraints.matrixConstraint(ctl_parent_R,\n                                                 secCtl.getParent(2),\n                                                 'rs',\n                                                 True)\n                    rightSec.append(secCtl)\n                    tag_parent = parent_tag_R\n\n                # controls tags\n                node.add_controller_tag(secCtl, tagParent=tag_parent)\n\n            secControlsMerged.append(rightSec)\n            secControlsMerged.append(leftSec)\n\n        else:\n            tempMainCtlCurves = mainCtlCurves\n            tempMainUpvCurves = mainCtlUpvs\n            secControlsMerged.append(secondaryControls)\n\n            for secCtl in secondaryControls:\n                constraints.matrixConstraint(ctl_parent,\n                                             secCtl.getParent(2),\n                                             'rs',\n                                             True)\n\n                # controls tags\n                node.add_controller_tag(secCtl, tagParent=parent_tag_L)\n\n        # create hooks on the main ctl curve\n        for j, crv in enumerate(secondaryCurves):\n            side = getSide(crv)\n\n            lvlType = 'transform'\n            cvs = crv.getCVs(space=\"world\")\n\n            for i, cv in enumerate(cvs):\n\n                oTransUpV = pm.PyNode(pm.createNode(\n                    lvlType,\n                    n=setName(\"secNpoUpv\", side, idx=str(i).zfill(3)),\n                    p=browsHooks_root,\n                    ss=True))\n\n                oTrans = pm.PyNode(pm.createNode(\n                    lvlType,\n                    n=setName(\"secNpo\", side, idx=str(i).zfill(3)),\n                    p=browsHooks_root, ss=True))\n\n                oParam, oLength = curve.getCurveParamAtPosition(crv, cv)\n                uLength = curve.findLenghtFromParam(crv, oParam)\n                u = uLength / oLength\n\n                # create motion paths transforms on main ctl curves\n                applyop.pathCns(oTransUpV,\n                                tempMainUpvCurves[j],\n                                cnsType=False,\n                                u=u,\n                                tangent=False)\n                cns = applyop.pathCns(oTrans,\n                                      tempMainCtlCurves[j],\n                                      cnsType=False,\n                                      u=u,\n                                      tangent=False)\n\n                cns.setAttr(\"worldUpType\", 1)\n                cns.setAttr(\"frontAxis\", 0)\n                cns.setAttr(\"upAxis\", 1)\n\n                pm.connectAttr(oTransUpV.attr(\"worldMatrix[0]\"),\n                               cns.attr(\"worldUpMatrix\"))\n\n                # connect scaling\n                ctl_parent = None\n                if side == \"C\":\n                    ctl_parent = ctl_parent_C\n                elif side == \"L\":\n                    ctl_parent = ctl_parent_L\n                elif side == \"R\":\n                    ctl_parent = ctl_parent_R\n\n                if ctl_parent:\n                    constraints.matrixConstraint(ctl_parent,\n                                                 oTrans,\n                                                 's',\n                                                 True)\n\n                # connect secondary control to oTrans hook.\n                constraints.matrixConstraint(\n                    oTrans,\n                    secControlsMerged[j][i].getParent(2),\n                    't',\n                    True)\n\n    ##################\n    # Wires and connections\n    ##################\n\n    # set drivers\n    crvDrivers = []\n    if secondary_ctl_check:\n        if symmetry_mode == 0:\n            crv = [crv for crv in mainCtlCurves if getSide(crv) == \"C\"]\n            crvDrivers.append(crv[0])\n\n            crvDrivers = crvDrivers + secondaryCurves\n        else:\n            crvDrivers = secondaryCurves\n\n    else:\n        crvDrivers = mainCtlCurves\n\n    for i, drv in enumerate(crvDrivers):\n        pm.wire(mainCurves[i], w=drv, dropoffDistance=[0, 1000])\n        pm.wire(mainCurveUpvs[i], w=drv, dropoffDistance=[0, 1000])\n        pm.wire(mainRopes[i], w=drv, dropoffDistance=[0, 1000])\n        pm.wire(mainRopeUpvs[i], w=drv, dropoffDistance=[0, 1000])\n    # ###########################################\n    # Joints\n    ###########################################\n    lvlType = \"transform\"\n\n    for j, crv in enumerate(mainCurves):\n        cvs = crv.getCVs(space=\"world\")\n        side = getSide(crv)\n\n        if symmetry_mode == 0:  # 0 means ON\n            if side == \"L\":\n                browJoint = brow_jnt_L\n            if side == \"R\":\n                browJoint = brow_jnt_R\n            if side == \"C\":\n                browJoint = brow_jnt_C\n        else:\n            browJoint = brow_jnt_C\n\n        for i, cv in enumerate(cvs):\n            if symmetry_mode == 0 and side == \"C\":\n\n                if i == 0 or i >= mid_loop_len - 1:\n                    continue\n\n            oTransUpV = pm.PyNode(pm.createNode(\n                lvlType,\n                n=setName(\"browRopeUpv\", idx=str(i).zfill(3)),\n                p=browsRope_root,\n                ss=True))\n\n            oTrans = pm.PyNode(\n                pm.createNode(lvlType,\n                              n=setName(\"browRope\", side, idx=str(i).zfill(3)),\n                              p=browsRope_root, ss=True))\n\n            oParam, oLength = curve.getCurveParamAtPosition(mainRopeUpvs[j],\n                                                            cv)\n            uLength = curve.findLenghtFromParam(mainRopes[j], oParam)\n            u = uLength / oLength\n\n            applyop.pathCns(\n                oTransUpV, mainRopeUpvs[j], cnsType=False, u=u, tangent=False)\n\n            cns = applyop.pathCns(\n                oTrans, mainRopes[j], cnsType=False, u=u, tangent=False)\n\n            cns.setAttr(\"worldUpType\", 1)\n            cns.setAttr(\"frontAxis\", 0)\n            cns.setAttr(\"upAxis\", 1)\n\n            pm.connectAttr(oTransUpV.attr(\"worldMatrix[0]\"),\n                           cns.attr(\"worldUpMatrix\"))\n            jnt = rigbits.addJnt(oTrans, noReplace=True, parent=browJoint)\n            jnt.segmentScaleCompensate.set(0)\n            allJoints.append(jnt)\n            pm.sets(defset, add=jnt)\n\n            # connect scaling\n            ctl_parent = None\n            if side == \"C\":\n                ctl_parent = ctl_parent_C\n            elif side == \"L\":\n                ctl_parent = ctl_parent_L\n            elif side == \"R\":\n                ctl_parent = ctl_parent_R\n\n            if ctl_parent:\n                constraints.matrixConstraint(ctl_parent,\n                                             oTrans,\n                                             's',\n                                             True)\n\n    for crv in mainCurves:\n        pm.delete(crv)\n\n    ###########################################\n    # Auto Skinning\n    ###########################################\n    if do_skin:\n        # base skin\n        if brow_jnt_C:\n            try:\n                brow_jnt_C = pm.PyNode(brow_jnt_C)\n            except RuntimeError:\n                pm.displayWarning(\n                    \"Auto skin aborted can not find %s \" % brow_jnt_C)\n                return\n\n        # Check if the object has a skinCluster\n        objName = pm.listRelatives(geo, parent=True)[0]\n\n        skinCluster = skin.getSkinCluster(objName)\n\n        if not skinCluster:\n            skinCluster = pm.skinCluster(joints_collect,\n                                         geo,\n                                         tsb=True,\n                                         nw=2,\n                                         n='skinCluster_{}'.format(geo.name()))\n\n        # totalLoops = rigid_loops + falloff_loops\n\n        # we set the first value 100% for the first initial loop\n        skinPercList = [1.0]\n        # we expect to have a regular grid topology\n        for r in range(rigid_loops):\n            for rr in range(2):\n                skinPercList.append(1.0)\n        increment = 1.0 / float(falloff_loops)\n        # we invert to smooth out from 100 to 0\n        inv = 1.0 - increment\n        for r in range(falloff_loops):\n            for rr in range(2):\n                if inv < 0.0:\n                    inv = 0.0\n                skinPercList.append(inv)\n            inv -= increment\n\n        # this loop add an extra 0.0 indices to avoid errors\n        for r in range(10):\n            for rr in range(2):\n                skinPercList.append(0.0)\n\n        pm.progressWindow(title='Auto skinning process',\n                          progress=0,\n                          max=len(allJoints))\n\n        vertexRowsList = []\n\n        totalLoops = rigid_loops + falloff_loops\n        vertexLoopList = meshNavigation.getConcentricVertexLoop(\n            closestVtxsList,\n            totalLoops)\n        vertexRowsList = meshNavigation.getVertexRowsFromLoops(vertexLoopList)\n\n        for i, jnt in enumerate(allJoints):\n\n            pm.progressWindow(e=True, step=1, status='\\nSkinning %s' % jnt)\n            skinCluster.addInfluence(jnt, weight=0)\n            v = closestVtxsList[i]\n            for row in vertexRowsList:\n                if v in row:\n                    for i, rv in enumerate(row):\n                        # find the deformer with max value for each vertex\n                        w = pm.skinPercent(skinCluster,\n                                           rv,\n                                           query=True,\n                                           value=True)\n                        transJoint = pm.skinPercent(skinCluster,\n                                                    rv,\n                                                    query=True,\n                                                    t=None)\n                        max_value = max(w)\n                        max_index = w.index(max_value)\n\n                        perc = skinPercList[i]\n                        t_value = [(jnt, perc),\n                                   (transJoint[max_index], 1.0 - perc)]\n                        pm.skinPercent(skinCluster,\n                                       rv,\n                                       transformValue=t_value)\n        pm.progressWindow(e=True, endProgress=True)\n\n##########################################################\n# Brows Rig UI\n##########################################################\n\n\nclass ui(MayaQWidgetDockableMixin, QtWidgets.QDialog):\n\n    valueChanged = QtCore.Signal(int)\n\n    def __init__(self, parent=None):\n        super(ui, self).__init__(parent)\n\n        self.filter = \"Brows Rigger Configuration .brows (*.brows)\"\n\n        self.create()\n\n    def create(self):\n\n        self.setWindowTitle(\"Brows Rigger\")\n        self.setWindowFlags(QtCore.Qt.Window)\n        self.setAttribute(QtCore.Qt.WA_DeleteOnClose, 1)\n\n        self.create_controls()\n        self.create_layout()\n        self.create_connections()\n\n    def create_controls(self):\n\n        # Geometry input controls\n        self.geometryInput_group = QtWidgets.QGroupBox(\"Geometry Input\")\n        self.edge_loop_label = QtWidgets.QLabel(\"Brow Edge Loop:\")\n        self.edge_loop = QtWidgets.QLineEdit()\n        self.edge_loop_button = QtWidgets.QPushButton(\"<<\")\n        # Name prefix\n        self.prefix_group = QtWidgets.QGroupBox(\"Name Prefix\")\n        self.name_prefix = QtWidgets.QLineEdit()\n        self.name_prefix.setText(\"brow\")\n\n        # control extension\n        self.control_group = QtWidgets.QGroupBox(\"Control Name Extension\")\n        self.ctl_name = QtWidgets.QLineEdit()\n        self.ctl_name.setText(\"ctl\")\n\n        # Topological Autoskin\n        self.topoSkin_group = QtWidgets.QGroupBox(\"Skin\")\n        self.rigid_loops_label = QtWidgets.QLabel(\"Rigid Loops:\")\n        self.rigid_loops = QtWidgets.QSpinBox()\n        self.rigid_loops.setRange(0, 30)\n        self.rigid_loops.setSingleStep(1)\n        self.rigid_loops.setValue(1)\n        self.falloff_loops_label = QtWidgets.QLabel(\"Falloff Loops:\")\n        self.falloff_loops = QtWidgets.QSpinBox()\n        self.falloff_loops.setRange(0, 30)\n        self.falloff_loops.setSingleStep(1)\n        self.falloff_loops.setValue(2)\n\n        self.do_skin = QtWidgets.QCheckBox(\n            'Compute Topological Autoskin')\n        self.do_skin.setChecked(False)\n\n        # Side\n        self.mode_group = QtWidgets.QGroupBox(\"Symmetry:\")\n        self.mode_label = QtWidgets.QLabel(\"Mode:\")\n        self.symmetry_mode = QtWidgets.QComboBox()\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding,\n                                           QtWidgets.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(\n            self.symmetry_mode.sizePolicy().hasHeightForWidth())\n        self.symmetry_mode.setSizePolicy(sizePolicy)\n        self.symmetry_mode.addItem(\"On\")\n        self.symmetry_mode.addItem(\"Off\")\n\n        # Options\n        self.options_group = QtWidgets.QGroupBox(\"Options\")\n\n        # default options\n        self.thickness_label = QtWidgets.QLabel(\"Brow Thickness:\")\n        self.thickness = QtWidgets.QDoubleSpinBox()\n        self.thickness.setRange(0, 10)\n        self.thickness.setSingleStep(.01)\n        self.thickness.setValue(.03)\n\n        # Side if single\n        self.side_label = QtWidgets.QLabel(\"Side:\")\n        self.side = QtWidgets.QComboBox()\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding,\n                                           QtWidgets.QSizePolicy.Fixed)\n        # sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(\n            self.side.sizePolicy().hasHeightForWidth())\n        self.side.setSizePolicy(sizePolicy)\n        self.side.addItem(\"C\")\n        self.side.addItem(\"L\")\n        self.side.addItem(\"R\")\n\n        self.side.setHidden(True)\n        self.side_label.setHidden(True)\n\n        # main divisions\n        self.main_div_label = QtWidgets.QLabel(\"Main Controls:\")\n        self.main_div = QtWidgets.QDoubleSpinBox()\n        self.main_div.setRange(0, 10)\n        self.main_div.setSingleStep(1)\n        self.main_div.setValue(3)\n        self.main_div.setDecimals(0)\n        self.main_div.setMinimum(3)\n\n        # secondary divisions\n        self.sec_div_label = QtWidgets.QLabel(\"Secondary Controls:\")\n        self.sec_div = QtWidgets.QDoubleSpinBox()\n        self.sec_div.setRange(0, 10)\n        self.sec_div.setSingleStep(1)\n        self.sec_div.setValue(5)\n        self.sec_div.setDecimals(0)\n        self.sec_div.setMinimum(3)\n\n        # secondary controls ?\n        self.secondary_ctl_check = QtWidgets.QCheckBox('Secondary controls')\n        self.secondary_ctl_check.setChecked(True)\n\n        # Parents\n        self.joints_group = QtWidgets.QGroupBox(\"Parent / Joints\")\n        self.controls_group = QtWidgets.QGroupBox(\"Controls\")\n\n        # central/main parent\n        self.brow_jnt_C_label = QtWidgets.QLabel(\"Main/central brow joint:\")\n        self.brow_jnt_C = QtWidgets.QLineEdit()\n        self.brow_jnt_C_button = QtWidgets.QPushButton(\"<<\")\n\n        # side joints\n        self.brow_jnt_L_label = QtWidgets.QLabel(\"Left brow joint:\")\n        self.brow_jnt_L = QtWidgets.QLineEdit()\n        self.brow_jnt_L_button = QtWidgets.QPushButton(\"<<\")\n\n        self.brow_jnt_R_label = QtWidgets.QLabel(\"Right brow joint:\")\n        self.brow_jnt_R = QtWidgets.QLineEdit()\n        self.brow_jnt_R_button = QtWidgets.QPushButton(\"<<\")\n\n        # ctl parents\n        self.ctl_parent_C_label = QtWidgets.QLabel(\"Head/Central control:\")\n        self.ctl_parent_C = QtWidgets.QLineEdit()\n        self.ctl_parent_C_button = QtWidgets.QPushButton(\"<<\")\n\n        self.ctl_parent_L_label = QtWidgets.QLabel(\"Left control:\")\n        self.ctl_parent_L = QtWidgets.QLineEdit()\n        self.ctl_parent_L_button = QtWidgets.QPushButton(\"<<\")\n\n        self.ctl_parent_R_label = QtWidgets.QLabel(\"Right control:\")\n        self.ctl_parent_R = QtWidgets.QLineEdit()\n        self.ctl_parent_R_button = QtWidgets.QPushButton(\"<<\")\n\n        # static parent\n        self.parent_label = QtWidgets.QLabel(\"Static Rig Parent:\")\n        self.parent_node = QtWidgets.QLineEdit()\n        self.parent_button = QtWidgets.QPushButton(\"<<\")\n\n        # Build button\n        self.build_button = QtWidgets.QPushButton(\"Build Brows Rig\")\n        self.import_button = QtWidgets.QPushButton(\"Import Config from json\")\n        self.export_button = QtWidgets.QPushButton(\"Export Config to json\")\n\n    def create_layout(self):\n\n        # Edge Loop Layout\n        edge_loop_layout = QtWidgets.QHBoxLayout()\n        edge_loop_layout.setContentsMargins(1, 1, 1, 1)\n        edge_loop_layout.addWidget(self.edge_loop_label)\n        edge_loop_layout.addWidget(self.edge_loop)\n        edge_loop_layout.addWidget(self.edge_loop_button)\n\n        # Geometry Input Layout\n        geometryInput_layout = QtWidgets.QVBoxLayout()\n        geometryInput_layout.setContentsMargins(6, 1, 6, 2)\n        geometryInput_layout.addLayout(edge_loop_layout)\n        self.geometryInput_group.setLayout(geometryInput_layout)\n\n        # Symmetry mode Layout\n        sym_layout = QtWidgets.QHBoxLayout()\n        sym_layout.setContentsMargins(1, 1, 1, 1)\n        sym_layout.addWidget(self.mode_label)\n        sym_layout.addWidget(self.symmetry_mode)\n\n        # Side if single\n        side_layout = QtWidgets.QHBoxLayout()\n        side_layout.setContentsMargins(1, 1, 1, 1)\n        side_layout.addWidget(self.side_label)\n        side_layout.addWidget(self.side)\n\n        mode_layout = QtWidgets.QVBoxLayout()\n        mode_layout.setContentsMargins(6, 4, 6, 4)\n        mode_layout.addLayout(sym_layout)\n        mode_layout.addLayout(side_layout)\n        self.mode_group.setLayout(mode_layout)\n\n        # parents Layout\n        # joints\n        brow_jnt_L_layout = QtWidgets.QHBoxLayout()\n        brow_jnt_L_layout.addWidget(self.brow_jnt_L_label)\n        brow_jnt_L_layout.addWidget(self.brow_jnt_L)\n        brow_jnt_L_layout.addWidget(self.brow_jnt_L_button)\n\n        brow_jnt_R_layout = QtWidgets.QHBoxLayout()\n        brow_jnt_R_layout.addWidget(self.brow_jnt_R_label)\n        brow_jnt_R_layout.addWidget(self.brow_jnt_R)\n        brow_jnt_R_layout.addWidget(self.brow_jnt_R_button)\n\n        brow_jnt_C_layout = QtWidgets.QHBoxLayout()\n        brow_jnt_C_layout.addWidget(self.brow_jnt_C_label)\n        brow_jnt_C_layout.addWidget(self.brow_jnt_C)\n        brow_jnt_C_layout.addWidget(self.brow_jnt_C_button)\n\n        # controls\n        ctl_parent_C_layout = QtWidgets.QHBoxLayout()\n        ctl_parent_C_layout.addWidget(self.ctl_parent_C_label)\n        ctl_parent_C_layout.addWidget(self.ctl_parent_C)\n        ctl_parent_C_layout.addWidget(self.ctl_parent_C_button)\n\n        ctl_parent_L_layout = QtWidgets.QHBoxLayout()\n        ctl_parent_L_layout.addWidget(self.ctl_parent_L_label)\n        ctl_parent_L_layout.addWidget(self.ctl_parent_L)\n        ctl_parent_L_layout.addWidget(self.ctl_parent_L_button)\n\n        ctl_parent_R_layout = QtWidgets.QHBoxLayout()\n        ctl_parent_R_layout.addWidget(self.ctl_parent_R_label)\n        ctl_parent_R_layout.addWidget(self.ctl_parent_R)\n        ctl_parent_R_layout.addWidget(self.ctl_parent_R_button)\n\n        # static parent\n        staticParent_layout = QtWidgets.QHBoxLayout()\n        staticParent_layout.addWidget(self.parent_label)\n        staticParent_layout.addWidget(self.parent_node)\n        staticParent_layout.addWidget(self.parent_button)\n\n        # joing layout\n        parents_layout = QtWidgets.QVBoxLayout()\n        parents_layout.setContentsMargins(6, 4, 6, 4)\n        parents_layout.addLayout(staticParent_layout)\n        parents_layout.addLayout(brow_jnt_L_layout)\n        parents_layout.addLayout(brow_jnt_R_layout)\n        parents_layout.addLayout(brow_jnt_C_layout)\n        self.joints_group.setLayout(parents_layout)\n\n        controls_layout = QtWidgets.QVBoxLayout()\n        controls_layout.setContentsMargins(6, 4, 6, 4)\n        controls_layout.addLayout(ctl_parent_C_layout)\n        controls_layout.addLayout(ctl_parent_L_layout)\n        controls_layout.addLayout(ctl_parent_R_layout)\n        self.controls_group.setLayout(controls_layout)\n\n        # Options Layout\n        thickness_layout = QtWidgets.QHBoxLayout()\n        thickness_layout.addWidget(self.thickness_label)\n        thickness_layout.addWidget(self.thickness)\n\n        secondary_ctl_check_layout = QtWidgets.QVBoxLayout()\n        secondary_ctl_check_layout.setContentsMargins(6, 4, 6, 4)\n        secondary_ctl_check_layout.addWidget(\n            self.secondary_ctl_check, alignment=QtCore.Qt.Alignment())\n\n        main_div_layout = QtWidgets.QHBoxLayout()\n        main_div_layout.addWidget(self.main_div_label)\n        main_div_layout.addWidget(self.main_div)\n\n        sec_div_layout = QtWidgets.QHBoxLayout()\n        sec_div_layout.addWidget(self.sec_div_label)\n        sec_div_layout.addWidget(self.sec_div)\n\n        options_layout = QtWidgets.QVBoxLayout()\n        options_layout.setContentsMargins(6, 1, 6, 2)\n        options_layout.addLayout(secondary_ctl_check_layout)\n        options_layout.addLayout(thickness_layout)\n        options_layout.addLayout(main_div_layout)\n        options_layout.addLayout(sec_div_layout)\n        self.options_group.setLayout(options_layout)\n\n        # Name prefix\n        name_prefix_layout = QtWidgets.QHBoxLayout()\n        name_prefix_layout.setContentsMargins(1, 1, 1, 1)\n        name_prefix_layout.addWidget(self.name_prefix)\n        self.prefix_group.setLayout(name_prefix_layout)\n\n        # Control Name Extension\n        controlExtension_layout = QtWidgets.QHBoxLayout()\n        controlExtension_layout.setContentsMargins(1, 1, 1, 1)\n        controlExtension_layout.addWidget(self.ctl_name)\n        self.control_group.setLayout(controlExtension_layout)\n\n        # topological autoskin Layout\n        skinLoops_layout = QtWidgets.QGridLayout()\n        skinLoops_layout.addWidget(self.rigid_loops_label, 0, 0)\n        skinLoops_layout.addWidget(self.falloff_loops_label, 0, 1)\n        skinLoops_layout.addWidget(self.rigid_loops, 1, 0)\n        skinLoops_layout.addWidget(self.falloff_loops, 1, 1)\n\n        topoSkin_layout = QtWidgets.QVBoxLayout()\n        topoSkin_layout.setContentsMargins(6, 4, 6, 4)\n        topoSkin_layout.addWidget(self.do_skin,\n                                  alignment=QtCore.Qt.Alignment())\n        topoSkin_layout.addLayout(skinLoops_layout)\n        topoSkin_layout.addLayout(parents_layout)\n        self.topoSkin_group.setLayout(topoSkin_layout)\n\n        # Main Layout\n        main_layout = QtWidgets.QVBoxLayout()\n        main_layout.setContentsMargins(6, 6, 6, 6)\n        main_layout.addWidget(self.prefix_group)\n        main_layout.addWidget(self.control_group)\n        main_layout.addWidget(self.geometryInput_group)\n        main_layout.addWidget(self.mode_group)\n        main_layout.addWidget(self.options_group)\n        main_layout.addWidget(self.joints_group)\n        main_layout.addWidget(self.controls_group)\n        main_layout.addWidget(self.topoSkin_group)\n        main_layout.addWidget(self.build_button)\n        main_layout.addWidget(self.import_button)\n        main_layout.addWidget(self.export_button)\n\n        self.setLayout(main_layout)\n\n    def create_connections(self):\n        self.symmetry_mode.currentTextChanged.connect(self.setSymmetryLayout)\n        self.side.currentIndexChanged.connect(self.setSideControls)\n        self.secondary_ctl_check.stateChanged.connect(\n            self.setSecondaryControls)\n\n        self.edge_loop_button.clicked.connect(partial(self.populate_edge_loop,\n                                                      self.edge_loop))\n\n        self.parent_button.clicked.connect(partial(self.populate_element,\n                                                   self.parent_node))\n\n        self.brow_jnt_L_button.clicked.connect(partial(self.populate_element,\n                                                       self.brow_jnt_L,\n                                                       \"joint\"))\n\n        self.brow_jnt_R_button.clicked.connect(partial(self.populate_element,\n                                                       self.brow_jnt_R,\n                                                       \"joint\"))\n\n        self.brow_jnt_C_button.clicked.connect(partial(self.populate_element,\n                                                       self.brow_jnt_C,\n                                                       \"joint\"))\n\n        self.ctl_parent_C_button.clicked.connect(partial(self.populate_element,\n                                                         self.ctl_parent_C))\n        self.ctl_parent_L_button.clicked.connect(partial(self.populate_element,\n                                                         self.ctl_parent_L))\n\n        self.ctl_parent_R_button.clicked.connect(partial(self.populate_element,\n                                                         self.ctl_parent_R))\n\n        self.build_button.clicked.connect(self.build_rig)\n        self.import_button.clicked.connect(self.import_settings)\n        self.export_button.clicked.connect(self.export_settings)\n\n    def setSymmetryLayout(self, value):\n        self.setSideControls(value)\n        if value == \"Off\":\n            self.side.setHidden(False)\n            self.side_label.setHidden(False)\n\n            self.brow_jnt_L_label.setHidden(True)\n            self.brow_jnt_L.setHidden(True)\n            self.brow_jnt_L_button.setHidden(True)\n\n            self.brow_jnt_R_label.setHidden(True)\n            self.brow_jnt_R.setHidden(True)\n            self.brow_jnt_R_button.setHidden(True)\n\n            self.ctl_parent_R_label.setHidden(True)\n            self.ctl_parent_R.setHidden(True)\n            self.ctl_parent_R_button.setHidden(True)\n        else:\n            self.side.setHidden(True)\n            self.side_label.setHidden(True)\n\n            self.brow_jnt_L_label.setHidden(False)\n            self.brow_jnt_L.setHidden(False)\n            self.brow_jnt_L_button.setHidden(False)\n\n            self.brow_jnt_R_label.setHidden(False)\n            self.brow_jnt_R.setHidden(False)\n            self.brow_jnt_R_button.setHidden(False)\n\n            self.ctl_parent_R_label.setHidden(False)\n            self.ctl_parent_R.setHidden(False)\n            self.ctl_parent_R_button.setHidden(False)\n\n    def setSideControls(self, value):\n\n        if value == \"On\":\n            self.ctl_parent_R_label.setHidden(False)\n            self.ctl_parent_R.setHidden(False)\n            self.ctl_parent_R_button.setHidden(False)\n            self.ctl_parent_L_label.setHidden(False)\n            self.ctl_parent_L.setHidden(False)\n            self.ctl_parent_L_button.setHidden(False)\n            self.ctl_parent_C_label.setHidden(False)\n            self.ctl_parent_C.setHidden(False)\n            self.ctl_parent_C_button.setHidden(False)\n\n        elif self.side.currentText() == \"R\":\n            self.ctl_parent_R_label.setHidden(False)\n            self.ctl_parent_R.setHidden(False)\n            self.ctl_parent_R_button.setHidden(False)\n            self.ctl_parent_L_label.setHidden(True)\n            self.ctl_parent_L.setHidden(True)\n            self.ctl_parent_L_button.setHidden(True)\n            self.ctl_parent_C_label.setHidden(True)\n            self.ctl_parent_C.setHidden(True)\n            self.ctl_parent_C_button.setHidden(True)\n\n        elif self.side.currentText() == \"L\":\n            self.ctl_parent_R_label.setHidden(True)\n            self.ctl_parent_R.setHidden(True)\n            self.ctl_parent_R_button.setHidden(True)\n            self.ctl_parent_L_label.setHidden(False)\n            self.ctl_parent_L.setHidden(False)\n            self.ctl_parent_L_button.setHidden(False)\n            self.ctl_parent_C_label.setHidden(True)\n            self.ctl_parent_C.setHidden(True)\n            self.ctl_parent_C_button.setHidden(True)\n\n        elif self.side.currentText() == \"C\":\n            self.ctl_parent_R_label.setHidden(True)\n            self.ctl_parent_R.setHidden(True)\n            self.ctl_parent_R_button.setHidden(True)\n            self.ctl_parent_L_label.setHidden(True)\n            self.ctl_parent_L.setHidden(True)\n            self.ctl_parent_L_button.setHidden(True)\n            self.ctl_parent_C_label.setHidden(False)\n            self.ctl_parent_C.setHidden(False)\n            self.ctl_parent_C_button.setHidden(False)\n\n    def setSecondaryControls(self, value):\n        if value == 0:\n            self.sec_div_label.setHidden(True)\n            self.sec_div.setHidden(True)\n        else:\n            self.sec_div_label.setHidden(False)\n            self.sec_div.setHidden(False)\n    #SLOTS ##########################################################\n\n    def populate_element(self, lEdit, oType=\"transform\"):\n        if oType == \"joint\":\n            oTypeInst = pm.nodetypes.Joint\n        elif oType == \"vertex\":\n            oTypeInst = pm.MeshVertex\n        else:\n            oTypeInst = pm.nodetypes.Transform\n\n        oSel = pm.selected()\n        if oSel:\n            if isinstance(oSel[0], oTypeInst):\n                lEdit.setText(oSel[0].name())\n            else:\n                pm.displayWarning(\n                    \"The selected element is not a valid %s\" % oType)\n        else:\n            pm.displayWarning(\"Please select first one %s.\" % oType)\n\n    def populate_edge_loop(self, lineEdit):\n        lineEdit.setText(lib.get_edge_loop_from_selection())\n\n    def build_rig(self):\n        rig(**lib.get_settings_from_widget(self))\n\n    def export_settings(self):\n        data_string = json.dumps(\n            lib.get_settings_from_widget(self), indent=4, sort_keys=True\n        )\n\n        file_path = lib.get_file_path(self.filter, \"save\")\n        if not file_path:\n            return\n\n        with open(file_path, \"w\") as f:\n            f.write(data_string)\n\n    def import_settings(self):\n        file_path = lib.get_file_path(self.filter, \"open\")\n        if not file_path:\n            return\n\n        lib.import_settings_from_file(file_path, self)\n\n\n# Build from json file.\ndef rig_from_file(path):\n    rig(**json.load(open(path)))\n\n\ndef show(*args):\n    gqt.showDialog(ui)\n\n\nif __name__ == \"__main__\":\n    show()\n",
  "language": "python",
  "imports": [],
  "has_docstring": true
}