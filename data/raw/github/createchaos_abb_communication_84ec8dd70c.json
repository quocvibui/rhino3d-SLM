{
  "source_url": "https://github.com/createchaos/abb_communication/blob/740ea3c6bf93b9b0d03e63a6d56ee8ad748e4e38/src/abb_communication/clients/rfl_robot/gantry.py",
  "repo": "createchaos/abb_communication",
  "repo_stars": 3,
  "repo_description": "communication library for abb robot control",
  "license": "NOASSERTION",
  "filepath": "src/abb_communication/clients/rfl_robot/gantry.py",
  "instruction": ". . . . . . . . . . . . . . . . . . \n.                                 .\n.   <<><><>    <<><><>  <<        .\n.   <<    ><   <<       <<        .\n.   <<><><>    <<><><   <<        .  \n.   <<  ><    ...",
  "code": "'''\n. . . . . . . . . . . . . . . . . . \n.                                 .\n.   <<><><>    <<><><>  <<        .\n.   <<    ><   <<       <<        .\n.   <<><><>    <<><><   <<        .  \n.   <<  ><     <<       <<        .\n.   <<   <>    <<       <<        .\n.   <<    ><   <<       <<><><>   .\n.                                 .\n.             GKR 2016/17         .\n. . . . . . . . . . . . . . . . . .\n\nCreated on 05.01.2017\n\n@author: stefanap \n'''\n\n\nfrom abb_communication.geometry import Frame\nimport ghpythonlib.components as ghcomp\nimport Rhino.Geometry as rg\nimport math as m\n\n\nclass Gantry(object):\n    \n    #===========================================================================\n    def __init__(self, geo, gantry_plane):\n        ''' gantry class for the rfl \n        geo = gantry geometry as list\n        plane = defined gantry plane - if default - [0,0,0,x,y]\n        '''\n        \n        self.geo = geo\n        self.plane = gantry_plane\n        self.frame = Frame(self.plane, draw_geo=True)\n        \n        self.T = rg.Transform.PlaneToPlane(self.plane, rg.Plane.WorldXY)\n        self.geo_WCS = ghcomp.Transform(self.geo, self.T) # gantry aligned_with_WCS\n        \n        self.plane_WCS = ghcomp.Transform(self.plane, self.T) # should be WorldXY plane\n    \n    \n    def get_transformed_geo(self, plane_new, rob_nr):\n        \n        self.plane = plane_new\n        geo_z1, geo_z2, geo_y, geo_x, geo_fix = self.geo\n        \n        plane_0 = rg.Plane(rg.Point3d(0,0,0), rg.Vector3d(1,0,0), rg.Vector3d(0,1,0))\n\n        #self.plane.YAxis.Reverse()\n        #self.plane.XAxis.Reverse()\n        vec_trans_1 = rg.Vector3d.Subtract(rg.Vector3d(self.plane.Origin), rg.Vector3d(rg.Plane.WorldXY.Origin))\n        T1 = rg.Transform.Translation(vec_trans_1)\n        \n        T_rot = rg.Transform.Rotation(m.pi, rg.Vector3d.ZAxis, self.plane.Origin)\n        T_mirr = rg.Transform.Mirror(self.plane.Origin, rg.Vector3d.XAxis)\n            \n        z_max = 4500\n        vec_trans_2_z = ((z_max - vec_trans_1.Z)/2) + vec_trans_1.Z \n        vec_trans_2 = vec_trans_1\n        vec_trans_2.Z = vec_trans_2_z\n        T2 = rg.Transform.Translation(vec_trans_2)\n        \n        vec_trans_3 = rg.Vector3d(vec_trans_1.X, vec_trans_1.Y, 0)\n        T3 = rg.Transform.Translation(vec_trans_3)\n        \n        vec_trans_4 = rg.Vector3d(vec_trans_1.X, 0, 0)\n        T4 = rg.Transform.Translation(vec_trans_4)\n        \n        geo_z1_WCS = ghcomp.Transform(geo_z1, T1)\n        geo_z2_WCS = ghcomp.Transform(geo_z2, T2)\n        geo_y_WCS = ghcomp.Transform(geo_y, T3)\n        \n        if rob_nr == 1 or rob_nr == 3:\n            geo_x_WCS = ghcomp.Transform(geo_x, T4)\n        else:\n            geo_x_WCS = None\n        \n        if rob_nr == 2 or rob_nr == 4:\n            geo_z1_WCS = ghcomp.Transform(geo_z1_WCS, T_rot)\n            geo_z2_WCS = ghcomp.Transform(geo_z2_WCS, T_rot)\n        if rob_nr == 3 or rob_nr == 4:\n            geo_y_WCS = ghcomp.Transform(geo_y_WCS, T_rot)\n        if rob_nr == 3:\n            geo_x_WCS = ghcomp.Transform(geo_x_WCS, T_mirr)\n\n         \n        geo_gantry = [geo_z1_WCS, geo_z2_WCS, geo_y_WCS, geo_x_WCS, geo_fix]\n        \n        return geo_gantry\n        \n        \n    ",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}