{
  "source_url": "https://github.com/Nihalmannath/Grounded-one_click_structural_solution/blob/94373d5c3a0ea210040d9de1195b23acb6fba0c2/comprehensivefinalscript.py",
  "repo": "Nihalmannath/Grounded-one_click_structural_solution",
  "repo_stars": 0,
  "repo_description": "Research studio/term_2",
  "license": "unknown",
  "filepath": "comprehensivefinalscript.py",
  "instruction": "-------------------------------------------------------------- GLB TO 3DM CONVERTER --------------------------------------------------------------",
  "code": "\r\n# --------------------------------------------------------------\r\n# GLB TO 3DM CONVERTER\r\n# --------------------------------------------------------------\r\n\r\nimport pygltflib\r\nimport rhino3dm\r\nimport os\r\nimport numpy as np\r\nfrom shapely.geometry import Polygon, Point, MultiPolygon, LineString\r\nimport matplotlib.pyplot as plt\r\n# import csv\r\nimport pandas as pd\r\nfrom collections import OrderedDict\r\nimport json\r\nfrom shapely.ops import unary_union # For combining polygons on a floor\r\nimport plotly.io as pio\r\npio.renderers.default = 'browser'\r\n\r\ndef convert_glb_to_3dm(glb_path, output_3dm_path):\r\n    \"\"\"\r\n    Loads a GLB file, extracts its mesh data, and saves it as a 3dm file.\r\n    Only mesh geometry will be converted. Materials, animations, etc., are not translated.\r\n    \"\"\"\r\n\r\n    if not os.path.exists(glb_path):\r\n        raise FileNotFoundError(f\"GLB file not found: {glb_path}\")\r\n\r\n    print(f\"Loading GLB file from: {glb_path}\")\r\n    gltf = pygltflib.GLTF2().load(glb_path)\r\n\r\n    model_3dm = rhino3dm.File3dm()\r\n\r\n    # Iterate through GLTF meshes and add them to the 3dm model\r\n    for mesh_idx, gltf_mesh in enumerate(gltf.meshes):\r\n        print(f\"Processing mesh: {gltf_mesh.name if gltf_mesh.name else f'Mesh_{mesh_idx}'}\")\r\n        \r\n        for primitive in gltf_mesh.primitives:\r\n            # Get vertex positions\r\n            accessor_pos = gltf.accessors[primitive.attributes.POSITION]\r\n            buffer_view_pos = gltf.bufferViews[accessor_pos.bufferView]\r\n            buffer_pos = gltf.buffers[buffer_view_pos.buffer]\r\n\r\n            # Extract vertices\r\n            vertices_bytes = gltf.get_data_from_buffer_uri(buffer_pos.uri)[\r\n                buffer_view_pos.byteOffset : buffer_view_pos.byteOffset + buffer_view_pos.byteLength\r\n            ]\r\n            vertices = np.frombuffer(vertices_bytes, dtype=np.float32).reshape(-1, 3)\r\n\r\n            # Detect unit scale\r\n            scale_factor = 1\r\n            print(f\"Detected scale factor: {scale_factor} (applied to convert to meters)\")\r\n\r\n            rhino_mesh = rhino3dm.Mesh()\r\n\r\n            for v in vertices:\r\n                rhino_mesh.Vertices.Add(v[0] * scale_factor, v[1] * scale_factor, v[2] * scale_factor)\r\n\r\n            # Get indices (faces)\r\n            if primitive.indices is not None:\r\n                accessor_indices = gltf.accessors[primitive.indices]\r\n                buffer_view_indices = gltf.bufferViews[accessor_indices.bufferView]\r\n                buffer_indices = gltf.buffers[buffer_view_indices.buffer]\r\n\r\n                indices_bytes = gltf.get_data_from_buffer_uri(buffer_indices.uri)[\r\n                    buffer_view_indices.byteOffset : buffer_view_indices.byteOffset + buffer_view_indices.byteLength\r\n                ]\r\n                \r\n                # Determine dtype for indices (UINT8, UINT16, UINT32)\r\n                if accessor_indices.componentType == pygltflib.UNSIGNED_BYTE:\r\n                    indices_dtype = np.uint8\r\n                elif accessor_indices.componentType == pygltflib.UNSIGNED_SHORT:\r\n                    indices_dtype = np.uint16\r\n                elif accessor_indices.componentType == pygltflib.UNSIGNED_INT:\r\n                    indices_dtype = np.uint32\r\n                else:\r\n                    print(f\"Warning: Unsupported index component type: {accessor_indices.componentType}. Skipping faces for this primitive.\")\r\n                    continue\r\n\r\n                indices = np.frombuffer(indices_bytes, dtype=indices_dtype)\r\n\r\n                # glTF uses flat arrays for indices, assuming triangles (mode 4)\r\n                if primitive.mode == pygltflib.TRIANGLES:\r\n                    for i in range(0, len(indices), 3):\r\n                        rhino_mesh.Faces.AddFace(int(indices[i]), int(indices[i+1]), int(indices[i+2]))\r\n                else:\r\n                    print(f\"Warning: Skipping primitive with unsupported mode: {primitive.mode}. Only triangles (mode 4) are fully supported for faces.\")\r\n                    continue\r\n            else:\r\n                print(f\"Warning: Primitive has no indices. Assuming sequential triangles, but this might not be correct for complex GLBs.\")\r\n                for i in range(0, len(vertices) - 2, 3):\r\n                    rhino_mesh.Faces.AddFace(i, i+1, i+2)\r\n\r\n            # Optional: Calculate normals\r\n            rhino_mesh.Normals.ComputeNormals()\r\n            rhino_mesh.Compact()\r\n\r\n            model_3dm.Objects.AddMesh(rhino_mesh)\r\n    \r\n    print(f\"Saving 3dm file to: {output_3dm_path}\")\r\n    model_3dm.Write(output_3dm_path, 0)\r\n    print(\"Conversion complete!\")\r\n\r\n    print(\"Sample vertices:\", vertices[:5])\r\n\r\n# --- Define paths ---\r\n# Prompt the user for the GLB file path\r\nwhile True:\r\n    glb_input_path = input(\"Please enter the full path to your GLB file: \").strip().strip('\"').strip(\"'\")\r\n    glb_file_path = os.path.abspath(os.path.expanduser(glb_input_path))\r\n\r\n    # glb_input_path = input(\"Please enter the full path to your GLB file (e.g., C:\\\\Users\\\\papad\\\\Documents\\\\GitHub\\\\Octopusie\\\\Reference Files\\\\my_model.glb): \")\r\n    # glb_file_path = os.path.abspath(os.path.expanduser(glb_input_path.strip())) # Clean and absolute path\r\n    if os.path.exists(glb_file_path):\r\n        if glb_file_path.lower().endswith(\".glb\"):\r\n            break\r\n        else:\r\n            print(\"Error: The provided file is not a .glb file. Please enter a valid GLB file path.\")\r\n    else:\r\n        print(f\"Error: File not found at '{glb_file_path}'. Please check the path and try again.\")\r\n\r\n# Derive the output 3dm file path from the GLB file path\r\ndirectory = os.path.dirname(glb_file_path)\r\nfile_name_without_ext = os.path.splitext(os.path.basename(glb_file_path))[0]\r\noutput_3dm_file_path = os.path.join(directory, f\"{file_name_without_ext}.3dm\")\r\n\r\n# --- Run the conversion ---\r\ntry:\r\n    convert_glb_to_3dm(glb_file_path, output_3dm_file_path)\r\n    print(f\"\\nConversion successful! The 3DM file is saved at: {output_3dm_file_path}\")\r\n\r\nexcept FileNotFoundError as e:\r\n    print(e)\r\n    print(\"Please ensure the GLB file path is correct.\")\r\nexcept Exception as e:\r\n    print(f\"An error occurred during conversion: {e}\")\r\n\r\n\r\n# --------------------------------------------------------------\r\n# MASHALLA FOR FORCED COLUMNS - Now uses the dynamically generated 3DM file\r\n# --------------------------------------------------------------\r\n\r\n# File path - now dynamically set from the conversion output\r\nrhino_path = output_3dm_file_path\r\n\r\nif not os.path.exists(rhino_path):\r\n    raise FileNotFoundError(f\"File not found: {rhino_path}\")\r\n\r\n# Load model\r\nmodel = rhino3dm.File3dm.Read(rhino_path)\r\n\r\n# Extract geometries and their bounding boxes\r\nbuilding_floor_footprints = []\r\nall_mesh_bboxes = []\r\nroof_meshes_info = []\r\nmax_z = 0.0\r\n\r\nZ_FLATNESS_TOLERANCE = 0.1\r\n\r\nfor obj in model.Objects:\r\n    geom = obj.Geometry\r\n    if geom.ObjectType == rhino3dm.ObjectType.Mesh:\r\n        bbox = geom.GetBoundingBox()\r\n        \r\n        bbox_x_dim = bbox.Max.X - bbox.Min.X\r\n        bbox_y_dim = bbox.Max.Y - bbox.Min.Y\r\n        bbox_z_dim = bbox.Max.Z - bbox.Min.Z\r\n\r\n        if bbox_z_dim < Z_FLATNESS_TOLERANCE and bbox_x_dim > 0.1 and bbox_y_dim > 0.1:\r\n            base_pts = [\r\n                [bbox.Min.X, bbox.Min.Y],\r\n                [bbox.Max.X, bbox.Min.Y],\r\n                [bbox.Max.X, bbox.Max.Y],\r\n                [bbox.Min.X, bbox.Max.Y],\r\n                [bbox.Min.X, bbox.Min.Y]\r\n            ]\r\n            poly = Polygon(base_pts)\r\n            if poly.area > 1e-3:\r\n                building_floor_footprints.append(poly)\r\n                roof_meshes_info.append((obj.Attributes.Id, bbox, poly))\r\n\r\n        all_mesh_bboxes.append(bbox)\r\n        \r\n        max_z = max(max_z, bbox.Max.Z)\r\n\r\nif not building_floor_footprints:\r\n    raise RuntimeError(\"No meaningful building floor footprints (meshes flat in Z with area) found in the model.\")\r\n\r\nprint(f\"Detected {len(building_floor_footprints)} building floor footprints. Max Z height: {max_z:.2f}m\")\r\nprint(f\"Total meshes contributing to height calculation: {len(all_mesh_bboxes)}\")\r\nprint(f\"Detected {len(roof_meshes_info)} potential roof meshes for comparison.\")\r\n\r\n# --------------------------------------------------------------\r\n# ===== PERIMETER =====\r\n# --------------------------------------------------------------\r\n\r\n# Find and print roofs that are peaks (taller than all directly touching roofs)\r\nprint(\"\\n--- Analyzing Roof Heights ---\")\r\n\r\nwall_thickness = 0.3  # meters (30 cm)\r\nprint(f\"Using default wall thickness: {wall_thickness} m\")\r\n\r\n\r\ncombined_building_polygon = MultiPolygon(building_floor_footprints)\r\n\r\ntry:\r\n    exterior_perimeter = combined_building_polygon.buffer(wall_thickness, join_style=1)\r\nexcept Exception as e:\r\n    print(f\"Could not buffer the building outline. Error: {e}\")\r\n    exterior_perimeter = None\r\n\r\nif exterior_perimeter and exterior_perimeter.geom_type == 'MultiPolygon':\r\n    exterior_perimeter = max(exterior_perimeter.geoms, key=lambda p: p.area)\r\n\r\nperimeter_line_coords = []\r\nif exterior_perimeter:\r\n    if exterior_perimeter.geom_type == 'Polygon':\r\n        perimeter_line_coords = list(exterior_perimeter.exterior.coords)\r\n    elif exterior_perimeter.geom_type == 'MultiPolygon':\r\n        perimeter_line_coords = list(exterior_perimeter.geoms[0].exterior.coords)\r\n    else:\r\n        print(\"Warning: The buffered perimeter is not a Polygon or MultiPolygon. Cannot extract line coordinates.\")\r\n\r\n# --- End perimeter section ---\r\n\r\ndetected_rooms = sorted([(poly, poly.area) for poly in building_floor_footprints], key=lambda x: -x[1])\r\nif not detected_rooms:\r\n    raise RuntimeError(\"No valid rooms detected after filtering by area. Check your Rhino model geometry.\")\r\n\r\n\r\n# --------------------------------------------------------------\r\n# ===== FLOOR DETECTION =====\r\n# --------------------------------------------------------------\r\n\r\nfloor_height = 2.5  # meters per floor\r\nnum_floors = max(1, int(round(max_z / floor_height)))\r\nprint(f\"Automatically calculated number of floors: {num_floors} (based on max height {max_z:.2f}m and {floor_height}m per floor)\")\r\n\r\n# Assume floor_height and Z_FLATNESS_TOLERANCE are defined\r\n\r\n# --- Step 1: Categorize Floor Footprints by Height/Floor Level ---\r\nfloor_footprints_by_level = {}\r\nfloor_z_levels = set() # To store the z-coordinates of each detected floor\r\n\r\nfor obj in model.Objects:\r\n    geom = obj.Geometry\r\n    if geom.ObjectType == rhino3dm.ObjectType.Mesh:\r\n        bbox = geom.GetBoundingBox()\r\n        \r\n        bbox_x_dim = bbox.Max.X - bbox.Min.X\r\n        bbox_y_dim = bbox.Max.Y - bbox.Min.Y\r\n        bbox_z_dim = bbox.Max.Z - bbox.Min.Z\r\n\r\n        if bbox_z_dim < Z_FLATNESS_TOLERANCE and bbox_x_dim > 0.1 and bbox_y_dim > 0.1:\r\n            base_pts = [\r\n                [bbox.Min.X, bbox.Min.Y],\r\n                [bbox.Max.X, bbox.Min.Y],\r\n                [bbox.Max.X, bbox.Max.Y],\r\n                [bbox.Min.X, bbox.Max.Y],\r\n                [bbox.Min.X, bbox.Min.Y]\r\n            ]\r\n            poly = Polygon(base_pts)\r\n            if poly.area > 1e-3:\r\n                # Estimate floor level based on min Z of the bbox\r\n                # You might need to refine this to snap to discrete floor levels\r\n                \r\n                # A more robust way might be to cluster Z values\r\n                # For simplicity, let's just use the rounded Z for grouping for now\r\n                approx_z = round(bbox.Max.Z / floor_height) * floor_height # Snap to nearest floor_height multiple\r\n                floor_z_levels.add(approx_z)\r\n                \r\n                if approx_z not in floor_footprints_by_level:\r\n                    floor_footprints_by_level[approx_z] = []\r\n                floor_footprints_by_level[approx_z].append(poly)\r\n\r\n# Sort the Z levels to process floors in order\r\nsorted_floor_z_levels = sorted(list(floor_z_levels))\r\nprint(f\"Detected Z levels for floors: {sorted_floor_z_levels}\")\r\n\r\n\r\n# --------------------------------------------------------------\r\n# ===== CANTILEVER DETECTION =====\r\n# --------------------------------------------------------------\r\n\r\n\r\n# --- REVISED CANTILEVER DETECTION LOGIC ---\r\nCANTILEVER_AREA_THRESHOLD = 0.5 # m^2, adjust as needed\r\n\r\nprint(\"\\n--- REVISING Cantilever Analysis (Ground Floor vs. First Floor) ---\")\r\n\r\ndetected_cantilevers = []\r\n\r\nforced_cantilever_corner_points = []\r\n\r\n\r\n\r\n# Store regions where columns should NOT be placed from ground to first floor\r\ncantilever_no_column_zones_ground_to_first = [] \r\n\r\nCANTILEVER_CHECK_BUFFER = 0.05 # meters, a small buffer for point-in-polygon checks\r\n\r\n# These columns will start from the first floor level instead of the ground.\r\ncolumns_to_skip_ground_to_first_span = set()\r\n\r\n# Ensure we have at least a ground floor and a \"first floor\" above it\r\nif len(sorted_floor_z_levels) >= 2:\r\n    ground_floor_z = sorted_floor_z_levels[0] # Assuming the lowest Z is the ground floor\r\n    first_floor_above_ground_z = sorted_floor_z_levels[1] # This is the \"first floor\" to check for cantilevers\r\n\r\n    ground_floor_polygons = floor_footprints_by_level.get(ground_floor_z, [])\r\n    first_floor_polygons = floor_footprints_by_level.get(first_floor_above_ground_z, [])\r\n\r\n    if not ground_floor_polygons:\r\n        print(f\"No ground floor polygons found at Z level {ground_floor_z:.2f}. Cannot check for first floor cantilevers.\")\r\n    elif not first_floor_polygons:\r\n        print(f\"No first floor polygons found at Z level {first_floor_above_ground_z:.2f}. No cantilevers to detect.\")\r\n    else:\r\n        # Create a combined footprint for the ground floor\r\n        combined_ground_floor_footprint = unary_union(ground_floor_polygons)\r\n        \r\n        print(f\"\\nChecking First Floor (Z={first_floor_above_ground_z:.2f}m) against Ground Floor (Z={ground_floor_z:.2f}m) for cantilevers.\")\r\n\r\n        for first_floor_poly in first_floor_polygons:\r\n            # Calculate the part of the first floor polygon that extends beyond the ground floor\r\n            cantilever_part = first_floor_poly.difference(combined_ground_floor_footprint)\r\n\r\n            if not cantilever_part.is_empty and cantilever_part.geom_type in ['Polygon', 'MultiPolygon']:\r\n                cantilever_area = 0\r\n                if cantilever_part.geom_type == 'Polygon':\r\n                    cantilever_area = cantilever_part.area\r\n                else: # MultiPolygon\r\n                    for geom in cantilever_part.geoms:\r\n                        if geom.geom_type == 'Polygon':\r\n                            cantilever_area += geom.area\r\n                \r\n                if cantilever_area > CANTILEVER_AREA_THRESHOLD:\r\n                    detected_cantilevers.append({\r\n                        \"UpperFloorZ\": round(first_floor_above_ground_z, 2),\r\n                        \"LowerFloorZ\": round(ground_floor_z, 2),\r\n                        \"CantileverArea\": round(cantilever_area, 2),\r\n                        \"CantileverGeometry\": cantilever_part,\r\n                        \"UpperFloorPolygonCenter\": [round(first_floor_poly.centroid.x, 2), round(first_floor_poly.centroid.y, 2)]\r\n                    })\r\n                    print(f\"  Detected cantilever at First Floor Z={first_floor_above_ground_z:.2f}m with area: {cantilever_area:.2f} mÂ²\")\r\n                    print(f\"    Originating polygon center: X={first_floor_poly.centroid.x:.2f}, Y={first_floor_poly.centroid.y:.2f}\")\r\nelse:\r\n    print(\"\\nNot enough floor levels (less than 2) to check for first floor cantilevers.\")\r\n\r\nif detected_cantilevers:\r\n    print(\"\\n--- Summary of Detected First Floor Cantilevers ---\")\r\n    for cantilever in detected_cantilevers:\r\n        print(f\"  - Upper Floor Z: {cantilever['UpperFloorZ']}m, Lower Floor Z: {cantilever['LowerFloorZ']}m, Cantilever Area: {cantilever['CantileverArea']} mÂ²\")\r\nelse:\r\n    print(\"\\nNo significant first floor cantilevers detected based on the defined thresholds.\")\r\n\r\n    \r\nfor cantilever in detected_cantilevers:\r\n    cantilever_geom = cantilever[\"CantileverGeometry\"]\r\n    ground_walls = floor_footprints_by_level[ground_floor_z]\r\n\r\n    if cantilever_geom.geom_type == 'Polygon':\r\n        polys = [cantilever_geom]\r\n    elif cantilever_geom.geom_type == 'MultiPolygon':\r\n        polys = list(cantilever_geom.geoms)\r\n    else:\r\n        continue\r\n\r\n    for poly in polys:\r\n        coords = list(poly.exterior.coords)\r\n\r\n        for i in range(len(coords) - 1):\r\n            pt1, pt2 = coords[i], coords[i+1]\r\n            edge = LineString([pt1, pt2])\r\n\r\n            # If this edge touches any wall from the ground floor\r\n            for wall in ground_walls:\r\n                if wall.buffer(0.05).intersects(edge):\r\n                    # Force columns at both endpoints of the edge (i.e., the corners)\r\n                    forced_cantilever_corner_points.append(pt1)\r\n                    forced_cantilever_corner_points.append(pt2)\r\n                    break  # Only need one wall to validate the edge\r\n\r\n\r\n# --------------------------------------------------------------\r\n# ===== NO COLUMN ZONES =====\r\n# --------------------------------------------------------------\r\n\r\n\r\n# --- Identify \"No-Column\" Zones for Cantilevers (Ground to First Floor) ---\r\nif detected_cantilevers and len(sorted_floor_z_levels) >= 2:\r\n    ground_floor_z = sorted_floor_z_levels[0]\r\n    combined_ground_floor_footprint = unary_union(floor_footprints_by_level.get(ground_floor_z, []))\r\n\r\n    if not combined_ground_floor_footprint.is_empty:\r\n        print(\"\\n--- Identifying Cantilever 'No-Column' Zones ---\")\r\n        for cantilever_info in detected_cantilevers:\r\n            cantilever_geom = cantilever_info['CantileverGeometry']\r\n            \r\n            # The perimeter of the cantilever geometry\r\n            cantilever_perimeter = cantilever_geom.exterior if cantilever_geom.geom_type == 'Polygon' else unary_union([g.exterior for g in cantilever_geom.geoms if g.geom_type == 'Polygon'])\r\n\r\n            if cantilever_perimeter.is_empty:\r\n                continue\r\n\r\n            # The part of the cantilever perimeter that does NOT touch the ground floor footprint\r\n            exposed_perimeter_candidate = cantilever_perimeter.difference(combined_ground_floor_footprint.buffer(CANTILEVER_CHECK_BUFFER))\r\n\r\n            # Filter out small artifacts and keep only LineString or MultiLineString components\r\n            no_column_lines = []\r\n            if exposed_perimeter_candidate.geom_type == 'LineString':\r\n                if exposed_perimeter_candidate.length > 0.1: # Only consider significant lengths\r\n                    no_column_lines.append(exposed_perimeter_candidate)\r\n            elif exposed_perimeter_candidate.geom_type == 'MultiLineString':\r\n                for line in exposed_perimeter_candidate.geoms:\r\n                    if line.length > 0.1:\r\n                        no_column_lines.append(line)\r\n            elif exposed_perimeter_candidate.geom_type == 'Polygon': # Should ideally not be a polygon unless a very thin part\r\n                if exposed_perimeter_candidate.area > 0.01: # Small area threshold\r\n                    no_column_lines.append(exposed_perimeter_candidate.exterior) # Use its exterior as the line\r\n\r\n            for line in no_column_lines:\r\n                # Create a thin rectangular zone along this line\r\n                try:\r\n                    no_column_zone = line.buffer(CANTILEVER_CHECK_BUFFER, cap_style=3) # cap_style=3 for square ends\r\n                    cantilever_no_column_zones_ground_to_first.append(no_column_zone)\r\n                except Exception as e:\r\n                    print(f\"Warning: Could not create no-column zone from line. Error: {e}\")\r\n        \r\n        # Combine all no-column zones into a single MultiPolygon for efficient checking\r\n        if cantilever_no_column_zones_ground_to_first:\r\n            cantilever_no_column_zones_ground_to_first_combined = unary_union(cantilever_no_column_zones_ground_to_first)\r\n            print(f\"  Combined {len(cantilever_no_column_zones_ground_to_first)} no-column zones.\")\r\n        else:\r\n            cantilever_no_column_zones_ground_to_first_combined = None\r\n            print(\"  No significant cantilever no-column zones identified.\")\r\n    else:\r\n        cantilever_no_column_zones_ground_to_first_combined = None\r\n        print(\"  Ground floor footprint is empty, cannot define cantilever no-column zones.\")\r\nelse:\r\n    cantilever_no_column_zones_ground_to_first_combined = None\r\n    print(\"  No detected cantilevers or not enough floor levels to define no-column zones.\")\r\n\r\n# --------------------------------------------------------------\r\n# ===== COLUMN PLACEMENT =====\r\n# --------------------------------------------------------------\r\n\r\n# Structural logic\r\nMaxS = 6.0\r\nMinS = 3.0\r\n\r\ncolumns_2d_points = [] # Store raw (x,y) points for columns\r\nbeams_2d_lines = []    # Store raw ((x1,y1),(x2,y2)) for beams for 2D plot\r\n\r\nadded_column_xy = set()\r\ncolumns_to_skip_ground_to_first_span = set()\r\n\r\n# Find and print roofs that are peaks (taller than all directly touching roofs)\r\nprint(\"\\n--- Analyzing Roof Heights ---\")\r\n\r\n\r\n# --------------------------------------------------------------\r\n# ===== DOMINANT ROOFS =====\r\n# --------------------------------------------------------------\r\n\r\nINTERSECTION_BUFFER_ROOF = 0.1\r\n\r\ndominant_roofs_identified = []\r\n\r\nfor i, (roof1_id, roof1_bbox, roof1_poly_2d) in enumerate(roof_meshes_info):\r\n    roof1_max_z = roof1_bbox.Max.Z\r\n    is_dominant_roof = True\r\n    touching_lower_neighbors = []\r\n    touching_equal_or_higher_neighbors = []\r\n\r\n    for j, (roof2_id, roof2_bbox, roof2_poly_2d) in enumerate(roof_meshes_info):\r\n        if i == j:\r\n            continue\r\n\r\n        roof2_max_z = roof2_bbox.Max.Z\r\n\r\n        intersection_geometry = roof1_poly_2d.buffer(INTERSECTION_BUFFER_ROOF).intersection(roof2_poly_2d.buffer(INTERSECTION_BUFFER_ROOF))\r\n        \r\n        is_touching = not intersection_geometry.is_empty and \\\r\n                      intersection_geometry.geom_type in ['LineString', 'MultiLineString', 'Polygon', 'MultiPolygon']\r\n        \r\n        if is_touching:\r\n            if roof1_max_z <= roof2_max_z + 1e-6:\r\n                is_dominant_roof = False\r\n                touching_equal_or_higher_neighbors.append({\"Id\": str(roof2_id), \"Height\": round(roof2_max_z, 3)})\r\n            else:\r\n                touching_lower_neighbors.append({\"Id\": str(roof2_id), \"Height\": round(roof2_max_z, 3)})\r\n        \r\n    if is_dominant_roof and (touching_lower_neighbors or touching_equal_or_higher_neighbors):\r\n        dominant_roofs_identified.append({\r\n            \"RhinoObjectId\": str(roof1_id),\r\n            \"Height\": round(roof1_max_z, 3),\r\n            \"Location_Min_X\": round(roof1_bbox.Min.X, 3),\r\n            \"Location_Min_Y\": round(roof1_bbox.Min.Y, 3),\r\n            \"Polygon\": roof1_poly_2d,\r\n            \"TouchingLowerNeighbors\": touching_lower_neighbors,\r\n            \"TouchingEqualOrHigherNeighbors\": touching_equal_or_higher_neighbors\r\n        })\r\n\r\nif dominant_roofs_identified:\r\n    print(\"\\nRoofs identified as strictly taller than all their directly touching neighbors:\")\r\n    for roof_info in dominant_roofs_identified:\r\n        if not roof_info['TouchingEqualOrHigherNeighbors']:\r\n            print(f\"  Roof ID: {roof_info['RhinoObjectId']} (Height: {roof_info['Height']}m)\")\r\n            print(f\"    Location (Min XY): ({roof_info['Location_Min_X']}, {roof_info['Location_Min_Y']})\")\r\n            if roof_info['TouchingLowerNeighbors']:\r\n                neighbor_details = \", \".join([f\"ID: {n['Id']} (H: {n['Height']}m)\" for n in roof_info['TouchingLowerNeighbors']])\r\n                print(f\"    Touching Lower Neighbors: {neighbor_details}\")\r\n            else:\r\n                print(f\"    No directly touching lower neighbors found (might be isolated or higher than implied).\")\r\nelse:\r\n    print(\"\\nNo roofs found that are strictly taller than all their directly touching neighbors.\")\r\n\r\n# --------------------------------------------------------------\r\n# ===== PERIMETER LINE =====\r\n# --------------------------------------------------------------\r\nwhile True:\r\n    try:\r\n        wall_thickness = 0.3\r\n        if wall_thickness <= 0:\r\n            raise ValueError\r\n        break\r\n    except ValueError:\r\n        print(\"Please enter a valid positive number for wall thickness.\")\r\n\r\ncombined_building_polygon = MultiPolygon(building_floor_footprints)\r\n\r\ntry:\r\n    exterior_perimeter = combined_building_polygon.buffer(wall_thickness, join_style=1)\r\nexcept Exception as e:\r\n    print(f\"Could not buffer the building outline. Error: {e}\")\r\n    exterior_perimeter = None\r\n\r\nif exterior_perimeter and exterior_perimeter.geom_type == 'MultiPolygon':\r\n    exterior_perimeter = max(exterior_perimeter.geoms, key=lambda p: p.area)\r\n\r\nperimeter_line_coords = []\r\nif exterior_perimeter:\r\n    if exterior_perimeter.geom_type == 'Polygon':\r\n        perimeter_line_coords = list(exterior_perimeter.exterior.coords)\r\n    elif exterior_perimeter.geom_type == 'MultiPolygon':\r\n        perimeter_line_coords = list(exterior_perimeter.geoms[0].exterior.coords)\r\n    else:\r\n        print(\"Warning: The buffered perimeter is not a Polygon or MultiPolygon. Cannot extract line coordinates.\")\r\n\r\n# Force columns at the corners of dominant roof footprints\r\nprint(\"\\n--- Forcing columns at dominant roof corners ---\")\r\nfor roof_info in dominant_roofs_identified:\r\n    if not roof_info['TouchingEqualOrHigherNeighbors']:\r\n        poly_2d = roof_info['Polygon']\r\n        minx, miny, maxx, maxy = poly_2d.bounds\r\n        corners_to_force = [\r\n            (minx, miny),\r\n            (maxx, miny),\r\n            (maxx, maxy),\r\n            (minx, maxy)\r\n        ]\r\n        for cx, cy in corners_to_force:\r\n            rounded_cx = round(cx, 5)\r\n            rounded_cy = round(cy, 5)\r\n            if (rounded_cx, rounded_cy) not in added_column_xy:\r\n                columns_2d_points.append((rounded_cx, rounded_cy))\r\n                added_column_xy.add((rounded_cx, rounded_cy))\r\n                print(f\"  Forced column at dominant roof corner: ({rounded_cx}, {rounded_cy})\")\r\n\r\n# Iterate through detected rooms/floor footprints\r\nfor approx_z, floor_polygons in floor_footprints_by_level.items():\r\n    current_floor_z = approx_z # Get the Z-level for the current set of polygons\r\n\r\n    for room_poly in floor_polygons: # Iterate through individual room polygons on this floor\r\n        minx, miny, maxx, maxy = room_poly.bounds\r\n        width, height = maxx - minx, maxy - miny\r\n        \r\n        divisions_x = max(1, int(np.ceil(width / MaxS)))\r\n        divisions_y = max(1, int(np.ceil(height / MaxS)))\r\n        \r\n        x_points_grid = np.linspace(minx, maxx, divisions_x + 1)\r\n        y_points_grid = np.linspace(miny, maxy, divisions_y + 1)\r\n        \r\n        # Add interior grid columns (this part is fine, columns go to ground unless skipped)\r\n        for x in x_points_grid:\r\n            for y in y_points_grid:\r\n                col_pt = Point(x, y)\r\n                rounded_x = round(x, 5)\r\n                rounded_y = round(y, 5)\r\n                \r\n                if room_poly.contains(col_pt) or room_poly.buffer(1e-6).contains(col_pt):\r\n                    if (rounded_x, rounded_y) not in added_column_xy:\r\n                        if all(np.linalg.norm(np.array((rounded_x, rounded_y)) - np.array(exist_col_xy)) >= MinS for exist_col_xy in added_column_xy):\r\n                            columns_2d_points.append((rounded_x, rounded_y))\r\n                            added_column_xy.add((rounded_x, rounded_y))\r\n\r\n                    # Check for cantilever no-column zones for the vertical span\r\n                    if cantilever_no_column_zones_ground_to_first_combined:\r\n                        if cantilever_no_column_zones_ground_to_first_combined.intersects(col_pt.buffer(CANTILEVER_CHECK_BUFFER)):\r\n                            columns_to_skip_ground_to_first_span.add((rounded_x, rounded_y))\r\n\r\n        # Add columns at corners of the room polygon (this part is fine)\r\n        for corner_x, corner_y in room_poly.exterior.coords:\r\n            corner_pt_shapely = Point(corner_x, corner_y)\r\n            rounded_corner_x = round(corner_x, 5)\r\n            rounded_corner_y = round(corner_y, 5)\r\n            \r\n            if (rounded_corner_x, rounded_corner_y) not in added_column_xy:\r\n                if all(np.linalg.norm(np.array((corner_x, corner_y)) - np.array(exist_col_xy)) >= MinS * 0.5 for exist_col_xy in added_column_xy):\r\n                    columns_2d_points.append((rounded_corner_x, rounded_corner_y))\r\n                    added_column_xy.add((rounded_corner_x, rounded_corner_y))\r\n            \r\n            # Check for cantilever no-column zones for the vertical span\r\n            if cantilever_no_column_zones_ground_to_first_combined:\r\n                if cantilever_no_column_zones_ground_to_first_combined.intersects(corner_pt_shapely.buffer(CANTILEVER_CHECK_BUFFER)):\r\n                    columns_to_skip_ground_to_first_span.add((rounded_corner_x, rounded_corner_y))\r\n\r\n        # IMPORTANT: NEW BEAM GENERATION LOGIC - APPLY CONDITION HERE\r\n        if abs(current_floor_z - ground_floor_z) > 1e-4: # Or 1e-5, depending on precision needed            # Horizontal beams\r\n            for y_fixed in y_points_grid:\r\n                points_on_line = []\r\n                for x_coord in x_points_grid:\r\n                    p = Point(x_coord, y_fixed)\r\n                    if room_poly.buffer(1e-6).contains(p):\r\n                        points_on_line.append((x_coord, y_fixed))\r\n                \r\n                if len(points_on_line) > 1:\r\n                    for i in range(len(points_on_line) - 1):\r\n                        beams_2d_lines.append((points_on_line[i], points_on_line[i+1]))\r\n\r\n            # Vertical beams\r\n            for x_fixed in x_points_grid:\r\n                points_on_line = []\r\n                for y_coord in y_points_grid:\r\n                    p = Point(x_fixed, y_coord)\r\n                    if room_poly.buffer(1e-6).contains(p):\r\n                        points_on_line.append((x_fixed, y_coord))\r\n                \r\n                if len(points_on_line) > 1:\r\n                    for i in range(len(points_on_line) - 1):\r\n                        beams_2d_lines.append((points_on_line[i], points_on_line[i+1]))\r\n\r\n\r\n# Combine all base columns\r\nall_base_columns = list(added_column_xy)\r\n\r\n# --- Utility function for wall height ---\r\ndef get_wall_height(x, y, mesh_bboxes, global_max_z):\r\n    pt = Point(x, y)\r\n    relevant_bboxes = []\r\n    for bbox in mesh_bboxes:\r\n        bbox_poly = Polygon([\r\n            [bbox.Min.X, bbox.Min.Y],\r\n            [bbox.Max.X, bbox.Min.Y],\r\n            [bbox.Max.X, bbox.Max.Y],\r\n            [bbox.Min.X, bbox.Max.Y],\r\n            [bbox.Min.X, bbox.Min.Y]\r\n        ])\r\n        if bbox_poly.buffer(1e-4).contains(pt):\r\n            relevant_bboxes.append(bbox)\r\n\r\n    if not relevant_bboxes:\r\n        return global_max_z \r\n\r\n    max_relevant_z = 0.0\r\n    for bbox in relevant_bboxes:\r\n        max_relevant_z = max(max_relevant_z, bbox.Max.Z)\r\n        \r\n    return max_relevant_z if max_relevant_z > 0 else global_max_z\r\n# --------------------------------------------------------------\r\n# --- DATA GENERATION AND CSV/JSON EXPORT ---\r\n# --------------------------------------------------------------\r\n\r\nprint(\"--- Generating data and Exporting CSVs & JSONs ---\")\r\n\r\nEXPORT_SAVE_PATH = os.path.join(os.path.dirname(os.path.abspath(glb_file_path)), \"structural_data\") # Dynamically set export path\r\n\r\nos.makedirs(EXPORT_SAVE_PATH, exist_ok=True)\r\nprint(f\"Ensuring directory exists: {os.path.abspath(EXPORT_SAVE_PATH)}\")\r\n\r\ncolumn_lines = []\r\nbeam_lines = []\r\nfloor_height = 2.5  # Ideal floor height reference\r\n\r\nfor fx, fy in forced_cantilever_corner_points:\r\n    rounded_fx = round(fx, 5)\r\n    rounded_fy = round(fy, 5)\r\n    if (rounded_fx, rounded_fy) not in added_column_xy:\r\n        columns_2d_points.append((rounded_fx, rounded_fy))\r\n        added_column_xy.add((rounded_fx, rounded_fy))\r\n        print(f\"ðŸ”µ Forced column at cantilever corner touching ground wall: ({rounded_fx}, {rounded_fy})\")\r\n\r\n\r\nnode_coords = []\r\nnode_dict = OrderedDict()\r\n\r\ndef add_node(pt):\r\n    key = tuple(np.round(pt, 5))\r\n    if key not in node_dict:\r\n        node_id = f\"N{len(node_dict)}\"\r\n        node_dict[key] = node_id\r\n        node_coords.append([node_id] + list(key))\r\n    return node_dict[key]\r\n\r\n# --------------------------------------------------------------\r\n# ===== CORRECT FLOOR SEGMENTATION =====\r\n# --------------------------------------------------------------\r\n\r\nfor x, y in all_base_columns:\r\n    local_height = get_wall_height(x, y, all_mesh_bboxes, max_z)\r\n    skip_ground_to_first = (round(x, 5), round(y, 5)) in columns_to_skip_ground_to_first_span\r\n\r\n    num_floors = max(1, int(round(local_height / floor_height)))\r\n    actual_floor_height = local_height / num_floors\r\n    z_levels = [round(i * actual_floor_height, 5) for i in range(num_floors + 1)]\r\n\r\n    for i in range(len(z_levels) - 1):\r\n        start_z = z_levels[i]\r\n        end_z = z_levels[i + 1]\r\n        if skip_ground_to_first and abs(start_z) < 1e-4:\r\n            continue\r\n\r\n        id1 = add_node((x, y, start_z))\r\n        id2 = add_node((x, y, end_z))\r\n        column_lines.append((id1, id2))\r\n\r\nunique_beam_tuples_3d = set()\r\nbeam_lines = []\r\n\r\nfor (x1, y1), (x2, y2) in beams_2d_lines:\r\n    mid_x, mid_y = (x1 + x2) / 2, (y1 + y2) / 2\r\n    local_height = get_wall_height(mid_x, mid_y, all_mesh_bboxes, max_z)\r\n\r\n    num_floors = max(1, int(round(local_height / floor_height)))\r\n    actual_floor_height = local_height / num_floors\r\n    z_levels = [round(i * actual_floor_height, 5) for i in range(1, num_floors + 1)]\r\n\r\n    skip1 = (round(x1, 5), round(y1, 5)) in columns_to_skip_ground_to_first_span\r\n    skip2 = (round(x2, 5), round(y2, 5)) in columns_to_skip_ground_to_first_span\r\n\r\n    for z in z_levels:\r\n        if abs(z) < 1e-4:  # â¬…ï¸ THIS LINE SKIPS GROUND LEVEL BEAMS\r\n            continue\r\n        if abs(z) < 1e-4 and (skip1 or skip2):\r\n            continue\r\n\r\n        id1 = add_node((x1, y1, z))\r\n        id2 = add_node((x2, y2, z))\r\n        ordered_nodes = tuple(sorted((id1, id2)))\r\n        if ordered_nodes not in unique_beam_tuples_3d:\r\n            unique_beam_tuples_3d.add(ordered_nodes)\r\n            beam_lines.append((id1, id2))\r\n\r\n\r\n# --------------------------------------------------------------\r\n# ===== EXPORT CSV AND JSON =====\r\n# --------------------------------------------------------------\r\n\r\n# --------------------------------------------------------------\r\n# --- DATA GENERATION AND JSON-ONLY EXPORT ---\r\n# --------------------------------------------------------------\r\n\r\nprint(\"--- Generating data and exporting JSONs only ---\")\r\nEXPORT_SAVE_PATH = os.path.join(os.path.dirname(os.path.abspath(glb_file_path)), \"structural_data\")\r\nos.makedirs(EXPORT_SAVE_PATH, exist_ok=True)\r\nprint(f\"Ensuring directory exists: {os.path.abspath(EXPORT_SAVE_PATH)}\")\r\n\r\n# --- Export nodes.json only ---\r\nnodes_json_path = os.path.join(EXPORT_SAVE_PATH, \"nodes.json\")\r\nnodes_json_data = [\r\n    {\"ID\": n[0], \"X\": n[1], \"Y\": n[2], \"Z\": n[3]}\r\n    for n in node_coords\r\n]\r\nwith open(nodes_json_path, \"w\") as f:\r\n    json.dump(nodes_json_data, f, indent=4)\r\nprint(f\"âœ… nodes.json written to {nodes_json_path}\")\r\n\r\n# --- Export columns.json only ---\r\ncolumns_json_path = os.path.join(EXPORT_SAVE_PATH, \"columns.json\")\r\ncolumns_json_data = []\r\nfor i, (i_node_id, j_node_id) in enumerate(column_lines):\r\n    A = next(item for item in nodes_json_data if item[\"ID\"] == i_node_id)\r\n    B = next(item for item in nodes_json_data if item[\"ID\"] == j_node_id)\r\n    length = round(np.linalg.norm(\r\n        (B[\"X\"]-A[\"X\"], B[\"Y\"]-A[\"Y\"], B[\"Z\"]-A[\"Z\"])\r\n    ), 3)\r\n    columns_json_data.append({\r\n        \"ID\": f\"C{i}\",\r\n        \"i_node\": i_node_id,\r\n        \"j_node\": j_node_id,\r\n        \"length\": length\r\n    })\r\nwith open(columns_json_path, \"w\") as f:\r\n    json.dump(columns_json_data, f, indent=4)\r\nprint(f\"âœ… columns.json written to {columns_json_path}\")\r\n\r\n# --- Export beams.json only ---\r\nbeams_json_path = os.path.join(EXPORT_SAVE_PATH, \"beams.json\")\r\nbeams_json_data = []\r\nfor i, (i_node_id, j_node_id) in enumerate(beam_lines):\r\n    A = next(item for item in nodes_json_data if item[\"ID\"] == i_node_id)\r\n    B = next(item for item in nodes_json_data if item[\"ID\"] == j_node_id)\r\n    length = round(np.linalg.norm(\r\n        (B[\"X\"]-A[\"X\"], B[\"Y\"]-A[\"Y\"], B[\"Z\"]-A[\"Z\"])\r\n    ), 3)\r\n    beams_json_data.append({\r\n        \"ID\": f\"B{i}\",\r\n        \"i_node\": i_node_id,\r\n        \"j_node\": j_node_id,\r\n        \"length\": length\r\n    })\r\nwith open(beams_json_path, \"w\") as f:\r\n    json.dump(beams_json_data, f, indent=4)\r\nprint(f\"âœ… beams.json written to {beams_json_path}\")\r\n\r\n\r\n\r\n# --- Combine JSON files into combinedjson.json ---\r\ncombined_json_path = os.path.join(EXPORT_SAVE_PATH, \"combinedjson.json\")\r\n\r\n# Load individual JSON files\r\nwith open(nodes_json_path, 'r') as f:\r\n    nodes_data = json.load(f)\r\n\r\nwith open(columns_json_path, 'r') as f:\r\n    columns_data = json.load(f)\r\n\r\nwith open(beams_json_path, 'r') as f:\r\n    beams_data = json.load(f)\r\n\r\n# Combine into one dictionary\r\ncombined_data = {\r\n    \"nodes\": nodes_data,\r\n    \"columns\": columns_data,\r\n    \"beams\": beams_data\r\n}\r\n\r\n# Write to combined JSON file\r\nwith open(combined_json_path, 'w') as f:\r\n    json.dump(combined_data, f, indent=4)\r\n\r\nprint(f\"âœ… combinedjson.json written to {combined_json_path}\")\r\n\r\n\r\n\r\n# --------------------------------------\r\n# Correct Json Viewer - Now uses the dynamically generated 3DM file and CSV paths\r\n# --------------------------------------\r\n\r\n\r\ntry:\r\n    with open(nodes_json_path, 'r') as f:\r\n        nodes = json.load(f)\r\n    df_nodes_loaded   = pd.DataFrame(nodes)\r\n\r\n    with open(columns_json_path, 'r') as f:\r\n        cols = json.load(f)\r\n    df_columns_loaded = pd.DataFrame(cols)\r\n\r\n    with open(beams_json_path, 'r') as f:\r\n        bms = json.load(f)\r\n    df_beams_loaded   = pd.DataFrame(bms)\r\n\r\n    print(\"âœ… JSON files loaded successfully for update process.\")\r\nexcept FileNotFoundError:\r\n    print(\"Error: Make sure 'nodes.json', 'columns.json', and 'beams.json' are in the specified path.\")\r\n    exit()\r\n\r\n\r\nif not os.path.exists(rhino_path):\r\n    print(f\"Error: Rhino file not found at {rhino_path}. Cannot identify peak roofs for re-processing.\")\r\n    exit()\r\n\r\nmodel = rhino3dm.File3dm.Read(rhino_path)\r\n\r\n# Generate 3D visualization\r\nimport plotly.graph_objects as go # Added this import\r\n\r\nfig_3d = go.Figure()\r\n\r\n# Add columns\r\nfor index, row in df_columns_loaded.iterrows():\r\n    n1_coords = df_nodes_loaded[df_nodes_loaded['ID'] == row['i_node']][['X', 'Y', 'Z']].values[0]\r\n    n2_coords = df_nodes_loaded[df_nodes_loaded['ID'] == row['j_node']][['X', 'Y', 'Z']].values[0]\r\n    fig_3d.add_trace(go.Scatter3d(\r\n        x=[n1_coords[0], n2_coords[0]],\r\n        y=[n1_coords[1], n2_coords[1]],\r\n        z=[n1_coords[2], n2_coords[2]],\r\n        mode='lines',\r\n        line=dict(color='blue', width=5),\r\n        name=f'Column {row[\"ID\"]}',\r\n        hoverinfo='text',\r\n        text=f'Column: {row[\"ID\"]}<br>Length: {row[\"length\"]:.2f}m'\r\n    ))\r\n\r\n# Add beams\r\nfor index, row in df_beams_loaded.iterrows():\r\n    n1_coords = df_nodes_loaded[df_nodes_loaded['ID'] == row['i_node']][['X', 'Y', 'Z']].values[0]\r\n    n2_coords = df_nodes_loaded[df_nodes_loaded['ID'] == row['j_node']][['X', 'Y', 'Z']].values[0]\r\n    \r\n    line_color = 'green'\r\n    line_width = 3\r\n\r\n    fig_3d.add_trace(go.Scatter3d(\r\n        x=[n1_coords[0], n2_coords[0]],\r\n        y=[n1_coords[1], n2_coords[1]],\r\n        z=[n1_coords[2], n2_coords[2]],\r\n        mode='lines',\r\n        line=dict(color=line_color, width=line_width),\r\n        name=f'Beam {row[\"ID\"]}',\r\n        hoverinfo='text',\r\n        text=f'Beam: {row[\"ID\"]}<br>Length: {row[\"length\"]:.2f}m'\r\n    ))\r\n\r\n# Add nodes as markers\r\nfig_3d.add_trace(go.Scatter3d(\r\n    x=df_nodes_loaded['X'],\r\n    y=df_nodes_loaded['Y'],\r\n    z=df_nodes_loaded['Z'],\r\n    mode='markers',\r\n    marker=dict(size=4, color='black'),\r\n    name='Nodes',\r\n    hoverinfo='text',\r\n    text=df_nodes_loaded['ID']\r\n))\r\n\r\n# Update layout for better visualization\r\nfig_3d.update_layout(\r\n    title='3D Structural Model with Columns (Blue), Beams (Green), and Peak Roof Beams (Red)',\r\n    scene=dict(\r\n        xaxis_title='X',\r\n        yaxis_title='Y',\r\n        zaxis_title='Z',\r\n        aspectmode='data' # Ensure uniform scaling\r\n    ),\r\n    height=800\r\n)\r\n\r\nfig_3d.show()\r\n\r\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n# Pynite FEM Analysis\r\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nfrom Pynite.Visualization import Renderer\r\nfrom Pynite.FEModel3D import FEModel3D\r\n\r\n# 1) INITIALIZE MODEL\r\nmodel = FEModel3D()\r\n\r\n# 2) ADD NODES (convert m â†’ in)\r\nUNIT_CONVERSION = 39.37  # meters to inches\r\nfor _, row in df_nodes_loaded.iterrows():\r\n    nid = str(row['ID'])\r\n    model.add_node(\r\n        nid,\r\n        row['X'] * UNIT_CONVERSION,\r\n        row['Y'] * UNIT_CONVERSION,\r\n        row['Z'] * UNIT_CONVERSION\r\n    )\r\n\r\n# 3) MATERIAL & SECTION\r\nf_c   = 4.0                          # ksi\r\nE_c   = 57000 * (f_c ** 0.5)         # ksi\r\nG_c   = E_c / (2 * (1 + 0.2))        # ksi\r\nrho_c = (150 / 1728) * 1e-3          # kip/in^3\r\nmodel.add_material('RCC', E_c, G_c, f_c, rho_c)\r\n\r\nA, Iy, Iz, J = 8.84, 49.0, 14.4, 0.95\r\nmodel.add_section('W14X30', A, Iy, Iz, J)\r\n\r\n# 4) ADD MEMBERS\r\nfor _, row in df_beams_loaded.iterrows():\r\n    bid = str(row['ID'])\r\n    model.add_member(bid,\r\n                     str(row['i_node']),\r\n                     str(row['j_node']),\r\n                     'RCC', 'W14X30')\r\n\r\nfor _, row in df_columns_loaded.iterrows():\r\n    cid = str(row['ID'])\r\n    model.add_member(cid,\r\n                     str(row['i_node']),\r\n                     str(row['j_node']),\r\n                     'RCC', 'W14X30')\r\n\r\n# 5) SUPPORTS (fixed at Z=0)\r\nfor _, row in df_nodes_loaded.iterrows():\r\n    fixed = (row['Z'] == 0)\r\n    model.def_support(\r\n        str(row['ID']),\r\n        fixed, fixed, fixed,  # Tx,Ty,Tz  \r\n        fixed, fixed, fixed   # Rx,Ry,Rz\r\n    )\r\n\r\n# 6) MEMBER LENGTHS lookup\r\nimport numpy as np\r\nbeam_lengths = {}\r\ncolumn_lengths = {}\r\n\r\nfor _, row in df_beams_loaded.iterrows():\r\n    mid = str(row['ID'])\r\n    iN, jN = str(row['i_node']), str(row['j_node'])\r\n    xi, yi, zi = model.nodes[iN].X, model.nodes[iN].Y, model.nodes[iN].Z\r\n    xj, yj, zj = model.nodes[jN].X, model.nodes[jN].Y, model.nodes[jN].Z\r\n    beam_lengths[mid] = float(np.sqrt((xj-xi)**2 + (yj-yi)**2 + (zj-zi)**2))\r\n\r\nfor _, row in df_columns_loaded.iterrows():\r\n    mid = str(row['ID'])\r\n    iN, jN = str(row['i_node']), str(row['j_node'])\r\n    xi, yi, zi = model.nodes[iN].X, model.nodes[iN].Y, model.nodes[iN].Z\r\n    xj, yj, zj = model.nodes[jN].X, model.nodes[jN].Y, model.nodes[jN].Z\r\n    column_lengths[mid] = float(np.sqrt((xj-xi)**2 + (yj-yi)**2 + (zj-zi)**2))\r\n\r\n# 7) DISTRIBUTED LOADS\r\nlength_lookup = {**beam_lengths, **column_lengths}\r\nfor mid in model.members:\r\n    L = length_lookup[mid]\r\n    if mid in beam_lengths:\r\n        w_DL, w_LL = -0.02, -0.015\r\n    else:\r\n        w_DL, w_LL = -0.01, -0.008\r\n    model.add_member_dist_load(mid, 'FZ', w_DL, w_LL, 0, L, case='DL')\r\n    model.add_member_dist_load(mid, 'FZ', w_LL, w_LL, 0, L, case='LL')\r\n\r\n# 8) LOAD COMBINATIONS\r\nmodel.add_load_combo('0.9DL+1.0W', factors={'DL': 1.2, 'W': 1.0})\r\nmodel.add_load_combo('1.2DL+1.0W', factors={'DL': 0.9, 'W': 1.0})\r\n\r\n# 9) ANALYZE\r\nmodel.analyze()\r\n\r\n# 10) DEFORMED SHAPE\r\nrndr = Renderer(model)\r\nrndr.deformed_shape = True\r\nrndr.deformed_scale = 50\r\nrndr.combo_name     = '1.2DL+1.0W'\r\nrndr.show_loads     = True\r\nrndr.show_reactions = True\r\nrndr.window_width   = 750\r\nrndr.window_height  = 750\r\nrndr.render_model()\r\n\r\n# 11) SLENDERNESS CHECKS\r\nprint(\"\\nCOLUMN SLENDERNESS (L/r):\")\r\nsec = model.sections['W14X30']\r\nr_y = np.sqrt(sec.Iy / sec.A)\r\nr_z = np.sqrt(sec.Iz / sec.A)\r\nr   = min(r_y, r_z)\r\nfor _, row in df_columns_loaded.iterrows():\r\n    cid = str(row['ID'])\r\n    L   = column_lengths[cid]\r\n    sl  = L / r\r\n    ok  = \"PASS\" if sl <= 200 else \"FAIL\"\r\n    print(f\"  Col {cid}: L/r={sl:.1f} ({ok})\")\r\n\r\nprint(\"\\nBEAM SLENDERNESS (L/r):\")\r\nfor _, row in df_beams_loaded.iterrows():\r\n    bid = str(row['ID'])\r\n    L   = beam_lengths[bid]\r\n    sl  = L / r\r\n    ok  = \"PASS\" if sl <= 300 else \"FAIL\"\r\n    print(f\"  Beam {bid}: L/r={sl:.1f} ({ok})\")\r\n\r\n# 12) STIFFNESS & DISPLACEMENTS\r\nK = model.K(combo_name='1.2DL+1.0W', log=True, check_stability=True, sparse=True).toarray()\r\nprint(f\"\\nGlobal K matrix ({K.shape[0]}Ã—{K.shape[1]}):\")\r\nlabels = [f\"{nid}_{dof}\" for nid in model.nodes for dof in ('DX','DY','DZ','RX','RY','RZ')]\r\nimport pandas as pd\r\nK_df = pd.DataFrame(K, index=labels, columns=labels)\r\nprint(K_df)\r\n\r\nprint(\"\\nNODAL DISPLACEMENTS:\")\r\nfor nid, node in model.nodes.items():\r\n    dx = node.DX.get('1.2DL+1.0W', 0.0)\r\n    dy = node.DY.get('1.2DL+1.0W', 0.0)\r\n    dz = node.DZ.get('1.2DL+1.0W', 0.0)\r\n    print(f\"  {nid}: DX={dx:.6e} in, DY={dy:.6e} in, DZ={dz:.6e} in\")\r\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}