{
  "source_url": "https://github.com/fesmcr/Grafit/blob/0b80fd011af1d84bb50d5cafb684feb331ec3435/examples/rhino/Python%20F2.1%20Primal%20Directed%20Graph.py",
  "repo": "fesmcr/Grafit",
  "repo_stars": 1,
  "repo_description": null,
  "license": "MIT",
  "filepath": "examples/rhino/Python F2.1 Primal Directed Graph.py",
  "instruction": "Python f2.1 primal directed graph",
  "code": "ï»¿import rhinoscriptsyntax as rs\nimport Rhino.Geometry as rg\nimport sys\nimport clr\n\nclr.AddReference(\"System.IO\")\n\nfrom System import Environment\nfrom System.IO import *\n\nif CustomLibPath is not None: \n\t# Check if the assembly is loaded\n\tif \"Grafit\" not in sys.modules: \n\t\tsearchResult = Directory.GetFiles(CustomLibPath, \"Grafit.dll\", SearchOption.AllDirectories)\n\n\t\tif len(searchResult) == 0:\n\t\t\traise Exception(\"Grafit.dll is not found in folder.\")\n\t\t\t\n\t\tLibPathGrafit = searchResult[0] \n\t\tLibPathGrafitRhino = Path.GetDirectoryName(LibPathGrafit) + \"\\\\\"  + \"GrafitRhino.dll\"   \n\t\n\t\tclr.AddReferenceToFileAndPath(LibPathGrafit)\n\t\tclr.AddReferenceToFileAndPath(LibPathGrafitRhino) \nelse:\n\tclr.AddReference(\"Grafit\") \n\tclr.AddReference(\"GrafitRhino\")\n\nfrom Grafit import *\nfrom GrafitRhino import *\nfrom System import Array\n\n# Positive infinity (similar to double.PositiveInfinity in C#)\ndouble_PositiveInfinity = float('inf')\n\n# Maximum finite positive value (similar to double.MaxValue in C#)\ndouble_MaxValue = sys.float_info.max\n\nprimalGraph = {} \n \n#Create Primal Graph\nlineGeometry = Array[CWLine](map(lambda s: CWLine(s), LineGeometry))\n\ngraphElements, edgeLengths = GeometryToGraphElements.GetNodesAndEdgesFromLines(lineGeometry)\n\nprimalGraph = CPrimalDirectedGraph(graphElements)\nprimalGraph.AddWeightMatrix(edgeLengths)    # index 0\nprimalGraph.AddEmptyWeightMatrix(double_MaxValue)          # index 1  \nprimalGraph.AddEmptyWeightMatrix(double_MaxValue)          # index 2  \n\nfor i in range(len(primalGraph.UndirectedEdges)):\n    n1 = primalGraph.UndirectedEdges[i][0]  # start node of edge #i\n    n2 = primalGraph.UndirectedEdges[i][1]  # end node of edge #i\n \n    \n\t\n    if EdgeWeightsForward[i] <= 0:\n        EdgeWeightsForward[i] = 0.00001\t\n    if EdgeWeightsBackward[i] <= 0:\n        EdgeWeightsBackward[i] = 0.00001\n    if EdgeWeightsForward2[i] <= 0:\n        EdgeWeightsForward2[i] = 0.00001\t\n    if EdgeWeightsBackward2[i] <= 0:\n        EdgeWeightsBackward2[i] = 0.00001\n\n    weight_matrix_id = 1\n    primalGraph.SetWeightMatrixAndEdgeValue(EdgeWeightsForward[i], n1, n2, weight_matrix_id)  # forward direction\n    primalGraph.SetWeightMatrixAndEdgeValue(EdgeWeightsBackward[i], n2, n1, weight_matrix_id)  # backward direction \n\n    weight_matrix_id = 2\n    primalGraph.SetWeightMatrixAndEdgeValue(EdgeWeightsForward2[i], n1, n2, weight_matrix_id)  # forward direction 2\n    primalGraph.SetWeightMatrixAndEdgeValue(EdgeWeightsBackward2[i], n2, n1, weight_matrix_id)  # backward direction 2 \n\nif UseFilterMatrix:\n  primalGraph.APShortestPathsByManyWeights(WeightMatrixIndexMain, WeightMatrixIndexFilter, GPU, 0.000001);\nelse:\n  primalGraph.APShortestPathsByOneWeight(WeightMatrixIndexMain, GPU,0.000001);\n \n# If graph has more than 1 weight matrix, calculate distances along shortest paths according to all other weights\nif CalculateAllMatrices:\n    # Select which weights are needed to measure shortest paths\n    # By default, all other matrices which are not the main are selected\n    allIds = list(range(primalGraph.WeightMatricesCount))\n    otherMatricesIds = [i for i in allIds if i != WeightMatrixIndexMain]\n    primalGraph.FillWeightMatrixBySPRestore(Array[int](otherMatricesIds), GPU)\n    \nPrimalDirGraph = primalGraph    \n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}