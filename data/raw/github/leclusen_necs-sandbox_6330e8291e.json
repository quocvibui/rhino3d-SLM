{
  "source_url": "https://github.com/leclusen/necs-sandbox/blob/8d8006ae3c845c9f3e38154803caac6b03d298a9/structure-batiment/structure_aligner/transform/dalle_consolidator.py",
  "repo": "leclusen/necs-sandbox",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "structure-batiment/structure_aligner/transform/dalle_consolidator.py",
  "instruction": "Dalle (slab) consolidation: create large planar Breps per floor.",
  "code": "\"\"\"Dalle (slab) consolidation: create large planar Breps per floor.\n\nPhase 5.1 - Replaces removed individual dalle panels with 1-3 large\nconsolidated slab surfaces per floor level.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom collections import defaultdict\nfrom dataclasses import dataclass\n\nimport rhino3dm\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass RemovedDalleInfo:\n    \"\"\"Footprint info from a removed dalle for consolidation.\"\"\"\n    name: str\n    x_min: float\n    x_max: float\n    y_min: float\n    y_max: float\n    z: float\n\n\ndef extract_dalle_info(\n    model: rhino3dm.File3dm,\n    dalle_names: set[str],\n) -> list[RemovedDalleInfo]:\n    \"\"\"Extract footprint info from dalle objects before removal.\n\n    Call this BEFORE removing dalles to capture their extents.\n    \"\"\"\n    info: list[RemovedDalleInfo] = []\n    for obj in model.Objects:\n        name = obj.Attributes.Name\n        if name not in dalle_names:\n            continue\n        geom = obj.Geometry\n        if not isinstance(geom, rhino3dm.Brep) or len(geom.Vertices) == 0:\n            continue\n        xs = [geom.Vertices[i].Location.X for i in range(len(geom.Vertices))]\n        ys = [geom.Vertices[i].Location.Y for i in range(len(geom.Vertices))]\n        zs = [geom.Vertices[i].Location.Z for i in range(len(geom.Vertices))]\n        z_avg = sum(zs) / len(zs)\n        info.append(RemovedDalleInfo(\n            name=name,\n            x_min=min(xs), x_max=max(xs),\n            y_min=min(ys), y_max=max(ys),\n            z=round(z_avg, 2),\n        ))\n    return info\n\n\ndef consolidate_dalles(\n    model: rhino3dm.File3dm,\n    removed_dalles: list[RemovedDalleInfo],\n    floor_z_levels: tuple[float, ...],\n    layer_index: int = 0,\n) -> int:\n    \"\"\"Create consolidated slab Breps per floor level.\n\n    Groups removed dalle footprints by Z-level, computes bounding\n    rectangles per structural zone, and creates single-face planar\n    Breps at each floor.\n\n    Args:\n        model: The rhino3dm model to add objects to.\n        removed_dalles: Footprint info from removed dalles.\n        floor_z_levels: Known floor Z-levels.\n        layer_index: Layer index for new objects.\n\n    Returns:\n        Number of consolidated dalle objects added.\n    \"\"\"\n    if not removed_dalles:\n        return 0\n\n    # Group by Z-level (match to nearest floor)\n    by_z: dict[float, list[RemovedDalleInfo]] = defaultdict(list)\n    for info in removed_dalles:\n        matched_z = _match_z(info.z, floor_z_levels)\n        by_z[matched_z].append(info)\n\n    added = 0\n    next_id = _get_max_coque_id(model) + 1\n\n    for z_level, dalles in sorted(by_z.items()):\n        # Compute overall bounding box\n        x_min = min(d.x_min for d in dalles)\n        x_max = max(d.x_max for d in dalles)\n        y_min = min(d.y_min for d in dalles)\n        y_max = max(d.y_max for d in dalles)\n\n        # Split into structural zones if the footprint is large\n        zones = _split_zones(dalles, x_min, x_max, y_min, y_max)\n\n        for zone_x_min, zone_x_max, zone_y_min, zone_y_max in zones:\n            brep = _create_planar_brep(\n                zone_x_min, zone_x_max, zone_y_min, zone_y_max, z_level\n            )\n            if brep is None:\n                continue\n\n            name = f\"Coque_{next_id}\"\n            next_id += 1\n\n            attr = rhino3dm.ObjectAttributes()\n            attr.Name = name\n            attr.LayerIndex = layer_index\n            model.Objects.AddBrep(brep, attr)\n            added += 1\n\n    logger.info(\"Dalle consolidation: %d consolidated slabs added\", added)\n    return added\n\n\ndef _match_z(z: float, floor_z_levels: tuple[float, ...], tol: float = 0.5) -> float:\n    \"\"\"Match Z to nearest floor level.\"\"\"\n    if not floor_z_levels:\n        return round(z, 2)\n    best = min(floor_z_levels, key=lambda fz: abs(z - fz))\n    if abs(z - best) <= tol:\n        return best\n    return round(z, 2)\n\n\ndef _split_zones(\n    dalles: list[RemovedDalleInfo],\n    x_min: float, x_max: float,\n    y_min: float, y_max: float,\n) -> list[tuple[float, float, float, float]]:\n    \"\"\"Split into structural zones based on dalle distribution.\n\n    Uses a simple approach: if the Y extent is large (>50m),\n    split at the largest Y-gap between dalle groups.\n    \"\"\"\n    x_range = x_max - x_min\n    y_range = y_max - y_min\n\n    if y_range < 50.0 and x_range < 100.0:\n        return [(x_min, x_max, y_min, y_max)]\n\n    # Find Y-gap to split\n    y_centers = sorted(set(round((d.y_min + d.y_max) / 2, 1) for d in dalles))\n    if len(y_centers) < 2:\n        return [(x_min, x_max, y_min, y_max)]\n\n    # Find largest gap\n    max_gap = 0.0\n    split_y = None\n    for i in range(len(y_centers) - 1):\n        gap = y_centers[i + 1] - y_centers[i]\n        if gap > max_gap:\n            max_gap = gap\n            split_y = (y_centers[i] + y_centers[i + 1]) / 2\n\n    if max_gap > 10.0 and split_y is not None:\n        zone_a = [d for d in dalles if (d.y_min + d.y_max) / 2 < split_y]\n        zone_b = [d for d in dalles if (d.y_min + d.y_max) / 2 >= split_y]\n        zones = []\n        if zone_a:\n            zones.append((\n                min(d.x_min for d in zone_a),\n                max(d.x_max for d in zone_a),\n                min(d.y_min for d in zone_a),\n                max(d.y_max for d in zone_a),\n            ))\n        if zone_b:\n            zones.append((\n                min(d.x_min for d in zone_b),\n                max(d.x_max for d in zone_b),\n                min(d.y_min for d in zone_b),\n                max(d.y_max for d in zone_b),\n            ))\n        return zones\n\n    return [(x_min, x_max, y_min, y_max)]\n\n\ndef _create_planar_brep(\n    x_min: float, x_max: float,\n    y_min: float, y_max: float,\n    z: float,\n) -> rhino3dm.Brep | None:\n    \"\"\"Create a single-face horizontal planar Brep at the given Z.\"\"\"\n    plane = rhino3dm.Plane(\n        rhino3dm.Point3d(0, 0, z),\n        rhino3dm.Vector3d(0, 0, 1),\n    )\n    srf = rhino3dm.PlaneSurface(\n        plane,\n        rhino3dm.Interval(x_min, x_max),\n        rhino3dm.Interval(y_min, y_max),\n    )\n    return rhino3dm.Brep.CreateFromSurface(srf)\n\n\ndef _get_max_coque_id(model: rhino3dm.File3dm) -> int:\n    \"\"\"Find the highest Coque_NNNN id in the model.\"\"\"\n    max_id = 0\n    for obj in model.Objects:\n        name = obj.Attributes.Name\n        if name and name.startswith(\"Coque_\"):\n            try:\n                num = int(name.split(\"_\")[1])\n                if num > max_id:\n                    max_id = num\n            except (ValueError, IndexError):\n                pass\n    return max_id\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}