{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_createDivsBetween2OffsetCrvsForSurfacing.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_createDivsBetween2OffsetCrvsForSurfacing.py",
  "instruction": "Spb brep create divs between2offset crvs for surfacing",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\n\"\"\"\r\n200402-04: Created, starting with other scripts.\r\n220328: Import-related update.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Enum\r\nfrom System import Guid\r\n\r\nimport spb_Crv_fitRebuild\r\n\r\n\r\nsBrepMethods = 'Loft2Crvs', 'LoftSectionLines', 'Sweep2A', 'Sweep2B', 'Network'\r\n\r\nclass Opts():\r\n    \r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    riAddOpts = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    def addOptionDouble(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionDouble(\r\n            getObj, englishName=names[key], numberValue=riOpts[key])\r\n\r\n\r\n    def addOptionInteger(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionInteger(\r\n            getObj, englishName=names[key], intValue=riOpts[key])\r\n\r\n\r\n    def addOptionList(key, names, listValues, values):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionList(\r\n            getObj,\r\n            englishOptionName=names[key],\r\n            listValues=listValues,\r\n            listCurrentIndex=values[key])\r\n\r\n\r\n    def addOptionToggle(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionToggle(\r\n            getObj, englishName=names[key], toggleValue=riOpts[key])\r\n\r\n\r\n    key = 'bRebuildRails'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bCPlane'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'PlanView'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'World', 'CPlane')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bAtGrevilles'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bAtEqualDivisions'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'iDivisionCt'; keys.append(key)\r\n    values[key] = 2\r\n    riOpts[key] = ri.Custom.OptionInteger(\r\n            initialValue=values[key],\r\n            setLowerLimit=True,\r\n            limit=2)\r\n    riAddOpts[key] = addOptionInteger(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bSplitPolyCrvToSegs'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bSplitPathsAtKnots'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bAddArrayedLines'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bAddBrep'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'iBrepMethod'; keys.append(key)\r\n    values[key] = 0\r\n    riAddOpts[key] = addOptionInteger(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'iLoftType'; keys.append(key)\r\n    values[key] = 0\r\n    riAddOpts[key] = addOptionInteger(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'fBrepTol'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n    \r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.keys:\r\n            if key in cls.riOpts:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n\r\n\r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if key in cls.riOpts:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef get2Curves():\r\n    \"\"\"\r\n    Get 2 curves.  No options.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select 2 curves\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n\r\n    while True:\r\n        res = go.GetMultiple(minimumNumber=2, maximumNumber=2)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n        elif res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n\r\ndef prepareCurves(rgCs_In, bRebuild=False, bSplitPolyCrvToSegs=True, bSplitPathsAtKnots=False):\r\n    \"\"\"\r\n    Prepare curves, including splitting per options.\r\n\r\n    Returns: list of new curves\r\n    \"\"\"\r\n    \r\n    rc = rg.Curve.JoinCurves(\r\n            rgCs_In,\r\n            joinTolerance=sc.doc.ModelAbsoluteTolerance)\r\n    if not rc: return\r\n    rgCrvs_Joined = rc\r\n\r\n    rgCrvs_Final = []\r\n    for rgCrv_Joined in rgCrvs_Joined:\r\n        if isinstance(rgCrv_Joined, rg.PolyCurve):\r\n            rgCrv_Joined.RemoveNesting()\r\n\r\n        if not bSplitPolyCrvToSegs:\r\n            if not bRebuild:\r\n                rgCrvs_SplitPoly = [rgCrv_Joined.Duplicate()]\r\n            else:\r\n                rc = spb_Crv_fitRebuild.rebuildCurve(\r\n                    rgCrv_Joined,\r\n                    0.25*sc.doc.ModelAbsoluteTolerance,\r\n                    iDegree=3,\r\n                    bPreserveEndTans=True,\r\n                    bFurtherTranslateCps=False,\r\n                    iMinCpCt=None,\r\n                    iMaxCpCt=50,\r\n                    bDebug=False,\r\n                    )\r\n                rgCrvs_SplitPoly = [rgCrv_Joined.Duplicate()] if rc[0] is None else [rc[0]]\r\n        else:\r\n            # bSplitPolyCrvToSegs == True.\r\n            if isinstance(rgCrv_Joined, rg.PolyCurve):\r\n                rc = rgCrv_Joined.Explode()\r\n                if rc:\r\n                    rgCrvs_Exploded = rc\r\n                    if not bRebuild:\r\n                        rgCrvs_SplitPoly = rc\r\n                    else:\r\n                        rgCrvs_SplitPoly = []\r\n                        for c in rgCrvs_Exploded:\r\n                            rc = spb_Crv_fitRebuild.rebuildCurve(\r\n                                c,\r\n                                0.25*sc.doc.ModelAbsoluteTolerance,\r\n                                iDegree=3,\r\n                                bPreserveEndTans=True,\r\n                                bFurtherTranslateCps=False,\r\n                                iMinCpCt=None,\r\n                                iMaxCpCt=50,\r\n                                bDebug=False,\r\n                                )\r\n                            rgCrvs_SplitPoly.append(c if rc[0] is None else rc[0])\r\n            else:\r\n                # not PolyCurve.\r\n                if not bRebuild:\r\n                    rgCrvs_SplitPoly = [rgCrv_Joined.Duplicate()]\r\n                else:\r\n                    rc = spb_Crv_fitRebuild.rebuildCurve(\r\n                        rgCrv_Joined,\r\n                        0.25*sc.doc.ModelAbsoluteTolerance,\r\n                        iDegree=3,\r\n                        bPreserveEndTans=True,\r\n                        bFurtherTranslateCps=False,\r\n                        iMinCpCt=None,\r\n                        iMaxCpCt=50,\r\n                        bDebug=False,\r\n                        )\r\n                    rgCrvs_SplitPoly = [rgCrv_Joined.Duplicate()] if rc[0] is None else [rc[0]]\r\n\r\n        if not bSplitPathsAtKnots:\r\n            if not bRebuild:\r\n                rgCrvs_Final.extend(rgCrvs_SplitPoly)\r\n            else:\r\n                rgCrvs_Final = []\r\n                for rgCrv_SplitPoly in rgCrvs_SplitPoly:\r\n                    rc = spb_Crv_fitRebuild.rebuildCurve(\r\n                        rgCrv_SplitPoly,\r\n                        0.25*sc.doc.ModelAbsoluteTolerance,\r\n                        iDegree=3,\r\n                        bPreserveEndTans=True,\r\n                        bFurtherTranslateCps=False,\r\n                        iMinCpCt=None,\r\n                        iMaxCpCt=50,\r\n                        bDebug=False,\r\n                        )\r\n                    rgCrvs_Final.append(rgCrv_SplitPoly.Duplicate() if rc[0] is None else rc[0])\r\n        else:\r\n            for rgCrv_SplitPoly in rgCrvs_SplitPoly:\r\n                ts_SpanBoundaries = [rgCrv_SplitPoly.Domain.T0]\r\n                for iSpan in xrange(rgCrv_SplitPoly.SpanCount):\r\n                    ts_SpanBoundaries.append(rgCrv_SplitPoly.SpanDomain(iSpan).T1)\r\n                rc = rgCrv_SplitPoly.Split(ts_SpanBoundaries)\r\n                if rc:\r\n                    rgCrvs_SplitAtKnots = rc\r\n                    if not bRebuild:\r\n                        rgCrvs_Final.extend(rgCrvs_SplitAtKnots)\r\n                    else:\r\n                        rgCrvs_Final = []\r\n                        for rgCrv_SplitAtKnots in rgCrvs_SplitAtKnots:\r\n                            rc = spb_Crv_fitRebuild.rebuildCurve(\r\n                                rgCrv_SplitAtKnots,\r\n                                0.25*sc.doc.ModelAbsoluteTolerance,\r\n                                iDegree=3,\r\n                                bPreserveEndTans=True,\r\n                                bFurtherTranslateCps=False,\r\n                                iMinCpCt=None,\r\n                                iMaxCpCt=50,\r\n                                bDebug=False\r\n                                )\r\n                            rgCrvs_Final.append(rgCrv_SplitAtKnots if rc[0] is None else rc[0])\r\n\r\n                rgCrv_SplitPoly.Dispose()\r\n    \r\n    return rgCrvs_Final\r\n\r\n\r\ndef getParameters(nc, bAtGrevilles, iDivisionCt=None, fDivisionLength=None):\r\n\r\n\r\n    ts = []\r\n\r\n    #if bAtGrevilles:\r\n    #    rc = nc.GrevilleParameters()\r\n    #    if rc: ts.extend(rc)\r\n    #    if nc.IsClosed:\r\n    #        ts.pop()\r\n\r\n\r\n    #if iDivisionCt:\r\n    #    rc = nc.DivideByCount(\r\n    #            segmentCount=iDivisionCt,\r\n    #            includeEnds=True)\r\n    #    if rc: ts.extend(rc)\r\n    #    if nc.IsClosed:\r\n    #        ts.append(nc.Domain.T1)\r\n    \r\n    fDivisionLength = 10.0*sc.doc.ModelAbsoluteTolerance\r\n    if fDivisionLength:\r\n        rc = nc.DivideByLength(\r\n            segmentLength=fDivisionLength,\r\n            includeEnds=True)\r\n        print rc[-1]\r\n        if rc: ts.extend(rc)\r\n        if not nc.IsClosed:\r\n            # DivideByLength doesn't add the T1 segment\r\n            # even though includeEnds == True.\r\n            # https://developer.rhino3d.com/api/RhinoCommon/html/M_Rhino_Geometry_Curve_DivideByLength.htm\r\n            # shows the parameter labeled as 'includeStart'.\r\n            ts.append(nc.Domain.T1)\r\n\r\n    if ts is None:\r\n        print \"No parameters were obtained.\"\r\n        return\r\n\r\n    ts = sorted(set(ts)) # Remove duplicates and sort.\r\n\r\n    # Remove overlaps for closed (including periodic) curves.\r\n    if nc.IsClosed:\r\n        ts_WIP = []\r\n        for t in ts:\r\n            if t >= nc.Domain.T0 and t < nc.Domain.T1:\r\n                ts_WIP.append(t)\r\n        ts = ts_WIP\r\n\r\n    return ts\r\n\r\n\r\ndef createCrossSectionLines_NoProjection(ncs_A, ncs_B, ts_perA, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    lines_Out_perA = []\r\n    ncs_B_Out_perA = []\r\n\r\n    for iA in range(len(ncs_A)):\r\n        ncA = ncs_A[iA]\r\n        tsA = ts_perA[iA]\r\n        \r\n        lines_Out_perA.append([])\r\n        ncs_B_Out_perA.append([None])\r\n\r\n        t_B_StartForA = None\r\n        nc_B_StartForA = None\r\n        t_B_EndForA = None\r\n        nc_B_EndForA = None\r\n            \r\n        for iT, tA in enumerate(tsA):\r\n\r\n            if tA > 26.1:\r\n                pass\r\n                #bDebug = True\r\n\r\n            bSuccess, frame = ncA.PerpendicularFrameAt(t=tA)\r\n            if not bSuccess:\r\n                print \"Perpendicular frame could not be calculated.\"\r\n                continue\r\n\r\n            pt_A = ncA.PointAt(tA)\r\n\r\n            for iB in range(len(ncs_B)):\r\n                \r\n                nc_B = ncs_B[iB]\r\n\r\n                rc = rg.Intersect.Intersection.CurvePlane(\r\n                    nc_B,\r\n                    frame,\r\n                    tolerance=0.1*sc.doc.ModelAbsoluteTolerance)\r\n                if not rc:\r\n                    # No intersection, so don't bother proceeding with this nc_B.\r\n                    continue # to next ncs_B.\r\n\r\n                res, tB = nc_B.ClosestPoint(pt_A)\r\n                if not res:\r\n                    raise ValueError(\"ClosestPoint returned {}.\".format(res))\r\n\r\n                pt_B_ClosestPt = nc_B.PointAt(tB)\r\n                if bDebug: sc.doc.Objects.AddPoint(pt_B_ClosestPt)\r\n\r\n                for intersection in rc:\r\n                    ptB_PerpToA = intersection.PointA\r\n                    if bDebug: sc.doc.Objects.AddPoint(ptB_PerpToA)\r\n\r\n                    dist = ptB_PerpToA.DistanceTo(pt_B_ClosestPt)\r\n                    if bDebug: print dist\r\n\r\n                    if dist <= 1.0*sc.doc.ModelAbsoluteTolerance:\r\n                        if bDebug: sc.doc.Objects.AddLine(rg.Line(pt_A, ptB_PerpToA))\r\n                        line = rg.Line(ncA.PointAt(tA), to=nc_B.PointAt(tB))\r\n                        if bDebug: sc.doc.Objects.AddLine(line)\r\n                        lines_Out_perA[-1].append(line)\r\n                        if t_B_StartForA is None:\r\n                            nc_B_StartForA = nc_B\r\n                            t_B_StartForA = tB\r\n                        if bDebug: sc.doc.Views.Redraw(); return\r\n                        break # to next ncB.\r\n\r\n    return lines_Out_perA\r\n\r\n\r\ndef createCrossSectionLines_PerProjection(ncs_A, ncs_B, ts_perA, plane_Proj, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    xform_Proj = rg.Transform.PlanarProjection(plane_Proj)\r\n\r\n    ncs_B_Flattened = []\r\n\r\n    for nc_B in ncs_B:\r\n        ncB_Flattened = nc_B.Duplicate()\r\n        ncB_Flattened.Transform(xform_Proj)\r\n        #sc.doc.Objects.AddCurve(ncB_Flattened)\r\n        ncs_B_Flattened.append(ncB_Flattened)\r\n\r\n    lines_Out_perA = []\r\n\r\n    for iA in range(len(ncs_A)):\r\n        ncA = ncs_A[iA]\r\n        tsA = ts_perA[iA]\r\n        \r\n        ncA_Flattened = ncA.Duplicate()\r\n        ncA_Flattened.Transform(xform_Proj)\r\n        #sc.doc.Objects.AddCurve(ncA_Flattened)\r\n\r\n        lines_Out_perA.append([])\r\n\r\n        for iT, tA in enumerate(tsA):\r\n\r\n            if tA > 26.1:\r\n                pass\r\n                #bDebug = True\r\n\r\n            bSuccess, frame = ncA_Flattened.PerpendicularFrameAt(t=tA)\r\n            if not bSuccess:\r\n                print \"Perpendicular frame could not be calculated.\"\r\n                continue\r\n\r\n            ptA_Flat = ncA_Flattened.PointAt(tA)\r\n            \r\n            for iB in range(len(ncs_B_Flattened)):\r\n                \r\n                ncB_Flat = ncs_B_Flattened[iB]\r\n                if bDebug: sc.doc.Objects.AddCurve(ncB_Flat)\r\n                nc_B = ncs_B[iB]\r\n\r\n                rc = rg.Intersect.Intersection.CurvePlane(\r\n                    ncB_Flat,\r\n                    frame,\r\n                    tolerance=0.1*sc.doc.ModelAbsoluteTolerance)\r\n                if not rc:\r\n                    # No intersection, so don't bother getting ClosestPoint.\r\n                    continue\r\n\r\n                res, tB = ncB_Flat.ClosestPoint(ptA_Flat)\r\n                if not res: continue\r\n\r\n                ptB_Flat_ClosestPt = ncB_Flat.PointAt(tB)\r\n                if bDebug: sc.doc.Objects.AddPoint(ptB_Flat_ClosestPt)\r\n\r\n                for intersection in rc:\r\n                    ptB_Flat_PerpToA = intersection.PointA\r\n                    if bDebug: sc.doc.Objects.AddPoint(ptB_Flat_PerpToA)\r\n\r\n                    dist = ptB_Flat_PerpToA.DistanceTo(ptB_Flat_ClosestPt)\r\n                    if bDebug: print dist\r\n\r\n                    if dist <= 1.0*sc.doc.ModelAbsoluteTolerance:\r\n                        if bDebug: sc.doc.Objects.AddLine(rg.Line(ptA_Flat, ptB_Flat_PerpToA))\r\n                        line = rg.Line(ncA.PointAt(tA), to=nc_B.PointAt(tB))\r\n                        if bDebug: sc.doc.Objects.AddLine(line)\r\n                        lines_Out_perA[-1].append(line)\r\n                        if bDebug: sc.doc.Views.Redraw(); return\r\n                        break # to next ncB_Flat.\r\n\r\n        ncA_Flattened.Dispose()\r\n\r\n\r\n    for nc in ncs_B_Flattened:\r\n        nc.Dispose()\r\n\r\n    return lines_Out_perA\r\n\r\n\r\ndef createBrep(iBrepMethod, iLoftType, fBrepTol, ncs_A, ncs_B, lines_perA):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    rgBreps1 = []\r\n\r\n    for iA in range(len(ncs_A)):\r\n        nc_A = ncs_A[iA]\r\n        lines_A = lines_perA[iA]\r\n    \r\n        if sBrepMethods[Opts.values['iBrepMethod']] == 'Loft2Crvs':\r\n            rgBreps1 = rg.Brep.CreateFromLoft(\r\n                    curves=[nc_A, rgNurbsCrv_TaperEnd_1Seg],\r\n                    start=rg.Point3d.Unset,\r\n                    end=rg.Point3d.Unset,\r\n                    loftType=rg.LoftType.Straight,\r\n                    closed=False)\r\n        elif sBrepMethods[Opts.values['iBrepMethod']] == 'LoftSectionLines':\r\n            for L in lines_A:\r\n                print L.PointAtStart, L.PointAtEnd\r\n            print lines_A[0].PointAtEnd.EpsilonEquals(lines_A[-1].PointAtEnd, epsilon=1e-12)\r\n            rgBreps1 = rg.Brep.CreateFromLoft(\r\n                    curves=lines_A,\r\n                    start=rg.Point3d.Unset,\r\n                    end=rg.Point3d.Unset,\r\n                    loftType=Enum.ToObject(rg.LoftType, iLoftType),\r\n                    closed=rgNurbsCrv1_PathSeg.IsClosed)\r\n            print rgBreps1\r\n        elif sBrepMethods[Opts.values['iBrepMethod']] == 'Sweep2A':\r\n            rgBreps1 = rg.Brep.CreateFromSweep(\r\n                    rail1=rgNurbsCrv1_PathSeg,\r\n                    rail2=rgNurbsCrv_TaperEnd_1Seg,\r\n                    shapes=lines_A,\r\n                    closed=rgNurbsCrv1_PathSeg.IsClosed,\r\n                    tolerance=fBrepTol)\r\n        elif sBrepMethods[Opts.values['iBrepMethod']] == 'Sweep2B':\r\n            rgSweep2 = rg.SweepTwoRail()\r\n            #rgSweep2.AngleToleranceRadians\r\n            rgSweep2.ClosedSweep = rgNurbsCrv1_PathSeg.IsClosed\r\n            rgSweep2.MaintainHeight = False\r\n            rgSweep2.SweepTolerance = fBrepTol\r\n            rgBreps1 = rgSweep2.PerformSweep(\r\n                    rail1=rgNurbsCrv1_PathSeg,\r\n                    rail2=rgNurbsCrv_TaperEnd_1Seg,\r\n                    crossSections=lines_A)\r\n        elif sBrepMethods[Opts.values['iBrepMethod']] == 'Network':\r\n            rgNurbsSrf, iError = rg.NurbsSurface.CreateNetworkSurface(\r\n                    curves=[rgNurbsCrv1_PathSeg, rgNurbsCrv_TaperEnd_1Seg]+lines_A,\r\n                    continuity=1,\r\n                    edgeTolerance=fBrepTol,\r\n                    interiorTolerance=fBrepTol,\r\n                    angleTolerance=0.1*sc.doc.ModelAngleToleranceDegrees)\r\n            if iError:\r\n                print \"CreateNetworkSurface error code: {}\".format(iError)\r\n            else:\r\n                rgBreps1 = [rgNurbsSrf.ToBrep()]\r\n                rgNurbsSrf.Dispose()\r\n\r\n    return rgBreps1\r\n\r\n\r\ndef createGeometry(rgCs_A_In, rgCs_B_In, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bRebuildRails = getOpt('bRebuildRails')\r\n    bSplitPolyCrvToSegs = getOpt('bSplitPolyCrvToSegs')\r\n    bSplitPathsAtKnots = getOpt('bSplitPathsAtKnots')\r\n    bAtGrevilles = getOpt('bAtGrevilles')\r\n    iDivisionCt = getOpt('iDivisionCt')\r\n    bCPlane = getOpt('bCPlane')\r\n    iBrepMethod = getOpt('iBrepMethod')\r\n    iLoftType = getOpt('iLoftType')\r\n    fBrepTol = getOpt('fBrepTol')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Preparing path curves ...\")\r\n\r\n    rgCs_A_Prepped = prepareCurves(\r\n        rgCs_A_In,\r\n        bRebuild=bRebuildRails,\r\n        bSplitPolyCrvToSegs=bSplitPolyCrvToSegs,\r\n        bSplitPathsAtKnots=bSplitPathsAtKnots)\r\n\r\n    rgCs_B_Prepped = prepareCurves(\r\n        rgCs_B_In,\r\n        bRebuild=bRebuildRails,\r\n        bSplitPolyCrvToSegs=bSplitPolyCrvToSegs,\r\n        bSplitPathsAtKnots=bSplitPathsAtKnots)\r\n\r\n\r\n    ncs_A = [c.ToNurbsCurve() for c in rgCs_A_Prepped]\r\n    ncs_B = [c.ToNurbsCurve() for c in rgCs_B_Prepped]\r\n\r\n\r\n    ts_perA = []\r\n    for nc in ncs_A:\r\n        ts = getParameters(\r\n            nc,\r\n            bAtGrevilles=bAtGrevilles,\r\n            iDivisionCt=iDivisionCt,\r\n            fDivisionLength=None)\r\n        if ts is None:\r\n            print \"Parameters could not be obtained for curve.\"\r\n            return\r\n        ts_perA.append(ts)\r\n\r\n\r\n    if bCPlane:\r\n        view_Active = sc.doc.Views.ActiveView\r\n        plane_Proj = view_Active.ActiveViewport.ConstructionPlane()\r\n        \r\n        xform1 = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, plane_Proj)\r\n        rgLine_ToArray.Transform(xform1)\r\n    else:\r\n        plane_Proj = rg.Plane.WorldXY\r\n\r\n\r\n    rc = createCrossSectionLines_NoProjection(\r\n        ncs_A,\r\n        ncs_B,\r\n        ts_perA,\r\n        bDebug=bDebug)\r\n\r\n    #rc = createCrossSectionLines_PerProjection(\r\n    #    ncs_A,\r\n    #    ncs_B,\r\n    #    ts_perA,\r\n    #    plane_Proj,\r\n    #    bDebug=bDebug)\r\n\r\n    lines_perA = rc\r\n\r\n    #brep = createBrep(\r\n    #        iBrepMethod=iBrepMethod,\r\n    #        iLoftType=iLoftType,\r\n    #        fBrepTol=fBrepTol,\r\n    #        ncs_A=ncs_A,\r\n    #        ncs_B=ncs_B,\r\n    #        lines_perA=lines_perA)\r\n\r\n    return lines_perA\r\n\r\n    return lines_perA, brep\r\n\r\n\r\nclass DrawLinesConduit(Rhino.Display.DisplayConduit):\r\n\r\n    def __init__(self):\r\n        self.color = sc.doc.Layers.CurrentLayer.Color\r\n        self.lines = None\r\n\r\n    def CalculateBoundingBox(self, calculateBoundingBoxEventArgs):\r\n        if self.lines:\r\n            self.bbox = rg.BoundingBox(points=[line.From for line in self.lines])\r\n            calculateBoundingBoxEventArgs.IncludeBoundingBox(self.bbox)\r\n\r\n    def PreDrawObjects(self, drawEventArgs):\r\n        if self.lines:\r\n            drawEventArgs.Display.DrawLines(\r\n                lines=self.lines,\r\n                color=self.color,\r\n                thickness=1)\r\n\r\n\r\ndef getOptions(rgCs_A_In, rgCs_B_In):\r\n    \"\"\"\r\n    Get options.\r\n    \r\n    Returns\r\n        None to cancel.\r\n        False to indicate to create objects with current options.\r\n        True to indicate to regenerate geometry and return to this function.\r\n    \"\"\"\r\n    \r\n    valuesBefore = {}\r\n\r\n    go = ri.Custom.GetOption()\r\n    go.SetCommandPrompt(\"Set options\")\r\n\r\n    go.AcceptNothing(True)\r\n\r\n    rc = createGeometry(\r\n        rgCs_A_In,\r\n        rgCs_B_In,\r\n        iDivisionCt=Opts.values['iDivisionCt'] if Opts.values['bAtEqualDivisions'] else None,\r\n        )\r\n\r\n    conduit = DrawLinesConduit()\r\n\r\n    if rc:\r\n        conduit.lines = [line for lines in rc for line in lines]\r\n        conduit.Enabled = True\r\n        sc.doc.Views.Redraw()\r\n\r\n\r\n    idxs_Opts = {}\r\n\r\n    while True:\r\n        sc.escape_test()\r\n\r\n        for key in Opts.keys:\r\n            valuesBefore[key] = Opts.values[key]\r\n\r\n        go.AddOptionToggle(Opts.names['bRebuildRails'], Opts.riOpts['bRebuildRails'])\r\n        go.AddOptionToggle(Opts.names['bCPlane'], Opts.riOpts['bCPlane'])\r\n        go.AddOptionToggle(Opts.names['bAtGrevilles'], Opts.riOpts['bAtGrevilles'])\r\n        go.AddOptionToggle(Opts.names['bAtEqualDivisions'],\r\n                            Opts.riOpts['bAtEqualDivisions'])\r\n        if Opts.values['bAtEqualDivisions']:\r\n            go.AddOptionInteger(Opts.names['iDivisionCt'],\r\n                                Opts.riOpts['iDivisionCt'])\r\n        go.AddOptionToggle(Opts.names['bSplitPolyCrvToSegs'], Opts.riOpts['bSplitPolyCrvToSegs'])\r\n        go.AddOptionToggle(Opts.names['bSplitPathsAtKnots'], Opts.riOpts['bSplitPathsAtKnots'])\r\n        go.AddOptionToggle(Opts.names['bAddArrayedLines'], Opts.riOpts['bAddArrayedLines'])\r\n        go.AddOptionToggle(Opts.names['bAddBrep'], Opts.riOpts['bAddBrep'])\r\n        if Opts.values['bAddBrep']:\r\n            idxs_Opts['iBrepMethod'] = go.AddOptionList(\r\n                    englishOptionName=Opts.names['iBrepMethod'],\r\n                    listValues=sBrepMethods,\r\n                    listCurrentIndex=Opts.values['iBrepMethod'])\r\n            if sBrepMethods[Opts.values['iBrepMethod']] == 'LoftSectionLines':\r\n                idxs_Opts['iLoftType'] = go.AddOptionList(\r\n                        englishOptionName=Opts.names['iLoftType'],\r\n                        listValues=Enum.GetNames(rg.LoftType),\r\n                        listCurrentIndex=Opts.values['iLoftType'])\r\n            go.AddOptionDouble(Opts.names['fBrepTol'], Opts.riOpts['fBrepTol'])\r\n        key = 'bEcho'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'bDebug'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        \r\n        res = go.Get()\r\n\r\n        conduit.Enabled = False\r\n        sc.doc.Views.Redraw()\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n        elif res == ri.GetResult.Nothing:\r\n            # Accept current result.\r\n            return rc\r\n        elif Opts.values['bAddBrep'] and go.OptionIndex() == idxs_Opts['iBrepMethod']:\r\n            Opts.values['iBrepMethod'] = go.Option().CurrentListOptionIndex\r\n        elif Opts.values['bAddBrep'] and Opts.values['iBrepMethod'] == 1 and go.OptionIndex() == idxs_Opts['iLoftType']:\r\n            Opts.values['iLoftType'] = go.Option().CurrentListOptionIndex\r\n        elif Opts.riOpts['fBrepTol'].CurrentValue < 0.0:\r\n            Opts.riOpts['fBrepTol'].CurrentValue = Opts.riOpts['fBrepTol'].InitialValue\r\n\r\n        Opts.setValues()\r\n        Opts.saveSticky()\r\n\r\n        for key in Opts.keys:\r\n            if valuesBefore[key] != Opts.values[key]:\r\n                rc = createGeometry(\r\n                    rgCs_A_In,\r\n                    rgCs_B_In,\r\n                    iDivisionCt=Opts.values['iDivisionCt'] if Opts.values['bAtEqualDivisions'] else None,\r\n                    )\r\n                if rc:\r\n                    conduit.lines = [line for lines in rc for line in lines]\r\n                    conduit.Enabled = True\r\n                    sc.doc.Views.Redraw()\r\n                break\r\n        else:\r\n            for key in Opts.keys:\r\n                print valuesBefore[key], Opts.values[key]\r\n            print \"No options were changed.\"\r\n\r\n\r\ndef main():\r\n\r\n    res, objrefs = ri.RhinoGet.GetMultipleObjects(\r\n        \"Select first rail curves\",\r\n        acceptNothing=False,\r\n        filter=rd.ObjectType.Curve)\r\n    if res == Rhino.Commands.Result.Cancel: return\r\n    \r\n    rgCs_A_In = [o.Curve() for o in objrefs]\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    res, objrefs = ri.RhinoGet.GetMultipleObjects(\r\n        \"Select second rail curves\",\r\n        acceptNothing=False,\r\n        filter=rd.ObjectType.Curve)\r\n    if res == Rhino.Commands.Result.Cancel: return\r\n\r\n    rgCs_B_In = [o.Curve() for o in objrefs]\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    #rc = get2Curves()\r\n    #if rc is None: return\r\n\r\n    #rgC_A_In = rc[0].Curve()\r\n    #rgC_B_In = rc[1].Curve()\r\n\r\n\r\n    bRebuildRails = Opts.values['bRebuildRails']\r\n    bCPlane = Opts.values['bRebuildRails']\r\n    bAtGrevilles = Opts.values['bAtGrevilles']\r\n    bAtEqualDivisions = Opts.values['bAtEqualDivisions']\r\n    iDivisionCt = Opts.values['iDivisionCt']\r\n    bSplitPolyCrvToSegs = Opts.values['bSplitPolyCrvToSegs']\r\n    bSplitPathsAtKnots = Opts.values['bSplitPathsAtKnots']\r\n    bAddArrayedLines = Opts.values['bAddArrayedLines']\r\n    bAddBrep = Opts.values['bAddBrep']\r\n    iBrepMethod = Opts.values['iBrepMethod']\r\n    iLoftType = Opts.values['iLoftType']\r\n    fBrepTol = Opts.values['fBrepTol']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n\r\n    rc = getOptions(rgCs_A_In, rgCs_B_In)\r\n\r\n    if rc is None:\r\n        # Cancel.\r\n        return\r\n    if not rc:\r\n        # Create objects.\r\n        return\r\n\r\n    for lines in rc:\r\n        for line in lines:\r\n            sc.doc.Objects.AddCurve(rg.LineCurve(line))\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n    return\r\n\r\n    bRebuildRails = Opts.values['bRebuildRails']\r\n    bCPlane = Opts.values['bRebuildRails']\r\n    bAtGrevilles = Opts.values['bAtGrevilles']\r\n    bAtEqualDivisions = Opts.values['bAtEqualDivisions']\r\n    iDivisionCt = Opts.values['iDivisionCt']\r\n    bSplitPolyCrvToSegs = Opts.values['bSplitPolyCrvToSegs']\r\n    bSplitPathsAtKnots = Opts.values['bSplitPathsAtKnots']\r\n    bAddArrayedLines = Opts.values['bAddArrayedLines']\r\n    bAddBrep = Opts.values['bAddBrep']\r\n    iBrepMethod = Opts.values['iBrepMethod']\r\n    iLoftType = Opts.values['iLoftType']\r\n    fBrepTol = Opts.values['fBrepTol']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    rgLine_ToArray = None\r\n    rgCrvs0_Path = []\r\n    rgCrvs1_Path = []\r\n\r\n    while not (bAtGrevilles or bAtEqualDivisions):\r\n        print \"No path point sampling is enabled.\"\r\n        sc.doc.Views.Redraw()\r\n        rc = getOptions(bFirstGetObjects=False)\r\n        if rc is None or rc is False:\r\n            if rgLine_ToArray: rgLine_ToArray.Dispose()\r\n            for c in rgCrvs0_Path: c.Dispose()\r\n            for c in rgCrvs1_Path: c.Dispose()\r\n            return\r\n        objrefs_Paths = rc[0]\r\n\r\n    rgCrvs0_Path = []\r\n    for objref_Path in objrefs_Paths:\r\n        c = objref_Path.Curve()\r\n        rgCrvs0_Path.append(c)\r\n\r\n\r\n    ncs_A = []\r\n    ncs_B = []\r\n\r\n    nc2_Path = ncA.ToNurbsCurve()\r\n    if nc2_Path is None:\r\n        print \"NurbsCurve could not be calculated from curve.\"\r\n        return\r\n    #sc.doc.Objects.AddCurve(nc2_Path)\r\n\r\n\r\n\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Preparing path curves ...\")\r\n    rc = prepareCurves(\r\n            rgCrvs0=rgCrvs0_Path,\r\n            bRebuild=bRebuildRails,\r\n            bSplitPolyCrvToSegs=bSplitPolyCrvToSegs,\r\n            bSplitPathsAtKnots=bSplitPathsAtKnots)\r\n    if not rc: return\r\n    rgCrvs1_Path = rc\r\n\r\n    rgLine_ToArray = rg.Line(\r\n            rg.Point3d(0.0, 0.0, 0.0),\r\n            rg.Point3d(0.0, fDistance, 0.0))\r\n    \r\n    rgLineCrv_ToArray = rg.LineCurve(rgLine_ToArray)\r\n\r\n    gLineCrvs1_Arrayed = []\r\n    gCrvs_TaperEnds_All = []\r\n    rgBreps1 = []\r\n    gBreps1 = []\r\n\r\n    rgCrvs_PathSegs = None\r\n        \r\n    Rhino.RhinoApp.SetCommandPrompt(\"Creating geometry ...\")\r\n\r\n    for rgCrv1_Path_1Seg in rgCrvs1_Path:\r\n        rc = createCrossSectionLines_PerProjection(\r\n            ncA=rgCrv1_Path_1Seg,\r\n            rgObjs_ToArray=[rgLineCrv_ToArray],\r\n            plane_Proj=plane_Proj,\r\n            fTaper_Start_Deg=fTaper_Start_Deg,\r\n            fTaper_End_Deg=fTaper_End_Deg if bVariableTaper else fTaper_Start_Deg,\r\n            bTaperChangePerCrvParam=bTaperChangePerCrvParam,\r\n            bAtGrevilles=bAtGrevilles,\r\n            bAtEqualDivisions=bAtEqualDivisions,\r\n            iDivisionCt=iDivisionCt,\r\n            bDebug=bDebug)\r\n        if rc is None: return\r\n        # Flatten list.\r\n        rgLineCrvs_Arrayed_1PathSeg = [rgLs[0] for rgLs in rc]\r\n    \r\n        if bAddArrayedLines:\r\n            for i, rgL in enumerate(rgLineCrvs_Arrayed_1PathSeg):\r\n                gL = sc.doc.Objects.AddCurve(rgL)\r\n                if gL != Guid.Empty:\r\n                    gLineCrvs1_Arrayed.append(gL)\r\n                    #rgDot_ = rg.TextDot(str(i), rgObj1_Arrayed_1Seg.PointAtStart)\r\n                    #sc.doc.Objects.AddTextDot(rgDot_)\r\n        else:\r\n            # bAddArrayedLines == False.\r\n            if bAtEqualDivisions:\r\n                if bAtEqualDivisions and iBrepMethod == 0:\r\n                    s  = \"AtEqualDivisions\"\r\n                    s += \" only affects added arrayed lines\"\r\n                    s += \" when BrepMethod == {},\".format(sBrepMethods[iBrepMethod])\r\n                    s += \" but AddArrayed option is disabled.\"\r\n                    print s\r\n\r\n        if bAddBrep:\r\n\r\n            if not bAtGrevilles or bAtEqualDivisions:\r\n                rc = createCrossSectionLines_PerProjection(\r\n                    ncA=rgCrv1_Path_1Seg,\r\n                    rgObjs_ToArray=[rgLineCrv_ToArray],\r\n                    plane_Proj=plane_Proj,\r\n                    fTaper_Start_Deg=fTaper_Start_Deg,\r\n                    fTaper_End_Deg=fTaper_End_Deg if bVariableTaper else fTaper_Start_Deg,\r\n                    bTaperChangePerCrvParam=bTaperChangePerCrvParam,\r\n                    bAtGrevilles=True,\r\n                    bAtEqualDivisions=False,\r\n                    iDivisionCt=0,\r\n                    bDebug=bDebug)\r\n                if rc is None: continue\r\n                # Flatten list.\r\n                rgLineCrvs_Arrayed_1PathSeg_GrevsOnly = [L[0] for L in rc]\r\n            else:\r\n                rgLineCrvs_Arrayed_1PathSeg_GrevsOnly = [L.Duplicate() for L in rgLineCrvs_Arrayed_1PathSeg]\r\n                \r\n            pts_EndOf_LineCrvs_Arrayed = []\r\n            for rgLineCrv in rgLineCrvs_Arrayed_1PathSeg_GrevsOnly:\r\n                pts_EndOf_LineCrvs_Arrayed.append(rgLineCrv.PointAtEnd)\r\n\r\n                rgNurbsCrv_TaperEnd = rgCrv1_Path_1Seg.ToNurbsCurve()\r\n                rgNurbsCrv_TaperEnd.SetGrevillePoints(pts_EndOf_LineCrvs_Arrayed)\r\n\r\n            if bAddBrep:\r\n                rc = createBrep(\r\n                        iBrepMethod=iBrepMethod,\r\n                        iLoftType=iLoftType,\r\n                        fBrepTol=fBrepTol,\r\n                        rgCrv_Path=rgCrv1_Path_1Seg,\r\n                        rgNurbsCrv_TaperEnd_1Seg=rgNurbsCrv_TaperEnd,\r\n                        rgLineCrvs_Arrayed=rgLineCrvs_Arrayed_1PathSeg_GrevsOnly)\r\n                if rc is None:\r\n                    print \"Cannot create brep(s).  Check input.\"\r\n                else:\r\n                    rgBreps1.extend(rc)\r\n                rgCrv1_Path_1Seg.Dispose()\r\n                \r\n            for c in rgLineCrvs_Arrayed_1PathSeg_GrevsOnly:\r\n                c.Dispose()\r\n\r\n\r\n    if rgBreps1:\r\n        rgBreps1_Joined = rg.Brep.JoinBreps(\r\n                rgBreps1,\r\n                tolerance=0.5*sc.doc.ModelAbsoluteTolerance)\r\n        for b in rgBreps1: b.Dispose()\r\n            \r\n        if rgBreps1_Joined:\r\n            gBreps1 = []\r\n            for rgBrep1_Joined in rgBreps1_Joined:\r\n                gBrep1 = sc.doc.Objects.AddBrep(rgBrep1_Joined)\r\n                rgBrep1_Joined.Dispose()\r\n                if gBrep1 != Guid.Empty:\r\n                    gBreps1.append(gBrep1)\r\n            if bEcho:\r\n                print \"{} brep(s) with {} face(s) created.\".format(\r\n                len(gBreps1), len(rgBreps1))\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n    rc = getOptions(bFirstGetObjects=False)\r\n    if rc is None:\r\n        for g_ in gLineCrvs1_Arrayed:\r\n            sc.doc.Objects.Delete(g_, True)\r\n        for g_ in gCrvs_TaperEnds_All:\r\n            sc.doc.Objects.Delete(g_, True)\r\n        for g_ in gBreps1:\r\n            sc.doc.Objects.Delete(g_, True)\r\n    objrefs_Paths = rc[0]\r\n\r\n    for g_ in gLineCrvs1_Arrayed:\r\n        sc.doc.Objects.Delete(g_, True)\r\n    for g_ in gCrvs_TaperEnds_All:\r\n        sc.doc.Objects.Delete(g_, True)\r\n    for g_ in gBreps1:\r\n        sc.doc.Objects.Delete(g_, True)\r\n\r\n    for c in rgCrvs0_Path: c.Dispose()\r\n    for c in rgCrvs1_Path: c.Dispose()\r\n    rgLineCrv_ToArray.Dispose()\r\n    for c in rgLineCrvs_Arrayed_1PathSeg:\r\n        c.Dispose()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": false
}