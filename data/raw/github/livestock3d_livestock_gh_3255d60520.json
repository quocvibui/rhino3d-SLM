{
  "source_url": "https://github.com/livestock3d/livestock_gh/blob/97309ebe4bff2c00ae6ce3a44d5b01e2e433ea6c/python/components/comp_cmf.py",
  "repo": "livestock3d/livestock_gh",
  "repo_stars": 8,
  "repo_description": "Livestock is a plugin/library for Grasshopper",
  "license": "LGPL-3.0",
  "filepath": "python/components/comp_cmf.py",
  "instruction": "Comp cmf",
  "code": "__author__ = \"Christian Kongsgaard\"\n__license__ = \"GNU GPLv3\"\n\n# -------------------------------------------------------------------------------------------------------------------- #\n# Imports\n\n# Module imports\nimport os\nimport xml.etree.ElementTree as ET\nimport collections\nimport subprocess\nfrom shutil import copyfile\nimport pprint\nimport json\nimport datetime\nfrom System.Diagnostics import Process\nimport shutil\nimport tempfile\n\n# Livestock imports\nimport livestock.lib.ssh as ssh\nimport livestock.lib.cmf_lib as cmf_lib\nimport livestock.lib.geometry as gh_geo\nimport livestock.lib.livestock_csv as csv\nfrom livestock.components.component import GHComponent\nfrom livestock.components import component\nimport livestock.lib.misc as gh_misc\nfrom livestock.lib.templates import pick_template\n\n# Grasshopper imports\nimport Rhino.Geometry as rg\nimport rhinoscriptsyntax as rs\n\n\n# -------------------------------------------------------------------------------------------------------------------- #\n# Classes\n\n\nclass CMFGround(GHComponent):\n    \"\"\"A component class that generates the CMF ground\"\"\"\n\n    def __init__(self, ghenv):\n        GHComponent.__init__(self, ghenv)\n\n        def inputs():\n            return {0: component.inputs('required'),\n\n                    1: {'name': 'MeshFaces',\n                        'description': 'The mesh the where the ground '\n                                       'properties should be applied.',\n                        'access': 'item',\n                        'default_value': None},\n\n                    2: {'name': 'Write',\n                        'description': 'Boolean to write the mesh to disk',\n                        'access': 'item',\n                        'default_value': False},\n\n                    3: component.inputs('optional'),\n\n                    4: {'name': 'Layers',\n                        'description': 'List of the depth of soil layers to '\n                                       'add to the mesh in m.\\n'\n                                       'If the values 1 and 2 are given, two '\n                                       'layers will be created. '\n                                       'One from 0 to 1m and one from 1m to 2m.'\n                                       '\\nDefault is 1m',\n                        'access': 'list',\n                        'default_value': 1},\n\n                    5: {'name': 'GroundType',\n                        'description': 'Ground type to be applied. A number '\n                                       'from 0-6 can be provided or the '\n                                       'Livestock Ground Type component can be '\n                                       'connected.\\n'\n                                       '0 - Short grass with medium ground\\n'\n                                       '1 - Gravel (light color and '\n                                       'permeable)\\n'\n                                       '2 - Pavement (dark color and '\n                                       'non-permeable)\\n'\n                                       'Default is 0 - Short grass with medium '\n                                       'ground',\n                        'access': 'item',\n                        'default_value': 0},\n\n                    6: {'name': 'SurfaceWater',\n                        'description': 'Initial volume of surface water placed '\n                                       'on each mesh face in m3.\\n'\n                                       'Default is set to 0m3',\n                        'access': 'item',\n                        'default_value': 0},\n\n                    7: {'name': 'ETMethod',\n                        'description': 'Set method to calculate '\n                                       'evapotranspiration.\\n'\n                                       '0: No evapotranspiration\\n'\n                                       '1: Penman-Monteith\\n'\n                                       '2: Shuttleworth-Wallace\\n'\n                                       'Default is set to no '\n                                       'evapotranspiratio.',\n                        'access': 'item',\n                        'default_value': 0},\n\n                    8: {'name': 'SurfaceRunOffMethod',\n                        'description': 'Set the method for computing the '\n                                       'surface run-off.\\n'\n                                       '0 - Kinematic Wave.\\n'\n                                       '1 - Diffusive Wave.\\n'\n                                       'Default is set 0 - Kinematic Wave.',\n                        'access': 'item',\n                        'default_value': 0}\n                    }\n\n        def outputs():\n            return {0: component.outputs('readme'),\n\n                    1: {'name': 'GroundData',\n                        'description': 'Livestock Ground Data'},\n\n                    2: {'name': 'Ground',\n                        'description': 'Livestock Ground Data Class'}}\n\n        # Component Config\n        self.inputs = inputs()\n        self.outputs = outputs()\n        self.component_number = 11\n        self.description = 'Generates CMF ground' \\\n                           '\\nCMF ground is a mesh surface with porous or ' \\\n                           'glass-like properties.' \\\n                           'CMF ground can be used to model surface runoff and ' \\\n                           'water transport on and within the mesh.' \\\n                           '\\nIcon art based created by Ben Davis from the ' \\\n                           'Noun Project.'\n        self.checks = False\n        self.results = None\n\n        # Data Parameters\n        self.mesh_faces = None\n        self.layers = None\n        self.ground_type = None\n        self.surface_water = None\n        self.et_number = None\n        self.surface_run_off_method = None\n        self.ground_dict = {'mesh': None, 'layers': None, 'ground_type': None, 'surface_water': None,\n                            'et_method': None, 'runoff_method': None}\n\n    def check_inputs(self):\n        \"\"\"\n        Checks inputs and raises a warning if an input is not the correct type.\n        \"\"\"\n\n        self.checks = True\n\n    def config(self):\n        \"\"\"Generates the Grasshopper component.\"\"\"\n\n        # Generate Component\n        self.config_component(self.component_number)\n\n    def run_checks(self, mesh_faces, write, layers, ground_type, surface_water,\n                   et_method, surface_run_off_method):\n        \"\"\"\n        Gathers the inputs and checks them.\n\n        :param layers: Depth of layers.\n        :param retention_curve: Livestock retention curve dict.\n        :param vegetation_properties: Livestock vegetation properties dict.\n        :param saturated_depth: Saturated depth of the cell.\n        :param surface_water: Initial surface water volume.\n        :param face_indices: Face indices where the properties should be applied to.\n        :param et_method: Evapotranspriation calculation method.\n        :param manning_: Manning roughness.\n        :param puddle: Puddle depth.\n        :param surface_run_off_method: Surface Run-off method.\n        \"\"\"\n\n        # Gather data\n        self.mesh_faces = self.add_default_value(mesh_faces, 1)\n        self.write = self.add_default_value(write, 2)\n        self.layers = self.add_default_value(layers, 4)\n        self.ground_type = self.convert_ground_type(ground_type)\n        self.surface_water = self.add_default_value(surface_water, 6)\n        self.et_number = self.add_default_value(et_method, 7)\n        self.surface_run_off_method = self.add_default_value(\n            surface_run_off_method, 8)\n\n        # Run checks\n        self.check_inputs()\n\n    def convert_ground_type(self, ground_type):\n        if isinstance(ground_type, int) or isinstance(ground_type, float):\n            return self.construct_ground_type(ground_type)\n\n        elif not ground_type:\n            return self.construct_ground_type(0)\n\n        else:\n            return ground_type.c\n\n    @staticmethod\n    def construct_ground_type(index):\n        manning = None\n        puddle = 0.01\n        saturated_depth = 3\n\n        if index == 0:\n            return {'retention_curve': cmf_lib.load_retention_curve(0),\n                    'surface_properties': cmf_lib.load_surface_cover(0),\n                    'manning': manning,\n                    'puddle_depth': puddle,\n                    'saturated_depth': saturated_depth, }\n\n        elif index == 1:\n            return {'retention_curve': cmf_lib.load_retention_curve(1),\n                    'surface_properties': cmf_lib.load_surface_cover(3),\n                    'manning': manning,\n                    'puddle_depth': puddle,\n                    'saturated_depth': saturated_depth, }\n\n        elif index == 2:\n            return {'retention_curve': cmf_lib.load_retention_curve(0,\n                                                                    {'k_sat':\n                                                                         0.01}),\n                    'surface_properties': cmf_lib.load_surface_cover(5),\n                    'manning': manning,\n                    'puddle_depth': puddle,\n                    'saturated_depth': saturated_depth, }\n\n        else:\n            raise ValueError('Ground type should be an integer from 0-2. '\n                             'Given value was:' + str(index))\n\n    def convert_et_number_to_method(self):\n        \"\"\"\n        Converts a number into a ET method.\n\n        :return: ET method name.\n        \"\"\"\n\n        if self.et_number == 0:\n            return None\n        elif self.et_number == 1:\n            return 'penman_monteith'\n        elif self.et_number == 2:\n            return 'shuttleworth_wallace'\n        else:\n            w = 'ETMethod has to between 0 and 2. Input was: ' + \\\n                str(self.et_number)\n            self.add_warning(w)\n            raise ValueError(w)\n\n    def convert_runoff_number_to_method(self):\n        \"\"\"\n        Converts a number into a surface run-off method.\n\n        :return: Surface run-off name\n        \"\"\"\n\n        if self.surface_run_off_method == 0:\n            return 'kinematic'\n        elif self.surface_run_off_method == 1:\n            return 'diffusive'\n        else:\n            w = 'SurfaceRunOffMethod has to between 0 and 1. Input was: ' + \\\n                str(self.surface_run_off_method)\n            self.add_warning(w)\n            raise ValueError(w)\n\n    def write_mesh(self, doc):\n        tmp_folder = os.path.join(tempfile.gettempdir(), 'livestock')\n        if not os.path.exists(tmp_folder):\n            os.mkdir(tmp_folder)\n\n        mesh_name = 'mesh_' + str(self.mesh_faces)\n        gh_geo.bake_export_delete(self.mesh_faces, tmp_folder,\n                                  mesh_name, '.obj', doc)\n\n        return mesh_name\n\n    def run(self, doc):\n        \"\"\"\n        In case all the checks have passed the component runs.\n        The component puts all the inputs into a dict and uses PassClass\n        to pass it on.\n        \"\"\"\n\n        if self.checks and self.write:\n            self.ground_dict = {\n                'mesh': self.write_mesh(doc),\n                'layers': self.layers,\n                'ground_type': self.ground_type,\n                'surface_water': self.surface_water,\n                'et_method': self.convert_et_number_to_method(),\n                'runoff_method': self.convert_runoff_number_to_method()\n            }\n\n            self.results = gh_misc.PassClass(self.ground_dict, 'Ground')\n\n\nclass CMFGroundType(GHComponent):\n\n    def __init__(self, ghenv):\n        GHComponent.__init__(self, ghenv)\n\n        def inputs():\n            return {0: component.inputs('optional'),\n\n                    1: {'name': 'RetentionCurve',\n                        'description': 'Sets the retention curve for the '\n                                       'ground. Can either be an integer from '\n                                       '0-5 or'\n                                       'the output from CMF RetentionCurve.\\n'\n                                       '0 - Standard CMF Retention Curve\\n'\n                                       '1 - Coarse Soil\\n'\n                                       '2 - Medium Soil\\n'\n                                       '3 - Medium Fine Soil\\n'\n                                       '4 - Fine Soil\\n'\n                                       '5 - Very Fine Soil\\n'\n                                       'Default is set to 0: Standard CMF '\n                                       'Retention Curve',\n                        'access': 'item',\n                        'default_value': 0},\n\n                    2: {'name': 'SurfaceCover',\n                        'description': 'Sets the surface cover for the ground. '\n                                       'Can either be an integer from 0-6 or'\n                                       'the output from CMF Surface Cover.\\n'\n                                       '0 - Short Grass: 0.12m\\n'\n                                       '1 - High Grass: 0.4m\\n'\n                                       '2 - Wet Sand\\n'\n                                       '3 - Yellow Sand\\n'\n                                       '4 - White Sand\\n'\n                                       '5 - Bare Moist Soil\\n'\n                                       '6 - Bare Dry Soil\\n'\n                                       'Default is set to 0: '\n                                       'Short Grass: 0.12m',\n                        'access': 'item',\n                        'default_value': 0},\n\n                    3: {'name': 'Manning',\n                        'description': 'Set Manning roughness. '\n                                       '\\nIf not set CMF calculates it from '\n                                       'the above given values.',\n                        'access': 'item',\n                        'default_value': None},\n\n                    4: {'name': 'PuddleDepth',\n                        'description': 'Set puddle depth. Puddle depth is the '\n                                       'height were run-off begins.\\n '\n                                       'Default is set to 0.01m',\n                        'access': 'item',\n                        'default_value': 0.01},\n                    }\n\n        def outputs():\n            return {0: component.outputs('readme'),\n\n                    1: {'name': 'GroundTypeData',\n                        'description': 'Livestock Ground Type Data'},\n\n                    2: {'name': 'GroundType',\n                        'description': 'Livestock Ground Type Data Class'}}\n\n        # Component Config\n        self.inputs = inputs()\n        self.outputs = outputs()\n        self.component_number = 11\n        self.description = 'Specifies the CMF Ground Type properties.'\n        self.checks = False\n\n        # Data Parameters\n        self.retention_curve = None\n        self.surface_properties = None\n        self.manning = None\n        self.puddle = None\n        self.saturated_depth = None\n        self.results = None\n\n    def check_inputs(self):\n        \"\"\"\n        Checks inputs and raises a warning if an input is not the correct type.\n        \"\"\"\n\n        self.checks = True\n\n    def config(self):\n        \"\"\"Generates the Grasshopper component.\"\"\"\n\n        # Generate Component\n        self.config_component(self.component_number)\n\n    def run_checks(self, retention_curve, surface_properties, manning_roughness, puddle_depth, saturated_depth):\n        \"\"\"\n        Gathers the inputs and checks them.\n\n        :param retention_curve: Livestock retention curve dict.\n        :param surface_properties: Livestock surface properties dict.\n        :param manning_roughness: Manning roughness.\n        :param puddle_depth: Puddle depth.\n        :param saturated_depth: Saturated depth of the cell.\n        \"\"\"\n\n        # Gather data\n        self.retention_curve = self.convert_retention_curve(retention_curve)\n        self.surface_properties = self.convert_surface_properties(surface_properties)\n        self.manning = self.add_default_value(manning_roughness, 2)\n        self.puddle = self.add_default_value(puddle_depth, 3)\n        self.saturated_depth = self.add_default_value(saturated_depth, 4)\n\n        # Run checks\n        self.check_inputs()\n\n    @staticmethod\n    def convert_retention_curve(retention_curve):\n        if isinstance(retention_curve, int):\n            return cmf_lib.load_retention_curve(retention_curve)\n        elif not retention_curve:\n            return cmf_lib.load_retention_curve(0)\n        else:\n            return retention_curve.c\n\n    @staticmethod\n    def convert_surface_properties(surface_cover):\n        if isinstance(surface_cover, int):\n            return cmf_lib.load_surface_cover(surface_cover)\n        elif not surface_cover:\n            return cmf_lib.load_surface_cover(0)\n        else:\n            return surface_cover.c\n\n    def run(self):\n        \"\"\"\n        In case all the checks have passed the component runs.\n        The component puts all the inputs into a dict and uses\n        PassClass to pass it on.\n        \"\"\"\n\n        if self.checks:\n            ground_type_dict = {'retention_curve': self.retention_curve,\n                                'surface_properties': self.surface_properties,\n                                'manning': self.manning,\n                                'puddle_depth': self.puddle,\n                                'saturated_depth': self.saturated_depth,\n                                }\n\n            self.results = gh_misc.PassClass(ground_type_dict, 'Ground Type')\n\n\nclass CMFWeather(GHComponent):\n    \"\"\"A component class that generates the CMF weather\"\"\"\n\n    def __init__(self, ghenv):\n        GHComponent.__init__(self, ghenv)\n\n        def inputs():\n            return {0: component.inputs('required'),\n\n                    1: {'name': 'Location',\n                        'description': 'A Ladybug Tools Location',\n                        'access': 'item',\n                        'default_value': None},\n\n                    2: {'name': 'MeshFaceCount',\n                        'description': 'Number of faces in the ground mesh',\n                        'access': 'item',\n                        'default_value': None},\n\n                    3: component.inputs('optional'),\n\n                    4: {'name': 'Temperature',\n                        'description': 'Temperature in C. Either a list or a tree where the number of branches is equal'\n                                       ' to the number of mesh faces.',\n                        'access': 'tree',\n                        'default_value': None},\n\n                    5: {'name': 'WindSpeed',\n                        'description': 'Wind speed in m/s. Either a list or a tree where the number of branches is'\n                                       ' equal to the number of mesh faces.',\n                        'access': 'tree',\n                        'default_value': None},\n\n                    6: {'name': 'RelativeHumidity',\n                        'description': 'Relative humidity in %. Either a list or a tree where the number of branches is'\n                                       ' equal to the number of mesh faces.',\n                        'access': 'tree',\n                        'default_value': None},\n\n                    7: {'name': 'CloudCover',\n                        'description': 'Cloud cover, unitless between 0 and 1. Either a list or a tree where the number'\n                                       ' of branches is equal to the number of mesh faces.',\n                        'access': 'tree',\n                        'default_value': None},\n\n                    8: {'name': 'GlobalRadiation',\n                        'description': 'Global Radiation in W/m2. Either a list or a tree where the number of branches'\n                                       ' is equal to the number of mesh faces.',\n                        'access': 'tree',\n                        'default_value': None},\n\n                    9: {'name': 'Rain',\n                        'description': 'Horizontal precipitation in mm/h. Either a list or a tree where the number of'\n                                       ' branches is equal to the number of mesh faces.',\n                        'access': 'tree',\n                        'default_value': None},\n\n                    10: {'name': 'GroundTemperature',\n                         'description': 'Ground temperature in C. Either a list or a tree where the number of branches'\n                                        ' is equal to the number of mesh faces.',\n                         'access': 'tree',\n                         'default_value': None},\n                    }\n\n        def outputs():\n            return {0: component.outputs('readme'),\n\n                    1: {'name': 'Weather',\n                        'description': 'Livestock Weather Data Class'}}\n\n        # Component Config\n        self.inputs = inputs()\n        self.outputs = outputs()\n        self.component_number = 12\n        self.description = 'Generates CMF weather' \\\n                           '\\nIcon art based created by Adrien Coquet from the Noun Project.'\n        self.checks = [False, False, False, False, False, False, False, False]\n        self.results = None\n\n        # Data Parameters\n        self.temp = None\n        self.wind = None\n        self.rel_hum = None\n        self.cloud_cover = None\n        self.global_radiation = None\n        self.rain = None\n        self.ground_temp = None\n        self.location = None\n        self.face_count = None\n\n    def check_inputs(self):\n        \"\"\"Checks inputs and raises a warning if an input is not the correct type.\"\"\"\n\n        self.checks = True\n\n    def config(self):\n        \"\"\"Generates the Grasshopper component.\"\"\"\n\n        # Generate Component\n        self.config_component(self.component_number)\n\n    def run_checks(self, location, face_count, temp, wind, rel_hum, cloud_cover, global_radiation,\n                   rain, ground_temp):\n        \"\"\"\n        Gathers the inputs and checks them.\n\n        :param temp: Temperature\n        :param wind: Wind speed\n        :param rel_hum: Relative humidity\n        :param cloud_cover: Cloud cover\n        :param global_radiation: Global radiation\n        :param rain: Rain\n        :param ground_temp: Ground temperature.\n        :param location: Ladybug Tool location\n        :param face_count: Number of mesh faces in project\n        \"\"\"\n\n        # Gather data\n        if face_count:\n            self.face_count = int(face_count)\n        self.location = location\n\n        self.temp = self.match_cell_count(temp)\n        self.wind = self.match_cell_count(wind)\n        self.rel_hum = self.match_cell_count(rel_hum)\n        self.cloud_cover = self.match_cell_count(cloud_cover)\n        self.global_radiation = self.match_cell_count(global_radiation)\n        self.rain = self.match_cell_count(rain)\n        self.ground_temp = self.match_cell_count(ground_temp)\n\n        # Run checks\n        self.check_inputs()\n\n    def convert_cloud_cover(self):\n        \"\"\"\n        | Converts cloud cover to sun shine fraction.\n        | Sun shine = 1 - cloud cover\n\n        :return: list with sun shine fractions.\n        \"\"\"\n\n        if self.cloud_cover:\n            sun_shine = {}\n\n            for cloud_key in self.cloud_cover.keys():\n                sun_shine[cloud_key] = []\n                for cc in self.cloud_cover[cloud_key]:\n                    sun_shine[cloud_key].append(1 - float(cc))\n\n            return sun_shine\n\n    def convert_radiation_unit(self):\n        \"\"\"\n        | Converts radiation from W/m\\ :sup:`2` to MJ/(m\\ :sup:`2` day)\n        | 1 W/m\\ :sup:`2` => 60s * 60min * 24hours/10\\ :sup:`6` => MJ/(m\\ :sup:`2` day)\n        | 1 W/m\\ :sup:`2` = 0.0864 MJ/(m\\ :sup:`2` day)\n\n        \"\"\"\n\n        if self.global_radiation:\n            converted_radiation = {}\n\n            for radiation_key in self.global_radiation.keys():\n                converted_radiation[radiation_key] = []\n                for rad in self.global_radiation[radiation_key]:\n                    converted_radiation[radiation_key].append(float(rad) * 0.0864)\n\n            self.global_radiation = converted_radiation\n\n    def convert_rain_unit(self):\n        \"\"\"\n        | Converts rain from mm/h to mm/day\n        | 1 mm/h = 24 mm/day\n\n        \"\"\"\n\n        if self.rain:\n            converted_rain = {}\n\n            for rain_key in self.rain.keys():\n                converted_rain[rain_key] = []\n                for rain in self.rain[rain_key]:\n                    converted_rain[rain_key].append(float(rain) * 24)\n\n            self.rain = converted_rain\n\n    def convert_location(self):\n        \"\"\"\n        Extracts information from a Ladybug Tools location\n\n        :return: Latitude, longitude and time zone\n        \"\"\"\n\n        if self.location:\n            location_name, latitude, longitude, time_zone, elevation = gh_misc.decompose_ladybug_location(self.location)\n\n            return latitude, longitude, time_zone\n\n        else:\n            self.add_warning('Component needs a Ladybug Location to run')\n            return None, None, None\n\n    def match_cell_count(self, weather_parameter):\n        \"\"\"\n        Checks whether a whether a weather parameter has the correct number of sublists,\n        so they matches the number of cells. Then converts it into a dict with a list for each cell.\n\n        :param weather_parameter: Weather parameter to check.\n        :return: Corrected weather parameter as dict.\n        \"\"\"\n\n        def find_list(weather_list_):\n            if weather_list_:\n                cleaned_list = []\n\n                for element in weather_list_:\n                    if isinstance(element, list):\n                        cleaned_list.append(element)\n                    else:\n                        pass\n\n                if len(cleaned_list) == 1:\n                    return cleaned_list\n                else:\n                    return cleaned_list\n            else:\n                return None\n\n        if weather_parameter:\n            weather_list = gh_misc.tree_to_list(weather_parameter)\n            clean_weather_list = find_list(weather_list)\n            weather_dict = {}\n\n            if not clean_weather_list:\n                return None\n\n            elif len(clean_weather_list) == 1:\n                weather_dict['all'] = clean_weather_list[0]\n\n            elif len(weather_list) == self.face_count:\n                for i in range(0, len(weather_list)):\n                    cell_number = 'cell_' + str(i)\n                    weather_dict[cell_number] = weather_list[i]\n\n            return weather_dict\n\n        else:\n            return None\n\n    def print_weather_lengths(self):\n        \"\"\"Prints the length of each weather parameter.\"\"\"\n\n        def printer(parameter_name, parameter):\n            if parameter:\n                print(str(parameter_name) + ' includes: ' + str(\n                    len(parameter.keys())) + ' lists')\n            else:\n                print(str(parameter_name) + ' is empty')\n\n        printer('Temperature', self.temp)\n        printer('Wind Speed', self.wind)\n        printer('Relative Humidity', self.rel_hum)\n        printer('Sunshine',\n                self.cloud_cover)  # are converted from cloud cover to sun later, but have same length.\n        printer('Global Radiation', self.global_radiation)\n        printer('Rain', self.rain)\n        printer('Ground Temperature', self.ground_temp)\n\n    def run(self):\n        \"\"\"\n        In case all the checks have passed the component runs.\n        The following functions are run:\n\n        - print_weather_lengths()\n        - convert_cloud_cover()\n        - convert_radiation_unit()\n        - convert_location()\n\n        A weather dict is created an passes on with PassClass.\n        \"\"\"\n\n        if self.checks:\n            # Make print statement\n            self.print_weather_lengths()\n\n            # Convertions\n            sun = self.convert_cloud_cover()\n            self.convert_rain_unit()\n            self.convert_radiation_unit()\n            latitude, longitude, time_zone = self.convert_location()\n\n            # Construct dict\n            weather_dict = {'temp': self.temp,\n                            'wind': self.wind,\n                            'rel_hum': self.rel_hum,\n                            'sun': sun,\n                            'rad': self.global_radiation,\n                            'rain': self.rain,\n                            'ground_temp': self.ground_temp,\n                            'latitude': latitude,\n                            'longitude': longitude,\n                            'time_zone': time_zone}\n\n            self.results = gh_misc.PassClass(weather_dict, 'Weather')\n\n\nclass CMFSurfaceProperties(GHComponent):\n    \"\"\"A component class that generates the CMF Vegetation Properties.\"\"\"\n\n    def __init__(self, ghenv):\n        GHComponent.__init__(self, ghenv)\n\n        def inputs():\n            return {0: component.inputs('optional'),\n\n                    1: {'name': 'SurfaceCover',\n                        'description': 'Sets the surface cover for the ground.\\n'\n                                       '0 - Short Grass: 0.12m\\n'\n                                       '1 - High Grass: 0.4m\\n'\n                                       '2 - Wet Sand\\n'\n                                       '3 - Yellow Sand\\n'\n                                       '4 - White Sand\\n'\n                                       '5 - Bare Moist Soil\\n'\n                                       '6 - Bare Dry Soil\\n'\n                                       'Default is set to 0: Short Grass: 0.12m',\n                        'access': 'item',\n                        'default_value': 0},\n\n                    2: {'name': 'Height',\n                        'description': 'Height of the surface cover in meters.\\n'\n                                       'Default is 0.12m',\n                        'access': 'item',\n                        'default_value': 0.12},\n\n                    3: {'name': 'LeafAreaIndex',\n                        'description': 'Leaf area index of the surface cover. Leaf area index is unitless.\\n'\n                                       'Default is 2.88',\n                        'access': 'item',\n                        'default_value': 2.88},\n\n                    4: {'name': 'Albedo',\n                        'description': 'Albedo of the surface cover. Albedo is unitless.\\n'\n                                       'Default is 0.23',\n                        'access': 'item',\n                        'default_value': 0.23},\n\n                    5: {'name': 'CanopyClosure',\n                        'description': 'Canopy closure of the surface cover. Canopy closure is unitless.\\n'\n                                       'Default is 1.0',\n                        'access': 'item',\n                        'default_value': 1.0},\n\n                    6: {'name': 'CanopyPARExtinction',\n                        'description': 'Canopy PAR Extinction of the surface cover. '\n                                       'Canopy PAR Extinction is unitless.\\n'\n                                       'Default is 0.6',\n                        'access': 'item',\n                        'default_value': 0.6},\n\n                    7: {'name': 'CanopyCapacityLAI',\n                        'description': 'Canopy Capacity per LAI of the surface cover. '\n                                       'Canopy Capacity per LAI is in millimeters.\\n'\n                                       'Default is 0.1',\n                        'access': 'item',\n                        'default_value': 0.1},\n\n                    8: {'name': 'StomatalResistance',\n                        'description': 'Stomatal Resistance of the surface cover. '\n                                       'Stomatal Resistance is in s/m.\\n'\n                                       'Default is 100.0',\n                        'access': 'item',\n                        'default_value': 100.0},\n\n                    9: {'name': 'RootDepth',\n                        'description': 'Root Depth of the surface cover. '\n                                       'Root Depth is in meters.\\n'\n                                       'Default is 0.25',\n                        'access': 'item',\n                        'default_value': 0.25},\n\n                    10: {'name': 'FractionRootDepth',\n                         'description': 'Fraction at root depth of the surface cover. '\n                                        'Fraction at root depth is unitless.\\n'\n                                        'Default is 1',\n                         'access': 'item',\n                         'default_value': 1},\n\n                    11: {'name': 'LeafWidth',\n                         'description': 'Leaf width of the surface cover. '\n                                        'Leaf width is in meters.\\n'\n                                        'Default is 0.005m',\n                         'access': 'item',\n                         'default_value': 0.005}\n                    }\n\n        def outputs():\n            return {0: component.outputs('readme'),\n\n                    1: {'name': 'Units',\n                        'description': 'Shows the units of the surface values'},\n\n                    2: {'name': 'SurfaceValues',\n                        'description': 'Chosen Surface Properties Values'},\n\n                    3: {'name': 'SurfaceProperties',\n                        'description': 'Livestock Surface Properties Data Class'}}\n\n        # Component Config\n        self.inputs = inputs()\n        self.outputs = outputs()\n        self.component_number = 13\n        self.description = 'Generates CMF Surface Cover Properties' \\\n                           '\\nIcon art based created by Ben Davis from the Noun Project.'\n        self.checks = False\n        self.results = None\n\n        # Data Parameters\n        self.property_index = None\n        self.property = None\n        self.properties_dict = {}\n        self.height = None\n        self.lai = None\n        self.albedo = None\n        self.canopy_closure = None\n        self.canopy_par = None\n        self.canopy_capacity = None\n        self.stomatal = None\n        self.root_depth = None\n        self.root_fraction = None\n        self.leaf_width = None\n\n    def check_inputs(self):\n        \"\"\"Checks inputs and raises a warning if an input is not the correct type.\"\"\"\n\n        self.checks = True\n\n    def config(self):\n        \"\"\"Generates the Grasshopper component.\"\"\"\n\n        # Generate Component\n        self.config_component(self.component_number)\n\n    def run_checks(self, property_, height, lai, albedo, canopy_closure,\n                   canopy_par, canopy_cap,\n                   stomatal, root_depth, root_fraction, leaf_width):\n        \"\"\"\n        Gathers the inputs and checks them.\n\n        :param property_: Property index.\n        \"\"\"\n\n        # Gather data\n        self.property_index = self.add_default_value(int(property_), 0)\n        self.height = self.add_default_value(height, 1)\n        self.lai = self.add_default_value(lai, 2)\n        self.albedo = self.add_default_value(albedo, 3)\n        self.canopy_closure = self.add_default_value(canopy_closure, 4)\n        self.canopy_par = self.add_default_value(canopy_par, 5)\n        self.canopy_capacity = self.add_default_value(canopy_cap, 6)\n        self.stomatal = self.add_default_value(stomatal, 7)\n        self.root_depth = self.add_default_value(root_depth, 8)\n        self.root_fraction = self.add_default_value(root_fraction, 9)\n        self.leaf_width = self.add_default_value(leaf_width, 10)\n        self.modified_properties()\n\n        # Run checks\n        self.check_inputs()\n\n    def modified_properties(self):\n        self.properties_dict = collections.OrderedDict([\n            ('height', self.height),\n            ('lai', self.lai),\n            ('albedo', self.albedo),\n            ('canopy_closure', self.canopy_closure),\n            ('canopy_par', self.canopy_par),\n            ('canopy_capacity', self.canopy_capacity),\n            ('stomatal_res', self.stomatal),\n            ('root_depth', self.root_depth),\n            ('root_fraction', self.root_fraction),\n            ('leaf_width', self.leaf_width),\n        ])\n\n    def run(self):\n        \"\"\"\n        | In case all the checks have passed the component runs.\n        | It run pick_properties()\n        | And passes on the property dict with PassClass.\n\n        \"\"\"\n\n        if self.checks:\n            self.property = cmf_lib.load_surface_cover(self.property_index,\n                                                       self.properties_dict)\n            self.results = gh_misc.PassClass(self.property, 'SurfaceCover')\n\n\nclass CMFSyntheticTree(GHComponent):\n    \"\"\"A component class that generates a synthetic tree.\"\"\"\n\n    def __init__(self, ghenv):\n        GHComponent.__init__(self, ghenv)\n\n        def inputs():\n            return {0: {'name': 'FaceIndex',\n                        'description': 'Mesh face index where tree is placed',\n                        'access': 'item',\n                        'default_value': None},\n\n                    1: {'name': 'TreeType',\n                        'description': 'Tree types: 0 - Deciduous. Default is deciduous',\n                        'access': 'item',\n                        'default_value': 0},\n\n                    2: {'name': 'Height',\n                        'description': 'Height of tree in meters. Default is set to 10m',\n                        'access': 'item',\n                        'default_value': 10}}\n\n        def outputs():\n            return {0: {'name': 'readMe!',\n                        'description': 'In case of any errors, it will be shown here.'},\n\n                    1: {'name': 'Units',\n                        'description': 'Shows the units of the tree values'},\n\n                    2: {'name': 'TreeValues',\n                        'description': 'Chosen tree properties values'},\n\n                    3: {'name': 'TreeProperties',\n                        'description': 'Livestock tree properties data'}}\n\n        self.inputs = inputs()\n        self.outputs = outputs()\n        self.component_number = 18\n        self.description = 'Generates a synthetic tree'\n        self.data = None\n        self.units = None\n        self.data_path = [os.getenv('APPDATA') +\n                          r'\\McNeel\\Rhinoceros\\5.0\\scripts\\livestock\\data\\syntheticDeciduous.csv',\n                          os.getenv('APPDATA') +\n                          r'\\McNeel\\Rhinoceros\\5.0\\scripts\\livestock\\data\\syntheticConiferous.csv',\n                          os.getenv('APPDATA') +\n                          r'\\McNeel\\Rhinoceros\\5.0\\scripts\\livestock\\data\\syntheticShrubs.csv']\n        self.tree_type = None\n        self.height = None\n        self.property = None\n        self.face_index = None\n        self.checks = False\n        self.results = None\n\n    def check_inputs(self):\n        \"\"\"Checks inputs and raises a warning if an input is not the correct type.\"\"\"\n\n        if self.height:\n            self.checks = True\n        else:\n            warning = 'Temperature should be a float'\n            self.add_warning(warning)\n\n    def config(self):\n        \"\"\"Generates the Grasshopper component.\"\"\"\n\n        # Generate Component\n        self.config_component(self.component_number)\n\n    def run_checks(self, face_index, tree_type, height):\n        \"\"\"\n        Gathers the inputs and checks them.\n\n        :param face_index: Mesh face index.\n        :param tree_type: Tree type.\n        :param height: Tree height.\n        \"\"\"\n\n        # Gather data\n        self.face_index = self.add_default_value(int(face_index), 0)\n        self.tree_type = self.add_default_value(int(tree_type), 1)\n        self.height = self.add_default_value(height, 2)\n\n        # Run checks\n        self.check_inputs()\n\n    def load_csv(self):\n        \"\"\"Loads a csv file with the tree properties.\"\"\"\n\n        load = csv.read_csv(self.data_path[self.tree_type])\n        self.units = load[0]\n        self.data = load[1]\n\n    def compute_tree(self):\n        \"\"\"Selects the correct tree property. It computes the property information and stores it as a ordered dict.\"\"\"\n\n        self.load_csv()\n        self.property = collections.OrderedDict(\n            [('name', 'Synthetic Deciduous'),\n             ('height', self.height),\n             ('lai',\n              float(self.data[0][2]) * self.height + float(self.data[1][2])),\n             ('albedo', float(self.data[0][3]) *\n              self.height + float(self.data[1][3])),\n             ('canopy_closure', float(self.data[2][4])),\n             ('canopy_par', float(self.data[2][5])),\n             ('canopy_capacity', float(self.data[0][6]) *\n              self.height + float(self.data[1][6])),\n             ('stomatal_res', float(self.data[0][7]) *\n              self.height + float(self.data[1][7])),\n             ('root_depth', float(self.data[2][8])),\n             ('root_fraction', float(self.data[2][9])),\n             ('leaf_width', 0.05)\n             ])\n\n    def run(self):\n        \"\"\"\n        In case all the checks have passed the component runs.\n        It runs the function compute_tree.\n        Creates a dict and passes it on with PassClass.\n        \"\"\"\n\n        if self.checks:\n            self.compute_tree()\n            dic = {'face_index': self.face_index,\n                   'property': self.property}\n\n            self.results = gh_misc.PassClass(dic, 'SyntheticTreeProperty')\n\n\nclass CMFRetentionCurve(GHComponent):\n    \"\"\"A component class that generates the CMF retention curve\"\"\"\n\n    def __init__(self, ghenv):\n        GHComponent.__init__(self, ghenv)\n\n        def inputs():\n            return {0: {'name': 'SoilIndex',\n                        'description': 'Index for choosing soil type. '\n                                       'Index from 0-5.\\n'\n                                       'Default is set to 0, which is the '\n                                       'default CMF retention curve.',\n                        'access': 'item',\n                        'default_value': 0},\n\n                    1: {'name': 'K_sat',\n                        'description': 'Saturated conductivity in m/day',\n                        'access': 'item',\n                        'default_value': None},\n\n                    2: {'name': 'Phi',\n                        'description': 'Porosity in m3/m3',\n                        'access': 'item',\n                        'default_value': None},\n\n                    3: {'name': 'Alpha',\n                        'description': 'Inverse of water entry potential in 1/cm',\n                        'access': 'item',\n                        'default_value': None},\n\n                    4: {'name': 'N',\n                        'description': 'Pore size distribution parameter is unitless',\n                        'access': 'item',\n                        'default_value': None},\n\n                    5: {'name': 'M',\n                        'description': 'VanGenuchten m (if negative, 1-1/n is used) is unitless',\n                        'access': 'item',\n                        'default_value': None},\n\n                    6: {'name': 'L',\n                        'description': 'Mualem tortoisivity is unitless',\n                        'access': 'item',\n                        'default_value': None}\n                    }\n\n        def outputs():\n            return {0: component.outputs('readme'),\n\n                    1: {'name': 'Units',\n                        'description': 'Shows the units of the curve values'},\n\n                    2: {'name': 'CurveValues',\n                        'description': 'Chosen curve properties values'},\n\n                    3: {'name': 'RetentionCurve',\n                        'description': 'Livestock Retention Curve'}}\n\n        # Component Config\n        self.inputs = inputs()\n        self.outputs = outputs()\n        self.component_number = 15\n        self.description = 'Generates CMF retention curve'\n        self.checks = False\n        self.results = None\n\n        # Data Parameters\n        self.property = None\n        self.properties_dict = {}\n        self.soil_index = None\n        self.k_sat = None\n        self.phi = None\n        self.alpha = None\n        self.n = None\n        self.m = None\n        self.l = None\n\n    def check_inputs(self):\n        \"\"\"\n        Checks inputs and raises a warning if an input is not the correct type.\n        \"\"\"\n\n        self.checks = True\n\n    def config(self):\n        \"\"\"Generates the Grasshopper component.\"\"\"\n\n        # Generate Component\n        self.config_component(self.component_number)\n\n    def run_checks(self, soil_index, k_sat, phi, alpha, n, m, l):\n        \"\"\"\n        Gathers the inputs and checks them.\n\n        :param soil_index: Soil index.\n        :param k_sat: Ksat\n        :param phi: Phi\n        :param alpha: Alpha\n        :param n: N\n        :param m: M\n        :param l: L\n        \"\"\"\n\n        # Gather data\n        self.soil_index = self.add_default_value(int(soil_index), 0)\n        self.k_sat = self.add_default_value(k_sat, 1)\n        self.phi = self.add_default_value(phi, 2)\n        self.alpha = self.add_default_value(alpha, 3)\n        self.n = self.add_default_value(n, 4)\n        self.m = self.add_default_value(m, 5)\n        self.l = self.add_default_value(l, 6)\n        self.modified_properties()\n\n        # Run checks\n        self.check_inputs()\n\n    def modified_properties(self):\n        self.properties_dict = collections.OrderedDict([\n            ('k_sat', self.k_sat),\n            ('phi', self.phi),\n            ('alpha', self.alpha),\n            ('n', self.n),\n            ('m', self.m),\n            ('l', self.l)\n        ])\n\n    def run(self):\n        \"\"\"\n        In case all the checks have passed the component runs.\n        Loads the retention curve data and passes it on with PassClass.\n        \"\"\"\n\n        if self.checks:\n            self.property = cmf_lib.load_retention_curve(self.soil_index,\n                                                         self.properties_dict)\n            self.results = gh_misc.PassClass(self.property, 'RetentionCurve')\n\n\nclass CMFSolve(GHComponent):\n    \"\"\"A component class that solves the CMF Case.\"\"\"\n\n    def __init__(self, ghenv):\n        GHComponent.__init__(self, ghenv)\n\n        def inputs():\n            return {0: component.inputs('required'),\n\n                    1: {'name': 'Ground',\n                        'description': 'Output from Livestock CMF Ground',\n                        'access': 'list',\n                        'default_value': None},\n\n                    2: {'name': 'Write',\n                        'description': 'Boolean to write files',\n                        'access': 'item',\n                        'default_value': False},\n\n                    3: {'name': 'Run',\n                        'description': 'Boolean to run analysis\\n',\n                        'access': 'item',\n                        'default_value': False},\n\n                    4: component.inputs('optional'),\n\n                    5: {'name': 'Weather',\n                        'description': 'Input from Livestock CMF Weather',\n                        'access': 'item',\n                        'default_value': None},\n\n                    6: {'name': 'Trees',\n                        'description': 'Input from Livestock CMF Tree',\n                        'access': 'list',\n                        'default_value': None},\n\n                    7: {'name': 'BoundaryConditions',\n                        'description': 'Input from Livestock CMF Boundary Condition',\n                        'access': 'list',\n                        'default_value': None},\n\n                    8: {'name': 'SolverSettings',\n                        'description': 'Input from Livestock CMF Solver Settings',\n                        'access': 'item',\n                        'default_value': None},\n\n                    9: {'name': 'Outputs',\n                        'description': 'Connect Livestock Outputs',\n                        'access': 'item',\n                        'default_value': None},\n\n                    10: {'name': 'CaseName',\n                         'description': 'Case name as string.\\n'\n                                        'Default is: unnamed_cmf_case',\n                         'access': 'item',\n                         'default_value': 'unnamed_cmf_case'},\n\n                    11: {'name': 'Folder',\n                         'description': 'Path to case folder.\\n'\n                                        'Default is C:/livestock/analyses',\n                         'access': 'item',\n                         'default_value': r'C:\\livestock\\analyses'},\n\n                    12: {'name': 'SSH',\n                         'description': 'If True the case will be computed '\n                                        'through the SSH connection.'\n                                        'To get the SSH connection to work; '\n                                        'the Livestock SSH Component '\n                                        'should be configured. If False; '\n                                        'the case will be run locally.\\n'\n                                        'Default is set to False',\n                         'access': 'item',\n                         'default_value': False},\n                    }\n\n        def outputs():\n            return {0: component.outputs('readme'),\n\n                    1: {'name': 'ResultPath',\n                        'description': 'Path to result files'}}\n\n        # Component Config\n        self.inputs = inputs()\n        self.outputs = outputs()\n        self.component_number = 14\n        self.description = 'Solves CMF Case.\\n' \\\n                           'Icon art based on Vectors Market from the ' \\\n                           'Noun Project.'\n        self.checks = False\n        self.results = None\n\n        # Data Parameters\n        self.ground = None\n        self.write_case = None\n        self.run_case = None\n        self.weather = None\n        self.trees = None\n        self.boundary_conditions = None\n        self.solver_settings = None\n        self.output_config = None\n        self.folder = None\n        self.case_name = None\n        self.ssh = None\n\n        # Additional Parameters\n        self.case_path = None\n        self.mesh = None\n        self.py_exe = self.get_cpython()\n        self.written = False\n\n    def check_inputs(self):\n        \"\"\"Checks inputs and raises a warning if an input is not\n        the correct type.\"\"\"\n\n        self.checks = True\n\n    def config(self):\n        \"\"\"Generates the Grasshopper component.\"\"\"\n\n        # Generate Component\n        self.config_component(self.component_number)\n\n    def run_checks(self, ground, write, run, weather, trees,\n                   boundary_conditions, solver_settings,\n                   outputs, name, folder, ssh, ):\n        \"\"\"\n        Gathers the inputs and checks them.\n\n        :param ground: Livestock Ground dict\n        :param write: Whether to write or not\n        :param run: Whether to run or not.\n        :param weather: Livestock Weather dict\n        :param trees: Livestock Tree dict\n        :param boundary_conditions: Livestock Boundary Condition dict\n        :param solver_settings: Livestock Solver settings dict\n        :param outputs: Livestock Outputs dict\n        :param name: Case name\n        :param folder: Case folder\n        :param ssh: Whether to run on ssh or not.\n        \"\"\"\n\n        # Gather data\n        self.ground = self.add_default_value(ground, 1)\n        self.write_case = self.add_default_value(write, 2)\n        self.run_case = self.add_default_value(run, 3)\n        self.weather = self.add_default_value(weather, 5)\n        self.trees = self.add_default_value(trees, 6)\n        self.boundary_conditions = self.add_default_value(boundary_conditions,\n                                                          7)\n        self.solver_settings = self.convert_solver_settings(solver_settings)\n        self.output_config = self.convert_outputs(outputs)\n        self.case_name = self.add_default_value(name, 10)\n        self.folder = self.add_default_value(folder, 11)\n        self.ssh = self.add_default_value(ssh, 12)\n\n        self.update_case_path()\n\n        # Run checks\n        self.check_inputs()\n\n    def update_case_path(self):\n        \"\"\"Updates the case folder path.\"\"\"\n\n        self.case_path = self.folder + '\\\\' + self.case_name + '\\\\cmf'\n\n    @staticmethod\n    def convert_solver_settings(solver_settings):\n        if not solver_settings:\n            return cmf_lib.default_solver_settings()\n        else:\n            return solver_settings.c\n\n    @staticmethod\n    def convert_outputs(outputs):\n        if not outputs:\n            return cmf_lib.default_outputs()\n        else:\n            return outputs.c\n\n    def write(self, doc):\n        \"\"\"\n        Writes the needed files.\n\n        :param doc: Grasshopper document.\n        \"\"\"\n\n        # Helper functions\n        def write_weather(weather_dict, folder):\n\n            # Write json file\n            weather_file = 'weather.json'\n            with open(folder + '/' + weather_file, 'w') as outfile:\n                json.dump(weather_dict.c, outfile)\n\n            return weather_file\n\n        def write_ground(ground_dict_, folder):\n\n            # Process ground\n            ground_dict = [ground.c\n                           for ground in ground_dict_]\n\n            # Copy meshes\n            tmp_folder = os.path.join(tempfile.gettempdir(), 'livestock')\n            meshes = []\n            for ground in ground_dict:\n                mesh_name = ground['mesh'] + '.obj'\n                tmp_mesh = os.path.join(tmp_folder, mesh_name)\n                case_mesh = os.path.join(self.case_path,\n                                         mesh_name)\n                shutil.copyfile(tmp_mesh, case_mesh)\n                meshes.append(mesh_name)\n\n            # Write json file\n            ground_file = 'ground.json'\n            with open(folder + '/' + ground_file, 'w') as outfile:\n                json.dump(ground_dict, outfile)\n\n            return [ground_file, ] + meshes\n\n        def write_trees(tree_dict_, folder):\n            # Process trees\n\n            tree_dict = list(tree.c for tree in tree_dict_)\n            tree_root = ET.Element('tree')\n\n            for i in range(0, len(tree_dict)):\n                tree = ET.SubElement(tree_root, 'tree_%i' % i)\n                t_keys = tree_dict[i].keys()\n\n                for t in t_keys:\n                    data = ET.SubElement(tree, str(t))\n                    data_to_write = tree_dict[i][str(t)]\n                    if isinstance(data_to_write, dict):\n                        data.text = str(dict(data_to_write))\n                    else:\n                        data.text = str(data_to_write)\n\n            tree_tree = ET.ElementTree(tree_root)\n            tree_file = 'trees.xml'\n            tree_tree.write(folder + '/' + tree_file, xml_declaration=True)\n\n            return tree_file\n\n        def write_outputs(output_dict, folder):\n\n            # Write json file\n            output_file = 'outputs.json'\n            with open(folder + '/' + output_file, 'w') as outfile:\n                json.dump(output_dict, outfile)\n\n            return output_file\n\n        def write_boundary_conditions(boundary_dict_, folder):\n            # Process boundary conditions\n            boundary_conditions_dict = list(bc.c\n                                            for bc in boundary_dict_)\n\n            boundary_conditions_root = ET.Element('boundary_conditions')\n\n            for i in range(0, len(boundary_conditions_dict)):\n                boundary_condition = ET.SubElement(boundary_conditions_root,\n                                                   'boundary_condition_%i' % i)\n\n                bc_type = ET.SubElement(boundary_condition, 'type')\n                bc_type.text = str(boundary_conditions_dict[i]['type'])\n\n                bc_cell = ET.SubElement(boundary_condition, 'cell')\n                bc_cell.text = str(boundary_conditions_dict[i]['cell'])\n\n                bc_layer = ET.SubElement(boundary_condition, 'layer')\n                bc_layer.text = str(boundary_conditions_dict[i]['layer'])\n\n                if boundary_conditions_dict[i]['type'] == 'inlet':\n                    bc_flux = ET.SubElement(boundary_condition, 'inlet_flux')\n                    bc_flux.text = str(\n                        boundary_conditions_dict[i]['inlet_flux'])\n\n                    bc_step = ET.SubElement(boundary_condition, 'time_step')\n                    bc_step.text = str(boundary_conditions_dict[i]['time_step'])\n\n                elif boundary_conditions_dict[i]['type'] == 'outlet':\n                    bc_flux = ET.SubElement(boundary_condition, 'outlet_type')\n\n                    outlet_connection = ET.SubElement(bc_flux,\n                                                      'outlet_connection')\n                    outlet_connection.text = str(\n                        boundary_conditions_dict[i]['outlet_type'][\n                            'connection'])\n\n                    outlet_parameter = ET.SubElement(bc_flux,\n                                                     'connection_parameter')\n                    outlet_parameter.text = str(\n                        boundary_conditions_dict[i]['outlet_type'][\n                            'connection_parameter'])\n\n                    bc_flux = ET.SubElement(boundary_condition, 'location')\n                    bc_flux.text = str(boundary_conditions_dict[i]['location'])\n\n            boundary_conditions_tree = ET.ElementTree(boundary_conditions_root)\n            boundary_condition_file = 'boundary_condition.xml'\n            boundary_conditions_tree.write(\n                folder + '/' + boundary_condition_file, xml_declaration=True)\n\n            return boundary_condition_file\n\n        def write_solver_info(solver_dict, folder):\n\n            # Write json file\n            solver_file = 'solver.json'\n            with open(folder + '/' + solver_file, 'w') as outfile:\n                json.dump(solver_dict, outfile)\n\n            return solver_file\n\n        def write_ssh_files(files_written_):\n            # Clean SSH folder\n            ssh.clean_ssh_folder()\n\n            # SSH commands\n            ssh_command = ssh.get_ssh()\n\n            file_transfer = files_written_\n            file_run = ['cmf_template.py']\n            file_return = ['results.json']\n\n            ssh_command['file_transfer'] = ','.join(file_transfer) + \\\n                                           ',cmf_template.py'\n            ssh_command['file_run'] = ','.join(file_run)\n            ssh_command['file_return'] = ','.join(file_return)\n            ssh_command['template'] = 'cmf'\n\n            ssh.write_ssh_commands(ssh_command)\n\n            return ssh_command\n\n        # check if folder exists\n        if os.path.exists(self.case_path):\n            shutil.rmtree(self.case_path)\n            os.mkdir(self.case_path)\n        else:\n            os.mkdir(self.case_path)\n\n        # Append to files written\n        files_written = list()\n        files_written.append(write_ground(self.ground, self.case_path))\n        files_written.append(write_outputs(self.output_config, self.case_path))\n        files_written.append(write_solver_info(self.solver_settings, self.case_path))\n\n        if self.trees:\n            files_written.append(write_trees(self.trees, self.case_path))\n\n        if self.boundary_conditions:\n            files_written.append(write_boundary_conditions(self.boundary_conditions, self.case_path))\n\n        if self.weather:\n            files_written.append(write_weather(self.weather, self.case_path))\n\n        # template\n        pick_template('cmf', self.case_path)\n\n        # ssh\n        if self.ssh:\n            ssh_cmd = write_ssh_files(files_written)\n            transfer_files = ssh_cmd['file_transfer'].split(',')\n\n            # Copy files from case folder to ssh folder\n            for file_ in transfer_files:\n                copyfile(os.path.join(self.case_path, file_), os.path.join(ssh.ssh_path, file_))\n\n        self.written = True\n\n        return True\n\n    def do_case(self):\n        \"\"\"Spawns a new subprocess, that runs the ssh template.\"\"\"\n\n        if self.ssh:\n            template = ssh.ssh_path + '/ssh_template.py'\n        else:\n            template = self.case_path + '/cmf_template.py'\n\n        # Run template\n        Process.Start(self.py_exe, '\"' + str(template) + '\"').WaitForExit()\n\n        return True\n\n    def check_results(self):\n        \"\"\"\n        Checks if the result files exists and then copies them form the ssh\n        folder to the case folder.\n        If not then a warning is raised.\n        \"\"\"\n\n        ssh_result = ssh.ssh_path + '/results.json'\n        result_path = self.case_path + '/results.json'\n\n        if os.path.exists(ssh_result):\n            copyfile(ssh_result, result_path)\n            ssh.clean_ssh_folder()\n            return result_path\n\n        elif os.path.exists(result_path):\n            return result_path\n\n        else:\n            warning = 'Could not find result file. Unknown error occurred'\n            self.add_warning(warning)\n\n    @staticmethod\n    def read_log():\n        log_file = os.path.join(ssh.livestock_path, 'logs', 'livestock_info.log')\n\n        if os.path.exists(log_file):\n            with open(log_file, 'r') as file_:\n                log_lines = file_.readlines()\n\n            for line in log_lines:\n                print(line.strip())\n\n    def run(self, doc):\n        \"\"\"\n        In case all the checks have passed and write_case is True the\n        component writes the case files.\n        If all checks have passed and run_case is True the\n        simulation is started.\n        \"\"\"\n\n        if self.checks and self.write_case:\n            self.write(doc)\n\n        if self.checks and self.run_case:\n            self.do_case()\n            self.results = self.check_results()\n            self.read_log()\n\n\nclass CMFResults(GHComponent):\n    \"\"\"A component class that loads the CMF results.\"\"\"\n\n    def __init__(self, ghenv):\n        GHComponent.__init__(self, ghenv)\n\n        def inputs():\n            return {0: component.inputs('required'),\n\n                    1: {'name': 'ResultFolder',\n                        'description': 'Path to result folder. '\n                                       'Accepts output from Livestock Solve.',\n                        'access': 'item',\n                        'default_value': None},\n\n                    2: {'name': 'FetchResult',\n                        'description': 'Choose which result should be loaded:'\n                                       '\\n0 - Evapotranspiration'\n                                       '\\n1 - Surface water volume'\n                                       '\\n2 - Surface water flux'\n                                       '\\n3 - Heat flux'\n                                       '\\n4 - Soil layer water flux'\n                                       '\\n5 - Soil layer potential'\n                                       '\\n6 - Soil layer theta'\n                                       '\\n7 - Soil layer volume'\n                                       '\\n8 - Soil layer wetness',\n                        'access': 'item',\n                        'default_value': 0},\n\n                    3: {'name': 'Run',\n                        'description': 'Run component',\n                        'access': 'item',\n                        'default_value': False},\n                    }\n\n        def outputs():\n            return {0: component.outputs('readme'),\n\n                    1: {'name': 'Units',\n                        'description': 'Shows the units of the results'},\n\n                    2: {'name': 'Values',\n                        'description': 'List with chosen result values'},\n                    }\n\n        # Component Config\n        self.inputs = inputs()\n        self.outputs = outputs()\n        self.component_number = 17\n        self.description = 'Load CMF results'\n        self.checks = False\n\n        # Data Parameters\n        self.unit = None\n        self.path = None\n        self.fetch_result = None\n        self.run_component = None\n        self.results = None\n\n    def check_inputs(self):\n        \"\"\"\n        Checks inputs and raises a warning if an input is not the correct type.\n        \"\"\"\n\n        self.checks = True\n\n    def config(self):\n        \"\"\"Generates the Grasshopper component.\"\"\"\n\n        # Generate Component\n        self.config_component(self.component_number)\n\n    def run_checks(self, path, fetch_result, run):\n        \"\"\"\n        Gathers the inputs and checks them.\n\n        :param path: Result path\n        :param fetch_result: Which result to fetch\n        :param run: Whether to run the component or not.\n        \"\"\"\n\n        # Gather data\n        if path:\n            self.path = os.path.join(path, 'results.json')\n        else:\n            self.path = None\n        self.fetch_result = self.add_default_value(fetch_result, 1)\n        self.run_component = self.add_default_value(run, 3)\n\n        # Run checks\n        self.check_inputs()\n\n    def set_fetch_result(self):\n        \"\"\"Function to organize the output units.\"\"\"\n\n        if self.fetch_result == 0:\n            self.fetch_result = 'evapotranspiration'\n            self.unit = 'm3/day'\n\n        elif self.fetch_result == 1:\n            self.fetch_result = 'surface_water_volume'\n            self.unit = 'm3'\n\n        elif self.fetch_result == 2:\n            self.fetch_result = 'surface_water_flux'\n            self.unit = 'm3/day'\n\n        elif self.fetch_result == 3:\n            self.fetch_result = 'heat_flux'\n            self.unit = 'W/m2'\n\n        elif self.fetch_result == 4:\n            self.fetch_result = 'volumetric_flux'\n            self.unit = 'm3/day'\n\n        elif self.fetch_result == 5:\n            self.fetch_result = 'potential'\n            self.unit = 'm'\n\n        elif self.fetch_result == 6:\n            self.fetch_result = 'theta'\n            self.unit = 'm3'\n\n        elif self.fetch_result == 7:\n            self.fetch_result = 'volume'\n            self.unit = 'm3'\n\n        elif self.fetch_result == 8:\n            self.fetch_result = 'wetness'\n            self.unit = '-'\n\n    def run(self):\n        \"\"\"\n        In case all the checks have passed and run is True the component runs.\n        Following functions are run: set_units(), load_cmf_result_file()\n        The results are converted into a Grasshopper Tree structure.\n        \"\"\"\n\n        if self.checks and self.run_component:\n            self.set_fetch_result()\n            results = cmf_lib.load_cmf_result_file(self.path,\n                                                   self.fetch_result)\n            self.results = gh_misc.list_to_tree(results)\n\n\nclass CMFOutputs(GHComponent):\n    \"\"\"\n    A component class that specifies the wanted outputs from the\n    CMF simulation.\n    \"\"\"\n\n    def __init__(self, ghenv):\n        GHComponent.__init__(self, ghenv)\n\n        def inputs():\n            return {0: component.inputs('optional'),\n\n                    1: {'name': 'Evapotranspiration',\n                        'description': 'Cell evaporation'\n                                       '\\nDefault is set to False',\n                        'access': 'item',\n                        'default_value': None},\n\n                    2: {'name': 'SurfaceWaterVolume',\n                        'description': 'Cell surface water\\n'\n                                       'Default is set to True',\n                        'access': 'item',\n                        'default_value': 'init'},\n\n                    3: {'name': 'SurfaceWaterFlux',\n                        'description': 'Cell surface water flux\\n'\n                                       'Default is set to False',\n                        'access': 'item',\n                        'default_value': None},\n\n                    4: {'name': 'HeatFlux',\n                        'description': 'Cell surface heat flux\\n'\n                                       'Default is set to False',\n                        'access': 'item',\n                        'default_value': None},\n\n                    5: {'name': 'VolumetricFlux',\n                        'description': 'Soil layer volumetric flux vectors\\n'\n                                       'Default is set to False',\n                        'access': 'item',\n                        'default_value': None},\n\n                    6: {'name': 'Potential',\n                        'description': 'Soil layer total potential '\n                                       '(Psi_tot = Psi_M + Psi_G)\\n'\n                                       'Default is set to False',\n                        'access': 'item',\n                        'default_value': None},\n\n                    7: {'name': 'Theta',\n                        'description': 'Soil layer volumetric water content of '\n                                       'the layer\\n'\n                                       'Default is set to False',\n                        'access': 'item',\n                        'default_value': None},\n\n                    8: {'name': 'Volume',\n                        'description': 'Soil layer volume of water in the '\n                                       'layer\\n'\n                                       'Default is set to True',\n                        'access': 'item',\n                        'default_value': 'init'},\n\n                    9: {'name': 'Wetness',\n                        'description': 'Soil layer wetness of the soil '\n                                       '(V_volume/V_pores)\\n'\n                                       'Default is set to False',\n                        'access': 'item',\n                        'default_value': None}\n                    }\n\n        def outputs():\n            return {0: component.outputs('readme'),\n\n                    1: {'name': 'ChosenOutputs',\n                        'description': 'Shows the chosen outputs'},\n\n                    2: {'name': 'Outputs',\n                        'description': 'Livestock Output Data'}\n                    }\n\n        # Component Config\n        self.inputs = inputs()\n        self.outputs = outputs()\n        self.component_number = 16\n        self.description = \"Specify the wanted outputs from the CMF simulation.\"\n        self.results = None\n        self.checks = False\n\n        # Data Parameters\n        self.evapo_trans = None\n        self.surface_water_volume = None\n        self.surface_water_flux = None\n        self.heat_flux = None\n        self.three_d_flux = None\n        self.potential = None\n        self.theta = None\n        self.volume = None\n        self.wetness = None\n        self.output_dict = None\n\n    def check_inputs(self):\n        \"\"\"\n        Checks inputs and raises a warning if an input is not the correct type.\n        \"\"\"\n\n        self.checks = True\n\n    def config(self):\n        \"\"\"Generates the Grasshopper component.\"\"\"\n\n        # Generate Component\n        self.config_component(self.component_number)\n\n    def run_checks(self, evapo_trans, surface_water_volume, surface_water_flux,\n                   heat_flux, three_d_flux,\n                   potential, theta, volume, wetness):\n        \"\"\"\n        Gathers the inputs and checks them.\n\n        :param evapo_trans: Whether to include evapotranspiration or not.\n        :param surface_water_volume: Whether to include surface water volume or not.\n        :param surface_water_flux: Whether to include surface water flux or not.\n        :param heat_flux: Whether to include surface heat flux or not.\n        :param three_d_flux: Whether to include soil water flux or not.\n        :param potential: Whether to include soil potential or not.\n        :param theta: Whether to include soil theta or not.\n        :param volume: Whether to include soil water volume or not.\n        :param wetness: Whether to include soil wetness or not.\n        \"\"\"\n\n        # Gather data\n        self.evapo_trans = self.add_default_value(evapo_trans, 1)\n        self.surface_water_volume = self.add_default_value(surface_water_volume,\n                                                           2)\n        self.surface_water_flux = self.add_default_value(surface_water_flux, 3)\n        self.heat_flux = self.add_default_value(heat_flux, 4)\n        self.three_d_flux = self.add_default_value(three_d_flux, 5)\n        self.potential = self.add_default_value(potential, 6)\n        self.theta = self.add_default_value(theta, 7)\n        self.volume = self.add_default_value(volume, 8)\n        self.wetness = self.add_default_value(wetness, 9)\n\n        # Run checks\n        self.check_inputs()\n\n    def set_outputs(self):\n        \"\"\"\n        Converts the wanted outputs into a dict\n\n        :return: output dict.\n        \"\"\"\n\n        output_dict = {'cell': [], 'layer': []}\n\n        if self.evapo_trans:\n            output_dict['cell'].append('evaporation')\n            output_dict['cell'].append('transpiration')\n\n        if self.surface_water_volume or self.surface_water_volume == 'init':\n            output_dict['cell'].append('surface_water_volume')\n\n        if self.surface_water_flux:\n            output_dict['cell'].append('surface_water_flux')\n\n        if self.heat_flux:\n            output_dict['cell'].append('heat_flux')\n\n        if self.three_d_flux:\n            output_dict['layer'].append('volumetric_flux')\n\n        if self.potential:\n            output_dict['layer'].append('potential')\n\n        if self.theta:\n            output_dict['layer'].append('theta')\n\n        if self.volume or self.volume == 'init':\n            output_dict['layer'].append('volume')\n\n        if self.wetness:\n            output_dict['layer'].append('wetness')\n\n        return output_dict\n\n    def run(self):\n        \"\"\"\n        In case all the checks have passed the component runs.\n        set_outputs() are run and passed on with PassClass.\n        \"\"\"\n\n        if self.checks:\n            out_dict = self.set_outputs()\n            self.output_dict = out_dict\n            self.results = gh_misc.PassClass(out_dict, 'Outputs')\n\n\nclass CMFInlet(GHComponent):\n\n    def __init__(self, ghenv):\n        GHComponent.__init__(self, ghenv)\n\n        def inputs():\n            return {0: {'name': 'ConnectedCell',\n                        'description': 'Cell to connect to. Default is set to first cell',\n                        'access': 'item',\n                        'default_value': 0},\n\n                    1: {'name': 'ConnectedLayer',\n                        'description': 'Layer of cell to connect to. 0 is surface water.\\n'\n                                       '1 is first layer of cell and so on.\\n'\n                                       'Default is set to 0 - surface water',\n                        'access': 'item',\n                        'default_value': 0},\n\n                    2: {'name': 'InletFlux',\n                        'description': 'If inlet, then set flux in m3/day',\n                        'access': 'list',\n                        'default_value': None},\n\n                    3: {'name': 'TimeStep',\n                        'description': 'Time step between each value in InletFlux. Time step is in hours -'\n                                       ' e.g. 1/60 equals time steps of 1 min.\\n'\n                                       'Default is 1 hour.',\n                        'access': 'item',\n                        'default_value': 1}\n                    }\n\n        def outputs():\n            return {0: {'name': 'readMe!',\n                        'description': 'In case of any errors, it will be shown here.'},\n\n                    1: {'name': 'BoundaryCondition',\n                        'description': 'Livestock Boundary Condition'}\n                    }\n\n        self.inputs = inputs()\n        self.outputs = outputs()\n        self.description = 'CMF Boundary connection'\n        self.component_number = 23\n        self.cell = None\n        self.layer = None\n        self.inlet_flux = None\n        self.time_step = None\n        self.checks = False\n        self.results = None\n\n    def check_inputs(self):\n        \"\"\"\n        Checks inputs and raises a warning if an input is not the correct type.\n        \"\"\"\n\n        if self.inlet_flux:\n            self.checks = True\n\n    def config(self):\n        \"\"\"\n        Generates the Grasshopper component.\n        \"\"\"\n\n        # Generate Component\n        self.config_component(self.component_number)\n\n    def run_checks(self, cell, layer, inlet_flux, time_step):\n        \"\"\"\n        Gathers the inputs and checks them.\n\n        :param cell:\n        :param layer:\n        :param inlet_flux:\n        :param time_step:\n        :return:\n        \"\"\"\n\n        # Gather data\n        self.cell = self.add_default_value(int(cell), 0)\n        self.layer = self.add_default_value(int(layer), 1)\n        self.inlet_flux = self.add_default_value(inlet_flux, 2)\n        self.time_step = self.add_default_value(time_step, 3)\n\n        # Run checks\n        self.check_inputs()\n\n    def set_inlet(self):\n        \"\"\"Constructs a dict with inlet information.\"\"\"\n\n        self.results = gh_misc.PassClass({'type': 'inlet',\n                                          'cell': self.cell,\n                                          'layer': self.layer,\n                                          'inlet_flux': ','.join([str(elem)\n                                                                  for elem in\n                                                                  self.inlet_flux]),\n                                          'time_step': self.time_step\n                                          },\n                                         'BoundaryCondition')\n\n        pp = pprint.PrettyPrinter(indent=1, width=50)\n        pp.pprint(self.results.c)\n\n    def run(self):\n        \"\"\"\n        In case all the checks have passed the component runs.\n        It runs set_inlet().\n        \"\"\"\n\n        if self.checks:\n            self.set_inlet()\n\n\nclass CMFSolverSettings(GHComponent):\n    \"\"\"A component class that sets the solver settings for CMF Solve.\"\"\"\n\n    def __init__(self, ghenv):\n        GHComponent.__init__(self, ghenv)\n\n        def inputs():\n            return {0: component.inputs('optional'),\n\n                    1: {'name': 'AnalysisLength',\n                        'description': 'Total length of the simulation.'\n                                       'The input should be a list with two '\n                                       'values. The first value is the '\n                                       'numerical length e.g. 24.\\n'\n                                       'Second value is the time unit e.g. h '\n                                       'for hour. The second option is '\n                                       'optional and if not given'\n                                       'the time unit is set to hours.\\n'\n                                       'The time unit has to be one of the '\n                                       'following values:\\n'\n                                       'y - year\\n'\n                                       'd - day\\n'\n                                       'h - hour\\n'\n                                       'm - minute\\n'\n                                       's - second\\n'\n                                       'Default is set to 24 hours.',\n                        'access': 'list',\n                        'default_value': None},\n\n                    2: {'name': 'TimeStep',\n                        'description': 'Size of each simulation time step.'\n                                       'The input should be a list with two '\n                                       'values. The first value is the '\n                                       'numerical length e.g. 24.\\n'\n                                       'Second value is the time unit e.g. h '\n                                       'for hour. The second option is '\n                                       'optional and if not given'\n                                       'the time unit is set to hours.\\n'\n                                       'The time unit has to be one of the '\n                                       'following values:\\n'\n                                       'y - year\\n'\n                                       'd - day\\n'\n                                       'h - hour\\n'\n                                       'm - minute\\n'\n                                       's - second\\n'\n                                       'Default is 1 hour',\n                        'access': 'list',\n                        'default_value': None},\n\n                    3: {'name': 'StartTime',\n                        'description': 'Sets the start time for the '\n                                       'simulation.\\n'\n                                       'The input should be a list with three '\n                                       'values. The first value is the day. '\n                                       'Second value is the month. '\n                                       'Third value is the year.\\n'\n                                       'All values should be integers and they '\n                                       'all start from 1.\\n'\n                                       'Default is 01-01-[current year]',\n                        'access': 'list',\n                        'default_value': [1, 1, datetime.datetime.now().year]},\n\n                    4: {'name': 'SolverTolerance',\n                        'description': 'Solver tolerance\\nDefault is 1e-8',\n                        'access': 'item',\n                        'default_value': None},\n                    }\n\n        def outputs():\n            return {0: component.outputs('readme'),\n\n                    1: {'name': 'ChosenSolverSettings',\n                        'description': 'Shows the chosen solver settings'},\n\n                    2: {'name': 'SolverSettings',\n                        'description': 'Livestock Solver Settings'}}\n\n        # Component Config\n        self.inputs = inputs()\n        self.outputs = outputs()\n        self.component_number = 21\n        self.description = 'Sets the solver settings for CMF Solve'\n        self.checks = [False, False, False, False]\n        self.results = None\n\n        # Data Parameters\n        self.length = None\n        self.time_step = None\n        self.tolerance = None\n        self.start_time = None\n        self.settings = None\n        self.settings_dict = None\n\n    def check_inputs(self):\n        \"\"\"\n        Checks inputs and raises a warning if an input is not the correct type.\n        \"\"\"\n\n        self.checks = True\n\n    def config(self):\n        \"\"\"Generates the Grasshopper component.\"\"\"\n\n        # Generate Component\n        self.config_component(self.component_number)\n\n    def run_checks(self, length, time_step, start_time, tolerance):\n        \"\"\"\n        Gathers the inputs and checks them.\n\n        :param length: Number of time steps to be taken.\n        :param time_step: Size of time step.\n        :param tolerance: Solver tolerance.\n        :param start_time: Solver start time.\n        \"\"\"\n\n        # Gather data\n        self.length = self.add_default_value(length, 1)\n        self.time_step = self.add_default_value(time_step, 2)\n        self.start_time = self.add_default_value(start_time, 3)\n        self.tolerance = self.add_default_value(tolerance, 4)\n        self.modified_settings()\n\n        # Run checks\n        self.check_inputs()\n\n    def modified_settings(self):\n\n        if self.length:\n            if len(self.length) == 1:\n                self.length[0] = int(self.length[0])\n                self.length.append('h')\n\n            elif len(self.length) == 2:\n                self.length[0] = int(self.length[0])\n\n        if self.time_step:\n            if len(self.time_step) == 1:\n                self.time_step[0] = int(self.time_step[0])\n                self.time_step.append('h')\n\n            elif len(self.time_step) == 2:\n                self.time_step[0] = int(self.time_step[0])\n\n        self.start_time = {'day': int(self.start_time[0]),\n                           'month': int(self.start_time[1]),\n                           'year': int(self.start_time[2])}\n\n        self.settings = {'analysis_length': self.length,\n                         'time_step': self.time_step,\n                         'start_time': self.start_time,\n                         'tolerance': self.tolerance\n                         }\n\n    def run(self):\n        \"\"\"\n        In case all the checks have passed the component runs.\n        Constructs a solver settings dict, prints it and passes it on with\n        PassClass.\n        \"\"\"\n\n        if self.checks:\n            self.settings_dict = cmf_lib.default_solver_settings(self.settings)\n            self.results = gh_misc.PassClass(self.settings_dict,\n                                             'SolverSettings')\n\n\nclass CMFSurfaceFluxResult(GHComponent):\n    \"\"\"A component class that visualizes the surface fluxes from a CMF case.\"\"\"\n\n    def __init__(self, ghenv):\n        GHComponent.__init__(self, ghenv)\n\n        def inputs():\n            return {0: {'name': 'ResultFolder',\n                        'description': 'Path to result folder. Accepts output from Livestock Solve',\n                        'access': 'item',\n                        'default_value': None},\n\n                    1: {'name': 'Mesh',\n                        'description': 'Mesh of the case',\n                        'access': 'item',\n                        'default_value': None},\n\n                    2: {'name': 'IncludeRunOff',\n                        'description': 'Include surface run-off into the surface flux vector? '\n                                       '\\nDefault is set to True',\n                        'access': 'item',\n                        'default_value': True},\n\n                    3: {'name': 'IncludeRain',\n                        'description': 'Include rain into the surface flux vector?'\n                                       '\\nDefault is False.',\n                        'access': 'item',\n                        'default_value': False},\n\n                    4: {'name': 'IncludeEvapotranspiration',\n                        'description': 'Include evapotranspiration into the surface flux vector? '\n                                       '\\nDefault is set to False',\n                        'access': 'item',\n                        'default_value': False},\n\n                    5: {'name': 'IncludeInfiltration',\n                        'description': 'Include infiltration into the surface flux vector? '\n                                       '\\nDefault is set to False',\n                        'access': 'item',\n                        'default_value': False},\n\n                    6: {'name': 'SaveResult',\n                        'description': 'Save the values as a text file - Default is set to False',\n                        'access': 'item',\n                        'default_value': False},\n\n                    7: {'name': 'Write',\n                        'description': 'Write component files',\n                        'access': 'item',\n                        'default_value': False},\n\n                    8: {'name': 'Run',\n                        'description': 'Run component',\n                        'access': 'item',\n                        'default_value': False}}\n\n        def outputs():\n            return {0: {'name': 'readMe!',\n                        'description': 'In case of any errors, it will be shown here.'},\n\n                    1: {'name': 'Unit',\n                        'description': 'Shows the units of the results'},\n\n                    2: {'name': 'SurfaceFluxVectors',\n                        'description': 'Tree with the surface flux vectors'},\n\n                    3: {'name': 'CSVPath',\n                        'description': 'Path to csv file.'}}\n\n        self.inputs = inputs()\n        self.outputs = outputs()\n        self.component_number = 25\n        self.description = 'Visualize the surface fluxes from a CMF case.'\n        self.unit = 'm3/day'\n        self.mesh = None\n        self.path = None\n        self.run_off = None\n        self.rain = None\n        self.evapo = None\n        self.infiltration = None\n        self.save_result = None\n        self.write_files = None\n        self.run_component = None\n        self.py_exe = gh_misc.get_python_exe()\n        self.checks = False\n        self.results = None\n        self.result_path = None\n\n    def check_inputs(self):\n        \"\"\"Checks inputs and raises a warning if an input is not the correct type.\"\"\"\n\n        if self.path:\n            self.checks = True\n        else:\n            warning = 'Insert result path'\n            self.add_warning(warning)\n\n    def config(self):\n        \"\"\"Generates the Grasshopper component.\"\"\"\n\n        # Generate Component\n        self.config_component(self.component_number)\n\n    def run_checks(self, path, mesh, run_off, rain, evapo, infiltration, save,\n                   write, run):\n        \"\"\"\n        Gathers the inputs and checks them.\n\n        :param path: Path for result file.\n        :param mesh: Case mesh\n        :param run_off: Whether to include run-off or not.\n        :param rain: Whether to include rain or not.\n        :param evapo: Whether to include evapotranspiration or not.\n        :param infiltration: Whether to include infiltration or not.\n        :param save: Save result to file or not\n        :param write: Write component files or not\n        :param run: Run component or not.\n        \"\"\"\n\n        # Gather data\n        self.path = path\n        self.mesh = mesh\n        self.run_off = self.add_default_value(run_off, 2)\n        self.rain = self.add_default_value(rain, 3)\n        self.evapo = self.add_default_value(evapo, 4)\n        self.infiltration = self.add_default_value(infiltration, 5)\n        self.save_result = self.add_default_value(save, 6)\n        self.write_files = self.add_default_value(write, 7)\n        self.run_component = self.add_default_value(run, 8)\n        self.result_path = self.path + '/surface_flux_result.txt'\n\n        # Run checks\n        self.check_inputs()\n\n    def run_template(self):\n        \"\"\"Spawns a subprocess that runs the template.\"\"\"\n\n        # Run template\n        thread = subprocess.Popen(\n            [self.py_exe, self.path + '/cmf_surface_results_template.py'])\n        thread.wait()\n        thread.kill()\n\n    def write(self):\n        \"\"\"Writes the wanted information from the mesh and the flux configurations.\"\"\"\n\n        # helper functions\n        def process_mesh(mesh_, path_):\n            points = rs.MeshFaceCenters(mesh_)\n\n            point_obj = open(path_ + '/center_points.txt', 'w')\n            for point in points:\n                point_obj.write(','.join(str(element)\n                                         for element in point) + '\\n'\n                                )\n\n            point_obj.close()\n\n            return True\n\n        def flux_config(path_, run_off, rain, evapo, infiltration):\n            flux_obj = open(path_ + '/flux_config.txt', 'w')\n            flux_obj.write(str(run_off) + '\\n')\n            flux_obj.write(str(rain) + '\\n')\n            flux_obj.write(str(evapo) + '\\n')\n            flux_obj.write(str(infiltration) + '\\n')\n            flux_obj.close()\n\n            return True\n\n        process_mesh(self.mesh, self.path)\n        flux_config(self.path, self.run_off, self.rain, self.evapo,\n                    self.infiltration)\n        # Write template\n        pick_template('cmf_surface_results', self.path)\n\n        return True\n\n    def load_result(self):\n        \"\"\"Loads the results.\"\"\"\n\n        # Helper functions\n        def convert_file_to_points(file_lines):\n            point_list = []\n            for line_ in file_lines:\n                point_list.append(convert_line_to_points(line_.strip()))\n\n            return point_list\n\n        def convert_line_to_points(line_):\n            points_ = []\n            for element in line_.split('\\t'):\n                x, y, z = element.split(',')\n                points_.append(rg.Point3d(float(x), float(y), float(z)))\n\n            return points_\n\n        result_obj = open(self.result_path, 'r')\n        result_lines = result_obj.readlines()\n        results = convert_file_to_points(result_lines)\n        result_obj.close()\n\n        return results\n\n    def delete_files(self):\n        \"\"\"Deletes the helper files.\"\"\"\n\n        if os.path.exists(self.path + '/flux_config.txt'):\n            os.remove(self.path + '/flux_config.txt')\n\n        if os.path.exists(self.path + '/center_points.txt'):\n            os.remove(self.path + '/center_points.txt')\n\n        if os.path.exists(self.path + '/cmf_surface_results_template.py'):\n            os.remove(self.path + '/cmf_surface_results_template.py')\n\n        if not self.save_result:\n            os.remove(self.result_path)\n\n    def run(self):\n        \"\"\"\n        | In case all the checks have passed and Write is True the component writes the component files.\n        | In case all the checks have passed the component runs.\n        | The following functions are run:\n        | write()\n        | run_template()\n        | load_results()\n        | delete_files()\n        | The results are converted into a Grasshopper Tree structure.\n\n        \"\"\"\n\n        if self.checks and self.write_files:\n            self.write()\n\n        if self.checks and self.run_component:\n            self.run_template()\n            self.results = gh_misc.list_to_tree(self.load_result())\n            self.delete_files()\n\n\nclass CMFOutlet(GHComponent):\n    \"\"\"A component class that creates a CMF Outlet.\"\"\"\n\n    def __init__(self, ghenv):\n        GHComponent.__init__(self, ghenv)\n\n        def inputs():\n            return {0: {'name': 'Location',\n                        'description': 'Location of the outlet in x, y and z coordinates.\\n'\n                                       'Default is 0,0,0',\n                        'access': 'item',\n                        'default_value': [0, 0, 0]},\n\n                    1: {'name': 'ConnectedCell',\n                        'description': 'Cell to connect to.\\n'\n                                       'Default is set to first cell',\n                        'access': 'item',\n                        'default_value': 0},\n\n                    2: {'name': 'ConnectedLayer',\n                        'description': 'Layer of cell to connect to.\\n'\n                                       '0 is surface water.\\n'\n                                       '1 is first layer of cell and so on.\\n'\n                                       'Default is set to 0 - surface water',\n                        'access': 'item',\n                        'default_value': 0},\n\n                    3: {'name': 'OutletType',\n                        'description': 'Set type of outlet connection.\\n'\n                                       '1 - Richards.\\n'\n                                       '2 - Kinematic wave.\\n'\n                                       '3 - Technical Flux.',\n                        'access': 'item',\n                        'default_value': None},\n\n                    4: {'name': 'ConnectionParameter',\n                        'description': 'If Richards:\\n'\n                                       '    Potential - Sets the potential of the outlet. The difference in potential'\n                                       ' is what drives the flux.\\n'\n                                       'If Kinematic wave:\\n'\n                                       '    Residence Time - Linear flow parameter of travel time in days.\\n'\n                                       'If Technical Flux:\\n'\n                                       '    Maximum Flux - The maximum flux is in m3/day.',\n                        'access': 'item',\n                        'default_value': None}\n\n                    }\n\n        def outputs():\n            return {0: {'name': 'readMe!',\n                        'description': 'In case of any errors, it will be shown here.'},\n\n                    1: {'name': 'BoundaryCondition',\n                        'description': 'Livestock Boundary Condition'}\n                    }\n\n        self.inputs = inputs()\n        self.outputs = outputs()\n        self.description = 'Create a CMF Outlet'\n        self.component_number = 29\n        self.location = None\n        self.cell = None\n        self.layer = None\n        self.outlet_type = None\n        self.parameter = None\n        self.checks = False\n        self.results = None\n\n    def check_inputs(self):\n        \"\"\"Checks inputs and raises a warning if an input is not the correct type.\"\"\"\n\n        if self.outlet_type and self.parameter:\n            self.checks = True\n\n    def config(self):\n        \"\"\"Generates the Grasshopper component.\"\"\"\n\n        # Generate Component\n        self.config_component(self.component_number)\n\n    def run_checks(self, location, cell, layer, type_, type_parameter):\n        \"\"\"\n        Gathers the inputs and checks them.\n\n        :param location: Location of the cell\n        :param cell: Cell to connect to. Default is set to first cell\n        :param layer: Layer of cell to connect to. 0 is surface water.\n        :param type_: Type of connection from CMF Outlet Type\n        :param type_parameter: Parameter for the connection type.\n        \"\"\"\n\n        # Gather data\n        self.location = self.add_default_value(location, 0)\n        self.cell = self.add_default_value(int(cell), 1)\n        self.layer = self.add_default_value(int(layer), 2)\n        self.outlet_type = self.add_default_value(type_, 3)\n        self.parameter = self.add_default_value(type_parameter, 4)\n\n        # Run checks\n        self.check_inputs()\n\n    def location_to_string(self):\n        \"\"\"\n        Converts the location to a string.\n\n        :return: The location as a comma separated string\n        :rtype: str\n        \"\"\"\n\n        if isinstance(self.location, str):\n            return self.location\n\n        else:\n            location_string = ','.join([str(v)\n                                        for v in self.location])\n            return location_string\n\n    def type_to_connection(self):\n        if self.outlet_type == 1:\n            return 'richards'\n\n        elif self.outlet_type == 2:\n            return 'kinematic_wave'\n\n        elif self.outlet_type == 3:\n            return 'technical_flux'\n\n    def set_outlet_connection(self):\n        \"\"\"Constructs a dict with outlet information.\"\"\"\n\n        return {'connection': self.type_to_connection(),\n                'connection_parameter': self.parameter}\n\n    def set_outlet(self):\n        \"\"\"Constructs a dict with outlet information.\"\"\"\n\n        self.results = gh_misc.PassClass({'type': 'outlet',\n                                          'location': self.location_to_string(),\n                                          'cell': self.cell,\n                                          'layer': self.layer,\n                                          'outlet_type': self.set_outlet_connection(),\n                                          },\n                                         'BoundaryCondition')\n\n        pp = pprint.PrettyPrinter(indent=1, width=50)\n        pp.pprint(self.results.c)\n\n    def run(self):\n        \"\"\"\n        | In case all the checks have passed the component runs.\n        | It runs set_outlet().\n\n        \"\"\"\n\n        if self.checks:\n            self.set_outlet()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}