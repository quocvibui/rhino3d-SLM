{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_BrepFace_detachEdgeLoop.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_BrepFace_detachEdgeLoop.py",
  "instruction": "Spb brep face detach edge loop",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n181009-10: Created.\r\n181026: Fixed bug in surface output.\r\n190413: Added reference to replace local function.\r\n200618: Added PerFaceColor support for V7.\r\n250222: Added command options.\r\n250224: Bug fixes.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bDetachAll'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAllSimilar'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDupCrvsOnSrfBorders'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fMinSegLengthToKeep'; keys.append(key)\r\n    values[key] = 2.0 * sc.doc.ModelAbsoluteTolerance\r\n    #value = 1e-3 * Rhino.RhinoMath.UnitScale(\r\n    #    Rhino.UnitSystem.Millimeters,\r\n    #    sc.doc.ModelUnitSystem)\r\n    #values[key] = float(format(value, '.0e'))\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'fJoinTol'; keys.append(key)\r\n    value = 1e-6 * Rhino.RhinoMath.UnitScale(\r\n        Rhino.UnitSystem.Millimeters,\r\n        sc.doc.ModelUnitSystem)\r\n    values[key] = float(format(value, '.0e'))\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key in ('fJoinTol', 'fMinSegLengthToKeep'):\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < Rhino.RhinoMath.ZeroTolerance:\r\n                cls.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.listValues:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = idxList\r\n\r\n        print(\"Invalid key?\")\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get faces or edges.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    idxs_Opts = {}\r\n\r\n    def addOption(key): idxs_Opts[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opts.clear()\r\n\r\n        addOption('bDetachAll')\r\n        if not Opts.values['bDetachAll']:\r\n            addOption('bAllSimilar')\r\n        addOption('bDupCrvsOnSrfBorders')\r\n        addOption('fMinSegLengthToKeep')\r\n        addOption('fJoinTol')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        if Opts.values['bDetachAll']:\r\n            go.SubObjectSelect = False\r\n            go.SetCommandPrompt(\"Select face to untrim\")\r\n            go.GeometryFilter = rd.ObjectType.Surface\r\n            go.GeometryAttributeFilter = ri.Custom.GeometryAttributeFilter.TrimmedSurface\r\n        else:\r\n            go.SubObjectSelect = True\r\n            go.SetCommandPrompt(\"Select edge of loop to detach\")\r\n            go.GeometryFilter = rd.ObjectType.EdgeFilter\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opts:\r\n            if go.Option().Index == idxs_Opts[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef brep_GUIDs_and_indices_of_trims_from_objrefs(objrefs):\r\n    gBreps = []\r\n    idx_Trims_per_brep = []\r\n\r\n    for objref in objrefs:\r\n        idx_rgTrim = objref.GeometryComponentIndex.Index\r\n        gBrep = objref.ObjectId\r\n\r\n        if not gBrep in gBreps:\r\n            gBreps.append(gBrep)\r\n            idx_Trims_per_brep.append([idx_rgTrim])\r\n        else:\r\n            idx_Trims_per_brep[gBreps.index(gBrep)].append(idx_rgTrim)\r\n\r\n    return (\r\n        gBreps,\r\n        idx_Trims_per_brep,\r\n        )\r\n\r\n\r\ndef printBrepElementCounts(rgBrep):\r\n    \r\n    print('-'*10)\r\n    sEval = 'rgBrep.Surfaces.Count'; print(sEval+':', eval(sEval))\r\n    sEval = 'rgBrep.Faces.Count'; print(sEval+':', eval(sEval))\r\n    sEval = 'rgBrep.Curves2D.Count'; print(sEval+':', eval(sEval))\r\n    sEval = 'rgBrep.Curves3D.Count'; print(sEval+':', eval(sEval))\r\n    sEval = 'rgBrep.Loops.Count'; print(sEval+':', eval(sEval))\r\n    sEval = 'rgBrep.Trims.Count'; print(sEval+':', eval(sEval))\r\n    sEval = 'rgBrep.Edges.Count'; print(sEval+':', eval(sEval))\r\n    sEval = 'rgBrep.Vertices.Count'; print(sEval+':', eval(sEval))\r\n    print('-'*30)\r\n\r\n\r\ndef duplicateBrepPerLoops(rgBrep_In, idxLoops_ToDetach, bEcho=None, bDebug=None):\r\n    \r\n    if bEcho is None: bEcho = Opts.values['bEcho']\r\n    if bDebug is None: bDebug = Opts.values['bDebug']\r\n    \r\n    if bDebug: print(\"Make blank Brep.\")\r\n    \r\n    rgB_Out = rg.Brep()\r\n    \r\n    #printBrepElementCounts(rgB_Out)\r\n    \r\n    # Outer loop.\r\n    \r\n    for idxLoop_ToDetach in idxLoops_ToDetach:\r\n        rgF_In = rgBrep_In.Faces[0]\r\n        if rgBrep_In.Loops[idxLoop_ToDetach].LoopType == rg.BrepLoopType.Outer:\r\n            if bDebug: print(\"Add Face directly from Surface, including its outer loop.\")\r\n            rgF_B_Out = rgB_Out.Faces.Add(rgF_In.DuplicateSurface())\r\n            break\r\n    else:\r\n        if bDebug: print(\"Add Surface.\")\r\n        idxSurface = rgB_Out.AddSurface(rgF_In.DuplicateSurface())\r\n        if bDebug: print(\"Add Face.\")\r\n        rgF_B_Out = rgB_Out.Faces.Add(idxSurface)\r\n\r\n    if Rhino.RhinoApp.ExeVersion >= 7:\r\n        rgF_B_Out.PerFaceColor = rgF_In.PerFaceColor\r\n\r\n\r\n    if bDebug: printBrepElementCounts(rgB_Out)\r\n    \r\n    if bDebug: print(\"Loop through loops, building Brep.\")\r\n    \r\n    # Order of B0 lists will correspond those of B1.\r\n    idx_Crvs2d_B0 = []\r\n    idx_Crvs2d_B1 = []\r\n    \r\n    idx_Crvs3d_B0 = []\r\n    idx_Crvs3d_B1 = []\r\n    \r\n    idxVertices_B0 = []\r\n    idxVertices_B1 = []\r\n    \r\n    idx_Edges_B0 = []\r\n    idx_Edges_B1 = []\r\n    \r\n    idx_Trims_B0 = []\r\n    idx_Trims_B1 = []\r\n    \r\n    for iL, rgLoop_B0 in enumerate(rgBrep_In.Loops):\r\n        if bDebug: print(\"Loop {}:\".format(iL))\r\n        if rgLoop_B0.LoopIndex in idxLoops_ToDetach:\r\n            if bDebug: print(\"This loop will no be copied.  Continue to next loop.\")\r\n            continue\r\n        \r\n        if (\r\n                rgLoop_B0.LoopType == rg.BrepLoopType.Outer\r\n                and\r\n                rgB_Out.Loops.Count > 0\r\n        ):\r\n            if bDebug: print(\"Outer loop is already in rgB_Out.  Continue to next loop.\")\r\n            continue\r\n        \r\n        if bDebug: print(\"Copy all related Brep elements of this loop to Brep1.\")\r\n        \r\n        if bDebug: print(\"Add Loop.\")\r\n        rgLoop_B1 = rgB_Out.Loops.Add(rgLoop_B0.LoopType, rgB_Out.Faces[0])\r\n        \r\n        if bDebug: print(\"Loop through Trims in this Loop.\")\r\n        for rgTrim_B0 in rgLoop_B0.Trims:\r\n            idxTrim_B0 = rgTrim_B0.TrimIndex\r\n            idx_Trims_B0.append(idxTrim_B0)\r\n            rgEdge_B0 = rgTrim_B0.Edge\r\n            idxEdge_B0 = rgEdge_B0.EdgeIndex\r\n            \r\n            if idxEdge_B0 not in idx_Edges_B0:\r\n                idx_Edges_B0.append(idxEdge_B0)\r\n                rgEdge_B1 = idxEdge_B1 = None # to show that Edge needs to be added to Brep1.\r\n            else:\r\n                if bDebug: print(\"Using existing Edge.\")\r\n                idxEdge_B1 = idx_Edges_B1[idx_Edges_B0.index(idxEdge_B0)]\r\n                rgEdge_B1 = rgB_Out.Edges[idxEdge_B1]\r\n            \r\n            if bDebug: print(\"Trim{}  Edge{}:\".format(idxTrim_B0, idxEdge_B0))\r\n            \r\n            if bDebug: print(\"Duplicate and add Curve for Trim.\")\r\n            rgCrv2d_B0 = rgTrim_B0.TrimCurve\r\n            idx_Crvs2d_B0.append(rgTrim_B0.TrimCurveIndex)\r\n            rgCrv2d_B1 = rgCrv2d_B0.Duplicate()\r\n            idxCrv2d_B1 = rgB_Out.Curves2D.Add(rgCrv2d_B1)\r\n            idx_Crvs2d_B1.append(idxCrv2d_B1)\r\n            \r\n            \r\n            if bDebug: print(\"Duplicate and add Curve for Edge.\")\r\n            idxCrv3d_B0 = rgEdge_B0.EdgeCurveIndex\r\n            if idxCrv3d_B0 not in idx_Crvs3d_B0:\r\n                idx_Crvs3d_B0.append(idxCrv3d_B0)\r\n                rgCrv3d_B0 = rgEdge_B0.EdgeCurve\r\n                rgCrv3d_B1 = rgCrv3d_B0.Duplicate()\r\n                idxCrv3d_B1 = rgB_Out.Curves3D.Add(rgCrv3d_B1)\r\n                idx_Crvs3d_B1.append(idxCrv3d_B1)\r\n            else:\r\n                if bDebug: print(\"Using existing Curve for Edge.\")\r\n            \r\n            if bDebug: print(\"Process Start Vertex of Trim.\")\r\n            rgVertex_TrimStart_B0 = rgTrim_B0.StartVertex\r\n            idxVertex_TrimStart_B0 = rgVertex_TrimStart_B0.VertexIndex\r\n            if idxVertex_TrimStart_B0 not in idxVertices_B0:\r\n                if bDebug: print(\"Add Vertex.\")\r\n                idxVertices_B0.append(idxVertex_TrimStart_B0)\r\n                rgVertex_TrimStart_B1 = rgB_Out.Vertices.Add(rgVertex_TrimStart_B0.Location, vertexTolerance=sc.doc.ModelAbsoluteTolerance)\r\n                idxVertex_TrimStart_B1 = rgVertex_TrimStart_B1.VertexIndex\r\n                idxVertices_B1.append(idxVertex_TrimStart_B1)\r\n            else:\r\n                if bDebug: print(\"Using existing Vertex.\")\r\n                idxVertex_TrimStart_B1 = idxVertices_B1[idxVertices_B0.index(idxVertex_TrimStart_B0)]\r\n            \r\n            if bDebug: print(\"Process End Vertex of Trim.\")\r\n            rgVertex_TrimEnd_B0 = rgTrim_B0.EndVertex\r\n            idxVertex_TrimEnd_B0 = rgVertex_TrimEnd_B0.VertexIndex\r\n            if idxVertex_TrimEnd_B0 not in idxVertices_B0:\r\n                if bDebug: print(\"Add Vertex.\")\r\n                idxVertices_B0.append(idxVertex_TrimEnd_B0)\r\n                rgVertex_TrimEnd_B1 = rgB_Out.Vertices.Add(rgVertex_TrimEnd_B0.Location, vertexTolerance=sc.doc.ModelAbsoluteTolerance)\r\n                idxVertex_TrimEnd_B1 = rgVertex_TrimEnd_B1.VertexIndex\r\n                idxVertices_B1.append(idxVertex_TrimEnd_B1)\r\n            else:\r\n                if bDebug: print(\"Using existing Vertex.\")\r\n                idxVertex_TrimEnd_B1 = idxVertices_B1[idxVertices_B0.index(idxVertex_TrimEnd_B0)]\r\n            \r\n            if bDebug: print(\"Determine Start and End Vertices of Edge.\")\r\n            if rgTrim_B0.IsReversed():\r\n                if bDebug: print(\"Trim IS reversed to Edge.\")\r\n                idxVertex_EdgeStart_B1 = idxVertex_TrimEnd_B1\r\n                idxVertex_EdgeEnd_B1 = idxVertex_TrimStart_B1\r\n                rev3d = True\r\n            else:\r\n                if bDebug: print(\"Trim is NOT reversed to Edge.\")\r\n                idxVertex_EdgeStart_B1 = idxVertex_TrimStart_B1\r\n                idxVertex_EdgeEnd_B1 = idxVertex_TrimEnd_B1\r\n                rev3d = False\r\n            \r\n            if idxEdge_B1 is None:\r\n                if bDebug: print(\"Add Edge.\")\r\n                rgEdge_B1 = rgB_Out.Edges.Add(\r\n                        rgB_Out.Vertices[idxVertex_EdgeStart_B1],\r\n                        rgB_Out.Vertices[idxVertex_EdgeEnd_B1],\r\n                        idxCrv3d_B1,\r\n                        rgEdge_B0.Tolerance)\r\n                idxEdge_B1 = rgEdge_B1.EdgeIndex\r\n                idx_Edges_B1.append(idxEdge_B1)\r\n            else:\r\n                if bDebug: print(\"Using existing edge for Trim.\")\r\n            \r\n            if bDebug: print(\"Add Trim.\")\r\n            rgTrim_B1 = rgB_Out.Trims.Add(\r\n                    rgEdge_B1,\r\n                    rev3d=rev3d,\r\n                    loop=rgLoop_B1,\r\n                    curve2dIndex=idxCrv2d_B1)\r\n            idxTrim_B1 = rgTrim_B1.TrimIndex\r\n            idx_Trims_B1.append(idxTrim_B1)\r\n            \r\n            if bDebug: print(\"Set Trim tolerance.\")\r\n            tolU, tolV = rgTrim_B0.GetTolerances()\r\n            #            if bDebug:\r\n            #                sEval = 'tolU'; print(sEval+':', eval(sEval))\r\n            #                sEval = 'tolV'; print(sEval+':', eval(sEval))\r\n            rgTrim_B1.SetTolerances(tolU, tolV)\r\n            #            if bDebug:\r\n            #                tolU, tolV = rgTrim_B1.GetTolerances()\r\n            #                sEval = 'tolU'; print(sEval+':', eval(sEval))\r\n            #                sEval = 'tolV'; print(sEval+':', eval(sEval))\r\n        \r\n            if bDebug: print(\"Set Trim IsoStatus.\")\r\n            rgTrim_B1.IsoStatus = rgTrim_B0.IsoStatus\r\n            if bDebug: sEval = 'rgTrim_B1.IsoStatus'; print(sEval+':', eval(sEval))\r\n    \r\n    if bDebug: printBrepElementCounts(rgB_Out)\r\n    \r\n    return rgB_Out\r\n\r\n\r\ndef isSenw(rgTrim):\r\n    return (rgTrim.IsoStatus == Rhino.Geometry.IsoStatus.South or\r\n            rgTrim.IsoStatus == Rhino.Geometry.IsoStatus.East or\r\n            rgTrim.IsoStatus == Rhino.Geometry.IsoStatus.North or\r\n            rgTrim.IsoStatus == Rhino.Geometry.IsoStatus.West)\r\n\r\n\r\ndef processBrep(gB_In, idx_rgTrims=None, bDetachAll=None, bAllSimilar=None, bDupCrvsOnSrfBorders=None, fMinSegLengthToKeep=None, fJoinTol=None, bEcho=True, bDebug=False):\r\n\r\n    if bDetachAll is None: bDetachAll = Opts.values['bDetachAll']\r\n    if bAllSimilar is None: bAllSimilar = Opts.values['bAllSimilar']\r\n    if bDupCrvsOnSrfBorders is None: bDupCrvsOnSrfBorders = Opts.values['bDupCrvsOnSrfBorders']\r\n    if fMinSegLengthToKeep is None: bDebug = Opts.values['fMinSegLengthToKeep']\r\n    if fJoinTol is None: bDebug = Opts.values['fJoinTol']\r\n    if bEcho is None: bEcho = Opts.values['bEcho']\r\n    if bDebug is None: bDebug = Opts.values['bDebug']\r\n\r\n    def outputUnderlyingSurface():\r\n        \"\"\"\r\n        \"\"\"\r\n        \r\n\r\n        rgF_In = rgBrep_In.Faces[0]\r\n\r\n        srf = rgF_In.UnderlyingSurface()\r\n        if srf is None:\r\n            if bEcho: print(\"Underlying surface cannot be obtained.\")\r\n            return False\r\n        \r\n        if all(bAddCurve_successes):\r\n            rgB_Out = srf.ToBrep()\r\n            if Rhino.RhinoApp.ExeVersion >= 7:\r\n                rgB_Out.Faces[0].PerFaceColor = rgF_In.PerFaceColor\r\n            bAdded = sc.doc.Objects.Replace(gB_In, rgB_Out)\r\n            if not bAdded:\r\n                if bEcho: print(\"Brep could not be replaced with underlying surface.\")\r\n            return bAdded\r\n        else:\r\n            # Not all curves could be added.\r\n            rgB_Out = srf.ToBrep()\r\n            gB_Out = sc.doc.Objects.AddBrep(rgB_Out)\r\n            if gB_Out == Guid.Empty:\r\n                if bEcho: print(\"Underlying surface could not be added to document.\")\r\n                return False\r\n            if bEcho:\r\n                print(\"Underlying surface was added instead of untrimming the face was not untrimmed because not all trim edge curves could be added.\")\r\n            return gB_Out\r\n\r\n    def addCurves():\r\n        \"\"\"\r\n        \"\"\"\r\n        \r\n        def edgesOfLoop():\r\n            \"\"\"\r\n            \"\"\"\r\n            \r\n            rgEdges_ThisLoop = []\r\n            for rgTrim in rgLoop.Trims:\r\n                if rgTrim.TrimType == rg.BrepTrimType.Seam:\r\n                    continue\r\n                elif not bDupCrvsOnSrfBorders and isSenw(rgTrim):\r\n                    continue\r\n                edge = rgTrim.Edge\r\n                if edge is None:\r\n                    raise Exception(\"Edge is None.\")\r\n                    #bAddCurve_successes.append(False)\r\n                    #continue\r\n                if fMinSegLengthToKeep:\r\n                    fLength = edge.GetLength()\r\n                    if fLength < fMinSegLengthToKeep:\r\n                        continue\r\n                bAddCurve_successes.append(True)\r\n                rgEdges_ThisLoop.append(edge)\r\n            return rgEdges_ThisLoop\r\n        \r\n        rgEdges_ThisLoop = edgesOfLoop()\r\n        if rgEdges_ThisLoop is None:\r\n            return\r\n\r\n        i_Crv_cts[0] += len(rgEdges_ThisLoop)\r\n\r\n        rgCrvs_Joined = rg.Curve.JoinCurves(\r\n            rgEdges_ThisLoop,\r\n            joinTolerance=fJoinTol)\r\n\r\n        i_Crv_cts[1] += len(rgCrvs_Joined)\r\n\r\n        for rgCrv in rgCrvs_Joined:\r\n            gCrv = sc.doc.Objects.AddCurve(rgCrv)\r\n            if gCrv == Guid.Empty:\r\n                bAddCurve_successes.append(False)\r\n            else:\r\n                bAddCurve_successes.append(True)\r\n\r\n\r\n    rgBrep_In = rs.coercebrep(gB_In)\r\n    \r\n    if rgBrep_In.IsSurface:\r\n        if bEcho: print(\"Monoface brep is not trimmed.  Its borders are the same as those of its underlying surface.\")\r\n        return\r\n    \r\n    bAddCurve_successes = []\r\n    \r\n    i_Crv_cts = [0, 0] # Before join, After join\r\n    \r\n    if not bDetachAll:\r\n        # Check for bAllSimilar with trims from both Outer and Inner loops selected.\r\n        if bAllSimilar:\r\n            bOuter = any(rgTrim.TrimIndex in idx_rgTrims for rgTrim in rgBrep_In.Faces[0].OuterLoop.Trims)\r\n            if bDebug: sEval = 'bOuter'; print(sEval+':', eval(sEval))\r\n            bInner = any(rgTrim.TrimIndex in idx_rgTrims for rgLoop in rgBrep_In.Loops if rgLoop.LoopType == rg.BrepLoopType.Inner for rgTrim in rgLoop.Trims)\r\n            if bDebug: sEval = 'bInner'; print(sEval+':', eval(sEval))\r\n            if bOuter and bInner:\r\n                bDetachAll = True\r\n    \r\n    if bDetachAll:\r\n        for rgLoop in rgBrep_In.Loops:\r\n            addCurves()\r\n        \r\n        print(\"{} joined curves from {} curves added to document.\".format(\r\n                i_Crv_cts[1], i_Crv_cts[0]))\r\n        \r\n        if i_Crv_cts[1]:\r\n            rgB_Res = outputUnderlyingSurface()\r\n    else:\r\n        # Not bDetachAll.\r\n        \r\n        idxLoops_ToDetach = []\r\n        \r\n        if bAllSimilar:\r\n            if bOuter:\r\n                rgLoop = rgBrep_In.Faces[0].OuterLoop\r\n                \r\n                addCurves()\r\n                \r\n                if all(bAddCurve_successes):\r\n                    idxLoops_ToDetach.append(rgLoop.LoopIndex)\r\n            \r\n            if bInner:\r\n                for rgLoop in rgBrep_In.Loops:\r\n                    \r\n                    if rgLoop.LoopType != rg.BrepLoopType.Inner:\r\n                        continue\r\n                    \r\n                    addCurves()\r\n                    \r\n                    if all(bAddCurve_successes):\r\n                        idxLoops_ToDetach.append(rgLoop.LoopIndex)\r\n            \r\n        else:\r\n            # Not bAllSimilar.\r\n            for rgLoop in rgBrep_In.Loops:\r\n                \r\n                for rgTrim in rgLoop.Trims:\r\n                    if rgTrim.TrimIndex in idx_rgTrims:\r\n                        # Detach this loop.\r\n                        break\r\n                else:\r\n                    # No given trims found in this loop.\r\n                    continue # to next loop.\r\n                \r\n                addCurves()\r\n                \r\n                if all(bAddCurve_successes):\r\n                    idxLoops_ToDetach.append(rgLoop.LoopIndex)\r\n        \r\n        print(\"{} joined curves from {} curves added to document.\".format(\r\n            i_Crv_cts[1], i_Crv_cts[0]))\r\n        \r\n        if not i_Crv_cts[1]:\r\n            if bEcho: print(\"Brep was not modified.\")\r\n            return\r\n        \r\n        # If all loops were selected, then output the entire underlying surface.\r\n        if len(idxLoops_ToDetach) == rgBrep_In.Loops.Count:\r\n            # Detach all trim.\r\n            return outputUnderlyingSurface()\r\n        \r\n        if bDebug: print(\"Create brep with loops removed.\")\r\n        \r\n        rgB_Res = duplicateBrepPerLoops(rgBrep_In, idxLoops_ToDetach)\r\n        \r\n        if rgB_Res is None:\r\n            sEval = 'rgB_Res'; print(sEval+':', eval(sEval))\r\n            return False\r\n        if not rgB_Res.IsValid:\r\n            sEval = 'rgB_Res.IsValid'; print(sEval+':', eval(sEval))\r\n            b, sLog = rgB_Res.IsValidWithLog()\r\n            if not b: print(sLog)\r\n            return False\r\n        \r\n        if bDebug: sEval = 'rgB_Res.Loops.Count'; print(sEval+':', eval(sEval))\r\n        \r\n        if all(bAddCurve_successes):\r\n            bReplaced = sc.doc.Objects.Replace(gB_In, rgB_Res)\r\n        else:\r\n            gBrep1 = sc.doc.Objects.AddBrep(rgB_Res)\r\n            if gBrep1 == Guid.Empty:\r\n                print(\"Modified brep could not be added to document.\")\r\n                return False\r\n            print(\"Brep was not replaced because all trim edge curves could not be added.\")\r\n            return False\r\n    \r\n    return rgB_Res\r\n\r\n\r\ndef processBreps(gBreps0, idx_Trims_per_brep, bDetachAll=None, bAllSimilar=None, bDupCrvsOnSrfBorders=None, fMinSegLengthToKeep=None, fJoinTol=None, bEcho=True, bDebug=False):\r\n\r\n    i_Success_ct = 0\r\n\r\n    for gB_In, idx_rgTrims in zip(gBreps0, idx_Trims_per_brep):\r\n        if processBrep(\r\n            gB_In,\r\n            idx_rgTrims,\r\n            bDetachAll=bDetachAll,\r\n            bAllSimilar=bAllSimilar,\r\n            bDupCrvsOnSrfBorders=bDupCrvsOnSrfBorders,\r\n            fMinSegLengthToKeep=fMinSegLengthToKeep,\r\n            fJoinTol=fJoinTol,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug\r\n        ):\r\n            i_Success_ct += 1\r\n\r\n    print(\"{} out of {} monoface breps have been untrimmed.\".format(\r\n            i_Success_ct, len(gBreps0)))\r\n\r\n\r\ndef main():\r\n    \r\n    objrefs = getInput()\r\n    if objrefs is None: return\r\n\r\n    rv = brep_GUIDs_and_indices_of_trims_from_objrefs(objrefs)\r\n    if not rv: return\r\n\r\n    (\r\n        gBreps,\r\n        idx_Trims_per_brep,\r\n        ) = rv\r\n\r\n    bDetachAll = Opts.values['bDetachAll']\r\n    bAllSimilar = Opts.values['bAllSimilar']\r\n    bDupCrvsOnSrfBorders = Opts.values['bDupCrvsOnSrfBorders']\r\n    fMinSegLengthToKeep = Opts.values['fMinSegLengthToKeep']\r\n    fJoinTol = Opts.values['fJoinTol']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    processBreps(\r\n        gBreps,\r\n        idx_Trims_per_brep,\r\n        bDetachAll=bDetachAll,\r\n        bAllSimilar=bAllSimilar,\r\n        bDupCrvsOnSrfBorders=bDupCrvsOnSrfBorders,\r\n        fMinSegLengthToKeep=fMinSegLengthToKeep,\r\n        fJoinTol=fJoinTol,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug\r\n        )\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}