{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_splitCrvsAndNakedEdges_mutually.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_splitCrvsAndNakedEdges_mutually.py",
  "instruction": "Behavior notes:\r\n    Wire curves are only split by naked edges and other wire curves, not mated edges or face interiors.\r\n    Naked edges are only split by wire curves.\r\n    Mated edges are not...",
  "code": "\"\"\"\r\nBehavior notes:\r\n    Wire curves are only split by naked edges and other wire curves, not mated edges or face interiors.\r\n    Naked edges are only split by wire curves.\r\n    Mated edges are not split.\r\n    Pressing Enter with no selected input will process all normal (not locked or hidden) curves and breps.\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, print_function, unicode_literals\r\n\r\n\"\"\"\r\n220715-17: Created.\r\n220718: Now includes wire-wire intersections.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport scriptcontext as sc\r\n\r\n\r\nclass _Data:\r\n    def __init__(self):\r\n        self.rdCs = []\r\n        self.rdBs = []\r\n        self.rgNEs_perB = []\r\n        self.pts_Cs = []\r\n        self.pts_NEs_perB = []\r\n        self.devs_X = []\r\n\r\n\r\ndef _getInput():\r\n    \r\n    res, objrefs = Rhino.Input.RhinoGet.GetMultipleObjects(\r\n            \"Select curves and breps <All normal when none are selected>\",\r\n            acceptNothing=True,\r\n            filter=rd.ObjectType.Brep | rd.ObjectType.Curve)\r\n    if res == Rhino.Commands.Result.Cancel:\r\n        return\r\n    elif objrefs:\r\n        return [o.Object() for o in objrefs]\r\n    else:\r\n        iter = rd.ObjectEnumeratorSettings()\r\n        iter.NormalObjects = True\r\n        iter.LockedObjects = False\r\n        iter.ObjectTypeFilter = rd.ObjectType.Brep | rd.ObjectType.Curve\r\n        return [o for o in sc.doc.Objects.GetObjectList(iter)]\r\n\r\n\r\ndef _sortInput(rdObjs, d):\r\n    bFound = False\r\n    \r\n    for rdObj in rdObjs:\r\n        if rdObj.ObjectType == rd.ObjectType.Curve:\r\n            d.rdCs.append(rdObj)\r\n            bFound = True\r\n        else:\r\n            d.rdBs.append(rdObj)\r\n            d.rgNEs_perB.append(\r\n                [rgE for rgE in rdObj.Geometry.Edges\r\n                if rgE.Valence == rg.EdgeAdjacency.Naked])\r\n            bFound = bFound or d.rgNEs_perB[-1]\r\n    \r\n    return bFound\r\n\r\n\r\ndef buildEmptyPtLists(d):\r\n    \r\n    for i, rdC in enumerate(d.rdCs):\r\n        d.pts_Cs.append([])\r\n    \r\n    for i, rgNEs in enumerate(d.rgNEs_perB):\r\n        d.pts_NEs_perB.append([[] for _ in xrange(len(rgNEs))])\r\n\r\n\r\ndef _getIntPts_WireEdge(d):\r\n\r\n    bFound = False\r\n\r\n    for iC, rdC in enumerate(d.rdCs):\r\n        rgC = rdC.Geometry\r\n        for iNEs, rgNEs in enumerate(d.rgNEs_perB):\r\n            for iNE, rgNE in enumerate(rgNEs):\r\n                ie = rg.Intersect.Intersection.CurveCurve(\r\n                    curveA=rgC,\r\n                    curveB=rgNE,\r\n                    tolerance=sc.doc.ModelAbsoluteTolerance,\r\n                    overlapTolerance=0.0)\r\n                if ie.Count == 0:\r\n                    continue\r\n                for iie in xrange(ie.Count):\r\n                    if ie[iie].IsOverlap:\r\n                        print(\"Overlap interesection was created and will be ignored.\")\r\n                        continue\r\n                    d.pts_Cs[iC].append(ie[iie].PointA)\r\n                    d.pts_NEs_perB[iNEs][iNE].append(ie[iie].PointB)\r\n                    d.devs_X.append(ie[iie].PointA.DistanceTo(ie[iie].PointB))\r\n                bFound = True\r\n\r\n    return bFound\r\n\r\n\r\ndef _getIntPts_WireWire(d):\r\n\r\n    bFound = False\r\n\r\n    for iCA in xrange(len(d.rdCs)-1):\r\n        rdCA = d.rdCs[iCA]\r\n        rgCA = rdCA.Geometry\r\n        for iCB in xrange(iCA+1, len(d.rdCs)):\r\n            rdCB = d.rdCs[iCB]\r\n            rgCB = rdCB.Geometry\r\n\r\n            ie = rg.Intersect.Intersection.CurveCurve(\r\n                curveA=rgCA,\r\n                curveB=rgCB,\r\n                tolerance=sc.doc.ModelAbsoluteTolerance,\r\n                overlapTolerance=0.0)\r\n            if ie.Count == 0:\r\n                continue\r\n            for iie in xrange(ie.Count):\r\n                if ie[iie].IsOverlap:\r\n                    print(\"Overlap interesection was created and will be ignored.\")\r\n                    continue\r\n                d.pts_Cs[iCA].append(ie[iie].PointA)\r\n                d.pts_Cs[iCB].append(ie[iie].PointB)\r\n                d.devs_X.append(ie[iie].PointA.DistanceTo(ie[iie].PointB))\r\n            bFound = True\r\n\r\n    return bFound\r\n\r\n\r\ndef _cleanedPointList(pts, rgC, tol=None):\r\n    if tol is None: tol = sc.doc.ModelAbsoluteTolerance\r\n    pts_Out = list(rg.Point3d.CullDuplicates(pts, tolerance=tol))\r\n    \r\n    for i, pt in reversed(list(enumerate(pts_Out))):\r\n        if pt.DistanceTo(rgC.PointAtStart) <= tol:\r\n            del pts_Out[i]\r\n        elif pt.DistanceTo(rgC.PointAtEnd) <= tol:\r\n            del pts_Out[i]\r\n    \r\n    return pts_Out\r\n\r\n\r\ndef _splitCurveObjects(d):\r\n    \r\n    iCt_WereSplit = 0\r\n    iCt_Result = 0\r\n    \r\n    for iC, rdC in enumerate(d.rdCs):\r\n        rgC = rdC.Geometry\r\n        pts = d.pts_Cs[iC]\r\n        if len(pts) == 0: continue\r\n        pts = _cleanedPointList(pts, rgC, tol=sc.doc.ModelAbsoluteTolerance)\r\n        if len(pts) == 0: continue\r\n        ts = [rgC.ClosestPoint(pt)[1] for pt in pts]\r\n        rgCs_Out = rgC.Split(ts)\r\n        if len(rgCs_Out) < 2 and not rgC.IsClosed:\r\n            print(\"Curve {} was not split.\".format(rdC.Id))\r\n        for rgC_Out in rgCs_Out:\r\n            sc.doc.Objects.AddCurve(rgC_Out)\r\n            iCt_Result += 1\r\n        if not sc.doc.Objects.Remove(rdC):\r\n            print(\"Curve {} could not be deleted.\".format(rdC.Id))\r\n        iCt_WereSplit += 1\r\n    \r\n    if iCt_WereSplit == 0:\r\n        print(\"No curves were split.\")\r\n    else:\r\n        print(\"{} curves split into {}.\".format(iCt_WereSplit, iCt_Result))\r\n\r\n\r\ndef _splitNakedEdges(d):\r\n    iCt_WereSplit = 0\r\n    iCt_Result = 0\r\n    \r\n    for iB, rdB in enumerate(d.rdBs):\r\n        rgB = rdB.Geometry\r\n        iCts_Splits_ThisB = 0\r\n        for iE, rgE in enumerate(d.rgNEs_perB[iB]):\r\n            pts = d.pts_NEs_perB[iB][iE]\r\n            if len(pts) == 0: continue\r\n            pts = _cleanedPointList(pts, rgE, tol=sc.doc.ModelAbsoluteTolerance)\r\n            if len(pts) == 0: continue\r\n            ts = [rgE.ClosestPoint(pt)[1] for pt in pts]\r\n            idxE = rgE.EdgeIndex\r\n            iCts_Splits = rgB.Edges.SplitEdgeAtParameters(idxE, ts)\r\n            if iCts_Splits == 0:\r\n                raise Exception(\"Edge was not split.\")\r\n            iCt_Result += iCts_Splits + 1\r\n            iCts_Splits_ThisB += iCt_Result\r\n            iCt_WereSplit += 1\r\n        if iCts_Splits_ThisB == 0: continue\r\n        if not rdB.CommitChanges():\r\n            print(\"Brep {} could not be modified.\".format(rdB.Id))\r\n    \r\n    if iCt_WereSplit == 0:\r\n        print(\"No edges were split.\")\r\n    else:\r\n        print(\"{} edges split into {}.\".format(iCt_WereSplit, iCt_Result))\r\n\r\n\r\ndef main():\r\n    \r\n    rdObjs = _getInput()\r\n    if rdObjs is None: return\r\n    \r\n    d = _Data()\r\n    \r\n    if not _sortInput(rdObjs, d):\r\n        print(\"No curve or edge data in input.\")\r\n        return\r\n    \r\n    buildEmptyPtLists(d)\r\n    \r\n    if not any((_getIntPts_WireEdge(d), _getIntPts_WireWire(d))):\r\n        print(\"No intersections found.\")\r\n        return\r\n    \r\n    _splitCurveObjects(d)\r\n    \r\n    _splitNakedEdges(d)\r\n    \r\n    if max(d.devs_X) >= 0.1*sc.doc.ModelAbsoluteTolerance:\r\n        print(\"Max. intersection pt-pt deviation: {:.{}f}\".format(\r\n            max(d.devs_X), sc.doc.ModelDistanceDisplayPrecision))\r\n    \r\n    sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}