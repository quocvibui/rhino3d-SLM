{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Forward%20Raytracing.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Forward Raytracing.py",
  "instruction": "Use this component to get a sense of how sunlight is reflected by a set of context geometries by tracing sun rays forwards through this geometry.\nExamples where this component might be useful include...",
  "code": "#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Mostapha Sadeghipour Roudsari <mostapha@ladybug.tools> \n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to get a sense of how sunlight is reflected by a set of context geometries by tracing sun rays forwards through this geometry.\nExamples where this component might be useful include the evaluation of the diffusion of light by a light shelf, or testing to see whether a parabolic building geometry (like a Ghery building) might focus sunlight to dangerous levels at certain times of the year.\nNote that this component assumes that all sun light is reflected off of these geometries specularly (as if they were a mirror) and, for more detailed raytrace analysis, the Honeybee daylight components should be used.\n-\nProvided by Ladybug 0.0.69\n    \n    Args:\n        _startPts: Points from which the sun rays will be cast towards the _context geometry.  You may want to connect a grid of points here to mimic the fact that direct sun will be streaming evenly from the sky.\n        _startVectors: A sun vector from the sunPath component or a list of sun vectors to be forward ray-traced.\n        _context: Breps or meshes of conext geometry that will reflect the sun rays.  Note that, for curved surfaces, smooth meshes of the geometry will be more accurate than inputing a Brep.\n        _numOfBounce_: An interger representing the number of ray bounces to trace the sun rays forward.\n        _lastBounceLen_: A float number representing the length in Rhino model units of the light ray after the last bounce.\n    Returns:\n        readMe!: Read erros, comments, suggestions here.\n        rays: A series of line curves representing light rays traced forward through the geometry.\n\"\"\"\n\nghenv.Component.Name = \"Ladybug_Forward Raytracing\"\nghenv.Component.NickName = 'forwardRaytracing'\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"3 | EnvironmentalAnalysis\"\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"0\"\nexcept: pass\n\n\nfrom clr import AddReference\nAddReference('Grasshopper')\nimport Grasshopper.Kernel as gh\nimport Rhino as rc\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\n\ndef main(startPts, startVectors, context, numOfBounce, lastBounceLen):\n    # import the classes\n    if sc.sticky.has_key('ladybug_release'):\n        try:\n            if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): return -1\n            if sc.sticky['ladybug_release'].isInputMissing(ghenv.Component): return -1\n        except:\n            warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n            \"Use updateLadybug component to update userObjects.\\n\" + \\\n            \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n            \"into canvas and try again.\"\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n            return -1\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n        lb_mesh = sc.sticky[\"ladybug_Mesh\"]()\n        lb_runStudy_GH = sc.sticky[\"ladybug_RunAnalysis\"]()\n        lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\n    else:\n        print \"You should first let the Ladybug fly...\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"You should first let the Ladybug fly...\")\n        return -1\n    \n    # A failed attampt to use mesh instead of brep so the component could work with trimmed surfaces\n    if len(context)!=0:\n        ## clean the geometry and bring them to rhinoCommon separated as mesh and Brep\n        contextMesh, contextBrep = lb_preparation.cleanAndCoerceList(context)\n        ## mesh Brep\n        contextMeshedBrep = lb_mesh.parallel_makeContextMesh(contextBrep)\n        \n        ## Flatten the list of surfaces\n        contextMeshedBrep = lb_preparation.flattenList(contextMeshedBrep)\n        contextSrfs = contextMesh + contextMeshedBrep\n        joinedContext = lb_mesh.joinMesh(contextSrfs)\n        \n        \n    # Get rid of trimmed parts\n    cleanBrep = rc.Geometry.Brep.CreateFromMesh(joinedContext, False)\n    \n    rays = []\n    for testPt in startPts:\n        for vector in startVectors:\n            vector.Unitize()\n            ray = rc.Geometry.Ray3d(testPt, vector)\n            if numOfBounce>0:\n                intPts = rc.Geometry.Intersect.Intersection.RayShoot(ray, [cleanBrep], numOfBounce)\n                #print intPts\n                if intPts:\n                    ptList = [testPt]\n                    ptList.extend(intPts)\n                    ray = rc.Geometry.Polyline(ptList).ToNurbsCurve()\n                    \n                    try:\n                        # create last ray\n                        # calculate plane at intersection\n                        intNormal = cleanBrep.ClosestPoint(intPts[-1], sc.doc.ModelAbsoluteTolerance)[5]\n                        \n                        lastVector = rc.Geometry.Vector3d(ptList[-2] - ptList[-1])\n                        lastVector.Unitize()\n                        \n                        crossProductNormal = rc.Geometry.Vector3d.CrossProduct(intNormal, lastVector)\n                        \n                        plane = rc.Geometry.Plane(intPts[-1], intNormal, crossProductNormal)\n                        \n                        mirrorT = rc.Geometry.Transform.Mirror(intPts[-1], plane.Normal)\n                        \n                        lastRay = rc.Geometry.Line(intPts[-1], lastBounceLen * lastVector).ToNurbsCurve()\n                        lastRay.Transform(mirrorT)\n                        \n                        ray = rc.Geometry.Curve.JoinCurves([ray, lastRay])[0]\n                    except:\n                        pass\n                        \n                    rays.append(ray)\n                else:\n                    # no bounce so let's just create a line form the point\n                    firstRay = rc.Geometry.Line(testPt, lastBounceLen * vector).ToNurbsCurve()\n                    rays.append(firstRay)\n                    \n    if len(rays) == 0:\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, \"No reflection!\")\n    return rays\n\nif (_startPts and _startPts[0]!=None) and (_startVectors and _startVectors[0]!=None) and (_context and _context[0]!=None):\n    rays = main(_startPts, _startVectors, _context, _numOfBounce_, _lastBounceLen_)\nelif _startPts == [] and _startVectors == [] and _context == []:\n    print \"Provide start points, start vectors and context.\"\nelse:\n    #print _startPts\n    print \"Provide valid start points, start vectors and context...\"\n    ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, \"Provide start points, start vectors and context...\")\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}