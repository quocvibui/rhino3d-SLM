{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_sheathing_generator.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_sheathing_generator.py",
  "instruction": "Sheathing Generator for Grasshopper.",
  "code": "# File: scripts/gh_sheathing_generator.py\n\"\"\"Sheathing Generator for Grasshopper.\n\nGenerates sheathing panel layouts for walls with proper panel sizing,\njoint staggering, and opening cutouts. Outputs JSON data with panel\npositions and a material summary for takeoff calculations.\n\nKey Features:\n1. Material Selection\n   - Structural plywood (7/16\", 15/32\", 1/2\", 19/32\")\n   - OSB (7/16\", 1/2\")\n   - Gypsum board (1/2\", 5/8\")\n   - DensGlass exterior sheathing\n\n2. Panel Layout\n   - Standard panel sizes (4x8, 4x9, 4x10, 4x12)\n   - Automatic joint staggering between rows\n   - Configurable minimum piece width\n\n3. Opening Handling\n   - Automatic cutouts for windows and doors\n   - Cutout bounds clipped to panel edges\n   - Waste calculation including cutouts\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n\nDependencies:\n    - Grasshopper: Component framework\n    - json: Serialization\n    - timber_framing_generator.sheathing: Sheathing generation logic\n\nPerformance Considerations:\n    - Processing time scales with wall count and panel density\n    - Large walls with many openings may have more cutout calculations\n    - JSON output size proportional to panel count\n\nUsage:\n    1. Connect 'walls_json' from Wall Analyzer component\n    2. Optionally configure material and panel size via 'config_json'\n    3. Set 'run' to True to execute\n    4. Collect 'sheathing_json' for downstream processing\n    5. View 'summary' for material quantities\n\nInput Requirements:\n    Walls JSON (walls_json) - str:\n        JSON string from Wall Analyzer with wall geometry data\n        Required: Yes\n        Access: Item\n\n    Junctions JSON (junctions_json) - str:\n        Optional JSON from Junction Analyzer with per-layer adjustments.\n        When connected, sheathing panels are extended or trimmed at wall\n        ends to account for wall intersections (L-corners, T-junctions).\n        Required: No\n        Access: Item\n\n    Config JSON (config_json) - str:\n        Optional JSON configuration with:\n        - panel_size: \"4x8\", \"4x9\", \"4x10\", \"4x12\" (default \"4x8\")\n        - material: Material name (default \"structural_plywood_7_16\")\n        - stagger_offset: Feet between row joints (default 2.0)\n        - min_piece_width: Minimum panel width in feet (default 0.5)\n        - faces: List of faces to sheathe (default [\"exterior\"])\n        Required: No\n        Access: Item\n\n    Run (run) - bool:\n        Boolean to trigger execution\n        Required: Yes\n        Access: Item\n\nOutputs:\n    Sheathing JSON (sheathing_json) - str:\n        JSON string containing all sheathing panels with positions and cutouts\n\n    Summary (summary) - str:\n        Material summary with panel counts, areas, and waste percentage\n\n    Log (log) - str:\n        Processing log with debug information\n\nTechnical Details:\n    - Panels laid out left-to-right, bottom-to-top\n    - Stagger offset applied to alternating rows\n    - Cutouts calculated as intersection of opening and panel bounds\n    - Full sheets identified for material ordering optimization\n\nError Handling:\n    - Invalid JSON returns empty results with error in log\n    - Invalid material name falls back to default with warning\n    - Empty walls return empty panel list (no error)\n\nAuthor: Timber Framing Generator\nVersion: 1.0.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\n# Rhino / Grasshopper\nimport Grasshopper\n\n# =============================================================================\n# Module Reload (Development Only)\n# =============================================================================\n\n# Force reload of project modules during development\n# Set to False in production for better performance\nFORCE_RELOAD = True\n\nif FORCE_RELOAD:\n    modules_to_reload = [key for key in sys.modules.keys()\n                         if 'timber_framing_generator' in key]\n    for mod_name in modules_to_reload:\n        del sys.modules[mod_name]\n\n# =============================================================================\n# Project Imports (after reload)\n# =============================================================================\n\nfrom src.timber_framing_generator.sheathing import (\n    generate_wall_sheathing,\n    SHEATHING_MATERIALS,\n    PANEL_SIZES,\n)\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Sheathing Generator\"\nCOMPONENT_NICKNAME = \"Sheath\"\nCOMPONENT_MESSAGE = \"v1.0\"\nCOMPONENT_CATEGORY = \"Timber Framing\"\nCOMPONENT_SUBCATEGORY = \"4-Sheathing\"\n\n# Default configuration\nDEFAULT_CONFIG = {\n    \"panel_size\": \"4x8\",\n    \"material\": \"structural_plywood_7_16\",\n    \"stagger_offset\": 2.0,\n    \"min_piece_width\": 0.5,\n    \"faces\": [\"exterior\"],\n}\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message, level=\"info\"):\n    \"\"\"Log to console and optionally add GH runtime message.\"\"\"\n    print(f\"[{level.upper()}] {message}\")\n\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n\n\ndef log_info(message):\n    \"\"\"Log info message (console only).\"\"\"\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message):\n    \"\"\"Log warning message (console + GH UI).\"\"\"\n    log_message(message, \"warning\")\n\n\ndef log_error(message):\n    \"\"\"Log error message (console + GH UI).\"\"\"\n    log_message(message, \"error\")\n\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\"\"\"\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs\n    inputs = ghenv.Component.Params.Input\n\n    input_config = [\n        (\"Walls JSON\", \"walls_json\", \"JSON string from Wall Analyzer\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Junctions JSON\", \"junctions_json\",\n         \"Optional JSON from Junction Analyzer for per-layer adjustments\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Config JSON\", \"config_json\", \"Optional configuration JSON\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Run\", \"run\", \"Boolean to trigger execution\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    # Configure outputs (start from index 1)\n    outputs = ghenv.Component.Params.Output\n\n    output_config = [\n        (\"Sheathing JSON\", \"sheathing_json\", \"JSON with sheathing panel data\"),\n        (\"Summary\", \"summary\", \"Material summary string\"),\n        (\"Log\", \"log\", \"Processing log\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef validate_inputs(walls_json, run):\n    \"\"\"Validate component inputs.\n\n    Args:\n        walls_json: JSON string with wall data\n        run: Boolean run trigger\n\n    Returns:\n        tuple: (is_valid, error_message)\n    \"\"\"\n    if not run:\n        return False, \"Run is False - component disabled\"\n\n    if walls_json is None or not walls_json.strip():\n        return False, \"walls_json is required\"\n\n    return True, None\n\n\ndef parse_config(config_json):\n    \"\"\"Parse configuration JSON with defaults.\n\n    Args:\n        config_json: Optional JSON string with config overrides\n\n    Returns:\n        dict: Merged configuration with defaults\n    \"\"\"\n    config = dict(DEFAULT_CONFIG)\n\n    if config_json and config_json.strip():\n        try:\n            user_config = json.loads(config_json)\n            config.update(user_config)\n            log_info(f\"Applied user config: {list(user_config.keys())}\")\n        except json.JSONDecodeError as e:\n            log_warning(f\"Invalid config_json, using defaults: {e}\")\n\n    # Validate material\n    if config[\"material\"] not in SHEATHING_MATERIALS:\n        log_warning(f\"Unknown material '{config['material']}', using default\")\n        config[\"material\"] = DEFAULT_CONFIG[\"material\"]\n\n    # Validate panel size\n    if config[\"panel_size\"] not in PANEL_SIZES:\n        log_warning(f\"Unknown panel size '{config['panel_size']}', using default\")\n        config[\"panel_size\"] = DEFAULT_CONFIG[\"panel_size\"]\n\n    return config\n\n\ndef compute_sheathing_bounds(wall_id, wall_length, face, junctions_data):\n    \"\"\"Compute U-axis panel bounds from junction adjustments.\n\n    Looks up the junction adjustments for a specific wall and face,\n    and returns the adjusted u_start_bound and u_end_bound.\n\n    Args:\n        wall_id: Wall identifier.\n        wall_length: Original wall length in feet.\n        face: \"exterior\" or \"interior\" â€” determines which layer to use.\n        junctions_data: Parsed junctions_json dict, or None.\n\n    Returns:\n        tuple: (u_start_bound, u_end_bound) in feet.\n    \"\"\"\n    u_start_bound = 0.0\n    u_end_bound = wall_length\n\n    if not junctions_data:\n        return u_start_bound, u_end_bound\n\n    # Map face to layer name\n    layer_name = \"exterior\" if face == \"exterior\" else \"interior\"\n\n    # Get adjustments for this wall\n    wall_adjustments = junctions_data.get(\"wall_adjustments\", {}).get(wall_id, [])\n\n    for adj in wall_adjustments:\n        if adj.get(\"layer_name\") != layer_name:\n            continue\n\n        end = adj.get(\"end\")\n        adj_type = adj.get(\"adjustment_type\")\n        amount = adj.get(\"amount\", 0.0)\n\n        if end == \"start\":\n            if adj_type == \"extend\":\n                u_start_bound = -amount  # Extend before wall start\n            elif adj_type == \"trim\":\n                u_start_bound = amount   # Trim after wall start\n        elif end == \"end\":\n            if adj_type == \"extend\":\n                u_end_bound = wall_length + amount  # Extend past wall end\n            elif adj_type == \"trim\":\n                u_end_bound = wall_length - amount  # Trim before wall end\n\n    return u_start_bound, u_end_bound\n\n\ndef process_walls(walls_json, config, junctions_data=None):\n    \"\"\"Process walls and generate sheathing panels.\n\n    Args:\n        walls_json: JSON string with wall data\n        config: Configuration dictionary\n        junctions_data: Optional parsed junctions_json dict\n\n    Returns:\n        tuple: (all_results, summary_text, log_lines)\n    \"\"\"\n    log_lines = []\n    all_results = []\n\n    try:\n        walls_data = json.loads(walls_json)\n    except json.JSONDecodeError as e:\n        log_error(f\"Failed to parse walls_json: {e}\")\n        return [], \"Error: Invalid JSON\", [f\"JSON parse error: {e}\"]\n\n    # Handle single wall or list of walls\n    if isinstance(walls_data, dict):\n        walls_list = [walls_data]\n    elif isinstance(walls_data, list):\n        walls_list = walls_data\n    else:\n        log_error(\"walls_json must be a dict or list\")\n        return [], \"Error: Invalid format\", [\"Invalid walls_json format\"]\n\n    log_info(f\"Processing {len(walls_list)} walls\")\n    log_lines.append(f\"Processing {len(walls_list)} walls\")\n    log_lines.append(f\"Config: panel_size={config['panel_size']}, material={config['material']}\")\n\n    total_panels = 0\n    total_gross_area = 0\n    total_net_area = 0\n\n    for i, wall_data in enumerate(walls_list):\n        wall_id = wall_data.get(\"wall_id\", f\"wall_{i}\")\n        log_info(f\"Processing wall {wall_id}\")\n\n        try:\n            # Determine actual face labels, accounting for wall flip state.\n            # When is_flipped=True, the wall's Z-axis (positive normal) points\n            # to the interior instead of the exterior. We swap face labels so\n            # \"exterior\" sheathing is placed on the actual building exterior.\n            faces = config.get(\"faces\", [\"exterior\"])\n            is_flipped = wall_data.get(\"is_flipped\", False)\n            if is_flipped:\n                faces = [\n                    \"interior\" if f == \"exterior\" else \"exterior\"\n                    for f in faces\n                ]\n                log_info(f\"  Wall {wall_id} is flipped - swapped faces to {faces}\")\n\n            wall_length = wall_data.get(\"wall_length\", 0)\n            face_bounds = {}\n            for face in faces:\n                u_start, u_end = compute_sheathing_bounds(\n                    wall_id, wall_length, face, junctions_data\n                )\n                face_bounds[face] = (u_start, u_end)\n                if u_start != 0.0 or u_end != wall_length:\n                    log_info(\n                        f\"  {face} bounds: u=[{u_start:.4f}, {u_end:.4f}] \"\n                        f\"(wall_length={wall_length:.4f})\"\n                    )\n\n            # Generate sheathing for this wall\n            # Use first face bounds for the generator (each face will be\n            # generated separately if bounds differ per face)\n            first_face = faces[0] if faces else \"exterior\"\n            u_start_bound, u_end_bound = face_bounds.get(\n                first_face, (0.0, wall_length)\n            )\n\n            result = generate_wall_sheathing(\n                wall_data,\n                config=config,\n                faces=faces,\n                u_start_bound=u_start_bound,\n                u_end_bound=u_end_bound,\n            )\n\n            all_results.append(result)\n\n            # Accumulate stats\n            wall_summary = result.get(\"summary\", {})\n            total_panels += wall_summary.get(\"total_panels\", 0)\n            total_gross_area += wall_summary.get(\"gross_area_sqft\", 0)\n            total_net_area += wall_summary.get(\"net_area_sqft\", 0)\n\n            log_lines.append(f\"  Wall {wall_id}: {wall_summary.get('total_panels', 0)} panels\")\n\n        except Exception as e:\n            log_warning(f\"Error processing wall {wall_id}: {e}\")\n            log_lines.append(f\"  Wall {wall_id}: ERROR - {e}\")\n            continue\n\n    # Build summary text\n    waste_area = total_gross_area - total_net_area\n    waste_pct = (waste_area / total_gross_area * 100) if total_gross_area > 0 else 0\n\n    summary_text = (\n        f\"Total Panels: {total_panels}\\n\"\n        f\"Gross Area: {total_gross_area:.1f} sq ft\\n\"\n        f\"Net Area: {total_net_area:.1f} sq ft\\n\"\n        f\"Waste: {waste_area:.1f} sq ft ({waste_pct:.1f}%)\\n\"\n        f\"Material: {config['material']}\\n\"\n        f\"Panel Size: {config['panel_size']}\"\n    )\n\n    log_info(f\"Total: {total_panels} panels, {total_gross_area:.1f} sq ft\")\n\n    return all_results, summary_text, log_lines\n\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main(walls_json_in, junctions_json_in, config_json_in, run_in):\n    \"\"\"Main entry point for the component.\n\n    Args:\n        walls_json_in: JSON string from Wall Analyzer\n        junctions_json_in: Optional JSON from Junction Analyzer\n        config_json_in: Optional configuration JSON\n        run_in: Boolean to trigger execution\n    \"\"\"\n    # Set component metadata and NickNames (for display, after inputs are read)\n    setup_component()\n\n    try:\n        # Use inputs passed as arguments\n        walls_json_input = walls_json_in\n        junctions_json_input = junctions_json_in\n        config_json_input = config_json_in\n        run_input = run_in\n\n        # Validate inputs\n        is_valid, error_msg = validate_inputs(walls_json_input, run_input)\n        if not is_valid:\n            log_info(error_msg)\n            return \"\", error_msg, error_msg\n\n        # Parse configuration\n        config = parse_config(config_json_input)\n\n        # Parse junctions data (optional)\n        junctions_data = None\n        if junctions_json_input and str(junctions_json_input).strip():\n            try:\n                junctions_data = json.loads(junctions_json_input)\n                junc_count = junctions_data.get(\"junction_count\", 0)\n                adj_count = sum(\n                    len(adjs)\n                    for adjs in junctions_data.get(\"wall_adjustments\", {}).values()\n                )\n                log_info(\n                    f\"Loaded junction data: {junc_count} junctions, \"\n                    f\"{adj_count} adjustments\"\n                )\n            except (json.JSONDecodeError, TypeError) as e:\n                log_warning(f\"Invalid junctions_json, ignoring: {e}\")\n\n        # Process walls\n        results, summary_text, log_lines = process_walls(\n            walls_json_input, config, junctions_data\n        )\n\n        # Serialize results to JSON\n        sheathing_json_output = json.dumps(results, indent=2)\n        log_output = \"\\n\".join(log_lines)\n\n        return sheathing_json_output, summary_text, log_output\n\n    except Exception as e:\n        error_msg = f\"Unexpected error: {str(e)}\"\n        log_error(error_msg)\n        print(traceback.format_exc())\n        return \"\", error_msg, traceback.format_exc()\n\n\n# =============================================================================\n# Execution\n# =============================================================================\n\n# Read inputs by parameter index via VolatileData.AllData(True).\n# NickName-based global injection is unreliable in Rhino 8 CPython --\n# setup_component() renames NickNames but GH injects globals based on the\n# NickName at solve-start, causing mismatches. AllData(True) always works.\n\ndef _read_input(index, default=None):\n    \"\"\"Read a GH input value by parameter index via VolatileData.\"\"\"\n    inputs = ghenv.Component.Params.Input\n    if index >= inputs.Count:\n        return default\n    param = inputs[index]\n    if param.VolatileDataCount == 0:\n        return default\n    all_data = list(param.VolatileData.AllData(True))\n    if not all_data:\n        return default\n    goo = all_data[0]\n    if hasattr(goo, \"Value\"):\n        return goo.Value\n    if hasattr(goo, \"ScriptVariable\"):\n        return goo.ScriptVariable()\n    return default\n\n_input_count = ghenv.Component.Params.Input.Count\nif _input_count < 4:\n    _msg = (\n        \"ERROR: Component has %d inputs but needs 4. \"\n        \"Right-click component zoomable UI (ZUI) -> add input until you have 4, \"\n        \"then reconnect: walls_json, junctions_json, config_json, run\"\n        % _input_count\n    )\n    print(_msg)\n    sheathing_json = \"\"\n    summary = _msg\n    log = _msg\nelse:\n    _walls_json = _read_input(0)       # walls_json\n    _junctions_json = _read_input(1)   # junctions_json\n    _config_json = _read_input(2)      # config_json\n    _run = bool(_read_input(3, False)) # run\n\n    sheathing_json, summary, log = main(\n        _walls_json, _junctions_json, _config_json, _run\n    )\n",
  "language": "python",
  "imports": [
    "RhinoCommon"
  ],
  "has_docstring": true
}