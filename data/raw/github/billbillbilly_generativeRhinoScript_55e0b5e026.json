{
  "source_url": "https://github.com/billbillbilly/generativeRhinoScript/blob/c0612d88918cd655a60d23af27a1ae1cfc05db94/8_agent/agent.py",
  "repo": "billbillbilly/generativeRhinoScript",
  "repo_stars": 1,
  "repo_description": "A collection of RhinoScript of design computation",
  "license": "GPL-3.0",
  "filepath": "8_agent/agent.py",
  "instruction": null,
  "code": "import rhinoscriptsyntax as rs\nimport ghpythonlib.components as ghc\nimport scriptcontext as sc\nimport Rhino\nimport math\nimport random\n\nclass Agent(object):\n    #initilize data in class\n    def __init__(self, point, coord, vec):\n        #initialize agent data\n        self.ptID = point\n        self.pos = coord\n        self.vector = vec\n        self.trailPts = []\n        self.trailPts += [self.pos]\n        self.curveID = None\n\n    # find out the closest mesh\n    def detectMesh(self, mesh):\n        distances = []\n        closestMesh = {}\n        for each in mesh:\n            ptData = ghc.MeshClosestPoint(self.ptID, each)\n            distance = rs.Distance(ptData[0], self.pos)\n            distances += [distance]\n            closestMesh[distance] = [each, ptData[0]]\n        distance = min(distances)\n        self.closestMesh = closestMesh[distance]\n        return self\n\n    # find the closest agent\n    def detectAgent(self, agentPopulation):\n        distances = []\n        closestAgent = {}\n        for agent in agentPopulation:\n            distance = rs.Distance(self.pos, agent.pos)\n            # select a closest agent within a random distance\n            if distance > random.randint(2,20):\n                distances += [distance]\n                closestAgent[distance] = [agent, distance]\n        distance = min(distances)\n        self.closestAgent = closestAgent[distance]\n        return self\n\n    def vectorAttract(self):\n        # if the closest agent is close enough, change the default vector to push agent toward other agents\n        if self.closestAgent[1] > random.randint(5,8) and self.closestAgent[1] < random.randint(9,13) and self.pos[2] > 1:\n            direction = rs.AddLine(self.pos, self.closestAgent[0].pos)\n            translation = rs.CreatePoint((0,0,1)) - rs.CreatePoint(self.pos)\n            rs.MoveObject(direction, translation)\n            self.tempVector = rs.VectorCreate(rs.CurveEndPoint(direction), (0,0,0))\n            rs.DeleteObject(direction)\n            if rs.VectorLength(self.tempVector) >= 1:\n                self.tempVector = rs.VectorUnitize(self.tempVector)\n        # if agent is too close to each other, push it away from other agents\n        elif self.closestAgent[1] <= 5 and self.pos[2] > 1:\n            direction = rs.AddLine(self.closestAgent[0].pos, self.pos)\n            translation = rs.CreatePoint((0,0,1)) - rs.CreatePoint(self.pos)\n            rs.MoveObject(direction, translation)\n            self.tempVector = rs.VectorCreate(rs.CurveEndPoint(direction), (0,0,0))\n            rs.DeleteObject(direction)\n            if rs.VectorLength(self.tempVector) >= 1:\n                self.tempVector = rs.VectorUnitize(self.tempVector)\n        else:\n            self.tempVector = self.vector\n\n    def move(self):\n        self.vectorAttract()\n        # keep moving upward if agent is far from barriers\n        if rs.Distance(self.closestMesh[1], self.pos) > 2 or self.closestMesh[1][2] == self.pos[2]:\n            self.pos = rs.PointAdd(self.pos, self.tempVector)\n        else: # make agent detour\n            # get normal from the closest point on the closest mesh\n            self.closestMesh[0].FaceNormals.ComputeFaceNormals()\n            fid,mPt = self.closestMesh[0].ClosestPoint(self.closestMesh[1],2)\n            meshNormal = self.closestMesh[0].FaceNormals[fid]\n            # add vector to the closest point on the closest mesh\n            vecPt = rs.PointAdd(self.closestMesh[1], meshNormal)\n            # create direction line starting from vector point to ClosestPoint\n            # when agent is below half the height of the sphere\n            if self.closestMesh[1][2] > self.pos[2]:\n                direction = rs.AddLine(self.closestMesh[1], vecPt)\n            # when the height of agent is more than half the height of the sphere\n            elif self.closestMesh[1][2] < self.pos[2]:\n                direction = rs.AddLine(vecPt, self.closestMesh[1])\n            startPt = rs.CurveStartPoint(direction)\n            # create an elevated point from agent\n            pt = (self.pos[0], self.pos[1], self.pos[2]+1/math.sin(math.radians(45)))\n            # move direction line to elevated point\n            translation = rs.CreatePoint(pt) - startPt\n            rs.MoveObject(direction, translation)\n            # relocate agent at the end point of moved direction line\n            self.pos = rs.CurveEndPoint(direction)\n            rs.DeleteObject(direction)\n        self.trailPts += [self.pos]\n        rs.DeleteObject(self.ptID)\n        self.ptID = rs.AddPoint(self.pos)\n        return self\n\n    # draw trails\n    def drawTrails(self):\n        if self.curveID != None:\n            rs.DeleteObject(self.curveID)\n        self.curveID = rs.AddCurve(self.trailPts)\n\ndef main():\n    ptNum = rs.GetInteger('how many attractor points?', 60)\n    startPtNum = rs.GetInteger('how many streams?', 80)\n    steps = rs.GetInteger('How many steps?', 80)\n\n    # moving direction\n    vector = (0,0,1)\n    spheres = []\n    agentPopulation = []\n\n    # setup barrier sphere mesh\n    for i in range(ptNum):\n        x = random.randrange(5, 45)\n        y = random.randrange(5, 45)\n        z = random.randrange(5, 80)\n        point = (x,y,z) # center point\n        radius = random.randrange(3, 10) # random radius\n        plane = ghc.XYPlane(rs.AddPoint(point))\n        sphere = ghc.MeshSphere(plane, radius)\n        spheres += [sphere]\n\n    # convert separate sphere into subD and then convert subD in to mesh\n    mesh = ghc.MeshUnion(spheres)\n    subD = ghc.SubDfromMesh(mesh)\n    meshFSubD = ghc.MeshfromSubD(subD)\n    meshIDs = []\n    for i in meshFSubD:\n        meshIDs += [sc.doc.Objects.AddMesh(i)]\n\n    # setup start points for line structure\n    for i in range(startPtNum):\n        x = random.randrange(0, 50)\n        y = random.randrange(0, 50)\n        z = 0\n        point = (x,y,z)\n        agentPopulation += [Agent(rs.AddPoint(point), point, vector)]\n\n    # call Agent methods\n    n = 0\n    while n <= steps:\n    #while not sc.escape_test():\n        n += 1\n        for agent in agentPopulation:\n            agent.detectMesh(meshFSubD).detectAgent(agentPopulation).move().drawTrails()\n\nmain()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}