{
  "source_url": "https://github.com/billbillbilly/generativeRhinoScript/blob/c0612d88918cd655a60d23af27a1ae1cfc05db94/4_terrain/terrain.py",
  "repo": "billbillbilly/generativeRhinoScript",
  "repo_stars": 1,
  "repo_description": "A collection of RhinoScript of design computation",
  "license": "GPL-3.0",
  "filepath": "4_terrain/terrain.py",
  "instruction": "This script consists of two part of functions: set up loft surface and generate surface structures over the surface from first part using surface vectors and point matrix. #",
  "code": "# This script consists of two part of functions: set up loft surface and generate\n# surface structures over the surface from first part using surface vectors\n# and point matrix. #\n\nimport rhinoscriptsyntax as rs\nimport random\nimport math\n\n### 1. Create a loft surface ###\n# Generate a set of points (point matrix)\ndef pointsetup(x_number, y_number, interval):\n    points = {} # points dictionary for saving 3D points\n    point_list = [] # points list for saving point id\n    for i in range(1,x_number):\n        for j in range(1,y_number):\n            addpoint = rs.AddPoint((i*interval, j*interval, 0))\n            points[(i,j)] = (i*interval, j*interval, 0)\n            point_list += [addpoint]\n    return points, point_list\n\n# indicate how many of curves will be created based on created points matrix\n# the curve(s) will be used as attract curve(s), where its divide points will be\n# attract points. #\ndef attrcurvesetup(num_curves):\n    curve_points_list = [] # for saving divide 3D points along the curve(s)\n    curve_endpoint = [] # for saving endpoint(s) of curve(s)\n    curveid_list = [] # for saving curve id\n    if num_curves == 1: # only draw one curve\n        # pick up some generated points to create a cerve\n        selected_points = rs.GetObjects(message=\"select points to create curve(s)\",\n                                        filter=1, group=False)\n        # curve id\n        curve_guid = rs.AddCurve(selected_points,3)\n        # sample points along the curve\n        curve_length = rs.CurveLength(curve_guid)\n        # divide curve by the length of curve\n        curve_points_list = rs.DivideCurve(curve_guid, round(curve_length),\n                                           False, True)\n    else: # draw several curves\n        n = 0\n        while n < num_curves:\n            selected_points = rs.GetObjects(message=\"select points to create a curve\",\n                                            filter=1, group=False)\n            curve_guid = rs.AddCurve(selected_points,3)\n            # sample points along the curve\n            curve_length = rs.CurveLength(curve_guid)\n            # divide curve by the length of curve\n            points_along_curve = rs.DivideCurve(curve_guid, round(curve_length),\n                                                False, True)\n            curve_points_list += points_along_curve\n            # collect end point of each curve\n            curve_endpoint += points_along_curve[-1]\n            # save curve ids\n            curveid_list += [curve_guid]\n            n += 1\n    # Delete cure(s) in rhino space\n    if curveid_list != []:\n        rs.DeleteObjects(curveid_list)\n    else:\n        rs.DeleteObject(curve_guid)\n    return curve_points_list, curve_endpoint\n\n# Create loft surface based on point matrix. #\n# The elevations of 3D points in the matrix will be incresed based on\n# the shortest distances from themselves to the points on the curve(s) #\n# Section curves will generated from the elevated points in each row.\n# Loft surfsace will be created by section curves.\ndef loftsurf(points, num_curves, curve_points_list, curve_endpoint, x_number,\n             y_number, interval):\n    curve_cluster = [] # for saving curve sections for loft surface\n    for i in range(1,x_number):\n        point_cluster = [] # for saving 3D points in\n        for j in range(1,y_number):\n            pt = points[(i,j)]\n            # Calculate min distance from the point to the curve\n            min_distance = min(rs.Distance(pt, curve_points_list))\n            # The height of a point is based on the shortest distance from each\n            # point in matrix to the curve(s). #\n            # There are two height modification solutions down below\n            # The longer the distance the point is\n            # from the enpoint, the higher the elevation #\n            h1 = min_distance/1.5\n            h2 = math.sqrt(min_distance/2)\n            # Calculate minimumn distance from endpoint to the point in the matrix\n            # This vaiable will be used to elevate points in the matrix\n            if num_curves == 1: # if there only one curve as input\n                h_change = rs.Distance(pt, curve_points_list[-1])\n            else: # if there more than one curve used as input\n                h_change = min(rs.Distance(pt, curve_endpoint))\n            # if this vaiable (distance) is shorter than 1, we just plus 1\n            if h_change <= 1:\n                h_change += 1\n            if min_distance > 2*interval: # We set up a buffer along the curve(s),\n                                          # where some points will not be elevated so much. #\n                                          # The longer the distance the point is\n                                          # from the enpoint, the lower the\n                                          # elevation of the point. #\n                # This height is affected by the distance from the point to the\n                # endpoints of curves. #\n                h1 -= 1.5*h1**2/h_change\n                point_cluster += [(points[(i,j)][0], points[(i,j)][1], h1)]\n            else:\n                h2 -= h2**2/h_change\n                # Save the elevated points in the same row in the list\n                # within this loop. #\n                point_cluster += [(points[(i,j)][0], points[(i,j)][1], h2)]\n        # Create section curves\n        section_curve = rs.AddCurve(point_cluster)\n        # Save the sections in the list\n        curve_cluster += [section_curve]\n    # Create loft surface by section curves\n    loft_surface = rs.AddLoftSrf(curve_cluster)\n    # Delete the sections\n    rs.DeleteObjects(curve_cluster)\n    return loft_surface, curve_points_list\n\n# A wraped up function for generating loft surface based on comtumized point matrix\ndef srfsetup():\n    # Set the size of matrix\n    x_number = rs.GetInteger(message=\"set the number of point on x direction\",\n                             number=30)\n    y_number = rs.GetInteger(message=\"set the number of point on y direction\",\n                             number=30)\n    # Set interval (size of unit in the matrix)\n    interval = rs.GetInteger(message=\"set the interval\", number=5)\n    # Number of attract curves to be created\n    num_curves = rs.GetInteger(message=\"set the number of curves\")\n    # Set up points matrix\n    points, point_list = pointsetup(x_number, y_number, interval)\n    # Sample attract points along the curve(s)\n    curve_points_list, curve_endpoint = attrcurvesetup(num_curves)\n    loft_surface, curve_points_list = loftsurf(points, num_curves,\n                                               curve_points_list,\n                                               curve_endpoint, x_number,\n                                               y_number, interval)\n    rs.DeleteObjects(point_list)\n    return loft_surface, curve_points_list, interval\n\n### 2.Create structure based on the loft surface ###\n# Get domains and set up steps of uv\ndef surf_uv_stepsetup(surface, u_number, v_number):\n    u_domain = rs.SurfaceDomain(surface, 0)\n    v_domain = rs.SurfaceDomain(surface, 1)\n    u_step = (u_domain[1]-u_domain[0])/u_number\n    v_step = (v_domain[1]-v_domain[0])/v_number\n    return u_domain, v_domain, u_step, v_step\n\n# Set up point matrix based on uv steps\ndef surf_uv_pointsetup(surface, u_number, v_number, u_domain, v_domain, u_step,\n                       v_step, curve_points_list):\n    uvpoints = {} # Save points on the surface\n    uvvectors = {} # Save points created by suface normal(vectors)\n    for i in range(u_number+1):\n        for j in range(v_number+1):\n            u = u_domain[0] + i*u_step\n            v = v_domain[0] + j*v_step\n            # Get uv points on surface\n            uvpoints[(i,j)] = rs.EvaluateSurface(surface, u, v)\n            # Get vectors based on uv coordinates on surface\n            uv_vector = rs.SurfaceNormal(surface, (u,v))\n            # Calculate shortest distance for each uv point to the curve(s)\n            min_distance = min(rs.Distance(uvpoints[(i,j)], curve_points_list))\n            # Unitize the vectors\n            uv_vector = rs.VectorUnitize(uv_vector)\n            # This factor is used to rescale vectors\n            factor = math.sqrt(min_distance)/2\n            if factor <= 1:\n                factor += 1 # We keep the factor always larger than 1\n            # Scale the vector\n            # The longer the distance the point is from the curve(s),\n            # the larger the vector #\n            uv_vector = rs.VectorScale(uv_vector, factor)\n            # Create the vector points above the surface\n            uvvectors[(i,j)] = rs.PointAdd(uv_vector, uvpoints[(i,j)])\n            #rs.AddPoint(uvvectors[(i,j)])\n    return uvpoints, uvvectors\n\n# set up point matrix based on uv steps using points along the curve(s)\n# as attract points\ndef attr_uv_pointsetup(surface, u_number, v_number, u_domain, v_domain, u_step,\n                       v_step, curve_points_list):\n    uvpoints = {} # Save points on the surface\n    uvattrpoints = {} # Save attracted points on the surface\n    uv_unit_vectors = {}\n    uvvectors = {} # Save points created by suface normal(vectors)\n    # Get uv points on surface\n    for i in range(u_number+1):\n        for j in range(v_number+1):\n            u = u_domain[0] + i*u_step\n            v = v_domain[0] + j*v_step\n            uvpoints[(i,j)] = rs.EvaluateSurface(surface, u, v)\n    # create point attracted by the closest points on curve(s)\n    for i in range(u_number+1):\n        for j in range(v_number+1):\n            # keep the edge points\n            if i == 0 or i == u_number:\n                uvattrpoints[(i,j)] = uvpoints[(i,j)]\n            elif j == 0 and j == v_number:\n                uvattrpoints[(i,j)] = uvpoints[(i,j)]\n            else:\n                # Calculate shortest distance for each uv point to the curve(s)\n                distance = min(rs.Distance(uvpoints[(i,j)], curve_points_list))\n                for each in curve_points_list:\n                    # Find out the closest point on the curve(s)\n                    if rs.Distance(uvpoints[(i,j)], each) == distance:\n                        # Create the vector between uv point on surface and\n                        # closest point on curve(s). #\n                        attr_vector = rs.VectorCreate(each, uvpoints[(i,j)])\n                        if distance < 1:\n                            distance += 1\n                        # This factor is used to rescale the vector\n                        # The longer the distance the point is from the curve(s),\n                        # the less the vector gets reduced. #\n                        factor = math.sqrt(distance)/distance\n                        attr_vector = rs.VectorScale(attr_vector, factor)\n                        # Add vector to uv point\n                        attr_pt = rs.PointAdd(attr_vector, uvpoints[(i,j)])\n                        # Create the attracted point on surface\n                        uvattrpoints[(i,j)] = rs.BrepClosestPoint(surface, attr_pt)[0]\n\n    for i in range(u_number+1):\n        for j in range(v_number+1):\n            # Get vectors based on attracted points on surface\n            uv = rs.SurfaceClosestPoint(surface, uvattrpoints[(i,j)])\n            uv_vector = rs.SurfaceNormal(surface, (uv[0],uv[1]))\n            # Calculate shortest distance from the attracted point to curve(s)\n            min_distance = min(rs.Distance(uvattrpoints[(i,j)], curve_points_list))\n            # Unitize the vector\n            uv_vector = rs.VectorUnitize(uv_vector)\n            # This factor is used to rescale vector\n            # The longer distance from attracted point to curve(s),\n            # the larger the vector is. (the higher the point is)#\n            factor = math.sqrt(min_distance)/1.5\n            if factor < 1:\n                factor += 1\n            uv_vector = rs.VectorScale(uv_vector, factor)\n            uvvectors[(i,j)] = rs.PointAdd(uv_vector, uvattrpoints[(i,j)])\n            #rs.AddPoint(uvvectors[(i,j)])\n    uvpoints = uvattrpoints\n    return uvpoints, uvvectors\n\n# Generate surface based on point matrix\ndef structure_generator(uvpoints, uvvectors, curve_points_list, u_number,\n                        v_number, interval):\n    # Count row number\n    count1 = 0\n    for i in range(u_number+1):\n        # count column number\n        count2 = 0\n        for j in range(v_number+1):\n            if i > 0 and j > 0:\n                # Calculate this count factor for recognizing units\n                count = abs(count1 - count2)\n                # Create a buffer along the curve(s), where we only generate the surface\n                # based on four point. #\n                if min(rs.Distance(uvpoints[(i,j)], curve_points_list)) <= 2*interval:\n                    # Count column number\n                    count2 += 1\n                    rs.AddSrfPt((uvpoints[(i,j)], uvpoints[(i,j-1)],\n                                 uvpoints[(i-1,j-1)], uvpoints[(i-1,j)]))\n                else: # There are two suface structure solutions, which will be\n                      # alternatively applied to units of point matrix. #\n                    # if the count factor can be divided by 2\n                    if (count % 2) == 0:\n                        # Count column number\n                        count2 += 1\n                        # A list of points in a unit\n                        pt_cluster = [uvpoints[(i,j)], uvpoints[(i,j-1)],\n                                      uvpoints[(i-1,j-1)], uvpoints[(i-1,j)]]\n                        # A list of heights of the points above\n                        h = [uvpoints[(i,j)][2], uvpoints[(i,j-1)][2],\n                             uvpoints[(i-1,j-1)][2], uvpoints[(i-1,j)][2]]\n                        pt = None\n                        # Find out the lowest point\n                        for k in pt_cluster:\n                            if k[2] == min(h):\n                                pt = k\n                        # Generate 3D surface\n                        # The longer distance from attracted point to curve(s),\n                        # the thicker the 3D surface is. #\n                        if pt == uvpoints[(i,j)]:\n                            new_pt = (pt[0], pt[1], uvvectors[(i,j)][2])\n                            srf = rs.AddSrfPt((new_pt, uvpoints[(i,j-1)],\n                                         uvpoints[(i-1,j-1)], uvpoints[(i-1,j)]))\n                            m_index = rs.AddMaterialToObject(srf)\n                            rs.MaterialColor(m_index, (255,255,255))\n                            # infill surfaces\n                            srf = rs.AddSrfPt((pt, uvpoints[(i,j-1)], new_pt))\n                            m_index = rs.AddMaterialToObject(srf)\n                            rs.MaterialColor(m_index, (255,255,255))\n                            srf = rs.AddSrfPt((pt, new_pt, uvpoints[(i-1,j)]))\n                            m_index = rs.AddMaterialToObject(srf)\n                            rs.MaterialColor(m_index, (255,255,255))\n\n                        elif pt == uvpoints[(i,j-1)]:\n                            new_pt = (pt[0], pt[1], uvvectors[(i,j-1)][2])\n                            srf = rs.AddSrfPt((uvpoints[(i,j)], new_pt,\n                                         uvpoints[(i-1,j-1)], uvpoints[(i-1,j)]))\n                            m_index = rs.AddMaterialToObject(srf)\n                            rs.MaterialColor(m_index, (255,255,255))\n                            # infill surfaces\n                            srf = rs.AddSrfPt((pt, uvpoints[(i,j)], new_pt))\n                            m_index = rs.AddMaterialToObject(srf)\n                            rs.MaterialColor(m_index, (255,255,255))\n                            srf = rs.AddSrfPt((pt, new_pt, uvpoints[(i-1,j-1)]))\n                            m_index = rs.AddMaterialToObject(srf)\n                            rs.MaterialColor(m_index, (255,255,255))\n\n                        elif pt == uvpoints[(i-1,j-1)]:\n                            new_pt = (pt[0], pt[1], uvvectors[(i-1,j-1)][2])\n                            srf = rs.AddSrfPt((uvpoints[(i,j)], uvpoints[(i,j-1)],\n                                         new_pt, uvpoints[(i-1,j)]))\n                            m_index = rs.AddMaterialToObject(srf)\n                            rs.MaterialColor(m_index, (255,255,255))\n                            # infill surfaces\n                            srf = rs.AddSrfPt((pt, uvpoints[(i-1,j)], new_pt))\n                            m_index = rs.AddMaterialToObject(srf)\n                            rs.MaterialColor(m_index, (255,255,255))\n                            srf = rs.AddSrfPt((pt, new_pt, uvpoints[(i,j-1)]))\n                            m_index = rs.AddMaterialToObject(srf)\n                            rs.MaterialColor(m_index, (255,255,255))\n\n                        elif pt == uvpoints[(i-1,j)]:\n                            new_pt = (pt[0], pt[1], uvvectors[(i-1,j)][2])\n                            srf = rs.AddSrfPt((uvpoints[(i,j)], uvpoints[(i,j-1)],\n                                         uvpoints[(i-1,j-1)], new_pt))\n                            m_index = rs.AddMaterialToObject(srf)\n                            rs.MaterialColor(m_index, (255,255,255))\n                            # infill surfaces\n                            srf = rs.AddSrfPt((pt, uvpoints[(i-1,j-1)], new_pt))\n                            m_index = rs.AddMaterialToObject(srf)\n                            rs.MaterialColor(m_index, (255,255,255))\n                            srf = rs.AddSrfPt((pt, new_pt, uvpoints[(i,j)]))\n                            m_index = rs.AddMaterialToObject(srf)\n                            rs.MaterialColor(m_index, (255,255,255))\n                    # if the count factor can not be divided by 2\n                    else:\n                        # Count column number\n                        count2 += 1\n                        # Create bottom curve based on uv points in a unit on surface\n                        bottom_curve = rs.AddCurve([uvpoints[(i,j)], uvpoints[(i,j-1)],\n                                                    uvpoints[(i-1,j-1)], uvpoints[(i-1,j)],\n                                                    uvpoints[(i,j)]], 1)\n                        # Create up curve based on vector points in a unit above surface\n                        up_curve = rs.AddCurve([uvvectors[(i,j)], uvvectors[(i,j-1)],\n                                                uvvectors[(i-1,j-1)], uvvectors[(i-1,j)],\n                                                uvvectors[(i,j)]], 1)\n                        # Get the spatial centroid of vector points in a unit above surface\n                        mid_pt = ((uvvectors[(i,j)][0]+uvvectors[(i-1,j-1)][0])/2,\n                                 (uvvectors[(i,j)][1]+uvvectors[(i-1,j-1)][1])/2,\n                                 (uvvectors[(i,j)][2]+uvvectors[(i-1,j-1)][2])/2)\n                        # Calculate the shortest distance from the centroid to curve(s)\n                        mid_distance = min(rs.Distance(mid_pt, curve_points_list))\n                        # This factor is used to scale and rotate up curve\n                        factor = math.sqrt(mid_distance)/mid_distance\n                        # A list of points in a unit\n                        pts = [uvpoints[(i,j)], uvpoints[(i,j-1)],\n                               uvpoints[(i-1,j-1)], uvpoints[(i-1,j)]]\n                        # Scale up curve\n                        rs.ScaleObject(up_curve, mid_pt,\n                                       ((1-factor)/(interval/2),\n                                        (1-factor)/(interval/2), 0.4))\n                        # Get control points of up curve\n                        pt_c = rs.CurvePoints(up_curve)\n                        # Save the distance from each point of\n                        # those four points in a unit to curve(s). #\n                        distance = []\n                        # Get transilation\n                        target = None # Target is where the up curve will be moved to\n                        origin = None # Origin of the up curve\n                        # Find the target point (furthest point to the attract curve(s))\n                        for p in pts:\n                            distance += [rs.Distance(p, curve_points_list)]\n                        for p in pts:\n                            if rs.Distance(p, curve_points_list) == max(distance):\n                                if p == uvpoints[(i,j)]:\n                                    target = uvvectors[(i,j)]\n                                elif p == uvpoints[(i,j-1)]:\n                                    target = uvvectors[(i,j-1)]\n                                elif p == uvpoints[(i-1,j-1)]:\n                                    target = uvvectors[(i-1,j-1)]\n                                else:\n                                    target = uvvectors[(i-1,j)]\n                        # Use the closest point of control points of up curve\n                        # to target point as origin. #\n                        for p in pt_c:\n                            if min(rs.Distance(target, pt_c)) == rs.Distance(target, p):\n                                origin = p\n                        # Make the centroid of vector points in a unit a 3D point\n                        mid_pt = rs.CreatePoint(mid_pt)\n                        # Calculate the transilation\n                        translation = target - origin\n                        # Move the up curve backward gainst the curve(s)\n                        rs.MoveObject(up_curve, translation)\n                        # Also move the controid\n                        rs.MoveObject(mid_pt, translation)\n                        # Rotate the moved up curve\n                        rs.RotateObject(up_curve, mid_pt, 50*factor)\n                        # Generate loft surface by up curve and bottom curve\n                        srf = rs.AddLoftSrf((up_curve, bottom_curve))\n                        m_index = rs.AddMaterialToObject(srf)\n                        rs.MaterialColor(m_index, (255,255,255))\n                        # Delete the up curve and bottom curve\n                        rs.DeleteObject(up_curve)\n                        rs.DeleteObject(bottom_curve)\n        count1 += 1\n\n# Final wraped up function\ndef main():\n    surface, curve_points_list, interval = srfsetup()\n    u_number = rs.GetInteger(message=\"set the number of point on u direction\",\n                             number=20)\n    v_number = rs.GetInteger(message=\"set the number of point on v direction\",\n                             number=20)\n    # Select a structure type\n    structure_type = 2\n    while structure_type != 0 and structure_type != 1:\n        structure_type = rs.GetInteger(message=\"choose structure type, only type 0 or 1\",\n                                       number=0)\n    u_domain, v_domain, u_step, v_step = surf_uv_stepsetup(surface, u_number, v_number)\n    if structure_type == 0:\n        uvpoints, uvvectors = surf_uv_pointsetup(surface, u_number, v_number,\n                                                 u_domain, v_domain, u_step, v_step,\n                                                 curve_points_list)\n    else:\n        uvpoints, uvvectors = attr_uv_pointsetup(surface, u_number, v_number,\n                                                 u_domain, v_domain, u_step, v_step,\n                                                 curve_points_list)\n    structure_generator(uvpoints, uvvectors, curve_points_list, u_number,\n                        v_number, interval)\n    rs.DeleteObject(surface)\n\n# Run\nmain()\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}