{
  "source_url": "https://github.com/fstwn/pyembroideryGH/blob/ee7fd47316b364962a69976b4168ce9fef2702cf/usrobj_src/pyembroideryGH_EmbroideryGrid.py",
  "repo": "fstwn/pyembroideryGH",
  "repo_stars": 11,
  "repo_description": "Set of UserObjects enabling Grasshopper to directly read, write and manipulate various kinds of embroidery formats. It is based on an IronPython-compatible fork of the original pyembroidery library.",
  "license": "MIT",
  "filepath": "usrobj_src/pyembroideryGH_EmbroideryGrid.py",
  "instruction": "Create grid-based embroidery stitches inside a closed boundary (closed curve).\n    Inputs:\n        Pattern: List of curves to create grid-based embroidery inside.\n                 {list, Curve}\n     ...",
  "code": "\"\"\"\nCreate grid-based embroidery stitches inside a closed boundary (closed curve).\n    Inputs:\n        Pattern: List of curves to create grid-based embroidery inside.\n                 {list, Curve}\n        ResolutionX: Resolution of stitches in X direction of the supplied\n                     plane.\n                     {item, float}\n        ResolutionY: Resolution of stitches in Y direction of the supplied\n                     plane.\n                     {item, float}\n        StitchPlane: Plane for creating the grid based embroidery stitches.\n                     {item, Plane}\n        Thread: EmbThread to use for the grid-based embroidery.\n                {item, EmbThread}\n    Output:\n        StitchPts: The stitch points of the generated embroidery as Rhino \n                   Points.\n                   {list/tree, Point3d}\n        Stitches: The stitches of the generated embroidery in string format.\n                  {list/tree, str)\n        StitchBlock: The generated grid-based embroidery as a StitchBlock.\n                     {item/list/tree, SitchBlock)\n    Remarks:\n        Author: Max Eschenbach\n        License: MIT License\n        Version: 211129\n\"\"\"\n\n# PYTHON STANDARD LIBRARY IMPORTS\nfrom __future__ import division\nfrom collections import deque\n\n# GHPYTHON SDK IMPORTS\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\n# ADDITIONAL RHINO IMPORTS\nimport scriptcontext\nfrom ghpythonlib import treehelpers as th\n\n# GHENV COMPONENT SETTINGS\nghenv.Component.Name = \"EmbroideryGrid\"\nghenv.Component.NickName = \"EG\"\nghenv.Component.Category = \"pyembroideryGH\"\nghenv.Component.SubCategory = \"3 Pattern Creation\"\n\n# LOCAL MODULE IMPORTS\ntry:\n    import pyembroidery\nexcept ImportError:\n    errMsg = (\"The pyembroidery python module seems to be not correctly \" +\n              \"installed! Please make sure the module is in you search \" +\n              \"path, see README for instructions!.\")\n    raise ImportError(errMsg)\n\nclass StitchBlock(object):\n    \n    def __init__(self, stitches, thread):\n        self._set_stitches(stitches)\n        self._set_thread(thread)\n    \n    def __getitem__(self, item):\n        return (self.stitches, self.thread)[item]\n    \n    def get_stitches_iter(self):\n        for s in self._stitches:\n            yield s\n    \n    def _get_stitches(self):\n        return self._stitches\n    \n    def _set_stitches(self, stitches):\n        if isinstance(stitches, list):\n            self._stitches = stitches\n        elif isinstance(stitches, tuple):\n            self._stitches = list(stitches)\n        else:\n            raise ValueError(\"Supplied data for stitches is not a valid list \" +\n                             \"of stitches!\")\n    \n    stitches = property(_get_stitches, _set_stitches, None,\n                        \"The stitches of this StitchBlock\")\n    \n    def _get_thread(self):\n        return self._thread\n    \n    def _set_thread(self, thread):\n        if isinstance(thread, pyembroidery.EmbThread):\n            self._thread = thread\n        else:\n            raise ValueError(\"Supplied thread is not a valid EmbThread \" + \n                             \"instance!\")\n    \n    thread = property(_get_thread, _set_thread, None,\n                      \"The thread of this StitchBlock\")\n    \n    def ToString(self):\n        descr = \"StitchBlock ({} Stitches, EmbThread {})\"\n        color = self.thread.hex_color()\n        descr = descr.format(len(self.stitches), color)\n        return descr\n\nclass EmbroideryGrid(component):\n    \n    def _sanitize_input_data(self, crvs, planes, threads):\n        # get longest list\n        data = [crvs, planes, threads]\n        counts = [len(l) for l in data]\n        maxcount = max(counts)\n        for i in range(maxcount):\n            if i > len(crvs) - 1:\n                crvs.append(crvs[-1])\n            if i > len(planes) - 1:\n                planes.append(planes[-1])\n            if i > len(threads) - 1:\n                threads.append(threads[-1])\n        return crvs, planes, threads\n    \n    def _get_branch_counts(self, branched_rows):\n        return [len(row) for row in branched_rows] \n    \n    def _get_first_nonzero(self, branched_rows):\n        for i, row in enumerate(branched_rows):\n            if len(row) > 0:\n                return i\n        return -1\n    \n    def _point_to_stitch(self, pt, cmd):\n        return \",\".join([str(pt.X * 10), \n                         str(pt.Y * -10),\n                         str(cmd)])\n    \n    def _points_to_stitches(self, pts, cmds):\n        stitches = []\n        stitch_strings = []\n        if len(pts) >= len(cmds):\n            for i, pt in enumerate(pts):\n                # extract command with failsafe\n                if i <= len(cmds) - 1:\n                    command = cmds[i]\n                else:\n                    command = cmds[-1]\n                # compile stitch string\n                stitch_str = \",\".join([str(pt.X * 10), \n                                       str(pt.Y * -10),\n                                       str(command)])\n                # append to list of stitches\n                stitches.append((pt.X * 10, pt.Y * -10, int(command)))\n                stitch_strings.append(stitch_str)\n        # list of commands is longer than list of points, so we have to\n        # loop over the list of commands\n        elif len(pts) < len(cmds):\n            for j, command in enumerate(cmds):\n                # extract coordinate with failsafe\n                if j <= len(pts) - 1:\n                    pt = pts[j]\n                else:\n                    pt = pts[-1]\n                # compile stitch string\n                stitch_str = \",\".join([str(pt.X * 10),\n                                       str(pt.Y * -10),\n                                       str(command)])\n                # append to list of stitches\n                stitches.append((pt.X * 10, pt.Y * -10, int(command)))\n                stitch_strings.append(stitch_str)\n        return stitches, stitch_strings\n    \n    def _find_closest_branch(self, lastpt, gridlines, branched_rows):\n        candidate_branches = []\n        for i, row in enumerate(branched_rows):\n            row = branched_rows[i]\n            branchcount = len(row)\n            if branchcount > 0:\n                for j, branch in enumerate(row):\n                    dist = lastpt.DistanceToSquared(gridlines[j].PointAt(branch[0]))\n                    candidate_branches.append((dist, i, j))\n        dists, rowindex, branchindex = zip(*sorted(candidate_branches))\n        return (rowindex[0], branchindex[0])\n    \n    def RunScript(self, input_curves, ResolutionX, ResolutionY, StitchPlane, Thread):\n        # initialize outputs so they're never empty\n        StitchPts = Grasshopper.DataTree[object]()\n        Stitches = Grasshopper.DataTree[object]()\n        stitch_block = Grasshopper.DataTree[object]()\n        allrows = Grasshopper.DataTree[object]()\n        \n        # set constants and defaults\n        tol = scriptcontext.doc.ModelAbsoluteTolerance\n        if not StitchPlane:\n            StitchPlane = [Rhino.Geometry.Plane.WorldXY]\n        if not Thread:\n            Thread = [pyembroidery.EmbThread()]\n        \n        \n        if input_curves and StitchPlane and Thread:\n            # sanitize input data list lengths\n            input_curves, StitchPlane, Thread = self._sanitize_input_data(input_curves, StitchPlane, Thread)\n            \n            # CREATE VALID ROWS OF STITCHPTS ----------------------------------\n            \n            # loop over all input curves\n            for i, crv in enumerate(input_curves):\n                # first get the boundingbox of the current curve\n                bbx = crv.GetBoundingBox(False)\n                # then rotate the plane\n                bbx_center = Rhino.Geometry.Point3d(bbx.Center.X,\n                                                    bbx.Center.Y,\n                                                    0.0)\n                # get aligned rotated bbx\n                pln = StitchPlane[i]\n                pln.Origin = bbx_center\n                bbx = crv.GetBoundingBox(pln)\n                # get projected corners from bounding box\n                botleft = pln.PointAt(bbx.Min.X, bbx.Min.Y, bbx.Min.Z)\n                botright = pln.PointAt(bbx.Max.X, bbx.Min.Y, bbx.Min.Z)\n                topleft = pln.PointAt(bbx.Min.X, bbx.Max.Y, bbx.Min.Z)\n                topright = pln.PointAt(bbx.Max.X, bbx.Max.Y, bbx.Min.Z)\n                \n                # first get all \"x axis lines along y\" by creating the y\n                # axis and dividing it\n                y_ax = Rhino.Geometry.LineCurve(botleft, topleft)\n                y_basepts = [y_ax.PointAt(t) for t \n                             in y_ax.DivideByCount(ResolutionY, True)]\n                tvecs = [Rhino.Geometry.Vector3d(bpt - botleft)\n                         for bpt in y_basepts]\n                \n                # create base x axis\n                x_ax = Rhino.Geometry.LineCurve(botleft, botright)\n                x_basepts = [x_ax.PointAt(t) for t \n                             in x_ax.DivideByCount(ResolutionX, True)]\n                \n                # create rows by translating base x axis with all y vectors\n                rows = []\n                gridlines = []\n                gridparams = []\n                for v in tvecs:\n                    row = [xpt + v for xpt in x_basepts]\n                    ln = Rhino.Geometry.Line(row[0], row[-1])\n                    gridparams.append([ln.ClosestParameter(pt) for pt in row])\n                    ln = ln.ToNurbsCurve()\n                    ln.Domain = Rhino.Geometry.Interval(0, 1)\n                    rows.append(row)\n                    gridlines.append(ln)\n                \n                # GET INTERSECTION EVENTS AND BRANCHED ROWS -------------------\n                \n                branched_rows = [deque([]) for x in rows]\n                for j, row in enumerate(rows):\n                    \n                    # get intersection events and all their parameters\n                    intevents = Rhino.Geometry.Intersect.Intersection.CurveCurve(gridlines[j], crv, tol, tol)\n                    intparams = []\n                    for e in intevents:\n                        if e.IsOverlap:\n                            intparams.append(e.OverlapA.Min)\n                            intparams.append(e.OverlapA.Max)\n                        else:\n                            intparams.append(e.ParameterA)\n                    \n                    # ONE event means intersection is exactly at a corner\n                    # create a new branch with a single point in this row\n                    if len(intparams) == 1:\n                        branched_rows[j].append(intparams)\n                    \n                    # >= TWO and EVEN number of intersections means there\n                    # are defined domains of points inside the curve\n                    elif len(intparams) >= 2 and (len(intparams) % 2) == 0:\n                        for k in range(len(intparams)):\n                            if k % 2 != 0:\n                                continue\n                            sequence = [t for t in gridparams[j] if t > intparams[k] and t < intparams[k + 1]]\n                            sequence.insert(0, intparams[k])\n                            sequence.append(intparams[k + 1])\n                            branched_rows[j].append(sequence)\n                    \n                    # >= THREE and UNEVEN number of intersections means we have\n                    # to check point containment to find the domains inside\n                    # the boundary curve\n                    elif len(intparams) > 2 and (len(intparams) % 2) != 0:\n                        protoseq = intparams + [t for t in gridparams[j] if t > min(intparams) and t < max(intparams)]\n                        protoseq.sort()\n                        last_inside = None\n                        sequence = []\n                        for k, param in enumerate(protoseq):\n                            pt = gridlines[j].PointAt(param)\n                            # check point for containment\n                            containment =  crv.Contains(pt,\n                                                        Rhino.Geometry.Plane.WorldXY,\n                                                        tol)\n                            pt_on_curve = (containment == Rhino.Geometry.PointContainment.Inside or containment == Rhino.Geometry.PointContainment.Coincident)\n                            # if point is in, it is part of the current seq\n                            if pt_on_curve:\n                                sequence.append(param)\n                            elif not pt_on_curve and len(sequence) > 0:\n                                branched_rows[j].append(sequence)\n                                sequence = []\n                            # set boolean to check previous point containment\n                            last_inside = pt_on_curve\n                \n                # LOOP OVER ALL BRANCHED ROWS AND RESOLVE ---------------------\n                \n                j = 0\n                lastidx = -1\n                lastcount = 0\n                param_sequence = []\n                total_sequence = []\n                stitch_sequence = []\n                block = []\n                \n                while j < len(branched_rows):\n                    # set row and get branchcount\n                    row = branched_rows[j]\n                    branchcount = len(row)\n                    # only step into row if it has any branches\n                    if branchcount >= 1:\n                        # pop the next branch from the current row\n                        branch = row.popleft()\n                        stitchpts = [gridlines[j].PointAt(t) for t in branch]\n                        commands = [pyembroidery.STITCH for pt in stitchpts]\n                        # check for jumps\n                        if lastidx != j - 1:\n                            print \"Jump detected! From {} to {}!\".format(lastidx, j)\n                            # inject trim command\n                            branch.insert(0, param_sequence[-1])\n                            stitchpts.insert(0, total_sequence[-1])\n                            commands.insert(0, pyembroidery.TRIM)\n                            \n                            \"\"\"\n                            # if a jump is detected, prepare the travel path\n                            spt = gridlines[j].PointAt(param_sequence[-1])\n                            ept = gridlines[j].PointAt(branch[0])\n                            rawmove = Rhino.Geometry.LineCurve(spt, ept)\n                            rawmove.Domain = Rhino.Geometry.Interval(0, 1)\n                            # check raw move for intersection\n                            intevents = Rhino.Geometry.Intersect.Intersection.CurveCurve(rawmove, crv, tol, tol)\n                            intparams = []\n                            for e in intevents:\n                                if e.IsOverlap:\n                                    intparams.append(e.OverlapA.Min)\n                                    intparams.append(e.OverlapA.Max)\n                                else:\n                                    intparams.append(e.ParameterA)\n                            print intparams\n                            \"\"\"\n                        stitches, stitch_strings = self._points_to_stitches(stitchpts, commands)\n                        block.extend(stitches)\n                        stitch_sequence.extend(stitch_strings)\n                        param_sequence.extend(branch)\n                        total_sequence.extend(stitchpts)\n                        if j == len(branched_rows) - 1:\n                            nzi = self._get_first_nonzero(branched_rows)\n                            print \"Last row reached, first nonzero is: {}\".format(nzi)\n                            if nzi != -1:\n                                cb = self._find_closest_branch(stitchpts[-1],\n                                                               gridlines,\n                                                               branched_rows)\n                                print cb\n                                lastidx = j\n                                j = cb[0]\n                                continue\n                            else:\n                                # inject trim and finish\n                                stitch = block[-1]\n                                stitch = (stitch[0], stitch[1], pyembroidery.TRIM)\n                                block.append(stitch)\n                                stitch_strings.append(\",\".join([str(stitch[0]), \n                                                                str(stitch[1]),\n                                                                str(stitch[2])]))\n                                param_sequence.append(param_sequence[-1])\n                                total_sequence.append(total_sequence[-1])\n                                break\n                    \n                    # if row is empty, find nonzero row with the lowest index\n                    else:\n                        nzi = self._get_first_nonzero(branched_rows)\n                        print \"Row at index {} has no branches! First nonzero is: {}\".format(j, nzi)\n                        if nzi != -1:\n                            lastidx = j\n                            j = nzi\n                            continue\n                        # if all rows are empty, inject trim command and finish\n                        else:\n                            stitch = block[-1]\n                            stitch = (stitch[0], stitch[1], pyembroidery.TRIM)\n                            block.append(stitch)\n                            stitch_strings.append(\",\".join([str(stitch[0]), \n                                                            str(stitch[1]),\n                                                            str(stitch[2])]))\n                            param_sequence.append(param_sequence[-1])\n                            total_sequence.append(total_sequence[-1])\n                            lastidx = j\n                            j += 1\n                            break\n                    \n                    # set last index value and increment j\n                    lastidx = j\n                    j += 1\n                \n                # CREATE STITCHBLOCK ------------------------------------------\n                \n                try:\n                    sblock = StitchBlock(block, Thread[i])\n                except Exception, e:\n                    rml = self.RuntimeMessageLevel.Warning\n                    errMsg = \"Could not create StitchBlock at index {}!\"\n                    errMsg = \" \".join([errMsg, e]).format(i)\n                    self.AddRuntimeMessage(rml, errMsg)\n                    sblock = None\n                \n                # PREPARE OUTPUTS ---------------------------------------------\n                path = Grasshopper.Kernel.Data.GH_Path(i)\n                StitchPts.AddRange(total_sequence, path)\n                Stitches.AddRange(stitch_sequence, path)\n                stitch_block.Add(sblock, path)\n                \n                # dev output\n                for j, row in enumerate(rows):\n                    allrows.AddRange(row, path)\n            \n        else:\n            rml = self.RuntimeMessageLevel.Warning\n            errMsg = (\"Input Curve failed to collect data!\")\n            self.AddRuntimeMessage(rml, errMsg)\n        \n        # return outputs if you have them; here I try it for you:\n        return StitchPts, Stitches, stitch_block",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}