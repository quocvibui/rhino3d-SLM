{
  "source_url": "https://github.com/ladybug-tools/honeybee-legacy/blob/bd62af4862fe022801fb87dbc8794fdf1dff73a9/src/Honeybee_Construct%20Energy%20Balance.py",
  "repo": "ladybug-tools/honeybee-legacy",
  "repo_stars": 129,
  "repo_description": ":bee: Honeybee is a free and open source plugin to connect Grasshopper3D to EnergyPlus, Radiance, Daysim and OpenStudio for building energy and daylighting simulation",
  "license": "NOASSERTION",
  "filepath": "src/Honeybee_Construct Energy Balance.py",
  "instruction": "This component accepst the outputs of the \"Read EP Result\" and the \"Read EP Surface Result\" components and outputs a data tree with all of the building-wide energy balance terms.  This can then be...",
  "code": "#\n# Honeybee: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Honeybee.\n# \n# Copyright (c) 2013-2020, Chris Mackey <Chris@MackeyArchitecture.com> \n# Honeybee is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Honeybee is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Honeybee; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nThis component accepst the outputs of the \"Read EP Result\" and the \"Read EP Surface Result\" components and outputs a data tree with all of the building-wide energy balance terms.  This can then be plugged into the \"Ladybug_3D Chart\" or \"Ladybug_Monthly Bar Chart\" to give a visualization of the energy balance of the whole model.\n\n-\nProvided by Honeybee 0.0.66\n    \n    Args:\n        _HBZones: The HBZones out of any of the HB components that generate or alter zones.  Note that these should ideally be the zones that are fed into the Run Energy Simulation component.  Zones read back into Grasshopper from the Import idf component will not align correctly with the EP Result data.\n        cooling_: The cooling load from the \"Honeybee_Read EP Result\" component.\n        heating_: The heating load from the \"Honeybee_Read EP Result\" component.\n        electricLight_: The electric lighting load from the \"Honeybee_Read EP Result\" component.\n        electricEquip_: The electric equipment load from the \"Honeybee_Read EP Result\" component.\n        fanElectric_: The electric fan load from the \"Honeybee_Read EP Result\" component.\n        peopleGains_: The people gains from the \"Honeybee_Read EP Result\" component.\n        totalSolarGain_: The total solar gain from the \"Honeybee_Read EP Result\" component.\n        infiltrationEnergy_: The infiltration heat loss (negative) or heat gain (positive) from the \"Honeybee_Read EP Result\" component.\n        mechVentilationEnergy_: The outdoor air heat loss (negative) or heat gain (positive) from the \"Honeybee_Read EP Result\" component.\n        natVentEnergy_: The natural ventilation heat loss (negative) or heat gain (positive) from the \"Honeybee_Read EP Result\" component.\n        surfaceEnergyFlow_: The surface heat loss (negative) or heat gain (positive) from the \"Honeybee_Read EP Surface Result\" component.\n    Returns:\n        readMe!: ...\n        --------------------: ...\n        flrNormEnergyBal: A data tree with the important building-wide energy balance terms normalized by floor area.  This can then be plugged into the \"Ladybug_3D Chart\" or \"Ladybug_Monthly Bar Chart\" to give a visualization of the energy balance of the whole model.\n        flrNormBalWStorage:  A data tree with the important building-wide energy balance terms normalized by floor area plus an additional term to represent the energy being stored in the building's mass.  If you have input all of the terms of your energy balance to this component, you storage term should be very small in relation to the other energy balance terms.  Thus, this storage term can be a good way to check whether all of your energy balance terms are accounted for.  This output can then be plugged into the \"Ladybug_3D Chart\" or \"Ladybug_Monthly Bar Chart\" to give a visualization of the energy balance of the whole model.\n        --------------------: ...\n        modelEnergyBalance:  A data tree with the important building-wide energy balance terms.  This can then be plugged into the \"Ladybug_3D Chart\" or \"Ladybug_Monthly Bar Chart\" to give a visualization of the energy balance of the whole model.\n        energyBalWithStorage:  A data tree with the important building-wide energy balance terms plus an additional term to represent the energy being stored in the building's mass.  If you have input all of the terms of your energy balance to this component, you storage term should be very small in relation to the other energy balance terms.  Thus, this storage term can be a good way to check whether all of your energy balance terms are accounted for.  This output can then be plugged into the \"Ladybug_3D Chart\" or \"Ladybug_Monthly Bar Chart\" to give a visualization of the energy balance of the whole model.\n\"\"\"\n\nghenv.Component.Name = \"Honeybee_Construct Energy Balance\"\nghenv.Component.NickName = 'energyBalance'\nghenv.Component.Message = 'VER 0.0.66\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"HB-Legacy\"\nghenv.Component.SubCategory = \"10 | Energy | Energy\"\n#compatibleHBVersion = VER 0.0.56\\nFEB_21_2016\n#compatibleLBVersion = VER 0.0.59\\nAPR_04_2015\nghenv.Component.AdditionalHelpFromDocStrings = \"5\"\n\n\nfrom System import Object\nfrom clr import AddReference\nAddReference('Grasshopper')\nimport Grasshopper.Kernel as gh\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\nimport scriptcontext as sc\n\n\n\ndef checkCreateDataTree(dataTree, dataName, dataType):\n    #Define a variable for warnings.\n    w = gh.GH_RuntimeMessageLevel.Warning\n    \n    #Convert the data tree to a python list.\n    dataPyList = []\n    for i in range(dataTree.BranchCount):\n        branchList = dataTree.Branch(i)\n        dataVal = []\n        for item in branchList:\n            try: dataVal.append(float(item))\n            except: dataVal.append(item)\n        dataPyList.append(dataVal)\n    \n    #Test to see if the data has a header on it, which is necessary to know if it is the right data type.  If there's no header, the data should not be vizualized with this component.\n    checkHeader = []\n    dataHeaders = []\n    dataNumbers = []\n    for list in dataPyList:\n        if str(list[0]) == \"key:location/dataType/units/frequency/startsAt/endsAt\":\n            checkHeader.append(1)\n            dataHeaders.append(list[:7])\n            dataNumbers.append(list[7:])\n        else:\n            dataNumbers.append(list)\n    \n    if sum(checkHeader) == len(dataPyList):\n        dataCheck1 = True\n    else:\n        if len(dataPyList) > 0 and dataPyList[0][0] == None: pass\n        else:\n            dataCheck1 = False\n            warning = \"Not all of the connected \" + dataName + \" has a Ladybug/Honeybee header on it.  This header is necessary to generate an indoor temperture map with this component.\"\n            print warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n    \n    try:\n        #Check to be sure that the lengths of data in in the dataTree branches are all the same.\n        dataLength = len(dataNumbers[0])\n        dataLenCheck = []\n        for list in dataNumbers:\n            if len(list) == dataLength:\n                dataLenCheck.append(1)\n            else: pass\n        if sum(dataLenCheck) == len(dataNumbers) and dataLength <8761:\n            dataCheck2 = True\n        else:\n            dataCheck2 = False\n            warning = \"Not all of the connected \" + dataName + \" branches are of the same length or there are more than 8760 values in the list.\"\n            print warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n        \n        if dataCheck1 == True:\n            #Check to be sure that all of the data headers say that they are of the same type.\n            header = dataHeaders[0]\n            \n            headerUnits =  header[3]\n            headerStart = header[5]\n            headerEnd = header[6]\n            simStep = str(header[4])\n            headUnitCheck = []\n            headPeriodCheck = []\n            nonIdealAir = False\n            for head in dataHeaders:\n                if dataType == 'Heating' or dataType == 'Cooling':\n                    if 'Chiller' in head[2] or 'Coil' in head[2] or 'Boiler' in head[2]:\n                        nonIdealAir = True\n                if dataType in head[2]:\n                    headUnitCheck.append(1)\n                if head[3] == headerUnits and str(head[4]) == simStep and head[5] == headerStart and head[6] == headerEnd:\n                    headPeriodCheck.append(1)\n                else: pass\n            \n            if sum(headPeriodCheck) == len(dataHeaders):\n                dataCheck3 = True\n            else:\n                dataCheck3 = False\n                warning = \"Not all of the connected \" + dataName + \" branches are of the same timestep or same analysis period.\"\n                print warning\n                ghenv.Component.AddRuntimeMessage(w, warning)\n            \n            if sum(headUnitCheck) == len(dataHeaders):\n                dataCheck4 = True\n            else:\n                dataCheck4 = False\n                warning = \"Not all of the connected \" + dataName + \" data is for the correct data type.\"\n                print warning\n                ghenv.Component.AddRuntimeMessage(w, warning)\n            \n            if nonIdealAir == True:\n                dataCheck4 = False\n                warning = \"The HVAC system of the connected data is not Ideal Air.\\n An ideal air system is necessary to reconstruct the zone-level energy balance.\"\n                print warning\n                ghenv.Component.AddRuntimeMessage(w, warning)\n            \n            if 'm2' in headerUnits or 'ft2' in headerUnits:\n                dataCheck5 = False\n                warning = \"The data from the \" + dataName + \" input has been normalized by an area. \\n Values need to be non-normalized for the energy balance to work.\"\n                print warning\n                ghenv.Component.AddRuntimeMessage(w, warning)\n            else:\n                dataCheck5 = True\n            \n            if dataCheck1 == True and dataCheck2 == True and dataCheck3 == True and dataCheck4 == True and dataCheck5 == True: dataCheck = True\n            else: dataCheck = False\n        else:\n            dataCheck = False\n            headerUnits = 'unknown units'\n            dataHeaders = []\n            header = [None, None, None, None, None, None, None]\n    except:\n        dataCheck = True\n        headerUnits = None\n        dataHeaders = []\n        dataNumbers = []\n        header = [None, None, None, None, None, None, None]\n    \n    return dataCheck, headerUnits, dataHeaders, dataNumbers, [header[5], header[6]]\n\n\ndef getSrfNames(HBZones):\n    wall = []\n    window = []\n    skylight =[]\n    roof = []\n    exposedFloor = []\n    groundFloor = []\n    undergroundWall = []\n    \n    for zone in HBZones:\n        # call the objects from the lib\n        hb_hive = sc.sticky[\"honeybee_Hive\"]()\n        \n        zone = hb_hive.visualizeFromHoneybeeHive([zone])[0]\n        \n        for srf in zone.surfaces:\n            if srf.BC.upper() == \"OUTDOORS\" or srf.BC.upper() == \"GROUND\":\n                if srf.BC.upper() == \"OUTDOORS\":\n                    # Wall\n                    if srf.type == 0 or srf.type == 0.5:\n                        if srf.hasChild:\n                            wall.append(srf.name)\n                            for childSrf in srf.childSrfs:\n                                window.append(childSrf.name)\n                        else: wall.append(srf.name)\n                    #Roof\n                    elif srf.type == 1 or srf.type == 3 or srf.type == 1.5:\n                        if srf.hasChild:\n                            roof.append(srf.name)\n                            for childSrf in srf.childSrfs:\n                                skylight.append(childSrf.name)\n                        else: roof.append(srf.name)\n                    #Floor\n                    elif srf.type == 2.75 or srf.type == 2.5 or srf.type == 2:\n                        if srf.hasChild:\n                            exposedFloor.append(srf.name)\n                            for childSrf in srf.childSrfs:\n                                skylight.append(childSrf.name)\n                        else: exposedFloor.append(srf.name)\n                elif srf.BC.upper() == \"GROUND\":\n                    # Wall\n                    if srf.type == 0 or srf.type == 0.5:\n                        if srf.hasChild:\n                            undergroundWall.append(srf.name)\n                            for childSrf in srf.childSrfs:\n                                window.append(childSrf.name)\n                        else: undergroundWall.append(srf.name)\n                    #Roof\n                    elif srf.type == 1 or srf.type == 3 or srf.type == 1.5 or srf.type == 2.75 or srf.type == 2.5 or srf.type == 2:\n                        if srf.hasChild:\n                            groundFloor.append(srf.name)\n                            for childSrf in srf.childSrfs:\n                                skylight.append(childSrf.name)\n                        else: groundFloor.append(srf.name)\n                    #Floor\n                    elif srf.type == 2.75 or srf.type == 2.5 or srf.type == 2:\n                        if srf.hasChild:\n                            exposedFloor.append(srf.name)\n                            for childSrf in srf.childSrfs:\n                                skylight.append(childSrf.name)\n                        else: exposedFloor.append(srf.name)\n    \n    return wall, window, skylight, roof, \\\n           exposedFloor, groundFloor, undergroundWall\n\ndef checkList(theList, dataTree, name, branchList):\n    itemFound = False\n    for srf in theList:\n        if srf.upper() == name:\n            dataTree.append(branchList)\n            itemFound = True\n        else: pass\n    return itemFound\n\ndef sumAllLists(tree):\n    if len(tree) == 1: summedList = tree[0]\n    else:\n        summedList = tree[0]\n        for dataCount, dataList in enumerate(tree):\n            if dataCount == 0: pass\n            else:\n                for count, item in enumerate(dataList):\n                    summedList[count] = summedList[count] + item\n    \n    return summedList\n\n\ndef main(HBZones, heatingLoad, solarLoad, lightingLoad, equipLoad, fanElectric, peopleLoad, surfaceEnergyFlow, infiltrationEnergy, outdoorAirEnergy, natVentEnergy, coolingLoad):\n    #Get the zone floor area.\n    hb_hive = sc.sticky[\"honeybee_Hive\"]()\n    flrAreas = []\n    for Hzone in HBZones:\n        zone = hb_hive.visualizeFromHoneybeeHive([Hzone])[0]\n        flrAreas.append(zone.getFloorArea())\n    totalFlrArea = sum(flrAreas)\n    \n    #Check and convert the data for each of the zone data lists.\n    checkData1, heatingUnits, heatingHeaders, heatingNumbers, heatingAnalysisPeriod = checkCreateDataTree(heatingLoad, \"heating\", \"Heating\")\n    checkData2, solarUnits, solarHeaders, solarNumbers, solarAnalysisPeriod = checkCreateDataTree(solarLoad, \"totalSolarGain_\", \"Solar\")\n    checkData3, lightingUnits, lightingHeaders, lightingNumbers, lightingAnalysisPeriod = checkCreateDataTree(lightingLoad, \"electricLight_\", \"Lighting\")\n    checkData4, equipUnits, equipHeaders, equipNumbers, equipAnalysisPeriod = checkCreateDataTree(equipLoad, \"electricEquip_\", \"Equipment\")\n    checkData5, peopleUnits, peopleHeaders, peopleNumbers, peopleAnalysisPeriod = checkCreateDataTree(peopleLoad, \"peopleGains_\", \"People\")\n    checkData6, infiltrationUnits, infiltrationHeaders, infiltrationNumbers, infiltrationAnalysisPeriod = checkCreateDataTree(infiltrationEnergy, \"infiltrationEnergy_\", \"Infiltration\")\n    checkData7, outdoorAirUnits, outdoorAirHeaders, outdoorAirNumbers, outdoorAirAnalysisPeriod = checkCreateDataTree(outdoorAirEnergy, \"mechVentilationEnergy_\", \"Mechanical Ventilation\")\n    checkData8, natVentUnits, natVentHeaders, natVentNumbers, natVentAnalysisPeriod = checkCreateDataTree(natVentEnergy, \"natVentEnergy_\", \"Natural Ventilation\")\n    checkData9, coolingUnits, coolingHeaders, coolingNumbers, coolingAnalysisPeriod = checkCreateDataTree(coolingLoad, \"cooling\", \"Cooling\")\n    checkData10, surfaceUnits, surfaceHeaders, surfaceNumbers, surfaceAnalysisPeriod = checkCreateDataTree(surfaceEnergyFlow, \"surfaceEnergyFlow_\", \"Surface Energy\")\n    checkData11, fanUnits, fanHeaders, fanNumbers, fanAnalysisPeriod = checkCreateDataTree(fanElectric, \"fanElectric_\", \"Fan Electric\")\n    \n    if checkData1 == True and checkData2 == True and checkData3 == True and checkData4 == True and checkData5 == True and checkData6 == True and checkData7 == True and checkData8 == True and checkData9 == True  and checkData10 == True and checkData11 == True:\n        #Get the names of the surfaces from the HBZones.\n        wall, window, skylight, roof, exposedFloor, groundFloor, undergroundWall = getSrfNames(HBZones)\n        \n        #Organize all of the surface data by type of surface.\n        opaqueEnergyFlow = []\n        glazingEnergyFlow = []\n        \n        if len(surfaceNumbers) > 0:\n            for srfCount, srfHeader in enumerate(surfaceHeaders):\n                try:srfName = srfHeader[2].split(\" for \")[-1].split(\": \")[0]\n                except:srfName = srfHeader[2].split(\" for \")[-1]\n                \n                itemFound = checkList(wall, opaqueEnergyFlow, srfName, surfaceNumbers[srfCount])\n                if itemFound == False: itemFound = checkList(window, glazingEnergyFlow, srfName, surfaceNumbers[srfCount])\n                if itemFound == False: itemFound = checkList(skylight, glazingEnergyFlow, srfName, surfaceNumbers[srfCount])\n                if itemFound == False: itemFound = checkList(roof, opaqueEnergyFlow, srfName, surfaceNumbers[srfCount])\n                if itemFound == False: itemFound = checkList(exposedFloor, opaqueEnergyFlow, srfName, surfaceNumbers[srfCount])\n                if itemFound == False: itemFound = checkList(groundFloor, opaqueEnergyFlow, srfName, surfaceNumbers[srfCount])\n                if itemFound == False: itemFound = checkList(undergroundWall, opaqueEnergyFlow, srfName, surfaceNumbers[srfCount])\n        \n        #Sum all of the zones and sufaces into one list for each energy balance term.\n        if len(heatingNumbers) > 0: heatingNumbers = sumAllLists(heatingNumbers)\n        if len(solarNumbers) > 0: solarNumbers = sumAllLists(solarNumbers)\n        if len(lightingNumbers) > 0: lightingNumbers = sumAllLists(lightingNumbers)\n        if len(equipNumbers) > 0: equipNumbers = sumAllLists(equipNumbers)\n        if len(fanNumbers) > 0: fanNumbers = sumAllLists(fanNumbers)\n        if len(peopleNumbers) > 0: peopleNumbers = sumAllLists(peopleNumbers)\n        if len(infiltrationNumbers) > 0: infiltrationNumbers = sumAllLists(infiltrationNumbers)\n        if len(outdoorAirNumbers) > 0: outdoorAirNumbers = sumAllLists(outdoorAirNumbers)\n        if len(natVentNumbers) > 0: natVentNumbers = sumAllLists(natVentNumbers)\n        if len(coolingNumbers) > 0: coolingNumbers = sumAllLists(coolingNumbers)\n        if len(opaqueEnergyFlow) > 0: opaqueEnergyFlow = sumAllLists(opaqueEnergyFlow)\n        if len(glazingEnergyFlow) > 0: glazingEnergyFlow = sumAllLists(glazingEnergyFlow)\n        \n        #Subtract the solar load from the glazing energy flow to get just the heat conduction through the glazing.\n        for count, val in enumerate(glazingEnergyFlow):\n            glazingEnergyFlow[count] = val - solarNumbers[count]\n        \n        #Make sure that the cooling energy is negative.\n        if len(coolingNumbers) > 0:\n            for count, val in enumerate(coolingNumbers):\n                coolingNumbers[count] = -val\n        \n        #Add headers to the data number lists\n        if len(heatingNumbers) > 0: heatingHeader = heatingHeaders[0][:2] + ['Heating'] + [heatingUnits] + [heatingHeaders[0][4]] + heatingAnalysisPeriod\n        if len(solarNumbers) > 0: solarHeader = solarHeaders[0][:2] + ['Solar'] + [solarUnits] + [solarHeaders[0][4]] + solarAnalysisPeriod\n        if len(lightingNumbers) > 0: lightingHeader = lightingHeaders[0][:2] + ['Lighting'] + [lightingUnits] + [lightingHeaders[0][4]] + lightingAnalysisPeriod\n        if len(equipNumbers) > 0: equipHeader = equipHeaders[0][:2] + ['Equipment'] + [equipUnits] + [equipHeaders[0][4]] + equipAnalysisPeriod\n        if len(fanNumbers) > 0: fanHeader = fanHeaders[0][:2] + ['Fan Electric'] + [fanUnits] + [fanHeaders[0][4]] + fanAnalysisPeriod\n        if len(peopleNumbers) > 0: peopleHeader = peopleHeaders[0][:2] + ['People'] + [peopleUnits] + [peopleHeaders[0][4]] + peopleAnalysisPeriod\n        if len(infiltrationNumbers) > 0: infiltrationHeader = infiltrationHeaders[0][:2] + ['Infiltration'] + [infiltrationUnits] + [infiltrationHeaders[0][4]] + infiltrationAnalysisPeriod\n        if len(outdoorAirNumbers) > 0: outdoorAirHeader = outdoorAirHeaders[0][:2] + ['Mechanical Ventilation'] + [outdoorAirUnits] + [outdoorAirHeaders[0][4]] + outdoorAirAnalysisPeriod\n        if len(natVentNumbers) > 0: natVentHeader = natVentHeaders[0][:2] + ['Natural Ventilation'] + [natVentUnits] + [natVentHeaders[0][4]] + natVentAnalysisPeriod\n        if len(coolingNumbers) > 0: coolingHeader = coolingHeaders[0][:2] + ['Cooling'] + [coolingUnits] + [coolingHeaders[0][4]] + coolingAnalysisPeriod\n        if len(opaqueEnergyFlow) > 0: opaqueHeader = surfaceHeaders[0][:2] + ['Opaque Conduction'] + [surfaceUnits] + [surfaceHeaders[0][4]] + surfaceAnalysisPeriod\n        if len(glazingEnergyFlow) > 0: glazingHeader = surfaceHeaders[0][:2] + ['Glazing Conduction'] + [surfaceUnits] + [surfaceHeaders[0][4]] + surfaceAnalysisPeriod\n        \n        #Put each of the terms into one master list.    \n        modelEnergyBalance = []\n        modelEnergyBalanceNum = []\n        if len(heatingNumbers) > 0:\n            modelEnergyBalance.append(heatingHeader + heatingNumbers)\n            modelEnergyBalanceNum.append(heatingNumbers)\n        if len(solarNumbers) > 0:\n            modelEnergyBalance.append(solarHeader + solarNumbers)\n            modelEnergyBalanceNum.append(solarNumbers)\n        if len(equipNumbers) > 0:\n            modelEnergyBalance.append(equipHeader + equipNumbers)\n            modelEnergyBalanceNum.append(equipNumbers)\n        if len(fanNumbers) > 0:\n            modelEnergyBalance.append(fanHeader + fanNumbers)\n            modelEnergyBalanceNum.append(fanNumbers)\n        if len(lightingNumbers) > 0:\n            modelEnergyBalance.append(lightingHeader + lightingNumbers)\n            modelEnergyBalanceNum.append(lightingNumbers)\n        if len(peopleNumbers) > 0:\n            modelEnergyBalance.append(peopleHeader + peopleNumbers)\n            modelEnergyBalanceNum.append(peopleNumbers)\n        if len(infiltrationNumbers) > 0:\n            modelEnergyBalance.append(infiltrationHeader + infiltrationNumbers)\n            modelEnergyBalanceNum.append(infiltrationNumbers)\n        if len(outdoorAirNumbers) > 0:\n            modelEnergyBalance.append(outdoorAirHeader + outdoorAirNumbers)\n            modelEnergyBalanceNum.append(outdoorAirNumbers)\n        if len(natVentNumbers) > 0:\n            modelEnergyBalance.append(natVentHeader + natVentNumbers)\n            modelEnergyBalanceNum.append(natVentNumbers)\n        if len(opaqueEnergyFlow) > 0:\n            modelEnergyBalance.append(opaqueHeader + opaqueEnergyFlow)\n            modelEnergyBalanceNum.append(opaqueEnergyFlow)\n        if len(glazingEnergyFlow) > 0:\n            modelEnergyBalance.append(glazingHeader + glazingEnergyFlow)\n            modelEnergyBalanceNum.append(glazingEnergyFlow)\n        if len(coolingNumbers) > 0:\n            modelEnergyBalance.append(coolingHeader + coolingNumbers)\n            modelEnergyBalanceNum.append(coolingNumbers)\n        \n        #Create an energy balance list with a storage term.\n        energyBalWithStorage = modelEnergyBalance[:]\n        storageHeaderInit = modelEnergyBalance[0][:7]\n        storageHeader = storageHeaderInit[:2] + ['Storage'] + storageHeaderInit[3:7]\n        storageNumbers = sumAllLists(modelEnergyBalanceNum)\n        for count, val in enumerate(storageNumbers):\n            storageNumbers[count] = -val\n        energyBalWithStorage.append(storageHeader + storageNumbers)\n        \n        #Create an energy balance normalized by floor area.\n        flrNormEBal = []\n        for dataList in modelEnergyBalance: flrNormEBal.append(dataList[:])\n        for listcount, eBalList in enumerate(flrNormEBal):\n            for valCount, val in enumerate(eBalList):\n                try: flrNormEBal[listcount][valCount] = val/totalFlrArea\n                except:\n                    if 'kWh' in val: flrNormEBal[listcount][valCount] = 'kWh/m2'\n        \n        flrNormEBalWStorage = flrNormEBal[:]\n        flrNormStorage = energyBalWithStorage[-1][:]\n        for valCount, val in enumerate(flrNormStorage):\n            try: flrNormStorage[valCount] = val/totalFlrArea\n            except:\n                if 'kWh' in val: flrNormStorage[valCount] = 'kWh/m2'\n        flrNormEBalWStorage.append(flrNormStorage)\n        \n        \n        return modelEnergyBalance, energyBalWithStorage, flrNormEBal, flrNormEBalWStorage\n    else: return -1\n\n\n#Honeybee check.\ninitCheck = True\nif not sc.sticky.has_key('honeybee_release') == True:\n    initCheck = False\n    print \"You should first let Honeybee fly...\"\n    ghenv.Component.AddRuntimeMessage(w, \"You should first let Honeybee fly...\")\nelse:\n    try:\n        if not sc.sticky['honeybee_release'].isCompatible(ghenv.Component): initCheck = False\n        if sc.sticky['honeybee_release'].isInputMissing(ghenv.Component): initCheck = False\n    except:\n        initCheck = False\n        warning = \"You need a newer version of Honeybee to use this compoent.\" + \\\n        \"Use updateHoneybee component to update userObjects.\\n\" + \\\n        \"If you have already updated userObjects drag Honeybee_Honeybee component \" + \\\n        \"into canvas and try again.\"\n        ghenv.Component.AddRuntimeMessage(w, warning)\n\n\n\nif initCheck == True and _HBZones != []:\n    if heating_.BranchCount > 0 or totalSolarGain_.BranchCount > 0 or  electricLight_.BranchCount > 0 or  electricEquip_.BranchCount > 0 or  peopleGains_.BranchCount > 0 or  surfaceEnergyFlow_.BranchCount > 0 or infiltrationEnergy_.BranchCount > 0 or mechVentilationEnergy_.BranchCount > 0 or natVentEnergy_.BranchCount > 0 or cooling_.BranchCount > 0 or fanElectric_.BranchCount > 0:\n        result = main(_HBZones, heating_, totalSolarGain_, electricLight_, electricEquip_, fanElectric_, peopleGains_, surfaceEnergyFlow_, infiltrationEnergy_, mechVentilationEnergy_, natVentEnergy_, cooling_)\n        \n        if result != -1:\n            modelEnergyBalanceInit, energyBalWithStorageInit, flrNormEBalInit, flrNormEBalWStorageInit = result\n            \n            modelEnergyBalance = DataTree[Object]()\n            energyBalWithStorage = DataTree[Object]()\n            flrNormEnergyBal = DataTree[Object]()\n            flrNormBalWStorage = DataTree[Object]()\n            \n            for dataCount, dataList in enumerate(modelEnergyBalanceInit):\n                for item in dataList: modelEnergyBalance.Add(item, GH_Path(dataCount))\n            for dataCount, dataList in enumerate(energyBalWithStorageInit):\n                for item in dataList: energyBalWithStorage.Add(item, GH_Path(dataCount))\n            for dataCount, dataList in enumerate(flrNormEBalInit):\n                for item in dataList: flrNormEnergyBal.Add(item, GH_Path(dataCount))\n            for dataCount, dataList in enumerate(flrNormEBalWStorageInit):\n                for item in dataList: flrNormBalWStorage.Add(item, GH_Path(dataCount))",
  "language": "python",
  "imports": [
    "scriptcontext"
  ],
  "has_docstring": true
}