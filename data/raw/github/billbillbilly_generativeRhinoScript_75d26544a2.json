{
  "source_url": "https://github.com/billbillbilly/generativeRhinoScript/blob/c0612d88918cd655a60d23af27a1ae1cfc05db94/6_recompose/recompose.py",
  "repo": "billbillbilly/generativeRhinoScript",
  "repo_stars": 1,
  "repo_description": "A collection of RhinoScript of design computation",
  "license": "GPL-3.0",
  "filepath": "6_recompose/recompose.py",
  "instruction": "This script transforms randomly generated surfaces from a given surface to pipes tower. First, an input surface is used to generate surfaces based on uv point matrix. These surfaces are ramdomly trimmed to create new scaled surfaces. Then, slope, area, centroid, vertexes, and GUID are save in different lists. Slopes in list are sorted from smallest to largest. finally, the surface is recognized and relocated one by one based on slope. The surface is transformed to circle based on four vertexes. The circle is also scale by factor calculated by slope and area. Each circle is used to create a pipe whose diameter is based on slope again.",
  "code": "# This script transforms randomly generated surfaces from a given surface to pipes tower.\n# First, an input surface is used to generate surfaces based on uv point matrix.\n# These surfaces are ramdomly trimmed to create new scaled surfaces.\n# Then, slope, area, centroid, vertexes, and GUID are save in different lists.\n# Slopes in list are sorted from smallest to largest.\n# finally, the surface is recognized and relocated one by one based on slope.\n# The surface is transformed to circle based on four vertexes.\n# The circle is also scale by factor calculated by slope and area.\n# Each circle is used to create a pipe whose diameter is based on slope again.\n\nimport rhinoscriptsyntax as rs\nimport math\nimport random\n\nclass surfaceStructure(object):\n    def __init__(self, surface = None):\n        self.surface = surface\n        self.pointMatrix = {}\n    # setup domain and step\n    def surfaceParameter(self, u_number, v_number):\n        self.u_number = u_number\n        self.v_number = v_number\n        self.u_domain = rs.SurfaceDomain(self.surface, 0)\n        self.v_domain = rs.SurfaceDomain(self.surface, 1)\n        self.u_step = (self.u_domain[1]-self.u_domain[0])/u_number\n        self.v_step = (self.v_domain[1]-self.v_domain[0])/v_number\n        return self\n    # get point matrix from surface\n    def setupPointVector(self):\n        for i in range(self.u_number+1):\n            for j in range(self.v_number+1):\n                u = self.u_domain[0] + i*self.u_step\n                v = self.v_domain[0] + j*self.v_step\n                self.pointMatrix[(i,j)] = rs.EvaluateSurface(self.surface, u, v)\n                vec = rs.VectorUnitize(rs.SurfaceNormal(self.surface, (u, v)))\n        return self\n    # setup a series of surfaces based on point matrix\n    def setupSurface(self):\n        self.surfaces = []\n        for i in range(self.u_number+1):\n            for j in range(self.v_number+1):\n                if i > 0 and j > 0:\n                    self.surfaces += [rs.AddSrfPt((self.pointMatrix[(i,j)], self.pointMatrix[(i,j-1)],\n                                                   self.pointMatrix[(i-1,j-1)], self.pointMatrix[(i-1,j)]))]\n        return self\n    # process surface structure\n    class SrfData:\n        def __init__(self, surfaceID):\n            # the information of a series of geometries\n            self.surfaceID = surfaceID\n            self.domain_u = list(rs.SurfaceDomain(surfaceID, 0))\n            self.domain_v = list(rs.SurfaceDomain(surfaceID, 1))\n        # randomly scaled surface based on domain\n        def randomScale(self):\n            scale_0 = random.uniform(0.55, 0.95)\n            scale_1 = random.uniform(0.55, 0.95)\n            self.domain_u[0] = (self.domain_u[1] - self.domain_u[0]) * scale_0\n            self.domain_u[1] = (self.domain_u[1] - self.domain_u[0]) * scale_1\n            self.domain_v[0] = (self.domain_v[1] - self.domain_v[0]) * scale_0\n            self.domain_v[1] = (self.domain_v[1] - self.domain_v[0]) * scale_1\n            self.surface = rs.TrimSurface(self.surfaceID, 2, (self.domain_u, self.domain_v))\n            self.centroid = rs.SurfaceAreaCentroid(self.surface)[0]\n            self.area = rs.Area(self.surface)\n            rs.HideObject(self.surfaceID)\n            return self\n\n        def getSlope(self):\n            edges = rs.DuplicateEdgeCurves(self.surface)\n            self.vertex = [] # save four vertexes of surface\n            # get four vertexes of surface\n            for each in edges:\n                self.vertex += [rs.CurveEndPoint(each)]\n            # list heights of four vertexes\n            heights = [self.vertex[0][2], self.vertex[1][2], self.vertex[2][2], self.vertex[3][2]]\n            # calculate the largest slope\n            self.slope = max(heights) - min(heights)\n            rs.DeleteObjects(edges)\n            return self\n\n        # reorgnize geometry based on area\n        def reorgnize(self, slopes):\n            for i in range(len(slopes)):\n                # recognize surace by slope\n                if self.slope == slopes[i]:\n                    translation = ((0 - self.centroid[0]),\n                                   (0 - self.centroid[1]),\n                                   (i*20 - self.centroid[2]))\n                    # move surface and its vertexes\n                    rs.MoveObject(self.surface, translation)\n                    rs.MoveObjects(self.vertex, translation)\n                    # create circle based on vertexes\n                    self.circle = rs.AddCurve(self.vertex+[self.vertex[0]])\n                    # scale circle based on area\n                    factor = math.sqrt(self.area)/(self.slope+1)**2 + 1\n                    centroid = rs.SurfaceAreaCentroid(self.surface)[0]\n                    rs.ScaleObject(self.circle, centroid, (factor,factor,factor))\n                    # create pipe based on circle and\n                    rs.AddPipe(self.circle, 0, 1.5*math.sqrt(self.slope))\n                    rs.HideObject(self.surface)\n            return self\n\ndef main():\n    # select a surface in rhino space\n    srfGUID = rs.GetObject(message=\"select a surface\")\n    # input the number of point on uv direction\n    u_number = rs.GetInteger(message=\"set the number of point on u direction\",\n                             number=5)\n    v_number = rs.GetInteger(message=\"set the number of point on v direction\",\n                             number=5)\n    # setup initial surface\n    srfs = surfaceStructure(srfGUID).surfaceParameter(u_number, v_number).setupPointVector().setupSurface().surfaces\n    srf_member = [] # save each surface from initial surface\n    slope_member = []\n    # save surface geberated from point matrix on initial surface\n    for i in range(len(srfs)):\n        srf_member += [surfaceStructure().SrfData(srfs[i]).randomScale().getSlope()]\n        slope_member += [srf_member[i].slope]\n    # delete initial surface\n    rs.DeleteObject(srfGUID)\n    # sort slope from smallest to largest\n    slope_member.sort()\n    #slope_member.reverse()\n    # reorgnize members\n    for each in srf_member:\n        each.reorgnize(slope_member)\n\nmain()\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}