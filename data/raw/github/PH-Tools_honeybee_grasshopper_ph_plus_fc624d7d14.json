{
  "source_url": "https://github.com/PH-Tools/honeybee_grasshopper_ph_plus/blob/b89f9887488d9c10eb732ffafe910cec70be0752/honeybee_ph_plus_rhino/gh_compo_io/reporting/build_elev_surfaces.py",
  "repo": "PH-Tools/honeybee_grasshopper_ph_plus",
  "repo_stars": 2,
  "repo_description": "Additional Honeybe-PH Grasshopper Components",
  "license": "GPL-3.0",
  "filepath": "honeybee_ph_plus_rhino/gh_compo_io/reporting/build_elev_surfaces.py",
  "instruction": "Create the 'Elevation' Geometry for Export to PDF.",
  "code": "# -*- coding: utf-8 -*-\n# -*- Python Version: 2.7 -*-\n\n\"\"\"Create the 'Elevation' Geometry for Export to PDF. \"\"\"\n\nimport math\nfrom collections import defaultdict\n\ntry:\n    from typing import Any, Dict, Iterable, List, Set, Tuple\nexcept ImportError:\n    pass  # IronPython 2.7\n\ntry:\n    from itertools import izip  # type: ignore\nexcept ImportError:\n    import zip as izip  # type: ignore // Python 3\n\ntry:\n    from System import Object  # type: ignore\n    from System.Drawing import Color  # type: ignore\nexcept ImportError:\n    pass  # Outside .NET\n\ntry:\n    from Grasshopper import DataTree  # type: ignore\n    from Grasshopper.Kernel.Data import GH_Path  # type: ignore\nexcept ImportError:\n    pass  # Outside Grasshopper\n\ntry:\n    from Rhino.DocObjects import ObjectAttributes  # type: ignore\n    from Rhino.Geometry import Brep, Curve, Mesh, Plane, TextJustification  # type: ignore\nexcept ImportError:\n    pass  # Outside Rhino\n\ntry:\n    from ladybug_geometry.geometry3d import plane\n    from ladybug_rhino.fromgeometry import from_face3d, from_plane, from_point3d\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import ladybug_rhino:\\n\\t{}\".format(e))\n\ntry:\n    from honeybee import boundarycondition, face, model\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee:\\n\\t{}\".format(e))\n\ntry:\n    from ph_gh_component_io import gh_io\nexcept ImportError:\n    raise ImportError(\"Failed to import honeybee_ph_rhino\")\n\n\nclass GHCompo_CreateElevationPDFGeometry(object):\n    def __init__(\n        self,\n        _IGH,\n        hb_model,\n        surface_color,\n        line_color,\n        line_weight,\n        branch_count,\n        *args,\n        **kwargs\n    ):\n        # type: (gh_io.IGH, model.Model, Color, Color, float, int, List[Any], Dict[Any, Any]) -> None\n        self.IGH = _IGH\n        self.hb_model = hb_model\n        self.surface_color = surface_color or Color.FromArgb(255, 255, 255)  # type: ignore\n        self.line_color = line_color or Color.FromArgb(0, 0, 0)  # type: ignore\n        self.line_weight = line_weight or 0.25\n        self.branch_count = branch_count or 1\n        self.error = []\n\n    def find_all_room_ids(self):\n        # type: () -> Set[str]\n        \"\"\"Return a set of all the Room identifiers in the model.\"\"\"\n        return {room.identifier for room in self.hb_model.rooms}\n\n    def get_exterior_hb_faces_by_const_type(self):\n        # type: () -> Dict[str, List[face.Face]]\n        \"\"\"Return a Dict of all the 'Exterior' Honeybee Faces, keyed by construction-type and surface normal direction.\"\"\"\n\n        def _clean_val(val, tolerance=0000.1):\n            # type: (float, float) -> float\n            \"\"\"Handle rounding the the -0 problem.\"\"\"\n            val = round(val, 4)\n            if val - 0.0 < tolerance:\n                return 0.0\n            else:\n                return val\n\n        def _interior_surface(hb_face):\n            # type: (face.Face) -> bool\n            \"\"\"Return True if the face is an 'Interior' Surface exposure.\"\"\"\n            if isinstance(hb_face.boundary_condition, boundarycondition.Surface):\n                adjacent_room_name = (\n                    hb_face.boundary_condition.boundary_condition_objects[-1]\n                )\n                if adjacent_room_name in all_room_ids:\n                    return True\n            return False\n\n        all_room_ids = self.find_all_room_ids()\n        hb_faces_by_const_type = defaultdict(list)\n\n        for room in self.hb_model.rooms:\n            for hb_face in room.faces:\n                # -- Filter out any 'Interior' Surface exposure faces.\n                # -- If the face is a 'Surface' exposure, BUT the other side is NOT in the model, keep the face.\n                if _interior_surface(hb_face):\n                    continue\n\n                key = \"{}-{:.4f}-{:.4f}-{:.4f}\".format(\n                    hb_face.properties.energy.construction.display_name,\n                    _clean_val(hb_face.geometry.normal.x),\n                    _clean_val(hb_face.geometry.normal.y),\n                    _clean_val(hb_face.geometry.normal.z),\n                )\n                hb_faces_by_const_type[key].append(hb_face)\n\n        return hb_faces_by_const_type\n\n    def get_punched_breps(self, _hb_face):\n        # type: (List[face.Face]) -> List[Brep]\n        \"\"\"Return a list of the 'Punched' Breps for a group of HB-Faces.\"\"\"\n        breps_ = []\n        for hb_face in _hb_face:\n            if not hb_face.apertures:\n                breps_.append(from_face3d(hb_face.geometry))\n            else:\n                breps_.append(from_face3d(hb_face.punched_geometry))\n        return breps_\n\n    def get_centered_aperture_plane(self, _aperture):\n        # type (aperture.Aperture) -> plane.Plane\n        \"\"\"Return the 'Aperture' Plane centered on the Aperture's center point.\"\"\"\n        ap_cp = from_point3d(_aperture.geometry.center)\n        ap_plane = from_plane(_aperture.geometry.plane)\n        move_vec = self.IGH.ghpythonlib_components.Vector2Pt(\n            ap_plane.Origin, ap_cp, False\n        ).vector\n        centered_plane = self.IGH.ghpythonlib_components.Move(ap_plane, move_vec).geometry\n\n        # -- Ensure that the plane's Y-Axis is always pointing up.\n        if centered_plane.YAxis.Z < 0:\n            centered_plane.Rotate(math.pi, centered_plane.Normal)\n\n        return centered_plane\n\n    def get_aperture_breps(self, _hb_faces):\n        # type: (Iterable[face.Face]) -> Tuple[List[Brep], List[str], List[plane.Plane]]\n        \"\"\"Return a list of all the 'Aperture' Breps (and names / planes) for a group of HB-Faces.\"\"\"\n        return (\n            [\n                from_face3d(ap.geometry)\n                for hb_face in _hb_faces\n                for ap in hb_face.apertures\n            ],\n            [ap.display_name for hb_face in _hb_faces for ap in hb_face.apertures],\n            [\n                self.get_centered_aperture_plane(ap)\n                for hb_face in _hb_faces\n                for ap in hb_face.apertures\n            ],\n        )\n\n    def breps_to_meshes(self, _breps):\n        # type: (Iterable[Brep]) -> List[Mesh]\n        \"\"\"Convert a group of Brep-Surface into to list of Meshes.\"\"\"\n        meshes_ = []\n        for brep in _breps:\n            meshes_.append(\n                self.IGH.ghpythonlib_components.MeshColours(brep, self.surface_color)\n            )\n        return meshes_\n\n    def get_mesh_naked_edges(self, _mesh):\n        # type: (Mesh) -> List[Curve]\n        \"\"\"Extract the naked edges of a Mesh and return them as Curves.\"\"\"\n\n        surface_edges = self.IGH.ghc.MeshEdges(_mesh).naked_edges\n        surface_edges = self.IGH.ghc.JoinCurves(surface_edges, True)\n\n        if not isinstance(surface_edges, list):\n            surface_edges = [surface_edges]\n\n        return surface_edges\n\n    def merge_rh_breps(self, _rh_breps):\n        # type: (Iterable[Brep]) -> List[Brep]\n        \"\"\"Try to join and merge a group of Rhino Breps together.\"\"\"\n\n        joined_breps = self.IGH.ghpythonlib_components.BrepJoin(_rh_breps).breps\n        if not isinstance(joined_breps, list):\n            joined_breps = [joined_breps]\n\n        merged_breps = self.IGH.ghpythonlib_components.MergeFaces(joined_breps).breps\n        if not isinstance(merged_breps, list):\n            merged_breps = [merged_breps]\n\n        for brep in merged_breps:\n            brep.Edges.MergeAllEdges((math.pi) / 2)\n\n        return merged_breps\n\n    def create_rh_attr_object(self, _color, _line_weight):\n        # type: (Color, float) -> ObjectAttributes\n        \"\"\"Return a Rhino Object Attributes object.\"\"\"\n\n        new_attr_obj = self.IGH.Rhino.DocObjects.ObjectAttributes()\n\n        new_attr_obj.ObjectColor = _color\n        new_attr_obj.PlotColor = _color\n        new_attr_obj.ColorSource = (\n            self.IGH.Rhino.DocObjects.ObjectColorSource.ColorFromObject\n        )\n        new_attr_obj.PlotColorSource = (\n            self.IGH.Rhino.DocObjects.ObjectPlotColorSource.PlotColorFromObject\n        )\n        new_attr_obj.PlotWeight = _line_weight\n        new_attr_obj.PlotWeightSource = (\n            self.IGH.Rhino.DocObjects.ObjectPlotWeightSource.PlotWeightFromObject\n        )\n        new_attr_obj.DisplayOrder = 0\n\n        return new_attr_obj\n\n    def run(self):\n        # type: () -> Tuple\n        all_geom, all_geom_attributes, all_aperture_names, all_aperture_planes = (\n            [],\n            [],\n            [],\n            [],\n        )\n\n        if not self.hb_model:\n            return (\n                self.error,\n                all_geom,\n                all_geom_attributes,\n                all_aperture_names,\n                all_aperture_planes,\n            )\n\n        ext_hb_faces = self.get_exterior_hb_faces_by_const_type()\n\n        # -- Get all the Surface and Aperture Meshes, Edges, and Rhino-Attributes\n        for face_group in ext_hb_faces.values():\n            surface_punched_breps = self.merge_rh_breps(\n                self.get_punched_breps(face_group)\n            )\n            (\n                surface_aperture_breps,\n                surface_aperture_names,\n                surface_aperture_planes,\n            ) = self.get_aperture_breps(face_group)\n\n            # -- Base surfaces (wall, floor, roof, etc.)\n            for surface_msh in self.breps_to_meshes(surface_punched_breps):\n                all_geom.append(surface_msh)\n                all_geom_attributes.append(\n                    self.create_rh_attr_object(self.surface_color, self.line_weight)\n                )\n\n                for edge in self.get_mesh_naked_edges(surface_msh):\n                    all_geom.append(edge)\n                    all_geom_attributes.append(\n                        self.create_rh_attr_object(self.line_color, self.line_weight)\n                    )\n\n            # -- Apertures (windows, doors, etc.)\n            all_aperture_names.extend(surface_aperture_names)\n            all_aperture_planes.extend(surface_aperture_planes)\n            for ap_msh in self.breps_to_meshes(surface_aperture_breps):\n                all_geom.append(ap_msh)\n                all_geom_attributes.append(\n                    self.create_rh_attr_object(self.surface_color, self.line_weight)\n                )\n\n                for edge in self.get_mesh_naked_edges(ap_msh):\n                    all_geom.append(edge)\n                    all_geom_attributes.append(\n                        self.create_rh_attr_object(self.line_color, self.line_weight)\n                    )\n\n        # -- Package up the data into DataTrees for Export\n        # -- This is required to ensure the geom branches match the layout-views being printed.\n        geom_ = self.IGH.duplicate_data_to_branches(all_geom, self.branch_count)\n        geom_attributes_ = self.IGH.duplicate_data_to_branches(\n            all_geom_attributes, self.branch_count\n        )\n        aperture_names_ = self.IGH.duplicate_data_to_branches(\n            all_aperture_names, self.branch_count\n        )\n        aperture_planes_ = self.IGH.duplicate_data_to_branches(\n            all_aperture_planes, self.branch_count\n        )\n\n        return self.error, geom_, geom_attributes_, aperture_names_, aperture_planes_\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}