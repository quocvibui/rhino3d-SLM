{
  "source_url": "https://github.com/ar0551/Wasp/blob/66f63c018f2420d37aa451ade0178de260946b0c/src/wasp/core/aggregation.py",
  "repo": "ar0551/Wasp",
  "repo_stars": 67,
  "repo_description": "Combinatorial Design with Grasshopper plug-in (LGPL) initiated by Andrea Rossi",
  "license": "LGPL-3.0",
  "filepath": "src/wasp/core/aggregation.py",
  "instruction": "(C) 2017-2020 Andrea Rossi <ghwasp@gmail.com>",
  "code": "\"\"\"\n(C) 2017-2020 Andrea Rossi <ghwasp@gmail.com>\n\nThis file is part of Wasp. https://github.com/ar0551/Wasp\n@license GPL-3.0 <https://www.gnu.org/licenses/gpl.html>\n\n@version 0.6.001\n\nAggregation class and functions\n\"\"\"\n\nimport random\nimport bisect\nimport time\n\nfrom Rhino.Geometry import Transform\nfrom Rhino.Geometry import Point3d, Vector3d, Plane\n\nfrom wasp import global_tolerance\n\nfrom wasp.core.parts import Part, AdvancedPart, PartCatalog\nfrom wasp.core.rules import Rule\nfrom wasp.core.graph import Graph\nfrom wasp.core.constraints import Plane_Constraint, Mesh_Constraint\n\nfrom wasp.field import Field\n\n\n#################################################################### Aggregation ####################################################################\nclass Aggregation(object):\n\t\n\n\t## class constructor\n\tdef __init__(self, _name, _parts, _rules, _mode, _prev = [], _coll_check = True, _field = [], _global_constraints = [], _rnd_seed = None, _catalog = None):\n\t\t\n\t\t## basic parameters\n\t\tself.name = _name\n\t\t\n\t\tself.parts = {}\n\t\tfor part in _parts:\n\t\t\tself.parts[part.name] = part\n\t\t\n\t\tself.rules = _rules\n\t\t\n\t\tself.mode = _mode\n\t\tself.coll_check = _coll_check\n\t\t\n\t\tself.aggregated_parts = []\n\t\tself.graph = Graph()\n\t\t\n\t\t## fields\n\t\tself.multiple_fields = False\n\t\tif len(_field) == 0:\n\t\t\tself.field = None\n\t\telif len(_field) == 1:\n\t\t\tself.field = _field[0]\n\t\telse:\n\t\t\tself.field = {}\n\t\t\tfor f in _field:\n\t\t\t\tself.field[f.name] = f\n\t\t\tself.multiple_fields = True\n\t\t\n\t\t## reset base parts\n\t\tself.reset_base_parts()\n\t\t\n\t\t## temp list to store possible colliders to newly added parts\n\t\tself.possible_collisions = []\n\t\t\n\t\t## aggregation queue, storing sorted possible next states in the form (part, f_val)\n\t\tself.aggregation_queue = []\n\t\tself.queue_values = []\n\t\tself.queue_count = 0\n\t\t\n\t\t## previous aggregated parts\n\t\tself.prev_num = 0\n\t\tif len(_prev) > 0:\n\t\t\tself.prev_num = len(_prev)\n\t\t\tfor prev_p in _prev:\n\t\t\t\tprev_p_copy = prev_p.copy(maintain_parenting=True)\n\t\t\t\tprev_p_copy.reset_part(self.rules)\n\t\t\t\tif prev_p_copy.id is None:\n\t\t\t\t\tprev_p_copy.id = len(self.aggregated_parts)\n\t\t\t\tself.aggregated_parts.append(prev_p_copy)\n\n\t\t\t\t## add node to graph\n\t\t\t\tself.graph.add_node(prev_p_copy.id)\n\t\t\t\tif prev_p_copy.parent is not None:\n\t\t\t\t\tself.graph.add_edge(prev_p_copy.parent, prev_p_copy.id, prev_p_copy.conn_on_parent, prev_p_copy.conn_to_parent)\n\n\t\t\t\tif self.field is not None:\n\t\t\t\t\tself.compute_next_w_field(prev_p_copy)\n\t\t\n\t\t## global constraints applied to the aggregation\n\t\tself.global_constraints = _global_constraints\n\t\t\n\t\t## random seed\n\t\tself.rnd_seed = None\n\t\tif _rnd_seed is None:\n\t\t\tself.rnd_seed = int(time.time())\t\n\t\telse:\n\t\t\tself.rnd_seed = _rnd_seed\n\t\trandom.seed(self.rnd_seed)\n\t\t\n\t\t## parts catalog\n\t\tself.catalog = _catalog\n\n\t\t#### WIP ####\n\t\tself.collision_shapes = []\n\t\t\n\t\n\t## override Rhino .ToString() method (display name of the class in Gh)\n\tdef ToString(self):\n\t\treturn \"WaspAggregation [name: %s, size: %s]\" % (self.name, len(self.aggregated_parts))\n\t\n\n\t## create class from data dictionary\n\t@classmethod\n\tdef from_data(cls, data):\n\t\td_name = data['name']\n\n\t\td_parts = []\n\t\tfor part_data in data['parts']:\n\t\t\tif part_data['class_type'] == 'Part':\n\t\t\t\td_parts.append(Part.from_data(part_data))\n\t\t\telif part_data['class_type'] == 'AdvancedPart':\n\t\t\t\td_parts.append(AdvancedPart.from_data(part_data))\n\t\t\telse:\n\t\t\t\tpass\n\t\t\n\t\td_rules = [Rule.from_data(rule_data) for rule_data in data['rules']]\n\t\td_mode = int(data['mode'])\n\t\td_coll_check = data['coll_check']\n\t\td_field = []\n\t\tif data['field'] is not None:\n\t\t\td_field = [Field.from_data(field_data) for field_data in data['field']]\n\t\t\n\t\td_global_constraints = []\n\t\tfor const_data in data['global_constraints']:\n\t\t\tif const_data['type'] == 'plane':\n\t\t\t\td_global_constraints.append(Plane_Constraint.from_data(const_data))\n\t\t\telif const_data['type'] == 'mesh_collider':\n\t\t\t\td_global_constraints.append(Mesh_Constraint.from_data(const_data))\n\n\t\td_rnd_seed = data['rnd_seed']\n\t\td_catalog = None\n\t\tif data['catalog'] is not None:\n\t\t\td_catalog = PartCatalog.from_data(data['catalog'])\n\t\t\n\t\taggregation = cls(d_name, d_parts, d_rules, d_mode, [], d_coll_check, _field = d_field, _global_constraints=d_global_constraints, _rnd_seed=d_rnd_seed, _catalog=d_catalog)\n\n\t\td_aggregated_parts = []\n\t\tfor p_id in data['aggregated_parts_sequence']:\n\t\t\taggr_part_data = data['aggregated_parts'][str(p_id)]\n\t\t\tif aggr_part_data['class_type'] == 'Part':\n\t\t\t\td_aggregated_parts.append(Part.from_data(aggr_part_data))\n\t\t\telif aggr_part_data['class_type'] == 'AdvancedPart':\n\t\t\t\td_aggregated_parts.append(AdvancedPart.from_data(aggr_part_data))\n\t\t\telse:\n\t\t\t\tpass\n\t\t\n\t\taggregation.aggregated_parts = d_aggregated_parts\n\n\t\taggregation.graph = Graph.from_data(data['graph'])\n\n\t\taggregation.reset_rules(aggregation.rules)\n\t\t## if using a field, recompute the whole aggregation queue\n\t\tif aggregation.field is not None:\n\t\t\taggregation.recompute_aggregation_queue()\n\n\t\treturn aggregation\n\n\n\t\t\n\t## return the data dictionary representing the aggregation\n\tdef to_data(self):\n\t\tdata = {}\n\t\tdata['name'] = self.name\n\t\tdata['parts'] = [part.to_data() for part in self.parts.values()]\n\t\tdata['rules'] = [rule.to_data() for rule in self.rules]\n\t\tdata['mode'] = self.mode\n\t\tdata['coll_check'] = self.coll_check\n\t\tdata['graph'] = self.graph.to_data()\n\n\t\tif self.field is None:\n\t\t\tdata['field'] = None\n\t\telif not self.multiple_fields:\n\t\t\tdata['field'] = [self.field.to_data()]\n\t\telse:\n\t\t\tdata['field'] = [f.to_data() for f in self.field.values()]\n\t\t\n\t\tdata['global_constraints'] = [const.to_data() for const in self.global_constraints]\n\n\t\tdata['rnd_seed'] = self.rnd_seed\n\t\tdata['catalog'] = None\n\t\tif self.catalog is not None:\n\t\t\tdata['catalog'] = self.catalog.to_data()\n\n\t\t#data['aggregated_parts'] = [part.to_data() for part in self.aggregated_parts]\n\t\tdata['aggregated_parts'] =\t{}\n\t\tdata['aggregated_parts_sequence'] = []\n\t\tfor part in self.aggregated_parts:\n\t\t\tdata['aggregated_parts'][part.id] = part.to_data()\n\t\t\tdata['aggregated_parts_sequence'].append(part.id)\n\n\t\treturn data\n\t\n\n\t## reset base parts\n\tdef reset_base_parts(self, new_parts = None):\n\t\tif new_parts != None:\n\t\t\tself.parts = {}\n\t\t\tfor part in new_parts:\n\t\t\t\tself.parts[part.name] = part\n\t\t\n\t\tfor p_key in self.parts:\n\t\t\tself.parts[p_key].reset_part(self.rules)\n\n\n\t## reset rules and regenerate rule tables for each part\n\tdef reset_rules(self, rules):\n\t\tself.rules = rules\n\t\tself.reset_base_parts()\n\t\t\n\t\tfor part in self.aggregated_parts:\n\t\t\tpart.reset_part(rules)\n\t\n\n\t## recompute aggregation queue\n\tdef recompute_aggregation_queue(self):\n\t\tself.aggregation_queue = []\n\t\tself.queue_values = []\n\t\tself.queue_count = 0\n\t\tfor part in self.aggregated_parts:\n\t\t\tself.compute_next_w_field(part)\n\t\n\n\t## trim aggregated parts list to a specific length\n\tdef remove_elements(self, num):\n\n\t\tself.removed_parts = self.aggregated_parts[num:]\n\t\tfor p in self.removed_parts:\n\t\t\t## remove item from graph\n\t\t\tself.graph.remove_node(p.id)\n\n\t\t\t## if using and limited, update the catalog by adding back the removed parts\n\t\t\tif self.catalog is not None:\n\t\t\t\tself.catalog.update(p.name, 1)\n\n\t\t## trim the list to the desired length\n\t\tself.aggregated_parts = self.aggregated_parts[:num]\n\n\t\t## reset the remaining parts (reactivate all connections, who might have been blocked by removed parts)\n\t\tfor part in self.aggregated_parts:\n\t\t\tpart.reset_part(self.rules)\n\t\t\n\t\t## if using a field, recompute the whole aggregation queue\n\t\tif self.field is not None:\n\t\t\tself.recompute_aggregation_queue()\n\t\n\n\t## compute all possible parts which can be placed given an existing part and connection\n\tdef compute_possible_children(self, part_id, conn_id, check_constraints = False):\n\t\t\n\t\tpossible_children = []\n\t\tcurrent_part = self.aggregated_parts[part_id]\n\t\t\n\t\tif conn_id in current_part.active_connections:\n\t\t\tcurrent_conn = current_part.connections[conn_id]\n\t\t\tfor rule_id in current_conn.active_rules:\n\t\t\t\trule = current_conn.rules_table[rule_id]\n\t\t\t\t\n\t\t\t\tnext_part = self.parts[rule.part2]\n\t\t\t\torientTransform = Transform.PlaneToPlane(next_part.connections[rule.conn2].flip_pln, current_conn.pln)\n\t\t\t\t\n\t\t\t\t## boolean checks for all constraints\n\t\t\t\tglobal_check = False\n\t\t\t\t\n\t\t\t\tif check_constraints:\n\t\t\t\t\tglobal_check, _, _, _, _, _, _, _ = self.check_all_constraints(next_part, orientTransform)\n\t\t\t\t\n\t\t\t\tif not global_check:\n\t\t\t\t\tnext_part_trans = next_part.transform(orientTransform)\n\t\t\t\t\tpossible_children.append(next_part_trans)\n\t\t\t\n\t\t\treturn possible_children\t\n\t\telse:\n\t\t\treturn -1\n\t\t\n\t\n\t## add a custom pre-computed part which has been already transformed in place and checked for constraints\n\tdef add_custom_part(self, part_id, conn_id, next_part):\n\t\tnext_part.reset_part(self.rules)\n\t\tnext_part.id = len(self.aggregated_parts)\n\t\t\n\t\tself.aggregated_parts[part_id].children.append(next_part)\n\t\tnext_part.parent = self.aggregated_parts[part_id]\n\t\tself.aggregated_parts.append(next_part)\n\t\t\n\t\tfor i in range(len(self.aggregated_parts[part_id].active_connections)):\n\t\t\tif self.aggregated_parts[part_id].active_connections[i] == conn_id:\n\t\t\t\tself.aggregated_parts[part_id].active_connections.pop(i)\n\t\t\t\tbreak\n\n\t\n\t#### constraints checks ####\n\t## function grouping all collsion and constraints checks\n\tdef check_all_constraints(self, part, trans):\n\t\t\n\t\t## boolean checks for all constraints\n\t\tcoll_check = False\n\t\tadd_coll_check = False\n\t\tmissing_sup_check = False\n\t\tadjacencies_check = False\n\t\texclusions_back_check = False\n\t\torientation_check = False\n\t\tglobal_const_check = False\n\n\t\t## variables to store already computed colliders\n\t\tpart_center_trans = None\n\t\tpart_collider_trans = None\n\n\t\t## check overlaps/collisions with previously placed parts\n\t\tcoll_check, part_center_trans, part_collider_trans = self.collision_check(part, trans)\n\n\t\tif coll_check == False:\n\t\t\t## check constraints\n\t\t\t## only local constraints mode\n\t\t\tif self.mode == 1:\n\t\t\t\tif part.is_constrained:\n\t\t\t\t\tadd_coll_check = self.additional_collider_check(part, trans)\n\t\t\t\t\t\n\t\t\t\t\tif not add_coll_check:\n\t\t\t\t\t\tmissing_sup_check = self.missing_supports_check(part, trans)\n\n\t\t\t\t\t\tif not missing_sup_check:\n\t\t\t\t\t\t\tadjacencies_check = self.adjacencies_check(part, trans)\n\n\t\t\t\t\t\t\tif not adjacencies_check:\n\t\t\t\t\t\t\t\texclusions_back_check = self.exclusions_back_check(part, trans)\n\n\t\t\t\t\t\t\t\tif not exclusions_back_check:\n\t\t\t\t\t\t\t\t\torientation_check = self.orientation_check(part, trans)\n\n\t\t\t\n\t\t\t## onyl global constraints mode\n\t\t\telif self.mode == 2:\n\t\t\t\tif len(self.global_constraints) > 0:\n\t\t\t\t\tglobal_const_check = self.global_constraints_check(part, trans, part_center_trans, part_collider_trans)\n\t\t\t\n\t\t\t## local+global constraints mode\n\t\t\telif self.mode == 3:\n\t\t\t\tif len(self.global_constraints) > 0:\n\t\t\t\t\tglobal_const_check = self.global_constraints_check(part, trans, part_center_trans, part_collider_trans)\n\t\t\t\t\n\t\t\t\tif not global_const_check and part.is_constrained:\n\t\t\t\t\tadd_coll_check = self.additional_collider_check(part, trans)\n\t\t\t\t\t\n\t\t\t\t\tif not add_coll_check:\n\t\t\t\t\t\tmissing_sup_check = self.missing_supports_check(part, trans)\n\t\t\t\t\t\t\n\t\t\t\t\t\tif not missing_sup_check:\n\t\t\t\t\t\t\tadjacencies_check = self.adjacencies_check(part, trans)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif not adjacencies_check:\n\t\t\t\t\t\t\t\texclusions_back_check = self.exclusions_back_check(part, trans)\n\n\t\t\t\t\t\t\t\tif not exclusions_back_check:\n\t\t\t\t\t\t\t\t\torientation_check = self.orientation_check(part, trans)\n\n\t\t## combine all constraints check result\n\t\tglobal_check = coll_check or add_coll_check or missing_sup_check or global_const_check or adjacencies_check or exclusions_back_check or orientation_check\n\n\t\treturn global_check, coll_check, add_coll_check, missing_sup_check, global_const_check, adjacencies_check, exclusions_back_check, orientation_check\n\n\t\n\t## overlap // part-part collision check\n\tdef collision_check(self, part, trans, part_center=None, part_collider=None):\n\n\t\tself.possible_collisions = []\n\t\tif part_center is None:\n\t\t\tpart_center = part.transform_center(trans)\n\t\t\n\t\t## overlap check\n\t\tcoll_count = 0\n\t\tfor ex_part in self.aggregated_parts:\n\t\t\tdist = ex_part.center.DistanceTo(part_center)\n\n\t\t\t## if part centers overlap, return\n\t\t\tif dist < global_tolerance:\n\t\t\t\treturn True, None, None\n\t\t\t\t\n\t\t\t## if not, check if the part is within collision range\n\t\t\telif dist < ex_part.dim + part.dim:\n\t\t\t\tself.possible_collisions.append(coll_count)\n\t\t\t\n\t\t\tcoll_count += 1\n\t\t\n\t\t## check collisions with parts in range\n\t\tif self.coll_check == True:\n\t\t\tif part_collider is None:\n\t\t\t\tpart_collider = part.transform_collider(trans)\n\t\t\tif part_collider.check_collisions_by_id(self.aggregated_parts, self.possible_collisions):\n\t\t\t\treturn True, None, None\n\t\t\n\t\treturn False, part_center, part_collider\n\t\n\t\n\t## additional collider check\n\tdef additional_collider_check(self, part, trans):\n\t\tif part.add_collider != None:\n\t\t\tadd_collider = part.add_collider.transform(trans, transform_connections=True, maintain_valid = False)\n\t\t\tif add_collider.check_collisions_w_parts(self.aggregated_parts):\n\t\t\t\treturn True\n\t\t\t## assign computed valid connections according to collider location\n\t\t\tpart.add_collider.valid_connections = list(add_collider.valid_connections)\n\t\treturn False\n\t\n\t\n\t## support check\n\tdef missing_supports_check(self, part, trans):\n\t\tif len(part.supports) > 0:\n\t\t\tfor sup in part.supports:\n\t\t\t\tsupports_count = 0\n\t\t\t\tsup_trans = sup.transform(trans)\n\t\t\t\tfor dir in sup_trans.sup_dir:\n\t\t\t\t\tfor id in self.possible_collisions:\n\t\t\t\t\t\tif self.aggregated_parts[id].collider.check_intersection_w_line(dir):\n\t\t\t\t\t\t\tsupports_count += 1\n\t\t\t\t\t\t\tbreak\n\t\t\t\tif supports_count == len(sup_trans.sup_dir):\n\t\t\t\t\treturn False\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\t\n\n\t## adjacencies/exclusions check\n\tdef adjacencies_check(self, part, trans):\n\t\tif len(part.adjacency_const) > 0:\n\t\t\tfor aec in part.adjacency_const:\n\t\t\t\taec_trans = aec.transform(trans)\n\t\t\t\tif not aec_trans.check(self.aggregated_parts, self.possible_collisions):\n\t\t\t\t\treturn True\n\t\t\treturn False\n\t\telse:\n\t\t\treturn False\n\t\n\n\t## back-checking exclusions on already placed parts\n\tdef exclusions_back_check(self, part, trans):\n\t\tpart_trans = None\n\t\tfor id in self.possible_collisions:\n\t\t\tif self.aggregated_parts[id].is_constrained:\n\t\t\t\tif len(self.aggregated_parts[id].adjacency_const) > 0:\n\t\t\t\t\tfor adj_const in self.aggregated_parts[id].adjacency_const:\n\t\t\t\t\t\tif not adj_const.is_adjacency:\n\t\t\t\t\t\t\tif part_trans is None:\n\t\t\t\t\t\t\t\tpart_trans = part.transform(trans)\n\t\t\t\t\t\t\tif not adj_const.check_single(part_trans):\n\t\t\t\t\t\t\t\treturn True\n\t\treturn False\n\n\n\t## orientation check\n\tdef orientation_check(self, part, trans):\n\t\tif len(part.orientation_const) > 0:\n\t\t\tfor oc in part.orientation_const:\n\t\t\t\toc_trans = oc.transform(trans)\n\t\t\t\tif not oc_trans.check():\n\t\t\t\t\treturn True\n\t\t\treturn False\n\t\telse:\n\t\t\treturn False\n\n\n\t## global constraints check\n\tdef global_constraints_check(self, part, trans, part_center=None, part_collider=None):\n\t\t\n\t\toptional_constraints = 0\n\t\tfor constraint in self.global_constraints:\n\t\t\tif not constraint.required:\n\t\t\t\toptional_constraints += 1\n\t\t\n\t\tvalid_optional_constraints = optional_constraints\n\t\tfor constraint in self.global_constraints:\n\t\t\tif part_center is None:\n\t\t\t\tpart_center = part.transform_center(trans)\n\t\t\tif constraint.soft:\n\t\t\t\tif constraint.check(pt = part_center, p_name=part.name) == False:\n\t\t\t\t\tif constraint.required:\n\t\t\t\t\t\treturn True\n\t\t\t\t\telse:\n\t\t\t\t\t\tvalid_optional_constraints -= 1\n\t\t\telse:\n\t\t\t\tif part_collider is None:\n\t\t\t\t\tpart_collider = part.transform_collider(trans)\n\t\t\t\tif constraint.check(pt = part_center, collider = part_collider, p_name=part.name) == False:\n\t\t\t\t\tif constraint.required:\n\t\t\t\t\t\treturn True\n\t\t\t\t\telse:\n\t\t\t\t\t\tvalid_optional_constraints -= 1\n\t\t\n\t\tif optional_constraints > 0 and valid_optional_constraints == 0:\n\t\t\treturn True\n\t\t\n\t\treturn False\n\t\n\t\n\t## check all connections for validity against the give constraints\n\tdef check_all_connections(self):\n\t\tfor part in self.aggregated_parts:\n\t\t\tif len(part.active_connections) > 0:\n\t\t\t\tfor conn_id in part.active_connections:\n\t\t\t\t\tconn = part.connections[conn_id]\n\t\t\t\t\tif len(conn.active_rules) > 0:\n\t\t\t\t\t\tfor rule_id in conn.active_rules:\n\t\t\t\t\t\t\tnext_rule = conn.rules_table[rule_id]\n\n\t\t\t\t\t\t\tnext_part = self.parts[next_rule.part2]\n\t\t\t\t\t\t\torientTransform = Transform.PlaneToPlane(next_part.connections[next_rule.conn2].flip_pln, conn.pln)\n\t\t\t\t\t\t\tcoll_check, _, _ = self.collision_check(next_part, orientTransform)\n\t\t\t\t\t\t\tif coll_check:\n\t\t\t\t\t\t\t\tconn.active_rules.remove(rule_id)\n\t\t\t\t\t\t\t\tif len(conn.active_rules) == 0: \n\t\t\t\t\t\t\t\t\tpart.active_connections.remove(conn_id)\n\t\n\n\t## check all connections of a given part for occlusion from other parts\n\tdef check_blocked_connections(self, part, connections_only=False, custom_graph=None):\n\t\tconnection_matrix = []\n\n\t\tif custom_graph is None:\n\t\t\tfor i in range(len(part.connections)):\n\t\t\t\tconnection_matrix.append(i)\n\n\t\t\tfor i in range(len(part.connections)):\n\t\t\t\tconn = part.connections[i]\n\t\t\t\tfor other_part in self.aggregated_parts:\n\t\t\t\t\tif other_part.id != part.id:\n\t\t\t\t\t\tif connections_only:\n\t\t\t\t\t\t\tfor other_conn in other_part.connections:\n\t\t\t\t\t\t\t\tif conn.pln.Origin.DistanceTo(other_conn.pln.Origin) < global_tolerance:\n\t\t\t\t\t\t\t\t\tconnection_matrix.remove(i)\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tconn_cp = other_part.geo.ClosestPoint(conn.pln.Origin)\n\t\t\t\t\t\t\tif conn.pln.Origin.DistanceTo(conn_cp) < global_tolerance:\n\t\t\t\t\t\t\t\tconnection_matrix.remove(i)\n\t\t\t\t\t\t\t\tbreak\n\t\t\n\t\telse:\n\t\t\tfor i in range(len(part.connections)):\n\t\t\t\tconnection_matrix.append(i)\n\t\t\t\n\t\t\tif part.id in custom_graph.graph_dict.keys():\n\t\t\t\tif len(custom_graph.graph_dict[part.id]) > 0:\n\t\t\t\t\tfor connected_part in custom_graph.graph_dict[part.id].keys():\n\t\t\t\t\t\tconnection_matrix.remove(custom_graph.graph_dict[part.id][connected_part][\"conn_start\"])\n\n\t\treturn connection_matrix\n\n\n\t#### aggregation methods ####\n\t## sequential aggregation with Graph Grammar\n\tdef aggregate_sequence(self, graph_rules):\n\t\t\n\t\tfor rule in graph_rules:\t\n\t\t\t## first part\n\t\t\tif len(self.aggregated_parts) == 0:\n\t\t\t\taggr_rule = rule.split(\">\")[0]\n\t\t\t\trule_parts = aggr_rule.split(\"_\")\n\t\t\t\tpart1 = str(rule_parts[0].split(\"|\")[0])\n\t\t\t\tconn1 = int(rule_parts[0].split(\"|\")[1])\n\t\t\t\tpart2 = str(rule_parts[1].split(\"|\")[0])\n\t\t\t\tconn2 = int(rule_parts[1].split(\"|\")[1])\n\t\t\t\t\n\t\t\t\trule_ids = rule.split(\">\")[1].split(\"_\")\n\t\t\t\t## TO FIX >>> conflict between text and int ids\n\t\t\t\ttry:\n\t\t\t\t\tfor i in range(2):\n\t\t\t\t\t\trule_ids[i] = int(rule_ids[i])\n\t\t\t\texcept:\n\t\t\t\t\tpass\n\t\t\t\t\n\t\t\t\tfirst_part = self.parts[part1]\n\t\t\t\tfirst_part_trans = first_part.transform(Transform.Identity)\n\t\t\t\tfirst_part_trans.id = rule_ids[0]\n\t\t\t\t\n\t\t\t\tnext_part = self.parts[part2]\n\t\t\t\t\n\t\t\t\torientTransform = Transform.PlaneToPlane(next_part.connections[conn2].flip_pln, first_part.connections[conn1].pln)\n\t\t\t\t\n\t\t\t\tnext_part_trans = next_part.transform(orientTransform)\n\n\t\t\t\tnext_part_trans.id = rule_ids[1]\n\t\t\t\t\n\t\t\t\t## check additional collider (for fabrication constraints)\n\t\t\t\t## self.additional_collider_check(next_part, orientTransform)\n\t\t\t\t\n\t\t\t\t## parent-child tracking\n\t\t\t\tfirst_part_trans.children.append(next_part_trans)\n\t\t\t\tnext_part_trans.parent = first_part_trans\n\t\t\t\t\n\t\t\t\tself.aggregated_parts.append(first_part_trans)\n\t\t\t\tself.aggregated_parts.append(next_part_trans)\n\t\t\t\t\n\t\t\t\tfirst_part_trans.children.append(next_part_trans)\n\n\t\t\t\t## add data to graph\n\t\t\t\tself.graph.add_node(first_part_trans.id)\n\t\t\t\tself.graph.add_node(next_part_trans.id)\n\t\t\t\tself.graph.add_edge(first_part_trans.id, next_part_trans.id, conn1, conn2)\n\n\t\t\t\n\t\t\telse:\n\t\t\t\taggr_rule = rule.split(\">\")[0]\n\t\t\t\trule_parts = aggr_rule.split(\"_\")\n\t\t\t\t\n\t\t\t\t## TO FIX >>> conflict between text and int ids\n\t\t\t\ttry:\n\t\t\t\t\tpart1_id = int(rule_parts[0].split(\"|\")[0])\n\t\t\t\texcept:\n\t\t\t\t\tpart1_id = str(rule_parts[0].split(\"|\")[0])\n\t\t\t\t\n\t\t\t\tconn1 = int(rule_parts[0].split(\"|\")[1])\n\t\t\t\tpart2 = str(rule_parts[1].split(\"|\")[0])\n\t\t\t\tconn2 = int(rule_parts[1].split(\"|\")[1])\n\t\t\t\t\n\t\t\t\trule_ids = rule.split(\">\")[1].split(\"_\")\n\t\t\t\t## TO FIX >>> conflict between text and int ids\n\t\t\t\ttry:\n\t\t\t\t\tfor i in range(2):\n\t\t\t\t\t\trule_ids[i] = int(rule_ids[i])\n\t\t\t\texcept:\n\t\t\t\t\tpass\n\n\t\t\t\t\n\t\t\t\tfirst_part = None\n\t\t\t\tfor part in self.aggregated_parts:\n\t\t\t\t\tif part.id == part1_id:\n\t\t\t\t\t\tfirst_part = part\n\t\t\t\t\t\tbreak\n\t\t\t\tif first_part is not None:\n\t\t\t\t\tfirst_part.id = rule_ids[0]\n\t\t\t\t\tnext_part = self.parts[part2]\n\t\t\t\t\t\n\t\t\t\t\torientTransform = Transform.PlaneToPlane(next_part.connections[conn2].flip_pln, first_part.connections[conn1].pln)\n\t\t\t\t\tnext_part_trans = next_part.transform(orientTransform)\n\t\t\t\t\tnext_part_trans.id = rule_ids[1]\n\n\t\t\t\t\t## parent-child tracking\n\t\t\t\t\tfirst_part.children.append(next_part_trans.id)\n\t\t\t\t\tnext_part_trans.parent = first_part.id\n\t\t\t\t\tnext_part_trans.conn_on_parent = conn1\n\t\t\t\t\tnext_part_trans.conn_to_parent = conn2\n\n\t\t\t\t\t## add part to aggregated_parts list\n\t\t\t\t\tself.aggregated_parts.append(next_part_trans)\n\n\t\t\t\t\t## add data to graph\n\t\t\t\t\tself.graph.add_node(next_part_trans.id)\n\t\t\t\t\tself.graph.add_edge(first_part.id, next_part_trans.id, conn1, conn2)\n\n\n\t\t\t\telse:\n\t\t\t\t\t## if a part with a given id could not be found, return an error message\n\t\t\t\t\tmsg = \"Could not find part with id \" + str(part1_id)\n\t\t\t\t\treturn msg\n\n\t\n\t## stochastic aggregation\n\tdef aggregate_rnd(self, num, use_catalog = False):\n\t\tadded = 0\n\t\tloops = 0\n\t\twhile added < num:\n\t\t\tloops += 1\n\t\t\tif loops > num*100:\n\t\t\t\tmsg = \"Could not place \" + str(num-added) + \" parts\"\n\t\t\t\treturn msg\n\t\t\t\n\t\t\t## if no part is present in the aggregation, add first random part\n\t\t\tif len(self.aggregated_parts) == 0:\n\t\t\t\t\n\t\t\t\t## choose first part\n\t\t\t\tfirst_part = None\n\t\t\t\tif use_catalog:\n\t\t\t\t\tfirst_part = self.parts[self.catalog.return_weighted_part()]\n\t\t\t\telse:\n\t\t\t\t\tfirst_part = self.parts[random.choice(self.parts.keys())]\t\t\n\n\t\t\t\tif first_part is not None:\n\t\t\t\t\tfirst_part_trans = first_part.transform(Transform.Identity)\n\t\t\t\t\tfor conn in first_part_trans.connections:\n\t\t\t\t\t\tconn.generate_rules_table(self.rules)\n\t\t\t\t\t\n\t\t\t\t\tfirst_part_trans.id = 0\n\t\t\t\t\tself.aggregated_parts.append(first_part_trans)\n\n\t\t\t\t\t## add data to graph\n\t\t\t\t\tself.graph.add_node(first_part_trans.id)\n\n\t\t\t\t\tadded += 1\n\t\t\t\t\tif use_catalog:\n\t\t\t\t\t\tself.catalog.update(first_part_trans.name, -1)\n\t\t\t\n\t\t\t## otherwise add new random part\n\t\t\telse:\n\t\t\t\tnext_rule = None\n\t\t\t\tpart_01_id = -1\n\t\t\t\tconn_01_id = -1\n\t\t\t\tnext_rule_id = -1\n\t\t\t\tnew_rule_attempts = 0\n\t\t\t\t\n\t\t\t\twhile new_rule_attempts < 10000:\n\t\t\t\t\tnew_rule_attempts += 1\n\t\t\t\t\tnext_rule = None\n\t\t\t\t\tif use_catalog:\n\t\t\t\t\t\tif self.catalog.is_limited and self.catalog.is_empty:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tnext_part = self.parts[self.catalog.return_weighted_part()]\n\t\t\t\t\t\tif next_part is not None:\n\t\t\t\t\t\t\tpart_01_id = random.randint(0,len(self.aggregated_parts)-1)\n\t\t\t\t\t\t\tpart_01 = self.aggregated_parts[part_01_id]\n\t\t\t\t\t\t\tif len(part_01.active_connections) > 0:\n\t\t\t\t\t\t\t\tconn_01_id = part_01.active_connections[random.randint(0, len(part_01.active_connections)-1)]\n\t\t\t\t\t\t\t\tconn_01 = part_01.connections[conn_01_id]\n\t\t\t\t\t\t\t\tif len(conn_01.active_rules) > 0:\n\t\t\t\t\t\t\t\t\tnext_rule_id = conn_01.active_rules[random.randint(0, len(conn_01.active_rules)-1)]\n\t\t\t\t\t\t\t\t\tnext_rule = conn_01.rules_table[next_rule_id]\n\t\t\t\t\t\t\t\t\tif next_rule.part2 == next_part.name:\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\t\tnext_rule = None\n\t\t\t\t\telse:\n\t\t\t\t\t\tpart_01_id = random.randint(0,len(self.aggregated_parts)-1)\n\t\t\t\t\t\tpart_01 = self.aggregated_parts[part_01_id]\n\t\t\t\t\t\tif len(part_01.active_connections) > 0:\n\t\t\t\t\t\t\tconn_01_id = part_01.active_connections[random.randint(0, len(part_01.active_connections)-1)]\n\t\t\t\t\t\t\tconn_01 = part_01.connections[conn_01_id]\n\t\t\t\t\t\t\tif len(conn_01.active_rules) > 0:\n\t\t\t\t\t\t\t\tnext_rule_id = conn_01.active_rules[random.randint(0, len(conn_01.active_rules)-1)]\n\t\t\t\t\t\t\t\tnext_rule = conn_01.rules_table[next_rule_id]\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\n\t\t\t\tif next_rule is not None:\n\t\t\t\t\tnext_part = self.parts[next_rule.part2]\n\t\t\t\t\torientTransform = Transform.PlaneToPlane(next_part.connections[next_rule.conn2].flip_pln, conn_01.pln)\n\t\t\t\t\t\n\t\t\t\t\tglobal_check, coll_check, add_coll_check, missing_sup_check, global_const_check, adjacencies_check, exclusions_back_check, orientation_check = self.check_all_constraints(next_part, orientTransform)\n\t\t\t\t\t\n\t\t\t\t\tif not global_check:\n\t\t\t\t\t\tnext_part_trans = next_part.transform(orientTransform)\n\t\t\t\t\t\tnext_part_trans.reset_part(self.rules)\n\t\t\t\t\t\tfor i in range(len(next_part_trans.active_connections)):\n\t\t\t\t\t\t\tif next_part_trans.active_connections[i] == next_rule.conn2:\n\t\t\t\t\t\t\t\tnext_part_trans.active_connections.pop(i)\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tnext_part_trans.id = len(self.aggregated_parts)\n\t\t\t\t\t\t\n\t\t\t\t\t\t## parent-child tracking\n\t\t\t\t\t\tself.aggregated_parts[part_01_id].children.append(next_part_trans.id)\n\t\t\t\t\t\tnext_part_trans.parent = self.aggregated_parts[part_01_id].id\n\t\t\t\t\t\tnext_part_trans.conn_on_parent = next_rule.conn1\n\t\t\t\t\t\tnext_part_trans.conn_to_parent = next_rule.conn2\n\t\t\t\t\t\t\n\t\t\t\t\t\t## add part to aggregated_parts list\n\t\t\t\t\t\tself.aggregated_parts.append(next_part_trans)\n\n\t\t\t\t\t\t## add data to graph\n\t\t\t\t\t\tself.graph.add_node(next_part_trans.id)\n\t\t\t\t\t\tself.graph.add_edge(part_01_id, next_part_trans.id, next_rule.conn1, next_rule.conn2)\n\n\t\t\t\t\t\t## update catalog if using one\n\t\t\t\t\t\tif use_catalog:\n\t\t\t\t\t\t\tself.catalog.update(next_part_trans.name, -1)\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor i in range(len(self.aggregated_parts[part_01_id].active_connections)):\n\t\t\t\t\t\t\tif self.aggregated_parts[part_01_id].active_connections[i] == conn_01_id:\n\t\t\t\t\t\t\t\tself.aggregated_parts[part_01_id].active_connections.pop(i)\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tadded += 1\n\t\t\t\t\t## TO FIX --> do not remove rules when only caused by missing supports\n\t\t\t\t\telse:\n\t\t\t\t\t\t## remove rules if they cause collisions or overlappings\n\t\t\t\t\t\tfor i in range(len(self.aggregated_parts[part_01_id].connections[conn_01_id].active_rules)):\n\t\t\t\t\t\t\tif self.aggregated_parts[part_01_id].connections[conn_01_id].active_rules[i] == next_rule_id:\n\t\t\t\t\t\t\t\tself.aggregated_parts[part_01_id].connections[conn_01_id].active_rules.pop(i)\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t## check if the connection is still active (still active rules available)\n\t\t\t\t\t\tif len(self.aggregated_parts[part_01_id].connections[conn_01_id].active_rules) == 0:\n\t\t\t\t\t\t\tfor i in range(len(self.aggregated_parts[part_01_id].active_connections)):\n\t\t\t\t\t\t\t\tif self.aggregated_parts[part_01_id].active_connections[i] == conn_01_id:\n\t\t\t\t\t\t\t\t\tself.aggregated_parts[part_01_id].active_connections.pop(i)\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\t## if no part is available, exit the aggregation routine and return an error message\n\t\t\t\t\tmsg = \"Could not place \" + str(num-added) + \" parts\"\n\t\t\t\t\treturn msg\n\t\n\t\n\t## compute all possibilities for child-parts of the given part, and store them in the aggregation queue\n\tdef compute_next_w_field(self, part):\n\t\t\n\t\tfor i in range(len(part.active_connections)-1, -1, -1):\n\t\t\tconn_id = part.active_connections[i]\n\t\t\tconn = part.connections[conn_id]\n\t\t\tfor i2 in range(len(conn.active_rules)-1, -1, -1):\n\t\t\t\trule_id = conn.active_rules[i2]\n\t\t\t\trule = conn.rules_table[rule_id]\n\t\t\t\t\n\t\t\t\tnext_part = self.parts[rule.part2]\n\t\t\t\t\n\t\t\t\tnext_center = Point3d(next_part.center)\n\t\t\t\torientTransform = Transform.PlaneToPlane(next_part.connections[rule.conn2].flip_pln, conn.pln)\n\t\t\t\tnext_center.Transform(orientTransform)\n\t\t\t\t\n\t\t\t\tif self.multiple_fields:\n\t\t\t\t\tf_name = next_part.field\n\t\t\t\t\tif self.field[f_name].bbox.Contains(next_center) == True:\n\t\t\t\t\t\tfield_val = self.field[f_name].return_pt_val(next_center)\n\t\t\t\t\t\t\n\t\t\t\t\t\tqueue_index = bisect.bisect_left(self.queue_values, field_val)\n\t\t\t\t\t\tqueue_entry = (next_part.name, part.id, orientTransform, rule.conn1, rule.conn2)\n\t\t\t\t\t\t\n\t\t\t\t\t\tself.queue_values.insert(queue_index, field_val)\n\t\t\t\t\t\tself.aggregation_queue.insert(queue_index, queue_entry)\n\t\t\t\t\t\tself.queue_count += 1\n\t\t\t\t\t\n\t\t\t\telse:\n\t\t\t\t\tif self.field.bbox.Contains(next_center) == True:\n\t\t\t\t\t\tfield_val = self.field.return_pt_val(next_center)\n\t\t\t\t\t\t\n\t\t\t\t\t\tqueue_index = bisect.bisect_left(self.queue_values, field_val)\n\t\t\t\t\t\tqueue_entry = (next_part.name, part.id, orientTransform, rule.conn1, rule.conn2)\n\t\t\t\t\t\t\n\t\t\t\t\t\tself.queue_values.insert(queue_index, field_val)\n\t\t\t\t\t\tself.aggregation_queue.insert(queue_index, queue_entry)\n\t\t\t\t\t\tself.queue_count += 1\n\t\n\t\n\t## field-driven aggregation\n\tdef aggregate_field(self, num, use_catalog = False):\n\t\t\n\t\tadded = 0\n\t\tloops = 0\n\t\twhile added < num:\n\t\t\t## avoid endless loops\n\t\t\tloops += 1\n\t\t\tif loops > num*100:\n\t\t\t\tmsg = \"Could not place \" + str(num-added) + \" parts\"\n\t\t\t\treturn msg\n\t\t\t\n\t\t\t## if no part is present in the aggregation, add first random part\n\t\t\tif len(self.aggregated_parts) == 0 and self.prev_num == 0:\n\n\t\t\t\t## choose first part\n\t\t\t\tfirst_part = None\n\t\t\t\tif use_catalog:\n\t\t\t\t\tfirst_part = self.parts[self.catalog.return_weighted_part()]\n\t\t\t\telse:\n\t\t\t\t\tfirst_part = self.parts[random.choice(self.parts.keys())]\n\t\t\t\t\n\t\t\t\tif first_part is not None:\n\t\t\t\t\tstart_point = None\n\t\t\t\t\tif self.multiple_fields:\n\t\t\t\t\t\tf_name = first_part.field\n\t\t\t\t\t\tif (self.mode == 2 or self.mode == 3) and len(self.global_constraints) > 0:\n\t\t\t\t\t\t\tstart_point = self.field[f_name].return_highest_pt(constraints=self.global_constraints)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tstart_point = self.field[f_name].return_highest_pt()\n\t\t\t\t\telse:\n\t\t\t\t\t\tif (self.mode == 2 or self.mode == 3) and len(self.global_constraints) > 0:\n\t\t\t\t\t\t\tstart_point = self.field.return_highest_pt(constraints=self.global_constraints)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tstart_point = self.field.return_highest_pt()\n\t\t\t\t\t\n\t\t\t\t\tbase_plane = Plane(first_part.center, Vector3d.XAxis, Vector3d.YAxis)\n\t\t\t\t\tfirst_transform = Transform.PlaneToPlane(base_plane, start_point)\n\t\t\t\t\t\n\t\t\t\t\t#### maybe add possibility to choose if first part should be oriented in the field plane or not\n\t\t\t\t\tfirst_part_trans = first_part.transform(first_transform)\n\t\t\t\t\t\n\t\t\t\t\tfor conn in first_part_trans.connections:\n\t\t\t\t\t\tconn.generate_rules_table(self.rules)\n\t\t\t\t\t\n\t\t\t\t\tfirst_part_trans.id = 0\n\t\t\t\t\tself.aggregated_parts.append(first_part_trans)\n\n\t\t\t\t\t## add data to graph\n\t\t\t\t\tself.graph.add_node(first_part_trans.id)\n\n\t\t\t\t\t## update catalog\n\t\t\t\t\tif use_catalog:\n\t\t\t\t\t\tself.catalog.update(first_part_trans.name, -1)\n\t\t\t\t\t\n\t\t\t\t\t## compute all possible next parts and append to list\n\t\t\t\t\tself.compute_next_w_field(first_part_trans)\n\t\t\t\t\tadded += 1\n\t\t\t\n\t\t\telse:\n\t\t\t\t## if no part is available, exit the aggregation routine and return an error message\n\t\t\t\tif self.queue_count == 0:\n\t\t\t\t\tmsg = \"Could not place \" + str(num-added) + \" parts\"\n\t\t\t\t\treturn msg\n\t\t\t\t\n\t\t\t\tnext_data = None\n\t\t\t\tnext_data_id = -1\n\t\t\t\tnext_part = None\n\t\t\t\tnext_center = None\n\t\t\t\torientTransform = None\n\n\t\t\t\t## choose next part\n\t\t\t\t#### with catalog > best in queue of a give type\n\t\t\t\tif use_catalog:\n\t\t\t\t\tif self.catalog.is_limited and self.catalog.is_empty:\n\t\t\t\t\t\tmsg = \"Could not place \" + str(num-added) + \" parts. Part Catalog is empty.\"\n\t\t\t\t\t\treturn msg\n\t\t\t\t\telse:\n\t\t\t\t\t\tnext_part_id = None\n\t\t\t\t\t\tnext_part_attempts = 0\n\t\t\t\t\t\t###### WIP, could be optimized using a set with all names of parts in the queue\n\t\t\t\t\t\twhile next_part_attempts < 1000:\n\t\t\t\t\t\t\tnext_part_attempts += 1\n\t\t\t\t\t\t\tnext_part_id = self.catalog.return_weighted_part()\n\t\t\t\t\t\t\tfor i in range(self.queue_count-1, -1, -1):\n\t\t\t\t\t\t\t\tif self.aggregation_queue[i][0] == next_part_id:\n\t\t\t\t\t\t\t\t\tnext_data = self.aggregation_queue[i]\n\t\t\t\t\t\t\t\t\tnext_data_id = i\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\tif next_data is not None:\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\n\t\t\t\t#### without catalog > last item in the queue\n\t\t\t\telse:\n\t\t\t\t\tnext_data = self.aggregation_queue[self.queue_count-1]\n\n\t\t\t\tif next_data is not None:\n\t\t\t\t\tnext_part = self.parts[next_data[0]]\n\t\t\t\t\tnext_center = Point3d(next_part.center)\n\t\t\t\t\torientTransform = next_data[2]\n\t\t\t\t\t\n\t\t\t\t\tglobal_check, coll_check, add_coll_check, missing_sup_check, global_const_check, adjacencies_check, exclusions_back_check, orientation_check = self.check_all_constraints(next_part, orientTransform)\n\t\t\t\t\t\t\n\t\t\t\t\tif not global_check:\n\t\t\t\t\t\tnext_part_trans = next_part.transform(orientTransform)\n\t\t\t\t\t\tnext_part_trans.reset_part(self.rules)\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor conn in next_part_trans.connections:\n\t\t\t\t\t\t\tconn.generate_rules_table(self.rules)\n\t\t\t\t\t\t\n\t\t\t\t\t\tnext_part_trans.id = len(self.aggregated_parts)\n\n\t\t\t\t\t\t## parent-child tracking\n\t\t\t\t\t\tself.aggregated_parts[next_data[1]].children.append(next_part_trans.id)\n\t\t\t\t\t\tnext_part_trans.parent = self.aggregated_parts[next_data[1]].id\n\t\t\t\t\t\tnext_part_trans.conn_on_parent = next_data[3]\n\t\t\t\t\t\tnext_part_trans.conn_to_parent = next_data[4]\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t## add part to aggregated_parts list\n\t\t\t\t\t\tself.aggregated_parts.append(next_part_trans)\n\n\t\t\t\t\t\t## add data to graph\n\t\t\t\t\t\tself.graph.add_node(next_part_trans.id)\n\t\t\t\t\t\tself.graph.add_edge(next_data[1], next_part_trans.id, next_data[3], next_data[4])\n\n\t\t\t\t\t\t## update catalog if using one\n\t\t\t\t\t\tif use_catalog:\n\t\t\t\t\t\t\tself.catalog.update(next_part_trans.name, -1)\n\t\t\t\t\t\t\n\t\t\t\t\t\t## compute all possible next parts and append to list\n\t\t\t\t\t\tself.compute_next_w_field(next_part_trans)\n\t\t\t\t\t\tadded += 1\n\t\t\t\t\t\n\t\t\t\t\t## TO FIX --> do not remove rules when only caused by missing supports\n\t\t\t\t\tif use_catalog:\n\t\t\t\t\t\tself.aggregation_queue.pop(next_data_id)\n\t\t\t\t\t\tself.queue_values.pop(next_data_id)\n\t\t\t\t\telse:\n\t\t\t\t\t\tself.aggregation_queue.pop()\n\t\t\t\t\t\tself.queue_values.pop()\n\t\t\t\t\t\n\t\t\t\t\tself.queue_count -=1\n\t\t\t\telse:\n\t\t\t\t\tmsg = \"Could not place \" + str(num-added) + \" parts\"\n\t\t\t\t\treturn msg",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}