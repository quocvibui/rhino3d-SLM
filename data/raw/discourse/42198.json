{
  "source_url": "https://discourse.mcneel.com/t/need-help-python-recursive-subdivision/42198",
  "topic_id": 42198,
  "title": "Need help, Python recursive subdivision",
  "question": "Hey,\n\nI’ve been trying to create a python function that takes a flat list of closed triangular polylines and subdivide dem at a given parameter (in my example .5 of each curve) returning 4 new triangles for each polyline in the line. I would then like to set the number of iterations, so that 1 polyline triangle first turns into a total of 4, 16, 64, etc, forming smaller and smaller polyline triangles within the scope of the first one. I’m not a very experienced progammer and this is the first time I take on the task of creating a recursive function, so please bear with me.\n\n\nI’ve managed to get the basic recursiveness of the function working, altough it the recursive part seems to only iterate over the last polyline in the list. I’ve been staring at this for hours now and would be really greatful for any help getting this right!\n\n\nHere is my function:\n\n\n#performs subdivision on a list of equilateral triangle polylines\n\ndef subDivEquiTriangles2(polylines, generation, recursionLevel):\n    if generation > recursionLevel: return\n    generation += 1\n\n    for p in polylines:\n        newPoints = []\n        for i in range(len(p)-1):\n            newPoints.append(Rhino.Geometry.Point3d((p[i][0] + p[i+1][0])/2, (p[i][1] + p[i+1][1])/2, (p[i][2] + p[i+1][2])/2))\n        subD = [\n        Rhino.Geometry.Polyline([p[0], newPoints[0], newPoints[2], p[0]]),\n        Rhino.Geometry.Polyline([newPoints[2], newPoints[1], p[2], newPoints[2]]),\n        Rhino.Geometry.Polyline([newPoints[0], p[1], newPoints[1], newPoints[0]]), \n        Rhino.Geometry.Polyline([newPoints[0], newPoints[1], newPoints[2], newPoints[0]])\n        ]\n        #REPLACE EACH VALUE IN SUBD WITH 4 NEW\n        if generation <= recursionLevel:\n            for i in range(len(subD)):\n                subD[i:i+1] = subDivEquiTriangles2(subD, generation, recursionLevel)\n    return subD\n\n\n\nand here is a picture of what it produces:\n\n\n\n\nNamnlöst-1.jpg\n813×610 51.1 KB\n\n\n\n\nMany thanks\n\n\nJakob",
  "code_blocks": [
    {
      "code": "import Rhino\nimport scriptcontext\n\ndef one2four( pli ):\n  p01 = ( pli[ 0 ] + pli[ 1 ] ) / 2.0\n  p12 = ( pli[ 1 ] + pli[ 2 ] ) / 2.0\n  p20 = ( pli[ 2 ] + pli[ 0 ] ) / 2.0\n  return [\n      Rhino.Geometry.Polyline( [ pli[ 0 ], p01, p20, pli[ 0 ] ] ),\n      Rhino.Geometry.Polyline( [ pli[ 1 ], p12, p01, pli[ 1 ] ] ),\n      Rhino.Geometry.Polyline( [ pli[ 2 ], p20, p12, pli[ 2 ] ] ),\n      Rhino.Geometry.Polyline( [ p01, p12, p20, p01 ] ) ]\n\ndef dividelist( plis, times ):\n  if times < 1:\n    return plis\n  result = []\n  for pli in plis:\n    result.extend( one2four( pli ) )\n  if times > 1:\n    result = dividelist( result, times - 1 )\n  return result\n\ndef main():\n  pli = Rhino.Geometry.Polyline( [\n      Rhino.Geometry.Point3d( 0, 0, 0 ),\n      Rhino.Geometry.Point3d( 100, 0, 0 ),\n      Rhino.Geometry.Point3d( 50, 87, 0 ),\n      Rhino.Geometry.Point3d( 0, 0, 0 ) ] )\n  cnt = 1\n  res, cnt = Rhino.Input.RhinoGet.GetInteger( 'Recursion depth ?', True, cnt )\n  if res == Rhino.Commands.Result.Success:\n    plis = dividelist( [ pli ], cnt )\n    for pli in plis:\n      scriptcontext.doc.Objects.Addpolyline( pli )\n    scriptcontext.doc.Views.Redraw()\n\nmain()",
      "language": "python",
      "author": "emilio",
      "post_number": 3,
      "is_solution": false
    },
    {
      "code": "import math\nimport Rhino\n\n#Define function to shift a list in place\ndef shiftInPlace(l, n):\n    n = n % len(l)\n    head =l[:n]\n    l[:n] = []\n    l.extend(head)\n    return l\n\n#Define a function to move points to the unit sphere\n#Remove this bit if subdivision is beeing performed on another set of triangles than a icosasphere\ndef point2unitsphere(Point):\n    l = math.sqrt(Point[0] * Point[0] + Point[1] * Point[1] + Point[2] * Point[2])\n    return Rhino.Geometry.Point3d(Point[0]/l, Point[1]/l, Point[2]/l)\n\n#Define function to draw the points of an icosahedron\ndef icosahedron():\n    t = ( 1 + math.sqrt(5)) / 2\n    points = []\n    polylines = []\n    for k in reversed(range(-2, 1)):\n        c = []\n        for i in reversed(range(-1, 2, 2)):\n            for j in range(-1, 2, 2):\n                c.append([j, t * i, 0])\n        for j in c:\n            points.append(point2unitsphere(shiftInPlace(j, k)))\n\n    polylines.append(Rhino.Geometry.Polyline([points[0], points[11], points[5], points[0]]))\n    polylines.append(Rhino.Geometry.Polyline([points[0], points[5], points[1], points[0]]))\n    polylines.append(Rhino.Geometry.Polyline([points[0], points[1], points[7], points[0]]))\n    polylines.append(Rhino.Geometry.Polyline([points[0], points[7], points[10], points[0]]))\n    polylines.append(Rhino.Geometry.Polyline([points[0], points[10], points[11], points[0]]))\n\n    polylines.append(Rhino.Geometry.Polyline([points[1], points[5], points[9], points[1]]))\n    polylines.append(Rhino.Geometry.Polyline([points[5], points[11], points[4], points[5]]))\n    polylines.append(Rhino.Geometry.Polyline([points[11], points[10], points[2], points[11]]))\n    polylines.append(Rhino.Geometry.Polyline([points[10], points[7], points[6], points[10]]))\n    polylines.append(Rhino.Geometry.Polyline([points[7], points[1], points[8], points[7]]))\n\n    polylines.append(Rhino.Geometry.Polyline([points[3], points[9], points[4], points[3]]))\n    polylines.append(Rhino.Geometry.Polyline([points[3], points[4], points[2], points[3]]))\n    polylines.append(Rhino.Geometry.Polyline([points[3], points[2], points[6], points[3]]))\n    polylines.append(Rhino.Geometry.Polyline([points[3], points[6], points[8], points[3]]))\n    polylines.append(Rhino.Geometry.Polyline([points[3], points[8], points[9], points[3]]))\n\n    polylines.append(Rhino.Geometry.Polyline([points[4], points[9], points[5], points[4]]))\n    polylines.append(Rhino.Geometry.Polyline([points[2], points[4], points[11], points[2]]))\n    polylines.append(Rhino.Geometry.Polyline([points[6], points[2], points[10], points[6]]))\n    polylines.append(Rhino.Geometry.Polyline([points[8], points[6], points[7], points[8]]))\n    polylines.append(Rhino.Geometry.Polyline([points[9], points[8], points[1], points[9]]))\n\n    return polylines\n\n#subdivides a single triangular polyline into 4 smaller\ndef subdivide_triangle(polylines, recursionLevel):\n\n    #Define function to subdive a single closed triangular polyline to 4 smaller ones\n    def one2four(polyline):\n        p01 = point2unitsphere((polyline[0] + polyline[1]) / 2)\n        p12 = point2unitsphere((polyline[1] + polyline[2]) / 2)\n        p20 = point2unitsphere((polyline[2] + polyline[0]) / 2)\n\n        return [\n        Rhino.Geometry.Polyline([polyline[0], p01, p20, polyline[0]]),\n        Rhino.Geometry.Polyline([p20, p12, polyline[2], p20]),\n        Rhino.Geometry.Polyline([p01, polyline[1], p12, p01]), \n        Rhino.Geometry.Polyline([p01, p12, p20, p01])\n        ]\n\n    def dividelist(polylines, recursionLevel):\n        if recursionLevel < 1: return polylines\n        result = []\n        for polyline in polylines:\n            result.extend(one2four(polyline))\n        if recursionLevel > 1:\n            result = dividelist(result, recursionLevel - 1)\n        return result\n\n    polylines = dividelist(polylines, recursionLevel)\n    return polylines\n\nIcosahedron = icosahedron()\na = subdivide_triangle(Icosahedron, recursionLevel)",
      "language": "python",
      "author": "Jakob1",
      "post_number": 4,
      "is_solution": false
    },
    {
      "code": "#performs subdivision on a list of equilateral triangle polylines\n\ndef subDivEquiTriangles2(polylines, generation, recursionLevel):\n    if generation > recursionLevel: return\n    generation += 1\n\n    for p in polylines:\n        newPoints = []\n        for i in range(len(p)-1):\n            newPoints.append(Rhino.Geometry.Point3d((p[i][0] + p[i+1][0])/2, (p[i][1] + p[i+1][1])/2, (p[i][2] + p[i+1][2])/2))\n        subD = [\n        Rhino.Geometry.Polyline([p[0], newPoints[0], newPoints[2], p[0]]),\n        Rhino.Geometry.Polyline([newPoints[2], newPoints[1], p[2], newPoints[2]]),\n        Rhino.Geometry.Polyline([newPoints[0], p[1], newPoints[1], newPoints[0]]), \n        Rhino.Geometry.Polyline([newPoints[0], newPoints[1], newPoints[2], newPoints[0]])\n        ]\n        #REPLACE EACH VALUE IN SUBD WITH 4 NEW\n        if generation <= recursionLevel:\n            for i in range(len(subD)):\n                subD[i:i+1] = subDivEquiTriangles2(subD, generation, recursionLevel)\n    return subD",
      "language": "python",
      "author": "Jakob1",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "python",
    "rhinocommon",
    "transformation",
    "ui"
  ],
  "has_accepted_answer": false,
  "category_id": 8,
  "posts_count": 5,
  "views": 2401
}