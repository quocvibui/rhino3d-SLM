{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/xBrepFace.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "xBrepFace.py",
  "instruction": "200619: Created.\r\n200629: Bug fix.\r\n200729: Import-related update.\r\n200810: Added a couple of functions.\r\n210114: Removed raise for when createPoint3dOnInterior doesn't find a point.\r\n210209: Now...",
  "code": "\"\"\"\r\n200619: Created.\r\n200629: Bug fix.\r\n200729: Import-related update.\r\n200810: Added a couple of functions.\r\n210114: Removed raise for when createPoint3dOnInterior doesn't find a point.\r\n210209: Now won't raise an error when 2 curves do not close in splitFace.\r\n210407: Added more support for new-in-V7's BrepFace.PerFaceColor.\r\n210412: Added more times fEdgeLen_Min is used in splitFace.\r\n210503: Now, curves on SENW are ignored for retrim when underlying surface is not being replaced.\r\n210929: is3dPointOnFace now converts non-NurbsSurfaces into NurbsSurfaces on ClosestPoint fails.\r\n220317: Updated to use a new overload.  Import-related update.\r\n230830: Disabled a routine in splitFace for testing purposes.\r\n230901: Added code for debugging.\r\n250324: Added routines that adjust curves to meet with natural corners and/or sides of surfaces.\r\n        Added check for surfaces that create bad breps.\r\n        Changed 2.0 to 1.8 to match Rhino (8)'s tolerances for joining curves.\r\n        Modified what is used for curve joining tolerance.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System import Random\r\n\r\nimport xCurve\r\nimport xSurface\r\n\r\n\r\ndef createPoint3dOnInterior(rgFace, fMinDistFromBorder=None, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rgFace: BrepFace\r\n        fMinDistFromBorder: float or (None to loop through various)\r\n    Returns:\r\n        Point3d on success, None on failure\r\n    \"\"\"\r\n    \r\n    fMinDistFromBorder_In = fMinDistFromBorder\r\n    \r\n    rgB_1F = rgFace.DuplicateFace(duplicateMeshes=False)\r\n    rgB_1F.Faces.ShrinkFaces()\r\n    rgB_1F.Compact() # Is this cecessary to remove duplicate surfaces?\r\n    rgSrf_Shrunk = rgB_1F.Surfaces[0]\r\n    \r\n    domU_Shrunk = rgSrf_Shrunk.Domain(0)\r\n    domV_Shrunk = rgSrf_Shrunk.Domain(1)\r\n\r\n    #areaMassProp = rg.AreaMassProperties.Compute(rgFace.DuplicateFace(True)) # Otherwise, Compute uses underlying Surface for BrepFace.\r\n    #if areaMassProp is None:\r\n    #    print \"Face[{}]'s AreaMassProperties cannot be calculated.\".format(\r\n    #        rgFace.FaceIndex)\r\n    #    u = domU_Shrunk.Mid\r\n    #    v = domV_Shrunk.Mid\r\n    #else:\r\n    #    ptCentrdW = areaMassProp.Centroid\r\n    #    bSuccess, u, v = rgFace.ClosestPoint(ptCentrdW)\r\n\r\n    u_Shrunk = domU_Shrunk.Mid\r\n    v_Shrunk = domV_Shrunk.Mid\r\n\r\n    # To3dCurve will include curves of seams.  This is advantageous in this circumstance.\r\n    cs_All_loops_for_split = [loop.To3dCurve() for loop in rgFace.Loops]\r\n\r\n    rand = Random()\r\n\r\n    if fMinDistFromBorder_In is None:\r\n        rangeTol = (\r\n            10.0*sc.doc.ModelAbsoluteTolerance,\r\n            sc.doc.ModelAbsoluteTolerance,\r\n            0.5*sc.doc.ModelAbsoluteTolerance\r\n            )\r\n    else:\r\n        rangeTol = fMinDistFromBorder_In,\r\n\r\n    for fMinDistFromBorder in rangeTol:\r\n        for i in xrange(1000):\r\n            pt = rgSrf_Shrunk.PointAt(u_Shrunk, v_Shrunk)\r\n            \r\n            b, u, v = rgFace.ClosestPoint(pt)\r\n            if not b: raise ValueError(\"ClosestPoint failed in createPointOnFace.\")\r\n            \r\n            ptFaceRel = rgFace.IsPointOnFace(u, v)\r\n            #sc.doc.Objects.AddPoint(pt); sc.doc.Views.Redraw()\r\n\r\n            if bDebug: sEval = \"ptFaceRel\"; print sEval+':',eval(sEval)\r\n\r\n            if ptFaceRel == rg.PointFaceRelation.Interior:\r\n                # If point is not at least fMinDistFromBorder from border (all edges),\r\n                # continue searching.\r\n                for c in cs_All_loops_for_split:\r\n                    b, t = c.ClosestPoint(pt)\r\n                    if not b: raise ValueError(\"ClosestPoint failed in createPointOnFace.\")\r\n    \r\n                    dist = pt.DistanceTo(c.PointAt(t))\r\n                    if dist < fMinDistFromBorder:\r\n                        break # to get another u and v.\r\n                else: # Good point\r\n                    for c in cs_All_loops_for_split: c.Dispose()\r\n                    rgB_1F.Dispose()\r\n                    if bDebug: sEval = \"i\"; print sEval+':',eval(sEval)\r\n                    return pt\r\n    \r\n            # Get new parameters for point.\r\n            u_Shrunk = rand.NextDouble() * domU_Shrunk.Length + domU_Shrunk.Min\r\n            v_Shrunk = rand.NextDouble() * domV_Shrunk.Length + domV_Shrunk.Min\r\n\r\n    from System.Drawing import Color\r\n    attr = rd.ObjectAttributes()\r\n    attr.LayerIndex = sc.doc.Layers.CurrentLayerIndex\r\n    attr.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n    attr.ObjectColor = Color.Red\r\n    sc.doc.Objects.AddBrep(rgFace.DuplicateFace(duplicateMeshes=True), attributes=attr)\r\n\r\n    print \"Failed to find an interior point on face.\" \\\r\n        \"  Its monoface has been added to the document.\"\r\n\r\n    #sc.doc.Views.Redraw()\r\n    #raise ValueError(\r\n    #    \"Failed to find an interior point on face[{}].\".format(\r\n    #        rgFace.FaceIndex))\r\n\r\n\r\ndef is3dPointOnFace(rgFace, pt, fTolerance=None):\r\n    \"\"\"\r\n    Returns:\r\n        False when the point is at least fTolerance from the face's underlying surface.\r\n        Otherwise, rg.PointFaceRelation.Interior or Boundary.\r\n    \"\"\"\r\n    \r\n    if fTolerance is None:\r\n        fTolerance = sc.doc.ModelAbsoluteTolerance\r\n    \r\n    b, u, v = rgFace.ClosestPoint(pt) # ClosestPoint is a Surface method and ignores edges of BrepFaces.\r\n    if not b:\r\n        s = \"ClosestPoint on {} failed \".format(rgFace.UnderlyingSurface().GetType().Name)\r\n        s += \"at {:.15g},{:.15g},{:.15g}.\".format(pt.X, pt.Y, pt.Z)\r\n        if isinstance(rgFace.UnderlyingSurface(), rg.NurbsSurface):\r\n            print s\r\n            return\r\n\r\n        ns = rgFace.UnderlyingSurface().ToNurbsSurface()\r\n        b, u, v = ns.ClosestPoint(pt)\r\n        ns.Dispose()\r\n        if not b:\r\n            s += \"  It also failed for the NurbsSurface equivalent.\"\r\n            print s\r\n            return\r\n        s += \"  But NurbsSurface equivalent passed.\"\r\n        print s\r\n\r\n    dist = rgFace.PointAt(u,v).DistanceTo(pt)\r\n    if dist > fTolerance:\r\n        # Point isn't even on underlying surface.\r\n        return False\r\n\r\n    try:\r\n        ptFaceRel = rgFace.IsPointOnFace(u, v, fTolerance) # Overload added to RhinoCommon 7.0.\r\n    except:\r\n        ptFaceRel = isParameterPointOnFace_beforeV7(\r\n            rgFace, u, v, fTolerance)\r\n\r\n    if ptFaceRel == rg.PointFaceRelation.Interior:\r\n        pass\r\n    elif ptFaceRel == rg.PointFaceRelation.Exterior:\r\n        pass\r\n    elif ptFaceRel == rg.PointFaceRelation.Boundary:\r\n        pass\r\n    else:\r\n        pass\r\n\r\n    return ptFaceRel\r\n\r\n\r\ndef isParameterPointOnFace_beforeV7(rgFace, u, v, f3dTolerance=None):\r\n    \"\"\"\r\n    Hard-coded (3D) tolerance of IsPointOnFace up through at least V6.28 (7/17/2020)\r\n    is Rhino.RhinoMath.SqrtEpsilon.\r\n    Request to add tolerance parameter:\r\n    https://discourse.mcneel.com/t/wish-add-tolerance-parameter-to-ispointonface/106801\r\n    Until tolerance parameter is added to IsPointOnFace,\r\n    check False values against distance from closest edge.\r\n    \"\"\"\r\n    \r\n    if f3dTolerance is None:\r\n        f3dTolerance = sc.doc.ModelAbsoluteTolerance\r\n    \r\n    ptAt = rgFace.PointAt(u, v)\r\n    # Note that this Point3d will already be pulled to the face.\r\n    # For true 3D point check, use is3dPointOnFace instead.\r\n    \r\n    ptFaceRel = rgFace.IsPointOnFace(u, v)\r\n    \r\n    if ptFaceRel == rg.PointFaceRelation.Boundary:\r\n        return rg.PointFaceRelation.Boundary\r\n    \r\n    for iE in rgFace.AdjacentEdges():\r\n        bSuccess, t = rgFace.Brep.Edges[iE].ClosestPoint(\r\n            testPoint=ptAt,\r\n            maximumDistance=f3dTolerance)\r\n        if not bSuccess:\r\n            continue\r\n        pt_onEdge = rgFace.Brep.Edges[iE].PointAt(t)\r\n        dist_toCrv = ptAt.DistanceTo(other=pt_onEdge)\r\n        if dist_toCrv <= f3dTolerance:\r\n            return rg.PointFaceRelation.Boundary\r\n    else:\r\n        # No distances smaller than f3dTolerance found.\r\n        return ptFaceRel # Exterior or boundary.\r\n\r\n\r\ndef separate_short_curves_from_others_in_loop(cs_ofLoop, fTol_MinDistBetweenOpenEnds=None):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    if fTol_MinDistBetweenOpenEnds is None:\r\n        fTol_MinDistBetweenOpenEnds = 1.8 * sc.doc.ModelAbsoluteTolerance\r\n\r\n    cs_WIP = []\r\n    cs_Shorts = []\r\n    for c in cs_ofLoop:\r\n        \r\n        # 250324: Commented out and replaced by below this comment block.\r\n        #fLength = c.GetLength()\r\n        #if fLength > max(fSplitTol, fEdgeLen_Min):\r\n        #    cs_WIP.append(c)\r\n        #else:\r\n        #    c.Dispose()\r\n        \r\n        if c.IsClosed:\r\n            if len(cs_ofLoop) > 1:\r\n                print(\"Closed curve found in loop of {}.\".format(len(cs_ofLoop)))\r\n                return\r\n\r\n            fLength = c.GetLength()\r\n            if fLength <= (2.0 * fTol_MinDistBetweenOpenEnds):\r\n                import rhinoscriptsyntax as rs\r\n                point = c.PointAt(c.Domain.Mid)\r\n                rs.AddTextDot(\r\n                    text=\"Tiny trim loop?\",\r\n                    point=point)\r\n                break\r\n        \r\n            cs_WIP.append(c)\r\n            continue\r\n        \r\n        fDist_BtwnEndPts = c.PointAtStart.DistanceTo(c.PointAtEnd)\r\n        if fDist_BtwnEndPts <= fTol_MinDistBetweenOpenEnds:\r\n            fLength = c.GetLength()\r\n            if fLength >= (2.0 * fDist_BtwnEndPts): # 2.0 is a guess. See print below.\r\n                import rhinoscriptsyntax as rs\r\n                #_rgB = rgFace.DuplicateFace(duplicateMeshes=False)\r\n                #_rgB.Faces.ShrinkFaces()\r\n                #_rgF = _rgB.Faces[0]\r\n                #point = _rgF.PointAt(u=_rgF.Domain(0).Mid, v=_rgF.Domain(1).Mid)\r\n                point = c.PointAt(c.Domain.Mid)\r\n                rs.AddTextDot(\r\n                    text=\"Large loop in trim?\",\r\n                    point=point)\r\n                #_rgB.Dispose()\r\n                print(\"End points are close but length is at least double the distance.\"\r\n                    \"This face will not be retrimmed.\"\r\n                    \"Dot added.\")\r\n                return\r\n            #sEval=\"c.IsDocumentControlled\"; print(sEval,'=',eval(sEval))\r\n            #c.Dispose()\r\n            cs_Shorts.append(c)\r\n            continue\r\n\r\n        cs_WIP.append(c)\r\n\r\n    return cs_WIP, cs_Shorts\r\n\r\n\r\ndef rebuild_short_contiguous_crvs(cs_Short, fTol_MinDistBetweenOpenEnds=None):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    if fTol_MinDistBetweenOpenEnds is None:\r\n        fTol_MinDistBetweenOpenEnds = 1.8 * sc.doc.ModelAbsoluteTolerance\r\n\r\n    joinTolerance = 1e-6 * Rhino.RhinoMath.UnitScale(\r\n        Rhino.UnitSystem.Millimeters, sc.doc.ModelUnitSystem)\r\n\r\n    cs_joined = rg.Curve.JoinCurves(cs_Short, joinTolerance=joinTolerance)\r\n\r\n    cs_Out = []\r\n\r\n    for cs in cs_joined:\r\n        if not isinstance(cs, (rg.PolyCurve, rg.PolylineCurve)):\r\n            continue\r\n\r\n        fDist = cs.PointAtStart.DistanceTo(cs.PointAtEnd)\r\n\r\n        if fDist <= fTol_MinDistBetweenOpenEnds:\r\n            continue\r\n\r\n        rebuilt = cs.Rebuild(\r\n            pointCount=4,\r\n            degree=3,\r\n            preserveTangents=False)\r\n\r\n        rvs = rg.Curve.GetDistancesBetweenCurves(cs, rebuilt, tolerance=0.1*joinTolerance)\r\n        if not rvs[0]:\r\n            continue\r\n\r\n        if rvs[1] > 0.1 * sc.doc.ModelAbsoluteTolerance:\r\n            continue\r\n\r\n        cs_Out.append(rebuilt)\r\n\r\n    return cs_Out\r\n\r\n\r\ndef _getNaturalCornerPts(srf):\r\n    return (\r\n        srf.PointAt(srf.Domain(0).Min, srf.Domain(1).Min),\r\n        srf.PointAt(srf.Domain(0).Min, srf.Domain(1).Max),\r\n        srf.PointAt(srf.Domain(0).Max, srf.Domain(1).Min),\r\n        srf.PointAt(srf.Domain(0).Max, srf.Domain(1).Max)\r\n        )\r\n\r\n\r\ndef _getCrvsOfIsoCrvs(srf):\r\n    return (\r\n        srf.IsoCurve(direction=1, constantParameter=srf.Domain(0).T0),\r\n        srf.IsoCurve(direction=0, constantParameter=srf.Domain(1).T0),\r\n        srf.IsoCurve(direction=1, constantParameter=srf.Domain(0).T1),\r\n        srf.IsoCurve(direction=0, constantParameter=srf.Domain(1).T1)\r\n        )\r\n\r\n\r\ndef tryToExtendCrvToNearPtOfSet(crv_In, side, pts_Target, tolerance):\r\n    dists = []\r\n    if side == rg.CurveEnd.Start:\r\n        pt_c = crv_In.PointAtStart\r\n    elif side == rg.CurveEnd.End:\r\n        pt_c = crv_In.PointAtEnd\r\n    else:\r\n        raise Exception(\"{} passed as the side.\".format(side))\r\n\r\n    for pt_Target in pts_Target:\r\n        dist = pt_c.DistanceTo(pt_Target)\r\n        dists.append(dist)\r\n\r\n    if min(dists) > tolerance:\r\n        return\r\n\r\n    idx_Winner = dists.index(min(dists))\r\n\r\n    return crv_In.Extend(\r\n        side=side,\r\n        style=rg.CurveExtensionStyle.Smooth,\r\n        endPoint=pts_Target[idx_Winner])\r\n\r\n\r\ndef tryToSetCrvEndToPtOfSet(crv_In, side, pts_Target, tolerance):\r\n    dists = []\r\n    if side == rg.CurveEnd.Start:\r\n        pt_c = crv_In.PointAtStart\r\n        setPoint = rg.Curve.SetStartPoint\r\n    elif side == rg.CurveEnd.End:\r\n        pt_c = crv_In.PointAtEnd\r\n        setPoint = rg.Curve.SetEndPoint\r\n    else:\r\n        raise Exception(\"{} passed as the side.\".format(side))\r\n\r\n    for pt_Target in pts_Target:\r\n        dist = pt_c.DistanceTo(pt_Target)\r\n        dists.append(dist)\r\n\r\n    if min(dists) > tolerance:\r\n        return\r\n\r\n    idx_Winner = dists.index(min(dists))\r\n\r\n    crv_Out = crv_In.DuplicateCurve()\r\n\r\n    bSuccess = setPoint(crv_Out, point=pts_Target[idx_Winner])\r\n\r\n    if bSuccess:\r\n        return crv_Out\r\n\r\n    crv_Out.Dispose()\r\n\r\n\r\ndef tryToExtendCrvToNearCrvOfSet(crv_In, side, crvs_Target, tolerance):\r\n    dists = []\r\n    if side == rg.CurveEnd.Start:\r\n        pt_c = crv_In.PointAtStart\r\n    elif side == rg.CurveEnd.End:\r\n        pt_c = crv_In.PointAtEnd\r\n    else:\r\n        raise Exception(\"{} passed as the side.\".format(side))\r\n\r\n    for crv_Target in crvs_Target:\r\n        bSuccess, t = crv_Target.ClosestPoint(pt_c)\r\n        dist = pt_c.DistanceTo(crv_Target.PointAt(t))\r\n        dists.append(dist)\r\n\r\n    if min(dists) > tolerance:\r\n        return\r\n\r\n    idx_Winner = dists.index(min(dists))\r\n\r\n    return crv_In.Extend(\r\n        side=side,\r\n        style=rg.CurveExtensionStyle.Smooth,\r\n        geometry=[crvs_Target[idx_Winner]])\r\n\r\n\r\ndef is_pt_near_a_pt_in_set(pt_toTest, pts_Ref, tolerance):\r\n    for pt_Ref in pts_Ref:\r\n        dist = pt_toTest.DistanceTo(pt_Ref)\r\n        if dist <= tolerance:\r\n            return True\r\n    return False\r\n\r\n\r\ndef is_pt_near_a_crv_of_set(pt_toTest, crvs_Ref, tolerance):\r\n    for crv_Ref in crvs_Ref:\r\n        bSuccess, t = crv_Ref.ClosestPoint(pt_toTest)\r\n        dist = pt_toTest.DistanceTo(crv_Ref.PointAt(t))\r\n        if dist <= tolerance:\r\n            return True\r\n    return False\r\n\r\n\r\ndef tryToAdjustCrvEndsToSENW(crv_In, rgSrf_toSplit, tolerance):\r\n    zeroTol = 1e-6 * Rhino.RhinoMath.UnitScale(\r\n        Rhino.UnitSystem.Millimeters, sc.doc.ModelUnitSystem)\r\n\r\n    pts_Corner = _getNaturalCornerPts(rgSrf_toSplit)\r\n\r\n    bStartIsAtCorner = is_pt_near_a_pt_in_set(\r\n        crv_In.PointAtStart, pts_Corner, tolerance=zeroTol)\r\n\r\n    bEndIsAtCorner = is_pt_near_a_pt_in_set(\r\n        crv_In.PointAtEnd, pts_Corner, tolerance=zeroTol)\r\n\r\n    if bStartIsAtCorner and bEndIsAtCorner:\r\n        return\r\n\r\n    bProcessStart = not bStartIsAtCorner and is_pt_near_a_pt_in_set(\r\n        crv_In.PointAtStart, pts_Corner, tolerance=tolerance)\r\n    bProcessEnd = not bEndIsAtCorner and is_pt_near_a_pt_in_set(\r\n        crv_In.PointAtEnd, pts_Corner, tolerance=tolerance)\r\n\r\n    crv_Out = None\r\n    crv_WIP = crv_In\r\n\r\n    if bProcessStart:\r\n        rv = tryToExtendCrvToNearPtOfSet(\r\n            crv_WIP,\r\n            side=rg.CurveEnd.Start,\r\n            pts_Target=pts_Corner,\r\n            tolerance=tolerance)\r\n        if rv:\r\n            crv_Out = crv_WIP = rv\r\n        else:\r\n            rv = tryToSetCrvEndToPtOfSet(\r\n                crv_WIP,\r\n                side=rg.CurveEnd.Start,\r\n                pts_Target=pts_Corner,\r\n                tolerance=tolerance)\r\n            if rv:\r\n                crv_Out = crv_WIP = rv\r\n\r\n    if bProcessEnd:\r\n        rv = tryToExtendCrvToNearPtOfSet(\r\n            crv_WIP,\r\n            side=rg.CurveEnd.End,\r\n            pts_Target=pts_Corner,\r\n            tolerance=tolerance)\r\n        if rv:\r\n            crv_Out = crv_WIP = rv\r\n        else:\r\n            rv = tryToSetCrvEndToPtOfSet(\r\n                crv_WIP,\r\n                side=rg.CurveEnd.End,\r\n                pts_Target=pts_Corner,\r\n                tolerance=tolerance)\r\n            if rv:\r\n                crv_Out = crv_WIP = rv\r\n\r\n    bStartIsAtCorner = is_pt_near_a_pt_in_set(\r\n        crv_In.PointAtStart, pts_Corner, tolerance=zeroTol)\r\n\r\n    bEndIsAtCorner = is_pt_near_a_pt_in_set(\r\n        crv_In.PointAtEnd, pts_Corner, tolerance=zeroTol)\r\n\r\n    if bStartIsAtCorner and bEndIsAtCorner:\r\n        return crv_Out\r\n\r\n    isoCrvs = _getCrvsOfIsoCrvs(rgSrf_toSplit)\r\n\r\n    bStartIsOnSide = is_pt_near_a_crv_of_set(\r\n        crv_In.PointAtStart, isoCrvs, tolerance=zeroTol)\r\n\r\n    bEndIsAtCorner = is_pt_near_a_crv_of_set(\r\n        crv_In.PointAtEnd, isoCrvs, tolerance=zeroTol)\r\n\r\n    if bStartIsOnSide and bEndIsAtCorner:\r\n        return crv_Out\r\n\r\n    bProcessStart = not bStartIsOnSide and is_pt_near_a_crv_of_set(\r\n        crv_In.PointAtStart, isoCrvs, tolerance=tolerance)\r\n    bProcessEnd = not bEndIsAtCorner and is_pt_near_a_crv_of_set(\r\n        crv_In.PointAtEnd, isoCrvs, tolerance=tolerance)\r\n\r\n    if (not bProcessStart) and (not bProcessEnd):\r\n        return crv_Out\r\n\r\n    if bProcessStart:\r\n        rv = tryToExtendCrvToNearCrvOfSet(\r\n            crv_WIP,\r\n            side=rg.CurveEnd.Start,\r\n            crvs_Target=isoCrvs,\r\n            tolerance=tolerance)\r\n        if rv:\r\n            crv_Out = crv_WIP = rv\r\n\r\n    if bProcessEnd:\r\n        rv = tryToExtendCrvToNearCrvOfSet(\r\n            crv_WIP,\r\n            side=rg.CurveEnd.End,\r\n            crvs_Target=isoCrvs,\r\n            tolerance=tolerance)\r\n\r\n        if rv:\r\n            crv_Out = crv_WIP = rv\r\n\r\n    return crv_Out\r\n\r\n\r\ndef _isTrim_SENW(rgTrim):\r\n    return (rgTrim.IsoStatus == Rhino.Geometry.IsoStatus.South or\r\n            rgTrim.IsoStatus == Rhino.Geometry.IsoStatus.East or\r\n            rgTrim.IsoStatus == Rhino.Geometry.IsoStatus.North or\r\n            rgTrim.IsoStatus == Rhino.Geometry.IsoStatus.West)\r\n\r\n\r\ndef splitFace(rgFace, **kwargs):\r\n    \"\"\"\r\n    Parameters:\r\n        rgFace\r\n        rgSrf_Replacement: If None, use UnderlyingSurface of BrepFace.\r\n        rgCrvs_Splitters_Replacement: If None, use 3D curves of rgFace loops.\r\n        fSplitTol\r\n        bTrimToSegs\r\n        fEdgeLen_Min\r\n        bOutputTrimmingCrvs\r\n        bEcho\r\n        bDebug\r\n    Returns on success:\r\n        rg.Brep\r\n    Returns on fail:\r\n        None\r\n    \"\"\"\r\n\r\n\r\n    def setOpt(key, value): return kwargs[key] if key in kwargs else value\r\n\r\n    rgSrf_Replacement = setOpt('rgSrf_Replacement', None)\r\n    rgCrvs_Splitters_Replacement = setOpt('rgCrvs_Splitters_Replacement', None)\r\n    fSplitTol = setOpt('fSplitTol', sc.doc.ModelAbsoluteTolerance)\r\n    bTrimToSegs = setOpt('bTrimToSegs', True)\r\n    fEdgeLen_Min = setOpt('fEdgeLen_Min', 1.8*sc.doc.ModelAbsoluteTolerance)\r\n    bOutputTrimmingCrvs = setOpt('bOutputTrimmingCrvs', False)\r\n    bEcho = setOpt('bEcho', True)\r\n    bDebug = setOpt('bDebug', True)\r\n\r\n\r\n    if bDebug: print \"Function splitFace():\"\r\n    \r\n    rgF_In = rgFace\r\n\r\n    rgSrf_toSplit = rgF_In.UnderlyingSurface() if rgSrf_Replacement is None else rgSrf_Replacement\r\n\r\n    if not xSurface.is_srf_valid_for_brep(rgSrf_toSplit):\r\n        if isinstance(rgSrf_toSplit, rg.NurbsSurface):\r\n            return\r\n        rv = xSurface.repair_srf_invalid_for_brep(rgSrf_toSplit)\r\n        if rv is None: return\r\n        rgSrf_toSplit = rv\r\n\r\n    # Reject surfaces that contain natural edges < 2 * fSplitTol.\r\n    # 230830: Disabled this to enable surfaces with poles and to find examples where this routine is useful.\r\n    #    for iDir, t in zip(\r\n    #        (0, 0, 1, 1),\r\n    #        (rgSrf_toSplit.Domain(1).T0, rgSrf_toSplit.Domain(1).T1,\r\n    #            rgSrf_toSplit.Domain(0).T0, rgSrf_toSplit.Domain(1).T1,),\r\n    #    ):\r\n    #        isoCrv = rgSrf_toSplit.IsoCurve(iDir, t)\r\n    #        fLength = isoCrv.GetLength()\r\n    #        isoCrv.Dispose()\r\n    #        if 0.0 < fLength <= 1.8 * sc.doc.ModelAbsoluteTolerance:\r\n    #            return\r\n\r\n    # 250324: Commented out.\r\n    #fEdgeTols = []\r\n    #for idxE in rgF_In.AdjacentEdges():\r\n    #    fEdgeDev = rgF_In.Brep.Edges[idxE].Tolerance\r\n    #    if fEdgeDev is not None:\r\n    #        fEdgeTols.append(fEdgeDev)\r\n    #fMaxEdgeTol = max(fEdgeTols)\r\n\r\n\r\n\r\n    # Although splits may be successful if trims include seams,\r\n    # they are avoided for cleaner input.  Otherwise, this could be used:\r\n    # cs_All_loops_for_split = [loop.To3dCurve() for loop in rgFace_In.Loops]\r\n\r\n    isoCrvs = _getCrvsOfIsoCrvs(rgSrf_toSplit)\r\n\r\n    cs_All_loops_for_split = []\r\n\r\n    for iL in range(rgF_In.Loops.Count):\r\n        rgL = rgF_In.Loops[iL]\r\n        cs_ofLoop = []\r\n\r\n        bNaturalEdgesSkipped = False\r\n        bNearNaturalEdgeSkipped = False\r\n\r\n        for iT in range(rgL.Trims.Count):\r\n            rgT = rgL.Trims[iT]\r\n            if rgT.TrimType == rg.BrepTrimType.Seam: continue\r\n            if rgT.TrimType == rg.BrepTrimType.Singular: continue\r\n            if rgT.TrimType not in (\r\n                rg.BrepTrimType.Boundary, rg.BrepTrimType.Mated\r\n            ):\r\n                print rgT.TrimType\r\n\r\n            if rgSrf_Replacement is None:\r\n                # Ignore curves on SENW.\r\n                if _isTrim_SENW(rgT):\r\n                    if bDebug: print \"SENW curve ignored.\"\r\n                    bNaturalEdgesSkipped = True\r\n                    continue\r\n\r\n            crv_EdgeDup = rgT.Edge.DuplicateCurve()\r\n\r\n            for isoCrv in isoCrvs:\r\n                rvs = rg.Curve.GetDistancesBetweenCurves(crv_EdgeDup, isoCrv, tolerance=0.1*fSplitTol)\r\n                if not rvs[0]:\r\n                    continue\r\n                if rvs[1] <= fSplitTol:\r\n                    bNearNaturalEdgeSkipped = True\r\n                    break\r\n            else:\r\n                cs_ofLoop.append(crv_EdgeDup)\r\n\r\n        #for c in cs_ofLoop: sc.doc.Objects.AddCurve(c)\r\n        #sc.doc.Views.Redraw(); 1/0\r\n        \r\n        rvs = separate_short_curves_from_others_in_loop(\r\n            cs_ofLoop,\r\n            fTol_MinDistBetweenOpenEnds=fEdgeLen_Min)\r\n        if rvs is None:\r\n            return\r\n        \r\n        cs_toJoin, cs_Short = rvs\r\n        \r\n        if cs_Short:\r\n            rvs = rebuild_short_contiguous_crvs(\r\n                cs_Short, \r\n                fTol_MinDistBetweenOpenEnds=fEdgeLen_Min)\r\n            if rvs:\r\n                cs_toJoin.extend(rvs)\r\n\r\n        if len(cs_toJoin) == 0:\r\n            continue\r\n\r\n        #cs_toJoin = cs_WIP[:]\r\n        \r\n        #250324: Replaced this line with below: fJoinTol = max(2.0*fMaxEdgeTol, 2.0*fSplitTol, fEdgeLen_Min)\r\n        fJoinTol = fEdgeLen_Min\r\n        \r\n        rgCrvs_Joined = rg.Curve.JoinCurves(\r\n            cs_toJoin,\r\n            joinTolerance=fJoinTol)\r\n\r\n        #for c in rgCrvs_Joined: sc.doc.Objects.AddCurve(c)\r\n        #sc.doc.Views.Redraw(); 1/0\r\n\r\n\r\n        for c in rgCrvs_Joined:\r\n            # Open loop is OK if natural edges were skipped.\r\n            if not c.IsClosed:\r\n                if not bNaturalEdgesSkipped and not bNearNaturalEdgeSkipped:\r\n                    if len(cs_toJoin) == 2:\r\n                        print \"Loop may be thin and didn't close.\"\r\n                        return\r\n\r\n                    sc.doc.Objects.AddCurve(c); sc.doc.Views.Redraw()\r\n                    raise ValueError(\"Curve is not closed.\")\r\n\r\n                rv = tryToAdjustCrvEndsToSENW(c, rgSrf_toSplit, tolerance=fJoinTol)\r\n                if rv:\r\n                    c = rv\r\n\r\n            cs_All_loops_for_split.append(c)\r\n\r\n    #for c in cs_All_loops_for_split: sc.doc.Objects.AddCurve(c)\r\n    #sc.doc.Views.Redraw()\r\n    #return\r\n\r\n    rgCrvs_Splitters_WIP = [c.Duplicate() for c in cs_All_loops_for_split]\r\n\r\n    rc = xCurve.getCurvesToSplitSurface(\r\n        rgCrvs_Splitters_WIP, rgSrf_toSplit, fSplitTol)\r\n    if not rc:\r\n        rgB_Out = rgSrf_toSplit.ToBrep()\r\n        if Rhino.RhinoApp.ExeVersion >= 7:\r\n            rgB_Out.Faces[0].PerFaceColor = rgF_In.PerFaceColor\r\n        return rgB_Out\r\n\r\n    for c in rgCrvs_Splitters_WIP: c.Dispose()\r\n    rgCrvs_Splitters_WIP = rc\r\n\r\n    iCt_CrvsWithShortEdgesRemoved = 0\r\n    if fEdgeLen_Min:\r\n        for c in rgCrvs_Splitters_WIP:\r\n            if c.RemoveShortSegments(fEdgeLen_Min):\r\n                iCt_CrvsWithShortEdgesRemoved += 1\r\n\r\n    if bTrimToSegs:\r\n        segs = xCurve.duplicateSegments(rgCrvs_Splitters_WIP)\r\n        if segs:\r\n            for c in rgCrvs_Splitters_WIP: c.Dispose()\r\n            rgCrvs_Splitters_WIP = segs\r\n\r\n    rgCrvs_Splitters = rgCrvs_Splitters_WIP\r\n\r\n    if bOutputTrimmingCrvs: map(sc.doc.Objects.AddCurve, rgCrvs_Splitters)\r\n    #if bDebug and not bOutputTrimmingCrvs: map(sc.doc.Objects.AddCurve, rgCrvs_Splitters)\r\n    #if bDebug: sc.doc.Objects.AddSurface(rgSrf_toSplit)\r\n\r\n    rc = xSurface.splitSurfaceIntoBrep(\r\n        rgSrf_toSplit,\r\n        rgCrvs_Splitters,\r\n        fTolerance=fSplitTol,\r\n        bTryOtherTolsOnFail=True,\r\n        bDebug=bDebug)\r\n    if rc is None:\r\n        if bEcho: print \"Split failed.\"\r\n        return\r\n    rgB_Out = rc\r\n    if Rhino.RhinoApp.ExeVersion >= 7:\r\n        for rgF in rgB_Out.Faces:\r\n            rgF.PerFaceColor = rgF_In.PerFaceColor\r\n    return rgB_Out\r\n\r\n\r\ndef retrimFace(rgFace, **kwargs):\r\n    \"\"\"\r\n    Parameters:\r\n        rgFace,\r\n        rgSrf_Replacement=None, # If None, UnderlyingSurface of BrepFace is used.\r\n        rgCrvs_Splitters_Replacement=None, # If None, 3D curves of rgFace loops are used.\r\n        fSplitTol=sc.doc.ModelAbsoluteTolerance,\r\n        bTrimToSegs=True,\r\n        fEdgeLen_Min,\r\n        bOutputSplitOnFail=False,\r\n        bOutputTrimmingCrvs=False,\r\n        bEcho=True,\r\n        bDebug=False)\r\n    Returns on success:\r\n        rg.Brep\r\n    Returns on fail:\r\n        None\r\n    \"\"\"\r\n\r\n\r\n    def setOpt(key, value): return kwargs[key] if key in kwargs else value\r\n\r\n    rgSrf_Replacement = setOpt('rgSrf_Replacement', None)\r\n    rgCrvs_Splitters_Replacement = setOpt('rgCrvs_Splitters_Replacement', None)\r\n    fSplitTol = setOpt('fSplitTol', sc.doc.ModelAbsoluteTolerance)\r\n    bTrimToSegs = setOpt('bTrimToSegs', True)\r\n    fEdgeLen_Min = setOpt('fEdgeLen_Min', 1.8*sc.doc.ModelAbsoluteTolerance)\r\n    bOutputSplitOnFail = setOpt('bOutputSplitOnFail', False)\r\n    bOutputTrimmingCrvs = setOpt('bOutputTrimmingCrvs', False)\r\n    bEcho = setOpt('bEcho', True)\r\n    bDebug = setOpt('bDebug', False)\r\n\r\n\r\n    def faceAtPoint(rgBrep, pt_onFace, bDebug=False):\r\n        \"\"\"\r\n        Returns face index.\r\n        \"\"\"\r\n        for idxF, rgFace in enumerate(rgBrep.Faces):\r\n            b, u, v = rgFace.ClosestPoint(pt_onFace)\r\n            if not b: raise ValueError(\"ClosestPoint returned None.\")\r\n            ptFaceRel = rgFace.IsPointOnFace(u, v)\r\n            if ptFaceRel == rg.PointFaceRelation.Interior:\r\n                return idxF\r\n        sc.doc.Objects.AddBrep(rgBrep); sc.doc.Views.Redraw()\r\n        raise ValueError(\"Face with point on its interior not found.\")\r\n\r\n\r\n    if bDebug: print \"Function retrimFace():\"\r\n    \r\n    rgFace_In = rgFace\r\n\r\n    rgB_Split = splitFace(\r\n        rgFace=rgFace_In,\r\n        rgSrf_Replacement=rgSrf_Replacement,\r\n        rgCrvs_Splitters_Replacement=rgCrvs_Splitters_Replacement,\r\n        fSplitTol=fSplitTol,\r\n        bTrimToSegs=bTrimToSegs,\r\n        fEdgeLen_Min=fEdgeLen_Min,\r\n        bOutputSplitOnFail=bOutputSplitOnFail,\r\n        bOutputTrimmingCrvs=bOutputTrimmingCrvs,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug)\r\n\r\n    if rgB_Split is None:\r\n        if bEcho: print \"Split rejected/failed.\"\r\n        return\r\n\r\n\r\n    pt_onFace_In = createPoint3dOnInterior(rgFace_In)\r\n    if not pt_onFace_In:\r\n        if bOutputSplitOnFail: sc.doc.Objects.AddBrep(rgB_Split)\r\n        rgB_Split.Dispose()\r\n        return\r\n\r\n\r\n    idxF_Pos = faceAtPoint(rgB_Split, pt_onFace_In)\r\n    if idxF_Pos is None:\r\n        if bOutputSplitOnFail: sc.doc.Objects.AddBrep(rgB_Split)\r\n        rgB_Split.Dispose()\r\n        return\r\n\r\n\r\n    rgBrep_Retrmd = rgB_Split.Faces[idxF_Pos].DuplicateFace(duplicateMeshes=False)\r\n\r\n    rgB_Split.Dispose()\r\n\r\n    return rgBrep_Retrmd\r\n\r\n\r\ndef createModifiedFace(rgFace_In, surfaceFunc, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rgFace_In,\r\n        surfaceFunc,\r\n        bDebug,\r\n    Returns on success:\r\n        tuple(\r\n            rg.Brep,\r\n            float(Surface deviation from input))\r\n        str(Feedback)\r\n    Returns on fail:\r\n        None,\r\n        str(Feedback)\r\n    \"\"\"\r\n\r\n\r\n    rgB_1F_In = rgFace_In.DuplicateFace(duplicateMeshes=True)\r\n    area_In = rgB_1F_In.GetArea()\r\n    rgB_1F_In.Dispose()\r\n    if area_In <= (10.0*sc.doc.ModelAbsoluteTolerance)**2:\r\n        return None, \"Area of face is too small to process.\"\r\n\r\n    rgSrf_In = rgFace_In.UnderlyingSurface()\r\n\r\n\r\n    res, sLog = surfaceFunc(rgSrf_In)\r\n\r\n    if not res:\r\n        return None, sLog\r\n\r\n    ns_Res, srf_dev = res\r\n\r\n    if not ns_Res:\r\n        return None, \"NurbsSurface not created.\"\r\n    if not ns_Res.IsValid:\r\n        return None, \"Invalid Surface geometry after Fit.\"\r\n\r\n    if rgFace_In.IsSurface:\r\n        rgBrep1_BeforeTrim = ns_Res.ToBrep()\r\n        if not rgBrep1_BeforeTrim.IsValid:\r\n            return None, \"Invalid brep geometry after ToBrep.\"\r\n\r\n        # Success.\r\n        return (rgBrep1_BeforeTrim, srf_dev), \"Trim skipped because face IsSurface.\"\r\n\r\n    rgBrep1_AfterTrim = retrimFace(\r\n        rgFace_In,\r\n        rgSrf_Replacement=ns_Res, # If None, UnderlyingSurface of BrepFace is used.\r\n        rgCrvs_Splitters_Replacement=None, # If None, 3D curves of rgFace loops are used.\r\n        fSplitTol=sc.doc.ModelAbsoluteTolerance,\r\n        bTrimToSegs=True,\r\n        fEdgeLen_Min=1.8*sc.doc.ModelAbsoluteTolerance,\r\n        bOutputSplitOnFail=False,\r\n        bOutputTrimmingCrvs=False,\r\n        bDebug=bDebug)\r\n\r\n    if rgBrep1_AfterTrim is None:\r\n        # Check areas.\r\n        rgBrep1_BeforeTrim = ns_Res.ToBrep()\r\n\r\n        area_Out = rgBrep1_BeforeTrim.GetArea()\r\n        area_Diff = abs(area_In-area_Out)\r\n        if area_Diff <= (10.0*sc.doc.ModelAbsoluteTolerance)**2:\r\n            return (rgBrep1_BeforeTrim, srf_dev), \"Face not trimmed because it is almost IsSurface.\"\r\n\r\n        if bDebug:\r\n            if not rgBrep1_BeforeTrim.IsValid:\r\n                return None, \"Invalid brep geometry after ToBrep.  (Split fail).\"\r\n            attrRed = rd.ObjectAttributes()\r\n            attrRed.LayerIndex = sc.doc.Layers.CurrentLayerIndex\r\n            attrRed.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n            attrRed.ObjectColor = Color.Red\r\n            gBrep1 = sc.doc.Objects.AddBrep(rgBrep1_BeforeTrim, attrRed)\r\n            if gBrep1 == Guid.Empty:\r\n                return None, \"Untrimmed monoface brep could not be added to document.\"\r\n            return None, \"Trim fail.  Split brep added.\"\r\n        return None, \"Trim fail.\"\r\n\r\n    if not rgBrep1_AfterTrim.IsValid:\r\n        if bDebug:\r\n            rgBrep1_BeforeTrim = ns_Res.ToBrep()\r\n            if not rgBrep1_BeforeTrim.IsValid:\r\n                return None, \"Invalid brep geometry after ToBrep.  (Split fail).\"\r\n            attrRed = rd.ObjectAttributes()\r\n            attrRed.LayerIndex = sc.doc.Layers.CurrentLayerIndex\r\n            attrRed.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n            attrRed.ObjectColor = Color.Red\r\n            gBrep1 = sc.doc.Objects.AddBrep(rgBrep1_BeforeTrim, attrRed)\r\n            if gBrep1 == Guid.Empty:\r\n                return None, \"Untrimmed monoface brep could not be added to document.\"\r\n        return None, \"Trim fail.\"\r\n\r\n    # Success.\r\n    return (rgBrep1_AfterTrim, srf_dev), None\r\n\r\n\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}