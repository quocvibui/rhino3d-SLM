{
  "source_url": "https://github.com/Mintherbi/EcoLogic/blob/546c53d7732477b1d04e916bcd629ad492b605a6/DEMO/PythonFiles/Venus%20Flower%20Basket/01_Static_Venus-Flower-Basket.py",
  "repo": "Mintherbi/EcoLogic",
  "repo_stars": 1,
  "repo_description": null,
  "license": "unknown",
  "filepath": "DEMO/PythonFiles/Venus Flower Basket/01_Static_Venus-Flower-Basket.py",
  "instruction": "Venus Flower Basket Structure Generator for Grasshopper\nCreates Voronoi-like cellular pattern that can be applied to ANY surface\nPerfect for facades, curved surfaces, or cylindrical forms",
  "code": "\"\"\"\nVenus Flower Basket Structure Generator for Grasshopper\nCreates Voronoi-like cellular pattern that can be applied to ANY surface\nPerfect for facades, curved surfaces, or cylindrical forms\n\nInputs:\n    surface: Surface - Target surface (if None, creates cylinder)\n    height: float - Overall height (for default cylinder)\n    diameter: float - Base diameter (for default cylinder)\n    taper: float - Taper ratio (0-1, for default cylinder)\n    fiber_diameter: float - Base thickness of fibers\n    cell_density_u: int - Number of cells in U direction\n    cell_density_v: int - Number of cells in V direction\n    diagonal_guides: int - Number of diagonal guide lines\n    include_framework: bool - Include diagonal lattice framework\n    framework_thickness: float - Multiplier for framework thickness\n    pattern_type: int - 0=Voronoi only, 1=Framework only, 2=Combined\n    seed: int - Random seed for cell distribution\n\"\"\"\n\nimport Rhino.Geometry as rg\nimport math\nimport random\nimport System\n\n# Default values\nif 'height' not in globals(): height = 100\nif 'diameter' not in globals(): diameter = 150\nif 'taper' not in globals(): taper = 0.1\nif 'fiber_diameter' not in globals(): fiber_diameter = 2.5\nif 'cell_density_u' not in globals(): cell_density_u = 30\nif 'cell_density_v' not in globals(): cell_density_v = 40\nif 'diagonal_guides' not in globals(): diagonal_guides = 15\nif 'include_framework' not in globals(): include_framework = True\nif 'framework_thickness' not in globals(): framework_thickness = 1.5\nif 'pattern_type' not in globals(): pattern_type = 2\nif 'seed' not in globals(): seed = 42\n\n# Set random seed\nrandom.seed(seed)\n\n# Check if custom surface provided, otherwise create cylinder\nif 'surface' not in globals() or surface is None:\n    # Create default tapered cylinder\n    circle = rg.Circle(rg.Plane.WorldXY, diameter/2)\n    cylinder = rg.Cylinder(circle, height)\n    base_surface = cylinder.ToBrep(True, True)\n    if base_surface:\n        target_surface = base_surface.Faces[0]\n    print(\"Using default cylinder surface\")\nelse:\n    # Use provided surface - handle different input types\n    import Rhino\n    import scriptcontext as sc\n    \n    # If it's a GUID, get the actual geometry\n    if isinstance(surface, System.Guid):\n        obj = sc.doc.Objects.Find(surface)\n        if obj:\n            geometry = obj.Geometry\n            if hasattr(geometry, 'Faces'):\n                target_surface = geometry.Faces[0]\n            else:\n                target_surface = geometry\n        else:\n            print(\"ERROR: Could not find surface object\")\n            target_surface = None\n    # If it's a Brep\n    elif hasattr(surface, 'Faces'):\n        target_surface = surface.Faces[0]\n    # If it's already a surface\n    else:\n        target_surface = surface\n    \n    print(\"Using custom surface\")\n\n# Output lists\nvoronoi_fibers = []\nframework_fibers = []\nseed_points = []\n\ndef generate_voronoi_seeds_on_surface(surf, num_u, num_v):\n    \"\"\"Generate seed points distributed across surface UV space with variation\"\"\"\n    seeds = []\n    \n    num_u = int(num_u)\n    num_v = int(num_v)\n    \n    u_domain = surf.Domain(0)\n    v_domain = surf.Domain(1)\n    \n    u_step = (u_domain.Max - u_domain.Min) / float(num_u - 1)\n    v_step = (v_domain.Max - v_domain.Min) / float(num_v - 1)\n    \n    for i in range(num_u):\n        for j in range(num_v):\n            # Base UV coordinates\n            u = u_domain.Min + i * u_step\n            v = v_domain.Min + j * v_step\n            \n            # Add random variation\n            u += random.uniform(-u_step * 0.3, u_step * 0.3)\n            v += random.uniform(-v_step * 0.3, v_step * 0.3)\n            \n            # Clamp to domain\n            u = max(u_domain.Min, min(u_domain.Max, u))\n            v = max(v_domain.Min, min(v_domain.Max, v))\n            \n            # Get 3D point on surface\n            point = surf.PointAt(u, v)\n            seeds.append((u, v, point))\n    \n    return seeds\n\ndef find_voronoi_neighbors(seeds, surf, max_distance_factor=1.6):\n    \"\"\"Find neighboring Voronoi cells and create edges between them\"\"\"\n    edges = []\n    \n    u_domain = surf.Domain(0)\n    v_domain = surf.Domain(1)\n    \n    # Calculate average spacing\n    if len(seeds) > 1:\n        u_range = u_domain.Max - u_domain.Min\n        v_range = v_domain.Max - v_domain.Min\n        avg_u_spacing = u_range / math.sqrt(len(seeds))\n        avg_v_spacing = v_range / math.sqrt(len(seeds))\n    else:\n        return edges\n    \n    for i, seed1 in enumerate(seeds):\n        u1, v1, pt1 = seed1\n        \n        # Find nearby seeds\n        for j, seed2 in enumerate(seeds):\n            if i >= j:  # Avoid duplicates\n                continue\n            \n            u2, v2, pt2 = seed2\n            \n            # Check UV distance first (faster)\n            uv_dist = math.sqrt((u1-u2)**2 + (v1-v2)**2)\n            \n            # Only consider if close in UV space\n            if uv_dist < max(avg_u_spacing, avg_v_spacing) * max_distance_factor:\n                # Calculate 3D distance\n                dist_3d = pt1.DistanceTo(pt2)\n                \n                # Connect if reasonable neighbors\n                edges.append(((u1, v1, pt1), (u2, v2, pt2)))\n    \n    return edges\n\ndef create_curve_on_surface(surf, pt1_uv, pt2_uv, steps=8):\n    \"\"\"Create a curve between two points following the surface\"\"\"\n    u1, v1 = pt1_uv[0], pt1_uv[1]\n    u2, v2 = pt2_uv[0], pt2_uv[1]\n    \n    points = []\n    for i in range(steps + 1):\n        t = i / float(steps)\n        u = u1 + (u2 - u1) * t\n        v = v1 + (v2 - v1) * t\n        point = surf.PointAt(u, v)\n        points.append(point)\n    \n    if len(points) > 1:\n        return rg.Curve.CreateInterpolatedCurve(points, 3)\n    return None\n\n# Generate pattern based on type\nif pattern_type == 0 or pattern_type == 2:\n    # Generate Voronoi seed points\n    print(\"Generating Voronoi seeds...\")\n    seeds = generate_voronoi_seeds_on_surface(target_surface, cell_density_u, cell_density_v)\n    seed_points = [s[2] for s in seeds]\n    \n    print(\"Creating Voronoi edges...\")\n    edges = find_voronoi_neighbors(seeds, target_surface)\n    \n    # Create curves and pipes for Voronoi cell edges\n    print(\"Creating \" + str(len(edges)) + \" fiber geometries...\")\n    for seed1, seed2 in edges:\n        curve = create_curve_on_surface(target_surface, seed1, seed2)\n        \n        if curve:\n            pipe = rg.Brep.CreatePipe(curve, fiber_diameter/2, False, \n                                      rg.PipeCapMode.Round, True, 0.01, 0.01)\n            if pipe:\n                voronoi_fibers.extend(pipe)\n\n# Add diagonal framework guides\nif (pattern_type == 1 or pattern_type == 2) and include_framework:\n    print(\"Creating diagonal framework...\")\n    \n    diagonal_guides = int(diagonal_guides)\n    u_domain = target_surface.Domain(0)\n    v_domain = target_surface.Domain(1)\n    \n    num_steps = max(int(cell_density_v), 20)\n    \n    # Left diagonals (ascending)\n    for diag in range(diagonal_guides):\n        points = []\n        \n        for i in range(num_steps):\n            t = i / float(num_steps - 1)\n            \n            # Move diagonally across UV space\n            u = u_domain.Min + ((diag / float(diagonal_guides)) + t) % 1.0 * (u_domain.Max - u_domain.Min)\n            v = v_domain.Min + t * (v_domain.Max - v_domain.Min)\n            \n            point = target_surface.PointAt(u, v)\n            points.append(point)\n        \n        if len(points) > 1:\n            curve = rg.Curve.CreateInterpolatedCurve(points, 3)\n            if curve:\n                pipe_radius = (fiber_diameter * framework_thickness) / 2\n                pipe = rg.Brep.CreatePipe(curve, pipe_radius, False, \n                                          rg.PipeCapMode.Round, True, 0.01, 0.01)\n                if pipe:\n                    framework_fibers.extend(pipe)\n    \n    # Right diagonals (descending)\n    for diag in range(diagonal_guides):\n        points = []\n        \n        for i in range(num_steps):\n            t = i / float(num_steps - 1)\n            \n            # Move diagonally in opposite direction\n            u = u_domain.Min + ((diag / float(diagonal_guides)) - t) % 1.0 * (u_domain.Max - u_domain.Min)\n            v = v_domain.Min + t * (v_domain.Max - v_domain.Min)\n            \n            point = target_surface.PointAt(u, v)\n            points.append(point)\n        \n        if len(points) > 1:\n            curve = rg.Curve.CreateInterpolatedCurve(points, 3)\n            if curve:\n                pipe_radius = (fiber_diameter * framework_thickness) / 2\n                pipe = rg.Brep.CreatePipe(curve, pipe_radius, False, \n                                          rg.PipeCapMode.Round, True, 0.01, 0.01)\n                if pipe:\n                    framework_fibers.extend(pipe)\n\n# Combine all geometry\nall_fibers = voronoi_fibers + framework_fibers\n\n# Output information\nprint(\"\\nVenus Flower Basket Pattern Generated:\")\nprint(\"  Pattern type: \" + str(['Voronoi only', 'Framework only', 'Combined'][pattern_type]))\nprint(\"  Voronoi cell edges: \" + str(len(voronoi_fibers)))\nprint(\"  Framework guides: \" + str(len(framework_fibers)))\nprint(\"  Total elements: \" + str(len(all_fibers)))\nprint(\"  Seed points: \" + str(len(seed_points)))\n\n# Assign outputs\na = all_fibers  # All combined geometry\nb = voronoi_fibers  # Just Voronoi cells\nc = framework_fibers  # Just diagonal framework\nd = seed_points  # Seed points for visualization",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}