{
  "source_url": "https://discourse.mcneel.com/t/rhino-version-8-sr6-has-broken-my-gh-ironpython-2-script/181238",
  "topic_id": 181238,
  "title": "Rhino Version 8 SR6 has broken my GH IronPython 2 script",
  "question": "Updating to this version of Rhino 8 SR6 (8.6.24101.5001, 2024-04-10) has broken an unchanged and previously working GH IronPython 2 script component.\n\n\nExample attached:\n\nEdit - code retracted",
  "code_blocks": [
    {
      "code": "\"\"\"\nAtaraxia G-Code tool_path Visualizer scripting component\n\"\"\"\n\n__author__ = \"Leo Pedersen\"\n__version__ = \"2024.01.20\"\n\nimport Grasshopper.Kernel as gh\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\n\nsc.doc = ghdoc\ne = gh.GH_RuntimeMessageLevel.Error\n\narcs_centers_points = []\nboolean_feed = []\nfloat_drill_R_retract = 0.0\nfloat_drill_Z_bottom = 0.0\nint_rapid_dashes = 10\nint_rapid_divisions = ((int_rapid_dashes - 1) * 2) + 1\nint_T = 0\npaths = []\npoint_current = rs.CreatePoint(point_start.X,point_start.Y,point_start.Z)\npoint_previous = rs.CreatePoint(point_current.X,point_current.Y,point_current.Z)\nstr_arc_center_mode = \"incremental\"\nstr_mode = \"\"\n\n\ndef Main():\n    global curves_tool_path\n    global point_tool_path_end\n    process_Gcode()\n    curves_tool_path = paths\n    point_tool_path_end = rs.CreatePoint(point_current)\n\ndef process_Gcode():    \n    for i in range(len(cut_Gcode)):\n        #print(\"line \"+str(i))         # uncomment for debugging\n        str_block = str(cut_Gcode[i])\n        set_mode(str_block)\n        \n        # substring block before comments\n        str_block = str_block[:str_block.find(\"(\")]\n        if set_point_current(str_block):\n            global str_mode\n            #print str_mode            # uncomment for debugging\n            if str_mode == \"rapid\":\n                G00_rapid()\n            elif str_mode == \"feed line\":\n                G01_feed()\n            elif str_mode.find(\"arc\") >= 0:\n                G02_G03_arc(str_block)\n            elif str_mode == \"drill\":\n                G81_drill(str_block)\n            elif str_mode == \"peck drill\":\n                G83_peck_drill(str_block)\n\ndef set_mode(str_block):\n    global str_mode\n    # no mode change\n    if str_block.startswith(\"X\"):\n        return\n    elif str_block.startswith(\"Y\"):\n        return\n    elif str_block.startswith(\"Z\"):\n        return\n    elif str_block.startswith(\"A\"):\n        return\n    elif str_block.startswith(\"B\"):\n        return\n    elif str_block.startswith(\"C\"):\n        return\n    elif str_block.startswith(\"(\"):\n        return\n    \n    # set movement mode\n    elif str_block.startswith(\"G00\"):\n        str_mode = \"rapid\"\n    elif str_block.startswith(\"G01\"):\n        str_mode =  \"feed line\"\n    elif str_block.startswith(\"G02\"):\n        str_mode =  \"feed arc clockwise\"\n    elif str_block.startswith(\"G03\"):\n        str_mode =  \"feed arc counterclockwise\"\n    elif str_block.startswith(\"G80\"):\n        str_mode = \"\"\n    elif str_block.startswith(\"G81\"):\n        str_mode = \"drill\"\n    elif str_block.startswith(\"G83\"):\n        str_mode =  \"peck drill\"\n    \n\n    # tool change\n    elif str_block.startswith(\"M06\"):\n        # cutter radius\n        global float_cutter_diameter\n        global float_cutter_radius\n        int_diameter = str_block.find(\"Tool Change \") + 12\n        int_inch = str_block.find('\"')\n        if int_inch != -1:\n            float_cutter_diameter = float(str_block[int_diameter:int_inch])\n        else:\n            int_mm = str_block.find(\"mm\")\n            if int_mm != -1:\n                float_cutter_diameter = float(str_block[int_diameter:int_mm]) * 0.03937\n            else:\n                float_cutter_diameter = 0.125               # tolken diameter for center drills etc.\n        float_cutter_radius = float_cutter_diameter / 2\n    \n    # set arc center mode (works in Mach4 but not UCCNC)\n    elif str_block.startswith(\"G90.1\"):\n        str_arc_center_mode = \"absolute\"\n    elif str_block.startswith(\"G91.1\"):\n        str_arc_center_mode = \"incremental\"\n\ndef set_point_current(str_block):\n    global point_current\n    global point_previous\n    global float_drill_Z_bottom\n    # detect position change for each axis\n    bool_movement = False\n    point_new = rs.CreatePoint(point_current.X,point_current.Y,point_current.Z)\n    int_X_start = str_block.find(\"X\") + 1\n    if int_X_start > 0:\n        bool_movement = True\n        int_X_end = str_block.find(\" \", int_X_start)\n        point_new.X = float(str_block[int_X_start:int_X_end])\n    int_Y_start = str_block.find(\"Y\") + 1\n    if int_Y_start > 0:\n        bool_movement = True\n        int_Y_end = str_block.find(\" \", int_Y_start)\n        point_new.Y = float(str_block[int_Y_start:int_Y_end])\n    int_Z_start = str_block.find(\"Z\") + 1\n    if int_Z_start > 0:\n        bool_movement = True\n        int_Z_end = str_block.find(\" \", int_Z_start)\n        point_new.Z = float(str_block[int_Z_start:int_Z_end])\n        \"\"\"if \"drill\" in str_mode:\n            float_drill_Z_bottom = point_new.Z\n            point_new.Z = point_current.Z\"\"\"\n    \n    int_A_start = str_block.find(\"A\") + 1\n    if int_A_start > 0:\n        bool_movement = True\n    int_B_start = str_block.find(\"B\") + 1\n    if int_B_start > 0:\n        bool_movement = True\n    int_C_start = str_block.find(\"C\") + 1\n    if int_C_start > 0:\n        bool_movement = True\n\n    if bool_movement == False:\n        return False\n    else:\n        point_previous = rs.CreatePoint(point_current.X,point_current.Y,point_current.Z)\n        point_current = rs.CreatePoint(point_new.X,point_new.Y,point_new.Z)\n        return True\n\ndef G00_rapid():\n    global paths\n    global point_current\n    global point_previous\n    if rs.PointCompare(point_previous, point_current):\n        return\n    else:\n        # rapid line\n        line = rs.AddLine(point_previous, point_current)\n        paths.append(line)\n        boolean_feed.append(False)\n        point_previous = rs.CreatePoint(point_current.X,point_current.Y,point_current.Z)\n\ndef G01_feed():\n    global paths\n    global point_current\n    global point_previous\n    if rs.PointCompare(point_previous, point_current):\n        print \"Error - G01 Feed distance 0\"\n    else:\n        line = rs.AddLine(point_previous, point_current)\n        paths.append(line)\n        boolean_feed.append(True)\n        point_previous = rs.CreatePoint(point_current.X,point_current.Y,point_current.Z)\n\n\n\ndef G02_G03_arc(str_block):\n    global paths\n    global point_current\n    global point_previous\n    global str_arc_center_mode\n    \n    point_arc_start = rs.CreatePoint(point_previous.X,point_previous.Y,point_previous.Z)\n    point_arc_end = rs.CreatePoint(point_current.X, point_current.Y, point_current.Z)\n    \n    # find arc center coordinate I\n    int_I_start = str_block.find(\"I\") + 1\n    if int_I_start > 0:\n        int_I_end = str_block.find(\" \", int_I_start)\n        float_arc_I = float(str_block[int_I_start:int_I_end])\n        if str_arc_center_mode == \"incremental\":\n            float_arc_center_X = point_arc_start.X + float_arc_I\n        elif str_arc_center_mode == \"absolute\":\n            float_arc_center_X = float_arc_I\n        else:\n            ghenv.Component.AddRuntimeMessage(e, \"Error: arc center I undefined.\")\n    else:\n         ghenv.Component.AddRuntimeMessage(e, \"Error: can't find I coordinate for arc center point\")\n    \n    # find arc center coordinate J\n    int_J_start = str_block.find(\"J\") + 1\n    if int_J_start > 0:\n        int_J_end = str_block.find(\" \", int_J_start)\n        float_arc_J = float(str_block[int_J_start:int_J_end])\n        if str_arc_center_mode == \"incremental\":\n            float_arc_center_Y = point_arc_start.Y + float_arc_J\n        elif str_arc_center_mode == \"absolute\":\n            float_arc_center_Y = float_arc_J\n        else:\n            ghenv.Component.AddRuntimeMessage(e, \"Error: arc center J undefined.\")\n    else:\n         ghenv.Component.AddRuntimeMessage(e, \"Error: can't find J coordinate for arc center point\")\n    \n    # find arc radius\n    float_arc_center_Z = point_arc_start[2]\n    point_arc_center = rs.CreatePoint(float_arc_center_X, float_arc_center_Y, float_arc_center_Z)\n    float_arc_radius = rs.Distance(point_arc_center, point_arc_start)\n    \n    # find arc plane\n    if str_mode == \"feed arc clockwise\":\n        vector_plane_arc_axis_Z = [0,0,-1]\n    elif str_mode == \"feed arc counterclockwise\":\n        vector_plane_arc_axis_Z = [0,0,1]\n    vector_plane_arc_axis_X = rs.VectorCreate(point_arc_start, point_arc_center)\n    plane_arc_center = rs.PlaneFromNormal(point_arc_center, vector_plane_arc_axis_Z, vector_plane_arc_axis_X)\n    \n    # check if arc is a circle or helix 360Â°\n    if point_arc_end.X == point_arc_start.X and point_arc_end.Y == point_arc_start.Y:\n        feed_arc = rs.AddCircle(plane_arc_center,float_arc_radius)\n    else:\n        # create arc\n        vector_arc_start = rs.VectorCreate(point_arc_start,point_arc_center)\n        vector_arc_end = rs.VectorCreate(point_arc_end,point_arc_center)\n        float_arc_angle = rs.VectorAngle(vector_arc_start,vector_arc_end)\n        float_angle_direction = rs.VectorCrossProduct(vector_arc_start,vector_arc_end)[2]\n        if float_angle_direction < 0 and str_mode == \"feed arc counterclockwise\":\n            float_arc_angle = 360 - float_arc_angle\n        elif float_angle_direction > 0 and str_mode == \"feed arc clockwise\":\n            float_arc_angle = 360 - float_arc_angle\n        feed_arc = rs.AddArc(plane_arc_center, float_arc_radius, float_arc_angle)\n        \n    # check if arc is helical\n    if point_arc_start.Z != point_arc_end.Z:\n        # check for  closed circle\n        if rs.IsCurveClosed(feed_arc):\n            # split circle at start\n            circle_splits = rs.SplitCurve(feed_arc,0.000000001)\n            feed_arc = circle_splits[1]\n        \n        # morph arc into helix\n        # get arc control points\n        points_arc = rs.CurvePoints(feed_arc)\n        float_knots_arc = rs.CurveKnots(feed_arc)\n        int_degree_arc = rs.CurveDegree(feed_arc)\n        float_weights_arc = rs.CurveWeights(feed_arc)\n        float_helix_depthZ = point_arc_end.Z - point_arc_start.Z\n        int_arc_points = len(points_arc)\n        int_stepsZ = int_arc_points - 1\n        float_stepZ = float_helix_depthZ / int_stepsZ\n        points_helix = []\n        float_knots_helix = []\n        float_weights_helix = []\n        # distribute control points through Z axis\n        for i in range(int_arc_points):\n            point_helix = [points_arc[i].X, points_arc[i].Y, points_arc[i].Z + (i * float_stepZ)]\n            points_helix.append(point_helix)\n        feed_arc = rs.AddNurbsCurve(points_helix, float_knots_arc, int_degree_arc, float_weights_arc)\n    \n    paths.append(feed_arc)\n    boolean_feed.append(True)\n    point_previous = rs.CreatePoint(point_current.X,point_current.Y,point_current.Z)\n\n\ndef G81_drill(str_block):\n    global float_cutter_radius\n    global float_drill_R_retract\n    global float_drill_Z_bottom\n    global paths\n    global point_current\n    global point_previous\n    global str_mode\n    \n    # rapid to position at retract height\n    int_R_start = str_block.find(\"R\") + 1\n    if int_R_start > 0:\n        int_R_end = str_block.find(\" \", int_R_start)\n        float_drill_R_retract = float(str_block[int_R_start:int_R_end])\n    float_drill_Z_bottom = point_current.Z\n    point_current.Z = float_drill_R_retract\n    G00_rapid()\n    \n    # drill feed to bottom\n    point_current.Z = float_drill_Z_bottom\n    G01_feed()\n    plane_circle = rs.PlaneFromNormal(point_current, [0,0,1])\n    paths.append(rs.AddCircle(plane_circle, float_cutter_radius))\n    boolean_feed.append(True)\n    \n    # drill rapid retract\n    point_current.Z = float_drill_R_retract\n    G00_rapid()\n\n\ndef G83_peck_drill(str_block):\n    global float_cutter_radius\n    global float_drill_R_retract\n    global float_drill_Z_bottom\n    global float_Q_peck\n    global paths\n    global point_current\n    global point_previous\n    global str_mode\n    \n    #drill rapid to position at retract height\n    int_R_start = str_block.find(\"R\") + 1\n    if int_R_start > 0:\n        int_R_end = str_block.find(\" \", int_R_start)\n        float_drill_R_retract = float(str_block[int_R_start:int_R_end])\n    float_drill_Z_bottom = point_current.Z\n    point_current.Z = float_drill_R_retract\n    G00_rapid()\n    \n    # drill pecking\n    int_Q_start = str_block.find(\"Q\") + 1\n    if int_Q_start > 0:\n        int_Q_end = str_block.find(\" \", int_Q_start)\n        float_Q_peck = float(str_block[int_Q_start:int_Q_end])\n    while point_current.Z >= (float_drill_Z_bottom + float_Q_peck):\n        point_current.Z = point_current.Z - float_Q_peck\n        G01_feed()\n        plane_circle = rs.PlaneFromNormal(point_current, [0,0,1])\n        paths.append(rs.AddCircle(plane_circle, float_cutter_radius))\n        boolean_feed.append(True)\n    point_current.Z = float_drill_Z_bottom\n    G01_feed()\n    plane_circle = rs.PlaneFromNormal(point_current, [0,0,1])\n    paths.append(rs.AddCircle(plane_circle, float_cutter_radius))\n    boolean_feed.append(True)\n\n    # drill rapid retract\n    point_current.Z = float_drill_R_retract\n    G00_rapid()\n\n\n\nMain()",
      "language": "python",
      "author": "James_Parrott",
      "post_number": 3,
      "is_solution": true
    }
  ],
  "tags": [
    "boolean",
    "file-io",
    "geometry",
    "grasshopper",
    "nurbs",
    "python",
    "rhinoscriptsyntax",
    "transformation"
  ],
  "has_accepted_answer": true,
  "category_id": 2,
  "posts_count": 6,
  "views": 199
}