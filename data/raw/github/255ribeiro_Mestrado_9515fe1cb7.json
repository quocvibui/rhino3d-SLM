{
  "source_url": "https://github.com/255ribeiro/Mestrado/blob/07e9939e80a3217834a7cd6707bda1bf5fb46389/python/Algoritmo%20de%20an%C3%A1lise%20grafost%C3%A1tica.py",
  "repo": "255ribeiro/Mestrado",
  "repo_stars": 0,
  "repo_description": "Arquivos da Dissertação de Mestrado",
  "license": "unknown",
  "filepath": "python/Algoritmo de análise grafostática.py",
  "instruction": "Algoritmo de análise grafostática",
  "code": "﻿from __future__ import division\n#importando bibliotecas do Rhinoceros:\n#Rhino Common, rhinoscriptsintax e ghpythonlib\n#import Rhino\nfrom Rhino.Geometry import Point3d, Line, NurbsCurve\nimport rhinoscriptsyntax as rs\nimport ghpythonlib.components as gh\n#import scriptcontext as sc\n\n#ghenv.Component.Params.Output[2].Hidden = True\n\n#função de desenho das cordas\ndef estendeCorda(linha,ponto,indice):\n    pto1 = linha.PointAt(indice)\n    return Line(pto1,ponto)\n# coloca a força externa na posição (nó) e direção de carregamento\ndef Linha_force_extena(no, peso, conv):\n    lincarg = rs.AddLine(no,gh.Move(no,peso*conv*eY)[0])\n    rs.ReverseCurve(lincarg)\n    return lincarg\n#coloca todas as linahs de carga da viga no respectivo nó e direção\ndef Linhas_de_Cargas(viga,cargas, nome):\n    Cargasvigas=[]\n    ptos1 = []\n    nos = rs.PolylineVertices(viga[0])\n    for i in range(len(cargas)):\n        lincarg = Linha_force_extena(nos[i],cargas[i],Escala)\n        linCoe = rs.coerceline(lincarg)\n        pt1 = linCoe.PointAt(.5)\n        pt2 = linCoe.PointAt(0)\n        texto1 = str('%.2f' % cargas[i])\n        texto2 = 'P'+str( i)+'_'+nome\n        Cargasvigas.append(lincarg)\n        ptos1 += [pt1,texto1,corcargas]\n        ptos1 += [pt2,texto2,corcargas]\n    return Cargasvigas, ptos1\n#separa uma viga en seus elementos - barras e nós\ndef Elementos_vigas(viga):\n    #banzo superior v3 -- barras\n    bs = rs.ExplodeCurves(viga[0])\n    #banzo superior v3 -- nos\n    nbs = rs.PolylineVertices(viga[0])\n    #diagonais v3 -- barras\n    dg = rs.ExplodeCurves(viga[1])\n    #diagonais v3 -- nos3\n    ndg = rs.PolylineVertices(viga[1])\n    #banzo inferior v3 -- barras\n    bi = rs.ExplodeCurves(viga[2])\n    #banzo inferior v3 -- nos\n    nbi = rs.PolylineVertices(viga[2])\n    return bs, nbs, dg, ndg, bi, nbi\n#desenha um circulo no nó com a mesma direção do \n#circulo - cirDir - que descreve a direção de seleção das cargas\ndef SentidoNo(cirDir,no,Plano,cirRaio):\n    pOr, eX, eY, eZ = Plano\n    planoAux = rs.PlaneFromNormal(no,eZ)\n    Circulo = rs.AddCircle(planoAux,cirRaio)\n    dir1 =  rs.ClosedCurveOrientation(cirDir,eZ)\n    dir2 =  rs.ClosedCurveOrientation(Circulo,eZ)\n    if  not dir1 == dir2:\n        rs.ReverseCurve(Circulo)\n    return Circulo\n#retorna 1 para tração e -1 para compressão\ndef TraComp(no, forcePF, forceFG, nome):\n    pontoFG = forceFG.PointAt(.5)\n    movevec = rs.AddLine(rs.CurveEndPoint(forcePF),no)\n    movevec = rs.coerceline(movevec)\n    testeLin = gh.Move(rs.coerceline(forcePF),movevec)[0]\n    dist1 = rs.Distance(testeLin.PointAt(0),pontoFG)\n    dist2 = gh.Length(testeLin)\n    dist2 += ( gh.Length(forceFG)/2 )\n    #testando tração\n    if abs(dist1 - dist2) <= Tol:\n        #coloca a nomenclattura do elemento na lista de objetos tracionados\n        Ltrac.append(nome)\n        #retorna 1 para tração\n        return 1\n        \n    #se compressão\n    else:\n       #coloca a nomenclattura do elemento na lista de objetos comprimidos\n       Lcomp.append(nome)\n       #retorna -1 para compressão\n       return -1\n       \n#testa se o elemento suporta as cargas de tração e compressão aplicadas\ndef teste_elemento(nome,carga,fglin):\n    #banzo ou diagonal\n    if nome[0] == 'b':\n        bd=0\n    else:\n        bd= 1\n        \n    # se tracionado\n    if carga >= 0:\n        if abs(carga) < F_adm[bd]:\n            #print nome + 'compressão ok'\n            return corpass\n            \n        else:\n            print nome + '  Falhou na tração'\n            return corfail\n           \n        \n        \n    #se comprimido\n    elif carga < 0:\n        len1 = rs.CurveLength(fglin)\n        rGira = (Areas[1][bd]/Areas[0][bd])**0.5\n        esbelt = len1/rGira\n        if esbelt >= esb_min:\n            T_comp = (3.14**2*Mod_E)/(esbelt**2 * coe_Comp)\n            #print nome + '  Formula de Euler'\n        else:\n            T_comp = (17000 - 0.485 * (esbelt**2))*6894.745\n            #print nome + '  Formula do A.I.S.C.'\n        if (abs(carga)/Areas[0][bd] < T_comp) and (abs(carga) < F_adm[bd]):\n            return corpass\n        else:\n            print nome + '  Falhou na compressão'\n            return corfail\n            \n        \n        \n#reotna os elementos de uma lista que se econtram no no em estudo\ndef elemntos_node(no,eList,nome_lista,nome_viga):\n    Nomes = []\n    elementos = []\n    for K in range(len(eList)) :\n        p1 = rs.CurveEndPoint(eList[K])\n        p2 = rs.CurveStartPoint(eList[K])\n        if rs.PointCompare(no,p1,Tol) or  rs.PointCompare(no,p2,Tol):\n            Nomes.append(nome_lista + str(K) + \"_\" + nome_viga)\n            elementos.append(eList[K])\n    return elementos,Nomes\n# cálculo grafostático dos elementos do shed\ndef Grafo_Shed( viga, F_ext, Plano, dicPF, cirDir, nome_viga):\n    bs3, nbs3, dg3, ndg3, bi3, nbi3 = Elementos_vigas(viga)\n    ptos =[]\n    dicUp2 ={}\n    count_ext =0\n    for i in range(len(ndg3)-1):\n        no = ndg3[i]\n        nomesNo = []\n        elementos =[]\n        #se banzo superior\n        if (i+len(dg3))%2==0:\n           #forças externas\n           if i == 0:\n               #reação RB\n               nomesNo.append('RB')\n               elementos.append(F_ext[count_ext])\n               count_ext += 1\n           else:\n               #cargas\n               f_ext = F_ext[count_ext]\n               p1 = f_ext.PointAt(0)\n               p2 = f_ext.PointAt(1)\n               f_ext = rs.AddLine(p1,p2)\n               nomesNo.append('P'+ str(count_ext)+ '_' + nome_viga)\n               elementos.append(f_ext)\n               count_ext += 1\n           #banzo superior\n           bs_no, nome_bs = elemntos_node(no,bs3,'bs','v3')\n           elementos += bs_no\n           nomesNo += nome_bs\n        else:\n            #forças externas\n            if i == 0:\n                #reação RA\n                nomesNo.append('RA')\n                elementos.append(F_ext[count_ext])\n                count_ext += 1\n            #Banzo inferior\n            bi_no , nome_bi = elemntos_node(no,bi3,'bi','v3')\n            elementos += bi_no\n            nomesNo += nome_bi\n        #diagonais\n        dg_no, nome_dg = elemntos_node(no,dg3,'dg','v3')\n        elementos += dg_no\n        nomesNo += nome_dg\n        nomesNo, elementos, countPF, countCalcular = OrdenaLinhasDeAcao(no,\n        cirDir,elementos,nomesNo, dicPF, Plano)\n        if countCalcular == 2:\n            dicUp, ptos1 = Cremona2(no, nomesNo, elementos, countPF, dicPF)\n        if countCalcular == 1:\n            dicUp, ptos1 = Cremona1(no, nomesNo, elementos, countPF, dicPF)\n        ptos += ptos1\n        dicPF.update(dicUp)\n        dicUp2.update(dicUp)\n    return dicUp2, ptos\n#retorna linas de ação e parametros\ndef OrdenaLinhasDeAcao(no,cirDir,Linhas,nomes, dicPF, Plano):\n    #serando contadores\n    countPF = 0\n    countCalcular = 0\n    #lista do comprimento das Linhas\n    compList = [rs.CurveLength(x) for x in Linhas]\n    cRaio = min(compList)/2\n    #circulo com direção de desenho na direeção de escolha dos vetores\n    Circulo = SentidoNo(cirDir,no,Plano,cRaio)\n    #lista de paramentos paara ordenar\n    paramAux=[]\n    #para cada linha da entrada 3\n    for I in range(len(Linhas)):\n        iCoe = rs.coerceline(Linhas[I])\n        #testa se a força atuante no elemento já e conehcida\n        if nomes[I] in dicPF:\n            #contador de forças conecidas no no\n            countPF += 1\n        else:\n            #contador das forças desconhecidas que atuam no no\n            countCalcular += 1\n        cirCoe = rs.coercecurve(Circulo)\n #lista - inter = [ponto de interseção,parametro no circulo,parametro na linha)]\n        inter = gh.CurveXCurve(cirCoe,iCoe)\n        # coloca parametro de interceção entre Linha e circulo na lista\n        # lista - paramAux - tem a mesma ordem das curvas em Linhas e os nomes\n        paramAux.append(inter[1])\n      \n    #ordenando linhas e nomes de acordo com os parametros -- paramAux\n    Linhas = [x for (y,x) in sorted(zip(paramAux,Linhas), key=lambda pair: pair[0])]\n    nomes  = [x for (y,x) in sorted(zip(paramAux, nomes), key=lambda pair: pair[0])]\n    if (0 < countPF) :\n        while nomes[0] in dicPF:\n            nomes = nomes[1:] + nomes[:1]\n            Linhas = Linhas[1:] + Linhas[:1]\n        while nomes[0] not in dicPF:\n            nomes = nomes[1:] + nomes[:1]\n            Linhas = Linhas[1:] + Linhas[:1]\n    return nomes, Linhas, countPF, countCalcular\n#resolve nó com 2 forças desconhecidas\ndef Cremona2(no, nomes, Linhas, countPF, dicPF):\n    ptos1 = []\n    dicUp ={}\n    for i in range(countPF):\n        if i == 0:\n            Spt = dicPF[nomes[i]].PointAt(0)\n            Ept = dicPF[nomes[i]].PointAt(1)\n        else:\n            if  i == 1:\n                cond1 = rs.PointCompare( dicPF[nomes[i-1]].PointAt(0), \n                dicPF[nomes[i]].PointAt(1), Tol)\n                cond2 =  rs.PointCompare( dicPF[nomes[i-1]].PointAt(0),\n                dicPF[nomes[i]].PointAt(0), Tol)\n                if cond1 or cond2:\n                    pAux3 = Spt\n                    Spt = Ept\n                    Ept = pAux3\n            if rs.PointCompare( Ept , dicPF[nomes[i]].PointAt(1), Tol):\n                ptAux1 = dicPF[nomes[i]].PointAt(1)\n                ptAux2 = dicPF[nomes[i]].PointAt(0)\n            else:\n                ptAux1 = dicPF[nomes[i]].PointAt(0)\n                ptAux2 = dicPF[nomes[i]].PointAt(1)\n            Ept += (ptAux2 - ptAux1)\n    vAux1 = Line( rs.CurveStartPoint(Linhas[-2]), Ept)\n    vAux2 = Line( rs.CurveStartPoint(Linhas[-1]), Spt)\n    F1 = gh.Move( rs.coerceline(Linhas[-2]), vAux1 )[0]\n    F2 = gh.Move( rs.coerceline(Linhas[-1]), vAux2 )[0]\n    inter = gh.LineXLine(F1,F2)[2]\n    F1 = rs.AddLine(Ept, inter)\n    F2= rs.AddLine(inter, Spt)\n    dicUp[ nomes[-2] ] = rs.coerceline(F1)\n    dicUp[ nomes[-1] ] = rs.coerceline(F2)\n    #-cargas e nomenclatura\n    #teste de tração e compressão\n    sin1 = TraComp(no, F1 , rs.coerceline(Linhas[-2]), nomes[-2])\n    sin2 = TraComp(no, F2 , rs.coerceline(Linhas[-1]), nomes[-1])\n    #valores das cargas\n    carga1 = rs.CurveLength(F1)*sin1/Escala\n    carga2 = rs.CurveLength(F2)*sin2/Escala\n    #teste de tensão admissivel\n    cor1 = teste_elemento(nomes[-2],carga1,Linhas[-2])\n    cor2 = teste_elemento(nomes[-1],carga2,Linhas[-1])\n    #nomenclatura do FG\n    txt1 = nomes[-2] + ' = ' + str('%.2f' %carga1)\n    txt2 = nomes[-1] + ' = ' + str('%.2f' %carga2)\n    pt1 = rs.coerceline(Linhas[-2]).PointAt(.5)\n    pt2 = rs.coerceline(Linhas[-1]).PointAt(.5)\n    ptos1 += [pt1, txt1,cor1]\n    ptos1 += [pt2, txt2,cor2]\n    #nimenclatura do PF\n    pt1 = rs.coerceline(F1).PointAt(.5)\n    pt2 = rs.coerceline(F2).PointAt(.5)\n    txt1 = nomes[-2]\n    txt2 = nomes[-1]\n    ptos1 += [pt1, txt1,cor1]\n    ptos1 += [pt2, txt2,cor2]\n    \n    return dicUp, ptos1\n#resolve nó com 1 força1 desconhecida\ndef Cremona1(no, nomes, Linhas, countPF, dicPF):\n    ptos1 = []\n    dicUp ={}\n    for i in range(countPF):\n        if i == 0:\n            Spt = dicPF[nomes[i]].PointAt(0)\n            Ept = dicPF[nomes[i]].PointAt(1)\n        else:\n            if  i == 1:\n                cond1 = rs.PointCompare( dicPF[nomes[i-1]].PointAt(0), \n                dicPF[nomes[i]].PointAt(1), Tol)\n                cond2 =  rs.PointCompare( dicPF[nomes[i-1]].PointAt(0),\n                dicPF[nomes[i]].PointAt(0), Tol)\n                if cond1 or cond2:\n                    pAux3 = Spt\n                    Spt = Ept\n                    Ept = pAux3\n                    \n            if rs.PointCompare( Ept , dicPF[nomes[i]].PointAt(1), Tol):\n                ptAux1 = dicPF[nomes[i]].PointAt(1)\n                ptAux2 = dicPF[nomes[i]].PointAt(0)\n            else:\n                ptAux1 = dicPF[nomes[i]].PointAt(0)\n                ptAux2 = dicPF[nomes[i]].PointAt(1)\n            Ept += (ptAux2 - ptAux1)\n    F1 = rs.AddLine(Ept,Spt)\n    #verificar o paralelismo entre F1 no PF e FG\n    vec1 = rs.VectorCreate(rs.CurveEndPoint(Linhas[-1]),\n    rs.CurveStartPoint(Linhas[-1]))\n    vec2 = rs.VectorCreate(Spt,Ept)\n    if rs.IsVectorParallelTo (vec2, vec1):\n        print '______Paralelismo______'\n    #colovcando F1 no dicionario do PF\n    dicUp[ nomes[-1] ] = rs.coerceline(F1)\n    #-cargas e nomenclatura\n    #teste de tração e compressão\n    sin1 = TraComp(no, F1 , rs.coerceline(Linhas[-1]), nomes[-1])\n    #valores das cargas\n    carga1 = rs.CurveLength(F1)*sin1/Escala\n    #teste de tensão admissivel\n    cor1 = teste_elemento(nomes[-1],carga1,Linhas[-1])\n    #nomenclatura do FG\n    txt1 = nomes[-1] + ' = ' + str('%.2f' %carga1)\n    pt1 = rs.coerceline(Linhas[-1]).PointAt(.5)\n    ptos1 += [pt1, txt1,cor1]\n    #nomenclatura do PF\n    pt1 = rs.coerceline(F1).PointAt(.5)\n    txt1 = nomes[-1]\n    ptos1 += [pt1, txt1,cor1]\n    return dicUp, ptos1\n# PF e funicular\ndef PF_funic(pto_inicial,polo,carreg, nomes_cargas):\n    raios=[]\n    ptos=[]\n    dicUp={}\n    PF =[]\n    resultante =[]\n    funicular =[]\n    ## -- Desenhando o poligono de forças -- ##\n    pAux = rs.coerce3dpoint(pto_inicial)\n    # polo do PF do Shed\n    polo = rs.coerce3dpoint(polo)\n    #primeiro raio polar\n    raios.append(Line(polo,pAux))\n    ptos += [polo, 'polo', cornode]\n    #desenhando carregamentos no PF e os raios polares\n    for i in range(len(carreg)):\n        v = carreg[i]\n        #carregamento no FG\n        vAux1 = rs.coerceline(v)\n        #vetor auxiliar para mover o carregamento para a posição de soma\n        vAux2 = pAux - v.PointAt(0)\n        # carregamento no PF\n        vAux3 = gh.Move(vAux1,vAux2)[0]\n        #Nomenclatura - texto da reação Pi\n        nome = nomes_cargas[i]\n        #Nomenclatua - posição do texto\n        txtPt = vAux3.PointAt(.5)\n        # Nomenclatura do PF\n        ptos += [txtPt, nome, corcargas]\n        # colocando carregamento na lista do PF\n        PF.append(vAux3)\n        # olocando carregamento no dicionario do PF\n        dicUp[nome]=vAux3\n        # ponto da posição de soma para o proximo carregamento\n        pAux = vAux3.PointAt(1)\n        #desenhando raio polar\n        r = Line(polo,pAux)\n        #colocando raio polar na lista de raios\n        raios.append(r)\n    #desenhando a resultante no PF\n    #ponto final da resultante R1\n    pto_R1 = pAux\n    #resultante r1 no PF\n    R1PF =Line(rs.coerce3dpoint(pto_inicial),pto_R1)\n    #colocando R1 na lista de resultantes\n    resultante.append(R1PF)\n    #R1 no dicionario do PF\n    dicUp['R1']= R1PF\n    #Desenhando o funicular\n    for i in range(len(raios)):\n        r = rs.coerceline(raios[i])\n        #caso da primeira corda\n        if i == 0:\n            pAux = (rs.coerceline(carreg[0]).PointAt(0))\n            vAux1 = Line(r.PointAt(0),pAux)\n            corda = gh.Move(r,vAux1)[0]\n            corda = rs.coerceline(corda)\n        #cordas intermediarias\n        elif i < len(raios)-1:\n            vAux1 = Line(r.PointAt(1),pAux)\n            crdAux = gh.Move(r,vAux1)[0]\n            crdAux = rs.coerceline(crdAux)\n            pAux2 = pAux\n            pAux = gh.LineXLine(crdAux,carreg[i])[-1]\n            corda = Line(pAux2,pAux)\n        #caso da ultima corda\n        else:\n            vAux1 = Line(r.PointAt(1),pAux)\n            corda = gh.Move(r,vAux1)[0]\n            corda = rs.coerceline(corda)\n        #adicionando corda na lista do funicular\n        funicular.append(corda)\n    #resesenhando as cordas extremas\n    return dicUp, raios, funicular, resultante, ptos\ndef Grafo_Viga(viga, F_ext, Plano,dicPF,cirDir,Bconect,reac,nome_viga):\n    bs, nbs, dg, ndg, bi, nbi = Elementos_vigas(viga)\n    Bconect = rs.ExplodeCurves(Bconect)\n    ptos =[]\n    dicUp2 ={}\n    for i in range(len(ndg)-1):\n        no = ndg[i]\n        nomesNo = []\n        elementos =[]\n        j = i//2\n        #se banzo superior\n        if i%2 == 1:\n            #Força extena\n            f_ext = F_ext[j]\n            p1 = f_ext.PointAt(0)\n            p2 = f_ext.PointAt(1)\n            f_ext = rs.AddLine(p1,p2)\n            nomesNo.append('P'+ str(j)+ '_' + nome_viga)\n            elementos.append(f_ext)\n            #banzo superior\n            nomesNo.append('bs'+ str(j)+ '_' + nome_viga)\n            elementos.append(bs[j])\n            if not j==0:\n                nomesNo.append('bs'+ str(j-1)+ '_' + nome_viga)\n                elementos.append(bs[j-1])\n            #diagonais\n            nomesNo.append('dg'+ str(i-1)+ '_' + nome_viga)\n            elementos.append(dg[i-1])\n            nomesNo.append('dg'+ str(i)+ '_' + nome_viga)\n            elementos.append(dg[i])\n        #se banzo inferior\n        elif i%2 == 0:\n            if i == 0:\n                #reação\n                p1 = reac.PointAt(0)\n                p2 = reac.PointAt(1)\n                reac = rs.AddLine(p1,p2)\n                nome_reac = 'R'+ '_' + nome_viga\n                nomesNo.append(nome_reac)\n                elementos.append(reac)\n            if not j == 0:\n                #diagonal anterior\n                nomesNo.append('dg'+ str(i-1)+ '_' + nome_viga)\n                elementos.append(dg[i-1])\n                #banzo inferior anterior\n                nomesNo.append('bi'+ str(j-1)+ '_' + nome_viga)\n                elementos.append(bi[j-1])\n            #diagonal posterior\n            nomesNo.append('dg'+ str(i)+ '_' + nome_viga)\n            elementos.append(dg[i])\n            #banzo inferior posterior\n            nomesNo.append('bi'+ str(j)+ '_' + nome_viga)\n            elementos.append(bi[j])\n        #ordenar linhas de ação em torno do nó\n        nomesNo, elementos, countPF, countCalcular = OrdenaLinhasDeAcao(no,\n        cirDir,elementos,nomesNo, dicPF, Plano)\n        if countCalcular == 2:\n            dicUp, ptos1 = Cremona2(no, nomesNo, elementos, countPF, dicPF)\n        if countCalcular == 1:\n            dicUp, ptos1 = Cremona1(no, nomesNo, elementos, countPF, dicPF)\n        ptos += ptos1\n        dicPF.update(dicUp)\n        dicUp2.update(dicUp)\n    ####------conector------####\n    # ùltimo no do banzo superior\n    no = nbs[-1]\n    #elementos do conector\n    elementos, nomesNo = elemntos_node(no,Bconect,'bc','c')\n    #ùltimo elemento do banzo superior\n    elementos.append(bs[-1])\n    nomesNo.append('bs'+str(len(bs)-1)+'_'+nome_viga)\n    #Força externa\n    f_ext = F_ext[len(F_ext)-1]\n    p1 = f_ext.PointAt(0)\n    p2 = f_ext.PointAt(1)\n    f_ext = rs.AddLine(p1,p2)\n    nomesNo.append('P'+ str(len(F_ext)-1)+ '_' + nome_viga)\n    elementos.append(f_ext)\n    #diagonal\n    if len(dg)%2 == 1:\n        elementos.append(dg[-1])\n        nomesNo.append('dg'+str(len(dg)-1)+'_'+nome_viga)\n    nomesNo, elementos, countPF, countCalcular = OrdenaLinhasDeAcao(no,cirDir,\n    elementos,nomesNo, dicPF, Plano)\n    dicUp, ptos1 = Cremona2(no, nomesNo, elementos, countPF, dicPF)\n    ptos += ptos1\n    dicPF.update(dicUp)\n    dicUp2.update(dicUp)\n    return dicUp2, ptos\n\n###---MAIN---###\n#listas vazias para as saidas\n\ntxt_pontos = [] # listas com pontos de inseção, texto e cores para vizualiação\nLinhas_de_Carga=[] # o carregamento na vifa\nraios_1=[] # raios polares do Shed\ncarreg_1 = [] # carregamento e reações do Shed\nFG1=[] # forma greométria do shed\nPF1 = [] # Polígono de forças  do Shed\nfunicular_1 =[] # funicilar do Shed\nresultante_1 =[] #resultante do Shed\ndic_1 ={} #dicionário do PF do Shed\nraios_2=[] # raios polares das vigas v1 e v2\ncarreg_2 = [] # carregamento das vigas v1 e v2\ncarreg_v1 = []\ncarreg_v2 = []\nFG2=[] # forma greométria das vigas v1 e v2\nPF2 = [] # Polígono de forças  das vigas v1 e v2\nfunicular_2 =[] # funicilar das vigas v1 e v2\nresultante_2 =[] #resultante das vigas v1 e v2\ndic_2 ={} #dicionário do PF das vigas v1 e v2\nLtrac = [] #lista de elementos tracionados\nLcomp = [] #lista de elementos comprimidos\n\n#variáveis globais com as cores de vizualização dos textos\n\ncornode = '0,0,255' #cor para pontos e nos\ncorcargas = '0,255,255'# cor para o textos das cargas\ncorpass = '0,255,100' #cor para o textos das barras que resitem à tensão admissivel\ncorfail = '255,0,255' #cor para o textos das barras que NÂO resitem à tensão admissivel\n\n#tolerancia \nTol = 0.0001\n#caso nãp seja definida uma escala\nif not Escala:\n    Escala = .0001 #assume-se a escala de 1/10000\nEscala\n#caso não seja fornecido um Plano de trabalho\nif not Plano:\n    Plano = rs.WorldXYPlane()# assume-se o palno xy\n#decompoe o plano de trabalho nos componentes Origem e os eixos xyz\npOr, eX, eY, eZ = Plano\n#separando cargas por vigas\nP_v1, P_v2, P_v3 = Cargas\n\n# se a tensão admissivel não é definida\nif not T_adm:\n    T_adm = 150*10**6 #assume-se 150 MPa\nif not coe_Trac: # se o coeficiente de segurança para tração não é definido\n    coe_Trac = 2 # assume-se 2\nif not coe_Comp: # se o coeficiente de segurança para compressão não é definido\n    coe_Comp = 2 # assume-se 2\nif not Mod_E: # se o modulo de elasticidade não foi informado\n    Mod_E = 200*10**9 #assume-se 200 GPa\nif not esb_min: # se a esbeltez minima não foi informada\n    esb_min = 105 # assume-se 105\n    \n# lista com as forças limites para banzos e diagonais\nF_adm = [(x*T_adm)/coe_Trac for x in Areas[0]]\n#Separando os eixos em listas\n#conector\nConector = Eixos[-2:]\n#vigas\nv1 = Eixos[:3]\nv2 = Eixos[3:6]\nv3 =  Eixos[6:9]\n#apoios\nApoios = [rs.CurveStartPoint(v1[2]),rs.CurveStartPoint(v2[2])]\n#Eixo de Simetria do conector\nEixoSimetria = Conector[0]\nBconect = Conector[1]\nEixoSimetria =  rs.coerceline(EixoSimetria)\nptX = gh.EndPoints(EixoSimetria)\n# vareável booleana para iniciar análise\nif Iniciar_Analise == None:\n    Iniciar_Analise = True # calcula tensões para True ou none\nif Iniciar_Analise: #não calcula para False\n    #Cargas na viga v1\n    C_v1, ptC_v1 = Linhas_de_Cargas(v1,P_v1,'V1')\n    Linhas_de_Carga += C_v1\n    txt_pontos += ptC_v1\n    #Cargas na viga v2\n    C_v2, ptC_v2 = Linhas_de_Cargas(v2,P_v2, 'V2')\n    Linhas_de_Carga += C_v2\n    txt_pontos += ptC_v2\n    #Cargas na viga v3\n    C_v3, ptC_v3 = Linhas_de_Cargas(v3,P_v3, 'V3')\n    Linhas_de_Carga += C_v3\n    txt_pontos += ptC_v3\n    #determinando sendido de seleção dos elementos\n    cirDir = rs.AddCircle3Pt(Apoios[0],ptX[0],Apoios[1])\n    #### --- Cálculo do Shed --- ####\n    print '####-------------------Shed----------------------####'\n    bi3 = v3[2]\n    pto = rs.CurveStartPoint(bi3)\n    if not pto_base_FG1:\n        pto_base_FG1 = pto\n    pto_base_FG1 = rs.coerce3dpoint(pto_base_FG1)\n    vAux1 = Line(pto,pto_base_FG1)\n    for i in range(len(v3)):\n        v3[i] = gh.Move(rs.coercegeometry(v3[i]),vAux1)[0]\n    for i in range(len(C_v3)):\n       C_aux = gh.Move(rs.coerceline(C_v3[i]),vAux1)[0]\n       carreg_1.append(C_aux)\n    FG1 = v3 + carreg_1\n    carreg_1.pop(0)\n    nomes_cargas =[]\n    for i in range(len(carreg_1)):\n        nome = \"P\" + str(i+1) + '_v3'\n        nomes_cargas.append(nome)\n    dic_1, raios_1, funicular_1, resultante_1, ptos = PF_funic(pto_inicial_1,\n    polo_1,carreg_1, nomes_cargas)\n    for i in dic_1.keys():\n        PF1.append(dic_1[i])\n    txt_pontos += ptos\n    # - desenhando a resultante no FG\n    # ponto de intecessão entre a primeira e ultuma corda\n    pAux = gh.LineXLine(funicular_1[0],funicular_1[-1])[-1]\n    #resesenhando as cordas extremas\n    funicular_1[0] = estendeCorda(funicular_1[0],pAux,0)\n    funicular_1[-1] = estendeCorda(funicular_1[-1],pAux,1)\n    #vetor auxiliar para mover R1PF para o FG\n    vAux1 = Line(dic_1['R1'].PointAt(.5),pAux)\n    #R1FG R1 no FG\n    R1FG = gh.Move(dic_1['R1'],vAux1)[0]\n    #coloca R1FG na lista de resultates_1\n    resultante_1.append(R1FG)\n    # separando a viga v3 em seus elementos - \n    #bs3 = lista de barras do banzo supeiro\n    #nbs3 = lista de nós do bazo superior\n    #dg3 e ndg3 para diagoains e bi3 e nbi3 para banzo inferior\n    bs3, nbs3, dg3, ndg3, bi3, nbi3 = Elementos_vigas(v3)\n    raAux = bi3[0]\n    rbAux = bs3[0]\n    pAux1 = nbi3[0]\n    pAux2 = nbs3[0]\n    #caso o numero de diagonais seja par\n    if len(dg3)%2 == 0:\n        raAux = rs.coerceline(raAux)\n        #ponto de interseção das resultantes\n        pt_inter = gh.LineXLine(R1FG,raAux)[-1]\n        resultante_1.append(pt_inter)\n        #resultante entre banzo e diagonal\n        rbAux = rs.AddLine(pAux2,pt_inter)\n        rbAux = rs.coerceline(rbAux)\n        #vetor auxiliar para deslocamento gh.Move\n        pto_R1 = dic_1['R1'].PointAt(1)\n        vAux1 = rs.AddLine(pAux1,pto_R1)\n        vAux1 = rs.coerceline(vAux1)\n        #vetor auxiliar para deslocamento gh.Move\n        vAux2 = rs.AddLine(pAux2,pto_inicial_1)\n        vAux2 = rs.coerceline(vAux2)\n        #movendo linhas do FG para o PF\n        raAux = gh.Move(raAux,vAux1)[0]\n        rbAux = gh.Move(rbAux,vAux2)[0]\n        #ponto de interseção das reações no PF\n        pto_PF = gh.LineXLine(raAux,rbAux)[-1]\n        # - desenhando reação RA no PF\n        RA = rs.AddLine(pto_R1,pto_PF)\n        \n        PF1.append(rs.coerceline(RA))\n        #dicionario do PF\n        dic_1['RA'] = rs.coerceline(RA)\n        #texto - ponto de inserção\n        p_txt = rs.coerceline(RA).PointAt(.5)\n        #texto\n        txt_pontos += [p_txt,'RA',corcargas]\n        # - desenhando  reaçãao RB no PF\n        RB = rs.AddLine(pto_PF, pto_inicial_1)\n        PF1.append(rs.coerceline(RB))\n        #dicionario do PF\n        dic_1['RB'] = rs.coerceline(RB)\n        #texto\n        p_txt = rs.coerceline(RB).PointAt(.5)\n        txt_pontos += [p_txt,'RB',corcargas]\n        # - desenhando reação RA no FG\n        vAux1 = rs.AddLine(rs.CurveEndPoint(RA),nbi3[0])\n        RAFG = gh.Move(rs.coerceline(RA),rs.coerceline(vAux1))[0]\n        p_txt = RAFG.PointAt(.5)\n        carga1 = rs.CurveLength(RA)*1/Escala\n        texto = 'RA = ' + str('%.2f' % carga1)\n        txt_pontos += [p_txt,texto,corcargas]\n        FG1.append(rs.coerceline(RAFG))\n        # - desenhando reação RB no FG\n        vAux2 = rs.AddLine(rs.CurveStartPoint(RB),nbs3[0])\n        RBFG = gh.Move(rs.coerceline(RB),rs.coerceline(vAux2))[0]\n        p_txt = RBFG.PointAt(.5)\n        carga2 = rs.CurveLength(RB)-1/Escala\n        texto = 'RB = ' + str('%.2f' % carga2)\n        txt_pontos += [p_txt,texto,corcargas]\n        FG1.append(rs.coerceline(RBFG))\n        # - tensão em bi3[0]\n        bi0PF = rs.CopyObjects(RA)\n        rs.ReverseCurve(bi0PF)\n        bi0PF = rs.coerceline(bi0PF)\n        #dicionario\n        dic_1['bi0_v3'] = bi0PF\n        #textos\n        carga1=-1*carga1\n        cor1 = teste_elemento(texto,carga1,bi3[0])\n        p_txt = rs.coerceline(bi0PF).PointAt(.75)\n        txt_pontos += [p_txt,'bi0_v3',cor1]\n        p_txt = rs.coerceline(bi3[0]).PointAt(.5)\n        texto = 'bi0_v3 = ' + str('%.2f' % (carga1))\n        txt_pontos += [p_txt,texto,cor1]\n        #carregamento no nó[0]\n        carreg_1.insert(0,RB)\n        #coloca nomenclatura do elemento na lista de elementos comprimidos\n        Lcomp.append('bi0_v3')\n    # caso o numero de diagonais seja impar\n    else:\n        pto_R1 = dic_1['R1'].PointAt(1)\n        rbAux = rs.coerceline(rbAux)\n        pt_inter = gh.LineXLine(R1FG,rbAux)[-1]\n        resultante_1.append(pt_inter)\n        #resultante entre banzo e diagonal\n        raAux = rs.AddLine(pAux1,pt_inter)\n        raAux = rs.coerceline(raAux)\n        #vetor auxiliar para deslocamento gh.Move\n        vAux1 = rs.AddLine(pAux1,pto_R1)\n        vAux1 = rs.coerceline(vAux1)\n        #vetor auxiliar para deslocamento gh.Move\n        vAux2 = rs.AddLine(pAux2,pto_inicial_1)\n        vAux2 = rs.coerceline(vAux2)\n        #movendo linhas do FG para o PF\n        raAux = gh.Move(raAux,vAux1)[0]\n        rbAux = gh.Move(rbAux,vAux2)[0]\n        #ponto de interseção das reações no PF\n        pto_PF = gh.LineXLine(raAux,rbAux)[-1]\n        # - desenhando reação RA no PF\n        RA = rs.AddLine(pto_R1,pto_PF)\n        PF1.append(rs.coerceline(RA))\n        #dicionario do PF\n        dic_1['RA'] = rs.coerceline(RA)\n        #texto - ponto de inserção\n        p_txt = rs.coerceline(RA).PointAt(.5)\n        #texto\n        txt_pontos += [p_txt,'RA',corcargas]\n        # - desenhando  reaçãao RB no PF\n        RB = rs.AddLine(pto_PF, pto_inicial_1)\n        PF1.append(rs.coerceline(RB))\n        #dicionario do PF\n        dic_1['RB'] = rs.coerceline(RB)\n        #texto\n        p_txt = rs.coerceline(RB).PointAt(.5)\n        txt_pontos += [p_txt,'RB',corcargas]\n        # - desenhando reação RA no FG\n        vAux1 = rs.AddLine(rs.CurveEndPoint(RA),nbi3[0])\n        RAFG = gh.Move(rs.coerceline(RA),rs.coerceline(vAux1))[0]\n        p_txt = RAFG.PointAt(.5)\n        carga1 = rs.CurveLength(RA)*1/Escala\n        texto = 'RA = ' + str('%.2f' % carga1)\n        txt_pontos += [p_txt,texto,corcargas]\n        FG1.append(rs.coerceline(RAFG))\n        # - desenhando reação RB no FG\n        vAux2 = rs.AddLine(rs.CurveStartPoint(RB),nbs3[0])\n        RBFG = gh.Move(rs.coerceline(RB),rs.coerceline(vAux2))[0]\n        p_txt = RBFG.PointAt(.5)\n        carga2 = rs.CurveLength(RB)*-1/Escala\n        texto = 'RB = ' + str('%.2f' % carga2)\n        txt_pontos += [p_txt,texto,corcargas]\n        FG1.append(rs.coerceline(RBFG))\n        # - tensão em bs3[0]\n        bs0PF = rs.CopyObjects(RB)\n        rs.ReverseCurve(bs0PF)\n        bs0PF = rs.coerceline(bs0PF)\n        #dicionario\n        dic_1['bs0_v3'] = bs0PF\n        #textos\n        carga2 = -1*carga2\n        cor1 = teste_elemento('bs0_v3',carga2,bs3[0])\n        p_txt = rs.coerceline(bs0PF).PointAt(.75)\n        txt_pontos += [p_txt,'bs0_v3',cor1]\n        p_txt = rs.coerceline(bs3[0]).PointAt(.5)\n        texto = 'bs0_v3 = ' + str('%.2f' % (carga2))\n        txt_pontos += [p_txt,texto,cor1]\n        #carregamento no nó[0]\n        carreg_1.insert(0,RA)\n        #coloca nomenclatura do elemento na lista de elementos tracionados\n        Ltrac.append('bi0_v3')\n    #calcula as forças nas barras da treliça do shed\n    dicUp, ptos = Grafo_Shed( v3, carreg_1, Plano, dic_1, cirDir, 'v3')\n    #atualizando nomenclatura\n    txt_pontos += ptos\n    #atualizando dicionário\n    dic_1.update(dicUp)\n    #Atualizando elementos na saida PF1\n    for i in dicUp.keys():\n        PF1.append(dicUp[i])\n#####---------- vigas v1 e v2 ----------####\n    # força F0 -- P0_v3 + RB\n    fAux = gh.FlipCurve( dic_1['RB'])[0]\n    p1 = fAux.PointAt(1)\n    p2 = rs.CurveStartPoint(C_v3[0])\n    vAux = Line(p1,p2)\n    fAux =  gh.Move(fAux,vAux)[0]\n    p1 = fAux.PointAt(0)\n    p2= rs.CurveEndPoint(C_v3[0])\n    F0 = rs.AddLine(p1,p2)\n    F0 = rs.CopyObjects(F0,(p2-p1))\n    # força C_v2[-1] -- C_v2[-1] + RA\n    fAux = gh.FlipCurve( dic_1['RA'])[0]\n    p1 = fAux.PointAt(1)\n    p2 = rs.CurveStartPoint(C_v2[-1])\n    bi1 = v1[2]\n    p2 = rs.CurveStartPoint(C_v2[-1])\n    vAux = Line(p1,p2)\n    fAux =  gh.Move(fAux,vAux)[0]\n    p1 = fAux.PointAt(0)\n    p2= rs.CurveEndPoint(C_v2[-1])\n    C_v2[-1] = rs.AddLine(p1,p2)\n    #Movendo FG2\n    pto = rs.CurveStartPoint(bi1)\n    if not pto_base_FG2:\n        pto_base_FG2 = pto\n    ptoMove = rs.coerce3dpoint(pto_base_FG2)\n    vAux1 = Line(pto,ptoMove)\n    for i in range(len(v1)):\n        v1[i] = gh.Move(rs.coercegeometry(v1[i]),vAux1)[0]\n    for i in range(len(v2)):\n        v2[i] = gh.Move(rs.coercegeometry(v2[i]),vAux1)[0]\n    for i in range(len(C_v1)):\n       C_aux = gh.Move(rs.coerceline(C_v1[i]),vAux1)[0]\n       carreg_v1.append(C_aux)\n    for i in range(len(C_v2)):\n       C_aux = gh.Move(rs.coerceline(C_v2[i]),vAux1)[0]\n       carreg_v2.append(C_aux)\n    for i in range(len(Conector)):\n        Conector[i] = gh.Move(rs.coercegeometry(Conector[i]),vAux1)[0]\n    F0 = gh.Move(rs.coerceline(F0), vAux1)[0]\n    #carregamento na ordem de seleção das forças\n    carreg_2 = carreg_v1 + [F0] + carreg_v2[::-1] #L[::-1] ==inverso da lista L\n    FG2 = v1 + v2 + Conector + carreg_2\n    nomes_cargas_v1 =[]\n    for i in range(len(carreg_v1)):\n        nome = \"P\" + str(i) + '_v1'\n        nomes_cargas_v1.append(nome)\n    nomes_cargas_v2 =[]\n    for i in range(len(carreg_v2)):\n        nome = \"P\" + str(i) + '_v2'\n        nomes_cargas_v2.append(nome)\n    nomes_cargas_2 = nomes_cargas_v1 + ['F0'] + nomes_cargas_v2[::-1]\n    dic_2, raios_2, funicular_2, resultante_2, ptos = PF_funic(pto_inicial_2\n    ,polo_2,carreg_2, nomes_cargas_2)\n    for i in dic_2.keys():\n        PF2.append(dic_2[i])\n    txt_pontos += ptos\n    #calculo das reações\n    bi1 = v1[2]\n    pto1 = rs.CurveStartPoint(bi1)\n    bi2 = v2[2]\n    pto2 = rs.CurveStartPoint(bi2)\n    #Eixo reação R_v1\n    L1 = Linha_force_extena(pto1, 1,1)\n    #Eixo reação R_v2\n    L2 = Linha_force_extena(pto2, 1,1)\n    pAux1 = gh.LineXLine(funicular_2[0],rs.coerceline(L1))[-1]\n    pAux2 = gh.LineXLine(funicular_2[-1],rs.coerceline(L2))[-1]\n    #resesenhando as cordas extremas\n    funicular_2[0] = estendeCorda(funicular_2[0],pAux1,0)\n    funicular_2[-1] = estendeCorda(funicular_2[-1],pAux2,1)\n    funicAux = rs.AddLine(pAux1,pAux2)\n    #fechando o funicular\n    funicular_2.append(funicAux)\n    vAux = rs.AddLine(pAux1,polo_2)\n    #Movendo corda que fecha o funicular para o PF\n    raio_aux = gh.Move(rs.coerceline(funicAux),rs.coerceline(vAux))[0]\n    #dividindo a resultante nas reações\n    pAux = gh.LineXLine(raio_aux,resultante_2[0])[-1]\n    resultante_2.append(pAux)\n    #desenhando o raio polar\n    raio_aux = rs.AddLine(polo_2,pAux)\n    #colocando o raio polar na lista de sarida raios_2\n    raios_2.append(raio_aux)\n    #reação R_V1 no PF\n    R_v1 = rs.AddLine(pAux,pto_inicial_2)\n    #reação R_V2 no PF\n    pAux3 = dic_2['P0_v2'].PointAt(1)\n    R_v2 = rs.AddLine( pAux3, pAux )\n    #Colocando reações no dicionário do PF\n    dic_2['R_v1'] = rs.coerceline(R_v1)\n    dic_2['R_v2'] = rs.coerceline(R_v2)\n    #Colocando reações na lista de saida resultante_2\n    resultante_2 += [pAux3,R_v1,R_v2]\n    #movendo reações para o FG\n    vAux1 = rs.AddLine(pto_inicial_2,pto1)\n    vAux2 = rs.AddLine(pAux,pto2)\n    fgR_v1 = gh.Move(rs.coerceline(R_v1),rs.coerceline(vAux1))[0]\n    fgR_v2 = gh.Move(rs.coerceline(R_v2),rs.coerceline(vAux2))[0]\n    #Nomenclatura R_v1\n    carga1 = gh.Length(fgR_v1)*1/Escala\n    p_txt = fgR_v1.PointAt(.5)\n    texto = 'R_v1 = ' + str('%.2f' % carga1)\n    txt_pontos += [p_txt,texto,corcargas]\n    #Nomenclatura R_v2\n    carga2 = gh.Length(fgR_v2)*1/Escala\n    p_txt = fgR_v2.PointAt(.5)\n    texto = 'R_v2 = ' + str('%.2f' % carga2)\n    txt_pontos += [p_txt,texto,corcargas]\n    #Colocando reações na lista de saida do FG\n    FG2.append(fgR_v1)\n    FG2.append(fgR_v2)\n    print '####--------------------V1-----------------------####'\n    dicUp, ptos = Grafo_Viga( v1, carreg_v1, Plano, dic_2, cirDir,\n    Conector[1], fgR_v1, 'v1')\n    txt_pontos += ptos\n    #atualizando dicionário\n    dic_2.update(dicUp)\n    #Atualizando elementos na saida PF2\n    for i in dicUp.keys():\n        PF2.append(dicUp[i])\n    print '####--------------------V2-----------------------####'\n    dicUp, ptos = Grafo_Viga( v2, carreg_v2, Plano, dic_2, cirDir,\n    Conector[1], fgR_v2, 'v2')\n    txt_pontos += ptos\n    #atualizando dicionário\n    dic_2.update(dicUp)\n    #Atualizando elementos na saida PF2\n    for i in dicUp.keys():\n        PF2.append(dicUp[i])\n    print '####--------------Eixo do Conector---------------####'\n    nos = rs.PolylineVertices(Conector[1])\n    no = nos[0]\n    conector = rs.ExplodeCurves(Conector[1]) \n    conector.append(rs.AddLine(no,nos[2]))\n    #elementos do conector\n    elementos, nomesNo = elemntos_node(no,conector,'bc','c')\n    #Força externa\n    fgF0 = (rs.AddLine(F0.PointAt(0),F0.PointAt(1)))\n    nomesNo, elementos, countPF, countCalcular = OrdenaLinhasDeAcao(no,cirDir,\n    elementos,nomesNo, dic_2, Plano)\n    nomesNo.insert(1,'F0')\n    elementos.insert(1,fgF0)\n    dicUp, ptos1 = Cremona1(no, nomesNo, elementos, countPF+1, dic_2)\n    txt_pontos += ptos1\n    dic_2.update(dicUp)\n    #Atualizando elementos na saida PF2\n    for i in dicUp.keys():\n        PF2.append(dicUp[i])\n    print 'elementos tracionados:', len(Ltrac)\n    print 'elementos comprimidos:', len(Lcomp)",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}