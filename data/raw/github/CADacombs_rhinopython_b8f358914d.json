{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_JoinNakedEdges.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_JoinNakedEdges.py",
  "instruction": "Spb join naked edges",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n160303: Created.  'JoinNakedEdges' apparently is an undocumented command.\r\n160304: Changed minimum tolerance allowed to be entered to 0.  Changed formatting of printed decimals.\r\n160728: Modularized and added more printed output.\r\n190625: Added Opts.  Refactored getInput.\r\n190822: Modified an option default value.\r\n200630: Import-related update and modified an optino default value.\r\n230928: Bug fixes.  Added a command option.  Refactored.\r\n231001: Refactored.  Added text (indices of bad brep components) to dots.\r\n250215: '+' now is included in reporting of changes in edge counts.\r\n250916: Modified an option default value.\r\n251009-10: Added an option to join edges iteratively through tolerance values.\r\n251012: Modified an option default value.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System.Drawing import Color\r\n\r\n#import re\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n    key = 'fMaxTol'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bIterateToMaxTol'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fStartTol'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance # 1e-5 * Rhino.RhinoMath.UnitScale(Rhino.UnitSystem.Millimeters, sc.doc.ModelUnitSystem)\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bMarkBadGeom'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if sc.sticky.has_key(stickyKeys[key]):\r\n            if riOpts[key]:\r\n                values[key] = riOpts[key].CurrentValue = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fMaxTol':\r\n            if cls.riOpts[key].CurrentValue < 0:\r\n                Opts.riOpts[key].CurrentValue = Opts.riOpts[key].InitialValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            if cls.values['fStartTol'] > cls.values['fMaxTol']:\r\n                sc.sticky[cls.stickyKeys['fStartTol']] = cls.values['fStartTol'] = cls.riOpts['fStartTol'].CurrentValue = cls.riOpts['fMaxTol'].CurrentValue\r\n            return\r\n\r\n        if key == 'fStartTol':\r\n            if cls.riOpts[key].CurrentValue < 0:\r\n                Opts.riOpts[key].CurrentValue = Opts.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < 1e-6 * Rhino.RhinoMath.UnitScale(\r\n                Rhino.UnitSystem.Millimeters, sc.doc.ModelUnitSystem):\r\n                Opts.riOpts[key].CurrentValue = 1e-6 * Rhino.RhinoMath.UnitScale(\r\n                    Rhino.UnitSystem.Millimeters, sc.doc.ModelUnitSystem)\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            if cls.values['fMaxTol'] < cls.values['fStartTol']:\r\n                sc.sticky[cls.stickyKeys['fMaxTol']] = cls.values['fMaxTol'] = cls.riOpts['fMaxTol'].CurrentValue = cls.riOpts['fStartTol'].CurrentValue\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        if key in cls.stickyKeys:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef get_all_normal_polysrf_breps():\r\n    oes = rd.ObjectEnumeratorSettings()\r\n    oes.LockedObjects = False # Default is True.\r\n    oes.ObjectTypeFilter = rd.ObjectType.Brep\r\n    rdBs_Out = []\r\n    for rdB in sc.doc.Objects.GetObjectList(oes):\r\n        #if not rdB.BrepGeometry.IsValid:\r\n        #    continue\r\n        if rdB.BrepGeometry.IsSolid:\r\n            continue\r\n        if rdB.BrepGeometry.Faces.Count == 1:\r\n            continue\r\n        rdBs_Out.append(rdB)\r\n\r\n    return rdBs_Out\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get brep face.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select polysrf breps\")\r\n    go.SetCommandPromptDefault(\"All normal when none are selected\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.PolysrfFilter\r\n    go.GeometryAttributeFilter = ri.Custom.GeometryAttributeFilter.OpenPolysrf\r\n    go.SubObjectSelect = False\r\n\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n\r\n    go.AcceptNothing(True)\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    bPreselectedObjsChecked = False\r\n\r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        addOption('fMaxTol')\r\n        addOption('bIterateToMaxTol')\r\n        if Opts.values['bIterateToMaxTol']:\r\n            addOption('fStartTol')\r\n        addOption('bMarkBadGeom')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            continue\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            go.Dispose()\r\n            rdBs_Out = get_all_normal_polysrf_breps()\r\n            if not rdBs_Out:\r\n                print(\"No open polysrf breps are selectable.\")\r\n                return\r\n            return rdBs_Out\r\n\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fMaxTol'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef _countsOfEdgeValences(rgBrep0):\r\n    \"\"\"\r\n    From https://developer.rhino3d.com/api/rhinocommon/rhino.geometry.edgeadjacency\r\n    EdgeAdjacency enum\r\n    None = 0            Edge is not used by any faces and is therefore superfluous.\r\n    Naked = 1           Edge is used by a single face.\r\n    Interior = 2        Edge is used by two adjacent faces.\r\n    NonManifold = 3     Edge is used by three or more adjacent faces.\r\n    \"\"\"\r\n    numEdgeValence = [0]*4\r\n    for e in rgBrep0.Edges:\r\n        numEdgeValence[e.Valence.value__] += 1\r\n        e.Dispose()\r\n    return numEdgeValence \r\n\r\n\r\ndef getMaxDeviationToJoin(rgBrep0, fMaxDevToFlag):\r\n    rgCrvs = rgBrep0.DuplicateNakedEdgeCurves(True, True)\r\n    rgBrep0.Dispose()\r\n    \r\n    rs.Prompt(message=\"Checking deviations of naked edges ...\")\r\n    \r\n    # Check all combinations of curves for maximum deviation.\r\n    fMaxDev = 0.\r\n    for i in range(len(rgCrvs)):\r\n        for j in range(i + 1, len(rgCrvs)):\r\n            rc = rg.Curve.GetDistancesBetweenCurves(\r\n                    rgCrvs[i], rgCrvs[j], sc.doc.ModelAbsoluteTolerance)\r\n            if rc[0]:\r\n                fDev = rc[1]\r\n                if fDev <= fMaxDevToFlag:\r\n                    if fDev > fMaxDev: fMaxDev = fDev\r\n        rgCrvs[i].Dispose()\r\n    \r\n    if fMaxDev:\r\n        print(\"Largest deviation <= {:f}: {:f}\".format(fMaxDevToFlag, fMaxDev))\r\n        fMaxTol = fMaxDev\r\n    else:\r\n        print(\"No deviations <= {:f} exist.\".format(fMaxDevToFlag))\r\n        fMaxTol = 2. * fMaxDevToFlag\r\n    \r\n    return rs.GetReal(\"Enter maximum deviation to join\", fMaxTol, 0.)\r\n\r\n\r\ndef _dotEdge(rgBrep, idxEdge):\r\n    rgEdge = rgBrep.Edges[idxEdge]\r\n    pt = rgEdge.PointAtNormalizedLength(0.5)\r\n    if pt.X == Rhino.RhinoMath.UnsetValue:\r\n        pt = rgEdge.PointAtStart\r\n\r\n    rgDot = rg.TextDot(text=\"E{}\".format(idxEdge), location=pt)\r\n    rgDot.FontHeight = 11 if Rhino.RhinoApp.ExeVersion >= 6 else 14\r\n\r\n    attr = rd.ObjectAttributes()\r\n    attr.LayerIndex = sc.doc.Layers.CurrentLayerIndex # If not done, layer of index 0 will be used.\r\n    attr.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n    attr.ObjectColor = Color.Red\r\n\r\n    gDot = sc.doc.Objects.AddTextDot(rgDot, attr)\r\n    \r\n    if gDot != gDot.Empty: return rgDot\r\n\r\n    print(\"AddTextDot failed for E[{}}.\".format(idxEdge))\r\n\r\n\r\ndef _dotFace(rgBrep, idxFace):\r\n\r\n    rgFace = rgBrep.Faces[idxFace]\r\n\r\n    amp = rg.AreaMassProperties.Compute(rgFace)\r\n    if amp is None:\r\n        print(\"Surface not dotted because its AreaMassProperties,\"\r\n            \"and thus its centroid, cannot be calculated.\")\r\n        return\r\n\r\n    ptCentroid = amp.Centroid\r\n    getrc, u, v = rgFace.ClosestPoint(ptCentroid)\r\n    if rg.BrepFace.IsPointOnFace(rgFace, u, v):\r\n        location = rgFace.PointAt(u, v)\r\n    else:\r\n        pts = []\r\n        for idxE in rgFace.AdjacentEdges():\r\n            rgE = rgBrep.Edges[idxE]\r\n            bSuccess, t = rgE.ClosestPoint(ptCentroid)\r\n            if bSuccess: pts.append(rgE.PointAt(t))\r\n        pt3dlist = Rhino.Collections.Point3dList(pts)\r\n        location = pt3dlist.ClosestPointInList(ptCentroid)\r\n\r\n    rgDot = rg.TextDot(text=\"F{}\".format(idxFace), location=location)\r\n    rgDot.FontHeight = 11 if Rhino.RhinoApp.ExeVersion >= 6 else 14\r\n\r\n    attr = rd.ObjectAttributes()\r\n    attr.LayerIndex = sc.doc.Layers.CurrentLayerIndex # If not done, layer of index 0 will be used.\r\n    attr.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n    attr.ObjectColor = Color.Red\r\n\r\n    gDot = sc.doc.Objects.AddTextDot(rgDot, attr)\r\n\r\n    if gDot != gDot.Empty: return rgDot\r\n\r\n    print(\"AddTextDot failed for F[{}].\".format(idxFace))\r\n\r\n\r\ndef _report_invalid_Brep_after_JoinNakedEdges(brep, bEcho=True, bMarkBadGeom=True):\r\n    if bEcho:\r\n        if bMarkBadGeom:\r\n            print(\"Brep became invalid at marked area(s).\")\r\n        else:\r\n            print(\"Brep became invalid at latest JoinNakedEdges.\")\r\n        sLog = brep.IsValidWithLog()[1]\r\n        print(sLog)\r\n    if bMarkBadGeom:\r\n        ## Alternative\r\n        #m = re.search(r\"\\[([A-Za-z0-9_]+)\\]\", sLog)\r\n        #print(m.group(1))\r\n        if 'ON_Brep.m_F[' in sLog:\r\n            idxF = int(\r\n                    sLog.split('ON_Brep.m_F[', 1)[1].\\\r\n                    split('] is invalid.')[0])\r\n            _dotFace(brep, idxF)\r\n        if 'ON_Brep.m_E[' in sLog:\r\n            idxE = int(\r\n                    sLog.split('ON_Brep.m_E[', 1)[1].\\\r\n                    split('] is invalid.')[0])\r\n            _dotEdge(brep, idxE)\r\n\r\n\r\ndef _formatDistance(fDistance):\r\n    try:\r\n        fDistance = float(fDistance)\r\n    except:\r\n        return \"(No deviation provided)\"\r\n\r\n    if fDistance == 0.0:\r\n        return \"0\"\r\n\r\n    if fDistance < 10**-(sc.doc.ModelDistanceDisplayPrecision-1):\r\n        return \"{:.4e}\".format(fDistance)\r\n\r\n    return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\ndef _formatDelta(integer):\r\n    sign_char = '+' if integer > 0 else '' # Empty string for zero and negative\r\n    return \"{0:{sign}d}\".format(integer, sign=sign_char)\r\n\r\n\r\ndef processBrep(rgBrep_In, fMaxTol, fStartTol, bMarkBadGeom=True, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    if rgBrep_In.IsSolid:\r\n        if bEcho:\r\n            print(\"Brep is already closed.\")\r\n        return\r\n\r\n    if not rgBrep_In.IsValid:\r\n        if bEcho:\r\n            print(\"Starting Brep is invalid and will not be processed.\")\r\n        return\r\n\r\n    rgBrep_PrevWIP = None\r\n    rgBrep_CurrentWIP = rgBrep_In.DuplicateBrep()\r\n    fTol_Current = fStartTol\r\n    ct_JoinedEdges_Total = 0\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(prompt=\"Joining naked edges ...\")\r\n\r\n    while True:\r\n        sc.escape_test()\r\n\r\n        iJoinCt = rgBrep_CurrentWIP.JoinNakedEdges(fTol_Current)\r\n\r\n        if bEcho and rgBrep_CurrentWIP.IsValid:\r\n            print(\"{} edges were joined JoinNakedEdges(tolerance={}).\".format(\r\n                iJoinCt,\r\n                _formatDistance(fTol_Current)))\r\n\r\n        if not rgBrep_CurrentWIP.IsValid and (bEcho or bMarkBadGeom):\r\n            _report_invalid_Brep_after_JoinNakedEdges(rgBrep_CurrentWIP, bEcho, bMarkBadGeom)\r\n            rgBrep_CurrentWIP.Dispose()\r\n            print(\"{} edges were joined JoinNakedEdges(tolerance={:f}) to an invalid brep.\".format(\r\n                iJoinCt,\r\n                fTol_Current))\r\n            if ct_JoinedEdges_Total:\r\n                return rgBrep_PrevWIP # Will be None if no JoinNakedEdges were successful and didn't create an invalid brep.\r\n            else:\r\n                rgBrep_PrevWIP.Dispose()\r\n                return\r\n\r\n        ct_JoinedEdges_Total += iJoinCt\r\n\r\n        if rgBrep_PrevWIP:\r\n            rgBrep_PrevWIP.Dispose()\r\n\r\n        if fTol_Current == fMaxTol:\r\n            break\r\n\r\n        rgBrep_PrevWIP = rgBrep_CurrentWIP\r\n        rgBrep_CurrentWIP = rgBrep_CurrentWIP.DuplicateBrep()\r\n\r\n        fTol_Current *= 10.0\r\n        #sEval = \"fMaxTol, fTol_Current, fMaxTol - fTol_Current\"; print(sEval,'=',eval(sEval))\r\n        #sEval = \"abs(fMaxTol - fTol_Current)/max((fMaxTol, fTol_Current))\"; print(sEval,'=',eval(sEval))\r\n        if fTol_Current > fMaxTol:\r\n            fTol_Current = fMaxTol\r\n        elif ((fMaxTol - fTol_Current) / fMaxTol) <= 0.1:\r\n            fTol_Current = fMaxTol\r\n\r\n    if ct_JoinedEdges_Total == 0:\r\n        rgBrep_CurrentWIP.Dispose()\r\n        return\r\n\r\n    return rgBrep_CurrentWIP\r\n\r\n\r\ndef coerceBrepObject(rhBrep_In):\r\n    if isinstance(rhBrep_In, rd.BrepObject):\r\n        return rhBrep_In\r\n    elif isinstance(rhBrep_In, Guid):\r\n        return sc.doc.Objects.FindId(rhBrep_In)\r\n    else:\r\n        raise Exception(\"{} passed to function. Should be BrepObject or GUID of one).\".format(\r\n            rdBrep_In.GetType().Name))\r\n\r\n\r\ndef processBrepObject(rhBrep_In, fMaxTol=None, fStartTol=None, bMarkBadGeom=True, bEcho=None, bDebug=None):\r\n    \"\"\"\r\n    rhBrep_In: BrepObject or GUID of one\r\n    \"\"\"\r\n\r\n    if fMaxTol is None: fMaxTol = Opts.values['fMaxTol']\r\n    if fStartTol is None: fStartTol = Opts.values['fStartTol']\r\n    if bMarkBadGeom is None: bMarkBadGeom = Opts.values['bMarkBadGeom']\r\n    if bEcho is None: bEcho = Opts.values['bEcho']\r\n    if bDebug is None: bDebug = Opts.values['bDebug']\r\n\r\n\r\n    rdBrep_In = coerceBrepObject(rhBrep_In)\r\n    rgBrep_In = rdBrep_In.BrepGeometry\r\n\r\n    rgBrep_Res = processBrep(\r\n        rgBrep_In,\r\n        fMaxTol=fMaxTol,\r\n        fStartTol=fStartTol,\r\n        bMarkBadGeom=bMarkBadGeom,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n    if rgBrep_Res is None:\r\n        return\r\n\r\n    # Report face count and edge valence counts.\r\n    ct_Faces_In = rgBrep_In.Faces.Count\r\n    cts_of_EdgeValences_In = _countsOfEdgeValences(rgBrep_In)\r\n\r\n    print(\"Counts:\",\r\n          \"{} faces,\".format(ct_Faces_In),\r\n          \"{} none edges,\".format(cts_of_EdgeValences_In[0]),\r\n          \"{} naked edges,\".format(cts_of_EdgeValences_In[1]),\r\n          \"{} interior edges,\".format(cts_of_EdgeValences_In[2]),\r\n          \"{} non-manifold edges\".format(cts_of_EdgeValences_In[3]))\r\n\r\n    if not sc.doc.Objects.Replace(rdBrep_In.Id, rgBrep_Res):\r\n        print(\"Brep was not replaced.\")\r\n        return False\r\n\r\n    sc.doc.Views.Redraw()\r\n    ct_Faces_Res = rgBrep_Res.Faces.Count\r\n    cts_of_EdgeValences_Res = _countsOfEdgeValences(rgBrep_Res)\r\n\r\n    print(\"Counts: Before -> After (Delta)\")\r\n\r\n    if ct_Faces_In != ct_Faces_Res:\r\n        print(\"Faces: {} - {} ({})\".format(\r\n            ct_Faces_In,\r\n            ct_Faces_Res,\r\n            _formatDelta(ct_Faces_Res-ct_Faces_In),\r\n            ))\r\n\r\n    if cts_of_EdgeValences_In[0] or cts_of_EdgeValences_Res[0]:\r\n        print(\"None edges: {} -> {} ({})\".format(\r\n            cts_of_EdgeValences_In[0],\r\n            cts_of_EdgeValences_Res[0],\r\n            _formatDelta(cts_of_EdgeValences_Res[0]-cts_of_EdgeValences_In[0]),\r\n            ))\r\n\r\n    print(\"Naked edges: {} -> {} ({})\".format(\r\n        cts_of_EdgeValences_In[1],\r\n        cts_of_EdgeValences_Res[1],\r\n        _formatDelta(cts_of_EdgeValences_Res[1]-cts_of_EdgeValences_In[1]),\r\n        ))\r\n\r\n    print(\"Interior edges: {} -> {} ({})\".format(\r\n        cts_of_EdgeValences_In[2],\r\n        cts_of_EdgeValences_Res[2],\r\n        _formatDelta(cts_of_EdgeValences_Res[2]-cts_of_EdgeValences_In[2]),\r\n        ))\r\n\r\n    if cts_of_EdgeValences_In[3] or cts_of_EdgeValences_Res[3]:\r\n        print(\"Non-manifold edges: {} -> {} ({})\".format(\r\n            cts_of_EdgeValences_In[3],\r\n            cts_of_EdgeValences_Res[3],\r\n            _formatDelta(cts_of_EdgeValences_Res[3]-cts_of_EdgeValences_In[3]),\r\n            ))\r\n\r\n    return rdBrep_In\r\n\r\n\r\n    #print(\"No edges were joined within a deviation of {:f}.\".format(fMaxTol))\r\n    return iJoinCt_Total\r\n\r\n\r\ndef main():\r\n    rhObjs_In = getInput()\r\n    if rhObjs_In is None: return\r\n    \r\n    fMaxTol = Opts.values['fMaxTol']\r\n    bIterateToMaxTol = Opts.values['bIterateToMaxTol']\r\n    fStartTol = Opts.values['fStartTol']\r\n    bMarkBadGeom = Opts.values['bMarkBadGeom']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(prompt=\"Working ...\")\r\n\r\n    gBs_Res = []\r\n\r\n    for rhObj in rhObjs_In:\r\n        gBrep = rs.coerceguid(rhObj)\r\n\r\n        rc = processBrepObject(\r\n            gBrep,\r\n            fMaxTol=fMaxTol,\r\n            fStartTol=fStartTol if bIterateToMaxTol else fMaxTol,\r\n            bMarkBadGeom=bMarkBadGeom,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug)\r\n\r\n        if rc is None:\r\n            continue\r\n        elif not rc:\r\n            print(\"No error in brep geometry, but no edges were joined.\")\r\n        else:\r\n            print(\"Edges were joined.\")\r\n            gBs_Res.append(rc)\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}