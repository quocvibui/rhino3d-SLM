{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_pipe_router.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_pipe_router.py",
  "instruction": "Pipe Router for Grasshopper.",
  "code": "# File: scripts/gh_pipe_router.py\n\"\"\"Pipe Router for Grasshopper.\n\nCalculates pipe routes from plumbing connectors to wall entry points.\nThis is the second step in the MEP integration pipeline.\n\nKey Features:\n1. Wall Finding\n   - Finds nearest wall using ray-plane intersection\n   - Respects max search distance parameter\n\n2. Route Calculation\n   - From fixture connector to wall face (entry point)\n   - Then to first vertical connection inside wall\n\n3. Geometry Output\n   - Creates polyline curves showing pipe paths\n   - Uses RhinoCommonFactory for proper assembly compatibility\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n\nDependencies:\n    - Rhino.Geometry: Core geometry creation\n    - Grasshopper: Component framework\n    - timber_framing_generator.mep.plumbing: Pipe routing logic\n    - timber_framing_generator.utils.geometry_factory: RhinoCommon geometry\n\nInput Requirements:\n    connectors_json (conn_json) - str:\n        JSON from MEP Connector Extractor\n        Required: Yes\n        Access: Item\n\n    walls_json (walls_json) - str:\n        JSON with wall geometry data (from Wall Analyzer)\n        Required: Yes\n        Access: Item\n\n    max_search_distance (max_dist) - float:\n        Maximum distance to search for walls (in feet)\n        Required: No (defaults to 10 ft)\n        Access: Item\n\n    run (run) - bool:\n        Execute toggle\n        Required: Yes\n        Access: Item\n\nOutputs:\n    routes_json (json) - str:\n        JSON with calculated routes for downstream components\n\n    route_curves (curves) - list of Curves:\n        Polyline curves showing pipe paths\n\n    route_points (pts) - list of Point3d:\n        All route path points for visualization\n\n    debug_info (info) - str:\n        Processing summary and diagnostics\n\nAuthor: Claude AI Assistant\nVersion: 1.1.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\n\n# Force reload of project modules (development only)\nFORCE_RELOAD = True\nif FORCE_RELOAD:\n    modules_to_reload = [k for k in sys.modules.keys()\n                         if 'timber_framing_generator' in k]\n    for mod_name in modules_to_reload:\n        del sys.modules[mod_name]\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\n# Rhino / Grasshopper\nimport Rhino\nimport Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Pipe Router\"\nCOMPONENT_NICKNAME = \"PipeRte\"\nCOMPONENT_MESSAGE = \"v1.1\"\n\n# Project path\nPROJECT_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator\"\nif PROJECT_PATH not in sys.path:\n    sys.path.insert(0, PROJECT_PATH)\n\n# =============================================================================\n# Project Imports\n# =============================================================================\n\ntry:\n    from src.timber_framing_generator.mep.plumbing import calculate_pipe_routes\n    from src.timber_framing_generator.core import MEPConnector, MEPRoute\n    from src.timber_framing_generator.utils.geometry_factory import get_factory\n    PROJECT_AVAILABLE = True\n    PROJECT_ERROR = None\nexcept ImportError as e:\n    PROJECT_AVAILABLE = False\n    PROJECT_ERROR = str(e)\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message, level=\"info\"):\n    \"\"\"Log to console and optionally add GH runtime message.\"\"\"\n    print(f\"[{level.upper()}] {message}\")\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n\n\ndef log_info(message):\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message):\n    log_message(message, \"warning\")\n\n\ndef log_error(message):\n    log_message(message, \"error\")\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\"\"\"\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef validate_inputs():\n    \"\"\"Validate component inputs.\"\"\"\n    if not PROJECT_AVAILABLE:\n        return False, f\"Project import error: {PROJECT_ERROR}\"\n\n    if not run:\n        return False, \"Toggle 'run' to True to execute\"\n\n    if not connectors_json:\n        return False, \"No connectors_json provided\"\n\n    if not walls_json:\n        return False, \"No walls_json provided\"\n\n    return True, None\n\n\ndef parse_connectors(connectors_json_str):\n    \"\"\"Parse connectors from JSON string.\n\n    Returns:\n        tuple: (connectors list, error message or None)\n    \"\"\"\n    try:\n        data = json.loads(connectors_json_str)\n        connector_list = data.get(\"connectors\", [])\n\n        connectors = []\n        for conn_dict in connector_list:\n            conn = MEPConnector.from_dict(conn_dict)\n            connectors.append(conn)\n\n        return connectors, None\n    except json.JSONDecodeError as e:\n        return [], f\"JSON parse error: {e}\"\n    except Exception as e:\n        return [], f\"Error parsing connectors: {e}\"\n\n\ndef extract_walls_list(walls_data):\n    \"\"\"Extract list of walls from various JSON structures.\"\"\"\n    if isinstance(walls_data, list):\n        return walls_data\n\n    if isinstance(walls_data, dict):\n        if \"walls\" in walls_data:\n            return walls_data[\"walls\"]\n        if \"wall_id\" in walls_data or \"base_plane\" in walls_data:\n            return [walls_data]\n        if \"results\" in walls_data:\n            return extract_walls_list(walls_data[\"results\"])\n\n    return []\n\n\ndef create_route_geometry(routes, factory):\n    \"\"\"Create route curves and points using RhinoCommonFactory.\n\n    Args:\n        routes: List of MEPRoute objects\n        factory: RhinoCommonFactory instance\n\n    Returns:\n        tuple: (curves, points) lists\n    \"\"\"\n    curves = []\n    points = []\n\n    for route in routes:\n        if len(route.path_points) >= 2:\n            # Create polyline curve using factory\n            curve = factory.create_polyline_curve(route.path_points)\n            if curve is not None:\n                curves.append(curve)\n\n            # Create points for visualization\n            for p in route.path_points:\n                pt = factory.create_point3d(p[0], p[1], p[2])\n                points.append(pt)\n\n    return curves, points\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main():\n    \"\"\"Main entry point for the component.\"\"\"\n    # Setup component\n    setup_component()\n\n    # Initialize outputs\n    routes_json = \"{}\"\n    route_curves = []\n    route_points = []\n    debug_lines = []\n\n    debug_lines.append(\"=\" * 50)\n    debug_lines.append(\"PIPE ROUTER\")\n    debug_lines.append(\"=\" * 50)\n\n    try:\n        # Validate inputs\n        is_valid, error_msg = validate_inputs()\n        if not is_valid:\n            debug_lines.append(error_msg)\n            return routes_json, route_curves, route_points, \"\\n\".join(debug_lines)\n\n        # Parse connectors\n        connectors, parse_error = parse_connectors(connectors_json)\n        if parse_error:\n            debug_lines.append(parse_error)\n            return routes_json, route_curves, route_points, \"\\n\".join(debug_lines)\n\n        debug_lines.append(f\"Input connectors: {len(connectors)}\")\n\n        if not connectors:\n            debug_lines.append(\"No connectors in JSON data\")\n            return routes_json, route_curves, route_points, \"\\n\".join(debug_lines)\n\n        # Parse walls\n        try:\n            walls_data = json.loads(walls_json)\n            walls_list = extract_walls_list(walls_data)\n            debug_lines.append(f\"Input walls: {len(walls_list)}\")\n        except json.JSONDecodeError as e:\n            debug_lines.append(f\"ERROR parsing walls_json: {e}\")\n            return routes_json, route_curves, route_points, \"\\n\".join(debug_lines)\n\n        # Build routing config\n        search_dist = max_search_distance if max_search_distance else 10.0\n        config = {\n            \"max_search_distance\": search_dist,\n            \"wall_thickness\": 0.333,  # Default 4\" wall\n        }\n        debug_lines.append(f\"Max search distance: {search_dist} ft\")\n\n        # Analyze connectors by fixture\n        fixture_groups = {}\n        for conn in connectors:\n            fid = conn.owner_element_id or 0\n            if fid not in fixture_groups:\n                fixture_groups[fid] = []\n            fixture_groups[fid].append(conn)\n\n        debug_lines.append(\"\")\n        debug_lines.append(f\"Fixtures: {len(fixture_groups)}\")\n        for fid, fconns in fixture_groups.items():\n            sys_types = set(c.system_type for c in fconns)\n            debug_lines.append(f\"  Fixture {fid}: {len(fconns)} connectors ({', '.join(sys_types)})\")\n\n        # Calculate routes\n        debug_lines.append(\"\")\n        debug_lines.append(\"Calculating routes with fixture-aware merging...\")\n\n        framing_data = {\"walls\": walls_list}\n        routes = calculate_pipe_routes(connectors, framing_data, [], config)\n        debug_lines.append(f\"Calculated {len(routes)} routes\")\n\n        if not routes:\n            debug_lines.append(\"No routes could be calculated\")\n            debug_lines.append(\"Check that fixtures are within search distance of walls\")\n            return routes_json, route_curves, route_points, \"\\n\".join(debug_lines)\n\n        # Analyze routes by system type\n        total_length = sum(route.get_length() for route in routes)\n        end_types = {}\n        system_types = {}\n        path_point_counts = {}\n        for route in routes:\n            et = route.end_point_type\n            st = route.system_type\n            pts = len(route.path_points)\n            end_types[et] = end_types.get(et, 0) + 1\n            system_types[st] = system_types.get(st, 0) + 1\n            path_point_counts[pts] = path_point_counts.get(pts, 0) + 1\n\n        debug_lines.append(\"\")\n        debug_lines.append(\"Route summary:\")\n        debug_lines.append(f\"  Total routes: {len(routes)}\")\n        debug_lines.append(f\"  Total length: {total_length:.2f} ft\")\n        debug_lines.append(\"\")\n        debug_lines.append(\"By system type (all orthogonal segments):\")\n        for st, count in system_types.items():\n            # Show routing behavior based on system type\n            if \"sanitary\" in st.lower():\n                behavior = \"↓DROP → →MERGE → ⊥WALL → →INTO → ↓DOWN\"\n            elif \"vent\" in st.lower():\n                behavior = \"↓DROP → →MERGE → ⊥WALL → →INTO → ↑UP\"\n            else:\n                # Supply water goes UP to connect to vertical risers\n                behavior = \"↓DROP → →MERGE → ⊥WALL → →INTO → ↑UP\"\n            debug_lines.append(f\"  {st}: {count} - {behavior}\")\n        debug_lines.append(\"\")\n        debug_lines.append(\"Path structure:\")\n        for pts, count in sorted(path_point_counts.items()):\n            debug_lines.append(f\"  {pts}-point paths: {count}\")\n        debug_lines.append(\"\")\n        debug_lines.append(\"By end type:\")\n        for et, count in end_types.items():\n            debug_lines.append(f\"  {et}: {count}\")\n\n        # Build JSON output\n        output_data = {\n            \"routes\": [route.to_dict() for route in routes],\n            \"count\": len(routes),\n            \"total_length\": total_length,\n            \"source\": \"gh_pipe_router\",\n        }\n        routes_json = json.dumps(output_data, indent=2)\n\n        # Create geometry using RhinoCommonFactory\n        factory = get_factory()\n        route_curves, route_points = create_route_geometry(routes, factory)\n\n        debug_lines.append(\"\")\n        debug_lines.append(f\"Created {len(route_curves)} route curves\")\n        debug_lines.append(f\"Created {len(route_points)} route points\")\n\n        # Summary\n        debug_lines.append(\"\")\n        debug_lines.append(\"=\" * 50)\n        debug_lines.append(\"ROUTING COMPLETE\")\n        debug_lines.append(f\"Total routes: {len(routes)}\")\n        debug_lines.append(f\"Total length: {total_length:.2f} ft\")\n        debug_lines.append(\"=\" * 50)\n\n    except Exception as e:\n        log_error(f\"Unexpected error: {str(e)}\")\n        debug_lines.append(f\"ERROR: {str(e)}\")\n        debug_lines.append(traceback.format_exc())\n\n    return routes_json, route_curves, route_points, \"\\n\".join(debug_lines)\n\n# =============================================================================\n# Execution\n# =============================================================================\n\n# Define default input values if not provided by Grasshopper\nif 'run' not in dir():\n    run = False\n\nif 'connectors_json' not in dir():\n    connectors_json = \"\"\n\nif 'walls_json' not in dir():\n    walls_json = \"\"\n\nif 'max_search_distance' not in dir():\n    max_search_distance = 10.0\n\n# Execute main and assign to output variables\nroutes_json, route_curves, route_points, debug_info = main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}