{
  "source_url": "https://github.com/leclusen/necs-sandbox/blob/8d8006ae3c845c9f3e38154803caac6b03d298a9/structure-batiment/structure_aligner/etl/reverse_writer.py",
  "repo": "leclusen/necs-sandbox",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "structure-batiment/structure_aligner/etl/reverse_writer.py",
  "instruction": "Reverse writer",
  "code": "from __future__ import annotations\n\nimport json\nimport logging\nimport math\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom pathlib import Path\n\nimport rhino3dm\n\nfrom structure_aligner.etl.reverse_reader import AlignedElement, AlignedVertexCoord\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass ReverseETLReport:\n    output_path: Path\n    report_path: Path\n    total_objects: int = 0\n    updated_objects: int = 0\n    updated_vertices: int = 0\n    skipped_objects: list[str] = field(default_factory=list)\n    skipped_unsupported: list[str] = field(default_factory=list)\n    mismatched_objects: list[str] = field(default_factory=list)\n    brep_residual_warnings: list[tuple[str, float]] = field(default_factory=list)\n    max_displacement_m: float = 0.0\n    total_displacement_sum: float = 0.0\n\n\ndef write_aligned_3dm(\n    template_3dm: Path,\n    aligned_elements: dict[str, AlignedElement],\n    output_path: Path,\n) -> ReverseETLReport:\n    \"\"\"Read template .3dm, update vertex coordinates in-place, write output.\"\"\"\n    if not template_3dm.exists():\n        raise FileNotFoundError(f\"Template .3dm not found: {template_3dm}\")\n\n    model = rhino3dm.File3dm.Read(str(template_3dm))\n    if model is None:\n        raise RuntimeError(f\"Failed to read template .3dm: {template_3dm}\")\n\n    report_path = output_path.with_suffix(\".reverse_etl_report.json\")\n    report = ReverseETLReport(output_path=output_path, report_path=report_path)\n    report.total_objects = len(model.Objects)\n\n    for obj in model.Objects:\n        name = obj.Attributes.Name\n        if not name:\n            report.skipped_objects.append(f\"unnamed-object-layer-{obj.Attributes.LayerIndex}\")\n            continue\n\n        element = aligned_elements.get(name)\n        if element is None:\n            report.skipped_objects.append(name)\n            continue\n\n        geom = obj.Geometry\n        vertices = element.vertices\n\n        # Skip elements with no vertices (e.g., db_only elements)\n        if not vertices:\n            continue\n\n        success, vertex_count, brep_warning = _update_geometry(geom, vertices, name)\n\n        if success is None:\n            # Unsupported geometry type\n            report.skipped_unsupported.append(f\"{name} ({type(geom).__name__})\")\n            logger.warning(\"Unsupported geometry type %s for element %s\", type(geom).__name__, name)\n            continue\n\n        if not success:\n            # Vertex count mismatch\n            report.mismatched_objects.append(name)\n            continue\n\n        report.updated_objects += 1\n        report.updated_vertices += vertex_count\n\n        if brep_warning:\n            report.brep_residual_warnings.append(brep_warning)\n\n    # Write output\n    output_path.parent.mkdir(parents=True, exist_ok=True)\n    model.Write(str(output_path), 0)\n    logger.info(\"Written aligned .3dm to %s\", output_path)\n\n    # Generate report\n    _write_report(report, template_3dm, aligned_elements)\n\n    return report\n\n\ndef _update_geometry(\n    geom: rhino3dm.GeometryBase,\n    vertices: list[AlignedVertexCoord],\n    name: str,\n) -> tuple[bool | None, int, tuple[str, float] | None]:\n    \"\"\"Dispatch to geometry-specific update. Returns (success, vertex_count, brep_warning).\n\n    success=None means unsupported geometry type.\n    success=False means vertex count mismatch.\n    success=True means update succeeded.\n    \"\"\"\n    if isinstance(geom, rhino3dm.Point):\n        return _update_point(geom, vertices, name)\n    elif isinstance(geom, rhino3dm.LineCurve):\n        return _update_line_curve(geom, vertices, name)\n    elif isinstance(geom, rhino3dm.PolylineCurve):\n        return _update_polyline_curve(geom, vertices, name)\n    elif isinstance(geom, rhino3dm.NurbsCurve):\n        return _update_nurbs_curve(geom, vertices, name)\n    elif isinstance(geom, rhino3dm.Brep):\n        return _update_brep(geom, vertices, name)\n    else:\n        return (None, 0, None)\n\n\ndef _update_point(\n    geom: rhino3dm.Point,\n    vertices: list[AlignedVertexCoord],\n    name: str,\n) -> tuple[bool, int, None]:\n    if len(vertices) != 1:\n        logger.warning(\"Point %s: expected 1 vertex, got %d\", name, len(vertices))\n        return (False, 0, None)\n    v = vertices[0]\n    geom.Location = rhino3dm.Point3d(v.x, v.y, v.z)\n    return (True, 1, None)\n\n\ndef _update_line_curve(\n    geom: rhino3dm.LineCurve,\n    vertices: list[AlignedVertexCoord],\n    name: str,\n) -> tuple[bool, int, None]:\n    if len(vertices) != 2:\n        logger.warning(\"LineCurve %s: expected 2 vertices, got %d\", name, len(vertices))\n        return (False, 0, None)\n    # Sort by vertex_index to ensure correct order\n    sorted_verts = sorted(vertices, key=lambda v: v.vertex_index)\n    geom.SetStartPoint(rhino3dm.Point3d(sorted_verts[0].x, sorted_verts[0].y, sorted_verts[0].z))\n    geom.SetEndPoint(rhino3dm.Point3d(sorted_verts[1].x, sorted_verts[1].y, sorted_verts[1].z))\n    return (True, 2, None)\n\n\ndef _update_polyline_curve(\n    geom: rhino3dm.PolylineCurve,\n    vertices: list[AlignedVertexCoord],\n    name: str,\n) -> tuple[bool, int, None]:\n    if len(vertices) != geom.PointCount:\n        logger.warning(\"PolylineCurve %s: expected %d vertices, got %d\", name, geom.PointCount, len(vertices))\n        return (False, 0, None)\n    sorted_verts = sorted(vertices, key=lambda v: v.vertex_index)\n    for v in sorted_verts:\n        geom.SetPoint(v.vertex_index, rhino3dm.Point3d(v.x, v.y, v.z))\n    return (True, len(vertices), None)\n\n\ndef _update_nurbs_curve(\n    geom: rhino3dm.NurbsCurve,\n    vertices: list[AlignedVertexCoord],\n    name: str,\n) -> tuple[bool, int, None]:\n    if len(vertices) != len(geom.Points):\n        logger.warning(\"NurbsCurve %s: expected %d control points, got %d\", name, len(geom.Points), len(vertices))\n        return (False, 0, None)\n    sorted_verts = sorted(vertices, key=lambda v: v.vertex_index)\n    for v in sorted_verts:\n        # Preserve existing W weight\n        existing_point = geom.Points[v.vertex_index]\n        w = existing_point.W\n        geom.Points[v.vertex_index] = rhino3dm.Point4d(v.x, v.y, v.z, w)\n    return (True, len(vertices), None)\n\n\ndef _update_brep(\n    geom: rhino3dm.Brep,\n    vertices: list[AlignedVertexCoord],\n    name: str,\n) -> tuple[bool, int, tuple[str, float] | None]:\n    \"\"\"Hybrid Transform + per-vertex fixup strategy.\"\"\"\n    brep_vertex_count = len(geom.Vertices)\n    if len(vertices) != brep_vertex_count:\n        logger.warning(\"Brep %s: expected %d vertices, got %d\", name, brep_vertex_count, len(vertices))\n        return (False, 0, None)\n\n    sorted_verts = sorted(vertices, key=lambda v: v.vertex_index)\n\n    # Step 1: Compute mean displacement\n    mean_dx = 0.0\n    mean_dy = 0.0\n    mean_dz = 0.0\n    for v in sorted_verts:\n        orig = geom.Vertices[v.vertex_index].Location\n        mean_dx += v.x - orig.X\n        mean_dy += v.y - orig.Y\n        mean_dz += v.z - orig.Z\n    n = len(sorted_verts)\n    mean_dx /= n\n    mean_dy /= n\n    mean_dz /= n\n\n    # Step 2: Apply bulk translation (moves vertices, edges, surfaces)\n    xform = rhino3dm.Transform.Translation(mean_dx, mean_dy, mean_dz)\n    geom.Transform(xform)\n\n    # Step 3: Per-vertex fixup for residuals\n    max_residual = 0.0\n    for v in sorted_verts:\n        current = geom.Vertices[v.vertex_index].Location\n        residual = math.sqrt(\n            (v.x - current.X) ** 2 + (v.y - current.Y) ** 2 + (v.z - current.Z) ** 2\n        )\n        if residual > 1e-9:\n            geom.Vertices[v.vertex_index].Location = rhino3dm.Point3d(v.x, v.y, v.z)\n        max_residual = max(max_residual, residual)\n\n    brep_warning = None\n    if max_residual > 0.001:  # > 1mm\n        brep_warning = (name, max_residual)\n        logger.debug(\"Brep %s edge desync residual: %.6fm\", name, max_residual)\n\n    return (True, len(vertices), brep_warning)\n\n\ndef _write_report(\n    report: ReverseETLReport,\n    template_3dm: Path,\n    aligned_elements: dict[str, AlignedElement],\n) -> None:\n    \"\"\"Write JSON validation report.\"\"\"\n    # Compute brep residual stats\n    residuals_mm = [residual * 1000 for _name, residual in report.brep_residual_warnings]\n\n    report_data = {\n        \"metadata\": {\n            \"timestamp\": datetime.now(timezone.utc).isoformat(),\n            \"template_3dm\": str(template_3dm),\n            \"output_3dm\": str(report.output_path),\n            \"software_version\": \"0.1.0\",\n        },\n        \"statistics\": {\n            \"total_objects\": report.total_objects,\n            \"updated_objects\": report.updated_objects,\n            \"updated_vertices\": report.updated_vertices,\n            \"skipped_not_in_db\": len(report.skipped_objects),\n            \"skipped_unsupported_geometry\": len(report.skipped_unsupported),\n            \"vertex_count_mismatches\": len(report.mismatched_objects),\n        },\n        \"brep_edge_desync\": {\n            \"breps_with_residual\": len(report.brep_residual_warnings),\n            \"max_residual_mm\": max(residuals_mm) if residuals_mm else 0.0,\n            \"mean_residual_mm\": sum(residuals_mm) / len(residuals_mm) if residuals_mm else 0.0,\n            \"details\": [\n                f\"{name}: max_residual={residual:.6f}m\"\n                for name, residual in report.brep_residual_warnings[:50]\n            ],\n        },\n        \"warnings\": report.skipped_unsupported,\n        \"skipped_objects\": report.skipped_objects[:50],\n        \"mismatched_objects\": report.mismatched_objects,\n    }\n\n    report.report_path.write_text(json.dumps(report_data, indent=2, ensure_ascii=False))\n    logger.info(\"Reverse ETL report written to %s\", report.report_path)\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}