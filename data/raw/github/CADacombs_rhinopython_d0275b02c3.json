{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Block_duplicateObjectFromInst.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Block_duplicateObjectFromInst.py",
  "instruction": "This script duplicates object of block instance by a single pick.\r\nNon-uniform blocks are supported.\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel...",
  "code": "\"\"\"\r\nThis script duplicates object of block instance by a single pick.\r\nNon-uniform blocks are supported.\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums, https://discourse.mcneel.com/\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n160416-27: Created.\r\n...\r\n170208: ArcCurve, PolyCurve, and Brep geometries now are made deformable when the\r\n        transform's SimilarityType is NotSimilarity, e.g., non-uniform scale.\r\n180309: In response to V6 allowing objects to be added to reference layers,\r\n        option to retain the duplicated object's layer was added.\r\n180926: Now, geometry from linked (not embedded) blocks will only be created on current layer.\r\n...\r\n230718: Now, block instances from references are placed on current layer.\r\n230817: Modified some command option text.\r\n231009: Bug fix for when BlockInstance is the target.\r\n240629: Annotations are now skipped during search of lowest level picked geometry.\r\n250120: Bug fix in command options.\r\n\r\nTODO:\r\n    Point and TextDots require very accurate picking.\r\n            Possibly allow a distance tolerance for these objects.\r\n    Support adding BlockInstance of reference object.\r\n\r\nCoding notes:\r\n    ArcCurve is not supported by MakeDeformable.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\n\r\nsObjTypes = (\r\n        'bBlockInstance',\r\n        'bBrep',\r\n        'bCurve',\r\n        'bExtrusion',\r\n        'bPoint',\r\n        'bTextDot',\r\n)\r\n\r\n\r\nsOpts = sObjTypes + (\r\n        'bFace',\r\n        'bRetainLayer_NotCurrent',\r\n        'bEcho',\r\n        'bDebug',\r\n)\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bBlockInstance'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bBrep'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bCurve'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bExtrusion'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bPoint'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bTextDot'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bFace'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'BrepComponent'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'EntireBrep', 'Face')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bRetainLayer_NotCurrent'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'OutputLayer'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Current', 'TryToRetain') # TryToRetain because current layer is used when an object from a reference block is picked.\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        #if key == 'fRadius':\r\n        #    if cls.riOpts[key].CurrentValue < 2.0*sc.doc.ModelAbsoluteTolerance:\r\n        #        cls.riOpts[key].CurrentValue = 0.0\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef findPickedObjOfBlockInst(rdInstObj, objTypes_ToAccept, pt_Picked, xform=Rhino.Geometry.Transform.Identity):\r\n    xform *= rdInstObj.InstanceXform\r\n    rdInstDef = rdInstObj.InstanceDefinition\r\n    rdObjs = rdInstDef.GetObjects()\r\n    xformSimilarityType = xform.SimilarityType\r\n\r\n    for rdObj in rdObjs:\r\n\r\n        # No ClosestPoint for Annotations so skip them.\r\n        if rdObj.ObjectType == rd.ObjectType.Annotation:\r\n            continue\r\n\r\n        if rdObj.ObjectType == rd.ObjectType.InstanceReference:\r\n            \r\n            # Dig into block instances until other object type is found.\r\n            \r\n            rc = findPickedObjOfBlockInst(rdObj, objTypes_ToAccept, pt_Picked, xform)\r\n            if rc:\r\n                return rc\r\n            continue # on to next rdObj.\r\n\r\n        # Object is not a block instance.\r\n        \r\n        rgObj = rdObj.DuplicateGeometry()\r\n        if not rgObj.IsValid:\r\n            s  = \"{} has invalid geometry.\".format(rdObj.Id)\r\n            s += \"  Nothing will be duplicated.\"\r\n            s += \"  Repair invalid objects in block definitions.\"\r\n            print(s)\r\n            return\r\n        \r\n        if xformSimilarityType == rg.TransformSimilarityType.NotSimilarity:\r\n            # Convert ArcCurves, PolyCurves (in case the contain arc segments), &\r\n            # Breps (in case they contain faces of non-NURBS surfaces) into\r\n            # deformable geometry.\r\n            \r\n            typeGeom = rgObj.GetType()\r\n\r\n            # ArcCurve is not supported by MakeDeformable.\r\n            if typeGeom == rg.ArcCurve:\r\n                #                    # This doesn't work.\r\n                #                    print(typeGeom)\r\n                #                    if not rgObj.MakeDeformable():\r\n                #                        print(\"Error in converting object into NURBS representation.  Object will not be duplicated.\")\r\n                #                        continue\r\n                \r\n                rgObjNurbsCrv = rgObj.ToNurbsCurve()\r\n                if rgObjNurbsCrv is not None: rgObj = rgObjNurbsCrv\r\n                else:\r\n                    print(\"Error in converting arc curve into NURBS curve!\")\r\n                    continue\r\n            elif typeGeom == rg.PolyCurve or typeGeom == rg.Brep:\r\n                if not rgObj.MakeDeformable():\r\n                    print(\"Error in making {} deformable!\".format(typeGeom))\r\n                    continue\r\n                if not rgObj.IsValid:\r\n                    print(\"{} is not valid after MakeDeformable!  Not using MakeDeformable...\".format(rgObj.ObjectType))\r\n                    b, sLog = rgObj.IsValidWithLog()\r\n                    print(sLog)\r\n                    rgObj = rdObj.DuplicateGeometry()\r\n                    #sc.doc.Objects.Add(rgObj) # For debugging.  Add object without transformation.\r\n        \r\n        rgObj.Transform(xform)\r\n        \r\n        if not rgObj.IsValid:\r\n            print(\"{} is not valid after transformation!  Skipping object...\".format(rgObj.ObjectType))\r\n            rgObj.Dispose()\r\n            continue\r\n        rdObjType_ThisObj = rgObj.ObjectType\r\n        if objTypes_ToAccept & rd.ObjectType.InstanceReference:\r\n            if rdObjType_ThisObj == rd.ObjectType.Brep:\r\n                pt_ClosestOnObj = rgObj.ClosestPoint(pt_Picked)\r\n            elif rdObjType_ThisObj == rd.ObjectType.Curve:\r\n                bPt, u = rgObj.ClosestPoint(pt_Picked)\r\n                pt_ClosestOnObj = rgObj.PointAt(u)\r\n            elif rdObjType_ThisObj == rd.ObjectType.Extrusion:\r\n                bPt, u, v = rgObj.ClosestPoint(pt_Picked)\r\n                pt_ClosestOnObj = rgObj.PointAt(u, v)\r\n                pt_ClosestOnObj = rgObj.ClosestPoint(pt_Picked)\r\n            elif rdObjType_ThisObj == rd.ObjectType.Point:\r\n                pt_ClosestOnObj = rgObj.Location\r\n            elif rdObjType_ThisObj == rd.ObjectType.TextDot:\r\n                pt_ClosestOnObj = rgObj.Point\r\n            else:\r\n                rgObj.Dispose()\r\n                continue\r\n\r\n            rgObj.Dispose()\r\n            \r\n            if pt_Picked.DistanceTo(pt_ClosestOnObj) <= sc.doc.ModelAbsoluteTolerance:\r\n                return rdInstObj, xform\r\n        else:\r\n            # Target is not InstanceReference.\r\n            if objTypes_ToAccept & rd.ObjectType.Brep & rdObjType_ThisObj:\r\n                pt_ClosestOnObj = rgObj.ClosestPoint(pt_Picked)\r\n            elif objTypes_ToAccept & rd.ObjectType.Curve & rdObjType_ThisObj:\r\n                bPt, u = rgObj.ClosestPoint(pt_Picked)\r\n                pt_ClosestOnObj = rgObj.PointAt(u)\r\n            elif objTypes_ToAccept & rd.ObjectType.Extrusion & rdObjType_ThisObj:\r\n                bPt, u, v = rgObj.ClosestPoint(pt_Picked)\r\n                pt_ClosestOnObj = rgObj.PointAt(u, v)\r\n            elif objTypes_ToAccept & rd.ObjectType.Point & rdObjType_ThisObj:\r\n                pt_ClosestOnObj = rgObj.Location\r\n            elif objTypes_ToAccept & rd.ObjectType.TextDot & rdObjType_ThisObj:\r\n                pt_ClosestOnObj = rgObj.Point\r\n            else:\r\n                rgObj.Dispose()\r\n                continue\r\n            \r\n            rgObj.Dispose()\r\n            \r\n            if pt_Picked.DistanceTo(pt_ClosestOnObj) <= sc.doc.ModelAbsoluteTolerance:\r\n                return rdObj, xform\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get block instance with optional input\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Pick object of block instance\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.InstanceReference\r\n\r\n    go.DisablePreSelect()\r\n\r\n    go.OneByOnePostSelect = True\r\n\r\n    idxs_Opts = {}\r\n\r\n    def addOption(ric, key): idxs_Opts[key] = Opts.addOption(ric, key)\r\n\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opts.clear()\r\n\r\n        addOption(go, 'bBlockInstance')\r\n        if not Opts.values['bBlockInstance']:\r\n            idxs_Opts['CrvsOnly'] = go.AddOption('CrvsOnly')\r\n            idxs_Opts['BrepsOnly'] = go.AddOption('BrepsOnly')\r\n            idxs_Opts['ObjectFilter'] = go.AddOption('ObjectFilter')\r\n            if Opts.values['bBrep']:\r\n                addOption(go, 'bFace')\r\n        addOption(go, 'bRetainLayer_NotCurrent')\r\n        addOption(go, 'bEcho')\r\n        addOption(go, 'bDebug')\r\n\r\n        sTrue = []\r\n        sFalse = []\r\n        for key in sObjTypes:\r\n            if Opts.values[key]:\r\n                sTrue.append(Opts.names[key])\r\n            else:\r\n                sFalse.append(Opts.names[key])\r\n\r\n        if not Opts.values['bBlockInstance']:\r\n            s  = \"Objects that will ONLY be accepted:\"\r\n            s += \" {}\".format(\", \".join(sTrue) if sTrue else 'None')\r\n            s += \"\\t\\tNOT accepted:\"\r\n            s += \" {}\".format(\", \".join(sFalse) if sFalse else 'None')\r\n            print(s)\r\n\r\n        objTypes_ToAccept = rd.ObjectType.None\r\n        if Opts.values['bBlockInstance']:\r\n            objTypes_ToAccept |= rd.ObjectType.InstanceReference\r\n            objTypes_ToAccept |= rd.ObjectType.Brep\r\n            objTypes_ToAccept |= rd.ObjectType.Curve\r\n            objTypes_ToAccept |= rd.ObjectType.Extrusion\r\n            objTypes_ToAccept |= rd.ObjectType.Point\r\n            objTypes_ToAccept |= rd.ObjectType.TextDot\r\n        else:\r\n            if Opts.values['bBrep']: objTypes_ToAccept |= rd.ObjectType.Brep\r\n            if Opts.values['bCurve']: objTypes_ToAccept |= rd.ObjectType.Curve\r\n            if Opts.values['bExtrusion']: objTypes_ToAccept |= rd.ObjectType.Extrusion\r\n            if Opts.values['bPoint']: objTypes_ToAccept |= rd.ObjectType.Point\r\n            if Opts.values['bTextDot']: objTypes_ToAccept |= rd.ObjectType.TextDot\r\n\r\n        res = go.Get()\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objref = go.Object(0)\r\n            \r\n            rdInstObj = objref.Object()\r\n            \r\n            rc = findPickedObjOfBlockInst(rdInstObj, objTypes_ToAccept, objref.SelectionPoint())\r\n            if not rc:\r\n                print(\"Picked object not found.  Pick again.\")\r\n                continue\r\n\r\n            if objTypes_ToAccept & rd.ObjectType.InstanceReference:\r\n                if rc[0].InstanceDefinition.Index == rdInstObj.InstanceDefinition.Index:\r\n                    print(\"Nested block instance not found.\")\r\n                    go.Dispose()\r\n                    return\r\n\r\n            # Success.\r\n\r\n            rdObj, xform = rc\r\n\r\n            go.Dispose()\r\n\r\n            return (\r\n                rdObj,\r\n                xform,\r\n                Opts.values['bRetainLayer_NotCurrent'],\r\n                Opts.values['bEcho'],\r\n                Opts.values['bDebug'],\r\n                )\r\n\r\n        # An option was selected.\r\n\r\n        if 'CrvsOnly' in idxs_Opts and go.Option().Index == idxs_Opts['CrvsOnly']:\r\n            for key in sObjTypes:\r\n                if key == 'bCurve':\r\n                    Opts.riOpts[key].CurrentValue = True\r\n                else:\r\n                    Opts.riOpts[key].CurrentValue = False\r\n                Opts.setValue(key)\r\n            continue\r\n\r\n        if 'BrepsOnly' in idxs_Opts and go.Option().Index == idxs_Opts['BrepsOnly']:\r\n            for key in sObjTypes:\r\n                if key == 'bBrep':\r\n                    Opts.riOpts[key].CurrentValue = True\r\n                else:\r\n                    Opts.riOpts[key].CurrentValue = False\r\n                Opts.setValue(key)\r\n            continue\r\n\r\n        if 'ObjectFilter' in idxs_Opts and go.Option().Index == idxs_Opts['ObjectFilter']:\r\n\r\n            go_ObjType = ri.Custom.GetOption()\r\n            go_ObjType.SetCommandPrompt(\"Object type(s) to filter\")\r\n\r\n            while True:\r\n                idxs_Opts.clear()\r\n\r\n                addOption(go_ObjType, 'bBlockInstance')\r\n                addOption(go_ObjType, 'bBrep')\r\n                addOption(go_ObjType, 'bCurve')\r\n                addOption(go_ObjType, 'bExtrusion')\r\n                addOption(go_ObjType, 'bPoint')\r\n                addOption(go_ObjType, 'bTextDot')\r\n                idxs_Opts['YesToAll'] = go_ObjType.AddOption('YesToAll')\r\n                idxs_Opts['NoToAll'] = go_ObjType.AddOption('NoToAll')\r\n\r\n                res = go_ObjType.Get()\r\n                if res != ri.GetResult.Option:\r\n                    break\r\n                    \r\n                if go_ObjType.OptionIndex() == idxs_Opts['YesToAll']:\r\n                    for key in sObjTypes:\r\n                        Opts.riOpts[key].CurrentValue = True\r\n                elif go_ObjType.OptionIndex() == idxs_Opts['NoToAll']:\r\n                    for key in sObjTypes:\r\n                        Opts.riOpts[key].CurrentValue = False\r\n\r\n                for key in idxs_Opts:\r\n                    if go_ObjType.Option().Index == idxs_Opts[key]:\r\n                        Opts.setValue(key, go_ObjType.Option().CurrentListOptionIndex)\r\n                        break\r\n\r\n                go_ObjType.ClearCommandOptions()\r\n\r\n            go_ObjType.Dispose()\r\n            continue\r\n\r\n        for key in idxs_Opts:\r\n            if go.Option().Index == idxs_Opts[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n    go.Dispose()\r\n\r\n    return rdObj, rgObj, bRetainLayer_NotCurrent\r\n\r\n\r\ndef processInput(rdObj, xform, bRetainLayer_NotCurrent=True, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    attr = rdObj.Attributes.Duplicate()\r\n    \r\n    if Opts.values['bRetainLayer_NotCurrent']:\r\n        if rdObj.IsReference:\r\n            s  = \"{} is not embedded.\".format(rdObj.ObjectType)\r\n            s += \"  Geometry will be created on the current layer.\"\r\n            print(s)\r\n            attr.LayerIndex = sc.doc.Layers.CurrentLayerIndex\r\n    else:\r\n        attr.LayerIndex = sc.doc.Layers.CurrentLayerIndex\r\n    \r\n    if rdObj.ObjectType == rd.ObjectType.InstanceReference:\r\n        idxInstDef = rdObj.InstanceDefinition.Index\r\n        if rdObj.IsReference:\r\n            # The following doesn't work in a script because per\r\n            # https://discourse.mcneel.com/t/history-in-script/171964/20\r\n            # \"Because history is command based, you might consider writing a plug-in\" ...\r\n            # gObj1 = sc.doc.Objects.AddInstanceObject(\r\n            #     instanceDefinitionIndex=idxInstDef,\r\n            #     instanceXform=xform,\r\n            #     attributes=attr,\r\n            #     history=rd.HistoryRecord(\r\n            #     reference=False)\r\n\r\n            gObj1 = sc.doc.Objects.AddInstanceObject(idxInstDef, xform, attr)\r\n\r\n            # Attempt to embed a reference block.\r\n            #            gObj_eraseme = sc.doc.Objects.AddInstanceObject(idxInstDef, xform)\r\n            #            sc.doc.Objects.Delete(objectId=gObj_eraseme, quiet=True)\r\n            rdObj1 = sc.doc.Objects.FindId(gObj1) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(gObj1)\r\n            # Attempt to embed a reference block.\r\n            #            rdObj1.Attributes = rd.ObjectAttributes()\r\n            #            print(rdObj1.CommitChanges())\r\n            if gObj1 == gObj1.Empty:\r\n                print(\"Error!  {} not added.\".format(rdObj.ObjectType))\r\n                return\r\n            elif sc.doc.Objects.Select(gObj1):\r\n                s  = \"Duplicated {} is selected.\".format(rdObj.ObjectType)\r\n                s += \"  It is a reference, so modify a duplicate of it.\"\r\n                print(s)\r\n                return gObj1\r\n        else:\r\n            gObj1 = sc.doc.Objects.AddInstanceObject(idxInstDef, xform, attr)\r\n    else:\r\n        xformSimilarityType = xform.SimilarityType\r\n        rgObj_Xformed = rdObj.Geometry.Duplicate()\r\n        if xformSimilarityType == rg.TransformSimilarityType.NotSimilarity:\r\n            # ArcCurve is not supported by MakeDeformable.\r\n            if isinstance(rgObj_Xformed, rg.ArcCurve):\r\n                rgObj_Xformed = rgObj_Xformed.ToNurbsCurve()\r\n                if rgObj_Xformed is None:\r\n                    print(\"Error in converting arc curve into NURBS curve!\")\r\n                    return\r\n\r\n            if isinstance(rgObj_Xformed, (rg.PolyCurve, rg.Brep)):\r\n                if not rgObj_Xformed.MakeDeformable():\r\n                    print(\"Error in making {} deformable!\".format(rgObj_Xformed.ObjectType))\r\n                    return\r\n                if not rgObj_Xformed.IsValid:\r\n                    print(\"{} is not valid after MakeDeformable!  Not using MakeDeformable...\".format(rgObj_Xformed.ObjectType))\r\n                    b, sLog = rgObj_Xformed.IsValidWithLog()\r\n                    print(sLog)\r\n                    rgObj_Xformed.Dispose()\r\n                    rgObj_Xformed = rdObj.Geometry.Duplicate()\r\n\r\n        rgObj_Xformed.Transform(xform)\r\n        gObj1 = sc.doc.Objects.Add(rgObj_Xformed, attr)\r\n        rgObj_Xformed.Dispose()\r\n    \r\n    if gObj1 == gObj1.Empty:\r\n        print(\"Error!  {} not added.\".format(rdObj.ObjectType))\r\n        return\r\n    elif sc.doc.Objects.Select(gObj1):\r\n        print(\"Duplicated {} is selected.\".format(rdObj.ObjectType))\r\n    \r\n    return gObj1\r\n\r\n\r\ndef main():\r\n\r\n    rc = getInput()\r\n    if rc is None: return\r\n    (\r\n        rdObj,\r\n        xform,\r\n        bRetainLayer_NotCurrent,\r\n        bEcho,\r\n        bDebug,\r\n        ) = rc\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    processInput(\r\n        rdObj=rdObj,\r\n        xform=xform,\r\n        bRetainLayer_NotCurrent=bRetainLayer_NotCurrent,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}