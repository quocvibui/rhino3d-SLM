{
  "source_url": "https://github.com/compas-dev/compas/blob/HEAD/src/compas_rhino/geometry/curves/curve.py",
  "repo": "compas-dev/compas",
  "repo_stars": 352,
  "repo_description": "Main library of the COMPAS framework and CAD integrations for Rhino/GH and Blender.",
  "license": "MIT",
  "filepath": "src/compas_rhino/geometry/curves/curve.py",
  "instruction": null,
  "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport Rhino.Geometry  # type: ignore\n\nfrom compas.geometry import Curve\nfrom compas.geometry import Plane\nfrom compas_rhino.conversions import box_to_compas\nfrom compas_rhino.conversions import plane_to_compas_frame\nfrom compas_rhino.conversions import plane_to_rhino\nfrom compas_rhino.conversions import point_to_compas\nfrom compas_rhino.conversions import point_to_rhino\nfrom compas_rhino.conversions import transformation_to_rhino\nfrom compas_rhino.conversions import vector_to_compas\n\n\nclass RhinoCurve(Curve):\n    \"\"\"Class representing a general curve object.\n\n    Parameters\n    ----------\n    native_curve : :rhino:`Curve`\n        A Rhino curve.\n    name : str, optional\n        Name of the curve.\n\n    Attributes\n    ----------\n    dimension : int, read-only\n        The spatial dimension of the curve.\n    domain : tuple[float, float], read-only\n        The parameter domain.\n    start : :class:`compas.geometry.Point`, read-only\n        The point corresponding to the start of the parameter domain.\n    end : :class:`compas.geometry.Point`, read-only\n        The point corresponding to the end of the parameter domain.\n    is_closed : bool, read-only\n        True if the curve is closed.\n    is_periodic : bool, read-only\n        True if the curve is periodic.\n\n    Other Attributes\n    ----------------\n    native_curve : :rhino:`Curve`\n        The underlying Rhino curve.\n\n    \"\"\"\n\n    def __init__(self, native_curve, name=None):\n        super(RhinoCurve, self).__init__(name=name)\n        self._native_curve = native_curve\n\n    def __eq__(self, other):\n        return self.native_curve.IsEqual(other.native_curve)  # type: ignore\n\n    # ==============================================================================\n    # Data\n    # ==============================================================================\n\n    # ==============================================================================\n    # Properties\n    # ==============================================================================\n\n    @property\n    def rhino_curve(self):\n        return self._native_curve\n\n    @property\n    def native_curve(self):\n        return self._native_curve\n\n    @native_curve.setter\n    def native_curve(self, curve):\n        self._native_curve = curve\n\n    @property\n    def dimension(self):\n        if self.native_curve:\n            return self.native_curve.Dimension\n\n    @property\n    def domain(self):\n        if self.native_curve:\n            return self.native_curve.Domain.T0, self.native_curve.Domain.T1\n\n    @property\n    def start(self):\n        if self.native_curve:\n            return point_to_compas(self.native_curve.PointAtStart)\n\n    @property\n    def end(self):\n        if self.native_curve:\n            return point_to_compas(self.native_curve.PointAtEnd)\n\n    @property\n    def is_closed(self):\n        if self.native_curve:\n            return self.native_curve.IsClosed\n\n    @property\n    def is_periodic(self):\n        if self.native_curve:\n            return self.native_curve.IsPeriodic\n\n    # ==============================================================================\n    # Constructors\n    # ==============================================================================\n\n    @classmethod\n    def from_native(cls, native_curve):\n        \"\"\"Construct a curve from an existing Rhino curve.\n\n        Parameters\n        ----------\n        native_curve : Rhino.Geometry.Curve\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoCurve`\n\n        \"\"\"\n        return cls(native_curve)\n\n    @classmethod\n    def from_rhino(cls, native_curve):\n        \"\"\"Construct a curve from an existing Rhino curve.\n\n        Parameters\n        ----------\n        native_curve : Rhino.Geometry.Curve\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoCurve`\n\n        Warnings\n        --------\n        .. deprecated:: 2.3\n            Use `from_native` instead.\n\n        \"\"\"\n        return cls(native_curve)\n\n    # ==============================================================================\n    # Conversions\n    # ==============================================================================\n\n    # ==============================================================================\n    # Methods\n    # ==============================================================================\n\n    def copy(self):\n        \"\"\"Make an independent copy of the current curve.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoCurve`\n\n        \"\"\"\n        cls = type(self)\n        native_curve = self.native_curve.Duplicate()\n        return cls.from_native(native_curve)\n\n    def transform(self, T):\n        \"\"\"Transform this curve.\n\n        Parameters\n        ----------\n        T : :class:`compas.geometry.Transformation`\n            A COMPAS transformation.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        self.native_curve.Transform(transformation_to_rhino(T))  # type: ignore\n\n    def reverse(self):\n        \"\"\"Reverse the parametrisation of the curve.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        self.native_curve.Reverse()  # type: ignore\n\n    def point_at(self, t):\n        \"\"\"Compute a point on the curve.\n\n        Parameters\n        ----------\n        t : float\n            The value of the curve parameter. Must be between 0 and 1.\n\n        Returns\n        -------\n        :class:`compas.geometry.Point`\n            the corresponding point on the curve.\n\n        \"\"\"\n        point = self.native_curve.PointAt(t)  # type: ignore\n        return point_to_compas(point)\n\n    def tangent_at(self, t):\n        \"\"\"Compute the tangent vector at a point on the curve.\n\n        Parameters\n        ----------\n        t : float\n            The value of the curve parameter. Must be between 0 and 1.\n\n        Returns\n        -------\n        :class:`compas.geometry.Vector`\n            The corresponding tangent vector.\n\n        \"\"\"\n        vector = self.native_curve.TangentAt(t)  # type: ignore\n        return vector_to_compas(vector)\n\n    def curvature_at(self, t):\n        \"\"\"Compute the curvature at a point on the curve.\n\n        Parameters\n        ----------\n        t : float\n            The value of the curve parameter. Must be between 0 and 1.\n\n        Returns\n        -------\n        :class:`compas.geometry.Vector`\n            The corresponding curvature vector.\n\n        \"\"\"\n        vector = self.native_curve.CurvatureAt(t)  # type: ignore\n        return vector_to_compas(vector)\n\n    def frame_at(self, t):\n        \"\"\"Compute the local frame at a point on the curve.\n\n        Parameters\n        ----------\n        t : float\n            The value of the curve parameter.\n\n        Returns\n        -------\n        :class:`compas.geometry.Frame`\n            The corresponding local frame.\n\n        \"\"\"\n        t, plane = self.native_curve.FrameAt(t)  # type: ignore\n        return plane_to_compas_frame(plane)\n\n    def torsion_at(self, t):\n        \"\"\"Compute the torsion of the curve at a parameter.\n\n        Parameters\n        ----------\n        t : float\n            The value of the curve parameter.\n\n        Returns\n        -------\n        float\n            The torsion value.\n\n        \"\"\"\n        return self.native_curve.TorsionAt(t)  # type: ignore\n\n    # ==============================================================================\n    # Methods continued\n    # ==============================================================================\n\n    def closest_point(self, point, return_parameter=False):\n        \"\"\"Compute the closest point on the curve to a given point.\n\n        Parameters\n        ----------\n        point : :class:`compas.geometry.Point`\n            The test point.\n        return_parameter : bool, optional\n            If True, the parameter corresponding to the closest point should be returned in addition to the point.\n\n        Returns\n        -------\n        :class:`compas.geometry.Point` | tuple[:class:`compas.geometry.Point`, float]\n            If `return_parameter` is False, only the closest point is returned.\n            If `return_parameter` is True, the closest point and the corresponding parameter are returned.\n\n        \"\"\"\n        result, t = self.native_curve.ClosestPoint(point_to_rhino(point))  # type: ignore\n        if not result:\n            return\n        point = self.point_at(t)\n        if return_parameter:\n            return point, t\n        return point\n\n    def divide_by_count(self, count, return_points=False):\n        \"\"\"Divide the curve into a specific number of equal length segments.\n\n        Parameters\n        ----------\n        count : int\n            The number of segments.\n        return_points : bool, optional\n            If True, return the list of division parameters,\n            and the points corresponding to those parameters.\n            If False, return only the list of parameters.\n\n        Returns\n        -------\n        list[float] | tuple[list[float], list[:class:`compas.geometry.Point`]]\n            If `return_points` is False, the parameters of the discretisation.\n            If `return_points` is True, a list of points in addition to the parameters of the discretisation.\n\n        \"\"\"\n        params = self.native_curve.DivideByCount(count, True)  # type: ignore\n        if return_points:\n            points = [self.point_at(t) for t in params]\n            return params, points\n        return params\n\n    def divide_by_length(self, length, return_points=False):\n        \"\"\"Divide the curve into segments of specified length.\n\n        Parameters\n        ----------\n        length : float\n            The length of the segments.\n        return_points : bool, optional\n            If True, return the list of division parameters,\n            and the points corresponding to those parameters.\n            If False, return only the list of parameters.\n\n        Returns\n        -------\n        list[float] | tuple[list[float], list[:class:`compas.geometry.Point`]]\n            If `return_points` is False, the parameters of the discretisation.\n            If `return_points` is True, a list of points in addition to the parameters of the discretisation.\n\n        \"\"\"\n        params = self.native_curve.DivideByLength(length, True)  # type: ignore\n        if return_points:\n            points = [self.point_at(t) for t in params]\n            return params, points\n        return params\n\n    def aabb(self):\n        \"\"\"Compute the axis aligned bounding box of the curve.\n\n        Returns\n        -------\n        :class:`compas.geometry.Box`\n\n        \"\"\"\n        box = self.native_curve.getBoundingBox(True)  # type: ignore\n        return box_to_compas(box)\n\n    def length(self, precision=1e-8):\n        \"\"\"Compute the length of the curve.\n\n        Parameters\n        ----------\n        precision : float, optional\n            Required precision of the calculated length.\n\n        \"\"\"\n        return self.native_curve.GetLength(precision)  # type: ignore\n\n    def fair(self, tol=1e-3):\n        raise NotImplementedError\n\n    def offset(self, distance, direction, tolerance=1e-3):\n        \"\"\"Compute the length of the curve.\n\n        Parameters\n        ----------\n        distance : float\n            The offset distance.\n        direction : :class:`compas.geometry.Vector`\n            The normal direction of the offset plane.\n        tolerance : float, optional\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        point = self.point_at(self.domain[0])  # type: ignore\n        plane = Plane(point, direction)\n        plane = plane_to_rhino(plane)\n        offset_style = Rhino.Geometry.CurveOffsetCornerStyle.NONE\n        self.native_curve = self.native_curve.Offset(plane, distance, tolerance, offset_style)[0]  # type: ignore\n\n    def smooth(self):\n        raise NotImplementedError\n\n    def split(self):\n        raise NotImplementedError\n\n    def trim(self):\n        raise NotImplementedError\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}