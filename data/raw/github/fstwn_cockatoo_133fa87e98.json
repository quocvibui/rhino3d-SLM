{
  "source_url": "https://github.com/fstwn/cockatoo/blob/d952ac5d2148ec29fba52e8eb75f0f43770c74ca/usrobj_src/Cockatoo_VisualisePatternData.py",
  "repo": "fstwn/cockatoo",
  "repo_stars": 38,
  "repo_description": "Cockatoo is a prototypical open-source software toolkit for generating (3d-)knitting patterns from NURBS surface and mesh geometry directly inside Grasshopper.",
  "license": "MIT",
  "filepath": "usrobj_src/Cockatoo_VisualisePatternData.py",
  "instruction": "Draws a custom 2d graph layout of a KnitNetwork and the corresponding 2d pattern\ndata.\n---\n[WARNING!]\nBe careful when using the DrawData parameter. Drawing of text tags is very slow\nin rhino and...",
  "code": "\"\"\"\nDraws a custom 2d graph layout of a KnitNetwork and the corresponding 2d pattern\ndata.\n---\n[WARNING!]\nBe careful when using the DrawData parameter. Drawing of text tags is very slow\nin rhino and since there are a looooot of text tags in such a graph, it may\nbecome unresponsive for quite some time. Definitely save your file before\nswitching this to True!\n    Inputs:\n        KnitNetworkDual: The dual graph of the KnitNetwork.\n                         {item, KnitDiNetwork)\n        PatternData: The topological sorted 2d pattern data optained from the\n                     MakePatternData component.\n                     {item, PatternData}\n        Plane: The plane to draw the graph layout onto.\n               {item, plane}\n        NodeRadius: The radius (i.e. size) of the nodes to draw.\n                    {item, float}\n        NodeDisplay: Display nodes either as circles or as squares.\n                     [0] = circle\n                     [1] = square\n                     {item, int}\n        PaddingX: The spacing between nodes in plane x-direction.\n                  {item, float}\n        PaddingY: The spacing between the nodes in plane y-direction.\n                  {item, float}\n        DirectionalDisplay: Set to True to draw arrows for edges instead of\n                            undirected lines.\n                            {item, bool}\n        DrawData: Set to True to also draw the attributes as text tags. This\n                  can be very slow!\n                  {item, bool}\n    Outputs:\n        FlatDual: A 'falt' version of the KnitNetworkDual where all nodes and\n                  edges are on the defined plane.\n                  {item, KnitDiNetwork}\n        NodeCurves: The circles/squares that are used for drawing the nodes.\n                    {list, curve}\n        WeftEdgeLines: The lines that are used for drawing the 'weft' edges.\n                       {list, line}\n        WarpEdgeLines: The lines that are used for drawing the 'warp' edges.\n                       {list, line}\n        TextTags: If DrawData is True, the text tags with all the attributes of\n                  nodes and edges.\n                  {list, TextGoo}\n    Outputs:\n    Remarks:\n        Author: Max Eschenbach\n        License: MIT License\n        Version: 200813\n\"\"\"\n\n# PYTHON STANDARD LIBRARY IMPORTS\nfrom __future__ import division\nfrom math import sqrt\n\n# GHPYTHON SDK IMPORTS\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\n# ADDITIONAL MODULE IMPORTS\nfrom ghpythonlib import treehelpers as th\nfrom scriptcontext import doc\n\n# GHENV COMPONENT SETTINGS\nghenv.Component.Name = \"VisualisePatternData\"\nghenv.Component.NickName =\"VPD\"\nghenv.Component.Category = \"Cockatoo\"\nghenv.Component.SubCategory = \"08 Visualisation\"\n\n# LOCAL MODULE IMPORTS\ntry:\n    import cockatoo\nexcept ImportError:\n    errMsg = \"The Cockatoo python module seems to be not correctly \" + \\\n             \"installed! Please make sure the module is in you search \" + \\\n             \"path, see README for instructions!.\"\n    raise ImportError(errMsg)\n\nclass TextGoo(Grasshopper.Kernel.Types.GH_GeometricGoo[Rhino.Display.Text3d], Grasshopper.Kernel.IGH_BakeAwareData, Grasshopper.Kernel.IGH_PreviewData):\n    \"\"\"\n    Custom TextGoo class.\n    Based on an example by Giulio Piacentino & David Rutten.\n    https://discourse.mcneel.com/t/creating-text-objects-and-outputting-them-as-normal-rhino-geometry/47834/10\n    \"\"\"\n    \n    #region construction\n    def __init__(self, text):\n        self.m_value = text\n    \n    @staticmethod\n    def DuplicateText3d(original):\n        if original is None: return None\n        text = Rhino.Display.Text3d(original.Text, original.TextPlane, original.Height)\n        text.Bold = original.Bold,\n        text.Italic = original.Italic,\n        text.FontFace = original.FontFace\n        return text\n    \n    def DuplicateGeometry(self):\n        return TextGoo(TextGoo.DuplicateText3d(self.m_value))\n    \n    #region properties\n    def get_TypeName(self):\n        return \"3D Text\"\n        \n    def get_TypeDescription(self):\n        return \"3D Text\"\n    \n    def ToString(self):\n        if self.m_value is None: return \"<null>\"\n        return self.m_value.Text\n        \n    def get_Boundingbox(self):\n        if self.m_value is None:\n            return Rhino.Geometry.BoundingBox.Empty;\n        return self.m_value.BoundingBox;\n        \n    def GetBoundingBox(self, xform):\n        if self.m_value is None:\n            return Rhino.Geometry.BoundingBox.Empty\n        box = self.m_value.BoundingBox\n        corners = xform.TransformList(box.GetCorners())\n        return Rhino.Geometry.BoundingBox(corners)\n    \n    #region methods\n    def Transform(self, xform):\n        text = TextGoo.DuplicateText3d(self.m_value)\n        if text is None: return TextGoo(None)\n        \n        plane = text.TextPlane\n        point = plane.PointAt(1, 1)\n        \n        plane.Transform(xform)\n        point.Transform(xform)\n        dd = point.DistanceTo(plane.Origin)\n        \n        text.TextPlane = plane;\n        text.Height *= dd / sqrt(2)\n        return TextGoo(text)\n        \n    def Morph(self, xmorph):\n        return self.DuplicateGeometry()\n\n    #region preview\n    def get_ClippingBox(self):\n        return self.get_Boundingbox()\n        \n    def DrawViewportWires(self, args):\n        if self.m_value is None: return\n        args.Pipeline.Draw3dText(self.m_value, args.Color)\n      \n    def DrawViewportMeshes(self, args):\n        # Do not draw in meshing layer.\n        pass\n\n    #region baking\n    def BakeGeometry(self, doc, att, id):\n        id = System.Guid.Empty\n        \n        if self.m_value is None:\n            return false, id\n        \n        if att is None:\n            att = doc.CreateDefaultAttributes()\n        \n        id = doc.Objects.AddText(self.m_value, att)\n        \n        return True, id\n\n\nclass VisualisePatternData(component):\n    \n    def __init__(self):\n        super(VisualisePatternData, self).__init__()\n        \n        self.drawing_nodes = []\n        self.drawing_edges = []\n        self.drawing_data = []\n        self.draw_directional = False\n        self.node_display = 0\n    \n    def get_ClippingBox(self):\n        return Rhino.Geometry.BoundingBox()\n    \n    def DrawViewportWires(self, args):\n        try:\n            # get display from args\n            display = args.Display\n            \n            # draw all catalogued nodes\n            for node in self.drawing_nodes:\n                node_display = self.node_display\n                if node_display == 0:\n                #display.DrawPoint(node[0], node[1], node[2], node[3])\n                    display.DrawCircle(node[0], node[1])\n                elif node_display == 1:\n                    display.DrawCurve(node[0], node[1])\n            \n            # draw all catalogued edges\n            if self.draw_directional:\n                for edge in self.drawing_edges:\n                    display.DrawArrow(edge[0], edge[1])\n            else:\n                for edge in self.drawing_edges:\n                    display.DrawLine(edge[0], edge[1], 2)\n            \n            # draw all catalogued data text tags\n            for txtag in self.drawing_data:\n                if display.IsVisible(txtag[0].TextPlane.Origin):\n                    display.Draw3dText(txtag[0], txtag[1])\n        \n        except Exception, e:\n            System.Windows.Forms.MessageBox.Show(str(e),\n                                                 \"Error while drawing preview!\")\n    \n    def node_color(self, data):\n        \"\"\"\n        checks the node and returns the appropriate drawing color\n        \"\"\"\n        \n        # define colours for nodes and node texts\n        colStart = System.Drawing.Color.Green\n        colStartLeaf = System.Drawing.Color.SeaGreen\n        colStartLeafEnd = System.Drawing.Color.Orange\n        colStartEnd = System.Drawing.Color.DarkGreen\n        colEnd = System.Drawing.Color.Blue\n        colLeaf = System.Drawing.Color.Cyan\n        colEndLeaf = System.Drawing.Color.Magenta\n        colRegular = System.Drawing.Color.Black\n        colIncreaseEnd = System.Drawing.Color.Purple\n        colDecreaseEnd = System.Drawing.Color.DarkViolet\n        colIncrease = System.Drawing.Color.Red\n        colDecrease = System.Drawing.Color.DarkRed\n        \n        # END BUT NOT LEAF\n        if data[\"end\"] and not data[\"leaf\"]:\n            if not data[\"increase\"] and not data[\"decrease\"]:\n                if data[\"start\"]:\n                    nodecol = colStartEnd\n                else:\n                    nodecol = colEnd\n            elif data[\"increase\"] and not data[\"decrease\"]:\n                nodecol = colIncreaseEnd\n            elif not data[\"increase\"] and data[\"decrease\"]:\n                nodecol = colDecreaseEnd\n        # END AND LEAF\n        elif data[\"end\"] and data[\"leaf\"]:\n            if data[\"start\"]:\n                nodecol = colStartLeafEnd\n            else:\n                nodecol = colEndLeaf\n        # NO END BUT LEAF\n        elif not data[\"end\"] and data[\"leaf\"]:\n            if data[\"start\"]:\n                nodecol = colStartLeaf\n            else:\n                nodecol = colLeaf\n        # NO END NO LEAF\n        elif not data[\"end\"] and not data[\"leaf\"]:\n            if data[\"increase\"] and not data[\"decrease\"]:\n                nodecol = colIncrease\n            elif not data[\"increase\"] and data[\"decrease\"]:\n                nodecol = colDecrease\n            else:\n                if data[\"color\"]:\n                    nodecol = System.Drawing.Color.FromArgb(\n                                                *data[\"color\"])\n                else:\n                    nodecol = colRegular\n        \n        # return the color\n        return nodecol\n    \n    def RunScript(self, KnitNetworkDual, PatternData, Plane, NodeRadius, NodeDisplay, PaddingX, PaddingY, DirectionalDisplay, DrawData):\n        \n        # set defaults and catch missing params\n        if NodeRadius == None:\n            NodeRadius = 0.1\n        if PaddingX == None:\n            PaddingX = NodeRadius * 1.5\n        if PaddingY == None:\n            PaddingY = NodeRadius * 1.5\n        if NodeDisplay == None or NodeDisplay < 0:\n            NodeDisplay = 0\n        elif NodeDisplay > 1:\n            NodeDisplay = 1\n        if DirectionalDisplay == None:\n            DirectionalDisplay = False\n        if Plane == None:\n            Plane = Rhino.Geometry.Plane.WorldXY\n        \n        self.drawing_nodes = []\n        self.drawing_edges = []\n        self.drawing_data = []\n        \n        # set directional display\n        self.draw_directional = DirectionalDisplay\n        self.node_display = NodeDisplay\n        \n        # set font faces for display/drawing\n        nodeFontFace = \"Helvetica\"\n        contourFontFace = \"Helvetica\"\n        weftFontFace = \"Helvetica\"\n        warpFontFace = \"Helvetica\"\n        \n        # set edge colors for display/drawing\n        contourcol = System.Drawing.Color.Gray\n        weftcol = System.Drawing.Color.Blue\n        warpcol = System.Drawing.Color.Red\n        \n        # create a copy version of the knitnetwork\n        FlatDual = cockatoo.KnitDiNetwork(KnitNetworkDual)\n        \n        if FlatDual and PatternData:\n            \n            # set origin\n            origin = Plane.Origin\n            origin += Plane.XAxis * NodeRadius\n            origin += Plane.YAxis * NodeRadius\n            \n            # modify the padding according to node radius\n            PaddingX += NodeRadius * 2\n            PaddingY += NodeRadius * 2\n            \n            # create containers for the geometry data\n            grid = [[] for row in PatternData]\n            GraphNodes = []\n            edgelines = []\n            \n            # create containers for the drawing data\n            node_drawing_list = []\n            edge_drawing_list = []\n            data_drawing_list = []\n            \n            # loop over all the rows of the pattern data\n            for i, row in enumerate(PatternData):\n                # compute the y-coordinate\n                yval = PaddingY * i\n                \n                # loop over all items in the current row (columns)\n                for j, value in enumerate(row):\n                    # if the current value is not a placeholder, set the flat node\n                    # coordinates and create the node in the layout\n                    if value >= 0:\n                        # compute point location for flat layout\n                        pt = origin + Rhino.Geometry.Vector3d(PaddingX * j, yval, 0)\n                        \n                        # append point to output list\n                        grid[i].append(pt)\n                        \n                        # set the node coordinates of the flat network\n                        FlatDual.node[value][\"geo\"] = pt\n                        FlatDual.node[value][\"x\"] = pt.X\n                        FlatDual.node[value][\"y\"] = pt.Y\n                        FlatDual.node[value][\"z\"] = pt.Z\n                        \n                        # create the display geometry\n                        if NodeDisplay == 0:\n                            graphnode = Rhino.Geometry.Circle(pt, NodeRadius)\n                        elif NodeDisplay == 1:\n                            recpln = Plane.Clone()\n                            recpln.Origin = pt\n                            recinterval = Rhino.Geometry.Interval(NodeRadius * -1,\n                                                                  NodeRadius)\n                            graphnode = Rhino.Geometry.Rectangle3d(recpln,\n                                                                   recinterval,\n                                                                   recinterval)\n                            graphnode = graphnode.ToNurbsCurve()\n                        # append geometry to output list\n                        GraphNodes.append(graphnode)\n                        \n                        # get the node data from the dual\n                        node_data = FlatDual.node[value]\n                        node_color = self.node_color(node_data)\n                        node_drawing_list.append((graphnode, node_color))\n                        \n                        if DrawData:\n                            NodeTextPlane = Plane.Clone()\n                            NodeTextPlane.Origin = (pt + \n                                Rhino.Geometry.Vector3d(NodeRadius * -0.33,\n                                                        NodeRadius * 0.5,\n                                                        0))\n                            tagTxt = Rhino.Display.Text3d(str(value),\n                                                              NodeTextPlane,\n                                                              NodeRadius * 0.15)\n                            tagTxt.FontFace = \"Source Sans Pro\"\n                            data_drawing_list.append((tagTxt, node_color))\n                            \n                            nodeLabel = [(k, node_data[k]) for k in node_data\n                                         if k != \"geo\" and\n                                            k != \"x\" and\n                                            k != \"y\" and\n                                            k != \"z\"]\n                            nodeLabel = [\"{}: {}\".format(t[0], t[1])\n                                         for t in nodeLabel]\n                            nodeLabel.sort()\n                            nodeLabel = [\"\", \"\"] + nodeLabel\n                            nodeLabel = \"\\n\".join(nodeLabel)\n                            nodeTxt = Rhino.Display.Text3d(str(nodeLabel),\n                                                          NodeTextPlane,\n                                                          NodeRadius * 0.06)\n                            nodeTxt.FontFace = \"Source Sans Pro\"\n                            data_drawing_list.append((nodeTxt, node_color))\n                        \n                    else:\n                        continue\n            \n            WeftEdgeLines = []\n            WarpEdgeLines = []\n            \n            # loop over all edges in the dual and create the flat geometry\n            # for the layout\n            for edge in FlatDual.edges_iter(data=True):\n                # get from and to point\n                ptA = FlatDual.node[edge[0]][\"geo\"]\n                ptB = FlatDual.node[edge[1]][\"geo\"]\n                # create line\n                ln = Rhino.Geometry.Line(ptA, ptB)\n                edge[2][\"geo\"] = ln\n                # shorten line according to node radius\n                ln = Rhino.Geometry.Line(ln.PointAtLength(NodeRadius),\n                                         ln.PointAtLength(ln.Length - NodeRadius))\n                # create drawing display\n                if not edge[2][\"weft\"] and not edge[2][\"warp\"]:\n                    edge_drawing_list.append((ln, contourcol))\n                    \n                    \n                    data_drawing_list.append((tagTxt, contourcol))\n                elif edge[2][\"weft\"]:\n                    WeftEdgeLines.append(ln)\n                    edge_drawing_list.append((ln, weftcol))\n                    \n                    if DrawData:\n                        EdgeTextPlane = Plane.Clone()\n                        EdgeTextPlane.Origin = (ln.PointAt(0.5) \n                                                - Rhino.Geometry.Vector3d(\n                                                            NodeRadius * 0.4,\n                                                            NodeRadius * 0.2,\n                                                            0))\n                        edgeLabel = [(k, edge[2][k]) for k\n                                     in edge[2] if k != \"geo\"]\n                        edgeLabel = [\"{}: {}\".format(t[0], t[1]) for t\n                                     in edgeLabel]\n                        edgeLabel.sort()\n                        edgeLabel = [str(edge[0]) + \"-\" +\n                                     str(edge[1])] + edgeLabel\n                        edgeLabel = \"\\n\".join(edgeLabel)\n                        tagTxt = Rhino.Display.Text3d(str(edgeLabel),\n                                                      EdgeTextPlane,\n                                                      NodeRadius * 0.09)\n                        tagTxt.FontFace = \"Source Sans Pro\"\n                        data_drawing_list.append((tagTxt, weftcol))\n                    \n                elif edge[2][\"warp\"]:\n                    WarpEdgeLines.append(ln)\n                    edge_drawing_list.append((ln, warpcol))\n                    \n                    if DrawData:\n                        EdgeTextPlane = Plane.Clone()\n                        EdgeTextPlane.Origin = (ln.PointAt(0.5) \n                                                + Rhino.Geometry.Vector3d(\n                                                            NodeRadius * 0.1,\n                                                            NodeRadius * 0.2,\n                                                            0))\n                        edgeLabel = [(k, edge[2][k]) for k\n                                     in edge[2] if k != \"geo\"]\n                        edgeLabel = [\"{}: {}\".format(t[0], t[1]) for t\n                                     in edgeLabel]\n                        edgeLabel.sort()\n                        edgeLabel = [str(edge[0]) + \"-\" +\n                                     str(edge[1])] + edgeLabel\n                        edgeLabel = \"\\n\".join(edgeLabel)\n                        tagTxt = Rhino.Display.Text3d(str(edgeLabel),\n                                                      EdgeTextPlane,\n                                                      NodeRadius * 0.09)\n                        tagTxt.FontFace = \"Source Sans Pro\"\n                        data_drawing_list.append((tagTxt, warpcol))\n            \n            # set attributes and draw\n            self.drawing_nodes = node_drawing_list\n            self.drawing_edges = edge_drawing_list\n            self.drawing_data = data_drawing_list\n            \n            TextTags = [TextGoo(t[0]) for t in data_drawing_list]\n            \n            # return outputs if you have them; here I try it for you:\n            return FlatDual, GraphNodes, WeftEdgeLines, WarpEdgeLines, TextTags\n        \n        else:\n            self.drawing_nodes = []\n            self.drawing_edges = []\n            self.drawing_data = []\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}