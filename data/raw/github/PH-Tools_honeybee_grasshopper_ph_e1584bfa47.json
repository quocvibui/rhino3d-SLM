{
  "source_url": "https://github.com/PH-Tools/honeybee_grasshopper_ph/blob/c433bc8e66f3a51fd05ee4c485f4c54c03d2a569/honeybee_ph_rhino/make_spaces/make_floor_segment.py",
  "repo": "PH-Tools/honeybee_grasshopper_ph",
  "repo_stars": 6,
  "repo_description": "Honeybe-PH plugin for Rhino / Grasshopper ",
  "license": "GPL-3.0",
  "filepath": "honeybee_ph_rhino/make_spaces/make_floor_segment.py",
  "instruction": "Functions to create SpaceFloorSegment objects from Rhino/Grasshopper inputs.",
  "code": "# -*- coding: utf-8 -*-\n# -*- Python Version: 2.7 -*-\n\n\"\"\"Functions to create SpaceFloorSegment objects from Rhino/Grasshopper inputs.\"\"\"\n\ntry:\n    from typing import Any, List\nexcept ImportError:\n    pass  # IronPython\n\nfrom honeybee_ph import space\nfrom ladybug_geometry.geometry3d import face, pointvector\nfrom ladybug_rhino.fromgeometry import from_face3d, from_point3d\n\nfrom honeybee_ph_rhino import gh_io\n\n\ndef calc_reference_point(IGH, _face3D):\n    # type: (gh_io.IGH, face.Face3D) -> pointvector.Point3D\n    \"\"\"Find the 'reference point' for a Face3D.\n\n    For rectangular Face3D objects, this is the center point. For irregular shaped Face3D\n    objects ('L', 'T', 'O', etc...) this will use the Rhino 'PullPoint' to project the\n    center to the nearest surface edge. This ensure thats the reference point is always\n    'on' the Face3D itself.\n\n    Arguments:\n    ----------\n        * IGH (gh_io.IGH): The Grasshopper Interface object.\n        * _face3D (face.Face3D): The Ladybug Face3D object for the SpaceFloorSegment.\n\n    Returns:\n    -------\n        * (pointvector.Point3D): The Reference Point found.\n    \"\"\"\n\n    # -------------------------------------------------------------------------\n    # -- Find the normal centerpoint of the surface\n    face_cent_rh_pt = from_point3d(_face3D.center)\n    face_rh = from_face3d(_face3D)\n\n    # -------------------------------------------------------------------------\n    # -- 'Pull' the point onto the nearest surface edge\n    new_cp = IGH.ghpythonlib_components.PullPoint(face_cent_rh_pt, face_rh).closest_point\n\n    # -------------------------------------------------------------------------\n    # -- Move the point a little more ( + 0.01) in the direction of the 'pull'\n    # -- to ensure the reference point is 'in' the space volume brep\n    MOVE_DISTANCE = 0.01\n    pull_vector, pull_length = IGH.ghpythonlib_components.Vector2Pt(face_cent_rh_pt, new_cp, False)\n\n    pull_vector = IGH.ghpythonlib_components.Amplitude(pull_vector, MOVE_DISTANCE)\n    new_cp = IGH.ghpythonlib_components.Move(new_cp, pull_vector).geometry\n\n    return pointvector.Point3D(new_cp.X, new_cp.Y, new_cp.Z)\n\n\ndef create_floor_segment_from_rhino_geom(IGH, _flr_segment_geom, _weighting_factors, _net_areas):\n    # type: (gh_io.IGH, List[Any], List[float], List[float | None]) -> List[space.SpaceFloorSegment]\n    \"\"\"Return a list of SpaceFloorSegments created from Rhino geometry.\n\n    Arguments:\n    ----------\n        * IGH (gh_io.IGH): The Grasshopper Interface Object.\n        * _flr_segment_geom (List[Any]): A list of Rhino Geometry representing\n            the floor-segments.\n        * _weighting_factors (List[float]): A List of the weighting-factors (0.0-1.0)\n            to apply to the floor segments. Note: the length of this list should match the\n            _flr_segment_geom length.\n        * _net_areas (List[float | None]): A list of the net-areas for each of the floor\n            segments. If no net-area is provided, this should be set to None.\n\n    Returns:\n    --------\n        * list[space.SpaceFloorSegment]: A list of the new SpaceFloorSegments\n            created from the input Rhino geometry.\n    \"\"\"\n\n    # -- Convert the input surfaces to LBT Geom\n    # -- Note: convert_to_LBT_geom() returns a list of lists since the\n    # -- to_face3d might return a list of triangulated srfcs sometimes.\n    lbt_face_3ds = IGH.convert_to_LBT_geom(_flr_segment_geom)  # type: List[List[face.Face3D]]\n\n    # TODO: probably need to type check of validate that they are all\n    # Face3Ds here before moving on? Give useful warnings.\n\n    # -- Check weighting factors\n    assert len(lbt_face_3ds) == len(\n        _weighting_factors\n    ), \"Error: input lists of floor-segments and weighting-factors do not have matching length?\"\n\n    # -- Check net-area factors\n    assert len(lbt_face_3ds) == len(\n        _net_areas\n    ), \"Error: input lists of floor-segments and net-areas do not have matching length?\"\n\n    # -- Create new SpaceFloorSegments for each surface input\n    flr_segments = []\n    for i, face_3d_list in enumerate(lbt_face_3ds):\n        for face_3d in face_3d_list:\n            new_segment = space.SpaceFloorSegment()\n            new_segment.geometry = face_3d\n            new_segment.reference_point = calc_reference_point(IGH, face_3d)\n            new_segment.weighting_factor = _weighting_factors[i]\n\n            _net_area = _net_areas[i]\n            if _net_area is not None:\n                try:\n                    net_area_factor = _net_area / face_3d.area\n                except ZeroDivisionError:\n                    net_area_factor = 1.0\n                new_segment.net_area_factor = net_area_factor\n\n            flr_segments.append(new_segment)\n\n    return flr_segments\n",
  "language": "python",
  "imports": [
    "ghpythonlib"
  ],
  "has_docstring": true
}