{
  "source_url": "https://github.com/StudioClue/Book_Generator/blob/3ac4e3509ba7cc9b9605ae8b4460254ae5880ee9/Random_Book_Generator.py",
  "repo": "StudioClue/Book_Generator",
  "repo_stars": 0,
  "repo_description": "This script generates books along a custom curved shelf using three guide curves in Rhino Grasshopper. Each book has randomized dimensions, adaptive orientation, and automatic collision prevention. Includes optional color assignment for visual clarity using Custom Preview.",
  "license": "MIT",
  "filepath": "Random_Book_Generator.py",
  "instruction": "Random book generator",
  "code": "import Rhino.Geometry as rg\r\nimport random\r\n\r\n# === INPUTS ===\r\nbf_crv = bottom_front  # Front bottom edge curve\r\nbb_crv = bottom_back   # Back bottom edge curve\r\ntb_crv = top_back      # Back top curve\r\n\r\n# === SETTINGS ===\r\nbook_min_w = 20.0\r\nbook_max_w = 40.0\r\nbook_min_h = 30.0\r\nbook_max_h = 36.0\r\nbook_min_t = 0.8\r\nbook_max_t = 5.0\r\nmax_books = 150\r\ntolerance = 0.001\r\n\r\nbooks = []\r\n\r\n# === Utility: Create a plane surface perpendicular to bookshelf direction ===\r\ndef create_section_surface(origin, normal, size=50.0):\r\n    normal.Unitize()\r\n    x_guess = rg.Vector3d(1, 0, 0) if abs(normal * rg.Vector3d(1, 0, 0)) < 0.99 else rg.Vector3d(0, 1, 0)\r\n    x_axis = rg.Vector3d.CrossProduct(x_guess, normal)\r\n    x_axis.Unitize()\r\n    y_axis = rg.Vector3d.CrossProduct(normal, x_axis)\r\n    return rg.PlaneSurface(rg.Plane(origin, x_axis, y_axis), rg.Interval(-size, size), rg.Interval(-size, size))\r\n\r\n# === Initial Section ===\r\nstart_pt = bf_crv.PointAtStart\r\nnext_pt = bf_crv.PointAt(bf_crv.Domain.T0 + 0.01 * bf_crv.Domain.Length)\r\ninitial_normal = next_pt - start_pt\r\ncurr_srf = create_section_surface(start_pt, initial_normal)\r\n\r\n# === Main Loop ===\r\nfor i in range(max_books):\r\n    bf_result = rg.Intersect.Intersection.CurveSurface(bf_crv, curr_srf, tolerance, tolerance)\r\n    bb_result = rg.Intersect.Intersection.CurveSurface(bb_crv, curr_srf, tolerance, tolerance)\r\n\r\n    if not (bf_result and bb_result) or bf_result.Count == 0 or bb_result.Count == 0:\r\n        break\r\n\r\n    pt_front = bf_result[0].PointA\r\n    pt_back = bb_result[0].PointA\r\n    success, t = tb_crv.ClosestPoint(pt_back)\r\n    if not success:\r\n        break\r\n    pt_top = tb_crv.PointAt(t)\r\n\r\n    book_w = random.uniform(book_min_w, book_max_w)\r\n    base_vec = pt_front - pt_back\r\n    base_vec.Unitize()\r\n    pt_scaled = pt_back + base_vec * book_w\r\n    base_line_scaled = rg.Line(pt_back, pt_scaled)\r\n\r\n    book_h = random.uniform(book_min_h, book_max_h)\r\n    height_vec = pt_top - pt_back\r\n    height_vec.Unitize()\r\n    height_vec *= book_h\r\n\r\n    base_crv = rg.LineCurve(base_line_scaled)\r\n    moved_crv = base_crv.DuplicateCurve()\r\n    moved_crv.Transform(rg.Transform.Translation(height_vec))\r\n\r\n    loft = rg.Brep.CreateFromLoft([base_crv, moved_crv], rg.Point3d.Unset, rg.Point3d.Unset, rg.LoftType.Normal, False)\r\n    if not loft or len(loft) == 0:\r\n        break\r\n    height_brep = loft[0]\r\n\r\n    # Overlap pushback\r\n    if i > 0:\r\n        intersection = rg.Intersect.Intersection.BrepBrep(books[-1], height_brep, tolerance)\r\n        if intersection:\r\n            inter_crvs = intersection[1]\r\n            inter_srfs = intersection[2]\r\n            max_push = 5.0\r\n            step = 0.01\r\n            move_count = 0\r\n            face = height_brep.Faces[0]\r\n            u, v = face.Domain(0).Mid, face.Domain(1).Mid\r\n            normal = face.NormalAt(u, v)\r\n            normal.Unitize()\r\n            while (len(inter_crvs) > 1 or len(inter_srfs) > 0) and move_count * step < max_push:\r\n                xform = rg.Transform.Translation(normal * step)\r\n                height_brep.Transform(xform)\r\n                moved_crv.Transform(xform)\r\n                intersection = rg.Intersect.Intersection.BrepBrep(books[-1], height_brep, tolerance)\r\n                inter_crvs = intersection[1]\r\n                inter_srfs = intersection[2]\r\n                move_count += 1\r\n\r\n    face = height_brep.Faces[0]\r\n    book_t = random.uniform(book_min_t, book_max_t)\r\n    book_brep = rg.Brep.CreateFromOffsetFace(face, book_t, tolerance, False, True)\r\n    if not book_brep or book_brep.Faces.Count == 0:\r\n        break\r\n\r\n    books.append(book_brep)\r\n\r\n    # Update section surface from midpoint of last book face\r\n    face = book_brep.Faces[0]\r\n    u_dom = face.Domain(0)\r\n    v_dom = face.Domain(1)\r\n    u_mid = (u_dom.T0 + u_dom.T1) / 2.0\r\n    v_mid = (v_dom.T0 + v_dom.T1) / 2.0\r\n    origin = face.PointAt(u_mid, v_mid)\r\n    normal = face.NormalAt(u_mid, v_mid)\r\n    curr_srf = create_section_surface(origin, normal)\r\n\r\n# === Final Check: Remove last book if it overlaps with second last ===\r\nif len(books) >= 2:\r\n    last = books[-1]\r\n    second_last = books[-2]\r\n    result = rg.Intersect.Intersection.BrepBrep(second_last, last, tolerance)\r\n    if result:\r\n        inter_crvs = result[1]\r\n        inter_srfs = result[2]\r\n        if len(inter_crvs) > 0 or len(inter_srfs) > 0:\r\n            books.pop()\r\n\r\n# === OUTPUT ===\r\na = books\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}