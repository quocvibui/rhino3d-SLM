{
  "source_url": "https://github.com/JanMeow/BFH_Reuse24/blob/8ee5b5647d3500e8ac32686766bd46658e59ac11/Kevin/demoSeries/demo_wallSystem_02032024/py/innerMaterialGenerate.py",
  "repo": "JanMeow/BFH_Reuse24",
  "repo_stars": 0,
  "repo_description": "BFH 24 Spring Studio Scripts Development",
  "license": "MIT",
  "filepath": "Kevin/demoSeries/demo_wallSystem_02032024/py/innerMaterialGenerate.py",
  "instruction": "Inner material generate",
  "code": "import Rhino.Geometry as rg\nfrom ghpythonlib.components import Area, SurfaceClosestPoint, EvaluateSurface, SurfaceSplit, Extrude, OffsetCurve, BoundarySurfaces, TrimwithRegions, JoinCurves, RegionDifference, AlignPlane, EvaluateLength, LineSDL, Project, RegionUnion, ProjectPoint, PullPoint, BrepEdges, CurveProximity, JoinCurves\nimport ghpythonlib.treehelpers as th\nimport math\nfrom copy import copy, deepcopy\nfrom Grasshopper.Kernel.Data import GH_Path\nfrom Grasshopper import DataTree\nimport System.Array as array\nfrom itertools import chain\nimport random\nfrom collections import Counter\n\nimport sys\nimport os\n\nclass InnerMaterialGenerate:\n    def __init__(self, DB, surfaceList, materialList, thicknessList, moduleDistance=None, wallFrame=None, claddingDirection=None, moduleCurve=[], moduleCrvDist=10, ifModule=False):\n        print(\"class of innerMaterialGenerate is running\")\n        self.boardDB = DB[\"boardDB\"]\n        self.surfaceList = surfaceList\n        self.materialList = materialList\n        self.thicknessList = thicknessList\n        self.moduleDistance = moduleDistance\n        self.wallFrame = wallFrame\n        self.claddingDirection = claddingDirection\n        self.moduleCurve = moduleCurve\n        self.moduleCrvDist = moduleCrvDist\n        self.ifModule = ifModule\n\n\n        basePlane = [self.wallFrame]\n        boardGeoList = []\n        substructInfillGeoList = []\n        paintGeoList = []\n        substructGeoList = []\n        claddingGeoList = []\n        self.materialInfoDict = {}\n        layerTree = DataTree[object]()\n        layerTreeModule = DataTree[object]()\n\n        self.checkGeo = []\n\n        for self.layerId, (srfList, matList) in enumerate(zip(self.surfaceList, self.materialList)):\n            mat = matList\n            srfList = [srfList]\n            \n            allTypeGeo = []\n            for entireSrf_id, entireSrf in enumerate(srfList):\n                workPlane = basePlane[entireSrf_id]\n                matType = mat.materialType\n                \n\n                # Splite surface into several module\n                if ifModule == True:\n                    if len(self.moduleCurve) != 0:\n                        srf_List = self.create_module_byCurve(entireSrf, workPlane, self.moduleCurve, self.moduleCrvDist)\n                    elif self.moduleDistance != None:\n                        srf_List = self.create_module_withDistance(entireSrf, workPlane, self.moduleDistance)\n                    else:\n                        srf_List = [entireSrf]\n                else:\n                    srf_List = [entireSrf]\n\n\n                if self.layerId not in self.materialInfoDict:\n                    self.materialInfoDict[self.layerId] = {}\n\n                for self.module_id, srf in enumerate(srf_List):\n                    if self.module_id not in self.materialInfoDict[self.layerId]:\n                        self.materialInfoDict[self.layerId][self.module_id] = {}\n\n                    allTypeGeoModule = []\n                    if matType == \"board\":\n                        \n                        useWidth, useLength, useDepth, useMatAttr, useDirect, usePt = mat.width, mat.length, mat.thickness, mat.attrList, mat.direction, mat.pt\n\n                        # print(useMatAttr.uuid)\n                        boardGeo = self.create_board(srf, workPlane, useLength, useWidth, useDepth, useDirect, useMatAttr, usePt)\n                        boardGeoList.append(boardGeo)\n                        allTypeGeo.append(boardGeo)\n                        allTypeGeoModule.append(boardGeo)\n                        \n                    elif matType == \"substructInfill\":\n                        useWidth, useDepth, useMatAttr, useDirect, useDist = mat.width, mat.thickness, mat.attrList, mat.direction, mat.distance\n\n                        panelGeo, beamGeo = self.create_substructInfill(srf, workPlane, useWidth, useDepth, useDist, useDirect, useMatAttr)\n                        substructInfillGeoList.append(beamGeo)\n                        substructInfillGeoList.append(panelGeo)\n                        allTypeGeo.append(beamGeo)\n                        allTypeGeo.append(panelGeo)\n                        li = []\n                        li.extend(beamGeo)\n                        li.extend(panelGeo)\n                        allTypeGeoModule.append(li)\n\n                    elif matType == \"paint\":\n                        paintGeo = self.create_paint(srf, workPlane, mat.thickness, mat.attrList)\n                        paintGeoList.append([paintGeo])\n                        allTypeGeo.append([paintGeo])\n                        allTypeGeoModule.append([paintGeo])\n                        \n                    elif matType == \"substruct\":\n                        useWidth, useDepth, useMatAttr, useDirect, useDist = mat.width, mat.thickness, mat.attrList, mat.direction, mat.distance\n\n                        substructGeo = self.create_substruct(srf, workPlane, useWidth, useDepth, useDist, useDirect, useMatAttr)\n                        substructGeoList.append(substructGeo)\n                        allTypeGeo.append(substructGeo)\n                        allTypeGeoModule.append(substructGeo)\n                    \n                    path_module = GH_Path(array[int]([self.layerId, self.module_id]))\n                    layerTreeModule.AddRange(allTypeGeoModule, path_module)\n                    \n                \n            path = GH_Path(array[int]([0,0,self.layerId]))\n            layerTree.AddRange(allTypeGeo, path)\n                \n        self.allTypeMaterial = layerTree\n        self.allTypeMaterialModule = layerTreeModule\n        \n\n    def create_module_byCurve(self, surface, base_plane, curves, crvDist):\n        newCurve = []\n        midPtList = []\n        oriCurve = []\n        for crv in curves:\n            midPtList.append(crv.PointAtNormalizedLength(0.5))\n            crv = crv.Extend(rg.CurveEnd.Start, 10000, 0)\n            crv = crv.Extend(rg.CurveEnd.End, 10000, 0)\n            oriCurve.append(crv)\n            crv1 = crv.Offset(base_plane, crvDist/2, 0.1, 0)[0]\n            crv2 = crv.Offset(base_plane, -crvDist/2, 0.1, 0)[0]\n            newCurve.append(crv1)\n            newCurve.append(crv2)\n\n        projectMidPt = ProjectPoint(midPtList, base_plane.ZAxis, surface)[0]\n        if isinstance(projectMidPt, rg.Point3d):\n            projectMidPt = [projectMidPt]\n        projectCurves = Project(newCurve, surface, base_plane.ZAxis)\n        pCurvesOriginal = Project(oriCurve, surface, base_plane.ZAxis)\n        surfaceList = SurfaceSplit(surface, projectCurves)\n        surfaceList = self.sortSurface(surfaceList, base_plane)\n\n        chosenSrf = []\n        for srf in surfaceList:\n            delete = False\n            edges = BrepEdges(srf)[0]\n\n            if not isinstance(pCurvesOriginal, list):\n                pCurvesOriginal = [pCurvesOriginal]\n\n            for e in edges:\n                for pCrv in pCurvesOriginal:\n                    crvDist = CurveProximity(e, pCrv)[2]\n                    if crvDist < 0.1:\n                        delete = True\n                        continue\n                        \n            if not delete:\n                chosenSrf.append(srf)\n\n        return chosenSrf\n\n\n    def create_module_withDistance(self, surface, base_plane, distance):\n        base_plane = copy(base_plane)\n        \n        if self.claddingDirection:\n            base_plane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n        curves, _ = self.create_contours(surface, base_plane, distance)\n\n        chosenSrf = self.create_module_byCurve(surface, base_plane, curves, self.moduleCrvDist)\n\n        # surfaceList = SurfaceSplit(surface, curves)\n        # surfaceList = self.sortSurface(surfaceList, base_plane)\n\n        return chosenSrf\n\n\n    def sortSurface(self, srfList, sortPlane):\n            # Calculate the center point of each surface's bounding box\n            centers = [srf.GetBoundingBox(True).Center for srf in srfList]\n            \n            # Project these center points onto the sortPlane's Y-axis and calculate distance from the plane's origin\n            distances = [sortPlane.YAxis * (center - sortPlane.Origin) for center in centers]\n            \n            # Sort the surfaces based on these distances\n            sortedSurfaces = [srf for _, srf in sorted(zip(distances, srfList))]\n            \n            return sortedSurfaces\n\n\n    @classmethod\n    def create_contours(self, surface, base_plane, interval, pt=None):\n        interval = float(interval)\n        base_plane = deepcopy(base_plane)\n        base_plane.Rotate(math.pi/2, base_plane.XAxis, base_plane.Origin)\n        base_plane.Rotate(math.pi/10, base_plane.ZAxis, base_plane.Origin) # Maybe this line can be removed\n\n        contours = []\n        # trimmed_contours = []\n\n        # Get the bounding box of the surface in the plane's coordinate system\n        bbox = surface.GetBoundingBox(base_plane)\n\n        # Start and end values for contouring in the direction of the plane's normal\n        start = bbox.Min.Z\n        end = bbox.Max.Z\n        \n        originPlane = rg.Plane(base_plane)\n        originPlane.Translate(base_plane.Normal * start)\n\n        if pt == None:\n            offsetDist = 0\n        else:\n            # print(interval)\n            offsetDist = originPlane.DistanceTo(pt)%interval\n        \n\n        z = start + offsetDist\n        while z <= end:\n            # Create a plane parallel to the base plane at height z\n            contour_plane = rg.Plane(base_plane)\n            contour_plane.Translate(base_plane.Normal * z)\n\n\n            # Generate the contour\n            contour_curves = rg.Brep.CreateContourCurves(surface, contour_plane)\n            contours.extend(contour_curves)\n            \n            z += interval\n\n        total_length = 0\n        for crv in contours:\n            total_length += crv.GetLength()\n            # print(crv.GetLength())\n\n        return (contours, int(total_length))\n\n    def create_beam(self, curve, base_plane, width, height):\n        start_point = curve.PointAtStart\n\n        # Create a plane at the start point with the same orientation as the provided plane\n        section_plane = rg.Plane(start_point, base_plane.YAxis, base_plane.ZAxis)\n        matrix = rg.Transform.Translation(-base_plane.YAxis * width / 2)\n        section_plane.Transform(matrix)\n\n        # Create a rectangle in this plane\n        rectangle = rg.Rectangle3d(section_plane, width, height)\n\n        # Create a sweep\n        sweep = rg.SweepOneRail()\n        sweep.AngleToleranceRadians = 0.01\n        sweep.ClosedSweep = True\n        sweep.SweepTolerance = 0.01\n\n        # Explode the rectangle into segments\n        seg_rect = rectangle.ToNurbsCurve().DuplicateSegments()\n        brep_list = []\n\n        # Perform a sweep for each segment\n        for seg in seg_rect:\n            swept_breps = sweep.PerformSweep(curve, seg)\n            if swept_breps:  # Check if sweep was successful\n                brep_list.append(swept_breps[0])\n\n        # Join all swept BReps into one BRep if there are multiple parts\n        if brep_list:\n            beam_geo = rg.Brep.JoinBreps(brep_list, 0.01)\n            if beam_geo:\n                return beam_geo[0]  # Assuming join was successful and returns at least one BRep\n            else:\n                return None\n        else:\n            return None\n      \n\n    def create_board(self, surface, base_plane, length, width, thickness, direction, matAttr, oriPt):\n        if direction:\n            firDirPlane = copy(base_plane)\n            secDirPlane = copy(base_plane)\n            secDirPlane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n        else:\n            base_plane = copy(base_plane)\n            base_plane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n            firDirPlane = copy(base_plane)\n            secDirPlane = copy(base_plane)\n            secDirPlane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n\n        crvLength, _ = self.create_contours(surface, firDirPlane, length, oriPt)\n        crvWidth, _ = self.create_contours(surface, secDirPlane, width, oriPt)\n\n        crvCombine = []\n        crvCombine.extend(crvLength)\n        crvCombine.extend(crvWidth)\n\n        panelGeoList = SurfaceSplit(surface, crvCombine)\n\n        # create panel geometry\n        panelOffsetList = []\n        boardSeam = 2\n        # print(\"=====================\")\n        # print(panelGeoList)\n        if not isinstance(panelGeoList, list):\n            panelGeoList = [panelGeoList]\n        for panel in panelGeoList:\n            panelOffsetList.append(Extrude(panel, base_plane.ZAxis*thickness))\n\n        # Record Material using information.\n        boardArea = length*width\n        cuttedPiece = 0\n        for panel in panelGeoList:\n            area_properties = rg.AreaMassProperties.Compute(panel)\n            if area_properties is not None:\n                panelArea = area_properties.Area\n                if (boardArea - panelArea) > 10: #############################\n                    cuttedPiece += 1\n\n        usedPiece = len(panelGeoList)\n        self.materialInfoDict[self.layerId][self.module_id][\"availableQuantity\"] = matAttr.anzahl\n        self.materialInfoDict[self.layerId][self.module_id][\"materialType\"] = \"board\"\n        self.materialInfoDict[self.layerId][self.module_id][\"usedPiece\"] = usedPiece\n        self.materialInfoDict[self.layerId][self.module_id][\"cuttedPiece\"] = cuttedPiece\n        self.materialInfoDict[self.layerId][self.module_id][\"completedPiece\"] = usedPiece - cuttedPiece\n        self.materialInfoDict[self.layerId][self.module_id][\"info\"] = matAttr\n        \n        return panelOffsetList\n\n    \"\"\"\n    def find_board(self, searchDB, searchLength, searchWidth, searchDepth):\n        widthDB = []\n        lengthDB = []\n        depthDB = []\n        quantityDB = []\n        for board in searchDB:\n            w, l, d = board.breite, board.hoehe, board.tiefe\n            widthDB.append(w)\n            lengthDB.append(l)\n            depthDB.append(d)\n            quantityDB.append(board.anzahl)\n\n        boardList = []\n        for id, (w, l, d, q, obj) in enumerate(zip(widthDB, lengthDB, depthDB, quantityDB, searchDB)):\n            idName = \"board_\" + str(id)\n            boardList.append((w,l,d,q,idName,obj))\n\n        euclideanDistList = []\n        for w, l, d, q, id, obj in boardList:\n            euclideanDist = abs(searchWidth-w)**2 + abs(searchLength-l)**2 + abs(searchDepth-d)**2\n            euclideanDistList.append(euclideanDist)\n\n        # Pair each element of first_list with the corresponding element in second_list\n        paired_list = zip(boardList, euclideanDistList)\n\n        # Sort the pairs based on the elements of second_list\n        sorted_pairs = sorted(paired_list, key=lambda x: x[1])\n\n        # Extract the sorted elements of first_list\n        sorted_list = [element for element, _ in sorted_pairs]\n        tileData = sorted_list[0]\n\n        useWidth, useLength, useDepth, useQuantity, useId, useObjAttr = tileData\n\n        return (useWidth, useLength, useDepth, useQuantity, useId, useObjAttr)\n    \"\"\"\n\n\n    def create_substructInfill(self, surface, base_plane, width, thickness, distance, direction, matAttr):\n        def offset_surface_inner(surface, plane, distance, tolerance=0.01):\n            inner_distance = -abs(distance)\n            \n            # Offset the surface\n            # print(type(surface))\n            offset_surface = surface.Offset(100, tolerance)\n            \n            if offset_surface:\n                # Convert the offset surface to Brep\n                return offset_surface\n            else:\n                print(\"Offset operation failed.\")\n                return None\n\n        if direction:\n            workPlane = copy(base_plane)\n\n        else:\n            base_plane = copy(base_plane)\n            base_plane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n            workPlane = copy(base_plane)\n        \n        substructCrv, substructureLength = self.create_contours(surface, workPlane, distance)\n\n        panelGeoList = SurfaceSplit(surface, substructCrv)\n\n        if isinstance(panelGeoList, list):\n            pass\n        else:\n            panelGeoList = [panelGeoList]\n\n        # create panel geometry\n        panelOffsetList = []\n        totalArea = 0\n        for panel in panelGeoList:\n            # Assuming 'brep' is your Brep object and it's essentially a single surface\n            if panel.Faces.Count == 1:\n                surface = panel.Faces[0]\n            else:\n                print(\"The Brep contains multiple faces. Please specify which face to offset.\")\n                # For this example, let's proceed with the first face\n                surface = panel.Faces[0]\n            \n            # panelOffsetSrf = offset_surface_inner(surface, base_plane, width/2)\n            panelOffsetSrf = panel\n\n            panelOffsetList.append(Extrude(panelOffsetSrf, base_plane.ZAxis*thickness*0.95))\n\n            area_properties = rg.AreaMassProperties.Compute(panelOffsetSrf)\n            if area_properties is not None:\n                panelArea = area_properties.Area\n                totalArea += panelArea\n\n        # create beam\n        beamGeo = []\n        for crv in substructCrv:\n            beamGeo.append(self.create_beam(crv, base_plane, width, thickness))\n        \n        self.materialInfoDict[self.layerId][self.module_id][\"availableQuantity\"] = matAttr.anzahl\n        self.materialInfoDict[self.layerId][self.module_id][\"materialType\"] = \"substructInfill\"\n        self.materialInfoDict[self.layerId][self.module_id][\"usedLength\"] = substructureLength\n        self.materialInfoDict[self.layerId][self.module_id][\"usedArea\"] = int(totalArea)\n        self.materialInfoDict[self.layerId][self.module_id][\"info\"] = matAttr\n\n        return (panelOffsetList, beamGeo)\n\n\n    def create_paint(self, surface, base_plane, thickness, matAttr):\n        area_properties = rg.AreaMassProperties.Compute(surface)\n        if area_properties is not None:\n            panelArea = area_properties.Area\n\n        self.materialInfoDict[self.layerId][self.module_id][\"availableQuantity\"] = matAttr.anzahl\n        self.materialInfoDict[self.layerId][self.module_id][\"materialType\"] = \"paint\"\n        self.materialInfoDict[self.layerId][self.module_id][\"usedArea\"] = None\n        self.materialInfoDict[self.layerId][self.module_id][\"usedArea\"] = int(panelArea)\n        self.materialInfoDict[self.layerId][self.module_id][\"info\"] = matAttr\n\n        return Extrude(surface, base_plane.ZAxis*thickness)\n\n\n    def create_substruct(self, surface, base_plane, width, thickness, distance, direction, matAttr):\n        if direction:\n            workPlane = copy(base_plane)\n\n        else:\n            base_plane = copy(base_plane)\n            base_plane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n            workPlane = copy(base_plane)\n        \n        substructCrv, substructureLength = self.create_contours(surface, workPlane, distance)\n\n        # create beam\n        beamGeo = []\n        for crv in substructCrv:\n            beamGeo.append(self.create_beam(crv, base_plane, width, thickness))\n        \n        # self.materialInfoList.append((self.module_id, \"substruct\", substructureLength))\n        self.materialInfoDict[self.layerId][self.module_id][\"availableQuantity\"] = matAttr.anzahl\n        self.materialInfoDict[self.layerId][self.module_id][\"materialType\"] = \"substruct\"\n        self.materialInfoDict[self.layerId][self.module_id][\"usedLength\"] = substructureLength\n        self.materialInfoDict[self.layerId][self.module_id][\"info\"] = matAttr\n\n        return beamGeo\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}