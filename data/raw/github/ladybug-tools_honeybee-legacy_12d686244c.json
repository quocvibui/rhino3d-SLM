{
  "source_url": "https://github.com/ladybug-tools/honeybee-legacy/blob/bd62af4862fe022801fb87dbc8794fdf1dff73a9/src/Honeybee_SplitBuildingMass2Floors.py",
  "repo": "ladybug-tools/honeybee-legacy",
  "repo_stars": 129,
  "repo_description": ":bee: Honeybee is a free and open source plugin to connect Grasshopper3D to EnergyPlus, Radiance, Daysim and OpenStudio for building energy and daylighting simulation",
  "license": "NOASSERTION",
  "filepath": "src/Honeybee_SplitBuildingMass2Floors.py",
  "instruction": "Use this component to divide up a brep (polysurface) representative of a complete building massing into floors.\nThis generic zoning will divide the input mass into seprate floors based on an input...",
  "code": "#\n# Honeybee: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n#\n# This file is part of Honeybee.\n#\n# Copyright (c) 2013-2020, Chris Mackey <Chris@MackeyArchitecture.com> and Saeran Vasanthakumar <saeranv@gmail.com>\n# Honeybee is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published\n# by the Free Software Foundation; either version 3 of the License,\n# or (at your option) any later version.\n#\n# Honeybee is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Honeybee; If not, see <http://www.gnu.org/licenses/>.\n#\n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to divide up a brep (polysurface) representative of a complete building massing into floors.\nThis generic zoning will divide the input mass into seprate floors based on an input floor height.\n_\nIf you have a single mass representing two towers off of a podium, the two towers are not a continuous mass and you should therefore send each tower and the podium in as a separate Brep into this component.  The component will work for courtyard buildings.\nCore and perimeter zoneing should work for almost all masses where all walls are planar.  It works in a limited number of cases that have both curved and planar walls.  Also, it is important to note that, if your offset depth is so large in comparison to your building depth as to create perimeter zones that intersect one another, the whole floor will be returned as a single zone.\nWhile this component can usually get you the most of the way there, it is still recommended that you bake the output and check the geometry in Rhino before turning the breps into HBZones.\n_\nThe assumption about an E+ zone is that the air is well mixed and all at the same temperature.\nTherefore, it is usually customary to break up a building depending on the areas where you would expect different building microclimates to exist.\nThis includes breaking up the building into floors (since each floor can have a different microclimate) and breaking up each floor into a core zone and perimeter zones (since each side of the buidling gets a different amount of solar gains and losses/gains through the envelope).\nThis component helps break up building masses into floors, and can be used in conjunction with the Honeybee_SplitBuildingFloor2ThermalZones component to genreate core zone and perimeter zones.\n-\nProvided by Honeybee 0.0.66\n\n    Args:\n        _bldgMasses: A Closed brep or list of closed breps representing a building massing.\n        _bldgsFlr2FlrHeights: A list of floor heights in Rhino model units that will be used to make each floor of the building.  The list should run from bottom floor to top floor.  Alternatively, you can input a text string that codes for how many floors of each height you want.  For example, inputting \"2@4\" (without quotations) will make two ground floors with a height of 4 Rhino model units.  Simply typing \"@3\" will make all floors 3 Rhino model units.  Putting in lists of these text strings will divide up floors accordingly.  For example, the list \"1@5   2@4   @3\"  will make a ground floor of 5 units, two floors above that at 4 units and all remaining floors at 3 units.\n    Returns:\n        readMe!: ...\n        splitBldgFloors: A series of breps that correspond to inputted floor heights. These can be inserted into the Honeybee_SplitBuildingFloor2ThermalZones component to further split the floors into thermal zones for energy simulation.\n\"\"\"\n\n\nghenv.Component.Name = 'Honeybee_SplitBuildingMass2Floors'\nghenv.Component.NickName = 'Split2Floors'\nghenv.Component.Message = 'VER 0.0.66\\nFEB_23_2021'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"HB-Legacy\"\nghenv.Component.SubCategory = \"00 | Honeybee\"\n#compatibleHBVersion = VER 0.0.56\\nFEB_01_2015\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"2\"\nexcept: pass\n\n\nimport Rhino as rc\nimport scriptcontext as sc\nimport Grasshopper.Kernel as gh\nfrom System import Object\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\nimport rhinoscriptsyntax as rs\n\ntolerance = sc.doc.ModelAbsoluteTolerance\n\ndef checkTheInputs():\n    if len(_bldgMasses) != 0 and _bldgMasses[0]!=None :\n        brepSolid = []\n        for brep in _bldgMasses:\n            if brep.IsSolid == True:\n                brepSolid.append(1)\n            else:\n                warning = \"Building masses must be closed solids!\"\n                print warning\n                w = gh.GH_RuntimeMessageLevel.Warning\n                ghenv.Component.AddRuntimeMessage(w, warning)\n        if sum(brepSolid) == len(_bldgMasses):\n            checkData1 = True\n    else:\n        checkData1 = False\n        print \"Connect closed solid building masses to split them up into floors.\"\n\n    if _bldgsFlr2FlrHeights != []:\n        checkData2 = True\n    else:\n        print \"A value must be connected for floor heights in _bldgsFlr2FlrHeights in order to run.\"\n        checkData2 = False\n\n    if checkData1 == True and checkData2 == True:\n        checkData = True\n    else:\n        checkData = False\n    return checkData\ndef getFloorHeights(flr2flrHeights, maxHeights, firstFloorHeight = 0, rep = True):\n    flrHeights = [firstFloorHeight]\n    for height in flr2flrHeights:\n        if '@' in height:\n            floorH = float(height.split('@')[1])\n            try: numOfFlr = int(height.split('@')[0])\n            except:  numOfFlr = int((maxHeights - flrHeights[-1])/floorH)\n        else:\n            numOfFlr = 1\n            floorH = float(height)\n        if floorH!=0:\n            #if numOfFlr != 1 and rep:\n            #    print 'There are ' + `numOfFlr` + ' floors with height of ' + `floorH` + ' m.'\n            #elif rep:\n            #    print 'There is a floor with height of ' + `floorH` + ' m.'\n\n            for floors in range(numOfFlr): flrHeights.append(flrHeights[-1] + floorH)\n\n    return flrHeights # list of floor heights\ndef getFloorCrvs(buildingMass, floorHeights, maxHeights):\n    #Draw a bounding box around the mass and use the lowest Z point to set the base point.\n    massBB = buildingMass.GetBoundingBox(rc.Geometry.Plane.WorldXY)\n    minZ = massBB.Min.Z\n\n    basePoint = rc.Geometry.Point3d.Origin\n    cntrCrvs = []; splitters = []\n    bbox = buildingMass.GetBoundingBox(True)\n    for count, h in enumerate(floorHeights):\n        crvList = []\n        floorBasePt = rc.Geometry.Point3d.Add(basePoint, rc.Geometry.Vector3d(0,0,h + minZ))\n        sectionPlane = rc.Geometry.Plane(floorBasePt, rc.Geometry.Vector3d.ZAxis)\n        crvList = rc.Geometry.Brep.CreateContourCurves(buildingMass, sectionPlane)\n\n        #If the crvList cointains multiple curves, this probably means that it's a courtyard building.  Order the curves from greatest area to least area and create different lists of curves for the interior and exterior.\n        if len(crvList) > 1 and count == 0:\n            areaList = []\n            for curve in crvList:\n                try: areaList.append(rc.Geometry.AreaMassProperties.Compute(curve).Area)\n                except: areaList.append(0.0)\n            crvList = [x for (y,x) in sorted(zip(areaList, crvList))]\n            crvList.reverse()\n            for curve in crvList:\n                cntrCrvs.append([curve])\n        elif len(crvList) > 1 and count != 0:\n            areaList = []\n            for curve in crvList:\n                try: areaList.append(rc.Geometry.AreaMassProperties.Compute(curve).Area)\n                except: areaList.append(0.0)\n            crvList = [x for (y,x) in sorted(zip(areaList, crvList))]\n            crvList.reverse()\n            for crvCount, curve in enumerate(crvList):\n                try: cntrCrvs[crvCount].append(curve)\n                except: pass\n        elif len(crvList) == 1 and count == 0:\n            cntrCrvs.append([crvList[0]])\n        elif len(crvList) == 1 and count != 0:\n            try: cntrCrvs[0].append(crvList[0])\n            except: cntrCrvs.append([crvList[0]])\n        else: pass\n\n        if crvList != []:\n            # This part is based on one of David Rutten's script\n            bool, extU, extV = sectionPlane.ExtendThroughBox(bbox)\n            # extend the plane for good measure\n            extU.T0 -= 1.0\n            extU.T1 += 1.0\n            extV.T0 -= 1.0\n            extV.T1 += 1.0\n            splitters.append(rc.Geometry.PlaneSurface(sectionPlane, extU, extV))\n\n    finaltopIncList = []\n\n    for courtyrdCount, contourCrvs in enumerate(cntrCrvs):\n\n        #Check if the operation has generated a single nurbs curve for a floor (like a circle) and, if so, segment it.\n        goodContourCrvs = []\n        nurbsList = []\n        for curve in contourCrvs:\n            try:\n                segCount = curve.SegmentCount\n                goodContourCrvs.append(curve)\n                nurbsList.append(False)\n            except:\n                #If the curve has failed the operation above, then it is a single NURBS Curve.  Test to see if offsetting it will generate segments and, if not, it should be segemented into a polycurve.\n                curveLength = curve.GetLength()\n                divisionParams = curve.DivideByLength((curveLength/4), False)[0:3]\n                splitCurve = curve.Split(divisionParams)\n                newCrv = rc.Geometry.PolyCurve()\n                for segment in splitCurve:\n                    newCrv.Append(segment)\n                goodContourCrvs.append(newCrv)\n                nurbsList.append(True)\n        contourCrvs = goodContourCrvs\n\n        #Check if any of the generated curves have no area and, if so, discount them from the list. Make a note if the curves are at the top, which happens a lot with gabled roofs.  This can be corrected later.\n        newContourCrvs = []\n        problemIndices = []\n        problem = False\n        for crvCount, crv in enumerate(contourCrvs):\n            if crv.SegmentCount == 2:\n                segments = crv.DuplicateSegments()\n                if segments[0].IsLinear and segments[1].IsLinear:\n                    problem = True\n                    problemIndices.append(crvCount)\n                else: newContourCrvs.append(crv)\n            else: newContourCrvs.append(crv)\n        if problem == True:\n            if problemIndices[-1] == len(contourCrvs)-1: topProblem = True\n            else: topProblem = False\n        else: topProblem = False\n        contourCrvs = newContourCrvs\n\n        #Check to see if the top floor is shorter than 2 meters and, if so, discount it.\n        units = sc.doc.ModelUnitSystem\n        #Define a default max height for a floor based on the model units and typical building dimensions.\n        if `units` == 'Rhino.UnitSystem.Meters':\n            maxHeight = 2\n        elif `units` == 'Rhino.UnitSystem.Centimeters':\n            maxHeight = 200\n        elif `units` == 'Rhino.UnitSystem.Millimeters':\n            maxHeight = 2000\n        elif `units` == 'Rhino.UnitSystem.Feet':\n            maxHeight = 6\n        elif `units` == 'Rhino.UnitSystem.Inches':\n            maxHeight = 72\n        else:\n            warning = \"What model units are you using? Use either meters, centimeters, millimeters, feet or inches\"\n            print warning\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n\n        lastFloorHeight = (maxHeights)  - floorHeights[-1]\n\n        #Adding is_near_zero function due\n        #to rounding/precision issues with equality of floats\n        if is_near_zero(lastFloorHeight):\n            lastFloorInc = True\n        else:\n            if lastFloorHeight < maxHeight:\n                lastFloorInc = False\n            else:\n                lastFloorInc = True\n        #Check to see if the top surface is horizontal + planar and, if so, include it in the curve process below.\n        if lastFloorInc == True:\n            #First find the top surface\n            massSurfaces = []\n            faceLen = buildingMass.Faces.Count\n            for surfaceCount in range(faceLen):\n                massSurfaces.append(buildingMass.DuplicateSubBrep([surfaceCount]))\n            srfAvgZValue = []\n            for brep in massSurfaces:\n                vertices = brep.DuplicateVertices()\n                zValues = []\n                for vertex in vertices:\n                    zValues.append(vertex.Z)\n                zAvg = (sum(zValues))/(len(zValues))\n                srfAvgZValue.append(zAvg)\n            maxIndex = max(enumerate(srfAvgZValue),key=lambda x: x[1])[0]\n            topSurface = massSurfaces[maxIndex]\n\n            #Check the Z-Values of the vertices to see if they are equal and check for planarity\n            topZValues = []\n            for vertex in topSurface.DuplicateVertices():\n                topZValues.append(vertex.Z)\n            refZ = topZValues[0]\n            zCheckList = []\n            for Z in topZValues:\n                if Z < refZ + tolerance and Z > refZ - tolerance:\n                    zCheckList.append(1)\n                else:pass\n            if sum(zCheckList) == len(topZValues): tophoriz = True\n            else: tophoriz = False\n            topPlanar = topSurface.Surfaces[0].IsPlanar()\n            #If it's both horizontal and planar, take the boundary curve and include it in the rest of the process.\n            if tophoriz == True and topPlanar == True:\n                topInc = True\n            else:\n                topInc = False\n        else:\n            if lastFloorHeight < maxHeight:\n                topInc = True\n            else: topInc = False\n\n        if topProblem == True:\n            topInc = False\n        else: pass\n\n        #Append the results to the list.\n        finaltopIncList.append(topInc)\n    return splitters, finaltopIncList, lastFloorInc\ndef splitFloorHeights(bldgMasses, bldgsFlr2FlrHeights, lb_preparation, lb_visualization):\n    #Input: mass, floorHeights, lb_preparation, lb_visualization\n    #Output: splitFloors, floorCrvs, topInc, nurbsList, lastFloorInclud\n\n    if len(bldgMasses)!=0:\n        # clean the geometries\n        analysisMesh, initialMasses = lb_preparation.cleanAndCoerceList(bldgMasses)\n\n        splitZones = []\n        topIncluded = []\n        lastFloorInclud = []\n        for bldgCount, mass in enumerate(initialMasses):\n            # 0- split the mass vertically [well, it is actually horizontally! so confusing...]\n            # 0-1 find the boundingBox\n            massBB = rc.Geometry.Brep.GetBoundingBox(mass, rc.Geometry.Plane.WorldXY)\n            # SPLIT MASS TO FLOORS\n            # 0-2 get floor curves and split surfaces based on floor heights\n            # I don't use floor curves here. It is originally developed for upload Rhino2Web\n            maxHeights = massBB.Max.Z - massBB.Min.Z\n            floorHeights = getFloorHeights(bldgsFlr2FlrHeights, maxHeights)\n\n            if floorHeights!=[0]:\n                splitterSrfs, topInc,lastFloorInc = getFloorCrvs(mass, floorHeights, maxHeights)\n\n                topIncluded.append(topInc)\n                lastFloorInclud.append(lastFloorInc)\n\n                # well, I'm pretty sure that something like this is smarter to be written\n                # as a recursive fuction but I'm not comfortable enough to write it that way\n                # right now. Should be fixed later!\n                restOfmass = mass\n                massZones = []\n                for srfCount, srf in enumerate(splitterSrfs):\n                    lastPiece = []\n                    lastPiece.append(restOfmass)\n                    pieces = restOfmass.Split(srf.ToBrep(), tolerance)\n\n                    if len(pieces)== 2:\n                        # swap order so it's compatible w/ rest of code (fix for R7 bug) \n                        if lb_visualization.calculateBB([pieces[0]], True)[-1].Z > lb_visualization.calculateBB([pieces[1]], True)[-1].Z:\n                            pieces[0], pieces[1] = pieces[1], pieces[0]\n                        try:\n                            zone = pieces[0].CapPlanarHoles(tolerance);\n                            if zone!=None:\n                                massZones.append(zone)\n                            restOfmass = pieces[1].CapPlanarHoles(tolerance)\n                        except Exception, e:\n                            print 'error 1: ' + `e`\n                    else:\n                        if srfCount == len(splitterSrfs) - 1:\n                            pass\n                        else:\n                            msg = 'One of the masses is causing a problem. Check the output for the mass that causes the problem. You should consider breaking up this mass into smaller pieces.'\n                            print msg\n                            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, msg)\n                            return [[[restOfmass]], -1, -1, -1]\n                if restOfmass != None:\n                    massZones.append(restOfmass)\n                else: pass\n\n                splitZones.append(massZones)\n\n        return splitZones, topIncluded, lastFloorInclud\ndef is_near_zero(num, eps=1E-10):\n    return abs(float(num)) < eps\ndef main(mass, floorHeights):\n    #Import the Ladybug Classes.\n    if sc.sticky.has_key('ladybug_release')and sc.sticky.has_key('honeybee_release'):\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n        lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\n        #If the user has specified a floor height, split the mass up by floor.\n        #Input: mass, floorHeights, lb_preparation, lb_visualization\n        #Output: splitFloors, floorCrvs, topInc, nurbsList, lastFloorInclud\n        splitFloors = []\n        topInc = []\n        lastFloorInclud = []\n        if floorHeights != []:\n            splitFloors, topInc,lastFloorInclud = splitFloorHeights(mass, floorHeights, lb_preparation, lb_visualization)\n        #Sort the floors into a list\n        splitZones = []\n        for count, mass in enumerate(splitFloors):\n            #print count, mass, topInc[count], lastFloorInclud[count]\n            if topInc[count][0] == True and lastFloorInclud[count] == True:\n                splitZones.append(mass)\n            elif topInc[count][0] == False and lastFloorInclud[count] == False:\n                splitZones.append(mass)\n            else:\n                splitZones.append(mass[:-1])\n\n        #return list of list of each floor zones\n        return splitZones\n    else:\n        print \"You should first let both Ladybug and Honeybee to fly...\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"You should first let both Ladybug and Honeybee to fly...\")\n        return -1\n\ncheckData = False\n\nif _runIt == True:\n    checkData = checkTheInputs()\nif checkData == True:\n    splitBldgMassesLists = main(_bldgMasses, _bldgsFlr2FlrHeights)\n    if splitBldgMassesLists!= -1:\n        splitBldgFloors = DataTree[Object]()\n        names = DataTree[Object]()\n        for i, buildingMasses in enumerate(splitBldgMassesLists):\n            for j, mass in enumerate(buildingMasses):\n                p = GH_Path(i,j)\n\n                # in case mass is not a list change it to list\n                try: mass[0]\n                except: mass = [mass]\n\n                newMass = []\n                for brep in mass:\n                    if brep != None:\n                        #Bake the objects into the Rhino scene to ensure that surface normals are facing the correct direction\n                        sc.doc = rc.RhinoDoc.ActiveDoc #change target document\n                        rs.EnableRedraw(False)\n                        guid1 = [sc.doc.Objects.AddBrep(brep)]\n\n                        if guid1:\n                            a = [rs.coercegeometry(a) for a in guid1]\n                            for g in a: g.EnsurePrivateCopy() #must ensure copy if we delete from doc\n\n                            rs.DeleteObjects(guid1)\n\n                        sc.doc = ghdoc #put back document\n                        rs.EnableRedraw()\n                        newMass.append(g)\n                    mass = newMass\n\n                try:\n                    splitBldgFloors.AddRange(mass, p)\n                    #zoneNames = [str(i) + \"_\" + str(m) for m in range(len(mass))]\n                    #names.AddRange(zoneNames, p)\n                except:\n                    splitBldgFloors.Add(mass, p)\n                    #names.Add(str(i) + \"_\" + str(j), p)",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}