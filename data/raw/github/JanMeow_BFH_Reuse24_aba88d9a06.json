{
  "source_url": "https://github.com/JanMeow/BFH_Reuse24/blob/8ee5b5647d3500e8ac32686766bd46658e59ac11/Kevin/otherThing/wallGenerate.py",
  "repo": "JanMeow/BFH_Reuse24",
  "repo_stars": 0,
  "repo_description": "BFH 24 Spring Studio Scripts Development",
  "license": "MIT",
  "filepath": "Kevin/otherThing/wallGenerate.py",
  "instruction": "Wall generate",
  "code": "import Rhino.Geometry as rg\nfrom ghpythonlib.components import Area, SurfaceClosestPoint, EvaluateSurface, Contour, SurfaceSplit, Extrude, OffsetCurve, BoundarySurfaces\nimport ghpythonlib.treehelpers as th\nimport math\nfrom copy import copy\nfrom Grasshopper.Kernel.Data import GH_Path\nfrom Grasshopper import DataTree\nimport System.Array as array\n\n\nclass CompoundMaterial:\n    def __init__(self, materialList):\n        self.materialList = materialList\n        self.new_materialList = self.readMaterial(self.materialList)\n        self.thicknessList = self.calculateThickness(self.new_materialList)\n\n    \n    def readMaterial(self, materialList):\n        new_materialList = []\n        for mat in materialList:\n            if hasattr(mat, 'boardData'):\n                new_materialList.append(mat.boardData)\n            elif hasattr(mat, 'substructInfillData'):\n                new_materialList.append(mat.substructInfillData)\n            elif hasattr(mat, 'substructData'):\n                new_materialList.append(mat.substructData)\n            elif hasattr(mat, 'paintData'):\n                new_materialList.append(mat.paintData)\n            elif hasattr(mat, 'claddingData'):\n                new_materialList.append(mat.claddingData)\n        return new_materialList\n\n    \n    def calculateThickness(self, materialList):\n        thicknessList = []\n        for mat in materialList:\n            thicknessList.append(mat.thickness)\n        return thicknessList\n\n\nclass wallGenerate:\n    def __init__(self, surfaceList, materialList, thicknessList):\n        self.surfaceList = surfaceList\n        self.materialList = materialList\n        self.thicknessList = thicknessList\n\n        basePlane = []\n        boardGeoList = []\n        substructInfillGeoList = []\n        paintGeoList = []\n        substructGeoList = []\n        claddingGeoList = []\n        layerTree = DataTree[object]()\n\n        for id, (srfList, matList) in enumerate(zip(self.surfaceList, self.materialList)):\n            mat = matList\n            srfList = [srfList]\n            if id == 0:\n                for srf in srfList:\n                    uvP = SurfaceClosestPoint(Area(srf)[1], srf)[1]\n                    frame = EvaluateSurface(srf, uvP)[4]\n                    basePlane.append(frame)\n            \n            allTypeGeo = []\n            for srf_id, srf in enumerate(srfList):\n                workPlane = basePlane[srf_id]\n                matType = mat.materialType\n                print(matType)\n                if matType == \"board\":\n                    boardGeo = self.create_board(srf, workPlane, mat.length, mat.width, mat.thickness, mat.direction)\n                    boardGeoList.append(boardGeo)\n                    allTypeGeo.append(boardGeo)\n                    \n                elif matType == \"substructInfill\":\n                    panelGeo, beamGeo = self.create_substructInfill(srf, workPlane, mat.width, mat.thickness, mat.distance, mat.direction)\n                    substructInfillGeoList.append(beamGeo)\n                    substructInfillGeoList.append(panelGeo)\n                    allTypeGeo.append(beamGeo)\n                    allTypeGeo.append(panelGeo)\n\n                elif matType == \"paint\":\n                    paintGeo = self.create_paint(srf, workPlane, mat.thickness)\n                    paintGeoList.append([paintGeo])\n                    allTypeGeo.append([paintGeo])\n                    \n                elif matType == \"substruct\":\n                    substructGeo = self.create_substruct(srf, workPlane, mat.width, mat.thickness, mat.distance, mat.direction)\n                    substructGeoList.append(substructGeo)\n                    allTypeGeo.append(substructGeo)\n\n                elif matType == \"cladding\":\n                    claddingGeo = self.create_cladding(srf, workPlane, mat.length, mat.width, mat.thickness, mat.direction)\n                    claddingGeoList.append(claddingGeo)\n                    allTypeGeo.append(claddingGeo)\n                \n            path = GH_Path(array[int]([0,0,id]))\n            layerTree.AddRange(allTypeGeo, path)\n                \n        self.allTypeMaterial = layerTree\n\n\n    def create_contours(self, surface, base_plane, interval):\n        base_plane = copy(base_plane)\n        base_plane.Rotate(math.pi/2, base_plane.XAxis, base_plane.Origin)\n        base_plane.Rotate(math.pi/10, base_plane.ZAxis, base_plane.Origin)\n        contours = []\n        trimmed_contours = []\n\n        # Get the bounding box of the surface in the plane's coordinate system\n        bbox = surface.GetBoundingBox(base_plane)\n\n        # Start and end values for contouring in the direction of the plane's normal\n        start = bbox.Min.Z\n        end = bbox.Max.Z\n\n        # Generate contours\n        z = start\n        while z <= end:\n            # Create a plane parallel to the base plane at height z\n            contour_plane = rg.Plane(base_plane)\n            contour_plane.Translate(base_plane.Normal * z)\n\n            # Generate the contour\n            contour_curves = rg.Brep.CreateContourCurves(surface, contour_plane)\n            contours.extend(contour_curves)\n\n            z += interval\n\n        # Get the edge curves of the surface\n        edge_curves = surface.DuplicateEdgeCurves()\n\n        boundary = rg.Curve.JoinCurves(edge_curves)[0]  # Join edge curves to form a single boundary curve\n        self.check = contours\n        \n        # Trim contours\n        # for contour in contours:\n        #     intersection_events = rg.Intersect.Intersection.CurveCurve(contour, boundary, 0.01, 0.01)\n        #     if intersection_events:\n        #         intersection_params = [event.ParameterA for event in intersection_events]\n        #         segments = contour.Split(intersection_params)\n        #         for segment in segments:\n        #             trimmed_contours.append(segment)\n\n        return contours\n\n\n    def create_beam(self, curve, base_plane, width, height):\n        start_point = curve.PointAtStart\n\n        # Create a plane at the start point with the same orientation as the provided plane\n        section_plane = rg.Plane(start_point, base_plane.YAxis, base_plane.ZAxis)\n        matrix = rg.Transform.Translation(-base_plane.YAxis*width/2)\n        section_plane.Transform(matrix)\n\n        # Create a rectangle in this plane\n        rectangle = rg.Rectangle3d(section_plane, width, height)\n\n        # Create a sweep\n        sweep = rg.SweepOneRail()\n        sweep.AngleToleranceRadians = 0.01\n        sweep.ClosedSweep = True\n        sweep.SweepTolerance = 0.01\n\n        # Perform the sweep\n        swept_breps = sweep.PerformSweep(curve, rectangle.ToNurbsCurve())\n\n        # Assuming we want the first Brep if there are multiple\n        return swept_breps[0]\n        \n\n\n    def create_board(self, surface, base_plane, length, width, thickness, direction):\n        if direction:\n            firDirPlane = copy(base_plane)\n            secDirPlane = copy(base_plane)\n            secDirPlane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n        else:\n            base_plane = copy(base_plane)\n            base_plane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n            firDirPlane = copy(base_plane)\n            secDirPlane = copy(base_plane)\n            secDirPlane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n\n        crvLength = self.create_contours(surface, firDirPlane, length)\n        crvWidth = self.create_contours(surface, secDirPlane, width)\n\n        crvCombine = []\n        crvCombine.extend(crvLength)\n        crvCombine.extend(crvWidth)\n\n\n        panelGeoList = SurfaceSplit(surface, crvCombine)\n\n            # create panel geometry\n        panelOffsetList = []\n        boardSeam = 2\n        for panel in panelGeoList:\n            panelOffsetList.append(Extrude(panel, base_plane.ZAxis*thickness))\n        \n        return panelOffsetList\n\n\n\n    def create_substructInfill(self, surface, base_plane, width, thickness, distance, direction):\n        if direction:\n            workPlane = copy(base_plane)\n\n        else:\n            base_plane = copy(base_plane)\n            base_plane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n            workPlane = copy(base_plane)\n        \n        substructCrv = self.create_contours(surface, workPlane, distance)\n\n        panelGeoList = SurfaceSplit(surface, substructCrv)\n\n\n        # create panel geometry\n        panelOffsetList = []\n        for panel in panelGeoList:\n            neg = OffsetCurve(panel, -width/2, base_plane, 1)\n            pos = OffsetCurve(panel, width/2, base_plane, 1)\n            if pos.GetLength() > neg.GetLength():\n                offsetResult = neg\n            else:\n                offsetResult = pos\n            \n            panelOffsetSrf = BoundarySurfaces(offsetResult)\n            panelOffsetList.append(Extrude(panelOffsetSrf, base_plane.ZAxis*thickness*0.8))\n\n        # create beam\n        beamGeo = []\n        for crv in substructCrv:\n            beamGeo.append(self.create_beam(crv, base_plane, width, thickness))\n\n        return (panelOffsetList, beamGeo)\n\n\n    def create_paint(self, surface, base_plane, thickness):\n        return Extrude(surface, base_plane.ZAxis*thickness)\n\n\n    def create_substruct(self, surface, base_plane, width, thickness, distance, direction):\n        if direction:\n            workPlane = copy(base_plane)\n\n        else:\n            base_plane = copy(base_plane)\n            base_plane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n            workPlane = copy(base_plane)\n        \n        substructCrv = self.create_contours(surface, workPlane, distance)\n\n        # create beam\n        beamGeo = []\n        for crv in substructCrv:\n            beamGeo.append(self.create_beam(crv, base_plane, width, thickness))\n\n        return beamGeo\n\n\n    def create_cladding(self, surface, base_plane, length, width, thickness, direction):\n        if direction:\n            firDirPlane = copy(base_plane)\n            secDirPlane = copy(base_plane)\n            secDirPlane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n        else:\n            base_plane = copy(base_plane)\n            base_plane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n            firDirPlane = copy(base_plane)\n            secDirPlane = copy(base_plane)\n            secDirPlane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n\n        crvLength = self.create_contours(surface, firDirPlane, length)\n        crvWidth = self.create_contours(surface, secDirPlane, width)\n\n        crvCombine = []\n        crvCombine.extend(crvLength)\n        crvCombine.extend(crvWidth)\n\n        panelGeoList = SurfaceSplit(surface, crvCombine)\n\n            # create panel geometry\n        panelOffsetList = []\n        boardSeam = 2\n        for panel in panelGeoList:\n            panelOffsetList.append(Extrude(panel, base_plane.ZAxis*thickness))\n        \n        return panelOffsetList\n\n\n\ndef offset_brep(brep, distances, tolerance=0.01):\n    all_offset_breps = []\n    for distance in distances:\n        offset_breps = rg.Brep.CreateOffsetBrep(brep, distance, solid=False, extend=False, tolerance=tolerance)\n        if offset_breps:\n            all_offset_breps.append(offset_breps[0][0])\n        else:\n            print(\"Offset operation failed for distance .\")\n            all_offset_breps.append(None)\n    return all_offset_breps\n\n\n\ncompoundMaterialObj = CompoundMaterial(material_collection)\nmaterialList = compoundMaterialObj.new_materialList\nmaterial_thickness = compoundMaterialObj.thicknessList\n\noffsetList = []\ntotal = 0\nfor num in material_thickness:\n    total += num\n    offsetList.append(total)\n\n\noffsetList = offsetList[:-1]\noffsetList.insert(0,0)\n\noffsetted_surface = offset_brep(wallSurface, offsetList)\n\nwallObj = wallGenerate(offsetted_surface, materialList, material_thickness)\nallTypeMaterial = wallObj.allTypeMaterial\ncheck = wallObj.check\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}