{
  "source_url": "https://github.com/a3aremba/CrawlerProxy/blob/f242b5564f0a4df35cd650939311b27995525997/proxyScript.py",
  "repo": "a3aremba/CrawlerProxy",
  "repo_stars": 0,
  "repo_description": "CrowlerProxy",
  "license": "unknown",
  "filepath": "proxyScript.py",
  "instruction": "Proxy script",
  "code": "__author__ = 'alexz'\n\nfrom libcproxy.script import ScriptContext, concurrent\nfrom libcproxy.protocol.http import HTTPFlow, HTTPRequest, HTTPResponse\nfrom libcproxy.protocol.tcp import TCPHandler\nfrom libcproxy.protocol import KILL\nimport os, sys, platform\n\n\nargs = sys.argv\nif (platform.node() == 'VM-MYPAY-POLY01'):\n    sys.path.append('/home/docker/code/app/') # add this folder to system path\nelse:\n    sys.path.append(os.getcwd()) # add this folder to system path\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"core.settings\")  # turn on django settings\n\n\nfrom netlib.odict import ODictCaseless\nfrom core.service.CheckUrl.CheckUrlService import CCheckUrlService\nfrom debug import pycharmDebug\n\npycharmDebug()\n\"\"\"\n    This is a script stub, with definitions for all events.\n\"\"\"\ndef start(context, argv):\n    HTTPRequest._headers_to_strip_off.remove(\"Connection\")\n    HTTPRequest._headers_to_strip_off.remove(\"Upgrade\")\n    \"\"\"\n        Called once on script startup, before any other events.\n    \"\"\"\n\ndef clientconnect(context, conn_handler):\n    \"\"\"\n        Called when a client initiates a connection to the proxy. Note that a\n        connection can correspond to multiple HTTP requests\n    \"\"\"\n    HTTPRequest._headers_to_strip_off.append(\"Connection\")\n    HTTPRequest._headers_to_strip_off.append(\"Upgrade\")\n    context.log(\"clientconnect\")\n\ndef serverconnect(context, conn_handler):\n    \"\"\"\n        Called when the proxy initiates a connection to the target server. Note that a\n        connection can correspond to multiple HTTP requests\n    \"\"\"\n    context.log(\"serverconnect\")\n\n@concurrent\ndef request(context, flow):\n    \"\"\"\n        Called when a client request has been received.\n    \"\"\"\n\n    checkService = CCheckUrlService()\n    response = checkService.check(flow.request.method, flow.request.url,\n                                  flow.request.content, flow.request.headers)\n\n    if response:\n        resp = HTTPResponse(\n            [1, 1], response.http_code, response.msg,\n            ODictCaseless(response.headers),\n            response.content)\n        flow.reply(resp)\n    context.log(\"request\")\n\ndef responseheaders(context, flow):\n    \"\"\"\n        Called when the response headers for a server response have been received,\n        but the response body has not been processed yet. Can be used to tell mitcproxy\n        to stream the response.\n    \"\"\"\n    flow.response.headers['Mitm-Proxy'] = [\"enabled\"]\n    flow.response.headers['Department'] = [\"it-isto\"]\n    context.log(\"responseheaders\")\n\n@concurrent\ndef response(context, flow):\n    \"\"\"\n       Called when a server response has been received.\n       :type context: ScriptContext\n       :type flow: HTTPFlow\n    \"\"\"\n    value = flow.response.headers.get_first(\"Connection\", None)\n    if value and value.upper() == \"UPGRADE\":\n        # We need to send the response manually now...\n        flow.client_conn.send(flow.response.assemble())\n        # ...and then delegate to tcp passthrough.\n        TCPHandler(flow.live.c, log=False).handle_messages()\n        flow.reply(KILL)\n    context.log(\"response\")\n\ndef error(context, flow):\n    \"\"\"\n        Called when a flow error has occured, e.g. invalid server responses, or\n        interrupted connections. This is distinct from a valid server HTTP error\n        response, which is simply a response with an HTTP error code.\n    \"\"\"\n    context.log(\"error\")\n\ndef clientdisconnect(context, conn_handler):\n    \"\"\"\n        Called when a client disconnects from the proxy.\n    \"\"\"\n    context.log(\"clientdisconnect\")\n\ndef done(context):\n    \"\"\"\n        Called once on script shutdown, after any other events.\n    \"\"\"\n    context.log(\"done\")",
  "language": "python",
  "imports": [],
  "has_docstring": false
}