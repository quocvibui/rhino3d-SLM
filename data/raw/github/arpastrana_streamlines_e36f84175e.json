{
  "source_url": "https://github.com/arpastrana/streamlines/blob/603813aef3dd22f20b7821304bd4cadf20cd6bf1/src/streamlines/fea/fea.py",
  "repo": "arpastrana/streamlines",
  "repo_stars": 0,
  "repo_description": null,
  "license": "MIT",
  "filepath": "src/streamlines/fea/fea.py",
  "instruction": "A bunch of utilities that help to communicate with abaqus through compas FEA.",
  "code": "'''\nA bunch of utilities that help to communicate with abaqus through compas FEA.\n'''\n\n__author__ = 'Rafael Pastrana, Andrew Liew'\n__name__ = 'FEA Communication'\n__version__ = '0.0.2'\n__date__ = '16.08.27'\n\n\nimport Rhino\nimport compas.geometry as cg\nimport rhinoscriptsyntax as rs\nfrom compas_fea.cad import rhino\nfrom compas_fea.structure import Structure\nfrom compas_fea.structure import ShellSection\nfrom compas_fea.structure import Concrete\nfrom compas_fea.structure import Steel\nfrom compas_fea.structure import ElementProperties as Properties\n\n\ndef clean_vectors(vectors):\n    cleaned_vectors = []\n    for vector in vectors:\n        try:\n            vector = [vector.X, vector.Y, vector.Z]\n        except Exception:\n            vector = None\n        cleaned_vectors.append(vector)\n    return cleaned_vectors\n\n\ndef steel_area_to_spacing(s_area, diameter):\n    TOL = 1e-3\n    bar_area = get_bar_area(diameter)\n\n    if s_area > TOL:\n        spacing = s_area / bar_area\n        spacing = 1 / spacing\n    else:\n        return None\n\n    def get_bar_area(diameter):\n        return math.pi * math.pow((diameter / 10), 2) / 4\n\n    return spacing\n\n\ndef get_rebar_angles(x_dir, ori):\n    angle = cg.angle_vectors(ori, x_dir, deg=True)\n    angle_2 = angle + 90.0\n\n    # if angle > 90.0:\n    #     angle = angle-90\n    #     angle_2 = angle - 90.0\n\n    return angle, angle_2\n\n\ndef get_rebar_spacing(mesh, fkey):\n    TAG = 'spacing_'\n    AS_TAGS = ['asx_', 'asy_']\n    SF = 1.0\n\n    diam_x = mesh.get_face_attribute(fkey, 'bar_diameter_x') / 1000.\n    diam_y = mesh.get_face_attribute(fkey, 'bar_diameter_y') / 1000.\n\n\n    sp_x = mesh.get_face_attribute(fkey, TAG + AS_TAGS[0]) * SF\n    sp_y = mesh.get_face_attribute(fkey, TAG + AS_TAGS[1]) * SF\n    return [diam_x, diam_y], [sp_x, sp_y]\n\n\ndef get_rc_property(fkey, s_sec, m_conc, m_reb, diam, spac, he, ang):\n    pr_n = 'ep_' + str(fkey)\n    rebar = get_rebar(m_reb, diam, spac, he, ang)\n    ep = Properties(name=pr_n, material=m_conc, section=s_sec, elements=[fkey], reinforcement=rebar)\n\n    if fkey == 0:\n        # print(angle, t, cover, sp_x_b, sp_x_t, diam_x)\n        print(rebar)\n    return ep\n\n\ndef get_rebar(mat_rebar, diameter, spacing, height, angle):\n    rebar = {\n            'r_x': {'pos': height[0],\n                    'spacing': spacing[0],\n                    'material': mat_rebar,\n                    'dia': diameter[0],\n                    'angle': angle[0]\n                    },\n            'r_y': {'pos': height[1],\n                    'spacing': spacing[1],\n                    'material': mat_rebar,\n                    'dia': diameter[1],\n                    'angle': angle[1]\n                    }\n            }\n    return rebar\n\n\ndef add_nodes_elements_from_mesh(stru, mesh, s_sec, m_conc, m_reb, angles, heights, elset):\n\n    for key in sorted(list(mesh.vertices()), key=int):\n        stru.add_node(mesh.vertex_coordinates(key))\n\n    ek = []\n    for fkey in mesh.faces():\n\n        f = []\n        for i in mesh.face[fkey]:\n            f.append(stru.check_node_exists(mesh.vertex_coordinates(i)))\n        ek.append(stru.add_element(nodes=f, type='ShellElement'))\n\n        # add rc properties\n        diam, spac = get_rebar_spacing(mesh, fkey)\n        ang = angles[fkey]\n        he = heights[fkey]\n        ep = get_rc_property(fkey, s_sec, m_conc, m_reb, diam, spac, he, ang)\n        stru.add_element_properties(ep)\n\n    stru.add_set(name=elset, type='element', selection=ek)\n\n    return ek\n\n\ndef add_nodes_elements_from_mesh_simple(stru, mesh, elset):\n    for key in sorted(list(mesh.vertices()), key=int):\n        stru.add_node(mesh.vertex_coordinates(key))\n    ek = []\n\n    for fkey in mesh.faces():\n\n        f = []\n        for i in mesh.face[fkey]:\n            f.append(stru.check_node_exists(mesh.vertex_coordinates(i)))\n\n        ek.append(stru.add_element(nodes=f, type='ShellElement'))\n\n    if elset:\n        stru.add_set(name=elset, type='element', selection=ek)\n\n    return ek\n\n\ndef add_element_set(structure, guids, name):\n    added_ele = set()\n\n    for guid in guids:\n        if rs.IsMesh(guid):\n            vertices = rs.MeshVertices(guid)\n            faces = rs.MeshFaceVertices(guid)\n            nodes = [structure.add_node(vertex) for vertex in vertices]\n\n            for f in rs.MeshFaceVertices(guid):\n                nodes = [structure.check_node_exists(vertices[i]) for i in f]\n\n                if nodes[-1] == nodes[-2]:\n                    del nodes[-1]\n\n                ekey = structure.add_element(nodes=nodes, type='ShellElement')\n                if ekey is not None:\n                    added_ele.add(ekey)\n\n    structure.add_set(name=name, type='element', selection=list(added_ele))\n\n\ndef add_points_sets(structure, points, names):\n    for idx, point_list in enumerate(points.Branches):\n        name = names[idx]\n        check_points = [rs.IsPoint(pt) for pt in point_list]\n        if all(check_points):\n            add_node_set(structure=structure, pt_guids=point_list, name=name)\n        else:\n            print('*****.set not created *****'.format(name))\n\n\ndef add_node_set(structure, pt_guids, name):\n    nodes = []\n    for pt_guid in pt_guids:\n        if rs.IsPoint(pt_guid):\n            node = structure.check_node_exists(rs.PointCoordinates(pt_guid))\n            if node is not None:\n                nodes.append(node)\n    structure.add_set(name=name, type='node', selection=nodes)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}