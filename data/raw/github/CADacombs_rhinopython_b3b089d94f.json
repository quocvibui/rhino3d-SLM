{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Crv_ArcRefGeom.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Crv_ArcRefGeom.py",
  "instruction": "Spb crv arc ref geom",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n250312-13: Created.\r\n\r\nTODO:\r\n    WIP: Only allow arc-shaped curves to be selected.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    #key = 'fScaleFactor'; keys.append(key)\r\n    #values[key] = 2.0\r\n    #names[key] = 'ScaleFactor'\r\n    #riOpts[key] = ri.Custom.OptionDouble(\r\n    #        initialValue=values[key],\r\n    #        setLowerLimit=True,\r\n    #        limit=Rhino.RhinoMath.SqrtEpsilon\r\n    #)\r\n    #stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fTol_IsArc'; keys.append(key)\r\n    values[key] = 1e-6 * Rhino.RhinoMath.UnitScale(\r\n        Rhino.UnitSystem.Millimeters, sc.doc.ModelUnitSystem)\r\n    names[key] = 'IsArcTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key], setLowerLimit=True,\r\n        limit=Rhino.RhinoMath.ZeroTolerance)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.ModelUnitSystem)\r\n\r\n    key = 'bAddArcIfInputIsNotArcCrv'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if riOpts[key]:\r\n                values[key] = riOpts[key].CurrentValue = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        #if key == 'fSearchTol':\r\n        #    if cls.riOpts[key].CurrentValue < 0.0:\r\n        #        cls.riOpts[key].CurrentValue = cls.values[key] = cls.riOpts[key].InitialValue\r\n        #        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n        #        return\r\n\r\n        #    sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n        #    return\r\n\r\n        if key == 'fTol_IsArc':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < cls.riOpts[key].InitialValue:\r\n                cls.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.listValues:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = idxList\r\n\r\n        print(\"Invalid key?\")\r\n\r\n\r\ndef getInput(bDebug=False):\r\n    \"\"\"\r\n    Get linear curves.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n    go.SetCommandPrompt(\"Select arc-shaped curves\")\r\n    \r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\r\n    #go.GeometryAttributeFilter = (\r\n    #    ri.Custom.GeometryAttributeFilter.\r\n\r\n    #go.AcceptNumber(True, acceptZero=False)\r\n    go.EnableClearObjectsOnEntry(False) # If not set to False, faces will be unselected when result == ri.GetResult.Object \r\n\r\n    idxs_Opts = {}\r\n\r\n    def addOption(key): idxs_Opts[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n        idxs_Opts.clear()\r\n\r\n        #addOption('fScaleFactor')\r\n        addOption('fTol_IsArc')\r\n        addOption('bAddArcIfInputIsNotArcCrv')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fTol_IsArc'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opts:\r\n            if go.Option().Index == idxs_Opts[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef _formatDistance(fDistance, fPrecision=None):\r\n    if fDistance is None:\r\n        return \"(None)\"\r\n    if fDistance == Rhino.RhinoMath.UnsetValue:\r\n        return \"(Infinite)\"\r\n    if fPrecision is None:\r\n        fPrecision = sc.doc.ModelDistanceDisplayPrecision\r\n\r\n    if fDistance < 10.0**(-(fPrecision-1)):\r\n        # For example, if fDistance is 1e-5 and fPrecision == 5,\r\n        # the end of this script would display only one digit.\r\n        # Instead, this return displays 2 digits.\r\n        return \"{:.2e}\".format(fDistance)\r\n\r\n    return \"{:.{}f}\".format(fDistance, fPrecision)\r\n\r\n\r\ndef _formatRadius(radius):\r\n    if sc.doc.ModelUnitSystem == Rhino.UnitSystem.Millimeters:\r\n        return _formatDistance(radius)\r\n\r\n    return \"{} {} [{} millimeters]\".format(\r\n        _formatDistance(radius),\r\n        sc.doc.GetUnitSystemName(\r\n            modelUnits=True,\r\n            capitalize=False,\r\n            singular=False,\r\n            abbreviate=False),\r\n        _formatDistance(radius*Rhino.RhinoMath.UnitScale(\r\n            sc.doc.ModelUnitSystem, Rhino.UnitSystem.Millimeters),\r\n            fPrecision=4)\r\n        )\r\n\r\n\r\ndef main():\r\n\r\n    objrefs = getInput()\r\n    if objrefs is None: return\r\n\r\n    #fScaleFactor = Opts.values['fScaleFactor']\r\n    fTol_IsArc = Opts.values['fTol_IsArc']\r\n    bAddArcIfInputIsNotArcCrv = Opts.values['bAddArcIfInputIsNotArcCrv']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    radii = []\r\n\r\n    for objref in objrefs:\r\n        rgC_In = objref.Curve()\r\n        if rgC_In is None:\r\n            continue\r\n\r\n        bSuccess, arc = rgC_In.TryGetArc(tolerance=fTol_IsArc)\r\n        if not bSuccess:\r\n            continue\r\n\r\n        if isinstance(rgC_In, rg.BrepEdge):\r\n            bIsEdge = True\r\n            rgC_In_NotProxy = rgC_In.DuplicateCurve()\r\n        else:\r\n            bIsEdge = False\r\n            rgC_In_NotProxy = rgC_In\r\n\r\n        if isinstance(rgC_In_NotProxy, rg.ArcCurve):\r\n            bIsArcCrv = True\r\n            arc = rgC_In_NotProxy.Arc\r\n        else:\r\n            bIsArcCrv = False\r\n\r\n        radius = arc.Radius\r\n        radii.append(radius)\r\n\r\n        plane = arc.Plane\r\n\r\n        ps = rg.PlaneSurface(\r\n            plane,\r\n            xExtents=rg.Interval(-radius, radius),\r\n            yExtents=rg.Interval(-radius, radius))\r\n\r\n        line = rg.Line(plane.Origin, span=arc.Radius*plane.Normal)\r\n\r\n        sc.doc.Objects.AddSurface(ps)\r\n\r\n        sc.doc.Objects.AddLine(line)\r\n\r\n        if bAddArcIfInputIsNotArcCrv and not bIsArcCrv:\r\n            sc.doc.Objects.AddArc(arc)\r\n\r\n    if bEcho:\r\n        if len(objrefs) == 1:\r\n            if len(radii) == 0:\r\n                print(\"Curve is not arc-shaped.\")\r\n            else:\r\n                print(\"Curve's radius is {}.\".format(_formatRadius(radius)))\r\n        else:\r\n            if len(radii) == 0:\r\n                print(\"None of the curves are arc-shaped.\")\r\n            elif len(objrefs) > 10:\r\n                print(\"Arc-shaped curves found.\")\r\n            else:\r\n                print(\"Curves' radii: {}\".format(\r\n                    \", \".join([_formatRadius(radius) for radius in radii])))\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}