{
  "source_url": "https://github.com/gperonato/GHCitySim/blob/05bf431de75f867ff67262b44c8d46742dfb3e65/src/Honeybee_CitySim-LoadSolar.py",
  "repo": "gperonato/GHCitySim",
  "repo_stars": 14,
  "repo_description": "Set of Grasshopper components for interfacing with CitySim. ©2016-2018 EPFL-LIPID",
  "license": "unknown",
  "filepath": "src/Honeybee_CitySim-LoadSolar.py",
  "instruction": "Honeybee city sim load solar",
  "code": "﻿# GH-CitySim: an interface to CitySim started by Giuseppe Peronato\n#\n# © All rights reserved. Ecole polytechnique fédérale de Lausanne (EPFL), Switzerland,\n# Laboratory of Integrated Performance in Design (LIPID), 2016-2017\n# Author: Giuseppe Peronato, <giuseppe.peronato@epfl.ch\n#\n# CitySim is a software developed and distributed by the\n# Laboratory of Solar Energy and Building Physics (LESO-PB)\n# http://citysim.epfl.ch/\n\n\"\"\"\nThis component loads the Citysim ouput into Grasshopper.\n\n-\nThis component will hopefully be part of\nLadybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n\n@license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n-\n\n    \n    Args:\n        dir: Directory\n        name: name of the project\n        yearly: Loads yearly results (default = False)\n        geometry: same geometry used as simulation input\n        type: choose between SW or DC (default = SW)\n        Run: set Boolean to True to load the results\n    Returns:\n        results: SW radiation\n\"\"\"\n\nghenv.Component.Name = \"Honeybee_CitySim-LoadSolar\"\nghenv.Component.NickName = 'CitySim-LoadSolar'\nghenv.Component.Message = 'VER 0.0.2\\nAVR_01_2017'\nghenv.Component.Category = \"Honeybee\"\nghenv.Component.SubCategory = \"14 | CitySim\"\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"2\"\nexcept: pass\n\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport uuid\n\n#Default values\ntype = \"SW\"\nyearly = False\n\nif dir != None:\n    dir += \"\\\\\" #Add \\ in case is missing\n\n#Get surfaces from Honeybee zones\n# written by Giulio Piacentino, giulio@mcneel.com\ndef tree_to_list(input, retrieve_base = lambda x: x[0]):\n    \"\"\"Returns a list representation of a Grasshopper DataTree\"\"\"\n    def extend_at(path, index, simple_input, rest_list):\n        target = path[index]\n        if len(rest_list) <= target: rest_list.extend([None]*(target-len(rest_list)+1))\n        if index == path.Length - 1:\n            rest_list[target] = list(simple_input)\n        else:\n            if rest_list[target] is None: rest_list[target] = []\n            extend_at(path, index+1, simple_input, rest_list[target])\n    all = []\n    for i in range(input.BranchCount):\n        path = input.Path(i)\n        extend_at(path, 0, input.Branch(path), all)\n    return retrieve_base(all)\n    \ngeometry = tree_to_list(geometry, lambda x: x)\n\n\n\n\n\ndef list_to_tree(input, none_and_holes=True, source=[0]):\n    \"\"\"Transforms nestings of lists or tuples to a Grasshopper DataTree\"\"\"\n    # written by Giulio Piacentino, giulio@mcneel.com\n    from Grasshopper import DataTree as Tree\n    from Grasshopper.Kernel.Data import GH_Path as Path\n    from System import Array\n    def proc(input,tree,track):\n        path = Path(Array[int](track))\n        if len(input) == 0 and none_and_holes: tree.EnsurePath(path); return\n        for i,item in enumerate(input):\n            if hasattr(item, '__iter__'): #if list or tuple\n                track.append(i); proc(item,tree,track); track.pop()\n            else:\n                if none_and_holes: tree.Insert(item,path,i)\n                elif item is not None: tree.Add(item,path)\n    if input is not None: t=Tree[object]();proc(input,t,source[:]);return t\n    \n    \ndef loadOut(path,name,type=\"SW\",yearly=True):\n    #Load SW output file\n    if yearly:\n        ending = \"_yearly.out\"\n    else:\n        ending = \".out\"\n    in_file = open(path+name+\"_\"+type+ending,\"r\")\n    txt = in_file.read()\n    in_file.close()\n    results = txt.splitlines()\n    header = results[0]\n    results.pop(0) #remove header\n    return header, results\n\ndef parseHead(head):        \n    #Parse header\n    import re\n    header = head.split()\n    #header.pop(0)\n    bIDs = []\n    sIDs = []\n    for i in range(len(header)):\n        if i == 0:\n            bIDs.append('')\n            sIDs.append('')\n        else:\n            b = header[i].split('(')\n            s = re.search('(?<=:)\\w+', header[i])\n            b = b[0]\n            s = s.group(0)\n            #print 'building', b, 'surface', s\n            bIDs.append(b)\n            sIDs.append(int(s))\n    return bIDs, sIDs\n\ndef parseRes(results,sIDs):\n    #Parse results\n    irrH = []\n\n    for l in results: #for each line corresponding to a hour\n        bldg = []\n        isrf = []\n        for i in l.split(): #split the surfaces\n            isrf.append(float(i))\n        irrH.append(isrf)\n    #print len(isrf)\n    irrS = []\n    for s in xrange(len(sIDs)): #for each surface\n        srf = []\n        for h in range(len(irrH)): #for each hour\n            srf.append(irrH[h][s])\n        irrS.append(srf)\n    return irrS\n\ndef removeTerr(irrS,bIDs,sIDs):   \n    #Remove terrain from results \n    bIDs2 = []\n    sIDs2 = []\n    IDs = []\n    irrS2 = []\n    for s in xrange(len(bIDs)):\n        if bIDs[s] != \"NA\" and bIDs[s] != \"\" : #remove columns\n            sIDs2.append(int(sIDs[s]))\n            bIDs2.append(int(bIDs[s]))\n            IDs.append([int(bIDs[s]),int(sIDs[s])])\n            irrS2.append(irrS[s])\n    return irrS2, bIDs2, sIDs2\n\n\nif Run:\n    header, results = loadOut(dir,name,type,yearly)\n    bIDs, sIDs = parseHead(header)\n    irrS = parseRes(results,sIDs)\n    irrS2, bIDs2, sIDs2 = removeTerr(irrS,bIDs,sIDs)\n    \n    \n    #Create a dictionary from the output file\n    diction = {}\n    for i in xrange(len(bIDs2)):\n        diction[str(bIDs2[i])+\"-\"+str(sIDs2[i])]= irrS2[i]\n        \n    #Create lists of IDs from geometry data tree\n    bIDs3 = []\n    sIDs3 = []\n    for b in xrange(len(geometry)):\n        for s in xrange(len(geometry[b])):\n            bldgid, srfid = b, s, \n            bIDs3.append(int(bldgid))\n            sIDs3.append(int(srfid))\n    bIDs3set = list(set(bIDs3)) #create a set of unique building IDs from geometry data tree\n    \n    #Iterate over the geometry IDs\n    output = []\n    for b in bIDs3set:\n        bldg = []\n        for s in xrange(len(sIDs3)):\n            if bIDs3[s] == b:\n                #print b, sIDs2[s]\n                #print str(b)+'-'+str(sIDs3[s])\n                bldg.append(diction.get(str(b)+'-'+str(sIDs3[s]),[-1])) #if the key is valid retun list of hourly values, otherwise empty list\n        output.append(bldg)\n\n    results = list_to_tree(output,none_and_holes=True, source=[])",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}