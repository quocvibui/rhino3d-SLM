{
  "source_url": "https://github.com/dtbinh/T1_python-exercises/blob/f4710c3dc2ba8ddb3e3e9069ab8d65df674463ab/07_ur_online/shifted_frames_setup/compas/packages/compas_fabrication/fabrication/grasshopper/path_planning.py",
  "repo": "dtbinh/T1_python-exercises",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "07_ur_online/shifted_frames_setup/compas/packages/compas_fabrication/fabrication/grasshopper/path_planning.py",
  "instruction": "Path planning",
  "code": "from __future__ import print_function\n\nimport logging\nfrom timeit import default_timer as timer\nfrom compas_fabrication.fabrication.robots import Pose\nfrom compas_fabrication.fabrication.robots.rfl import Configuration, SimulationCoordinator\nfrom compas_fabrication.fabrication.grasshopper.geometry import xform_from_matrix, vrep_pose_from_plane\nfrom compas_fabrication.fabrication.grasshopper.helpers import mesh_from_guid\n\ntry:\n    import clr\n    import rhinoscriptsyntax as rs\n    from Rhino.Geometry import Transform\n    from Rhino.Geometry import Mesh as RhinoMesh\nexcept ImportError:\n    import platform\n    if platform.python_implementation() == 'IronPython':\n        raise\n\nLOG = logging.getLogger('compas_fabrication.grasshopper.path_planning')\n\n\ndef _transform_to_origin(mesh, xform):\n    inverse = clr.StrongBox[Transform]()\n    if not xform.TryGetInverse(inverse):\n        raise ValueError('Unable to get inverse of matrix')\n\n    mesh.Transform(inverse.Value)\n\n    return mesh\n\n\ndef _create_rhino_mesh(vertices, faces):\n    vertices = [vertices[i:i + 3] for i in range(0, len(vertices), 3)]\n    faces = [faces[i:i + 3] for i in range(0, len(faces), 3)]\n    mesh = RhinoMesh()\n    for a, b, c in vertices:\n        mesh.Vertices.Add(a, b, c)\n    for face in faces:\n        mesh.Faces.AddFace(face[0], face[1], face[2])\n\n    return mesh\n\n\nclass PathVisualizer(object):\n    \"\"\"Handles the generation of meshes to visualize a full path plan\n    in Rhino/Grasshopper.\n    \"\"\"\n    def __init__(self, simulator, robot, building_member=None, building_member_pickup_config=None):\n        self.simulator = simulator\n        self.robot = robot\n        self.building_member = building_member\n        self.building_member_pickup_config = building_member_pickup_config\n\n    def get_frame_meshes(self, path, frame, ctx):\n        \"\"\"Retrieves all meshes required to render a specific frame of a path plan.\n\n        Args:\n            path (:obj:`list` of :class:`Configuration`): Represents a collision-free\n                path to a goal pose. It is the output of the path planning generated\n                by a :class:`Simulator` object.\n            frame (:obj:`int`): Frame number to retrieve.\n            ctx (:obj:`dict`): A dictionary to keep context. Within Grasshopper, this is\n                normally the ``sc.sticky`` object.\n\n        Returns:\n            list: list of Rhino meshes that can be used to visualize the selected frame.\n        \"\"\"\n        first_start = timer() if self.debug else None\n        shape_handles = self.simulator.get_all_visible_handles()\n        if self.debug:\n            LOG.debug('Execution time: get_all_visible_handles=%.2f', timer() - first_start)\n\n        if 'rfl_meshes' not in ctx:\n            ctx['rfl_meshes'] = self._get_rfl_meshes(shape_handles)\n\n        frame_config = path[frame]\n\n        start = timer() if self.debug else None\n        self.simulator.set_robot_config(self.robot, frame_config)\n        if self.debug:\n            LOG.debug('Execution time: set_robot_config=%.2f', timer() - start)\n\n        start = timer() if self.debug else None\n        meshes = []\n        mesh_matrices = self.simulator.get_object_matrices(shape_handles)\n        for handle, mesh_matrix in mesh_matrices.iteritems():\n            mesh = ctx['rfl_meshes'][handle].DuplicateShallow()\n            mesh.Transform(xform_from_matrix(mesh_matrix))\n            meshes.append(mesh)\n\n        if self.building_member:\n            gripping_config = self.building_member_pickup_config if self.building_member_pickup_config else path[0]\n            info = self._get_building_member_info(gripping_config)\n            mesh = info['mesh'].DuplicateShallow()\n            parent_transform = xform_from_matrix(mesh_matrices[info['parent_handle']])\n            relative_transform = info['relative_transform']\n\n            mesh.Transform(Transform.Multiply(parent_transform, relative_transform))\n            meshes.append(mesh)\n\n        if self.debug:\n            LOG.debug('Execution time: get all transformed meshes=%.2f', timer() - start)\n            LOG.debug('Execution time: total=%.2f', timer() - first_start)\n\n        return meshes\n\n    @property\n    def debug(self):\n        \"\"\"Indicates whether the path visualizer is in debug mode or not.\"\"\"\n        return self.simulator.debug\n\n    def _get_rfl_meshes(self, shape_handles):\n        start = timer() if self.debug else None\n        shape_geometry = []\n        for handle in shape_handles:\n            _, faces, vertices, _, _ = self.simulator.run_child_script('getShapeMesh', [handle], [], [])\n            shape_geometry.append((vertices, faces))\n\n        rfl_meshes = {}\n        _, _, mesh_matrices, _, _ = self.simulator.run_child_script('getShapeMatrices', shape_handles, [], [])\n        for i in range(0, len(mesh_matrices), 12):\n            handle = shape_handles[i // 12]\n            vertices, faces = shape_geometry[i // 12]\n            transform = xform_from_matrix(mesh_matrices[i:i + 12])\n            mesh = _transform_to_origin(_create_rhino_mesh(vertices, faces), transform)\n            rfl_meshes[handle] = mesh\n\n        if self.debug:\n            LOG.debug('Execution time: create RFL meshes at origin=%.2f', timer() - start)\n\n        return rfl_meshes\n\n    def _get_building_member_info(self, gripping_config):\n        start = timer() if self.debug else None\n\n        self.simulator.set_robot_config(self.robot, gripping_config)\n        mesh = mesh_from_guid(self.building_member)\n        handle = self.simulator.add_building_member(self.robot, mesh)\n        matrix = self.simulator.get_object_matrices([handle])[handle]\n\n        parent_handle = self.simulator.get_object_handle('customGripper' + self.robot.name)\n        _, _, mesh_matrix, _, _ = self.simulator.run_child_script('getShapeMatrixRelative', [handle, parent_handle], [], [])\n\n        relative_transform = xform_from_matrix(mesh_matrix)\n\n        transform = xform_from_matrix(matrix)\n        mesh_at_origin = _transform_to_origin(rs.coercemesh(self.building_member), transform)\n\n        if self.debug:\n            LOG.debug('Execution time: building member=%.2f', timer() - start)\n\n        return {'mesh': mesh_at_origin,\n                'parent_handle': parent_handle,\n                'relative_transform': relative_transform}\n\n\nclass PathPlanner(object):\n    \"\"\"Provides a simple/compact API to call the path planner from Grasshopper.\"\"\"\n\n    @classmethod\n    def find_path(cls, host='127.0.0.1', port=19997, mode='local', **kwargs):\n        \"\"\"Finds a path for the specified scene description. There is a large number\n        of parameters that can be passed as `kwargs`. It can run in two modes: *remote* or\n        *local*. In remote mode, the `host` and `port` parameters correspond to a\n        simulation coordinator, and in local mode, `host` and `port` correspond to\n        a V-REP instance.\n\n        Args:\n            host (:obj:`str`): IP address of the service (simulation coordinator in `remote`, V-REP in `local` mode)\n            port (:obj:`int`): Port of the service.\n            mode (:obj:`str`): Execution mode, either ``local`` or ``remote``.\n            kwargs: Keyword arguments.\n\n        Returns:\n            list: list of configurations representing a path.\n        \"\"\"\n        parser = InputParameterParser()\n        options = {'robots': []}\n        active_robot = None\n\n        if 'robots' in kwargs:\n            for i, settings in enumerate(kwargs['robots']):\n                if 'robot' not in settings:\n                    raise KeyError(\"'robot' not found at kwargs['robots'][%d]\" % i)\n\n                robot = {'robot': settings['robot']}\n\n                if 'start' in settings:\n                    start = parser.get_config_or_pose(settings['start'])\n                    if start:\n                        robot['start'] = start.to_data()\n\n                if 'goal' in settings:\n                    if not active_robot:\n                        active_robot = robot\n                        goal = parser.get_config_or_pose(settings['goal'])\n                        if goal:\n                            robot['goal'] = goal.to_data()\n                    else:\n                        raise ValueError('Multi-move is not (yet) supported. Only one goal can be specified.')\n\n                if 'building_member' in settings:\n                    robot['building_member'] = mesh_from_guid(settings['building_member']).to_data()\n\n                if 'metric_values' in settings:\n                    robot['metric_values'] = map(float, settings['metric_values'].split(','))\n\n                if 'joint_limits' in settings:\n                    robot['joint_limits'] = settings['joint_limits']\n\n                options['robots'].append(robot)\n\n        if 'collision_meshes' in kwargs:\n            mesh_guids = parser.compact_list(kwargs['collision_meshes'])\n            options['collision_meshes'] = map(lambda m: m.to_data(), map(mesh_from_guid, mesh_guids))\n\n        options['debug'] = kwargs.get('debug')\n        options['trials'] = kwargs.get('trials')\n        options['shallow_state_search'] = kwargs.get('shallow_state_search')\n        options['algorithm'] = kwargs.get('algorithm')\n        options['resolution'] = kwargs.get('resolution')\n\n        if mode == 'remote':\n            LOG.debug('Running remote path planner executor. Host=%s:%d', host, port)\n            return SimulationCoordinator.remote_executor(options, host, port)\n        else:\n            LOG.debug('Running local path planner executor. Host=%s:%d', host, port)\n            return SimulationCoordinator.local_executor(options, host, port)\n\n\nclass InputParameterParser(object):\n    \"\"\"Simplifies some tasks related to parsing Grasshopper input parameters\n    for path planning.\"\"\"\n\n    def compact_list(self, list):\n        \"\"\"Compacts a list filtering all `None` values.\"\"\"\n        return filter(None, list)\n\n    def get_pose(self, plane_or_pose):\n        \"\"\"Gets a pose that is compatible with V-REP from a string containing\n        comma-separated floats or from a Rhino/Grasshopper plane.\n\n        Args:\n            plane_or_pose (comma-separated :obj:`str` of a Rhino :obj:`Plane`):\n\n        Returns:\n            pose: :class:`.Pose` instance representing a transformation matrix.\n        \"\"\"\n        if not plane_or_pose:\n            return None\n\n        try:\n            return Pose.from_list(vrep_pose_from_plane(plane_or_pose))\n        except (TypeError, IndexError):\n            return Pose.from_list(map(float, plane_or_pose.split(','))) if plane_or_pose else None\n\n    def get_config_or_pose(self, config_values_or_plane):\n        \"\"\"Parses multiple input data types and returns a configuration or a pose\n        represented as a transformation matrix.\n\n        Args:\n            config_values_or_plane (comma-separated :obj:`string`, or :class:`Configuration` instance,\n                or a Rhino :obj:`Plane`).\n        \"\"\"\n        if not config_values_or_plane:\n            return None\n\n        try:\n            return Pose.from_list(vrep_pose_from_plane(config_values_or_plane))\n        except (TypeError, IndexError):\n            try:\n                if config_values_or_plane.external_axes and config_values_or_plane.joint_values:\n                    return config_values_or_plane\n            except AttributeError:\n                values = map(float, config_values_or_plane.split(','))\n                return Configuration.from_degrees_list(values)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}