{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/xBrepEdge_replaceCurve.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "xBrepEdge_replaceCurve.py",
  "instruction": "200701: Created.",
  "code": "\"\"\"\r\n200701: Created.\r\n\"\"\"\r\n\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    idxOpt = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fTol'; keys.append(key)\r\n    values[key] = 1.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        cls.idxOpt[key] = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                cls.idxOpt[key] = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                cls.idxOpt[key] = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                cls.idxOpt[key] = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            cls.idxOpt[key] = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n\r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            if key == 'fTol':\r\n                if cls.riOpts[key].CurrentValue < 0.0:\r\n                    cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n\r\n\r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if key in cls.riOpts:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                # For OptionList.\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput_Edge():\r\n    \"\"\"\r\n    Get BrepEdge with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select edge to replace\")\r\n    \r\n    go.GeometryFilter = rd.ObjectType.EdgeFilter\r\n\r\n    go.AcceptNumber(enable=True, acceptZero=True)\r\n\r\n    idxs_Opts = {}\r\n    \r\n    while True:\r\n        Opts.addOption(go, 'fTol')\r\n        Opts.addOption(go, 'bEcho')\r\n        Opts.addOption(go, 'bDebug')\r\n        \r\n        res = go.Get()\r\n        \r\n        if res == ri.GetResult.Object:\r\n            objref = go.Object(0)\r\n            go.Dispose()\r\n            return tuple([objref] + [Opts.values[key] for key in Opts.keys])\r\n        elif res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        # An option was selected or a number was entered.\r\n\r\n        if res == ri.GetResult.Number:\r\n            Opts.riOpts['fTol'].CurrentValue = go.Number()\r\n\r\n        Opts.setValues()\r\n        Opts.saveSticky()\r\n        go.ClearCommandOptions()\r\n\r\n\r\ndef getInput_Curve():\r\n    \"\"\"\r\n    Get Curve with optional input.\r\n    \"\"\"\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select replacing curve\")\r\n    \r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n\r\n    go.AcceptNumber(enable=True, acceptZero=True)\r\n\r\n    idxs_Opts = {}\r\n    \r\n    while True:\r\n        Opts.addOption(go, 'fTol')\r\n        Opts.addOption(go, 'bEcho')\r\n        Opts.addOption(go, 'bDebug')\r\n        \r\n        res = go.Get()\r\n        \r\n        if res == ri.GetResult.Object:\r\n            objref = go.Object(0)\r\n            go.Dispose()\r\n            return tuple([objref] + [Opts.values[key] for key in Opts.keys])\r\n        elif res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        # An option was selected or a number was entered.\r\n\r\n        if res == ri.GetResult.Number:\r\n            Opts.riOpts['fTol'].CurrentValue = go.Number()\r\n\r\n        Opts.setValues()\r\n        Opts.saveSticky()\r\n        go.ClearCommandOptions()\r\n\r\n\r\ndef replaceBrepObject(objref_Edge, objref_Curve, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n\r\n    def setOpt(key, value=None):\r\n        if key in kwargs:\r\n            return kwargs[key]\r\n        elif key in Opts.riOpts:\r\n            return Opts.riOpts[key].InitialValue\r\n        else:\r\n            return value\r\n\r\n    fTol = setOpt('fTol')\r\n    bEcho = setOpt('bEcho')\r\n    bDebug = setOpt('bDebug')\r\n\r\n\r\n    def printValidLog():\r\n        bValid, sLog = rgBrep_Out.IsValidWithLog()\r\n        if bValid:\r\n            print \"Brep is valid.\"\r\n        else:\r\n            print sLog\r\n\r\n\r\n    rdBrep_In = objref_Edge.Object()\r\n    rgBrep_In = rdBrep_In.Geometry.Duplicate() # So it is not DocumentControlled.\r\n    rgEdge_toMod = objref_Edge.Edge()\r\n    rgCrv_In = objref_Curve.Curve().DuplicateCurve() # DuplicateCurve in case Curve is a BrepEdge.\r\n\r\n    rgBrep_In.Compact() # Purge unused components to avoid duplicating them.\r\n\r\n\r\n    rgBrep_Out = rg.Brep()\r\n\r\n\r\n    for srf_In in rgBrep_In.Surfaces:\r\n        srf_Out = srf_In.Duplicate()\r\n        rgBrep_Out.AddSurface(srf_Out)\r\n\r\n\r\n    for iEC, iE in sorted([(e.EdgeCurveIndex, i) for i, e in enumerate(rgBrep_In.Edges)]):\r\n        edge_In = rgBrep_In.Edges[iE]\r\n        if edge_In.EdgeIndex != rgEdge_toMod.EdgeIndex:\r\n            edgeCrv_Out = edge_In.EdgeCurve.Duplicate()\r\n            rgBrep_Out.AddEdgeCurve(edgeCrv_Out)\r\n        else:\r\n            if not rg.Curve.DoDirectionsMatch(curveA=edge_In.EdgeCurve, curveB=rgCrv_In):\r\n                rgCrv_In.Reverse()\r\n            rgBrep_Out.AddEdgeCurve(rgCrv_In)\r\n\r\n\r\n    for iTC, iT in sorted([(t.TrimCurveIndex, i) for i, t in enumerate(rgBrep_In.Trims)]):\r\n        trim_In = rgBrep_In.Trims[iT]\r\n\r\n        if trim_In.Edge.EdgeIndex != rgEdge_toMod.EdgeIndex:\r\n            trimCrv_Out = trim_In.TrimCurve.Duplicate()\r\n            rgBrep_Out.AddTrimCurve(trimCrv_Out)\r\n        else:\r\n            face_In = trim_In.Face\r\n            srf_In = face_In.UnderlyingSurface()\r\n            trimCrv_Out = srf_In.Pullback(rgCrv_In, tolerance=fTol)\r\n            if not rg.Curve.DoDirectionsMatch(curveA=trimCrv_Out, curveB=trim_In.TrimCurve):\r\n                trimCrv_Out.Reverse()\r\n            rgBrep_Out.AddTrimCurve(trimCrv_Out)\r\n\r\n\r\n    #for i, c in enumerate(rgBrep_Out.Curves3D):\r\n    #    sc.doc.Objects.AddCurve(c)\r\n    #    sc.doc.Objects.AddTextDot(text=str(i),location=c.PointAt(c.Domain.Mid))\r\n    #sc.doc.Views.Redraw()\r\n    #return\r\n\r\n\r\n    for iF, face_In in enumerate(rgBrep_In.Faces):\r\n        rgBrep_Out.Faces.Add(face_In.SurfaceIndex)\r\n        rgBrep_Out.Faces[rgBrep_Out.Faces.Count-1].OrientationIsReversed = (\r\n            face_In.OrientationIsReversed)\r\n\r\n\r\n    for iV, vertex_In in enumerate(rgBrep_In.Vertices):\r\n        rgBrep_Out.Vertices.Add(\r\n            point=vertex_In.Location,\r\n            vertexTolerance=fTol)\r\n\r\n\r\n    for iL, loop_In in enumerate(rgBrep_In.Loops):\r\n        rgBrep_Out.Loops.Add(\r\n            loopType=loop_In.LoopType,\r\n            face=rgBrep_Out.Faces[loop_In.Face.FaceIndex])\r\n\r\n\r\n    for iE, edge_In in enumerate(rgBrep_In.Edges):\r\n        rgBrep_Out.Edges.Add(\r\n            startVertexIndex=edge_In.StartVertex.VertexIndex,\r\n            endVertexIndex=edge_In.EndVertex.VertexIndex,\r\n            curve3dIndex=edge_In.EdgeCurveIndex,\r\n            edgeTolerance=fTol)\r\n\r\n\r\n    for iT, trim_In in enumerate(rgBrep_In.Trims):\r\n        rgBrep_Out.Trims.Add(\r\n            edge=rgBrep_Out.Edges[trim_In.Edge.EdgeIndex],\r\n            rev3d=trim_In.IsReversed(),\r\n            loop=rgBrep_Out.Loops[trim_In.Loop.LoopIndex],\r\n            curve2dIndex=trim_In.TrimCurveIndex)\r\n        rgBrep_Out.Trims[rgBrep_Out.Trims.Count-1].SetTolerances(0.0,0.0)\r\n        rgBrep_Out.Trims[rgBrep_Out.Trims.Count-1].IsoStatus = (\r\n            trim_In.Face.IsIsoparametric(trim_In.TrimCurve))\r\n\r\n\r\n    if rgBrep_Out.IsValid:\r\n        rgBrep_Out.SetTolerancesBoxesAndFlags(\r\n            bLazy=False,\r\n            bSetVertexTolerances=True,\r\n            bSetEdgeTolerances=True,\r\n            bSetTrimTolerances=True,\r\n            bSetTrimIsoFlags=True,\r\n            bSetTrimTypeFlags=True,\r\n            bSetLoopTypeFlags=True,\r\n            bSetTrimBoxes=True)\r\n        if sc.doc.Objects.Replace(objectId=rdBrep_In.Id, brep=rgBrep_Out):\r\n            if bEcho:\r\n                print \"Brep geometry was replaced.\"\r\n            return rdBrep_In.Id\r\n        else:\r\n            if bEcho:\r\n                print \"Brep geometry was not replaced.\"\r\n    else:\r\n        if bEcho:\r\n            printValidLog()\r\n\r\n\r\ndef main():\r\n    \r\n    rc = getInput_Edge()\r\n    if rc is None: return\r\n\r\n    (\r\n        objref_Edge,\r\n        fTol,\r\n        bEcho,\r\n        bDebug,\r\n        ) = rc\r\n\r\n    rc = getInput_Curve()\r\n    if rc is None: return\r\n\r\n    (\r\n        objref_Curve,\r\n        fTol,\r\n        bEcho,\r\n        bDebug,\r\n        ) = rc\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    gBrep_Res = replaceBrepObject(\r\n        objref_Edge=objref_Edge,\r\n        objref_Curve=objref_Curve,\r\n        fTol=fTol,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}