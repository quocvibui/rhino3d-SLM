{
  "source_url": "https://github.com/felipeharker/alexandria-lab/blob/1d3696f4b28ecc45579b5fbe5809a7e00699fa08/alexandria-application-files/alexandria-scripts/ghpython/variable_curve_eval.py",
  "repo": "felipeharker/alexandria-lab",
  "repo_stars": 1,
  "repo_description": "a repo of documents, links, visual assets, drawings, videos, articles, etc. I find interesting. Brain dump, catch-all repo with limited structure. ",
  "license": "unknown",
  "filepath": "alexandria-application-files/alexandria-scripts/ghpython/variable_curve_eval.py",
  "instruction": "GhPython Component: Variable-density curve sampling (focus as ratio, falloff as slider)",
  "code": "# ALEXANDRIA IO SPEC (standardized)\n# Inputs:\n# - Curve (GH: Crv) | Rhino.Geometry.Curve | Curve to sample\n# - FocusRatio (GH: Focus) | float | Density focus ratio 0..1\n# - MinSpacing (GH: MinS) | float | Minimum spacing\n# - MaxSpacing (GH: MaxS) | float | Maximum spacing\n# - Radius (GH: Radius) | float | Influence radius\n# - FalloffMode (GH: FalloffMode) | int | 0 Gaussian / 1 Smooth / 2 Linear\n# Outputs:\n# - Pts (GH: Pts) | list[Rhino.Geometry.Point3d] | Sampled points\n# - Params (GH: t) | list[float] | Curve parameters at sampled points\n\n\"\"\"GhPython Component: Variable-density curve sampling (focus as ratio, falloff as slider)\n\nInputs:\n    Crv:          Rhino.Geometry.Curve\n    Focus:        float in [0..1] — where density is highest (reparameterized along length)\n    MinS:         float > 0 — minimum spacing (most dense)\n    MaxS:         float >= MinS — maximum spacing (least dense)\n    Radius:       float > 0 — influence radius in length units\n    FalloffMode:  int in {0,1,2} — 0:Gaussian, 1:Smooth, 2:Linear\n\nOutputs:\n    Pts:          list[Rhino.Geometry.Point3d]\n    t:            list[float] curve parameters at sampled points\n\"\"\"\n\nimport math\nfrom Rhino.Geometry import Curve, Point3d, Interval\n\n# -------------------------- Utilities --------------------------------------\n\ndef clamp(x, a, b):\n    return a if x < a else (b if x > b else x)\n\ndef length_to_param(crv, s):\n    rc, tt = crv.LengthParameter(s)\n    if rc: return tt\n    # Edge clamp fallback\n    return crv.Domain.T0 if s <= 0.0 else crv.Domain.T1\n\ndef param_to_length(crv, tt):\n    return crv.GetLength(Interval(crv.Domain.T0, tt))\n\ndef falloff_weight(u, mode):\n    \"\"\"u = normalized distance d/Radius >=0. Return weight in [0..1].\"\"\"\n    if mode == 0:  # Gaussian\n        return math.exp(-0.5 * u * u)\n    elif mode == 1:  # Smooth (compact C1, falls to 0 at u>=1)\n        u = clamp(u, 0.0, 1.0)\n        s = u*u*(3.0 - 2.0*u)  # smoothstep\n        return 1.0 - s\n    elif mode == 2:  # Linear (compact)\n        return max(0.0, 1.0 - u)\n    # default to Gaussian\n    return math.exp(-0.5 * u * u)\n\ndef spacing_at_length(s, s_focus, minS, maxS, radius, mode):\n    \"\"\"Local spacing field s(l) given arc-length l and focus location.\"\"\"\n    if radius <= 0.0:\n        return maxS\n    d = abs(s - s_focus)\n    w = falloff_weight(d / radius, mode)\n    return maxS - (maxS - minS) * w\n\ndef march(crv, start_len, direction, minS, maxS, radius, mode, end_len):\n    \"\"\"Step from start_len toward end_len (direction = +1 or -1) with variable spacing.\"\"\"\n    pts, ts = [], []\n    t0 = length_to_param(crv, start_len)\n    pts.append(crv.PointAt(t0))\n    ts.append(t0)\n\n    s_focus = start_len\n    s = start_len\n    L = crv.GetLength()\n    max_iters = 100000\n    it = 0\n\n    while True:\n        it += 1\n        if it > max_iters:\n            break\n\n        local = spacing_at_length(s, s_focus, minS, maxS, radius, mode)\n        local = max(local, 1e-9)\n\n        s_next = s + direction * local\n        if direction > 0 and s_next > end_len: break\n        if direction < 0 and s_next < end_len: break\n\n        t_next = length_to_param(crv, s_next)\n        pts.append(crv.PointAt(t_next))\n        ts.append(t_next)\n        s = s_next\n\n    return pts, ts\n\n# -------------------------- Main -------------------------------------------\n\nPts, t = [], []\n\nif Crv is None or not isinstance(Crv, Curve):\n    pass\nelse:\n    L = Crv.GetLength()\n    if L > 0:\n        # Sanitize inputs\n        Focus = 0.0 if Focus is None else clamp(float(Focus), 0.0, 1.0)\n        MinS = 0.1 if (MinS is None or MinS <= 0.0) else float(MinS)\n        MaxS = float(MaxS) if (MaxS is not None and MaxS >= MinS) else MinS\n        Radius = float(Radius) if (Radius is not None and Radius > 0.0) else (0.25 * L)\n        mode = int(FalloffMode) if FalloffMode is not None else 0\n        if mode not in (0,1,2): mode = 0\n\n        # Resolve focus as arc length (ratio * total length)\n        s_focus = Focus * L\n\n        # March outwards from focus in both directions\n        f_pts, f_ts = march(Crv, s_focus, +1, MinS, MaxS, Radius, mode, L)\n        b_pts, b_ts = march(Crv, s_focus, -1, MinS, MaxS, Radius, mode, 0.0)\n\n        # Ensure curve ends included\n        # Start\n        if not b_ts or abs(b_ts[-1] - Crv.Domain.T0) > 1e-12:\n            b_pts.append(Crv.PointAt(Crv.Domain.T0))\n            b_ts.append(Crv.Domain.T0)\n        # End\n        if not f_ts or abs(f_ts[-1] - Crv.Domain.T1) > 1e-12:\n            f_pts.append(Crv.PointAt(Crv.Domain.T1))\n            f_ts.append(Crv.Domain.T1)\n\n        # Merge: backward (from start -> focus), then forward (focus -> end)\n        b_pts = list(reversed(b_pts))\n        b_ts  = list(reversed(b_ts))\n\n        # Avoid duplicate focus point if both sides share it\n        if b_ts and f_ts and abs(b_ts[-1] - f_ts[0]) < 1e-12:\n            Pts = b_pts + f_pts[1:]\n            t   = b_ts  + f_ts[1:]\n        else:\n            Pts = b_pts + f_pts\n            t   = b_ts  + f_ts\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}