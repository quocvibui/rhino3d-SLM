{
  "source_url": "https://github.com/felipeharker/harkitecture-lab/blob/8182a567a8bfaa081e74902e337f063ba641623e/alexandria-application-files/scripts/image%20sampler.py",
  "repo": "felipeharker/harkitecture-lab",
  "repo_stars": 0,
  "repo_description": "knowledge hub for FH",
  "license": "unknown",
  "filepath": "alexandria-application-files/scripts/image sampler.py",
  "instruction": "Image Sampler via File Path (UV in 0..1)\nAuthor: FHarker + ChatGPT (2025.10)",
  "code": "\"\"\"Image Sampler via File Path (UV in 0..1)\nAuthor: FHarker + ChatGPT (2025.10)\n\"\"\"\n\nimport System\nimport os, math\nimport scriptcontext  # âœ… must be imported first\nfrom System.Drawing import Bitmap, Color\nfrom Rhino.Geometry import Point2d\n\n# ---------- helpers ----------\ndef _mirror_wrap(t):\n    ti = math.floor(t)\n    frac = t - ti\n    if int(ti) % 2 != 0:\n        frac = 1.0 - frac\n    return frac\n\ndef wrap01(x, mode):\n    if mode == 0:  # Clamp\n        return max(0.0, min(1.0, x))\n    elif mode == 1:  # Repeat\n        return x - math.floor(x)\n    else:  # Mirror\n        return _mirror_wrap(x)\n\ndef bilinear_sample(bmp, x, y):\n    \"\"\"x,y in pixel space (float). Returns Color via bilinear filtering.\"\"\"\n    w, h = bmp.Width, bmp.Height\n    x = max(0.0, min(w - 1.0, x))\n    y = max(0.0, min(h - 1.0, y))\n\n    x0 = int(math.floor(x))\n    y0 = int(math.floor(y))\n    x1 = min(x0 + 1, w - 1)\n    y1 = min(y0 + 1, h - 1)\n\n    fx = x - x0\n    fy = y - y0\n\n    c00 = bmp.GetPixel(x0, y0)\n    c10 = bmp.GetPixel(x1, y0)\n    c01 = bmp.GetPixel(x0, y1)\n    c11 = bmp.GetPixel(x1, y1)\n\n    def lerp(a, b, t): return a + (b - a) * t\n\n    a0 = lerp(c00.A, c10.A, fx); a1 = lerp(c01.A, c11.A, fx); a = int(lerp(a0, a1, fy))\n    r0 = lerp(c00.R, c10.R, fx); r1 = lerp(c01.R, c11.R, fx); r = int(lerp(r0, r1, fy))\n    g0 = lerp(c00.G, c10.G, fx); g1 = lerp(c01.G, c11.G, fx); g = int(lerp(g0, g1, fy))\n    b0 = lerp(c00.B, c10.B, fx); b1 = lerp(c01.B, c11.B, fx); b = int(lerp(b0, b1, fy))\n\n    return Color.FromArgb(a, r, g, b)\n\ndef to_gray01(col):\n    return (0.2126*col.R + 0.7152*col.G + 0.0722*col.B) / 255.0\n\ndef as_uv2(pt):\n    return float(pt.X), float(pt.Y)\n\n# ---------- sticky cache ----------\nkey = \"img_cache_v1\"\ncache = scriptcontext.sticky.get(key, {})\n\ndef get_bitmap(path):\n    if not path or not os.path.isfile(path):\n        return None, \"No file at path.\"\n    try:\n        mtime = os.path.getmtime(path)\n    except:\n        mtime = None\n    entry = cache.get(path)\n    if entry and entry.get(\"mtime\") == mtime:\n        return entry[\"bmp\"], \"Cached\"\n    try:\n        bmp = Bitmap(path)\n        cache[path] = {\"bmp\": bmp, \"mtime\": mtime}\n        scriptcontext.sticky[key] = cache\n        return bmp, \"Loaded\"\n    except Exception as e:\n        return None, \"Load error: %s\" % e\n\n# ---------- main ----------\nmode_map = {\"clamp\": 0, \"repeat\": 1, \"mirror\": 2}\nm = mode_map.get((Mode or \"Clamp\").strip().lower(), 0)\n\nbmp, status = get_bitmap(Path)\nC, G = [], []\n\nif bmp is None:\n    Size = \"0x0\"\n    Report = \"Image not available. \" + status\nelse:\n    w, h = bmp.Width, bmp.Height\n    Size = \"{}x{}\".format(w, h)\n    for p in UV:\n        u, v = as_uv2(p)\n        u = wrap01(u, m)\n        v = wrap01(v, m)\n        if FlipV:\n            v = 1.0 - v\n        x = u * (w - 1)\n        y = v * (h - 1)\n        col = bilinear_sample(bmp, x, y)\n        C.append(col)\n        G.append(to_gray01(col))\n    Report = \"OK ({})\".format(status)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}