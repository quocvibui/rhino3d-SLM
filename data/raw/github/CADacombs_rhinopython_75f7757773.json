{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Grips_linearize_per2Pts.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Grips_linearize_per2Pts.py",
  "instruction": "1. _PointsOn or _SolidPtOn to object to modify its grips, e.g., control points.\r\n2. Run this script and follow prompts.\r\n    Do not include end points with first selection, grips to move.\r\nOptions:\r\n...",
  "code": "\"\"\"\r\n1. _PointsOn or _SolidPtOn to object to modify its grips, e.g., control points.\r\n2. Run this script and follow prompts.\r\n    Do not include end points with first selection, grips to move.\r\nOptions:\r\n    DistributeEvenly=Yes: All control points will be evenly distributed between\r\n        reference points.\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums, https://discourse.mcneel.com/\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n#! python 2\r\n\r\n\"\"\"\r\n190904: Created.\r\n220824: Now multiple grips will be made inline to 2 reference grips.\r\n220922: Added DistributeEvenly option.  Refactored.\r\n220923: Now, references are picked points, not other grips.\r\n240829-30: Added OuterGripsAtRefPts option for when DistributeEvenly and BetweenRefPts are enabled.\r\n\r\nTODO:\r\n    Allow points to be scaled so each of the 2 extents are on a reference point.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bDistributeEvenly'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bBetweenRefPts'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bOuterGripsAtRefPts'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput_Grips_ToMove():\r\n    \r\n    #\r\n    go = ri.Custom.GetObject()\r\n    go.SetCommandPrompt(\"Select grips to move\")\r\n    \r\n    go.GeometryFilter = rd.ObjectType.Grip\r\n    \r\n    # go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False\r\n    go.EnableClearObjectsOnEntry(False)\r\n    go.EnableUnselectObjectsOnExit(False)\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n    \r\n    idxs_Opt = {}\r\n\r\n    bFirstRun = True\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('bDistributeEvenly')\r\n        if Opts.values['bDistributeEvenly']:\r\n            addOption('bBetweenRefPts')\r\n            if Opts.values['bBetweenRefPts']:\r\n                addOption('bOuterGripsAtRefPts')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        sc.doc.Views.Redraw()\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            grips_ToMove = [o.Object() for o in objrefs]\r\n            return grips_ToMove\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n        if bFirstRun:\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True) # Default is True.\r\n            bFirstRun = False\r\n\r\n\r\ndef getInput_Points_Ref():\r\n    \r\n    pts = [None, None]\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(gp, key)\r\n\r\n    for i, s in zip((0,1),('1st', '2nd')):\r\n        gp = ri.Custom.GetPoint()\r\n\r\n        gp.SetCommandPrompt(\"Pick {} reference point\".format(s))\r\n    \r\n\r\n        idxs_Opt = {}\r\n\r\n        while True:\r\n            gp.ClearCommandOptions()\r\n\r\n            idxs_Opt.clear()\r\n\r\n            addOption('bDistributeEvenly')\r\n            if Opts.values['bDistributeEvenly']:\r\n                addOption('bBetweenRefPts')\r\n                if Opts.values['bBetweenRefPts']:\r\n                    addOption('bOuterGripsAtRefPts')\r\n            addOption('bEcho')\r\n            addOption('bDebug')\r\n\r\n            res = gp.Get()\r\n\r\n            if res == ri.GetResult.Cancel:\r\n                gp.Dispose()\r\n                return\r\n\r\n            if res == ri.GetResult.Point:\r\n                pts[i] = gp.Point()\r\n                break\r\n\r\n            for key in idxs_Opt:\r\n                if gp.Option().Index == idxs_Opt[key]:\r\n                    Opts.setValue(key, gp.Option().CurrentListOptionIndex)\r\n                    break\r\n\r\n    return pts\r\n\r\n\r\ndef processGrips(grips_ToMove, pts_Ref, bDistributeEvenly=False, bBetweenRefPts=True, bOuterGripsAtRefPts=False, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    ptA, ptB = pts_Ref\r\n\r\n    line = rg.Line(ptA, ptB)\r\n\r\n    rdOwners = []\r\n    gOwners = []\r\n\r\n    bSomeGripsWereTranslated = False\r\n\r\n    for grip_ToMove in grips_ToMove:\r\n\r\n        pt_Target = line.ClosestPoint(\r\n                grip_ToMove.CurrentLocation,\r\n                limitToFiniteSegment=False)\r\n    \r\n        gOwner = grip_ToMove.OwnerId\r\n        rdOwner = sc.doc.Objects.FindId(gOwner) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(gOwner)\r\n        if rdOwner.Id not in gOwners:\r\n            rdOwners.append(rdOwner)\r\n            gOwners.append(rdOwner.Id)\r\n\r\n        if grip_ToMove.CurrentLocation.DistanceTo(pt_Target) > Rhino.RhinoMath.ZeroTolerance:\r\n            grip_ToMove.CurrentLocation = pt_Target\r\n            bSomeGripsWereTranslated = True\r\n\r\n\r\n    if not bDistributeEvenly:\r\n        if not bSomeGripsWereTranslated:\r\n            print(\"Grips are already at target locations. No objects were modified.\")\r\n            return\r\n\r\n        for rdOwner in rdOwners:\r\n            sc.doc.Objects.GripUpdate(rdOwner, deleteOriginal=True)\r\n\r\n        return\r\n\r\n\r\n\r\n    # Distribute grips evenly.\r\n\r\n\r\n    def sortGripsFromPt(grips_In, pt):\r\n        fDists_From1stRef = []\r\n        for grip_ToMove in grips_In:\r\n            fDists_From1stRef.append(\r\n                pt.DistanceTo(grip_ToMove.CurrentLocation))\r\n\r\n        grips_ToMove_Sorted = []\r\n        for dist, grip in sorted(zip(fDists_From1stRef, grips_In)):\r\n            grips_ToMove_Sorted.append(grip)\r\n\r\n        return grips_ToMove_Sorted\r\n\r\n\r\n    def evenlyRedistributeSortedGrips(grips, ptStart, ptEnd, bOuterGripsAtExtents):\r\n        bSomeGripsWereTranslated = False\r\n        if bOuterGripsAtExtents:\r\n            for i in range(len(grips)):\r\n                perunum = float(i) / float(len(grips) - 1)\r\n                pt_Target = ptStart + (ptEnd - ptStart) * perunum\r\n                grip_ToMove = grips_ToMove_Sorted[i]\r\n                if grip_ToMove.CurrentLocation.DistanceTo(pt_Target) > Rhino.RhinoMath.ZeroTolerance:\r\n                    grip_ToMove.CurrentLocation = pt_Target\r\n                    bSomeGripsWereTranslated = True\r\n        else:\r\n             for i in range(len(grips)):\r\n                perunum = float(i + 1) / float(len(grips) + 1)\r\n                pt_Target = ptStart + (ptEnd - ptStart) * perunum\r\n                grip_ToMove = grips[i]\r\n                if grip_ToMove.CurrentLocation.DistanceTo(pt_Target) > Rhino.RhinoMath.ZeroTolerance:\r\n                    grip_ToMove.CurrentLocation = pt_Target\r\n                    bSomeGripsWereTranslated = True\r\n\r\n        return bSomeGripsWereTranslated\r\n\r\n\r\n    if bBetweenRefPts:\r\n        grips_ToMove_Sorted = sortGripsFromPt(grips_ToMove, ptA)\r\n\r\n        bSomeGripsWereTranslated |= evenlyRedistributeSortedGrips(\r\n            grips_ToMove_Sorted,\r\n            ptA,\r\n            ptB,\r\n            bOuterGripsAtExtents=bOuterGripsAtRefPts\r\n        )\r\n    else:\r\n        # Do not distribute between the 2 reference points.\r\n        # The 2 points extents (not necessarily the reference points) remain\r\n        # and the rest are distributed between them.\r\n        bSuccess, line = rg.Line.TryFitLineToPoints(\r\n            [grip.CurrentLocation for grip in grips_ToMove])\r\n        if not bSuccess:\r\n            print(\"Line could not be generated from transformed grip locations.\")\r\n        else:\r\n            grips_ToMove_Sorted = sortGripsFromPt(grips_ToMove, line.From)\r\n\r\n            bSomeGripsWereTranslated |= evenlyRedistributeSortedGrips(\r\n                grips_ToMove_Sorted,\r\n                line.From,\r\n                line.To,\r\n                bOuterGripsAtExtents=True\r\n            )\r\n            for i in range(len(grips_ToMove_Sorted)):\r\n                perunum = float(i) / float(len(grips_ToMove_Sorted) - 1)\r\n                pt_Target = line.From + (line.To - line.From) * perunum\r\n                grip_ToMove = grips_ToMove_Sorted[i]\r\n                if grip_ToMove.CurrentLocation.DistanceTo(pt_Target) > Rhino.RhinoMath.ZeroTolerance:\r\n                    grip_ToMove.CurrentLocation = pt_Target\r\n                    bSomeGripsWereTranslated = True\r\n\r\n            # print(sc.doc.Objects.AddLine(line))\r\n\r\n    if not bSomeGripsWereTranslated:\r\n        print(\"Grips are already at target locations. No objects were modified.\")\r\n        return\r\n\r\n    for rdOwner in rdOwners:\r\n        sc.doc.Objects.GripUpdate(rdOwner, deleteOriginal=True)\r\n\r\n\r\ndef main():\r\n\r\n    grips_ToMove = getInput_Grips_ToMove()\r\n    if grips_ToMove is None: return\r\n\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    pts_Ref = getInput_Points_Ref()\r\n    if pts_Ref is None: return\r\n\r\n    bDistributeEvenly = Opts.values['bDistributeEvenly']\r\n    bBetweenRefPts = Opts.values['bBetweenRefPts']\r\n    bOuterGripsAtRefPts = Opts.values['bOuterGripsAtRefPts']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    processGrips(\r\n        grips_ToMove,\r\n        pts_Ref,\r\n        bDistributeEvenly=bDistributeEvenly,\r\n        bBetweenRefPts=bBetweenRefPts,\r\n        bOuterGripsAtRefPts=bOuterGripsAtRefPts,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug)\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}