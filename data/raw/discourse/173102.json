{
  "source_url": "https://discourse.mcneel.com/t/script-to-snap-a-mesh-vertex-to-nearest-mesh-vertex-of-other-mesh/173102",
  "topic_id": 173102,
  "title": "Script to Snap a mesh vertex to nearest mesh vertex of other mesh",
  "question": "I have two larger meshes which meet at one or more edges in such a way, that after joining there should be no naked edges. However, the vertex coordinates sometimes differ by an extremely small amount, so that sometimes the mesh is still seen as open (even though the displacement is like 1e-6 m at a tolerance value of 0.01). If I - by hand - drag the vertex away and snap it back on the target mesh, everything is fine. However, the number of vertices is far too large to do this by hand.\n\n\nI have created a simple example model, which shows this problem (see image).\n\n\nimage\n1284×729 83.4 KB\n\n\nI tried to create a python script to make this adjustment automatically, but it seems the python functions for mesh manipulation are not fully fleshed out. For example, rs.MeshVertices(meshID) gives me a list of vertex coordinates, but I could not find a way to modify this list and update the vertex positions based on it. A different route over obj.Geometry.Vertices and using SetVertex also correctly identified the offending positions, but Rhino still shows the edge as open after joining\n\n\nJoin_Mesh_Example.3dm\n (184.1 KB)\n\n.\n\nI’m grateful for any suggestion.",
  "code_blocks": [
    {
      "code": "Rhino.DocObjects.ObjRef objref0;\n    Rhino.Commands.Result result0 = Rhino.Input.RhinoGet.GetOneObject(\"Select mesh to edit\", false, Rhino.DocObjects.ObjectType.Mesh, out objref0);\n    Rhino.DocObjects.ObjRef objref1;\n    Rhino.Commands.Result result1 = Rhino.Input.RhinoGet.GetOneObject(\"Select static mesh\", false, Rhino.DocObjects.ObjectType.Mesh, out objref1);\n    double tolerance = 0.1;\n    Rhino.Commands.Result result2 = Rhino.Input.RhinoGet.GetNumber(\"Tolerance\", false, ref tolerance, 0, 100);\n    Rhino.Geometry.Mesh m0 = objref0.Mesh();\n    Rhino.Geometry.Mesh m1 = objref1.Mesh();\n    m0.Vertices.UseDoublePrecisionVertices = false;\n    m1.Vertices.UseDoublePrecisionVertices = false;\n    Point3d[] pts = m0.Vertices.ToPoint3dArray();\n    Rhino.Geometry.PointCloud pc = new PointCloud(objref1.Mesh().Vertices.ToPoint3dArray());\n    tolerance *= tolerance;\n    for(int i = 0;i < pts.Length;i++){\n      int j = pc.ClosestPoint(pts[i]);\n      if(pc[j].Location.DistanceToSquared(pts[i]) < tolerance){\n        m0.Vertices[i] = m1.Vertices[j];\n      }\n    }\n    this.RhinoDocument.Objects.Replace(objref0, m0);\n    this.RhinoDocument.Objects.Replace(objref1, m1);",
      "language": "csharp",
      "author": "maje90",
      "post_number": 5,
      "is_solution": false
    },
    {
      "code": "import Rhino\nfrom Rhino.Geometry import PointCloud\n\ndef main():\n    # Prompt user to select the first mesh\n    result0, objref0 = Rhino.Input.RhinoGet.GetOneObject(\"Select mesh to edit\", False, Rhino.DocObjects.ObjectType.Mesh)\n    if result0 != Rhino.Commands.Result.Success:\n        print(\"Failed to select the first mesh.\")\n        return\n\n    # Prompt user to select the second mesh\n    result1, objref1 = Rhino.Input.RhinoGet.GetOneObject(\"Select static mesh\", False, Rhino.DocObjects.ObjectType.Mesh)\n    if result1 != Rhino.Commands.Result.Success:\n        print(\"Failed to select the second mesh.\")\n        return\n\n    # Get tolerance input\n    tolerance = 0.1\n    result2, tolerance = Rhino.Input.RhinoGet.GetNumber(\"Tolerance\", False, tolerance, 0, 500)\n    if result2 != Rhino.Commands.Result.Success:\n        print(\"Failed to get tolerance input.\")\n        return\n\n    # Get the meshes\n    mesh0 = objref0.Mesh()\n    mesh1 = objref1.Mesh()\n\n    # Set single-precision vertices\n    mesh0.Vertices.UseDoublePrecisionVertices = False\n    mesh1.Vertices.UseDoublePrecisionVertices = False\n\n    # Convert vertices to point arrays\n    pts = mesh0.Vertices.ToPoint3dArray()\n    mesh1_pts = mesh1.Vertices.ToPoint3dArray()\n\n    # Create a PointCloud from the second mesh's vertices\n    pc = PointCloud()\n    for pt in mesh1_pts:\n        pc.Add(pt)\n\n    # Use squared tolerance for efficiency\n    tolerance_squared = tolerance * tolerance\n\n    # Iterate through the vertices of the first mesh\n    for i in range(len(pts)):\n        # Find the closest point in the point cloud\n        j = pc.ClosestPoint(pts[i])\n        if pc[j].Location.DistanceToSquared(pts[i]) < tolerance_squared:\n            # Replace the vertex in mesh0 with the corresponding vertex from mesh1\n            mesh0.Vertices.SetVertex(i, mesh1.Vertices[j])\n\n    # Replace the original objects in the document\n    doc = Rhino.RhinoDoc.ActiveDoc\n    doc.Objects.Replace(objref0.ObjectId, mesh0)\n    doc.Objects.Replace(objref1.ObjectId, mesh1)\n\n    # Notify user of success\n    print(\"Meshes updated successfully.\")\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()",
      "language": "python",
      "author": "Bogdan_Chipara",
      "post_number": 7,
      "is_solution": false
    },
    {
      "code": "import Rhino\nfrom Rhino.Geometry import PointCloud, Plane\n\ndef main():\n    # Prompt user to select the first mesh\n    result0, objref0 = Rhino.Input.RhinoGet.GetOneObject(\"Select mesh to edit\", False, Rhino.DocObjects.ObjectType.Mesh)\n    if result0 != Rhino.Commands.Result.Success:\n        print(\"Failed to select the first mesh.\")\n        return\n\n    # Prompt user to select the second mesh\n    result1, objref1 = Rhino.Input.RhinoGet.GetOneObject(\"Select static mesh\", False, Rhino.DocObjects.ObjectType.Mesh)\n    if result1 != Rhino.Commands.Result.Success:\n        print(\"Failed to select the second mesh.\")\n        return\n\n    # Get tolerance input\n    tolerance = 0.1\n    result2, tolerance = Rhino.Input.RhinoGet.GetNumber(\"Tolerance\", False, tolerance, 0, 1000)\n    if result2 != Rhino.Commands.Result.Success:\n        print(\"Failed to get tolerance input.\")\n        return\n\n    # Get the meshes\n    mesh0 = objref0.Mesh()\n    mesh1 = objref1.Mesh()\n\n    # Set single-precision vertices\n    mesh0.Vertices.UseDoublePrecisionVertices = False\n    mesh1.Vertices.UseDoublePrecisionVertices = False\n\n    # Convert vertices to point arrays\n    pts = mesh0.Vertices.ToPoint3dArray()\n    mesh1_pts = mesh1.Vertices.ToPoint3dArray()\n\n    # Create a PointCloud from the second mesh's vertices\n    pc = PointCloud()\n    for pt in mesh1_pts:\n        pc.Add(pt)\n\n    # Use squared tolerance for efficiency\n    tolerance_squared = tolerance * tolerance\n\n    # Iterate through the vertices of the first mesh\n    for i in range(len(pts)):\n        # Find the closest point in the point cloud\n        j = pc.ClosestPoint(pts[i])\n        \n        # Check if points are in the same plane (assuming Z-coordinates must match)\n        if abs(pc[j].Location.Z - pts[i].Z) < 1e-6:  # Allow for slight floating-point inaccuracies\n            # Check if the points are within the given tolerance\n            if pc[j].Location.DistanceToSquared(pts[i]) < tolerance_squared:\n                # Replace the vertex in mesh0 with the corresponding vertex from mesh1\n                mesh0.Vertices.SetVertex(i, mesh1.Vertices[j])\n\n    # Replace the original objects in the document\n    doc = Rhino.RhinoDoc.ActiveDoc\n    doc.Objects.Replace(objref0.ObjectId, mesh0)\n    doc.Objects.Replace(objref1.ObjectId, mesh1)\n\n    # Notify user of success\n    print(\"Meshes updated successfully, but only points in the same plane were moved.\")\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()",
      "language": "python",
      "author": "Bogdan_Chipara",
      "post_number": 8,
      "is_solution": false
    },
    {
      "code": "#SubD mesh snapping\nimport Rhino\nfrom Rhino.Geometry import PointCloud, Mesh\n\ndef main():\n    # Prompt user to select the first SubD\n    result0, objref0 = Rhino.Input.RhinoGet.GetOneObject(\"Select SubD to edit\", False, Rhino.DocObjects.ObjectType.SubD)\n    if result0 != Rhino.Commands.Result.Success:\n        print(\"Failed to select the first SubD.\")\n        return\n\n    # Prompt user to select the second SubD\n    result1, objref1 = Rhino.Input.RhinoGet.GetOneObject(\"Select static SubD\", False, Rhino.DocObjects.ObjectType.SubD)\n    if result1 != Rhino.Commands.Result.Success:\n        print(\"Failed to select the second SubD.\")\n        return\n\n    # Get tolerance input\n    tolerance = 1000\n    result2, tolerance = Rhino.Input.RhinoGet.GetNumber(\"Tolerance\", False, tolerance, 0, 1000)\n    if result2 != Rhino.Commands.Result.Success:\n        print(\"Failed to get tolerance input.\")\n        return\n\n    # Get the SubD objects\n    subd0 = objref0.Geometry()\n    subd1 = objref1.Geometry()\n\n    # Convert SubD to control-net meshes\n    mesh0 = Mesh.CreateFromSubDControlNet(subd0)\n    mesh1 = Mesh.CreateFromSubDControlNet(subd1)\n\n    # Use single-precision vertices\n    mesh0.Vertices.UseDoublePrecisionVertices = False\n    mesh1.Vertices.UseDoublePrecisionVertices = False\n\n    # Build a PointCloud from the second mesh\n    pc = PointCloud()\n    for pt in mesh1.Vertices:\n        pc.Add(pt)\n\n    # Tolerance squared\n    tolerance_sq = tolerance * tolerance\n\n    # Snap the vertices of mesh0\n    for i in range(len(mesh0.Vertices)):\n        pt = mesh0.Vertices[i]\n        j = pc.ClosestPoint(pt)\n        if pc[j].Location.DistanceToSquared(pt) < tolerance_sq:\n            mesh0.Vertices.SetVertex(i, pc[j].Location)\n\n    # Create a new SubD from the updated mesh\n    updated_subd0 = Rhino.Geometry.SubD.CreateFromMesh(mesh0)\n\n    # Replace the original SubD with this new one\n    Rhino.RhinoDoc.ActiveDoc.Objects.Replace(objref0.ObjectId, updated_subd0)\n\n    print(\"SubD updated successfully (but creases not preserved).\")\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()",
      "language": "python",
      "author": "Bogdan_Chipara",
      "post_number": 10,
      "is_solution": false
    },
    {
      "code": "\"\"\" Snaps vertices of 'mesh_in' to the closest vertices of 'mesh_ref' if within 'tolerance'.\n\nIN:\n    mesh_in   (Mesh)    -- Mesh to modify\n    mesh_ref  (Mesh)    -- Reference mesh whose vertices are the snap targets\n    tolerance (float)   -- Distance threshold for snapping\n\nOUT:\n    mesh_out  (Mesh)    -- The modified mesh with snapped vertices\n\"\"\"\n\nimport Rhino\nfrom Rhino.Geometry import PointCloud\n\ndef snap_mesh_vertices(mesh_in, mesh_ref, tolerance):\n    # Validate inputs\n    if not mesh_in or not mesh_ref:\n        return None\n\n    # Build a PointCloud from mesh_ref’s vertices for fast nearest-point lookups\n    pc = PointCloud()\n    for i in range(mesh_ref.Vertices.Count):\n        pt = mesh_ref.Vertices[i]\n        pc.Add(pt)\n\n    # Create a *copy* of mesh_in so we can modify it safely\n    new_mesh = mesh_in.DuplicateMesh()\n    if not new_mesh:\n        return None\n\n    # We'll compare squared distances to avoid repeated sqrt\n    tol_sq = tolerance * tolerance\n\n    # Snap each vertex in new_mesh if within tolerance\n    for i in range(new_mesh.Vertices.Count):\n        pt = new_mesh.Vertices[i]\n        idx_closest = pc.ClosestPoint(pt)  # index in the point cloud\n        dist_sq = pt.DistanceToSquared(pc[idx_closest].Location)\n        if dist_sq < tol_sq:\n            # Snap this vertex to the reference vertex\n            new_mesh.Vertices.SetVertex(i, pc[idx_closest].Location)\n\n    # (Optional) Rebuild normals to keep them consistent after vertex changes\n    new_mesh.RebuildNormals()\n\n    return new_mesh\n\n\ndef main(mesh_in, mesh_ref, tolerance):\n    return snap_mesh_vertices(mesh_in, mesh_ref, tolerance)\n\nmesh_out = main(mesh_in, mesh_ref, tolerance)",
      "language": "python",
      "author": "Bogdan_Chipara",
      "post_number": 11,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "mesh",
    "python",
    "rhinocommon",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 1,
  "posts_count": 11,
  "views": 466
}