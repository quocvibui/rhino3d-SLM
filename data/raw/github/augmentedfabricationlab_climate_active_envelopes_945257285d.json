{
  "source_url": "https://github.com/augmentedfabricationlab/climate_active_envelopes/blob/d9ac2ce9da23c5bc3214dfc87307f07db3dc8b2a/src/climate_active_envelopes/assembly/assembly.py",
  "repo": "augmentedfabricationlab/climate_active_envelopes",
  "repo_stars": 2,
  "repo_description": null,
  "license": "MIT",
  "filepath": "src/climate_active_envelopes/assembly/assembly.py",
  "instruction": "Assembly",
  "code": "from __future__ import print_function\nfrom __future__ import absolute_import\nfrom __future__ import division\n\nfrom compas.datastructures import Datastructure\nfrom compas.datastructures import Graph\nfrom compas.datastructures import AssemblyError\nfrom compas.geometry import Frame, Translation, Rotation, Transformation, Vector, Point, normalize_vector\nfrom compas_rhino.conversions import plane_to_compas_frame, point_to_compas, mesh_to_rhino, point_to_rhino, vector_to_rhino\n\n\nfrom scipy.spatial import cKDTree\nfrom compas.geometry import Polygon\nfrom shapely.geometry import Polygon as ShapelyPolygon\n\nimport math as m\nimport numpy as np\n\n\nfrom compas.geometry import Frame\nfrom compas.geometry import local_to_world_coordinates_numpy\n\n\nfrom collections import deque\n\nfrom assembly_information_model import Assembly\nfrom .part import CAEPart as Part\nfrom scipy.spatial import cKDTree\n#from .reference_model import CAECellNetwork as CellNetwork\n\n\nimport math\nimport Rhino.Geometry as rg\n\n\n\nclass CAEAssembly(Assembly):\n    \"\"\"A data structure for managing the connections between different parts of an assembly.\n\n    Parameters\n    ----------\n    name : str, optional\n        The name of the assembly.\n    **kwargs : dict, optional\n        Additional keyword arguments, which are stored in the attributes dict.\n\n    Attributes\n    ----------\n    graph : :class:`compas.datastructures.Graph`\n        The graph that is used under the hood to store the parts and their connections.\n\n    See Also\n    --------\n    :class:`compas.datastructures.Graph`\n    :class:`compas.datastructures.Mesh`\n    :class:`compas.datastructures.VolMesh`\n\n    \"\"\"\n\n    def __init__(self, name=None, brick_full=None, brick_insulated=None, brick_half=None, brick_air_dried=None, **kwargs):\n        super(CAEAssembly, self).__init__()\n        self.brick_params = None\n        if brick_full and brick_insulated and brick_half and brick_air_dried:\n            self.set_brick_params(brick_full, brick_insulated, brick_half, brick_air_dried)\n\n    def export_to_json(self, path, is_built=False):\n        # TODO!\n        self.graph.update_default_node_attributes({\"is_built\":False})\n        for key in self.parts():\n            self.graph.node_attribute(key, \"is_built\", is_built)\n        self.to_json(path)\n\n    def set_brick_params(self, brick_full, brick_insulated, brick_half, brick_air_dried):\n\n        self.brick_params = {\n            \"brick_full\": brick_full,\n            \"brick_insulated\": brick_insulated,\n            \"brick_half\": brick_half,\n            \"brick_air_dried\": brick_air_dried,\n           \n        }\n\n        return self.brick_params\n\n    def get_brick_dimensions(self):\n\n        \"\"\"\n        Get the dimensions of the bricks\n        \n        Parameters\n        ----------\n        brick_full : :class:`CAEPart`\n            The full brick to use for the wall\n        brick_insulated : :class:`CAEPart`\n            The insulated brick to use for the wall\n        \"\"\"\n\n        if self.brick_params is None:\n            raise ValueError(\"brick_params is not set. Please set brick_params using set_brick_params method before calling get_brick_dimensions.\")\n\n        brick_full = self.brick_params[\"brick_full\"]\n        brick_half = self.brick_params[\"brick_half\"]\n\n        brick_length = brick_full.shape.ysize\n        brick_height = brick_full.shape.zsize\n        brick_width = brick_full.shape.xsize\n        brick_length_h = brick_half.shape.ysize\n\n        return brick_length, brick_height, brick_width, brick_length_h\n    \n    def compute_brick_layout(self, cell_network, mesh, course_height, brick_spacing, input_type):\n\n        # get the dimensions of the bricks\n        brick_length, _, brick_width, _, = self.get_brick_dimensions()\n\n        # get the assembly data from the cell network\n        #assembly_data = cell_network.generate_assembly_data_from_cellnetwork(cell_network, course_height)\n        assembly_data = cell_network.generate_assembly_data(mesh, course_height, input_type)\n\n\n        direction_vector = assembly_data['direction_vector']\n        edge_length = assembly_data['edge_length']\n        start_edge_type = assembly_data['start_edge_type']\n        end_edge_type = assembly_data['end_edge_type']\n        num_courses = assembly_data['num_courses']\n        curve_start_point = assembly_data['curve_start_point']\n        curve_end_point = assembly_data['curve_end_point']\n\n\n        course_brick_data = []\n        for course in range(math.ceil(num_courses + 1)):    \n\n            # Check if the course is odd         \n            course_is_odd = course % 2 != 0\n\n            # Calculate the number of bricks per course\n            bricks_per_course = math.floor(edge_length / ((brick_width + brick_length) / 2 + brick_spacing))\n\n            # Adjust the z-coordinate of the curves_start_point for each course\n            adjusted_start_point = rg.Point3d(curve_start_point[0], curve_start_point[1], curve_start_point[2] + course * course_height)\n            adjusted_end_point = rg.Point3d(curve_end_point[0], curve_end_point[1], curve_end_point[2] + course * course_height)\n\n            # Calculate the midpoint of the contour curve\n            curve_midpoint = point_to_rhino((adjusted_start_point + adjusted_end_point) / 2)\n            \n            # Number of bricks per course are always odd\n            if bricks_per_course % 2 == 0:\n                bricks_per_course -= 1\n\n            #If course is odd and number of bricks per course is even, subtract 1\n            if course_is_odd and bricks_per_course % 2 != 0:\n                bricks_per_course -= 1\n\n            course_brick_data.append((bricks_per_course, edge_length, course_is_odd, direction_vector, start_edge_type,\n                                    end_edge_type, curve_midpoint, adjusted_start_point, adjusted_end_point))\n\n        return course_brick_data\n\n    def generate_wall(self, \n                      cell_network,\n                      bond_type, \n                      ornament_type,\n                      wall_system,  \n                      brick_spacing, \n                      course_height, \n                      input_type,\n                      mesh\n                      ):\n\n        course_brick_data = self.compute_brick_layout(cell_network, mesh, course_height, brick_spacing, input_type)\n        \n        for course_index, data in enumerate(course_brick_data):\n            bricks_per_course, edge_length, course_is_odd, direction_vector, start_edge_type, end_edge_type, curve_midpoint, adjusted_start_point, adjusted_end_point = data\n\n            if bond_type == \"flemish_bond\":\n                # Calculate the total length of the course\n                total_length = self.calculate_flemish_course_length(\n                    bricks_per_course=bricks_per_course,\n                    brick_spacing=brick_spacing,\n                    course_is_odd=course_is_odd)                              \n\n                # Adjust the initial brick position based on corner detection\n                # if start_edge_type == \"corner\":\n                #     initial_brick_position = adjusted_start_point\n                # if end_edge_type == \"corner\":\n                #     initial_brick_position = adjusted_end_point - (direction_vector * (total_length))\n                # else:\n                initial_brick_position = curve_midpoint - (direction_vector * (total_length / 2))\n\n\n                self.generate_flemish_bond(\n                    initial_brick_position=initial_brick_position,\n                    bricks_per_course=bricks_per_course,\n                    course_is_odd=course_is_odd,\n                    direction_vector=direction_vector,\n                    course_index=course_index,\n                    wall_system=wall_system,\n                    brick_spacing=brick_spacing,\n                    start_edge_type=start_edge_type,\n                    end_edge_type=end_edge_type,\n                    ornament_type=ornament_type,\n                    )\n                \n            if bond_type ==\"vertical_bond\":\n\n                total_length = self.calculate_vertical_course_length(\n                    bricks_per_course=bricks_per_course,\n                    brick_spacing=brick_spacing,\n                    course_is_odd=course_is_odd)                              \n\n                initial_brick_position = curve_midpoint - (direction_vector * (total_length / 2))\n                self.generate_vertical_bond(\n                        initial_brick_position=initial_brick_position,\n                        edge_length=edge_length,          \n                        course_is_odd=course_is_odd,\n                        direction_vector=direction_vector,\n                        course_index=course_index,\n                        wall_system=wall_system,\n                        brick_spacing=brick_spacing,\n                        start_edge_type=start_edge_type,\n                        end_edge_type=end_edge_type,\n                        ornament_type = ornament_type,\n                        )\n\n    def create_brick_and_add_to_assembly(self,\n                        brick_type, \n                        transform_type, \n                        frame=None,\n                        ): \n        \"\"\"Create a brick with a specified type and add it to the assembly\n\n        Parameters\n        ----------\n        brick_type : str\n            The type of brick to create (\"full\" or \"insulated\").\n        brick_full : :class:`CAEPart`\n            The full brick to use for the wall.\n        brick_insulated : :class:`CAEPart`\n            The insulated brick to use for the wall.\n        transform_type : str\n            Type of transformation to apply (\"translate\" or \"rotate\").\n        frame : :class:`compas.geometry.Frame`, optional\n            The frame of the brick.\n        \n        Returns\n        -------\n        Part\n            The brick part that is added to the assembly. \n        \"\"\"\n\n        brick_full = self.brick_params[\"brick_full\"]\n        brick_insulated = self.brick_params[\"brick_insulated\"]\n        brick_half = self.brick_params[\"brick_half\"]\n        brick_air_dried = self.brick_params[\"brick_air_dried\"]\n\n        if frame is None:\n            frame = frame\n\n        if brick_type == \"full\":\n            brick = brick_full\n\n        if brick_type == \"insulated\":\n            brick = brick_insulated\n\n        if brick_type == \"half\":\n            brick = brick_half\n\n        if brick_type == \"air_dried\":\n            brick = brick_air_dried\n            \n        my_brick = brick.transformed(Transformation.from_frame(frame))\n\n        # Adjust the gripping frame by translating it along the z-axis to account for the brick height\n        gripping_frame = frame.transformed(Translation.from_vector(frame.zaxis*((brick_full.shape.zsize - 0.020)/2)))\n\n        # Rotate the gripping frame by 180 degrees around the x-axis\n        R = Rotation.from_axis_and_angle(gripping_frame.xaxis, math.radians(180), gripping_frame.point)\n        gripping_frame.transform(R)\n        # Set the gripping frame of the brick \n        my_brick.gripping_frame = gripping_frame\n        my_brick.frame = frame\n        my_brick.original_frame = my_brick.frame.copy()\n\n        self.add_part(my_brick, attr_dict={\"brick_type\": brick_type, \"transform_type\": transform_type})\n\n    def generate_vertical_bond(self,\n                                initial_brick_position,\n                                edge_length,\n                                course_is_odd,\n                                direction_vector,\n                                course_index,\n                                wall_system,\n                                brick_spacing,\n                                start_edge_type,\n                                end_edge_type,\n                                ornament_type,\n                                ):\n        \"\"\"\n        Generate a vertical bond layout for a course of bricks.\n\n        Parameters\n        ----------\n        initial_brick_position : :class:`compas.geometry.Point`\n            The starting position for the course.\n        line_length : float\n            The total length of the course.\n        course_is_odd : bool\n            Whether the course is odd or even.\n        direction_vector : :class:`compas.geometry.Vector`\n            The direction in which the course extends.\n        wall_system : str\n            The type of wall system (\"single_layer\" or \"double_layer\").\n        brick_spacing : float\n            The spacing between bricks.\n        start_edge_type : str\n            The type of the start edge (\"corner\" or other).\n        end_edge_type : str\n            The type of the end edge (\"corner\" or other).\n        j : int\n            The index of the current course.\n        \"\"\"\n        brick_length, _, brick_width, _ = self.get_brick_dimensions()\n        brick_full = self.brick_params[\"brick_full\"]\n        center_brick_frame = brick_full.frame\n\n        # Calculate the number of bricks per course\n        bricks_per_course = math.ceil(max(0.0,edge_length) / (brick_width + brick_spacing))\n\n        # Adjust the starting position for odd courses\n        adjusted_initial_position = initial_brick_position + direction_vector * (brick_width / 2)\n\n        for brick in range(bricks_per_course):\n            # Calculate the position of the current brick\n            T = direction_vector * (brick * (brick_width + brick_spacing))\n            brick_position = adjusted_initial_position + T\n\n            if ornament_type == \"cross\":\n                shifted = brick + course_index\n                if not course_is_odd:            \n                    if course_index %4 == 0 and shifted %2 != 0:#header\n                        transform_type = \"translate\"\n                    elif course_index %4 != 0 and shifted %2 == 0:#header\n                        transform_type = \"translate\"\n                    else:\n                        transform_type = \"fixed\"\n                else:\n                    transform_type = \"fixed\"\n\n            if ornament_type == \"diamond_large\":\n                if course_index % 4 == 1 and brick % 4 == 0:#shiner\n                    transform_type = \"translate\"\n                elif course_index % 4 == 3 and brick % 4 == 2:#shiner\n                    transform_type = \"translate\"\n\n                elif course_index % 2 == 0 and brick % 2 == 0:#header\n                    transform_type = \"translate\"\n                else: \n                    transform_type = \"fixed\"\n\n            if ornament_type == \"diamond_small\":\n                if course_index % 4 == 1 and brick % 2 == 0: #shiner\n                    transform_type = \"translate\"\n                elif course_index % 4 == 3 and brick % 2 == 1: #shiner\n                    transform_type = \"translate\"\n                elif course_index % 2 == 0: #header\n                    transform_type = \"translate\"\n                else: \n                    transform_type = \"fixed\"\n\n            # Create the frame for the brick\n            if direction_vector[1] in [-1, 1]:\n                brick_frame = Frame(brick_position, direction_vector, center_brick_frame.xaxis)\n            else:\n                brick_frame = Frame(brick_position, direction_vector, center_brick_frame.yaxis)\n\n            if not course_is_odd:          \n                # Rotate 90 degrees\n                R = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(90), brick_frame.point)\n                T1 = Translation.from_vector(brick_frame.yaxis * ((brick_width - brick_length) / 2))\n                brick_frame = brick_frame.transformed(T1*R)\n                self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = transform_type, frame=brick_frame)\n\n                # Duplicate that row in y-axis\n                T2 = Translation.from_vector(brick_frame.yaxis * (brick_length + brick_spacing))\n                brick_frame = brick_frame.transformed(T2)\n                if brick != 0: #skip the first brick in the course\n                    self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"fixed\", frame=brick_frame)\n\n                if wall_system == \"double_layer\":\n                    if brick != 0: #skip the first brick in the course\n                        R = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(-90), brick_frame.point)\n                        T3 = Translation.from_vector(brick_frame.xaxis * (brick_length / 2 + brick_spacing / 2 + brick_length + brick_spacing))\n                        brick_frame = brick_frame.transformed(T3*R)\n                        self.create_brick_and_add_to_assembly(brick_type=\"insulated\", transform_type = \"fixed\", frame=brick_frame)\n\n                        T4 = Translation.from_vector(brick_frame.yaxis * (brick_length + brick_spacing))\n                        brick_frame = brick_frame.transformed(T4)\n                        self.create_brick_and_add_to_assembly(brick_type=\"insulated\", transform_type = \"fixed\", frame=brick_frame)\n\n            if course_is_odd:\n                self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = transform_type, frame=brick_frame)\n                \n                if wall_system == \"double_layer\":  \n                    R = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(90), brick_frame.point)\n                    T5 = Translation.from_vector(brick_frame.xaxis * (brick_length + brick_spacing + brick_length/2 + brick_spacing/2 ))\n                    brick_frame = brick_frame.transformed(R*T5)\n                    self.create_brick_and_add_to_assembly(brick_type=\"insulated\", transform_type = \"fixed\", frame=brick_frame)\n\n                    T6 = Translation.from_vector(brick_frame.yaxis * (brick_length + brick_spacing))\n                    brick_frame = brick_frame.transformed(T6)\n                    if brick != 0:\n                        self.create_brick_and_add_to_assembly(brick_type=\"insulated\", transform_type = \"fixed\", frame=brick_frame)\n\n                    # Duplicate the row in y-axis\n                    R = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(-90), brick_frame.point)\n                    T7 = Translation.from_vector(brick_frame.yaxis * ( brick_length / 2 + brick_spacing / 2 + brick_length + brick_spacing))\n                    T8 = Translation.from_vector(brick_frame.xaxis * (brick_width/2 + brick_spacing/2 ))\n                    brick_frame = brick_frame.transformed(R*T7*T8)\n                    self.create_brick_and_add_to_assembly(brick_type=\"insulated\", transform_type = \"fixed\", frame=brick_frame)\n\n                else:\n                    # Duplicate the row in y-axis\n                    T5 = Translation.from_vector(brick_frame.yaxis * (brick_length + brick_spacing))\n                    brick_frame = brick_frame.transformed(T5)\n                    self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"fixed\", frame=brick_frame)\n\n    def generate_corner_vertical_bond(self, \n                                    initial_brick_position,\n                                    course_is_odd,\n                                    direction_vector,\n                                    brick_spacing,\n                                    start_edge_type,\n                                    end_edge_type):\n        \"\"\"\n        Generates a corner course for a vertical bond.\n        \n        For odd courses (bricks laid long side out):\n        - The spacing step is: step_odd = brick_width + brick_spacing.\n        - When the corner condition applies, two bricks are generated as corner bricks.\n        \n        For even courses (bricks laid with short side out, rotated 90°):\n        - The spacing step is: step_even = brick_length + brick_spacing.\n        - In a corner region the sequence is: [full, half, full, full] bricks.\n        \n        Note: In these formulas, brick_width is actually the brick’s long side,\n            and brick_length is the brick’s short side.\n        \"\"\"\n        # Retrieve brick dimensions.\n        brick_length, _, brick_width, _ = self.get_brick_dimensions()  # brick_length: short side; brick_width: long side.\n        brick_full = self.brick_params[\"brick_full\"]\n        center_brick_frame = brick_full.frame\n\n        if course_is_odd:\n            bricks_per_course = 2\n            for brick in range(bricks_per_course):\n                T = direction_vector * (brick * (brick_width + brick_spacing))\n                brick_position = initial_brick_position + T\n\n                # Create brick frame\n                if direction_vector[1] in [-1, 1]:\n                    brick_frame = Frame(brick_position, direction_vector, center_brick_frame.xaxis)\n                else:\n                    brick_frame = Frame(brick_position, direction_vector, center_brick_frame.yaxis)\n                \n                T1 = Translation.from_vector(-1* brick_frame.yaxis * (( (brick_width - brick_length) / 2)))\n                brick_frame= brick_frame.transformed(T1)\n                self.create_brick_and_add_to_assembly(\"full\", \"fixed\", brick_frame)\n\n                if brick == 1:\n                    T2 = Translation.from_vector(brick_frame.yaxis * (( (brick_length + (brick_width - (2*brick_length))))))\n                    brick_frame= brick_frame.transformed(T2)\n                    self.create_brick_and_add_to_assembly(\"full\", \"fixed\", brick_frame)\n\n            bricks_per_course = 3\n            for brick in range(bricks_per_course):\n                T = direction_vector * (brick * (brick_width + brick_spacing))\n                brick_position = initial_brick_position + T\n\n                # Create brick frame\n                if direction_vector[1] in [-1, 1]:\n                    brick_frame = Frame(brick_position, direction_vector, center_brick_frame.xaxis)\n                else:\n                    brick_frame = Frame(brick_position, direction_vector, center_brick_frame.yaxis)\n                T1 = Translation.from_vector(-1* brick_frame.yaxis * (( (brick_width - brick_length) / 2)))\n                brick_frame = brick_frame.transformed(T1)\n\n                if brick == 0:\n                    T2 = Translation.from_vector((brick_frame.yaxis * ((((brick_length/3)*2)+(3*(brick_width - (2*brick_length)))) + 3*((brick_width - (2*brick_length)))/2)))\n                    brick_frame = brick_frame.transformed(T2)\n                    self.create_brick_and_add_to_assembly(\"half\", \"fixed\", brick_frame) # adding the half brick for the corner\n                \n                elif brick == 1:\n                    R = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(90), brick_frame.point)\n                    rotated_frame = brick_frame.transformed(R)\n                    T2 = Translation.from_vector(rotated_frame.xaxis * (((((brick_length))))))\n                    brick_frame = rotated_frame.transformed(T2)\n                    T3 = Translation.from_vector(brick_frame.yaxis*((brick_length/2)+ ((brick_width - (2*brick_length))/2)))\n                    brick_frame = brick_frame.transformed(T3)\n                    self.create_brick_and_add_to_assembly(\"full\", \"fixed\", brick_frame) # adding the half brick for the corner\n\n                    T3 = Translation.from_vector(brick_frame.yaxis * (-1)* (((3*brick_length)/4)+brick_spacing/2))\n                    brick_frame = brick_frame.transformed(T3)\n                    self.create_brick_and_add_to_assembly(\"half\", \"fixed\", brick_frame) # adding the half brick for the corner\n\n            # Double-layer (insulated)\n        else:\n            # Bricks laid short side out (rotated 90 degrees)\n            bricks_per_course = 4\n            # Shift the starting point to align to the middle of the long facing brick\n            adjusted_initial_position = initial_brick_position \n\n            for brick in range(bricks_per_course):\n                if brick == 0:\n                        T = direction_vector * (brick * (brick_length + (brick_spacing/2)+ ((brick_width - (2*brick_length))/2)))\n                        brick_position = adjusted_initial_position + T\n\n                        # Create base brick frame\n                        if direction_vector[1] in [-1, 1]:\n                            brick_frame = Frame(brick_position, direction_vector, center_brick_frame.xaxis)\n                        else:\n                            brick_frame = Frame(brick_position, direction_vector, center_brick_frame.yaxis)\n\n                        # Rotate 90 degrees\n                        R = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(90), brick_frame.point)\n                        rotated_frame = brick_frame.transformed(R)\n\n                        # Translate to align correctly\n                        T1 = Translation.from_vector(rotated_frame.yaxis * ((brick_width - brick_length) / 2))\n                        brick_frame_final = rotated_frame.transformed(T1)\n                        self.create_brick_and_add_to_assembly(\"full\", \"fixed\", brick_frame_final)\n\n\n                        T2 = Translation.from_vector(brick_frame_final.xaxis * ((brick_width + brick_spacing)))\n                        brick_frame_final = brick_frame_final.transformed(T2)\n                        self.create_brick_and_add_to_assembly(\"full\", \"fixed\", brick_frame_final)\n\n                        T3 = Translation.from_vector(brick_frame_final.yaxis * (-1)*((brick_length + brick_spacing)))\n                        brick_frame_final = brick_frame_final.transformed(T3)\n                        self.create_brick_and_add_to_assembly(\"full\", \"fixed\", brick_frame_final)\n                        \n                        T3 = Translation.from_vector(brick_frame_final.xaxis * ((brick_width - (brick_length/2) - ((brick_width - (2*(brick_length)))/2) + brick_spacing)))\n                        T4 = Translation.from_vector(-1*(brick_frame_final.yaxis * ((2*(brick_length+ brick_spacing)))))\n                        brick_frame_final = brick_frame.transformed(T3*T4)\n                        self.create_brick_and_add_to_assembly(\"full\", \"fixed\", brick_frame_final)\n\n                        T5 = Translation.from_vector((brick_frame_final.yaxis * ((brick_length+ brick_spacing) - (brick_length/4))))\n                        brick_frame_final = brick_frame_final.transformed(T5)\n                        self.create_brick_and_add_to_assembly(\"half\", \"fixed\", brick_frame_final)\n\n                elif brick == 1:\n                    T = direction_vector * (brick * (brick_length/2 + (brick_spacing/2)+ ((brick_width - (brick_length))/2)))\n                    brick_position = adjusted_initial_position + T\n\n                    # Create base brick frame\n                    if direction_vector[1] in [-1, 1]:\n                        brick_frame = Frame(brick_position, direction_vector, center_brick_frame.xaxis)\n                    else:\n                        brick_frame = Frame(brick_position, direction_vector, center_brick_frame.yaxis)\n\n                    # Rotate 90 degrees\n                    R = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(90), brick_frame.point)\n                    rotated_frame = brick_frame.transformed(R)\n\n                    # Translate to align correctly\n                    T1 = Translation.from_vector(rotated_frame.yaxis * ((brick_width - brick_length/2) / 2))\n                    brick_frame_final = rotated_frame.transformed(T1)\n                    self.create_brick_and_add_to_assembly(\"half\", \"fixed\", brick_frame_final)\n\n                elif brick in range (2,4):\n                    T = direction_vector * (brick * (brick_length/2 + (brick_spacing/2)+ ((brick_width - (brick_length))/2)))\n                    brick_position = adjusted_initial_position + T\n\n                    # Create base brick frame\n                    if direction_vector[1] in [-1, 1]:\n                        brick_frame = Frame(brick_position, direction_vector, center_brick_frame.xaxis)\n                    else:\n                        brick_frame = Frame(brick_position, direction_vector, center_brick_frame.yaxis)\n\n                    # Rotate 90 degrees\n                    R = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(90), brick_frame.point)\n                    rotated_frame = brick_frame.transformed(R)\n\n                    # Translate to align correctly\n                    T1 = Translation.from_vector(rotated_frame.yaxis * ((brick_width - brick_length)))\n                    brick_frame_final = rotated_frame.transformed(T1)\n                    self.create_brick_and_add_to_assembly(\"full\", \"fixed\", brick_frame_final)\n\n    def calculate_vertical_course_length(self,\n                                        bricks_per_course,\n                                        brick_spacing,\n                                        course_is_odd):\n        \"\"\"\n        Calculate the total length of a vertical bond course \n\n        Parameters\n        ----------\n        brick_full : :class:`CAEPart`\n            The full brick to use for the wall.\n        bricks_per_course : int\n            The number of bricks in the course.\n        brick_spacing : float\n            The spacing between bricks.\n        course_is_odd : bool\n            True if the course is an odd-numbered course, False otherwise.\n\n        Returns\n        -------\n        float\n            The total length of the brick bond course.\n        \"\"\"\n\n        brick_length, _, brick_width, _ = self.get_brick_dimensions()\n\n        # Calculate the total length based on the pattern\n        if course_is_odd:\n            # Odd courses start and end with a header, alternate in between\n            total_length = (bricks_per_course // 2) * (brick_width + brick_length + 2 * brick_spacing)\n        else:\n            # Even courses start and end with a stretcher, alternate in between\n            total_length = (bricks_per_course // 2) * (brick_length + brick_width + 2 * brick_spacing)\n\n        return total_length\n\n\n    def generate_flemish_bond(self,\n                                initial_brick_position,\n                                bricks_per_course,\n                                course_is_odd,\n                                direction_vector,\n                                course_index,\n                                wall_system,\n                                brick_spacing, \n                                start_edge_type,\n                                end_edge_type,     \n                                ornament_type,                                                     \n                                ):\n        \n        \n        brick_length, _, brick_width, _ = self.get_brick_dimensions()\n        brick_full = self.brick_params[\"brick_full\"]\n        center_brick_frame = brick_full.frame\n\n        shift_vector = direction_vector * ((brick_length + brick_width)/2 + brick_spacing)\n\n        for brick in range(bricks_per_course):\n            T = direction_vector * (brick * ((brick_length + brick_width)/2 + brick_spacing))\n            # Adjust the starting position for odd courses\n            if course_is_odd:\n                T += shift_vector\n\n            brick_position = initial_brick_position + T    \n\n\n            # if ornament_type == \"cross\":\n      \n            #     if course_index %4 == 0 and brick %2 != 0:#header\n            #         transform_type = \"translate\"\n\n\n            if direction_vector[1] in [-1, 1]:\n                brick_frame = Frame(brick_position, direction_vector, center_brick_frame.xaxis)\n            else:\n                brick_frame = Frame(brick_position, direction_vector, center_brick_frame.yaxis)\n\n\n\n\n            if not course_is_odd:\n                # if start_edge_type == \"corner\":\n                #     self.generate_corner_flemish_bond(\n                #         initial_brick_position=initial_brick_position,\n                #         bricks_per_course=bricks_per_course,\n                #         course_is_odd=course_is_odd,\n                #         direction_vector=direction_vector,\n                #         brick_spacing=brick_spacing,\n                #         start_edge_type=start_edge_type,\n                #         end_edge_type=end_edge_type                        \n                #     )\n        \n                # elif end_edge_type == \"corner\":\n                #     self.generate_corner_flemish_bond(\n                #         initial_brick_position=initial_brick_position,\n                #         bricks_per_course=bricks_per_course,\n                #         course_is_odd=course_is_odd,\n                #         direction_vector=direction_vector,\n                #         brick_spacing=brick_spacing,\n                #         start_edge_type=start_edge_type,\n                #         end_edge_type=end_edge_type,\n                #     )\n                        \n                # else:\n\n\n                if brick % 2 != 0: #brick is odd - header\n                    R1 = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(90), point=brick_frame.point)  \n                    T1 = Translation.from_vector(brick_frame.xaxis * (brick_length + brick_spacing)/2)\n                    current_frame = brick_frame.transformed(R1*T1)\n                    self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"translate\", frame=current_frame) \n\n                    # second row - insulated bricks - header bricks\n                    T2 = Translation.from_vector(current_frame.xaxis * (brick_width + brick_spacing))\n                    copy_current_frame = current_frame.transformed(T2)\n                    if wall_system == \"double_layer\":\n                        self.create_brick_and_add_to_assembly(brick_type = \"insulated\", transform_type = \"fixed\", frame = copy_current_frame) \n\n                else: #strecther bricks - first row\n                    self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"rotate\", frame=brick_frame) \n                    \n                    # second row - full bricks - stretcher bricks\n                    if wall_system == \"single_layer\":                      \n                        T3 = Translation.from_vector(brick_frame.yaxis * (brick_length + brick_spacing))\n                        current_frame = brick_frame.transformed(T3)\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"fixed\", frame=current_frame)\n                    \n                    if wall_system == \"double_layer\":\n                        T4 = Translation.from_vector(brick_frame.yaxis * (brick_length + brick_width + 2 * brick_spacing))\n                        current_frame = brick_frame.transformed(T4)\n                        self.create_brick_and_add_to_assembly(brick_type = \"insulated\", transform_type = \"fixed\", frame = current_frame) \n\n                        # middle bricks in the row\n                        R2 = Rotation.from_axis_and_angle(current_frame.zaxis, math.radians(90), point=current_frame.point)\n                        T5 = Translation.from_vector(current_frame.yaxis * ((brick_width - brick_length)/2 + brick_spacing/4))\n                        T6 = Translation.from_vector(current_frame.xaxis * - ((brick_width + brick_length)/2 + brick_spacing))\n                        current_frame = current_frame.transformed(R2 * T5 * T6)\n                        self.create_brick_and_add_to_assembly(brick_type = \"insulated\", transform_type = \"fixed\", frame = current_frame )\n\n                        T7 = Translation.from_vector(current_frame.yaxis * - (brick_length + brick_spacing))\n                        current_frame = current_frame.transformed(T7)\n                        self.create_brick_and_add_to_assembly( brick_type = \"insulated\", transform_type = \"fixed\", frame = current_frame )\n\n            else: #if course_is_odd:                    \n                if brick == 0:  # first brick in course\n                    R3 = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(90), point=brick_frame.point)  \n                    current_frame = brick_frame.transformed(R3)\n                    T8 = Translation.from_vector(current_frame.xaxis * ((brick_length + brick_spacing)/2))\n                    T9 = Translation.from_vector(current_frame.yaxis * ((brick_length + brick_width)/2 + brick_spacing))\n                    current_frame = current_frame.transformed(T9 * T8)\n                    self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"translate\", frame=current_frame)\n\n                    if wall_system == \"double_layer\":\n                        # first insulated brick\n                        T10 = Translation.from_vector(current_frame.xaxis *((brick_width + brick_spacing)))\n                        current_frame = current_frame.transformed(T10)\n                        self.create_brick_and_add_to_assembly(brick_type = \"insulated\", transform_type = \"fixed\", frame = current_frame) \n\n                if brick >= 0 and brick < bricks_per_course - 1: \n                    if brick % 2 != 0: #brick is even               \n                        # first row - header bricks\n                        R4 = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(90), point=brick_frame.point)  \n                        T11 = Translation.from_vector(brick_frame.xaxis * (brick_length + brick_spacing)/2)\n                        current_frame = brick_frame.transformed(R4 * T11)\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"translate\", frame=current_frame)\n\n                        # second row - insulated bricks - header bricks\n                        T13 = Translation.from_vector(current_frame.xaxis * (brick_width + brick_spacing))\n                        copy_current_frame = current_frame.transformed(T13)\n                        if wall_system == \"double_layer\":                        \n                            self.create_brick_and_add_to_assembly(brick_type = \"insulated\", transform_type = \"fixed\", frame = copy_current_frame)\n\n                    else:\n                        # first row - self-shading bricks - stretcher bricks\n                        T14 = Translation.from_vector(brick_frame.xaxis * (brick_length + brick_spacing))\n                        current_frame = brick_frame.transformed(T14)\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"rotate\", frame=brick_frame) \n\n                        if wall_system == \"single_layer\": # stretcher bricks - copy\n                            T15 = Translation.from_vector(brick_frame.yaxis * (brick_length + brick_spacing))\n                            current_frame = brick_frame.transformed(T15)\n                            self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"fixed\", frame=current_frame)\n\n                        if wall_system == \"double_layer\":\n                            # last brick in the row\n                            T14 = Translation.from_vector(brick_frame.yaxis * (brick_length + brick_width + 2 * brick_spacing))\n                            current_frame = brick_frame.transformed(T14)\n                            self.create_brick_and_add_to_assembly(brick_type = \"insulated\", transform_type = \"fixed\", frame = current_frame) \n\n                            # middle bricks in the row\n                            R5 = Rotation.from_axis_and_angle(current_frame.zaxis, math.radians(90), point=current_frame.point)\n                            T15 = Translation.from_vector(current_frame.yaxis * ((brick_width - brick_length)/2 + brick_spacing/4))\n                            T16 = Translation.from_vector(current_frame.xaxis * - ((brick_width + brick_length)/2 + brick_spacing))\n                            current_frame = current_frame.transformed(R5 * T15 * T16)\n                            self.create_brick_and_add_to_assembly(brick_type = \"insulated\", transform_type = \"fixed\", frame = current_frame)\n\n                            T17 = Translation.from_vector(current_frame.yaxis * -(brick_length + brick_spacing))\n                            current_frame = current_frame.transformed(T17)\n                            self.create_brick_and_add_to_assembly( brick_type = \"insulated\", transform_type = \"fixed\", frame = current_frame)\n\n                elif brick == bricks_per_course - 1: # last brick even courses\n                    R6 = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(90), point=brick_frame.point)  \n                    current_frame = brick_frame.transformed(R6)\n                    T18 = Translation.from_vector(current_frame.xaxis * ((brick_length + brick_spacing)/2))\n                    current_frame = current_frame.transformed(T18)\n                    self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"translate\", frame=current_frame)\n\n                    if wall_system == \"double_layer\":\n                        # last insulated brick\n                        T19 = Translation.from_vector(current_frame.xaxis *((brick_width + brick_spacing)))\n                        current_frame = current_frame.transformed(T19)\n                        self.create_brick_and_add_to_assembly(brick_type = \"insulated\", transform_type = \"fixed\", frame = current_frame)\n\n    def generate_corner_flemish_bond(self, \n                                    initial_brick_position,\n                                    bricks_per_course,\n                                    course_is_odd,\n                                    direction_vector,\n                                    brick_spacing,\n                                    start_edge_type,\n                                    end_edge_type,\n                                    ):\n        \n        \n        brick_length, _, brick_width, brick_length_h = self.get_brick_dimensions()\n        brick_full = self.brick_params[\"brick_full\"]\n        center_brick_frame = brick_full.frame\n\n        shift_vector = direction_vector * ((brick_length + brick_width)/2 + brick_spacing)\n        for brick in range(bricks_per_course):\n            T = direction_vector * (brick * ((brick_length + brick_width)/2 + brick_spacing))\n            if course_is_odd:\n                T += shift_vector\n\n            brick_position = initial_brick_position + T\n\n            if direction_vector[1] in [-1, 1]:\n                brick_frame = Frame(brick_position, direction_vector, center_brick_frame.xaxis)\n            else:\n                brick_frame = Frame(brick_position, direction_vector, center_brick_frame.yaxis)\n\n            if not course_is_odd:\n                if brick % 2 != 0:  # last header brick\n                    R1 = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(90), point=brick_frame.point)\n                    T1 = Translation.from_vector(brick_frame.xaxis * (brick_length + brick_spacing) / 2)\n                    current_frame = brick_frame.transformed(R1 * T1)\n                    \n                    if start_edge_type == 'corner' and brick == 1:\n                        T2 = Translation.from_vector(brick_frame.xaxis * (brick_length_h / 2))\n                        current_frame = current_frame.transformed(T2)\n                        self.create_brick_and_add_to_assembly(brick_type=\"half\", transform_type=\"fixed\", frame=current_frame)\n\n                    elif end_edge_type == 'corner' and brick == bricks_per_course - 2:\n                        T3 = Translation.from_vector(brick_frame.xaxis * (-brick_length_h / 2))\n                        current_frame = current_frame.transformed(T3)\n                        self.create_brick_and_add_to_assembly(brick_type=\"half\", transform_type=\"fixed\", frame=current_frame)\n\n                    else: # end_edge_type == 'corner':\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type=\"fixed\", frame=current_frame)\n\n                else:\n                    if start_edge_type == 'corner' and brick == 0:\n                        T4 = Translation.from_vector(brick_frame.xaxis * (brick_length_h))\n                        current_frame = brick_frame.transformed(T4)\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type=\"fixed\", frame=current_frame)\n\n                        #T8 = Translation.from_vector(brick_frame.yaxis * (brick_length + brick_spacing))\n                        #current_frame = current_frame.transformed(T8)\n                        #self.create_brick_and_add_to_assembly(brick_type=\"insulated\", transform_type=\"fixed\", frame=current_frame)\n                        \n                    elif end_edge_type == 'corner' and brick == bricks_per_course - 1:\n                        T5 = Translation.from_vector(brick_frame.xaxis * (-brick_length_h))\n                        current_frame = brick_frame.transformed(T5)\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type=\"fixed\", frame=current_frame)\n\n                        #T6 = Translation.from_vector(current_frame.yaxis * (brick_length + brick_spacing))\n                        #current_frame = current_frame.transformed(T6)\n                        #self.create_brick_and_add_to_assembly(brick_type=\"insulated\", transform_type=\"fixed\", frame=current_frame)\n\n                    else: #end_edge_type == 'corner':\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type=\"fixed\", frame=brick_frame)\n\n                        T7 = Translation.from_vector(brick_frame.yaxis * (brick_length + brick_spacing))\n                        current_frame = brick_frame.transformed(T7)\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type=\"fixed\", frame=current_frame)\n\n    def calculate_flemish_course_length(self,\n                                        bricks_per_course,\n                                        brick_spacing,\n                                        course_is_odd):\n        \"\"\"\n        Calculate the total length of a Flemish bond course \n\n        Parameters\n        ----------\n        brick_full : :class:`CAEPart`\n            The full brick to use for the wall.\n        bricks_per_course : int\n            The number of bricks in the course.\n        brick_spacing : float\n            The spacing between bricks.\n        course_is_odd : bool\n            True if the course is an odd-numbered course, False otherwise.\n\n        Returns\n        -------\n        float\n            The total length of the brick bond course.\n        \"\"\"\n\n        brick_length, _, brick_width, _ = self.get_brick_dimensions()\n\n        # Calculate the total length based on the pattern\n        if course_is_odd:\n            # Odd courses start and end with a header, alternate in between\n            total_length = (bricks_per_course // 2) * (brick_width + brick_length + 2 * brick_spacing)\n        else:\n            # Even courses start and end with a stretcher, alternate in between\n            total_length = (bricks_per_course // 2) * (brick_length + brick_width + 2 * brick_spacing)\n\n        return total_length\n\n    def reset_transformations(self):\n        \"\"\"\n        Reset all transformations applied to the parts back to their original state.\n        \"\"\"\n        for key in self.graph.nodes():\n            part = self.part(key)\n            if hasattr(part, 'original_frame'):\n                # Reset the part's frame to its original frame\n                T = Transformation.from_frame_to_frame(part.frame, part.original_frame)\n                part.transform(T)\n\n    def apply_gradient(self, values, points, keys, transform_type, rotation_direction, nrbh_size, reset):\n        \"\"\"\n        Apply a gradient transformation to the parts.\n\n        Parameters\n        ----------\n        values : list\n            List of values to determine the transformation.\n        points : list or array_like\n            3D points corresponding to the parts (used for nearest neighbor search).\n        keys : list\n            List of keys identifying the parts.\n        transform_type : str\n            Type of transformation to apply (\"translate\" or \"rotate\"). \n        rotation_direction : str\n            Direction for rotation (\"left\" or other).\n        nrbh_size : int\n            The number of nearest neighbors to consider.\n        reset : bool\n            Whether to reset transformations.\n        ornament : str, optional\n            Ornament type (\"cross\", \"straight\", \"diamond\", etc.).\n        \"\"\"\n\n        if reset:\n            self.reset_transformations()\n            return\n\n        # Build a KDTree for fast nearest neighbor search.\n        tree = cKDTree(points)\n\n        # Normalize the global direction \n        global_direction = Vector(0, 1, 0)\n        global_direction = normalize_vector(global_direction)\n\n        #z_values = {key: self.graph.node_attribute(key, \"z\") for key in keys}\n        #unique_z_values = sorted(set(z_values.values()))\n        #z_to_course_index = {z: i for i, z in enumerate(unique_z_values)}\n\n        for key in keys:\n            part = self.part(key)\n            part_position = part.frame.point \n\n            # Nearest neighbor search to grab associated values\n            distances, indices = tree.query(part_position, k=nrbh_size)\n            neighbor_values = np.array([values[i] for i in indices])\n            \n            # Use inverse-distance weighting for interpolation\n            weights = 1 / (distances + 1e-10)\n            weights /= weights.sum()\n            value = np.dot(weights, neighbor_values)\n\n            translation_factor = value * -0.08  # Factor for translation\n            rotation_factor = value * -0.1      # Factor for rotation\n\n            if transform_type == \"translate\":\n                # Determine the orientation of the brick based on its local frame and global direction\n                brick_length, _, brick_width, _ = self.get_brick_dimensions()\n\n                local_xaxis, local_yaxis = part.frame.xaxis, part.frame.yaxis\n\n                #Compute the dot products to determine the facing direction\n                dot_x = abs(local_xaxis.dot(global_direction))  \n                dot_y = abs(local_yaxis.dot(global_direction))\n\n                if brick_length > brick_width:\n                    facing = \"header\" if dot_x >= dot_y else \"strecher\"\n                else:\n                    facing = \"header\" if dot_y >= dot_x else \"strecher\"\n            \n                if facing == \"header\":\n                    translation_vector = local_yaxis * translation_factor\n                else:\n                    translation_vector = local_xaxis * translation_factor\n\n                T = Translation.from_vector(translation_vector)\n\n\n\n            elif transform_type == \"rotate\":\n                center_brick_frame = part.frame\n                if rotation_direction == \"left\":\n                    rotation_factor = -rotation_factor\n                    R = Rotation.from_axis_and_angle(center_brick_frame.zaxis, rotation_factor, point=center_brick_frame.point)\n                    translation_vector = np.array(center_brick_frame.yaxis) * (-(0.09 * rotation_factor))\n                else:\n                    R = Rotation.from_axis_and_angle(center_brick_frame.zaxis, rotation_factor, point=center_brick_frame.point)\n                    translation_vector = np.array(center_brick_frame.yaxis) * (0.09 * rotation_factor)\n                    x_translation_vector = np.array(center_brick_frame.xaxis) * (-0.015 * rotation_factor)\n                    translation_vector += x_translation_vector\n\n                if value < 0:\n                    translation_vector = -translation_vector\n\n                T = R * Translation.from_vector(translation_vector)\n\n            else:\n                continue\n\n            part.transform(T)\n\n    def add_part_from_model(self, part, key=None, attr_dict=None, **kwargs):\n        \"\"\"Add a part to the assembly.\n\n        Parameters\n        ----------\n        part : :class:`compas.datastructures.Part`\n            The part to add.\n        key : int | str, optional\n            The identifier of the part in the assembly.\n            Note that the key is unique only in the context of the current assembly.\n            Nested assemblies may have the same `key` value for one of their parts.\n            Default is None in which case the key will be an automatically assigned integer value.\n        **kwargs: dict[str, Any], optional\n            Additional named parameters collected in a dict.\n\n        Returns\n        -------\n        int | str\n            The identifier of the part in the current assembly graph.\n\n        \"\"\"\n        if part.guid in self._parts:\n            raise AssemblyError(\"Part already added to the assembly\")\n        \n        key = self.graph.add_node(key=key, part=part, x=part.frame.point.x, y=part.frame.point.y, z=part.frame.point.z, **kwargs)\n        part.key = key\n        self._parts[part.guid] = part.key\n\n        if attr_dict:\n            for attr, value in attr_dict.items():\n                part.attributes[attr] = value\n                self.graph.node_attribute(key, attr, value)\n\n        part.original_frame = part.frame.copy()\n\n        return key\n    \n    def read_model_to_assembly(self, brick_list, brick_type, transform_type):\n        \"\"\"Read a model to an assembly.\n\n        Parameters\n        ----------\n        brick_list : list\n            List of bricks to add to the assembly.\n        brick_type : str\n            The type of brick to add to the assembly.\n        transform_type : str, optional\n            Type of transformation to apply (\"fixed\", \"translate\", or \"rotate\"). \n        \"\"\"\n        for brick in brick_list:\n\n            if brick.Faces.Count > 0:\n                face = brick.Faces[5]\n                \n                u, v = face.Domain(0).Mid, face.Domain(1).Mid\n                plane = face.FrameAt(u, v)\n                frame = plane_to_compas_frame(plane[1])\n\n                brick_part = self.brick_params[brick_type]\n                z_size = brick_part.shape.zsize\n                translation_vector = -frame.zaxis * (z_size / 2)\n                \n                frame.point += translation_vector\n                T = Transformation.from_frame_to_frame(brick_part.frame, frame)\n                part = brick_part.transformed(T)\n\n                part.frame = frame\n\n            part_key = self.add_part_from_model(part, attr_dict={\"brick_type\": brick_type, \n                                                                 \"transform_type\": transform_type,\n                                                                 })\n            z_value = frame.point.z\n            self.graph.node_attribute(part_key, 'z', z_value)\n\n    def assembly_courses(self, tol=0.001):\n        \"\"\"Identify the courses in a wall of bricks.\n\n        Parameters\n        ----------\n        wall : Assembly\n            The wall assembly data structure.\n\n        Examples\n        --------\n        .. code-block:: python\n\n            pass\n\n        \"\"\"\n        courses = []\n\n        # all part keys\n        parts = set(self.graph.nodes())\n\n        # base course keys\n        c_min = min(self.graph.nodes_attribute('z'))\n\n        base = set()\n        for e in parts:\n            z = self.graph.node_attribute(key=e, name='z')\n            if (z - c_min) ** 2 < tol:\n                base.add(e)\n\n        if base:\n            courses.append(list(base))\n            parts -= base\n            while parts:  # and counter<1000:\n                c_min = min([self.graph.node_attribute(key=key, name='z') for key in parts])\n                base = set()\n                for p in parts:\n                    z = self.graph.node_attribute(key=p, name='z')\n                    if (z - c_min) ** 2 < tol:\n                        base.add(p)\n                courses.append(list(base))\n                parts -= base\n\n        # assign course id's to the corresponding blocks\n        for i, course in enumerate(courses):\n            self.graph.nodes_attribute(name='course', value=i, keys=course)\n\n        return courses   \n\n    def project_part_faces(self, courses):\n        \"\"\"Project the faces of the parts in the assembly to 2D polygons.\n\n        Parameters\n        ----------\n        courses : list\n            List of courses in the assembly.\n\n        Returns\n        -------\n        dict\n            Dictionary mapping part keys to their corresponding 2D polygons.\n        \"\"\"    \n\n        courses = self.assembly_courses()\n        sorted_parts = [part for course in courses for part in course]\n        polygons = {}\n        \n        for part in sorted_parts:\n            part = self.part(part)\n            mesh = part.mesh\n            fkey_centroid = {fkey: mesh.face_center(fkey) for fkey in mesh.faces()}\n            \n            # Find the face with the lowest z-coordinate\n            bottom_face = min(fkey_centroid.items(), key=lambda x: x[1][2])[0]\n\n            # Get the vertices of the bottom face\n            face_vertices = mesh.face_vertices(bottom_face)\n            vertices = [mesh.vertex_coordinates(vkey) for vkey in face_vertices]\n\n            # Project the vertices to 2D (x, y)\n            projected_vertices = [(x, y) for x, y, z in vertices]\n\n            # Create a 2D polygon from the projected vertices\n            polygon = Polygon(projected_vertices)\n            polygons[part.key] = polygon\n\n        return polygons\n\n\n        # for part in sorted_parts:\n        #     frame_point = self.graph.node_attributes(part, 'xyz')\n        #     part = self.part(part)\n        #     for face in part.mesh.faces():\n        #         face_vertices = part.mesh.face_vertices(face)\n        #         face_coords = [part.mesh.vertex_coordinates(vkey) for vkey in face_vertices]\n        #         if all(coord[2] == frame_point[2] for coord in face_coords):\n        #             target_face = face\n        #     face_vertices = part.mesh.face_vertices(target_face)\n        #     vertices = [part.mesh.vertex_coordinates(vkey) for vkey in face_vertices]\n        #     projected_vertices = [(x, y) for x, y, z in vertices]\n        #     polygon = Polygon(projected_vertices)\n        #     polygons[part.key] = polygon\n        # return polygons\n\n    def compute_polygon_intersections(self, polygons, courses):\n        intersections = {}\n        for i in range(len(courses) - 1):\n            current_course = courses[i]\n            next_course = courses[i + 1]\n\n            current_course_parts = current_course\n            next_course_parts = next_course\n\n            for part in current_course_parts:\n                part_polygon = polygons.get(part)\n                if not part_polygon:\n                    continue\n\n                for neighbor in next_course_parts:\n                    neighbor_polygon = polygons.get(neighbor)\n                    if not neighbor_polygon:\n                        continue\n\n                    # Convert compas polygons to shapely polygons\n                    shapely_part_polygon = ShapelyPolygon([(point.x, point.y) for point in part_polygon.points])\n                    shapely_neighbor_polygon = ShapelyPolygon([(point.x, point.y) for point in neighbor_polygon.points])\n\n                    # Compute intersection\n                    intersection = shapely_part_polygon.intersection(shapely_neighbor_polygon)\n                    if not intersection.is_empty:\n                        # Handle different intersection types\n                        if intersection.geom_type == \"Polygon\":\n                            intersection_coords = list(intersection.exterior.coords)\n                        elif intersection.geom_type == \"LineString\":\n                            intersection_coords = list(intersection.coords)\n                        else:\n                            continue  # Skip Points or other types\n\n                        intersection_points = [Point(x, y, part_polygon.points[0].z) for x, y in intersection_coords]\n                        intersections[(part, neighbor)] = Polygon(intersection_points)\n\n        return intersections\n\n    def transform_intersections_to_original_course(self, intersections, courses):\n        transformed_intersections = {}\n        for (part, neighbor), intersection in intersections.items():\n            part_course = next(i for i, course in enumerate(courses) if part in course)\n            neighbor_course = next(i for i, course in enumerate(courses) if neighbor in course)\n            if part_course < neighbor_course:\n                z_coord = self.graph.node_attribute(part, 'z')\n                transformed_intersection_points = [Point(p.x, p.y, z_coord) for p in intersection.points]\n                transformed_intersections[(part, neighbor)] = Polygon(transformed_intersection_points)\n            else:\n                z_coord = self.graph.node_attribute(neighbor, 'z')\n                transformed_intersection_points = [Point(p.x, p.y, z_coord) for p in intersection.points]\n                transformed_intersections[(neighbor, part)] = Polygon(transformed_intersection_points)\n\n            attr = {\n            'interface_type': 'face_face',\n            'interface_points': [(point.x, point.y, point.z) for point in transformed_intersection_points],\n            }\n            self.graph.add_edge(part, neighbor, attr_dict=attr)\n\n        return transformed_intersections\n\n    def transform_intersections_to_course_above(self, intersections, courses):\n        transformed_intersections = {}\n        for (part, neighbor), intersection in intersections.items():\n            neighbor_course = next(i for i, course in enumerate(courses) if neighbor in course)\n            z_coord = self.graph.node_attribute(neighbor, 'z')\n            transformed_intersection_points = [Point(p.x, p.y, z_coord) for p in intersection.points]\n            transformed_intersections[(part, neighbor)] = Polygon(transformed_intersection_points)\n\n            attr = {\n                'interface_type': 'face_face',\n                'interface_points': [(point.x, point.y, point.z) for point in transformed_intersection_points],\n            }\n            self.graph.add_edge(part, neighbor, attr_dict=attr)\n\n        return transformed_intersections\n\n    def set_interface_points(self):\n        for key in self.graph.nodes():\n            # Skip parts tagged with \"skip_intersections\"\n            if self.graph.node_attribute(key, 'skip_intersections'):\n                continue\n\n            part = self.part(key)\n            frame_point = self.graph.node_attributes(key, 'xyz')\n            target_face = None\n\n            # Find the face that matches the condition\n            for face in part.mesh.faces():\n                face_vertices = part.mesh.face_vertices(face)\n                face_coords = [part.mesh.vertex_coordinates(vkey) for vkey in face_vertices]\n                if all(coord[2] == frame_point[2] for coord in face_coords):\n                    target_face = face\n                    break\n\n            # If no valid face is found, skip this part\n            if target_face is None:\n                continue\n\n            # Get the vertices of the target face\n            face_vertices = part.mesh.face_vertices(target_face)\n            vertices = [part.mesh.vertex_coordinates(vkey) for vkey in face_vertices]\n            projected_vertices = [(x, y) for x, y, z in vertices]\n\n            # Store the interface points as a node attribute\n            self.graph.node_attribute(key, 'interface_points', projected_vertices)\n\n    # def assembly_building_sequence(self, key):\n    #     \"\"\"Determine the sequence of bricks that need to be assembled to be able to\n    #     place a target brick.\n\n    #     Parameters\n    #     ----------\n    #     assembly : Assembly\n    #         An assembly data structure.\n    #     key : hashable\n    #         The block identifier.\n\n    #     Returns\n    #     -------\n    #     list\n    #         A sequence of block identifiers.\n    #     Notes\n    #     -----\n    #     This will only work for properly supported *wall* assemblies of which the\n    #     interfaces and courses have been identified.\n\n    #     Examples\n    #     --------\n    #     .. code-block:: python\n\n    #         # this code only works in Rhino\n\n    #         assembly = Assembly.from_json(...)\n\n    #         placed = list(assembly.nodes_where({'is_placed': True}))\n\n    #         artist = AssemblyArtist(assembly, layer=\"Assembly\")\n\n    #         artist.clear_layer()\n    #         artist.draw_nodes()\n    #         artist.draw_blocks(show_faces=False, show_edges=True)\n\n    #         if placed:\n    #             artist.draw_blocks(keys=placed, show_faces=True, show_edges=False)\n\n    #         artist.redraw()\n\n    #         key = AssemblyHelper.select_node(assembly)\n\n    #         sequence = assembly_block_building_sequence(assembly, key)\n\n    #         print(sequence)\n\n    #         keys = list(set(sequence) - set(placed))\n\n    #         artist.draw_blocks(keys=keys, show_faces=True, show_edges=False)\n    #         artist.redraw()\n\n    #     \"\"\"\n\n    #     course = self.graph.node_attribute(key, 'course')\n\n    #     if course is None:\n    #         raise Exception(\"The courses of the assembly have not been identified.\")\n\n    #     sequence = []\n    #     seen = set()\n    #     tovisit = deque([(key, course + 1)])\n\n    #     while tovisit:\n    #         k, course_above = tovisit.popleft()\n\n    #         if k not in seen:\n    #             seen.add(k)\n    #             course = self.graph.node_attribute(k, 'course')\n\n    #             if course_above == course + 1:\n    #                 sequence.append(k)\n    #                 for nbr in self.graph.neighbors(k):\n    #                     if nbr not in seen:\n    #                         tovisit.append((nbr, course))\n\n    #     for i in range(len(sequence) - 1):\n    #         self.add_connection(sequence[i], sequence[i + 1])\n\n    #     for i in range(len(sequence)):\n    #         current_node = sequence[i]\n    #         current_z = self.graph.node_attribute(current_node, 'z')\n    #         for j in range(i + 1, len(sequence)):\n    #             next_node = sequence[j]\n    #             next_z = self.graph.node_attribute(next_node, 'z')\n    #             if next_z > current_z:\n    #                 self.add_connection(current_node, next_node)\n    #                 break\n\n    #     return sequence[::-1]\n    \n    def sort_parts_by_closest_neighbor(self, courses):\n        \"\"\"Sort parts in each course by their XY coordinates.\n\n        Parameters\n        ----------\n        courses : list\n            A list of courses, where each course is a list of part keys.\n\n        Returns\n        -------\n        list\n            A list of sorted courses, where each course is a list of part keys sorted by XY coordinates.\n        \"\"\"\n\n        sorted_courses = []\n        for course in courses:\n            if not course:\n                continue\n\n            # Start with the first part in the course\n            remaining_parts = set(course)\n            current_part = remaining_parts.pop()\n            sorted_course = [current_part]\n\n            while remaining_parts:\n                # Find the closest neighbor to the current part\n                current_x = self.graph.node_attribute(current_part, 'x')\n                current_y = self.graph.node_attribute(current_part, 'y')\n\n                closest_part = min(\n                    remaining_parts,\n                    key=lambda key: (\n                        (self.graph.node_attribute(key, 'x') - current_x) ** 2 +\n                        (self.graph.node_attribute(key, 'y') - current_y) ** 2\n                    )\n                )\n\n                # Add the closest part to the sorted list and remove it from remaining parts\n                sorted_course.append(closest_part)\n                remaining_parts.remove(closest_part)\n                current_part = closest_part\n\n            sorted_courses.append(sorted_course)\n\n        return sorted_courses\n\n    def sort_parts_by_direction(self, courses):\n        \"\"\"Sort parts in each course by moving first in the positive X direction, then in the positive Y direction.\n\n        Parameters\n        ----------\n        courses : list\n            A list of courses, where each course is a list of part keys.\n\n        Returns\n        -------\n        list\n            A list of sorted courses, where each course is sorted by positive X and then positive Y direction.\n        \"\"\"\n        sorted_courses = []\n        for course in courses:\n            if not course:\n                continue\n\n            # Sort parts by X first, then by Y\n            sorted_course = sorted(\n                course,\n                key=lambda key: (\n                    self.graph.node_attribute(key, 'x'),  # Sort by X coordinate\n                    self.graph.node_attribute(key, 'y')   # Then by Y coordinate\n                )\n            )\n            sorted_courses.append(sorted_course)\n\n        return sorted_courses\n\n    def reassign_part_keys(self, sorted_courses):\n        \"\"\"Reassign the keys of the parts in the assembly based on the sorted courses.\n\n        Parameters\n        ----------\n        sorted_courses : list\n            A list of sorted courses, where each course is a list of part keys.\n        \"\"\"\n        new_graph = Graph()\n        key_mapping = {}\n\n        # Flatten the sorted courses into a single list of parts\n        sorted_parts = [part for course in sorted_courses for part in course]\n\n        # Iterate through the sorted parts and reassign keys\n        for new_key, old_key in enumerate(sorted_parts):\n            part = self.graph.node_attribute(old_key, 'part')\n            attributes = self.graph.node_attributes(old_key)\n\n            # Add the part to the new graph with the new key\n            new_graph.add_node(new_key, **attributes)\n            new_graph.node_attribute(new_key, 'part', part)\n\n            # Store the mapping of old keys to new keys\n            key_mapping[old_key] = new_key\n\n        # Replace the old graph with the new graph\n        self.graph = new_graph\n\n        return key_mapping",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}