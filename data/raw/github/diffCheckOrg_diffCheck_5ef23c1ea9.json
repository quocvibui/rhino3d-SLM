{
  "source_url": "https://github.com/diffCheckOrg/diffCheck/blob/8f668b1f273e8d81a282c6115ba3eae07eef9235/src/gh/components/DF_csv_exporter/code.py",
  "repo": "diffCheckOrg/diffCheck",
  "repo_stars": 15,
  "repo_description": "diffCheck is a CAD-integrated tool for evaluating digital timber fabrication processes.",
  "license": "GPL-3.0",
  "filepath": "src/gh/components/DF_csv_exporter/code.py",
  "instruction": null,
  "code": "#! python3\n\nimport System\nimport csv\nimport os\nimport typing\n\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper as gh\n\nfrom diffCheck.df_error_estimation import DFInvalidData, DFVizResults\n\n\ndef add_bool_toggle(self,\n    nickname: str,\n    indx: int,\n    X_param_coord: float,\n    Y_param_coord: float,\n    X_offset: int=87\n    ) -> None:\n    \"\"\"\n        Adds a boolean toggle to the component input\n\n        :param nickname: the nickname of the value list\n        :param indx: the index of the input parameter\n        :param X_param_coord: the x coordinate of the input parameter\n        :param Y_param_coord: the y coordinate of the input parameter\n        :param X_offset: the offset of the value list from the input parameter\n    \"\"\"\n    param = ghenv.Component.Params.Input[indx]  # noqa: F821\n    if param.SourceCount == 0:\n        toggle = gh.Kernel.Special.GH_BooleanToggle()\n        toggle.NickName = nickname\n        toggle.Description = \"Toggle the value to use with DFVizSettings\"\n        toggle.CreateAttributes()\n        toggle.Attributes.Pivot = System.Drawing.PointF(\n            X_param_coord - (toggle.Attributes.Bounds.Width) - X_offset,\n            Y_param_coord - (toggle.Attributes.Bounds.Height / 2 + 0.1)\n            )\n        toggle.Attributes.ExpireLayout()\n        gh.Instances.ActiveCanvas.Document.AddObject(toggle, False)\n        ghenv.Component.Params.Input[indx].AddSource(toggle)  # noqa: F821\n\n\nclass DFCsvExporter(component):\n    def __init__(self):\n        super(DFCsvExporter, self).__init__()\n        self.prefix = \"\"\n        self.counter = 0\n\n        ghenv.Component.ExpireSolution(True)  # noqa: F821\n        ghenv.Component.Attributes.PerformLayout()  # noqa: F821\n        params = getattr(ghenv.Component.Params, \"Input\")  # noqa: F821\n        for j in range(len(params)):\n            Y_cord = params[j].Attributes.InputGrip.Y + 1\n            X_cord = params[j].Attributes.Pivot.X + 10\n            input_indx = j\n            if \"i_export_seperate_files\" == params[j].NickName:\n                add_bool_toggle(\n                    ghenv.Component,  # noqa: F821\n                    \"export_asfiles\",\n                    input_indx, X_cord, Y_cord)\n            if \"i_export_distances\" == params[j].NickName:\n                add_bool_toggle(\n                    ghenv.Component,  # noqa: F821\n                    \"export_dist\",\n                    input_indx, X_cord, Y_cord)\n\n    def _prepare_row(self,\n            idx: int,\n            i_result: DFVizResults\n        ) -> typing.Dict[str, typing.Any]:\n        \"\"\"\n            Convert the results contained in the DFVizResults object to a dict to be written in the CSV file\n\n            :param idx: Index of the element\n            :param i_result: DFVizResults object containing all the values\n\n            :return: Dict of values containing as keys the header and as items the values to be written in the CSV file\n        \"\"\"\n        if i_result.sanity_check[idx].value != DFInvalidData.VALID.value:\n            invalid_type = i_result.sanity_check[idx].name\n            return {\n                f\"{self.prefix} id\": i_result.find_id(idx),\n                \"invalid_type\": invalid_type,\n                \"min_deviation\": invalid_type,\n                \"max_deviation\": invalid_type,\n                \"std_deviation\": invalid_type,\n                \"rmse\": invalid_type,\n                \"mean\": invalid_type\n            }\n\n        distances = [round(value, 4) for value in i_result.distances[idx]]\n        min_dev = round(i_result.distances_min_deviation[idx], 4)\n        max_dev = round(i_result.distances_max_deviation[idx], 4)\n        std_dev = round(i_result.distances_sd_deviation[idx], 4)\n        rmse = round(i_result.distances_rmse[idx], 4)\n        mean = round(i_result.distances_mean[idx], 4)\n\n        row: typing.Dict[str, typing.Any] = {\n            f\"{self.prefix} id\": i_result.find_id(idx),\n            \"distances\": distances,\n            \"min_deviation\": min_dev,\n            \"max_deviation\": max_dev,\n            \"std_deviation\": std_dev,\n            \"rmse\": rmse,\n            \"mean\": mean\n        }\n\n        # Add extra geometric info based on analysis type here:\n        if i_result.analysis_type == \"beam\":\n            row.update({\n                \"beam_length\": i_result.assembly.beams[idx].length\n            })\n        elif i_result.analysis_type == \"joint\":\n            # NB:: for conviniency, if there is only one beam, we add the lenght of the beam i nthe joint csv analysis output\n            if i_result.assembly.has_only_one_beam:\n                row.update({\n                    \"beam_length\": i_result.assembly.beams[0].length\n                })\n            row.update({\n                \"joint_distance_to_beam_midpoint\": i_result.assembly.compute_all_joint_distances_to_midpoint()[idx]\n            })\n        elif i_result.analysis_type == \"joint_face\":\n            row.update({\n                \"jointface_angle\": i_result.assembly.compute_all_joint_angles()[idx]\n            })\n\n        return row\n\n    def _write_csv(self,\n        csv_path: str,\n        rows: typing.List[typing.Dict[str, typing.Any]],\n        is_writing_only_distances: bool = False\n        ) -> None:\n        \"\"\"\n            Write the CSV file\n\n            :param csv_path: Path of the CSV file\n            :param rows: List of dictionaries containing values to be written in the CSV file\n            :param is_writing_only_distances: Flag to check if to write ONLY distances or the whole analysis\n\n            :return: None\n        \"\"\"\n        with open(csv_path, mode='w', newline='') as file:\n            writer = csv.writer(file, quoting=csv.QUOTE_MINIMAL)\n            if is_writing_only_distances:\n                writer.writerow(list(rows[0].keys())[:2])  # header\n                element_id = [row[f\"{self.prefix} id\"] for row in rows]\n                dist_rows = [row[\"distances\"] for row in rows]\n                for idx, dist_row in enumerate(dist_rows):\n                    for dist in dist_row:\n                        writer.writerow([element_id[idx], dist])\n            else:\n                rows = [{k: v for k, v in row.items() if k != \"distances\"} for row in rows]  # no distances\n                writer.writerow(list(rows[0].keys()))  # header\n                writer.writerows([list(row.values()) for row in rows])\n\n    def RunScript(self,\n            i_dump: bool,\n            i_export_dir: str,\n            i_file_name: str,\n            i_export_seperate_files: bool,\n            i_export_distances: bool,\n            i_result: DFVizResults) -> None:\n\n        csv_analysis_path: str = None\n        csv_distances_path: str = None\n\n        if i_dump:\n            os.makedirs(i_export_dir, exist_ok=True)\n\n            self.prefix = i_result.analysis_type\n\n            if i_export_seperate_files:\n                for idx in range(len(i_result.source)):\n                    element_id = self._get_id(idx, i_result)\n                    csv_analysis_path = os.path.join(i_export_dir, f\"{i_file_name}_{self.prefix}_{element_id}.csv\")\n                    rows = [self._prepare_row(idx, i_result)]\n                    self._write_csv(csv_analysis_path, rows)\n                    if i_export_distances:\n                        csv_distances_path = os.path.join(i_export_dir, f\"{i_file_name}_{self.prefix}_{element_id}_distances.csv\")\n                        self._write_csv(csv_distances_path, rows, is_writing_only_distances=True)\n            else:\n                csv_analysis_path = os.path.join(i_export_dir, f\"{i_file_name}.csv\")\n                merged_rows = [self._prepare_row(idx, i_result) for idx in range(len(i_result.source))]\n                self._write_csv(csv_analysis_path, merged_rows)\n                if i_export_distances:\n                    csv_distances_path = os.path.join(i_export_dir, f\"{i_file_name}_distances.csv\")\n                    self._write_csv(csv_distances_path, merged_rows, is_writing_only_distances=True)\n",
  "language": "python",
  "imports": [
    "ghpythonlib"
  ],
  "has_docstring": false
}