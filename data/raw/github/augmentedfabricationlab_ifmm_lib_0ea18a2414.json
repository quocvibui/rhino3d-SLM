{
  "source_url": "https://github.com/augmentedfabricationlab/ifmm_lib/blob/1cc6e87f5b07e0d6bd144f8f24462cc0d0a70fdb/clients/if_robot/robot.py",
  "repo": "augmentedfabricationlab/ifmm_lib",
  "repo_stars": 0,
  "repo_description": "In situ Fabricatr & Mesh Mould @ EMPA Nest 2017",
  "license": "unknown",
  "filepath": "clients/if_robot/robot.py",
  "instruction": ". . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<  <<><><>  <<      ><  <<      ><   .\n.   <<  <<       < ><   ><<  < ><   ><<   .\n.   <<  <<><><>  << ><...",
  "code": "'''\n. . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<  <<><><>  <<      ><  <<      ><   .\n.   <<  <<       < ><   ><<  < ><   ><<   .\n.   <<  <<><><>  << >< > ><  << >< > ><   .  \n.   <<  <<       <<  ><  ><  <<  ><  ><   .\n.   <<  <<       <<      ><  <<      ><   .\n.   <<  <<       <<      ><  <<      ><   .\n.                                         .\n.             GKR 2016/17                 .\n. . . . . . . . . . . . . . . . . . . . . .\n\nCreated on 02.11.2016\n\n@author: kathrind\n'''\n\nfrom ifmm_lib.geometry import Frame\nimport Rhino.Geometry as rg\nimport ghpythonlib.components as ghcomp\nimport math as m\n\nfrom communication import ABBCommunication\n\n\nclass Robot(object):\n    \n    #===========================================================================\n    def __init__(self, link_geo, base_geo, joint_planes, ip_abb = '192.168.125.1', tool = None):\n        ''' the robot class, it contains:\n        1) the geometry of the robot \n        2) the communication modules to send commands to the ABB arm.\n        '''\n        \n        self.link_geo = link_geo\n        self.base_geo = base_geo\n        \n        self.joint_planes = joint_planes\n        self.tool = tool # has to be set with the Tool class\n        \n        self.origin_plane = rg.Plane.WorldXY\n        \n        self.joint_values = [0,0,0,0,0,0]\n        \n        # transform world to robot origin\n        self.T_W_R = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, self.origin_plane)\n        # transform robot to world\n        self.T_R_W = rg.Transform.PlaneToPlane(self.origin_plane, rg.Plane.WorldXY)\n        \n        geo = self.get_geo_with_rotated_joints_in_world(self.joint_values)\n        # --> then self.T_R_TOOL0 and self.T_W_TOOL0 are set\n        \n        self.comm = ABBCommunication(\"ABB\", ip_abb, port_snd=30003, port_rcv=30004)\n        \n        self.colors_links = [ghcomp.ColourRGB(150, 220, 220, 220) for part in link_geo]\n        self.colors_base = [ghcomp.ColourRGB(150, 220, 220, 220), ghcomp.ColourRGB(150, 5, 5, 5)]\n        \n    \n    #===========================================================================  \n    def is_connected(self):\n        return self.comm.running\n    \n    #===========================================================================  \n    def get_state(self):\n        return self.comm.get_state()\n\n    #=========================================================================== \n    def set_tool(self, tool):\n        ''' sets the tool of the robot using the tool class '''\n             \n        self.tool = tool # shall be of the class Tool\n    \n    #===========================================================================\n    def set_robot_origin(self, plane):\n        ''' sets to origin plane of the robot '''\n        \n        self.origin_plane = plane\n        self.T_W_R = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, self.origin_plane)\n        self.T_R_W = rg.Transform.PlaneToPlane(self.origin_plane, rg.Plane.WorldXY)\n    \n    #===========================================================================\n    def set_robot_origin_with_pose(self, pose):\n        ''' sets to origin plane of the robot '''\n        frame = Frame()\n        frame.set_to_pose_quaternion(pose)\n        self.set_robot_origin(frame.get_plane())\n    \n    #===========================================================================\n    def set_robot_origin_with_measured_base(self, base_plane):\n        ''' sets to origin plane of the robot based on a manual measured base '''\n        \n        T = rg.Transform.PlaneToPlane(base_plane, rg.Plane.WorldXY)\n        plane = ghcomp.Transform(rg.Plane.WorldXY, T)\n        \n        self.set_robot_origin(plane)\n    \n    #===========================================================================\n    def set_robot_origin_with_measured_base_with_pose(self, base_pose):\n        ''' sets to origin plane of the robot based on a manual measured base '''\n        frame = Frame()\n        frame.set_to_pose_quaternion(base_pose)\n        \n        self.set_robot_origin_with_measured_base_as_plane(frame.get_plane())\n    \n    #===========================================================================\n    def get_robot_origin(self):\n        return rg.Plane(self.origin_plane)\n    \n    #===========================================================================\n    def get_tool_plane_in_RCS(self, tool_plane_WCS):\n        ''' returns the tool plane in the robot coordinate system from a plane in the world cs'''\n\n        tool_plane_RCS = ghcomp.Transform(tool_plane_WCS, self.T_R_W)\n        return tool_plane_RCS\n    \n    #===========================================================================\n    def get_tool_pose_in_RCS(self, tp_WCS):\n        ''' returns the tool pose in the robot coordinate system from a plane in the world cs'''\n        \n        frame = Frame(self.get_tool_plane_in_RCS(tp_WCS))\n        return frame.get_pose_angle_axis()\n    \n    #===========================================================================\n    def get_tool0_plane_in_RCS_from_plane_RCS(self, tp_RCS):\n        ''' returns the tool0 plane in the robot coordinate system from a plane in the robot cs -\n        we want to 'subtract' the tool T from the tool plane in RCS '''\n\n        T_TP_in_zero_W = rg.Transform.PlaneToPlane(self.tool.plane, rg.Plane.WorldXY)\n        \n        tool0_plane_in_RCS = rg.Plane.WorldXY\n        tool0_plane_in_RCS.Transform(T_TP_in_zero_W)\n        \n        T_W_TP_in_RCS = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tp_RCS)\n        tool0_plane_in_RCS.Transform(T_W_TP_in_RCS)\n        \n        return tool0_plane_in_RCS  \n    \n    \n    #===========================================================================\n    def get_tool0_plane_in_RCS(self, tp_WCS):\n        ''' returns the tool0 plane in the robot coordinate system from a plane in the world cs -\n        we want to 'subtract' the tool T from the tool plane in RCS '''\n        \n        tool_plane_in_RCS = self.get_tool_plane_in_RCS(tp_WCS)\n\n        T_TP_in_zero_W = rg.Transform.PlaneToPlane(self.tool.plane, rg.Plane.WorldXY)\n        \n        tool0_plane_in_RCS = rg.Plane.WorldXY\n        tool0_plane_in_RCS.Transform(T_TP_in_zero_W)\n        \n        T_W_TP_in_RCS = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tool_plane_in_RCS)\n        tool0_plane_in_RCS.Transform(T_W_TP_in_RCS)\n        \n        return tool0_plane_in_RCS        \n        \n    #===========================================================================\n    def get_tool_plane_from_pose_quaternion(self, pose_quaternion):\n        ''' Returns the tool plane according to the given pose in angle axis. '''\n        frame = Frame()\n        frame.set_to_pose_quaternion(pose_quaternion)\n        return frame.get_plane() \n    \n    #===========================================================================\n    def get_tool0_plane_from_pose_quaternion(self, pose_quaternion):\n        ''' Returns the tool0 plane according to the given pose in angle axis. '''\n        tool_plane_RCS = self.get_tool_plane_from_pose_quaternion(pose_quaternion)\n        \n        # Edit Romana:\n        T1 = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tool_plane_RCS)\n        T2 = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, self.tool.get_plane())\n        tool0_plane_RCS = rg.Plane.WorldXY\n        tool0_plane_RCS.Transform(T1 * T2)\n\n        # Kathrin TODO: this does not work... why??\n        #T = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, self.tool.get_plane())\n        #tcp_plane_RCS = ghcomp.Transform(tool_plane_RCS, T)\n        return tool0_plane_RCS       \n        \n    def get_geo_with_rotated_joints_in_world(self, joint_values):\n        ''' the joint values (in degrees) serve as the input, the method returns the link geo (and tool geo) and tool0 plane transformed '''\n        \n        # the angles in radians\n        joint_values = [m.radians(j) for j in joint_values]\n        a1, a2, a3, a4, a5, a6 = joint_values\n        L1, L2, L3, L4, L5, L6 = self.link_geo\n        \n        # calculate transformations\n        j1, j2, j3, j4, j5, j6 = [rg.Plane(jp) for jp in self.joint_planes]\n        \n        T1 = rg.Transform.Rotation(a1, j1.ZAxis, j1.Origin)\n        T2 = T1 * rg.Transform.Rotation(a2, j2.ZAxis, j2.Origin)\n        T3 = T2 * rg.Transform.Rotation(a3, j3.ZAxis, j3.Origin)\n        T4 = T3 * rg.Transform.Rotation(a4, j4.ZAxis, j4.Origin)\n        T5 = T4 * rg.Transform.Rotation(a5, j5.ZAxis, j5.Origin)\n        T6 = T5 * rg.Transform.Rotation(a6, j6.ZAxis, j6.Origin)\n        \n        L1_t = ghcomp.Transform(L1, T1)\n        L2_t = ghcomp.Transform(L2, T2)\n        L3_t = ghcomp.Transform(L3, T3)\n        L4_t = ghcomp.Transform(L4, T4)\n        L5_t = ghcomp.Transform(L5, T5)\n        L6_t = ghcomp.Transform(L6, T6)\n        \n        link_geo_transformed = [L1_t, L2_t, L3_t, L4_t, L5_t, L6_t]\n        \n        tool0_plane_transformed = ghcomp.Transform(j6, T6)\n        self.T_R_TOOL0 = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tool0_plane_transformed)\n        \n        link_geo_transformed_world = ghcomp.Transform(link_geo_transformed, self.T_W_R)\n        tool0_plane_transformed_world = ghcomp.Transform(tool0_plane_transformed, self.T_W_R)\n        base_geo_world = ghcomp.Transform(self.base_geo, self.T_W_R)\n        \n        self.T_W_TOOL0 = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tool0_plane_transformed_world)\n        \n        if self.tool:\n            tool_geo_trfd_world = ghcomp.Transform(self.tool.geo, rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tool0_plane_transformed_world))\n            return [base_geo_world, link_geo_transformed_world, tool_geo_trfd_world] \n        else:\n            return [base_geo_world, link_geo_transformed_world]\n        \n    \n    def get_attachment_planes_for_cables(self, plane_transformer, plane_gripper, joint_values, tool_joint_values, extended = True, transformer_on_axis = 3):\n        \n        tool0_plane_transformed_world = self.get_tool0_plane_from_joint_values_world(joint_values)\n        \n        # the angles in radians\n        joint_values = [m.radians(j) for j in joint_values]\n        a1, a2, a3, a4, a5, a6 = joint_values\n\n        # calculate transformations\n        j1, j2, j3, j4, j5, j6 = [rg.Plane(jp) for jp in self.joint_planes]\n        \n        T1 = rg.Transform.Rotation(a1, j1.ZAxis, j1.Origin)\n        T2 = T1 * rg.Transform.Rotation(a2, j2.ZAxis, j2.Origin)\n        T3 = T2 * rg.Transform.Rotation(a3, j3.ZAxis, j3.Origin)\n        T4 = T3 * rg.Transform.Rotation(a4, j4.ZAxis, j4.Origin)\n        T5 = T4 * rg.Transform.Rotation(a5, j5.ZAxis, j5.Origin)\n        T6 = T5 * rg.Transform.Rotation(a6, j6.ZAxis, j6.Origin)\n        \n        if transformer_on_axis == 6: plane_transformer_transformed = ghcomp.Transform(plane_transformer, T6) \n        if transformer_on_axis == 4: plane_transformer_transformed = ghcomp.Transform(plane_transformer, T4) \n        if transformer_on_axis == 3: plane_transformer_transformed = ghcomp.Transform(plane_transformer, T3)\n        \n        plane_transformer_transformed_world = ghcomp.Transform(plane_transformer_transformed, self.T_W_R)   \n        \n        T = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tool0_plane_transformed_world)       \n        plane_gripper_transformed_world = self.tool.get_transformed_plane_gripper(T, tool_joint_values[0], tool_joint_values[1], plane_gripper, extended = extended)\n        \n        return (plane_transformer_transformed_world, plane_gripper_transformed_world)\n    \n    def get_geo_with_rotated_joints_in_world_with_tool_rot(self, joint_values, tool_joint_values, extended = True):\n        ''' the joint values (in degrees) serve as the input, the method returns the link geo (and tool geo) and tool0 plane transformed '''\n        \n        # the angles in radians\n        joint_values = [m.radians(j) for j in joint_values]\n        a1, a2, a3, a4, a5, a6 = joint_values\n        L1, L2, L3, L4, L5, L6 = self.link_geo\n        \n        # calculate transformations\n        j1, j2, j3, j4, j5, j6 = [rg.Plane(jp) for jp in self.joint_planes]\n        \n        T1 = rg.Transform.Rotation(a1, j1.ZAxis, j1.Origin)\n        T2 = T1 * rg.Transform.Rotation(a2, j2.ZAxis, j2.Origin)\n        T3 = T2 * rg.Transform.Rotation(a3, j3.ZAxis, j3.Origin)\n        T4 = T3 * rg.Transform.Rotation(a4, j4.ZAxis, j4.Origin)\n        T5 = T4 * rg.Transform.Rotation(a5, j5.ZAxis, j5.Origin)\n        T6 = T5 * rg.Transform.Rotation(a6, j6.ZAxis, j6.Origin)\n        \n        L1_t = ghcomp.Transform(L1, T1)\n        L2_t = ghcomp.Transform(L2, T2)\n        L3_t = ghcomp.Transform(L3, T3)\n        L4_t = ghcomp.Transform(L4, T4)\n        L5_t = ghcomp.Transform(L5, T5)\n        L6_t = ghcomp.Transform(L6, T6)\n        \n        link_geo_transformed = [L1_t, L2_t, L3_t, L4_t, L5_t, L6_t]\n        \n        tool0_plane_transformed = ghcomp.Transform(j6, T6)\n        self.T_R_TOOL0 = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tool0_plane_transformed)\n        \n        link_geo_transformed_world = ghcomp.Transform(link_geo_transformed, self.T_W_R)\n        tool0_plane_transformed_world = ghcomp.Transform(tool0_plane_transformed, self.T_W_R)\n        base_geo_world = ghcomp.Transform(self.base_geo, self.T_W_R)\n        \n        self.T_W_TOOL0 = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tool0_plane_transformed_world)\n        \n        if self.tool:\n            T = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, tool0_plane_transformed_world)\n            tool_geo_trfd_world = self.tool.get_transformed_geo_with_tool_transformation(T, tool_joint_values[0], tool_joint_values[1], extended = extended)\n            return [base_geo_world, link_geo_transformed_world, tool_geo_trfd_world] \n        else:\n            return [base_geo_world, link_geo_transformed_world]\n        \n        \n    def get_tool0_plane_from_joint_values(self, joint_values):\n        ''' the joint values (in degrees)'''\n        \n        # the angles in radians\n        joint_values = [m.radians(j) for j in joint_values]\n        a1, a2, a3, a4, a5, a6 = joint_values\n        \n        # calculate transformations\n        j1, j2, j3, j4, j5, j6 = [rg.Plane(jp) for jp in self.joint_planes]\n        \n        T1 = rg.Transform.Rotation(a1, j1.ZAxis, j1.Origin)\n        T2 = T1 * rg.Transform.Rotation(a2, j2.ZAxis, j2.Origin)\n        T3 = T2 * rg.Transform.Rotation(a3, j3.ZAxis, j3.Origin)\n        T4 = T3 * rg.Transform.Rotation(a4, j4.ZAxis, j4.Origin)\n        T5 = T4 * rg.Transform.Rotation(a5, j5.ZAxis, j5.Origin)\n        T6 = T5 * rg.Transform.Rotation(a6, j6.ZAxis, j6.Origin)\n        \n        tool0_plane_transformed = ghcomp.Transform(j6, T6)\n        \n        return tool0_plane_transformed\n    \n    def get_tool0_pose_from_joint_values(self, joint_values):\n        ''' the joint values (in degrees)'''\n        \n        frame = Frame(self.get_tool0_plane_from_joint_values(joint_values))\n        return frame.get_pose_quaternion()\n    \n    def get_tool0_plane_from_joint_values_world(self, joint_values):\n        ''' the joint values (in degrees)'''\n        \n        tool0_plane_transformed = self.get_tool0_plane_from_joint_values(joint_values)\n        tool0_plane_transformed_world = ghcomp.Transform(tool0_plane_transformed, self.T_W_R)\n        \n        return tool0_plane_transformed_world\n    \n    def get_tool0_pose_from_joint_values_world(self, joint_values):\n        ''' the joint values (in degrees)'''\n        \n        frame = Frame(self.get_tool0_plane_from_joint_values_world(joint_values))\n        return frame.get_pose_quaternion()\n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}