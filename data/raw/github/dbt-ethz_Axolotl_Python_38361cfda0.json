{
  "source_url": "https://github.com/dbt-ethz/Axolotl_Python/blob/0938046ecc5e50645d241a330b57734767958b07/_old_axolotl-1.0/code/primitives/lattice.py",
  "repo": "dbt-ethz/Axolotl_Python",
  "repo_stars": 59,
  "repo_description": "Volumetric Modelling components for Rhino Grasshopper.",
  "license": "unknown",
  "filepath": "_old_axolotl-1.0/code/primitives/lattice.py",
  "instruction": "Creates a spatial lattice truss in a predefined cube.\n    Inputs:\n        nx: The x-dimension of the original voxel space to fill\n        ny: The y-dimension of the original voxel space to fill\n     ...",
  "code": "#!/usr/bin/env python2\n# -*- coding: utf-8 -*-\n\n\"\"\"\nCreates a spatial lattice truss in a predefined cube.\n    Inputs:\n        nx: The x-dimension of the original voxel space to fill\n        ny: The y-dimension of the original voxel space to fill\n        nz: The z-dimension of the original voxel space to fill\n        n: The number of voxels along one side of the cube cell\n        r: The ratio between diameter and n (0 to 1)\n        mode: type of lattice (see code). more can easily be added as list of lists (point pair)\n    Output:\n        a: Distance values for all points in voxel space (nx, ny, nz)\n\"\"\"\n\n__author__     = ['Mathias Bernhard']\n__copyright__  = 'Copyright 2018 / Digital Building Technologies DBT / ETH Zurich'\n__license__    = 'MIT License'\n__email__      = '<bernhard@arch.ethz.ch>'\n\nimport rhinoscriptsyntax as rs\nimport Rhino.Geometry as rg\nimport math\n\nif nx==None:\n    nx = 30\nif ny==None:\n    ny = 30\nif nz==None:\n    nz = 30\nif n==None:\n    n=15\nif r==None:\n    r = 0.15\nif mode==None:\n    mode=0\nif mode<0 or mode>9:\n    mode=0\ndef dot(i,j,k,l,m,n):\n    return i*l + j*m + k*n\n\ndef get_dist(p,ls,le):\n    x = p.X\n    y = p.Y\n    z = p.Z\n\n    x1 = ls[0]\n    y1 = ls[1]\n    z1 = ls[2]\n\n    x2 = le[0]\n    y2 = le[1]\n    z2 = le[2]\n\n    vx = x2-x1\n    vy = y2-y1\n    vz = z2-z1\n    c2 =  dot(vx, vy, vz, vx, vy, vz)\n\n    dx = x - x1\n    dy = y - y1\n    dz = z - z1\n    c1 =  dot(dx, dy, dz, vx, vy, vz)\n\n    b = c1 / c2\n    px = x1 + b * vx\n    py = y1 + b * vy\n    pz = z1 + b * vz\n\n    d = math.sqrt((x-px)**2 + (y-py)**2 + (z-pz)**2)\n    return d - f\n\ndef get_index(x,y,z):\n    return x * nyz + y * nz + z\n\ndef get_local_ix(x,y,z):\n    return x*n**2 + y*n + z\n\nrx = int(nx/n)+1\nry = int(ny/n)+1\nrz = int(nz/n)+1\nnyz = ny*nz\n\nf = n*r/2\n\nv1 = 0.0\nv2 = 0.5 * n\nv3 = v2/2\n\nloc = [[]]*20\n\nloc[0] = [v1,v1,v1]\nloc[1] = [v2,v1,v1]\nloc[2] = [v2,v2,v1]\nloc[3] = [v1,v2,v1]\n\nloc[4] = [v1,v1,v2]\nloc[5] = [v2,v1,v2]\nloc[6] = [v2,v2,v2]\nloc[7] = [v1,v2,v2]\n\nloc[8]  = [v3,v1,v1]\nloc[9]  = [v2,v3,v1]\nloc[10] = [v3,v2,v1]\nloc[11] = [v1,v3,v1]\n\nloc[12] = [v1,v1,v3]\nloc[13] = [v2,v1,v3]\nloc[14] = [v2,v2,v3]\nloc[15] = [v1,v2,v3]\n\nloc[16] = [v3,v1,v2]\nloc[17] = [v2,v3,v2]\nloc[18] = [v3,v2,v2]\nloc[19] = [v1,v3,v2]\n\nbigx = [[loc[0],loc[6]]]\ngrid = [[loc[6],loc[2]],[loc[6],loc[5]],[loc[6],loc[7]]]\nstar = grid + bigx\ncross = [[loc[1],loc[6]],[loc[3],loc[6]],[loc[4],loc[6]]]\noctagon = [[loc[1],loc[3]],[loc[3],loc[4]],[loc[4],loc[1]]]\noctet = cross + octagon\nvintile = [[loc[8],loc[13]],[loc[13],loc[17]],[loc[17],loc[18]],[loc[18],loc[15]],[loc[15],loc[11]],[loc[11],loc[8]]]\ndual = [[loc[0],loc[1]],[loc[0],loc[3]],[loc[0],loc[4]]]\ninterlock = grid+dual\nisotrop = [[loc[0],loc[1]],[loc[2],loc[1]],[loc[5],loc[1]],[loc[7],loc[1]],[loc[3],loc[7]],[loc[6],loc[7]],[loc[4],loc[7]]]\n\nlines = grid\n\nif mode==0:\n    lines = octet\nelif mode==1:\n    lines = bigx\nelif mode==2:\n    lines = grid\nelif mode==3:\n    lines = star\nelif mode==4:\n    lines = cross\nelif mode==5:\n    lines = octagon\nelif mode==6:\n    lines = vintile\nelif mode==7:\n    lines = dual\nelif mode==8:\n    lines = interlock\nelif mode==9:\n    lines = isotrop\n\na = [9999] * (nx*ny*nz)\nb = [0]*(n**3)\n\noff = 0.5 + (n%2)*0.5\n\nnn = int(round(n/2.0))\nfor x in range(nn):\n    for y in range(nn):\n        for z in range(nn):\n            p = rg.Point3d(nn-x - off,nn-y - off,nn-z - off)\n            v = 99999\n            for l in lines:\n                v = min(v,get_dist(p,l[0],l[1]))\n            b[get_local_ix(x,y,z)] = v\n            b[get_local_ix(n-x-1,y,z)] = v\n            b[get_local_ix(x,n-y-1,z)] = v\n            b[get_local_ix(x,y,n-z-1)] = v\n            b[get_local_ix(n-x-1,n-y-1,z)] = v\n            b[get_local_ix(x,n-y-1,n-z-1)] = v\n            b[get_local_ix(n-x-1,y,n-z-1)] = v\n            b[get_local_ix(n-x-1,n-y-1,n-z-1)] = v\n\nfor i in range(rx):\n    for j in range(ry):\n        for k in range(rz):\n            #maybe try to replace these following 3 for loops with a clever slicing [:,xy]\n            for x in range(n):\n                for y in range(n):\n                    for z in range(n):\n                        ix = i*n+x\n                        iy = j*n+y\n                        iz = k*n+z\n                        if ix<nx and iy<ny and iz<nz:\n                            a[get_index(ix,iy,iz)] = b[get_local_ix(x,y,z)]\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}