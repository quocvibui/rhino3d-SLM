{
  "source_url": "https://github.com/liugehao/wiki/blob/4128502efd11ac254f301d262185dae627e11c88/MoinMoin/mail/mailimport.py",
  "repo": "liugehao/wiki",
  "repo_stars": 0,
  "repo_description": "my documents",
  "license": "unknown",
  "filepath": "MoinMoin/mail/mailimport.py",
  "instruction": "MoinMoin - E-Mail Import into wiki",
  "code": "\"\"\"\n    MoinMoin - E-Mail Import into wiki\n\n    Just call this script with the URL of the wiki as a single argument\n    and feed the mail into stdin.\n\n    @copyright: 2006 MoinMoin:AlexanderSchremmer,\n                2006 MoinMoin:ThomasWaldmann\n    @license: GNU GPL, see COPYING for details.\n\"\"\"\n\nimport sys, re, time\nimport email\nfrom email.Utils import getaddresses, parsedate_tz, mktime_tz\n\nfrom MoinMoin import wikiutil, user\nfrom MoinMoin.action.AttachFile import add_attachment, AttachmentAlreadyExists\nfrom MoinMoin.Page import Page\nfrom MoinMoin.PageEditor import PageEditor\n# python, at least up to 2.4, ships a broken parser for headers\nfrom MoinMoin.support.HeaderFixed import decode_header\n\ninfile = sys.stdin\n\ndebug = False\n\nre_sigstrip = re.compile(\"\\r?\\n-- \\r?\\n.*$\", re.S)\n\nclass attachment(object):\n    \"\"\" Represents an attachment of a mail. \"\"\"\n    def __init__(self, filename, mimetype, data):\n        self.filename = filename\n        self.mimetype = mimetype\n        self.data = data\n\n    def __repr__(self):\n        return \"<attachment filename=%r mimetype=%r size=%i bytes>\" % (\n            self.filename, self.mimetype, len(self.data))\n\nclass ProcessingError(Exception):\n    pass\n\ndef log(text):\n    if debug:\n        print >> sys.stderr, text\n\ndef decode_2044(header):\n    \"\"\" Decodes header field. See RFC 2044. \"\"\"\n    chunks = decode_header(header)\n    chunks_decoded = []\n    for i in chunks:\n        chunks_decoded.append(i[0].decode(i[1] or 'ascii'))\n    return u''.join(chunks_decoded).strip()\n\ndef email_to_markup(request, email):\n    \"\"\" transform the (realname, mailaddr) tuple we get in email argument to\n        some string usable as wiki markup, that represents that person (either\n        HomePage link for a wiki user, or just the realname of the person). \"\"\"\n    realname, mailaddr = email\n    u = user.get_by_email_address(request, mailaddr)\n    if u:\n        markup = u.wikiHomeLink()\n    else:\n        markup = realname or mailaddr\n    return markup\n\ndef get_addrs(message, header):\n    \"\"\" get a list of tuples (realname, mailaddr) from the specified header \"\"\"\n    dec_hdr = [decode_2044(hdr) for hdr in message.get_all(header, [])]\n    return getaddresses(dec_hdr)\n\ndef process_message(message):\n    \"\"\" Processes the read message and decodes attachments. \"\"\"\n    attachments = []\n    html_data = []\n    text_data = []\n\n    from_addr = get_addrs(message, 'From')[0]\n    to_addrs = get_addrs(message, 'To')\n    cc_addrs = get_addrs(message, 'Cc')\n    bcc_addrs = get_addrs(message, 'Bcc') # depending on sending MTA, this can be present or not\n    envelope_to_addrs = get_addrs(message, 'X-Original-To') + get_addrs(message, 'X-Envelope-To') # Postfix / Sendmail does this\n    target_addrs = to_addrs + cc_addrs + bcc_addrs + envelope_to_addrs\n\n    subject = decode_2044(message['Subject'])\n    date = time.strftime(\"%Y-%m-%dT%H:%M:%S\", time.gmtime(mktime_tz(parsedate_tz(message['Date']))))\n\n    log(\"Processing mail:\\n To: %r\\n From: %r\\n Subject: %r\" % (to_addrs[0], from_addr, subject))\n\n    for part in message.walk():\n        log(\" Part \" + repr((part.get_charsets(), part.get_content_charset(), part.get_content_type(), part.is_multipart(), )))\n        ct = part.get_content_type()\n        cs = part.get_content_charset() or \"latin1\"\n        payload = part.get_payload(None, True)\n\n        fn = part.get_filename()\n        if fn is not None and fn.startswith(\"=?\"): # heuristics ...\n            fn = decode_2044(fn)\n\n        if fn is None and part[\"Content-Disposition\"] is not None and \"attachment\" in part[\"Content-Disposition\"]:\n            # this doesn't catch the case where there is no content-disposition but there is a file to offer to the user\n            # i hope that this can be only found in mails that are older than 10 years,\n            # so I won't care about it here\n            fn = part[\"Content-Description\"] or \"NoName\"\n        if fn:\n            a = attachment(fn, ct, payload)\n            attachments.append(a)\n        else:\n            if ct == 'text/plain':\n                text_data.append(payload.decode(cs))\n                log(repr(payload.decode(cs)))\n            elif ct == 'text/html':\n                html_data.append(payload.decode(cs))\n            elif not part.is_multipart():\n                log(\"Unknown mail part \" + repr((part.get_charsets(), part.get_content_charset(), part.get_content_type(), part.is_multipart(), )))\n\n    return {'text': u\"\".join(text_data), 'html': u\"\".join(html_data),\n            'attachments': attachments,\n            'target_addrs': target_addrs,\n            'to_addrs': to_addrs, 'cc_addrs': cc_addrs, 'bcc_addrs': bcc_addrs, 'envelope_to_addrs': envelope_to_addrs,\n            'from_addr': from_addr,\n            'subject': subject, 'date': date}\n\ndef get_pagename_content(request, msg):\n    \"\"\" Generates pagename and content according to the specification\n        that can be found on MoinMoin:FeatureRequests/WikiEmailintegration \"\"\"\n    generate_summary = False\n    choose_html = True\n\n    cfg = request.cfg\n    email_subpage_template = cfg.mail_import_subpage_template\n    email_pagename_envelope = cfg.mail_import_pagename_envelope\n    wiki_addrs = cfg.mail_import_wiki_addrs\n    search_list = cfg.mail_import_pagename_search\n    re_subject = re.compile(cfg.mail_import_pagename_regex)\n\n    subj = msg['subject'].strip()\n    pagename_tpl = \"\"\n    for method in search_list:\n        if method == 'to':\n            for addr in msg['target_addrs']:\n                if addr[1].strip().lower() in wiki_addrs:\n                    pagename_tpl = addr[0]\n                    # special fix for outlook users :-)\n                    if pagename_tpl and pagename_tpl[-1] == pagename_tpl[0] == \"'\":\n                        pagename_tpl = pagename_tpl[1:-1]\n                    if pagename_tpl:\n                        break\n        elif method == 'subject':\n            m = re_subject.search(subj)\n            if m:\n                pagename_tpl = m.group(1)\n                # remove the pagename template from the subject:\n                subj = re_subject.sub('', subj, 1).strip()\n        if pagename_tpl:\n            break\n\n    pagename_tpl = pagename_tpl.strip()\n    # last resort\n    if not pagename_tpl:\n        pagename_tpl = email_subpage_template\n\n    if not subj:\n        subj = '(...)' # we need non-empty subject\n    msg['subject'] = subj\n\n    # for normal use, email_pagename_envelope is just u\"%s\" - so nothing changes.\n    # for special use, you can use u\"+ %s/\" - so you don't need to enter \"+\"\n    # and \"/\" in every email, but you get the result as if you did.\n    pagename_tpl = email_pagename_envelope % pagename_tpl\n\n    if pagename_tpl.endswith(\"/\"):\n        pagename_tpl += email_subpage_template\n\n    subject = msg['subject'].replace('/', '\\\\') # we can't use / in pagenames\n\n    # rewrite using string.formatter when python 2.4 is mandatory\n    pagename = (pagename_tpl.replace(\"$from\", msg['from_addr'][0]).\n                replace(\"$date\", msg['date']).\n                replace(\"$subject\", subject))\n\n    if pagename.startswith(\"+ \") and \"/\" in pagename:\n        generate_summary = True\n        pagename = pagename[1:].lstrip()\n\n    pagename = wikiutil.normalize_pagename(pagename, request.cfg)\n\n    if choose_html and msg['html']:\n        content = \"{{{#!html\\n%s\\n}}}\" % msg['html'].replace(\"}}}\", \"} } }\")\n    else:\n        # strip signatures ...\n        content = re_sigstrip.sub(\"\", msg['text'])\n\n    return {'pagename': pagename, 'content': content, 'generate_summary': generate_summary}\n\ndef import_mail_from_string(request, string):\n    \"\"\" Reads an RFC 822 compliant message from a string and imports it\n        to the wiki. \"\"\"\n    return import_mail_from_message(request, email.message_from_string(string))\n\ndef import_mail_from_file(request, infile):\n    \"\"\" Reads an RFC 822 compliant message from the file `infile` and imports it to\n        the wiki. \"\"\"\n    return import_mail_from_message(request, email.message_from_file(infile))\n\ndef import_mail_from_message(request, message):\n    \"\"\" Reads a message generated by the email package and imports it\n        to the wiki. \"\"\"\n    _ = request.getText\n    msg = process_message(message)\n\n    wiki_addrs = request.cfg.mail_import_wiki_addrs\n\n    request.user = user.get_by_email_address(request, msg['from_addr'][1])\n\n    if not request.user:\n        raise ProcessingError(\"No suitable user found for mail address %r\" % (msg['from_addr'][1], ))\n\n    d = get_pagename_content(request, msg)\n    pagename = d['pagename']\n    generate_summary = d['generate_summary']\n\n    comment = u\"Mail: '%s'\" % (msg['subject'], )\n\n    page = PageEditor(request, pagename, do_editor_backup=0)\n\n    if not request.user.may.save(page, \"\", 0):\n        raise ProcessingError(\"Access denied for page %r\" % pagename)\n\n    attachments = []\n\n    for att in msg['attachments']:\n        i = 0\n        while i < 1000: # do not create a gazillion attachments if something\n                        # strange happens, give up after 1000.\n            if i == 0:\n                fname = att.filename\n            else:\n                components = att.filename.split(\".\")\n                new_suffix = \"-\" + str(i)\n                # add the counter before the file extension\n                if len(components) > 1:\n                    fname = u\"%s%s.%s\" % (u\".\".join(components[:-1]), new_suffix, components[-1])\n                else:\n                    fname = att.filename + new_suffix\n            try:\n                # att.data can be None for forwarded message content - we can\n                # just ignore it, the forwarded message's text will be present\n                # nevertheless\n                if att.data is not None:\n                    # get the fname again, it might have changed\n                    fname, fsize = add_attachment(request, pagename, fname, att.data)\n                    attachments.append(fname)\n                break\n            except AttachmentAlreadyExists:\n                i += 1\n\n    # build an attachment link table for the page with the e-mail\n    attachment_links = [\"\"] + [u'''[[attachment:%s|%s]]''' % (\"%s/%s\" % (pagename, att), att) for att in attachments]\n\n    # assemble old page content and new mail body together\n    old_content = Page(request, pagename).get_raw_body()\n    if old_content:\n        new_content = u\"%s\\n-----\\n\" % old_content\n    else:\n        new_content = ''\n\n    #if not (generate_summary and \"/\" in pagename):\n    #generate header in any case:\n    new_content += u\"'''Mail: %s (%s, <<DateTime(%s)>>)'''\\n\\n\" % (msg['subject'], email_to_markup(request, msg['from_addr']), msg['date'])\n\n    new_content += d['content']\n    new_content += \"\\n\" + u\"\\n * \".join(attachment_links)\n\n    try:\n        page.saveText(new_content, 0, comment=comment)\n    except page.AccessDenied:\n        raise ProcessingError(\"Access denied for page %r\" % pagename)\n\n    if generate_summary and \"/\" in pagename:\n        parent_page = u\"/\".join(pagename.split(\"/\")[:-1])\n        old_content = Page(request, parent_page).get_raw_body().splitlines()\n\n        found_table = None\n        table_ends = None\n        for lineno, line in enumerate(old_content):\n            if line.startswith(\"## mail_overview\") and old_content[lineno+1].startswith(\"||\"):\n                found_table = lineno\n            elif found_table is not None and line.startswith(\"||\"):\n                table_ends = lineno + 1\n            elif table_ends is not None and not line.startswith(\"||\"):\n                break\n\n        # in order to let the gettext system recognise the <<GetText>> calls used below,\n        # we must repeat them here:\n        [_(\"Date\"), _(\"From\"), _(\"To\"), _(\"Content\"), _(\"Attachments\")]\n\n        table_header = (u\"\\n\\n## mail_overview (don't delete this line)\\n\" +\n                        u\"|| '''<<GetText(Date)>> ''' || '''<<GetText(From)>> ''' || '''<<GetText(To)>> ''' || '''<<GetText(Content)>> ''' || '''<<GetText(Attachments)>> ''' ||\\n\"\n                       )\n\n        from_col = email_to_markup(request, msg['from_addr'])\n        to_col = ' '.join([email_to_markup(request, (realname, mailaddr))\n                           for realname, mailaddr in msg['target_addrs'] if not mailaddr in wiki_addrs])\n        subj_col = '[[%s|%s]]' % (pagename, msg['subject'])\n        date_col = msg['date']\n        attach_col = \" \".join(attachment_links)\n        new_line = u'|| <<DateTime(%s)>> || %s || %s || %s || %s ||' % (date_col, from_col, to_col, subj_col, attach_col)\n        if found_table is not None:\n            content = \"\\n\".join(old_content[:table_ends] + [new_line] + old_content[table_ends:])\n        else:\n            content = \"\\n\".join(old_content) + table_header + new_line\n\n        page = PageEditor(request, parent_page, do_editor_backup=0)\n        page.saveText(content, 0, comment=comment)\n\nif __name__ == \"__main__\":\n    if len(sys.argv) > 1:\n        request_url = sys.argv[1]\n    else:\n        request_url = None\n\n    from MoinMoin.web.contexts import ScriptContext\n    request = ScriptContext(url=request_url)\n\n    try:\n        import_mail_from_file(request, infile)\n    except ProcessingError, e:\n        print >> sys.stderr, \"An error occurred while processing the message:\", e.args\n\n",
  "language": "python",
  "imports": [],
  "has_docstring": true
}