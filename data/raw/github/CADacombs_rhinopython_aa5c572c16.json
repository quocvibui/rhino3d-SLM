{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_convertSurfaceToNurbs.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_convertSurfaceToNurbs.py",
  "instruction": "This script is an alternative to _ToNURBS, which has problems with some RevSurfaces.\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums,...",
  "code": "\"\"\"\r\nThis script is an alternative to _ToNURBS, which has problems with some RevSurfaces.\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums, https://discourse.mcneel.com/\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n180206-07: Created, starting with fitSurface.py\r\n...\r\n190519: Updated an import name.\r\n200207: Now accepts BrepFaces.  Refactored.  Removed reporting routine.\r\n200414: Added bAcceptParamMismatch and now uses an external module to trim the face.\r\n200422: Now, doesn't attempt to trim closed surfaces from closed monoface breps.\r\n200428: Bug fix.\r\n200527, 0619: Import-related update.\r\n231108: Improved some debug reporting.\r\n250326: Bug fix for processing individual faces of a polysrf. Refactored.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\n\r\nimport xBrepFace\r\nimport xBrepObject\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    riAddOpts = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    def addOptionDouble(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionDouble(\r\n            getObj, englishName=names[key], numberValue=riOpts[key])\r\n\r\n\r\n    def addOptionInteger(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionInteger(\r\n            getObj, englishName=names[key], intValue=riOpts[key])\r\n\r\n\r\n    def addOptionList(key, names, listValues, values):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionList(\r\n            getObj,\r\n            englishOptionName=names[key],\r\n            listValues=listValues,\r\n            listCurrentIndex=values[key])\r\n\r\n\r\n    def addOptionToggle(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionToggle(\r\n            getObj, englishName=names[key], toggleValue=riOpts[key])\r\n\r\n\r\n    key = 'fTol'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    names[key] = 'Tolerance'\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    riAddOpts[key] = addOptionDouble(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bAcceptParamMismatch'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bReplace'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'Action'\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='Add', onValue='Replace')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.keys:\r\n            if key in cls.riOpts:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n\r\n\r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if key in cls.riOpts:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get surfaces and/or breps and option values.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select breps and/or faces\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Brep\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Keep objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False)\r\n\r\n    go.AcceptNumber(enable=True, acceptZero=True)\r\n\r\n    idxs_Opts = {}\r\n\r\n\r\n    while True:\r\n        key = 'fTol'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bAcceptParamMismatch'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bReplace'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bEcho'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bDebug'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n        \r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return tuple([objrefs] + [Opts.values[key] for key in Opts.keys])\r\n\r\n        # An option was selected or a number was entered.\r\n        \r\n        key = 'fTol'\r\n        if res == ri.GetResult.Number:\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n        if Opts.riOpts[key].CurrentValue < 0.0:\r\n            Opts.riOpts[key].CurrentValue = Opts.riOpts[key].InitialValue\r\n\r\n        Opts.setValues()\r\n        Opts.saveSticky()\r\n        go.ClearCommandOptions()\r\n\r\n\r\ndef processBrepObjects(rhBreps, idxFaces_perBrep, **kwargs):\r\n    \"\"\"\r\n    rhBreps: Can be rd.BrepObjects or GUIDs,\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fTol = getOpt('fTol')\r\n    bAcceptParamMismatch = getOpt('bAcceptParamMismatch')\r\n    bReplace = getOpt('bReplace')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    def getBrep(rhBrep):\r\n        if isinstance(rhBrep, rg.Brep):\r\n            return None, rhBrep\r\n        elif isinstance(rhBrep, rg.GeometryBase):\r\n            rdObj = None\r\n            rgObj = rhBrep\r\n        elif isinstance(rhBrep, rd.ObjRef):\r\n            rdObj = rhBrep.Object()\r\n            rgObj = rhBrep.Geometry()\r\n        elif isinstance(rhBrep, Guid):\r\n            rdObj = sc.doc.Objects.FindId(rhBrep) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhBrep)\r\n            rgObj = rdObj.Geometry\r\n        else:\r\n            return\r\n\r\n        if isinstance(rgObj, (rg.Brep, rg.BrepFace)):\r\n            return rdObj, rgObj\r\n\r\n\r\n    def areAllBrepTrimIsostatusesSENW(rgFace0):\r\n        if rgFace0.IsSurface: return True\r\n        iCt_Trims = 0\r\n        for rgTrim_ in rgFace0.Brep.Trims:\r\n            if rgTrim_.Face.FaceIndex == rgFace0.FaceIndex:\r\n                if rgTrim_.IsoStatus == rg.IsoStatus.None:\r\n                    return False\r\n                elif rgTrim_.IsoStatus == rg.IsoStatus.X:\r\n                    return False\r\n                elif rgTrim_.IsoStatus == rg.IsoStatus.Y:\r\n                    return False\r\n                iCt_Trims += 1\r\n        if iCt_Trims != 4:\r\n            return False\r\n        return True\r\n\r\n\r\n    iFs_perB = idxFaces_perBrep\r\n\r\n\r\n    bNon1AccuracyProduced = False\r\n\r\n    gBs_Out = []\r\n    iCt_Fs_Success = 0\r\n    sLogs = []\r\n\r\n    for iB in range(len(rhBreps)):\r\n        rhB = rhBreps[iB]\r\n        rc = getBrep(rhB)\r\n        if not rc: continue\r\n        rdB_In, rgB_In = rc\r\n        if iFs_perB is None or iFs_perB[iB] is None:\r\n            iFs = range(rgB_In.Faces.Count)\r\n        else:\r\n            iFs = iFs_perB[iB]\r\n\r\n        iFs_Processed = []\r\n        rgBs_1Fs_NewGeom = []\r\n\r\n        for iF in iFs:\r\n            rgSrf_In = rgB_In.Faces[iF].UnderlyingSurface()\r\n            if isinstance(rgSrf_In, rg.NurbsSurface):\r\n                continue\r\n\r\n            rgNSrf, iAccuracy = rgSrf_In.ToNurbsSurface(tolerance=fTol)\r\n            if rgNSrf is None:\r\n                continue\r\n\r\n            # accuracy result per https://developer.rhino3d.com/api/RhinoCommon/html/M_Rhino_Geometry_Surface_ToNurbsSurface_1.htm\r\n            if bDebug:\r\n                print(\"accuracy set (out parameter) by ToNurbsSurface: {}\".format(iAccuracy))\r\n                if iAccuracy == 0:\r\n                    print(\"0 = unable to create NURBS representation with desired accuracy.\")\r\n                elif iAccuracy == 1:\r\n                    print(\"1 = success - returned NURBS parameterization matches the surface's to the desired accuracy.\")\r\n                elif iAccuracy == 2:\r\n                    print(\"2 = success - returned NURBS point locus matches the surface's to the desired accuracy and the domain of the NURBS surface is correct. However, this surface's parameterization and the NURBS surface parameterization may not match to the desired accuracy. This situation happens when getting NURBS representations of surfaces that have a transendental parameterization like spheres, cylinders, and cones.\")\r\n                else:\r\n                    raise ValueError(\"What happened?\")\r\n\r\n            if iAccuracy == 1:\r\n                if rgB_In.Faces.Count == 1 and rgB_In.IsSolid:\r\n                    rgB_1F_Out = rgNSrf.ToBrep()\r\n                    rgBs_1Fs_NewGeom.append(rgB_1F_Out)\r\n                    iFs_Processed.append(iF)\r\n                elif rgB_In.Faces.Count == 1 and rgB_In.Faces[iF].IsSurface:\r\n                    rgB_1F_Out = rgNSrf.ToBrep()\r\n                    rgBs_1Fs_NewGeom.append(rgB_1F_Out)\r\n                    iFs_Processed.append(iF)\r\n                elif rgB_In.Faces.Count == 1 and areAllBrepTrimIsostatusesSENW(rgB_In.Faces[iF]):\r\n                    rgB_1F_Out = rgNSrf.ToBrep()\r\n                    rgBs_1Fs_NewGeom.append(rgB_1F_Out)\r\n                    iFs_Processed.append(iF)\r\n                else:\r\n                    rgB_1F_WIP = rgB_In.Faces[iF].DuplicateFace(duplicateMeshes=False)\r\n                    \r\n                    rgB_1F_WIP.AddSurface(rgNSrf)\r\n    \r\n                    rgNSrf.Dispose()\r\n                    if not rgB_1F_WIP.Faces[0].ChangeSurface(1):\r\n                        print(\"Brep.ChangeSurface failed.\")\r\n                    else:\r\n                        rgB_1F_WIP.Compact()\r\n    \r\n                        rgBs_1Fs_NewGeom.append(rgB_1F_WIP)\r\n                        iFs_Processed.append(iF)\r\n            elif iAccuracy == 2 and bAcceptParamMismatch:\r\n                \r\n                if rgB_In.Faces.Count == 1 and rgB_In.IsSolid:\r\n                    rgB_1F_Out = rgNSrf.ToBrep()\r\n                    rgBs_1Fs_NewGeom.append(rgB_1F_Out)\r\n                    iFs_Processed.append(iF)\r\n                elif rgB_In.Faces.Count == 1 and rgB_In.Faces[iF].IsSurface:\r\n                    rgB_1F_Out = rgNSrf.ToBrep()\r\n                    rgBs_1Fs_NewGeom.append(rgB_1F_Out)\r\n                    iFs_Processed.append(iF)\r\n                elif rgB_In.Faces.Count == 1 and areAllBrepTrimIsostatusesSENW(rgB_In.Faces[iF]):\r\n                    rgB_1F_Out = rgNSrf.ToBrep()\r\n                    rgBs_1Fs_NewGeom.append(rgB_1F_Out)\r\n                    iFs_Processed.append(iF)\r\n                else:\r\n                    rgB_1F_WIP_Retrimmed = xBrepFace.retrimFace(\r\n                        rgB_In.Faces[iF],\r\n                        rgSrf_Replacement=rgNSrf,\r\n                        bDebug=bDebug\r\n                        )\r\n\r\n                    rgNSrf.Dispose()\r\n\r\n                    if not rgB_1F_WIP_Retrimmed:\r\n                        rgB_In.Dispose()\r\n                        continue\r\n\r\n                    rgBs_1Fs_NewGeom.append(rgB_1F_WIP_Retrimmed)\r\n                    iFs_Processed.append(iF)\r\n            else:\r\n                if iAccuracy == 0:\r\n                    sLogs.append(\r\n                        \"unable to create NURBS representation with desired accuracy.\")\r\n                    #sc.doc.Objects.AddSurface(rgSrf_In)\r\n                elif iAccuracy == 2:\r\n                    sLogs.append(\r\n                        \"this surface's parameterization and the NURBS surface parameterization may not match to the desired accuracy.\" \\\r\n                            \"  This situation happens when getting NURBS representations of surfaces that have a transendental parameterization like spheres, cylinders, and cones.\")\r\n                    #sc.doc.Objects.AddSurface(rgSrf_In)\r\n\r\n                if not bNon1AccuracyProduced:\r\n                    s  = \"For Accuracy level, see \"\r\n                    s += \"http://developer.rhino3d.com/api/RhinoCommon/html/M_Rhino_Geometry_Surface_ToNurbsSurface_1.htm\"\r\n                    print(s)\r\n                    bNon1AccuracyProduced = True\r\n\r\n\r\n        if not iFs_Processed:\r\n            rgB_In.Dispose()\r\n            continue\r\n\r\n\r\n        if bReplace:\r\n            rc = xBrepObject.replaceFaces(\r\n                rdB_In, iFs_Processed, rgBs_1Fs_NewGeom,\r\n                bExtract=False,\r\n                )\r\n            if not rc: continue\r\n            gBs_Out.extend(rc)\r\n            iCt_Fs_Success += len(iFs_Processed)\r\n        else:\r\n            for iB in range(len(rgBs_1Fs_NewGeom)):\r\n                gB_Out = sc.doc.Objects.AddBrep(rgBs_1Fs_NewGeom[iB])\r\n                if gB_Out == Guid.Empty: continue\r\n                gBs_Out.append(rc)\r\n                iCt_Fs_Success += 1\r\n\r\n\r\n    if sLogs:\r\n        for sLog in set(sLogs):\r\n            print(\"[{}] {}\".format(sLogs.count(sLog), sLog))\r\n\r\n\r\n    print(\"{} faces {}.\".format(\r\n        iCt_Fs_Success,\r\n        \"replaced\" if bReplace else \"added\"))\r\n\r\n    return gBs_Out\r\n\r\n\r\ndef processObjRefs(objrefs, **kwargs):\r\n    \"\"\"\r\n    objrefs\r\n    \"\"\"\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fTol = getOpt('fTol')\r\n    bAcceptParamMismatch = getOpt('bAcceptParamMismatch')\r\n    bReplace = getOpt('bReplace')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    if not all([isinstance(objref, rd.ObjRef) for objref in objrefs]):\r\n        print(\"Only input ObjRefs. Script canceled.\")\r\n        return\r\n\r\n\r\n    def sortBrepObjects_and_face_indices(objrefs):\r\n        gBs = []; iFs_perB = []\r\n    \r\n        for objref in objrefs:\r\n            if objref.Object().ObjectType != rd.ObjectType.Brep: continue\r\n\r\n            if objref.GeometryComponentIndex.Index == -1:\r\n                if objref.ObjectId in gBs:\r\n                    iB = gBs.index(objref.ObjectId)\r\n                    iFs_perB[iB] = None\r\n                else:\r\n                    gBs.append(objref.ObjectId)\r\n                    iFs_perB.append(None)\r\n            elif (\r\n                objref.GeometryComponentIndex.ComponentIndexType ==\r\n                rg.ComponentIndexType.BrepFace\r\n            ):\r\n                if objref.ObjectId in gBs:\r\n                    iB = gBs.index(objref.ObjectId)\r\n                    if iFs_perB[iB] is None:\r\n                        pass\r\n                    else:\r\n                        iFs_perB[iB].append(objref.GeometryComponentIndex.Index)\r\n                else:\r\n                    gBs.append(objref.ObjectId)\r\n                    iFs_perB.append([objref.GeometryComponentIndex.Index])\r\n\r\n\r\n        iFs_perB_Sorted = []\r\n        for iFs in iFs_perB:\r\n            if iFs is None:\r\n                iFs_perB_Sorted.append(None)\r\n            else:\r\n                iFs_perB_Sorted.append(sorted(iFs))\r\n\r\n        return gBs, iFs_perB_Sorted\r\n\r\n\r\n    rdBreps, idxFaces_perBrep = sortBrepObjects_and_face_indices(objrefs)\r\n\r\n    return processBrepObjects(\r\n        rhBreps=rdBreps, idxFaces_perBrep=idxFaces_perBrep)\r\n\r\n\r\ndef main(bDebug=False):\r\n    \r\n    rc = getInput()\r\n    if rc is None: return\r\n\r\n    objrefs = rc[0]\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if bDebug:\r\n        pass\r\n    else:\r\n        sc.doc.Views.RedrawEnabled = False\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\r\n\r\n    rc = processObjRefs(\r\n        objrefs=objrefs)\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main(bDebug=bool(0))",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": true
}