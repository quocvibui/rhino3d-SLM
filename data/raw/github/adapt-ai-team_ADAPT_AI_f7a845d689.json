{
  "source_url": "https://github.com/adapt-ai-team/ADAPT_AI/blob/5de8b42c4f4d4ad35cbd8e79588fc6e869398bc4/spz_analysis2/solar_radiation_.py",
  "repo": "adapt-ai-team/ADAPT_AI",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "spz_analysis2/solar_radiation_.py",
  "instruction": "Solar radiation",
  "code": "import os\nimport json\nimport numpy as np\nimport rhino3dm\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nfrom ladybug.epw import EPW\nfrom ladybug.sunpath import Sunpath\nfrom pygltflib import GLTF2, Scene, Node, Mesh, Buffer, BufferView, Accessor, Asset, Primitive, Material\n\n# üìÇ Define file paths\nEPW_FILE_PATH = os.path.join(os.getcwd(), \"newyork.epw\")\nRESULTS_FILE = os.path.join(os.getcwd(), \"solar_results.json\")\nGLB_FILE_PATH = os.path.join(os.getcwd(), \"solar_radiation.glb\")\nTHREEDM_FILE_PATH = os.path.join(os.getcwd(), \"newyork.3dm\")\n\n# ‚úÖ Load EPW weather data\ndef load_epw(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"‚ùå EPW file not found: {file_path}\")\n    return EPW(file_path)\n\n# ‚òÄÔ∏è Generate sun vectors\ndef get_sun_vectors(epw):\n    sunpath = Sunpath.from_location(epw.location)\n    return [sunpath.calculate_sun(6, 21, h).sun_vector for h in range(8, 15, 1)]\n\n# üè¢ Extract surfaces from 3DM file\ndef extract_surfaces_from_3dm(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"‚ùå 3DM file not found: {file_path}\")\n\n    model = rhino3dm.File3dm.Read(file_path)\n    return [obj.Geometry for obj in model.Objects if isinstance(obj.Geometry, rhino3dm.Mesh)]\n\n# üîÜ Compute Solar Radiation\ndef compute_solar_radiation(epw, surfaces):\n    sun_vectors = get_sun_vectors(epw)\n    all_radiation_values = []\n    \n    for i, surface in enumerate(surfaces):\n        normals = [surface.Normals[j] for j in range(len(surface.Vertices))] if len(surface.Normals) > 0 else [rhino3dm.Vector3d(0, 0, 1)]\n\n        solar_exposure = [\n            max(0, np.dot([normals[0].X, normals[0].Y, normals[0].Z], [sun_vec.x, sun_vec.y, sun_vec.z]))\n            for sun_vec in sun_vectors\n        ]\n        direct_radiation = [epw.direct_normal_radiation[hour % 24] for hour in range(6, 18)]\n        max_radiation = max(direct_radiation) if max(direct_radiation) > 0 else 1\n\n        normalized_exposure = [(solar / max_radiation) * rad for solar, rad in zip(solar_exposure, direct_radiation)]\n        all_radiation_values.append(normalized_exposure)\n\n    min_value = min(map(min, all_radiation_values))\n    max_value = max(map(max, all_radiation_values))\n\n    normalized_radiation_values = [[(value - min_value) / (max_value - min_value) if max_value != min_value else 1.0 for value in radiation] for radiation in all_radiation_values]\n\n    with open(RESULTS_FILE, \"w\") as f:\n        json.dump(normalized_radiation_values, f, indent=4)\n\n    save_multiple_meshes_to_glb(surfaces, normalized_radiation_values, GLB_FILE_PATH)\n\n# üé≠ Save a Mesh with Color Data to GLB\ndef save_multiple_meshes_to_glb(surfaces, radiation_values, filename):\n    all_vertices, all_faces, all_colors = [], [], []\n    vertex_offset = 0\n    colormap = plt.colormaps.get_cmap('viridis')\n\n    for i, surface in enumerate(surfaces):\n        vertices = np.array([[pt.X, pt.Y, pt.Z] for pt in surface.Vertices], dtype=np.float32)\n        faces = np.array([[f[0], f[1], f[2]] for f in surface.Faces], dtype=np.uint32) + vertex_offset\n        vertex_offset += len(vertices)\n\n        # Calculate face-based colors (instead of per-vertex)\n        face_colors = np.zeros((len(faces), 4), dtype=np.float32)\n        for j, face in enumerate(faces):\n            face_avg_radiation = np.mean([radiation_values[i][v % len(radiation_values[i])] for v in face])  # Compute avg radiation for face\n            mapped_color = colormap(face_avg_radiation)  # Map to colormap\n            face_colors[j] = mapped_color  # Assign color\n\n        all_vertices.append(vertices)\n        all_faces.append(faces)\n        all_colors.append(face_colors)\n\n    save_mesh_to_glb(np.vstack(all_vertices), np.vstack(all_faces), np.vstack(all_colors), filename)\n\n# üé≠ Save a Mesh to GLB\ndef save_mesh_to_glb(vertices, faces, colors, filename):\n    gltf = GLTF2(asset=Asset(version=\"2.0\"))\n    buffer_data = vertices.tobytes() + faces.tobytes() + colors.tobytes()\n    \n    gltf.buffers.append(Buffer(uri=None, byteLength=len(buffer_data)))\n\n    buffer_views = [\n        BufferView(buffer=0, byteOffset=0, byteLength=vertices.nbytes, target=34962),\n        BufferView(buffer=0, byteOffset=vertices.nbytes, byteLength=faces.nbytes, target=34963),\n        BufferView(buffer=0, byteOffset=vertices.nbytes + faces.nbytes, byteLength=colors.nbytes, target=34962),\n    ]\n    \n    gltf.bufferViews.extend(buffer_views)\n\n    gltf.accessors.extend([\n        Accessor(bufferView=0, componentType=5126, count=len(vertices), type=\"VEC3\"),\n        Accessor(bufferView=1, componentType=5125, count=len(faces) * 3, type=\"SCALAR\"),\n        Accessor(bufferView=2, componentType=5126, count=len(colors), type=\"VEC4\"),\n    ])\n\n    gltf.materials.append(Material(\n        pbrMetallicRoughness={\"baseColorFactor\": [1.0, 1.0, 1.0, 1.0]},\n        doubleSided=True\n    ))\n\n    gltf.meshes.append(Mesh(primitives=[Primitive(attributes={\"POSITION\": 0, \"COLOR_0\": 2}, indices=1, material=0)]))\n    gltf.nodes.append(Node(mesh=0))\n    gltf.scenes.append(Scene(nodes=[0]))\n    gltf.scene = 0\n\n    gltf.set_binary_blob(buffer_data)\n    gltf.save_binary(filename)\n\n    print(f\"‚úÖ Successfully saved {filename}\")\n\n# üöÄ Run Analysis\nif __name__ == \"__main__\":\n    try:\n        epw_data = load_epw(EPW_FILE_PATH)\n        surfaces = extract_surfaces_from_3dm(THREEDM_FILE_PATH)\n        compute_solar_radiation(epw_data, surfaces)\n    except Exception as e:\n        print(f\"‚ùå Error: {e}\")\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}