{
  "source_url": "https://github.com/le-ar-n/le-ar-n/blob/64600ee3bbe7e42f87f28442923b216cc565cf24/code/02_geometry/libraries/algorithms/mycelium/myceliumGH.py",
  "repo": "le-ar-n/le-ar-n",
  "repo_stars": 9,
  "repo_description": null,
  "license": "unknown",
  "filepath": "code/02_geometry/libraries/algorithms/mycelium/myceliumGH.py",
  "instruction": ". . . . . . . . . . . . . . . . . . . . . \n.                                       .\n.    <<      ><      ><       >< <<     .\n.    < ><   ><<     ><<<    ><    ><<   .\n.    << >< > ><    ><  ><    ...",
  "code": "'''\n. . . . . . . . . . . . . . . . . . . . . \n.                                       .\n.    <<      ><      ><       >< <<     .\n.    < ><   ><<     ><<<    ><    ><<   .\n.    << >< > ><    ><  ><     ><        .  \n.    <<  ><  ><   ><<<<<><      ><      .\n.    <<      >< ><<     ><< ><    ><<   .\n.    <<      ><><<       ><<  >< <<     .\n.                                       .\n.             DFAB 2016/17              .\n. . . . . . . . . . . . . . . . . . . . . \n\nCreated on 04.10.2016\n\n@author: kathrind\n\nhttp://www.creativeapplications.net/processing/mycelium-processing/\n\n'''\n\nimport math\nimport random as rnd\nimport ghpythonlib.components as ghcomp\nimport Rhino.Geometry as rg\nfrom libraries.useful import clamp, map_range\nfrom libraries.useful.color import convert_rgb_to_grey\n\n\n#===============================================================================\nclass MyceliumGH:\n    \n    def __init__(self, image_file, number_of_worms, scale_factor = 1, speed = 10, branch_thresh = 1000, max_worms = 100, thresh_worm = 30, favour=\"light\"):\n        \n        self.load_image(image_file)\n        self.scale(scale_factor)\n        \n        self.max_worms = max_worms # maximum number of worms\n     \n        # controls when a worm will branch\n        self.branch_thresh = branch_thresh\n        self.thresh_worm = thresh_worm\n        self.speed = speed\n        \n        self.init_worms(number_of_worms)\n        \n        self.dead_worms = []\n        self.just_branched = 0\n        self.favour = favour\n        \n        self.looking_angle = math.pi/12\n        \n    def load_image(self, image_file):\n        self.cmesh = ghcomp.ImportImage(image_file)\n        bb = self.cmesh.GetBoundingBox(rg.Plane.WorldXY)\n        self.width = bb.Max.X\n        self.height = bb.Max.Y\n        self.point_cloud = rg.PointCloud(self.cmesh.Vertices.ToPoint3dArray())\n    \n    def get_grey_value(self, x, y):\n        point = rg.Point3d(x, y, 0)\n        color_rgb = self.cmesh.VertexColors[self.point_cloud.ClosestPoint(point)]\n        grey = convert_rgb_to_grey(color_rgb.R, color_rgb.G, color_rgb.B)\n        grey = clamp(grey, 0, 255)\n        return grey\n    \n    def get_score_from_grey_value(self, x, y):\n        grey = self.get_grey_value(x,y)\n        ts = 4 * grey\n        return {'grey': grey, 'score': ts}\n    \n    def scale(self, factor):\n        S = rg.Transform.Scale(rg.Plane.WorldXY, factor, factor, factor)\n        self.cmesh.Transform(S)\n        self.point_cloud.Transform(S)\n        self.width *= factor\n        self.height *= factor\n     \n    def init_worms(self, number_of_worms):\n        \n        self.worms = []\n        \n        \"\"\"\n        for i in range(number_of_worms):\n            tx = math.floor(rnd.random() * self.width)\n            ty = math.floor(rnd.random() * self.height)\n            angle = rnd.random() * 2 * math.pi\n            worm = Worm(tx, ty, angle, self)\n            worms.append(worm)\n        \"\"\"\n        \n        # only init worms on dark spots of the image\n        for i in range(number_of_worms * 10):\n            \n            tx = math.floor(rnd.random() * self.width)\n            ty = math.floor(rnd.random() * self.height)\n            angle = rnd.random() * 2 * math.pi\n            \n            grey = self.get_grey_value(tx, ty)\n            if grey < self.thresh_worm:\n                self.add_worm(tx, ty, angle)\n            if len(self.worms) == number_of_worms:\n                break\n    \n    def add_worm(self, tx, ty, angle, index=None):\n        if index:\n            self.worms[index] = WormGH(tx, ty, angle, self)\n        else:\n            self.worms.append(WormGH(tx, ty, angle, self))\n    \n    def step(self):\n        #print self.worms\n        for i, w in enumerate(self.worms):\n            if not w.dead:\n\n                # save the worms points for the worm path      \n                w.points.append((w.x,w.y))\n                 \n                # move all the worms\n                w.x += (math.cos(w.angle) * self.speed)\n                w.y += (math.sin(w.angle) * self.speed)\n     \n                w.update_direction()\n     \n                \n                if (w.x > self.width) or (w.x < 0) or (w.y > self.height) or (w.y < 0):\n                    w.points.append(())\n                \n                # Wrap the worms around the canvas \n                if w.x > self.width: w.x = 0\n                if w.x < 0: w.x = self.width\n                if w.y > self.height: w.y = 0\n                if w.y < 0: w.y = self.height\n                \n            else:\n                # regenerate an available worm at a random slot\n                grey = 255\n                while grey > self.thresh_worm:            \n                    tx = math.floor(rnd.random() * self.width)\n                    ty = math.floor(rnd.random() * self.height)\n         \n                    # assign a random vector to begin with\n                    angle = rnd.random() * 2 * math.pi\n                     \n                    grey = self.get_grey_value(tx, ty)\n                    self.dead_worms.append(self.worms[i])  \n                    self.add_worm(tx, ty, angle, i)\n        \n            # draw geometry\n            if len(w.points) > 2:\n                if(len(w.points[-2]) and len(w.points[-1])):\n                    x1, y1 = w.points[-2]\n                    x2, y2 = w.points[-1]\n                    w.add_geometry(rg.Line(rg.Point3d(x1, y1, 0), rg.Point3d(x2, y2, 0)))\n\n\n         \n#===============================================================================\nclass WormGH:\n     \n    def __init__(self, x, y, angle, parent):\n        self.x = x\n        self.y = y\n        self.angle = angle\n        self.food = 100\n        self.dead = False\n        self.grey = 0\n        self.points = []\n        self.parent = parent\n        \n        self.geometry = []\n    \n    def add_geometry(self, geo):\n        self.geometry.append(geo)\n    \n    def get_polylines(self):\n        \n        polylines = []\n        polyline_pts = []\n        \n        for p in self.points:\n            if list(p) == []:\n                # make a new polyline\n                polylines.append(rg.PolylineCurve(polyline_pts))\n                polyline_pts = []\n            else:\n                x, y = p\n                polyline_pts.append(rg.Point3d(x, y, 0))\n        polylines.append(rg.PolylineCurve(polyline_pts))\n        \n        return polylines\n            \n        \n    def update_direction(self):\n                \n        # we know the current location, we know the vector\n        # calculate a few variations between -30 degrees and +30 degree and get their colors\n        # whichever is brightest, that's where we go to. \n         \n        angle = 0\n        best_angle = 0\n        best_score_so_far = {'grey': 0, 'angle': 0, 'score': 99999999 }\n     \n        # look for the best place to go\n        for i in range(12):\n     \n            angle = self.angle - ((rnd.random() * self.parent.looking_angle)) + ((rnd.random() * self.parent.looking_angle))\n            \n            # calculate a new direction                \n            tx = self.x + (math.cos(angle) * self.parent.speed)\n            ty = self.y + (math.sin(angle) * self.parent.speed) # 5 makes it look further out\n     \n            # test the source image\n            score = self.parent.get_score_from_grey_value(tx, ty)\n     \n            # swap > for < \n            if (score['score'] < best_score_so_far['score']):\n                best_angle = angle\n                score['angle'] = angle\n                best_score_so_far = score        \n     \n        self.parent.just_branched -= 1\n     \n        # If the score is SOO good, we should branch (unless maximum worms have been reached\n        if (best_score_so_far['score'] > self.parent.branch_thresh):\n     \n            if (self.parent.just_branched <= 0):\n                # assign a new vector, close to the original\n                start_angle = self.angle + ((rnd.random() * self.parent.looking_angle))\n                self.angle -= 0.37\n     \n                if (len(self.parent.worms) < self.parent.max_worms):\n                    # new worm\n\n                    self.parent.add_worm(self.x, self.y, start_angle)\n                    \n                    # we don't want everything branching at once\n                    self.parent.just_branched = 500\n                \n                   \n                else:\n                    # maybe we can find a dead-worm and re-use him\n                    for i, w in enumerate(self.parent.worms):\n                        if w.dead == True:\n                            self.parent.add_worm(self.x, self.y, start_angle, i)\n                            break\n     \n        self.angle = best_angle\n        self.food -= 1\n     \n        if self.parent.favour == \"light\": # favor the light\n            if best_score_so_far['score'] > 755:\n                self.food = 200\n        else: # favor the dark\n            if best_score_so_far['score'] < 355:\n                self.food = 200\n     \n        if self.food == 0:\n            self.dead = True\n \n\n#===============================================================================",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}