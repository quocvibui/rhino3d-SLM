{
  "source_url": "https://github.com/Eridaa/1.RhinoGH--Python-hops-examples/blob/db30011918629b550eb1e26aa638723944303b9a/RhinoGH--Mesh-analysis-with-networkx-main/03_MeshStrips/meshutils.py",
  "repo": "Eridaa/1.RhinoGH--Python-hops-examples",
  "repo_stars": 2,
  "repo_description": null,
  "license": "unknown",
  "filepath": "RhinoGH--Mesh-analysis-with-networkx-main/03_MeshStrips/meshutils.py",
  "instruction": "Meshutils",
  "code": "import rhino3dm as rg\nimport networkx as nx\nimport random\n\ndef makeSampleMesh(U,V):\n    #creating a simple mesh from a grid of points\n    mesh = rg.Mesh()\n    for i in range(U):\n        for j in range(V):\n            p = rg.Point3d(i,j,0)\n            mesh.Vertices.Add(p.X, p.Y, p.Z) \n            \n    for i in range(len(mesh.Vertices)-(V)):\n        if ( i % V != V -1 ):\n            mesh.Faces.AddFace(i,i+1, i+V+1,i+V)\n\n    return mesh\n\n\ndef avgPt(ptList):\n\n    ptX = list(map(lambda p: p.X, ptList))\n    ptY = list(map(lambda p: p.Y, ptList))\n    ptZ = list(map(lambda p: p.Z, ptList))\n    \n    return rg.Point3d(sum(ptX)/len(ptList), sum(ptY)/len(ptList), sum(ptZ)/len(ptList))\n\ndef explodeMeshRG(mesh):\n    exploded =[]\n    m_copy = mesh.Duplicate()\n    for i in range(len(m_copy.Faces)):\n        exploded.append(m_copy.Faces.ExtractFaces([0]))\n    return exploded\n\n\ndef explodeMesh(mesh):\n    meshList = []\n\n    for i in range(len(mesh.Faces)):\n\n        new_mesh = rg.Mesh()\n\n        v1 = mesh.Vertices[mesh.Faces[i][0]]\n        v2 = mesh.Vertices[mesh.Faces[i][1]]\n        v3 = mesh.Vertices[mesh.Faces[i][2]]\n\n        new_mesh.Vertices.Add(v1.X, v1.Y, v1.Z)\n        new_mesh.Vertices.Add(v2.X, v2.Y, v2.Z)\n        new_mesh.Vertices.Add(v3.X, v3.Y, v3.Z)\n\n        if mesh.Faces[0][-1] != mesh.Faces[0][-2]:\n            v4 = mesh.Vertices[mesh.Faces[i][3]]\n            new_mesh.Vertices.Add(v4.X, v4.Y, v4.Z)\n            new_mesh.Faces.AddFace(0, 1, 2, 3 )\n        else:\n            new_mesh.Faces.AddFace(0, 1, 2)\n            \n        meshList.append(new_mesh)\n\n\n    return meshList\n\ndef getAdjancentFaceList(mesh):\n    sets = []\n\n    for i in range(mesh.Faces.Count):\n        sets.append( set(mesh.Faces[i]) )\n        \n    allAdj = []\n\n    for i in range(len(sets)):\n        adj = []\n        for j in range(len(sets)):\n            if sets[i] is not sets[j]:\n                inter = sets[i].intersection( sets[j])\n                if len(inter) ==2:\n                    adj.append(j) \n        allAdj.append(adj)\n    return allAdj      \n\n\ndef getAdjancentFaces(mesh, MeshFaceIndex):\n    sets = []\n\n    for i in range(mesh.Faces.Count):\n        sets.append( set(mesh.Faces[i]) )\n        \n    adj  = []\n\n    for i in range(len(sets)):\n        if sets[MeshFaceIndex] is not sets[i]:\n            inter = sets[i].intersection(sets[MeshFaceIndex])\n            if len(inter) ==2:\n                adj.append(i) \n\n    return adj    \n\n   \ndef getVertexTopology(mesh):\n\n    m = mesh\n    topology = [ [] for i in  range(len(m.Vertices))]\n\n    for i in range(m.Faces.Count):\n        vert= list(m.Faces[i])\n        \n        if vert[-1] == vert[-2]: t = \"tri\"\n        else: t = \"quad\"\n        \n        if t== \"quad\":\n            vert.append(vert[0])\n            for j in range(len(vert)-1):\n                if vert[j+1] not in topology[vert[j]]:\n                    topology[vert[j]].append(vert[j+1])\n            vert.reverse()\n\n            for k in range(len(vert)-1):\n                if vert[k+1] not in topology[vert[k]]:\n                    topology[vert[k]].append(vert[k+1])\n    \n        if t==\"tri\":\n            vert.pop(-1)\n            vert.append(vert[0])\n\n            for j in range(len(vert)-1):\n                if vert[j+1] not in topology[vert[j]]:\n                    topology[vert[j]].append(vert[j+1])\n            vert.reverse()\n\n            for k in range(len(vert)-1):\n                if vert[k+1] not in topology[vert[k]]:\n                    topology[vert[k]].append(vert[k+1])\n   \n    return topology, t\n\ndef getNakedVertices(mesh):\n\n    topology = getVertexTopology(mesh)\n    topo = topology[0]\n    t = topology[1]\n\n    nakedPts = []\n    if t == \"quad\":\n        for i in range(len(topo)):\n            if len(topo[i]) <= 3: nakedPts.append(mesh.Vertices[i])\n    else:\n        for i in range(len(topo)):\n            if len(topo[i]) <= 4: nakedPts.append(mesh.Vertices[i])    \n\n    return nakedPts\n\n\ndef getNakedVertexIndexes(mesh):\n    topology = getVertexTopology(mesh)\n    topo = topology[0]\n    t = topology[1]\n\n    naked = []\n    if t == \"quad\":\n        for i in range(len(topo)):\n            if len(topo[i]) <= 3: naked.append(i)\n    else:\n        for i in range(len(topo)):\n            if len(topo[i]) <= 4: naked.append(i)    \n\n    return naked\n\n\ndef getGraphNakedNodes(nxgraph, meshtype=\"tri\"):\n    \n    naked_nodes = []\n    for n in nxgraph.nodes:\n        if meshtype == \"tri\":\n            if nxgraph.degree[n] <= 2: naked_nodes.append(n) \n        else:\n            if nxgraph.degree[n] <= 3: naked_nodes.append(n) \n\n    return naked_nodes\n\ndef getGraphNakedNodes(nxgraph):\n    \n    naked_nodes = []\n    for v, d in nxgraph.nodes(data=True):\n        if d['isNaked']: naked_nodes.append(v) \n \n    return naked_nodes\n\ndef getGraphNakedNodesTri(nxgraph):\n    \n    naked_nodes = []\n    for v, d in nxgraph.nodes(data=True):\n        if d['isNaked']: \n            naked_nodes.append(v) \n            #neighbors = [n for n in nxgraph.neighbors(v) if n not in naked_nodes]\n            #naked_nodes.extend(neighbors)\n \n    return naked_nodes\n\n\ndef addWeights(nxgraph, weights):\n\n    #if weights is an int, make  list out of it\n    if isinstance(weights, int):\n        weights = [weights for e in nxgraph.edges] \n\n    for i,n in enumerate(nxgraph.edges):\n        try :\n            nxgraph[n[0]][n[1]]['weight']=weights[i]\n        except:\n            nxgraph[n[0]][n[1]]['weight']=weights[-1]\n\n\ndef setWeightsNodesEdges(nxgraph, nodes, weights):\n\n    #if weights is an int, make  list out of it\n    if isinstance(weights, int):\n        weights = [weights for e in nxgraph.edges] \n\n    for i,e in enumerate(nxgraph.edges):\n        nxgraph[e[0]][e[1]]['weight']=weights[i]\n\ndef addRandomWeights(nxgraph, min=0, max=10):\n\n    for n in nxgraph.edges:\n        nxgraph[n[0]][n[1]]['weight']=random.randint(min, max)\n      \n\ndef hasPath(nxgraph, source, target):\n    return nx.has_path(nxgraph, source, target)\n\ndef getMeshType(mesh):\n    if mesh.Faces.QuadCount > 0:\n        typ = \"quad\"\n    else: typ = \"tri\"\n    return typ\n\ndef serializeNestedList(nestedList):\n    import json\n    return json.dumps(nestedList)\n\n\ndef isGraphConnected(g):\n    return nx.is_connected(g)\n\ndef getConnectedComponents(g):\n    return nx.connected_components(g)\n\n# G=nx.gnm_random_graph(5,5)\n# addRandomWeights(G)\n\n\ndef getFaceCenterTri(mesh,meshFace): #i think only for triangles\n    faceVertex = []\n    for i in range(len(meshFace)):\n        p3f = mesh.Vertices[meshFace[i]]\n        faceVertex.append(rg.Point3d(p3f.X, p3f.Y, p3f.Z))\n    \n    mid1=rg.Point3d((faceVertex[0].X + faceVertex[1].X)/2,(faceVertex[0].Y + faceVertex[1].Y)/2,(faceVertex[0].Z + faceVertex[1].Z)/2)\n    mid2=rg.Point3d((faceVertex[1].X + faceVertex[2].X)/2,(faceVertex[1].Y + faceVertex[2].Y)/2,(faceVertex[1].Z + faceVertex[2].Z)/2)\n    line1=rg.Line(mid1,faceVertex[2])\n    line2=rg.Line(mid2,faceVertex[0])\n\n    center_parameter=rg.Intersection.LineLine(line1,line2)[1]\n    center=rg.Line.PointAt(line1, center_parameter)\n    return center\n\ndef getFaceCenter(mesh, meshFace):\n    faceVertex = []\n\n    for i in range(len(meshFace)):\n        p3f = mesh.Vertices[meshFace[i]]\n        faceVertex.append(rg.Point3d(p3f.X, p3f.Y, p3f.Z))\n    return avgPt(faceVertex)\n        \ndef getStartPoint(g):\n\n    if nx.is_connected(g):\n        Grapheccentricity=nx.algorithms.distance_measures.eccentricity(g)\n        Maxeccentricity=max(list(Grapheccentricity.values()))\n        MaxeccentricityIndex=(list(Grapheccentricity.values()).index(Maxeccentricity))\n        realIndex=list(Grapheccentricity.keys())[MaxeccentricityIndex]\n        startpoint=realIndex\n    else:\n        largest_cc = max(nx.connected_components(g), key=len)\n        largest_graph=g.subgraph(largest_cc).copy()\n        Grapheccentricity=nx.algorithms.distance_measures.eccentricity(largest_graph)\n        Maxeccentricity=max(list(Grapheccentricity.values()))\n        MaxeccentricityIndex=list(Grapheccentricity.values()).index(Maxeccentricity)\n        realIndex=list(Grapheccentricity.keys())[MaxeccentricityIndex]\n        startpoint=realIndex\n    \n    return startpoint\n\ndef changeNeighborsWeight(g, nodes, weight = 1):\n    for n in nodes:\n        neighbors = [n for n in g.neighbors(n)]\n        for nb in neighbors:\n            for e in g.edges(nb):\n                g[e[0]][e[1]]['weight']=weight\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}