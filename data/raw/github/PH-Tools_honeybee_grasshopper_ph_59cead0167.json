{
  "source_url": "https://github.com/PH-Tools/honeybee_grasshopper_ph/blob/c433bc8e66f3a51fd05ee4c485f4c54c03d2a569/honeybee_ph_rhino/gh_io.py",
  "repo": "PH-Tools/honeybee_grasshopper_ph",
  "repo_stars": 6,
  "repo_description": "Honeybe-PH plugin for Rhino / Grasshopper ",
  "license": "GPL-3.0",
  "filepath": "honeybee_ph_rhino/gh_io.py",
  "instruction": "Grasshopper Interface Class. Used to pass Rhino, GH side dependencies to all other classes.",
  "code": "# -*- coding: utf-8 -*-\n# -*- Python Version: 2.7 -*-\n\n\"\"\"Grasshopper Interface Class. Used to pass Rhino, GH side dependencies to all other classes.\n\nThis is done so that other classes can be tested by mocking out this Interface. If I\ncould figure out how to get Rhino dependencies to be recognized by testing framework,\nprobably would not need something like this? I suppose it does help reduce coupling?\n\"\"\"\n\nfrom contextlib import contextmanager\nfrom copy import deepcopy\n\ntry:\n    from typing import Any, Dict, List, Optional, Sequence, Union\nexcept ImportError:\n    pass  # Python 3\n\ntry:\n    from itertools import izip as zip  # type: ignore\nexcept ImportError:\n    pass  # Python3+\n\ntry:\n    import System  # type: ignore\n    from System import Object  # type: ignore\nexcept ImportError:\n    raise ImportError(\"Failed to import System\")\n\ntry:\n    from GhPython import Component\nexcept ImportError:\n    raise ImportError(\"Failed to import GhPython\")\n\ntry:\n    import Grasshopper\nexcept ImportError:\n    raise ImportError(\"Failed to import Grasshopper\")\n\ntry:\n    import Rhino\nexcept ImportError:\n    raise ImportError(\"Failed to import Rhino\")\n\ntry:\n    import honeybee.face\nexcept ImportError:\n    raise ImportError(\"Failed to import honeybee\")\n\ntry:\n    from ladybug_geometry.geometry3d.face import Face3D\n    from ladybug_rhino.fromgeometry import from_face3d, from_linesegment3d, from_mesh3d, from_point3d, from_polyline3d\n    from ladybug_rhino.togeometry import to_face3d, to_linesegment3d, to_mesh3d, to_point3d, to_polyline3d\nexcept ImportError:\n    raise ImportError(\"Failed to import ladybug_geometry\")\n\ntry:\n    from honeybee_ph_utils.input_tools import clean_get, input_to_int\nexcept ImportError:\n    raise ImportError(\"Failed to import honeybee_ph_utils\")\n\n\nclass LBTGeometryConversionError(Exception):\n    def __init__(self, _in):\n        self.message = 'Input Error: Cannot convert \"{}\" to LBT Geometry.'.format(type(_in))\n\n        super(LBTGeometryConversionError, self).__init__(self.message)\n\n\nclass IGH:\n    \"\"\"PyPH Interface for basic Grasshopper (and Rhino) dependencies that can be\n        used by other classes which accept this Interface object.\n\n    Arguments:\n    ----------\n        * _ghdoc: (ghdoc)\n        * _ghenv: (ghenv)\n        * _sc: (scriptcontext)\n        * _rh: (Rhino)\n        * _rs (rhinoscriptsyntax)\n        * _ghc (ghpythonlib.components)\n        * _gh (Grasshopper)\n    \"\"\"\n\n    def __init__(self, _ghdoc, _ghenv, _sc, _rh, _rs, _ghc, _gh):\n        # type: (Any, Any, Any, Rhino, Any, Any, Grasshopper) -> None\n        self.ghdoc = _ghdoc\n        self.ghenv = _ghenv\n        self.scriptcontext = _sc\n        self.Rhino = _rh\n        self.rhinoscriptsyntax = _rs\n        self.ghpythonlib_components = _ghc\n        self.Grasshopper = _gh\n\n    @property\n    def rs(self):\n        \"\"\"Convenience Attribute Alias.\"\"\"\n        return self.rhinoscriptsyntax\n\n    @property\n    def ghc(self):\n        \"\"\"Convenience Attribute Alias.\"\"\"\n        return self.ghpythonlib_components\n\n    @property\n    def sc(self):\n        \"\"\"Convenience Attribute Alias.\"\"\"\n        return self.scriptcontext\n\n    def DataTree(self, _type=Object):\n        # type: (Any) -> Any\n        \"\"\"Facade for Grasshopper.DataTree[_type]\"\"\"\n        return self.Grasshopper.DataTree[_type]()  # type: ignore\n\n    def GH_Path(self, _i):\n        # type: (int) -> Any\n        \"\"\"Facade for Grasshopper.Kernel.Data.GH_Path\"\"\"\n        return self.Grasshopper.Kernel.Data.GH_Path(_i)\n\n    def gh_compo_find_input_index_by_name(self, _input_name):\n        # type: (str) -> int\n        \"\"\"\n        Compares an input name against the list of GH_Component Inputs. Returns the\n        index of any match or None if not found\n\n        Arguments:\n        ----------\n            * _input_name (str): The name to search for\n\n        Returns:\n        --------\n            * (int): The index of the matching item\n        \"\"\"\n\n        for i, each in enumerate(list(self.ghenv.Component.Params.Input)):\n            names = [str(each.Name).upper(), str(each.NickName).upper()]\n            if _input_name.upper() in names:\n                return i\n\n        raise Exception('Error: The input node \"{}\" cannot be found?'.format(_input_name))\n\n    def gh_compo_get_input_for_node_number(self, _node_number):\n        # type: (int) -> GH_Structure[IGH_Goo]\n        \"\"\"Returns the 'VolatileData' for a GH-Component's Input Param.\n\n        Arguments:\n        ----------\n            * _node_number (int): The number of the GH-Component Input Node to read.\n\n        Returns:\n        --------\n            * (GH_Structure[IGH_Goo]): The 'VolatileData' of the GH-Component Input Node.\n        \"\"\"\n        return self.ghenv.Component.Params.Input[_node_number].VolatileData\n\n    def gh_compo_get_input_guids(self, _input_index_number, _branch_num=0):\n        # type: (int, int) -> List[System.Guid]\n        \"\"\"\n        Returns a list of all the GUIDs of the objects being passed to the\n        component's specified input node.\n\n        Arguments:\n        ----------\n            * _input_index_number (int): The index number of the input node to\n                look at.\n\n        Returns:\n        --------\n            * list[System.Guid]: The GUIDs of the objects being input into the specified\n                component input node.\n        \"\"\"\n\n        guids = []\n        try:\n            for _ in self.ghenv.Component.Params.Input[_input_index_number].VolatileData[_branch_num]:\n                try:\n                    guids.append(_.ReferenceID)\n                except AttributeError:\n                    # If input doesn't have a ReferenceID, its probably a Panel text or number input\n                    guids.append(None)\n        except ValueError:\n            nm = self.ghenv.Component.Params.Input[_input_index_number].NickName\n            print('No input values found for \"{}\".'.format(nm))\n\n        return guids\n\n    @contextmanager\n    def context_rh_doc(self):\n        \"\"\"\n        Context Manager used to switch Grasshopper's scriptcontext.doc\n        to Rhino.RhinoDoc.ActiveDoc temporarily. This is needed when trying\n        to access information such as UserText for Rhino objects\n\n        Use:\n        ----\n        >>> with context_rh_doc():\\n\n        >>>    run_some_command( gh_component_input )\n        \"\"\"\n\n        try:\n            self.scriptcontext.doc = self.Rhino.RhinoDoc.ActiveDoc\n            yield\n        except Exception as e:\n            self.scriptcontext.doc = self.ghdoc\n            print(\"Exception:\", e.message)\n            raise Exception\n        finally:\n            self.scriptcontext.doc = self.ghdoc\n\n    def get_rh_obj_UserText_dict(self, _rh_obj_guids):\n        # type: (System.guid) -> List[Dict]\n        \"\"\"\n        Get any Rhino-side UserText attribute data for the Object/Elements.\n        Note: this only works in Rhino v6.0+ I believe...\n\n        Arguments:\n        ----------\n            _rh_obj_guids (list[Rhino Guid]): The Rhino Guid(s) of the Object/Elements.\n\n        Returns:\n        --------\n            output_list (list[dict]): A list of dictionaries, each with all the data found\n                in the Rhino object's UserText library.\n        \"\"\"\n\n        def is_grasshopper_geometry(_guid):\n            \"\"\"If its GH generated geom, will have this GUID always\"\"\"\n            return str(_guid) == \"00000000-0000-0000-0000-000000000000\"\n\n        if not _rh_obj_guids:\n            return []\n        if not isinstance(_rh_obj_guids, list):\n            _rh_obj_guids = [_rh_obj_guids]\n\n        output_list = []\n        with self.context_rh_doc():\n            for guid in _rh_obj_guids:\n                if not guid or is_grasshopper_geometry(guid):\n                    output_list.append({\"Object Name\": None})\n                else:\n                    # -- Go get the data from Rhino\n                    rh_obj = self.Rhino.RhinoDoc.ActiveDoc.Objects.Find(guid)\n                    object_rh_UserText_dict = {\n                        k: self.rhinoscriptsyntax.GetUserText(rh_obj, k)\n                        for k in self.rhinoscriptsyntax.GetUserText(rh_obj)\n                    }\n\n                    # -- Fix the name\n                    object_name = self.rhinoscriptsyntax.ObjectName(guid)\n                    object_rh_UserText_dict[\"Object Name\"] = object_name\n\n                    output_list.append(object_rh_UserText_dict)\n\n        return output_list\n\n    def convert_to_LBT_geom(self, _inputs):\n        # type: (List[Any]) -> List[List]\n        \"\"\"Converts a list of RH- or GH-Geometry into a list of LBT-Geometry. If\n            input is a string, boolean or number, will just return that without converting.\n\n            Note: The return is a list of lists since the lbt converter might return\n            triangulated faces in some cases.\n\n        Arguments:\n        ----------\n            * _inputs (list[Any]): The Rhino items / objects to try and convert\n\n        Returns:\n        --------\n            * list[list]: The input (RH/GH) geometry, converted to LBT-Geometry\n        \"\"\"\n\n        if not isinstance(_inputs, list):\n            _inputs = [_inputs]\n        lbt_geometry = []\n        for i, _ in enumerate(_inputs):\n            if isinstance(_, list):\n                for __ in _:\n                    result = self.convert_to_LBT_geom(__)\n                    lbt_geometry.append(result)\n            elif isinstance(_, (str, int, float)):\n                try:\n                    lbt_geometry.append(float(str(_)))\n                except ValueError:\n                    lbt_geometry.append(str(_))\n            elif isinstance(_, bool):\n                lbt_geometry.append(_)\n            elif isinstance(_, self.Rhino.Geometry.Brep):\n                lbt_geometry.append(to_face3d(_))\n            elif isinstance(_, self.Rhino.Geometry.PolylineCurve):\n                lbt_geometry.append(to_polyline3d(_))\n            elif isinstance(_, self.Rhino.Geometry.LineCurve):\n                lbt_geometry.append(to_linesegment3d(_))\n            elif isinstance(_, self.Rhino.Geometry.Line):\n                lbt_geometry.append(to_linesegment3d(self.Rhino.Geometry.LineCurve(_)))\n            elif isinstance(_, self.Rhino.Geometry.Mesh):\n                lbt_geometry.append(to_mesh3d(_))\n            elif isinstance(_, self.Rhino.Geometry.Point3d):\n                lbt_geometry.append(to_point3d(_))\n            else:\n                raise LBTGeometryConversionError(_)\n\n        return lbt_geometry\n\n    def convert_to_rhino_geom(self, _inputs):\n        # type: (List) -> List\n        \"\"\"Converts a list of LBT-Geometry into RH-Geometry.\n\n        Arguments:\n        ----------\n            * _inputs (List): The LBT Geometry items / objects to try and convert\n\n        Returns:\n        --------\n            * list: The input LBT geometry, converted to Rhino-Geometry\n        \"\"\"\n\n        if not isinstance(_inputs, list):\n            _inputs = [_inputs]\n\n        rh_geom = []\n        for _ in _inputs:\n            if isinstance(_, list):\n                for __ in _:\n                    result = self.convert_to_rhino_geom(__)\n                    rh_geom.append(result)\n            elif isinstance(_, honeybee.face.Face):\n                rh_geom.append(from_face3d(_.geometry))\n            elif isinstance(_, honeybee.face.Face3D):\n                rh_geom.append(from_face3d(_))\n            else:\n                raise Exception('Input Error: Cannot convert \"{}\" to Rhino Geometry.'.format(type(_)))\n\n        return rh_geom\n\n    def inset_LBT_face(self, _lbt_face, _inset_distance):\n        # type: (honeybee.face.Face, float) -> List\n        \"\"\"Converts an LBT face to Rhino Geom and performs an 'inset' operation on it. Returns the newly inset Face3D\n\n        Arguments:\n        ----------\n            * _lbt_face (honeybee.face.Face): The LBT Face to inset\n            * _inset_distance (float): The distance to inset the surface\n\n        Returns:\n        --------\n            * (List): A new LBT Face, inset by the specified amount\n        \"\"\"\n\n        rh_floor_surface = self.convert_to_rhino_geom(_lbt_face)\n\n        if _inset_distance < 0.001:\n            return rh_floor_surface\n\n        # -----------------------------------------------------------------------\n        srfcPerim = self.ghpythonlib_components.JoinCurves(\n            self.ghpythonlib_components.BrepEdges(rh_floor_surface)[0], preserve=False\n        )\n\n        # Get the inset Curve\n        # -----------------------------------------------------------------------\n        srfcCentroid = self.Rhino.Geometry.AreaMassProperties.Compute(rh_floor_surface).Centroid\n        plane = self.ghpythonlib_components.XYPlane(srfcCentroid)\n        plane = self.ghpythonlib_components.IsPlanar(rh_floor_surface, True).plane\n        srfcPerim_Inset_Pos = self.ghpythonlib_components.OffsetCurve(srfcPerim, _inset_distance, plane, 1)\n        srfcPerim_Inset_Neg = self.ghpythonlib_components.OffsetCurve(srfcPerim, _inset_distance * -1, plane, 1)\n\n        # Choose the right Offset Curve. The one with the smaller area\n        # Check IsPlanar first to avoid self.grasshopper_components.BoundarySurfaces error\n        # -----------------------------------------------------------------------\n        if srfcPerim_Inset_Pos.IsPlanar:\n            srfcInset_Pos = self.ghpythonlib_components.BoundarySurfaces(srfcPerim_Inset_Pos)\n        else:\n            srfcInset_Pos = self.ghpythonlib_components.BoundarySurfaces(srfcPerim)  # Use the normal perim\n\n        if srfcPerim_Inset_Neg.IsPlanar():\n            srfcInset_Neg = self.ghpythonlib_components.BoundarySurfaces(srfcPerim_Inset_Neg)\n        else:\n            srfcInset_Neg = self.ghpythonlib_components.BoundarySurfaces(srfcPerim)  # Use the normal perim\n\n        # -----------------------------------------------------------------------\n        area_Pos = self.ghpythonlib_components.Area(srfcInset_Pos).area\n        area_neg = self.ghpythonlib_components.Area(srfcInset_Neg).area\n\n        if area_Pos < area_neg:\n            return self.convert_to_LBT_geom(srfcInset_Pos)\n        else:\n            return self.convert_to_LBT_geom(srfcInset_Neg)\n\n    def merge_Face3D(self, _face3Ds):\n        # type: (List[honeybee.face.Face3D]) -> List[List[honeybee.face.Face3D] ]\n        \"\"\"Combine a set of Face3D surfaces together into 'merged' Face3Ds\n\n        This *should* work on surfaces that are touching, AND ones that overlap. Using\n        GH MergeFaces() only works on 'touching' surfaces, but not overlapping ones.\n        Using 'RegionUnion' should work on both touching and overlapping surfaces.\n\n        Arguments:\n        ----------\n            * _face3Ds (list[honeybee.face.Face3D]): The Face3Ds to try and merge\n\n        Returns:\n        --------\n            * (list[list[honeybee.face.Face3D]]): The merged Face3Ds\n        \"\"\"\n\n        # -- Pull out the Perimeter curves from each Face3D\n        perims = []\n        for face3D in _face3Ds:\n            rh_brep = self.convert_to_rhino_geom(face3D)\n            faces, edges, vertices = self.ghpythonlib_components.DeconstructBrep(rh_brep)\n            perims.append(self.ghpythonlib_components.JoinCurves(edges, True))\n\n        joined_curves = self.ghpythonlib_components.RegionUnion(perims)\n\n        if not isinstance(joined_curves, list):\n            joined_curves = [joined_curves]\n\n        # -- Intersect and Merge the Perimeter Curves back together, make new Face3Ds\n        new_LBT_face3ds = []\n        for crv in joined_curves:\n            merged_breps = self.Rhino.Geometry.Brep.CreatePlanarBreps(crv, 0.01)\n\n            for new_brep in merged_breps:\n                new_LBT_Face = self.convert_to_LBT_geom(new_brep)\n                new_LBT_face3ds.extend(new_LBT_Face)\n\n        return new_LBT_face3ds\n\n    def extrude_Face3D_WorldZ(self, _face3D, _dist=2.5):\n        # type: (List[Face3D], float) -> List[Face3D]\n        \"\"\"Returns a list of Face3D surfaces representing a closed brep extrusion of the base Face3D\"\"\"\n        extrusion_vector = self.ghpythonlib_components.UnitZ(_dist)\n        rh_brep = from_face3d(_face3D)\n        volume_geom = self.ghpythonlib_components.Extrude(rh_brep, extrusion_vector)\n        try:\n            volume_geom = volume_geom.ToBrep()\n        except AttributeError:\n            pass\n\n        return self.convert_to_LBT_geom(volume_geom)[0]\n\n    def error(self, _in):\n        \"\"\"Raise a runtime Error message on the GH Component\"\"\"\n        if not _in:\n            return None\n        else:\n            level = self.Grasshopper.Kernel.GH_RuntimeMessageLevel.Error\n            self.ghenv.Component.AddRuntimeMessage(level, _in)\n\n    def warning(self, _in):\n        \"\"\"Raise a runtime Warning message on the GH Component\"\"\"\n        if not _in:\n            return None\n        else:\n            level = self.Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning\n            self.ghenv.Component.AddRuntimeMessage(level, _in)\n\n    def remark(self, _in):\n        \"\"\"Raise a runtime Note message on the GH Component\"\"\"\n        if not _in:\n            return None\n        else:\n            level = self.Grasshopper.Kernel.GH_RuntimeMessageLevel.Remark\n            self.ghenv.Component.AddRuntimeMessage(level, _in)\n\n    def get_rhino_unit_system_name(self):\n        # type: () -> str\n        \"\"\"Returns the Rhino Unit System Name as a string.\"\"\"\n        return str(self.sc.doc.ModelUnitSystem)\n\n    def duplicate_data_to_branches(self, _data, _branch_count=1, _shallow=True):\n        # type: (List[Any], int, bool) -> DataTree[Object]\n        \"\"\"Duplicate a list of data into a DataTree with the specified number of branches.\n\n        Arguments:\n        ----------\n            * data: (Iterable[Any]) The data that you would like to duplicate onto the new branches.\n            * branch_count: (int) The number of branches that you would like to create.\n            * shallow: (bool) default=True. If set to True, the data will be 'shallow' copied onto the new branches.\n\n        Returns:\n        --------\n            * DataTree[Object]: A DataTree with data copied onto the specified number of branches.\n        \"\"\"\n        output_tree_ = self.DataTree()\n        if _shallow == True:\n            for i in range(_branch_count):\n                output_tree_.AddRange(_data, self.GH_Path(i))\n        else:\n            for i in range(_branch_count):\n                output_tree_.AddRange(deepcopy(_data), self.GH_Path(i))\n\n        return output_tree_\n\n    @property\n    def tolerance(self):\n        # type: () -> float\n        return self.scriptcontext.doc.ModelAbsoluteTolerance\n\n\nclass ComponentInput:\n    \"\"\"GH-Component Input Node data class.\"\"\"\n\n    def __init__(\n        self,\n        _name=\"-\",\n        _description=\"\",\n        _access=0,\n        _type_hint=Component.NoChangeHint(),\n        _target_unit=None,\n    ):\n        # type: (str, str, int, Component.NoChangeHint, Optional[str]) -> None\n        self.name = _name\n        self.description = _description\n        self.access = _access  # 0='item, 1='list', 2='tree'\n        self.type_hint = _type_hint\n        self.target_unit = _target_unit\n\n    def __str__(self):\n        return \"{}(name={})\".format(\n            self.__class__.__name__,\n            self.name,\n        )\n\n    def __repr__(self):\n        return str(self)\n\n    def ToString(self):\n        return str(self)\n\n\ndef handle_inputs(IGH, _input_objects, _input_name, _branch_num=0):\n    # type: (IGH, list, str, int) -> List[dict]\n    \"\"\"\n    Generic Rhino / GH Geometry input handler\n\n    Arguments:\n    ----------\n        * IGH (PyPH_Rhino.gh_io.IGH)\n        * _input_objects (Any):\n        * _input_name (str):\n\n    Returns:\n    --------\n        (list[dict]): A list of the object dictionaries with all the information found.\n    \"\"\"\n\n    if not isinstance(_input_objects, list):\n        _input_objects = list(_input_objects)\n\n    # -- Get the Input Object Attribute UserText values (if any)\n    input_index_number = IGH.gh_compo_find_input_index_by_name(_input_name)\n    input_guids = IGH.gh_compo_get_input_guids(input_index_number, _branch_num)\n    inputs = IGH.get_rh_obj_UserText_dict(input_guids)\n\n    # -- Add the Input Geometry to the output dictionary\n    input_geometry_lists = IGH.convert_to_LBT_geom(_input_objects)\n\n    output_list = []\n    for input_dict, geometry_list in zip(inputs, input_geometry_lists):\n        if not isinstance(geometry_list, list):\n            geometry_list = [geometry_list]\n\n        for geometry in geometry_list:\n            item = deepcopy(input_dict)\n            item.update({\"Geometry\": [geometry]})\n            output_list.append(item)\n\n    return output_list\n\n\ndef setup_component_inputs(IGH, _input_dict, _start_i=1, _end_i=20):\n    # type: (IGH, Dict[int, ComponentInput], int, int) -> None\n    \"\"\"Dynamic GH component input node configuration.\n\n    Arguments:\n    ----------\n        * IGH (): The Grasshopper Interface object.\n        * _input_dict (dict[int, ComponentInput]): The input dict with the field names\n            and descriptions to use for the component input nodes.\n        * _start_i (int): Optional starting node number. Default=1\n        * _end_i (int): Optional ending node number. Default=20\n\n    Returns:\n    --------\n        * None\n    \"\"\"\n    for input_num in range(_start_i, _end_i):\n        input_item = _input_dict.get(input_num, ComponentInput(\"-\", \"-\"))\n\n        try:\n            input_node = IGH.ghenv.Component.Params.Input[input_num]\n            input_node.NickName = input_item.name\n            input_node.Name = input_item.name\n            input_node.Description = input_item.description\n            input_node.Access = IGH.Grasshopper.Kernel.GH_ParamAccess(input_item.access)\n            input_node.TypeHint = input_item.type_hint\n        except ValueError:\n            # -- past end of component inputs\n            pass\n\n    return None\n\n\ndef _get_component_input_value(_input):\n    # type: (Sequence[Any]) -> Union[float, str]\n    \"\"\"Try and cast the input value to the appropriate type.\"\"\"\n\n    try:\n        input_value = _input[0].Value\n\n        if isinstance(input_value, str):\n            # For some reason, floats come as Str?....\n            try:\n                return float(input_value)\n            except:\n                return input_value\n        else:\n            return input_value\n    except:\n        return str(_input[0])\n\n\ndef get_component_input_values(ghenv):\n    # type: (Any) -> Dict[str, Any]\n    \"\"\"Dynamic Component Input 'get' - pulls all the component input names/values into a dictionary.\n\n    Arguments:\n    ----------\n        * ghenv (): The Grasshopper ghenv variable.\n\n    Returns:\n    --------\n        * dict[str, Any]: A dictionary of the component input node's user input values.\n\n    \"\"\"\n    inputs = {}\n    for _input in ghenv.Component.Params.Input:\n        try:\n            # Cast from GH_Goo to a normal PH-List\n            try:\n                input_list = list(_input.VolatileData[0])\n            except:\n                input_list = []\n\n            if str(_input.Access) == \"list\":\n                val = []\n                for v in input_list:\n                    val.append(_get_component_input_value([v]))\n            elif str(_input.Access) == \"tree\":\n                raise NotImplementedError(\"Tree input not allowed yet....\")\n            else:\n                val = _get_component_input_value(input_list)\n\n            inputs[_input.Name] = val\n        except:\n            inputs[_input.Name] = None\n\n    return inputs\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}