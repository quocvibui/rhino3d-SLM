{
  "source_url": "https://github.com/lucianoambrosini/Ambrosinus_Scripts/blob/ccf30aa3cb505ab5b13baeecdcb556341c900c8b/Rhinoscript/Weaving_of_Trumpets_v1.py",
  "repo": "lucianoambrosini/Ambrosinus_Scripts",
  "repo_stars": 6,
  "repo_description": "Rhinoscript, Python, C# and maybe...tricks",
  "license": "MIT",
  "filepath": "Rhinoscript/Weaving_of_Trumpets_v1.py",
  "instruction": "WEAVING OF TRUMPETS by Luciano Ambrosini",
  "code": "#WEAVING OF TRUMPETS by Luciano Ambrosini\r\nimport rhinoscriptsyntax as rs\r\nimport random as rnd\r\n\r\n\r\n##---MY FUNCTIONS DEFINITION---#\r\n\r\ndef SetGrid():\r\n    \r\n    #create an empty list/dict\r\n    ptList = []\r\n    ptDict = {}\r\n    \r\n    ##-----INPUT-----##\r\n    \r\n    #input values for imax and jmax and x and y spacing values\r\n    imax = rs.GetInteger(\"input number in x direction\",10)\r\n    jmax = rs.GetInteger(\"input number in y direction\",2)\r\n    kmax = rs.GetInteger(\"input number in k direction\",10)\r\n    dx = rs.GetReal(\"input number for x spacing direction\",5)\r\n    dy = rs.GetReal(\"input number for y spacing direction\",5)\r\n    dz = rs.GetReal(\"input number for z spacing direction\",5)\r\n    \r\n    \r\n    #ASK ABOUT DISPLAYING DOT TEXT E CHECK IF THE ANSWER IS CORRECT\r\n    \r\n    #SET MESSAGE AND OPTIONS\r\n    #for dotText\r\n    strPrompt1 = \"would you like to print dotText?\"\r\n    strOptions1 = [\"yes\",\"no\"]\r\n    strPromptErr1=\"Please write 'yes' or 'no'\"\r\n    \r\n    #for shifting Pts\r\n    strPrompt2 = \"would you like to shift Points location?\"\r\n    \r\n    #proportionally space the points\r\n    strPrompt3 = \"would you like to proportionally space the points?\"\r\n    \r\n    \r\n    #ASK FOR INPUT/QUESTION ABOUT TEXT DOT\r\n    showDot=rs.GetString(strPrompt1,\"no\",strOptions1)\r\n    \r\n    #assign check-flag\r\n    if (showDot == \"yes\" or showDot == \"no\"):\r\n        checkDot=1\r\n    else:\r\n        checkDot=0\r\n        \r\n    #check loop for Text dot\r\n    while checkDot!=1:\r\n        showDot=rs.GetString(strPromptErr1,\"no\",strOptions1)\r\n        if (showDot != \"yes\" or showDot !=\"no\"):\r\n            checkDot=0\r\n        elif showDot==None:\r\n            showDot=\"no\"\r\n            checkDot=1\r\n        else:\r\n            checkDot=1\r\n    \r\n    \r\n    #ASK THE FOR PROPORTIONAL SPACING\r\n    propPts=rs.GetString(strPrompt3,\"no\",strOptions1)\r\n    \r\n    #assign check-flag\r\n    if (propPts == \"yes\" or propPts == \"no\"):\r\n        checkProp=1\r\n    else:\r\n        checkProp=0\r\n        \r\n    #check loop for spacing proportionally Pts\r\n    while checkProp!=1:\r\n        propPts=rs.GetString(strPromptErr1,\"no\",strOptions1)\r\n        if (propPts != \"yes\" or propPts !=\"no\"):\r\n            checkProp=0\r\n        elif propPts==None:\r\n            propPts=\"no\"\r\n            checkProp=1\r\n        else:\r\n            checkProp=1\r\n    \r\n    \r\n    #ASK THE FOR SHIFTING PTS\r\n    shiftPts=rs.GetString(strPrompt2,\"no\",strOptions1)\r\n    \r\n    #assign check-flag\r\n    if (shiftPts == \"yes\" or shiftPts == \"no\"):\r\n        checkShift=1\r\n    else:\r\n        checkShift=0\r\n        \r\n    #check loop for shifting Pts\r\n    while checkShift!=1:\r\n        shiftPts=rs.GetString(strPromptErr1,\"no\",strOptions1)\r\n        if (shiftPts != \"yes\" or shiftPts !=\"no\"):\r\n            checkShift=0\r\n        elif shiftPts==None:\r\n            shiftPts=\"no\"\r\n            checkPts=1\r\n        else:\r\n            checkShift=1\r\n    #return (checkDot,checkProp,checkPts)\r\n\r\n\r\n    ##-----GENERATE GRID-----##\r\n    \r\n    #set shifting Pts random values\r\n    rndSpts=1\r\n    rndEpts=5\r\n    rndSTpts=1\r\n    \r\n    \r\n    #nested incremental loop to generate a matrix-points\r\n    for i in range(imax):\r\n        for j in range(jmax):\r\n            for k in range(kmax):\r\n                \r\n                if shiftPts==\"yes\" and propPts==\"yes\":\r\n                    x = (i+i*i)*dx + i*(rnd.randrange(rndSpts,rndEpts,rndSTpts,int))\r\n                    y = (j+j*j)*dy + i*(rnd.randrange(rndSpts,rndEpts,rndSTpts,int))\r\n                    z = (k+k*k)*dz + i*(rnd.randrange(rndSpts,rndEpts,rndSTpts,int))\r\n                elif shiftPts==\"yes\" and propPts==\"no\":\r\n                    x = i*dx + (rnd.randrange(rndSpts,rndEpts,rndSTpts,int))\r\n                    y = j*dy + (rnd.randrange(rndSpts,rndEpts,rndSTpts,int))\r\n                    z = k*dz + (rnd.randrange(rndSpts,rndEpts,rndSTpts,int))\r\n                elif shiftPts==\"no\" and propPts==\"yes\":\r\n                    x = (i+i*i)*dx\r\n                    y = (j+j*j)*dy\r\n                    z = (k+k*k)*dz\r\n                else:           #case: no-shifted and no prop Pts\r\n                    x = i*dx \r\n                    y = j*dy\r\n                    z = k*dz\r\n                    \r\n                #draw Pts in Rhino.Space\r\n                #rs.AddPoint(x,y,z)\r\n                \r\n                #print dot texts\r\n                if showDot==\"yes\":\r\n                    rs.AddTextDot((x,y,z), (x,y,z)) \r\n                    \r\n                #save point values in a dictionary using (i,j) as a key\r\n                ptDict[(i,j,k)] = (x,y,z)\r\n    return(ptDict,imax,jmax,kmax,propPts)\r\n\r\ndef numberPoints(points):\r\n    for i in range(len(points)):\r\n        #rs.AddPoint(points[i])\r\n        rs.AddTextDot(i, points[i])\r\n\r\ndef RndID(gridPts):\r\n    #find max dim of a list of points (points from srf control points list)\r\n    dim=len(gridPts)-1\r\n    id=rnd.randint(0,dim)\r\n    return(id)\r\n\r\ndef RndRAD(max):\r\n    #random radius\r\n    rad=round(rnd.uniform(0.5,max/3),2)\r\n    return (rad)\r\n\r\ndef PtFrame(origin,ptDict,loc):\r\n    #generate frame of my cube-module by origin and loc (loc:front,back,left,right,bottom,up)\r\n    if loc=='front'or loc=='back':\r\n        xaxis=(1,0,0)\r\n        yaxis=(0,0,1)\r\n    elif loc=='left' or loc=='right':\r\n        xaxis=(0,1,0)\r\n        yaxis=(0,0,1)\r\n    elif loc=='bott' or loc=='up':\r\n        xaxis=(1,0,0)\r\n        yaxis=(0,1,0)\r\n    Frm=rs.PlaneFromFrame(origin,xaxis,yaxis)\r\n    return(Frm)\r\n\r\n\r\n\r\ndef wallType01(ptDict,IMAX,JMAX,KMAX,propGrid):\r\n    \r\n    #scale factor\r\n    sclF=0.5\r\n    \r\n    #Mid circle radius\r\n    midRad=0.5\r\n    \r\n    \r\n    for i in range(IMAX):\r\n        for j in range(JMAX):\r\n            for k in range(KMAX):\r\n                if i > 0 and j > 0 and k > 0:\r\n                    \r\n                    #cube-module centroid\r\n                    Crossline=rs.AddCurve((ptDict[(i-1,j-1,k-1)],ptDict[(i,j,k)]))\r\n                    centroid=rs.AddPoint(rs.CurveMidPoint(Crossline))\r\n                    rs.DeleteObject(Crossline)\r\n                    \r\n                    \r\n                    #FRONT FACE\r\n                    #find Front Face centroid\r\n                    FFline=rs.AddCurve((ptDict[(i-1,j-1,k-1)],ptDict[(i,j-1,k)]))\r\n                    centFace=rs.AddPoint(rs.CurveMidPoint(FFline))\r\n                    rs.DeleteObject(FFline)\r\n                    #create construction surface to find grid of points\r\n                    srf = rs.AddSrfPt((ptDict[(i-1,j-1,k)], ptDict[(i,j-1,k)], \r\n                    ptDict[(i,j-1,k-1)], ptDict[(i-1,j-1,k-1)]))\r\n                    #scale srf\r\n                    rs.ScaleObject(srf,centFace,(sclF,sclF,sclF),False)\r\n                    #rebuild surface to create 4 x 4 grid (9 quadrants)\r\n                    rs.RebuildSurface(srf, (3,3), (4,4))\r\n                    #extract points from grid\r\n                    FFpts = rs.SurfacePoints(srf)\r\n                    #call function to reveal order of points\r\n                    #numberPoints(FFpts)\r\n                    #delete construction surface\r\n                    rs.DeleteObject(srf)\r\n                    rs.DeleteObject(centFace)\r\n                    \r\n                    \r\n                    #BACK FACE\r\n                    #find Back Face centroid\r\n                    BFline=rs.AddCurve((ptDict[(i-1,j,k-1)],ptDict[(i,j,k-1)]))\r\n                    centFace=rs.AddPoint(rs.CurveMidPoint(BFline))\r\n                    rs.DeleteObject(BFline)\r\n                    #create construction surface to find grid of points\r\n                    srf = rs.AddSrfPt((ptDict[(i-1,j,k-1)], ptDict[(i,j,k-1)], \r\n                    ptDict[(i,j,k)], ptDict[(i-1,j,k)]))\r\n                    #scale srf\r\n                    rs.ScaleObject(srf,centFace,(sclF,sclF,sclF),False)\r\n                    #rebuild surface to create 4 x 4 grid (9 quadrants)\r\n                    rs.RebuildSurface(srf, (3,3), (4,4))\r\n                    #extract points from grid\r\n                    BFpts = rs.SurfacePoints(srf)\r\n                    #delete construction surface\r\n                    rs.DeleteObject(srf)\r\n                    rs.DeleteObject(centFace)\r\n                    \r\n                    \r\n                    #LEFT FACE\r\n                    #find Left Face centroid\r\n                    LFline=rs.AddCurve((ptDict[(i-1,j,k-1)],ptDict[(i-1,j-1,k)]))\r\n                    centFace=rs.AddPoint(rs.CurveMidPoint(LFline))\r\n                    rs.DeleteObject(LFline)\r\n                    #create construction surface to find grid of points\r\n                    srf = rs.AddSrfPt((ptDict[(i-1,j,k-1)], ptDict[(i-1,j-1,k-1)], \r\n                    ptDict[(i-1,j-1,k)], ptDict[(i-1,j,k)]))\r\n                    #scale srf\r\n                    rs.ScaleObject(srf,centFace,(sclF,sclF,sclF),False)\r\n                    #rebuild surface to create 4 x 4 grid (9 quadrants)\r\n                    rs.RebuildSurface(srf, (3,3), (4,4))\r\n                    #extract points from grid\r\n                    LFpts = rs.SurfacePoints(srf)\r\n                    #call function to reveal order of points\r\n                    #numberPoints(LFpts)\r\n                    #delete construction surface\r\n                    rs.DeleteObject(srf)\r\n                    rs.DeleteObject(centFace)\r\n                    \r\n                    \r\n                    #RIGHT FACE\r\n                    #find Right Face centroid\r\n                    RFline=rs.AddCurve((ptDict[(i,j-1,k-1)],ptDict[(i,j,k)]))\r\n                    centFace=rs.AddPoint(rs.CurveMidPoint(RFline))\r\n                    rs.DeleteObject(RFline)\r\n                    #create construction surface to find grid of points\r\n                    srf = rs.AddSrfPt((ptDict[(i,j-1,k-1)], ptDict[(i,j,k-1)], \r\n                    ptDict[(i,j,k)], ptDict[(i,j-1,k)]))\r\n                    #scale srf\r\n                    rs.ScaleObject(srf,centFace,(sclF,sclF,sclF),False)\r\n                    #rebuild surface to create 4 x 4 grid (9 quadrants)\r\n                    rs.RebuildSurface(srf, (3,3), (4,4))\r\n                    #extract points from grid\r\n                    RFpts = rs.SurfacePoints(srf)\r\n                    #delete construction surface\r\n                    rs.DeleteObject(srf)\r\n                    rs.DeleteObject(centFace)\r\n                    \r\n                    \r\n                    #BOTTOM FACE\r\n                    #find Bottom Face centroid\r\n                    BbFline=rs.AddCurve((ptDict[(i-1,j-1,k-1)],ptDict[(i,j,k-1)]))\r\n                    centFace=rs.AddPoint(rs.CurveMidPoint(BbFline))\r\n                    rs.DeleteObject(BbFline)\r\n                    #create construction surface to find grid of points\r\n                    srf = rs.AddSrfPt((ptDict[(i-1,j-1,k-1)], ptDict[(i-1,j,k-1)], \r\n                    ptDict[(i,j,k-1)], ptDict[(i,j-1,k-1)]))\r\n                    #scale srf\r\n                    rs.ScaleObject(srf,centFace,(sclF,sclF,sclF),False)\r\n                    #rebuild surface to create 4 x 4 grid (9 quadrants)\r\n                    rs.RebuildSurface(srf, (3,3), (4,4))\r\n                    #extract points from grid\r\n                    BbFpts = rs.SurfacePoints(srf)\r\n                    #call function to reveal order of points\r\n                    #numberPoints(BbFpts)\r\n                    #delete construction surface\r\n                    rs.DeleteObject(srf)\r\n                    rs.DeleteObject(centFace)\r\n                    \r\n                    \r\n                    #UPPER FACE\r\n                    #find Bottom Face centroid\r\n                    UpFline=rs.AddCurve((ptDict[(i-1,j-1,k)],ptDict[(i,j,k)]))\r\n                    centFace=rs.AddPoint(rs.CurveMidPoint(UpFline))\r\n                    rs.DeleteObject(UpFline)\r\n                    #create construction surface to find grid of points\r\n                    srf = rs.AddSrfPt((ptDict[(i-1,j-1,k)], ptDict[(i-1,j,k)], \r\n                    ptDict[(i,j,k)], ptDict[(i,j-1,k)]))\r\n                    #scale srf\r\n                    rs.ScaleObject(srf,centFace,(sclF,sclF,sclF),False)\r\n                    #rebuild surface to create 4 x 4 grid (9 quadrants)\r\n                    rs.RebuildSurface(srf, (3,3), (4,4))\r\n                    #extract points from grid\r\n                    UpFpts = rs.SurfacePoints(srf)\r\n                    #delete construction surface\r\n                    rs.DeleteObject(srf)\r\n                    rs.DeleteObject(centFace)\r\n                    \r\n                    \r\n                    ###CREATE CIRCLES###\r\n                    \r\n                    #DRAW FRONT-FACE AND BACK-FACE CIRCLES\r\n                    #random point from srf control points\r\n                    id=RndID(FFpts)                    \r\n                    #Draw a circle in Front/Back planes\r\n                    Fframe=PtFrame(FFpts[id],ptDict,'front')\r\n                    radius=RndRAD(5)\r\n                    FCircle=rs.AddCircle(Fframe,radius)                    \r\n                    #random point from srf control points\r\n                    id=RndID(BFpts)   \r\n                    Bframe=PtFrame(BFpts[id],ptDict,'back')\r\n                    radius=RndRAD(5)\r\n                    BCircle=rs.AddCircle(Bframe,radius)                    \r\n                    #Middle circle\r\n                    C1frame=PtFrame(centroid,ptDict,'front')\r\n                    MCircle1=rs.AddCircle(C1frame,midRad)\r\n                    \r\n                    \r\n                    #DRAW LEFT-FACE AND RIGHT-FACE CIRCLES\r\n                    #random point from srf control points\r\n                    id=RndID(LFpts)                    \r\n                    #Draw a circle in Front/Back planes\r\n                    Lframe=PtFrame(LFpts[id],ptDict,'left')\r\n                    radius=RndRAD(5)\r\n                    LCircle=rs.AddCircle(Lframe,radius)                    \r\n                    #random point from srf control points\r\n                    id=RndID(RFpts)   \r\n                    Rframe=PtFrame(RFpts[id],ptDict,'right')\r\n                    radius=RndRAD(5)\r\n                    RCircle=rs.AddCircle(Rframe,radius)                    \r\n                    #Middle circle\r\n                    C2frame=PtFrame(centroid,ptDict,'left')\r\n                    MCircle2=rs.AddCircle(C2frame,midRad)\r\n                    \r\n                    \r\n                    #DRAW BOTTOM-FACE AND UPPER-FACE CIRCLES\r\n                    #random point from srf control points\r\n                    id=RndID(BbFpts)                    \r\n                    #Draw a circle in Front/Back planes\r\n                    Bbframe=PtFrame(BbFpts[id],ptDict,'bott')\r\n                    radius=RndRAD(5)\r\n                    BbCircle=rs.AddCircle(Bbframe,radius)                    \r\n                    #random point from srf control points\r\n                    id=RndID(UpFpts)   \r\n                    Upframe=PtFrame(UpFpts[id],ptDict,'up')\r\n                    radius=RndRAD(5)\r\n                    UpCircle=rs.AddCircle(Upframe,radius)                    \r\n                    #Middle circle\r\n                    C3frame=PtFrame(centroid,ptDict,'bott')\r\n                    MCircle3=rs.AddCircle(C3frame,midRad)\r\n                    \r\n                    \r\n                    ###CREATE SURFACES###\r\n                    \r\n                    #Loft from Front to Back\r\n                    loft1=rs.AddLoftSrf((FCircle,MCircle1,BCircle))\r\n                    #rs.ObjectColor(loft1, (255/IMAX*i, 255-(255/JMAX)*j,255/KMAX*k))\r\n                    \r\n                    #loft from left to Right\r\n                    loft2=rs.AddLoftSrf((LCircle,MCircle2,RCircle))                    \r\n                    #rs.ObjectColor(loft2, (255/IMAX*i, 255-(255/JMAX)*j,255/KMAX*k))\r\n                    \r\n                    #loft from bottom to up\r\n                    loft3=rs.AddLoftSrf((BbCircle,MCircle3,UpCircle)) \r\n                    \r\n                    #Draw sphere\r\n                    if propGrid=='yes':\r\n                        sphere=rs.AddSphere(centroid,1.2*i)\r\n                    else:\r\n                        sphere=rs.AddSphere(centroid,1.2)\r\n                        \r\n                    rs.ObjectColor(sphere, (255/IMAX*i, 255-(255/JMAX)*j,255/KMAX*k))\r\n\r\n                    Obj=loft1+loft2+loft3\r\n                    rs.ObjectColor(Obj, (255/IMAX*i, 255-(255/JMAX)*j,255/KMAX*k))\r\n    return()\r\n\r\n\r\n##---MAIN RUN---#\r\n\r\ndef main():\r\n    #call function\r\n    rs.EnableRedraw(False)\r\n    \r\n    Pts3D,IMAX,JMAX,KMAX,propGrid=SetGrid()\r\n    wallType01(Pts3D,IMAX,JMAX,KMAX,propGrid)\r\n    \r\n    rs.EnableRedraw(True)\r\n\r\n#call main() function to start program\r\nmain()\r\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}