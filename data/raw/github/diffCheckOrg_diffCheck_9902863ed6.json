{
  "source_url": "https://github.com/diffCheckOrg/diffCheck/blob/8f668b1f273e8d81a282c6115ba3eae07eef9235/src/gh/diffCheck/diffCheck/df_cvt_bindings.py",
  "repo": "diffCheckOrg/diffCheck",
  "repo_stars": 15,
  "repo_description": "diffCheck is a CAD-integrated tool for evaluating digital timber fabrication processes.",
  "license": "GPL-3.0",
  "filepath": "src/gh/diffCheck/diffCheck/df_cvt_bindings.py",
  "instruction": "This module contains the utility functions to convert the data between the\n    Rhino, the basic diffCheck data structures and the diffCheck bindings.",
  "code": "#! python3\n\"\"\"\n    This module contains the utility functions to convert the data between the\n    Rhino, the basic diffCheck data structures and the diffCheck bindings.\n\"\"\"\n\nimport Rhino.Geometry as rg\nimport scriptcontext as sc\n\nimport System\nimport System.Drawing\n\nfrom typing import Any\n\nfrom diffCheck import diffcheck_bindings  # type: ignore\n\ndef test_bindings() -> Any:\n    \"\"\"\n        Test the bindings import.\n\n        :return is_imported: True if the bindings are imported, False otherwise\n    \"\"\"\n    return diffcheck_bindings.dfb_test.test()\n\ndef cvt_rhcloud_2_dfcloud(rh_cloud) -> diffcheck_bindings.dfb_geometry.DFPointCloud:\n    \"\"\"\n        Convert a Rhino cloud to a diffCheck cloud.\n\n        :param rh_cloud: rhino cloud\n\n        :return df_cloud: diffCheck cloud\n    \"\"\"\n\n    if not isinstance(rh_cloud, rg.PointCloud):\n        raise ValueError(\"rh_cloud for convertion should be a PointCloud\")\n\n    df_cloud = diffcheck_bindings.dfb_geometry.DFPointCloud()\n\n    # points\n    if rh_cloud.Count == 0:\n        print(\"The input rhino cloud is empty\")\n        return df_cloud\n    df_cloud.points = [[pt.X, pt.Y, pt.Z] for pt in rh_cloud]\n\n    # normals\n    if rh_cloud.ContainsNormals:\n        df_cloud.normals = [[n.X, n.Y, n.Z] for n in rh_cloud.GetNormals()]\n\n    # colors\n    if rh_cloud.ContainsColors:\n        df_cloud.colors = [[rh_c.R, rh_c.G, rh_c.B] for rh_c in rh_cloud.GetColors()]\n\n    return df_cloud\n\ndef cvt_dfcloud_2_rhcloud(df_cloud):\n    \"\"\"\n        Convert a diffCheck cloud to a Rhino cloud.\n\n        :param df_cloud: diffCheck cloud\n\n        :return rh_cloud: rhino cloud\n    \"\"\"\n    if not isinstance(df_cloud, diffcheck_bindings.dfb_geometry.DFPointCloud):\n        raise ValueError(\"df_cloud should be a DFPointCloud\")\n\n    rh_cloud = rg.PointCloud()\n\n    if len(df_cloud.points) == 0:\n        print(\"The input diffCheck cloud is empty\")\n        return rh_cloud\n\n    df_cloud_points = df_cloud.points\n    df_cloud_colors = df_cloud.colors\n    df_cloud_normals = df_cloud.normals\n\n    df_cloud_points = [rg.Point3d(pt[0], pt[1], pt[2]) for pt in df_cloud_points]\n    df_cloud_normals = [rg.Vector3d(n[0], n[1], n[2]) for n in df_cloud_normals]\n    df_cloud_colors = [System.Drawing.Color.FromArgb(c[0], c[1], c[2]) for c in df_cloud_colors]\n\n    rh_cloud = rg.PointCloud()\n\n    if df_cloud.has_normals() and df_cloud.has_colors():\n        rh_cloud.AddRange(df_cloud_points, df_cloud_normals, df_cloud_colors)\n    elif df_cloud.has_normals():\n        rh_cloud.AddRange(df_cloud_points, df_cloud_normals)\n    elif df_cloud.has_colors():\n        rh_cloud.AddRange(df_cloud_points)\n        for i, color in enumerate(df_cloud_colors):\n            rh_cloud[i].Color = color\n    else:\n        rh_cloud.AddRange(df_cloud_points)\n\n    return rh_cloud\n\ndef cvt_dfmesh_2_rhmesh(df_mesh: diffcheck_bindings.dfb_geometry.DFMesh) -> rg.Mesh:\n    \"\"\"\n        Convert a diffCheck mesh to a Rhino mesh.\n\n        :param df_mesh: diffCheck mesh\n\n        :return rh_mesh: rhino mesh\n    \"\"\"\n    if not isinstance(df_mesh, diffcheck_bindings.dfb_geometry.DFMesh):\n        raise ValueError(\"df_mesh should be a DFMesh\")\n\n    rh_mesh = rg.Mesh()\n\n    if len(df_mesh.vertices) == 0:\n        print(\"The input diffCheck mesh is empty\")\n        return rh_mesh\n\n    # vertices\n    for vertex in df_mesh.vertices:\n        rh_mesh.Vertices.Add(vertex[0], vertex[1], vertex[2])\n\n    # faces\n    for face in df_mesh.faces:\n        int_face = [int(f) for f in face]\n        rh_mesh.Faces.AddFace(int_face[0], int_face[1], int_face[2])\n\n    # normals\n    if len(df_mesh.normals_vertex) > 0:\n        for i, normal in enumerate(df_mesh.normals_vertex):\n            rh_mesh.Normals.SetNormal(i, normal[0], normal[1], normal[2])\n\n    # colors\n    if len(df_mesh.colors_vertex) > 0:\n        for i, color in enumerate(df_mesh.colors_vertex):\n            rh_mesh.VertexColors.SetColor(i, color[0], color[1], color[2])\n\n    return rh_mesh\n\ndef cvt_rhmesh_2_dfmesh(rh_mesh: rg.Mesh) -> diffcheck_bindings.dfb_geometry.DFMesh:\n    \"\"\"\n        Convert a Rhino mesh to a diffCheck mesh.\n\n        :param rh_mesh: rhino mesh\n\n        :return df_mesh: diffCheck mesh\n    \"\"\"\n    if not isinstance(rh_mesh, rg.Mesh):\n        raise ValueError(\"rh_mesh should be a Mesh\")\n\n    df_mesh = diffcheck_bindings.dfb_geometry.DFMesh()\n\n    if rh_mesh.Vertices.Count == 0:\n        print(\"The input rhino mesh is empty\")\n        return df_mesh\n\n    # vertices\n    rh_vertices = rh_mesh.Vertices.ToFloatArray()\n    vertices = []\n    for i in range(0, len(rh_vertices), 3):\n        vertices.append([rh_vertices[i], rh_vertices[i + 1], rh_vertices[i + 2]])\n    df_mesh.vertices = vertices\n\n    # faces\n    rh_faces = rh_mesh.Faces\n    faces = []\n    for i in range(len(rh_faces)):\n        face = rh_faces[i]\n        faces.append([face.A, face.B, face.C])\n    df_mesh.faces = faces\n\n    # normals\n    if rh_mesh.Normals.Count > 0:\n        normals = rh_mesh.Normals.ToFloatArray()\n        normals_vertex = []\n        for i in range(0, len(normals), 3):\n            normals_vertex.append([normals[i], normals[i + 1], normals[i + 2]])\n        df_mesh.normals_vertex = normals_vertex\n\n    # colors\n    if rh_mesh.VertexColors.Count > 0:\n        colors = rh_mesh.VertexColors.ToArgbColors()\n        colors_vertex = []\n        for i in range(len(colors)):\n            color = colors[i]\n            colors_vertex.append([color.R, color.G, color.B])\n        df_mesh.colors_vertex = colors_vertex\n\n    return df_mesh\n\ndef cvt_dfxform_2_rhxform(df_xform : diffcheck_bindings.dfb_transformation.DFTransformation) -> rg.Transform:\n    \"\"\"\n        Convert a diffCheck transformation to a Rhino transformation.\n\n        :param df_xform: diffCheck transformation\n        :return rh_xform: rhino transformation\n    \"\"\"\n    if not isinstance(df_xform, diffcheck_bindings.dfb_transformation.DFTransformation):\n        raise ValueError(\"df_xform should be a DFTransformation\")\n\n    rh_xform = rg.Transform()\n\n    # translation\n    translation = df_xform.translation_vector\n    rh_xform = rg.Transform.Translation(translation[0], translation[1], translation[2])\n\n    # rotation\n    rotation = df_xform.rotation_matrix\n    rh_xform = rh_xform * rg.Transform.Rotation(rotation[0], rg.Vector3d(rotation[1], rotation[2], rotation[3]), rg.Point3d(0, 0, 0))\n\n    return rh_xform\n\ndef cvt_dfOBB_2_rhbrep(df_OBB) -> rg.Box:\n    \"\"\" Convert a diffCheck OBB to a Rhino Brep.\n\n        :param df_OBB: diffCheck OBB\n\n        :return rh_obb_brep: the brep box object\n    \"\"\"\n    rh_pts = []\n    for pt in df_OBB:\n        rh_pts.append(rg.Point3d(pt[0], pt[1], pt[2]))\n\n    surfaces = []\n    surfaces.append(rg.NurbsSurface.CreateFromCorners(rh_pts[0], rh_pts[1], rh_pts[7], rh_pts[2]))\n    surfaces.append(rg.NurbsSurface.CreateFromCorners(rh_pts[0], rh_pts[1], rh_pts[6], rh_pts[3]))\n    surfaces.append(rg.NurbsSurface.CreateFromCorners(rh_pts[3], rh_pts[6], rh_pts[4], rh_pts[5]))\n    surfaces.append(rg.NurbsSurface.CreateFromCorners(rh_pts[2], rh_pts[7], rh_pts[4], rh_pts[5]))\n    surfaces.append(rg.NurbsSurface.CreateFromCorners(rh_pts[1], rh_pts[6], rh_pts[4], rh_pts[7]))\n    surfaces.append(rg.NurbsSurface.CreateFromCorners(rh_pts[0], rh_pts[3], rh_pts[5], rh_pts[2]))\n\n    rh_obb_brep = rg.Brep.JoinBreps([rg.Brep.CreateFromSurface(srf) for srf in surfaces], sc.doc.ModelAbsoluteTolerance)[0]\n\n    if rh_obb_brep is None:\n        raise ValueError(\"The OBB could not be converted to a Rhino Brep\")\n    if not rh_obb_brep.IsValid:\n        raise ValueError(\"The OBB Rhino Brep is not valid\")\n    if not rh_obb_brep.IsSolid:\n        raise ValueError(\"The OBB Rhino Brep is not solid\")\n\n    return rh_obb_brep\n\ndef cvt_ndarray_2_rh_transform(matrix) -> rg.Transform:\n    \"\"\"\n        Convert a numpy matrix to a Rhino transformation.\n        Useful to transform a DFTransformation-transformation_matrix to a Rhino transformation.\n\n        :param matrix: the numpy matrix\n\n        :return transfo: the Rhino transformation\n    \"\"\"\n    transfo = rg.Transform()\n    transfo.M00 = matrix[0, 0]\n    transfo.M01 = matrix[0, 1]\n    transfo.M02 = matrix[0, 2]\n    transfo.M03 = matrix[0, 3]\n    transfo.M10 = matrix[1, 0]\n    transfo.M11 = matrix[1, 1]\n    transfo.M12 = matrix[1, 2]\n    transfo.M13 = matrix[1, 3]\n    transfo.M20 = matrix[2, 0]\n    transfo.M21 = matrix[2, 1]\n    transfo.M22 = matrix[2, 2]\n    transfo.M23 = matrix[2, 3]\n    transfo.M30 = matrix[3, 0]\n    transfo.M31 = matrix[3, 1]\n    transfo.M32 = matrix[3, 2]\n    transfo.M33 = matrix[3, 3]\n    return transfo\n\n\ndef cvt_dfcloud_2_dict(df_cloud: diffcheck_bindings.dfb_geometry.DFPointCloud) -> dict:\n    \"\"\"\n        Convert a diffCheck cloud to a dictionary mainly for pickling and serialization.\n\n        :param df_cloud: diffCheck cloud\n        :return cloud_dict: the cloud dictionary\n    \"\"\"\n    cloud_dict = {\n        \"points\": df_cloud.points,\n        \"normals\": df_cloud.normals,\n        \"colors\": df_cloud.colors\n    }\n    return cloud_dict\n\ndef cvt_dict_2_dfcloud(cloud_dict: dict) -> diffcheck_bindings.dfb_geometry.DFPointCloud:\n    \"\"\"\n        Convert a dictionary to a diffCheck cloud mainly for pickling and deserialization.\n\n        :param cloud_dict: the cloud dictionary\n        :return df_cloud: diffCheck cloud\n    \"\"\"\n    df_cloud = diffcheck_bindings.dfb_geometry.DFPointCloud()\n    df_cloud.points = cloud_dict[\"points\"]\n    df_cloud.normals = cloud_dict[\"normals\"]\n    df_cloud.colors = cloud_dict[\"colors\"]\n    return df_cloud\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}