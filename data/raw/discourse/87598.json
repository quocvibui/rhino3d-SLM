{
  "source_url": "https://discourse.mcneel.com/t/how-to-optimise-ghpython-obj-export/87598",
  "topic_id": 87598,
  "title": "How to optimise GHPython OBJ export?",
  "question": "Hi,\n\n\nI’ve written this function to be able to export OBJs directly from GHPython inside Grasshopper. So far everything works fine, however dense meshes take quite some time to export. I’m thus looking for ways to optimise the code!\n\n\nimport os\n\ndef export_obj(mesh, path, filename):\n    \n    obj_fname = \"%s.%s\" %(filename, \"obj\")\n    mtl_fname = \"%s.%s\" %(filename, \"mtl\")\n    obj_fpath = os.path.join(path, obj_fname)\n    \n    header = \"# Rhino\\n\\nmtllib %s\\ng %s\\nusemtl diffuse_0_0_0_255\\n\" \\\n        %(mtl_fname, \"object_1\")\n    \n    with open(obj_fpath, 'w') as f:\n        f.write(header)\n        \n        for vtx in mesh.Vertices:\n            f.write(\"v %.4f %.4f %.4f\\n\" %(vtx.X, vtx.Y, vtx.Z))\n        \n        for uv in mesh.TextureCoordinates:\n            f.write(\"vt %.2f %.2f\\n\" %(uv[0], uv[1]))\n        \n        for vec in mesh.Normals:\n            f.write(\"vn %.4f %.4f %.4f\\n\" %(vec.X, vec.Y, vec.Z))\n        \n        for face in mesh.Faces:\n            f.write(\"f\")\n            for i in face:\n                f.write(\" %d/%d/%d\" % (i + 1, i + 1, i + 1))\n            f.write(\"\\n\")\n\n\n\nAny suggestions are welcome.",
  "code_blocks": [
    {
      "code": "dll_mesh2string = r'C:\\Users\\Terry\\source\\repos\\Mesh2String\\x64\\Release\\Mesh2String.dll'\n#dll_name = r'C:\\Users\\Terry\\Downloads\\float2string.dll'\nfrom scriptcontext import doc\nfrom time import time\nfrom ctypes import cdll, c_float, c_int, create_string_buffer, pointer, byref as c_byref\nfrom System.Threading import Tasks\nimport os\n\ndef export_obj(mesh, path, filename):\n\t\"\"\"\n\tExports the vertices with vertex colors, textures, normals and faces of a mesh to .obj file.\n\tParameters:\n\t\tmesh: Geometry of mesh to be exported.\n\t\tpath: Path to output file.\n\t\tfilename: Name of output file.\n\tReturns:\n\t\tNone\n\t\tThe mesh data is written to an .obj file.\n\t\"\"\"\n\t# Add .obj to end of file name.\n\tobj_fname = \"%s.%s\" %(filename, \"obj\")\n\t# Add mtl to end of file name for mtl line.\n\tmtl_fname = \"%s.%s\" %(filename, \"mtl\")\n\t# Create full path to output file.  Data will be written to this file.\n\tobj_fpath = os.path.join(path, obj_fname)\n\t\n\t#\n\t# Write out header to .obj file while still in Python.\n\t#\n\t#header = \"# Rhino\\n\\nmtllib %s\\nusemtl diffuse_0_0_0_255\\n\" \\\n\t#\t%(mtl_fname)\n\t# This writes header without extra blank line.\n\theader = \"# Rhino\\n\\nmtllib %s\\nusemtl %s\\n\" %(mtl_fname,filename)\n\twith open(obj_fpath, 'w') as f: f.write(header)\n\t#\n\t# Export mesh data to file\n\t#\n\ttimea = time()\n\t# Use DLL to speedup converting floating and integer numbers to string and writing to file.\n\tsoMesh2String = cdll.LoadLibrary(dll_mesh2string)\n\t# Convert mesh data to array or list.\n\ttimeb = time()\n\tprint 'Time to load DLL = {0:.4f} sec'.format(timeb-timea)\n\t# Use precision of 8 so all digits of single-precision floating point numbers in arrays is preserved.\n\tprecision = 8\n\t# Set precision for colors to 3 since RGB has max of 3 digits (256).\n\tc_precision = 3\n\t#\n\t# Extract data from mesh.\n\t#\n\ttimep = time()\n\t# Get local reference to mesh colors.\n\tvcolors = mesh.VertexColors\n\tnum_colors = vcolors.Count\n\t# Define function for use in parallel tasks.\n\tdef extract_data(i):\n\t\tif i == 0: return mesh.Vertices.ToFloatArray()\n\t\telif i == 1: return [color.ToArgb() for color in vcolors]\n\t\telif i == 2: return mesh.TextureCoordinates.ToFloatArray()\n\t\telif i == 3: return mesh.Normals.ToFloatArray()\n\t\telif i == 4: return mesh.Faces.ToIntArray(mesh.Faces.QuadCount == 0)\n\t# Size input & output lists to hold 5 entries.\n\tpieces, results = range(5), range(5)\n\t# Define helper procedure for feeding data choice to function and results to output list.\n\tdef helper(i): results[i] = extract_data(i)\n\t# Execute extra_data function in parallel.\n\tTasks.Parallel.ForEach(pieces, helper)\n\t# Enable next line and comment out above line for debug.\n\t#for i in pieces: helper(i)\n\t# Define local variables for extracted data.\n\tverts = results[0]\n\tcolors = results[1]\n\ttcs = results[2]\n\tnormals = results[3]\n\tfaces = results[4]\n\tprint 'Time to prep data = {0:.4f} sec'.format(time() - timep)\n\t# Define data limits to be used during parallel execution.\n\tQv = 3*((verts.Length//3)//4)\n\tHv = 3*((verts.Length//3)//2)\n\tQt = 3*((tcs.Length//3)//4)\n\tHt = 3*((tcs.Length//3)//2)\n\tQv = 3*((normals.Length//3)//4)\n\tHv = 3*((normals.Length//3)//2)\n\tQc = num_colors//4\n\tHc = num_colors//2\n\tQn = 3*((normals.Length//3)//4)\n\tHn = 3*((normals.Length//3)//2)\n\tE = 4*((faces.Length//4)//8)\n\tQ = 4*((faces.Length//4)//4)\n\tH = 4*((faces.Length//4)//2)\n\t# Define lengths of string buffer for holding long string result from one parallel task.\n\tvert_str_len = mesh.Vertices.Count//4*((precision+2)*3 + (c_precision+1)*3 + 3 + 2)\n\ttext_str_len = mesh.TextureCoordinates.Count//2*((precision+2)*2 + 4 + 2)\n\tnorm_str_len = mesh.Normals.Count//4*((precision+2)*3 + 4 + 2)\n\tface_str_len = mesh.Faces.Count//8*((precision+1)*9 + 3 + 2)\n\t#\n\t# Define function that selects number-to-string DLL converter for each parallel task.\n\t#\n\tdef function(i):\n\t\tglobal time0,time1,time2,time3,time4,time5,time6,time7,time8,time9,time10,time11,time12,time13,\\\n\t\t\ttime14,time15,time16,time17,time18,time19,time20,time21,time22,time23,time24,time25,time26,time27,\\\n\t\t\ttime28,time29,time30,time31,time32,time33,time34,time35\n\t\tif i == 0:\n\t\t\ttime0 = time()\n\t\t\tcstrv1 = create_string_buffer(vert_str_len)\n\t\t\tcverts1 = (c_float * (Qv))(); cverts1[:] = verts[:Qv]\n\t\t\tccolors1 = (c_int * (Qc))(); ccolors1[:] = colors[:Qc]\n\t\t\tcsizev1 = c_int(0)\n\t\t\tsoMesh2String.vertex2string1(precision, c_precision, cverts1, ccolors1, Qv, Qc, cstrv1, c_byref(csizev1))\n\t\t\t# Write results from first vertex group to file as part of parallel task.\n\t\t\t# Only this task can write to the file and be in the correct order.\n\t\t\t# Writes from following tasks have to wait until all tasks are complete.\n\t\t\tsoMesh2String.verts2file(obj_fpath, cstrv1, csizev1.value)\n\t\t\ttime1 = time()\n\t\t\treturn [cstrv1,csizev1.value]\n\t\telif i == 1:\n\t\t\ttime2 = time()\n\t\t\tcstrv2 = create_string_buffer(vert_str_len)\n\t\t\tcverts2 = (c_float * (Hv - Qv))(); cverts2[:] = verts[Qv:Hv]\n\t\t\tccolors2 = (c_int * (Hc - Qc))(); ccolors2[:] = colors[Qc:Hc]\n\t\t\tcsizev2 = c_int(0)\n\t\t\tsoMesh2String.vertex2string2(precision, c_precision, cverts2, ccolors2, Hv-Qv, Hc-Qc, cstrv2, c_byref(csizev2))\n\t\t\ttime3 = time()\n\t\t\treturn [cstrv2,csizev2.value]\n\t\telif i == 2:\n\t\t\ttime4 = time()\n\t\t\tcstrv3 = create_string_buffer(vert_str_len)\n\t\t\tcverts3 = (c_float * (Qv))(); cverts3[:] = verts[Hv:Hv+Qv]\n\t\t\tccolors3 = (c_int * (Qc))(); ccolors3[:] = colors[Hc:Hc+Qc]\n\t\t\tcsizev3 = c_int(0)\n\t\t\tsoMesh2String.vertex2string3(precision, c_precision, cverts3, ccolors3, Qv, Qc, cstrv3, c_byref(csizev3))\n\t\t\ttime5 = time()\n\t\t\treturn [cstrv3,csizev3.value]\n\t\telif i == 3:\n\t\t\ttime6 = time()\n\t\t\tcstrv4 = create_string_buffer(vert_str_len)\n\t\t\tcverts4 = (c_float * (verts.Length - Hv - Qv))(); cverts4[:] = verts[Hv+Qv:verts.Length]\n\t\t\tccolors4 = (c_int * (num_colors - Hc - Qc))(); ccolors4[:] = colors[Hc+Qc:num_colors]\n\t\t\tcsizev4 = c_int(0)\n\t\t\tsoMesh2String.vertex2string4(precision, c_precision, cverts4, ccolors4, verts.Length-Hv-Qv, num_colors-Hc-Qc, cstrv4, c_byref(csizev4))\n\t\t\ttime7 = time()\n\t\t\treturn [cstrv4,csizev4.value]\n\t\telif i == 4:\n\t\t\ttime8 = time()\n\t\t\tcstrt1 = create_string_buffer(text_str_len)\n\t\t\tctcs1 = (c_float * (Ht))(); ctcs1[:] = tcs[:Ht]\n\t\t\tcsizet1 = c_int(0)\n\t\t\tsoMesh2String.textures2string1(precision, ctcs1, Ht, cstrt1, c_byref(csizet1))\n\t\t\ttime9 = time()\n\t\t\treturn [cstrt1,csizet1.value]\n\t\telif i == 5:\n\t\t\ttime10 = time()\n\t\t\tcstrt2 = create_string_buffer(text_str_len)\n\t\t\tctcs2 = (c_float * (tcs.Length - Ht))(); ctcs2[:] = tcs[Ht:tcs.Length]\n\t\t\tcsizet2 = c_int(0)\n\t\t\tsoMesh2String.textures2string2(precision, ctcs2, tcs.Length-Ht, cstrt2, c_byref(csizet2))\n\t\t\ttime11 = time()\n\t\t\treturn [cstrt2,csizet2.value]\n\t\telif i == 6:\n\t\t\ttime12 = time()\n\t\t\tcstrn1 = create_string_buffer(norm_str_len)\n\t\t\tcnormals1 = (c_float * (Qn))(); cnormals1[:] = normals[:Qn]\n\t\t\tcsizen1 = c_int(0)\n\t\t\tsoMesh2String.normals2string1(precision, cnormals1, Qn, cstrn1, c_byref(csizen1))\n\t\t\ttime13 = time()\n\t\t\treturn [cstrn1,csizen1.value]\n\t\telif i == 7:\n\t\t\ttime14 = time()\n\t\t\tcstrn2 = create_string_buffer(norm_str_len)\n\t\t\tcnormals2 = (c_float * (Hn-Qn))(); cnormals2[:] = normals[Qn:Hn]\n\t\t\tcsizen2 = c_int(0)\n\t\t\tsoMesh2String.normals2string2(precision, cnormals2, Hn-Qn, cstrn2, c_byref(csizen2))\n\t\t\ttime15 = time()\n\t\t\treturn [cstrn2,csizen2.value]\n\t\telif i == 8:\n\t\t\ttime16 = time()\n\t\t\tcstrn3 = create_string_buffer(norm_str_len)\n\t\t\tcnormals3 = (c_float * (Qn))(); cnormals3[:] = normals[Hn:Hn+Qn]\n\t\t\tcsizen3 = c_int(0)\n\t\t\tsoMesh2String.normals2string3(precision, cnormals3, Qn, cstrn3, c_byref(csizen3))\n\t\t\ttime17 = time()\n\t\t\treturn [cstrn3,csizen3.value]\n\t\telif i == 9:\n\t\t\ttime18 = time()\n\t\t\tcstrn4 = create_string_buffer(norm_str_len)\n\t\t\tcnormals4 = (c_float * (normals.Length - Hn - Qn))(); cnormals4[:] = normals[Hn+Qn:normals.Length]\n\t\t\tcsizen4 = c_int(0)\n\t\t\tsoMesh2String.normals2string4(precision, cnormals4, normals.Length-Hn-Qn, cstrn4, c_byref(csizen4))\n\t\t\ttime19 = time()\n\t\t\treturn [cstrn4,csizen4.value]\n\t\telif i == 10:\n\t\t\ttime20 = time()\n\t\t\tcstrf1 = create_string_buffer(face_str_len)\n\t\t\tcfaces1 = (c_int * (E))(); cfaces1[:] = faces[:E]\n\t\t\tcsizef1 = c_int(0)\n\t\t\tsoMesh2String.faces2string1(precision, cfaces1, E, mesh.TextureCoordinates.Count, mesh.Normals.Count, cstrf1, c_byref(csizef1))\n\t\t\ttime21 = time()\n\t\t\treturn [cstrf1,csizef1.value]\n\t\telif i == 11:\n\t\t\ttime22 = time()\n\t\t\tcstrf2 = create_string_buffer(face_str_len)\n\t\t\tcfaces2 = (c_int * (Q-E))(); cfaces2[:] = faces[E:Q]\n\t\t\tcsizef2 = c_int(0)\n\t\t\tsoMesh2String.faces2string2(precision, cfaces2, Q-E, mesh.TextureCoordinates.Count, mesh.Normals.Count, cstrf2, c_byref(csizef2))\n\t\t\ttime23 = time()\n\t\t\treturn [cstrf2,csizef2.value]\n\t\telif i == 12:\n\t\t\ttime24 = time()\n\t\t\tcstrf3 = create_string_buffer(face_str_len)\n\t\t\tcfaces3 = (c_int * (E))(); cfaces3[:] = faces[Q:Q+E]\n\t\t\tcsizef3 = c_int(0)\n\t\t\tsoMesh2String.faces2string3(precision, cfaces3, E, mesh.TextureCoordinates.Count, mesh.Normals.Count, cstrf3, c_byref(csizef3))\n\t\t\ttime25 = time()\n\t\t\treturn [cstrf3,csizef3.value]\n\t\telif i == 13:\n\t\t\ttime26 = time()\n\t\t\tcstrf4 = create_string_buffer(face_str_len)\n\t\t\tcfaces4 = (c_int * (H-Q-E))(); cfaces4[:] = faces[Q+E:H]\n\t\t\tcsizef4 = c_int(0)\n\t\t\tsoMesh2String.faces2string4(precision, cfaces4, H-Q-E, mesh.TextureCoordinates.Count, mesh.Normals.Count, cstrf4, c_byref(csizef4))\n\t\t\ttime27 = time()\n\t\t\treturn [cstrf4,csizef4.value]\n\t\telif i == 14:\n\t\t\ttime28 = time()\n\t\t\tcstrf5 = create_string_buffer(face_str_len)\n\t\t\tcfaces5 = (c_int * (E))(); cfaces5[:] = faces[H:H+E]\n\t\t\tcsizef5 = c_int(0)\n\t\t\tsoMesh2String.faces2string5(precision, cfaces5, E, mesh.TextureCoordinates.Count, mesh.Normals.Count, cstrf5, c_byref(csizef5))\n\t\t\ttime29 = time()\n\t\t\treturn [cstrf5,csizef5.value]\n\t\telif i == 15:\n\t\t\ttime30 = time()\n\t\t\tcstrf6 = create_string_buffer(face_str_len)\n\t\t\tcfaces6 = (c_int * (Q-E))(); cfaces6[:] = faces[H+E:H+Q]\n\t\t\tcsizef6 = c_int(0)\n\t\t\tsoMesh2String.faces2string6(precision, cfaces6, Q-E, mesh.TextureCoordinates.Count, mesh.Normals.Count, cstrf6, c_byref(csizef6))\n\t\t\ttime31 = time()\n\t\t\treturn [cstrf6,csizef6.value]\n\t\telif i == 16:\n\t\t\ttime32 = time()\n\t\t\tcstrf7 = create_string_buffer(face_str_len)\n\t\t\tcfaces7 = (c_int * (E))(); cfaces7[:] = faces[H+Q:H+Q+E]\n\t\t\tcsizef7 = c_int(0)\n\t\t\tsoMesh2String.faces2string7(precision, cfaces7, E, mesh.TextureCoordinates.Count, mesh.Normals.Count, cstrf7, c_byref(csizef7))\n\t\t\ttime33 = time()\n\t\t\treturn [cstrf7,csizef7.value]\n\t\telif i == 17:\n\t\t\ttime34 = time()\n\t\t\tcstrf8 = create_string_buffer(face_str_len)\n\t\t\tcfaces8 = (c_int * (faces.Length-H-Q-E))(); cfaces8[:] = faces[H+Q+E:faces.Length]\n\t\t\tcsizef8 = c_int(0)\n\t\t\tsoMesh2String.faces2string8(precision, cfaces8, faces.Length-H-Q-E, mesh.TextureCoordinates.Count, mesh.Normals.Count, cstrf8, c_byref(csizef8))\n\t\t\ttime35 = time()\n\t\t\treturn [cstrf8,csizef8.value]\n\ttimeb = time()\n\t# Size input and output lists for 18 entries.\n\tpieces, results = range(18), range(18)\n\t# Define helper procedure for feeding data selector to function and results to output list.\n\tdef helper(piece): results[piece] = function(piece)\n\t#\n\t# Use parallel execution to translate mesh data to strings for output.\n\t# This is very effective because most of the time is spent in DLL's so\n\t# the Python interpreter is not a bottleneck to parallel execution.\n\t#\n\tTasks.Parallel.ForEach(pieces, helper)\n\t# Use next line for debugging.\n\t#for piece in pieces: helper(piece)\n\t#\n\t# Show timing summary to show effectiveness of balancing parallel tasks.\n\t#\n\tprint 'Time to run parallel Tasks = {0:.4f} sec'.format(time() - timeb)\n\tprint '    Time to export vertices1 = {0:.4f} sec.'.format(time1 -time0)\n\tprint '    Time to export vertices2 = {0:.4f} sec.'.format(time3 -time2)\n\tprint '    Time to export vertices3 = {0:.4f} sec.'.format(time5 -time4)\n\tprint '    Time to export vertices4 = {0:.4f} sec.'.format(time7 -time6)\n\tprint '    Time to export textures1 = {0:.4f} sec.'.format(time9 -time8)\n\tprint '    Time to export textures2 = {0:.4f} sec.'.format(time11 -time10)\n\tprint '    Time to export normals1 = {0:.4f} sec.'.format(time13 -time12)\n\tprint '    Time to export normals2 = {0:.4f} sec.'.format(time15 -time14)\n\tprint '    Time to export normals3 = {0:.4f} sec.'.format(time17 -time16)\n\tprint '    Time to export normals4 = {0:.4f} sec.'.format(time19 -time18)\n\tprint '    Time to export faces1 = {0:.4f} sec.'.format(time21 -time20)\n\tprint '    Time to export faces2 = {0:.4f} sec.'.format(time23 -time22)\n\tprint '    Time to export faces3 = {0:.4f} sec.'.format(time25 -time24)\n\tprint '    Time to export faces4 = {0:.4f} sec.'.format(time27 -time26)\n\tprint '    Time to export faces5 = {0:.4f} sec.'.format(time29 -time28)\n\tprint '    Time to export faces6 = {0:.4f} sec.'.format(time31 -time30)\n\tprint '    Time to export faces7 = {0:.4f} sec.'.format(time33 -time32)\n\tprint '    Time to export faces8 = {0:.4f} sec.'.format(time35 -time34)\n\t#\n\t# Call DLL to write data from tasks 1 to 17 to file.  Results from task0 have already been written.\n\t#\n\ttimews = time()\n\tsoMesh2String.data2file(obj_fpath, results[1][0], results[1][1], results[2][0],\n\tresults[2][1], results[3][0], results[3][1], results[4][0], results[4][1],\n\tresults[5][0], results[5][1], results[6][0], results[6][1], results[7][0],\n\tresults[7][1], results[8][0], results[8][1], results[8][0], results[9][1],\n\tresults[10][0], results[10][1], results[11][0], results[11][1],\n\tresults[12][0], results[12][1], results[13][0], results[13][1],\n\tresults[14][0], results[14][1], results[15][0], results[15][1],\n\tresults[16][0], results[16][1], results[17][0], results[17][1])\n\ttimew = time()\n\tprint 'Time to write data to file = {0:.4f} sec.'.format(timew - timews)\n\t\n\tprint 'Total time = {0:.4f} sec'.format(timew-timea)\n\n\n# The simple code here for testing the export_obj script expects that 1 mesh is displayed.  This mesh is exported to the .obj file.\nfrom rhinoscriptsyntax import ObjectsByType, VisibleObjects\n# This is used in place of rs.coercegeometry.\ndef getGeo(id): return doc.Objects.Find(id).Geometry\n# Get visible meshes.\nmeshes = [mesh for mesh in ObjectsByType(32, select=False) if (mesh in VisibleObjects())]\n# Report error for too few or too many visible meshes.\nif len(meshes) == 0: print 'ERROR: No visible mesh found. Please fix and try again.'; exit()\nif len(meshes) > 1: print 'ERROR: {} visible meshes found. Only 1 mesh is supported. Please fix and try again.'.format(len(meshes)); exit()\n# Get the 1 visible mesh and its geometry.\nmesh = meshes[0]\nmeshGeo = getGeo(mesh)\n# Export the mesh.\n#export_obj(meshGeo, \"C:\\Users\\Terry\\Documents\", \"myobj\")\nexport_obj(meshGeo, 'D:\\Photoscan', 'myobj')",
      "language": "python",
      "author": "Terry_Chappell",
      "post_number": 79,
      "is_solution": false
    },
    {
      "code": "// Mesh2String.cpp : Defines the exported functions for the DLL application.\n//\n\n#include \"stdafx.h\"\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nusing namespace std;\n\n#define DLLEXPORT extern \"C\" __declspec(dllexport)\n#define UCLASS()\n#define GENERATED_BODY()\n#define UFUNCTION()\n\nDLLEXPORT void vertex2string1(int precision, int c_precision, float *verts, int *colors, int num_verts, int num_colors, char *str, long &size_of_line) {\n\tstatic int pow10[10] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };\n\t// Used to convert to string.\n\tint a, b, c, k, l, m, i, j, i_begin, A, R, G, B;\n\tfloat f;\n\t// Process vertices.\n\t// Save starting value of i.\n\ti = 0;\n\ti_begin = i;\n\tfor (j = 0; j < num_verts; j += 3) {\n\t\t// Do first value.\n\t\tf = verts[j];\n\t\t// Start vertex line with 'v '.\n\t\tstr[i++] = 'v';\n\t\tstr[i++] = ' ';\n\t\t// check for negative float\n\t\tif (f < 0.0) {\n\t\t\tstr[i++] = '-';\n\t\t\tf *= -1;\n\t\t}\n\t\t// Extract the whole number.\n\t\ta = f;\n\t\t// Extract the decimal part.\n\t\tf -= a;\n\t\tk = precision;\n\t\t// Get the number of digits in the whole number = k+1.\n\t\t// This loop finishes sooner when there are more digits.\n\t\twhile (k > -1) {\n\t\t\tl = pow10[k];\n\t\t\tm = a / l;\n\t\t\tif (m > 0) { break; }\n\t\t\tk--;\n\t\t}\n\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\tb = pow10[l - 1];\n\t\t\tc = a / b;\n\t\t\tstr[i++] = c + 48;\n\t\t\ta %= b;\n\t\t}\n\t\t// Add decimal point.\n\t\tstr[i++] = '.';\n\t\t// Extract decimal digits till precision met.\n\t\tfor (l = 0; l < precision - k - 1; l++) {\n\t\t\tf *= 10.0;\n\t\t\tb = f;\n\t\t\tstr[i++] = b + 48;\n\t\t\tf -= b;\n\t\t}\n\t\t// Do second value.\n\t\tf = verts[j + 1];\n\t\tstr[i++] = ' ';\n\t\t// check for negative float\n\t\tif (f < 0.0) {\n\t\t\tstr[i++] = '-';\n\t\t\tf *= -1;\n\t\t}\n\t\t// Extract the whole number.\n\t\ta = f;\n\t\t// Extract the decimal part.\n\t\tf -= a;\n\t\tk = precision;\n\t\t// Get the number of digits in the whole number = k+1.\n\t\twhile (k > -1) {\n\t\t\tl = pow10[k];\n\t\t\tm = a / l;\n\t\t\tif (m > 0) { break; }\n\t\t\tk--;\n\t\t}\n\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\tb = pow10[l - 1];\n\t\t\tc = a / b;\n\t\t\tstr[i++] = c + 48;\n\t\t\ta %= b;\n\t\t}\n\t\t// Add decimal point.\n\t\tstr[i++] = '.';\n\t\t// Extract decimal digits till precision met.\n\t\tfor (l = 0; l < precision - k - 1; l++) {\n\t\t\tf *= 10.0;\n\t\t\tb = f;\n\t\t\tstr[i++] = b + 48;\n\t\t\tf -= b;\n\t\t}\n\t\t// Do third value.\n\t\tf = verts[j + 2];\n\t\tstr[i++] = ' ';\n\t\t// check for negative float\n\t\tif (f < 0.0) {\n\t\t\tstr[i++] = '-';\n\t\t\tf *= -1;\n\t\t}\n\t\t// Extract the whole number.\n\t\ta = f;\n\t\t// Extract the decimal part.\n\t\tf -= a;\n\t\tk = precision;\n\t\t// Get the number of digits in the whole number = k+1.\n\t\twhile (k > -1) {\n\t\t\tl = pow10[k];\n\t\t\tm = a / l;\n\t\t\tif (m > 0) { break; }\n\t\t\tk--;\n\t\t}\n\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\tb = pow10[l - 1];\n\t\t\tc = a / b;\n\t\t\tstr[i++] = c + 48;\n\t\t\ta %= b;\n\t\t}\n\t\t// Add decimal point.\n\t\tstr[i++] = '.';\n\t\t// Extract decimal digits till precision met.\n\t\tfor (l = 0; l < precision - k - 1; l++) {\n\t\t\tf *= 10.0;\n\t\t\tb = f;\n\t\t\tstr[i++] = b + 48;\n\t\t\tf -= b;\n\t\t}\n\t\t// Add vertex color if present.\n\t\tif (num_colors) {\n\t\t\t// Put space after Z of vertex.\n\t\t\tstr[i++] = ' ';\n\t\t\t// Get 32-bit color to convert.\n\t\t\ta = colors[j / 3];\n\t\t\t// Convert to normalize R,G,B.\n\t\t\t// Shift off possible A.\n\t\t\tA = a >> 24;\n\t\t\ta -= (A << 24);\n\t\t\tR = a >> 16;\n\t\t\ta -= (R << 16);\n\t\t\tG = a >> 8;\n\t\t\tB = a - (G << 8);\n\t\t\t// Do first value.\n\t\t\ta = R;\n\t\t\tk = c_precision;\n\t\t\t// Get the number of digits in the whole number = k+1.\n\t\t\twhile (k > -1) {\n\t\t\t\tl = pow10[k];\n\t\t\t\tm = a / l;\n\t\t\t\tif (m > 0) { break; }\n\t\t\t\tk--;\n\t\t\t}\n\t\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\t\tb = pow10[l - 1];\n\t\t\t\tc = a / b;\n\t\t\t\tstr[i++] = c + 48;\n\t\t\t\ta %= b;\n\t\t\t}\n\t\t\t// Do second value.\n\t\t\t// Put space after R.\n\t\t\tstr[i++] = ' ';\n\t\t\ta = G;\n\t\t\tk = c_precision;\n\t\t\t// Get the number of digits in the whole number = k+1.\n\t\t\twhile (k > -1) {\n\t\t\t\tl = pow10[k];\n\t\t\t\tm = a / l;\n\t\t\t\tif (m > 0) { break; }\n\t\t\t\tk--;\n\t\t\t}\n\t\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\t\tb = pow10[l - 1];\n\t\t\t\tc = a / b;\n\t\t\t\tstr[i++] = c + 48;\n\t\t\t\ta %= b;\n\t\t\t}\n\t\t\t// Do third value.\n\t\t\t// Put space after G.\n\t\t\tstr[i++] = ' ';\n\t\t\ta = B;\n\t\t\tk = c_precision;\n\t\t\t// Get the number of digits in the whole number = k+1.\n\t\t\twhile (k > -1) {\n\t\t\t\tl = pow10[k];\n\t\t\t\tm = a / l;\n\t\t\t\tif (m > 0) { break; }\n\t\t\t\tk--;\n\t\t\t}\n\t\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\t\tb = pow10[l - 1];\n\t\t\t\tc = a / b;\n\t\t\t\tstr[i++] = c + 48;\n\t\t\t\ta %= b;\n\t\t\t}\n\t\t\t// Add CR LF to terminate line with vertex and colors.\n\t\t\tstr[i++] = '\\r';\n\t\t\tstr[i++] = '\\n';\n\t\t}\n\t\telse {\n\t\t\t// Add CR LF when no color.\n\t\t\tstr[i++] = '\\r';\n\t\t\tstr[i++] = '\\n';\n\t\t}\n\t}\n\t// Write vertex lines to file.\n\tsize_of_line = i - i_begin;\n}",
      "language": "csharp",
      "author": "Terry_Chappell",
      "post_number": 79,
      "is_solution": false
    },
    {
      "code": "import Rhino.Geometry as rg\nimport os\n\ndef export_obj(mesh, path, filename):\n    obj_fname = \"%s.%s\" %(filename, \"obj\")\n    mtl_fname = \"%s.%s\" %(filename, \"mtl\")\n    obj_fpath = os.path.join(path, obj_fname)\n    \n    header = \"# Rhino\\n\\nmtllib %s\\ng %s\\nusemtl diffuse_0_0_0_255\\n\" \\\n        %(mtl_fname, \"object_1\")\n    \n    vertices_info = [\"v %.4f %.4f %.4f\\n\" %(v.X, v.Y, v.Z) for v in mesh.Vertices]\n    coords_info = [\"vt %.2f %.2f\\n\" %(uv[0], uv[1]) for uv in mesh.TextureCoordinates]\n    normals_info = [\"vn %.4f %.4f %.4f\\n\" %(v.X, v.Y, v.Z) for v in mesh.Normals]\n    \n    faces_info = []\n    for face in mesh.Faces:\n            face_info = [\"f\"]\n            for i in face:\n                face_info.append(\" %d/%d/%d\" % (i + 1, i + 1, i + 1))\n            face_info.append(\"\\n\")\n            \"\".join(face_info)\n            faces_info.extend(face_info)\n    \n    all_info = \"%s%s%s%s%s\" %(header, \"\".join(vertices_info), \"\".join(coords_info), \"\".join(normals_info), \"\".join(faces_info))\n    \n    with open(obj_fpath, 'w') as f:\n        f.write(all_info)",
      "language": "python",
      "author": "diff-arch",
      "post_number": 24,
      "is_solution": false
    },
    {
      "code": "import Rhino.Geometry as rg\nimport os\nimport time\n\ndef export_obj(mesh, path, filename):\n    start = time.clock()\n    obj_fname = \"%s.%s\" %(filename, \"obj\")\n    mtl_fname = \"%s.%s\" %(filename, \"mtl\")\n    obj_fpath = os.path.join(path, obj_fname)\n    \n    header = \"# Rhino\\n\\nmtllib %s\\ng %s\\nusemtl diffuse_0_0_0_255\\n\" \\\n        %(mtl_fname, \"object_1\")\n    \n    vertices_info = [\"v %.4f %.4f %.4f\\n\" %(v.X, v.Y, v.Z) for v in mesh.Vertices]\n    coords_info = [\"vt %.2f %.2f\\n\" %(uv.X, uv.Y) for uv in mesh.TextureCoordinates]\n    normals_info = [\"vn %.4f %.4f %.4f\\n\" %(v.X, v.Y, v.Z) for v in mesh.Normals]\n    \n    faces_info = []\n    for face in mesh.Faces:\n            face_info = [\"f\"]\n            for i in face:\n                face_info.append(\" %d/%d/%d\" % (i + 1, i + 1, i + 1))\n            face_info.append(\"\\n\")\n            \"\".join(face_info)\n            faces_info.extend(face_info)\n    \n    all_info = \"%s%s%s%s%s\" %(header, \"\".join(vertices_info), \"\".join(coords_info), \"\".join(normals_info), \"\".join(faces_info))\n    str_time = time.clock()\n    print str_time - start\n    \n    with open(obj_fpath, 'w') as f:\n        f.write(all_info)\n    print time.clock() - str_time\n\nexport_obj(x, r\"C:\\\\Users\\\\KNAPP\", \"piratetest\")",
      "language": "python",
      "author": "Dancergraham",
      "post_number": 25,
      "is_solution": false
    },
    {
      "code": "import Rhino.Geometry as rg\nimport os\nimport time\n\ndef export_obj(mesh, path, filename):\n    now = time.clock()\n    obj_fname = \"%s.%s\" %(filename, \"obj\")\n    mtl_fname = \"%s.%s\" %(filename, \"mtl\")\n    obj_fpath = os.path.join(path, obj_fname)\n    \n    header = \"# Rhino\\n\\nmtllib %s\\ng %s\\nusemtl diffuse_0_0_0_255\\n\" \\\n        %(mtl_fname, \"object_1\")\n    \n    vertices_info = [\"v %.4f %.4f %.4f\\n\" %(v.X, v.Y, v.Z) for v in mesh.Vertices]\n    coords_info = [\"vt %.2f %.2f\\n\" %(uv.X, uv.Y) for uv in mesh.TextureCoordinates]\n    normals_info = [\"vn %.4f %.4f %.4f\\n\" %(v.X, v.Y, v.Z) for v in mesh.Normals]\n    \n    then, now = now, time.clock()\n    print \"Build 3 info lists %.3f seconds\" % (now - then)\n    \n    faces_info = []\n    for face in mesh.Faces:\n            face_info = [\"f\"]\n            for i in face:\n                face_info.append(\" %d/%d/%d\" % (i + 1, i + 1, i + 1))\n            face_info.append(\"\\n\")\n            \"\".join(face_info)\n            faces_info.extend(face_info)\n            \n    then, now = now, time.clock()\n    print \"Build face info list %.3f seconds\" % (now - then)\n    \n    all_info = \"%s%s%s%s%s\" %(header, \"\".join(vertices_info), \"\".join(coords_info), \"\".join(normals_info), \"\".join(faces_info))\n\n    then, now = now, time.clock()\n    print \"Build all info list %.3f seconds\" % (now - then)\n    \n    with open(obj_fpath, 'w') as f:\n        f.write(all_info)\n        \n    then, now = now, time.clock()\n    print \"Write file %.3f seconds\" % (now - then)\n\nexport_obj(x, r\"C:\\\\Users\\\\KNAPP\", \"piratetest\")",
      "language": "python",
      "author": "Dancergraham",
      "post_number": 26,
      "is_solution": false
    },
    {
      "code": "import Rhino.Geometry as rg\nimport os\n\ndef export_obj(mesh, path, filename):\n    obj_fname = \"%s.%s\" %(filename, \"obj\")\n    mtl_fname = \"%s.%s\" %(filename, \"mtl\")\n    obj_fpath = os.path.join(path, obj_fname)\n    \n    header = \"# Rhino\\n\\nmtllib %s\\ng %s\\nusemtl diffuse_0_0_0_255\\n\" \\\n        %(mtl_fname, \"object_1\")\n    \n    with open(obj_fpath, 'w') as f:\n        f.write(header)\n        \n        verts = mesh.Vertices.ToFloatArray()\n        for i in xrange(0, verts.Length, 3):\n            f.write(\"v %.4f %.4f %.4f\\n\" %(verts[i], verts[i+1], verts[i+2]))\n        \n        tcs = mesh.TextureCoordinates.ToFloatArray();\n        for i in xrange(0, tcs.Length, 2):\n            f.write(\"vt %.2f %.2f\\n\" %(tcs[i], tcs[i+1]))\n        \n        normals = mesh.Normals.ToFloatArray();\n        for i in xrange(0, normals.Length, 3):\n            f.write(\"vn %.4f %.4f %.4f\\n\" %(normals[i], normals[i+1], normals[i+2]))\n        \n        faces = mesh.Faces.ToIntArray(True)\n        for i in xrange(0, faces.Length, 3):\n            a = faces[i]+1\n            b = faces[i+1]+1\n            c = faces[i+2]+1\n            f.write(\"f %d/%d/%d %d/%d/%d %d/%d/%d\\n\" % (a,a,a,b,b,b,c,c,c))\n            \nexport_obj(mesh, \"C:\\\\dev\\\\\", \"myobj.obj\")",
      "language": "python",
      "author": "stevebaer",
      "post_number": 29,
      "is_solution": false
    },
    {
      "code": "import Rhino.Geometry as rg\nfrom scriptcontext import doc\nfrom rhinoscriptsyntax import ObjectsByType, VisibleObjects\nfrom time import time\nimport os\n\n# This is used in place of rs.coercegeometry.\ndef getGeo(id): return doc.Objects.Find(id).Geometry\n\ndef export_obj(mesh, path, filename):\n\tobj_fname = \"%s.%s\" %(filename, \"obj\")\n\tmtl_fname = \"%s.%s\" %(filename, \"mtl\")\n\tobj_fpath = os.path.join(path, obj_fname)\n\t\n\theader = \"# Rhino\\n\\nmtllib %s\\ng %s\\nusemtl diffuse_0_0_0_255\\n\" \\\n\t\t%(mtl_fname, \"object_1\")\n\t\n\twith open(obj_fpath, 'w') as f:\n\t\tf.write(header)\n\t\ttimea = time()\n\t\tverts = mesh.Vertices.ToFloatArray()\n\t\tfor i in xrange(0, verts.Length, 3):\n\t\t\tf.write(\"v %.4f %.4f %.4f\\n\" %(verts[i], verts[i+1], verts[i+2]))\n\t\ttimeb = time()\n\t\ttcs = mesh.TextureCoordinates.ToFloatArray();\n\t\tfor i in xrange(0, tcs.Length, 2):\n\t\t\tf.write(\"vt %.2f %.2f\\n\" %(tcs[i], tcs[i+1]))\n\t\ttimec = time()\n\t\tnormals = mesh.Normals.ToFloatArray();\n\t\tfor i in xrange(0, normals.Length, 3):\n\t\t\tf.write(\"vn %.4f %.4f %.4f\\n\" %(normals[i], normals[i+1], normals[i+2]))\n\t\ttimed = time()\n\t\tfaces = mesh.Faces.ToIntArray(True)\n\t\tfor i in xrange(0, faces.Length, 3):\n\t\t\ta = faces[i]+1\n\t\t\tb = faces[i+1]+1\n\t\t\tc = faces[i+2]+1\n\t\t\tf.write(\"f %d/%d/%d %d/%d/%d %d/%d/%d\\n\" % (a,a,a,b,b,b,c,c,c))\n\t\ttimee = time()\n\t\tprint 'Time to write vertices = {0:.4f} sec\\nTime to write textures = {1:.4f} sec\\nTime to write normals = {2:.4f}\\nTime to write faces = {3:.4f}\\nTotal Time = {4:.4f} sec'\\\n\t\t\t.format(timeb-timea, timec-timeb, timed - timec, timee - timed, timee - timea)\n\t\t\t\n# Get visible meshes.\nmeshes = [mesh for mesh in ObjectsByType(32, select=False) if (mesh in VisibleObjects())]\n# Report error for too few or too many visible meshes.\nif len(meshes) == 0: print 'ERROR: No visible mesh found. Please fix and try again.'; exit()\nif len(meshes) > 1: print 'ERROR: {} visible meshes found. Only 1 mesh is supported. Please fix and try again.'.format(len(meshes)); exit()\n# Get the 1 visible mesh and its geometry.\nmesh = meshes[0]\nmeshGeo = getGeo(mesh)\n# Export the mesh.\nexport_obj(meshGeo, \"C:\\Users\\Terry\\Documents\", \"myobj\")",
      "language": "python",
      "author": "Terry_Chappell",
      "post_number": 30,
      "is_solution": false
    },
    {
      "code": "#dll_name = r'C:\\Users\\Terry\\source\\repos\\float2string\\x64\\Release\\float2string.dll'\ndll_name = r'C:\\Users\\Terry\\Downloads\\float2string.dll'\nfrom scriptcontext import doc\nfrom time import time\nfrom ctypes import cdll, c_float, c_int, create_string_buffer, pointer\nimport os\n\ndef export_obj(mesh, path, filename):\n\tobj_fname = \"%s.%s\" %(filename, \"obj\")\n\tmtl_fname = \"%s.%s\" %(filename, \"mtl\")\n\tobj_fpath = os.path.join(path, obj_fname)\n\t\n\t# Write out header while still in Python.\n\t#header = \"# Rhino\\n\\nmtllib %s\\nusemtl diffuse_0_0_0_255\\n\" \\\n\t#\t%(mtl_fname)\n\theader = \"# Rhino\\n\\nmtllib %s\\nusemtl %s\\n\" %(mtl_fname,filename)\n\twith open(obj_fpath, 'w') as f: f.write(header)\n\t\n\t# Export mesh data to file\n\ttimea = time()\n\t# Use DLL to speedup converting floating and integer numbers to string and writing to file.\n\tsoFloat2String = cdll.LoadLibrary(dll_name)\n\tvcolors = mesh.VertexColors\n\t# Convert mesh data to array or list.\n\tverts = mesh.Vertices.ToFloatArray()\n\tcolors = [color.ToArgb() for color in vcolors]; num_colors = len(colors) # No .ToFloatArray for colors!\n\ttcs = mesh.TextureCoordinates.ToFloatArray()\n\tnormals = mesh.Normals.ToFloatArray()\n\tfaces = mesh.Faces.ToIntArray(False)\n\ttimeb = time()\n\t# Use precision of 8 so all digits of single-precision floating point numbers in arrays is preserved.\n\t# This result in a range of 99999999. to 0.12345678 when all precision is preserved.\n\t# If your mesh has vertices more than 99,999,999 away from the origin, then the conversion will fail.\n\t# If your mesh has vertices closer than 0.1 to the origin, then the precision will be reduced but never fail.\n\t# If your mesh has more than 999,999,999 vertices, then the conversion for faces will fail.\n\tprecision = 8\n\t# Set precision for colors to 4 since RGB has max of 3 digits (256).\n\tc_precision = 4\n\t# Define c-types variables for passing mesh arrays to DLL.\n\tcverts = (c_float * (verts.Length))(); cverts[:] = verts\n\tnum_colors = vcolors.Count\n\tccolors = (c_int * (num_colors))(); ccolors[:] = colors\n\tctcs = (c_float * (tcs.Length))(); ctcs[:] = tcs\n\tcnormals = (c_float * (normals.Length))(); cnormals[:] = normals\n\tcfaces = (c_int * (faces.Length))(); cfaces[:] = faces\n\t# Define string buffer for holding 1 line of output. The largest case is for a mesh face.\n\t# f 99123456/99123456/99123456 99123456/99123456/99123456 99123456/99123456/99123456 + 2 CRLF + 2 extra\n\t# Formula is: (precision+1)*9 + 3 = 84 for 8-digit precision + 2 extra = 86\n\t# (precision+1)*6 + 3 if only normal or texture = 51 + 2 = 53\n\t# (precision+1)*3 + 3 if no normal or texture = 30 +2 = 53\n\t# For vertex: (precision+2)*3 + (c_precision+2)*3 + 3 = 51 + 2 = 53\n\tcstr = create_string_buffer((precision+1)*9 + 3 + 2) # Covers maximum faces case.\n\t# NOTE: Could use 1.5GB cstr buffer and make 1 string for each array and then write whole array at once.\n\t# Saves 5 sec due to fewer writes or 9%.  Not worth the trouble as this limits the\n\t# max mesh size to 18M faces.  For 100M faces would need 7.5GB buffer which is too big.\n\ttimec = time()\n\t# Call DLL to convert values to strings and do binary write to file.\n\tsoFloat2String.vertex2string(obj_fpath, precision, c_precision, cverts, ccolors, ctcs, cnormals, cfaces,\n\t\tverts.Length, num_colors, tcs.Length, normals.Length, faces.Length, cstr)\n\ttimed = time()\n\tprint 'Time to convert mesh data to arrays = {0:.4f} sec'.format(timeb-timea)\n\tprint 'Time to load mesh data into c-types variables = {0:.4f}'.format(timec-timeb)\n\tprint 'Time for DLL to write {0:,} faces, {1:,} vertices, {2:,} colors, {3:,} texture coords, {4:,} normals to file = {5:.4f} sec'\\\n\t\t.format(faces.Length//4, verts.Length//3, num_colors, tcs.Length//2, normals.Length//3, timed-timec)\n\tprint 'Total time = {0:.4f} sec'.format(timed-timea) \n\n# The simple code for testing expects 1 mesh is displayed.  This mesh is written out as an .obj file.\nfrom rhinoscriptsyntax import ObjectsByType, VisibleObjects\n# This is used in place of rs.coercegeometry.\ndef getGeo(id): return doc.Objects.Find(id).Geometry\n# Get visible meshes.\nmeshes = [mesh for mesh in ObjectsByType(32, select=False) if (mesh in VisibleObjects())]\n# Report error for too few or too many visible meshes.\nif len(meshes) == 0: print 'ERROR: No visible mesh found. Please fix and try again.'; exit()\nif len(meshes) > 1: print 'ERROR: {} visible meshes found. Only 1 mesh is supported. Please fix and try again.'.format(len(meshes)); exit()\n# Get the 1 visible mesh and its geometry.\nmesh = meshes[0]\nmeshGeo = getGeo(mesh)\n# Export the mesh.\nexport_obj(meshGeo, \"C:\\Users\\Terry\\Documents\", \"myobj\")",
      "language": "python",
      "author": "Terry_Chappell",
      "post_number": 44,
      "is_solution": false
    },
    {
      "code": "// float2string.cpp : Defines the exported functions for the DLL application.\n//\n\n#include \"stdafx.h\"\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>     // for _countof\n\nusing namespace std;\n\n#define DLLEXPORT extern \"C\" __declspec(dllexport)\n#define UCLASS()\n#define GENERATED_BODY()\n#define UFUNCTION()\n\nDLLEXPORT void vertex2string(wchar_t *file_name, int precision, int c_precision, float *verts, int *colors, float *tcs, float *normals,\n\tint *faces, int num_verts, int num_colors, int num_tcs,int num_normals, int num_faces, char *str) {\n\tstatic int pow10[10] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };\n\t// Used to convert to string.\n\tint a, b, c, k, l = 0, m, n, i = 0, j, i_begin, A, R, G, B;\n\t// Used when processing faces.\n\tint i1, i2, i3, i4, i_start, i_end;\n\tfloat f, f1, f2, f3;\n\t// Setup flags that control generation of texture coordinants and vertex normals.\n\tbool do_one = false, do_tcs = false, do_normals = false, q;\n\tif (num_tcs) { do_tcs = true; }\n\tif (num_normals) { do_normals = true; }\n\tif (num_tcs or num_normals) { do_one = true; }\n\t//\n\t// Open file for binary write.\n\t//\n\t// Set size_of_line as streampos type so multi-line output can be supported.\n\tstreampos size_of_line = 0;\n\t// Open file for binary writing at end of exising file (to preserve header written in Python script).\n\tofstream out_file(file_name, ios::binary | ios::out | ios:: app);\n\tif (out_file.is_open()) {\n\t\t// Process vertices.\n\t\tfor (j = 0; j < num_verts; j += 3) {\n\t\t\t// Save starting value of i.\n\t\t\ti = 0;\n\t\t\ti_begin = i;\n\t\t\t// Get X,Y,Z values to convert.\n\t\t\tf1 = verts[j]; f2 = verts[j + 1]; f3 = verts[j + 2];\n\t\t\t// Do first value.\n\t\t\tf = f1;\n\t\t\t// Start vertex line with 'v '.\n\t\t\tstr[i++] = 'v';\n\t\t\tstr[i++] = ' ';\n\t\t\t// check for negative float\n\t\t\tif (f < 0.0) {\n\t\t\t\tstr[i++] = '-';\n\t\t\t\tf *= -1;\n\t\t\t}\n\t\t\t// Extract the whole number.\n\t\t\ta = f;\n\t\t\t// Extract the decimal part.\n\t\t\tf -= a;\n\t\t\tk = precision;\n\t\t\t// Get the number of digits in the whole number = k+1.\n\t\t\twhile (k > -1) {\n\t\t\t\tl = pow10[k];\n\t\t\t\tm = a / l;\n\t\t\t\tif (m > 0) { break; }\n\t\t\t\tk--;\n\t\t\t}\n\t\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\t\tb = pow10[l - 1];\n\t\t\t\tc = a / b;\n\t\t\t\tstr[i++] = c + 48;\n\t\t\t\ta %= b;\n\t\t\t}\n\t\t\t// Add decimal point.\n\t\t\tstr[i++] = '.';\n\t\t\t// Extract decimal digits till precision met.\n\t\t\tfor (l = 0; l < precision - k - 1; l++) {\n\t\t\t\tf *= 10.0;\n\t\t\t\tb = f;\n\t\t\t\tstr[i++] = b + 48;\n\t\t\t\tf -= b;\n\t\t\t}\n\t\t\t// Do second value.\n\t\t\tf = f2;\n\t\t\tstr[i++] = ' ';\n\t\t\t// check for negative float\n\t\t\tif (f < 0.0) {\n\t\t\t\tstr[i++] = '-';\n\t\t\t\tf *= -1;\n\t\t\t}\n\t\t\t// Extract the whole number.\n\t\t\ta = f;\n\t\t\t// Extract the decimal part.\n\t\t\tf -= a;\n\t\t\tk = precision;\n\t\t\t// Get the number of digits in the whole number = k+1.\n\t\t\twhile (k > -1) {\n\t\t\t\tl = pow10[k];\n\t\t\t\tm = a / l;\n\t\t\t\tif (m > 0) { break; }\n\t\t\t\tk--;\n\t\t\t}\n\t\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\t\tb = pow10[l - 1];\n\t\t\t\tc = a / b;\n\t\t\t\tstr[i++] = c + 48;\n\t\t\t\ta %= b;\n\t\t\t}\n\t\t\t// Add decimal point.\n\t\t\tstr[i++] = '.';\n\t\t\t// Extract decimal digits till precision met.\n\t\t\tfor (l = 0; l < precision - k - 1; l++) {\n\t\t\t\tf *= 10.0;\n\t\t\t\tb = f;\n\t\t\t\tstr[i++] = b + 48;\n\t\t\t\tf -= b;\n\t\t\t}\n\t\t\t// Do third value.\n\t\t\tf = f3;\n\t\t\tstr[i++] = ' ';\n\t\t\t// check for negative float\n\t\t\tif (f < 0.0) {\n\t\t\t\tstr[i++] = '-';\n\t\t\t\tf *= -1;\n\t\t\t}\n\t\t\t// Extract the whole number.\n\t\t\ta = f;\n\t\t\t// Extract the decimal part.\n\t\t\tf -= a;\n\t\t\tk = precision;\n\t\t\t// Get the number of digits in the whole number = k+1.\n\t\t\twhile (k > -1) {\n\t\t\t\tl = pow10[k];\n\t\t\t\tm = a / l;\n\t\t\t\tif (m > 0) { break; }\n\t\t\t\tk--;\n\t\t\t}\n\t\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\t\tb = pow10[l - 1];\n\t\t\t\tc = a / b;\n\t\t\t\tstr[i++] = c + 48;\n\t\t\t\ta %= b;\n\t\t\t}\n\t\t\t// Add decimal point.\n\t\t\tstr[i++] = '.';\n\t\t\t// Extract decimal digits till precision met.\n\t\t\tfor (l = 0; l < precision - k - 1; l++) {\n\t\t\t\tf *= 10.0;\n\t\t\t\tb = f;\n\t\t\t\tstr[i++] = b + 48;\n\t\t\t\tf -= b;\n\t\t\t}\n\t\t\t// Add vertex color if present.\n\t\t\tif (num_colors) {\n\t\t\t\t// Put space after Z of vertex.\n\t\t\t\tstr[i++] = ' ';\n\t\t\t\t// Get 32-bit color to convert.\n\t\t\t\ta = colors[j/3];\n\t\t\t\t// Convert to R,G,B.\n\t\t\t\t// Shift off possible A.\n\t\t\t\tA = a >> 24;\n\t\t\t\ta -= (A << 24);\n\t\t\t\tR = a >> 16;\n\t\t\t\ta -= (R << 16);\n\t\t\t\tG = a >> 8;\n\t\t\t\tB = a - (G << 8);\n\t\t\t\t// Do first value.\n\t\t\t\ta = R;\n\t\t\t\tk = c_precision;\n\t\t\t\t// Get the number of digits in the whole number = k+1.\n\t\t\t\twhile (k > -1) {\n\t\t\t\t\tl = pow10[k];\n\t\t\t\t\tm = a / l;\n\t\t\t\t\tif (m > 0) { break; }\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\t\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\t\t\tb = pow10[l - 1];\n\t\t\t\t\tc = a / b;\n\t\t\t\t\tstr[i++] = c + 48;\n\t\t\t\t\ta %= b;\n\t\t\t\t}\n\t\t\t\t// Do second value.\n\t\t\t\t// Put space after R.\n\t\t\t\tstr[i++] = ' ';\n\t\t\t\ta = G;\n\t\t\t\tk = c_precision;\n\t\t\t\t// Get the number of digits in the whole number = k+1.\n\t\t\t\twhile (k > -1) {\n\t\t\t\t\tl = pow10[k];\n\t\t\t\t\tm = a / l;\n\t\t\t\t\tif (m > 0) { break; }\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\t\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\t\t\tb = pow10[l - 1];\n\t\t\t\t\tc = a / b;\n\t\t\t\t\tstr[i++] = c + 48;\n\t\t\t\t\ta %= b;\n\t\t\t\t}\n\t\t\t\t// Do third value.\n\t\t\t\t// Put space after G.\n\t\t\t\tstr[i++] = ' ';\n\t\t\t\ta = B;\n\t\t\t\tk = c_precision;\n\t\t\t\t// Get the number of digits in the whole number = k+1.\n\t\t\t\twhile (k > -1) {\n\t\t\t\t\tl = pow10[k];\n\t\t\t\t\tm = a / l;\n\t\t\t\t\tif (m > 0) { break; }\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\t\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\t\t\tb = pow10[l - 1];\n\t\t\t\t\tc = a / b;\n\t\t\t\t\tstr[i++] = c + 48;\n\t\t\t\t\ta %= b;\n\t\t\t\t}\n\t\t\t\t// Add CR LF to terminate line with vertex and colors.\n\t\t\t\tstr[i++] = '\\r';\n\t\t\t\tstr[i++] = '\\n';\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Add CR LF when no color.\n\t\t\t\tstr[i++] = '\\r';\n\t\t\t\tstr[i++] = '\\n';\n\t\t\t}\n\t\t\t// Write vertex line to file.\n\t\t\tsize_of_line = i - i_begin;\n\t\t\t// Write memblock of data into memory.\n\t\t\tout_file.write(str, size_of_line);\n\t\t}\n\t\t//\n\t\t// Process texture coordinates.\n\t\t//\n\t\tfor (j = 0; j < num_tcs; j += 2) {\n\t\t\t// Save starting value of i.\n\t\t\ti = 0;\n\t\t\ti_begin = i;\n\t\t\t// Get u,v values to convert.\n\t\t\tf1 = tcs[j]; f2 = tcs[j + 1];\n\t\t\t// Do first value.\n\t\t\tf = f1;\n\t\t\tstr[i++] = 'v';\n\t\t\tstr[i++] = 't';\n\t\t\tstr[i++] = ' ';\n\t\t\t// check for negative float\n\t\t\tif (f < 0.0) {\n\t\t\t\tstr[i++] = '-';\n\t\t\t\tf *= -1;\n\t\t\t}\n\t\t\t// Extract the whole number.\n\t\t\ta = f;\n\t\t\t// Extract the decimal part.\n\t\t\tf -= a;\n\t\t\tk = precision;\n\t\t\t// Get the number of digits in the whole number = k+1.\n\t\t\twhile (k > -1) {\n\t\t\t\tl = pow10[k];\n\t\t\t\tm = a / l;\n\t\t\t\tif (m > 0) { break; }\n\t\t\t\tk--;\n\t\t\t}\n\t\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\t\tb = pow10[l - 1];\n\t\t\t\tc = a / b;\n\t\t\t\tstr[i++] = c + 48;\n\t\t\t\ta %= b;\n\t\t\t}\n\t\t\t// Add decimal point.\n\t\t\tstr[i++] = '.';\n\t\t\t// Extract decimal digits till precision met.\n\t\t\tfor (l = 0; l < precision-k-1; l++) {\n\t\t\t\tf *= 10.0;\n\t\t\t\tb = f;\n\t\t\t\tstr[i++] = b + 48;\n\t\t\t\tf -= b;\n\t\t\t}\n\t\t\t// Do second value.\n\t\t\tf = f2;\n\t\t\tstr[i++] = ' ';\n\t\t\t// check for negative float\n\t\t\tif (f < 0.0) {\n\t\t\t\tstr[i++] = '-';\n\t\t\t\tf *= -1;\n\t\t\t}\n\t\t\t// Extract the whole number.\n\t\t\ta = f;\n\t\t\t// Extract the decimal part.\n\t\t\tf -= a;\n\t\t\tk = precision;\n\t\t\t// Get the number of digits in the whole number = k+1.\n\t\t\twhile (k > -1) {\n\t\t\t\tl = pow10[k];\n\t\t\t\tm = a / l;\n\t\t\t\tif (m > 0) { break; }\n\t\t\t\tk--;\n\t\t\t}\n\t\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\t\tb = pow10[l - 1];\n\t\t\t\tc = a / b;\n\t\t\t\tstr[i++] = c + 48;\n\t\t\t\ta %= b;\n\t\t\t}\n\t\t\t// Add decimal point.\n\t\t\tstr[i++] = '.';\n\t\t\t// Extract decimal digits till precision met.\n\t\t\tfor (l = 0; l < precision-k-1; l++) {\n\t\t\t\tf *= 10.0;\n\t\t\t\tb = f;\n\t\t\t\tstr[i++] = b + 48;\n\t\t\t\tf -= b;\n\t\t\t}\n\t\t\t// Add CR LF.\n\t\t\tstr[i++] = '\\r';\n\t\t\tstr[i++] = '\\n';\n\t\t\t// Write vertex line to file.\n\t\t\tsize_of_line = i - i_begin;\n\t\t\t// Write memblock of data into memory.\n\t\t\tout_file.write(str, size_of_line);\n\t\t}\n\t\t//\n\t\t// Process normals.\n\t\t//\n\t\tfor (j = 0; j < num_normals; j += 3) {\n\t\t\t// Save starting value of i.\n\t\t\ti = 0;\n\t\t\ti_begin = i;\n\t\t\t// Get X,Y,Z values to convert.\n\t\t\tf1 = normals[j]; f2 = normals[j + 1]; f3 = normals[j + 2];\n\t\t\t// Do first value.\n\t\t\tf = f1;\n\t\t\tstr[i++] = 'v';\n\t\t\tstr[i++] = 'n';\n\t\t\tstr[i++] = ' ';\n\t\t\t// check for negative float\n\t\t\tif (f < 0.0) {\n\t\t\t\tstr[i++] = '-';\n\t\t\t\tf *= -1;\n\t\t\t}\n\t\t\t// Extract the whole number.\n\t\t\ta = f;\n\t\t\t// Extract the decimal part.\n\t\t\tf -= a;\n\t\t\tk = precision;\n\t\t\t// Get the number of digits in the whole number = k+1.\n\t\t\twhile (k > -1) {\n\t\t\t\tl = pow10[k];\n\t\t\t\tm = a / l;\n\t\t\t\tif (m > 0) { break; }\n\t\t\t\tk--;\n\t\t\t}\n\t\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\t\tb = pow10[l - 1];\n\t\t\t\tc = a / b;\n\t\t\t\tstr[i++] = c + 48;\n\t\t\t\ta %= b;\n\t\t\t}\n\t\t\t// Add decimal point.\n\t\t\tstr[i++] = '.';\n\t\t\t// Extract decimal digits till precision met.\n\t\t\tfor (l = 0; l < precision-k-1; l++) {\n\t\t\t\tf *= 10.0;\n\t\t\t\tb = f;\n\t\t\t\tstr[i++] = b + 48;\n\t\t\t\tf -= b;\n\t\t\t}\n\t\t\t// Do second value.\n\t\t\tf = f2;\n\t\t\tstr[i++] = ' ';\n\t\t\t// check for negative float\n\t\t\tif (f < 0.0) {\n\t\t\t\tstr[i++] = '-';\n\t\t\t\tf *= -1;\n\t\t\t}\n\t\t\t// Extract the whole number.\n\t\t\ta = f;\n\t\t\t// Extract the decimal part.\n\t\t\tf -= a;\n\t\t\tk = precision;\n\t\t\t// Get the number of digits in the whole number = k+1.\n\t\t\twhile (k > -1) {\n\t\t\t\tl = pow10[k];\n\t\t\t\tm = a / l;\n\t\t\t\tif (m > 0) { break; }\n\t\t\t\tk--;\n\t\t\t}\n\t\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\t\tb = pow10[l - 1];\n\t\t\t\tc = a / b;\n\t\t\t\tstr[i++] = c + 48;\n\t\t\t\ta %= b;\n\t\t\t}\n\t\t\t// Add decimal point.\n\t\t\tstr[i++] = '.';\n\t\t\t// Extract decimal digits till precision met.\n\t\t\tfor (l = 0; l < precision-k-1; l++) {\n\t\t\t\tf *= 10.0;\n\t\t\t\tb = f;\n\t\t\t\tstr[i++] = b + 48;\n\t\t\t\tf -= b;\n\t\t\t}\n\t\t\t// Do third value.\n\t\t\tf = f3;\n\t\t\tstr[i++] = ' ';\n\t\t\t// check for negative float\n\t\t\tif (f < 0.0) {\n\t\t\t\tstr[i++] = '-';\n\t\t\t\tf *= -1;\n\t\t\t}\n\t\t\t// Extract the whole number.\n\t\t\ta = f;\n\t\t\t// Extract the decimal part.\n\t\t\tf -= a;\n\t\t\tk = precision;\n\t\t\t// Get the number of digits in the whole number = k+1.\n\t\t\twhile (k > -1) {\n\t\t\t\tl = pow10[k];\n\t\t\t\tm = a / l;\n\t\t\t\tif (m > 0) { break; }\n\t\t\t\tk--;\n\t\t\t}\n\t\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\t\tb = pow10[l - 1];\n\t\t\t\tc = a / b;\n\t\t\t\tstr[i++] = c + 48;\n\t\t\t\ta %= b;\n\t\t\t}\n\t\t\t// Add decimal point.\n\t\t\tstr[i++] = '.';\n\t\t\t// Extract decimal digits till precision met.\n\t\t\tfor (l = 0; l < precision-k-1; l++) {\n\t\t\t\tf *= 10.0;\n\t\t\t\tb = f;\n\t\t\t\tstr[i++] = b + 48;\n\t\t\t\tf -= b;\n\t\t\t}\n\t\t\t// Add CR LF.\n\t\t\tstr[i++] = '\\r';\n\t\t\tstr[i++] = '\\n';\n\t\t\t// Write vertex line to file.\n\t\t\tsize_of_line = i - i_begin;\n\t\t\t// Write memblock of data into memory.\n\t\t\tout_file.write(str, size_of_line);\n\t\t}\n\t\t//\n\t\t// Process faces. 8 precision supports 999,999,999 vertices or 2G faces.\n\t\t//\n\t\tfor (j = 0; j < num_faces; j += 4) {\n\t\t\t// Save starting value of i.\n\t\t\ti = 0;\n\t\t\ti_begin = i;\n\t\t\t// Increment index by 1 since .obj file is 1 based not 0.\n\t\t\ti1 = faces[j] + 1; i2 = faces[j + 1] + 1; i3 = faces[j + 2] + 1; i4 = faces[j + 3] + 1;\n\t\t\tq = (i4 != i3);\n\t\t\t//Do i1.\n\t\t\ta = i1;\n\t\t\tstr[i++] = 'f';\n\t\t\tstr[i++] = ' ';\n\t\t\t// Save i for making copies of a.\n\t\t\ti_start = i;\n\t\t\t// check for negative int\n\t\t\tif (a < 0) {\n\t\t\t\tstr[i++] = '-';\n\t\t\t\ta *= -1;\n\t\t\t}\n\t\t\tk = precision;\n\t\t\t// Get the number of digits in the whole number = k+1.\n\t\t\twhile (k > -1) {\n\t\t\t\tl = pow10[k];\n\t\t\t\tm = a / l;\n\t\t\t\tif (m > 0) { break; }\n\t\t\t\tk--;\n\t\t\t}\n\t\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\t\tb = pow10[l - 1];\n\t\t\t\tc = a / b;\n\t\t\t\tstr[i++] = c + 48;\n\t\t\t\ta %= b;\n\t\t\t}\n\t\t\t// Capture end of a.\n\t\t\ti_end = i;\n\t\t\t// Add more info if texture or normals are present.\n\t\t\tif (do_one) {\n\t\t\t\t// Add separator for texture.\n\t\t\t\tstr[i++] = '/';\n\t\t\t\tif (do_tcs) {\n\t\t\t\t\t// Copy 2nd a to make: f i1/i1\n\t\t\t\t\tfor (n = i_start; n < i_end; n++) {\n\t\t\t\t\t\tstr[i++] = str[n];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (do_normals) {\n\t\t\t\t\t// Add separator for normal.\n\t\t\t\t\tstr[i++] = '/';\n\t\t\t\t\t// Copy third a to make: f i1/i1/i1\n\t\t\t\t\tfor (n = i_start; n < i_end; n++) {\n\t\t\t\t\t\tstr[i++] = str[n];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Add space.\n\t\t\tstr[i++] = ' ';\n\t\t\t// Save i.\n\t\t\ti_start = i;\n\t\t\t//\n\t\t\t// Do i2.\n\t\t\t//\n\t\t\ta = i2;\n\t\t\t// check for negative int\n\t\t\tif (a < 0) {\n\t\t\t\tstr[i++] = '-';\n\t\t\t\ta *= -1;\n\t\t\t}\n\t\t\tk = precision;\n\t\t\t// Get the number of digits in the whole number = k+1.\n\t\t\twhile (k > -1) {\n\t\t\t\tl = pow10[k];\n\t\t\t\tm = a / l;\n\t\t\t\tif (m > 0) { break; }\n\t\t\t\tk--;\n\t\t\t}\n\t\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\t\tb = pow10[l - 1];\n\t\t\t\tc = a / b;\n\t\t\t\tstr[i++] = c + 48;\n\t\t\t\ta %= b;\n\t\t\t}\n\t\t\t// Capture end of a.\n\t\t\ti_end = i;\n\t\t\t// Add more info if texture or normals are present.\n\t\t\tif (do_one) {\n\t\t\t\t// Add separator for texture.\n\t\t\t\tstr[i++] = '/';\n\t\t\t\tif (do_tcs) {\n\t\t\t\t\t// Copy 2nd a to make: f i1/i1\n\t\t\t\t\tfor (n = i_start; n < i_end; n++) {\n\t\t\t\t\t\tstr[i++] = str[n];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (do_normals) {\n\t\t\t\t\t// Add separator for normal.\n\t\t\t\t\tstr[i++] = '/';\n\t\t\t\t\t// Copy third a to make: f i1/i1/i1\n\t\t\t\t\tfor (n = i_start; n < i_end; n++) {\n\t\t\t\t\t\tstr[i++] = str[n];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Add space.\n\t\t\tstr[i++] = ' ';\n\t\t\t// Save i.\n\t\t\ti_start = i;\n\t\t\t//\n\t\t\t// Do i3.\n\t\t\t//\n\t\t\ta = i3;\n\t\t\t// check for negative int\n\t\t\tif (a < 0) {\n\t\t\t\tstr[i++] = '-';\n\t\t\t\ta *= -1;\n\t\t\t}\n\t\t\tk = precision;\n\t\t\t// Get the number of digits in the whole number = k+1.\n\t\t\twhile (k > -1) {\n\t\t\t\tl = pow10[k];\n\t\t\t\tm = a / l;\n\t\t\t\tif (m > 0) { break; }\n\t\t\t\tk--;\n\t\t\t}\n\t\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\t\tb = pow10[l - 1];\n\t\t\t\tc = a / b;\n\t\t\t\tstr[i++] = c + 48;\n\t\t\t\ta %= b;\n\t\t\t}\n\t\t\t// Capture end of a.\n\t\t\ti_end = i;\n\t\t\t// Add more info if texture or normals are present.\n\t\t\tif (do_one) {\n\t\t\t\t// Add separator for texture.\n\t\t\t\tstr[i++] = '/';\n\t\t\t\tif (do_tcs) {\n\t\t\t\t\t// Copy 2nd a to make: f i1/i1\n\t\t\t\t\tfor (n = i_start; n < i_end; n++) {\n\t\t\t\t\t\tstr[i++] = str[n];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (do_normals) {\n\t\t\t\t\t// Add separator for normal.\n\t\t\t\t\tstr[i++] = '/';\n\t\t\t\t\t// Copy third a to make: f i1/i1/i1\n\t\t\t\t\tfor (n = i_start; n < i_end; n++) {\n\t\t\t\t\t\tstr[i++] = str[n];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\n\t\t\t// Do i4 if i4 is different from i3.\n\t\t\t//\n\t\t\tif (q) {\n\t\t\t\t// Add space.\n\t\t\t\tstr[i++] = ' ';\n\t\t\t\t// Save i.\n\t\t\t\ti_start = i;\n\t\t\t\ta = i4;\n\t\t\t\t// check for negative int\n\t\t\t\tif (a < 0) {\n\t\t\t\t\tstr[i++] = '-';\n\t\t\t\t\ta *= -1;\n\t\t\t\t}\n\t\t\t\tk = precision;\n\t\t\t\t// Get the number of digits in the whole number = k+1.\n\t\t\t\twhile (k > -1) {\n\t\t\t\t\tl = pow10[k];\n\t\t\t\t\tm = a / l;\n\t\t\t\t\tif (m > 0) { break; }\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\t// Extract most significant digit and concatenate to string obtained as\n\t\t\t\t// quotient by dividing number by 10^k where k = (number of digit - 1)\n\t\t\t\tfor (l = k + 1; l > 0; l--) {\n\t\t\t\t\tb = pow10[l - 1];\n\t\t\t\t\tc = a / b;\n\t\t\t\t\tstr[i++] = c + 48;\n\t\t\t\t\ta %= b;\n\t\t\t\t}\n\t\t\t\t// Capture end of a.\n\t\t\t\ti_end = i;\n\t\t\t\t// Add more info if texture or normals are present.\n\t\t\t\tif (do_one) {\n\t\t\t\t\t// Add separator for texture.\n\t\t\t\t\tstr[i++] = '/';\n\t\t\t\t\tif (do_tcs) {\n\t\t\t\t\t\t// Copy 2nd a to make: f i1/i1\n\t\t\t\t\t\tfor (n = i_start; n < i_end; n++) {\n\t\t\t\t\t\t\tstr[i++] = str[n];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (do_normals) {\n\t\t\t\t\t\t// Add separator for normal.\n\t\t\t\t\t\tstr[i++] = '/';\n\t\t\t\t\t\t// Copy third a to make: f i1/i1/i1\n\t\t\t\t\t\tfor (n = i_start; n < i_end; n++) {\n\t\t\t\t\t\t\tstr[i++] = str[n];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Add CR LF.\n\t\t\tstr[i++] = '\\r';\n\t\t\tstr[i++] = '\\n';\n\t\t\t// Write vertex line to file.\n\t\t\tsize_of_line = i - i_begin;\n\t\t\t// Write line of data into memory.\n\t\t\tout_file.write(str, size_of_line);\n\t\t}\n\t\t// Close file.\n\t\tout_file.close();\n\t}\n}",
      "language": "csharp",
      "author": "Terry_Chappell",
      "post_number": 44,
      "is_solution": false
    },
    {
      "code": "import scriptcontext as sc\nimport System\nimport Rhino\nimport random\nimport string\nimport time\nimport os\n\n\ndef add_layer(layer_name=None, layer_color=None):\n    \"\"\"Adds a new layer to the active Rhino document.\n    \n    Args:\n      layer_name (str): An optional layer name.\n      layer_color (System.Drawing.Color): An optional layer color.\n    Returns:\n      The index of the new layer.\n    \"\"\"\n    sc.doc = Rhino.RhinoDoc.ActiveDoc\n    if layer_name != None:\n        # Check whether the layer name is valid\n        if not Rhino.DocObjects.Layer.IsValidName(layer_name):\n            raise ValueError(\"{} is not a valid layer name.\"\\\n                .format(layer_name))\n        # Check whether a layer with the same name already exists\n        layer_index = sc.doc.Layers.Find(layer_name, True)\n        if layer_index >= 0:\n            raise ValueError(\"A layer with the name {} already exists.\"\\\n                .format(layer_name))\n    else:\n        layer_name = sc.doc.Layers.GetUnusedLayerName(False)\n    \n    # Check whether the layer color is valid\n    if layer_color != None:\n        if not isinstance(layer_color, System.Drawing.Color):\n            raise ValueError(\"{} is not a valid layer color.\"\\\n                .format(layer_color))\n    else:\n        layer_color = System.Drawing.Color.Black # default layer color\n    \n    # Add a new layer to the active document\n    layer_index = sc.doc.Layers.Add(layer_name, layer_color)\n    if layer_index < 0:\n        raise ValueError(\"Unable to add layer {} to document.\"\\\n            .format(layer_name))\n    return layer_index\n    \n\ndef delete_layer(layer):\n    \"\"\"Deletes an existing layer from the active Rhino document. \n    The layer to be removed cannot be the current layer and \n    it will be deleted even if it contains objects.\n    \n    Args:\n      layer (str\\id): A name or id of an existing layer.\n    Returns:\n      True or False, indicating success or failure.\n    \"\"\"\n    sc.doc = Rhino.RhinoDoc.ActiveDoc\n    layer_index = sc.doc.Layers.Find(layer, True)\n    if layer_index < 0:\n        raise ValueError(\"The layer {} does not exist.\".format(layer))\n    rc = sc.doc.Layers.Purge(layer_index, True)\n    sc.doc.Views.Redraw()\n    return rc\n    \n\ndef bake_mesh(layer, mesh, mesh_name=None):\n    \"\"\"Bakes a mesh object to the active Rhino document.\n    \n    Args:\n      layer (str\\id): The name or id of an existing layer.\n      mesh (Rhino.Geometry.Mesh): A mesh object to bake.\n      mesh_name (str): An optional mesh object name.\n    Returns:\n      The GUID of the baked mesh.\n    \"\"\"\n    sc.doc = Rhino.RhinoDoc.ActiveDoc\n    # Check whether the mesh is a mesh object\n    if mesh.ObjectType != Rhino.DocObjects.ObjectType.Mesh:\n        raise ValueError(\"{} is not a mesh.\".format(mesh))\n    # Create the mesh object attributes\n    attr = Rhino.DocObjects.ObjectAttributes()\n    # Set the mesh object layer index attribute\n    layer_index = sc.doc.Layers.Find(layer, True)\n    if layer_index < 0:\n        if layer == \"Default\":\n            raise ValueError(\"The layer {} can't be baked to.\".format(layer))\n        else:\n            raise ValueError(\"The layer {} does not exist.\".format(layer))    \n    else:\n        attr.LayerIndex = layer_index\n    # Set the mesh object name attribute\n    if mesh_name != None:\n        attr.Name = mesh_name\n    # Bake the mesh to the active Rhino documemnt\n    mesh_id = sc.doc.Objects.AddMesh(mesh, attr)\n    return mesh_id\n\n\ndef parse_obj_settings():\n    \"\"\"Returns the settings for the OBJ export command as a string.\"\"\"\n    # Formatting options\n    cfg = \"_Geometry=_Mesh \"\n    cfg += \"_EndOfLine=CRLF \"\n    cfg += \"_ExportRhinoObjectNames=_ExportObjectsAsOBJGroups \"\n    cfg += \"_ExportMeshTextureCoordinates=_Yes \"\n    cfg += \"_ExportMeshVertexNormals=_Yes \"\n    cfg += \"_ExportMeshVertexColors=_Yes \"\n    cfg += \"_CreateNGons=_No \"\n    cfg += \"_ExportMaterialDefinitions=_No \"\n    cfg += \"_YUp=_Yes \"\n    cfg += \"_WrapLongLines=_No \"\n    cfg += \"_VertexWelding=_Unmodified \"\n    cfg += \"_WritePrecision=4 \"\n    cfg += \"_Enter \"\n    # Detailed options\n    cfg += \"_DetailedOptions \"\n    cfg += \"_JaggedSeams=_No \"\n    cfg += \"_PackTextures=_No \"\n    cfg += \"_Refine=_No \"\n    cfg += \"_SimplePlane=_No \"\n    # Advanced options\n    cfg += \"_AdvancedOptions \"\n    cfg += \"_Angle=0 \"\n    cfg += \"_AspectRatio=0 \"\n    cfg += \"_Distance=0.0 \"\n    cfg += \"_Density=0.5 \"\n    cfg += \"_Grid=0 \"\n    cfg += \"_MaxEdgeLength=0 \"\n    cfg += \"_MinEdgeLength=0.0001 \"\n    cfg += \"_Enter _Enter\" # remove the last _Enter to check if density is set\n    return cfg\n\n\ndef export_obj(meshes, path, filename, debug=False):\n    \"\"\"Exports a collection of meshes to an OBJ file.\n    \n    Args:\n      meshes (list): A list of Rhino.Geometry.Mesh objects.\n      path (str): An absolute path pointing to a directory.\n      filename (str): A filename (without extension).\n      debug (bool): Optional True to print debug information.\n    Returns:\n      True or False, indicating success or failure.\n    \"\"\"\n    sc.doc = Rhino.RhinoDoc.ActiveDoc\n    sc.doc.Views.RedrawEnabled = False\n    if debug: \n        now = time.clock()\n        elapsed = 0.0\n        \n    # Create a temporary layer\n    layer = \"\".join(random.choice(string.ascii_uppercase) for _ in range(9))\n    layer_index = add_layer(layer)\n    if debug: \n        then, now = now, time.clock()\n        elapsed += now - then\n        print \"Creating temporary layer: {0:.4f} seconds\".format(now-then)\n        \n    # Bake the temporary mesh(es)\n    mesh_ids = [bake_mesh(layer, mesh) for mesh in meshes]\n    if debug: \n        then, now = now, time.clock()\n        elapsed += now - then\n        print \"Creating temporary mesh(es): {0:.4f} seconds\".format(now-then)\n    \n    # Unselect all objects in the scene\n    sc.doc.Objects.UnselectAll()\n    # Select the baked mesh object(s)\n    for mid in mesh_ids:\n        sc.doc.Objects.Select(mid)\n    if debug: \n        then, now = now, time.clock()\n        elapsed += now - then\n        print \"Unselecting and selecting: {0:.4f} seconds\".format(now-then)\n    \n    # Export the selected mesh object(s) to OBJ\n    obj_fname = \"{}.{}\".format(filename, \"obj\")\n    obj_fpath = os.path.join(path, obj_fname)\n    obj_config = parse_obj_settings()\n    cmd = '_-Export \"{}\" {}'.format(obj_fpath, obj_config)\n    #start = Rhino.DocObjects.RhinoObject.NextRuntimeSerialNumber\n    rc = Rhino.RhinoApp.RunScript(cmd, True)\n    #end = Rhino.DocObjects.RhinoObject.NextRuntimeSerialNumber\n    #global __command_serial_numbers\n    #__command_serial_numbers = None\n    #if start != end:\n        #__command_serial_numbers = (start, end)\n    \n    if debug: \n        then, now = now, time.clock()\n        elapsed += now - then\n        print \"Exporting OBJ: {0:.4f} seconds\".format(now-then)\n    \n    # Delete the temporary layer and meshes\n    delete_layer(layer)\n    \n    if debug: \n        then, now = now, time.clock()\n        elapsed += now - then\n        print \"Cleaning up: {0:.4f} seconds\\n\".format(now-then)\n        print \"Total elapsed: {0:.4f} seconds\".format(elapsed)\n\n    sc.doc.Views.RedrawEnabled = True\n    return rc\n    \n\nif __name__ == \"__main__\":\n    filename = \"test_export\" # OBJ filename\n    path = \"C:\\Users\\your_username\\Documents\" # folder\n\n    rc = export_obj(Meshes, path, filename, True)\n    if not rc:\n        raise ValueError(\"OBJ export failed.\")",
      "language": "python",
      "author": "diff-arch",
      "post_number": 55,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "grasshopper",
    "layers",
    "materials",
    "mesh",
    "python",
    "rhinocommon",
    "rhinoscriptsyntax",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 2,
  "posts_count": 91,
  "views": 5612
}