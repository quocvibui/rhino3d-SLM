{
  "source_url": "https://github.com/jlopezbi/rhinoUnfolder/blob/37abb2c4d2a464e62dbdbb0bde72491dcbfd7343/rhino_unwrapper/depricated_islandCreator_safety.py",
  "repo": "jlopezbi/rhinoUnfolder",
  "repo_stars": 8,
  "repo_description": "unwrap meshes in rhino!",
  "license": "GPL-3.0",
  "filepath": "rhino_unwrapper/depricated_islandCreator_safety.py",
  "instruction": "Depricated island creator safety",
  "code": "\n#DEPRICATED\nclass IslandCreator(object):\n    \"\"\"DEPRICATED, left for now in case need to check how did something traverses a mesh to create an island \"\"\"\n\n    def __init__(self,dataMap=None,myMesh=None,mesh_loc=None,start_frame=None,island_index=None):\n        self.dataMap = dataMap\n        self.myMesh = myMesh\n        self.mesh_loc = mesh_loc\n        self.island_loc = IslandLoc(0,0,[0,1])\n        self.island_index = island_index #index of island in net\n\n        self.island = nt.Island()\n        if start_frame==None:\n            start_frame = trans.make_origin_frame()\n        self.to_frame = start_frame\n        self.update_from_frame()\n        self.visualize_mode = True\n        if self.visualize_mode:\n            self.to_frame.show()\n            self.from_frame.show()\n\n    def make_island(self,foldList,mesh_frame,toBasis):\n        self.foldList = foldList\n        self.layout_face(None,None,mesh_frame,toBasis)\n\n    def new_layout(self,meshLoc,islandLoc):\n        self.add_facet_to_island_and_update_map(meshLoc,islandLoc) #does the map get updated in here. yes\n        edges = self.myMesh.getFaceEdges(meshLoc.face)\n        for edge in faceEdges:\n            if self.is_fold(edge):\n                self.modify_edge_type('fold',edge) #edge can now have meshEdgeIdx\n                # RECURSE\n                new_island_loc = self.get_new_island_loc(islandLoc,edge)\n                new_mesh_loc = self.get_new_mesh_loc(meshLoc,edge)\n                new_layout(new_mesh_loc,new_island_loc)\n            if self.is_cut(edge):\n                self.island.modify_edge_type('cut') #sibling edge found using map\n            if self.is_naked(edge):\n                self.island.modify_edge_type('naked')\n\n    def update_from_frame(self):\n        self.from_frame = trans.get_frame_on_mesh(self.mesh_loc,self.myMesh)\n\n    def update_to_frame(self):\n        if self.island_loc != None:\n            face,edge = self.island_loc\n            self.to_frame = self.island.get_frame_reverse_edge(face,edge)\n\n    def add_first_edge_to_island(self):\n        ''' first edge and verts added to island so that recursion is easier'''\n        sourceFace,sourceEdge,sourceVert = self.mesh_loc\n        edgePoints = self.myMesh.get_oriented_points_for_edge(sourceEdge,sourceFace)\n        islandVertPair = []\n        for point in edgePoints:\n            mapped_point = trans.get_mapped_point(point,self.from_frame,self.to_frame)\n            islandVertPair.append(self.island.add_vert_from_point(mapped_point))\n        indexInFace = 0 #always will be first edge in face (?)\n        face = 0 #always will be from first face\n        island_edge = self.island.add_edge_with_from_face(0,index=indexInFace) \n        self.dataMap.add_edge(sourceEdge,self.island_index,island_edge)\n        \n# NEW PLAN:\n# iterate edge-wise over edges for meshFace and  use GetEdgesForFace() method\n# that outputs list of booleans for edges that are backwards relative to face\n# then can add only the head vert for each edge\n    \n    def add_facet(self):\n        self.update_from_frame()\n        self.update_to_frame()\n        sourceFace,sourceEdge,sourceVert = self.mesh_loc #indices\n        islandFace,islandEdge,islandVertPair = self.island_loc #indices\n        edges,orientations = self.myMesh.get_edges_and_orientation_for_face(sourceFace)\n        for i,edge in enumerate(edges):\n            if self.edge_not_added(edge):\n                vert_list = self.myMesh.getTVertsForEdge(edge)\n                point_list = self.myMesh.getPointsForEdge(edge)\n                if not orientations[i]:\n                    vert_list.reverse()\n                    point_list.reverse()\n                mapped_point = trans.get_mapped_point(point_list[1],self.from_frame,self.to_frame)\n                self.island.add_vert_from_point(mapped_point)\n                self.island.add_edge_before_face(i)\n            else:\n                pass\n\n    def add_facet_to_island_and_update_map(self):\n        self.update_from_frame()\n        self.update_to_frame()\n        sourceFace,sourceEdge,sourceVert = self.mesh_loc #indices\n        islandFace,islandEdge,islandEdgeVerts = self.island_loc #indices\n        edgeTVerts = set(self.myMesh.getTVertsForEdge(sourceEdge))\n        all_verts = self.myMesh.getTVertsForFace(sourceFace)\n        verts_to_assign = set(all_verts)\n        if self.island_loc != None:\n            verts_to_assign = verts_to_assign.difference(edgeTVerts)\n        island_face_verts = []\n        island_face_edges = []\n        for i,vert in enumerate(all_verts):\n            if vert in verts_to_assign:\n                point = self.myMesh.get_point_for_tVert(vert)\n                mapped_point = trans.get_mapped_point(point,self.from_frame,self.to_frame)\n                new_island_vert = self.island.add_vert_from_point(mapped_point)\n                self.dataMap.add_child_to_vert(vert,new_island_vert)\n            next_vert = all_verts[ (i+1)%len(all_verts) ]\n            island_vert = self.dataMap.get_recent_island_vert(vert)\n            island_next_vert = self.dataMap.get_recent_island_vert(next_vert)\n            island_face_verts.append(island_vert)\n            #TODO: this is absurdely ugly (below line) need to figure out better organization to avoid\n            island_hop_edge_verts = self.island.flatEdges[islandEdge].get_verts(self.island.flatVerts)\n            if set([island_vert,island_next_vert]) != set(island_hop_edge_verts):\n                new_edge_idx = self.island.add_edge_with_from_face(sourceFace,i)\n                island_face_edges.append(new_edge_idx)\n        flatFace = self.island.add_face_verts_edges(island_face_verts,island_edges)\n\n    def layout_face(self, fromFace, hopEdge, meshLoc, to_frame):\n        ''' Recursive Function to traverse through faces, hopping along fold edges\n            input:\n                fromface = \n                hopEdge = \n                meshLoc = (faceIdx,edgeIdx,tVertIdx) information required to make basis\n                self.myMesh = a wrapper for RhinoCommon mesh, to unfold\n                to_frame = frame in flat world\n            out/in:\n                flatEdges = list containing flatEdges (a class that stores the edgeIdx,coordinates)\n        '''\n        \"\"\"FLAT VERTS\"\"\"\n        new_island_verts = self.assign_flat_verts(meshLoc,to_frame,fromFace) \n        \"\"\"FLAT FACES\"\"\"\n        new_island_face = self.island.add_face(flatGeom.FlatFace(new_island_verts,fromFace))\n        self.dataMap.meshFaces[meshLoc.face] = new_island_face\n\n        \"\"\"FLAT EDGES\"\"\"\n        faceEdges = self.myMesh.getFaceEdges(meshLoc.face)\n        for edge in faceEdges:\n            meshI, meshJ = self.myMesh.getTVertsForEdge(edge)\n\n            if edge in self.foldList:\n                if not self.alreadyBeenPlaced(edge, self.dataMap.meshEdges):\n\n                    new_mesh_frame = self.getNewBasisInfo(meshLoc, edge, self.myMesh)\n                    edgeCoords = (self.island.flatVerts[netI].point,self.island.flatVerts[netJ].point)\n\n                    flatEdge = fe.FoldEdge(meshEdgeIdx=edge, vertAidx=netI,\n                                   vertBidx=netJ,fromFace=meshLoc.face,toFace=new_mesh_frame.face) \n                    netEdge = self.island.addEdge(flatEdge)\n                    self.dataMap.updateEdgeMap(edge, netEdge)\n\n                    # RECURSE\n                    recurse = True\n                    new_net_frame = trans.get_net_frame(edgeCoords)\n                    self.dataMap = self.layout_face( meshLoc.face, flatEdge, new_mesh_frame,new_net_frame)\n\n            else:\n                if len(self.dataMap.meshEdges[edge]) == 0:\n                    flatEdge = fe.FlatEdge(meshEdgeIdx=edge, vertAidx=netI,\n                                   vertBidx=netJ,fromFace=meshLoc.face)\n                    netEdge = self.island.addEdge(flatEdge)\n                    self.dataMap.updateEdgeMap(edge, netEdge)\n\n                elif len(self.dataMap.meshEdges[edge]) == 1:\n                    otherEdge = self.dataMap.meshEdges[edge][0]\n                    otherFace = self.myMesh.getOtherFaceIdx(edge,meshLoc.face)\n                    flatEdge = fe.CutEdge(meshEdgeIdx=edge,\n                                          vertAidx=netI,\n                                          vertBidx=netJ,\n                                          fromFace=meshLoc.face,\n                                          toFace=otherFace,\n                                          sibling=otherEdge)\n                    flatEdge.get_other_face_center(self.myMesh, meshLoc.face, xForm)\n                    netEdge = self.island.addEdge(flatEdge)\n                    self.dataMap.updateEdgeMap(edge, netEdge)\n                    sibFlatEdge = self.island.flatEdges[otherEdge]\n                    self.island.flatEdges[otherEdge] = fe.change_to_cut_edge(sibFlatEdge,netEdge)\n\n    def assign_flat_verts(self,meshLoc,to_frame,start=False):\n        from_frame = trans.get_frame_on_mesh(meshLoc,self.myMesh)\n        if self.visualize_mode:\n            from_frame.show()\n        faceIdx = meshLoc.face\n        edgeIdx = meshLoc.edge\n        edgeTVerts = set(self.myMesh.getTVertsForEdge(edgeIdx))\n        verts_to_assign = set(self.myMesh.getTVertsForFace(faceIdx))\n        if not start:\n            verts_to_assign = verts_to_assign.difference(edgeTVerts)\n        new_island_verts = []\n        for vert in verts_to_assign:\n            point = self.myMesh.get_point_for_tVert(vert)\n            mapped_point = trans.get_mapped_point(point,from_frame,to_frame)\n            new_island_vert = self.island.add_vert_from_point(mapped_point)\n            new_island_verts.append(new_island_vert)\n            self.dataMap.add_child_to_vert(vert,new_island_vert)\n        return new_island_verts\n\n    def assignFlatVerts(self, hopEdge, face, from_frame, to_frame):\n        '''\n        add valid flatVerts to flatVerts list and also return\n        a list of netVertassignFlatVerts\n        '''\n\n        face_verts = self.myMesh.getTVertsForFace(face)\n        netVerts = []\n        hopMeshVerts = []\n\n        if hopEdge is not None:\n            netI, netJ = [hopEdge.vertAidx, hopEdge.vertBidx]\n            hopMeshVerts = [\n                self.island.flatVerts[netI].tVertIdx,\n                self.island.flatVerts[netJ].tVertIdx]\n            self.dataMap.add_child_to_vert(hopMeshVerts[0],netI)\n            mapping[hopMeshVerts[0]] = netI\n            mapping[hopMeshVerts[1]] = netJ\n\n        for vert in face_verts:\n            if vert not in hopMeshVerts:\n                point = self.myMesh.get_point_for_tVert(vert)\n                mapped_point = trans.get_mapped_point(point,from_frame,to_frame) \n                flatVert = flatGeom.FlatVert(vert, mapped_point)\n                newVertIdx = self.island.addVert(flatVert)\n                self.dataMap.meshVerts[point].append(newVertIdx)\n                netVerts.append(flatVert)\n                mapping[vert] = flatVert\n            else:\n                # this section is important for preserving order\n                if vert == self.island.flatVerts[netI].tVertIdx:\n                    netVerts.append(netI)\n                elif point == self.island.flatVerts[netJ].tVertIdx:\n                    netVerts.append(netJ)\n        return netVerts, mapping\n\n    def getNewBasisInfo(self, oldBasisInfo, testEdgeIdx, myMesh):\n        faceIdx, edgeIdx, tVertIdx = oldBasisInfo\n        newFaceIdx = myMesh.getOtherFaceIdx(testEdgeIdx, faceIdx)\n        newEdgeIdx = testEdgeIdx\n        newTVertIdx = myMesh.mesh.TopologyEdges.GetTopologyVertices(\n            testEdgeIdx).I  # convention: useI\n        return Basis(newFaceIdx, newEdgeIdx, newTVertIdx)\n\n    def getNetEdges(self, mesh, edge, netVerts, dataMap):\n        I, J = mesh.getTVertsForEdge(edge)\n        vertI = dataMap.get\n\n    def transformPoint(self, mesh, tVert, xForm):\n        #NOTE: mesh.TopologyVertices.Item returns a point3f\n        point = Rhino.Geometry.Point3d(mesh.TopologyVertices.Item[tVert])\n        point.Transform(xForm)\n        point.Z = 0.0  # TODO: find where error comes from!!! (rounding?)\n        return point\n\n    def edge_not_added(self, edge):\n        return not self.dataMap.meshEdges[edge]\n",
  "language": "python",
  "imports": [
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": false
}