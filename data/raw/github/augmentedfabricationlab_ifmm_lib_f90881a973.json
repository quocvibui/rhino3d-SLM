{
  "source_url": "https://github.com/augmentedfabricationlab/ifmm_lib/blob/1cc6e87f5b07e0d6bd144f8f24462cc0d0a70fdb/mmmesh/archive/mmfabmesh-safecopy.py",
  "repo": "augmentedfabricationlab/ifmm_lib",
  "repo_stars": 0,
  "repo_description": "In situ Fabricatr & Mesh Mould @ EMPA Nest 2017",
  "license": "unknown",
  "filepath": "mmmesh/archive/mmfabmesh-safecopy.py",
  "instruction": ". . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<  <<><><>  <<      ><  <<      ><   .\n.   <<  <<       < ><   ><<  < ><   ><<   .\n.   <<  <<><><>  << ><...",
  "code": "'''\n. . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<  <<><><>  <<      ><  <<      ><   .\n.   <<  <<       < ><   ><<  < ><   ><<   .\n.   <<  <<><><>  << >< > ><  << >< > ><   .  \n.   <<  <<       <<  ><  ><  <<  ><  ><   .\n.   <<  <<       <<      ><  <<      ><   .\n.   <<  <<       <<      ><  <<      ><   .\n.                                         .\n.             GKR 2016/17                 .\n. . . . . . . . . . . . . . . . . . . . . .\n\nCreated on 21.01.2017\n\n@author: kathrind\n'''\nimport Rhino.Geometry as rg\nimport ghpythonlib.components as ghcomp\nimport math as m\nfrom System.Collections.Generic import IEnumerable, List\nfrom mmmesh import MMMesh\nfrom node import Node\n\n# globals\ndiscrete_insertion_offset = 35\ndiscrete_insertion_bending_offset = 0 #--> = formerly 8\ndiscrete_offset_to_wire_continuous = 4.5 #6.0 #4.5\ndiscrete_excess_len_top = 13 #0 #15\ndiscrete_excess_len_bottom = 5 #0 #10\n\noffset_lead_in = 5\noffset_lead_out = 20\noffset_to_plinth = 400\n\nclass MMFabMesh(MMMesh):\n\n    #===========================================================================\n    def __init__(self):\n        MMMesh.__init__(self)\n        \n        # mesh nodes\n        self.nodes_in_layers = [] #layer based structure [[[nodes_interior],[nodes_exterior_srf1],[nodes_exterior_srf2]],[[],[],[]],...]\n        self.nodes = [] #shallow list of nodes\n        \n        self.collision_geo = None\n    \n    #===========================================================================\n    def set_collision_geo(self, geo):\n        self.collision_geo = geo\n    \n    #===========================================================================\n    def generate_fab_mesh(self, row_from, row_to):\n        ''' generate the mesh node topology of the intersection pts grid'''\n        self.nodes_in_layers = []\n        self.nodes = []\n        \n        self.nodes_in_layers = self.generate_nodes_in_layers(row_from, row_to)\n        self.nodes = self.get_flat_list_from_2dlist([j for i in self.nodes_in_layers for j in i])\n        \n        self.calc_node_indices_from_nodes()\n    \n    def calc_neighbor_nodes_for_line_est(self):\n        '''calculate the neighbor geometry for all nodes for the line estimation'''\n        [self.calc_neighbor_nodes_geo_for_line_est(n) for n in self.nodes]\n\n    #===========================================================================\n    def generate_nodes_in_layers(self, row_from, row_to):\n        '''calculcate the nodes in layers, starting with srf1, srf2 and each x row interiors'''\n        \n        nodes_in_row_interior = [self.get_fab_nodes_row_interior(row, index_row, index_layer_list=0) if row%3==0 and row>row_from+3 else [] for index_row, row in enumerate(range(max(row_from,1), row_to))]\n        nodes_in_row_srf1 = [self.get_fab_nodes_row(row, index_row, \"srf1\", index_layer_list=1) for index_row, row in enumerate(range(max(row_from,1), row_to))]\n        nodes_in_row_srf2 = [self.get_fab_nodes_row(row, index_row, \"srf2\", index_layer_list=2) for index_row, row in enumerate(range(max(row_from,1), row_to))]\n        \n        #return zip(nodes_in_row_srf1, nodes_in_row_srf2)\n        return zip(nodes_in_row_interior, nodes_in_row_srf1, nodes_in_row_srf2)\n\n    #===========================================================================\n    def get_fab_nodes_row(self, row, index_row, srf = \"srf1\", index_layer_list=0):\n        \"return nodes of one row\"\n        \n        layer_type = \"even\" if row%2 == 0 else \"odd\"\n        node_type = \"ext_srf1\" if srf== \"srf1\" else \"ext_srf2\"\n        \n        nodes_in_row = []\n        \n        if layer_type == \"even\":\n        \n            #for col, pt in enumerate(self.get_pts_in_row_rgmesh_fab(row, srf=srf)):\n            \n            # 1. lead in nodes\n            nodes = self.generate_nodes_exterior_lead_in(row, index_row, 0, node_type = node_type, srf = srf, layer_type = layer_type, index_layer_list = index_layer_list)\n            nodes_in_row += nodes\n            \n            # 2. normal nodes\n            for col in range(2, self.cols):\n                if col==0: # lead in nodes\n                    pass\n                #elif col==self.cols: # lead out nodes\n                #    pass \n                else:\n                    if col % 2 == 0: #and col >= 2: # just take every 3rd plane\n                        node = self.generate_node_exterior(row, index_row, col, node_type = node_type, srf = srf, insert_discrete_element = True, layer_type = layer_type, index_layer_list = index_layer_list)\n                        nodes_in_row.append(node)\n            \n            # 3. lead out nodes\n            nodes = self.generate_nodes_exterior_lead_out(row, index_row, node_type = node_type, srf = srf, layer_type = layer_type, index_layer_list = index_layer_list)\n            nodes_in_row += nodes\n        \n        else: #layer_type == \"odd\":\n            \n            # 1. lead in nodes\n            nodes = self.generate_nodes_exterior_lead_in(row, index_row, 0, node_type = node_type, srf = srf, layer_type = layer_type, index_layer_list = index_layer_list)\n            nodes_in_row += nodes\n            \n            #for col, pt in enumerate(self.get_pts_in_row_rgmesh_fab(row, srf=srf)):\n            for col in range(2, self.cols):\n                if col==0: # lead in nodes\n                    pass\n                #elif col==self.cols: # lead out nodes\n                #    pass \n                else:\n                    if col % 2 == 1: #and col >= 2: # just take every 3rd plane\n                        node = self.generate_node_exterior(row, index_row, col, node_type = node_type, srf = srf, insert_discrete_element = True, layer_type = layer_type, index_layer_list = index_layer_list)\n                        nodes_in_row.append(node)\n            \n            # 3. lead out nodes\n            nodes = self.generate_nodes_exterior_lead_out(row, index_row, node_type = node_type, srf = srf, layer_type = layer_type, index_layer_list = index_layer_list)\n            nodes_in_row += nodes\n        \n        self.calc_lines_in_cont_dir_row(nodes_in_row) # calculate the continuous members\n        self.calc_bending_angles_row(nodes_in_row) # calculate the absolute bending angles of the individual nodes\n        self.calc_node_indices_col_in_row(nodes_in_row)\n        self.set_collision_geo_for_nodes_in_row(nodes_in_row) # calculate the collision geo associated with every node which has a insertion\n        \n        return nodes_in_row\n    \n    #===========================================================================\n    def get_fab_nodes_row_interior(self, row, index_row, index_layer_list=2):\n        \"return nodes of one row\"\n        \n        \n        layer_type = \"even\" if row%2 == 0 else \"odd\"\n        node_type = \"interior\"\n        \n        nodes_in_row = []\n        \n        if layer_type == \"even\":\n        \n            #for col, pt in enumerate(self.get_pts_in_row_rgmesh_fab(row, srf=srf)):\n            \n            # 1. lead in nodes\n            #nodes = self.generate_nodes_exterior_lead_in(row, 0, node_type = node_type, srf = srf, layer_type = layer_type, index_layer_list = index_layer_list)\n            #nodes_in_row += nodes\n            \n            # 2. normal nodes\n            for col in range(2, self.cols):\n                if col==0: # lead in nodes\n                    pass\n                #elif col==self.cols: # lead out nodes\n                #    pass \n                else:\n                    if col % 2 == 0: #and col >= 2: # just take every 3rd plane\n                        srf = \"srf2\"\n                        if ((col/2)%8 == 0 or (col/2)%8 == 1 or (col/2)%8 == 2 or (col/2)%8 == 3): srf = \"srf1\"   \n                        ide = True\n                        if col>5:\n                            ide = False if (col/2)%8 == 0 or (col/2)%8 == 4 else True\n                        node = self.generate_node_interior(row, index_row, col, node_type = node_type, srf = srf, insert_discrete_element = ide, layer_type = layer_type, index_layer_list = index_layer_list)\n                        nodes_in_row.append(node)\n            \n            # 3. lead out nodes\n            #nodes = self.generate_nodes_exterior_lead_out(row, node_type = node_type, srf = srf, layer_type = layer_type, index_layer_list = index_layer_list)\n            #nodes_in_row += nodes\n        \n        else: #layer_type == \"odd\":\n            \n            # 1. lead in nodes\n            #nodes = self.generate_nodes_exterior_lead_in(row, 0, node_type = node_type, srf = srf, layer_type = layer_type, index_layer_list = index_layer_list)\n            #nodes_in_row += nodes\n            \n            #for col, pt in enumerate(self.get_pts_in_row_rgmesh_fab(row, srf=srf)):\n            for col in range(2, self.cols):\n                if col==0: # lead in nodes\n                    pass\n                #elif col==self.cols: # lead out nodes\n                #    pass \n                else:\n                    if col % 2 == 1: #and col >= 2: # just take every 3rd plane\n                        \n                        srf = \"srf1\"\n                        if ((col/2)%8 == 0 or (col/2)%8 == 1 or (col/2)%8 == 2 or (col/2)%8 == 3): srf = \"srf2\"   \n                        ide = True\n                        if col>5:\n                            ide = False if (col/2)%8 == 0 or (col/2)%8 == 4 else True\n                        \n                        node = self.generate_node_interior(row, index_row, col, node_type = node_type, srf = srf, insert_discrete_element = ide, layer_type = layer_type, index_layer_list = index_layer_list)\n                        nodes_in_row.append(node)\n            \n            # 3. lead out nodes\n            #nodes = self.generate_nodes_exterior_lead_out(row, node_type = node_type, srf = srf, layer_type = layer_type, index_layer_list = index_layer_list)\n            #nodes_in_row += nodes\n        \n        self.calc_lines_in_cont_dir_row(nodes_in_row) # calculate the continuous members\n        self.calc_bending_angles_row(nodes_in_row) # calculate the absolute bending angles of the individual nodes\n        self.calc_node_indices_col_in_row(nodes_in_row)\n        self.set_collision_geo_for_nodes_in_row(nodes_in_row) # calculate the collision geo associated with every node which has a insertion\n        \n        return nodes_in_row\n    \n    def get_node_in_layer(self, row, col, index_layer_list = 0):\n        ''' return the node given by row and column and side of the mesh '''\n        row = min(len(self.nodes_in_layers)-1, row)\n        col = min(len(self.nodes_in_layers[row][index_layer_list])-1, col)\n        return self.nodes_in_layers[row][index_layer_list][col]\n    \n    def get_corner_pts(self, row, col, srf = \"srf1\"):\n        pt1_row_current = self.get_pt_row_col_rgmesh_fab(row, col, srf = srf)\n        pt2_row_current = self.get_pt_row_col_rgmesh_fab(row, col - 2, srf = srf)\n        pt1_row_under = self.get_pt_row_col_rgmesh_fab(row - 1, col, srf = srf)\n        pt2_row_under = self.get_pt_row_col_rgmesh_fab(row - 1, col - 2, srf = srf)\n        return (pt1_row_current, pt2_row_current, pt1_row_under, pt2_row_under)\n    \n    def generate_node_exterior(self, row, index_row, col, node_type, srf, insert_discrete_element = True, layer_type = \"even\", index_layer_list = 0):\n        ''' creating an exterior node '''\n        \n        node = Node(node_type, layer_type, index_row, index_layer_list) # create one instance of the class node\n        \n        # get the wrist_xy_plane from the cutting plane list\n        wrist_plane = self.cutting_planes[row]\n        \n        # get the corner points of the current square\n        pt_current, pt_before, pt_under_current, pt_under_before = self.get_corner_pts(row, col, srf = srf)\n        \n        axis = rg.Vector3d(pt_current-pt_before)\n        axis.Unitize()\n        \n        if insert_discrete_element == True:\n            \n            line_discrete_element = rg.Line(pt_before, pt_under_before)\n            intersect_line_cont_disc = rg.Point3d(pt_before)\n            \n            line_discrete_element_vec = line_discrete_element.Direction\n            line_discrete_element_vec.Unitize()\n            \n            T_stretch_above = rg.Transform.Translation(line_discrete_element_vec * -discrete_excess_len_top)\n            T_stretch_under = rg.Transform.Translation(line_discrete_element_vec * discrete_excess_len_bottom)\n            \n            pt_before_stretched, pt_under_before_stretched = (rg.Point3d(pt_before), rg.Point3d(pt_under_before))\n            \n            pt_before_stretched.Transform(T_stretch_above)\n            pt_under_before_stretched.Transform(T_stretch_under)\n            \n            line_discrete_element = rg.Line(pt_before_stretched, pt_under_before_stretched)\n\n            #wrist_plane_for_bending, wrist_plane_for_inserting = self.get_wrist_planes(wrist_plane, pt_before, axis)\n            wrist_plane_for_inserting = self.get_wrist_plane_for_inserting(wrist_plane, pt_before, axis)\n            wrist_plane_for_bending = rg.Plane(wrist_plane_for_inserting)\n            wrist_plane_for_inserting_tilted = self.get_wrist_plane_for_inserting_tilted(wrist_plane_for_inserting, line_discrete_element, axis)\n            \n            T_offset = rg.Transform.Translation(wrist_plane_for_inserting.YAxis * -discrete_offset_to_wire_continuous)\n            line_discrete_element.Transform(T_offset)\n            \n            \n        else:\n            \n            line_discrete_element = None\n            intersect_line_cont_disc = None\n            \n            wrist_plane_for_bending = rg.Plane(wrist_plane)\n            wrist_plane_for_bending.Origin = pt_current\n            wrist_plane_for_inserting, wrist_plane_for_inserting_tilted = (None, None)\n            \n        \n        \n        node.fill_params(wrist_plane_for_bending, axis, insert_discrete_element, wrist_plane_for_inserting, wrist_plane_for_inserting_tilted, line_discrete_element, intersect_line_cont_disc)\n        \n        \n        #node.corner_pts = self.get_corner_pts(row, col, srf = srf)\n        return node\n\n    def generate_nodes_exterior_lead_in(self, row, index_row, col, node_type, srf, layer_type, index_layer_list):\n        ''' creating the exterior node for lead in '''\n        \n        node_lead_in_0 = Node(node_type, layer_type, index_row, index_layer_list) # create one instance of the class node\n        node_lead_in_1 = Node(node_type, layer_type, index_row, index_layer_list) # create one instance of the class node\n        \n        # get the wrist_xy_plane from the cutting plane list\n        wrist_plane = self.cutting_planes[row]\n        \n        wrist_plane_for_bending_1 = rg.Plane(wrist_plane)\n        wrist_plane_for_bending_1.Origin = self.get_pt_row_col_rgmesh_fab(row, col, srf = srf)\n        \n        node_lead_in_1.fill_params(wrist_plane_for_bending_1)  \n        \n        wrist_plane_for_bending_0 = rg.Plane(wrist_plane_for_bending_1)\n        \n        #vec_lead_in = self.get_pt_row_col_rgmesh_fab(row, 1, srf = srf) - self.get_pt_row_col_rgmesh_fab(row, 0, srf = srf)\n        #vec_lead_in.Unitize()\n        \n        wrist_plane_for_bending_0.Translate(wrist_plane_for_bending_0.XAxis * -offset_lead_in)\n        \n        node_lead_in_0.fill_params(wrist_plane_for_bending_0)  \n        \n        #node_lead_in_1.estimate_with_eeff_cam = False\n        \n        return [node_lead_in_0, node_lead_in_1]\n\n    def generate_nodes_exterior_lead_out(self, row, index_row, node_type, srf, layer_type, index_layer_list):\n        ''' creating an exterior node '''\n        \n        node_lead_out_0 = Node(node_type, layer_type, index_row, index_layer_list) # create one instance of the class node\n        node_lead_out_1 = Node(node_type, layer_type, index_row, index_layer_list) # create one instance of the class node\n        \n        # get the wrist_xy_plane from the cutting plane list\n        wrist_plane = self.cutting_planes[row]\n        \n        # get the corner points of the current square\n        # pt_current, pt_before, pt_under_current, pt_under_before = self.get_corner_pts(row, col, srf = srf)\n        \n        if layer_type == \"even\":\n            pt_current = self.get_pt_row_col_rgmesh_fab(row, self.cols-1, srf = srf)\n            pt_before = self.get_pt_row_col_rgmesh_fab(row, self.cols-2, srf = srf)\n            pt_under_current = self.get_pt_row_col_rgmesh_fab(row - 1, self.cols-1, srf = srf)\n            pt_under_before = self.get_pt_row_col_rgmesh_fab(row - 1, self.cols-2, srf = srf)\n        else:\n            vec_lead_out = self.get_pt_row_col_rgmesh_fab(row, self.cols-1, srf = srf) - self.get_pt_row_col_rgmesh_fab(row, self.cols-2, srf = srf)\n            vec_lead_out.Unitize()\n            \n            pt_current = self.get_pt_row_col_rgmesh_fab(row, self.cols-1, srf = srf) + vec_lead_out*100\n            pt_before = self.get_pt_row_col_rgmesh_fab(row, self.cols-1, srf = srf)\n            pt_under_current = self.get_pt_row_col_rgmesh_fab(row - 1, self.cols-1, srf = srf) + vec_lead_out*100\n            pt_under_before = self.get_pt_row_col_rgmesh_fab(row - 1, self.cols-1, srf = srf)\n            \n        \n        axis = rg.Vector3d(pt_current-pt_before)\n        axis.Unitize()\n        \n            \n        line_discrete_element = rg.Line(pt_before, pt_under_before)\n        intersect_line_cont_disc = rg.Point3d(pt_before)\n        \n        line_discrete_element_vec = line_discrete_element.Direction\n        line_discrete_element_vec.Unitize()\n        \n        T_stretch_above = rg.Transform.Translation(line_discrete_element_vec * -discrete_excess_len_top)\n        T_stretch_under = rg.Transform.Translation(line_discrete_element_vec * discrete_excess_len_bottom)\n        \n        pt_before_stretched, pt_under_before_stretched = (rg.Point3d(pt_before), rg.Point3d(pt_under_before))\n        \n        pt_before_stretched.Transform(T_stretch_above)\n        pt_under_before_stretched.Transform(T_stretch_under)\n        \n        line_discrete_element = rg.Line(pt_before_stretched, pt_under_before_stretched)\n\n        #wrist_plane_for_bending, wrist_plane_for_inserting = self.get_wrist_planes(wrist_plane, pt_before, axis)\n        wrist_plane_for_inserting = self.get_wrist_plane_for_inserting(wrist_plane, pt_before, axis)\n        wrist_plane_for_bending = rg.Plane(wrist_plane_for_inserting)\n        wrist_plane_for_inserting_tilted = self.get_wrist_plane_for_inserting_tilted(wrist_plane_for_inserting, line_discrete_element, axis)\n        \n        T_offset = rg.Transform.Translation(wrist_plane_for_inserting.YAxis * -discrete_offset_to_wire_continuous)\n        line_discrete_element.Transform(T_offset)\n        \n        \n        node_lead_out_0.fill_params(wrist_plane_for_bending, axis, True, wrist_plane_for_inserting, wrist_plane_for_inserting_tilted, line_discrete_element, intersect_line_cont_disc)\n        \n        \n        #node_lead_out_0.corner_pts = [pt_current, pt_before, pt_under_current, pt_under_before]\n        \n        wrist_plane_for_bending_1 = rg.Plane(wrist_plane_for_bending)\n        wrist_plane_for_bending_1.Translate(wrist_plane_for_bending_1.XAxis * offset_lead_out)\n        \n        node_lead_out_1.fill_params(wrist_plane_for_bending_1)  \n        \n        \n        return [node_lead_out_0, node_lead_out_1]\n    \n    def get_corner_pts_interior(self, row, col, srf = \"srf1\"):\n        ''' get corner points for interior layer '''\n        \n        pt1_row_current = self.get_pt_row_col_rgmesh_fab(row, col, srf = srf)\n        pt2_row_current = self.get_pt_row_col_rgmesh_fab(row, col - 2, srf = srf)\n        pt1_row_under = self.get_pt_row_col_rgmesh_fab(row - 1, col, srf = srf)\n        pt2_row_under = self.get_pt_row_col_rgmesh_fab(row - 1, col - 2, srf = srf)\n        \n        vec_h = pt1_row_current - pt2_row_current\n        #vec_h.Unitize()\n        \n        vec_v = pt2_row_current - pt2_row_under\n        #vec_v.Unitize()\n        \n        #pt2_row_current = pt2_row_current + 20 * vec_h - 20 * vec_v\n        pt1_row_current = pt1_row_current - vec_v/3*1\n        pt2_row_current = pt2_row_current + vec_h/4*1 - vec_v/3*1\n        pt2_row_under = pt2_row_under + vec_h/4*1\n        \n        return (pt1_row_current, pt2_row_current, pt1_row_under, pt2_row_under)\n    \n    def generate_node_interior(self, row, index_row, col, node_type, srf, insert_discrete_element = True, layer_type = \"even\", index_layer_list = 0):\n        ''' creating an exterior node '''\n        \n        node = Node(node_type, layer_type, index_row, index_layer_list) # create one instance of the class node\n        \n        # get the wrist_xy_plane from the cutting plane list\n        wrist_plane = self.cutting_planes[row]\n        \n        # get the corner points of the current square\n        pt_current, pt_before, pt_under_current, pt_under_before = self.get_corner_pts_interior(row, col, srf = srf)\n        \n        axis = rg.Vector3d(pt_current-pt_before)\n        axis.Unitize()\n        \n        if insert_discrete_element == True:\n            \n            line_discrete_element = rg.Line(pt_before, pt_under_before)\n            intersect_line_cont_disc = rg.Point3d(pt_before)\n            \n            line_discrete_element_vec = line_discrete_element.Direction\n            line_discrete_element_vec.Unitize()\n            \n            T_stretch_above = rg.Transform.Translation(line_discrete_element_vec * -discrete_excess_len_top)\n            T_stretch_under = rg.Transform.Translation(line_discrete_element_vec * discrete_excess_len_bottom)\n            \n            pt_before_stretched, pt_under_before_stretched = (rg.Point3d(pt_before), rg.Point3d(pt_under_before))\n            \n            pt_before_stretched.Transform(T_stretch_above)\n            pt_under_before_stretched.Transform(T_stretch_under)\n            \n            line_discrete_element = rg.Line(pt_before_stretched, pt_under_before_stretched)\n\n            #wrist_plane_for_bending, wrist_plane_for_inserting = self.get_wrist_planes(wrist_plane, pt_before, axis)\n            wrist_plane_for_inserting = self.get_wrist_plane_for_inserting(wrist_plane, pt_before, axis)\n            wrist_plane_for_bending = rg.Plane(wrist_plane_for_inserting)\n            wrist_plane_for_inserting_tilted = self.get_wrist_plane_for_inserting_tilted(wrist_plane_for_inserting, line_discrete_element, axis)\n            \n            T_offset = rg.Transform.Translation(wrist_plane_for_inserting.YAxis * -discrete_offset_to_wire_continuous)\n            line_discrete_element.Transform(T_offset)\n            \n            \n        else:\n            \n            line_discrete_element = None\n            intersect_line_cont_disc = None\n            \n            wrist_plane_for_bending = rg.Plane(wrist_plane)\n            wrist_plane_for_bending.Origin = pt_current\n            wrist_plane_for_inserting, wrist_plane_for_inserting_tilted = (None, None)\n            \n        \n        \n        node.fill_params(wrist_plane_for_bending, axis, insert_discrete_element, wrist_plane_for_inserting, wrist_plane_for_inserting_tilted, line_discrete_element, intersect_line_cont_disc)\n        \n        \n        node.corner_pts = self.get_corner_pts(row, col, srf = srf)\n        return node\n    \n    def generate_nodes_exterior_lead_out_old(self, row, col, node_type, srf, insert_discrete_element = True, layer_type = \"even\"):\n        ''' creating the exterior node for lead in '''\n        \n        lead_out_nodes = []\n\n        if layer_type == \"even\":\n            \n            node_lead_out_0 = self.generate_node_exterior(row, self.u, node_type, srf, insert_discrete_element = True, layer_type = layer_type)\n            lead_out_nodes.append(node_lead_out_0)\n        \n            node_lead_out_1 = Node(node_type, layer_type, row) # create one instance of the class node\n            \n            # get the wrist_xy_plane from the cutting plane list\n            wrist_plane = self.cutting_planes[row]\n            \n            # get the corner points of the current square of planes\n            pt_before = self.get_pt_row_col_rgmesh_fab(row, self.u, srf = srf)\n            pt_under_before = self.get_pt_in_row(row-2, self.u, srf=srf)\n            \n            pt_current = pt_before + self.get_plane_from_srf(pt_before, srf).YAxis * 100\n            pt_under_current = pt_under_before + self.get_plane_from_srf(pt_under_before, srf).YAxis * 100\n            \n            '''\n            pt_current = pt_before + wrist_plane.YAxis * 100\n            pt_under_current = pt_under_before + wrist_plane.YAxis * 100'''\n            \n            axis = rg.Vector3d(pt_current-pt_before)\n            axis.Unitize()\n\n            line_discrete_element = rg.Line(pt_before, pt_under_before)\n            \n            wrist_plane_for_bending, wrist_plane_for_inserting = self.get_wrist_planes(wrist_plane, pt_before, axis)\n            wrist_plane_for_inserting_tilted = self.get_wrist_plane_for_inserting_tilted(wrist_plane_for_inserting, line_discrete_element, axis)   \n            \n            node_lead_out_1.fill_params(wrist_plane_for_bending, axis, insert_discrete_element, wrist_plane_for_inserting, wrist_plane_for_inserting_tilted, line_discrete_element)  \n           \n            node_lead_out_1.line_for_estimation = rg.Line(pt_under_before, pt_under_current)\n            \n            lead_out_nodes.append(node_lead_out_1)\n        \n        else: # layer type == \"odd\"\n            print \"odd layer\"\n            \n            node_lead_out_0 = self.generate_node_exterior(row, col, node_type, srf, insert_discrete_element = True, layer_type = layer_type)\n            lead_out_nodes.append(node_lead_out_0)\n            \n            node_lead_out_1 = Node(node_type, layer_type, row) # create one instance of the class node\n            \n            # get the wrist_xy_plane from the cutting plane list\n            wrist_plane = self.cutting_planes[row]\n            \n            # get the corner points of the current square of planes\n            pt_before = self.get_pt_in_row(row, self.u-2, srf=srf)\n            pt_under_before = self.get_pt_in_row(row-2, self.u-2, srf=srf)\n            pt_current = self.get_pt_in_row(row, self.u, srf=srf)\n            pt_under_current = self.get_pt_in_row(row-2, self.u, srf=srf)\n\n            axis = rg.Vector3d(pt_current-pt_before)\n            axis.Unitize()\n\n            line_discrete_element = rg.Line(pt_before, pt_under_before)\n            \n            wrist_plane_for_bending, wrist_plane_for_inserting = self.get_wrist_planes(wrist_plane, pt_before, axis)\n            wrist_plane_for_inserting_tilted = self.get_wrist_plane_for_inserting_tilted(wrist_plane_for_inserting, line_discrete_element, axis)   \n            \n            node_lead_out_1.fill_params(wrist_plane_for_bending, axis, insert_discrete_element, wrist_plane_for_inserting, wrist_plane_for_inserting_tilted, line_discrete_element)  \n           \n            node_lead_out_1.line_for_estimation = rg.Line(pt_under_before, pt_under_current)\n            \n            lead_out_nodes.append(node_lead_out_1)\n        \n        \n        node_lead_out_2 = Node(node_type, layer_type, row)\n        \n        wrist_plane_for_bending = rg.Plane(node_lead_out_1.wrist_plane_for_bending)\n        T = rg.Transform.Translation(node_lead_out_1.axis * self.offset_lead_out)\n        wrist_plane_for_bending.Transform(T)\n        \n        node_lead_out_2.fill_params(wrist_plane_for_bending)  \n        lead_out_nodes.append(node_lead_out_2)\n        \n        return lead_out_nodes\n    \n    def get_wrist_planes_old(self, wrist_plane, pt_before, axis):\n        ''' the wrist planes have an offset to the inserted vertical, given the vertical insertion offset and the additional offset for bending'''\n\n        wrist_plane_for_bending, wrist_plane_for_inserting = (rg.Plane(wrist_plane), rg.Plane(wrist_plane))\n        wrist_plane_for_bending.Origin = rg.Point3d.Add(pt_before, axis * (discrete_insertion_offset + discrete_insertion_bending_offset))\n        wrist_plane_for_inserting.Origin = rg.Point3d.Add(pt_before, axis * discrete_insertion_offset)\n        return wrist_plane_for_bending, wrist_plane_for_inserting\n    \n    def get_wrist_plane_for_inserting(self, wrist_plane, pt_before, axis):\n        ''' the wrist planes have an offset to the inserted vertical, given the vertical insertion offset and the additional offset for bending'''\n\n        wrist_plane_for_inserting = rg.Plane(wrist_plane)\n        wrist_plane_for_inserting.Origin = rg.Point3d.Add(pt_before, axis * discrete_insertion_offset)\n        \n        return wrist_plane_for_inserting\n    \n    def get_wrist_plane_for_inserting_tilted(self, wrist_plane_for_inserting, line_discrete_element, axis):\n        '''return xy plane tilted according to the angle of the vertical wire (= rg.Line)'''\n        \n        wrist_plane_for_inserting_tilted = rg.Plane(wrist_plane_for_inserting)\n        angle = self.get_angle(rg.Vector3d(line_discrete_element.From - line_discrete_element.To), wrist_plane_for_inserting.ZAxis, axis)\n        wrist_plane_for_inserting_tilted.Rotate(angle, axis,  wrist_plane_for_inserting_tilted.Origin)\n        \n        return wrist_plane_for_inserting_tilted\n    \n    def get_angle(self,n1,n2,axis): \n        ''' get the angle for the tilted plane for inserting the discrete rebar element'''\n        \n        #________________check for the rotation direction_______________________\n        #angle           = rs.VectorAngle (n1,n2) # rotation angle\n        angle           = rg.Vector3d.VectorAngle(rg.Vector3d(n1), rg.Vector3d(n2))\n         \n        #print \"angle: \", angle\n        test_vec_clw = rg.Vector3d(n1)\n        test_vec_clw.Rotate(angle, axis)\n        \n        sub_vec_clw = rg.Vector3d.Subtract(test_vec_clw,n2)\n        length_clw = sub_vec_clw.Length\n        test_vec_aclw = rg.Vector3d(n1)\n        test_vec_aclw.Rotate(angle*-1, axis)       \n        sub_vec_aclw = rg.Vector3d.Subtract(test_vec_aclw, n2)\n        length_aclw = sub_vec_aclw.Length\n        \n        if angle == 0 or length_clw < length_aclw:\n            rot_angle = angle * -1\n        else:\n            rot_angle = angle \n   \n        return rot_angle\n    \n    def calc_neighbor_nodes_geo_for_line_est(self, node):\n        ''' this method returns the lines for the line estimation with the endeffector cameras\n        line 1 = line_c = line from discrete element 01 startpt to discrete element 02 startpt (= continuous element)\n        line 2 = line_d1 = line of discrete element 01 (= discrete element in front)\n        line 3 = line_d2 = line of discrete element 02 (= discrete element in the back)\n        '''\n        \n        # estimation_type: 1: front discrete wire, 2: back discrete wire, 3: match both wires\n        \n        neighbor_nodes = self.get_neighbor_nodes_from_node_for_line_est(node)\n        if len(neighbor_nodes):\n            node.estimate_with_eeff_cam = True\n            node.neighbor_node_for_est_01, node.neighbor_node_for_est_02 = neighbor_nodes\n            line_d1, line_d2 = [n.line_discrete_element for n in neighbor_nodes]\n            \n            if line_d1 and line_d2:\n                #print \"line_d1 and line_d2\"\n                node.estimation_type = 2\n                p1, p2 = [n.intersect_line_cont_disc for n in neighbor_nodes]\n                line_c = rg.Line(p1, p2)\n                print line_c\n            \n            if line_d1 and line_d2 == None:\n                #print \"line_d1 and line_d2 == None\"\n                node.estimation_type = 1\n                p1 = neighbor_nodes[0].intersect_line_cont_disc\n                p2 = neighbor_nodes[1].wrist_plane_for_bending.Origin\n                line_c = rg.Line(p1, p2)\n                print line_c\n            \n            if line_d1 == None and line_d2:\n                #print \"line_d1 == None and line_d2\"\n                node.estimation_type = 2\n                p2 = neighbor_nodes[1].intersect_line_cont_disc\n                p1 = neighbor_nodes[0].wrist_plane_for_bending.Origin\n                line_c = rg.Line(p1, p2)\n                #print line_c\n                \n            if line_d1 == None and line_d2 == None:\n                #print \"line_d1 == None and line_d2 == None\"\n                node.estimation_type = 3\n                p2 = neighbor_nodes[1].wrist_plane_for_bending.Origin\n                p1 = neighbor_nodes[0].wrist_plane_for_bending.Origin\n                line_c = rg.Line(p1, p2)\n            \n            \n            node.estimated_lines_global = [line_c, line_d1, line_d2]\n\n\n    def get_neighbor_nodes_from_node_for_line_est(self, node):\n        #node.index_row\n        #node.index_col\n        #node.index\n        #node.index_layer_list\n        \n        if node.insert_discrete_element and node.node_type != \"interior\":\n            row_prev = node.index_row-1\n            \n            if node.layer_type == \"odd\":  \n                neighbor_node_for_est_01 = self.get_node_in_layer(row_prev, node.index_col+1, index_layer_list = node.index_layer_list)\n                neighbor_node_for_est_02 = self.get_node_in_layer(row_prev, node.index_col, index_layer_list = node.index_layer_list)\n            else:\n                neighbor_node_for_est_01 = self.get_node_in_layer(row_prev, node.index_col, index_layer_list = node.index_layer_list)\n                neighbor_node_for_est_02 = self.get_node_in_layer(row_prev, node.index_col-1, index_layer_list = node.index_layer_list)\n            \n            return (neighbor_node_for_est_01, neighbor_node_for_est_02)\n        else:\n            return []\n        \n    def calc_neighbor_nodes_from_node_for_line_est(self, node):\n        neighbor_nodes = self.get_neighbor_nodes_from_node_for_line_est(node)\n        if len(neighbor_nodes): node.neighbor_node_for_est_01, node.neighbor_node_for_est_02 = neighbor_nodes\n    \n    def calc_neighbor_nodes_for_line_estimation(self):\n        for layer in self.nodes_in_layers[1:]:\n            for node_list in layer:\n                for node in node_list[1:len(node_list)-1]:\n                    self.calc_neighbor_nodes_from_node_for_line_est(node)\n                    \n    def calc_neighbor_nodes_for_line_estimation_old(self):\n        for i, layer in enumerate(self.nodes_in_layers[1:]):\n            i = i+1 # because we start only from the second layer\n            for j, node_list in enumerate(layer):\n                for k, node in enumerate(node_list):\n                    if k > 0 and k < len(node_list)-1:\n                        node_current = self.nodes_in_layers[i][j][k]\n                        if node_current.layer_type == \"odd\":\n                            #print node_current.layer_type\n                            node_current.neighbor_node_for_est_01 = self.nodes_in_layers[i-1][j][k+1] if self.nodes_in_layers[i-1][j][k+1].insert_discrete_element else None\n                            node_current.neighbor_node_for_est_02 = self.nodes_in_layers[i-1][j][k] if self.nodes_in_layers[i-1][j][k].insert_discrete_element else None\n                        else: #node.layer_type == \"even\"\n                            #print node_current.layer_type \n                            if k < len(self.nodes_in_layers[i-1][j]):\n                                node_current.neighbor_node_for_est_01 = self.nodes_in_layers[i-1][j][k] if self.nodes_in_layers[i-1][j][k].insert_discrete_element else None\n                                node_current.neighbor_node_for_est_02 = self.nodes_in_layers[i-1][j][k-1] if self.nodes_in_layers[i-1][j][k-1].insert_discrete_element else None\n                            else:\n                                node_current.neighbor_node_for_est_01 = None\n                                node_current.neighbor_node_for_est_02 = self.nodes_in_layers[i-1][j][k-1]\n                        \n                        # now define which type of estimation is necessary, depending on which discrete element exists\n                        if node_current.neighbor_node_for_est_01 and node_current.neighbor_node_for_est_02 == None:\n                            node_current.estimation_type = 1\n                            node_current.estimate_with_eeff_cam = True\n                        elif node_current.neighbor_node_for_est_02 and node_current.neighbor_node_for_est_01 == None:\n                            node_current.estimation_type = 2\n                            node_current.estimate_with_eeff_cam = True\n                        elif node_current.neighbor_node_for_est_01 and node_current.neighbor_node_for_est_02:\n                            node_current.estimation_type = 2\n                            node_current.estimate_with_eeff_cam = True\n                        else:\n                            node_current.estimate_with_eeff_cam = False\n    \n\n    \n    def calc_node_indices_from_nodes(self):\n        '''calculates the index of nodes from the falt list of nodes'''\n        [node.set_index(i) for i, node in enumerate(self.nodes)]\n        \n    def calc_node_indices_col_in_row(self, nodes_in_row):\n        '''calculates the index of nodes from the falt list of nodes'''\n        [node.set_index_col(i) for i, node in enumerate(nodes_in_row)]\n\n    def calc_lines_in_cont_dir_row(self, nodes_in_row):\n        '''this methods takes a row of nodes and calculates the line members in contiuous direction '''\n        \n        # first node\n        if not nodes_in_row[0].node_type == \"interior\":\n            node_current = nodes_in_row[0]\n            node_current.line_continuous_element = rg.Line(node_current.wrist_plane_for_bending.Origin, node_current.wrist_plane_for_bending.Origin - node_current.wrist_plane_for_bending.XAxis * offset_to_plinth)\n            \n        for i in range(1, len(nodes_in_row)):\n            node_current = nodes_in_row[i]\n            node_before = nodes_in_row[i-1]\n            node_current.line_continuous_element = rg.Line(node_current.wrist_plane_for_bending.Origin, node_before.wrist_plane_for_bending.Origin)\n                \n    def calc_bending_angles_row(self, nodes_in_row):\n        '''this methods takes a row of nodes and calculates the bending angles for the MM Tool. \n        The values are absolute in relation to the X axis of the current wrist plane of each layer '''             \n\n        for i in range(len(nodes_in_row)-1):\n            \n            if nodes_in_row[i+1].line_continuous_element:\n                vec = rg.Vector3d(nodes_in_row[i+1].line_continuous_element.From - nodes_in_row[i+1].line_continuous_element.To)\n                angle = rg.Vector3d.VectorAngle(nodes_in_row[i].wrist_plane_for_bending.XAxis, vec, nodes_in_row[i].wrist_plane_for_bending)\n                \n                try: angle = m.degrees(angle) # needs to be done because of a math overflow error\n                except: angle = 0\n                \n                if angle > 180:\n                    angle = (360-angle)*-1\n\n                nodes_in_row[i].absolute_bending_angle = angle\n    \n    def set_collision_geo_for_nodes_in_row(self, nodes_in_row):\n        if self.collision_geo:\n            for i, node in enumerate(nodes_in_row):\n                if node.insert_discrete_element:\n                    T1 = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, node.wrist_plane_for_inserting_tilted)\n                    bending_angle = nodes_in_row[i-1].absolute_bending_angle  if i>0 else node.absolute_bending_angle\n                    #T2 = rg.Transform.Rotation(m.radians(bending_angle), node.wrist_plane_for_inserting_tilted.ZAxis, node.wrist_plane_for_inserting_tilted.Origin)\n                    T2 = rg.Transform.Rotation(m.radians(bending_angle), rg.Plane.WorldXY.ZAxis, rg.Plane.WorldXY.Origin)\n    \n                    coll_geo_transformed = ghcomp.Transform(self.collision_geo, T1*T2)\n                    node.collision_geo = coll_geo_transformed\n    \n    def get_collcheck_geo(self, node_idx, collcheck_num):\n        mesh_nodes_collcheck = self.nodes[max(node_idx - collcheck_num, 0):node_idx]\n        geo_c_collcheck = [node.line_continuous_element for node in mesh_nodes_collcheck if node.line_continuous_element]\n        geo_d_collcheck = [node.line_discrete_element for node in mesh_nodes_collcheck if node.line_discrete_element]\n        return geo_c_collcheck+geo_d_collcheck\n        ",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}