{
  "source_url": "https://github.com/cmuphyscomp/hmv-s16/blob/7863c66ed645b463b72aef98a5c484a18cc9f396/Grasshopper/MocapDemo/optiload.py",
  "repo": "cmuphyscomp/hmv-s16",
  "repo_stars": 5,
  "repo_description": "Course resources for the Human-Machine Virtuosity course at Carnegie Mellon University, Spring 2016.",
  "license": "BSD-3-Clause",
  "filepath": "Grasshopper/MocapDemo/optiload.py",
  "instruction": "optiload.py : motion capture data loader for use within Grasshopper ghpython objects",
  "code": "# optiload.py : motion capture data loader for use within Grasshopper ghpython objects\n\n# Copyright (c) 2016, Garth Zeglin. All rights reserved. Licensed under the\n# terms of the BSD 3-clause license.\n\n# use RhinoCommon API\nimport Rhino\n\n# Make sure that the Python libraries that are also contained within this course\n# package are on the load path. This adds the python/ folder to the load path\n# *after* the current folder.  The path manipulation assumes that this module is\n# still located within the Grasshopper/MocapDemo subfolder, and so the package\n# modules are at ../../python.\nimport sys, os\nsys.path.insert(1, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(os.path.dirname(__file__)))), \"python\"))\n\n# use itertools for subsampling sequences\nimport itertools\n\n# import the Optitrack CSV file parser\nimport optitrack.csv_reader as csv\n\n# import a quaternion conversion function\nfrom optitrack.geometry import quaternion_to_xaxis_yaxis\n\n# load the Grasshopper utility functions from the course packages\nfrom ghutil import *\n\n#================================================================\ndef load_csv_file(path):\n    take = csv.Take().readCSV(path)\n    return take\n\n#================================================================\n# Convert from default Optitrack coordinates with a XZ ground plane to default\n# Rhino coordinates with XY ground plane.\n\ndef rotated_point(pt):\n    if pt is None:\n        return None\n    else:\n        return Rhino.Geometry.Point3d( pt[0], -pt[2], pt[1])\n\ndef rotated_orientation(q):\n    if q is None:\n        return [0,0,0,1]\n    else:\n        return [q[0], -q[2], q[1], q[3]]\n\ndef plane_or_null(origin,x,y):\n    \"\"\"Utility function to create a Plane unless the origin is None, in which case it returns None.\"\"\"\n    if origin is None:\n        return None\n    else:\n        return Rhino.Geometry.Plane(origin, x, y)\n\n#================================================================\ndef all_Planes(take, stride=1):\n    \"\"\"Return a DataTree of trajectories containing Planes or None.\n\n    The tree has one branch for each rigid body; each branch contains a list of\n    objects, either Plane for a valid sample or None if the sample is missing.\n\n    Due to implicit ghpython conversions, the branches will end up described by\n    paths {0;0},{0;1},{0;2}, etc.\n\n    :param stride: the skip factor to apply for subsampling input (default=1, no subsampling)\n    \"\"\"\n\n    # Extract the origin position data and convert to Point3d objects within a\n    # Python list structure.  The subsampling is handled within the\n    # comprehension.  Note that missing data is returned as None.  Each 'body'\n    # in the take.rigid_bodies dictionary is a RigidBody object.  body.positions\n    # is a list with one element per frame, either None or [x,y,z].\n    origins = [ [rotated_point(pos) for pos in itertools.islice(body.positions, 0, len(body.positions), stride)] \\\n                for body in take.rigid_bodies.values()]\n\n    # Similar to extract a tree of quaternion trajectories.  The leaves are\n    # numbers, the dimensions are (num_bodies, num_frames, 4).\n    quats = [ [rotated_orientation(rot) for rot in itertools.islice(body.rotations, 0, len(body.rotations), stride)] \\\n              for body in take.rigid_bodies.values()]\n\n    # Generate a tree of basis vector pairs (xaxis, yaxis).  Dimensions are (num_bodies, num_frames, 2, 3)\n    basis_vectors = [[quaternion_to_xaxis_yaxis(rot) for rot in body] for body in quats]\n\n    # Extract the X axis basis elements into a tree of Vector3d objects with dimension (num_bodies, num_frames).\n    xaxes = [[Rhino.Geometry.Vector3d(*(basis[0])) for basis in body] for body in basis_vectors]\n\n    # Same for Y.\n    yaxes = [[Rhino.Geometry.Vector3d(*(basis[1])) for basis in body] for body in basis_vectors]\n\n    # Iterate over the 2D list structures, combining them into a 2D list of Plane objects.\n    planes = [[plane_or_null(origin, x, y) for origin,x,y in zip(os,xs,ys)] for os,xs,ys in zip(origins, xaxes, yaxes)]\n\n    # Recursively convert from a Python tree to a data tree.\n    return list_to_tree(planes)\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}