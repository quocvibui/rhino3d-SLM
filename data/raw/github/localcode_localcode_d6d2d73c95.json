{
  "source_url": "https://github.com/localcode/localcode/blob/3089aee227d257adc856021a4e1eb678d9527f50/render3dms.py",
  "repo": "localcode/localcode",
  "repo_stars": 4,
  "repo_description": "Code repository for the local code project",
  "license": "unknown",
  "filepath": "render3dms.py",
  "instruction": "Render3dms",
  "code": "import os\nimport shelve\nimport Rhino\nimport cPickle as pickle\nfrom rhinopythonscripts import LayerTools, FileTools\nfrom rhinopythonscripts.GeomTools import bakeMany\nfrom System.Collections.Generic import List\nfrom scriptcontext import doc\nfrom System.Drawing import Rectangle\nimport rhinoscriptsyntax as rs\n\nmxwl = 'Maxwell_'\n\ndef __getMaterial( name):\n    index = doc.Materials.Find( name, True )\n    return index\n\ndef rcmd(commandstring, echo=True, mask=True):\n    if mask:\n        premask = '-_%s '\n        try:\n            cmd = premask % commandstring\n        except:\n            print commandstring, 'failed to mask'\n    else:\n        cmd = commandstring\n    result = Rhino.RhinoApp.RunScript(cmd, echo)\n    if not result:\n        print 'The following command failed:'\n        print '   ',cmd\n    return result\n\ndef rcmds(commands, echo=True):\n    for cmd in commands:\n        rcmd(cmd, echo)\n\ndef formatCmd( tup ):\n    if tup[1]:\n        return tup[0] % tup[1]\n    else:\n        return tup[0]\n\n\ndef bakeRaw( data, attributes = None, transVect=None):\n    if type(data) not in (list, tuple):\n        data = [data]\n    elif type(data[0]) in (list, tuple, List):\n        data = data[0]\n    if attributes:\n        att = attributes\n    else:\n        att = Rhino.DocObjects.ObjectAttributes()\n    for thing in data:\n        bakeMany(thing, att, transVect)\n    doc.Views.ActiveView.Redraw()\n\ndef setView( sid ):\n    # still don't know how to set up the size of the viewport.\n    # this needs to be done manually\n    f = open('/amigos/db/%sview' % sid, 'rb')\n    view = pickle.load(f)\n    f.close()\n    if len(view) == 3:\n        geom = view[0]\n        vect = Rhino.Geometry.Vector3d(view[1])\n        targ = view[2]\n    else:\n        return 'bad view data'\n\n\n    vp = doc.Views.ActiveView.ActiveViewport\n    vp.SetCameraDirection( vect, True)\n    vp.SetCameraTarget(targ, True)\n    bb = geom.GetBoundingBox(True)\n    vp.ZoomBoundingBox( bb)\n    doc.Views.ActiveView.Redraw()\n    return view\n\ndef bakePickle( path, layer=None, attributes=None, transVector=None):\n    if os.path.exists(path):\n        try:\n            f = open( path, 'rb' )\n            data = pickle.load(f)\n            f.close()\n            bakeRaw(data, attributes, transVector)\n            print 'baked %s to layer \"%s\"' % (path, layer)\n        except:\n            print 'trouble unpickling', path\n    else:\n        print '%s does not exist' % path\n\ndef materialConfig( layerName, materialName, uv=None, run=False):\n    if not materialName:\n        return ''\n    else:\n        cmds = [\n                ('SelNone',None),\n                ('%sSetCurrentMaterial \"%s\"',(mxwl, materialName)),\n                ('SelLayer \"%s\"', layerName),\n                ('%sApplyCurrentMaterialToSelectedObjects', mxwl),\n                ]\n        if uv:\n            cmds.extend( setUV(layerName, uv) )\n        if run:\n            rcmds(cmds)\n        else:\n            return cmds\n\ndef setUV( layerName, uv, run=False):\n    if type(uv) in (int, float):\n        u, v, w = uv, uv, uv\n    elif len(uv) == 2:\n        u, v, w = uv[0], uv[1], uv[0]\n    elif len(uv) == 3:\n        u, v, w = uv[0], uv[1], uv[2]\n\n    cmds = [\n            #('SelNone',None),\n            #('SelLayer \"%s\"', layerName),\n            ('ApplyBoxMapping 1 Diagonal 0 %s,%s,%s Yes Single 1 1',(u, v, w)),\n            ]\n    return cmds\n\ndef exportMXS( fileName, sl=8, time=9999, run=False):\n    folder = os.path.split(fileName)[0]\n    fname, ext = os.path.splitext(fileName)\n    mxsName = fname + '.mxs'\n    cmds = [\n            ('%sOutputSettings ImagePath \"%s\" ImageType=%s _Enter', (mxwl, fileName, ext)),\n            ('%sOutputSettings ScenePath \"%s\" _Enter', (mxwl, mxsName)),\n            ('%sCameraSettings R V _Enter', mxwl),\n            ('%sRenderSettings WriteMXI=No SamplingLevel=%s Time=%s _Enter ', (mxwl, sl, time)),\n            ('%sRenderChannels Alpha=Yes MaterialID=Yes _Enter', mxwl),\n            ('%sOutputSettings RenderSilent=yes _Enter', mxwl),\n            ('%sRenderToMXS RenderScene _Enter', mxwl)\n            ]\n    if run:\n        rcmds(cmds)\n    else:\n        return cmds\n\n\n\n\nif __name__=='__main__':\n    \"\"\"\n    This script needs to loop through each site, and then render the\n    appropriate layers in sequence.\n\n    For each site, I need to render:\n        0 canopy with billboard and benches\n        1 hardscape\n        2 plantscape\n        3 terrainmesh\n        then I need to do a make2d with:\n            4 everything?!\n\n\n\n    For each render, I need to turn layers on and off and produce the mxs file\n\n    For each layer:\n        I need to assign and configure materials.\n        for each material:\n            I need to set UV tiling size\n\n    \"\"\"\n    rs.EnableRedraw(False)\n\n\n    materials = {\n            # name: size\n            'benches': 9.0,\n            'canopy': 1.0,\n            'billboard': 1.0,\n            'new fur': (1.0, 3.0, 1.0),\n            'fur light': 1.0,\n            'hardscape': 1.0,\n            'grayterrain': 9.0,\n            }\n\n    scenes ={\n            0: 'toppings',\n            1: 'hardscape',\n            2: 'plants',\n            3: 'terrain',\n            4: 'linework',\n            5: 'shadows',\n            }\n\n\n    from site_ids import ids\n\n    layers = {\n            'benchmeshes': ((0, 4, 5), 'benches'),\n            'canopybreps':( (0,4, 5), 'canopy'),\n            'drainareamesh':( (2,5), 'fur light'),\n            'fullterrainmesh':((3,5), 'grayterrain'),\n            'activebusstops':((4, ),),\n            'siteoutline':((4, ),),\n            'drainarrows':((4, ),),\n            'billboards':( (0, 4, 5), 'billboard'),\n            'parcels':((4, ),),\n            'hardscapemesh': (( 1,5), 'hardscape'),\n            }\n\n\n    #i = 25\n\n    s = 5\n    for sid in ids:\n\n        setView(sid)\n        # unhide all and delete all\n        [ rs.LayerVisible( n, True ) for n in layers ]\n        FileTools.deleteAll()\n        # get all the geometry\n        for layer in layers:\n            # make the layer\n            att = LayerTools.layerAttributes(layer)\n            path = '/amigos/db/%s%s' % (sid, layer)\n            # get the geometry\n            bakePickle( path, layer, att )\n\n            if not rs.IsLayerEmpty( layer ) and len(layers[layer]) > 1:\n                # set the material\n                material = None\n                material = layers[layer][1]\n                matindex = __getMaterial( material )\n                uv = materials[material]\n                cmds = materialConfig( layer, material, uv )\n                cmds = [formatCmd(c) for c in cmds]\n                rcmds(cmds, False)\n\n        # run through render frames\n        for frame in range(6):\n\n            # get the name of the frame/scene\n            scene = scenes[frame]\n\n            imageName = '/amigos/renders/%s-%03d.TIF' % (scene, sid )\n\n            for layer in layers:\n                # check that the layer has stuff\n                if not rs.IsLayerEmpty( layer ):\n                    if frame in layers[layer][0]: # on for this frame\n                        #turn on layer\n                        rs.LayerVisible( layer, True)\n\n                    else:\n                        # turn the layer off\n                        rs.LayerVisible(layer, False)\n\n            # export the mxs file\n            renderCmds = exportMXS( imageName )\n            renderCmds = [formatCmd(c) for c in renderCmds]\n\n            # RUN THE RENDER COMMANDS\n            rcmds( renderCmds, False )\n\n            #print '\\n'.join(renderCmds)\n\n            #doc.Views.ActiveView.Redraw()\n\n    rs.EnableRedraw(True)\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}