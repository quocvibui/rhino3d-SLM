{
  "source_url": "https://github.com/josehernandezvargas/Rhino_PyWorkshop/blob/e061b54b86ef8e5b118408d00081d26c723b2c28/scripts/thermal_patterns.py",
  "repo": "josehernandezvargas/Rhino_PyWorkshop",
  "repo_stars": 1,
  "repo_description": "A personal collection of Python tools for Rhino / Grasshopper",
  "license": "AGPL-3.0",
  "filepath": "scripts/thermal_patterns.py",
  "instruction": "Thermal patterns",
  "code": "#! python3\n\nimport rhinoscriptsyntax as rs\nimport math\nimport curvelib as cl\nimport geometrylib as gl\nfrom ghpythonlib import treehelpers as th\nfrom itertools import chain\n\ncontact_tol = 1e-6\n\nbase_layers, transition_layers = amp_modulation\n\ndef _curve_normal_xy(tangent):\n    return rs.VectorRotate(tangent, 90, [0, 0, 1])\n\ndef create_contour_curve(base_curve, amplitude, offset_dist):\n    tangent_vector = rs.VectorCreate(rs.CurveEndPoint(base_curve), rs.CurveStartPoint(base_curve))\n    normal_vector = rs.VectorRotate(tangent_vector, 90, [0, 0, 1])\n    curve_top = rs.CopyObject(base_curve, rs.VectorScale(rs.VectorUnitize(normal_vector), amplitude))\n    curve_bottom = rs.CopyObject(base_curve, rs.VectorScale(rs.VectorUnitize(normal_vector), -amplitude))\n    pt_0 = rs.CurveStartPoint(curve_bottom)\n    pt_1 = rs.CurveStartPoint(curve_top)\n    pt_2 = rs.CurveEndPoint(curve_top)\n    pt_3 = rs.CurveEndPoint(curve_bottom)\n    bbox = rs.AddPolyline([pt_0, pt_1, pt_2, pt_3, pt_0])\n    return rs.OffsetCurve(bbox, [0, 0, 1], offset_dist)\n\ndef _add_contact_segment(container, contact):\n    start_pt, end_pt, _ = contact\n    if rs.Distance(start_pt, end_pt) > contact_tol:\n        container.append(rs.AddLine(start_pt, end_pt))\n\n\n#FIXME: this function doesn't work properly\ndef _join_contour_with_pattern(contour_curve, pattern_curve):\n    if not contour_curve or not pattern_curve:\n        return pattern_curve or contour_curve\n    contour_start = rs.CurveStartPoint(contour_curve)\n    pattern_start = rs.CurveStartPoint(pattern_curve)\n    connector = None\n    if rs.Distance(contour_start, pattern_start) > contact_tol:\n        connector = rs.AddLine(contour_start, pattern_start)\n    curves = [contour_curve]\n    if connector:\n        curves.append(connector)\n    curves.append(pattern_curve)\n    joined = rs.JoinCurves(curves)\n    if joined:\n        return joined\n    return None\n\n\ndef build_contactlines(base_curve, target_dist, amplitude, contact_length):\n    if not base_curve or target_dist <= 0:\n        return [], []\n    div_pts = cl.divide_crv_equal(base_curve, target_dist)\n    truss_pts = []\n    contactlines = []\n    for i, pt in enumerate(div_pts):\n        t_param = rs.CurveClosestPoint(base_curve, pt)\n        if t_param is None:\n            continue\n        tangent = rs.VectorUnitize(rs.CurveTangent(base_curve, t_param))\n        normal = _curve_normal_xy(tangent)\n        if i % 2 == 0:\n            normal = -normal\n\n        if i == 0 or i == len(div_pts) - 1 or contact_length == 0:\n            moved_pt = rs.PointAdd(pt, rs.VectorScale(normal, amplitude))\n            truss_pts.append(moved_pt)\n            contactlines.append((moved_pt, moved_pt, tangent))\n            continue\n\n        contactline = cl.centercrv_dir(pt, tangent, contact_length)\n        contactline = rs.MoveObject(contactline, rs.VectorScale(normal, amplitude))\n        start_pt = rs.CurveStartPoint(contactline)\n        end_pt = rs.CurveEndPoint(contactline)\n        truss_pts.append(start_pt)\n        truss_pts.append(end_pt)\n        contactlines.append((start_pt, end_pt, tangent))\n\n    return truss_pts, contactlines\n\n\ndef truss_polyline(base_curve, target_dist, amplitude, contact_length):\n    truss_pts, _ = build_contactlines(base_curve, target_dist, amplitude, contact_length)\n    if not truss_pts:\n        return None\n    return rs.AddPolyline(truss_pts)\n\n\ndef sine_like_curve(base_curve, target_dist, amplitude, contact_length, handle_length):\n    _, contactlines = build_contactlines(base_curve, target_dist, amplitude, contact_length)\n    if len(contactlines) < 2:\n        return None\n    sine_like = []\n    for i in range(len(contactlines) - 1):\n        _, start_pt, start_tangent = contactlines[i]\n        end_pt, _, end_tangent = contactlines[i + 1]\n        start_handle = rs.PointAdd(start_pt, rs.VectorScale(start_tangent, handle_length))\n        end_handle = rs.PointAdd(end_pt, rs.VectorScale(end_tangent, -handle_length))\n        _add_contact_segment(sine_like, contactlines[i])\n        sine_like.append(rs.AddCurve([start_pt, start_handle, end_handle, end_pt], 3))\n    _add_contact_segment(sine_like, contactlines[-1])\n    return rs.JoinCurves(sine_like)\n\n\ndef bezier_curve(base_curve, target_dist, amplitude, contact_length, handle_length):\n    _, contactlines = build_contactlines(base_curve, target_dist, amplitude, contact_length)\n    if len(contactlines) < 2:\n        return None\n    bezier_crvs = []\n    for i in range(len(contactlines) - 1):\n        _, start_pt, start_tangent = contactlines[i]\n        end_pt, _, end_tangent = contactlines[i + 1]\n        start_normal = rs.VectorRotate(start_tangent, -90, [0, 0, 1])\n        end_normal = rs.VectorRotate(end_tangent, 90, [0, 0, 1])\n        start_normal = rs.VectorScale(rs.VectorUnitize(start_normal), amplitude / 100)\n        end_normal = rs.VectorScale(rs.VectorUnitize(end_normal), amplitude / 100)\n        if i % 2 == 0:\n            start_normal = -start_normal\n            end_normal = -end_normal\n        start_handle = rs.PointAdd(start_pt, rs.VectorScale(start_normal, handle_length))\n        end_handle = rs.PointAdd(end_pt, rs.VectorScale(end_normal, handle_length))\n        _add_contact_segment(bezier_crvs, contactlines[i])\n        bezier_crvs.append(rs.AddCurve([start_pt, start_handle, end_handle, end_pt], 3))\n    _add_contact_segment(bezier_crvs, contactlines[-1])\n    return rs.JoinCurves(bezier_crvs)\n\n\ndef sine_curve_on_base(base_curve, wavelength, amplitude, phase, sample_count=50):\n    if sample_count < 2 or not base_curve:\n        return None\n    pts = []\n    base_pts = rs.DivideCurve(base_curve, (sample_count - 1))\n    for base_pt in base_pts:\n        t_param = rs.CurveClosestPoint(base_curve, base_pt)\n        if t_param is None:\n            continue\n        tangent = rs.VectorUnitize(rs.CurveTangent(base_curve, t_param))\n        normal = _curve_normal_xy(tangent)\n        dist = rs.CurveLength(base_curve, 0, [0.0, t_param])\n        phase_offset = 2.0 * math.pi * (phase + 0.75)\n        offset = amplitude * math.sin((2.0 * math.pi * (dist / wavelength / 2.0)) + phase_offset)\n        pts.append(rs.PointAdd(base_pt, rs.VectorScale(normal, offset)))\n    return rs.AddInterpCurve(pts)\n\n\ndef _amplitude_factors(layer_count, base_layers, transition_layers):\n    if layer_count <= 0:\n        return []\n    base_layers = max(0, int(base_layers))\n    transition_layers = max(0, int(transition_layers))\n    if base_layers == 0 and transition_layers == 0:\n        return [1.0] * layer_count\n    pattern = []\n    if base_layers:\n        pattern.extend([1.0] * base_layers)\n    if transition_layers:\n        if transition_layers == 1:\n            pattern.append(-1.0)\n        else:\n            for j in range(transition_layers):\n                pattern.append(gl.remap(0, transition_layers - 1, 1, -1, j))\n    if base_layers:\n        pattern.extend([-1.0] * base_layers)\n    if transition_layers:\n        if transition_layers == 1:\n            pattern.append(1.0)\n        else:\n            for j in range(transition_layers):\n                pattern.append(gl.remap(0, transition_layers - 1, -1, 1, j))\n    factors = []\n    while len(factors) < layer_count:\n        for val in pattern:\n            factors.append(val)\n            if len(factors) >= layer_count:\n                break\n    return factors\n\n\ndef _move_curve_z(curve, z_offset):\n    if not curve or z_offset == 0:\n        return curve\n    return rs.CopyObject(curve, [0, 0, z_offset])\n\n\ndef build_layer_stack(base_curve, layer_height, layer_count, base_layers, transition_layers,\n                      target_dist, amplitude, contact_length, handle_length, phase, sample_count,\n                      offset_dist):\n    factors = _amplitude_factors(layer_count, base_layers, transition_layers)\n    if not factors:\n        return [], [], [], []\n    a_layers = []\n    b_layers = []\n    c_layers = []\n    d_layers = []\n    for i, factor in enumerate(factors):\n        layer_curve = _move_curve_z(base_curve, layer_height * i)\n        amp = amplitude * factor\n        # add a contour curve for each layer\n        contour_curve = create_contour_curve(layer_curve, amplitude, offset_dist)\n        # A: truss pattern\n        a_pattern = truss_polyline(layer_curve, target_dist, amp, contact_length)\n        a_pattern_pts = rs.CurvePoints(a_pattern)\n        rs.CurveSeam(contour_curve, rs.CurveClosestPoint(contour_curve, rs.CurveStartPoint(a_pattern)))\n        if draw_contour:\n            a_pattern_pts.extend(rs.CurvePoints(contour_curve))\n        a_layers.append(rs.AddPolyline(a_pattern_pts))\n\n        # B: sine-like pattern\n        b_pattern = sine_like_curve(layer_curve, target_dist, amp, contact_length, handle_length)\n        rs.CurveSeam(contour_curve, rs.CurveClosestPoint(contour_curve, rs.CurveStartPoint(b_pattern)))\n        if draw_contour:\n            b_layers.append(_join_contour_with_pattern(contour_curve, b_pattern))\n        else:\n            b_layers.append(b_pattern)\n        # b_layers.append(sine_like_curve(layer_curve, target_dist, amp, contact_length, handle_length))\n\n        # C: bezier pattern\n        c_pattern = bezier_curve(layer_curve, target_dist, amp, contact_length, handle_length)\n        rs.CurveSeam(contour_curve, rs.CurveClosestPoint(contour_curve, rs.CurveStartPoint(c_pattern)))\n        if draw_contour:\n            c_layers.append(_join_contour_with_pattern(contour_curve, c_pattern))\n        else:\n            c_layers.append(c_pattern)\n        # c_layers.append(bezier_curve(layer_curve, target_dist, amp, contact_length, handle_length))\n\n        # D: true sine wave pattern\n        layer_length = rs.CurveLength(layer_curve)\n        div_length = max(1, int(round(layer_length / target_dist)))\n        wavelength = layer_length / div_length\n        d_pattern = sine_curve_on_base(layer_curve, wavelength, amp, phase, sample_count)\n        d_pattern_pts = rs.CurvePoints(d_pattern)\n        rs.CurveSeam(contour_curve, rs.CurveClosestPoint(contour_curve, rs.CurveStartPoint(d_pattern)))\n        if draw_contour:\n            d_pattern_pts.extend(rs.CurvePoints(contour_curve))\n        d_layers.append(rs.AddPolyline(d_pattern_pts))\n        # d_layers.append(sine_curve_on_base(layer_curve, wavelength, amp, phase, sample_count))\n    return a_layers, b_layers, c_layers, d_layers\n\n\nsample_count = 50\noffset_dist = 10\na_list, b_list, c_list, d_list = build_layer_stack(\n    base_crv, layer_height, layer_count, base_layers, transition_layers,\n    target_dist, amplitude, contact_length, handle_length, phase, sample_count,\n    offset_dist\n)\na = th.list_to_tree(a_list)\nb = th.list_to_tree(b_list)\nc = th.list_to_tree(c_list)\nd = th.list_to_tree(d_list)\n",
  "language": "python",
  "imports": [
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}