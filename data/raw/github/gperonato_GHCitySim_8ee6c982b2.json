{
  "source_url": "https://github.com/gperonato/GHCitySim/blob/05bf431de75f867ff67262b44c8d46742dfb3e65/src/Honeybee_Epw%20to%20Cli.py",
  "repo": "gperonato/GHCitySim",
  "repo_stars": 14,
  "repo_description": "Set of Grasshopper components for interfacing with CitySim. ©2016-2018 EPFL-LIPID",
  "license": "unknown",
  "filepath": "src/Honeybee_Epw to Cli.py",
  "instruction": "Honeybee epw to cli",
  "code": "﻿# GH-CitySim: an interface to CitySim started by Giuseppe Peronato\n#\n# © All rights reserved. Ecole polytechnique fédérale de Lausanne (EPFL), Switzerland,\n# Interdisciplinary Laboratory of Performance-Integrated Design (LIPID), 2016-2017\n# Developer: Giuseppe Peronato, <giuseppe.peronato@alumni.epfl.ch\n#\n# Further development conducted at Uppsala University, Sweden.\n# Division of Construction Engineering, 2019\n# Developer: Giuseppe Peronato <giuseppe.peronato@angstrom.uu.se>\n#\n# CitySim is a software developed and distributed by the\n# Laboratory of Solar Energy and Building Physics (LESO-PB)\n# http://citysim.epfl.ch/\n#\n# Contributions:\n# Aymeric Delmas <aymeric.delmas@imageen.re>\n\n\"\"\"\nThis component converts an EPW file into a CLI file.\n\n-\nThis component will hopefully be part of\nLadybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n\n@license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n-\n\n    \n    Args:\n        _epwFile: EPW file\n        dir: Directory\n        Run: Boolean\n    Returns:\n        climatefile: name of climate file (with extension)\n\n\"\"\"\n\n\n\n\nimport scriptcontext as sc\nimport os\nfrom clr import AddReference\nAddReference('Grasshopper')\nimport Grasshopper.Kernel as gh\n\nghenv.Component.Name = \"Honeybee_Epw to Cli\"\nghenv.Component.NickName = 'EPW-to-Cli'\nghenv.Component.Message = 'VER 0.0.4\\nMAR_07_2019'\n#compatibleLBVersion = VER 0.0.59\\nJUN_07_2015\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"Honeybee\"\nghenv.Component.SubCategory = \"0 | Honeybee\"\n\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"2\"\nexcept: pass\n\n\ndef main(_epw_file):\n    #This function has been copied (with some adaptations)\n    #from Ladybug's \"Import epw\" component, version VER 0.0.63\\nAUG_10_2016'\n    #All credits to the authors.\n    \n    # import the classes\n    if sc.sticky.has_key('ladybug_release'):\n        try:\n            if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): return -1\n            if sc.sticky['ladybug_release'].isInputMissing(ghenv.Component): return -1\n        except:\n            warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n            \"Use updateLadybug component to update userObjects.\\n\" + \\\n            \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n            \"into canvas and try again.\"\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n            return -1\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n        \n        if not os.path.isfile(_epw_file):\n            warningM = \"Failed to find the file: \" + str(_epw_file)\n            print warningM\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warningM)\n            return -1\n        \n        locationData = lb_preparation.epwLocation(_epw_file)\n        weatherData = lb_preparation.epwDataReader(_epw_file, locationData[0])\n        groundtemp = lb_preparation.groundTempData(_epwFile,[]);\n        \n        return locationData, weatherData, groundtemp\n    \n    else:\n        warningM = \"First please let the Ladybug fly...\"\n        print warningM\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warningM)\n        return -1\n    \n\nresult = main(_epwFile)\n\nif result!= -1:\n    location, locName, latitude, longitude, meridian, altitude = result[0][-1], result[0][0], result[0][1], result[0][2], result[0][3], result[0][4]\n    dryBulbTemperature, dewPointTemperature, relativeHumidity, windSpeed, windDirection, directNormalRadiation, diffuseHorizontalRadiation, globalHorizontalRadiation, directNormalIlluminance, diffuseHorizontalIlluminance, globalHorizontalIlluminance, totalSkyCover, horizontalInfraredRadiation, barometricPressure, modelYear = result[1][:]\n    groundtemp = result[2]\n    print 'Hourly weather data for ' + locName + ' is imported successfully!'\n\n#Ground Temperatures.\nfor d in groundtemp:\n    if len(d) > 7:\n        groundData = True\n        groundtempNum = d[7:]\n    \nyearlyGroundTemp = []\nif groundData: #Use groundtemperature is exists\n    for d in xrange(31*24):\n        yearlyGroundTemp.append(groundtempNum[0])\n    for d in xrange(28*24):\n        yearlyGroundTemp.append(groundtempNum[1])\n    for d in xrange(31*24):\n        yearlyGroundTemp.append(groundtempNum[2])\n    for d in xrange(30*24):\n        yearlyGroundTemp.append(groundtempNum[3])\n    for d in xrange(31*24):\n        yearlyGroundTemp.append(groundtempNum[4])\n    for d in xrange(30*24):\n        yearlyGroundTemp.append(groundtempNum[5])\n    for d in xrange(31*24):\n        yearlyGroundTemp.append(groundtempNum[6])\n    for d in xrange(31*24):\n        yearlyGroundTemp.append(groundtempNum[7])\n    for d in xrange(30*24):\n        yearlyGroundTemp.append(groundtempNum[8])\n    for d in xrange(31*24):\n        yearlyGroundTemp.append(groundtempNum[9])\n    for d in xrange(30*24):\n        yearlyGroundTemp.append(groundtempNum[10])\n    for d in xrange(31*24):\n        yearlyGroundTemp.append(groundtempNum[11])   \nelse: #Use meanDryBulbTemperature\n    meanDryBulbTemperature = round(float(sum(dryBulbTemperature[7:])) / float(len(dryBulbTemperature[7:])),1)\n    for d in xrange(8760):\n        yearlyGroundTemp.append(meanDryBulbTemperature)\n\n#Create the header\nlocName = locName.strip()\nheader = locName\nheader += \"\\n\\n\" + str(latitude) + \",\" + str(longitude) + \",\" + str(altitude) + \",\" + str(meridian) + \"\\n\\n\\n\\n\"\nheader += \"dm\\tm\\th\\tG_Dh\\tG_Bn\\tTa\\tTs\\tFF\\tDD\\tRH\\tRR\\tN\\n\\n\"\n\n\n# Create time stamps\ndef datetime_range(start, end, delta):\n    current = start\n    if not isinstance(delta, timedelta):\n        delta = timedelta(**delta)\n    while current < end:\n        yield current\n        current += delta\n#start = datetime(2010,1,1)\n#end = datetime(2011,1,1)\n#count = 0\n#dates = []\n#for dt in datetime_range(start,end,{'hours':1}):\n    #dates.append((dt.day, dt.month, dt.hour))\n    \n    \n#Import and write weather data\n#default values\nprecipitation  = 0\nnebulosity = 0 #clear sky\n\n\ndir += \"\\\\\" #Add \\ in case is missing\nfilename = _epwFile.replace(\"\\\\\",\"/\")\nfilename = filename.split(\"/\")[-1].split(\".\")[0]\n\nif Run:\n    data = \"\"\n    for h in xrange(7,len(diffuseHorizontalRadiation)):\n        data += \"{}\\t{}\\t{}\\t{}\\t{}\\t{}\\t{}\\t{}\\t{}\\t{}\\t{}\\t{}\\n\".format(1,1,1,int(diffuseHorizontalRadiation[h]),int(directNormalRadiation[h]),dryBulbTemperature[h],yearlyGroundTemp[h-7],windSpeed[h],int(windDirection[h]),int(relativeHumidity[h]),precipitation,nebulosity)\n\n\n    #Write CLI file\n    clipath = dir+filename+\".cli\"\n    out_file = open(clipath,\"w\")\n    out_file.write(header + data)\n    out_file.close()\n\n\n#Retrieve the name of the climate file  \nCSobj = dir+filename+\".cli\"\n",
  "language": "python",
  "imports": [
    "scriptcontext"
  ],
  "has_docstring": false
}