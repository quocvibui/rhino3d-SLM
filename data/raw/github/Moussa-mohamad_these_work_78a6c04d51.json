{
  "source_url": "https://github.com/Moussa-mohamad/these_work/blob/2594e0f1bf5839db92263f3a606f83a3f3ff92a7/2D_implementation/pont.py",
  "repo": "Moussa-mohamad/these_work",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "2D_implementation/pont.py",
  "instruction": null,
  "code": "\nimport rhinoscriptsyntax as rs\nimport gmsh\nimport numpy as np\nimport importlib\nimport plotly.graph_objects as go\n#import meshio\nfrom cvxopt import matrix, solvers, spmatrix\n#from scipy.sparse import coo_matrix\nimport sys\nimport time\nfrom sklearn.cluster import KMeans\n#import pandas as pd\nimport os\nimport vtk\nfrom pyevtk.hl import unstructuredGridToVTK\nfrom pyevtk.vtk import VtkTriangle, VtkQuad, VtkVertex, VtkPolyLine, VtkPolygon\nimport mesh\nimport mosek\nimport math\nfrom scipy.linalg import block_diag\nfrom scipy.spatial import cKDTree\nimport os\nimport json\nimport locale\nfrom urllib.request import urlopen\nfrom datetime import datetime\n\n\n\ndef blocks_face_neighboring(blocks_centroid,face_centroid, k_neighbors):\n    kdtree = cKDTree(blocks_centroid[:,-3:])\n \n    distances, neighbors = kdtree.query(face_centroid, k=k_neighbors + 1)\n  \n    return distances, neighbors\n\n\ndef calculate_moment(point_coords, force_coords, applied_point_coords):\n    \"\"\"\n    Calculate the moment of a force around a point.\n\n    Parameters:\n    - point_coords: Coordinates of the point where the moment is calculated (numpy array).\n    - force_coords: Coordinates of the force vector (numpy array).\n    - applied_point_coords: Coordinates of the point where the force is applied (numpy array).\n\n    Returns:\n    - moment: Moment of the force around the point (numpy array).\n    \"\"\"\n    r = - point_coords + applied_point_coords\n    F = force_coords\n\n    # Calculate the cross product to get the moment\n    moment = np.cross(r, F)\n\n    return moment\ndef rotate_x(theta):\n    return np.array([\n        [1, 0, 0],\n        [0, np.cos(theta), -np.sin(theta)],\n        [0, np.sin(theta), np.cos(theta)]\n    ])\n\ndef rotate_y(theta):\n    return np.array([\n        [np.cos(theta), 0, np.sin(theta)],\n        [0, 1, 0],\n        [-np.sin(theta), 0, np.cos(theta)]\n    ])\n\ndef rotate_z(theta):\n    return np.array([\n        [np.cos(theta), -np.sin(theta), 0],\n        [np.sin(theta), np.cos(theta), 0],\n        [0, 0, 1]\n    ])\ndef transform_point(point, displacement, rotations):\n    \n\n    # Apply rotations\n    for rotation in rotations:\n        axis, angle = rotation[0], rotation[1]\n        if axis == 'x':\n            rotation_matrix = rotate_x(angle)\n        elif axis == 'y':\n            rotation_matrix = rotate_y(angle)\n        elif axis == 'z':\n            rotation_matrix = rotate_z(angle)\n        else:\n            raise ValueError(\"Invalid rotation axis. Use 'x', 'y', or 'z'.\")\n\n        point = np.dot(rotation_matrix, point)\n        # Apply displacement\n    point = np.array(point) + np.array(displacement)\n    return point.tolist()\n\ndef check_outward_normal(block_centroid,face_ind, face_centroid,face_normal,local_ref):\n\n    block_centroid = [ block_centroid[0], block_centroid[1], block_centroid[2]]\n   \n    if np.dot(face_normal, np.array(block_centroid )- np.array(face_centroid)) > 0:\n        face_normal = [-1*element for element in face_normal]\n        \n        \n    if face_normal[1] != 0 or face_normal[2] != 0:\n        x_local = [face_normal[1]**2 + face_normal[2]**2, -face_normal[0]*face_normal[1] , -face_normal[0]*face_normal[2] ]\n        y_local = [0, face_normal[2] , -face_normal[1] ]\n    else:\n        if face_normal[0] > 0:\n            x_local = [0,1,0]\n            y_local = [0,0,1]\n        else:\n            x_local = [0,-1,0]\n            y_local = [0,0,1]\n  \n        \n    x_local /= np.linalg.norm(x_local)\n    y_local /= np.linalg.norm(y_local)\n\n    x_local = [round(element,4) for element in x_local ]\n    y_local = [round(element,4) for element in y_local ]\n    \n\n    local_ref = np.append(local_ref, np.array([[ face_ind, face_normal[0], face_normal[1],face_normal[2], \\\n                                              x_local[0],x_local[1],x_local[2], y_local[0],y_local[1],y_local[2]  ]]), axis =0)\n        \n  \n    return local_ref\n\n\ndef stat_parav(data, calc_type, stat_sol):\n\n    all_unique_points = data[\"all_unique_points\"]\n    all_triangles = data[\"all_triangles\"]\n\n \n    \n    FILE_PATH = data[\"rhino_file_path\"]  + \"\\\\\" + calc_type + \"_stat\"\n\n    print(\"Running unstructured...\")\n\n    \n    \n    \n    if calc_type == \"ub\":\n        area = data[\"Coutput\"][12]\n  \n        normal_load = [ stat_sol[ind+2]/area[int(ind/3)]   for ind in range(0,len(stat_sol[0:-1:]),3) ]\n        shear_loadx = [ stat_sol[ind]/area[int(ind/3)]    for ind in range(0,len(stat_sol[0:-1:]),3) ]\n        shear_loady = [ stat_sol[ind+1]/area[int(ind/3)]    for ind in range(0,len(stat_sol[0:-1:]),3) ]\n     \n\n    \n    else:\n        normal_load = [ stat_sol[ind+2]   for ind in range(0,len(stat_sol[0:-1:]),3) ]\n        shear_loadx = [ stat_sol[ind]   for ind in range(0,len(stat_sol[0:-1:]),3) ]\n        shear_loady = [ stat_sol[ind+1]   for ind in range(0,len(stat_sol[0:-1:]),3) ]\n    \n  \n    all_unique_points = np.array(all_unique_points)\n\n    # Define vertices\n    x = [float(element) for element in all_unique_points[:, 0]]\n    y = [float(element) for element in all_unique_points[:, 1]]\n    z = [float(element) for element in all_unique_points[:, 2]]\n\n\n    x = np.array(x, dtype = np.float64)\n    y = np.array(y,dtype = np.float64)\n    z = np.array(z,dtype = np.float64)\n    \n\n    # Define connectivity or vertices that belong to each element\n    conn = []\n    # Define offset of the last vertex of each element\n    offset = []\n    # Define cell types\n    ctype = []\n   \n    node_ind = 0\n \n    for face_triangles in all_triangles:\n      \n        for triangle in face_triangles:\n            for node in triangle:\n                conn.append(int(node-1))\n                node_ind += 1\n\n\n            offset.append(node_ind )\n\n            if len(triangle) == 3:\n                ctype.append(VtkTriangle.tid)\n            else:\n                \n                ctype.append(VtkQuad.tid)\n          \n\n    conn =  np.array(conn)\n    offset =  np.array(offset)\n    ctype =  np.array(ctype)\n\n    #cd = np.random.rand(2)\n    cellData = {\"pressure\": []}\n\n    \n    # Define displacement components\n    normal_stress = np.array(normal_load)\n    shear_stress1 = np.array(shear_loadx)\n    shear_stress2 = np.array(shear_loady)\n\n    # Combine displacement components into separate arrays\n    pointData = {\"normal_stress\":normal_stress, \"shear_stress1\": shear_stress1, \"shear_stress2\": shear_stress2  }\n \n    unstructuredGridToVTK(FILE_PATH, x, y, z, connectivity=conn, offsets=offset, cell_types=ctype, pointData=pointData)\n    \ndef blocks_mesh_parav(data):\n\n    noc_triangles_coor = data[\"noc_triangles_coor\"]\n    noc_triangles = data[\"noc_triangles\"]\n    \n    FILE_PATH = data[\"rhino_file_path\"] + \"\\\\blocks_mesh\"\n   \n    # Define vertices\n    \n    noc_triangles_coor = np.array(noc_triangles_coor)\n\n    # Define vertices\n    x = [float(element) for element in noc_triangles_coor[:, 0]]\n    y = [float(element) for element in noc_triangles_coor[:, 1]]\n    z = [float(element) for element in noc_triangles_coor[:, 2]]\n\n   \n    x = np.array(x, dtype = np.float64)\n    y = np.array(y,dtype = np.float64)\n    z = np.array(z,dtype = np.float64)\n    \n     # Define connectivity or vertices that belong to each element\n    conn = []\n    # Define offset of the last vertex of each element\n    offset = []\n    # Define cell types\n    ctype = []\n\n    tri_ind = 0\n    node_ind = 0\n \n    for face_triangles in noc_triangles:\n      \n        for triangle in face_triangles:\n            for node in triangle:\n                conn.append(int(node-1))\n                node_ind += 1\n\n\n            offset.append(node_ind )\n\n            if len(triangle) == 3:\n                ctype.append(VtkTriangle.tid)\n            else:\n\n                ctype.append(VtkQuad.tid)\n          \n  \n\n    conn =  np.array(conn)\n    offset =  np.array(offset)\n    ctype =  np.array(ctype)\n\n    pointData = {'d': np.ones(x.shape[0])}\n\n    unstructuredGridToVTK(FILE_PATH, x, y, z, connectivity=conn, offsets=offset, cell_types=ctype, pointData=pointData)\n\n\ndef streamprinter(text):\n    sys.stdout.write(text)\n    sys.stdout.flush()\n\n\n\ndef kin_parav(data,calc_type,ub):\n\n    blocks_centroid = data[\"blocks_centroid\"]\n    blocks = data[\"blocks\"]\n    faces = data[\"faces\"]\n    points = data[\"points\"]\n\n\n    ub = [ element for element in ub ]\n\n    new_points = []\n    initial_points = np.empty((0,3))\n    points_disp = np.empty((0,3))\n\n    FILE_PATH =  data[\"rhino_file_path\"] + \"\\\\\" + calc_type +  \"_disp\"\n  \n    # Define connectivity or vertices that belong to each element\n    conn = []\n    # Define offset of the last vertex of each element\n    offset = []\n    # Define cell types\n    ctype = []\n  \n    for ind, block_centroid in enumerate(blocks_centroid):\n    \n      \n        faces_ind = blocks[np.where( blocks[:,0] == ind+1)][:,1]\n      \n        for face in faces_ind:\n          \n            points_ind = faces[ np.where(faces[:,0] == face)][:,2]\n            points_ind = [ int(element) -1 for element in points_ind] \n            \n            points_coor = points[points_ind][:,-3:]\n            points_coor.astype(float)\n            points_coor = np.array([[float(element) for element in row] for row in points_coor])\n            \n\n            all_new = []\n            reference_point = block_centroid[-3:]\n       \n            \n            displacement_vector = [ ub[6*ind], ub[6*ind +1], ub[6*ind +2] ]\n      \n            \n            rotations = [('x', ub[6*ind +3]), ('y',ub[6*ind +4]),('z',  ub[6*ind +5])]\n            \n            for element in points_coor:\n             \n                initial_points = np.append(initial_points, np.array([element]), axis = 0)\n                \n\n                conn.extend( [initial_points.shape[0] - 1 ])\n                \n                point_new_ref = [element[element1] - reference_point[element1] for element1 in range(3) ]\n               \n                \n                new_point = transform_point(point_new_ref , displacement_vector, rotations)\n                \n               \n                new_point = [new_point[element] + reference_point[element] for element in range(3) ]\n                \n                all_new.append(new_point)\n\n                points_disp = np.append(points_disp, np.array( [new_point[:] - element[:] ] ), axis = 0)\n             \n                \n            ctype.extend ([VtkQuad.tid])\n            offset.extend( [initial_points.shape[0] ])\n            \n            new_points.append(all_new[0]) \n            \n            all_new = np.array(all_new)   \n            \n            \n\n            \n    \n    points = new_points\n   \n    point = np.array([[float(element) for element in row] for row in points])\n    \n    # Define vertices\n    x = [float(element) for element in initial_points[:, 0]]\n    y = [float(element) for element in initial_points[:, 1]]\n    z = [float(element) for element in initial_points[:, 2]]\n\n    x = np.array(x)\n    y = np.array(y)\n    z = np.array(z)\n\n    # Define displacement components\n    dx = np.array(points_disp[:,0])\n    dy = np.array(points_disp[:,1])\n    dz = np.array(points_disp[:,2])\n\n    pointData = {'dx': dx, 'dy': dy, 'dz': dz } \n    conn = np.array(conn)\n    offset = np.array(offset)\n    ctype = np.array(ctype)\n    \n\n    unstructuredGridToVTK(FILE_PATH, x, y, z, connectivity=conn, offsets=offset, cell_types=ctype, pointData=pointData)\n\n\n##first part\n# Reload the RhinoScriptSyntax module\n\n\ndef read_data_from_rhino(data):\n  \n\n    read_data_start = time.time()\n    importlib.reload(rs)\n\n    lc = data[\"lc\"]\n    faces_rep = []\n    pts_coor = np.empty((0,3))\n\n    block_ind = 1  # initialize blocks counter variable \n    face_ind = 1    # initialize faces counter variable \n\n    blocks = np.empty((0, 7), dtype = np.float64) # blocks array shape( block ind | face_unique_ind | block_name | face_non_unique_ind | face_type | cohesion_ind | 11 if the face is principal 22 if not  )\n    faces = np.empty((0,3))   # shape(face_unique_ind | face_non_unique_ind | node ind )\n    blocks_centroid = np.empty((0,4), dtype = np.float64 ) # shape(block ind |x | y |z)\n    blocks_volume = np.empty((0,2), dtype = np.float64)  # shape( block ind |  volume )\n    blocks_att = dict()    # variable to store blocks attributes          \n\n    unsorted_faces_rep = [] # variable to store the faces representation without sorting the nodes indices  ( ex: a face whose the boundary passes through the nodes having indcides 1,3,7,5  have the representation 1#3#7#5)\n    plans_data = np.empty((0,4)) # local variable to store the external surfaces data shape( surface ind |  coordinates for a single point that constitutes the boundary of the surface  )\n    plan_ind = 1  # initialize surfaces counter variable \n    f_points = [] #local variable to store faces points\n    keys_of_interest = [\"fx\", \"fy\", \"fz\", \"mx\", \"my\", \"mz\"] # keys for blocks loading applied on their centroids\n    local_ref = np.empty((0,10),  dtype = np.float64) # shape(face_unique_ind | normal local axis(x,y,z) |   local_1 axis(x,y,z)  | local_2 axis(x,y,z) )\n    \n    blocks_brep = [] \n    bars = []\n    supports_type = [] \n\n    # store some contacts data (A face belonging to more than one block is called a contact)\n    contacts_ind = [] \n    contacts_nodes = []\n    contacts_FE = [0]\n\n    # store some faces data (A face belonging to at least one block is called face)\n\n    faces_ind = [] \n    faces_nodes = []\n    faces_FE = [0]\n\n    #store some data for external surfaces attributes\n\n    phi_type = [] # contains the friction agnle value attributated to an external surface. If no attribute is found -1 is stored\n    coh_type = [] # contains the cohesion value attributated to an external surface. If no attribute is found -1 is stored\n    lc_type = []  # contains the friction agnle value attributated to an external surface. If no attribute is found -1 is stored\n    fc_type = []\n\n    objs = rs.AllObjects()\n\n    loading_keys_interest = [\"px_l\", \"py_l\", \"pz_l\", \"pn_l\", \"px_d\", \"py_d\", \"pz_d\", \"pn_d\"]\n\n    linear_loading_key_interest = [\"wx_l\", \"wy_l\", \"wz_l\", \"wn_l\", \"wx_d\", \"wy_d\", \"wz_d\", \"wn_d\"]\n    \n    ponc_loading_key_interest = [\"fx_l\", \"fy_l\", \"fz_l\",\"mx_l\", \"my_l\", \"mz_l\",               \"fx_d\", \"fy_d\", \"fz_d\" , \"mx_d\", \"my_d\", \"mz_d\"] \n\n    loaded_faces_values = []\n    loaded_faces_adress = []\n    blocks_adress = []\n    loaded_blocks = []\n    torseur_blocks_live = []\n    torseur_blocks_dead = []\n    loaded_poly_adress = []\n    loaded_poly_values = []\n\n    loaded_points_values = []\n    loaded_points_adress = []\n\n    for obj in objs:\n        obj_type = rs.ObjectType(obj)\n\n        if obj_type == 1: # chekc if the object is a point\n            point_att = [element.lower() for element in rs.GetUserText(obj)]\n            if set(point_att) & set(ponc_loading_key_interest ):\n                loaded_points_values.append([0]*12)\n                loaded_points_adress.append(obj)\n\n\n                loading_att = set(point_att) & set(ponc_loading_key_interest )\n                for att in loading_att:\n                    \n                    att_pos = ponc_loading_key_interest.index( att.lower() )\n                   \n                    if rs.GetUserText(obj, att) != \" \":\n                        loaded_points_values[-1][att_pos] += float( rs.GetUserText(obj, att) )\n\n\n        \n        if obj_type == 4: # Check if the object is a curve\n            poly_att = [element.lower() for element in rs.GetUserText(obj)]\n            if \"fy\" in poly_att and \"as\" in poly_att:\n                bars.append(obj) \n            elif set(poly_att) & set(linear_loading_key_interest ) :\n                loaded_poly_values.append([0]*8)\n                loaded_poly_adress.append(obj)\n                \n                loading_att = set(poly_att) & set(linear_loading_key_interest )\n                for att in loading_att:\n                    \n                    att_pos = linear_loading_key_interest.index( att.lower() )\n                   \n                    if rs.GetUserText(obj, att) != \" \":\n                        loaded_poly_values[-1][att_pos] += float( rs.GetUserText(obj, att) )\n\n\n\n        if obj_type == 8: # Check if the object is a surface\n        \n            \n            boundary_curve_id = rs.DuplicateSurfaceBorder(obj)\n            # Get points along the boundary curve\n            points = rs.CurvePoints(boundary_curve_id)\n\n            rs.DeleteObjects(boundary_curve_id)\n            points = points[0:-1:]\n            \n            for i, point in enumerate(points):\n            \n                plans_data = np.append(plans_data, np.array([[ plan_ind, np.round(point[0],5) , np.round( point[1],5), np.round(point[2],5) ]]), axis = 0)\n            \n            plan_ind += 1\n            att_lcase = [item.lower() for item in  rs.GetUserText(obj)]\n        \n\n            if 'type' in att_lcase:\n                index = att_lcase.index('type')\n                if rs.GetUserText(obj, rs.GetUserText(obj)[index]) == '3':\n                    supports_type.append(3)\n                elif rs.GetUserText(obj, rs.GetUserText(obj)[index]) == '2':\n                    supports_type.append(2)\n            else:\n                supports_type.append(-1)\n\n            \n            if 'c' in att_lcase:\n                index = att_lcase.index('c')\n                coh_type.append(float(rs.GetUserText(obj, rs.GetUserText(obj)[index])))\n                \n            else:\n                coh_type.append(-1)\n            \n            if 'phi' in att_lcase:\n                index = att_lcase.index('phi')\n                phi_type.append(float(rs.GetUserText(obj, rs.GetUserText(obj)[index])))\n                \n            else:\n                phi_type.append(-1)\n\n            if 'fc' in att_lcase:\n                index = att_lcase.index('fc')\n                fc_type.append(float(rs.GetUserText(obj, rs.GetUserText(obj)[index])))\n                \n            else:\n                fc_type.append(-1)\n\n            \n            if 'lc' in att_lcase:\n                index = att_lcase.index('lc')\n                lc_type.append(float(rs.GetUserText(obj, rs.GetUserText(obj)[index])))\n                \n            else:\n                lc_type.append(-1)\n\n        \n\n\n            loading_att = set(loading_keys_interest) & set(att_lcase) # surface loading\n            \n            if loading_att:\n                loaded_faces_values.append([0]*8)\n                loaded_faces_adress.append(obj)\n\n                for att in loading_att:\n                    \n                    att_pos = loading_keys_interest.index( att.lower() )\n                  \n                    if rs.GetUserText(obj, att) != \" \":\n                        loaded_faces_values[-1][att_pos] += float( rs.GetUserText(obj, att) )\n                        \n\n\n\n                \n    \n        print(\"loadeddd face\", loaded_faces_values)\n        if obj_type in [16, 1073741824]:  # Check if the object is a solid\n            blocks_adress.append(obj)\n\n            block_name = rs.ObjectName(obj)\n            \n            blocks_brep.append(obj)\n            # Explode the solid into its faces\n            faces_data = rs.ExplodePolysurfaces(obj)\n            \n            if faces_data:\n                for face in faces_data:\n\n                    boundary_curve_id = rs.DuplicateSurfaceBorder(face)\n                    if not boundary_curve_id:\n                        print(\"Failed to extract surface boundary.\")\n                        \n        \n                    # Get points along the boundary curve\n                    points = rs.CurvePoints(boundary_curve_id)\n                    rs.DeleteObjects(boundary_curve_id)\n                    \n                    points = points[0:-1:]\n                    \n\n                    \n                    face_pts = np.empty((0,3))\n                    # Loop through the control points\n                    for i, point in enumerate(points):\n                    \n                        # Print the coordinates of each control point\n                        face_pts = np.append(face_pts, np.array([[ np.round(point[0],5), np.round(point[1],5), np.round(point[2],5) ]]), axis = 0)\n                    \n                \n                    \n                    b_centroid = rs.SurfaceVolumeCentroid(obj)[0]\n                    \n                    face_centroid = np.mean(face_pts, axis = 0)\n                    \n                    face_normal = np.cross(face_centroid - face_pts[0], face_pts[1] - face_pts[0])\n                \n                    face_normal /= np.linalg.norm(face_normal)\n                    \n                    \n                    pts_coor = np.append(pts_coor, face_pts, axis=0)\n\n                    # Get unique points and their indices\n                    pts_coor , unique_indices = np.unique(pts_coor, axis=0, return_index=True)\n\n                    # Reorder the unique points based on their original order\n                    pts_coor = pts_coor[np.argsort(unique_indices)]\n\n                    added_positions = []\n\n                    for point in face_pts:\n                        pt_position = np.where(np.all(pts_coor == point, axis=1))[0][0]\n                        added_positions.append(pt_position +1 )\n                    \n\n                    unsorted_face_rep = '#'.join(map(str, added_positions.copy() ))\n\n                    added_positions_copy = added_positions.copy()\n\n                    sorted_point_indices = sorted(set(added_positions_copy))\n                    #sorted_point_indices = [element + 1 for element in sorted_point_indices]\n\n                    face_rep = '#'.join(map(str, sorted_point_indices ))\n                \n                    if (not face_rep in faces_rep) or block_ind == 1:\n                        faces_rep.append(face_rep)\n                        f_points.append(face_pts)\n                        unsorted_faces_rep.append(unsorted_face_rep)\n\n                        faces_ind += [faces_rep.index(face_rep) + 1 ]\n                        faces_nodes += added_positions\n                        faces_FE.append(faces_FE[-1:][0] + len(added_positions))\n\n\n                        local_ref = check_outward_normal(b_centroid,face_ind,face_centroid,face_normal,local_ref)\n                        local_ref[-1:, 0] = len(faces_rep)\n                    \n                        block_name = -99\n                        blocks = np.append(blocks, np.array([[block_ind, len(faces_rep), block_name, face_ind  , 0,-1, 11 ]]), axis = 0)\n                        for ind in added_positions:\n                            faces = np.append(faces, np.array([[len(faces_rep), face_ind, ind  ]]),axis = 0) #ind or ind+1\n                    else:\n                        contacts_ind += [faces_rep.index(face_rep) + 1 ]\n                        contacts_nodes += added_positions\n                    \n                        contacts_FE.append(contacts_FE[-1:][0] + len(added_positions))\n\n                        block_name = -99\n                        blocks = np.append(blocks, np.array([[block_ind, faces_rep.index(face_rep) + 1, block_name, face_ind, 0 , -1, 22 ]]), axis = 0)\n    \n                    # Do something with each face (e.g., print face area)\n                    face_area = rs.SurfaceArea(face)[1]\n                    \n                    \n                    \n                    face_ind += 1\n\n                    #  delete the exploded face\n                    rs.DeleteObject(face)\n                    rs.DeleteObject(boundary_curve_id)\n                    \n            \n        \n            b_centroid = rs.SurfaceVolumeCentroid(obj)[0]\n            b_volume = rs.SurfaceVolume(obj)[0]\n\n            blocks_volume = np.append(blocks_volume, np.array([[block_ind, b_volume ]]), axis = 0)\n\n            blocks_centroid = np.append(blocks_centroid, np.array([[block_ind, b_centroid[0], b_centroid[1], b_centroid[2] ]]), axis = 0)\n            \n            atb_keys = rs.GetUserText(obj)\n            \n            if atb_keys:\n                \n                b_att = []\n\n                for atb_key in atb_keys:\n                    if atb_key in keys_of_interest:\n                        key_ind = keys_of_interest.index(atb_key)\n                        \n\n                        b_att.extend([key_ind +1, rs.GetUserText(obj, atb_key) ])\n                \n                blocks_att[block_ind] = b_att\n\n    \n            \n            block_ind += 1\n\n\n    nb = block_ind - 1\n\n    # Get the number of rows in the array\n    num_rows = pts_coor.shape[0]\n\n    # Create an array of 1-based indices\n    indices_column = (np.arange(num_rows) + 1).reshape(-1, 1)\n\n    # Add the indices column to the original array\n    points = np.hstack((indices_column, pts_coor),dtype = np.float64)\n\n    data[\"faces_number\"] =  len(faces_rep)\n  \n    plans_rep = []\n    supports_ind = []\n\n    if plans_data.shape[0] != 0:\n        for ind in range(plan_ind-1):\n        \n            plan_elements = plans_data[ np.where(plans_data[:,0] == ind +1 )[0] ]\n    \n            plan_pts = []\n            for  element in plan_elements:\n                pt_coor = element[-3:]\n                pt_ind = np.where( np.all(points[:,-3:] == pt_coor, axis=1)  )[0]\n                \n                plan_pts.extend(pt_ind)\n            \n            sorted_plan_pts = sorted(set(plan_pts))\n            sorted_plan_pts = [element + 1 for element in sorted_plan_pts]\n\n            plan_rep = '#'.join(map(str, sorted_plan_pts ))\n            \n            plans_rep.append(plan_rep)\n            \n        \n    for ind in contacts_ind:    blocks[np.where(blocks[:,1] == ind)[0], 4] = 1\n\n\n    supports_rep = set(plans_rep) &  set(faces_rep)\n\n    for ind in supports_rep :\n        if supports_type[plans_rep.index(ind)] == 2:\n            \n            blocks[np.where(blocks[:,1] == faces_rep.index(ind) +1)[0] , 4] = 2\n            \n            contacts_ind += [faces_rep.index(ind) +1]\n            \n            \n            unsorted_rep = unsorted_faces_rep[faces_rep.index(ind)] \n        \n            nodes_ind = [int(num) for num in unsorted_rep.split('#')]\n            \n            contacts_nodes += nodes_ind\n            \n            contacts_FE += [ contacts_FE[-1:][0] + len(nodes_ind)]\n        \n        if supports_type[plans_rep.index(ind)] == 3:\n\n            supports_ind += [faces_rep.index(ind) +1]\n            blocks[np.where(blocks[:,1] == faces_rep.index(ind) +1)[0] , 4 ] = 3\n\n            contacts_ind += [faces_rep.index(ind) +1]\n        \n            unsorted_rep = unsorted_faces_rep[faces_rep.index(ind)] \n            \n            nodes_ind = [int(num) for num in unsorted_rep.split('#')]\n            \n            contacts_nodes += nodes_ind\n            \n            contacts_FE += [ contacts_FE[-1:][0] + len(nodes_ind)]\n        if coh_type[plans_rep.index(ind)] != -1:\n            blocks[np.where(blocks[:,1] == faces_rep.index(ind) +1)[0] , 5 ] = float(coh_type[plans_rep.index(ind)])\n\n\n\n    contacts_ind_sorted = sorted(contacts_ind)\n\n    for face_pos, face_adress in enumerate(loaded_faces_adress):\n\n        face_centroid = rs.SurfaceAreaCentroid(face_adress)[0]\n        face_centroid = [face_centroid[0],face_centroid[1],  face_centroid[2] ]\n        distances , neighboors = blocks_face_neighboring( blocks_centroid[:, -3:] , face_centroid, 40  )\n        print(distances)\n\n        real_distances_pos = np.where(distances != np.inf)[0] \n\n        print(real_distances_pos)\n\n        for index in real_distances_pos:\n            \n            block_adress  = blocks_adress[neighboors[index]]\n            inter = rs.IntersectBreps(face_adress, block_adress)\n            \n            \n            if inter:\n                if rs.IsCurveClosed(inter):\n                    \n                    print(\"enteredddd\")\n                    area = rs.Area(inter)\n                    centroid = rs.CurveAreaCentroid(inter)[0]\n                    centroid = [ centroid[0],  centroid[1], centroid[2] ]\n\n                    crv_points = rs.CurvePoints(inter)  \n\n                    print(crv_points)    \n                    pt1 =  crv_points[0]\n                    pt2 =  crv_points[1]\n                    pt3 =  crv_points[-2]\n                    print(pt1)\n                    print(pt2)\n                    print(pt3)\n                    vect1 = [pt1[i]-pt2[i] for i in range(3)]\n                    vect2 = [pt3[i]-pt2[i] for i in range(3)]\n\n                    normal = np.cross(vect1, vect2)\n                    normal /= np.linalg.norm(normal)\n                    print(vect1, vect2 , normal)\n                    test_vector = [blocks_centroid[index][i+1] - centroid[i]  for i in range(3)  ]\n\n                    if np.dot(test_vector, normal ) >0:\n                        normal = [-element for element in normal]\n\n                    \n                    Dead_load = [area*loaded_faces_values[face_pos][4], area*loaded_faces_values[face_pos][5], area*loaded_faces_values[face_pos][6] ]\n                    print(Dead_load)\n\n                    Dead_load = [Dead_load[i] + normal[i]*area*loaded_faces_values[face_pos][7] for i in range(3) ]\n                        \n                    print(Dead_load)\n                    Live_load = [area*loaded_faces_values[face_pos][0], area*loaded_faces_values[face_pos][1], area*loaded_faces_values[face_pos][2] ]\n                    Live_load = [Live_load[i] + normal[i]*area*loaded_faces_values[face_pos][3] for i in range(3) ]\n                    \n                    \n\n                    moment_dead = calculate_moment(blocks_centroid[index][-3:], Dead_load  , centroid  )\n                    print(moment_dead)\n\n                    moment_live = calculate_moment(blocks_centroid[index][-3:], Live_load  , centroid  )\n\n                    if neighboors[index] not in loaded_blocks:\n                        loaded_blocks.append(neighboors[index])\n                        torseur_blocks_dead.append( [*Dead_load, *moment_dead ])\n                        torseur_blocks_live.append( [*Live_load, *moment_live ])\n                    else:\n                        block_pos = loaded_blocks.index(neighboors[index])#not sure\n\n                        torseur_blocks_dead[block_pos] = [  element + torseur_blocks_dead[block_pos][ind]  for ind, element in enumerate([*Dead_load, *moment_dead ])  ]\n                        torseur_blocks_live[block_pos] = [  element + torseur_blocks_live[block_pos][ind]  for ind, element in enumerate([*Live_load, *moment_live ]) ]\n\n\n                    \n                    \n                    rs.DeleteObjects(inter)\n    \n       \n    for point_pos, point_adress in enumerate(loaded_points_adress):\n        \n        loading_point_points = np.empty((0,3)) #mesh for poly loading and\n        points_ind = []\n\n        points_torseur_blocks_dead = []\n\n        points_torseur_blocks_live = []\n\n        points_loaded_blocks = []\n\n    \n\n        \n        point_coor = [ rs.PointCoordinates(point_adress)[0], rs.PointCoordinates(point_adress)[1], rs.PointCoordinates(point_adress)[2] ]\n        \n\n        distances , neighboors = blocks_face_neighboring( blocks_centroid[:, -3:] , point_coor , 40  )\n\n        real_distances_pos = np.where(distances != np.inf)[0] \n\n       \n        \n\n        for index in real_distances_pos:\n\n            block_adress  = blocks_adress[neighboors[index]]\n\n            faces_adress = rs.ExplodePolysurfaces(block_adress)\n            \n\n            for face in faces_adress :\n\n                if rs.IsPointOnSurface(face,point_adress):\n                   \n                    \n                    rs.DeleteObject(face)\n                    search_pt1 = np.where( np.all(loading_point_points == point_coor , axis = 1) )[0]\n                    if len(search_pt1) != 0:\n                        points_ind.append( int(search_pt1[0]) + 1)\n                    else:\n                        loading_point_points = np.append(loading_point_points , np.array([point_coor]) ,axis = 0 )\n                        points_ind.append( loading_point_points.shape[0] )\n                \n                    Dead_load = [ loaded_points_values[point_pos][6], loaded_points_values[point_pos][7], loaded_points_values[point_pos][8] ]\n                        \n                    Live_load = [ loaded_points_values[point_pos][0], loaded_points_values[point_pos][1], loaded_points_values[point_pos][2] ]\n            \n                    moment_dead = calculate_moment(blocks_centroid[neighboors[index]][-3:], Dead_load  , point_coor  )\n                    moment_live = calculate_moment(blocks_centroid[neighboors[index]][-3:], Live_load  , point_coor  )\n\n                    moment_dead = [ element1 + element2 for element1, element2 in zip(moment_dead, loaded_points_values[point_pos][9:12] ) ]   \n\n                    moment_live = [ element1 + element2 for element1, element2 in zip(moment_live, loaded_points_values[point_pos][3:6] ) ]  \n\n\n                    points_torseur_blocks_dead.append( [*Dead_load, *moment_dead ])\n                    points_torseur_blocks_live.append( [*Live_load, *moment_live ])\n\n                    points_loaded_blocks.append(neighboors[index])\n                    \n                    \n                    \n                    break\n                else:\n                 \n                    rs.DeleteObject(face)\n\n            rs.DeleteObjects(faces_adress)\n                \n      \n\n        for i, point_loaded_block in enumerate(points_loaded_blocks):\n            point_occ = points_ind.count( points_ind[i] )\n     \n\n            if point_loaded_block not in loaded_blocks:\n                loaded_blocks.append(point_loaded_block)\n                torseur_blocks_dead.append( [ element/point_occ  for element in points_torseur_blocks_dead[i]   ])\n                torseur_blocks_live.append(  [ element/point_occ  for element in points_torseur_blocks_live[i]   ])\n            \n            else:\n\n                block_pos = loaded_blocks.index(point_loaded_block)\n\n                torseur_blocks_dead[block_pos] = [  element/point_occ + torseur_blocks_dead[block_pos][ind]  for ind, element in enumerate( points_torseur_blocks_dead[i] )  ]\n                torseur_blocks_live[block_pos] = [  element/point_occ + torseur_blocks_live[block_pos][ind]  for ind, element in enumerate( points_torseur_blocks_live[i] ) ]\n\n\n\n    for poly_pos, poly_adress in enumerate(loaded_poly_adress):\n        \n        loading_poly_points = np.empty((0,3)) #mesh for poly loading and\n        polys_rep = []\n\n        poly_torseur_blocks_dead = []\n\n        poly_torseur_blocks_live = []\n\n        poly_loaded_blocks = []\n\n        points_poly = rs.CurvePoints(poly_adress)\n             \n        pt1 =  [round(points_poly[0][i],5) for i in range(3) ] \n        \n\n        distances , neighboors = blocks_face_neighboring( blocks_centroid[:, -3:] , pt1, 40  )\n\n        real_distances_pos = np.where(distances != np.inf)[0] \n\n        for index in real_distances_pos:\n\n            \n            block_adress  = blocks_adress[neighboors[index]]\n            \n            inter = rs.CurveBrepIntersect(poly_adress , block_adress   )\n            \n            \n            if inter:\n                for line in inter[0]:\n            \n                    points_poly = rs.CurvePoints(line)\n             \n                    pt1 =  [round(points_poly[0][i],5) for i in range(3) ] \n                    pt2 =  [round(points_poly[-1][i],5) for i in range(3) ]\n                    \n                    search_pt1 = np.where( np.all(loading_poly_points == pt1 , axis = 1) )[0]\n                    if len(search_pt1) != 0:\n                        pt1_pos = int(search_pt1[0]) + 1\n                    else:\n                        loading_poly_points = np.append(loading_poly_points , np.array([pt1]) ,axis = 0 )\n                        pt1_pos = loading_poly_points.shape[0]\n\n                    search_pt2 = np.where( np.all(loading_poly_points == pt2 , axis = 1) )[0]\n                    if len(search_pt2) != 0:\n                        pt2_pos = int(search_pt2[0]) + 1\n                    else:\n                        loading_poly_points = np.append(loading_poly_points , np.array([pt2]) ,axis = 0 )\n                        pt2_pos = loading_poly_points.shape[0]\n\n                    poly_rep = '#'.join(map(str, [min(pt1_pos, pt2_pos) ,  max(pt1_pos, pt2_pos) ] )) \n\n                    polys_rep.append(poly_rep)\n\n\n                    line_centroid = [ 0.5*pt1[i] + 0.5*pt2[i] for i in range(3)]\n                    line_length = rs.CurveLength(line)\n            \n                    Dead_load = [line_length*loaded_poly_values[poly_pos][4], line_length*loaded_poly_values[poly_pos][5], line_length*loaded_poly_values[poly_pos][6] ]\n                    \n                    Live_load = [line_length*loaded_poly_values[poly_pos][0], line_length*loaded_poly_values[poly_pos][1], line_length*loaded_poly_values[poly_pos][2] ]\n          \n                    moment_dead = calculate_moment(blocks_centroid[neighboors[index]][-3:], Dead_load  , line_centroid  )\n                    moment_live = calculate_moment(blocks_centroid[neighboors[index]][-3:], Live_load  , line_centroid  )\n\n\n                    poly_torseur_blocks_dead.append( [*Dead_load, *moment_dead ])\n                    poly_torseur_blocks_live.append( [*Live_load, *moment_live ])\n\n                    poly_loaded_blocks.append(neighboors[index])\n\n                    rs.DeleteObjects(line)  \n        \n        for i, poly_loaded_block in enumerate(poly_loaded_blocks):\n            poly_occ = polys_rep.count( polys_rep[i] )\n      \n\n            if poly_loaded_block not in loaded_blocks:\n                loaded_blocks.append(poly_loaded_block)\n                torseur_blocks_dead.append( [ element/poly_occ  for element in poly_torseur_blocks_dead[i]   ])\n                torseur_blocks_live.append(  [ element/poly_occ  for element in poly_torseur_blocks_live[i]   ])\n            \n            else:\n\n                block_pos = loaded_blocks.index(poly_loaded_block)\n\n                torseur_blocks_dead[block_pos] = [  element/poly_occ + torseur_blocks_dead[block_pos][ind]  for ind, element in enumerate( poly_torseur_blocks_dead[i] )  ]\n                torseur_blocks_live[block_pos] = [  element/poly_occ + torseur_blocks_live[block_pos][ind]  for ind, element in enumerate( poly_torseur_blocks_live[i] ) ]\n        #jkjk\n\n\n\n    supports_pos = []\n    for ind in supports_ind:\n        supports_pos += [contacts_ind_sorted.index(ind)]\n\n\n\n    curve_ids = bars\n\n    if not curve_ids:\n        print(\"No curve selected. Exiting...\")\n        #quit()\n    rs.EnableRedraw(False)\n\n\n    bpts_inter = np.empty((0,3))\n    bars_data = np.empty((0,7))\n\n    ##Calculate steel rebars load and moment effect\n\n    for block_ind, solid_id in enumerate(blocks_brep):\n        pts_pos = set()\n        # Split the curves with the solid\n        for curve_id in curve_ids:\n            added_positions = []\n            att_num = 0\n\n            atb_keys = rs.GetUserText(curve_id)   \n            if atb_keys:\n                \n                for atb_key in atb_keys:\n                    if atb_key == 'A':\n                        bar_area = rs.GetUserText(curve_id, 'A')\n                        att_num += 1\n                    if atb_key == 'fy':\n                        bar_fy = rs.GetUserText(curve_id, 'fy')\n                        att_num += 1\n                        \n            if att_num == 2:\n                exploded_curve = rs.ExplodeCurves(curve_id)\n            \n                for line in exploded_curve:\n                    start_pt = rs.CurvePoints(line)[0]\n                    end_pt = rs.CurvePoints(line)[1]\n                \n                    bar_dir = np.array([start_pt[0]- end_pt[0]  , start_pt[1]- end_pt[1], start_pt[2]- end_pt[2]  ] )\n                    \n                    bar_dir /= np.linalg.norm(bar_dir)  \n                    bar_dir = [np.round(element, 5)  for element in bar_dir]\n                    # Check if the curve intersects with the solid\n                    if rs.CurveBrepIntersect(line, solid_id):\n            \n                        \n                        inter1_coor = rs.PointCoordinates((rs.CurveBrepIntersect(line, solid_id)[1][0]))\n                        inter1_coor = [inter1_coor[0], inter1_coor[1], inter1_coor[2] ]\n                        part_to_add = np.array( [inter1_coor])\n\n                        if len(rs.CurveBrepIntersect(line, solid_id)[1]) == 2:\n                            inter2_coor = rs.PointCoordinates((rs.CurveBrepIntersect(line, solid_id)[1][1]))\n                            inter2_coor = [inter2_coor[0], inter2_coor[1], inter2_coor[2]]\n                            part_to_add = np.array( [inter1_coor, inter2_coor])\n                    \n                        part_to_add = np.round(part_to_add, decimals=5)\n\n                        bpts_inter = np.append(bpts_inter, part_to_add , axis = 0)\n                        # Get unique points and their indice\n                        bpts_inter , unique_indices = np.unique(bpts_inter, axis=0, return_index=True)\n                \n                        # Reorder the unique points based on their original order\n                        bpts_inter = bpts_inter[np.argsort(unique_indices)]\n                    \n                        # Use broadcasting to compare all points in points_array with each point in set_of_points\n                        matches = np.all(np.expand_dims( bpts_inter, axis=1) == part_to_add, axis=2)\n\n                        # Find row indices where any row in set_of_points matches points_array\n                        added_positions = np.where(matches.any(axis=1))[0]\n                    \n                \n                        \n                        if len(added_positions) != 0:\n                            \n                            for  pt_pos in added_positions:\n                                \n                                pt_coor = bpts_inter[pt_pos]\n                                if np.dot(bar_dir, np.array(blocks_centroid[block_ind, -3:] )- np.array(pt_coor)) > 0:\n                                    bar_dir = [-1*element for element in bar_dir]\n                                \n                                bars_data = np.append( bars_data, np.array([[int(block_ind +1) , int(pt_pos +1), float(bar_area), float(bar_fy), *bar_dir  ]] ),axis = 0   )  \n            \n                rs.DeleteObjects(exploded_curve)\n\n    rs.EnableRedraw(True)\n\n\n    \n\n    lc_faces_val = lc*np.ones((len(contacts_ind)), dtype = np.float64)\n\n\n    for ind, lc_face  in enumerate(lc_type):\n        if lc_face != -1:\n        \n            face_ind = faces_rep.index( plans_rep[ind] )\n            contact_ind = contacts_ind.index(face_ind + 1)\n        \n            lc_faces_val[contact_ind] = float(lc_face)\n\n\n    bars_data = np.unique(bars_data,axis = 0)\n\n    contacts_ind = np.array(contacts_ind, dtype = np.int32)\n    contacts_nodes = np.array(contacts_nodes, dtype = np.int32)\n    contacts_FE = np.array(contacts_FE, dtype = np.int32)\n\n    \n\n    contacts_ind = np.array(contacts_ind, dtype = np.int32)\n    faces_nodes = np.array(faces_nodes, dtype = np.int32)\n    faces_FE = np.array(faces_FE, dtype = np.int32)\n\n    data[\"points\"] = points\n    data[\"blocks\"] = blocks\n    data[\"faces\"] = faces\n    data[\"blocks_volume\"] = blocks_volume\n    data[\"blocks_centroid\"] = blocks_centroid\n    data[\"local_ref\"] = local_ref\n    data[\"lc_faces_val\"] = lc_faces_val\n    data[\"contacts_ind\"] = contacts_ind\n    data[\"faces_FE\"] = faces_FE\n    data[\"faces_nodes\"] = faces_nodes\n\n    data[\"faces_rep\"] = faces_rep\n    data[\"plans_rep\"] = plans_rep\n\n    data[\"supports_pos\"] = supports_pos\n    data[\"coh_type\"] = coh_type\n    data[\"phi_type\"] = phi_type\n    data[\"fc_type\"] = fc_type\n    data[\"blocks_att\"] = blocks_att\n    data[\"bpts_inter\"] = bpts_inter\n    data[\"bars_data\"] = bars_data\n\n    data[\"contacts_ind_sorted\"] = contacts_ind_sorted\n\n    data[\"nb\"] = nb\n    data[\"loaded_blocks\"] = loaded_blocks\n    data[\"torseur_blocks_dead\"] = torseur_blocks_dead\n    data[\"torseur_blocks_live\"] = torseur_blocks_live\n\n    read_data_end = time.time()\n\n    calc_time = dict()\n    data[\"calc_time\"] = {\"read_rhino_data_time\" : read_data_end - read_data_start }\n\n    \n    \n    \n\n    return data\n    \n\n\n#### second part \ndef generate_mesh_and_construct_matrices(data):  \n    \n    contacts_ind = data[\"contacts_ind\"]\n    blocks = data[\"blocks\"]\n    points = data[\"points\"]\n    faces_FE = data[\"faces_FE\"]\n    faces_nodes = data[\"faces_nodes\"]\n    blocks_centroid = data[\"blocks_centroid\"]\n    local_ref = data[\"local_ref\"]\n    lc_faces_val = data[\"lc_faces_val\"]\n\n    coh_type = data[\"coh_type\"]\n    supports_pos = data[\"supports_pos\"]\n    faces_rep = data[\"faces_rep\"] \n    plans_rep = data[\"plans_rep\"]\n    contacts_ind_sorted = data[\"contacts_ind_sorted\"]\n    phi_type = data[\"phi_type\"]\n    \n    #fc_type = data[\"fc_type\"]\n\n    tri_mesh = data[\"tri_mesh\"]\n\n    lc_ncn = data[\"lc_ncn\"]\n\n    # Call C++ function \n\n    points_coor = np.array(points[:,1:4] , dtype = np.float64)\n   \n\n    output = mesh.generate_mesh_and_construct_matrices( contacts_ind,  blocks , points_coor,  faces_FE, faces_nodes, blocks_centroid , \\\n                        local_ref, np.array(lc_faces_val, dtype = np.float64), lc_ncn, tri_mesh )\n\n    \n    data[\"calc_time\"][\" \"] = \" \"\n    data[\"calc_time\"][\"faces_mesh\"] = output[-1:][0][0]\n    data[\"calc_time\"][\"read_mesh\"] = output[-1:][0][1]\n    data[\"calc_time\"][\"Cpp_matrices_construction\"] = output[-1:][0][2]\n\n   \n    supports_nodes = set()\n\n\n    for pos in supports_pos:\n        for tri in output[7][pos]:\n                supports_nodes.update({ element for element in tri } )\n\n    supports_nodes = list(supports_nodes)\n\n    all_coh_nodes = []\n    all_coh_val = []\n\n\n    for ind, coh in enumerate(coh_type):\n        if coh != -1:\n            faces_pos = faces_rep.index( plans_rep[ind] )\n            contact_pos = contacts_ind_sorted.index( faces_pos + 1 )\n\n            contact_nodes = []\n            for tri in output[7][contact_pos]:\n                contact_nodes += [element for element in tri if element not in contact_nodes ]\n            \n            all_coh_nodes += contact_nodes \n            all_coh_val += [coh for i in range(len(contact_nodes))] \n\n\n    all_coh_nodes = list(all_coh_nodes)\n\n\n    all_phi_nodes = []\n    all_phi_val = []\n \n    for ind, phi in enumerate(phi_type):\n        if phi != -1:\n            \n            faces_pos = faces_rep.index( plans_rep[ind] )\n            contact_pos = contacts_ind_sorted.index( faces_pos + 1 )\n\n            contact_nodes = []\n            for tri in output[7][contact_pos]:\n                contact_nodes += [element for element in tri if element not in contact_nodes ]\n            \n            all_phi_nodes += contact_nodes\n            all_phi_val += [phi for i in range(len(contact_nodes))] \n\n    all_fc_nodes = []\n    all_fc_val = []\n\n    fc_type = data[\"fc_type\"]\n    for ind, fc in enumerate(fc_type):\n        if fc != -1:\n            \n            faces_pos = faces_rep.index( plans_rep[ind] )\n            contact_pos = contacts_ind_sorted.index( faces_pos + 1 )\n\n            contact_nodes = []\n            for tri in output[7][contact_pos]:\n                \n                contact_nodes += [element for element in tri if element not in contact_nodes ]\n            \n            all_fc_nodes += contact_nodes\n            all_fc_val += [fc for i in range(len(contact_nodes))] \n\n    \n\n\n    all_fc_nodes = list(all_fc_nodes)\n    all_phi_nodes = list(all_phi_nodes)\n\n    data[\"supports_nodes\"] = supports_nodes\n    \n    data[\"all_phi_nodes\"] = all_phi_nodes\n    data[\"all_fc_nodes\"] = all_fc_nodes\n    data[\"all_coh_nodes\"] = all_coh_nodes\n\n    data[\"all_phi_val\"] = all_phi_val\n    data[\"all_fc_val\"] = all_fc_val\n    data[\"all_coh_val\"] = all_coh_val\n    \n    data[\"Coutput\"] = output\n \n    return data\n\n\n### third part\n\n\n\n# Define a stream printer to capture the solver output\ndef stream_printer(text,log_path):\n    with open(log_path, \"a\") as f:\n        f.write(text)\n\n\n# New function to add a title/header to the log file\ndef add_solution_title(title,log_path):\n    with open(log_path, \"a\") as f:\n        f.write(f\"\\n{title}\\n\")  # Write the title with newlines for separation\n        f.flush()  # Explicitly flush to ensure it's written immediately\n\ndef log_objective_value(task,log_path):\n    obj_value = task.getprimalobj(mosek.soltype.itr)  # Assuming you're interested in the interior solution\n    with open(log_path, \"a\") as f:\n        f.write(f\"Objective Value: {obj_value}\\n\")\n        f.flush()\n\ndef solve_problem_with_solvers(data):\n    loaded_blocks = data[\"loaded_blocks\"]  \n    torseur_blocks_dead= data[\"torseur_blocks_dead\"] \n    torseur_blocks_live = data[\"torseur_blocks_live\"] \n\n    fig = go.Figure()\n\n    \n    nb = data[\"nb\"]\n\n    output = data[\"Coutput\"]  \n    \n    equilibrium_matrix_row = output[1]\n    equilibrium_matrix_col = output[2]\n    equilibrium_matrix = output[0]\n\n    equilibrium_matrix_load_row = output[4]\n    equilibrium_matrix_load_col = output[5]\n    equilibrium_matrix_load = output[3]\n\n    area = output[12]\n\n \n    n = int((max(equilibrium_matrix_col)+1)/3)\n    \n    \n    equilibrium_matrix_row = [int(element) for element in equilibrium_matrix_row]\n\n    equilibrium_matrix_col = [int(element) for element in equilibrium_matrix_col]\n\n\n    equilibrium_matrix_load_row = [int(element) for element in equilibrium_matrix_load_row]\n\n    equilibrium_matrix_load_col = [int(element) for element in equilibrium_matrix_load_col]\n\n\n    live_load = [0]*6*nb\n    \n    blocks_att = data[\"blocks_att\"]\n    bpts_inter = data[\"bpts_inter\"] \n\n    #### blocks attributes\n \n\n    for index, block_ind in enumerate(loaded_blocks):\n        block_att = [ ]\n        live = [0]*6\n       \n        \n\n        if block_ind + 1 in blocks_att : # are both floats\n                for att in range(0, len(blocks_att[block_ind + 1]), 2):\n                    live[ blocks_att[block_ind + 1][att] - 1 ] += float(blocks_att[block_ind + 1][att + 1])\n        \n        \n        live = [live[i] + torseur_blocks_live[index][i] for i in range(6)]\n\n        for ind, element in enumerate(live):\n            if abs(element) > 1e-10:\n                block_att += [ind+1, element]\n        \n        blocks_att[block_ind + 1] = block_att\n\n    for block_ind , block_attributes in blocks_att.items():\n        for ind in range(0,len(block_attributes),2):\n            key = block_attributes[ind]\n            \n            \n            val = block_attributes[ind+1]\n            \n            #live_load[block_ind*6 - 6 + key - 1] =  float(val)\n            \n            equilibrium_matrix.append( float(val))\n            equilibrium_matrix_row.append(  (block_ind)*6 - 6 + key - 1  )\n            equilibrium_matrix_col.append(3*n)\n\n            equilibrium_matrix_load.append( float(val))\n            equilibrium_matrix_load_row.append(  (block_ind)*6 - 6 + key - 1  )\n            equilibrium_matrix_load_col.append(3*n)\n    \n    \n\n    c = np.zeros((3*n +1,1))\n  \n    c[3*n] = -1\n\n    #c = matrix(c) \n    \n    b = np.zeros((6*nb,1 )) \n    \n    blocks_volume = data[\"blocks_volume\"]\n    \n    density = 1.4e-5 # blocks density\n    density = data[\"blocks_density\"]\n    \n\n    weight = 0\n    volume = 0\n   \n    for block_ind, block_volume in enumerate(blocks_volume):\n        b[6*block_ind +2] = density*block_volume[1] \n        volume += block_volume[1] \n        weight += density*block_volume[1] \n        if data[\"seisme\"]:\n            equilibrium_matrix.append( density*block_volume[1]  )\n            equilibrium_matrix_row.append(  (block_ind)*6    )\n            equilibrium_matrix_col.append(3*n)\n\n            equilibrium_matrix_load.append( density*block_volume[1]  )\n            equilibrium_matrix_load_row.append(  (block_ind)*6   )\n            equilibrium_matrix_load_col.append(3*n)\n\n        if data[\"self_weight_failure\"]:\n            equilibrium_matrix.append( -density*block_volume[1]  )\n            equilibrium_matrix_row.append(  (block_ind)*6 + 2    )\n            equilibrium_matrix_col.append(3*n)\n\n            equilibrium_matrix_load.append( -density*block_volume[1]  )\n            equilibrium_matrix_load_row.append(  (block_ind)*6  + 2 )\n            equilibrium_matrix_load_col.append(3*n)\n\n    \n    for ind ,block_ind in enumerate(loaded_blocks):\n        \n        b[6*block_ind:6*block_ind+6] = [ b[6*block_ind+i  ] - torseur_blocks_dead[ind][i]   for i in range(6)]\n\n    \n    print(torseur_blocks_dead)\n\n \n    # sparse matrices for the stresses approach to be used in Mosek solver\n    aval = equilibrium_matrix\n    acol = equilibrium_matrix_col\n    arow = equilibrium_matrix_row\n\n\n    # sparse matrices for the loads approach to be used in Mosek solver\n\n    aval_load = equilibrium_matrix_load\n    acol_load = equilibrium_matrix_load_col\n    arow_load = equilibrium_matrix_load_row\n\n    avalk = equilibrium_matrix\n    acolk = equilibrium_matrix_col\n    arowk = equilibrium_matrix_row\n    \n\n    ####Steel rebars attributes\n\n    bars_cap = []\n    bars_data = data[\"bars_data\"]\n    blocks_centroid = data[\"blocks_centroid\"]\n\n    for ind, point_coor in enumerate(bpts_inter):\n        blocks_data = bars_data[ np.where(bars_data[:,1] == ind +1)[0] ]\n        var_col = max(acol) + 1\n        \n        bars_cap.append( float(blocks_data[0][2]) * float(blocks_data[0][3] ) )\n        \n        for block in blocks_data:\n            block_ind = int(block[0]) - 1\n            block_centroid = blocks_centroid[block_ind][-3:]\n            bar_dir = block[-3:]\n            bar_dir = [float(element) for element in bar_dir]\n            \n            bar_moment = calculate_moment( block_centroid, bar_dir, point_coor )\n            \n            bar_tor = list(bar_dir) + list(bar_moment)\n        \n            nzero_pos = [ind for ind in range(6) if np.round(bar_tor[ind],5) != 0]\n            \n            for pos in nzero_pos:\n                \n                arow.append( block_ind*6 + pos )\n                acol.append( var_col )\n                aval.append( float(bar_tor[pos]) )\n\n                arow_load.append( block_ind*6 + pos )\n                acol_load.append( var_col )\n                aval_load.append( float(bar_tor[pos]) )\n\n\n\n    # Since the actual value of Infinity is ignores, we define it solely\n    # for symbolic purposes:\n    inf = 0.0\n\n    nef = n\n    supports_nodes = data[\"supports_nodes\"]\n    all_phi_nodes = data[\"all_phi_nodes\"]\n    all_coh_nodes = data[\"all_coh_nodes\"]\n\n    all_coh_val = data[\"all_coh_val\"]\n    all_phi_val = data[\"all_phi_val\"]\n\n    # Get the directory of the current script\n    rhino_file_dir = data[\"rhino_file_path\"]\n\n    # Construct the path to the log file in the same directory as the script\n    log_path = os.path.join(rhino_file_dir, 'lower_upper_bounds_solutions.log')\n\n\n    data[\"all_unique_points\"] = output[6]\n    data[\"all_triangles\"] = output[7]\n    #triangles_num = max(output[8]) \n\n    data[\"noc_triangles_coor\"] = output[9]\n    data[\"noc_triangles\"] = output[10]\n    #Ntriangles_num = max(output[11]) \n\n    blocks_mesh_parav( data )\n\n    with open(log_path, \"w\") as f:\n        f.write(\"\")  # Clear the file\n\n\n    if data[\"lower_bound_calc\"]:\n        \n        prep_data_lower_bound_start = time.time()\n        add_solution_title(\"Lower Bound Problem: \", log_path)\n        with mosek.Task() as task:\n            task = mosek.Task() \n            # Attach a printer to the task\n            task.set_Stream(mosek.streamtype.log, streamprinter)\n\n            bkx_lb = []\n            cohs = []\n            blx_lb = []\n            bux_lb = []\n\n            \n            for i in range(nef):\n                if (i+1) not in supports_nodes:\n                    \n                    fc = data[\"fc\"]\n                    if (i+1) in data[\"all_fc_nodes\"]:\n                        fc = float( data[\"all_fc_val\"][ data[\"all_fc_nodes\"].index(i + 1)])\n\n                    if fc != False:    \n                        blx_lb += [-inf, -inf , -abs(fc)  ] #variables lower bounds\n                        bkx_lb += [mosek.boundkey.fr, mosek.boundkey.fr, mosek.boundkey.ra] #variables TYPE\n                    else:\n                        blx_lb += [-inf, -inf , -inf ] #variables lower bounds\n                        bkx_lb += [mosek.boundkey.fr, mosek.boundkey.fr, mosek.boundkey.up] #variables TYPE\n                else:\n                    bkx_lb += [mosek.boundkey.fr, mosek.boundkey.fr, mosek.boundkey.fr] #variables TYPE\n                    blx_lb += [-inf, -inf , -inf  ] #variables lower bounds\n            \n            bkx_lb +=  [mosek.boundkey.lo]*1 + [mosek.boundkey.ra]*len(bars_cap)\n\n            \n           \n                \n                \n            blx_lb +=  [0]*1 +  [ -0*element for element in bars_cap] \n\n           \n            ft = data[\"ft\"] \n            for i in range(nef):\n                if i not in supports_nodes:\n                    bux_lb += [inf, inf , abs(ft) ] #variables upper bounds\n                else:\n                    bux_lb += [inf, inf , inf ] #variables upper bounds\n                \n            bux_lb += [inf]*1 + list(bars_cap) #variables upper bounds\n\n            \n            bkc_lb = [mosek.boundkey.fx]*nb*6 #type of constraints (equalities here)\n            print(\"bbbbb\", b )\n            blc_lb = list(b)    #b for equalities\n            buc_lb = list(b) #b for equalities\n          \n        \n            \n            c_lb = np.zeros((3*nef +1,1))\n           \n            c_lb[3*nef] = -1\n            \n            z_lb = [element for element in list(c_lb)] + [0]*len(bars_cap) #objective function \n\n            aval_lb = list(aval)\n            arow_lb = list(arow)\n            acol_lb = list(acol)\n\n\n            ####### a remettre\n            if False:\n                # equalities for kinematic problem\n                arowk = acol.copy()\n                acolk = arow.copy()\n                avalk = aval.copy()\n                for i in range(3*nef):\n                    index = arowk.index(i)\n                    arowk.insert(index, i)\n                    acolk.insert(index, 6*nb + i)\n                    avalk.insert(index, 1)\n                    if ((i+1) % 3 == 0):\n                        index = arowk.index(i)\n                        arowk.insert(index, i)\n                        acolk.insert(  index, 6*nb + 3*n + int((i+1)/3) - 1 )\n                        avalk.insert(index, 1)\n\n             ###### till here        \n      \n           \n            num_lists = 3*nef + 1 + len(bars_cap)  # Adjust the number of inner lists \n    \n          \n            asub_mos_lb = [[] for _ in range(num_lists)]\n            aval_mos_lb  = [[] for _ in range(num_lists)]\n            \n            for i,j in enumerate(acol_lb):\n                asub_mos_lb[int(j)].append(arow_lb[i])\n                aval_mos_lb[int(j)].append(aval_lb[i])\n            \n            numvar_lb = len(bkx_lb)\n            numcon_lb = len(bkc_lb)\n            NUMANZ = 4 \n    \n         # Append 'numcon' empty constraints.\n            # The constraints will initially have no bounds.\n            task.appendcons(numcon_lb)\n    \n            #Append 'numvar' variables.\n            # The variables will initially be fixed at zero (x=0).\n            task.appendvars(numvar_lb)\n    \n            for j in range(numvar_lb):\n                # Set the linear term c_j in the objective.\n                task.putcj(j, z_lb[j])\n                # Set the bounds on variable j\n                # blx[j] <= x_j <= bux[j]\n                task.putvarbound(j, bkx_lb[j], blx_lb[j], bux_lb[j])\n            \n            \n            for j in range(len(aval_mos_lb)):\n                # Input column j of A\n                task.putacol(j,     asub_mos_lb[j],aval_mos_lb[j])            # Non-zero Values of column j.\n            \n         \n        # Input the affine conic constraints\n            task.appendafes(3*nef)\n         \n            list_con_lb = []\n            list_coef_lb = []\n         \n            for ind in range(nef):\n                if (ind +1) not in supports_nodes:\n                    friction_ang = data[\"friction_ang\"]\n                    c = data[\"c\"] # input value\n  \n                    if (ind+1) in all_phi_nodes:\n                        friction_ang = float(all_phi_val[all_phi_nodes.index(ind + 1)])\n      \n                    if (ind+1) in all_coh_nodes:\n                        c = all_coh_val[all_coh_nodes.index(ind+1)]\n                    \n                    cohs += [-c,0,0]\n                    list_con_lb += [3*ind + 2 , 3*ind,3*ind + 1]\n                   \n                    list_coef_lb += [-math.tan(math.radians(friction_ang)),1.0,1.0]\n                    \n             \n            task.putafefentrylist(range(3*nef - len(supports_nodes) ),                      # Rows\n                                list_con_lb ,            # Columns \n                                list_coef_lb  )          #coefficients\n    \n            # Quadratic cone (x(3),x(0),x(1)) \\in QUAD_3 \n            \n            \n            coh_vect_lb = []\n            for ind in range(nef - len(supports_nodes) ):\n                \n                #if ind not in all_supports_ind:\n                if True:\n                   \n                    coh = cohs[3*ind: 3*ind +3]\n                   \n                    coh_vect_lb += coh\n                    quadcone  = task.appendquadraticconedomain(3)\n                    task.appendacc(quadcone,          [3*ind, 3*ind +1, 3*ind + 2],  coh)                    # None if there is no b for conic \n           \n            \n\n            for i in range(numcon_lb):\n                task.putconbound(i, bkc_lb[i], blc_lb[i], buc_lb[i])\n    \n    \n           # Input the objective sense (minimize/maximize)\n            task.putobjsense(mosek.objsense.minimize)\n\n            # Define a stream printer to capture the solver output\n          \n\n            # Attach the stream printer to the task for logging\n            task.set_Stream(mosek.streamtype.log, lambda text: stream_printer(text, log_path))\n            \n            \n            \n            # Now, when you run the optimizer, detailed output will be captured in the specified log file\n            prep_data_lower_bound_end = time.time()\n\n            task.optimize()\n\n            calc_lower_bound_end = time.time()\n\n            log_objective_value(task,log_path)\n\n            data[\"calc_time\"][\"prep_data_lower_bound\"] =   prep_data_lower_bound_end - prep_data_lower_bound_start \n            data[\"calc_time\"][\"calc_data_lower_bound\"] = calc_lower_bound_end - prep_data_lower_bound_end \n\n\n            \n            # Print a summary containing information\n            # about the solution for debugging purposes\n            #task.solutionsummary(mosek.streamtype.msg)\n            prosta = task.getprosta(mosek.soltype.itr)\n            solsta = task.getsolsta(mosek.soltype.itr)\n    \n            # Output a solution\n            xx_lb = task.getxx(mosek.soltype.itr)\n            ub = [task.getsuc(mosek.soltype.itr)[ind] - task.getslc(mosek.soltype.itr)[ind]  for ind in range(6*nb) ] # get dual variables for equilibrium but why upper ? not slb\n            #print(\"xxx\",xx)\n            #print(task.getsuc(mosek.soltype.itr)[0:6*nb])\n            #print(task.getslc(mosek.soltype.itr)[0:6*nb])\n            #print(ub)\n\n            stat_parav(data, \"lb\",xx_lb[0:3*nef + 1])\n\n            kin_parav(data, \"lb\",ub)\n\n           \n\n            if solsta == mosek.solsta.optimal:\n                print(\"Objective: %s\" % xx_lb[-1:])\n                #print(\"Optimal solution: %s\" % dual(xx))\n                # Get dual variables for the linear constraints\n            elif solsta == mosek.solsta.dual_infeas_cer:\n                print(\"Primal or dual infeasibility.\\n\")\n            elif solsta == mosek.solsta.prim_infeas_cer:\n                print(\"Primal or dual infeasibility.\\n\")\n            elif mosek.solsta.unknown:\n                print(\"Unknown solution status\")\n            else:\n                print(\"Other solution status\")\n          \n\n    if data[\"upper_bound_calc\"]:\n        prep_data_upper_bound_start = time.time()\n        add_solution_title(\"Upper Bound Problem: \", log_path)\n        with mosek.Task() as task:\n            task = mosek.Task() \n\n            \n            bkx_ub = []\n            cohs = []\n\n            blx_ub = []\n            bux_ub = []\n\n            #bkx = [mosek.boundkey.fr, mosek.boundkey.fr, mosek.boundkey.up]*nef   #variables lower bounded, if free just put .fr\n            for i in range(nef):\n                if (i+1) not in supports_nodes:\n                    \n                    fc = data[\"fc\"]\n                    if (i+1) in data[\"all_fc_nodes\"]:\n                        fc = float( data[\"all_fc_val\"][ data[\"all_fc_nodes\"].index(i + 1)])\n\n                    if fc != False:    \n                        blx_ub += [-inf, -inf , -abs(fc)*abs(area[i])  ] #variables lower bounds\n                        bkx_ub += [mosek.boundkey.fr, mosek.boundkey.fr, mosek.boundkey.ra] #variables TYPE\n                    else:\n                        blx_ub += [-inf, -inf , -inf ] #variables lower bounds\n                        bkx_ub += [mosek.boundkey.fr, mosek.boundkey.fr, mosek.boundkey.up] #variables TYPE\n                else:\n                    bkx_ub += [mosek.boundkey.fr, mosek.boundkey.fr, mosek.boundkey.fr] #variables TYPE\n                    blx_ub += [-inf, -inf , -inf  ] #variables lower bounds\n\n            bkx_ub +=  [mosek.boundkey.lo]*1 + [mosek.boundkey.ra]*len(bars_cap)\n                              \n            blx_ub +=  [0]*1 +  [ -0*element for element in bars_cap] \n            \n            for i in range(nef):\n                if (i+1) not in supports_nodes:\n                    bux_ub += [inf, inf , 0 ] #variables upper bounds\n                else:\n                   \n                    bux_ub += [inf, inf , inf ] #variables upper bounds\n                \n            bux_ub += [inf]*1 + list(bars_cap) #variables upper bounds\n  \n            \n            bkc_ub = [mosek.boundkey.fx]*nb*6 #type of constraints (equalities here)\n            blc_ub = list(b)    #b for equalities\n            buc_ub = list(b) #b for equalities\n          \n        \n            \n            c = np.zeros((3*nef +1,1))\n            #c =  spmatrix( [-1], [3*n], [0], (3*n +1, 1 ) )   \n           \n            c[3*nef] = -1\n          \n            z_ub = [element for element in list(c)] + [0]*len(bars_cap) #objective function \n\n            \n       \n            aval_ub = list(aval_load)\n            arow_ub = list(arow_load)\n            acol_ub = list(acol_load)\n \n           \n            num_lists = 3*nef + 1 + len(bars_cap)   # Adjust the number of inner lists as needed\n    \n          \n            asub_mos_ub = [[] for _ in range(num_lists)]\n            aval_mos_ub  = [[] for _ in range(num_lists)]\n            \n            for i,j in enumerate(acol_ub):\n                asub_mos_ub[int(j)].append(arow_ub[i])\n                aval_mos_ub[int(j)].append(aval_ub[i])\n            \n\n            numvar_ub = len(bkx_ub)\n            numcon_ub = len(bkc_ub)\n            NUMANZ = 4 \n    \n         # Append 'numcon' empty constraints.\n            # The constraints will initially have no bounds.\n            task.appendcons(numcon_ub)\n    \n            #Append 'numvar' variables.\n            # The variables will initially be fixed at zero (x=0).\n            task.appendvars(numvar_ub)\n    \n            for j in range(numvar_ub):\n                # Set the linear term c_j in the objective.\n                task.putcj(j, z_ub[j])\n                task.putvarbound(j, bkx_ub[j], blx_ub[j], bux_ub[j])\n            \n            \n            for j in range(len(aval_mos_ub)):\n                \n               \n                # Input column j of A\n                task.putacol(j,     asub_mos_ub[j],aval_mos_ub[j])            # Non-zero Values of column j.\n            \n         \n        # Input the affine conic constraints\n            # Create a matrix F such that F * x = [x(3),x(0),x(1),x(4),x(5),x(2)] \n            task.appendafes(3*nef)\n         \n            list_con_ub = []\n            list_coef_ub = []\n           \n            \n            for ind in range(nef):\n                if (ind +1) not in supports_nodes:\n                    friction_ang = data[\"friction_ang\"]\n                    c = data[\"c\"]*area[ind] # input value\n                    \n                    if (ind+1) in all_phi_nodes:\n                        friction_ang = float(all_phi_val[all_phi_nodes.index(ind + 1)])\n      \n                    if (ind+1) in all_coh_nodes:\n                        c = all_coh_val[all_coh_nodes.index(ind+1)]*area[ind]\n                        \n                    cohs += [-c,0,0]\n                    list_con_ub += [3*ind + 2 , 3*ind,3*ind + 1]\n                   \n                    list_coef_ub += [-math.tan(math.radians(friction_ang)),1.0,1.0]\n                    \n             \n            task.putafefentrylist(range(3*nef - len(supports_nodes) ),                      # Rows\n                                list_con_ub ,            # Columns \n                                list_coef_ub  )          #coefficients\n    \n        \n            coh_vect_ub = []\n            for ind in range(nef - len(supports_nodes) ):\n                \n                #if ind not in all_supports_ind:\n                if True:\n                   \n                    coh = cohs[3*ind: 3*ind +3]\n                   \n                    coh_vect_ub += coh\n                    quadcone  = task.appendquadraticconedomain(3)\n                    task.appendacc(quadcone,          [3*ind, 3*ind +1, 3*ind + 2],  coh)                    # None if there is no b for conic \n           \n            \n           \n            \n            for i in range(numcon_ub):\n                task.putconbound(i, bkc_ub[i], blc_ub[i], buc_ub[i])\n    \n    \n        # Input the objective sense (minimize/maximize)\n            task.putobjsense(mosek.objsense.minimize)\n\n            task.set_Stream(mosek.streamtype.log, lambda text: stream_printer(text, log_path))\n\n            prep_data_upper_bound_end = time.time()\n            \n            # Optimize the task\n            task.optimize()\n\n            calc_upper_bound_end = time.time()\n\n            data[\"calc_time\"][\"prep_data_upper_bound\"] =  prep_data_upper_bound_end - prep_data_upper_bound_start \n            data[\"calc_time\"][\"calc_data_upper_bound\"] =  calc_upper_bound_end - prep_data_upper_bound_end \n\n\n            log_objective_value(task,log_path)\n            #task.writedata(\"cqo1.ptf\")\n            # Print a summary containing information\n            # about the solution for debugging purposes\n            #task.solutionsummary(mosek.streamtype.msg)\n            prosta = task.getprosta(mosek.soltype.itr)\n            solsta = task.getsolsta(mosek.soltype.itr)\n    \n            # Output a solution\n            xx_ub = task.getxx(mosek.soltype.itr)\n            ub = [task.getsuc(mosek.soltype.itr)[ind] - task.getslc(mosek.soltype.itr)[ind]  for ind in range(6*nb) ] # get dual variables for equilibrium but why upper ? not slb\n            \n\n            stat_parav(data, \"ub\",xx_ub[0:3*nef + 1])\n\n            kin_parav(data, \"ub\",ub)\n            \n            #skc, y = task.getsolution(mosek.soltype.bas)\n            if solsta == mosek.solsta.optimal:\n                print(\"Objective: %s\" % xx_ub[3*nef])\n                #print(\"Optimal solution: %s\" % dual(xx))\n                # Get dual variables for the linear constraints\n                \n              \n            elif solsta == mosek.solsta.dual_infeas_cer:\n                print(\"Primal or dual infeasibility.\\n\")\n            elif solsta == mosek.solsta.prim_infeas_cer:\n                print(\"Primal or dual infeasibility.\\n\")\n            elif mosek.solsta.unknown:\n                print(\"Unknown solution status\")\n            else:\n                print(\"Other solution status\")\n          \n        \n    #non associative calc\n    tol =1\n    itr = 0\n    \n    alpha= data[\"alpha\"]\n    beta= data[\"beta\"]\n    #tolerance=0.001\n    tolerance= data[\"tolerance\"]\n    \n\n \n    if data[\"ub_non_ass_calc\"]:\n\n        \n        # Construct the path to the log file in the same directory as the script\n        log_path = os.path.join(rhino_file_dir, 'ub_non_ass_solutions.log')\n\n        with open(log_path, \"w\") as f:\n            f.write(\"\")  # Clear the file\n\n        \n\n        while tol >tolerance: \n    \n            # Check if the solver found an optimal solution\n            if solsta == mosek.solsta.optimal:\n          \n                if itr>1:\n                    normalvalues_old = normalvalues\n                else:\n                    normalvalues_old = np.zeros((int(nef) - len(supports_nodes),1))\n                    normal = []\n                    for element in range(0,len(xx_ub)-2,3):\n                        if int(element /3 + 1) not in supports_nodes:\n                            normal += [xx_ub[element+2]]\n\n                    normal = np.array(normal).reshape(-1,1)\n                    # Apply KMeans with 2 clusters to normal loads values\n                    kmeans_normal = KMeans(n_clusters=2, random_state=0).fit(normal)\n\n                    # Split values based on the KMeans labels\n                    cluster_1 = [normal[i] for i in range(len(normal)) if kmeans_normal.labels_[i] == 0]\n                    min_normal = min(cluster_1)\n\n                statsolver_old = xx_ub[3*nef]   \n                \n                normalvalues = np.empty((0,1))\n               \n                \n                for element in range(0,len(xx_ub)-2,3):\n                    if int(element /3 + 1) not in supports_nodes:\n                        normalvalues = np.append(normalvalues,xx_ub[element+2]) \n            \n            coh_vect_new = [0,0,0]*len(coh_vect_ub)\n            friction_coef_new = [1,1,1]*len(list_coef_ub)\n       \n\n            \n            for element in range(int(nef - len(supports_nodes))):\n\n                if abs(normalvalues[element]) > 1e-5:\n                    coh_corr = normalvalues[element]\n                else:\n                    coh_corr = min_normal\n                 \n\n\n                if itr >1:\n                    coh_vect_new[3*element] =  0.00001*coh_corr +  coh_vect_ub[3*element] + (1+alpha)*abs(list_coef_ub[3*element])*(beta*normalvalues[element] + (1-beta)*normalvalues_old[element]) \n                    friction_coef_new[3*element] = -math.tan(math.radians(data[\"friction_ang\"])*alpha)\n                    \n                else:\n        \n                    coh_vect_new[3*element] = 0.00001*coh_corr + coh_vect_ub[3*element] + (1+alpha)*abs(list_coef_ub[3*element])*(normalvalues[element] )\n                    friction_coef_new[3*element] = -math.tan(math.radians(data[\"friction_ang\"])*alpha)\n                    \n            #-list_coef[3*element]*alpha\n            statsol_old = xx_ub\n\n           \n    \n            #mosek\n            with mosek.Task() as task:\n                # Attach a printer to the task\n                task.set_Stream(mosek.streamtype.log, streamprinter)\n        \n                \n             # Append 'numcon' empty constraints.\n                # The constraints will initially have no bounds.\n                task.appendcons(numcon_ub)\n        \n                #Append 'numvar' variables.\n                # The variables will initially be fixed at zero (x=0).\n                task.appendvars(numvar_ub)\n        \n                for j in range(numvar_ub):\n                    # Set the linear term c_j in the objective.\n                    task.putcj(j, z_ub[j])\n                    # Set the bounds on variable j\n                    # blx[j] <= x_j <= bux[j]\n                    task.putvarbound(j, bkx_ub[j], blx_ub[j], bux_ub[j])\n                \n                \n                for j in range(len(aval_mos_ub)):\n                    \n                   \n                    # Input column j of A\n                    task.putacol(j,      asub_mos_ub[j],aval_mos_ub[j])            # Non-zero Values of column j.\n                \n                \n        \n            # Input the affine conic constraints\n\n                task.appendafes(3*nef)\n                \n                list_con_ub = []\n                \n\n                for ind in range(nef):\n                    if (ind+1) not in supports_nodes:\n                    \n                        list_con_ub += [3*ind + 2 , 3*ind,3*ind + 1]\n                        #list_coef += [-math.tan(math.radians(friction_ang)),1.0,1.0]\n                    \n                task.putafefentrylist(range(3*nef - len(supports_nodes) ),                      # Rows\n                                    list_con_ub ,            # Columns \n                                    friction_coef_new  )          #coefficients\n        \n                # Quadratic cone (x(3),x(0),x(1)) \\in QUAD_3 \n       \n\n           \n                for ind in range(nef - len(supports_nodes) ):\n                    \n                    #if ind not in all_supports_ind:\n                    if True:\n                        quadcone  = task.appendquadraticconedomain(3)\n                        task.appendacc(quadcone, [3*ind, 3*ind +1, 3*ind + 2],   [coh_vect_new[3*ind], coh_vect_new[3*ind +1] , coh_vect_new[3*ind +2] ] )                    # None if there is no b for conic \n           \n                \n                for i in range(numcon_ub):\n                    task.putconbound(i, bkc_ub[i], blc_ub[i], buc_ub[i])\n        \n        \n            # Input the objective sense (minimize/maximize)\n                task.putobjsense(mosek.objsense.minimize)\n\n                #task.putintparam(mosek.iparam.log, 0)\n\n                # Attach the stream printer to the task for logging\n                task.set_Stream(mosek.streamtype.log, lambda text: stream_printer(text, log_path))\n                # Optimize the task\n                task.optimize()\n                with open(log_path, \"a\") as f:\n                    f.write(f\"min normal: {min(normalvalues)}\\n\")\n                    f.write(f\"min_normal: {min_normal}\\n\")\n\n                    f.flush()\n                #task.writedata(\"cqo1.ptf\")\n                # Print a summary containing information\n                # about the solution for debugging purposes\n                #task.solutionsummary(mosek.streamtype.msg)\n                prosta = task.getprosta(mosek.soltype.itr)\n                solsta = task.getsolsta(mosek.soltype.itr)\n        \n                # Output a solution\n                xx_ub = task.getxx(mosek.soltype.itr)\n                \n                ub = [task.getsuc(mosek.soltype.itr)[ind] - task.getslc(mosek.soltype.itr)[ind]  for ind in range(6*nb) ] # get dual variables for equilibrium but why upper ? not slb\n            \n                \n                #skc, y = task.getsolution(mosek.soltype.bas)\n                if solsta == mosek.solsta.optimal:\n                    print(\"Objective: %s\" % xx_ub[3*nef])\n                    #print(\"Optimal solution: %s\" % dual(xx))\n                    # Get dual variables for the linear constraints\n                    \n                  \n                elif solsta == mosek.solsta.dual_infeas_cer:\n                    print(\"Primal or dual infeasibility.\\n\")\n                elif solsta == mosek.solsta.prim_infeas_cer:\n                    print(\"Primal or dual infeasibility.\\n\")\n                elif mosek.solsta.unknown:\n                    print(\"Unknown solution status\")\n                else:\n                    print(\"Other solution status\")\n            #end mosek\n    \n                if solsta == mosek.solsta.optimal:\n     \n                    if itr >1:\n                    \n                        tol = abs(xx_ub[3*nef] - statsolver_old)/abs(xx_ub[3*nef] )\n                        print(\"tolerance\", tol)\n                else:\n                    statsol = statsol_old\n                    \n                if alpha <= 0.0001:\n                    alpha = 0.0001\n                else:\n                    alpha = alpha*0.5\n        \n                itr = itr+1\n                # Clear or reset the task\n                \n                del task  # Delete the task object\n                    \n        stat_parav(data, \"ub_non_ass\",xx_ub[0:3*nef + 1])\n\n        kin_parav(data, \"ub_non_ass\",ub)\n\n\n\n    if data[\"lb_non_ass_calc\"]:\n\n        tol =1\n        itr = 0\n        \n        alpha= data[\"alpha\"]\n        beta= data[\"beta\"]\n        #tolerance=0.001\n        tolerance= data[\"tolerance\"]\n\n        \n        # Construct the path to the log file in the same directory as the script\n        log_path = os.path.join(rhino_file_dir, 'lb_non_ass_solutions.log')\n\n        with open(log_path, \"w\") as f:\n            f.write(\"\")  # Clear the file\n\n        \n\n        while tol >tolerance: \n    \n            # Check if the solver found an optimal solution\n            if solsta == mosek.solsta.optimal:\n          \n                if itr>1:\n                    normalvalues_old = normalvalues\n                else:\n                    normalvalues_old = np.zeros((int(nef) - len(supports_nodes),1))\n                    normal = []\n                    for element in range(0,len(xx_lb)-2,3):\n                        if int(element /3 + 1) not in supports_nodes:\n                            normal += [xx_lb[element+2]]\n\n                    normal = np.array(normal).reshape(-1,1)\n                    # Apply KMeans with 2 clusters to normal loads values\n                    kmeans_normal = KMeans(n_clusters=2, random_state=0).fit(normal)\n\n                    # Split values based on the KMeans labels\n                    cluster_1 = [normal[i] for i in range(len(normal)) if kmeans_normal.labels_[i] == 0]\n                    min_normal = min(cluster_1)\n\n                statsolver_old = xx_lb[3*nef]   \n                \n                normalvalues = np.empty((0,1))\n               \n                \n                for element in range(0,len(xx_lb)-2,3):\n                    if int(element /3 + 1) not in supports_nodes:\n                        normalvalues = np.append(normalvalues,xx_lb[element+2]) \n            \n            coh_vect_new = [0,0,0]*len(coh_vect_lb)\n            friction_coef_new = [1,1,1]*len(list_coef_lb)\n       \n\n            \n            for element in range(int(nef - len(supports_nodes))):\n\n                if abs(normalvalues[element]) > 1e-5:\n                    coh_corr = normalvalues[element]\n                else:\n                    coh_corr = min(normalvalues)\n                 \n\n\n                if itr >1:\n                    coh_vect_new[3*element] =  0.000001*coh_corr +  coh_vect_lb[3*element] + (1+alpha)*abs(list_coef_lb[3*element])*(beta*normalvalues[element] + (1-beta)*normalvalues_old[element]) \n                    friction_coef_new[3*element] = -math.tan(math.radians(data[\"friction_ang\"])*alpha)\n                    \n                else:\n        \n                    coh_vect_new[3*element] = 0.000001*coh_corr + coh_vect_lb[3*element] + (1+alpha)*abs(list_coef_lb[3*element])*(normalvalues[element] )\n                    friction_coef_new[3*element] = -math.tan(math.radians(data[\"friction_ang\"])*alpha)\n                    \n            #-list_coef[3*element]*alpha\n            statsol_old = xx_lb\n\n           \n    \n            #mosek\n            with mosek.Task() as task:\n                # Attach a printer to the task\n                task.set_Stream(mosek.streamtype.log, streamprinter)\n    \n             # Append 'numcon' empty constraints.\n                # The constraints will initially have no bounds.\n                task.appendcons(numcon_lb)\n        \n                #Append 'numvar' variables.\n                # The variables will initially be fixed at zero (x=0).\n                task.appendvars(numvar_lb)\n        \n                for j in range(numvar_lb):\n                    # Set the linear term c_j in the objective.\n                    task.putcj(j, z_lb[j])\n                    # Set the bounds on variable j\n                    # blx[j] <= x_j <= bux[j]\n                    task.putvarbound(j, bkx_lb[j], blx_lb[j], bux_lb[j])\n                \n                \n                for j in range(len(aval_mos_lb)):\n                    \n                   \n                    # Input column j of A\n                    task.putacol(j,      asub_mos_lb[j],aval_mos_lb[j])            # Non-zero Values of column j.\n                \n            # Input the affine conic constraints\n\n                task.appendafes(3*nef)\n                \n                list_con_lb = []\n                \n\n                for ind in range(nef):\n                    if (ind+1) not in supports_nodes:\n                    \n                        list_con_lb += [3*ind + 2 , 3*ind,3*ind + 1]\n                      \n                    \n                task.putafefentrylist(range(3*nef - len(supports_nodes) ),                      # Rows\n                                    list_con_lb ,            # Columns \n                                    friction_coef_new  )          #coefficients\n        \n                # Quadratic cone (x(3),x(0),x(1)) \\in QUAD_3 \n       \n\n           \n                for ind in range(nef - len(supports_nodes) ):\n                    \n                    #if ind not in all_supports_ind:\n                    if True:\n                        quadcone  = task.appendquadraticconedomain(3)\n                        task.appendacc(quadcone, [3*ind, 3*ind +1, 3*ind + 2],   [coh_vect_new[3*ind], coh_vect_new[3*ind +1] , coh_vect_new[3*ind +2] ] )                    # None if there is no b for conic \n           \n               \n                for i in range(numcon_lb):\n                    task.putconbound(i, bkc_lb[i], blc_lb[i], buc_lb[i])\n        \n        \n            # Input the objective sense (minimize/maximize)\n                task.putobjsense(mosek.objsense.minimize)\n\n                #task.putintparam(mosek.iparam.log, 0)\n\n                # Attach the stream printer to the task for logging\n                task.set_Stream(mosek.streamtype.log, lambda text: stream_printer(text, log_path))\n                # Optimize the task\n                task.optimize()\n                with open(log_path, \"a\") as f:\n                    f.write(f\"min normal: {min(normalvalues)}\\n\")\n                    f.write(f\"min_normal: {min_normal}\\n\")\n\n                    f.flush()\n               \n                prosta = task.getprosta(mosek.soltype.itr)\n                solsta = task.getsolsta(mosek.soltype.itr)\n        \n                # Output a solution\n                xx_lb = task.getxx(mosek.soltype.itr)\n                \n                ub = [task.getsuc(mosek.soltype.itr)[ind] - task.getslc(mosek.soltype.itr)[ind]  for ind in range(6*nb) ] # get dual variables for equilibrium but why upper ? not slb\n            \n                \n                #skc, y = task.getsolution(mosek.soltype.bas)\n                if solsta == mosek.solsta.optimal:\n                    print(\"Objective: %s\" % xx_lb[3*nef])\n                    #print(\"Optimal solution: %s\" % dual(xx))\n                    # Get dual variables for the linear constraints\n                    \n                  \n                elif solsta == mosek.solsta.dual_infeas_cer:\n                    print(\"Primal or dual infeasibility.\\n\")\n                elif solsta == mosek.solsta.prim_infeas_cer:\n                    print(\"Primal or dual infeasibility.\\n\")\n                elif mosek.solsta.unknown:\n                    print(\"Unknown solution status\")\n                else:\n                    print(\"Other solution status\")\n            #end mosek\n    \n            if solsta == mosek.solsta.optimal:\n    \n                if itr >1:\n                   \n                    tol = abs(xx_lb[3*nef] - statsolver_old)/abs(xx_lb[3*nef] )\n                    print(\"tolerance\", tol)\n            else:\n                statsol = statsol_old\n                \n            if alpha <= 0.0001:\n                alpha = 0.0001\n            else:\n                alpha = alpha*0.5\n    \n            itr = itr+1\n            # Clear or reset the task\n            \n            del task  # Delete the task object\n                \n        stat_parav(data, \"lb_non_ass\",xx_lb[0:3*nef + 1])\n\n        kin_parav(data, \"lb_non_ass\",ub)\n    \n\n    # Construct the path to the data.json file\n    json_file_path = os.path.join(data[\"script_dir\"] , 'calc_time.json')\n    \n\n    with open(json_file_path, 'w') as file:\n        json.dump(data[\"calc_time\"], file, indent=4)\n\n\n    return ub\n\n\ndef main():\n\n    # Get the directory of the current script\n    script_dir = os.path.dirname(__file__)\n\n\n    # Get the path of the currently open Rhino file\n    rhino_file_path = rs.DocumentPath()\n  \n    # Construct the path to the data.json file\n    json_file_path = os.path.join(rhino_file_path, 'data.json')\n\n    # Load the data from the JSON file\n    with open(json_file_path, 'r') as file:\n        data = json.load(file)\n\n    data[\"script_dir\"] = script_dir\n    data[\"rhino_file_path\"] = rhino_file_path\n\n    #call main function\n    #main(data)\n\n    # Get the current date and time from the URL\n    now = urlopen('http://just-the-time.appspot.com/')\n    now_str = now.read().strip().decode('utf-8')\n    try:\n    # Try setting to 'en_US' for UNIX/Linux systems or 'English_United States' for Windows.\n        locale.setlocale(locale.LC_ALL, 'en_US')  # Try 'en_US.UTF-8' if 'en_US' doesn't work\n    except locale.Error:\n        print(\"Locale 'en-US' could not be set.\")\n\n    exp_date = datetime( year = 2024, month = 8 , day = 31   )\n\n    now_datetime = datetime.strptime(now_str, '%Y-%m-%d %H:%M:%S')\n\n    # Compare the two dates\n    if exp_date > now_datetime:\n        #print(\"You can still use the script\")\n    \n    \n        ## read rhino file\n        data = read_data_from_rhino(data)\n\n        ## call C++ function to generate mesh and construct problem\n        data = generate_mesh_and_construct_matrices(data)\n\n        ## solve different approaches and generate paraview file\n\n        ub = solve_problem_with_solvers(data)\n\n        #\n        #block_disp_plot(data[\"blocks_centroid\"],data[\"blocks\"],data[\"faces\"],data[\"points\"],ub)\n\n\n\n#call main function\nmain()\n\n\n\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}