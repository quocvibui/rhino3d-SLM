{
  "source_url": "https://github.com/adapt-ai-team/ADAPT_AI/blob/5de8b42c4f4d4ad35cbd8e79588fc6e869398bc4/spz_analysis2/working_solar_radiation.py",
  "repo": "adapt-ai-team/ADAPT_AI",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "spz_analysis2/working_solar_radiation.py",
  "instruction": "Working solar radiation",
  "code": "import os\nimport json\nimport numpy as np\nimport rhino3dm\nimport matplotlib.pyplot as plt\nfrom ladybug.epw import EPW\nfrom ladybug.sunpath import Sunpath\nfrom pygltflib import GLTF2, Buffer, Accessor, BufferView, Mesh, Asset, Primitive, Material, Scene, Node\n\n# üìÇ Define file paths\nPIPELINE_OUTPUT_DIR = r\"D:\\spz_pipeline\\pipeline_outputs\"\nEPW_FILE_PATH = os.path.join(PIPELINE_OUTPUT_DIR, \"newyork.epw\")\nRESULTS_FILE = os.path.join(PIPELINE_OUTPUT_DIR, \"solar_results_example_image.json\")\nGLB_FILE_PATH = os.path.join(PIPELINE_OUTPUT_DIR, \"example_image.glb\")  # Ensure this is correct\nSOLAR_OUTPUT_GLB = os.path.join(PIPELINE_OUTPUT_DIR, \"solar_radiation_example_image.glb\")\n\n# ‚úÖ Load EPW weather data\ndef load_epw(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"‚ùå EPW file not found: {file_path}\")\n    return EPW(file_path)\n\n# ‚òÄÔ∏è Generate sun vectors\ndef get_sun_vectors(epw):\n    sunpath = Sunpath.from_location(epw.location)\n    return [sunpath.calculate_sun(6, 21, h).sun_vector for h in range(8, 15, 1)]\n\n# üìÇ Extract surfaces from GLB file\ndef extract_surfaces_from_glb(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"‚ùå GLB file not found: {file_path}\")\n    \n    gltf = GLTF2().load_binary(file_path)\n    \n    if not gltf.meshes or len(gltf.meshes) == 0:\n        raise ValueError(\"‚ùå No meshes found in the GLB file.\")\n    \n    binary_blob = gltf.binary_blob()\n    surfaces = []\n    for mesh in gltf.meshes:\n        for primitive in mesh.primitives:\n            if not hasattr(primitive.attributes, \"POSITION\"):\n                continue\n            \n            pos_accessor = gltf.accessors[primitive.attributes.POSITION]\n            buffer_view = gltf.bufferViews[pos_accessor.bufferView]\n            vertex_start = buffer_view.byteOffset\n            vertex_end = vertex_start + buffer_view.byteLength\n            vertices = np.frombuffer(binary_blob[vertex_start:vertex_end], dtype=np.float32).reshape(-1, 3)\n            \n            faces = []\n            if primitive.indices is not None:\n                index_accessor = gltf.accessors[primitive.indices]\n                index_buffer_view = gltf.bufferViews[index_accessor.bufferView]\n                index_start = index_buffer_view.byteOffset\n                index_end = index_start + index_buffer_view.byteLength\n                faces = np.frombuffer(binary_blob[index_start:index_end], dtype=np.uint32).reshape(-1, 3)\n            \n            rhino_mesh = rhino3dm.Mesh()\n            for v in vertices:\n                rhino_mesh.Vertices.Add(v[0], v[1], v[2])\n            for f in faces:\n                if len(f) == 3:\n                    rhino_mesh.Faces.AddFace(int(f[0]), int(f[1]), int(f[2]))\n            \n            surfaces.append(rhino_mesh)\n    \n    if not surfaces:\n        raise ValueError(\"‚ùå No valid geometry extracted from the GLB file.\")\n    \n    return surfaces\n\n# üîÜ Compute Solar Radiation\ndef compute_solar_radiation(epw, surfaces):\n    sun_vectors = get_sun_vectors(epw)\n    all_radiation_values = []\n    for surface in surfaces:\n        normals = [surface.Normals[j] for j in range(len(surface.Vertices))] if len(surface.Normals) > 0 else [rhino3dm.Vector3d(0, 0, 1)]\n        solar_exposure = [\n            max(0, np.dot([normals[0].X, normals[0].Y, normals[0].Z], [sun_vec.x, sun_vec.y, sun_vec.z]))\n            for sun_vec in sun_vectors\n        ]\n        direct_radiation = [epw.direct_normal_radiation[hour % 24] for hour in range(6, 18)]\n        max_radiation = max(direct_radiation) if max(direct_radiation) > 0 else 1\n        normalized_exposure = [(solar / max_radiation) * rad for solar, rad in zip(solar_exposure, direct_radiation)]\n        all_radiation_values.append(normalized_exposure)\n    \n    min_value = min(map(min, all_radiation_values))\n    max_value = max(map(max, all_radiation_values))\n    normalized_radiation_values = [[(value - min_value) / (max_value - min_value) if max_value != min_value else 1.0 for value in radiation] for radiation in all_radiation_values]\n    \n    with open(RESULTS_FILE, \"w\") as f:\n        json.dump(normalized_radiation_values, f, indent=4)\n    \n    save_mesh_to_glb(surfaces, normalized_radiation_values, SOLAR_OUTPUT_GLB)\n    print(f\"‚úÖ solar_radiation.glb saved to {SOLAR_OUTPUT_GLB}\")\n\n# üé≠ Save a Mesh with Solar Radiation Data to GLB\ndef save_mesh_to_glb(meshes, radiation_values, filename):\n    gltf = GLTF2(asset=Asset(version=\"2.0\"))\n    all_vertices, all_faces = [], []\n    vertex_offset = 0\n    for mesh in meshes:\n        vertices = np.array([[v.X, v.Y, v.Z] for v in mesh.Vertices], dtype=np.float32)\n        faces = np.array([[f[0], f[1], f[2]] for f in mesh.Faces], dtype=np.uint32)\n        all_vertices.append(vertices)\n        all_faces.append(faces + vertex_offset)\n        vertex_offset += len(vertices)\n    \n    final_vertices = np.vstack(all_vertices)\n    final_faces = np.vstack(all_faces)\n    vertex_buffer = Buffer(uri=None, byteLength=final_vertices.nbytes)\n    face_buffer = Buffer(uri=None, byteLength=final_faces.nbytes)\n    gltf.buffers.extend([vertex_buffer, face_buffer])\n    buffer_view_vertices = BufferView(buffer=0, byteOffset=0, byteLength=final_vertices.nbytes, target=34962)\n    buffer_view_faces = BufferView(buffer=1, byteOffset=0, byteLength=final_faces.nbytes, target=34963)\n    gltf.bufferViews.extend([buffer_view_vertices, buffer_view_faces])\n    accessor_vertices = Accessor(bufferView=0, byteOffset=0, componentType=5126, count=len(final_vertices), type=\"VEC3\")\n    accessor_faces = Accessor(bufferView=1, byteOffset=0, componentType=5125, count=len(final_faces) * 3, type=\"SCALAR\")\n    gltf.accessors.extend([accessor_vertices, accessor_faces])\n    primitive = Primitive(attributes={\"POSITION\": 0}, indices=1)\n    mesh = Mesh(primitives=[primitive])\n    gltf.meshes.append(mesh)\n    node = Node(mesh=0)\n    gltf.nodes.append(node)\n    scene = Scene(nodes=[0])\n    gltf.scenes.append(scene)\n    gltf.scene = 0\n    gltf.set_binary_blob(final_vertices.tobytes() + final_faces.tobytes())\n    gltf.save_binary(filename)\n    print(f\"‚úÖ Successfully saved {filename} as a proper GLB file.\")\n\n# üöÄ Run Analysis\nif __name__ == \"__main__\":\n    try:\n        epw_data = load_epw(EPW_FILE_PATH)\n        surfaces = extract_surfaces_from_glb(GLB_FILE_PATH)\n        compute_solar_radiation(epw_data, surfaces)\n    except Exception as e:\n        print(f\"‚ùå Error: {e}\")\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}