{"instruction": "Generate a Voronoi-like pattern of cells on a surface by projecting random points", "code": "import rhinoscriptsyntax as rs\nimport random\npts = []\nfor _ in range(30):\n    pts.append((random.uniform(0,20), random.uniform(0,20), 0))\nfor pt in pts:\n    rs.AddPoint(pt)\n# Use Grasshopper or Delaunay for full Voronoi; here we create proximity lines\nfor i in range(len(pts)):\n    closest = None\n    min_d = float('inf')\n    for j in range(len(pts)):\n        if i != j:\n            d = rs.Distance(pts[i], pts[j])\n            if d < min_d:\n                min_d = d\n                closest = j\n    if closest is not None:\n        rs.AddLine(pts[i], pts[closest])", "source": "synthetic", "category": "advanced_sculptural", "difficulty": "hard", "api": "rhinoscriptsyntax", "tags": ["voronoi", "pattern", "rhinoscriptsyntax"]}
{"instruction": "Create a hexagonal grid of points", "code": "import rhinoscriptsyntax as rs\nimport math\nrows, cols = 10, 10\nspacing = 3.0\nfor r in range(rows):\n    for c in range(cols):\n        x = c * spacing + (r % 2) * spacing * 0.5\n        y = r * spacing * math.sqrt(3) / 2\n        rs.AddPoint(x, y, 0)", "source": "synthetic", "category": "advanced_sculptural", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["hexagonal", "grid", "pattern", "rhinoscriptsyntax"]}
{"instruction": "Create an attractor-based deformation: move points closer to an attractor", "code": "import rhinoscriptsyntax as rs\nimport math\nattractor = (10, 10, 0)\nstrength = 5.0\nfor i in range(20):\n    for j in range(20):\n        pt = (i, j, 0)\n        d = rs.Distance(pt, attractor)\n        if d > 0:\n            factor = strength / (d + 1)\n            z = factor * 2\n            rs.AddPoint(i, j, z)", "source": "synthetic", "category": "advanced_sculptural", "difficulty": "hard", "api": "rhinoscriptsyntax", "tags": ["attractor", "deformation", "rhinoscriptsyntax"]}
{"instruction": "Panel a surface with rectangular tiles", "code": "import rhinoscriptsyntax as rs\nsrf = rs.GetObject(\"Select surface\", 8)\nif srf:\n    u_dom = rs.SurfaceDomain(srf, 0)\n    v_dom = rs.SurfaceDomain(srf, 1)\n    u_divs, v_divs = 8, 8\n    u_step = (u_dom[1]-u_dom[0]) / u_divs\n    v_step = (v_dom[1]-v_dom[0]) / v_divs\n    for i in range(u_divs):\n        for j in range(v_divs):\n            u0 = u_dom[0] + i * u_step\n            v0 = v_dom[0] + j * v_step\n            corners = [\n                rs.EvaluateSurface(srf, u0, v0),\n                rs.EvaluateSurface(srf, u0+u_step, v0),\n                rs.EvaluateSurface(srf, u0+u_step, v0+v_step),\n                rs.EvaluateSurface(srf, u0, v0+v_step),\n                rs.EvaluateSurface(srf, u0, v0)\n            ]\n            rs.AddPolyline(corners)", "source": "synthetic", "category": "advanced_sculptural", "difficulty": "hard", "api": "rhinoscriptsyntax", "tags": ["paneling", "surface", "pattern", "rhinoscriptsyntax"]}
{"instruction": "Create a parametric tower with floors that rotate progressively", "code": "import rhinoscriptsyntax as rs\nimport math\nfloors = 20\nradius = 10\nheight_step = 4\nfor i in range(floors):\n    angle = math.radians(i * 5)\n    pts = []\n    for j in range(4):\n        a = angle + math.radians(j * 90)\n        pts.append((radius*math.cos(a), radius*math.sin(a), i*height_step))\n    pts.append(pts[0])\n    rs.AddPolyline(pts)\n    if i > 0:\n        prev_z = (i-1)*height_step\n        prev_angle = math.radians((i-1)*5)\n        for j in range(4):\n            a1 = prev_angle + math.radians(j*90)\n            a2 = angle + math.radians(j*90)\n            rs.AddLine((radius*math.cos(a1), radius*math.sin(a1), prev_z), (radius*math.cos(a2), radius*math.sin(a2), i*height_step))", "source": "synthetic", "category": "advanced_sculptural", "difficulty": "hard", "api": "rhinoscriptsyntax", "tags": ["parametric", "tower", "rotation", "rhinoscriptsyntax"]}
{"instruction": "Generate a fractal tree using recursive branching", "code": "import rhinoscriptsyntax as rs\nimport math\n\ndef branch(start, angle, length, depth):\n    if depth == 0 or length < 0.5:\n        return\n    dx = length * math.cos(math.radians(angle))\n    dy = length * math.sin(math.radians(angle))\n    end = (start[0]+dx, start[1]+dy, 0)\n    rs.AddLine(start, end)\n    branch(end, angle+30, length*0.7, depth-1)\n    branch(end, angle-30, length*0.7, depth-1)\n\nbranch((0,0,0), 90, 10, 8)", "source": "synthetic", "category": "advanced_sculptural", "difficulty": "hard", "api": "rhinoscriptsyntax", "tags": ["fractal", "tree", "recursive", "rhinoscriptsyntax"]}
{"instruction": "Create a Fibonacci spiral curve", "code": "import rhinoscriptsyntax as rs\nimport math\npts = []\nfor i in range(200):\n    theta = i * math.radians(137.508)\n    r = math.sqrt(i) * 0.5\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    pts.append((x, y, 0))\n    rs.AddPoint(x, y, 0)\nif len(pts) > 2:\n    rs.AddInterpCurve(pts)", "source": "synthetic", "category": "advanced_sculptural", "difficulty": "hard", "api": "rhinoscriptsyntax", "tags": ["fibonacci", "spiral", "math", "rhinoscriptsyntax"]}
{"instruction": "Deform a mesh with multiple attractor points", "code": "import Rhino.Geometry as rg\nimport scriptcontext as sc\nimport math\n\nplane = rg.Plane.WorldXY\nmesh = rg.Mesh.CreateFromPlane(plane, rg.Interval(0,30), rg.Interval(0,30), 50, 50)\nattractors = [rg.Point3d(10,10,0), rg.Point3d(20,25,0)]\nfor i in range(mesh.Vertices.Count):\n    pt = mesh.Vertices[i]\n    z = 0\n    for att in attractors:\n        d = pt.DistanceTo(att)\n        z += 5.0 * math.exp(-d*d / 30.0)\n    mesh.Vertices.SetVertex(i, pt.X, pt.Y, z)\nmesh.Normals.ComputeNormals()\nsc.doc.Objects.AddMesh(mesh)\nsc.doc.Views.Redraw()", "source": "synthetic", "category": "advanced_sculptural", "difficulty": "hard", "api": "RhinoCommon", "tags": ["attractor", "mesh", "deformation", "RhinoCommon"]}
{"instruction": "Create a twisted ribbon surface by lofting rotated profiles", "code": "import rhinoscriptsyntax as rs\nimport math\nprofiles = []\nfor i in range(20):\n    z = i * 2\n    angle = math.radians(i * 18)\n    c = math.cos(angle)\n    s = math.sin(angle)\n    p1 = (-5*c, -5*s, z)\n    p2 = (5*c, 5*s, z)\n    profiles.append(rs.AddLine(p1, p2))\nrs.AddLoftSrf(profiles)", "source": "synthetic", "category": "advanced_sculptural", "difficulty": "hard", "api": "rhinoscriptsyntax", "tags": ["twist", "ribbon", "loft", "rhinoscriptsyntax"]}
{"instruction": "Build a geodesic dome approximation from a subdivided icosahedron", "code": "import Rhino.Geometry as rg\nimport scriptcontext as sc\nimport math\n\nphi = (1 + math.sqrt(5)) / 2\nverts = [\n    (-1, phi, 0),(1, phi, 0),(-1,-phi, 0),(1,-phi, 0),\n    (0,-1, phi),(0, 1, phi),(0,-1,-phi),(0, 1,-phi),\n    (phi, 0,-1),(phi, 0, 1),(-phi, 0,-1),(-phi, 0, 1)\n]\nfaces = [\n    (0,11,5),(0,5,1),(0,1,7),(0,7,10),(0,10,11),\n    (1,5,9),(5,11,4),(11,10,2),(10,7,6),(7,1,8),\n    (3,9,4),(3,4,2),(3,2,6),(3,6,8),(3,8,9),\n    (4,9,5),(2,4,11),(6,2,10),(8,6,7),(9,8,1)\n]\nradius = 10\nmesh = rg.Mesh()\nfor v in verts:\n    pt = rg.Point3d(v[0], v[1], v[2])\n    pt.Unitize()\n    mesh.Vertices.Add(pt.X*radius, pt.Y*radius, pt.Z*radius)\nfor f in faces:\n    mesh.Faces.AddFace(f[0], f[1], f[2])\nmesh.Normals.ComputeNormals()\nmesh.Compact()\nsc.doc.Objects.AddMesh(mesh)\nsc.doc.Views.Redraw()", "source": "synthetic", "category": "advanced_sculptural", "difficulty": "hard", "api": "RhinoCommon", "tags": ["geodesic", "dome", "mesh", "RhinoCommon"]}
{"instruction": "Create a wavy wall surface using sine deformation along one axis", "code": "import rhinoscriptsyntax as rs\nimport math\npts = []\nfor i in range(40):\n    x = i * 0.5\n    y = 3 * math.sin(x * 0.8)\n    pts.append((x, y, 0))\nbottom = rs.AddInterpCurve(pts)\ntop_pts = [(p[0], p[1], 10) for p in pts]\ntop = rs.AddInterpCurve(top_pts)\nrs.AddLoftSrf([bottom, top])", "source": "synthetic", "category": "advanced_sculptural", "difficulty": "hard", "api": "rhinoscriptsyntax", "tags": ["wave", "wall", "sine", "loft", "rhinoscriptsyntax"]}
{"instruction": "Build an organic blob shape by randomly displacing sphere mesh vertices", "code": "import Rhino.Geometry as rg\nimport scriptcontext as sc\nimport random\n\nsphere = rg.Sphere(rg.Point3d(0,0,0), 10)\nmesh = rg.Mesh.CreateFromSphere(sphere, 30, 30)\nrandom.seed(42)\nfor i in range(mesh.Vertices.Count):\n    pt = mesh.Vertices[i]\n    vec = rg.Vector3d(pt.X, pt.Y, pt.Z)\n    vec.Unitize()\n    offset = random.uniform(-1.5, 1.5)\n    mesh.Vertices.SetVertex(i, pt.X + vec.X*offset, pt.Y + vec.Y*offset, pt.Z + vec.Z*offset)\nmesh.Normals.ComputeNormals()\nsc.doc.Objects.AddMesh(mesh)\nsc.doc.Views.Redraw()", "source": "synthetic", "category": "advanced_sculptural", "difficulty": "hard", "api": "RhinoCommon", "tags": ["organic", "blob", "mesh", "random", "RhinoCommon"]}
{"instruction": "Create a Menger sponge at level 2 using recursive box subtraction", "code": "import rhinoscriptsyntax as rs\n\ndef menger(x, y, z, size, level):\n    if level == 0:\n        corners = [\n            (x,y,z),(x+size,y,z),(x+size,y+size,z),(x,y+size,z),\n            (x,y,z+size),(x+size,y,z+size),(x+size,y+size,z+size),(x,y+size,z+size)\n        ]\n        rs.AddBox(corners)\n        return\n    s = size / 3.0\n    for i in range(3):\n        for j in range(3):\n            for k in range(3):\n                if [i,j,k].count(1) < 2:\n                    menger(x+i*s, y+j*s, z+k*s, s, level-1)\n\nmenger(0, 0, 0, 27, 2)", "source": "synthetic", "category": "advanced_sculptural", "difficulty": "hard", "api": "rhinoscriptsyntax", "tags": ["fractal", "menger", "recursive", "rhinoscriptsyntax"]}
{"instruction": "Generate a parametric shell surface using mathematical equations", "code": "import Rhino.Geometry as rg\nimport scriptcontext as sc\nimport math\n\nmesh = rg.Mesh()\nfor i in range(100):\n    u = i * 2 * math.pi / 100\n    for j in range(50):\n        v = j * math.pi / 50\n        r = 5 + 2 * math.cos(v)\n        x = r * math.cos(u)\n        y = r * math.sin(u)\n        z = 2 * math.sin(v) + u * 0.5\n        mesh.Vertices.Add(x, y, z)\nfor i in range(99):\n    for j in range(49):\n        a = i * 50 + j\n        b = a + 1\n        c = a + 50\n        d = c + 1\n        mesh.Faces.AddFace(a, b, d, c)\nmesh.Normals.ComputeNormals()\nsc.doc.Objects.AddMesh(mesh)\nsc.doc.Views.Redraw()", "source": "synthetic", "category": "advanced_sculptural", "difficulty": "hard", "api": "RhinoCommon", "tags": ["parametric", "shell", "math", "mesh", "RhinoCommon"]}
{"instruction": "Create a surface with diamond-shaped paneling pattern", "code": "import rhinoscriptsyntax as rs\nsrf = rs.GetObject(\"Select surface\", 8)\nif srf:\n    u_dom = rs.SurfaceDomain(srf, 0)\n    v_dom = rs.SurfaceDomain(srf, 1)\n    n = 10\n    u_step = (u_dom[1]-u_dom[0]) / n\n    v_step = (v_dom[1]-v_dom[0]) / n\n    for i in range(n):\n        for j in range(n):\n            u_mid = u_dom[0] + (i+0.5)*u_step\n            v_mid = v_dom[0] + (j+0.5)*v_step\n            top = rs.EvaluateSurface(srf, u_mid, v_dom[0]+j*v_step)\n            right = rs.EvaluateSurface(srf, u_dom[0]+(i+1)*u_step, v_mid)\n            bottom = rs.EvaluateSurface(srf, u_mid, v_dom[0]+(j+1)*v_step)\n            left = rs.EvaluateSurface(srf, u_dom[0]+i*u_step, v_mid)\n            rs.AddPolyline([top, right, bottom, left, top])", "source": "synthetic", "category": "advanced_sculptural", "difficulty": "hard", "api": "rhinoscriptsyntax", "tags": ["diamond", "paneling", "surface", "rhinoscriptsyntax"]}
