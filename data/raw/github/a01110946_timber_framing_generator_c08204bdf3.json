{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/src/timber_framing_generator/framing_elements/studs.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "src/timber_framing_generator/framing_elements/studs.py",
  "instruction": "File: timber_framing_generator/framing_elements/studs.py",
  "code": "# File: timber_framing_generator/framing_elements/studs.py\n\nfrom typing import Dict, List, Any, Optional\nimport Rhino.Geometry as rg\nimport math\nfrom src.timber_framing_generator.config.framing import FRAMING_PARAMS, PROFILES, get_framing_param\nfrom src.timber_framing_generator.utils.safe_rhino import safe_closest_point, safe_get_length, safe_create_extrusion, safe_get_bounding_box\nfrom ..utils.logging_config import get_logger\n\n# Initialize logger for this module\nlogger = get_logger(__name__)\n\n\ndef calculate_stud_locations(\n    cell, stud_spacing=0.6, start_location=None, remove_first=False, remove_last=False\n):\n    \"\"\"\n    Calculates stud locations for a given wall cell (or segment) based on its base geometry.\n    This intermediate step takes a cell (which should include a base line or a segment)\n    and returns a list of points representing the locations for studs.\n\n    Keyword Args:\n        stud_spacing (float): Desired spacing between studs.\n        start_location: Optional starting point (rg.Point3d) or parameter on the base geometry\n                        where stud distribution should begin.\n        remove_first (bool): If True, skip the first stud (to avoid collision with a king stud).\n        remove_last (bool): If True, skip the last stud.\n\n    Returns:\n        list: A list of rg.Point3d objects representing stud locations.\n    \"\"\"\n    logger.debug(\"Calculating stud locations\")\n    logger.debug(f\"Parameters - stud_spacing: {stud_spacing}, remove_first: {remove_first}, remove_last: {remove_last}\")\n    \n    # Assume the cell contains a key \"base_line\" with a Rhino.Geometry.Curve representing the stud area.\n    base_line = cell.get(\"base_line\")\n    if not base_line or not isinstance(base_line, rg.Curve):\n        logger.error(\"Invalid base_line for stud placement\")\n        raise ValueError(\n            \"Cell must contain a valid 'base_line' (Rhino.Geometry.Curve) for stud placement.\"\n        )\n\n    # Determine the starting parameter. If start_location is given and is a point, get its parameter on the line.\n    if start_location and isinstance(start_location, rg.Point3d):\n        logger.debug(f\"Using start location point: ({start_location.X}, {start_location.Y}, {start_location.Z})\")\n        success, t0 = safe_closest_point(base_line, start_location)\n        if not success:\n            logger.warning(\"Failed to find closest point on base_line, using parameter 0.0\")\n            t0 = 0.0\n        else:\n            logger.debug(f\"Found parameter t0={t0} on base_line\")\n    else:\n        logger.debug(\"No start location provided, using parameter 0.0\")\n        t0 = 0.0\n\n    # Compute the total length of the base_line.\n    length = safe_get_length(base_line)\n    logger.debug(f\"Base line length: {length}\")\n    \n    # Determine number of studs (using stud_spacing)\n    num_intervals = int(length / stud_spacing)\n    logger.debug(f\"Calculated {num_intervals+1} studs at spacing {stud_spacing}\")\n    \n    # Create stud locations uniformly along the line.\n    stud_points = [\n        base_line.PointAt(t0 + (i / float(num_intervals)) * length)\n        for i in range(num_intervals + 1)\n    ]\n    logger.debug(f\"Generated {len(stud_points)} initial stud points\")\n\n    # Optionally remove the first and/or last stud.\n    if remove_first and stud_points:\n        logger.debug(\"Removing first stud\")\n        stud_points = stud_points[1:]\n    if remove_last and stud_points:\n        logger.debug(\"Removing last stud\")\n        stud_points = stud_points[:-1]\n\n    logger.debug(f\"Returning {len(stud_points)} stud locations\")\n    return stud_points\n\ndef generate_stud(profile=\"2x4\", stud_height=2.4, stud_thickness=None, stud_width=None):\n    \"\"\"\n    Generate a stud data structure with the specified profile or dimensions.\n    \n    Args:\n        profile (str): Standard lumber profile (e.g., \"2x4\")\n        stud_height (float): Height of the stud\n        stud_thickness (float, optional): Override thickness from profile\n        stud_width (float, optional): Override width from profile\n        \n    Returns:\n        dict: Dictionary containing stud information\n    \"\"\"\n    logger.debug(f\"Generating stud with profile: {profile}\")\n    \n    dimensions = PROFILES.get(profile, {})\n    thickness = stud_thickness or dimensions.get(\"thickness\", 0.04)\n    width = stud_width or dimensions.get(\"width\", 0.09)\n    \n    logger.debug(f\"Using dimensions - thickness: {thickness}, width: {width}, height: {stud_height}\")\n\n    if thickness is None or width is None:\n        logger.error(\"Missing dimensions for custom profile\")\n        raise ValueError(\"Explicit dimensions must be provided for custom profiles.\")\n\n    stud = {\n        \"type\": \"stud\",\n        \"profile\": profile,\n        \"thickness\": thickness,\n        \"width\": width,\n        \"height\": stud_height,\n        \"geometry\": \"placeholder_for_geometry\",\n    }\n    \n    logger.debug(\"Stud data structure created successfully\")\n    return stud\n\n\nclass StudGenerator:\n    \"\"\"\n    Generates standard wall studs within stud cells.\n\n    Studs are vertical framing members placed at regular intervals along the wall.\n    They run from the top face of the bottom plate to the bottom face of the top plate.\n    This class uses existing Stud Cell (SC) information from cell decomposition\n    to determine where studs should be placed with proper spacing.\n    \"\"\"\n\n    def __init__(\n        self,\n        wall_data: Dict[str, Any],\n        bottom_plate: Any,\n        top_plate: Any,\n        king_studs: List[rg.Brep] = None,\n    ):\n        \"\"\"\n        Initialize the stud generator with wall data and plate references.\n\n        Args:\n            wall_data: Dictionary containing wall information including:\n                - base_plane: Reference plane for wall coordinate system\n                - cells: List of cell dictionaries from decomposition\n            bottom_plate: The bottom plate object (for elevation reference)\n            top_plate: The top plate object (for elevation reference)\n            king_studs: Optional list of king stud geometries to avoid overlap\n        \"\"\"\n        logger.debug(\"Initializing StudGenerator\")\n        logger.debug(f\"Wall data: {wall_data}\")\n        \n        # Store the wall data for use throughout the generation process\n        self.wall_data = wall_data\n        self.bottom_plate = bottom_plate\n        self.top_plate = top_plate\n        self.king_studs = king_studs or []\n        \n        logger.debug(f\"Bottom plate: {bottom_plate}\")\n        logger.debug(f\"Top plate: {top_plate}\")\n        logger.debug(f\"King studs count: {len(self.king_studs)}\")\n\n        # Initialize storage for debug geometry\n        self.debug_geometry = {\"points\": [], \"planes\": [], \"profiles\": [], \"paths\": []}\n\n        # Extract and store king stud positions for reference\n        self.king_stud_positions = self._extract_king_stud_positions()\n        logger.debug(f\"Extracted {len(self.king_stud_positions)} king stud positions\")\n\n    def _extract_king_stud_positions(self) -> List[float]:\n        \"\"\"\n        Extract U-coordinates of king studs to avoid overlap.\n\n        Returns:\n            List of U-coordinates (along wall length) where king studs are positioned\n        \"\"\"\n        logger.debug(\"Extracting king stud positions\")\n        positions = []\n\n        if not self.king_studs:\n            logger.info(\"No king studs provided to avoid overlap\")\n            return positions\n\n        try:\n            base_plane = self.wall_data.get(\"base_plane\")\n            if base_plane is None:\n                logger.warning(\"No base plane available for king stud position extraction\")\n                return positions\n\n            # Process each king stud to extract its U-coordinate\n            for i, stud in enumerate(self.king_studs):\n                logger.debug(f\"Processing king stud {i+1}\")\n                # Get bounding box of king stud\n                bbox = safe_get_bounding_box(stud, True)\n                if not bbox.IsValid:\n                    logger.warning(f\"Invalid bounding box for king stud {i+1}\")\n                    continue\n\n                # Calculate center point of bounding box\n                center_x = (bbox.Min.X + bbox.Max.X) / 2\n                center_y = (bbox.Min.Y + bbox.Max.Y) / 2\n                center_point = rg.Point3d(center_x, center_y, bbox.Min.Z)\n                logger.debug(f\"King stud center point: ({center_point.X}, {center_point.Y}, {center_point.Z})\")\n\n                # Project onto wall base plane to get u-coordinate\n                u_coordinate = self._project_point_to_u_coordinate(\n                    center_point, base_plane\n                )\n                positions.append(u_coordinate)\n                logger.debug(f\"King stud {i+1} u-coordinate: {u_coordinate}\")\n\n            logger.debug(f\"Extracted {len(positions)} king stud positions: {positions}\")\n            return positions\n\n        except Exception as e:\n            logger.error(f\"Error extracting king stud positions: {str(e)}\")\n            import traceback\n            logger.error(traceback.format_exc())\n            return positions\n\n    def _project_point_to_u_coordinate(\n        self, point: rg.Point3d, base_plane: rg.Plane\n    ) -> float:\n        \"\"\"\n        Project a 3D point onto the wall's u-axis to get its u-coordinate.\n\n        Args:\n            point: The 3D point to project\n            base_plane: The wall's base plane\n\n        Returns:\n            The u-coordinate (distance along wall)\n        \"\"\"\n        logger.debug(f\"Projecting point ({point.X}, {point.Y}, {point.Z}) to u-coordinate\")\n        try:\n            # Vector from base plane origin to the point\n            vec = point - base_plane.Origin\n\n            # Project this vector onto the u-axis (XAxis)\n            # Use the dot product for projection\n            u = vec * base_plane.XAxis\n            logger.debug(f\"Calculated u-coordinate: {u}\")\n\n            return u\n\n        except Exception as e:\n            logger.error(f\"Error projecting point to u-coordinate: {str(e)}\")\n            return 0.0\n\n    def generate_studs(self) -> List[rg.Brep]:\n        \"\"\"\n        Generate standard wall studs based on stud cells.\n\n        This method processes all stud cells (SC) and generates studs with\n        proper spacing according to the configured stud spacing parameter.\n\n        Returns:\n            List of Brep geometries representing wall studs\n        \"\"\"\n        logger.debug(\"Generating standard wall studs\")\n        \n        try:\n            # Extract cell data from wall data\n            cells = self.wall_data.get(\"cells\", [])\n            base_plane = self.wall_data.get(\"base_plane\")\n\n            # Debug print\n            print(f\"\\n=== STUD GENERATOR: generate_studs() ===\")\n            print(f\"Cells from wall_data: {len(cells)}\")\n            for i, cell in enumerate(cells):\n                ct = cell.get(\"type\", \"NO_TYPE\")\n                ct2 = cell.get(\"cell_type\", \"NO_CELL_TYPE\")\n                print(f\"  Cell {i}: type='{ct}', cell_type='{ct2}'\")\n            print(f\"Base plane: {base_plane is not None}\")\n\n            if not cells:\n                logger.warning(\"No cells available for stud generation\")\n                print(\"WARNING: No cells available for stud generation\")\n                return []\n\n            if base_plane is None:\n                logger.warning(\"No base plane available for stud generation\")\n                print(\"WARNING: No base plane available for stud generation\")\n                return []\n\n            logger.debug(f\"Found {len(cells)} cells for stud processing\")\n            print(f\"Found {len(cells)} cells for stud processing\")\n\n            # Extract dimensions from framing parameters\n            # Uses wall_data config if available (for material-specific dimensions)\n            stud_width = get_framing_param(\"stud_width\", self.wall_data, 1.5 / 12)  # Default to 1.5 inches\n            stud_depth = get_framing_param(\"stud_depth\", self.wall_data, 3.5 / 12)  # Default to 3.5 inches\n            stud_spacing = get_framing_param(\"stud_spacing\", self.wall_data, 16 / 12)  # Default to 16 inches on center\n            logger.debug(f\"Stud dimensions - width: {stud_width}, depth: {stud_depth}, spacing: {stud_spacing}\")\n\n            # Calculate vertical extents for studs\n            bottom_elevation = self._get_bottom_elevation()\n            top_elevation = self._get_top_elevation()\n            \n            if bottom_elevation is None or top_elevation is None:\n                logger.warning(\"Could not determine stud extents from plates\")\n                return []\n                \n            logger.debug(f\"Stud vertical extents - bottom: {bottom_elevation}, top: {top_elevation}\")\n\n            # Process all cells marked as stud cells (SC)\n            all_studs = []\n            processed_cells = 0\n            \n            for cell in cells:\n                cell_type = cell.get(\"type\")\n\n                # Debug: show every cell being evaluated\n                print(f\"  Evaluating cell: type='{cell_type}', id='{cell.get('id', 'unknown')}'\")\n\n                # Skip cells that are not stud cells\n                if cell_type != \"SC\":\n                    print(f\"    -> Skipping (not SC)\")\n                    continue\n\n                processed_cells += 1\n                print(f\"    -> PROCESSING as SC cell #{processed_cells}\")\n                logger.debug(f\"Processing stud cell {processed_cells}\")\n                \n                try:\n                    # Get the horizontal region of the cell\n                    u_start = cell.get(\"u_start\")\n                    u_end = cell.get(\"u_end\")\n\n                    if u_start is None or u_end is None:\n                        logger.warning(\"Stud cell missing u-coordinate boundaries\")\n                        print(f\"    WARNING: Cell missing u_start or u_end\")\n                        continue\n\n                    logger.debug(f\"Stud cell boundaries - u_start: {u_start}, u_end: {u_end}\")\n                    print(f\"    Cell bounds: u_start={u_start}, u_end={u_end}, width={u_end - u_start}\")\n                    print(f\"    Stud spacing: {stud_spacing}\")\n                    print(f\"    Vertical range: bottom={bottom_elevation}, top={top_elevation}\")\n\n                    # Calculate stud positions within this cell\n                    stud_positions = self._calculate_stud_positions(u_start, u_end, stud_spacing)\n                    logger.debug(f\"Calculated {len(stud_positions)} stud positions in cell\")\n                    print(f\"    Calculated stud positions: {len(stud_positions)} - {stud_positions[:5] if stud_positions else 'NONE'}\")\n\n                    # Filter out positions too close to king studs\n                    original_count = len(stud_positions)\n                    stud_positions = self._filter_positions_by_king_studs(\n                        stud_positions, stud_width * 1.5\n                    )\n                    logger.debug(f\"{len(stud_positions)} positions remain after king stud filtering\")\n                    print(f\"    After king stud filter: {len(stud_positions)} (was {original_count})\")\n\n                    # Create studs at each position\n                    studs_created = 0\n                    studs_failed = 0\n                    for pos in stud_positions:\n                        stud = self._create_stud_geometry(\n                            base_plane,\n                            pos,\n                            bottom_elevation,\n                            top_elevation,\n                            stud_width,\n                            stud_depth,\n                        )\n                        if stud:\n                            all_studs.append(stud)\n                            studs_created += 1\n                            logger.debug(f\"Created stud at u={pos}\")\n                        else:\n                            studs_failed += 1\n                            print(f\"    FAILED to create stud at u={pos}\")\n                    print(f\"    Studs created: {studs_created}, failed: {studs_failed}\")\n\n                except Exception as e:\n                    logger.error(f\"Error processing stud cell: {str(e)}\")\n                    continue\n\n            logger.info(f\"Generated {len(all_studs)} standard wall studs\")\n            print(f\"=== STUD GENERATOR SUMMARY ===\")\n            print(f\"Processed {processed_cells} SC cells\")\n            print(f\"Generated {len(all_studs)} standard wall studs\")\n            print(f\"=== END STUD GENERATOR ===\\n\")\n            return all_studs\n\n        except Exception as e:\n            logger.error(f\"Error generating studs: {str(e)}\")\n            import traceback\n            logger.error(traceback.format_exc())\n            return []\n\n    def _get_bottom_elevation(self) -> Optional[float]:\n        \"\"\"\n        Get the elevation of the top of the bottom plate.\n\n        Returns:\n            The elevation value, or None if it cannot be determined\n        \"\"\"\n        logger.debug(\"Getting bottom elevation for studs\")\n        try:\n            # If we have a bottom plate reference, extract its top elevation\n            if self.bottom_plate is not None:\n                # Get bounding box of bottom plate\n                bbox = safe_get_bounding_box(self.bottom_plate, True)\n                if bbox.IsValid:\n                    elevation = bbox.Max.Z\n                    logger.debug(f\"Bottom elevation from plate bounding box: {elevation}\")\n                    return elevation\n\n            # Fallback to wall data if available\n            bottom_plate_thickness = get_framing_param(\"plate_thickness\", self.wall_data, 1.5 / 12)\n            wall_base_elevation = self.wall_data.get(\"wall_base_elevation\", 0.0)\n            elevation = wall_base_elevation + bottom_plate_thickness\n            logger.debug(f\"Bottom elevation from wall data: {elevation}\")\n            return elevation\n\n        except Exception as e:\n            logger.error(f\"Error determining bottom elevation: {str(e)}\")\n            return None\n\n    def _get_top_elevation(self) -> Optional[float]:\n        \"\"\"\n        Get the elevation of the bottom of the FIRST top plate (not cap plate).\n\n        Studs should end at the bottom face of the first top plate, which is\n        at wall_top - plate_thickness (the top plate top face is at wall_top).\n\n        Returns:\n            The elevation value, or None if it cannot be determined\n        \"\"\"\n        logger.debug(\"Getting top elevation for studs\")\n        try:\n            # Get plate thickness for calculations\n            plate_thickness = get_framing_param(\"plate_thickness\", self.wall_data, 1.5 / 12)\n\n            # If we have a top plate reference, extract its bottom elevation\n            # NOTE: self.top_plate should be the FIRST top plate (not cap plate)\n            # Its top face should be at wall_top, bottom face at wall_top - thickness\n            if self.top_plate is not None:\n                # Get bounding box of top plate\n                bbox = safe_get_bounding_box(self.top_plate, True)\n                if bbox.IsValid:\n                    # Use bbox.Min.Z for the bottom of the plate\n                    elevation = bbox.Min.Z\n                    logger.debug(f\"Top elevation from plate bounding box: {elevation}\")\n                    return elevation\n\n            # Fallback to wall data if available\n            # Studs end at bottom of top plate = wall_top - plate_thickness\n            wall_height = self.wall_data.get(\"wall_height\")\n            wall_base_elevation = self.wall_data.get(\"wall_base_elevation\", 0.0)\n\n            if wall_height is not None:\n                # Wall top elevation minus plate thickness gives bottom of top plate\n                wall_top = wall_base_elevation + wall_height\n                elevation = wall_top - plate_thickness\n                logger.debug(f\"Top elevation from wall data (wall_top - thickness): {elevation}\")\n                return elevation\n\n            logger.warning(\"Could not determine top elevation\")\n            return None\n\n        except Exception as e:\n            logger.error(f\"Error determining top elevation: {str(e)}\")\n            return None\n\n    def _calculate_stud_positions(\n        self, u_start: float, u_end: float, stud_spacing: float\n    ) -> List[float]:\n        \"\"\"\n        Calculate stud positions within a cell based on spacing.\n\n        CRITICAL: Every PANEL MUST have studs at both ends, regardless of length.\n        For short panels, we place end studs even if the panel is narrower than stud spacing.\n\n        End studs at panel boundaries are offset inward by half the stud width\n        so the stud edge aligns with the panel edge.\n\n        Studs at SC/OC boundaries (opening edges) are removed since those are king stud positions.\n\n        Args:\n            u_start: Starting u-coordinate of the cell\n            u_end: Ending u-coordinate of the cell\n            stud_spacing: Desired spacing between studs\n\n        Returns:\n            List of u-coordinates where studs should be placed\n        \"\"\"\n        logger.debug(f\"Calculating stud positions from {u_start} to {u_end} with spacing {stud_spacing}\")\n        try:\n            # Get wall length and stud dimensions for boundary detection\n            wall_length = self.wall_data.get(\"wall_length\", 0)\n            stud_width = get_framing_param(\"stud_width\", self.wall_data, 1.5 / 12)\n            half_stud_width = stud_width / 2\n\n            # Get panel boundaries if available (for panelized walls)\n            # Each panel needs its own end studs at panel boundaries\n            panel_u_start = self.wall_data.get(\"panel_u_start\", 0.0)\n            panel_u_end = self.wall_data.get(\"panel_u_end\", wall_length)\n\n            # Calculate the width of the cell\n            cell_width = u_end - u_start\n            logger.debug(f\"Cell width: {cell_width}\")\n            logger.debug(f\"Panel bounds: u_start={panel_u_start}, u_end={panel_u_end}\")\n\n            # Tolerance for boundary detection\n            tol = 0.01\n\n            # Determine if this cell is at PANEL boundaries (not just wall boundaries)\n            # For panelized walls, each panel needs end studs at its edges\n            is_at_panel_start = abs(u_start - panel_u_start) < tol\n            is_at_panel_end = abs(u_end - panel_u_end) < tol\n\n            # Also check wall boundaries for non-panelized walls\n            is_at_wall_start = abs(u_start) < tol\n            is_at_wall_end = wall_length > 0 and abs(u_end - wall_length) < tol\n\n            # Cell needs end studs if at panel OR wall boundary\n            needs_start_stud = is_at_panel_start or is_at_wall_start\n            needs_end_stud = is_at_panel_end or is_at_wall_end\n\n            logger.debug(f\"Panel boundary check: start={is_at_panel_start}, end={is_at_panel_end}\")\n            logger.debug(f\"Wall boundary check: start={is_at_wall_start}, end={is_at_wall_end}\")\n            print(f\"    Panel bounds: {panel_u_start:.4f} to {panel_u_end:.4f}\")\n            print(f\"    Cell at panel start: {is_at_panel_start}, at panel end: {is_at_panel_end}\")\n\n            # CRITICAL: Always add end studs at panel/wall boundaries\n            # Every panel MUST have studs at both ends\n            positions = []\n\n            # If cell starts at panel/wall start, add end stud (offset inward from panel edge)\n            if needs_start_stud:\n                # End stud position is offset inward from the panel/cell start\n                end_stud_pos = u_start + half_stud_width\n                positions.append(end_stud_pos)\n                logger.debug(f\"Added panel/wall start stud at u={end_stud_pos}\")\n                print(f\"    Added panel START stud at u={end_stud_pos:.4f}\")\n\n            # If cell ends at panel/wall end, add end stud (offset inward from panel edge)\n            if needs_end_stud:\n                # End stud position is offset inward from the panel/cell end\n                end_stud_pos = u_end - half_stud_width\n                # Only add if it's not too close to the start stud\n                if not positions or abs(end_stud_pos - positions[0]) > stud_width:\n                    positions.append(end_stud_pos)\n                    logger.debug(f\"Added panel/wall end stud at u={end_stud_pos}\")\n                    print(f\"    Added panel END stud at u={end_stud_pos:.4f}\")\n                else:\n                    logger.debug(f\"Panel too short for separate end stud (would overlap start stud)\")\n                    print(f\"    Panel too short - end stud would overlap start stud\")\n\n            # Now calculate intermediate studs based on spacing\n            # Only if there's enough room for at least one intermediate stud\n            internal_start = u_start + half_stud_width + stud_width if needs_start_stud else u_start\n            internal_end = u_end - half_stud_width - stud_width if needs_end_stud else u_end\n\n            internal_width = internal_end - internal_start\n\n            if internal_width > stud_spacing * 0.5:\n                # Calculate number of intermediate studs\n                num_intermediate = max(0, int(internal_width / stud_spacing))\n                logger.debug(f\"Can fit {num_intermediate} intermediate studs in internal width {internal_width}\")\n                print(f\"    Internal width={internal_width:.4f}, can fit {num_intermediate} intermediate studs\")\n\n                if num_intermediate > 0:\n                    # Distribute intermediate studs evenly\n                    actual_spacing = internal_width / (num_intermediate + 1)\n                    for i in range(1, num_intermediate + 1):\n                        pos = internal_start + i * actual_spacing\n                        positions.append(pos)\n                        logger.debug(f\"Added intermediate stud at u={pos}\")\n                        print(f\"    Added intermediate stud at u={pos:.4f}\")\n\n            # Handle cells that are NOT at panel/wall boundaries (bounded by openings)\n            # These cells have king studs at their edges, so we don't add studs at u_start/u_end\n            if not needs_start_stud and not needs_end_stud:\n                # This cell is between openings - only add intermediate studs\n                if cell_width > stud_spacing:\n                    num_studs = int(cell_width / stud_spacing)\n                    if num_studs > 0:\n                        actual_spacing = cell_width / (num_studs + 1)\n                        for i in range(1, num_studs + 1):\n                            pos = u_start + i * actual_spacing\n                            # Don't add if too close to cell boundaries (king stud positions)\n                            if pos - u_start > stud_width and u_end - pos > stud_width:\n                                positions.append(pos)\n                                logger.debug(f\"Added interior cell stud at u={pos}\")\n                                print(f\"    Added interior cell stud at u={pos:.4f}\")\n\n            # Sort positions and remove duplicates\n            positions = sorted(set(positions))\n\n            # Filter out positions at SC/OC boundaries (king stud positions)\n            # These are at u_start or u_end when NOT at panel/wall boundaries\n            filtered_positions = []\n            for pos in positions:\n                # Check if at cell boundary (not panel boundary) - these are king stud positions\n                is_near_cell_start = abs(pos - u_start) < tol and not needs_start_stud\n                is_near_cell_end = abs(pos - u_end) < tol and not needs_end_stud\n\n                if is_near_cell_start or is_near_cell_end:\n                    logger.debug(f\"Removing stud at {pos} (king stud position)\")\n                    print(f\"    Removing stud at u={pos:.3f} (OC boundary = king stud position)\")\n                else:\n                    filtered_positions.append(pos)\n\n            logger.debug(f\"Calculated stud positions: {filtered_positions}\")\n            print(f\"    Final stud positions: {[f'{p:.4f}' for p in filtered_positions]}\")\n            return filtered_positions\n\n        except Exception as e:\n            logger.error(f\"Error calculating stud positions: {str(e)}\")\n            import traceback\n            logger.error(traceback.format_exc())\n            return []\n\n    def _filter_positions_by_king_studs(\n        self, positions: List[float], min_distance: float\n    ) -> List[float]:\n        \"\"\"\n        Filter out stud positions that are too close to king studs.\n\n        Args:\n            positions: List of candidate stud positions (u-coordinates)\n            min_distance: Minimum distance to keep from king studs\n\n        Returns:\n            Filtered list of positions that are safe from king studs\n        \"\"\"\n        logger.debug(f\"Filtering {len(positions)} positions to avoid king studs\")\n        logger.debug(f\"Using minimum distance: {min_distance}\")\n        \n        if not self.king_stud_positions:\n            logger.debug(\"No king stud positions to filter against\")\n            return positions\n\n        try:\n            filtered_positions = []\n            for pos in positions:\n                # Check distance to all king studs\n                too_close = False\n                for king_pos in self.king_stud_positions:\n                    distance = abs(pos - king_pos)\n                    if distance < min_distance:\n                        logger.debug(f\"Position {pos} too close to king stud at {king_pos} (distance: {distance})\")\n                        too_close = True\n                        break\n\n                if not too_close:\n                    filtered_positions.append(pos)\n\n            logger.debug(f\"Filtered to {len(filtered_positions)} positions\")\n            return filtered_positions\n\n        except Exception as e:\n            logger.error(f\"Error filtering positions by king studs: {str(e)}\")\n            return positions\n\n    def _create_stud_geometry(\n        self,\n        base_plane: rg.Plane,\n        u_coordinate: float,\n        bottom_v: float,\n        top_v: float,\n        width: float,\n        depth: float,\n    ) -> Optional[rg.Brep]:\n        \"\"\"\n        Create the geometry for a single stud.\n\n        Args:\n            base_plane: Wall's base plane for coordinate system\n            u_coordinate: Position along wall (horizontal)\n            bottom_v: Bottom elevation of stud\n            top_v: Top elevation of stud\n            width: Width of stud (perpendicular to wall face)\n            depth: Depth of stud (parallel to wall length)\n\n        Returns:\n            Brep geometry for the stud, or None if creation fails\n        \"\"\"\n        logger.debug(f\"Creating stud geometry at u={u_coordinate}, v range={bottom_v}-{top_v}\")\n        logger.debug(f\"Stud dimensions - width: {width}, depth: {depth}\")\n        \n        try:\n            # 1. Create the centerline endpoints in world coordinates\n            # Position along wall using XAxis (U direction)\n            # Vertical position uses Z coordinate directly (V direction)\n            point_along_wall = rg.Point3d.Add(\n                base_plane.Origin,\n                rg.Vector3d.Multiply(base_plane.XAxis, u_coordinate)\n            )\n\n            # Create start point at bottom elevation (Z = bottom_v)\n            start_point = rg.Point3d(point_along_wall.X, point_along_wall.Y, bottom_v)\n\n            # Create end point at top elevation (Z = top_v)\n            end_point = rg.Point3d(point_along_wall.X, point_along_wall.Y, top_v)\n\n            logger.debug(f\"Centerline start point: ({start_point.X}, {start_point.Y}, {start_point.Z})\")\n            logger.debug(f\"Centerline end point: ({end_point.X}, {end_point.Y}, {end_point.Z})\")\n\n            # Create the centerline as a curve\n            # Convert to NurbsCurve to ensure proper type for SweepOneRail.PerformSweep()\n            centerline = rg.LineCurve(start_point, end_point).ToNurbsCurve()\n            self.debug_geometry[\"paths\"].append(centerline)\n            logger.debug(f\"Centerline length: {safe_get_length(centerline)}\")\n\n            # 2. Create a HORIZONTAL profile plane at the start point\n            # For vertical studs, the profile must be perpendicular to the centerline\n            # Since centerline is vertical (Z direction), profile plane must be horizontal\n            # Use a simple horizontal plane with normal pointing UP\n            profile_plane = rg.Plane(start_point, rg.Vector3d.ZAxis)\n            self.debug_geometry[\"planes\"].append(profile_plane)\n            logger.debug(\"Created horizontal profile plane for stud cross-section\")\n\n            # 3. Create a rectangle for the profile\n            # For timber framing studs:\n            # - Width (1.5\") = visible on wall face, runs ALONG wall direction\n            # - Depth (3.5\") = wall thickness, runs PERPENDICULAR to wall face (wall normal)\n            half_width = width / 2\n            half_depth = depth / 2\n\n            # Project wall directions onto horizontal plane for profile orientation\n            wall_normal_horiz = rg.Vector3d(base_plane.ZAxis.X, base_plane.ZAxis.Y, 0)\n            wall_along_horiz = rg.Vector3d(base_plane.XAxis.X, base_plane.XAxis.Y, 0)\n\n            # Normalize (handle zero-length vectors)\n            if wall_normal_horiz.Length > 0.001:\n                wall_normal_horiz.Unitize()\n            else:\n                wall_normal_horiz = rg.Vector3d(0, 1, 0)  # Default Y\n            if wall_along_horiz.Length > 0.001:\n                wall_along_horiz.Unitize()\n            else:\n                wall_along_horiz = rg.Vector3d(1, 0, 0)  # Default X\n\n            # Create corners in world XY, offset from start_point\n            # Width (1.5\") along wall, Depth (3.5\") through wall thickness\n            c1 = rg.Point3d(\n                start_point.X - wall_along_horiz.X * half_width - wall_normal_horiz.X * half_depth,\n                start_point.Y - wall_along_horiz.Y * half_width - wall_normal_horiz.Y * half_depth,\n                start_point.Z\n            )\n            c2 = rg.Point3d(\n                start_point.X + wall_along_horiz.X * half_width - wall_normal_horiz.X * half_depth,\n                start_point.Y + wall_along_horiz.Y * half_width - wall_normal_horiz.Y * half_depth,\n                start_point.Z\n            )\n            c3 = rg.Point3d(\n                start_point.X + wall_along_horiz.X * half_width + wall_normal_horiz.X * half_depth,\n                start_point.Y + wall_along_horiz.Y * half_width + wall_normal_horiz.Y * half_depth,\n                start_point.Z\n            )\n            c4 = rg.Point3d(\n                start_point.X - wall_along_horiz.X * half_width + wall_normal_horiz.X * half_depth,\n                start_point.Y - wall_along_horiz.Y * half_width + wall_normal_horiz.Y * half_depth,\n                start_point.Z\n            )\n\n            # Debug: store corners\n            for corner in [c1, c2, c3, c4]:\n                self.debug_geometry[\"points\"].append(corner)\n\n            # Create closed polyline for profile\n            profile_poly = rg.Polyline([c1, c2, c3, c4, c1])  # Close the loop\n            profile_curve = profile_poly.ToNurbsCurve()\n            self.debug_geometry[\"profiles\"].append(profile_curve)\n            logger.debug(\"Created profile rectangle in horizontal plane\")\n\n            # 4. Extrude the profile along the vertical direction\n            # Using Extrusion.Create for simple vertical extrusion\n            # Note: Extrusion.Create extrudes OPPOSITE to curve plane normal when height > 0\n            # Our profile plane normal is (0,0,1) pointing UP, so we need NEGATIVE height\n            # to extrude UPWARD (in direction of normal)\n            extrusion_height = -(end_point.Z - start_point.Z)\n\n            print(f\"      Extrusion height: {extrusion_height:.2f} (negative = extrude UP)\")\n\n            # Create extrusion from planar profile curve\n            # Extrusion.Create(planarCurve, height, cap) -> Extrusion\n            extrusion = rg.Extrusion.Create(profile_curve, extrusion_height, True)\n\n            if extrusion is None:\n                logger.warning(\"Failed to create extrusion\")\n                print(f\"      EXTRUSION FAILED: Extrusion.Create returned None\")\n                return None\n\n            # Convert Extrusion to Brep for compatibility with rest of pipeline\n            brep = extrusion.ToBrep()\n            if brep is None:\n                logger.warning(\"Failed to convert extrusion to Brep\")\n                print(f\"      EXTRUSION FAILED: ToBrep returned None\")\n                return None\n\n            logger.debug(\"Successfully created stud Brep via extrusion\")\n            print(f\"      EXTRUSION SUCCESS: Created stud Brep\")\n            return brep\n\n        except Exception as e:\n            logger.error(f\"Error creating stud geometry: {str(e)}\")\n            import traceback\n            tb = traceback.format_exc()\n            logger.error(tb)\n            print(f\"      EXCEPTION: {str(e)}\")\n            print(f\"      TRACEBACK: {tb}\")\n            return None\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}