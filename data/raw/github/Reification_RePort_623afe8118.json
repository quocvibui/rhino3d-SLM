{
  "source_url": "https://github.com/Reification/RePort/blob/c4c821704138d67464eeb69a176bee42d49a99da/Rhino_Exporter/RePort_cmd.py",
  "repo": "Reification/RePort",
  "repo_stars": 1,
  "repo_description": "A free open source tool to convert architecture designs to first-person immersive experiences.",
  "license": "unknown",
  "filepath": "Rhino_Exporter/RePort_cmd.py",
  "instruction": "Copyright 2021 Reification Incorporated Licensed under Apache 2.0. All Rights reserved.",
  "code": "# Copyright 2021 Reification Incorporated\n# Licensed under Apache 2.0. All Rights reserved.\n\nfrom Rhino import *\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport os\nimport shutil\nimport __plugin__\n\n__commandname__ = __plugin__.title\n\n# PROBLEM: The IronPython plugin for Rhino (versions 5, 6, 7) uses the first installed command version.\n# SOLUTION: Make the version in __plugin__.py invariant and declare code version here.\n# NOTE: The version declared in __plugin__.py must be non-zero\n# https://discourse.mcneel.com/t/updating-python-plugin-version/119362\nRePort_version = \"0.3.1\" #__plugin__.version\n\nRhino_version = RhinoApp.Version.Major\n\n# https://developer.rhino3d.com/api/RhinoCommon/html/T_Rhino_DocObjects_ObjectType.htm\n# WARNING: Incomplete documentation for Rhino7 in RhinoScript reference:\n# https://developer.rhino3d.com/api/rhinoscript/object_methods/objecttype.htm\n#    - None                  0             Nothing.\n#    X Point                 1             A point.\n#    X PointSet              2             A point set or cloud.\n#    X Curve                 4             A curve.\n#    V Surface               8             A surface.\n#    V Brep                  16            A brep.\n#    V Mesh                  32            A mesh.\n#    V Light                 256           A rendering light.\n#    X Annotation            512           An annotation.\n#    X InstanceDefinition    2048          A block definition.\n#    V InstanceReference     4096          A block reference.\n#    X TextDot               8192          A text dot.\n#    X Grip                  16384         Selection filter value - not a real object type.\n#    X Detail                32768         A detail.\n#    X Hatch                 65536         A hatch.\n#    X MorphControl          131072        A morph control.\n#    V SubD                  262144        A SubD object.\n#    X BrepLoop              524288        A brep loop.\n#    X BrepVertex            1048576       a brep vertex.\n#    X PolysrfFilter         2097152       Selection filter value - not a real object type.\n#    X EdgeFilter            4194304       Selection filter value - not a real object type.\n#    X PolyedgeFilter        8388608       Selection filter value - not a real object type.\n#    X MeshVertex            16777216      A mesh vertex.\n#    X MeshEdge              33554432      A mesh edge.\n#    X MeshFace              67108864      A mesh face.\n#    X Cage                  134217728     A cage.\n#    X Phantom               268435456     A phantom object. https://discourse.mcneel.com/t/what-is-the-phantom-object-type/119363/7\n#    X ClipPlane             536870912     A clipping plane.\n#    V Extrusion             1073741824    An extrusion.\n#    - AnyObject             4294967295    All bits set.\nlights_export = 256 # Lights with configuration placeholders\nmeshes_export = 32  # Single export at fixed detail\ndetail_export = 8 + 16 + 262144 + 1073741824  # Multiple level of detail export\nblocks_export = 4096  # Block instances are replaced by transform placeholders\nexport_select = lights_export | meshes_export | detail_export | blocks_export\n\n# Select all objects that will be exported\ndef SelectExport():\n    rs.ObjectsByType(geometry_type=export_select, select=True, state=0)\n\n# Get selected objects that will be exported\ndef SelectedObjects():\n    return rs.SelectedObjects(True, False)\n\n# Remove unsafe characters from file name\n# https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file\n# https://stackoverflow.com/questions/62771/how-do-i-check-if-a-given-string-is-a-legal-valid-file-name-under-windows\ndef SafeFileName(name):\n    name = name.replace('<', \"\")\n    name = name.replace('>', \"\")\n    name = name.replace(':', \"\")\n    name = name.replace('\"', \"\")\n    name = name.replace('/', \"\")\n    name = name.replace('\\\\', \"\")\n    name = name.replace('|', \"\")\n    name = name.replace('?', \"\")\n    name = name.replace('*', \"\")\n    return name\n\n# TODO: Rhino specific safety\n# https://docs.mcneel.com/rhino/7/help/en-us/information/namingconventions.htm\n\n# Remove unsafe characters from object name\ndef SafeObjectName(name):\n    if name is None:\n        return \"\"\n    name = SafeFileName(name)\n    name = name.replace(\"=\", \"-\")\n    return name\n\n# QUESTION: Is it possible to also render block names safe?\n\n# PROBLEM: Objects may have empty, non-unique opr unsafe names\n# SOLUTION: Give each object a unique safe name, and create\n# a dictionary to revert these changes after export.\ndef UniqueRename(name_map):\n    selected = SelectedObjects()\n    for object in selected:\n        old_name = rs.ObjectName(object)\n        new_name = SafeObjectName(old_name)\n        if len(new_name) == 0:\n            new_name = \"Unknown\"\n            if rs.IsObject(object):\n                new_name = \"Object\"\n            # NOTE: IsObject and IsLight can both be true\n            # so IsLight must be checked after\n            if rs.IsLight(object):\n                new_name = \"Light\"\n        if old_name is None or len(old_name) == 0 or new_name in name_map:\n            suffix = len(name_map)\n            while new_name + \"_\" + str(suffix) in name_map:\n                suffix += 1\n            new_name += \"_\" + str(suffix)\n        name_map[new_name] = old_name\n        rs.ObjectName(object, new_name)\n\n# Revert name changes\ndef RevertRename(name_map):\n    selected = SelectedObjects()\n    for object in selected:\n        new_name = rs.ObjectName(object)\n        if new_name in name_map:\n            old_name = name_map[new_name]\n            if old_name is None:\n                old_name = \"\"  # Restores name is None state\n            rs.ObjectName(object, old_name)\n            del name_map[new_name]\n\n# Rhino export looks at filename suffix to determine format\n# Unity import looks for suffix to determined format,\n# and at names before suffix to determine provenance.\ndef SaveSuffix():\n    return \".3dm_\" + str(Rhino_version) + \".fbx\"\n\n# IDEA: When exporting placeholders\n# exclude materials and textures\n# IDEA: When  exporting detail or placeholders exclude cameras and lights\n\n# Save options target export for rendering\n# NOTE: GeometryOnly=Yes would exclude BOTH cameras and lights\n# WARNING: Unrecognized commands are interpreted as filename!\n# When running Rhino5 entering Version=6 saves \"Version=6.3dm\"\ndef SaveOptions():\n    # https://docs.mcneel.com/rhino/5/help/en-us/commands/save.htm\n    options = \"Version=\" + str(Rhino_version) + \" \"\\\n        \"SaveTextures=Yes \"\\\n        \"GeometryOnly=No \"\\\n        \"SavePluginData=No \"\\\n        \"SaveSmall=Yes \"\n    # https://docs.mcneel.com/rhino/6/help/en-us/commands/save.htm\n    # https://docs.mcneel.com/rhino/7/help/en-us/commands/save.htm\n    if Rhino_version >= 6:\n        options += \\\n            \"SaveNotes=No \"\n    return options\n\n# FBX export options targeting Unity's import process\n# NOTE: Enter exits fbx options\ndef FormatOptions():\n    # https://docs.mcneel.com/rhino/5/help/en-us/fileio/motionbuilder_fbx_import_export.htm\n    options = \\\n        \"ExportFileAs=Version7Binary \"\\\n        \"ExportNurbsObjectsAs=Mesh \"\\\n        \"ExportMaterialsAs=Lambert \"\n    # https://docs.mcneel.com/rhino/6/help/en-us/fileio/motionbuilder_fbx_import_export.htm\n    if Rhino_version >= 6:\n        options += \\\n            \"YUp=No \"\n    # https://docs.mcneel.com/rhino/7/help/en-us/fileio/motionbuilder_fbx_import_export.htm\n    if Rhino_version >= 7:\n        options += \\\n            \"ExportVertexNormals=Yes \"\\\n            \"ExportLights=Yes \"\\\n            \"ExportViews=No \"\n    return options\n\n# Parametric Surface Meshing Options\n# https://wiki.mcneel.com/rhino/meshsettings\n# https://docs.mcneel.com/rhino/7/help/en-us/popup_moreinformation/polygon_mesh_detailed_options.htm\ndef MeshingOptions(detail):\n    options = \" PolygonDensity=0 \"\n    if detail == 0:\n        options += \"DetailedOptions \"\\\n            \"JaggedSeams=No \"\\\n            \"SimplePlane=Yes \"\\\n            \"Refine=Yes \"\\\n            \"PackTextures=No \"\n    else:\n        options += \"DetailedOptions \"\\\n            \"JaggedSeams=Yes \"\\\n            \"SimplePlane=Yes \"\\\n            \"Refine=Yes \"\\\n            \"PackTextures=No \"\n    if detail == 0:\n        options += \"AdvancedOptions \"\\\n            \"Angle=15 \"\\\n            \"AspectRatio=0 \"\\\n            \"Distance=0.01 \"\\\n            \"Density=0 \"\\\n            \"Grid=0 \"\\\n            \"MaxEdgeLength=0 \"\\\n            \"MinEdgeLength=0.001 \"\n        # SubD options: https://discourse.mcneel.com/t/exporting-subd-objects-to-fbx/119364/4\n        if Rhino_version >= 7:\n            options += \\\n                \"SubdivisionLevel=5 \"\\\n                \"SubdivisionContext=Absolute \"\n    if detail == 1:\n        options += \"AdvancedOptions \"\\\n            \"Angle=30 \"\\\n            \"AspectRatio=0 \"\\\n            \"Distance=0.1 \"\\\n            \"Density=0 \"\\\n            \"Grid=0 \"\\\n            \"MaxEdgeLength=0 \"\\\n            \"MinEdgeLength=0.01 \"\n        # SubD options: https://discourse.mcneel.com/t/exporting-subd-objects-to-fbx/119364/4\n        if Rhino_version >= 7:\n            options += \\\n                \"SubdivisionLevel=3 \"\\\n                \"SubdivisionContext=Adaptive \"\n    if detail == 2:\n        options += \"AdvancedOptions \"\\\n            \"Angle=45 \"\\\n            \"AspectRatio=0 \"\\\n            \"Distance=1.0 \"\\\n            \"Density=0 \"\\\n            \"Grid=0 \"\\\n            \"MaxEdgeLength=0 \"\\\n            \"MinEdgeLength=0.1 \"\n        # SubD options: https://discourse.mcneel.com/t/exporting-subd-objects-to-fbx/119364/4\n        if Rhino_version >= 7:\n            options += \\\n                \"SubdivisionLevel=1 \"\\\n                \"SubdivisionContext=Adaptive \"\n    return options\n\n# TODO: Adapt distance options to file units.\n# IDEA: Adapt angle parameters (or maximum distance) to object size,\n# so that large curves are not heavily segmented.\n\n# NOTE: High levels of detail on large objects slows rendering,\n# since rendered detail selection is proportionate to screen size.\n# IDEA: If mesh edge size was consistent then it could be used\n# to modify the screen size choice.\n\n# NOTE: Least resolved detail level is used for collisions,\n# so maximum distance cannot diverge too significantly.\n# IDEA: Physics detail level should be based on object scale.\n\n# IDEA: For terrain, a different export-import process would help.\n# Export could be at maximum level of detail.\n# Import could subdivide & subsample.\n# Lightmap should be contributing only.\n\n# IDEA: Interactive mode could allow modification of defaults\n# Including count or even parameters.\n# NOTE: This would require cached preferences.\n\n# NOTE: file_name followed by space will exit save options\n# IMPORTANT: enclosing file_name in \" prevents truncation at spaces\ndef ExportModel(path, name, detail=0):\n    file_name = os.path.join(path, name + SaveSuffix())\n    return rs.Command(\n        \"-Export \" +\\\n        SaveOptions() +\\\n        '\"' + file_name + '\" ' +\\\n        FormatOptions() + \"Enter \" +\\\n        MeshingOptions(detail) + \"Enter \" +\\\n        \"Enter\", \n        True\n    )\n\n# NOTE: file_name followed by space will exit save options\n# IMPORTANT: enclosing file_name in \" prevents truncation at spaces\ndef ExportBlock(path, name, detail=0):\n    file_name = os.path.join(path, name + save_sufix())\n    return rs.Command(\n        \"-BlockManager Export \" +\\\n        '\"' + name + '\" ' +\\\n        SaveOptions() +\\\n        '\"' + file_name + '\" ' +\\\n        FormatOptions() + \"Enter \" +\\\n        MeshingOptions(detail) + \"Enter \" +\\\n        \"Enter Enter\",  # NOTE: Second enter exits BlockManager\n        True\n    )\n\n# TODO: Find Documentation for custom units python interface\n# https://developer.rhino3d.com/api/rhinoscript/document_methods/unitcustomunitsystem.htm\n\n# Multiplier to convert model scale to meters\n# FBX export will correctly scale models and blocks.\n# https://developer.rhino3d.com/api/rhinoscript/document_methods/unitsystem.htm\ndef ModelScale():\n    meter = 1.0  # Unity units\n    inch = meter * 0.3048 / 12.0\n    units = int(sc.doc.ActiveDoc.ModelUnitSystem)\n    scale = 1.0\n    if units == 0: scale = 1.0 # None\n    if units == 1: scale = meter * 1.0e-6\n    if units == 2: scale = meter * 1.0e-3\n    if units == 3: scale = meter * 1.0e-2\n    if units == 4: scale = meter\n    if units == 5: scale = meter * 1.0e+3\n    if units == 6: scale = inch * 1.0e-6\n    if units == 7: scale = inch * 1.0e-3\n    if units == 8: scale = inch\n    if units == 9: scale = inch * 12  # foot\n    if units == 10: scale = inch * 12 * 5280  # mile\n    if units == 11: 1.0 # Custom -- interface is  missing from python\n    if units == 12: scale = meters * 1.0e-10\n    if units == 13: scale = meter * 1.0e-9\n    if units == 14: scale = meter * 1.0e-1\n    if units == 15: scale = meter * 1.0e1\n    if units == 16: scale = meter * 1.0e2\n    if units == 17: scale = meter * 1.0e6\n    if units == 18: scale = meter * 1.0e9\n    if units == 19: scale = inch * 12 * 3  # yard\n    if units == 20: scale = inch / 72  # printer point\n    if units == 21: scale = inch / 6  # printer pica\n    if units == 22: scale = meter * 1852 # nautical mile\n    # https://en.wikipedia.org/wiki/Astronomical_unit\n    if units == 23: scale = meter * 149597870700\n    #  https://en.wikipedia.org/wiki/Light-year\n    if units == 24: scale = meter * 9460730472580800\n    # https://en.wikipedia.org/wiki/Parsec\n    if units == 25: scale = meter * 149597870700 * 648000 / 3.14159265358979323\n    return scale\n\n# Zero vector\ndef ZeroVector():\n    # NOTE: Rhino5 interprets [0, 0, 0] as a vector\n    # Later versions explicit conversion via rs.CreateVector([0, 0, 0])\n    return rs.VectorCreate([0, 0, 0], [0, 0, 0])\n\n# Copy of unit basis vector\ndef UnitVector(b):\n    vector = ZeroVector()\n    vector[b] = 1\n    return vector\n\n# Copy of unit basis    \ndef UnitBasis():\n    return [UnitVector(0), UnitVector(1), UnitVector(2)]\n\n# Create a basis with direction as the final element\ndef BasisFromDirection(direction):\n    b2 = rs.VectorUnitize(direction)\n    for b in range(3):\n        b0 = UnitVector(b)\n        # At least one unit vector must meet this condition\n        inner = rs.VectorDotProduct(b0, b2)\n        if -0.5 < inner <= 0.5:\n            b0 = rs.VectorUnitize(b0 - b2 * inner)\n            b1 = rs.VectorCrossProduct(b2, b0)\n            return [b0, b1, b2]\n    return UnitBasis()\n\n# Create a location encoding tetrahedron mesh\ndef LocationMesh(origin, basis):\n    points = UnitBasis()\n    # Convert directions to positions relative to origin\n    for b in range(3):\n        points[b] = rs.VectorAdd(basis[b], origin)\n    # Construct basis tetrahedron\n    mesh = rs.AddMesh(\n        [origin, points[0], points[1], points[2]],\n        [[0, 2, 1], [0, 3, 2], [0, 1, 3], [1, 2, 3]]\n    )\n    return mesh\n\n# Create a placeholder tetrahedron that encodes the block instance transform\n# Units will be in meters to be consistent with import\ndef BlockLocation(object, scale):\n    # WARNING: The basis describes a transformation of the Rhino basis\n    # with respect to the Rhino basis, which might not match the\n    # import environment world basis.\n    x = rs.BlockInstanceXform(object)\n    p0 = [x.M00, x.M10, x.M20]  # X Basis direction\n    p1 = [x.M01, x.M11, x.M21]  # Y Basis direction\n    p2 = [x.M02, x.M12, x.M22]  # Z Basis direction\n    p3 = [x.M03, x.M13, x.M23]  # Origin position\n    # Rescale transform units\n    for i in range(3):\n        p0[i] /= scale\n        p1[i] /= scale\n        p2[i] /= scale\n    # Construct basis tetrahedron\n    placeholder = LocationMesh(p3, [p0, p1, p2])\n    \n    # Unity import will render names unique with a _N suffix on the N copy\n    # so block name is included as a prefix to facilitate matching\n    # in the case that block objects names are not unique\n    block = rs.BlockInstanceName(object)\n    block_name = SafeObjectName(block)\n    object_name = rs.ObjectName(object)\n    rs.ObjectName(placeholder, block_name + \"=\" + object_name)\n    rs.ObjectLayer(placeholder, rs.ObjectLayer(object))\n    return placeholder\n\n# PROBLEM: Lights-only export fails!\n# PROBLEM: Lights are exported without rotation or shape!\n# SOLUTION: Create a placeholder tetrahedron that encodes light parameters\n# PROBLEM: FBX does not support line light type\n# https://help.autodesk.com/view/FBX/2020/ENU/?guid=FBX_Developer_Help_cpp_ref_class_fbx_light_html\n# SOLUTION: Describe line lights as area lights with length equal to zero\n# - Rhino exports color, intensity and type\n# - Placeholders will be created with corresponding names\n# - Light type will be encoded in the name in case of unsupported types\n# - Rectangles use X and Y scale for dimensions\n# - Spots will use X (and equal Y) ratio to Z=1 for opening angle\n# - Lines have a Y scale equal to the width, other dimensions equal to zero\n# - Range must be determined from context on import\n# https://developer.rhino3d.com/api/rhinoscript/light_methods/light_methods.htm\ndef LightLocation(light, scale):\n    if not rs.IsLight(light):\n        return\n    \n    # Default light transform\n    # NOTE: Point light direction is [0, 0, -1]\n    position = rs.LightLocation(light)\n    direction = rs.LightDirection(light)\n    basis = BasisFromDirection(direction)\n    \n    # Modify transform according to light type\n    lightType = \"UnknownLight\"\n    if rs.IsPointLight(light):\n        lightType = \"PointLight\"\n        #clone = rs.AddPointLight(position)\n    if rs.IsDirectionalLight(light):\n        lightType = \"DirectionalLight\"\n        #clone = rs.AddDirectionalLight(position, position + direction)\n    if rs.IsSpotLight(light):\n        lightType = \"SpotLight\"\n        outer = rs.SpotLightRadius(light)\n        inner = rs.SpotLightHardness(light) * outer\n        # Encode spot parameters in basis lengths\n        basis = [\n            basis[0] * outer,\n            basis[1] * inner,\n            direction\n        ]\n        #clone = rs.AddSpotLight(position + direction, outer, position)\n        #rs.SpotLightHardness(clone, inner / outer)\n    if rs.IsRectangularLight(light):\n        # WARNING: Incomplete documentation for Rhino7 in RhinoScript reference:\n        # https://developer.rhino3d.com/api/rhinoscript/light_methods/rectangularlightplane.htm\n        lightType = \"RectangularLight\"\n        quadVectors, quadLengths = rs.RectangularLightPlane(light)\n        heightBasis = quadVectors[1] * quadLengths[0] / 2\n        widthBasis = quadVectors[2] * quadLengths[1] / 2\n        position = quadVectors[0] + heightBasis + widthBasis # center\n        direction = -quadVectors[3] # negative of light direction\n        # Encode quad dimensions in basis lengths\n        basis = [\n            widthBasis,\n            heightBasis,\n            direction\n        ]\n        #corner = position - (widthBasis + heightBasis)\n        #clone = rs.AddRectangularLight(corner, corner + widthBasis * 2, corner + heightBasis * 2)\n    if rs.IsLinearLight(light):\n        # Encode line segment in first basis\n        lightType = \"LinearLight\"\n        widthBasis = direction / 2\n        position = position + widthBasis\n        basis = [\n            widthBasis,\n            basis[1],\n            -basis[0]\n        ]\n        #clone = rs.AddLinearLight (position - widthBasis, position + widthBasis)\n    \n    # Create placeholder mesh\n    # NOTE: light dimensions are not scaled\n    placeholder = LocationMesh(position, basis)\n    \n    # NOTE: Lights have no corresponding exported block,\n    # but the same notation will be used to configure lights in the exported model.\n    # Unity import will render names unique with a _N suffix on the N copy\n    # so block name is included as a prefix to facilitate matching\n    # in the case that block instances names are not unique\n    objectName = rs.ObjectName(light)\n    rs.ObjectName(placeholder, lightType + \"=\" + objectName)\n    rs.ObjectLayer(placeholder, rs.ObjectLayer(light))\n    return placeholder\n\n# Pause exporting to show additions and selection\ndef ShowStep(step_name):\n    rs.EnableRedraw(True)\n    input = rs.GetString(\"Showing step: \" + step_name + \" (Press Enter to continue)\")\n    rs.EnableRedraw(False)\n\n# Export currently selected objects\n# This enables recursive exporting of exploded block instances\n# which creates detail and placeholder constituents for blocks\ndef ExportSelected(scale, path, name):\n    #ShowStep(\"Scene or block export\")\n    # Include lights, exclude grips in selected\n    selected = SelectedObjects()\n    rs.UnselectAllObjects()\n    export_exists = False\n    \n    # Export lights\n    # NOTE: Lights must be exported separately so that\n    # placeholder meshes can be imported without modification.\n    placeholders = []\n    for object in selected:\n        if rs.ObjectType(object) & lights_export:\n            rs.SelectObject(object)\n            lightLocation = LightLocation(object, scale)\n            placeholders.append(lightLocation)\n            rs.SelectObject(lightLocation)\n    if len(SelectedObjects()) > 0:\n        #ShowStep(\"Light export\")\n        ExportModel(path, name + \".lights\")\n        rs.DeleteObjects(placeholders)\n        export_exists = True\n    rs.UnselectAllObjects()\n    \n    # Export meshes\n    for object in selected:\n        if rs.ObjectType(object) & meshes_export:\n            rs.SelectObject(object)\n    if len(SelectedObjects()) > 0:\n        #ShowStep(\"Mesh objects export\")\n        ExportModel(path, name + \".meshes\")\n        export_exists = True\n    rs.UnselectAllObjects()\n    \n    # Export detail\n    for object in selected:\n        if rs.ObjectType(object) & detail_export:\n            rs.SelectObject(object)\n    if len(SelectedObjects()) > 0:\n        #ShowStep(\"Parametric objects export\")\n        ExportModel(path, name + \".meshes0\", 0)\n        ExportModel(path, name + \".meshes1\", 1)\n        ExportModel(path, name + \".meshes2\", 2)\n        export_exists = True\n    rs.UnselectAllObjects()\n    \n    # Export blocks\n    # NOTE: Block placeholders must be exported separately\n    # so that meshes can be imported with modification.\n    placeholders = []\n    for object in selected:\n        if rs.ObjectType(object) & blocks_export:\n            # Export block constituents into subdirectory\n            # On import contents of block will be merged,\n            # and will then replace placeholders in scene and other blocks\n            block = rs.BlockInstanceName(object)\n            block_name = SafeObjectName(block)\n            block_path = os.path.join(path, block_name)\n            block_done = False\n            try:\n                os.mkdir(block_path)\n            except OSError:\n                # Directory exists so block has already been exported\n                block_done = True\n            if not block_done:\n                # Export block instantiation\n                instance = rs.InsertBlock(block, [0, 0, 0])\n                # IMPORTANT: Nested instances are not exploded,\n                # so that constituent blocks will be exported.\n                instance_parts = rs.ExplodeBlockInstance(instance)\n                rs.SelectObjects(instance_parts)\n                block_name_map = {}\n                UniqueRename(block_name_map)\n                #ShowStep(\"Block \" + block + \" export\")\n                # IMPORTANT: block subdirectory is prepended to name\n                # so that constituent blocks will be discovered or exported\n                # in adjacent directories.\n                # This prevents repeated exporting in nested directories.\n                block_pathname = os.path.join(block_name, block_name)\n                block_done = ExportSelected(scale, path, block_pathname)\n                rs.DeleteObjects(instance_parts)\n            if block_done:\n                # Create a placeholder\n                placeholders.append(BlockLocation(object, scale))\n            else:\n                # Remove empty directory\n                os.rmdir(block_path)\n    if len(placeholders) > 0:\n        rs.SelectObjects(placeholders)\n        #ShowStep(\"Block placeholder export\")\n        ExportModel(path, name + \".places\")\n        rs.DeleteObjects(placeholders)\n        export_exists = True\n    \n    # Restore selection\n    rs.SelectObjects(selected)\n    return export_exists\n\n# Default: create a folder next to active doc with the same name\ndef GetExportPath(is_interactive):\n    if sc.doc.ActiveDoc.Path is None or sc.doc.ActiveDoc.Name is None:\n        print(\"Save document before exporting\")\n        return\n    \n    # NOTE: [:-4] removes ActiveDoc.Name suffix \".3dm\"\n    name = sc.doc.ActiveDoc.Name[:-4]\n    path = sc.doc.ActiveDoc.Path[:-4]\n    if is_interactive:\n        path = rs.BrowseForFolder(\n            folder=os.path.dirname(path),\n            title=\"RePort\",\n            message=\"Choose root folder for exported files...\"\n        )  # Known safe\n        if path is None:\n            # User cancelled out of location selection\n            return\n        name = os.path.split(path)[1]\n    else:\n        shutil.rmtree(path, True)\n        os.mkdir(path)\n        # BUG: If directory already exists os.mkdir may raise error.\n        # NOTE: Directory deletion still succeedes, and subsequent run\n        # will not raise an error.\n    \n    return path, name\n\ndef RunCommand(is_interactive):\n    command_preamble = __commandname__ + \" v\" + RePort_version\n    \n    if not (Rhino_version == 7 or Rhino_version == 6 or Rhino_version == 5):\n        print(command_preamble + \": does not support Rhino Rhino_version \" + str(Rhino_version) + \" -> abort\")\n        return\n    \n    path_name = GetExportPath(is_interactive)\n    if path_name is None:\n        print(command_preamble + \": no export location -> abort\")\n        return\n    \n    # Record modification status\n    modified = sc.doc.Modified\n    \n    name_map = {}\n    selected = rs.SelectedObjects(True, True)\n    try:\n        rs.EnableRedraw(False)\n        \n        # Select all exportable objects in scene\n        SelectExport()\n        UniqueRename(name_map)\n        scale = ModelScale()\n        ExportSelected(scale, *path_name)\n    finally:\n        # Revert object names and selection\n        SelectExport()\n        RevertRename(name_map)\n        rs.UnselectAllObjects()\n        rs.SelectObjects(selected)\n        \n        rs.EnableRedraw(True)\n    \n    # Restore modification status - all changes have been reverted\n    sc.doc.Modified = modified\n    print(command_preamble + \": success\")\n\n# GOAL: No changes to scene (no save request)\n# GOAL: Launch Rhino in batch mode (headless) \n# with script, input & output paths as arguments\nif __name__ == \"__main__\": RunCommand(False)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}