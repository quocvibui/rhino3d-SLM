{
  "source_url": "https://github.com/livestock3d/livestock_gh/blob/97309ebe4bff2c00ae6ce3a44d5b01e2e433ea6c/python/lib/geometry.py",
  "repo": "livestock3d/livestock_gh",
  "repo_stars": 8,
  "repo_description": "Livestock is a plugin/library for Grasshopper",
  "license": "LGPL-3.0",
  "filepath": "python/lib/geometry.py",
  "instruction": "Geometry",
  "code": "__author__ = \"Christian Kongsgaard\"\n__license__ = \"GNU GPLv3\"\n\n# -------------------------------------------------------------------------------------------------------------------- #\n# Imports\n\n# Module imports\nimport os\nimport json\n\n# Livestock imports\n\n# Grasshopper imports\nimport Rhino.Geometry as rg\nimport scriptcontext as sc\nimport rhinoscriptsyntax as rs\nimport Rhino as rc\nfrom System.Threading.Tasks.Parallel import ForEach\nfrom Rhino.Geometry.Brep import JoinBreps\n\n# -------------------------------------------------------------------------------------------------------------------- #\n# Livestock Grasshopper Geometry Classes and Functions\n\n\ndef obj_export(mesh, file_path):\n\n    if not file_path.endswith('.obj'):\n        file_path = file_path + '.obj'\n\n    with open(file_path, 'w') as file_obj:\n        file_obj.write('# Livestock OBJ exporter\\n')\n        for vert in rs.MeshVertices(mesh):\n            file_obj.write('v ' + str(vert.X) + ' ' + str(vert.Y) + ' ' + str(vert.Z) + '\\n')\n        for fvert in rs.MeshFaceVertices(mesh):\n            if len(fvert) == 3:\n                file_obj.write('f ' + str(fvert[0] + 1) + ' ' + str(fvert[1] + 1) + ' ' + str(fvert[2] + 1) + '\\n')\n            elif len(fvert) == 4:\n                file_obj.write(\n                    'f ' + str(fvert[0] + 1) + ' ' + str(fvert[1] + 1) + ' ' + str(fvert[2] + 1) + ' ' +\n                    str(fvert[3] + 1) + '\\n')\n\n\ndef bake(geo, doc):\n    \"\"\"\n    Bakes geometry from Grasshopper\n\n    :param geo: Geometry to bake\n    :param doc: Grasshopper doc\n    :return: Rhino ID\n    \"\"\"\n\n    # we create or use some geometry\n    geo_id = geo\n\n    # we obtain the reference in the Rhino doc\n    sc.doc = doc\n    doc_object = rs.coercerhinoobject(geo_id)\n\n    attributes = doc_object.Attributes\n    geometry = doc_object.Geometry\n\n    # we change the scriptcontext\n    sc.doc = rc.RhinoDoc.ActiveDoc\n\n    # we add both the geometry and the attributes to the Rhino doc\n    rhino_line = sc.doc.Objects.Add(geometry, attributes)\n\n    # we put back the original Grasshopper document as default\n    sc.doc = doc\n    return rhino_line\n\n\ndef export(ids, file_path, file_name, file_type, doc):\n    \"\"\"\n    Exports Rhino geometry to a file.\n\n    :param ids: Geometry ID\n    :param file_path: File directory\n    :param file_name: File name\n    :param file_type: File extension\n    :param doc: Grasshopper document\n    :return: True on success.\n    \"\"\"\n\n    sel_ids = \"\"\n    for i in range(len(ids)):\n        sel_ids += \"_SelId %s \" % ids[i]\n\n    file_name_and_type = file_name + file_type\n    final_path = chr(34) + file_path + '\\\\' + file_name_and_type + chr(34)\n\n    command_string = \"_-Export \" + sel_ids + \"_Enter \" + final_path + \\\n                     \" _Enter _Enter _Enter\"\n    echo = False\n    done = rs.Command(command_string, echo)\n\n    sc.doc = rc.RhinoDoc.ActiveDoc\n    rs.SelectObject(ids)\n    rs.Command(\"_Delete\", True)\n    sc.doc = doc\n\n    if done:\n        return True\n    else:\n        return False\n\n\ndef bake_export_delete(geo, file_path, file_name, file_type, doc):\n    \"\"\"\n    Bakes and exports Grasshopper geometry.\n\n    :param geo: Grasshopper geometry.\n    :param file_path: File directory\n    :param file_name: File name\n    :param file_type: File extension.\n    :param doc: Grasshopper document\n    \"\"\"\n\n    g = bake(geo, doc)\n    export([g, ], file_path, file_name, file_type, doc)\n\n\ndef import_obj(path):\n    \"\"\"\n    Reads a .obj file and converts it into a Rhino Mesh.\n\n    :param path: path including file name and file extension (.obj)\n    :return: Rhino Mesh\n    \"\"\"\n\n    # Initialize mesh\n    mesh = rg.Mesh()\n\n    # Open File\n    file_ = open(path)\n    lines = file_.readlines()\n    file_.close()\n\n    for line in lines:\n        if line.find(\"v\") == 0 and line.find(\"n\") == -1 and line.find(\n                \"t\") == -1:\n            mesh.Vertices.Add(rg.Point3d(float((line.split(' '))[1]),\n                                         float((line.split(' '))[2]),\n                                         float((line.split(' '))[3])))\n        if line.find(\"f\") == 0:\n            if len(line.split(' ')) == 4:\n                mesh.Faces.AddFace(\n                    rg.MeshFace(int(line.split(' ')[1].split('/')[0]) - 1,\n                                int(line.split(' ')[2].split('/')[0]) - 1,\n                                int(line.split(' ')[3].split('/')[0]) - 1))\n\n            elif len(line.split(' ')) == 5:\n                mesh.Faces.AddFace(\n                    rg.MeshFace(int(line.split(' ')[1].split('/')[0]) - 1,\n                                int(line.split(' ')[2].split('/')[0]) - 1,\n                                int(line.split(' ')[3].split('/')[0]) - 1,\n                                int(line.split(' ')[4].split('/')[0]) - 1))\n\n    mesh.Normals.ComputeNormals()\n    mesh.Compact()\n\n    return mesh\n\n\ndef load_points(point_file):\n    \"\"\"\n    Loads a text file containing points\n\n    :param point_file: Path to the points file.\n    :type point_file: str\n    :return: List of Rhino 3D points\n    :rtype: list\n    \"\"\"\n\n    points = []\n    with open(point_file) as file:\n        raw_pts = json.load(file)\n\n    for line in raw_pts:\n        points.append([rg.Point3d(float(pt[0]), float(pt[1]), float(pt[2]))\n                       for pt in line])\n\n    return points\n\n\ndef make_curves_from_points(points):\n    \"\"\"Converts a list of points to a 5-degree polynomial curve.\"\"\"\n\n    curves = []\n    end_points = []\n\n    for pts in points:\n        if len(pts) == 1:\n            end_points.append(pts[0])\n        else:\n            crv = rg.Curve.CreateControlPointCurve(pts, 5)\n            if crv:\n                curves.append(crv)\n                end_points.append(pts[-1])\n\n    return curves, end_points\n\n\ndef parallel_make_context_mesh(brep, parallel=False):\n    #\"\"\"Ladybug - mesh breps parallel\"\"\"\n\n    def make_mesh_from_srf(i):\n        try:\n            mesh[i] = rc.Mesh.CreateFromBrep(brep[i], mesh_param)\n            brep[i].Dispose()\n        except:\n            print('Error in converting Brep to Mesh...')\n            pass\n\n    # prepare bulk list for each surface\n    mesh = [None] * len(brep)\n\n    # set-up mesh parameters for each surface based on surface size\n    mesh_param = rc.MeshingParameters.Default  # Coarse\n    rc.MeshingParameters.GridMaxCount.__set__(mesh_param, 1)\n    rc.MeshingParameters.SimplePlanes.__set__(mesh_param, True)\n    rc.MeshingParameters.GridAmplification.__set__(mesh_param, 1.5)\n\n    # Call the mesh function\n    if parallel:\n        ForEach(xrange(len(brep)), make_mesh_from_srf)\n    else:\n        for i in range(len(mesh)):\n            make_mesh_from_srf(i)\n\n    return mesh\n\n\ndef clean_and_coerce_list(brep_list):\n    #\"\"\" Ladybug - This definition cleans the list and adds them to RhinoCommon\"\"\"\n\n    outputMesh = []\n    outputBrep = []\n\n    for id in brep_list:\n        if rs.IsMesh(id):\n            geo = rs.coercemesh(id)\n            if geo is not None:\n                outputMesh.append(geo)\n                try:\n                    rs.DeleteObject(id)\n                except:\n                    pass\n\n        elif rs.IsBrep(id):\n            geo = rs.coercebrep(id)\n            if geo is not None:\n                outputBrep.append(geo)\n                try:\n                    rs.DeleteObject(id)\n                except:\n                    pass\n\n            else:\n                # the idea was to remove the problematice surfaces\n                # not all the geometry which is not possible since\n                # badGeometries won't pass rs.IsBrep()\n                tempBrep = []\n                surfaces = rs.ExplodePolysurfaces(id)\n\n                for surface in surfaces:\n                    geo = rs.coercesurface(surface)\n                    if geo is not None:\n                        tempBrep.append(geo)\n                        try:\n                            rs.DeleteObject(surface)\n                        except:\n                            pass\n\n                geo = JoinBreps(tempBrep, 0.01)\n\n                for Brep in tempBrep:\n                    Brep.Dispose()\n                    try:\n                        rs.DeleteObject(id)\n                    except:\n                        pass\n                outputBrep.append(geo)\n\n    return outputMesh, outputBrep\n\n\ndef join_mesh(mesh_list):\n    #\"\"\"Ladybug - joinMesh\"\"\"\n\n    joined_mesh = rg.Mesh()\n    for m in mesh_list: joined_mesh.Append(m)\n\n    return joined_mesh\n\n\ndef rayTrace(startPts, startVectors, context, numOfBounce, lastBounceLen):\n    #\"\"\"Ladybug - RayTrace\"\"\"\n\n    # A failed attampt to use mesh instead of brep so the component could work with trimmed surfaces\n    if len(context) != 0:\n        ## clean the geometry and bring them to rhinoCommon separated as mesh and Brep\n        contextMesh, contextBrep = clean_and_coerce_list(context)\n        ## mesh Brep\n        contextMeshedBrep = parallel_make_context_mesh(contextBrep)\n\n        ## Flatten the list of surfaces\n        contextMeshedBrep = flatten_list(contextMeshedBrep)\n        contextSrfs = contextMesh + contextMeshedBrep\n        joinedContext = join_mesh(contextSrfs)\n\n    # Get rid of trimmed parts\n    cleanBrep = rg.Brep.CreateFromMesh(joinedContext, False)\n\n    rays = []\n    for testPt in startPts:\n        for vector in startVectors:\n            vector.Unitize()\n            ray = rg.Ray3d(testPt, vector)\n            if numOfBounce > 0:\n                intPts = rc.Intersect.Intersection.RayShoot(ray, [cleanBrep], numOfBounce)\n                # print intPts\n                if intPts:\n                    ptList = [testPt]\n                    ptList.extend(intPts)\n                    ray = rc.Polyline(ptList).ToNurbsCurve()\n\n                    try:\n                        # create last ray\n                        # calculate plane at intersection\n                        intNormal = cleanBrep.ClosestPoint(intPts[-1], sc.doc.ModelAbsoluteTolerance)[5]\n\n                        lastVector = rc.Vector3d(ptList[-2] - ptList[-1])\n                        lastVector.Unitize()\n\n                        crossProductNormal = rc.Vector3d.CrossProduct(intNormal, lastVector)\n\n                        plane = rc.Plane(intPts[-1], intNormal, crossProductNormal)\n\n                        mirrorT = rc.Transform.Mirror(intPts[-1], plane.Normal)\n\n                        lastRay = rc.Line(intPts[-1], lastBounceLen * lastVector).ToNurbsCurve()\n                        lastRay.Transform(mirrorT)\n\n                        ray = rc.Curve.JoinCurves([ray, lastRay])[0]\n                    except:\n                        pass\n\n                    rays.append(ray)\n                else:\n                    # no bounce so let's just create a line form the point\n                    firstRay = rc.Line(testPt, lastBounceLen * vector).ToNurbsCurve()\n                    rays.append(firstRay)\n\n    if len(rays) == 0:\n        print(\"No reflection!\")\n        return False\n\n    return rays\n\n\ndef ray_shoot(start_pt, vector, context, num_of_bounce=1):\n    #\"\"\"Build on: Ladybug - RayTrace\"\"\"\n\n    ray = rg.Ray3d(start_pt, vector)\n    print('ray', ray)\n\n    if num_of_bounce > 0:\n        int_pt = rg.RayShoot(ray, [context], num_of_bounce)\n        print('intPt:', int_pt)\n\n        if int_pt:\n            print('Intersection!')\n            return True\n        else:\n            print('No intersection!')\n            return False\n\n    else:\n        print(\"No reflection!\")\n        return False\n\n\ndef load_mesh_data(path):\n    \"\"\"\n    Load additional data for a mesh.\n\n    :param path: Path for mesh file.\n    :return: Data from the mesh\n    \"\"\"\n\n    path = path.split('.')[0] + '_Data.txt'\n\n    # Check if file exists\n    exists = os.path.isfile(path)\n    if exists:\n        data = []\n        file_obj = open(path, 'r')\n        lines = file_obj.readlines()\n        for l in lines:\n            data.append(l[:-1])\n\n        print('Mesh loaded with data')\n        return data\n\n    else:\n        print(\"Mesh don't have any associated data\")\n\n\ndef get_mesh_faces(mesh):\n    \"\"\"\n    Takes a mesh and convert its faces into individual meshes.\n\n    :param mesh: mesh\n    :return: list of \"face\" meshes\n    \"\"\"\n\n    mesh_faces = rs.MeshFaces(mesh)\n    faces = []\n\n    for i in range(0, len(mesh_faces), 4):\n        vertices = [mesh_faces[i], mesh_faces[i + 1], mesh_faces[i + 2], mesh_faces[i + 3]]\n        added_mesh = rs.AddMesh(vertices, [[0, 1, 2, 3]])\n        faces.append(added_mesh)\n\n    return faces\n\n\ndef convert_file_to_points(csv_file):\n    point_list = []\n    for line_ in csv_file:\n        point_list.append(convert_line_to_points(line_))\n\n    return point_list\n\n\ndef convert_line_to_points(line_):\n    points_ = []\n    for element in line_:\n        x, y, z = element.split(' ')\n        points_.append(rg.Point3d(float(x), float(y), float(z)))\n\n    return points_\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}