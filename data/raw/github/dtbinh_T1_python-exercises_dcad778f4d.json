{
  "source_url": "https://github.com/dtbinh/T1_python-exercises/blob/f4710c3dc2ba8ddb3e3e9069ab8d65df674463ab/07_ur_online/shifted_frames_setup/compas/__debugging/meshing_of_architectural_surfaces_in_rhino/relax_on_surface.py",
  "repo": "dtbinh/T1_python-exercises",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "07_ur_online/shifted_frames_setup/compas/__debugging/meshing_of_architectural_surfaces_in_rhino/relax_on_surface.py",
  "instruction": "Relax on surface",
  "code": "__author__     = ['Matthias Rippmann <rippmann@ethz.ch>', ]\n__copyright__  = 'Copyright 2016, Block Research Group - ETH Zurich'\n__license__    = 'MIT License'\n__version__    = '0.1'\n__date__       = 'Nov 11, 2016'\n\n\nimport time\nimport rhinoscriptsyntax as rs  \nimport math\nimport copy\nimport Rhino\nfrom compas.datastructures.mesh.mesh import Mesh\nfrom compas.geometry.functions import centroid\nfrom compas.geometry.functions import distance\nfrom compas.geometry.functions import midpoint\n\n\nfrom compas.geometry.arithmetic import add_vectors\nfrom compas.geometry.arithmetic import subtract_vectors\n\nfrom compas.geometry.transformations import normalize\nfrom compas.geometry.transformations import scale\nfrom compas.utilities.colors import i2rgb\nfrom compas.geometry.spatial import closest_point_on_plane\n\nimport compas_rhino.utilities as rhino\nfrom compas.datastructures.mesh.algorithms.smoothing import mesh_smooth_centerofmass\nfrom compas.datastructures.mesh.algorithms.smoothing import mesh_smooth_angle\nfrom compas.datastructures.mesh.algorithms.smoothing import mesh_smooth_centroid\nfrom compas.datastructures.mesh.algorithms.smoothing import  mesh_smooth_area\n\n\nfrom compas.datastructures.mesh.algorithms.orientation import mesh_unify_cycle_directions\n\nfrom compas_rhino.conduits.lines import LinesConduit\n\n#import utility as rhutil\nimport Rhino\nimport scriptcontext\n\n\n\n\n\ndef get_faces_from_polylines(polys,points):\n    faces = []\n    for key in polys:\n        poly_points = polys[key]['points']\n        indices = []\n        for point in poly_points:\n            indices.append(str(rs.PointArrayClosestPoint(points,point)))\n        faces.append(indices)\n    return faces\n\n\n\ndef get_points_coordinates(objs):\n    return [rs.PointCoordinates(obj) for obj in objs]\n\n\ndef get_polyline_points(polylines):\n    polys = {}\n    for key,id in enumerate(polylines):\n        polys[key] = {}\n        if not rs.IsCurveClosed(id):\n            print str(id) + \" is an open curve\"\n            rs.MessageBox(str(id) + \" is an open curve\")\n            return None\n        polys[key]['points'] = rs.PolylineVertices(id)[:-1]\n        polys[key]['id'] = id\n    return polys\n\n\ndef draw_light(mesh,temp = True):\n    key_index = dict((key, index) for index, key in mesh.vertices_enum())\n    xyz = mesh.xyz\n    faces = []\n    \n    for fkey in mesh.faces_iter():\n        face = mesh.face_vertices(fkey,True)\n        \n        \n        #poly_pts = [xyz[key_index[k]] for k in face+[face[0]]]\n        \n        face.append(face[-1])\n        faces.append([key_index[k] for k in face])\n        \n        \n    \n        #rs.AddPolyline(poly_pts)\n        \n    guid = rs.AddMesh(xyz, faces) \n    if temp:\n        rs.EnableRedraw(True)\n        rs.EnableRedraw(False)\n        rs.DeleteObject(guid)\n    return guid \n\ndef draw(mesh,layer_1,layer_2):\n    \n    rs.EnableRedraw(False)\n    \n    rs.LayerVisible(layer_1, True)\n    rs.LayerVisible(layer_2, True)\n\n    objs = rs.ObjectsByLayer(layer_1)\n    rs.DeleteObjects(objs)\n    objs = rs.ObjectsByLayer(layer_2)\n    rs.DeleteObjects(objs)    \n    \n    pts_objs = []\n    for key, a in mesh.vertices_iter(True):\n    \n       pt = (a['x'], a['y'], a['z'])\n       \n       pts_objs.append(rs.AddPoint(pt))\n       rs.ObjectColor(pts_objs[-1],a['color'] )\n       \n    rs.ObjectLayer(pts_objs,layer_1)\n        \n        \n    key_index = dict((key, index) for index, key in mesh.vertices_enum())\n    xyz = mesh.xyz    \n    polylines = []\n    for fkey in mesh.faces_iter():\n        face = mesh.face_vertices(fkey,True)\n        \n        \n        poly_pts = [xyz[key_index[k]] for k in face+[face[0]]]\n        polylines.append(rs.AddPolyline(poly_pts))\n        \n    rs.ObjectLayer(polylines,layer_2)\n    \n        \n        \n\n    rs.EnableRedraw(True)\n       \n\n\n\n\ndef wrapper(vis):\n    \n    def user_function(mesh,i):\n     \n        for key, a in mesh.vertices_iter(True):\n        \n           pt = (a['x'], a['y'], a['z'])\n           \n           if a['type'] == 'fixed' or a['type'] == 'free':\n               continue\n           if a['type'] == 'guide':\n               point = rs.coerce3dpoint(pt)\n               rc, t = a['guide_crv'].ClosestPoint(point)\n               pt = a['guide_crv'].PointAt(t)\n           elif a['type'] == 'surface':\n               point = rs.coerce3dpoint(pt)\n               pt = a['guide_srf'].ClosestPoint(point)\n            \n           mesh.vertex[key]['x'] = pt[0]\n           mesh.vertex[key]['y'] = pt[1]\n           mesh.vertex[key]['z'] = pt[2]    \n        \n        \n        if vis:\n            if i%vis==0:\n                rs.Prompt(str(i))\n                draw_light(mesh,temp = True) \n                Rhino.RhinoApp.Wait()\n\n    return user_function\n\n\ndef relax_mesh_on_surface():\n    \n    srf = rs.ObjectsByLayer(\"re_01_trg_srf\")[0]\n    srf_id = rs.coerceguid(srf, True)\n    brep = rs.coercebrep(srf_id, False)\n    \n    polylines = rs.ObjectsByLayer(\"re_02_polys\")\n    pts_objs = rs.ObjectsByLayer(\"re_03_points\")\n    guides = rs.ObjectsByLayer(\"re_04_guides\")\n    \n    vis = 1\n    \n    rs.LayerVisible(\"re_02_polys\", False)\n    rs.LayerVisible(\"re_03_points\", False)\n    \n    pts = get_points_coordinates(pts_objs)\n    \n    mesh = Mesh()\n    \n    for i,pt in enumerate(pts):\n        color = rs.ObjectColor(pts_objs[i])\n        type, guide_srf,guide_crv = None, None, None\n\n        if [rs.ColorRedValue(color),rs.ColorGreenValue(color),rs.ColorBlueValue(color)] == [255,0,0]:\n            type = 'fixed'\n        elif [rs.ColorRedValue(color),rs.ColorGreenValue(color),rs.ColorBlueValue(color)] == [255,255,255]:\n            type = 'free'\n        elif [rs.ColorRedValue(color),rs.ColorGreenValue(color),rs.ColorBlueValue(color)] == [0,0,0]:\n            type = 'surface'\n            guide_srf = brep\n        else:\n            type = 'guide'\n            for guide in guides:\n                if rs.ObjectColor(guide) == color:\n                    crv_id = rs.coerceguid(guide, True)\n                    crv = rs.coercecurve(crv_id, False)\n                    guide_crv = crv\n                    break       \n            \n        mesh.add_vertex(str(i),{'x' : pt[0], 'y' : pt[1], 'z' : pt[2], 'color' : color, 'type' : type,'guide_srf' : guide_srf,'guide_crv' : guide_crv})\n    \n\n    \n    polys = get_polyline_points(polylines)\n    tris = get_faces_from_polylines(polys,pts)\n    \n    for tri in tris:\n        mesh.add_face(tri)     \n     \n     \n        \n    user_function = wrapper(vis)    \n    fixed = [key for key, a in mesh.vertices_iter(True) if a['type'] == 'fixed']\n    \n    mesh_smooth_centerofmass(mesh, fixed=fixed, kmax=150, d=1.0, ufunc=user_function)\n    \n    #mesh_smooth_angle(mesh, fixed=fixed, kmax=150, ufunc=user_function)\n    \n    #mesh_smooth_centroid(mesh, fixed=fixed, kmax=150, d=1.0, ufunc=user_function)\n    \n    #mesh_smooth_area(mesh, fixed=fixed, kmax=150, d=1.0, ufunc=user_function)\n    \n    \n    #draw_light(mesh,temp = False)\n    \n    draw(mesh,\"re_03_points\",\"re_02_polys\")\n    \n\nif __name__ == \"__main__\":\n    \n    \n    relax_mesh_on_surface()",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}