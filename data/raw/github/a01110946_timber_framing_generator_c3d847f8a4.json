{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/src/timber_framing_generator/wall_data/revit_data_extractor.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "src/timber_framing_generator/wall_data/revit_data_extractor.py",
  "instruction": "File: src/wall_data/revit_data_extractor.py",
  "code": "# File: src/wall_data/revit_data_extractor.py\n\nfrom typing import List, Dict, Union\nimport logging\n\nfrom src.timber_framing_generator.utils.safe_rhino import safe_closest_point\nfrom Autodesk.Revit import DB\nimport Rhino.Geometry as rg\nimport RhinoInside.Revit.Convert.Geometry as Geometry\n\nfrom src.timber_framing_generator.wall_data.wall_helpers import (\n    compute_wall_base_elevation,\n    get_wall_base_curve,\n    get_wall_base_plane,\n)\nfrom src.timber_framing_generator.cell_decomposition.cell_segmentation import decompose_wall_to_cells\nfrom src.timber_framing_generator.cell_decomposition.cell_types import deconstruct_all_cells\nfrom src.timber_framing_generator.utils.geometry_helpers import curve_length\nfrom src.timber_framing_generator.utils.safe_rhino import safe_closest_point\n\nlogger = logging.getLogger(__name__)\n\nWallInputData = Dict[\n    str, Union[rg.Curve, float, bool, List[Dict[str, Union[str, float]]], rg.Plane]\n]\n\n\ndef _get_opening_dimension(element, symbol, param_names: List[str]) -> float:\n    \"\"\"\n    Try multiple parameter names to get an opening dimension.\n\n    Checks in order:\n    1. Named parameters on instance\n    2. Named parameters on symbol (type)\n\n    Args:\n        element: The FamilyInstance (door/window)\n        symbol: The FamilySymbol (type)\n        param_names: List of parameter names to try (e.g., [\"Rough Width\", \"Width\"])\n\n    Returns:\n        The dimension value, or 0.0 if not found\n    \"\"\"\n    # Try instance parameters first\n    for name in param_names:\n        try:\n            param = element.LookupParameter(name)\n            if param and param.HasValue:\n                value = param.AsDouble()\n                if value > 0:\n                    print(f\"    Found {name} on instance: {value}\")\n                    return value\n        except Exception as e:\n            print(f\"    Error reading instance param '{name}': {e}\")\n\n    # Try type (symbol) parameters\n    for name in param_names:\n        try:\n            param = symbol.LookupParameter(name)\n            if param and param.HasValue:\n                value = param.AsDouble()\n                if value > 0:\n                    print(f\"    Found {name} on type: {value}\")\n                    return value\n        except Exception as e:\n            print(f\"    Error reading type param '{name}': {e}\")\n\n    return 0.0\n\ndef extract_wall_data_from_revit(revit_wall: DB.Wall, doc) -> WallInputData:\n    \"\"\"\n    Extracts timber framing data from a Revit wall, decomposes the wall into cells,\n    and returns a dictionary with wall geometry, openings, and cell data.\n    \"\"\"\n    try:\n        print(f\"Extracting wall data from Revit wall: {revit_wall.Id}\")\n        # 1. Compute the wall base curve.\n        wall_base_curve_rhino = get_wall_base_curve(revit_wall)\n        if wall_base_curve_rhino is None:\n            print(f\"Failed to extract wall base curve from Revit wall: {revit_wall.Id}\")\n            return None\n        else:\n            print(f\"Wall base curve extracted successfully for Revit wall: {revit_wall.Id}\")\n\n        # 2. Compute the wall base elevation (using our helper).\n        wall_base_elevation = compute_wall_base_elevation(revit_wall, doc)\n        print(f\"Wall base elevation computed: {wall_base_elevation}\")\n        print(f\"Type of Wall base elevation computed: {type(wall_base_elevation)}\")\n        if wall_base_elevation is None:\n            print(f\"Failed to compute wall base elevation for Revit wall: {revit_wall.Id}\")\n            return None\n        else:\n            print(f\"Wall base elevation computed successfully for Revit wall: {revit_wall.Id}\")\n\n        # 3. Get Base and Top Elevations:\n        base_level_param = revit_wall.get_Parameter(\n            DB.BuiltInParameter.WALL_BASE_CONSTRAINT\n        )\n        base_offset_param = revit_wall.get_Parameter(DB.BuiltInParameter.WALL_BASE_OFFSET)\n        top_level_param = revit_wall.get_Parameter(DB.BuiltInParameter.WALL_HEIGHT_TYPE)\n        top_offset_param = revit_wall.get_Parameter(DB.BuiltInParameter.WALL_TOP_OFFSET)\n        if base_level_param is None or top_level_param is None:\n            print(f\"Failed to extract base or top level parameters from Revit wall: {revit_wall.Id}\")\n            return None\n        else:\n            print(f\"Base and top level parameters extracted successfully for Revit wall: {revit_wall.Id}\")\n\n        # Get base level and offset (unchanged)\n        base_level = (\n            doc.GetElement(base_level_param.AsElementId())\n            if base_level_param\n            and base_level_param.AsElementId() != DB.ElementId.InvalidElementId\n            else None\n        )\n        print(f\"Base level computed: {base_level}\")\n        if base_level is None:\n            print(f\"Failed to extract base level from Revit wall: {revit_wall.Id}\")\n            return None\n        base_offset = base_offset_param.AsDouble() if base_offset_param else 0.0\n        print(f\"Base offset computed: {base_offset}\")\n\n        # Get top level and offset - NEW CODE: Fallback to unconnected height\n        top_level = (\n            doc.GetElement(top_level_param.AsElementId())\n            if top_level_param\n            and top_level_param.AsElementId() != DB.ElementId.InvalidElementId\n            else None\n        )\n        print(f\"Top level computed: {top_level}\")\n\n        # Instead of returning None, use unconnected height if available\n        if top_level is None:\n            print(f\"No top level constraint for wall: {revit_wall.Id}, checking unconnected height...\")\n            # Try to get the unconnected height parameter\n            unconnected_height_param = revit_wall.LookupParameter(\"Unconnected Height\")\n            \n            if unconnected_height_param and unconnected_height_param.HasValue:\n                unconnected_height = unconnected_height_param.AsDouble()\n                print(f\"Using unconnected height: {unconnected_height}\")\n                wall_top_elevation = wall_base_elevation + unconnected_height\n                print(f\"Calculated top elevation from unconnected height: {wall_top_elevation}\")\n                # Continue processing with the calculated top elevation\n                top_offset = 0.0  # No offset when using unconnected height\n            else:\n                print(f\"No top level constraint or unconnected height found for wall: {revit_wall.Id}\")\n                return None\n        else:\n            # Original code for top level offset\n            top_offset = top_offset_param.AsDouble() if top_offset_param else 0.0\n            # Calculate wall_top_elevation\n            wall_top_elevation = top_level.Elevation + top_offset\n\n        # NOTE: \"Top is Attached\" walls have geometry cut by floors/roofs\n        # but Revit's bounding box and solid geometry don't always reflect this accurately\n        # For now, we use level-based elevation. A future improvement could check\n        # the attached floor's bottom elevation directly.\n\n        # 4. Determine if the wall is exterior.\n        wall_type = revit_wall.WallType\n        wall_function_param = wall_type.get_Parameter(DB.BuiltInParameter.FUNCTION_PARAM)\n        is_exterior_wall = wall_function_param and (wall_function_param.AsInteger() == 1)\n\n        # 4a. Get wall flip state.\n        # When Flipped=True, the exterior face is on the negative Z-axis side\n        # (opposite to the default cross(curve_direction, world_Z) direction).\n        is_flipped = bool(revit_wall.Flipped)\n\n        # 4a-ii. Store wall.Orientation as the geometric exterior normal.\n        # wall.Orientation = cross(curve_tangent, world_Z) â€” purely geometric,\n        # does NOT change when wall.Flipped=True.\n        # The flip correction (negating when Flipped=True) is applied in the\n        # Wall Analyzer GH component (gh_wall_analyzer.py) to avoid module\n        # cache issues with this imported module.\n        orientation = revit_wall.Orientation\n        exterior_normal = {\n            \"x\": float(orientation.X),\n            \"y\": float(orientation.Y),\n            \"z\": float(orientation.Z),\n        }\n\n        # 4b. Determine if the wall is load-bearing.\n        # WALL_STRUCTURAL_USAGE_PARAM values:\n        # 0 = Non-bearing, 1 = Bearing, 2 = Shear, 3 = Structural Combined\n        structural_usage_param = revit_wall.get_Parameter(DB.BuiltInParameter.WALL_STRUCTURAL_USAGE_PARAM)\n        is_load_bearing = False\n        if structural_usage_param and structural_usage_param.HasValue:\n            usage_value = structural_usage_param.AsInteger()\n            # Values 1 (Bearing), 2 (Shear), 3 (Combined) are structural/load-bearing\n            is_load_bearing = usage_value >= 1\n\n        # 5. Get openings.\n        openings_data: List[Dict[str, Union[str, float]]] = []\n        print(f\"Wall {revit_wall.Id} has {len(revit_wall.FindInserts(True, False, True, True))} openings\")\n        insert_ids = revit_wall.FindInserts(True, False, True, True)\n        print(f\"Wall {revit_wall.Id} has {len(insert_ids)} inserts\")\n        for insert_id in insert_ids:\n            insert_element = revit_wall.Document.GetElement(insert_id)\n            if isinstance(insert_element, DB.FamilyInstance):\n                if not (insert_element.Category and insert_element.Category.Name):\n                    continue\n                category_name = insert_element.Category.Name\n                if category_name == \"Doors\":\n                    opening_type = \"door\"\n                elif category_name == \"Windows\":\n                    opening_type = \"window\"\n                else:\n                    continue\n                print(f\"Opening {insert_id} is {opening_type}\")\n\n                family_symbol = insert_element.Symbol\n\n                # Try multiple parameter names for width/height\n                # Different Revit families use different names\n                width_param_names = [\n                    \"Rough Width\", \"Width\", \"Default Width\", \"Frame Width\",\n                    \"Opening Width\", \"Clear Width\", \"Nominal Width\"\n                ]\n                height_param_names = [\n                    \"Rough Height\", \"Height\", \"Default Height\", \"Frame Height\",\n                    \"Opening Height\", \"Clear Height\", \"Nominal Height\"\n                ]\n\n                # Get dimensions using helper function with fallbacks\n                opening_width_value = _get_opening_dimension(\n                    insert_element, family_symbol, width_param_names\n                )\n                opening_height_value = _get_opening_dimension(\n                    insert_element, family_symbol, height_param_names\n                )\n\n                print(f\"Opening {insert_id} - width={opening_width_value}, height={opening_height_value}\")\n\n                # If standard parameters failed, try to get dimensions from the opening cut\n                if opening_width_value <= 0 or opening_height_value <= 0:\n                    print(f\"  WARNING: Could not find dimensions via parameters, trying opening cut...\")\n                    try:\n                        # Get the opening cut from the wall\n                        opening_cut = insert_element.GetSubComponentIds()\n                        bbox = insert_element.get_BoundingBox(None)\n                        if bbox:\n                            # Use bounding box as fallback (less accurate but better than nothing)\n                            if opening_width_value <= 0:\n                                # Width is typically along X or Y depending on wall orientation\n                                dx = abs(bbox.Max.X - bbox.Min.X)\n                                dy = abs(bbox.Max.Y - bbox.Min.Y)\n                                opening_width_value = max(dx, dy)  # Use larger dimension as width\n                            if opening_height_value <= 0:\n                                opening_height_value = abs(bbox.Max.Z - bbox.Min.Z)\n                            print(f\"  Using bounding box fallback: width={opening_width_value}, height={opening_height_value}\")\n                    except Exception as bbox_err:\n                        print(f\"  Failed to get bounding box: {bbox_err}\")\n\n                # Get sill height parameter\n                sill_height_param = insert_element.LookupParameter(\"Sill Height\")\n                sill_height_builtin = None\n                try:\n                    sill_height_builtin = insert_element.get_Parameter(DB.BuiltInParameter.INSTANCE_SILL_HEIGHT_PARAM)\n                    if sill_height_builtin:\n                        print(f\"  Built-in INSTANCE_SILL_HEIGHT_PARAM value: {sill_height_builtin.AsDouble()}\")\n                except Exception as e:\n                    print(f\"  Could not get INSTANCE_SILL_HEIGHT_PARAM: {e}\")\n\n                # Get sill height value (raw)\n                sill_height_value_raw = 0.0\n                try:\n                    if sill_height_builtin and sill_height_builtin.HasValue:\n                        sill_height_value_raw = sill_height_builtin.AsDouble()\n                    elif sill_height_param and sill_height_param.HasValue:\n                        sill_height_value_raw = sill_height_param.AsDouble()\n                except Exception as e:\n                    print(f\"  Error getting sill height: {e}\")\n\n                # Only process if we have valid dimensions\n                if opening_width_value > 0 and opening_height_value > 0:\n\n                    opening_location_point = insert_element.Location.Point\n                    opening_location_point_rhino = rg.Point3d(\n                        opening_location_point.X,\n                        opening_location_point.Y,\n                        opening_location_point.Z,\n                    )\n\n                    # FIX: Use built-in parameter as primary source, it's more reliable\n                    # The INSTANCE_SILL_HEIGHT_PARAM is specifically designed for this purpose\n                    sill_height_value = None\n\n                    if sill_height_builtin and sill_height_builtin.HasValue:\n                        sill_height_value = sill_height_builtin.AsDouble()\n                    elif sill_height_param and sill_height_param.HasValue:\n                        sill_height_value = sill_height_value_raw\n\n                    # If parameter values are negative or None, calculate from geometry\n                    # Calculate sill as: opening_bottom_Z - wall_base_elevation\n                    # where opening_bottom_Z = opening_center_Z - half_height\n                    # BUT: Some families have location point at sill, some at center\n                    # We need to detect which case we're in\n\n                    # Calculate what sill would be if location point is at CENTER\n                    sill_from_center = opening_location_point.Z - (opening_height_value / 2.0) - wall_base_elevation\n                    # Calculate what sill would be if location point is at SILL\n                    sill_from_sill_point = opening_location_point.Z - wall_base_elevation\n\n                    # If we got a parameter value, use it but validate\n                    if sill_height_value is not None and sill_height_value >= 0:\n                        # Check if calculated values are close to parameter\n                        # This helps verify the parameter is correct\n                        diff_from_center = abs(sill_height_value - sill_from_center)\n                        diff_from_sill = abs(sill_height_value - sill_from_sill_point)\n\n                        # If parameter doesn't match either calculation within tolerance,\n                        # prefer the sill-point calculation (more common in Revit families)\n                        if diff_from_center > 1.0 and diff_from_sill > 1.0:\n                            sill_height_value = sill_from_sill_point\n                    else:\n                        # No valid parameter, use sill-point calculation\n                        # (assumes location point is at sill, which is common)\n                        sill_height_value = sill_from_sill_point\n\n                    # Final sanity check: sill should be >= 0 and < wall_height\n                    wall_height = wall_top_elevation - wall_base_elevation\n                    if sill_height_value < 0:\n                        sill_height_value = 0.0\n                    elif sill_height_value >= wall_height:\n                        sill_height_value = wall_height - opening_height_value\n\n                    try:\n                        # Try to use ClosestPoint directly if available\n                        success, t = safe_closest_point(wall_base_curve_rhino, opening_location_point_rhino)\n                    except AttributeError:\n                        # Fallback for LineCurve\n                        if isinstance(wall_base_curve_rhino, rg.LineCurve):\n                            # Get the underlying Line\n                            line = wall_base_curve_rhino.Line\n\n                            # Use the Line to find the closest point\n                            t = line.ClosestParameter(opening_location_point_rhino)\n\n                            # Calculate the relative parameter on the curve (0-1)\n                            t_normalized = t / wall_base_curve_rhino.GetLength()\n\n                            success = True\n                            t = t_normalized\n                        else:\n                            # Another approach: convert to NurbsCurve which should have ClosestPoint\n                            nurbs_curve = wall_base_curve_rhino.ToNurbsCurve()\n                            success, t = nurbs_curve.ClosestPoint(opening_location_point_rhino)\n\n                    print(f\"Opening {insert_id} has t (normalized 0-1): {t}\")\n\n                    # BUG FIX: t is a normalized parameter (0-1), not an absolute coordinate\n                    # We need to convert it to absolute distance along the wall\n                    # Use curve_length helper to handle LineCurve (no GetLength method)\n                    wall_curve_length = curve_length(wall_base_curve_rhino)\n                    opening_center_u = t * wall_curve_length  # Convert normalized to absolute\n                    print(f\"Opening {insert_id} - wall_curve_length: {wall_curve_length}, opening_center_u: {opening_center_u}\")\n\n                    rough_width_half = opening_width_value / 2.0\n                    start_u_coordinate = opening_center_u - rough_width_half if success else 0.0\n\n                    # Note: Revit's \"Sill Height\" parameter is the height above the floor level,\n                    # which is the same as relative to wall base (since wall is on that level).\n                    # No need to subtract wall_base_elevation - it's already relative.\n                    opening_data = {\n                        \"opening_type\": opening_type,\n                        \"opening_location_point\": opening_location_point_rhino,\n                        \"start_u_coordinate\": start_u_coordinate,\n                        \"rough_width\": opening_width_value,\n                        \"rough_height\": opening_height_value,\n                        \"base_elevation_relative_to_wall_base\": sill_height_value,\n                    }\n\n                    # NEW CODE: Validate opening is within wall bounds\n                    end_u_coordinate = start_u_coordinate + opening_width_value\n                    if start_u_coordinate >= 0 and end_u_coordinate <= wall_curve_length:\n                        openings_data.append(opening_data)\n                    else:\n                        print(f\"WARNING: Skipping opening {insert_id} - outside wall bounds \"\n                              f\"(u={start_u_coordinate:.2f} to {end_u_coordinate:.2f}, \"\n                              f\"wall_length={wall_curve_length:.2f})\")\n                else:\n                    print(f\"WARNING: Skipping opening {insert_id} - invalid dimensions (width={opening_width_value}, height={opening_height_value})\")\n\n        # 6. Get the wall's base plane using our helper.\n        wall_base_plane = get_wall_base_plane(\n            revit_wall, wall_base_curve_rhino, wall_base_elevation\n        )\n        if wall_base_plane is None:\n            return None\n\n        # 7. Compute wall length and height.\n        wall_length = curve_length(wall_base_curve_rhino)\n        wall_height = wall_top_elevation - wall_base_elevation\n\n        # 7b. Get wall thickness from wall type\n        wall_thickness = wall_type.Width  # In Revit internal units (feet)\n        print(f\"Wall thickness from WallType.Width: {wall_thickness} ft ({wall_thickness * 12:.2f} inches)\")\n\n        # 7c. Extract CompoundStructure for multi-layer assembly data.\n        wall_assembly_dict = None\n        try:\n            from src.timber_framing_generator.wall_data.assembly_extractor import (\n                extract_compound_structure,\n            )\n            wall_assembly_dict = extract_compound_structure(wall_type, doc)\n            if wall_assembly_dict:\n                layer_count = len(wall_assembly_dict.get(\"layers\", []))\n                print(f\"Extracted CompoundStructure: {layer_count} layers from {wall_type.Name}\")\n            else:\n                print(f\"No CompoundStructure available for {wall_type.Name}, using defaults\")\n        except Exception as cs_err:\n            print(f\"CompoundStructure extraction failed: {cs_err}\")\n\n        # 8. Decompose the wall into cells.\n        cell_data_dict = decompose_wall_to_cells(\n            wall_length=wall_length,\n            wall_height=wall_height,\n            opening_data_list=openings_data,\n            base_plane=wall_base_plane,\n        )\n        cells_list = deconstruct_all_cells(cell_data_dict)\n\n        # 9. Build and return the final wall data dictionary.\n        wall_input_data_final: WallInputData = {\n            \"wall_type\": wall_type.Name,\n            \"wall_base_curve\": wall_base_curve_rhino,\n            \"wall_length\": wall_length,\n            \"wall_thickness\": wall_thickness,  # For CFS profile selection\n            \"base_plane\": wall_base_plane,\n            \"base_level\": base_level,\n            \"base_offset\": base_offset,\n            \"wall_base_elevation\": wall_base_elevation,\n            \"top_level\": top_level,\n            \"top_offset\": top_offset,\n            \"wall_top_elevation\": wall_top_elevation,\n            \"wall_height\": wall_height,\n            \"is_exterior_wall\": is_exterior_wall,\n            \"is_flipped\": is_flipped,\n            \"exterior_normal\": exterior_normal,\n            \"is_load_bearing\": is_load_bearing,\n            \"wall_assembly\": wall_assembly_dict,\n            \"openings\": openings_data,\n            \"cells\": cells_list,\n        }\n        return wall_input_data_final\n    except Exception as e:\n        print(f\"Failed to extract wall data from Revit wall: {revit_wall.Id}\")\n        print(f\"Error: {str(e)}\")\n        return None\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}