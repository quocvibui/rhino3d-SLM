{
  "source_url": "https://github.com/dtbinh/T1_python-exercises/blob/f4710c3dc2ba8ddb3e3e9069ab8d65df674463ab/07_ur_online/shifted_frames_setup/compas/__debugging/Mesh_optimization_in_rhino/planarize_panels.py",
  "repo": "dtbinh/T1_python-exercises",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "07_ur_online/shifted_frames_setup/compas/__debugging/Mesh_optimization_in_rhino/planarize_panels.py",
  "instruction": "Planarize panels",
  "code": "__author__     = ['Matthias Rippmann <rippmann@ethz.ch>', ]\n__copyright__  = 'Copyright 2016, Block Research Group - ETH Zurich'\n__license__    = 'MIT License'\n__version__    = '0.1'\n__date__       = 'Nov 11, 2016'\n\n\nimport time\nimport rhinoscriptsyntax as rs  \nimport math\nimport copy\nimport Rhino\nfrom compas.datastructures.mesh.mesh import Mesh\nfrom compas.geometry.functions import centroid\nfrom compas.geometry.functions import distance\nfrom compas.geometry.functions import midpoint\n\n\nfrom compas.geometry.arithmetic import add_vectors\nfrom compas.geometry.arithmetic import subtract_vectors\n\nfrom compas.geometry.transformations import normalize\nfrom compas.geometry.transformations import scale\nfrom compas.utilities.colors import i2rgb\nfrom compas.geometry.spatial import closest_point_on_plane\n\nimport compas_rhino.utilities as rhino\nfrom compas.datastructures.mesh.algorithms.smoothing import mesh_smooth_centroid\n\n#import utility as rhutil\nimport Rhino\nimport scriptcontext\n\n\ndef mesh_smooth_on_local_plane(mesh, k=1, d=0.5,boundary=None):\n    \"\"\"Smoothen the input mesh by moving each vertex to the centroid of its\n    neighbours.\n\n    Note:\n        This is a node-per-node version of Laplacian smoothing with umbrella weights.\n\n    Parameters:\n        k (int): The number of smoothing iterations.\n            Defaults to `1`.\n        d (float): Scale factor for (i.e. damping of) the displacement vector.\n            Defaults to `0.5`.\n\n    Returns:\n        None\n    \"\"\"\n    def centroid(points):\n        p = len(points)\n        return [coord / p for coord in map(sum, zip(*points))]\n    boundary = set(mesh.vertices_on_boundary())\n    for _ in range(k):\n        key_xyz = dict((key, (attr['x'], attr['y'], attr['z'])) for key, attr in mesh.vertices_iter(True))\n        for key in key_xyz:\n            if key in boundary:\n                continue\n            nbrs       = mesh.vertex_neighbours(key)\n            points     = [key_xyz[nbr] for nbr in nbrs]\n            cx, cy, cz = centroid(points)\n            x, y, z    = key_xyz[key]\n            tx, ty, tz = d * (cx - x), d * (cy - y), d * (cz - z)\n            \n            x += tx\n            y += ty\n            z += tz\n            \n            n = mesh.vertex_normal(key)\n            x,y,z = closest_point_on_plane(key_xyz[key], n,(x,y,z))\n            \n            mesh.vertex[key]['x'] = x\n            mesh.vertex[key]['y'] = y\n            mesh.vertex[key]['z'] = z\n            \n            \n            \ndef mesh_pull_to_surface(mesh,brep,max_srf_dis,tolerance):            \n    pts = []\n    key_index = {}\n    count = 0\n    for k, a in mesh.vertices_iter(True):\n#         if k in fixed:\n#             continue\n        pts.append((a['x'], a['y'], a['z'])) \n        key_index[k] = count\n        count += 1\n    if pts:\n        points = rs.coerce3dpointlist(pts, True)      \n        points = brep.Faces[0].PullPointsToFace(points, tolerance)\n        if len(pts) == len(points):\n            #print \"Yes\"\n            for key in key_index:\n                index = key_index[key]\n                \n                if distance(points[index],pts[index])> max_srf_dis:\n                    vec = subtract_vectors(pts[index],points[index])\n                    vec = normalize(vec)\n                    vec = scale(vec,max_srf_dis)\n                    x,y,z = add_vectors(points[index],vec)\n                    \n                    \n                    mesh.vertex[key]['x'] = x\n                    mesh.vertex[key]['y'] = y\n                    mesh.vertex[key]['z'] = z\n        else:\n            print \"No\" \n            pass            \n            \n            \n\ndef draw_light(mesh,temp = True):\n    key_index = dict((key, index) for index, key in mesh.vertices_enum())\n    xyz = mesh.xyz\n    faces = []\n    for fkey in mesh.faces_iter():\n        face = mesh.face_vertices(fkey,True)\n        face.append(face[-1])\n        faces.append([key_index[k] for k in face])\n    guid = rs.AddMesh(xyz, faces) \n    if temp:\n        rs.EnableRedraw(True)\n        rs.EnableRedraw(False)\n        rs.DeleteObject(guid)\n    return guid  \n\n\ndef space_points(pt1,pt2,trg_dis):\n    mid_pt = midpoint(pt1,pt2)\n    vec = subtract_vectors(pt1,pt2)\n    vec = normalize(vec)\n    vec = scale(vec,trg_dis*0.5)\n    pt1 = add_vectors(mid_pt,vec)\n    pt2 = add_vectors(mid_pt,scale(vec,-1))\n    return pt1,pt2\n\n\ndef mesh_max_deviation(mesh):\n    \n    max_distances = []\n    for fkey in mesh.faces_iter():\n                   \n        keys = mesh.face_vertices(fkey,ordered=True)\n        points = [mesh.vertex_coordinates(key) for key in keys]\n        \n        points = rs.coerce3dpointlist(points, True)\n        rc, plane = Rhino.Geometry.Plane.FitPlaneToPoints(points)\n        points_planar = [plane.ClosestPoint(pt) for pt in points]\n        \n        distances = [distance(pt1,pt2) for pt1,pt2 in zip(points,points_planar)]\n        max_distances.append(max(distances))\n    return max(max_distances)\n\ndef color_mesh(mesh,dis_ub,dis_lb):\n    \n    max_distances = []\n    mesh_faces = []\n    for fkey in mesh.faces_iter():\n                   \n        keys = mesh.face_vertices(fkey,ordered=True)\n        points = [mesh.vertex_coordinates(key) for key in keys]\n        plane = rs.PlaneFitFromPoints(points)\n        points_planar = [rs.PlaneClosestPoint(plane, pt) for pt in points] \n        distances = [distance(pt1,pt2) for pt1,pt2 in zip(points,points_planar)]\n        max_distances.append(max(distances))\n        mesh_faces.append(rs.AddMesh(points,[(0,1,2,3)]))\n        \n    values = normalize_values(max_distances,dis_ub,dis_lb,1,0)\n    \n    for i,face in enumerate(mesh_faces):\n        rs.ObjectColor(face,i2rgb(values[i]))\n    return mesh_faces\n\n    \n        \n          \n    \ndef normalize_values(values,old_max,old_min,new_max,new_min):\n    old_range = (old_max - old_min)  \n    new_range = (new_max - new_min)  \n    return [(((old_value - old_min) * new_range) / old_range) + new_min for old_value in values]\n    \n\n\ndef create_quad_mesh(srf,u_div,v_div):\n    \n  \n    \n    u_domain = rs.SurfaceDomain(srf, 0)\n    v_domain = rs.SurfaceDomain(srf, 1)\n    u = (u_domain[1] - u_domain[0]) / (u_div - 1)\n    v = (v_domain[1] - v_domain[0]) / (v_div - 1)\n    \n    #pts =  [[None for i in range(v_div)] for j in range(u_div)]\n    mesh_pts = []\n    for i in xrange(u_div):\n        for j in xrange(v_div):\n            #pts[i][j] = rs.EvaluateSurface (srf, u_domain[0] + u * i, v_domain[0] + v * j)\n            mesh_pts.append(rs.EvaluateSurface (srf, u_domain[0] + u * i, v_domain[0] + v * j))\n            \n    faces = []        \n    for i in xrange(u_div-1):\n         for j in xrange(v_div-1):       \n             faces.append(((i*v_div)+j,((i+1)*v_div)+j,((i+1)*v_div)+j+1,(i*v_div)+j+1))\n\n    mesh = Mesh()\n    \n    for i,pt in enumerate(mesh_pts):\n        mesh.add_vertex(str(i),{'x' : pt[0], 'y' : pt[1], 'z' : pt[2]})\n    \n    for face in faces:\n        mesh.add_face(face)  \n    \n    return mesh        \n\nif __name__ == \"__main__\":\n    \n    srf = rs.GetObject(\"Select Surface\",8)\n    \n#     srf_trg = rs.GetObject(\"Select Target Surface\",8)\n#     srf_id = rs.coerceguid(srf_trg, True)\n#     brep = rs.coercebrep(srf_id, False)   \n#     tolerance = rs.UnitAbsoluteTolerance()\n    \n    rs.EnableRedraw(False)\n    \n    rs.HideObject(srf)\n    \n    u_div = rs.GetInteger(\"Panel division in u direction\",20)\n    v_div = rs.GetInteger(\"Panel division in v direction\",12)\n    \n    dev_threshold = rs.GetReal(\"Threshold in m\",0.01)\n    \n    mesh = create_quad_mesh(srf,u_div,v_div)\n\n    max_dev = mesh_max_deviation(mesh)\n    mesh_faces = color_mesh(mesh,max_dev,0)\n    rs.AddObjectsToGroup(mesh_faces,rs.AddGroup())\n    rs.HideObjects(mesh_faces)\n    \n    kmax = 1000\n\n\n    vis = 2\n\n\n    diagonal_prop = 0.15\n    edge_prop = 0.1\n    \n    edge_min = 1\n    edge_max = 5\n    max_srf_dis = 1\n    \n    \n\n    \n    \n    boundary = mesh.vertices_on_boundary()\n    boundary = []\n    \n    \n#     diagonal = {}\n#     for fkey in mesh.faces_iter():\n#         keys = mesh.face_vertices(fkey, ordered=True)\n#         if len(keys) == 4:\n#             dis1 = distance(mesh.vertex_coordinates(keys[0]),mesh.vertex_coordinates(keys[2]))\n#             dis1_min, dis1_max = dis1*(1-diagonal_fac),dis1*(1+diagonal_fac)\n#             dis2 = distance(mesh.vertex_coordinates(keys[1]),mesh.vertex_coordinates(keys[3]))\n#             dis2_min, dis2_max = dis2*(1-diagonal_fac),dis2*(1+diagonal_fac)\n#             diagonal[fkey] = dis1_min,dis1_max,dis2_min,dis2_max\n#             \n#     edges_dis = {}\n#     for uv in mesh.edges():\n#         dis = mesh.edge_length(uv[0], uv[1])\n#         dis_min, dis_max = dis*(1-edge_fac),dis*(1+edge_fac)\n#         edges_dis[uv] = dis_min, dis_max\n    \n    for k in range(kmax):\n        \n        if 1 == 1:\n        \n        \n            max_dev_step = mesh_max_deviation(mesh)\n        \n            nodes_dict = {key: [] for key in mesh.vertices()}\n            dots = []\n            for fkey in mesh.faces_iter():\n                \n                keys = mesh.face_vertices(fkey,ordered=True)\n                points = [mesh.vertex_coordinates(key) for key in keys]\n                \n                points = rs.coerce3dpointlist(points, True)\n                rc, plane = Rhino.Geometry.Plane.FitPlaneToPoints(points)\n                points = [plane.ClosestPoint(pt) for pt in points]\n    \n    #             dis1_min, dis1_max,dis2_min,dis2_max= diagonal[fkey] \n                \n                if 1==1:\n                    dis1_step = distance(points[0],points[2])\n                    dis2_step = distance(points[1],points[3])\n                    \n                    if dis1_step > dis2_step:\n                        if (dis1_step-dis2_step)/dis1_step > diagonal_prop:\n                            trg_dis = -dis2_step/(diagonal_prop-1)\n                            points[0],points[2] = space_points(points[0],points[2],trg_dis)\n                            #rs.AddLine(points[0],points[2])\n                    else:\n                        if (dis2_step-dis1_step)/dis2_step > diagonal_prop:\n                            trg_dis = -dis1_step/(diagonal_prop-1)\n                            points[1],points[3] = space_points(points[1],points[3],trg_dis)\n                            #rs.AddLine(points[1],points[3])    \n                \n                \n    #             if dis1_step < dis1_min:\n    #                 trg_dis = dis1_min\n    #             elif dis1_step > dis1_max:\n    #                 trg_dis = dis1_max\n    #             else:\n    #                 trg_dis = None\n    #             if trg_dis:\n    #                 space_points(points[0],points[2],trg_dis)\n    #                 rs.AddLine(points[0],points[2])\n    #                 \n    #                 \n    #             if dis2_step < dis2_min:\n    #                 trg_dis = dis2_min\n    #             elif dis2_step > dis2_max:\n    #                 trg_dis = dis2_max\n    #             else:\n    #                 trg_dis = None\n    #             if trg_dis:\n    #                 space_points(points[1],points[3],trg_dis)\n    #                 rs.AddLine(points[1],points[3])            \n                dis1_step = distance(points[0],points[1])\n                dis2_step = distance(points[2],points[3])\n                if dis1_step > dis2_step:\n                    if (dis1_step-dis2_step)/dis1_step > edge_prop:\n                        trg_dis = -dis2_step/(edge_prop-1)\n                        points[0],points[1] = space_points(points[0],points[1],trg_dis)\n                        #rs.AddLine(points[0],points[1])\n                else:\n                    if (dis2_step-dis1_step)/dis2_step > edge_prop:\n                        trg_dis = -dis1_step/(edge_prop-1)\n                        points[2],points[3] = space_points(points[2],points[3],trg_dis)\n                        #rs.AddLine(points[2],points[3])     \n                                \n                dis1_step = distance(points[1],points[2])\n                dis2_step = distance(points[3],points[0])            \n                if dis1_step > dis2_step:\n                    if (dis1_step-dis2_step)/dis1_step > edge_prop:\n                        trg_dis = -dis2_step/(edge_prop-1)\n                        points[1],points[2] = space_points(points[1],points[2],trg_dis)\n                        #rs.AddLine(points[1],points[2])\n                else:\n                    if (dis2_step-dis1_step)/dis2_step > edge_prop:\n                        trg_dis = -dis1_step/(edge_prop-1)\n                        points[3],points[0] = space_points(points[3],points[0],trg_dis)\n                        #rs.AddLine(points[3],points[0])             \n                \n                \n                \n                \n                for i,key in enumerate(keys):\n                    nodes_dict[key].append(points[i])\n            \n            \n            \n                    \n            for key in mesh.vertices():\n                if key in boundary:\n                    continue\n                cent = centroid(nodes_dict[key])\n                mesh.vertex[key]['x'] = cent[0]\n                mesh.vertex[key]['y'] = cent[1]\n                mesh.vertex[key]['z'] = cent[2]   \n                \n                \n            nodes_dict = {key: [] for key in mesh.vertices()}    \n            for uv in mesh.edges():\n                dis_step = mesh.edge_length(uv[0], uv[1])\n                        \n                if dis_step < edge_min:\n                    trg_dis = edge_min\n                elif dis_step > edge_max:\n                    trg_dis = edge_max\n                else:\n                    trg_dis = None\n                if trg_dis:\n                    pt1 = mesh.vertex_coordinates(uv[0])\n                    pt2 = mesh.vertex_coordinates(uv[1])\n                    pt1,pt2 = space_points(pt1,pt2,trg_dis)\n                    \n                    nodes_dict[uv[0]].append(pt1)\n                    nodes_dict[uv[1]].append(pt2)\n                    \n                    #rs.AddLine(pt1,pt2) \n            \n            for key in nodes_dict:\n                if key in boundary:\n                    continue\n                cent = centroid(nodes_dict[key])\n                if cent:\n                    mesh.vertex[key]['x'] = cent[0]\n                    mesh.vertex[key]['y'] = cent[1]\n                    mesh.vertex[key]['z'] = cent[2] \n            #rs.AddPoints(points)\n            \n            #rhino_mesh = draw_light(mesh,temp = False)   \n        \n        mesh_smooth_on_local_plane(mesh, k=1, d=0.01)\n        \n        #mesh_pull_to_surface(mesh,brep,max_srf_dis,tolerance)\n        \n        if k%vis==0:  \n            rs.Prompt(\"Iteration {0} of {1} with a maximum deviation of {2}\".format(k,kmax,round(max_dev_step,4)))\n            #draw_light(mesh,temp = True)  \n            mesh_faces = color_mesh(mesh,max_dev,0)\n            rs.Redraw()\n            Rhino.RhinoApp.Wait()\n            rs.DeleteObjects(mesh_faces)\n        if max_dev_step < dev_threshold or k == kmax:\n            print\"Iteration {0} of {1} with a maximum deviation of {2}\".format(k,kmax,round(max_dev_step,4))\n            break\n    \n    #draw_light(mesh,temp = False)  \n    mesh_faces = color_mesh(mesh,max_dev,0)\n    rs.AddObjectsToGroup(mesh_faces,rs.AddGroup())\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}