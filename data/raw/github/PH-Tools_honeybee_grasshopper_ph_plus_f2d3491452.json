{
  "source_url": "https://github.com/PH-Tools/honeybee_grasshopper_ph_plus/blob/b89f9887488d9c10eb732ffafe910cec70be0752/honeybee_ph_plus_rhino/gh_compo_io/reporting/to_pdf.py",
  "repo": "PH-Tools/honeybee_grasshopper_ph_plus",
  "repo_stars": 2,
  "repo_description": "Additional Honeybe-PH Grasshopper Components",
  "license": "GPL-3.0",
  "filepath": "honeybee_ph_plus_rhino/gh_compo_io/reporting/to_pdf.py",
  "instruction": "Functions for exporting a PDF report page.",
  "code": "# -*- coding: utf-8 -*-\n# -*- Python Version: 2.7 -*-\n\n\"\"\"Functions for exporting a PDF report page.\"\"\"\n\nimport os\n\ntry:\n    from itertools import izip_longest  # type: ignore\nexcept:\n    from itertools import zip_longest as izip_longest\n\ntry:\n    from typing import Iterable, List, Optional, Tuple\nexcept ImportError:\n    pass  # IronPython 2.7\n\ntry:\n    from System import Guid  # type: ignore\n    from System.Drawing import Color, Size  # type: ignore\nexcept ImportError:\n    pass  # Outside .NET\n\ntry:\n    from Rhino import Display as rdp  # type: ignore\n    from Rhino import DocObjects as rdo  # type: ignore\n    from Rhino import FileIO  # type: ignore\n    from Rhino import Geometry as rg  # type: ignore\n    from Rhino.DocObjects.DimensionStyle import MaskFrame  # type: ignore\n\n    # from Rhino.Geometry import (\n    #     Hatch,\n    #     Mesh,\n    #     Point3d,\n    #     Rectangle3d,\n    #     TextJustification,\n    #     Transform,\n    # )\nexcept ImportError:\n    pass  # Outside Rhino\n\ntry:\n    from Grasshopper import DataTree  # type: ignore\nexcept ImportError:\n    pass  # Outside Grasshopper\n\ntry:\n    from ph_gh_component_io import gh_io\nexcept ImportError:\n    raise ImportError(\"Failed to import honeybee_ph_rhino\")\n\ntry:\n    from honeybee_ph_utils.input_tools import clean_tree_get\nexcept ImportError:\n    raise ImportError(\"Failed to import honeybee_ph_utils\")\n\ntry:\n    from honeybee_ph_plus_rhino.gh_compo_io.reporting.annotations import TextAnnotation\n    from honeybee_ph_plus_rhino.gh_compo_io.reporting.create_clipping_plane_set import (\n        ClippingPlaneLocation,\n    )\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee_ph_rhino:\\n\\t{}\".format(e))\n\n\nclass HatchFromCurveError(Exception):\n    \"\"\"Raised when a Curve cannot be converted to a Hatch.\"\"\"\n\n    def __init__(self, crv):\n        self.message = \"Error: Could not create a Hatch from the input curve: {}\".format(\n            crv\n        )\n        super(HatchFromCurveError, self).__init__(self.message)\n\n\ndef create_default_solid_hatch_pattern(_IGH):\n    # type: (gh_io.IGH) -> int\n    \"\"\"Create a new SOLID hatch pattern in the document and return its index.\"\"\"\n    hatch_pattern = rdo.HatchPattern()\n    hatch_pattern.FillType = rdo.HatchPatternFillType.Solid  # type: ignore\n    hatch_pattern.Name = \"SOLID\"\n    try:\n        new_index = _IGH.sc.doc.HatchPatterns.Add(hatch_pattern)\n        return new_index\n    except Exception as e:\n        print(e)\n        return 0\n\n\ndef get_default_solid_hatch_index(_IGH):\n    # type: (gh_io.IGH) -> int\n    \"\"\"Return the index of the default SOLID hatch pattern.\n\n    If the SOLID hatch pattern does not exist, create it first.\n    \"\"\"\n    for hatch_pattern in _IGH.sc.doc.HatchPatterns:\n        if str(hatch_pattern.Name).upper() == \"SOLID\":\n            return hatch_pattern.Index\n    try:\n        return create_default_solid_hatch_pattern(_IGH)\n    except Exception as e:\n        print(e)\n        return 0\n\n\ndef hatch_from_curve(_hatchCurve, _tolerance, _hatch_pattern_index=0):\n    # type: (rg.Curve, float, int) -> rg.Hatch\n    hatch = rg.Hatch.Create(\n        curve=_hatchCurve,\n        hatchPatternIndex=_hatch_pattern_index,\n        rotationRadians=0,\n        scale=0,\n        tolerance=_tolerance,\n    )\n    if len(hatch) == 0:\n        raise HatchFromCurveError(_hatchCurve)\n    return hatch[0]\n\n\ndef _clean_filename(_input_str):\n    # type: (str) -> str\n    \"\"\"Return a cleaned and validated filename string.\"\"\"\n    valid_filename = os.path.splitext(_input_str)[0]  # remove any extension\n    valid_filename = valid_filename.replace(\" \", \"_\").strip()\n    valid_filename = \"\".join(_ if _.isalnum() else \"_\" for _ in valid_filename)\n    return valid_filename\n\n\ndef gen_file_paths(_save_folder, _file_names, _target_length):\n    # type: (str, DataTree, int) -> List[str]\n    \"\"\"Return a list of full paths for each PDF file to export. Will create save folder if needed.\n\n    Arguments:\n    ----------\n        * _save_folder (str):\n        * _file_names (DataTree):\n        * _target_length (int):\n\n    Returns:\n    --------\n        * List[str]\n    \"\"\"\n    file_paths = []\n\n    if not _save_folder:\n        return file_paths\n\n    if _file_names.BranchCount == 0:\n        return file_paths\n\n    if _target_length == 0:\n        # save-file list len should match the target (geometry) len.\n        return file_paths\n\n    if _file_names.BranchCount != _target_length:\n        raise Exception(\n            \"Error: The number of geometry branches ({}) does not\"\n            \" match the number of file-names ({})?\".format(\n                _target_length, _file_names.BranchCount\n            )\n        )\n\n    # --- Save folder\n    if not os.path.exists(_save_folder):\n        try:\n            os.makedirs(_save_folder)\n        except Exception as e:\n            raise Exception(\"{}\\nError creating save folder: {}\".format(e, _save_folder))\n\n    # -- Save filenames\n    for branch in _file_names.Branches:\n        file_name = _clean_filename(str(branch[0]))\n        file_path = os.path.join(_save_folder, file_name + os.extsep + \"pdf\")\n        file_paths.append(file_path)\n\n    return file_paths\n\n\ndef gen_layout_names(_layout_names, _target_length):\n    layout_names = []\n\n    if not _layout_names:\n        return layout_names\n\n    if _layout_names.BranchCount == 0:\n        return layout_names\n\n    if _target_length == 0:\n        # layout-name list len should match the target (geometry) len.\n        return layout_names\n\n    # -- Create the LayoutNames list\n    for i in range(_target_length):\n        try:\n            layout_names.append(_layout_names.Branch(i)[0])\n        except:\n            try:\n                layout_names.append(_layout_names.Branch(0)[0])\n            except:\n                raise Exception(\"Error: Shape of _layout_names does not match geometry?\")\n\n    return layout_names\n\n\ndef get_active_view_name(_IGH):\n    return _IGH.scriptcontext.doc.Views.ActiveView.ActiveViewport.Name\n\n\ndef set_active_view_by_name(_IGH, _view_name):\n    # type: (gh_io.IGH, str) -> None\n    \"\"\"Changes the Active View to the specified layout/view by name. Raises an error if the target view name does not exist.\n\n    Arguments:\n    ----------\n        * _IGH (gh_io.IGH):\n        * _view_name (str):\n\n    Returns:\n    --------\n        * (None)\n    \"\"\"\n    # https://developer.rhino3d.com/samples/rhinocommon/get-and-set-the-active-view/\n\n    # active view and non-active view names\n    active_view_name = get_active_view_name(_IGH)\n    non_active_views = [\n        (view.ActiveViewport.Name, view)\n        for view in _IGH.scriptcontext.doc.Views\n        if view.ActiveViewport.Name != active_view_name\n    ]\n\n    if _view_name != active_view_name:\n        if _view_name in [seq[0] for seq in non_active_views]:\n            _IGH.scriptcontext.doc.Views.ActiveView = [\n                seq[1] for seq in non_active_views if seq[0] == _view_name\n            ][0]\n            # print(\"Setting Active View to: '{}'\".format(_view_name))\n        else:\n            msg = '\"{0}\" is not a valid view name?'.format(_view_name)\n            _IGH.error(msg)\n\n\ndef get_active_layer_name(_IGH):\n    # type (gh_io.IGH) -> str\n    \"\"\"Return the name of the current active layer\"\"\"\n    with _IGH.context_rh_doc():\n        return _IGH.scriptcontext.doc.Layers.CurrentLayer.FullPath\n\n\ndef set_active_layer_by_name(_IGH, _layer_name):\n    # type: (gh_io.IGH, str) -> None\n    \"\"\"Change the active layer by name\"\"\"\n    with _IGH.context_rh_doc():\n        if _layer_name not in _IGH.rhinoscriptsyntax.LayerNames():\n            raise Exception(\n                \"Error: Cannot find the Layer with name: '{}'?\".format(_layer_name)\n            )\n        _IGH.rhinoscriptsyntax.CurrentLayer(_layer_name)\n\n\ndef get_detail_views_for_active_view(_IGH):\n    # type: (gh_io.IGH) -> List[rdo.DetailViewObject]\n    \"\"\"Return a List of the DetailViewObjects for the Active View.\"\"\"\n\n    with _IGH.context_rh_doc():\n        active_view = _IGH.scriptcontext.doc.Views.ActiveView\n        try:\n            return active_view.GetDetailViews()\n        except:\n            # If its not a Layout View....\n            return []\n\n\ndef get_layout_view_transform(_IGH, _dtl_view_objs, _layout_name):\n    # type: (gh_io.IGH, List[rdo.DetailViewObject], str) -> rg.Transform\n    \"\"\"Return the Transform for the Layout View. Raises an error if there are multiple Detail-Views on the Layout-Page.\"\"\"\n\n    all_dtl_view_transforms = {vw.WorldToPageTransform for vw in _dtl_view_objs}\n    if len(all_dtl_view_transforms) != 1:\n        msg = (\n            \"Warning: There are {} Detail-Views found on Layout-Page: '{}'.\"\n            \"Model-Annotations may not align properly when multiple Detail-Views \"\n            \"are present on a single Layout-Page. Try splitting up the Detail-Views \"\n            \"onto multiple Layout-Pages, or make sure that the orientation of each \"\n            \"Detail-View on the Layout-Page is the same.\".format(\n                len(_dtl_view_objs), _layout_name\n            )\n        )\n        _IGH.warning(msg)\n    return all_dtl_view_transforms.pop()\n\n\ndef find_layers_with_detail_views(_IGH):\n    # type: (gh_io.IGH) -> List[str]\n    \"\"\"Goes to the Active View and looks to see if there are any 'DetailViews' present,\n    If so, find the Layer the DetailViews are on and add the layerIndex to the list.\n    This is used to ensure that the DetailViews will remain 'on' when exporting the PDF.\n\n    Arguments:\n    ----------\n        * (gh_io.IGH):\n\n    Returns:\n    --------\n        * (List[str]):\n    \"\"\"\n\n    layer_names_ = []  # type: List[str]\n    layer_IDs_ = []  # type: List[int]\n\n    with _IGH.context_rh_doc():\n        active_view = _IGH.scriptcontext.doc.Views.ActiveView\n        detail_views = active_view.GetDetailViews()\n        for detail_view in detail_views:\n            layer_IDs_.append(detail_view.Attributes.LayerIndex)\n\n        # Find the right Layer Names from the Index vals\n        layer_IDs_ = list(set(layer_IDs_))  # Keep only one of each unique index val\n\n        for i in range(len(layer_IDs_)):\n            # Get the Layer and any parents\n            layer_path = _IGH.scriptcontext.doc.Layers[layer_IDs_[i]].FullPath\n            layer_names = list(layer_path.Split(\":\"))  # type: List[str]\n\n            for layerName in layer_names:\n                layer_names_.append(layer_path)\n                layer_names_.append(layerName)\n\n    return list(set(layer_names_))\n\n\ndef get_current_layer_visibilities(_IGH):\n    # type: (gh_io.IGH) -> List[bool]\n    \"\"\"Return a list of current Layer visibilities\"\"\"\n    with _IGH.context_rh_doc():\n        return [\n            _IGH.rhinoscriptsyntax.LayerVisible(layer)\n            for layer in _IGH.rhinoscriptsyntax.LayerNames()\n        ]\n\n\ndef turn_off_all_layers(_IGH, _except_layers):\n    # type: (gh_io.IGH, List[str]) -> None\n    \"\"\"Turn all Layer Visibilities 'Off' except for the specified layers. Returns a list\n        of the starting layer states before changing as a bool (True=On, False=Off).\n\n    Arguments:\n    ----------\n        * _IGH (gh_io.IGH):\n        * _except_layers (List[str]): A list of the Layers to leave 'on'\n\n    Returns:\n    --------\n        * (None)\n    \"\"\"\n\n    with _IGH.context_rh_doc():\n        # Set layers 'off' if they aren't on the list to stay on\n        for layer_name in _IGH.rhinoscriptsyntax.LayerNames():\n            # if list(layer.Split(\":\"))[-1] not in allLayersOn:\n            if layer_name in _except_layers:\n                _IGH.rhinoscriptsyntax.LayerVisible(layer_name, True)\n            else:\n                _IGH.rhinoscriptsyntax.LayerVisible(layer_name, False)\n\n        _IGH.Rhino.RhinoDoc.ActiveDoc.Views.RedrawEnabled = True\n        _IGH.Rhino.RhinoDoc.ActiveDoc.Views.Redraw()\n\n\ndef reset_all_layer_visibility(_IGH, _layer_vis_settings):\n    # type: (gh_io.IGH, List[bool]) -> None\n    \"\"\"Reset all the Layer Vis settings to the original State\n\n    Arguments:\n    ----------\n        *\n        *\n\n    Returns:\n    --------\n        * (None)\n    \"\"\"\n\n    with _IGH.context_rh_doc():\n        layers = _IGH.rhinoscriptsyntax.LayerNames()\n\n        for (\n            layer,\n            vis_setting,\n        ) in izip_longest(layers, _layer_vis_settings):\n            _IGH.rhinoscriptsyntax.LayerVisible(layer, vis_setting)\n\n        _IGH.Rhino.RhinoDoc.ActiveDoc.Views.RedrawEnabled = True\n        _IGH.Rhino.RhinoDoc.ActiveDoc.Views.Redraw()\n\n\ndef create_bake_layer(_IGH):\n    # type: (gh_io.IGH) -> str\n    \"\"\"Creates a new layer which is used for bake objects. Returns the name of the new layer.\n\n    Arguments:\n    ----------\n        *\n\n    Returns:\n    --------\n        *\n    \"\"\"\n\n    with _IGH.context_rh_doc():\n        # Create an Unused Layer Name\n        new_layer_name = _IGH.scriptcontext.doc.Layers.GetUnusedLayerName(False)\n\n        # Add a new Layer to the Document\n        _IGH.scriptcontext.doc.Layers.Add(new_layer_name, Color.Black)\n\n    return new_layer_name\n\n\ndef remove_bake_layer(_IGH, _layer_name):\n    # type: (gh_io.IGH, str) -> None\n    \"\"\"Remove a layer with the specified name. Will also delete all objects on the layer.\n\n    Arguments:\n    ----------\n        *\n\n    Returns:\n    --------\n        *\n    \"\"\"\n\n    with _IGH.context_rh_doc():\n        print(\"Removing Bake-Layer: {}\".format(_layer_name))\n\n        # Be sure the temp layer exists\n        if _layer_name not in _IGH.rhinoscriptsyntax.LayerNames():\n            return\n\n        # Remove all the objects on the specified layer\n        _IGH.rhinoscriptsyntax.DeleteObjects(\n            _IGH.rhinoscriptsyntax.ObjectsByLayer(_layer_name)\n        )\n\n        # Remove the layer\n        _IGH.scriptcontext.doc.Layers.Delete(\n            _IGH.scriptcontext.doc.Layers.FindName(_layer_name)\n        )\n\n\ndef mesh2Hatch(_IGH, mesh, _hatch_pattern_index=0):\n    # type: (gh_io.IGH, rg.Mesh, int) -> Tuple[List[rg.Hatch], List[Color]]\n    \"\"\"Copied / Adapted from Ladybug Definition\n\n    Arguments:\n    ----------\n        *\n\n    Returns:\n    --------\n        *\n    \"\"\"\n\n    # Make some lists to hold key parameters\n    hatches = []  # type: List[rg.Hatch]\n    colors = []  # type: List[Color]\n    meshColors = mesh.VertexColors\n\n    for faceCount, face in enumerate(mesh.Faces):\n        faceColorList = []\n        facePointList = []\n\n        # Extract the points and colors.\n        if face.IsQuad:\n            faceColorList.append(meshColors[face.A])\n            faceColorList.append(meshColors[face.B])\n            faceColorList.append(meshColors[face.C])\n            faceColorList.append(meshColors[face.D])\n\n            facePointList.append(mesh.PointAt(faceCount, 1, 0, 0, 0))\n            facePointList.append(mesh.PointAt(faceCount, 0, 1, 0, 0))\n            facePointList.append(mesh.PointAt(faceCount, 0, 0, 1, 0))\n            facePointList.append(mesh.PointAt(faceCount, 0, 0, 0, 1))\n        else:\n            faceColorList.append(meshColors[face.A])\n            faceColorList.append(meshColors[face.B])\n            faceColorList.append(meshColors[face.C])\n\n            facePointList.append(mesh.PointAt(faceCount, 1, 0, 0, 0))\n            facePointList.append(mesh.PointAt(faceCount, 0, 1, 0, 0))\n            facePointList.append(mesh.PointAt(faceCount, 0, 0, 1, 0))\n\n        # Calculate the average color of the face.\n        if face.IsQuad:\n            hatchColorR = (\n                faceColorList[0].R\n                + faceColorList[1].R\n                + faceColorList[2].R\n                + faceColorList[3].R\n            ) / 4\n            hatchColorG = (\n                faceColorList[0].G\n                + faceColorList[1].G\n                + faceColorList[2].G\n                + faceColorList[3].G\n            ) / 4\n            hatchColorB = (\n                faceColorList[0].B\n                + faceColorList[1].B\n                + faceColorList[2].B\n                + faceColorList[3].B\n            ) / 4\n        else:\n            hatchColorR = (\n                faceColorList[0].R + faceColorList[1].R + faceColorList[2].R\n            ) / 3\n            hatchColorG = (\n                faceColorList[0].G + faceColorList[1].G + faceColorList[2].G\n            ) / 3\n            hatchColorB = (\n                faceColorList[0].B + faceColorList[1].B + faceColorList[2].B\n            ) / 3\n        hatchColor = Color.FromArgb(255, hatchColorR, hatchColorG, hatchColorB)\n\n        # Create the outline of a new hatch.\n        hatchCurveInit = rg.PolylineCurve(facePointList)\n        if face.IsQuad:\n            hatchExtra = rg.LineCurve(facePointList[0], facePointList[3])\n        else:\n            hatchExtra = rg.LineCurve(facePointList[0], facePointList[2])\n        hatchCurve = rg.Curve.JoinCurves([hatchCurveInit, hatchExtra], _IGH.tolerance)[0]\n        # Create the Hatch\n        if hatchCurve.IsPlanar():\n            meshFaceHatch = hatch_from_curve(\n                hatchCurve, _IGH.tolerance, _hatch_pattern_index\n            )\n            hatches.append(meshFaceHatch)\n            colors.append(hatchColor)\n        else:\n            # We have to split the quad face into two triangles.\n            try:\n                hatchCurveInit1 = rg.PolylineCurve(\n                    [facePointList[0], facePointList[1], facePointList[2]]\n                )\n                hatchExtra1 = rg.LineCurve(facePointList[0], facePointList[2])\n                hatchCurve1 = rg.Curve.JoinCurves(\n                    [hatchCurveInit1, hatchExtra1],\n                    _IGH.tolerance,\n                )[0]\n                meshFaceHatch1 = hatch_from_curve(\n                    hatchCurve1, _IGH.tolerance, _hatch_pattern_index\n                )\n                hatchCurveInit2 = rg.PolylineCurve(\n                    [facePointList[2], facePointList[3], facePointList[0]]\n                )\n                hatchExtra2 = rg.LineCurve(facePointList[2], facePointList[0])\n                hatchCurve2 = rg.Curve.JoinCurves(\n                    [hatchCurveInit2, hatchExtra2],\n                    _IGH.tolerance,\n                )[0]\n                meshFaceHatch2 = hatch_from_curve(\n                    hatchCurve2, _IGH.tolerance, _hatch_pattern_index\n                )\n                hatches.extend([meshFaceHatch1, meshFaceHatch2])\n                colors.extend([hatchColor, hatchColor])\n            except HatchFromCurveError as e:\n                msg = \"Warning: Could not create hatch for a Non-Planar mesh face. Skipping that face.\"\n                print(e)\n                print(msg)\n                _IGH.warning(msg)\n\n    return hatches, colors\n\n\ndef create_geometry_attributes(parent_layer_index, _color, _display_order=0):\n    # type: (int, Color, int) -> rdo.ObjectAttributes\n    \"\"\"Create a new ObjectAttributes object with the specified color and layer index.\"\"\"\n    attr = rdo.ObjectAttributes()\n    attr.LayerIndex = parent_layer_index\n    attr.ObjectColor = _color\n    attr.PlotColor = _color\n    attr.ColorSource = rdo.ObjectColorSource.ColorFromObject  # type: ignore\n    attr.PlotColorSource = rdo.ObjectPlotColorSource.PlotColorFromObject  # type: ignore\n    attr.DisplayOrder = _display_order\n    return attr\n\n\ndef bake_mesh(_IGH, _layer_name, _geometry, _draw_order=0):\n    # type: (gh_io.IGH, str, rg.Mesh, int) -> None\n    \"\"\"Bake a Mesh object into the Rhino Scene.\"\"\"\n\n    # --\n    layer_table = _IGH.Rhino.RhinoDoc.ActiveDoc.Layers\n    hatch_id = get_default_solid_hatch_index(_IGH)\n    parent_layer_index = rdo.Tables.LayerTable.FindByFullPath(  # type: ignore\n        layer_table, _layer_name, True\n    )\n\n    # -- Create the hatches, and Bake them into the Rhino Doc\n    guids = []\n    for hatch, color in zip(*mesh2Hatch(_IGH, _geometry, hatch_id)):\n        attr = create_geometry_attributes(parent_layer_index, color, _draw_order)\n        guids.append(_IGH.Rhino.RhinoDoc.ActiveDoc.Objects.AddHatch(hatch, attr))\n\n    # -- Group the hatches so they are manageable\n    group_ = _IGH.Rhino.RhinoDoc.ActiveDoc.Groups\n    rdo.Tables.GroupTable.Add(group_, guids)  # type: ignore\n    _IGH.scriptcontext.doc.Views.Redraw()\n\n    return None\n\n\ndef bake_geometry_object(_IGH, _geom_obj, _attr_obj, _layer_name):\n    # type: (gh_io.IGH, Guid, rdo.ObjectAttributes | None, str) -> None\n    \"\"\"Takes in a geom obj Guid and attributes, then bakes to a Layer\n\n    If the Object is a Mesh, will bake that using the Mesh's Vertex Colors. To\n    set these, use the Grasshopper MeshColor component (ghc.MeshColours() ) before\n    inputting here.\n\n    If its a Curve input, will try and look for Attribute information in the\n    _geomAttributes input.\n\n    If its some other type of geometry, will just use a default attribute for printing.\n\n    Arguments:\n    ----------\n        * _IGH (gh_io.IGH):\n        * _geom_obj (Guid):\n        * _attr_obj (ObjectAttributes):\n        * _layer_name (str):\n\n    Returns:\n    --------\n        * (None)\n    \"\"\"\n    doc_object = _IGH.rhinoscriptsyntax.coercerhinoobject(_geom_obj, True, True)\n    geometry = doc_object.Geometry\n\n    with _IGH.context_rh_doc():\n        if _IGH.rhinoscriptsyntax.IsMesh(geometry):\n            if _attr_obj and _attr_obj.DisplayOrder:\n                draw_order = _attr_obj.DisplayOrder\n            else:\n                draw_order = -1  # +1 = Front, -1 = Back\n            bake_mesh(_IGH, _layer_name, geometry, draw_order)\n\n        elif isinstance(geometry, rg.Curve):\n            rhino_geom = _IGH.scriptcontext.doc.Objects.Add(\n                geometry, _attr_obj or doc_object.Attributes\n            )\n\n            # Set the new Object's Layer\n            if not _IGH.rhinoscriptsyntax.IsLayer(_layer_name):\n                _IGH.rhinoscriptsyntax.AddLayer(_layer_name)\n            _IGH.rhinoscriptsyntax.ObjectLayer(rhino_geom, _layer_name)\n\n        else:\n            # Just bake the regular Geometry with default attributes\n            rhino_geom = _IGH.scriptcontext.doc.Objects.Add(\n                geometry, doc_object.Attributes\n            )\n\n            # Set the new Object's Layer\n            if not _IGH.rhinoscriptsyntax.IsLayer(_layer_name):\n                _IGH.rhinoscriptsyntax.AddLayer(_layer_name)\n            _IGH.rhinoscriptsyntax.ObjectLayer(rhino_geom, _layer_name)\n\n\ndef bake_annotation_object(\n    _IGH, _annotation, _target_layer, _avoid_collisions=False, _neighbors=None\n):\n    # type: (gh_io.IGH, TextAnnotation, str, bool, Optional[List[rg.Rectangle3d]]) -> Optional[rg.Rectangle3d]\n    \"\"\"Add a new Text element to the Rhino document.\n\n    Arguments:\n    ----------\n        * _IGH (gh_io.IGH):\n        * _annotation (TextAnnotation):\n        * _target_layer (str):\n        * _avoid_collisions (bool):\n        * _neighbors (Optional[List[Rectangle3d]])\n\n    Returns:\n    --------\n        * (Optional[Rhino.Geometry.Rectangle3d])\n    \"\"\"\n\n    # https://developer.rhino3d.com/api/RhinoCommon/html/T_Rhino_Geometry_TextEntity.htm\n    # https://discourse.mcneel.com/t/adding-text-to-instancedefinition-block/99346\n\n    bounding_rect = None\n    _neighbors = _neighbors or []\n    with _IGH.context_rh_doc():\n        # Create the txt object\n        txt = rg.TextEntity()\n        try:\n            txt.Font = rdo.Font(\"Source Code Pro\")  # type: ignore\n        except:\n            pass\n        txt.Text = _annotation.text\n        txt.Plane = _IGH.ghc.Move(\n            _annotation.plane, _IGH.ghc.Amplitude(_annotation.plane.Normal, 0.1)\n        ).geometry\n        txt.TextHeight = _annotation.text_size\n        txt.Justification = _annotation.justification\n        txt.DrawForward = False\n        if _annotation.mask:\n            txt.MaskEnabled = _annotation.mask.show_mask\n            txt.MaskColor = _annotation.mask.mask_color\n            txt.MaskOffset = _annotation.mask.mask_offset\n            txt.MaskFrame = _annotation.mask.frame_type\n            txt.DrawTextFrame = _annotation.mask.show_frame\n\n        if _avoid_collisions:\n            raise NotImplementedError(\"Not yet....\")\n            #  Test against the other text items on the sheet\n            # First, find / create the bounding box rectangle of the text note\n            this_bounding_box = txt.GetBoundingBox(txt.Plane)\n            box_x_dim = abs(this_bounding_box.Min.X - this_bounding_box.Max.X)\n            box_y_dim = abs(this_bounding_box.Min.Y - this_bounding_box.Max.Y)\n            domain_x = _IGH.ghpythonlib_components.ConstructDomain(\n                (box_x_dim / 2) * -1, box_x_dim / 2\n            )\n            domain_y = _IGH.ghpythonlib_components.ConstructDomain(\n                (box_y_dim / 2) * -1, box_y_dim / 2\n            )\n            bounding_rect = _IGH.ghpythonlib_components.Rectangle(\n                txt.Plane, domain_x, domain_y, 0\n            ).rectangle\n\n            # Compare the current text note to the others already in the scene\n            # Move the current tag if necessary\n            for eachNeighbor in _neighbors:\n                intersection = _IGH.ghpythonlib_components.CurveXCurve(\n                    eachNeighbor, bounding_rect\n                )\n                if intersection.points != None:\n                    neighbor = _IGH.ghpythonlib_components.DeconstuctRectangle(\n                        eachNeighbor\n                    )  # The overlapping textbox\n                    neighborY = neighbor.Y  # Returns a domain\n                    # neighborY = abs(neighborY[0] - neighborY[1]) # Total Y distance\n\n                    neighborCP = neighbor.base_plane.Origin\n                    thisCP = _IGH.ghpythonlib_components.DeconstuctRectangle(\n                        bounding_rect\n                    ).base_plane.Origin\n\n                    if thisCP.Y > neighborCP.Y:\n                        # Move the tag 'up'\n                        neighborMaxY = neighborCP.Y + neighborY[1]\n                        thisMinY = thisCP.Y - (box_y_dim / 2)\n                        moveVector = rg.Vector3d(0, neighborMaxY - thisMinY, 0)\n                        bounding_rect = _IGH.ghpythonlib_components.Move(\n                            bounding_rect, moveVector\n                        ).geometry\n                    else:\n                        # Move the tag 'down'\n                        neighborMinY = neighborCP.Y - neighborY[1]\n                        thisMaxY = thisCP.Y + (box_y_dim / 2)\n                        moveVector = rg.Vector3d(0, neighborMinY - thisMaxY, 0)\n                        bounding_rect = _IGH.ghpythonlib_components.Move(\n                            bounding_rect, moveVector\n                        ).geometry\n\n                    # Re-Set the text tag's origin to the new location\n                    txt.Plane = _IGH.ghpythonlib_components.DeconstuctRectangle(\n                        bounding_rect\n                    ).base_plane\n\n        # Add the new text object to the Scene\n        txtObj = _IGH.Rhino.RhinoDoc.ActiveDoc.Objects.AddText(txt)\n\n        # Set the new Text's Layer\n        if not _IGH.rhinoscriptsyntax.IsLayer(_target_layer):\n            _IGH.rhinoscriptsyntax.AddLayer(_target_layer)\n        _IGH.rhinoscriptsyntax.ObjectLayer(txtObj, _target_layer)\n\n    return bounding_rect\n\n\ndef export_single_pdf(_IGH, _file_path, _dpi=300, _raster=True):\n    # type: (gh_io.IGH,  str, float, bool) -> None\n    \"\"\"Export a single-page PDF document of the Active Layout View.\n\n    Arguments:\n    ----------\n        * _IGH (gh_io.IGH): Grasshopper Interface\n        * _file_path (str): The full path for the PDF file to create\n        * _dpi (float): default=300\n        * _raster (bool): Use raster output mode. default=False.\n\n    Returns:\n    --------\n        * (None)\n    \"\"\"\n    # Layout Page Size in Layout's Units\n    page_height = _IGH.scriptcontext.doc.Views.ActiveView.PageHeight\n    page_width = _IGH.scriptcontext.doc.Views.ActiveView.PageWidth\n\n    # Layout Page Size in Inches\n    # Ref: https://developer.rhino3d.com/api/RhinoScriptSyntax/#document-UnitScale\n    # Ref: https://developer.rhino3d.com/api/RhinoCommon/html/P_Rhino_RhinoDoc_PageUnitSystem.htm\n    page_unit_system_number = _IGH.rhinoscriptsyntax.UnitSystem(in_model_units=False)\n    page_unit_scale = _IGH.rhinoscriptsyntax.UnitScale(\n        8, page_unit_system_number\n    )  # Type 8 = Inches\n\n    page_height = page_height * page_unit_scale\n    page_width = page_width * page_unit_scale\n    page_height = round(page_height, 2)\n    page_width = round(page_width, 2)\n\n    pdf = FileIO.FilePdf.Create()  # type: ignore\n    size = Size(page_width * _dpi, page_height * _dpi)\n    settings = rdp.ViewCaptureSettings(\n        _IGH.scriptcontext.doc.Views.ActiveView, size, _dpi\n    )\n    settings.RasterMode = _raster\n    settings.OutputColor = rdp.ViewCaptureSettings.ColorMode.DisplayColor  # type: ignore\n    pdf.AddPage(settings)\n\n    try:\n        os.remove(_file_path)\n    except OSError as e:\n        if not os.path.exists(_file_path):\n            pass\n        else:\n            raise OSError(\"{}/nFile {} can not be removed?\".format(e, _file_path))\n\n    pdf.Write(_file_path)\n\n\ndef add_clipping_plane(_IGH, _cp_location, _cp_layer, _dtl_view_objs):\n    # type: (gh_io.IGH, ClippingPlaneLocation, str, List[rdo.DetailViewObject]) -> None\n    \"\"\"Add a new ClippingPlane object into the Rhino Scene.\n\n    Ref: https://developer.rhino3d.com/samples/rhinocommon/add-clipping-plane/\n\n    Arguments:\n    ----------\n        * _IGH (gh_io.IGH):\n        * _cp_location (ClippingPlaneLocation): The ClippingPlaneLocation object with an origin and normal.\n        * _cp_layer(str): The name of the Clipping Plane layer to bake to.\n        * _dtl_view_objs (List[DetailViewObject]): A list of DetailViewObjects to apply the ClippingPlane to.\n\n    Returns:\n    --------\n        * (System.Guid)\n    \"\"\"\n\n    pl = rg.Plane(_cp_location.origin, _cp_location.normal)\n\n    with _IGH.context_rh_doc():\n        cp_id = _IGH.scriptcontext.doc.Objects.AddClippingPlane(\n            plane=pl,\n            uMagnitude=1,\n            vMagnitude=1,\n            clippedViewportIds=[dv.Id for dv in _dtl_view_objs],\n        )\n\n        # Set the new ClippingPlane's Layer\n        if not _IGH.rhinoscriptsyntax.IsLayer(_cp_layer):\n            _IGH.rhinoscriptsyntax.AddLayer(_cp_layer)\n        _IGH.rhinoscriptsyntax.ObjectLayer(cp_id, _cp_layer)\n\n        if cp_id != Guid.Empty:\n            _IGH.scriptcontext.doc.Views.Redraw()\n\n    return cp_id\n\n\ndef align_to_detail_view(_model_annotations):\n    # type: (Iterable[TextAnnotation]) -> bool\n    \"\"\"Check if all the model-annotations have the same 'Align to Layout View' attribute value.\"\"\"\n\n    all_values = {a.align_to_layout_view for a in _model_annotations}\n\n    if all_values == {True}:  # All True\n        return True\n    elif all_values == {False}:  # All False\n        return False\n    else:\n        msg = \"Error: Model-Annotation 'Align to Layout View' attribute values are not all the same?\"\n        raise Exception(msg)\n\n\ndef export_pdfs(\n    _IGH,\n    _file_paths,\n    _layout_names,\n    _layers_on,\n    _cp_loc,\n    _geom,\n    _geom_attrs,\n    _model_annotations,\n    _layout_annotations,\n    _remove_baked_items,\n    _raster,\n):\n    # type: (gh_io.IGH, List[str], List[str], List[str], DataTree[ClippingPlaneLocation],DataTree[Guid], DataTree[rdo.ObjectAttributes], DataTree[TextAnnotation], DataTree[TextAnnotation],bool,bool) -> None\n    \"\"\"\n\n    Arguments:\n    ----------\n        * _IGH (gh_io.IGH): Grasshopper Interface.\n        * _file_paths (List[str]): A list of the full file-paths to save out to.\n        * _layout_name (str): The name of the Layout (View) to export as PDF\n        * _layers_on (List[str]): A list of the layer-names to leave 'on' during export.\n        * _cp_loc (DataTree[ClippingPlaneLocation]):\n        * _geom (DataTree[Guid]):\n        * _geom_attrs (DataTree[ObjectAttributes]):\n        * _model_annotations (DataTree[LayoutPageLabel]):\n        * _layout_annotations (DataTree[LayoutPageLabel]):\n        * _raster (bool): Use raster output mode. default=False.\n\n    Returns:\n    --------\n        * None\n    \"\"\"\n    # -- Sort out the layers and views and transforms\n    starting_active_view_name = get_active_view_name(_IGH)\n    starting_active_layer_name = get_active_layer_name(_IGH)\n    starting_layer_visibilities = get_current_layer_visibilities(_IGH)\n\n    # -- Bake objects\n    for branch_num, geom_list in enumerate(_geom.Branches):\n        # --------------------------------------------------------------------------------------------------------------\n        # -- Setup the right layers for the Layout View being printed\n        layout_view_name = _layout_names[branch_num]\n        set_active_view_by_name(_IGH, layout_view_name)\n        layers_with_detail_views = find_layers_with_detail_views(_IGH)\n        layers_on = _layers_on + layers_with_detail_views\n        turn_off_all_layers(_IGH, _except_layers=layers_on)\n\n        # --------------------------------------------------------------------------------------------------------------\n        # -- Find the Layout's Detail-View objects and View-Transform\n        dtl_view_objs = get_detail_views_for_active_view(_IGH)\n        dtl_view_transform = get_layout_view_transform(\n            _IGH, dtl_view_objs, layout_view_name\n        )\n\n        # --------------------------------------------------------------------------------------------------------------\n        # -- Create new temporary output layers\n        geom_bake_layer = create_bake_layer(_IGH)  # Geometry\n        label_bake_layer = create_bake_layer(_IGH)  # Text Labels\n        cp_layer = create_bake_layer(_IGH)  # Clipping Planes\n\n        try:\n            # ----------------------------------------------------------------------------------------------------------\n            # -- Bake the Geometry into the Scene\n            set_active_view_by_name(_IGH, \"Top\")  # Change to 'Top' View for Baking\n            for i, geom_obj in enumerate(geom_list):\n                # -- Object Attribute\n                attr_obj = _geom_attrs.Branch(branch_num)[i]\n\n                # -- Bake Geometry to the specified layer\n                bake_geometry_object(_IGH, geom_obj, attr_obj, geom_bake_layer)\n\n            # ----------------------------------------------------------------------------------------------------------\n            # -- Add any ClippingPlanes into the scene\n            try:\n                for cp in clean_tree_get(_cp_loc, branch_num, []):\n                    add_clipping_plane(_IGH, cp, cp_layer, dtl_view_objs)\n            except ValueError as e:\n                msg = \"Error Adding Clipping Plane: {}\".format(e)\n                print(msg)\n                raise Exception(msg)\n\n            # ----------------------------------------------------------------------------------------------------------\n            # -- Bake Model-Space Annotations (text in the RH model space)\n            if _model_annotations.BranchCount != 0:\n                # -- Set the right view for baking\n                align_annotations = align_to_detail_view(\n                    _model_annotations.Branch(branch_num)\n                )\n                if align_annotations == True:\n                    set_active_view_by_name(_IGH, layout_view_name)\n                else:\n                    set_active_view_by_name(_IGH, \"Perspective\")\n\n                # -- Bake the Annotations to the Rhino Scene\n                text_bounding_boxes = []  # the annotations's bounding boxes\n                for model_annotation in _model_annotations.Branch(branch_num):\n                    # -- If the annotation needs to be rotated to match the view, execute the transform\n                    if align_annotations == True:\n                        # -- Transform (Rotate) the Annotation's Location to match the Detail-View\n                        model_annotation = model_annotation.transform(dtl_view_transform)\n\n                    # -- Bake the text to the Rhino view\n                    text_bounding_box = bake_annotation_object(\n                        _IGH=_IGH,\n                        _annotation=model_annotation,\n                        _target_layer=label_bake_layer,\n                        _avoid_collisions=False,\n                        _neighbors=text_bounding_boxes,\n                    )\n\n                    # -- Keep track of bounding boxes for collision detection later\n                    text_bounding_boxes.append(text_bounding_box)\n\n            # ----------------------------------------------------------------------------------------------------------\n            # -- Bake Paper-Space Title-block Labels to the specified layer\n            set_active_view_by_name(_IGH, layout_view_name)\n            try:\n                for layout_annotation in _layout_annotations.Branch(branch_num):\n                    bake_annotation_object(_IGH, layout_annotation, label_bake_layer)\n            except ValueError as e:\n                # No Layout Annotations for this Branch-number\n                pass\n\n            # ----------------------------------------------------------------------------------------------------------\n            # # -- Export PDF file\n            set_active_view_by_name(_IGH, layout_view_name)\n            export_single_pdf(_IGH, _file_paths[branch_num], _raster=_raster)\n        finally:\n            # ----------------------------------------------------------------------------------------------------------\n            # -- Cleanup baked items\n            if _remove_baked_items != False:\n                print(\"Removing Bake-Layers\")\n                remove_bake_layer(_IGH, geom_bake_layer)\n                remove_bake_layer(_IGH, label_bake_layer)\n                remove_bake_layer(_IGH, cp_layer)\n\n    # -- Cleanup layer vis and active view\n    reset_all_layer_visibility(_IGH, starting_layer_visibilities)\n    set_active_view_by_name(_IGH, starting_active_view_name)\n    set_active_layer_by_name(_IGH, starting_active_layer_name)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}