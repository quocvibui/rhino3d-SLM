{
  "source_url": "https://github.com/j0hnm4r5/portfolio-projects/blob/fe4f5b2fd5be055b59ae6bcf0387b0dd4b07691b/Computing%20Drawing/Boids-Code/*flockingStartEndObstacles.py",
  "repo": "j0hnm4r5/portfolio-projects",
  "repo_stars": 1,
  "repo_description": "Code for projects on john-mars.com",
  "license": "NOASSERTION",
  "filepath": "Computing Drawing/Boids-Code/*flockingStartEndObstacles.py",
  "instruction": "*flocking start end obstacles",
  "code": "import rhinoscriptsyntax as rs\nimport random, math\nfrom operator import itemgetter\n\n\"\"\"\nFor each agent, for each increment of time:\na) Avoid crowding local flockmates. Steer to keep a minimum distance between each agent and the ones around it. In flocking models, a boid (bird/droid) reacts only to flockmates within a certain neighborhood around itself; there is no global steering intelligence. The neighborhood is defined by a distance from the center of the boid and the angle around it, measured by its direction of travel.\nb) Align towards the average heading of local flockmates.\nc) Cohere to the flock: move toward the center of mass of local flockmates. The center of mass is the average position of all the agents.\n\"\"\"\n\nclass Boid(object):\n\n\tSZ_radius = 1\n\tNZ_radius = 5\n\tNZ_angle = 270\n\n\tseparation_factor = 1\n\talignment_factor = 1\n\tcohesion_factor = .1\n\tavoidance_factor = 10\n\tstriver_factor = 1\n\n\tdef __init__(self, guid, heading, goal, obstacles):\n\t\t\"\"\" CREATE A BOID \"\"\"\n\n\t\tself.guid = guid\n\n\t\tself.position = rs.PointCoordinates(self.guid)\n\t\tself.heading = heading\n\n\t\tself.goal = goal\n\n\t\tself.obstacles = obstacles\n\n\t\tself.SZ_neighbors = []\n\t\tself.NZ_neighbors = []\n\n\t\tself.NZ_avg_heading = []\n\t\tself.NZ_center_of_mass = []\n\n\t\tself.separation_vector = (0,0,0)\n\t\tself.alignment_vector = (0,0,0)\n\t\tself.cohesion_vector = (0,0,0)\n\t\tself.avoidance_vector = (0,0,0)\n\t\tself.striver_vector = (0,0,0)\n\n\t\tself.path_pts = []\n\t\tself.path_guid = \"\"\n\t\tself.path_pts.append(self.position)\n\n\tdef get_SZ_neighbors(self, population):\n\t\t\"\"\" IF AGENT IS WITHIN SZ, MAKE IT AN SZ NEIGHBOR \"\"\"\n\n\t\tself.SZ_neighbors = []\n\n\t\tfor agent in population:\n\t\t\tdistance = rs.Distance(self.guid, agent.guid)\n\t\t\tif (distance != 0) and (distance < Boid.SZ_radius):\n\t\t\t\tself.SZ_neighbors.append(agent)\n\n\tdef get_NZ_neighbors(self, population):\n\t\t\"\"\" IF AGENT IS WITHIN NZ, MAKE IT AN NZ NEIGHBOR \"\"\"\n\n\t\tself.NZ_neighbors = []\n\t\tcenter_cone = rs.VectorReverse(self.heading)\n\n\t\tfor agent in population:\n\t\t\tdistance = rs.Distance(self.guid, agent.guid)\n\t\t\tif distance != 0:\n\t\t\t\tagent_angle = rs.VectorAngle(rs.VectorCreate(self.guid, agent.guid), center_cone)\n\t\t\t\tif (distance < Boid.NZ_radius) and (agent_angle < Boid.NZ_angle / 2):\n\t\t\t\t\tself.NZ_neighbors.append(agent)\n\n\n\tdef separate(self):\n\t\t\"\"\" MOVE AWAY FROM NEIGHBORS IN SZ \"\"\"\n\n\t\tself.separation_vector = (0,0,0)\n\t\tif len(self.SZ_neighbors) > 0:\n\n\t\t\tfor neighbor in self.SZ_neighbors:\n\t\t\t\tself.separation_vector = rs.VectorAdd(rs.VectorCreate(self.position, neighbor.position), self.separation_vector)\n\n\t\t\tself.separation_vector = rs.VectorDivide(self.separation_vector, len(self.SZ_neighbors))\n\t\t\tself.separation_vector = rs.VectorScale(self.separation_vector, Boid.separation_factor)\n\n\tdef align(self):\n\t\t\"\"\" ALIIGN TOWARDS AVERAGE HEADING OF NEIGHBORS \"\"\"\n\n\t\tself.NZ_avg_heading = (0,0,0)\n\n\t\tif len(self.NZ_neighbors) > 0:\n\t\t\tfor neighbor in self.NZ_neighbors:\n\t\t\t\tself.NZ_avg_heading = rs.VectorAdd(self.NZ_avg_heading, neighbor.heading)\n\n\t\t\tself.NZ_avg_heading = rs.VectorDivide(self.NZ_avg_heading, len(self.NZ_neighbors))\n\n\t\t\tself.alignment_vector = rs.VectorScale(self.NZ_avg_heading, Boid.alignment_factor)\n\n\tdef cohere(self):\n\t\t\"\"\" MOVE TOWARD THE CENTER OF MASS OF NEIGHBORS \"\"\"\n\n\t\tself.NZ_center_of_mass = (0,0,0)\n\n\t\tif len(self.NZ_neighbors) > 0:\n\n\t\t\tfor neighbor in self.NZ_neighbors:\n\t\t\t\tself.NZ_center_of_mass = rs.VectorAdd(self.NZ_center_of_mass, neighbor.position)\n\n\t\t\tself.NZ_center_of_mass = rs.VectorDivide(self.NZ_center_of_mass, len(self.NZ_neighbors))\n\n\t\t\tself.cohesion_vector = rs.VectorCreate(self.NZ_center_of_mass, self.position)\n\t\t\tself.cohesion_vector = rs.VectorScale(self.cohesion_vector, Boid.cohesion_factor)\n\n\tdef avoid(self):\n\t\t\"\"\" AVOID OBSTACLES \"\"\"\n\n\t\tif self.obstacles != None:\n\n\t\t\tavoidance_line = rs.VectorScale(self.heading, Boid.avoidance_factor)\n\t\t\tavoidance_line = rs.AddLine(self.position, rs.PointAdd(self.position, avoidance_line))\n\n\t\t\ti = 0\n\t\t\tfor obstacle in self.obstacles:\n\t\t\t\tcsx = rs.CurveSurfaceIntersection(avoidance_line, obstacle)\n\t\t\t\ti += 1\n\t\t\t\tif csx != None:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tcsx = None\n\n\t\t\tif csx != None:\n\t\t\t\tcentroid = rs.SurfaceAreaCentroid(self.obstacles[i-1])\n\t\t\t\tcentroid = rs.AddPoint(centroid[0])\n\t\t\t\tself.avoidance_vector = rs.VectorCreate(centroid, self.guid)\n\t\t\t\tprint self.avoidance_vector\n\t\t\t\taxis = rs.VectorCreate(rs.CurveStartPoint(avoidance_line), rs.CurveEndPoint(avoidance_line))\n\t\t\t\tself.avoidance_vector = rs.VectorRotate(self.avoidance_vector, 180, axis)\n\t\t\t\t# print self.avoidance_vector\n\n\t\t\telse:\n\t\t\t\tself.avoidance_vector = (0,0,0)\n\n\t\t\trs.DeleteObject(avoidance_line)\n\n\n\tdef strive(self):\n\t\t\"\"\" HEAD TOWARDS GOAL \"\"\"\n\n\t\tself.striver_vector = rs.VectorScale(rs.VectorUnitize(rs.VectorCreate(self.goal, self.position)), Boid.striver_factor)\n\n\n\tdef update_heading(self):\n\t\t\"\"\" AVERAGE SEPARATION, ALIGNMENT, AND COHESION VECTORS \"\"\"\n\n\t\tself.separate()\n\t\tself.align()\n\t\tself.cohere()\n\t\tself.avoid()\n\t\tself.strive()\n\n\t\tself.heading = rs.VectorAdd(self.heading, self.separation_vector)\n\t\tself.heading = rs.VectorAdd(self.heading, self.alignment_vector)\n\t\tself.heading = rs.VectorAdd(self.heading, self.cohesion_vector)\n\t\tself.heading = rs.VectorAdd(self.heading, self.avoidance_vector)\n\t\tself.heading = rs.VectorAdd(self.heading, self.striver_vector)\n\t\tself.heading = rs.VectorDivide(self.heading, 5)\n\n\tdef move(self):\n\t\t\"\"\" MOVE A BOID \"\"\"\n\n\t\tself.position = rs.PointAdd(self.position, self.heading)\n\t\tself.path_pts.append(self.position)\n\t\trs.DeleteObject(self.guid)\n\t\tself.guid = rs.AddPoint(self.position)\n\n\n\tdef update(self, population):\n\t\t\"\"\" CHANGE HEADING AND MOVE BOID \"\"\"\n\n\t\tself.get_SZ_neighbors(population)\n\t\tself.get_NZ_neighbors(population)\n\t\tself.update_heading()\n\t\tself.move()\n\n\tdef draw_path(self):\n\t\t\"\"\" DRAW BOID'S PATH \"\"\"\n\n\t\tif self.path_guid:\n\t\t\trs.DeleteObject(self.path_guid)\n\t\tself.path_guid = rs.AddCurve(self.path_pts)\n\ndef main():\n\n\tstart_line = rs.GetObject(\"Pick starting line:\", 4)\n\tdivision_pts = rs.DivideCurve(start_line, 10, False, True)\n\tpopulation_pts = []\n\tfor pt in division_pts:\n\t\tpopulation_pts.append(rs.AddPoint(pt))\n\n\tinitial_heading = rs.GetObject(\"Pick initial heading:\", 4)\n\tinitial_heading = rs.VectorCreate(rs.CurveEndPoint(initial_heading), rs.CurveStartPoint(initial_heading))\n\n\tend_heading = rs.GetObject(\"Pick end heading:\", 4)\n\tend_heading = rs.VectorCreate(rs.CurveStartPoint(end_heading), rs.CurveEndPoint(end_heading))\n\n\tend_line = rs.GetObject(\"Pick ending line:\", 4)\n\tdivision_pts = rs.DivideCurve(end_line, 10, False, True)\n\tgoal_pts = []\n\tfor pt in division_pts:\n\t\tgoal_pts.append(rs.AddPoint(pt))\n\teasing_goal_pts = rs.CopyObjects(goal_pts, rs.VectorReverse(end_heading))\n\n\tobstacles = rs.GetObjects(\"Pick possible obstacles:\", 24)\n\n\n\tpopulation = []\n\ti = 0\n\twhile i < len(population_pts):\n\t\tpopulation.append(Boid(population_pts[i], initial_heading, easing_goal_pts[i], obstacles))\n\t\ti += 1\n\n\tfinished = []\n\twhile len(finished) < len(goal_pts):\n\t\tfor boid in population:\n\t\t\tif rs.Distance(boid.position, boid.goal) > 2.5:\n\t\t\t\tboid.update(population)\n\t\t\telse:\n\t\t\t\tboid.update(population)\n\t\t\t\tfinished.append(boid)\n\t\t\t\tpopulation.remove(boid)\n\n\tcoordinate_sum = []\n\tfor boid in finished:\n\t\tcoordinate_sum.append((boid, boid.position[0] + boid.position[1] + boid.position[2]))\n\n\tcoordinate_sum = sorted(coordinate_sum, key=itemgetter(1))\n\tfinished, numbers = zip(*coordinate_sum)\n\n\tgoal_pts.reverse()\n\n\ti = 0\n\tfor boid in finished:\n\t\tboid.path_pts.append(rs.PointCoordinates(goal_pts[i]))\n\t\ti += 1\n\n\n\tfor boid in finished:\n\t\tboid.draw_path()\n\n\t# points = rs.ObjectsByType(1)\n\t# rs.DeleteObject(points)\n\nmain()",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}