{
  "source_url": "https://github.com/compas-dev/compas/blob/HEAD/src/compas_rhino/geometry/brep/face.py",
  "repo": "compas-dev/compas",
  "repo_stars": 352,
  "repo_description": "Main library of the COMPAS framework and CAD integrations for Rhino/GH and Blender.",
  "license": "MIT",
  "filepath": "src/compas_rhino/geometry/brep/face.py",
  "instruction": null,
  "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport Rhino  # type: ignore\n\nfrom compas.geometry import Brep\nfrom compas.geometry import BrepFace\nfrom compas.geometry import Cylinder\nfrom compas.geometry import Frame\nfrom compas.geometry import Sphere\nfrom compas.geometry import SurfaceType\nfrom compas_rhino.conversions import cylinder_to_compas\nfrom compas_rhino.conversions import cylinder_to_rhino\nfrom compas_rhino.conversions import frame_to_rhino_plane\nfrom compas_rhino.conversions import plane_to_compas_frame\nfrom compas_rhino.conversions import sphere_to_compas\nfrom compas_rhino.conversions import sphere_to_rhino\nfrom compas_rhino.geometry import RhinoNurbsSurface\nfrom compas_rhino.geometry.surfaces import RhinoSurface\n\nfrom .edge import RhinoBrepEdge\nfrom .loop import RhinoBrepLoop\n\n\nclass RhinoBrepFace(BrepFace):\n    \"\"\"A wrapper for Rhino.Geometry.BrepFace\n\n    Attributes\n    ----------\n    native_surface : :class:`Rhino.Geometry.Surface`\n        The rhino native underlying geometry of this face.\n    loops : list[:class:`compas_rhino.geometry.RhinoBrepLoop`], read-only\n        The list of loops which comprise this face.\n    surface : :class:`compas_rhino.geometry.RhinoNurbsSurface`\n        The compas_rhino wrapper of the underlying geometry of this face.\n    boundary : :class:`compas_rhino.geometry.RhinoBrepLoop`, read-only\n        The loop which defines the outer boundary of this face.\n    holes : list[:class:`compas_rhino.geometry.RhinoBrepLoop`], read-only\n        The list of loops which comprise the holes of this brep, if any.\n    is_plane : float, read-only\n        True if the geometry of this face is a plane, False otherwise.\n    is_reversed : bool, read-only\n        True if the orientation of this face is reversed, False otherwise.\n    native_face : :class:`Rhino.Geometry.BrepFace`\n        The underlying BrepFace object.\n\n    \"\"\"\n\n    def __init__(self, rhino_face=None):\n        super(RhinoBrepFace, self).__init__()\n        self._loops = None\n        self._surface = None\n        self._face = None\n        if rhino_face:\n            self.native_face = rhino_face\n\n    # ==============================================================================\n    # Data\n    # ==============================================================================\n\n    @property\n    def __data__(self):\n        surface_type, surface, uv_domain, plane = self._get_surface_geometry(self._face.UnderlyingSurface())\n        return {\n            \"surface_type\": surface_type,\n            \"surface\": surface.__data__,\n            \"uv_domain\": uv_domain,\n            \"frame\": plane_to_compas_frame(plane).__data__,  # until all shapes have a frame\n            \"loops\": [loop.__data__ for loop in self._loops],\n        }\n\n    @classmethod\n    def __from_data__(cls, data, builder):\n        \"\"\"Construct an object of this type from the provided data.\n\n        Parameters\n        ----------\n        data : dict\n            The data dictionary.\n        builder : :class:`compas_rhino.geometry.BrepBuilder`\n            The object reconstructing the current Brep.\n\n        Returns\n        -------\n        :class:`compas.data.Data`\n            An instance of this object type if the data contained in the dict has the correct schema.\n\n        \"\"\"\n\n        instance = cls()\n        instance._surface = instance._make_surface__from_data__(data[\"surface_type\"], data[\"surface\"], data[\"uv_domain\"], data[\"frame\"])\n        face_builder = builder.add_face(instance._surface)\n        for loop_data in data[\"loops\"]:\n            RhinoBrepLoop.__from_data__(loop_data, face_builder)\n        instance.native_face = face_builder.result\n        return instance\n\n    # ==============================================================================\n    # Properties\n    # ==============================================================================\n\n    @property\n    def native_surface(self):\n        return self._surface\n\n    @property\n    def area(self):\n        return self._mass_props.Area\n\n    @property\n    def centroid(self):\n        return self._mass_props.Centroid\n\n    @property\n    def edges(self):\n        brep = self._face.Brep\n        edge_indices = self._face.AdjacentEdges()\n        return [RhinoBrepEdge(brep.Edges[index]) for index in edge_indices]\n\n    @property\n    def loops(self):\n        return self._loops\n\n    @property\n    def surface(self):\n        return self._surface\n\n    @property\n    def boundary(self):\n        return self._loops[0]\n\n    @property\n    def holes(self):\n        return self._loops[1:]\n\n    @property\n    def is_plane(self):\n        return self._face.UnderlyingSurface().IsPlanar()\n\n    @property\n    def is_cone(self):\n        return self._face.UnderlyingSurface().IsCone()\n\n    @property\n    def is_cylinder(self):\n        return self._face.UnderlyingSurface().IsCylinder()\n\n    @property\n    def is_sphere(self):\n        return self._face.UnderlyingSurface().IsSphere()\n\n    @property\n    def is_torus(self):\n        return self._face.UnderlyingSurface().IsTorus()\n\n    @property\n    def is_reversed(self):\n        return self._face.OrientationIsReversed\n\n    @property\n    def native_face(self):\n        return self._face\n\n    @native_face.setter\n    def native_face(self, rhino_face):\n        self._face = rhino_face\n        self._mass_props = Rhino.Geometry.AreaMassProperties.Compute(rhino_face.ToBrep())\n        self._loops = [RhinoBrepLoop(loop) for loop in rhino_face.Loops]\n        self._surface = RhinoNurbsSurface.from_rhino(self._face.UnderlyingSurface().ToNurbsSurface())\n\n    @property\n    def nurbssurface(self):\n        return self._surface\n\n    @property\n    def vertices(self):\n        vertices = []\n        for edge in self.edges:\n            vertices.extend(edge.vertices)\n        return vertices\n\n    @property\n    def type(self):\n        if self.is_cone:\n            return SurfaceType.CONE\n        elif self.is_cylinder:\n            return SurfaceType.CYLINDER\n        elif self.is_sphere:\n            return SurfaceType.SPHERE\n        elif self.is_torus:\n            return SurfaceType.TORUS\n        elif self.is_plane:\n            return SurfaceType.PLANE\n        else:\n            return SurfaceType.OTHER_SURFACE\n\n    # ==============================================================================\n    # Methods\n    # ==============================================================================\n\n    @staticmethod\n    def _get_surface_geometry(surface):\n        uv_domain = [[surface.Domain(0)[0], surface.Domain(0)[1]], [surface.Domain(1)[0], surface.Domain(1)[1]]]\n        if isinstance(surface, Rhino.Geometry.PlaneSurface):\n            _, plane = surface.FrameAt(0.0, 0.0)\n            return \"plane\", plane_to_compas_frame(plane), uv_domain, plane\n        if isinstance(surface, Rhino.Geometry.NurbsSurface):\n            _, plane = surface.FrameAt(0.0, 0.0)\n            return \"nurbs\", RhinoNurbsSurface.from_rhino(surface), uv_domain, plane\n        if isinstance(surface, Rhino.Geometry.RevSurface):\n            success, cast_surface = surface.TryGetSphere()\n            if success:\n                return \"sphere\", sphere_to_compas(cast_surface), uv_domain, cast_surface.EquatorialPlane\n            success, cast_surface = surface.TryGetCylinder()\n            if success:\n                return \"cylinder\", cylinder_to_compas(cast_surface), uv_domain, cast_surface.BasePlane\n            success, cast_surface = surface.TryGetTorus()\n        raise NotImplementedError(\"Support for surface type: {} is not yet implemented.\".format(surface.__class__.__name__))\n\n    def _make_surface__from_data__(self, surface_type, surface_data, uv_domain, frame_data):\n        u_domain, v_domain = uv_domain\n        frame = Frame.__from_data__(frame_data)  # workaround until all shapes have a frame\n        if surface_type == \"plane\":\n            frame = Frame.__from_data__(surface_data)  # redundancy in shapes which already have a frame\n            surface = RhinoSurface.from_frame(frame, u_domain, v_domain)\n        elif surface_type == \"sphere\":\n            sphere = self._make_sphere_surface(surface_data, u_domain, v_domain, frame)\n            surface = RhinoSurface.from_rhino(sphere)\n        elif surface_type == \"cylinder\":\n            cylinder = self._make_cylinder_surface(surface_data, u_domain, v_domain, frame)\n            surface = RhinoSurface.from_rhino(cylinder)\n        elif surface_type == \"nurbs\":\n            surface = RhinoNurbsSurface.__from_data__(surface_data)\n        elif surface_type == \"torus\":\n            raise NotImplementedError(\"Support for torus surface is not yet implemented!\")\n        else:\n            raise NotImplementedError(\"Support for surface type: {} is not yet implemented.\".format(surface_type))\n        surface.rhino_surface.SetDomain(0, Rhino.Geometry.Interval(*u_domain))\n        surface.rhino_surface.SetDomain(1, Rhino.Geometry.Interval(*v_domain))\n        return surface\n\n    @staticmethod\n    def _make_cylinder_surface(surface_data, u_domain, v_domain, frame):\n        cylinder = Cylinder.__from_data__(surface_data)\n        cylinder = cylinder_to_rhino(cylinder)\n        cylinder.BasePlane = frame_to_rhino_plane(frame)\n        surface = Rhino.Geometry.RevSurface.CreateFromCylinder(cylinder)\n        surface.SetDomain(0, Rhino.Geometry.Interval(*u_domain))\n        surface.SetDomain(1, Rhino.Geometry.Interval(*v_domain))\n        return surface\n\n    @staticmethod\n    def _make_sphere_surface(surface_data, u_domain, v_domain, frame):\n        sphere = Sphere.__from_data__(surface_data)\n        sphere = sphere_to_rhino(sphere)\n        # seems Sphere => Rhino.Geometry.RevSurface conversion modifies the orientation of the sphere\n        # setting the plane here is overriden by this modification and surface ends up oriented differntly than\n        # original.\n        # sphere.EquatorialPlane = frame_to_rhino_plane(frame)\n        surface = Rhino.Geometry.RevSurface.CreateFromSphere(sphere)\n        surface.SetDomain(0, Rhino.Geometry.Interval(*u_domain))\n        surface.SetDomain(1, Rhino.Geometry.Interval(*v_domain))\n        return surface\n\n    # ==============================================================================\n    # Methods\n    # ==============================================================================\n\n    def adjacent_faces(self):\n        \"\"\"Returns a list of the faces adjacent to this face.\n\n        Returns\n        -------\n        list[:class:`compas_rhino.geometry.RhinoBrepFace`]\n            The list of adjacent faces.\n\n        \"\"\"\n        face_indices = self._face.AdjacentFaces()\n        brep = self._face.Brep\n        return [RhinoBrepFace(brep.Faces[index]) for index in face_indices]\n\n    def as_brep(self):\n        \"\"\"Returns a Brep representation of this face.\n\n        Returns\n        -------\n        :class:`~compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        return Brep.from_native(self._face.ToBrep())\n\n    def frame_at(self, u, v):\n        \"\"\"Returns the frame at the given uv parameters.\n\n        Parameters\n        ----------\n        u : float\n            The u parameter.\n        v : float\n            The v parameter.\n\n        Returns\n        -------\n        :class:`compas.geometry.Frame`\n            The frame at the given uv parameters.\n\n        \"\"\"\n        success, rhino_plane = self._face.FrameAt(u, v)\n        if not success:\n            raise ValueError(\"Failed to get frame at uv parameters: ({},{}).\".format(u, v))\n        return plane_to_compas_frame(rhino_plane)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}