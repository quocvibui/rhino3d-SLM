{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_geometry_converter.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_geometry_converter.py",
  "instruction": "Geometry Converter for Grasshopper.",
  "code": "# File: scripts/gh_geometry_converter.py\n\"\"\"Geometry Converter for Grasshopper.\n\nConverts framing elements JSON to RhinoCommon geometry (Breps and Curves).\nThis is the final stage of the modular pipeline, handling the assembly\nmismatch issue by using the RhinoCommonFactory.\n\nKey Features:\n1. Assembly-Safe Geometry Creation\n   - Uses RhinoCommonFactory for correct RhinoCommon assembly\n   - Avoids Rhino3dmIO/RhinoCommon mismatch issues\n   - Geometry verified for Grasshopper compatibility\n\n2. Flexible Filtering\n   - Filter by element type (stud, plate, header, etc.)\n   - Filter by wall ID for single-wall visualization\n   - Multiple output organizations (flat, by-type, by-wall)\n\n3. Multiple Output Formats\n   - Flat list of all Breps\n   - DataTree organized by element type\n   - DataTree organized by wall ID\n   - Centerline curves for visualization\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n\nDependencies:\n    - Rhino.Geometry: Core geometry types\n    - Grasshopper: DataTree for organized output\n    - timber_framing_generator.utils.geometry_factory: RhinoCommonFactory\n    - timber_framing_generator.core.json_schemas: JSON deserialization\n\nPerformance Considerations:\n    - Processing time scales linearly with element count\n    - Memory usage proportional to geometry complexity\n    - Large walls (>1000 elements) may take several seconds\n\nUsage:\n    1. Connect 'framing_json' from Framing Generator\n    2. Optionally set 'filter_types' to filter specific element types\n    3. Optionally set 'filter_wall' to show only one wall's framing\n    4. Set 'run' to True to execute\n    5. Connect 'breps' to display or bake geometry\n\nInput Requirements:\n    Framing JSON (framing_json) - str:\n        JSON string from Framing Generator containing framing elements\n        Required: Yes\n        Access: Item\n\n    Filter Types (filter_types) - str:\n        Comma-separated element types to include (e.g., \"stud,plate\")\n        Required: No (shows all types)\n        Access: Item\n\n    Filter Wall (filter_wall) - str:\n        Wall ID to filter (e.g., \"1234567\" for single wall)\n        Required: No (shows all walls)\n        Access: Item\n\n    Run (run) - bool:\n        Boolean to trigger execution\n        Required: Yes\n        Access: Item\n\nOutputs:\n    Breps (breps) - list[Brep]:\n        All framing elements as Brep geometry\n\n    By Type (by_type) - DataTree[Brep]:\n        Breps organized by element type in branches\n\n    By Wall (by_wall) - DataTree[Brep]:\n        Breps organized by wall ID in branches\n\n    Centerlines (centerlines) - list[Curve]:\n        Centerline curves for each element\n\n    Element IDs (element_ids) - list[str]:\n        Element IDs for selection feedback\n\n    Wall IDs (wall_ids) - list[str]:\n        List of unique wall IDs found in data\n\n    Debug Info (debug_info) - str:\n        Debug information and status messages\n\nTechnical Details:\n    - Uses RhinoCommonFactory to ensure correct assembly\n    - Box geometry created from centerline + profile dimensions\n    - Wall direction from element metadata for correct orientation\n\nError Handling:\n    - Invalid JSON returns empty outputs with error in debug_info\n    - Missing elements logged but don't halt execution\n    - Invalid geometry creation logged and skipped\n\nAuthor: Timber Framing Generator\nVersion: 1.1.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\n# Rhino / Grasshopper\nimport Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\n# =============================================================================\n# Force Module Reload (CPython 3 in Rhino 8)\n# =============================================================================\n\n# Clear timber_framing_generator modules AND the 'src' package itself.\n_modules_to_clear = [k for k in sys.modules.keys()\n                     if 'timber_framing_generator' in k\n                     or k == 'src']\nfor mod in _modules_to_clear:\n    del sys.modules[mod]\n\n# =============================================================================\n# Project Setup\n# =============================================================================\n\n# Primary: worktree / feature-branch path\n# Fallback: main repo path (for modules not yet in the worktree)\n_WORKTREE_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\tfg-sheathing-junctions\"\n_MAIN_REPO_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator\"\n\nfor _p in (_WORKTREE_PATH, _MAIN_REPO_PATH):\n    while _p in sys.path:\n        sys.path.remove(_p)\nsys.path.insert(0, _MAIN_REPO_PATH)\nsys.path.insert(0, _WORKTREE_PATH)\n\nfrom src.timber_framing_generator.utils.geometry_factory import get_factory\nfrom src.timber_framing_generator.core.json_schemas import (\n    deserialize_framing_results, FramingElementData, Point3D\n)\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Geometry Converter\"\nCOMPONENT_NICKNAME = \"GeoConv\"\nCOMPONENT_MESSAGE = \"v1.1\"\nCOMPONENT_CATEGORY = \"Timber Framing\"\nCOMPONENT_SUBCATEGORY = \"Geometry\"\n\n# Element type to branch index mapping\nTYPE_ORDER = [\n    \"bottom_plate\", \"top_plate\", \"stud\", \"king_stud\", \"trimmer\",\n    \"header\", \"sill\", \"header_cripple\", \"sill_cripple\", \"blocking\",\n    \"track\", \"web_stiffener\", \"bridging\",\n]\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message, level=\"info\"):\n    \"\"\"Log to console and optionally add GH runtime message.\"\"\"\n    print(f\"[{level.upper()}] {message}\")\n\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n\n\ndef log_debug(message):\n    \"\"\"Log debug message (console only).\"\"\"\n    print(f\"[DEBUG] {message}\")\n\n\ndef log_info(message):\n    \"\"\"Log info message (console only).\"\"\"\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message):\n    \"\"\"Log warning message (console + GH UI).\"\"\"\n    log_message(message, \"warning\")\n\n\ndef log_error(message):\n    \"\"\"Log error message (console + GH UI).\"\"\"\n    log_message(message, \"error\")\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\n\n    Configures:\n    1. Component metadata (name, category, etc.)\n    2. Input parameter names, descriptions, and access\n    3. Output parameter names and descriptions\n\n    Note: Output[0] is reserved for GH's internal 'out' - start from Output[1]\n\n    IMPORTANT: Type Hints cannot be set programmatically in Rhino 8.\n    They must be configured via UI: Right-click input → Type hint → Select type\n    \"\"\"\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs\n    # NOTE: Type Hints must be set via GH UI (right-click → Type hint)\n    inputs = ghenv.Component.Params.Input\n    input_config = [\n        (\"Framing JSON\", \"framing_json\", \"JSON string from Framing Generator\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Filter Types\", \"filter_types\", \"Comma-separated element types to include\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Filter Wall\", \"filter_wall\", \"Wall ID to filter (single wall view)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Run\", \"run\", \"Boolean to trigger execution\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    # Configure outputs (start from index 1)\n    outputs = ghenv.Component.Params.Output\n    output_config = [\n        (\"Breps\", \"breps\", \"All framing elements as Breps\"),\n        (\"By Type\", \"by_type\", \"DataTree of Breps by element type\"),\n        (\"By Wall\", \"by_wall\", \"DataTree of Breps by wall ID\"),\n        (\"Centerlines\", \"centerlines\", \"Centerline curves for each element\"),\n        (\"Element IDs\", \"element_ids\", \"Element IDs for selection\"),\n        (\"Wall IDs\", \"wall_ids\", \"Unique wall IDs found in data\"),\n        (\"Debug Info\", \"debug_info\", \"Debug information and status\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef validate_inputs(framing_json, run):\n    \"\"\"Validate component inputs.\n\n    Args:\n        framing_json: JSON string with framing data\n        run: Boolean trigger\n\n    Returns:\n        tuple: (is_valid, error_message)\n    \"\"\"\n    if not run:\n        return False, \"Component not running. Set 'run' to True.\"\n\n    if not framing_json:\n        return False, \"No framing_json input provided\"\n\n    try:\n        json.loads(framing_json)\n    except json.JSONDecodeError as e:\n        return False, f\"Invalid JSON in framing_json: {e}\"\n\n    return True, None\n\n\ndef element_type_to_branch_index(element_type):\n    \"\"\"Map element type to a consistent branch index.\n\n    Args:\n        element_type: Element type string (e.g., \"stud\", \"bottom_plate\")\n\n    Returns:\n        Integer index for GH_Path\n    \"\"\"\n    elem_lower = element_type.lower()\n    if elem_lower in TYPE_ORDER:\n        return TYPE_ORDER.index(elem_lower)\n    else:\n        return len(TYPE_ORDER) + hash(element_type) % 100\n\n\ndef create_brep_from_element(element, factory):\n    \"\"\"Create a Brep from a framing element.\n\n    Args:\n        element: FramingElementData with centerline and profile info\n        factory: RhinoCommonFactory instance\n\n    Returns:\n        Brep geometry or None if creation fails\n    \"\"\"\n    start = element.centerline_start\n    end = element.centerline_end\n\n    dx = end.x - start.x\n    dy = end.y - start.y\n    dz = end.z - start.z\n    length = (dx*dx + dy*dy + dz*dz) ** 0.5\n\n    if length < 0.001:\n        return None\n\n    direction = (dx/length, dy/length, dz/length)\n\n    # Extract wall direction from element metadata\n    wall_x_axis = None\n    wall_z_axis = None\n    if element.metadata:\n        wall_x_axis = element.metadata.get('wall_x_axis')\n        wall_z_axis = element.metadata.get('wall_z_axis')\n\n    return factory.create_box_brep_from_centerline(\n        start_point=(start.x, start.y, start.z),\n        direction=direction,\n        length=length,\n        width=element.profile.width,\n        depth=element.profile.depth,\n        wall_x_axis=wall_x_axis,\n        wall_z_axis=wall_z_axis,\n    )\n\n\ndef create_centerline_from_element(element, factory):\n    \"\"\"Create a LineCurve centerline from a framing element.\n\n    Args:\n        element: FramingElementData with centerline info\n        factory: RhinoCommonFactory instance\n\n    Returns:\n        LineCurve geometry or None if creation fails\n    \"\"\"\n    start = element.centerline_start\n    end = element.centerline_end\n\n    return factory.create_line_curve(\n        (start.x, start.y, start.z),\n        (end.x, end.y, end.z)\n    )\n\n\ndef get_element_wall_id(element):\n    \"\"\"Extract wall ID from element metadata or cell_id.\n\n    Args:\n        element: FramingElementData instance\n\n    Returns:\n        Wall ID string\n    \"\"\"\n    if element.metadata and element.metadata.get('wall_id'):\n        return element.metadata['wall_id']\n    elif element.cell_id:\n        parts = element.cell_id.split('_')\n        if len(parts) >= 2:\n            return parts[0]\n    elif '_' in element.id:\n        parts = element.id.split('_')\n        if len(parts) >= 1 and parts[0].isdigit():\n            return parts[0]\n    return 'unknown'\n\n\ndef process_geometry(results, filter_types_list, wall_filter, factory):\n    \"\"\"Process all elements to geometry.\n\n    Args:\n        results: Deserialized FramingResults\n        filter_types_list: List of element types to include (or None)\n        wall_filter: Wall ID to filter (or None)\n        factory: RhinoCommonFactory instance\n\n    Returns:\n        Tuple of (breps, type_groups, wall_groups, centerlines, element_ids, unique_walls)\n    \"\"\"\n    breps = []\n    type_groups = {}\n    type_names = {}\n    wall_groups = {}\n    centerlines = []\n    element_ids = []\n    unique_walls = set()\n\n    for element in results.elements:\n        elem_type = element.element_type.lower()\n        elem_wall_id = get_element_wall_id(element)\n        unique_walls.add(elem_wall_id)\n\n        # Apply filters\n        if filter_types_list and elem_type not in filter_types_list:\n            continue\n        if wall_filter and elem_wall_id != wall_filter:\n            continue\n\n        # Create Brep\n        brep = create_brep_from_element(element, factory)\n        if brep:\n            breps.append(brep)\n\n            # Group by type\n            branch_idx = element_type_to_branch_index(elem_type)\n            if branch_idx not in type_groups:\n                type_groups[branch_idx] = []\n                type_names[branch_idx] = elem_type\n            type_groups[branch_idx].append(brep)\n\n            # Group by wall\n            if elem_wall_id not in wall_groups:\n                wall_groups[elem_wall_id] = []\n            wall_groups[elem_wall_id].append(brep)\n\n            # Create centerline\n            centerline = create_centerline_from_element(element, factory)\n            if centerline:\n                centerlines.append(centerline)\n\n            element_ids.append(element.id)\n\n    return breps, type_groups, type_names, wall_groups, centerlines, element_ids, unique_walls\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main():\n    \"\"\"Main entry point for the component.\n\n    Returns:\n        tuple: (breps, by_type, by_wall, centerlines, element_ids, wall_ids, debug_info)\n    \"\"\"\n    setup_component()\n\n    # Initialize outputs\n    breps = []\n    by_type = DataTree[object]()\n    by_wall = DataTree[object]()\n    centerlines = []\n    element_ids = []\n    wall_ids = []\n    log_lines = []\n\n    try:\n        # Unwrap Grasshopper list wrappers\n        framing_json_input = framing_json\n        if isinstance(framing_json, (list, tuple)):\n            framing_json_input = framing_json[0] if framing_json else None\n\n        filter_types_input = filter_types if filter_types else None\n        if isinstance(filter_types, (list, tuple)):\n            filter_types_input = filter_types[0] if filter_types else None\n\n        filter_wall_input = filter_wall if filter_wall else None\n        if isinstance(filter_wall, (list, tuple)):\n            filter_wall_input = filter_wall[0] if filter_wall else None\n\n        # Validate inputs\n        is_valid, error_msg = validate_inputs(framing_json_input, run)\n        if not is_valid:\n            if error_msg and \"not running\" not in error_msg.lower():\n                log_warning(error_msg)\n            return breps, by_type, by_wall, centerlines, element_ids, wall_ids, error_msg\n\n        # Get geometry factory\n        factory = get_factory()\n\n        # Parse JSON\n        results = deserialize_framing_results(framing_json_input)\n\n        log_lines.append(f\"Geometry Converter v1.1\")\n        log_lines.append(f\"Material System: {results.material_system}\")\n        log_lines.append(f\"Total Elements: {len(results.elements)}\")\n        log_lines.append(\"\")\n\n        # Parse filter_types\n        filter_types_list = None\n        if filter_types_input:\n            filter_types_list = [f.strip().lower() for f in filter_types_input.split(',')]\n            log_lines.append(f\"Type Filter: {filter_types_list}\")\n\n        # Parse filter_wall\n        wall_filter = str(filter_wall_input).strip() if filter_wall_input else None\n        if wall_filter:\n            log_lines.append(f\"Wall Filter: {wall_filter}\")\n\n        # Process geometry\n        breps, type_groups, type_names, wall_groups, centerlines, element_ids, unique_walls = \\\n            process_geometry(results, filter_types_list, wall_filter, factory)\n\n        # Build by_type DataTree\n        for branch_idx in sorted(type_groups.keys()):\n            path = GH_Path(branch_idx)\n            for brep in type_groups[branch_idx]:\n                by_type.Add(brep, path)\n\n        # Build by_wall DataTree\n        sorted_walls = sorted(wall_groups.keys())\n        wall_id_to_branch = {wid: idx for idx, wid in enumerate(sorted_walls)}\n        for wall_id_key in sorted_walls:\n            path = GH_Path(wall_id_to_branch[wall_id_key])\n            for brep in wall_groups[wall_id_key]:\n                by_wall.Add(brep, path)\n\n        # Set wall_ids output\n        wall_ids = sorted(unique_walls)\n\n        # Summary\n        log_lines.append(\"\")\n        log_lines.append(f\"Unique Walls: {len(unique_walls)}\")\n        log_lines.append(f\"Wall IDs: {sorted(unique_walls)}\")\n        log_lines.append(\"\")\n        log_lines.append(\"Elements by Type:\")\n        for branch_idx in sorted(type_groups.keys()):\n            elem_type = type_names[branch_idx]\n            count = len(type_groups[branch_idx])\n            log_lines.append(f\"  [{branch_idx}] {elem_type}: {count}\")\n\n        log_lines.append(\"\")\n        log_lines.append(f\"Total Breps: {len(breps)}\")\n        log_lines.append(f\"Total Centerlines: {len(centerlines)}\")\n\n        # === BBOX DIAGNOSTICS ===\n        # Show actual world-space bounding boxes to verify framing positions\n        log_lines.append(\"\")\n        log_lines.append(\"=== Framing BBOX Diagnostic ===\")\n        stud_idx = TYPE_ORDER.index(\"stud\")\n        if stud_idx in type_groups:\n            stud_breps = type_groups[stud_idx]\n            for si, sbrep in enumerate(stud_breps[:3]):\n                try:\n                    bb = sbrep.GetBoundingBox(True)\n                    log_lines.append(\n                        f\"  Stud[{si}]: \"\n                        f\"min=({bb.Min.X:.4f}, {bb.Min.Y:.4f}, {bb.Min.Z:.4f})  \"\n                        f\"max=({bb.Max.X:.4f}, {bb.Max.Y:.4f}, {bb.Max.Z:.4f})  \"\n                        f\"size=({bb.Max.X-bb.Min.X:.4f}, \"\n                        f\"{bb.Max.Y-bb.Min.Y:.4f}, \"\n                        f\"{bb.Max.Z-bb.Min.Z:.4f})\"\n                    )\n                except Exception as ex:\n                    log_lines.append(f\"  Stud[{si}]: bbox error: {ex}\")\n        else:\n            log_lines.append(\"  No studs found in type_groups\")\n\n        plate_idx = TYPE_ORDER.index(\"bottom_plate\")\n        if plate_idx in type_groups:\n            for pi, pbrep in enumerate(type_groups[plate_idx][:1]):\n                try:\n                    bb = pbrep.GetBoundingBox(True)\n                    log_lines.append(\n                        f\"  Plate[{pi}]: \"\n                        f\"min=({bb.Min.X:.4f}, {bb.Min.Y:.4f}, {bb.Min.Z:.4f})  \"\n                        f\"max=({bb.Max.X:.4f}, {bb.Max.Y:.4f}, {bb.Max.Z:.4f})  \"\n                        f\"size=({bb.Max.X-bb.Min.X:.4f}, \"\n                        f\"{bb.Max.Y-bb.Min.Y:.4f}, \"\n                        f\"{bb.Max.Z-bb.Min.Z:.4f})\"\n                    )\n                except Exception as ex:\n                    log_lines.append(f\"  Plate[{pi}]: bbox error: {ex}\")\n\n    except Exception as e:\n        log_error(f\"Unexpected error: {str(e)}\")\n        log_lines.append(f\"ERROR: {str(e)}\")\n        log_lines.append(traceback.format_exc())\n\n    return breps, by_type, by_wall, centerlines, element_ids, wall_ids, \"\\n\".join(log_lines)\n\n# =============================================================================\n# Execution\n# =============================================================================\n\n# Set default values for optional inputs\ntry:\n    framing_json\nexcept NameError:\n    framing_json = None\n\ntry:\n    filter_types\nexcept NameError:\n    filter_types = None\n\ntry:\n    filter_wall\nexcept NameError:\n    filter_wall = None\n\ntry:\n    run\nexcept NameError:\n    run = False\n\n# Execute main\nif __name__ == \"__main__\":\n    breps, by_type, by_wall, centerlines, element_ids, wall_ids, debug_info = main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}