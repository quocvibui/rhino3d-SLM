{
  "source_url": "https://github.com/augmentedfabricationlab/robot_see_robot_do/blob/797efe013308af0cbf0f91203d4c47018dffab0a/src/robot_see_robot_do/assembly_reciprocal/assembly.py",
  "repo": "augmentedfabricationlab/robot_see_robot_do",
  "repo_stars": 4,
  "repo_description": null,
  "license": "MIT",
  "filepath": "src/robot_see_robot_do/assembly_reciprocal/assembly.py",
  "instruction": "Assembly",
  "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport json\nimport os\nimport math\nimport compas\n\nfrom copy import deepcopy\nfrom compas.geometry import Frame, Vector\nfrom compas.geometry import Transformation, Translation, Rotation\nfrom compas.geometry import distance_point_point\nfrom compas.datastructures import Network, network, mesh_offset\nfrom compas_ghpython.artists import MeshArtist\n\nimport rhinoscriptsyntax as rs\n\nfrom .element import Element\n\nfrom .utilities import FromToData\nfrom .utilities import FromToJson\nfrom .utilities import element_to_INCON \nfrom .utilities import tag_to_INCON\n\n__all__ = ['Assembly']\n\n\nclass Assembly(FromToData, FromToJson):\n    \"\"\"A data structure for discrete element assemblies.\n\n    An assembly is essentially a network of assembly elements.\n    Each element is represented by a node of the network.\n    Each interface or connection between elements is represented by an edge of the network.\n\n    Attributes\n    ----------\n    network : :class:`compas.Network`, optional\n    elements : list of :class:`Element`, optional\n        A list of assembly elements.\n    attributes : dict, optional\n        User-defined attributes of the assembly.\n        Built-in attributes are:\n        * name (str) : ``'Assembly'``\n    default_element_attribute : dict, optional\n        User-defined default attributes of the elements of the assembly.\n        The built-in attributes are:\n        * is_planned (bool) : ``False``\n        * is_placed (bool) : ``False``\n    default_connection_attributes : dict, optional\n        User-defined default attributes of the connections of the assembly.\n\n    Examples\n    --------\n    >>> assembly = Assembly()\n    >>> for i in range(2):\n    >>>     element = Element.from_box(Box(Frame.worldXY(), 10, 5, 2))\n    >>>     assembly.add_element(element)\n    \"\"\"\n\n    def __init__(self,\n                 elements=None,\n                 attributes=None,\n                 default_element_attributes=None,\n                 default_connection_attributes=None):\n\n        self.network = Network()\n        self.network.attributes.update({'name': 'Assembly'})\n\n        if attributes is not None:\n            self.network.attributes.update(attributes)\n\n        self.network.default_node_attributes.update({\n            'is_planned': False,\n            'is_placed': False\n        })\n\n        if default_element_attributes is not None:\n            self.network.default_node_attributes.update(default_element_attributes)\n\n        if default_connection_attributes is not None:\n            self.network.default_edge_attributes.update(default_connection_attributes)\n\n        if elements:\n            for element in elements:\n                self.add_element(element)\n\n    @property\n    def name(self):\n        \"\"\"str : The name of the assembly.\"\"\"\n        return self.network.attributes.get('name', None)\n\n    @name.setter\n    def name(self, value):\n        self.network.attributes['name'] = value\n\n    def number_of_elements(self):\n        \"\"\"Compute the number of elements of the assembly.\n\n        Returns\n        -------\n        int\n            The number of elements.\n\n        \"\"\"\n        return self.network.number_of_nodes()\n\n    def number_of_connections(self):\n        \"\"\"Compute the number of connections of the assembly.\n\n        Returns\n        -------\n        int\n            the number of connections.\n\n        \"\"\"\n        return self.network.number_of_edges()\n\n    @property\n    def data(self):\n        \"\"\"Return a data dictionary of the assembly.\n        \"\"\"\n        # Network data does not recursively serialize to data...\n        d = self.network.data\n\n        # so we need to trigger that for elements stored in nodes\n        node = {}\n        for vkey, vdata in d['node'].items():\n            node[vkey] = {key: vdata[key] for key in vdata.keys() if key != 'element'}\n            node[vkey]['element'] = vdata['element'].to_data()\n\n            if 'frame_est' in vdata:\n                if node[vkey]['frame_est']:\n                    node[vkey]['frame_est'] = node[vkey]['frame_est'].to_data()\n\n        d['node'] = node\n\n        return d\n\n    @data.setter\n    def data(self, data):\n        # Deserialize elements from node dictionary\n        for _vkey, vdata in data['node'].items():\n            vdata['element'] = Element.from_data(vdata['element'])\n\n            if 'frame_est' in vdata:\n                if vdata['frame_est']:\n                    vdata['frame_est'] = Frame.from_data(vdata['frame_est']) #node[vkey]['frame_est'].to_data()\n\n        self.network = Network.from_data(data)\n\n    def clear(self):\n        \"\"\"Clear all the assembly data.\"\"\"\n        self.network.clear()\n\n    def add_element(self, element, key=None, attr_dict={}, **kwattr):\n        \"\"\"Add an element to the assembly.\n\n        Parameters\n        ----------\n        element : Element\n            The element to add.\n        attr_dict : dict, optional\n            A dictionary of element attributes. Default is ``None``.\n\n        Returns\n        -------\n        hashable\n            The identifier of the element.\n        \"\"\"\n        attr_dict.update(kwattr)\n        x, y, z = element.frame.point\n        key = self.network.add_node(key=key, attr_dict=attr_dict,\n                                    x=x, y=y, z=z, element=element)\n        return key\n\n\n    def add_unit_element(self, current_key, flip='AA', angle1=0, angle2=0, placed_by='human', on_ground=False, unit_index=0, frame_id=None, frame_est=None):\n        \"\"\"Add an element to the assembly.\n        \"\"\"\n        radius = self.globals['radius']\n        height = self.globals['height']\n        rf_unit_radius = self.globals['rf_unit_radius']\n        rf_unit_offset = self.globals['rf_unit_offset']\n\n        N = self.network.number_of_nodes()\n\n        current_elem = self.network.node[current_key]['element']\n\n        # Find the open connector of the current element\n        if current_elem.connector_1_state:\n            current_connector_frame = current_elem.connector_frame_1\n            c = -1\n        else:\n            current_connector_frame = current_elem.connector_frame_2\n            c = 1\n\n        if flip == 'AA':\n            a = b = 0\n        if flip == 'AB':\n            a = 0\n            b = 1*c\n        if flip == 'BA':\n            a = 1*c\n            b = 0\n        if flip == 'BB':\n            a = b = 1*c\n\n        new_elem = current_elem.copy()\n\n        if placed_by == 'robot':\n            R1 = Rotation.from_axis_and_angle(current_connector_frame.zaxis, math.radians(angle1), current_connector_frame.point)\n            T1 = Translation.from_vector(-new_elem.frame.xaxis*a*((height-rf_unit_radius+rf_unit_offset)/2.))\n        else:\n            R1 = Rotation.from_axis_and_angle(current_connector_frame.zaxis, math.radians(360-angle1), current_connector_frame.point)\n            T1 = Translation.from_vector(-new_elem.frame.xaxis*b*((height-rf_unit_radius+rf_unit_offset)/2.))\n\n        new_elem.transform(R1*T1)\n\n        # Define a desired rotation in reference to the built element\n        T_point = Translation.from_vector(current_elem.frame.xaxis)\n        new_point = current_elem.frame.point.transformed(T_point)\n        R2 = Rotation.from_axis_and_angle(current_elem.frame.xaxis, math.radians(angle2),new_point)\n\n        new_elem.transform(R2)\n\n        #if self.collision_check(new_elem, tolerance = -0.001) == False:\n        if True:\n            self.add_element(new_elem, placed_by=placed_by, on_ground=on_ground, frame_id=frame_id, frame_est=frame_est)\n\n            if unit_index == 0:\n                self.network.add_edge(current_key, N, edge_to='neighbour')\n            else:\n                self.network.add_edge(N-1, N, edge_to='parent')\n                self.network.add_edge(current_key, N, edge_to='parent')\n\n            self.update_connectors_states(current_key, flip, new_elem, unit_index)\n\n        if unit_index == 1:\n            if current_elem.connector_1_state:\n                current_elem.connector_1_state = False\n            else:\n                current_elem.connector_2_state = False\n\n        return new_elem\n\n    def add_connection(self, u, v, attr_dict=None, **kwattr):\n        \"\"\"Add a connection between two elements and specify its attributes.\n\n        Parameters\n        ----------\n        u : hashable\n            The identifier of the first element of the connection.\n        v : hashable\n            The identifier of the second element of the connection.\n        attr_dict : dict, optional\n            A dictionary of connection attributes.\n        kwattr\n            Other connection attributes as additional keyword arguments.\n\n        Returns\n        -------\n        tuple\n            The identifiers of the elements.\n        \"\"\"\n        return self.network.add_edge(u, v, attr_dict, **kwattr)\n\n    def add_joint(self, edge, joint):\n        \"\"\"\n        \"\"\"\n        u, v = edge\n        return self.add_edge(u, v, joint=joint)\n\n    def transform(self, transformation):\n        \"\"\"Transforms this assembly.\n\n        Parameters\n        ----------\n        transformation : :class:`Transformation`\n\n        Returns\n        -------\n        None\n        \"\"\"\n        for _k, element in self.elements(data=False):\n            element.transform(transformation)\n\n    def transformed(self, transformation):\n        \"\"\"Returns a transformed copy of this assembly.\n\n        Parameters\n        ----------\n        transformation : :class:`Transformation`\n\n        Returns\n        -------\n        Assembly\n        \"\"\"\n        assembly = self.copy()\n        assembly.transform(transformation)\n        assembly.network.transform(transformation)\n        return assembly\n\n    def copy(self):\n        \"\"\"Returns a copy of this assembly.\n        \"\"\"\n        cls = type(self)\n        return cls.from_data(deepcopy(self.data))\n\n    def element(self, key, data=False):\n        \"\"\"Get an element by its key.\"\"\"\n        if data:\n            return self.network.node[key]['element'], self.network.node[key]\n        else:\n            return self.network.node[key]['element']\n\n    def elements(self, data=False):\n        \"\"\"Iterate over the elements of the assembly.\n\n        Parameters\n        ----------\n        data : bool, optional\n            If ``True``, yield both the identifier and the attributes.\n\n        Yields\n        ------\n        2-tuple\n            The next element as a (key, element) tuple, if ``data`` is ``False``.\n        3-tuple\n            The next element as a (key, element, attr) tuple, if ``data`` is ``True``.\n\n        \"\"\"\n        if data:\n            for vkey, vattr in self.network.nodes(True):\n                yield vkey, vattr['element'], vattr\n        else:\n            for vkey in self.network.nodes(data):\n                yield vkey, self.network.node[vkey]['element']\n\n    def connections(self, data=False):\n        \"\"\"Iterate over the connections of the network.\n\n        Parameters\n        ----------\n        data : bool, optional\n            If ``True``, yield both the identifier and the attributes.\n\n        Yields\n        ------\n        2-tuple\n            The next connection identifier (u, v), if ``data`` is ``False``.\n        3-tuple\n            The next connection as a (u, v, attr) tuple, if ``data`` is ``True``.\n\n        \"\"\"\n        return self.network.edges(data)\n\n    def direction(self, current_key, current_connector_key):\n        \"\"\"Compute direction of growth.\n        \"\"\"\n        current_elem = self.network.node[current_key]['element']\n        current_elem_type = current_elem._type\n        current_connectors = current_elem.connectors(state='open')\n\n        orient_map = {'X': 0, 'Y': 1, 'Z': 2}\n        axis = orient_map[current_elem_type]\n\n        current_location = current_elem.tool_frame.point[axis]\n\n        if current_connectors:\n            next_location = current_connectors[current_connector_key].point[axis]\n            if current_location > next_location:\n                direction = 0\n            else:\n                direction = 1\n            return direction\n\n    def direction_rf(self, current_key, current_connector_key):\n        \"\"\"Compute direction of growth.\n        \"\"\"\n        current_elem = self.network.node[current_key]['element']\n        current_elem_type = current_elem._type\n        current_connectors = current_elem.connectors(state='open')\n\n        orient_map = {'X': 0, 'Y': 1, 'Z': 2}\n        axis = orient_map[current_elem_type]\n\n        current_location = current_elem.tool_frame.point[axis]\n\n        if current_connectors:\n            next_location = current_connectors[current_connector_key].point[axis]\n            if current_location > next_location:\n                direction = 0\n            else:\n                direction = 1\n            return direction\n\n    def sequence(self, start_type, on_ground=False):\n        \"\"\"Compute the sequence for element placement.\n        \"\"\"\n        sequence = []\n\n        if start_type == 'X':\n            sequence = ['X', 'Y', 'Z']\n        if start_type == 'Y' and on_ground:\n            sequence = ['X', 'Y', 'Z']\n        else:\n            sequence = ['X', 'Y', 'Z']  # should be Y,X,Z when on ground=False\n        if start_type == 'Z':\n            sequence = ['Z', 'X', 'Y']\n\n        return sequence\n\n    def sequence_rf(self, start_type, on_ground=False):\n        \"\"\"Compute the sequence for element placement.\n        \"\"\"\n        sequence = []\n\n        if start_type == 'X':\n            sequence = ['Y', 'Z']\n        #if start_type == 'Y' and on_ground:\n        elif start_type == 'Y':\n            sequence = ['X', 'Z']\n        else:\n            sequence = ['X', 'Y']\n\n        return sequence\n\n    def collision_check(self, elem, tolerance):\n        \"\"\"Check for collisions with assembly elements.\n        \"\"\"\n\n        #key_index = self.network.key_index()\n        #keys = [key_index[key] for key in self.network.nodes()]\n        keys = [key for key, element in self.elements()]\n        elements = [self.element(key) for key in keys]\n\n        collision = False\n\n        for element in elements:\n            elem_mesh_offset = mesh_offset(elem.mesh, distance=tolerance, cls=None)\n\n            artist1 = MeshArtist(elem_mesh_offset)\n            elem_rmesh = artist1.draw_mesh()\n\n            artist2 = MeshArtist(element.mesh)\n            assembly_rmesh = artist2.draw_mesh()\n\n            results = rs.MeshMeshIntersection(elem_rmesh, assembly_rmesh)\n            if results:\n                collision = True\n\n        return collision\n\n    def close_unit(self, current_key, flip, angle1, angle2, on_ground=False, added_frame_id=None, frame_est=None):\n        \"\"\"Add a module to the assembly.\n        \"\"\"\n\n        keys_robot = []\n\n        for i in range(2):\n            if i == 0:\n                placed_by = 'robot'\n                frame_id = None\n                my_new_elem = self.add_unit_element(current_key, flip=flip, angle1=angle1, angle2=angle2, placed_by=placed_by, on_ground=False, unit_index=i, frame_id=frame_id, frame_est=None)\n                keys_robot += list(self.network.nodes_where({'element': my_new_elem}))\n            else:\n                placed_by = 'human'\n                frame_id = added_frame_id\n                my_new_elem = self.add_unit_element(current_key, flip=flip, angle1=angle1, angle2=angle2, placed_by=placed_by, on_ground=False, unit_index=i, frame_id=frame_id, frame_est=frame_est)\n                keys_human = list((self.network.nodes_where({'element': my_new_elem})))\n\n        keys_dict = {'keys_human': keys_human, 'keys_robot':keys_robot}\n\n        return keys_dict\n\n\n    def parent_key(self, point, within_dist):\n        \"\"\"Return the parent key of a tracked object.\n        \"\"\"\n        parent_key = None\n\n        for key, element in self.elements():\n            connectors = element.connectors(state='open')\n            for connector in connectors:\n                dist = distance_point_point(point, connector.point)\n                if dist < within_dist:\n                    parent_key = key\n\n        return parent_key\n\n\n    def update_connectors_states(self, current_key, flip, my_new_elem, unit_index):\n\n        key_index = self.network.key_index()\n        current_elem = self.network.node[current_key]['element']\n        keys = [key_index[key] for key in self.network.nodes()]\n        previous_elem = self.network.node[keys[-2]]['element']\n\n        if unit_index == 1:\n            if current_elem.connector_2_state:\n                if flip == 'AA':\n                    previous_elem.connector_2_state = False\n                    my_new_elem.connector_2_state = False\n                if flip == 'AB':\n                    previous_elem.connector_2_state = False\n                    my_new_elem.connector_1_state = False\n                if flip == 'BA':\n                    previous_elem.connector_1_state = False\n                    my_new_elem.connector_2_state = False\n                if flip == 'BB':\n                    previous_elem.connector_1_state = False\n                    my_new_elem.connector_1_state = False\n            if current_elem.connector_1_state:\n                if flip == 'AA':\n                    previous_elem.connector_1_state = False\n                    my_new_elem.connector_1_state = False\n                if flip == 'AB':\n                    previous_elem.connector_1_state = False\n                    my_new_elem.connector_2_state = False\n                if flip == 'BA':\n                    previous_elem.connector_2_state = False\n                    my_new_elem.connector_1_state = False\n                if flip == 'BB':\n                    previous_elem.connector_2_state = False\n                    my_new_elem.connector_2_state = False\n\n\n    def keys_within_radius(self, current_key):\n\n        for key, element in self.elements(data=True):\n            pass\n\n    def keys_within_radius_xy(self, current_key):\n        pass\n\n    def keys_within_radius_domain(self, current_key):\n        pass\n\n    def range_filter(self, base_frame):\n        \"\"\"Disable connectors outside of a given range, e.g. robot reach.\n        \"\"\"\n        ur_range_max = 1.3\n        ur_range_min = 0.75\n\n        for key, element in self.elements():\n            if element.connector_1_state == True:\n                distance = distance_point_point(element.connector_frame_1.point, base_frame.point)\n                if not ur_range_min <= distance <= ur_range_max:\n                    element.connector_1_state = False\n            elif element.connector_2_state == True:\n                distance = distance_point_point(element.connector_frame_2.point, base_frame.point)\n                if not ur_range_min <= distance <= ur_range_max:\n                    element.connector_2_state = False\n            else:\n                pass\n\n    def options_elements(self, elem_x, elem_y, elem_z):\n        \"\"\"Returns a list of elements.\n        \"\"\"\n        keys = [key for key, element in self.elements()]\n        return [self.element(key).options_elements(elem_x=elem_x, elem_y=elem_y, elem_z=elem_z) for key in keys]\n\n\n    def options_vectors(self):\n        \"\"\"Returns a list of vectors.\n        \"\"\"\n        keys = [key for key, element in self.elements()]\n        return [self.element(key).options_vectors() for key in keys]\n\n\n    def connectors(self, state='all'):\n        \"\"\" Get assembly's connectors.\n\n        Parameters\n        ----------\n        state : string\n            A string indentifying the connectors' state.\n\n        'all' : return all connectors.\n        'open' : return all open connectors.\n        'closed' : return all closed connectors.\n\n        Returns\n        -------\n        list\n            A list of frames.\n\n        \"\"\"\n        #key_index = self.network.key_index()\n        #keys = [key_index[key] for key in self.network.nodes()]\n        keys = [key for key, element in self.elements()]\n        return [self.element(key).connectors(state) for key in keys]\n\n\n    def export_building_plan(self):\n        \"\"\"\n        exports the building plan by using the following protocol:\n\n        the first lines are the description of the global markers (fixed in the world frame):\n        type [string], element pose [6]\n        = \"GM\", x, y, z, qw, qx, qy, qz\n\n        the next lines contain the wall information:\n        type [string], element pose [6], string_message [string]\n        = type, x, y, z, qw, qx, qy, qz, string_message\n        \"\"\"\n\n        print(\"exporting\")\n        building_plan = []\n\n        for key, element, data in self.elements(data=True):\n            line = []\n\n            t = element._type\n            line.append(t) #type\n            line += element.get_pose_quaternion() #element pose\n            string_message = \"This is the element with the key index %i\" %key\n            line.append(string_message)\n            building_plan.append(line)\n\n        print(building_plan)\n        exporter = Exporter()\n        exporter.delete_file()\n        exporter.export_building_plan(building_plan)\n\n    def export_to_json_for_xr(self, path, is_built=False):\n\n        self.network.update_default_node_attributes({\"is_built\":False,\"idx_v\":None,\"custom_attr_1\":None,\"custom_attr_2\":None,\"custom_attr_3\":None})\n\n        for key, element in self.elements():\n            idx_v = self.network.node_attribute(key, \"course\")\n            self.network.node_attribute(key, \"idx_v\", idx_v)\n            self.network.node_attribute(key, \"is_built\", is_built)\n\n        self.to_json(path)\n\n    def export_to_json_incon(self, path, qr_code, starting_geometry=True, is_built=True, pretty=True):\n        buildingplan = {\"id\":\"iaac_plan\",'name':\"iaac_plan\", \"description\":\"iaac_plan\", \"building_steps\":[]}\n        building_steps = []\n        len = 0\n\n        if starting_geometry:\n            element_to_INCON(\"starting element\", len, None, building_steps, True, \"starting_material.obj\")\n            len += 1\n\n        for key, element, data in self.elements(data=True):\n            element_to_INCON(\"dynamic_cylinder\", key, element, building_steps, True, \"cylinder_for_iaac_workshop.obj\") \n\n        placeholder = {\"type\":\"object\",'object_type':\"cylinder_for_iaac_workshop_1m.obj\", \"id\": \"dynamic_cylinder\", \"is_tag\": False, \"is_already_built\": False, \"color_rgb\": [1.0, 0.0, 0.0],\"instances\": 200,\"build_instructions\" : []}\n        building_steps.append(placeholder)\n\n        for key, tag in enumerate(qr_code):\n            tag_to_INCON(key, tag, building_steps)\n\n        buildingplan['building_steps'] = building_steps\n        compas.json_dump(buildingplan, path, pretty)\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}