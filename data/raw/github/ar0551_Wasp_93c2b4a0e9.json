{
  "source_url": "https://github.com/ar0551/Wasp/blob/66f63c018f2420d37aa451ade0178de260946b0c/src/wasp/core/parts.py",
  "repo": "ar0551/Wasp",
  "repo_stars": 67,
  "repo_description": "Combinatorial Design with Grasshopper plug-in (LGPL) initiated by Andrea Rossi",
  "license": "LGPL-3.0",
  "filepath": "src/wasp/core/parts.py",
  "instruction": "(C) 2017-2020 Andrea Rossi <ghwasp@gmail.com>",
  "code": "\"\"\"\n(C) 2017-2020 Andrea Rossi <ghwasp@gmail.com>\n\nThis file is part of Wasp. https://github.com/ar0551/Wasp\n@license GPL-3.0 <https://www.gnu.org/licenses/gpl.html>\n\n@version 0.6.001\n\nPart classes and utilities\n\"\"\"\n\nfrom Rhino.Geometry import Transform\nfrom Rhino.Geometry import Point3d\nfrom Rhino.Geometry import AreaMassProperties\n\nfrom wasp.utilities import mesh_from_data, mesh_to_data\nfrom wasp.utilities import transform_from_data, transform_to_data\nfrom wasp.core import Connection\nfrom wasp.core.colliders import Collider\nfrom wasp.core.constraints import Adjacency_Constraint\n\nimport random\n\n\n#################################################################### Base Part ####################################################################\nclass Part(object):\n\t\n\t## constructor\n\tdef __init__(self, name, geometry, connections, collider, attributes, dim=None, id=None, field=None):\n\t\t\n\t\tself.name = name\n\t\tself.id = id\n\t\tself.geo = geometry\n\t\t\n\t\tself.field = field\n\t\t\n\t\tself.connections = []\n\t\tself.active_connections = []\n\n\t\tcount = 0\n\t\tfor conn in connections:\n\t\t\tconn.part = self.name\n\t\t\tconn.id = count\n\t\t\tself.connections.append(conn)\n\t\t\tself.active_connections.append(count)\n\t\t\tcount += 1\n\t\t\n\t\tself.transformation = Transform.Identity\n\t\tself.center = AreaMassProperties.Compute(self.geo).Centroid\n\t\tself.collider = collider\n\t\t\n\t\t##part size\n\t\tif dim is not None:\n\t\t\tself.dim = dim\n\t\telse:\n\t\t\tmax_collider_dist = None\n\t\t\tfor coll_geo in self.collider.geometry:\n\t\t\t\tfor v in coll_geo.Vertices:\n\t\t\t\t\tdist = self.center.DistanceTo(v)\n\t\t\t\t\tif dist > max_collider_dist or max_collider_dist is None:\n\t\t\t\t\t\tmax_collider_dist = dist\n\t\t\t\n\t\t\tself.dim = max_collider_dist\n\t\t\n\t\tself.parent = None\n\t\tself.conn_on_parent = None\n\t\tself.conn_to_parent = None\n\t\tself.children = []\n\t\t\n\t\tself.attributes = []\n\t\tif len(attributes) > 0:\n\t\t\tself.attributes = attributes\n\t\t\n\t\tself.is_constrained = False\n\t\n\n\t## override Rhino .ToString() method (display name of the class in Gh)\n\tdef ToString(self):\n\t\treturn \"WaspPart [name: %s, id: %s]\" % (self.name, self.id)\n\t\n\n\t## create class from data dictionary\n\t@classmethod\n\tdef from_data(cls, data):\n\t\tp_name = data['name']\n\t\tp_geometry = mesh_from_data(data['geometry'])\n\t\tp_connections = [Connection.from_data(c_data) for c_data in data['connections']]\n\t\tp_collider = Collider.from_data(data['collider'])\n\t\tp_attributes = [] #### ATTRIBUTES NOT IMPLEMENTED\n\t\tp_dim = float(data['dim'])\n\t\t\n\t\tp_id = None\n\t\ttry:\n\t\t\tp_id = int(data['id'])\n\t\texcept:\n\t\t\tp_id = data['id']\n\t\tp_field = data['field']\n\n\t\tpart = cls(p_name, p_geometry, p_connections, p_collider, p_attributes, dim=p_dim, id=p_id, field=p_field)\n\n\t\tpart.transformation = transform_from_data(data['transform'])\n\t\tpart.parent = data['parent']\n\t\tpart.conn_on_parent = data['conn_on_parent']\n\t\tpart.conn_to_parent = data['conn_to_parent']\n\t\t\n\t\tfor child_data in data['children']:\n\t\t\tchild_id = None\n\t\t\ttry:\n\t\t\t\tpart.children.append(int(child_data))\n\t\t\texcept:\n\t\t\t\tpart.children.append(child_data)\n\t\t\n\t\treturn part\n\n\t\t\n\t## return the data dictionary representing the part\n\tdef to_data(self):\n\t\tdata = {}\n\t\t## class types\n\t\tdata['class_type'] = 'Part'\n\t\t## shared parameters\n\t\tdata['name'] = self.name\n\t\tdata['id'] = self.id\n\t\tdata['geometry'] = mesh_to_data(self.geo)\n\t\tdata['field'] = self.field\n\t\tdata['connections'] = [conn.to_data() for conn in self.connections]\n\t\tdata['active_connections'] = self.active_connections\n\t\tdata['collider'] = self.collider.to_data()\n\t\tdata['transform'] = transform_to_data(self.transformation)\n\t\tdata['dim'] = self.dim\n\t\tdata['parent'] = self.parent\n\t\tdata['conn_on_parent'] = self.conn_on_parent\n\t\tdata['conn_to_parent'] = self.conn_to_parent\n\t\tdata['children'] = self.children\n\t\treturn data\t\n\n\n\t## reset the part and connections according to new provided aggregation rules\n\tdef reset_part(self, rules):\n\t\tcount = 0\n\t\tself.active_connections = []\n\t\tfor conn in self.connections:\n\t\t\tconn.generate_rules_table(rules)\n\t\t\tself.active_connections.append(count)\n\t\t\tcount += 1\n\t\n\t\n\t## return a dictionary containing all part data\n\tdef return_part_data(self):\n\t\tdata_dict = {}\n\t\tdata_dict['name'] = self.name\n\t\tdata_dict['id'] = self.id\n\t\tdata_dict['geo'] = self.geo\n\t\tdata_dict['connections'] = self.connections\n\t\tdata_dict['transform'] = self.transformation\n\t\tdata_dict['collider'] = self.collider\n\t\tdata_dict['center'] = self.center\n\t\tdata_dict['parent'] = self.parent\n\t\tdata_dict['children'] = self.children\n\t\tdata_dict['attributes'] = self.attributes\n\t\treturn data_dict\n\t\n\n\t## return a transformed copy of the part\n\tdef transform(self, trans, transform_sub_parts=False, maintain_parenting = False):\n\t\tgeo_trans = self.geo.Duplicate()\n\t\tgeo_trans.Transform(trans)\n\t\t\n\t\tcollider_trans = self.collider.transform(trans)\n\t\t\n\t\tconnections_trans = []\n\t\tfor conn in self.connections:\n\t\t\tconnections_trans.append(conn.transform(trans))\n\t\t\n\t\tattributes_trans = []\n\t\tif len(self.attributes) > 0:\n\t\t\tfor attr in self.attributes:\n\t\t\t\tattributes_trans.append(attr.transform(trans))\n\t\t\n\t\tpart_trans = Part(self.name, geo_trans, connections_trans, collider_trans, attributes_trans, dim=self.dim, id=self.id, field=self.field)\n\n\t\tpart_trans.transformation = Transform.Multiply(trans, self.transformation)\n\n\t\tif maintain_parenting:\n\t\t\tpart_trans.parent = self.parent\n\t\t\tpart_trans.conn_on_parent = self.conn_on_parent\n\t\t\tpart_trans.conn_to_parent = self.conn_to_parent\n\t\t\tpart_trans.children = self.children\n\n\t\treturn part_trans\n\t\n\t## return a copy of the part\n\tdef copy(self, maintain_parenting = False):\n\t\tgeo_copy = self.geo.Duplicate()\n\t\t\n\t\tcollider_copy = self.collider.copy()\n\t\t\n\t\tconnections_copy = []\n\t\tfor conn in self.connections:\n\t\t\tconnections_copy.append(conn.copy())\n\t\t\n\t\tattributes_copy = []\n\t\tif len(self.attributes) > 0:\n\t\t\tfor attr in self.attributes:\n\t\t\t\tattributes_copy.append(attr.copy())\n\t\t\n\t\tpart_copy = Part(self.name, geo_copy, connections_copy, collider_copy, attributes_copy, dim=self.dim, id=self.id, field=self.field)\n\t\tpart_copy.transformation = self.transformation\n\n\t\tif maintain_parenting:\n\t\t\tpart_copy.parent = self.parent\n\t\t\tpart_copy.conn_on_parent = self.conn_on_parent\n\t\t\tpart_copy.conn_to_parent = self.conn_to_parent\n\t\t\tpart_copy.children = self.children\n\n\t\treturn part_copy\n\t\n\t## return transformed center point of the part\n\tdef transform_center(self, trans):\n\t\tcenter_trans = Point3d(self.center)\n\t\tcenter_trans.Transform(trans)\n\t\treturn center_trans\n\t\n\t## return transformed collider\n\tdef transform_collider(self, trans):\n\t\treturn self.collider.transform(trans)\n\n\n#################################################################### Constrained Part ####################################################################\nclass AdvancedPart(Part):\n\t\n\t## constructor\n\tdef __init__(self, name, geometry, connections, collider, attributes, additional_collider, supports, dim = None, id=None, field=None, sub_parts=[], adjacency_const = [], orientation_const=[]):\n\t\t\n\t\tsuper(AdvancedPart, self).__init__(name, geometry, connections, collider, attributes, dim=dim, id=id, field=field)\n\t\t\n\t\tself.add_collider = additional_collider\n\t\tself.supports = supports\n\t\tself.adjacency_const = adjacency_const\n\t\tself.orientation_const = orientation_const\n\n\t\tif self.add_collider is not None or len(self.supports) > 0 or len(self.adjacency_const) > 0 or len(self.orientation_const) > 0:\n\t\t\tself.is_constrained = True \n\t\t\n\t\t## hierarchical sub-parts\n\t\tself.sub_parts = sub_parts\n\t\tself.hierarchy_level = 0\n\t\tif len(self.sub_parts) > 0:\n\t\t\tself.hierarchy_level = self.sub_parts[0].hierarchy_level + 1\n\t\n\n\t## override Rhino .ToString() method (display name of the class in Gh)\n\tdef ToString(self):\n\t\treturn \"WaspAdvancedPart [name: %s, id: %s]\" % (self.name, self.id)\n\t\n\n\t## create class from data dictionary\n\t@classmethod\n\tdef from_data(cls, data):\n\t\tp_name = data['name']\n\t\tp_geometry = mesh_from_data(data['geometry'])\n\t\tp_connections = [Connection.from_data(c_data) for c_data in data['connections']]\n\t\tp_collider = Collider.from_data(data['collider'])\n\t\tp_attributes = [] #### ATTRIBUTES NOT IMPLEMENTED\n\t\tp_dim = float(data['dim'])\n\n\t\tp_id = None\n\t\ttry:\n\t\t\tp_id = int(data['id'])\n\t\texcept:\n\t\t\tp_id = data['id']\n\t\tp_field = data['field']\n\n\t\t#### AdvPart parameters\n\t\tp_add_collider = None\n\t\tif data['add_collider'] is not None:\n\t\t\tp_add_collider = Collider.from_data(data['add_collider'])\n\t\tp_supports = [] ## Supports not implemented (WILL BE REMOVED IN NEXT VERSION)\n\t\tp_sub_parts = [AdvancedPart.from_data(sp_data) for sp_data in data['sub_parts']]\n\t\tp_adjacency_const = [Adjacency_Constraint.from_data(adj_data) for adj_data in data['adjacency_const']]\n\n\t\tadv_part = cls(p_name, p_geometry, p_connections, p_collider, p_attributes, p_add_collider, p_supports, dim=p_dim, id=p_id, field=p_field, sub_parts=p_sub_parts, adjacency_const=p_adjacency_const)\n\n\t\tadv_part.transformation = transform_from_data(data['transform'])\n\n\t\tadv_part.parent = data['parent']\n\t\tadv_part.conn_on_parent = data['conn_on_parent']\n\t\tadv_part.conn_to_parent = data['conn_to_parent']\n\t\t\n\t\tfor child_data in data['children']:\n\t\t\tchild_id = None\n\t\t\ttry:\n\t\t\t\tadv_part.children.append(int(child_data))\n\t\t\texcept:\n\t\t\t\tadv_part.children.append(child_data)\n\t\t\n\t\treturn adv_part\n\n\t\t\n\t## return the data dictionary representing the part\n\tdef to_data(self):\n\t\tdata = {}\n\n\t\t## class types\n\t\tdata['class_type'] = 'AdvancedPart'\n\n\t\t## shared parameters\n\t\tdata['name'] = self.name\n\t\tdata['id'] = self.id\n\t\tdata['geometry'] = mesh_to_data(self.geo)\n\t\tdata['field'] = self.field\n\t\tdata['connections'] = [conn.to_data() for conn in self.connections]\n\t\tdata['active_connections'] = self.active_connections\n\t\tdata['collider'] = self.collider.to_data()\n\t\tdata['transform'] = transform_to_data(self.transformation)\n\t\tdata['dim'] = self.dim\n\t\tdata['parent'] = self.parent\n\t\tdata['conn_on_parent'] = self.conn_on_parent\n\t\tdata['conn_to_parent'] = self.conn_to_parent\n\t\tdata['children'] = self.children\n\n\t\t#### AdvPart parameters\n\t\tdata['add_collider'] = None\n\t\tif self.add_collider is not None:\n\t\t\tdata['add_collider'] = self.add_collider.to_data()\n\t\t\n\t\t## Supports not implemented (WILL BE REMOVED IN NEXT VERSION)\n\t\tdata['adjacency_const'] = [const.to_data() for const in self.adjacency_const]\n\t\t\n\t\t## Orientation Constraints not implemented\n\t\t\n\t\tdata['sub_parts'] = [sub_p.to_data() for sub_p in self.sub_parts]\n\t\treturn data\n\n\n\t## return all part data\n\t######################################## add returs for adjacency constraints\n\tdef return_part_data(self):\n\t\tdata_dict = {}\n\t\tdata_dict['name'] = self.name\n\t\tdata_dict['id'] = self.id\n\t\tdata_dict['geo'] = self.geo\n\t\tdata_dict['connections'] = self.connections\n\t\tdata_dict['transform'] = self.transformation\n\t\tdata_dict['collider'] = self.collider\n\t\tdata_dict['center'] = self.center\n\t\tdata_dict['parent'] = self.parent\n\t\tdata_dict['children'] = self.children\n\t\tdata_dict['attributes'] = self.attributes\n\t\tdata_dict['add_collider'] = self.add_collider\n\t\treturn data_dict\n\t\n\n\t## return a transformed copy of the part\n\tdef transform(self, trans, transform_sub_parts=False, sub_level = 0, maintain_parenting = False):\n\t\tgeo_trans = self.geo.Duplicate()\n\t\tgeo_trans.Transform(trans)\n\t\t\n\t\tcollider_trans = self.collider.transform(trans)\n\t\t\n\t\tconnections_trans = []\n\t\tfor conn in self.connections:\n\t\t\tconnections_trans.append(conn.transform(trans))\n\t\t\n\t\tattributes_trans = []\n\t\tif len(self.attributes) > 0:\n\t\t\tfor attr in self.attributes:\n\t\t\t\tattributes_trans.append(attr.transform(trans))\n\t\t\n\t\tadd_collider_trans = None\n\t\tif(self.add_collider != None):\n\t\t\tadd_collider_trans = self.add_collider.transform(trans, transform_connections=True, maintain_valid=True)\n\t\t\t\n\t\tsupports_trans = []\n\t\tif len(self.supports) > 0:\n\t\t\tfor sup in self.supports:\n\t\t\t\tsup_trans = sup.transform(trans)\n\t\t\t\tsupports_trans.append(sup_trans)\n\n\t\tadjacency_const_trans = []\n\t\tif len(self.adjacency_const) > 0:\n\t\t\tfor ac in self.adjacency_const:\n\t\t\t\tac_trans = ac.transform(trans)\n\t\t\t\tadjacency_const_trans.append(ac_trans)\n\t\t\n\t\torient_const_trans = []\n\t\tif len(self.orientation_const) > 0:\n\t\t\tfor oc in self.orientation_const:\n\t\t\t\toc_trans = oc.transform(trans)\n\t\t\t\torient_const_trans.append(oc_trans)\n\n\t\tif transform_sub_parts and len(self.sub_parts) > 0 and sub_level > 0:\n\t\t\tsub_parts_trans = []\n\t\t\tfor sp in self.sub_parts:\n\t\t\t\tsp_trans = sp.transform(trans, transform_sub_parts = True, sub_level = sub_level - 1)\n\t\t\t\tsub_parts_trans.append(sp_trans)\n\t\t\tpart_trans = AdvancedPart(self.name, geo_trans, connections_trans, collider_trans, attributes_trans, add_collider_trans, supports_trans, dim=self.dim, id=self.id, field=self.field, sub_parts=sub_parts_trans, adjacency_const = adjacency_const_trans, orientation_const=orient_const_trans)\n\t\t\tpart_trans.transformation = Transform.Multiply(trans, self.transformation)\n\t\t\tpart_trans.is_constrained = True\n\t\t\t\n\t\t\tif maintain_parenting:\n\t\t\t\tpart_trans.parent = self.parent\n\t\t\t\tpart_trans.conn_on_parent = self.conn_on_parent\n\t\t\t\tpart_trans.conn_to_parent = self.conn_to_parent\n\t\t\t\tpart_trans.children = self.children\n\n\t\t\treturn part_trans\n\t\t\n\t\telse:\n\t\t\tpart_trans = AdvancedPart(self.name, geo_trans, connections_trans, collider_trans, attributes_trans, add_collider_trans, supports_trans, dim=self.dim, id=self.id, field=self.field, sub_parts=self.sub_parts, adjacency_const = adjacency_const_trans, orientation_const=orient_const_trans)\n\t\t\tpart_trans.transformation = Transform.Multiply(trans, self.transformation)\n\t\t\tpart_trans.is_constrained = True\n\t\t\t\n\t\t\tif maintain_parenting:\n\t\t\t\tpart_trans.parent = self.parent\n\t\t\t\tpart_trans.conn_on_parent = self.conn_on_parent\n\t\t\t\tpart_trans.conn_to_parent = self.conn_to_parent\n\t\t\t\tpart_trans.children = self.children\n\n\t\t\treturn part_trans\n\t\n\t\n\t## return a copy of the part\t\t\n\tdef copy(self, maintain_parenting = False):\n\t\tgeo_copy = self.geo.Duplicate()\n\t\t\n\t\tcollider_copy = self.collider.copy()\n\t\t\n\t\tconnections_copy = []\n\t\tfor conn in self.connections:\n\t\t\tconnections_copy.append(conn.copy())\n\t\t\n\t\tattributes_copy = []\n\t\tif len(self.attributes) > 0:\n\t\t\tfor attr in self.attributes:\n\t\t\t\tattributes_copy.append(attr.copy())\n\t\t\n\t\tadd_collider_copy = None\n\t\tif(self.add_collider != None):\n\t\t\tadd_collider_copy = self.add_collider.copy()\n\t\t\t\n\t\tsupports_copy = []\n\t\tif len(self.supports) > 0:\n\t\t\tfor sup in self.supports:\n\t\t\t\tsup_copy = sup.copy()\n\t\t\t\tsupports_copy.append(sup_copy)\n\t\t\n\t\tadjacency_const_copy = []\n\t\tif len(self.adjacency_const) > 0:\n\t\t\tfor ac in self.adjacency_const:\n\t\t\t\tac_copy = ac.copy()\n\t\t\t\tadjacency_const_copy.append(ac_copy)\n\t\t\n\t\torient_const_copy = []\n\t\tif len(self.orientation_const) > 0:\n\t\t\tfor oc in self.orientation_const:\n\t\t\t\toc_copy = oc.copy()\n\t\t\t\torient_const_copy.append(oc_copy)\n\n\t\tif len(self.sub_parts) > 0:\n\t\t\tsub_parts_copy = []\n\t\t\tfor sp in self.sub_parts:\n\t\t\t\tsp_copy = sp.copy()\n\t\t\t\tsub_parts_copy.append(sp_copy)\n\t\t\t\n\t\t\tpart_copy = AdvancedPart(self.name, geo_copy, connections_copy, collider_copy, attributes_copy, add_collider_copy, supports_copy, dim=self.dim, id=self.id, field=self.field, sub_parts=sub_parts_copy, adjacency_const=adjacency_const_copy, orientation_const=orient_const_copy)\n\t\t\tpart_copy.transformation = self.transformation\n\t\t\tpart_copy.is_constrained = True\n\t\t\t\n\t\t\tif maintain_parenting:\n\t\t\t\tpart_copy.parent = self.parent\n\t\t\t\tpart_copy.conn_on_parent = self.conn_on_parent\n\t\t\t\tpart_copy.conn_to_parent = self.conn_to_parent\n\t\t\t\tpart_copy.children = self.children\n\t\t\t\n\t\t\treturn part_copy\n\t\t\n\t\telse:\n\t\t\tpart_copy = AdvancedPart(self.name, geo_copy, connections_copy, collider_copy, attributes_copy, add_collider_copy, supports_copy, dim=self.dim, id=self.id, field=self.field, sub_parts=self.sub_parts, adjacency_const=adjacency_const_copy, orientation_const=orient_const_copy)\n\t\t\tpart_copy.transformation = self.transformation\n\t\t\tpart_copy.is_constrained = True\n\t\t\t\n\t\t\tif maintain_parenting:\n\t\t\t\tpart_copy.parent = self.parent\n\t\t\t\tpart_copy.conn_on_parent = self.conn_on_parent\n\t\t\t\tpart_copy.conn_to_parent = self.conn_to_parent\n\t\t\t\tpart_copy.children = self.children\n\t\t\t\n\t\t\treturn part_copy\n\n\n################################################################# Parts Catalog ##################################################################\nclass PartCatalog(object):\n\t##constructor\n\tdef __init__(self, _parts, _amounts, _is_limited=True, _is_adaptive=False):\n\t\t\n\t\tself.parts = _parts\n\t\tself.amounts = _amounts\n\t\tself.is_limited = _is_limited\n\t\tself.is_adaptive = _is_adaptive\n\t\t\n\t\tself.dict = {}\n\t\tfor i in range(len(self.parts)):\n\t\t\tself.dict[self.parts[i]] = _amounts[i]\n\t\t\n\t\tself.is_empty = False\n\t\tself.parts_total = sum(self.dict.values())\n\t\n\n\t## override Rhino .ToString() method (display name of the class in Gh)\n\tdef ToString(self):\n\t\treturn \"WaspPartCatalog [%s]\" % (self.dict)\n\t\n\t\n\t## create class from data dictionary\n\t@classmethod\n\tdef from_data(cls, data):\n\t\treturn cls(data['parts'], [int(a) for a in data['amounts']], _is_limited=data['is_limited'], _is_adaptive=data['is_adaptive'])\n\n\t\t\n\t## return the data dictionary representing the catalog\n\tdef to_data(self):\n\t\tdata = {}\n\t\tdata['parts'] = self.parts\n\t\tdata['amounts'] = self.amounts\n\t\tdata['is_limited'] = self.is_limited\n\t\tdata['is_adaptive'] = self.is_adaptive\n\t\treturn data\t\n\t\n\n\t## return a random part type\n\tdef return_random_part(self):\n\t\tchoices = [key for key in self.dict.keys() if self.dict[key] > 0]\n\t\tif len(choices) > 0:\n\t\t\treturn random.choice(choices)\n\t\telse:\n\t\t\tself.is_empty = True\n\t\t\treturn None\n\t\n\n\t## return a weighted-choice between the available parts, give the available parts amounts\n\tdef return_weighted_part(self):\n\t\tif self.parts_total == 0:\n\t\t\tself.is_empty = True\n\t\t\treturn None\n\t\tn = random.uniform(0, self.parts_total)\n\t\tfor key in self.dict:\n\t\t\tif n < self.dict[key]:\n\t\t\t\treturn key\n\t\t\tn = n - self.dict[key]\n\t\treturn None\n\n\t## add or remove parts from the catalog\t\n\tdef update(self, part_name, difference):\n\t\tif self.is_limited:\n\t\t\tself.dict[part_name] += difference\n\t\t\tself.parts_total = sum(self.dict.values())\n\t\t\tif self.parts_total == 0:\n\t\t\t\tself.is_empty = True\n\t\t\telse:\n\t\t\t\tself.is_empty = False\n\t\telif self.is_adaptive:\n\t\t\tself.dict[part_name] += difference\n\t\t\tprev_parts_total = self.parts_total\n\t\t\tself.parts_total = sum(self.dict.values())\n\t\t\tfor key in self.dict:\n\t\t\t\tself.dict[key] = (self.dict[key] * prev_parts_total) / (self.parts_total)\n\t\t\tself.parts_total = sum(self.dict.values())\n\t\telse:\n\t\t\tpass\n\t\n\t## return a copy of the catalog\n\tdef copy(self):\n\t\tamounts = [self.dict[part] for part in self.parts]\n\t\treturn PartCatalog(self.parts, amounts, _is_limited=self.is_limited, _is_adaptive=self.is_adaptive)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}