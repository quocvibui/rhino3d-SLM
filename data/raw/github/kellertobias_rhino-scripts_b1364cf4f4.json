{
  "source_url": "https://github.com/kellertobias/rhino-scripts/blob/1b965725c49d5e0f82ebb80006ce6300219ecbae/export.py",
  "repo": "kellertobias/rhino-scripts",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "export.py",
  "instruction": "Rhino 8 for macOS — Generate ClippingDrawings per DECK_* section and export DWG per deck Pipeline per deck: generate_drawing(sectionName) -> export_sublayers_dwg(layer) -> cleanup_drawing(layer) Note: We also delete the temporary layers created by ClippingDrawings after export. Notes: - Uses ClippingDrawings with: Angle=0, Projection=Parallel, AddSilhouette=Yes, ShowHatch=Yes, ShowSolid=Yes, AddBackground=Yes, ShowLabel=No. (PrintWidth/DisplayColor set to “By Input Object” if your build supports those tokens.) - Placement: moves the generated drawing so its center is 3× model width to the RIGHT of the model’s bbox center. - Exports ONLY the drawing layer (including sublayers) to ~/Desktop/<sectionName>-Export.dwg - No layouts, no clipboard, no ChangeSpace.",
  "code": "# -*- coding: utf-8 -*-\n# Rhino 8 for macOS — Generate ClippingDrawings per DECK_* section and export DWG per deck\n# Pipeline per deck:\n#   generate_drawing(sectionName) -> export_sublayers_dwg(layer) -> cleanup_drawing(layer)\n#   Note: We also delete the temporary layers created by ClippingDrawings after export.\n#\n# Notes:\n# - Uses ClippingDrawings with:\n#   Angle=0, Projection=Parallel, AddSilhouette=Yes, ShowHatch=Yes, ShowSolid=Yes,\n#   AddBackground=Yes, ShowLabel=No. (PrintWidth/DisplayColor set to “By Input Object” if your build supports those tokens.)\n# - Placement: moves the generated drawing so its center is 3× model width to the RIGHT of the model’s bbox center.\n# - Exports ONLY the drawing layer (including sublayers) to ~/Desktop/<sectionName>-Export.dwg\n# - No layouts, no clipboard, no ChangeSpace.\n\nimport rhinoscriptsyntax as rs\nimport Rhino\nimport re\nimport os\nimport time\nimport logging\nimport tempfile\n\n# ---------- logging ----------\n# We initialize a module-level logger that writes verbose diagnostics to a log file\n# and a concise stream to the console (Rhino command history). The file handler\n# captures DEBUG+ while the console emits INFO+ for readability.\nlogger = logging.getLogger(\"clipping_export\")\n\n\ndef _default_log_path():\n    \"\"\"\n    Determine a writable log file path.\n    Preference order:\n      1) ~/Desktop/RhinoClippingExport.log\n      2) current working directory ./RhinoClippingExport.log\n      3) system temporary directory\n    \"\"\"\n    try:\n        desktop = os.path.join(os.path.expanduser('~'), 'Desktop')\n        if os.path.isdir(desktop):\n            return os.path.join(desktop, \"RhinoClippingExport.log\")\n    except Exception:\n        # Fall through to next option\n        pass\n    try:\n        cwd = os.getcwd()\n        return os.path.join(cwd, \"RhinoClippingExport.log\")\n    except Exception:\n        pass\n    # Last resort: temp directory\n    return os.path.join(tempfile.gettempdir(), \"RhinoClippingExport.log\")\n\n\ndef _setup_logging():\n    \"\"\"\n    Configure logging only once per interpreter session.\n    - FileHandler captures DEBUG and above (full fidelity)\n    - StreamHandler captures INFO and above (human friendly)\n    \"\"\"\n    if getattr(_setup_logging, \"_configured\", False):\n        return\n\n    log_path = _default_log_path()\n    logger.setLevel(logging.DEBUG)\n\n    formatter = logging.Formatter(\n        fmt=\"%(asctime)s %(levelname)s [%(name)s] %(message)s\",\n        datefmt=\"%Y-%m-%d %H:%M:%S\"\n    )\n\n    # File handler for full diagnostics\n    try:\n        fh = logging.FileHandler(log_path, encoding=\"utf-8\")\n        fh.setLevel(logging.DEBUG)\n        fh.setFormatter(formatter)\n        logger.addHandler(fh)\n    except Exception:\n        # If file handler fails, at least keep console logging\n        logger.debug(\n            \"FileHandler init failed; continuing with console-only.\", exc_info=True)\n\n    # Console handler for Rhino command history\n    ch = logging.StreamHandler()\n    ch.setLevel(logging.INFO)\n    ch.setFormatter(formatter)\n    logger.addHandler(ch)\n\n    _setup_logging._configured = True\n    logger.debug(\"Logging initialized. Log file: %s\", log_path)\n\n\n# Initialize logging on import so any functions used standalone still log.\n_setup_logging()\n\n# ---------- helpers ----------\n\n\ndef _activate_model_view():\n    \"\"\"Ensure we’re in a model-space viewport (not a layout).\"\"\"\n    logger.debug(\"Activating a model-space viewport.\")\n    doc = Rhino.RhinoDoc.ActiveDoc\n    for v in doc.Views:\n        if not isinstance(v, Rhino.Display.RhinoPageView):\n            doc.Views.ActiveView = v\n            try:\n                rs.CurrentView(v.ActiveViewport.Name)\n            except Exception:\n                logger.debug(\"Failed to set CurrentView to %s\", getattr(\n                    v.ActiveViewport, \"Name\", \"?\"), exc_info=True)\n            rs.Redraw()\n            logger.debug(\"Activated model-space view: %s\",\n                         getattr(v.ActiveViewport, \"Name\", \"?\"))\n            return True\n    created = rs.Command('_-NewViewport _Top _Enter', echo=False)\n    logger.debug(\"New viewport created via command: %s\", created)\n    return created\n\n\ndef _restore_named_view_if_exists(name):\n    \"\"\"Restore named view into current model viewport if it exists.\"\"\"\n    logger.debug(\"Attempting to restore named view: %s\", name)\n    doc = Rhino.RhinoDoc.ActiveDoc\n    idx = doc.NamedViews.FindByName(name)\n    if idx >= 0:\n        vp = doc.Views.ActiveView.ActiveViewport\n        try:\n            doc.NamedViews.Restore(idx, vp, True)\n            logger.debug(\"Named view restored: %s\", name)\n        except Exception:\n            logger.debug(\"Failed to restore named view: %s\",\n                         name, exc_info=True)\n\n\ndef _find_clipping_plane_by_name(name):\n    \"\"\"Return the first ClipPlaneObject whose name == name.\"\"\"\n    doc = Rhino.RhinoDoc.ActiveDoc\n    for obj in doc.Objects.GetObjectList(Rhino.DocObjects.ObjectType.ClipPlane):\n        try:\n            if (obj.Attributes.Name or \"\") == name:\n                logger.debug(\"Found clipping plane with name: %s\", name)\n                return obj\n        except Exception:\n            logger.debug(\"Error while scanning clip planes\", exc_info=True)\n    return None\n\n\ndef _model_bbox():\n    \"\"\"Bounding box of all model-space geometry.\"\"\"\n    logger.debug(\"Computing model-space bounding box.\")\n    doc = Rhino.RhinoDoc.ActiveDoc\n    bb = None\n    for o in doc.Objects:\n        try:\n            if o.IsDeleted:\n                continue\n            if o.Attributes.Space != Rhino.DocObjects.ActiveSpace.ModelSpace:\n                continue\n            ob = o.Geometry.GetBoundingBox(True)\n            if not ob.IsValid:\n                continue\n            bb = ob if bb is None else Rhino.Geometry.BoundingBox.Union(bb, ob)\n        except Exception:\n            logger.debug(\n                \"Error computing object bbox; skipping one object.\", exc_info=True)\n    logger.debug(\"Model bbox computed: %s\", bb)\n    return bb\n\n\ndef _move_ids_right_of_model(ids, factor=3.0):\n    \"\"\"Move ids so their center is factor×model width to the right of model center.\"\"\"\n    if not ids:\n        return\n    logger.debug(\n        \"Moving %d ids to the right of model by factor %.2f\", len(ids), factor)\n    mbb = _model_bbox()\n    if not mbb or not mbb.IsValid:\n        return\n    mmin, mmax = mbb.Min, mbb.Max\n    mw = max(0.0, mmax.X - mmin.X)\n    mcx = 0.5*(mmin.X + mmax.X)\n    mcy = 0.5*(mmin.Y + mmax.Y)\n\n    bb = rs.BoundingBox(ids)\n    if not bb or len(bb) < 2:\n        return\n    minx = min(p.X for p in bb)\n    maxx = max(p.X for p in bb)\n    miny = min(p.Y for p in bb)\n    maxy = max(p.Y for p in bb)\n    dcx = 0.5*(minx + maxx)\n    dcy = 0.5*(miny + maxy)\n\n    dx = (mcx + factor*mw) - dcx\n    dy = mcy - dcy\n    try:\n        rs.MoveObjects(ids, (dx, dy, 0.0))\n        logger.debug(\"Moved objects by dx=%.3f, dy=%.3f\", dx, dy)\n    except Exception:\n        logger.debug(\"Failed to move objects.\", exc_info=True)\n\n\ndef _ensure_layer(name, color=None, parent=None):\n    \"\"\"Create layer (optionally under parent) and return full layer path.\"\"\"\n    full = name\n    if parent:\n        full = parent + \"::\" + name\n    if not rs.IsLayer(full):\n        try:\n            rs.AddLayer(full, color=color)\n            logger.debug(\"Created layer: %s\", full)\n        except Exception:\n            logger.debug(\"Failed to create layer: %s\", full, exc_info=True)\n    return full\n\n\ndef _diff_new_objects(before_set):\n    after = set(rs.AllObjects() or [])\n    diff = list(after - before_set)\n    logger.debug(\"Detected %d new objects.\", len(diff))\n    return diff\n\n\ndef _diff_new_layers(before_set):\n    \"\"\"\n    Return list of new layer names created since 'before_set' snapshot.\n    \"\"\"\n    after = set(rs.LayerNames() or [])\n    diff = [ln for ln in (after - before_set)]\n    logger.debug(\"Detected %d new layers.\", len(diff))\n    return diff\n\n\ndef _objs_on_layer_and_children(layer_name):\n    \"\"\"Return object ids on layer and sublayers.\"\"\"\n    ids = []\n    all_layers = rs.LayerNames() or []\n    targets = []\n    for ln in all_layers:\n        if ln == layer_name or ln.startswith(layer_name + \"::\"):\n            targets.append(ln)\n    if not targets and rs.IsLayer(layer_name):\n        targets = [layer_name]\n    for ln in targets:\n        try:\n            ids.extend(rs.ObjectsByLayer(ln, True) or [])\n        except Exception:\n            logger.debug(\"Failed to collect objects for layer: %s\",\n                         ln, exc_info=True)\n    # unique\n    uniq = []\n    seen = set()\n    for i in ids:\n        if i not in seen:\n            uniq.append(i)\n            seen.add(i)\n    logger.debug(\"Collected %d objects across %d layers (including sublayers).\", len(\n        uniq), len(targets))\n    return uniq, targets\n\n\ndef _unlock_layers(layer_names):\n    logger.debug(\"Unlocking %d layers.\", len(layer_names))\n    for ln in layer_names:\n        try:\n            if rs.IsLayer(ln) and rs.IsLayerLocked(ln):\n                rs.UnlockLayer(ln)\n                logger.debug(\"Unlocked layer: %s\", ln)\n        except Exception:\n            logger.debug(\"Failed to unlock layer: %s\", ln, exc_info=True)\n\n\ndef _lock_layers(layer_names):\n    logger.debug(\"Locking %d layers.\", len(layer_names))\n    for ln in layer_names:\n        try:\n            if rs.IsLayer(ln) and not rs.IsLayerLocked(ln):\n                rs.LockLayer(ln)\n                logger.debug(\"Locked layer: %s\", ln)\n        except Exception:\n            logger.debug(\"Failed to lock layer: %s\", ln, exc_info=True)\n\n\ndef _delete_layer_tree(layer_name):\n    \"\"\"Delete layer and all its children.\"\"\"\n    all_layers = sorted(rs.LayerNames() or [],\n                        key=lambda s: len(s.split(\"::\")), reverse=True)\n    # delete children first\n    logger.info(\"Deleting layer tree: %s\", layer_name)\n    for ln in all_layers:\n        if ln == layer_name or ln.startswith(layer_name + \"::\"):\n            try:\n                # delete objects on the layer\n                objs = rs.ObjectsByLayer(ln, True) or []\n                if objs:\n                    for oid in objs:\n                        try:\n                            rs.DeleteObject(oid)\n                        except Exception:\n                            logger.debug(\n                                \"Failed to delete object on layer: %s\", ln, exc_info=True)\n                # delete layer\n                if rs.IsLayer(ln):\n                    try:\n                        rs.DeleteLayer(ln)\n                        logger.debug(\"Deleted layer: %s\", ln)\n                    except Exception:\n                        logger.debug(\"Failed to delete layer: %s\",\n                                     ln, exc_info=True)\n            except Exception:\n                logger.debug(\n                    \"Error while deleting within layer tree for: %s\", ln, exc_info=True)\n\n# ---------- file/system helpers ----------\n\n\ndef _wait_for_file(path, timeout_seconds=20.0, poll_seconds=0.25):\n    \"\"\"\n    Wait until a file at 'path' exists, is non-empty, and its size has stabilized.\n    This helps with async/slow writer plugins so we don't prematurely fail.\n    Returns True if the file appears stable before timeout; otherwise False.\n    \"\"\"\n    logger.debug(\"Waiting for file to stabilize: %s (timeout=%.1fs)\",\n                 path, timeout_seconds)\n    start = time.time()\n    last_size = -1\n    stable_count = 0\n    while (time.time() - start) < timeout_seconds:\n        try:\n            if os.path.exists(path):\n                size = os.path.getsize(path)\n                if size > 0:\n                    if size == last_size:\n                        stable_count += 1\n                        # consider stable after two consecutive identical sizes\n                        if stable_count >= 2:\n                            logger.debug(\n                                \"File is stable (size=%d): %s\", size, path)\n                            return True\n                    else:\n                        stable_count = 0\n                        last_size = size\n        except Exception:\n            logger.debug(\"Error while probing file status for: %s\",\n                         path, exc_info=True)\n        time.sleep(poll_seconds)\n    logger.debug(\"Timed out waiting for file: %s\", path)\n    return False\n\n# Resolve DWG output path helper\n\n\ndef _resolve_export_outpath(sectionName, output_dir=None):\n    \"\"\"\n    Compute the DWG output path for a given section name.\n    - If output_dir is provided and valid, place file there\n    - Otherwise primary: user's Desktop; fallback: current working directory\n    Filename: <sectionName>-Export.dwg\n    \"\"\"\n    try:\n        if output_dir and os.path.isdir(output_dir):\n            base = output_dir\n        else:\n            desktop = os.path.join(os.path.expanduser('~'), 'Desktop')\n            base = desktop if os.path.isdir(desktop) else os.getcwd()\n        return os.path.join(base, \"{}-Export.dwg\".format(sectionName))\n    except Exception:\n        # Last resort: ensure we return something writable with a safe filename\n        safe_name = \"{}-Export.dwg\".format(\n            re.sub(r\"[^\\w\\-\\.]+\", \"_\", sectionName))\n        return os.path.join(output_dir or tempfile.gettempdir(), safe_name)\n\n# ---------- required API ----------\n\n\ndef generate_drawing(sectionName):\n    \"\"\"\n    1) Select clipping plane named sectionName and run ClippingDrawings with:\n       Angle=0, Projection=Parallel, AddSilhouette=Yes, ShowHatch=Yes, ShowSolid=Yes, AddBackground=Yes, ShowLabel=No.\n       (Tries to set PrintWidth/DisplayColor to ByInputObject if available.)\n    2) Move the result 3× model width to the right of model center.\n    3) Create/ensure a layer 'DRAWING_<sectionName>' and move all result objects there.\n    4) Return (drawing_layer_name, created_layers_from_clipping_drawings).\n       'created_layers_from_clipping_drawings' are temporary layers produced by the\n       ClippingDrawings command that we will delete after export to avoid layer bloat.\n    \"\"\"\n    logger.info(\"Generating drawing for section: %s\", sectionName)\n    if not _activate_model_view():\n        logger.error(\"No model-space view available.\")\n        raise Exception(\"No model-space view available\")\n\n    # If there is a matching named view, restore it\n    _restore_named_view_if_exists(sectionName)\n\n    # Find the clipping plane object\n    cp = _find_clipping_plane_by_name(sectionName)\n    if cp is None:\n        logger.error(\"Clipping plane not found: %s\", sectionName)\n        raise Exception(\"Clipping plane not found: {}\".format(sectionName))\n\n    # Snapshot layers before running ClippingDrawings so we can detect which layers it creates\n    before_layers = set(rs.LayerNames() or [])\n\n    # Run ClippingDrawings with requested options\n    before = set(rs.AllObjects() or [])\n    rs.UnselectAllObjects()\n    try:\n        rs.SelectObject(cp.Id)\n        logger.debug(\"Selected clipping plane id: %s\", getattr(cp, \"Id\", None))\n    except Exception:\n        logger.debug(\"Failed to select clipping plane id for: %s\",\n                     sectionName, exc_info=True)\n\n    # Important: some mac builds use AddBackground (not ShowBackground)\n    # PrintWidth/DisplayColor tokens may be unavailable; include them if accepted, otherwise Rhino ignores.\n    cmd = (\n        '-_ClippingDrawings '\n        'Angle 0 '\n        'Projection=_Parallel '\n        'AddSilhouette=_Yes '\n        'ShowHatch=_Yes '\n        'ShowSolid=_Yes '\n        'AddBackground=_Yes '\n        'ShowLabel=_No '\n        'PrintWidth=_ByInputObject '\n        'DisplayColor=_ByInputObject '\n        '_Enter'\n    )\n    logger.debug(\"Executing command: %s\", cmd)\n    rs.Command(cmd, echo=False)\n\n    # Determine which layers were created by ClippingDrawings (before we create our own DRAWING_* layer)\n    created_layers = _diff_new_layers(before_layers)\n\n    new_ids = _diff_new_objects(before)\n    if not new_ids:\n        logger.error(\n            \"ClippingDrawings produced no geometry for %s\", sectionName)\n        raise Exception(\n            \"ClippingDrawings produced no geometry for {}\".format(sectionName))\n\n    # Place drawing right of model\n    _move_ids_right_of_model(new_ids, factor=3.0)\n\n    # Create/ensure target layer and move results there\n    drawing_layer = \"DRAWING_{}\".format(sectionName)\n    _ensure_layer(drawing_layer)\n    for oid in new_ids:\n        try:\n            rs.ObjectLayer(oid, drawing_layer)\n        except Exception:\n            logger.debug(\"Failed to move object to layer: %s\",\n                         drawing_layer, exc_info=True)\n\n    logger.info(\"Generated drawing on layer: %s (objects: %d)\",\n                drawing_layer, len(new_ids))\n    return drawing_layer, created_layers\n\n\ndef export_sublayers_dwg(drawingLayerName, output_dir=None, allow_overwrite=True):\n    \"\"\"\n    Unlock layer + all sublayers, select all their objects, and export ONLY those to DWG.\n    Filename: <sectionName>-Export.dwg (sectionName is the part after 'DRAWING_').\n    Then re-lock the layers.\n\n    Args:\n        drawingLayerName: Name of the drawing layer tree, must start with 'DRAWING_'.\n        output_dir: Optional folder where the DWG should be written.\n        allow_overwrite: If False and file exists, skip writing and return existing path.\n    \"\"\"\n    # Resolve export filename\n    if not drawingLayerName.startswith(\"DRAWING_\"):\n        logger.error(\"Unexpected drawing layer name: %s\", drawingLayerName)\n        raise Exception(\n            \"Unexpected drawing layer name: {}\".format(drawingLayerName))\n    sectionName = drawingLayerName[len(\"DRAWING_\"):]\n    outpath = _resolve_export_outpath(sectionName, output_dir=output_dir)\n    logger.info(\"Exporting DWG for layer tree '%s' -> %s\",\n                drawingLayerName, outpath)\n\n    # Respect overwrite policy early\n    try:\n        if (not allow_overwrite) and os.path.exists(outpath) and os.path.getsize(outpath) > 0:\n            logger.info(\"Skipping export (preserving existing): %s\", outpath)\n            return outpath\n    except Exception:\n        logger.debug(\"Overwrite check failed for: %s\", outpath, exc_info=True)\n\n    # Collect layers and objects\n    ids, layers = _objs_on_layer_and_children(drawingLayerName)\n    if not ids:\n        logger.error(\"No objects on layer tree: %s\", drawingLayerName)\n        raise Exception(\n            \"No objects on layer tree: {}\".format(drawingLayerName))\n\n    # Unlock layers, select ids\n    _unlock_layers(layers)\n    rs.UnselectAllObjects()\n    try:\n        rs.SelectObjects(ids)\n    except Exception:\n        logger.debug(\"Failed to select objects for export.\", exc_info=True)\n\n    # Remove stale file only when overwrite is allowed\n    if allow_overwrite:\n        try:\n            if os.path.exists(outpath):\n                os.remove(outpath)\n                logger.debug(\n                    \"Removed existing file prior to export: %s\", outpath)\n        except Exception:\n            logger.debug(\n                \"Failed to remove existing export file (continuing): %s\", outpath, exc_info=True)\n\n    wrote = False\n\n    # First attempt: RhinoCommon WriteFile with \"selected only\", suppressing UI.\n    # This avoids command-line option variance across mac builds.\n    try:\n        logger.debug(\n            \"Attempting RhinoCommon WriteFile (selected-only) to: %s\", outpath)\n        doc = Rhino.RhinoDoc.ActiveDoc\n        opts = Rhino.FileIO.FileWriteOptions()\n        opts.WriteSelectedObjectsOnly = True\n        opts.SuppressAllInput = True\n        # Some exporters honor geometry-only when selection is present; we rely on 'selected only'\n        ok = doc.WriteFile(outpath, opts)\n        logger.debug(\"WriteFile returned: %s\", ok)\n        if _wait_for_file(outpath, timeout_seconds=30.0):\n            wrote = True\n            logger.info(\"DWG export succeeded via RhinoCommon: %s\", outpath)\n    except Exception:\n        logger.debug(\n            \"RhinoCommon WriteFile failed, will try command-based export.\", exc_info=True)\n\n    # Fallback: Command-driven export (mac builds differ in prompts).\n    if not wrote:\n        export_cmds = [\n            u'-_Export \"{}\" _Enter'.format(outpath),\n            u'-_Export \"{}\" _Enter _Enter'.format(outpath),\n            u'-_Export {} _Enter'.format(outpath),\n            u'-_Export {} _Enter _Enter'.format(outpath),\n        ]\n        for cmd in export_cmds:\n            logger.debug(\"Attempting export via command: %s\", cmd)\n            rs.Command(cmd, echo=False)\n            # Wait up to 30s for the exporter plugin to finish writing\n            if _wait_for_file(outpath, timeout_seconds=30.0):\n                wrote = True\n                logger.info(\"DWG export succeeded: %s\", outpath)\n                break\n\n    # Re-lock layers regardless\n    _lock_layers(layers)\n    rs.UnselectAllObjects()\n\n    if not wrote:\n        logger.error(\"DWG export failed: %s\", outpath)\n        raise Exception(\"DWG export failed: {}\".format(outpath))\n\n    return outpath\n\n\ndef cleanup_drawing(drawingLayerName):\n    \"\"\"Delete the drawing layer (and all sublayers/objects) created for this deck.\"\"\"\n    logger.info(\"Cleaning up drawing layer tree: %s\", drawingLayerName)\n    _delete_layer_tree(drawingLayerName)\n\n\ndef export_deck(sectionName, output_dir=None, allow_overwrite=True):\n    \"\"\"\n    Orchestrates a single deck export:\n      1) generate_drawing(sectionName) -> (drawingLayerName, createdTempLayers)\n      2) export_sublayers_dwg(drawingLayerName)\n      3) delete createdTempLayers (from ClippingDrawings)\n      4) cleanup_drawing(drawingLayerName)\n      5) If DWG already exists before starting and allow_overwrite is False, skip.\n\n    Args:\n        sectionName: The clipping plane name to export.\n        output_dir: Optional destination folder for the DWG.\n        allow_overwrite: If False and the output file exists, skip this export.\n    \"\"\"\n    logger.info(\"Starting deck export for: %s\", sectionName)\n    # Skip if output already exists to avoid re-exporting the same deck\n    try:\n        preexisting_out = _resolve_export_outpath(\n            sectionName, output_dir=output_dir)\n        if (not allow_overwrite) and os.path.exists(preexisting_out) and os.path.getsize(preexisting_out) > 0:\n            logger.info(\"Skipping export for %s; DWG already exists: %s\",\n                        sectionName, preexisting_out)\n            return preexisting_out\n    except Exception:\n        logger.debug(\n            \"Pre-export existence check failed; will proceed with export.\", exc_info=True)\n\n    drawing_layer = None\n    created_temp_layers = []\n    out = None\n    try:\n        drawing_layer, created_temp_layers = generate_drawing(sectionName)\n        out = export_sublayers_dwg(\n            drawing_layer, output_dir=output_dir, allow_overwrite=allow_overwrite)\n        return out\n    finally:\n        # Always delete the temporary layers created by ClippingDrawings to avoid Rhino layer bloat\n        if created_temp_layers:\n            logger.info(\"Deleting %d temporary layers created by ClippingDrawings.\", len(\n                created_temp_layers))\n            for ln in created_temp_layers:\n                try:\n                    if ln and rs.IsLayer(ln):\n                        _delete_layer_tree(ln)\n                except Exception:\n                    logger.debug(\n                        \"Failed to delete temporary layer tree: %s\", ln, exc_info=True)\n        # Remove the generated drawing layer tree as before\n        if drawing_layer:\n            cleanup_drawing(drawing_layer)\n        if out:\n            logger.info(\"Export complete for %s -> %s\", sectionName, out)\n        else:\n            logger.info(\n                \"Export finished with no output path for %s (likely failed earlier).\", sectionName)\n\n# ---------- discovery and interactive prompts ----------\n\n\ndef _all_section_names_with_prefix(prefix):\n    \"\"\"\n    Collect names of all clipping planes whose name starts with the given prefix.\n    Names are returned in case-insensitive sorted order for stability.\n    \"\"\"\n    names = []\n    doc = Rhino.RhinoDoc.ActiveDoc\n    for obj in doc.Objects.GetObjectList(Rhino.DocObjects.ObjectType.ClipPlane):\n        nm = obj.Attributes.Name or \"\"\n        if nm.startswith(prefix):\n            names.append(nm)\n    names.sort(key=lambda s: s.lower())\n    logger.info(\"Discovered %d sections with prefix '%s'.\", len(names), prefix)\n    return names\n\n\ndef _force_parallel_projection():\n    # keep projection parallel in current view to match spec\n    try:\n        v = rs.CurrentView()\n        if v:\n            rs.ViewProjection(v, 1)  # 1 = parallel\n            logger.debug(\"Forced parallel projection on view: %s\", v)\n    except Exception:\n        logger.debug(\"Failed to force parallel projection.\", exc_info=True)\n\n\ndef _prompt_prefix(default_prefix=\"FLOOR_\"):\n    \"\"\"\n    Prompt the user for the clipping section prefix.\n    Defaults to 'FLOOR_' if user accepts default or submits empty.\n    Returns the prefix string, or None if cancelled.\n    \"\"\"\n    try:\n        result = rs.GetString(\"Enter section prefix\", default_prefix)\n    except Exception:\n        result = default_prefix\n    if result is None:\n        return None\n    result = result.strip()\n    return result if result else default_prefix\n\n\ndef _confirm_sections_list(sections):\n    \"\"\"\n    Show the list of matched sections and ask the user to confirm to continue.\n    Returns True to continue, False to abort.\n    \"\"\"\n    if not sections:\n        logger.warning(\"No sections matched the given prefix.\")\n        return False\n    logger.info(\"Matched sections (%d): %s\",\n                len(sections), \", \".join(sections))\n    try:\n        resp = rs.GetString(\"Continue with these sections? (Y/N) [Y]\", \"Y\")\n    except Exception:\n        resp = \"Y\"\n    if resp is None:\n        return False\n    resp = (resp or \"Y\").strip().lower()\n    return resp.startswith(\"y\")\n\n\ndef _prompt_export_folder():\n    \"\"\"\n    Prompt the user to select the export folder via UI; fallback to Desktop on text input.\n    Returns folder path or None if cancelled.\n    \"\"\"\n    try:\n        folder = rs.BrowseForFolder(\n            message=\"Select export folder for DWG files\")\n        if folder and os.path.isdir(folder):\n            logger.info(\"Selected export folder: %s\", folder)\n            return folder\n    except Exception:\n        logger.debug(\n            \"BrowseForFolder failed, falling back to string prompt.\", exc_info=True)\n    desktop = os.path.join(os.path.expanduser('~'), 'Desktop')\n    prompt = \"Enter export folder path [{}]: \".format(desktop)\n    try:\n        result = rs.GetString(prompt, desktop)\n    except Exception:\n        result = desktop\n    if result is None:\n        return None\n    result = os.path.expanduser((result or desktop).strip())\n    if not os.path.isdir(result):\n        logger.error(\"Invalid export folder: %s\", result)\n        return None\n    logger.info(\"Selected export folder: %s\", result)\n    return result\n\n\ndef _select_existing_to_overwrite(section_to_path):\n    \"\"\"\n    Given a mapping of section -> outpath, show which files already exist and\n    let the user select which of them to overwrite.\n    Returns a set of section names that the user chose to overwrite.\n    If no files exist, returns an empty set (caller can skip selection).\n    \"\"\"\n    existing = [(sec, p) for sec, p in section_to_path.items()\n                if os.path.exists(p) and os.path.getsize(p) > 0]\n    if not existing:\n        return set()\n\n    rows = []\n    for sec, p in existing:\n        rows.append([sec, p])\n\n    selected_secs = set()\n    # Try multi-selection dialog if available\n    try:\n        selection = rs.MultiListBox(rows, [\"Section\", \"Existing File\"],\n                                    \"Select existing files to OVERWRITE\",\n                                    \"Overwrite Existing Exports\")\n        if selection:\n            for row in selection:\n                if row and len(row) > 0:\n                    selected_secs.add(row[0])\n            return selected_secs\n    except Exception:\n        logger.debug(\n            \"MultiListBox not available; falling back to typed selection.\", exc_info=True)\n\n    # Fallback: display and accept comma-separated indices\n    logger.info(\"Existing exports:\")\n    for idx, (sec, p) in enumerate(existing, 1):\n        logger.info(\"%d) %s -> %s\", idx, sec, p)\n    try:\n        raw = rs.GetString(\n            \"Enter numbers to overwrite (comma-separated), or 'none'/'all' [none]\", \"none\")\n    except Exception:\n        raw = \"none\"\n    if raw is None:\n        return set()\n    raw = (raw or \"none\").strip().lower()\n    if raw == \"all\":\n        return {sec for sec, _ in existing}\n    if raw == \"none\" or raw == \"\":\n        return set()\n    try:\n        indices = [int(x.strip())\n                   for x in raw.split(\",\") if x.strip().isdigit()]\n        for i in indices:\n            if 1 <= i <= len(existing):\n                selected_secs.add(existing[i-1][0])\n    except Exception:\n        logger.debug(\n            \"Failed to parse selection; defaulting to none.\", exc_info=True)\n    return selected_secs\n\n\ndef main():\n    \"\"\"\n    Interactive export workflow:\n      1) Ask for section prefix (default 'FLOOR_')\n      2) Show matched sections and confirm to continue\n      3) Ask for export folder (file picker dialog)\n      4) Show which export files already exist and let the user select which to overwrite\n         (if none exist, this step is skipped)\n      5) Export the selected sections\n    \"\"\"\n    logger.info(\"Starting interactive export.\")\n    if not _activate_model_view():\n        logger.error(\"No model view. Abort.\")\n        return\n    _force_parallel_projection()\n\n    # 1) Prefix prompt\n    prefix = _prompt_prefix(default_prefix=\"FLOOR_\")\n    if prefix is None:\n        logger.warning(\"Prefix prompt cancelled.\")\n        return\n\n    # 2) Discover and confirm sections\n    sections = _all_section_names_with_prefix(prefix)\n    if not sections:\n        logger.warning(\"No clipping sections starting with %s.\", prefix)\n        return\n    if not _confirm_sections_list(sections):\n        logger.info(\"User declined to continue with matched sections.\")\n        return\n\n    # 3) Export folder\n    export_folder = _prompt_export_folder()\n    if export_folder is None:\n        logger.error(\"Export folder selection cancelled. Aborting.\")\n        return\n\n    # Map each section to its intended outpath\n    section_to_outpath = {}\n    for sec in sections:\n        section_to_outpath[sec] = _resolve_export_outpath(\n            sec, output_dir=export_folder)\n\n    # 4) Existing file selection\n    overwrite_existing_secs = _select_existing_to_overwrite(section_to_outpath)\n\n    # Determine final set of sections to export:\n    # - Always include those without an existing file\n    # - Include those user selected to overwrite\n    to_export = []\n    for sec, outp in section_to_outpath.items():\n        exists = False\n        try:\n            exists = os.path.exists(outp) and os.path.getsize(outp) > 0\n        except Exception:\n            exists = os.path.exists(outp)\n        if (not exists) or (sec in overwrite_existing_secs):\n            to_export.append(sec)\n    if not to_export:\n        logger.info(\"Nothing to export based on current selections.\")\n        return\n\n    # 5) Export\n    for sec in to_export:\n        try:\n            allow_overwrite = sec in overwrite_existing_secs\n            export_deck(sec, output_dir=export_folder,\n                        allow_overwrite=allow_overwrite)\n        except Exception as e:\n            logger.exception(\"FAIL %s -> %s\", sec, e)\n\n\nmain()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}