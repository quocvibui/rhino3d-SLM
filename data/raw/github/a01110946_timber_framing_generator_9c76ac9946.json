{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_mep_target_finder.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_mep_target_finder.py",
  "instruction": "MEP Target Finder for Grasshopper.",
  "code": "# File: scripts/gh_mep_target_finder.py\n\"\"\"MEP Target Finder for Grasshopper.\n\nFinds and ranks routing target candidates for MEP connectors using\nsystem-specific heuristics. Part of the OAHS (Obstacle-Aware Hanan Sequential)\nMEP routing pipeline.\n\nKey Features:\n1. Target Generation\n   - Generates targets from wall geometry (wet walls, penetration zones)\n   - Detects wet walls from plumbing fixture density\n   - Creates floor penetration targets for island fixtures\n\n2. Heuristic-Based Ranking\n   - System-specific heuristics (Sanitary, Vent, Supply, Power, Data)\n   - Considers distance, priority, and system constraints\n   - Gravity-aware routing for drains\n\n3. Visualization\n   - Target points for Rhino preview\n   - Candidate lines from connectors to targets\n   - Color-coded by system type\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n    Rhino.Inside.Revit (optional - for Revit connector extraction)\n\nDependencies:\n    - Rhino.Geometry: Core geometry types\n    - Grasshopper: DataTree for output organization\n    - timber_framing_generator.mep.routing: Target generator and heuristics\n\nPerformance Considerations:\n    - Processing time scales with number of connectors and targets\n    - Typical fixture finds candidates in < 10ms\n    - Wet wall detection adds overhead proportional to wall count\n\nUsage:\n    1. Connect MEP connectors JSON to 'connectors_json' input\n    2. Connect walls JSON to 'walls_json' input\n    3. Optionally provide pre-generated targets\n    4. Set 'run' to True to execute\n    5. Connect 'targets_json' to downstream routing components\n\nInput Requirements:\n    Connectors JSON (connectors_json) - str:\n        JSON string with MEP connector data\n        Required: Yes\n        Access: Item\n\n    Walls JSON (walls_json) - str:\n        JSON string with wall geometry data\n        Required: Yes\n        Access: Item\n\n    Targets JSON (targets_json) - str:\n        Optional pre-generated targets\n        Required: No\n        Access: Item\n\n    Config (config) - str:\n        Optional configuration JSON\n        Required: No\n        Access: Item\n\n    Run (run) - bool:\n        Boolean to trigger execution\n        Required: Yes\n        Access: Item\n\nOutputs:\n    Targets JSON (targets_out) - str:\n        JSON with targets and ranked candidates per connector\n\n    Target Points (target_points) - DataTree[Point3d]:\n        Target locations for visualization\n\n    Candidate Lines (candidate_lines) - DataTree[Line]:\n        Lines from connectors to candidate targets\n\n    Debug Info (debug_info) - str:\n        Debug information and status messages\n\nTechnical Details:\n    - Uses pluggable heuristics for each MEP system type\n    - Sanitary heuristic enforces gravity (downward only)\n    - Wet wall detection based on fixture density\n    - Supports custom heuristic registration\n\nError Handling:\n    - Invalid JSON returns error in debug_info\n    - Missing connectors logged but doesn't halt\n    - Unknown system types use fallback heuristic\n\nAuthor: Timber Framing Generator\nVersion: 1.0.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\n# Rhino / Grasshopper\nimport Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\n# =============================================================================\n# Force Module Reload (CPython 3 in Rhino 8)\n# =============================================================================\n\n_modules_to_clear = [k for k in sys.modules.keys() if 'timber_framing_generator' in k]\nfor mod in _modules_to_clear:\n    del sys.modules[mod]\n\n# =============================================================================\n# Project Setup\n# =============================================================================\n\nPROJECT_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator\"\nif PROJECT_PATH not in sys.path:\n    sys.path.insert(0, PROJECT_PATH)\n\nfrom src.timber_framing_generator.mep.routing import (\n    TargetCandidateGenerator,\n    ConnectorInfo,\n    RoutingTarget,\n    TargetType,\n    RoutingDomain,\n    RoutingDomainType,\n    detect_wet_walls,\n    generate_targets_from_walls,\n)\nfrom src.timber_framing_generator.utils.geometry_factory import get_factory\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"MEP Target Finder\"\nCOMPONENT_NICKNAME = \"MEPTargets\"\nCOMPONENT_MESSAGE = \"v1.0\"\nCOMPONENT_CATEGORY = \"Timber Framing\"\nCOMPONENT_SUBCATEGORY = \"MEP Routing\"\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message, level=\"info\"):\n    \"\"\"Log to console and optionally add GH runtime message.\"\"\"\n    print(f\"[{level.upper()}] {message}\")\n\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n\n\ndef log_debug(message):\n    \"\"\"Log debug message (console only).\"\"\"\n    print(f\"[DEBUG] {message}\")\n\n\ndef log_info(message):\n    \"\"\"Log info message (console only).\"\"\"\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message):\n    \"\"\"Log warning message (console + GH UI).\"\"\"\n    log_message(message, \"warning\")\n\n\ndef log_error(message):\n    \"\"\"Log error message (console + GH UI).\"\"\"\n    log_message(message, \"error\")\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\n\n    Configures:\n    1. Component metadata (name, category, etc.)\n    2. Input parameter names, descriptions, and access\n    3. Output parameter names and descriptions\n\n    Note: Output[0] is reserved for GH's internal 'out' - start from Output[1]\n\n    IMPORTANT: Type Hints cannot be set programmatically in Rhino 8.\n    They must be configured via UI: Right-click input -> Type hint -> Select type\n    \"\"\"\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs\n    inputs = ghenv.Component.Params.Input\n    input_config = [\n        (\"Connectors JSON\", \"connectors_json\", \"JSON string with MEP connector data\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Walls JSON\", \"walls_json\", \"JSON string with wall geometry data\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Targets JSON\", \"targets_json\", \"Optional pre-generated targets JSON\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Config\", \"config\", \"Optional configuration JSON\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Run\", \"run\", \"Boolean to trigger execution\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    # Configure outputs (start from index 1)\n    outputs = ghenv.Component.Params.Output\n    output_config = [\n        (\"Targets JSON\", \"targets_out\", \"JSON with targets and candidates\"),\n        (\"Target Points\", \"target_points\", \"Target locations for visualization\"),\n        (\"Candidate Lines\", \"candidate_lines\", \"Lines to candidate targets\"),\n        (\"Debug Info\", \"debug_info\", \"Debug information and status\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef validate_inputs(connectors_json, walls_json, run):\n    \"\"\"Validate component inputs.\n\n    Args:\n        connectors_json: JSON string with connector data\n        walls_json: JSON string with wall data\n        run: Boolean trigger\n\n    Returns:\n        tuple: (is_valid, error_message)\n    \"\"\"\n    if not run:\n        return False, \"Component not running. Set 'run' to True.\"\n\n    if not connectors_json:\n        return False, \"No connectors JSON provided\"\n\n    if not walls_json:\n        return False, \"No walls JSON provided\"\n\n    return True, None\n\n\ndef parse_connectors(connectors_json):\n    \"\"\"Parse connector data from JSON.\n\n    Args:\n        connectors_json: JSON string with connector data\n\n    Returns:\n        list: List of ConnectorInfo objects\n    \"\"\"\n    data = json.loads(connectors_json)\n\n    # Handle both list format and dict with 'connectors' key\n    if isinstance(data, list):\n        connector_list = data\n    elif isinstance(data, dict) and \"connectors\" in data:\n        connector_list = data[\"connectors\"]\n    else:\n        connector_list = [data]  # Single connector\n\n    connectors = []\n    for item in connector_list:\n        try:\n            connector = ConnectorInfo.from_dict(item)\n            connectors.append(connector)\n        except Exception as e:\n            log_warning(f\"Failed to parse connector: {e}\")\n\n    return connectors\n\n\ndef parse_walls(walls_json):\n    \"\"\"Parse wall data from JSON.\n\n    Args:\n        walls_json: JSON string with wall data\n\n    Returns:\n        list: List of wall data dictionaries\n    \"\"\"\n    data = json.loads(walls_json)\n\n    # Handle both list format and dict with 'walls' key\n    if isinstance(data, list):\n        return data\n    elif isinstance(data, dict) and \"walls\" in data:\n        return data[\"walls\"]\n    else:\n        return [data]\n\n\ndef parse_targets(targets_json):\n    \"\"\"Parse pre-generated targets from JSON.\n\n    Args:\n        targets_json: JSON string with target data\n\n    Returns:\n        list: List of RoutingTarget objects\n    \"\"\"\n    if not targets_json:\n        return []\n\n    data = json.loads(targets_json)\n\n    # Handle both list format and dict with 'targets' key\n    if isinstance(data, list):\n        target_list = data\n    elif isinstance(data, dict) and \"targets\" in data:\n        target_list = data[\"targets\"]\n    else:\n        target_list = [data]\n\n    targets = []\n    for item in target_list:\n        try:\n            target = RoutingTarget.from_dict(item)\n            targets.append(target)\n        except Exception as e:\n            log_warning(f\"Failed to parse target: {e}\")\n\n    return targets\n\n\ndef create_visualization_geometry(targets, connectors, candidates_by_connector):\n    \"\"\"Create visualization geometry for Rhino preview.\n\n    Args:\n        targets: List of RoutingTarget objects\n        connectors: List of ConnectorInfo objects\n        candidates_by_connector: Dict mapping connector ID to candidates\n\n    Returns:\n        tuple: (target_points DataTree, candidate_lines DataTree)\n    \"\"\"\n    factory = get_factory()\n\n    target_points = DataTree[object]()\n    candidate_lines = DataTree[object]()\n\n    # Create target points\n    for i, target in enumerate(targets):\n        path = GH_Path(i)\n        pt = factory.create_point3d(\n            target.location[0],\n            target.location[1],\n            target.location[2]\n        )\n        target_points.Add(pt, path)\n\n    # Create lines from connectors to candidates\n    for j, connector in enumerate(connectors):\n        path = GH_Path(j)\n        candidates = candidates_by_connector.get(connector.id, [])\n\n        conn_pt = factory.create_point3d(\n            connector.location[0],\n            connector.location[1],\n            connector.location[2]\n        )\n\n        for candidate in candidates[:3]:  # Top 3 candidates\n            tgt_pt = factory.create_point3d(\n                candidate.target.location[0],\n                candidate.target.location[1],\n                candidate.target.location[2]\n            )\n            line = factory.create_line(conn_pt, tgt_pt)\n            candidate_lines.Add(line, path)\n\n    return target_points, candidate_lines\n\n\ndef build_output_json(targets, connectors, candidates_by_connector, wet_walls):\n    \"\"\"Build output JSON with targets and candidates.\n\n    Args:\n        targets: List of RoutingTarget objects\n        connectors: List of ConnectorInfo objects\n        candidates_by_connector: Dict mapping connector ID to candidates\n        wet_walls: List of detected wet walls\n\n    Returns:\n        str: JSON string with complete output\n    \"\"\"\n    output = {\n        \"targets\": [t.to_dict() for t in targets],\n        \"wet_walls\": [\n            {\n                \"wall_id\": ww.wall_id,\n                \"fixture_count\": ww.fixture_count,\n                \"score\": ww.score,\n                \"is_back_to_back\": ww.is_back_to_back\n            }\n            for ww in wet_walls\n        ],\n        \"candidates\": {}\n    }\n\n    for connector_id, candidates in candidates_by_connector.items():\n        output[\"candidates\"][connector_id] = [\n            {\n                \"target_id\": c.target.id,\n                \"score\": c.score,\n                \"distance\": c.distance,\n                \"routing_domain\": c.routing_domain,\n                \"requires_floor_routing\": c.requires_floor_routing,\n                \"notes\": c.notes\n            }\n            for c in candidates\n        ]\n\n    return json.dumps(output, indent=2)\n\n\n# =============================================================================\n# Main Processing\n# =============================================================================\n\ndef main(connectors_json, walls_json, targets_json, config):\n    \"\"\"Main processing function.\n\n    Args:\n        connectors_json: JSON string with connector data\n        walls_json: JSON string with wall data\n        targets_json: Optional pre-generated targets\n        config: Optional configuration\n\n    Returns:\n        tuple: (targets_out, target_points, candidate_lines, debug_info)\n    \"\"\"\n    debug_lines = []\n    debug_lines.append(\"=== MEP Target Finder ===\")\n\n    try:\n        # Parse inputs\n        connectors = parse_connectors(connectors_json)\n        debug_lines.append(f\"Parsed {len(connectors)} connectors\")\n\n        walls = parse_walls(walls_json)\n        debug_lines.append(f\"Parsed {len(walls)} walls\")\n\n        # Create generator\n        generator = TargetCandidateGenerator()\n\n        # Generate or load targets\n        if targets_json:\n            targets = parse_targets(targets_json)\n            debug_lines.append(f\"Loaded {len(targets)} pre-generated targets\")\n        else:\n            targets = generate_targets_from_walls(walls, connectors)\n            debug_lines.append(f\"Generated {len(targets)} targets from walls\")\n\n        generator.add_targets(targets)\n\n        # Detect wet walls for info\n        wet_walls = detect_wet_walls(walls, connectors)\n        debug_lines.append(f\"Detected {len(wet_walls)} wet walls\")\n\n        for ww in wet_walls[:3]:  # Show top 3\n            debug_lines.append(f\"  - {ww.wall_id}: {ww.fixture_count} fixtures, score={ww.score:.1f}\")\n\n        # Find candidates for each connector\n        candidates_by_connector = generator.find_all_candidates(connectors, max_candidates_per_connector=5)\n\n        total_candidates = sum(len(c) for c in candidates_by_connector.values())\n        debug_lines.append(f\"Found {total_candidates} total candidates\")\n\n        # Log system breakdown\n        system_counts = {}\n        for conn in connectors:\n            system_counts[conn.system_type] = system_counts.get(conn.system_type, 0) + 1\n\n        debug_lines.append(\"Connectors by system:\")\n        for sys_type, count in sorted(system_counts.items()):\n            debug_lines.append(f\"  - {sys_type}: {count}\")\n\n        # Create visualization\n        target_points, candidate_lines = create_visualization_geometry(\n            targets, connectors, candidates_by_connector\n        )\n\n        # Build output JSON\n        targets_out = build_output_json(targets, connectors, candidates_by_connector, wet_walls)\n\n        debug_lines.append(\"=== Complete ===\")\n        debug_info = \"\\n\".join(debug_lines)\n\n        return targets_out, target_points, candidate_lines, debug_info\n\n    except Exception as e:\n        error_msg = f\"Error: {str(e)}\\n{traceback.format_exc()}\"\n        log_error(str(e))\n        return None, DataTree[object](), DataTree[object](), error_msg\n\n\n# =============================================================================\n# Entry Point\n# =============================================================================\n\nif __name__ == \"__main__\":\n    # Setup component on first run\n    setup_component()\n\n    # Validate inputs\n    is_valid, error_msg = validate_inputs(connectors_json, walls_json, run)\n\n    if not is_valid:\n        targets_out = None\n        target_points = DataTree[object]()\n        candidate_lines = DataTree[object]()\n        debug_info = error_msg\n        log_info(error_msg)\n    else:\n        # Run main processing\n        targets_out, target_points, candidate_lines, debug_info = main(\n            connectors_json, walls_json, targets_json, config\n        )\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}