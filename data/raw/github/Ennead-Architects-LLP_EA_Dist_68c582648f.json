{
  "source_url": "https://github.com/Ennead-Architects-LLP/EA_Dist/blob/635520d89b8308b78eabf5b60bb80121d0fa3838/Apps/_revit/EnneaDuck.extension/EnneadTab.tab/Import%20Export.panel/Rhino.pulldown/room2diagram.pushbutton/room2diagram_script.py",
  "repo": "Ennead-Architects-LLP/EA_Dist",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Apps/_revit/EnneaDuck.extension/EnneadTab.tab/Import Export.panel/Rhino.pulldown/room2diagram.pushbutton/room2diagram_script.py",
  "instruction": "Room2diagram script",
  "code": "#!/usr/bin/python\r\n# -*- coding: utf-8 -*-\r\n\r\n__doc__ = \"\"\"Export Revit Rooms/Areas to Rhino as color-coded diagrams with XAML GUI.\r\n\r\nThis tool creates a simplified diagram representation of Rooms or Areas in Rhino:\r\n- Exports boundaries with filleted corners and optional inner offset\r\n- Maintains color coding from Revit color schemes\r\n- Adds text labels for space identifiers\r\n- Creates solid hatches for each space\r\n- Features XAML GUI with persistent settings\r\n- Supports both Rooms and Areas export\r\n- Configurable corner fillet radius and inner offset distance\r\n- Automatic settings save/restore for future use\r\n- Framework ready for drafting view group export (future feature)\r\n\"\"\"\r\n__title__ = \"RoomOrArea2Diagram\"\r\n\r\nimport traceback\r\nimport os\r\nimport System # pyright: ignore \r\n\r\nfrom Autodesk.Revit.UI import IExternalEventHandler, ExternalEvent # pyright: ignore \r\nfrom Autodesk.Revit.Exceptions import InvalidOperationException # pyright: ignore \r\nfrom pyrevit.forms import WPFWindow\r\nfrom pyrevit.forms import SelectFromList\r\nfrom pyrevit import forms\r\nfrom pyrevit import script \r\n\r\ntry:\r\n    import clr  # pyright: ignore\r\n    clr.AddReference('RhinoCommon')\r\n    import Rhino  # pyright: ignore\r\n    clr.AddReference('RhinoInside.Revit')\r\n    from RhinoInside.Revit.Convert.Geometry import GeometryDecoder as RIR_DECODER  # pyright: ignore\r\n    RHINO_INSIDE_IMPORT_OK = True\r\nexcept:\r\n    RHINO_INSIDE_IMPORT_OK = False\r\n\r\nimport proDUCKtion # pyright: ignore \r\nproDUCKtion.validify()\r\n\r\nfrom EnneadTab.REVIT import REVIT_FORMS, REVIT_APPLICATION\r\nfrom EnneadTab import DATA_FILE, IMAGE, ERROR_HANDLE, LOG, NOTIFICATION\r\nfrom Autodesk.Revit import DB # pyright: ignore \r\n\r\nuidoc = REVIT_APPLICATION.get_uidoc()\r\ndoc = REVIT_APPLICATION.get_doc()\r\n__persistentengine__ = True\r\n\r\noutput = script.get_output()\r\n\r\n# Import shared constants\r\nfrom shared_constants import ElementType, ExportMethod\r\n\r\n# Import the separated process classes\r\nfrom rhino_process import RhinoProcess\r\nfrom revit_process import RevitProcess\r\n\r\n\r\nclass InputValidator:\r\n    \"\"\"Input validation class for protecting processing from invalid inputs.\"\"\"\r\n    \r\n    # Validation constants\r\n    MIN_FILLET_RADIUS = 0.0\r\n    MAX_FILLET_RADIUS = 100.0  # 100 feet max\r\n    MIN_OFFSET_DISTANCE = 0.0\r\n    MAX_OFFSET_DISTANCE = 50.0  # 50 feet max\r\n    \r\n    @classmethod\r\n    def validate_fillet_radius(cls, value):\r\n        \"\"\"Validate fillet radius input.\"\"\"\r\n        try:\r\n            radius = float(value)\r\n            if radius < cls.MIN_FILLET_RADIUS:\r\n                return False, \"Fillet radius must be >= {} feet\".format(cls.MIN_FILLET_RADIUS)\r\n            if radius > cls.MAX_FILLET_RADIUS:\r\n                return False, \"Fillet radius must be <= {} feet\".format(cls.MAX_FILLET_RADIUS)\r\n            return True, \"\"\r\n        except (ValueError, TypeError):\r\n            return False, \"Fillet radius must be a valid number\"\r\n    \r\n    @classmethod\r\n    def validate_offset_distance(cls, value):\r\n        \"\"\"Validate offset distance input.\"\"\"\r\n        try:\r\n            offset = float(value)\r\n            if offset < cls.MIN_OFFSET_DISTANCE:\r\n                return False, \"Offset distance must be >= {} feet\".format(cls.MIN_OFFSET_DISTANCE)\r\n            if offset > cls.MAX_OFFSET_DISTANCE:\r\n                return False, \"Offset distance must be <= {} feet\".format(cls.MAX_OFFSET_DISTANCE)\r\n            return True, \"\"\r\n        except (ValueError, TypeError):\r\n            return False, \"Offset distance must be a valid number\"\r\n    \r\n    @classmethod\r\n    def validate_all_inputs(cls, fillet_radius, offset_distance):\r\n        \"\"\"Validate all inputs at once.\"\"\"\r\n        is_valid, error_msg = cls.validate_fillet_radius(fillet_radius)\r\n        if not is_valid:\r\n            return False, error_msg\r\n        \r\n        is_valid, error_msg = cls.validate_offset_distance(offset_distance)\r\n        if not is_valid:\r\n            return False, error_msg\r\n        \r\n        return True, \"\"\r\n\r\n\r\nclass ProcessingConfig:\r\n    \"\"\"Configuration class to hold all processing settings.\"\"\"\r\n    \r\n    def __init__(self, element_type, export_method, fillet_radius, offset_distance, selected_views=None):\r\n        self.element_type = element_type\r\n        self.export_method = export_method\r\n        self.fillet_radius = fillet_radius\r\n        self.offset_distance = offset_distance\r\n        self.selected_views = selected_views or []\r\n\r\n\r\nclass Shape2Diagram:\r\n    \"\"\"Main orchestrator class for Room/Area diagram export.\"\"\"\r\n    \r\n    def __init__(self, revit_doc, config):\r\n        \"\"\"Initialize exporter with Revit document and configuration.\"\"\"\r\n        self.revit_doc = revit_doc\r\n        self.config = config\r\n        \r\n        # Initialize appropriate processor\r\n        if self.config.export_method == ExportMethod.RHINO:\r\n            self.processor = RhinoProcess(revit_doc, config.fillet_radius, config.offset_distance)\r\n        else:\r\n            self.processor = RevitProcess(revit_doc, config.fillet_radius, config.offset_distance)\r\n        \r\n    @ERROR_HANDLE.try_catch_error()\r\n    def export_as_diagram(self, level_name=None, source_view=None):\r\n        \"\"\"Main export function with optional level name and source view parameters.\"\"\"\r\n        try:\r\n            # Use source view if provided, otherwise use active view\r\n            view_to_process = source_view if source_view else self.revit_doc.ActiveView\r\n            \r\n            # Use BaseProcessor methods for validation and processing\r\n            results = self.processor.process_view_with_elements(\r\n                self.config.element_type, \r\n                view_to_process, \r\n                level_name\r\n            )\r\n            \r\n            if results:\r\n                # Delegate to appropriate processor with processed results\r\n                try:\r\n                    self.processor.process_spaces_from_results(results)\r\n                except Exception as e:\r\n                    print(\"ERROR: Failed to process spaces: {}. Stopping export.\".format(str(e)))\r\n                    return\r\n            else:\r\n                print(\"No results from view processing - skipping export\")\r\n                \r\n        except Exception as e:\r\n            print(\"CRITICAL ERROR in export_as_diagram: {}. Stopping export.\".format(str(e)))\r\n            return\r\n\r\n\r\n# Create a subclass of IExternalEventHandler\r\nclass room2diagram_SimpleEventHandler(IExternalEventHandler):\r\n    \"\"\"\r\n    Simple IExternalEventHandler sample\r\n    \"\"\"\r\n\r\n    # __init__ is used to make function from outside of the class to be executed by the handler. \\\r\n    # Instructions could be simply written under Execute method only\r\n    def __init__(self, do_this):\r\n        self.do_this = do_this\r\n        self.kwargs = None\r\n        self.OUT = None\r\n\r\n    # Execute method run in Revit API environment.\r\n    def Execute(self, uiapp):\r\n        try:\r\n            try:\r\n                self.OUT = self.do_this(*self.kwargs)\r\n            except:\r\n                print(\"failed\")\r\n                print(traceback.format_exc())\r\n        except InvalidOperationException:\r\n            # If you don't catch this exeption Revit may crash.\r\n            print(\"InvalidOperationException catched\")\r\n\r\n    def GetName(self):\r\n        return \"simple function executed by an IExternalEventHandler in a Form\"\r\n\r\n\r\n# Global recursion protection\r\n_processing_depth = 0\r\n_MAX_PROCESSING_DEPTH = 5\r\n\r\n@ERROR_HANDLE.try_catch_error()\r\ndef process_diagram_export(config):\r\n    \"\"\"Main processing function called by ExternalEventHandler with integrated multiple view processing.\"\"\"\r\n    global _processing_depth\r\n    \r\n    # RECURSION PROTECTION\r\n    _processing_depth += 1\r\n    if _processing_depth > _MAX_PROCESSING_DEPTH:\r\n        print(\"ERROR: Maximum processing depth exceeded. Possible recursion detected. Stopping to prevent stack overflow.\")\r\n        _processing_depth -= 1\r\n        return\r\n    \r\n    # Class-level error collection for review\r\n    collected_errors = []\r\n    \r\n    try:\r\n        print(\"Starting Room/Area diagram export...\")\r\n        \r\n        # Validate that we have a document\r\n        if not doc:\r\n            error_msg = \"No active document available\"\r\n            collected_errors.append(error_msg)\r\n            NOTIFICATION.messenger(error_msg)\r\n            return\r\n        \r\n        # Always require views to be selected - no fallback to current view\r\n        if not config.selected_views:\r\n            error_msg = \"No views selected. Please use 'Pick Views' button to select views for processing.\"\r\n            collected_errors.append(error_msg)\r\n            NOTIFICATION.messenger(error_msg)\r\n            return\r\n        \r\n        print(\"Processing {} views... (depth: {})\".format(len(config.selected_views), _processing_depth))\r\n        \r\n        # Filter views by unique levels to avoid duplicate processing\r\n        processed_levels = set()\r\n        unique_level_views = []\r\n        valid_views = []\r\n        \r\n        # First, filter out invalid views\r\n        for view in config.selected_views:\r\n            try:\r\n                if not view:\r\n                    print(\"Skipping invalid view (null reference)\")\r\n                    continue\r\n                \r\n                # SAFEGUARD: Check if view is still valid\r\n                if not view.IsValidObject:\r\n                    print(\"Skipping invalid view (no longer valid)\")\r\n                    continue\r\n                \r\n                if not is_view_suitable_for_processing(view):\r\n                    print(\"Skipping unsuitable view: {} (type: {})\".format(view.Name, view.ViewType))\r\n                    continue\r\n                \r\n                valid_views.append(view)\r\n            except Exception as e:\r\n                error_msg = \"Error validating view: {}. Skipping.\".format(str(e))\r\n                collected_errors.append(error_msg)\r\n                print(error_msg)\r\n                continue\r\n        \r\n        if not valid_views:\r\n            error_msg = \"No valid views found for processing. Please select floor plans, area plans, or similar views.\"\r\n            collected_errors.append(error_msg)\r\n            print(error_msg)\r\n            REVIT_FORMS.notification(\r\n                main_text=\"No Valid Views Found\",\r\n                sub_text=\"Please select floor plans or area plans for processing.\\nCurrent views are not suitable for room/area diagram export.\",\r\n                window_title=\"EnneadTab - Warning\",\r\n                button_name=\"OK\",\r\n                self_destruct=5\r\n            )\r\n            return\r\n        \r\n        print(\"Found {} valid views for processing...\".format(len(valid_views)))\r\n        \r\n        # Now process valid views by unique levels and area schemes\r\n        for view in valid_views:\r\n            try:\r\n                level_name = \"Unknown_Level\"\r\n                area_scheme_name = \"Default\"\r\n                \r\n                if view and view.GenLevel:\r\n                    level_name = view.GenLevel.Name\r\n                \r\n                # For area plans, also check the area scheme to avoid conflicts\r\n                if view.ViewType == DB.ViewType.AreaPlan:\r\n                    try:\r\n                        # Use the proper AreaScheme property from ViewPlan\r\n                        if hasattr(view, 'AreaScheme') and view.AreaScheme:\r\n                            area_scheme_name = view.AreaScheme.Name\r\n                        else:\r\n                            area_scheme_name = \"Default\"\r\n                    except:\r\n                        area_scheme_name = \"Default\"\r\n                \r\n                # Create a unique identifier combining level and area scheme (only for area plans)\r\n                if view.ViewType == DB.ViewType.AreaPlan:\r\n                    unique_identifier = \"{}_AreaScheme_{}\".format(level_name, area_scheme_name)\r\n                else:\r\n                    # For floor plans and other view types, just use level name\r\n                    unique_identifier = level_name\r\n                \r\n                if unique_identifier not in processed_levels:\r\n                    processed_levels.add(unique_identifier)\r\n                    unique_level_views.append((view, level_name))\r\n                    if view.ViewType == DB.ViewType.AreaPlan:\r\n                        print(\"Found unique level/scheme: {} (Level: {}, Area Scheme: {})\".format(unique_identifier, level_name, area_scheme_name))\r\n                    else:\r\n                        print(\"Found unique level: {} (Level: {})\".format(unique_identifier, level_name))\r\n            except Exception as e:\r\n                error_msg = \"Error processing view {}: {}. Skipping.\".format(view.Name if view else \"Unknown\", str(e))\r\n                collected_errors.append(error_msg)\r\n                print(error_msg)\r\n                continue\r\n        \r\n        print(\"Processing {} unique levels (filtered from {} views)...\".format(len(unique_level_views), len(config.selected_views)))\r\n        \r\n        # Process each unique level with error handling\r\n        for i, (view, level_name) in enumerate(unique_level_views):\r\n            try:\r\n                print(\"Processing level {}/{}: {} (view: {})\".format(i+1, len(unique_level_views), level_name, view.Name))\r\n                \r\n                # SAFEGUARD: Check if view is still valid before processing\r\n                if not view or not view.IsValidObject:\r\n                    error_msg = \"View no longer valid, skipping: {}\".format(view.Name if view else \"Unknown\")\r\n                    collected_errors.append(error_msg)\r\n                    print(error_msg)\r\n                    continue\r\n                \r\n                # Process the view with level name using BaseProcessor\r\n                # Create a temporary processor to use its process_single_view method\r\n                if config.export_method == ExportMethod.RHINO:\r\n                    temp_processor = RhinoProcess(doc, config.fillet_radius, config.offset_distance)\r\n                else:\r\n                    temp_processor = RevitProcess(doc, config.fillet_radius, config.offset_distance)\r\n                \r\n                temp_processor.process_single_view(config, view, level_name)\r\n                \r\n                # SAFEGUARD: Force garbage collection after each view\r\n                import gc\r\n                gc.collect()\r\n                \r\n            except Exception as e:\r\n                error_msg = \"Error processing level {}: {}. Continuing with next level...\".format(level_name, str(e))\r\n                collected_errors.append(error_msg)\r\n                print(error_msg)\r\n                print(traceback.format_exc())\r\n                continue\r\n        \r\n        # Show completion notification with more detailed information\r\n        processed_count = len(unique_level_views)\r\n        total_selected = len(config.selected_views)\r\n        \r\n        # Display collected errors if any\r\n        if collected_errors:\r\n            print(\"\\n\" + \"=\"*50)\r\n            print(\"ERROR SUMMARY - {} errors collected:\".format(len(collected_errors)))\r\n            print(\"=\"*50)\r\n            for i, error in enumerate(collected_errors, 1):\r\n                print(\"{}. {}\".format(i, error))\r\n            print(\"=\"*50)\r\n            print(\"Full error details have been logged above.\")\r\n            print(\"=\"*50 + \"\\n\")\r\n        \r\n        if processed_count == total_selected:\r\n            REVIT_FORMS.notification(\r\n                main_text=\"Batch Processing Complete\",\r\n                sub_text=\"Successfully processed {} views\".format(processed_count),\r\n                window_title=\"EnneadTab\",\r\n                button_name=\"Close\",\r\n                self_destruct=10\r\n            )\r\n        else:\r\n            REVIT_FORMS.notification(\r\n                main_text=\"Batch Processing Complete\",\r\n                sub_text=\"Processed {} of {} selected views\\nSome views were skipped due to duplicates or invalid types.\".format(processed_count, total_selected),\r\n                window_title=\"EnneadTab\",\r\n                button_name=\"Close\",\r\n                self_destruct=10\r\n            )\r\n        \r\n    except Exception as e:\r\n        error_msg = \"CRITICAL ERROR in process_diagram_export: {}. Stopping processing.\".format(str(e))\r\n        collected_errors.append(error_msg)\r\n        print(error_msg)\r\n        print(traceback.format_exc())\r\n    finally:\r\n        # Always decrement processing depth\r\n        _processing_depth -= 1\r\n\r\n@ERROR_HANDLE.try_catch_error()\r\ndef is_view_suitable_for_processing(view):\r\n    \"\"\"Check if a view is suitable for room/area diagram processing.\"\"\"\r\n    if not view:\r\n        return False\r\n    \r\n    # Check view type - we want views that can show rooms/areas\r\n    suitable_view_types = [\r\n        DB.ViewType.FloorPlan,\r\n        DB.ViewType.AreaPlan\r\n    ]\r\n    \r\n    return view.ViewType in suitable_view_types\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# A simple WPF form used to call the ExternalEvent\r\nclass room2diagram_ModelessForm(WPFWindow):\r\n    \"\"\"\r\n    Simple modeless form sample\r\n    \"\"\"\r\n\r\n    def pre_actions(self):\r\n        self.process_event_handler = room2diagram_SimpleEventHandler(process_diagram_export)\r\n        self.ext_event_process = ExternalEvent.Create(self.process_event_handler)\r\n        return\r\n\r\n    @ERROR_HANDLE.try_catch_error()\r\n    def __init__(self):\r\n        self.pre_actions()\r\n\r\n        xaml_file_name = \"room2diagram_UI.xaml\"\r\n        WPFWindow.__init__(self, xaml_file_name)\r\n\r\n        self.title_text.Text = \"Room/Area to Diagram Exporter\"\r\n        self.sub_text.Text = \"Configure export settings and pick views for processing. Processing will happen in background.\"\r\n\r\n        self.Title = self.title_text.Text\r\n\r\n        logo_file = IMAGE.get_image_path_by_name(\"logo_vertical_light.png\")\r\n        self.set_image_source(self.logo_img, logo_file)\r\n\r\n        self.selected_views = []\r\n\r\n        self.load_setting()\r\n        self.update_ui_state()\r\n\r\n        self.Show()\r\n\r\n    @ERROR_HANDLE.try_catch_error()\r\n    def load_setting(self):\r\n        \"\"\"Load settings from file.\"\"\"\r\n        data = DATA_FILE.get_data(\"room2diagram_settings\")\r\n        if not data:\r\n            data = {}\r\n\r\n        # Set element type - compare with string values\r\n        element_type = data.get(\"element_type\", \"Rooms\")\r\n        if element_type == \"Rooms\":\r\n            self.radio_bt_rooms.IsChecked = True\r\n            self.radio_bt_areas.IsChecked = False\r\n        else:\r\n            self.radio_bt_rooms.IsChecked = False\r\n            self.radio_bt_areas.IsChecked = True\r\n        \r\n        # Set export method - compare with string values\r\n        export_method = data.get(\"export_method\", \"Rhino\")\r\n\r\n        if export_method == \"Rhino\":\r\n            self.radio_bt_rhino.IsChecked = True\r\n            self.radio_bt_drafting.IsChecked = False\r\n        else:\r\n            self.radio_bt_rhino.IsChecked = False\r\n            self.radio_bt_drafting.IsChecked = True\r\n        \r\n        # Set geometry settings with validation\r\n        fillet_radius = data.get(\"fillet_radius\", \"12\")\r\n        offset_distance = data.get(\"offset_distance\", \"2\")\r\n        \r\n        # Validate saved settings and use defaults if invalid\r\n        is_valid, _ = InputValidator.validate_all_inputs(fillet_radius, offset_distance)\r\n        if not is_valid:\r\n            print(\"Invalid saved settings detected. Using default values.\")\r\n            fillet_radius = \"12\"\r\n            offset_distance = \"2\"\r\n        \r\n        self.textbox_fillet_radius.Text = str(fillet_radius)\r\n        self.textbox_offset_distance.Text = str(offset_distance)\r\n\r\n    @ERROR_HANDLE.try_catch_error()\r\n    def save_setting(self):\r\n        \"\"\"Save current settings to file.\"\"\"\r\n        # Create a clean data dictionary with only string values\r\n        clean_data = {}\r\n        \r\n        # Save element type as string values\r\n        if self.radio_bt_rooms.IsChecked:\r\n            clean_data[\"element_type\"] = \"Rooms\"\r\n        else:\r\n            clean_data[\"element_type\"] = \"Areas\"\r\n        \r\n        # Save export method as string values\r\n        if self.radio_bt_rhino.IsChecked:\r\n            clean_data[\"export_method\"] = \"Rhino\"\r\n        else:\r\n            clean_data[\"export_method\"] = \"Revit\"\r\n        \r\n        # Save geometry settings with validation\r\n        fillet_radius_text = self.textbox_fillet_radius.Text\r\n        offset_distance_text = self.textbox_offset_distance.Text\r\n        \r\n        # Only save if values are valid\r\n        is_valid, _ = InputValidator.validate_all_inputs(fillet_radius_text, offset_distance_text)\r\n        if is_valid:\r\n            clean_data[\"fillet_radius\"] = fillet_radius_text\r\n            clean_data[\"offset_distance\"] = offset_distance_text\r\n        else:\r\n            print(\"Invalid values detected. Settings not saved.\")\r\n            return\r\n        \r\n        # Save the clean data\r\n        DATA_FILE.set_data(clean_data, \"room2diagram_settings\")\r\n\r\n    def update_ui_state(self):\r\n        \"\"\"Update UI state based on current selections.\"\"\"\r\n        if self.radio_bt_drafting.IsChecked:\r\n            self.debug_textbox.Text = \"Ready to export - Please pick views first\"\r\n        else:\r\n            self.debug_textbox.Text = \"Ready to export to Rhino...\"\r\n        # Always enable export button - validation will happen on click\r\n        self.bt_export.IsEnabled = True\r\n\r\n    @ERROR_HANDLE.try_catch_error()\r\n    def element_type_changed(self, sender, e):\r\n        \"\"\"Handle element type radio button changes.\"\"\"\r\n        self.update_ui_state()\r\n\r\n    @ERROR_HANDLE.try_catch_error()\r\n    def export_method_changed(self, sender, e):\r\n        \"\"\"Handle export method radio button changes.\"\"\"\r\n        self.update_ui_state()\r\n\r\n    @ERROR_HANDLE.try_catch_error()\r\n    def fillet_radius_changed(self, sender, e):\r\n        \"\"\"Handle fillet radius text changes.\"\"\"\r\n        pass\r\n\r\n    @ERROR_HANDLE.try_catch_error()\r\n    def offset_distance_changed(self, sender, e):\r\n        \"\"\"Handle offset distance text changes.\"\"\"\r\n        pass\r\n\r\n    @ERROR_HANDLE.try_catch_error()\r\n    def pick_views_click(self, sender, e):\r\n        \"\"\"Handle pick views button click.\"\"\"\r\n        self.pick_views()\r\n\r\n    @ERROR_HANDLE.try_catch_error()\r\n    def pick_views(self):\r\n        \"\"\"\r\n        Pick views for processing - Simple and robust approach.\r\n        \r\n        This method:\r\n        1. Collects all views from the document\r\n        2. Filters for eligible views (Floor Plans and Area Plans with levels)\r\n        3. Creates user-friendly display names\r\n        4. Shows selection dialog to user\r\n        5. Maps selected names back to view objects\r\n        \"\"\"\r\n        try:\r\n            # ============================================================================\r\n            # STEP 1: VALIDATE DOCUMENT\r\n            # ============================================================================\r\n            if not doc or not doc.IsValidObject:\r\n                self.debug_textbox.Text = \"ERROR: Document is no longer valid\"\r\n                return\r\n            \r\n            # ============================================================================\r\n            # STEP 2: COLLECT ALL VIEWS\r\n            # ============================================================================\r\n            all_views = DB.FilteredElementCollector(doc).OfClass(DB.View).ToElements()\r\n            \r\n            # ============================================================================\r\n            # STEP 3: FILTER AND CREATE DISPLAY MAPPING\r\n            # ============================================================================\r\n            view_dict = {}  # Dictionary: display_name -> view_object\r\n            \r\n            for view in all_views:\r\n                try:\r\n                    # Validate view object\r\n                    if not self._is_view_valid(view):\r\n                        continue\r\n                    \r\n                    # Check if view type is suitable for room/area processing\r\n                    if not self._is_view_type_suitable(view):\r\n                        continue\r\n                    \r\n                    # Create user-friendly display name\r\n                    display_name = self._create_display_name(view)\r\n                    \r\n                    # Store mapping\r\n                    view_dict[display_name] = view\r\n                    \r\n                except Exception as e:\r\n                    # Skip problematic views silently\r\n                    continue\r\n            \r\n            # ============================================================================\r\n            # STEP 4: CHECK IF ANY ELIGIBLE VIEWS FOUND\r\n            # ============================================================================\r\n            if not view_dict:\r\n                self.selected_views = []\r\n                self.debug_textbox.Text = \"No eligible views found - Please ensure you have floor plans or area plans with levels\"\r\n                return\r\n            \r\n            # ============================================================================\r\n            # STEP 5: SHOW SELECTION DIALOG\r\n            # ============================================================================\r\n            display_names = sorted(list(view_dict.keys()))  # Sort for better UX\r\n            selected_names = SelectFromList.show(\r\n                display_names,\r\n                title=\"Select Views for Room/Area Diagram Export\",\r\n                button_name=\"Select Views\",\r\n                multiselect=True\r\n            )\r\n            \r\n            # ============================================================================\r\n            # STEP 6: PROCESS USER SELECTION\r\n            # ============================================================================\r\n            if selected_names:\r\n                selected_views, view_details = self._process_user_selection(selected_names, view_dict)\r\n                \r\n                self.selected_views = selected_views\r\n                self._update_debug_text(selected_views, view_details)\r\n            else:\r\n                self.selected_views = []\r\n                self.debug_textbox.Text = \"No views selected - Please pick views to continue\"\r\n                \r\n        except Exception as e:\r\n            self.debug_textbox.Text = \"ERROR in pick_views: {}. Please try again.\".format(str(e))\r\n            self.selected_views = []\r\n    \r\n    def _is_view_valid(self, view):\r\n        \"\"\"Check if a view object is valid and can be processed.\"\"\"\r\n        return (view and \r\n                view.IsValidObject and \r\n                not view.IsTemplate and \r\n                view.GenLevel is not None)\r\n    \r\n    def _is_view_type_suitable(self, view):\r\n        \"\"\"Check if view type is suitable for room/area diagram processing.\"\"\"\r\n        suitable_types = [DB.ViewType.FloorPlan, DB.ViewType.AreaPlan]\r\n        return view.ViewType in suitable_types\r\n    \r\n    def _create_display_name(self, view):\r\n        \"\"\"\r\n        Create user-friendly display name for view selection.\r\n        \r\n        Format: [ViewType][AreaScheme if available][LevelName] View Name\r\n        \r\n        Args:\r\n            view: Revit view object\r\n            \r\n        Returns:\r\n            str: Formatted display name\r\n        \"\"\"\r\n        # Extract basic information\r\n        level_name = view.GenLevel.Name if view.GenLevel else \"Unknown\"\r\n        view_name = view.Name if view.Name else \"Unknown\"\r\n        view_type = view.ViewType.ToString()\r\n        \r\n        if view.ViewType == DB.ViewType.AreaPlan:\r\n            # For area plans, include area scheme information\r\n            area_scheme = self._get_area_scheme_name(view)\r\n            return \"[{}][{}][{}] {}\".format(view_type, area_scheme, level_name, view_name)\r\n        else:\r\n            # For floor plans, no area scheme needed\r\n            return \"[{}][{}] {}\".format(view_type, level_name, view_name)\r\n    \r\n    def _get_area_scheme_name(self, view):\r\n        \"\"\"Safely extract area scheme name from view.\"\"\"\r\n        try:\r\n            if hasattr(view, 'AreaScheme') and view.AreaScheme:\r\n                return view.AreaScheme.Name\r\n        except:\r\n            pass\r\n        return \"Default\"\r\n    \r\n    def _process_user_selection(self, selected_names, view_dict):\r\n        \"\"\"\r\n        Process user's view selection and map back to view objects.\r\n        \r\n        Args:\r\n            selected_names: List of display names selected by user\r\n            view_dict: Dictionary mapping display names to view objects\r\n            \r\n        Returns:\r\n            tuple: (selected_views, view_details)\r\n        \"\"\"\r\n        selected_views = []\r\n        view_details = []\r\n        \r\n        for selected_name in selected_names:\r\n            try:\r\n                # Get view object from dictionary\r\n                view = view_dict.get(selected_name)\r\n                if view and view.IsValidObject:\r\n                    selected_views.append(view)\r\n                    view_details.append(\"â€¢ {}\".format(selected_name))\r\n            except:\r\n                continue\r\n        \r\n        return selected_views, view_details\r\n    \r\n    def _update_debug_text(self, selected_views, view_details):\r\n        \"\"\"Update debug textbox with selection summary.\"\"\"\r\n        if len(view_details) <= 5:\r\n            # Show all views if 5 or fewer\r\n            display_text = \"Selected {} views:\\n{}\".format(\r\n                len(selected_views), \r\n                \"\\n\".join(view_details)\r\n            )\r\n        else:\r\n            # Show first 3 and summary if more than 5\r\n            display_text = \"Selected {} views:\\n{}\\n... and {} more views\".format(\r\n                len(selected_views), \r\n                \"\\n\".join(view_details[:3]), \r\n                len(selected_views) - 3\r\n            )\r\n        \r\n        self.debug_textbox.Text = display_text\r\n\r\n    @ERROR_HANDLE.try_catch_error()\r\n    def export_click(self, sender, e):\r\n        \"\"\"Handle export button click - start processing via external event.\"\"\"\r\n        # Validate inputs before processing\r\n        is_valid, error_message = InputValidator.validate_all_inputs(\r\n            self.textbox_fillet_radius.Text,\r\n            self.textbox_offset_distance.Text\r\n        )\r\n        \r\n        if not is_valid:\r\n            print(\"Input Validation Error: {}\".format(error_message))\r\n            return\r\n        \r\n        # Convert to float after validation\r\n        fillet_radius = float(self.textbox_fillet_radius.Text)\r\n        offset_distance = float(self.textbox_offset_distance.Text)\r\n        \r\n        # Save settings\r\n        self.save_setting()\r\n        \r\n        # Get current settings - convert UI state to class constants\r\n        element_type = ElementType.ROOMS if self.radio_bt_rooms.IsChecked else ElementType.AREAS\r\n        export_method = ExportMethod.RHINO if self.radio_bt_rhino.IsChecked else ExportMethod.REVIT\r\n        \r\n\r\n        \r\n        # Always require views to be selected\r\n        selected_views = getattr(self, 'selected_views', [])\r\n        if not selected_views:\r\n            REVIT_FORMS.notification(\r\n                main_text=\"No Views Selected\",\r\n                sub_text=\"Please use 'Pick Views' button to select views for processing.\",\r\n                window_title=\"EnneadTab\",\r\n                button_name=\"Close\",\r\n                self_destruct=5\r\n            )\r\n            return\r\n        \r\n        # Create configuration object\r\n        config = ProcessingConfig(\r\n            element_type=element_type,\r\n            export_method=export_method,\r\n            fillet_radius=fillet_radius,\r\n            offset_distance=offset_distance,\r\n            selected_views=getattr(self, 'selected_views', [])\r\n        )\r\n        \r\n        # Start processing via external event\r\n        self.process_event_handler.kwargs = config,  # pyright: ignore\r\n        self.ext_event_process.Raise()\r\n        \r\n        # Update UI\r\n        self.debug_textbox.Text = \"Processing started in background...\"\r\n        print(\"Room/Area diagram export started...\")\r\n\r\n    @ERROR_HANDLE.try_catch_error()\r\n    def close_Click(self, sender, e):\r\n        \"\"\"Handle close button click.\"\"\"\r\n        self.save_setting()\r\n        self.Close()\r\n\r\n    @ERROR_HANDLE.try_catch_error()\r\n    def mouse_down_main_panel(self, sender, e):\r\n        \"\"\"Handle mouse down for window dragging.\"\"\"\r\n        self.DragMove()\r\n\r\n\r\n@LOG.log(__file__, __title__)\r\n@ERROR_HANDLE.try_catch_error()\r\ndef room2diagram(doc):\r\n    \"\"\"Main entry point for the Room/Area diagram export tool.\"\"\"\r\n    \r\n    # Check if Rhino Inside is available - if not, block execution completely\r\n    if not RHINO_INSIDE_IMPORT_OK:\r\n        print(\"Rhino Inside Required.\\nPlease initiate Rhino Inside first for this tool to work.\")\r\n\r\n        return\r\n    \r\n    # Show the GUI for settings and view selection\r\n    room2diagram_ModelessForm()\r\n\r\n\r\n################## main code below #####################\r\noutput = script.get_output()\r\noutput.close_others()\r\n\r\nif __name__ == \"__main__\":\r\n    room2diagram(doc)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "RhinoCommon"
  ],
  "has_docstring": false
}