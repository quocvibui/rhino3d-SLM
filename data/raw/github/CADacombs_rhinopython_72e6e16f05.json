{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/xBrep_deleteFaces.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "xBrep_deleteFaces.py",
  "instruction": "160531-0601: Created.\r\n160824: Now selection of faces can continue after chain fillet selection.\r\n160829: Adjacent faces are now trimmed to one another and attempted to be joined back into a solid.\r\n...",
  "code": "\"\"\"\r\n160531-0601: Created.\r\n160824: Now selection of faces can continue after chain fillet selection.\r\n160829: Adjacent faces are now trimmed to one another and attempted to be joined back into a solid.\r\n        Added bAddCrvs option.\r\n160831: Import-related update.\r\n        joinBrepsWithOneIndividually now allows main breps to start with no faces.\r\n160907-08: Modularizations and now adjacent faces will extend if the solid doesn't heal using other techniques.\r\n160911: Removed brep layer of nesting in orderedLists_AdjacentFLT_perSelFBorders.\r\n        Moved orderedLists_AdjacentFLT_perSelFBorders from brep.py.\r\n160914-15: Now curvesForTrim uses Curve.ClosestPoints before attempting to pull naked edges of polyface breps to face to split.\r\n180612, 190423, 200107: Import-related update.\r\n200107-10: Restarted development of this script.\r\n           Added bHeal and bAddModFaces.\r\n           Now tries Brep.JoinBreps instead of Brep.Join due to forced edge joining of the latter.\r\n           Now determines whether resultant brep is final based on naked edge border counts before versus after processing.\r\n200619: Import-related update.\r\n\r\nTODO: \r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System.Diagnostics import Stopwatch\r\n\r\nimport xBrep_findMatchingFace\r\nimport xBrep_nakedEdgeLoop\r\nimport xBrepFace\r\nimport xBrepFace_extendAtUntrimmedEdge\r\nimport xBrepFace_removeTrim\r\nimport xBrepObject\r\nimport xInput\r\n\r\n\r\nstopwatch = Stopwatch() # One instance will be used for all tests.\r\ntimeLimit = 0.1 # Occurrences of some methods requiring more time (seconds) than this value will be stated.\r\n\r\n\r\nclass Opts:\r\n    \r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    riAddOpts = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    def addOptionDouble(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionDouble(\r\n            getObj, englishName=names[key], numberValue=riOpts[key])\r\n\r\n\r\n    def addOptionInteger(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionInteger(\r\n            getObj, englishName=names[key], intValue=riOpts[key])\r\n\r\n\r\n    def addOptionList(key, names, listValues, values):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionList(\r\n            getObj,\r\n            englishOptionName=names[key],\r\n            listValues=listValues,\r\n            listCurrentIndex=values[key])\r\n\r\n\r\n    def addOptionToggle(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionToggle(\r\n            getObj, englishName=names[key], toggleValue=riOpts[key])\r\n\r\n\r\n    key = 'bHeal'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddModFaces'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'AddFacesOnNoSolid'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddCrvs'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'AddCrvsOnNoSolid'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.keys:\r\n            if key in cls.riOpts:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n\r\n\r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if key in cls.riOpts:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    # Prepare lists for collecting.\r\n    gBreps = []; idx_rgFs_perB = []\r\n    \r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select faces\")\r\n    #go.SetCommandPromptDefault(\"Enter when done\")\r\n\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Surface\r\n    #go.GeometryAttributeFilter = (\r\n    #        ri.Custom.GeometryAttributeFilter.SubSurface)\r\n\r\n    go.AcceptNothing(True)\r\n\r\n    idxs_Opts = {}\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\n    def collectSelection():\r\n        for rdObjRef in go.Objects():\r\n            idx_rgFace = rdObjRef.GeometryComponentIndex.Index\r\n            gBrep = rdObjRef.ObjectId\r\n                \r\n            if not gBrep in gBreps:\r\n                gBreps.append(gBrep)\r\n                idx_rgFs_perB.append(set([idx_rgFace]))\r\n            else:\r\n                if idx_rgFace in idx_rgFs_perB[gBreps.index(gBrep)]:\r\n                    idx_rgFs_perB[gBreps.index(gBrep)].remove(idx_rgFace)\r\n                else:\r\n                    idx_rgFs_perB[gBreps.index(gBrep)].add(idx_rgFace)\r\n\r\n    def unhighlightAllFacesInAllSelectedBreps():\r\n        for gB in gBreps:\r\n            rdB = sc.doc.Objects.FindId(gB) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(gB)\r\n            rdB.UnhighlightAllSubObjects()\r\n        sc.doc.Views.Redraw()\r\n\r\n\r\n    while True:\r\n        idxs_Opts['ChainSelectFillets'] = go.AddOption('ChainSelectFillets')\r\n        Opts.riAddOpts['bHeal'](go)\r\n        if Opts.values['bHeal']:\r\n            Opts.riAddOpts['bAddModFaces'](go)\r\n            Opts.riAddOpts['bAddCrvs'](go)\r\n        Opts.riAddOpts['bEcho'](go)\r\n        Opts.riAddOpts['bDebug'](go)\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n        \r\n        if res == ri.GetResult.Cancel:\r\n            unhighlightAllFacesInAllSelectedBreps()\r\n            gBreps = []; idx_rgFs_perB = []\r\n            break\r\n        elif res == ri.GetResult.Nothing:\r\n            break\r\n        elif res == ri.GetResult.Object:\r\n            collectSelection()\r\n            break\r\n        elif res == ri.GetResult.Option:\r\n\r\n            # Collect any faces already selected.\r\n            collectSelection()\r\n\r\n            if go.Option().Index == idxs_Opts['ChainSelectFillets']:\r\n                sc.doc.Objects.UnselectAll()\r\n                sc.doc.Views.Redraw()\r\n\r\n                rc = xInput.getChainFilletFaces()\r\n                if rc is not None:\r\n                    gBrep, idx_rgFaces_Chain = rc\r\n                    if not gBrep in gBreps:\r\n                        gBreps.append(gBrep)\r\n                        idx_rgFs_perB.append(set(idx_rgFaces_Chain))\r\n                    else:\r\n                        idx_rgFs_perB[gBreps.index(gBrep)] |= set(idx_rgFaces_Chain)\r\n\r\n            Opts.setValues()\r\n            Opts.saveSticky()\r\n            go.ClearCommandOptions()\r\n        \r\n        sc.doc.Objects.UnselectAll() # Necessary when go.Get() is repeated.\r\n        \r\n        # Highlight all faces in selections.\r\n        for b, gB in enumerate(gBreps):\r\n            rdB = sc.doc.Objects.FindId(gB) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(gB)\r\n            rgFs = rdB.BrepGeometry.Faces\r\n            for idxF in idx_rgFs_perB[b]:\r\n                rdB.HighlightSubObject(rgFs[idxF].ComponentIndex(), True)\r\n            rgFs[idxF].Dispose()\r\n        sc.doc.Views.Redraw()\r\n    \r\n    go.Dispose()\r\n    \r\n    unhighlightAllFacesInAllSelectedBreps()\r\n    \r\n    if len(gBreps) == 0:\r\n        return\r\n    \r\n    # Convert nested sets into lists.\r\n    for i, idx_rgFs in enumerate(idx_rgFs_perB):\r\n        idx_rgFs_perB[i] = list(idx_rgFs)\r\n    \r\n    return tuple(\r\n            [gBreps] +\r\n            [idx_rgFs_perB] +\r\n            [Opts.values[key] for key in Opts.keys])\r\n\r\n\r\ndef processBrep(rgBrep0, idx_rgFs, bEcho=False, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rgBrep0\r\n        idx_rgFs: Face indices to delete.\r\n    Returns:\r\n        Success:\r\n            list(rgBreps to replace original geometry)\r\n            list(Original rgBrepFaces adjacent to faces deleted)\r\n            list(Modified rgBrepFaces adjacent to faces deleted)\r\n            list(rgCurves of unaffected edges of adjacent faces)\r\n        Failure: None\r\n    \"\"\"\r\n\r\n\r\n    rgB0 = rgBrep0\r\n    idx_Fs0_toDel = idx_rgFs\r\n\r\n\r\n\r\n    def createOrderedListsOfBrepComponents(rgBrep0, idx_rgFaces0_Sel):\r\n        \"\"\"\r\n        Per edges that border input BrepFace indices,\r\n        create ordered lists of adjacent face, loop, and trim indices.\r\n\r\n        Returns list(BrepFace indices), list(BrepLoop indices), list(BrepTrim indices)\r\n        \"\"\"\r\n    \r\n        idx_Fs0_Sel = idx_rgFaces0_Sel\r\n\r\n        idx_AdjFs = []\r\n        idx_Ls = []\r\n        idx_Ts = []\r\n        idx_Es0_All = []\r\n        idx_Es0_NotSharedBySel = []\r\n    \r\n        # Loop through each face of selected trims.\r\n        for iF, idx_F0_Sel in enumerate(idx_Fs0_Sel):\r\n            rgF_Sel = rgBrep0.Faces[idx_F0_Sel]\r\n            for idx_E in rgF_Sel.AdjacentEdges():\r\n                idx_Es0_All.append(idx_E)\r\n\r\n        for idx_E in set(idx_Es0_All):\r\n            if idx_Es0_All.count(idx_E) == 1:\r\n                idx_Es0_NotSharedBySel.append(idx_E)\r\n            else:\r\n                # Shared by 2 select faces or is a seam.\r\n                pass\r\n\r\n        for idx_rgEdge0_NotShared in idx_Es0_NotSharedBySel:\r\n            idx_rgTrims_ToCheck = rgBrep0.Edges[idx_rgEdge0_NotShared].TrimIndices()\r\n            if len(idx_rgTrims_ToCheck) > 1:\r\n                for idx_rgTrim in idx_rgTrims_ToCheck:\r\n                    idx_rgFace = rgBrep0.Trims[idx_rgTrim].Face.FaceIndex\r\n                    if idx_rgFace not in idx_Fs0_Sel:\r\n                        rgTrim = rgBrep0.Trims[idx_rgTrim]\r\n                        idx_rgFace = rgTrim.Face.FaceIndex\r\n                        idx_rgLoop = rgTrim.Loop.LoopIndex\r\n                        if not idx_rgFace in idx_AdjFs:\r\n                            idx_AdjFs.append(idx_rgFace)\r\n                            idx_Ls.append([idx_rgLoop])\r\n                            idx_Ts.append([[idx_rgTrim]])\r\n                        else:\r\n                            iF = idx_AdjFs.index(idx_rgFace)\r\n                            if not idx_rgLoop in idx_Ls[iF]:\r\n                                idx_Ls[iF].append(idx_rgLoop)\r\n                                idx_Ts[iF].append([idx_rgTrim])\r\n                            else:\r\n                                iL = idx_Ls[iF].index(idx_rgLoop)\r\n                                idx_Ts[iF][iL].append(idx_rgTrim)\r\n    \r\n        return idx_AdjFs, idx_Ls, idx_Ts\r\n\r\n\r\n    def curvesForTrim(rgB_ToSplit, rgBs_Splitters_Now, fIntrsctTol=0.1*sc.doc.ModelAbsoluteTolerance):\r\n        rgFace = rgB_ToSplit.Faces[0]\r\n        rgCrvs_ForTrim = []\r\n        fDevTol = sc.doc.ModelAbsoluteTolerance\r\n        for rgB_Splitter in rgBs_Splitters_Now:\r\n            if rgB_Splitter.Faces.Count == 1:\r\n                # Get brep intersections with single-face splitters.\r\n                stopwatch.Restart()\r\n                b, rgCrvs, rgPts = rg.Intersect.Intersection.BrepBrep(\r\n                        rgB_ToSplit, rgB_Splitter, fIntrsctTol)\r\n                stopwatch.Stop()\r\n                timeElapsed = stopwatch.Elapsed.TotalSeconds\r\n                if timeElapsed > timeLimit:\r\n                    print \"{:.2f} seconds for \" \\\r\n                        \"Intersect.Intersection.BrepBrep\".format(\r\n                        timeElapsed)\r\n                if b and rgCrvs.Count > 0:\r\n                    rgCrvs_ForTrim.extend(rgCrvs)\r\n            elif rgB_Splitter.Faces.Count > 1:\r\n                rgCrvs = rgB_Splitter.DuplicateNakedEdgeCurves(True, True)\r\n                if rgCrvs.Count > 0:\r\n                    # Get intersections of brep with polyface splitter edges.\r\n                    # Only accept curves that lie on brep.\r\n                    for cA in rgCrvs:\r\n                        # Due to Curve.PullToBrepFace possibly hanging Rhino,\r\n                        # first test with Curve.ClosestPoints.\r\n                        stopwatch.Restart()\r\n                        b, ptOnCrv, ptOnObj, iObj = cA.ClosestPoints([rgB_ToSplit])\r\n                        stopwatch.Stop()\r\n                        timeElapsed = stopwatch.Elapsed.TotalSeconds\r\n                        if timeElapsed > timeLimit:\r\n                            print \"{:.2f} seconds for \" \\\r\n                                \"Curve.ClosestPoints\".format(\r\n                                timeElapsed)\r\n                            #if b:\r\n                                #sc.doc.Objects.AddCurve(cA)\r\n                                #sc.doc.Objects.AddBrep(rgB_ToSplit)\r\n                        if not b: continue\r\n                        rgCrvs_Pulled = cA.PullToBrepFace(rgFace, fIntrsctTol)\r\n                        if rgCrvs_Pulled.Count == 1: # Can > 1 curves be useful?\r\n                            cB = rgCrvs_Pulled[0]\r\n                            rc = rg.Curve.GetDistancesBetweenCurves(cA, cB, fDevTol)\r\n                            if rc[0] and rc[1] <= fDevTol: rgCrvs_ForTrim.append(cB)\r\n                else:\r\n                    print \"Not!\"\r\n        return rgCrvs_ForTrim\r\n\r\n\r\n    def joinBrepsSimultaneously(rgBreps_toJoin, iCt_NakedBorders):\r\n        \"\"\"\r\n        Returns:\r\n            list of Breps\r\n            None on failure\r\n        \"\"\"\r\n\r\n        iCt_NB0 = iCt_NakedBorders\r\n\r\n        fTol_Join = max(\r\n            1.001 * max([edge.Tolerance for rgB in rgBreps_toJoin for edge in rgB.Edges]),\r\n            2.1 * sc.doc.ModelAbsoluteTolerance,\r\n        )\r\n\r\n\r\n        rgBs_Joined = rg.Brep.JoinBreps(\r\n                rgBreps_toJoin,\r\n                tolerance=fTol_Join)\r\n\r\n        if not rgBs_Joined:\r\n            if bEcho: print \"Join failed.\"\r\n            return\r\n        \r\n        for rgB in rgBs_Joined:\r\n            if not rgB.IsValid:\r\n                print \"Invalid brep from JoinBreps\"\r\n                for rgB in rgBs_Joined: rgB.Dispose()\r\n                return\r\n\r\n        # Check if all are solid for quick return from this function.\r\n        for rgB in rgBs_Joined:\r\n            if not rgB.IsSolid: break\r\n        else:\r\n            # All breps are solids.\r\n            return rgBs_Joined\r\n\r\n\r\n        # In case some naked edges need some coercing ...\r\n        for iB in range(len(rgBs_Joined)):\r\n            if not rgBs_Joined[iB].IsSolid:\r\n                rgB_JNE = rgBs_Joined[iB].DuplicateBrep()\r\n\r\n                iCt_Joins = rgB_JNE.JoinNakedEdges(fTol_Join)\r\n\r\n                if iCt_Joins:\r\n                    print \"JoinNakedEdges produced {} joins.\".format(\r\n                        iCt_Joins)\r\n\r\n                if rgB_JNE.IsSolid:\r\n                    print \"Brep is now a solid.\"\r\n\r\n                if not rgB_JNE.IsValid:\r\n                    print \"But Brep is no longer valid.\" \\\r\n                        \"  Previous will be used instead.\"\r\n                    rgB_JNE.Dispose()\r\n                else:\r\n                    rgBs_Joined[iB].Dispose()\r\n                    rgBs_Joined[iB] = rgB_JNE\r\n\r\n\r\n        # Check if all are solid.\r\n        for rgB in rgBs_Joined:\r\n            if not rgB.IsSolid: break\r\n        else:\r\n            # All breps are solids.\r\n            return rgBs_Joined\r\n\r\n\r\n        # Check whether the resultant brep(s) has no more naked borders than the input count.\r\n        iCt_NB1_All = 0\r\n\r\n        for rgB in rgBs_Joined:\r\n\r\n            if rgB.IsSolid: continue\r\n\r\n            idx_Es_NB1 = xBrep_nakedEdgeLoop.getEdgeIndicesOfBorders(rgB, None)\r\n            iCt_NB = len(idx_Es_NB1) # 0 == Solid.\r\n            iCt_NB1_All += iCt_NB\r\n\r\n        if iCt_NB1_All > iCt_NB0:\r\n            for rgB in rgBs_Joined: rgB.Dispose()\r\n            return\r\n\r\n\r\n        return rgBs_Joined\r\n\r\n\r\n    def joinBrepsSingly(rgBrep_Main, rgBreps_Others, bDebug=False):\r\n        \"\"\"\r\n        Parameters:\r\n        Returns: New brep on success.\r\n        \"\"\"\r\n\r\n        fTol_Join = max(\r\n            1.001 * max([edge.Tolerance for rgB in [rgBrep_Main] + rgBreps_Others for edge in rgB.Edges]),\r\n            2.1 * sc.doc.ModelAbsoluteTolerance,\r\n        )\r\n\r\n\r\n        # Make working copies of the original input.\r\n        rgB0_Joined_WIP = rgBrep_Main.DuplicateBrep()\r\n        rgBreps_Others_Copy = rgBreps_Others[:]\r\n    \r\n        # If rgB0_Joined_WIP doesn't contain any faces,\r\n        # Append the first brep of rgBreps_Others_Copy to it.\r\n        if rgB0_Joined_WIP.Faces.Count == 0:\r\n            rgB0_Joined_WIP.Append(rgBreps_Others_Copy[0])\r\n            del rgBreps_Others_Copy[0]\r\n\r\n        while True:\r\n            for i, rgBrep_Try in enumerate(rgBreps_Others_Copy):\r\n                bSuccess = rgB0_Joined_WIP.Join(\r\n                    rgBrep_Try, fTol_Join,\r\n                    compact=True)\r\n                # compact=False sometimes creates an invalid brep\r\n                # that doesn't become valid with a later Compact() call.\r\n                if bSuccess:\r\n                    # Successful join, so remove that face from the ID and RG lists\r\n                    # and restart joining with the modified RG list.\r\n                    del rgBreps_Others_Copy[i]\r\n                \r\n                    #sc.doc.Objects.AddBrep(rgB0_Joined_WIP); sc.doc.Views.Redraw(); #1/0\r\n                \r\n                    break # to restart for loop.\r\n            else:\r\n              # Join for each remaining brep to the main has been attempted\r\n              # in an uninterrupted for loop.\r\n              break # out of while loop.\r\n    \r\n        b, sLog = rgB0_Joined_WIP.IsValidWithLog()\r\n        if not b:\r\n            rgB0_Joined_WIP.Dispose()\r\n            print sLog\r\n            print '-'*40\r\n            b, sLog = rgB1_1F.IsValidTopology()\r\n            print sLog\r\n            return\r\n\r\n        #sc.doc.Objects.AddBrep(rgB0_Joined_WIP); sc.doc.Views.Redraw()#; 1/0\r\n\r\n        if rgB0_Joined_WIP is None:\r\n            if bEcho: print \"Join failed.\"\r\n            return\r\n\r\n        if not rgB0_Joined_WIP.IsSolid:\r\n            if bEcho:\r\n                print \"Failed to heal into a solid after trimming faces.\"\r\n            rgB0_Joined_WIP.JoinNakedEdges(2.1*sc.doc.ModelAbsoluteTolerance)\r\n            if rgB0_Joined_WIP.IsSolid:\r\n                if bEcho: print \"JoinNakedEdges resulted in a solid.\"\r\n            else:\r\n                if bEcho: print \"JoinNakedEdges didn't result in a solid.\"\r\n                rgB0_Joined_WIP.Dispose()\r\n                return\r\n\r\n        return rgB0_Joined_WIP\r\n\r\n\r\n    def trim1FaceBrepsWithEachOther(rgBs_1F_ToTrim, ptsOnFaces, rgB_Base, bEcho=False, bDebug=False):\r\n        \"\"\"\r\n        Parameters:\r\n        Returns:\r\n        \"\"\"\r\n\r\n        rgBs_1F_Out = []\r\n        iCtIntersectFails = 0\r\n    \r\n        for iB in range(len(rgBs_1F_ToTrim)):\r\n            rgB_ToSplit = rgBs_1F_ToTrim[iB].DuplicateBrep()\r\n            rgBs_Splitters_Now = rgBs_1F_ToTrim[0:iB] + rgBs_1F_ToTrim[iB:] + rgB_Base\r\n        \r\n            # Create curves from intersections of face with splitters.\r\n            stopwatch.Restart()\r\n            rgCrvs_ForTrim = curvesForTrim(rgB_ToSplit, rgBs_Splitters_Now)\r\n            stopwatch.Stop()\r\n            timeElapsed = stopwatch.Elapsed.TotalSeconds\r\n            if timeElapsed > timeLimit:\r\n                print \"{:.2f} seconds for \" \\\r\n                    \"curvesForTrim\" \\\r\n                    \" for brep {} of {}\".format(\r\n                        timeElapsed, iB, len(rgBs_1F_ToTrim))\r\n        #            if len(rgCrvs_ForTrim) > 1:\r\n        #                sc.doc.Objects.AddBrep(rgB_ToSplit)\r\n        #                map(sc.doc.Objects.AddCurve, rgCrvs_ForTrim)\r\n        \r\n            if len(rgCrvs_ForTrim) == 0:\r\n                iCtIntersectFails += 1\r\n                if bEcho:\r\n                    print \"No intersections found for 1-face brep {} of {}.\".format(\r\n                            iB+1, len(rgBs_1F_ToTrim))\r\n                rgBs_1F_Out.append(rgB_ToSplit)\r\n                continue\r\n        \r\n            #if bDebug: map(sc.doc.Objects.AddCurve, rgCrvs_ForTrim)\r\n        \r\n            # Split face using intersection curves.\r\n            rgF_ToSplit = rgB_ToSplit.Faces[0]\r\n            rgB_Split = rgF_ToSplit.Split(rgCrvs_ForTrim,\r\n                    sc.doc.ModelAbsoluteTolerance)\r\n            if rgB_Split is None:\r\n                rgBs_1F_Out.append(rgB_ToSplit)\r\n                continue\r\n        \r\n            if rgB_Split.Faces.Count == 1:\r\n                rgB_Split.Dispose()\r\n                rgBs_1F_Out.append(rgB_ToSplit)\r\n                continue\r\n        \r\n            #  Find correct face in split brep.\r\n            idx_rgFace_Pos = xBrep_findMatchingFace.usingPointOnFace(\r\n                    rgB_Split, ptsOnFaces[iB])\r\n            if idx_rgFace_Pos is None:\r\n                rgBs_1F_Out.append(rgB_ToSplit)\r\n                continue\r\n            rgB_1F_ForReplace = rgB_Split.Faces[\r\n                    idx_rgFace_Pos].DuplicateFace(False)\r\n            rgBs_1F_Out.append(rgB_1F_ForReplace)\r\n    \r\n        return rgBs_1F_Out, iCtIntersectFails\r\n\r\n\r\n    def isoStatusesToExtend(idx_AdjFs, idx_Ls_perAdjF, idx_Ts_ToRemove_perL_perAdjF):\r\n        \"\"\"\r\n        Returns: List of lists of isoStatuses per adjacent face.\r\n        \"\"\"\r\n        # Use Surface.ClosestSide to determine SENW Trim(s) of each surface to extend.\r\n        rgB0_Shrunk = rgB0.DuplicateBrep()\r\n        rgB0_Shrunk.Faces.ShrinkFaces()\r\n        isoStats_Closest_OnFaces = []\r\n\r\n        for iF, idx_AdjF in enumerate(idx_AdjFs):\r\n            rgFace = rgB0_Shrunk.Faces[idx_AdjF]\r\n            isoStats_Closest_OnFaces.append([])\r\n            for iL, idx_rgLoop in enumerate(idx_Ls_perAdjF[iF]):\r\n                for idx_rgTrim_ToRemove in idx_Ts_ToRemove_perL_perAdjF[iF][iL]:\r\n                    rgTrim = rgB0_Shrunk.Trims[idx_rgTrim_ToRemove]\r\n                    t = rgTrim.DivideByCount(2, False)[0]\r\n                    ptTrim = rgTrim.PointAt(t)\r\n                    #pt3d = rgFace.PointAt(ptTrim.X, ptTrim.Y)\r\n                    #sc.doc.Objects.AddPoint(pt3d)\r\n                    isoStat_Closest_OnFace = rgFace.ClosestSide(ptTrim.X, ptTrim.Y)\r\n                    if isoStat_Closest_OnFace not in isoStats_Closest_OnFaces[iF]:\r\n                        isoStats_Closest_OnFaces[iF].append(isoStat_Closest_OnFace)\r\n\r\n        rgB0_Shrunk.Dispose()\r\n\r\n        return isoStats_Closest_OnFaces\r\n\r\n\r\n    def extend1FaceBrep(rgB1_1F, isoStats_Closest_OnFace):\r\n        \r\n        rgSrf_Ext = rgB1_1F.Faces[0].UnderlyingSurface()\r\n        \r\n        # Extend all isostats of interest for each 1-face brep.\r\n        for isostat in isoStats_Closest_OnFace:\r\n            # Create extended surface.\r\n            rgSrf_Ext = rgSrf_Ext.Extend(isostat, fExtLength, True) # True for smooth.\r\n        \r\n        # Create indices of Trims with which not to trim the extended surface.\r\n        idxTrims_toSkip = []\r\n        for idx, rgTrim in enumerate(rgB1_1F.Trims):\r\n            if any(rgTrim.IsoStatus == iso for iso in\r\n                    isoStats_Closest_OnFace):\r\n                idxTrims_toSkip.append(idx)\r\n        \r\n        stopwatch.Restart()\r\n        rgB1_1F_Adj_Ext = xBrepFace_extendAtUntrimmedEdge.trimExtendedSrf(\r\n                rgSrf_Ext,\r\n                rgB1_1F,\r\n                idxTrims_toSkip,\r\n                bEcho=bDebug,\r\n                bDebug=bDebug)\r\n        stopwatch.Stop()\r\n        timeElapsed = stopwatch.Elapsed.TotalSeconds\r\n        if timeElapsed > timeLimit:\r\n            print \"{:.2f} seconds for \" \\\r\n                \"xBrepFace_extendAtUntrimmedEdge.trimExtendedSrf\".format(\r\n                timeElapsed)\r\n            #sc.doc.Objects.AddBrep(rgB1_1F_Adj_Ext)\r\n        \r\n        return rgB1_1F_Adj_Ext\r\n\r\n\r\n    def extend1FaceBreps(rgBs1_1F_Adj_ForExt, isoStats_Closest_OnFaces):\r\n        \r\n        rgBs_Adj_Extended = []\r\n        \r\n        for iB in range(len(rgBs1_1F_Adj_ForExt)):\r\n            rgB_In = rgBs1_1F_Adj_ForExt[iB]\r\n\r\n            #sEval = 'rgB_In.IsSolid'; print sEval+':',eval(sEval)\r\n            if rgB_In.IsSolid:\r\n                rgBs_Adj_Extended.append(rgB_In.DuplicateBrep())\r\n            elif not xBrepFace_extendAtUntrimmedEdge.isBrepReadyForExtend(\r\n                    rgB_In, bEcho=bEcho, bDebug=bDebug):\r\n                if bEcho:\r\n                    s = \"Brep {} of rgBs1_1F_Adj_ForExt is not ready to be \" \\\r\n                          \"extended and will be skipped.\".format(iB)\r\n                    print s\r\n                #sc.doc.Objects.AddBrep(rgB1_1F)\r\n                rgBs_Adj_Extended.append(rgB_In.DuplicateBrep())\r\n            else:\r\n                rgB_Out = extend1FaceBrep(rgB_In, isoStats_Closest_OnFaces[iB])\r\n                \r\n                if rgB_Out is not None:\r\n                    rgBs_Adj_Extended.append(rgB_Out)\r\n                    #sc.doc.Objects.AddBrep(rgB_Out); sc.doc.Views.Redraw()\r\n        \r\n        return rgBs_Adj_Extended\r\n\r\n\r\n\r\n    # Collect into lists the faces, loops, and trims\r\n    # of adjacent faces that share edges of faces to remove.\r\n    rc = createOrderedListsOfBrepComponents(\r\n        rgB0,\r\n        idx_Fs0_toDel)\r\n    (\r\n        idx_AdjFs,\r\n        idx_Ls_perAdjF,\r\n        idx_Ts_ToRemove_perL_perAdjF\r\n    ) = rc\r\n\r\n    if bDebug:\r\n        sEval = 'idx_AdjFs'; print sEval+':',eval(sEval)\r\n        sEval = 'idx_Ls_perAdjF'; print sEval+':',eval(sEval)\r\n        sEval = 'idx_Ts_ToRemove_perL_perAdjF'; print sEval+':',eval(sEval)\r\n\r\n\r\n    # Remove selected and adjacent faces from brep.\r\n    # It is OK if brep has no faces left.\r\n    idx_rgFaces_ToRemove = idx_Fs0_toDel + idx_AdjFs\r\n    idx_rgFaces_ToRemove.sort(reverse=True)\r\n    rgB_Unaffected = rgB0.DuplicateBrep()\r\n    for idx_rgFace_ToRemove in idx_rgFaces_ToRemove:\r\n        rgB_Unaffected.Faces.RemoveAt(idx_rgFace_ToRemove)\r\n\r\n    rgBs_Adj_0 = [rgB0.Faces[idx].DuplicateFace(True) for idx in idx_AdjFs]\r\n\r\n\r\n    print \"Phase 1: Untrim adjacent faces and join all.\"\r\n\r\n\r\n    # From adjacent faces, remove trim common with those of faces to remove.\r\n    rgBs_Adj_RemovedSharedT = []\r\n    rgCrvs1_Joined = []\r\n\r\n    for iF, idx_AdjF in enumerate(idx_AdjFs):\r\n        \r\n        if iF == 3:\r\n            pass\r\n        \r\n        rc = xBrepFace_removeTrim.removeTrim(\r\n                rgB0,\r\n                idx_AdjF,\r\n                idx_Ls_perAdjF[iF],\r\n                idx_Ts_ToRemove_perL_perAdjF[iF],\r\n                bDebug=bDebug)\r\n\r\n        if rc is None or rc[0] is None:\r\n            print \"f[{}] not untrimmed!\".format(idx_AdjF)\r\n            for rgB in rgBs_Adj_RemovedSharedT: rgB.Dispose()\r\n            return [rgB_Unaffected], rgBs_Adj_0, [], []\r\n\r\n        rgB1_1F, rgEdges_NotSelButInLoopsWithSel = rc\r\n        \r\n        rgBs_Adj_RemovedSharedT.append(rgB1_1F)\r\n        \r\n        # Join curves.\r\n        if len(rgEdges_NotSelButInLoopsWithSel) > 0:\r\n            rgCrvs1_Joined.extend(Rhino.Geometry.Curve.JoinCurves(\r\n                    rgEdges_NotSelButInLoopsWithSel))\r\n\r\n\r\n    # Get point on each original adjacent face to later use to find correct faces of split brep.\r\n    ptsOnFaces = []\r\n    for idx_AdjF in idx_AdjFs:\r\n        if idx_AdjF == 36:\r\n            pass\r\n        \r\n        pt = xBrepFace.createPoint3dOnInterior(rgB0.Faces[idx_AdjF])\r\n        if pt is None:\r\n            print \"Point on face not found!\" \\\r\n                \"Only non-modified adjacent faces will be added.\"\r\n            for rgB in rgBs_Adj_RemovedSharedT: rgB.Dispose()\r\n\r\n            sc.doc.Objects.AddBrep(rgB0.Faces[idx_AdjF].DuplicateFace(False))\r\n            sc.doc.Views.Redraw(); return\r\n\r\n            return [rgB_Unaffected], rgBs_Adj_0, [], []\r\n\r\n        ptsOnFaces.append(pt)\r\n    \r\n\r\n\r\n    # Track number of naked borders of initial brep to determine\r\n    # expectations of naked borders of final breps.\r\n    idx_Es_nakedBorders0 = xBrep_nakedEdgeLoop.getEdgeIndicesOfBorders(rgB0, None)\r\n    iCt_NakedBorders = len(idx_Es_nakedBorders0) # 0 == Solid.\r\n\r\n\r\n    rgBs_Joined = joinBrepsSimultaneously(\r\n        [rgB_Unaffected] + rgBs_Adj_RemovedSharedT,\r\n        iCt_NakedBorders)\r\n    if rgBs_Joined is not None:\r\n        if bEcho:\r\n            print \"Brep healed after \" \\\r\n                \"untrimming adjacent faces.\"\r\n\r\n        rgB_Unaffected.Dispose()\r\n        for rgB in rgBs_Adj_0: rgB.Dispose()\r\n        for rgB in rgBs_Adj_RemovedSharedT: rgB.Dispose()\r\n\r\n        return rgBs_Joined, [], [], rgCrvs1_Joined\r\n\r\n    #rgB_Joined = joinBrepsSingly(\r\n    #    rgB_Unaffected,\r\n    #    rgBs_Adj_RemovedSharedT,\r\n    #    bDebug=bDebug)\r\n    #if rgB_Joined is not None:\r\n    #    if bEcho: print \"Brep healed into a solid after untrimming adjacent faces.\"\r\n    #    rgB_Unaffected.Dispose()\r\n    #    for rgB in rgBs_Adj_RemovedSharedT: rgB.Dispose()\r\n    #    return rgB_Joined, rgBs_Adj_0, [], rgCrvs1_Joined\r\n\r\n    if bEcho: print \"Failed to heal after untrimming adjacent faces.\"\r\n\r\n\r\n    print \"Phase 2: Trim adjacent faces and join all.\"\r\n\r\n    if bEcho: print \"Trimming adjacent faces with one another...\"\r\n    rc = trim1FaceBrepsWithEachOther(\r\n            rgBs_Adj_RemovedSharedT,\r\n            ptsOnFaces=ptsOnFaces,\r\n            rgB_Base=[],\r\n            bEcho=bEcho,\r\n            bDebug=bDebug)\r\n    rgBs_Adj_NewTrim, iCtIntersectFails = rc\r\n    \r\n    if iCtIntersectFails > 0:\r\n        if bEcho:\r\n            print \"Intersects for trimming not found for {} out of {} faces.\".format(\r\n                    iCtIntersectFails, len(rgBs_Adj_NewTrim))\r\n\r\n\r\n    rgBs_Joined = joinBrepsSimultaneously(\r\n        [rgB_Unaffected] + rgBs_Adj_NewTrim,\r\n        iCt_NakedBorders)\r\n    if rgBs_Joined is not None:\r\n        if bEcho:\r\n            print \"Brep healed after \" \\\r\n                \"trimming adjacent faces.\"\r\n\r\n        rgB_Unaffected.Dispose()\r\n        for rgB in rgBs_Adj_0: rgB.Dispose()\r\n        for rgB in rgBs_Adj_NewTrim: rgB.Dispose()\r\n\r\n        return rgBs_Joined, [], [], rgCrvs1_Joined\r\n\r\n    #rgB_Joined = joinBrepsSingly(\r\n    #    rgB_Unaffected,\r\n    #    rgBs_Adj_NewTrim,\r\n    #    bDebug=bDebug)\r\n    #if rgB_Joined is not None:\r\n    #    if bEcho: print \"Brep healed into a solid after trimming adjacent faces.\"\r\n    #    rgB_Unaffected.Dispose()\r\n    #    for rgB in rgBs_Adj_NewTrim: rgB.Dispose()\r\n    #    return rgB_Joined, rgBs_Adj_0, [], rgCrvs1_Joined\r\n\r\n    for rgB in rgBs_Adj_NewTrim: rgB.Dispose()\r\n\r\n    if bEcho: print \"Failed to heal brep after trimming adjacent faces.\"\r\n\r\n\r\n    print \"Phase 3: Extend the adjacent faces and trim again.\"\r\n\r\n    ## Shrink planar, cylindrical, and conical surfaces before extend.\r\n    #rgBs1_1F_Adj_ForExt = []\r\n    #tol = sc.doc.ModelAbsoluteTolerance\r\n    #for rgB1_1F_Adj in rgBs1_1F_Adj:\r\n    #    rgB1_1F_Adj_ForExt = rgB1_1F_Adj.DuplicateBrep()\r\n    #    rgF = rgB1_1F_Adj_ForExt.Faces[0]\r\n    #    if rgF.IsPlanar(tol) or rgF.IsCylinder(tol) or rgF.IsCone(tol):\r\n    #        print rgB1_1F_Adj_ForExt.Faces.ShrinkFaces()\r\n    #    rgBs1_1F_Adj_ForExt.append(rgB1_1F_Adj_ForExt)\r\n\r\n\r\n    isoStats_Closest_OnFaces = isoStatusesToExtend(\r\n        idx_AdjFs,\r\n        idx_Ls_perAdjF,\r\n        idx_Ts_ToRemove_perL_perAdjF)\r\n    \r\n    # For surface extension length,\r\n    # use diagonal dimension of bounding box of faces to delete.\r\n    rgBs_Sel = map(lambda x: rgB0.Faces[x].DuplicateFace(True), idx_Fs0_toDel)\r\n    bbox = rgBs_Sel[0].GetBoundingBox(True)\r\n    rgBs_Sel[0].Dispose()\r\n    if rgBs_Sel.Count > 1:\r\n        for i in range(1, len(rgBs_Sel)):\r\n            bbox.Union(rgBs_Sel[i].GetBoundingBox(True))\r\n            rgBs_Sel[i].Dispose()\r\n    fExtLength = bbox.Min.DistanceTo(bbox.Max)\r\n\r\n    rgBs_Adj_Extended = extend1FaceBreps(rgBs_Adj_RemovedSharedT, isoStats_Closest_OnFaces)\r\n\r\n    rc = trim1FaceBrepsWithEachOther(\r\n            rgBs_Adj_Extended,\r\n            ptsOnFaces,[rgB_Unaffected],\r\n            bEcho=bEcho,\r\n            bDebug=bDebug)\r\n    rgBs_Adj_NewTrim, iCtIntersectFails = rc\r\n\r\n    for rgB in rgBs_Adj_Extended: rgB.Dispose()\r\n\r\n    #for rgB in rgBs_Adj_NewTrim: sc.doc.Objects.AddBrep(rgB)\r\n    #sc.doc.Views.Redraw(); return\r\n\r\n    rgBs_Joined = joinBrepsSimultaneously(\r\n        [rgB_Unaffected] + rgBs_Adj_NewTrim,\r\n        iCt_NakedBorders)\r\n    if rgBs_Joined is not None:\r\n        if bEcho:\r\n            print \"Brep healed after \" \\\r\n                \"extending and trimming adjacent faces.\"\r\n\r\n        rgB_Unaffected.Dispose()\r\n        for rgB in rgBs_Adj_0: rgB.Dispose()\r\n        for rgB in rgBs_Adj_NewTrim: rgB.Dispose()\r\n\r\n        return rgBs_Joined, [], [], rgCrvs1_Joined\r\n\r\n    #rgB_Joined = joinBrepsSingly(\r\n    #    rgB_Unaffected,\r\n    #    rgBs_Adj_NewTrim,\r\n    #    bDebug=bDebug)\r\n    #if rgB_Joined is not None:\r\n    #    if bEcho: print \"Brep healed into a solid after extending and trimming adjacent faces.\"\r\n    #    rgB_Unaffected.Dispose()\r\n    #    for rgB in rgBs_Adj_NewTrim: rgB.Dispose()\r\n    #    return rgB_Joined, rgBs_Adj_0, [], rgCrvs1_Joined\r\n\r\n    for rgB in rgBs_Adj_NewTrim: rgB.Dispose()\r\n\r\n    if bEcho: print \"Failed to heal after extending and trimming adjacent faces.\"\r\n\r\n    return [rgB_Unaffected], [], rgBs_Adj_RemovedSharedT, rgCrvs1_Joined\r\n\r\n\r\ndef processBrepObjects(gBreps0, idx_rgFs_perB0, bHeal=True, bAddModFaces=True, bAddCrvs=True, bEcho=False, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        idBreps0 (optional)\r\n        idx_rgFs_perB (optional): Faces to be deleted\r\n    Returns: None\r\n    \"\"\"\r\n    \r\n    Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\r\n    \r\n    # Loop through breps.\r\n    for iB0 in range(len(gBreps0)):\r\n        gBrep0 = gBreps0[iB0]\r\n        rdBrep0 = sc.doc.Objects.FindId(gBrep0) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(gBrep0)\r\n        rgB0 = rdBrep0.BrepGeometry # Do not modify this brep.\r\n\r\n        if not rgB0.IsValid:\r\n            if bEcho: print \"Invalid brep skipped.\"\r\n            rgB0.Dispose()\r\n            continue\r\n\r\n        idx_rgFs0_thisB = idx_rgFs_perB0[iB0] # Faces of 1 brep, so no nesting.\r\n        \r\n        if rgB0.Faces.Count == len(idx_rgFs0_thisB):\r\n            sc.doc.Objects.Delete(gBrep0, False)\r\n            rgB0.Dispose()\r\n            if bEcho:\r\n                print \"All faces of brep were selected,\" \\\r\n                    \" so the entire brep was deleted.\"\r\n            continue\r\n        \r\n        if not bHeal:\r\n            xBrepObject.removeFaces(rdBrep0, idx_rgFs0_thisB)\r\n            continue\r\n\r\n        rc = processBrep(\r\n            rgBrep0=rgB0,\r\n            idx_rgFs=idx_rgFs0_thisB,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug)\r\n        rgB0.Dispose()\r\n        \r\n        if not rc: continue\r\n\r\n        (\r\n            rgB1s_forReplacement,\r\n            rgBs_Adj_0,\r\n            rgBs_Adj_Mod,\r\n            rgCrvs_RemainingTsOfAdjFs,\r\n        ) = rc\r\n\r\n        if len(rgB1s_forReplacement) == 1 and not rgBs_Adj_0 and not rgBs_Adj_Mod:\r\n            if not xBrepObject.replaceGeometry(rdBrep0, rgB1s_forReplacement):\r\n                if bEcho: print \"Replacing original brep failed.\"\r\n        else:\r\n            if bAddModFaces and rgBs_Adj_Mod:\r\n                for iB in range(len(rgBs_Adj_Mod)):\r\n                    idB1_1F = sc.doc.Objects.AddBrep(\r\n                        rgBs_Adj_Mod[iB], rdBrep0.Attributes)\r\n                if bEcho:\r\n                    print \"Modified \" \\\r\n                        \"faces adjacent with those removed have been extracted.\"\r\n            elif rgBs_Adj_0:\r\n                for iB in range(len(rgBs_Adj_0)):\r\n                    idB1_1F = sc.doc.Objects.AddBrep(\r\n                        rgBs_Adj_0[iB], rdBrep0.Attributes)\r\n                if bEcho:\r\n                    print \"Unmodified \" \\\r\n                        \"faces adjacent with those removed have been extracted.\"\r\n\r\n            # Replace original brep with one (or more) with removed faces.\r\n            xBrepObject.replaceGeometry(rdBrep0, rgB1s_forReplacement)\r\n\r\n            if bAddCrvs and (rgBs_Adj_0 or rgBs_Adj_Mod):\r\n                for rgCrv in rgCrvs_RemainingTsOfAdjFs:\r\n                    # Using default attributes so curves are more noticeable\r\n                    # than the untrimmed faces.\r\n                    sc.doc.Objects.AddCurve(rgCrv)\r\n                sc.doc.Views.Redraw()\r\n\r\n        for rgB in rgB1s_forReplacement: rgB.Dispose()\r\n        for rgB in rgBs_Adj_0: rgB.Dispose()\r\n        for rgB in rgBs_Adj_Mod: rgB.Dispose()\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\ndef main():\r\n    \r\n    rc = getInput()\r\n    if rc is None: return\r\n\r\n    (\r\n        gBreps0,\r\n        idx_rgFs_perB,\r\n        bHeal,\r\n        bAddModFaces,\r\n        bAddCrvs,\r\n        bEcho,\r\n        bDebug,\r\n    ) = rc\r\n\r\n    if gBreps0 is None or idx_rgFs_perB is None: return\r\n\r\n    if Opts.values['bDebug']:\r\n        print \"Running with Debug mode on.\"\r\n        import sys\r\n        for sModule in list(sys.modules):\r\n            if sModule[0] == 'x':\r\n                try:\r\n                    reload(sys.modules[sModule])\r\n                    print \"{} reloaded.\".format(sModule)\r\n                except:\r\n                    s  = \"{} NOT reloaded.\".format(sModule)\r\n                    s += \"  Does the module contain a bug\"\r\n                    s += \" or was its name changed?\"\r\n                    print s\r\n\r\n    processBrepObjects(\r\n        gBreps0=gBreps0,\r\n        idx_rgFs_perB0=idx_rgFs_perB,\r\n        bHeal=bHeal,\r\n        bAddModFaces=bAddModFaces,\r\n        bAddCrvs=bAddCrvs,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug)\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}