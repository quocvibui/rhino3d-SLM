{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Crv_modifyLength.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Crv_modifyLength.py",
  "instruction": "This script allows the modification of a curve's length to be set to a entered value or\r\nto match the length of another curve.\r\n\r\nIt is an alternative script to Pascal Golay's\r\nRelimitCurve.py (June...",
  "code": "\"\"\"\r\nThis script allows the modification of a curve's length to be set to a entered value or\r\nto match the length of another curve.\r\n\r\nIt is an alternative script to Pascal Golay's\r\nRelimitCurve.py (June 2024) https://discourse.mcneel.com/t/questions-about-the-extend-command-for-curves/183480/4\r\nSetCurveLength (November 2022) https://discourse.mcneel.com/t/matching-curve-lengths-with-a-macro/151353/6\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums, https://discourse.mcneel.com/\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n250727: Started with Pascal Golay's RelimitCurve.py (see above).\r\n\r\nTODO:\r\n    Support BrepEdges as input Curves. Their resultant Curves will be added to the document (No Brep modification).\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bBoth'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'ModifyEnd'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'NearPick', 'Both')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fLength'; keys.append(key)\r\n    values[key] = 1.0\r\n    names[key] = 'fNewLength'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.ModelUnitSystem)\r\n\r\n    key = 'bReplace'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'DocAction'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Add', 'Replace')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef _formatDistance(fDistance, iPrecision=None):\r\n    if iPrecision is None:\r\n        iPrecision = sc.doc.ModelDistanceDisplayPrecision\r\n\r\n    if fDistance is None:\r\n        return \"(No deviation provided)\"\r\n\r\n    if fDistance < 10**-iPrecision:\r\n        return \"{:.{}e}\".format(fDistance, 0)\r\n\r\n    if fDistance < 0.1:\r\n        return \"{:.{}g}\".format(fDistance, iPrecision)\r\n\r\n    return \"{:.{}f}\".format(fDistance, iPrecision)\r\n\r\n\r\ndef getInput_CrvsToMod():\r\n    \"\"\"\r\n    Get curves with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n    go.GeometryAttributeFilter = ri.Custom.GeometryAttributeFilter.WireCurve\r\n\r\n    #go.OneByOnePostSelect = True\r\n    go.DisablePreSelect()\r\n\r\n    idxs_Opt = {}\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('bBoth')\r\n        addOption('bReplace')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        if Opts.values['bBoth']:\r\n            go.SetCommandPrompt(\"Select curves to modify\")\r\n            res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n        else:\r\n            go.SetCommandPrompt(\"Select curve near its end to modify\")\r\n            res = go.Get()\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef getInput_TargetLength(fStartLength=None):\r\n    \"\"\"\r\n    Get float with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n\r\n    if fStartLength is None:\r\n        go.SetCommandPrompt(\"Enter target length or select curve to match its length\")\r\n    else:\r\n        go.SetCommandPrompt(\"Starting length is {}. Enter target length or select curve to match its length\".format(\r\n            _formatDistance(fStartLength)))\r\n\r\n    go.SetCommandPromptDefault(str(Opts.values['fLength']))\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n    go.AcceptNothing(True)\r\n\r\n    go.DisablePreSelect()\r\n\r\n    idxs_Opt = {}\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('bReplace')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.Get()\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            go.Dispose()\r\n            return Opts.values['fLength']\r\n\r\n        if res == ri.GetResult.Object:\r\n            objref = go.Object(0)\r\n            go.Dispose()\r\n            fLength = objref.Curve().GetLength()\r\n            sc.sticky[Opts.stickyKeys['fLength']] = fLength\r\n            return fLength\r\n\r\n        if res == ri.GetResult.Number:\r\n            fLength = go.Number()\r\n            if fLength < Rhino.RhinoMath.ZeroTolerance:\r\n                print(\"Value must be greater than {}\".format(Rhino.RhinoMath.ZeroTolerance))\r\n                continue\r\n            sc.sticky[Opts.stickyKeys['fLength']] = fLength\r\n            return fLength\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef _curveEnd_closestToPick(objref_Crv):\r\n    rgCrv = objref_Crv.Curve()\r\n\r\n    bSuccess, t = rgCrv.ClosestPoint(objref_Crv.SelectionPoint())\r\n    if not bSuccess:\r\n        return\r\n\r\n    t_MidLength = rgCrv.DivideByCount(segmentCount=2, includeEnds=False)[0]\r\n\r\n    return rg.CurveEnd.End if t >= t_MidLength else rg.CurveEnd.Start\r\n\r\n\r\ndef modifyCurveLength(crv_In, fLength_Target, end):\r\n    \"\"\"\r\n    Returns a new rg.Curve\r\n    \"\"\"\r\n\r\n    fLength_Start = crv_In.GetLength()\r\n\r\n    fLength_Delta = fLength_Target - fLength_Start\r\n\r\n    if fLength_Target < fLength_Start:\r\n        fLength_toRemove = fLength_Start - fLength_Target\r\n        return rg.Curve.Trim(\r\n            crv_In,\r\n            side=end,\r\n            length=fLength_toRemove/2.0 if end==rg.CurveEnd.Both else fLength_toRemove)\r\n    else:\r\n        fLength_toAdd = fLength_Target - fLength_Start\r\n        return rg.Curve.Extend(\r\n            crv_In,\r\n            side=end,\r\n            length=fLength_toAdd/2.0 if end == rg.CurveEnd.Both else fLength_toAdd,\r\n            style=rg.CurveExtensionStyle.Smooth)\r\n\r\n\r\ndef main():\r\n\r\n    objrefs = getInput_CrvsToMod()\r\n    if objrefs is None: return\r\n\r\n    bBoth = Opts.values['bBoth']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n    sc.doc.Views.Redraw()\r\n\r\n    fLength_Target = getInput_TargetLength(objrefs[0].Curve().GetLength() if objrefs.Count==1 else None)\r\n    if fLength_Target is None: return\r\n    #sEval = \"fLength_Target\"; print(sEval,'=', eval(sEval))\r\n\r\n    bReplace = Opts.values['bReplace']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    if bBoth:\r\n        end = rg.CurveEnd.Both\r\n\r\n    gAlreadyAtTarget = []\r\n    gFailed = []\r\n    gMissedTarget_Arc = []\r\n    gMissedTarget_Other = []\r\n    gAdded = []\r\n    gModified = []\r\n\r\n    for objref in objrefs:\r\n\r\n        crv_In = objref.Curve()\r\n\r\n        if not bBoth:\r\n            end = _curveEnd_closestToPick(objrefs[0])\r\n\r\n\r\n        fLength_In = crv_In.GetLength()\r\n\r\n        fLength_Delta = fLength_Target - fLength_In\r\n        if abs(fLength_Delta) <= (0.1 * sc.doc.ModelAbsoluteTolerance):\r\n            gAlreadyAtTarget.append(objref.ObjectId)\r\n            continue\r\n\r\n        crv_Res = modifyCurveLength(crv_In, fLength_Target, end)\r\n        if crv_Res is None:\r\n            gFailed.append(objref.ObjectId)\r\n            continue\r\n\r\n        fLength_Res = crv_Res.GetLength()\r\n\r\n        if abs(fLength_Res - fLength_Target) > (0.1 * sc.doc.ModelAbsoluteTolerance):\r\n            if isinstance(crv_In, rg.ArcCurve):\r\n                gMissedTarget_Arc.append(objref.ObjectId)\r\n            else:\r\n                gMissedTarget_Other.append(objref.ObjectId)\r\n            crv_Res.Dispose()\r\n            continue\r\n\r\n        if bReplace:\r\n            if sc.doc.Objects.Replace(objref, crv_Res):\r\n                gModified.append(objref.ObjectId)\r\n            else:\r\n                gFailed.append(objref.ObjectId)\r\n        else:\r\n            gCrv_Out = sc.doc.Objects.AddCurve(crv_Res)\r\n            if gCrv_Out != gCrv_Out.Empty:\r\n                gAdded.append(gCrv_Out)\r\n            else:\r\n                gFailed.append(objref.ObjectId)\r\n\r\n    if bEcho:\r\n        if objrefs.Count == 1:\r\n            if gAdded:\r\n                print(\"Added curve with length of {}\".format(\r\n                    _formatDistance(fLength_Res)))\r\n            elif gModified:\r\n                print(\"Curve length is now {}\".format(\r\n                    _formatDistance(fLength_Res)))\r\n            elif gAlreadyAtTarget:\r\n                print(\"Curve is already at target length, {}.\".format(\r\n                    _formatDistance(fLength_Target)))\r\n            elif gMissedTarget_Arc:\r\n                print(\"Skipped arc curve with length of {}.\".format(\r\n                    _formatDistance(fLength_Res)))\r\n            elif gMissedTarget_Other:\r\n                print(\"Skipped curve with length of {}.\".format(\r\n                    _formatDistance(fLength_Res)))\r\n            elif gFailed:\r\n                print(\"Failed to create curve with new length, {}.\".format(\r\n                    _formatDistance(fLength_Target)))\r\n        elif objrefs.Count > 1:\r\n            if gAdded:\r\n                print(\"Added {} curves each with length of {}\".format(\r\n                    len(gAdded),\r\n                    _formatDistance(fLength_Target)))\r\n            if gModified:\r\n                print(\"Modified length of {} curves to {}\".format(\r\n                    len(gModified),\r\n                    _formatDistance(fLength_Target)))\r\n            if gAlreadyAtTarget:\r\n                print(\"{} curves are already at target length and were not modified.\".format(\r\n                    len(gAlreadyAtTarget)))\r\n            if gMissedTarget_Arc:\r\n                print(\"{} arc curves could not be modified to target length.\".format(\r\n                    len(gMissedTarget_Arc)))\r\n            if gMissedTarget_Other:\r\n                print(\"{} non-arc curves could not be modified to target length.\".format(\r\n                    len(gMissedTarget_Other)))\r\n            if gFailed:\r\n                print(\"{} curves were not modified.\".format(len(gFailed)))\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}