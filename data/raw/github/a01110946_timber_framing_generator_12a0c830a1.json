{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_baking_data_parser.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_baking_data_parser.py",
  "instruction": "GHPython Component: Baking Data Parser",
  "code": "# File: scripts/gh_baking_data_parser.py\n\"\"\"\nGHPython Component: Baking Data Parser\n\nFlattens the nested baking_data_json structure into parallel lists suitable\nfor Grasshopper's data matching requirements.\n\nInputs:\n    baking_data_json (JSON) - str:\n        JSON string from Revit Baker component\n        Required: Yes\n        Access: Item\n\n    filter_classification (Filter) - str:\n        Optional filter: \"column\", \"beam\", or empty for all\n        Required: No (defaults to all)\n        Access: Item\n\n    run (Run) - bool:\n        Boolean to trigger execution\n        Required: Yes\n        Access: Item\n\nOutputs:\n    wall_ids (WID) - list[str]:\n        Wall IDs (one per member, for grouping/data matching)\n\n    element_ids (EID) - list[str]:\n        Element IDs\n\n    element_types (Type) - list[str]:\n        Element types (stud, bottom_plate, etc.)\n\n    classifications (Class) - list[str]:\n        Classifications (column or beam)\n\n    profile_names (Prof) - list[str]:\n        Profile names (350S162-54, 2x4, etc.)\n\n    revit_type_names (RType) - list[str]:\n        Matched Revit type names\n\n    csr_angles (CSR) - list[float]:\n        Cross-Section Rotation angles in degrees (beams only, 0.0 for columns)\n\n    geometry_indices (GIdx) - list[int]:\n        Indices linking to column_curves/beam_curves DataTrees\n\n    column_planes (ColPln) - list[Plane]:\n        Orientation planes for columns (use to update Location after creation).\n        For beams, this will be None/invalid plane.\n\n    base_level_ids (BLvl) - list[int]:\n        Base level IDs (from wall, per member)\n\n    top_level_ids (TLvl) - list[int]:\n        Top level IDs (from wall, per member)\n\n    centerline_starts (PtS) - list[Point3d]:\n        Centerline start points\n\n    centerline_ends (PtE) - list[Point3d]:\n        Centerline end points\n\n    debug_info (Info) - str:\n        Processing summary\n\nUsage:\n    1. Connect 'baking_data_json' from Revit Baker\n    2. Optionally set 'filter_classification' to \"column\" or \"beam\"\n    3. Set 'run' to True\n    4. Connect outputs to downstream components\n\nNotes:\n    - All outputs are parallel lists with the same length\n    - base_level_id and top_level_id are inherited from the wall for each member\n    - Use filter_classification to get only columns or beams for RiR components\n    - geometry_index links to the corresponding curve in column_curves or beam_curves\n    - column_planes contains valid Plane objects for columns (for Location update)\n    - column_planes contains Plane.Unset for beams (use csr_angles instead)\n\nColumn Orientation Workflow:\n    1. Create columns using column_curves from Revit Baker\n    2. After creation, update column Location using column_planes to set orientation\n    3. The plane's X-axis controls where the C-section lips face\n\nExtending This Component (Adding New Fields):\n    To add a new output field, follow these steps:\n\n    IMPORTANT: In GHPython, the NickName becomes the Python variable name!\n    Format: (DisplayName, variable_name, Description)\n\n    1. Add to OUTPUT_CONFIG in setup_component():\n       ```\n       (\"My New Field\", \"my_new_field\", \"Description of my new field\"),\n       ```\n\n    2. Initialize the output list at the top of Main Execution section:\n       ```\n       my_new_field = []\n       ```\n\n    3. Append to it inside the member processing loop (after \"# Extract all\n       member properties\" comment):\n       ```\n       # For member-level properties:\n       my_new_field.append(member.get(\"my_json_key\", default_value))\n\n       # For wall-level properties (inherited per member):\n       my_new_field.append(wall_data.get(\"my_wall_key\", default_value))\n       ```\n\n    4. (Optional) Add to debug output counts for verification:\n       ```\n       f\"  my_new_field: {len(my_new_field)}\",\n       ```\n\n    Example - Adding a \"cell_id\" output:\n       Step 1: (\"Cell IDs\", \"cell_ids\", \"Cell IDs for each member\"),\n       Step 2: cell_ids = []\n       Step 3: cell_ids.append(member.get(\"cell_id\", \"\"))\n       Step 4: f\"  cell_ids: {len(cell_ids)}\",\n\nEnvironment:\n    Rhino 8, Grasshopper, Python component (CPython 3)\n\nAuthor: Timber Framing Generator Project\nVersion: 1.0.0\n\"\"\"\n\nimport sys\nimport json\n\n# =============================================================================\n# Force Module Reload (CPython 3 in Rhino 8)\n# =============================================================================\n_modules_to_clear = [k for k in sys.modules.keys() if 'timber_framing_generator' in k]\nfor mod in _modules_to_clear:\n    del sys.modules[mod]\nprint(f\"[RELOAD] Cleared {len(_modules_to_clear)} cached timber_framing_generator modules\")\n\n# =============================================================================\n# RhinoCommon / Grasshopper Setup\n# =============================================================================\n\nimport clr\nclr.AddReference('RhinoCommon')\nclr.AddReference('Grasshopper')\n\nimport Rhino.Geometry as rg\nimport Grasshopper\n\n# =============================================================================\n# Project Setup (for RhinoCommonFactory)\n# =============================================================================\n\nPROJECT_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator\"\nif PROJECT_PATH not in sys.path:\n    sys.path.insert(0, PROJECT_PATH)\n\nfrom src.timber_framing_generator.utils.geometry_factory import get_factory\n\n# =============================================================================\n# Component Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Baking Data Parser\"\nCOMPONENT_NICKNAME = \"BakeParser\"\nCOMPONENT_MESSAGE = \"v1.0\"\nCOMPONENT_CATEGORY = \"Timber Framing\"\nCOMPONENT_SUBCATEGORY = \"Revit\"\n\n# Input configuration: (Name, NickName, Description, Access)\n# IMPORTANT: NickName becomes the Python variable name in GHPython!\nINPUT_CONFIG = [\n    (\"Baking Data JSON\", \"baking_data_json\", \"JSON string from Revit Baker component\",\n     Grasshopper.Kernel.GH_ParamAccess.item),\n    (\"Filter Classification\", \"filter_classification\", \"Optional: 'column', 'beam', or empty for all\",\n     Grasshopper.Kernel.GH_ParamAccess.item),\n    (\"Run\", \"run\", \"Set to True to execute\",\n     Grasshopper.Kernel.GH_ParamAccess.item),\n]\n\n# Output configuration: (Name, NickName, Description)\n# IMPORTANT: NickName becomes the Python variable name in GHPython!\n# Note: Output[0] is reserved for 'out' - these start at index 1\nOUTPUT_CONFIG = [\n    (\"Wall IDs\", \"wall_ids\", \"Wall IDs (one per member)\"),\n    (\"Element IDs\", \"element_ids\", \"Element IDs\"),\n    (\"Element Types\", \"element_types\", \"Element types (stud, bottom_plate, etc.)\"),\n    (\"Classifications\", \"classifications\", \"Classifications (column or beam)\"),\n    (\"Profile Names\", \"profile_names\", \"Profile names\"),\n    (\"Revit Type Names\", \"revit_type_names\", \"Matched Revit type names\"),\n    (\"CSR Angles\", \"csr_angles\", \"Cross-Section Rotation angles (beams only)\"),\n    (\"Geometry Indices\", \"geometry_indices\", \"Indices into column_curves/beam_curves\"),\n    (\"Base Level IDs\", \"base_level_ids\", \"Base level IDs (from wall)\"),\n    (\"Top Level IDs\", \"top_level_ids\", \"Top level IDs (from wall)\"),\n    (\"Centerline Starts\", \"centerline_starts\", \"Centerline start points (Point3d)\"),\n    (\"Centerline Ends\", \"centerline_ends\", \"Centerline end points (Point3d)\"),\n    (\"Column Planes\", \"column_planes\", \"Orientation planes for columns (Plane)\"),\n    (\"Debug Info\", \"debug_info\", \"Processing summary\"),\n]\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\n\n    This function handles:\n    1. Setting component metadata (name, category, etc.)\n    2. Configuring input parameters\n    3. Configuring output parameters\n\n    Note: Output[0] is reserved for GH's internal 'out' - start from Output[1]\n    \"\"\"\n    # Component metadata\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs\n    inputs = ghenv.Component.Params.Input\n    for i, (name, nick, desc, access) in enumerate(INPUT_CONFIG):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    # Configure outputs (start from index 1, as 0 is reserved for 'out')\n    outputs = ghenv.Component.Params.Output\n    for i, (name, nick, desc) in enumerate(OUTPUT_CONFIG):\n        idx = i + 1  # Skip Output[0] which is 'out'\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n\n# Run setup on component load\nsetup_component()\n\n# =============================================================================\n# Main Execution\n# =============================================================================\n\n# Initialize all outputs as empty lists\nwall_ids = []\nelement_ids = []\nelement_types = []\nclassifications = []\nprofile_names = []\nrevit_type_names = []\ncsr_angles = []\ngeometry_indices = []\nbase_level_ids = []\ntop_level_ids = []\ncenterline_starts = []\ncenterline_ends = []\ncolumn_planes = []\ndebug_info = \"\"\n\nif run and baking_data_json:\n    try:\n        # Get RhinoCommon factory for plane creation\n        rc_factory = get_factory()\n\n        # Handle Grasshopper wrapping\n        json_input = baking_data_json\n        if isinstance(baking_data_json, (list, tuple)):\n            json_input = baking_data_json[0] if baking_data_json else \"\"\n\n        # Parse JSON\n        data = json.loads(json_input)\n\n        # Check for error in JSON\n        if \"error\" in data:\n            debug_info = f\"Error in baking_data_json: {data['error']}\"\n        else:\n            # Get filter classification (normalize to lowercase)\n            filter_class = None\n            if filter_classification:\n                if isinstance(filter_classification, (list, tuple)):\n                    filter_class = str(filter_classification[0]).lower() if filter_classification else None\n                else:\n                    filter_class = str(filter_classification).lower()\n                # Validate filter\n                if filter_class not in (\"column\", \"beam\"):\n                    filter_class = None\n\n            # Process walls and members\n            walls_data = data.get(\"walls\", {})\n            total_members = 0\n            filtered_members = 0\n\n            for wid, wall_data in walls_data.items():\n                # Get wall-level properties\n                wall_base_level = wall_data.get(\"base_level_id\")\n                wall_top_level = wall_data.get(\"top_level_id\")\n\n                # Process each member in this wall\n                for member in wall_data.get(\"members\", []):\n                    total_members += 1\n\n                    # Apply classification filter if specified\n                    member_class = member.get(\"classification\", \"\")\n                    if filter_class and member_class != filter_class:\n                        continue\n\n                    filtered_members += 1\n\n                    # Extract all member properties\n                    wall_ids.append(wid)\n                    element_ids.append(member.get(\"id\", \"\"))\n                    element_types.append(member.get(\"element_type\", \"\"))\n                    classifications.append(member_class)\n                    profile_names.append(member.get(\"profile_name\", \"\"))\n                    revit_type_names.append(member.get(\"revit_type_name\", \"\"))\n                    csr_angles.append(member.get(\"csr_angle\", 0.0))\n                    geometry_indices.append(member.get(\"geometry_index\", -1))\n\n                    # Wall-level properties (inherited per member)\n                    base_level_ids.append(wall_base_level)\n                    top_level_ids.append(wall_top_level)\n\n                    # Centerline points as Point3d\n                    start = member.get(\"centerline_start\", {})\n                    end = member.get(\"centerline_end\", {})\n                    centerline_starts.append(rg.Point3d(\n                        start.get(\"x\", 0.0),\n                        start.get(\"y\", 0.0),\n                        start.get(\"z\", 0.0)\n                    ))\n                    centerline_ends.append(rg.Point3d(\n                        end.get(\"x\", 0.0),\n                        end.get(\"y\", 0.0),\n                        end.get(\"z\", 0.0)\n                    ))\n\n                    # Column orientation planes (for updating Location after creation)\n                    # Only valid for columns; beams use CSR instead\n                    # CRITICAL: Use RhinoCommonFactory to create planes from correct assembly\n                    if member_class == \"column\":\n                        plane_origin = member.get(\"plane_origin\", {})\n                        plane_x_axis = member.get(\"plane_x_axis\", {})\n\n                        # Extract coordinates as Python floats\n                        ox = float(plane_origin.get(\"x\", 0.0))\n                        oy = float(plane_origin.get(\"y\", 0.0))\n                        oz = float(plane_origin.get(\"z\", 0.0))\n\n                        ax = float(plane_x_axis.get(\"x\", 1.0))\n                        ay = float(plane_x_axis.get(\"y\", 0.0))\n                        az = float(plane_x_axis.get(\"z\", 0.0))\n\n                        # Normalize x_axis\n                        mag = (ax*ax + ay*ay + az*az) ** 0.5\n                        if mag > 0:\n                            ax, ay, az = ax/mag, ay/mag, az/mag\n\n                        # Y-axis = Z × X (for vertical columns, Z = world Z)\n                        # Cross product: (0,0,1) × (ax,ay,az) = (-ay, ax, 0)\n                        yx, yy, yz = -ay, ax, 0.0\n                        y_mag = (yx*yx + yy*yy + yz*yz) ** 0.5\n                        if y_mag > 0:\n                            yx, yy, yz = yx/y_mag, yy/y_mag, yz/y_mag\n\n                        # Create plane using RhinoCommonFactory\n                        rc_plane = rc_factory.create_plane(\n                            (ox, oy, oz),  # origin\n                            (ax, ay, az),  # x_axis\n                            (yx, yy, yz)   # y_axis\n                        )\n                        column_planes.append(rc_plane)\n                    else:\n                        # Beams don't use planes - append None\n                        column_planes.append(None)\n\n            # Build debug summary\n            summary = data.get(\"summary\", {})\n            # Count valid column planes (not None)\n            valid_planes = sum(1 for p in column_planes if p is not None)\n            debug_lines = [\n                \"Baking Data Parser\",\n                \"=\" * 40,\n                f\"Material System: {summary.get('material_system', 'unknown')}\",\n                f\"Total Walls: {len(walls_data)}\",\n                f\"Total Members in JSON: {total_members}\",\n                f\"Filter: {filter_class if filter_class else 'None (all)'}\",\n                f\"Output Members: {filtered_members}\",\n                \"\",\n                \"Output Counts:\",\n                f\"  wall_ids: {len(wall_ids)}\",\n                f\"  element_ids: {len(element_ids)}\",\n                f\"  element_types: {len(element_types)}\",\n                f\"  classifications: {len(classifications)}\",\n                f\"  profile_names: {len(profile_names)}\",\n                f\"  revit_type_names: {len(revit_type_names)}\",\n                f\"  csr_angles: {len(csr_angles)}\",\n                f\"  geometry_indices: {len(geometry_indices)}\",\n                f\"  base_level_ids: {len(base_level_ids)}\",\n                f\"  top_level_ids: {len(top_level_ids)}\",\n                f\"  centerline_starts: {len(centerline_starts)}\",\n                f\"  centerline_ends: {len(centerline_ends)}\",\n                f\"  column_planes: {len(column_planes)} ({valid_planes} valid)\",\n            ]\n\n            # Show sample data\n            if filtered_members > 0:\n                debug_lines.append(\"\")\n                debug_lines.append(\"Sample (first 3 members):\")\n                for i in range(min(3, filtered_members)):\n                    debug_lines.append(f\"  [{i}] {element_types[i]} | {revit_type_names[i]} | CSR={csr_angles[i]}°\")\n\n            debug_info = \"\\n\".join(debug_lines)\n\n    except json.JSONDecodeError as e:\n        debug_info = f\"JSON Parse Error: {str(e)}\"\n    except Exception as e:\n        import traceback\n        debug_info = f\"ERROR: {str(e)}\\n{traceback.format_exc()}\"\n\nelif not run:\n    debug_info = \"Set 'run' to True to execute\"\nelif not baking_data_json:\n    debug_info = \"No baking_data_json input provided\"\n\n# Print debug_info so it appears in the 'out' output\nprint(debug_info)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}