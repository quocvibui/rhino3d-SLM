{
  "source_url": "https://github.com/mcneel/developer.rhino3d.com/blob/6e9b91820175abba93f399fbd04f6459343091cf/script/convert.py",
  "repo": "mcneel/developer.rhino3d.com",
  "repo_stars": 88,
  "repo_description": "The developer.rhino3d.com website contents",
  "license": "unknown",
  "filepath": "script/convert.py",
  "instruction": "convert - dan@mcneel.com This python script converts the old Jekyll developer.rhino3d.com site to the Hugo static site engine. The Jekyll version of developer.rhino3d.com used git branches to determine which version of the site would be built and deployed.  The Hugo version generated by this script dispenses with version-specific branches and collapses everything in to the main branch. This script can be run progressively on the old 6, 7, and master branches (5 was ignored because the differences were somewhat significant) to generate the new site. After final conversion, this script is of limited value.",
  "code": "# convert - dan@mcneel.com\n# This python script converts the old Jekyll developer.rhino3d.com site to the Hugo static site engine.\n# The Jekyll version of developer.rhino3d.com used git branches to determine which version of the site\n# would be built and deployed.  The Hugo version generated by this script dispenses with version-specific\n# branches and collapses everything in to the main branch. This script can be run progressively on the\n# old 6, 7, and master branches (5 was ignored because the differences were somewhat significant) to generate\n# the new site. After final conversion, this script is of limited value.\n\nimport subprocess\nfrom subprocess import Popen, PIPE\nimport sys\nimport os\nfrom os.path import expanduser\nimport re\nfrom typing import DefaultDict, Dict\nimport toml\nimport os, tempfile\nimport shutil\nfrom shutil import copyfile\nimport json\n\n# general globals\ndebugging = True #TODO: Change this to False for the final run\nbaseURL = \"https://developer.rhino3d.com\"\nold_root = os.path.abspath(os.path.join(expanduser(\"~\"), \"dev\", \"mcneel\", \"developer.rhino3d.com-archive\"))\nold_content_authors_root_path = os.path.abspath(os.path.join(old_root, \"_authors\"))\nold_content_guides_root_path = os.path.abspath(os.path.join(old_root, \"_guide_topics\"))\nold_content_samples_root_path = os.path.abspath(os.path.join(old_root, \"_samples\"))\nold_images_root_path = os.path.abspath(os.path.join(old_root, \"images\"))\nold_content_videos_page_path = os.path.abspath(os.path.join(old_root, \"videos.md\"))\nold_content_api_page_path = os.path.abspath(os.path.join(old_root, \"api.md\"))\nold_files_root_path = os.path.abspath(os.path.join(old_root, \"files\"))\n\nnew_root = os.path.abspath(os.path.join(expanduser(\"~\"), \"dev\", \"mcneel\", \"developer.rhino3d.com\"))\nnew_content_root_path = os.path.abspath(os.path.join(new_root, \"content\", \"en\"))\nnew_content_guides_root_path = os.path.abspath(os.path.join(new_content_root_path, \"guides\"))\nnew_content_samples_root_path = os.path.abspath(os.path.join(new_content_root_path, \"samples\"))\nnew_content_data_path = os.path.abspath(os.path.join(new_root, \"data\"))\nnew_images_root_path = os.path.abspath(os.path.join(new_root, \"static\", \"images\"))\nnew_files_root_path = os.path.abspath(os.path.join(new_root, \"static\", \"files\"))\n\n# the list we need to populate\nold_content_authors_paths = []\nold_content_guides_paths = []\nold_content_samples_paths = []\n\n# this list needs to be populated manually and iteratively as we port 6, 7, master\n# paths should be relative to the old root, like this: _posts/2015-06-04-welcome-to-jekyll.markdown\nold_exclude_files = [\n    \"_posts/2015-06-04-welcome-to-jekyll.markdown\",\n    \"_authors/dan_belcher.md\"\n]\n\n# Frontmatter fields conversion ----------------------------------------------------------------------------------------\n\nfrontmatter_key_mapping = {\n    \"title\": \"title\",\n    \"description\": \"description\",\n    \"authors\": \"authors\",\n    \"categories\": \"categories\",\n    \"sdk\": \"sdk\",\n    \"languages\": \"languages\",\n    \"keywords\": \"keywords\",\n    \"date\": \"date\",\n    \"layout\": \"type\",\n    \"order\": \"weight\",\n    \"TODO\": \"TODO\",\n    \"origin\": \"origin\",\n    \"platforms\": \"platforms\",\n    \"category_page\": \"category_page\"\n}\n\nyaml_keys_to_ignore = [\"author_contacts\", \"redirect_from\", \"permalink\"]\n\n# Authors conversion ---------------------------------------------------------------------------------------------------\n\n# key = developer.rhino3d.com key\n# value = rhino3d.com-theme key\nauthors_mapping = {\n    \"aj\": \"aj\",\n    \"alain_cormier\": \"alain\",\n    \"andrew_le_bihan\": \"andy\",\n    \"andy_payne\": \"andy.payne\",\n    \"arthur_van_der_harten\": \"arthur-van-der-harten\",\n    \"brian_gillespie\": \"brian\",\n    \"brian\": \"brian\",\n    \"dale_fugier\": \"dale\",\n    \"dale_lear\": \"dalelear\",\n    \"dan_belcher\": \"dan\",\n    \"dan_rigdon_bel\": \"dan\",\n    \"david_leon\": \"david.leon\",\n    \"david_rutten\": \"david\",\n    \"callum_sykes\": \"callum\",\n    \"giulio_piacentino\": \"giulio\",\n    \"jess_maertterer\": \"jess-maertterer\",\n    \"john_croudy\": \"john.croudy\",\n    \"john_morse\": \"johnm\",\n    \"luis_fraguada\": \"luis\",\n    \"nathan_letwory\": \"nathan\",\n    \"pascal_golay\": \"pascal\",\n    \"rajaa_issa\": \"rajaa\",\n    \"scott_davidson\": \"scottd\",\n    \"skylar_tibbits\": \"skylar-tibbits\",\n    \"steve_baer\": \"steve\",\n    \"steven_janssen\": \"steven-janssen\",\n    \"stylianos_dritsas\": \"stylianos-dritsas\",\n    \"will_pearson\": \"will\"\n}\n\n# Layout conversion ----------------------------------------------------------------------------------------------------\n# The Jekyll site has 10 layout types. Jekyll makes no distinction between a \"node\" page and a \"leaf\" page, as Hugo does\n# so we can map some Jekyll values like \"guide-homepage\" to the same type in Hugo, because Hugo can distinguish which\n# layout to apply based upon the page's position and name (_index for nodes; index for leaves). In addition, since - in\n# Hugo - we toggle the table-of-contents using a frontmatter value (toc), we can map those Jekyll layouts to the same \n# type in Hugo and toggle the toc during conversion.\n\n# NOTE: At the moment, we are using layouts in the site/layouts folder (rather than the theme), but these layouts will\n# likely be moved into the rhino3d.com-theme when possible/feasible.\n\n# key = Jekyll developer.rhino3d.com key\n# value = Hugo developer.rhino3d.com value\nlayout_mapping = {\n    \"authors-page\": \"authors\",\n    \"admin\": \"admin\",\n    \"fullwidth-page\": \"guides\",\n    \"toc-page\": \"guides\",\n    \"toc-guide-page\": \"guides\",\n    \"guide-homepage\": \"guides\",\n    \"bootstrap\": \"guides\",\n    \"code-sample-cpp\": \"samples/cpp\",\n    \"code-sample-rhinocommon\": \"samples/rhinocommon\",\n    \"code-sample-python\": \"samples/python\",\n    \"code-sample-rhinoscript\": \"samples/rhinoscript\",\n}\n\n# Utility functions ----------------------------------------------------------------------------------------------------\n\n# colors for terminal reporting\nclass bcolors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n\n\ndef print_warning_message(warning_message):\n    warning_prefix = \" warning: \"\n    print(bcolors.BOLD + bcolors.FAIL + warning_prefix.upper() + bcolors.ENDC + bcolors.FAIL + warning_message + bcolors.ENDC)\n\n\ndef print_error_message(error_message):\n    error_prefix = \" error: \"\n    print(bcolors.BOLD + bcolors.FAIL + error_prefix.upper() + bcolors.ENDC + bcolors.FAIL + error_message + bcolors.ENDC)\n\n\ndef print_ok_message(ok_message):\n    ok_prefix = \" ok: \"\n    print(bcolors.BOLD + bcolors.OKBLUE + ok_prefix.upper() + bcolors.ENDC + bcolors.OKBLUE + ok_message + bcolors.ENDC)\n\n\ndef copy_folder_tree_without_files(src, dst):\n    src = os.path.abspath(src)\n\n    src_prefix = len(src) + len(os.path.sep)\n\n    if not os.path.exists(dst):\n        os.makedirs(dst)\n     \n    for root, folders, files in os.walk(src):\n        for dirname in folders:\n\n            folder_path = os.path.join(dst, root[src_prefix:], dirname)\n            \n            if not os.path.exists(folder_path):\n                os.mkdir(folder_path)\n\n\ndef get_markdown_files_list(path_to_crawl):\n    path_list = []\n    # Find all the markdown files in the old guides...\n    for root, dirs, files in os.walk(path_to_crawl):\n        for file in files:\n            if file.endswith(\".md\"):\n                path_to_old_file = os.path.abspath(os.path.join(root, file))\n                path_list.append(path_to_old_file)\n\n    # Remove exclusions (if any)...\n    for file in old_exclude_files:\n        exclude_path = os.path.abspath(os.path.join(old_root, file))\n        if exclude_path in path_list:\n            path_list.remove(exclude_path)\n    \n    return path_list\n\n\n# If we move or change the location of a page while porting the site, we need to keep a list\ndef log_redirect_url(fromURL, toURL):\n    if fromURL != toURL:\n        global baseURL\n        script_folder = os.path.dirname(os.path.abspath(__file__))\n        redirect_log_path = os.path.abspath(os.path.join(script_folder, \"redirect_log.json\"))\n        redirectURL = \"[\\\"\" + baseURL + fromURL + \"\\\", \" + \"\\\"\" + baseURL + toURL + \"\\\"],\\n\"\n        if os.path.exists(redirect_log_path):\n            redirect_log_file = open(redirect_log_path, \"r\")\n            existing_redirects = redirect_log_file.read()\n            redirect_log_file.close()\n            if not redirectURL in existing_redirects:\n                redirect_log_file = open(redirect_log_path, \"a\")\n                redirect_log_file.write(redirectURL)\n                redirect_log_file.close()\n        else:\n            redirect_log_file = open(redirect_log_path, \"a\")\n            redirect_log_file.write(redirectURL)\n            redirect_log_file.close()\n\n\n# YAML to TOML frontmatter conversion ----------------------------------------------------------------------------------\n\n# The python frontmatter library dumps an extra comma at the end of each list entry, so remove it\ndef strip_extra_comma(toml_frontmatter_old):\n    toml_frontmatter_new = toml_frontmatter_old.replace('\\\",]', '\\\" ]')\n    return toml_frontmatter_new\n\n\ndef remove_toml_separators(toml_frontmatter_old):\n    toml_without_separators = toml_frontmatter_old\n    if toml_without_separators.startswith('+++\\n'):\n        toml_without_separators = toml_frontmatter_old.split('+++\\n')[1].strip()\n    if toml_without_separators.endswith('\\n+++\\n'):\n        toml_without_separators = toml.frotnmatter_old.split('\\n+++')[0].strip()\n    \n    return toml_without_separators\n\n\ndef add_toml_separators(toml_frontmatter_old):\n    toml_with_separators = toml_frontmatter_old\n    if not toml_with_separators.startswith('+++\\n'):\n        toml_with_separators = '+++\\n' + toml_with_separators\n    if not toml_with_separators.endswith('\\n+++\\n'):\n        toml_with_separators = toml_with_separators + '\\n+++\\n'\n    \n    return toml_with_separators\n\n\n# This is where we replace old key titles with new key titles (not value content)\n# We also keep track of the mappings between the yaml keys and the toml keys to make sure some mapping has been\n# properly established.  Some keys get ignored on purpose.\ndef rename_frontmatter_keys(toml_frontmatter_old):\n    toml_without_separators = remove_toml_separators(toml_frontmatter_old)\n    toml_dictionary = {}\n    toml_dictionary = toml.loads(toml_without_separators)\n\n    # audit: record each of the old frontmatter keys in the mapping dictionary to make sure we're not missing any\n    global frontmatter_key_mapping\n    global yaml_keys_to_ignore\n    for key in toml_dictionary:\n        if not key in yaml_keys_to_ignore:\n            if not key in frontmatter_key_mapping:\n                frontmatter_key_mapping[key] = \"[missing]\"\n\n    # title (string) -> title (string)\n    # description (string) -> description (string)\n    # authors [string] -> authors [string]\n    # categories [string] -> categories [string]\n    # sdk [string] -> sdk [string]\n    # languages [string] -> languages [string]\n    # keywords [string] -> keywords [string] (not yet used on rhino3d.com-theme sites)\n\n    # date (date in frontmatter is not used, but there is a last-modified) - but we'll set that later\n\n    # layout -> type\n    if \"layout\" in toml_dictionary:\n        toml_dictionary[\"type\"] = toml_dictionary.pop(\"layout\")\n\n    # order -> weight (int)\n    if \"order\" in toml_dictionary:\n        toml_dictionary[\"weight\"] = toml_dictionary.pop(\"order\")\n    \n    # [admin]\n    # todo (string) -> todo (string)\n    # origin (string) -> origin (string)\n    \n    # move todo and origin into the [admin] namespace (dict) and add some missing keys for picky sisters and state\n    toml_dictionary[\"admin\"] = {}\n    if \"TODO\" in toml_dictionary or \"origin\" in toml_dictionary:\n        if \"TODO\" in toml_dictionary:\n            toml_dictionary[\"admin\"][\"TODO\"] = toml_dictionary[\"TODO\"]\n            toml_dictionary.pop('TODO', None)\n        else:\n            toml_dictionary[\"admin\"][\"TODO\"] = \"\"\n        if \"origin\" in toml_dictionary:\n            if toml_dictionary[\"origin\"] == \"unset\" or toml_dictionary[\"origin\"] == \" \":\n                toml_dictionary[\"admin\"][\"origin\"] = \"\"\n            else:\n                toml_dictionary[\"admin\"][\"origin\"] = toml_dictionary[\"origin\"]\n            toml_dictionary.pop('origin', None)\n        else:\n            toml_dictionary[\"admin\"][\"origin\"] = \"\"\n    toml_dictionary[\"admin\"][\"picky_sisters\"] = \"\"\n    toml_dictionary[\"admin\"][\"state\"] = \"\"\n    \n    # [included_in]\n    # platforms [string] -> platforms [string]\n    # move platforms into [included_in] namespace (dict) and add the missing key \"since\"\n    toml_dictionary[\"included_in\"] = {}\n    if \"platforms\" in toml_dictionary:\n        toml_dictionary[\"included_in\"][\"platforms\"] = toml_dictionary[\"platforms\"]\n        toml_dictionary.pop('platforms', None)\n    else:\n        toml_dictionary[\"included_in\"][\"platforms\"] = []\n    since = 0\n    toml_dictionary[\"included_in\"][\"since\"] = since\n    \n    # [page_options] - this maps pages that have a toc style layout (in jekyll) to those that have toc and bylines set\n    if toml_dictionary[\"type\"]:\n        if toml_dictionary[\"type\"].startswith('toc-'):\n            toml_dictionary[\"page_options\"] = {}\n            byline = False\n            toc = False\n            if toml_dictionary[\"type\"] == \"toc-guide-page\":\n                byline = True\n                toc = True\n            else:\n                toc = True\n            toml_dictionary[\"page_options\"][\"byline\"] = byline\n            toml_dictionary[\"page_options\"][\"toc\"] = toc\n            if toc:\n                toml_dictionary[\"page_options\"][\"toc_type\"] = \"single\"\n\n    # Remove ignored yaml keys (don't port them across to the toml)\n    toml_dictionary_trimmed = {}\n    for key, value in toml_dictionary.items():\n        if not key in yaml_keys_to_ignore:\n            toml_dictionary_trimmed[key] = value\n    toml_dictionary = toml_dictionary_trimmed\n\n    # Finish up...\n    toml_frontmatter_new = toml.dumps(toml_dictionary)\n    toml_frontmatter_new = add_toml_separators(toml_frontmatter_new)\n    toml_frontmatter_new = strip_extra_comma(toml_frontmatter_new)\n    \n    return toml_frontmatter_new\n\n\n# This is where we replace old values with new values\ndef rename_frontmatter_values(toml_frontmatter_old):\n    toml_without_separators = remove_toml_separators(toml_frontmatter_old)\n\n    toml_dictionary = {}\n    toml_dictionary = toml.loads(toml_without_separators)\n\n    # Authors\n    if \"authors\" in toml_dictionary:\n        if not toml_dictionary[\"authors\"] == \"unset\" and not toml_dictionary[\"authors\"] == '':\n            for key, value in toml_dictionary.items():\n                if key == \"authors\":\n                    new_authors = []\n                    for author in toml_dictionary[\"authors\"]:\n                        new_authors.append(authors_mapping[author])\n                    toml_dictionary[\"authors\"] = new_authors\n                else:\n                    break\n\n    # Layouts/Types\n    if \"type\" in toml_dictionary:\n        if not toml_dictionary[\"type\"] == \"unset\" and not toml_dictionary[\"type\"] == '':\n            old_type = toml_dictionary[\"type\"]\n            new_type = layout_mapping[old_type]\n            toml_dictionary[\"type\"] = new_type\n            # special case homepage\n            if toml_dictionary[\"title\"] == \"Rhino and Grasshopper Developer Documentation\":\n                toml_dictionary[\"type\"] = \"home\"\n\n    toml_frontmatter_new = toml.dumps(toml_dictionary)\n    toml_frontmatter_new = add_toml_separators(toml_frontmatter_new)\n    toml_frontmatter_new = strip_extra_comma(toml_frontmatter_new)\n\n    return toml_frontmatter_new\n\n\ndef add_override_last_modified(toml_frontmatter_old, override_last_modified):\n    toml_without_separators = remove_toml_separators(toml_frontmatter_old)\n\n    toml_dictionary = {}\n    toml_dictionary = toml.loads(toml_without_separators)\n\n    toml_dictionary[\"override_last_modified\"] = override_last_modified\n\n    toml_frontmatter_new = toml.dumps(toml_dictionary)\n    toml_frontmatter_new = add_toml_separators(toml_frontmatter_new)\n    toml_frontmatter_new = strip_extra_comma(toml_frontmatter_new)\n\n    return toml_frontmatter_new\n    \n\ndef convert_frontmatter(old_frontmatter, override_last_modified):\n    #split by newlines\n    yaml_items = old_frontmatter.split('\\n')\n\n    toml_items = []\n    for item in yaml_items:\n        should_append_item = True\n        # delimiters\n        if item.startswith('---'):\n            item = re.sub('---', '+++', item)\n        else:\n            # title: string (standard key/value string-to-string)\n            if not '[' in item:\n                yaml_value = ''\n                if item:\n                    yaml_value = item.split(\":\", 1)[1].strip()\n\n                if yaml_value.isnumeric():\n                    item = re.sub(r'([^:]*):\\s*([^\\[]*)', r'\\1 = \\2', item)\n                else:\n                    key_title = item.split(':', 1)[0]\n\n                    if not key_title: # final line\n                        item = \"\"\n                    else:\n                        item_split = item.split(':', 1)\n                        if len(item_split) == 1:\n                            should_append_item = False\n                        elif len(item_split) == 2:\n                            formatted_value = item_split[1].strip()\n                            if formatted_value.startswith(\"'\") or formatted_value.startswith(\"\\\"\"):\n                                formatted_value = formatted_value[1:]\n                            if formatted_value.endswith(\"'\") or formatted_value.endswith(\"\\\"\"):\n                                formatted_value = formatted_value[:-1]\n                            \n                            if formatted_value:\n                                if formatted_value != \"# empty\":\n                                    item = key_title + \" = \" + \"\\\"\" + formatted_value + \"\\\"\"\n                                else:\n                                    should_append_item = False\n                            else:\n                                should_append_item = False\n\n                        else:\n                            print_error_message(\"bad formatting in original yaml entry.\")\n                            sys.exit(1)\n\n            else:\n                # lists\n                key_title = item.split(':', 1)[0]\n\n                old_list_values = item.split('[')[1].split(']')[0].split(\",\")\n                if not old_list_values[0]:\n                    item = key_title + ' = []'\n                else:\n                    new_list_values = []\n                    for value in old_list_values:\n                        value = value.replace('\\'', '\\\"').strip()\n                        if value != '\"':\n                            new_list_values.append(value)\n\n                    # Handle mal-formed yaml values\n                    new_list_values_sanitized = []\n                    for value in new_list_values:\n                        if not value.startswith('\"'):\n                            value = '\"' + value\n                        if not value.endswith('\"'):\n                            value = value + '\"'\n                        new_list_values_sanitized.append(value)\n                        \n                    new_list_values_string = ', '.join(new_list_values_sanitized)\n                    if new_list_values_string.endswith(','):\n                        new_list_values_string = new_list_values_string[:-1]\n\n                    item = key_title + ' = [ ' + new_list_values_string + ' ]'\n        \n        if should_append_item:\n            toml_items.append(item)\n    \n    # sort alphabetically...\n    sorted_items = toml_items[1:-2]\n    sorted_items.sort()\n    sorted_toml_items = []\n    sorted_toml_items.append(toml_items[0])\n    sorted_toml_items = sorted_toml_items + sorted_items + toml_items[-2:]\n    \n    # flatten it all back into a single string\n    new_frontmatter = \"\\n\".join(sorted_toml_items)\n\n    # Churn through the toml frontmatter, renaming first the field titles, then the contents, if necessary...\n    new_frontmatter = rename_frontmatter_keys(new_frontmatter)\n    new_frontmatter = rename_frontmatter_values(new_frontmatter)\n\n    # Add the override_last_modified if set\n    if override_last_modified:\n        new_frontmatter = add_override_last_modified(new_frontmatter, override_last_modified)\n\n    return new_frontmatter\n\n\n# the hugo yaml toTOML parser is more robust, but slower and it does not do linting along the way. This should be used\n# for comparison purposes with our own, customer parser above, as well as to highlight potential bugs with our\n# yaml-to-toml converter above\ndef hugo_convert_frontmatter(old_frontmatter):\n    new_frontmatter = ''\n\n    # Write the old frontmatter to a temp folder on disk\n    temp_root = os.path.abspath(tempfile.gettempdir())\n    temp_dummy_hugo_root = os.path.abspath(os.path.join(temp_root, \"temp_dummy_hugo_root\"))\n    temp_dummy_hugo_content = os.path.abspath(os.path.join(temp_dummy_hugo_root, \"content\"))\n\n    if not os.path.exists(temp_dummy_hugo_root):\n        os.makedirs(temp_dummy_hugo_root)\n\n    # Copy hugo over\n    script_folder = os.path.dirname(os.path.abspath(__file__))\n    path_to_hugo_orig = os.path.abspath(os.path.join(script_folder, \"..\", \"hugo\"))\n    path_to_hugo_new = os.path.abspath(os.path.join(temp_dummy_hugo_root, \"hugo\"))\n    if not os.path.exists(path_to_hugo_new):\n        if not os.path.exists(path_to_hugo_orig):\n            print_error_message(\"hugo not found, please make sure it's in the root folder before running...it's needed to convert the yaml to toml\")\n            sys.exit(1)\n        copyfile(path_to_hugo_orig, path_to_hugo_new)\n\n    # Create the dummy config file to appease hugo\n    temp_dummy_config_path = os.path.abspath(os.path.join(temp_dummy_hugo_root, \"config\", \"_default\"))\n    if not os.path.exists(temp_dummy_config_path):\n        os.makedirs(temp_dummy_config_path)\n        temp_dummy_config_file_path = os.path.abspath(os.path.join(temp_dummy_config_path, \"config.toml\"))\n        dummy_config_file = open(temp_dummy_config_file_path, \"w\")\n        dummy_config_file.write(\"\")\n        dummy_config_file.close()\n\n    # Create a spot for the input - deleting the old if it existss\n    if os.path.exists(temp_dummy_hugo_content):\n        shutil.rmtree(temp_dummy_hugo_content)\n    \n    os.makedirs(temp_dummy_hugo_content)\n\n    # Delete old output if it exists and make a spot for the new\n    temp_dummy_toml_output_root = os.path.abspath(os.path.join(temp_dummy_hugo_root, \"toTOML\"))\n    if os.path.exists(temp_dummy_toml_output_root):\n        shutil.rmtree(temp_dummy_toml_output_root)\n    os.makedirs(temp_dummy_toml_output_root)\n    \n    temp_input_file_path = os.path.abspath(os.path.join(temp_dummy_hugo_content, \"temp_frontmatter.md\"))\n    temp_input_file = open(temp_input_file_path, \"w\")\n    temp_input_file.write(old_frontmatter)\n    temp_input_file.close()\n\n    os.chdir(temp_dummy_hugo_root)\n    # hugo convert toTOML --verbose --log -s . -o toTOML\n    hugo_totoml_process = subprocess.Popen(['hugo', 'convert', 'toTOML', '--verbose', '--log', '-s', '.', '-o', 'toTOML'], stdin=PIPE, stdout=PIPE, stderr=PIPE)\n    hugo_totoml, err = hugo_totoml_process.communicate()\n\n    temp_output_file_path = os.path.abspath(os.path.join(temp_dummy_toml_output_root, \"content\", \"temp_frontmatter.md\"))\n    temp_output_file = open(temp_output_file_path, \"r\")\n\n    new_frontmatter = temp_output_file.read()\n    temp_output_file.close()\n\n    # Churn through the toml frontmatter, renaming first the field titles, then the contents, if necessary...\n    new_frontmatter = rename_frontmatter_keys(new_frontmatter)\n    new_frontmatter = rename_frontmatter_values(new_frontmatter)\n\n    return new_frontmatter\n\n\n# Markdown content conversion handlers ---------------------------------------------------------------------------------\ndef convert_markdown_content(old_content):\n    new_content = \"\"\n\n    # -----------------------------------------------------------------------------------------------------------\n    # Useful VSCode search: \\x7B{2}[^\\x3C].*?[^\\x3E]\\x7D{2} in *.md  ...this is {{ stuff }} but not {{< stuff >}}\n    # REGEX template: new_content = re.sub(r'pattern', r'replace', new_content, flags=re.MULTILINE | re.DOTALL)\n    # -----------------------------------------------------------------------------------------------------------\n\n    # BaseURL links - {{ site.baseurl }}\n    new_content = re.sub(r'\\x7B{2}(\\s{0,4})site.baseurl(\\s{0,4})\\x7D{2}', r'', old_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x7B{2}(\\s{0,4})site.basurl(\\s{0,4})\\x7D{2}', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Branch specific links - {{ site.git_branch ...}}\n    new_content = re.sub(r'developer-rhino3d-com/blob/\\x7B{2}(\\s{0,4})site.git_branch(\\s{0,4})\\|(\\s{0,4})default:(.{0,9})(\\s{0,4})\\x7D{2}', r'developer-rhino3d-com/blob/main', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'rhino-developer-samples/blob/\\x7B{2}(\\s{0,4})site.git_branch(\\s{0,4})\\|(\\s{0,4})default:(.{0,9})(\\s{0,4})\\x7D{2}', r'rhino-developer-samples/blob/master', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Author links\n    for key, value in authors_mapping.items():\n        old_author_link = \"(/authors/\" + key + \")\"\n        new_author_link = \"(/authors/\" + value + \")\"\n        new_content = new_content.replace(old_author_link, new_author_link)\n\n    # new_content = re.sub(r'(/authors/)(.{0,30})_(.{0,30})', r'\\1\\2-\\3', new_content) # <--old regex\n    new_content = re.sub(r'Dan Belcher', r'Dan Rigdon-Bel', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'dan-belcher', r'dan', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # css formatting suffixes: https://digitaldrummerj.me/styling-jekyll-markdown/\n    new_content = re.sub(r'\\x7B: rules=\"groups\"\\x7D', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x7C\\x3D{5}\\s\\x7C\\s\\x7B\\x3A.*?\\x7D', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # homepage special cases\n    new_content = re.sub(r'<div align=\"center\">.{0,10}(<p>Welcome to the Rhino . version of this site).+?(<p>Rhino developer tools are royalty free and include support.</p>.{0,10}</div>)', r'{{< center >}}\\n\\nRhino developer tools are royalty free and include support.\\n\\n{{< /center >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Horizontal rule formatters (---)\n    new_content = re.sub(r'\\n---\\n\\n', r'\\n', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Header level inconsistencies\n    new_content = re.sub(r'#### Related Topics', r'## Related Topics', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # youtube embeds\n    new_content = re.sub(r'{%\\s{0,2}include\\s{0,2}youtube_player.html\\s{0,2}id=.(.{0,11}).\\s{0,2}%}', r'{{< youtube \\1 >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'<div\\s{0,2}class=\"embed-responsive\\s{0,2}embed-responsive-16by9\">\\s{0,6}<iframe\\s}{0,2}.{0,250}\\s{0,2}src=.https://www.youtube.com/embed/(.{0,11}).\\s{0,2}.{0,250}</iframe>\\s{0,6}</div>', r'{{< youtube \\1 >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # vimeo includes\n    new_content = re.sub(r'<div\\s{0,2}class=\"embed-responsive\\s{0,2}embed-responsive-16by9\">\\s{0,6}<iframe\\s}{0,2}class=.embed-responsive-item.\\s{0,2}src=.https://player.vimeo.com/video/(.{0,9}).></iframe>\\s{0,6}</div>', r'{{< vimeo \\1 >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x7B\\x25\\s{0,1}include\\svimeo_player.html\\sid\\x3D\\x22(.*?)\\x22\\s{0,1}\\x25\\x7D', r'{{< vimeo \\1 >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # download links\n    new_content = re.sub(r'<a .*?href=\\\"([^\\\"]*)\\\"><span\\s{0,2}class=\"glyphicon glyphicon-download\"></span>(.{0,500})</a>', r'[{{< awesome \"fas fa-download\">}} \\2](\\1)', new_content) # this one really needs to not be multiline or it messes up some of the top-level pages\n\n    # multi-column layouts\n    # <!--column--> style layouts\n    regexp = re.compile(r'<!--column-->')\n    if regexp.search(new_content):\n        new_content = '{{< row >}}\\n{{< column >}}\\n' + new_content + '\\n{{< /column >}}\\n{{< /row >}}\\n'\n        new_content = re.sub(r'<!--column-->', r'{{< /column >}}\\n{{< column >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    \n    # multi-column layouts using html: \n    # columns first because they are inner\n    new_content = re.sub(r'(?s)(<div class=\"col-md-7 col-sm-12 col-sm-12\" markdown=\"1\">)(.*?)(\\n</div>)', r'{{< column >}}\\2\\n{{< /column >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(?s)(<div\\s{0,2}class=\"col-md-4\"\\s{0,2}markdown=\"1\">)(.*?)(\\n</div>)', r'{{< column >}}\\2\\n{{< /column >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    # rows next because they are outer\n    new_content = re.sub(r'(?s)(<div class=\"row-fluid\">)(.*?)(\\n</div>)', r'{{< row >}}\\2\\n{{< /row >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Liquid templating that iterates a list - usually a ul -  will be surrounded by: <div class=\"trigger\">  ... </div>\n    # we use the following shortcode: {{< dev-topic-list \"guides\" \"RhinoCommon\" \"Rendering\" \"weight\" >}}\n    # A couple of the pages have hardcoded <li> items in them - esp the RhinoCommon Advanced one - account for these...\n    new_content = re.sub(r'(<div class=\"trigger\">\\n\\s{0,4}\\x7B% assign guides = site.guide_topics \\| sort:\"order\" %\\x7Dn\\s{0,4}<ul>\\n\\s{0,4}<li><a href=\"(.{0,30})\">)(.{0,30})</a></li>\\n\\s{0,4}<li><a href=\"(.{0,60})\">(.{0,50})</a></li>', r'- [\\3](\\2)\\n- [\\5](\\4)\\n\\n\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n    # The RhinoPython sample source doesn't contain a categories section, so we need to parse these two special-cases in this order to get the sample index correct\n    new_content = re.sub(r'<div class=\"trigger\".*?for.*?in samples[ %]+.*?sdk contains \\'RhinoCommon\\'.*?categories contains \\'(.*?)\\'.*?<\\/div>', r'{{< dev-topic-list \"samples\" \"RhinoCommon\" \"\\1\" \"weight\" >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'<div class=\"trigger\".*?for.*?in samples[ %]+.*?sdk contains \\'RhinoPython\\'.*?<\\/div>', r'{{< dev-topic-list \"samples\" \"RhinoPython\" \"Adding Objects\" \"weight\" >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    # ...then replace the rest with with the shortcode, the general case:\n    new_content = re.sub(r'<div class=\"trigger\".*?for.*?in (\\w+?)[ %]+.*?sdk contains \\'(.*?)\\'.*?categories contains \\'(.*?)\\'.*?<\\/div>', r'{{< dev-topic-list \"\\1\" \"\\2\" \"\\3\" \"weight\" >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    # Then handle the {% assign guides } cases in /guides/yak (which don't use the triggers)\n    new_content = re.sub(r'\\x7B\\x25\\sassign guides = site.guide_topics\\s\\x7C\\swhere:\\x22sdk\\x22,\\x22Yak\\x22\\s\\x7C\\swhere:\\x22categories\\x22,\\x22(.*?)\\x22\\s\\x7C\\ssort.*?\\x25\\x7D', r'{{< dev-topic-list \"guides\" \"Yak\" \"\\1\" \"weight\" >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x3Cul\\x3E\\s\\x7B\\x25\\sfor guide in guides \\x25\\x7D\\s\\s\\s\\x3Cli\\x3E\\x3Ca href=\\x22\\x7B{2} guide.url \\x7C prepend:\\ssite.baseurl \\x7D{2}\\x22\\x3E\\x7B{2} guide.title \\x7D{2}\\x3C/a\\x3E\\x3C/li\\x3E\\s\\x7B\\x25 endfor \\x25\\x7D.{0,150}\\x3C/ul\\x3E', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Remove hardcoded platform images\n    new_content = re.sub(r'\\s<img src=\"/images/.*?-logo-small.png\" alt=\".*?\" class=\"guide_icon\">', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Remove hardcoded anchor tags\n    new_content = re.sub(r'\\x7B:\\s{0,2}#.{0,20}\\s{0,2}\\x7D', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Code blocks (samples) with tabbed content\n    if (\"```cs\" in new_content) and (\"```vbnet\" in new_content) and (\"```python\" in new_content):\n        new_content = re.sub(r'(```cs\\s.+?```).+?{:\\s#cs\\s.tab-pane .fade .in .active\\s{0,1}}', r'<div class=\"codetab-content\" id=\"cs\">\\n\\n\\1\\n\\n</div>', new_content, flags=re.MULTILINE | re.DOTALL)\n        new_content = re.sub(r'(```vbnet\\s.+?```).+?{:\\s#vb .tab-pane .fade .in}', r'<div class=\"codetab-content\" id=\"vb\">\\n\\n\\1\\n\\n</div>', new_content, flags=re.MULTILINE | re.DOTALL)\n        new_content = re.sub(r'(```python\\s.+?```).+?{:\\s#py .tab-pane .fade .in}', r'<div class=\"codetab-content\" id=\"py\">\\n\\n\\1\\n\\n</div>', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Footnotes - from headers to sections\n    new_content = re.sub(r'#{1,3}\\sFootnotes:{0,1}', r'**Footnotes**', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Essential Mathematics Special cases\n    new_content = re.sub(r'# Essential Mathematics for Computational Design', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(..< column >..\\s*)(.*?.Essential Mathematics for Computational Design.*?..< /column >..).*?(\\!\\[(/images/math-logo.svg)\\]).*?</div>', r'\\1![\\4 alt >](\\4)\\n\\n\\2', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'<div class=.note..markdown=.1.>(.*?)</div>', r'{{< call-out note \"Note\" >}}\\n\\1\\n{{< /call-out >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Mathjax\n    new_content = re.sub(r'\\\\(\\$\\$)', r'\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\$\\$(.*?)\\$\\$', r'{{< mathjax >}}$$\\1$${{< /mathjax >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'..< mathjax >..(.._save_..)..< /mathjax >..', r'\\1', new_content, flags=re.MULTILINE | re.DOTALL) #special case of non-Mathjax $$ use\n\n    # Image alignment\n    new_content = re.sub(r'\\x21\\x5B(.{0,100})\\x5D\\x28(.{0,100})\\x29\\x7B\\x3A\\s\\x2Efloat-img-left\\swidth\\x3D\\x22(\\d{0,5})\\x22\\x7D', r'{{< image url=\"\\2\" alt=\"\\1\" class=\"float_left\" width=\"\\3\" >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x21\\x5B(.{0,100})\\x5D\\x28(.{0,100})\\x29\\x7B\\x3A\\s\\x2Efloat-img-right\\swidth\\x3D\\x22(\\d{0,5})\\x22\\x7D', r'{{< image url=\"\\2\" alt=\"\\1\" class=\"float_right\" width=\"\\3\" >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x21\\x5B(.{0,100})\\x5D\\x28(.{0,100})\\x29\\x7B\\x3A\\s{1,2}\\x2Efloat-img-right\\s{1,2}\\x7D', r'{{< image url=\"\\2\" alt=\"\\1\" class=\"float_right\" >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'&nbsp;\\x7B:\\s.clear-img\\x7D', r'{{< div class=\"clear_both\" />}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x7B:\\s.clear-img\\x7D', r'{{< div class=\"clear_both\" />}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x7B\\x3A\\s{0,2}style\\x3D\\x22clear\\x3Aboth\\x3B\\x22\\x7D', r'{{< div class=\"clear_both\" />}}', new_content, flags=re.MULTILINE | re.DOTALL)  #{:style=\"clear:both;\"}\n    new_content = re.sub(r'\\x21\\x5B(.{0,100})\\x5D\\x28(.{0,100})\\x29\\x7B\\x3A\\s\\x2Eimg-center\\s{1,2}width\\x3D\\x22(\\S{1,5})\\x22\\x7D', r'{{< image url=\"\\2\" alt=\"\\1\" class=\"image_center\" width=\"\\3\" >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x21\\x5B(.{0,100})\\x5D\\x28(.{0,100})\\x29\\x7B\\x3A\\s{1,2}\\x2Eimg-center\\s\\x7D', r'{{< image url=\"\\2\" alt=\"\\1\" class=\"image_center\" >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x3Cimg\\ssrc\\x3D\\x22(.{1,60})\\x22\\x3E\\x7B\\x3A\\s\\x2Eimg-center\\s{1,2}width\\x3D\\x22(\\S{0,5})\\x22\\x7D', r'{{< image url=\"\\1\" alt=\"\\1\" class=\"image_center\" width=\"\\2\" >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x21\\x5B(.{0,100})\\x5D\\x28(.{0,100})\\x29\\x7B\\x3A\\s{1,2}width\\x3D\\x22(\\S{1,5})\\x22\\x7D', r'{{< image url=\"\\2\" alt=\"\\1\" width=\"\\3\" >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x21\\x5B(.{0,100})\\x5D\\x28(.{0,100})\\x29\\x7B\\x3A\\s{1,2}\\x2Efloat-img-center\\swidth\\x3D\\x22(\\S{1,5})\\x22\\x7D', r'{{< image url=\"\\2\" alt=\"\\1\" width=\"\\3px\" >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x21\\x5B(.{0,100})\\x5D\\x28(.{0,100})\\x29\\x7B\\x3Astyle=\\x22float:\\sright;.*?\\x22\\x7D', r'{{< image url=\"\\2\" alt=\"\\1\" class=\"float_right\" >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Remove remaining redundant Titles\n    new_content = re.sub(r'#\\sAuthors.*?(Thanks to all who have)', r'\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'# Compute Guides', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'# Rhino.Python Primer 101  ', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'# RhinoScript Primer 101', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Fix heading levels\n    new_content = re.sub(r'# Dynamic Layout', r'## Dynamic Layout', new_content, flags=re.MULTILINE | re.DOTALL)\n    # The # Next Steps ones are hard to fix because they are at the start of a line so we should fix these after porting\n\n    # {: .multiline} - this is for tables of linenumber explanations\n    new_content = re.sub(r'\\x3Ctable\\x3E(.*?)\\x3C\\x2Ftable\\x3E\\s\\x7B\\x3A\\s{1,2}\\x2Emultiline\\s{0,1}\\x7D', r'<table class=\"multiline\">\\1</table>', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x3Ctable width\\x3D\\x22100%\\x22\\x3E(.*?)\\x3C\\x2Ftable\\x3E\\s\\x7B\\x3A\\s{1,2}\\x2Emultiline-middle\\s{0,1}\\x7D', r'<table class=\"multiline-middle\" width=\"100%\">\\1</table>', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # {:.language-cs}\n    new_content = re.sub(r'(\\x60)\\x7B\\x3A\\x2Elanguage-cs\\x7D\\s', r'\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(\\x60)\\x7B\\x3A\\x2Elanguage-cs\\x7D', r'\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # {: .line-numbers}\n    # First, remove a bad vb code-block that causes problems below\n    new_content = re.sub(r'(\\x60\\x60\\x60vb)\\s\\s', r'\\1\\n', new_content, flags=re.MULTILINE | re.DOTALL)\n    # Second, replace the {: .line-numbers } with {{< /div >}} closing shortcode to maintain length of overall string\n    new_content = re.sub(r'\\x7B\\x3A\\s{0,1}\\x2Eline-numbers\\s{0,1}\\x7D', r'{{< /div >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    if '{{< /div >}}' in new_content:\n        lines = new_content.split(\"\\n\")\n        ranges_list = []\n        for i in range(len(lines)):\n            if lines[i].startswith('```'):\n                if (len(lines[i+1]) > 0) and not ('{{< /div >}}' in lines[i+1]): # if it's the start of a code-block\n                    # look ahead to the closing code-block backticks\n                    for j in range(i+1, len(lines)):\n                        if lines[j].startswith('```') and lines[j].endswith('```'):\n                            # see if if the following line contains the line-numbers {{< /div >}} tag\n                            if '{{< /div >}}' in lines[j+1]:\n                                range_start = i\n                                range_end = j+1\n                                ranges_list.append(range(range_start, range_end))\n                            else:\n                                break # it's not a line-numbers code-block, just a regular one.\n        # now we have our ranges list of code-blocks with line-numbers\n        new_lines = []\n        for i in range(len(lines)):\n            is_start_of_range = False\n            # Check to see if the index is equal to any of the start ranges\n            for range_to_check in ranges_list:\n                if i == range_to_check[0]:\n                    is_start_of_range = True\n            \n            if is_start_of_range:\n                new_line = '{{< div class=\\\"line-numbers\\\" >}}' + lines[i]\n                new_lines.append(new_line)\n            else:\n                new_lines.append(lines[i])\n\n        # Flatten the string back into new_content\n        new_content = '\\n'.join(new_lines)\n    \n        # Finally split the top-level div back into two separate lines at the start of the code-block\n        new_content = re.sub(r'(\\x7B\\x7B\\x3C\\sdiv class=.line-numbers.\\s\\x3E\\x7D\\x7D)(\\x60\\x60\\x60)', r'\\1\\n\\2', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # {:class=“table table-bordered”} and re-align table\n    new_content = re.sub(r'\\x7B\\x3Aclass=.table\\stable-bordered.\\x7D', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(Procedure for deletion\\s\\x7C\\s\\x7C)(-*)\\x7C(-*)\\x7C', r'\\1:\\2|:\\3|', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # {: .multiline} removal\n    new_content = re.sub(r'\\x7B\\x3A\\s\\x2Emultiline\\x7D', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Weird edge case where tables were used inappropriately\n    new_content = re.sub(r'(\\x7C\\sCurve\\sPlane\\sIntersection\\s\\x7C).*?\\x7B\\x3A\\s\\x2Eguide_fullwidth\\x7D', r'* Curve Plane Intersection\\n* Project Curve\\n* Pull Curve\\n* Split with Brep\\n* Shatter\\n* Split with Breps\\n* Trim with Brep\\n* Trim with Breps\\n* Area\\n* Area Moments\\n* Volume\\n* Volume Moments\\n* Brep Closest Point\\n* Mesh Plane Intersection\\n* Brep Line Intersection\\n* Brep Brep Intersection\\n* Brep Plane Intersection\\n* Curve Curve Intersection\\n* Curve Curves Intersection\\n* Point in Brep\\n* Point in Breps\\n* Curve Self-Intersection \\n* Contour\\n* Dash Pattern\\n* Divide Curve\\n* Boundary Surface', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Remove obsolete documentation\n    new_content = re.sub(r'\\x23{3}\\sInline\\sAttributes.*?(\\x23{3}\\s)', r'\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x23{3}\\sBlock\\sAttributes.*?(\\x23{3}\\s)', r'\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x23{3}\\sHTML\\sElements.*?(\\x23{3}\\s)', r'\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Remove obsolete {:start=\"8\"} tags\n    new_content = re.sub(r'\\x7B\\x3Astart=\\x22\\d\\x22\\x7D', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # tab-pane code-block samples\n    # First, handle the <ul class=\"nav nav-pills\">\n    new_content = re.sub(r'\\x3Cul\\sclass=\\x22nav\\snav-pills\\x22\\x3E\\s*?\\x3Cli\\sclass=\\x22active\\x22\\x3E\\x3Ca\\shref=\\x22\\x23(.*?)\\x22\\sdata-toggle=\\x22pill\\x22\\x3E(.*?)\\x3C\\x2Fa\\x3E\\x3C\\x2Fli\\x3E\\s*?\\x3Cli\\x3E\\x3Ca\\shref=\\x22\\x23(.*?)\\x22\\sdata-toggle=\\x22pill\\x22\\x3E(.*?)\\x3C\\x2Fa\\x3E\\x3C\\x2Fli\\x3E\\s\\x3C\\x2Ful\\x3E', r'<div class=\"codetab\">\\n  <button class=\"tablinks\" onclick=\"openCodeTab(event, \\'\\1\\')\" id=\"defaultOpen\">\\2</button>\\n  <button class=\"tablinks\" onclick=\"openCodeTab(event, \\'\\3\\')\">\\4</button>\\n</div>', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r\"\\x28event,\\s\\x5C\\x27(.*?)\\x5C\\x27\\x29\", r\"(event, '\\1')\", new_content, flags=re.MULTILINE | re.DOTALL) # fix escaped single quotes\n    # Second, iterate through these new code-tabs and make the ids unique\n    lines = new_content.split(\"\\n\")\n    # Find all the lines with tablinks...\n    tablinks_list = []\n    for i in range(len(lines)):\n        if '<button class=\"tablinks' in lines[i]:\n            tablinks_list.append(i)\n    # ...go through and label each of the lines and add the counter\n    if len(tablinks_list) > 0:\n        if len(tablinks_list) % 2 == 0: # only process those with two code tabs (we may need to special-case three)\n            new_lines = []\n            counter = 0\n            for i in range(len(lines)):\n                if i in tablinks_list:\n                    l1 = lines[i]\n                    l2 = lines[i+1]\n                    if counter > 0:\n                        l1_new = re.sub(r'tablinks', r'tablinks' + str(counter), l1)\n                        l1_new = re.sub(r'defaultOpen', r'defaultOpen' + str(counter), l1_new)\n                        l2_new = re.sub(r'tablinks', r'tablinks' + str(counter), l2)\n                        l2_new = re.sub(r'defaultOpen', r'defaultOpen' + str(counter), l2_new)\n                    else:\n                        l1_new = l1\n                        l2_new = l2\n                    new_lines.append(l1_new)\n                    new_lines.append(l2_new)\n                    tablinks_list.remove(i+1)\n                    counter = counter + 1\n                else:\n                    if not '<button class=\"tablinks\"' in lines[i]:\n                        new_lines.append(lines[i])\n            new_content = '\\n'.join(new_lines)\n    # ...then we remove the {::options parse_block_html=\"true\" /}:\n    new_content = re.sub(r'\\x7B\\x3A{2}options\\sparse_block_html=\\x22true\\x22\\s\\x2F\\x7D\\s(\\x3Cdiv\\sclass=\\x22tab-content\\x22\\x3E)', r'\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x7B\\x3A{2}options\\sparse_block_html=\\x22true\\x22\\s\\x2F\\x7D\\s', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n    # The last major step is to find all the {: #cs1 .tab-pane .fade .in. active } and replace with surrounding divs...\n    # ...starting with the unnumbered codetab case with and without the final div\n    new_content = re.sub(r'(\\x3Cdiv class=\\x22tab-content\\x22\\x3E)\\s{1,3}(\\x60{3}\\w{0,8})(.*?)\\x60{3}\\s(\\x7B\\x3A\\s\\x23(\\D{1,10})\\s\\x2Etab-pane \\x2Efade \\x2Ein.*?\\x7D)\\s\\s(\\x60{3}\\w{0,8})(.*?)\\x60{3}\\s(\\x7B\\x3A\\s\\x23(\\D{1,10})\\s\\x2Etab-pane \\x2Efade \\x2Ein.*?\\x7D)\\s\\s(\\x3C\\x2Fdiv\\x3E)', r'\\1\\n<div class=\"codetab-content\" id=\"\\5\">\\n\\n\\2\\3\\n```\\n\\n</div>\\n\\n<div class=\"codetab-content\" id=\"\\9\">\\n\\n\\6\\7```\\n\\n\\10\\n\\10', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(\\x3Cdiv class=\\x22tab-content\\x22\\x3E)\\s{1,3}(\\x60{3}\\w{0,8})(.*?)\\x60{3}\\s(\\x7B\\x3A\\s\\x23(\\D{1,10})\\s\\x2Etab-pane \\x2Efade \\x2Ein.*?\\x7D)\\s\\s(\\x60{3}\\w{0,8})(.*?)\\x60{3}\\s(\\x7B\\x3A\\s\\x23(\\D{1,10})\\s\\x2Etab-pane \\x2Efade \\x2Ein.*?\\x7D)', r'\\1\\n<div class=\"codetab-content\" id=\"\\5\">\\n\\n\\2\\3\\n```\\n\\n</div>\\n\\n<div class=\"codetab-content\" id=\"\\9\">\\n\\n\\6\\7```\\n\\n</div>\\n/div>', new_content, flags=re.MULTILINE | re.DOTALL)\n    # ...and then numbered codetab cases with and without the final div\n    new_content = re.sub(r'(\\x3Cdiv class=\\x22tab-content\\x22\\x3E)\\s{1,3}(\\x60{3}\\w{0,8})(.*?)\\x60{3}\\s(\\x7B\\x3A\\s\\x23(\\D{1,10})(\\d{1,10})\\s\\x2Etab-pane \\x2Efade \\x2Ein.*?\\x7D)\\s\\s(\\x60{3}\\w{0,8})(.*?)\\x60{3}\\s(\\x7B\\x3A\\s\\x23(\\D{1,10})(\\d{1,10})\\s\\x2Etab-pane \\x2Efade \\x2Ein.*?\\x7D)\\s\\s(\\x3C\\x2Fdiv\\x3E)', r'\\1\\n<div class=\"codetab-content\\6\" id=\"\\5\\6\">\\n\\n\\2\\3\\n```\\n\\n</div>\\n\\n<div class=\"codetab-content\\11\" id=\"\\10\\11\">\\n\\n\\7\\8```\\n\\n\\12\\n\\12', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(\\x3Cdiv class=\\x22tab-content\\x22\\x3E)\\s{1,3}(\\x60{3}\\w{0,8})(.*?)\\x60{3}\\s(\\x7B\\x3A\\s\\x23(\\D{1,10})(\\d{1,10})\\s\\x2Etab-pane \\x2Efade \\x2Ein.*?\\x7D)\\s\\s(\\x60{3}\\w{0,8})(.*?)\\x60{3}\\s(\\x7B\\x3A\\s\\x23(\\D{1,10})(\\d{1,10})\\s\\x2Etab-pane \\x2Efade \\x2Ein.*?\\x7D)', r'\\1\\n<div class=\"codetab-content\\6\" id=\"\\5\\6\">\\n\\n\\2\\3\\n```\\n\\n</div>\\n\\n<div class=\"codetab-content\\11\" id=\"\\10\\11\">\\n\\n\\7\\8```\\n\\n</div>\\n</div>', new_content, flags=re.MULTILINE | re.DOTALL)\n    # and finally we're done with the tab-pane code-block samples\n\n    # Special case: http://localhost:1313/guides/general/essential-mathematics/ - ![/images/math-logo.svg alt >](/images/math-logo.svg)\n    new_content = re.sub(r'\\x21\\x5B\\x2Fimages\\x2Fmath-logo.svg\\salt\\s\\x3E\\x5D\\x28\\x2Fimages\\x2Fmath-logo.svg\\x29', r'{{< image url=\"/images/math-logo.svg\" alt=\"/images/math-logo.svg\" class=\"float_right\" >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    \n    # Remove extraneous formatting at bottom of tables: |=====\n    new_content = re.sub(r'\\x7C\\x3D{5}\\s\\x7C\\s\\s', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Special case header missing ## http://localhost:1313/guides/rhinopython/python-editing-scripts/\n    new_content = re.sub(r'(The Menu)\\s\\s(The menu provides access to all the RhinoPythonScript)', r'## \\1\\n\\n\\2', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Fix typos in closing code blocks - then a bunch of typos\n    new_content = re.sub(r'\\x60{4}\\s\\s\\x60random\\x60', r'```\\n\\n`random`', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x60{4}\\sKeep', r'```\\n\\nKeep', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(\\x23methods-of-file-objects\\x29\\s)\\x60{3}', r'\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(\\x60{3}\\s)(We\\x27ve put the action)', r'\\1\\n\\2', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(\\x60{3}\\s)(section. This allows)', r'\\1\\n\\2', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(\\x60{3}\\s)----', r'\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # http://localhost:1313/guides/rhinocommon/run-rhino-command-from-plugin/ - contains bad code-tabs with mismatched defaults - reverse order is intentional\n    new_content = re.sub(r'tablinks2(\\x22\\s.*?cs3.*?)defaultOpen2\\x22', r'tablinks3\\1defaultOpen3\"', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'tablinks1(\\x22\\s.*?cs2.*?)defaultOpen1\\x22', r'tablinks2\\1defaultOpen2\"', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'tablinks(\\x22\\s.*?cs1.*?)defaultOpen\\x22', r'tablinks1\\1defaultOpen1\"', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # add call-out wwarnings about being out-of-date to website guides\n    warning_text = '{{< call-out \"warning\" \"Transition underway\" >}}\\nThis site is undergoing a transition from Jekyll to Hugo. This page is out-of-date while this warning is in place.\\n{{< /call-out >}}\\n\\n'\n    new_content = re.sub(r'(\\x5BThis site\\x5D\\x28http://developer.rhino3d.com\\x29 is hosted on)', warning_text + r'\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(Below are examples of nearly all the available syntax)', warning_text + r'\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # http://localhost:1313/guides/rhinopython/primer-101/ - main images are not floated correctly.  Fix Bad link in acknowledgments\n    # First delete the old column div\n    new_content = re.sub(r'<div class=\\x22col-md-4 hidden-sm hidden-xs\\x22 markdown=\\x221\\x22>\\s.*?</div>', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n    # Insert the first image at the right spot\n    new_content = re.sub(r'(You.ve just opened the .*? edition of the .*? primer.)', r'{{< image url=\"/images/primer-normals.svg\" alt=\"/images/primer-normals.svg\" width=\"30%\" class=\"float_right\" >}}\\n\\n\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n    # Insert the second in the paragraph below that one...\n    new_content = re.sub(r'(Similar to the previous primers, we have the advantage)', r'{{< div class=\"clear_both\" />}}\\n\\n{{< image url=\"/images/primer-branchpropagation2.svg\" alt=\"/images/primer-branchpropagation2.svg\" width=\"30%\" class=\"float_right\" >}}\\n\\n\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(The one advantage I enjoy over authors of other programming books)', r'{{< div class=\"clear_both\" />}}\\n\\n{{< image url=\"/images/primer-branchpropagation2.svg\" alt=\"/images/primer-branchpropagation2.svg\" width=\"30%\" class=\"float_right\" >}}\\n\\n\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n    # Make the autograph smaller\n    new_content = re.sub(r'(primer-autograph.svg\\x22\\swidth=\\x22)70%\\x22', r'primer-autograph.svg\" width=\"40%\"', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(.A special thanks to David Rutten for the inspiration)', r'\\n\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n    # Fix authors columns\n    new_content = re.sub(r'(\\x3Cdiv class=\\x22row\\x22\\x3E\\s\\s)(.*?Tibbits)', r'{{< row >}}\\n\\2', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(Baer\\x2A{2}\\x3Cbr\\x2F\\x3E.*?)(\\x3C\\x2Fdiv\\x3E)', r'\\1{{< /row >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Under construction warnings\n    warning_text = '{{< call-out \"danger\" \"Under Construction\" >}}\\nThis guide has yet to be ported to this site. Please check back soon for updates.\\n{{< /call-out >}}\\n\\n'\n    new_content = re.sub(r'(\\x3Cdiv\\sclass=\\x22bs-callout\\sbs-callout-danger\\x22\\x3E\\s.*?UNDER\\sCONSTRUCTION.*?\\x3C\\x2Fdiv\\x3E)', warning_text, new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # http://localhost:1313/guides/rhinopython/primer-101/8-geometry/ - fix errant line-numbers divs\n    # http://localhost:1313/guides/rhinoscript/primer-101/7-geometry/ - fix errant line-numbers divs\n    new_content = re.sub(r'(rs.EnableRedraw.True.\\s)\\x7B{2}\\x3C\\sdiv\\sclass=\\x22line-numbers\\x22\\s\\x3E\\x7D{2}\\s\\x60{3}', r'\\1\\n```\\n', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(End Sub\\s)\\x7B{2}\\x3C\\sdiv\\sclass=\\x22line-numbers\\x22\\s\\x3E\\x7D{2}\\s\\x60{3}', r'\\1\\n```\\n', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(VectorDotProduct.D.\\sBisector.\\s)\\x7B{2}\\x3C\\sdiv\\sclass=\\x22line-numbers\\x22\\s\\x3E\\x7D{2}\\s\\x60{3}', r'\\1```\\n', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # http://localhost:1313/guides/cpp/defining-new-plugin-commands/ - broken image\n    new_content = re.sub(r'your_first_plugin_windows_cpp_07.png', r'your-first-plugin-windows-cpp-07.png', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # {{ site.nwo }} links\n    new_content = re.sub(r'https://github.com/\\x7B{2}\\ssite.nwo\\s\\x7D{2}/blob/\\x7B{2}\\ssite.git_branch\\s\\x7D{2}/\\x7B{2}\\spage.path\\s\\x7D{2}', r'https://github.com/mcneel/developer-rhino3d-com/blob/main/content/en/guides/general/how-this-site-works/index.md', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # http://localhost:1313/guides/rhinocommon/your-first-plugin-windows/ - window too wide\n    # http://localhost:1313/guides/rhinocommon/your-first-plugin-mac/ - window too wide\n    new_content = re.sub(r'\\s{8}(RhinoApp.WriteLine\\s..The distance between the two points is .*?Length\\x29\\x3B)', r'```cs\\n\\1\\n```\\n', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\s{8}(RhinoApp.WriteLine\\s..The distance between the two points is .*?ToLower\\x28\\x29\\x29\\x3B)', r'```cs\\n\\1\\n```\\n', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # http://localhost:1313/guides/rhinopython/python-operators/ - table clean up\n    # http://localhost:1313/guides/rhinoscript/vbscript-operators/ - table clean up\n    new_content = re.sub(r'\\s\\x7C--\\s\\s\\x7c\\sDescription\\s\\x7C\\s.*?\\x7C\\s{0,1}Symbol\\s\\x7C\\s\\s\\x7C--', r'| Description |      | Symbol |\\n| :---------- | ---- | -----: |', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # http://localhost:1313/guides/rhinopython/ - remove snagit image at bottom of page\n    new_content = re.sub(r'\\x3C\\x21--the\\s.snagit\\sproject\\sfor.this.image.can.be.found.next.to.the.image.--\\x3E\\s{0,2}\\x5B\\x3Cimg.src=\\x22/images/rhinopython-guides-col3.png\\x22\\x3E\\x5D\\x28http://www.rhino3d.com/download/IronPython/5.0/RhinoPython101\\x29(\\s\\s\\x7B{2})', r'\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # {{ site.git_branch | default: \"master\" }}\n    new_content = re.sub(r'\\x7B{2}\\ssite.git_branch\\s.\\sdefault.\\s\\x22master\\x22\\s\\x7D{2}', r'master', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # http://localhost:1313/guides/rhinoscript/primer-101/2-vbscript-essentials/ - table formatting wrong\n    new_content = re.sub(r'\\x7C\\smov\\s\\x7C\\s\\x7C\\s\\x7C.*?esp,\\s8\\s\\x7C', r'|   |  |  |   |\\n| :--- | --- | --- | -------------: |\\n| mov  | [ebx], ecx     |\\n| add  | ebx, 4         |\\n| loop | init_loop      |\\n| push | dword FirstMsg |\\n| call | _puts          |\\n| pop  | ecx            |\\n| push | dword 10       |\\n| push | dword array    |\\n| call | _print_array   |\\n| add  | esp, 8         |\\n', new_content, flags=re.MULTILINE | re.DOTALL)\n    \n    # http://localhost:1313/guides/rhinoscript/getting-and-setting-locale/ - table formatting wrong\n    new_content = re.sub(r'\\x7C--\\s\\x7C\\sCulture\\s\\x7C.*?\\x27567.89\\s\\x7C', r'| Culture       |   Format     |\\n| :------------ | -----------: |\\n| United States | 1,234,567.89 |\\n| France        | 1 234 567,89 |\\n| German        | 1.234.567,89 |\\n| Switzerland   | 1’234’567.89 |\\n', new_content, flags=re.MULTILINE | re.DOTALL)\n    \n    # http://localhost:1313/guides/cpp/loading-plugins-at-startup/ - table formatting wrong\n    new_content = re.sub(r'\\x7C\\s:-------------\\s\\x7C\\s\\x7C\\s\\x7C\\s:-------------\\s\\x7C\\s\\x7C \\x7C\\s:-------------\\s\\x7C', r'| :------------- | --- | --- | :------------- | --- | --- | :------------- |', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(Load when Rhino is loaded)\\s\\s{0,7}\\x7C', r'\\1 |', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # http://localhost:1313/guides/cpp/your-first-plugin-windows/ - window too wide\n    new_content = re.sub(r'\\s{8}RHINO_PLUG_IN_', r'RHINO_PLUG_IN_', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(RHINO_PLUG_IN_DEVELOPER_ORGANIZATION.*?mycompany.com/support\\x22\\x29\\x3B)', r'```cpp\\n\\1\\n```', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\s{4}(\\x21\\x5BRhino\\sOptions\\x5D\\x28/images/your-first-plugin-windows-cpp-07.png\\x29)', r'\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Fix typos\n    new_content = re.sub(r'availabe', r'available', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'RhinoScritSyntax', r'RhinoScriptSyntax', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Add missing codeblock language specifiers\n    new_content = re.sub(r'(```)(\\sconst\\sON_SubD\\x2A\\ssubd\\s=\\sON_SubD\\x3A{2}Cast)', r'\\1cpp\\2', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'(```)(\\s//\\sGets a ON_Brep representation the subdivision limit surface)', r'\\1cpp\\2', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # {{ site.rhino.mac_path }} -> -> /Applications/Rhino x.app\n    new_content = re.sub(r'\\x7B{2}\\ssite.rhino.mac_path\\s\\x7D{2}', r'/Applications/Rhino {{< latest-rhino-version >}}.app', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # {{ site.rhino.windows_path }} -> C:\\Program Files\\Rhino x\n    new_content = re.sub(r'\\x7B{2}\\ssite.rhino.windows_path\\s\\x7D{2}', r'C:\\\\Program Files\\\\Rhino {{< latest-rhino-version >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # {% include yak-mac-path-note.html %}\n    new_content = re.sub(r'\\x7B\\x25\\sinclude\\syak-mac-path-note.html\\s\\x25\\x7D', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # handle call-outs, mostly in yak pages\n    new_content = re.sub(r'\\x3Cdiv\\sclass=\\x22alert\\salert-info\\x22\\srole=\\x22alert\\x22\\x3E\\s(.*?)\\x3C/div\\x3E', r'{{< call-out \"note\" \"Note\" >}}\\n\\1{{< /call-out >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x3Cdiv\\sclass=\\x22alert\\salert-warning\\x22\\srole=\\x22alert\\x22\\x3E\\s(.*?)\\x3C/div\\x3E', r'{{< call-out \"warning\" \"Warning\" >}}\\n\\1{{< /call-out >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x3Cdiv\\sclass=\\x22alert\\salert-danger\\x22\\srole=\\x22alert\\x22\\x3E\\s(.*?)\\x3C/div\\x3E', r'{{< call-out \"danger\" \"Danger\" >}}\\n\\1{{< /call-out >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_content = re.sub(r'\\x3Cstrong\\x3ENote:\\x3C/strong\\x3E\\s', r'', new_content, flags=re.MULTILINE | re.DOTALL) # Remove redundant words\n\n    # Handle bad formatting in yak guide\n    new_content = re.sub(r'\\x3Cbr\\x3E\\x3Cbr\\x3E\\s\\x3Cpre\\x3E\\x3Ccode\\sclass=\\x22language-commandline\\x22\\x3E\\s\\x26gt\\x3B\\s(.*?)\\x26gt\\x3B\\s(.*?)\\x3C/code\\x3E\\x3C/pre\\x3E\\s\\x3Cbr\\x3E\\x3Cbr\\x3E', r'```cmd\\n\\1\\2```', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Remove WIP warning from bottom of index (home) page\n    new_content = re.sub(r'\\x3Cp\\x3E\\x3Ci\\x3EWARNING\\x3C/i\\x3E: This is the Work-In-Progress version of this site & should not be considered stable. \\x3Ca href=\\x22\\x7B{2}site.baseurl_orig\\x7D{2}\\x7B{2} page.url \\x7D{2}\\x22\\x3EView the current stable version instead.\\x3C/a\\x3E\\x3C/p\\x3E', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n    \n    return new_content\n\n\ndef convert_markdown_file(file_to_convert):\n    global old_root\n    new_content = \"\"\n\n    new_frontmatter_section = \" \"\n    new_content_section = \" \"\n\n    # Separate the yml frontmatter from the content\n    old_file = open(file_to_convert, \"r\")\n    old_frontmatter_section = ''\n    old_content_section = ''\n    \n    found_seperators = 0\n    for line in old_file:\n        if found_seperators < 2:\n            old_frontmatter_section += line \n            if line.startswith(\"---\\n\"):\n                found_seperators = found_seperators + 1\n        else:\n            old_content_section += line\n    \n    old_file.close()\n\n    # If this is a guide or sample, we should calculate the override_last_modified date and add that to the frontmatter\n    override_last_modified = ''\n    if not debugging: # this process is kinda slow, so only do this at the end\n        if ('_guide_topics' in file_to_convert) or ('_samples' in file_to_convert):\n            git_log_argument = 'git log -1 --pretty=\"format:%ci\" ' + file_to_convert\n            git_log_process = subprocess.Popen([git_log_argument], cwd=old_root, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)\n            git_last_updated, err = git_log_process.communicate()\n            \n            if git_last_updated:\n                git_last_updated = str(git_last_updated.decode())\n                hugo_date_format = git_last_updated.split(\" \")[0] + 'T' + git_last_updated.split(\" \")[1] + 'Z'\n\n                override_last_modified = hugo_date_format\n\n    # Convert frontmatter\n    new_fontmatter_section = convert_frontmatter(old_frontmatter_section, override_last_modified)\n\n    # Convert markdown\n    new_content_section = convert_markdown_content(old_content_section)\n\n    # Put the frontmatter and the content together\n    new_content = new_fontmatter_section + new_content_section\n\n    return new_content\n\n\ndef convert_path_list(list_of_file_paths, src_folder, dest_folder):\n    for old_file_path in list_of_file_paths:\n        old_file_title = os.path.basename(old_file_path).split(\".md\")[0]\n        \n        # Create a folder based on the name of the old file in the right spot\n        new_subpath = old_file_path.split(src_folder + \"/\")[1].split(\".md\")[0]\n        new_file_folder_path = os.path.abspath(os.path.join(dest_folder, new_subpath))\n        if not os.path.exists(new_file_folder_path):\n            os.makedirs(new_file_folder_path)\n            \n        # Check to see if there is a folder that matches the name of the old file, if so, it's an index page\n        is_index_page = False\n        path_to_check = os.path.abspath(os.path.join(src_folder, new_subpath))\n        if os.path.exists(path_to_check):\n            if os.path.isdir(path_to_check):\n                is_index_page = True\n            \n        new_file_path = \"\"\n        if is_index_page:\n            new_file_path = os.path.abspath(os.path.join(new_file_folder_path, \"_index.md\"))\n        else:\n            new_file_path = os.path.abspath(os.path.join(new_file_folder_path, \"index.md\"))\n\n        print(\"Converting: \" + new_subpath + \"...\")\n        new_content = convert_markdown_file(old_file_path)\n        new_file = open(new_file_path, \"w\")\n        new_file.write(new_content)\n        new_file.close()\n\n\n# Main handlers --------------------------------------------------------------------------------------------------------\ndef handle_homepage():\n    print(\"Port homepage (index) from jekyll to hugo...\")\n    old_content_homepage_path = os.path.abspath(os.path.join(old_root, \"index.md\"))\n    new_content_homepage_path = os.path.abspath(os.path.join(new_content_root_path, \"_index.md\"))\n\n    new_content = convert_markdown_file(old_content_homepage_path)\n    new_homepage_index_file = open(new_content_homepage_path, \"w\")\n    \n    # add top-level list_group for multi-page TOCs\n    new_content = re.sub(r'\\s{1}(\\+\\+\\+)', r'\\n[cascade]\\nlist_group = \"uncategorized\"\\n\\1', new_content, flags=re.MULTILINE | re.DOTALL)\n    \n    # Force left-aligned table headings:\n    new_content = re.sub(r'(\\x3Cth)\\x3E', r'\\1 style=\"text-align: left;\">', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    # Add padding to the top and bottom of the tagline at the bottom\n    new_content = re.sub(r'(\\x7B{2}\\x3C\\scenter\\s\\x3E\\x7D{2}\\s\\s)(Rhino developer tools are royalty free and include support.)', r'\\1{{< div class=\"index_free_support\" >}}\\n\\2\\n{{< /div >}}', new_content, flags=re.MULTILINE | re.DOTALL)\n\n    new_homepage_index_file.write(new_content)\n    new_homepage_index_file.close()\n\n    print_ok_message(\"homepage (index) successfully ported to hugo.\")\n\n\ndef handle_authors():\n    print(\"Porting authors from jekyll to hugo...\")\n    old_content_authors_paths = get_markdown_files_list(old_content_authors_root_path)\n    \n    # make sure the /contents/en/authors section exists and create it if it doesn't\n    new_content_authors_root_path = os.path.abspath(os.path.join(new_content_root_path, \"authors\"))\n    if not os.path.exists(new_content_authors_root_path):\n        print_warning_message(new_content_authors_root_path + \" does not exists, creating it\")\n        os.makedirs(new_content_authors_root_path)\n\n    # Handle _authors index (new: /content/en/authors/_index.md)\n    old_authors_index_path = os.path.abspath(os.path.join(old_root, \"authors.md\"))\n    new_authors_index_path = os.path.abspath(os.path.join(new_content_authors_root_path, \"_index.md\"))\n    new_content = convert_markdown_file(old_authors_index_path)\n    # make sure the authors page uses the correct authors layout template\n    new_content = re.sub(r'type\\s=\\s\\x22guides\\x22', r'type = \"authors\"', new_content, flags=re.MULTILINE | re.DOTALL)\n    # remove old authors list generation\n    new_content = re.sub(r'\\x3Cdiv\\sclass=\\x22trigger\\x22\\x3E\\s.*?\\x3C\\x2Fdiv\\x3E', r'', new_content, flags=re.MULTILINE | re.DOTALL)\n    new_authors_index_file = open(new_authors_index_path, \"w\")\n    new_authors_index_file.write(new_content)\n    new_authors_index_file.close()\n\n    # Create folders for each author and put the default layout file in it.\n    for old_author_path in old_content_authors_paths:\n        old_author = os.path.basename(old_author_path).split(\".\")[0].strip()\n        new_author = authors_mapping[old_author]\n        new_author_path = os.path.abspath(os.path.join(new_content_authors_root_path, new_author))\n        log_redirect_url(\"/authors/\" + old_author, \"/authors/\" + new_author)\n        if not os.path.exists(new_author_path):\n            print_warning_message(new_author_path + \" does not exists, creating it\")\n            os.makedirs(new_author_path)\n        \n        new_author_content_path = os.path.abspath(os.path.join(new_author_path, \"index.md\"))\n        new_index_file = open(new_author_content_path, \"w\")\n        index_file_contents = ['+++', 'type = \\\"authors\\\"', '+++']\n        new_index_file.write('\\n'.join(index_file_contents) + '\\n')\n        new_index_file.close()\n\n    print_ok_message(\"authors successfully ported to hugo.\")\n\n\ndef handle_guides():\n    print(\"Porting guides from jekyll to hugo...\")\n    old_content_guides_paths = get_markdown_files_list(old_content_guides_root_path)\n\n    # make sure the /contents/en/guides section exists and create it if it doesn't\n    new_content_guides_root_path = os.path.abspath(os.path.join(new_content_root_path, \"guides\"))\n    if not os.path.exists(new_content_guides_root_path):\n        print_warning_message(new_content_guides_root_path + \" does not exists, creating it\")\n        os.makedirs(new_content_guides_root_path)\n\n    # copy over the old folder structure \"as is\"\n    copy_folder_tree_without_files(old_content_guides_root_path, new_content_guides_root_path)\n\n    # grab the guides index page\n    guides_index_path_old = os.path.abspath(os.path.join(old_root, \"guides.md\"))\n    guides_index_path_new = os.path.abspath(os.path.join(new_content_guides_root_path, \"_index.md\"))\n    print(\"Converting: /guides.md ...\")\n    new_content = convert_markdown_file(guides_index_path_old)\n    new_file = open(guides_index_path_new, \"w\")\n    new_content = re.sub(r'#\\sGuides', r'', new_content) #remove redundant title\n    new_file.write(new_content)\n    new_file.close()\n\n    # perform the conversion...\n    convert_path_list(old_content_guides_paths, old_content_guides_root_path, new_content_guides_root_path)\n\n    print_ok_message(\"guides successfully ported to hugo.\")\n\n    \ndef handle_samples():\n    print(\"Porting samples from jekyll to hugo...\")\n    old_content_samples_paths = get_markdown_files_list(old_content_samples_root_path)\n    \n    # make sure the /contents/en/samples section exists and create it if it doesn't\n    new_content_samples_root_path = os.path.abspath(os.path.join(new_content_root_path, \"samples\"))\n    if not os.path.exists(new_content_samples_root_path):\n        print_warning_message(new_content_samples_root_path + \" does not exists, creating it\")\n        os.makedirs(new_content_samples_root_path)\n\n    # copy over the old folder structure \"as is\"\n    copy_folder_tree_without_files(old_content_samples_root_path, new_content_samples_root_path)\n\n    # grab the samples index page\n    samples_index_path_old = os.path.abspath(os.path.join(old_root, \"samples.md\"))\n    samples_index_path_new = os.path.abspath(os.path.join(new_content_samples_root_path, \"_index.md\"))\n    print(\"Converting: /samples.md ...\")\n    new_content = convert_markdown_file(samples_index_path_old)\n    new_file = open(samples_index_path_new, \"w\")\n    new_content = re.sub(r'#\\sSamples', r'', new_content) #remove redundant title\n    new_file.write(new_content)\n    new_file.close()\n\n    # perform the conversion...\n    convert_path_list(old_content_samples_paths, old_content_samples_root_path, new_content_samples_root_path)\n\n    print_ok_message(\"samples successfully ported to hugo.\")\n\n\ndef handle_api():\n    print(\"Porting api page from jekyll to hugo...\")\n    global old_content_api_page_path\n    \n    # make sure the /contents/en/api section exists and create it if it doesn't\n    new_content_api_root_path = os.path.abspath(os.path.join(new_content_root_path, \"api\"))\n    if not os.path.exists(new_content_api_root_path):\n        print_warning_message(new_content_api_root_path + \" does not exists, creating it\")\n        os.makedirs(new_content_api_root_path)\n    \n    new_content_api_page_path = os.path.abspath(os.path.join(new_content_api_root_path, \"_index.md\"))\n\n    print(\"Converting: /api.md ...\")\n    new_content = convert_markdown_file(old_content_api_page_path)\n    new_file = open(new_content_api_page_path, \"w\")\n\n    # Special cases for API page...\n    new_content = re.sub(r'#\\sAPI References  ', r'', new_content) # remove redundant title\n    new_content = re.sub(r'title = \\\"API\\\"', r'title = \"API References\"', new_content) # add proper title    \n    new_content = re.sub(r'<span class=\"glyphicon glyphicon-new-window\" aria-hidden=\"true\"></span>', r'{{< awesome \"fas fa-external-link-alt\" >}}', new_content)\n    \n    new_file.write(new_content)\n    new_file.close()\n\n    print_ok_message(\"api successfully ported to hugo.\")\n\n\ndef handle_images():\n    print(\"Porting images and resources content from old site to new...\")\n\n    shutil.copytree(old_images_root_path, new_images_root_path, dirs_exist_ok=True)\n\n    print_ok_message(\"images and resources ported to new site.\")\n\n\ndef handle_videos():\n    print(\"Porting videos page from old site to new...\")\n    global old_content_videos_page_path\n\n    # make sure the /contents/en/videos section exists and create it if it doesn't\n    new_content_video_root_path = os.path.abspath(os.path.join(new_content_root_path, \"videos\"))\n    if not os.path.exists(new_content_video_root_path):\n        print_warning_message(new_content_video_root_path + \" does not exists, creating it\")\n        os.makedirs(new_content_video_root_path)\n    \n    new_content_video_page_path = os.path.abspath(os.path.join(new_content_video_root_path, \"_index.md\"))\n\n    print(\"Converting: /videos.md ...\")\n    new_content = convert_markdown_file(old_content_videos_page_path)\n    new_file = open(new_content_video_page_path, \"w\")\n    new_content = re.sub(r'#\\sVideos', r'', new_content) #remove redundant title\n    new_file.write(new_content)\n    new_file.close()\n\n    print_ok_message(\"videos page successfully ported to hugo.\")\n\n\ndef handle_files_folder():\n    print(\"Porting files content from old site to new...\")\n\n    shutil.copytree(old_files_root_path, new_files_root_path, dirs_exist_ok=True)\n\n    print_ok_message(\"files ported to new site.\")\n\n\ndef handle_rhinoscript_syntax_api():\n    print(\"Processing rhinoscriptsyntax data...\")\n\n    # open and read the rhinoscriptsyntax.json file\n    path_to_rhinoscriptsyntax_json = os.path.abspath(os.path.join(new_content_data_path, \"rhinoscriptsyntax.json\"))\n    rs_json_file = open(path_to_rhinoscriptsyntax_json)\n    modules = json.load(rs_json_file)\n\n    for module in modules:\n        new_content_api_root_path = os.path.abspath(os.path.join(new_content_root_path, \"api\"))\n        rhinoscriptsyntax_root_path = os.path.abspath(os.path.join(new_content_api_root_path, \"RhinoScriptSyntax\"))\n        \n        # make the module folder\n        new_module_folder_path = os.path.abspath(os.path.join(rhinoscriptsyntax_root_path, module[\"ModuleName\"]))\n        if not os.path.exists(new_module_folder_path):\n            os.makedirs(new_module_folder_path)\n        \n        # add the module index.md file\n        module_index_path = os.path.abspath(os.path.join(new_module_folder_path, \"index.md\"))\n        f = open(module_index_path, \"w\")\n\n        # write the frontmatter\n        f.write('+++\\n')\n        f.write('Title = \\\"' + module[\"ModuleName\"] + '\\\"\\n')\n        f.write('type = \\\"guides\\\"\\n')\n        #f.write('list_group = \\\"' + module[\"ModuleName\"] + ' module \\\"\\n\\n')\n        f.write('[page_options]\\n')\n        f.write('byline = false\\n')\n        f.write('toc = true\\n')\n        f.write('toc_type = \\\"multi\\\"\\n')\n        f.write('+++\\n\\n')\n\n        for function in module[\"functions\"]:\n            f.write('## ' + function[\"Name\"] + '\\n\\n')\n            f.write('```py\\n')\n            f.write(function[\"Signature\"]  + '\\n')\n            f.write('```\\n\\n')\n            description = function[\"Description\"].replace('\\r\\n    ', '')\n            f.write(description + '\\n\\n')\n            if function[\"HasArguments\"]:\n                f.write('**Parameters:**\\n\\n')\n                f.write('```\\n')\n                f.write(function[\"ArgumentDesc\"]  + '\\n')\n                f.write('```\\n\\n')\n            if function[\"ReturnStr\"]:\n                f.write('**Returns:**\\n\\n')\n                f.write('```\\n')\n                f.write(function[\"ReturnStr\"]  + '\\n')\n                f.write('```\\n\\n')\n            if function[\"ExampleString\"]:\n                f.write('**Example:**\\n\\n')\n                f.write('```py\\n')\n                f.write(function[\"ExampleString\"]  + '\\n')\n                f.write('```\\n\\n')\n            if len(function[\"SeeAlso\"]) > 0:\n                f.write('**See Also:**\\n\\n')\n                for entry in function[\"SeeAlso\"]:\n                    moduleName = ''\n                    if not entry[\"ModuleName\"]:\n                        moduleName = module[\"ModuleName\"]\n                    else:\n                        moduleName = entry[\"ModuleName\"]\n                    f.write('* [' + entry[\"FunctionName\"] + '](/api/RhinoScriptSyntax/' + moduleName + '/#' + entry[\"FunctionName\"].lower() + ')\\n')\n                f.write('\\n')\n        \n        f.close()\n    \n    rs_json_file.close()\n\n    print_ok_message(\"done processing rhinoscriptsyntax data.\")\n\n\ndef audit_frontmatter():\n    global frontmatter_key_mapping\n    global yaml_keys_to_ignore\n    print(\"Auditing frontmatter...\")\n    print(\"  The following yaml frontmatter keys were found:\")\n    for key in frontmatter_key_mapping:\n        print(\"    \" + key)\n    \n    print(\"  The following yaml keys were ignored:\")\n    for key in yaml_keys_to_ignore:\n        print(\"    \" + key)\n\n    # Check for missing mappings\n    missing_mappings = {}\n    for key, value in frontmatter_key_mapping.items():\n        if \"[missing]\" in value:\n            missing_mappings[key] = value\n    if missing_mappings:\n        print(\"  The following yaml keys DO NOT have a toml mapping value:\")\n        for key, value in missing_mappings.items():\n            print(\"    \" + key + \" -> \" + value)\n\n\ndef add_aliases_to_files_list(files_list):\n    for file_path in files_list:\n        with open(file_path, \"r\") as f:\n            contents = f.readlines()\n\n        old_link = re.sub(r'.*?\\x2Fcontent\\x2Fen(\\x2F.*?\\x2F).{0,1}index.md', r'\\1', file_path, flags=re.MULTILINE | re.DOTALL)\n        contents.insert(1, \"aliases = [\\\"/5\" + old_link + \"\\\", \\\"/6\" + old_link + \"\\\", \\\"/7\" + old_link + \"\\\", \\\"/wip\" + old_link + \"\\\"]\\n\")\n\n        with open(file_path, \"w\") as f:\n            contents = \"\".join(contents)\n            f.write(contents)\n\n\ndef main():\n    handle_homepage()\n    handle_authors()\n    handle_guides()\n    handle_samples()\n    handle_api()\n    handle_images()\n    handle_files_folder()\n    handle_videos()\n    audit_frontmatter()\n    #handle_rhinoscript_syntax_api()\n    #add_aliases_to_files_list(get_markdown_files_list(new_content_root_path))\n\nif __name__ == \"__main__\":\n    main()\n",
  "language": "python",
  "imports": [
    "RhinoCommon",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}