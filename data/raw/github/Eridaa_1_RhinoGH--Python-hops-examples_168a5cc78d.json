{
  "source_url": "https://github.com/Eridaa/1.RhinoGH--Python-hops-examples/blob/db30011918629b550eb1e26aa638723944303b9a/RhinoGH--Mesh-analysis-with-networkx-main/02_MeshToGraph/meshpath.py",
  "repo": "Eridaa/1.RhinoGH--Python-hops-examples",
  "repo_stars": 2,
  "repo_description": null,
  "license": "unknown",
  "filepath": "RhinoGH--Mesh-analysis-with-networkx-main/02_MeshToGraph/meshpath.py",
  "instruction": "Meshpath",
  "code": "import networkx as nx\nimport rhino3dm as rg\nimport meshutils as mu\n\ndef SimpleGraphFromMesh(mesh):\n\n    # Create graph\n    G=nx.Graph()\n\n    #Get the full graph\n    for i in range(mesh.Faces.Count):\n        \n        # Add node to graph and get its neighbours\n        G.add_node(i)\n        neighbours = mu.getAdjancentFaces(mesh ,i)\n        \n        # Add edges to graph\n        for n in neighbours:\n            if n > i:\n                G.add_edge(i,n)\n\n    return G\n\n\n\ndef graphFromMesh(mesh,weightMode = \"edgeLength\"):\n\n    # Create graph\n    g=nx.Graph()\n    a=mesh\n    meshtype = mu.getMeshType(mesh)\n\n    #Get the full graph\n    for i in range(a.Faces.Count):\n\n        if meshtype == \"tri\":    \n            face_center = mu.getFaceCenterTri(a, a.Faces[i])\n        elif meshtype == \"quad\":\n             face_center =mu.getFaceCenter(a, a.Faces[i])\n\n        \n        # Add node to graph and get its neighbours\n        g.add_node(i,point = face_center, face = i, isNaked = a.Faces.HasNakedEdges(i))\n        neighbours = mu.getAdjancentFaces(a ,i)\n        \n        \n        # Add edges to graph\n        for n in neighbours:\n            if n > i:\n                p1=face_center\n                if meshtype == \"tri\":    \n                    p2=mu.getFaceCenterTri(a, a.Faces[n])\n                elif meshtype == \"quad\":\n                    p2=mu.getFaceCenter(a, a.Faces[n])\n                \n                line = rg.Line(p1,p2)\n                if weightMode == \"edgeLength\":\n                    w = line.Length\n                elif weightMode == \"sameWeight\":\n                    w = 1\n                g.add_edge(i,n,weight=w,line=line)\n\n    return g\n\n\n\ndef shortestPath(g, f1, f2):\n\n    sp = nx.shortest_path(g, f1, f2, weight = \"weight\")\n    \n    pts = [g.nodes[i][\"point\"] for i in sp]\n    faceInd = [g.nodes[i][\"face\"] for i in sp]\n\n    return pts, faceInd, sp\n\n\ndef dijkstraPath(g, f1, f2):\n\n    sp = nx.dijkstra_path(g, f1, f2, weight = \"weight\")\n    \n    pts = [g.nodes[i][\"point\"] for i in sp]\n    faceInd = [g.nodes[i][\"face\"] for i in sp]\n\n    return pts, faceInd, sp\n\ndef longestPath(g, f1, f2):\n\n    sp = nx.dag_longest_path(g, f1, f2, weight = \"weight\")\n    \n    pts = [g.nodes[i][\"point\"] for i in sp]\n    faceInd = [g.nodes[i][\"face\"] for i in sp]\n\n    return pts, faceInd, sp\n\n\ndef burnEdgesPath(g):\n    \n    sp = mu.getGraphNakedNodes(g)\n\n    pts = [g.nodes[i][\"point\"] for i in sp]\n    faceInd = [g.nodes[i][\"face\"] for i in sp]\n\n    return pts, faceInd, sp\n\n\ndef AllShortestPaths(g, startpoint):\n    end_point_index=startpoint #for single face islands\n    \"\"\"Get the end point by getting the index of the point that has the longest shortest path\"\"\"\n\n    initial_length=0 \n    for i in list(g.nodes):          \n        if mu.hasPath(g,startpoint,i):\n            Pathlength = nx.dijkstra_path_length(g,startpoint,i,weight = \"weight\")\n            if Pathlength>initial_length :\n                initial_length=Pathlength\n                end_point_index=i\n                s=i\n            elif Pathlength < initial_length and i!=startpoint:\n                end_point_index=s\n\n\n    end=end_point_index\n    \n    # Check that start and end are not the same node\n    if startpoint == end:\n        pts = [g.nodes[startpoint][\"point\"]]\n        indexes=[startpoint]\n        sl=1\n        to_be_removed=[startpoint]\n        return [pts,indexes,sl,to_be_removed]\n        \n    else:\n        # Check that a path exist between the two nodes\n        if mu.hasPath(g,startpoint,end):\n            # Calculate shortest path\n            \n            sp = nx.dijkstra_path(g,startpoint,end,weight = \"weight\")\n\n            # Make polyline through path\n            pts = [g.nodes[i][\"point\"] for i in sp]\n            #get points indexes \n            indexes=sp\n            sl=len(sp)\n            to_be_removed=sp\n\n        \n                    \n        return [pts,indexes,sl,to_be_removed]\n\n\n\ndef minimun_spanning_tree(g):\n\n    MST=nx.minimum_spanning_tree(g, algorithm='kruskal')\n    \n    #MB =nx.maximum_branching(MST, preserve_attrs = True)\n    #MB =nx.minimum_branching(MST, preserve_attrs = True)\n\n    ED= nx.algorithms.tree.branchings.Edmonds(MST)\n    MB= ED.find_optimum(style=\"branching\", kind= \"max\",preserve_attrs = True)\n    #print(MB.nodes(data=True))\n\n    S = [MB.subgraph(c).copy() for c in nx.connected_components(MB)]\n    \n    allnodes= [list(g.nodes) for g in S]\n\n    return allnodes\n\n\ndef minimun_spanning_edges(g):\n\n    MST=nx.minimum_spanning_tree(g, algorithm='kruskal')\n    T_edges=MST.edges\n    tree_lines=[]\n    \n    for i in T_edges:\n        p1index=i[0]\n        p2index=i[1]\n        p1=g.nodes[p1index][\"point\"]\n        p2=g.nodes[p2index][\"point\"]\n        l=rg.LineCurve(p1, p2)\n        tree_lines.append(l)\n    \n    return tree_lines\n\n\n        ",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}