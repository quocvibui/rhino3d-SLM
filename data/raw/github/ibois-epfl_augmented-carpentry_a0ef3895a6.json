{
  "source_url": "https://github.com/ibois-epfl/augmented-carpentry/blob/414eeb93984fad40a4e57daa60e1bb268cbd406c/py/pypi/ACPy/ac_hole.py",
  "repo": "ibois-epfl/augmented-carpentry",
  "repo_stars": 15,
  "repo_description": "Main repository hosting the main AR software developed for Augmented Carpentry rersearch at Ibois, Epfl.",
  "license": "GPL-3.0",
  "filepath": "py/pypi/ACPy/ac_hole.py",
  "instruction": "Ac hole",
  "code": "import Rhino\nimport Rhino.Geometry as rg\nimport rhinoscriptsyntax as rs\nimport random\n\nimport ACPy.ac_util\n\nTOL_DOC = Rhino.RhinoDoc.ActiveDoc.ModelAbsoluteTolerance\n\ndef _get_radius_from_curved_brep_faces(cylinder_faces_b, start_pt, end_pt):\n    for face in cylinder_faces_b:\n        if not face.Faces[0].IsPlanar():\n            face_curves = face.DuplicateEdgeCurves(True)\n            face_crv = face_curves[0]\n            pt_base = face_crv.PointAtStart\n            axis_ln = rg.Line(start_pt, end_pt)\n            radius = axis_ln.DistanceTo(pt_base, False)\n            radius = round(radius, 3)\n    return round(radius, 3)\n\ndef parse_data_from_brep(ACIM,\n                         p_GUID,\n                         cylinder_b,\n                         bbox_b):\n    \"\"\"\n        Parse data from a brep defining a hole\n        :param ACIM: the ACIM object to export xml\n        :param p_GUID: the guid of the timber\n        :param cylinder_b: the brep defining the hole\n        :param bbox_b: the brep of the bounding box\n\n        :return list: A list of objects and text for debugging\n    \"\"\"\n    debug_objects = []\n    # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n    bbox_faces_b = ACPy.ac_util.explode_brep(bbox_b)\n    cylinder_faces_b = ACPy.ac_util.explode_brep(cylinder_b)\n    # print(\"cylinder faces: \" + str(len(cylinder_faces_b)))\n    # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n    # get the centers of the cylinder's bases and if they are exposed\n    acim_centers = {}\n    for face in cylinder_faces_b:\n        if face.Faces[0].IsPlanar():\n            continue\n        face_curves = face.DuplicateEdgeCurves(True)\n        for face_crv in face_curves:\n            face_crv_center = ACPy.ac_util.get_crv_circle_center(face_crv)\n            is_on_face = False\n            if bbox_b.IsPointInside(face_crv_center, TOL_DOC, True):\n                if ACPy.ac_util.is_pt_unique_in_dict(face_crv_center, acim_centers):\n                    acim_centers[face_crv_center] = is_on_face\n                    debug_objects.append(face_crv_center)  # vd.addPt(face_crv_center, (0,255,0))\n                    continue\n            if rs.IsPointOnSurface(face, face_crv_center):\n                is_on_face = True\n            if ACPy.ac_util.is_pt_unique_in_dict(face_crv_center, acim_centers):\n                acim_centers[face_crv_center] = is_on_face\n                debug_objects.append(face_crv_center)  # vd.addPt(face_crv_center, (255,0,0))\n    # print(\"length of acim_centers: \" + str(len(acim_centers)))\n\n    # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n    # parse simple holes or sub-holes\n    centers_len = len(acim_centers)\n    acim_centers_values = list(acim_centers.values())\n    acim_centers_keys = list(acim_centers.keys())\n    \n    if centers_len == 0:\n        # print(\"No center found for the hole. Exiting...\")\n        return\n    if centers_len == 1:\n        # print(\"Single center found for the hole. Exiting...\")\n        return\n    if centers_len == 2:\n        # print(\"Simple 2-points hole detected\")\n        start_pt = rg.Point3d(0,0,0)\n        end_pt = rg.Point3d(0,0,0)\n        is_start_pt_accessible = False\n        is_end_pt_accessible = False\n        if acim_centers_values[0]:\n            start_pt = acim_centers_keys[0]\n            end_pt = acim_centers_keys[1]\n            is_start_pt_accessible = acim_centers_values[0]\n            is_end_pt_accessible = acim_centers_values[1]\n        else:\n            start_pt = acim_centers_keys[1]\n            end_pt = acim_centers_keys[0]\n            is_start_pt_accessible = acim_centers_values[1]\n            is_end_pt_accessible = acim_centers_values[0]\n\n        radius = _get_radius_from_curved_brep_faces(cylinder_faces_b, start_pt, end_pt)\n        # print(\"radius: \" + str(radius))\n        debug_objects.append(rg.Line(start_pt, end_pt))  # vd.addLine(rg.Line(start_pt, end_pt), (255,165,0))\n        # vd.addDotPt(ptA=start_pt, ptB=end_pt, clr=(0,255,0), txt=str(ACIM.peek_current_hole_id(p_GUID)))\n        \n        for face in cylinder_faces_b:\n            if not face.Faces[0].IsPlanar():\n                face_curves = face.DuplicateEdgeCurves(True)\n                debug_objects.append(face_curves[0])  # vd.addCurve(face_curves[0], (255,0,255))\n                debug_objects.append(face_curves[1])  # vd.addCurve(face_curves[1], (255,0,255))\n\n        ACIM.add_hole(p_GUID,\n                    start_pt,\n                    end_pt,\n                    is_start_pt_accessible,\n                    is_end_pt_accessible,\n                    radius)\n    if centers_len > 2:\n        # print(\"Complex hole detected\")\n        holes = []\n        \n        # get longest line\n        dists = []\n        extreme_pts = []\n        for i in range(0, centers_len):\n            for j in range(i+1, centers_len):\n                pt1 = acim_centers_keys[i]\n                pt2 = acim_centers_keys[j]\n                dist = pt1.DistanceTo(pt2)\n                dists.append(dist)\n                if dist >= max(dists) or len(dists) == 0:\n                    extreme_pts = [i, j]\n\n        extreme_pts = [acim_centers_keys[extreme_pts[0]],\n                       acim_centers_keys[extreme_pts[1]]]\n        longest_ln = rg.Line(extreme_pts[0], extreme_pts[1])\n        longest_crv = longest_ln.ToNurbsCurve()\n\n        centers_lst_reorder = list(acim_centers_keys)\n        centers_lst_reorder.sort(key=lambda x: extreme_pts[0].DistanceTo(x))\n\n        #create segments\n        hole_axis_ln = []\n        for i in range(0, centers_len-1):\n            pt1 = centers_lst_reorder[i]\n            pt2 = centers_lst_reorder[i+1]\n            ln = rg.Line(pt1, pt2)\n            hole_axis_ln.append(ln)\n        \n        # detect neighbours\n        neighbor_lst = []\n        for i in range(0, len(hole_axis_ln)):\n            for j in range(0, len(hole_axis_ln)):\n                if i == j:\n                    continue\n                if hole_axis_ln[i].DistanceTo(hole_axis_ln[j].From, False) < 0.01:\n                    neighbor_lst.append([i, j])\n                    break\n                if hole_axis_ln[i].DistanceTo(hole_axis_ln[j].To, False) < 0.01:\n                    neighbor_lst.append([i, j])\n                    break\n        # print(\"neighbor pattern for current hole set: \" + str(neighbor_lst))\n        next_hole_ids = []\n        current_hole_id = ACIM.peek_current_hole_id(p_GUID)\n        for i in range(1, len(neighbor_lst)+1):\n            next_hole_ids.append(current_hole_id)\n            current_hole_id += 1\n        # print(\"next hole ids: \" + str(next_hole_ids))\n        neighbor_acim_str = []\n        for i in range(0, len(neighbor_lst)):\n            temp_str = \"\"\n            for j in range(1, len(neighbor_lst[i])):\n                temp_str += str(next_hole_ids[neighbor_lst[i][j]]) + \" \"\n            temp_str = temp_str[:-1]\n            neighbor_acim_str.append(temp_str)\n        # print(\"neighbor acim str: \" + str(neighbor_acim_str))\n\n        for i, axis_ln in enumerate(hole_axis_ln):\n            debug_objects.append(axis_ln)  # vd.addLine(axis_ln, (255,165,0))\n            # vd.addDotLn(ln=axis_ln, clr=(30,255,230), txt=str(ACIM.peek_current_hole_id(p_GUID)))\n\n            start_pt = rg.Point3d(0,0,0)\n            end_pt = rg.Point3d(0,0,0)\n            is_start_pt_accessible = False\n            is_end_pt_accessible = False\n            pt_1 = axis_ln.PointAt(0)\n            pt_2 = axis_ln.PointAt(1)\n            if acim_centers[pt_1]:\n                start_pt = pt_1\n                end_pt = pt_2\n                is_start_pt_accessible = acim_centers[pt_1]\n                is_end_pt_accessible = acim_centers[pt_2]\n            else:\n                start_pt = pt_2\n                end_pt = pt_1\n                is_start_pt_accessible = acim_centers[pt_2]\n                is_end_pt_accessible = acim_centers[pt_1]\n            \n            for face in cylinder_faces_b:\n                if not face.Faces[0].IsPlanar():\n                    radius = 0\n                    face_curves = face.DuplicateEdgeCurves(True)\n                    face_center_A = ACPy.ac_util.get_crv_circle_center(face_curves[0])\n                    face_center_B = ACPy.ac_util.get_crv_circle_center(face_curves[1])\n\n                    debug_objects.append(face_curves[0])  # vd.addCurve(face_curves[0], (255,0,255))\n                    debug_objects.append(face_curves[1])  # vd.addCurve(face_curves[1], (255,0,255))\n\n                    f_0X = round(face_center_A.X, 3)\n                    f_0Y = round(face_center_A.Y, 3)\n                    f_0Z = round(face_center_A.Z, 3)\n\n                    f_1X = round(face_center_B.X, 3)\n                    f_1Y = round(face_center_B.Y, 3)\n                    f_1Z = round(face_center_B.Z, 3)\n\n                    sX = round(start_pt.X, 3)\n                    sY = round(start_pt.Y, 3)\n                    sZ = round(start_pt.Z, 3)\n\n                    eX = round(end_pt.X, 3)\n                    eY = round(end_pt.Y, 3)\n                    eZ = round(end_pt.Z, 3)\n\n                    if (f_0X == sX and f_0Y == sY and f_0Z == sZ) or (f_0X == eX and f_0Y == eY and f_0Z == eZ):  # = start\n                        if (f_1X == sX and f_1Y == sY and f_1Z == sZ) or (f_1X == eX and f_1Y == eY and f_1Z == eZ):  # = end\n                            ellipse_pt = face_curves[0].PointAtStart\n                            radius = axis_ln.DistanceTo(ellipse_pt, False)\n                            radius = round(radius, 3)\n                            break\n\n            ACIM.add_hole(p_GUID,\n                        start_pt,\n                        end_pt,\n                        is_start_pt_accessible,\n                        is_end_pt_accessible,\n                        radius,\n                        neighbours=neighbor_acim_str[i])\n\n    return debug_objects\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}