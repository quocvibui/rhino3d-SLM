{
  "source_url": "https://github.com/969flash/DesignAutomationLecture/blob/4e85efcd91e11c0715f2ff7d7e1162cc84c942f1/stub/RhinoStub/rhino3d-8.19.25132.1001/Rhino/Geometry/__init__.pyi",
  "repo": "969flash/DesignAutomationLecture",
  "repo_stars": 0,
  "repo_description": "DesignAutomationLecture",
  "license": "unknown",
  "filepath": "stub/RhinoStub/rhino3d-8.19.25132.1001/Rhino/Geometry/__init__.pyi",
  "instruction": "this file is auto-generated by rhinocode stubmaker. do not make changes",
  "code": "\"\"\"this file is auto-generated by rhinocode stubmaker. do not make changes\"\"\"\n\n# region: Exports\n__all__ = [\"Morphs\", \"MeshRefinements\", \"Intersect\", \"Collections\", \"AnnotationType\", \"Dimension\", \"OrdinateDimension\", \"SubDComponentLocation\", \"SubDVertexTag\", \"SubDEdgeTag\", \"SubDEdgeType\", \"SubDHashType\", \"SubDToBrepOptions\", \"SubDFromSurfaceMethods\", \"SubDEndCapStyle\", \"SubDVertexFacetType\", \"SubDChainType\", \"SubDFriendlyKnotType\", \"SubDAutomaticMeshToSubDContext\", \"SubDPatchStyle\", \"SubD\", \"SubDCreationOptions\", \"SubDSurfaceInterpolator\", \"MeshPipeCapStyle\", \"MeshExtruderParameterMode\", \"MeshExtruderFaceDirectionMode\", \"MeshUnwrapMethod\", \"SquishDeformation\", \"SquishFlatteningAlgorithm\", \"FilletSurfaceSplitType\", \"RefitTrimSectionMode\", \"RefitTrimKnotMode\", \"TextJustification\", \"TextDot\", \"AnnotationBase\", \"InvalidDimensionStyleIdException\", \"ArcCurve\", \"Extrusion\", \"BezierCurve\", \"BezierSurface\", \"Box\", \"PipeCapMode\", \"LoftType\", \"ExtrudeCornerType\", \"BlendType\", \"RailType\", \"BrepEdgeFilletDistance\", \"SweepRebuild\", \"SweepFrame\", \"SweepBlend\", \"SweepMiter\", \"Brep\", \"PointFaceRelation\", \"BrepSolidOrientation\", \"EdgeAdjacency\", \"Concavity\", \"BrepVertex\", \"BrepEdge\", \"BrepTrimType\", \"BrepTrim\", \"BrepLoopType\", \"BrepLoop\", \"BrepFace\", \"BrepRegion\", \"BrepRegionFaceSide\", \"ComponentStatus\", \"CurveProxy\", \"DetailView\", \"LinearDimension\", \"AngularDimension\", \"RadialDimension\", \"Centermark\", \"Hatch\", \"HiddenLineDrawingParameters\", \"HiddenLineDrawing\", \"HiddenLineDrawingObject\", \"HiddenLineDrawingPoint\", \"HiddenLineDrawingObjectCurve\", \"HiddenLineDrawingSegment\", \"InstanceDefinitionGeometry\", \"InstanceReferenceGeometry\", \"Arrowhead\", \"Leader\", \"Light\", \"LineCurve\", \"AreaMassProperties\", \"VolumeMassProperties\", \"LengthMassProperties\", \"Matrix\", \"MeshingParameterStyle\", \"SmoothingCoordinateSystem\", \"MeshCheckParameters\", \"MeshingParameterTextureRange\", \"SubDDisplayParameters\", \"MeshingParameters\", \"MeshPart\", \"MeshThicknessMeasurement\", \"ReduceMeshParameters\", \"QuadRemeshParameters\", \"QuadRemeshSymmetryAxis\", \"ShrinkWrapParameters\", \"Mesh\", \"MeshBooleanOptions\", \"MeshUnsafeLock\", \"MeshFace\", \"MeshNgon\", \"ShutLiningCurveInfo\", \"MeshDisplacementInfo\", \"NurbsSurface\", \"MorphControl\", \"HermiteSurface\", \"PlaneSurface\", \"ClippingPlaneSurface\", \"MeshPoint\", \"SilhouetteType\", \"Silhouette\", \"PointCloudUnsafeLock\", \"PointCloudItem\", \"PointCloud\", \"Point\", \"Point3dGrid\", \"PolyCurve\", \"Polyline\", \"PolylineCurve\", \"Rectangle3d\", \"RevSurface\", \"RTreeEventArgs\", \"RTree\", \"SquishParameters\", \"Squisher\", \"SubDComponent\", \"SubDFace\", \"SubDVertex\", \"SubDEdge\", \"SumSurface\", \"IsoStatus\", \"SurfaceCurvature\", \"Surface\", \"SurfaceProxy\", \"TextRunType\", \"TextEntity\", \"DistancingMode\", \"MeshExtruder\", \"MeshUnwrapper\", \"Interpolator\", \"Particle\", \"ParticleSystem\", \"Arc\", \"BoundingBox\", \"Circle\", \"Cone\", \"BlendContinuity\", \"PreserveEnd\", \"CurveOffsetCornerStyle\", \"CurveOffsetEndStyle\", \"CurveKnotStyle\", \"CurveOrientation\", \"PointContainment\", \"RegionContainment\", \"CurveExtensionStyle\", \"CurveSimplifyOptions\", \"CurveEnd\", \"CurveEvaluationSide\", \"ConicSectionType\", \"CurveBooleanRegions\", \"Curve\", \"RibbonOffsetParameters\", \"RibbonOffsetSurfaceMethod\", \"Cylinder\", \"Ellipse\", \"GeometryBase\", \"Line\", \"Triangle3d\", \"KnotStyle\", \"NurbsCurve\", \"ControlPoint\", \"PlaneFitResult\", \"Plane\", \"Point2f\", \"Point3f\", \"Vector2f\", \"Vector3f\", \"Quaternion\", \"Sphere\", \"Torus\", \"Transform\", \"TransformSimilarityType\", \"TransformRigidType\", \"SpaceMorph\", \"Interval\", \"Point2d\", \"Point3d\", \"Point4d\", \"Vector2d\", \"Vector3d\", \"Ray3d\", \"Continuity\", \"MeshType\", \"LightStyle\", \"ComponentIndexType\", \"ComponentIndex\", \"SurfaceFilletBase\", \"SweepOneRail\", \"SweepTwoRail\", \"Unroller\", \"DevelopableSrf\", \"ForceArrow\", \"ForceText\", \"MeasuredDirection\", \"ExtraordinaryVertexProcessOption\", \"NurbsSurfaceType\", \"InteriorCreaseOption\", \"ConvexCornerOption\", \"ConcaveCornerOption\", \"TextureCoordinateOption\", \"MaximumCounts\", \"ShrinkDisableSide\", \"Visibility\", \"SideFill\", \"Attenuation\", \"Density\", \"NurbsCurveEndConditionType\"]\n# endregion\n\n# region: Imports\nfrom Rhino import ApplicationSettings\nfrom Rhino import Collections\nfrom Rhino import Commands\nfrom Rhino import Display\nfrom Rhino import DocObjects\nfrom Rhino import FileIO\nfrom Rhino import Render\nfrom Rhino import Runtime\nfrom Rhino.Geometry import Collections\nfrom Rhino.Geometry import MeshRefinements\nfrom System import Drawing\nfrom System import Threading\nfrom System.Collections import Generic\nfrom System.Collections import ObjectModel\nfrom System.Collections import Specialized\nfrom System.Runtime import CompilerServices\nfrom System.Runtime import Serialization\nfrom System.Threading import Tasks\nfrom typing import overload\nimport enum\nimport Rhino\nimport System\n# endregion\n\n# region: RhinoCommon, Version=8.19.25132.1001\n\nclass AnnotationType(enum.Enum):\n    Unset = 0\n    Aligned = 1\n    Angular = 2\n    Diameter = 3\n    Radius = 4\n    Rotated = 5\n    Ordinate = 6\n    ArcLen = 7\n    CenterMark = 8\n    Text = 9\n    Leader = 10\n    Angular3pt = 11\n\nclass Dimension(AnnotationBase):\n    \"\"\"Base class for dimensions\n\n    \"\"\"\n    @overload\n    def Explode() -> System.Array[GeometryBase]: ...\n    @property\n    def AlternateBelowLine(self) -> bool: ...\n    @property\n    def AltLengthFactor(self) -> float: ...\n    @property\n    def AltLengthResolution(self) -> int: ...\n    @property\n    def AltLengthRoundoff(self) -> float: ...\n    @property\n    def AltPrefix(self) -> str: ...\n    @property\n    def AltSuffix(self) -> str: ...\n    @property\n    def AltToleranceResolution(self) -> int: ...\n    @property\n    def AltUnitsDisplay(self) -> bool: ...\n    @property\n    def AltZeroSuppression(self) -> DocObjects.ZeroSuppression: ...\n    @property\n    def ArrowBlockId1(self) -> System.Guid: ...\n    @property\n    def ArrowBlockId2(self) -> System.Guid: ...\n    @property\n    def ArrowFit(self) -> DocObjects.ArrowFit: ...\n    @property\n    def ArrowheadType1(self) -> DocObjects.ArrowType: ...\n    @property\n    def ArrowheadType2(self) -> DocObjects.ArrowType: ...\n    @property\n    def ArrowSize(self) -> float: ...\n    @property\n    def BaselineSpacing(self) -> float: ...\n    @property\n    def CentermarkSize(self) -> float: ...\n    @property\n    def CentermarkStyle(self) -> DocObjects.CenterMarkStyle: ...\n    @property\n    def DetailMeasured(self) -> System.Guid: ...\n    @property\n    def DimensionLineExtension(self) -> float: ...\n    @property\n    def DistanceScale(self) -> float: ...\n    @property\n    def ExtensionLineExtension(self) -> float: ...\n    @property\n    def ExtensionLineOffset(self) -> float: ...\n    @property\n    def FixedExtensionLength(self) -> float: ...\n    @property\n    def FixedLengthExtensionOn(self) -> bool: ...\n    @property\n    def ForceArrowPosition(self) -> ForceArrow: ...\n    @property\n    def ForceDimensionLineBetweenExtensionLines(self) -> bool: ...\n    @property\n    def ForceDimLine(self) -> bool: ...\n    @property\n    def ForceTextPosition(self) -> ForceText: ...\n    @property\n    def LengthFactor(self) -> float: ...\n    @property\n    def LengthResolution(self) -> int: ...\n    @property\n    def LengthRoundoff(self) -> float: ...\n    @property\n    def NumericValue(self) -> float: ...\n    @property\n    def PlainUserText(self) -> str: ...\n    @property\n    def Prefix(self) -> str: ...\n    @property\n    def Suffix(self) -> str: ...\n    @property\n    def SuppressExtension1(self) -> bool: ...\n    @property\n    def SuppressExtension2(self) -> bool: ...\n    @property\n    def TextAngleType(self) -> DocObjects.LeaderContentAngleStyle: ...\n    @property\n    def TextFit(self) -> DocObjects.TextFit: ...\n    @property\n    def TextFormula(self) -> str: ...\n    @property\n    def TextLocation(self) -> DocObjects.TextLocation: ...\n    @property\n    def TextOrientation(self) -> DocObjects.TextOrientation: ...\n    @property\n    def TextPosition(self) -> Point2d: ...\n    @property\n    def TextRotation(self) -> float: ...\n    @property\n    def ToleranceFormat(self) -> DocObjects.ToleranceDisplayFormat: ...\n    @property\n    def ToleranceHeightScale(self) -> float: ...\n    @property\n    def ToleranceLowerValue(self) -> float: ...\n    @property\n    def ToleranceResolution(self) -> int: ...\n    @property\n    def ToleranceUpperValue(self) -> float: ...\n    @property\n    def UseDefaultTextPoint(self) -> bool: ...\n    @property\n    def ZeroSuppression(self) -> DocObjects.ZeroSuppression: ...\n    @overload\n    def GetTextTransform(self, viewport: DocObjects.ViewportInfo, style: DocObjects.DimensionStyle, textScale: float, drawForward: bool) -> Transform: ...\n    @AlternateBelowLine.setter\n    def AlternateBelowLine(self, value: System.Void): ...\n    @AltLengthFactor.setter\n    def AltLengthFactor(self, value: System.Void): ...\n    @AltLengthResolution.setter\n    def AltLengthResolution(self, value: System.Void): ...\n    @AltLengthRoundoff.setter\n    def AltLengthRoundoff(self, value: System.Void): ...\n    @AltPrefix.setter\n    def AltPrefix(self, value: System.Void): ...\n    @AltSuffix.setter\n    def AltSuffix(self, value: System.Void): ...\n    @AltToleranceResolution.setter\n    def AltToleranceResolution(self, value: System.Void): ...\n    @AltUnitsDisplay.setter\n    def AltUnitsDisplay(self, value: System.Void): ...\n    @AltZeroSuppression.setter\n    def AltZeroSuppression(self, value: System.Void): ...\n    @ArrowBlockId1.setter\n    def ArrowBlockId1(self, value: System.Void): ...\n    @ArrowBlockId2.setter\n    def ArrowBlockId2(self, value: System.Void): ...\n    @ArrowFit.setter\n    def ArrowFit(self, value: System.Void): ...\n    @ArrowheadType1.setter\n    def ArrowheadType1(self, value: System.Void): ...\n    @ArrowheadType2.setter\n    def ArrowheadType2(self, value: System.Void): ...\n    @ArrowSize.setter\n    def ArrowSize(self, value: System.Void): ...\n    @BaselineSpacing.setter\n    def BaselineSpacing(self, value: System.Void): ...\n    @CentermarkSize.setter\n    def CentermarkSize(self, value: System.Void): ...\n    @CentermarkStyle.setter\n    def CentermarkStyle(self, value: System.Void): ...\n    @DetailMeasured.setter\n    def DetailMeasured(self, value: System.Void): ...\n    @DimensionLineExtension.setter\n    def DimensionLineExtension(self, value: System.Void): ...\n    @DistanceScale.setter\n    def DistanceScale(self, value: System.Void): ...\n    @ExtensionLineExtension.setter\n    def ExtensionLineExtension(self, value: System.Void): ...\n    @ExtensionLineOffset.setter\n    def ExtensionLineOffset(self, value: System.Void): ...\n    @FixedExtensionLength.setter\n    def FixedExtensionLength(self, value: System.Void): ...\n    @FixedLengthExtensionOn.setter\n    def FixedLengthExtensionOn(self, value: System.Void): ...\n    @ForceArrowPosition.setter\n    def ForceArrowPosition(self, value: System.Void): ...\n    @ForceDimensionLineBetweenExtensionLines.setter\n    def ForceDimensionLineBetweenExtensionLines(self, value: System.Void): ...\n    @ForceDimLine.setter\n    def ForceDimLine(self, value: System.Void): ...\n    @ForceTextPosition.setter\n    def ForceTextPosition(self, value: System.Void): ...\n    @LengthFactor.setter\n    def LengthFactor(self, value: System.Void): ...\n    @LengthResolution.setter\n    def LengthResolution(self, value: System.Void): ...\n    @LengthRoundoff.setter\n    def LengthRoundoff(self, value: System.Void): ...\n    @Prefix.setter\n    def Prefix(self, value: System.Void): ...\n    @Suffix.setter\n    def Suffix(self, value: System.Void): ...\n    @SuppressExtension1.setter\n    def SuppressExtension1(self, value: System.Void): ...\n    @SuppressExtension2.setter\n    def SuppressExtension2(self, value: System.Void): ...\n    @TextAngleType.setter\n    def TextAngleType(self, value: System.Void): ...\n    @TextFit.setter\n    def TextFit(self, value: System.Void): ...\n    @TextFormula.setter\n    def TextFormula(self, value: System.Void): ...\n    @TextLocation.setter\n    def TextLocation(self, value: System.Void): ...\n    @TextOrientation.setter\n    def TextOrientation(self, value: System.Void): ...\n    @TextPosition.setter\n    def TextPosition(self, value: System.Void): ...\n    @TextRotation.setter\n    def TextRotation(self, value: System.Void): ...\n    @ToleranceFormat.setter\n    def ToleranceFormat(self, value: System.Void): ...\n    @ToleranceHeightScale.setter\n    def ToleranceHeightScale(self, value: System.Void): ...\n    @ToleranceLowerValue.setter\n    def ToleranceLowerValue(self, value: System.Void): ...\n    @ToleranceResolution.setter\n    def ToleranceResolution(self, value: System.Void): ...\n    @ToleranceUpperValue.setter\n    def ToleranceUpperValue(self, value: System.Void): ...\n    @UseDefaultTextPoint.setter\n    def UseDefaultTextPoint(self, value: System.Void): ...\n    @ZeroSuppression.setter\n    def ZeroSuppression(self, value: System.Void): ...\n    @overload\n    def SetAltDimensionLengthDisplayWithZeroSuppressionReset(self, ld: DocObjects.LengthDisplay) -> None: ...\n    @overload\n    def SetDimensionLengthDisplayWithZeroSuppressionReset(self, ld: DocObjects.LengthDisplay) -> None: ...\n    @overload\n    def UpdateDimensionText(self, style: DocObjects.DimensionStyle, units: Rhino.UnitSystem) -> None: ...\n\nclass OrdinateDimension(Dimension):\n    \"\"\"Represents an ordinate dimension\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, plane: Plane, direction: MeasuredDirection, basepoint: Point3d, defpoint: Point3d, leaderpoint: Point3d, kinkoffset1: float, kinkoffset2: float): ...\n    @overload\n    def AdjustFromPoints(self, plane: Plane, direction: MeasuredDirection, basepoint: Point3d, defpoint: Point3d, leaderpoint: Point3d, kinkoffset1: float, kinkoffset2: float) -> bool: ...\n    @overload\n    @staticmethod\n    def Create(dimStyle: DocObjects.DimensionStyle, plane: Plane, direction: MeasuredDirection, basepoint: Point3d, defpoint: Point3d, leaderpoint: Point3d, kinkoffset1: float, kinkoffset2: float) -> OrdinateDimension: ...\n    @property\n    def DefPoint(self) -> Point2d: ...\n    @property\n    def Direction(self) -> MeasuredDirection: ...\n    @property\n    def KinkOffset1(self) -> float: ...\n    @property\n    def KinkOffset2(self) -> float: ...\n    @property\n    def KinkPoint1(self) -> Point2d: ...\n    @property\n    def KinkPoint2(self) -> Point2d: ...\n    @property\n    def LeaderPoint(self) -> Point2d: ...\n    @overload\n    def Get3dPoints() -> (bool, Point3d, Point3d, Point3d, Point3d, Point3d): ...\n    @overload\n    def GetDisplayLines(self, style: DocObjects.DimensionStyle, scale: float) -> (bool, Generic.IEnumerable): ...\n    @overload\n    def GetDistanceDisplayText(self, unitsystem: Rhino.UnitSystem, style: DocObjects.DimensionStyle) -> str: ...\n    @overload\n    def GetTextRectangle() -> (bool, System.Array[Point3d]): ...\n    @DefPoint.setter\n    def DefPoint(self, value: System.Void): ...\n    @Direction.setter\n    def Direction(self, value: System.Void): ...\n    @KinkOffset1.setter\n    def KinkOffset1(self, value: System.Void): ...\n    @KinkOffset2.setter\n    def KinkOffset2(self, value: System.Void): ...\n    @LeaderPoint.setter\n    def LeaderPoint(self, value: System.Void): ...\n\nclass SubDComponentLocation(enum.Enum):\n    Unset = 0\n    ControlNet = 1\n    Surface = 2\n\nclass SubDVertexTag(enum.Enum):\n    Unset = 0\n    Smooth = 1\n    Crease = 2\n    Corner = 3\n    Dart = 4\n\nclass SubDEdgeTag(enum.Enum):\n    Unset = 0\n    Smooth = 1\n    Crease = 2\n    SmoothX = 4\n\nclass SubDEdgeType(enum.Enum):\n    Unset = 0\n    Wire = 1\n    Boundary = 2\n    InteriorSmooth = 4\n    InteriorSharp = 8\n    InteriorCrease = 16\n    InteriorMask = 28\n    Nonmanifold = 32\n    ValidTypesMask = 63\n    Invalid = 64\n\nclass SubDHashType(enum.Enum):\n    Unset = 0\n    TopologyAndEdgeCreases = 1\n    Geometry = 2\n    Topology = 3\n\nclass SubDToBrepOptions(object):\n    \"\"\"Options used for converting a SubD to a Brep\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, packFaces: bool, vertexProcess: ExtraordinaryVertexProcessOption): ...\n    @overload\n    def Dispose() -> None: ...\n    @property\n    def Default(self) -> SubDToBrepOptions: ...\n    @property\n    def DefaultPacked(self) -> SubDToBrepOptions: ...\n    @property\n    def DefaultUnpacked(self) -> SubDToBrepOptions: ...\n    @property\n    def ExtraordinaryVertexProcess(self) -> ExtraordinaryVertexProcessOption: ...\n    @property\n    def PackFaces(self) -> bool: ...\n    @ExtraordinaryVertexProcess.setter\n    def ExtraordinaryVertexProcess(self, value: System.Void): ...\n    @PackFaces.setter\n    def PackFaces(self, value: System.Void): ...\n\nclass SubDFromSurfaceMethods(enum.Enum):\n    Unset = 0\n    SubDFriendlyFit = 1\n    FromNurbsControlNet = 2\n\nclass SubDEndCapStyle(enum.Enum):\n    Unset = 0\n    None_ = 1\n    Triangles = 2\n    Quads = 3\n    Ngon = 4\n\nclass SubDVertexFacetType(enum.Enum):\n    Unset = 0\n    Tri = 3\n    Quad = 4\n    Ngon = 5\n    Mixed = 255\n\nclass SubDChainType(enum.Enum):\n    Unset = 0\n    MixedTag = 1\n    EqualEdgeTag = 2\n    EqualEdgeAndVertexTag = 3\n    EqualEdgeTagAndOrdinary = 4\n    EqualEdgeAndVertexTagAndOrdinary = 5\n\nclass SubDFriendlyKnotType(enum.Enum):\n    Unset = 0\n    UnclampedUniform = 1\n    ClampedUniform = 2\n    ClampedPiecewiseUniform = 4\n    Unfriendly = 127\n\nclass SubDAutomaticMeshToSubDContext(enum.Enum):\n    Unset = 0\n    Rhino5BoxModeTSpline = 1\n    FBXMeshWithDivisionLevels = 2\n\nclass SubDPatchStyle(enum.Enum):\n    Unset = 0\n    Automatic = 1\n    SingleFace = 2\n    TriangleFan = 3\n    QuadOrTriangleFan = 4\n    Triangulated = 5\n\nclass SubD(GeometryBase):\n    \"\"\"Subdivision surface\n\n    \"\"\"\n    def __init__(self): ...\n    @overload\n    def ClearEvaluationCache() -> None: ...\n    @overload\n    def ComponentFromComponentIndex(self, componentIndex: ComponentIndex) -> SubDComponent: ...\n    @overload\n    def CopyEvaluationCache() -> (bool, SubD): ...\n    @overload\n    @staticmethod\n    def CreateFromCylinder(cylinder: Cylinder, circumferenceFaceCount: System.UInt32, heightFaceCount: System.UInt32, endCapStyle: SubDEndCapStyle, endCapEdgeTag: SubDEdgeTag, radiusLocation: SubDComponentLocation) -> SubD: ...\n    @overload\n    @staticmethod\n    def CreateFromLoft(curves: Generic.IEnumerable, closed: bool, addCorners: bool, addCreases: bool, divisions: int) -> SubD: ...\n    @overload\n    @staticmethod\n    def CreateFromMesh(mesh: Mesh) -> SubD: ...\n    @overload\n    @staticmethod\n    def CreateFromMesh(mesh: Mesh, options: SubDCreationOptions) -> SubD: ...\n    @overload\n    @staticmethod\n    def CreateFromSurface(surface: Surface, method: SubDFromSurfaceMethods, corners: bool) -> SubD: ...\n    @overload\n    @staticmethod\n    def CreateFromSweep(rail1: NurbsCurve, rail2: NurbsCurve, shapes: Generic.IEnumerable, closed: bool, addCorners: bool) -> SubD: ...\n    @overload\n    @staticmethod\n    def CreateFromSweep(rail1: NurbsCurve, shapes: Generic.IEnumerable, closed: bool, addCorners: bool, roadlikeFrame: bool, roadlikeNormal: Vector3d) -> SubD: ...\n    @overload\n    @staticmethod\n    def CreateGlobeSphere(sphere: Sphere, vertexLocation: SubDComponentLocation, axialFaceCount: System.UInt32, equatorialFaceCount: System.UInt32) -> SubD: ...\n    @overload\n    @staticmethod\n    def CreateIcosahedron(sphere: Sphere, vertexLocation: SubDComponentLocation) -> SubD: ...\n    @overload\n    @staticmethod\n    def CreateQuadSphere(sphere: Sphere, vertexLocation: SubDComponentLocation, quadSubdivisionLevel: System.UInt32) -> SubD: ...\n    @overload\n    @staticmethod\n    def CreateTriSphere(sphere: Sphere, vertexLocation: SubDComponentLocation, triSubdivisionLevel: System.UInt32) -> SubD: ...\n    @overload\n    def DuplicateEdgeCurves() -> System.Array[Curve]: ...\n    @overload\n    def DuplicateEdgeCurves(self, boundaryOnly: bool, interiorOnly: bool, smoothOnly: bool, sharpOnly: bool, creaseOnly: bool, clampEnds: bool) -> System.Array[Curve]: ...\n    @overload\n    def Flip() -> bool: ...\n    @property\n    def Edges(self) -> Collections.SubDEdgeList: ...\n    @property\n    def Empty(self) -> SubD: ...\n    @property\n    def Faces(self) -> Collections.SubDFaceList: ...\n    @property\n    def IsSolid(self) -> bool: ...\n    @property\n    def Vertices(self) -> Collections.SubDVertexList: ...\n    @overload\n    def InterpolateSurfacePoints(self, surfacePoints: System.Array[Point3d]) -> bool: ...\n    @overload\n    def InterpolateSurfacePoints(self, vertexIndices: System.System.Array[System.UInt32], surfacePoints: System.Array[Point3d]) -> bool: ...\n    @overload\n    @staticmethod\n    def JoinSubDs(subdsToJoin: Generic.IEnumerable, tolerance: float, joinedEdgesAreCreases: bool) -> System.Array[SubD]: ...\n    @overload\n    @staticmethod\n    def JoinSubDs(subdsToJoin: Generic.IEnumerable, tolerance: float, joinedEdgesAreCreases: bool, preserveSymmetry: bool) -> System.Array[SubD]: ...\n    @overload\n    def MergeAllCoplanarFaces(self, tolerance: float) -> bool: ...\n    @overload\n    def MergeAllCoplanarFaces(self, tolerance: float, angleTolerance: float) -> bool: ...\n    @overload\n    def Offset(self, distance: float, solidify: bool) -> SubD: ...\n    @overload\n    def PackFaces() -> System.UInt32: ...\n    @overload\n    def SetVertexSurfacePoint(self, vertexIndex: System.UInt32, surfacePoint: Point3d) -> bool: ...\n    @overload\n    def Subdivide() -> bool: ...\n    @overload\n    def Subdivide(self, count: int) -> bool: ...\n    @overload\n    def Subdivide(self, faceIndices: Generic.IEnumerable) -> bool: ...\n    @overload\n    def SurfaceMeshCacheExists(self, bTextureCoordinatesExist: bool, bCurvaturesExist: bool, bColorsExist: bool) -> bool: ...\n    @overload\n    def ToBrep() -> Brep: ...\n    @overload\n    def ToBrep(self, options: SubDToBrepOptions) -> Brep: ...\n    @overload\n    def TransformComponents(self, components: Generic.IEnumerable, xform: Transform, componentLocation: SubDComponentLocation) -> System.UInt32: ...\n    @overload\n    def UpdateAllTagsAndSectorCoefficients() -> System.UInt32: ...\n    @overload\n    def UpdateSurfaceMeshCache(self, lazyUpdate: bool) -> System.UInt32: ...\n\nclass SubDCreationOptions(object):\n    \"\"\"Options used for creating a SubD\n\n    \"\"\"\n    def __init__(self): ...\n    @overload\n    def Dispose() -> None: ...\n    @property\n    def ConcaveCornerTest(self) -> ConcaveCornerOption: ...\n    @property\n    def ConvexAndConcaveCornersAndInteriorCreases(self) -> SubDCreationOptions: ...\n    @property\n    def ConvexCornersAndInteriorCreases(self) -> SubDCreationOptions: ...\n    @property\n    def ConvexCornerTest(self) -> ConvexCornerOption: ...\n    @property\n    def InteriorCreases(self) -> SubDCreationOptions: ...\n    @property\n    def InteriorCreaseTest(self) -> InteriorCreaseOption: ...\n    @property\n    def InterpolateMeshVertices(self) -> bool: ...\n    @property\n    def MaximumConvexCornerAngleRadians(self) -> float: ...\n    @property\n    def MaximumConvexCornerEdgeCount(self) -> System.UInt32: ...\n    @property\n    def MinimumConcaveCornerAngleRadians(self) -> float: ...\n    @property\n    def MinimumConcaveCornerEdgeCount(self) -> System.UInt32: ...\n    @property\n    def Smooth(self) -> SubDCreationOptions: ...\n    @ConcaveCornerTest.setter\n    def ConcaveCornerTest(self, value: System.Void): ...\n    @ConvexCornerTest.setter\n    def ConvexCornerTest(self, value: System.Void): ...\n    @InteriorCreaseTest.setter\n    def InteriorCreaseTest(self, value: System.Void): ...\n    @InterpolateMeshVertices.setter\n    def InterpolateMeshVertices(self, value: System.Void): ...\n    @MaximumConvexCornerAngleRadians.setter\n    def MaximumConvexCornerAngleRadians(self, value: System.Void): ...\n    @MaximumConvexCornerEdgeCount.setter\n    def MaximumConvexCornerEdgeCount(self, value: System.Void): ...\n    @MinimumConcaveCornerAngleRadians.setter\n    def MinimumConcaveCornerAngleRadians(self, value: System.Void): ...\n    @MinimumConcaveCornerEdgeCount.setter\n    def MinimumConcaveCornerEdgeCount(self, value: System.Void): ...\n\nclass SubDSurfaceInterpolator(object):\n    \"\"\"Interpolate some or all of the vertices limit surface positions in a SubD to specified locations. NB: It is recommended not to use these methods to interpolate more than 1000 vertices.\n\n    \"\"\"\n    def __init__(self): ...\n    @overload\n    def Clear() -> None: ...\n    @overload\n    @staticmethod\n    def CreateFromMarkedVertices(subd: SubD, interpolatedVerticesMark: bool) -> (SubDSurfaceInterpolator, System.UInt32): ...\n    @overload\n    @staticmethod\n    def CreateFromSelectedVertices(subd: SubD) -> (SubDSurfaceInterpolator, System.UInt32): ...\n    @overload\n    @staticmethod\n    def CreateFromSubD(subd: SubD) -> (SubDSurfaceInterpolator, System.UInt32): ...\n    @overload\n    @staticmethod\n    def CreateFromVertexIdList(subd: SubD, vertexIndices: Generic.IEnumerable) -> (SubDSurfaceInterpolator, System.UInt32): ...\n    @overload\n    def Dispose() -> None: ...\n    @overload\n    def FixedVertexCount() -> System.UInt32: ...\n    @property\n    def ContextId(self) -> System.Guid: ...\n    @property\n    def MaximumRecommendedInterpolatedVertexCount(self) -> System.UInt32: ...\n    @overload\n    def InterpolatedVertexCount() -> System.UInt32: ...\n    @overload\n    def InterpolatedVertexIndex(self, vertexId: System.UInt32) -> System.UInt32: ...\n    @overload\n    def IsInterpolatedVertex(self, vertexId: System.UInt32) -> bool: ...\n    @overload\n    def IsInterpolatedVertex(self, vertex: SubDVertex) -> bool: ...\n    @ContextId.setter\n    def ContextId(self, value: System.Void): ...\n    @overload\n    def Solve(self, surfacePoints: System.Array[Point3d]) -> bool: ...\n    @overload\n    def Transform(self, transform: Transform) -> None: ...\n    @overload\n    def VertexIdList() -> System.System.Array[System.UInt32]: ...\n\nclass MeshPipeCapStyle(enum.Enum):\n    None_ = 0\n    Flat = 1\n    Box = 2\n    Dome = 3\n\nclass MeshExtruderParameterMode(enum.Enum):\n    CoverWalls = 0\n    KeepAndStretch = 1\n\nclass MeshExtruderFaceDirectionMode(enum.Enum):\n    Keep = 0\n    OrientClosedFrontOut = 1\n\nclass MeshUnwrapMethod(enum.Enum):\n    LSCM = 0\n    ABFPP = 1\n    ARAP = 2\n\nclass SquishDeformation(enum.Enum):\n    Free = 0\n    StretchMostly = 1\n    StretchOnly = 2\n    CompressMostly = 3\n    CompressOnly = 4\n    Custom = 5\n\nclass SquishFlatteningAlgorithm(enum.Enum):\n    Geometric = 0\n    PhysicalStress = 1\n\nclass FilletSurfaceSplitType(enum.Enum):\n    Nothing = 0\n    Trim = 1\n    Split = 2\n\nclass RefitTrimSectionMode(enum.Enum):\n    NoSections = 0\n    DivideAtInputKnots = 1\n    DivideAtAddedKnots = 2\n    DivideAtAllKnots = 3\n\nclass RefitTrimKnotMode(enum.Enum):\n    None_ = 0\n    UniformEntireSurface = 1\n    UniformPerSpan = 2\n    Custom = 3\n\nclass TextJustification(enum.Enum):\n    None_ = 0\n    Left = 1\n    Center = 2\n    Right = 4\n    Bottom = 65536\n    BottomLeft = 65537\n    BottomCenter = 65538\n    BottomRight = 65540\n    Middle = 131072\n    MiddleLeft = 131073\n    MiddleCenter = 131074\n    MiddleRight = 131076\n    Top = 262144\n    TopLeft = 262145\n    TopCenter = 262146\n    TopRight = 262148\n\nclass TextDot(GeometryBase):\n    \"\"\"Represents a text dot, or an annotation entity with text that always faces the camera and always has the same size.\nThis class refers to the geometric element that is independent from the document.\n\n    \"\"\"\n    def __init__(self, text: str, location: Point3d): ...\n    @property\n    def FontFace(self) -> str: ...\n    @property\n    def FontHeight(self) -> int: ...\n    @property\n    def Point(self) -> Point3d: ...\n    @property\n    def SecondaryText(self) -> str: ...\n    @property\n    def Text(self) -> str: ...\n    @FontFace.setter\n    def FontFace(self, value: System.Void): ...\n    @FontHeight.setter\n    def FontHeight(self, value: System.Void): ...\n    @Point.setter\n    def Point(self, value: System.Void): ...\n    @SecondaryText.setter\n    def SecondaryText(self, value: System.Void): ...\n    @Text.setter\n    def Text(self, value: System.Void): ...\n\nclass AnnotationBase(GeometryBase):\n    \"\"\"Provides a common base class to all annotation geometry.\nThis class refers to the geometric element that is independent from the document.\n\n    \"\"\"\n    @overload\n    def ClearPropertyOverrides() -> bool: ...\n    @overload\n    @staticmethod\n    def FirstCharProperties(rtf_str: str) -> (bool, bool, bool, bool, str): ...\n    @overload\n    @staticmethod\n    def FormatRtfString(rtf_in: str, clear_bold: bool, set_bold: bool, clear_italic: bool, set_italic: bool, clear_underline: bool, set_underline: bool, clear_facename: bool, set_facename: bool, facename: str) -> str: ...\n    @property\n    def AlternateDimensionLengthDisplay(self) -> DocObjects.LengthDisplay: ...\n    @property\n    def AnnotationType(self) -> AnnotationType: ...\n    @property\n    def DecimalSeparator(self) -> System.Char: ...\n    @property\n    def DimensionLengthDisplay(self) -> DocObjects.LengthDisplay: ...\n    @property\n    def DimensionScale(self) -> float: ...\n    @property\n    def DimensionStyle(self) -> DocObjects.DimensionStyle: ...\n    @property\n    def DimensionStyleId(self) -> System.Guid: ...\n    @property\n    def DrawForward(self) -> bool: ...\n    @property\n    def DrawTextFrame(self) -> bool: ...\n    @property\n    def FirstCharFont(self) -> DocObjects.Font: ...\n    @property\n    def Font(self) -> DocObjects.Font: ...\n    @property\n    def FontIndex(self) -> int: ...\n    @property\n    def FormatWidth(self) -> float: ...\n    @property\n    def HasPropertyOverrides(self) -> bool: ...\n    @property\n    def MaskColor(self) -> Drawing.Color: ...\n    @property\n    def MaskColorSource(self) -> DocObjects.MaskType: ...\n    @property\n    def MaskEnabled(self) -> bool: ...\n    @property\n    def MaskFrame(self) -> DocObjects.MaskFrame: ...\n    @property\n    def MaskOffset(self) -> float: ...\n    @property\n    def MaskUsesViewportColor(self) -> bool: ...\n    @property\n    def ParentDimensionStyle(self) -> DocObjects.DimensionStyle: ...\n    @property\n    def PlainText(self) -> str: ...\n    @property\n    def PlainTextWithFields(self) -> str: ...\n    @property\n    def Plane(self) -> Plane: ...\n    @property\n    def RichText(self) -> str: ...\n    @property\n    def Text(self) -> str: ...\n    @property\n    def TextFormula(self) -> str: ...\n    @property\n    def TextHasRtfFormatting(self) -> bool: ...\n    @property\n    def TextHeight(self) -> float: ...\n    @property\n    def TextIsWrapped(self) -> bool: ...\n    @property\n    def TextModelWidth(self) -> float: ...\n    @property\n    def TextRotationDegrees(self) -> float: ...\n    @property\n    def TextRotationRadians(self) -> float: ...\n    @overload\n    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...\n    @overload\n    @staticmethod\n    def GetDimensionScale(doc: Rhino.RhinoDoc, dimstyle: DocObjects.DimensionStyle, vport: Display.RhinoViewport) -> float: ...\n    @overload\n    def GetDimensionStyle(self, parentDimStyle: DocObjects.DimensionStyle) -> DocObjects.DimensionStyle: ...\n    @overload\n    def GetPlainTextWithRunMap() -> (str, System.System.Array[int]): ...\n    @overload\n    def IsAllBold() -> bool: ...\n    @overload\n    def IsAllItalic() -> bool: ...\n    @overload\n    def IsAllUnderlined() -> bool: ...\n    @overload\n    def IsPropertyOverridden(self, field: DocObjects.Field) -> bool: ...\n    @overload\n    @staticmethod\n    def PlainTextToRtf(str_: str) -> str: ...\n    @overload\n    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...\n    @AlternateDimensionLengthDisplay.setter\n    def AlternateDimensionLengthDisplay(self, value: System.Void): ...\n    @DecimalSeparator.setter\n    def DecimalSeparator(self, value: System.Void): ...\n    @DimensionLengthDisplay.setter\n    def DimensionLengthDisplay(self, value: System.Void): ...\n    @DimensionScale.setter\n    def DimensionScale(self, value: System.Void): ...\n    @DimensionStyleId.setter\n    def DimensionStyleId(self, value: System.Void): ...\n    @DrawForward.setter\n    def DrawForward(self, value: System.Void): ...\n    @DrawTextFrame.setter\n    def DrawTextFrame(self, value: System.Void): ...\n    @Font.setter\n    def Font(self, value: System.Void): ...\n    @FontIndex.setter\n    def FontIndex(self, value: System.Void): ...\n    @FormatWidth.setter\n    def FormatWidth(self, value: System.Void): ...\n    @MaskColor.setter\n    def MaskColor(self, value: System.Void): ...\n    @MaskColorSource.setter\n    def MaskColorSource(self, value: System.Void): ...\n    @MaskEnabled.setter\n    def MaskEnabled(self, value: System.Void): ...\n    @MaskFrame.setter\n    def MaskFrame(self, value: System.Void): ...\n    @MaskOffset.setter\n    def MaskOffset(self, value: System.Void): ...\n    @MaskUsesViewportColor.setter\n    def MaskUsesViewportColor(self, value: System.Void): ...\n    @ParentDimensionStyle.setter\n    def ParentDimensionStyle(self, value: System.Void): ...\n    @PlainText.setter\n    def PlainText(self, value: System.Void): ...\n    @Plane.setter\n    def Plane(self, value: System.Void): ...\n    @RichText.setter\n    def RichText(self, value: System.Void): ...\n    @Text.setter\n    def Text(self, value: System.Void): ...\n    @TextFormula.setter\n    def TextFormula(self, value: System.Void): ...\n    @TextHeight.setter\n    def TextHeight(self, value: System.Void): ...\n    @TextIsWrapped.setter\n    def TextIsWrapped(self, value: System.Void): ...\n    @TextRotationDegrees.setter\n    def TextRotationDegrees(self, value: System.Void): ...\n    @TextRotationRadians.setter\n    def TextRotationRadians(self, value: System.Void): ...\n    @overload\n    def SetBold(self, set_on: bool) -> bool: ...\n    @overload\n    def SetFacename(self, set_on: bool, facename: str) -> bool: ...\n    @overload\n    def SetItalic(self, set_on: bool) -> bool: ...\n    @overload\n    def SetOverrideDimStyle(self, OverrideStyle: DocObjects.DimensionStyle) -> bool: ...\n    @overload\n    def SetRichText(self, rtfText: str, dimstyle: DocObjects.DimensionStyle) -> None: ...\n    @overload\n    def SetUnderline(self, set_on: bool) -> bool: ...\n    @overload\n    def WrapText() -> None: ...\n\nclass InvalidDimensionStyleIdException(System.InvalidOperationException):\n    \"\"\"General exception that can be thrown by annotations\n\n    \"\"\"\n    def __init__(self, msg: str): ...\n\nclass ArcCurve(Curve):\n    \"\"\"Represent arcs and circles.\nArcCurve.IsCircle returns true if the curve is a complete circle.\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, other: ArcCurve): ...\n    @overload\n    def __init__(self, arc: Arc): ...\n    @overload\n    def __init__(self, circle: Circle): ...\n    @overload\n    def __init__(self, arc: Arc, t0: float, t1: float): ...\n    @overload\n    def __init__(self, circle: Circle, t0: float, t1: float): ...\n    @property\n    def AngleDegrees(self) -> float: ...\n    @property\n    def AngleRadians(self) -> float: ...\n    @property\n    def Arc(self) -> Arc: ...\n    @property\n    def IsCompleteCircle(self) -> bool: ...\n    @property\n    def Radius(self) -> float: ...\n\nclass Extrusion(Surface):\n    \"\"\"Represents an extrusion, or objects such as beams or linearly extruded elements, that can be represented by profile curves and two miter planes at the extremes.\n\n    \"\"\"\n    def __init__(self): ...\n    @overload\n    def AddInnerProfile(self, innerProfile: Curve) -> bool: ...\n    @overload\n    @staticmethod\n    def Create(planarCurve: Curve, height: float, cap: bool) -> Extrusion: ...\n    @overload\n    @staticmethod\n    def Create(curve: Curve, plane: Plane, height: float, cap: bool) -> Extrusion: ...\n    @overload\n    @staticmethod\n    def CreateBoxExtrusion(box: Box, cap: bool) -> Extrusion: ...\n    @overload\n    @staticmethod\n    def CreateCylinderExtrusion(cylinder: Cylinder, capBottom: bool, capTop: bool) -> Extrusion: ...\n    @overload\n    @staticmethod\n    def CreatePipeExtrusion(cylinder: Cylinder, otherRadius: float, capTop: bool, capBottom: bool) -> Extrusion: ...\n    @property\n    def CapCount(self) -> int: ...\n    @property\n    def IsCappedAtBottom(self) -> bool: ...\n    @property\n    def IsCappedAtTop(self) -> bool: ...\n    @property\n    def IsMiteredAtEnd(self) -> bool: ...\n    @property\n    def IsMiteredAtStart(self) -> bool: ...\n    @property\n    def IsSolid(self) -> bool: ...\n    @property\n    def MiterPlaneNormalAtEnd(self) -> Vector3d: ...\n    @property\n    def MiterPlaneNormalAtStart(self) -> Vector3d: ...\n    @property\n    def PathEnd(self) -> Point3d: ...\n    @property\n    def PathStart(self) -> Point3d: ...\n    @property\n    def PathTangent(self) -> Vector3d: ...\n    @property\n    def ProfileCount(self) -> int: ...\n    @overload\n    def GetBrepFormComponentIndex(self, extrusionComponentIndex: ComponentIndex) -> ComponentIndex: ...\n    @overload\n    def GetMesh(self, meshType: MeshType) -> Mesh: ...\n    @overload\n    def GetPathPlane(self, s: float) -> Plane: ...\n    @overload\n    def GetProfilePlane(self, s: float) -> Plane: ...\n    @overload\n    def GetProfileTransformation(self, s: float) -> Transform: ...\n    @overload\n    def GetWireframe() -> System.Array[Curve]: ...\n    @overload\n    def PathLineCurve() -> LineCurve: ...\n    @overload\n    def Profile3d(self, ci: ComponentIndex) -> Curve: ...\n    @overload\n    def Profile3d(self, profileIndex: int, s: float) -> Curve: ...\n    @overload\n    def ProfileIndex(self, profileParameter: float) -> int: ...\n    @MiterPlaneNormalAtEnd.setter\n    def MiterPlaneNormalAtEnd(self, value: System.Void): ...\n    @MiterPlaneNormalAtStart.setter\n    def MiterPlaneNormalAtStart(self, value: System.Void): ...\n    @overload\n    def SetMesh(self, mesh: Mesh, meshType: MeshType) -> bool: ...\n    @overload\n    def SetOuterProfile(self, outerProfile: Curve, cap: bool) -> bool: ...\n    @overload\n    def SetPathAndUp(self, a: Point3d, b: Point3d, up: Vector3d) -> bool: ...\n    @overload\n    def ToBrep(self, splitKinkyFaces: bool) -> Brep: ...\n    @overload\n    def WallEdge(self, ci: ComponentIndex) -> Curve: ...\n    @overload\n    def WallSurface(self, ci: ComponentIndex) -> Surface: ...\n\nclass BezierCurve(object):\n    \"\"\"Represents a Bezier curve.\nNote: as an exception, the bezier curve\nis not\nderived from\n.\n\n    \"\"\"\n    @overload\n    def __init__(self, controlPoints: Generic.IEnumerable): ...\n    @overload\n    def __init__(self, controlPoints: Generic.IEnumerable): ...\n    @overload\n    def __init__(self, controlPoints: Generic.IEnumerable): ...\n    @overload\n    def ChangeDimension(self, desiredDimension: int) -> bool: ...\n    @overload\n    @staticmethod\n    def CreateBeziers(sourceCurve: Curve) -> System.Array[BezierCurve]: ...\n    @overload\n    @staticmethod\n    def CreateCubicBeziers(sourceCurve: Curve, distanceTolerance: float, kinkTolerance: float) -> System.Array[BezierCurve]: ...\n    @overload\n    @staticmethod\n    def CreateLoftedBezier(points: Generic.IEnumerable) -> BezierCurve: ...\n    @overload\n    @staticmethod\n    def CreateLoftedBezier(points: Generic.IEnumerable) -> BezierCurve: ...\n    @overload\n    def CurvatureAt(self, t: float) -> Vector3d: ...\n    @overload\n    def Dispose() -> None: ...\n    @property\n    def ControlVertexCount(self) -> int: ...\n    @property\n    def Dimension(self) -> int: ...\n    @property\n    def IsRational(self) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @overload\n    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...\n    @overload\n    def GetControlVertex2d(self, index: int) -> Point2d: ...\n    @overload\n    def GetControlVertex3d(self, index: int) -> Point3d: ...\n    @overload\n    def GetControlVertex4d(self, index: int) -> Point4d: ...\n    @overload\n    def GetObjectData(self, info: Serialization.SerializationInfo, context: Serialization.StreamingContext) -> None: ...\n    @overload\n    def IncreaseDegree(self, desiredDegree: int) -> bool: ...\n    @overload\n    def MakeNonRational() -> bool: ...\n    @overload\n    def MakeRational() -> bool: ...\n    @overload\n    def PointAt(self, t: float) -> Point3d: ...\n    @overload\n    def Split(self, t: float) -> (bool, BezierCurve, BezierCurve): ...\n    @overload\n    def TangentAt(self, t: float) -> Vector3d: ...\n    @overload\n    def ToNurbsCurve() -> NurbsCurve: ...\n\nclass BezierSurface(object):\n    \"\"\"Represents a Bezier surface.\n\n    \"\"\"\n    @overload\n    def ControlVertexCount(self, direction: int) -> int: ...\n    @overload\n    @staticmethod\n    def CreateLoftedBezier(curves: Generic.IEnumerable) -> BezierSurface: ...\n    @overload\n    def Dispose() -> None: ...\n    @overload\n    def Domain(self, direction: int) -> Interval: ...\n    @property\n    def Dimension(self) -> int: ...\n    @property\n    def IsRational(self) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @overload\n    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...\n    @overload\n    def GetControlVertex2d(self, i: int, j: int) -> Point2d: ...\n    @overload\n    def GetControlVertex3d(self, i: int, j: int) -> Point3d: ...\n    @overload\n    def GetControlVertex4d(self, i: int, j: int) -> Point4d: ...\n    @overload\n    def MakeNonRational() -> bool: ...\n    @overload\n    def MakeRational() -> bool: ...\n    @overload\n    def PointAt(self, u: float, v: float) -> Point3d: ...\n    @overload\n    def Reverse(self, direction: int) -> BezierSurface: ...\n    @overload\n    def Split(self, direction: int, t: float) -> (bool, BezierSurface, BezierSurface): ...\n    @overload\n    def ToNurbsSurface() -> NurbsSurface: ...\n    @overload\n    def Transform(self, xform: Transform) -> bool: ...\n    @overload\n    def Transpose() -> BezierSurface: ...\n\nclass Box(System.ValueType):\n    \"\"\"Represents the value of a plane and three intervals in an orthogonal, oriented box that is not necessarily parallel to the world Y, X, Z axes.\n\n    \"\"\"\n    @overload\n    def __init__(self, other: Box): ...\n    @overload\n    def __init__(self, bbox: BoundingBox): ...\n    @overload\n    def __init__(self, basePlane: Plane, points: Generic.IEnumerable): ...\n    @overload\n    def __init__(self, basePlane: Plane, geometry: GeometryBase): ...\n    @overload\n    def __init__(self, basePlane: Plane, boundingbox: BoundingBox): ...\n    @overload\n    def __init__(self, basePlane: Plane, xSize: Interval, ySize: Interval, zSize: Interval): ...\n    @overload\n    def ClosestPoint(self, point: Point3d) -> Point3d: ...\n    @overload\n    def Contains(self, box: BoundingBox) -> bool: ...\n    @overload\n    def Contains(self, point: Point3d) -> bool: ...\n    @overload\n    def Contains(self, box: Box) -> bool: ...\n    @overload\n    def Contains(self, box: BoundingBox, strict: bool) -> bool: ...\n    @overload\n    def Contains(self, box: Box, strict: bool) -> bool: ...\n    @overload\n    def Contains(self, point: Point3d, strict: bool) -> bool: ...\n    @overload\n    def EpsilonEquals(self, other: Box, epsilon: float) -> bool: ...\n    @overload\n    def FurthestPoint(self, point: Point3d) -> Point3d: ...\n    @property\n    def Area(self) -> float: ...\n    @property\n    def BoundingBox(self) -> BoundingBox: ...\n    @property\n    def Center(self) -> Point3d: ...\n    @property\n    def Empty(self) -> Box: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Plane(self) -> Plane: ...\n    @property\n    def Unset(self) -> Box: ...\n    @property\n    def Volume(self) -> float: ...\n    @property\n    def X(self) -> Interval: ...\n    @property\n    def Y(self) -> Interval: ...\n    @property\n    def Z(self) -> Interval: ...\n    @overload\n    def GetCorners() -> System.Array[Point3d]: ...\n    @overload\n    def Inflate(self, amount: float) -> None: ...\n    @overload\n    def Inflate(self, xAmount: float, yAmount: float, zAmount: float) -> None: ...\n    @overload\n    def MakeValid() -> bool: ...\n    @overload\n    def PointAt(self, x: float, y: float, z: float) -> Point3d: ...\n    @overload\n    def RepositionBasePlane(self, origin: Point3d) -> None: ...\n    @Plane.setter\n    def Plane(self, value: System.Void): ...\n    @X.setter\n    def X(self, value: System.Void): ...\n    @Y.setter\n    def Y(self, value: System.Void): ...\n    @Z.setter\n    def Z(self, value: System.Void): ...\n    @overload\n    def ToBrep() -> Brep: ...\n    @overload\n    def ToExtrusion() -> Extrusion: ...\n    @overload\n    def Transform(self, xform: Transform) -> bool: ...\n    @overload\n    def Union(self, point: Point3d) -> None: ...\n\nclass PipeCapMode(enum.Enum):\n    None_ = 0\n    Flat = 1\n    Round = 2\n\nclass LoftType(enum.Enum):\n    Normal = 0\n    Loose = 1\n    Tight = 2\n    Straight = 3\n    Developable = 4\n    Uniform = 5\n\nclass ExtrudeCornerType(enum.Enum):\n    None_ = 0\n    Sharp = 1\n    Round = 2\n    Smooth = 3\n    Chamfer = 4\n\nclass BlendType(enum.Enum):\n    Chamfer = 0\n    Fillet = 1\n    Blend = 2\n\nclass RailType(enum.Enum):\n    DistanceFromEdge = 0\n    RollingBall = 1\n    DistanceBetweenRails = 2\n\nclass BrepEdgeFilletDistance(object):\n    \"\"\"Fillet distances along a BrepEdge\n\n    \"\"\"\n    def __init__(self, edgeParameter: float, filletDistance: float): ...\n    @property\n    def EdgeParameter(self) -> float: ...\n    @property\n    def FilletDistance(self) -> float: ...\n\nclass SweepRebuild(enum.Enum):\n    None_ = 0\n    Rebuild = 1\n    Refit = 2\n\nclass SweepFrame(enum.Enum):\n    Freeform = 0\n    Roadlike = 1\n\nclass SweepBlend(enum.Enum):\n    Local = 0\n    Global = 1\n\nclass SweepMiter(enum.Enum):\n    None_ = 0\n    Trimmed = 1\n    Untrimmed = 2\n\nclass Brep(GeometryBase):\n    \"\"\"Boundary Representation. A surface or polysurface along with trim curve information.\n\n    \"\"\"\n    def __init__(self): ...\n    @overload\n    def AddEdgeCurve(self, curve: Curve) -> int: ...\n    @overload\n    def AddSurface(self, surface: Surface) -> int: ...\n    @overload\n    def AddTrimCurve(self, curve: Curve) -> int: ...\n    @overload\n    def Append(self, other: Brep) -> None: ...\n    @overload\n    def CapPlanarHoles(self, tolerance: float) -> Brep: ...\n    @overload\n    @staticmethod\n    def ChangeSeam(face: BrepFace, direction: int, parameter: float, tolerance: float) -> Brep: ...\n    @overload\n    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...\n    @overload\n    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> (bool, Point3d, ComponentIndex, float, float, Vector3d): ...\n    @overload\n    def Compact() -> None: ...\n    @overload\n    @staticmethod\n    def CopyTrimCurves(trimSource: BrepFace, surfaceSource: Surface, tolerance: float) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateBaseballSphere(center: Point3d, radius: float, tolerance: float) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateBlendShape(face0: BrepFace, edge0: BrepEdge, t0: float, rev0: bool, continuity0: BlendContinuity, face1: BrepFace, edge1: BrepEdge, t1: float, rev1: bool, continuity1: BlendContinuity) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateBlendSurface(face0: BrepFace, edge0: BrepEdge, domain0: Interval, rev0: bool, continuity0: BlendContinuity, face1: BrepFace, edge1: BrepEdge, domain1: Interval, rev1: bool, continuity1: BlendContinuity) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanDifference(firstBrep: Brep, secondBrep: Brep, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanDifference(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanDifference(firstBrep: Brep, secondBrep: Brep, tolerance: float, manifoldOnly: bool) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanDifference(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable, tolerance: float, manifoldOnly: bool) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanDifferenceWithIndexMap(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable, tolerance: float, manifoldOnly: bool) -> (System.Array[Brep], System.System.Array[int]): ...\n    @overload\n    @staticmethod\n    def CreateBooleanIntersection(firstBrep: Brep, secondBrep: Brep, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanIntersection(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanIntersection(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable, tolerance: float, manifoldOnly: bool) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanIntersection(firstBrep: Brep, secondBrep: Brep, tolerance: float, manifoldOnly: bool) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanSplit(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanSplit(firstBrep: Brep, secondBrep: Brep, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanUnion(breps: Generic.IEnumerable, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanUnion(breps: Generic.IEnumerable, tolerance: float, manifoldOnly: bool) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanUnion(breps: Generic.IEnumerable, tolerance: float, manifoldOnly: bool) -> (System.Array[Brep], System.Array[Point3d], System.Array[Point3d], System.Array[Point3d]): ...\n    @overload\n    @staticmethod\n    def CreateChamferSurface(face0: BrepFace, uv0: Point2d, radius0: float, face1: BrepFace, uv1: Point2d, radius1: float, extend: bool, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateChamferSurface(face0: BrepFace, uv0: Point2d, radius0: float, face1: BrepFace, uv1: Point2d, radius1: float, trim: bool, extend: bool, tolerance: float) -> (System.Array[Brep], System.Array[Brep], System.Array[Brep]): ...\n    @overload\n    @staticmethod\n    def CreateContourCurves(brepToContour: Brep, sectionPlane: Plane) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def CreateContourCurves(brepToContour: Brep, contourStart: Point3d, contourEnd: Point3d, interval: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def CreateCurvatureAnalysisMesh(brep: Brep, state: ApplicationSettings.CurvatureAnalysisSettingsState) -> System.Array[Mesh]: ...\n    @overload\n    @staticmethod\n    def CreateDevelopableLoft(rail0: NurbsCurve, rail1: NurbsCurve, fixedRulings: Generic.IEnumerable) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateDevelopableLoft(crv0: Curve, crv1: Curve, reverse0: bool, reverse1: bool, density: int) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateEdgeSurface(curves: Generic.IEnumerable) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateFilletEdges(brep: Brep, edgeIndices: Generic.IEnumerable, startRadii: Generic.IEnumerable, endRadii: Generic.IEnumerable, blendType: BlendType, railType: RailType, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFilletEdges(brep: Brep, edgeIndices: Generic.IEnumerable, startRadii: Generic.IEnumerable, endRadii: Generic.IEnumerable, blendType: BlendType, railType: RailType, setbackFillets: bool, tolerance: float, angleTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFilletEdgesVariableRadius(brep: Brep, edgeIndices: Generic.IEnumerable, edgeDistances: Generic.IDictionary, blendType: BlendType, railType: RailType, setbackFillets: bool, tolerance: float, angleTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFilletSurface(face0: BrepFace, uv0: Point2d, face1: BrepFace, uv1: Point2d, radius: float, extend: bool, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFilletSurface(face0: BrepFace, uv0: Point2d, face1: BrepFace, uv1: Point2d, radius: float, trim: bool, extend: bool, tolerance: float) -> (System.Array[Brep], System.Array[Brep], System.Array[Brep]): ...\n    @overload\n    @staticmethod\n    def CreateFromBox(box: BoundingBox) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateFromBox(box: Box) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateFromBox(corners: Generic.IEnumerable) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateFromCone(cone: Cone, capBottom: bool) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateFromCornerPoints(corner1: Point3d, corner2: Point3d, corner3: Point3d, tolerance: float) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateFromCornerPoints(corner1: Point3d, corner2: Point3d, corner3: Point3d, corner4: Point3d, tolerance: float) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateFromCylinder(cylinder: Cylinder, capBottom: bool, capTop: bool) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateFromJoinedEdges(brep0: Brep, edgeIndex0: int, brep1: Brep, edgeIndex1: int, joinTolerance: float) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateFromLoft(curves: Generic.IEnumerable, start: Point3d, end: Point3d, loftType: LoftType, closed: bool) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFromLoft(curves: Generic.IEnumerable, start: Point3d, end: Point3d, StartTangent: bool, EndTangent: bool, StartTrim: BrepTrim, EndTrim: BrepTrim, loftType: LoftType, closed: bool) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFromLoftRebuild(curves: Generic.IEnumerable, start: Point3d, end: Point3d, loftType: LoftType, closed: bool, rebuildPointCount: int) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFromLoftRefit(curves: Generic.IEnumerable, start: Point3d, end: Point3d, loftType: LoftType, closed: bool, refitTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFromMesh(mesh: Mesh, trimmedTriangles: bool) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateFromOffsetFace(face: BrepFace, offsetDistance: float, offsetTolerance: float, bothSides: bool, createSolid: bool) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateFromRevSurface(surface: RevSurface, capStart: bool, capEnd: bool) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateFromSphere(sphere: Sphere) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateFromSurface(surface: Surface) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateFromSweep(rail: Curve, shapes: Generic.IEnumerable, closed: bool, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFromSweep(rail: Curve, shape: Curve, closed: bool, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFromSweep(rail1: Curve, rail2: Curve, shapes: Generic.IEnumerable, closed: bool, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFromSweep(rail1: Curve, rail2: Curve, shape: Curve, closed: bool, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFromSweep(rail1: Curve, rail2: Curve, shapes: Generic.IEnumerable, start: Point3d, end: Point3d, closed: bool, tolerance: float, rebuild: SweepRebuild, rebuildPointCount: int, refitTolerance: float, preserveHeight: bool) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFromSweep(rail1: Curve, rail2: Curve, shapes: Generic.IEnumerable, start: Point3d, end: Point3d, closed: bool, tolerance: float, rebuild: SweepRebuild, rebuildPointCount: int, refitTolerance: float, preserveHeight: bool, autoAdjust: bool) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFromSweep(rail: Curve, shapes: Generic.IEnumerable, startPoint: Point3d, endPoint: Point3d, frameType: SweepFrame, roadlikeNormal: Vector3d, closed: bool, blendType: SweepBlend, miterType: SweepMiter, tolerance: float, rebuildType: SweepRebuild, rebuildPointCount: int, refitTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFromSweepInParts(rail1: Curve, rail2: Curve, shapes: Generic.IEnumerable, rail_params: Generic.IEnumerable, closed: bool, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFromSweepSegmented(rail: Curve, shape: Curve, closed: bool, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFromSweepSegmented(rail: Curve, shapes: Generic.IEnumerable, closed: bool, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFromSweepSegmented(rail: Curve, shapes: Generic.IEnumerable, startPoint: Point3d, endPoint: Point3d, frameType: SweepFrame, roadlikeNormal: Vector3d, closed: bool, blendType: SweepBlend, miterType: SweepMiter, tolerance: float, rebuildType: SweepRebuild, rebuildPointCount: int, refitTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFromTaperedExtrude(curveToExtrude: Curve, distance: float, direction: Vector3d, basePoint: Point3d, draftAngleRadians: float, cornerType: ExtrudeCornerType, tolerance: float, angleToleranceRadians: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFromTaperedExtrudeWithRef(curve: Curve, direction: Vector3d, distance: float, draftAngle: float, plane: Plane, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateFromTorus(torus: Torus) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateOffsetBrep(brep: Brep, distance: float, solid: bool, extend: bool, tolerance: float) -> (System.Array[Brep], System.Array[Brep], System.Array[Brep]): ...\n    @overload\n    @staticmethod\n    def CreateOffsetBrep(brep: Brep, distance: float, solid: bool, extend: bool, shrink: bool, tolerance: float) -> (System.Array[Brep], System.Array[Brep], System.Array[Brep]): ...\n    @overload\n    @staticmethod\n    def CreatePatch(geometry: Generic.IEnumerable, startingSurface: Surface, tolerance: float) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreatePatch(geometry: Generic.IEnumerable, uSpans: int, vSpans: int, tolerance: float) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreatePatch(geometry: Generic.IEnumerable, startingSurface: Surface, uSpans: int, vSpans: int, trim: bool, tangency: bool, pointSpacing: float, flexibility: float, surfacePull: float, fixEdges: System.System.Array[bool], tolerance: float) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreatePipe(rail: Curve, radius: float, localBlending: bool, cap: PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreatePipe(rail: Curve, railRadiiParameters: Generic.IEnumerable, radii: Generic.IEnumerable, localBlending: bool, cap: PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreatePlanarBreps(inputLoops: Generic.IEnumerable, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreatePlanarBreps(inputLoop: Curve, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreatePlanarBreps(inputLoops: Collections.CurveList, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreatePlanarDifference(b0: Brep, b1: Brep, plane: Plane, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreatePlanarIntersection(b0: Brep, b1: Brep, plane: Plane, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreatePlanarUnion(breps: Generic.IEnumerable, plane: Plane, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreatePlanarUnion(b0: Brep, b1: Brep, plane: Plane, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateQuadSphere(sphere: Sphere) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateShell(brep: Brep, facesToRemove: Generic.IEnumerable, distance: float, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateSolid(breps: Generic.IEnumerable, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateThickPipe(rail: Curve, radius0: float, radius1: float, localBlending: bool, cap: PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateThickPipe(rail: Curve, railRadiiParameters: Generic.IEnumerable, radii0: Generic.IEnumerable, radii1: Generic.IEnumerable, localBlending: bool, cap: PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CreateTrimmedPlane(plane: Plane, curve: Curve) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateTrimmedPlane(plane: Plane, curves: Generic.IEnumerable) -> Brep: ...\n    @overload\n    @staticmethod\n    def CreateTrimmedSurface(trimSource: BrepFace, surfaceSource: Surface, tolerance: float) -> Brep: ...\n    @overload\n    def CullUnused2dCurves() -> bool: ...\n    @overload\n    def CullUnused3dCurves() -> bool: ...\n    @overload\n    def CullUnusedEdges() -> bool: ...\n    @overload\n    def CullUnusedFaces() -> bool: ...\n    @overload\n    def CullUnusedLoops() -> bool: ...\n    @overload\n    def CullUnusedSurfaces() -> bool: ...\n    @overload\n    def CullUnusedTrims() -> bool: ...\n    @overload\n    def CullUnusedVertices() -> bool: ...\n    @overload\n    @staticmethod\n    def CutUpSurface(surface: Surface, curves: Generic.IEnumerable, useEdgeCurves: bool, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def CutUpSurface(surface: Surface, curves: Generic.IEnumerable, flip: bool, fitTolerance: float, keepTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    def DestroyRegionTopology() -> None: ...\n    @overload\n    def Duplicate() -> GeometryBase: ...\n    @overload\n    def DuplicateBrep() -> Brep: ...\n    @overload\n    def DuplicateEdgeCurves() -> System.Array[Curve]: ...\n    @overload\n    def DuplicateEdgeCurves(self, nakedOnly: bool) -> System.Array[Curve]: ...\n    @overload\n    def DuplicateNakedEdgeCurves(self, nakedOuter: bool, nakedInner: bool) -> System.Array[Curve]: ...\n    @overload\n    def DuplicateSubBrep(self, faceIndices: Generic.IEnumerable) -> Brep: ...\n    @overload\n    def DuplicateVertices() -> System.Array[Point3d]: ...\n    @overload\n    @staticmethod\n    def ExtendBrepFacesToConnect(Face0: BrepFace, f0_sel_pt: Point3d, Face1: BrepFace, f1_sel_pt: Point3d, tol: float, angleTol: float) -> (bool, Brep, Brep): ...\n    @overload\n    @staticmethod\n    def ExtendBrepFacesToConnect(Face0: BrepFace, edgeIndex0: int, Face1: BrepFace, edgeIndex1: int, tol: float, angleTol: float) -> (bool, Brep, Brep): ...\n    @overload\n    def FindCoincidentBrepComponents(self, point: Point3d, tolerance: float) -> (System.System.Array[int], System.System.Array[int], System.System.Array[int]): ...\n    @overload\n    def Flip() -> None: ...\n    @property\n    def Curves2D(self) -> Collections.BrepCurveList: ...\n    @property\n    def Curves3D(self) -> Collections.BrepCurveList: ...\n    @property\n    def Edges(self) -> Collections.BrepEdgeList: ...\n    @property\n    def Faces(self) -> Collections.BrepFaceList: ...\n    @property\n    def HasRegionTopology(self) -> bool: ...\n    @property\n    def IsManifold(self) -> bool: ...\n    @property\n    def IsSolid(self) -> bool: ...\n    @property\n    def IsSurface(self) -> bool: ...\n    @property\n    def Loops(self) -> Collections.BrepLoopList: ...\n    @property\n    def SolidOrientation(self) -> BrepSolidOrientation: ...\n    @property\n    def Surfaces(self) -> Collections.BrepSurfaceList: ...\n    @property\n    def Trims(self) -> Collections.BrepTrimList: ...\n    @property\n    def Vertices(self) -> Collections.BrepVertexList: ...\n    @overload\n    def GetArea() -> float: ...\n    @overload\n    def GetArea(self, relativeTolerance: float, absoluteTolerance: float) -> float: ...\n    @overload\n    def GetConnectedComponents() -> System.Array[Brep]: ...\n    @overload\n    def GetPointInside(self, tolerance: float) -> (bool, Point3d): ...\n    @overload\n    def GetRegions() -> System.Array[BrepRegion]: ...\n    @overload\n    def GetTangentConnectedComponents(self, angleTolerance: float, includeMeshes: bool) -> System.Array[Brep]: ...\n    @overload\n    def GetVolume() -> float: ...\n    @overload\n    def GetVolume(self, relativeTolerance: float, absoluteTolerance: float) -> float: ...\n    @overload\n    def GetWireframe(self, density: int) -> System.Array[Curve]: ...\n    @overload\n    def InsetFaces(self, faceIndices: Generic.IEnumerable, distance: float, loose: bool, ignoreSeams: bool, creaseCorners: bool, tolerance: float, angleTolerance: float) -> Brep: ...\n    @overload\n    def IsBox() -> bool: ...\n    @overload\n    def IsBox(self, tolerance: float) -> bool: ...\n    @overload\n    def IsDuplicate(self, other: Brep, tolerance: float) -> bool: ...\n    @overload\n    def IsPointInside(self, point: Point3d, tolerance: float, strictlyIn: bool) -> bool: ...\n    @overload\n    def IsValidGeometry() -> (bool, str): ...\n    @overload\n    def IsValidTolerancesAndFlags() -> (bool, str): ...\n    @overload\n    def IsValidTopology() -> (bool, str): ...\n    @overload\n    def Join(self, otherBrep: Brep, tolerance: float, compact: bool) -> bool: ...\n    @overload\n    @staticmethod\n    def JoinBreps(brepsToJoin: Generic.IEnumerable, tolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def JoinBreps(brepsToJoin: Generic.IEnumerable, tolerance: float, angleTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def JoinBreps(brepsToJoin: Generic.IEnumerable, tolerance: float, angleTolerance: float) -> (System.Array[Brep], Generic.List): ...\n    @overload\n    def JoinEdges(self, edgeIndex0: int, edgeIndex1: int, joinTolerance: float, compact: bool) -> bool: ...\n    @overload\n    def JoinNakedEdges(self, tolerance: float) -> int: ...\n    @overload\n    def MakeValidForV2() -> bool: ...\n    @overload\n    @staticmethod\n    def MergeBreps(brepsToMerge: Generic.IEnumerable, tolerance: float) -> Brep: ...\n    @overload\n    def MergeCoplanarFaces(self, tolerance: float) -> bool: ...\n    @overload\n    def MergeCoplanarFaces(self, tolerance: float, angleTolerance: float) -> bool: ...\n    @overload\n    def MergeCoplanarFaces(self, faceIndex: int, tolerance: float, angleTolerance: float) -> bool: ...\n    @overload\n    def MergeCoplanarFaces(self, faceIndex0: int, faceIndex1: int, tolerance: float, angleTolerance: float) -> bool: ...\n    @overload\n    @staticmethod\n    def MergeSurfaces(surface0: Surface, surface1: Surface, tolerance: float, angleToleranceRadians: float) -> Brep: ...\n    @overload\n    @staticmethod\n    def MergeSurfaces(brep0: Brep, brep1: Brep, tolerance: float, angleToleranceRadians: float) -> Brep: ...\n    @overload\n    @staticmethod\n    def MergeSurfaces(brep0: Brep, brep1: Brep, tolerance: float, angleToleranceRadians: float, point0: Point2d, point1: Point2d, roundness: float, smooth: bool) -> Brep: ...\n    @overload\n    def PushPullExtend(self, faceIndex: int, transform: Transform, tolerance: float) -> Brep: ...\n    @overload\n    def RebuildTrimsForV2(self, face: BrepFace, nurbsSurface: NurbsSurface) -> None: ...\n    @overload\n    def RemoveFins() -> bool: ...\n    @overload\n    def RemoveHoles(self, tolerance: float) -> Brep: ...\n    @overload\n    def RemoveHoles(self, loops: Generic.IEnumerable, tolerance: float) -> Brep: ...\n    @overload\n    def Repair(self, tolerance: float) -> bool: ...\n    @overload\n    def SetTolerancesBoxesAndFlags() -> None: ...\n    @overload\n    def SetTolerancesBoxesAndFlags(self, bLazy: bool, bSetVertexTolerances: bool, bSetEdgeTolerances: bool, bSetTrimTolerances: bool, bSetTrimIsoFlags: bool, bSetTrimTypeFlags: bool, bSetLoopTypeFlags: bool, bSetTrimBoxes: bool) -> None: ...\n    @overload\n    def SetTrimIsoFlags() -> None: ...\n    @overload\n    def SetVertices() -> None: ...\n    @overload\n    def Split(self, cutter: Brep, intersectionTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    def Split(self, cutters: Generic.IEnumerable, intersectionTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    def Split(self, cutters: Generic.IEnumerable, intersectionTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    def Split(self, cutter: Brep, intersectionTolerance: float) -> (System.Array[Brep], bool): ...\n    @overload\n    def Split(self, cutters: Generic.IEnumerable, normal: Vector3d, planView: bool, intersectionTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def SplitDisjointPieces(brep: Brep) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def SplitDisjointPieces(brep: Brep) -> (System.Array[Brep], Generic.List): ...\n    @overload\n    def Standardize() -> None: ...\n    @overload\n    def TransformComponent(self, components: Generic.IEnumerable, xform: Transform, tolerance: float, timeLimit: float, useMultipleThreads: bool) -> bool: ...\n    @overload\n    def Trim(self, cutter: Brep, intersectionTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    def Trim(self, cutter: Plane, intersectionTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    @staticmethod\n    def TryConvertBrep(geometry: GeometryBase) -> Brep: ...\n    @overload\n    def UnjoinEdges(self, edgesToUnjoin: Generic.IEnumerable) -> System.Array[Brep]: ...\n\nclass PointFaceRelation(enum.Enum):\n    Exterior = 0\n    Interior = 1\n    Boundary = 2\n\nclass BrepSolidOrientation(enum.Enum):\n    None_ = 0\n    Outward = 1\n    Unknown = 2\n    Inward = -1\n\nclass EdgeAdjacency(enum.Enum):\n    None_ = 0\n    Naked = 1\n    Interior = 2\n    NonManifold = 3\n\nclass Concavity(enum.Enum):\n    Tangent = 0\n    Convex = 1\n    Concave = 2\n    None_ = -1\n\nclass BrepVertex(Point):\n    \"\"\"Brep vertex information\n\n    \"\"\"\n    @overload\n    def EdgeIndices() -> System.System.Array[int]: ...\n    @property\n    def Brep(self) -> Brep: ...\n    @property\n    def ProxyBrepSubDVertexId(self) -> System.UInt32: ...\n    @property\n    def Tolerance(self) -> float: ...\n    @property\n    def VertexIndex(self) -> int: ...\n\nclass BrepEdge(CurveProxy):\n    \"\"\"Represents a single edge curve in a Brep object.\n\n    \"\"\"\n    @overload\n    def AdjacentFaces() -> System.System.Array[int]: ...\n    @overload\n    def ConcavityAt(self, t: float, tolerance: float) -> Concavity: ...\n    @property\n    def Brep(self) -> Brep: ...\n    @property\n    def EdgeCurve(self) -> Curve: ...\n    @property\n    def EdgeCurveIndex(self) -> int: ...\n    @property\n    def EdgeIndex(self) -> int: ...\n    @property\n    def EndVertex(self) -> BrepVertex: ...\n    @property\n    def ProxyBrepSubDEdgeId(self) -> System.UInt32: ...\n    @property\n    def StartVertex(self) -> BrepVertex: ...\n    @property\n    def Tolerance(self) -> float: ...\n    @property\n    def TrimCount(self) -> int: ...\n    @property\n    def Valence(self) -> EdgeAdjacency: ...\n    @overload\n    def GetEdgeParameter(self, trimIndex: int, trimParameter: float) -> (bool, float): ...\n    @overload\n    def IsSmoothManifoldEdge(self, angleToleranceRadians: float) -> bool: ...\n    @Tolerance.setter\n    def Tolerance(self, value: System.Void): ...\n    @overload\n    def SetEdgeCurve(self, curve3dIndex: int) -> bool: ...\n    @overload\n    def SetEdgeCurve(self, curve3dIndex: int, subDomain: Interval) -> bool: ...\n    @overload\n    def TrimIndices() -> System.System.Array[int]: ...\n\nclass BrepTrimType(enum.Enum):\n    Unknown = 0\n    Boundary = 1\n    Mated = 2\n    Seam = 3\n    Singular = 4\n    CurveOnSurface = 5\n    PointOnSurface = 6\n    Slit = 7\n\nclass BrepTrim(CurveProxy):\n    \"\"\"Brep trim information is stored in BrepTrim classes. Brep.Trims is an array of all the trims in the brep. A BrepTrim is derived from CurveProxy so the trim can supply easy to use evaluation tools via the Curve virtual member functions. Note well that the domains and orientations of the curve m_C2[trim.m_c2i] and the trim as a curve may not agree.\n\n    \"\"\"\n    @property\n    def Brep(self) -> Brep: ...\n    @property\n    def Edge(self) -> BrepEdge: ...\n    @property\n    def EndVertex(self) -> BrepVertex: ...\n    @property\n    def Face(self) -> BrepFace: ...\n    @property\n    def IsoStatus(self) -> IsoStatus: ...\n    @property\n    def Loop(self) -> BrepLoop: ...\n    @property\n    def StartVertex(self) -> BrepVertex: ...\n    @property\n    def TrimCurve(self) -> Curve: ...\n    @property\n    def TrimCurveIndex(self) -> int: ...\n    @property\n    def TrimIndex(self) -> int: ...\n    @property\n    def TrimType(self) -> BrepTrimType: ...\n    @overload\n    def GetTolerances() -> (float, float): ...\n    @overload\n    def GetTrimParameter(self, edgeParameter: float) -> (bool, float): ...\n    @overload\n    def IsReversed() -> bool: ...\n    @IsoStatus.setter\n    def IsoStatus(self, value: System.Void): ...\n    @TrimType.setter\n    def TrimType(self, value: System.Void): ...\n    @overload\n    def SetTolerances(self, toleranceU: float, toleranceV: float) -> None: ...\n    @overload\n    def SetTrimCurve(self, curve2dIndex: int) -> bool: ...\n    @overload\n    def SetTrimCurve(self, curve2dIndex: int, subDomain: Interval) -> bool: ...\n\nclass BrepLoopType(enum.Enum):\n    Unknown = 0\n    Outer = 1\n    Inner = 2\n    Slit = 3\n    CurveOnSurface = 4\n    PointOnSurface = 5\n\nclass BrepLoop(GeometryBase):\n    \"\"\"Represent a single loop in a Brep object. A loop is composed of a list of trim curves.\n\n    \"\"\"\n    @property\n    def Brep(self) -> Brep: ...\n    @property\n    def Face(self) -> BrepFace: ...\n    @property\n    def LoopIndex(self) -> int: ...\n    @property\n    def LoopType(self) -> BrepLoopType: ...\n    @property\n    def Trims(self) -> Collections.BrepTrimList: ...\n    @overload\n    def To2dCurve() -> Curve: ...\n    @overload\n    def To3dCurve() -> Curve: ...\n\nclass BrepFace(SurfaceProxy):\n    \"\"\"Provides strongly-typed access to brep faces.\nA Brep face is composed of one surface and trimming curves.\n\n    \"\"\"\n    @overload\n    def AdjacentEdges() -> System.System.Array[int]: ...\n    @overload\n    def AdjacentFaces() -> System.System.Array[int]: ...\n    @overload\n    def ChangeSurface(self, surfaceIndex: int) -> bool: ...\n    @overload\n    def ClearMaterialChannelIndex() -> None: ...\n    @overload\n    def ClearPackId() -> None: ...\n    @overload\n    def CreateExtrusion(self, pathCurve: Curve, cap: bool) -> Brep: ...\n    @overload\n    def DraftAnglePoint(self, testPoint: Point2d, testAngle: float, pullDirection: Vector3d, edge: bool) -> (bool, Point3d, float): ...\n    @overload\n    def DuplicateFace(self, duplicateMeshes: bool) -> Brep: ...\n    @overload\n    def DuplicateSurface() -> Surface: ...\n    @overload\n    def FilletSurfaceToCurve(self, curve: Curve, t: float, u: float, v: float, radius: float, alignToCurve: int, railDegree: int, arcDegree: int, arcSliders: Generic.IEnumerable, numBezierSrfs: int, tolerance: float, out_fillets: Generic.List) -> (bool, System.System.Array[float]): ...\n    @overload\n    def FilletSurfaceToRail(self, curveOnFace: Curve, secondFace: BrepFace, u1: float, v1: float, railDegree: int, arcDegree: int, arcSliders: Generic.IEnumerable, numBezierSrfs: int, extend: bool, split_type: FilletSurfaceSplitType, tolerance: float, out_fillets: Generic.List, out_breps0: Generic.List, out_breps1: Generic.List) -> (bool, System.System.Array[float]): ...\n    @property\n    def Brep(self) -> Brep: ...\n    @property\n    def FaceIndex(self) -> int: ...\n    @property\n    def Id(self) -> System.Guid: ...\n    @property\n    def IsSurface(self) -> bool: ...\n    @property\n    def Loops(self) -> Collections.BrepLoopList: ...\n    @property\n    def MaterialChannelIndex(self) -> int: ...\n    @property\n    def OrientationIsReversed(self) -> bool: ...\n    @property\n    def OuterLoop(self) -> BrepLoop: ...\n    @property\n    def PackId(self) -> System.UInt32: ...\n    @property\n    def PerFaceColor(self) -> Drawing.Color: ...\n    @property\n    def ProxyBrepSubDFaceId(self) -> System.UInt32: ...\n    @property\n    def SurfaceIndex(self) -> int: ...\n    @overload\n    def GetMesh(self, meshType: MeshType) -> Mesh: ...\n    @overload\n    def IsPointOnFace(self, u: float, v: float) -> PointFaceRelation: ...\n    @overload\n    def IsPointOnFace(self, u: float, v: float, tolerance: float) -> PointFaceRelation: ...\n    @overload\n    def PullPointsToFace(self, points: Generic.IEnumerable, tolerance: float) -> System.Array[Point3d]: ...\n    @overload\n    def RebuildEdges(self, tolerance: float, rebuildSharedEdges: bool, rebuildVertices: bool) -> bool: ...\n    @overload\n    def RefitTrim(self, edge: BrepEdge, knots: Generic.IEnumerable, tolerance: float, bSections: bool) -> (System.Array[Surface], float): ...\n    @overload\n    def RemoveHoles(self, tolerance: float) -> Brep: ...\n    @Id.setter\n    def Id(self, value: System.Void): ...\n    @MaterialChannelIndex.setter\n    def MaterialChannelIndex(self, value: System.Void): ...\n    @OrientationIsReversed.setter\n    def OrientationIsReversed(self, value: System.Void): ...\n    @PerFaceColor.setter\n    def PerFaceColor(self, value: System.Void): ...\n    @overload\n    def SetDomain(self, direction: int, domain: Interval) -> bool: ...\n    @overload\n    def SetMesh(self, meshType: MeshType, mesh: Mesh) -> bool: ...\n    @overload\n    def SetPackId(self, packId: System.UInt32) -> None: ...\n    @overload\n    def ShrinkFace(self, disableSide: ShrinkDisableSide) -> bool: ...\n    @overload\n    def ShrinkSurfaceToEdge() -> bool: ...\n    @overload\n    def Split(self, curves: Generic.IEnumerable, tolerance: float) -> Brep: ...\n    @overload\n    def TrimAwareIsoCurve(self, direction: int, constantParameter: float) -> System.Array[Curve]: ...\n    @overload\n    def TrimAwareIsoIntervals(self, direction: int, constantParameter: float) -> System.Array[Interval]: ...\n    @overload\n    def UnderlyingSurface() -> Surface: ...\n\nclass BrepRegion(Runtime.CommonObject):\n    \"\"\"Represents a brep topological region that has sides.\n\n    \"\"\"\n    @overload\n    def BoundaryBrep() -> Brep: ...\n    @property\n    def BoundingBox(self) -> BoundingBox: ...\n    @property\n    def Brep(self) -> Brep: ...\n    @property\n    def Index(self) -> int: ...\n    @property\n    def IsFinite(self) -> bool: ...\n    @overload\n    def GetFaceSides() -> System.Array[BrepRegionFaceSide]: ...\n\nclass BrepRegionFaceSide(Runtime.CommonObject):\n    \"\"\"Represents a side of a\nentity.\n\n    \"\"\"\n    @property\n    def Brep(self) -> Brep: ...\n    @property\n    def Face(self) -> BrepFace: ...\n    @property\n    def Region(self) -> BrepRegion: ...\n    @property\n    def SurfaceNormalPointsIntoRegion(self) -> bool: ...\n\nclass ComponentStatus(System.ValueType):\n    \"\"\"Provides information about selection, highlighting, visibility, editability and integrity states of a component.\nThis structure is immutable.\n\n    \"\"\"\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @overload\n    def Equals(self, other: ComponentStatus) -> bool: ...\n    @property\n    def AllSet(self) -> ComponentStatus: ...\n    @property\n    def Clear(self) -> ComponentStatus: ...\n    @property\n    def Damaged(self) -> ComponentStatus: ...\n    @property\n    def Hidden(self) -> ComponentStatus: ...\n    @property\n    def Highlighted(self) -> ComponentStatus: ...\n    @property\n    def IsClear(self) -> bool: ...\n    @property\n    def IsDamaged(self) -> bool: ...\n    @property\n    def IsHidden(self) -> bool: ...\n    @property\n    def IsHighlighted(self) -> bool: ...\n    @property\n    def IsLocked(self) -> bool: ...\n    @property\n    def IsSelected(self) -> bool: ...\n    @property\n    def IsSelectedPersistent(self) -> bool: ...\n    @property\n    def Locked(self) -> ComponentStatus: ...\n    @property\n    def Selected(self) -> ComponentStatus: ...\n    @property\n    def SelectedPersistent(self) -> ComponentStatus: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    def HasAllEqualStates(self, statesFilter: ComponentStatus, comparand: ComponentStatus) -> bool: ...\n    @overload\n    def HasNoEqualStates(self, statesFilter: ComponentStatus, comparand: ComponentStatus) -> bool: ...\n    @overload\n    def HasSomeEqualStates(self, statesFilter: ComponentStatus, comparand: ComponentStatus) -> bool: ...\n    @overload\n    def ToString() -> str: ...\n    @overload\n    def WithStates(self, additionalStatus: ComponentStatus) -> ComponentStatus: ...\n\nclass CurveProxy(Curve):\n    \"\"\"Represent curve geometry. Usually this is part of another piece of geometry that can be represented as a \"proxy\".\n\n    \"\"\"\n    @property\n    def ProxyCurveIsReversed(self) -> bool: ...\n\nclass DetailView(GeometryBase):\n    \"\"\"Represents a view of the model placed on a page layout.\n\n    \"\"\"\n    @property\n    def IsParallelProjection(self) -> bool: ...\n    @property\n    def IsPerspectiveProjection(self) -> bool: ...\n    @property\n    def IsProjectionLocked(self) -> bool: ...\n    @property\n    def PageToModelRatio(self) -> float: ...\n    @IsParallelProjection.setter\n    def IsParallelProjection(self, value: System.Void): ...\n    @IsPerspectiveProjection.setter\n    def IsPerspectiveProjection(self, value: System.Void): ...\n    @IsProjectionLocked.setter\n    def IsProjectionLocked(self, value: System.Void): ...\n    @overload\n    def SetScale(self, modelLength: float, modelUnits: Rhino.UnitSystem, pageLength: float, pageUnits: Rhino.UnitSystem) -> bool: ...\n\nclass LinearDimension(Dimension):\n    \"\"\"Represents a linear dimension\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, dimensionPlane: Plane, extensionLine1End: Point2d, extensionLine2End: Point2d, pointOnDimensionLine: Point2d): ...\n    @overload\n    @staticmethod\n    def Create(dimtype: AnnotationType, dimStyle: DocObjects.DimensionStyle, plane: Plane, horizontal: Vector3d, defpoint1: Point3d, defpoint2: Point3d, dimlinepoint: Point3d, rotationInPlane: float) -> LinearDimension: ...\n    @overload\n    @staticmethod\n    def FromPoints(extensionLine1End: Point3d, extensionLine2End: Point3d, pointOnDimensionLine: Point3d) -> LinearDimension: ...\n    @property\n    def Aligned(self) -> bool: ...\n    @property\n    def AnnotationType(self) -> AnnotationType: ...\n    @property\n    def Arrowhead1End(self) -> Point2d: ...\n    @property\n    def Arrowhead2End(self) -> Point2d: ...\n    @property\n    def DimensionLinePoint(self) -> Point2d: ...\n    @property\n    def DistanceBetweenArrowTips(self) -> float: ...\n    @property\n    def ExtensionLine1End(self) -> Point2d: ...\n    @property\n    def ExtensionLine2End(self) -> Point2d: ...\n    @overload\n    def Get3dPoints() -> (bool, Point3d, Point3d, Point3d, Point3d, Point3d, Point3d): ...\n    @overload\n    def GetDisplayLines(self, style: DocObjects.DimensionStyle, scale: float) -> (bool, Generic.IEnumerable): ...\n    @overload\n    def GetDistanceDisplayText(self, unitsystem: Rhino.UnitSystem, style: DocObjects.DimensionStyle) -> str: ...\n    @overload\n    def GetTextRectangle() -> (bool, System.Array[Point3d]): ...\n    @Aligned.setter\n    def Aligned(self, value: System.Void): ...\n    @AnnotationType.setter\n    def AnnotationType(self, value: System.Void): ...\n    @DimensionLinePoint.setter\n    def DimensionLinePoint(self, value: System.Void): ...\n    @ExtensionLine1End.setter\n    def ExtensionLine1End(self, value: System.Void): ...\n    @ExtensionLine2End.setter\n    def ExtensionLine2End(self, value: System.Void): ...\n    @overload\n    def SetLocations(self, extensionLine1End: Point2d, extensionLine2End: Point2d, pointOnDimensionLine: Point2d) -> None: ...\n\nclass AngularDimension(Dimension):\n    \"\"\"Represents a dimension of an entity that can be measured with an angle.\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, arc: Arc, offset: float): ...\n    @overload\n    def __init__(self, plane: Plane, horizontal: Vector3d, centerpoint: Point3d, defpoint1: Point3d, defpoint2: Point3d, dimlinepoint: Point3d): ...\n    @overload\n    def __init__(self, line1: Line, pointOnLine1: Point3d, line2: Line, pointOnLine2: Point3d, pointOnAngularDimensionArc: Point3d, bSetExtensionPoints: bool): ...\n    @overload\n    def __init__(self, plane: Plane, horizontal: Vector3d, extpoint1: Point3d, extpoint2: Point3d, dirpoint1: Point3d, dirpoint2: Point3d, dimlinepoint: Point3d): ...\n    @overload\n    def AdjustFromPoints(self, plane: Plane, centerpoint: Point3d, defpoint1: Point3d, defpoint2: Point3d, dimlinepoint: Point3d) -> bool: ...\n    @overload\n    def AdjustFromPoints(self, plane: Plane, extpoint1: Point3d, extpoint2: Point3d, dirpoint1: Point3d, dirpoint2: Point3d, dimlinepoint: Point3d) -> bool: ...\n    @overload\n    @staticmethod\n    def Create(dimStyle: DocObjects.DimensionStyle, plane: Plane, horizontal: Vector3d, centerpoint: Point3d, defpoint1: Point3d, defpoint2: Point3d, dimlinepoint: Point3d) -> AngularDimension: ...\n    @overload\n    @staticmethod\n    def Create(dimStyle: DocObjects.DimensionStyle, line1: Line, pointOnLine1: Point3d, line2: Line, pointOnLine2: Point3d, pointOnAngularDimensionArc: Point3d, bSetExtensionPoints: bool) -> AngularDimension: ...\n    @overload\n    @staticmethod\n    def Create(dimStyle: DocObjects.DimensionStyle, plane: Plane, horizontal: Vector3d, extpoint1: Point3d, extpoint2: Point3d, dirpoint1: Point3d, dirpoint2: Point3d, dimlinepoint: Point3d) -> AngularDimension: ...\n    @property\n    def AngleFormat(self) -> DocObjects.AngleDisplayFormat: ...\n    @property\n    def AngleResolution(self) -> int: ...\n    @property\n    def AngleRoundoff(self) -> float: ...\n    @property\n    def AngleZeroSuppression(self) -> DocObjects.ZeroSuppression: ...\n    @property\n    def ArrowPoint1(self) -> Point2d: ...\n    @property\n    def ArrowPoint2(self) -> Point2d: ...\n    @property\n    def CenterPoint(self) -> Point2d: ...\n    @property\n    def DefPoint1(self) -> Point2d: ...\n    @property\n    def DefPoint2(self) -> Point2d: ...\n    @property\n    def DimlinePoint(self) -> Point2d: ...\n    @overload\n    def Get3dPoints() -> (bool, Point3d, Point3d, Point3d, Point3d, Point3d, Point3d, Point3d): ...\n    @overload\n    def GetAngleDisplayText(self, style: DocObjects.DimensionStyle) -> str: ...\n    @overload\n    def GetDisplayLines(self, style: DocObjects.DimensionStyle, scale: float) -> (bool, System.Array[Line], System.Array[Arc]): ...\n    @overload\n    def GetTextRectangle() -> (bool, System.Array[Point3d]): ...\n    @AngleFormat.setter\n    def AngleFormat(self, value: System.Void): ...\n    @AngleResolution.setter\n    def AngleResolution(self, value: System.Void): ...\n    @AngleRoundoff.setter\n    def AngleRoundoff(self, value: System.Void): ...\n    @AngleZeroSuppression.setter\n    def AngleZeroSuppression(self, value: System.Void): ...\n    @CenterPoint.setter\n    def CenterPoint(self, value: System.Void): ...\n    @DefPoint1.setter\n    def DefPoint1(self, value: System.Void): ...\n    @DefPoint2.setter\n    def DefPoint2(self, value: System.Void): ...\n    @DimlinePoint.setter\n    def DimlinePoint(self, value: System.Void): ...\n\nclass RadialDimension(Dimension):\n    \"\"\"Represents a dimension of a circular entity that can be measured with radius or diameter.\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, dimtype: AnnotationType, plane: Plane, centerpoint: Point3d, radiuspoint: Point3d, dimlinepoint: Point3d): ...\n    @overload\n    def AdjustFromPoints(self, plane: Plane, centerpoint: Point3d, radiuspoint: Point3d, dimlinepoint: Point3d, rotationInPlane: float) -> bool: ...\n    @overload\n    @staticmethod\n    def Create(dimStyle: DocObjects.DimensionStyle, dimtype: AnnotationType, plane: Plane, centerpoint: Point3d, radiuspoint: Point3d, dimlinepoint: Point3d) -> RadialDimension: ...\n    @property\n    def AnnotationType(self) -> AnnotationType: ...\n    @property\n    def CenterPoint(self) -> Point2d: ...\n    @property\n    def DimlinePoint(self) -> Point2d: ...\n    @property\n    def IsDiameterDimension(self) -> bool: ...\n    @property\n    def KneePoint(self) -> Point2d: ...\n    @property\n    def LeaderArrowBlockId(self) -> System.Guid: ...\n    @property\n    def LeaderArrowSize(self) -> float: ...\n    @property\n    def LeaderArrowType(self) -> DocObjects.ArrowType: ...\n    @property\n    def LeaderCurveStyle(self) -> DocObjects.LeaderCurveStyle: ...\n    @property\n    def LeaderTextHorizontalAlignment(self) -> DocObjects.TextHorizontalAlignment: ...\n    @property\n    def RadiusPoint(self) -> Point2d: ...\n    @property\n    def TextAngleType(self) -> DocObjects.LeaderContentAngleStyle: ...\n    @property\n    def TextLocation(self) -> DocObjects.TextLocation: ...\n    @property\n    def TextOrientation(self) -> DocObjects.TextOrientation: ...\n    @overload\n    def Get3dPoints() -> (bool, Point3d, Point3d, Point3d, Point3d): ...\n    @overload\n    def GetDisplayLines(self, style: DocObjects.DimensionStyle, scale: float) -> (bool, Generic.IEnumerable): ...\n    @overload\n    def GetDistanceDisplayText(self, unitsystem: Rhino.UnitSystem, style: DocObjects.DimensionStyle) -> str: ...\n    @overload\n    def GetTextRectangle() -> (bool, System.Array[Point3d]): ...\n    @AnnotationType.setter\n    def AnnotationType(self, value: System.Void): ...\n    @CenterPoint.setter\n    def CenterPoint(self, value: System.Void): ...\n    @DimlinePoint.setter\n    def DimlinePoint(self, value: System.Void): ...\n    @LeaderArrowBlockId.setter\n    def LeaderArrowBlockId(self, value: System.Void): ...\n    @LeaderArrowSize.setter\n    def LeaderArrowSize(self, value: System.Void): ...\n    @LeaderArrowType.setter\n    def LeaderArrowType(self, value: System.Void): ...\n    @LeaderCurveStyle.setter\n    def LeaderCurveStyle(self, value: System.Void): ...\n    @LeaderTextHorizontalAlignment.setter\n    def LeaderTextHorizontalAlignment(self, value: System.Void): ...\n    @RadiusPoint.setter\n    def RadiusPoint(self, value: System.Void): ...\n    @TextAngleType.setter\n    def TextAngleType(self, value: System.Void): ...\n    @TextLocation.setter\n    def TextLocation(self, value: System.Void): ...\n    @TextOrientation.setter\n    def TextOrientation(self, value: System.Void): ...\n\nclass Centermark(Dimension):\n    \"\"\"Represents a center mark dimension.\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, plane: Plane, centerPoint: Point3d, radius: float): ...\n    @overload\n    def __init__(self, plane: Plane, curve: Curve, curveParameter: float): ...\n    @overload\n    def AdjustFromPoints(self, plane: Plane, centerPoint: Point3d) -> bool: ...\n    @overload\n    @staticmethod\n    def Create(dimStyle: DocObjects.DimensionStyle, plane: Plane, centerPoint: Point3d, radius: float) -> Centermark: ...\n    @overload\n    @staticmethod\n    def Create(dimStyle: DocObjects.DimensionStyle, plane: Plane, curve: Curve, curveParameter: float) -> Centermark: ...\n    @property\n    def Radius(self) -> float: ...\n    @Radius.setter\n    def Radius(self, value: System.Void): ...\n\nclass Hatch(GeometryBase):\n    \"\"\"Represents a hatch in planar boundary loop or loops. This is a 2d entity with a plane defining a local coordinate system. The loops, patterns, angles, etc are all in this local coordinate system. The Hatch object manages the plane and loop array Fill definitions are in the HatchPattern or class derived from HatchPattern Hatch has an index to get the pattern definition from the pattern table.\n\n    \"\"\"\n    @overload\n    @staticmethod\n    def Create(curves: Generic.IEnumerable, hatchPatternIndex: int, rotationRadians: float, scale: float, tolerance: float) -> System.Array[Hatch]: ...\n    @overload\n    @staticmethod\n    def Create(curve: Curve, hatchPatternIndex: int, rotationRadians: float, scale: float, tolerance: float) -> System.Array[Hatch]: ...\n    @overload\n    @staticmethod\n    def Create(hatchPlane: Plane, outerLoop: Curve, innerLoops: Generic.IEnumerable, hatchPatternIndex: int, rotationRadians: float, scale: float) -> Hatch: ...\n    @overload\n    def CreateDisplayGeometry(self, pattern: DocObjects.HatchPattern, patternScale: float) -> (System.Array[Curve], System.Array[Line], Brep): ...\n    @overload\n    @staticmethod\n    def CreateFromBrep(brep: Brep, brepFaceIndex: int, hatchPatternIndex: int, rotationRadians: float, scale: float, basePoint: Point3d) -> Hatch: ...\n    @overload\n    def Explode() -> System.Array[GeometryBase]: ...\n    @property\n    def BasePoint(self) -> Point3d: ...\n    @property\n    def PatternIndex(self) -> int: ...\n    @property\n    def PatternRotation(self) -> float: ...\n    @property\n    def PatternScale(self) -> float: ...\n    @property\n    def Plane(self) -> Plane: ...\n    @overload\n    def Get2dCurves(self, outer: bool) -> System.Array[Curve]: ...\n    @overload\n    def Get3dCurves(self, outer: bool) -> System.Array[Curve]: ...\n    @overload\n    def GetGradientFill() -> Display.ColorGradient: ...\n    @overload\n    def ScalePattern(self, xform: Transform) -> None: ...\n    @BasePoint.setter\n    def BasePoint(self, value: System.Void): ...\n    @PatternIndex.setter\n    def PatternIndex(self, value: System.Void): ...\n    @PatternRotation.setter\n    def PatternRotation(self, value: System.Void): ...\n    @PatternScale.setter\n    def PatternScale(self, value: System.Void): ...\n    @Plane.setter\n    def Plane(self, value: System.Void): ...\n    @overload\n    def SetGradientFill(self, fill: Display.ColorGradient) -> None: ...\n    @overload\n    def ToBrep() -> Brep: ...\n\nclass HiddenLineDrawingParameters(object):\n    \"\"\"Input used for computing a hidden line drawing\n\n    \"\"\"\n    def __init__(self): ...\n    @overload\n    def AddClippingPlane(self, plane: Plane) -> None: ...\n    @overload\n    def AddGeometry(self, geometry: GeometryBase, tag: object) -> bool: ...\n    @overload\n    def AddGeometry(self, geometry: GeometryBase, xform: Transform, tag: object) -> bool: ...\n    @overload\n    def AddGeometry(self, geometry: GeometryBase, tag: object, occluding_sections: bool) -> bool: ...\n    @overload\n    def AddGeometry(self, geometry: GeometryBase, xform: Transform, tag: object, occluding_sections: bool) -> bool: ...\n    @overload\n    def AddGeometryAndPlanes(self, geometry: GeometryBase, tag: object, clips: Generic.List) -> bool: ...\n    @overload\n    def AddGeometryAndPlanes(self, geometry: GeometryBase, xform: Transform, tag: object, clips: Generic.List) -> bool: ...\n    @overload\n    def AddGeometryAndPlanes(self, geometry: GeometryBase, tag: object, occluding_sections: bool, clips: Generic.List) -> bool: ...\n    @overload\n    def AddGeometryAndPlanes(self, geometry: GeometryBase, xform: Transform, tag: object, occluding_sections: bool, clips: Generic.List) -> bool: ...\n    @property\n    def AbsoluteTolerance(self) -> float: ...\n    @property\n    def Flatten(self) -> bool: ...\n    @property\n    def IncludeHiddenCurves(self) -> bool: ...\n    @property\n    def IncludeTangentEdges(self) -> bool: ...\n    @property\n    def IncludeTangentSeams(self) -> bool: ...\n    @property\n    def OccludingSectionOption(self) -> bool: ...\n    @AbsoluteTolerance.setter\n    def AbsoluteTolerance(self, value: System.Void): ...\n    @Flatten.setter\n    def Flatten(self, value: System.Void): ...\n    @IncludeHiddenCurves.setter\n    def IncludeHiddenCurves(self, value: System.Void): ...\n    @IncludeTangentEdges.setter\n    def IncludeTangentEdges(self, value: System.Void): ...\n    @IncludeTangentSeams.setter\n    def IncludeTangentSeams(self, value: System.Void): ...\n    @OccludingSectionOption.setter\n    def OccludingSectionOption(self, value: System.Void): ...\n    @overload\n    def SetViewport(self, viewport: Display.RhinoViewport) -> None: ...\n    @overload\n    def SetViewport(self, viewport: DocObjects.ViewportInfo) -> None: ...\n\nclass HiddenLineDrawing(object):\n    \"\"\"Represents a hidden line drawing object. A hidden line drawing consists of curves generated from source objects. The curves correspond to edges, and silhouettes of source objects and intersections with cutting planes.\n\n    \"\"\"\n    @overload\n    def BoundingBox(self, includeHidden: bool) -> BoundingBox: ...\n    @overload\n    @staticmethod\n    def Compute(parameters: HiddenLineDrawingParameters, multipleThreads: bool) -> HiddenLineDrawing: ...\n    @overload\n    @staticmethod\n    def Compute(parameters: HiddenLineDrawingParameters, multipleThreads: bool, progress: System.IProgress, cancelToken: Threading.CancellationToken) -> HiddenLineDrawing: ...\n    @overload\n    def Dispose() -> None: ...\n    @property\n    def Points(self) -> Generic.IEnumerable: ...\n    @property\n    def Segments(self) -> Generic.IEnumerable: ...\n    @property\n    def Viewport(self) -> DocObjects.ViewportInfo: ...\n    @property\n    def WorldToHiddenLine(self) -> Transform: ...\n    @overload\n    def RejoinCompatibleVisible() -> None: ...\n\nclass HiddenLineDrawingObject(object):\n    \"\"\"Represents an object added to a HiddenLineDrawing\n\n    \"\"\"\n    @property\n    def Geometry(self) -> GeometryBase: ...\n    @property\n    def OccludingSections(self) -> bool: ...\n    @property\n    def Tag(self) -> object: ...\n    @property\n    def Transform(self) -> Transform: ...\n    @OccludingSections.setter\n    def OccludingSections(self, value: System.Void): ...\n\nclass HiddenLineDrawingPoint(object):\n    \"\"\"Points generated from source objects which correspond to point and point cloud source objects.\n\n    \"\"\"\n    @property\n    def ClippingPlaneIndex(self) -> int: ...\n    @property\n    def Index(self) -> int: ...\n    @property\n    def Location(self) -> Point3d: ...\n    @property\n    def PointVisibility(self) -> Visibility: ...\n    @property\n    def SourceObject(self) -> HiddenLineDrawingObject: ...\n    @property\n    def SourceObjectComponentIndex(self) -> ComponentIndex: ...\n\nclass HiddenLineDrawingObjectCurve(object):\n    \"\"\"Curves generated from source objects which correspond to edges, and silhouettes of source objects and intersections with cutting planes. A HiddenLineDrawingObjectCurve is partitioned into hidden and visible segments called HiddenLineDrawingSegment\n\n    \"\"\"\n    @overload\n    def Curve(self, t: float) -> HiddenLineDrawingSegment: ...\n    @overload\n    def Curve(self, t: float, side: int) -> HiddenLineDrawingSegment: ...\n    @property\n    def ClippingPlaneIndex(self) -> int: ...\n    @property\n    def Index(self) -> int: ...\n    @property\n    def IsProjecting(self) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def OriginalDomainStart(self) -> float: ...\n    @property\n    def Parameters(self) -> System.System.Array[float]: ...\n    @property\n    def Segments(self) -> System.Array[HiddenLineDrawingSegment]: ...\n    @property\n    def SilhouetteType(self) -> SilhouetteType: ...\n    @property\n    def SourceObject(self) -> HiddenLineDrawingObject: ...\n    @property\n    def SourceObjectComponentIndex(self) -> ComponentIndex: ...\n\nclass HiddenLineDrawingSegment(object):\n    \"\"\"The results of HiddenLineDrawing calculation are a collection of segments. A segment is a sub-curve of a HiddenLineDrawingObjectCurve.\n\n    \"\"\"\n    @property\n    def CurveGeometry(self) -> Curve: ...\n    @property\n    def CurveSideFills(self) -> System.Array[SideFill]: ...\n    @property\n    def Index(self) -> int: ...\n    @property\n    def IsSceneSilhouette(self) -> bool: ...\n    @property\n    def ParentCurve(self) -> HiddenLineDrawingObjectCurve: ...\n    @property\n    def SegmentVisibility(self) -> Visibility: ...\n\nclass InstanceDefinitionGeometry(DocObjects.ModelComponent):\n    \"\"\"Represents a block definition in a File3dm. This is the same as Rhino.DocObjects.InstanceDefinition, but not associated with a RhinoDoc.\n\n    \"\"\"\n    def __init__(self): ...\n    @overload\n    def DeleteAllUserStrings() -> None: ...\n    @overload\n    def DeleteUserString(self, key: str) -> bool: ...\n    @property\n    def ComponentType(self) -> DocObjects.ModelComponentType: ...\n    @property\n    def Description(self) -> str: ...\n    @property\n    def SourceArchive(self) -> str: ...\n    @property\n    def Url(self) -> str: ...\n    @property\n    def UrlDescription(self) -> str: ...\n    @property\n    def UserStringCount(self) -> int: ...\n    @overload\n    def GetObjectIds() -> System.System.Array[System.Guid]: ...\n    @overload\n    def GetUserString(self, key: str) -> str: ...\n    @overload\n    def GetUserStrings() -> Specialized.NameValueCollection: ...\n    @Description.setter\n    def Description(self, value: System.Void): ...\n    @Url.setter\n    def Url(self, value: System.Void): ...\n    @UrlDescription.setter\n    def UrlDescription(self, value: System.Void): ...\n    @overload\n    def SetUserString(self, key: str, value: str) -> bool: ...\n\nclass InstanceReferenceGeometry(GeometryBase):\n    \"\"\"Represents a reference to the geometry in a block definition.\n\n    \"\"\"\n    def __init__(self, instanceDefinitionId: System.Guid, transform: Transform): ...\n    @property\n    def ParentIdefId(self) -> System.Guid: ...\n    @property\n    def Xform(self) -> Transform: ...\n\nclass Arrowhead(object):\n    \"\"\"Arrowhead used by annotation\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, arrowType: DocObjects.ArrowType, blockId: System.Guid): ...\n    @property\n    def ArrowType(self) -> DocObjects.ArrowType: ...\n    @property\n    def BlockId(self) -> System.Guid: ...\n\nclass Leader(AnnotationBase):\n    \"\"\"Leader geometry class\n\n    \"\"\"\n    def __init__(self): ...\n    @overload\n    @staticmethod\n    def Create(text: str, plane: Plane, dimstyle: DocObjects.DimensionStyle, points: System.Array[Point3d]) -> Leader: ...\n    @overload\n    @staticmethod\n    def CreateWithRichText(richText: str, plane: Plane, dimstyle: DocObjects.DimensionStyle, points: System.Array[Point3d]) -> Leader: ...\n    @overload\n    def Explode() -> System.Array[GeometryBase]: ...\n    @property\n    def Curve(self) -> NurbsCurve: ...\n    @property\n    def LeaderArrowBlockId(self) -> System.Guid: ...\n    @property\n    def LeaderArrowSize(self) -> float: ...\n    @property\n    def LeaderArrowType(self) -> DocObjects.ArrowType: ...\n    @property\n    def LeaderContentAngleStyle(self) -> DocObjects.LeaderContentAngleStyle: ...\n    @property\n    def LeaderCurveStyle(self) -> DocObjects.LeaderCurveStyle: ...\n    @property\n    def LeaderHasLanding(self) -> bool: ...\n    @property\n    def LeaderLandingLength(self) -> float: ...\n    @property\n    def LeaderTextHorizontalAlignment(self) -> DocObjects.TextHorizontalAlignment: ...\n    @property\n    def LeaderTextVerticalAlignment(self) -> DocObjects.TextVerticalAlignment: ...\n    @property\n    def Points2D(self) -> System.Array[Point2d]: ...\n    @property\n    def Points3D(self) -> System.Array[Point3d]: ...\n    @LeaderArrowBlockId.setter\n    def LeaderArrowBlockId(self, value: System.Void): ...\n    @LeaderArrowSize.setter\n    def LeaderArrowSize(self, value: System.Void): ...\n    @LeaderArrowType.setter\n    def LeaderArrowType(self, value: System.Void): ...\n    @LeaderContentAngleStyle.setter\n    def LeaderContentAngleStyle(self, value: System.Void): ...\n    @LeaderCurveStyle.setter\n    def LeaderCurveStyle(self, value: System.Void): ...\n    @LeaderHasLanding.setter\n    def LeaderHasLanding(self, value: System.Void): ...\n    @LeaderLandingLength.setter\n    def LeaderLandingLength(self, value: System.Void): ...\n    @LeaderTextHorizontalAlignment.setter\n    def LeaderTextHorizontalAlignment(self, value: System.Void): ...\n    @LeaderTextVerticalAlignment.setter\n    def LeaderTextVerticalAlignment(self, value: System.Void): ...\n    @Points2D.setter\n    def Points2D(self, value: System.Void): ...\n    @Points3D.setter\n    def Points3D(self, value: System.Void): ...\n\nclass Light(GeometryBase):\n    \"\"\"Represents a light that shines in the modeling space.\n\n    \"\"\"\n    def __init__(self): ...\n    @property\n    def ConstantAttenuationVector(self) -> Vector3d: ...\n    @property\n    def LinearAttenuationVector(self) -> Vector3d: ...\n    @property\n    def InverseSquaredAttenuationVector(self) -> Vector3d: ...\n    @overload\n    @staticmethod\n    def CreateSunLight(sun: Render.Sun) -> Light: ...\n    @overload\n    @staticmethod\n    def CreateSunLight(northAngleDegrees: float, azimuthDegrees: float, altitudeDegrees: float) -> Light: ...\n    @overload\n    @staticmethod\n    def CreateSunLight(northAngleDegrees: float, when: System.DateTime, latitudeDegrees: float, longitudeDegrees: float) -> Light: ...\n    @property\n    def Ambient(self) -> Drawing.Color: ...\n    @property\n    def AttenuationType(self) -> Attenuation: ...\n    @property\n    def AttenuationVector(self) -> Vector3d: ...\n    @property\n    def CoordinateSystem(self) -> DocObjects.CoordinateSystem: ...\n    @property\n    def Diffuse(self) -> Drawing.Color: ...\n    @property\n    def Direction(self) -> Vector3d: ...\n    @property\n    def HotSpot(self) -> float: ...\n    @property\n    def Id(self) -> System.Guid: ...\n    @property\n    def Intensity(self) -> float: ...\n    @property\n    def IsDirectionalLight(self) -> bool: ...\n    @property\n    def IsEnabled(self) -> bool: ...\n    @property\n    def IsLinearLight(self) -> bool: ...\n    @property\n    def IsPointLight(self) -> bool: ...\n    @property\n    def IsRectangularLight(self) -> bool: ...\n    @property\n    def IsSpotLight(self) -> bool: ...\n    @property\n    def IsSunLight(self) -> bool: ...\n    @property\n    def Length(self) -> Vector3d: ...\n    @property\n    def LightStyle(self) -> LightStyle: ...\n    @property\n    def Location(self) -> Point3d: ...\n    @property\n    def Name(self) -> str: ...\n    @property\n    def PerpendicularDirection(self) -> Vector3d: ...\n    @property\n    def PowerCandela(self) -> float: ...\n    @property\n    def PowerLumens(self) -> float: ...\n    @property\n    def PowerWatts(self) -> float: ...\n    @property\n    def ShadowIntensity(self) -> float: ...\n    @property\n    def Specular(self) -> Drawing.Color: ...\n    @property\n    def SpotAngleRadians(self) -> float: ...\n    @property\n    def SpotExponent(self) -> float: ...\n    @property\n    def SpotLightShadowIntensity(self) -> float: ...\n    @property\n    def Width(self) -> Vector3d: ...\n    @overload\n    def GetAttenuation(self, d: float) -> float: ...\n    @overload\n    def GetSpotLightRadii() -> (bool, float, float): ...\n    @Ambient.setter\n    def Ambient(self, value: System.Void): ...\n    @AttenuationType.setter\n    def AttenuationType(self, value: System.Void): ...\n    @AttenuationVector.setter\n    def AttenuationVector(self, value: System.Void): ...\n    @Diffuse.setter\n    def Diffuse(self, value: System.Void): ...\n    @Direction.setter\n    def Direction(self, value: System.Void): ...\n    @HotSpot.setter\n    def HotSpot(self, value: System.Void): ...\n    @Id.setter\n    def Id(self, value: System.Void): ...\n    @Intensity.setter\n    def Intensity(self, value: System.Void): ...\n    @IsEnabled.setter\n    def IsEnabled(self, value: System.Void): ...\n    @Length.setter\n    def Length(self, value: System.Void): ...\n    @LightStyle.setter\n    def LightStyle(self, value: System.Void): ...\n    @Location.setter\n    def Location(self, value: System.Void): ...\n    @Name.setter\n    def Name(self, value: System.Void): ...\n    @PowerCandela.setter\n    def PowerCandela(self, value: System.Void): ...\n    @PowerLumens.setter\n    def PowerLumens(self, value: System.Void): ...\n    @PowerWatts.setter\n    def PowerWatts(self, value: System.Void): ...\n    @ShadowIntensity.setter\n    def ShadowIntensity(self, value: System.Void): ...\n    @Specular.setter\n    def Specular(self, value: System.Void): ...\n    @SpotAngleRadians.setter\n    def SpotAngleRadians(self, value: System.Void): ...\n    @SpotExponent.setter\n    def SpotExponent(self, value: System.Void): ...\n    @SpotLightShadowIntensity.setter\n    def SpotLightShadowIntensity(self, value: System.Void): ...\n    @Width.setter\n    def Width(self, value: System.Void): ...\n    @overload\n    def SetAttenuation(self, a0: float, a1: float, a2: float) -> None: ...\n\nclass LineCurve(Curve):\n    \"\"\"Represents a linear curve.\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, other: LineCurve): ...\n    @overload\n    def __init__(self, line: Line): ...\n    @overload\n    def __init__(self, from_: Point2d, to: Point2d): ...\n    @overload\n    def __init__(self, from_: Point3d, to: Point3d): ...\n    @overload\n    def __init__(self, line: Line, t0: float, t1: float): ...\n    @property\n    def Line(self) -> Line: ...\n    @Line.setter\n    def Line(self, value: System.Void): ...\n\nclass AreaMassProperties(object):\n    \"\"\"Contains static initialization methods and allows access to the computed metrics of area, area centroid and area moments in closed planar curves, in meshes, in surfaces, in hatches and in boundary representations.\n\n    \"\"\"\n    @overload\n    def CentroidCoordinatesPrincipalMoments() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...\n    @overload\n    def CentroidCoordinatesPrincipalMomentsOfInertia() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...\n    @overload\n    @staticmethod\n    def Compute(closedPlanarCurve: Curve) -> AreaMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(hatch: Hatch) -> AreaMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(mesh: Mesh) -> AreaMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(brep: Brep) -> AreaMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(surface: Surface) -> AreaMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(geometry: Generic.IEnumerable) -> AreaMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(closedPlanarCurve: Curve, planarTolerance: float) -> AreaMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(mesh: Mesh, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(brep: Brep, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(surface: Surface, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(geometry: Generic.IEnumerable, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(brep: Brep, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool, relativeTolerance: float, absoluteTolerance: float) -> AreaMassProperties: ...\n    @overload\n    def Dispose() -> None: ...\n    @property\n    def Area(self) -> float: ...\n    @property\n    def AreaError(self) -> float: ...\n    @property\n    def Centroid(self) -> Point3d: ...\n    @property\n    def CentroidCoordinatesMomentsOfInertia(self) -> Vector3d: ...\n    @property\n    def CentroidCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...\n    @property\n    def CentroidCoordinatesProductMoments(self) -> Vector3d: ...\n    @property\n    def CentroidCoordinatesProductMomentsError(self) -> Vector3d: ...\n    @property\n    def CentroidCoordinatesRadiiOfGyration(self) -> Vector3d: ...\n    @property\n    def CentroidCoordinatesSecondMoments(self) -> Vector3d: ...\n    @property\n    def CentroidCoordinatesSecondMomentsError(self) -> Vector3d: ...\n    @property\n    def CentroidError(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesFirstMoments(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesFirstMomentsError(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesMomentsOfInertia(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesProductMoments(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesProductMomentsError(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesRadiiOfGyration(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesSecondMoments(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesSecondMomentsError(self) -> Vector3d: ...\n    @overload\n    def WorldCoordinatesPrincipalMoments() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...\n    @overload\n    def WorldCoordinatesPrincipalMomentsOfInertia() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...\n\nclass VolumeMassProperties(object):\n    \"\"\"Contains static initialization methods and allows access to the computed metrics of volume, volume centroid and volume moments in in solid meshes, in solid surfaces and in solid (closed) boundary representations.\n\n    \"\"\"\n    @overload\n    def CentroidCoordinatesPrincipalMoments() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...\n    @overload\n    def CentroidCoordinatesPrincipalMomentsOfInertia() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...\n    @overload\n    @staticmethod\n    def Compute(mesh: Mesh) -> VolumeMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(brep: Brep) -> VolumeMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(surface: Surface) -> VolumeMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(geometry: Generic.IEnumerable) -> VolumeMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(mesh: Mesh, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(brep: Brep, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(surface: Surface, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(geometry: Generic.IEnumerable, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(brep: Brep, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool, relativeTolerance: float, absoluteTolerance: float) -> VolumeMassProperties: ...\n    @overload\n    def Dispose() -> None: ...\n    @property\n    def Centroid(self) -> Point3d: ...\n    @property\n    def CentroidCoordinatesMomentsOfInertia(self) -> Vector3d: ...\n    @property\n    def CentroidCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...\n    @property\n    def CentroidCoordinatesProductMoments(self) -> Vector3d: ...\n    @property\n    def CentroidCoordinatesProductMomentsError(self) -> Vector3d: ...\n    @property\n    def CentroidCoordinatesRadiiOfGyration(self) -> Vector3d: ...\n    @property\n    def CentroidCoordinatesSecondMoments(self) -> Vector3d: ...\n    @property\n    def CentroidCoordinatesSecondMomentsError(self) -> Vector3d: ...\n    @property\n    def CentroidError(self) -> Vector3d: ...\n    @property\n    def Volume(self) -> float: ...\n    @property\n    def VolumeError(self) -> float: ...\n    @property\n    def WorldCoordinatesFirstMoments(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesFirstMomentsError(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesMomentsOfInertia(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesProductMoments(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesProductMomentsError(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesRadiiOfGyration(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesSecondMoments(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesSecondMomentsError(self) -> Vector3d: ...\n    @overload\n    def Sum(self, summand: VolumeMassProperties) -> bool: ...\n    @overload\n    def Transform(self, xform: Transform) -> bool: ...\n    @overload\n    def WorldCoordinatesPrincipalMoments() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...\n    @overload\n    def WorldCoordinatesPrincipalMomentsOfInertia() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...\n\nclass LengthMassProperties(object):\n    \"\"\"Contains static initialization methods and allows access to the computed metrics of length, length centroid, and length moments in curves.\n\n    \"\"\"\n    @overload\n    def CentroidCoordinatesPrincipalMoments() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...\n    @overload\n    def CentroidCoordinatesPrincipalMomentsOfInertia() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...\n    @overload\n    @staticmethod\n    def Compute(curve: Curve) -> LengthMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(curves: Generic.IEnumerable) -> LengthMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(curve: Curve, length: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> LengthMassProperties: ...\n    @overload\n    @staticmethod\n    def Compute(curves: Generic.IEnumerable, length: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> LengthMassProperties: ...\n    @overload\n    def Dispose() -> None: ...\n    @property\n    def Centroid(self) -> Point3d: ...\n    @property\n    def CentroidCoordinatesMomentsOfInertia(self) -> Vector3d: ...\n    @property\n    def CentroidCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...\n    @property\n    def CentroidCoordinatesProductMoments(self) -> Vector3d: ...\n    @property\n    def CentroidCoordinatesProductMomentsError(self) -> Vector3d: ...\n    @property\n    def CentroidCoordinatesRadiiOfGyration(self) -> Vector3d: ...\n    @property\n    def CentroidCoordinatesSecondMoments(self) -> Vector3d: ...\n    @property\n    def CentroidCoordinatesSecondMomentsError(self) -> Vector3d: ...\n    @property\n    def CentroidError(self) -> Vector3d: ...\n    @property\n    def Length(self) -> float: ...\n    @property\n    def LengthError(self) -> float: ...\n    @property\n    def WorldCoordinatesFirstMoments(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesFirstMomentsError(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesMomentsOfInertia(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesProductMoments(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesProductMomentsError(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesRadiiOfGyration(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesSecondMoments(self) -> Vector3d: ...\n    @property\n    def WorldCoordinatesSecondMomentsError(self) -> Vector3d: ...\n    @overload\n    def WorldCoordinatesPrincipalMoments() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...\n    @overload\n    def WorldCoordinatesPrincipalMomentsOfInertia() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...\n\nclass Matrix(object):\n    \"\"\"Represents an arbitrarily sized matrix of\ndouble\n-precision floating point numbers. If you are working with a 4x4 matrix, then you may want to use the\nclass instead.\n\n    \"\"\"\n    @overload\n    def __init__(self, xform: Transform): ...\n    @overload\n    def __init__(self, rowCount: int, columnCount: int): ...\n    @overload\n    def BackSolve(self, zeroTolerance: float, b: System.System.Array[float]) -> System.System.Array[float]: ...\n    @overload\n    def BackSolvePoints(self, zeroTolerance: float, b: System.Array[Point3d]) -> System.Array[Point3d]: ...\n    @overload\n    def Dispose() -> None: ...\n    @overload\n    def Duplicate() -> Matrix: ...\n    @property\n    def ColumnCount(self) -> int: ...\n    @property\n    def IsColumnOrthogonal(self) -> bool: ...\n    @property\n    def IsColumnOrthoNormal(self) -> bool: ...\n    @property\n    def IsRowOrthogonal(self) -> bool: ...\n    @property\n    def IsRowOrthoNormal(self) -> bool: ...\n    @property\n    def IsSquare(self) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Item(self) -> float: ...\n    @property\n    def RowCount(self) -> int: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    def Invert(self, zeroTolerance: float) -> bool: ...\n    @overload\n    def RowReduce(self, zeroTolerance: float, b: System.Array[Point3d]) -> (int, float): ...\n    @overload\n    def RowReduce(self, zeroTolerance: float, b: System.System.Array[float]) -> (int, float): ...\n    @overload\n    def RowReduce(self, zeroTolerance: float) -> (int, float, float): ...\n    @overload\n    def Scale(self, s: float) -> None: ...\n    @Item.setter\n    def Item(self, value: System.Void): ...\n    @overload\n    def SetDiagonal(self, d: float) -> None: ...\n    @overload\n    def SwapColumns(self, columnA: int, columnB: int) -> bool: ...\n    @overload\n    def SwapRows(self, rowA: int, rowB: int) -> bool: ...\n    @overload\n    def Transpose() -> bool: ...\n    @overload\n    def Zero() -> None: ...\n\nclass MeshingParameterStyle(enum.Enum):\n    None_ = 0\n    Fast = 1\n    Quality = 2\n    Custom = 9\n    PerObject = 10\n\nclass SmoothingCoordinateSystem(enum.Enum):\n    World = 0\n    CPlane = 1\n    Object = 2\n\nclass MeshCheckParameters(System.ValueType):\n    \"\"\"Output of a mesh checking operations.\n\n    \"\"\"\n    @overload\n    @staticmethod\n    def Defaults() -> MeshCheckParameters: ...\n    @property\n    def CheckForBadNormals(self) -> bool: ...\n    @property\n    def CheckForDegenerateFaces(self) -> bool: ...\n    @property\n    def CheckForDisjointMeshes(self) -> bool: ...\n    @property\n    def CheckForDuplicateFaces(self) -> bool: ...\n    @property\n    def CheckForExtremelyShortEdges(self) -> bool: ...\n    @property\n    def CheckForInvalidNgons(self) -> bool: ...\n    @property\n    def CheckForNakedEdges(self) -> bool: ...\n    @property\n    def CheckForNonManifoldEdges(self) -> bool: ...\n    @property\n    def CheckForRandomFaceNormals(self) -> bool: ...\n    @property\n    def CheckForSelfIntersection(self) -> bool: ...\n    @property\n    def CheckForUnusedVertices(self) -> bool: ...\n    @property\n    def DegenerateFaceCount(self) -> int: ...\n    @property\n    def DisjointMeshCount(self) -> int: ...\n    @property\n    def DuplicateFaceCount(self) -> int: ...\n    @property\n    def ExtremelyShortEdgeCount(self) -> int: ...\n    @property\n    def InvalidNgonCount(self) -> int: ...\n    @property\n    def NakedEdgeCount(self) -> int: ...\n    @property\n    def NonManifoldEdgeCount(self) -> int: ...\n    @property\n    def NonUnitVectorNormalCount(self) -> int: ...\n    @property\n    def RandomFaceNormalCount(self) -> int: ...\n    @property\n    def SelfIntersectingPairsCount(self) -> int: ...\n    @property\n    def UnusedVertexCount(self) -> int: ...\n    @property\n    def VertexFaceNormalsDifferCount(self) -> int: ...\n    @property\n    def ZeroLengthNormalCount(self) -> int: ...\n    @CheckForBadNormals.setter\n    def CheckForBadNormals(self, value: System.Void): ...\n    @CheckForDegenerateFaces.setter\n    def CheckForDegenerateFaces(self, value: System.Void): ...\n    @CheckForDisjointMeshes.setter\n    def CheckForDisjointMeshes(self, value: System.Void): ...\n    @CheckForDuplicateFaces.setter\n    def CheckForDuplicateFaces(self, value: System.Void): ...\n    @CheckForExtremelyShortEdges.setter\n    def CheckForExtremelyShortEdges(self, value: System.Void): ...\n    @CheckForInvalidNgons.setter\n    def CheckForInvalidNgons(self, value: System.Void): ...\n    @CheckForNakedEdges.setter\n    def CheckForNakedEdges(self, value: System.Void): ...\n    @CheckForNonManifoldEdges.setter\n    def CheckForNonManifoldEdges(self, value: System.Void): ...\n    @CheckForRandomFaceNormals.setter\n    def CheckForRandomFaceNormals(self, value: System.Void): ...\n    @CheckForSelfIntersection.setter\n    def CheckForSelfIntersection(self, value: System.Void): ...\n    @CheckForUnusedVertices.setter\n    def CheckForUnusedVertices(self, value: System.Void): ...\n\nclass MeshingParameterTextureRange(enum.Enum):\n    Unset = 0\n    UnpackedUnscaledNormalized = 1\n    PackedScaledNormalized = 2\n\nclass SubDDisplayParameters(object):\n    \"\"\"A collection of parameters that are passed to functions that calculate a various representations of SubD objects.\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, info: Serialization.SerializationInfo, context: Serialization.StreamingContext): ...\n    @overload\n    @staticmethod\n    def AbsoluteDisplayDensityFromSubD(adaptiveSubDDisplayDensity: System.UInt32, subd: SubD) -> System.UInt32: ...\n    @overload\n    @staticmethod\n    def AbsoluteDisplayDensityFromSubDFaceCount(adaptiveSubDDisplayDensity: System.UInt32, subDFaceCount: System.UInt32) -> System.UInt32: ...\n    @overload\n    @staticmethod\n    def ClampDisplayDensity(displayDensity: System.UInt32) -> System.UInt32: ...\n    @overload\n    @staticmethod\n    def Coarse() -> SubDDisplayParameters: ...\n    @overload\n    @staticmethod\n    def CreateFromAbsoluteDisplayDensity(absoluteSubDDisplayDensity: System.UInt32) -> SubDDisplayParameters: ...\n    @overload\n    @staticmethod\n    def CreateFromDisplayDensity(adaptiveSubDDisplayDensity: System.UInt32) -> SubDDisplayParameters: ...\n    @overload\n    @staticmethod\n    def CreateFromMeshDensity(normalizedMeshDensity: float) -> SubDDisplayParameters: ...\n    @overload\n    @staticmethod\n    def Default() -> SubDDisplayParameters: ...\n    @overload\n    def DisplayDensity(self, subd: SubD) -> System.UInt32: ...\n    @overload\n    def Dispose() -> None: ...\n    @overload\n    @staticmethod\n    def Empty() -> SubDDisplayParameters: ...\n    @overload\n    @staticmethod\n    def ExtraCoarse() -> SubDDisplayParameters: ...\n    @overload\n    @staticmethod\n    def ExtraFine() -> SubDDisplayParameters: ...\n    @overload\n    @staticmethod\n    def Fine() -> SubDDisplayParameters: ...\n    @overload\n    @staticmethod\n    def FromEncodedString(value: str) -> SubDDisplayParameters: ...\n    @property\n    def AdaptiveDisplayMeshQuadMaximum(self) -> System.UInt32: ...\n    @property\n    def DisplayDensityIsAbsolute(self) -> bool: ...\n    @property\n    def DisplayDensityIsAdaptive(self) -> bool: ...\n    @property\n    def MeshLocation(self) -> SubDComponentLocation: ...\n    @overload\n    def GetObjectData(self, info: Serialization.SerializationInfo, context: Serialization.StreamingContext) -> None: ...\n    @overload\n    @staticmethod\n    def Medium() -> SubDDisplayParameters: ...\n    @MeshLocation.setter\n    def MeshLocation(self, value: System.Void): ...\n    @overload\n    def SetAbsoluteDisplayDensity(self, absoluteDisplayDensity: System.UInt32) -> None: ...\n    @overload\n    def SetAdaptiveDisplayDensity(self, adaptiveDisplayDensity: System.UInt32) -> None: ...\n    @overload\n    def ToEncodedString() -> str: ...\n\nclass MeshingParameters(object):\n    \"\"\"Represents settings used for creating a mesh representation of a brep or surface.\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, source: MeshingParameters): ...\n    @overload\n    def __init__(self, density: float): ...\n    @overload\n    def __init__(self, density: float, minimumEdgeLength: float): ...\n    @overload\n    def __init__(self, info: Serialization.SerializationInfo, context: Serialization.StreamingContext): ...\n    @overload\n    def CopyFrom(self, source: MeshingParameters) -> None: ...\n    @overload\n    def Dispose() -> None: ...\n    @overload\n    @staticmethod\n    def DocumentCurrentSetting(doc: Rhino.RhinoDoc) -> MeshingParameters: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @overload\n    def Equals(self, other: MeshingParameters) -> bool: ...\n    @overload\n    @staticmethod\n    def FromEncodedString(value: str) -> MeshingParameters: ...\n    @property\n    def ClosedObjectPostProcess(self) -> bool: ...\n    @property\n    def Coarse(self) -> MeshingParameters: ...\n    @property\n    def ComputeCurvature(self) -> bool: ...\n    @property\n    def Default(self) -> MeshingParameters: ...\n    @property\n    def DefaultAnalysisMesh(self) -> MeshingParameters: ...\n    @property\n    def DoublePrecision(self) -> bool: ...\n    @property\n    def FastRenderMesh(self) -> MeshingParameters: ...\n    @property\n    def GridAmplification(self) -> float: ...\n    @property\n    def GridAngle(self) -> float: ...\n    @property\n    def GridAspectRatio(self) -> float: ...\n    @property\n    def GridMaxCount(self) -> int: ...\n    @property\n    def GridMinCount(self) -> int: ...\n    @property\n    def JaggedSeams(self) -> bool: ...\n    @property\n    def MaximumEdgeLength(self) -> float: ...\n    @property\n    def Minimal(self) -> MeshingParameters: ...\n    @property\n    def MinimumEdgeLength(self) -> float: ...\n    @property\n    def MinimumTolerance(self) -> float: ...\n    @property\n    def QualityRenderMesh(self) -> MeshingParameters: ...\n    @property\n    def RefineAngle(self) -> float: ...\n    @property\n    def RefineAngleInDegrees(self) -> float: ...\n    @property\n    def RefineGrid(self) -> bool: ...\n    @property\n    def RelativeTolerance(self) -> float: ...\n    @property\n    def SimplePlanes(self) -> bool: ...\n    @property\n    def Smooth(self) -> MeshingParameters: ...\n    @property\n    def TextureRange(self) -> MeshingParameterTextureRange: ...\n    @property\n    def Tolerance(self) -> float: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    def GetObjectData(self, info: Serialization.SerializationInfo, context: Serialization.StreamingContext) -> None: ...\n    @ClosedObjectPostProcess.setter\n    def ClosedObjectPostProcess(self, value: System.Void): ...\n    @ComputeCurvature.setter\n    def ComputeCurvature(self, value: System.Void): ...\n    @DoublePrecision.setter\n    def DoublePrecision(self, value: System.Void): ...\n    @GridAmplification.setter\n    def GridAmplification(self, value: System.Void): ...\n    @GridAngle.setter\n    def GridAngle(self, value: System.Void): ...\n    @GridAspectRatio.setter\n    def GridAspectRatio(self, value: System.Void): ...\n    @GridMaxCount.setter\n    def GridMaxCount(self, value: System.Void): ...\n    @GridMinCount.setter\n    def GridMinCount(self, value: System.Void): ...\n    @JaggedSeams.setter\n    def JaggedSeams(self, value: System.Void): ...\n    @MaximumEdgeLength.setter\n    def MaximumEdgeLength(self, value: System.Void): ...\n    @MinimumEdgeLength.setter\n    def MinimumEdgeLength(self, value: System.Void): ...\n    @MinimumTolerance.setter\n    def MinimumTolerance(self, value: System.Void): ...\n    @RefineAngle.setter\n    def RefineAngle(self, value: System.Void): ...\n    @RefineAngleInDegrees.setter\n    def RefineAngleInDegrees(self, value: System.Void): ...\n    @RefineGrid.setter\n    def RefineGrid(self, value: System.Void): ...\n    @RelativeTolerance.setter\n    def RelativeTolerance(self, value: System.Void): ...\n    @SimplePlanes.setter\n    def SimplePlanes(self, value: System.Void): ...\n    @TextureRange.setter\n    def TextureRange(self, value: System.Void): ...\n    @Tolerance.setter\n    def Tolerance(self, value: System.Void): ...\n    @overload\n    def SetSubDDisplayParameters(self, subDDisplayParameters: SubDDisplayParameters) -> None: ...\n    @overload\n    def SubDDisplayParameters() -> SubDDisplayParameters: ...\n    @overload\n    def ToEncodedString() -> str: ...\n\nclass MeshPart(object):\n    \"\"\"Represents a portion of a mesh for partitioning\n\n    \"\"\"\n    @property\n    def EndFaceIndex(self) -> int: ...\n    @property\n    def EndVertexIndex(self) -> int: ...\n    @property\n    def StartFaceIndex(self) -> int: ...\n    @property\n    def StartVertexIndex(self) -> int: ...\n    @property\n    def TriangleCount(self) -> int: ...\n    @property\n    def VertexCount(self) -> int: ...\n\nclass MeshThicknessMeasurement(System.ValueType):\n    \"\"\"Thickness measurement used in the mesh thickness solver.\n\n    \"\"\"\n    def __init__(self, meshIndex: int, vertexIndex: int, thickness: float, point: Point3d, oppositePoint: Point3d): ...\n    @property\n    def MeshIndex(self) -> int: ...\n    @property\n    def OppositePoint(self) -> Point3d: ...\n    @property\n    def Point(self) -> Point3d: ...\n    @property\n    def Thickness(self) -> float: ...\n    @property\n    def VertexIndex(self) -> int: ...\n\nclass ReduceMeshParameters(object):\n    \"\"\"Parameters for Reduce method\n\n    \"\"\"\n    def __init__(self): ...\n    @property\n    def Accuracy(self) -> int: ...\n    @property\n    def AllowDistortion(self) -> bool: ...\n    @property\n    def CancelToken(self) -> Threading.CancellationToken: ...\n    @property\n    def DesiredPolygonCount(self) -> int: ...\n    @property\n    def Error(self) -> str: ...\n    @property\n    def FaceTags(self) -> System.System.Array[int]: ...\n    @property\n    def LockedComponents(self) -> System.Array[ComponentIndex]: ...\n    @property\n    def NormalizeMeshSize(self) -> bool: ...\n    @property\n    def ProgressReporter(self) -> System.IProgress: ...\n    @Accuracy.setter\n    def Accuracy(self, value: System.Void): ...\n    @AllowDistortion.setter\n    def AllowDistortion(self, value: System.Void): ...\n    @CancelToken.setter\n    def CancelToken(self, value: System.Void): ...\n    @DesiredPolygonCount.setter\n    def DesiredPolygonCount(self, value: System.Void): ...\n    @FaceTags.setter\n    def FaceTags(self, value: System.Void): ...\n    @LockedComponents.setter\n    def LockedComponents(self, value: System.Void): ...\n    @NormalizeMeshSize.setter\n    def NormalizeMeshSize(self, value: System.Void): ...\n    @ProgressReporter.setter\n    def ProgressReporter(self, value: System.Void): ...\n\nclass QuadRemeshParameters(object):\n    \"\"\"Parameters for QuadRemesh method\n\n    \"\"\"\n    def __init__(self): ...\n    @property\n    def AdaptiveQuadCount(self) -> bool: ...\n    @property\n    def AdaptiveSize(self) -> float: ...\n    @property\n    def DetectHardEdges(self) -> bool: ...\n    @property\n    def GuideCurveInfluence(self) -> int: ...\n    @property\n    def PreserveMeshArrayEdgesMode(self) -> int: ...\n    @property\n    def SymmetryAxis(self) -> QuadRemeshSymmetryAxis: ...\n    @property\n    def TargetEdgeLength(self) -> float: ...\n    @property\n    def TargetQuadCount(self) -> int: ...\n    @AdaptiveQuadCount.setter\n    def AdaptiveQuadCount(self, value: System.Void): ...\n    @AdaptiveSize.setter\n    def AdaptiveSize(self, value: System.Void): ...\n    @DetectHardEdges.setter\n    def DetectHardEdges(self, value: System.Void): ...\n    @GuideCurveInfluence.setter\n    def GuideCurveInfluence(self, value: System.Void): ...\n    @PreserveMeshArrayEdgesMode.setter\n    def PreserveMeshArrayEdgesMode(self, value: System.Void): ...\n    @SymmetryAxis.setter\n    def SymmetryAxis(self, value: System.Void): ...\n    @TargetEdgeLength.setter\n    def TargetEdgeLength(self, value: System.Void): ...\n    @TargetQuadCount.setter\n    def TargetQuadCount(self, value: System.Void): ...\n\nclass QuadRemeshSymmetryAxis(enum.Enum):\n    None_ = 0\n    X = 1\n    Y = 2\n    Z = 4\n\nclass ShrinkWrapParameters(object):\n    \"\"\"Parameters for ShrinkWrap method\n\n    \"\"\"\n    def __init__(self): ...\n    @property\n    def FillHolesInInputObjects(self) -> bool: ...\n    @property\n    def InflateVerticesAndPoints(self) -> bool: ...\n    @property\n    def Offset(self) -> float: ...\n    @property\n    def PolygonOptimization(self) -> int: ...\n    @property\n    def SmoothingIterations(self) -> int: ...\n    @property\n    def TargetEdgeLength(self) -> float: ...\n    @FillHolesInInputObjects.setter\n    def FillHolesInInputObjects(self, value: System.Void): ...\n    @InflateVerticesAndPoints.setter\n    def InflateVerticesAndPoints(self, value: System.Void): ...\n    @Offset.setter\n    def Offset(self, value: System.Void): ...\n    @PolygonOptimization.setter\n    def PolygonOptimization(self, value: System.Void): ...\n    @SmoothingIterations.setter\n    def SmoothingIterations(self, value: System.Void): ...\n    @TargetEdgeLength.setter\n    def TargetEdgeLength(self, value: System.Void): ...\n\nclass Mesh(GeometryBase):\n    \"\"\"Represents a geometry type that is defined by vertices and faces.\nThis is often called a face-vertex mesh.\n\n    \"\"\"\n    def __init__(self): ...\n    @overload\n    def Append(self, meshes: Generic.IEnumerable) -> None: ...\n    @overload\n    def Append(self, other: Mesh) -> None: ...\n    @overload\n    def Check(self, textLog: FileIO.TextLog) -> (bool, MeshCheckParameters): ...\n    @overload\n    def ClearSurfaceData() -> None: ...\n    @overload\n    def ClearTextureData() -> None: ...\n    @overload\n    def ClosestMeshPoint(self, testPoint: Point3d, maximumDistance: float) -> MeshPoint: ...\n    @overload\n    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...\n    @overload\n    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> (int, Point3d): ...\n    @overload\n    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> (int, Point3d, Vector3d): ...\n    @overload\n    def CollapseFacesByArea(self, lessThanArea: float, greaterThanArea: float) -> int: ...\n    @overload\n    def CollapseFacesByByAspectRatio(self, aspectRatio: float) -> int: ...\n    @overload\n    def CollapseFacesByEdgeLength(self, bGreaterThan: bool, edgeLength: float) -> int: ...\n    @overload\n    def ColorAt(self, meshPoint: MeshPoint) -> Drawing.Color: ...\n    @overload\n    def ColorAt(self, faceIndex: int, t0: float, t1: float, t2: float, t3: float) -> Drawing.Color: ...\n    @overload\n    def Compact() -> bool: ...\n    @overload\n    def ComputeAutoCreaseInformation() -> System.System.Array[System.Byte]: ...\n    @overload\n    def ComputeCurvatureApproximation(self, type_: int) -> (bool, System.System.Array[float]): ...\n    @overload\n    @staticmethod\n    def ComputeThickness(meshes: Generic.IEnumerable, maximumThickness: float) -> System.Array[MeshThicknessMeasurement]: ...\n    @overload\n    @staticmethod\n    def ComputeThickness(meshes: Generic.IEnumerable, maximumThickness: float, cancelToken: Threading.CancellationToken) -> System.Array[MeshThicknessMeasurement]: ...\n    @overload\n    @staticmethod\n    def ComputeThickness(meshes: Generic.IEnumerable, maximumThickness: float, sharpAngle: float, cancelToken: Threading.CancellationToken) -> System.Array[MeshThicknessMeasurement]: ...\n    @overload\n    def CopyFrom(self, other: Mesh) -> None: ...\n    @overload\n    @staticmethod\n    def CreateBooleanDifference(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable) -> System.Array[Mesh]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanDifference(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable, options: MeshBooleanOptions) -> (System.Array[Mesh], Commands.Result): ...\n    @overload\n    @staticmethod\n    def CreateBooleanIntersection(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable) -> System.Array[Mesh]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanIntersection(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable, options: MeshBooleanOptions) -> (System.Array[Mesh], Commands.Result): ...\n    @overload\n    @staticmethod\n    def CreateBooleanSplit(meshesToSplit: Generic.IEnumerable, meshSplitters: Generic.IEnumerable) -> System.Array[Mesh]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanSplit(meshesToSplit: Generic.IEnumerable, meshSplitters: Generic.IEnumerable, options: MeshBooleanOptions) -> (System.Array[Mesh], Commands.Result): ...\n    @overload\n    @staticmethod\n    def CreateBooleanUnion(meshes: Generic.IEnumerable) -> System.Array[Mesh]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanUnion(meshes: Generic.IEnumerable, tolerance: float) -> System.Array[Mesh]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanUnion(meshes: Generic.IEnumerable, options: MeshBooleanOptions) -> (System.Array[Mesh], Commands.Result): ...\n    @overload\n    @staticmethod\n    def CreateContourCurves(meshToContour: Mesh, sectionPlane: Plane, tolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def CreateContourCurves(meshToContour: Mesh, contourStart: Point3d, contourEnd: Point3d, interval: float, tolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def CreateConvexHull3D(points: Generic.IEnumerable, tolerance: float, angleTolerance: float) -> (Mesh, System.System.Array[System.System.Array[int]]): ...\n    @overload\n    @staticmethod\n    def CreateExtrusion(profile: Curve, direction: Vector3d) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateExtrusion(profile: Curve, direction: Vector3d, parameters: MeshingParameters) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromBox(corners: Generic.IEnumerable, xCount: int, yCount: int, zCount: int) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromBox(box: BoundingBox, xCount: int, yCount: int, zCount: int) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromBox(box: Box, xCount: int, yCount: int, zCount: int) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromBrep(brep: Brep, meshingParameters: MeshingParameters) -> System.Array[Mesh]: ...\n    @overload\n    @staticmethod\n    def CreateFromClosedPolyline(polyline: Polyline) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromCone(cone: Cone, vertical: int, around: int) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromCone(cone: Cone, vertical: int, around: int, solid: bool) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromCone(cone: Cone, vertical: int, around: int, solid: bool, quadCaps: bool) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromCurveExtrusion(curve: Curve, direction: Vector3d, parameters: MeshingParameters, boundingBox: BoundingBox) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromCurvePipe(curve: Curve, radius: float, segments: int, accuracy: int, capType: MeshPipeCapStyle, faceted: bool, intervals: Generic.IEnumerable) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int, capBottom: bool, capTop: bool) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int, capBottom: bool, capTop: bool, quadCaps: bool) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int, capBottom: bool, capTop: bool, circumscribe: bool, quadCaps: bool) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromExtrusion(extrusion: Extrusion, meshingParameters: MeshingParameters) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromFilteredFaceList(original: Mesh, inclusion: Generic.IEnumerable) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromIterativeCleanup(meshes: Generic.IEnumerable, tolerance: float) -> System.Array[Mesh]: ...\n    @overload\n    @staticmethod\n    def CreateFromLines(lines: System.Array[Curve], maxFaceValence: int, tolerance: float) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromPatchSingleFace(mesh: Mesh, components: Generic.IEnumerable) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromPlanarBoundary(boundary: Curve, parameters: MeshingParameters, tolerance: float) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromPlane(plane: Plane, xInterval: Interval, yInterval: Interval, xCount: int, yCount: int) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromSphere(sphere: Sphere, xCount: int, yCount: int) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromSubD(subd: SubD, displayDensity: int) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromSubDControlNet(subd: SubD) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromSubDControlNetWithTextureCoordinates(subd: SubD) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromSurface(surface: Surface) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromSurface(surface: Surface, meshingParameters: MeshingParameters) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromSurfaceControlNet(surface: Surface) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromTessellation(points: Generic.IEnumerable, edges: Generic.IEnumerable, plane: Plane, allowNewVertices: bool) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateFromTorus(torus: Torus, vertical: int, around: int) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateIcoSphere(sphere: Sphere, subdivisions: int) -> Mesh: ...\n    @overload\n    def CreatePartitions(self, maximumVertexCount: int, maximumTriangleCount: int) -> bool: ...\n    @overload\n    @staticmethod\n    def CreatePatch(outerBoundary: Polyline, angleToleranceRadians: float, pullbackSurface: Surface, innerBoundaryCurves: Generic.IEnumerable, innerBothSideCurves: Generic.IEnumerable, innerPoints: Generic.IEnumerable, trimback: bool, divisions: int) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateQuadSphere(sphere: Sphere, subdivisions: int) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateRefinedCatmullClarkMesh(mesh: Mesh, settings: MeshRefinements.RefinementSettings) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateRefinedLoopMesh(mesh: Mesh, formula: MeshRefinements.LoopFormula, settings: MeshRefinements.RefinementSettings) -> Mesh: ...\n    @overload\n    @staticmethod\n    def CreateUnweldedMesh(mesh: Mesh) -> Mesh: ...\n    @overload\n    def CreateVertexColorsFromBitmap(self, doc: Rhino.RhinoDoc, mapping: Render.TextureMapping, xform: Transform, bitmap: Drawing.Bitmap) -> bool: ...\n    @overload\n    def DestroyPartition() -> None: ...\n    @overload\n    def DestroyTopology() -> None: ...\n    @overload\n    def DestroyTree() -> None: ...\n    @overload\n    def Duplicate() -> GeometryBase: ...\n    @overload\n    def DuplicateMesh() -> Mesh: ...\n    @overload\n    def EvaluateMeshGeometry(self, surface: Surface) -> bool: ...\n    @overload\n    def ExplodeAtUnweldedEdges() -> System.Array[Mesh]: ...\n    @overload\n    def ExtendSelectionByEdgeRidge(self, preselectedEdges: System.System.Array[int], newEdge: int, iterative: bool) -> System.System.Array[int]: ...\n    @overload\n    def ExtendSelectionByFaceLoop(self, preselectedFaces: System.System.Array[int], newFace: int, iterative: bool) -> System.System.Array[int]: ...\n    @overload\n    def ExtractNonManifoldEdges(self, selective: bool) -> Mesh: ...\n    @overload\n    def FileHole(self, topologyEdgeIndex: int) -> bool: ...\n    @overload\n    def FillHoles() -> bool: ...\n    @overload\n    def Flip(self, vertexNormals: bool, faceNormals: bool, faceOrientation: bool) -> None: ...\n    @overload\n    def Flip(self, vertexNormals: bool, faceNormals: bool, faceOrientation: bool, ngonsBoundaryDirection: bool) -> None: ...\n    @property\n    def ComponentStates(self) -> Collections.MeshVertexStatusList: ...\n    @property\n    def DisjointMeshCount(self) -> int: ...\n    @property\n    def FaceNormals(self) -> Collections.MeshFaceNormalList: ...\n    @property\n    def Faces(self) -> Collections.MeshFaceList: ...\n    @property\n    def HasCachedTextureCoordinates(self) -> bool: ...\n    @property\n    def HasPrincipalCurvatures(self) -> bool: ...\n    @property\n    def IsClosed(self) -> bool: ...\n    @property\n    def IsOriented(self) -> bool: ...\n    @property\n    def IsSolid(self) -> bool: ...\n    @property\n    def Ngons(self) -> Collections.MeshNgonList: ...\n    @property\n    def Normals(self) -> Collections.MeshVertexNormalList: ...\n    @property\n    def PartitionCount(self) -> int: ...\n    @property\n    def TextureCoordinates(self) -> Collections.MeshTextureCoordinateList: ...\n    @property\n    def TopologyEdges(self) -> Collections.MeshTopologyEdgeList: ...\n    @property\n    def TopologyVertices(self) -> Collections.MeshTopologyVertexList: ...\n    @property\n    def VertexColors(self) -> Collections.MeshVertexColorList: ...\n    @property\n    def Vertices(self) -> Collections.MeshVertexList: ...\n    @overload\n    def GetCachedTextureCoordinates(self, textureMappingId: System.Guid) -> Render.CachedTextureCoordinates: ...\n    @overload\n    def GetCachedTextureCoordinates(self, rhinoObject: DocObjects.RhinoObject, texture: DocObjects.Texture) -> Render.CachedTextureCoordinates: ...\n    @overload\n    def GetNakedEdgePointStatus() -> System.System.Array[bool]: ...\n    @overload\n    def GetNakedEdges() -> System.Array[Polyline]: ...\n    @overload\n    def GetNgonAndFacesCount() -> int: ...\n    @overload\n    def GetNgonAndFacesEnumerable() -> Generic.IEnumerable: ...\n    @overload\n    def GetOutlines(self, viewport: Display.RhinoViewport) -> System.Array[Polyline]: ...\n    @overload\n    def GetOutlines(self, plane: Plane) -> System.Array[Polyline]: ...\n    @overload\n    def GetOutlines(self, viewportInfo: DocObjects.ViewportInfo, plane: Plane) -> System.Array[Polyline]: ...\n    @overload\n    def GetPartition(self, which: int) -> MeshPart: ...\n    @overload\n    def GetSelfIntersections(self, tolerance: float, overlapsPolylines: bool, overlapsMesh: bool, textLog: FileIO.TextLog, cancel: Threading.CancellationToken, progress: System.IProgress) -> (bool, System.Array[Polyline], System.Array[Polyline], Mesh): ...\n    @overload\n    def GetUnsafeLock(self, writable: bool) -> MeshUnsafeLock: ...\n    @overload\n    def HealNakedEdges(self, distance: float) -> bool: ...\n    @overload\n    def InvalidateCachedTextureCoordinates(self, bOnlyInvalidateCachedSurfaceParameterMapping: bool) -> None: ...\n    @overload\n    def IsManifold() -> bool: ...\n    @overload\n    def IsManifold(self, topologicalTest: bool) -> (bool, bool, bool): ...\n    @overload\n    def IsPointInside(self, point: Point3d, tolerance: float, strictlyIn: bool) -> bool: ...\n    @overload\n    def MatchEdges(self, distance: float, rachet: bool) -> bool: ...\n    @overload\n    def MergeAllCoplanarFaces(self, tolerance: float) -> bool: ...\n    @overload\n    def MergeAllCoplanarFaces(self, tolerance: float, angleTolerance: float) -> bool: ...\n    @overload\n    def NormalAt(self, meshPoint: MeshPoint) -> Vector3d: ...\n    @overload\n    def NormalAt(self, faceIndex: int, t0: float, t1: float, t2: float, t3: float) -> Vector3d: ...\n    @overload\n    def Offset(self, distance: float) -> Mesh: ...\n    @overload\n    def Offset(self, distance: float, solidify: bool) -> Mesh: ...\n    @overload\n    def Offset(self, distance: float, solidify: bool, direction: Vector3d) -> Mesh: ...\n    @overload\n    def Offset(self, distance: float, solidify: bool, direction: Vector3d) -> (Mesh, Generic.List): ...\n    @overload\n    def PatchSingleFace(self, components: Generic.IEnumerable) -> bool: ...\n    @overload\n    def PointAt(self, meshPoint: MeshPoint) -> Point3d: ...\n    @overload\n    def PointAt(self, faceIndex: int, t0: float, t1: float, t2: float, t3: float) -> Point3d: ...\n    @overload\n    def PullCurve(self, curve: Curve, tolerance: float) -> PolylineCurve: ...\n    @overload\n    def PullPointsToMesh(self, points: Generic.IEnumerable) -> System.Array[Point3d]: ...\n    @overload\n    def QuadRemesh(self, parameters: QuadRemeshParameters) -> Mesh: ...\n    @overload\n    def QuadRemesh(self, parameters: QuadRemeshParameters, guideCurves: Generic.IEnumerable) -> Mesh: ...\n    @overload\n    def QuadRemeshAsync(self, parameters: QuadRemeshParameters, progress: System.IProgress, cancelToken: Threading.CancellationToken) -> Tasks.Task: ...\n    @overload\n    def QuadRemeshAsync(self, parameters: QuadRemeshParameters, guideCurves: Generic.IEnumerable, progress: System.IProgress, cancelToken: Threading.CancellationToken) -> Tasks.Task: ...\n    @overload\n    def QuadRemeshAsync(self, faceBlocks: Generic.IEnumerable, parameters: QuadRemeshParameters, guideCurves: Generic.IEnumerable, progress: System.IProgress, cancelToken: Threading.CancellationToken) -> Tasks.Task: ...\n    @overload\n    @staticmethod\n    def QuadRemeshBrep(brep: Brep, parameters: QuadRemeshParameters) -> Mesh: ...\n    @overload\n    @staticmethod\n    def QuadRemeshBrep(brep: Brep, parameters: QuadRemeshParameters, guideCurves: Generic.IEnumerable) -> Mesh: ...\n    @overload\n    @staticmethod\n    def QuadRemeshBrepAsync(brep: Brep, parameters: QuadRemeshParameters, progress: System.IProgress, cancelToken: Threading.CancellationToken) -> Tasks.Task: ...\n    @overload\n    @staticmethod\n    def QuadRemeshBrepAsync(brep: Brep, parameters: QuadRemeshParameters, guideCurves: Generic.IEnumerable, progress: System.IProgress, cancelToken: Threading.CancellationToken) -> Tasks.Task: ...\n    @overload\n    def RebuildNormals() -> None: ...\n    @overload\n    def Reduce(self, parameters: ReduceMeshParameters) -> bool: ...\n    @overload\n    def Reduce(self, parameters: ReduceMeshParameters, threaded: bool) -> bool: ...\n    @overload\n    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool) -> bool: ...\n    @overload\n    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool, threaded: bool) -> bool: ...\n    @overload\n    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool, cancelToken: Threading.CancellationToken, progress: System.IProgress) -> (bool, str): ...\n    @overload\n    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool, cancelToken: Threading.CancellationToken, progress: System.IProgress, threaded: bool) -> (bool, str): ...\n    @overload\n    def ReleaseUnsafeLock(self, meshData: MeshUnsafeLock) -> None: ...\n    @overload\n    @staticmethod\n    def RequireIterativeCleanup(meshes: Generic.IEnumerable, tolerance: float) -> bool: ...\n    @overload\n    def SetCachedTextureCoordinates(self, tm: Render.TextureMapping) -> (Transform): ...\n    @overload\n    def SetCachedTextureCoordinatesFromMaterial(self, rhinoObject: DocObjects.RhinoObject, material: DocObjects.Material) -> None: ...\n    @overload\n    def SetSurfaceParametersFromTextureCoordinates() -> bool: ...\n    @overload\n    def SetTextureCoordinates(self, tm: Render.TextureMapping, xf: Transform, lazy: bool) -> None: ...\n    @overload\n    def SetTextureCoordinates(self, tm: Render.TextureMapping, xf: Transform, lazy: bool, seamCheck: bool) -> None: ...\n    @overload\n    def ShrinkWrap(self, parameters: ShrinkWrapParameters) -> Mesh: ...\n    @overload\n    def ShrinkWrap(self, parameters: ShrinkWrapParameters, token: Threading.CancellationToken) -> Mesh: ...\n    @overload\n    @staticmethod\n    def ShrinkWrap(pointCloud: PointCloud, parameters: ShrinkWrapParameters) -> Mesh: ...\n    @overload\n    @staticmethod\n    def ShrinkWrap(meshes: Generic.IEnumerable, parameters: ShrinkWrapParameters) -> Mesh: ...\n    @overload\n    @staticmethod\n    def ShrinkWrap(geometryBases: Generic.IEnumerable, parameters: ShrinkWrapParameters, meshingParameters: MeshingParameters) -> Mesh: ...\n    @overload\n    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> bool: ...\n    @overload\n    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> bool: ...\n    @overload\n    def Smooth(self, vertexIndices: Generic.IEnumerable, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> bool: ...\n    @overload\n    def Smooth(self, smoothFactor: float, numSteps: int, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> bool: ...\n    @overload\n    def Smooth(self, vertexIndices: Generic.IEnumerable, smoothFactor: float, numSteps: int, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> bool: ...\n    @overload\n    def SolidOrientation() -> int: ...\n    @overload\n    def Split(self, mesh: Mesh) -> System.Array[Mesh]: ...\n    @overload\n    def Split(self, plane: Plane) -> System.Array[Mesh]: ...\n    @overload\n    def Split(self, meshes: Generic.IEnumerable) -> System.Array[Mesh]: ...\n    @overload\n    def Split(self, meshes: Generic.IEnumerable, tolerance: float, splitAtCoplanar: bool, textLog: FileIO.TextLog, cancel: Threading.CancellationToken, progress: System.IProgress) -> System.Array[Mesh]: ...\n    @overload\n    def Split(self, meshes: Generic.IEnumerable, tolerance: float, splitAtCoplanar: bool, createNgons: bool, textLog: FileIO.TextLog, cancel: Threading.CancellationToken, progress: System.IProgress) -> System.Array[Mesh]: ...\n    @overload\n    def SplitDisjointPieces() -> System.Array[Mesh]: ...\n    @overload\n    def SplitWithProjectedPolylines(self, curves: Generic.IEnumerable, tolerance: float) -> System.Array[Mesh]: ...\n    @overload\n    def SplitWithProjectedPolylines(self, curves: Generic.IEnumerable, tolerance: float, textLog: FileIO.TextLog, cancel: Threading.CancellationToken, progress: System.IProgress) -> System.Array[Mesh]: ...\n    @overload\n    def Subdivide() -> bool: ...\n    @overload\n    def Subdivide(self, faceIndices: Generic.IEnumerable) -> bool: ...\n    @overload\n    def UnifyNormals() -> int: ...\n    @overload\n    def UnifyNormals(self, countOnly: bool) -> int: ...\n    @overload\n    def Unweld(self, angleToleranceRadians: float, modifyNormals: bool) -> None: ...\n    @overload\n    def UnweldEdge(self, edgeIndices: Generic.IEnumerable, modifyNormals: bool) -> bool: ...\n    @overload\n    def UnweldVertices(self, topologyVertexIndices: Generic.IEnumerable, modifyNormals: bool) -> bool: ...\n    @overload\n    def Volume() -> float: ...\n    @overload\n    def Weld(self, angleToleranceRadians: float) -> None: ...\n    @overload\n    def WithDisplacement(self, displacement: MeshDisplacementInfo) -> Mesh: ...\n    @overload\n    def WithEdgeSoftening(self, softeningRadius: float, chamfer: bool, faceted: bool, force: bool, angleThreshold: float) -> Mesh: ...\n    @overload\n    def WithShutLining(self, faceted: bool, tolerance: float, curves: Generic.IEnumerable) -> Mesh: ...\n\nclass MeshBooleanOptions(object):\n    \"\"\"Contains a set of data to pass to boolean options.\n\n    \"\"\"\n    def __init__(self): ...\n    @property\n    def CancellationToken(self) -> Threading.CancellationToken: ...\n    @property\n    def ProgressReporter(self) -> System.IProgress: ...\n    @property\n    def TextLog(self) -> FileIO.TextLog: ...\n    @property\n    def Tolerance(self) -> float: ...\n    @CancellationToken.setter\n    def CancellationToken(self, value: System.Void): ...\n    @ProgressReporter.setter\n    def ProgressReporter(self, value: System.Void): ...\n    @TextLog.setter\n    def TextLog(self, value: System.Void): ...\n    @Tolerance.setter\n    def Tolerance(self, value: System.Void): ...\n\nclass MeshUnsafeLock(object):\n    \"\"\"Permits access to the underlying mesh raw data structures in an unsafe way.\n\n    \"\"\"\n    @overload\n    def FaceNormalsArray() -> (Vector3f, int): ...\n    @overload\n    def FacesArray() -> (MeshFace, int): ...\n    @overload\n    def NormalVector3fArray() -> (Vector3f, int): ...\n    @overload\n    def Release() -> None: ...\n    @overload\n    def VertexColorsArray() -> (System.Int32, int): ...\n    @overload\n    def VertexPoint3dArray() -> (Point3d, int): ...\n    @overload\n    def VertexPoint3fArray() -> (Point3f, int): ...\n\nclass MeshFace(System.ValueType):\n    \"\"\"Represents the values of the four indices of a mesh face quad.\nIf the third and fourth values are the same, this face represents a triangle.\n\n    \"\"\"\n    @overload\n    def __init__(self, a: int, b: int, c: int): ...\n    @overload\n    def __init__(self, a: int, b: int, c: int, d: int): ...\n    @overload\n    def CompareTo(self, other: MeshFace) -> int: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @overload\n    def Equals(self, other: MeshFace) -> bool: ...\n    @overload\n    def Flip() -> MeshFace: ...\n    @property\n    def A(self) -> int: ...\n    @property\n    def B(self) -> int: ...\n    @property\n    def C(self) -> int: ...\n    @property\n    def D(self) -> int: ...\n    @property\n    def IsQuad(self) -> bool: ...\n    @property\n    def IsTriangle(self) -> bool: ...\n    @property\n    def Item(self) -> int: ...\n    @property\n    def Unset(self) -> MeshFace: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    def IsValid() -> bool: ...\n    @overload\n    def IsValid(self, vertexCount: int) -> bool: ...\n    @overload\n    def IsValid(self, points: System.Array[Point3d]) -> bool: ...\n    @overload\n    def IsValidEx() -> (bool, System.Array[Point3d]): ...\n    @overload\n    def Repair(self, points: System.Array[Point3d]) -> bool: ...\n    @overload\n    def RepairEx() -> (bool, System.Array[Point3d]): ...\n    @A.setter\n    def A(self, value: System.Void): ...\n    @B.setter\n    def B(self, value: System.Void): ...\n    @C.setter\n    def C(self, value: System.Void): ...\n    @D.setter\n    def D(self, value: System.Void): ...\n    @Item.setter\n    def Item(self, value: System.Void): ...\n    @overload\n    def Set(self, a: int, b: int, c: int) -> None: ...\n    @overload\n    def Set(self, a: int, b: int, c: int, d: int) -> None: ...\n    @overload\n    def ToString() -> str: ...\n\nclass MeshNgon(object):\n    \"\"\"Represents a mesh ngon.\nWhen retrieved from the Ngon property of a mesh, this contains faces that have edge valence strictly higher than 4.\nWhen retrieving Ngons from\n, this might contain also triangles and quads.\n\n    \"\"\"\n    @overload\n    def BoundaryVertexIndexList() -> System.System.Array[System.UInt32]: ...\n    @overload\n    def CompareTo(self, otherNgon: MeshNgon) -> int: ...\n    @overload\n    @staticmethod\n    def Create(meshVertexIndexList: Generic.IList, meshFaceIndexList: Generic.IList) -> MeshNgon: ...\n    @overload\n    def Equals(self, otherNgon: MeshNgon) -> bool: ...\n    @overload\n    def Equals(self, otherObj: object) -> bool: ...\n    @overload\n    def FaceIndexList() -> System.System.Array[System.UInt32]: ...\n    @property\n    def BoundaryVertexCount(self) -> int: ...\n    @property\n    def Empty(self) -> MeshNgon: ...\n    @property\n    def FaceCount(self) -> int: ...\n    @property\n    def Item(self) -> int: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    def Set(self, meshVertexIndexList: Generic.IList, meshFaceIndexList: Generic.IList) -> None: ...\n    @overload\n    def ToString() -> str: ...\n\nclass ShutLiningCurveInfo(object):\n    \"\"\"Contains shutlining curve information. This is used in\n.\n\n    \"\"\"\n    def __init__(self, curve: Curve, radius: float, profile: int, pull: bool, isBump: bool, curveIntervals: Generic.IEnumerable, enabled: bool): ...\n    @property\n    def Curve(self) -> Curve: ...\n    @property\n    def CurveIntervals(self) -> ObjectModel.ReadOnlyCollection: ...\n    @property\n    def Enabled(self) -> bool: ...\n    @property\n    def IsBump(self) -> bool: ...\n    @property\n    def Profile(self) -> int: ...\n    @property\n    def Pull(self) -> bool: ...\n    @property\n    def Radius(self) -> float: ...\n\nclass MeshDisplacementInfo(object):\n    \"\"\"Contains mesh displacement information.\n\n    \"\"\"\n    def __init__(self, texture: Render.RenderTexture, mapping: Render.TextureMapping): ...\n    @property\n    def Black(self) -> float: ...\n    @property\n    def BlackMove(self) -> float: ...\n    @property\n    def ChannelNumber(self) -> int: ...\n    @property\n    def FaceLimit(self) -> int: ...\n    @property\n    def FairingAmount(self) -> int: ...\n    @property\n    def InstanceTransform(self) -> Transform: ...\n    @property\n    def Mapping(self) -> Render.TextureMapping: ...\n    @property\n    def MappingTransform(self) -> Transform: ...\n    @property\n    def MemoryLimit(self) -> int: ...\n    @property\n    def PostWeldAngle(self) -> float: ...\n    @property\n    def RefineSensitivity(self) -> float: ...\n    @property\n    def RefineStepCount(self) -> int: ...\n    @property\n    def SweepPitch(self) -> float: ...\n    @property\n    def Texture(self) -> Render.RenderTexture: ...\n    @property\n    def White(self) -> float: ...\n    @property\n    def WhiteMove(self) -> float: ...\n    @Black.setter\n    def Black(self, value: System.Void): ...\n    @BlackMove.setter\n    def BlackMove(self, value: System.Void): ...\n    @ChannelNumber.setter\n    def ChannelNumber(self, value: System.Void): ...\n    @FaceLimit.setter\n    def FaceLimit(self, value: System.Void): ...\n    @FairingAmount.setter\n    def FairingAmount(self, value: System.Void): ...\n    @InstanceTransform.setter\n    def InstanceTransform(self, value: System.Void): ...\n    @MappingTransform.setter\n    def MappingTransform(self, value: System.Void): ...\n    @MemoryLimit.setter\n    def MemoryLimit(self, value: System.Void): ...\n    @PostWeldAngle.setter\n    def PostWeldAngle(self, value: System.Void): ...\n    @RefineSensitivity.setter\n    def RefineSensitivity(self, value: System.Void): ...\n    @RefineStepCount.setter\n    def RefineStepCount(self, value: System.Void): ...\n    @SweepPitch.setter\n    def SweepPitch(self, value: System.Void): ...\n    @White.setter\n    def White(self, value: System.Void): ...\n    @WhiteMove.setter\n    def WhiteMove(self, value: System.Void): ...\n\nclass NurbsSurface(Surface):\n    \"\"\"Represents a Non Uniform Rational B-Splines (NURBS) surface.\n\n    \"\"\"\n    def __init__(self, other: NurbsSurface): ...\n    @overload\n    def ConvertSpanToBezier(self, spanIndex0: int, spanIndex1: int) -> BezierSurface: ...\n    @overload\n    def CopyFrom(self, other: NurbsSurface) -> None: ...\n    @overload\n    @staticmethod\n    def Create(dimension: int, isRational: bool, order0: int, order1: int, controlPointCount0: int, controlPointCount1: int) -> NurbsSurface: ...\n    @overload\n    @staticmethod\n    def CreateCurveOnSurface(surface: Surface, points: Generic.IEnumerable, tolerance: float, periodic: bool) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateCurveOnSurfacePoints(surface: Surface, fixedPoints: Generic.IEnumerable, tolerance: float, periodic: bool, initCount: int, levels: int) -> System.Array[Point2d]: ...\n    @overload\n    @staticmethod\n    def CreateFromCone(cone: Cone) -> NurbsSurface: ...\n    @overload\n    @staticmethod\n    def CreateFromCorners(corner1: Point3d, corner2: Point3d, corner3: Point3d) -> NurbsSurface: ...\n    @overload\n    @staticmethod\n    def CreateFromCorners(corner1: Point3d, corner2: Point3d, corner3: Point3d, corner4: Point3d) -> NurbsSurface: ...\n    @overload\n    @staticmethod\n    def CreateFromCorners(corner1: Point3d, corner2: Point3d, corner3: Point3d, corner4: Point3d, tolerance: float) -> NurbsSurface: ...\n    @overload\n    @staticmethod\n    def CreateFromCylinder(cylinder: Cylinder) -> NurbsSurface: ...\n    @overload\n    @staticmethod\n    def CreateFromPlane(plane: Plane, uInterval: Interval, vInterval: Interval, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...\n    @overload\n    @staticmethod\n    def CreateFromPoints(points: Generic.IEnumerable, uCount: int, vCount: int, uDegree: int, vDegree: int) -> NurbsSurface: ...\n    @overload\n    @staticmethod\n    def CreateFromSphere(sphere: Sphere) -> NurbsSurface: ...\n    @overload\n    @staticmethod\n    def CreateFromTorus(torus: Torus) -> NurbsSurface: ...\n    @overload\n    @staticmethod\n    def CreateNetworkSurface(curves: Generic.IEnumerable, continuity: int, edgeTolerance: float, interiorTolerance: float, angleTolerance: float) -> (NurbsSurface, int): ...\n    @overload\n    @staticmethod\n    def CreateNetworkSurface(uCurves: Generic.IEnumerable, uContinuityStart: int, uContinuityEnd: int, vCurves: Generic.IEnumerable, vContinuityStart: int, vContinuityEnd: int, edgeTolerance: float, interiorTolerance: float, angleTolerance: float) -> (NurbsSurface, int): ...\n    @overload\n    @staticmethod\n    def CreateRailRevolvedSurface(profile: Curve, rail: Curve, axis: Line, scaleHeight: bool) -> NurbsSurface: ...\n    @overload\n    @staticmethod\n    def CreateRuledSurface(curveA: Curve, curveB: Curve) -> NurbsSurface: ...\n    @overload\n    @staticmethod\n    def CreateSubDFriendly(surface: Surface) -> NurbsSurface: ...\n    @overload\n    @staticmethod\n    def CreateThroughPoints(points: Generic.IEnumerable, uCount: int, vCount: int, uDegree: int, vDegree: int, uClosed: bool, vClosed: bool) -> NurbsSurface: ...\n    @overload\n    def EpsilonEquals(self, other: NurbsSurface, epsilon: float) -> bool: ...\n    @overload\n    def FindClosestIsoCurve(self, testPoint: Point3d) -> IsoStatus: ...\n    @property\n    def IsRational(self) -> bool: ...\n    @property\n    def KnotsU(self) -> Collections.NurbsSurfaceKnotList: ...\n    @property\n    def KnotsV(self) -> Collections.NurbsSurfaceKnotList: ...\n    @property\n    def OrderU(self) -> int: ...\n    @property\n    def OrderV(self) -> int: ...\n    @property\n    def Points(self) -> Collections.NurbsSurfacePointList: ...\n    @overload\n    def IncreaseDegreeU(self, desiredDegree: int) -> bool: ...\n    @overload\n    def IncreaseDegreeV(self, desiredDegree: int) -> bool: ...\n    @overload\n    @staticmethod\n    def MakeCompatible(surface0: Surface, surface1: Surface) -> (bool, NurbsSurface, NurbsSurface): ...\n    @overload\n    def MakeNonRational() -> bool: ...\n    @overload\n    def MakeRational() -> bool: ...\n    @overload\n    def MatchToCurve(self, side: IsoStatus, targetCurve: Curve, maxEndDistance: float, maxInteriorDistance: float, matchTolerance: float, maxLevel: int) -> NurbsSurface: ...\n    @overload\n    def UVNDirectionsAt(self, u: float, v: float) -> (bool, Vector3d, Vector3d, Vector3d): ...\n\nclass MorphControl(GeometryBase):\n    \"\"\"Represents a geometry that is able to control the morphing behavior of some other geometry.\n\n    \"\"\"\n    def __init__(self, originCurve: NurbsCurve, targetCurve: NurbsCurve): ...\n    @property\n    def Curve(self) -> NurbsCurve: ...\n    @property\n    def PreserveStructure(self) -> bool: ...\n    @property\n    def QuickPreview(self) -> bool: ...\n    @property\n    def SpaceMorphTolerance(self) -> float: ...\n    @property\n    def Surface(self) -> NurbsSurface: ...\n    @overload\n    def Morph(self, geometry: GeometryBase) -> bool: ...\n    @PreserveStructure.setter\n    def PreserveStructure(self, value: System.Void): ...\n    @QuickPreview.setter\n    def QuickPreview(self, value: System.Void): ...\n    @SpaceMorphTolerance.setter\n    def SpaceMorphTolerance(self, value: System.Void): ...\n\nclass HermiteSurface(object):\n    \"\"\"Create an ON_NurbsSurface satisfying Hermite interpolation conditions at a grid of points.\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, uCount: int, vCount: int): ...\n    @overload\n    def Dispose() -> None: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def UCount(self) -> int: ...\n    @property\n    def VCount(self) -> int: ...\n    @overload\n    def PointAt(self, uIndex: int, vIndex: int) -> Point3d: ...\n    @overload\n    def SetPointAt(self, uIndex: int, vIndex: int, point: Point3d) -> None: ...\n    @overload\n    def SetTwistAt(self, uIndex: int, vIndex: int, twist: Vector3d) -> None: ...\n    @overload\n    def SetUParameterAt(self, index: int, parameter: float) -> None: ...\n    @overload\n    def SetUTangentAt(self, uIndex: int, vIndex: int, tangent: Vector3d) -> None: ...\n    @overload\n    def SetVParameterAt(self, index: int, parameter: float) -> None: ...\n    @overload\n    def SetVTangentAt(self, uIndex: int, vIndex: int, tangent: Vector3d) -> None: ...\n    @overload\n    def ToNurbsSurface() -> NurbsSurface: ...\n    @overload\n    def TwistAt(self, uIndex: int, vIndex: int) -> Vector3d: ...\n    @overload\n    def UParameterAt(self, index: int) -> float: ...\n    @overload\n    def UTangentAt(self, uIndex: int, vIndex: int) -> Vector3d: ...\n    @overload\n    def VParameterAt(self, index: int) -> float: ...\n    @overload\n    def VTangentAt(self, uIndex: int, vIndex: int) -> Vector3d: ...\n\nclass PlaneSurface(Surface):\n    \"\"\"Represents a plane surface.\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, plane: Plane): ...\n    @overload\n    def __init__(self, plane: Plane, xExtents: Interval, yExtents: Interval): ...\n    @overload\n    @staticmethod\n    def CreateThroughBox(plane: Plane, box: BoundingBox) -> PlaneSurface: ...\n    @overload\n    @staticmethod\n    def CreateThroughBox(lineInPlane: Line, vectorInPlane: Vector3d, box: BoundingBox) -> PlaneSurface: ...\n    @property\n    def Plane(self) -> Plane: ...\n    @overload\n    def GetExtents(self, direction: int) -> Interval: ...\n    @Plane.setter\n    def Plane(self, value: System.Void): ...\n    @overload\n    def SetExtents(self, direction: int, extents: Interval, syncDomain: bool) -> None: ...\n    @overload\n    def ToMesh() -> Mesh: ...\n\nclass ClippingPlaneSurface(PlaneSurface):\n    \"\"\"Represents a planar surface that is used as clipping plane in viewports. A clipping plane object maintains a list of viewports that it clips against.\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, plane: Plane): ...\n    @overload\n    def __init__(self, planeSurface: PlaneSurface): ...\n    @overload\n    def AddClipViewportId(self, viewportId: System.Guid) -> bool: ...\n    @overload\n    def ClearClipParticipationLists() -> None: ...\n    @property\n    def ParticipationListsEnabled(self) -> bool: ...\n    @property\n    def PlaneDepth(self) -> float: ...\n    @property\n    def PlaneDepthEnabled(self) -> bool: ...\n    @overload\n    def GetClipParticipation() -> (Generic.IEnumerable, Generic.IEnumerable, bool): ...\n    @overload\n    def RemoveClipViewportId(self, viewportId: System.Guid) -> bool: ...\n    @ParticipationListsEnabled.setter\n    def ParticipationListsEnabled(self, value: System.Void): ...\n    @PlaneDepth.setter\n    def PlaneDepth(self, value: System.Void): ...\n    @PlaneDepthEnabled.setter\n    def PlaneDepthEnabled(self, value: System.Void): ...\n    @overload\n    def SetClipParticipation(self, objectIds: Generic.IEnumerable, layerIndices: Generic.IEnumerable, isExclusionList: bool) -> None: ...\n    @overload\n    def ViewportIds() -> System.System.Array[System.Guid]: ...\n\nclass MeshPoint(object):\n    \"\"\"Represents a point that is found on a mesh.\n\n    \"\"\"\n    @property\n    def ComponentIndex(self) -> ComponentIndex: ...\n    @property\n    def EdgeIndex(self) -> int: ...\n    @property\n    def EdgeParameter(self) -> float: ...\n    @property\n    def FaceIndex(self) -> int: ...\n    @property\n    def Mesh(self) -> Mesh: ...\n    @property\n    def Point(self) -> Point3d: ...\n    @property\n    def T(self) -> System.System.Array[float]: ...\n    @property\n    def Triangle(self) -> System.Char: ...\n    @overload\n    def GetTriangle() -> (bool, int, int, int): ...\n\nclass SilhouetteType(enum.Enum):\n    None_ = 0\n    Projecting = 1\n    TangentProjects = 2\n    Tangent = 4\n    Crease = 8\n    Boundary = 16\n    NonSilhouetteCrease = 256\n    NonSilhouetteTangent = 512\n    NonSilhouetteSeam = 1024\n    SectionCut = 4096\n    MiscellaneousFeature = 8192\n    DraftCurve = 32768\n\nclass Silhouette(object):\n    \"\"\"Information about silhouette curves that are generated from geometry (surfaces, brep faces, meshes)\n\n    \"\"\"\n    @overload\n    @staticmethod\n    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, perspectiveCameraLocation: Point3d, tolerance: float, angleToleranceRadians: float) -> System.Array[Silhouette]: ...\n    @overload\n    @staticmethod\n    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, parallelCameraDirection: Vector3d, tolerance: float, angleToleranceRadians: float) -> System.Array[Silhouette]: ...\n    @overload\n    @staticmethod\n    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, viewport: DocObjects.ViewportInfo, tolerance: float, angleToleranceRadians: float) -> System.Array[Silhouette]: ...\n    @overload\n    @staticmethod\n    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, perspectiveCameraLocation: Point3d, tolerance: float, angleToleranceRadians: float, clippingPlanes: Generic.IEnumerable, cancelToken: Threading.CancellationToken) -> System.Array[Silhouette]: ...\n    @overload\n    @staticmethod\n    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, parallelCameraDirection: Vector3d, tolerance: float, angleToleranceRadians: float, clippingPlanes: Generic.IEnumerable, cancelToken: Threading.CancellationToken) -> System.Array[Silhouette]: ...\n    @overload\n    @staticmethod\n    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, viewport: DocObjects.ViewportInfo, tolerance: float, angleToleranceRadians: float, clippingPlanes: Generic.IEnumerable, cancelToken: Threading.CancellationToken) -> System.Array[Silhouette]: ...\n    @overload\n    @staticmethod\n    def ComputeDraftCurve(geometry: GeometryBase, draftAngle: float, pullDirection: Vector3d, tolerance: float, angleToleranceRadians: float) -> System.Array[Silhouette]: ...\n    @overload\n    @staticmethod\n    def ComputeDraftCurve(geometry: GeometryBase, draftAngle: float, pullDirection: Vector3d, tolerance: float, angleToleranceRadians: float, cancelToken: Threading.CancellationToken) -> System.Array[Silhouette]: ...\n    @property\n    def Curve(self) -> Curve: ...\n    @property\n    def GeometryComponentIndex(self) -> ComponentIndex: ...\n    @property\n    def SilhouetteType(self) -> SilhouetteType: ...\n\nclass PointCloudUnsafeLock(object):\n    \"\"\"Permits access to the underlying PointCloud raw data structures in an unsafe way.\n\n    \"\"\"\n    @overload\n    def ColorArray() -> (System.Int32, int): ...\n    @overload\n    def NormalArray() -> (Vector3d, int): ...\n    @overload\n    def PointArray() -> (Point3d, int): ...\n    @overload\n    def Release() -> None: ...\n    @overload\n    def ValueArray() -> (System.Double, int): ...\n\nclass PointCloudItem(object):\n    \"\"\"Represents a single item in a point cloud. A PointCloud item always has a location, but it has an optional normal vector and color.\n\n    \"\"\"\n    @property\n    def Color(self) -> Drawing.Color: ...\n    @property\n    def Hidden(self) -> bool: ...\n    @property\n    def Index(self) -> int: ...\n    @property\n    def Location(self) -> Point3d: ...\n    @property\n    def Normal(self) -> Vector3d: ...\n    @property\n    def PointValue(self) -> float: ...\n    @property\n    def X(self) -> float: ...\n    @property\n    def Y(self) -> float: ...\n    @property\n    def Z(self) -> float: ...\n    @Color.setter\n    def Color(self, value: System.Void): ...\n    @Hidden.setter\n    def Hidden(self, value: System.Void): ...\n    @Location.setter\n    def Location(self, value: System.Void): ...\n    @Normal.setter\n    def Normal(self, value: System.Void): ...\n    @PointValue.setter\n    def PointValue(self, value: System.Void): ...\n    @X.setter\n    def X(self, value: System.Void): ...\n    @Y.setter\n    def Y(self, value: System.Void): ...\n    @Z.setter\n    def Z(self, value: System.Void): ...\n\nclass PointCloud(GeometryBase):\n    \"\"\"Represents a collection of coordinates with optional normal vectors and colors.\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, other: PointCloud): ...\n    @overload\n    def __init__(self, points: Generic.IEnumerable): ...\n    @overload\n    def Add(self, point: Point3d) -> None: ...\n    @overload\n    def Add(self, point: Point3d, color: Drawing.Color) -> None: ...\n    @overload\n    def Add(self, point: Point3d, normal: Vector3d) -> None: ...\n    @overload\n    def Add(self, point: Point3d, normal: Vector3d, color: Drawing.Color) -> None: ...\n    @overload\n    def Add(self, point: Point3d, normal: Vector3d, color: Drawing.Color, value: float) -> None: ...\n    @overload\n    def AddRange(self, points: Generic.IEnumerable) -> None: ...\n    @overload\n    def AddRange(self, points: Generic.IEnumerable, colors: Generic.IEnumerable) -> None: ...\n    @overload\n    def AddRange(self, points: Generic.IEnumerable, normals: Generic.IEnumerable) -> None: ...\n    @overload\n    def AddRange(self, points: Generic.IEnumerable, normals: Generic.IEnumerable, colors: Generic.IEnumerable) -> None: ...\n    @overload\n    def AddRange(self, points: Generic.IEnumerable, normals: Generic.IEnumerable, colors: Generic.IEnumerable, values: Generic.IEnumerable) -> None: ...\n    @overload\n    def AppendNew() -> PointCloudItem: ...\n    @overload\n    def AsReadOnlyListOfPoints() -> Generic.IReadOnlyList: ...\n    @overload\n    def ClearColors() -> None: ...\n    @overload\n    def ClearHiddenFlags() -> None: ...\n    @overload\n    def ClearNormals() -> None: ...\n    @overload\n    def ClearPointValues() -> None: ...\n    @overload\n    def ClosestPoint(self, testPoint: Point3d) -> int: ...\n    @overload\n    def CreateContourCurves(self, contourStart: Point3d, contourEnd: Point3d, interval: float, absoluteTolerance: float) -> System.Array[Curve]: ...\n    @overload\n    def CreateContourCurves(self, startPoint: Point3d, endPoint: Point3d, interval: float, absoluteTolerance: float, maxDistance: float, minDistance: float, openCurves: bool, createSpline: bool, createPolyline: bool, fitTolerance: float) -> System.Array[Curve]: ...\n    @overload\n    def CreateSectionCurve(self, plane: Plane, absoluteTolerance: float) -> System.Array[Curve]: ...\n    @overload\n    def CreateSectionCurve(self, plane: Plane, absoluteTolerance: float, maxDistance: float, minDistance: float, openCurves: bool, createSpline: bool, createPolyline: bool, fitTolerance: float) -> System.Array[Curve]: ...\n    @property\n    def ContainsColors(self) -> bool: ...\n    @property\n    def ContainsHiddenFlags(self) -> bool: ...\n    @property\n    def ContainsNormals(self) -> bool: ...\n    @property\n    def ContainsPointValues(self) -> bool: ...\n    @property\n    def Count(self) -> int: ...\n    @property\n    def HiddenPointCount(self) -> int: ...\n    @property\n    def Item(self) -> PointCloudItem: ...\n    @overload\n    def GetColors() -> Drawing.System.Array[Drawing.Color]: ...\n    @overload\n    def GetEnumerator() -> Generic.IEnumerator: ...\n    @overload\n    def GetNormals() -> System.Array[Vector3d]: ...\n    @overload\n    def GetPoints() -> System.Array[Point3d]: ...\n    @overload\n    def GetPointValues() -> System.System.Array[float]: ...\n    @overload\n    def GetRandomSubsample(self, numberOfPoints: System.UInt32) -> PointCloud: ...\n    @overload\n    def GetRandomSubsample(self, numberOfPoints: System.UInt32, cancelToken: Threading.CancellationToken, progress: System.IProgress) -> PointCloud: ...\n    @overload\n    def GetUnsafeLock(self, writable: bool) -> PointCloudUnsafeLock: ...\n    @overload\n    def Insert(self, index: int, point: Point3d) -> None: ...\n    @overload\n    def Insert(self, index: int, point: Point3d, normal: Vector3d) -> None: ...\n    @overload\n    def Insert(self, index: int, point: Point3d, color: Drawing.Color) -> None: ...\n    @overload\n    def Insert(self, index: int, point: Point3d, normal: Vector3d, color: Drawing.Color) -> None: ...\n    @overload\n    def Insert(self, index: int, point: Point3d, normal: Vector3d, color: Drawing.Color, value: float) -> None: ...\n    @overload\n    def InsertNew(self, index: int) -> PointCloudItem: ...\n    @overload\n    def InsertRange(self, index: int, points: Generic.IEnumerable) -> None: ...\n    @overload\n    def Merge(self, other: PointCloud) -> None: ...\n    @overload\n    def PointAt(self, index: int) -> Point3d: ...\n    @overload\n    def ReleaseUnsafeLock(self, pointCloudData: PointCloudUnsafeLock) -> None: ...\n    @overload\n    def RemoveAt(self, index: int) -> None: ...\n    @overload\n    def RemoveRange(self, indices: Generic.IEnumerable) -> int: ...\n    @overload\n    def ShrinkWrap(self, parameters: ShrinkWrapParameters) -> Mesh: ...\n\nclass Point(GeometryBase):\n    \"\"\"Represents a geometric point.\nThis is fundamentally a class that derives from\nand contains a single\nlocation.\n\n    \"\"\"\n    def __init__(self, location: Point3d): ...\n    @property\n    def Location(self) -> Point3d: ...\n    @Location.setter\n    def Location(self, value: System.Void): ...\n\nclass Point3dGrid(GeometryBase):\n    \"\"\"Represents a rectangular grid of 3D points.\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, rows: int, columns: int): ...\n\nclass PolyCurve(Curve):\n    \"\"\"Represents a curve that is the result of joining several (possibly different) types of curves.\n\n    \"\"\"\n    def __init__(self): ...\n    @overload\n    def Append(self, line: Line) -> bool: ...\n    @overload\n    def Append(self, arc: Arc) -> bool: ...\n    @overload\n    def Append(self, curve: Curve) -> bool: ...\n    @overload\n    def AppendSegment(self, curve: Curve) -> bool: ...\n    @overload\n    def CleanUp() -> Curve: ...\n    @overload\n    def Duplicate() -> GeometryBase: ...\n    @overload\n    def DuplicatePolyCurve() -> PolyCurve: ...\n    @overload\n    def Explode() -> System.Array[Curve]: ...\n    @property\n    def HasGap(self) -> bool: ...\n    @property\n    def IsNested(self) -> bool: ...\n    @property\n    def SegmentCount(self) -> int: ...\n    @overload\n    def PolyCurveParameter(self, segmentIndex: int, segmentCurveParameter: float) -> float: ...\n    @overload\n    def RemoveNesting() -> bool: ...\n    @overload\n    def SegmentCurve(self, index: int) -> Curve: ...\n    @overload\n    def SegmentCurveParameter(self, polycurveParameter: float) -> float: ...\n    @overload\n    def SegmentDomain(self, segmentIndex: int) -> Interval: ...\n    @overload\n    def SegmentIndex(self, polycurveParameter: float) -> int: ...\n    @overload\n    def SegmentIndexes(self, subdomain: Interval) -> (int, int, int): ...\n\nclass Polyline(Collections.Point3dList):\n    \"\"\"Represents an ordered set of points connected by linear segments.\nPolylines are closed if start and end points coincide.\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, initialCapacity: int): ...\n    @overload\n    def __init__(self, collection: Generic.IEnumerable): ...\n    @overload\n    def BreakAtAngles(self, angle: float) -> System.Array[Polyline]: ...\n    @overload\n    def CenterPoint() -> Point3d: ...\n    @overload\n    def ClosestParameter(self, testPoint: Point3d) -> float: ...\n    @overload\n    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...\n    @overload\n    def CollapseShortSegments(self, tolerance: float) -> int: ...\n    @overload\n    @staticmethod\n    def CreateByJoiningLines(lines: Generic.IEnumerable, tolerance: float, splitAtIntersections: bool) -> System.Array[Polyline]: ...\n    @overload\n    @staticmethod\n    def CreateCircumscribedPolygon(circle: Circle, sideCount: int) -> Polyline: ...\n    @overload\n    @staticmethod\n    def CreateInscribedPolygon(circle: Circle, sideCount: int) -> Polyline: ...\n    @overload\n    @staticmethod\n    def CreateStarPolygon(circle: Circle, radius: float, cornerCount: int) -> Polyline: ...\n    @overload\n    def DeleteShortSegments(self, tolerance: float) -> int: ...\n    @overload\n    def Duplicate() -> Polyline: ...\n    @property\n    def IsClosed(self) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Length(self) -> float: ...\n    @property\n    def SegmentCount(self) -> int: ...\n    @overload\n    def GetSegments() -> System.Array[Line]: ...\n    @overload\n    def IsClosedWithinTolerance(self, tolerance: float) -> bool: ...\n    @overload\n    def MergeColinearSegments(self, angleTolerance: float, includeSeam: bool) -> int: ...\n    @overload\n    def PointAt(self, t: float) -> Point3d: ...\n    @overload\n    def ReduceSegments(self, tolerance: float) -> int: ...\n    @overload\n    def RemoveNearlyEqualSubsequentPoints(self, tolerance: float) -> None: ...\n    @overload\n    def SegmentAt(self, index: int) -> Line: ...\n    @overload\n    def Smooth(self, amount: float) -> bool: ...\n    @overload\n    def TangentAt(self, t: float) -> Vector3d: ...\n    @overload\n    def ToNurbsCurve() -> NurbsCurve: ...\n    @overload\n    def ToPolylineCurve() -> PolylineCurve: ...\n    @overload\n    def TriangulateClosedPolyline() -> System.Array[MeshFace]: ...\n    @overload\n    def Trim(self, domain: Interval) -> Polyline: ...\n\nclass PolylineCurve(Curve):\n    \"\"\"Represents the geometry of a set of linked line segments.\nThis is fundamentally a class that derives from\nand internally contains a\n.\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, other: PolylineCurve): ...\n    @overload\n    def __init__(self, points: Generic.IEnumerable): ...\n    @overload\n    @staticmethod\n    def CreateConvexHull2d(points: System.Array[Point2d]) -> (PolylineCurve, System.System.Array[int]): ...\n    @property\n    def PointCount(self) -> int: ...\n    @overload\n    def Parameter(self, index: int) -> float: ...\n    @overload\n    def Point(self, index: int) -> Point3d: ...\n    @overload\n    def SetArcLengthParameterization(self, tolerance: float) -> None: ...\n    @overload\n    def SetParameter(self, index: int, parameter: float) -> None: ...\n    @overload\n    def SetPoint(self, index: int, point: Point3d) -> None: ...\n    @overload\n    def ToArray() -> System.Array[Point3d]: ...\n    @overload\n    def ToPolyline() -> Polyline: ...\n\nclass Rectangle3d(System.ValueType):\n    \"\"\"Represents the values of a plane and two intervals that form an oriented rectangle in three dimensions.\n\n    \"\"\"\n    @overload\n    def __init__(self, plane: Plane, width: float, height: float): ...\n    @overload\n    def __init__(self, plane: Plane, width: Interval, height: Interval): ...\n    @overload\n    def __init__(self, plane: Plane, cornerA: Point3d, cornerB: Point3d): ...\n    @overload\n    def ClosestPoint(self, point: Point3d) -> Point3d: ...\n    @overload\n    def ClosestPoint(self, point: Point3d, includeInterior: bool) -> Point3d: ...\n    @overload\n    def Contains(self, pt: Point3d) -> PointContainment: ...\n    @overload\n    def Contains(self, x: float, y: float) -> PointContainment: ...\n    @overload\n    def Corner(self, index: int) -> Point3d: ...\n    @overload\n    @staticmethod\n    def CreateFromPolyline(polyline: Generic.IEnumerable) -> Rectangle3d: ...\n    @overload\n    @staticmethod\n    def CreateFromPolyline(polyline: Generic.IEnumerable) -> (Rectangle3d, float, float): ...\n    @overload\n    def EpsilonEquals(self, other: Rectangle3d, epsilon: float) -> bool: ...\n    @property\n    def Area(self) -> float: ...\n    @property\n    def BoundingBox(self) -> BoundingBox: ...\n    @property\n    def Center(self) -> Point3d: ...\n    @property\n    def Circumference(self) -> float: ...\n    @property\n    def Height(self) -> float: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Plane(self) -> Plane: ...\n    @property\n    def Unset(self) -> Rectangle3d: ...\n    @property\n    def Width(self) -> float: ...\n    @property\n    def X(self) -> Interval: ...\n    @property\n    def Y(self) -> Interval: ...\n    @overload\n    def MakeIncreasing() -> None: ...\n    @overload\n    def PointAt(self, t: float) -> Point3d: ...\n    @overload\n    def PointAt(self, x: float, y: float) -> Point3d: ...\n    @overload\n    def RecenterPlane(self, origin: Point3d) -> None: ...\n    @overload\n    def RecenterPlane(self, index: int) -> None: ...\n    @Plane.setter\n    def Plane(self, value: System.Void): ...\n    @X.setter\n    def X(self, value: System.Void): ...\n    @Y.setter\n    def Y(self, value: System.Void): ...\n    @overload\n    def ToNurbsCurve() -> NurbsCurve: ...\n    @overload\n    def ToPolyline() -> Polyline: ...\n    @overload\n    def Transform(self, xform: Transform) -> bool: ...\n\nclass RevSurface(Surface):\n    \"\"\"Represents a surface of revolution.\nRevolutions can be incomplete (they can form arcs).\n\n    \"\"\"\n    @overload\n    @staticmethod\n    def Create(revoluteCurve: Curve, axisOfRevolution: Line) -> RevSurface: ...\n    @overload\n    @staticmethod\n    def Create(revoluteLine: Line, axisOfRevolution: Line) -> RevSurface: ...\n    @overload\n    @staticmethod\n    def Create(revolutePolyline: Polyline, axisOfRevolution: Line) -> RevSurface: ...\n    @overload\n    @staticmethod\n    def Create(revoluteCurve: Curve, axisOfRevolution: Line, startAngleRadians: float, endAngleRadians: float) -> RevSurface: ...\n    @overload\n    @staticmethod\n    def Create(revoluteLine: Line, axisOfRevolution: Line, startAngleRadians: float, endAngleRadians: float) -> RevSurface: ...\n    @overload\n    @staticmethod\n    def Create(revolutePolyline: Polyline, axisOfRevolution: Line, startAngleRadians: float, endAngleRadians: float) -> RevSurface: ...\n    @overload\n    @staticmethod\n    def CreateFromCone(cone: Cone) -> RevSurface: ...\n    @overload\n    @staticmethod\n    def CreateFromCylinder(cylinder: Cylinder) -> RevSurface: ...\n    @overload\n    @staticmethod\n    def CreateFromSphere(sphere: Sphere) -> RevSurface: ...\n    @overload\n    @staticmethod\n    def CreateFromTorus(torus: Torus) -> RevSurface: ...\n    @property\n    def Angle(self) -> Interval: ...\n    @property\n    def Axis(self) -> Line: ...\n    @property\n    def Curve(self) -> Curve: ...\n    @property\n    def Interval(self) -> Interval: ...\n    @property\n    def IsTransposed(self) -> bool: ...\n\nclass RTreeEventArgs(System.EventArgs):\n    \"\"\"Represents event data that is passed when an item that meets certain criteria is found and the passed RTree event is raised.\n\n    \"\"\"\n    @property\n    def Cancel(self) -> bool: ...\n    @property\n    def Id(self) -> int: ...\n    @property\n    def IdB(self) -> int: ...\n    @property\n    def IdBPtr(self) -> System.IntPtr: ...\n    @property\n    def IdPtr(self) -> System.IntPtr: ...\n    @property\n    def SearchBoundingBox(self) -> BoundingBox: ...\n    @property\n    def SearchSphere(self) -> Sphere: ...\n    @property\n    def Tag(self) -> object: ...\n    @Cancel.setter\n    def Cancel(self, value: System.Void): ...\n    @SearchBoundingBox.setter\n    def SearchBoundingBox(self, value: System.Void): ...\n    @SearchSphere.setter\n    def SearchSphere(self, value: System.Void): ...\n    @Tag.setter\n    def Tag(self, value: System.Void): ...\n\nclass RTree(object):\n    \"\"\"Represents a spatial search structure based on implementations of the R-tree algorithm by Toni Gutman.\n\n    \"\"\"\n    def __init__(self): ...\n    @overload\n    def Clear() -> None: ...\n    @overload\n    @staticmethod\n    def CreateFromPointArray(points: Generic.IEnumerable) -> RTree: ...\n    @overload\n    @staticmethod\n    def CreateMeshFaceTree(mesh: Mesh) -> RTree: ...\n    @overload\n    @staticmethod\n    def CreatePointCloudTree(cloud: PointCloud) -> RTree: ...\n    @overload\n    def Dispose() -> None: ...\n    @property\n    def Count(self) -> int: ...\n    @overload\n    def Insert(self, point: Point3d, elementId: int) -> bool: ...\n    @overload\n    def Insert(self, point: Point2d, elementId: System.IntPtr) -> bool: ...\n    @overload\n    def Insert(self, point: Point2d, elementId: int) -> bool: ...\n    @overload\n    def Insert(self, box: BoundingBox, elementId: System.IntPtr) -> bool: ...\n    @overload\n    def Insert(self, point: Point3d, elementId: System.IntPtr) -> bool: ...\n    @overload\n    def Insert(self, box: BoundingBox, elementId: int) -> bool: ...\n    @overload\n    @staticmethod\n    def Point3dClosestPoints(hayPoints: Generic.IEnumerable, needlePts: Generic.IEnumerable, limitDistance: float) -> Generic.IEnumerable: ...\n    @overload\n    @staticmethod\n    def Point3dKNeighbors(hayPoints: Generic.IEnumerable, needlePts: Generic.IEnumerable, amount: int) -> Generic.IEnumerable: ...\n    @overload\n    @staticmethod\n    def PointCloudClosestPoints(pointcloud: PointCloud, needlePts: Generic.IEnumerable, limitDistance: float) -> Generic.IEnumerable: ...\n    @overload\n    @staticmethod\n    def PointCloudKNeighbors(pointcloud: PointCloud, needlePts: Generic.IEnumerable, amount: int) -> Generic.IEnumerable: ...\n    @overload\n    def Remove(self, point: Point3d, elementId: System.IntPtr) -> bool: ...\n    @overload\n    def Remove(self, box: BoundingBox, elementId: int) -> bool: ...\n    @overload\n    def Remove(self, box: BoundingBox, elementId: System.IntPtr) -> bool: ...\n    @overload\n    def Remove(self, point: Point2d, elementId: int) -> bool: ...\n    @overload\n    def Remove(self, point: Point3d, elementId: int) -> bool: ...\n    @overload\n    def Search(self, box: BoundingBox, callback: System.EventHandler) -> bool: ...\n    @overload\n    def Search(self, sphere: Sphere, callback: System.EventHandler) -> bool: ...\n    @overload\n    def Search(self, box: BoundingBox, callback: System.EventHandler, tag: object) -> bool: ...\n    @overload\n    def Search(self, sphere: Sphere, callback: System.EventHandler, tag: object) -> bool: ...\n    @overload\n    @staticmethod\n    def SearchOverlaps(treeA: RTree, treeB: RTree, tolerance: float, callback: System.EventHandler) -> bool: ...\n\nclass SquishParameters(object):\n    \"\"\"Parameters used by the 'Squish' command flattening algorithm\n\n    \"\"\"\n    def __init__(self): ...\n    @overload\n    def Dispose() -> None: ...\n    @property\n    def AbsoluteLimit(self) -> float: ...\n    @property\n    def Algorithm(self) -> SquishFlatteningAlgorithm: ...\n    @property\n    def BoundaryCompressConstant(self) -> float: ...\n    @property\n    def BoundaryStretchConstant(self) -> float: ...\n    @property\n    def Default(self) -> SquishParameters: ...\n    @property\n    def InteriorCompressConstant(self) -> float: ...\n    @property\n    def InteriorStretchConstant(self) -> float: ...\n    @property\n    def PreserveTopology(self) -> bool: ...\n    @property\n    def SaveMapping(self) -> bool: ...\n    @overload\n    def GetSpringConstants() -> (bool, float, float): ...\n    @AbsoluteLimit.setter\n    def AbsoluteLimit(self, value: System.Void): ...\n    @Algorithm.setter\n    def Algorithm(self, value: System.Void): ...\n    @BoundaryCompressConstant.setter\n    def BoundaryCompressConstant(self, value: System.Void): ...\n    @BoundaryStretchConstant.setter\n    def BoundaryStretchConstant(self, value: System.Void): ...\n    @InteriorCompressConstant.setter\n    def InteriorCompressConstant(self, value: System.Void): ...\n    @InteriorStretchConstant.setter\n    def InteriorStretchConstant(self, value: System.Void): ...\n    @PreserveTopology.setter\n    def PreserveTopology(self, value: System.Void): ...\n    @SaveMapping.setter\n    def SaveMapping(self, value: System.Void): ...\n    @overload\n    def SetDeformation(self, deformation: SquishDeformation, bPreserveBoundary: bool, boundaryStretchConstant: float, boundaryCompressConstant: float, interiorStretchConstant: float, interiorCompressConstant: float) -> None: ...\n    @overload\n    def SetSpringConstants(self, boundaryBias: float, deformationBias: float) -> None: ...\n\nclass Squisher(object):\n    \"\"\"class used to wrap Squish functions\n\n    \"\"\"\n    def __init__(self): ...\n    @overload\n    def Dispose() -> None: ...\n    @overload\n    def Get2dMesh() -> Mesh: ...\n    @overload\n    def Get3dMesh() -> Mesh: ...\n    @overload\n    def GetAreaConstrainedTrianglesIndices() -> System.Array[MeshFace]: ...\n    @overload\n    def GetLengthConstrained2dLines() -> System.Array[Line]: ...\n    @overload\n    def GetLengthConstrained3dLines() -> System.Array[Line]: ...\n    @overload\n    def GetMesh2dEdges() -> System.Array[Line]: ...\n    @overload\n    def GetMesh3dEdges() -> System.Array[Line]: ...\n    @overload\n    @staticmethod\n    def Is2dPatternSquished(geometry: GeometryBase) -> bool: ...\n    @overload\n    @staticmethod\n    def SquishBack2dMarks(squishedGeometry: GeometryBase, marks: Generic.IEnumerable) -> Generic.IEnumerable: ...\n    @overload\n    def SquishCurve(self, curve: Curve) -> PolylineCurve: ...\n    @overload\n    def SquishMesh(self, sp: SquishParameters, mesh3d: Mesh) -> Mesh: ...\n    @overload\n    def SquishMesh(self, sp: SquishParameters, mesh3d: Mesh, marks: Generic.IEnumerable, squished_marks_out: Generic.List) -> Mesh: ...\n    @overload\n    def SquishPoint(self, point: Point3d) -> (bool, Point3d): ...\n    @overload\n    def SquishSurface(self, sp: SquishParameters, surface: Surface) -> Brep: ...\n    @overload\n    def SquishSurface(self, sp: SquishParameters, surface: Surface, marks: Generic.IEnumerable, squished_marks_out: Generic.List) -> Brep: ...\n    @overload\n    def SquishTextDot(self, textDot: TextDot) -> TextDot: ...\n\nclass SubDComponent(object):\n    \"\"\"A part of SubD geometry. Common base class for vertices, faces, and edges\n\n    \"\"\"\n    @property\n    def Id(self) -> System.UInt32: ...\n    @property\n    def IsDamaged(self) -> bool: ...\n    @property\n    def IsDeleted(self) -> bool: ...\n    @property\n    def IsHidden(self) -> bool: ...\n    @property\n    def IsHighlighted(self) -> bool: ...\n    @property\n    def IsLocked(self) -> bool: ...\n    @property\n    def IsSelected(self) -> bool: ...\n    @property\n    def ParentSubD(self) -> SubD: ...\n\nclass SubDFace(SubDComponent):\n    \"\"\"Single face of a SubD\n\n    \"\"\"\n    @overload\n    def ComponentIndex() -> ComponentIndex: ...\n    @overload\n    def EdgeAt(self, index: int) -> SubDEdge: ...\n    @overload\n    def EdgeDirectionMatchesFaceOrientation(self, index: int) -> bool: ...\n    @property\n    def ControlNetCenterFrame(self) -> Plane: ...\n    @property\n    def ControlNetCenterNormal(self) -> Vector3d: ...\n    @property\n    def ControlNetCenterPoint(self) -> Point3d: ...\n    @property\n    def EdgeCount(self) -> int: ...\n    @property\n    def LimitSurfaceCenterPoint(self) -> Point3d: ...\n    @property\n    def PerFaceColor(self) -> Drawing.Color: ...\n    @property\n    def SurfaceCenterFrame(self) -> Plane: ...\n    @property\n    def SurfaceCenterNormal(self) -> Vector3d: ...\n    @property\n    def VertexCount(self) -> int: ...\n    @PerFaceColor.setter\n    def PerFaceColor(self, value: System.Void): ...\n    @overload\n    def VertexAt(self, index: int) -> SubDVertex: ...\n\nclass SubDVertex(SubDComponent):\n    \"\"\"Single vertex of a SubD\n\n    \"\"\"\n    @overload\n    def EdgeAt(self, index: int) -> SubDEdge: ...\n    @overload\n    def FaceAt(self, index: int) -> SubDFace: ...\n    @property\n    def ControlNetPoint(self) -> Point3d: ...\n    @property\n    def EdgeCount(self) -> int: ...\n    @property\n    def Edges(self) -> Generic.IEnumerable: ...\n    @property\n    def FaceCount(self) -> int: ...\n    @property\n    def Next(self) -> SubDVertex: ...\n    @property\n    def Previous(self) -> SubDVertex: ...\n    @property\n    def Tag(self) -> SubDVertexTag: ...\n    @ControlNetPoint.setter\n    def ControlNetPoint(self, value: System.Void): ...\n    @Tag.setter\n    def Tag(self, value: System.Void): ...\n    @overload\n    def SetControlNetPoint(self, position: Point3d, bClearNeighborhoodCache: bool) -> bool: ...\n    @overload\n    def SurfacePoint() -> Point3d: ...\n\nclass SubDEdge(SubDComponent):\n    \"\"\"Single edge of a SubD\n\n    \"\"\"\n    @overload\n    def ComponentIndex() -> ComponentIndex: ...\n    @overload\n    def FaceAt(self, index: int) -> SubDFace: ...\n    @property\n    def ControlNetLine(self) -> Line: ...\n    @property\n    def FaceCount(self) -> int: ...\n    @property\n    def Tag(self) -> SubDEdgeTag: ...\n    @property\n    def VertexFrom(self) -> SubDVertex: ...\n    @property\n    def VertexTo(self) -> SubDVertex: ...\n    @Tag.setter\n    def Tag(self, value: System.Void): ...\n    @overload\n    def ToNurbsCurve(self, clampEnds: bool) -> NurbsCurve: ...\n\nclass SumSurface(Surface):\n    \"\"\"Represents a sum surface, or an extrusion of a curve along a curved path.\n\n    \"\"\"\n    @overload\n    @staticmethod\n    def Create(curveA: Curve, curveB: Curve) -> SumSurface: ...\n    @overload\n    @staticmethod\n    def Create(curve: Curve, extrusionDirection: Vector3d) -> SumSurface: ...\n\nclass IsoStatus(enum.Enum):\n    None_ = 0\n    X = 1\n    Y = 2\n    West = 3\n    South = 4\n    East = 5\n    North = 6\n\nclass SurfaceCurvature(object):\n    \"\"\"Maintains computed information for surface curvature evaluation.\n\n    \"\"\"\n    @overload\n    def Direction(self, direction: int) -> Vector3d: ...\n    @property\n    def Gaussian(self) -> float: ...\n    @property\n    def Mean(self) -> float: ...\n    @property\n    def Normal(self) -> Vector3d: ...\n    @property\n    def Point(self) -> Point3d: ...\n    @property\n    def UVPoint(self) -> Point2d: ...\n    @overload\n    def Kappa(self, direction: int) -> float: ...\n    @overload\n    def OsculatingCircle(self, direction: int) -> Circle: ...\n\nclass Surface(GeometryBase):\n    \"\"\"Represents a base class that is common to most RhinoCommon surface types.\nA surface represents an entity that can be all visited by providing two independent parameters, usually called (u, v), or sometimes (s, t).\n\n    \"\"\"\n    @overload\n    def ClosestPoint(self, testPoint: Point3d) -> (bool, float, float): ...\n    @overload\n    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...\n    @overload\n    @staticmethod\n    def CreateExtrusion(profile: Curve, direction: Vector3d) -> Surface: ...\n    @overload\n    @staticmethod\n    def CreateExtrusionToPoint(profile: Curve, apexPoint: Point3d) -> Surface: ...\n    @overload\n    @staticmethod\n    def CreatePeriodicSurface(surface: Surface, direction: int) -> Surface: ...\n    @overload\n    @staticmethod\n    def CreatePeriodicSurface(surface: Surface, direction: int, bSmooth: bool) -> Surface: ...\n    @overload\n    @staticmethod\n    def CreateRollingBallFillet(surfaceA: Surface, surfaceB: Surface, radius: float, tolerance: float) -> System.Array[Surface]: ...\n    @overload\n    @staticmethod\n    def CreateRollingBallFillet(surfaceA: Surface, flipA: bool, surfaceB: Surface, flipB: bool, radius: float, tolerance: float) -> System.Array[Surface]: ...\n    @overload\n    @staticmethod\n    def CreateRollingBallFillet(surfaceA: Surface, uvA: Point2d, surfaceB: Surface, uvB: Point2d, radius: float, tolerance: float) -> System.Array[Surface]: ...\n    @overload\n    @staticmethod\n    def CreateSoftEditSurface(surface: Surface, uv: Point2d, delta: Vector3d, uLength: float, vLength: float, tolerance: float, fixEnds: bool) -> Surface: ...\n    @overload\n    @staticmethod\n    def CreateTweenSurfacesWithSampling(surface0: Surface, surface1: Surface, numSurfaces: int, numSamples: int, tolerance: float) -> System.Array[Surface]: ...\n    @overload\n    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...\n    @overload\n    def Degree(self, direction: int) -> int: ...\n    @overload\n    def Domain(self, direction: int) -> Interval: ...\n    @overload\n    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> (bool, Point3d, System.Array[Vector3d]): ...\n    @overload\n    def Extend(self, direction: int, interval: Interval) -> bool: ...\n    @overload\n    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...\n    @overload\n    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...\n    @overload\n    def FitCurveToSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Generic.IEnumerable, divideIntoSections: bool) -> (System.Array[Curve], Curve, Curve): ...\n    @overload\n    def FrameAt(self, u: float, v: float) -> (bool, Plane): ...\n    @property\n    def IsSolid(self) -> bool: ...\n    @property\n    def IsSubDFriendly(self) -> bool: ...\n    @overload\n    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> (bool, float): ...\n    @overload\n    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> (bool, float): ...\n    @overload\n    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> (bool, float, float): ...\n    @overload\n    def GetSpanVector(self, direction: int) -> System.System.Array[float]: ...\n    @overload\n    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> (bool, float, float): ...\n    @overload\n    def GetSurfaceSize() -> (bool, float, float): ...\n    @overload\n    def HasNurbsForm() -> int: ...\n    @overload\n    def InterpolatedCurveOnSurface(self, points: Generic.IEnumerable, tolerance: float) -> NurbsCurve: ...\n    @overload\n    def InterpolatedCurveOnSurfaceUV(self, points: Generic.IEnumerable, tolerance: float) -> NurbsCurve: ...\n    @overload\n    def InterpolatedCurveOnSurfaceUV(self, points: Generic.IEnumerable, tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...\n    @overload\n    def IsAtSeam(self, u: float, v: float) -> int: ...\n    @overload\n    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...\n    @overload\n    def IsClosed(self, direction: int) -> bool: ...\n    @overload\n    def IsCone() -> bool: ...\n    @overload\n    def IsCone(self, tolerance: float) -> bool: ...\n    @overload\n    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...\n    @overload\n    def IsCylinder() -> bool: ...\n    @overload\n    def IsCylinder(self, tolerance: float) -> bool: ...\n    @overload\n    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...\n    @overload\n    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...\n    @overload\n    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...\n    @overload\n    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...\n    @overload\n    def IsPeriodic(self, direction: int) -> bool: ...\n    @overload\n    def IsPlanar() -> bool: ...\n    @overload\n    def IsPlanar(self, tolerance: float) -> bool: ...\n    @overload\n    def IsSingular(self, side: int) -> bool: ...\n    @overload\n    def IsSphere() -> bool: ...\n    @overload\n    def IsSphere(self, tolerance: float) -> bool: ...\n    @overload\n    def IsTorus() -> bool: ...\n    @overload\n    def IsTorus(self, tolerance: float) -> bool: ...\n    @overload\n    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> (bool, float, float): ...\n    @overload\n    def NormalAt(self, u: float, v: float) -> Vector3d: ...\n    @overload\n    def Offset(self, distance: float, tolerance: float) -> Surface: ...\n    @overload\n    def PointAt(self, u: float, v: float) -> Point3d: ...\n    @overload\n    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...\n    @overload\n    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...\n    @overload\n    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...\n    @overload\n    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...\n    @overload\n    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...\n    @overload\n    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...\n    @overload\n    def RefitSimplySplitSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, knotAdditionMode: RefitTrimKnotMode, numInsertKnots: int, Knots: Generic.IEnumerable, sectionMode: RefitTrimSectionMode, numNonTrimSpans: int, meetCurve: bool, oneSided: bool, PtActive: Point3d, outputSurface: bool, outputCurve: bool, lowerSurface: Generic.List, upperSurface: Generic.List, edgeCurve: Generic.List) -> (bool, int, float, Curve, Curve): ...\n    @overload\n    def RefitSplit(self, curve: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Generic.IEnumerable, bMeetCurve: bool, divideIntoSections: bool, srfLower: Generic.List, srfUpper: Generic.List, edgeCurve: Generic.List) -> (int, Curve, Curve): ...\n    @overload\n    def Reverse(self, direction: int) -> Surface: ...\n    @overload\n    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...\n    @overload\n    def SetDomain(self, direction: int, domain: Interval) -> bool: ...\n    @overload\n    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...\n    @overload\n    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...\n    @overload\n    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...\n    @overload\n    def SpanCount(self, direction: int) -> int: ...\n    @overload\n    def Split(self, direction: int, parameter: float) -> System.Array[Surface]: ...\n    @overload\n    def ToBrep() -> Brep: ...\n    @overload\n    def ToNurbsSurface() -> NurbsSurface: ...\n    @overload\n    def ToNurbsSurface(self, tolerance: float) -> (NurbsSurface, int): ...\n    @overload\n    def Transpose() -> Surface: ...\n    @overload\n    def Transpose(self, inPlace: bool) -> Surface: ...\n    @overload\n    def Trim(self, u: Interval, v: Interval) -> Surface: ...\n    @overload\n    def TryGetCone() -> (bool, Cone): ...\n    @overload\n    def TryGetCone(self, tolerance: float) -> (bool, Cone): ...\n    @overload\n    def TryGetCylinder() -> (bool, Cylinder): ...\n    @overload\n    def TryGetCylinder(self, tolerance: float) -> (bool, Cylinder): ...\n    @overload\n    def TryGetFiniteCylinder(self, tolerance: float) -> (bool, Cylinder): ...\n    @overload\n    def TryGetPlane() -> (bool, Plane): ...\n    @overload\n    def TryGetPlane(self, tolerance: float) -> (bool, Plane): ...\n    @overload\n    def TryGetSphere() -> (bool, Sphere): ...\n    @overload\n    def TryGetSphere(self, tolerance: float) -> (bool, Sphere): ...\n    @overload\n    def TryGetTorus() -> (bool, Torus): ...\n    @overload\n    def TryGetTorus(self, tolerance: float) -> (bool, Torus): ...\n    @overload\n    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...\n    @overload\n    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Generic.IEnumerable, interiorDistances: Generic.IEnumerable, tolerance: float) -> Surface: ...\n\nclass SurfaceProxy(Surface):\n    \"\"\"Provides a base class to brep faces and other surface proxies.\n\n    \"\"\"\n\nclass TextRunType(enum.Enum):\n    None_ = 0\n    Text = 1\n    Newline = 2\n    Paragraph = 3\n    Column = 4\n    Field = 5\n    Fontdef = 6\n    Header = 7\n\nclass TextEntity(AnnotationBase):\n    \"\"\"    \"\"\"\n    def __init__(self): ...\n    @overload\n    @staticmethod\n    def Create(text: str, plane: Plane, style: DocObjects.DimensionStyle, wrapped: bool, rectWidth: float, rotationRadians: float) -> TextEntity: ...\n    @overload\n    def CreateCurves(self, dimstyle: DocObjects.DimensionStyle, allowOpen: bool, smallCapsScale: float, spacing: float) -> System.Array[Curve]: ...\n    @overload\n    def CreateCurvesGrouped(self, dimstyle: DocObjects.DimensionStyle, allowOpen: bool, smallCapsScale: float, spacing: float) -> Generic.List: ...\n    @overload\n    def CreateExtrusions(self, dimstyle: DocObjects.DimensionStyle, height: float, smallCapsScale: float, spacing: float) -> System.Array[Extrusion]: ...\n    @overload\n    def CreateExtrusionsGrouped(self, dimstyle: DocObjects.DimensionStyle, smallCapsScale: float, height: float, spacing: float) -> Generic.List: ...\n    @overload\n    def CreatePolySurfaces(self, dimstyle: DocObjects.DimensionStyle, height: float, smallCapsScale: float, spacing: float) -> System.Array[Brep]: ...\n    @overload\n    def CreatePolysurfacesGrouped(self, dimstyle: DocObjects.DimensionStyle, smallCapsScale: float, height: float, spacing: float) -> Generic.List: ...\n    @overload\n    def CreateSurfaces(self, dimstyle: DocObjects.DimensionStyle, smallCapsScale: float, spacing: float) -> System.Array[Brep]: ...\n    @overload\n    def CreateSurfacesGrouped(self, dimstyle: DocObjects.DimensionStyle, smallCapsScale: float, spacing: float) -> Generic.List: ...\n    @overload\n    @staticmethod\n    def CreateWithRichText(richTextString: str, plane: Plane, style: DocObjects.DimensionStyle, wrapped: bool, rectWidth: float, rotationRadians: float) -> TextEntity: ...\n    @overload\n    def Explode() -> System.Array[Curve]: ...\n    @property\n    def Justification(self) -> TextJustification: ...\n    @property\n    def TextHorizontalAlignment(self) -> DocObjects.TextHorizontalAlignment: ...\n    @property\n    def TextOrientation(self) -> DocObjects.TextOrientation: ...\n    @property\n    def TextVerticalAlignment(self) -> DocObjects.TextVerticalAlignment: ...\n    @overload\n    def GetTextTransform(self, textscale: float, dimstyle: DocObjects.DimensionStyle) -> Transform: ...\n    @Justification.setter\n    def Justification(self, value: System.Void): ...\n    @TextHorizontalAlignment.setter\n    def TextHorizontalAlignment(self, value: System.Void): ...\n    @TextOrientation.setter\n    def TextOrientation(self, value: System.Void): ...\n    @TextVerticalAlignment.setter\n    def TextVerticalAlignment(self, value: System.Void): ...\n    @overload\n    def Transform(self, transform: Transform, style: DocObjects.DimensionStyle) -> bool: ...\n\nclass DistancingMode(enum.Enum):\n    Undefined = 0\n    Linear = 1\n    LinearFromEnd = 2\n    Ratio = 3\n    RatioFromEnd = 4\n\nclass MeshExtruder(object):\n    \"\"\"Extrudes a mesh and provides preview\n\n    \"\"\"\n    def __init__(self, inputMesh: Mesh, componentIndices: Generic.IEnumerable): ...\n    @overload\n    def Dispose() -> None: ...\n    @overload\n    def ExtrudedMesh() -> (bool, Mesh): ...\n    @overload\n    def ExtrudedMesh() -> (bool, Mesh, Generic.List): ...\n    @property\n    def EdgeBasedUVN(self) -> bool: ...\n    @property\n    def FaceDirectionMode(self) -> MeshExtruderFaceDirectionMode: ...\n    @property\n    def KeepOriginalFaces(self) -> bool: ...\n    @property\n    def PreviewLines(self) -> System.Array[Line]: ...\n    @property\n    def SurfaceParameterMode(self) -> MeshExtruderParameterMode: ...\n    @property\n    def TextureCoordinateMode(self) -> MeshExtruderParameterMode: ...\n    @property\n    def Transform(self) -> Transform: ...\n    @property\n    def UVN(self) -> bool: ...\n    @overload\n    def GetWallFaces() -> Generic.List: ...\n    @EdgeBasedUVN.setter\n    def EdgeBasedUVN(self, value: System.Void): ...\n    @FaceDirectionMode.setter\n    def FaceDirectionMode(self, value: System.Void): ...\n    @KeepOriginalFaces.setter\n    def KeepOriginalFaces(self, value: System.Void): ...\n    @SurfaceParameterMode.setter\n    def SurfaceParameterMode(self, value: System.Void): ...\n    @TextureCoordinateMode.setter\n    def TextureCoordinateMode(self, value: System.Void): ...\n    @Transform.setter\n    def Transform(self, value: System.Void): ...\n    @UVN.setter\n    def UVN(self, value: System.Void): ...\n\nclass MeshUnwrapper(object):\n    \"\"\"Unwraps meshes and stores the result in their texture coordinates\n\n    \"\"\"\n    @overload\n    def __init__(self, mesh: Mesh): ...\n    @overload\n    def __init__(self, meshes: Generic.IEnumerable): ...\n    @overload\n    def Dispose() -> None: ...\n    @SymmetryPlane.setter\n    def SymmetryPlane(self, value: System.Void): ...\n    @overload\n    def Unwrap(self, method: MeshUnwrapMethod) -> bool: ...\n\nclass Interpolator(Collections.RhinoList):\n    \"\"\"Exposes a set of standard numeric interpolation algorithms.\n\n    \"\"\"\n    @overload\n    def __init__(self): ...\n    @overload\n    def __init__(self, initialCapacity: int): ...\n    @overload\n    def __init__(self, list_: Collections.RhinoList): ...\n    @overload\n    def __init__(self, collection: Generic.IEnumerable): ...\n    @overload\n    def __init__(self, amount: int, defaultValue: float): ...\n    @property\n    def Cyclical(self) -> bool: ...\n    @overload\n    def InterpolateCatmullRom(self, t: float) -> float: ...\n    @overload\n    def InterpolateCosine(self, t: float) -> float: ...\n    @overload\n    def InterpolateCubic(self, t: float) -> float: ...\n    @overload\n    def InterpolateLinear(self, t: float) -> float: ...\n    @overload\n    def InterpolateNearestNeighbour(self, t: float) -> float: ...\n    @Cyclical.setter\n    def Cyclical(self, value: System.Void): ...\n\nclass Particle(object):\n    \"\"\"Represents a simple particle.\nThis base class only defines position and display properties (size, color, bitmap id). You will most likely create a class that derives from this particle class to perform some sort of physical simulation (movement over time or frames).\n\n    \"\"\"\n    def __init__(self): ...\n    @property\n    def Color(self) -> Drawing.Color: ...\n    @property\n    def DisplayBitmapIndex(self) -> int: ...\n    @property\n    def Index(self) -> int: ...\n    @property\n    def Location(self) -> Point3d: ...\n    @property\n    def ParentSystem(self) -> ParticleSystem: ...\n    @property\n    def Size(self) -> System.Single: ...\n    @Color.setter\n    def Color(self, value: System.Void): ...\n    @DisplayBitmapIndex.setter\n    def DisplayBitmapIndex(self, value: System.Void): ...\n    @Location.setter\n    def Location(self, value: System.Void): ...\n    @Size.setter\n    def Size(self, value: System.Void): ...\n    @overload\n    def Update() -> None: ...\n\nclass ParticleSystem(object):\n    \"\"\"    \"\"\"\n    def __init__(self): ...\n    @overload\n    def Add(self, particle: Particle) -> bool: ...\n    @overload\n    def Clear() -> None: ...\n    @property\n    def BoundingBox(self) -> BoundingBox: ...\n    @property\n    def DisplaySizesInWorldUnits(self) -> bool: ...\n    @property\n    def DrawRequiresDepthSorting(self) -> bool: ...\n    @overload\n    def GetEnumerator() -> Generic.IEnumerator: ...\n    @overload\n    def Remove(self, particle: Particle) -> None: ...\n    @DisplaySizesInWorldUnits.setter\n    def DisplaySizesInWorldUnits(self, value: System.Void): ...\n    @DrawRequiresDepthSorting.setter\n    def DrawRequiresDepthSorting(self, value: System.Void): ...\n    @overload\n    def Update() -> None: ...\n\nclass Arc(System.ValueType):\n    \"\"\"Represents the value of a plane, two angles and a radius in a sub-curve of a three-dimensional circle.\nThe curve is parameterized by an angle expressed in radians. For an IsValid arc the total subtended angle AngleRadians() = Domain()(1) - Domain()(0) must satisfy 0 < AngleRadians() < 2*Pi\nThe parameterization of the Arc is inherited from the Circle it is derived from. In particular\nt -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxis\nwhere xaxis and yaxis, (part of Circle.Plane) form an orthonormal frame of the plane containing the circle.\n\n    \"\"\"\n    @overload\n    def __init__(self, circle: Circle, angleRadians: float): ...\n    @overload\n    def __init__(self, circle: Circle, angleIntervalRadians: Interval): ...\n    @overload\n    def __init__(self, plane: Plane, radius: float, angleRadians: float): ...\n    @overload\n    def __init__(self, center: Point3d, radius: float, angleRadians: float): ...\n    @overload\n    def __init__(self, startPoint: Point3d, pointOnInterior: Point3d, endPoint: Point3d): ...\n    @overload\n    def __init__(self, pointA: Point3d, tangentA: Vector3d, pointB: Point3d): ...\n    @overload\n    def __init__(self, plane: Plane, center: Point3d, radius: float, angleRadians: float): ...\n    @overload\n    def BoundingBox() -> BoundingBox: ...\n    @overload\n    def ClosestParameter(self, testPoint: Point3d) -> float: ...\n    @overload\n    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...\n    @overload\n    def EpsilonEquals(self, other: Arc, epsilon: float) -> bool: ...\n    @overload\n    def Equals(self, other: Arc) -> bool: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @property\n    def Angle(self) -> float: ...\n    @property\n    def AngleDegrees(self) -> float: ...\n    @property\n    def AngleDomain(self) -> Interval: ...\n    @property\n    def Center(self) -> Point3d: ...\n    @property\n    def Circumference(self) -> float: ...\n    @property\n    def Diameter(self) -> float: ...\n    @property\n    def EndAngle(self) -> float: ...\n    @property\n    def EndAngleDegrees(self) -> float: ...\n    @property\n    def EndPoint(self) -> Point3d: ...\n    @property\n    def IsCircle(self) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Length(self) -> float: ...\n    @property\n    def MidPoint(self) -> Point3d: ...\n    @property\n    def Plane(self) -> Plane: ...\n    @property\n    def Radius(self) -> float: ...\n    @property\n    def StartAngle(self) -> float: ...\n    @property\n    def StartAngleDegrees(self) -> float: ...\n    @property\n    def StartPoint(self) -> Point3d: ...\n    @property\n    def Unset(self) -> Arc: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    def PointAt(self, t: float) -> Point3d: ...\n    @overload\n    def Reverse() -> None: ...\n    @Angle.setter\n    def Angle(self, value: System.Void): ...\n    @AngleDegrees.setter\n    def AngleDegrees(self, value: System.Void): ...\n    @AngleDomain.setter\n    def AngleDomain(self, value: System.Void): ...\n    @Center.setter\n    def Center(self, value: System.Void): ...\n    @Diameter.setter\n    def Diameter(self, value: System.Void): ...\n    @EndAngle.setter\n    def EndAngle(self, value: System.Void): ...\n    @EndAngleDegrees.setter\n    def EndAngleDegrees(self, value: System.Void): ...\n    @Plane.setter\n    def Plane(self, value: System.Void): ...\n    @Radius.setter\n    def Radius(self, value: System.Void): ...\n    @StartAngle.setter\n    def StartAngle(self, value: System.Void): ...\n    @StartAngleDegrees.setter\n    def StartAngleDegrees(self, value: System.Void): ...\n    @overload\n    def TangentAt(self, t: float) -> Vector3d: ...\n    @overload\n    def ToNurbsCurve() -> NurbsCurve: ...\n    @overload\n    def ToNurbsCurve(self, degree: int, cvCount: int) -> NurbsCurve: ...\n    @overload\n    def Transform(self, xform: Transform) -> bool: ...\n    @overload\n    def Trim(self, domain: Interval) -> bool: ...\n\nclass BoundingBox(System.ValueType):\n    \"\"\"Represents the value of two points in a bounding box defined by the two extreme corner points.\nThis box is therefore aligned to the world X, Y and Z axes.\n\n    \"\"\"\n    @overload\n    def __init__(self, points: Generic.IEnumerable): ...\n    @overload\n    def __init__(self, min_: Point3d, max_: Point3d): ...\n    @overload\n    def __init__(self, points: Generic.IEnumerable, xform: Transform): ...\n    @overload\n    def __init__(self, minX: float, minY: float, minZ: float, maxX: float, maxY: float, maxZ: float): ...\n    @overload\n    def ClosestPoint(self, point: Point3d) -> Point3d: ...\n    @overload\n    def ClosestPoint(self, point: Point3d, includeInterior: bool) -> Point3d: ...\n    @overload\n    def Contains(self, point: Point3d) -> bool: ...\n    @overload\n    def Contains(self, box: BoundingBox) -> bool: ...\n    @overload\n    def Contains(self, box: BoundingBox, strict: bool) -> bool: ...\n    @overload\n    def Contains(self, point: Point3d, strict: bool) -> bool: ...\n    @overload\n    def Corner(self, minX: bool, minY: bool, minZ: bool) -> Point3d: ...\n    @overload\n    def FurthestPoint(self, point: Point3d) -> Point3d: ...\n    @property\n    def Area(self) -> float: ...\n    @property\n    def Center(self) -> Point3d: ...\n    @property\n    def Diagonal(self) -> Vector3d: ...\n    @property\n    def Empty(self) -> BoundingBox: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Max(self) -> Point3d: ...\n    @property\n    def Min(self) -> Point3d: ...\n    @property\n    def Unset(self) -> BoundingBox: ...\n    @property\n    def Volume(self) -> float: ...\n    @overload\n    def GetCorners() -> System.Array[Point3d]: ...\n    @overload\n    def GetEdges() -> System.Array[Line]: ...\n    @overload\n    def Inflate(self, amount: float) -> None: ...\n    @overload\n    def Inflate(self, xAmount: float, yAmount: float, zAmount: float) -> None: ...\n    @overload\n    @staticmethod\n    def Intersection(a: BoundingBox, b: BoundingBox) -> BoundingBox: ...\n    @overload\n    def IsDegenerate(self, tolerance: float) -> int: ...\n    @overload\n    def MakeValid() -> bool: ...\n    @overload\n    def PointAt(self, tx: float, ty: float, tz: float) -> Point3d: ...\n    @Max.setter\n    def Max(self, value: System.Void): ...\n    @Min.setter\n    def Min(self, value: System.Void): ...\n    @overload\n    def ToBrep() -> Brep: ...\n    @overload\n    def ToString() -> str: ...\n    @overload\n    def Transform(self, xform: Transform) -> bool: ...\n    @overload\n    def Union(self, other: BoundingBox) -> None: ...\n    @overload\n    def Union(self, point: Point3d) -> None: ...\n    @overload\n    @staticmethod\n    def Union(a: BoundingBox, b: BoundingBox) -> BoundingBox: ...\n    @overload\n    @staticmethod\n    def Union(box: BoundingBox, point: Point3d) -> BoundingBox: ...\n\nclass Circle(System.ValueType):\n    \"\"\"Represents a circle in 3D.\nThe values used are a radius and an orthonormal frame of the plane containing the circle, with origin at the center.\nThe circle is parameterized by radians from 0 to 2 Pi given by\nt -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxis\nwhere center, xaxis and yaxis define the orthonormal frame of the circle plane.\n\n    \"\"\"\n    @overload\n    def __init__(self, radius: float): ...\n    @overload\n    def __init__(self, arc: Arc): ...\n    @overload\n    def __init__(self, plane: Plane, radius: float): ...\n    @overload\n    def __init__(self, center: Point3d, radius: float): ...\n    @overload\n    def __init__(self, point1: Point3d, point2: Point3d, point3: Point3d): ...\n    @overload\n    def __init__(self, plane: Plane, center: Point3d, radius: float): ...\n    @overload\n    def __init__(self, startPoint: Point3d, tangentAtP: Vector3d, pointOnCircle: Point3d): ...\n    @overload\n    def ClosestParameter(self, testPoint: Point3d) -> (bool, float): ...\n    @overload\n    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...\n    @overload\n    def DerivativeAt(self, derivative: int, t: float) -> Vector3d: ...\n    @overload\n    def EpsilonEquals(self, other: Circle, epsilon: float) -> bool: ...\n    @property\n    def BoundingBox(self) -> BoundingBox: ...\n    @property\n    def Center(self) -> Point3d: ...\n    @property\n    def Circumference(self) -> float: ...\n    @property\n    def Diameter(self) -> float: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Normal(self) -> Vector3d: ...\n    @property\n    def Plane(self) -> Plane: ...\n    @property\n    def Radius(self) -> float: ...\n    @property\n    def Unset(self) -> Circle: ...\n    @overload\n    def IsInPlane(self, plane: Plane, tolerance: float) -> bool: ...\n    @overload\n    def PointAt(self, t: float) -> Point3d: ...\n    @overload\n    def Reverse() -> None: ...\n    @overload\n    def Rotate(self, angle: float, axis: Vector3d) -> bool: ...\n    @overload\n    def Rotate(self, angle: float, axis: Vector3d, point: Point3d) -> bool: ...\n    @overload\n    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d) -> bool: ...\n    @overload\n    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d, point: Point3d) -> bool: ...\n    @Center.setter\n    def Center(self, value: System.Void): ...\n    @Circumference.setter\n    def Circumference(self, value: System.Void): ...\n    @Diameter.setter\n    def Diameter(self, value: System.Void): ...\n    @Plane.setter\n    def Plane(self, value: System.Void): ...\n    @Radius.setter\n    def Radius(self, value: System.Void): ...\n    @overload\n    def TangentAt(self, t: float) -> Vector3d: ...\n    @overload\n    def ToNurbsCurve() -> NurbsCurve: ...\n    @overload\n    def ToNurbsCurve(self, degree: int, cvCount: int) -> NurbsCurve: ...\n    @overload\n    def Transform(self, xform: Transform) -> bool: ...\n    @overload\n    def Translate(self, delta: Vector3d) -> bool: ...\n    @overload\n    @staticmethod\n    def TryFitCircleToPoints(points: Generic.IEnumerable) -> (bool, Circle): ...\n    @overload\n    @staticmethod\n    def TryFitCircleTT(c1: Curve, c2: Curve, t1: float, t2: float) -> Circle: ...\n    @overload\n    @staticmethod\n    def TryFitCircleTTT(c1: Curve, c2: Curve, c3: Curve, t1: float, t2: float, t3: float) -> Circle: ...\n    @overload\n    @staticmethod\n    def TrySmallestEnclosingCircle(points: Generic.IEnumerable, tolerance: float) -> (bool, Circle, System.System.Array[int]): ...\n\nclass Cone(System.ValueType):\n    \"\"\"Represents the center plane, radius and height values in a right circular cone.\n\n    \"\"\"\n    def __init__(self, plane: Plane, height: float, radius: float): ...\n    @overload\n    def AngleInDegrees() -> float: ...\n    @overload\n    def AngleInRadians() -> float: ...\n    @overload\n    def EpsilonEquals(self, other: Cone, epsilon: float) -> bool: ...\n    @property\n    def ApexPoint(self) -> Point3d: ...\n    @property\n    def Axis(self) -> Vector3d: ...\n    @property\n    def BasePoint(self) -> Point3d: ...\n    @property\n    def Height(self) -> float: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Plane(self) -> Plane: ...\n    @property\n    def Radius(self) -> float: ...\n    @property\n    def Unset(self) -> Cone: ...\n    @Height.setter\n    def Height(self, value: System.Void): ...\n    @Plane.setter\n    def Plane(self, value: System.Void): ...\n    @Radius.setter\n    def Radius(self, value: System.Void): ...\n    @overload\n    def ToBrep(self, capBottom: bool) -> Brep: ...\n    @overload\n    def ToNurbsSurface() -> NurbsSurface: ...\n    @overload\n    def ToRevSurface() -> RevSurface: ...\n\nclass BlendContinuity(enum.Enum):\n    Position = 0\n    Tangency = 1\n    Curvature = 2\n\nclass PreserveEnd(enum.Enum):\n    None_ = 0\n    Position = 1\n    Tangency = 2\n    Curvature = 3\n\nclass CurveOffsetCornerStyle(enum.Enum):\n    None_ = 0\n    Sharp = 1\n    Round = 2\n    Smooth = 3\n    Chamfer = 4\n\nclass CurveOffsetEndStyle(enum.Enum):\n    None_ = 0\n    Flat = 1\n    Round = 2\n\nclass CurveKnotStyle(enum.Enum):\n    Uniform = 0\n    Chord = 1\n    ChordSquareRoot = 2\n    UniformPeriodic = 3\n    ChordPeriodic = 4\n    ChordSquareRootPeriodic = 5\n\nclass CurveOrientation(enum.Enum):\n    Undefined = 0\n    CounterClockwise = 1\n    Clockwise = -1\n\nclass PointContainment(enum.Enum):\n    Unset = 0\n    Inside = 1\n    Outside = 2\n    Coincident = 3\n\nclass RegionContainment(enum.Enum):\n    Disjoint = 0\n    MutualIntersection = 1\n    AInsideB = 2\n    BInsideA = 3\n\nclass CurveExtensionStyle(enum.Enum):\n    Line = 0\n    Arc = 1\n    Smooth = 2\n\nclass CurveSimplifyOptions(enum.Enum):\n    None_ = 0\n    SplitAtFullyMultipleKnots = 1\n    RebuildLines = 2\n    RebuildArcs = 4\n    RebuildRationals = 8\n    AdjustG1 = 16\n    Merge = 32\n    All = 63\n\nclass CurveEnd(enum.Enum):\n    None_ = 0\n    Start = 1\n    End = 2\n    Both = 3\n\nclass CurveEvaluationSide(enum.Enum):\n    Default = 0\n    Above = 1\n    Below = -1\n\nclass ConicSectionType(enum.Enum):\n    Unknown = 0\n    Circle = 1\n    Ellipse = 2\n    Hyperbola = 3\n    Parabola = 4\n\nclass CurveBooleanRegions(object):\n    \"\"\"Represents the results of a Curve.CreateBooleanRegions calculation.\n\n    \"\"\"\n    @overload\n    def BoundaryCount(self, regionIndex: int) -> int: ...\n    @overload\n    def Dispose() -> None: ...\n    @property\n    def PlanarCurveCount(self) -> int: ...\n    @property\n    def PointCount(self) -> int: ...\n    @property\n    def RegionCount(self) -> int: ...\n    @overload\n    def PlanarCurve(self, planarCurveIndex: int) -> Curve: ...\n    @overload\n    def RegionCurves(self, regionIndex: int) -> System.Array[Curve]: ...\n    @overload\n    def RegionPointIndex(self, pointIndex: int) -> int: ...\n    @overload\n    def SegmentCount(self, regionIndex: int, boundaryIndex: int) -> int: ...\n    @overload\n    def SegmentDetails(self, regionIndex: int, boundaryIndex: int, segmmentIndex: int) -> (int, Interval, bool): ...\n\nclass Curve(GeometryBase):\n    \"\"\"Represents a base class that is common to most RhinoCommon curve types.\nA curve represents an entity that can be all visited by providing a single parameter, usually called t.\n\n    \"\"\"\n    @overload\n    def ChangeClosedCurveSeam(self, t: float) -> bool: ...\n    @overload\n    def ChangeDimension(self, desiredDimension: int) -> bool: ...\n    @overload\n    def ClosedCurveOrientation() -> CurveOrientation: ...\n    @overload\n    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...\n    @overload\n    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...\n    @overload\n    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...\n    @overload\n    def ClosestPoint(self, testPoint: Point3d) -> (bool, float): ...\n    @overload\n    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> (bool, float): ...\n    @overload\n    def ClosestPoints(self, otherCurve: Curve) -> (bool, Point3d, Point3d): ...\n    @overload\n    def ClosestPoints(self, geometry: Generic.IEnumerable) -> (bool, Point3d, Point3d, int): ...\n    @overload\n    def ClosestPoints(self, geometry: Generic.IEnumerable, maximumDistance: float) -> (bool, Point3d, Point3d, int): ...\n    @overload\n    def CombineShortSegments(self, tolerance: float) -> bool: ...\n    @overload\n    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...\n    @overload\n    def ControlPolygon() -> Polyline: ...\n    @overload\n    @staticmethod\n    def CreateArcBlend(startPt: Point3d, startDir: Vector3d, endPt: Point3d, endDir: Vector3d, controlPointLengthRatio: float) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateArcCornerRectangle(rectangle: Rectangle3d, radius: float) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateArcLineArcBlend(startPt: Point3d, startDir: Vector3d, endPt: Point3d, endDir: Vector3d, radius: float) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateBlendCurve(curveA: Curve, curveB: Curve, continuity: BlendContinuity) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateBlendCurve(curveA: Curve, curveB: Curve, continuity: BlendContinuity, bulgeA: float, bulgeB: float) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateBlendCurve(curve0: Curve, t0: float, reverse0: bool, continuity0: BlendContinuity, curve1: Curve, t1: float, reverse1: bool, continuity1: BlendContinuity) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateBooleanDifference(curveA: Curve, curveB: Curve, tolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanDifference(curveA: Curve, subtractors: Generic.IEnumerable, tolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanIntersection(curveA: Curve, curveB: Curve, tolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def CreateBooleanRegions(curves: Generic.IEnumerable, plane: Plane, combineRegions: bool, tolerance: float) -> CurveBooleanRegions: ...\n    @overload\n    @staticmethod\n    def CreateBooleanRegions(curves: Generic.IEnumerable, plane: Plane, points: Generic.IEnumerable, combineRegions: bool, tolerance: float) -> CurveBooleanRegions: ...\n    @overload\n    @staticmethod\n    def CreateBooleanUnion(curves: Generic.IEnumerable, tolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def CreateConicCornerRectangle(rectangle: Rectangle3d, rho: float) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateControlPointCurve(points: Generic.IEnumerable) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateControlPointCurve(points: Generic.IEnumerable, degree: int) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateCurve2View(curveA: Curve, curveB: Curve, vectorA: Vector3d, vectorB: Vector3d, tolerance: float, angleTolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def CreateFillet(curve0: Curve, curve1: Curve, radius: float, t0Base: float, t1Base: float) -> Arc: ...\n    @overload\n    @staticmethod\n    def CreateFilletCornersCurve(curve: Curve, radius: float, tolerance: float, angleTolerance: float) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateFilletCurves(curve0: Curve, point0: Point3d, curve1: Curve, point1: Point3d, radius: float, join: bool, trim: bool, arcExtension: bool, tolerance: float, angleTolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def CreateInterpolatedCurve(points: Generic.IEnumerable, degree: int) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateInterpolatedCurve(points: Generic.IEnumerable, degree: int, knots: CurveKnotStyle) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateInterpolatedCurve(points: Generic.IEnumerable, degree: int, knots: CurveKnotStyle, startTangent: Vector3d, endTangent: Vector3d) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateMatchCurve(curve0: Curve, reverse0: bool, continuity: BlendContinuity, curve1: Curve, reverse1: bool, preserve: PreserveEnd, average: bool) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def CreateMeanCurve(curveA: Curve, curveB: Curve) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateMeanCurve(curveA: Curve, curveB: Curve, angleToleranceRadians: float) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreatePeriodicCurve(curve: Curve) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreatePeriodicCurve(curve: Curve, smooth: bool) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateRevisionCloud(points: Generic.IEnumerable, angle: float, flip: bool) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateRevisionCloud(curve: Curve, segmentCount: int, angle: float, flip: bool) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateSoftEditCurve(curve: Curve, t: float, delta: Vector3d, length: float, fixEnds: bool) -> Curve: ...\n    @overload\n    @staticmethod\n    def CreateTextOutlines(text: str, font: str, textHeight: float, textStyle: int, closeLoops: bool, plane: Plane, smallCapsScale: float, tolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def CreateTweenCurves(curve0: Curve, curve1: Curve, numCurves: int, tolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def CreateTweenCurvesWithMatching(curve0: Curve, curve1: Curve, numCurves: int, tolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def CreateTweenCurvesWithSampling(curve0: Curve, curve1: Curve, numCurves: int, numSamples: int, tolerance: float) -> System.Array[Curve]: ...\n    @overload\n    def CurvatureAt(self, t: float) -> Vector3d: ...\n    @overload\n    def DerivativeAt(self, t: float, derivativeCount: int) -> System.Array[Vector3d]: ...\n    @overload\n    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> System.Array[Vector3d]: ...\n    @overload\n    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> System.Array[Point3d]: ...\n    @overload\n    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> System.System.Array[float]: ...\n    @overload\n    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> (System.System.Array[float], System.Array[Point3d]): ...\n    @overload\n    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> System.System.Array[float]: ...\n    @overload\n    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> System.System.Array[float]: ...\n    @overload\n    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> (System.System.Array[float], System.Array[Point3d]): ...\n    @overload\n    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> (System.System.Array[float], System.Array[Point3d]): ...\n    @overload\n    def DivideEquidistant(self, distance: float) -> System.Array[Point3d]: ...\n    @overload\n    def DivideEquidistant(self, distance: float) -> (System.Array[Point3d], System.System.Array[float]): ...\n    @overload\n    @staticmethod\n    def DoDirectionsMatch(curveA: Curve, curveB: Curve) -> bool: ...\n    @overload\n    def Duplicate() -> GeometryBase: ...\n    @overload\n    def DuplicateCurve() -> Curve: ...\n    @overload\n    def DuplicateSegments() -> System.Array[Curve]: ...\n    @overload\n    def Extend(self, domain: Interval) -> Curve: ...\n    @overload\n    def Extend(self, t0: float, t1: float) -> Curve: ...\n    @overload\n    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Generic.IEnumerable) -> Curve: ...\n    @overload\n    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...\n    @overload\n    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...\n    @overload\n    def ExtendByArc(self, side: CurveEnd, geometry: Generic.IEnumerable) -> Curve: ...\n    @overload\n    def ExtendByLine(self, side: CurveEnd, geometry: Generic.IEnumerable) -> Curve: ...\n    @overload\n    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...\n    @overload\n    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...\n    @overload\n    def ExtremeParameters(self, direction: Vector3d) -> System.System.Array[float]: ...\n    @overload\n    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...\n    @overload\n    def FilletSurfaceToCurve(self, face: BrepFace, t: float, u: float, v: float, radius: float, alignToCurve: int, railDegree: int, arcDegree: int, arcSliders: Generic.IEnumerable, numBezierSrfs: int, tolerance: float, out_fillets: Generic.List) -> (bool, System.System.Array[float]): ...\n    @overload\n    def FilletSurfaceToRail(self, faceWithCurve: BrepFace, secondFace: BrepFace, u1: float, v1: float, railDegree: int, arcDegree: int, arcSliders: Generic.IEnumerable, numBezierSrfs: int, extend: bool, split_type: FilletSurfaceSplitType, tolerance: float, out_fillets: Generic.List, out_breps0: Generic.List, out_breps1: Generic.List) -> (bool, System.System.Array[float]): ...\n    @overload\n    def FindLocalInflection(self, N: Vector3d, subDomain: Interval, seed: float) -> (bool, float, float): ...\n    @overload\n    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...\n    @overload\n    def FrameAt(self, t: float) -> (bool, Plane): ...\n    @property\n    def Degree(self) -> int: ...\n    @property\n    def Dimension(self) -> int: ...\n    @property\n    def Domain(self) -> Interval: ...\n    @property\n    def IsClosed(self) -> bool: ...\n    @property\n    def IsPeriodic(self) -> bool: ...\n    @property\n    def IsSubDFriendly(self) -> bool: ...\n    @property\n    def PointAtEnd(self) -> Point3d: ...\n    @property\n    def PointAtMid(self) -> Point3d: ...\n    @property\n    def PointAtStart(self) -> Point3d: ...\n    @property\n    def SpanCount(self) -> int: ...\n    @property\n    def TangentAtEnd(self) -> Vector3d: ...\n    @property\n    def TangentAtStart(self) -> Vector3d: ...\n    @overload\n    def GetConicSectionType() -> ConicSectionType: ...\n    @overload\n    def GetConicSectionType() -> (ConicSectionType, Point3d, Point3d, Point3d): ...\n    @overload\n    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> (bool, float): ...\n    @overload\n    @staticmethod\n    def GetDistancesBetweenCurves(curveA: Curve, curveB: Curve, tolerance: float) -> (bool, float, float, float, float, float, float): ...\n    @overload\n    @staticmethod\n    def GetFilletPoints(curve0: Curve, curve1: Curve, radius: float, t0Base: float, t1Base: float) -> (bool, float, float, Plane): ...\n    @overload\n    def GetLength() -> float: ...\n    @overload\n    def GetLength(self, subdomain: Interval) -> float: ...\n    @overload\n    def GetLength(self, fractionalTolerance: float) -> float: ...\n    @overload\n    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...\n    @overload\n    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> (bool, float): ...\n    @overload\n    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> (bool, float): ...\n    @overload\n    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> (bool, float): ...\n    @overload\n    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> (bool, float): ...\n    @overload\n    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> (bool, float): ...\n    @overload\n    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> (bool, float): ...\n    @overload\n    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> (bool, float): ...\n    @overload\n    def GetPerpendicularFrames(self, parameters: Generic.IEnumerable) -> System.Array[Plane]: ...\n    @overload\n    def GetSubCurves() -> System.Array[Curve]: ...\n    @overload\n    def HasNurbsForm() -> int: ...\n    @overload\n    def InflectionPoints() -> System.Array[Point3d]: ...\n    @overload\n    def InflectionPoints() -> (System.Array[Point3d], System.System.Array[float]): ...\n    @overload\n    def IsArc() -> bool: ...\n    @overload\n    def IsArc(self, tolerance: float) -> bool: ...\n    @overload\n    def IsCircle() -> bool: ...\n    @overload\n    def IsCircle(self, tolerance: float) -> bool: ...\n    @overload\n    def IsClosable(self, tolerance: float) -> bool: ...\n    @overload\n    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...\n    @overload\n    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...\n    @overload\n    def IsEllipse() -> bool: ...\n    @overload\n    def IsEllipse(self, tolerance: float) -> bool: ...\n    @overload\n    def IsInPlane(self, testPlane: Plane) -> bool: ...\n    @overload\n    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...\n    @overload\n    def IsLinear() -> bool: ...\n    @overload\n    def IsLinear(self, tolerance: float) -> bool: ...\n    @overload\n    def IsPlanar() -> bool: ...\n    @overload\n    def IsPlanar(self, tolerance: float) -> bool: ...\n    @overload\n    def IsPolyline() -> bool: ...\n    @overload\n    def IsShort(self, tolerance: float) -> bool: ...\n    @overload\n    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...\n    @overload\n    @staticmethod\n    def JoinCurves(inputCurves: Generic.IEnumerable) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def JoinCurves(inputCurves: Generic.IEnumerable, joinTolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def JoinCurves(inputCurves: Generic.IEnumerable, joinTolerance: float, preserveDirection: bool) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def JoinCurves(inputCurves: Generic.IEnumerable, joinTolerance: float, preserveDirection: bool) -> (System.Array[Curve], System.System.Array[int]): ...\n    @overload\n    @staticmethod\n    def JoinCurves(inputCurves: Generic.IEnumerable, joinTolerance: float, preserveDirection: bool, simpleJoin: bool) -> (System.Array[Curve], System.System.Array[int]): ...\n    @overload\n    def LengthParameter(self, segmentLength: float) -> (bool, float): ...\n    @overload\n    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> (bool, float): ...\n    @overload\n    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> (bool, float): ...\n    @overload\n    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> (bool, float): ...\n    @overload\n    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> (bool, float): ...\n    @overload\n    def MakeClosed(self, tolerance: float) -> bool: ...\n    @overload\n    @staticmethod\n    def MakeEndsMeet(curveA: Curve, adjustStartCurveA: bool, curveB: Curve, adjustStartCurveB: bool) -> bool: ...\n    @overload\n    def MaxCurvaturePoints() -> System.Array[Point3d]: ...\n    @overload\n    def MaxCurvaturePoints() -> (System.Array[Point3d], System.System.Array[float]): ...\n    @overload\n    def NormalizedLengthParameter(self, s: float) -> (bool, float): ...\n    @overload\n    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> (bool, float): ...\n    @overload\n    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> (bool, float): ...\n    @overload\n    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> (bool, float): ...\n    @overload\n    def NormalizedLengthParameters(self, s: System.System.Array[float], absoluteTolerance: float) -> System.System.Array[float]: ...\n    @overload\n    def NormalizedLengthParameters(self, s: System.System.Array[float], absoluteTolerance: float, subdomain: Interval) -> System.System.Array[float]: ...\n    @overload\n    def NormalizedLengthParameters(self, s: System.System.Array[float], absoluteTolerance: float, fractionalTolerance: float) -> System.System.Array[float]: ...\n    @overload\n    def NormalizedLengthParameters(self, s: System.System.Array[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> System.System.Array[float]: ...\n    @overload\n    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> System.Array[Curve]: ...\n    @overload\n    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> System.Array[Curve]: ...\n    @overload\n    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> System.Array[Curve]: ...\n    @overload\n    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...\n    @overload\n    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> System.Array[Curve]: ...\n    @overload\n    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> System.Array[Curve]: ...\n    @overload\n    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> System.Array[Curve]: ...\n    @overload\n    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> System.Array[Curve]: ...\n    @overload\n    def OffsetOnSurface(self, surface: Surface, curveParameters: System.System.Array[float], offsetDistances: System.System.Array[float], fittingTolerance: float) -> System.Array[Curve]: ...\n    @overload\n    def OffsetOnSurface(self, face: BrepFace, curveParameters: System.System.Array[float], offsetDistances: System.System.Array[float], fittingTolerance: float) -> System.Array[Curve]: ...\n    @overload\n    def OffsetTangentToSurface(self, surface: Surface, height: float) -> Curve: ...\n    @overload\n    def PerpendicularFrameAt(self, t: float) -> (bool, Plane): ...\n    @overload\n    @staticmethod\n    def PlanarClosedCurveRelationship(curveA: Curve, curveB: Curve, testPlane: Plane, tolerance: float) -> RegionContainment: ...\n    @overload\n    @staticmethod\n    def PlanarCurveCollision(curveA: Curve, curveB: Curve, testPlane: Plane, tolerance: float) -> bool: ...\n    @overload\n    def PointAt(self, t: float) -> Point3d: ...\n    @overload\n    def PointAtLength(self, length: float) -> Point3d: ...\n    @overload\n    def PointAtNormalizedLength(self, length: float) -> Point3d: ...\n    @overload\n    @staticmethod\n    def ProjectToBrep(curves: Generic.IEnumerable, breps: Generic.IEnumerable, direction: Vector3d, tolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def ProjectToBrep(curve: Curve, breps: Generic.IEnumerable, direction: Vector3d, tolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def ProjectToBrep(curve: Curve, brep: Brep, direction: Vector3d, tolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def ProjectToBrep(curve: Curve, breps: Generic.IEnumerable, direction: Vector3d, tolerance: float) -> (System.Array[Curve], System.System.Array[int]): ...\n    @overload\n    @staticmethod\n    def ProjectToBrep(curves: Generic.IEnumerable, breps: Generic.IEnumerable, direction: Vector3d, tolerance: float) -> (System.Array[Curve], System.System.Array[int], System.System.Array[int]): ...\n    @overload\n    @staticmethod\n    def ProjectToBrep(curves: Generic.IEnumerable, breps: Generic.IEnumerable, direction: Vector3d, tolerance: float, loose: bool) -> (System.Array[Curve], System.System.Array[int], System.System.Array[int]): ...\n    @overload\n    @staticmethod\n    def ProjectToMesh(curve: Curve, mesh: Mesh, direction: Vector3d, tolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def ProjectToMesh(curve: Curve, meshes: Generic.IEnumerable, direction: Vector3d, tolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def ProjectToMesh(curves: Generic.IEnumerable, meshes: Generic.IEnumerable, direction: Vector3d, tolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def ProjectToMesh(curves: Generic.IEnumerable, meshes: Generic.IEnumerable, direction: Vector3d, tolerance: float, loose: bool) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def ProjectToPlane(curve: Curve, plane: Plane) -> Curve: ...\n    @overload\n    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def PullToBrepFace(curve: Curve, face: BrepFace, tolerance: float) -> System.Array[Curve]: ...\n    @overload\n    @staticmethod\n    def PullToBrepFace(curve: Curve, face: BrepFace, tolerance: float, loose: bool) -> System.Array[Curve]: ...\n    @overload\n    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...\n    @overload\n    def PullToMesh(self, mesh: Mesh, tolerance: float, loose: bool) -> Curve: ...\n    @overload\n    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...\n    @overload\n    def RemoveShortSegments(self, tolerance: float) -> bool: ...\n    @overload\n    def Repair(self, tolerance: float) -> bool: ...\n    @overload\n    def Reparameterize() -> Curve: ...\n    @overload\n    def Reverse() -> bool: ...\n    @overload\n    def RibbonOffset(self, ribbonParameters: RibbonOffsetParameters) -> (Curve, System.Array[Curve], System.Array[Curve], System.Array[Brep]): ...\n    @overload\n    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...\n    @overload\n    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> (Curve, System.Array[Curve], System.Array[Surface]): ...\n    @overload\n    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> (Curve, System.System.Array[float], System.System.Array[float]): ...\n    @Domain.setter\n    def Domain(self, value: System.Void): ...\n    @overload\n    def SetEndPoint(self, point: Point3d) -> bool: ...\n    @overload\n    def SetStartPoint(self, point: Point3d) -> bool: ...\n    @overload\n    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...\n    @overload\n    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...\n    @overload\n    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...\n    @overload\n    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...\n    @overload\n    def SpanDomain(self, spanIndex: int) -> Interval: ...\n    @overload\n    def SpanVector() -> System.System.Array[float]: ...\n    @overload\n    def Split(self, t: float) -> System.Array[Curve]: ...\n    @overload\n    def Split(self, t: Generic.IEnumerable) -> System.Array[Curve]: ...\n    @overload\n    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> System.Array[Curve]: ...\n    @overload\n    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> System.Array[Curve]: ...\n    @overload\n    def TangentAt(self, t: float) -> Vector3d: ...\n    @overload\n    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...\n    @overload\n    def ToNurbsCurve() -> NurbsCurve: ...\n    @overload\n    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...\n    @overload\n    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...\n    @overload\n    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...\n    @overload\n    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...\n    @overload\n    def TorsionAt(self, t: float) -> float: ...\n    @overload\n    def Trim(self, domain: Interval) -> Curve: ...\n    @overload\n    def Trim(self, t0: float, t1: float) -> Curve: ...\n    @overload\n    def Trim(self, side: CurveEnd, length: float) -> Curve: ...\n    @overload\n    def TryGetArc() -> (bool, Arc): ...\n    @overload\n    def TryGetArc(self, tolerance: float) -> (bool, Arc): ...\n    @overload\n    def TryGetArc(self, plane: Plane) -> (bool, Arc): ...\n    @overload\n    def TryGetArc(self, plane: Plane, tolerance: float) -> (bool, Arc): ...\n    @overload\n    def TryGetCircle() -> (bool, Circle): ...\n    @overload\n    def TryGetCircle(self, tolerance: float) -> (bool, Circle): ...\n    @overload\n    def TryGetEllipse() -> (bool, Ellipse): ...\n    @overload\n    def TryGetEllipse(self, tolerance: float) -> (bool, Ellipse): ...\n    @overload\n    def TryGetEllipse(self, plane: Plane) -> (bool, Ellipse): ...\n    @overload\n    def TryGetEllipse(self, plane: Plane, tolerance: float) -> (bool, Ellipse): ...\n    @overload\n    def TryGetPlane() -> (bool, Plane): ...\n    @overload\n    def TryGetPlane(self, tolerance: float) -> (bool, Plane): ...\n    @overload\n    def TryGetPolyline() -> (bool, Polyline): ...\n    @overload\n    def TryGetPolyline() -> (bool, Polyline, System.System.Array[float]): ...\n\nclass RibbonOffsetParameters(object):\n    \"\"\"Advanced parameters for RibbonOffset Parameters mimic the RibbonOffset Command.\n\n    \"\"\"\n    def __init__(self): ...\n    @property\n    def AlignCrossSections(self) -> bool: ...\n    @property\n    def BlendRadius(self) -> float: ...\n    @property\n    def OffsetDistance(self) -> float: ...\n    @property\n    def OffsetLocation(self) -> Point3d: ...\n    @property\n    def OffsetPlaneVector3d(self) -> Vector3d: ...\n    @property\n    def OffsetTolerance(self) -> float: ...\n    @property\n    def RebuildPointCount(self) -> int: ...\n    @property\n    def RefitTolerance(self) -> float: ...\n    @property\n    def RibbonSurfaceGenerationMethod(self) -> RibbonOffsetSurfaceMethod: ...\n    @AlignCrossSections.setter\n    def AlignCrossSections(self, value: System.Void): ...\n    @BlendRadius.setter\n    def BlendRadius(self, value: System.Void): ...\n    @OffsetDistance.setter\n    def OffsetDistance(self, value: System.Void): ...\n    @OffsetLocation.setter\n    def OffsetLocation(self, value: System.Void): ...\n    @OffsetPlaneVector3d.setter\n    def OffsetPlaneVector3d(self, value: System.Void): ...\n    @OffsetTolerance.setter\n    def OffsetTolerance(self, value: System.Void): ...\n    @RebuildPointCount.setter\n    def RebuildPointCount(self, value: System.Void): ...\n    @RefitTolerance.setter\n    def RefitTolerance(self, value: System.Void): ...\n    @RibbonSurfaceGenerationMethod.setter\n    def RibbonSurfaceGenerationMethod(self, value: System.Void): ...\n\nclass RibbonOffsetSurfaceMethod(enum.Enum):\n    None_ = 0\n    Sweep2 = 1\n    Sweep2NetworkSrf = 2\n\nclass Cylinder(System.ValueType):\n    \"\"\"Represents the values of a plane, a radius and two heights -on top and beneath- that define a right circular cylinder.\n\n    \"\"\"\n    @overload\n    def __init__(self, baseCircle: Circle): ...\n    @overload\n    def __init__(self, baseCircle: Circle, height: float): ...\n    @overload\n    def CircleAt(self, linearParameter: float) -> Circle: ...\n    @overload\n    def EpsilonEquals(self, other: Cylinder, epsilon: float) -> bool: ...\n    @property\n    def Axis(self) -> Vector3d: ...\n    @property\n    def BasePlane(self) -> Plane: ...\n    @property\n    def Center(self) -> Point3d: ...\n    @property\n    def Height1(self) -> float: ...\n    @property\n    def Height2(self) -> float: ...\n    @property\n    def IsFinite(self) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Radius(self) -> float: ...\n    @property\n    def TotalHeight(self) -> float: ...\n    @property\n    def Unset(self) -> Cylinder: ...\n    @overload\n    def LineAt(self, angularParameter: float) -> Line: ...\n    @BasePlane.setter\n    def BasePlane(self, value: System.Void): ...\n    @Height1.setter\n    def Height1(self, value: System.Void): ...\n    @Height2.setter\n    def Height2(self, value: System.Void): ...\n    @Radius.setter\n    def Radius(self, value: System.Void): ...\n    @overload\n    def ToBrep(self, capBottom: bool, capTop: bool) -> Brep: ...\n    @overload\n    def ToNurbsSurface() -> NurbsSurface: ...\n    @overload\n    def ToRevSurface() -> RevSurface: ...\n    @overload\n    def Transform(self, xform: Transform) -> bool: ...\n\nclass Ellipse(System.ValueType):\n    \"\"\"Represents the values of a plane and the two semi-axes radii in an ellipse.\n\n    \"\"\"\n    @overload\n    def __init__(self, plane: Plane, radius1: float, radius2: float): ...\n    @overload\n    def __init__(self, center: Point3d, second: Point3d, third: Point3d): ...\n    @overload\n    def EpsilonEquals(self, other: Ellipse, epsilon: float) -> bool: ...\n    @property\n    def Center(self) -> Point3d: ...\n    @property\n    def FocalDistance(self) -> float: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Plane(self) -> Plane: ...\n    @property\n    def Radius1(self) -> float: ...\n    @property\n    def Radius2(self) -> float: ...\n    @overload\n    def GetFoci() -> (Point3d, Point3d): ...\n    @Center.setter\n    def Center(self, value: System.Void): ...\n    @Plane.setter\n    def Plane(self, value: System.Void): ...\n    @Radius1.setter\n    def Radius1(self, value: System.Void): ...\n    @Radius2.setter\n    def Radius2(self, value: System.Void): ...\n    @overload\n    def ToNurbsCurve() -> NurbsCurve: ...\n\nclass GeometryBase(Runtime.CommonObject):\n    \"\"\"Provides a common base for most geometric classes. This class is abstract.\n\n    \"\"\"\n    @overload\n    def ComponentIndex() -> ComponentIndex: ...\n    @overload\n    def DataCRC(self, currentRemainder: System.UInt32) -> System.UInt32: ...\n    @overload\n    def DeleteAllUserStrings() -> None: ...\n    @overload\n    def DeleteUserString(self, key: str) -> bool: ...\n    @overload\n    def Duplicate() -> GeometryBase: ...\n    @overload\n    def DuplicateShallow() -> GeometryBase: ...\n    @overload\n    @staticmethod\n    def GeometryEquals(first: GeometryBase, second: GeometryBase) -> bool: ...\n    @overload\n    @staticmethod\n    def GeometryReferenceEquals(one: GeometryBase, other: GeometryBase) -> bool: ...\n    @property\n    def HasBrepForm(self) -> bool: ...\n    @property\n    def IsDeformable(self) -> bool: ...\n    @property\n    def IsDocumentControlled(self) -> bool: ...\n    @property\n    def ObjectType(self) -> DocObjects.ObjectType: ...\n    @property\n    def UserStringCount(self) -> int: ...\n    @overload\n    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...\n    @overload\n    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...\n    @overload\n    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...\n    @overload\n    def GetBoundingBox(self, plane: Plane) -> (BoundingBox, Box): ...\n    @overload\n    def GetUserString(self, key: str) -> str: ...\n    @overload\n    def GetUserStrings() -> Specialized.NameValueCollection: ...\n    @overload\n    def MakeDeformable() -> bool: ...\n    @overload\n    def MemoryEstimate() -> System.UInt32: ...\n    @overload\n    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...\n    @overload\n    def Scale(self, scaleFactor: float) -> bool: ...\n    @overload\n    def SetUserString(self, key: str, value: str) -> bool: ...\n    @overload\n    def Transform(self, xform: Transform) -> bool: ...\n    @overload\n    def Translate(self, translationVector: Vector3d) -> bool: ...\n    @overload\n    def Translate(self, x: float, y: float, z: float) -> bool: ...\n\nclass Line(System.ValueType):\n    \"\"\"Represents the value of start and end points in a single line segment.\n\n    \"\"\"\n    @overload\n    def __init__(self, from_: Point3d, to: Point3d): ...\n    @overload\n    def __init__(self, start: Point3d, span: Vector3d): ...\n    @overload\n    def __init__(self, start: Point3d, direction: Vector3d, length: float): ...\n    @overload\n    def __init__(self, x0: float, y0: float, z0: float, x1: float, y1: float, z1: float): ...\n    @overload\n    def ClosestParameter(self, testPoint: Point3d) -> float: ...\n    @overload\n    def ClosestPoint(self, testPoint: Point3d, limitToFiniteSegment: bool) -> Point3d: ...\n    @overload\n    def DistanceTo(self, testPoint: Point3d, limitToFiniteSegment: bool) -> float: ...\n    @overload\n    def EpsilonEquals(self, other: Line, epsilon: float) -> bool: ...\n    @overload\n    def Equals(self, other: Line) -> bool: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @overload\n    def Extend(self, startLength: float, endLength: float) -> bool: ...\n    @overload\n    def ExtendThroughBox(self, box: BoundingBox) -> bool: ...\n    @overload\n    def ExtendThroughBox(self, box: Box) -> bool: ...\n    @overload\n    def ExtendThroughBox(self, box: Box, additionalLength: float) -> bool: ...\n    @overload\n    def ExtendThroughBox(self, box: BoundingBox, additionalLength: float) -> bool: ...\n    @overload\n    def Flip() -> None: ...\n    @property\n    def BoundingBox(self) -> BoundingBox: ...\n    @property\n    def Direction(self) -> Vector3d: ...\n    @property\n    def From(self) -> Point3d: ...\n    @property\n    def FromX(self) -> float: ...\n    @property\n    def FromY(self) -> float: ...\n    @property\n    def FromZ(self) -> float: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Length(self) -> float: ...\n    @property\n    def To(self) -> Point3d: ...\n    @property\n    def ToX(self) -> float: ...\n    @property\n    def ToY(self) -> float: ...\n    @property\n    def ToZ(self) -> float: ...\n    @property\n    def UnitTangent(self) -> Vector3d: ...\n    @property\n    def Unset(self) -> Line: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    def MaximumDistanceTo(self, testLine: Line) -> float: ...\n    @overload\n    def MaximumDistanceTo(self, testPoint: Point3d) -> float: ...\n    @overload\n    def MinimumDistanceTo(self, testLine: Line) -> float: ...\n    @overload\n    def MinimumDistanceTo(self, testPoint: Point3d) -> float: ...\n    @overload\n    def PointAt(self, t: float) -> Point3d: ...\n    @overload\n    def PointAtLength(self, distance: float) -> Point3d: ...\n    @From.setter\n    def From(self, value: System.Void): ...\n    @FromX.setter\n    def FromX(self, value: System.Void): ...\n    @FromY.setter\n    def FromY(self, value: System.Void): ...\n    @FromZ.setter\n    def FromZ(self, value: System.Void): ...\n    @Length.setter\n    def Length(self, value: System.Void): ...\n    @To.setter\n    def To(self, value: System.Void): ...\n    @ToX.setter\n    def ToX(self, value: System.Void): ...\n    @ToY.setter\n    def ToY(self, value: System.Void): ...\n    @ToZ.setter\n    def ToZ(self, value: System.Void): ...\n    @overload\n    def ToNurbsCurve() -> NurbsCurve: ...\n    @overload\n    def ToString() -> str: ...\n    @overload\n    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...\n    @overload\n    def Transform(self, xform: Transform) -> bool: ...\n    @overload\n    @staticmethod\n    def TryCreateBetweenCurves(curve0: Curve, curve1: Curve, perpendicular0: bool, perpendicular1: bool) -> (bool, float, float, Line): ...\n    @overload\n    @staticmethod\n    def TryFitLineToPoints(points: Generic.IEnumerable) -> (bool, Line): ...\n    @overload\n    def TryGetPlane() -> (bool, Plane): ...\n\nclass Triangle3d(System.ValueType):\n    \"\"\"Represents a triangle, modeled using double three points that use double-precision floating point numbers.\n\n    \"\"\"\n    def __init__(self, a: Point3d, b: Point3d, c: Point3d): ...\n    @overload\n    def BarycentricCoordsAt(self, point: Point3d) -> (Point2d, float): ...\n    @overload\n    def ClosestParameterOnBoundary(self, point: Point3d) -> float: ...\n    @overload\n    def ClosestPointOnBoundary(self, point: Point3d) -> Point3d: ...\n    @property\n    def A(self) -> Point3d: ...\n    @property\n    def AB(self) -> Line: ...\n    @property\n    def AltitudeA(self) -> Line: ...\n    @property\n    def AltitudeB(self) -> Line: ...\n    @property\n    def AltitudeC(self) -> Line: ...\n    @property\n    def AngleA(self) -> float: ...\n    @property\n    def AngleB(self) -> float: ...\n    @property\n    def AngleC(self) -> float: ...\n    @property\n    def Area(self) -> float: ...\n    @property\n    def AreaCenter(self) -> Point3d: ...\n    @property\n    def B(self) -> Point3d: ...\n    @property\n    def BC(self) -> Line: ...\n    @property\n    def BoundingBox(self) -> BoundingBox: ...\n    @property\n    def C(self) -> Point3d: ...\n    @property\n    def CA(self) -> Line: ...\n    @property\n    def Circumcenter(self) -> Point3d: ...\n    @property\n    def Circumcircle(self) -> Circle: ...\n    @property\n    def MedianA(self) -> Line: ...\n    @property\n    def MedianB(self) -> Line: ...\n    @property\n    def MedianC(self) -> Line: ...\n    @property\n    def Orthocenter(self) -> Point3d: ...\n    @property\n    def Perimeter(self) -> float: ...\n    @property\n    def PerpendicularAB(self) -> Line: ...\n    @property\n    def PerpendicularBC(self) -> Line: ...\n    @property\n    def PerpendicularCA(self) -> Line: ...\n    @overload\n    def PointAlongBoundary(self, t: float) -> Point3d: ...\n    @overload\n    def PointAtBarycentricCoords(self, coords: Point2d) -> Point3d: ...\n    @overload\n    def PointOnInterior(self, u: float, v: float) -> Point3d: ...\n    @overload\n    def ToMesh() -> Mesh: ...\n    @overload\n    def ToPolyline() -> Polyline: ...\n    @overload\n    def Transform(self, transform: Transform) -> Triangle3d: ...\n    @overload\n    @staticmethod\n    def TrySmallestEnclosingTriangle(points: Generic.IEnumerable, tolerance: float) -> (bool, Triangle3d): ...\n    @overload\n    def WithA(self, a: Point3d) -> Triangle3d: ...\n    @overload\n    def WithB(self, b: Point3d) -> Triangle3d: ...\n    @overload\n    def WithC(self, c: Point3d) -> Triangle3d: ...\n\nclass KnotStyle(enum.Enum):\n    Unknown = 0\n    Uniform = 1\n    QuasiUniform = 2\n    PiecewiseBezier = 3\n    ClampedEnd = 4\n    NonUniform = 5\n\nclass NurbsCurve(Curve):\n    \"\"\"Represents a Non Uniform Rational B-Splines (NURBS) curve.\n\n    \"\"\"\n    @overload\n    def __init__(self, other: NurbsCurve): ...\n    @overload\n    def __init__(self, degree: int, pointCount: int): ...\n    @overload\n    def __init__(self, dimension: int, rational: bool, order: int, pointCount: int): ...\n    @overload\n    def Append(self, nurbsCurve: NurbsCurve) -> bool: ...\n    @overload\n    def ConvertSpanToBezier(self, spanIndex: int) -> BezierCurve: ...\n    @overload\n    @staticmethod\n    def Create(periodic: bool, degree: int, points: Generic.IEnumerable) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateFromArc(arc: Arc) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateFromArc(arc: Arc, degree: int, cvCount: int) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateFromCircle(circle: Circle) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateFromCircle(circle: Circle, degree: int, cvCount: int) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateFromEllipse(ellipse: Ellipse) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateFromFitPoints(points: Generic.IEnumerable, tolerance: float, periodic: bool) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateFromFitPoints(points: Generic.IEnumerable, tolerance: float, degree: int, periodic: bool, startTangent: Vector3d, endTangent: Vector3d) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateFromLine(line: Line) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateHSpline(points: Generic.IEnumerable) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateHSpline(points: Generic.IEnumerable, startTangent: Vector3d, endTangent: Vector3d) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateNonRationalArcBezier(degree: int, center: Point3d, start: Point3d, end: Point3d, radius: float, tanSlider: float, midSlider: float) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateParabolaFromFocus(focus: Point3d, startPoint: Point3d, endPoint: Point3d) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateParabolaFromPoints(startPoint: Point3d, innerPoint: Point3d, endPoint: Point3d) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateParabolaFromVertex(vertex: Point3d, startPoint: Point3d, endPoint: Point3d) -> NurbsCurve: ...\n    @overload\n    def CreatePlanarRailFrames(self, parameters: Generic.IEnumerable, normal: Vector3d) -> System.Array[Plane]: ...\n    @overload\n    def CreateRailFrames(self, parameters: Generic.IEnumerable) -> System.Array[Plane]: ...\n    @overload\n    @staticmethod\n    def CreateSpiral(axisStart: Point3d, axisDir: Vector3d, radiusPoint: Point3d, pitch: float, turnCount: float, radius0: float, radius1: float) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateSpiral(railCurve: Curve, t0: float, t1: float, radiusPoint: Point3d, pitch: float, turnCount: float, radius0: float, radius1: float, pointsPerTurn: int) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateSubDFriendly(curve: Curve) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateSubDFriendly(points: Generic.IEnumerable, interpolatePoints: bool, periodicClosedCurve: bool) -> NurbsCurve: ...\n    @overload\n    @staticmethod\n    def CreateSubDFriendly(curve: Curve, pointCount: int, periodicClosedCurve: bool) -> NurbsCurve: ...\n    @overload\n    def EpsilonEquals(self, other: NurbsCurve, epsilon: float) -> bool: ...\n    @property\n    def HasBezierSpans(self) -> bool: ...\n    @property\n    def IsRational(self) -> bool: ...\n    @property\n    def Knots(self) -> Collections.NurbsCurveKnotList: ...\n    @property\n    def Order(self) -> int: ...\n    @property\n    def Points(self) -> Collections.NurbsCurvePointList: ...\n    @overload\n    def GrevilleParameter(self, index: int) -> float: ...\n    @overload\n    def GrevilleParameters() -> System.System.Array[float]: ...\n    @overload\n    def GrevillePoint(self, index: int) -> Point3d: ...\n    @overload\n    def GrevillePoints() -> Collections.Point3dList: ...\n    @overload\n    def GrevillePoints(self, all_: bool) -> Collections.Point3dList: ...\n    @overload\n    def IncreaseDegree(self, desiredDegree: int) -> bool: ...\n    @overload\n    @staticmethod\n    def IsDuplicate(curveA: NurbsCurve, curveB: NurbsCurve, ignoreParameterization: bool, tolerance: float) -> bool: ...\n    @overload\n    @staticmethod\n    def MakeCompatible(curves: Generic.IEnumerable, startPt: Point3d, endPt: Point3d, simplifyMethod: int, numPoints: int, refitTolerance: float, angleTolerance: float) -> System.Array[NurbsCurve]: ...\n    @overload\n    def MakePiecewiseBezier(self, setEndWeightsToOne: bool) -> bool: ...\n    @overload\n    def MatchToCurve(self, targetCurve: Curve, maxEndDistance: float, maxInteriorDistance: float, matchTolerance: float, maxLevel: int) -> NurbsCurve: ...\n    @overload\n    def Reparameterize(self, c: float) -> bool: ...\n    @overload\n    def SetEndCondition(self, bSetEnd: bool, continuity: NurbsCurveEndConditionType, point: Point3d, tangent: Vector3d) -> bool: ...\n    @overload\n    def SetEndCondition(self, bSetEnd: bool, continuity: NurbsCurveEndConditionType, point: Point3d, tangent: Vector3d, curvature: Vector3d) -> bool: ...\n    @overload\n    def SetGrevillePoints(self, points: Generic.IEnumerable) -> bool: ...\n    @overload\n    def UVNDirectionsAt(self, t: float) -> (bool, Vector3d, Vector3d, Vector3d): ...\n\nclass ControlPoint(System.ValueType):\n    \"\"\"Represents control point geometry with three-dimensional position and weight.\n\n    \"\"\"\n    @overload\n    def __init__(self, pt: Point3d): ...\n    @overload\n    def __init__(self, pt: Point4d): ...\n    @overload\n    def __init__(self, euclideanPt: Point3d, weight: float): ...\n    @overload\n    def __init__(self, x: float, y: float, z: float): ...\n    @overload\n    def __init__(self, x: float, y: float, z: float, weight: float): ...\n    @overload\n    def EpsilonEquals(self, other: ControlPoint, epsilon: float) -> bool: ...\n    @overload\n    def Equals(self, other: ControlPoint) -> bool: ...\n    @property\n    def Location(self) -> Point3d: ...\n    @property\n    def Unset(self) -> ControlPoint: ...\n    @property\n    def Weight(self) -> float: ...\n    @property\n    def X(self) -> float: ...\n    @property\n    def Y(self) -> float: ...\n    @property\n    def Z(self) -> float: ...\n    @Location.setter\n    def Location(self, value: System.Void): ...\n    @Weight.setter\n    def Weight(self, value: System.Void): ...\n    @X.setter\n    def X(self, value: System.Void): ...\n    @Y.setter\n    def Y(self, value: System.Void): ...\n    @Z.setter\n    def Z(self, value: System.Void): ...\n\nclass PlaneFitResult(enum.Enum):\n    Success = 0\n    Inconclusive = 1\n    Failure = -1\n\nclass Plane(System.ValueType):\n    \"\"\"Represents the value of a center point and two axes in a plane in three dimensions.\n\n    \"\"\"\n    @overload\n    def __init__(self, other: Plane): ...\n    @overload\n    def __init__(self, origin: Point3d, normal: Vector3d): ...\n    @overload\n    def __init__(self, origin: Point3d, xDirection: Vector3d, yDirection: Vector3d): ...\n    @overload\n    def __init__(self, origin: Point3d, xPoint: Point3d, yPoint: Point3d): ...\n    @overload\n    def __init__(self, a: float, b: float, c: float, d: float): ...\n    @overload\n    def Clone() -> Plane: ...\n    @overload\n    def ClosestParameter(self, testPoint: Point3d) -> (bool, float, float): ...\n    @overload\n    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...\n    @overload\n    @staticmethod\n    def CreateFromFrame(origin: Point3d, xDirection: Vector3d, yDirection: Vector3d) -> Plane: ...\n    @overload\n    @staticmethod\n    def CreateFromNormal(origin: Point3d, normal: Vector3d) -> Plane: ...\n    @overload\n    @staticmethod\n    def CreateFromNormalYup(origin: Point3d, normal: Vector3d, yDirection: Vector3d) -> Plane: ...\n    @overload\n    @staticmethod\n    def CreateFromPoints(origin: Point3d, xPoint: Point3d, yPoint: Point3d) -> Plane: ...\n    @overload\n    def DistanceTo(self, testPoint: Point3d) -> float: ...\n    @overload\n    def DistanceTo(self, bbox: BoundingBox) -> (bool, float, float): ...\n    @overload\n    def EpsilonEquals(self, other: Plane, epsilon: float) -> bool: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @overload\n    def Equals(self, plane: Plane) -> bool: ...\n    @overload\n    def ExtendThroughBox(self, box: BoundingBox) -> (bool, Interval, Interval): ...\n    @overload\n    def ExtendThroughBox(self, box: Box) -> (bool, Interval, Interval): ...\n    @overload\n    @staticmethod\n    def FitPlaneToPoints(points: Generic.IEnumerable) -> (PlaneFitResult, Plane): ...\n    @overload\n    @staticmethod\n    def FitPlaneToPoints(points: Generic.IEnumerable) -> (PlaneFitResult, Plane, float): ...\n    @overload\n    def Flip() -> None: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Normal(self) -> Vector3d: ...\n    @property\n    def Origin(self) -> Point3d: ...\n    @property\n    def OriginX(self) -> float: ...\n    @property\n    def OriginY(self) -> float: ...\n    @property\n    def OriginZ(self) -> float: ...\n    @property\n    def Unset(self) -> Plane: ...\n    @property\n    def WorldXY(self) -> Plane: ...\n    @property\n    def WorldYZ(self) -> Plane: ...\n    @property\n    def WorldZX(self) -> Plane: ...\n    @property\n    def XAxis(self) -> Vector3d: ...\n    @property\n    def YAxis(self) -> Vector3d: ...\n    @property\n    def ZAxis(self) -> Vector3d: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    def GetPlaneEquation() -> System.System.Array[float]: ...\n    @overload\n    def IsCoplanar(self, plane: Plane) -> bool: ...\n    @overload\n    def IsCoplanar(self, plane: Plane, tolerance: float) -> bool: ...\n    @overload\n    def PointAt(self, u: float, v: float) -> Point3d: ...\n    @overload\n    def PointAt(self, u: float, v: float, w: float) -> Point3d: ...\n    @overload\n    def RemapToPlaneSpace(self, ptSample: Point3d) -> (bool, Point3d): ...\n    @overload\n    def Rotate(self, angle: float, axis: Vector3d) -> bool: ...\n    @overload\n    def Rotate(self, angle: float, axis: Vector3d, centerOfRotation: Point3d) -> bool: ...\n    @overload\n    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d) -> bool: ...\n    @overload\n    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d, centerOfRotation: Point3d) -> bool: ...\n    @Origin.setter\n    def Origin(self, value: System.Void): ...\n    @OriginX.setter\n    def OriginX(self, value: System.Void): ...\n    @OriginY.setter\n    def OriginY(self, value: System.Void): ...\n    @OriginZ.setter\n    def OriginZ(self, value: System.Void): ...\n    @XAxis.setter\n    def XAxis(self, value: System.Void): ...\n    @YAxis.setter\n    def YAxis(self, value: System.Void): ...\n    @ZAxis.setter\n    def ZAxis(self, value: System.Void): ...\n    @overload\n    def ToString() -> str: ...\n    @overload\n    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...\n    @overload\n    def Transform(self, xform: Transform) -> bool: ...\n    @overload\n    def Translate(self, delta: Vector3d) -> bool: ...\n    @overload\n    def UpdateEquation() -> bool: ...\n    @overload\n    def ValueAt(self, p: Point3d) -> float: ...\n\nclass Point2f(System.ValueType):\n    \"\"\"Represents the two coordinates of a point in two-dimensional space, using\n-precision floating point numbers.\n\n    \"\"\"\n    @overload\n    def __init__(self, x: System.Single, y: System.Single): ...\n    @overload\n    def __init__(self, x: float, y: float): ...\n    @overload\n    def CompareTo(self, other: Point2f) -> int: ...\n    @overload\n    def DistanceTo(self, other: Point2f) -> float: ...\n    @overload\n    def DistanceToSquared(self, other: Point2f) -> float: ...\n    @overload\n    def EpsilonEquals(self, other: Point2f, epsilon: System.Single) -> bool: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @overload\n    def Equals(self, point: Point2f) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Item(self) -> System.Single: ...\n    @property\n    def Unset(self) -> Point2f: ...\n    @property\n    def X(self) -> System.Single: ...\n    @property\n    def Y(self) -> System.Single: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @Item.setter\n    def Item(self, value: System.Void): ...\n    @X.setter\n    def X(self, value: System.Void): ...\n    @Y.setter\n    def Y(self, value: System.Void): ...\n    @overload\n    def ToString() -> str: ...\n    @overload\n    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...\n\nclass Point3f(System.ValueType):\n    \"\"\"Represents the three coordinates of a point in three-dimensional space, using\n-precision floating point numbers.\n\n    \"\"\"\n    def __init__(self, x: System.Single, y: System.Single, z: System.Single): ...\n    @overload\n    def CompareTo(self, other: Point3f) -> int: ...\n    @overload\n    def DistanceTo(self, other: Point3f) -> float: ...\n    @overload\n    def DistanceToSquared(self, other: Point3f) -> float: ...\n    @overload\n    def EpsilonEquals(self, other: Point3f, epsilon: System.Single) -> bool: ...\n    @overload\n    def Equals(self, point: Point3f) -> bool: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Origin(self) -> Point3f: ...\n    @property\n    def Unset(self) -> Point3f: ...\n    @property\n    def X(self) -> System.Single: ...\n    @property\n    def Y(self) -> System.Single: ...\n    @property\n    def Z(self) -> System.Single: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @X.setter\n    def X(self, value: System.Void): ...\n    @Y.setter\n    def Y(self, value: System.Void): ...\n    @Z.setter\n    def Z(self, value: System.Void): ...\n    @overload\n    @staticmethod\n    def Subtract(point1: Point3f, point2: Point3f) -> Vector3f: ...\n    @overload\n    def ToString() -> str: ...\n    @overload\n    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...\n    @overload\n    def Transform(self, xform: Transform) -> None: ...\n\nclass Vector2f(System.ValueType):\n    \"\"\"Represents the two components of a vector in two-dimensional space, using\n-precision floating point numbers.\n\n    \"\"\"\n    def __init__(self, x: System.Single, y: System.Single): ...\n    @overload\n    @staticmethod\n    def Add(point: Point2f, vector: Vector2f) -> Point2f: ...\n    @overload\n    @staticmethod\n    def Add(vector1: Vector2f, vector2: Vector2f) -> Vector2f: ...\n    @overload\n    def CompareTo(self, other: Vector2f) -> int: ...\n    @overload\n    def EpsilonEquals(self, other: Vector2f, epsilon: System.Single) -> bool: ...\n    @overload\n    def Equals(self, vector: Vector2f) -> bool: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @property\n    def IsUnitVector(self) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def IsZero(self) -> bool: ...\n    @property\n    def Length(self) -> float: ...\n    @property\n    def SquareLength(self) -> System.Single: ...\n    @property\n    def Unset(self) -> Vector2f: ...\n    @property\n    def X(self) -> System.Single: ...\n    @property\n    def XAxis(self) -> Vector2f: ...\n    @property\n    def Y(self) -> System.Single: ...\n    @property\n    def YAxis(self) -> Vector2f: ...\n    @property\n    def Zero(self) -> Vector2f: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    @staticmethod\n    def Multiply(point1: Vector2f, point2: Vector2f) -> float: ...\n    @overload\n    @staticmethod\n    def Negate(vector: Vector2f) -> Vector2f: ...\n    @overload\n    def PerpendicularTo(self, other: Vector2f) -> bool: ...\n    @overload\n    def Reverse() -> bool: ...\n    @X.setter\n    def X(self, value: System.Void): ...\n    @Y.setter\n    def Y(self, value: System.Void): ...\n    @overload\n    @staticmethod\n    def Subtract(vector1: Vector2f, vector2: Vector2f) -> Vector2f: ...\n    @overload\n    def ToString() -> str: ...\n    @overload\n    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...\n    @overload\n    def Unitize() -> bool: ...\n\nclass Vector3f(System.ValueType):\n    \"\"\"Represents the three components of a vector in three-dimensional space, using\n-precision floating point numbers.\n\n    \"\"\"\n    def __init__(self, x: System.Single, y: System.Single, z: System.Single): ...\n    @overload\n    @staticmethod\n    def Add(vector1: Vector3f, vector2: Vector3f) -> Vector3f: ...\n    @overload\n    @staticmethod\n    def Add(point: Point3f, vector: Vector3f) -> Point3f: ...\n    @overload\n    def CompareTo(self, other: Vector3f) -> int: ...\n    @overload\n    @staticmethod\n    def CrossProduct(a: Vector3f, b: Vector3f) -> Vector3f: ...\n    @overload\n    @staticmethod\n    def Divide(vector: Vector3f, t: float) -> Vector3f: ...\n    @overload\n    @staticmethod\n    def Divide(vector: Vector3f, t: System.Single) -> Vector3f: ...\n    @overload\n    def EpsilonEquals(self, other: Vector3f, epsilon: System.Single) -> bool: ...\n    @overload\n    def Equals(self, vector: Vector3f) -> bool: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @property\n    def IsUnitVector(self) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def IsZero(self) -> bool: ...\n    @property\n    def Length(self) -> System.Single: ...\n    @property\n    def SquareLength(self) -> System.Single: ...\n    @property\n    def Unset(self) -> Vector3f: ...\n    @property\n    def X(self) -> System.Single: ...\n    @property\n    def XAxis(self) -> Vector3f: ...\n    @property\n    def Y(self) -> System.Single: ...\n    @property\n    def YAxis(self) -> Vector3f: ...\n    @property\n    def Z(self) -> System.Single: ...\n    @property\n    def ZAxis(self) -> Vector3f: ...\n    @property\n    def Zero(self) -> Vector3f: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    @staticmethod\n    def Multiply(t: System.Single, vector: Vector3f) -> Vector3f: ...\n    @overload\n    @staticmethod\n    def Multiply(vector: Vector3f, t: System.Single) -> Vector3f: ...\n    @overload\n    @staticmethod\n    def Multiply(point1: Vector3f, point2: Vector3f) -> float: ...\n    @overload\n    @staticmethod\n    def Negate(vector: Vector3f) -> Vector3f: ...\n    @overload\n    def PerpendicularTo(self, other: Vector3f) -> bool: ...\n    @overload\n    def Reverse() -> bool: ...\n    @overload\n    def Rotate(self, angleRadians: float, rotationAxis: Vector3f) -> bool: ...\n    @X.setter\n    def X(self, value: System.Void): ...\n    @Y.setter\n    def Y(self, value: System.Void): ...\n    @Z.setter\n    def Z(self, value: System.Void): ...\n    @overload\n    @staticmethod\n    def Subtract(vector1: Vector3f, vector2: Vector3f) -> Vector3f: ...\n    @overload\n    def ToString() -> str: ...\n    @overload\n    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...\n    @overload\n    def Transform(self, transformation: Transform) -> None: ...\n    @overload\n    def Unitize() -> bool: ...\n\nclass Quaternion(System.ValueType):\n    \"\"\"Represents the four coefficient values in a quaternion.\nThe first value\na\nis the real part, while the rest multiplies\ni\n,\nj\nand\nk\n, that are imaginary.\nquaternion = a + bi + cj + dk\n\n    \"\"\"\n    def __init__(self, a: float, b: float, c: float, d: float): ...\n    @overload\n    @staticmethod\n    def CreateFromRotationZYX(yaw: float, pitch: float, roll: float) -> Quaternion: ...\n    @overload\n    @staticmethod\n    def CreateFromRotationZYZ(alpha: float, beta: float, gamma: float) -> Quaternion: ...\n    @overload\n    @staticmethod\n    def CrossProduct(p: Quaternion, q: Quaternion) -> Quaternion: ...\n    @overload\n    @staticmethod\n    def Distance(p: Quaternion, q: Quaternion) -> float: ...\n    @overload\n    def DistanceTo(self, q: Quaternion) -> float: ...\n    @overload\n    def EpsilonEquals(self, other: Quaternion, epsilon: float) -> bool: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @overload\n    def Equals(self, other: Quaternion) -> bool: ...\n    @property\n    def A(self) -> float: ...\n    @property\n    def B(self) -> float: ...\n    @property\n    def C(self) -> float: ...\n    @property\n    def Conjugate(self) -> Quaternion: ...\n    @property\n    def D(self) -> float: ...\n    @property\n    def I(self) -> Quaternion: ...\n    @property\n    def Identity(self) -> Quaternion: ...\n    @property\n    def Inverse(self) -> Quaternion: ...\n    @property\n    def IsScalar(self) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def IsVector(self) -> bool: ...\n    @property\n    def IsZero(self) -> bool: ...\n    @property\n    def J(self) -> Quaternion: ...\n    @property\n    def K(self) -> Quaternion: ...\n    @property\n    def Length(self) -> float: ...\n    @property\n    def LengthSquared(self) -> float: ...\n    @property\n    def Scalar(self) -> float: ...\n    @property\n    def Vector(self) -> Vector3d: ...\n    @property\n    def Zero(self) -> Quaternion: ...\n    @overload\n    def GetEulerZYZ() -> (bool, float, float, float): ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    def GetRotation() -> (bool, Transform): ...\n    @overload\n    def GetRotation() -> (bool, Plane): ...\n    @overload\n    def GetRotation() -> (bool, float, Vector3d): ...\n    @overload\n    def GetYawPitchRoll() -> (bool, float, float, float): ...\n    @overload\n    def Invert() -> bool: ...\n    @overload\n    @staticmethod\n    def Lerp(a: Quaternion, b: Quaternion, t: float) -> Quaternion: ...\n    @overload\n    def MatrixForm() -> Transform: ...\n    @overload\n    @staticmethod\n    def Product(p: Quaternion, q: Quaternion) -> Quaternion: ...\n    @overload\n    def Rotate(self, v: Vector3d) -> Vector3d: ...\n    @overload\n    @staticmethod\n    def RotateTowards(a: Quaternion, b: Quaternion, maxRadians: float) -> Quaternion: ...\n    @overload\n    @staticmethod\n    def Rotation(plane0: Plane, plane1: Plane) -> Quaternion: ...\n    @overload\n    @staticmethod\n    def Rotation(angle: float, axisOfRotation: Vector3d) -> Quaternion: ...\n    @A.setter\n    def A(self, value: System.Void): ...\n    @B.setter\n    def B(self, value: System.Void): ...\n    @C.setter\n    def C(self, value: System.Void): ...\n    @D.setter\n    def D(self, value: System.Void): ...\n    @overload\n    def Set(self, a: float, b: float, c: float, d: float) -> None: ...\n    @overload\n    def SetRotation(self, plane0: Plane, plane1: Plane) -> None: ...\n    @overload\n    def SetRotation(self, angle: float, axisOfRotation: Vector3d) -> None: ...\n    @overload\n    @staticmethod\n    def Slerp(a: Quaternion, b: Quaternion, t: float) -> Quaternion: ...\n    @overload\n    def ToString() -> str: ...\n    @overload\n    def Unitize() -> bool: ...\n\nclass Sphere(System.ValueType):\n    \"\"\"Represents the plane and radius values of a sphere.\n\n    \"\"\"\n    @overload\n    def __init__(self, center: Point3d, radius: float): ...\n    @overload\n    def __init__(self, equatorialPlane: Plane, radius: float): ...\n    @overload\n    def ClosestParameter(self, testPoint: Point3d) -> (bool, float, float): ...\n    @overload\n    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...\n    @overload\n    def EpsilonEquals(self, other: Sphere, epsilon: float) -> bool: ...\n    @overload\n    @staticmethod\n    def FitSphereToPoints(points: Generic.IEnumerable) -> Sphere: ...\n    @property\n    def BoundingBox(self) -> BoundingBox: ...\n    @property\n    def Center(self) -> Point3d: ...\n    @property\n    def Diameter(self) -> float: ...\n    @property\n    def EquatorialPlane(self) -> Plane: ...\n    @property\n    def EquitorialPlane(self) -> Plane: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def NorthPole(self) -> Point3d: ...\n    @property\n    def Radius(self) -> float: ...\n    @property\n    def SouthPole(self) -> Point3d: ...\n    @property\n    def Unset(self) -> Sphere: ...\n    @overload\n    def LatitudeDegrees(self, degrees: float) -> Circle: ...\n    @overload\n    def LatitudeRadians(self, radians: float) -> Circle: ...\n    @overload\n    def LongitudeDegrees(self, degrees: float) -> Circle: ...\n    @overload\n    def LongitudeRadians(self, radians: float) -> Circle: ...\n    @overload\n    def NormalAt(self, longitudeRadians: float, latitudeRadians: float) -> Vector3d: ...\n    @overload\n    def PointAt(self, longitudeRadians: float, latitudeRadians: float) -> Point3d: ...\n    @overload\n    def Rotate(self, angleRadians: float, axisOfRotation: Vector3d) -> bool: ...\n    @overload\n    def Rotate(self, angleRadians: float, axisOfRotation: Vector3d, centerOfRotation: Point3d) -> bool: ...\n    @overload\n    def Rotate(self, sinAngle: float, cosAngle: float, axisOfRotation: Vector3d) -> bool: ...\n    @overload\n    def Rotate(self, sinAngle: float, cosAngle: float, axisOfRotation: Vector3d, centerOfRotation: Point3d) -> bool: ...\n    @Center.setter\n    def Center(self, value: System.Void): ...\n    @Diameter.setter\n    def Diameter(self, value: System.Void): ...\n    @EquatorialPlane.setter\n    def EquatorialPlane(self, value: System.Void): ...\n    @EquitorialPlane.setter\n    def EquitorialPlane(self, value: System.Void): ...\n    @Radius.setter\n    def Radius(self, value: System.Void): ...\n    @overload\n    def ToBrep() -> Brep: ...\n    @overload\n    def ToNurbsSurface() -> NurbsSurface: ...\n    @overload\n    def ToRevSurface() -> RevSurface: ...\n    @overload\n    def Transform(self, xform: Transform) -> bool: ...\n    @overload\n    def Translate(self, delta: Vector3d) -> bool: ...\n\nclass Torus(System.ValueType):\n    \"\"\"Represents the value of a plane and two radii in a torus that is oriented in three-dimensional space.\n\n    \"\"\"\n    def __init__(self, basePlane: Plane, majorRadius: float, minorRadius: float): ...\n    @overload\n    def EpsilonEquals(self, other: Torus, epsilon: float) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def MajorRadius(self) -> float: ...\n    @property\n    def MinorRadius(self) -> float: ...\n    @property\n    def Plane(self) -> Plane: ...\n    @property\n    def Unset(self) -> Torus: ...\n    @MajorRadius.setter\n    def MajorRadius(self, value: System.Void): ...\n    @MinorRadius.setter\n    def MinorRadius(self, value: System.Void): ...\n    @Plane.setter\n    def Plane(self, value: System.Void): ...\n    @overload\n    def ToBrep() -> Brep: ...\n    @overload\n    def ToNurbsSurface() -> NurbsSurface: ...\n    @overload\n    def ToRevSurface() -> RevSurface: ...\n\nclass Transform(System.ValueType):\n    \"\"\"Represents the values in a 4x4 transform matrix.\nThis is parallel to C++ ON_Xform.\n\n    \"\"\"\n    @overload\n    def __init__(self, diagonalValue: float): ...\n    @overload\n    def __init__(self, value: Transform): ...\n    @overload\n    def Affineize() -> None: ...\n    @overload\n    @staticmethod\n    def ChangeBasis(plane0: Plane, plane1: Plane) -> Transform: ...\n    @overload\n    @staticmethod\n    def ChangeBasis(X0: Vector3d, Y0: Vector3d, Z0: Vector3d, X1: Vector3d, Y1: Vector3d, Z1: Vector3d) -> Transform: ...\n    @overload\n    @staticmethod\n    def ChangeBasis(P0: Point3d, X0: Vector3d, Y0: Vector3d, Z0: Vector3d, P1: Point3d, X1: Vector3d, Y1: Vector3d, Z1: Vector3d) -> Transform: ...\n    @overload\n    def Clone() -> Transform: ...\n    @overload\n    def CompareTo(self, other: Transform) -> int: ...\n    @overload\n    def DecomposeAffine() -> (bool, Vector3d, Transform): ...\n    @overload\n    def DecomposeAffine() -> (bool, Transform, Vector3d): ...\n    @overload\n    def DecomposeAffine() -> (bool, Vector3d, Transform, Transform, Vector3d): ...\n    @overload\n    def DecomposeRigid(self, tolerance: float) -> (TransformRigidType, Vector3d, Transform): ...\n    @overload\n    def DecomposeSimilarity(self, tolerance: float) -> (TransformSimilarityType, Vector3d, float, Transform): ...\n    @overload\n    def DecomposeSymmetric() -> (bool, Transform, Vector3d): ...\n    @overload\n    def DecomposeTextureMapping() -> (Vector3d, Vector3d, Vector3d): ...\n    @overload\n    @staticmethod\n    def Diagonal(diagonal: Vector3d) -> Transform: ...\n    @overload\n    @staticmethod\n    def Diagonal(d0: float, d1: float, d2: float) -> Transform: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @overload\n    def Equals(self, other: Transform) -> bool: ...\n    @property\n    def Determinant(self) -> float: ...\n    @property\n    def Identity(self) -> Transform: ...\n    @property\n    def IsAffine(self) -> bool: ...\n    @property\n    def IsIdentity(self) -> bool: ...\n    @property\n    def IsLinear(self) -> bool: ...\n    @property\n    def IsRotation(self) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def IsZero(self) -> bool: ...\n    @property\n    def IsZero4x4(self) -> bool: ...\n    @property\n    def IsZeroTransformation(self) -> bool: ...\n    @property\n    def Item(self) -> float: ...\n    @property\n    def M00(self) -> float: ...\n    @property\n    def M01(self) -> float: ...\n    @property\n    def M02(self) -> float: ...\n    @property\n    def M03(self) -> float: ...\n    @property\n    def M10(self) -> float: ...\n    @property\n    def M11(self) -> float: ...\n    @property\n    def M12(self) -> float: ...\n    @property\n    def M13(self) -> float: ...\n    @property\n    def M20(self) -> float: ...\n    @property\n    def M21(self) -> float: ...\n    @property\n    def M22(self) -> float: ...\n    @property\n    def M23(self) -> float: ...\n    @property\n    def M30(self) -> float: ...\n    @property\n    def M31(self) -> float: ...\n    @property\n    def M32(self) -> float: ...\n    @property\n    def M33(self) -> float: ...\n    @property\n    def RigidType(self) -> TransformRigidType: ...\n    @property\n    def SimilarityType(self) -> TransformSimilarityType: ...\n    @property\n    def Unset(self) -> Transform: ...\n    @property\n    def ZeroTransformation(self) -> Transform: ...\n    @overload\n    def GetEulerZYZ() -> (bool, float, float, float): ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    def GetQuaternion() -> (bool, Quaternion): ...\n    @overload\n    def GetYawPitchRoll() -> (bool, float, float, float): ...\n    @overload\n    def IsRigid(self, tolerance: float) -> TransformRigidType: ...\n    @overload\n    def IsSimilarity(self, tolerance: float) -> TransformSimilarityType: ...\n    @overload\n    def IsZeroTransformationWithTolerance(self, zeroTolerance: float) -> bool: ...\n    @overload\n    def Linearize() -> None: ...\n    @overload\n    @staticmethod\n    def Mirror(mirrorPlane: Plane) -> Transform: ...\n    @overload\n    @staticmethod\n    def Mirror(pointOnMirrorPlane: Point3d, normalToMirrorPlane: Vector3d) -> Transform: ...\n    @overload\n    @staticmethod\n    def Multiply(a: Transform, b: Transform) -> Transform: ...\n    @overload\n    def Orthogonalize(self, tolerance: float) -> bool: ...\n    @overload\n    @staticmethod\n    def PlanarProjection(plane: Plane) -> Transform: ...\n    @overload\n    @staticmethod\n    def PlaneToPlane(plane0: Plane, plane1: Plane) -> Transform: ...\n    @overload\n    @staticmethod\n    def ProjectAlong(plane: Plane, direction: Vector3d) -> Transform: ...\n    @overload\n    @staticmethod\n    def Rotation(angleRadians: float, rotationCenter: Point3d) -> Transform: ...\n    @overload\n    @staticmethod\n    def Rotation(startDirection: Vector3d, endDirection: Vector3d, rotationCenter: Point3d) -> Transform: ...\n    @overload\n    @staticmethod\n    def Rotation(angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> Transform: ...\n    @overload\n    @staticmethod\n    def Rotation(sinAngle: float, cosAngle: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> Transform: ...\n    @overload\n    @staticmethod\n    def Rotation(x0: Vector3d, y0: Vector3d, z0: Vector3d, x1: Vector3d, y1: Vector3d, z1: Vector3d) -> Transform: ...\n    @overload\n    @staticmethod\n    def RotationZYX(yaw: float, pitch: float, roll: float) -> Transform: ...\n    @overload\n    @staticmethod\n    def RotationZYZ(alpha: float, beta: float, gamma: float) -> Transform: ...\n    @overload\n    @staticmethod\n    def Scale(anchor: Point3d, scaleFactor: float) -> Transform: ...\n    @overload\n    @staticmethod\n    def Scale(plane: Plane, xScaleFactor: float, yScaleFactor: float, zScaleFactor: float) -> Transform: ...\n    @Item.setter\n    def Item(self, value: System.Void): ...\n    @M00.setter\n    def M00(self, value: System.Void): ...\n    @M01.setter\n    def M01(self, value: System.Void): ...\n    @M02.setter\n    def M02(self, value: System.Void): ...\n    @M03.setter\n    def M03(self, value: System.Void): ...\n    @M10.setter\n    def M10(self, value: System.Void): ...\n    @M11.setter\n    def M11(self, value: System.Void): ...\n    @M12.setter\n    def M12(self, value: System.Void): ...\n    @M13.setter\n    def M13(self, value: System.Void): ...\n    @M20.setter\n    def M20(self, value: System.Void): ...\n    @M21.setter\n    def M21(self, value: System.Void): ...\n    @M22.setter\n    def M22(self, value: System.Void): ...\n    @M23.setter\n    def M23(self, value: System.Void): ...\n    @M30.setter\n    def M30(self, value: System.Void): ...\n    @M31.setter\n    def M31(self, value: System.Void): ...\n    @M32.setter\n    def M32(self, value: System.Void): ...\n    @M33.setter\n    def M33(self, value: System.Void): ...\n    @overload\n    @staticmethod\n    def Shear(plane: Plane, x: Vector3d, y: Vector3d, z: Vector3d) -> Transform: ...\n    @overload\n    @staticmethod\n    def TextureMapping(offset: Vector3d, repeat: Vector3d, rotation: Vector3d) -> Transform: ...\n    @overload\n    def ToDoubleArray(self, rowDominant: bool) -> System.System.Array[float]: ...\n    @overload\n    def ToFloatArray(self, rowDominant: bool) -> System.System.Array[System.Single]: ...\n    @overload\n    def ToString() -> str: ...\n    @overload\n    def TransformBoundingBox(self, bbox: BoundingBox) -> BoundingBox: ...\n    @overload\n    def TransformList(self, points: Generic.IEnumerable) -> System.Array[Point3d]: ...\n    @overload\n    @staticmethod\n    def Translation(motion: Vector3d) -> Transform: ...\n    @overload\n    @staticmethod\n    def Translation(dx: float, dy: float, dz: float) -> Transform: ...\n    @overload\n    def Transpose() -> Transform: ...\n    @overload\n    def TryGetInverse() -> (bool, Transform): ...\n\nclass TransformSimilarityType(enum.Enum):\n    NotSimilarity = 0\n    OrientationPreserving = 1\n    OrientationReversing = -1\n\nclass TransformRigidType(enum.Enum):\n    NotRigid = 0\n    Rigid = 1\n    RigidReversing = -1\n\nclass SpaceMorph(object):\n    \"\"\"Represents a spacial, Euclidean morph.\n\n    \"\"\"\n    @property\n    def PreserveStructure(self) -> bool: ...\n    @property\n    def QuickPreview(self) -> bool: ...\n    @property\n    def Tolerance(self) -> float: ...\n    @overload\n    @staticmethod\n    def IsMorphable(geometry: GeometryBase) -> bool: ...\n    @overload\n    def Morph(self, geometry: GeometryBase) -> bool: ...\n    @overload\n    def Morph() -> (bool, Plane): ...\n    @overload\n    def MorphPoint(self, point: Point3d) -> Point3d: ...\n    @PreserveStructure.setter\n    def PreserveStructure(self, value: System.Void): ...\n    @QuickPreview.setter\n    def QuickPreview(self, value: System.Void): ...\n    @Tolerance.setter\n    def Tolerance(self, value: System.Void): ...\n\nclass Interval(System.ValueType):\n    \"\"\"Represents an interval in one-dimensional space, that is defined as two extrema or bounds.\n\n    \"\"\"\n    @overload\n    def __init__(self, other: Interval): ...\n    @overload\n    def __init__(self, t0: float, t1: float): ...\n    @overload\n    def CompareTo(self, other: Interval) -> int: ...\n    @overload\n    def EpsilonEquals(self, other: Interval, epsilon: float) -> bool: ...\n    @overload\n    def Equals(self, other: Interval) -> bool: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @overload\n    @staticmethod\n    def FromIntersection(a: Interval, b: Interval) -> Interval: ...\n    @overload\n    @staticmethod\n    def FromUnion(a: Interval, b: Interval) -> Interval: ...\n    @property\n    def IsDecreasing(self) -> bool: ...\n    @property\n    def IsIncreasing(self) -> bool: ...\n    @property\n    def IsSingleton(self) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Item(self) -> float: ...\n    @property\n    def Length(self) -> float: ...\n    @property\n    def Max(self) -> float: ...\n    @property\n    def Mid(self) -> float: ...\n    @property\n    def Min(self) -> float: ...\n    @property\n    def T0(self) -> float: ...\n    @property\n    def T1(self) -> float: ...\n    @property\n    def Unset(self) -> Interval: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    def Grow(self, value: float) -> None: ...\n    @overload\n    def IncludesInterval(self, interval: Interval) -> bool: ...\n    @overload\n    def IncludesInterval(self, interval: Interval, strict: bool) -> bool: ...\n    @overload\n    def IncludesParameter(self, t: float) -> bool: ...\n    @overload\n    def IncludesParameter(self, t: float, strict: bool) -> bool: ...\n    @overload\n    def MakeIncreasing() -> None: ...\n    @overload\n    def NormalizedIntervalAt(self, intervalParameter: Interval) -> Interval: ...\n    @overload\n    def NormalizedParameterAt(self, intervalParameter: float) -> float: ...\n    @overload\n    def ParameterAt(self, normalizedParameter: float) -> float: ...\n    @overload\n    def ParameterIntervalAt(self, normalizedInterval: Interval) -> Interval: ...\n    @overload\n    def Reverse() -> None: ...\n    @Item.setter\n    def Item(self, value: System.Void): ...\n    @T0.setter\n    def T0(self, value: System.Void): ...\n    @T1.setter\n    def T1(self, value: System.Void): ...\n    @overload\n    def Swap() -> None: ...\n    @overload\n    def ToString() -> str: ...\n\nclass Point2d(System.ValueType):\n    \"\"\"Represents the two coordinates of a point in two-dimensional space, using\n-precision floating point numbers.\n\n    \"\"\"\n    @overload\n    def __init__(self, vector: Vector2d): ...\n    @overload\n    def __init__(self, point: Point2d): ...\n    @overload\n    def __init__(self, point: Point3d): ...\n    @overload\n    def __init__(self, x: float, y: float): ...\n    @overload\n    @staticmethod\n    def Add(point1: Point2d, point2: Point2d) -> Point2d: ...\n    @overload\n    @staticmethod\n    def Add(vector: Vector2d, point: Point2d) -> Point2d: ...\n    @overload\n    @staticmethod\n    def Add(point: Point2d, vector: Vector2d) -> Point2d: ...\n    @overload\n    def CompareTo(self, other: Point2d) -> int: ...\n    @overload\n    def DistanceTo(self, other: Point2d) -> float: ...\n    @overload\n    def DistanceToSquared(self, other: Point2d) -> float: ...\n    @overload\n    @staticmethod\n    def Divide(point: Point2d, t: float) -> Point2d: ...\n    @overload\n    def EpsilonEquals(self, other: Point2d, epsilon: float) -> bool: ...\n    @overload\n    def Equals(self, point: Point2d) -> bool: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Item(self) -> float: ...\n    @property\n    def MaximumCoordinate(self) -> float: ...\n    @property\n    def MinimumCoordinate(self) -> float: ...\n    @property\n    def Origin(self) -> Point2d: ...\n    @property\n    def Unset(self) -> Point2d: ...\n    @property\n    def X(self) -> float: ...\n    @property\n    def Y(self) -> float: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    @staticmethod\n    def Multiply(point: Point2d, t: float) -> Point2d: ...\n    @overload\n    @staticmethod\n    def Multiply(t: float, point: Point2d) -> Point2d: ...\n    @Item.setter\n    def Item(self, value: System.Void): ...\n    @X.setter\n    def X(self, value: System.Void): ...\n    @Y.setter\n    def Y(self, value: System.Void): ...\n    @overload\n    @staticmethod\n    def Subtract(point: Point2d, vector: Vector2d) -> Point2d: ...\n    @overload\n    @staticmethod\n    def Subtract(point1: Point2d, point2: Point2d) -> Vector2d: ...\n    @overload\n    def ToString() -> str: ...\n    @overload\n    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...\n    @overload\n    def Transform(self, xform: Transform) -> None: ...\n\nclass Point3d(System.ValueType):\n    \"\"\"Represents the three coordinates of a point in three-dimensional space, using\n-precision floating point values.\n\n    \"\"\"\n    @overload\n    def __init__(self, vector: Vector3d): ...\n    @overload\n    def __init__(self, point: Point3f): ...\n    @overload\n    def __init__(self, point: Point3d): ...\n    @overload\n    def __init__(self, point: Point4d): ...\n    @overload\n    def __init__(self, x: float, y: float, z: float): ...\n    @overload\n    @staticmethod\n    def Add(point: Point3d, vector: Vector3d) -> Point3d: ...\n    @overload\n    @staticmethod\n    def Add(vector: Vector3d, point: Point3d) -> Point3d: ...\n    @overload\n    @staticmethod\n    def Add(point1: Point3d, point2: Point3d) -> Point3d: ...\n    @overload\n    @staticmethod\n    def Add(point: Point3d, vector: Vector3f) -> Point3d: ...\n    @overload\n    @staticmethod\n    def ArePointsCoplanar(points: Generic.IEnumerable, tolerance: float) -> bool: ...\n    @overload\n    def CompareTo(self, other: Point3d) -> int: ...\n    @overload\n    @staticmethod\n    def CullDuplicates(points: Generic.IEnumerable, tolerance: float) -> System.Array[Point3d]: ...\n    @overload\n    def DistanceTo(self, other: Point3d) -> float: ...\n    @overload\n    def DistanceToSquared(self, other: Point3d) -> float: ...\n    @overload\n    @staticmethod\n    def Divide(point: Point3d, t: float) -> Point3d: ...\n    @overload\n    def EpsilonEquals(self, other: Point3d, epsilon: float) -> bool: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @overload\n    def Equals(self, point: Point3d) -> bool: ...\n    @overload\n    @staticmethod\n    def FromPoint3f(point: Point3f) -> Point3d: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Item(self) -> float: ...\n    @property\n    def MaximumCoordinate(self) -> float: ...\n    @property\n    def MinimumCoordinate(self) -> float: ...\n    @property\n    def Origin(self) -> Point3d: ...\n    @property\n    def Unset(self) -> Point3d: ...\n    @property\n    def X(self) -> float: ...\n    @property\n    def Y(self) -> float: ...\n    @property\n    def Z(self) -> float: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    def Interpolate(self, pA: Point3d, pB: Point3d, t: float) -> None: ...\n    @overload\n    @staticmethod\n    def Multiply(t: float, point: Point3d) -> Point3d: ...\n    @overload\n    @staticmethod\n    def Multiply(point: Point3d, t: float) -> Point3d: ...\n    @Item.setter\n    def Item(self, value: System.Void): ...\n    @X.setter\n    def X(self, value: System.Void): ...\n    @Y.setter\n    def Y(self, value: System.Void): ...\n    @Z.setter\n    def Z(self, value: System.Void): ...\n    @overload\n    @staticmethod\n    def SortAndCullPointList(points: Generic.IEnumerable, minimumDistance: float) -> System.Array[Point3d]: ...\n    @overload\n    @staticmethod\n    def Subtract(point1: Point3d, point2: Point3d) -> Vector3d: ...\n    @overload\n    @staticmethod\n    def Subtract(point: Point3d, vector: Vector3d) -> Point3d: ...\n    @overload\n    def ToString() -> str: ...\n    @overload\n    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...\n    @overload\n    def Transform(self, xform: Transform) -> None: ...\n    @overload\n    @staticmethod\n    def TryParse(input_: str) -> (bool, Point3d): ...\n\nclass Point4d(System.ValueType):\n    \"\"\"Represents the four coordinates of a point in four-dimensional space.\nThe W (fourth) dimension is often considered the weight of the point as seen in 3D space.\n\n    \"\"\"\n    @overload\n    def __init__(self, point: Point3d): ...\n    @overload\n    def __init__(self, point: Point4d): ...\n    @overload\n    def __init__(self, x: float, y: float, z: float, w: float): ...\n    @overload\n    @staticmethod\n    def Add(point1: Point4d, point2: Point4d) -> Point4d: ...\n    @overload\n    def EpsilonEquals(self, other: Point4d, epsilon: float) -> bool: ...\n    @overload\n    def Equals(self, point: Point4d) -> bool: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Unset(self) -> Point4d: ...\n    @property\n    def W(self) -> float: ...\n    @property\n    def X(self) -> float: ...\n    @property\n    def Y(self) -> float: ...\n    @property\n    def Z(self) -> float: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    @staticmethod\n    def Multiply(point: Point4d, d: float) -> Point4d: ...\n    @W.setter\n    def W(self, value: System.Void): ...\n    @X.setter\n    def X(self, value: System.Void): ...\n    @Y.setter\n    def Y(self, value: System.Void): ...\n    @Z.setter\n    def Z(self, value: System.Void): ...\n    @overload\n    @staticmethod\n    def Subtract(point1: Point4d, point2: Point4d) -> Point4d: ...\n    @overload\n    def ToString() -> str: ...\n    @overload\n    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...\n    @overload\n    def Transform(self, xform: Transform) -> None: ...\n\nclass Vector2d(System.ValueType):\n    \"\"\"Represents the two components of a vector in two-dimensional space, using\n-precision floating point numbers.\n\n    \"\"\"\n    def __init__(self, x: float, y: float): ...\n    @overload\n    @staticmethod\n    def Add(vector1: Vector2d, vector2: Vector2d) -> Vector2d: ...\n    @overload\n    def CompareTo(self, other: Vector2d) -> int: ...\n    @overload\n    @staticmethod\n    def Divide(vector: Vector2d, t: float) -> Vector2d: ...\n    @overload\n    def EpsilonEquals(self, other: Vector2d, epsilon: float) -> bool: ...\n    @overload\n    def Equals(self, vector: Vector2d) -> bool: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def Length(self) -> float: ...\n    @property\n    def SquareLength(self) -> float: ...\n    @property\n    def Unset(self) -> Vector2d: ...\n    @property\n    def X(self) -> float: ...\n    @property\n    def Y(self) -> float: ...\n    @property\n    def Zero(self) -> Vector2d: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    def IsTiny() -> bool: ...\n    @overload\n    def IsTiny(self, tolerance: float) -> bool: ...\n    @overload\n    @staticmethod\n    def Multiply(vector1: Vector2d, vector2: Vector2d) -> float: ...\n    @overload\n    @staticmethod\n    def Multiply(vector: Vector2d, t: float) -> Vector2d: ...\n    @overload\n    @staticmethod\n    def Multiply(t: float, vector: Vector2d) -> Vector2d: ...\n    @overload\n    @staticmethod\n    def Negate(vector: Vector2d) -> Vector2d: ...\n    @overload\n    def Rotate(self, angleRadians: float) -> bool: ...\n    @X.setter\n    def X(self, value: System.Void): ...\n    @Y.setter\n    def Y(self, value: System.Void): ...\n    @overload\n    @staticmethod\n    def Subtract(vector1: Vector2d, vector2: Vector2d) -> Vector2d: ...\n    @overload\n    def ToString() -> str: ...\n    @overload\n    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...\n    @overload\n    def Unitize() -> bool: ...\n\nclass Vector3d(System.ValueType):\n    \"\"\"Represents the three components of a vector in three-dimensional space, using\n-precision floating point numbers.\n\n    \"\"\"\n    @overload\n    def __init__(self, point: Point3d): ...\n    @overload\n    def __init__(self, vector: Vector3f): ...\n    @overload\n    def __init__(self, vector: Vector3d): ...\n    @overload\n    def __init__(self, x: float, y: float, z: float): ...\n    @overload\n    @staticmethod\n    def Add(vector1: Vector3d, vector2: Vector3d) -> Vector3d: ...\n    @overload\n    @staticmethod\n    def AreOrthogonal(x: Vector3d, y: Vector3d, z: Vector3d) -> bool: ...\n    @overload\n    @staticmethod\n    def AreOrthonormal(x: Vector3d, y: Vector3d, z: Vector3d) -> bool: ...\n    @overload\n    @staticmethod\n    def AreRighthanded(x: Vector3d, y: Vector3d, z: Vector3d) -> bool: ...\n    @overload\n    def CompareTo(self, other: Vector3d) -> int: ...\n    @overload\n    @staticmethod\n    def CrossProduct(a: Vector3d, b: Vector3d) -> Vector3d: ...\n    @overload\n    @staticmethod\n    def Divide(vector: Vector3d, t: float) -> Vector3d: ...\n    @overload\n    def EpsilonEquals(self, other: Vector3d, epsilon: float) -> bool: ...\n    @overload\n    def Equals(self, vector: Vector3d) -> bool: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @property\n    def IsUnitVector(self) -> bool: ...\n    @property\n    def IsValid(self) -> bool: ...\n    @property\n    def IsZero(self) -> bool: ...\n    @property\n    def Item(self) -> float: ...\n    @property\n    def Length(self) -> float: ...\n    @property\n    def MaximumCoordinate(self) -> float: ...\n    @property\n    def MinimumCoordinate(self) -> float: ...\n    @property\n    def SquareLength(self) -> float: ...\n    @property\n    def Unset(self) -> Vector3d: ...\n    @property\n    def X(self) -> float: ...\n    @property\n    def XAxis(self) -> Vector3d: ...\n    @property\n    def Y(self) -> float: ...\n    @property\n    def YAxis(self) -> Vector3d: ...\n    @property\n    def Z(self) -> float: ...\n    @property\n    def ZAxis(self) -> Vector3d: ...\n    @property\n    def Zero(self) -> Vector3d: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    def IsParallelTo(self, other: Vector3d) -> int: ...\n    @overload\n    def IsParallelTo(self, other: Vector3d, angleTolerance: float) -> int: ...\n    @overload\n    def IsPerpendicularTo(self, other: Vector3d) -> bool: ...\n    @overload\n    def IsPerpendicularTo(self, other: Vector3d, angleTolerance: float) -> bool: ...\n    @overload\n    def IsTiny() -> bool: ...\n    @overload\n    def IsTiny(self, tolerance: float) -> bool: ...\n    @overload\n    @staticmethod\n    def Multiply(vector: Vector3d, t: float) -> Vector3d: ...\n    @overload\n    @staticmethod\n    def Multiply(t: float, vector: Vector3d) -> Vector3d: ...\n    @overload\n    @staticmethod\n    def Multiply(vector1: Vector3d, vector2: Vector3d) -> float: ...\n    @overload\n    @staticmethod\n    def Negate(vector: Vector3d) -> Vector3d: ...\n    @overload\n    def PerpendicularTo(self, other: Vector3d) -> bool: ...\n    @overload\n    def PerpendicularTo(self, point0: Point3d, point1: Point3d, point2: Point3d) -> bool: ...\n    @overload\n    def Reverse() -> bool: ...\n    @overload\n    def Rotate(self, angleRadians: float, rotationAxis: Vector3d) -> bool: ...\n    @Item.setter\n    def Item(self, value: System.Void): ...\n    @X.setter\n    def X(self, value: System.Void): ...\n    @Y.setter\n    def Y(self, value: System.Void): ...\n    @Z.setter\n    def Z(self, value: System.Void): ...\n    @overload\n    @staticmethod\n    def Subtract(vector1: Vector3d, vector2: Vector3d) -> Vector3d: ...\n    @overload\n    def ToString() -> str: ...\n    @overload\n    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...\n    @overload\n    def Transform(self, transformation: Transform) -> None: ...\n    @overload\n    def Unitize() -> bool: ...\n    @overload\n    @staticmethod\n    def VectorAngle(a: Vector3d, b: Vector3d) -> float: ...\n    @overload\n    @staticmethod\n    def VectorAngle(v1: Vector3d, v2: Vector3d, vNormal: Vector3d) -> float: ...\n    @overload\n    @staticmethod\n    def VectorAngle(a: Vector3d, b: Vector3d, plane: Plane) -> float: ...\n\nclass Ray3d(System.ValueType):\n    \"\"\"Represents an immutable ray in three dimensions, using position and direction.\n\n    \"\"\"\n    def __init__(self, position: Point3d, direction: Vector3d): ...\n    @overload\n    def EpsilonEquals(self, other: Ray3d, epsilon: float) -> bool: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @overload\n    def Equals(self, ray: Ray3d) -> bool: ...\n    @property\n    def Direction(self) -> Vector3d: ...\n    @property\n    def Position(self) -> Point3d: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    def PointAt(self, t: float) -> Point3d: ...\n\nclass Continuity(enum.Enum):\n    None_ = 0\n    C0_continuous = 1\n    C1_continuous = 2\n    C2_continuous = 3\n    G1_continuous = 4\n    G2_continuous = 5\n    C0_locus_continuous = 6\n    C1_locus_continuous = 7\n    C2_locus_continuous = 8\n    G1_locus_continuous = 9\n    G2_locus_continuous = 10\n    Cinfinity_continuous = 11\n    Gsmooth_continuous = 12\n\nclass MeshType(enum.Enum):\n    Default = 0\n    Render = 1\n    Analysis = 2\n    Preview = 3\n    Any = 4\n\nclass LightStyle(enum.Enum):\n    None_ = 0\n    CameraDirectional = 4\n    CameraPoint = 5\n    CameraSpot = 6\n    WorldDirectional = 7\n    WorldPoint = 8\n    WorldSpot = 9\n    Ambient = 10\n    WorldLinear = 11\n    WorldRectangular = 12\n\nclass ComponentIndexType(enum.Enum):\n    InvalidType = 0\n    BrepVertex = 1\n    BrepEdge = 2\n    BrepFace = 3\n    BrepTrim = 4\n    BrepLoop = 5\n    MeshVertex = 11\n    MeshTopologyVertex = 12\n    MeshTopologyEdge = 13\n    MeshFace = 14\n    MeshNgon = 15\n    InstanceDefinitionPart = 21\n    PolycurveSegment = 31\n    PointCloudPoint = 41\n    GroupMember = 51\n    ExtrusionBottomProfile = 61\n    ExtrusionTopProfile = 62\n    ExtrusionWallEdge = 63\n    ExtrusionWallSurface = 64\n    ExtrusionCapSurface = 65\n    ExtrusionPath = 66\n    SubdVertex = 71\n    SubdEdge = 72\n    SubdFace = 73\n    DimLinearPoint = 100\n    DimRadialPoint = 101\n    DimAngularPoint = 102\n    DimOrdinatePoint = 103\n    DimTextPoint = 104\n    NoType = 268435455\n\nclass ComponentIndex(System.ValueType):\n    \"\"\"Represents an index of an element contained in another object.\n\n    \"\"\"\n    def __init__(self, type_: ComponentIndexType, index: int): ...\n    @overload\n    def CompareTo(self, other: ComponentIndex) -> int: ...\n    @overload\n    def Equals(self, other: ComponentIndex) -> bool: ...\n    @overload\n    def Equals(self, obj: object) -> bool: ...\n    @property\n    def ComponentIndexType(self) -> ComponentIndexType: ...\n    @property\n    def Index(self) -> int: ...\n    @property\n    def Unset(self) -> ComponentIndex: ...\n    @overload\n    def GetHashCode() -> int: ...\n    @overload\n    def IsUnset() -> bool: ...\n\nclass SurfaceFilletBase(object):\n    \"\"\"New interactive FilletSrf\n\n    \"\"\"\n    @overload\n    @staticmethod\n    def CreateG2ChordalQuinticFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: Generic.List, trimmedBrepsB: Generic.List, rail_degree: int, bTrim: bool, bExtend: bool, Fillets: Generic.List) -> bool: ...\n    @overload\n    @staticmethod\n    def CreateNonRationalCubicArcsFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: Generic.List, trimmedBrepsB: Generic.List, rail_degree: int, bTrim: bool, bExtend: bool, Fillets: Generic.List) -> bool: ...\n    @overload\n    @staticmethod\n    def CreateNonRationalCubicFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: Generic.List, trimmedBrepsB: Generic.List, rail_degree: int, TanSlider: float, bTrim: bool, bExtend: bool, Fillets: Generic.List) -> bool: ...\n    @overload\n    @staticmethod\n    def CreateNonRationalQuarticArcsFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: Generic.List, trimmedBrepsB: Generic.List, rail_degree: int, bTrim: bool, bExtend: bool, Fillets: Generic.List) -> bool: ...\n    @overload\n    @staticmethod\n    def CreateNonRationalQuarticFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: Generic.List, trimmedBrepsB: Generic.List, rail_degree: int, TanSlider: float, InnerSlider: float, bTrim: bool, bExtend: bool, Fillets: Generic.List) -> bool: ...\n    @overload\n    @staticmethod\n    def CreateNonRationalQuinticArcsFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: Generic.List, trimmedBrepsB: Generic.List, rail_degree: int, bTrim: bool, bExtend: bool, Fillets: Generic.List) -> bool: ...\n    @overload\n    @staticmethod\n    def CreateNonRationalQuinticFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: Generic.List, trimmedBrepsB: Generic.List, rail_degree: int, TanSlider: float, InnerSlider: float, bTrim: bool, bExtend: bool, Fillets: Generic.List) -> bool: ...\n    @overload\n    @staticmethod\n    def CreateRationalArcsFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: Generic.List, trimmedBrepsB: Generic.List, rail_degree: int, bTrim: bool, bExtend: bool, Fillets: Generic.List) -> bool: ...\n    @overload\n    def Dispose() -> None: ...\n    @overload\n    def G2ChordalQuintic(self, railDegree: int, bExtend: bool, Fillets: Generic.List) -> bool: ...\n    @overload\n    def IsInitialized() -> bool: ...\n    @overload\n    def NonRationalCubic(self, railDegree: int, TanSlider: float, bExtend: bool, Fillets: Generic.List) -> bool: ...\n    @overload\n    def NonRationalCubicArcs(self, railDegree: int, bExtend: bool, Fillets: Generic.List) -> bool: ...\n    @overload\n    def NonRationalQuartic(self, railDegree: int, TanSlider: float, InnerSlider: float, bExtend: bool, Fillets: Generic.List) -> bool: ...\n    @overload\n    def NonRationalQuarticArcs(self, railDegree: int, bExtend: bool, Fillets: Generic.List) -> bool: ...\n    @overload\n    def NonRationalQuintic(self, railDegree: int, TanSlider: float, InnerSlider: float, bExtend: bool, Fillets: Generic.List) -> bool: ...\n    @overload\n    def NonRationalQuinticArcs(self, railDegree: int, bExtend: bool, Fillets: Generic.List) -> bool: ...\n    @overload\n    def RationalArcs(self, railDegree: int, bExtend: bool, Fillets: Generic.List) -> bool: ...\n    @overload\n    def TrimBreps(self, bExtend: bool, TrimmedBreps0: Generic.List, TrimmedBreps1: Generic.List) -> bool: ...\n\nclass SweepOneRail(object):\n    \"\"\"Utility class for generating Breps by sweeping cross section curves over a single rail curve. Note, this class has been superseded by the Rhino.Geometry.Brep.CreateFromSweep static functions.\n\n    \"\"\"\n    def __init__(self): ...\n    @property\n    def AngleToleranceRadians(self) -> float: ...\n    @property\n    def ClosedSweep(self) -> bool: ...\n    @property\n    def GlobalShapeBlending(self) -> bool: ...\n    @property\n    def IsFreeform(self) -> bool: ...\n    @property\n    def IsRoadlike(self) -> bool: ...\n    @property\n    def IsRoadlikeFront(self) -> bool: ...\n    @property\n    def IsRoadlikeTop(self) -> bool: ...\n    @property\n    def IsRoadlineRight(self) -> bool: ...\n    @property\n    def MiterType(self) -> int: ...\n    @property\n    def SweepTolerance(self) -> float: ...\n    @overload\n    def PerformSweep(self, rail: Curve, crossSections: Generic.IEnumerable) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweep(self, rail: Curve, crossSection: Curve) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweep(self, rail: Curve, crossSection: Curve, crossSectionParameter: float) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweep(self, rail: Curve, crossSections: Generic.IEnumerable, crossSectionParameters: Generic.IEnumerable) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweepRebuild(self, rail: Curve, crossSections: Generic.IEnumerable, rebuildCount: int) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweepRebuild(self, rail: Curve, crossSection: Curve, rebuildCount: int) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweepRebuild(self, rail: Curve, crossSections: Generic.IEnumerable, crossSectionParameters: Generic.IEnumerable, rebuildCount: int) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweepRebuild(self, rail: Curve, crossSection: Curve, crossSectionParameter: float, rebuildCount: int) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweepRefit(self, rail: Curve, crossSection: Curve, refitTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweepRefit(self, rail: Curve, crossSections: Generic.IEnumerable, refitTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweepRefit(self, rail: Curve, crossSection: Curve, crossSectionParameter: float, refitTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweepRefit(self, rail: Curve, crossSections: Generic.IEnumerable, crossSectionParameters: Generic.IEnumerable, refitTolerance: float) -> System.Array[Brep]: ...\n    @AngleToleranceRadians.setter\n    def AngleToleranceRadians(self, value: System.Void): ...\n    @ClosedSweep.setter\n    def ClosedSweep(self, value: System.Void): ...\n    @GlobalShapeBlending.setter\n    def GlobalShapeBlending(self, value: System.Void): ...\n    @MiterType.setter\n    def MiterType(self, value: System.Void): ...\n    @SweepTolerance.setter\n    def SweepTolerance(self, value: System.Void): ...\n    @overload\n    def SetRoadlikeUpDirection(self, up: Vector3d) -> None: ...\n    @overload\n    def SetToRoadlikeFront() -> None: ...\n    @overload\n    def SetToRoadlikeRight() -> None: ...\n    @overload\n    def SetToRoadlikeTop() -> None: ...\n\nclass SweepTwoRail(object):\n    \"\"\"Utility class for generating Breps by sweeping cross section curves over two rail curves. Note, this class has been superseded by the Rhino.Geometry.Brep.CreateFromSweep static functions.\n\n    \"\"\"\n    def __init__(self): ...\n    @property\n    def AngleToleranceRadians(self) -> float: ...\n    @property\n    def AutoAdjust(self) -> bool: ...\n    @property\n    def ClosedSweep(self) -> bool: ...\n    @property\n    def MaintainHeight(self) -> bool: ...\n    @property\n    def SweepTolerance(self) -> float: ...\n    @property\n    def UseLegacySweeper(self) -> bool: ...\n    @overload\n    def PerformSweep(self, rail1: Curve, rail2: Curve, crossSection: Curve) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweep(self, rail1: Curve, rail2: Curve, crossSections: Generic.IEnumerable) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweep(self, rail1: Curve, rail2: Curve, crossSection: Curve, crossSectionParameterRail1: float, crossSectionParameterRail2: float) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweep(self, rail1: Curve, rail2: Curve, crossSections: Generic.IEnumerable, crossSectionParameters1: Generic.IEnumerable, crossSectionParameters2: Generic.IEnumerable) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweepRebuild(self, rail1: Curve, rail2: Curve, crossSections: Generic.IEnumerable, rebuildCount: int) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweepRebuild(self, rail1: Curve, rail2: Curve, crossSection: Curve, rebuildCount: int) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweepRebuild(self, rail1: Curve, rail2: Curve, crossSections: Generic.IEnumerable, crossSectionParametersRail1: Generic.IEnumerable, crossSectionParametersRail2: Generic.IEnumerable, rebuildCount: int) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweepRebuild(self, rail1: Curve, rail2: Curve, crossSection: Curve, crossSectionParameterRail1: float, crossSectionParameterRail2: float, rebuildCount: int) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweepRefit(self, rail1: Curve, rail2: Curve, crossSection: Curve, refitTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweepRefit(self, rail1: Curve, rail2: Curve, crossSections: Generic.IEnumerable, refitTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweepRefit(self, rail1: Curve, rail2: Curve, crossSection: Curve, crossSectionParameterRail1: float, crossSectionParameterRail2: float, refitTolerance: float) -> System.Array[Brep]: ...\n    @overload\n    def PerformSweepRefit(self, rail1: Curve, rail2: Curve, crossSections: Generic.IEnumerable, crossSectionParametersRail1: Generic.IEnumerable, crossSectionParametersRail2: Generic.IEnumerable, refitTolerance: float) -> System.Array[Brep]: ...\n    @AngleToleranceRadians.setter\n    def AngleToleranceRadians(self, value: System.Void): ...\n    @AutoAdjust.setter\n    def AutoAdjust(self, value: System.Void): ...\n    @ClosedSweep.setter\n    def ClosedSweep(self, value: System.Void): ...\n    @MaintainHeight.setter\n    def MaintainHeight(self, value: System.Void): ...\n    @SweepTolerance.setter\n    def SweepTolerance(self, value: System.Void): ...\n    @UseLegacySweeper.setter\n    def UseLegacySweeper(self, value: System.Void): ...\n\nclass Unroller(object):\n    \"\"\"Represents the operation of unrolling a single surface.\n\n    \"\"\"\n    @overload\n    def __init__(self, surface: Surface): ...\n    @overload\n    def __init__(self, brep: Brep): ...\n    @overload\n    def AddFollowingGeometry(self, curves: Generic.IEnumerable) -> None: ...\n    @overload\n    def AddFollowingGeometry(self, curve: Curve) -> None: ...\n    @overload\n    def AddFollowingGeometry(self, points: Generic.IEnumerable) -> None: ...\n    @overload\n    def AddFollowingGeometry(self, point: Point3d) -> None: ...\n    @overload\n    def AddFollowingGeometry(self, point: Point) -> None: ...\n    @overload\n    def AddFollowingGeometry(self, dots: Generic.IEnumerable) -> None: ...\n    @overload\n    def AddFollowingGeometry(self, dot: TextDot) -> None: ...\n    @overload\n    def AddFollowingGeometry(self, dotLocations: Generic.IEnumerable, dotText: Generic.IEnumerable) -> None: ...\n    @overload\n    def AddFollowingGeometry(self, dotLocation: Point3d, dotText: str) -> None: ...\n    @overload\n    def FollowingGeometryIndex(self, curve: Curve) -> int: ...\n    @overload\n    def FollowingGeometryIndex(self, dot: TextDot) -> int: ...\n    @property\n    def AbsoluteTolerance(self) -> float: ...\n    @property\n    def ExplodeOutput(self) -> bool: ...\n    @property\n    def ExplodeSpacing(self) -> float: ...\n    @property\n    def RelativeTolerance(self) -> float: ...\n    @overload\n    def PerformUnroll(self, flatbreps: Generic.List) -> int: ...\n    @overload\n    def PerformUnroll() -> (System.Array[Brep], System.Array[Curve], System.Array[Point3d], System.Array[TextDot]): ...\n    @AbsoluteTolerance.setter\n    def AbsoluteTolerance(self, value: System.Void): ...\n    @ExplodeOutput.setter\n    def ExplodeOutput(self, value: System.Void): ...\n    @ExplodeSpacing.setter\n    def ExplodeSpacing(self, value: System.Void): ...\n    @RelativeTolerance.setter\n    def RelativeTolerance(self, value: System.Void): ...\n\nclass DevelopableSrf(object):\n    \"\"\"Helpers for developable surface functions\n\n    \"\"\"\n    def __init__(self): ...\n    @overload\n    @staticmethod\n    def GetLocalDevopableRuling(rail0: NurbsCurve, t0: float, dom0: Interval, rail1: NurbsCurve, t1: float, dom1: Interval) -> (int, float, float): ...\n    @overload\n    @staticmethod\n    def RulingMinTwist(rail0: NurbsCurve, t0: float, rail1: NurbsCurve, t1: float, dom1: Interval) -> (bool, float, float): ...\n    @overload\n    @staticmethod\n    def RulingMinTwist(rail0: NurbsCurve, t0: float, dom0: Interval, rail1: NurbsCurve, t1: float, dom1: Interval) -> (bool, float, float, float): ...\n    @overload\n    @staticmethod\n    def UntwistRulings(rail0: NurbsCurve, rail1: NurbsCurve) -> (bool, Generic.IEnumerable): ...\n\nclass ForceArrow(enum.Enum):\n    Auto = 0\n    Inside = 1\n    Outside = 2\n\nclass ForceText(enum.Enum):\n    Auto = 0\n    Inside = 1\n    Right = 2\n    Left = 3\n    HintRight = 4\n    HintLeft = 5\n\nclass MeasuredDirection(enum.Enum):\n    Unset = 0\n    Xaxis = 1\n    Yaxis = 2\n\nclass ExtraordinaryVertexProcessOption(enum.Enum):\n    None_ = 0\n    LocalG1 = 1\n    LocalG2 = 2\n    LocalG1x = 3\n    LocalG1xx = 4\n\nclass NurbsSurfaceType(enum.Enum):\n    Unset = 0\n    Large = 1\n    Medium = 2\n    Small = 3\n    Unprocessed = 4\n\nclass InteriorCreaseOption(enum.Enum):\n    Unset = 0\n    None_ = 1\n    AtMeshDoubleEdge = 2\n\nclass ConvexCornerOption(enum.Enum):\n    Unset = 0\n    None_ = 1\n    AtMeshCorner = 2\n\nclass ConcaveCornerOption(enum.Enum):\n    Unset = 0\n    None_ = 1\n    AtMeshCorner = 2\n\nclass TextureCoordinateOption(enum.Enum):\n    Unset = 0\n    None_ = 1\n    Automatic = 2\n    Packed = 3\n    CopyMapping = 4\n    CopyCoordinates = 5\n\nclass MaximumCounts(enum.Enum):\n    MaximumRecommendedInterpolatedVertexCount = 1000\n\nclass ShrinkDisableSide(enum.Enum):\n    ShrinkAllSides = 0\n    DoNotShrinkWestSide = 1\n    DoNotShrinkSouthSide = 2\n    DoNotShrinkEastSide = 4\n    DoNotShrinkNorthSide = 8\n\nclass Visibility(enum.Enum):\n    Unset = 0\n    Visible = 1\n    Hidden = 2\n    Duplicate = 3\n\nclass Visibility(enum.Enum):\n    Unset = 0\n    Visible = 1\n    Hidden = 2\n    Duplicate = 3\n    Projecting = 4\n    Clipped = 5\n\nclass SideFill(enum.Enum):\n    SideUnset = 0\n    SideSurface = 1\n    SideVoid = 2\n    OtherSurface = 3\n\nclass Attenuation(enum.Enum):\n    Constant = 0\n    Linear = 1\n    InverseSquared = 2\n\nclass Density(enum.Enum):\n    UnsetDensity = 0\n    MinimumDensity = 0\n    ExtraCoarseDensity = 1\n    MinimumUserInterfaceDensity = 1\n    MinimumAdaptiveDensity = 1\n    CoarseDensity = 2\n    MediumDensity = 3\n    DefaultDensity = 4\n    FineDensity = 4\n    MaximumUserInterfaceDensity = 5\n    ExtraFineDensity = 5\n    MaximumDensity = 6\n\nclass NurbsCurveEndConditionType(enum.Enum):\n    Nothing = 0\n    Position = 1\n    Tangency = 2\n    Curvature = 3\n\n# endregion\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}