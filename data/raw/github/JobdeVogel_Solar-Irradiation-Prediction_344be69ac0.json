{
  "source_url": "https://github.com/JobdeVogel/Solar-Irradiation-Prediction/blob/ce25b61727edaaaeb0e965bb821506de01cb0dcc/dataset/load_3dbag/sensors.py",
  "repo": "JobdeVogel/Solar-Irradiation-Prediction",
  "repo_stars": 0,
  "repo_description": "Graduation repository for Master Building Technology",
  "license": "unknown",
  "filepath": "dataset/load_3dbag/sensors.py",
  "instruction": "Sensors",
  "code": "import Rhino.Geometry as rg\nimport System\nimport time\nimport math\nimport helpers\nimport os\nimport sys\nimport numpy as np\nimport open3d as o3d\nfrom parameters.params import _MINIMUM_ANGLE, _MINIMUM_AREA, _WALL_RAY_TOLERANCE, QUAD_ONLY\n\nfrom helpers.mesh import join_meshes, get_face_vertices\n\ndef delete_invalid_sensors(mesh, sensors, normals, minimum_angle = _MINIMUM_ANGLE, minimum_area=_MINIMUM_AREA):\n    \"\"\"_summary_\n\n    Args:\n        mesh (rg.Mesh): mesh to iterate over the faces\n        sensors (list[rg.Point3d]): list of sensors\n        normals (list[rg.Vector3d]): list of normals for the sensors\n        minimum_angle (float, optional): Minimum corner angle for the face. Defaults to _MINIMUM_ANGLE.\n        minimum_area (_type_, optional): _description_. Defaults to _MINIMUM_AREA.\n    \"\"\"\n    \n    # Iterate over the mesh faces\n    for i, face in enumerate(mesh.Faces):\n        \n        # Check if the face is a triangle\n        if face.IsTriangle:\n            # Get the vertices of the face\n            vertices = get_face_vertices(face, mesh)\n            \n            # Generate a triangle from the vertices\n            triangle = rg.Triangle3d(vertices[0], vertices[1], vertices[2])\n            \n            # Find the lowest angle of the triangle\n            min_angle = min([triangle.AngleA, triangle.AngleB, triangle.AngleC])\n            \n            # If the minimum angle is lower than acceptable or the area is lower than acceptable,\n            # set the sensor and normal to a None value\n            if min_angle < minimum_angle:\n                sensors[i] = None\n                normals[i] = None\n            elif triangle.Area < minimum_area:\n                sensors[i] = None\n                normals[i] = None\n\n    return sensors, normals\n\ndef offset_points(points, vectors, offset):\n    \"\"\"Offset points using numpy in the direction of a vector\n\n    Args:\n        points (list[rg.Point3d]): list of points to offset\n        vectors (list[rg.Vector3d]): list of vectors to use for the offset\n        offset (float): distance to offset\n\n    Returns:\n        points (list[rg.Point3d]): list of offsetted points\n    \"\"\"\n    \n    try:\n        # Convert the points and vectors to numpy arrays\n        np_points = np.array([[point.X, point.Y, point.Z] for point in points])\n        np_vectors = np.array([[vector.X, vector.Y, vector.Z] for vector in vectors]) * offset\n        \n        # Offset the points\n        new_points = np_points + np_vectors\n        points = [rg.Point3d(*point) for point in new_points]\n    except:\n        offset_vectors = [rg.Vector3d(vector) * offset for vector in vectors]\n        points = [point + vector for point, vector in zip(points, offset_vectors)]\n    \n    return points\n\ndef is_above_mesh(point, meshes, ray_vector=rg.Vector3d(0,0,-1)):\n    \"\"\"Check if a point is above any of a list of meshes\n\n    Args:\n        point (rg.Point3d): point\n        meshes (list[rg.mesh]): list of meshes\n        ray_vector (rg.Vector3d, optional): Direction to check intersection. Defaults to rg.Vector3d(0,0,-1).\n\n    Returns:\n        bool: True if above any of the meshes\n    \"\"\"\n    ray = rg.Ray3d(point, ray_vector)\n    \n    for mesh in meshes:\n        if rg.Intersect.Intersection.MeshRay(mesh, ray) > 0:\n            return True\n\n    return False\n\ndef roof_ray_intersection(point, roofs, face_height, offset):\n    \"\"\"Check if a point intersects with a list of roofs, based on a maximum distance. If this\n    is the case, offset the point.\n\n    Args:\n        point (rg.Point3d): point\n        roofs (list[rg.Mesh]): list of roof meshes to check\n        face_height (float): height of the face for the corresponding sensorpoint mesh\n        offset (float): distance to offset\n\n    Returns:\n        bool: True if point intersects\n        point (rg.Point3d): offsetted point if offesetted else original point\n    \"\"\"\n    \n    # Generate an upward ray\n    upwards_vector = rg.Vector3d(0,0,1)\n    ray = rg.Ray3d(point, upwards_vector)\n    \n    # Iterate over the roofs\n    for roof in roofs:\n        # Compute the distance between roof and point\n        distance = rg.Intersect.Intersection.MeshRay(roof, ray)\n        \n        # Check if the distance is smaller than half the face height\n        if 0 < distance < 0.5 * face_height:\n            \n            # Offset the point\n            point += upwards_vector * distance + rg.Vector3d(0,0,offset)\n            return True, point \n\n    return False, point\n\ndef wall_ray_intersection(point, normal, walls, grid_size, offset, tolerance=_WALL_RAY_TOLERANCE):\n    \"\"\"Compute the intersection between a point on a wall and a list of wall meshes. If the\n    intersection is close enough, move the point to the intersection + an offset\n\n    Args:\n        point (rg.Point3d): point on a wall\n        normal (rg.Vector3d): normal for the point on the wall\n        walls (list[rg.Mesh]): list of wall meshes\n        grid_size (float): grid size\n        offset (float): offset distance\n        tolerance (f;pat, optional): Intersection tolerance. Defaults to _WALL_RAY_TOLERANCE.\n\n    Returns:\n        success (bool): True if intersection occured\n        point (rg.Point): offsetted point if offesetted else original point\n    \"\"\"\n    \n    # Hrnrtate an upward vector\n    upwards_vector = rg.Vector3f(0,0,1)\n    \n    # Compute the perpendicular vector in relation to the normals\n    left_vector = rg.Vector3f.CrossProduct(normal, upwards_vector)\n    right_vector = -left_vector\n    \n    # Convert the vectors to rays\n    left_ray = rg.Ray3d(point, rg.Vector3d(left_vector))\n    right_ray = rg.Ray3d(point, rg.Vector3d(right_vector))\n    \n    # Store the success value\n    success = False\n    \n    # Iterate over the walls\n    for wall in walls:\n        \n        # Compute the intersections to the left and right\n        left_distance = rg.Intersect.Intersection.MeshRay(wall, left_ray)\n        right_distance = rg.Intersect.Intersection.MeshRay(wall, right_ray)\n        \n        # Check if the intersection is close enough\n        if 0 < left_distance < 0.5 * grid_size - tolerance:\n            if left_distance < right_distance:\n                # Move the point\n                left_vector = rg.Vector3d.Multiply(rg.Vector3d(left_vector), left_distance + offset)\n                point += left_vector\n                success = True\n                break\n        \n        # Check if the intersection is close enough\n        elif 0 < right_distance < 0.5 * grid_size - tolerance:\n            if right_distance < left_distance:\n                # Move the point\n                right_vector = rg.Vector3d.Multiply(rg.Vector3d(right_vector), right_distance + offset)\n                point += right_vector\n                success = True\n                break\n\n    return success, point\n\ndef compute(ground, roofs, walls, building_heights, grid_size, offset, random=False, quad_only=QUAD_ONLY, logger=False):\n    \"\"\"Compute the sensorpoints for building meshes\n\n    Args:\n        ground (rg.Mesh): ground mesh\n        roofs (list[rg.Mesh]): list of roof meshes\n        walls (list[rg.Mesh]): list of wall meshes\n        building_heights (list[float]): list of corresponding building height\n        grid_size (float): grid size\n        offset (float): offset value for the sensorpoints\n        quad_only (bool, optional): Indicate if quad faces should be computed only. Defaults to QUAD_ONLY.\n\n    Returns:\n        sensorpoints (list[rg.Point3d]): sensorpoints\n        normals (list[rg.Vector3d])): normals for the sensorpoints\n    \"\"\"\n    \n    if random:     \n        rhino_mesh = join_meshes([ground, *roofs, *walls])\n        area = rg.AreaMassProperties.Compute(rhino_mesh).Area\n        num_points = int(area)\n        \n        tri_mesh = rhino_mesh.Duplicate()\n        tri_mesh.Faces.ConvertQuadsToTriangles()\n        \n        mesh = tri_mesh        \n  \n        vertices = [[point.X, point.Y, point.Z] for point in mesh.Vertices]\n        faces = [[face[0], face[1], face[2]] for face in mesh.Faces]\n\n        vertices = np.array(vertices).astype(np.float32)\n        faces = np.array(faces).astype(np.int32)\n    \n        # Create Open3D triangle mesh\n        mesh = o3d.geometry.TriangleMesh()\n        mesh.vertices = o3d.utility.Vector3dVector(vertices)\n        mesh.triangles = o3d.utility.Vector3iVector(faces)\n        \n        sensors = np.asarray(mesh.sample_points_poisson_disk(init_factor=2, number_of_points=num_points).points).tolist()\n        sensorpoints = [rg.Point3d(point[0], point[1], point[2]) for point in sensors]\n        \n        faces = [rhino_mesh.ClosestMeshPoint(point, 1).FaceIndex for point in sensorpoints]\n\n        normals = [rhino_mesh.FaceNormals[face] for face in faces]\n        \n        sensorpoints = offset_points(sensorpoints, normals, offset)\n        return sensorpoints, normals\n    \n    # Store the sensorpoints and normals of the sensorpoints            \n    sensorpoints = []\n    normals = []\n    \n    # Compute the centroids and normals for the ground mesh\n    ground_normals = list(ground.FaceNormals)\n    ground_centroids = [ground.Faces.GetFaceCenter(System.Int32(i)) for i in range(ground.Faces.Count)] \n    \n    # Offset the ground centroids\n    ground_centroids = offset_points(ground_centroids, ground_normals, offset)\n    \n    \n    # Delete the invalid sensors for the ground\n    ground_centroids, ground_normals = delete_invalid_sensors(ground, ground_centroids, ground_normals)\n    \n\n    # Compute the centroids and normals for the roof meshes\n    joined_roofs = join_meshes(roofs)\n    roof_normals = joined_roofs.FaceNormals\n    roof_centroids = [joined_roofs.Faces.GetFaceCenter(System.Int32(i)) for i in range(joined_roofs.Faces.Count)]\n    \n    # Offset the roof centroids\n    roof_centroids = offset_points(roof_centroids, roof_normals, offset)\n    \n    # Append the computed centroids to the sensors\n    sensorpoints.extend(ground_centroids)\n    sensorpoints.extend(roof_centroids)\n    \n    # Append the computed centroid normals to the normals\n    normals.extend(ground_normals)\n    normals.extend(roof_normals)\n    \n    # Join the ground and roof into one mesh\n    meshes = [ground] + roofs\n    joined_meshes = join_meshes(meshes)\n    \n    # Join the walls into one mesh\n    joined_walls = join_meshes(walls)\n    \n    # Iterate over all the walls\n    for i, (wall, height) in enumerate(zip(walls, building_heights)):\n        # Compute the face normals for the wall\n        wall.FaceNormals.ComputeFaceNormals()\n        \n        # Get the face centroids for the wall\n        wall_sensors = [wall.Faces.GetFaceCenter(j) for j in range(wall.Faces.Count)]\n        \n        # Offset the face centroids\n        wall_sensors = offset_points(wall_sensors, wall.FaceNormals, offset)\n        \n        # Compute the height of one face\n        face_height = height / int(math.ceil(height / grid_size))    \n        \n        # Iterate over the points and normals in the wall mesh\n        for point, normal in zip(wall_sensors, wall.FaceNormals):\n            \n            # Check if the point is above a horizontal surface\n            if is_above_mesh(point, [joined_meshes]):\n                \n                # If this is the case, add the centroids to sensors and normals to normals\n                sensorpoints.append(point)\n                normals.append(normal)\n              \n            # Check if the sensorpoints are under the corresponding walls' roof (because of splitting error)\n            # Sometimes the ground is not splitted properly so wall points seem to be floating in space\n            elif is_above_mesh(point, [meshes[i+1]], ray_vector=rg.Vector3d(0,0,1)):\n                \n                # If this is the case, add the centroids to sensors and normals to normals\n                sensorpoints.append(point)\n                normals.append(normal)\n            \n            # The centroid is floating under a roof            \n            \n            else:\n                # Try to move the sensorpoint to close roof + offset\n                success, point = roof_ray_intersection(point, [joined_roofs], face_height, offset)\n                \n                if not success:\n                    # Try to move the sensorpoint to close wall + offset\n                    success, point = wall_ray_intersection(point, normal, [joined_walls], grid_size, offset)\n                    \n                    \n                    if not success:\n                        # Set this point and normal value to None, thus it is invalid\n                        point = None\n                        normal = None\n                    \n                # Append the invalid point and normal\n                sensorpoints.append(point)\n                normals.append(normal)\n            \n        \n    # Only compute the sensors for quad faces, skip the triangle faces at the borders of buildings    \n    if quad_only:\n        # Join all the meshes together in one list\n        meshes = [ground] + roofs + walls\n        \n        # Generate a single mesh\n        joined_mesh = rg.Mesh()\n        for mesh in meshes:\n            joined_mesh.Append(mesh)\n        \n        # Generate a single mesh with all horizontal meshes\n        horizontal_mesh = rg.Mesh()\n        for mesh in meshes:\n            horizontal_mesh.Append(mesh)\n        \n        # Store the new sensorpoints and normals\n        new_sensorpoints = []\n        new_normals = []\n        \n        # Iterate over the faces, points and normals\n        for face, point, normal in zip(horizontal_mesh.Faces, sensorpoints, normals):\n            \n            # Check if the face is a triangle face\n            if not face.IsTriangle:\n                # The face is a quad, so add the point and normal to new sensors and normals\n                new_sensorpoints.append(point)\n                new_normals.append(normal)\n            else:\n                # Append a None value, it is a triangle\n                new_sensorpoints.append(None)\n                new_normals.append(None)\n        \n        # Overwrite the sensorpoints and normals\n        sensorpoints = new_sensorpoints\n        normals = new_normals\n    \n    if logger:\n        logger.debug(f\"Computed {len(sensorpoints)} sensorpoints with grid_size {grid_size} and offset {offset}\")\n    return sensorpoints, normals\n\ndef filter_sensors(sensorpoints, normals):\n    \"\"\"Filter points and normals based on None values\n\n    Args:\n        sensorpoints (list): list of rg.Point3d and None values\n        normals (list): list of rg.Vector3d and None values\n\n    Returns:\n        filtered_points (list[rg.Point3d]): filtered points\n        filtered_normals (list[rg.Vector3d]): filtered normals\n        pointmap (list[bool]): list indicating if point was None or not for restoration in postprocessing\n    \"\"\"\n    \n    # Store the results\n    filtered_points = []\n    filtered_normals = []\n    pointmap = []\n\n    # Iterate over points and normals\n    for point, normal in zip(sensorpoints, normals):\n        # Check if the point is None\n        if point is not None:\n            filtered_points.append(point)\n            filtered_normals.append(normal)\n            pointmap.append(True)\n        else:\n            pointmap.append(False)\n    \n    return filtered_points, filtered_normals, pointmap\n    \n    \n    ",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}