{
  "source_url": "https://github.com/jlopezbi/rhinoUnfolder/blob/37abb2c4d2a464e62dbdbb0bde72491dcbfd7343/rhino_unwrapper/transformations.py",
  "repo": "jlopezbi/rhinoUnfolder",
  "repo_stars": 8,
  "repo_description": "unwrap meshes in rhino!",
  "license": "GPL-3.0",
  "filepath": "rhino_unwrapper/transformations.py",
  "instruction": "Transformations",
  "code": "from rhino_helpers import *\nimport rhino_helpers as helper\nimport Rhino.Geometry as geom\nimport visualization \nimport math\n\nreload(visualization)\n\ndef get_mapped_point(point,from_frame,to_frame):\n    did_map, mapped_point = from_frame.plane.RemapToPlaneSpace(point)\n    assert did_map, \"get_mapped_point failed for point {}\".format(point)\n    final_point = to_frame.plane.PointAt(mapped_point.X,mapped_point.Y,mapped_point.Z)\n    return final_point\n\ndef get_frame_on_mesh(mesh_location,myMesh):\n    '''DEPRICATED FUNCTION, moved to mesh methods '''\n    faceIdx,edgeIdx,vertIdx = mesh_location\n    face_edges = myMesh.getFaceEdges(faceIdx)\n    assert (edgeIdx in face_edges), \"edge {} not in face {}\".format(edgeIdx,faceIdx)\n    faceTopoVerts = myMesh.getTVertsForFace(faceIdx)\n    assert(vertIdx in faceTopoVerts), \"prblm in getBasisOnMesh():tVert not in faceTopoVerts \"\n    edgeTVerts = myMesh.getTVertsForEdge(edgeIdx) \n    assert(vertIdx in edgeTVerts), \"prblm in getBasisOnMesh():tVert not part of given edge\"\n    def getOther(vertIdx, edgeTVerts):\n        if(edgeTVerts[0] == vertIdx):\n            return edgeTVerts[1]\n        elif(edgeTVerts[1] == vertIdx):\n            return edgeTVerts[0]\n        else:\n            print \"ERROR: edgeTVerts does not contain vertIdx\"\n            return None\n    pntA = myMesh.get_point_for_tVert(vertIdx)\n    pntB = myMesh.get_point_for_tVert(getOther(vertIdx, edgeTVerts))\n    x = helper.getVectorForPoints(pntA,pntB)\n    normal = geom.Vector3d(myMesh.mesh.FaceNormals.Item[faceIdx])\n    return Frame.create_frame_from_normal_and_x(pntA,normal,x)\n\ndef get_xy_net_frame(pointPair):\n    pntI, pntJ = pointPair\n    o = pntI\n    x = geom.Vector3d(pntJ - pntI)\n    z = geom.Vector3d(0,0,1)\n    return Frame.create_frame_from_vectors(o,x,z)\n\ndef make_xy_frame(point,xVec):\n    '''\n    returns a frame whose normal is in the unit-Z direction\n    projects point to xy plane.\n    '''\n    #TODO: project xVec to xy plane as well\n    x,y,z = point\n    point = geom.Point3d(x,y,0.0)\n    normal = geom.Vector3d(0.0,0.0,1.0)\n    return Frame.create_frame_from_normal_and_x(point,normal,xVec)\n\ndef make_origin_frame():\n    plane = rs.WorldXYPlane()\n    \"\"\"\n    print \"first element of worldXYplane is {}\".format(type(plane[0]))\n    print \"second element of worldXYplane is {}\".format(type(plane[1]))\n    print \"third element of worldXYplane is {}\".format(type(plane[2]))\n    print \"fourth element of worldXYplane is {}\".format(type(plane[3]))\n    \"\"\"\n    return Frame(plane)\n\nclass Frame(object):\n\n    \"\"\"\n    An orthonormal bases: each vector is of unit length\n    and all three vectors are orthogonal to one-another\n    \"\"\"\n    def __init__(self,plane):\n        self.plane = plane #RhinoGeom Plane\n        self.precision = .0000001\n        self._unitize()\n        self._check_unitized()\n        self._check_orthogonal()\n        self.x_color = {'red':(0,250,32,32)} #a,r,g,b,\n        self.y_color = {'green':(0,32,250,32)}\n        self.z_color = {'blue':(0,32,32,250)}\n\n    @classmethod\n    def create_frame_from_vectors(cls,origin,x,y):\n        plane = cls.instantiate_plane(origin,x,y)\n        return cls(plane)\n\n    @classmethod\n    def create_frame_from_normal_and_x(cls,origin,normal,x):\n        '''\n        origin = Rhino.Geometry.Point3d\n        x,normal = Rhino.Geometry.Vector3d\n        '''\n        y = geom.Vector3d.CrossProduct(normal,x)\n        return cls(cls.instantiate_plane(origin,x,y))\n\n    @classmethod\n    def create_frame_from_tuples(cls,origin,x,y):\n        origin = geom.Point3d(origin[0],origin[1],origin[2])\n        x = geom.Vector3d(x[0],x[1],x[2])\n        y = geom.Vector3d(y[0],y[1],y[2])\n        plane = cls.instantiate_plane(origin,x,y)\n        return cls(plane)\n\n    @staticmethod\n    def instantiate_plane(origin,x,y):\n        assert x.IsPerpendicularTo(y), \"vec {} is not perpendicular to {}\".format(x,y)\n        return geom.Plane(origin,x,y)\n\n    def show(self):\n        visualization.drawVector(self.plane.XAxis,self.plane.Origin,self.x_color['red'])\n        visualization.drawVector(self.plane.YAxis,self.plane.Origin,self.y_color['green'])\n        visualization.drawVector(self.plane.ZAxis,self.plane.Origin,self.z_color['blue'])\n\n    def is_equal(self,test_frame):\n        return self.plane.Equals(test_frame.plane)\n\n    def _check_vector3d(self):\n        pass\n\n    def _unitize(self):\n        self.plane.XAxis.Unitize()\n        self.plane.YAxis.Unitize()\n        self.plane.ZAxis.Unitize()\n\n    def _check_orthogonal(self):\n        xy = geom.Vector3d.Multiply(self.plane.XAxis,self.plane.YAxis)\n        assert(math.fabs(xy)< self.precision)\n        yz = geom.Vector3d.Multiply(self.plane.YAxis,self.plane.ZAxis)\n        assert(math.fabs(yz)< self.precision)\n        zx = geom.Vector3d.Multiply(self.plane.ZAxis,self.plane.XAxis)\n        assert(math.fabs(zx)< self.precision)\n\n    def _check_unitized(self):\n        assert(self.plane.XAxis.Length - 1 < .00000001), \"x.Length!~=1\"\n        assert(self.plane.YAxis.Length - 1 < .00000001), \"y.Length!~=1\"\n        assert(self.plane.ZAxis.Length - 1 < .00000001), \"z.Length!~=1\"\n\nif __name__ == \"__main__\":\n    make_origin_frame()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}