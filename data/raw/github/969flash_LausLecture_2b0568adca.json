{
  "source_url": "https://github.com/969flash/LausLecture/blob/004c0a8938bf805b8d70c744ddf5eb911fd4277f/Lecture4/01_parking_design.py",
  "repo": "969flash/LausLecture",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Lecture4/01_parking_design.py",
  "instruction": "자주식 지상 주차장 레이아웃 자동화 스크립트",
  "code": "### 자주식 지상 주차장 레이아웃 자동화 스크립트\n\nfrom operator import ge\nfrom typing import List, Tuple, Any, Optional\nimport Rhino.Geometry as geo\nimport ghpythonlib.components as ghcomp\nimport scriptcontext as sc\n\nimport utils\nimport importlib\n\nimportlib.reload(utils)\n\n\n# Constants\nCELL_WIDTH = 2.5  # meters\nCELL_LENGTH = 5.0  # meters\nROAD_WIDTH = 6.0  # meters\nTOL = 0.01  # 허용 오차\n\n# # 그래스호퍼 인풋을 위한 임시 변수\n# target_region = geo.Curve()\n# entrance_pt = geo.Point3d()\n\n\ndef get_axis_from_region(region: geo.Curve) -> geo.Plane:\n    \"\"\"\n    주차장 영역의 방향성을 파악하기위한 축 생성\n    :param region: 주차장 영역 (PolylineCurve)\n    :return: 축 (Plane)\n    \"\"\"\n    # 모든 변을 기준으로 바운딩 박스를 생성하여 최소 바운딩 박스를 구하여 해당 변을 축으로 설정\n\n    min_bbox = None\n    for segment in utils.explode_curve(region):\n        # segment를 기준으로 regigon의 바운딩 박스를 구함\n        x_vec = segment.TangentAt(0)\n        y_vec = geo.Vector3d(-x_vec.Y, x_vec.X, 0)\n        plane_from_seg = geo.Plane(segment.PointAtStart, x_vec, y_vec)\n        bbox = region.GetBoundingBox(plane_from_seg)\n\n        if min_bbox is None:\n            min_bbox = bbox\n            axis = plane_from_seg\n\n        if min_bbox.Area < bbox.Area:\n            continue\n\n        min_bbox = bbox\n        axis = plane_from_seg\n\n    return axis\n\n\ndef generate_pattern_list(l) -> List[float]:\n    \"\"\"\n    주차장 셀의 패턴 리스트 생성\n    \"\"\"\n    if l < 5:\n        return []\n\n    pattern, pattern_sum = [], 0\n    values = [5, 5, 6]\n    i = 0\n    while pattern_sum + values[i % 3] <= l:\n        val = values[i % 3]\n        pattern.append(val)\n        pattern_sum += val\n        i += 1\n\n    edge = (l - pattern_sum) / 2\n    return [edge] + pattern + [edge]\n\n\ndef get_cells_from_inside_region(region: geo.Curve, axis: geo.Plane) -> List[geo.Curve]:\n    \"\"\"\n    내부 영역에서 셀을 생성\n    :param region: 내부 영역 (PolylineCurve)\n    :return: 셀 리스트 (list of PolylineCurve)\n    \"\"\"\n    bbox_region = utils.get_bounding_box_crv(region, axis)\n    bbox_segs = utils.explode_curve(bbox_region)\n    bbox_segs = sorted(bbox_segs, key=lambda seg: seg.GetLength())\n    short_seg, long_seg = bbox_segs[0], bbox_segs[-1]\n\n    vec = -utils.get_outside_perp_vec_from_pt(short_seg.PointAt(0.5), bbox_region)\n    length_to_move = 0\n    cells = []\n    pattern = generate_pattern_list(long_seg.GetLength())\n    for moved_length in pattern:\n        length_to_move += moved_length\n        seg_for_cell = utils.move_curve(short_seg, vec * length_to_move)\n        if 5 - TOL < moved_length < 5 + TOL:\n            cells += get_cells_from_segement(seg_for_cell, -vec)\n\n    return cells\n\n\ndef get_cells_from_inside(\n    target_region: geo.Curve,\n) -> List[geo.Curve]:\n    \"\"\"\n    내부 영역에서 셀을 생성\n    :param target_region: 전체 영역 (PolylineCurve)\n    :return: 셀 리스트 (list of PolylineCurve)\n    \"\"\"\n\n    # 1. 축 생성\n    axis = get_axis_from_region(target_region)\n\n    # 2. 전체 영역을 CELL_LENGTH + ROAD_WIDTH 만큼 안쪽으로 offset\n    inside_regions = utils.offset_regions_inward(\n        target_region, CELL_LENGTH + ROAD_WIDTH\n    )\n\n    if not inside_regions:\n        return []\n\n    # 3. 내부 영역에서 셀 생성\n    cells = []\n    for region in inside_regions:\n        cells.extend(get_cells_from_inside_region(region, axis))\n\n    # 4. 내부 영역을 벗어난 셀 필터링\n    cells = filter_cells_inside_region(cells, inside_regions)\n\n    return cells\n\n\ndef get_cell_rectangle(\n    base_pt: geo.Point3d,\n    x_vec: geo.Vector3d,\n    y_vec: geo.Vector3d,\n    x_dist: float,\n    y_dist: float,\n) -> geo.PolylineCurve:\n    # 원본 변수가 수정되지 않도록 새 객체 생성하여 사용\n    x_vec = geo.Vector3d(x_vec)\n    y_vec = geo.Vector3d(y_vec)\n    x_vec.Unitize()\n    y_vec.Unitize()\n    pt_b = base_pt + (y_vec * y_dist)\n    pt_c = base_pt + (y_vec * y_dist) + (x_vec * x_dist)\n    pt_d = base_pt + (x_vec * x_dist)\n    return geo.PolylineCurve([base_pt, pt_b, pt_c, pt_d, base_pt])\n\n\ndef get_cells_from_segement(segment: geo.Curve, vec: geo.Vector3d) -> List[geo.Curve]:\n    \"\"\"\n    segment를 기준으로 셀을 생성\n    :param segment: segment (LineCurve)\n    :param vec: Cell의 생성 방향 벡터 (Vector3d)\n    :return: 셀 리스트 (list of PolylineCurve)\n    \"\"\"\n\n    cells = []\n    segment_length = segment.GetLength()\n    num_cells = int(segment_length // (CELL_WIDTH))\n    if num_cells < 1:\n        return cells\n\n    pts_for_cell = utils.get_pt_by_length(segment, CELL_WIDTH, True)\n\n    cell_count = 0\n    for pt in pts_for_cell:\n        if cell_count >= num_cells:\n            break\n        cell = get_cell_rectangle(\n            pt, vec, segment.TangentAtStart, CELL_LENGTH, CELL_WIDTH\n        )\n        cell_count += 1\n        cells.append(cell)\n\n    return cells\n\n\ndef get_cells_from_outside(\n    target_region: geo.Curve,\n    entrance_pt: geo.Point3d,\n) -> List[geo.Curve]:\n    \"\"\"\n    주차 가능 영역의 외각을 둘러싸는 셀을 생성\n    :param target_region: 외부 영역 (PolylineCurve)\n    :return: 셀 리스트 (list of PolylineCurve)\n    \"\"\"\n    # 1. 주차가능 영역의 외부영역을 주차칸의 길이 + 도로폭 만큼 안쪽으로 offset\n    cells = []\n    offset_regions = utils.offset_regions_inward(target_region, CELL_LENGTH)\n\n    # 2. offset된 영역의 세그먼트를 기준으로 셀 생성\n    for offset_region in offset_regions:\n        for segment in utils.explode_curve(offset_region):\n            # segment를 기준으로 배치가능한 최대 셀 개수 측정\n            segment_length = segment.GetLength()\n            num_cells = int(segment_length // (CELL_LENGTH))\n            if num_cells < 1:\n                continue\n            # segment를 기준으로 셀 생성\n            center_pt = segment.PointAt(0.5)\n            cell_vec = utils.get_outside_perp_vec_from_pt(center_pt, offset_region)\n            cells_from_seg = get_cells_from_segement(segment, cell_vec)\n\n            cells.extend(cells_from_seg)\n\n    # 3. 진입로 확보를 위한 셀 필터링\n    cells = filter_cells_at_entrance(cells, entrance_pt, target_region)\n\n    return cells\n\n\ndef filter_cells_at_entrance(\n    cells: List[geo.Curve],\n    entrance_pt: geo.Point3d,\n    target_region: geo.Curve,\n) -> List[geo.Curve]:\n    \"\"\"진입로 확보를 위한 셀 필터링\n    :param cells: 셀 리스트 (list of PolylineCurve)\n    :param entrance_pt: 진입점 (Point3d)\n    :param target_region: 전체 영역 (PolylineCurve)\n    :return: 필터링된 셀 리스트 (list of PolylineCurve)\n    \"\"\"\n    filtered_cells = []\n    for cell in cells:\n        # entrance_pt와의 거리가 2.5M 이하인 셀 제거\n        pt_on_region = target_region.PointAt(target_region.ClosestPoint(entrance_pt)[1])\n        if utils.get_dist_between_pt_and_crv(pt_on_region, cell) > CELL_WIDTH:\n            filtered_cells.append(cell)\n\n    return filtered_cells\n\n\ndef filter_cells_inside_region(\n    cells: List[geo.Curve], inside_regions: List[geo.Curve]\n) -> List[geo.Curve]:\n    \"\"\"내부 영역에 맞게 셀 필터링\n    :param cells: 셀 리스트 (list of PolylineCurve)\n    :param inside_regions: 내부 영역 리스트 (list of PolylineCurve)\n    :return: 필터링된 셀 리스트 (list of PolylineCurve)\n    \"\"\"\n    filtered_cells = []\n    for cell in cells:\n        if any(utils.is_region_inside_region(cell, ir) for ir in inside_regions):\n            filtered_cells.append(cell)\n    return filtered_cells\n\n\n# 1. 외부 영역에서 셀 생성\ncells_from_outside = get_cells_from_outside(target_region, entrance_pt)\n\n# 2. 내부 영역에서 셀 생성\ncells_from_inside = get_cells_from_inside(target_region)\n\n# 최종 셀 리스트 생성\ncells = cells_from_outside + cells_from_inside\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": true
}