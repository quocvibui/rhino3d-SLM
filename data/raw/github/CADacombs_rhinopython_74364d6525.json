{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_NurbsCrv_fitToCrvByTransCPsPerGrevillePs.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_NurbsCrv_fitToCrvByTransCPsPerGrevillePs.py",
  "instruction": "Spb nurbs crv fit to crv by trans cps per greville ps",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n190920, 23-24: Created.\r\n191021: Changed some variable names.\r\n220823, 0908-10: Further development.\r\n221007: Branched script off of another to focus on specific type of control point translation.\r\n\r\nNotes:\r\nGreville points aren't directly translated because any curve tangency is not maintained,\r\nand results are squiggly.\r\n\r\nNo longer applicable for this script: It doesn't seem that Greville points can be adjusted within 1e-12 accuracy, so use a minimum of 1e-11.\r\n\r\nTODO:\r\n    Create alternative control point translation: Move Greville point on a temp curve,\r\n    then adjust just the relative control point on the WIP curve.\r\n\r\n    Upon one test, using a scale weight of 1.5 in createNcWithTransCp_ByGrevClosestPt\r\n    was better than 1.0 or 2.0 or using createNcWithTransCp_CpFromGrevTrans.\r\n    More testing is needed.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\n\r\ndebugHelp = {'gCrv' : None}\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'iPreserveEndCont'; keys.append(key)\r\n    values[key] = 1\r\n    names[key] = 'PreserveEndCContinuity'\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key])\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fResolution'; keys.append(key)\r\n    values[key] = 1e-6\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bReplace'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'DocAction'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Add', 'Replace')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fResolution':\r\n            if cls.riOpts[key].CurrentValue <= 0.0:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < Rhino.RhinoMath.ZeroTolerance:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef knotMultiplicityPattern(nc):\r\n    mp = []\r\n    iK = 0\r\n    while iK < nc.Knots.Count:\r\n        m = nc.Knots.KnotMultiplicity(iK)\r\n        mp.append(m)\r\n        iK += m\r\n    return mp\r\n\r\n\r\ndef getInput(objref_ToMod=None):\r\n    \"\"\"\r\n    Get curve with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n\r\n    if objref_ToMod is None:\r\n        go.SetCommandPrompt(\"Select NURBS curve to modify\")\r\n    else:\r\n        rdObj_ToMod = objref_ToMod.Object()\r\n        edge = objref_ToMod.Edge()\r\n        if edge is None:\r\n            wire = objref_ToMod.Curve()\r\n        else:\r\n            wire = None\r\n        if Opts.values['bDebug']: print(edge, wire)\r\n\r\n        go.SetCommandPrompt(\"Select reference curve\")\r\n\r\n        def customGeometryFilter(rdObj, rgObj, compIdx):\r\n            if rdObj.Id != rdObj_ToMod.Id:\r\n                return True\r\n            if wire and not isinstance(rgObj, rg.BrepEdge):\r\n                return False\r\n            if edge and isinstance(rgObj, rg.BrepEdge):\r\n                if edge.EdgeIndex == rgObj.EdgeIndex:\r\n                    return False\r\n            return True\r\n\r\n        go.SetCustomGeometryFilter(customGeometryFilter)\r\n\r\n\r\n    #go.SubObjectSelect = True\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('iPreserveEndCont')\r\n        addOption('fResolution')\r\n        addOption('bReplace')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        res = go.Get()\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objref = go.Object(0)\r\n\r\n            if objref_ToMod is not None:\r\n                go.Dispose()\r\n                return objref\r\n\r\n\r\n            # Verify that curve to modify is acceptable.\r\n\r\n            nc = go.Object(0).Curve().DuplicateCurve() # In case Curve is a BrepEdge.\r\n            if not isinstance(nc, rg.NurbsCurve):\r\n                print(\"Not a NURBS curve.\")\r\n                nc.Dispose()\r\n                sc.doc.Objects.UnselectAll()\r\n                go.ClearObjects()\r\n                sc.doc.Views.Redraw()\r\n                continue\r\n\r\n            iK = nc.Degree\r\n            if any(m > 1 for m in knotMultiplicityPattern(nc)[1:-1]):\r\n                print(\r\n                    \"NURBS curve has some interior knots with multiplicity > 1.\"\r\n                    \"This is not supported.\")\r\n                nc.Dispose()\r\n                sc.doc.Objects.UnselectAll()\r\n                go.ClearObjects()\r\n                sc.doc.Views.Redraw()\r\n                continue\r\n\r\n            iPreserveEndCont = Opts.values['iPreserveEndCont']\r\n            if iPreserveEndCont >= 0:\r\n                if nc.Points.Count < (2*(iPreserveEndCont + 1) + 1):\r\n                    print(\r\n                        \"NURBS curve has only {} control points.\".format(nc.Points.Count),\r\n                        \"Need at least {} for parametric continuity preservation.\".format(2*(iPreserveEndCont + 1) + 1))\r\n                    nc.Dispose()\r\n                    sc.doc.Objects.UnselectAll()\r\n                    go.ClearObjects()\r\n                    sc.doc.Views.Redraw()\r\n                    continue\r\n\r\n            # All good.\r\n\r\n            go.Dispose()\r\n            return objref\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'iPreserveEndCont'\r\n            Opts.riOpts[key].CurrentValue = int(go.Number())\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef formatDistance(fDistance):\r\n    if fDistance is None: return \"(No deviation provided)\"\r\n    if fDistance < 0.001:\r\n        return \"{:.2e}\".format(fDistance)\r\n    else:\r\n        return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\ndef _createCrvWithTranslatedCp(nc_In, idx, vect):\r\n    nc_Out = nc_In.Duplicate()\r\n    nc_Out.Points.SetPoint(\r\n        idx,\r\n        nc_In.Points[idx].Location + vect,\r\n        nc_In.Points[idx].Weight)\r\n    return nc_Out\r\n\r\n\r\ndef _OLD_CODE():\r\n\r\n    def translateCP_GrevilleToClosestPt(nc_toDeform, iCp, nc_Target, bDebug=False):\r\n        \"\"\"\r\n        returns:\r\n            Success: New NurbsCurve with deviation less than 1e-6.\r\n            Fail: None\r\n        \"\"\"\r\n\r\n        #Rhino.RhinoApp.CommandPrompt = (\r\n        #        sCmdPrompt0 +\r\n        #        \"Searching for adjusted control points with less curve deviation ...\")\r\n\r\n        nc_toReturn = nc_toDeform.Duplicate()\r\n\r\n        fWeight = 1.0#5\r\n\r\n        pt_g0 = nc_toReturn.GrevillePoint(iCp)\r\n        b, t = nc_Target.ClosestPoint(pt_g0)\r\n        pt_Target = nc_Target.PointAt(t)\r\n        dist = pt_Target.DistanceTo(pt_g0)\r\n        if bDebug: sEval='dist'; print(sEval+': ',eval(sEval))\r\n        if dist <= Rhino.RhinoMath.ZeroTolerance:\r\n            return # No change.\r\n        pt_cp_1 = (\r\n            nc_toReturn.Points[iCp].Location +\r\n            fWeight * (pt_Target - pt_g0)\r\n            )\r\n        nc_toReturn.Points.SetPoint(iCp, point=pt_cp_1)\r\n        return nc_toReturn\r\n\r\n\r\n        for i in xrange(100):\r\n            sc.escape_test()\r\n            pt_g0 = nc_toReturn.GrevillePoint(iCp)\r\n            b, t = nc_Target.ClosestPoint(pt_g0)\r\n            pt_Target = nc_Target.PointAt(t)\r\n            dist = pt_Target.DistanceTo(pt_g0)\r\n            if bDebug: sEval='dist'; print(sEval+': ',eval(sEval))\r\n            if dist <= Rhino.RhinoMath.ZeroTolerance:\r\n                if i == 0: return # No change.\r\n                #print(\"{} iterations to adjust CP (index {}).\".format(i, iCp))\r\n                return nc_toReturn\r\n            else:\r\n                pt_cp_1 = (\r\n                    nc_toReturn.Points[iCp].Location +\r\n                    fWeight * (pt_Target - pt_g0)\r\n                    )\r\n                nc_toReturn.Points.SetPoint(iCp, point=pt_cp_1)\r\n        else:\r\n            print('#'*80)\r\n            print(\"100 iterations in createNcWithTransCp_ByGrevClosestPt.  Check this!\")\r\n            print('#'*80)\r\n\r\n        return nc_toReturn\r\n\r\n\r\n\r\n\r\n    #for iCp in range(start, stop):\r\n    #    if bDebug: sEval='iCp'; print(sEval+': ',eval(sEval),)\r\n\r\n    #    nc_Trans = translateCP_GrevilleToClosestPt(\r\n    #        nc_toDeform=nc_WIP,\r\n    #        iCp=iCp,\r\n    #        nc_Target=rgNurbsCrv_forDevComp,\r\n    #        bDebug=bDebug)\r\n\r\n    #    if bDebug:\r\n    #        sEval='nc_Trans'; print(sEval+': ',eval(sEval))\r\n    #        sc.doc.Objects.AddCurve(nc_Trans); sc.doc.Views.Redraw()\r\n    #        #1/0\r\n\r\n    #    if nc_Trans is not None:\r\n    #        # Check deviation.\r\n    #        fDev = getMaximumDeviation(rgNurbsCrv_forDevComp, nc_Trans)\r\n    #        if bDebug: sEval='fDev'; print(sEval+': ',eval(sEval))\r\n    #        if fDev <= (fDev0 + 1e-6):\r\n    #            nc_WIP.Dispose()\r\n    #            nc_WIP = nc_Trans\r\n    #            bWIP_was_adjusted = True\r\n    #            if bDebug:\r\n    #                print(\"Reduced deviation by adjusting control point {}.\".format(iCp))\r\n    #        else:\r\n    #            nc_Trans.Dispose()\r\n    #            if bDebug:\r\n    #                sEval='fDev > fDev0'; print(sEval+': ',eval(sEval))\r\n    #                print(\"Morphing increased the deviation.\")\r\n\r\n\r\n    #iFullAdjLoop += 1\r\n        \r\n    #sc.doc.Objects.AddCurve(nc_WIP); sc.doc.Views.Redraw()#; return\r\n\r\n    pass\r\n\r\n\r\ndef fitCurve(nc_toDeform, nc_forDevComp, **kwargs):\r\n    \"\"\"\r\n    returns:\r\n        Success: New NurbsCurve with deviation less than nc0\r\n        Fail: None\r\n    \"\"\"\r\n\r\n    if not nc_toDeform.IsValid: return\r\n\r\n    if nc_toDeform.Points.Count < 3: return\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    iPreserveEndCont = getOpt('iPreserveEndCont')\r\n    fResolution = getOpt('fResolution')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    if iPreserveEndCont >= 0:\r\n        if nc_toDeform.Points.Count < (2*(iPreserveEndCont + 1) + 1):\r\n            return\r\n\r\n\r\n    def getMaxDev(rgCrvA, rgCrvB):\r\n        rc = rg.Curve.GetDistancesBetweenCurves(\r\n                rgCrvA,\r\n                rgCrvB,\r\n                tolerance=0.1*sc.doc.ModelAbsoluteTolerance)\r\n        if rc[0]:\r\n            return rc[1]\r\n\r\n\r\n    fDev_Start = getMaxDev(nc_forDevComp, nc_toDeform)\r\n    if bDebug: sEval='fDev0'; print(sEval+': ',eval(sEval))\r\n    if fDev_Start is None: return\r\n    #if dev <= fDevTol:\r\n    #    if bDebug: print(\"Deviation is already within tolerance.\")\r\n    #    # Deviation is out of tolerance,\r\n    #    # so capture the previous curve.\r\n    #    break\r\n\r\n    nc_WIP = nc_toDeform.Duplicate() # Keep copy of original because nc_WIP will be modified per iteration.\r\n\r\n    sCmdPrompt0 = Rhino.RhinoApp.CommandPrompt\r\n\r\n\r\n    def calculateGrevilleToClosestPtVector(nc_toDeform, iCp, nc_Target, bDebug=False):\r\n        pt_Gr_In = nc_toDeform.GrevillePoint(iCp)#; sc.doc.Objects.AddPoint(pt_Gr_In)\r\n        b, t = nc_Target.ClosestPoint(pt_Gr_In)\r\n        pt_Target = nc_Target.PointAt(t)#; sc.doc.Objects.AddPoint(pt_Target)\r\n        dist = pt_Target.DistanceTo(pt_Gr_In)\r\n        if bDebug: sEval='dist'; print(sEval+': ',eval(sEval))\r\n        if dist <= max(1e-6, 0.1*sc.doc.ModelAbsoluteTolerance):\r\n            return # No change.\r\n        return pt_Target - pt_Gr_In\r\n\r\n\r\n    iFullAdjLoop = 1\r\n\r\n\r\n    if iPreserveEndCont < 0:\r\n        start_idxCP = 0\r\n        stop_idxCP = nc_WIP.Points.Count\r\n    else:\r\n        start_idxCP = iPreserveEndCont + 1\r\n        stop_idxCP = nc_WIP.Points.Count - iPreserveEndCont -1\r\n\r\n\r\n    ncs_Res = []\r\n    devs = []\r\n\r\n\r\n    while iFullAdjLoop < 1000:\r\n        sc.escape_test()\r\n        if bDebug: sEval='iFullAdjLoop'; print(sEval+': ',eval(sEval))\r\n\r\n        # Calculate control point translations.\r\n        vts_TranslateToward = []\r\n\r\n        for iCp in range(start_idxCP, stop_idxCP):\r\n            vt = calculateGrevilleToClosestPtVector(\r\n                nc_WIP, iCp, nc_forDevComp, bDebug=False)\r\n            vts_TranslateToward.append(vt)\r\n\r\n        if bDebug:\r\n            [print(vt) for vt in vts_TranslateToward]\r\n\r\n        if all(_ is None for _ in vts_TranslateToward):\r\n            print(\"No more control points need to be translated.\")\r\n            break\r\n\r\n        iCt_toTrans = (len(vts_TranslateToward) - vts_TranslateToward.count(None))\r\n        #print(iCt_toTrans)\r\n\r\n        # TODO: Iterate various weight calculations and later choose curve with least deviation.\r\n        # Why does 8.0 sometimes work well (so far)?  Goal is achieved faster than lower values,\r\n        # but 16.0 is too large.\r\n        weight = 2.00 / iCt_toTrans\r\n        #print(weight)\r\n\r\n        # Apply control point translations.\r\n        for j, iCp in enumerate(range(start_idxCP, stop_idxCP)):\r\n            vt = vts_TranslateToward[j]\r\n            if vt is None:\r\n                continue\r\n            vt *= weight\r\n            pt_Start = nc_WIP.Points[iCp].Location\r\n            #sc.doc.Objects.AddLine(rg.Line(pt_Start, span=vt))\r\n            pt_End = pt_Start + vt\r\n            nc_WIP.Points.SetPoint(iCp, point=pt_End)\r\n\r\n        dev = getMaxDev(nc_forDevComp, nc_WIP)\r\n\r\n        #sc.doc.Views.Redraw()\r\n        #return\r\n\r\n        #sc.doc.Objects.AddCurve(nc_WIP); sc.doc.Views.Redraw()\r\n\r\n        ncs_Res.append(nc_WIP.Duplicate())\r\n        devs.append(dev)\r\n\r\n        iFullAdjLoop += 1\r\n\r\n    else:\r\n        print(\"For loop completed.\")\r\n\r\n    print(\"After {} iterations.\".format(iFullAdjLoop))\r\n\r\n    print(\"Latest deviation: {}\".format(formatDistance(devs[-1])))\r\n    min_dev = min(devs)\r\n    print(\"Minimum deviation: {}\".format(formatDistance(min_dev)))\r\n\r\n    count_min_dev = devs.count(min_dev)\r\n    if count_min_dev > 1:\r\n        print(\"Minimum deviation for {} curves.\".format(count_min_dev))\r\n\r\n    idx_Winner = devs.index(min_dev)\r\n\r\n    nc_Out = ncs_Res[idx_Winner].Duplicate()\r\n\r\n    for nc in ncs_Res: nc.Dispose()\r\n    nc_WIP.Dispose()\r\n\r\n    if nc_Out.EpsilonEquals(nc_toDeform, epsilon=fResolution):\r\n        nc_Out.Dispose()\r\n        return\r\n\r\n    return nc_Out\r\n\r\n\r\ndef main():\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    objref_ToMod = getInput()\r\n    if objref_ToMod is None: return\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    objref_Ref = getInput(objref_ToMod)\r\n    if objref_Ref is None: return\r\n\r\n    iPreserveEndCont = Opts.values['iPreserveEndCont']\r\n    fResolution = Opts.values['fResolution']\r\n    bReplace = Opts.values['bReplace']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    edge_A = objref_ToMod.Edge()\r\n    crv_A = objref_ToMod.Curve()\r\n    crv_R = objref_Ref.Curve()\r\n\r\n\r\n    if bDebug:\r\n        Rhino.RhinoApp.ClearCommandHistoryWindow()\r\n\r\n\r\n    Rhino.RhinoApp.CommandPrompt = \"Working ...\"\r\n\r\n    nc_Res = fitCurve(\r\n        crv_A,\r\n        crv_R,\r\n        iPreserveEndCont=iPreserveEndCont,\r\n        fResolution=fResolution,\r\n        bDebug=bDebug)\r\n\r\n\r\n    if nc_Res is None:\r\n        print(\"Curve was not created.\")\r\n        return\r\n\r\n    if edge_A or not bReplace:\r\n        # Only add curve.\r\n        gOut = sc.doc.Objects.AddCurve(nc_Res)\r\n        if gOut == gOut.Empty:\r\n            print(\"Curve could not be added.\")\r\n        return\r\n\r\n    if not sc.doc.Objects.Replace(objref_ToMod, curve=nc_Res):\r\n        print(\"Curve could not be replaced.\")\r\n\r\n    return\r\n\r\n\r\n    rc = getInput_OLD()\r\n    if rc is None: return\r\n    objrefs = rc[0]\r\n\r\n    if Opts.values['bDebug']:\r\n        pass\r\n\r\n    processCurveObjects_OLD(\r\n            rhCrvs0=objrefs,\r\n    )\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n\r\n#    try:\r\n#        main()\r\n#    except ZeroDivisionError as e:\r\n#        print(e)\r\n#    except Exception as e:\r\n#        import traceback\r\n#        print('Traceback: {}'.format(traceback.format_exc()))\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}