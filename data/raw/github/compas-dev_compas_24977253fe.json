{
  "source_url": "https://github.com/compas-dev/compas/blob/HEAD/src/compas_rhino/conversions/meshes.py",
  "repo": "compas-dev/compas",
  "repo_stars": 352,
  "repo_description": "Main library of the COMPAS framework and CAD integrations for Rhino/GH and Blender.",
  "license": "MIT",
  "filepath": "src/compas_rhino/conversions/meshes.py",
  "instruction": "Meshes",
  "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\ntry:\n    from itertools import zip_longest\nexcept ImportError:\n    from itertools import izip_longest as zip_longest  # type: ignore\n\nimport Rhino  # type: ignore\nimport System  # type: ignore\n\nfrom compas.colors import Color\nfrom compas.datastructures import Mesh\nfrom compas.geometry import centroid_polygon\nfrom compas.itertools import pairwise\n\nfrom .geometry import vector_to_compas\n\n\ndef average_color(colors):\n    c = len(colors)\n    r, g, b = zip(*colors)\n    r = sum(r) / c\n    g = sum(g) / c\n    b = sum(b) / c\n    return Color(int(r), int(g), int(b))\n\n\ndef connected_ngon(face, vertices, rmesh):\n    points = [vertices[index] for index in face]\n    centroid = centroid_polygon(points)\n\n    c = rmesh.Vertices.Add(*centroid)\n\n    facets = []\n    for i, j in pairwise(face + face[:1]):\n        facets.append(rmesh.Faces.AddFace(i, j, c))\n\n    ngon = Rhino.Geometry.MeshNgon.Create(face, facets)  # type: ignore\n    rmesh.Ngons.AddNgon(ngon)\n\n\ndef disjoint_ngon(face, vertices, rmesh):\n    points = [vertices[vertex] for vertex in face]\n    centroid = centroid_polygon(points)\n\n    indices = []\n    for point in points:\n        x, y, z = point\n        indices.append(rmesh.Vertices.Add(x, y, z))\n\n    c = rmesh.Vertices.Add(*centroid)\n\n    facets = []\n    for i, j in pairwise(indices + indices[:1]):\n        facets.append(rmesh.Faces.AddFace(i, j, c))\n\n    ngon = Rhino.Geometry.MeshNgon.Create(indices, facets)  # type: ignore\n    rmesh.Ngons.AddNgon(ngon)\n\n\ndef disjoint_face(face, vertices, rmesh):\n    indices = []\n    for index in face:\n        x, y, z = vertices[index]\n        indices.append(rmesh.Vertices.Add(x, y, z))\n    rmesh.Faces.AddFace(*indices)\n\n\n# =============================================================================\n# To Rhino\n# =============================================================================\n\n\ndef mesh_to_rhino(\n    mesh,\n    color=None,\n    vertexcolors=None,\n    facecolors=None,\n    disjoint=True,\n    face_callback=None,\n):\n    \"\"\"Convert a COMPAS Mesh or a Polyhedron to a Rhino mesh object.\n\n    Parameters\n    ----------\n    mesh : :class:`compas.datastructures.Mesh` | :class:`compas.geometry.Polyhedron`\n        A COMPAS Mesh or a Polyhedron.\n    disjoint : bool, optional\n        If ``True``, each face of the resulting mesh will be independently defined (have a copy of its own vertices).\n    face_callback : callable, optional\n        Called after each face is created with the face as an agrument, useful for custom post-processing.\n\n    Returns\n    -------\n    :class:`Rhino.Geometry.Mesh`\n        A Rhino mesh object.\n\n    \"\"\"\n    vertices, faces = mesh.to_vertices_and_faces()\n    return vertices_and_faces_to_rhino(\n        vertices,\n        faces,\n        color=color,\n        vertexcolors=vertexcolors,\n        facecolors=facecolors,\n        disjoint=disjoint,\n        face_callback=face_callback,\n    )\n\n\npolyhedron_to_rhino = mesh_to_rhino\n\n\ndef vertices_and_faces_to_rhino(\n    vertices,\n    faces,\n    color=None,\n    vertexcolors=None,\n    facecolors=None,\n    disjoint=True,\n    face_callback=None,  # type: ignore\n):\n    \"\"\"Convert COMPAS vertices and faces to a Rhino mesh object.\n\n    Parameters\n    ----------\n    vertices : list[[float, float, float] | :class:`compas.geometry.Point`]\n        A list of point locations.\n    faces : list[list[int]]\n        A list of faces as lists of indices into `vertices`.\n    disjoint : bool, optional\n        If ``True``, each face of the resulting mesh will be independently defined (have a copy of its own vertices).\n    face_callback : callable, optional\n        Called after each face is created with the face as an agrument, useful for custom post-processing.\n\n    Returns\n    -------\n    :class:`Rhino.Geometry.Mesh`\n        A Rhino mesh object.\n\n    \"\"\"\n    if disjoint and facecolors:\n        if len(faces) != len(facecolors):\n            raise ValueError(\"The number of face colors does not match the number of faces.\")\n\n    if not disjoint and vertexcolors:\n        if len(vertices) != len(vertexcolors):\n            raise ValueError(\"The number of vertex colors does not match the number of vertices.\")\n\n    mesh = Rhino.Geometry.Mesh()\n\n    if not face_callback:\n\n        def face_callback(face):\n            pass\n\n    if disjoint:\n        vertexcolors = []\n\n        for face, facecolor in zip_longest(faces, facecolors or []):\n            f = len(face)\n\n            if f < 3:\n                continue\n\n            if f > 4:\n                if Rhino.Geometry.MeshNgon is None:\n                    raise NotImplementedError(\"MeshNgons are not supported in this version of Rhino.\")\n\n                disjoint_ngon(face, vertices, mesh)\n                if facecolor:\n                    for _ in range(f + 1):\n                        vertexcolors.append(facecolor)\n\n            else:\n                disjoint_face(face, vertices, mesh)\n                if facecolor:\n                    for _ in range(f):\n                        vertexcolors.append(facecolor)\n\n            face_callback(face)\n\n    else:\n        for x, y, z in vertices:\n            mesh.Vertices.Add(x, y, z)\n\n        for face in faces:\n            f = len(face)\n\n            if f < 3:\n                continue\n\n            if f > 4:\n                if Rhino.Geometry.MeshNgon is None:\n                    raise NotImplementedError(\"MeshNgons are not supported in this version of Rhino.\")\n\n                connected_ngon(face, vertices, mesh)\n                if vertexcolors:\n                    vertexcolors.append(average_color([vertexcolors[index] for index in face]))\n\n            else:\n                mesh.Faces.AddFace(*face)\n\n            face_callback(face)\n\n    if vertexcolors:\n        if len(mesh.Vertices) != len(vertexcolors):\n            raise ValueError(\"The number of vertex colors does not match the number of vertices.\")\n\n        colors = System.Array.CreateInstance(System.Drawing.Color, len(vertexcolors))\n        for index, color in enumerate(vertexcolors):\n            colors[index] = System.Drawing.Color.FromArgb(*color.rgb255)\n\n        mesh.VertexColors.SetColors(colors)\n    else:\n        if color:\n            mesh.VertexColors.CreateMonotoneMesh(System.Drawing.Color.FromArgb(*color.rgb255))\n\n    # mesh.UnifyNormals()\n    mesh.Normals.ComputeNormals()\n    mesh.Compact()\n\n    return mesh\n\n\n# =============================================================================\n# To COMPAS\n# =============================================================================\n\n\ndef mesh_to_compas(rhinomesh, cls=None):\n    \"\"\"Convert a Rhino mesh to a COMPAS mesh.\n\n    Parameters\n    ----------\n    rhinomesh : :class:`Rhino.Geometry.Mesh`\n        A Rhino mesh object.\n    cls: :class:`compas.datastructures.Mesh`, optional\n        The mesh type.\n\n    Returns\n    -------\n    :class:`compas.datastructures.Mesh`\n        A COMPAS mesh.\n\n    \"\"\"\n    cls = cls or Mesh\n    mesh = cls()\n    mesh.update_default_vertex_attributes(normal=None, color=None)\n    mesh.update_default_face_attributes(normal=None)\n\n    vertexcolors = rhinomesh.VertexColors\n    if not vertexcolors:\n        vertexcolors = [None] * rhinomesh.Vertices.Count\n\n    for vertex, normal, color in zip(rhinomesh.Vertices, rhinomesh.Normals, vertexcolors):\n        mesh.add_vertex(\n            x=float(vertex.X),\n            y=float(vertex.Y),\n            z=float(vertex.Z),\n            normal=vector_to_compas(normal),\n            color=Color.from_rgb255(int(color.R), int(color.G), int(color.B)) if color else None,\n        )\n\n    facenormals = rhinomesh.FaceNormals\n    if not facenormals:\n        facenormals = [None] * rhinomesh.Faces.Count\n\n    for face, normal in zip(rhinomesh.Faces, facenormals):\n        if face.IsTriangle:\n            vertices = [face.A, face.B, face.C]\n        else:\n            vertices = [face.A, face.B, face.C, face.D]\n        mesh.add_face(vertices, normal=vector_to_compas(normal) if normal else None)\n\n    for key in rhinomesh.UserDictionary:\n        mesh.attributes[key] = rhinomesh.UserDictionary[key]\n\n    return mesh\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}