{
  "source_url": "https://github.com/BlockResearchGroup/compas_3gs/blob/162cecfbeb8806340a55713ec3a0bce7cc932c89/src/compas_3gs/algorithms/egi.py",
  "repo": "BlockResearchGroup/compas_3gs",
  "repo_stars": 11,
  "repo_description": "3D graphic statics add-on for the COMPAS framework",
  "license": "MIT",
  "filepath": "src/compas_3gs/algorithms/egi.py",
  "instruction": null,
  "code": "from __future__ import absolute_import\nfrom __future__ import print_function\nfrom __future__ import division\n\nimport compas\n\nfrom compas.datastructures import Network\n\nfrom compas.geometry import add_vectors\nfrom compas.geometry import distance_point_point as distance\nfrom compas.geometry import dot_vectors\nfrom compas.geometry import cross_vectors\nfrom compas.geometry import normalize_vector\nfrom compas.geometry import subtract_vectors\n\nfrom compas.datastructures.network.duality import network_node_find_first_neighbor\n\nfrom compas.utilities import geometric_key\n\nfrom compas_3gs.diagrams import EGI\nfrom compas_3gs.diagrams import Cell\n\ntry:\n    from Rhino.Geometry import Arc\n    from Rhino.Geometry import Point3d\n    from Rhino.Geometry import ArcCurve\n    from Rhino.Geometry import Vector3d\n    from Rhino.Geometry import Circle\n    from Rhino.Geometry import Plane\n\n    from Rhino.Geometry.Intersect.Intersection import CurveCurve as CCX\n\nexcept ImportError:\n    compas.raise_if_ironpython()\n\n\n__all__ = ['egi_from_vectors',\n           'cell_from_egi']\n\n\ndef egi_from_vectors(vectordict, origin, tol=0.001):\n    \"\"\"Construct an egi from a set of vectors.\n\n    Parameters\n    ----------\n    vectordict : dict\n        A dectionary of key-vector pairs.\n    origin : list\n        The coordinates of the centroid.\n    tol : float, optional\n        Tolerance for evaluating antipodal.\n\n    Returns\n    -------\n    egi : mesh\n        A mesh object representing the egi.\n\n    Raises\n    ------\n    Exception\n        If there are less than four vectors.\n\n    Notes\n    -----\n    This algorithm is dependent on Rhinoceros objects; the adjacency arcs are implemented using Rhino.Geometry.Arc,\n    and the cross-adjacencies (arc-arc intersections) are computed using Rhino.Geometry.Intersect.Intersection.CurveCurve.\n\n    Warning\n    -------\n    - This algorithm does not address scenarios where multiple parallel (collinear) vectors are present.\n\n    References\n    ----------\n    - Horn, B.K.P. (1984). *Extended Gaussian images*.\n    - Moni, S. (1990, June). *A closed-form solution for the reconstruction\n    of a convex polyhedron from its extended gaussian image.*\n    - Lee, J., T. Van Mele, and P. Block (2018). *Disjointed force polyhedra.*\n\n    \"\"\"\n    if len(vectordict) < 4:\n        raise Exception('Four or more vectors are needed for the construction of egi.')\n\n    egi = Network()\n\n    # --------------------------------------------------------------------------\n    #   1. add vertices from vectors\n    # --------------------------------------------------------------------------\n    vertex_geokeys = {}\n\n    for vkey in vectordict:\n        normal = normalize_vector(vectordict[vkey])\n        vertex_xyz = add_vectors(normal, origin)\n        vertex_geokeys[geometric_key(normal)] = vkey\n        egi.add_vertex(x=vertex_xyz[0],\n                       y=vertex_xyz[1],\n                       z=vertex_xyz[2],\n                       key=vkey,\n                       attr_dict={'type': 'face',\n                                  'normal': normal,\n                                  'nbrs': []})\n\n    # --------------------------------------------------------------------------\n    #   2.  Identify main adjacencies\n    # --------------------------------------------------------------------------\n    vkey_pairs = set()\n\n    for vkey in egi.vertex:\n        v_crs_dict = {}\n\n        for nbr_vkey in egi.vertex:\n\n            if nbr_vkey is not vkey:\n\n                n1 = egi.vertex[vkey]['normal']\n                n2 = egi.vertex[nbr_vkey]['normal']\n\n                # This checks if the normals are opposite ----------------------\n                dot = dot_vectors(n1, n2)\n\n                if dot > 1 - tol:\n                    raise Exception(\"Coincident vectors detected.\")\n\n                elif dot > -1 + tol:\n\n                    this_crs = cross_vectors(n1, n2)\n                    unit_crs = normalize_vector(this_crs)\n\n                    crs_gkey = geometric_key(unit_crs)\n\n                    # Check to see if any other normals are coplanar\n                    if crs_gkey not in v_crs_dict:\n                        v_crs_dict[crs_gkey] = nbr_vkey\n\n                    # If multiple arcs are coplanar, choose the closer one\n                    elif crs_gkey in v_crs_dict:\n                        this_dist = distance(egi.vertex_coordinates(vkey),\n                                             egi.vertex_coordinates(nbr_vkey))\n                        test_dist = distance(egi.vertex_coordinates(vkey),\n                                             egi.vertex_coordinates(v_crs_dict[crs_gkey]))\n                        if this_dist < test_dist:\n                            del v_crs_dict[crs_gkey]\n                            v_crs_dict[crs_gkey] = nbr_vkey\n\n        # Add to overall connectivity dict -------------------------------------\n        for crs_gkey in v_crs_dict:\n            nbr_vkey = v_crs_dict[crs_gkey]\n            pair = frozenset([vkey, nbr_vkey])\n            vkey_pairs.add(pair)\n\n    # --------------------------------------------------------------------------\n    #   3.  Main adjacency arcs\n    # --------------------------------------------------------------------------\n    arcs = {}\n\n    for pair in vkey_pairs:\n        u, v = list(pair)\n        arc = _draw_arc(egi.vertex[u]['normal'],\n                        egi.vertex[v]['normal'],\n                        origin)\n\n        if len(arcs) == 0:\n            arc_key = 0\n        else:\n            arc_key = max(int(x) for x in arcs.keys()) + 1\n        arcs[arc_key] = {'arc': arc,\n                         'vkeys': [u, v],\n                         'end_vkeys': [u, v],\n                         'int_vkeys': {}, }\n\n    # --------------------------------------------------------------------------\n    #   3.  arc intersections --> cross adjacencies\n    # --------------------------------------------------------------------------\n    arc_pairs_seen = set()\n    for arckey_1 in arcs:\n        for arckey_2 in arcs:\n            if arckey_1 != arckey_2:\n                arc_pair = frozenset([arckey_1, arckey_2])\n                if arc_pair not in arc_pairs_seen:\n                    arc_1 = arcs[arckey_1]['arc']\n                    arc_2 = arcs[arckey_2]['arc']\n                    intersection = _curve_curve_intx(arc_1, arc_2)\n                    if intersection:\n                        new_vkey = max(int(vkey) for vkey in egi.vertex.keys()) + 1\n                        new_normal = subtract_vectors(intersection, origin)\n                        new_normal = normalize_vector(new_normal)\n                        new_vertex_geokey = geometric_key(new_normal, precision='3f')\n\n                        # if intersection is not an endpoint -------------------\n                        if new_vertex_geokey not in vertex_geokeys.keys():\n                            vertex_geokeys[new_vertex_geokey] = new_vkey\n                            egi.add_vertex(x=intersection[0],\n                                           y=intersection[1],\n                                           z=intersection[2],\n                                           key=new_vkey,\n                                           attr_dict={'type': 'zero',\n                                                      'normal': new_normal,\n                                                      'magnitude': 0,\n                                                      'nbrs': []})\n                            arcs[arckey_1]['vkeys'].append(new_vkey)\n                            arcs[arckey_2]['vkeys'].append(new_vkey)\n                            arcs[arckey_1]['int_vkeys'][new_vkey] = arckey_2\n                            arcs[arckey_2]['int_vkeys'][new_vkey] = arckey_1\n\n                        # if intersection already exists -----------------------\n                        elif new_vertex_geokey in vertex_geokeys.keys():\n                            vkey = vertex_geokeys[new_vertex_geokey]\n                            if vkey not in arcs[arckey_1]['vkeys']:\n                                arcs[arckey_1]['vkeys'].append(vkey)\n                                arcs[arckey_1]['int_vkeys'][vkey] = arckey_2\n                            if vkey not in arcs[arckey_2]['vkeys']:\n                                arcs[arckey_2]['vkeys'].append(vkey)\n                                arcs[arckey_2]['int_vkeys'][vkey] = arckey_1\n                        arc_pairs_seen.add(arc_pair)\n\n    # --------------------------------------------------------------------------\n    #   5.  Reorder vertices along each arc and add edges to EGI network\n    # --------------------------------------------------------------------------\n    for arckey in arcs:\n        vkeys = arcs[arckey]['vkeys']\n        if len(vkeys) > 2:\n            pt_list = [egi.vertex_coordinates(key) for key in vkeys]\n            arcs[arckey]['vkeys'] = _reorder_pts_on_arc(pt_list,\n                                                        arcs[arckey]['vkeys'],\n                                                        arcs[arckey]['arc'])[1]\n        #     edge_type = 'cross'\n        # else:\n        #     edge_type = 'main'\n        for i in range(len(arcs[arckey]['vkeys']) - 1):\n            vkey_1 = arcs[arckey]['vkeys'][i]\n            vkey_2 = arcs[arckey]['vkeys'][i + 1]\n            egi.vertex[vkey_1]['nbrs'] += [vkey_2]\n            egi.vertex[vkey_2]['nbrs'] += [vkey_1]\n            egi.add_edge(vkey_1, vkey_2)\n\n    # --------------------------------------------------------------------------\n    #   6.  For each vertex, sort nbrs in ccw order\n    # --------------------------------------------------------------------------\n    _egi_sort_v_nbrs(egi)\n\n    # --------------------------------------------------------------------------\n    #   7.  Add EGI Network faces\n    # --------------------------------------------------------------------------\n    egi_mesh = EGI()\n    for vkey in egi.vertex:\n        egi_mesh.vertex[vkey] = egi.vertex[vkey]\n\n    egi_mesh.attributes['name'] = 'egi'\n    egi_mesh.attributes['origin'] = list(origin)\n\n    _egi_find_faces(egi, egi_mesh)\n\n    return egi_mesh\n\n\n# ******************************************************************************\n# ******************************************************************************\n# ******************************************************************************\n#\n#   from egi to unit polyhedron\n#\n# ******************************************************************************\n# ******************************************************************************\n# ******************************************************************************\n\ndef cell_from_egi(egi):\n    \"\"\"Construct a cell from an egi.\n\n    Parameters\n    ----------\n    egi\n        A mesh object representing the egi.\n\n    Returns\n    -------\n    cell\n        A mesh object representing the unit polyhedron.\n\n    \"\"\"\n    cell = Cell()\n    cell.name = 'cell'\n\n    for fkey in egi.face:\n        x, y, z = egi.face_center(fkey)\n        cell.add_vertex(key=fkey, x=x, y=y, z=z)\n\n    for vkey in egi.vertex:\n        cell_face = egi.vertex_faces(vkey, ordered=True)\n        cell.add_face(cell_face[::-1], fkey=vkey)\n\n        cell.facedata[vkey]['type'] = egi.vertex[vkey]['type']\n\n    return cell\n\n\n# ******************************************************************************\n# ******************************************************************************\n# ******************************************************************************\n#\n#   helpers\n#\n# ******************************************************************************\n# ******************************************************************************\n# ******************************************************************************\n\n\ndef _draw_arc(normal_1, normal_2, origin):\n    mid_pt = normalize_vector(add_vectors(normal_1, normal_2))\n    arc = Arc(Point3d(*[sum(axis) for axis in zip(normal_1, origin)]),\n              Point3d(*[sum(axis) for axis in zip(mid_pt, origin)]),\n              Point3d(*[sum(axis) for axis in zip(normal_2, origin)]))\n    arc_as_curve = ArcCurve(arc)\n    return arc_as_curve\n\n\ndef _reorder_pts_on_arc(pt_list, pt_key_list, arc_curve):\n    # all points should be on the arc...\n    dist_list = []\n    sp = arc_curve.PointAtStart\n    for pt in pt_list:\n        dist_list.append(distance(sp, pt))\n    ordered_pt_list = [x for (y, x) in sorted(zip(dist_list, pt_list))]\n    ordered_pt_key_list = [x for (y, x) in sorted(zip(dist_list, pt_key_list))]\n    return ordered_pt_list, ordered_pt_key_list\n\n\ndef _curve_curve_intx(curve_1, curve_2):\n    intersection_tolerance = 0.01\n    overlap_tolerance = 0.0\n    intersection = CCX(curve_1,\n                       curve_2,\n                       intersection_tolerance,\n                       overlap_tolerance)\n    if not intersection:\n        return None\n    for instance in intersection:\n        return instance.PointA\n\n\ndef _egi_sort_v_nbrs(egi):\n    \"\"\" By default, the sorting should be ccw, since the circle is typically drawn\n    ccw around the local plane's z-axis...\n    \"\"\"\n    xyz = dict((key, [attr[_] for _ in 'xyz']) for key, attr in egi.vertices(True))\n    for vkey in egi.vertex:\n        nbrs = egi.vertex[vkey]['nbrs']\n        plane = Plane(Point3d(*xyz[vkey]),\n                      Vector3d(*[axis for axis in egi.vertex[vkey]['normal']]))\n        circle = Circle(plane, 1)\n        p_list = []\n        for nbr_vkey in nbrs:\n            boolean, parameter = ArcCurve(circle).ClosestPoint(Point3d(*xyz[nbr_vkey]))\n            p_list.append(parameter)\n        sorted_nbrs = [key for (param, key) in sorted(zip(p_list, nbrs))]\n        egi.vertex[vkey]['sorted_nbrs'] = sorted_nbrs\n\n\ndef _egi_find_edge_face(u, v, egi):\n    \"\"\" same as duality.algorithms.find_edge_faces... using 'sorted_nbrs' instead\n    \"\"\"\n    cycle = [u]\n    while True:\n        cycle.append(v)\n        nbrs = egi.vertex[v]['sorted_nbrs']\n        nbr = nbrs[nbrs.index(u) - 1]\n        u, v = v, nbr\n        if v == cycle[0]:\n            cycle.append(v)\n            break\n    return cycle\n\n\ndef _egi_find_faces(egi, egi_mesh):\n    \"\"\" Modified, and simplified version of duality.algorithms.find_network_faces...\n    since there are no leaves or open faces in a egi network.\n    \"\"\"\n    egi_mesh.halfedge = {key: {} for key in egi.vertices()}\n    for u, v in egi.edges():\n        egi_mesh.halfedge[u][v] = None\n        egi_mesh.halfedge[v][u] = None\n    u = sorted(egi.vertices(True), key=lambda x: (x[1]['y'], x[1]['x']))[0][0]\n    v = network_node_find_first_neighbor(egi, u)\n\n    egi_mesh.add_face(_egi_find_edge_face(u, v, egi))\n\n    for u, v in egi.edges():\n\n        if egi_mesh.halfedge[u][v] is None:\n\n            egi_mesh.add_face(_egi_find_edge_face(u, v, egi))\n        if egi_mesh.halfedge[v][u] is None:\n            egi_mesh.add_face(_egi_find_edge_face(v, u, egi))\n\n    return egi_mesh\n\n\n# ******************************************************************************\n# ******************************************************************************\n# ******************************************************************************\n#\n#   main\n#\n# ******************************************************************************\n# ******************************************************************************\n# ******************************************************************************\n\n\nif __name__ == '__main__':\n    pass\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}