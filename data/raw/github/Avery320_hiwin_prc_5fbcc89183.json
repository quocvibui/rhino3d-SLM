{
  "source_url": "https://github.com/Avery320/hiwin_prc/blob/9353bee9d53d95b96bf354c28c79c89620e39885/robot/mesh_loader.py",
  "repo": "Avery320/hiwin_prc",
  "repo_stars": 0,
  "repo_description": null,
  "license": "BSD-3-Clause",
  "filepath": "robot/mesh_loader.py",
  "instruction": "mesh_loader.py - 電池01：網格檔案載入器",
  "code": "\"\"\"\nmesh_loader.py - 電池01：網格檔案載入器\n\n功能：\n    從資料夾載入網格檔案（.stl, .obj, .dae 等）到 Grasshopper\n    自動合併同一檔案中的多個 mesh 物件\n    支援快取機制以提升效能\n\n作者：Avery Tsai\n版本：2.0\n日期：2025-10-05\n\"\"\"\n\nimport os\n\ntry:\n    import Rhino\n    import scriptcontext as sc\n    from Rhino.Geometry import Mesh\nexcept ImportError:\n    Rhino = sc = Mesh = None\n\nCACHE_KEY = 'GH_ROBOT_MESH_CACHE'\n\ndef _get_cache():\n    \"\"\"取得快取字典\"\"\"\n    if sc is None:\n        return {}\n    cache = sc.sticky.get(CACHE_KEY)\n    if cache is None:\n        cache = {}\n        sc.sticky[CACHE_KEY] = cache\n    return cache\n\n\ndef clear_cache():\n    \"\"\"清除所有快取\"\"\"\n    if sc:\n        sc.sticky.pop(CACHE_KEY, None)\n\ndef find_mesh_files(dirpath):\n    \"\"\"遞迴搜尋資料夾中的 .stl 檔案\"\"\"\n    if not dirpath or not os.path.isdir(dirpath):\n        return []\n\n    files = []\n    for root, _, filenames in os.walk(dirpath):\n        for fn in filenames:\n            if fn.lower().endswith('.stl'):\n                files.append(os.path.abspath(os.path.join(root, fn)))\n\n    return sorted(files)\n\ndef import_mesh_file(filepath):\n    \"\"\"匯入單一 .stl 檔案並合併所有 mesh\"\"\"\n    if not filepath or not os.path.exists(filepath):\n        return None\n\n    doc = Rhino.RhinoDoc.ActiveDoc\n    if not doc:\n        return None\n\n    cmd = '-_Import \"{}\" _Enter'.format(filepath.replace('\"', '\\\\\"'))\n    prev_redraw = doc.Views.RedrawEnabled\n    doc.Views.RedrawEnabled = False\n\n    try:\n        before_ids = set(obj.Id for obj in doc.Objects)\n        Rhino.RhinoApp.RunScript(cmd, False)\n        after_objs = [obj for obj in doc.Objects if obj.Id not in before_ids]\n\n        # 提取並合併 mesh\n        meshes = []\n        for obj in after_objs:\n            geo = obj.Geometry\n            if isinstance(geo, Mesh):\n                meshes.append(geo.DuplicateMesh())\n            else:\n                try:\n                    brep_meshes = Rhino.Geometry.Mesh.CreateFromBrep(geo)\n                    if brep_meshes:\n                        meshes.extend(brep_meshes)\n                except:\n                    pass\n            doc.Objects.Delete(obj, True)\n\n        # 合併\n        if not meshes:\n            return None\n        if len(meshes) == 1:\n            return meshes[0]\n\n        merged = Mesh()\n        for m in meshes:\n            merged.Append(m)\n        return merged\n\n    finally:\n        doc.Views.RedrawEnabled = prev_redraw\n\ndef load_meshes(dirpath, recursive, extensions, use_cache):\n    \"\"\"批次載入資料夾中的所有 .stl 檔案\"\"\"\n    cache = _get_cache()\n    files = find_mesh_files(dirpath)\n\n    meshes = []\n    paths = []\n\n    for fpath in files:\n        cache_key = ('MESH', fpath, os.path.getmtime(fpath))\n\n        if cache_key in cache:\n            mesh = cache[cache_key].DuplicateMesh()\n        else:\n            mesh = import_mesh_file(fpath)\n            if mesh:\n                cache[cache_key] = mesh.DuplicateMesh()\n\n        if mesh:\n            meshes.append(mesh)\n            paths.append(fpath)\n\n    return meshes, paths\n\ndef load(dirpath, reload=False):\n    \"\"\"載入網格檔案（主要 API）\n\n    自動遞迴搜尋 .stl 檔案，每個檔案會被合併成一個 mesh\n\n    Args:\n        dirpath: 搜尋目錄\n        reload: 強制重新載入，清除快取（預設 False）\n\n    Returns:\n        (meshes, paths): Mesh 物件列表與對應的檔案路徑列表\n    \"\"\"\n    if reload:\n        clear_cache()\n\n    if not dirpath or not os.path.isdir(dirpath):\n        return [], []\n\n    meshes, paths = load_meshes(dirpath, True, \"stl\", not reload)\n    return meshes, paths\n\n\n# 向後相容的別名\nmesh_loader = load\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}