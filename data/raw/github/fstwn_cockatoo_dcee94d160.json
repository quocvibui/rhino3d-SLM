{
  "source_url": "https://github.com/fstwn/cockatoo/blob/d952ac5d2148ec29fba52e8eb75f0f43770c74ca/usrobj_src/Cockatoo_ExtractKnitConstraintsFromTubularMesh.py",
  "repo": "fstwn/cockatoo",
  "repo_stars": 38,
  "repo_description": "Cockatoo is a prototypical open-source software toolkit for generating (3d-)knitting patterns from NURBS surface and mesh geometry directly inside Grasshopper.",
  "license": "MIT",
  "filepath": "usrobj_src/Cockatoo_ExtractKnitConstraintsFromTubularMesh.py",
  "instruction": "Extracts the necessary constraint to create KnitContours for a tubular mesh with\ntwo closed boundaries based  on specified parameters. The constraints consist of\na start, end as well as a  left and...",
  "code": "\"\"\"\nExtracts the necessary constraint to create KnitContours for a tubular mesh with\ntwo closed boundaries based  on specified parameters. The constraints consist of\na start, end as well as a  left and right boundary. Preview shows the start\ncourse in red, the end course in green and the left/right boundaries in blue.\n    Inputs:\n        Mesh: The mesh that should be knit for constraint extraction.\n              {item, mesh}\n        SeamA: Normalized position of the seam on the first closed boundary of\n               the tube. Between 0.0 an 1.0.\n               {item, float}\n        SeamB: Normalized position of the seam on the second closed boundary of\n               the tube. Between 0.0 an 1.0.\n               {item, float}\n        FlipDir: If True, inverts the knitting direction.\n                 {item, bool}\n    Output:\n        KnitConstraint: The KnitConstraint for this mesh for contour\n                        generation.\n                        {item, KnitConstraint}\n    Remarks:\n        Author: Max Eschenbach\n        License: MIT License\n        Version: 200929\n\"\"\"\n\n# PYTHON STANDARD LIBRARY IMPORTS\nfrom __future__ import division\nimport clr\nfrom os import path\n\n# GHPYTHON SDK IMPORTS\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\n# .NET IMPORTS\nfrom System.Collections.Generic import List\n\n# GHENV COMPONENT SETTINGS\nghenv.Component.Name = \"ExtractKnitConstraintsFromTubularMesh\"\nghenv.Component.NickName =\"EKCFTM\"\nghenv.Component.Category = \"Cockatoo\"\nghenv.Component.SubCategory = \"04 Constraints\"\n\n# KANGAROO 2 IMPORT\nk2import = False\ntry:\n    clr.AddReferenceToFile(\"KangarooSolver.dll\")\n    k2import = True\nexcept IOError:\n    pass\nif not k2import:\n    try:\n        clr.AddReferenceToFileAndPath(path.normpath(r\"C:\\Program Files\\Rhino 7\\Plug-ins\\Grasshopper\\Components\\KangarooSolver.dll\"))\n        k2import = True\n    except IOError:\n        pass\nif not k2import:\n    try:\n        clr.AddReferenceToFileAndPath(path.normpath(r\"C:\\Program Files\\Rhino 7 WIP\\Plug-ins\\Grasshopper\\Components\\KangarooSolver.dll\"))\n        k2import = True\n    except IOError:\n        pass\nif not k2import:\n    try:\n        clr.AddReferenceToFileAndPath(path.normpath(r\"C:\\Program Files\\Rhino 6\\Plug-ins\\Grasshopper\\Components\\KangarooSolver.dll\"))\n    except IOError:\n        raise RuntimeError(\"KangarooSolver.dll was not found! please add the \" + \\\n                           \"folder to your module search paths manually!\")\nimport KangarooSolver as ks\n\n# LOCAL MODULE IMPORTS\ntry:\n    from cockatoo import KnitConstraint\n    from cockatoo.utilities import break_polyline\nexcept ImportError as e:\n    errMsg = \"The Cockatoo python module seems to be not correctly \" + \\\n             \"installed! Please make sure the module is in you search \" + \\\n             \"path, see README for instructions!.\"\n    raise ImportError(errMsg)\n\nclass ExtractKnitConstraintsFromTubularMesh(component):\n    \n    def __init__(self):\n        super(ExtractKnitConstraintsFromTubularMesh, self).__init__()\n        self.SC = None\n        self.EC = None\n        self.SB = None\n        self.RB = None\n    \n    def get_ClippingBox(self):\n        return Rhino.Geometry.BoundingBox()\n    \n    def DrawViewportWires(self, args):\n        try:\n            # get display from args\n            display = args.Display\n            \n            if self.SC and self.EC:\n                # diplay colors for start and end in custom display\n                scol = System.Drawing.Color.Red\n                ecol = System.Drawing.Color.Green\n                sbcol = System.Drawing.Color.SkyBlue\n                # add start and end to customdisplay\n                display.DrawCurve(self.SC, scol, 3)\n                display.DrawCurve(self.EC, ecol, 3)\n                display.DrawCurve(self.SB, sbcol, 2)\n                display.DrawCurve(self.RB, sbcol, 2)\n            \n        except Exception, e:\n            System.Windows.Forms.MessageBox.Show(str(e),\n                                                 \"Error while drawing preview!\")\n    \n    def relax_polylines_on_mesh(self, polylines, mesh, kLineLength, kOnMesh, thres, iMax, tol):\n        \"\"\"Relax a bunch of polylines on a mesh as an approach to finding\n        approximate geodesics on meshes.\n        Based on an approach by Anders Holden Deleuran.\"\"\"\n        \n        if iMax == 0:\n            return polylines, 0\n        else:\n            # create the list of goals\n            goals = []\n            for i, pl in enumerate(polylines):\n                # make show goal\n                ghc = Grasshopper.Kernel.Types.GH_Curve(pl.ToPolylineCurve())\n                gow = Grasshopper.Kernel.Types.GH_ObjectWrapper(ghc)\n                goals.append(ks.Goals.Locator(gow))\n                # make anchor goals\n                plpts = pl.ToArray()\n                goals.extend([ks.Goals.Anchor(a, 100000) for a in [plpts[0],\n                                                                   plpts[-1]]])\n                # make spring goals (line length)\n                segs = pl.GetSegments()\n                if len(segs) <= 10:\n                    rml = Grasshopper.Kernel.GH_RuntimeMessageLevel.Remark\n                    self.AddRuntimeMessage(rml, \"Segment count is quite low! \" +\n                            \"You might want to incerease this to find useful \" +\n                            \"geodesics on the mesh.\")\n                for j, seg in enumerate(segs):\n                    goals.append(ks.Goals.Spring(seg.From,\n                                                 seg.To,\n                                                 0.00,\n                                                 kLineLength))\n                # make onmesh goal with all points\n                anchorList = List[Rhino.Geometry.Point3d]()\n                [anchorList.Add(pt) for pt in plpts]\n                goals.append(ks.Goals.OnMesh(anchorList, mesh, kOnMesh))\n            \n            # create physical system and dotnet list for goals\n            ps = ks.PhysicalSystem()\n            goalsList = List[ks.IGoal]()\n            \n            # assign particle indices automagically\n            for g in goals:\n                ps.AssignPIndex(g, tol)\n                goalsList.Add(g)\n            \n            # solve the k2 physical system\n            iterations = 0\n            for i in range(iMax):\n                ps.Step(goalsList, True, 1000)\n                vs = ps.GetvSum()\n                iterations += 1\n                if vs <= thres:\n                    break\n            \n            # get relaxed polylines from output\n            geodesics = []\n            for o in ps.GetOutput(goalsList):\n                if type(o) is Rhino.Geometry.Polyline:\n                    geodesics.append(o)\n                    \n            return geodesics, iterations\n    \n    def discretize_destination_line(self, line, mode, resolution):\n        \"\"\"Discretizes a destination line into a polyline with\n        equally sized segments.\"\"\"\n        \n        if mode == 0:\n            division = round(resolution)\n            if division == 0:\n                division = 1\n        elif mode == 1:\n            division = math.ceil(line.Length / resolution)\n            if division == 0:\n                division = 1\n        \n        line = line.ToNurbsCurve()\n        divT = list(line.DivideByCount(division, True))\n        dPts = [line.PointAt(t) for t in divT]\n        pl = Rhino.Geometry.Polyline(dPts)\n        \n        return pl\n    \n    def RunScript(self, Mesh, SeamA, SeamB, FlipDir, ):\n        \n        # define defaults and sanitize input\n        if SeamA == None:\n            SeamA = 0.5\n        elif SeamA > 1:\n            SeamA = 1.0\n        elif SeamA < 0:\n            SeamA = 0.0\n        \n        if SeamB == None:\n            SeamB = 0.5\n        elif SeamB > 1:\n            SeamB = 1.0\n        elif SeamB < 0:\n            SeamB = 0.0\n        \n        # define empty tree placeholder output\n        NullTree = Grasshopper.DataTree[object]()\n        \n        # catch missing inputs\n        if not Mesh or SeamA == None or SeamB == None:\n            if not Mesh:\n                rml = self.RuntimeMessageLevel.Warning\n                self.AddRuntimeMessage(rml, \"No Mesh input!\")\n            return NullTree\n        \n        # get naked edges of the mesh boundary\n        mesh_boundaries = list(Mesh.GetNakedEdges())\n        if len(mesh_boundaries) > 2:\n            errMsg = \"Meshes with more than two closed \" + \\\n                     \"boundaries are not supported yet!\"\n            rml = self.RuntimeMessageLevel.Warning\n            self.AddRuntimeMessage(rml, errMsg)\n            return Grasshopper.DataTree[object]()\n        \n        mesh_boundary_curves = [pl.ToPolylineCurve() for pl in mesh_boundaries]\n        \n        # set start and end courses\n        if FlipDir:\n            StartCourse = mesh_boundary_curves[1]\n            EndCourse = mesh_boundary_curves[0]\n        else:\n            StartCourse = mesh_boundary_curves[0]\n            EndCourse = mesh_boundary_curves[1]\n        \n        # reparam domains\n        StartCourse.Domain = Rhino.Geometry.Interval(0, 1)\n        EndCourse.Domain = Rhino.Geometry.Interval(0, 1)\n        \n        # set seam\n        StartCourse.ChangeClosedCurveSeam(SeamA)\n        EndCourse.ChangeClosedCurveSeam(SeamB)\n        \n        # create destination line (seam of the knit, if you will)\n        dest_a = StartCourse.PointAtStart\n        dest_b = EndCourse.PointAtStart\n        dest_line = Rhino.Geometry.Line(dest_a, dest_b)\n        dest_line = self.discretize_destination_line(dest_line,\n                                                     0,\n                                                     100)\n        \n        tol = Rhino.RhinoDoc.ActiveDoc.ModelAbsoluteTolerance\n        seam_line = self.relax_polylines_on_mesh(\n                                            [dest_line],\n                                            Mesh,\n                                            10,\n                                            100,\n                                            1e-14,\n                                            1000,\n                                            tol)[0][0].ToPolylineCurve()\n        \n        LeftBoundary = seam_line\n        RightBoundary = seam_line.Duplicate()\n        \n        # set left and right for preview drawing\n        self.SC = StartCourse\n        self.EC = EndCourse\n        self.SB = LeftBoundary\n        self.RB = RightBoundary\n        \n        KC = KnitConstraint(StartCourse,\n                            EndCourse,\n                            [LeftBoundary],\n                            [RightBoundary])\n        \n        # return outputs if you have them; here I try it for you:\n        return KC\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}