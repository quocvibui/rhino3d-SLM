{
  "source_url": "https://github.com/SZU-WenjieHuang/clusting-algorithm-for-complex-facade-surfaces/blob/e2b66d3dfa0f7b5d9a143ab8e9f04a3f12feaf4f/0-3DAR_geometry_tools.py",
  "repo": "SZU-WenjieHuang/clusting-algorithm-for-complex-facade-surfaces",
  "repo_stars": 1,
  "repo_description": "龙门山单体生成算法评估",
  "license": "unknown",
  "filepath": "0-3DAR_geometry_tools.py",
  "instruction": "coding=utf-8",
  "code": "# coding=utf-8\r\nimport rhinoinside\r\nrhinoinside.load()\r\n# import run\r\nimport Rhino.Geometry as rg\r\nimport math\r\n\r\n#from Rhino.Geometry import Curve as rc\r\n#import ghpythonlib.treehelpers as tr\r\n\r\n# XKool_DAR_Rhinocommon 工具集\r\n\"\"\"\r\n曲线差集\r\nrg.Curve.CreateBooleanDifference(curve,curve)\r\n曲线交集\r\nrg.Curve.CreateBooleanIntersection(curve, curve)\r\n曲线并集\r\nrg.Curve.CreateBooleanUnion(curves)\r\n曲线分段\r\nlist(polyline.DuplicateSegments())\r\n曲线节点\r\n[i for i in polyline]\r\n曲线中点\r\nCurve.PointAt(crv.Domain[1]/2)\r\n曲线长度\r\ncrv.Domain[1]\r\n\"\"\"\r\n\r\n\r\ndef to_NurbsCurve(objects):\r\n    \"\"\"\r\n    1 将物体转化为NurbsCurve\r\n    :param objects:\r\n    :return:\r\n    \"\"\"\r\n    if type(objects) is list:\r\n        return [i.ToNurbsCurve() for i in objects]\r\n    if type(objects) is not list:\r\n        return objects.ToNurbsCurve()\r\n\r\n\r\ndef createPlanarBreps(curve):\r\n    \"\"\"\r\n    2 将曲线转化为brep平面\r\n    :param curve:\r\n    :return: brep\r\n    \"\"\"\r\n    return rg.Brep.CreatePlanarBreps(curve)\r\n\r\n\r\ndef join_curves(curves):\r\n    \"\"\"\r\n    3 合并曲线\r\n    当crvs类型为item或者为list且len值等于1时，输出等于输入\r\n    当crvs类型为list时，输出join\r\n    \"\"\"\r\n    if type(curves) is not list or type(curves) is list and len(curves) == 1:\r\n        return curves\r\n    elif type(curves) is list:\r\n        return list(rg.Curve.JoinCurves(curves))\r\n\r\n\r\ndef _offset(curves, dis):\r\n    \"\"\"\r\n    4 易用曲线偏移\r\n    (直角，xy平面，正反向偏移)\r\n    当crvs类型为item或者为list且len值等于1时，输出单线offset\r\n    当crvs类型为list时，输出多线offset\r\n    \"\"\"\r\n    cornerStyle = rg.CurveOffsetCornerStyle(1)\r\n\r\n    if type(curves) is not list:\r\n        return curves.Offset(rg.Plane.WorldXY, dis, 0.001, cornerStyle)[0]\r\n    elif type(curves) is list:\r\n        return [i.Offset(rg.Plane.WorldXY, dis, 0.001, cornerStyle)[0] for i in curves]\r\n\r\n\r\ndef offset(curves, dis, both=False):\r\n    \"\"\"\r\n    5 可双向offset\r\n    curve为闭合图形时，dis正：内偏移；dis负：外偏移\r\n    \"\"\"\r\n    if both is True:\r\n        return [_offset(curves, dis), _offset(curves, -dis)]\r\n    elif both is not True:\r\n        return _offset(curves, dis)\r\n\r\n\r\ndef polyline_to_bar(polyline, dis, planar=False):\r\n    \"\"\"\r\n    6 polyline生成条形几何\r\n    :param polyline:\r\n    :param dis:\r\n    :return:\r\n    \"\"\"\r\n    # 两侧偏移线\r\n    poly1 = offset(polyline, dis, both=True)[0]\r\n    poly2 = offset(polyline, dis, both=True)[1]\r\n    # 当两偏移线均为闭合线时\r\n    if poly1.IsClosed is True and poly2.IsClosed is True:\r\n        if planar is False:\r\n            return [poly1, poly2]\r\n        elif planar is True:\r\n            brep1 = createPlanarBreps(poly1)[0]\r\n            brep2 = createPlanarBreps(poly2)[0]\r\n            return rg.Brep.CreateBooleanDifference(brep1, brep2, 0.001)\r\n    # 当两偏移线不为闭合线时\r\n    else:\r\n        # 短边封口线\r\n        line1 = rg.Polyline([poly1.PointAtStart, poly2.PointAtStart])\r\n        line2 = rg.Polyline([poly1.PointAtEnd, poly2.PointAtEnd])\r\n        # 转化为NurbsCurve\r\n        nurbs_lst = to_NurbsCurve([poly1, poly2, line1, line2])\r\n        if planar is False:\r\n            return join_curves(nurbs_lst)\r\n        elif planar is True:\r\n            join_crv = join_curves(nurbs_lst)\r\n            return rg.Brep.CreatePlanarBreps(join_crv)\r\n\r\n\r\ndef _transformOrientation(curve):\r\n    \"\"\"\r\n    7 单一曲线的方向翻转\r\n    :param curve: 曲线\r\n    :return: 统一方向的曲线\r\n    \"\"\"\r\n    if curve.IsClosed is True:\r\n        if str(curve.ClosedCurveOrientation()) == 'CounterClockwise':\r\n            curve.Reverse()\r\n            return curve\r\n        else:\r\n            return curve\r\n\r\n\r\ndef transformOrientation(curves):\r\n    \"\"\"\r\n    8 曲线的方向统一\r\n    :param curves: 曲线\r\n    :return: 统一方向的曲线\r\n    \"\"\"\r\n    if type(curves) is not list:\r\n        return _transformOrientation(curves)\r\n    elif type(curves) is list:\r\n        return [_transformOrientation(i) for i in curves]\r\n\r\n\r\ndef _choose_intersectionCrvs(crv_goal, crv_others):\r\n    \"\"\"\r\n    9 单一曲线选择曲线集合中相交的图形\r\n    :param crv_goal: 单曲线\r\n    :param crv_others: 曲线集合\r\n    :return: 选出的曲线集合,未选到的曲线集合\r\n    \"\"\"\r\n    itsct_lst = []\r\n    rest_lst = []\r\n    for i in crv_others:\r\n        event = rg.Intersect.Intersection.CurveCurve(crv_goal, i, 0.001, 0.0)\r\n        if event.Count == 0:\r\n            rest_lst.append(i)\r\n            continue\r\n        itsct_lst.append(i)\r\n    return [itsct_lst, rest_lst]\r\n\r\n\r\ndef choose_intersectionCrvs(crv_goals, crv_others):\r\n    \"\"\"\r\n    10 选择曲线中与目标曲线相交的曲线\r\n    :param crv_goals:\r\n    :param crv_others:\r\n    :return:\r\n    \"\"\"\r\n    if type(crv_goals) is not list:\r\n        itsct_lst = _choose_intersectionCrvs(crv_goals, crv_others)[0]\r\n        rest_lst = _choose_intersectionCrvs(crv_goals, crv_others)[1]\r\n        return [itsct_lst, rest_lst]\r\n    elif type(crv_goals) is list:\r\n        crvs_bool = rg.Curve.CreateBooleanUnion(crv_goals)\r\n        itsct_lst = Pytools.flat([_choose_intersectionCrvs(i, crv_others)[0] for i in crvs_bool])\r\n        rest_lst = Pytools.flat([_choose_intersectionCrvs(i, crv_others)[1] for i in crvs_bool])\r\n        return [itsct_lst, rest_lst]\r\n\r\n\r\ndef _multiple_trim(crv_goal, crv_others):\r\n    \"\"\"\r\n    12 单线split多线\r\n    :param crv_goal:\r\n    :param crv_others:\r\n    :return:\r\n    \"\"\"\r\n    # 有动态输入时\r\n    if crv_goal is not None:\r\n        # 求选择线\r\n        choosed_crvs = choose_intersectionCrvs(crv_goal, crv_others)[0]\r\n        # 求剩余线\r\n        rest_crvs = choose_intersectionCrvs(crv_goal, crv_others)[1]\r\n        # 被分者\r\n        split_blocks = []\r\n        # 切割者\r\n        cutter_blocks = []\r\n        for i in choosed_crvs:\r\n            split_blocks.extend(list(rg.Curve.CreateBooleanDifference(i, crv_goal)))\r\n            cutter_blocks.extend(list(rg.Curve.CreateBooleanIntersection(i, crv_goal)))\r\n        # 合并全部曲线\r\n        blocks = rest_crvs[:]\r\n        blocks.extend(split_blocks)\r\n        return [blocks, cutter_blocks]\r\n    # 无动态输入时\r\n    elif crv_goal is None:\r\n        return [crv_others, None]\r\n\r\n\r\ndef multiple_trim(crv_goals, crv_others):\r\n    \"\"\"\r\n    13 多线split并拾取包含的线\r\n    :param crv_goals:\r\n    :param crv_others:\r\n    :return: [0]被打断的线[1]cutter生成的打断线\r\n    \"\"\"\r\n    iter_lst = rg.Curve.CreateBooleanUnion(crv_goals)\r\n    # 储存cutter自身分割出的图形\r\n    cutter_blocks = []\r\n    blocks = crv_others\r\n    for i in iter_lst:\r\n        # 迭代储存被分割图形\r\n        blocks_i = _multiple_trim(i, blocks)[0]\r\n        # 集合储存cutter自身分割出的图形\r\n        cutters_i = _multiple_trim(i, blocks)[1]\r\n        cutter_blocks.extend(cutters_i)\r\n        blocks = blocks_i\r\n    # 在blocks中提取出来crvs\r\n    inCrvs = choose_inCrvs(crv_goals, blocks)[0]\r\n    cutter_blocks = inCrvs + cutter_blocks\r\n    blocks = choose_inCrvs(crv_goals, blocks)[1]\r\n    return [blocks, cutter_blocks]\r\n\r\n\r\ndef find_discontinuities(curve):\r\n    \"\"\"\r\n    14 寻找曲线不连续节点\r\n    :param curve: 单一曲线\r\n    :return: 节点集合\r\n    \"\"\"\r\n    cont = rg.Continuity.G2_locus_continuous\r\n    dom = curve.Domain\r\n    t = dom[0]\r\n    params = []\r\n    if curve.IsClosed:\r\n        pass\r\n    elif not curve.IsClosed:\r\n        params.append(curve.PointAtStart)\r\n    while True:\r\n        rst = curve.GetNextDiscontinuity(cont, t, dom[1])\r\n        if not rst[0]:break\r\n        t = rst[1]\r\n        params.append(curve.PointAt(t))\r\n    return params\r\n\r\n\r\ndef pts_in_closedCrv(pts, crv):\r\n    \"\"\"\r\n    根据多点与单线的关系分类点\r\n    :param pts: 多点\r\n    :param crv: 单曲线\r\n    :return: [0] 在线外的点 [1] 在线内的点 [2] 在线上的点\r\n    \"\"\"\r\n    pts0 = []\r\n    pts1 = []\r\n    pts2 = []\r\n    for i in pts:\r\n        if str(crv.Contains(i)) == \"Outside\":\r\n            pts0.append(i)\r\n        elif str(crv.Contains(i)) == \"Inside\":\r\n            pts1.append(i)\r\n        elif str(crv.Contains(i)) == \"Coincident\":\r\n            pts2.append(i)\r\n    return pts0, pts1, pts2\r\n\r\n\r\ndef pts_in_closedCrvs(pts, curves):\r\n    \"\"\"\r\n    根据多点与多线的关系分类点\r\n    :param pts: 多点\r\n    :param curves: 多曲线\r\n    :return: [0] 在线外的点 [1] 在线内的点 [2] 在线上的点\r\n    \"\"\"\r\n    pts0 = []\r\n    pts1 = []\r\n    pts2 = []\r\n    bool_curves = rg.Curve.CreateBooleanUnion(curves)\r\n    for i in bool_curves:\r\n        pts0.extend(pts_in_closedCrv(pts, i)[0])\r\n        pts1.extend(pts_in_closedCrv(pts, i)[1])\r\n        pts2.extend(pts_in_closedCrv(pts, i)[2])\r\n    return pts0, pts1, pts2\r\n\r\n\r\ndef choose_Crvs(crv_goal, crv_others):\r\n    \"\"\"\r\n    根据曲线和目标曲线的相交与包含关系分类曲线集\r\n    :param crv_goal: 单曲线\r\n    :param crv_others: 多曲线\r\n    :return: [0]在内部的曲线 [1]在外部的曲线 [2]相交的曲线\r\n    \"\"\"\r\n    inCrvs = []\r\n    outCrvs = []\r\n    intersectCrvs = []\r\n    for i in crv_others:\r\n        # 找到轮廓的角点\r\n        pts_corner = find_discontinuities(i)\r\n        # 在线外的点的数量\r\n        count_out = len(pts_in_closedCrv(pts_corner, crv_goal)[0])\r\n        # 在线内的点的数量\r\n        count_in = len(pts_in_closedCrv(pts_corner, crv_goal)[1])\r\n        if count_out == 0:\r\n            # 在线内\r\n            inCrvs.append(i)\r\n        elif count_in == 0:\r\n            # 在线外\r\n            outCrvs.append(i)\r\n        else:\r\n            # 相交\r\n            intersectCrvs.append(i)\r\n    return inCrvs, outCrvs, intersectCrvs\r\n\r\n\r\ndef choose_inCrvs(crv_goals, crv_others):\r\n    \"\"\"\r\n    选择曲线内的点\r\n    :param crv_goals: 多曲线\r\n    :param crv_others: 待筛选的曲线\r\n    :return: 内部的曲线集\r\n    \"\"\"\r\n    if type(crv_goals) is not list:\r\n        return choose_Crvs(crv_goals, crv_others)[0]\r\n    elif type(crv_goals) is list:\r\n        inCrvs_lst = []\r\n        bool_crvs = rg.Curve.CreateBooleanUnion(crv_goals)\r\n        for i in bool_crvs:\r\n            inCrvs = choose_Crvs(i, crv_others)[0]\r\n            inCrvs_lst.extend(inCrvs)\r\n        outCrvs_lst = crvList_difference(crv_others, inCrvs_lst)[1]\r\n        return inCrvs_lst, outCrvs_lst\r\n\r\n\r\ndef dic_midPt_crv(crvs):\r\n    \"\"\"\r\n    建立曲线中点作key的字典\r\n    :param crvs:\r\n    :return:\r\n    \"\"\"\r\n    keys = []\r\n    for i in crvs:\r\n        pt = i.PointAt(i.Domain[1]/2)\r\n        keys.append((round(pt.X, 2), round(pt.Y, 2)))\r\n    dict(zip(keys, crvs))\r\n    return dict(zip(keys, crvs))\r\n\r\n\r\ndef crvList_union(crvlst1, crvlst2):\r\n    \"\"\"\r\n    曲线list的并集（关联：dic_midPt_crv）\r\n    :param crvlst1:\r\n    :param crvlst2:\r\n    :return:并集\r\n    \"\"\"\r\n    # 中点key，曲线value字典\r\n    dic1 = dic_midPt_crv(crvlst1)\r\n    dic2 = dic_midPt_crv(crvlst2)\r\n    # 取key交集\r\n    itsct = list(set(dic1.keys()) & set(dic2.keys()))\r\n    # 取key差集\r\n    differ1 = set(dic1.keys())-set(dic2.keys())\r\n    differ2 = set(dic2.keys())-set(dic1.keys())\r\n    # 取value集\r\n    itsct_crvs = [dic1[i] for i in itsct]\r\n    differ_crv1 = [dic1[i] for i in differ1]\r\n    differ_crv2 = [dic2[i] for i in differ2]\r\n    union_crvs = itsct_crvs+differ_crv1+differ_crv2\r\n    return union_crvs\r\n\r\n\r\ndef crvList_difference(crvlst1, crvlst2):\r\n    \"\"\"\r\n    曲线list的差集（关联：dic_midPt_crv）\r\n    :param crvlst1:\r\n    :param crvlst2:\r\n    :return: [0]差集和[1]crv1被crv2差集[2]crv2被crv1差集\r\n    \"\"\"\r\n    # 中点key，曲线value字典\r\n    dic1 = dic_midPt_crv(crvlst1)\r\n    dic2 = dic_midPt_crv(crvlst2)\r\n    # 取key差集\r\n    differ1 = set(dic1.keys())-set(dic2.keys())\r\n    differ2 = set(dic2.keys())-set(dic1.keys())\r\n    # 取value集\r\n    differ_crv1 = [dic1[i] for i in differ1]\r\n    differ_crv2 = [dic2[i] for i in differ2]\r\n    differ_crvs = differ_crv1 + differ_crv2\r\n    return differ_crvs, differ_crv1, differ_crv2\r\n\r\n\r\ndef crvList_intersection(crvlst1, crvlst2):\r\n    \"\"\"\r\n    曲线list的交集（关联：dic_midPt_crv）\r\n    :param crvlst1:\r\n    :param crvlst2:\r\n    :return: 交集list\r\n    \"\"\"\r\n    # 中点key，曲线value字典\r\n    dic1 = dic_midPt_crv(crvlst1)\r\n    dic2 = dic_midPt_crv(crvlst2)\r\n    # 取key交集\r\n    itsct = list(set(dic1.keys()) & set(dic2.keys()))\r\n    # 取value交集\r\n    itsct_crvs = [dic1[i] for i in itsct]\r\n    return itsct_crvs\r\n\r\n\r\ndef dis_ptToCrv(crv, pt):\r\n    \"\"\"\r\n    测量点与曲线的距离，并求出最近点\r\n    :param crv:\r\n    :param pt:\r\n    :return:\r\n    \"\"\"\r\n    t = rg.Curve.ClosestPoint(crv, pt)[1]\r\n    pt_t = rg.Curve.PointAt(crv, t)\r\n    dis = rg.Point3d.DistanceTo(pt, pt_t)\r\n    return dis, pt_t\r\n\r\n\r\ndef choose_lgest_lines(polys, n=1, rev=True):\r\n    \"\"\"\r\n    寻找最长n边，如果是polyline则优先分解，如果是line则报错\r\n    :param polys: 单polyline或者多条lines\r\n    :param n: 最长的几条边 int\r\n    :param rev: [True]最长边 [False]最短边\r\n    :return: 最值的边\r\n    \"\"\"\r\n    if type(polys) is list:\r\n        polys_lst = sorted(polys, key=lambda x: x.Domain[1], reverse=rev)\r\n        return polys_lst[0:n]\r\n    elif type(polys) is not list:\r\n        polys = list(polys.DuplicateSegments())\r\n        if not len(polys):\r\n            raise Exception(\"输入的curve为line，无法分解及排序\")\r\n        polys_lst = sorted(polys, key=lambda x: x.Domain[1], reverse=rev)\r\n        return polys_lst[0:n]\r\n\r\n\r\ndef choose_nrest_line(polys, pt=None, rev=False):\r\n    \"\"\"\r\n    寻找距离点最近的线，当无输入点时，自动选择最长边\r\n    :param polys:\r\n    :param pt:\r\n    :param rev:\r\n    :return:\r\n    \"\"\"\r\n    # 无输入点\r\n    if pt is None:\r\n        return choose_lgest_lines(polys)\r\n    # 有输入点\r\n    elif pt is not None:\r\n        if type(polys) is list:\r\n            polys_lst = sorted(polys, key=lambda x: dis_ptToCrv(x, pt)[0], reverse=rev)\r\n            return polys_lst[0]\r\n        elif type(polys) is not list:\r\n            polys = list(polys.DuplicateSegments())\r\n            if not len(polys):\r\n                raise Exception(\"输入的curve为line，无法分解及排序\")\r\n            polys_lst = sorted(polys, key=lambda x: dis_ptToCrv(x, pt)[0], reverse=rev)\r\n            return polys_lst[0]\r\n\r\n\r\nclass Pytools:\r\n    @staticmethod\r\n    def flat(lst):\r\n        \"\"\"\r\n         拍平\r\n        :param lst: 列表\r\n        :return: 内部拍平的列表\r\n        \"\"\"\r\n        l = []\r\n        for i in lst:\r\n            if type(i) is list:\r\n                for j in i:\r\n                    l.append(j)\r\n            else:\r\n                l.append(i)\r\n        return l\r\n\r\n    @staticmethod\r\n    def put_in_dict(dic, key, value):\r\n        \"\"\"\r\n        以合并key而非删除重复key的方式建立字典\r\n        :param dic:\r\n        :param key:\r\n        :param value:\r\n        :return:\r\n        \"\"\"\r\n        if key not in dic.keys():\r\n            dic[key] = [value]\r\n        elif key in dic.keys():\r\n            dic.get(key).append(value)\r\n\r\n\r\ndef crv_area(crv):\r\n    \"\"\"\r\n    求闭合平面曲线面积\r\n    :param crv: 闭合平面曲线 : Curve/Polyline/PolylineCurve/Rectangle\r\n    :return: 面积 : float\r\n    \"\"\"\r\n    if type(crv).__name__ == \"PolylineCurve\":\r\n        crv = crv\r\n    else:\r\n        crv = crv.ToNurbsCurve()\r\n    # Exception\r\n    if not crv.IsClosed:\r\n        raise Exception(\"请输入闭合曲线\")\r\n    elif not crv.IsPlanar():\r\n        raise Exception(\"请输入平面曲线\")\r\n    return rg.AreaMassProperties.Compute(crv).Area\r\n\r\n\r\nclass Transformation:\r\n    @staticmethod\r\n    def move(obj, dir, keep=True):\r\n        \"\"\"\r\n        求闭合平面曲线面积\r\n        :param obj: 需要变换的物体\r\n        :param dir: 变换向量 Vector3d\r\n        :param keep: 是否保留原obj，默认True\r\n        :return: 变换后的物体\r\n        \"\"\"\r\n        transformation = rg.Transform.Translation(dir)\r\n\r\n        if keep is True:\r\n            obj.Transform(transformation)\r\n            return obj\r\n\r\n        elif keep is False:\r\n            if hasattr(obj, \"Duplicate\"):\r\n                obj_copied = obj.Duplicate()\r\n                obj_copied.Transform(transformation)\r\n                return obj_copied\r\n            else:\r\n                raise Exception(\"该物体无法被复制，需使用原位变换\")\r\n\r\n    @staticmethod\r\n    def mirror(obj, plane, keep=True):\r\n        \"\"\"\r\n        求闭合平面曲线面积\r\n        :param obj: 需要变换的物体\r\n        :param plane: 镜像平面 Plane\r\n        :param keep: 是否保留原obj，默认True\r\n        :return: 变换后的物体\r\n        \"\"\"\r\n        transformation = rg.Transform.Mirror(plane)\r\n        if keep is True:\r\n            obj.Transform(transformation)\r\n            return obj\r\n        elif keep is False:\r\n            if hasattr(obj, \"Duplicate\"):\r\n                obj_copied = obj.Duplicate()\r\n                obj_copied.Transform(transformation)\r\n                return obj_copied\r\n            else:\r\n                raise Exception(\"该物体无法被复制，需使用原位变换\")\r\n\r\n    @staticmethod\r\n    def scale(obj, scaler, centre, keep=True):\r\n        \"\"\"\r\n        求闭合平面曲线面积\r\n        :param obj: 需要变换的物体\r\n        :param scaler: 缩放比例 float\r\n        :param center: 缩放中心 Point3d\r\n        :param keep: 是否保留原obj，默认True\r\n        :return\r\n        \"\"\"\r\n        transformation = rg.Transform.Scale(centre, scaler)\r\n        if keep is True:\r\n            obj.Transform(transformation)\r\n            return obj\r\n        elif keep is False:\r\n            if hasattr(obj, \"Duplicate\"):\r\n                obj_copied = obj.Duplicate()\r\n                obj_copied.Transform(transformation)\r\n                return obj_copied\r\n            else:\r\n                raise Exception(\"该物体无法被复制，需使用原位变换\")\r\n\r\n    @staticmethod\r\n    def rotate(obj, angle, axis, center, keep=True):\r\n        \"\"\"\r\n        求闭合平面曲线面积\r\n        :param obj: 需要变换的物体\r\n        :param angle: 旋转角度 float\r\n        :param axis: 旋转轴 Vector3d\r\n        :param center: 旋转中心 Point3d\r\n        :param keep: 是否保留原obj，默认True\r\n        :return\r\n        \"\"\"\r\n        angle = (math.pi/180)*angle\r\n        transformation = rg.Transform.Rotation(angle,axis,center)\r\n        #\r\n        if keep is True:\r\n            obj.Transform(transformation)\r\n            return obj\r\n        # 判断物体能否被复制\r\n        elif keep is False:\r\n            if hasattr(obj, \"Duplicate\"):\r\n                obj_copied = obj.Duplicate()\r\n                obj_copied.Transform(transformation)\r\n                return obj_copied\r\n            else:\r\n                raise Exception(\"该物体无法被复制，需使用原位变换\")\r\n\r\n\r\nif __name__ == '__main__':\r\n    pass\r\n\r\n    # a = join_curves(crvs)\r\n    #\r\n    # b = offset(a, 100, both=True)\r\n    # print b\r\n    ##crv1 = polyline_to_bar(join_curves(crvs),100)\r\n    ##crv2 = polyline_to_bar(join_curves(crvs),100)\r\n    # print len(offset(test,100))\r\n    # d = offset(test,100)[0]\r\n    # e = offset(test,100)[1]\r\n    # print type(d)\r\n    # #c = polyline_to_bar(a, 100)\r\n    # a = polyline_to_bar(test, 100, planar=True)\r\n    # 测试test内偏移还是外偏移\r\n    # a = offset(test, 100)\r\n    # for i in test:\r\n    #     print i.ClosedCurveOrientation()\r\n    #a = transformOrientation(tests)\r\n    #b = _offset(tests, 100)\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}