{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_holddown_generator.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_holddown_generator.py",
  "instruction": "Holddown Generator for Grasshopper.",
  "code": "# File: scripts/gh_holddown_generator.py\n\"\"\"Holddown Generator for Grasshopper.\n\nGenerates holddown anchor locations at shear wall ends and panel splice points.\nOutputs both JSON data for documentation and Rhino Point3d objects for\nvisualization and coordination with structural engineers.\n\nKey Features:\n1. Wall End Holddowns\n   - Automatic placement at both ends of each wall\n   - Offset from wall end by half stud width (configurable)\n   - Tracks load-bearing status for structural coordination\n\n2. Panel Splice Holddowns\n   - Optional holddowns at panel boundaries for panelized walls\n   - Supports prefab/offsite construction workflows\n   - Can be disabled via configuration\n\n3. Visualization\n   - Outputs Rhino Point3d objects for display in Grasshopper\n   - Points can be baked for Revit coordination\n   - Color-code by position type (left/right/splice)\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n\nDependencies:\n    - Rhino.Geometry: Point3d creation\n    - Grasshopper: Component framework, DataTree\n    - timber_framing_generator.framing_elements.holddowns: Holddown logic\n\nPerformance Considerations:\n    - Very fast: O(n) where n = number of walls + panels\n    - Minimal memory usage (point objects only)\n    - Suitable for large projects\n\nUsage:\n    1. Connect 'walls_json' from Wall Analyzer component\n    2. Optionally connect 'panels_json' from Panel Decomposer\n    3. Configure offset and splice options via 'config_json'\n    4. Set 'run' to True to execute\n    5. Collect 'holddown_points' for visualization\n    6. Use 'holddowns_json' for documentation\n\nInput Requirements:\n    Walls JSON (walls_json) - str:\n        JSON string from Wall Analyzer with wall geometry data\n        Required: Yes\n        Access: Item\n\n    Panels JSON (panels_json) - str:\n        Optional JSON from Panel Decomposer for panelized walls\n        Required: No\n        Access: Item\n\n    Config JSON (config_json) - str:\n        Optional JSON configuration with:\n        - stud_width: Width of end studs in feet (default 0.125 = 1.5\")\n        - offset_from_end: Distance from wall end (default half stud width)\n        - include_splices: Include panel splice holddowns (default True)\n        Required: No\n        Access: Item\n\n    Run (run) - bool:\n        Boolean to trigger execution\n        Required: Yes\n        Access: Item\n\nOutputs:\n    Holddowns JSON (holddowns_json) - str:\n        JSON string with holddown locations and metadata\n\n    Holddown Points (holddown_points) - Point3d list:\n        Rhino Point3d objects for visualization\n\n    Summary (summary) - str:\n        Count summary of holddown types\n\n    Log (log) - str:\n        Processing log with debug information\n\nTechnical Details:\n    - Points created at bottom plate elevation (base of wall)\n    - U-coordinate offset accounts for stud centerline\n    - Load-bearing flag passed through from wall data\n    - Serialization includes XYZ coordinates for external tools\n\nError Handling:\n    - Invalid JSON returns empty results with error in log\n    - Walls without base_plane use XY coordinates only\n    - Missing panel data falls back to wall-end-only mode\n\nAuthor: Timber Framing Generator\nVersion: 1.0.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\n# Rhino / Grasshopper\nimport Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\n# =============================================================================\n# Module Reload (Development Only)\n# =============================================================================\n\nFORCE_RELOAD = True\n\nif FORCE_RELOAD:\n    modules_to_reload = [key for key in sys.modules.keys()\n                         if 'timber_framing_generator' in key]\n    for mod_name in modules_to_reload:\n        del sys.modules[mod_name]\n\n# =============================================================================\n# Project Imports (after reload)\n# =============================================================================\n\nfrom src.timber_framing_generator.framing_elements.holddowns import (\n    generate_holddown_locations,\n    get_holddown_summary,\n    HolddownPosition,\n)\n\n# Import geometry factory for RhinoCommon points (required for GH output)\nfrom src.timber_framing_generator.utils.geometry_factory import get_factory\n\n# Get factory instance for creating RhinoCommon geometry\n# This is REQUIRED to avoid \"Data conversion failed from Goo to Point\" errors\nRC_FACTORY = get_factory()\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Holddown Generator\"\nCOMPONENT_NICKNAME = \"Holddown\"\nCOMPONENT_MESSAGE = \"v1.0\"\nCOMPONENT_CATEGORY = \"Timber Framing\"\nCOMPONENT_SUBCATEGORY = \"5-Connections\"\n\nDEFAULT_CONFIG = {\n    \"stud_width\": 0.125,  # 1.5 inches in feet\n    \"offset_from_end\": None,  # Will default to half stud width\n    \"include_splices\": True,\n}\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message, level=\"info\"):\n    \"\"\"Log to console and optionally add GH runtime message.\"\"\"\n    print(f\"[{level.upper()}] {message}\")\n\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n\n\ndef log_info(message):\n    \"\"\"Log info message (console only).\"\"\"\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message):\n    \"\"\"Log warning message (console + GH UI).\"\"\"\n    log_message(message, \"warning\")\n\n\ndef log_error(message):\n    \"\"\"Log error message (console + GH UI).\"\"\"\n    log_message(message, \"error\")\n\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\"\"\"\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs\n    inputs = ghenv.Component.Params.Input\n\n    input_config = [\n        (\"Walls JSON\", \"walls_json\", \"JSON string from Wall Analyzer\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Panels JSON\", \"panels_json\", \"Optional JSON from Panel Decomposer\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Config JSON\", \"config_json\", \"Optional configuration JSON\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Run\", \"run\", \"Boolean to trigger execution\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    # Configure outputs (start from index 1)\n    outputs = ghenv.Component.Params.Output\n\n    output_config = [\n        (\"Holddowns JSON\", \"holddowns_json\", \"JSON with holddown location data\"),\n        (\"Holddown Points\", \"holddown_points\", \"Rhino Point3d objects\"),\n        (\"Summary\", \"summary\", \"Count summary\"),\n        (\"Log\", \"log\", \"Processing log\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef validate_inputs(walls_json, run):\n    \"\"\"Validate component inputs.\"\"\"\n    if not run:\n        return False, \"Run is False - component disabled\"\n\n    if walls_json is None or not walls_json.strip():\n        return False, \"walls_json is required\"\n\n    return True, None\n\n\ndef parse_config(config_json):\n    \"\"\"Parse configuration JSON with defaults.\"\"\"\n    config = dict(DEFAULT_CONFIG)\n\n    if config_json and config_json.strip():\n        try:\n            user_config = json.loads(config_json)\n            config.update(user_config)\n            log_info(f\"Applied user config: {list(user_config.keys())}\")\n        except json.JSONDecodeError as e:\n            log_warning(f\"Invalid config_json, using defaults: {e}\")\n\n    # Set offset_from_end default if not specified\n    if config[\"offset_from_end\"] is None:\n        config[\"offset_from_end\"] = config[\"stud_width\"] / 2\n\n    return config\n\n\ndef _extract_xyz(data, default=(0, 0, 0)):\n    \"\"\"Extract x, y, z coordinates from various formats.\n\n    Supports:\n    - Dict format: {\"x\": 1, \"y\": 2, \"z\": 3}\n    - List/tuple format: [1, 2, 3]\n\n    Args:\n        data: Coordinate data in dict or list format\n        default: Default value if extraction fails\n\n    Returns:\n        Tuple (x, y, z) as floats\n    \"\"\"\n    if data is None:\n        return default\n\n    try:\n        if isinstance(data, dict):\n            # Dict format: {\"x\": ..., \"y\": ..., \"z\": ...}\n            return (float(data.get(\"x\", 0)), float(data.get(\"y\", 0)), float(data.get(\"z\", 0)))\n        elif isinstance(data, (list, tuple)) and len(data) >= 3:\n            # List/tuple format: [x, y, z]\n            return (float(data[0]), float(data[1]), float(data[2]))\n    except (TypeError, ValueError, KeyError):\n        pass\n\n    return default\n\n\ndef reconstruct_base_plane(plane_data):\n    \"\"\"Reconstruct Rhino Plane from JSON data.\n\n    Args:\n        plane_data: Dict with origin, x_axis, y_axis (each can be dict or list),\n                    or Plane object, or None\n\n    Returns:\n        rg.Plane or None\n    \"\"\"\n    if plane_data is None:\n        return None\n\n    # Skip non-dict, non-plane values (e.g., 0, empty string, etc.)\n    if not isinstance(plane_data, dict) and not hasattr(plane_data, 'Origin'):\n        log_info(f\"Skipping non-plane data: {type(plane_data).__name__}\")\n        return None\n\n    try:\n        if isinstance(plane_data, dict):\n            # Validate required keys\n            if \"origin\" not in plane_data:\n                log_info(\"Plane data missing 'origin' key, skipping\")\n                return None\n\n            # Extract coordinates - supports both dict and list formats\n            origin = _extract_xyz(plane_data.get(\"origin\"), (0, 0, 0))\n            x_axis = _extract_xyz(plane_data.get(\"x_axis\"), (1, 0, 0))\n            y_axis = _extract_xyz(plane_data.get(\"y_axis\"), (0, 0, 1))\n\n            return rg.Plane(\n                rg.Point3d(origin[0], origin[1], origin[2]),\n                rg.Vector3d(x_axis[0], x_axis[1], x_axis[2]),\n                rg.Vector3d(y_axis[0], y_axis[1], y_axis[2])\n            )\n        elif hasattr(plane_data, 'Origin'):\n            # Already a Plane object\n            return plane_data\n    except Exception as e:\n        log_warning(f\"Failed to reconstruct plane: {e}\")\n\n    return None\n\n\ndef holddown_to_point(holddown):\n    \"\"\"Convert HolddownLocation to Rhino Point3d using RhinoCommonFactory.\n\n    Uses RhinoCommonFactory to create points from the correct assembly\n    (RhinoCommon, not Rhino3dmIO) to avoid \"Data conversion failed from\n    Goo to Point\" errors in Grasshopper.\n\n    Args:\n        holddown: HolddownLocation object\n\n    Returns:\n        rg.Point3d from RhinoCommon assembly, or None\n    \"\"\"\n    point = holddown.point\n\n    if point is None:\n        return None\n\n    try:\n        # Extract coordinates as floats (launders through assembly boundary)\n        if hasattr(point, 'X'):\n            x, y, z = float(point.X), float(point.Y), float(point.Z)\n        elif isinstance(point, (list, tuple)) and len(point) >= 3:\n            x, y, z = float(point[0]), float(point[1]), float(point[2])\n        else:\n            log_warning(f\"Unknown point format: {type(point)}\")\n            return None\n\n        # Use RhinoCommonFactory to create point from correct assembly\n        return RC_FACTORY.create_point3d(x, y, z)\n\n    except Exception as e:\n        log_warning(f\"Failed to convert holddown point: {e}\")\n\n    return None\n\n\ndef process_walls(walls_json, panels_json, config):\n    \"\"\"Process walls and generate holddown locations.\n\n    Args:\n        walls_json: JSON string with wall data\n        panels_json: Optional JSON string with panel data\n        config: Configuration dictionary\n\n    Returns:\n        tuple: (all_holddowns, points_list, summary_text, log_lines)\n    \"\"\"\n    log_lines = []\n    all_holddowns = []\n    all_points = []\n\n    # Parse walls JSON\n    try:\n        walls_data = json.loads(walls_json)\n    except json.JSONDecodeError as e:\n        log_error(f\"Failed to parse walls_json: {e}\")\n        return [], [], \"Error: Invalid JSON\", [f\"JSON parse error: {e}\"]\n\n    # Handle single wall or list\n    if isinstance(walls_data, dict):\n        walls_list = [walls_data]\n    elif isinstance(walls_data, list):\n        walls_list = walls_data\n    else:\n        log_error(\"walls_json must be a dict or list\")\n        return [], [], \"Error: Invalid format\", [\"Invalid walls_json format\"]\n\n    # Parse panels JSON if provided\n    # panels_json structure: [{wall_id, panels: [{id, u_start, u_end, ...}], joints, ...}, ...]\n    panels_by_wall = {}\n    total_panels = 0\n    if panels_json and panels_json.strip():\n        try:\n            panels_data = json.loads(panels_json)\n            # Each item is a wall object containing a 'panels' array\n            if isinstance(panels_data, list):\n                for wall_panel_data in panels_data:\n                    wall_id = str(wall_panel_data.get(\"wall_id\", \"unknown\"))\n                    # Extract the panels array from the wall object\n                    panels_list = wall_panel_data.get(\"panels\", [])\n                    if panels_list:\n                        panels_by_wall[wall_id] = panels_list\n                        total_panels += len(panels_list)\n            log_info(f\"Loaded {total_panels} panels for {len(panels_by_wall)} walls\")\n        except json.JSONDecodeError as e:\n            log_warning(f\"Invalid panels_json, ignoring: {e}\")\n\n    log_info(f\"Processing {len(walls_list)} walls\")\n    log_lines.append(f\"Processing {len(walls_list)} walls\")\n\n    for i, wall_data in enumerate(walls_list):\n        wall_id = str(wall_data.get(\"wall_id\", f\"wall_{i}\"))\n        log_info(f\"Processing wall {wall_id}\")\n\n        try:\n            # Reconstruct base_plane if it's serialized\n            base_plane = wall_data.get(\"base_plane\")\n            if isinstance(base_plane, dict):\n                wall_data[\"base_plane\"] = reconstruct_base_plane(base_plane)\n\n            # Get panels for this wall (if any)\n            wall_panels = panels_by_wall.get(wall_id, None)\n\n            # Generate holddowns\n            holddowns = generate_holddown_locations(\n                wall_data,\n                config=config,\n                panels_data=wall_panels\n            )\n\n            all_holddowns.extend(holddowns)\n\n            # Convert to points\n            for h in holddowns:\n                pt = holddown_to_point(h)\n                if pt is not None:\n                    all_points.append(pt)\n\n            log_lines.append(f\"  Wall {wall_id}: {len(holddowns)} holddowns\")\n\n        except Exception as e:\n            log_warning(f\"Error processing wall {wall_id}: {e}\")\n            log_lines.append(f\"  Wall {wall_id}: ERROR - {e}\")\n            continue\n\n    # Build summary\n    summary_dict = get_holddown_summary(all_holddowns)\n    summary_text = (\n        f\"Total Holddowns: {summary_dict['total_holddowns']}\\n\"\n        f\"Wall End: {summary_dict['wall_end_holddowns']}\\n\"\n        f\"Splice: {summary_dict['splice_holddowns']}\\n\"\n        f\"Load-Bearing: {summary_dict['load_bearing_count']}\"\n    )\n\n    log_info(f\"Total: {len(all_holddowns)} holddowns\")\n\n    return all_holddowns, all_points, summary_text, log_lines\n\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main(walls_json_in, panels_json_in, config_json_in, run_in):\n    \"\"\"Main entry point for the component.\n\n    Args:\n        walls_json_in: JSON string from Wall Analyzer\n        panels_json_in: Optional JSON from Panel Decomposer\n        config_json_in: Optional configuration JSON\n        run_in: Boolean to trigger execution\n    \"\"\"\n    setup_component()\n\n    try:\n        # Use inputs passed as arguments\n        walls_json_input = walls_json_in\n        panels_json_input = panels_json_in\n        config_json_input = config_json_in\n        run_input = run_in\n\n        # Validate inputs\n        is_valid, error_msg = validate_inputs(walls_json_input, run_input)\n        if not is_valid:\n            log_info(error_msg)\n            return \"\", [], error_msg, error_msg\n\n        # Parse configuration\n        config = parse_config(config_json_input)\n\n        # Process walls\n        holddowns, points, summary_text, log_lines = process_walls(\n            walls_json_input, panels_json_input, config\n        )\n\n        # Serialize holddowns to JSON\n        holddowns_dicts = [h.to_dict() for h in holddowns]\n        holddowns_json_output = json.dumps(holddowns_dicts, indent=2)\n\n        log_output = \"\\n\".join(log_lines)\n\n        return holddowns_json_output, points, summary_text, log_output\n\n    except Exception as e:\n        error_msg = f\"Unexpected error: {str(e)}\"\n        log_error(error_msg)\n        print(traceback.format_exc())\n        return \"\", [], error_msg, traceback.format_exc()\n\n\n# =============================================================================\n# Execution\n# =============================================================================\n\n# In GHPython, input variables are injected as globals based on NickName.\n# We access them directly here and pass to main() for clarity.\n# NOTE: After pasting this script, you may need to:\n#   1. Set the correct number of inputs (4) and outputs (4)\n#   2. Right-click each input and rename the NickName to match:\n#      Input 0: walls_json\n#      Input 1: panels_json\n#      Input 2: config_json\n#      Input 3: run\n\ntry:\n    _walls_json = walls_json\nexcept NameError:\n    _walls_json = None\n\ntry:\n    _panels_json = panels_json\nexcept NameError:\n    _panels_json = None\n\ntry:\n    _config_json = config_json\nexcept NameError:\n    _config_json = None\n\ntry:\n    _run = run\nexcept NameError:\n    _run = False\n\nholddowns_json, holddown_points, summary, log = main(\n    _walls_json, _panels_json, _config_json, _run\n)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}