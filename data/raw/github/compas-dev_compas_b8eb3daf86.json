{
  "source_url": "https://github.com/compas-dev/compas/blob/HEAD/src/compas_rhino/drawing.py",
  "repo": "compas-dev/compas",
  "repo_stars": 352,
  "repo_description": "Main library of the COMPAS framework and CAD integrations for Rhino/GH and Blender.",
  "license": "MIT",
  "filepath": "src/compas_rhino/drawing.py",
  "instruction": "Drawing",
  "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom functools import wraps\n\nimport Rhino  # type: ignore\nimport rhinoscriptsyntax as rs  # type: ignore\nimport scriptcontext as sc  # type: ignore\nimport System  # type: ignore\n\nfrom compas.geometry import centroid_polygon\nfrom compas_rhino.conversions import vertices_and_faces_to_rhino\nfrom compas_rhino.layers import clear_current_layer\nfrom compas_rhino.layers import clear_layer\nfrom compas_rhino.layers import create_layers_from_path\n\nfind_object = sc.doc.Objects.Find\nadd_point = sc.doc.Objects.AddPoint\nadd_line = sc.doc.Objects.AddLine\nadd_dot = sc.doc.Objects.AddTextDot\nadd_curve = sc.doc.Objects.AddCurve\nadd_polyline = sc.doc.Objects.AddPolyline\nadd_brep = sc.doc.Objects.AddBrep\nadd_sphere = sc.doc.Objects.AddSphere\nadd_mesh = sc.doc.Objects.AddMesh\nadd_circle = sc.doc.Objects.AddCircle\nadd_surface = sc.doc.Objects.AddSurface\n\nTOL = sc.doc.ModelAbsoluteTolerance\n\ntry:\n    find_layer_by_fullpath = sc.doc.Layers.FindByFullPath\nexcept SystemError:\n    find_layer_by_fullpath = None\n\n\ndef wrap_drawfunc(f):\n    \"\"\"Wraps all ``draw_`` functions with support for recurring keyword arguments.\"\"\"\n\n    @wraps(f)\n    def wrapper(*args, **kwargs):\n        layer = kwargs.get(\"layer\", None)\n        clear = kwargs.get(\"clear\", False)\n        redraw = kwargs.get(\"redraw\", False)\n        if layer:\n            if not rs.IsLayer(layer):\n                create_layers_from_path(layer)\n            previous = rs.CurrentLayer(layer)\n        if clear:\n            if not layer:\n                clear_current_layer()\n            else:\n                clear_layer(layer)\n        rs.EnableRedraw(False)\n        res = f(*args, **kwargs)\n        if redraw:\n            rs.EnableRedraw(True)\n        if layer:\n            rs.CurrentLayer(previous)  # type: ignore\n        return res\n\n    return wrapper\n\n\n@wrap_drawfunc\ndef draw_labels(labels, **kwargs):\n    \"\"\"Draw labels as text dots and optionally set individual font, fontsize, name, layer and color.\n\n    Parameters\n    ----------\n    labels : list[dict]\n        A list of labels dictionaries.\n        See Notes, for more information about the structure of the dict.\n\n    Returns\n    -------\n    list[System.Guid]\n\n    Notes\n    -----\n    A label dict has the following schema:\n\n    .. code-block:: python\n\n        Schema(\n            {\n                \"pos\": And(list, lambda x: len(x) == 3),\n                \"text\": And(str, len),\n                Optional(\"name\", default=\"\"): str,\n                Optional(\"color\", default=None): (lambda x: len(x) == 3 and all(0 <= y <= 255 for y in x)),\n                Optional(\"layer\", default=None): str,\n                Optional(\"fontsize\", default=10): Or(int, float),\n                Optional(\"font\", default=\"Arial Regular\"): str,\n            }\n        )\n\n    \"\"\"\n    guids = []\n    for label in iter(labels):\n        pos = label[\"pos\"]\n        text = label[\"text\"]\n        name = label.get(\"name\", \"\")\n        color = label.get(\"color\", None)\n        layer = label.get(\"layer\")\n        size = label.get(\"fontsize\", 10)\n        font = label.get(\"font\", \"Arial Regular\")\n        dot = Rhino.Geometry.TextDot(str(text), Rhino.Geometry.Point3d(*pos))\n        dot.FontHeight = size\n        dot.FontFace = font\n        guid = add_dot(dot)\n        if not guid:\n            continue\n        obj = find_object(guid)\n        if not obj:\n            continue\n        attr = obj.Attributes\n        if color:\n            attr.ObjectColor = System.Drawing.Color.FromArgb(*color)\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n        else:\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromLayer\n        if layer and find_layer_by_fullpath:\n            index = find_layer_by_fullpath(layer, True)\n            if index >= 0:\n                attr.LayerIndex = index\n        attr.Name = name\n        obj.CommitChanges()\n        guids.append(guid)\n    return guids\n\n\n@wrap_drawfunc\ndef draw_points(points, **kwargs):\n    \"\"\"Draw points and optionally set individual name, layer, and color properties.\n\n    Parameters\n    ----------\n    labels : list[dict]\n        A list of point dictionaries.\n        See Notes, for more information about the structure of the dict.\n\n    Returns\n    -------\n    list[System.Guid]\n\n    Notes\n    -----\n    A point dict has the following schema:\n\n    .. code-block:: python\n\n        Schema(\n            {\n                \"pos\": And(list, lambda x: len(x) == 3),\n                Optional(\"name\", default=\"\"): str,\n                Optional(\"color\", default=None): (lambda x: len(x) == 3 and all(0 <= y <= 255 for y in x)),\n                Optional(\"layer\", default=None): str,\n            }\n        )\n\n    \"\"\"\n    guids = []\n    for p in iter(points):\n        pos = p[\"pos\"]\n        name = p.get(\"name\", \"\")\n        color = p.get(\"color\")\n        layer = p.get(\"layer\")\n        guid = add_point(Rhino.Geometry.Point3d(*pos))\n        if not guid:\n            continue\n        obj = find_object(guid)\n        if not obj:\n            continue\n        attr = obj.Attributes\n        if color:\n            attr.ObjectColor = System.Drawing.Color.FromArgb(*color)\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n        else:\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromLayer\n        if layer and find_layer_by_fullpath:\n            index = find_layer_by_fullpath(layer, True)\n            if index >= 0:\n                attr.LayerIndex = index\n        attr.Name = name\n        obj.CommitChanges()\n        guids.append(guid)\n    return guids\n\n\n@wrap_drawfunc\ndef draw_lines(lines, **kwargs):\n    \"\"\"Draw lines and optionally set individual name, color, arrow, layer, and\n    width properties.\n\n    Parameters\n    ----------\n    labels : list[dict]\n        A list of line dictionaries.\n        See Notes, for more information about the structure of the dict.\n\n    Returns\n    -------\n    list[System.Guid]\n\n    Notes\n    -----\n    A line dict has the following schema:\n\n    .. code-block:: python\n\n        Schema(\n            {\n                \"start\": And(list, lambda x: len(x) == 3),\n                \"end\": And(list, lambda x: len(x) == 3),\n                Optional(\"name\", default=\"\"): str,\n                Optional(\"color\", default=None): (lambda x: len(x) == 3 and all(0 <= y <= 255 for y in x)),\n                Optional(\"layer\", default=None): str,\n                Optional(\"arrow\", default=None): str,\n                Optional(\"width\", default=None): Or(int, float),\n            }\n        )\n\n    \"\"\"\n    guids = []\n    for line in iter(lines):\n        sp = line[\"start\"]\n        ep = line[\"end\"]\n        name = line.get(\"name\", \"\")\n        color = line.get(\"color\")\n        arrow = line.get(\"arrow\")\n        layer = line.get(\"layer\")\n        width = line.get(\"width\")\n        guid = add_line(Rhino.Geometry.Point3d(*sp), Rhino.Geometry.Point3d(*ep))\n        if not guid:\n            continue\n        obj = find_object(guid)\n        if not obj:\n            continue\n        attr = obj.Attributes\n        if color:\n            attr.ObjectColor = System.Drawing.Color.FromArgb(*color)\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n        else:\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromLayer\n        if arrow == \"end\":\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectColorSource.EndArrowhead\n        if arrow == \"start\":\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectColorSource.StartArrowhead\n        if layer and find_layer_by_fullpath:\n            index = find_layer_by_fullpath(layer, True)\n            if index >= 0:\n                attr.LayerIndex = index\n        if width:\n            attr.PlotWeight = width\n            attr.PlotWeightSource = Rhino.DocObjects.ObjectPlotWeightSource.PlotWeightFromObject\n        attr.Name = name\n        obj.CommitChanges()\n        guids.append(guid)\n    return guids\n\n\n@wrap_drawfunc\ndef draw_geodesics(geodesics, **kwargs):\n    \"\"\"Draw geodesic lines on specified surfaces, and optionally set individual\n    name, color, arrow, and layer properties.\n\n    Parameters\n    ----------\n    labels : list[dict]\n        A list of geodesic dictionaries.\n        See Notes, for more information about the structure of the dict.\n\n    Returns\n    -------\n    list[System.Guid]\n\n    Notes\n    -----\n    A geodesic dict has the following schema:\n\n    .. code-block:: python\n\n        Schema(\n            {\n                \"start\": And(list, lambda x: len(x) == 3),\n                \"end\": And(list, lambda x: len(x) == 3),\n                \"srf\": Or(str, System.Guid),\n                Optional(\"name\", default=\"\"): str,\n                Optional(\"color\", default=None): (lambda x: len(x) == 3 and all(0 <= y <= 255 for y in x)),\n                Optional(\"layer\", default=None): str,\n                Optional(\"arrow\", default=None): str,\n            }\n        )\n\n    \"\"\"\n    guids = []\n    for g in iter(geodesics):\n        sp = g[\"start\"]\n        ep = g[\"end\"]\n        srf = g[\"srf\"]\n        name = g.get(\"name\", \"\")\n        color = g.get(\"color\")\n        arrow = g.get(\"arrow\")\n        layer = g.get(\"layer\")\n        # replace this by a proper rhinocommon call\n        guid = rs.ShortPath(srf, Rhino.Geometry.Point3d(*sp), Rhino.Geometry.Point3d(*ep))\n        if not guid:\n            continue\n        obj = find_object(guid)\n        if not obj:\n            continue\n        attr = obj.Attributes\n        if color:\n            attr.ObjectColor = System.Drawing.Color.FromArgb(*color)\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n        else:\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromLayer\n        if arrow == \"end\":\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectColorSource.EndArrowhead\n        if arrow == \"start\":\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectColorSource.StartArrowhead\n        if layer and find_layer_by_fullpath:\n            index = find_layer_by_fullpath(layer, True)\n            if index >= 0:\n                attr.LayerIndex = index\n        attr.Name = name\n        obj.CommitChanges()\n        guids.append(guid)\n    return guids\n\n\n@wrap_drawfunc\ndef draw_polylines(polylines, **kwargs):\n    \"\"\"Draw polylines, and optionally set individual name, color, arrow, and\n    layer properties.\n\n    Parameters\n    ----------\n    labels : list[dict]\n        A list of polyline dictionaries.\n        See Notes, for more information about the structure of the dict.\n\n    Returns\n    -------\n    list[System.Guid]\n\n    Notes\n    -----\n    A polyline dict has the following schema:\n\n    .. code-block:: python\n\n        Schema({\n            'points': And(list, lambda x: all(len(point) == 3 for point in x),\n            Optional('name', default=''): str,\n            Optional('color', default=None): (lambda x: len(x) == 3 and all(0 <= y <= 255 for y in x)),\n            Optional('layer', default=None): str,\n            Optional('arrow', default=None): str\n        })\n\n    \"\"\"\n    guids = []\n    for p in iter(polylines):\n        points = p[\"points\"]\n        name = p.get(\"name\", \"\")\n        color = p.get(\"color\")\n        arrow = p.get(\"arrow\")\n        layer = p.get(\"layer\")\n        poly = Rhino.Geometry.Polyline([Rhino.Geometry.Point3d(*xyz) for xyz in points])\n        poly.DeleteShortSegments(TOL)\n        guid = add_polyline(poly)\n        if not guid:\n            continue\n        obj = find_object(guid)\n        if not obj:\n            continue\n        attr = obj.Attributes\n        if color:\n            attr.ObjectColor = System.Drawing.Color.FromArgb(*color)\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n        else:\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromLayer\n        if arrow == \"end\":\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectColorSource.EndArrowhead\n        if arrow == \"start\":\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectColorSource.StartArrowhead\n        if layer and find_layer_by_fullpath:\n            index = find_layer_by_fullpath(layer, True)\n            if index >= 0:\n                attr.LayerIndex = index\n        attr.Name = name\n        obj.CommitChanges()\n        guids.append(guid)\n    return guids\n\n\n@wrap_drawfunc\ndef draw_breps(faces, u=10, v=10, join=False, **kwargs):\n    \"\"\"Draw polygonal faces as Rhino.Geometry.Breps, and optionally set individual name, color,\n    and layer properties.\n\n    Parameters\n    ----------\n    faces : list[dict]\n        A list of brep dictionaries.\n        See Notes, for more information about the structure of the dict.\n    u : int, optional\n        Number of spans in the U direction.\n    v : int, optional\n        Number of spans in the V direction.\n    join : bool, optional\n        If True, join the individual faces as polysurfaces\n\n    Returns\n    -------\n    list[System.Guid]\n\n    Notes\n    -----\n    A brep dict has the following schema:\n\n    .. code-block:: python\n\n        Schema({\n            'points': And(list, lambda x: len(x) > 3 and all(len(point) == 3 for point in x),\n            Optional('name', default=''): str,\n            Optional('color', default=None): (lambda x: len(x) == 3 and all(0 <= y <= 255 for y in x)),\n            Optional('layer', default=None): str,\n        })\n\n    Examples\n    --------\n    Using a compas Mesh as an example:\n\n    >>> from compas.datastructures import Mesh\n    >>> from compas.geometry import Box, Frame\n    >>> from compas_rhino.utilities import draw_breps\n    >>> box = Box(Frame.worldXY(), 1.0, 2.0, 3.0)\n    >>> mesh = Mesh.from_shape(box)\n\n    Draw convert each mesh face to brep dict schema:\n\n    >>> vertices = mesh.vertices_attributes(\"xyz\")\n    >>> breps = [{\"points\": mesh.face_coordinates(face)} for face in mesh.faces()]\n\n    Draw brep faces as one joined brep.\n\n    >>> guids = draw_breps(breps, join=True)\n\n    \"\"\"\n    breps = []\n    for f in iter(faces):\n        points = f[\"points\"]\n        name = f.get(\"name\", \"\")\n        color = f.get(\"color\")\n        layer = f.get(\"layer\")\n        corners = [Rhino.Geometry.Point3d(*point) for point in points + points[:1]]\n        pcurve = Rhino.Geometry.PolylineCurve(corners)\n        geo = System.Collections.Generic.List[Rhino.Geometry.GeometryBase](1)\n        geo.Add(pcurve)\n        p = len(points)\n        if p == 3:\n            brep = Rhino.Geometry.Brep.CreateFromCornerPoints(\n                Rhino.Geometry.Point3d(*points[0]),\n                Rhino.Geometry.Point3d(*points[1]),\n                Rhino.Geometry.Point3d(*points[2]),\n                TOL,\n            )\n        elif p == 4:\n            brep = Rhino.Geometry.Brep.CreateFromCornerPoints(\n                Rhino.Geometry.Point3d(*points[0]),\n                Rhino.Geometry.Point3d(*points[1]),\n                Rhino.Geometry.Point3d(*points[2]),\n                Rhino.Geometry.Point3d(*points[3]),\n                TOL,\n            )\n        else:\n            brep = Rhino.Geometry.Brep.CreatePatch(geo, u, v, TOL)\n        if brep:\n            breps.append(brep)\n\n    if join:\n        breps = Rhino.Geometry.Brep.JoinRhino.Geometry.Breps(breps, TOL)\n\n    guids = []\n    for brep in breps:\n        guid = add_brep(brep)\n        if not guid:\n            continue\n        obj = find_object(guid)\n        if not obj:\n            continue\n        attr = obj.Attributes\n        if color:\n            attr.ObjectColor = System.Drawing.Color.FromArgb(*color)\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n        else:\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromLayer\n        if layer and find_layer_by_fullpath:\n            index = find_layer_by_fullpath(layer, True)\n            if index >= 0:\n                attr.LayerIndex = index\n        attr.Name = name\n        attr.WireDensity = -1\n        obj.CommitChanges()\n        guids.append(guid)\n    return guids\n\n\n@wrap_drawfunc\ndef draw_cylinders(cylinders, cap=False, **kwargs):\n    \"\"\"Draw cylinders and optionally set individual name, color, and layer properties.\n\n    Parameters\n    ----------\n    cylinders : list[dict]\n        A list of cylinder dictionaries.\n        See Notes, for more information about the structure of the dict.\n    cap : bool, optional\n        If True, add caps.\n\n    Returns\n    -------\n    list[System.Guid]\n\n    Notes\n    -----\n    A cylinder dict has the following schema:\n\n    .. code-block:: python\n\n        Schema(\n            {\n                \"start\": And(list, lambda x: len(x) == 3),\n                \"end\": And(list, lambda x: len(x) == 3),\n                \"radius\": And(Or(int, float), lambda x: x > 0.0),\n                Optional(\"name\", default=\"\"): str,\n                Optional(\"color\", default=None): (lambda x: len(x) == 3 and all(0 <= y <= 255 for y in x)),\n                Optional(\"layer\", default=None): str,\n            }\n        )\n\n    \"\"\"\n    guids = []\n    for c in iter(cylinders):\n        start = c[\"start\"]\n        end = c[\"end\"]\n        radius = c[\"radius\"]\n        name = c.get(\"name\", \"\")\n        color = c.get(\"color\")\n        layer = c.get(\"layer\")\n        if radius < TOL:\n            continue\n        base = Rhino.Geometry.Point3d(*start)\n        normal = Rhino.Geometry.Point3d(*end) - base\n        height = normal.Length\n        if height < TOL:\n            continue\n        plane = Rhino.Geometry.Plane(base, normal)\n        circle = Rhino.Geometry.Circle(plane, radius)\n        cylinder = Rhino.Geometry.Cylinder(circle, height)\n        brep = cylinder.ToRhino.Geometry.Brep(cap, cap)\n        if not brep:\n            continue\n        guid = add_brep(brep)\n        if not guid:\n            continue\n        obj = find_object(guid)\n        if not obj:\n            continue\n        attr = obj.Attributes\n        if color:\n            attr.ObjectColor = System.Drawing.Color.FromArgb(*color)\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n        else:\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromLayer\n        if layer and find_layer_by_fullpath:\n            index = find_layer_by_fullpath(layer, True)\n            if index >= 0:\n                attr.LayerIndex = index\n        attr.Name = name\n        attr.WireDensity = -1\n        obj.CommitChanges()\n        guids.append(guid)\n    return guids\n\n\n@wrap_drawfunc\ndef draw_pipes(pipes, cap=2, fit=1.0, **kwargs):\n    \"\"\"Draw pipes and optionally set individual name, color, and layer properties.\n\n    Parameters\n    ----------\n    pipes : list[dict]\n        A list of pipe dictionaries.\n        See Notes, for more information about the structure of the dict.\n\n    Other Parameters\n    ----------------\n    cap : {0, 1, 2}, optional\n    fit : float, optional\n\n    Returns\n    -------\n    list[System.Guid]\n\n    Notes\n    -----\n    A pipe dict has the following schema:\n\n    .. code-block:: python\n\n        Schema(\n            {\n                \"points\": And(list, lambda x: all(len(y) == 3 for y in x)),\n                \"radius\": And(Or(int, float), lambda x: x > 0.0),\n                Optional(\"name\", default=\"\"): str,\n                Optional(\"color\", default=None): And(lambda x: len(x) == 3, all(0 <= y <= 255 for y in x)),\n                Optional(\"layer\", default=None): str,\n            }\n        )\n\n    \"\"\"\n    guids = []\n    abs_tol = TOL\n    ang_tol = sc.doc.ModelAngleToleranceRadians\n    for p in pipes:\n        points = p[\"points\"]\n        radius = p[\"radius\"]\n        name = p.get(\"name\", \"\")\n        color = p.get(\"color\")\n        layer = p.get(\"layer\")\n        params = [0.0, 1.0]\n        cap = System.Enum.ToObject(Rhino.Geometry.PipeCapMode, cap)\n        if type(radius) in (int, float):\n            radius = [radius] * 2\n        radius = [float(r) for r in radius]\n        rail = Rhino.Geometry.Curve.CreateControlPointRhino.Geometry.Curve([Rhino.Geometry.Point3d(*xyz) for xyz in points])\n        breps = Rhino.Geometry.Brep.CreatePipe(rail, params, radius, 1, cap, fit, abs_tol, ang_tol)\n        temp = [add_brep(brep) for brep in breps]\n        for guid in temp:\n            if not guid:\n                continue\n            obj = find_object(guid)\n            if not obj:\n                continue\n            attr = obj.Attributes\n            if color:\n                attr.ObjectColor = System.Drawing.Color.FromArgb(*color)\n                attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n            else:\n                attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromLayer\n            if layer and find_layer_by_fullpath:\n                index = find_layer_by_fullpath(layer, True)\n                if index >= 0:\n                    attr.LayerIndex = index\n            attr.Name = name\n            attr.WireDensity = -1\n            obj.CommitChanges()\n            guids.append(guid)\n    return guids\n\n\n@wrap_drawfunc\ndef draw_spheres(spheres, **kwargs):\n    \"\"\"Draw spheres and optionally set individual name, color, and layer properties.\n\n    Parameters\n    ----------\n    spheres : list[dict]\n        A list of sphere dictionaries.\n        See Notes, for more information about the structure of the dict.\n\n    Returns\n    -------\n    list[System.Guid]\n\n    Notes\n    -----\n    A sphere dict has the following schema:\n\n    .. code-block:: python\n\n        Schema(\n            {\n                \"pos\": And(list, lambda x: len(x) == 3),\n                \"radius\": And(Or(int, float), lambda x: x > 0.0),\n                Optional(\"name\", default=\"\"): str,\n                Optional(\"color\", default=None): And(lambda x: len(x) == 3, all(0 <= y <= 255 for y in x)),\n                Optional(\"layer\", default=None): str,\n            }\n        )\n\n    \"\"\"\n    guids = []\n    for s in iter(spheres):\n        pos = s[\"pos\"]\n        radius = s[\"radius\"]\n        name = s.get(\"name\", \"\")\n        color = s.get(\"color\")\n        layer = s.get(\"layer\")\n        sphere = Rhino.Geometry.Sphere(Rhino.Geometry.Point3d(*pos), radius)\n        guid = add_sphere(sphere)\n        if not guid:\n            continue\n        obj = find_object(guid)\n        if not obj:\n            continue\n        attr = obj.Attributes\n        if color:\n            attr.ObjectColor = System.Drawing.Color.FromArgb(*color)\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n        else:\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromLayer\n        if layer and find_layer_by_fullpath:\n            index = find_layer_by_fullpath(layer, True)\n            if index >= 0:\n                attr.LayerIndex = index\n        attr.Name = name\n        attr.WireDensity = -1\n        obj.CommitChanges()\n        guids.append(guid)\n    return guids\n\n\n@wrap_drawfunc\ndef draw_mesh(vertices, faces, name=None, color=None, vertex_color=None, disjoint=False, **kwargs):\n    \"\"\"Draw a mesh and optionally set individual name, color, and layer properties.\n\n    Parameters\n    ----------\n    vertices : list[[float, float, float] | :class:`compas.geometry.Point`]\n        A list of point locations.\n    faces : list[list[int]]\n        A list of faces as lists of indices into `vertices`.\n    name : str, optional\n        The name of the mesh object in Rhino.\n    color : tuple[[int, int, int]], optional\n        The base color of the mesh.\n    vertex_color : dict[int, tuple[int, int, int]], optional\n        A color per vertex of the mesh.\n        Vertices without a color specification in this mapping, will receive the base color.\n        For example: ``vertex_color = {vertex: Color.from_i(random.random()).rgb255 for face in faces for vertex in face}``\n    disjoint : bool, optional\n        If True, draw the mesh with disjoint faces.\n\n    Returns\n    -------\n    System.Guid\n\n    \"\"\"\n\n    def average_color(colors):\n        c = len(colors)\n        r, g, b = zip(*colors)\n        r = sum(r) / c\n        g = sum(g) / c\n        b = sum(b) / c\n        return int(r), int(g), int(b)\n\n    vertex_color = vertex_color or {}\n    vertexcolors = []\n\n    def populate_vertexcolors(face):\n        v_count = len(face)\n        facecolors = [vertex_color.get(vertex, color) for vertex in face]\n        if v_count > 4:\n            facecolors.append(average_color(facecolors))\n        vertexcolors.extend(facecolors)\n\n    if not disjoint:\n        rhino_mesh = vertices_and_faces_to_rhino(vertices, faces, disjoint)\n        vertexcolors = [vertex_color.get(vertex, color) for vertex in vertices]\n    else:\n        rhino_mesh = vertices_and_faces_to_rhino(vertices, faces, disjoint, face_callback=populate_vertexcolors)\n\n    guid = add_mesh(rhino_mesh)\n\n    if guid != System.Guid.Empty:\n        if vertexcolors:\n            try:\n                rs.MeshVertexColors(guid, vertexcolors)\n            except Exception:\n                pass\n\n        obj = find_object(guid)\n        if obj:\n            attr = obj.Attributes\n            if color:\n                attr.ObjectColor = System.Drawing.Color.FromArgb(*color)\n                attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n            else:\n                attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromLayer\n            if name:\n                attr.Name = name\n            obj.CommitChanges()\n        return guid\n\n\n@wrap_drawfunc\ndef draw_faces(faces, **kwargs):\n    \"\"\"Draw faces as individual meshes and optionally set individual name, color, and layer properties.\n\n    Parameters\n    ----------\n    faces : list[dict]\n        A list of face dictionaries.\n        See Notes, for more information about the structure of the dict.\n\n    Returns\n    -------\n    list[System.Guid]\n\n    Notes\n    -----\n    A face dict has the following schema:\n\n    .. code-block:: python\n\n        Schema(\n            {\n                \"points\": And(len, lambda x: all(len(y) == 3 for y in x)),\n                Optional(\"name\", default=\"\"): str,\n                Optional(\"color\", default=None): And(lambda x: len(x) == 3, all(0 <= y <= 255 for y in x)),\n                Optional(\"vertexcolors\", default=None): And(len, lambda x: all(0 <= y <= 255 for y in x)),\n            }\n        )\n\n    \"\"\"\n    guids = []\n    for face in iter(faces):\n        points = face[\"points\"][:]\n        name = face.get(\"name\")\n        color = face.get(\"color\")\n        vertexcolors = face.get(\"vertexcolors\")\n\n        v = len(points)\n\n        if v < 3:\n            continue\n        elif v == 3:\n            mfaces = [[0, 1, 2, 2]]\n        elif v == 4:\n            mfaces = [[0, 1, 2, 3]]\n        else:\n            mfaces = [list(range(v))]\n\n        guid = draw_mesh(\n            points,\n            mfaces,\n            color=color,\n            name=name,\n            clear=False,\n            redraw=False,\n            layer=None,\n        )\n\n        if vertexcolors:\n            try:\n                rs.MeshVertexColors(guid, vertexcolors)\n            except Exception:\n                pass\n\n        guids.append(guid)\n\n    return guids\n\n\ndef _face_to_max_quad(points, face):\n    faces = []\n    c = len(points)\n    points.append(centroid_polygon(points))\n    for i in range(-1, len(face) - 1):\n        a = face[i]\n        b = face[i + 1]\n        faces.append([c, a, b, b])\n    return faces\n\n\n@wrap_drawfunc\ndef draw_circles(circles, **kwargs):\n    \"\"\"Draw circles and optionally set individual name, color, and layer properties.\n\n    Parameters\n    ----------\n    circles : list[dict]\n        A list of circle dictionaries.\n        See Notes, for more information about the structure of the dict.\n\n    Returns\n    -------\n    list[System.Guid]\n\n    Notes\n    -----\n    A circle dict has the following schema:\n\n    .. code-block:: python\n\n        Schema(\n            {\n                \"plane\": lambda x: len(x[0]) == 3 and len(x[1]) == 3,\n                \"radius\": And(Or(int, float), lambda x: x > 0),\n                Optional(\"name\", default=\"\"): str,\n                Optional(\"color\", default=None): And(lambda x: len(x) == 3, all(0 <= y <= 255 for y in x)),\n                Optional(\"layer\", default=None): str,\n            }\n        )\n\n    \"\"\"\n    guids = []\n    for data in iter(circles):\n        point, normal = data[\"plane\"]\n        radius = data[\"radius\"]\n        name = data.get(\"name\", \"\")\n        color = data.get(\"color\")\n        layer = data.get(\"layer\")\n        circle = Rhino.Geometry.Circle(Rhino.Geometry.Plane(Rhino.Geometry.Point3d(*point), Rhino.Geometry.Vector3d(*normal)), radius)\n        guid = add_circle(circle)\n        if not guid:\n            continue\n        obj = find_object(guid)\n        if not obj:\n            continue\n        attr = obj.Attributes\n        if color:\n            attr.ObjectColor = System.Drawing.Color.FromArgb(*color)\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n        else:\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromLayer\n        if layer and find_layer_by_fullpath:\n            index = find_layer_by_fullpath(layer, True)\n            if index >= 0:\n                attr.LayerIndex = index\n        attr.Name = name\n        attr.WireDensity = -1\n        obj.CommitChanges()\n        guids.append(guid)\n    return guids\n\n\n@wrap_drawfunc\ndef draw_curves(curves, **kwargs):\n    \"\"\"Draw curves and optionally set individual name, color, and layer properties.\n\n    Parameters\n    ----------\n    curves : list[dict]\n        A list of curve dictionaries.\n        See Notes, for more information about the structure of the dict.\n\n    Returns\n    -------\n    list[System.Guid]\n\n    Notes\n    -----\n    A curve dict has the following schema:\n\n    .. code-block:: python\n\n        Schema(\n            {\n                \"curve\": compas.geometry.Rhino.Geometry.Curve,\n                Optional(\"name\", default=\"\"): str,\n                Optional(\"color\", default=None): And(lambda x: len(x) == 3, all(0 <= y <= 255 for y in x)),\n                Optional(\"layer\", default=None): str,\n            }\n        )\n\n    \"\"\"\n    guids = []\n    for data in iter(curves):\n        curve = data[\"curve\"]\n        name = data.get(\"name\", \"\")\n        color = data.get(\"color\")\n        layer = data.get(\"layer\")\n        guid = add_curve(curve.rhino_curve)\n        if not guid:\n            continue\n        obj = find_object(guid)\n        if not obj:\n            continue\n        attr = obj.Attributes\n        if color:\n            attr.ObjectColor = System.Drawing.Color.FromArgb(*color)\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n        else:\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromLayer\n        if layer and find_layer_by_fullpath:\n            index = find_layer_by_fullpath(layer, True)\n            if index >= 0:\n                attr.LayerIndex = index\n        attr.Name = name\n        obj.CommitChanges()\n        guids.append(guid)\n    return guids\n\n\n@wrap_drawfunc\ndef draw_surfaces(surfaces, **kwargs):\n    \"\"\"Draw surfaces and optionally set individual name, color, and layer properties.\n\n    Parameters\n    ----------\n    surfaces : list[dict]\n        A list of surface dictionaries.\n        See Notes, for more information about the structure of the dict.\n\n    Returns\n    -------\n    list[System.Guid]\n\n    Notes\n    -----\n    A surface dict has the following schema:\n\n    .. code-block:: python\n\n        Schema(\n            {\n                \"surface\": compas.geometry.Surface,\n                Optional(\"name\", default=\"\"): str,\n                Optional(\"color\", default=None): And(lambda x: len(x) == 3, all(0 <= y <= 255 for y in x)),\n                Optional(\"layer\", default=None): str,\n            }\n        )\n\n    \"\"\"\n    guids = []\n    for data in iter(surfaces):\n        surface = data[\"surface\"]\n        name = data.get(\"name\", \"\")\n        color = data.get(\"color\")\n        layer = data.get(\"layer\")\n        guid = add_surface(surface.rhino_surface)\n        if not guid:\n            continue\n        obj = find_object(guid)\n        if not obj:\n            continue\n        attr = obj.Attributes\n        if color:\n            attr.ObjectColor = System.Drawing.Color.FromArgb(*color)\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n        else:\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromLayer\n        if layer and find_layer_by_fullpath:\n            index = find_layer_by_fullpath(layer, True)\n            if index >= 0:\n                attr.LayerIndex = index\n        attr.Name = name\n        obj.CommitChanges()\n        guids.append(guid)\n    return guids\n\n\n@wrap_drawfunc\ndef draw_brep(brep, color=None, **kwargs):\n    \"\"\"Draw a brep to the Rhino document.\n\n    Parameters\n    ----------\n    brep : :class:`compas_rhino.geometry.RhinoRhino.Geometry.Brep`\n        The brep to draw.\n    color : tuple[int, int, int] | tuple[float, float, float], optional\n        The color to draw the brep with.\n\n    Returns\n    -------\n    :rhino:`System.Guid`\n        The Rhino document GUID of the drawn Rhino.Geometry.Brep.\n\n    \"\"\"\n    native_brep = brep.native_brep\n    if color:\n        for face in native_brep.Faces:\n            face.PerFaceColor = System.Drawing.Color.FromArgb(*color)\n    return add_brep(native_brep)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}