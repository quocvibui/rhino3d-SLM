{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Surface%20View%20Analysis.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Surface View Analysis.py",
  "instruction": "Use this component to calculate view factors from a point or plane to a set of surfaces.  View factors are used in many thermal comfort calculations such as mean radiant temperture (MRT) or...",
  "code": "# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n#\n# This file is part of Ladybug.\n#\n# Copyright (c) 2013-2020, ....(YOUR NAME).... <....(YOUR EMAIL)....>\n# Ladybug is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published\n# by the Free Software Foundation; either version 3 of the License,\n# or (at your option) any later version.\n#\n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n#\n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to calculate view factors from a point or plane to a set of surfaces.  View factors are used in many thermal comfort calculations such as mean radiant temperture (MRT) or discomfort from radiant assymetry. \n-\nProvided by Ladybug 0.0.69\n\n    Args:\n        _testPtsOrPlanes: A point or plane from which view vectors will be pojected.  Note that, if a point is connected, all view vectors will be weighted evenly (assuming no directional bias).  However, if a plane is connected, vectors will be weighted based on their angle to the plane normal, producing view factors for a surface in the connected plane.  The first is useful for MRT calculations while the latter is needed for radiant assymetry calculations.  This input can also be a list of points or planes.\n        _testSrfs: A list of breps, surfaces, or meshes to which you want to compute view factors.  Note that by meshing and joining several goemtries together, you can calculate the combined view factor to these geometries.\n        context_: Optional context geometry as breps, surfaces, or meshes that can block the view to the _testSrfs.\n        _viewResolution_: An interger, which sets the number of times that the tergenza skyview patches are split.  A higher number will ensure a greater accuracy but will take longer.  The default is set to 0 for a quick calculation.\n        parallel_: Set to \"True\" to run the calculation in parallel and set to \"False\" to run it with a single core.  The default is set to \"False.\"\n        _runIt: Set to 'True' to run the component and claculate view factors.\n    Returns:\n        readMe!: ...\n        srfViewFactors: A list of view factors that describe the fraction of sperical view taken up by the input surfaces.  These values range from 0 (no view) to 1 (full view).  If multiple _testPtsOrPlanes have been connected, this output will be a data tree with one list for each point.\n        viewVecSrfIndex: The index of the surface that each view vector hit.  This can be used to identify which view pathces are intersected by each surface.  If no surfaces are intersected, this value will be -1.\n        viewVectors: The view vectors that were projected from each testPtOrPlane.\n        viewPatches: The patches of the sphere that each view vector correspond to.\n        viewPatchBasePt: The center of the viewPatches sphere. This can be used to move the view patches between the testPts.\n\"\"\"\n\nghenv.Component.Name = \"Ladybug_Surface View Analysis\"\nghenv.Component.NickName = 'srfViewFactors'\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"3 | EnvironmentalAnalysis\"\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\n#compatibleHBVersion = VER 0.0.56\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"0\"\nexcept: pass\n\nimport operator\nimport Grasshopper.Kernel as gh\nimport Rhino as rc\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport math\nimport System.Threading.Tasks as tasks\nfrom System import Object\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\nw = gh.GH_RuntimeMessageLevel.Warning\n\n\ndef checkInputs():\n    #Set a default view resolution.\n    if _viewResolution_ == None: viewRes = 0\n    else: viewRes = _viewResolution_\n    \n    #Set a default parallel.\n    if parallel_ == None: parallel = False\n    else: parallel = parallel_\n    \n    #Check to to see if the connected _testPts are points or planes.\n    checkData = True\n    viewMethod = 0\n    viewPoints = []\n    viewPtNormals = []\n    for point in _testPtsOrPlanes:\n        try:\n            #The user has connected planes.\n            viewPoints.append(point.Origin)\n            viewPtNormals.append(point.Normal)\n            viewMethod = 1\n        except:\n            #The user has connected points.\n            try:\n                viewPoints.append(rc.Geometry.Point3d(point))\n                if viewMethod ==  1: checkData = False\n            except:\n                try:\n                    viewPoints.append(rc.Geometry.Point3d(rs.coerce3dpoint(point)))\n                except:\n                    checkData = False\n    \n    if checkData == False:\n        warning = \"_testPtsOrPlanes can be either points or planes but not both.\"\n        print warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n    \n    return checkData, viewRes, viewMethod, viewPoints, viewPtNormals, parallel\n\ndef checkViewResolution(viewResolution, centPt, lb_preparation):\n    #Set lists to be filled.\n    newVecs = []\n    viewPatches = []\n    patchAreaFacs = []\n    patchAreas = []\n    \n    #Set up some transformations.\n    skyPtachTranslation = rc.Geometry.Transform.Translation(centPt.X, centPt.Y, centPt.Z)\n    patchReflectTrans = rc.Geometry.Transform.Mirror(rc.Geometry.Plane(centPt, rc.Geometry.Vector3d.XAxis, rc.Geometry.Vector3d.YAxis))\n    patchRotateTrans = rc.Geometry.Transform.Rotation(math.pi, rc.Geometry.Vector3d.ZAxis, centPt)\n    \n    #Generate sky patches.\n    skyPatches = lb_preparation.generateSkyGeo(rc.Geometry.Point3d.Origin, viewResolution, 1)\n    \n    #Extract info from the patches.\n    for patch in skyPatches:\n        #Add to the area list.\n        patchAreaProps = rc.Geometry.AreaMassProperties.Compute(patch)\n        patchAreas.extend([patchAreaProps.Area, patchAreaProps.Area])\n        \n        #Add to the vector list.\n        patchPt = patchAreaProps.Centroid\n        Vec = rc.Geometry.Vector3d(patchPt.X, patchPt.Y, patchPt.Z)\n        revVec = rc.Geometry.Vector3d(-patchPt.X, -patchPt.Y, -patchPt.Z)\n        newVecs.append(Vec)\n        newVecs.append(revVec)\n        \n        #Add to the viewPatches list.\n        patch.Transform(skyPtachTranslation)\n        viewPatches.append(patch)\n        newPatch = rc.Geometry.Brep.CreateTrimmedSurface(patch.Faces[0], patch.Faces[0])\n        newPatch.Transform(patchReflectTrans)\n        newPatch.Transform(patchRotateTrans)\n        viewPatches.append(newPatch)\n    \n    #Convert patch areas to factors that will be multiplied by the 0/1 values.\n    normPatArea = sum(patchAreas)/len(patchAreas)\n    for patArea in patchAreas:\n        patchAreaFacs.append(patArea/normPatArea)\n    \n    return newVecs, viewPatches, patchAreaFacs\n\ndef allZero(items):\n    return all(x == \"N\" for x in items)\n\ndef main(zoneSrfsMesh, context, viewVectors, patchAreaFacs, testPts, viewPtNormals, viewMethod, parallel = False):\n    #Make the list that will eventually hold the view factors of each surface.\n    testPtViewFactor = []\n    vecSrfIndices = []\n    for pointCount, point in enumerate(testPts):\n        testPtViewFactor.append([])\n        vecSrfIndices.append([])\n        divisor = len(viewVectors)\n    totalSrfsMesh = zoneSrfsMesh + context\n    \n    def intRays(i):\n        #Create the rays to be projected from each point.\n        pointRays = []\n        for vec in viewVectors: pointRays.append(rc.Geometry.Ray3d(testPts[i], vec))\n        \n        #Create a list that will hold the intersection hits of each surface\n        srfHits = []\n        for srf in totalSrfsMesh: srfHits.append([])\n        \n        #Perform the intersection of the rays with the mesh.\n        pointIntersectList = []\n        for rayCount, ray in enumerate(pointRays):\n            pointIntersectList.append([])\n            for srf in totalSrfsMesh:\n                intersect = rc.Geometry.Intersect.Intersection.MeshRay(srf, ray)\n                if intersect == -1: intersect = \"N\"\n                pointIntersectList[rayCount].append(intersect)\n        \n        #Find the intersection that was the closest for each ray (in case one ray intersects 2 surfaces)\n        for rayCount, intList in enumerate(pointIntersectList):\n            if allZero(intList) == False:\n                minIndex, minValue = min(enumerate(intList), key=operator.itemgetter(1))\n                if minIndex > len(zoneSrfsMesh)-1:\n                    vecSrfIndices[i].append(-1)\n                else:\n                    vecSrfIndices[i].append(minIndex)\n                    if viewMethod == 0: srfHits[minIndex].append(patchAreaFacs[rayCount])\n                    else:\n                        # calculate the angle between the surface and the vector to project the view into the plane.\n                        vecAngle = rc.Geometry.Vector3d.VectorAngle(viewVectors[rayCount], viewPtNormals[i])\n                        if math.degrees(vecAngle) > 90:\n                            srfHits[minIndex].append(0)\n                        else:\n                            srfHits[minIndex].append(patchAreaFacs[rayCount]* 4 * abs(math.cos(vecAngle)))\n            else:\n                vecSrfIndices[i].append(-1)\n        \n        #Sum up the lists and divide by the total rays to get the view factor.\n        for hitList in srfHits:\n            testPtViewFactor[i].append(sum(hitList)/divisor)\n    \n    if parallel:\n        tasks.Parallel.ForEach(range(len(testPts)), intRays)\n    else:\n        for count in range(len(testPts)):\n            intRays(count)\n    \n    \n    return testPtViewFactor, vecSrfIndices\n\n\n#If Honeybee or Ladybug is not flying or is an older version, give a warning.\ninitCheck = True\n\n#Ladybug check.\nif not sc.sticky.has_key('ladybug_release') == True:\n    initCheck = False\n    print \"You should first let Ladybug fly...\"\n    ghenv.Component.AddRuntimeMessage(w, \"You should first let Ladybug fly...\")\nelse:\n    try:\n        if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): initCheck = False\n        if sc.sticky['ladybug_release'].isInputMissing(ghenv.Component): initCheck = False\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n    except:\n        initCheck = False\n        warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n        \"Use updateLadybug component to update userObjects.\\n\" + \\\n        \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n        \"into canvas and try again.\"\n        ghenv.Component.AddRuntimeMessage(w, warning)\n\n\n\n\nif initCheck == True:\n    checkData, viewRes, viewMethod, viewPoints, viewPtNormals, parallel = checkInputs()\n    if checkData == True and _runIt == True:\n        viewPatchBasePt = viewPoints[0]\n        viewVectors, viewPatches, patchAreaFacs = checkViewResolution(viewRes, viewPatchBasePt, lb_preparation)\n        srfViewFactorsInit, viewVecSrfIndexInit = main(_testSrfs, context_, viewVectors, patchAreaFacs, viewPoints, viewPtNormals, viewMethod, parallel)\n        \n        srfViewFactors = DataTree[Object]()\n        viewVecSrfIndex = DataTree[Object]()\n        for count, dataList in enumerate(srfViewFactorsInit):\n            for item in dataList: srfViewFactors.Add(item, GH_Path(count))\n        for count, dataList in enumerate(viewVecSrfIndexInit):\n            for item in dataList: viewVecSrfIndex.Add(item, GH_Path(count))\n\nghenv.Component.Params.Output[4].Hidden= True\nghenv.Component.Params.Output[5].Hidden= True",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}