{
  "source_url": "https://github.com/felipeharker/alexandria-lab/blob/1d3696f4b28ecc45579b5fbe5809a7e00699fa08/alexandria-application-files/alexandria-scripts/ghpython/obstacle_shatter_points.py",
  "repo": "felipeharker/alexandria-lab",
  "repo_stars": 1,
  "repo_description": "a repo of documents, links, visual assets, drawings, videos, articles, etc. I find interesting. Brain dump, catch-all repo with limited structure. ",
  "license": "unknown",
  "filepath": "alexandria-application-files/alexandria-scripts/ghpython/obstacle_shatter_points.py",
  "instruction": "Shatter curves at user points while avoiding obstacles.",
  "code": "# ALEXANDRIA IO SPEC (standardized)\n# Inputs:\n# - CenterCurves (GH: C) | list[Rhino.Geometry.Curve] | Center curves to shatter\n# - ShatterPts (GH: Pts) | list[Rhino.Geometry.Point3d] | Requested shatter points\n# - ObstacleCurves (GH: Obs) | list[Rhino.Geometry.Curve] | Obstacle boundaries\n# - ObstacleTolerance (GH: ObsTol) | float | Centroid exclusion tolerance\n# - Step (GH: Step) | float | Arc-length shift step\n# Outputs:\n# - SafeSegments (GH: CrvSeg) | Grasshopper.DataTree[Rhino.Geometry.Curve] | Safe shattered segments\n# - CollidingSegments (GH: CrvColl) | Grasshopper.DataTree[Rhino.Geometry.Curve] | Colliding segments\n# - AdjustedPts (GH: PtsFixed) | Grasshopper.DataTree[Rhino.Geometry.Point3d] | Adjusted shatter points\n\n\"\"\"Shatter curves at user points while avoiding obstacles.\n\nInputs:\n    C       : list of center curves (Rhino.Geometry.Curve)\n    Pts     : list of user points where shatters are desired (Point3d)\n    Obs     : list of obstacle curves (rectangles/slots, closed & coplanar)\n    ObsTol  : minimum tolerance between the centroid of an obstacle and a shatter point\n    Step    : arc-length step for shifting a bad point along the curve\n\nOutputs:\n    CrvSeg   : DataTree of safe shattered segments (one branch per curve)\n    CrvColl  : DataTree of colliding segments (one branch per curve)\n    PtsFixed : DataTree of adjusted points actually used for shattering\n\"\"\"\n\nimport Rhino.Geometry as rg\nimport scriptcontext as sc\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\nCrvSeg   = DataTree[object]()\nCrvColl  = DataTree[object]()\nPtsFixed = DataTree[object]()\n\ntol = sc.doc.ModelAbsoluteTolerance\n\n# Coerce curves list\nif C is None:\n    curves = []\nelse:\n    try:\n        curves = list(C)\n    except TypeError:\n        curves = [C]\n\nif not curves:\n    # nothing to do\n    pass\nelse:\n    # ------------- global plane + centroids -------------\n    plane = rg.Plane.WorldXY\n    plane_found = False\n\n    # Try curves first\n    for crv in curves:\n        if crv is None or not crv.IsValid:\n            continue\n        success, pl = crv.TryGetPlane()\n        if success:\n            plane = pl\n            plane_found = True\n            break\n\n    # Fallback: obstacles\n    if not plane_found and Obs:\n        for ob in Obs:\n            if ob is None:\n                continue\n            success, pl = ob.TryGetPlane()\n            if success:\n                plane = pl\n                break\n\n    centroids = []\n    if ObsTol > 0 and Obs:\n        for ob in Obs:\n            if ob is None:\n                continue\n            amp = rg.AreaMassProperties.Compute(ob)\n            if amp:\n                centroids.append(amp.Centroid)\n\n    def point_forbidden(pt):\n        \"\"\"True if pt is inside an obstacle or within ObsTol of a centroid.\"\"\"\n        if Obs:\n            for ob in Obs:\n                if ob is None:\n                    continue\n                pc = ob.Contains(pt, plane, tol)\n                if pc == rg.PointContainment.Inside or pc == rg.PointContainment.Coincident:\n                    return True\n        if ObsTol > 0 and centroids:\n            for c in centroids:\n                if pt.DistanceTo(c) <= ObsTol:\n                    return True\n        return False\n\n    def endpoint_collides(pt):\n        \"\"\"True if endpoint lies inside any obstacle.\"\"\"\n        if not Obs:\n            return False\n        for ob in Obs:\n            if ob is None:\n                continue\n            pc = ob.Contains(pt, plane, tol)\n            if pc == rg.PointContainment.Inside or pc == rg.PointContainment.Coincident:\n                return True\n        return False\n\n    # Step along curve when fixing a bad point\n    step = abs(Step)\n    if step <= 0:\n        # fallback: 1/200 of typical length scale\n        step = 1.0\n\n    # per-curve parameter & fixed-point lists\n    n = len(curves)\n    curve_ts  = [[] for _ in range(n)]\n    curve_pts = [[] for _ in range(n)]\n\n    # ------------- assign and fix points -------------\n    if Pts:\n        for pt in Pts:\n            # find nearest curve to this point\n            best_i  = None\n            best_t  = None\n            best_d2 = None\n\n            for i, crv in enumerate(curves):\n                if crv is None or not crv.IsValid:\n                    continue\n                rc, t = crv.ClosestPoint(pt)\n                if not rc:\n                    continue\n                cpt = crv.PointAt(t)\n                d2 = cpt.DistanceToSquared(pt)\n                if best_d2 is None or d2 < best_d2:\n                    best_d2 = d2\n                    best_i  = i\n                    best_t  = t\n\n            if best_i is None:\n                continue\n\n            crv = curves[best_i]\n            if crv is None or not crv.IsValid:\n                continue\n\n            dom = crv.Domain\n            length = crv.GetLength()\n            if length <= 0:\n                continue\n\n            t0 = best_t\n            cpt0 = crv.PointAt(t0)\n\n            if not point_forbidden(cpt0):\n                # already good\n                curve_ts[best_i].append(t0)\n                curve_pts[best_i].append(cpt0)\n            else:\n                # slide along the curve in +/- arc length\n                # first convert t0 -> arc length s0\n                s0 = crv.GetLength(rg.Interval(dom.T0, t0))\n                max_steps = int(length / step) + 2\n\n                found = False\n                for k in range(1, max_steps):\n                    s_candidates = [s0 + k * step, s0 - k * step]\n                    for s_c in s_candidates:\n                        if s_c < 0.0 or s_c > length:\n                            continue\n                        rc2, t2 = crv.LengthParameter(s_c)\n                        if not rc2:\n                            continue\n                        p2 = crv.PointAt(t2)\n                        if not point_forbidden(p2):\n                            curve_ts[best_i].append(t2)\n                            curve_pts[best_i].append(p2)\n                            found = True\n                            break\n                    if found:\n                        break\n\n                if not found:\n                    # couldn't rescue: use original projection\n                    curve_ts[best_i].append(t0)\n                    curve_pts[best_i].append(cpt0)\n\n    # ------------- per-curve shatter & classify -------------\n    for i, crv in enumerate(curves):\n        path = GH_Path(i)\n\n        if crv is None or not crv.IsValid:\n            continue\n\n        dom = crv.Domain\n        t_start = dom.T0\n        t_end   = dom.T1\n\n        # start + fixed params + end\n        ts = [t_start] + curve_ts[i] + [t_end]\n\n        # sort & clean duplicates\n        ts = sorted(ts)\n        clean_ts = [ts[0]]\n        for t in ts[1:]:\n            if abs(t - clean_ts[-1]) > tol:\n                clean_ts.append(t)\n        ts = clean_ts\n\n        # output fixed points for this curve\n        for p in curve_pts[i]:\n            PtsFixed.Add(p, path)\n\n        # shatter\n        for j in range(len(ts) - 1):\n            t0 = ts[j]\n            t1 = ts[j + 1]\n            if t1 - t0 <= tol:\n                continue\n\n            sub = crv.Trim(rg.Interval(t0, t1))\n            if not sub or not sub.IsValid:\n                continue\n\n            p0 = crv.PointAt(t0)\n            p1 = crv.PointAt(t1)\n\n            if endpoint_collides(p0) or endpoint_collides(p1):\n                CrvColl.Add(sub, path)\n            else:\n                CrvSeg.Add(sub, path)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}