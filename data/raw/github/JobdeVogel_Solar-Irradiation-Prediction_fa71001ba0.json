{
  "source_url": "https://github.com/JobdeVogel/Solar-Irradiation-Prediction/blob/ce25b61727edaaaeb0e965bb821506de01cb0dcc/dataset/transform/model.py",
  "repo": "JobdeVogel/Solar-Irradiation-Prediction",
  "repo_stars": 0,
  "repo_description": "Graduation repository for Master Building Technology",
  "license": "unknown",
  "filepath": "dataset/transform/model.py",
  "instruction": null,
  "code": "import Rhino.Geometry as rg\n\nimport uuid\n\nfrom honeybee.face import Face\nfrom honeybee.facetype import face_types\nfrom honeybee.boundarycondition import boundary_conditions\nfrom honeybee.typing import clean_string, clean_and_id_string, clean_and_id_rad_string, clean_rad_string\n\n# Ladybug-Rhino dependencies\nfrom ladybug_rhino.togeometry import to_mesh3d, to_face3d\n# from ladybug_rhino.grasshopper import longest_list\nfrom ladybug_rhino.config import units_system, tolerance, angle_tolerance\n\n# Honeybee Core dependencies\nfrom honeybee.model import Model\n\n# Honeybee-Radiance dependencies\nfrom honeybee_radiance.lib.modifiers import modifier_by_identifier\nfrom honeybee_radiance.modifier.material import Plastic\nfrom honeybee_radiance.sensorgrid import SensorGrid\n\n\nimport time\n\nfrom parameters.params import REFLECTANCE, SPECULAR, ROUGHNESS, MODIFIER_NAME\n\ndef modifier(reflectance=REFLECTANCE, specular=SPECULAR, roughness=ROUGHNESS, name=MODIFIER_NAME):\n    # Set the default modifier properties\n    specular = 0.0 if specular is None else specular\n    roughness = 0.0 if roughness is None else roughness\n    name = clean_and_id_rad_string('OpaqueMaterial') if name is None else \\\n        clean_rad_string(name)\n\n    # Create the modifier\n    modifier = Plastic.from_single_reflectance(name, reflectance, specular, roughness)\n    modifier.display_name = name\n    \n    return modifier\n\ndef generate_HB_faces(mesh, modifier, name=\"faces\", boundary_condition=\"outdoors\"):\n    faces = []\n    for j, geo in enumerate(mesh):\n\n        # Assign Name\n        # display_name = '{}_{}'.format(longest_list(name, j), j + 1)\n        display_name = 'temp'\n        name = clean_and_id_string(display_name)\n        \n        # Type is not used in this context\n        typ = None\n        \n        # Assign boundary condition\n        bc = boundary_conditions.by_name(boundary_condition)\n        \n        # Generate LB faces\n        \n        lb_faces = to_face3d(geo)   # OPTIMIZE SPEED\n        for i, lb_face in enumerate(lb_faces):\n            face_name = '{}_{}'.format(name, i)\n            hb_face = Face(face_name, lb_face, typ, bc)\n            hb_face.display_name = display_name\n\n            # Assign radiance modifier\n            hb_face.properties.radiance.modifier = modifier\n            \n            # Append faces to collection\n            faces.append(hb_face)\n\n    return faces\n\ndef HB_model(faces, grid, name=\"model_\" + str(time.time())):\n    # Set a default name and get the Rhino Model units\n    name = clean_string(name)\n    units = units_system()\n\n    # Generate model with only name and faces\n    model = Model(name, [], faces, [], [], [],\n                  units=units, tolerance=tolerance, angle_tolerance=angle_tolerance)\n    model.display_name = name\n    \n    if isinstance(grid, list):\n        model.properties.radiance.add_sensor_grids(grid)\n    else:\n        model.properties.radiance.add_sensor_grids([grid])\n    \n    return model\n\n#model.to_hbjson(name='xjdsd', folder='C://Users//Job de Vogel//Desktop')\n\ndef grid(points, normals, name=\"custom_SensorGrid\"):\n    # Set the default name and process the points to tuples\n    name = name\n    pts = [(pt.X, pt.Y, pt.Z) if pt is not None else None for pt in points]\n\n    # create the sensor grid object\n    id  = clean_rad_string(name) if '/' not in name else clean_rad_string(name.split('/')[0])\n    if len(normals) == 0:\n        grid = SensorGrid.from_planar_positions(id, pts, (0, 0, 1))\n    else:\n        vecs = [(vec.X, vec.Y, vec.Z) if vec is not None else None for vec in normals]\n        grid = SensorGrid.from_position_and_direction(id, pts, vecs)\n\n    # set the display name\n    grid.display_name = name\n    if '/' in name:\n        grid.group_identifier = \\\n            '/'.join(clean_rad_string(key) for key in name.split('/')[1:])\n    \n    return grid\n\ndef generate(ground_mesh, roof_mesh, wall_mesh, sensors, normals):\n    mod = modifier()\n    faces = []\n\n    faces.extend(generate_HB_faces(ground_mesh, mod))\n    faces.extend(generate_HB_faces(roof_mesh, mod))\n    faces.extend(generate_HB_faces(wall_mesh, mod))\n\n    sensor_grid = grid(sensors, normals)\n    \n    name = str(uuid.uuid4())\n    \n    model = HB_model(faces, sensor_grid, name=name)\n    \n    return model",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}