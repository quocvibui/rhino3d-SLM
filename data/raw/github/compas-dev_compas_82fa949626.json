{
  "source_url": "https://github.com/compas-dev/compas/blob/HEAD/src/compas/_os.py",
  "repo": "compas-dev/compas",
  "repo_stars": 352,
  "repo_description": "Main library of the COMPAS framework and CAD integrations for Rhino/GH and Blender.",
  "license": "MIT",
  "filepath": "src/compas/_os.py",
  "instruction": "These are internal functions of the framework.\nNot intended to be used outside compas* packages.",
  "code": "# -*- coding: utf-8 -*-\n\"\"\"\nThese are internal functions of the framework.\nNot intended to be used outside compas* packages.\n\"\"\"\n\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\n\ntry:\n    NotADirectoryError\nexcept NameError:\n\n    class NotADirectoryError(Exception):\n        pass\n\n\nPY2 = sys.version_info[0] == 2\nPY3 = sys.version_info[0] == 3\nSYMLINK_REGEX = re.compile(r\"\\n.*\\<SYMLINKD\\>\\s(.*)\\s\\[(.*)\\]\\r\")\n\n\n__all__ = [\n    \"absjoin\",\n    \"realpath\",\n    \"create_symlink\",\n    \"create_symlinks\",\n    \"remove_symlink\",\n    \"remove_symlinks\",\n    \"copy\",\n    \"remove\",\n    \"rename\",\n    \"user_data_dir\",\n    \"select_python\",\n    \"prepare_environment\",\n    \"is_admin\",\n    \"is_windows\",\n    \"is_linux\",\n    \"is_osx\",\n    \"is_mono\",\n    \"is_ironpython\",\n    \"is_rhino\",\n    \"is_blender\",\n    \"is_grasshopper\",\n]\n\n\ndef is_windows():\n    \"\"\"Check if the operating system is Windows.\n\n    Returns\n    -------\n    bool\n        True if the OS is Windows. False otherwise\n\n    \"\"\"\n    if is_ironpython():\n        return os.name == \"nt\"\n    return sys.platform == \"win32\"\n\n\ndef is_linux():\n    \"\"\"Check if the operating system is Linux.\n\n    Returns\n    -------\n    bool\n        True if the OS is Linux. False otherwise\n\n    \"\"\"\n    return sys.platform in (\"linux\", \"linux2\")\n\n\ndef is_osx():\n    return sys.platform == \"darwin\"\n\n\ndef is_mono():\n    \"\"\"Check if the operating system is running on Mono.\n\n    Returns\n    -------\n    bool\n        True if the OS is running on Mono. False otherwise\n\n    \"\"\"\n    return \"mono\" in sys.version.lower()\n\n\ndef is_ironpython():\n    \"\"\"Check if the Python implementation is IronPython.\n\n    Returns\n    -------\n    bool\n        True if the implementation is IronPython. False otherwise\n\n    \"\"\"\n    return \"ironpython\" == platform.python_implementation().lower()\n\n\ndef is_rhino():\n    try:\n        import Rhino  # noqa : F401\n    except ImportError:\n        return False\n    return True\n\n\ndef is_grasshopper():\n    try:\n        import Rhino  # noqa : F401\n        import scriptcontext  # noqa : F401\n    except ImportError:\n        return False\n    return not isinstance(scriptcontext.doc, Rhino.RhinoDoc)\n\n\ndef is_blender():\n    try:\n        import bpy  # noqa : F401\n    except ImportError:\n        return False\n    return True\n\n\nif is_windows():\n    import ctypes\n    import ctypes.wintypes\n\n    class ShellExecuteInfo(ctypes.Structure):\n        _fields_ = [\n            (\"cbSize\", ctypes.wintypes.DWORD),\n            (\"fMask\", ctypes.c_ulong),\n            (\"hwnd\", ctypes.wintypes.HWND),\n            (\"lpVerb\", ctypes.c_char_p),\n            (\"lpFile\", ctypes.c_char_p),\n            (\"lpParameters\", ctypes.c_char_p),\n            (\"lpDirectory\", ctypes.c_char_p),\n            (\"nShow\", ctypes.c_int),\n            (\"hInstApp\", ctypes.wintypes.HINSTANCE),\n            (\"lpIDList\", ctypes.c_void_p),\n            (\"lpClass\", ctypes.c_char_p),\n            (\"hKeyClass\", ctypes.wintypes.HKEY),\n            (\"dwHotKey\", ctypes.wintypes.DWORD),\n            (\"hIcon\", ctypes.wintypes.HANDLE),\n            (\"hProcess\", ctypes.wintypes.HANDLE),\n        ]\n\n        def __init__(self, **kw):\n            super(ShellExecuteInfo, self).__init__()\n            self.cbSize = ctypes.sizeof(self)\n            for field_name, field_value in kw.items():\n                setattr(self, field_name, field_value)\n\n    SEE_MASK_NOCLOSEPROCESS = 0x00000040\n    SEE_MASK_NO_CONSOLE = 0x00008000\n    INFINITE = -1\n\n\n# seems a bit weird that this is done here, since it is only relevant for Rhino/GH\n# also, perhasps it makes more sense this is done at the top of the file\n# since it defines a few module-wide variables\ntry:\n    from compas_bootstrapper import PYTHON_DIRECTORY\nexcept:  # noqa: E722\n    # We re-map CONDA_PREFIX for backwards compatibility reasons\n    # In a few releases down the line, we can get rid of this bit\n    try:\n        from compas_bootstrapper import CONDA_PREFIX as PYTHON_DIRECTORY\n    except:  # noqa: E722\n        PYTHON_DIRECTORY = None\n\ntry:\n    from compas_bootstrapper import CONDA_EXE\nexcept:  # noqa: E722\n    CONDA_EXE = None\n\n\ndef select_python(python_executable):\n    \"\"\"Selects the most likely python interpreter to run.\n\n    This function detects if there is a conda environment we can use,\n    or if we need to default to a system-wide python interpreter instead.\n\n    Parameters\n    ----------\n    python_executable : str\n        Select which python executable you want to use,\n        either `python` or `pythonw`.\n    \"\"\"\n    if PYTHON_DIRECTORY and os.path.exists(PYTHON_DIRECTORY):\n        python_executables = [python_executable] if python_executable else [\"pythonw\", \"python\"]\n\n        for python_exe in python_executables:\n            python = os.path.join(PYTHON_DIRECTORY, python_exe)\n            if os.path.exists(python):\n                return python\n\n            python = os.path.join(PYTHON_DIRECTORY, \"{0}.exe\".format(python_exe))\n            if os.path.exists(python):\n                return python\n\n            python = os.path.join(PYTHON_DIRECTORY, \"bin\", python_exe)\n            if os.path.exists(python):\n                return python\n\n            python = os.path.join(PYTHON_DIRECTORY, \"bin\", \"{0}.exe\".format(python_exe))\n            if os.path.exists(python):\n                return python\n\n    default_exe = \"pythonw\" if is_windows() else \"python\"\n\n    # Assume a system-wide install exists\n    return python_executable or default_exe\n\n\ndef prepare_environment(env=None):\n    \"\"\"Prepares an environment context to run Python on.\n\n    If Python is being used from a conda environment, this is roughly equivalent\n    to activating the conda environment by setting up the correct environment\n    variables.\n\n    Parameters\n    ----------\n    env : dict, optional\n        Dictionary of environment variables to modify. If ``None`` is passed, then\n        this will create a copy of the current ``os.environ``.\n\n    Returns\n    -------\n    dict\n        Updated environment variable dictionary.\n    \"\"\"\n\n    if env is None:\n        env = os.environ.copy()\n\n    if PYTHON_DIRECTORY:\n        if is_windows():\n            lib_bin = os.path.join(PYTHON_DIRECTORY, \"Library\", \"bin\")\n        else:\n            lib_bin = os.path.join(PYTHON_DIRECTORY, \"bin\")\n\n        if os.path.exists(lib_bin) and lib_bin not in env[\"PATH\"]:\n            env[\"PATH\"] = lib_bin + os.pathsep + env[\"PATH\"]\n\n    if CONDA_EXE:\n        env[\"CONDA_EXE\"] = CONDA_EXE\n\n    return env\n\n\ndef absjoin(*parts):\n    return os.path.abspath(os.path.join(*parts))\n\n\ndef realpath(path):\n    \"\"\"Return the canonical path of the specified filename, resolving any symbolic links encountered in the path.\n\n    This function uses Python's stdlib `os.path.realpath` in most cases,\n    except when inside IronPython because (guess what?) it is broken and\n    doesn't really eliminate sym links, so, we fallback to a different\n    way to identifying symlinks in that situation.\n    \"\"\"\n    if not PY3 and is_ironpython():\n        if is_windows():\n            return _realpath_ipy_win(path)\n        else:\n            return _realpath_ipy_posix(path)\n\n    return os.path.realpath(path)\n\n\ndef _realpath_ipy_win(path):\n    dirname = os.path.basename(path)\n    parent_path = os.path.join(path, \"..\")\n\n    args = 'dir /c \"{}\" /Al'.format(parent_path)\n    process = subprocess.Popen(args, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n    output, _error = process.communicate()\n    matches = SYMLINK_REGEX.finditer(output)\n    for match in matches:\n        match_name = match.groups()[0].strip()\n        match_link = match.groups()[1]\n\n        if match_name == dirname:\n            return match_link\n\n    return path\n\n\ndef _realpath_ipy_posix(path):\n    args = 'readlink -f \"{}\"'.format(path)\n    process = subprocess.Popen(args, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    output, _error = process.communicate()\n    return output.strip()\n\n\n# Cache whatever symlink function works (native or polyfill)\n_os_symlink = None\n\n\ndef _polyfill_symlinks(symlinks, raise_on_error):\n    \"\"\"Create multiple symlinks using the polyfill implementation.\"\"\"\n    _handle, temp_path = tempfile.mkstemp(suffix=\".cmd\", text=True)\n\n    with open(temp_path, \"w\") as mklink_cmd:\n        mklink_cmd.write(\"@echo off\\n\")\n        mklink_cmd.write(\"SET /A symlink_result=0\\n\")\n        mklink_cmd.write(\"ECHO ret=%symlink_result%\\n\")\n        for i, (source, link_name) in enumerate(symlinks):\n            dir_symlink_arg = \"/J\" if os.path.isdir(source) else \"\"\n            mklink_cmd.write(\"mklink {} {}\\n\".format(dir_symlink_arg, subprocess.list2cmdline([link_name, source])))\n            mklink_cmd.write(\"IF %ERRORLEVEL% EQU 0 SET /A symlink_result += {} \\n\".format(2**i))\n\n        mklink_cmd.write(\"EXIT /B %symlink_result%\\n\")\n\n    ret_value = _run_as_admin([temp_path])\n\n    # The error level integer (ret_value) reflects the success/failure of\n    # each of the symlink operations, so we do a bit of bitwise-arithmetic\n    # on it to figure out which symlinks worked and which ones failed.\n\n    result = []\n    for i in range(len(symlinks)):\n        success = ret_value & 2**i != 0\n        result.append(success)\n\n    return result\n\n\ndef _native_symlinks(symlinks, raise_on_error):\n    \"\"\"Create multiple symlinks using the native implementation.\"\"\"\n    result = []\n\n    for source, link_name in symlinks:\n        try:\n            os.symlink(source, link_name)\n            result.append(True)\n        except OSError:\n            if raise_on_error:\n                raise\n\n            result.append(False)\n\n    return result\n\n\ndef _set_symlink_function(fn):\n    global _os_symlink\n    _os_symlink = fn\n\n\ndef _get_symlink_function():\n    global _os_symlink\n    allow_polyfill_retry = False\n\n    if not _os_symlink:\n        if getattr(os, \"symlink\", None):\n            _os_symlink = _native_symlinks\n\n        if is_windows():\n            if not callable(_os_symlink):\n                _os_symlink = _polyfill_symlinks\n            else:\n                allow_polyfill_retry = True\n\n    return _os_symlink, allow_polyfill_retry\n\n\ndef create_symlink(source, link_name):\n    \"\"\"Create a symbolic link pointing to source named link_name.\n\n    Parameters\n    ----------\n    source: str\n        Source of the link\n    link_name: str\n        Link name.\n\n    Notes\n    -----\n    This function is a polyfill of the native ``os.symlink``\n    for Python 2.x on Windows platforms.\n    \"\"\"\n    create_symlinks([(source, link_name)], raise_on_error=True)\n\n\ndef create_symlinks(symlinks, raise_on_error=False):\n    \"\"\"Create multiple symbolic links in one call.\n\n    Parameters\n    ----------\n    symlinks: list[str]ing tuples\n        List of ``source`` and ``link_name`` of the symlinks as tuples.\n    \"\"\"\n    symlink, allow_polyfill_retry = _get_symlink_function()\n\n    try:\n        return symlink(symlinks, raise_on_error=True)\n    except OSError:\n        if raise_on_error:\n            raise\n\n        _set_symlink_function(_polyfill_symlinks)\n        return _polyfill_symlinks(symlinks, raise_on_error=False)\n\n\ndef remove_symlink(symlink):\n    \"\"\"Remove a symlink from the file system.\n\n    Parameters\n    ----------\n    symlink : str\n        Symlink to remove.\n    \"\"\"\n    # Broken links return False on .exists(), so we need to check .islink() as well\n    if not (os.path.islink(symlink) or os.path.exists(symlink)):\n        return\n\n    if os.path.isdir(symlink):\n        try:\n            os.rmdir(symlink)\n        except NotADirectoryError:\n            os.unlink(symlink)\n        except PermissionError:\n            if not is_windows():\n                raise\n\n            _run_command_as_admin(\"rmdir\", [symlink])\n    else:\n        os.unlink(symlink)\n\n\ndef remove_symlinks(symlinks, raise_on_error=False):\n    \"\"\"Remove one or more symlinks.\n\n    Parameters\n    ----------\n    links\n        Sequence of symlinks to remove.\n    raise_on_error : bool\n        ``False`` to continue removing even on error,\n        otherwise ``True``.\n\n    Returns\n    -------\n    list\n        If ``raise_on_error`` is ``False``, returns a list\n        of bools indicating which links were successfully removed.\n    \"\"\"\n    result = []\n\n    for symlink in symlinks:\n        try:\n            remove_symlink(symlink)\n            result.append(True)\n        except OSError:\n            if raise_on_error:\n                raise\n\n            result.append(False)\n\n    return result\n\n\ndef rename(src, dst):\n    \"\"\"Rename a file or directory.\"\"\"\n    try:\n        os.rename(src, dst)\n    except (PermissionError, OSError):\n        if not is_windows():\n            raise\n\n        _run_command_as_admin(\"move\", [src, dst])\n\n\ndef remove(path):\n    \"\"\"Remove path.\"\"\"\n    try:\n        os.remove(path)\n    except (PermissionError, OSError):\n        if not is_windows():\n            raise\n\n        _run_command_as_admin(\"del\", [path])\n\n\ndef copy(src, dst):\n    \"\"\"Copy a file from source to destination.\"\"\"\n    try:\n        shutil.copy(src, dst)\n    except (PermissionError, OSError):\n        if not is_windows():\n            raise\n\n        _run_command_as_admin(\"copy\", [src, dst])\n\n\ndef is_admin():\n    \"\"\"Determines whether the current user has admin rights.\n\n    Returns\n    -------\n    bool\n        True if the user is administrator, otherwise False.\n    \"\"\"\n    if not is_windows():\n        return os.getuid() == 0\n\n    try:\n        return bool(ctypes.windll.shell32.IsUserAnAdmin())\n    except:  # noqa: E722\n        return False\n\n\ndef _run_command_as_admin(command, arguments):\n    \"\"\"Run a single command as admin on Windows.\n\n    Parameters\n    ----------\n    command : str\n        Command name.\n    arguments : list[str]\n        List of arguments.\n    \"\"\"\n    _handle, temp_path = tempfile.mkstemp(suffix=\".cmd\", text=True)\n\n    with open(temp_path, \"w\") as remove_symlink_cmd:\n        remove_symlink_cmd.write(\"@echo off\\n\")\n        remove_symlink_cmd.write(\"{} {}\\n\".format(command, subprocess.list2cmdline(arguments)))\n\n    _run_as_admin([temp_path])\n\n\ndef _run_as_admin(command):\n    \"\"\"Run the specified command as an admin.\n\n    Paramters\n    ---------\n    command : list[str]\n        List of strings of the command to run.\n\n    Returns\n    -------\n    int\n        Exit code of the process.\n    \"\"\"\n\n    if not is_windows():\n        raise RuntimeError(\"Only supported on Windows\")\n\n    command_file, command_args = command[0], command[1:]\n\n    params = ShellExecuteInfo(\n        nShow=int(False),\n        fMask=SEE_MASK_NOCLOSEPROCESS | SEE_MASK_NO_CONSOLE,\n        lpVerb=b\"runas\",\n        lpFile=command_file.encode(\"cp1252\"),\n        lpParameters=subprocess.list2cmdline(command_args).encode(\"cp1252\"),\n    )\n\n    if not ctypes.windll.shell32.ShellExecuteExA(ctypes.byref(params)):\n        raise RuntimeError('Failed to run command \"%s\" as admin', command_file)\n\n    process_handle = params.hProcess\n    ctypes.windll.kernel32.WaitForSingleObject(process_handle, INFINITE)\n\n    ret = ctypes.wintypes.DWORD()\n    if ctypes.windll.kernel32.GetExitCodeProcess(process_handle, ctypes.byref(ret)) == 0:\n        raise RuntimeError(\"Failed to retrieve exit code\")\n\n    return ret.value\n\n\n# The following methods has been adapted from the appdirs package\n#\n# MIT license\n# Copyright (c) 2005-2010 ActiveState Software Inc.\n#\n# Copyright (c) 2013 Eddy Petri»ôor\n# http://github.com/ActiveState/appdirs\n\n\ndef user_data_dir(appname=None, appauthor=None, version=None, roaming=False):\n    r\"\"\"Return full path to the user-specific data dir for this application.\n\n    Parameters\n    ----------\n    appname : str\n        Name of application.\n        If ``None``, just the system directory is returned.\n    appauthor : str\n        Only used on Windows. Name of the appauthor or distributing body\n        for this application. Typically it is the owning company name.\n        This falls back to appname. You may pass ``False`` to disable it.\n    version : str\n        Version path element to append to the path.\n        You might want to use this if you want multiple versions\n        of your app to be able to run independently. If used, this\n        would typically be \"<major>.<minor>\".\n        Only applied when appname is present.\n    roaming : bool, optional\n        True to use the Windows roaming appdata directory, otherwise False.\n        That means that for users on a Windows network setup for roaming profiles,\n        this user data will be sync'd on login. See\n        <http://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx>\n        for a discussion of issues.\n\n    Returns\n    -------\n    str\n        Full path to the user-specific data dir.\n    \"\"\"\n    if is_windows():\n        if appauthor is None:\n            appauthor = appname\n        const = \"CSIDL_APPDATA\" if roaming else \"CSIDL_LOCAL_APPDATA\"\n        path = os.path.normpath(_get_win_folder(const))\n        if appname:\n            if appauthor is not False:\n                path = os.path.join(path, appauthor, appname)\n            else:\n                path = os.path.join(path, appname)\n\n    elif is_osx():\n        path = os.path.expanduser(\"~/Library/Application Support/\")\n        if appname:\n            path = os.path.join(path, appname)\n\n    elif is_mono():\n        path = os.path.expanduser(\"~/Library/Application Support/\")\n        if appname:\n            path = os.path.join(path, appname)\n\n    else:\n        # is_linux()\n        path = os.getenv(\"XDG_DATA_HOME\", os.path.expanduser(\"~/.local/share\"))\n        if appname:\n            path = os.path.join(path, appname)\n\n    if appname and version:\n        path = os.path.join(path, version)\n\n    return path\n\n\ndef _get_win_folder_from_registry(csidl_name):\n    \"\"\"This is a fallback technique at best. I'm not sure if using the\n    registry for this guarantees us the correct answer for all CSIDL_*\n    names.\n    \"\"\"\n    if PY3:\n        import winreg as _winreg\n    else:\n        import _winreg\n\n    shell_folder_name = {\n        \"CSIDL_APPDATA\": \"AppData\",\n        \"CSIDL_COMMON_APPDATA\": \"Common AppData\",\n        \"CSIDL_LOCAL_APPDATA\": \"Local AppData\",\n    }[csidl_name]\n\n    key = _winreg.OpenKey(\n        _winreg.HKEY_CURRENT_USER,\n        r\"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\",\n    )\n    dir, type = _winreg.QueryValueEx(key, shell_folder_name)\n    return dir\n\n\ndef _get_win_folder_with_pywin32(csidl_name):\n    from win32com.shell import shell\n    from win32com.shell import shellcon\n\n    dir = shell.SHGetFolderPath(0, getattr(shellcon, csidl_name), 0, 0)\n    # Try to make this a unicode path because SHGetFolderPath does\n    # not return unicode strings when there is unicode data in the\n    # path.\n    try:\n        dir = str(dir) if PY3 else unicode(dir)  # noqa: F821\n\n        # Downgrade to short path name if have highbit chars. See\n        # <http://bugs.activestate.com/show_bug.cgi?id=85099>.\n        has_high_char = False\n        for c in dir:\n            if ord(c) > 255:\n                has_high_char = True\n                break\n        if has_high_char:\n            try:\n                import win32api\n\n                dir = win32api.GetShortPathName(dir)\n            except ImportError:\n                pass\n    except UnicodeError:\n        pass\n    return dir\n\n\ndef _get_win_folder_with_ctypes(csidl_name):\n    csidl_const = {\n        \"CSIDL_APPDATA\": 26,\n        \"CSIDL_COMMON_APPDATA\": 35,\n        \"CSIDL_LOCAL_APPDATA\": 28,\n    }[csidl_name]\n\n    buf = ctypes.create_unicode_buffer(1024)\n    ctypes.windll.shell32.SHGetFolderPathW(None, csidl_const, None, 0, buf)\n\n    # Downgrade to short path name if have highbit chars. See\n    # <http://bugs.activestate.com/show_bug.cgi?id=85099>.\n    has_high_char = False\n    for c in buf:\n        if ord(c) > 255:\n            has_high_char = True\n            break\n    if has_high_char:\n        buf2 = ctypes.create_unicode_buffer(1024)\n        if ctypes.windll.kernel32.GetShortPathNameW(buf.value, buf2, 1024):\n            buf = buf2\n\n    return buf.value\n\n\nif is_windows():\n    try:\n        import win32com.shell  # noqa: F401\n\n        _get_win_folder = _get_win_folder_with_pywin32\n    except ImportError:\n        try:\n            from ctypes import windll  # noqa: F401\n\n            _get_win_folder = _get_win_folder_with_ctypes\n        except ImportError:\n            _get_win_folder = _get_win_folder_from_registry\n",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}