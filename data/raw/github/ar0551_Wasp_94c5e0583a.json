{
  "source_url": "https://github.com/ar0551/Wasp/blob/66f63c018f2420d37aa451ade0178de260946b0c/src/ghComp/Wasp_Rules%20Visualizer.py",
  "repo": "ar0551/Wasp",
  "repo_stars": 67,
  "repo_description": "Combinatorial Design with Grasshopper plug-in (LGPL) initiated by Andrea Rossi",
  "license": "LGPL-3.0",
  "filepath": "src/ghComp/Wasp_Rules Visualizer.py",
  "instruction": "Visualize the provided rules.\n-\nProvided by Wasp 0.6\n    Args:\n        PART: Parts from which to visualize the rules\n        R: Rules to visualize\n        SF: OPTIONAL // Spacing factor between rules...",
  "code": "# Wasp: Discrete Design with Grasshopper plug-in (LGPL) initiated by Andrea Rossi\n# \n# This file is part of Wasp.\n# \n# Copyright (c) 2017-2023, Andrea Rossi <a.rossi.andrea@gmail.com>\n# Wasp is free software; you can redistribute it and/or modify \n# it under the terms of the GNU Lesser General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Wasp is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU Lesser General Public License for more details.\n# \n# You should have received a copy of the GNU Lesser General Public License\n# along with Wasp; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license LGPL-3.0 https://www.gnu.org/licenses/lgpl-3.0.html\n#\n# Early development of Wasp has been carried out by Andrea Rossi\n# as part of research on digital materials and discrete design at:\n# DDU Digital Design Unit - Prof. Oliver Tessmann\n# Technische Universitt Darmstadt\n\n\n#########################################################################\n##                            COMPONENT INFO                           ##\n#########################################################################\n\n\"\"\"\nVisualize the provided rules.\n-\nProvided by Wasp 0.6\n    Args:\n        PART: Parts from which to visualize the rules\n        R: Rules to visualize\n        SF: OPTIONAL // Spacing factor between rules visualizations (2.0 by default)\n        PLN: OPTIONAL // If the rules should be visualized in a different location than the worldXY, base plane of the desired coordinate system\n        SI: OPTIONAL // True to show rule index in the list, False to hide it (True by default)\n        ST: OPTIONAL // True to show connection types, False to hide them (True by default)\n    Returns:\n        BP: Base part for the rule\n        NP: Added part for the rule\n        RTL: Rule text location\n        RT: Rule text\n\"\"\"\n\nghenv.Component.Name = \"Wasp_Rules Visualizer\"\nghenv.Component.NickName = 'RuleViz'\nghenv.Component.Message = 'v0.6.001'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"Wasp\"\nghenv.Component.SubCategory = \"3 | Rules\"\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"2\"\nexcept: pass\n\nimport sys\nimport Grasshopper as gh\nimport Rhino.Geometry as rg\nimport math\n\n\n## add Wasp install directory to system path\nwasp_loaded = False\nghcompfolder = gh.Folders.DefaultAssemblyFolder\nif ghcompfolder not in sys.path:\n    sys.path.append(ghcompfolder)\ntry:\n    from wasp import __version__\n    wasp_loaded = True\nexcept:\n    msg = \"Cannot import Wasp. Is the wasp folder available in \" + ghcompfolder + \"?\"\n    ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Error, msg)\n\n## if Wasp is installed correctly, load the classes required by the component\nif wasp_loaded:\n    pass\n\n\ndef main(parts, rules, spacing_factor, base_plane, show_index, show_types):\n    \n    check_data = True\n    \n    ##check inputs\n    if len(parts) == 0 or parts is None:\n        check_data = False\n        msg = \"No part provided\"\n        ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Warning, msg)\n    \n    if len(rules) == 0 or rules is None:\n        check_data = False\n        msg = \"No rules provided\"\n        ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Warning, msg)\n    \n    if spacing_factor == None:\n        spacing_factor = 2.0\n    \n    if show_index is None:\n        show_index = True\n    \n    if show_types is None:\n        show_types = True\n    \n    if check_data:\n        \n        spacing = 0\n        for part in parts:\n            if part.dim > spacing:\n                spacing = part.dim\n        spacing *= 2.0\n        spacing *= spacing_factor\n        \n        rows_count = int(math.ceil(math.sqrt(len(rules))))\n        \n        base_parts = []\n        next_parts = []\n        rule_texts = []\n        rule_text_locs = []\n        \n        if base_plane != None:\n            global_transform = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, base_plane)\n        \n        for x in range(rows_count):\n            for y in range(rows_count):\n                \n                rule_id = y + (x*rows_count)\n                if rule_id >= len(rules):\n                    break\n                \n                rule = rules[rule_id]\n                \n                first_part = None\n                for part in parts:\n                    if part.name == rule.part1:\n                        first_part = part\n                        break\n                \n                next_part = None\n                for part in parts:\n                    if part.name == rule.part2:\n                        next_part = part\n                        break\n                \n                grid_point = rg.Vector3d(x*spacing, y*spacing, 0)\n                move_vec = rg.Vector3d.Subtract(grid_point, rg.Vector3d(first_part.center))\n                move_trans = rg.Transform.Translation(move_vec)\n                first_part = first_part.transform(move_trans)\n                \n                if base_plane != None:\n                    first_part = first_part.transform(global_transform)\n                \n                orientTransform = rg.Transform.PlaneToPlane(next_part.connections[rule.conn2].flip_pln, first_part.connections[rule.conn1].pln)\n                next_part = next_part.transform(orientTransform)\n                \n                base_parts.append(first_part)\n                next_parts.append(next_part)\n                \n                text_loc = rg.Point3d(grid_point)\n                text_loc.X -= spacing*0.5\n                text_loc.Y -= spacing*0.5\n                \n                text_pln = rg.Plane(text_loc, rg.Vector3d.XAxis, rg.Vector3d.YAxis)\n                \n                if base_plane != None:\n                    text_pln.Transform(global_transform)\n                \n                text = rule.ToString()\n                text = text.replace(\"WaspRule [\", \"\")\n                text = text.replace(\"]\", \"\")\n                \n                if show_index:\n                    text = str(rule_id) + \": \" + text\n                \n                if show_types:\n                    text +=\"\\n\"\n                    text += \"%s>%s\"%(first_part.connections[rule.conn1].type, next_part.connections[rule.conn2].type)\n                \n                rule_texts.append(text)\n                rule_text_locs.append(text_pln)\n                \n            if rule_id >= len(rules):\n                break\n        return base_parts, next_parts, rule_texts, rule_text_locs\n    else:\n        return -1\n\nresult = main(PART, R, SF, PLN, SI, ST)\n\nif result != -1:\n    BP = result[0]\n    NP = result[1]\n    RT = result[2]\n    RTL = result[3]\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}