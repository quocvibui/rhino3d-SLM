{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Block_ScaleDefObjs.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Block_ScaleDefObjs.py",
  "instruction": "For a STEP export to include block instances, not their exploded results,\r\nthe block instances need to be at full scale and not mirrored.\r\nNote: For block definitions that are represented by a single...",
  "code": "\"\"\"\r\nFor a STEP export to include block instances, not their exploded results,\r\nthe block instances need to be at full scale and not mirrored.\r\nNote: For block definitions that are represented by a single block instance,\r\nthose instances will also be exploded on STEP export.\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n180709: Created, replacing EvaluateBlockInstanceScale.rvb.\r\n180725: Now supports multiple selected objects.\r\n181117: Refactored.  Added scale routine.\r\n190208: Various bug fixes.\r\n230718: Split from another script.\r\n251027: Refactored many places and removed reliance on rhinoscriptsyntax.\r\n        Added options for modifying block definitions and instances for STEP export.\r\n251101: Now, correctly scales nested instances when their definition units doesn't match\r\n        that of parent definition.\r\n        Now, prints number of scale unit changes for each starting unit.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bFixScalingForStepExport'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bScaleNonDocUnitBlocks'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fScale'; keys.append(key)\r\n    values[key] = 1.0/25.4\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key], True, Rhino.RhinoMath.SqrtEpsilon)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bInverselyScaleModDefsInsts'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if riOpts[key]:\r\n                values[key] = riOpts[key].CurrentValue = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fScale':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.values[key] = cls.riOpts[key].InitialValue\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                return\r\n\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key == 'fTol_IsEllipse':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < cls.riOpts[key].InitialValue:\r\n                cls.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.listValues:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = idxList\r\n\r\n        print(\"Invalid key?\")\r\n\r\n\r\ndef _staticBlockDefs():\r\n    \"\"\"\r\n    Static == Embedded only\r\n    \"\"\"\r\n\r\n    ret = []\r\n    for rdDef in sc.doc.InstanceDefinitions.GetList(ignoreDeleted=True):\r\n        if rdDef.UpdateType == rd.InstanceDefinitionUpdateType.Static:\r\n            ret.append(rdDef)\r\n    return ret\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get options.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetOption()\r\n    go.SetCommandPrompt(\"Set options\")\r\n\r\n    go.AcceptNothing(True)\r\n\r\n    idxs_Opts = {}\r\n\r\n    def addOption(key): idxs_Opts[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n        idxs_Opts.clear()\r\n\r\n        addOption('bFixScalingForStepExport')\r\n        if Opts.values['bFixScalingForStepExport']:\r\n            go.AcceptNumber(False, acceptZero=False)\r\n        else:\r\n            addOption('bScaleNonDocUnitBlocks')\r\n            if Opts.values['bScaleNonDocUnitBlocks']:\r\n                go.AcceptNumber(False, acceptZero=False)\r\n            else:\r\n                addOption('fScale')\r\n                go.AcceptNumber(True, acceptZero=False)\r\n            addOption('bInverselyScaleModDefsInsts')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        res = go.Get()\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            go.Dispose()\r\n            return True\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fScale'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opts:\r\n            if go.Option().Index == idxs_Opts[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef scaleContentsOfBlockDefinition(rdDef, fScale, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    if fScale <= 0.0:\r\n        print(\"fScale must be > 0.0. {} was provided\".format(fScale))\r\n        return\r\n\r\n    rdObjs_InBlock = rdDef.GetObjects()\r\n\r\n    if not rdObjs_InBlock:\r\n        if bEcho:\r\n            print(\"Block definition, {}, contains no objects, so it will not be processed.\".format(\r\n                rdDef.Name))\r\n        return\r\n\r\n    if fScale == 1.0:\r\n        scale = None\r\n    else:\r\n        scale = rg.Transform.Scale(\r\n            anchor=rg.Point3d.Origin,\r\n            scaleFactor=fScale)\r\n\r\n    geoms = []\r\n    attrs = []\r\n\r\n    for rdObj_InBlock in rdObjs_InBlock:\r\n        geom = rdObj_InBlock.Geometry\r\n        attr = rdObj_InBlock.Attributes\r\n\r\n        if isinstance(rdObj_InBlock, rd.InstanceObject):\r\n            #pt = rg.Point3d.Origin\r\n            #pt.Transform(rdObj_InBlock.InstanceXform)\r\n            pt = rdObj_InBlock.InsertionPoint\r\n\r\n            rdDef_ofNestedInst = rdObj_InBlock.InstanceDefinition\r\n            if rdDef_ofNestedInst.UnitSystem != rdDef.UnitSystem:\r\n                if bDebug:\r\n                    print(\"NOT EQUAL! {}, {}\".format(\r\n                        rdDef_ofNestedInst.UnitSystem, rdDef.UnitSystem))\r\n                scale_Inst = rg.Transform.Scale(\r\n                    anchor=pt,\r\n                    scaleFactor=Rhino.RhinoMath.UnitScale(\r\n                        rdDef.UnitSystem,\r\n                        rdDef_ofNestedInst.UnitSystem,\r\n                        )\r\n                    )\r\n                geom.Transform(scale_Inst)\r\n\r\n            if scale is not None:\r\n                translation = rg.Transform.Translation(fScale*pt - pt)\r\n                geom.Transform(translation)\r\n        else:\r\n            if scale is not None:\r\n                geom.Transform(scale)\r\n\r\n        geoms.append(rdObj_InBlock.Geometry)\r\n        attrs.append(rdObj_InBlock.Attributes)\r\n\r\n    return sc.doc.InstanceDefinitions.ModifyGeometry(rdDef.Index, geoms, attrs)\r\n\r\n\r\ndef _getInstanceScaleComponents(rdInst):\r\n    xform = rdInst.InstanceXform\r\n    return tuple(\r\n        [(xform[0,c]**2.0 + xform[1,c]**2.0 + xform[2,c]**2.0)**0.5 for c in (0,1,2)]\r\n        )\r\n\r\n\r\ndef scaleRootLevelInstances(rdDef, fScale, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    if fScale <= 0.0:\r\n        print(\"fScale must be > 0.0. {} was provided\".format(fScale))\r\n        return\r\n\r\n    rdInsts = rdDef.GetReferences(wheretoLook=0)\r\n    if not rdInsts:\r\n        if bDebug: print(\"No instances at root level for {}.\".format(rdDef.Name))\r\n        return\r\n\r\n    #sEval = \"fScale\"; print(sEval, '=', eval(sEval))\r\n\r\n    gInsts_Scaled = []\r\n    gFails = []\r\n\r\n    for rdInst in rdInsts:\r\n        pt = rg.Point3d.Origin\r\n        pt.Transform(rdInst.InstanceXform)\r\n        #sEval = \"pt\"; print(sEval, '=', eval(sEval))\r\n\r\n        xform_Scale = rg.Transform.Scale(\r\n            anchor=pt,\r\n            scaleFactor=fScale)\r\n\r\n        #id = scriptcontext.doc.Objects.Transform(old_id, xform, not copy)\r\n        rv = sc.doc.Objects.Transform(\r\n            obj=rdInst,\r\n            xform=xform_Scale,\r\n            deleteOriginal=True)\r\n\r\n        #if not rdInst.Geometry.Transform(xform_Scale):\r\n        #    print(\"Failed to scale the instance geometry of {}.\".format(rdDef.Name))\r\n        #    return\r\n\r\n        #rv = rdInst.CommitChanges() # CommitChanges doesn't work.\r\n\r\n        if bDebug: print(rv)\r\n        if rv != rdInst.Id:\r\n            print(\"Scaling {} failed.\".format(rdInst.Id))\r\n            gFails.append(rdInst.Id)\r\n        else:\r\n            gInsts_Scaled.append(rdInst.Id)\r\n            rdInst_Out = sc.doc.Objects.FindId(rv)\r\n            svs = _getInstanceScaleComponents(rdInst_Out)\r\n            for sv in svs:\r\n                if not Rhino.RhinoMath.EpsilonEquals(sv, 1.0, epsilon=Rhino.RhinoMath.Epsilon):\r\n                    print(\"Warning, instance {} of block {} is not at full scale, but instead {}, {}, {}\".format(\r\n                        rdInst_Out.Id, rdDef.Name, *svs))\r\n                    break\r\n\r\n    return gInsts_Scaled\r\n\r\n    #print(\"Scaled {} root-level instance(s) by {:.20g} about their insertion points.\".format(\r\n    #        n_Insts_processed, 1.0/fScale))\r\n\r\n\r\ndef main():\r\n\r\n    rdDefs_Static = _staticBlockDefs()\r\n\r\n    if not rdDefs_Static:\r\n        print(\"Document has no static block definitions.\")\r\n        return\r\n\r\n    if False: #sc.doc.Modified:\r\n        showMessageResult = Rhino.UI.Dialogs.ShowMessage(\r\n            message=\"This document has been modified since the last save.\" \\\r\n                \"\\n\\nIn the case that this script produces erroneous results,\" \\\r\n                \" it is recommended to first press the Cancel button\" \\\r\n                \" then _Save or _SaveACopy before proceeding.\" \\\r\n                \"\\n\\nPress OK to continue fixing the scaling.\",\r\n            title=\"Document Not Saved\",\r\n            buttons=Rhino.UI.ShowMessageButton.OKCancel,\r\n            icon=Rhino.UI.ShowMessageIcon.Warning)\r\n        if showMessageResult == Rhino.UI.ShowMessageResult.Cancel:\r\n            return\r\n\r\n    rv = getInput()\r\n    if rv is None: return\r\n\r\n    bFixScalingForStepExport = Opts.values['bFixScalingForStepExport']\r\n    if bFixScalingForStepExport:\r\n        bScaleNonDocUnitBlocks = True\r\n        fScale = None\r\n        bInverselyScaleModDefsInsts = True\r\n    else:\r\n        bScaleNonDocUnitBlocks = Opts.values['bScaleNonDocUnitBlocks']\r\n        fScale = Opts.values['fScale']\r\n        bInverselyScaleModDefsInsts = Opts.values['bInverselyScaleModDefsInsts']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = True\r\n\r\n    if bScaleNonDocUnitBlocks:\r\n        rdDefs_toProcess = []\r\n        for rdDef in rdDefs_Static:\r\n            if rdDef.UnitSystem != sc.doc.ModelUnitSystem:\r\n                rdDefs_toProcess.append(rdDef)\r\n                continue\r\n            rdObjs_InBlock = rdDef.GetObjects()\r\n            if not rdObjs_InBlock:\r\n                continue\r\n            for rdObj_InBlock in rdObjs_InBlock:\r\n                if not isinstance(rdObj_InBlock, rd.InstanceObject):\r\n                    continue\r\n                rdDef_ofNestedInst = rdObj_InBlock.InstanceDefinition\r\n                if rdDef_ofNestedInst.UnitSystem != rdDef.UnitSystem:\r\n                    rdDefs_toProcess.append(rdDef)\r\n                    break\r\n\r\n        #rdDefs_toProcess = [rdDef for rdDef in rdDefs_Static if rdDef.UnitSystem != sc.doc.ModelUnitSystem]\r\n        if not rdDefs_toProcess:\r\n            print(\"No block definitions exist whose units are not {}, the document units.\".format(\r\n                sc.doc.ModelUnitSystem))\r\n            return\r\n    else:\r\n        rdDefs_toProcess = rdDefs_Static\r\n\r\n\r\n    #res, bProceed = ri.RhinoGet.GetBool(\r\n    #    prompt=\"{} block definitions to have their contents scaled. Proceed?\".format(\r\n    #            len(rdDefs_toProcess)),\r\n    #    acceptNothing=True,\r\n    #    offPrompt=\"No\", onPrompt=\"Yes\", boolValue=False)\r\n    #if res != Rhino.Commands.Result.Success or not bProceed:\r\n    #    print(\"Nothing was modified.\")\r\n    #    return\r\n\r\n\r\n    rdDefs_Scaled = []\r\n    rdInsts_Scaled = []\r\n    units_Previous = []\r\n\r\n    if bScaleNonDocUnitBlocks:\r\n        if bDebug: print(\"Doc unit: {}\".format(sc.doc.ModelUnitSystem))\r\n\r\n        rdDefs_Processed_Stage1 = []\r\n\r\n        for rdDef in rdDefs_toProcess:\r\n            if bDebug: print(\"{} unit: {}\".format(rdDef.Name, rdDef.UnitSystem))\r\n            if rdDef.UnitSystem == sc.doc.ModelUnitSystem:\r\n                if bDebug: print(\"Units match, so this block definition should contain instances of definitions with units that do not match this definition.\")\r\n                fScale_ThisBlock = 1.0\r\n            else:\r\n                fScale_ThisBlock = Rhino.RhinoMath.UnitScale(\r\n                    rdDef.UnitSystem,\r\n                    sc.doc.ModelUnitSystem)\r\n            if bDebug: print(\"Will scale block objects by {}.\".format(fScale_ThisBlock))\r\n\r\n            rv = scaleContentsOfBlockDefinition(\r\n                rdDef,\r\n                fScale=fScale_ThisBlock,\r\n                bEcho=bEcho,\r\n                bDebug=bDebug)\r\n            if rv:\r\n                rdDefs_Scaled.append(rdDef)\r\n            else:\r\n                print(\"Failed to scale contents of {}.\".format(rdDef.Name))\r\n                continue\r\n\r\n            rdDefs_Processed_Stage1.append(rdDef)\r\n\r\n        rdDefs_toProcess_Stage2 = rdDefs_Processed_Stage1\r\n\r\n        # Stage 2. UnitSystem was not modified in Stage 1 to allow correct scaling\r\n        # of nested instances with units not matching that of the parent definition.\r\n        # For example, cm definition instance inside a mm definition.\r\n\r\n        for rdDef in rdDefs_toProcess_Stage2:\r\n            units_Previous.append(rdDef.UnitSystem)\r\n            rdDef.UnitSystem = sc.doc.ModelUnitSystem\r\n\r\n            if bInverselyScaleModDefsInsts:\r\n                rv = scaleRootLevelInstances(\r\n                    rdDef,\r\n                    fScale=1.0/fScale_ThisBlock,\r\n                    bEcho=bEcho,\r\n                    bDebug=bDebug)\r\n                if bDebug: print(rv)\r\n                if rv is None: continue\r\n                rdInsts_Scaled.extend(rv)\r\n    else:\r\n        for rdDef in rdDefs_toProcess:\r\n\r\n            rv = scaleContentsOfBlockDefinition(\r\n                rdDef,\r\n                fScale=fScale,\r\n                bEcho=bEcho,\r\n                bDebug=bDebug)\r\n            if rv:\r\n                rdDefs_Scaled.append(rdDef)\r\n            else:\r\n                print(\"Failed to scale contents of {}.\".format(rdDef.Name))\r\n                continue\r\n\r\n            if bInverselyScaleModDefsInsts:\r\n                rv = scaleRootLevelInstances(\r\n                    rdDef,\r\n                    fScale=1.0/fScale,\r\n                    bEcho=bEcho,\r\n                    bDebug=bDebug)\r\n                if bDebug: print(rv)\r\n                if rv is None: continue\r\n                rdInsts_Scaled.extend(rv)\r\n\r\n\r\n    print(\"Scaled objects in {} definitions.\".format(len(rdDefs_Scaled)))\r\n    print(\"Scaled {} root-level instances.\".format(len(rdInsts_Scaled)))\r\n    if units_Previous:\r\n        ss = []\r\n        for unit in set(units_Previous):\r\n            ss.append(\"{} of {}\".format(\r\n                units_Previous.count(unit), unit))\r\n        print(\"Set block definitions to {}:\".format(sc.doc.ModelUnitSystem), \", \".join(ss))\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}