{
  "source_url": "https://github.com/caadxyz/caad4rhino/blob/d3df5a030b2bd0ab58954fb341f04a4e814835d9/dev/caad/physics/SunPath.py",
  "repo": "caadxyz/caad4rhino",
  "repo_stars": 22,
  "repo_description": " Caad4Rhino is a python package whose purpose is to provide computer aided architectural design tools in rhino 3d software",
  "license": "LGPL-3.0",
  "filepath": "dev/caad/physics/SunPath.py",
  "instruction": "Copyright\ncreate on 2020.02.28\n@author mahaidong",
  "code": "#coding=utf-8\n'''\nCopyright\ncreate on 2020.02.28\n@author mahaidong\n\ndescription:\n'''\nimport math\nfrom datetime import datetime, timedelta\nimport time\nimport Rhino\nimport rhinoscriptsyntax as rs\n\nclass SunPath:\n    def __init__(self,theLatitude, theLongitude, GMT ):\n        self.latitude = theLatitude\n        self.longitude = theLongitude\n        self.GMT = GMT\n\n    def calculateSunFromLocalDatetime( self, theLocalDatetime ):\n        utcDatetime = theLocalDatetime - timedelta( hours=self.GMT )\n        return self.__calculateSunPosition( utcDatetime )\n    \n    def __calculateSun(self, theUtcDatetime ):\n        localDatetime = theUtcDatetime + timedelta( hours=self.GMT )\n        \"\"\"\n        brief Calculates the sun light. \n        CalcSunPosition calculates the suns \"position\" based on a \n        given date and time in local time, latitude and longitude \n        expressed in decimal degrees. It is based on the method \n        found here: \n        http://guideving.blogspot.com/2010/08/sun-position-in-c.html\n        The calculation is only satisfiably correct for dates in \n        the range March 1 1900 to February 28 2100. \n        param latitude Latitude expressed in decimal degrees. \n        param longitude Longitude expressed in decimal degrees. \n        \"\"\"\n        Deg2Rad = math.pi/180.0\n        Rad2Deg = 180.0/math.pi\n        # Number of days from J2000.0.\n        julianDate = 367 * theUtcDatetime.year - \\\n                math.floor((7.0 / 4.0) * (theUtcDatetime.year + \\\n                math.floor((theUtcDatetime.month + 9.0) / 12.0))) + \\\n                math.floor((275.0 * theUtcDatetime.month ) / 9.0) +  theUtcDatetime.day - 730531.5\n        julianCenturies = julianDate / 36525.0\n\n        # Sidereal Time  \n        SECONDS_PER_MINUTE  = 60\n        SECONDS_PER_HOUR    = 3600\n        totalHours = theUtcDatetime.hour + theUtcDatetime.minute/60.0 + theUtcDatetime.second/3600.0\n        siderealTimeHours = 6.6974 + 2400.0513 * julianCenturies\n        siderealTimeUT = siderealTimeHours +  (366.2422 / 365.2422) * totalHours\n        siderealTime = siderealTimeUT * 15 + self.longitude\n\n        # Refine to number of days (fractional) to specific time.\n        julianDate += totalHours / 24.0\n        julianCenturies = julianDate / 36525.0\n\n        #Solar Coordinates\n        meanLongitude = SunPath.CorrectAngle( Deg2Rad * (280.466 + 36000.77 * julianCenturies))\n\n        meanAnomaly = SunPath.CorrectAngle( Deg2Rad * (357.529 + 35999.05 * julianCenturies))\n\n        equationOfCenter = Deg2Rad * ((1.915 - 0.005 * julianCenturies) * math.sin(meanAnomaly) + \\\n                0.02 * math.sin(2 * meanAnomaly))\n\n        elipticalLongitude = SunPath.CorrectAngle(meanLongitude + equationOfCenter)\n\n        obliquity = (23.439 - 0.013 * julianCenturies) * Deg2Rad\n\n        # Right Ascension  \n        rightAscension = math.atan2( math.cos(obliquity) * math.sin(elipticalLongitude),  \n                math.cos(elipticalLongitude));  \n          \n        declination = math.asin( math.sin(rightAscension) * math.sin(obliquity))\n\n        # Horizontal Coordinates\n        hourAngle = SunPath.CorrectAngle(siderealTime * Deg2Rad) - rightAscension\n\n        if (hourAngle > math.pi):\n            hourAngle -= 2 * math.pi\n  \n        altitude = math.asin(math.sin( self.latitude * Deg2Rad) * math.sin(declination) + \\\n                math.cos( self.latitude * Deg2Rad) * math.cos(declination) * math.cos(hourAngle))\n\n        # Nominator and denominator for calculating Azimuth\n        # angle. Needed to test which quadrant the angle is in.\n        aziNom = -math.sin(hourAngle)\n        aziDenom = math.tan(declination) * math.cos( self.latitude * Deg2Rad) - \\\n                math.sin( self.latitude * Deg2Rad) * math.cos(hourAngle)\n\n        azimuth = math.atan(aziNom / aziDenom)\n\n        if (aziDenom < 0): \n            # In 2nd or 3rd quadrant\n            azimuth += math.pi\n        elif (aziNom < 0): \n            # In 4th quadrant\n            azimuth += 2 * math.pi\n\n        \n        #radian\n        return Sun(localDatetime, altitude, azimuth)\n\n    @staticmethod\n    def CorrectAngle( angleInRadians ):\n        if angleInRadians < 0:\n            return 2 * math.pi - (math.fabs(angleInRadians) % (2 * math.pi))\n        elif angleInRadians > 2 * math.pi :\n            return angleInRadians % (2 * math.pi)\n        else:\n            return angleInRadians\n\n    def calculateSunriseSunset(self, year, month, day):\n        pass\n    \n    def drawSunPath(self):\n        pass\n\nclass Sun:\n    def __init__(self, datetime, altitude, azimuth ):\n        self.datetime = datetime\n        self.altitude = altitude\n        self.azimuth = azimuth\n        self.sunVector = self._calculateSunVector() \n\n    def _calculateSunVector(self):\n        \"\"\"\n        sunVector = rs.VectorRotate( (0,1,0), -(azimuth*180/math.pi), (0,0,1) )\n        return rs.VectorRotate( sunVector, altitude*180/math.pi, rs.VectorCrossProduct( sunVector,(0,0,1)) )\n        \"\"\"\n        northVector = Rhino.Geometry.Vector3d(0,1,0)\n        zAxis = Rhino.Geometry.Vector3d(0,0,1)\n        northVector.Rotate( -self.azimuth, zAxis )\n        northVector.Rotate( self.altitude, Rhino.Geometry.Vector3d.CrossProduct(northVector,zAxis) )\n        return northVector\n\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}