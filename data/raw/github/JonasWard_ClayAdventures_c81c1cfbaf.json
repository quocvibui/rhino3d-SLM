{
  "source_url": "https://github.com/JonasWard/ClayAdventures/blob/70e453eab058ddb92ad4ee34f3148155e4c1cf31/src/ghPython/PatternBrickLibrary/patternGenv3_0.py",
  "repo": "JonasWard/ClayAdventures",
  "repo_stars": 3,
  "repo_description": "A width range of different tests and experiments for fdm clay printing",
  "license": "MIT",
  "filepath": "src/ghPython/PatternBrickLibrary/patternGenv3_0.py",
  "instruction": "Pattern genv3 0",
  "code": "import Rhino.Geometry as rg\nimport math\nimport random\nfrom vertexClass import Vertex\nfrom copy import deepcopy as dc\n\n\nclass Dot2D:\n\n    def __init__(self, location = None, direction = 1.0, radius = 5.0, n_max_val = 5.0, rot_alfa = None, xy_scale_vals = (1.0, 1.0), top_rad = None, bot_rad = None):\n\n        self.update_parameters(location, direction, radius, n_max_val, rot_alfa, xy_scale_vals, top_rad, bot_rad)\n\n    def update_parameters(self, location = None, direction = 1.0, radius = 5.0, n_max_val = 5.0, rot_alfa = None, xy_scale_vals = (1.0, 1.0), top_rad = None, bot_rad = None):\n\n        self.loc = location\n        self.dir = direction\n        self.r = radius\n        self.n_max_val = n_max_val\n\n        self.special = False\n        self.rot_scale = False\n        self.xy_scale = False\n\n        # dealing with cylinder 2dDotMaps\n\n        if bot_rad == None and top_rad == None:\n\n            self.top_rad = radius\n            self.bot_rad = radius\n\n        elif bot_rad == None:\n\n            self.top_rad = top_rad\n            self.bot_rad = top_rad\n\n        else:\n\n            self.top_rad = radius\n            self.bot_rad = top_rad\n\n        self.delta_r = self.top_rad - self.bot_rad\n\n        self.h = radius\n\n        if not(self.rot_scale == None):\n\n            self.special = True\n\n            self.rot_scale = True\n\n            self.rot_alfa = rot_alfa\n\n        if not(self.rot_scale == None):\n\n            self.special = True\n\n            self.xy_scale = True\n\n            (self.x_scale, self.y_scale) = xy_scale_vals\n\n            self.h = radius * self.y_scale\n\n        self.h_h = self.h * .5\n\n    def scale_input_pt(self, pt):\n\n        loc_pt = pt - self.loc\n\n        if self.xy_scale:\n\n            loc_pt = rg.Point3d(loc_pt.X * self.x_scale, loc_pt.Y * self.y_scale, 0.0)\n\n        if self.rot_scale:\n            \n            rot_m = rg.Transform.Rotation(rg.Point3d(0,0,0), self.rot_alfa)\n\n            loc_pt.Transform(rot_m)\n\n        return loc_pt + self.loc\n\n    def get_distance(self, pt):\n\n        # saving the last distance into the instance, so it doesn't have to be recalcuated later\n\n        if self.special:\n\n            pt = self.scale_input_pt(pt)\n\n        self.rel_loc_pt = self.loc - pt\n        \n        self.working_dis = 1.0 - self.loc.DistanceTo(pt) / self.r\n\n        if self.working_dis < 0.0:\n\n            self.working_dis = 0.0\n\n        return self.working_dis\n\nclass PyramidDot2D(Dot2D):\n\n    @ property\n    def move_val(self):\n\n        # linear trajectory\n\n        return self.working_dis * self.dir * self.n_max_val\n\nclass EllipsoidDot2D(Dot2D):\n\n    @ property\n    def move_val(self):\n\n        # ellipsoid trajectory\n\n        elliptical_remap = (1.0 - (self.working_dis / self.r) ** 2.0) ** .5\n\n        return elliptical_remap * self.n_max_val * self.dir * self.n_max_val\n\nclass CylinderDot2D(Dot2D):\n\n    @ property\n    def move_val(self):\n\n        # this one is special\n\n        x_dis, y_dis = abs(self.rel_loc_pt.X), self.rel_loc_pt.Y\n\n        if abs(y_dis) < self.h_h:\n\n            local_r = self.bot_rad + self.delta_r * (y_dis / self.h_h)\n\n        else:\n\n            local_r = -1\n\n        if x_dis < local_r:\n\n            elliptical_remap = (1.0 - (x_dis / local_r) ** 2.0) ** .5\n\n            scale_val =  elliptical_remap * self.dir * self.n_max_val\n\n        else:\n\n            scale_val = 0.0\n\n        return scale_val\n\nclass ConstraintRec:\n\n    def __init__(self, b_pt, x_l, y_l):\n\n        self.b_pt = b_pt\n\n        x_interval = rg.Interval(b_pt[0] - x_l * .5, b_pt[0] + x_l * .5)\n        y_interval = rg.Interval(b_pt[1] - y_l * .5, b_pt[1] + y_l * .5)\n\n        self.constraint = rg.Rectangle3d(rg.Plane.WorldXY, x_interval, y_interval)\n\n    def constraint_trimming(self, pt):\n\n        return self.constraint.Contains(pt) == rg.PointContainment.Inside\n\n    def constraint_radius(self, b_pt):\n\n        distances = [corner.DistanceTo(b_pt) for corner in self.corners]\n\n        return max(distances)\n\n    @ property\n    def corners(self):\n\n        return [self.constraint.Corner[i] for i in range(4)]\n\n    def constraint_rotation(self, alfa, b_pt = None):\n\n        if b_pt == None:\n\n            b_pt = self.b_pt\n\n        rot = rg.Transform.Rotation(b_pt, alfa)\n\n        return_pts = [rg.Point3d(pt) for pt in self.corners]\n\n        [pt.Transform(rot) for pt in return_pts]\n\n        return return_pts\n\n\nclass DotMap2D:\n\n    MAX_DOTS = 250\n\n    RND_SEED = 1\n\n    def __init__(self, spacing, constraint, spacing_y = None, rotation_angle = None, dot_type = PyramidDot2D()):\n\n        self.spacing = spacing\n        self.constraint = constraint\n\n        self.dot_type = dot_type\n        \n        if spacing_y == None:\n\n            self.spacing_y = self.spacing\n            self.spacing_y_factor = 1.0\n\n        else:\n\n            self.spacing_y = spacing_y\n            self.spacing_y_factor = spacing_y / spacing\n\n        if rotation_angle == None:\n\n\n            self.rotate = False\n\n        else:\n\n            self.rotate = True\n            self.rot_a = rotation_angle\n\n        # def random values\n\n        self.rnd = False\n\n        self.rnd_culling = False\n        self.rnd_in_out = False\n        self.rnd_g_scaling = False\n        self.rnd_y_scaling = False\n        self.rnd_rotation = False\n        self.rnd_move = False\n\n        self.dots = []\n\n        random.seed(DotMap2D.RND_SEED)\n\n    def get_closest(self, pt):\n\n        distances = [dot.get_distance(pt) for dot in self.dots]\n\n        i = distances.index(min(distances) )\n\n        return self.dots[i]\n\n    def get_move(self, vertex):\n\n        dot = self.get_closest(vertex.vec_version)\n\n        n_val = dot.move_val\n\n        vertex.warp_pt(n_val)\n\n    def random_settings(self, culling = False, cull_percentage = 0.0, random_in_out = False, percentage_in = .5, global_scale_random = False, global_scale_delta = 0.0, y_scale_random = False, y_scale_delta = .0, n_scale_random = False, n_scale_delta = 0.0, rotation_random = False, angle = .5, move_random = False, quantity = 0.0):\n\n        if culling or random_in_out or y_scale_random or rotation_random or move_random:\n\n            self.rnd = True\n\n            if culling:\n\n                self.rnd_culling = True\n                self.rnc_cull_percentage = cull_percentage\n\n            if random_in_out:\n\n                self.rnd_in_out = True\n                self.rnd_in_percentage = percentage_in\n\n            if global_scale_random:\n\n                self.rnd_g_scaling = True\n                self.rnd_g_scale = global_scale_delta\n\n            if y_scale_random:\n\n                self.rnd_y_scaling = True\n                self.rnd_y_scale = y_scale_delta\n\n            if n_scale_random:\n\n                self.rnd_n_scaling = True\n                self.rnd_n_scale = n_scale_delta\n\n            if rotation_random:\n\n                self.rnd_rotation = True\n                self.rnd_rot_angle = angle\n\n            if move_random:\n\n                self.rnd_move = True\n                self.rnd_move_dis = quantity\n\n    def random_f(self, pt):\n\n        add_pt = True\n        direction = 1.0\n        g_scaling = 1.0\n        y_scaling = 1.0\n        alfa = 0.0\n        move_vec = rg.Point3d(0,0,0)\n\n        if self.rnd_culling:\n\n            add_pt = random.random() > self.rnd_culling\n\n        if add_pt:\n\n            if self.rnd_in_out:\n\n                if random.random() < self.rnd_in_percentage:\n\n                    direction = -1.0\n\n            if self.rnd_g_scaling:\n\n                g_scaling = 1.0 + (random.random() * 2.0 - 1.0) * self.rnd_g_scale\n\n            if self.rnd_y_scaling:\n\n                y_scaling = (1.0 + (random.random() * 2.0 - 1.0) * self.rnd_y_scale) * g_scaling\n\n            if self.rnd_n_scaling:\n\n                n_scaling = 1.0 + (random.random() * 2.0 - 1.0) * self.rnd_n_scale\n\n            if self.rnd_rotation:\n\n                alfa = (random.random() * 2.0 - 1.0) * self.rnd_rotation\n\n            if self.rnd_move:\n                \n                loc_alfa = random.random() * math.pi * 2.0\n                radius = random.random() * self.rnd_move_dis\n\n                move_vec = rg.Point3d(\n                    x = math.cos(loc_alfa) * radius,\n                    y = math.sin(loc_alfa) * radius,\n                    z = 0\n                )\n\n        return add_pt, direction, (g_scaling, y_scaling), n_scaling, alfa, move_vec\n\n    def add_pt(self, pt):\n\n        add_pt = self.constraint.constraint_trimming(pt)\n        dot = dc(self.dot_type)\n\n        if self.rnd and add_pt:\n\n            add_pt, d, xy_sc, n_sc, alfa, move_vec = self.random_f(pt)\n\n            loc = pt + move_vec\n            direction = self.dot_type.dir * direction\n\n            r, b_r, t_r, n = dot.r, dot.bot_rad, dot.top_rad, dot.n_max_val\n\n            dot.update_parameters(loc, d, r, n * n_sc, alfa, xy_sc, t_r, b_r)\n\n        elif add_pt:\n\n            dot.loc = pt\n\n        if add_pt:\n\n            self.dots.append(dot)\n\n\nclass RectangularDotMap(DotMap2D):\n\n    def alfa_rec(self):\n\n        pts = self.constraint.constraint_rotation( -1 * self.rot_a, self.b_pt)\n\n        x_s = [pt.X for pt in pts]\n        y_s = [pt.Y for pt in pts]\n\n        x_min, x_max = min(x_s), max(x_s)\n        y_min, y_max = min(y_s), max(y_s)\n\n        c_a, s_a = math.cos(self.rot_a), math.sin(self.rot_a)\n\n        x_axis = rg.Point3d(c_a * self.spacing, s_a * self.spacing, 0.0)\n        y_axis = rg.Point3d(-s_a * self.spacing_y, c_a * self.spacing_y, 0.0)\n\n        x_range_min = int( math.ceil( (self.b_pt.X - x_min) / self.spacing) )\n        x_range_max = int( math.ceil( (x_max - self.b_pt.X) / self.spacing) )\n\n        y_range_min = int( math.ceil( (self.b_pt.Y - y_min) / self.spacing_y) )\n        y_range_max = int( math.ceil( (y_max - self.b_pt.Y) / self.spacing_y) )\n\n        return x_axis, y_axis, (x_range_min, x_range_max), (y_range_min, y_range_max)\n\n    def make_dot_map(self, b_pt = None):\n\n        if b_pt == None:\n\n            self.b_pt = self.constraint.b_pt\n\n        else:\n            \n            self.b_pt = b_pt\n\n        self.dots = []\n\n        x_axis, y_axis, x_range, y_range = self.alfa_rec()\n\n        (x_min, x_max) = x_range\n        (y_min, y_max) = y_range\n\n        if (x_max - x_min + 1) * (y_max - y_min + 1) > DotMap2D.MAX_DOTS:\n\n            print(\"too many points\")\n\n        else:\n\n            for i in range(x_min, x_max, 1):\n\n                x_add = i * x_axis\n\n                for j in range(y_min, y_max, 1):\n\n                    y_add = j * y_axis\n\n                    self.add_pt(self.b_pt + x_add + y_add)\n\n\nclass FibonacciSpiralDotMap(DotMap2D):\n\n    def make_dot_map(self, b_pt, start_angle = 0.0):\n\n        self.dots = []\n\n        i = 0\n        r = 0\n\n        add_pt = True\n\n        stop_r = self.constraint.constraint_radius(b_pt)\n\n        while i < DotMap2D.MAX_DOTS and r < stop_r:\n\n            r = self.spacing * math.sqrt(i)\n            theta = i * 2.4 + start_angle\n            \n            pt = rg.Point3d(\n                x = b_pt[0] + math.cos(theta) * r,\n                y = b_pt[1] + math.sin(theta) * r,\n                z = 0\n            )\n\n            i+=1\n        \n            self.add_pt(pt)\n\n\nclass PatternMap:\n\n    DOT_MAP_RND = False\n    DOT_MAP_RND_SEED = 0\n    Y_SPACING_FACTOR = 1.0\n\n    def __init__(self, layer_set, set_tuples, periodic = False, other_set = None):\n\n        # set_tuples = (crv_l, div_l, lay_h)\n\n        self.pattern_set = layer_set\n\n        if not(other_set == None):\n\n            self.add_other_set = True\n            self.other_set = other_set\n\n        else:\n            \n            self.add_other_set = False\n\n        self.length, _, self.lay_h = set_tuples\n\n        self.div_c = len(self.pattern_set[0])\n        self.lay_c = len(self.pattern_set)\n\n        self.height = self.lay_c * self.lay_h\n\n        self.periodic = periodic\n\n        self.closed = True\n        self.curved = False\n\n    def build(self):\n\n        self.surface_set = []\n\n        for pattern_layer in self.pattern_set:\n\n            self.surface_set.extend(pattern_layer)\n\n    def edgeEasing(self, zero_length, normal_length):\n\n        ease_delta = normal_length - zero_length\n\n        for pt in self.surface_set:\n\n            if pt.x_val < zero_length or pt.x_val > self.length - zero_length:\n\n                pt.n_scale = 0.0\n\n            elif pt.x_val < normal_length:\n\n                pt.n_scale = abs(pt.x_val - zero_length) / ease_delta\n                \n            elif pt.x_val > self.length - normal_length:\n\n                pt.n_scale = abs(pt.x_val - (self.length - zero_length)) / ease_delta\n\n    def sinWarp(self, period, amplitude, phase_shift, direction = True):\n\n        if self.periodic:\n\n            print(\"sin periodicizing\")\n            print(\"updating the period\")\n            print(\"old period: %s\" %period)\n\n            period_count = math.ceil( self.length / ( 2 * math.pi * period ) )\n\n            period = self.length / (period_count * 2 * math.pi)\n\n            print(\"new period: %s\" %period)\n\n        for pt in self.surface_set:\n\n            local_phase = pt.y_val / self.lay_h * phase_shift\n\n            scale_val = math.sin(pt.x_val / period + local_phase) * amplitude\n\n            if not(direction):\n\n                scale_val = - scale_val\n\n            pt.warp_pt(scale_val)\n\n    def patternGeneration(self, pattern_set, spacing):\n\n        if self.periodic:\n\n            print(\"pattern periodicizing\")\n            print(\"updating the spacing\")\n            print(\"old spacing: %s\" %spacing)\n\n            scaling_int_val = math.ceil(self.length / spacing)\n            spacing = self.length / scaling_int_val\n\n            print(\"new spacing: %s\" %spacing)\n\n        else:\n\n            spacing = spacing\n\n        # pattern_map (start, step, count)\n        # only have to consider x distance\n\n        layer_set = []\n        layer_count = 0\n        layer_length_vals = []\n\n        for pattern in pattern_set:\n\n            start, step, count = pattern[0], pattern[1], pattern[2]\n\n            if count < 1:\n\n                count = 1\n\n            layer_vertexes = []\n            length_vals = []\n            \n            x_val = start\n\n            x_delta = step * spacing\n\n            while x_val < self.length:\n\n                layer_vertexes.append(Vertex(x_val = x_val))\n                length_vals.append(x_val)\n\n                x_val += x_delta\n\n            for i in range(count):\n\n                layer_set.append(layer_vertexes)\n                layer_length_vals.append(length_vals)\n\n            layer_count += count\n\n        return layer_set, layer_length_vals, layer_count\n\n    def curveSplitAtPoints(self, radius, length_vals):\n\n        pass\n\n\n    def specialLayerMap(self, spacing, pattern_set, radius, max_val, direction = True):\n\n        _, layer_length_vals, layer_count = self.patternGeneration(pattern_set, spacing)\n\n    def modBasedDotMap(self, x_spacing = 20.0, y_spacing = 20.0, max_val = 10.0, ellipsoid = True, direction = True, layer_shift = 2.0, shift_a = 0.0, shift_b = 0.0, rot_alfa = 0.0):\n\n        if self.periodic:\n\n            x_scale_val = 1.0\n            y_scale_val = 1.0\n\n        else:\n\n            x_scale_val = 1.0\n            y_scale_val = 1.0\n\n        for pt in self.surface_set:\n\n            # distance = pt.distance_function(x_spacing, y_spacing, layer_shift, rot_alfa, x_scale_val, y_scale_val)\n            distance = pt.distance_function(x_spacing, y_spacing, layer_shift, rot_alfa)\n\n            # applying shift values if necessary\n            if not(shift_a == 0.0):\n\n                distance *= shift_a\n\n            if not(shift_b == 0.0):\n\n                distance += shift_b\n\n            # curtaling the distances\n            if distance < 0.0:\n\n                scale_val = 0.0\n\n            elif distance > 1.0:\n\n                scale_val = max_val\n\n            else:\n\n                if ellipsoid:\n\n                    distance = (1 - (1 - distance) ** 2.0) ** .5\n\n                scale_val = max_val * distance\n\n            if not(direction):\n\n                scale_val = - scale_val\n\n            pt.warp_pt(scale_val) \n    \n    def layerMap(self, spacing, pattern_set, radius, max_val, direction = True):\n\n        # pattern_map (start, step, count)\n        # only have to consider x distance\n\n        layer_set, _, layer_count = self.patternGeneration(pattern_set, spacing)\n\n        # subdividing in layers\n        for pt_i, pt in enumerate(self.surface_set):\n\n            layer_index = (pt_i - pt_i % self.div_c) / self.div_c\n\n            pattern_layer_index = int(layer_index % layer_count)\n\n            dots = layer_set[pattern_layer_index]\n\n            dis_set = []\n\n            for dot in dots:\n\n                dis_set.append(pt.x_distance(dot))\n\n            distance = min(dis_set)\n\n            if distance < radius:\n\n                scale_val = (1 - (distance / radius) ** 2.0) ** .5 * max_val\n\n            else:\n\n                scale_val = 0.0\n\n            if not(direction):\n\n                scale_val = - scale_val\n\n            pt.warp_pt(scale_val)\n\n\n    def dotGen(self, spacing, y_spacing = None):\n\n        random.seed(PatternMap.DOT_MAP_RND_SEED)\n\n        y_val = 0.0\n        count = 0\n\n        x_spacing = 2.0 ** .5 * spacing\n\n        if self.periodic:\n\n            print(\"dotGen periodicizing\")\n            print(\"updating the x_spacing\")\n            print(\"old x_spacing: %s\" %x_spacing)\n\n            x_spacing_int = math.ceil(self.length / (x_spacing * 2.0))\n            x_spacing = (self.length / x_spacing_int) / 2.0\n\n            print(\"new x_spacing: %s\" %x_spacing)\n\n        if y_spacing == None:\n\n            y_spacing = x_spacing * PatternMap.Y_SPACING_FACTOR\n\n        dots = []\n\n        while y_val < self.height:\n\n            if count % 2 == 1:\n\n                x_val = x_spacing * .5\n\n            else:\n\n                x_val = 0.0\n\n            while x_val < self.length + .1:\n\n                loc_vertex = Vertex(x_val = x_val, y_val = y_val)\n\n                if PatternMap.DOT_MAP_RND:\n                    \n                    multiplier = round(random.random()) * 2 - 1\n\n                    loc_vertex.n_scale *= multiplier\n\n                dots.append(loc_vertex)\n\n                x_val += x_spacing\n\n            y_val += y_spacing\n            count += 1\n\n        return dots\n\n\n    def dotMap(self, spacing, radius, max_val, direction = True):\n\n        dots = self.dotGen(spacing)\n\n        for pt in self.surface_set:\n\n            distance_set = []\n\n            for dot in dots:\n\n                distance = pt.numeric_distance(dot)\n                distance_set.append(distance)\n\n            distance = min(distance_set)\n\n            v_i = distance_set.index(distance)\n\n            distance -= radius\n\n            if distance < 0:\n\n                scale_val = abs(distance) / radius * max_val\n\n            else:\n\n                scale_val = 0.0\n\n            if not(direction):\n\n                scale_val = - scale_val\n\n            # using random values from dots\n            \n            scale_val *= dots[v_i].n_scale\n\n            pt.warp_pt(scale_val)\n\n\n    def ellipsoidBumpMap(self, spacing, radius, max_val, direction = True):\n\n        dots = self.dotGen(spacing)\n\n        for pt in self.surface_set:\n\n            distance_set = []\n\n            for dot in dots:\n\n                distance = pt.numeric_distance(dot)\n                distance_set.append(distance)\n\n            distance = min(distance_set)\n\n            v_i = distance_set.index(distance)\n\n            if distance < radius:\n\n                scale_val = (1 - (distance / radius) ** 2.0) ** .5 * max_val\n\n            else:\n\n                scale_val = 0.0\n\n            if not(direction):\n\n                scale_val = - scale_val\n\n            # using random values from dots\n            scale_val *= dots[v_i].n_scale\n\n            pt.warp_pt(scale_val)\n\n\n    def getKey(self, item):\n\n        return item[0]\n\n\n    def cylinderMap(self, spacing, height, radius, max_val, radius_bot = None, direction = True):\n\n        if radius_bot == None:\n\n            radius_bot = radius\n            radius_delta = 0\n\n        else:\n\n            radius_delta = radius - radius_bot\n\n        dots = self.dotGen(spacing)\n\n        for pt in self.surface_set:\n\n            # get closest dot\n\n            distance_set = []\n\n            for dot in dots:\n\n                distance = pt.numeric_distance(dot)\n                distance_set.append((distance, dot))\n\n            _, dot = sorted(distance_set, key = self.getKey)[0]\n\n            # y_distance calculation    \n\n            y_distance = pt.y_val - dot.y_val\n\n            # x_distance calculation\n\n            x_distance = abs(pt.x_val - dot.x_val)\n\n            if abs(y_distance) + .01 < height * .5 :\n\n                local_radius = radius_bot + radius_delta * (y_distance / height + .5)\n\n            else:\n\n                local_radius = -1\n\n            if x_distance < local_radius:\n\n                scale_val = (1 - (x_distance / local_radius) ** 2.0) ** .5 * max_val\n\n            else:\n\n                scale_val = 0.0\n\n            if not(direction):\n\n                scale_val = - scale_val\n\n            # using random values from dots\n            scale_val *= dot.n_scale\n\n            pt.warp_pt(scale_val)\n\n\n    def makeCurves(self):\n\n        self.pts_set = []\n        crv_set = []\n\n        for layer_i, layer_set in enumerate(self.pattern_set):\n\n            pt_set = [vertex.v for vertex in layer_set]\n\n            if self.add_other_set:\n\n                pt_set = pt_set + self.other_set[layer_i][1:-1] + [pt_set[0]]\n\n            if self.periodic:\n\n                print(\"I am giving you a closed polyline\")\n\n                pt_set = pt_set + [pt_set[0]]\n\n            self.pts_set.append(pt_set)\n\n            crv = rg.Polyline(pt_set)\n\n            crv_set.append(crv)\n\n        self.curved = True\n\n        return crv_set\n\n\n    def makeMesh(self, quad = False):\n\n        if not(self.curved):\n\n            self.makeCurves()\n\n        srf_mesh = rg.Mesh()\n\n        lay_c = len(self.pts_set)\n        pt_c = len(self.pts_set[0])\n\n        # adding the vertices\n\n        [srf_mesh.Vertices.Add(pt) for pt in self.pts_set[0]]\n\n        for i in range(1, lay_c, 1):\n\n            y = i - 1\n\n            for pt_i, pt in enumerate(self.pts_set[i]):\n\n                x = pt_i\n\n                srf_mesh.Vertices.Add(pt)\n\n                v_a = y * pt_c + x -1\n                v_b = (y + 1) * pt_c + x -1\n                v_c = (y + 1) * pt_c + x\n                v_d = y * pt_c + x\n\n                if quad:\n\n                    srf_mesh.Faces.AddFace(v_a, v_b, v_c, v_d)\n\n                else:\n\n                    srf_mesh.Faces.AddFace(v_a, v_b, v_c)\n                    srf_mesh.Faces.AddFace(v_c, v_d, v_a)\n\n\n        # addding the faces\n\n        return srf_mesh",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}