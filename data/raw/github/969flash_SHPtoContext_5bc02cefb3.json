{
  "source_url": "https://github.com/969flash/SHPtoContext/blob/908cd606347bea9676241d916e6393f85c4244bd/main.py",
  "repo": "969flash/SHPtoContext",
  "repo_stars": 0,
  "repo_description": "Zipped shp files to context modeling (shp file's from VWORLD)",
  "license": "unknown",
  "filepath": "main.py",
  "instruction": null,
  "code": "# -*- coding:utf-8 -*-\nfrom typing import List, Tuple, Optional\nimport zipfile\nimport shapefile\nimport Rhino.Geometry as geo\nimport ghpythonlib.components as ghcomp  # ignore\n\n#########################\n# bsh960flash@snu.ac.kr #\n#########################\n\n\n# Contour Divide Resolution(Higher value means more points in terrain mesh)\nRESOLUTION = 4\n\n# Shape type mapping\n# This dictionary categorizes shape types based on their IDs as defined in the shapefile specification.\n# The categories are 'point' and 'polyline', and the IDs represent different geometry types.\nshape_types = {\n    \"point\": [\n        1,  # POINT\n        8,  # MULTIPOINT\n        11,  # POINTZ\n        18,  # MULTIPOINTZ\n        21,  # POINTM\n        28,  # MULTIPOINTM\n    ],\n    \"polyline\": [\n        3,  # POLYLINE\n        5,  # POLYGON\n        13,  # POLYLINEZ\n        15,  # POLYGONZ\n        23,  # POLYLINEM\n        25,  # POLYGONM\n        31,  # MULTIPATCH\n    ],\n}\n\n\nclass ShapefileHandler:\n    \"\"\"\n    A class to manage Shapefile operations.\n    \"\"\"\n\n    def __init__(self, zip_paths: List[str]):\n        self.zip_files = [zipfile.ZipFile(zip_path, \"r\") for zip_path in zip_paths]\n\n    def read_shapefile(self, file_prefixes: List[str]) -> List[shapefile.Reader]:\n        \"\"\"\n        Attempts to read shapefiles from the zip archives using a list of prefixes.\n        \"\"\"\n        readers = []\n        for zip_file in self.zip_files:\n            for prefix in file_prefixes:\n                try:\n                    readers.append(\n                        shapefile.Reader(\n                            shp=zip_file.open(f\"{prefix}.shp\"),\n                            shx=zip_file.open(f\"{prefix}.shx\"),\n                            dbf=zip_file.open(f\"{prefix}.dbf\"),\n                            prj=zip_file.open(f\"{prefix}.prj\"),\n                            encoding=\"cp949\",\n                        )\n                    )\n                except KeyError:\n                    continue\n        return readers\n\n    def extract_data(self, shapefiles: List[shapefile.Reader]) -> \"ShpData\":\n        \"\"\"\n        Extracts data from a list of shapefiles.\n        \"\"\"\n        all_geometry = []\n        all_fields = []\n        all_field_names = []\n        all_records = []\n        shape_type = None\n\n        for sf in shapefiles:\n            result = ShapefileParser.read_shapefile(sf)\n            if shape_type is None:\n                shape_type = result[0]\n            all_geometry.extend(result[1])\n            all_fields.extend(result[2])\n            all_field_names.extend(result[3])\n            all_records.extend(result[4])\n\n        return ShpData(\n            shape_type, all_geometry, all_fields, all_field_names, all_records\n        )\n\n\nclass ShpData:\n    \"\"\"\n    A class to store Shapefile data.\n    \"\"\"\n\n    def __init__(self, shape_type, geometry, fields, field_names, records):\n        self.shape_type = shape_type\n        self.geometry = geometry\n        self.fields = fields\n        self.field_names = field_names\n        self.records = records\n\n\nclass ShapefileParser:\n    \"\"\"\n    A class to handle parsing operations for shapefiles.\n    \"\"\"\n\n    @staticmethod\n    def find_type(shape_type):\n        for key, values in shape_types.items():\n            if shape_type in values:\n                return key\n        return None\n\n    @staticmethod\n    def read_shapefile(sf: shapefile.Reader, encoding=\"utf-8\") -> Tuple:\n        result_geom = []\n        result_fields = []\n        result_field_names = []\n        result_records = []\n\n        shape_type = ShapefileParser.find_type(sf.shapeType)\n\n        # Extract field names\n        for field in sf.fields:\n            if field[0] != \"DeletionFlag\":\n                _field = field[0]\n                if isinstance(_field, bytes):\n                    _field = _field.decode(encoding, errors=\"replace\")\n                result_field_names.append(_field)\n                result_fields.append(field)\n\n        # Extract geometry and records\n        for shape, record in zip(sf.shapes(), sf.records()):\n            geom = ShapefileParser.parse_geometry(shape, shape_type)\n            result_geom.append(geom)\n            _record = []\n            for rec in record:\n                if isinstance(rec, bytes):\n                    _record.append(rec.decode(encoding, errors=\"replace\"))\n                else:\n                    _record.append(rec)\n            result_records.append(_record)\n\n        return (\n            shape_type,\n            result_geom,\n            result_fields,\n            result_field_names,\n            result_records,\n        )\n\n    @staticmethod\n    def parse_geometry(shape, shape_type):\n        if shape_type == \"point\":\n            return [GeometryUtils.list2point(pt) for pt in shape.points]\n        elif shape_type == \"polyline\":\n            parts = [\n                shape.points[\n                    shape.parts[i] : (\n                        shape.parts[i + 1] if i + 1 < len(shape.parts) else None\n                    )\n                ]\n                for i in range(len(shape.parts))\n            ]\n            return [\n                geo.PolylineCurve([GeometryUtils.list2point(pt) for pt in part])\n                for part in parts\n            ]\n        return []\n\n\nclass GeometryUtils:\n    \"\"\"\n    A utility class for geometry-related operations.\n    \"\"\"\n\n    @staticmethod\n    def list2point(pts):\n        pts = list(pts)\n        if len(pts) == 2:\n            pts.append(0)\n        return geo.Point3d(*pts)\n\n    @staticmethod\n    def get_vertices(curve):\n        vertices = [\n            curve.PointAt(curve.SpanDomain(i)[0]) for i in range(curve.SpanCount)\n        ]\n        if not curve.IsClosed:\n            vertices.append(curve.PointAtEnd)\n        return vertices\n\n    @staticmethod\n    def get_projected_pt_on_mesh(pt, mesh):\n        for direction in [geo.Vector3d(0, 0, -1), geo.Vector3d(0, 0, 1)]:\n            ray = geo.Ray3d(pt, direction)\n            t = geo.Intersect.Intersection.MeshRay(mesh, ray)\n            if t >= 0:\n                return ray.PointAt(t)\n        return None\n\n\nclass ContourProcessor:\n    \"\"\"\n    A class to handle contour operations.\n    \"\"\"\n\n    @staticmethod\n    def create_contour_curves(contour_geometry_records):\n        contour_crvs = []\n        for contour_geom, contour_record in contour_geometry_records:\n            contour_crvs.append(\n                geo.PolylineCurve(\n                    [\n                        geo.Point3d(\n                            contour_geom[0].Point(pt_count).X,\n                            contour_geom[0].Point(pt_count).Y,\n                            contour_record[1],\n                        )\n                        for pt_count in range(contour_geom[0].SpanCount)\n                    ]\n                )\n            )\n        return contour_crvs\n\n    @staticmethod\n    def create_points_for_mesh(contour_curves, resolution):\n        points = []\n        for curve in contour_curves:\n            params = curve.DivideByLength(resolution, True)\n            if params:\n                points.extend([curve.PointAt(param) for param in params])\n        return points\n\n\nclass BuildingProcessor:\n    \"\"\"\n    A class to process building geometries.\n    \"\"\"\n\n    @staticmethod\n    def create_building_breps(building_geometry_records, mesh_terrain):\n        breps = []\n        for geom, record in building_geometry_records:\n            base_curve = geom[0]\n            height = record[5] * 3.5\n            vertices = GeometryUtils.get_vertices(base_curve)\n\n            projected_pts = [\n                GeometryUtils.get_projected_pt_on_mesh(pt, mesh_terrain)\n                for pt in vertices\n            ]\n            projected_pts = list(filter(None, projected_pts))\n\n            if projected_pts:\n                min_z = min(pt.Z for pt in projected_pts)\n                base_curve.Translate(geo.Vector3d(0, 0, min_z - vertices[0].Z))\n                building = geo.Extrusion.Create(base_curve, -height, True)\n                breps.append(building)\n\n        return breps\n\n\n# paths -> parameter of the component in grasshopper that is the path to the zip files\n\n# Main workflow\nhandler = ShapefileHandler(paths)\ncontour_shapes = handler.read_shapefile([\"N1L_F0010000\", \"N3L_F0010000\"])\nbuilding_shapes = handler.read_shapefile([\"N1A_B0010000\", \"N3A_B0010000\"])\nroad_region_shapes = handler.read_shapefile([\"N3A_A0010000\"])\nroad_centerline_shapes = handler.read_shapefile([\"N3L_A0020000\"])\nriver_shapes = handler.read_shapefile([\"N3A_E0010001\"])\nwater_shapes = handler.read_shapefile([\"N3A_G0020000\"])\n\n# Extract data\ncontour_data = handler.extract_data(contour_shapes)\nbuilding_data = handler.extract_data(building_shapes)\nroad_region_data = handler.extract_data(road_region_shapes)\nroad_centerline_data = handler.extract_data(road_centerline_shapes)\nriver_data = handler.extract_data(river_shapes)\nwater_shapes_data = handler.extract_data(water_shapes)\n\n\n# Process contour\ncontour_geometry_records = list(zip(contour_data.geometry, contour_data.records))\ncontour_curves = ContourProcessor.create_contour_curves(contour_geometry_records)\n\n# Process terrain\nmesh_points = ContourProcessor.create_points_for_mesh(contour_curves, RESOLUTION)\nterrain_mesh = ghcomp.DelaunayMesh(mesh_points)\n\n# Process buildings\nbuilding_geometry_records = list(zip(building_data.geometry, building_data.records))\nbuilding_breps = BuildingProcessor.create_building_breps(\n    building_geometry_records, terrain_mesh\n)\n\n# Process road\nroad_region_curves = [data[0] for data in road_region_data.geometry]\nroad_centerline_curves = [data[0] for data in road_centerline_data.geometry]\n\n# process river\nriver_curves = [data[0] for data in river_data.geometry]\n# process water\nwater_curves = [data[0] for data in water_shapes_data.geometry]\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}