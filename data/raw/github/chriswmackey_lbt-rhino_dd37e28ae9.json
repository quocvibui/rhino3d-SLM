{
  "source_url": "https://github.com/chriswmackey/lbt-rhino/blob/d650b6631f4a5708f4472427d076c2343c569ac2/libraries/ladybug_rhino/togeometry.py",
  "repo": "chriswmackey/lbt-rhino",
  "repo_stars": 0,
  "repo_description": "A set of Rhino scripts that run Ladybug Tools as commands.",
  "license": "AGPL-3.0",
  "filepath": "libraries/ladybug_rhino/togeometry.py",
  "instruction": "Functions to create Ladybug geometries from Rhino geometries.",
  "code": "\"\"\"Functions to create Ladybug geometries from Rhino geometries.\"\"\"\n\ntry:\n    from ladybug_geometry.geometry2d.pointvector import Vector2D, Point2D\n    from ladybug_geometry.geometry2d.ray import Ray2D\n    from ladybug_geometry.geometry2d.line import LineSegment2D\n    from ladybug_geometry.geometry2d.polyline import Polyline2D\n    from ladybug_geometry.geometry2d.polygon import Polygon2D\n    from ladybug_geometry.geometry2d.mesh import Mesh2D\n    from ladybug_geometry.geometry3d.pointvector import Vector3D, Point3D\n    from ladybug_geometry.geometry3d.ray import Ray3D\n    from ladybug_geometry.geometry3d.line import LineSegment3D\n    from ladybug_geometry.geometry3d.polyline import Polyline3D\n    from ladybug_geometry.geometry3d.plane import Plane\n    from ladybug_geometry.geometry3d.mesh import Mesh3D\n    from ladybug_geometry.geometry3d.face import Face3D\n    from ladybug_geometry.geometry3d.polyface import Polyface3D\nexcept ImportError as e:\n    raise ImportError(\n        \"Failed to import ladybug_geometry.\\n{}\".format(e))\n\ntry:\n    import ladybug.color as lbc\nexcept ImportError as e:\n    raise ImportError(\"Failed to import ladybug.\\n{}\".format(e))\n\ntry:\n    import Rhino.Geometry as rg\nexcept ImportError as e:\n    raise ImportError(\"Failed to import Rhino.\\n{}\".format(e))\n\nimport ladybug_rhino.planarize as _planar\nfrom .fromgeometry import from_face3ds_to_joined_brep\nfrom .config import tolerance\n\n\n\"\"\"____________2D GEOMETRY TRANSLATORS____________\"\"\"\n\n\ndef to_vector2d(vector):\n    \"\"\"Ladybug Vector2D from Rhino Vector3d.\"\"\"\n    return Vector2D(vector.X, vector.Y)\n\n\ndef to_point2d(point):\n    \"\"\"Ladybug Point2D from Rhino Point3d.\"\"\"\n    return Point2D(point.X, point.Y)\n\n\ndef to_ray2d(ray):\n    \"\"\"Ladybug Ray2D from Rhino Ray3d.\"\"\"\n    return Ray2D(to_point2d(ray.Position), to_vector2d(ray.Direction))\n\n\ndef to_linesegment2d(line):\n    \"\"\"Ladybug LineSegment2D from Rhino LineCurve.\"\"\"\n    return LineSegment2D.from_end_points(\n        to_point2d(line.PointAtStart), to_point2d(line.PointAtEnd))\n\n\ndef to_polyline2d(polyline):\n    \"\"\"Ladybug Polyline2D from a Rhino PolyLineCurve.\n\n    A LineSegment2D will be returned if the input polyline has only two points.\n    \"\"\"\n    pts = [to_point2d(polyline.Point(i)) for i in range(polyline.PointCount)]\n    return Polyline2D(pts) if len(pts) != 2 else LineSegment2D.from_end_points(*pts)\n\n\ndef to_polygon2d(polygon):\n    \"\"\"Ladybug Polygon2D from Rhino closed PolyLineCurve.\"\"\"\n    assert polygon.IsClosed, \\\n        'Rhino PolyLineCurve must be closed to make a Ladybug Polygon2D.'\n    return Polygon2D(\n        [to_point2d(polygon.Point(i)) for i in range(polygon.PointCount - 1)])\n\n\ndef to_mesh2d(mesh, color_by_face=True):\n    \"\"\"Ladybug Mesh2D from Rhino Mesh.\"\"\"\n    lb_verts = tuple(to_point2d(pt) for pt in mesh.Vertices)\n    lb_faces, colors = _extract_mesh_faces_colors(mesh, color_by_face)\n    return Mesh2D(lb_verts, lb_faces, colors)\n\n\n\"\"\"____________3D GEOMETRY TRANSLATORS____________\"\"\"\n\n\ndef to_vector3d(vector):\n    \"\"\"Ladybug Vector3D from Rhino Vector3d.\"\"\"\n    return Vector3D(vector.X, vector.Y, vector.Z)\n\n\ndef to_point3d(point):\n    \"\"\"Ladybug Point3D from Rhino Point3d.\"\"\"\n    return Point3D(point.X, point.Y, point.Z)\n\n\ndef to_ray3d(ray):\n    \"\"\"Ladybug Ray3D from Rhino Ray3d.\"\"\"\n    return Ray3D(to_point3d(ray.Position), to_vector3d(ray.Direction))\n\n\ndef to_linesegment3d(line):\n    \"\"\"Ladybug LineSegment3D from Rhino LineCurve.\"\"\"\n    return LineSegment3D.from_end_points(\n        to_point3d(line.PointAtStart), to_point3d(line.PointAtEnd))\n\n\ndef to_polyline3d(polyline):\n    \"\"\"Ladybug Polyline3D from a Rhino PolyLineCurve.\n\n    A LineSegment3D will be returned if the input polyline has only two points.\n    \"\"\"\n    pts = [to_point3d(polyline.Point(i)) for i in range(polyline.PointCount)]\n    return Polyline3D(pts) if len(pts) != 2 else LineSegment3D.from_end_points(*pts)\n\n\ndef to_plane(pl):\n    \"\"\"Ladybug Plane from Rhino Plane.\"\"\"\n    return Plane(\n        to_vector3d(pl.ZAxis), to_point3d(pl.Origin), to_vector3d(pl.XAxis))\n\n\ndef to_face3d(geo, meshing_parameters=None):\n    \"\"\"List of Ladybug Face3D objects from a Rhino Brep, Surface or Mesh.\n\n    Args:\n        brep: A Rhino Brep, Surface or Mesh that will be converted into a list\n            of Ladybug Face3D.\n        meshing_parameters: Optional Rhino Meshing Parameters to describe how\n            curved faces should be converted into planar elements. If None,\n            Rhino's Default Meshing Parameters will be used.\n    \"\"\"\n    faces = []  # list of Face3Ds to be populated and returned\n    if isinstance(geo, rg.Mesh):  # convert each Mesh face to a Face3D\n        pts = tuple(to_point3d(pt) for pt in geo.Vertices)\n        for face in geo.Faces:\n            if face.IsQuad:\n                all_verts = (pts[face[0]], pts[face[1]], pts[face[2]], pts[face[3]])\n                lb_face = Face3D(all_verts)\n                if lb_face.area != 0:\n                    for _v in lb_face.vertices:\n                        if lb_face.plane.distance_to_point(_v) >= tolerance:\n                            # non-planar quad split the quad into two planar triangles\n                            verts1 = (pts[face[0]], pts[face[1]], pts[face[2]])\n                            verts2 = (pts[face[3]], pts[face[0]], pts[face[1]])\n                            faces.append(Face3D(verts1))\n                            faces.append(Face3D(verts2))\n                            break\n                    else:\n                        faces.append(lb_face)\n            else:\n                all_verts = (pts[face[0]], pts[face[1]], pts[face[2]])\n                lb_face = Face3D(all_verts)\n                if lb_face.area != 0:\n                    faces.append(lb_face)\n    else:  # convert each Brep Face to a Face3D\n        meshing_parameters = meshing_parameters or rg.MeshingParameters.Default\n        for b_face in geo.Faces:\n            if b_face.IsPlanar(tolerance):\n                try:\n                    bf_plane = to_plane(b_face.FrameAt(0, 0)[-1])\n                except Exception:  # failed to extract the plane from the geometry\n                    bf_plane = None  # auto-calculate the plane from the vertices\n                all_verts = []\n                for count in range(b_face.Loops.Count):  # Each loop is a boundary/hole\n                    success, loop_pline = \\\n                        b_face.Loops.Item[count].To3dCurve().TryGetPolyline()\n                    if not success:  # Failed to get a polyline; there's a curved edge\n                        loop_verts = _planar.planar_face_curved_edge_vertices(\n                            b_face, count, meshing_parameters)\n                    else:  # we have a polyline representing the loop\n                        loop_verts = tuple(to_point3d(loop_pline.Item[i])\n                                           for i in range(loop_pline.Count - 1))\n                    all_verts.append(_remove_dup_verts(loop_verts))\n                if len(all_verts[0]) >= 3:\n                    if len(all_verts) == 1:  # No holes in the shape\n                        faces.append(Face3D(all_verts[0], plane=bf_plane))\n                    else:  # There's at least one hole in the shape\n                        hls = [hl for hl in all_verts[1:] if len(hl) >= 3]\n                        faces.append(Face3D(\n                            boundary=all_verts[0], holes=hls, plane=bf_plane))\n            else:  # curved face must be meshed into planar Face3D objects\n                faces.extend(_planar.curved_surface_faces(b_face, meshing_parameters))\n    return faces\n\n\ndef to_polyface3d(geo, meshing_parameters=None):\n    \"\"\"A Ladybug Polyface3D object from a Rhino Brep.\n\n    Args:\n        geo: A Rhino Brep, Surface or Mesh that will be converted into a single\n            Ladybug Polyface3D.\n        meshing_parameters: Optional Rhino Meshing Parameters to describe how\n            curved faces should be converted into planar elements. If None,\n            Rhino's Default Meshing Parameters will be used.\n    \"\"\"\n    mesh_par = meshing_parameters or rg.MeshingParameters.Default  # default\n    if not isinstance(geo, rg.Mesh) and _planar.has_curved_face(geo):  # keep solidity\n        new_brep = from_face3ds_to_joined_brep(_planar.curved_solid_faces(geo, mesh_par))\n        return Polyface3D.from_faces(to_face3d(new_brep[0], mesh_par), tolerance)\n    return Polyface3D.from_faces(to_face3d(geo, mesh_par), tolerance)\n\n\ndef to_mesh3d(mesh, color_by_face=True):\n    \"\"\"Ladybug Mesh3D from Rhino Mesh.\"\"\"\n    lb_verts = tuple(to_point3d(pt) for pt in mesh.Vertices)\n    lb_faces, colors = _extract_mesh_faces_colors(mesh, color_by_face)\n    return Mesh3D(lb_verts, lb_faces, colors)\n\n\n\"\"\"________ADDITIONAL 3D GEOMETRY TRANSLATORS________\"\"\"\n\n\ndef to_gridded_mesh3d(brep, grid_size, offset_distance=0):\n    \"\"\"Create a gridded Ladybug Mesh3D from a Rhino Brep.\n\n    This is useful since Rhino's grid meshing is often more beautiful than what\n    ladybug_geometry can produce. However, the ladybug_geometry Face3D.get_mesh_grid\n    method provides a workable alternative to this if it is needed.\n\n    Args:\n        brep: A Rhino Brep that will be converted into a gridded Ladybug Mesh3D.\n        grid_size: A number for the grid size dimension with which to make the mesh.\n        offset_distance: A number for the distance at which to offset the mesh from\n            the underlying brep. The default is 0.\n    \"\"\"\n    meshing_param = rg.MeshingParameters.Default\n    meshing_param.MaximumEdgeLength = grid_size\n    meshing_param.MinimumEdgeLength = grid_size\n    meshing_param.GridAspectRatio = 1\n    mesh_grids = rg.Mesh.CreateFromBrep(brep, meshing_param)\n    if len(mesh_grids) == 1:  # only one mesh was generated\n        mesh_grid = mesh_grids[0]\n    else:  # join the meshes into one\n        mesh_grid = rg.Mesh()\n        for m_grid in mesh_grids:\n            mesh_grid.Append(m_grid)\n    if offset_distance != 0:\n        temp_mesh = rg.Mesh()\n        mesh_grid.Normals.UnitizeNormals()\n        for pt, vec in zip(mesh_grid.Vertices, mesh_grid.Normals):\n            temp_mesh.Vertices.Add(pt + (rg.Vector3f.Multiply(vec, offset_distance)))\n        for face in mesh_grid.Faces:\n            temp_mesh.Faces.AddFace(face)\n        mesh_grid = temp_mesh\n    return to_mesh3d(mesh_grid)\n\n\ndef to_joined_gridded_mesh3d(geometry, grid_size, offset_distance=0):\n    \"\"\"Create a single gridded Ladybug Mesh3D from an array of Rhino geometry.\n\n    Args:\n        breps: An array of Rhino Breps and/or Rhino meshes that will be converted\n            into a single, joined gridded Ladybug Mesh3D.\n        grid_size: A number for the grid size dimension with which to make the mesh.\n        offset_distance: A number for the distance at which to offset the mesh from\n            the underlying brep. The default is 0.\n    \"\"\"\n    lb_meshes = []\n    for geo in geometry:\n        if isinstance(geo, rg.Brep):\n            lb_meshes.append(to_gridded_mesh3d(geo, grid_size, offset_distance))\n        else:  # assume that it's a Mesh\n            lb_meshes.append(to_mesh3d(geo))\n    if len(lb_meshes) == 1:\n        return lb_meshes[0]\n    else:\n        return Mesh3D.join_meshes(lb_meshes)\n\n\n\"\"\"________________EXTRA HELPER FUNCTIONS________________\"\"\"\n\n\ndef _extract_mesh_faces_colors(mesh, color_by_face):\n    \"\"\"Extract face indices and colors from a Rhino mesh.\"\"\"\n    colors = None\n    lb_faces = []\n    for face in mesh.Faces:\n        if face.IsQuad:\n            lb_faces.append((face[0], face[1], face[2], face[3]))\n        else:\n            lb_faces.append((face[0], face[1], face[2]))\n\n    if len(mesh.VertexColors) != 0:\n        colors = []\n        if color_by_face is True:\n            for face in mesh.Faces:\n                col = mesh.VertexColors[face[0]]\n                colors.append(lbc.Color(col.R, col.G, col.B))\n        else:\n            for col in mesh.VertexColors:\n                colors.append(lbc.Color(col.R, col.G, col.B))\n    return lb_faces, colors\n\n\ndef _remove_dup_verts(vertices):\n    \"\"\"Remove vertices from an array of Point3Ds that are equal within the tolerance.\"\"\"\n    return [pt for i, pt in enumerate(vertices)\n            if not pt.is_equivalent(vertices[i - 1], tolerance)]\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}