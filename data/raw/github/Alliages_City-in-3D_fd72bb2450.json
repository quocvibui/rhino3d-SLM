{
  "source_url": "https://github.com/Alliages/City-in-3D/blob/e395169df8662165e2acbe00af47a0e2b709216d/City_in_3D.py",
  "repo": "Alliages/City-in-3D",
  "repo_stars": 19,
  "repo_description": "a Rhinoceros script that create buildings according to geojson file and with real elevation",
  "license": "GPL-3.0",
  "filepath": "City_in_3D.py",
  "instruction": "#######\r\nversion 1.1 bugfix in approximation 2016/06/16\r\nversion 1.0 initial release 2016/06/12\r\n-\r\n    Args:\r\n        Geojson file\r\n        elevation file in Bil format\r\n        radius around the...",
  "code": "#\r\n# City in 3D : a Rhinoceros script that create buildings according to geojson file and with real elevation by Guillaume Meunier\r\n# \r\n# -----------------------------------\r\n# Need pygeoj.py & utm.py\r\n# It must be in your script's folder\r\n# -----------------------------------\r\n# TODO :\r\n# \r\n# -----------------------------------\r\n# \r\n# Copyright (c) 2016, Guillaume Meunier <alliages@gmail.com> \r\n# City in 3D is free software; you can redistribute it and/or modify \r\n# it under the terms of the GNU General Public License as published \r\n# by the Free Software Foundation; either version 3 of the License, \r\n# or (at your option) any later version. \r\n# \r\n# City in 3D is distributed in the hope that it will be useful,\r\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \r\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \r\n# GNU General Public License for more details.\r\n# \r\n# You should have received a copy of the GNU General Public License\r\n# along with City in 3D; If not, see <http://www.gnu.org/licenses/>.\r\n# \r\n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\r\n\r\n\r\n\"\"\"\r\n#######\r\nversion 1.1 bugfix in approximation 2016/06/16\r\nversion 1.0 initial release 2016/06/12\r\n-\r\n    Args:\r\n        Geojson file\r\n        elevation file in Bil format\r\n        radius around the address\r\n        address you around which you want to create city\r\n    Returns:\r\n        out: various information\r\n        coordinates: coordinates in JSON format\r\n        properties: properties in JSON format\r\n\"\"\"\r\nfrom System import Object\r\nimport collections\r\n\r\nimport pygeoj #pygeoj.py must be in your script's folder\r\nimport utm #pygeoj.py must be in your script's folder -- needed by latlong_to_coord\r\n\r\nimport Rhino as rh\nimport Rhino.Geometry as rg\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\nimport os\r\nimport struct\r\nimport math\r\n\r\n#####ELEV\r\nimport  httplib\r\nimport json\r\nimport urllib\r\n\r\n###############################\r\n###########  VARIOUS  #########\r\n###############################\r\n\r\ndef nominatim(address):\r\n    \"\"\"\r\n    transfrom address in lat long coordinates\r\n    \"\"\"\r\n    url = \"http://nominatim.openstreetmap.org/search\"\r\n    address = address.replace(\" \",\"+\")\r\n    format=\"jsonv2\"\r\n    addressdetails=\"0\"\r\n    polygon_=\"0\"\r\n    limit=\"1\"\r\n    url_totale = url+\"?q=\"+address+\"&format=\"+format+\"&addressdetails=\"+addressdetails+\"&polygon_=\"+polygon_+\"&limit=\"+limit\r\n    request = urllib.urlopen(url_totale)\r\n    try:\r\n        results = json.load(request)\r\n        if 0 < len(results):\r\n            r = results[0]\r\n            return float(r['lat']),float(r['lon'])\r\n        else:\r\n            print 'HTTP GET Request failed.'\r\n    except ValueError, e:\r\n        print 'JSON decode failed: '+str(request)\r\n\r\n#EXAMPLE\r\n#a = nominatim(\"133 rue saint antoine Paris\")\r\n#print a['display_name']\r\n#print a['lat']\r\n#print a['lon']        \r\n        \r\ndef parseTree(input,i=0):\r\n    \"\"\"\r\n    get tree depth\r\n    \"\"\"\r\n    if isinstance (input, list):\r\n        i = parseTree(input[0],i+1)\r\n        return(i)\r\n    else:\r\n        return(i)\r\n\r\ndef latlong_to_coord(lat,lon):\r\n    \"\"\"\r\n    need UTM\r\n    #convert lat long to rhino coordinates\r\n    #road zero point in France (middle of Paris)\r\n    \"\"\"\r\n    \r\n    #used as ZERO in rhino\r\n    ptzero_france_east = 452228.9940197494\r\n    ptzero_france_north = 5411363.8212742545\r\n    \r\n    if not -80.0 <= lat <= 84.0:\r\n        print \"Lat not in -80 and +84\"\r\n    if not -180.0 <= lon <= 180.0:\r\n        print \"long not in -180 and 180\"\r\n    loc = utm.from_latlon(lat,lon)\r\n    resX = loc[0]-ptzero_france_east\r\n    resY = loc[1]-ptzero_france_north\r\n    return (resX,resY)\r\n\r\n\r\ndef centroid(points):\r\n    \"\"\"\r\n    find centroid of points\r\n    \"\"\"\r\n    x_coords = [p[0] for p in points]\r\n    y_coords = [p[1] for p in points]\r\n    _len = len(points)\r\n    centroid_x = sum(x_coords)/_len\r\n    centroid_y = sum(y_coords)/_len\r\n    return [centroid_x, centroid_y]\r\n\r\ndef toPt(c,z):\r\n    coord = latlong_to_coord(c[1],c[0])\r\n    return rg.Point3d(coord[0],coord[1],z)\r\n\r\ndef distance(lat11, lon11, lat22, lon22):\r\n    \"\"\"\r\n    Calculate the great circle distance between two points \r\n    on the earth (specified in decimal degrees)\r\n    \"\"\"\r\n    # convert decimal degrees to radians \r\n    EARTH_RADIUS = 6371009 #en metre\r\n    #lon1, lat1, lon2, lat2 = map(math.radians, [lon11, lat11, lon22, lat22])\r\n    #lat1 = math.radians(lat11)\r\n    lat1, lng1 = math.radians(lat11), math.radians(lon11)\r\n    lat2, lng2 = math.radians(lat22), math.radians(lon22)\r\n    sin_lat1, cos_lat1 = math.sin(lat1), math.cos(lat1)\r\n    sin_lat2, cos_lat2 = math.sin(lat2), math.cos(lat2)\r\n    delta_lng = lng2 - lng1\r\n    cos_delta_lng, sin_delta_lng = math.cos(delta_lng), math.sin(delta_lng)\r\n    d = math.atan2(math.sqrt((cos_lat2 * sin_delta_lng) ** 2 + (cos_lat1 * sin_lat2 - sin_lat1 * cos_lat2 * cos_delta_lng) ** 2),sin_lat1 * sin_lat2 + cos_lat1 * cos_lat2 * cos_delta_lng)\r\n    return EARTH_RADIUS * d\r\n\r\n###############################\r\n########### BIL PARSER ########\r\n###############################\r\n\r\n\"\"\"\r\nThanks dbr/Ben\r\n#based upon https://gist.github.com/dbr/3351090\r\nwhich is mostly based of:\r\nhttp://stevendkay.wordpress.com/2010/05/29/parsing-usgs-bil-digital-elevation-models-in-python/\r\nDocumentation for the format itself:\r\nhttp://webhelp.esri.com/arcgisdesktop/9.2/index.cfm?TopicName=BIL,_BIP,_and_BSQ_raster_files\r\n\r\n\r\n#------ BIL EXAMPLE ---------\r\n#bp = BilParser(\"elevationBil/elev-decoupe75.hdr\") # expects to also find filename.bil\r\n#h = bp.header\r\n#v = bp.values\r\n\"\"\"\r\n\r\ndef parse_header(hdr):\r\n    \"\"\"\r\n    Parse a BIL header .hdr file\r\n    \"\"\"\r\n    contents = open(hdr).read()\r\n    lines = contents.strip().splitlines()\r\n    header = {}\r\n    for li in lines:\r\n        key, _, value = li.partition(\" \")\r\n        header[key] = value.strip()\r\n\r\n    return header\r\n\r\n\r\ndef parse_bil(path, rows, cols, dtype):\r\n    # where you put the extracted BIL file\r\n    fi = open(path, \"rb\")\r\n    contents = fi.read()\r\n    fi.close()\r\n\r\n    # unpack binary data into a flat tuple z\r\n    n = int(rows*cols)\r\n    if dtype == \"FLOAT\":\r\n        s = \"<%df\" % (n,)\r\n    else: # spec says to assume unsigned int if no type specified..\r\n        s = \"<%dH\" % (n,) # unsigned int\r\n    z = struct.unpack(s, contents)\r\n    values = [[None for x in range(cols)] for x in range(rows)]\r\n    for r in range(rows):\r\n        for c in range(cols):\r\n            val = z[(cols*r)+c]\r\n            if (val==65535 or val<0 or val>20000):\r\n                # may not be needed depending on format, and the \"magic number\"\r\n                # value used for 'void' or missing data\r\n                val=0.0\r\n            values[r][c]=float(val)\r\n    return values\r\n\r\nclass BilParser(object):\r\n    \"\"\"\r\n    magicin class\r\n    \"\"\"\r\n    #based upon https://gist.github.com/dbr/3351090\r\n    def __init__(self, headerpath):\r\n        self.basepath = os.path.splitext(headerpath)[0]\r\n        self.header = parse_header(self.basepath + \".hdr\")\r\n        self.values = parse_bil(\r\n            self.basepath + \".bil\",\r\n            rows = int(self.header['NROWS']),\r\n            cols = int(self.header['NCOLS']),\r\n            dtype = self.header['PIXELTYPE'])\r\n\r\ndef get_row_and_column(header, latitude, longitude):\r\n    \"\"\"\r\n    convert from lat/long to row&column\r\n    \"\"\"\r\n    sizelat = float(header['NROWS'])\r\n    sizelong = float(header['NCOLS'])\r\n    long_space = float(header['XDIM'])\r\n    lat_space = float(header['YDIM'])\r\n    long_min = float(header['ULXMAP'])-(long_space/2)#middle of the band\r\n    lat_max = float(header['ULYMAP'])+(lat_space/2)#middle of the band\r\n    long_max = long_min + (long_space*sizelong)\r\n    lat_min = lat_max - (lat_space*sizelat)\r\n    if not(lat_min < latitude < lat_max):\r\n        print \"min:\"+str(lat_min)+\", max:\"+str(lat_max)\r\n        return \"latitude outside range | min:\"+str(lat_min)+\", max:\"+str(lat_max)\r\n    if not(long_min < longitude < long_max):\r\n        print \"min:\"+str(long_min)+\", max:\"+str(long_max)\r\n        return \"longitude outside range | min:\"+str(long_min)+\", max:\"+str(long_max)\r\n    row = int(math.floor((lat_max - latitude) / lat_space))\r\n    column = int(math.floor((longitude - long_min) / long_space))\r\n    #print \"R=\"+str(row)+\" | C=\"+str(column)\r\n    return row,column\r\n\r\ndef get_lat_and_long(header,row,column):\r\n    \"\"\"\r\n    convert from row&column to lat/long\r\n    \"\"\"\r\n    #sizelat = float(header['NROWS'])\r\n    #sizelong = float(header['NCOLS'])\r\n    long_space = float(header['XDIM'])\r\n    lat_space = float(header['YDIM'])\r\n    long_min = float(header['ULXMAP'])#middle of the band\r\n    lat_max = float(header['ULYMAP'])#middle of the band\r\n    #FAIRE DES IFS\r\n    lat = lat_max - (lat_space*row)\r\n    long = long_min + (long_space*column)\r\n    return lat,long\r\n\r\n###############################\r\n########### ELEVATION #########\r\n###############################\r\n\r\ndef bil_elevation(h,v,lat,lon):\r\n    #from bil file, get value\r\n    try:\r\n        row, column = get_row_and_column(h,lat, lon)\r\n    except:\r\n        err = get_row_and_column(h,lat, lon)\r\n        raise Exception(err)\r\n    return v[row][column]\r\n\r\n#EXAMPLE    \r\n#el = bil_elevation(h,v,48.7810,2.12594)\r\n\r\ndef approx_elevation(h,v,lat,lon):\r\n    \"\"\"\r\n    linear approximation of elevation using bil file\r\n    \"\"\"\r\n    try:\r\n        row, column = get_row_and_column(h,lat, lon)\r\n    except:\r\n        err = \"problem getting row and column\"\r\n        raise Exception(err)\r\n    el_c = v[row][column]\r\n    lat_t,long_t = get_lat_and_long(h,row,column)\r\n\tdis_c = distance(lat,lon,lat_t,long_t)\r\n    if dis_c == 0:\r\n\t    return el_c #case perfectly at center\r\n    dis_c = 1/dis_c\r\n    ##\r\n    el_n = v[row-1][column]\r\n    lat_t,long_t = get_lat_and_long(h,row-1,column)\r\n    dis_n = 1/distance(lat,lon,lat_t,long_t)\r\n    ##\r\n    el_s = v[row+1][column]\r\n    lat_t,long_t = get_lat_and_long(h,row+1,column)\r\n    dis_s = 1/distance(lat,lon,lat_t,long_t)\r\n    ##\r\n    el_e = v[row][column+1]\r\n    lat_t,long_t = get_lat_and_long(h,row,column+1)\r\n    dis_e = 1/distance(lat,lon,lat_t,long_t)\r\n    ##\r\n    el_o = v[row][column-1]\r\n    lat_t,long_t = get_lat_and_long(h,row,column-1)\r\n    dis_o = 1/distance(lat,lon,lat_t,long_t)\r\n    ##\r\n    el_ne = v[row-1][column+1]\r\n    lat_t,long_t = get_lat_and_long(h,row-1,column+1)\r\n    dis_ne = 1/distance(lat,lon,lat_t,long_t)\r\n    ##\r\n    el_se = v[row+1][column+1]\r\n    lat_t,long_t = get_lat_and_long(h,row+1,column+1)\r\n    dis_se = 1/distance(lat,lon,lat_t,long_t)\r\n    ##\r\n    el_so = v[row+1][column-1]\r\n    lat_t,long_t = get_lat_and_long(h,row+1,column-1)\r\n    dis_so = 1/distance(lat,lon,lat_t,long_t)\r\n    ##\r\n    el_no = v[row-1][column-1]\r\n    lat_t,long_t = get_lat_and_long(h,row-1,column-1)\r\n    dis_no = 1/distance(lat,lon,lat_t,long_t)\r\n    ##\r\n    r = (el_c*dis_c+el_n*dis_n+el_s*dis_s+el_e*dis_e+el_o*dis_o+el_no*dis_no+el_ne*dis_ne+el_so*dis_so+el_se*dis_se)/(dis_c+dis_n+dis_s+dis_e+dis_o+dis_no+dis_ne+dis_so+dis_se)\r\n    return r\r\n\r\ndef google_elevation(lat, lng):\r\n    \"\"\"\r\n    Get elevation from google elevation API\r\n    it has limitation in time and number of request\r\n    \"\"\"\r\n    apikey = \"USE YOUR OWN KEY\"\r\n    url = \"https://maps.googleapis.com/maps/api/elevation/json\"\r\n    request = urllib.urlopen(url+\"?locations=\"+str(lat)+\",\"+str(lng)+\"&key=\"+apikey)\r\n    try:\r\n        results = json.load(request).get('results')\r\n        if 0 < len(results):\r\n            elevation = results[0].get('elevation')\r\n            return elevation\r\n        else:\r\n            print 'HTTP GET Request failed.'\r\n    except ValueError, e:\r\n        print 'JSON decode failed: '+str(request)\r\n\r\n#ELEV EXAMPLE\r\n#print google_elevation(48.8445548,2.4222176)\r\n\r\n##############################\r\n##########  EXTRUDE  #########\r\n##############################\r\n\r\ndef extrude(json, header, v, rayon=None, lat=None, long=None ):\r\n    #main definition\r\n    for feature in json: \r\n        try:\r\n            coord = feature.geometry.coordinates\r\n        except:\r\n            continue\r\n        prop = feature.properties\r\n        z=0\r\n        if parseTree(coord) == 4:\r\n            coord[0] = coord[0][0]\r\n        c_x, c_y = centroid(coord[0])\r\n        if rayon:\r\n            di = distance(lat,long,c_y,c_x)\r\n            if di>rayon:\r\n                continue\r\n        z = approx_elevation(header,v,c_y,c_x)\r\n        for i in range(len(coord)):\r\n            for j in range(len(coord[i])):\r\n                coord[i][j] = toPt(coord[i][j],z)\r\n            coord[i] = rg.PolylineCurve(coord[i])\r\n        brep_face_GUID = rs.AddPlanarSrf(coord) #GUID\r\n        if \"H_MED\" in prop:\r\n            h = prop[\"H_MED\"]\r\n        else:\r\n            if \"H_MOY\" in prop:\r\n                h = prop[\"H_MOY\"]\r\n            else:\r\n                if \"H_MAX\" in prop:\r\n                    h = prop[\"H_MAX\"]\r\n                else:\r\n                    if \"l_plan_h\" in prop:\r\n                        h = prop[\"l_plan_h\"]\r\n                        if h is None:\r\n                            h=3\r\n                        else:\r\n                            if h==\"R\":\r\n                                h=3\r\n                            else:\r\n                                h=float(h[-1])*3\r\n                    else:\r\n                        h = 3\r\n        try:\r\n            extrude_path = rs.AddLine((0,0,0), (0,0,h))\r\n        except:\r\n            print \"error extrude\"\r\n            continue\r\n        objectref_path = rh.DocObjects.ObjRef(extrude_path)\r\n        path_curve = rh.DocObjects.ObjRef.Curve(objectref_path)\r\n        object_reference = rh.DocObjects.ObjRef(brep_face_GUID[0])\r\n        brep_face = rh.DocObjects.ObjRef.Face(object_reference)\r\n        brep_extrude = rh.Geometry.BrepFace.CreateExtrusion(brep_face, path_curve, True)\r\n        added_brep = sc.doc.Objects.AddBrep(brep_extrude)\r\n        try:\r\n            rs.ObjectName(added_brep,str(prop[\"OBJECTID\"]))\r\n        except:\r\n            rs.ObjectName(added_brep,\"noID\")\r\n        try:\r\n            rs.DeleteObject(brep_face_GUID)\r\n        except:\r\n            print \"error\"\r\n        rs.DeleteObject(extrude_path)\r\n\r\n###############################\r\n##########   START    #########\r\n###############################\r\n\r\nrs.EnableRedraw(False)\r\n\r\n#YOUR BASE FOR EXTRUSION FILE AS GEOJSON\r\n#either without path if in same directory or with path\r\ncadastre_f = 'D:/DATA/g.meunier/Desktop/elev/emprise_bati_paris.geojson'\r\n\r\n#YOUR ELEVATION FILE AS HDR\r\n# expects to also find bil file in same folder\r\nelevation_f = \"elev-decoupe75.hdr\"\r\n\r\n#IF YOU WANT A SMALL PART OF PARIS (IF YOU DON'T USE ZERO IN  radius_around\r\n#THE ADDRESS YOU WANT\r\naddress_f = \"\"\r\naddress_f = \"20 rue Gasnier-Guy Paris\"\r\n\r\n#AND THE RADIUS AROUND THIS ADDRESS IN METER (OR ZERO)\r\nradius_around = 400\r\n\r\n#CALCULATION\r\nextrude_json = pygeoj.load(cadastre_f)\r\nelevation_file = BilParser(elevation_f)\r\nh = elevation_file.header\r\nv = elevation_file.values\r\n\r\n#test if radius_around>0 or exist\r\nif radius_around:\r\n    if address_f:\r\n        address_coord_lat,address_coord_lon = nominatim(address_f)\r\n        extrude(extrude_json, h, v, radius_around, address_coord_lat, address_coord_lon)\r\n    else:\r\n        print \"need an address or no radius\"\r\nelse:\r\n    extrude(extrude_json, h, v)\r\n\r\n#COULD USE MULTITHREADING :\r\n#https://stevebaer.wordpress.com/2011/06/01/multithreaded-python/\r\n\r\nprint \"done\"\r\nrs.EnableRedraw(True);",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}