{
  "source_url": "https://github.com/localsoftware/localsoftware_rhino-grasshopper/blob/4aafec57e33b9f09cce6fd73dcda12b17cf794a5/plugin_files/Import_GeoJSON.py",
  "repo": "localsoftware/localsoftware_rhino-grasshopper",
  "repo_stars": 0,
  "repo_description": null,
  "license": "BSD-2-Clause",
  "filepath": "plugin_files/Import_GeoJSON.py",
  "instruction": "Import geo json",
  "code": "ï»¿from ghpythonlib.componentbase import dotnetcompiledcomponent as component\nimport Grasshopper, GhPython, System, Rhino, json\n\n# Import standard library modules\nfrom Rhino.Geometry import *\nfrom scriptcontext import doc\n\n# import .NET libraries\nfrom System import Object\nimport rhinoscriptsyntax as rs\nimport sys, os\n\n# import GH dependencies\nfrom clr import AddReference as addr\naddr(\"Grasshopper\")\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\n\n\nclass MyComponent(component):\n    def __new__(cls):\n        instance = Grasshopper.Kernel.GH_Component.__new__(cls,\n            \"ImportGeoJSON\", \"ImportGeoJSON\", \"\"\"Imports geometry from GeoJSON files into grasshopper.\nPreserves layer hierarchy as data tree.\nThe Import GeoJSON component extracts the GIS attributes from the geoJSON files.\nBased on the work of Jackie Berry.\n    Typical usage:\nInput a path as a string.\"\"\", \"Extra\", \"LocalCode\")\n        return instance\n    \n    def get_ComponentGuid(self):\n        return System.Guid(\"0b9dd6c3-192c-47a1-a146-58d11f1018cf\")\n    \n    def SetUpParam(self, p, name, nickname, description):\n        p.Name = name\n        p.NickName = nickname\n        p.Description = description\n        p.Optional = True\n    \n    def RegisterInputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_Boolean()\n        self.SetUpParam(p, \"Import\", \"Import\", \"boolean to start import\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        self.Params.Input.Add(p)\n        \n        p = GhPython.Assemblies.MarshalParam()\n        self.SetUpParam(p, \"geoJSONFolderPath\", \"geoJSONFolderPath\", \"path to folder with GeoJSON files\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        self.Params.Input.Add(p)\n        \n        p = Grasshopper.Kernel.Parameters.Param_Integer()\n        self.SetUpParam(p, \"SiteNumber\", \"SiteNumber\", \"Script input SiteNumber.\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        self.Params.Input.Add(p)\n        \n    \n    def RegisterOutputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"Geometry\", \"Geometry\", \"The imported geometry ingo gh space\")\n        self.Params.Output.Add(p)\n        \n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"Attributes\", \"Attributes\", \"attributes of objects / layers\")\n        self.Params.Output.Add(p)\n        \n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"Values\", \"Values\", \"evaluated values\")\n        self.Params.Output.Add(p)\n        \n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"LayerNames\", \"LayerNames\", \"list of layer names\")\n        self.Params.Output.Add(p)\n        \n    \n    def SolveInstance(self, DA):\n        p0 = self.marshal.GetInput(DA, 0)\n        p1 = self.marshal.GetInput(DA, 1)\n        p2 = self.marshal.GetInput(DA, 2)\n        result = self.RunScript(p0, p1, p2)\n\n        if result is not None:\n            if not hasattr(result, '__getitem__'):\n                self.marshal.SetOutput(result, DA, 0, True)\n            else:\n                self.marshal.SetOutput(result[0], DA, 0, True)\n                self.marshal.SetOutput(result[1], DA, 1, True)\n                self.marshal.SetOutput(result[2], DA, 2, True)\n                self.marshal.SetOutput(result[3], DA, 3, True)\n        \n    def get_Internal_Icon_24x24(self):\n        o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAHYcAAB2HAY/l8WUAAANuSURBVEhLxVVrSJRBFF2jcrcye6irbio+dnUzN3XVNtZ87KpoikFQQmmhVPSmEiOtpHJ7WEQYalEp9DIxQ9N8LEZZmYiPAjH7EVQG/RAjCist10535muJyq1gKz84zMydO/fMvTNnPtH/+vwIWf8AGgL/Vu3Y4g6jMQSN1YHWo1GNowYFKK5BCC8SpZSf9wMQR4j6C9Cj424II8gRwhNB6SkFTeiAwUXWg0hu1weNJ8G7rzD3hyK+jX9lM7e/JfgYKQRg/c9R+PRaaPnirwG4jdWbjd+T7yj1mT9bR3Fu1VkiMEVjV6Y3Lp71p3EMdmd5wm7aJOTu8iKSaLJFY89OL27LzvSkMTtQNVavmMPXV11RofDEXDxsDbVAQIjVOSE/zwf9fVq4Ok9B/iEFpk61Rd9jDbpaQiAWT8Zhgy8kkslop+AP7/Mbg4EXWpw5qcSGNR541BFmmWBJkjOKTyjQTHVMjJeSLRnbN7uj9XYwtR6UIdt5Is9u0zo3PO3RcILTBb64ejGAfDzR0/4bgoKjcvQ/08LWdiKlTBr5KNzvOL0jqssDeL/+mop8pehuC8N0OwmS4p1wrsgfmVv/gODQPh/qx+FArjffnVYzE6ZhPWKiHHCzVsX9WpqCkJTggjuNwUhOdCVyJ6xY7kbn5W2JIIag5wT5eXIM9EfgDaGzbQGcpRLUV87HsqXOqKOdM7+mmvkUWIq7xmCsTXfHkf1yOh8xbU7+M0HFBSX2ZsvR+0CD9DQZr2dJkRLpqex2JCNrmxcKj/vxMzBQVsBiHDsoR8YqGdqb1ViZIkNf70Ke7b6cMTKoqfBHCu1ufYYbVPPscZ3q3NsZihn2YtRWB8NXYYdbNwJxzxiE2bPEqKlSw9FBgoYqFS9VQhy7DLE8020bx7hFlZeU6GoNg43NBPgrp2PwFROSDqtXyviuYnWOGB2igyYtpKa4ks2GyuXCS9XcEEhZs0xjsT/HC7mUQXfbDzooKRbO4OUTDYYGwoFhUuR7IqHb87x3ASmWxkylH5gtkjRBtmFS/IcImN6Gk7JpDVMyqXpkJJJILSmZJnlw5swXEExCoO9szI+1bMyeC/M8s5Hax/k1tRZjEVRcMP/RhAfNOsSg6973f7S0dRkylJUF4nLpPKtRVqaiF5e/AHlCeJHIk5BBSP+LoHgi1Rd2XtKzWw9aPQAAAABJRU5ErkJggg==\"\n        return System.Drawing.Bitmap(System.IO.MemoryStream(System.Convert.FromBase64String(o)))\n\n\n    def RunScript(self, Import, geoJSONFolderPath, SiteNumber):\n        Geometry, Attributes, Values, LayerNames = None, None, None, None\n        def addRhinoLayer(layerName, layerColor=System.Drawing.Color.Black):\n            \"\"\"Creates a Layer in Rhino using a name and optional color. Returns the\n            index of the layer requested. If the layer\n            already exists, the color is updated and no new layer is created.\"\"\"\n            docLyrs = doc.Layers\n            layerIndex = docLyrs.Find(layerName, True)\n            if layerIndex == -1:\n                layerIndex = docLyrs.Add(layerName,layerColor)\n            else: # it exists\n                layer = docLyrs[layerIndex] # so get it\n                if layer.Color != layerColor: # if it has a different color\n                    layer.Color = layerColor # reset the color\n            return layerIndex\n\n\n        def PointToRhinoPoint(coordinates):\n            if len(coordinates) > 2:\n                z = coordinates[2]\n            else:\n                z = 0.0\n            x, y = coordinates[0], coordinates[1]\n            return Point3d(x, y, z)\n\n\n        def MultiPointToRhinoPoint(coordinates):\n            rhPointList = []\n            for point in coordinates:\n                rhPointList.append(PointToRhinoPoint(point))\n            return rhPointList\n\n\n        def MeshToRhinoMesh(coordinates, faces):\n            rhMesh = Mesh()\n            for point in coordinates:\n                rhPoint = PointToRhinoPoint(point)\n                rhMesh.Vertices.Add(rhPoint)\n            for face in faces:\n                i, j, k = tuple(face)\n                mFace = MeshFace(i, j, k)\n                rhMesh.Faces.AddFace(mFace)\n            rhMesh.Normals.ComputeNormals()\n            rhMesh.Compact()\n            return rhMesh\n\n\n        def LineStringToRhinoCurve(coordinates):\n            rhPoints = MultiPointToRhinoPoint(coordinates)\n            return Curve.CreateControlPointCurve(rhPoints, 1)\n\n\n        def MultiLineStringToRhinoCurve(coordinates):\n            rhCurveList = []\n            for lineString in coordinates:\n                rhCurveList.append(LineStringToRhinoCurve(lineString))\n            return rhCurveList\n\n\n        def PolygonToRhinoCurve(coordinates):\n            # each ring is a separate list of coordinates\n            ringList = []\n            for ring in coordinates:\n                ringList.append(LineStringToRhinoCurve(ring))\n            return ringList\n\n\n        def MultiPolygonToRhinoCurve(coordinates):\n            polygonList = []\n            for polygon in coordinates:\n                polygonList.append(PolygonToRhinoCurve(polygon))\n            return polygonList\n\n\n        def GeometryCollectionToParser(geometries):\n            pass # I need to figure this one out still\n\n\n        def addPoint(rhPoint, objAtt):\n            return doc.Objects.AddPoint(rhPoint, objAtt)\n\n\n        def addPoints(rhPoints, objAtt):\n            guidList = []\n            for rhPoint in rhPoints:\n                guidList.append(doc.Objects.AddPoint(rhPoint, objAtt))\n            return guidList\n\n\n        def addCurve(rhCurve, objAtt):\n            return doc.Objects.AddCurve(rhCurve, objAtt)\n\n\n        def addCurves(rhCurves, objAtt):\n            guidList = []\n            for curve in rhCurves:\n                guidList.append(addCurve(curve, objAtt))\n            return guidList\n\n\n        def addPolygon(ringList, objAtt):\n            # for now this just makes curves\n            # but maybe it should make TrimmedSrfs\n            # or should group the rings\n            return addCurves(ringList, objAtt)\n\n\n        def addPolygons(polygonList, objAtt):\n            guidList = []\n            for polygon in polygonList:\n                # !! Extending the guid list !!!\n                guidList.extend(addPolygon(polygon, objAtt))\n            return guidList\n\n\n        def addMesh(rhMesh, objAtt):\n            return doc.Objects.AddMesh(rhMesh, objAtt)\n\n\n        def setUserKeys(properties, objAttributes):\n            for key in properties:\n                objAttributes.SetUserString(key, str(properties[key]))\n            return objAttributes\n\n\n        def jsonToRhinoCommon(jsonFeature):\n                # deal with the geometry\n                geom = jsonFeature['geometry']\n                geomType = geom['type'] # this will return a mappable string\n                coordinates = geom['coordinates']\n                # if this is a mesh, pass the faces\n                if geomType == 'Mesh':\n                    faces = geom['faces']\n                    rhFeature = geoJsonGeometryMap[geomType][0](coordinates, faces)\n                # translate the coordinates to Rhino.Geometry objects\n                else:\n                    rhFeature = geoJsonGeometryMap[geomType][0](coordinates)\n                return rhFeature\n\n\n        def addJsonFeature(jsonFeature, objAttributes):\n                # deal with the properties\n                if jsonFeature['properties']:\n                    objAttributes = setUserKeys(jsonFeature['properties'], objAttributes)\n                geomType = jsonFeature['geometry']['type']\n                rhFeature = jsonToRhinoCommon(jsonFeature)\n                # return the GUID(s) for the feature\n                return geoJsonGeometryMap[geomType][1](rhFeature, objAttributes)\n\n\n        def processGeoJson(parsedGeoJson,\n                 destinationLayer=None,\n                 destinationLayerColor=System.Drawing.Color.Black):\n            # get the features\n            jsonFeatures = parsedGeoJson['features']\n            guidResults = []\n            # set up object attributes\n            for jsonFeature in jsonFeatures: # for each feature\n                att = Rhino.DocObjects.ObjectAttributes()\n                # setup layer if requested\n                if destinationLayer != None:\n                    destinationLayer = None\n                    #att.LayerIndex = addRhinoLayer(destinationLayer,\n                                                   #destinationLayerColor)\n                guidResults.append(addJsonFeature(jsonFeature, att))\n            # return all the guids\n            return guidResults\n\n\n        def load(rawJsonData,\n                 prefix=None,\n                 destinationLayer=None,\n                 destinationLayerColor=System.Drawing.Color.Black):\n            # if the data already appears to be a dict literal ...\n            if type(rawJsonData) == dict:\n                jsonData = rawJsonData\n            else: # otherwise, just try to load it\n                jsonData = json.loads(rawJsonData)\n            # if this is just a GeoJSON ...\n            if jsonData[\"type\"] == \"FeatureCollection\":\n                # process the GeoJSON, pass the layer and color in\n                return processGeoJson(jsonData, destinationLayer,\n                                      destinationLayerColor)\n            # or if this is a set of layers from PostSites ...\n            elif jsonData[\"type\"] == \"LayerCollection\":\n                # make a list for all the guids\n                allResults = []\n                layersList = jsonData['layers']\n                for layer in layersList: # for each layer\n                    name = prefix + layer['name'] # get the name, modified to add filename to\n                    if 'color' in layer: # get the color if it exists\n                        color = layer['color']\n                    else:\n                        color = destinationLayerColor # or just make it black\n                    geoJson = layer['contents'] # get the GeoJSON for this layer\n                    # make it\n                    layerResults = processGeoJson( geoJson, name, color )\n                    allResults.append(layerResults)\n                return allResults, layersList\n            else:\n                self.AddRuntimeMessage(RML.Error,\"This doesn't look like correctly formatted GeoJSON data.\\nI'm not sure what to do with it, sorry.\")\n                return \"This doesn't look like correctly formatted GeoJSON data.\\nI'm not sure what to do with it, sorry.\"\n\n\n        def getAttsVals(id,path=None):\n            objct = doc.Objects.Find(id)\n            data = objct.Attributes.GetUserStrings()\n            d = {}\n            k = []\n            v = []\n            if path==None:\n                for u in sorted(data):\n                    k.append(u)\n                    print k\n                    d[u] = data[u]\n                    v.append(d[u])\n                U = d\n                Atts = k\n                Vals = v\n                return Atts,Vals\n            if path:\n                for u in data:\n                    k.append(u)\n                    d[u] = data[u]\n                    v.append(d[u])\n                    Attributes.Add(u,path)\n                    Values.Add(d[u],path)\n                return None,None\n\n\n        def importSitefolder(filepath):\n            f = str(SiteNumber)\n            prefix = str(f +\"_\")\n\n            try:\n                thisfilepath = os.path.join(filepath, f)\n                f = open(thisfilepath,'r')\n            except:\n                f = str(SiteNumber)+\".txt\"\n                thisfilepath = os.path.join(filepath, f)\n                f = open(thisfilepath,'r')\n            myGeoJson = f.readline()\n            guidList,layersList = load(myGeoJson, prefix)\n            idsOut.append(guidList)\n            layerNamesOut.append(layersList)\n            f.close()\n\n\n\n        def constructTree():\n            ### NOTE: some problems with mutlipolygons being nested 'up' a level. This problem is rooted in 'loader'\n            ### it needs to be debugged out\n            for i in range (len(layerNamesOut[0])):\n                p = GH_Path(i)\n                LayerNames.Add(layerNamesOut[0][i]['name'],p)\n            for A in idsOut:#for each file\n                for i in range (len(A)):# for each layer\n                    try:\n                        p = GH_Path(i)#make a new data tree path\n                        if (len(A[i])>1):# if the datatree path has more than one item\n                            for j in range (len(A[i])):# iterate\n                                try:\n                                    thisId = A[i][j][0]\n                                    pPrime = p.AppendElement(j)\n                                    Geometry.Add(thisId,p)# add each feature to the path\n                                    getAttsVals(thisId,pPrime)\n                                except:\n                                    ### It must be a point (tuple), cannot subscript it, grab it directly\n                                    try:\n                                        thisId = A[i][j]\n                                        pPrime = p.AppendElement(j)\n                                        Geometry.Add(thisId,p)\n                                        getAttsVals(thisId,pPrime)\n                                    except:\n                                        continue\n                        else:#otherwise, the layer has only one item (it is either a 1 item layer or a multipolygon)\n                            #it is a single object layer\n                            try:\n                                thisId = A[i][0]\n                                pPrime = p.AppendElement(0)\n                                Geometry.Add(thisId,p)\n                                getAttsVals(thisId,pPrime)\n                            except: #multipolygon is nested one level\n                                print \"Multipolygon found, some list-cleanup may be needed\"\n                                thisId = A[i][0][0]\n                                pPrime = p.AppendElement(0)\n                                Geometry.Add(thisId,p)\n                                getAttsVals(thisId,pPrime)\n                    except:\n                        print 'There were some problems importing a layer, please try again with a different set of layers'\n                        continue\n            return\n\n\n\n        geoJsonGeometryMap = {\n                'Point':(PointToRhinoPoint, addPoint),\n                'MultiPoint':(MultiPointToRhinoPoint, addPoints),\n                'LineString':(LineStringToRhinoCurve, addCurve),\n                'MultiLineString':(MultiLineStringToRhinoCurve, addCurves),\n                'Polygon':(PolygonToRhinoCurve, addPolygon),\n                'MultiPolygon':(MultiPolygonToRhinoCurve, addPolygons),\n                'Mesh':(MeshToRhinoMesh, addMesh),\n                'GeometryCollection':(GeometryCollectionToParser),\n                }\n\n\n        \"\"\"\n        To run the code\n        \"\"\"\n        if Import!= None and type(Import) == bool:\n            if Import == True:\n                try:\n                    idsOut = []\n                    layerNamesOut = []\n                    importSitefolder(geoJSONFolderPath)\n\n                    if idsOut != None:\n                        Geometry = DataTree[Object]()\n                        Attributes = DataTree[Object]()\n                        Values = DataTree[Object]()\n                        LayerNames = DataTree[Object]()\n                        constructTree()\n                        print 'You succesfully imported a geoJSON file!'\n                        self.AddRuntimeMessage(RML.Remark,\"You succesfully imported a geoJSON file\")\n                    else:\n                        print 'There was some problem with your geoJSON file, we imported as many layers as possible!'\n                        self.AddRuntimeMessage(RML.Error,\"There was some problem with your geoJSON file, we imported as many layers as possible!\")\n\n                except:\n                    pass\n        else:\n            print 'To Import you need to input a boolean toggle'\n            self.AddRuntimeMessage(RML.Warning,\"To Import you need to input a boolean toggle\")\n\n        # return outputs if you have them; here I try it for you:\n        return (Geometry, Attributes, Values, LayerNames)\n\n\nimport GhPython\nimport System\n\nclass AssemblyInfo(GhPython.Assemblies.PythonAssemblyInfo):\n    def get_AssemblyName(self):\n        return \"ImportGeoJSON\"\n    \n    def get_AssemblyDescription(self):\n        return \"\"\"\"\"\"\n\n    def get_AssemblyVersion(self):\n        return \"0.1\"\n\n    def get_AuthorName(self):\n        return \"\"\n    \n    def get_Id(self):\n        return System.Guid(\"4cdd4cd6-7794-4a13-aa27-1a1ead0b8943\")",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}