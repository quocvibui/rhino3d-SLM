{
  "source_url": "https://github.com/evdanil/cn-tool/blob/d83b0c68efb5aaf10f09f1b77ddd5c992157f4af/core/background.py",
  "repo": "evdanil/cn-tool",
  "repo_stars": 1,
  "repo_description": "Utility allowing to receive information from Infoblox API",
  "license": "unknown",
  "filepath": "core/background.py",
  "instruction": "Background",
  "code": "import threading\nfrom time import time, sleep\nfrom core.base import ScriptContext\nfrom utils.cache import CacheManager\nfrom utils.cache_helpers import mt_index_configurations\n\n\ndef start_background_tasks(ctx: ScriptContext) -> None:\n    \"\"\"\n    Initializes and starts all non-blocking background processes for the application.\n    \"\"\"\n    if ctx.cfg.get(\"cache_enabled\", False):\n        # Initialize the CacheManager instance and attach it to the context\n        ctx.cache = CacheManager.get_instance(\n            directory=ctx.cfg[\"cache_directory\"],\n            logger=ctx.logger\n        )\n        # Start the cache indexing in a separate thread\n        threading.Thread(target=_background_cache_init, args=[ctx], daemon=True).start()\n\n\ndef _background_cache_init(ctx: ScriptContext) -> None:\n    \"\"\"\n    Checks the cache state and triggers a re-index if necessary.\n    This function is designed to be run in a background thread.\n    (Original `background_cache_init` logic)\n    \"\"\"\n    logger = ctx.logger\n    if not ctx.cache:\n        logger.info(\"Index Cache - Cache does not exist, skipping.\")\n        return\n\n    cache: CacheManager = ctx.cache\n\n    if cache.dc.get(\"indexing\"):\n        logger.info(\"Index Cache - Another process is already indexing; will watch and recheck later.\")\n        threading.Thread(target=_wait_for_indexing_and_recheck, args=[ctx], daemon=True).start()\n        return\n\n    updated_time = cache.dc.get(\"updated\", 0)\n    if not isinstance(updated_time, (int, float)):\n        return\n\n    # Check if the cache was updated recently and if versions match\n    if (int(time()) - int(updated_time)) <= 30 and cache.dc.get(\"version\") == ctx.cfg.get(\"cache_version\", None):\n        logger.info(\"Index Cache - State is up-to-date, skipping checks.\")\n        cache.log_stats(\"startup-check\")\n        return\n\n    if cache.dc.get(\"version\") != ctx.cfg[\"cache_version\"]:\n        logger.info(f\"Index Cache - New cache version {ctx.cfg.get('cache_version', 'Unspecified')} in config.\")\n        # Mark resetting so UI doesn't briefly show Ready/0 devices\n        try:\n            cache.dc.set(\"indexing\", True)\n            cache.dc.set(\"indexing_phase\", \"resetting\")\n            cache.dc.set(\"indexing_started\", int(time()))\n            cache.dc.set(\"indexing_last_update\", int(time()))\n        except Exception:\n            pass\n        cache.reset_cache()\n\n    logger.info(\"Index Cache - Starting cache check and potential re-indexing.\")\n    try:\n        mt_index_configurations(ctx)\n    except Exception as e:\n        logger.error(f\"Index Cache - Error during background initialization: {e}\", exc_info=True)\n        # Ensure the indexing flag is cleared on error\n        cache.dc.pop(\"indexing\", None)\n\n\ndef _recheck_and_index_if_needed(ctx: ScriptContext) -> None:\n    \"\"\"\n    Re-run the same readiness check and trigger indexing if needed.\n    Used when we started while another process was indexing.\n    \"\"\"\n    logger = ctx.logger\n    cache: CacheManager = ctx.cache  # type: ignore\n\n    if cache.dc.get(\"version\") != ctx.cfg[\"cache_version\"]:\n        logger.info(\"Index Cache - Detected version change during recheck; resetting cache.\")\n        cache.reset_cache()\n\n    updated_time = cache.dc.get(\"updated\", 0)\n    if not isinstance(updated_time, (int, float)):\n        updated_time = 0\n\n    if (int(time()) - int(updated_time)) <= 30 and cache.dc.get(\"version\") == ctx.cfg.get(\"cache_version\", None):\n        logger.info(\"Index Cache - State is up-to-date on recheck, skipping.\")\n        cache.log_stats(\"post-foreign-index-recheck\")\n        return\n\n    logger.info(\"Index Cache - Rechecking cache; starting (re-)index if necessary.\")\n    try:\n        mt_index_configurations(ctx)\n    except Exception as e:\n        logger.error(f\"Index Cache - Error during recheck: {e}\", exc_info=True)\n        cache.dc.pop(\"indexing\", None)\n\n\ndef _wait_for_indexing_and_recheck(ctx: ScriptContext) -> None:\n    \"\"\"\n    Waits for an external indexing to complete or become stale, then rechecks and indexes if needed.\n    \"\"\"\n    logger = ctx.logger\n    cache: CacheManager = ctx.cache  # type: ignore\n    STALE_SECONDS = 180\n    POLL_SECONDS = 5\n\n    start_seen = int(cache.dc.get(\"indexing_started\", 0) or 0)\n    while True:\n        try:\n            # If an error was recorded during indexing, stop waiting and surface it\n            if cache.dc.get(\"indexing_error\"):\n                logger.error(\"Index Cache - External indexing signaled an error. Rechecking will not start automatically.\")\n                cache.dc.pop(\"indexing\", None)\n                break\n            if not cache.dc.get(\"indexing\"):\n                logger.info(\"Index Cache - External indexing finished (flag cleared). Rechecking.\")\n                break\n            last = int(cache.dc.get(\"indexing_last_update\", 0) or 0)\n            if (int(time()) - last) > STALE_SECONDS:\n                logger.warning(\"Index Cache - External indexing appears stale; clearing flag and rechecking.\")\n                cache.dc.pop(\"indexing\", None)\n                break\n        except Exception:\n            # Conservative: break and recheck if we cannot read the flag\n            break\n        sleep(POLL_SECONDS)\n\n    _recheck_and_index_if_needed(ctx)\n",
  "language": "python",
  "imports": [],
  "has_docstring": false
}