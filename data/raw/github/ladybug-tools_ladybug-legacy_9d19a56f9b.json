{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Line%20Chart.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Line Chart.py",
  "instruction": "Use this component to make a line chart in the Rhino scene of any data with a ladybug header on it.",
  "code": "# This component creates a bar chart of monthly or avrMonthlyPerHour data.\n#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Chris Mackey <chris@ladybug.tools> \n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to make a line chart in the Rhino scene of any data with a ladybug header on it.\n\n-\nProvided by Ladybug 0.0.69\n    \n    Args:\n        _inputData: A list of input data to plot.  This should usually be data out of the \"Ladybug_Average Data\" component or monthly data from an energy simulation but can also be hourly or daily data from the \"Ladybug_Import EPW.\"  However, it is recommended that you use the \"Ladybug_3D Chart\" component for daily or hourly data as this is usually a bit clearer.\n        chartType_: An integer that sets the type of chart that will be drawn.  Choose from the following options:\n            0 = Normal - Data will be plotted as polylines right next to each other.\n            1 = Stacked - Data will be plotted as lines stacked on top of one another.\n            2 = Stacked Area - Data will be plotted as filled areas stacked on top of one another.\n        altTitle_: An optional text string to replace the default title of the chart of the chart.  The default is set to pick out the location of the data connected to 'inputData.'\n        altYAxisTitle_: An optional text string to replace the default Y-Axis label of the chart.  This can also be a list of 2 y-axis titles if there are two different types of data connected to _inputData.  The default is set to pick out the names of the first (and possibly the second) list connected to the 'inputData.'\n        _basePoint_: An optional point with which to locate the 3D chart in the Rhino Model.  The default is set to the Rhino origin at (0,0,0).\n        _xScale_: The scale of the X axis of the graph. The default is set to 1 and this will plot the X axis with a length of 120 Rhino model units (for 12 months of the year).\n        _yScale_: The scale of the Y axis of the graph. The default is set to 1 and this will plot the Y axis with a length of 50 Rhino model units.\n        legendPar_: Optional legend parameters from the Ladybug Legend Parameters component.\n        bakeIt_ : An integer that tells the component if/how to bake the bojects in the Rhino scene.  The default is set to 0.  Choose from the following options:\n            0 (or False) - No geometry will be baked into the Rhino scene (this is the default).\n            1 (or True) - The geometry will be baked into the Rhino scene as a colored hatch and Rhino text objects, which facilitates easy export to PDF or vector-editing programs. \n            2 - The geometry will be baked into the Rhino scene as colored meshes, which is useful for recording the results of paramteric runs as light Rhino geometry.\n    Returns:\n        readMe!: ...\n        dataMesh: A list of meshes that represent the different input data.\n        dataCurves: A list of curves that represent the different input data.\n        dataCrvColors: A list of colors that correspond to the dataCurves above.  Hook this up to the 'swatch' input of the native Grasshopper 'Preview' component and the curves above up to the 'geometry input to preview the curves with their repective color.\n        graphAxes: A list of curves representing the axes of the chart.\n        graphLabels: A list of text meshes representing the time periods corresponding to the input data\n        title: A title for the chart.  By default, this is just the location of the data but you can input a custom title with the altTitle_ input.\n        titleBasePt: The title base point, which can be used to move the title in relation to the chart with the grasshopper \"move\" component.\n        legend: A legend of the chart that tells what each connected data stram's color is. Connect this output to a grasshopper \"Geo\" component in order to preview the legend in the Rhino scene.\n        legendBasePt: The legend base point, which can be used to move the legend in relation to the chart with the grasshopper \"move\" component.\n\"\"\"\n\nghenv.Component.Name = \"Ladybug_Line Chart\"\nghenv.Component.NickName = 'LineChart'\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"2 | VisualizeWeatherData\"\n#compatibleLBVersion = VER 0.0.59\\nJAN_24_2016\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"1\"\nexcept: pass\n\nimport scriptcontext as sc\nimport Rhino as rc\nimport Grasshopper.Kernel as gh\nimport copy\nimport math\n\ndef checkTheInputs(lb_preparation, lb_visualization, lb_comfortModels):\n    if len(_inputData)== 0:  return -1\n    elif _inputData[0] == None: return -1\n    else:\n        # separate the data\n        indexList, listInfo = lb_preparation.separateList(_inputData, lb_preparation.strToBeFound)\n        #separate the lists of data\n        separatedLists = []\n        for i in range(len(indexList)-1):\n            selList = []\n            [selList.append(float(x)) for x in _inputData[indexList[i]+7:indexList[i+1]]]\n            separatedLists.append(selList)\n        \n        #Set a default for chartType_.\n        if chartType_ != None:\n            chartType = chartType_\n        else: chartType = 0\n        \n        #Set defaults for xScale and yScale.\n        if _xScale_ != None: xS = _xScale_\n        else: xS = 1\n        if _yScale_ != None: yS = _yScale_\n        else: yS = 1\n        \n        #Check the altYAxisTitle_ input.\n        checkData = True\n        if len(altYAxisTitle_) <=2: pass\n        else:\n            checkData = False\n            warning = 'altYAxisTitle_ cannot be more than 2 values (one for each side of the chart).'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n        \n        # Organize the data tree of legend parameters.\n        legendPs = []\n        for i in range(legendPar_.BranchCount):\n            legendPs.append(legendPar_.Branch(i))\n        if len(legendPs) == 0: legendPs.append([])\n        \n        return checkData, separatedLists, listInfo, chartType, xS, yS, legendPs\n\ndef makeChartCrvs(separatedLists, listInfo, chartType, xS, yS, legendPs, lb_preparation, lb_visualization):\n    #Read legend parameters\n    lowBNotImp, highBNotImp, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan = lb_preparation.readLegendParameters(legendPs[0], False)\n    numSeg = int(numSeg)\n    \n    #Set some defaults.\n    if legendFontSize == None: legendFontSize = 1\n    allText = []\n    allTextPt = []\n    \n    unitsList = []\n    dataTypeList = []\n    futureColorsList = []\n    dataList = []\n    lowBList = []\n    highBList = []\n    dataLenList = []\n    stackIndices = []\n    \n    ### ANALYZE THE INPUT DATA TO SEE WHAT WE HAVE ###\n    for listCount, lst in enumerate(separatedLists):\n        #Read the legendPar for the data set.\n        try:\n            lowBInit, highBInit, numSegNotImportant, customColorsNotImportant, legendBasePointNotImportant, legendScaleNotImportant, legendFontNotImportant, legendFontSizeNotImportant, legendBoldNotImportant, decimalPlacesNotImportant, removeLessThanNotImportant = lb_preparation.readLegendParameters(legendPs[listCount], False)\n            lowBList.append(lowBInit)\n            highBList.append(highBInit)\n        except:\n            lowBList.append('min')\n            highBList.append('max')\n        dataLenList.append(len(lst))\n        \n        #Append everything to the full list of data.\n        if listInfo[listCount][3] in unitsList and chartType > 0:\n            stackIndices.append([])\n            for formatCount, formatList in enumerate(unitsList):\n                if listInfo[listCount][3] == formatList:\n                    stackIndices[listCount].append(formatCount)\n        else:\n            stackIndices.append(-1)\n        \n        dataList.append(lst)\n        unitsList.append(listInfo[listCount][3])\n        dataTypeList.append([listInfo[listCount][2]])\n        futureColorsList.append([0])\n    \n    \n    ### DRAW AN INITIAL BOUNDARY AROUND THE CHART ###\n    chartAxes = []\n    textSrfs = []\n    \n    #Make a chart boundary.\n    dataLenList.sort()\n    maxLen = dataLenList[-1]\n    width = xS * 0.1 * (maxLen-1)\n    height = yS * 50\n    chartAxes.append(rc.Geometry.Rectangle3d(rc.Geometry.Plane.WorldXY, width, height).ToNurbsCurve())\n    \n    #Make a chart with the number of y segments from the legendPar.\n    gridLines = []\n    yAxisLeftPts = []\n    yAxisRightPts = []\n    segHeight = 0\n    for segmentNum in range(numSeg):\n        gridLine = rc.Geometry.Line(0,segHeight,0,width,segHeight,0).ToNurbsCurve()\n        gridLines.append(gridLine)\n        yAxisLeftPts.append(rc.Geometry.Point3d(-8*legendFontSize,segHeight,0))\n        yAxisRightPts.append(rc.Geometry.Point3d(legendFontSize+width,segHeight,0))\n        segHeight = segHeight + (height/(int(numSeg) - 1))\n    chartAxes.extend(gridLines)\n    \n    # Correctly Label the Y-Values.\n    negativeTrigger = False\n    \n    # Make a function that checks the range of the data and comes up with a scaling factor for the data.\n    def makeNumberLabels(valueList, leftOrRight, lowB, highB):\n        newNegativeTrigger = negativeTrigger\n        cumulative = False\n        valList = copy.deepcopy(valueList)\n        \n        valList.sort()\n        if lowB == 'min': lowB = valList[0]\n        if highB == 'max': highB = valList[-1]\n        if cumulative == True:\n            if sum(negValList) < 0:\n                lowB = negValList[0]\n                newNegativeTrigger = True\n                if -lowB < highB: lowB = -highB\n                else:\n                    highB = -lowB\n            else: lowB = 0\n        \n        valRange = highB - lowB\n        valStep = valRange/(numSeg-1)\n        \n        finalValues = []\n        for num in range(numSeg):\n            finalValues.append(str(round(lowB + num*valStep, 2)))\n        \n        return lowB, valRange, finalValues, newNegativeTrigger\n    \n    #Make lists of start values and scale factors for each of the data types.\n    startVals = []\n    scaleFacs = []\n    \n    #Put in right Y axis labels.\n    basePt = rc.Geometry.Point3d(-9*legendFontSize, 0,0)\n    allTextPt.append(basePt)\n    if len(altYAxisTitle_) == 0:\n        yAxisSrf = lb_visualization.text2srf([dataTypeList[0][0] + ' (' + unitsList[0] + ')'], [basePt], legendFont, legendFontSize*1.5, legendBold)\n        allText.append(dataTypeList[0][0] + ' (' + unitsList[0] + ')')\n    else:\n        yAxisSrf = lb_visualization.text2srf([altYAxisTitle_[0]], [basePt], legendFont, legendFontSize*1.5, legendBold)\n        allText.append(altYAxisTitle_[0])\n    rotation = rc.Geometry.Transform.Rotation(math.pi/2, basePt)\n    for srf in yAxisSrf[0]:\n        srf.Transform(rotation)\n    textSrfs.extend(yAxisSrf[0])\n    lowVal1, valRange1, finalValues, negativeTrigger = makeNumberLabels(dataList[0], True, lowBList[0], highBList[0])\n    if valRange1 == 0:\n        valRange1 = 1\n        finalValues = []\n        valStep = valRange1/(numSeg-1)\n        for num in range(numSeg):\n            finalValues.append(str(round(lowVal1 + num*valStep, 2)))\n        warning = \"You have a list where all values are zero and this is would cause the Y-Axis to go from 0 to 0. \\n\" + \\\n        \"As a result the Y-Axis has automatically beeen set to go from 0 to 1.  Use legendPar to change this.\"\n        print warning\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    \n    startVals.append(lowVal1)\n    scaleFacs.append(valRange1/height)\n    #Move the text based on how long it is.\n    for ptCount, point in enumerate(yAxisLeftPts):\n        textLen = str(finalValues[ptCount])\n        textLen = len(list(textLen))\n        ptTransl = rc.Geometry.Transform.Translation(8-textLen, legendFontSize*(-0.5), 0)\n        point.Transform(ptTransl)\n    for count, valText in enumerate(finalValues):\n        textSrf = lb_visualization.text2srf([valText], [yAxisLeftPts[count]], legendFont, legendFontSize, legendBold)\n        textSrfs.extend(textSrf[0])\n    allTextPt.extend(yAxisLeftPts)\n    allText.extend(finalValues)\n    \n    #Put in left Y axis label and get scales for the rest of the data.\n    unit1 = unitsList[0]\n    unit2 = None\n    lowVal2 = None\n    valRange2 = None\n    axesTextSrf = []\n    done = False\n    for uCount, unit in enumerate(unitsList[1:]):\n        if unit.strip('') != unit1.strip('') and done == False:\n            unit2 = unitsList[uCount+1]\n            basePt = rc.Geometry.Point3d(9*legendFontSize+width, 0,0)\n            allTextPt.append(basePt)\n            if len(altYAxisTitle_) !=2:\n                yAxisSrf = lb_visualization.text2srf([dataTypeList[uCount+1][0] + ' (' + unitsList[uCount+1] + ')'], [basePt], legendFont, legendFontSize*1.5, legendBold)\n                allText.append(dataTypeList[uCount+1][0] + ' (' + unitsList[uCount+1] + ')')\n            else:\n                yAxisSrf = lb_visualization.text2srf([altYAxisTitle_[1]], [basePt], legendFont, legendFontSize*1.5, legendBold)\n                allText.append(altYAxisTitle_[1])\n            rotation = rc.Geometry.Transform.Rotation(math.pi/2, basePt)\n            for srf in yAxisSrf[0]:\n                srf.Transform(rotation)\n            textSrfs.extend(yAxisSrf[0])\n            lowVal2, valRange2, finalValues, negativeTrigger = makeNumberLabels(dataList[uCount+1], False, lowBList[uCount+1], highBList[uCount+1])\n            startVals.append(lowVal2)\n            scaleFacs.append(valRange2/height)\n            for count, valText in enumerate(finalValues):\n                axesTextSrf = lb_visualization.text2srf([valText], [yAxisRightPts[count]], legendFont, legendFontSize, legendBold)\n                textSrfs.extend(axesTextSrf[0])\n            allTextPt.extend(yAxisRightPts)\n            allText.extend(finalValues)\n            done = True\n        elif unit.strip('') == unit1.strip(''):\n            startVals.append(lowVal1)\n            scaleFacs.append(valRange1/height)\n        elif unit.strip('') == unit2.strip(''):\n            startVals.append(lowVal2)\n            scaleFacs.append(valRange2/height)\n        else:\n            lowVal, valRange, finalValues, negativeTrigger = makeNumberLabels(dataList[uCount+1], False, lowBList[uCount+1], highBList[uCount+1])\n            startVals.append(lowVal)\n            scaleFacs.append(valRange/height)\n    \n    #Create a title.\n    if altTitle_ == None: newlistInfo = str(listInfo[0][1])\n    else: newlistInfo = altTitle_\n    titleTxtPt = rc.Geometry.Point3d(-10*legendFontSize, -7*legendFontSize, 0)\n    titleTextSrfs = lb_visualization.text2srf([newlistInfo], [titleTxtPt], legendFont, legendFontSize*1.5, legendBold)\n    titleTextSrfs = lb_preparation.flattenList(titleTextSrfs)\n    allTextPt.append(titleTxtPt)\n    allText.append(newlistInfo)\n    \n    # Group eveything together to use it for the bounding box.\n    allGeo = []\n    allGeo.extend(chartAxes)\n    allGeo.extend(axesTextSrf)\n    \n    #Calculate a bounding box around everything that will help place the legend ad title.\n    lb_visualization.calculateBB(allGeo, True)\n    \n    # Get the graph colors\n    colors = lb_visualization.gradientColor(range(len(separatedLists)), 0, len(separatedLists)-1, customColors)\n    \n    #Create a legend for the data types.\n    if legendBasePoint == None:\n        basePt = rc.Geometry.Point3d(lb_visualization.BoundingBoxPar[0].X+(legendFontSize*2), lb_visualization.BoundingBoxPar[0].Y, lb_visualization.BoundingBoxPar[0].Z)\n    else: basePt = legendBasePoint\n    BBYlength = lb_visualization.BoundingBoxPar[2]\n    legendHeight = legendWidth = (BBYlength/10) * legendScale\n    \n    def legend(basePt, legendHeight, legendWidth, numOfSeg):\n        basePt = rc.Geometry.Point3d.Add(basePt, rc.Geometry.Vector3f(legendWidth, 0, 0))\n        numPt = int(4 + 2 * (numOfSeg - 1))\n        # make the point list\n        ptList = []\n        for pt in range(numPt):\n            point = rc.Geometry.Point3d(basePt[0] + (pt%2) * legendWidth, basePt[1] + int(pt/2) * legendHeight, basePt[2])\n            ptList.append(point)\n        \n        meshVertices = ptList; textPt = []\n        legendSrf = rc.Geometry.Mesh()\n        for segNum in  range(numOfSeg):\n            #Generate the legend mesh for the _inputdata\n            mesh = rc.Geometry.Mesh()\n            mesh.Vertices.Add(meshVertices[segNum * 2]) #0\n            mesh.Vertices.Add(meshVertices[segNum * 2 + 1]) #1\n            mesh.Vertices.Add(meshVertices[segNum * 2 + 2]) #2\n            mesh.Vertices.Add(meshVertices[segNum * 2 + 3]) #3\n            mesh.Faces.AddFace(0, 1, 3, 2)\n            legendSrf.Append(mesh)\n            # Text Points\n            txtPt = meshVertices[segNum * 2 + 1]\n            textPt.append(rc.Geometry.Point3d(txtPt.X+(legendFontSize), txtPt.Y+(legendFontSize/0.5), txtPt.Z))\n        \n        return legendSrf, textPt\n    \n    #Make Legend Text\n    legendSrf, textPt = legend(basePt, legendHeight, legendWidth, len(separatedLists))\n    dataTypeListFlat = []\n    for lst in dataTypeList: dataTypeListFlat.extend(lst)\n    \n    legendTextSrfs = lb_visualization.text2srf(dataTypeListFlat, textPt, legendFont, legendFontSize, legendBold)\n    allTextPt.extend(textPt)\n    allText.extend(dataTypeListFlat)\n    #Create legend.\n    legend = []\n    #color legend surfaces\n    legendSrf = lb_visualization.colorMesh(colors, legendSrf)\n    legend.append(legendSrf)\n    fullLegTxt = lb_preparation.flattenList(legendTextSrfs)   \n    legend.extend(fullLegTxt) \n    \n    # set the width to be useful for the plotted data.\n    dataWidth = width + (xS * 0.1)\n    \n    return chartAxes, textSrfs, titleTextSrfs, titleTxtPt, legend, basePt, dataList, dataWidth, width, startVals, scaleFacs, colors, stackIndices, negativeTrigger, allText, allTextPt, legendFontSize, legendFont, decimalPlaces\n\n\ndef plotData(dataLists, startVals, scaleFacs, dataWidth, width, colors, stackIndices, yS, chartType):\n    # make lists to collect everything.\n    dataMeshes = []\n    dataCurves = []\n    crvColors = []\n    stackPositions = []\n    \n    # create the first curve.\n    bottomLine = rc.Geometry.LineCurve(rc.Geometry.Point3d.Origin, rc.Geometry.Point3d(width,0,0))\n    bottomLines = []\n    \n    # plot the data in each list.\n    for dataCount, dataList in enumerate(dataLists):\n        pLinePts = []\n        interval = dataWidth / len(dataList)\n        stackPositions.append([])\n        \n        for count, val in enumerate(dataList):\n            # generate the polyline points for each day.\n            yPos = (val - startVals[dataCount]) / scaleFacs[dataCount]\n            \n            if stackIndices[dataCount] != -1:\n                #for c in stackIndices[dataCount]:\n                yPos = yPos + stackPositions[stackIndices[dataCount][-1]][count]\n            stackPositions[dataCount].append(yPos)\n            point = rc.Geometry.Point3d(count * interval, yPos, 0)\n            pLinePts.append(point)\n        \n        # create the Pline.\n        pLine = rc.Geometry.PolylineCurve(pLinePts)\n        dataCurves.append(pLine)\n        \n        if chartType == 2:\n            # find the bottom line\n            bottomLines.append(pLine)\n            if stackIndices[dataCount] == -1:\n                theBottom = bottomLine\n            else:\n                theBottom = bottomLines[stackIndices[dataCount][-1]]\n            \n            # make a list of curves surrounding the mesh\n            leftSideLine = rc.Geometry.LineCurve(theBottom.PointAtStart, pLine.PointAtStart)\n            rightSideLine = rc.Geometry.LineCurve(theBottom.PointAtEnd, pLine.PointAtEnd)\n            crvsToJoin = [theBottom, rightSideLine, pLine, leftSideLine]\n            \n            # create the joined curve\n            joinedLine = rc.Geometry.PolylineCurve.JoinCurves(crvsToJoin)[0]\n            joinedBrep = rc.Geometry.Brep.CreatePlanarBreps(joinedLine)\n            \n            # create the mesh from the curve\n            joinedMesh = rc.Geometry.Mesh()\n            if joinedBrep is not None:\n                for br in joinedBrep:\n                    mesh = rc.Geometry.Mesh.CreateFromBrep(br)[0]\n                    joinedMesh.Append(mesh)\n                joinedMesh.VertexColors.CreateMonotoneMesh(colors[dataCount])\n                dataMeshes.append(joinedMesh)\n            else:\n                dataMeshes.append(None)\n    \n    return dataMeshes, dataCurves\n\ndef moveGeo(graphAxes, graphLabels, title, titleBasePt, legend, legendBasePt, dataMesh, dataCurves, allTextPt):\n    moveTransform = rc.Geometry.Transform.Translation(_basePoint_.X, _basePoint_.Y, _basePoint_.Z)\n    \n    for geo in graphAxes:\n        geo.Transform(moveTransform)\n    for geo in graphLabels:\n        geo.Transform(moveTransform)\n    for geo in legend:\n        geo.Transform(moveTransform)\n    for geo in title:\n        geo.Transform(moveTransform)\n    legendBasePt.Transform(moveTransform)\n    for geo in dataMesh:\n        geo.Transform(moveTransform)\n    for geo in dataCurves:\n        geo.Transform(moveTransform)\n    for pt in allTextPt:\n        pt.Transform(moveTransform)\n\ndef bakeGeo(dataMesh, dataCurves):\n    #Make a single mesh for all data.\n    finalJoinedMesh = rc.Geometry.Mesh()\n    for mesh in dataMesh:\n        finalJoinedMesh.Append(mesh)\n    #Make a single list of curves for all data.\n    allDataCurves = []\n    for crv in dataCurves:\n        allDataCurves.append(crv)\n    studyLayerName = 'LINE_CHARTS'\n    # check the study type\n    try:\n        if 'key:location/dataType/units/frequency/startsAt/endsAt' in _inputData[0]: placeName = _inputData[1]\n        else: placeName = 'alternateLayerName'\n    except: placeName = 'alternateLayerName'\n    newLayerIndex, l = lb_visualization.setupLayers(None, 'LADYBUG', placeName, studyLayerName, False, False, 0, 0)\n    if bakeIt_ == 1: lb_visualization.bakeObjects(newLayerIndex, finalJoinedMesh, legend[-1], allText, allTextPt, textSize, legendFont, graphAxes+allDataCurves, decimalPlaces, 2)\n    else: lb_visualization.bakeObjects(newLayerIndex, finalJoinedMesh, legend[-1], allText, allTextPt, textSize, legendFont, graphAxes+allDataCurves, decimalPlaces, 2, False)\n\n\n#If Ladybug is not flying or is an older version, give a warning.\ninitCheck = True\n\n#Ladybug check.\nw = gh.GH_RuntimeMessageLevel.Warning\nif not sc.sticky.has_key('ladybug_release') == True:\n    initCheck = False\n    print \"You should first let Ladybug fly...\"\n    ghenv.Component.AddRuntimeMessage(w, \"You should first let Ladybug fly...\")\nelse:\n    try:\n        if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): initCheck = False\n        if sc.sticky['ladybug_release'].isInputMissing(ghenv.Component): initCheck = False\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n        lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\n        lb_comfortModels = sc.sticky[\"ladybug_ComfortModels\"]()\n    except:\n        initCheck = False\n        warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n        \"Use updateLadybug component to update userObjects.\\n\" + \\\n        \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n        \"into canvas and try again.\"\n        ghenv.Component.AddRuntimeMessage(w, warning)\n\n\nif initCheck == True:\n    checkData, separatedLists, listInfo, chartType, xS, yS, legendPs = checkTheInputs(lb_preparation, lb_visualization, lb_comfortModels)\n    if checkData == True:\n        # make the chart curves.\n        graphAxes, graphLabels, title, titleBasePt, legend, legendBasePt, dataList, dataWidth, xWidth, startVals, scaleFacs, dataCrvColors, stackIndices, negativeTrigger, allText, allTextPt, textSize, legendFont, decimalPlaces = makeChartCrvs(separatedLists, listInfo, chartType, xS, yS, legendPs, lb_preparation, lb_visualization)\n        \n        # plot the data on the chart.\n        dataMesh, dataCurves = plotData(dataList, startVals, scaleFacs, dataWidth, xWidth, dataCrvColors, stackIndices, yS, chartType)\n        \n        # move the geometry if the basepoint is not the origin.\n        if _basePoint_ != None and _basePoint_ != rc.Geometry.Point3d.Origin:\n            moveGeo(graphAxes, graphLabels, title, titleBasePt, legend, legendBasePt, dataMesh, dataCurves, allTextPt)\n        \n        # bake geometry if need be.\n        if bakeIt_ == True:\n            bakeGeo(dataMesh, dataCurves)\n\nghenv.Component.Params.Output[7].Hidden = True\nghenv.Component.Params.Output[9].Hidden = True",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}