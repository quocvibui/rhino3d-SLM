{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/src/timber_framing_generator/sheathing/sheathing_geometry.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "src/timber_framing_generator/sheathing/sheathing_geometry.py",
  "instruction": "Sheathing panel geometry creation.",
  "code": "# File: src/timber_framing_generator/sheathing/sheathing_geometry.py\n\"\"\"\nSheathing panel geometry creation.\n\nConverts sheathing panel data (UVW coordinates) to 3D Brep geometry\nwith cutouts for openings. Uses RhinoCommonFactory for Grasshopper-compatible\ngeometry output.\n\nUsage:\n    from src.timber_framing_generator.sheathing.sheathing_geometry import (\n        create_sheathing_breps,\n        SheathingPanelGeometry\n    )\n\n    geometries = create_sheathing_breps(\n        sheathing_data=parsed_sheathing_json,\n        wall_data=parsed_wall_json,\n        factory=get_factory()\n    )\n\"\"\"\n\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Tuple, Optional, Any\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n# Small outward nudge applied to layer W offsets so sheathing faces never\n# sit co-planar with framing faces.  Prevents Z-fighting and AABB overlap\n# artifacts in the Rhino viewport.  ~0.012 in ≈ 0.3 mm — invisible in practice.\nSHEATHING_GAP: float = 0.001\n\n\n@dataclass\nclass SheathingPanelGeometry:\n    \"\"\"\n    Geometry data for a sheathing panel.\n\n    Attributes:\n        panel_id: Unique panel identifier\n        wall_id: Parent wall ID\n        face: Wall face (\"exterior\" or \"interior\")\n        brep: RhinoCommon Brep geometry\n        area_gross: Gross panel area (sq ft)\n        area_net: Net area after cutouts (sq ft)\n        has_cutouts: Whether panel has opening cutouts\n    \"\"\"\n    panel_id: str\n    wall_id: str\n    face: str\n    brep: Any  # RhinoCommon Brep\n    area_gross: float\n    area_net: float\n    has_cutouts: bool\n\n\ndef uvw_to_world(\n    u: float,\n    v: float,\n    w: float,\n    base_plane: Dict[str, Any]\n) -> Tuple[float, float, float]:\n    \"\"\"\n    Transform UVW coordinates to world XYZ.\n\n    The wall coordinate system:\n    - U: Along wall length (wall's XAxis direction)\n    - V: Vertical direction (world Z, up)\n    - W: Through wall thickness (wall's ZAxis/normal direction)\n\n    Args:\n        u: Position along wall length (feet)\n        v: Vertical position from wall base (feet)\n        w: Offset through wall thickness (feet)\n        base_plane: Wall base plane dictionary with origin, x_axis, y_axis, z_axis\n\n    Returns:\n        (x, y, z) world coordinates\n    \"\"\"\n    origin = base_plane[\"origin\"]\n    x_axis = base_plane[\"x_axis\"]\n    y_axis = base_plane[\"y_axis\"]\n    z_axis = base_plane[\"z_axis\"]\n\n    # Transform: world = origin + u*X + v*Y + w*Z\n    x = origin[\"x\"] + x_axis[\"x\"] * u + y_axis[\"x\"] * v + z_axis[\"x\"] * w\n    y = origin[\"y\"] + x_axis[\"y\"] * u + y_axis[\"y\"] * v + z_axis[\"y\"] * w\n    z = origin[\"z\"] + x_axis[\"z\"] * u + y_axis[\"z\"] * v + z_axis[\"z\"] * w\n\n    return (x, y, z)\n\n\ndef get_extrusion_vector(\n    face: str,\n    base_plane: Dict[str, Any],\n    thickness: float\n) -> Tuple[float, float, float]:\n    \"\"\"\n    Get the extrusion vector for panel thickness.\n\n    Args:\n        face: \"exterior\" or \"interior\"\n        base_plane: Wall base plane dictionary\n        thickness: Panel thickness in feet\n\n    Returns:\n        (dx, dy, dz) extrusion vector\n    \"\"\"\n    z_axis = base_plane[\"z_axis\"]\n\n    # Exterior: extrude outward (positive normal direction)\n    # Interior: extrude inward (negative normal direction)\n    direction = 1.0 if face == \"exterior\" else -1.0\n\n    return (\n        z_axis[\"x\"] * thickness * direction,\n        z_axis[\"y\"] * thickness * direction,\n        z_axis[\"z\"] * thickness * direction\n    )\n\n\ndef calculate_w_offset(\n    face: str,\n    wall_thickness: float,\n    panel_thickness: float,\n    wall_assembly: Optional[Dict[str, Any]] = None,\n) -> float:\n    \"\"\"\n    Calculate the W offset for panel placement.\n\n    Panels are placed on the exterior or interior face of the wall,\n    offset from the wall centerline. When assembly data is available,\n    the offset is computed from the actual layer stack (core + exterior\n    or core + interior thicknesses), which is more accurate for\n    asymmetric assemblies.\n\n    Args:\n        face: \"exterior\" or \"interior\"\n        wall_thickness: Wall thickness in feet (fallback)\n        panel_thickness: Sheathing panel thickness in feet\n        wall_assembly: Optional assembly dict from wall_data. When present,\n            layer stack thicknesses are used instead of wall_thickness/2.\n\n    Returns:\n        W offset from wall centerline in feet\n    \"\"\"\n    if wall_assembly:\n        return _calculate_w_offset_from_assembly(\n            face, wall_assembly, panel_thickness\n        )\n\n    # Fallback: simple half-thickness (symmetric assumption)\n    half_wall = wall_thickness / 2.0\n\n    if face == \"exterior\":\n        # Exterior face: panel core-facing surface at wall outer face\n        return half_wall\n    else:\n        # Interior face: panel core-facing surface at wall inner face\n        # (mirrors exterior: extrusion in -Z places panel against wall)\n        return -half_wall\n\n\ndef _calculate_w_offset_from_assembly(\n    face: str,\n    wall_assembly: Dict[str, Any],\n    panel_thickness: float,\n) -> float:\n    \"\"\"\n    Calculate W offset from assembly layer stack.\n\n    Uses the actual cumulative layer thicknesses from the wall assembly\n    instead of dividing total thickness by 2. This produces correct\n    positioning for asymmetric assemblies where exterior and interior\n    layer thicknesses differ.\n\n    The centerline (W=0) is at the center of the structural core.\n\n    Args:\n        face: \"exterior\" or \"interior\"\n        wall_assembly: Assembly dictionary with \"layers\" list.\n        panel_thickness: Sheathing panel thickness in feet.\n\n    Returns:\n        W offset from wall centerline in feet.\n    \"\"\"\n    try:\n        from src.timber_framing_generator.wall_data.assembly_extractor import (\n            assembly_dict_to_def,\n        )\n        assembly_def = assembly_dict_to_def(wall_assembly)\n    except Exception:\n        # If conversion fails, fall back to total thickness\n        total = sum(l.get(\"thickness\", 0) for l in wall_assembly.get(\"layers\", []))\n        half = total / 2.0\n        if face == \"exterior\":\n            return half\n        return -half\n\n    core_half = assembly_def.core_thickness / 2.0\n\n    if face == \"exterior\":\n        # Panel starts at the wall's exterior face\n        # = core center + half core + all exterior layers\n        return core_half + assembly_def.exterior_thickness\n    else:\n        # Panel core-facing surface at wall's interior face\n        # (mirrors exterior: extrusion in -Z places panel against wall)\n        return -(core_half + assembly_def.interior_thickness)\n\n\ndef calculate_layer_w_offsets(\n    wall_assembly: Dict[str, Any],\n    framing_depth: Optional[float] = None,\n) -> Dict[str, float]:\n    \"\"\"\n    Compute W offset for each layer's core-facing surface.\n\n    Returns a dictionary mapping layer name to its W position where\n    the layer starts (the face closest to the structural core).\n\n    When ``framing_depth`` is provided, the starting offset is\n    ``max(core_half, framing_depth / 2)`` so that sheathing layers\n    never start inside the framing zone even when the assembly\n    catalog core thickness differs from the actual framing profile.\n\n    Args:\n        wall_assembly: Assembly dictionary with \"layers\" list.\n        framing_depth: Optional actual framing profile depth in feet\n            (e.g., 3.5/12 for 2x4). When provided, layers are pushed\n            outward to at least ``framing_depth / 2`` from centerline.\n\n    Returns:\n        Dict mapping composite key ``\"name|side\"`` to W offset (feet\n        from centerline).  Using composite keys prevents collisions\n        when two layers share the same name on different sides (e.g.,\n        \"Gypsum Board\" on both exterior and interior).\n    \"\"\"\n    from src.timber_framing_generator.wall_data.assembly_extractor import (\n        assembly_dict_to_def,\n    )\n    from src.timber_framing_generator.wall_junctions.junction_types import LayerSide\n\n    assembly_def = assembly_dict_to_def(wall_assembly)\n    offsets: Dict[str, float] = {}\n    core_half = assembly_def.core_thickness / 2.0\n\n    # Use actual framing depth when it exceeds assembly core\n    effective_half = core_half\n    if framing_depth is not None:\n        effective_half = max(core_half, framing_depth / 2.0)\n\n    # Tiny outward nudge so sheathing faces never sit co-planar with\n    # framing faces (prevents Z-fighting and AABB overlap artifacts).\n    effective_half += SHEATHING_GAP\n\n    # Exterior layers: stack outward from effective exterior face\n    ext_layers = assembly_def.get_layers_by_side(LayerSide.EXTERIOR)\n    cumulative = effective_half\n    for layer in reversed(ext_layers):  # closest to core first\n        offsets[f\"{layer.name}|{layer.side.value}\"] = cumulative\n        cumulative += layer.thickness\n\n    # Interior layers: stack inward from effective interior face\n    # Store core-facing surface (matching exterior convention)\n    int_layers = assembly_def.get_layers_by_side(LayerSide.INTERIOR)\n    cumulative = -effective_half\n    for layer in int_layers:  # order from assembly (closest to core first)\n        offsets[f\"{layer.name}|{layer.side.value}\"] = cumulative  # Core-facing surface\n        cumulative -= layer.thickness\n\n    # Core layer\n    core_layers = assembly_def.get_layers_by_side(LayerSide.CORE)\n    for layer in core_layers:\n        offsets[f\"{layer.name}|{layer.side.value}\"] = -effective_half\n\n    return offsets\n\n\ndef create_panel_brep(\n    panel_data: Dict[str, Any],\n    base_plane: Dict[str, Any],\n    wall_thickness: float,\n    factory: Any,\n    wall_assembly: Optional[Dict[str, Any]] = None,\n) -> Optional[Any]:\n    \"\"\"\n    Create a Brep for a sheathing panel.\n\n    Args:\n        panel_data: Sheathing panel dictionary from sheathing_json\n        base_plane: Wall's base plane (origin, x_axis, y_axis, z_axis)\n        wall_thickness: Wall thickness in feet\n        factory: RhinoCommonFactory instance\n        wall_assembly: Optional assembly dict for layer-aware W offset\n\n    Returns:\n        RhinoCommon Brep or None if creation fails\n    \"\"\"\n    # Extract panel bounds (UVW coordinates, in feet)\n    u_start = panel_data[\"u_start\"]\n    u_end = panel_data[\"u_end\"]\n    v_start = panel_data[\"v_start\"]\n    v_end = panel_data[\"v_end\"]\n\n    # Panel thickness (convert inches to feet)\n    thickness_ft = panel_data[\"thickness_inches\"] / 12.0\n\n    # Calculate W offset for panel placement.\n    # Per-layer offset (from multi-layer generator) takes priority over\n    # face-level offset, since it correctly positions each layer in the\n    # assembly stack (e.g., siding further out than OSB).\n    face = panel_data.get(\"face\", \"exterior\")\n    layer_w_offset = panel_data.get(\"layer_w_offset\")\n    if layer_w_offset is not None:\n        w_offset = layer_w_offset\n        logger.debug(\n            \"Panel %s: using layer_w_offset=%.4f\",\n            panel_data.get(\"id\", \"?\"), w_offset,\n        )\n    else:\n        w_offset = calculate_w_offset(face, wall_thickness, thickness_ft, wall_assembly)\n        logger.debug(\n            \"Panel %s: FALLBACK w_offset=%.4f (face=%s, wall_t=%.4f, has_assembly=%s)\",\n            panel_data.get(\"id\", \"?\"), w_offset, face, wall_thickness,\n            wall_assembly is not None,\n        )\n\n    # Create panel corners in world coordinates\n    # Order: bottom-left, bottom-right, top-right, top-left (counter-clockwise)\n    corners = [\n        uvw_to_world(u_start, v_start, w_offset, base_plane),  # BL\n        uvw_to_world(u_end, v_start, w_offset, base_plane),    # BR\n        uvw_to_world(u_end, v_end, w_offset, base_plane),      # TR\n        uvw_to_world(u_start, v_end, w_offset, base_plane),    # TL\n    ]\n\n    # Get extrusion vector (panel thickness direction)\n    extrusion_vector = get_extrusion_vector(face, base_plane, thickness_ft)\n\n    # Create box from corners and extrusion\n    panel_brep = factory.create_box_from_corners_and_thickness(\n        corners, extrusion_vector\n    )\n\n    if panel_brep is None:\n        return None\n\n    # Subtract cutouts if any\n    cutouts = panel_data.get(\"cutouts\", [])\n    if cutouts:\n        panel_brep = subtract_cutouts(\n            panel_brep, cutouts, base_plane,\n            w_offset, thickness_ft, face, factory\n        )\n\n    return panel_brep\n\n\ndef subtract_cutouts(\n    panel_brep: Any,\n    cutouts: List[Dict[str, Any]],\n    base_plane: Dict[str, Any],\n    w_offset: float,\n    panel_thickness: float,\n    face: str,\n    factory: Any\n) -> Any:\n    \"\"\"\n    Subtract cutout regions from panel brep.\n\n    Args:\n        panel_brep: Base panel Brep\n        cutouts: List of cutout dictionaries\n        base_plane: Wall's base plane\n        w_offset: W offset of panel face\n        panel_thickness: Panel thickness in feet\n        face: \"exterior\" or \"interior\"\n        factory: RhinoCommonFactory instance\n\n    Returns:\n        Panel Brep with cutouts subtracted\n    \"\"\"\n    cutout_breps = []\n\n    for cutout in cutouts:\n        cutout_brep = create_cutout_brep(\n            cutout, base_plane, w_offset, panel_thickness, face, factory\n        )\n        if cutout_brep is not None:\n            cutout_breps.append(cutout_brep)\n\n    if cutout_breps:\n        return factory.boolean_difference_multiple(panel_brep, cutout_breps)\n\n    return panel_brep\n\n\ndef create_cutout_brep(\n    cutout: Dict[str, Any],\n    base_plane: Dict[str, Any],\n    w_offset: float,\n    panel_thickness: float,\n    face: str,\n    factory: Any\n) -> Optional[Any]:\n    \"\"\"\n    Create a Brep for a cutout region.\n\n    The cutout extends slightly beyond the panel thickness to ensure\n    a clean boolean difference.\n\n    Args:\n        cutout: Cutout dictionary with u_start, u_end, v_start, v_end\n        base_plane: Wall's base plane\n        w_offset: W offset of panel face\n        panel_thickness: Panel thickness in feet\n        face: \"exterior\" or \"interior\"\n        factory: RhinoCommonFactory instance\n\n    Returns:\n        RhinoCommon Brep for cutout or None\n    \"\"\"\n    u_start = cutout[\"u_start\"]\n    u_end = cutout[\"u_end\"]\n    v_start = cutout[\"v_start\"]\n    v_end = cutout[\"v_end\"]\n\n    # Validate dimensions\n    if u_end <= u_start or v_end <= v_start:\n        return None\n\n    # Extend cutout slightly beyond panel surface for clean boolean\n    tolerance = 0.01  # ~1/8 inch\n    w_start = w_offset - tolerance\n    w_end = w_offset + panel_thickness + tolerance\n    if face == \"interior\":\n        w_start = w_offset - panel_thickness - tolerance\n        w_end = w_offset + tolerance\n\n    # Create cutout corners\n    corners = [\n        uvw_to_world(u_start, v_start, w_start, base_plane),\n        uvw_to_world(u_end, v_start, w_start, base_plane),\n        uvw_to_world(u_end, v_end, w_start, base_plane),\n        uvw_to_world(u_start, v_end, w_start, base_plane),\n    ]\n\n    # Extrusion vector through panel: always from w_start toward w_end (+Z).\n    # Corners are placed at w_start (the more-negative W boundary), so the\n    # extrusion must go in the +Z direction to reach w_end and fully\n    # encompass the panel for both exterior and interior faces.\n    extrusion_depth = abs(w_end - w_start)\n    z_axis = base_plane[\"z_axis\"]\n    extrusion_vector = (\n        z_axis[\"x\"] * extrusion_depth,\n        z_axis[\"y\"] * extrusion_depth,\n        z_axis[\"z\"] * extrusion_depth,\n    )\n\n    return factory.create_box_from_corners_and_thickness(corners, extrusion_vector)\n\n\ndef create_sheathing_breps(\n    sheathing_data: Dict[str, Any],\n    wall_data: Dict[str, Any],\n    factory: Any\n) -> List[SheathingPanelGeometry]:\n    \"\"\"\n    Create Brep geometry for all sheathing panels.\n\n    Args:\n        sheathing_data: Parsed sheathing JSON for a single wall\n        wall_data: Parsed wall JSON with base_plane and thickness\n        factory: RhinoCommonFactory instance\n\n    Returns:\n        List of SheathingPanelGeometry objects\n    \"\"\"\n    results = []\n\n    # Get wall properties\n    base_plane = wall_data.get(\"base_plane\", {})\n    wall_thickness = wall_data.get(\"thickness\", wall_data.get(\"wall_thickness\", 0.5))\n\n    # Handle different thickness keys (may be in inches or feet)\n    if wall_thickness > 2.0:  # Likely in inches\n        wall_thickness = wall_thickness / 12.0\n\n    # Get assembly data for layer-aware W offset (Phase 3)\n    wall_assembly = wall_data.get(\"wall_assembly\")\n\n    panels = sheathing_data.get(\"sheathing_panels\", [])\n\n    for panel_data in panels:\n        brep = create_panel_brep(\n            panel_data, base_plane, wall_thickness, factory, wall_assembly\n        )\n\n        if brep is not None:\n            geometry = SheathingPanelGeometry(\n                panel_id=panel_data.get(\"id\", \"unknown\"),\n                wall_id=panel_data.get(\"wall_id\", \"unknown\"),\n                face=panel_data.get(\"face\", \"exterior\"),\n                brep=brep,\n                area_gross=panel_data.get(\"area_gross_sqft\", 0),\n                area_net=panel_data.get(\"area_net_sqft\", 0),\n                has_cutouts=len(panel_data.get(\"cutouts\", [])) > 0\n            )\n            results.append(geometry)\n\n    return results\n\n\ndef create_sheathing_breps_batch(\n    sheathing_results: List[Dict[str, Any]],\n    walls_data: List[Dict[str, Any]],\n    factory: Any\n) -> Dict[str, List[SheathingPanelGeometry]]:\n    \"\"\"\n    Create Brep geometry for sheathing panels across multiple walls.\n\n    Args:\n        sheathing_results: List of sheathing JSON results (one per wall)\n        walls_data: List of wall JSON data (one per wall)\n        factory: RhinoCommonFactory instance\n\n    Returns:\n        Dictionary mapping wall_id to list of SheathingPanelGeometry\n    \"\"\"\n    # Index walls by ID\n    walls_by_id = {}\n    for wall in walls_data:\n        wall_id = str(wall.get(\"wall_id\", wall.get(\"id\", \"unknown\")))\n        walls_by_id[wall_id] = wall\n\n    results = {}\n\n    for sheathing_data in sheathing_results:\n        wall_id = str(sheathing_data.get(\"wall_id\", \"unknown\"))\n        wall_data = walls_by_id.get(wall_id, {})\n\n        # Provide default base plane if not present\n        if \"base_plane\" not in wall_data:\n            wall_data[\"base_plane\"] = _create_default_base_plane()\n\n        geometries = create_sheathing_breps(sheathing_data, wall_data, factory)\n\n        if wall_id not in results:\n            results[wall_id] = []\n        results[wall_id].extend(geometries)\n\n    return results\n\n\ndef _create_default_base_plane() -> Dict[str, Any]:\n    \"\"\"Create a default world-aligned base plane.\"\"\"\n    return {\n        \"origin\": {\"x\": 0.0, \"y\": 0.0, \"z\": 0.0},\n        \"x_axis\": {\"x\": 1.0, \"y\": 0.0, \"z\": 0.0},\n        \"y_axis\": {\"x\": 0.0, \"y\": 0.0, \"z\": 1.0},  # V = World Z\n        \"z_axis\": {\"x\": 0.0, \"y\": 1.0, \"z\": 0.0},  # W = World Y (into wall)\n    }\n",
  "language": "python",
  "imports": [
    "RhinoCommon"
  ],
  "has_docstring": true
}