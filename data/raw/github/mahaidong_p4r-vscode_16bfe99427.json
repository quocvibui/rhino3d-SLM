{
  "source_url": "https://github.com/mahaidong/p4r-vscode/blob/f75b8596c881faf1d5c2d0b7159ab2ec228acc4c/lib/ghpythonlib/components.py",
  "repo": "mahaidong/p4r-vscode",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "lib/ghpythonlib/components.py",
  "instruction": "Components",
  "code": "import clr\nclr.AddReference('Grasshopper, Culture=neutral, PublicKeyToken=dda4f5ec2cd80803')\n\nimport Grasshopper as gh\nimport os\n\nfrom Rhino.NodeInCode import Components as ghc\nimport System\nfrom System.Collections import IEnumerable, IEnumerator\n\n\nclass namedtupleiterator(IEnumerator):\n    def __init__(self, namedtuple):\n        self.namedtuple = namedtuple\n        self.position = -1\n\n    def get_Current(self):\n        if self.position == -1: return None\n        if self.position >= len(self.namedtuple): return None\n        return self.namedtuple[self.position]\n\n    def MoveNext(self):\n        self.position += 1\n        return self.position < len(self.namedtuple)\n\n    def Reset(self):\n        self.position = -1\n\nclass __namedtuple(IEnumerable):\n    def __init__(self, attributes, values=None):\n        if isinstance(attributes, dict):\n            new_attributes = [key for key in attributes]\n            values = [attributes[key] for key in new_attributes]\n            attributes = new_attributes\n\n        self.myattributes = attributes\n        self.myvalues = values\n\n    def __getattr__(self, name):\n        return self.__find_by_name(name)\n\n    def __getitem__(self, key):\n        if isinstance(key, basestring):\n            return self.__find_by_name(name)\n        else:\n            return self.myvalues[key]\n\n    def __len__(self):\n        return len(self.myvalues)\n\n\n    def __repr__(self):\n        return 'namedtuple(' + self.__str__() + ')'\n\n    def __str__(self):\n        return (\n            repr(dict(\n                (self.myattributes[i],self.myvalues[i])\n                    for i in xrange(len(self.myattributes))))\n                 )\n\n    def __find_by_name(self, name):\n        try:\n            index = System.Array[str].IndexOf(self.myattributes, name)\n        except System.Collections.Generic.KeyNotFoundException as ex:\n            raise ValueError(\n                str.format(\n                'namedtuple does not have an attribute for \\'{}\\'. Available: {}',\n                name, repr(list(self.myattributes)))\n                )\n        return self.myvalues[index]\n\n    def __iter__(self):\n       for a in self.myattributes:\n          yield a\n\n    def __contains__(self, item):\n        return item in self.myattributes\n\n    def __dir__(self):\n        return sorted(set((dir(type(self)) + list(self.__dict__) +\n                  self.myattributes)))\n\n    def GetEnumerator(self):\n        return namedtupleiterator(self)\n\n\nclass namespace_object(object):\n    pass\n\ndef __make_function__(info, inputnames, outputnames, keep_tree):\n    def component_function(*args, **kwargs):\n        result = None\n        warnings = None\n        final_args = None\n        if kwargs:\n            final_args = [System.Reflection.Missing.Value] * len(inputnames)\n            for kwarg in kwargs:\n                if kwarg in inputnames:\n                    index = inputnames[kwarg]\n                    final_args[index] = kwargs[kwarg]\n                else:\n                    raise ValueError(\n                        str.Format(\"{0} argument is not a valid parameter of the function. Valid parameters are: {1}.\",\n                                   kwarg, repr([x.lower().replace(\" \", \"_\") for x in sorted(inputnames.keys())]) )\n                    )\n            if (len(args) + len(kwargs)) > len(inputnames):\n                raise ValueError(str.Format(\"Expected at most {0} aguments, but got {1}.\", len(inputnames), len(args)))\n            for i,arg in enumerate(args): final_args[i] = arg\n            result, warnings = info.Evaluate(final_args, keep_tree)\n        elif args:\n            result, warnings = info.Evaluate(args, keep_tree)\n        else:\n            result, warnings = info.Evaluate(None, keep_tree)\n        if result:\n            if not keep_tree:\n                for i, result_item in enumerate(result):\n                    if result_item == None:\n                        continue\n                    elif len(result_item)<1:\n                        result[i] = None\n                    elif len(result_item)==1:\n                        result[i] = result_item[0]\n            if len(result) == 1: result = result[0]\n            elif len(result) > 1: result = __namedtuple(outputnames, result)\n        if warnings:\n            import scriptcontext as sc\n            do_this = None\n            if hasattr(sc.doc, 'Component') and sc.doc.Component != None:\n                do_this = sc.doc.Component.AddMessageForWarnings\n            for warning in warnings:\n                if do_this: do_this(warning)\n                print(\"Warning: \" + warning)\n        return result\n    return component_function\n\ndef __add_to_module(f, module, name, description):\n    setattr(module, name, f)\n    a = module.__dict__[name]\n    a.__name__ = name\n    a.__doc__ = description\n    return f\n\ndef __build_module():\n    import Rhino\n    def function_description(info, inputnames, outputnames):\n        rc = ['', info.Description, \"Input:\"]\n        for i, inputname in enumerate(inputnames):\n            if info.InputsOptional[i]:\n                s = \"\\t{0} (in, optional) [{1}] - {2}\"\n            else:\n                s = \"\\t{0} [{1}] - {2}\"\n            rc.append(s.format(inputname, info.InputTypeNames[i], info.InputDescriptions[i]))\n        if outputnames.Count == 1:\n            rc.append(\"Returns: [{0}] - {1}\".format(info.OutputTypeNames[0], info.OutputDescriptions[0]))\n        elif outputnames.Count > 1:\n            rc.append(\"Returns:\")\n            for i, out in enumerate(outputnames):\n                s = \"\\t{0} [{1}] - {2}\"\n                rc.append(s.format(out, info.OutputTypeNames[i], info.OutputDescriptions[i]))\n        return '\\n'.join(rc)\n\n    import sys, types, re\n    code_name = 'ghpythonlib.components'\n    core_module = sys.modules[code_name]\n    translate_from = u\"|+-*\\u2070\\u00B9\\u00B2\\u00B3\\u2074\\u2075\\u2076\\u2077\\u2078\\u2079\"\n    translate_to = \"X__x0123456789\"\n    transl = dict(zip(translate_from, translate_to))\n\n    tree_module = __add_to_module(\n        namespace_object(), core_module, \"trees\",\n        \"Functions in this module accept and always return datatrees.\")\n\n    for info_names in ghc.NodeInCodeFunctions.GetDynamicMemberNames():\n        info = ghc.NodeInCodeFunctions[info_names]\n        try:\n            name = info.Name\n            name = re.sub(\"[^a-zA-Z0-9]\", lambda match: transl[match.group()] if (match.group() in transl) else '', name)\n            if len(name) == 0 or not name[0].isalpha(): name = 'x' + name\n            inputnames = info.InputNames\n            inputnames_dict = dict((el,i) for i, el in enumerate(inputnames))\n            outputnames = info.OutputNames\n            function_flatten = __make_function__(info, inputnames_dict, outputnames, False)\n            function_tree = __make_function__(info, inputnames_dict, outputnames, True)\n            m = core_module\n            tm = tree_module\n            if info.Namespace:\n                module_name = info.Namespace.replace(\" \", \"\")\n                if module_name in core_module.__dict__:\n                    m = core_module.__dict__[module_name]\n                    tm = tree_module.__dict__[module_name]\n                else:\n                    description=\"Third-party add-on: \" + info.Namespace\n                    m =__add_to_module(\n                        namespace_object(), core_module, module_name, description)\n                    tm =__add_to_module(\n                        namespace_object(), tree_module, module_name, description + \". With trees\")\n            description = function_description(info, inputnames, outputnames)\n            __add_to_module(function_flatten, m, name, description)\n            __add_to_module(function_tree, tm, name, description)\n        except Exception as err:\n            Rhino.RhinoApp.WriteLine(str(err))\n            Rhino.Runtime.HostUtils.ExceptionReport(\"ghpythonlib.components.py|\" + info.Name, err.clsException)\n\n\n__build_module()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": false
}